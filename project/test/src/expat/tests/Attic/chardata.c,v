head	1.1;
access;
symbols
	gdb-csl-symbian-6_4_50_20060226-12:1.1.4.1
	gdb-csl-symbian-6_4_50_20060226-11:1.1.4.1
	gdb-csl-sourcerygxx-4_1-17:1.1.4.1
	gdb-csl-20060226-branch-local-2:1.1.4.1
	gdb-csl-sourcerygxx-4_1-14:1.1.4.1
	gdb-csl-sourcerygxx-4_1-13:1.1.4.1
	gdb-csl-sourcerygxx-4_1-12:1.1.4.1
	gdb-csl-sourcerygxx-3_4_4-21:1.1.4.1
	gdb-csl-sourcerygxx-4_1-9:1.1.4.1
	gdb-csl-sourcerygxx-4_1-8:1.1.4.1
	gdb-csl-sourcerygxx-4_1-7:1.1.4.1
	gdb-csl-arm-2006q1-6:1.1.4.1
	gdb-csl-sourcerygxx-4_1-6:1.1.4.1
	gdb-csl-symbian-6_4_50_20060226-10:1.1.4.1
	gdb-csl-symbian-6_4_50_20060226-9:1.1.4.1
	gdb-csl-symbian-6_4_50_20060226-8:1.1.4.1
	gdb-csl-coldfire-4_1-11:1.1.4.1
	gdb-csl-sourcerygxx-3_4_4-19:1.1.4.1
	gdb-csl-coldfire-4_1-10:1.1.4.1
	gdb-csl-sourcerygxx-4_1-5:1.1.4.1
	gdb-csl-sourcerygxx-4_1-4:1.1.4.1
	gdb-csl-sourcerygxx-3_4_4-17:1.1.4.1
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.1.4.1
	gdb-csl-symbian-20060226-branch:1.1.4.1.0.2
	gdb-csl-symbian-20060226-branchpoint:1.1.4.1
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.1.4.1
	gdb-csl-20060226-branch:1.1.0.4
	gdb-csl-available-20060303-branch:1.1.0.2;
locks; strict;
comment	@ * @;
expand	@o@;


1.1
date	2006.03.03.20.17.12;	author drow;	state dead;
branches
	1.1.2.1
	1.1.4.1;
next	;

1.1.2.1
date	2006.03.03.20.17.12;	author drow;	state Exp;
branches;
next	;

1.1.4.1
date	2006.04.03.00.47.36;	author drow;	state Exp;
branches;
next	;


desc
@@


1.1
log
@file chardata.c was initially added on branch gdb-csl-available-20060303-branch.
@
text
@@


1.1.4.1
log
@Merge XML and VFP support to this branch.
@
text
@a0 131
/* Copyright (c) 1998-2003 Thai Open Source Software Center Ltd
   See the file COPYING for copying permission.

   chardata.c
*/

#ifdef HAVE_EXPAT_CONFIG_H
#include <expat_config.h>
#endif
#ifdef HAVE_CHECK_H
#include <check.h>
#else
#include "minicheck.h"
#endif

#include <assert.h>
#include <stdio.h>
#include <string.h>

#include "chardata.h"


static int
xmlstrlen(const XML_Char *s)
{
    int len = 0;
    assert(s != NULL);
    while (s[len] != 0)
        ++len;
    return len;
}


void
CharData_Init(CharData *storage)
{
    assert(storage != NULL);
    storage->count = -1;
}

void
CharData_AppendString(CharData *storage, const char *s)
{
    int maxchars = sizeof(storage->data) / sizeof(storage->data[0]);
    int len;

    assert(s != NULL);
    len = strlen(s);
    if (storage->count < 0)
        storage->count = 0;
    if ((len + storage->count) > maxchars) {
        len = (maxchars - storage->count);
    }
    if (len + storage->count < sizeof(storage->data)) {
        memcpy(storage->data + storage->count, s, len);
        storage->count += len;
    }
}

void
CharData_AppendXMLChars(CharData *storage, const XML_Char *s, int len)
{
    int maxchars;

    assert(storage != NULL);
    assert(s != NULL);
    maxchars = sizeof(storage->data) / sizeof(storage->data[0]);
    if (storage->count < 0)
        storage->count = 0;
    if (len < 0)
        len = xmlstrlen(s);
    if ((len + storage->count) > maxchars) {
        len = (maxchars - storage->count);
    }
    if (len + storage->count < sizeof(storage->data)) {
        memcpy(storage->data + storage->count, s,
               len * sizeof(storage->data[0]));
        storage->count += len;
    }
}

int
CharData_CheckString(CharData *storage, const char *expected)
{
    char buffer[1280];
    int len;
    int count;

    assert(storage != NULL);
    assert(expected != NULL);
    count = (storage->count < 0) ? 0 : storage->count;
    len = strlen(expected);
    if (len != count) {
        if (sizeof(XML_Char) == 1)
            sprintf(buffer, "wrong number of data characters:"
                    " got %d, expected %d:\n%s", count, len, storage->data);
        else
            sprintf(buffer,
                    "wrong number of data characters: got %d, expected %d",
                    count, len);
        fail(buffer);
        return 0;
    }
    if (memcmp(expected, storage->data, len) != 0) {
        fail("got bad data bytes");
        return 0;
    }
    return 1;
}

int
CharData_CheckXMLChars(CharData *storage, const XML_Char *expected)
{
    char buffer[1024];
    int len = xmlstrlen(expected);
    int count;

    assert(storage != NULL);
    count = (storage->count < 0) ? 0 : storage->count;
    if (len != count) {
        sprintf(buffer, "wrong number of data characters: got %d, expected %d",
                count, len);
        fail(buffer);
        return 0;
    }
    if (memcmp(expected, storage->data, len * sizeof(storage->data[0])) != 0) {
        fail("got bad data bytes");
        return 0;
    }
    return 1;
}
@


1.1.2.1
log
@Import unmodified expat 2.0.0.
@
text
@a0 131
/* Copyright (c) 1998-2003 Thai Open Source Software Center Ltd
   See the file COPYING for copying permission.

   chardata.c
*/

#ifdef HAVE_EXPAT_CONFIG_H
#include <expat_config.h>
#endif
#ifdef HAVE_CHECK_H
#include <check.h>
#else
#include "minicheck.h"
#endif

#include <assert.h>
#include <stdio.h>
#include <string.h>

#include "chardata.h"


static int
xmlstrlen(const XML_Char *s)
{
    int len = 0;
    assert(s != NULL);
    while (s[len] != 0)
        ++len;
    return len;
}


void
CharData_Init(CharData *storage)
{
    assert(storage != NULL);
    storage->count = -1;
}

void
CharData_AppendString(CharData *storage, const char *s)
{
    int maxchars = sizeof(storage->data) / sizeof(storage->data[0]);
    int len;

    assert(s != NULL);
    len = strlen(s);
    if (storage->count < 0)
        storage->count = 0;
    if ((len + storage->count) > maxchars) {
        len = (maxchars - storage->count);
    }
    if (len + storage->count < sizeof(storage->data)) {
        memcpy(storage->data + storage->count, s, len);
        storage->count += len;
    }
}

void
CharData_AppendXMLChars(CharData *storage, const XML_Char *s, int len)
{
    int maxchars;

    assert(storage != NULL);
    assert(s != NULL);
    maxchars = sizeof(storage->data) / sizeof(storage->data[0]);
    if (storage->count < 0)
        storage->count = 0;
    if (len < 0)
        len = xmlstrlen(s);
    if ((len + storage->count) > maxchars) {
        len = (maxchars - storage->count);
    }
    if (len + storage->count < sizeof(storage->data)) {
        memcpy(storage->data + storage->count, s,
               len * sizeof(storage->data[0]));
        storage->count += len;
    }
}

int
CharData_CheckString(CharData *storage, const char *expected)
{
    char buffer[1280];
    int len;
    int count;

    assert(storage != NULL);
    assert(expected != NULL);
    count = (storage->count < 0) ? 0 : storage->count;
    len = strlen(expected);
    if (len != count) {
        if (sizeof(XML_Char) == 1)
            sprintf(buffer, "wrong number of data characters:"
                    " got %d, expected %d:\n%s", count, len, storage->data);
        else
            sprintf(buffer,
                    "wrong number of data characters: got %d, expected %d",
                    count, len);
        fail(buffer);
        return 0;
    }
    if (memcmp(expected, storage->data, len) != 0) {
        fail("got bad data bytes");
        return 0;
    }
    return 1;
}

int
CharData_CheckXMLChars(CharData *storage, const XML_Char *expected)
{
    char buffer[1024];
    int len = xmlstrlen(expected);
    int count;

    assert(storage != NULL);
    count = (storage->count < 0) ? 0 : storage->count;
    if (len != count) {
        sprintf(buffer, "wrong number of data characters: got %d, expected %d",
                count, len);
        fail(buffer);
        return 0;
    }
    if (memcmp(expected, storage->data, len * sizeof(storage->data[0])) != 0) {
        fail("got bad data bytes");
        return 0;
    }
    return 1;
}
@

