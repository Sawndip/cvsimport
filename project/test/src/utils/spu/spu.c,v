head	1.5;
access;
symbols
	gdb-csl-arm-20051020-branch:1.5.0.80
	gdb-csl-arm-20051020-branchpoint:1.5
	drow_intercu-merge-20040921:1.5
	drow_intercu-merge-20040915:1.5
	jimb-gdb_6_2-e500-branch:1.5.0.82
	jimb-gdb_6_2-e500-branchpoint:1.5
	gdb_6_2-20040730-release:1.5
	gdb_6_2-branch:1.5.0.78
	gdb_6_2-2004-07-10-gmt-branchpoint:1.5
	gdb_6_1_1-20040616-release:1.5
	gdb_6_1-2004-04-05-release:1.5
	drow_intercu-merge-20040402:1.5
	drow_intercu-merge-20040327:1.5
	ezannoni_pie-20040323-branch:1.5.0.76
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.74
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.72
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow_intercu-20040221-branch:1.5.0.70
	drow_intercu-20040221-branchpoint:1.5
	cagney_bfdfile-20040213-branch:1.5.0.68
	cagney_bfdfile-20040213-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	cagney_bigcore-20040122-branch:1.5.0.66
	cagney_bigcore-20040122-branchpoint:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	kettenis_sparc-20030918-branch:1.5.0.64
	kettenis_sparc-20030918-branchpoint:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.62
	cagney_x86i386-20030821-branch:1.5.0.60
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.58
	gdb_6_0-2003-06-23-branchpoint:1.5
	jimb-ppc64-linux-20030613-branch:1.5.0.56
	jimb-ppc64-linux-20030613-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.54
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.52
	cagney_writestrings-20030508-branchpoint:1.5
	jimb-ppc64-linux-20030528-branch:1.5.0.50
	jimb-ppc64-linux-20030528-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.48
	cagney_fileio-20030521-branchpoint:1.5
	kettenis_i386newframe-20030517-mergepoint:1.5
	jimb-ppc64-linux-20030509-branch:1.5.0.46
	jimb-ppc64-linux-20030509-branchpoint:1.5
	kettenis_i386newframe-20030504-mergepoint:1.5
	carlton_dictionary-20030430-merge:1.5
	kettenis_i386newframe-20030419-branch:1.5.0.44
	kettenis_i386newframe-20030419-branchpoint:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	kettenis_i386newframe-20030406-branch:1.5.0.42
	kettenis_i386newframe-20030406-branchpoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.40
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.38
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.36
	cagney_lazyid-20030317-branchpoint:1.5
	kettenis-i386newframe-20030316-mergepoint:1.5
	offbyone-20030313-branch:1.5.0.34
	offbyone-20030313-branchpoint:1.5
	kettenis-i386newframe-20030308-branch:1.5.0.32
	kettenis-i386newframe-20030308-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.30
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.28
	interps-20030202-branchpoint:1.5
	cagney-unwind-20030108-branch:1.5.0.26
	cagney-unwind-20030108-branchpoint:1.5
	carlton_dictionary-20021223-merge:1.5
	gdb_5_3-2002-12-12-release:1.5
	carlton_dictionary-20021115-merge:1.5
	kseitz_interps-20021105-merge:1.5
	kseitz_interps-20021103-merge:1.5
	drow-cplus-merge-20021020:1.5
	drow-cplus-merge-20021025:1.5
	carlton_dictionary-20021025-merge:1.5
	carlton_dictionary-20021011-merge:1.5
	drow-cplus-branch:1.5.0.24
	drow-cplus-branchpoint:1.5
	kseitz_interps-20020930-merge:1.5
	carlton_dictionary-20020927-merge:1.5
	carlton_dictionary-branch:1.5.0.22
	carlton_dictionary-20020920-branchpoint:1.5
	gdb_5_3-branch:1.5.0.20
	gdb_5_3-2002-09-04-branchpoint:1.5
	kseitz_interps-20020829-merge:1.5
	cagney_sysregs-20020825-branch:1.5.0.18
	cagney_sysregs-20020825-branchpoint:1.5
	readline_4_3-import-branch:1.5.0.16
	readline_4_3-import-branchpoint:1.5
	gdb_5_2_1-2002-07-23-release:1.5
	kseitz_interps-20020528-branch:1.5.0.14
	kseitz_interps-20020528-branchpoint:1.5
	cagney_regbuf-20020515-branch:1.5.0.12
	cagney_regbuf-20020515-branchpoint:1.5
	jimb-macro-020506-branch:1.5.0.10
	jimb-macro-020506-branchpoint:1.5
	gdb_5_2-2002-04-29-release:1.5
	gdb_5_2-branch:1.5.0.8
	gdb_5_2-2002-03-03-branchpoint:1.5
	gdb_5_1_1-2002-01-24-release:1.5
	gdb_5_1_0_1-2002-01-03-release:1.5
	cygnus_cvs_20020108_pre:1.5
	gdb_5_1_0_1-2002-01-03-branch:1.5.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.5
	gdb_5_1-2001-11-21-release:1.5
	gdb_s390-2001-09-26-branch:1.5.0.4
	gdb_s390-2001-09-26-branchpoint:1.5
	gdb_5_1-2001-07-29-branch:1.5.0.2
	gdb_5_1-2001-07-29-branchpoint:1.5
	insight-precleanup-2001-01-01:1.5
	gdb-premipsmulti-2000-06-06-branch:1.1.1.1.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.4
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	gdb-2000-02-04:1.1.1.1
	gdb-2000-02-02:1.1.1.1
	gdb-2000-02-01:1.1.1.1
	gdb-2000-01-31:1.1.1.1
	gdb-2000-01-26:1.1.1.1
	gdb-2000-01-24:1.1.1.1
	gdb-2000-01-17:1.1.1.1
	gdb-2000-01-10:1.1.1.1
	gdb-2000-01-05:1.1.1.1
	gdb-1999-12-21:1.1.1.1
	gdb-1999-12-13:1.1.1.1
	gdb-1999-12-07:1.1.1.1
	gdb-1999-12-06:1.1.1.1
	gdb-1999-11-16:1.1.1.1
	gdb-1999-11-08:1.1.1.1
	gdb-1999-11-01:1.1.1.1
	gdb-1999-10-25:1.1.1.1
	gdb-1999-10-18:1.1.1.1
	gdb-1999-10-11:1.1.1.1
	gdb-1999-10-04:1.1.1.1
	gdb-1999-09-28:1.1.1.1
	gdb-1999-09-21:1.1.1.1
	gdb-1999-09-13:1.1.1.1
	gdb-1999-09-08:1.1.1.1
	gdb-1999-08-30:1.1.1.1
	gdb-1999-08-23:1.1.1.1
	gdb-1999-08-16:1.1.1.1
	gdb-1999-08-09:1.1.1.1
	gdb-1999-08-02:1.1.1.1
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.5
date	2000.07.31.12.54.31;	author shebs;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.24.18.19.47;	author shebs;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.21.19.27.07;	author shebs;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.17.17.14.48;	author shebs;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.35.29;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.35.29;	author shebs;	state Exp;
branches;
next	;


desc
@@


1.5
log
@	Add the generation of C++ classes.
	* spu.c (version_string): Bump to 0.5.
	(DEFAULT_NUM_CLASSES, DEFAULT_NUM_LIB_CLASSES,
	DEFAULT_NUM_METHODS): New macros.
	(enum decl_types): Add d_class.
	(struct class_desc): New struct.
	(struct function_desc): Add class field.
	(num_classes, num_lib_classes, num_methods, classes, lib_classes):
	New globals.
	(main): Add --classes and --methods options.
	(display_usage): Mention them.
	(add_decl_to_table): Add d_class and default cases.
	(create_classes, create_class, write_class): New functions.
	(write_header_file, write_lib_header_file): Write classes.
	(write_function): Format class methods differently.

	(lang_names): New global.
	(main): Use c++ instead of cpp in --language.
	(write_description_block): Write out all parameter settings.
	* README: Update version number.
@
text
@/* spu -- A program to make lots of random C/C++ code.
   Copyright (C) 1993, 1994, 2000 Free Software Foundation, Inc.
   Contributed by Cygnus Support.  Written by Stan Shebs.

This file is part of SPU.

SPU is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; see the file COPYING.  If not, write to
the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */

/* This is a random program generator. */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include <time.h>

char *version_string = "0.5";

/* These values are the builtin defaults, mainly useful for testing
   purposes, or if the user is uninterested in setting a value.  */

#define DEFAULT_NUM_FILES 5

#define DEFAULT_NUM_HEADER_FILES 1

#define DEFAULT_NUM_MACROS 10

#define DEFAULT_NUM_LIB_MACROS 30

#define DEFAULT_MAX_MACRO_ARGS 5

#define DEFAULT_NUM_ENUMS 10

#define DEFAULT_NUM_LIB_ENUMS 30

#define DEFAULT_NUM_ENUMERATORS 10

#define DEFAULT_NUM_STRUCTS 10

#define DEFAULT_NUM_LIB_STRUCTS 30

#define DEFAULT_NUM_FIELDS 20

#define DEFAULT_NUM_CLASSES 10

#define DEFAULT_NUM_LIB_CLASSES 30

#define DEFAULT_NUM_METHODS 20

#define DEFAULT_NUM_FUNCTIONS 100

#define DEFAULT_NUM_LIB_FUNCTIONS 300

#define DEFAULT_MAX_FUNCTION_ARGS 8

#define DEFAULT_FUNCTION_LENGTH 20

#define DEFAULT_FUNCTION_DEPTH 3

#define DEFAULT_LIB_PERCENT 10

/* Generic hash table.  */

struct hash_entry
{
  char *val;
  struct hash_entry *next;
};

struct hash_table
{
  struct hash_entry *entries[253];
  int numadds;
};

enum decl_types {
  d_nothing,
  d_macro,
  d_enum,
  d_struct,
  d_class,
  d_function
};

enum {
  t_nothing = 0,
  t_void = 1,
  t_int = 2,
  t_short = 3,
  t_char = 4,
  t_first_user = 100,
  t_char_ptr = 1000004
};

char *typenames[] = { "?", "void", "int", "short", "char" };

struct macro_desc
{
  int id;
  char *name;
  int numargs;
  char **args;
  int use;
};

struct enumerator_desc
{
  char *name;
};

struct enum_desc
{
  int id;
  char *name;
  int num_enumerators;
  struct enumerator_desc *enumerators;
  int use;
};

struct field_desc
{
  int type;
  char *name;
};

struct struct_desc
{
  int id;
  char *name;
  int numfields;
  struct field_desc *fields;
  int use;
};

/* (should add unions as type of struct) */

struct class_desc
{
  int id;
  char *name;
  int numfields;
  struct field_desc *fields;
  int nummethods;
  struct function_desc *methods;
  int use;
};

struct type_desc
{
  char *name;
};

struct arg_desc
{
  int type;
  char *name;
};

struct function_desc
{
  int id;
  char *name;
  int return_type;
  int numargs;
  struct arg_desc *args;
  struct class_desc *class;
  int use;
};

struct file_desc
{
  char *name;
};

struct decl_entry {
  enum decl_types type;
  union {
    struct macro_desc *macro_d;
    struct enum_desc *enum_d;
    struct struct_desc *struct_d;
    struct class_desc *class_d;
    struct function_desc *function_d;
  } decl;
  int seq;
  int order;
};

struct decl_table {
  int size;
  int nextentry;
  struct decl_entry *entries;
};

/* Function declarations.  */

void display_usage (void);

int hash_string (char *str);

struct hash_entry *get_hash_entry (void);

char *add_to_hash_table (char *buf, struct hash_table *table);

char *get_from_hash_table (char *buf, struct hash_table *table);

void init_xrandom (int seed);

int xrandom (int n);

int probability (int prob);

char *copy_string (char *str);

char *xmalloc (int n);

char *gen_unique_global_name (char *root, int upcase);

void gen_random_global_name (char *root, char *namebuf);

char *gen_random_local_name (int n, char **others);

void create_macros (void);

void create_macro (struct macro_desc *macrodesc);

char *gen_new_macro_name (void);

void create_enums (void);

void create_enum (struct enum_desc *enumdesc);

char *gen_random_enumerator_name (void);

void create_structs (void);

void create_struct (struct struct_desc *structdesc, int lib);

char *gen_random_field_name (int n);

void create_classes (void);

void create_class (struct class_desc *classdesc, int lib);

void create_functions (void);

void create_function (struct function_desc *fndesc, int lib);

void write_header_file (int n);

void write_lib_header_file (void);

void write_source_file (int n);

void write_lib_source_file (void);

void write_macro (FILE *fp, struct macro_desc *macrodesc);

void write_enum (FILE *fp, struct enum_desc *enumdesc);

void write_struct (FILE *fp, struct struct_desc *structdesc);

void write_class (FILE *fp, struct class_desc *classdesc);

void write_function_decl (FILE *fp, struct function_desc *fndesc);

void write_function (FILE *fp, struct function_desc *fndesc);

void write_lib_function (FILE *fp, int n);

void write_statement (FILE *fp, int depth, int max_depth);

void write_expression (FILE *fp, int rslttype, int depth, int max_depth,
		       int exclude_id);

void write_description_block (FILE *fp);

void write_makefile (void);

/* Global variables.  */

/* The possible languages. */

enum languages { knr, c, cpp, objc };

enum languages language = c;

/* Filename extensions to use with each language type.  */

char *extensions[] = { "c", "c", "cc", "m" };

/* Names for each language.  */

char *lang_names[] = { "K&R C", "standard C", "standard C++", "Objective-C" };

int num_files = DEFAULT_NUM_FILES;

int num_header_files = DEFAULT_NUM_HEADER_FILES;

char *file_base_name = "file";

int num_macros = DEFAULT_NUM_MACROS;

int num_lib_macros = DEFAULT_NUM_LIB_MACROS;

int num_enums = DEFAULT_NUM_ENUMS;

int num_lib_enums = DEFAULT_NUM_LIB_ENUMS;

int num_enumerators = DEFAULT_NUM_ENUMERATORS;

int num_structs = DEFAULT_NUM_STRUCTS;

int num_lib_structs = DEFAULT_NUM_LIB_STRUCTS;

int num_fields = DEFAULT_NUM_FIELDS;

int num_classes = DEFAULT_NUM_CLASSES;

int num_lib_classes = DEFAULT_NUM_LIB_CLASSES;

int num_methods = DEFAULT_NUM_METHODS;

int num_functions = DEFAULT_NUM_FUNCTIONS;

int num_lib_functions = DEFAULT_NUM_LIB_FUNCTIONS;

int max_function_args = DEFAULT_MAX_FUNCTION_ARGS;

int function_length = DEFAULT_FUNCTION_LENGTH;

int function_depth = DEFAULT_FUNCTION_DEPTH;

/* Percentage of library constructs that will be referenced.  */

int lib_percent = DEFAULT_LIB_PERCENT;

int randomize_order = 1;

int num_functions_per_file;

/* The amount of commenting in the source.  */

int commenting = 0;

/* Hash table for globally visible symbols.  */

struct hash_table *global_hash_table;

/* The seed for the random number generator.  */

int seed = -1;

int next_id = 1;

/* Space to record info about generated constructs.  */

struct macro_desc *macros;

struct macro_desc *lib_macros;

struct enum_desc *enums;

struct enum_desc *lib_enums;

struct struct_desc *structs;

struct struct_desc *lib_structs;

struct class_desc *classes;

struct class_desc *lib_classes;

struct function_desc *functions;

struct function_desc *lib_functions;

struct decl_table order;

struct decl_table lib_order;

int num_computer_terms;

/* Likely words to appear in names of things.  These must never be
   valid C/C++ keywords, since they may appear by themselves in some
   contexts.  */

char *computerese[] = {
  "add", "all", "alloc", "allocate", "area", "array", "at",
  "bogus", "buf", "buff", "buffer", "by", "btree",
  "ch", "chr", "clean", "cleanup", "count", "create", "cull",
  "data", "del", "delete_", "depth", "desc", "dest", "discard", "dismiss",
  "dma", "done", "dst",
  "fill", "find", "fn", "for_",
  "gc", "go", "goto_", "grok", "gronk", "group", "grovel",
  "hack", "hacked", "have", "heap",
  "in", "ind", "index", "ini", "init", "initial", "inside",
  "lab", "label", "last", "len", "length", "line", "lis", "list", "lose",
  "make", "mark", "mod", "modify", "more",
  "name", "nest", "nesting", "new_", "next", "node", "null", "num", "number",
  "part", "partial",
  "query", "queue",
  "ob", "obj", "object", "of",
  "pc", "pnt", "point", "pop", "pos", "position", "push",
  "raw", "recalc", "rect", "rectangle", "rel", "relative", "ret", "rslt",
  "remove", "reset", "rmv",
  "see", "set", "shape", "stack", "str", "string",
  "tab", "table", "tbl", "tag", "tree",
  "undel", "undo", "unmark", "use",
  "vary", "vec", "vect", "vector", "virt", "virtual_",
  "win", "wind", "window", "word",
  "zbuf",
  NULL
};

/* Return a word that commonly appears in programs. */

char *
random_computer_word (void)
{
  if (num_computer_terms == 0)
    {
      int i;

      for (i = 0; computerese[i] != NULL; ++i)
	;
      num_computer_terms = i;
    }
  return computerese[xrandom (num_computer_terms)];
}

int
main (int argc, char **argv)
{
  int i, num;
  char *arg;

  
  /* Parse all the arguments. */
  /* (should check on numeric values) */
  for (i = 1; i < argc; ++i)
    {
      arg = argv[i];
      if (strcmp(arg, "--basename") == 0)
	{
	  file_base_name = copy_string(argv[++i]);
	}
      else if (strcmp(arg, "--classes") == 0)
	{
	  num = strtol (argv[++i], NULL, 10);
	  num_classes = num;
	}
      else if (strcmp(arg, "--comments") == 0)
	{
	  num = strtol (argv[++i], NULL, 10);
	  commenting = num;
	}
      else if (strcmp(arg, "--enums") == 0)
	{
	  num = strtol (argv[++i], NULL, 10);
	  num_enums = num;
	}
      else if (strcmp(arg, "--enumerators") == 0)
	{
	  num = strtol (argv[++i], NULL, 10);
	  num_enumerators = num;
	}
      else if (strcmp(arg, "--fields") == 0)
	{
	  num = strtol (argv[++i], NULL, 10);
	  num_fields = num;
	}
      else if (strcmp(arg, "--files") == 0)
	{
	  num = strtol (argv[++i], NULL, 10);
	  num_files = num;
	}
      else if (strcmp(arg, "--functions") == 0)
	{
	  num = strtol (argv[++i], NULL, 10);
	  num_functions = num;
	}
      else if (strcmp(arg, "--function-length") == 0)
	{
	  num = strtol (argv[++i], NULL, 10);
	  function_length = num;
	}
      else if (strcmp(arg, "--function-depth") == 0)
	{
	  num = strtol (argv[++i], NULL, 10);
	  function_depth = num;
	}
      else if (strcmp(arg, "--header-files") == 0)
	{
	  num = strtol (argv[++i], NULL, 10);
	  num_header_files = num;
	}
      else if (strcmp(arg, "--help") == 0)
	{
	  display_usage ();
	  exit (0);
	}
      else if (strcmp(arg, "--language") == 0)
	{
	  if (strcmp (argv[i+1], "c") == 0)
	    language = c;
	  else if (strcmp (argv[i+1], "c++") == 0)
	    language = cpp;
	  else if (strcmp (argv[i+1], "knr") == 0)
	    language = knr;
	  else if (strcmp (argv[i+1], "objc") == 0)
	    language = objc;
	  ++i;
	}
      else if (strcmp(arg, "--lib-classes") == 0)
	{
	  num = strtol (argv[++i], NULL, 10);
	  num_lib_classes = num;
	}
      else if (strcmp(arg, "--lib-enums") == 0)
	{
	  num = strtol (argv[++i], NULL, 10);
	  num_lib_enums = num;
	}
      else if (strcmp(arg, "--lib-functions") == 0)
	{
	  num = strtol (argv[++i], NULL, 10);
	  num_lib_functions = num;
	}
      else if (strcmp(arg, "--lib-macros") == 0)
	{
	  num = strtol (argv[++i], NULL, 10);
	  num_lib_macros = num;
	}
      else if (strcmp(arg, "--lib-structs") == 0)
	{
	  num = strtol (argv[++i], NULL, 10);
	  num_lib_structs = num;
	}
      else if (strcmp(arg, "--macros") == 0)
	{
	  num = strtol (argv[++i], NULL, 10);
	  num_macros = num;
	}
      else if (strcmp(arg, "--methods") == 0)
	{
	  num = strtol (argv[++i], NULL, 10);
	  num_methods = num;
	}
      else if (strcmp(arg, "--seed") == 0)
	{
	  num = strtol (argv[++i], NULL, 10);
	  seed = num;
	}
      else if (strcmp(arg, "--structs") == 0)
	{
	  num = strtol (argv[++i], NULL, 10);
	  num_structs = num;
	}
      else if (strcmp(arg, "--version") == 0)
	{
	  fprintf (stderr, "SPU program generator version %s\n",
		   version_string);
	  exit (0);
	}
      else
	{
	  fprintf (stderr, "Usage: \"%s\" not valid, ignored\n", arg);
	  display_usage ();
	}
    }
  if (language != cpp)
    num_classes = num_lib_classes = 0;
  init_xrandom (seed);
  /* Round up the number of functions so each file gets the same
     number. */
  num_functions_per_file = (num_functions + num_files - 1) / num_files;
  num_functions = num_functions_per_file * num_files;
  /* Create the definitions of objects internally. */
  order.size =
    num_macros + num_enums + num_structs + num_classes + num_functions;
  order.nextentry = 0;
  order.entries =
    (struct decl_entry *) xmalloc (order.size * sizeof(struct decl_entry));
  lib_order.size = num_lib_macros + num_lib_enums + num_lib_structs + num_lib_classes + num_lib_functions;
  lib_order.nextentry = 0;
  lib_order.entries =
    (struct decl_entry *) xmalloc (lib_order.size * sizeof(struct decl_entry));
  create_macros ();
  create_enums ();
  create_structs ();
  create_functions ();
  create_classes ();
  /* Write out a bunch of files. */
  printf ("Writing %d header files...\n", num_header_files);
  for (i = 0; i < num_header_files; ++i)
    write_header_file (i);
  write_lib_header_file ();
  write_lib_source_file ();
  printf ("Writing %d files...\n", num_files);
  for (i = 0; i < num_files; ++i)
    write_source_file (i);
  /* Write out a makefile. */
  write_makefile ();
  /* Succeed if we actually wrote out a whole program correctly. */
  exit (0);
}

void
display_usage (void)
{
  fprintf (stderr, "Usage: spu [ ... options ... ]\n");
  fprintf (stderr, "\t--basename str (default \"%s\")\n", "file");
  fprintf (stderr, "\t--classes n (default %d)\n", DEFAULT_NUM_CLASSES);
  fprintf (stderr, "\t--comments n\n");
  fprintf (stderr, "\t--enums n (default %d)\n", DEFAULT_NUM_ENUMS);
  fprintf (stderr, "\t--enumerators n (default %d)\n", DEFAULT_NUM_ENUMERATORS);
  fprintf (stderr, "\t--fields n (default %d)\n", DEFAULT_NUM_FIELDS);
  fprintf (stderr, "\t--files n (default %d)\n", DEFAULT_NUM_FILES);
  fprintf (stderr, "\t--functions n (default %d)\n", DEFAULT_NUM_FUNCTIONS);
  fprintf (stderr, "\t--function-length n (default %d)\n", DEFAULT_FUNCTION_LENGTH);
  fprintf (stderr, "\t--function-depth n (default %d)\n", DEFAULT_FUNCTION_DEPTH);
  fprintf (stderr, "\t--header-files n (default %d)\n", DEFAULT_NUM_HEADER_FILES);
  fprintf (stderr, "\t--help\n");
  fprintf (stderr, "\t--language c|cpp|knr|objc (default c)\n");
  fprintf (stderr, "\t--lib-classes n (default %d)\n", DEFAULT_NUM_LIB_CLASSES);
  fprintf (stderr, "\t--lib-enums n (default %d)\n", DEFAULT_NUM_LIB_ENUMS);
  fprintf (stderr, "\t--lib-functions n (default %d)\n", DEFAULT_NUM_LIB_FUNCTIONS);
  fprintf (stderr, "\t--lib-macros n (default %d)\n", DEFAULT_NUM_LIB_MACROS);
  fprintf (stderr, "\t--lib-structs n (default %d)\n", DEFAULT_NUM_LIB_STRUCTS);
  fprintf (stderr, "\t--macros n (default %d)\n", DEFAULT_NUM_MACROS);
  fprintf (stderr, "\t--methods n (default %d)\n", DEFAULT_NUM_METHODS);
  fprintf (stderr, "\t--seed n\n");
  fprintf (stderr, "\t--structs n (default %d)\n", DEFAULT_NUM_STRUCTS);
  fprintf (stderr, "\t--version\n");
}

int
random_type (int libonly)
{
  int i, n;

  switch (xrandom (6))
    {
    case 0:
      return t_short;
    case 1:
      return t_char;
    case 2:
      return t_char_ptr;
    case 3:
      for (i = 0; i < 1000; ++i)
	{
	  n = xrandom (num_lib_structs);
	  if (lib_structs[n].id > 0 && lib_structs[n].use)
	    return t_first_user + lib_structs[n].id;
	}
      return t_int;
    case 4:
      if (libonly)
	return t_int;
      for (i = 0; i < 1000; ++i)
	{
	  n = xrandom (num_structs);
	  if (structs[n].id > 0)
	    return t_first_user + structs[n].id;
	}
      return t_int;
    default:
      return t_int;
    }
}

/* Given a numbered type, return its name.  */

char *
name_from_type (int n)
{
  int i;
  char tmpbuf[100];

  if (n < t_first_user)
    {
      return typenames[n];
    }
  else if (n >= 1000000 && (n - 1000000) < t_first_user)
    {
      sprintf (tmpbuf, "%s *", typenames[n - 1000000]);
      return copy_string (tmpbuf);
    }
  else
    {
      for (i = 0; i < num_structs; ++i)
	{
	  if (structs[i].id == (n - t_first_user))
	    {
	      sprintf (tmpbuf, "struct %s *", structs[i].name);
	      return copy_string (tmpbuf);
	    }
	}
      for (i = 0; i < num_lib_structs; ++i)
	{
	  if (lib_structs[i].id == (n - t_first_user))
	    {
	      sprintf (tmpbuf, "struct %s *", lib_structs[i].name);
	      return copy_string (tmpbuf);
	    }
	}
    }
  return "?type?";
}

void
add_decl_to_table (enum decl_types type, void *desc, struct decl_table *table)
{
  int n = table->nextentry++;

  table->entries[n].type = type;
  switch (type)
    {
    case d_macro:
      table->entries[n].decl.macro_d = (struct macro_desc *) desc;
      break;
    case d_enum:
      table->entries[n].decl.enum_d = (struct enum_desc *) desc;
      break;
    case d_struct:
      table->entries[n].decl.struct_d = (struct struct_desc *) desc;
      break;
    case d_class:
      table->entries[n].decl.class_d = (struct class_desc *) desc;
      break;
    case d_function:
      table->entries[n].decl.function_d = (struct function_desc *) desc;
      break;
    default:
      fprintf (stderr, "Unknown decl type %d in add_decl_to_table\n", type);
      break;
    }
  table->entries[n].seq = n;
  if (randomize_order)
    table->entries[n].order = xrandom (10000);
}

/* Create basic definitions of macros.  Negative number of arguments
   means a macros that looks like a constant instead of a function.  */

void
create_macros (void)
{
  int i;

  printf ("Creating %d macros...\n", num_macros);
  macros =
    (struct macro_desc *) xmalloc (num_macros * sizeof(struct macro_desc));
  for (i = 0; i < num_macros; ++i)
    {
      create_macro (&(macros[i]));
      add_decl_to_table (d_macro, &(macros[i]), &order);
    }

  /* It's important to create library macros second, so that their ids
     are higher than those for program macros.  This is so that
     library macro bodies are excluded from referencing any program
     macros (because of the exclude_id bits in write_expression).  */

  printf ("Creating %d library macros...\n", num_lib_macros);
  lib_macros =
    (struct macro_desc *) xmalloc (num_lib_macros * sizeof(struct macro_desc));
  for (i = 0; i < num_lib_macros; ++i)
    {
      create_macro (&(lib_macros[i]));
      if (!probability(lib_percent))
	lib_macros[i].use = 0;
      add_decl_to_table (d_macro, &(lib_macros[i]), &lib_order);
    }
}

void
create_macro (struct macro_desc *macrodesc)
{
  int j, numargs;

  macrodesc->id = next_id++;
  macrodesc->name = gen_new_macro_name ();
  numargs = xrandom (DEFAULT_MAX_MACRO_ARGS + 1);
  --numargs;
  if (numargs > 0)
    {
      macrodesc->args = (char **) xmalloc (numargs * sizeof(char *));
      for (j = 0; j < numargs; ++j)
	{
	  macrodesc->args[j] = gen_random_local_name (j, NULL);
	}
    }
  macrodesc->numargs = numargs;
  macrodesc->use = 1;
}

/* Generate a macro name.  */

char *
gen_new_macro_name (void)
{
  return gen_unique_global_name ("M", (xrandom (3) > 0));
}

/* Create definitions of the desired number of enums.  */

void
create_enums (void)
{
  int i;

  printf ("Creating %d enums...\n", num_enums);
  enums =
    (struct enum_desc *) xmalloc (num_enums * sizeof(struct enum_desc));
  for (i = 0; i < num_enums; ++i)
    {
      create_enum (&(enums[i]));
      add_decl_to_table (d_enum, &(enums[i]), &order);
    }
  printf ("Creating %d library enums...\n", num_lib_enums);
  lib_enums =
    (struct enum_desc *) xmalloc (num_lib_enums * sizeof(struct enum_desc));
  for (i = 0; i < num_lib_enums; ++i)
    {
      create_enum (&(lib_enums[i]));
      if (!probability(lib_percent))
	lib_enums[i].use = 0;
      add_decl_to_table (d_enum, &(lib_enums[i]), &lib_order);
    }
}

void
create_enum (struct enum_desc *enumdesc)
{
  int j, num;

  enumdesc->id = next_id++;
  /* Let some enums be anonymous. */
  if (xrandom (100) < 50)
    enumdesc->name = gen_unique_global_name (NULL, 0);
  num = num_enumerators / 2 + xrandom (num_enumerators);
  if (num <= 0)
    num = 1;
  enumdesc->enumerators =
    (struct enumerator_desc *) xmalloc (num * sizeof(struct enumerator_desc));
  for (j = 0; j < num; ++j)
    {
      enumdesc->enumerators[j].name = gen_random_enumerator_name ();
    }
  enumdesc->num_enumerators = j;
  enumdesc->use = 1;
}

/* Generate a unique enumerator within an enum.  */

char *
gen_random_enumerator_name (void)
{
  return gen_unique_global_name ("enum", 0);
}

/* Create definitions of the desired number of structures.  */

void
create_structs (void)
{
  int i;

  /* Do the library structs first, so that program structs may use
     them in their definitions.  */
  printf ("Creating %d library structs...\n", num_lib_structs);
  lib_structs =
    (struct struct_desc *) xmalloc (num_lib_structs * sizeof(struct struct_desc));
  for (i = 0; i < num_lib_structs; ++i)
    {
      create_struct (&(lib_structs[i]), 1);
      if (!probability(lib_percent))
	lib_structs[i].use = 0;
      add_decl_to_table (d_struct, &(lib_structs[i]), &lib_order);
    }

  printf ("Creating %d structs...\n", num_structs);
  structs =
    (struct struct_desc *) xmalloc (num_structs * sizeof(struct struct_desc));
  for (i = 0; i < num_structs; ++i)
    {
      create_struct (&(structs[i]), 0);
      add_decl_to_table (d_struct, &(structs[i]), &order);
    }
}

void
create_struct (struct struct_desc *structdesc, int lib)
{
  int j, numf;

  structdesc->id = next_id++;
  structdesc->name = gen_unique_global_name (NULL, 0);
  numf = xrandom (num_fields) + 1;
  structdesc->fields =
    (struct field_desc *) xmalloc (numf * sizeof(struct field_desc));
  for (j = 0; j < numf; ++j)
    {
      structdesc->fields[j].type = random_type (lib);
      structdesc->fields[j].name = gen_random_field_name (j);
    }
  structdesc->numfields = numf;
  structdesc->use = 1;
}

char *
gen_random_field_name (int n)
{
  char namebuf[100];

  /* (should have more variety) */
  sprintf (namebuf, "field%d", n);
  return copy_string (namebuf);
}

/* Create definitions of the desired number of classures.  */

void
create_classes (void)
{
  int i;

  /* Do the library classes first, so that program classes may use
     them in their definitions.  */
  printf ("Creating %d library classes...\n", num_lib_classes);
  lib_classes =
    (struct class_desc *) xmalloc (num_lib_classes * sizeof(struct class_desc));
  for (i = 0; i < num_lib_classes; ++i)
    {
      create_class (&(lib_classes[i]), 1);
      if (!probability(lib_percent))
	lib_classes[i].use = 0;
      add_decl_to_table (d_class, &(lib_classes[i]), &lib_order);
    }

  printf ("Creating %d classes...\n", num_classes);
  classes =
    (struct class_desc *) xmalloc (num_classes * sizeof(struct class_desc));
  for (i = 0; i < num_classes; ++i)
    {
      create_class (&(classes[i]), 0);
      add_decl_to_table (d_class, &(classes[i]), &order);
    }
}

void
create_class (struct class_desc *classdesc, int lib)
{
  int j, numf, numm;

  classdesc->id = next_id++;
  classdesc->name = gen_unique_global_name (NULL, 0);
  numf = xrandom (num_fields) + 1;
  classdesc->fields =
    (struct field_desc *) xmalloc (numf * sizeof(struct field_desc));
  for (j = 0; j < numf; ++j)
    {
      classdesc->fields[j].type = random_type (lib);
      classdesc->fields[j].name = gen_random_field_name (j);
    }
  classdesc->numfields = numf;
  numm = xrandom (num_methods + 1);
  classdesc->methods =
    (struct function_desc *) xmalloc (numm * sizeof(struct function_desc));
  for (j = 0; j < numm; ++j)
    {
      create_function (&(classdesc->methods[j]), lib);
      classdesc->methods[j].class = classdesc;
    }
  classdesc->nummethods = numm;
  classdesc->use = 1;
}

/* Create a number of functions with random numbers and types of
   arguments. */

void
create_functions (void)
{
  int i;

  printf ("Creating %d functions...\n", num_functions);
  functions =
    (struct function_desc *) xmalloc (num_functions * sizeof(struct function_desc));

  /* Generate the main program, as the first function.  */
  functions[0].id = next_id++;
  functions[0].name = "main";
  functions[0].return_type = t_int;
  functions[0].numargs = 0;
  functions[0].use = 1;
  add_decl_to_table (d_function, &(functions[0]), &order);

  /* Generate all the other functions.  */
  for (i = 1; i < num_functions; ++i)
    {
      create_function (&(functions[i]), 0);
      add_decl_to_table (d_function, &(functions[i]), &order);
#if 0 /* use forward decls for now instead */
      {
	int j, type;
	struct function_desc *fndesc = &(functions[i]);
      
	for (j = 0; j < fndesc->numargs; ++j)
	  {
	    type = fndesc->args[i].type;
	    if (type >= t_first_user)
	      {
		/* (should find arg types and increase fndesc->order) */
	      }
	  }
      }
#endif
    }

  printf ("Creating %d library functions...\n", num_lib_functions);
  lib_functions =
    (struct function_desc *) xmalloc (num_lib_functions * sizeof(struct function_desc));
  for (i = 0; i < num_lib_functions; ++i)
    {
      create_function (&(lib_functions[i]), 1);
      /* Mark some functions as not to be referenced from the program.  */
      if (!probability(lib_percent))
	lib_functions[i].use = 0;
      add_decl_to_table (d_function, &(lib_functions[i]), &lib_order);
    }
}

/* Generate the details of a single function.  */

void
create_function (struct function_desc *fndesc, int lib)
{
  int j, range, numargs;

  fndesc->id = next_id++;
  fndesc->name = gen_unique_global_name ("fn", 0);
  fndesc->return_type = ((xrandom (4) == 0) ? t_void : random_type (lib));
  /* Choose the number of arguments, preferring shorter argument lists
     by using a simple binomial distribution that is "folded" in the
     middle so zero-arg functions are the most common.  */
  range = 2 * (max_function_args + 1);
  numargs = 0;
  for (j = 0; j < 6; ++j)
    numargs += xrandom (range + 1);
  if (j > 0)
    numargs /= j;
  /* Shift distribution so 0 is in the middle.  */
  numargs -= max_function_args;
  /* Fold negative values over to positive side.  */
  if (numargs < 0)
    numargs = -numargs;
  if (numargs > max_function_args)
    numargs = max_function_args;
  if (numargs > 0)
    {
      fndesc->args =
	(struct arg_desc *) xmalloc (numargs * sizeof(struct arg_desc));
      for (j = 0; j < numargs; ++j)
	{
	  fndesc->args[j].type = random_type (lib);
	  fndesc->args[j].name = gen_random_local_name (j, NULL);
	}
    }
  fndesc->numargs = numargs;
  fndesc->class = NULL;
  fndesc->use = 1;
}

int
compare_entries(const void *x1, const void *x2)
{
  struct decl_entry *e1 = (struct decl_entry *) x1;
  struct decl_entry *e2 = (struct decl_entry *) x2;

  if (e1->order != e2->order)
    return (e1->order - e2->order);
  /* Randomized order may have pairs of matching numbers, so use this
     as fallback.  */
  return (e1->seq - e2->seq);
}

void
write_header_file (int n)
{
  int i;
  char tmpbuf[100];
  FILE *fp;

  sprintf (tmpbuf, "%s%d.h", file_base_name, n);
  fp = fopen (tmpbuf, "w");
  if (fp == NULL)
    return;
  write_description_block (fp);
  if (commenting > 0)
    fprintf (fp, "/* header */\n");
  /* Ensure that structure decls exist before functions mentioning them.  */
  if (randomize_order)
    {
      fprintf (fp, "/* forward decls */\n");
      for (i = 0; i < num_structs; ++i)
	fprintf (fp, "struct %s;\n", structs[i].name);
      for (i = 0; i < num_classes; ++i)
	fprintf (fp, "class %s;\n", classes[i].name);
      fprintf (fp, "\n");
    }
  qsort(order.entries, order.size, sizeof(struct decl_entry),
	compare_entries);
  for (i = 0; i < order.size; ++i)
    {
      switch (order.entries[i].type)
	{
	case d_macro:
	  write_macro (fp, order.entries[i].decl.macro_d);
	  break;
	case d_enum:
	  write_enum (fp, order.entries[i].decl.enum_d);
	  break;
	case d_struct:
	  write_struct (fp, order.entries[i].decl.struct_d);
	  break;
	case d_class:
	  write_class (fp, order.entries[i].decl.class_d);
	  break;
	case d_function:
	  write_function_decl (fp, order.entries[i].decl.function_d);
	  break;
	default:
	  fprintf (stderr, "Unknown decl type %d in write_header_file\n",
		   order.entries[i].type);
	  break;
	}
    }
  fclose (fp);
}

void
write_lib_header_file (void)
{
  int i;
  char tmpbuf[100];
  FILE *fp;

  sprintf (tmpbuf, "%slib.h", file_base_name);
  fp = fopen (tmpbuf, "w");
  if (fp == NULL)
    return;
  if (commenting > 0)
    fprintf (fp, "/* library header */\n");
  write_description_block (fp);
  /* Ensure that structure decls exist before functions mentioning them.  */
  if (randomize_order)
    {
      fprintf (fp, "/* forward decls */\n");
      for (i = 0; i < num_lib_structs; ++i)
	fprintf (fp, "struct %s;\n", lib_structs[i].name);
      for (i = 0; i < num_lib_classes; ++i)
	fprintf (fp, "class %s;\n", lib_classes[i].name);
      fprintf (fp, "\n");
    }
  qsort(lib_order.entries, lib_order.size, sizeof(struct decl_entry),
	compare_entries);
  for (i = 0; i < lib_order.size; ++i)
    {
      switch (lib_order.entries[i].type)
	{
	case d_macro:
	  write_macro (fp, lib_order.entries[i].decl.macro_d);
	  break;
	case d_enum:
	  write_enum (fp, lib_order.entries[i].decl.enum_d);
	  break;
	case d_struct:
	  write_struct (fp, lib_order.entries[i].decl.struct_d);
	  break;
	case d_class:
	  write_class (fp, lib_order.entries[i].decl.class_d);
	  break;
	case d_function:
	  write_function_decl (fp, lib_order.entries[i].decl.function_d);
	  break;
	default:
	  fprintf (stderr, "Unknown decl type %d in write_header_file\n",
		   lib_order.entries[i].type);
	  break;
	}
    }
  fclose (fp);
}

void
write_macro (FILE *fp, struct macro_desc *macrodesc)
{
  int j;

  fprintf (fp, "\n#define %s", macrodesc->name);
  /* Negative # arguments indicates an argumentless macro instead of
     one with zero arguments. */
  if (macrodesc->numargs >= 0)
    {
      fprintf (fp, "(");
      for (j = 0; j < macrodesc->numargs; ++j)
	{
	  if (j > 0)
	    fprintf (fp, ",");
	  fprintf (fp, "%s", macrodesc->args[j]);
	}
      fprintf (fp, ")");
    }
  /* Generate a macro body. */
  fprintf (fp, " (");
  switch (xrandom(4))
    {
    case 0:
      write_expression (fp, t_int, 0, 2, macrodesc->id);
      break;
    case 1:
      /* A very common expansion for macros.  */
      fprintf (fp, "0");
      break;
    case 2:
      /* Likewise.  */
      fprintf (fp, "1");
      break;
    default:
      fprintf (fp, "%d", xrandom (100));
      break;
    }
  fprintf (fp, ")");
  fprintf (fp, "\n\n");
}

/* Write out the definition of a enum. */

void
write_enum (FILE *fp, struct enum_desc *enumdesc)
{
  int j;

  fprintf (fp, "\nenum");
  if (enumdesc->name)
    fprintf (fp, " %s", enumdesc->name);
  fprintf (fp, " {");
  for (j = 0; j < enumdesc->num_enumerators; ++j)
    {
      if (j > 0)
	fprintf (fp, ",");
      fprintf (fp, "\n  %s", enumdesc->enumerators[j].name);
    }
  fprintf (fp, "\n};\n\n");
}

/* Write out the definition of a structure. */

void
write_struct (FILE *fp, struct struct_desc *structdesc)
{
  int j;

  fprintf (fp, "\nstruct %s {\n", structdesc->name);
  for (j = 0; j < structdesc->numfields; ++j)
    {
      fprintf (fp, "  %s %s;\n",
	       name_from_type (structdesc->fields[j].type),
	       structdesc->fields[j].name);
    }
  fprintf (fp, "};\n\n");
}

/* Write out the definition of a classure. */

void
write_class (FILE *fp, struct class_desc *classdesc)
{
  int j;

  fprintf (fp, "\nclass %s {\n", classdesc->name);
  fprintf (fp, "public:\n");
  for (j = 0; j < classdesc->numfields; ++j)
    {
      fprintf (fp, "  %s %s;\n",
	       name_from_type (classdesc->fields[j].type),
	       classdesc->fields[j].name);
    }
  for (j = 0; j < classdesc->nummethods; ++j)
    {
      write_function (fp, &(classdesc->methods[j]));
    }
  fprintf (fp, "};\n\n");
}

void
write_function_decl (FILE *fp, struct function_desc *fndesc)
{
  int i;

  fprintf (fp, "extern %s %s (",
	   name_from_type (fndesc->return_type), fndesc->name);
  if (language != knr)
    {
      for (i = 0; i < fndesc->numargs; ++i)
	{
	  fprintf (fp, "%s %s",
		   name_from_type (fndesc->args[i].type),
		   fndesc->args[i].name);
	  if (i + 1 < fndesc->numargs)
	    fprintf (fp, ", ");
	}
    }
  fprintf (fp, ");\n");
}

/* Write a complete source file. */

void
write_source_file (int n)
{
  char tmpbuf[100];
  int j;
  FILE *fp;

  sprintf (tmpbuf, "%s%d.%s",
	   file_base_name, n, extensions[language]);
  fp = fopen (tmpbuf, "w");
  if (fp == NULL)
    return;
  write_description_block (fp);
  if (1 /*num_lib_header_files*/ > 0)
    {
      for (j = 0; j < 1 /*num_header_files*/; ++j)
	{
	  fprintf (fp, "#include \"%slib.h\"\n", file_base_name);
	}
      fprintf (fp, "\n");
    }
  if (num_header_files > 0)
    {
      for (j = 0; j < num_header_files; ++j)
	{
	  fprintf (fp, "#include \"%s%d.h\"\n", file_base_name, j);
	}
      fprintf (fp, "\n");
    }

  if (n == 0)
    printf ("  (Each file contains %d functions)\n",
	    num_functions_per_file);

  for (j = 0; j < num_functions_per_file; ++j)
    {
      write_function (fp, &(functions[n * num_functions_per_file + j]));
    }
  fclose (fp);
}

/* (should add option to define methods separately) */

void
write_function (FILE *fp, struct function_desc *fndesc)
{
  int i, k;

  if (fndesc->class)
    fprintf (fp, "  ");
  fprintf (fp, "%s", name_from_type (fndesc->return_type));
  fprintf (fp, (fndesc->class ? " " : "\n"));
  fprintf (fp, "%s (", fndesc->name);
  for (i = 0; i < fndesc->numargs; ++i)
    {
      if (language != knr)
	{
	  fprintf (fp, "%s ", name_from_type (fndesc->args[i].type));
	}
      fprintf (fp, "%s", fndesc->args[i].name);
      if (i + 1 < fndesc->numargs)
	fprintf (fp, ", ");
    }
  fprintf(fp, ")");
  fprintf (fp, (fndesc->class ? " " : "\n"));
  if (language == knr)
    {
      for (i = 0; i < fndesc->numargs; ++i)
	{
	  fprintf (fp, "%s %s;\n",
		   name_from_type (fndesc->args[i].type),
		   fndesc->args[i].name);
	}
    }
  fprintf(fp, "{");
  fprintf (fp, (fndesc->class ? " " : "\n"));
  if (fndesc->class)
    {
      /* (should generate something for the method sometimes) */
    }
  else
    {
      /* Generate a plausible function body by writing a number of
	 statements. */
      for (k = 0; k < function_length; ++k)
	{
	  write_statement (fp, 1, function_depth - 1 + xrandom (3));
	}
    }
  /* Write a return statement if appropriate.  */
  if (fndesc->return_type != t_void)
    {
      fprintf (fp, "  return 0;");
      fprintf (fp, (fndesc->class ? " " : "\n"));
    }
  fprintf (fp, "}");
  if (fndesc->class)
    fprintf (fp, ";");
  fprintf (fp, "\n");
}

/* Write "library source", which really just means empty function
   bodies, done so the program will link.  */

void
write_lib_source_file (void)
{
  char tmpbuf[100];
  int j;
  FILE *fp;

  sprintf (tmpbuf, "%slib.%s", file_base_name, extensions[language]);
  fp = fopen (tmpbuf, "w");
  if (fp == NULL)
    return;
  write_description_block (fp);
  if (1 /*num_lib_header_files*/ > 0)
    {
      for (j = 0; j < 1 /*num_lib_header_files*/; ++j)
	{
	  fprintf (fp, "#include \"%slib.h\"\n", file_base_name);
	}
      fprintf (fp, "\n");
    }

  for (j = 0; j < num_lib_functions; ++j)
    {
      write_lib_function (fp, j);
    }
  fclose (fp);
}

/* Generate empty bodies for library function definitions.  */

void
write_lib_function (FILE *fp, int n)
{
  int i;

  fprintf (fp, "%s\n%s (",
	   name_from_type (lib_functions[n].return_type),
	   lib_functions[n].name);
  for (i = 0; i < lib_functions[n].numargs; ++i)
    {
      if (language != knr)
	{
	  fprintf (fp, "%s ", name_from_type (lib_functions[n].args[i].type));
	}
      fprintf (fp, "%s", lib_functions[n].args[i].name);
      if (i + 1 < lib_functions[n].numargs)
	fprintf (fp, ", ");
    }
  fprintf (fp, ")");
  if (!lib_functions[n].use)
    fprintf (fp, " /* unused */");
  fprintf (fp, "\n");
  if (language == knr)
    {
      for (i = 0; i < lib_functions[n].numargs; ++i)
	{
	  fprintf (fp, "%s %s;\n",
		   name_from_type (lib_functions[n].args[i].type),
		   lib_functions[n].args[i].name);
	}
    }
  fprintf (fp, "{\n");
  if (lib_functions[n].return_type != t_void)
    fprintf (fp, "  return 0;\n");
  fprintf (fp, "}\n\n");
}

void
write_statement (FILE *fp, int depth, int max_depth)
{
  int i;

  for (i = 0; i < depth; ++i)
    fprintf (fp, "  ");
  /* Always do non-recursive statements if going too deep. */
  if (depth >= max_depth)
    {
      write_expression (fp, t_void, 0, xrandom(4) + 1, 0);
      fprintf (fp, ";\n");
      return;
    }
  switch (xrandom(2))
    {
    case 0:
      write_expression (fp, t_void, 0, xrandom(4) + 1, 0);
      fprintf (fp, ";");
      break;
    case 1:
      fprintf (fp, "if (");
      write_expression (fp, t_int, 0, xrandom(2) + 1, 0);
      fprintf (fp, ") {\n");
      write_statement(fp, depth + 1, max_depth);
      for (i = 0; i < depth; ++i)
	fprintf (fp, "  ");
      fprintf (fp, "}");
      break;
    }
  fprintf(fp, "\n");
}

/* Write a single expression. */

void cast_integer_type (FILE *fp, int type);
struct function_desc *find_function (int rslttype,
				     struct function_desc *fns, int numfns);
struct macro_desc *find_macro (int rslttype,
			       struct macro_desc *macs, int nummacros,
			       int exclude_id);

void
write_expression (FILE *fp, int rslttype, int depth, int max_depth,
		  int exclude_id)
{
  int n, n2, j;
  struct macro_desc *macrodesc;
  struct function_desc *fndesc;

  /* Always do non-recursive statements if going too deep. */
  if (depth >= max_depth)
    {
      switch (xrandom(10))
	{
	case 7:
	  cast_integer_type (fp, rslttype);
	  fprintf (fp, "%d", xrandom (1000));
	  break;
	default:
	  cast_integer_type (fp, rslttype);
	  fprintf (fp, "%d", xrandom (127));
	  break;
	}
      return;
    }
  switch (xrandom(10))
    {
    case 0:
      fndesc = find_function (rslttype, lib_functions, num_lib_functions);
      if (fndesc == NULL)
	{
	  cast_integer_type (fp, rslttype);
	  fprintf (fp, "%d", xrandom (100));
	  return;
	}
      fprintf (fp, "%s (", fndesc->name);
      for (j = 0; j < fndesc->numargs; ++j)
	{
	  if (j > 0)
	    fprintf (fp, ", ");
	  write_expression (fp, fndesc->args[j].type, depth + 1,
			    max_depth - 1, exclude_id);
	}
      fprintf(fp, ")");
      break;
    case 7:
      fndesc = find_function (rslttype, functions, num_functions);
      if (fndesc == NULL)
	{
	  cast_integer_type (fp, rslttype);
	  fprintf (fp, "%d", xrandom (100));
	  return;
	}
      fprintf (fp, "%s (", fndesc->name);
      for (j = 0; j < fndesc->numargs; ++j)
	{
	  if (j > 0)
	    fprintf (fp, ", ");
	  write_expression (fp, fndesc->args[j].type, depth + 1,
			    max_depth - 1, exclude_id);
	}
      fprintf(fp, ")");
      break;
    case 1:
    case 6:
      macrodesc = find_macro (t_int, lib_macros, num_lib_macros, exclude_id);
      if (macrodesc == NULL)
	{
	  cast_integer_type (fp, rslttype);
	  fprintf (fp, "%d", xrandom (100));
	  return;
	}
      cast_integer_type (fp, rslttype);
      fprintf (fp, "%s", macrodesc->name);
      if (macrodesc->numargs >= 0)
	{
	  fprintf (fp, " (");
	  for (j = 0; j < macrodesc->numargs; ++j)
	    {
	      if (j > 0)
		fprintf (fp, ", ");
	      write_expression (fp, t_int, depth + 1, max_depth - 1,
				exclude_id);
	    }
	  fprintf (fp, ")");
	}
      break;
    case 8:
      macrodesc = find_macro (t_int, macros, num_macros, exclude_id);
      if (macrodesc == NULL)
	{
	  cast_integer_type (fp, rslttype);
	  fprintf (fp, "%d", xrandom (100));
	  return;
	}
      cast_integer_type (fp, rslttype);
      fprintf (fp, "%s", macrodesc->name);
      if (macrodesc->numargs >= 0)
	{
	  fprintf (fp, " (");
	  for (j = 0; j < macrodesc->numargs; ++j)
	    {
	      if (j > 0)
		fprintf (fp, ", ");
	      write_expression (fp, t_int, depth + 1, max_depth - 1,
				exclude_id);
	    }
	  fprintf (fp, ")");
	}
      break;
    case 2:
      cast_integer_type (fp, rslttype);
      fprintf (fp, "(");
      write_expression (fp, t_int, depth + 1, max_depth, exclude_id);
      fprintf (fp, " + ");
      write_expression (fp, t_int, depth + 1, max_depth, exclude_id);
      fprintf (fp, ")");
      break;
    case 3:
      cast_integer_type (fp, rslttype);
      fprintf (fp, "(");
      write_expression (fp, t_int, depth + 1, max_depth, exclude_id);
      fprintf (fp, " - ");
      write_expression (fp, t_int, depth + 1, max_depth, exclude_id);
      fprintf (fp, ")");
      break;
    case 4:
      cast_integer_type (fp, rslttype);
      fprintf (fp, "(");
      write_expression (fp, t_int, depth + 1, max_depth, exclude_id);
      fprintf (fp, " * ");
      write_expression (fp, t_int, depth + 1, max_depth, exclude_id);
      fprintf (fp, ")");
      break;
    case 5:
      cast_integer_type (fp, rslttype);
      n = xrandom (num_enums);
      n2 = xrandom (enums[n].num_enumerators);
      fprintf (fp, "%s", enums[n].enumerators[n2].name);
      break;
    default:
      cast_integer_type (fp, rslttype);
      fprintf (fp, "%d", xrandom (127));
      break;
    }
}

void
cast_integer_type (FILE *fp, int type)
{
  if (type == t_void || type == t_int)
    return;
  fprintf (fp, "(%s) ", name_from_type (type));
}

struct macro_desc *
find_macro (int rslttype, struct macro_desc *macs, int nummacros,
	    int exclude_id)
{
  int j, n;

  for (j = 0; j < 1000; ++j)
    {
      n = xrandom (nummacros);
      if (macs[n].use && macs[n].id > exclude_id)
	return &(macs[n]);
    }
  return NULL;
}

/* Find a function that has the right return type.  */

struct function_desc *
find_function (int rslttype, struct function_desc *fns, int numfns)
{
  int j, n;

  /* Try several times, but eventually give up.  */
  for (j = 0; j < 1000; ++j)
    {
      n = xrandom (numfns);
      if (fns[n].use && fns[n].return_type == rslttype)
	return &(fns[n]);
    }
  return NULL;
}

/* Write out a comment block that lists all the parameters used to
   generate this program.  */

void
write_description_block (FILE *fp)
{
  extern unsigned long initial_randstate;

  fprintf (fp, "/* A fine software product by SPU %s.  */\n",
	   version_string);
  fprintf (fp, "/* Written in %s. */\n", lang_names[language]);
  fprintf (fp, "/* Program: %d macros, %d enums, %d structs, %d classes, %d functions, */\n",
	   num_macros, num_enums, num_structs, num_classes, num_functions);
  fprintf (fp, "/* divided into %d source file(s) and %d header(s).  */\n",
	   num_files, num_header_files);
  fprintf (fp, "/* Library: %d macros, %d enums, %d structs, %d classes, %d functions. */\n",
	   num_lib_macros, num_lib_enums, num_lib_structs, num_lib_classes,
	   num_lib_functions);
  fprintf (fp, "/* Enumerators per enum range from %d to %d.  */\n",
	   num_enumerators / 2, num_enumerators + 1);
  fprintf (fp, "/* Fields per struct/class range from %d to %d.  */\n",
	   1, num_fields);
  if (num_classes > 0 || num_lib_classes > 0)
    fprintf (fp, "/* Methods per class range from %d to %d.  */\n",
	     0, num_methods);
  fprintf (fp, "/* Function length is %d statements, expression depth is %d.  */\n",
	   function_length, function_depth);
  fprintf (fp, "/* Random seed is %d.  */\n", (int) initial_randstate);
  fprintf (fp, "\n");
}

/* Write out a makefile that will compile the program just generated. */

void
write_makefile (void)
{
  char tmpbuf[100];
  int i, j;
  FILE *fp;

  sprintf (tmpbuf, "%s.mk", file_base_name);
  fp = fopen (tmpbuf, "w");
  if (fp)
    {
      /* Name the compiler so we can change it easily.  */
      fprintf (fp, "CC = cc\n\n");
      /* Write dependencies and action line for the executable.  */
      fprintf (fp, "%s.out:	", file_base_name);
      for (i = 0; i < num_files; ++i)
	fprintf (fp, " %s%d.o", file_base_name, i);
      fprintf (fp, " %slib.o", file_base_name);
      fprintf (fp, "\n");
      fprintf (fp, "\t$(CC) -o %s.out", file_base_name);
      for (i = 0; i < num_files; ++i)
	fprintf (fp, " %s%d.o", file_base_name, i);
      fprintf (fp, " %slib.o", file_base_name);
      fprintf (fp, "\n\n");
      /* Write dependencies for individual files. */
      for (i = 0; i < num_files; ++i)
	{
	  fprintf (fp, " %s%d.o:	%s%d.%s",
		   file_base_name, i, file_base_name, i,
		   extensions[language]);
	  for (j = 0; j < num_header_files; ++j)
	    fprintf (fp, " %s%d.h", file_base_name, j);
	  fprintf (fp, "\n");
	  fprintf (fp, "\t$(CC) -c %s%d.%s\n",
		   file_base_name, i, extensions[language]);
	}

      /* Library stuff.  */
      fprintf (fp, "\nlib:	%slib.o\n\n", file_base_name);
      fprintf (fp, " %slib.o:	%slib.%s %slib.h",
	       file_base_name, file_base_name, extensions[language],
	       file_base_name);
      fprintf (fp, "\n");
      fprintf (fp, "\t$(CC) -c %slib.%s\n",
	       file_base_name, extensions[language]);
      fclose (fp);
    }
}

/* Utility/general functions. */

/* Generate a name that is guaranteed to be a valid C/C++ identifier.  */

char *
gen_unique_global_name (char *root, int upcase)
{
  int i, j;
  char *str, namebuf[100];

  if (global_hash_table == NULL)
    {
      global_hash_table =
	(struct hash_table *) xmalloc (sizeof (struct hash_table));
    }
  str = NULL;
  /* Keep trying until we get a unique name. */
  for (i = 0; i < 10000; ++i)
    {
      gen_random_global_name (root, namebuf);
      if (upcase)
	{
	  for (j = 0; namebuf[j] != '\0'; ++j)
	    namebuf[j] = toupper (namebuf[j]);
	}
      if (get_from_hash_table (namebuf, global_hash_table) == NULL)
	{
	  str = add_to_hash_table (namebuf, global_hash_table);
	  break;
	}
    }
  if (str == NULL)
    {
      fprintf (stderr, "Can't get a unique name!\n");
      exit(1);
    }
  return str;
}

/* Synthesize a random name that is a valid C/C++ identifier and that
   "looks like" something one might see in a program.  */

void
gen_random_global_name (char *root, char *namebuf)
{
  char smallbuf[100];
  int n, i, len;

  namebuf[0] = '\0';
  switch (xrandom (4))
    {
    case 0:
      namebuf[0] = 'a' + xrandom (26);
      namebuf[1] = '\0';
      break;
    case 1:
      /* Convert a random number into a string, maybe with some
	 underscores thrown in for flavor.  */
      n = xrandom (10000);
      i = 0;
      while (n > 0)
	{
	  if (xrandom (6) == 0)
	    namebuf[i++] = '_';
	  namebuf[i++] = 'a' + (n % 26);
	  n /= 26;
	}
      namebuf[i] = '\0';
      break;
    default:
      strcat (namebuf, random_computer_word ());
      break;
    }
  if (root != NULL)
    {
      strcat (namebuf, "_");
      strcat (namebuf, root);
    }
  switch (xrandom (5))
    {
    case 0:
      strcat (namebuf, "_");
      len = strlen (namebuf);
      namebuf[len] = 'a' + xrandom (26);
      namebuf[len + 1] = '\0';
      break;
    case 1:
      strcat (namebuf, "_");
      sprintf (smallbuf, "%d", xrandom (10000));
      strcat (namebuf, smallbuf);
      break;
    case 2:
      n = xrandom (10000);
      len = strlen (namebuf);
      i = len;
      while (n > 0)
	{
	  if (xrandom (6) == 0)
	    namebuf[i++] = '_';
	  namebuf[i++] = 'a' + (n % 26);
	  n /= 26;
	}
      namebuf[i] = '\0';
      break;
    default:
      strcat (namebuf, "_");
      strcat (namebuf, random_computer_word ());
      break;
    }
  if (xrandom (5) == 0)
    {
      strcat (namebuf, "_");
      sprintf (smallbuf, "%d", xrandom (10000));
      strcat (namebuf, smallbuf);
    }
#if 0 /* enable to study random name distribution */
  printf ("Try %s\n", namebuf);
#endif
}

/* Generate a local variable name. */

char *
gen_random_local_name (int numothers, char **others)
{
  char namebuf[100];

  sprintf (namebuf, "%s%d",
	   (xrandom (2) == 0 ? random_computer_word () : "arg"),
	   numothers + 1);
  return copy_string (namebuf);
}

/* Generic hash table code. */

int
hash_string (char *str)
{
  int i, rslt;

  rslt = 0;
  for (i = 0; str[i] != '\0'; ++i)
    {
      rslt ^= str[i];
      rslt %= 253;
    }
  return rslt;
}

struct hash_entry *
get_hash_entry (void)
{
  return (struct hash_entry *) xmalloc (sizeof (struct hash_entry));
}

char *
add_to_hash_table (char *buf, struct hash_table *table)
{
  int hash;
  struct hash_entry *ent, *lastent;

  if (buf == NULL)
    buf = "";
  ++(table->numadds);
  hash = hash_string (buf);
  if (table->entries[hash] == NULL)
    {
      table->entries[hash] = get_hash_entry ();
      table->entries[hash]->val = copy_string (buf);
      return table->entries[hash]->val;
    }
  else
    {
      for (ent = table->entries[hash]; ent != NULL; ent = ent->next)
	{
	  if (ent->val == NULL)
	    return "null!?!";
	  if (strcmp (buf, ent->val) == 0)
	    return ent->val;
	  lastent = ent;
	}
      if (lastent != NULL)
	{
	  lastent->next = get_hash_entry ();
	  lastent->next->val = copy_string (buf);
	  return lastent->next->val;
	}
    }
  /* should never happen */
  return "?!hash!?";
}

char *
get_from_hash_table (char *buf, struct hash_table *table)
{
  int hash;
  struct hash_entry *ent, *lastent;

  if (buf == NULL)
    buf = "";
  hash = hash_string (buf);
  if (table->entries[hash] == NULL)
    {
      return NULL;
    }
  else
    {
      for (ent = table->entries[hash]; ent != NULL; ent = ent->next)
	{
	  if (ent->val == NULL)
	    return "null!?!";
	  if (strcmp (buf, ent->val) == 0)
	    return ent->val;
	  lastent = ent;
	}
      if (lastent != NULL)
	{
	  return NULL;
	}
    }
  /* should never happen */
  return "?!hash!?";
}

/* Random number handling is important but terrible/nonexistent in
   some systems.  Do it ourselves.  Also, this will give repeatable
   results across multiple platforms, which is important if this is
   being used to generate test cases. */

/* The random state *must* be at least 32 bits.  */

unsigned long initial_randstate = 0;

unsigned long randstate = 0;

/* Seed can come from elsewhere, for repeatability.  Otherwise, it comes
   from the current time, scaled down to where 32-bit arithmetic won't
   overflow.  */

void
init_xrandom (int seed)
{
  time_t tm;
    	
  if (seed > 0)
    {
      /* If the random state is already set, changes are somewhat
	 suspicious.  */
      if (randstate > 0)
	{
	  fprintf (stderr, "Randstate being changed from %lu to %d\n",
		   randstate, seed);
	}
      randstate = seed;
    }
  else
    {
      time (&tm);
      randstate = tm;
    }
  /* Whatever its source, put the randstate into known range (0 - 199999).  */
  randstate = abs (randstate);
  randstate %= 200000;
  /* This is kept around for the sake of error reporting. */
  initial_randstate = randstate;
}

/* Numbers lifted from Numerical Recipes, p. 198.  */
/* Arithmetic must be 32-bit.  */

int
xrandom (int m)
{
  int rslt;

  randstate = (9301 * randstate + 49297) % 233280;
  rslt = (m * randstate) / 233280;
#if 0 /* enable to study random number distribution */
  printf ("# %lu -> %d\n", randstate, rslt);
#endif
  return rslt;
}

/* Percentage probability, with bounds checking. */

int
probability(int prob)
{
  if (prob <= 0)
    return 0;
  if (prob >= 100)
    return 1;
  return (xrandom (100) < prob);
}

char *
xmalloc (int amt)
{
  char *value = (char *) malloc (amt);

  if (value == NULL)
    {
      /* This is pretty serious, have to get out quickly.  */
      fprintf (stderr, "Memory exhausted!!\n");
      exit (1);
    }
  /* Save callers from having to clear things themselves.  */
  memset (value, 0, amt);
  return value;
}

/* Copy a string to newly-allocated space.  The new space is never
   freed.  */

char *
copy_string (char *str)
{
  int len = strlen (str);
  char *rslt;
  
  rslt = xmalloc (len + 1);
  strcpy (rslt, str);
  return rslt;
}
@


1.4
log
@	* spu.c: Bump to version 0.4; add random ordering of definitions
	and declarations in header files, add return type to functions,
	handle result type when generating expressions, add more computer
	words, generate more variety of types, generate casts around
	mistyped expressions, increase random number period.
	* README: Update version number.
@
text
@d29 1
a29 1
char *version_string = "0.4";
d56 6
d93 1
d149 11
d178 1
d193 1
d252 4
d274 3
a276 1
void write_function_decl (FILE *fp, struct function_desc *functiondesc);
d278 1
a278 1
void write_function (FILE *fp, int n);
d303 4
d329 6
d381 4
d459 5
d518 1
a518 1
	  else if (strcmp (argv[i+1], "cpp") == 0)
d526 5
d556 5
d583 2
d591 2
a592 1
  order.size = num_macros + num_enums + num_structs + num_functions;
d596 1
a596 1
  lib_order.size = num_lib_macros + num_lib_enums + num_lib_structs + num_lib_functions;
d604 1
d625 1
d637 1
d643 1
d741 3
d747 3
d935 34
a968 1
/* Create a number of functions with random numbers of arguments. */
d970 25
a994 1
/* (should gen with random arg types also) */
d1085 1
d1122 2
d1141 3
d1147 4
d1176 2
d1195 3
d1201 4
d1213 1
a1213 1
  int i, j;
d1289 22
d1370 1
a1370 1
      write_function (fp, n * num_functions_per_file + j);
d1375 2
d1378 1
a1378 1
write_function (FILE *fp, int n)
d1382 6
a1387 3
  fprintf(fp, "%s\n%s (",
	  name_from_type (functions[n].return_type), functions[n].name);
  for (i = 0; i < functions[n].numargs; ++i)
d1391 1
a1391 1
	  fprintf (fp, "%s ", name_from_type (functions[n].args[i].type));
d1393 2
a1394 2
      fprintf (fp, "%s", functions[n].args[i].name);
      if (i + 1 < functions[n].numargs)
d1397 2
a1398 1
  fprintf(fp, ")\n");
d1401 1
a1401 1
      for (i = 0; i < functions[n].numargs; ++i)
d1404 2
a1405 2
		   name_from_type (functions[n].args[i].type),
		   functions[n].args[i].name);
d1408 3
a1410 4
  fprintf(fp, "{\n");
  /* Generate a plausible function body by writing a number of
     statements. */
  for (k = 0; k < function_length; ++k)
d1412 10
a1421 1
      write_statement (fp, 1, function_depth - 1 + xrandom (3));
d1424 1
a1424 1
  if (functions[n].return_type != t_void)
d1426 2
a1427 1
      fprintf (fp, "  return 0;\n");
d1429 4
a1432 1
  fprintf (fp, "}\n\n");
a1557 1
    getout:
d1723 1
d1741 1
a1741 1
  fprintf (fp, "/* A fine software product by SPU %s  */\n",
d1743 18
a1760 6
  fprintf (fp, "/* Program: %d macros, %d enums, %d structs, %d functions */\n",
	   num_macros, num_enums, num_structs, num_functions);
  fprintf (fp, "/* Library: %d macros, %d enums, %d structs, %d functions */\n",
	   num_lib_macros, num_lib_enums, num_lib_structs, num_lib_functions);
  fprintf (fp, "/* Random seed is %d */\n", (int) initial_randstate);
  /* (should write all other parameters too) */
@


1.3
log
@	* spu.c: Bump to version 0.3; make all space dynamically sized
	and allocated, add generation of library constructs of which
	only a given percentage are used in the generated program.
	(main): New options --lib-enums, --lib-functions, --lib-macros,
	--lib-structs.
	* README: Update version number.
@
text
@d27 1
d29 1
a29 1
char *version_string = "0.3";
d82 20
d104 1
d118 1
d133 1
d155 1
d157 1
d168 18
d228 1
a228 1
void create_struct (struct struct_desc *structdesc);
d234 1
a234 1
void create_function (struct function_desc *fndesc);
d242 2
d258 4
a261 1
void write_expression (FILE *fp, int depth, int max_depth);
d313 2
d329 2
d349 4
d361 4
a364 3
  "by", "btree",
  "count", "create", "cull",
  "del", "delete_", "desc", "discard", "dismiss",
d366 6
a371 4
  "grok",
  "last", "line", "lis", "list", "lose",
  "make", "mod", "modify", "more",
  "new_", "node", "null", "num",
d375 6
a380 4
  "pnt", "point", "pos", "position",
  "rect", "rectangle", "remove", "reset",
  "see", "set", "shape", "str",
  "tag", "tree",
d382 1
a382 1
  "win", "wind", "window",
d529 4
d534 8
a545 3
  /* Round up the number of functions so each file gets the same
     number. */
  num_functions_per_file = (num_functions + num_files - 1) / num_files;
d588 1
a588 1
random_type (void)
d590 31
a620 1
  return xrandom (3);
d628 41
a668 1
  switch (n)
d670 12
a681 4
    case 0:
      return "char";
    case 1:
      return "short";
d683 3
a685 1
  return "int";
d702 1
d704 6
d718 1
d727 1
d764 1
d766 1
a766 1
  printf ("Creating %d lib_enums...\n", num_lib_enums);
d774 1
d783 1
d815 2
a816 7
  printf ("Creating %d structs...\n", num_structs);
  structs =
    (struct struct_desc *) xmalloc (num_structs * sizeof(struct struct_desc));
  for (i = 0; i < num_structs; ++i)
    {
      create_struct (&(structs[i]));
    }
d822 1
a822 1
      create_struct (&(lib_structs[i]));
d825 10
d839 1
a839 1
create_struct (struct struct_desc *structdesc)
d843 1
d850 1
a850 1
      structdesc->fields[j].type = random_type ();
d879 1
d881 1
d883 1
d885 4
a888 2
  /* Generate all the other functions.  The bodies don't get created
     until the functions are being written out.  */
d891 17
a907 1
      create_function (&(functions[i]));
d915 2
a916 1
      create_function (&(lib_functions[i]));
d919 1
d926 1
a926 1
create_function (struct function_desc *fndesc)
d930 1
d932 4
a935 2
  /* Choose the number of arguments, preferring shorter argument
     lists by using a simple binomial distribution.  */
d949 1
a949 3
  fndesc->args =
    (struct arg_desc *) xmalloc (numargs * sizeof(struct arg_desc));
  for (j = 0; j < numargs; ++j)
d951 7
a957 2
      fndesc->args[j].type = 0;
      fndesc->args[j].name = gen_random_local_name (j, NULL);
d963 13
d985 16
a1000 1
  if (fp)
d1002 1
a1002 3
      if (commenting > 0)
	fprintf (fp, "/* header */\n");
      if (1)
d1004 12
a1015 31
	  printf ("Writing %d macros...\n", num_macros);
	  for (i = 0; i < num_macros; ++i)
	    {
	      write_macro (fp, &(macros[i]));
	    }
	}
      if (1)
	{
	  printf ("Writing %d enums...\n", num_enums);
	  printf ("  (Each enum contains up to %d values)\n", num_enumerators);
	  for (i = 0; i < num_enums; ++i)
	    {
	      write_enum (fp, &(enums[i]));
	    }
	}
      if (1)
	{
	  printf ("Writing %d structs...\n", num_structs);
	  printf ("  (Each struct contains %d fields)\n", num_fields);
	  for (i = 0; i < num_structs; ++i)
	    {
	      write_struct (fp, &(structs[i]));
	    }
	}
      if (1)
	{
	  printf ("Writing %d function decls...\n", num_functions);
	  for (i = 0; i < num_functions; ++i)
	    {
	      write_function_decl (fp, &(functions[i]));
	    }
a1016 1
      fclose (fp);
d1018 1
d1030 16
a1045 1
  if (fp)
d1047 1
a1047 3
      if (commenting > 0)
	fprintf (fp, "/* library header */\n");
      if (1)
d1049 12
a1060 14
	  printf ("Writing %d library macros...\n", num_lib_macros);
	  for (i = 0; i < num_lib_macros; ++i)
	    {
	      write_macro (fp, &(lib_macros[i]));
	    }
	}
      if (1)
	{
	  printf ("Writing %d library enums...\n", num_lib_enums);
	  printf ("  (Each enum contains up to %d values)\n", num_enumerators);
	  for (i = 0; i < num_lib_enums; ++i)
	    {
	      write_enum (fp, &(lib_enums[i]));
	    }
a1061 18
      if (1)
	{
	  printf ("Writing %d library structs...\n", num_lib_structs);
	  printf ("  (Each struct contains %d fields)\n", num_fields);
	  for (i = 0; i < num_lib_structs; ++i)
	    {
	      write_struct (fp, &(lib_structs[i]));
	    }
	}
      if (1)
	{
	  printf ("Writing %d lib function decls...\n", num_lib_functions);
	  for (i = 0; i < num_lib_functions; ++i)
	    {
	      write_function_decl (fp, &(lib_functions[i]));
	    }
	}
      fclose (fp);
d1063 1
d1071 1
a1071 1
  fprintf (fp, "#define %s", macrodesc->name);
d1086 2
a1087 1
  switch (xrandom(2))
d1090 9
a1098 24
      fprintf (fp, " \\\n");
      fprintf (fp, "(");
      if (macrodesc->numargs > 0)
	{
	  for (i = 0; i < macrodesc->numargs; ++i)
	    {
	      if (i > 0)
		fprintf (fp, ",");
	      fprintf (fp, " \\\n");
	      fprintf (fp, "  (%s)", macrodesc->args[i]);
	      if (xrandom (2) == 0)
		{
		  fprintf (fp, ",");
		  fprintf (fp, " \\\n");
		  fprintf (fp, " ((int) (%s))", macrodesc->args[i]);
		}
	    }
	  fprintf (fp, " \\\n");
	}
      else
	{
	  fprintf (fp, " (1)");
	}
      fprintf (fp, ")");
d1101 1
a1101 1
      fprintf (fp, " (%d)", xrandom (100));
d1104 1
d1115 1
a1115 1
  fprintf (fp, "enum");
d1135 1
a1135 1
  fprintf (fp, "struct %s {\n", structdesc->name);
d1150 2
a1151 1
  fprintf (fp, "int %s (", fndesc->name);
d1156 3
a1158 1
	  fprintf (fp, "int %s", fndesc->args[i].name);
a1173 1
  extern unsigned long initial_randstate;
d1178 4
a1181 1
  if (fp)
d1183 1
a1183 4
      fprintf (fp,
	       "/* A fine software product by SPU %s, random seed == %d */\n\n",
	       version_string, (int) initial_randstate);
      if (1 /*num_lib_header_files*/ > 0)
d1185 1
a1185 5
	  for (j = 0; j < 1 /*num_header_files*/; ++j)
	    {
	      fprintf (fp, "#include \"%slib.h\"\n", file_base_name);
	    }
	  fprintf (fp, "\n");
d1187 5
a1191 1
      if (num_header_files > 0)
d1193 1
a1193 5
	  for (j = 0; j < num_header_files; ++j)
	    {
	      fprintf (fp, "#include \"%s%d.h\"\n", file_base_name, j);
	    }
	  fprintf (fp, "\n");
d1195 2
d1198 3
a1200 3
      if (n == 0)
	printf ("  (Each file contains %d functions)\n",
		num_functions_per_file);
d1202 3
a1204 4
      for (j = 0; j < num_functions_per_file; ++j)
	{
	  write_function (fp, n * num_functions_per_file + j);
	}
d1214 2
a1215 1
  fprintf(fp, "int\n%s (", functions[n].name);
d1220 1
a1220 1
	  fprintf (fp, "int ");
d1231 3
a1233 1
	  fprintf (fp, "int %s;\n", functions[n].args[i].name);
d1243 5
d1251 3
d1263 4
a1266 1
  if (fp)
d1268 1
a1268 1
      if (1 /*num_lib_header_files*/ > 0)
d1270 1
a1270 5
	  for (j = 0; j < 1 /*num_header_files*/; ++j)
	    {
	      fprintf (fp, "#include \"%slib.h\"\n", file_base_name);
	    }
	  fprintf (fp, "\n");
d1272 2
d1275 3
a1277 4
      for (j = 0; j < num_lib_functions; ++j)
	{
	  write_lib_function (fp, j);
	}
d1289 3
a1291 1
  fprintf (fp, "int\n%s (", lib_functions[n].name);
d1296 1
a1296 1
	  fprintf (fp, "int ");
d1304 1
a1304 1
    fprintf (fp, "/* unused */");
d1310 3
a1312 1
	  fprintf (fp, "int %s;\n", lib_functions[n].args[i].name);
d1316 2
d1331 1
a1331 1
      write_expression (fp, 0, xrandom(4) + 1);
d1338 1
a1338 1
      write_expression (fp, 0, xrandom(4) + 1);
d1343 1
a1343 1
      write_expression (fp, 0, xrandom(2) + 1);
d1356 7
d1364 2
a1365 1
write_expression (FILE *fp, int depth, int max_depth)
d1368 2
d1378 1
d1382 1
d1391 2
a1392 1
      for (j = 0; j < 1000; ++j)
d1394 6
a1399 9
	  n = xrandom (num_lib_functions);
	  if (lib_functions[n].use)
	    break;
	}
      if (!lib_functions[n].use)
	goto getout;
      n = xrandom (num_lib_functions);
      fprintf(fp, "%s (", lib_functions[n].name);
      for (j = 0; j < lib_functions[n].numargs; ++j)
d1403 2
a1404 1
	  write_expression(fp, depth + 1, max_depth - 1);
d1409 9
a1417 3
      n = xrandom (num_functions);
      fprintf(fp, "%s (", functions[n].name);
      for (j = 0; j < functions[n].numargs; ++j)
d1421 2
a1422 1
	  write_expression(fp, depth + 1, max_depth - 1);
d1428 2
a1429 1
      for (j = 0; j < 1000; ++j)
d1431 7
a1437 8
	  n = xrandom (num_lib_macros);
	  if (lib_macros[n].use)
	    break;
	}
      if (!lib_macros[n].use)
	goto getout;
      fprintf(fp, "%s", lib_macros[n].name);
      if (lib_macros[n].numargs >= 0)
d1439 2
a1440 2
	  fprintf(fp, " (");
	  for (j = 0; j < lib_macros[n].numargs; ++j)
d1444 2
a1445 1
	      write_expression(fp, depth + 1, max_depth - 1);
d1447 1
a1447 1
	  fprintf(fp, ")");
d1451 10
a1460 3
      n = xrandom (num_macros);
      fprintf(fp, "%s", macros[n].name);
      if (macros[n].numargs >= 0)
d1462 2
a1463 2
	  fprintf(fp, " (");
	  for (j = 0; j < macros[n].numargs; ++j)
d1467 2
a1468 1
	      write_expression(fp, depth + 1, max_depth - 1);
d1470 1
a1470 1
	  fprintf(fp, ")");
d1474 3
a1476 1
      write_expression (fp, depth + 1, max_depth);
d1478 2
a1479 1
      write_expression (fp, depth + 1, max_depth);
d1482 3
a1484 1
      write_expression (fp, depth + 1, max_depth);
d1486 2
a1487 1
      write_expression (fp, depth + 1, max_depth);
d1490 3
a1492 1
      write_expression (fp, depth + 1, max_depth);
d1494 2
a1495 1
      write_expression (fp, depth + 1, max_depth);
d1498 1
d1504 1
d1510 58
d1584 1
a1584 1
      fprintf (fp, "%s:	", file_base_name);
d1606 3
d1619 1
d1621 1
a1621 1
/* Utility/general functions. */
d1636 1
a1636 1
  for (i = 0; i < 100; ++i)
d1658 3
d1681 1
a1681 1
	  if (xrandom(6) == 0)
d1697 1
a1697 1
  switch (xrandom (4))
d1710 13
d1728 9
a1842 2
#include <time.h>

d1879 1
a1879 1
  /* Whatever its source, put the randstate into known range (0 - 99999).  */
d1881 1
a1881 1
  randstate %= 100000L;
d1892 8
a1899 2
  randstate = (8121 * randstate + 28411) % 134456L;
  return ((m * randstate) / 134456L);
d1911 1
a1911 1
  return (xrandom(100) < prob);
@


1.2
log
@	* spu.c: Rewrite almost everything; add enum generation, C++
	output, unique global name generation, more types of expressions.
	* README: Update to reflect changes.
@
text
@d28 1
a28 1
char *version_string = "0.2";
d39 1
a39 1
#define DEFAULT_NUM_ENUMS 10
d41 1
a41 1
#define DEFAULT_NUM_ENUMERATORS 5
d43 1
a43 1
#define DEFAULT_NUM_STRUCTS 20
d45 1
a45 1
#define DEFAULT_NUM_FIELDS 20
d47 1
a47 1
#define DEFAULT_NUM_FUNCTIONS 100
d49 1
a49 1
#define DEFAULT_FUNCTION_LENGTH 20
d51 1
a51 1
#define DEFAULT_FUNCTION_DEPTH 3
d53 1
a53 1
/* The limits on these should be eliminated... */
d55 1
a55 1
#define MAX_MACROS 50000
d57 1
a57 1
#define MAX_MACRO_ARGS 10
d59 1
a59 1
#define MAX_ENUMS 1000
d61 1
a61 1
#define MAX_ENUMERATORS 1000
d63 1
a63 1
#define MAX_STRUCTS 1000
d65 1
a65 5
#define MAX_STRUCT_FIELDS 100

#define MAX_FUNCTIONS 100000

#define MAX_FUNCTION_ARGS 20
d85 2
a86 1
  char *args[MAX_MACRO_ARGS];
d98 2
a99 1
  struct enumerator_desc enumerators[MAX_ENUMERATORS];
d112 2
a113 1
  struct field_desc fields[MAX_STRUCT_FIELDS];
d123 6
d133 2
a134 1
  char *args[MAX_FUNCTION_ARGS];
d158 2
d172 2
d178 1
a178 1
char *gen_new_enum_name (void);
d184 1
a184 1
char *gen_new_struct_name (void);
d190 1
a190 1
char *gen_new_function_name (void);
d194 2
d198 1
a198 1
void write_macro (FILE *fp, int n);
d200 1
a200 1
void write_enum (FILE *fp, int n);
d202 1
a202 1
void write_struct (FILE *fp, int n);
d204 1
a204 1
void write_function_decl (FILE *fp, int n);
d208 2
d236 2
d240 2
d246 2
d252 4
d260 4
d280 7
a286 1
struct macro_desc macros[MAX_MACROS];
d288 1
a288 1
struct enum_desc enums[MAX_ENUMS];
d290 1
a290 1
struct struct_desc structs[MAX_STRUCTS];
d292 3
a294 1
struct function_desc functions[MAX_FUNCTIONS];
d419 20
d479 2
d506 4
d537 2
a538 1
/* Create basic definitions of macros.  */
d543 1
a543 1
  int i, j, numargs;
d546 2
d550 24
a573 3
      macros[i].name = gen_new_macro_name ();
      numargs = xrandom (MAX_MACRO_ARGS + 1);
      --numargs;
d576 1
a576 1
	  macros[i].args[j] = gen_random_local_name (j, NULL);
a577 1
      macros[i].numargs = numargs;
d579 2
d596 1
a596 1
  int i, j, num;
d599 2
d603 10
a612 9
      /* Let some enums be anonymous. */
      if (xrandom (100) < 50)
	enums[i].name = gen_new_enum_name ();
      num = num_enumerators / 2 + xrandom (num_enumerators);
      for (j = 0; j < num; ++j)
	{
	  enums[i].enumerators[j].name = gen_random_enumerator_name ();
	}
      enums[i].num_enumerators = j;
d616 4
a619 1
/* Generate a unique enum name.  */
d621 14
a634 4
char *
gen_new_enum_name ()
{
  return gen_unique_global_name (NULL, 0);
d650 1
a650 1
  int i, j;
d653 2
d657 10
a666 7
      structs[i].name = gen_new_struct_name ();
      structs[i].numfields = xrandom (num_fields) + 1;
      for (j = 0; j < structs[i].numfields; ++j)
	{
	  structs[i].fields[j].type = random_type ();
	  structs[i].fields[j].name = gen_random_field_name (j);
	}
d670 4
a673 1
/* Generate a unique structure tag name.  */
d675 11
a685 4
char *
gen_new_struct_name (void)
{
  return gen_unique_global_name (NULL, 0);
d705 1
a705 1
  int i, j, maxargs, numargs;
d708 3
a710 1
  /* Generate the main program.  */
d717 11
a727 21
      functions[i].name = gen_new_function_name ();
      /* Choose the number of arguments, preferring shorter argument
	 lists by using a simple binomial distribution.  */
      maxargs = 2 * (MAX_FUNCTION_ARGS + 1);
      numargs = 0;
      for (j = 0; j < 6; ++j)
	{
	  numargs += xrandom (maxargs);
	}
      if (j > 0)
	numargs /= j;
      numargs -= MAX_FUNCTION_ARGS + 1;
      if (numargs < 0)
	numargs = -numargs;
      if (numargs > MAX_FUNCTION_ARGS)
	numargs = MAX_FUNCTION_ARGS;
      for (j = 0; j < numargs; ++j)
	{
	  functions[i].args[j] = gen_random_local_name (j, NULL);
	}
      functions[i].numargs = numargs;
d731 1
a731 1
/* Generate a function name.  */
d733 2
a734 2
char *
gen_new_function_name (void)
d736 27
a762 1
  return gen_unique_global_name ("fn", 0);
d783 1
a783 1
	      write_macro (fp, i);
d789 1
d792 1
a792 1
	      write_enum (fp, i);
d798 1
d801 1
a801 1
	      write_struct (fp, i);
d809 52
a860 1
	      write_function_decl (fp, i);
d868 1
a868 1
write_macro (FILE *fp, int n)
d872 1
a872 1
  fprintf (fp, "#define %s", macros[n].name);
d875 1
a875 1
  if (macros[n].numargs >= 0)
d878 1
a878 1
      for (j = 0; j < macros[n].numargs; ++j)
d882 1
a882 1
	  fprintf (fp, "%s", macros[n].args[j]);
d890 1
a890 1
      fprintf (fp, "\\\n");
d892 1
a892 1
      if (macros[n].numargs > 0)
d894 1
a894 1
	  for (i = 0; i < macros[n].numargs; ++i)
d899 1
a899 1
	      fprintf (fp, "  (%s)", macros[n].args[i]);
d904 1
a904 1
		  fprintf (fp, " ((int) (%s))", macros[n].args[i]);
d907 1
a907 1
	  fprintf (fp, "\\\n");
d925 1
a925 1
write_enum (FILE *fp, int i)
a928 2
  if (i == 0)
    printf ("  (Each enum contains up to %d values)\n", num_enumerators);
d930 2
a931 2
  if (enums[i].name)
    fprintf (fp, " %s", enums[i].name);
d933 1
a933 1
  for (j = 0; j < enums[i].num_enumerators; ++j)
d937 1
a937 1
      fprintf (fp, "\n  %s", enums[i].enumerators[j].name);
d945 1
a945 1
write_struct (FILE *fp, int i)
d949 2
a950 4
  if (i == 0)
    printf ("  (Each struct contains %d fields)\n", num_fields);
  fprintf (fp, "struct %s {\n", structs[i].name);
  for (j = 0; j < structs[i].numfields; ++j)
d953 2
a954 2
	       name_from_type (structs[i].fields[j].type),
	       structs[i].fields[j].name);
d960 1
a960 1
write_function_decl (FILE *fp, int n)
d964 1
a964 1
  fprintf (fp, "int %s (", functions[n].name);
d967 1
a967 1
      for (i = 0; i < functions[n].numargs; ++i)
d969 2
a970 2
	  fprintf (fp, "int %s", functions[n].args[i]);
	  if (i + 1 < functions[n].numargs)
d995 8
d1036 1
a1036 1
      fprintf (fp, "%s", functions[n].args[i]);
d1045 1
a1045 1
	  fprintf (fp, "int %s;\n", functions[n].args[i]);
d1059 61
d1162 1
d1177 18
d1208 21
d1231 2
a1232 2
      fprintf(fp, "%s(", macros[n].name);
      for (j = 0; j < macros[n].numargs; ++j)
d1234 8
a1241 3
	  if (j > 0)
	    fprintf (fp, ", ");
	  write_expression(fp, depth + 1, max_depth - 1);
a1242 1
      fprintf(fp, ")");
d1289 1
d1294 1
d1308 6
d1567 14
a1580 2
    randstate = (8121 * randstate + 28411) % 134456L;
    return ((m * randstate) / 134456L);
@


1.1
log
@Initial revision
@
text
@d1 2
a2 2
/* spu -- A program to make lots of random C code.
   Copyright (C) 1993, 1994 Free Software Foundation, Inc.
d24 3
d28 1
a28 1
#include "ansidecl.h"
d30 2
a31 10
/* The limits on these could be eliminated, but that would be
   some work.  As they stand, the limits are enough to generate
   some truly enormous programs...  */

#define MAXMACROS 50000
#define MAXMARGS 6
#define MAXSTRUCTS 1000
#define MAXSLOTS 20
#define MAXFUNCTIONS 50000
#define MAXFARGS 6
d33 54
a86 1
struct macro_desc {
d89 1
a89 1
  char *args[MAXMARGS];
d92 2
a93 1
struct slot_desc {
d97 2
a98 1
struct struct_desc {
d100 15
a114 2
  int numslots;
  struct slot_desc slots[MAXSLOTS];
d119 2
a120 1
struct type_desc {
d124 2
a125 1
struct function_desc {
d128 1
a128 1
  char *args[MAXFARGS];
d131 2
a132 1
struct file_desc {
d136 39
a174 2
void
display_usage PARAMS ((void));
d176 1
a176 2
void
init_xrandom PARAMS ((int seed));
d178 1
a178 2
int
xrandom PARAMS ((int n));
d180 1
a180 2
char *
copy_string PARAMS ((char *str));
d182 1
a182 2
char *
xmalloc PARAMS ((int n));
d184 1
a184 2
char *
gen_new_macro_name PARAMS ((int n));
d186 1
a186 2
char *
gen_random_name PARAMS ((char *root));
d188 1
a188 2
char *
gen_random_local_name PARAMS ((int n, char **others));
d190 1
a190 2
void
write_struct PARAMS ((FILE *fp, int n));
d192 1
a192 2
void
create_structs PARAMS ((void));
d194 1
a194 2
void
create_macros PARAMS ((void));
d196 1
a196 2
void
create_functions PARAMS ((void));
d198 1
a198 2
void
write_header_file PARAMS ((int n));
d200 1
a200 2
void
write_source_file PARAMS ((int n));
d202 1
a202 2
void
write_macro PARAMS ((FILE *fp, int n));
d204 1
a204 2
void
write_function_decl PARAMS ((FILE *fp, int n));
d206 1
a206 2
void
write_function PARAMS ((FILE *fp, int n));
d208 1
a208 2
void
write_statement PARAMS ((FILE *fp, int depth, int max_depth));
d210 1
a210 2
void
write_expression PARAMS ((FILE *fp, int depth, int max_depth));
d212 1
a212 2
void
write_makefile PARAMS ((void));
d214 1
a214 2
/* The default values are set low for testing purposes.
   Real values can get much larger. */
d216 1
a216 2
int numfiles = 5;
int numheaderfiles = 1;
d220 9
a228 1
int nummacros = 1000;
d230 1
a230 2
int numstructs = 20;
int numslots = MAXSLOTS;
d232 1
a232 1
int numfunctions = 100;
d234 1
a234 1
int function_length = 20;
d238 1
a238 1
/* The amount of commenting in the source. */
d242 1
a242 1
struct macro_desc macros[MAXMACROS];
d244 1
a244 1
struct struct_desc structs[MAXSTRUCTS];
d246 13
a258 1
struct function_desc functions[MAXFUNCTIONS];
d262 3
a264 1
/* Likely words to appear in names of things. */
d267 19
a285 20
  "make",
  "create",
  "alloc",
  "modify",
  "delete",
  "new",
  "add",
  "list",
  "array",
  "queue",
  "object",
  "of",
  "by",
  "point",
  "line",
  "rectangle",
  "shape",
  "area",
  "window",
  "null",
d292 1
a292 1
computer_word ()
d298 2
a299 1
      for (i = 0; computerese[i] != NULL; ++i) ;
d305 2
a306 3
main (argc, argv)
     int argc;
     char **argv;
a309 1
  FILE *fp;
d311 1
d317 5
a321 1
      if (strcmp(arg, "--comments") == 0)
d326 15
d344 1
a344 1
	  numfiles = num;
d349 1
a349 1
	  numfunctions = num;
d359 1
a359 1
	  /* (should use this!) */
d364 1
a364 1
	  numheaderfiles = num;
d371 12
d386 1
a386 1
	  nummacros = num;
d388 1
a388 1
      else if (strcmp(arg, "--slots") == 0)
d391 1
a391 1
	  numslots = num;
d396 1
a396 1
	  numstructs = num;
d400 2
a401 1
	  fprintf (stderr, "SPU program generator version 0.1\n");
d410 1
a410 1
  init_xrandom (-1);
d413 1
d416 3
a418 1
  num_functions_per_file = numfunctions / numfiles;
d420 2
a421 2
  printf ("Writing %d header files...\n", numheaderfiles);
  for (i = 0; i < numheaderfiles; ++i)
d423 2
a424 2
  printf ("Writing %d files...\n", numfiles);
  for (i = 0; i < numfiles; ++i)
d433 1
a433 1
display_usage ()
d436 16
a451 10
  fprintf (stderr, "           --comments <n>\n");
  fprintf (stderr, "           --files <n>\n");
  fprintf (stderr, "           --functions <n>\n");
  fprintf (stderr, "           --function-length <n>\n");
  fprintf (stderr, "           --function-depth <n>\n");
  fprintf (stderr, "           --help\n");
  fprintf (stderr, "           --macros <n>\n");
  fprintf (stderr, "           --slots <n>\n");
  fprintf (stderr, "           --structs <n>\n");
  fprintf (stderr, "           --version\n");
d455 1
a455 2
create_type (str)
char *str;
d457 1
a457 3
  int i;

  return 1;
d460 1
a460 5
int
random_type ()
{
  return 1;
}
d463 1
a463 2
name_from_type (n)
     int n;
d465 7
d475 1
a475 1
/* Generate a macro name that is unique if the given n is unique. */
d477 2
a478 3
char *
gen_new_macro_name (n)
     int n;
d480 1
a480 2
  int i = 0;
  char namebuf[100];
d482 2
a483 7
  ++n;
  namebuf[i] = '\0';
  strcat (namebuf, computer_word ());
  i = strlen (namebuf);
  namebuf[i++] = '_';
  namebuf[i++] = 'M';
  while (n > 0)
d485 8
a492 2
      namebuf[i++] = 'a' + (n % 26);
      n /= 26;
a493 2
  namebuf[i] = '\0';
  return copy_string (namebuf);
d496 9
a504 1
/* Create basic definitions of macros. */
d507 1
a507 1
create_macros()
d509 1
a509 1
  int i, j, numargs;
d511 2
a512 2
  printf ("Creating %d macros...\n", nummacros);
  for (i = 0; i < nummacros; ++i)
d514 5
a518 3
      macros[i].name = gen_new_macro_name (i);
      numargs = xrandom (MAXMARGS + 1);
      for (j = 0; j < numargs; ++j)
d520 1
a520 1
	  macros[i].args[j] = gen_random_local_name(j, NULL);
d522 1
a522 1
      macros[i].numargs = numargs;
d526 1
a526 1
/* Generate a unique structure name, based on the number n. */
d529 1
a529 2
gen_new_struct_name (n)
     int n;
d531 2
a532 2
  int i = 0;
  char namebuf[100];
d534 1
a534 13
  ++n;
  namebuf[i++] = 's';
  namebuf[i++] = '_';
  while (n > 0)
    {
      namebuf[i++] = 'a' + (n % 26);
      n /= 26;
    }
  namebuf[i] = '\0';
  if (xrandom (4) == 0)
    strcat (namebuf, "_struct");
  return copy_string (namebuf);
}
d537 1
a537 2
gen_random_slot_name (n)
     int n;
d539 1
a539 5
  char namebuf[100];

  /* (should have more variety) */
  sprintf (namebuf, "slot%d", n);
  return copy_string (namebuf);
d542 1
a542 1
/* Create definitions of the desired number of structures. */
d545 1
a545 1
create_structs()
d549 2
a550 2
  printf ("Creating %d structs...\n", numstructs);
  for (i = 0; i < numstructs; ++i)
d552 3
a554 2
      structs[i].name = gen_new_struct_name(i);
      for (j = 0; j < 20; ++j)
d556 2
a557 1
	  structs[i].slots[j].name = gen_random_slot_name (j);
a558 1
      structs[i].numslots = j;
d562 7
a568 1
/* Generate a function name that is unique if n is unique. */
d571 1
a571 2
gen_new_function_name (n)
     int n;
a572 1
  int i = 0;
d575 2
a576 29
  ++n;
  namebuf[i] = '\0';
  /* Start with a random computer term.  */
  if (xrandom (5) == 0)
    {
      strcat (namebuf, computer_word ());
      i = strlen (namebuf);
      namebuf[i++] = '_';
    }
  namebuf[i++] = 'f';
  /* Note that if we just add an 'f', there is a small chance of getting
     the name "for", which make the compiler unhappy.  */
  namebuf[i++] = 'n';
  /* Convert the number n itself into a string, maybe with some underscores
     thrown in for flavor.  */
  while (n > 0)
    {
      if (xrandom(4) == 0) namebuf[i++] = '_';
      namebuf[i++] = 'a' + (n % 26);
      n /= 26;
    }
  namebuf[i] = '\0';
  /* Maybe add some more computerese on the end. */
  if (xrandom (4) != 0)
    {
      namebuf[i++] = '_';
      namebuf[i] = '\0';
      strcat (namebuf, computer_word ());
    }
d585 1
a585 1
create_functions()
d587 1
a587 1
  int i, j, numargs;
d589 24
a612 5
  printf ("Creating %d functions...\n", numfunctions);
  for (i = 0; i < numfunctions; ++i)
    {
      functions[i].name = gen_new_function_name(i);
      numargs = xrandom (MAXFARGS + 1);
d615 1
a615 1
	  functions[i].args[j] = gen_random_local_name(j, NULL);
d621 8
d630 1
a630 2
write_header_file (n)
     int n;
d644 10
a653 2
	  printf ("Writing %d structs...\n", numstructs);
	  for (i = 0; i < numstructs; ++i)
d655 1
a655 1
	      write_struct (fp, i);
d660 2
a661 2
	  printf ("Writing %d macros...\n", nummacros);
	  for (i = 0; i < nummacros; ++i)
d663 1
a663 1
	      write_macro (fp, i);
d668 2
a669 2
	  printf ("Writing %d function decls...\n", numfunctions);
	  for (i = 0; i < numfunctions; ++i)
a677 2
/* Write out the definition of a structure. */

d679 1
a679 20
write_struct (fp, i)
     FILE *fp;
     int i;
{
  int j;

  if (i == 0) printf ("  (Each struct contains %d slots)\n", numslots);
  fprintf (fp, "struct %s {\n", structs[i].name);
  for (j = 0; j < structs[i].numslots; ++j)
    {
      fprintf (fp, "  %s %s;\n",
	       name_from_type (random_type ()), structs[i].slots[j].name);
    }
  fprintf (fp, "};\n\n");
}

void
write_macro (fp, n)
     FILE *fp;
     int n;
d684 3
a686 1
  if (1)
d691 2
a692 1
	  if (j > 0) fprintf (fp, ",");
d707 2
a708 1
	      if (i > 0) fprintf (fp, ",");
d727 1
a727 1
      fprintf (fp, " (1)");
d733 41
d775 1
a775 3
write_function_decl (fp, n)
     FILE *fp;
     int n;
d777 2
d780 9
d795 1
a795 2
write_source_file (n)
     int n;
d798 1
a798 1
  int j, k;
d800 1
d802 2
a803 1
  sprintf (tmpbuf, "%s%d.c", file_base_name, n);
d807 4
a810 1
      if (numheaderfiles > 0)
d812 1
a812 1
	  for (j = 0; j < numheaderfiles; ++j)
d814 1
a814 1
	      fprintf(fp, "#include \"%s%d.h\"\n", file_base_name, j);
d816 1
a816 1
	  fprintf(fp, "\n");
a818 4
      if (n == 0) printf ("  (Each file contains %d functions)\n",
			  num_functions_per_file);

      /* Put out a "main", but only in the first C file. */
d820 2
a821 10
	{
	  fprintf (fp, "main ()\n");
	  fprintf (fp, "{\n");
	  if (1 /* use stdio */)
	    {
	      fprintf (fp, "  printf (\"hello world\\n\");\n");
	      /* (should issue calls to other functions?) */
	    }
	  fprintf (fp, "}\n\n");
	}
d832 1
a832 3
write_function (fp, n)
     FILE *fp;
     int n;
d834 1
a834 1
  int k;
d836 19
a854 1
  fprintf(fp, "%s ()\n", functions[n].name);
d856 2
a857 1
  /* Generate a plausible function body. */
d860 1
a860 1
      write_statement (fp, 0, xrandom(2) + 1);
d866 1
a866 3
write_statement (fp, depth, max_depth)
     FILE *fp;
     int depth, max_depth;
d868 1
a868 1
  int n, j;
d870 2
d873 1
a873 1
  if (depth >= max_depth || xrandom(2) == 0)
d875 3
a877 7
      switch (xrandom(2))
	{
	default:
	  write_expression (fp, 0, xrandom(4) + 1);
	  fprintf (fp, ";\n");
	  break;
	}
d879 1
a879 1
  else
d881 13
a893 10
      switch (xrandom(2))
	{
	default:
	  fprintf (fp, "if (");
	  write_expression (fp, 0, xrandom(2) + 1);
	  fprintf (fp, ")\n    {\n");
	  write_statement(fp, depth + 1, max_depth);
	  fprintf (fp, "    }\n");
	  break;
	}
d895 1
d901 1
a901 3
write_expression (fp, depth, max_depth)
     FILE *fp;
     int depth, max_depth;
d903 1
a903 1
  int n, j;
d906 1
a906 1
  if (depth >= max_depth || xrandom(2) == 0)
d917 1
d919 1
a919 1
  else
d921 18
a938 1
      switch (xrandom(10))
d940 3
a942 42
	case 0:
	case 5:
	case 7:
	  n = xrandom (numfunctions);
	  fprintf(fp, "  %s (", functions[n].name);
	  for (j = 0; j < functions[n].numargs; ++j)
	    {
	      if (j > 0) fprintf (fp, ", ");
	      write_expression(fp, depth + 1, max_depth);
	    }
	  fprintf(fp, ")");
	  break;
	case 1:
	case 6:
	case 8:
	  n = xrandom (nummacros);
	  fprintf(fp, "  %s(", macros[n].name);
	  for (j = 0; j < macros[n].numargs; ++j)
	    {
	      if (j > 0) fprintf (fp, ", ");
	      write_expression(fp, depth + 1, max_depth);
	    }
	  fprintf(fp, ")");
	  break;
	case 2:
	  write_expression (fp, depth + 1, max_depth);
	  fprintf (fp, " + ");
	  write_expression (fp, depth + 1, max_depth);
	  break;
	case 3:
	  write_expression (fp, depth + 1, max_depth);
	  fprintf (fp, " - ");
	  write_expression (fp, depth + 1, max_depth);
	  break;
	case 4:
	  write_expression (fp, depth + 1, max_depth);
	  fprintf (fp, " * ");
	  write_expression (fp, depth + 1, max_depth);
	  break;
	default:
	  fprintf (fp, "%d", xrandom (127));
	  break;
d944 25
d975 1
a975 1
write_makefile ()
d985 1
d989 1
a989 1
      for (i = 0; i < numfiles; ++i)
d993 1
a993 1
      for (i = 0; i < numfiles; ++i)
d997 1
a997 1
      for (i = 0; i < numfiles; ++i)
d999 4
a1002 3
	  fprintf (fp, " %s%d.o:	%s%d.c",
		   file_base_name, i, file_base_name, i);
	  for (j = 0; j < numheaderfiles; ++j)
d1005 2
d1016 1
a1016 2
gen_random_name (root)
char *root;
d1018 37
a1054 1
  char namebuf[100];
d1056 48
a1103 3
  if (root == NULL) root = "n";
  sprintf (namebuf, "%s_%d", root, xrandom (10000));
  return copy_string (namebuf);
d1109 1
a1109 3
gen_random_local_name (numothers, others)
int numothers;
char **others;
d1113 3
a1115 1
  sprintf (namebuf, "arg%d", numothers + 1);
d1119 91
d1212 4
a1215 3
/* Random number handling is important but terrible/nonexistent
   in some systems.  Do it ourselves.  Also, this will give repeatable
   results across multiple platforms.  */
d1219 1
a1219 1
unsigned long initrandstate = 0;
d1228 1
a1228 2
init_xrandom (seed)
     int seed;
d1252 1
a1252 1
  initrandstate = randstate;
d1259 1
a1259 2
xrandom (m)
int m;
d1266 1
a1266 2
xmalloc (amt)
     int amt;
d1277 1
a1277 1
  bzero (value, amt);
d1281 2
a1282 1
/* Copy a string to newly-allocated space.  The new space is never freed. */
d1285 1
a1285 2
copy_string (str)
     char *str;
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@

