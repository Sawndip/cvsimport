head	1.2;
access;
symbols
	gdb_5_2_1-2002-07-23-release:1.1.1.1
	cagney_regbuf-20020515-branch:1.1.1.1.0.18
	cagney_regbuf-20020515-branchpoint:1.1.1.1
	jimb-macro-020506-branch:1.1.1.1.0.16
	jimb-macro-020506-branchpoint:1.1.1.1
	gdb_5_2-2002-04-29-release:1.1.1.1
	gdb_5_2-branch:1.1.1.1.0.14
	gdb_5_2-2002-03-03-branchpoint:1.1.1.1
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	gdb_5_1_0_1-2002-01-03-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.1.1.1
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.12
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.10
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.8
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb-premipsmulti-2000-06-06-branch:1.1.1.1.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.4
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	gdb-2000-02-04:1.1.1.1
	gdb-2000-02-02:1.1.1.1
	gdb-2000-02-01:1.1.1.1
	gdb-2000-01-31:1.1.1.1
	gdb-2000-01-26:1.1.1.1
	gdb-2000-01-24:1.1.1.1
	gdb-2000-01-17:1.1.1.1
	gdb-2000-01-10:1.1.1.1
	gdb-2000-01-05:1.1.1.1
	gdb-1999-12-21:1.1.1.1
	gdb-1999-12-13:1.1.1.1
	gdb-1999-12-07:1.1.1.1
	gdb-1999-12-06:1.1.1.1
	gdb-1999-11-16:1.1.1.1
	gdb-1999-11-08:1.1.1.1
	gdb-1999-11-01:1.1.1.1
	gdb-1999-10-25:1.1.1.1
	gdb-1999-10-18:1.1.1.1
	gdb-1999-10-11:1.1.1.1
	gdb-1999-10-04:1.1.1.1
	gdb-1999-09-28:1.1.1.1
	gdb-1999-09-21:1.1.1.1
	gdb-1999-09-13:1.1.1.1
	gdb-1999-09-08:1.1.1.1
	gdb-1999-08-30:1.1.1.1
	gdb-1999-08-23:1.1.1.1
	gdb-1999-08-16:1.1.1.1
	gdb-1999-08-09:1.1.1.1
	gdb-1999-08-02:1.1.1.1
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.2
date	2002.05.28.10.29.54;	author nickc;	state dead;
branches;
next	1.1;

1.1
date	99.04.16.01.35.27;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.35.27;	author shebs;	state Exp;
branches;
next	;


desc
@@


1.2
log
@ Remove amd-udi subdirectory - it is obsolete.
@
text
@static char _[] = "@@(#)parallel.c	1.4 93/09/08 14:14:32, Srini, AMD.";
/******************************************************************************
 * Copyright 1992 Advanced Micro Devices, Inc.
 *
 * This software is the property of Advanced Micro Devices, Inc  (AMD)  which
 * specifically  grants the user the right to modify, use and distribute this
 * software provided this notice is not removed or altered.  All other rights
 * are reserved by AMD.
 *
 * AMD MAKES NO WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, WITH REGARD TO THIS
 * SOFTWARE.  IN NO EVENT SHALL AMD BE LIABLE FOR INCIDENTAL OR CONSEQUENTIAL
 * DAMAGES IN CONNECTION WITH OR ARISING FROM THE FURNISHING, PERFORMANCE, OR
 * USE OF THIS SOFTWARE.
 *
 * So that all may benefit from your experience, please report  any  problems
 * or  suggestions about this software to the 29K Technical Support Center at
 * 800-29-29-AMD (800-292-9263) in the USA, or 0800-89-1131  in  the  UK,  or
 * 0031-11-1129 in Japan, toll free.  The direct dial number is 512-462-4118.
 *
 * Advanced Micro Devices, Inc.
 * 29K Systems Engineering
 * Mail Stop 573
 * 5204 E. Ben White Blvd.
 * Austin, TX 78741
 * 800-292-9263
 * 29k-support@@AMD.COM
 ****************************************************************************
 * Engineer:  Srini Subramanian.
 ****************************************************************************
 */
#include <bios.h>
#include <conio.h>
#include <stdio.h>
#include <string.h>

#include "types.h"
#include "memspcs.h"
#include "messages.h"
#include "mtip.h"
#include "tdfunc.h"

void   endian_cvt PARAMS((union msg_t *, int));

extern	FILE	*MsgFile;	/* for logging error retries */

unsigned _bios_printer(unsigned service, unsigned printer, unsigned data);


INT32 par_write( char	*buffer, INT32	length);

static	unsigned	portID=0;

#define	LPT1	0
#define	LPT2	1

#define CHECKSUM_FAIL -1

INT32
init_parport(portname)
char	*portname;
{
  unsigned status;

  if (strncmp(portname, "lpt1", 4) == 0)  {
     status = _bios_printer( _PRINTER_INIT, LPT1, 0);
     portID = LPT1;
  } else if (strncmp(portname, "lpt2", 4) == 0) {
     status = _bios_printer( _PRINTER_INIT, LPT2, 0);
     portID = LPT2;
  }
#if 0
  if (status != 0x90) {
    printf("parallel port status 0x%.4x\n", status);
    return ((INT32) -1);
  } else {
    return ((INT32) 0);
  }
#endif
    return ((INT32) 0);
}


INT32
msg_send_parport(msg_ptr, port_base)
union  msg_t  *msg_ptr;
INT32  port_base;
{
   INT32 result, i, ack, comm_err; 
   UINT32 checksum;
   unsigned int		timeout;
   INT32 	Rx_ack[2];

   INT32 header_size = (2 * sizeof(INT32));

   BYTE  *bfr_ptr = (BYTE *) msg_ptr;

   /* Save length before doing endian conversion */
   INT32 length = msg_ptr->generic_msg.length;
   INT32 total_length;
	
   total_length = header_size + length;

   /* Endian conversion */
   if (tip_target_config.TipEndian != tip_target_config.P29KEndian)
      endian_cvt(msg_ptr, OUTGOING_MSG);

   /* calc checksum for msg */
   checksum = 0;    
   for (i=0; i < total_length; i++)
     checksum = checksum + bfr_ptr[i];

   /* Append checksum to the end of the message. Do not update the
    * "length" field of the message header.
    */
   bfr_ptr[total_length] = (BYTE) ((checksum >> 24) & 0xff);
   bfr_ptr[total_length+1] = (BYTE) ((checksum >> 16) & 0xff);
   bfr_ptr[total_length+2] = (BYTE) ((checksum >> 8) & 0xff);
   bfr_ptr[total_length+3] = (BYTE) ((checksum >> 0) & 0xff);

   /* send msg */
	comm_err = (INT32) 0;

	/* send msg */ 
        result = par_write((char *)bfr_ptr, total_length+4 /* +4 */);
	if (result != (INT32) 0)
	    return((INT32) FAILURE);

	/* get ack */
	timeout = 0;
	result = (INT32) -1;
	comm_err = (INT32) 0;
	while ((timeout < 600) && (result == (INT32) -1) 
					  && (comm_err == (INT32) 0)) {
	/* Poll for user interrupt */
	   timeout=timeout+1;
           result = recv_bfr_serial((BYTE *) Rx_ack, (2 * sizeof(INT32)), 
					BLOCK, port_base, &comm_err);
	}

	if (comm_err != (INT32) 0) {
	     reset_comm_serial((INT32) -1, (INT32) -1);
	     return ((INT32) MSGRETRY);
	}
	/* check if timed out */
	if (timeout >= 10000) {
	 if (MsgFile) {
	   fprintf(MsgFile,"Timed out before ACK received. Reset comm. timeout=%ld\n",timeout);
     	   fflush(MsgFile);
	  }
	  (void) reset_comm_serial((INT32) 0, (INT32) 0);
	  return ((INT32) MSGRETRY);
	}

	ack = (INT32) Rx_ack[1];

	/* endian convert Ack */
    	if (tip_target_config.TipEndian != tip_target_config.P29KEndian)
       			        tip_convert32((BYTE *) &ack);

	if (ack != CHECKSUM_FAIL) { 
		return(0);		/* successful send */
		}
	else {
  		if (MsgFile) {	/* log the error */
     	 		fprintf(MsgFile, 
			  "\n** Checksum: Nack Received, Resending.\n");
     			fflush(MsgFile);
  			};
		}   

   return ((INT32) FAILURE);

}

INT32
par_write(buffer, length)
char	*buffer;
INT32 		length;
{

 unsigned 	status;

 for ( ; length > (INT32) 0; length=length-1)
 {
   status = _bios_printer(_PRINTER_WRITE, portID, (unsigned) *buffer);
   /* printf("status 0x%.4x \n", status); */
   buffer++;
 }
 return ((INT32) 0);
}
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@

