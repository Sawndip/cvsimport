head	1.2;
access;
symbols
	gdb_5_2_1-2002-07-23-release:1.1.1.1
	cagney_regbuf-20020515-branch:1.1.1.1.0.18
	cagney_regbuf-20020515-branchpoint:1.1.1.1
	jimb-macro-020506-branch:1.1.1.1.0.16
	jimb-macro-020506-branchpoint:1.1.1.1
	gdb_5_2-2002-04-29-release:1.1.1.1
	gdb_5_2-branch:1.1.1.1.0.14
	gdb_5_2-2002-03-03-branchpoint:1.1.1.1
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	gdb_5_1_0_1-2002-01-03-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.1.1.1
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.12
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.10
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.8
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb-premipsmulti-2000-06-06-branch:1.1.1.1.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.4
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	gdb-2000-02-04:1.1.1.1
	gdb-2000-02-02:1.1.1.1
	gdb-2000-02-01:1.1.1.1
	gdb-2000-01-31:1.1.1.1
	gdb-2000-01-26:1.1.1.1
	gdb-2000-01-24:1.1.1.1
	gdb-2000-01-17:1.1.1.1
	gdb-2000-01-10:1.1.1.1
	gdb-2000-01-05:1.1.1.1
	gdb-1999-12-21:1.1.1.1
	gdb-1999-12-13:1.1.1.1
	gdb-1999-12-07:1.1.1.1
	gdb-1999-12-06:1.1.1.1
	gdb-1999-11-16:1.1.1.1
	gdb-1999-11-08:1.1.1.1
	gdb-1999-11-01:1.1.1.1
	gdb-1999-10-25:1.1.1.1
	gdb-1999-10-18:1.1.1.1
	gdb-1999-10-11:1.1.1.1
	gdb-1999-10-04:1.1.1.1
	gdb-1999-09-28:1.1.1.1
	gdb-1999-09-21:1.1.1.1
	gdb-1999-09-13:1.1.1.1
	gdb-1999-09-08:1.1.1.1
	gdb-1999-08-30:1.1.1.1
	gdb-1999-08-23:1.1.1.1
	gdb-1999-08-16:1.1.1.1
	gdb-1999-08-09:1.1.1.1
	gdb-1999-08-02:1.1.1.1
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.2
date	2002.05.28.10.29.54;	author nickc;	state dead;
branches;
next	1.1;

1.1
date	99.04.16.01.35.27;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.35.27;	author shebs;	state Exp;
branches;
next	;


desc
@@


1.2
log
@ Remove amd-udi subdirectory - it is obsolete.
@
text
@static char _[] = "@@(#)endian.c	5.18 93/07/30 16:40:17, Srini, AMD.";
/******************************************************************************
 * Copyright 1991 Advanced Micro Devices, Inc.
 *
 * This software is the property of Advanced Micro Devices, Inc  (AMD)  which
 * specifically  grants the user the right to modify, use and distribute this
 * software provided this notice is not removed or altered.  All other rights
 * are reserved by AMD.
 *
 * AMD MAKES NO WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, WITH REGARD TO THIS
 * SOFTWARE.  IN NO EVENT SHALL AMD BE LIABLE FOR INCIDENTAL OR CONSEQUENTIAL
 * DAMAGES IN CONNECTION WITH OR ARISING FROM THE FURNISHING, PERFORMANCE, OR
 * USE OF THIS SOFTWARE.
 *
 * So that all may benefit from your experience, please report  any  problems
 * or  suggestions about this software to the 29K Technical Support Center at
 * 800-29-29-AMD (800-292-9263) in the USA, or 0800-89-1131  in  the  UK,  or
 * 0031-11-1129 in Japan, toll free.  The direct dial number is 512-462-4118.
 *
 * Advanced Micro Devices, Inc.
 * 29K Support Products
 * Mail Stop 573
 * 5900 E. Ben White Blvd.
 * Austin, TX 78741
 * 800-292-9263
 *****************************************************************************
 *      Engineer: Srini Subramanian.
 *****************************************************************************
 ** 
 **       This module implements the endian conversion routines used by MONTIP.
 **
 *****************************************************************************
 */

#include <stdio.h>
#include <ctype.h>
#include  "messages.h"

#ifdef MSDOS
#include <string.h>
#else
#include <string.h>
#endif  /* MSDOS */

/* Functions */
void  tip_convert32 PARAMS((BYTE *));
void  tip_convert16 PARAMS((BYTE *));

/*
** This function is used to convert the endian of messages.
** Both host to target and target to host messages can be
** converted using this function.
**
** Note that all monitor messages have a header consisting of
** a 32 bit message number and a 32 bit size.  Following this
** may be one or more 32 bit parameters.  And folowing these
** parameters may be an array of bytes.
**
** This function converts the endian of the header and any
** parameters.  It is not necessary to convert the array of
** bytes.
**
** Note that the use of 32 bit parameters makes this conversion
** routine fairly simple.
*/

void
endian_cvt(msg_buf, direction)
   union  msg_t  *msg_buf;
   int    direction;
   {
   INT32  i;
   BYTE  *byte;
   INT32  code;
   INT32  length;


   /*
   ** If incoming message, convert endian, then get message
   ** type and message length.  If outgoing message, get
   ** message type and message length, then convert endian.
   */

   if ((direction != OUTGOING_MSG) &&
       (direction != INCOMING_MSG))
      return;

   if (direction == OUTGOING_MSG) {
      code = (msg_buf->generic_msg).code;
      length = (msg_buf->generic_msg).length;
      }

   /* Change endian of "code" field */
   tip_convert32((BYTE *) &(msg_buf->generic_msg).code);

   /* Change endian of "length" field */
   tip_convert32((BYTE *) &(msg_buf->generic_msg).length);

   if (direction == INCOMING_MSG) {
      code = (msg_buf->generic_msg).code;
      length = (msg_buf->generic_msg).length;
      }

   /*
   ** Some messages, notably WRITE_REQ, FILL, READ
   ** and TRACE have data following the message
   ** parameters.  Since we don't want to swap bytes
   ** in the data array, we need to get the number of
   ** of bytes taken up by the parameters.  This is
   ** still better than having to find ALL of the
   ** message lengths statically.
   */

   if (code == WRITE_REQ) 
      length = msg_length(WRITE_REQ);
   else
   if (code == FILL)
      length = MSG_LENGTH(struct fill_msg_t);
   else
   if (code == READ_ACK)
      length = MSG_LENGTH(struct read_ack_msg_t);
   else
   if (code == CHANNEL1)
      length = MSG_LENGTH(struct channel1_msg_t);
   else
   if (code == CHANNEL2)
      length = MSG_LENGTH(struct channel2_msg_t);
   else
   if (code == CHANNEL0)
      length = MSG_LENGTH(struct channel0_msg_t);
   else
   if (code == STDIN_NEEDED_ACK)
      length = MSG_LENGTH(struct stdin_needed_ack_msg_t);

   /* Convert message parameters */

   byte = (BYTE *) &(msg_buf->generic_msg).byte;
   for (i=0; i<(length/sizeof(INT32)); i=i+1) {
      tip_convert32(byte);
      byte = byte + sizeof(INT32);
      }

   }   /* end endian_cvt */


/*
** This function is used to swap the bytes in a 32 bit
** word.  This will convert "little endian" (IBM-PC / Intel)
** words to "big endian" (Sun / Motorola) words.
*/


void
tip_convert32(byte)
   BYTE *byte;
   {
   BYTE temp;

   temp = byte[0];  /* Swap bytes 0 and 3 */
   byte[0] = byte[3];
   byte[3] = temp;
   temp = byte[1];  /* Swap bytes 1 and 2 */
   byte[1] = byte[2];
   byte[2] = temp;
   }   /* end tip_convert32() */


/*
** This function is used to swap the bytes in a 16 bit
** word.  This will convert "little endian" (IBM-PC / Intel)
** half words to "big endian" (Sun / Motorola) half words.
*/

void
tip_convert16(byte)
   BYTE *byte;
   {
   BYTE temp;

   temp = byte[0];  /* Swap bytes 0 and 1 */
   byte[0] = byte[1];
   byte[1] = temp;

   }   /* end tip_convert16() */
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@

