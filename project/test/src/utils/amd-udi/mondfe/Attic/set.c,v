head	1.2;
access;
symbols
	gdb_5_2_1-2002-07-23-release:1.1.1.1
	cagney_regbuf-20020515-branch:1.1.1.1.0.18
	cagney_regbuf-20020515-branchpoint:1.1.1.1
	jimb-macro-020506-branch:1.1.1.1.0.16
	jimb-macro-020506-branchpoint:1.1.1.1
	gdb_5_2-2002-04-29-release:1.1.1.1
	gdb_5_2-branch:1.1.1.1.0.14
	gdb_5_2-2002-03-03-branchpoint:1.1.1.1
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	gdb_5_1_0_1-2002-01-03-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.1.1.1
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.12
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.10
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.8
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb-premipsmulti-2000-06-06-branch:1.1.1.1.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.4
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	gdb-2000-02-04:1.1.1.1
	gdb-2000-02-02:1.1.1.1
	gdb-2000-02-01:1.1.1.1
	gdb-2000-01-31:1.1.1.1
	gdb-2000-01-26:1.1.1.1
	gdb-2000-01-24:1.1.1.1
	gdb-2000-01-17:1.1.1.1
	gdb-2000-01-10:1.1.1.1
	gdb-2000-01-05:1.1.1.1
	gdb-1999-12-21:1.1.1.1
	gdb-1999-12-13:1.1.1.1
	gdb-1999-12-07:1.1.1.1
	gdb-1999-12-06:1.1.1.1
	gdb-1999-11-16:1.1.1.1
	gdb-1999-11-08:1.1.1.1
	gdb-1999-11-01:1.1.1.1
	gdb-1999-10-25:1.1.1.1
	gdb-1999-10-18:1.1.1.1
	gdb-1999-10-11:1.1.1.1
	gdb-1999-10-04:1.1.1.1
	gdb-1999-09-28:1.1.1.1
	gdb-1999-09-21:1.1.1.1
	gdb-1999-09-13:1.1.1.1
	gdb-1999-09-08:1.1.1.1
	gdb-1999-08-30:1.1.1.1
	gdb-1999-08-23:1.1.1.1
	gdb-1999-08-16:1.1.1.1
	gdb-1999-08-09:1.1.1.1
	gdb-1999-08-02:1.1.1.1
	gdb-1999-07-26:1.1.1.1
	gdb-1999-07-19:1.1.1.1
	gdb-1999-07-12:1.1.1.1
	gdb-post-reformat-19990707:1.1.1.1
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.1
	gdb-pre-reformat-19990707:1.1.1.1
	gdb-1999-07-07:1.1.1.1
	gdb-1999-07-05:1.1.1.1
	gdb-1999-06-28:1.1.1.1
	gdb-1999-06-21:1.1.1.1
	gdb-1999-06-14:1.1.1.1
	gdb-1999-06-07:1.1.1.1
	gdb-1999-06-01:1.1.1.1
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.1
	gdb-1999-05-19:1.1.1.1
	gdb-1999-05-10:1.1.1.1
	gdb-19990504:1.1.1.1
	gdb-19990422:1.1.1.1
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.2
date	2002.05.28.10.29.53;	author nickc;	state dead;
branches;
next	1.1;

1.1
date	99.04.16.01.35.27;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.04.16.01.35.27;	author shebs;	state Exp;
branches;
next	;


desc
@@


1.2
log
@ Remove amd-udi subdirectory - it is obsolete.
@
text
@static char _[] = "@@(#)set.c	5.20 93/07/30 16:39:00, Srini, AMD.";
/******************************************************************************
 * Copyright 1991 Advanced Micro Devices, Inc.
 *
 * This software is the property of Advanced Micro Devices, Inc  (AMD)  which
 * specifically  grants the user the right to modify, use and distribute this
 * software provided this notice is not removed or altered.  All other rights
 * are reserved by AMD.
 *
 * AMD MAKES NO WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, WITH REGARD TO THIS
 * SOFTWARE.  IN NO EVENT SHALL AMD BE LIABLE FOR INCIDENTAL OR CONSEQUENTIAL
 * DAMAGES IN CONNECTION WITH OR ARISING FROM THE FURNISHING, PERFORMANCE, OR
 * USE OF THIS SOFTWARE.
 *
 * So that all may benefit from your experience, please report  any  problems
 * or  suggestions about this software to the 29K Technical Support Center at
 * 800-29-29-AMD (800-292-9263) in the USA, or 0800-89-1131  in  the  UK,  or
 * 0031-11-1129 in Japan, toll free.  The direct dial number is 512-462-4118.
 *
 * Advanced Micro Devices, Inc.
 * 29K Support Products
 * Mail Stop 573
 * 5900 E. Ben White Blvd.
 * Austin, TX 78741
 * 800-292-9263
 *****************************************************************************
 *      Engineer: Srini Subramanian.
 *****************************************************************************
 **       This code provides "set" routines to set memory and
 **       registers.  Data may be set as words (32 bit), half-words
 **       (16 bit), bytes (8 bit), float (32 bit floating point) or
 **       double (64 bit floating point).
 **
 **       Since registers are 32 bits long, the set byte and set half
 **       commands will only be permitted for memory accesses.
 *****************************************************************************
 */


#include <stdio.h>
#include <ctype.h>
#include <memory.h>
#include "main.h"
#include "monitor.h"
#include "miniint.h"
#include "memspcs.h"
#include "macros.h"
#include "error.h"


#ifdef MSDOS
#include <stdlib.h>
#include <string.h>
#else
#include <string.h>

#endif

int   get_addr_29k PARAMS((char *, struct addr_29k_t *));
int   addr_29k_ok PARAMS((struct addr_29k_t *));

int   get_word PARAMS((char *, INT32 *));
int   get_half PARAMS((char *, INT16 *));
int   get_byte PARAMS((char *, BYTE *));
int   get_float PARAMS((char *, float *));
int   get_double PARAMS((char *, double *));

int   set_data PARAMS((BYTE *, BYTE *, int));

/*
** The function below is used in setting data.  This function is
** called in the main command loop parser of the monitor.  The
** parameters passed to this function are:
**
** token - This is an array of pointers to strings.  Each string
**         referenced by this array is a "token" of the user's
**         input, translated to lower case.
**
** token_count - This is the number of items in the token array.
**
** This function reduces the tokens to three parameters:
** memory_space, address and the data to be set.  This data
** is one of the "temp_" variables.
**
*/


INT32
set_cmd(token, token_count)
   char   *token[];
   int     token_count;
   {
   INT16  size;
   int    result;
   struct addr_29k_t addr_29k;
   int    set_format;
   INT32  temp_word;
   INT16  temp_half;
   BYTE   temp_byte;
   float  temp_float;
   double temp_double;

   INT32	retval;
   BYTE		write_buffer[16];  /* */
   INT32	bytes_ret;
   INT32	hostendian;     /* UDI conformant */
   INT32	count;


   if (token_count != 3) {
      return (EMSYNTAX);
      }

   /*
   ** What is the data format?
   */

   count = (INT32) 1;
   if ((strcmp(token[0], "s") == 0) ||
       (strcmp(token[0], "sw") == 0)) {
      set_format = WORD_FORMAT;
      size = (INT16) sizeof(INT32);
      result = get_word(token[2], &temp_word);
      if (result != 0)
         return (EMSYNTAX);
      result = set_data(write_buffer, (BYTE *)&temp_word, sizeof(INT32));
      if (result != 0)
         return (EMSYNTAX);
      }
   else
   if (strcmp(token[0], "sh") == 0) {
      set_format = HALF_FORMAT;
      size = (INT16) sizeof(INT16);
      result = get_half(token[2], &temp_half);
      if (result != 0)
         return (EMSYNTAX);
      result = set_data(write_buffer, (BYTE *)&temp_half, sizeof(INT16));
      if (result != 0)
         return (EMSYNTAX);
      }
   else
   if (strcmp(token[0], "sb") == 0) {
      set_format = BYTE_FORMAT;
      size = (INT16) sizeof(BYTE);
      result = get_byte(token[2], &temp_byte);
      if (result != 0)
         return (EMSYNTAX);
      result = set_data(write_buffer, (BYTE *)&temp_byte, sizeof(BYTE));
      if (result != 0)
         return (EMSYNTAX);
      }
   else
   if (strcmp(token[0], "sf") == 0) {
      set_format = FLOAT_FORMAT;
      size = (INT16) sizeof(float);
      result = get_float(token[2], &temp_float);
      if (result != 0)
         return (EMSYNTAX);
      result = set_data(write_buffer, (BYTE *)&temp_float, sizeof(float));
      if (result != 0)
         return (EMSYNTAX);
      }
   else
   if (strcmp(token[0], "sd") == 0) {
      set_format = DOUBLE_FORMAT;
      size = (INT16) sizeof(double);
      result = get_double(token[2], &temp_double);
      if (result != 0)
         return (EMSYNTAX);
      result = set_data(write_buffer, (BYTE *)&temp_double, sizeof(double));
      if (result != 0)
         return (EMSYNTAX);
      }
   else
      return(EMSYNTAX);

   /*
   ** Get address
   */

   result = get_addr_29k(token[1], &addr_29k);
   if (result != 0)
      return (EMSYNTAX);
   result = addr_29k_ok(&addr_29k);
   if (result != 0)
      return (result);

   /*
   ** We don't set bytes or half words in registers
   */

   if (((ISREG(addr_29k.memory_space)) &&
        (set_format == BYTE_FORMAT)) ||

      ((ISREG(addr_29k.memory_space)) &&
        (set_format == HALF_FORMAT)))
      return (EMSYNTAX);

   /* Will the data overflow the message buffer? Done in TIP */

   hostendian = FALSE;
   if ((retval = Mini_write_req (addr_29k.memory_space,
				 addr_29k.address,
				 count,
				 (INT16) size,
				 &bytes_ret,
				 write_buffer,
				 hostendian)) != SUCCESS) {
	return(FAILURE);
   } else 
      return(SUCCESS);

   }  /* end set_cmd() */


@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@

