head	1.2;
access;
symbols
	msnyder-tracepoint-checkpoint-branch:1.1.1.1.0.58
	msnyder-tracepoint-checkpoint-branchpoint:1.1.1.1
	ezannoni_pie-20040323-branch:1.1.1.1.0.56
	ezannoni_pie-20040323-branchpoint:1.1.1.1
	cagney_tramp-20040321-mergepoint:1.1.1.1
	gdb_6_1-branch:1.1.1.1.0.54
	gdb_6_1-2004-03-01-gmt-branchpoint:1.1.1.1
	drow-cplus-merge-20040208:1.1.1.1
	carlton_dictionary-20040126-merge:1.1.1.1
	drow-cplus-merge-20040113:1.1.1.1
	drow-cplus-merge-20031224:1.1.1.1
	drow-cplus-merge-20031220:1.1.1.1
	carlton_dictionary-20031215-merge:1.1.1.1
	drow-cplus-merge-20031214:1.1.1.1
	carlton-dictionary-20031111-merge:1.1.1.1
	carlton_dictionary-20030917-merge:1.1.1.1
	ezannoni_pie-20030916-branchpoint:1.1.1.1
	ezannoni_pie-20030916-branch:1.1.1.1.0.52
	cagney_x86i386-20030821-branch:1.1.1.1.0.50
	cagney_x86i386-20030821-branchpoint:1.1.1.1
	carlton_dictionary-20030805-merge:1.1.1.1
	carlton_dictionary-20030627-merge:1.1.1.1
	gdb_6_0-branch:1.1.1.1.0.48
	gdb_6_0-2003-06-23-branchpoint:1.1.1.1
	cagney_convert-20030606-branch:1.1.1.1.0.46
	cagney_convert-20030606-branchpoint:1.1.1.1
	cagney_writestrings-20030508-branch:1.1.1.1.0.44
	cagney_writestrings-20030508-branchpoint:1.1.1.1
	carlton_dictionary-20030523-merge:1.1.1.1
	cagney_fileio-20030521-branch:1.1.1.1.0.42
	cagney_fileio-20030521-branchpoint:1.1.1.1
	carlton_dictionary-20030430-merge:1.1.1.1
	carlton_dictionary-20030416-merge:1.1.1.1
	cagney_frameaddr-20030409-mergepoint:1.1.1.1
	cagney_frameaddr-20030403-branchpoint:1.1.1.1
	cagney_frameaddr-20030403-branch:1.1.1.1.0.40
	cagney_framebase-20030330-mergepoint:1.1.1.1
	cagney_framebase-20030326-branch:1.1.1.1.0.38
	cagney_framebase-20030326-branchpoint:1.1.1.1
	cagney_lazyid-20030317-branch:1.1.1.1.0.36
	cagney_lazyid-20030317-branchpoint:1.1.1.1
	offbyone-20030313-branch:1.1.1.1.0.34
	offbyone-20030313-branchpoint:1.1.1.1
	carlton_dictionary-20030305-merge:1.1.1.1
	cagney_offbyone-20030303-branch:1.1.1.1.0.32
	cagney_offbyone-20030303-branchpoint:1.1.1.1
	carlton_dictionary-20030207-merge:1.1.1.1
	interps-20030202-branch:1.1.1.1.0.30
	interps-20030202-branchpoint:1.1.1.1
	cagney-unwind-20030108-branch:1.1.1.1.0.28
	cagney-unwind-20030108-branchpoint:1.1.1.1
	carlton_dictionary-20021223-merge:1.1.1.1
	carlton_dictionary-20021115-merge:1.1.1.1
	kseitz_interps-20021105-merge:1.1.1.1
	kseitz_interps-20021103-merge:1.1.1.1
	drow-cplus-merge-20021020:1.1.1.1
	drow-cplus-merge-20021025:1.1.1.1
	carlton_dictionary-20021025-merge:1.1.1.1
	carlton_dictionary-20021011-merge:1.1.1.1
	drow-cplus-branch:1.1.1.1.0.26
	drow-cplus-branchpoint:1.1.1.1
	kseitz_interps-20020930-merge:1.1.1.1
	carlton_dictionary-20020927-merge:1.1.1.1
	carlton_dictionary-branch:1.1.1.1.0.24
	carlton_dictionary-20020920-branchpoint:1.1.1.1
	sid-20020905-branchpoint:1.1.1.1
	sid-20020905-branch:1.1.1.1.0.22
	gdb_5_3-branch:1.1.1.1.0.20
	gdb_5_3-2002-09-04-branchpoint:1.1.1.1
	kseitz_interps-20020829-merge:1.1.1.1
	cagney_sysregs-20020825-branch:1.1.1.1.0.18
	cagney_sysregs-20020825-branchpoint:1.1.1.1
	readline_4_3-import-branch:1.1.1.1.0.16
	readline_4_3-import-branchpoint:1.1.1.1
	kseitz_interps-20020528-branch:1.1.1.1.0.14
	kseitz_interps-20020528-branchpoint:1.1.1.1
	cagney_regbuf-20020515-branch:1.1.1.1.0.12
	cagney_regbuf-20020515-branchpoint:1.1.1.1
	gdb_5_2-branch:1.1.1.1.0.10
	gdb_5_2-2002-03-03-branchpoint:1.1.1.1
	cygnus_cvs_20020108_pre:1.1.1.1
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	dejagnu-2000-02-04:1.1.1.1
	dejagnu-2000-01-31:1.1.1.1
	dejagnu-2000-01-24:1.1.1.1
	dejagnu-2000-01-17:1.1.1.1
	dejagnu-2000-01-10:1.1.1.1
	dejagnu-2000-01-04:1.1.1.1
	dejagnu-1999-12-21:1.1.1.1
	dejagnu-1999-12-13:1.1.1.1
	dejagnu-1999-12-07:1.1.1.1
	dejagnu-1999-12-06:1.1.1.1
	dejagnu-1999-11-15:1.1.1.1
	dejagnu-1999-11-08:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2005.06.28.05.02.30;	author bje;	state dead;
branches;
next	1.1;

1.1
date	99.11.09.01.28.43;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.11.09.01.28.43;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Remove this old version of Expect.
@
text
@#!../expect -f
# ftp-inband - copy files over a telnet/rlogin/etc link
# Author: Don Libes, NIST
# Date: Jan 11, 1993

# Program follows usual conventions and is otherwise self-documenting.
# Assumes standard UNIX conventions on both sides.  It uses "compress"
# which can be replaced with gzip or removed totally - it's just there
# for efficiency.
# Assumes error-free transmission (i.e., MNP modems), telnet links, etc.
# Assumes remote shell does not reset tty modes after each command.

# Note, there is very little error checking.  This script was written
# primarily as an exercise - just to demonstrate Expect.

set prompt "(%|#|\\\$) $"		;# default prompt
catch {set prompt $env(EXPECT_PROMPT)}

set timeout -1
set verbose_flag 0

proc send_verbose {msg} {
	global verbose_flag

	if $verbose_flag {
		send_user $msg
	}
}

proc get {infile outfile} {
	global prompt verbose_flag

	if (!$verbose_flag) {
		log_user 0
	}

	send_verbose "disabling echo: "
	send "stty -echo\r"
	expect -re $prompt

	send_verbose "remote pid is "
	send "echo $$\r"
	expect -re "(.*)\r\n.*$prompt" {set rpid $expect_out(1,string)}

	set pid [pid]
	# pid is local pid, rpid is remote pid

	set infile_plain	"/tmp/$rpid"
	set infile_compressed	"$infile_plain.Z"
	set infile_encoded	"$infile_compressed.uu"

	set outfile_plain	"/tmp/$pid"
	set outfile_compressed	"$outfile_plain.Z"
	set outfile_encoded	"$outfile_compressed.uu"

	set out [open $outfile_encoded w]

	send_verbose "compressing\n"
	send "compress -fc $infile > $infile_compressed\r"
	expect -re $prompt

	# use label corresponding to temporary name on local system
	send_verbose "uuencoding\n"
	send "uuencode $infile_compressed $outfile_compressed > $infile_encoded\r"
	expect -re $prompt

	send_verbose "copying\n"
	send "cat $infile_encoded\r"

	log_user 0

	expect {
		-re "^end\r\n" {
			puts $out "end"
			close $out
		} -re "^(\[^\r]*)\r\n" {
			puts $out $expect_out(1,string)
			send_verbose "."
			exp_continue
		}
	}

	if ($verbose_flag) {
		send_user "\n"		;# after last "."
		log_user 1
	}

	expect -re $prompt			;# wait for prompt from cat

	send_verbose "deleting temporary files\n"
	send "rm -f $infile_compressed $infile_encoded\r"
	expect -re $prompt

	send_verbose "switching attention to local system\nuudecoding\n"
	exec uudecode $outfile_encoded

	send_verbose "uncompressing\n"
	exec uncompress -f $outfile_compressed

	send_verbose "renaming\n"
	if [catch "exec cp $outfile_plain $outfile" msg] {
		send_user "could not move file in place, reason: $msg\n"
		send_user "left as $outfile_plain\n"
		exec rm -f $outfile_encoded
	} else {
		exec rm -f $outfile_plain $outfile_encoded
	}

	# restore echo and serendipitously reprompt
	send "stty echo\r"

	log_user 1
}	

proc put {infile outfile} {
	global prompt verbose_flag

	if (!$verbose_flag) {
		log_user 0
	}

	send_verbose "disabling echo: "
	send "stty -echo\r"
	expect -re $prompt

	send_verbose "remote pid is "
	send "echo $$\r"
	expect -re "(.*)\r\n.*$prompt" {set rpid $expect_out(1,string)}

	set pid [pid]
	# pid is local pid, rpid is remote pid

	set infile_plain	"/tmp/$pid"
	set infile_compressed	"$infile_plain.Z"
	set infile_encoded	"$infile_compressed.uu"

	set outfile_plain	"/tmp/$rpid"
	set outfile_compressed	"$outfile_plain.Z"
	set outfile_encoded	"$outfile_compressed.uu"

	set out [open $outfile_encoded w]

	send_verbose "compressing\n"
	exec compress -fc $infile > $infile_compressed

	# use label corresponding to temporary name on local system
	send_verbose "uuencoding\n"
	exec uuencode $infile_compressed $outfile_compressed > $infile_encoded

	send_verbose "copying\n"
	send "cat > $outfile_encoded\r"

	log_user 0

	set fp [open $infile_encoded r]
	while 1 {
		if {-1 == [gets $fp buf]} break
		send_verbose "."
		send "$buf\r"
	}

	if ($verbose_flag) {
		send_user "\n"			;# after last "."
		log_user 1
	}

	send "\004"				;# eof
	close $fp

	send_verbose "deleting temporary files\n"
	exec rm -f $infile_compressed $infile_encoded

	send_verbose "switching attention to remote system\n"

	expect -re $prompt			;# wait for prompt from cat

	send_verbose "uudecoding\n"
	send "uudecode $outfile_encoded\r"
	expect -re $prompt

	send_verbose "uncompressing\n"
	send "uncompress -f $outfile_compressed\r"
	expect -re $prompt

	send_verbose "renaming\n"
	send "cp $outfile_plain $outfile\r"
	expect -re $prompt

	send_verbose "deleting temporary files\n"
	send "rm -f $outfile_plain $outfile_encoded\r"
	expect -re $prompt

	# restore echo and serendipitously reprompt
	send "stty echo\r"

	log_user 1
}	

proc get_main {} {
	stty -raw echo
	send_user "g\nget remote file \[localfile]: "
	expect_user {
		-re "(\[^ ]+) +(\[^ ]+)\n" {
			send_user "copying (remote) $expect_out(1,string) to (local) $expect_out(2,string)\n"
			get $expect_out(1,string) $expect_out(2,string)
		} -re "(\[^ ]+)\n" {
			send_user "copying $expect_out(1,string)\n"
			get $expect_out(1,string) $expect_out(1,string)
		} -re "\n" {
			send_user "eh?\n"
		}
	}
	stty raw -echo
}

proc put_main {} {
	stty -raw echo
	send_user "p\nput localfile \[remotefile]: "
	expect_user {
		-re "(\[^ ]+) +(\[^ ]+)\n" {
			send_user "copying (local) $expect_out(1,string) to (remote) $expect_out(2,string)\n"
			put $expect_out(1,string) $expect_out(2,string)
		} -re "(\[^ ]+)\n" {
			send_user "copying $expect_out(1,string)\n"
			put $expect_out(1,string) $expect_out(1,string)
		} -re "\n" {
			send_user "eh?\n"
		}
	}
	stty raw -echo
}

proc chdir {} {
	stty -raw echo
	send_user "c\n"
	send_user "current directory is [pwd], new directory: "
	expect_user -re "(.*)\n" {
		cd $expect_out(1,string)
	}
	stty raw -echo
}

proc verbose {} {
	global verbose_flag

	set verbose_flag [expr !$verbose_flag]
	send_user "verbose [verbose_status]\r\n"
}

proc verbose_status {} {
	global verbose_flag

	if $verbose_flag {
		return "on"
	} else {
		return "off"
	}
}

proc cmd {} {
	set CTRLZ \032

	send_user "command (g,p,? for more): "
	expect_user {
		g get_main
		p put_main
		c chdir
		v verbose
		~ {send "~"}
		"\\?" {
			send_user "?\n"
			send_user "~~g  get file from remote system\n"
			send_user "~~p  put file to remote system\n"
			send_user "~~c  change/show directory on local system\n"
			send_user "~~~  send ~~ to remote system\n"
			send_user "~~?  this list\n"
			send_user "~~v  verbose mode toggle (currently [verbose_status])\n"
			send_user "~~^Z suspend\n"
		}
		$CTRLZ {
			stty -raw echo
			exec kill -STOP [pid]
			stty raw -echo
		}
		-re . {send_user "unknown command\n"}
	}
	send_user "resuming session...\n"
}

spawn -noecho $env(SHELL)

send_user "Once logged in, cd to directory to transfer to/from and press: ~~\n"
send_user "One moment...\n"
interact ~~ cmd

@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@import dejagnu-1999-11-08 snapshot
@
text
@@
