head	1.2;
access;
symbols
	msnyder-tracepoint-checkpoint-branch:1.1.1.1.0.58
	msnyder-tracepoint-checkpoint-branchpoint:1.1.1.1
	ezannoni_pie-20040323-branch:1.1.1.1.0.56
	ezannoni_pie-20040323-branchpoint:1.1.1.1
	cagney_tramp-20040321-mergepoint:1.1.1.1
	gdb_6_1-branch:1.1.1.1.0.54
	gdb_6_1-2004-03-01-gmt-branchpoint:1.1.1.1
	drow-cplus-merge-20040208:1.1.1.1
	carlton_dictionary-20040126-merge:1.1.1.1
	drow-cplus-merge-20040113:1.1.1.1
	drow-cplus-merge-20031224:1.1.1.1
	drow-cplus-merge-20031220:1.1.1.1
	carlton_dictionary-20031215-merge:1.1.1.1
	drow-cplus-merge-20031214:1.1.1.1
	carlton-dictionary-20031111-merge:1.1.1.1
	carlton_dictionary-20030917-merge:1.1.1.1
	ezannoni_pie-20030916-branchpoint:1.1.1.1
	ezannoni_pie-20030916-branch:1.1.1.1.0.52
	cagney_x86i386-20030821-branch:1.1.1.1.0.50
	cagney_x86i386-20030821-branchpoint:1.1.1.1
	carlton_dictionary-20030805-merge:1.1.1.1
	carlton_dictionary-20030627-merge:1.1.1.1
	gdb_6_0-branch:1.1.1.1.0.48
	gdb_6_0-2003-06-23-branchpoint:1.1.1.1
	cagney_convert-20030606-branch:1.1.1.1.0.46
	cagney_convert-20030606-branchpoint:1.1.1.1
	cagney_writestrings-20030508-branch:1.1.1.1.0.44
	cagney_writestrings-20030508-branchpoint:1.1.1.1
	carlton_dictionary-20030523-merge:1.1.1.1
	cagney_fileio-20030521-branch:1.1.1.1.0.42
	cagney_fileio-20030521-branchpoint:1.1.1.1
	carlton_dictionary-20030430-merge:1.1.1.1
	carlton_dictionary-20030416-merge:1.1.1.1
	cagney_frameaddr-20030409-mergepoint:1.1.1.1
	cagney_frameaddr-20030403-branchpoint:1.1.1.1
	cagney_frameaddr-20030403-branch:1.1.1.1.0.40
	cagney_framebase-20030330-mergepoint:1.1.1.1
	cagney_framebase-20030326-branch:1.1.1.1.0.38
	cagney_framebase-20030326-branchpoint:1.1.1.1
	cagney_lazyid-20030317-branch:1.1.1.1.0.36
	cagney_lazyid-20030317-branchpoint:1.1.1.1
	offbyone-20030313-branch:1.1.1.1.0.34
	offbyone-20030313-branchpoint:1.1.1.1
	carlton_dictionary-20030305-merge:1.1.1.1
	cagney_offbyone-20030303-branch:1.1.1.1.0.32
	cagney_offbyone-20030303-branchpoint:1.1.1.1
	carlton_dictionary-20030207-merge:1.1.1.1
	interps-20030202-branch:1.1.1.1.0.30
	interps-20030202-branchpoint:1.1.1.1
	cagney-unwind-20030108-branch:1.1.1.1.0.28
	cagney-unwind-20030108-branchpoint:1.1.1.1
	carlton_dictionary-20021223-merge:1.1.1.1
	carlton_dictionary-20021115-merge:1.1.1.1
	kseitz_interps-20021105-merge:1.1.1.1
	kseitz_interps-20021103-merge:1.1.1.1
	drow-cplus-merge-20021020:1.1.1.1
	drow-cplus-merge-20021025:1.1.1.1
	carlton_dictionary-20021025-merge:1.1.1.1
	carlton_dictionary-20021011-merge:1.1.1.1
	drow-cplus-branch:1.1.1.1.0.26
	drow-cplus-branchpoint:1.1.1.1
	kseitz_interps-20020930-merge:1.1.1.1
	carlton_dictionary-20020927-merge:1.1.1.1
	carlton_dictionary-branch:1.1.1.1.0.24
	carlton_dictionary-20020920-branchpoint:1.1.1.1
	sid-20020905-branchpoint:1.1.1.1
	sid-20020905-branch:1.1.1.1.0.22
	gdb_5_3-branch:1.1.1.1.0.20
	gdb_5_3-2002-09-04-branchpoint:1.1.1.1
	kseitz_interps-20020829-merge:1.1.1.1
	cagney_sysregs-20020825-branch:1.1.1.1.0.18
	cagney_sysregs-20020825-branchpoint:1.1.1.1
	readline_4_3-import-branch:1.1.1.1.0.16
	readline_4_3-import-branchpoint:1.1.1.1
	kseitz_interps-20020528-branch:1.1.1.1.0.14
	kseitz_interps-20020528-branchpoint:1.1.1.1
	cagney_regbuf-20020515-branch:1.1.1.1.0.12
	cagney_regbuf-20020515-branchpoint:1.1.1.1
	gdb_5_2-branch:1.1.1.1.0.10
	gdb_5_2-2002-03-03-branchpoint:1.1.1.1
	cygnus_cvs_20020108_pre:1.1.1.1
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	dejagnu-2000-02-04:1.1.1.1
	dejagnu-2000-01-31:1.1.1.1
	dejagnu-2000-01-24:1.1.1.1
	dejagnu-2000-01-17:1.1.1.1
	dejagnu-2000-01-10:1.1.1.1
	dejagnu-2000-01-04:1.1.1.1
	dejagnu-1999-12-21:1.1.1.1
	dejagnu-1999-12-13:1.1.1.1
	dejagnu-1999-12-07:1.1.1.1
	dejagnu-1999-12-06:1.1.1.1
	dejagnu-1999-11-15:1.1.1.1
	dejagnu-1999-11-08:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2005.06.28.05.02.30;	author bje;	state dead;
branches;
next	1.1;

1.1
date	99.11.09.01.28.43;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.11.09.01.28.43;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Remove this old version of Expect.
@
text
@#!../expect --
# Name: autoexpect - generate an Expect script from watching a session
#
# Description:
#
# Given a program name, autoexpect will run that program.  Otherwise
# autoexpect will start a shell.  Interact as desired.  When done, exit
# the program or shell.  Autoexpect will create a script that reproduces
# your interactions.  By default, the script is named script.exp.
# See the man page for more info.
#
# Author: Don Libes, NIST
# Date: June 30 1995
# Version: 1.4b

set filename "script.exp"
set verbose 1
set conservative 0
set promptmode 0
set option_keys ""

proc check_for_following {type} {
	if ![llength [uplevel set argv]] {
		puts "autoexpect: [uplevel set flag] requires following $type"
		exit 1
	}
}	

while {[llength $argv]>0} {
	set flag [lindex $argv 0]
	if 0==[regexp "^-" $flag] break
	set argv [lrange $argv 1 end]
	switch -- $flag \
	  "-c" {
		set conservative 1
	} "-C" {
		check_for_following character
		lappend option_keys [lindex $argv 0] ctoggle
		set argv [lrange $argv 1 end]
	} "-p" {
		set promptmode 1
	} "-P" {
		check_for_following character
		lappend option_keys [lindex $argv 0] ptoggle
		set argv [lrange $argv 1 end]
	} "-Q" {
		check_for_following character
		lappend option_keys [lindex $argv 0] quote
		set argv [lrange $argv 1 end]
	} "-f" {
		check_for_following filename
		set filename [lindex $argv 0]
		set argv [lrange $argv 1 end]
	} "-quiet" {
		set verbose 0
	} default {
		break
	}
}

#############################################################
# Variables	Descriptions
#############################################################
# userbuf	buffered characters from user
# procbuf	buffered characters from process
# lastkey	last key pressed by user
#		if undefined, last key came from process
# echoing	if the process is echoing
#############################################################

# Handle a character that came from user input (i.e., the keyboard)
proc input {c} {
	global userbuf lastkey

	send -- $c
	append userbuf $lastkey
	set lastkey $c
}

# Handle a null character from the keyboard
proc input_null {} {
	global lastkey userbuf procbuf echoing

	send -null

	if {$lastkey == ""} {
		if $echoing {
			sendcmd "$userbuf"
		}
		if {$procbuf != ""} {
			expcmd "$procbuf"
		}
	} else {
		sendcmd "$userbuf"
		if $echoing {
			expcmd "$procbuf"
			sendcmd "$lastkey"
		}			
	}
	cmd "send -null"
	set userbuf ""
	set procbuf ""
	set lastkey ""
	set echoing 0
}

# Handle a character that came from the process
proc output {s} {
	global lastkey procbuf userbuf echoing

	send_user -raw -- $s

	if {$lastkey == ""} {
		if !$echoing {
			append procbuf $s
		} else {
			sendcmd "$userbuf"
			expcmd "$procbuf"
			set echoing 0
			set userbuf ""
			set procbuf $s
		}
		return
	}

	regexp (.)(.*) $s dummy c tail
	if {$c == $lastkey} {
		if $echoing {
			append userbuf $lastkey
			set lastkey ""
		} else {
			if {$procbuf != ""} {
				expcmd "$procbuf"
				set procbuf ""
			}
			set echoing 1
		}
		append procbuf $s

		if [string length $tail] {
			sendcmd "$userbuf$lastkey"
			set userbuf ""
			set lastkey ""
			set echoing 0
		}
	} else {
		if !$echoing {
			expcmd "$procbuf"
		}
		sendcmd "$userbuf$lastkey"
		set procbuf $s
		set userbuf ""
		set lastkey ""
		set echoing 0
	}
}

# rewrite raw strings so that can appear as source code but still reproduce
# themselves.
proc expand {s} {
	regsub -all "\\\\" $s "\\\\\\\\" s
	regsub -all "\r" $s "\\r"  s
	regsub -all "\"" $s "\\\"" s
	regsub -all "\\\[" $s "\\\[" s
	regsub -all "\\\]" $s "\\\]" s
	regsub -all "\\\$" $s "\\\$" s

	return $s
}

# generate an expect command
proc expcmd {s} {
	global promptmode

	if $promptmode {
		regexp ".*\[\r\n]+(.*)" $s dummy s
	}

	cmd "expect -exact \"[expand $s]\""
}

# generate a send command
proc sendcmd {s} {
	global send_style conservative

	if {$conservative} {
		cmd "sleep .1"
	}

	cmd "send$send_style -- \"[expand $s]\""
}

# generate any command
proc cmd {s} {
	global fd
	puts $fd "$s"
}

proc verbose_send_user {s} {
	global verbose

	if $verbose {
		send_user -- $s
	}
}

proc ctoggle {} {
	global conservative send_style

	if $conservative {
		cmd "# conservative mode off - adding no delays"
		verbose_send_user "conservative mode off\n"
		set conservative 0
		set send_style ""
	} else {
		cmd "# prompt mode on - adding delays"
		verbose_send_user "conservative mode on\n"
		set conservative 1
		set send_style " -s"
	}
}

proc ptoggle {} {
	global promptmode

	if $promptmode {
		cmd "# prompt mode off - now looking for complete output"
		verbose_send_user "prompt mode off\n"
		set promptmode 0
	} else {
		cmd "# prompt mode on - now looking only for prompts"
		verbose_send_user "prompt mode on\n"
		set promptmode 1
	}
}

# quote the next character from the user
proc quote {} {
	expect_user -re .
	send -- $expect_out(buffer)
}
	

if [catch {set fd [open $filename w]} msg] {
	puts $msg
	exit
}
exec chmod +x $filename
verbose_send_user "autoexpect started, file is $filename\n"

# calculate a reasonable #! line
set expectpath /usr/local/bin		;# prepare default
foreach dir [split $env(PATH) :] {	;# now look for real location
	if [file executable $dir/expect] {
		set expectpath $dir
		break
	}
}

cmd "#![set expectpath]/expect -f
#
# This Expect script was generated by autoexpect on [timestamp -format %c]
# Expect and autoexpect were both written by Don Libes, NIST."
cmd {#
# Note that autoexpect does not guarantee a working script.  It
# necessarily has to guess about certain things.  Two reasons a script
# might fail are:
#
# 1) timing - A surprising number of programs (rn, ksh, zsh, telnet,
# etc.) and devices discard or ignore keystrokes that arrive "too
# quickly" after prompts.  If you find your new script hanging up at
# one spot, try adding a short sleep just before the previous send.
# Setting "force_conservative" to 1 (see below) makes Expect do this
# automatically - pausing briefly before sending each character.  This
# pacifies every program I know of.  The -c flag makes the script do
# this in the first place.  The -C flag allows you to define a
# character to toggle this mode off and on.

set force_conservative 0  ;# set to 1 to force conservative mode even if
			  ;# script wasn't run conservatively originally
if {$force_conservative} {
	set send_slow {1 .1}
	proc send {ignore arg} {
		sleep .1
		exp_send -s -- $arg
	}
}

#
# 2) differing output - Some programs produce different output each time
# they run.  The "date" command is an obvious example.  Another is
# ftp, if it produces throughput statistics at the end of a file
# transfer.  If this causes a problem, delete these patterns or replace
# them with wildcards.  An alternative is to use the -p flag (for
# "prompt") which makes Expect only look for the last line of output
# (i.e., the prompt).  The -P flag allows you to define a character to
# toggle this mode off and on.
#
# Read the man page for more info.
#
# -Don

}

cmd "set timeout -1"
if $conservative {
	set send_style " -s"
	cmd "set send_slow {1 .1}"
} else {
	set send_style ""
}

if [llength $argv]>0 {
	eval spawn -noecho $argv
	cmd "spawn $argv"
} else {
	spawn -noecho $env(SHELL)
	cmd "spawn \$env(SHELL)"
}

cmd "match_max 100000"

set lastkey ""
set procbuf ""
set userbuf ""
set echoing 0

remove_nulls 0

eval interact $option_keys {
	-re . {
		input $interact_out(0,string)
	} null {
		input_null
	} \
	-o \
	-re .+ {
		output $interact_out(0,string)
	} eof {
		cmd "expect eof"
		return
	} null {
	}
}

close $fd
verbose_send_user "autoexpect done, file is $filename\n"
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@import dejagnu-1999-11-08 snapshot
@
text
@@
