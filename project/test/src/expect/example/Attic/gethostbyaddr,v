head	1.2;
access;
symbols
	msnyder-tracepoint-checkpoint-branch:1.1.1.1.0.58
	msnyder-tracepoint-checkpoint-branchpoint:1.1.1.1
	ezannoni_pie-20040323-branch:1.1.1.1.0.56
	ezannoni_pie-20040323-branchpoint:1.1.1.1
	cagney_tramp-20040321-mergepoint:1.1.1.1
	gdb_6_1-branch:1.1.1.1.0.54
	gdb_6_1-2004-03-01-gmt-branchpoint:1.1.1.1
	drow-cplus-merge-20040208:1.1.1.1
	carlton_dictionary-20040126-merge:1.1.1.1
	drow-cplus-merge-20040113:1.1.1.1
	drow-cplus-merge-20031224:1.1.1.1
	drow-cplus-merge-20031220:1.1.1.1
	carlton_dictionary-20031215-merge:1.1.1.1
	drow-cplus-merge-20031214:1.1.1.1
	carlton-dictionary-20031111-merge:1.1.1.1
	carlton_dictionary-20030917-merge:1.1.1.1
	ezannoni_pie-20030916-branchpoint:1.1.1.1
	ezannoni_pie-20030916-branch:1.1.1.1.0.52
	cagney_x86i386-20030821-branch:1.1.1.1.0.50
	cagney_x86i386-20030821-branchpoint:1.1.1.1
	carlton_dictionary-20030805-merge:1.1.1.1
	carlton_dictionary-20030627-merge:1.1.1.1
	gdb_6_0-branch:1.1.1.1.0.48
	gdb_6_0-2003-06-23-branchpoint:1.1.1.1
	cagney_convert-20030606-branch:1.1.1.1.0.46
	cagney_convert-20030606-branchpoint:1.1.1.1
	cagney_writestrings-20030508-branch:1.1.1.1.0.44
	cagney_writestrings-20030508-branchpoint:1.1.1.1
	carlton_dictionary-20030523-merge:1.1.1.1
	cagney_fileio-20030521-branch:1.1.1.1.0.42
	cagney_fileio-20030521-branchpoint:1.1.1.1
	carlton_dictionary-20030430-merge:1.1.1.1
	carlton_dictionary-20030416-merge:1.1.1.1
	cagney_frameaddr-20030409-mergepoint:1.1.1.1
	cagney_frameaddr-20030403-branchpoint:1.1.1.1
	cagney_frameaddr-20030403-branch:1.1.1.1.0.40
	cagney_framebase-20030330-mergepoint:1.1.1.1
	cagney_framebase-20030326-branch:1.1.1.1.0.38
	cagney_framebase-20030326-branchpoint:1.1.1.1
	cagney_lazyid-20030317-branch:1.1.1.1.0.36
	cagney_lazyid-20030317-branchpoint:1.1.1.1
	offbyone-20030313-branch:1.1.1.1.0.34
	offbyone-20030313-branchpoint:1.1.1.1
	carlton_dictionary-20030305-merge:1.1.1.1
	cagney_offbyone-20030303-branch:1.1.1.1.0.32
	cagney_offbyone-20030303-branchpoint:1.1.1.1
	carlton_dictionary-20030207-merge:1.1.1.1
	interps-20030202-branch:1.1.1.1.0.30
	interps-20030202-branchpoint:1.1.1.1
	cagney-unwind-20030108-branch:1.1.1.1.0.28
	cagney-unwind-20030108-branchpoint:1.1.1.1
	carlton_dictionary-20021223-merge:1.1.1.1
	carlton_dictionary-20021115-merge:1.1.1.1
	kseitz_interps-20021105-merge:1.1.1.1
	kseitz_interps-20021103-merge:1.1.1.1
	drow-cplus-merge-20021020:1.1.1.1
	drow-cplus-merge-20021025:1.1.1.1
	carlton_dictionary-20021025-merge:1.1.1.1
	carlton_dictionary-20021011-merge:1.1.1.1
	drow-cplus-branch:1.1.1.1.0.26
	drow-cplus-branchpoint:1.1.1.1
	kseitz_interps-20020930-merge:1.1.1.1
	carlton_dictionary-20020927-merge:1.1.1.1
	carlton_dictionary-branch:1.1.1.1.0.24
	carlton_dictionary-20020920-branchpoint:1.1.1.1
	sid-20020905-branchpoint:1.1.1.1
	sid-20020905-branch:1.1.1.1.0.22
	gdb_5_3-branch:1.1.1.1.0.20
	gdb_5_3-2002-09-04-branchpoint:1.1.1.1
	kseitz_interps-20020829-merge:1.1.1.1
	cagney_sysregs-20020825-branch:1.1.1.1.0.18
	cagney_sysregs-20020825-branchpoint:1.1.1.1
	readline_4_3-import-branch:1.1.1.1.0.16
	readline_4_3-import-branchpoint:1.1.1.1
	kseitz_interps-20020528-branch:1.1.1.1.0.14
	kseitz_interps-20020528-branchpoint:1.1.1.1
	cagney_regbuf-20020515-branch:1.1.1.1.0.12
	cagney_regbuf-20020515-branchpoint:1.1.1.1
	gdb_5_2-branch:1.1.1.1.0.10
	gdb_5_2-2002-03-03-branchpoint:1.1.1.1
	cygnus_cvs_20020108_pre:1.1.1.1
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	dejagnu-2000-02-04:1.1.1.1
	dejagnu-2000-01-31:1.1.1.1
	dejagnu-2000-01-24:1.1.1.1
	dejagnu-2000-01-17:1.1.1.1
	dejagnu-2000-01-10:1.1.1.1
	dejagnu-2000-01-04:1.1.1.1
	dejagnu-1999-12-21:1.1.1.1
	dejagnu-1999-12-13:1.1.1.1
	dejagnu-1999-12-07:1.1.1.1
	dejagnu-1999-12-06:1.1.1.1
	dejagnu-1999-11-15:1.1.1.1
	dejagnu-1999-11-08:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2005.06.28.05.02.30;	author bje;	state dead;
branches;
next	1.1;

1.1
date	99.11.09.01.28.43;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.11.09.01.28.43;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Remove this old version of Expect.
@
text
@#!../expect --
#
# gethostbyaddr a.b.c.d - translate an internet address to a FQDN,
#			  guessing (a lot) if necessary.
# Author: Don Libes, NIST
# Version 4.0
# Written: January 11, 1991
# Last revised: March 21, 1996

# By default, return a FQDN (fully qualified domain name) or descriptive
# string (if FQDN is not easily determinable).  This is tagged with a brief
# explanation of how it was determined.
#
# If the host part of the FQDN cannot be determined, the original IP address
# is used.  
#
# Optional arguments act as toggles:					Default
# -t	tag names with a description of how derived.			true
# -v	verbose.							false
# -r	reverse names to see if they resolve back to orig IP address.	true
# -n	query nic for a descriptive string if it begins to look like	true
#	the FQDN may be hard to derive.
# -d	turn on debugging to expose underlying dialogue			false
#
# These options and others (see below) may be set in a ~/.gethostbyaddr file
# To set options from that file, use the same syntax as below.
set timeout 120		;# timeout query after this many seconds
set tag 1		;# same as -t
set reverse 1		;# same as -r
set verbose 0		;# same as -v
set nic 1		;# same as -n
set debug 0		;# same as -d
log_user 0

proc usage {} {
	send_user "usage: gethostbyaddr \[options\] a.b.c.d\n"
	send_user "options meaning (all options act as toggles)      default\n"
	send_user "  -t    tag with derivation description           true\n"
	send_user "  -v    verbose				     false\n"
	send_user "  -r    reverse back to IP addr for verification  true\n"
	send_user "  -n    query nic                                 true\n"
	send_user "  -d    produce debugging output                  false\n"
	send_user "options must be separate.\n"
	exit
}

if [file readable ~/.gethostbyaddr] {source ~/.gethostbyaddr}

while {[llength $argv]>0} {
	set flag [lindex $argv 0]
	switch -- $flag \
	"-v" {
		set verbose [expr !$verbose]
		set argv [lrange $argv 1 end]
	} "-r" {
		set reverse [expr !$reverse]
		set argv [lrange $argv 1 end]
	} "-n" {
		set nic [expr !$nic]
		set argv [lrange $argv 1 end]
	} "-t" {
		set tag [expr !$tag]
		set argv [lrange $argv 1 end]
	} "-d" {
		set debug [expr !$debug]
		set argv [lrange $argv 1 end]
		debug $debug
	} default {
		break
	}
}

set IPaddress $argv

if [llength $argv]!=1 usage
if 4!=[scan $IPaddress "%d.%d.%d.%d" a b c d] usage

proc vprint {s} {
	global verbose

	if !$verbose return
	send_user $s\n
}

# dn==1 if domain name, 0 if text (from nic)
proc printhost {name how dn} {
	global reverse tag IPaddress

	if {$dn && $reverse} {
		set verified [verify $name $IPaddress]
	} else {set verified 0}

	if {$verified || !$reverse || !$dn} {
		if $tag {
			send_user "$name ($how)\n"
		} else {
			send_user "$name\n"
		}
		
		if {$verified || !$reverse} {
			close
			wait
			exit
		}
	}
}

# return 1 if name resolves to IP address
proc verify {name IPaddress} {
	vprint "verifying $name is $IPaddress"
	set rc 0
	spawn nslookup
	expect ">*"
	send $name\r

	expect {
	 	-re "\\*\\*\\* (\[^\r]*)\r" {
			vprint $expect_out(1,string)
		} timeout {
			vprint "timed out"
		} -re "Address:.*Address:  (\[^\r]*)\r" {
			set addr2 $expect_out(1,string)
			if [string match $IPaddress $addr2] {
				vprint "verified"
				set rc 1
			} else {
				vprint "not verified - $name is $addr2"
			}
		}
	}
	close
	wait
	return $rc
}

set bad_telnet_responses "(telnet:|: unknown).*"

proc telnet_error {s} {
	regexp ": (.*)\r" $s dontcare msg
	vprint $msg
}

proc guessHost {guess} {
	global guessHost
	if [info exists guessHost] return
	set guessHost $guess
}

proc guessDomain {guess} {
	global guessDomain
	if [info exists guessDomain] return
	set guessDomain $guess
}

proc guessFQDN {} {
	global guessHost guessDomain
	return $guessHost.$guessDomain
}

######################################################################
# first do a simple reverse nslookup
######################################################################

vprint "using nslookup"
spawn nslookup
expect ">*"
send "set query=ptr\r"
expect ">*"
send "$d.$c.$b.$a.in-addr.arpa\r"
expect {
	timeout {
		vprint "timed out"
	} -re "\\*\\*\\* (\[^\r]*)\r" {
		vprint $expect_out(1,string)
	} -re "name = (\[^\r]*)\r" {
		set host $expect_out(1,string)
		printhost $host nslookup 1

		# split out hostname from FQDN as guess for later
		guessHost [lindex [split $host "."] 0]
	}
}

close
wait

######################################################################
# next telnet to host and ask it what its name is
######################################################################

vprint "talking smtp to $IPaddress"
spawn telnet $IPaddress smtp
expect	{
	-re $bad_telnet_responses {
		telnet_error $expect_out(buffer)
	} timeout {
		vprint "timed out"
	} -re "\n220 (\[^\\. ]*).?(\[^ ]*)" {
		set host $expect_out(1,string)
		set domain $expect_out(2,string)
		printhost $host.$domain smtp 1

		# if not valid FQDN, it's likely either host or domain
		if [string length $domain] {
		    guessDomain $host.$domain
		} else {
		    guessHost $host
		}
	}
}
catch close
wait

######################################################################
# ask NIC for any info about this host
######################################################################

if {$nic || ($d == 0)} {
 vprint "talking to nic"
 spawn telnet internic.net
 expect	{
	-re $bad_telnet_responses {
		telnet_error $expect_out(buffer)
	} timeout {
		vprint "timed out"
	} "InterNIC >" {
		send "whois\r"
		expect "Whois: "
		vprint "getting info on network $a.$b.$c"
		send "net $a.$b.$c\r"
		expect {
		    "No match*" {
			vprint "no info"
			expect "Whois: "
			vprint "getting info on network $a.$b"
			send "net $a.$b\r"
			expect {
			    "No match*" {
				vprint "no info"
			    } -re "net\r\n(\[^\r]*)\r" {
				printhost $expect_out(1,string) nic 0
			    } timeout {
				vprint "timed out"
			    }
			}
		    } -re "net\r\n(\[^\r]*)\r" {
			printhost $expect_out(1,string) nic 0
		    } timeout {
			vprint "timed out"
		    }
		}
	}
 }
 catch close
 wait
 if {$d == 0} exit
}

######################################################################
# ask other hosts in the same class C what their name is
# so that we can at least get the likely domain
#
# do this in two loops - first from current IP address down to 0
# and then next from current IP address up to 255
######################################################################

# give up guessing host name
guessHost "unknown"

for {set i [expr $d-1]} {$i>0} {incr i -1} {
	vprint "talking smtp to $a.$b.$c.$i"
	spawn telnet $a.$b.$c.$i smtp
	expect {
		-re $bad_telnet_responses {
			telnet_error $expect_out(buffer)
		} timeout {
			vprint "timed out"
		} -re "\n220 (\[^\\. ]*).?(\[^ ]*)" {
			set host $expect_out(1,string)
			set domain $expect_out(2,string)
			printhost $guessHost.$domain "smtp - $a.$b.$c.$i is $host.$domain" 1

			# if not valid FQDN, it's likely either host or domain
			# don't bother recording host since it can't be for
			# original addr.
			if [string length $domain] {
			    guessDomain $host.$domain
			}
		}
	}
	catch close
	wait
}

for {set i [expr $d+1]} {$i<255} {incr i} {
	vprint "talking smtp to $a.$b.$c.$i"
	spawn telnet $a.$b.$c.$i smtp
	expect {
		-re $bad_telnet_responses {
			telnet_error $expect_out(buffer)
		} timeout {
			vprint "timed out"
		} -re "\n220 (\[^ ]*.(\[^ ])) " {
			set host $expect_out(1,string)
			set domain $expect_out(2,string)
			printhost $guessHost.$domain "smtp - $a.$b.$c.$i is $host.$domain" 1

			# if not valid FQDN, it's likely either host or domain
			# don't bother recording host since it can't be for
			# original addr.
			if [string length $domain] {
			    guessDomain $host.$domain
			}
		}
	}
	catch close
	wait
}

######################################################################
# print our best guess as to the name
######################################################################


# How pathetic.  Print something, anything!
if {!$verbose && !$tag} {send_user [guessFQDN]}
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@import dejagnu-1999-11-08 snapshot
@
text
@@
