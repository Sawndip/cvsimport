head	1.2;
access;
symbols
	msnyder-tracepoint-checkpoint-branch:1.1.1.1.0.58
	msnyder-tracepoint-checkpoint-branchpoint:1.1.1.1
	ezannoni_pie-20040323-branch:1.1.1.1.0.56
	ezannoni_pie-20040323-branchpoint:1.1.1.1
	cagney_tramp-20040321-mergepoint:1.1.1.1
	gdb_6_1-branch:1.1.1.1.0.54
	gdb_6_1-2004-03-01-gmt-branchpoint:1.1.1.1
	drow-cplus-merge-20040208:1.1.1.1
	carlton_dictionary-20040126-merge:1.1.1.1
	drow-cplus-merge-20040113:1.1.1.1
	drow-cplus-merge-20031224:1.1.1.1
	drow-cplus-merge-20031220:1.1.1.1
	carlton_dictionary-20031215-merge:1.1.1.1
	drow-cplus-merge-20031214:1.1.1.1
	carlton-dictionary-20031111-merge:1.1.1.1
	carlton_dictionary-20030917-merge:1.1.1.1
	ezannoni_pie-20030916-branchpoint:1.1.1.1
	ezannoni_pie-20030916-branch:1.1.1.1.0.52
	cagney_x86i386-20030821-branch:1.1.1.1.0.50
	cagney_x86i386-20030821-branchpoint:1.1.1.1
	carlton_dictionary-20030805-merge:1.1.1.1
	carlton_dictionary-20030627-merge:1.1.1.1
	gdb_6_0-branch:1.1.1.1.0.48
	gdb_6_0-2003-06-23-branchpoint:1.1.1.1
	cagney_convert-20030606-branch:1.1.1.1.0.46
	cagney_convert-20030606-branchpoint:1.1.1.1
	cagney_writestrings-20030508-branch:1.1.1.1.0.44
	cagney_writestrings-20030508-branchpoint:1.1.1.1
	carlton_dictionary-20030523-merge:1.1.1.1
	cagney_fileio-20030521-branch:1.1.1.1.0.42
	cagney_fileio-20030521-branchpoint:1.1.1.1
	carlton_dictionary-20030430-merge:1.1.1.1
	carlton_dictionary-20030416-merge:1.1.1.1
	cagney_frameaddr-20030409-mergepoint:1.1.1.1
	cagney_frameaddr-20030403-branchpoint:1.1.1.1
	cagney_frameaddr-20030403-branch:1.1.1.1.0.40
	cagney_framebase-20030330-mergepoint:1.1.1.1
	cagney_framebase-20030326-branch:1.1.1.1.0.38
	cagney_framebase-20030326-branchpoint:1.1.1.1
	cagney_lazyid-20030317-branch:1.1.1.1.0.36
	cagney_lazyid-20030317-branchpoint:1.1.1.1
	offbyone-20030313-branch:1.1.1.1.0.34
	offbyone-20030313-branchpoint:1.1.1.1
	carlton_dictionary-20030305-merge:1.1.1.1
	cagney_offbyone-20030303-branch:1.1.1.1.0.32
	cagney_offbyone-20030303-branchpoint:1.1.1.1
	carlton_dictionary-20030207-merge:1.1.1.1
	interps-20030202-branch:1.1.1.1.0.30
	interps-20030202-branchpoint:1.1.1.1
	cagney-unwind-20030108-branch:1.1.1.1.0.28
	cagney-unwind-20030108-branchpoint:1.1.1.1
	carlton_dictionary-20021223-merge:1.1.1.1
	carlton_dictionary-20021115-merge:1.1.1.1
	kseitz_interps-20021105-merge:1.1.1.1
	kseitz_interps-20021103-merge:1.1.1.1
	drow-cplus-merge-20021020:1.1.1.1
	drow-cplus-merge-20021025:1.1.1.1
	carlton_dictionary-20021025-merge:1.1.1.1
	carlton_dictionary-20021011-merge:1.1.1.1
	drow-cplus-branch:1.1.1.1.0.26
	drow-cplus-branchpoint:1.1.1.1
	kseitz_interps-20020930-merge:1.1.1.1
	carlton_dictionary-20020927-merge:1.1.1.1
	carlton_dictionary-branch:1.1.1.1.0.24
	carlton_dictionary-20020920-branchpoint:1.1.1.1
	sid-20020905-branchpoint:1.1.1.1
	sid-20020905-branch:1.1.1.1.0.22
	gdb_5_3-branch:1.1.1.1.0.20
	gdb_5_3-2002-09-04-branchpoint:1.1.1.1
	kseitz_interps-20020829-merge:1.1.1.1
	cagney_sysregs-20020825-branch:1.1.1.1.0.18
	cagney_sysregs-20020825-branchpoint:1.1.1.1
	readline_4_3-import-branch:1.1.1.1.0.16
	readline_4_3-import-branchpoint:1.1.1.1
	kseitz_interps-20020528-branch:1.1.1.1.0.14
	kseitz_interps-20020528-branchpoint:1.1.1.1
	cagney_regbuf-20020515-branch:1.1.1.1.0.12
	cagney_regbuf-20020515-branchpoint:1.1.1.1
	gdb_5_2-branch:1.1.1.1.0.10
	gdb_5_2-2002-03-03-branchpoint:1.1.1.1
	cygnus_cvs_20020108_pre:1.1.1.1
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	dejagnu-2000-02-04:1.1.1.1
	dejagnu-2000-01-31:1.1.1.1
	dejagnu-2000-01-24:1.1.1.1
	dejagnu-2000-01-17:1.1.1.1
	dejagnu-2000-01-10:1.1.1.1
	dejagnu-2000-01-04:1.1.1.1
	dejagnu-1999-12-21:1.1.1.1
	dejagnu-1999-12-13:1.1.1.1
	dejagnu-1999-12-07:1.1.1.1
	dejagnu-1999-12-06:1.1.1.1
	dejagnu-1999-11-15:1.1.1.1
	dejagnu-1999-11-08:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.2
date	2005.06.28.05.02.31;	author bje;	state dead;
branches;
next	1.1;

1.1
date	99.11.09.01.28.43;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.11.09.01.28.43;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.2
log
@Remove this old version of Expect.
@
text
@#!../expect --
# allow another user to share a shell (or other program) with you
# See kibitz(1) man page for complete info.
# Author: Don Libes, NIST
# Date written: December 5, 1991
# Date last editted: October 19, 1994
# Version: 2.11
exp_version -exit 5.0

# if environment variable "EXPECT_PROMPT" exists, it is taken as a regular
# expression which matches the end of your login prompt (but does not other-
# wise occur while logging in).

set prompt "(%|#|\\$) $"	;# default prompt
set noproc 0
set tty ""			;# default if no -tty flag
set allow_escape 1		;# allow escapes if true
set escape_char \035		;# control-right-bracket
set escape_printable "^\]"
set verbose 1			;# if true, describe what kibitz is doing

set kibitz "kibitz"		;# where kibitz lives if some unusual place.
				;# this must end in "kibitz", but can have
				;# things in front (like directory names).
#set proxy "kibitz"		;# uncomment and set if you want kibitz to use
				;# some other account on remote systems

# The following code attempts to intuit whether cat buffers by default.
# The -u flag is required on HPUX (8 and 9) and IBM AIX (3.2) systems.
if [file exists $exp_exec_library/cat-buffers] {
	set catflags "-u"
} else {
	set catflags ""
}
# If this fails, you can also force it by commenting in one of the following.
# Or, you can use the -catu flag to the script.
#set catflags ""
#set catflags "-u"

# Some flags must be passed onto the remote kibitz process.  They are stored
# in "kibitz_flags".  Currently, they include -tty and -silent.
set kibitz_flags ""

while {[llength $argv]>0} {
	set flag [lindex $argv 0]
	switch -- $flag \
	"-noproc" {
		set noproc 1
		set argv [lrange $argv 1 end]
	} "-catu" {
		set catflags "-u"
		set argv [lrange $argv 1 end]
	} "-tty" {
		set tty [lindex $argv 1]
		set argv [lrange $argv 2 end]
		set kibitz_flags "$kibitz_flags -tty $tty"
	} "-noescape" {
		set allow_escape 0
		set argv [lrange $argv 1 end]
	} "-escape" {
		set escape_char [lindex $argv 1]
		set escape_printable $escape_char
		set argv [lrange $argv 2 end]
	} "-silent" {
		set verbose 0
		set argv [lrange $argv 1 end]
		set kibitz_flags "$kibitz_flags -silent"
	} "-proxy" {
		set proxy [lindex $argv 1]
		set argv [lrange $argv 2 end]
	} default {
		break
	}
}

if {([llength $argv]<1) && ($noproc==0)} {
	send_user "usage: kibitz \[args] user \[program ...]\n"
	send_user "   or: kibitz \[args] user@@host \[program ...]\n"
	exit
}

log_user 0
set timeout -1

set user [lindex $argv 0]
if [string match -r $user] {
	send_user "KRUN"	;# this tells user_number 1 that we're running
				;# and to prepare for possible error messages
	set user_number 3
	# need to check that it exists first!
	set user [lindex $argv 1]
} else {
	set user_number [expr 1+(0==[string first - $user])]
}

# at this point, user_number and user are correctly determined
# User who originated kibitz session has user_number == 1 on local machine.
# User who is responding to kibitz has user_number == 2.
# User who originated kibitz session has user_number == 3 on remote machine.

# user 1 invokes kibitz as "kibitz user[@@host]"
# user 2 invokes kibitz as "kibitz -####" (some pid).
# user 3 invokes kibitz as "kibitz -r user".

# uncomment for debugging: leaves each user's session in a file: 1, 2 or 3
#exec rm -f $user_number
#exp_internal -f $user_number 0

set user2_islocal 1	;# assume local at first

# later move inside following if $user_number == 1
# return true if x is a prefix of xjunk, given that prefixes are only
# valid at . delimiters
# if !do_if0, skip the whole thing - this is here just to make caller simpler
proc is_prefix {do_if0 x xjunk} {
	if 0!=$do_if0 {return 0}
	set split [split $xjunk .]
	for {set i [expr [llength $split]-1]} {$i>=0} {incr i -1} {
		if [string match $x [join [lrange $split 0 $i] .]] {return 1}
	}
	return 0
}

# get domainname.  Unfortunately, on some systems, domainname(1)
# returns NIS domainname which is not the internet domainname.
proc domainname {} {
	# open pops stack upon failure
	set rc [catch {open /etc/resolv.conf r} file]
	if {$rc==0} {
		while {-1!=[gets $file buf]} {
			if 1==[scan $buf "domain %s" name] {
				close $file
				return $name
			}
		}
		close $file
	}

	# fall back to using domainname
	if {0==[catch {exec domainname} name]} {return $name}

	error "could not figure out domainname"
}

if $user_number==1 {
	if $noproc==0 {
		if [llength $argv]>1 {
			set pid [eval spawn [lrange $argv 1 end]]
		} else {
			# if running as CGI, shell may not be set!
			set shell /bin/sh
			catch {set shell $env(SHELL)}
			set pid [spawn $shell]
		}
		set shell $spawn_id
	}

	# is user2 remote?
	regexp (\[^@@\]*)@@*(.*) $user ignore tmp host
	set user $tmp
	if ![string match $host ""] {
		set h_rc [catch {exec hostname}	hostname]
		set d_rc [catch domainname 	domainname]

		if {![is_prefix $h_rc $host $hostname]
		 && ![is_prefix $d_rc $host $hostname.$domainname]} {
			set user2_islocal 0
		}
	}

	if !$user2_islocal {
		if $verbose {send_user "connecting to $host\n"}

		if ![info exists proxy] {
			proc whoami {} {
				global env
				if [info exists env(USER)] {return $env(USER)}
				if [info exists env(LOGNAME)] {return $env(LOGNAME)}
				if ![catch {exec whoami} user] {return $user}
				if ![catch {exec logname} user] {return $user}
				# error "can't figure out who you are!"
			}
			set proxy [whoami]
		}
		spawn rlogin $host -l $proxy -8
		set userin $spawn_id
		set userout $spawn_id

		catch {set prompt $env(EXPECT_PROMPT)}

		set timeout 120
		expect {
			assword: {
				stty -echo
				send_user "password (for $proxy) on $host: "
				set old_timeout $timeout; set timeout -1
				expect_user -re "(.*)\n"
				send_user "\n"
				set timeout $old_timeout
				send "$expect_out(1,string)\r"
				# bother resetting echo?
				exp_continue
			} incorrect* {
				send_user "invalid password or account\n"
				exit
			} "TERM = *) " {
				send "\r"
				exp_continue
			} timeout {
				send_user "connection to $host timed out\n"
				exit
			} eof {
				send_user "connection to host failed: $expect_out(buffer)"
				exit
			} -re $prompt
		}
		if $verbose {send_user "starting kibitz on $host\n"}
		# the kill protects user1 from receiving user3's
		# prompt if user2 exits via expect's exit.
		send "$kibitz $kibitz_flags -r $user;kill -9 $$\r"

		expect {
			-re "kibitz $kibitz_flags -r $user.*KRUN" {}
			-re "kibitz $kibitz_flags -r $user.*(kibitz\[^\r\]*)\r" {
				send_user "unable to start kibitz on $host: \"$expect_out(1,string)\"\n"
				send_user "try rlogin by hand followed by \"kibitz $user\"\n"
				exit
			}
			timeout {
				send_user "unable to start kibitz on $host: "
				set expect_out(buffer) "timed out"
				set timeout 0; expect -re .+
				send_user $expect_out(buffer)
				exit
			}
		}
		expect {
			-re ".*\n" {
				# pass back diagnostics
				# should really strip out extra cr
				send_user $expect_out(buffer)
				exp_continue
			}
			KABORT exit
			default exit
			KDATA
		}
	}
}

if $user_number==2 {
	set pid [string trimleft $user -]
}

set local_io [expr ($user_number==3)||$user2_islocal]
if $local_io||($user_number==2) {
	if 0==[info exists pid] {set pid [pid]}

	set userinfile /tmp/exp0.$pid
	set useroutfile /tmp/exp1.$pid
}

proc prompt1 {} {
	return "kibitz[info level].[history nextid]> "
}

set esc_match {}
if {$allow_escape} {
   set esc_match {
      $escape_char {
	send_user "\nto exit kibitz, enter: exit\n"
	send_user "to suspend kibitz, press appropriate job control sequence\n"
	send_user "to return to kibitzing, enter: return\n"
	interpreter
	send_user "returning to kibitz\n"
      }
   }
}

proc prompt1 {} {
	return "kibitz[info level].[history nextid]> "
}

set timeout -1

# kibitzer executes following code
if $user_number==2 {
	# for readability, swap variables
	set tmp $userinfile
	set userinfile $useroutfile
	set useroutfile $tmp

	if ![file readable $userinfile] {
		send_user "Eh?  No one is asking you to kibitz.\n"
		exit -1
	}
 	spawn -open [open "|cat $catflags < $userinfile" "r"]
	set userin $spawn_id

	spawn -open [open $useroutfile w]
	set userout $spawn_id
	# open will hang until other user's cat starts

	stty -echo raw
	if $allow_escape {send_user "Escape sequence is $escape_printable\r\n"}

	# While user is reading message, try to delete other fifo
	catch {exec rm -f $userinfile}

	eval interact $esc_match \
		-output $userout \
		-input $userin

	exit
}

# only user_numbers 1 and 3 execute remaining code

proc abort {} {
	global user_number

	# KABORT tells user_number 1 that user_number 3 has run into problems
	# and is exiting, and diagnostics have been returned already
	if $user_number==3 {send_user KABORT}
	exit
}

if $local_io {
    proc mkfifo {f} {
	if 0==[catch {exec mkfifo $f}] return		;# POSIX
	if 0==[catch {exec mknod $f p}] return
	# some systems put mknod in wierd places
	if 0==[catch {exec /usr/etc/mknod $f p}] return	;# Sun
	if 0==[catch {exec /etc/mknod $f p}] return	;# AIX, Cray
	puts "Couldn't figure out how to make a fifo - where is mknod?"
	abort
    }

    proc rmfifos {} {
	global userinfile useroutfile
	catch {exec rm -f $userinfile $useroutfile}
    }

    trap {rmfifos; exit} {SIGINT SIGQUIT SIGTERM}

    # create 2 fifos to communicate with other user
    mkfifo $userinfile
    mkfifo $useroutfile
    # make sure other user can access despite umask
    exec chmod 666 $userinfile $useroutfile

    if $verbose {send_user "asking $user to type:  kibitz -$pid\n"}

    # can't use exec since write insists on being run from a tty!
    set rc [catch {
		   system echo "Can we talk?  Run: \"kibitz -$pid\"" | \
			/bin/write $user $tty
		}
	]
    if $rc {rmfifos;abort}

    spawn -open [open $useroutfile w]
    set userout $spawn_id
    # open will hang until other user's cat starts

    spawn -open [open "|cat $catflags < $userinfile" "r"]
    set userin $spawn_id
    catch {exec rm $userinfile}
}

stty -echo raw

if $user_number==3 {
	send_user "KDATA"	;# this tells user_number 1 to send data

	interact {
		-output $userout
		-input $userin eof {
			wait -i $userin
			return -tcl
		} -output $user_spawn_id 
	}
} else {
	if $allow_escape {send_user "Escape sequence is $escape_printable\r\n"}

	if $noproc {
		interact {
			-output $userout
			-input $userin eof {wait -i $userin; return}
			-output $user_spawn_id
		}
	} else {
		eval interact $esc_match {
			-output $shell \
			-input $userin eof {
				wait -i $userin
				close -i $shell
				return
			} -output $shell \
			-input $shell -output "$user_spawn_id $userout"
		}
		wait -i $shell
	}
}

if $local_io rmfifos
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@import dejagnu-1999-11-08 snapshot
@
text
@@
