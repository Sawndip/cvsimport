head	1.19;
access;
symbols
	newlib-2_2_0:1.18.0.2
	newlib-2_1_0:1.17
	newlib-2_0_0:1.17
	newlib-1_20_0:1.17
	newlib-1_19_0:1.17
	newlib-1_18_0:1.16
	newlib-1_17_0-arc:1.16.0.4
	binutils-arc-20080908-branch:1.16.0.2
	binutils-arc-20080908-branchpoint:1.16
	newlib-1_17_0:1.16
	newlib-1_16_0:1.16
	newlib-1_15_0:1.11
	newlib-csl-coldfire-4_1-32:1.9.2.3
	newlib-csl-sourcerygxx-4_1-32:1.9.2.3
	newlib-csl-innovasic-fido-3_4_4-33:1.9.2.3
	newlib-csl-coldfire-4_1-30:1.9.2.3
	newlib-csl-sourcerygxx-4_1-30:1.9.2.3
	newlib-csl-coldfire-4_1-28:1.9.2.3
	newlib-csl-sourcerygxx-4_1-28:1.9.2.3
	newlib-csl-arm-2006q3-27:1.9.2.3
	newlib-csl-sourcerygxx-4_1-27:1.9.2.3
	newlib-csl-arm-2006q3-26:1.9.2.3
	newlib-csl-sourcerygxx-4_1-26:1.9.2.3
	newlib-csl-sourcerygxx-4_1-24:1.9.2.3
	newlib-csl-sourcerygxx-4_1-23:1.9.2.3
	newlib-csl-sourcerygxx-4_1-21:1.9.2.3
	newlib-csl-arm-2006q3-21:1.9.2.3
	newlib-csl-arm-2006q3-19:1.9.2.3
	newlib-csl-sourcerygxx-4_1-19:1.9.2.3
	newlib-csl-sourcerygxx-4_1-18:1.9.2.3
	newlib-csl-sourcerygxx-3_4_4-25:1.11
	newlib-csl-sourcerygxx-4_1-17:1.9.2.1
	newlib-csl-sourcerygxx-4_1-14:1.9.2.1
	newlib-csl-sourcerygxx-4_1-13:1.9.2.1
	newlib-csl-sourcerygxx-4_1-12:1.9.2.1
	newlib-csl-sourcerygxx-4_1-9:1.9.2.1
	newlib-csl-sourcerygxx-4_1-8:1.9.2.1
	newlib-csl-sourcerygxx-4_1-7:1.9
	newlib-csl-arm-2006q1-6:1.9
	newlib-csl-sourcerygxx-4_1-6:1.9
	newlib-csl-sourcerygxx-4_1-5:1.9
	newlib-csl-sourcerygxx-4_1-4:1.9
	newlib-autotools-branch:1.9.0.4
	newlib-csl-20060320-branch:1.9.0.2
	newlib-csl-20060320-branchpoint:1.9
	newlib-1_14_0:1.8
	newlib-csl-arm-2005-q1b:1.3
	newlib-csl-arm-2005-q1a:1.2
	newlib-1_13_0:1.1
	csl-arm-2004-q3:1.1;
locks; strict;
comment	@ * @;


1.19
date	2015.02.17.09.30.52;	author corinna;	state Exp;
branches;
next	1.18;

1.18
date	2014.02.11.19.55.22;	author jjohnstn;	state Exp;
branches;
next	1.17;

1.17
date	2010.08.27.11.55.36;	author corinna;	state Exp;
branches;
next	1.16;

1.16
date	2007.08.10.19.36.46;	author jjohnstn;	state Exp;
branches;
next	1.15;

1.15
date	2007.07.06.17.00.12;	author jjohnstn;	state Exp;
branches;
next	1.14;

1.14
date	2007.01.03.16.55.25;	author jjohnstn;	state Exp;
branches;
next	1.13;

1.13
date	2006.12.25.23.05.24;	author kazu;	state Exp;
branches;
next	1.12;

1.12
date	2006.12.25.23.03.21;	author kazu;	state Exp;
branches;
next	1.11;

1.11
date	2006.06.13.20.51.08;	author jjohnstn;	state Exp;
branches;
next	1.10;

1.10
date	2006.06.05.19.46.18;	author jjohnstn;	state Exp;
branches;
next	1.9;

1.9
date	2006.02.07.18.46.23;	author jjohnstn;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2005.11.30.23.37.14;	author jjohnstn;	state Exp;
branches;
next	1.7;

1.7
date	2005.08.16.18.05.35;	author jjohnstn;	state Exp;
branches;
next	1.6;

1.6
date	2005.08.02.19.17.21;	author jjohnstn;	state Exp;
branches;
next	1.5;

1.5
date	2005.07.18.16.18.17;	author jjohnstn;	state Exp;
branches;
next	1.4;

1.4
date	2005.05.05.23.15.53;	author jjohnstn;	state Exp;
branches;
next	1.3;

1.3
date	2005.04.28.18.40.39;	author jjohnstn;	state Exp;
branches;
next	1.2;

1.2
date	2005.02.08.19.38.47;	author jjohnstn;	state Exp;
branches;
next	1.1;

1.1
date	2004.06.09.19.06.50;	author jjohnstn;	state Exp;
branches;
next	;

1.9.2.1
date	2006.06.09.15.52.15;	author sandra;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2006.08.30.22.24.18;	author pbrook;	state Exp;
branches;
next	1.9.2.3;

1.9.2.3
date	2006.09.01.15.28.54;	author pbrook;	state Exp;
branches;
next	;


desc
@@


1.19
log
@	* arm/crt0.S: Initialise __heap_limit when ARM_RDI_MONITOR is defined.
	* arm/syscalls.c: define __heap_limit global symbol.
	* arm/syscalls.c (_sbrk): Honour __heap_limit.
@
text
@/* Support files for GNU libc.  Files in the system namespace go here.
   Files in the C namespace (ie those that do not start with an
   underscore) go in .c.  */

#include <_ansi.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/fcntl.h>
#include <stdio.h>
#include <string.h>
#include <time.h>
#include <sys/time.h>
#include <sys/times.h>
#include <errno.h>
#include <reent.h>
#include <unistd.h>
#include <sys/wait.h>
#include "swi.h"

/* Forward prototypes.  */
int     _system     _PARAMS ((const char *));
int     _rename     _PARAMS ((const char *, const char *));
int     _isatty		_PARAMS ((int));
clock_t _times		_PARAMS ((struct tms *));
int     _gettimeofday	_PARAMS ((struct timeval *, void *));
int     _unlink		_PARAMS ((const char *));
int     _link 		_PARAMS ((void));
int     _stat 		_PARAMS ((const char *, struct stat *));
int     _fstat 		_PARAMS ((int, struct stat *));
int	_swistat	_PARAMS ((int fd, struct stat * st));
caddr_t _sbrk		_PARAMS ((int));
int     _getpid		_PARAMS ((int));
int     _close		_PARAMS ((int));
clock_t _clock		_PARAMS ((void));
int     _swiclose	_PARAMS ((int));
int     _open		_PARAMS ((const char *, int, ...));
int     _swiopen	_PARAMS ((const char *, int));
int     _write 		_PARAMS ((int, char *, int));
int     _swiwrite	_PARAMS ((int, char *, int));
int     _lseek		_PARAMS ((int, int, int));
int     _swilseek	_PARAMS ((int, int, int));
int     _read		_PARAMS ((int, char *, int));
int     _swiread	_PARAMS ((int, char *, int));
void    initialise_monitor_handles _PARAMS ((void));

static int	checkerror	_PARAMS ((int));
static int	error		_PARAMS ((int));
static int	get_errno	_PARAMS ((void));

/* Struct used to keep track of the file position, just so we
   can implement fseek(fh,x,SEEK_CUR).  */
struct fdent
{
  int handle;
  int pos;
};

#define MAX_OPEN_FILES 20

/* User file descriptors (fd) are integer indexes into 
   the openfiles[] array. Error checking is done by using
   findslot(). 

   This openfiles array is manipulated directly by only 
   these 5 functions:

	findslot() - Translate entry.
	newslot() - Find empty entry.
	initilise_monitor_handles() - Initialize entries.
	_swiopen() - Initialize entry.
	_close() - Handle stdout == stderr case.

   Every other function must use findslot().  */

static struct fdent openfiles [MAX_OPEN_FILES];

static struct fdent* 	findslot	_PARAMS ((int));
static int		newslot		_PARAMS ((void));

/* Register name faking - works in collusion with the linker.  */
register char * stack_ptr asm ("sp");


/* following is copied from libc/stdio/local.h to check std streams */
extern void   _EXFUN(__sinit,(struct _reent *));
#define CHECK_INIT(ptr) \
  do						\
    {						\
      if ((ptr) && !(ptr)->__sdidinit)		\
	__sinit (ptr);				\
    }						\
  while (0)

static int monitor_stdin;
static int monitor_stdout;
static int monitor_stderr;

/* Return a pointer to the structure associated with
   the user file descriptor fd. */ 
static struct fdent*
findslot (int fd)
{
  CHECK_INIT(_REENT);

  /* User file descriptor is out of range. */
  if ((unsigned int)fd >= MAX_OPEN_FILES)
    return NULL;

  /* User file descriptor is open? */
  if (openfiles[fd].handle == -1)
    return NULL;

  /* Valid. */
  return &openfiles[fd];
}

/* Return the next lowest numbered free file 
   structure, or -1 if we can't find one. */ 
static int
newslot (void)
{
  int i;

  for (i = 0; i < MAX_OPEN_FILES; i++)
    if (openfiles[i].handle == -1)
      break;

  if (i == MAX_OPEN_FILES)
    return -1;

  return i;
}

void
initialise_monitor_handles (void)
{
  int i;
  
  /* Open the standard file descriptors by opening the special
   * teletype device, ":tt", read-only to obtain a descritpor for
   * standard input and write-only to obtain a descriptor for standard
   * output. Finally, open ":tt" in append mode to obtain a descriptor
   * for standard error. Since this is a write mode, most kernels will
   * probably return the same value as for standard output, but the
   * kernel can differentiate the two using the mode flag and return a
   * different descriptor for standard error.
   */

#ifdef ARM_RDI_MONITOR
  int volatile block[3];
  
  block[0] = (int) ":tt";
  block[2] = 3;     /* length of filename */
  block[1] = 0;     /* mode "r" */
  monitor_stdin = do_AngelSWI (AngelSWI_Reason_Open, (void *) block);

  block[0] = (int) ":tt";
  block[2] = 3;     /* length of filename */
  block[1] = 4;     /* mode "w" */
  monitor_stdout = do_AngelSWI (AngelSWI_Reason_Open, (void *) block);

  block[0] = (int) ":tt";
  block[2] = 3;     /* length of filename */
  block[1] = 8;     /* mode "a" */
  monitor_stderr = do_AngelSWI (AngelSWI_Reason_Open, (void *) block);
#else
  int fh;
  const char * name;

  name = ":tt";
  asm ("mov r0,%2; mov r1, #0; swi %a1; mov %0, r0"
       : "=r"(fh)
       : "i" (SWI_Open),"r"(name)
       : "r0","r1");
  monitor_stdin = fh;

  name = ":tt";
  asm ("mov r0,%2; mov r1, #4; swi %a1; mov %0, r0"
       : "=r"(fh)
       : "i" (SWI_Open),"r"(name)
       : "r0","r1");
  monitor_stdout = fh;

  name = ":tt";
  asm ("mov r0,%2; mov r1, #8; swi %a1; mov %0, r0"
       : "=r"(fh)
       : "i" (SWI_Open),"r"(name)
       : "r0","r1");
  monitor_stderr = fh;
#endif

  /* If we failed to open stderr, redirect to stdout. */
  if (monitor_stderr == -1)
    monitor_stderr = monitor_stdout;

  for (i = 0; i < MAX_OPEN_FILES; i ++)
    openfiles[i].handle = -1;

  openfiles[0].handle = monitor_stdin;
  openfiles[0].pos = 0;
  openfiles[1].handle = monitor_stdout;
  openfiles[1].pos = 0;
  openfiles[2].handle = monitor_stderr;
  openfiles[2].pos = 0;
}

static int
get_errno (void)
{
#ifdef ARM_RDI_MONITOR
  return do_AngelSWI (AngelSWI_Reason_Errno, NULL);
#else
  register r0 asm("r0");
  asm ("swi %a1" : "=r"(r0) : "i" (SWI_GetErrno));
  return r0;
#endif
}

/* Set errno and return result. */
static int
error (int result)
{
  errno = get_errno ();
  return result;
}

/* Check the return and set errno appropriately. */
static int
checkerror (int result)
{
  if (result == -1)
    return error (-1);
  return result;
}

/* fh, is a valid internal file handle.
   ptr, is a null terminated string.
   len, is the length in bytes to read. 
   Returns the number of bytes *not* written. */
int
_swiread (int fh,
	  char * ptr,
	  int len)
{
#ifdef ARM_RDI_MONITOR
  int block[3];
  
  block[0] = fh;
  block[1] = (int) ptr;
  block[2] = len;
  
  return checkerror (do_AngelSWI (AngelSWI_Reason_Read, block));
#else
  register r0 asm("r0");
  register r1 asm("r1");
  register r2 asm("r2");
  r0 = fh;
  r1 = (int)ptr;
  r2 = len;
  asm ("swi %a4"
       : "=r" (r0)
       : "0"(r0), "r"(r1), "r"(r2), "i"(SWI_Read));
  return checkerror (r0);
#endif
}

/* fd, is a valid user file handle.
   Translates the return of _swiread into
   bytes read. */
int __attribute__((weak))
_read (int fd,
       char * ptr,
       int len)
{
  int res;
  struct fdent *pfd;

  pfd = findslot (fd);
  if (pfd == NULL)
    {
      errno = EBADF;
      return -1;
    }

  res = _swiread (pfd->handle, ptr, len);

  if (res == -1)
    return res;

  pfd->pos += len - res;

  /* res == len is not an error, 
     at least if we want feof() to work.  */
  return len - res;
}

/* fd, is a user file descriptor. */
int
_swilseek (int fd,
	int ptr,
	int dir)
{
  int res;
  struct fdent *pfd;

  /* Valid file descriptor? */
  pfd = findslot (fd);
  if (pfd == NULL)
    {
      errno = EBADF;
      return -1;
    }

  /* Valid whence? */
  if ((dir != SEEK_CUR)
      && (dir != SEEK_SET)
      && (dir != SEEK_END))
    {
      errno = EINVAL;
      return -1;
    }

  /* Convert SEEK_CUR to SEEK_SET */
  if (dir == SEEK_CUR)
    {
      ptr = pfd->pos + ptr;
      /* The resulting file offset would be negative. */
      if (ptr < 0)
        {
          errno = EINVAL;
          if ((pfd->pos > 0) && (ptr > 0))
            errno = EOVERFLOW;
          return -1;
        }
      dir = SEEK_SET;
    }
 
#ifdef ARM_RDI_MONITOR
  int block[2];
  if (dir == SEEK_END)
    {
      block[0] = pfd->handle;
      res = checkerror (do_AngelSWI (AngelSWI_Reason_FLen, block));
      if (res == -1)
        return -1;
      ptr += res;
    }
  
  /* This code only does absolute seeks.  */
  block[0] = pfd->handle;
  block[1] = ptr;
  res = checkerror (do_AngelSWI (AngelSWI_Reason_Seek, block));
#else
  if (dir == SEEK_END)
    {
      asm ("mov r0, %2; swi %a1; mov %0, r0"
	   : "=r" (res)
	   : "i" (SWI_Flen), "r" (pfd->handle)
	   : "r0");
      checkerror (res);
      if (res == -1)
        return -1;
      ptr += res;
    }

  /* This code only does absolute seeks.  */
  asm ("mov r0, %2; mov r1, %3; swi %a1; mov %0, r0"
       : "=r" (res)
       : "i" (SWI_Seek), "r" (pfd->handle), "r" (ptr)
       : "r0", "r1");
  checkerror (res);
#endif
  /* At this point ptr is the current file position. */
  if (res >= 0)
    {
      pfd->pos = ptr;
      return ptr;
    }
  else
    return -1;
}

_lseek (int fd,
	int ptr,
	int dir)
{
  return _swilseek (fd, ptr, dir);
}

/* fh, is a valid internal file handle.
   Returns the number of bytes *not* written. */
int
_swiwrite (
	   int    fh,
	   char * ptr,
	   int    len)
{
#ifdef ARM_RDI_MONITOR
  int block[3];
  
  block[0] = fh;
  block[1] = (int) ptr;
  block[2] = len;
  
  return checkerror (do_AngelSWI (AngelSWI_Reason_Write, block));
#else
  register r0 asm("r0");
  register r1 asm("r1");
  register r2 asm("r2");
  r0 = fh;
  r1 = (int)ptr;
  r2 = len;
  asm ("swi %a4"
       : "=r" (r0)
       : "0"(r0), "r"(r1), "r"(r2), "i"(SWI_Write));
  return checkerror (r0);
#endif
}

/* fd, is a user file descriptor. */
int __attribute__((weak))
_write (int    fd,
	char * ptr,
	int    len)
{
  int res;
  struct fdent *pfd;

  pfd = findslot (fd);
  if (pfd == NULL)
    {
      errno = EBADF;
      return -1;
    }

  res = _swiwrite (pfd->handle, ptr,len);

  /* Clearly an error. */
  if (res < 0)
    return -1;

  pfd->pos += len - res;

  /* We wrote 0 bytes? 
     Retrieve errno just in case. */
  if ((len - res) == 0)
    return error (0);
  
  return (len - res);
}

int
_swiopen (const char * path, int flags)
{
  int aflags = 0, fh;
#ifdef ARM_RDI_MONITOR
  int block[3];
#endif
  
  int fd = newslot ();

  if (fd == -1)
    {
      errno = EMFILE;
      return -1;
    }
  
  /* It is an error to open a file that already exists. */
  if ((flags & O_CREAT) 
      && (flags & O_EXCL))
    {
      struct stat st;
      int res;
      res = _stat (path, &st);
      if (res != -1)
        {
	  errno = EEXIST;
	  return -1;
        }
    }

  /* The flags are Unix-style, so we need to convert them. */ 
#ifdef O_BINARY
  if (flags & O_BINARY)
    aflags |= 1;
#endif
  
  /* In O_RDONLY we expect aflags == 0. */

  if (flags & O_RDWR) 
    aflags |= 2;

  if ((flags & O_CREAT)
      || (flags & O_TRUNC)
      || (flags & O_WRONLY))
    aflags |= 4;

  if (flags & O_APPEND)
    {
      /* Can't ask for w AND a; means just 'a'.  */
      aflags &= ~4;
      aflags |= 8;
    }
  
#ifdef ARM_RDI_MONITOR
  block[0] = (int) path;
  block[2] = strlen (path);
  block[1] = aflags;
  
  fh = do_AngelSWI (AngelSWI_Reason_Open, block);
  
#else
  asm ("mov r0,%2; mov r1, %3; swi %a1; mov %0, r0"
       : "=r"(fh)
       : "i" (SWI_Open),"r"(path),"r"(aflags)
       : "r0","r1");
#endif
  
  /* Return a user file descriptor or an error. */
  if (fh >= 0)
    {
      openfiles[fd].handle = fh;
      openfiles[fd].pos = 0;
      return fd;
    }
  else
    return error (fh);
}

int
_open (const char * path, int flags, ...)
{
  return _swiopen (path, flags);
}

/* fh, is a valid internal file handle. */
int
_swiclose (int fh)
{
#ifdef ARM_RDI_MONITOR
  return checkerror (do_AngelSWI (AngelSWI_Reason_Close, &fh));
#else
  register r0 asm("r0");
  r0 = fh;
  asm ("swi %a2" 
       : "=r"(r0) 
       : "0"(r0), "i" (SWI_Close));
  return checkerror (r0);
#endif
}

/* fd, is a user file descriptor. */
int
_close (int fd)
{
  int res;
  struct fdent *pfd;

  pfd = findslot (fd);
  if (pfd == NULL)
    {
      errno = EBADF;
      return -1;
    }

  /* Handle stderr == stdout. */
  if ((fd == 1 || fd == 2)
      && (openfiles[1].handle == openfiles[2].handle))
    {
      pfd->handle = -1;
      return 0;
    }

  /* Attempt to close the handle. */
  res = _swiclose (pfd->handle);

  /* Reclaim handle? */
  if (res == 0)
    pfd->handle = -1;

  return res;
}

int __attribute__((weak))
_getpid (int n __attribute__ ((unused)))
{
  return 1;
}

/* Heap limit returned from SYS_HEAPINFO Angel semihost call.  */
uint __heap_limit = 0xcafedead;

caddr_t __attribute__((weak))
_sbrk (int incr)
{
  extern char end asm ("end"); /* Defined by the linker.  */
  static char * heap_end;
  char * prev_heap_end;

  if (heap_end == NULL)
    heap_end = & end;
  
  prev_heap_end = heap_end;
  
  if ((heap_end + incr > stack_ptr)
      /* Honour heap limit if it's valid.  */
      || (__heap_limit != 0xcafedead && heap_end + incr > __heap_limit))
    {
      /* Some of the libstdc++-v3 tests rely upon detecting
	 out of memory errors, so do not abort here.  */
#if 0
      extern void abort (void);

      _write (1, "_sbrk: Heap and stack collision\n", 32);
      
      abort ();
#else
      errno = ENOMEM;
      return (caddr_t) -1;
#endif
    }
  
  heap_end += incr;

  return (caddr_t) prev_heap_end;
}

int 
_swistat (int fd, struct stat * st)
{
  struct fdent *pfd;
  int res;

  pfd = findslot (fd);
  if (pfd == NULL)
    {
      errno = EBADF;
      return -1;
    }

  /* Always assume a character device,
     with 1024 byte blocks. */
  st->st_mode |= S_IFCHR;
  st->st_blksize = 1024;
#ifdef ARM_RDI_MONITOR
  res = checkerror (do_AngelSWI (AngelSWI_Reason_FLen, &pfd->handle));
#else
  asm ("mov r0, %2; swi %a1; mov %0, r0"
       : "=r" (res)
       : "i" (SWI_Flen), "r" (pfd->handle)
       : "r0");
  checkerror (res);
#endif
  if (res == -1)
    return -1;
  /* Return the file size. */
  st->st_size = res;
  return 0;
}

int __attribute__((weak))
_fstat (int fd, struct stat * st)
{
  memset (st, 0, sizeof (* st));
  return _swistat (fd, st);
}

int __attribute__((weak))
_stat (const char *fname, struct stat *st)
{
  int fd, res;
  memset (st, 0, sizeof (* st));
  /* The best we can do is try to open the file readonly.  
     If it exists, then we can guess a few things about it. */
  if ((fd = _open (fname, O_RDONLY)) == -1)
    return -1;
  st->st_mode |= S_IFREG | S_IREAD;
  res = _swistat (fd, st);
  /* Not interested in the error. */
  _close (fd); 
  return res;
}

int __attribute__((weak))
_link (void)
{
  errno = ENOSYS;
  return -1;
}

int
_unlink (const char *path)
{
  int res;
#ifdef ARM_RDI_MONITOR
  int block[2];
  block[0] = (int)path;
  block[1] = strlen(path);
  res = do_AngelSWI (AngelSWI_Reason_Remove, block);
#else
  register r0 asm("r0");
  r0 = (int)path;
  asm ("swi %a2" 
       : "=r"(r0)
       : "0"(r0), "i" (SWI_Remove));
  res = r0;
#endif
  if (res == -1) 
    return error (res);
  return 0;
}

int
_gettimeofday (struct timeval * tp, void * tzvp)
{
  struct timezone *tzp = tzvp;
  if (tp)
    {
    /* Ask the host for the seconds since the Unix epoch.  */
#ifdef ARM_RDI_MONITOR
      tp->tv_sec = do_AngelSWI (AngelSWI_Reason_Time,NULL);
#else
      {
        int value;
        asm ("swi %a1; mov %0, r0" : "=r" (value): "i" (SWI_Time) : "r0");
        tp->tv_sec = value;
      }
#endif
      tp->tv_usec = 0;
    }

  /* Return fixed data for the timezone.  */
  if (tzp)
    {
      tzp->tz_minuteswest = 0;
      tzp->tz_dsttime = 0;
    }

  return 0;
}

/* Return a clock that ticks at 100Hz.  */
clock_t 
_clock (void)
{
  clock_t timeval;

#ifdef ARM_RDI_MONITOR
  timeval = do_AngelSWI (AngelSWI_Reason_Clock,NULL);
#else
  asm ("swi %a1; mov %0, r0" : "=r" (timeval): "i" (SWI_Clock) : "r0");
#endif
  return timeval;
}

/* Return a clock that ticks at 100Hz.  */
clock_t
_times (struct tms * tp)
{
  clock_t timeval = _clock();

  if (tp)
    {
      tp->tms_utime  = timeval;	/* user time */
      tp->tms_stime  = 0;	/* system time */
      tp->tms_cutime = 0;	/* user time, children */
      tp->tms_cstime = 0;	/* system time, children */
    }
  
  return timeval;
};


int
_isatty (int fd)
{
  struct fdent *pfd;
  int tty;

  pfd = findslot (fd);
  if (pfd == NULL)
    {
      errno = EBADF;
      return 0;
    }

#ifdef ARM_RDI_MONITOR
  tty = do_AngelSWI (AngelSWI_Reason_IsTTY, &pfd->handle);
#else
  register r0 asm("r0");
  r0 = pfd->handle;
  asm ("swi %a2"
       : "=r" (r0)
       : "0"(r0), "i" (SWI_IsTTY));
  tty = r0;
#endif

  if (tty == 1)
    return 1;
  errno = get_errno ();
  return 0;
}

int
_system (const char *s)
{
#ifdef ARM_RDI_MONITOR
  int block[2];
  int e;

  /* Hmmm.  The ARM debug interface specification doesn't say whether
     SYS_SYSTEM does the right thing with a null argument, or assign any
     meaning to its return value.  Try to do something reasonable....  */
  if (!s)
    return 1;  /* maybe there is a shell available? we can hope. :-P */
  block[0] = (int)s;
  block[1] = strlen (s);
  e = checkerror (do_AngelSWI (AngelSWI_Reason_System, block));
  if ((e >= 0) && (e < 256))
    {
      /* We have to convert e, an exit status to the encoded status of
         the command.  To avoid hard coding the exit status, we simply
	 loop until we find the right position.  */
      int exit_code;

      for (exit_code = e; e && WEXITSTATUS (e) != exit_code; e <<= 1)
	continue;
    }
  return e;
#else
  register r0 asm("r0");
  r0 = (int)s;
  asm ("swi %a2" 
       : "=r" (r0)
       : "0"(r0), "i" (SWI_CLI));
  return checkerror (r0);
#endif
}

int
_rename (const char * oldpath, const char * newpath)
{
#ifdef ARM_RDI_MONITOR
  int block[4];
  block[0] = (int)oldpath;
  block[1] = strlen(oldpath);
  block[2] = (int)newpath;
  block[3] = strlen(newpath);
  return checkerror (do_AngelSWI (AngelSWI_Reason_Rename, block)) ? -1 : 0;
#else
  register r0 asm("r0");
  register r1 asm("r1");
  r0 = (int)oldpath;
  r1 = (int)newpath;
  asm ("swi %a3" 
       : "=r" (r0)
       : "0" (r0), "r" (r1), "i" (SWI_Rename));
  return checkerror (r0);
#endif
}
@


1.18
log
@
2014-02-11  Joey Ye  <joey.ye@@arm.com>

        * arm/syscalls.c (_sbrk): Define as weak symbols.
        (_read, _write): Ditto.
@
text
@d590 3
d605 3
a607 1
  if (heap_end + incr > stack_ptr)
@


1.17
log
@	* syscalls.c (_isatty): Fix return value.
@
text
@d267 1
a267 1
/* fd, is a valid user file handle. 
d270 1
a270 1
int
d421 1
a421 1
int
d590 1
a590 1
caddr_t
@


1.16
log
@
2007-08-10  Carlos O'Donell  <carlos@@codesourcery.com>

        2007-07-12  Daniel Jacobowitz  <dan@@codesourcery.com>

        * arm/syscalls.c (_stat): Use _close

        * arm/syscalls.c (struct poslog): Rename to...
        (struct fdent): ... this.
        (FILE_HANDLE_OFFSET): Remove.
        (findslot): Return a struct fdent* if fd is valid, otherwise return NULL.
        (newslot): New function.
        (remap_handle): Remove.
        (initialise_monitor_handles): Use stdout as fallback for stderr.
        (wrap): Rename to...
        (checkerror): ...  this.
        (_swiread): Use checkerror() for the return of SWI calls.  Correct the use of r0.
        (_read): Use findslot().  Return EBADF on bad handle.
        (_swilseek): Call findslot().  Check for valid whence.  Check for negative offset when using
        SEEK_CUR, and check for overflow.  Use checkerror().  Check *_Flen calls for errors.
        (_swiwrite): Correct the use of r0.
        (_write): Call findslot().
        (_swiopen): Call findslot().  Check for valid flags.  Use checkerror().  Call newslot().
        Handle O_TRUNC, and O_WRONLY.  Return index into openfiles[] for fd.
        (_swiclose): Correct the use of r0.
        (_close): Handle stderr == stdout case.  Only reclaim handle if _swiclose succeeded.
        (_getpid): Use __attribute__((unused)).
        (_sbrk): Fix formatting.
        (_swistat): New function.
        (_stat): Call _swistat().
        (_fstat): Call _swistat().
        (_unlink): Correct the use of r0.
        (isatty): Call finslot().  Correct the use of r0.
        (_system): Call checkerror().  Correct the use of r0.
        (_rename): Correct the use of r0.
@
text
@d773 1
d779 1
a779 1
      return -1;
d783 1
a783 1
  return checkerror (do_AngelSWI (AngelSWI_Reason_IsTTY, &pfd->handle));
d790 1
a790 1
  return checkerror (r0);
d792 5
@


1.15
log
@
2007-07-06  Jeff Johnston  <jjohnstn@@redhat.com>

        * arm/syscalls.c (gettimeofday): Change to POSIX signature
        where second argument is passed as void *.
        * bfin/syscalls.c (gettimeofday): Ditto.
        * cris/gensyscalls (gettimeofday): Ditto.
        * cris/linunistd.h (gettimeofday): Ditto.
        * crx/time.c (gettimeofday): Ditto.
        * frv/sim-time.c (gettimeofday): Ditto.
        * i386/cygmon-salib.c (gettimeofday): Ditto.
        * libnosys/gettod.c (gettimeofday): Ditto.
        * m68k/io-gettimeofday.c (gettimeofday): Ditto.
        * sparc/cygmon-salib.c (gettimeofday): Ditto.
        * spu/gettimeofday.c (gettimeofday): Ditto.
@
text
@d30 1
d46 1
a46 1
static int	wrap		_PARAMS ((int));
d49 30
a78 2
static int	remap_handle	_PARAMS ((int));
static int 	findslot	_PARAMS ((int));
a93 3
/* Adjust our internal handles to stay away from std* handles.  */
#define FILE_HANDLE_OFFSET (0x20)

d98 4
a101 3
/* Struct used to keep track of the file position, just so we
   can implement fseek(fh,x,SEEK_CUR).  */
typedef struct
d103 12
a114 2
  int handle;
  int pos;
a115 4
poslog;

#define MAX_OPEN_FILES 20
static poslog openfiles [MAX_OPEN_FILES];
d117 2
d120 1
a120 1
findslot (int fh)
d123 3
a125 2
  for (i = 0; i < MAX_OPEN_FILES; i ++)
    if (openfiles[i].handle == fh)
a126 2
  return i;
}
d128 2
a129 5
/* Function to convert std(in|out|err) handles to internal versions.  */
static int
remap_handle (int fh)
{
  CHECK_INIT(_REENT);
d131 1
a131 8
  if (fh == STDIN_FILENO)
    return monitor_stdin;
  if (fh == STDOUT_FILENO)
    return monitor_stdout;
  if (fh == STDERR_FILENO)
    return monitor_stderr;

  return fh - FILE_HANDLE_OFFSET;
d192 4
d219 1
d227 1
d229 1
a229 1
wrap (int result)
d236 4
a239 1
/* Returns # chars not! written.  */
d241 1
a241 1
_swiread (int file,
a244 1
  int fh = remap_handle (file);
d252 1
a252 1
  return do_AngelSWI (AngelSWI_Reason_Read, block);
d254 10
a263 4
  asm ("mov r0, %1; mov r1, %2;mov r2, %3; swi %a0"
       : /* No outputs */
       : "i"(SWI_Read), "r"(fh), "r"(ptr), "r"(len)
       : "r0","r1","r2");
d267 3
d271 1
a271 1
_read (int file,
d275 9
a283 2
  int slot = findslot (remap_handle (file));
  int x = _swiread (file, ptr, len);
d285 4
a288 2
  if (x < 0)
    return error (-1);
d290 1
a290 2
  if (slot != MAX_OPEN_FILES)
    openfiles [slot].pos += len - x;
d292 3
a294 2
  /* x == len is not an error, at least if we want feof() to work.  */
  return len - x;
d297 1
d299 3
a301 3
_swilseek (int file,
	   int ptr,
	   int dir)
d304 18
a321 5
  int fh = remap_handle (file);
  int slot = findslot (fh);
#ifdef ARM_RDI_MONITOR
  int block[2];
#endif
d323 1
d326 9
a334 3
      if (slot == MAX_OPEN_FILES)
	return -1;
      ptr = openfiles[slot].pos + ptr;
d337 1
a337 1
  
d339 1
d342 5
a346 2
      block[0] = fh;
      ptr += do_AngelSWI (AngelSWI_Reason_FLen, block);
d350 1
a350 1
  block[0] = remap_handle (file);
d352 1
a352 1
  res = do_AngelSWI (AngelSWI_Reason_Seek, block);
d358 1
a358 1
	   : "i" (SWI_Flen), "r" (fh)
d360 3
d369 1
a369 1
       : "i" (SWI_Seek), "r" (fh), "r" (ptr)
d371 1
d373 8
a380 6

  if (slot != MAX_OPEN_FILES && res == 0)
    openfiles[slot].pos = ptr;

  /* This is expected to return the position in the file.  */
  return res == 0 ? ptr : -1;
d383 1
a383 2
int
_lseek (int file,
d387 1
a387 1
  return wrap (_swilseek (file, ptr, dir));
d390 2
a391 1
/* Returns #chars not! written.  */
d394 1
a394 1
	   int    file,
a397 1
  int fh = remap_handle (file);
d405 1
a405 1
  return do_AngelSWI (AngelSWI_Reason_Write, block);
d407 10
a416 4
  asm ("mov r0, %1; mov r1, %2;mov r2, %3; swi %a0"
       : /* No outputs */
       : "i"(SWI_Write), "r"(fh), "r"(ptr), "r"(len)
       : "r0","r1","r2");
d420 1
d422 1
a422 1
_write (int    file,
d426 2
a427 2
  int slot = findslot (remap_handle (file));
  int x = _swiwrite (file, ptr,len);
d429 19
a447 2
  if (x == -1 || x == len)
    return error (-1);
d449 1
a449 4
  if (slot != MAX_OPEN_FILES)
    openfiles[slot].pos += len - x;
  
  return len - x;
d453 1
a453 2
_swiopen (const char * path,
	  int          flags)
d460 7
a466 1
  int i = findslot (-1);
d468 13
a480 2
  if (i == MAX_OPEN_FILES)
    return -1;
d482 1
a482 1
  /* The flags are Unix-style, so we need to convert them.  */
d487 2
d490 1
a490 1
  if (flags & O_RDWR)
d493 3
a495 4
  if (flags & O_CREAT)
    aflags |= 4;

  if (flags & O_TRUNC)
d500 2
a501 1
      aflags &= ~4;     /* Can't ask for w AND a; means just 'a'.  */
d519 1
d522 3
a524 2
      openfiles[i].handle = fh;
      openfiles[i].pos = 0;
d526 2
a527 2

  return fh >= 0 ? fh + FILE_HANDLE_OFFSET : error (fh);
d531 1
a531 3
_open (const char * path,
       int          flags,
       ...)
d533 1
a533 1
  return wrap (_swiopen (path, flags));
d536 1
d538 1
a538 1
_swiclose (int file)
a539 6
  int myhan = remap_handle (file);
  int slot = findslot (myhan);
  
  if (slot != MAX_OPEN_FILES)
    openfiles[slot].handle = -1;

d541 1
a541 1
  return do_AngelSWI (AngelSWI_Reason_Close, & myhan);
d543 6
a548 1
  asm ("mov r0, %1; swi %a0" :: "i" (SWI_Close),"r"(myhan):"r0");
d552 1
d554 1
a554 1
_close (int file)
d556 26
a581 1
  return wrap (_swiclose (file));
d585 1
a585 1
_getpid (int n)
a587 1
  n = n;
d593 1
a593 1
  extern char   end asm ("end");	/* Defined by the linker.  */
d595 1
a595 1
  char *        prev_heap_end;
d623 33
d657 1
a657 1
_fstat (int file, struct stat * st)
d660 1
a660 4
  st->st_mode = S_IFCHR;
  st->st_blksize = 1024;
  return 0;
  file = file;
d666 5
a670 5
  int file;

  /* The best we can do is try to open the file readonly.  If it exists,
     then we can guess a few things about it.  */
  if ((file = _open (fname, O_RDONLY)) < 0)
d672 5
a676 6

  memset (st, 0, sizeof (* st));
  st->st_mode = S_IFREG | S_IREAD;
  st->st_blksize = 1024;
  _swiclose (file); /* Not interested in the error.  */
  return 0;
d689 1
d694 1
a694 1
  return wrap (do_AngelSWI (AngelSWI_Reason_Remove, block)) ? -1 : 0;
d696 6
a701 2
  (void)path;
  asm ("swi %a0" :: "i" (SWI_Remove));
d703 3
d772 9
a780 1
  int fh = remap_handle (fd);
d782 1
a782 1
  return wrap (do_AngelSWI (AngelSWI_Reason_IsTTY, &fh));
d784 6
a789 4
  asm ("mov r0, %1; swi %a0"
       : /* No outputs */
       : "i" (SWI_IsTTY), "r"(fh)
       : "r0");
d807 1
a807 1
  e = wrap (do_AngelSWI (AngelSWI_Reason_System, block));
d820 6
a825 2
  (void)s;
  asm ("swi %a0" :: "i" (SWI_CLI));
d838 1
a838 1
  return wrap (do_AngelSWI (AngelSWI_Reason_Rename, block)) ? -1 : 0;
d840 8
a847 2
  (void)oldpath; (void)newpath;
  asm ("swi %a0" :: "i" (SWI_Rename));
@


1.14
log
@
2006-01-03  Kazu Hirata  <kazu@@codesourcery.com>

        * arm/Makefile (RDPMON_OBJS): Add _exit.o and _kill.o.
        (RDIMON_OBJS): Define in terms of RDPMON_OBJS.
        (rdimon-_exit.o, rdimon-_kill.o): New.
        * arm/_exit.c, arm/_kill.c: New.
        * arm/syscalls.c (_exit, _kill): Remove.
@
text
@d25 1
a25 1
int     _gettimeofday	_PARAMS ((struct timeval *, struct timezone *));
d528 1
a528 1
_gettimeofday (struct timeval * tp, struct timezone * tzp)
d530 1
a530 1

@


1.13
log
@	* arm/licfunc.c (do_AngelSWI): Remove.
	* arm/syscalls.c (do_AngelSWI): Remove.
	* arm/swi.h (do_AngelSWI): New.
@
text
@a15 1
#include <signal.h>
a31 2
int     _kill		_PARAMS ((int, int));
void    _exit		_PARAMS ((int));
a438 30
int
_kill (int pid, int sig)
{
  (void)pid; (void)sig;
#ifdef ARM_RDI_MONITOR
  /* Note: The pid argument is thrown away.  */
  switch (sig) {
	  case SIGABRT:
		  return do_AngelSWI (AngelSWI_Reason_ReportException,
				  (void *) ADP_Stopped_RunTimeError);
	  default:
		  return do_AngelSWI (AngelSWI_Reason_ReportException,
				  (void *) ADP_Stopped_ApplicationExit);
  }
#else
  asm ("swi %a0" :: "i" (SWI_Exit));
#endif
}

void
_exit (int status)
{
  /* There is only one SWI for both _exit and _kill. For _exit, call
     the SWI with the second argument set to -1, an invalid value for
     signum, so that the SWI handler can distinguish the two calls.
     Note: The RDI implementation of _kill throws away both its
     arguments.  */
  _kill(status, -1);
}

@


1.12
log
@	* arm/syscalls.c (_unlink, _system, _rename): Cast arguments
	to do_AngelSWI to int.
@
text
@a51 1
static int	do_AngelSWI	_PARAMS ((int, void *));
a96 20
#ifdef ARM_RDI_MONITOR

static inline int
do_AngelSWI (int reason, void * arg)
{
  int value;
  asm volatile ("mov r0, %1; mov r1, %2; " AngelSWIInsn " %a3; mov %0, r0"
       : "=r" (value) /* Outputs */
       : "r" (reason), "r" (arg), "i" (AngelSWI) /* Inputs */
       : "r0", "r1", "r2", "r3", "ip", "lr", "memory", "cc"
		/* Clobbers r0 and r1, and lr if in supervisor mode */);
                /* Accordingly to page 13-77 of ARM DUI 0040D other registers
                   can also be clobbered.  Some memory positions may also be
                   changed by a system call, so they should not be kept in
                   registers. Note: we are assuming the manual is right and
                   Angel is respecting the APCS.  */
  return value;
}
#endif /* ARM_RDI_MONITOR */

@


1.11
log
@
2006-06-13  Sandra Loosemore <sandra@@codesourcery.com>

        * arm/syscalls.c (_unlink, isatty, _system, _rename):
        Make them do something useful in the ARM_RDI_MONITOR case.
@
text
@d572 1
a572 1
  block[0] = path;
d668 1
a668 1
  block[0] = s;
d693 1
a693 1
  block[0] = oldpath;
d695 1
a695 1
  block[2] = newpath;
@


1.10
log
@
2006-06-05  Shaun Jackman  <sjackman@@gmail.com>

        * arm/syscalls.c (kill) [ARM_RDI_MONITOR]: Use the signal
        argument to choose an ADP exception reason.
        * arm/libcfunc.c (abort): Remove this function.
@
text
@d18 1
d571 4
a574 1
  return do_AngelSWI (AngelSWI_Reason_Remove, &path);
d645 1
d647 1
a647 1
  return do_AngelSWI (AngelSWI_Reason_IsTTY, &fd);
d649 4
a652 2
  (void)fd;
  asm ("swi %a0" :: "i" (SWI_IsTTY));
d660 22
a681 1
  return do_AngelSWI (AngelSWI_Reason_System, &s);
d692 6
a697 2
  const char *block[2] = {oldpath, newpath};
  return do_AngelSWI (AngelSWI_Reason_Rename, block);
@


1.9
log
@
2006-02-07  Paul Brook  <paul@@codesourcery.com>

        * arm/crt0.S: Add Thumb-2 startup code.
        * arm/redboot-crt0.S: Ditto.
        * arm/libcfunc.c (do_AngelSWI): Use AngelSWIInsn.
        * arm/swi.h (AngelSWIInsn, AngelSWIAsm): Define.
        * arm/trap.S: Disable for Thumb-2.
@
text
@d16 1
d467 9
a475 3
  /* Note: Both arguments are thrown away.  */
  return do_AngelSWI (AngelSWI_Reason_ReportException,
		      (void *) ADP_Stopped_ApplicationExit);
@


1.9.2.1
log
@Add additional ARM_RDI_MONITOR calls
@
text
@a16 1
#include <sys/wait.h>
d563 1
a563 4
  int block[2];
  block[0] = path;
  block[1] = strlen(path);
  return wrap (do_AngelSWI (AngelSWI_Reason_Remove, block)) ? -1 : 0;
a633 1
  int fh = remap_handle (fd);
d635 1
a635 1
  return wrap (do_AngelSWI (AngelSWI_Reason_IsTTY, &fh));
d637 2
a638 4
  asm ("mov r0, %1; swi %a0"
       : /* No outputs */
       : "i" (SWI_IsTTY), "r"(fh)
       : "r0");
d646 1
a646 22
  int block[2];
  int e;

  /* Hmmm.  The ARM debug interface specification doesn't say whether
     SYS_SYSTEM does the right thing with a null argument, or assign any
     meaning to its return value.  Try to do something reasonable....  */
  if (!s)
    return 1;  /* maybe there is a shell available? we can hope. :-P */
  block[0] = s;
  block[1] = strlen (s);
  e = wrap (do_AngelSWI (AngelSWI_Reason_System, block));
  if ((e >= 0) && (e < 256))
    {
      /* We have to convert e, an exit status to the encoded status of
         the command.  To avoid hard coding the exit status, we simply
	 loop until we find the right position.  */
      int exit_code;

      for (exit_code = e; e && WEXITSTATUS (e) != exit_code; e <<= 1)
	continue;
    }
  return e;
d657 2
a658 6
  int block[4];
  block[0] = oldpath;
  block[1] = strlen(oldpath);
  block[2] = newpath;
  block[3] = strlen(newpath);
  return wrap (do_AngelSWI (AngelSWI_Reason_Rename, block)) ? -1 : 0;
@


1.9.2.2
log
@2006-08-30  Paul Brook  <paul@@codesourcery.com>

	libgloss/
	* arm/Makefile.in: Change armv7m linker script generation.  Add
	armv7m.spec.  Build armv7m-crt0.o.
	* arm/arm.sc: New file.
	* arm/armv7m.specs: New file.
	* arm/crt0.S: Add armv7m code.
	* arm/elf-lm3s10x.ld: Remove.
	* arm/elf-lm3s301.ld: Remove.
	* arm/elf-lm3s31x.ld: Remove.
	* arm/swi.h (do_AngelSWI): Add definition.
	* arm/syscalls.c: Merge lazy semihosting initialization from newlib.

	newlib/
	* libc/sys/arm/crt0.S: Add armv7m rom startup code.
@
text
@d45 1
a46 1
static void    initialise_monitor_handles _PARAMS ((void));
d51 1
d57 11
a90 2

  initialise_monitor_handles ();
d121 2
a147 16
  static int initialized;
  int was_initialized;

  /* We need do this only once.  */
  if (initialized)
    return;

#ifndef __SINGLE_THREAD__
  __lock_acquire_recursive (__arm_monitor_handles_lock);
  if (initialized)
    {
      __lock_release_recursive (__arm_monitor_handles_lock);
      return;
    }
#endif

a199 5

  initialized = 1;
#ifndef __SINGLE_THREAD__
  __lock_release_recursive (__arm_monitor_handles_lock);
#endif
d565 1
a565 1
  block[0] = (int)path;
d661 1
a661 1
  block[0] = (int)s;
d686 1
a686 1
  block[0] = (int)oldpath;
d688 1
a688 1
  block[2] = (int)newpath;
@


1.9.2.3
log
@2006-09-01  Paul Brook  <paul@@codesourcery.com>

	libgloss/
	* arm/Makefile.in: Include _exit.c in BSPs.  Add rdimon-ram.ld.
	Build linker scripts instead of spec files for rdimon and rdpmon.
	Pass CRT0 ad BSP to arm.sc.
	* arm/_exit.c: New file.
	* arm/arm.sc: Add STARTUP, GROUP and SEARCH_DIR.  Remove defaults
	for ROM and RAM.
	* arm/crt0.S: Give Thumb-2 symbols function type.
	Skip generic Arm init code for Thumb-2.
	Add _nmi_isr and _fault_isr.
	* arm/libcfunc.c (do_AngelSWI): Remove.
	* arm/swi.h (do_AngelSWI): New function.
	* arm/syscalls.c (do_AngelSWI): Remove.
	(_exit): Remove.
	(isatty): New function.
@
text
@a22 1
int     isatty		_PARAMS ((int));
d33 1
d87 20
d484 11
a657 5
int isatty(int fd)
{
  return _isatty(fd);
}

@


1.8
log
@
2005-11-30  Shaun Jackman  <sjackman@@gmail.com>

        * arm/libcfunc.c (clock, sleep, usleep): New functions.
        * arm/syscalls.c (_clock): New function.
        (_times): Call _clock.
@
text
@d102 1
a102 1
  asm volatile ("mov r0, %1; mov r1, %2; swi %a3; mov %0, r0"
@


1.7
log
@
2005-08-16  Shaun Jackman  <sjackman@@gmail.com>

        * arm/syscalls.c (initialise_monitor_handles): Set
        monitor_stderr to the result of SWI_open(":tt", "a")
        instead of simply duplicating stdout.
@
text
@d34 1
d601 1
a601 1
_times (struct tms * tp)
d610 8
@


1.6
log
@
2005-08-02  Shaun Jackman  <sjackman@@gmail.com>

        * libgloss/arm/syscalls.c (_exit): Call _kill with the second
        argument set to -1, which is an invalid signal number.
        (_kill): Comment and coding style changes only.
        (_raise): Remove function.
@
text
@d136 10
d157 6
a162 1
  monitor_stdout = monitor_stderr = do_AngelSWI (AngelSWI_Reason_Open, (void *) block);
d179 8
a186 1
  monitor_stdout = monitor_stderr = fh;
d196 2
@


1.5
log
@
2005-07-18  Shaun Jackman  <sjackman@@gmail.com>

        * libgloss/arm/libcfunc.c (abort): Call _exit instead of the RDI swi.
        (alarm): Add the weak attribute.
        (pause): New function. Return ENOSYS.
        * libgloss/arm/syscalls.c (_getpid): Add the weak attribute.
        (_fstat): Ditto.
        (_stat): Ditto.
        (_link): Ditto. Return ENOSYS.
        (_unlink): Call the swi instead of returning -1.
        (_raise): Add the weak attribute. Return ENOSYS.
        (isatty): Rename to _isatty. Call the swi instead of returning 1.
        (_system): Call the swi instead of returning ENOSYS.
        (_rename): Ditto.
@
text
@a24 1
int     _raise 		_PARAMS ((int));
d436 2
a437 2
void
_exit (int n)
d439 1
a439 2
  /* FIXME: return code is thrown away.  */
  
d441 3
a443 2
  do_AngelSWI (AngelSWI_Reason_ReportException,
	      (void *) ADP_Stopped_ApplicationExit);
a446 1
  n = n;
d449 2
a450 2
int
_kill (int n, int m)
d452 6
a457 7
#ifdef ARM_RDI_MONITOR
  return do_AngelSWI (AngelSWI_Reason_ReportException,
		      (void *) ADP_Stopped_ApplicationExit);
#else
  asm ("swi %a0" :: "i" (SWI_Exit));
#endif
  n = n; m = m;
a544 8
int __attribute__((weak))
_raise (int sig)
{
  (void)sig;
  errno = ENOSYS;
  return -1;
}

@


1.4
log
@
2005-05-05  Tobias Anderberg  <tobias.anderberg@@axis.com>

        * arm/syscalls.c (get_errno): Fix output register constraint.
@
text
@d10 1
d22 1
a22 1
int     isatty		_PARAMS ((int));
d25 2
a26 2
void    _raise 		_PARAMS ((void));
int     _unlink		_PARAMS ((void));
a348 2
extern int strlen (const char *);

d463 1
a463 1
int
d503 1
a503 3
extern void memset (struct stat *, int, unsigned int);

int
d513 2
a514 1
int _stat (const char *fname, struct stat *st)
d530 1
a530 1
int
d533 1
d538 1
a538 1
_unlink (void)
d540 6
a545 1
  return -1;
d548 2
a549 2
void
_raise (void)
d551 3
a553 1
  return;
d610 1
a610 1
isatty (int fd)
d612 6
a617 2
  return 1;
  fd = fd;
d623 6
a628 4
  if (s == NULL)
    return 0;
  errno = ENOSYS;
  return -1;
d634 7
a640 2
  errno = ENOSYS;
  return -1;
@


1.3
log
@
2005-04-28  Shaun Jackman  <sjackman@@gmail.com>

        * libgloss/syscalls.c (get_errno): Add an output register constraint.
@
text
@d183 1
a183 1
  asm ("swi %a1" : "=3Dr"(r0) : "i" (SWI_GetErrno));
@


1.2
log
@
2005-02-08  Antony King  <antony.king@@st.com>

        * arm/syscalls.c: Change CHECK_INIT to pass reentrant struct
        instead of file pointer.
@
text
@d182 3
a184 1
  asm ("swi %a0" :: "i" (SWI_GetErrno));
@


1.1
log
@
2004-06-09  Toralf Lund  <toralf@@procaptura.com>

        * arm/crt0.S: Copied from newlib and it now also sets up stacks for
        FIQ and IRQ mode, plus calls hardware_init_hook() and
        software_init_hook() if present.
        * arm/libcfunc.c, arm/swi.h, arm/syscalls.c: Copied
        from newlib.
        * arm/Makefile.in: Build crt0.o, rdpmon-crt0.o, rdimon-crt0.o,
        librdpmon.a, librdimon.a - support file for "bare" setup, as well
        as "RDP" and "RDI" monitors.
        * arm/coff-rdpmon.specs, arm/elf-rdpmon.specs,
        arm/coff-rdimon.specs, arm/elf-rdimon.specs: gcc specs files to go
        with above mentioned support libs and startfiles.
@
text
@d58 6
a63 8
#define CHECK_INIT(fp) \
  do                                    \
    {                                   \
      if ((fp)->_data == 0)             \
        (fp)->_data = _REENT;           \
      if (!(fp)->_data->__sdidinit)     \
        __sinit ((fp)->_data);          \
    }                                   \
a68 1
static int std_files_checked;
d119 2
a120 7
  if (!std_files_checked)
    {
       CHECK_INIT(stdin);
       CHECK_INIT(stdout);
       CHECK_INIT(stderr);
       std_files_checked = 1;
    }
@

