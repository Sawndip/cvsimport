head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.58
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.56
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.54
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.52
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.50
	gdb_7_0-branch:1.5.0.48
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tcl8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.46
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.44
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.42
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.40
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.38
	gdb_6_5-2006-05-14-branchpoint:1.5
	readline_5_1-import-branch:1.5.0.36
	readline_5_1-import-branchpoint:1.5
	gdb_6_4-branch:1.5.0.34
	gdb_6_4-2005-11-01-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.32
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	ezannoni_pie-20040323-branch:1.5.0.30
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.28
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.26
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.24
	cagney_x86i386-20030821-branch:1.5.0.22
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.20
	gdb_6_0-2003-06-23-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.18
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.16
	cagney_writestrings-20030508-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.14
	cagney_fileio-20030521-branchpoint:1.5
	carlton_dictionary-20030430-merge:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.12
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.10
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.8
	cagney_lazyid-20030317-branchpoint:1.5
	offbyone-20030313-branch:1.5.0.6
	offbyone-20030313-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.4
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.2
	interps-20030202-branchpoint:1.5
	TCL8_4_1:1.1.1.3
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.2
	TCL_8_4_1:1.1.1.3
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.4
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TCL_8_4_0:1.1.1.3
	carlton_dictionary-branch:1.2.0.16
	carlton_dictionary-20020920-branchpoint:1.2
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.14
	gdb_5_3-branch:1.2.0.12
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.10
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.8
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.6
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TCL_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	dejagnu-2000-02-04:1.1.1.1
	dejagnu-2000-01-31:1.1.1.1
	dejagnu-2000-01-24:1.1.1.1
	dejagnu-2000-01-17:1.1.1.1
	dejagnu-2000-01-10:1.1.1.1
	dejagnu-2000-01-04:1.1.1.1
	dejagnu-1999-12-21:1.1.1.1
	dejagnu-1999-12-13:1.1.1.1
	dejagnu-1999-12-07:1.1.1.1
	dejagnu-1999-12-06:1.1.1.1
	dejagnu-1999-11-15:1.1.1.1
	dejagnu-1999-11-08:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2003.01.21.19.40.00;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.26.19.47.50;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.37.02;	author kseitz;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2001.09.09.23.56.04;	author irox;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	99.11.09.01.28.43;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2002.09.27.21.49.02;	author kseitz;	state Exp;
branches;
next	;

1.3.4.1
date	2003.12.14.20.28.41;	author drow;	state Exp;
branches;
next	;

1.2.16.1
date	2002.12.23.19.40.13;	author carlton;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2003.02.07.19.18.09;	author carlton;	state Exp;
branches;
next	;

1.1.1.1
date	99.11.09.01.28.43;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.09.22.40.54;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.19.56.33;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tcl 8.4.1
@
text
@'\"
'\" Copyright (c) 1993 The Regents of the University of California.
'\" Copyright (c) 1994-1996 Sun Microsystems, Inc.
'\" Copyright (c) 2000 Ajuba Solutions.
'\"
'\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\" 
'\" RCS: @@(#) $Id: trace.n,v 1.11 2002/07/16 22:27:35 dgp Exp $
'\" 
.so man.macros
.TH trace n "8.4" Tcl "Tcl Built-In Commands"
.BS
'\" Note:  do not modify the .SH NAME line immediately below!
.SH NAME
trace \- Monitor variable accesses, command usages and command executions
.SH SYNOPSIS
\fBtrace \fIoption\fR ?\fIarg arg ...\fR?
.BE

.SH DESCRIPTION
.PP
This command causes Tcl commands to be executed whenever certain operations are
invoked.  The legal \fIoption\fR's (which may be abbreviated) are:
.TP
\fBtrace add \fItype name ops ?args?\fR
Where \fItype\fR is \fBcommand\fR, \fBexecution\fR, or \fBvariable\fR.
.RS
.TP
\fBtrace add command\fR \fIname ops command\fR
Arrange for \fIcommand\fR to be executed whenever command \fIname\fR
is modified in one of the ways given by the list \fIops\fR.  \fIName\fR will be
resolved using the usual namespace resolution rules used by
procedures.  If the command does not exist, an error will be thrown.
.RS
.PP
\fIOps\fR indicates which operations are of interest, and is a list of
one or more of the following items:
.TP
\fBrename\fR
Invoke \fIcommand\fR whenever the command is renamed.  Note that
renaming to the empty string is considered deletion, and will not
be traced with '\fBrename\fR'.
.TP
\fBdelete\fR
Invoke \fIcommand\fR when the command is deleted.  Commands can be
deleted explicitly by using the \fBrename\fR command to rename the
command to an empty string.  Commands are also deleted when the
interpreter is deleted, but traces will not be invoked because there is no
interpreter in which to execute them.
.PP
When the trace triggers, depending on the operations being traced, a 
number of arguments are appended to \fIcommand\fR so that the actual 
command is as follows:
.CS
\fIcommand oldName newName op\fR
.CE
\fIOldName\fR and \fInewName\fR give the traced command's current
(old) name, and the name to which it is being renamed (the empty
string if this is a 'delete' operation).
\fIOp\fR indicates what operation is being performed on the
command, and is one of \fBrename\fR or \fBdelete\fR as
defined above.  The trace operation cannot be used to stop a command
from being deleted.  Tcl will always remove the command once the trace
is complete.  Recursive renaming or deleting will not cause further traces 
of the same type to be evaluated, so a delete trace which itself
deletes the command, or a rename trace which itself renames the
command will not cause further trace evaluations to occur.
.RE
.TP
\fBtrace add execution\fR \fIname ops command\fR
Arrange for \fIcommand\fR to be executed whenever command \fIname\fR
is modified in one of the ways given by the list \fIops\fR.  \fIName\fR will be
resolved using the usual namespace resolution rules used by
procedures.  If the command does not exist, an error will be thrown.
.RS
.PP
\fIOps\fR indicates which operations are of interest, and is a list of
one or more of the following items:
.TP
\fBenter\fR
Invoke \fIcommand\fR whenever the command \fIname\fR is executed,
just before the actual execution takes place.
.TP
\fBleave\fR
Invoke \fIcommand\fR whenever the command \fIname\fR is executed,
just after the actual execution takes place.
.TP
\fBenterstep\fR
Invoke \fIcommand\fR for every tcl command which is executed 
inside the procedure \fIname\fR, just before the actual execution
takes place.  For example if we have 'proc foo {} { puts "hello" }',
then a \fIenterstep\fR trace would be 
invoked just before \fIputs "hello"\fR is executed.
Setting a \fIenterstep\fR trace on a \fIcommand\fR
will not result in an error and is simply ignored.
.TP
\fBleavestep\fR
Invoke \fIcommand\fR for every tcl command which is executed 
inside the procedure \fIname\fR, just after the actual execution
takes place.
Setting a \fIleavestep\fR trace on a \fIcommand\fR
will not result in an error and is simply ignored.
.PP
When the trace triggers, depending on the operations being traced, a 
number of arguments are appended to \fIcommand\fR so that the actual 
command is as follows:

For \fBenter\fR and \fBenterstep\fR operations:
.CS
\fIcommand command-string op\fR
.CE
\fICommand-string\fR gives the complete current command being 
executed (the traced command for a \fBenter\fR operation, an 
arbitrary command for a \fBenterstep\fR operation), including
all arguments in their fully expanded form.
\fIOp\fR indicates what operation is being performed on the
command execution, and is one of \fBenter\fR or \fBenterstep\fR as
defined above.  The trace operation can be used to stop the
command from executing, by deleting the command in question.  Of
course when the command is subsequently executed, an 'invalid command'
error will occur.
.TP
For \fBleave\fR and \fBleavestep\fR operations:
.CS
\fIcommand command-string code result op\fR
.CE
\fICommand-string\fR gives the complete current command being 
executed (the traced command for a \fBenter\fR operation, an 
arbitrary command for a \fBenterstep\fR operation), including
all arguments in their fully expanded form.
\fICode\fR gives the result code of that execution, and \fIresult\fR
the result string.
\fIOp\fR indicates what operation is being performed on the
command execution, and is one of \fBleave\fR or \fBleavestep\fR as
defined above.  
Note that the creation of many \fBenterstep\fR or
\fBleavestep\fR traces can lead to unintuitive results, since the
invoked commands from one trace can themselves lead to further
command invocations for other traces.

\fICommand\fR executes in the same context as the code that invoked
the traced operation: thus the \fIcommand\fR, if invoked from a procedure,
will have access to the same local variables as code in the procedure.
This context may be different than the context in which the trace was
created. If \fIcommand\fR invokes a procedure (which it normally does)
then the procedure will have to use upvar or uplevel commands if it wishes
to access the local variables of the code which invoked the trace operation.

While \fIcommand\fR is executing during an execution trace, traces
on \fIname\fR are temporarily disabled. This allows the \fIcommand\fR
to execute \fIname\fR in its body without invoking any other traces again.
If an error occurs while executing the \fIcommand\fR body, then the
\fIcommand\fR name as a whole will return that same error.

When multiple traces are set on \fIname\fR, then for \fIenter\fR
and \fIenterstep\fR operations, the traced commands are invoked
in the reverse order of how the traces were originally created;
and for \fIleave\fR and \fIleavestep\fR operations, the traced
commands are invoked in the original order of creation.

The behavior of execution traces is currently undefined for a command 
\fIname\fR imported into another namespace.
.RE
.TP
\fBtrace add variable\fI name ops command\fR
Arrange for \fIcommand\fR to be executed whenever variable \fIname\fR
is accessed in one of the ways given by the list \fIops\fR.  \fIName\fR may
refer to a normal variable, an element of an array, or to an array
as a whole (i.e. \fIname\fR may be just the name of an array, with no
parenthesized index).  If \fIname\fR refers to a whole array, then
\fIcommand\fR is invoked whenever any element of the array is
manipulated.  If the variable does not exist, it will be created but
will not be given a value, so it will be visible to \fBnamespace which\fR
queries, but not to \fBinfo exists\fR queries.
.RS
.PP
\fIOps\fR indicates which operations are of interest, and is a list of
one or more of the following items:
.TP
\fBarray\fR
Invoke \fIcommand\fR whenever the variable is accessed or modified via
the \fBarray\fR command, provided that \fIname\fR is not a scalar
variable at the time that the \fBarray\fR command is invoked.  If
\fIname\fR is a scalar variable, the access via the \fBarray\fR
command will not trigger the trace.
.TP
\fBread\fR
Invoke \fIcommand\fR whenever the variable is read.
.TP
\fBwrite\fR
Invoke \fIcommand\fR whenever the variable is written.
.TP
\fBunset\fR
Invoke \fIcommand\fR whenever the variable is unset.  Variables
can be unset explicitly with the \fBunset\fR command, or
implicitly when procedures return (all of their local variables
are unset).  Variables are also unset when interpreters are
deleted, but traces will not be invoked because there is no
interpreter in which to execute them.
.PP
When the trace triggers, three arguments are appended to
\fIcommand\fR so that the actual command is as follows:
.CS
\fIcommand name1 name2 op\fR
.CE
\fIName1\fR and \fIname2\fR give the name(s) for the variable
being accessed:  if the variable is a scalar then \fIname1\fR
gives the variable's name and \fIname2\fR is an empty string;
if the variable is an array element then \fIname1\fR gives the
name of the array and name2 gives the index into the array;
if an entire array is being deleted and the trace was registered
on the overall array, rather than a single element, then \fIname1\fR
gives the array name and \fIname2\fR is an empty string.
\fIName1\fR and \fIname2\fR are not necessarily the same as the
name used in the \fBtrace variable\fR command:  the \fBupvar\fR
command allows a procedure to reference a variable under a
different name.
\fIOp\fR indicates what operation is being performed on the
variable, and is one of \fBread\fR, \fBwrite\fR, or \fBunset\fR as
defined above.
.PP
\fICommand\fR executes in the same context as the code that invoked
the traced operation:  if the variable was accessed as part of a Tcl
procedure, then \fIcommand\fR will have access to the same local
variables as code in the procedure.  This context may be different
than the context in which the trace was created. If \fIcommand\fR
invokes a procedure (which it normally does) then the procedure will
have to use \fBupvar\fR or \fBuplevel\fR if it wishes to access the
traced variable.  Note also that \fIname1\fR may not necessarily be
the same as the name used to set the trace on the variable;
differences can occur if the access is made through a variable defined
with the \fBupvar\fR command.
.PP
For read and write traces, \fIcommand\fR can modify the variable to
affect the result of the traced operation.  If \fIcommand\fR modifies
the value of a variable during a read or write trace, then the new
value will be returned as the result of the traced operation.  The
return value from  \fIcommand\fR is ignored except that if it returns
an error of any sort then the traced operation also returns an error
with the same error message returned by the trace command (this
mechanism can be used to implement read-only variables, for example).
For write traces, \fIcommand\fR is invoked after the variable's value
has been changed; it can write a new value into the variable to
override the original value specified in the write operation.  To
implement read-only variables, \fIcommand\fR will have to restore the
old value of the variable.
.PP
While \fIcommand\fR is executing during a read or write trace, traces
on the variable are temporarily disabled.  This means that reads and
writes invoked by \fIcommand\fR will occur directly, without invoking
\fIcommand\fR (or any other traces) again.  However, if \fIcommand\fR
unsets the variable then unset traces will be invoked.
.PP
When an unset trace is invoked, the variable has already been deleted:
it will appear to be undefined with no traces.  If an unset occurs
because of a procedure return, then the trace will be invoked in the
variable context of the procedure being returned to:  the stack frame
of the returning procedure will no longer exist.  Traces are not
disabled during unset traces, so if an unset trace command creates a
new trace and accesses the variable, the trace will be invoked.  Any
errors in unset traces are ignored.
.PP
If there are multiple traces on a variable they are invoked in order
of creation, most-recent first.  If one trace returns an error, then
no further traces are invoked for the variable.  If an array element
has a trace set, and there is also a trace set on the array as a
whole, the trace on the overall array is invoked before the one on the
element.
.PP
Once created, the trace remains in effect either until the trace is
removed with the \fBtrace remove variable\fR command described below,
until the variable is unset, or until the interpreter is deleted.
Unsetting an element of array will remove any traces on that element,
but will not remove traces on the overall array.
.PP
This command returns an empty string.
.RE
.RE
.TP
\fBtrace remove \fItype name opList command\fR
Where \fItype\fR is either \fBcommand\fR, \fBexecution\fR or \fBvariable\fR.
.RS
.TP
\fBtrace remove command\fI name opList command\fR
If there is a trace set on command \fIname\fR with the operations and
command given by \fIopList\fR and \fIcommand\fR, then the trace is
removed, so that \fIcommand\fR will never again be invoked.  Returns
an empty string.   If \fIname\fR doesn't exist, the command will throw
an error.
.TP
\fBtrace remove execution\fI name opList command\fR
If there is a trace set on command \fIname\fR with the operations and
command given by \fIopList\fR and \fIcommand\fR, then the trace is
removed, so that \fIcommand\fR will never again be invoked.  Returns
an empty string.   If \fIname\fR doesn't exist, the command will throw
an error.
.TP
\fBtrace remove variable\fI name opList command\fR
If there is a trace set on variable \fIname\fR with the operations and
command given by \fIopList\fR and \fIcommand\fR, then the trace is
removed, so that \fIcommand\fR will never again be invoked.  Returns
an empty string.
.RE
.TP
\fBtrace info \fItype name\fR
Where \fItype\fR is either \fBcommand\fR, \fBexecution\fR or \fBvariable\fR.
.RS
.TP
\fBtrace info command\fI name\fR
Returns a list containing one element for each trace currently set on
command \fIname\fR. Each element of the list is itself a list
containing two elements, which are the \fIopList\fR and \fIcommand\fR
associated with the trace.  If \fIname\fR doesn't have any traces set,
then the result of the command will be an empty string.  If \fIname\fR
doesn't exist, the command will throw an error.
.TP
\fBtrace info execution\fI name\fR
Returns a list containing one element for each trace currently set on
command \fIname\fR. Each element of the list is itself a list
containing two elements, which are the \fIopList\fR and \fIcommand\fR
associated with the trace.  If \fIname\fR doesn't have any traces set,
then the result of the command will be an empty string.  If \fIname\fR
doesn't exist, the command will throw an error.
.TP
\fBtrace info variable\fI name\fR
Returns a list containing one element for each trace currently set on
variable \fIname\fR.  Each element of the list is itself a list
containing two elements, which are the \fIopList\fR and \fIcommand\fR
associated with the trace.  If \fIname\fR doesn't exist or doesn't
have any traces set, then the result of the command will be an empty
string.
.RE
.PP
For backwards compatibility, three other subcommands are available:
.RS
.TP
\fBtrace variable \fIname ops command\fR
This is equivalent to \fBtrace add variable \fIname ops command\fR.
.TP
\fBtrace vdelete \fIname ops command\fR
This is equivalent to \fBtrace remove variable \fIname ops command\fR
.TP 
\fBtrace vinfo \fIname\fR 
This is equivalent to \fBtrace info variable \fIname\fR
.RE
.PP
These subcommands are deprecated and will likely be removed in a
future version of Tcl.  They use an older syntax in which \fBarray\fR,
\fBread\fR, \fBwrite\fR, \fBunset\fR are replaced by \fBa\fR, \fBr\fR,
\fBw\fR and \fBu\fR respectively, and the \fIops\fR argument is not a
list, but simply a string concatenation of the operations, such as
\fBrwua\fR.

.SH "SEE ALSO"
set(n), unset(n)

.SH KEYWORDS
read, command, rename, variable, write, trace, unset
@


1.4
log
@touched all sources to ease next import
@
text
@d4 1
d9 1
a9 1
'\" RCS: @@(#) $Id: trace.n,v 1.6.8.1 2000/04/06 22:38:27 spolk Exp $
d12 1
a12 1
.TH trace n "" Tcl "Tcl Built-In Commands"
d16 1
a16 1
trace \- Monitor variable accesses
d24 1
a24 2
invoked.  At present, only variable tracing is implemented. The
legal \fIoption\fR's (which may be abbreviated) are:
d26 141
a166 1
\fBtrace variable \fIname ops command\fR
d168 1
a168 1
is accessed in one of the ways given by \fIops\fR.  \fIName\fR may
d178 9
a186 2
\fIOps\fR indicates which operations are of interest, and consists of
one or more of the following letters:
d188 1
a188 1
\fBr\fR
d191 1
a191 1
\fBw\fR
d194 1
a194 1
\fBu\fR
d220 1
a220 1
variable, and is one of \fBr\fR, \fBw\fR, or \fBu\fR as
d224 24
a247 28
the traced operation:  if the variable was accessed as part of a
Tcl procedure, then \fIcommand\fR will have access to the same
local variables as code in the procedure.  This context may be
different than the context in which the trace was created.
If \fIcommand\fR invokes a procedure (which it normally does) then
the procedure will have to use \fBupvar\fR or \fBuplevel\fR if it
wishes to access the traced variable.
Note also that \fIname1\fR may not necessarily be the same as the name
used to set the trace on the variable;  differences can occur if
the access is made through a variable defined with the \fBupvar\fR
command.
.PP
For read and write traces, \fIcommand\fR can modify
the variable to affect the result of the traced operation.
If \fIcommand\fR modifies the value of a variable during a
read or write trace, then the new value will be returned as the
result of the traced operation.
The return value from  \fIcommand\fR is ignored except that
if it returns an error of any sort then the traced operation
also returns an error with
the same error message returned by the trace command
(this mechanism can be used to implement read-only variables, for
example).
For write traces, \fIcommand\fR is invoked after the variable's
value has been changed; it can write a new value into the variable
to override the original value specified in the write operation.
To implement read-only variables, \fIcommand\fR will have to restore
the old value of the variable.
d250 26
a275 32
on the variable are temporarily disabled.
This means that reads and writes invoked by
\fIcommand\fR will occur directly, without invoking \fIcommand\fR
(or any other traces) again.
However, if \fIcommand\fR unsets the variable then unset traces
will be invoked.
.PP
When an unset trace is invoked, the variable has already been
deleted:  it will appear to be undefined with no traces.
If an unset occurs because of a procedure return, then the
trace will be invoked in the variable context of the procedure
being returned to:  the stack frame of the returning procedure
will no longer exist.
Traces are not disabled during unset traces, so if an unset trace
command creates a new trace and accesses the variable, the
trace will be invoked.
Any errors in unset traces are ignored.
.PP
If there are multiple traces on a variable they are invoked
in order of creation, most-recent first.
If one trace returns an error, then no further traces are
invoked for the variable.
If an array element has a trace set, and there is also a trace
set on the array as a whole, the trace on the overall array
is invoked before the one on the element.
.PP
Once created, the trace remains in effect either until the
trace is removed with the \fBtrace vdelete\fR command described
below, until the variable is unset, or until the interpreter
is deleted.
Unsetting an element of array will remove any traces on that
element, but will not remove traces on the overall array.
d279 61
d342 15
a356 14
If there is a trace set on variable \fIname\fR with the
operations and command given by \fIops\fR and \fIcommand\fR,
then the trace is removed, so that \fIcommand\fR will never
again be invoked.
Returns an empty string.
.TP
\fBtrace vinfo \fIname\fR
Returns a list containing one element for each trace
currently set on variable \fIname\fR.
Each element of the list is itself a list containing two
elements, which are the \fIops\fR and \fIcommand\fR associated
with the trace.
If \fIname\fR doesn't exist or doesn't have any traces set, then
the result of the command will be an empty string.
d359 1
a359 1
read, variable, write, trace, unset
@


1.3
log
@touched all sources to ease next import
@
text
@@


1.3.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@a3 1
'\" Copyright (c) 2000 Ajuba Solutions.
d8 1
a8 1
'\" RCS: @@(#) $Id: trace.n,v 1.11 2002/07/16 22:27:35 dgp Exp $
d11 1
a11 1
.TH trace n "8.4" Tcl "Tcl Built-In Commands"
d15 1
a15 1
trace \- Monitor variable accesses, command usages and command executions
d23 2
a24 1
invoked.  The legal \fIoption\fR's (which may be abbreviated) are:
d26 1
a26 141
\fBtrace add \fItype name ops ?args?\fR
Where \fItype\fR is \fBcommand\fR, \fBexecution\fR, or \fBvariable\fR.
.RS
.TP
\fBtrace add command\fR \fIname ops command\fR
Arrange for \fIcommand\fR to be executed whenever command \fIname\fR
is modified in one of the ways given by the list \fIops\fR.  \fIName\fR will be
resolved using the usual namespace resolution rules used by
procedures.  If the command does not exist, an error will be thrown.
.RS
.PP
\fIOps\fR indicates which operations are of interest, and is a list of
one or more of the following items:
.TP
\fBrename\fR
Invoke \fIcommand\fR whenever the command is renamed.  Note that
renaming to the empty string is considered deletion, and will not
be traced with '\fBrename\fR'.
.TP
\fBdelete\fR
Invoke \fIcommand\fR when the command is deleted.  Commands can be
deleted explicitly by using the \fBrename\fR command to rename the
command to an empty string.  Commands are also deleted when the
interpreter is deleted, but traces will not be invoked because there is no
interpreter in which to execute them.
.PP
When the trace triggers, depending on the operations being traced, a 
number of arguments are appended to \fIcommand\fR so that the actual 
command is as follows:
.CS
\fIcommand oldName newName op\fR
.CE
\fIOldName\fR and \fInewName\fR give the traced command's current
(old) name, and the name to which it is being renamed (the empty
string if this is a 'delete' operation).
\fIOp\fR indicates what operation is being performed on the
command, and is one of \fBrename\fR or \fBdelete\fR as
defined above.  The trace operation cannot be used to stop a command
from being deleted.  Tcl will always remove the command once the trace
is complete.  Recursive renaming or deleting will not cause further traces 
of the same type to be evaluated, so a delete trace which itself
deletes the command, or a rename trace which itself renames the
command will not cause further trace evaluations to occur.
.RE
.TP
\fBtrace add execution\fR \fIname ops command\fR
Arrange for \fIcommand\fR to be executed whenever command \fIname\fR
is modified in one of the ways given by the list \fIops\fR.  \fIName\fR will be
resolved using the usual namespace resolution rules used by
procedures.  If the command does not exist, an error will be thrown.
.RS
.PP
\fIOps\fR indicates which operations are of interest, and is a list of
one or more of the following items:
.TP
\fBenter\fR
Invoke \fIcommand\fR whenever the command \fIname\fR is executed,
just before the actual execution takes place.
.TP
\fBleave\fR
Invoke \fIcommand\fR whenever the command \fIname\fR is executed,
just after the actual execution takes place.
.TP
\fBenterstep\fR
Invoke \fIcommand\fR for every tcl command which is executed 
inside the procedure \fIname\fR, just before the actual execution
takes place.  For example if we have 'proc foo {} { puts "hello" }',
then a \fIenterstep\fR trace would be 
invoked just before \fIputs "hello"\fR is executed.
Setting a \fIenterstep\fR trace on a \fIcommand\fR
will not result in an error and is simply ignored.
.TP
\fBleavestep\fR
Invoke \fIcommand\fR for every tcl command which is executed 
inside the procedure \fIname\fR, just after the actual execution
takes place.
Setting a \fIleavestep\fR trace on a \fIcommand\fR
will not result in an error and is simply ignored.
.PP
When the trace triggers, depending on the operations being traced, a 
number of arguments are appended to \fIcommand\fR so that the actual 
command is as follows:

For \fBenter\fR and \fBenterstep\fR operations:
.CS
\fIcommand command-string op\fR
.CE
\fICommand-string\fR gives the complete current command being 
executed (the traced command for a \fBenter\fR operation, an 
arbitrary command for a \fBenterstep\fR operation), including
all arguments in their fully expanded form.
\fIOp\fR indicates what operation is being performed on the
command execution, and is one of \fBenter\fR or \fBenterstep\fR as
defined above.  The trace operation can be used to stop the
command from executing, by deleting the command in question.  Of
course when the command is subsequently executed, an 'invalid command'
error will occur.
.TP
For \fBleave\fR and \fBleavestep\fR operations:
.CS
\fIcommand command-string code result op\fR
.CE
\fICommand-string\fR gives the complete current command being 
executed (the traced command for a \fBenter\fR operation, an 
arbitrary command for a \fBenterstep\fR operation), including
all arguments in their fully expanded form.
\fICode\fR gives the result code of that execution, and \fIresult\fR
the result string.
\fIOp\fR indicates what operation is being performed on the
command execution, and is one of \fBleave\fR or \fBleavestep\fR as
defined above.  
Note that the creation of many \fBenterstep\fR or
\fBleavestep\fR traces can lead to unintuitive results, since the
invoked commands from one trace can themselves lead to further
command invocations for other traces.

\fICommand\fR executes in the same context as the code that invoked
the traced operation: thus the \fIcommand\fR, if invoked from a procedure,
will have access to the same local variables as code in the procedure.
This context may be different than the context in which the trace was
created. If \fIcommand\fR invokes a procedure (which it normally does)
then the procedure will have to use upvar or uplevel commands if it wishes
to access the local variables of the code which invoked the trace operation.

While \fIcommand\fR is executing during an execution trace, traces
on \fIname\fR are temporarily disabled. This allows the \fIcommand\fR
to execute \fIname\fR in its body without invoking any other traces again.
If an error occurs while executing the \fIcommand\fR body, then the
\fIcommand\fR name as a whole will return that same error.

When multiple traces are set on \fIname\fR, then for \fIenter\fR
and \fIenterstep\fR operations, the traced commands are invoked
in the reverse order of how the traces were originally created;
and for \fIleave\fR and \fIleavestep\fR operations, the traced
commands are invoked in the original order of creation.

The behavior of execution traces is currently undefined for a command 
\fIname\fR imported into another namespace.
.RE
.TP
\fBtrace add variable\fI name ops command\fR
d28 1
a28 1
is accessed in one of the ways given by the list \fIops\fR.  \fIName\fR may
d38 2
a39 9
\fIOps\fR indicates which operations are of interest, and is a list of
one or more of the following items:
.TP
\fBarray\fR
Invoke \fIcommand\fR whenever the variable is accessed or modified via
the \fBarray\fR command, provided that \fIname\fR is not a scalar
variable at the time that the \fBarray\fR command is invoked.  If
\fIname\fR is a scalar variable, the access via the \fBarray\fR
command will not trigger the trace.
d41 1
a41 1
\fBread\fR
d44 1
a44 1
\fBwrite\fR
d47 1
a47 1
\fBunset\fR
d73 1
a73 1
variable, and is one of \fBread\fR, \fBwrite\fR, or \fBunset\fR as
d77 28
a104 24
the traced operation:  if the variable was accessed as part of a Tcl
procedure, then \fIcommand\fR will have access to the same local
variables as code in the procedure.  This context may be different
than the context in which the trace was created. If \fIcommand\fR
invokes a procedure (which it normally does) then the procedure will
have to use \fBupvar\fR or \fBuplevel\fR if it wishes to access the
traced variable.  Note also that \fIname1\fR may not necessarily be
the same as the name used to set the trace on the variable;
differences can occur if the access is made through a variable defined
with the \fBupvar\fR command.
.PP
For read and write traces, \fIcommand\fR can modify the variable to
affect the result of the traced operation.  If \fIcommand\fR modifies
the value of a variable during a read or write trace, then the new
value will be returned as the result of the traced operation.  The
return value from  \fIcommand\fR is ignored except that if it returns
an error of any sort then the traced operation also returns an error
with the same error message returned by the trace command (this
mechanism can be used to implement read-only variables, for example).
For write traces, \fIcommand\fR is invoked after the variable's value
has been changed; it can write a new value into the variable to
override the original value specified in the write operation.  To
implement read-only variables, \fIcommand\fR will have to restore the
old value of the variable.
d107 32
a138 26
on the variable are temporarily disabled.  This means that reads and
writes invoked by \fIcommand\fR will occur directly, without invoking
\fIcommand\fR (or any other traces) again.  However, if \fIcommand\fR
unsets the variable then unset traces will be invoked.
.PP
When an unset trace is invoked, the variable has already been deleted:
it will appear to be undefined with no traces.  If an unset occurs
because of a procedure return, then the trace will be invoked in the
variable context of the procedure being returned to:  the stack frame
of the returning procedure will no longer exist.  Traces are not
disabled during unset traces, so if an unset trace command creates a
new trace and accesses the variable, the trace will be invoked.  Any
errors in unset traces are ignored.
.PP
If there are multiple traces on a variable they are invoked in order
of creation, most-recent first.  If one trace returns an error, then
no further traces are invoked for the variable.  If an array element
has a trace set, and there is also a trace set on the array as a
whole, the trace on the overall array is invoked before the one on the
element.
.PP
Once created, the trace remains in effect either until the trace is
removed with the \fBtrace remove variable\fR command described below,
until the variable is unset, or until the interpreter is deleted.
Unsetting an element of array will remove any traces on that element,
but will not remove traces on the overall array.
a141 61
.RE
.TP
\fBtrace remove \fItype name opList command\fR
Where \fItype\fR is either \fBcommand\fR, \fBexecution\fR or \fBvariable\fR.
.RS
.TP
\fBtrace remove command\fI name opList command\fR
If there is a trace set on command \fIname\fR with the operations and
command given by \fIopList\fR and \fIcommand\fR, then the trace is
removed, so that \fIcommand\fR will never again be invoked.  Returns
an empty string.   If \fIname\fR doesn't exist, the command will throw
an error.
.TP
\fBtrace remove execution\fI name opList command\fR
If there is a trace set on command \fIname\fR with the operations and
command given by \fIopList\fR and \fIcommand\fR, then the trace is
removed, so that \fIcommand\fR will never again be invoked.  Returns
an empty string.   If \fIname\fR doesn't exist, the command will throw
an error.
.TP
\fBtrace remove variable\fI name opList command\fR
If there is a trace set on variable \fIname\fR with the operations and
command given by \fIopList\fR and \fIcommand\fR, then the trace is
removed, so that \fIcommand\fR will never again be invoked.  Returns
an empty string.
.RE
.TP
\fBtrace info \fItype name\fR
Where \fItype\fR is either \fBcommand\fR, \fBexecution\fR or \fBvariable\fR.
.RS
.TP
\fBtrace info command\fI name\fR
Returns a list containing one element for each trace currently set on
command \fIname\fR. Each element of the list is itself a list
containing two elements, which are the \fIopList\fR and \fIcommand\fR
associated with the trace.  If \fIname\fR doesn't have any traces set,
then the result of the command will be an empty string.  If \fIname\fR
doesn't exist, the command will throw an error.
.TP
\fBtrace info execution\fI name\fR
Returns a list containing one element for each trace currently set on
command \fIname\fR. Each element of the list is itself a list
containing two elements, which are the \fIopList\fR and \fIcommand\fR
associated with the trace.  If \fIname\fR doesn't have any traces set,
then the result of the command will be an empty string.  If \fIname\fR
doesn't exist, the command will throw an error.
.TP
\fBtrace info variable\fI name\fR
Returns a list containing one element for each trace currently set on
variable \fIname\fR.  Each element of the list is itself a list
containing two elements, which are the \fIopList\fR and \fIcommand\fR
associated with the trace.  If \fIname\fR doesn't exist or doesn't
have any traces set, then the result of the command will be an empty
string.
.RE
.PP
For backwards compatibility, three other subcommands are available:
.RS
.TP
\fBtrace variable \fIname ops command\fR
This is equivalent to \fBtrace add variable \fIname ops command\fR.
d144 14
a157 15
This is equivalent to \fBtrace remove variable \fIname ops command\fR
.TP 
\fBtrace vinfo \fIname\fR 
This is equivalent to \fBtrace info variable \fIname\fR
.RE
.PP
These subcommands are deprecated and will likely be removed in a
future version of Tcl.  They use an older syntax in which \fBarray\fR,
\fBread\fR, \fBwrite\fR, \fBunset\fR are replaced by \fBa\fR, \fBr\fR,
\fBw\fR and \fBu\fR respectively, and the \fIops\fR argument is not a
list, but simply a string concatenation of the operations, such as
\fBrwua\fR.

.SH "SEE ALSO"
set(n), unset(n)
d160 1
a160 1
read, command, rename, variable, write, trace, unset
@


1.3.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@a3 1
'\" Copyright (c) 2000 Ajuba Solutions.
d8 1
a8 1
'\" RCS: @@(#) $Id: trace.n,v 1.11 2002/07/16 22:27:35 dgp Exp $
d11 1
a11 1
.TH trace n "8.4" Tcl "Tcl Built-In Commands"
d15 1
a15 1
trace \- Monitor variable accesses, command usages and command executions
d23 2
a24 1
invoked.  The legal \fIoption\fR's (which may be abbreviated) are:
d26 1
a26 141
\fBtrace add \fItype name ops ?args?\fR
Where \fItype\fR is \fBcommand\fR, \fBexecution\fR, or \fBvariable\fR.
.RS
.TP
\fBtrace add command\fR \fIname ops command\fR
Arrange for \fIcommand\fR to be executed whenever command \fIname\fR
is modified in one of the ways given by the list \fIops\fR.  \fIName\fR will be
resolved using the usual namespace resolution rules used by
procedures.  If the command does not exist, an error will be thrown.
.RS
.PP
\fIOps\fR indicates which operations are of interest, and is a list of
one or more of the following items:
.TP
\fBrename\fR
Invoke \fIcommand\fR whenever the command is renamed.  Note that
renaming to the empty string is considered deletion, and will not
be traced with '\fBrename\fR'.
.TP
\fBdelete\fR
Invoke \fIcommand\fR when the command is deleted.  Commands can be
deleted explicitly by using the \fBrename\fR command to rename the
command to an empty string.  Commands are also deleted when the
interpreter is deleted, but traces will not be invoked because there is no
interpreter in which to execute them.
.PP
When the trace triggers, depending on the operations being traced, a 
number of arguments are appended to \fIcommand\fR so that the actual 
command is as follows:
.CS
\fIcommand oldName newName op\fR
.CE
\fIOldName\fR and \fInewName\fR give the traced command's current
(old) name, and the name to which it is being renamed (the empty
string if this is a 'delete' operation).
\fIOp\fR indicates what operation is being performed on the
command, and is one of \fBrename\fR or \fBdelete\fR as
defined above.  The trace operation cannot be used to stop a command
from being deleted.  Tcl will always remove the command once the trace
is complete.  Recursive renaming or deleting will not cause further traces 
of the same type to be evaluated, so a delete trace which itself
deletes the command, or a rename trace which itself renames the
command will not cause further trace evaluations to occur.
.RE
.TP
\fBtrace add execution\fR \fIname ops command\fR
Arrange for \fIcommand\fR to be executed whenever command \fIname\fR
is modified in one of the ways given by the list \fIops\fR.  \fIName\fR will be
resolved using the usual namespace resolution rules used by
procedures.  If the command does not exist, an error will be thrown.
.RS
.PP
\fIOps\fR indicates which operations are of interest, and is a list of
one or more of the following items:
.TP
\fBenter\fR
Invoke \fIcommand\fR whenever the command \fIname\fR is executed,
just before the actual execution takes place.
.TP
\fBleave\fR
Invoke \fIcommand\fR whenever the command \fIname\fR is executed,
just after the actual execution takes place.
.TP
\fBenterstep\fR
Invoke \fIcommand\fR for every tcl command which is executed 
inside the procedure \fIname\fR, just before the actual execution
takes place.  For example if we have 'proc foo {} { puts "hello" }',
then a \fIenterstep\fR trace would be 
invoked just before \fIputs "hello"\fR is executed.
Setting a \fIenterstep\fR trace on a \fIcommand\fR
will not result in an error and is simply ignored.
.TP
\fBleavestep\fR
Invoke \fIcommand\fR for every tcl command which is executed 
inside the procedure \fIname\fR, just after the actual execution
takes place.
Setting a \fIleavestep\fR trace on a \fIcommand\fR
will not result in an error and is simply ignored.
.PP
When the trace triggers, depending on the operations being traced, a 
number of arguments are appended to \fIcommand\fR so that the actual 
command is as follows:

For \fBenter\fR and \fBenterstep\fR operations:
.CS
\fIcommand command-string op\fR
.CE
\fICommand-string\fR gives the complete current command being 
executed (the traced command for a \fBenter\fR operation, an 
arbitrary command for a \fBenterstep\fR operation), including
all arguments in their fully expanded form.
\fIOp\fR indicates what operation is being performed on the
command execution, and is one of \fBenter\fR or \fBenterstep\fR as
defined above.  The trace operation can be used to stop the
command from executing, by deleting the command in question.  Of
course when the command is subsequently executed, an 'invalid command'
error will occur.
.TP
For \fBleave\fR and \fBleavestep\fR operations:
.CS
\fIcommand command-string code result op\fR
.CE
\fICommand-string\fR gives the complete current command being 
executed (the traced command for a \fBenter\fR operation, an 
arbitrary command for a \fBenterstep\fR operation), including
all arguments in their fully expanded form.
\fICode\fR gives the result code of that execution, and \fIresult\fR
the result string.
\fIOp\fR indicates what operation is being performed on the
command execution, and is one of \fBleave\fR or \fBleavestep\fR as
defined above.  
Note that the creation of many \fBenterstep\fR or
\fBleavestep\fR traces can lead to unintuitive results, since the
invoked commands from one trace can themselves lead to further
command invocations for other traces.

\fICommand\fR executes in the same context as the code that invoked
the traced operation: thus the \fIcommand\fR, if invoked from a procedure,
will have access to the same local variables as code in the procedure.
This context may be different than the context in which the trace was
created. If \fIcommand\fR invokes a procedure (which it normally does)
then the procedure will have to use upvar or uplevel commands if it wishes
to access the local variables of the code which invoked the trace operation.

While \fIcommand\fR is executing during an execution trace, traces
on \fIname\fR are temporarily disabled. This allows the \fIcommand\fR
to execute \fIname\fR in its body without invoking any other traces again.
If an error occurs while executing the \fIcommand\fR body, then the
\fIcommand\fR name as a whole will return that same error.

When multiple traces are set on \fIname\fR, then for \fIenter\fR
and \fIenterstep\fR operations, the traced commands are invoked
in the reverse order of how the traces were originally created;
and for \fIleave\fR and \fIleavestep\fR operations, the traced
commands are invoked in the original order of creation.

The behavior of execution traces is currently undefined for a command 
\fIname\fR imported into another namespace.
.RE
.TP
\fBtrace add variable\fI name ops command\fR
d28 1
a28 1
is accessed in one of the ways given by the list \fIops\fR.  \fIName\fR may
d38 2
a39 9
\fIOps\fR indicates which operations are of interest, and is a list of
one or more of the following items:
.TP
\fBarray\fR
Invoke \fIcommand\fR whenever the variable is accessed or modified via
the \fBarray\fR command, provided that \fIname\fR is not a scalar
variable at the time that the \fBarray\fR command is invoked.  If
\fIname\fR is a scalar variable, the access via the \fBarray\fR
command will not trigger the trace.
d41 1
a41 1
\fBread\fR
d44 1
a44 1
\fBwrite\fR
d47 1
a47 1
\fBunset\fR
d73 1
a73 1
variable, and is one of \fBread\fR, \fBwrite\fR, or \fBunset\fR as
d77 28
a104 24
the traced operation:  if the variable was accessed as part of a Tcl
procedure, then \fIcommand\fR will have access to the same local
variables as code in the procedure.  This context may be different
than the context in which the trace was created. If \fIcommand\fR
invokes a procedure (which it normally does) then the procedure will
have to use \fBupvar\fR or \fBuplevel\fR if it wishes to access the
traced variable.  Note also that \fIname1\fR may not necessarily be
the same as the name used to set the trace on the variable;
differences can occur if the access is made through a variable defined
with the \fBupvar\fR command.
.PP
For read and write traces, \fIcommand\fR can modify the variable to
affect the result of the traced operation.  If \fIcommand\fR modifies
the value of a variable during a read or write trace, then the new
value will be returned as the result of the traced operation.  The
return value from  \fIcommand\fR is ignored except that if it returns
an error of any sort then the traced operation also returns an error
with the same error message returned by the trace command (this
mechanism can be used to implement read-only variables, for example).
For write traces, \fIcommand\fR is invoked after the variable's value
has been changed; it can write a new value into the variable to
override the original value specified in the write operation.  To
implement read-only variables, \fIcommand\fR will have to restore the
old value of the variable.
d107 32
a138 26
on the variable are temporarily disabled.  This means that reads and
writes invoked by \fIcommand\fR will occur directly, without invoking
\fIcommand\fR (or any other traces) again.  However, if \fIcommand\fR
unsets the variable then unset traces will be invoked.
.PP
When an unset trace is invoked, the variable has already been deleted:
it will appear to be undefined with no traces.  If an unset occurs
because of a procedure return, then the trace will be invoked in the
variable context of the procedure being returned to:  the stack frame
of the returning procedure will no longer exist.  Traces are not
disabled during unset traces, so if an unset trace command creates a
new trace and accesses the variable, the trace will be invoked.  Any
errors in unset traces are ignored.
.PP
If there are multiple traces on a variable they are invoked in order
of creation, most-recent first.  If one trace returns an error, then
no further traces are invoked for the variable.  If an array element
has a trace set, and there is also a trace set on the array as a
whole, the trace on the overall array is invoked before the one on the
element.
.PP
Once created, the trace remains in effect either until the trace is
removed with the \fBtrace remove variable\fR command described below,
until the variable is unset, or until the interpreter is deleted.
Unsetting an element of array will remove any traces on that element,
but will not remove traces on the overall array.
a141 61
.RE
.TP
\fBtrace remove \fItype name opList command\fR
Where \fItype\fR is either \fBcommand\fR, \fBexecution\fR or \fBvariable\fR.
.RS
.TP
\fBtrace remove command\fI name opList command\fR
If there is a trace set on command \fIname\fR with the operations and
command given by \fIopList\fR and \fIcommand\fR, then the trace is
removed, so that \fIcommand\fR will never again be invoked.  Returns
an empty string.   If \fIname\fR doesn't exist, the command will throw
an error.
.TP
\fBtrace remove execution\fI name opList command\fR
If there is a trace set on command \fIname\fR with the operations and
command given by \fIopList\fR and \fIcommand\fR, then the trace is
removed, so that \fIcommand\fR will never again be invoked.  Returns
an empty string.   If \fIname\fR doesn't exist, the command will throw
an error.
.TP
\fBtrace remove variable\fI name opList command\fR
If there is a trace set on variable \fIname\fR with the operations and
command given by \fIopList\fR and \fIcommand\fR, then the trace is
removed, so that \fIcommand\fR will never again be invoked.  Returns
an empty string.
.RE
.TP
\fBtrace info \fItype name\fR
Where \fItype\fR is either \fBcommand\fR, \fBexecution\fR or \fBvariable\fR.
.RS
.TP
\fBtrace info command\fI name\fR
Returns a list containing one element for each trace currently set on
command \fIname\fR. Each element of the list is itself a list
containing two elements, which are the \fIopList\fR and \fIcommand\fR
associated with the trace.  If \fIname\fR doesn't have any traces set,
then the result of the command will be an empty string.  If \fIname\fR
doesn't exist, the command will throw an error.
.TP
\fBtrace info execution\fI name\fR
Returns a list containing one element for each trace currently set on
command \fIname\fR. Each element of the list is itself a list
containing two elements, which are the \fIopList\fR and \fIcommand\fR
associated with the trace.  If \fIname\fR doesn't have any traces set,
then the result of the command will be an empty string.  If \fIname\fR
doesn't exist, the command will throw an error.
.TP
\fBtrace info variable\fI name\fR
Returns a list containing one element for each trace currently set on
variable \fIname\fR.  Each element of the list is itself a list
containing two elements, which are the \fIopList\fR and \fIcommand\fR
associated with the trace.  If \fIname\fR doesn't exist or doesn't
have any traces set, then the result of the command will be an empty
string.
.RE
.PP
For backwards compatibility, three other subcommands are available:
.RS
.TP
\fBtrace variable \fIname ops command\fR
This is equivalent to \fBtrace add variable \fIname ops command\fR.
d144 14
a157 15
This is equivalent to \fBtrace remove variable \fIname ops command\fR
.TP 
\fBtrace vinfo \fIname\fR 
This is equivalent to \fBtrace info variable \fIname\fR
.RE
.PP
These subcommands are deprecated and will likely be removed in a
future version of Tcl.  They use an older syntax in which \fBarray\fR,
\fBread\fR, \fBwrite\fR, \fBunset\fR are replaced by \fBa\fR, \fBr\fR,
\fBw\fR and \fBu\fR respectively, and the \fIops\fR argument is not a
list, but simply a string concatenation of the operations, such as
\fBrwua\fR.

.SH "SEE ALSO"
set(n), unset(n)
d160 1
a160 1
read, command, rename, variable, write, trace, unset
@


1.2
log
@touched all Tcl files to ease next import.
@
text
@@


1.2.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.2.16.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@a3 1
'\" Copyright (c) 2000 Ajuba Solutions.
d11 1
a11 1
.TH trace n "8.4" Tcl "Tcl Built-In Commands"
d15 1
a15 1
trace \- Monitor variable accesses, command usages and command executions
d23 2
a24 1
invoked.  The legal \fIoption\fR's (which may be abbreviated) are:
d26 1
a26 141
\fBtrace add \fItype name ops ?args?\fR
Where \fItype\fR is \fBcommand\fR, \fBexecution\fR, or \fBvariable\fR.
.RS
.TP
\fBtrace add command\fR \fIname ops command\fR
Arrange for \fIcommand\fR to be executed whenever command \fIname\fR
is modified in one of the ways given by the list \fIops\fR.  \fIName\fR will be
resolved using the usual namespace resolution rules used by
procedures.  If the command does not exist, an error will be thrown.
.RS
.PP
\fIOps\fR indicates which operations are of interest, and is a list of
one or more of the following items:
.TP
\fBrename\fR
Invoke \fIcommand\fR whenever the command is renamed.  Note that
renaming to the empty string is considered deletion, and will not
be traced with '\fBrename\fR'.
.TP
\fBdelete\fR
Invoke \fIcommand\fR when the command is deleted.  Commands can be
deleted explicitly by using the \fBrename\fR command to rename the
command to an empty string.  Commands are also deleted when the
interpreter is deleted, but traces will not be invoked because there is no
interpreter in which to execute them.
.PP
When the trace triggers, depending on the operations being traced, a 
number of arguments are appended to \fIcommand\fR so that the actual 
command is as follows:
.CS
\fIcommand oldName newName op\fR
.CE
\fIOldName\fR and \fInewName\fR give the traced command's current
(old) name, and the name to which it is being renamed (the empty
string if this is a 'delete' operation).
\fIOp\fR indicates what operation is being performed on the
command, and is one of \fBrename\fR or \fBdelete\fR as
defined above.  The trace operation cannot be used to stop a command
from being deleted.  Tcl will always remove the command once the trace
is complete.  Recursive renaming or deleting will not cause further traces 
of the same type to be evaluated, so a delete trace which itself
deletes the command, or a rename trace which itself renames the
command will not cause further trace evaluations to occur.
.RE
.TP
\fBtrace add execution\fR \fIname ops command\fR
Arrange for \fIcommand\fR to be executed whenever command \fIname\fR
is modified in one of the ways given by the list \fIops\fR.  \fIName\fR will be
resolved using the usual namespace resolution rules used by
procedures.  If the command does not exist, an error will be thrown.
.RS
.PP
\fIOps\fR indicates which operations are of interest, and is a list of
one or more of the following items:
.TP
\fBenter\fR
Invoke \fIcommand\fR whenever the command \fIname\fR is executed,
just before the actual execution takes place.
.TP
\fBleave\fR
Invoke \fIcommand\fR whenever the command \fIname\fR is executed,
just after the actual execution takes place.
.TP
\fBenterstep\fR
Invoke \fIcommand\fR for every tcl command which is executed 
inside the procedure \fIname\fR, just before the actual execution
takes place.  For example if we have 'proc foo {} { puts "hello" }',
then a \fIenterstep\fR trace would be 
invoked just before \fIputs "hello"\fR is executed.
Setting a \fIenterstep\fR trace on a \fIcommand\fR
will not result in an error and is simply ignored.
.TP
\fBleavestep\fR
Invoke \fIcommand\fR for every tcl command which is executed 
inside the procedure \fIname\fR, just after the actual execution
takes place.
Setting a \fIleavestep\fR trace on a \fIcommand\fR
will not result in an error and is simply ignored.
.PP
When the trace triggers, depending on the operations being traced, a 
number of arguments are appended to \fIcommand\fR so that the actual 
command is as follows:

For \fBenter\fR and \fBenterstep\fR operations:
.CS
\fIcommand command-string op\fR
.CE
\fICommand-string\fR gives the complete current command being 
executed (the traced command for a \fBenter\fR operation, an 
arbitrary command for a \fBenterstep\fR operation), including
all arguments in their fully expanded form.
\fIOp\fR indicates what operation is being performed on the
command execution, and is one of \fBenter\fR or \fBenterstep\fR as
defined above.  The trace operation can be used to stop the
command from executing, by deleting the command in question.  Of
course when the command is subsequently executed, an 'invalid command'
error will occur.
.TP
For \fBleave\fR and \fBleavestep\fR operations:
.CS
\fIcommand command-string code result op\fR
.CE
\fICommand-string\fR gives the complete current command being 
executed (the traced command for a \fBenter\fR operation, an 
arbitrary command for a \fBenterstep\fR operation), including
all arguments in their fully expanded form.
\fICode\fR gives the result code of that execution, and \fIresult\fR
the result string.
\fIOp\fR indicates what operation is being performed on the
command execution, and is one of \fBleave\fR or \fBleavestep\fR as
defined above.  
Note that the creation of many \fBenterstep\fR or
\fBleavestep\fR traces can lead to unintuitive results, since the
invoked commands from one trace can themselves lead to further
command invocations for other traces.

\fICommand\fR executes in the same context as the code that invoked
the traced operation: thus the \fIcommand\fR, if invoked from a procedure,
will have access to the same local variables as code in the procedure.
This context may be different than the context in which the trace was
created. If \fIcommand\fR invokes a procedure (which it normally does)
then the procedure will have to use upvar or uplevel commands if it wishes
to access the local variables of the code which invoked the trace operation.

While \fIcommand\fR is executing during an execution trace, traces
on \fIname\fR are temporarily disabled. This allows the \fIcommand\fR
to execute \fIname\fR in its body without invoking any other traces again.
If an error occurs while executing the \fIcommand\fR body, then the
\fIcommand\fR name as a whole will return that same error.

When multiple traces are set on \fIname\fR, then for \fIenter\fR
and \fIenterstep\fR operations, the traced commands are invoked
in the reverse order of how the traces were originally created;
and for \fIleave\fR and \fIleavestep\fR operations, the traced
commands are invoked in the original order of creation.

The behavior of execution traces is currently undefined for a command 
\fIname\fR imported into another namespace.
.RE
.TP
\fBtrace add variable\fI name ops command\fR
d28 1
a28 1
is accessed in one of the ways given by the list \fIops\fR.  \fIName\fR may
d38 2
a39 9
\fIOps\fR indicates which operations are of interest, and is a list of
one or more of the following items:
.TP
\fBarray\fR
Invoke \fIcommand\fR whenever the variable is accessed or modified via
the \fBarray\fR command, provided that \fIname\fR is not a scalar
variable at the time that the \fBarray\fR command is invoked.  If
\fIname\fR is a scalar variable, the access via the \fBarray\fR
command will not trigger the trace.
d41 1
a41 1
\fBread\fR
d44 1
a44 1
\fBwrite\fR
d47 1
a47 1
\fBunset\fR
d73 1
a73 1
variable, and is one of \fBread\fR, \fBwrite\fR, or \fBunset\fR as
d77 28
a104 24
the traced operation:  if the variable was accessed as part of a Tcl
procedure, then \fIcommand\fR will have access to the same local
variables as code in the procedure.  This context may be different
than the context in which the trace was created. If \fIcommand\fR
invokes a procedure (which it normally does) then the procedure will
have to use \fBupvar\fR or \fBuplevel\fR if it wishes to access the
traced variable.  Note also that \fIname1\fR may not necessarily be
the same as the name used to set the trace on the variable;
differences can occur if the access is made through a variable defined
with the \fBupvar\fR command.
.PP
For read and write traces, \fIcommand\fR can modify the variable to
affect the result of the traced operation.  If \fIcommand\fR modifies
the value of a variable during a read or write trace, then the new
value will be returned as the result of the traced operation.  The
return value from  \fIcommand\fR is ignored except that if it returns
an error of any sort then the traced operation also returns an error
with the same error message returned by the trace command (this
mechanism can be used to implement read-only variables, for example).
For write traces, \fIcommand\fR is invoked after the variable's value
has been changed; it can write a new value into the variable to
override the original value specified in the write operation.  To
implement read-only variables, \fIcommand\fR will have to restore the
old value of the variable.
d107 32
a138 26
on the variable are temporarily disabled.  This means that reads and
writes invoked by \fIcommand\fR will occur directly, without invoking
\fIcommand\fR (or any other traces) again.  However, if \fIcommand\fR
unsets the variable then unset traces will be invoked.
.PP
When an unset trace is invoked, the variable has already been deleted:
it will appear to be undefined with no traces.  If an unset occurs
because of a procedure return, then the trace will be invoked in the
variable context of the procedure being returned to:  the stack frame
of the returning procedure will no longer exist.  Traces are not
disabled during unset traces, so if an unset trace command creates a
new trace and accesses the variable, the trace will be invoked.  Any
errors in unset traces are ignored.
.PP
If there are multiple traces on a variable they are invoked in order
of creation, most-recent first.  If one trace returns an error, then
no further traces are invoked for the variable.  If an array element
has a trace set, and there is also a trace set on the array as a
whole, the trace on the overall array is invoked before the one on the
element.
.PP
Once created, the trace remains in effect either until the trace is
removed with the \fBtrace remove variable\fR command described below,
until the variable is unset, or until the interpreter is deleted.
Unsetting an element of array will remove any traces on that element,
but will not remove traces on the overall array.
a141 61
.RE
.TP
\fBtrace remove \fItype name opList command\fR
Where \fItype\fR is either \fBcommand\fR, \fBexecution\fR or \fBvariable\fR.
.RS
.TP
\fBtrace remove command\fI name opList command\fR
If there is a trace set on command \fIname\fR with the operations and
command given by \fIopList\fR and \fIcommand\fR, then the trace is
removed, so that \fIcommand\fR will never again be invoked.  Returns
an empty string.   If \fIname\fR doesn't exist, the command will throw
an error.
.TP
\fBtrace remove execution\fI name opList command\fR
If there is a trace set on command \fIname\fR with the operations and
command given by \fIopList\fR and \fIcommand\fR, then the trace is
removed, so that \fIcommand\fR will never again be invoked.  Returns
an empty string.   If \fIname\fR doesn't exist, the command will throw
an error.
.TP
\fBtrace remove variable\fI name opList command\fR
If there is a trace set on variable \fIname\fR with the operations and
command given by \fIopList\fR and \fIcommand\fR, then the trace is
removed, so that \fIcommand\fR will never again be invoked.  Returns
an empty string.
.RE
.TP
\fBtrace info \fItype name\fR
Where \fItype\fR is either \fBcommand\fR, \fBexecution\fR or \fBvariable\fR.
.RS
.TP
\fBtrace info command\fI name\fR
Returns a list containing one element for each trace currently set on
command \fIname\fR. Each element of the list is itself a list
containing two elements, which are the \fIopList\fR and \fIcommand\fR
associated with the trace.  If \fIname\fR doesn't have any traces set,
then the result of the command will be an empty string.  If \fIname\fR
doesn't exist, the command will throw an error.
.TP
\fBtrace info execution\fI name\fR
Returns a list containing one element for each trace currently set on
command \fIname\fR. Each element of the list is itself a list
containing two elements, which are the \fIopList\fR and \fIcommand\fR
associated with the trace.  If \fIname\fR doesn't have any traces set,
then the result of the command will be an empty string.  If \fIname\fR
doesn't exist, the command will throw an error.
.TP
\fBtrace info variable\fI name\fR
Returns a list containing one element for each trace currently set on
variable \fIname\fR.  Each element of the list is itself a list
containing two elements, which are the \fIopList\fR and \fIcommand\fR
associated with the trace.  If \fIname\fR doesn't exist or doesn't
have any traces set, then the result of the command will be an empty
string.
.RE
.PP
For backwards compatibility, three other subcommands are available:
.RS
.TP
\fBtrace variable \fIname ops command\fR
This is equivalent to \fBtrace add variable \fIname ops command\fR.
d144 14
a157 15
This is equivalent to \fBtrace remove variable \fIname ops command\fR
.TP 
\fBtrace vinfo \fIname\fR 
This is equivalent to \fBtrace info variable \fIname\fR
.RE
.PP
These subcommands are deprecated and will likely be removed in a
future version of Tcl.  They use an older syntax in which \fBarray\fR,
\fBread\fR, \fBwrite\fR, \fBunset\fR are replaced by \fBa\fR, \fBr\fR,
\fBw\fR and \fBu\fR respectively, and the \fIops\fR argument is not a
list, but simply a string concatenation of the operations, such as
\fBrwua\fR.

.SH "SEE ALSO"
set(n), unset(n)
d160 1
a160 1
read, command, rename, variable, write, trace, unset
@


1.1
log
@Initial revision
@
text
@d8 1
a8 1
'\" RCS: @@(#) $Id: trace.n,v 1.12 1999/01/26 03:53:07 jingham Exp $
d33 3
a35 1
manipulated.
@


1.1.1.1
log
@import dejagnu-1999-11-08 snapshot
@
text
@@


1.1.1.2
log
@Tcl 8.3 upgrade
@
text
@d8 1
a8 1
'\" RCS: @@(#) $Id: trace.n,v 1.6.8.1 2000/04/06 22:38:27 spolk Exp $
d33 1
a33 3
manipulated.  If the variable does not exist, it will be created but
will not be given a value, so it will be visible to \fBnamespace which\fR
queries, but not to \fBinfo exists\fR queries.
@


1.1.1.3
log
@import tcl 8.4.0
@
text
@a3 1
'\" Copyright (c) 2000 Ajuba Solutions.
d8 1
a8 1
'\" RCS: @@(#) $Id: trace.n,v 1.11 2002/07/16 22:27:35 dgp Exp $
d11 1
a11 1
.TH trace n "8.4" Tcl "Tcl Built-In Commands"
d15 1
a15 1
trace \- Monitor variable accesses, command usages and command executions
d23 2
a24 1
invoked.  The legal \fIoption\fR's (which may be abbreviated) are:
d26 1
a26 141
\fBtrace add \fItype name ops ?args?\fR
Where \fItype\fR is \fBcommand\fR, \fBexecution\fR, or \fBvariable\fR.
.RS
.TP
\fBtrace add command\fR \fIname ops command\fR
Arrange for \fIcommand\fR to be executed whenever command \fIname\fR
is modified in one of the ways given by the list \fIops\fR.  \fIName\fR will be
resolved using the usual namespace resolution rules used by
procedures.  If the command does not exist, an error will be thrown.
.RS
.PP
\fIOps\fR indicates which operations are of interest, and is a list of
one or more of the following items:
.TP
\fBrename\fR
Invoke \fIcommand\fR whenever the command is renamed.  Note that
renaming to the empty string is considered deletion, and will not
be traced with '\fBrename\fR'.
.TP
\fBdelete\fR
Invoke \fIcommand\fR when the command is deleted.  Commands can be
deleted explicitly by using the \fBrename\fR command to rename the
command to an empty string.  Commands are also deleted when the
interpreter is deleted, but traces will not be invoked because there is no
interpreter in which to execute them.
.PP
When the trace triggers, depending on the operations being traced, a 
number of arguments are appended to \fIcommand\fR so that the actual 
command is as follows:
.CS
\fIcommand oldName newName op\fR
.CE
\fIOldName\fR and \fInewName\fR give the traced command's current
(old) name, and the name to which it is being renamed (the empty
string if this is a 'delete' operation).
\fIOp\fR indicates what operation is being performed on the
command, and is one of \fBrename\fR or \fBdelete\fR as
defined above.  The trace operation cannot be used to stop a command
from being deleted.  Tcl will always remove the command once the trace
is complete.  Recursive renaming or deleting will not cause further traces 
of the same type to be evaluated, so a delete trace which itself
deletes the command, or a rename trace which itself renames the
command will not cause further trace evaluations to occur.
.RE
.TP
\fBtrace add execution\fR \fIname ops command\fR
Arrange for \fIcommand\fR to be executed whenever command \fIname\fR
is modified in one of the ways given by the list \fIops\fR.  \fIName\fR will be
resolved using the usual namespace resolution rules used by
procedures.  If the command does not exist, an error will be thrown.
.RS
.PP
\fIOps\fR indicates which operations are of interest, and is a list of
one or more of the following items:
.TP
\fBenter\fR
Invoke \fIcommand\fR whenever the command \fIname\fR is executed,
just before the actual execution takes place.
.TP
\fBleave\fR
Invoke \fIcommand\fR whenever the command \fIname\fR is executed,
just after the actual execution takes place.
.TP
\fBenterstep\fR
Invoke \fIcommand\fR for every tcl command which is executed 
inside the procedure \fIname\fR, just before the actual execution
takes place.  For example if we have 'proc foo {} { puts "hello" }',
then a \fIenterstep\fR trace would be 
invoked just before \fIputs "hello"\fR is executed.
Setting a \fIenterstep\fR trace on a \fIcommand\fR
will not result in an error and is simply ignored.
.TP
\fBleavestep\fR
Invoke \fIcommand\fR for every tcl command which is executed 
inside the procedure \fIname\fR, just after the actual execution
takes place.
Setting a \fIleavestep\fR trace on a \fIcommand\fR
will not result in an error and is simply ignored.
.PP
When the trace triggers, depending on the operations being traced, a 
number of arguments are appended to \fIcommand\fR so that the actual 
command is as follows:

For \fBenter\fR and \fBenterstep\fR operations:
.CS
\fIcommand command-string op\fR
.CE
\fICommand-string\fR gives the complete current command being 
executed (the traced command for a \fBenter\fR operation, an 
arbitrary command for a \fBenterstep\fR operation), including
all arguments in their fully expanded form.
\fIOp\fR indicates what operation is being performed on the
command execution, and is one of \fBenter\fR or \fBenterstep\fR as
defined above.  The trace operation can be used to stop the
command from executing, by deleting the command in question.  Of
course when the command is subsequently executed, an 'invalid command'
error will occur.
.TP
For \fBleave\fR and \fBleavestep\fR operations:
.CS
\fIcommand command-string code result op\fR
.CE
\fICommand-string\fR gives the complete current command being 
executed (the traced command for a \fBenter\fR operation, an 
arbitrary command for a \fBenterstep\fR operation), including
all arguments in their fully expanded form.
\fICode\fR gives the result code of that execution, and \fIresult\fR
the result string.
\fIOp\fR indicates what operation is being performed on the
command execution, and is one of \fBleave\fR or \fBleavestep\fR as
defined above.  
Note that the creation of many \fBenterstep\fR or
\fBleavestep\fR traces can lead to unintuitive results, since the
invoked commands from one trace can themselves lead to further
command invocations for other traces.

\fICommand\fR executes in the same context as the code that invoked
the traced operation: thus the \fIcommand\fR, if invoked from a procedure,
will have access to the same local variables as code in the procedure.
This context may be different than the context in which the trace was
created. If \fIcommand\fR invokes a procedure (which it normally does)
then the procedure will have to use upvar or uplevel commands if it wishes
to access the local variables of the code which invoked the trace operation.

While \fIcommand\fR is executing during an execution trace, traces
on \fIname\fR are temporarily disabled. This allows the \fIcommand\fR
to execute \fIname\fR in its body without invoking any other traces again.
If an error occurs while executing the \fIcommand\fR body, then the
\fIcommand\fR name as a whole will return that same error.

When multiple traces are set on \fIname\fR, then for \fIenter\fR
and \fIenterstep\fR operations, the traced commands are invoked
in the reverse order of how the traces were originally created;
and for \fIleave\fR and \fIleavestep\fR operations, the traced
commands are invoked in the original order of creation.

The behavior of execution traces is currently undefined for a command 
\fIname\fR imported into another namespace.
.RE
.TP
\fBtrace add variable\fI name ops command\fR
d28 1
a28 1
is accessed in one of the ways given by the list \fIops\fR.  \fIName\fR may
d38 2
a39 9
\fIOps\fR indicates which operations are of interest, and is a list of
one or more of the following items:
.TP
\fBarray\fR
Invoke \fIcommand\fR whenever the variable is accessed or modified via
the \fBarray\fR command, provided that \fIname\fR is not a scalar
variable at the time that the \fBarray\fR command is invoked.  If
\fIname\fR is a scalar variable, the access via the \fBarray\fR
command will not trigger the trace.
d41 1
a41 1
\fBread\fR
d44 1
a44 1
\fBwrite\fR
d47 1
a47 1
\fBunset\fR
d73 1
a73 1
variable, and is one of \fBread\fR, \fBwrite\fR, or \fBunset\fR as
d77 28
a104 24
the traced operation:  if the variable was accessed as part of a Tcl
procedure, then \fIcommand\fR will have access to the same local
variables as code in the procedure.  This context may be different
than the context in which the trace was created. If \fIcommand\fR
invokes a procedure (which it normally does) then the procedure will
have to use \fBupvar\fR or \fBuplevel\fR if it wishes to access the
traced variable.  Note also that \fIname1\fR may not necessarily be
the same as the name used to set the trace on the variable;
differences can occur if the access is made through a variable defined
with the \fBupvar\fR command.
.PP
For read and write traces, \fIcommand\fR can modify the variable to
affect the result of the traced operation.  If \fIcommand\fR modifies
the value of a variable during a read or write trace, then the new
value will be returned as the result of the traced operation.  The
return value from  \fIcommand\fR is ignored except that if it returns
an error of any sort then the traced operation also returns an error
with the same error message returned by the trace command (this
mechanism can be used to implement read-only variables, for example).
For write traces, \fIcommand\fR is invoked after the variable's value
has been changed; it can write a new value into the variable to
override the original value specified in the write operation.  To
implement read-only variables, \fIcommand\fR will have to restore the
old value of the variable.
d107 32
a138 26
on the variable are temporarily disabled.  This means that reads and
writes invoked by \fIcommand\fR will occur directly, without invoking
\fIcommand\fR (or any other traces) again.  However, if \fIcommand\fR
unsets the variable then unset traces will be invoked.
.PP
When an unset trace is invoked, the variable has already been deleted:
it will appear to be undefined with no traces.  If an unset occurs
because of a procedure return, then the trace will be invoked in the
variable context of the procedure being returned to:  the stack frame
of the returning procedure will no longer exist.  Traces are not
disabled during unset traces, so if an unset trace command creates a
new trace and accesses the variable, the trace will be invoked.  Any
errors in unset traces are ignored.
.PP
If there are multiple traces on a variable they are invoked in order
of creation, most-recent first.  If one trace returns an error, then
no further traces are invoked for the variable.  If an array element
has a trace set, and there is also a trace set on the array as a
whole, the trace on the overall array is invoked before the one on the
element.
.PP
Once created, the trace remains in effect either until the trace is
removed with the \fBtrace remove variable\fR command described below,
until the variable is unset, or until the interpreter is deleted.
Unsetting an element of array will remove any traces on that element,
but will not remove traces on the overall array.
a141 61
.RE
.TP
\fBtrace remove \fItype name opList command\fR
Where \fItype\fR is either \fBcommand\fR, \fBexecution\fR or \fBvariable\fR.
.RS
.TP
\fBtrace remove command\fI name opList command\fR
If there is a trace set on command \fIname\fR with the operations and
command given by \fIopList\fR and \fIcommand\fR, then the trace is
removed, so that \fIcommand\fR will never again be invoked.  Returns
an empty string.   If \fIname\fR doesn't exist, the command will throw
an error.
.TP
\fBtrace remove execution\fI name opList command\fR
If there is a trace set on command \fIname\fR with the operations and
command given by \fIopList\fR and \fIcommand\fR, then the trace is
removed, so that \fIcommand\fR will never again be invoked.  Returns
an empty string.   If \fIname\fR doesn't exist, the command will throw
an error.
.TP
\fBtrace remove variable\fI name opList command\fR
If there is a trace set on variable \fIname\fR with the operations and
command given by \fIopList\fR and \fIcommand\fR, then the trace is
removed, so that \fIcommand\fR will never again be invoked.  Returns
an empty string.
.RE
.TP
\fBtrace info \fItype name\fR
Where \fItype\fR is either \fBcommand\fR, \fBexecution\fR or \fBvariable\fR.
.RS
.TP
\fBtrace info command\fI name\fR
Returns a list containing one element for each trace currently set on
command \fIname\fR. Each element of the list is itself a list
containing two elements, which are the \fIopList\fR and \fIcommand\fR
associated with the trace.  If \fIname\fR doesn't have any traces set,
then the result of the command will be an empty string.  If \fIname\fR
doesn't exist, the command will throw an error.
.TP
\fBtrace info execution\fI name\fR
Returns a list containing one element for each trace currently set on
command \fIname\fR. Each element of the list is itself a list
containing two elements, which are the \fIopList\fR and \fIcommand\fR
associated with the trace.  If \fIname\fR doesn't have any traces set,
then the result of the command will be an empty string.  If \fIname\fR
doesn't exist, the command will throw an error.
.TP
\fBtrace info variable\fI name\fR
Returns a list containing one element for each trace currently set on
variable \fIname\fR.  Each element of the list is itself a list
containing two elements, which are the \fIopList\fR and \fIcommand\fR
associated with the trace.  If \fIname\fR doesn't exist or doesn't
have any traces set, then the result of the command will be an empty
string.
.RE
.PP
For backwards compatibility, three other subcommands are available:
.RS
.TP
\fBtrace variable \fIname ops command\fR
This is equivalent to \fBtrace add variable \fIname ops command\fR.
d144 14
a157 15
This is equivalent to \fBtrace remove variable \fIname ops command\fR
.TP 
\fBtrace vinfo \fIname\fR 
This is equivalent to \fBtrace info variable \fIname\fR
.RE
.PP
These subcommands are deprecated and will likely be removed in a
future version of Tcl.  They use an older syntax in which \fBarray\fR,
\fBread\fR, \fBwrite\fR, \fBunset\fR are replaced by \fBa\fR, \fBr\fR,
\fBw\fR and \fBu\fR respectively, and the \fIops\fR argument is not a
list, but simply a string concatenation of the operations, such as
\fBrwua\fR.

.SH "SEE ALSO"
set(n), unset(n)
d160 1
a160 1
read, command, rename, variable, write, trace, unset
@


