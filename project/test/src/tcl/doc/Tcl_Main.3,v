head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.58
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.56
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.54
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.52
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.50
	gdb_7_0-branch:1.5.0.48
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tcl8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.46
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.44
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.42
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.40
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.38
	gdb_6_5-2006-05-14-branchpoint:1.5
	readline_5_1-import-branch:1.5.0.36
	readline_5_1-import-branchpoint:1.5
	gdb_6_4-branch:1.5.0.34
	gdb_6_4-2005-11-01-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.32
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	ezannoni_pie-20040323-branch:1.5.0.30
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.28
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.26
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.24
	cagney_x86i386-20030821-branch:1.5.0.22
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.20
	gdb_6_0-2003-06-23-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.18
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.16
	cagney_writestrings-20030508-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.14
	cagney_fileio-20030521-branchpoint:1.5
	carlton_dictionary-20030430-merge:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.12
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.10
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.8
	cagney_lazyid-20030317-branchpoint:1.5
	offbyone-20030313-branch:1.5.0.6
	offbyone-20030313-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.4
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.2
	interps-20030202-branchpoint:1.5
	TCL8_4_1:1.1.1.3
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.2
	TCL_8_4_1:1.1.1.3
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.4
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TCL_8_4_0:1.1.1.3
	carlton_dictionary-branch:1.2.0.16
	carlton_dictionary-20020920-branchpoint:1.2
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.14
	gdb_5_3-branch:1.2.0.12
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.10
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.8
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.6
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TCL_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	dejagnu-2000-02-04:1.1.1.1
	dejagnu-2000-01-31:1.1.1.1
	dejagnu-2000-01-24:1.1.1.1
	dejagnu-2000-01-17:1.1.1.1
	dejagnu-2000-01-10:1.1.1.1
	dejagnu-2000-01-04:1.1.1.1
	dejagnu-1999-12-21:1.1.1.1
	dejagnu-1999-12-13:1.1.1.1
	dejagnu-1999-12-07:1.1.1.1
	dejagnu-1999-12-06:1.1.1.1
	dejagnu-1999-11-15:1.1.1.1
	dejagnu-1999-11-08:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@.\" @;
expand	@o@;


1.5
date	2003.01.21.19.39.59;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.26.19.47.50;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.37.01;	author kseitz;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2001.09.09.23.56.04;	author irox;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	99.11.09.01.28.43;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2002.09.27.21.49.01;	author kseitz;	state Exp;
branches;
next	;

1.3.4.1
date	2003.12.14.20.28.41;	author drow;	state Exp;
branches;
next	;

1.2.16.1
date	2002.12.23.19.40.09;	author carlton;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2003.02.07.19.18.08;	author carlton;	state Exp;
branches;
next	;

1.1.1.1
date	99.11.09.01.28.43;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.09.22.40.53;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.19.56.28;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tcl 8.4.1
@
text
@'\"
'\" Copyright (c) 1994 The Regents of the University of California.
'\" Copyright (c) 1994-1996 Sun Microsystems, Inc.
'\" Copyright (c) 2000 Ajuba Solutions.
'\"
'\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\" 
'\" RCS: @@(#) $Id: Tcl_Main.3,v 1.9 2002/07/01 18:24:39 jenglish Exp $
'\" 
.so man.macros
.TH Tcl_Main 3 8.4 Tcl "Tcl Library Procedures"
.BS
.SH NAME
Tcl_Main, Tcl_SetMainLoop \- main program and event loop definition for Tcl-based applications
.SH SYNOPSIS
.nf
\fB#include <tcl.h>\fR
.sp
\fBTcl_Main\fR(\fIargc, argv, appInitProc\fR)
.sp
\fBTcl_SetMainLoop\fR(\fImainLoopProc\fR)
.SH ARGUMENTS
.AS Tcl_AppInitProc *appInitProc
.AP int argc in
Number of elements in \fIargv\fR.
.AP char *argv[] in
Array of strings containing command-line arguments.
.AP Tcl_AppInitProc *appInitProc in
Address of an application-specific initialization procedure.
The value for this argument is usually \fBTcl_AppInit\fR.
.AP Tcl_MainLoopProc *mainLoopProc in
Address of an application-specific event loop procedure.
.BE

.SH DESCRIPTION
.PP
\fBTcl_Main\fR can serve as the main program for Tcl-based shell
applications.  A ``shell application'' is a program
like tclsh or wish that supports both interactive interpretation
of Tcl and evaluation of a script contained in a file given as
a command line argument.  \fBTcl_Main\fR is offered as a convenience
to developers of shell applications, so they do not have to 
reproduce all of the code for proper initialization of the Tcl
library and interactive shell operation.  Other styles of embedding
Tcl in an application are not supported by \fBTcl_Main\fR.  Those
must be achieved by calling lower level functions in the Tcl library
directly.

The \fBTcl_Main\fR function has been offered by the Tcl library
since release Tcl 7.4.  In older releases of Tcl, the Tcl library
itself defined a function \fBmain\fR, but that lacks flexibility
of embedding style and having a function \fBmain\fR in a library
(particularly a shared library) causes problems on many systems.
Having \fBmain\fR in the Tcl library would also make it hard to use
Tcl in C++ programs, since C++ programs must have special C++
\fBmain\fR functions.
.PP
Normally each shell application contains a small \fBmain\fR function
that does nothing but invoke \fBTcl_Main\fR.
\fBTcl_Main\fR then does all the work of creating and running a
\fBtclsh\fR-like application.
.PP
\fBTcl_Main\fR is not provided by the public interface of Tcl's
stub library.  Programs that call \fBTcl_Main\fR must be linked
against the standard Tcl library.  Extensions (stub-enabled or
not) are not intended to call \fBTcl_Main\fR.
.PP
\fBTcl_Main\fR is not thread-safe.  It should only be called by
a single master thread of a multi-threaded application.  This
restriction is not a problem with normal use described above.
.PP
\fBTcl_Main\fR and therefore all applications based upon it, like
\fBtclsh\fR, use \fBTcl_GetStdChannel\fR to initialize the standard
channels to their default values. See \fBTcl_StandardChannels\fR for
more information.
.PP
\fBTcl_Main\fR supports two modes of operation, depending on the
values of \fIargc\fR and \fIargv\fR.  If \fIargv[1]\fR exists and
does not begin with the character \fI-\fR, it is taken to be the
name of a file containing a \fIstartup script\fR, which \fBTcl_Main\fR
will attempt to evaluate.  Otherwise, \fBTcl_Main\fR will enter an
interactive mode.
.PP
In either mode, \fBTcl_Main\fR will define in its master interpreter
the Tcl variables \fIargc\fR, \fIargv\fR, \fIargv0\fR, and
\fItcl_interactive\fR, as described in the documentation for \fBtclsh\fR.
.PP
When it has finished its own initialization, but before it processes
commands, \fBTcl_Main\fR calls the procedure given by the
\fIappInitProc\fR argument.  This procedure provides a ``hook'' for
the application to perform its own initialization of the interpreter
created by \fBTcl_Main\fR, such as defining application-specific
commands.  The procedure must have an interface that matches the
type \fBTcl_AppInitProc\fR:
.CS
typedef int Tcl_AppInitProc(Tcl_Interp *\fIinterp\fR);
.CE

\fIAppInitProc\fR is almost always a pointer to \fBTcl_AppInit\fR; for more
details on this procedure, see the documentation for \fBTcl_AppInit\fR.
.PP
When the \fIappInitProc\fR is finished, \fBTcl_Main\fR enters one
of its two modes.  If a startup script has been provided, \fBTcl_Main\fR
attempts to evaluate it.  Otherwise, interactive mode begins with
examination of the variable \fItcl_rcFileName\fR in the master
interpreter.  If that variable exists and holds the name of a readable
file, the contents of that file are evaluated in the master interpreter.
Then interactive operations begin,
with prompts and command evaluation results written to the standard
output channel, and commands read from the standard input channel
and then evaluated.  The prompts written to the standard output
channel may be customized by defining the Tcl variables \fItcl_prompt1\fR
and \fItcl_prompt2\fR as described in the documentation for \fBtclsh\fR.
The prompts and command evaluation results are written to the standard
output channel only if the Tcl variable \fItcl_interactive\fR in the
master interpreter holds a non-zero integer value.
.PP
.VS 8.4
\fBTcl_SetMainLoop\fR allows setting an event loop procedure to be run.
This allows, for example, Tk to be dynamically loaded and set its event
loop.  The event loop will run following the startup script.  If you
are in interactive mode, setting the main loop procedure will cause the
prompt to become fileevent based and then the loop procedure is called.
When the loop procedure returns in interactive mode, interactive operation
will continue.
The main loop procedure must have an interface that matches the type
\fBTcl_MainLoopProc\fR:
.CS
typedef void Tcl_MainLoopProc(void);
.CE
.VE 8.4
.PP
\fBTcl_Main\fR does not return.  Normally a program based on
\fBTcl_Main\fR will terminate when the \fBexit\fR command is
evaluated.  In interactive mode, if an EOF or channel error
is encountered on the standard input channel, then \fBTcl_Main\fR
itself will evaluate the \fBexit\fR command after the main loop
procedure (if any) returns.  In non-interactive mode, after
\fBTcl_Main\fR evaluates the startup script, and the main loop
procedure (if any) returns, \fBTcl_Main\fR will also evaluate
the \fBexit\fR command.

.SH "SEE ALSO"
tclsh(1), Tcl_GetStdChannel(3), Tcl_StandardChannels(3), Tcl_AppInit(3),
exit(n)

.SH KEYWORDS
application-specific initialization, command-line arguments, main program
@


1.4
log
@touched all sources to ease next import
@
text
@d4 1
d9 1
a9 1
'\" RCS: @@(#) $Id: Tcl_Main.3,v 1.6.8.1 2000/04/06 22:38:26 spolk Exp $
d12 1
a12 1
.TH Tcl_Main 3 7.4 Tcl "Tcl Library Procedures"
d15 1
a15 1
Tcl_Main \- main program for Tcl-based applications
d21 2
d32 2
d38 17
a54 5
\fBTcl_Main\fR acts as the main program for most Tcl-based applications.
Starting with Tcl 7.4 it is not called \fBmain\fR anymore because it 
is part of the Tcl library and having a function \fBmain\fR
in a library (particularly a shared library) causes problems on many
systems.
d59 2
a60 2
Normally each application contains a small \fBmain\fR function that does
nothing but invoke \fBTcl_Main\fR.
d64 32
a95 6
When it is has finished its own initialization, but before
it processes commands, \fBTcl_Main\fR calls the procedure given by
the \fIappInitProc\fR argument.  This procedure provides a ``hook''
for the application to perform its own initialization, such as defining
application-specific commands.  The procedure must have an interface
that matches the type \fBTcl_AppInitProc\fR:
d99 48
a146 3
\fIAppInitProc\fR is almost always a pointer to \fBTcl_AppInit\fR;
for more details on this procedure, see the documentation
for \fBTcl_AppInit\fR.
@


1.3
log
@touched all sources to ease next import
@
text
@@


1.3.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@a3 1
'\" Copyright (c) 2000 Ajuba Solutions.
d8 1
a8 1
'\" RCS: @@(#) $Id: Tcl_Main.3,v 1.9 2002/07/01 18:24:39 jenglish Exp $
d11 1
a11 1
.TH Tcl_Main 3 8.4 Tcl "Tcl Library Procedures"
d14 1
a14 1
Tcl_Main, Tcl_SetMainLoop \- main program and event loop definition for Tcl-based applications
a19 2
.sp
\fBTcl_SetMainLoop\fR(\fImainLoopProc\fR)
a28 2
.AP Tcl_MainLoopProc *mainLoopProc in
Address of an application-specific event loop procedure.
d33 5
a37 17
\fBTcl_Main\fR can serve as the main program for Tcl-based shell
applications.  A ``shell application'' is a program
like tclsh or wish that supports both interactive interpretation
of Tcl and evaluation of a script contained in a file given as
a command line argument.  \fBTcl_Main\fR is offered as a convenience
to developers of shell applications, so they do not have to 
reproduce all of the code for proper initialization of the Tcl
library and interactive shell operation.  Other styles of embedding
Tcl in an application are not supported by \fBTcl_Main\fR.  Those
must be achieved by calling lower level functions in the Tcl library
directly.

The \fBTcl_Main\fR function has been offered by the Tcl library
since release Tcl 7.4.  In older releases of Tcl, the Tcl library
itself defined a function \fBmain\fR, but that lacks flexibility
of embedding style and having a function \fBmain\fR in a library
(particularly a shared library) causes problems on many systems.
d42 2
a43 2
Normally each shell application contains a small \fBmain\fR function
that does nothing but invoke \fBTcl_Main\fR.
d47 6
a52 32
\fBTcl_Main\fR is not provided by the public interface of Tcl's
stub library.  Programs that call \fBTcl_Main\fR must be linked
against the standard Tcl library.  Extensions (stub-enabled or
not) are not intended to call \fBTcl_Main\fR.
.PP
\fBTcl_Main\fR is not thread-safe.  It should only be called by
a single master thread of a multi-threaded application.  This
restriction is not a problem with normal use described above.
.PP
\fBTcl_Main\fR and therefore all applications based upon it, like
\fBtclsh\fR, use \fBTcl_GetStdChannel\fR to initialize the standard
channels to their default values. See \fBTcl_StandardChannels\fR for
more information.
.PP
\fBTcl_Main\fR supports two modes of operation, depending on the
values of \fIargc\fR and \fIargv\fR.  If \fIargv[1]\fR exists and
does not begin with the character \fI-\fR, it is taken to be the
name of a file containing a \fIstartup script\fR, which \fBTcl_Main\fR
will attempt to evaluate.  Otherwise, \fBTcl_Main\fR will enter an
interactive mode.
.PP
In either mode, \fBTcl_Main\fR will define in its master interpreter
the Tcl variables \fIargc\fR, \fIargv\fR, \fIargv0\fR, and
\fItcl_interactive\fR, as described in the documentation for \fBtclsh\fR.
.PP
When it has finished its own initialization, but before it processes
commands, \fBTcl_Main\fR calls the procedure given by the
\fIappInitProc\fR argument.  This procedure provides a ``hook'' for
the application to perform its own initialization of the interpreter
created by \fBTcl_Main\fR, such as defining application-specific
commands.  The procedure must have an interface that matches the
type \fBTcl_AppInitProc\fR:
d56 3
a58 48

\fIAppInitProc\fR is almost always a pointer to \fBTcl_AppInit\fR; for more
details on this procedure, see the documentation for \fBTcl_AppInit\fR.
.PP
When the \fIappInitProc\fR is finished, \fBTcl_Main\fR enters one
of its two modes.  If a startup script has been provided, \fBTcl_Main\fR
attempts to evaluate it.  Otherwise, interactive mode begins with
examination of the variable \fItcl_rcFileName\fR in the master
interpreter.  If that variable exists and holds the name of a readable
file, the contents of that file are evaluated in the master interpreter.
Then interactive operations begin,
with prompts and command evaluation results written to the standard
output channel, and commands read from the standard input channel
and then evaluated.  The prompts written to the standard output
channel may be customized by defining the Tcl variables \fItcl_prompt1\fR
and \fItcl_prompt2\fR as described in the documentation for \fBtclsh\fR.
The prompts and command evaluation results are written to the standard
output channel only if the Tcl variable \fItcl_interactive\fR in the
master interpreter holds a non-zero integer value.
.PP
.VS 8.4
\fBTcl_SetMainLoop\fR allows setting an event loop procedure to be run.
This allows, for example, Tk to be dynamically loaded and set its event
loop.  The event loop will run following the startup script.  If you
are in interactive mode, setting the main loop procedure will cause the
prompt to become fileevent based and then the loop procedure is called.
When the loop procedure returns in interactive mode, interactive operation
will continue.
The main loop procedure must have an interface that matches the type
\fBTcl_MainLoopProc\fR:
.CS
typedef void Tcl_MainLoopProc(void);
.CE
.VE 8.4
.PP
\fBTcl_Main\fR does not return.  Normally a program based on
\fBTcl_Main\fR will terminate when the \fBexit\fR command is
evaluated.  In interactive mode, if an EOF or channel error
is encountered on the standard input channel, then \fBTcl_Main\fR
itself will evaluate the \fBexit\fR command after the main loop
procedure (if any) returns.  In non-interactive mode, after
\fBTcl_Main\fR evaluates the startup script, and the main loop
procedure (if any) returns, \fBTcl_Main\fR will also evaluate
the \fBexit\fR command.

.SH "SEE ALSO"
tclsh(1), Tcl_GetStdChannel(3), Tcl_StandardChannels(3), Tcl_AppInit(3),
exit(n)
@


1.3.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@a3 1
'\" Copyright (c) 2000 Ajuba Solutions.
d8 1
a8 1
'\" RCS: @@(#) $Id: Tcl_Main.3,v 1.9 2002/07/01 18:24:39 jenglish Exp $
d11 1
a11 1
.TH Tcl_Main 3 8.4 Tcl "Tcl Library Procedures"
d14 1
a14 1
Tcl_Main, Tcl_SetMainLoop \- main program and event loop definition for Tcl-based applications
a19 2
.sp
\fBTcl_SetMainLoop\fR(\fImainLoopProc\fR)
a28 2
.AP Tcl_MainLoopProc *mainLoopProc in
Address of an application-specific event loop procedure.
d33 5
a37 17
\fBTcl_Main\fR can serve as the main program for Tcl-based shell
applications.  A ``shell application'' is a program
like tclsh or wish that supports both interactive interpretation
of Tcl and evaluation of a script contained in a file given as
a command line argument.  \fBTcl_Main\fR is offered as a convenience
to developers of shell applications, so they do not have to 
reproduce all of the code for proper initialization of the Tcl
library and interactive shell operation.  Other styles of embedding
Tcl in an application are not supported by \fBTcl_Main\fR.  Those
must be achieved by calling lower level functions in the Tcl library
directly.

The \fBTcl_Main\fR function has been offered by the Tcl library
since release Tcl 7.4.  In older releases of Tcl, the Tcl library
itself defined a function \fBmain\fR, but that lacks flexibility
of embedding style and having a function \fBmain\fR in a library
(particularly a shared library) causes problems on many systems.
d42 2
a43 2
Normally each shell application contains a small \fBmain\fR function
that does nothing but invoke \fBTcl_Main\fR.
d47 6
a52 32
\fBTcl_Main\fR is not provided by the public interface of Tcl's
stub library.  Programs that call \fBTcl_Main\fR must be linked
against the standard Tcl library.  Extensions (stub-enabled or
not) are not intended to call \fBTcl_Main\fR.
.PP
\fBTcl_Main\fR is not thread-safe.  It should only be called by
a single master thread of a multi-threaded application.  This
restriction is not a problem with normal use described above.
.PP
\fBTcl_Main\fR and therefore all applications based upon it, like
\fBtclsh\fR, use \fBTcl_GetStdChannel\fR to initialize the standard
channels to their default values. See \fBTcl_StandardChannels\fR for
more information.
.PP
\fBTcl_Main\fR supports two modes of operation, depending on the
values of \fIargc\fR and \fIargv\fR.  If \fIargv[1]\fR exists and
does not begin with the character \fI-\fR, it is taken to be the
name of a file containing a \fIstartup script\fR, which \fBTcl_Main\fR
will attempt to evaluate.  Otherwise, \fBTcl_Main\fR will enter an
interactive mode.
.PP
In either mode, \fBTcl_Main\fR will define in its master interpreter
the Tcl variables \fIargc\fR, \fIargv\fR, \fIargv0\fR, and
\fItcl_interactive\fR, as described in the documentation for \fBtclsh\fR.
.PP
When it has finished its own initialization, but before it processes
commands, \fBTcl_Main\fR calls the procedure given by the
\fIappInitProc\fR argument.  This procedure provides a ``hook'' for
the application to perform its own initialization of the interpreter
created by \fBTcl_Main\fR, such as defining application-specific
commands.  The procedure must have an interface that matches the
type \fBTcl_AppInitProc\fR:
d56 3
a58 48

\fIAppInitProc\fR is almost always a pointer to \fBTcl_AppInit\fR; for more
details on this procedure, see the documentation for \fBTcl_AppInit\fR.
.PP
When the \fIappInitProc\fR is finished, \fBTcl_Main\fR enters one
of its two modes.  If a startup script has been provided, \fBTcl_Main\fR
attempts to evaluate it.  Otherwise, interactive mode begins with
examination of the variable \fItcl_rcFileName\fR in the master
interpreter.  If that variable exists and holds the name of a readable
file, the contents of that file are evaluated in the master interpreter.
Then interactive operations begin,
with prompts and command evaluation results written to the standard
output channel, and commands read from the standard input channel
and then evaluated.  The prompts written to the standard output
channel may be customized by defining the Tcl variables \fItcl_prompt1\fR
and \fItcl_prompt2\fR as described in the documentation for \fBtclsh\fR.
The prompts and command evaluation results are written to the standard
output channel only if the Tcl variable \fItcl_interactive\fR in the
master interpreter holds a non-zero integer value.
.PP
.VS 8.4
\fBTcl_SetMainLoop\fR allows setting an event loop procedure to be run.
This allows, for example, Tk to be dynamically loaded and set its event
loop.  The event loop will run following the startup script.  If you
are in interactive mode, setting the main loop procedure will cause the
prompt to become fileevent based and then the loop procedure is called.
When the loop procedure returns in interactive mode, interactive operation
will continue.
The main loop procedure must have an interface that matches the type
\fBTcl_MainLoopProc\fR:
.CS
typedef void Tcl_MainLoopProc(void);
.CE
.VE 8.4
.PP
\fBTcl_Main\fR does not return.  Normally a program based on
\fBTcl_Main\fR will terminate when the \fBexit\fR command is
evaluated.  In interactive mode, if an EOF or channel error
is encountered on the standard input channel, then \fBTcl_Main\fR
itself will evaluate the \fBexit\fR command after the main loop
procedure (if any) returns.  In non-interactive mode, after
\fBTcl_Main\fR evaluates the startup script, and the main loop
procedure (if any) returns, \fBTcl_Main\fR will also evaluate
the \fBexit\fR command.

.SH "SEE ALSO"
tclsh(1), Tcl_GetStdChannel(3), Tcl_StandardChannels(3), Tcl_AppInit(3),
exit(n)
@


1.2
log
@touched all Tcl files to ease next import.
@
text
@@


1.2.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.2.16.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@a3 1
'\" Copyright (c) 2000 Ajuba Solutions.
d11 1
a11 1
.TH Tcl_Main 3 8.4 Tcl "Tcl Library Procedures"
d14 1
a14 1
Tcl_Main, Tcl_SetMainLoop \- main program and event loop definition for Tcl-based applications
a19 2
.sp
\fBTcl_SetMainLoop\fR(\fImainLoopProc\fR)
a28 2
.AP Tcl_MainLoopProc *mainLoopProc in
Address of an application-specific event loop procedure.
d33 5
a37 17
\fBTcl_Main\fR can serve as the main program for Tcl-based shell
applications.  A ``shell application'' is a program
like tclsh or wish that supports both interactive interpretation
of Tcl and evaluation of a script contained in a file given as
a command line argument.  \fBTcl_Main\fR is offered as a convenience
to developers of shell applications, so they do not have to 
reproduce all of the code for proper initialization of the Tcl
library and interactive shell operation.  Other styles of embedding
Tcl in an application are not supported by \fBTcl_Main\fR.  Those
must be achieved by calling lower level functions in the Tcl library
directly.

The \fBTcl_Main\fR function has been offered by the Tcl library
since release Tcl 7.4.  In older releases of Tcl, the Tcl library
itself defined a function \fBmain\fR, but that lacks flexibility
of embedding style and having a function \fBmain\fR in a library
(particularly a shared library) causes problems on many systems.
d42 2
a43 2
Normally each shell application contains a small \fBmain\fR function
that does nothing but invoke \fBTcl_Main\fR.
d47 6
a52 32
\fBTcl_Main\fR is not provided by the public interface of Tcl's
stub library.  Programs that call \fBTcl_Main\fR must be linked
against the standard Tcl library.  Extensions (stub-enabled or
not) are not intended to call \fBTcl_Main\fR.
.PP
\fBTcl_Main\fR is not thread-safe.  It should only be called by
a single master thread of a multi-threaded application.  This
restriction is not a problem with normal use described above.
.PP
\fBTcl_Main\fR and therefore all applications based upon it, like
\fBtclsh\fR, use \fBTcl_GetStdChannel\fR to initialize the standard
channels to their default values. See \fBTcl_StandardChannels\fR for
more information.
.PP
\fBTcl_Main\fR supports two modes of operation, depending on the
values of \fIargc\fR and \fIargv\fR.  If \fIargv[1]\fR exists and
does not begin with the character \fI-\fR, it is taken to be the
name of a file containing a \fIstartup script\fR, which \fBTcl_Main\fR
will attempt to evaluate.  Otherwise, \fBTcl_Main\fR will enter an
interactive mode.
.PP
In either mode, \fBTcl_Main\fR will define in its master interpreter
the Tcl variables \fIargc\fR, \fIargv\fR, \fIargv0\fR, and
\fItcl_interactive\fR, as described in the documentation for \fBtclsh\fR.
.PP
When it has finished its own initialization, but before it processes
commands, \fBTcl_Main\fR calls the procedure given by the
\fIappInitProc\fR argument.  This procedure provides a ``hook'' for
the application to perform its own initialization of the interpreter
created by \fBTcl_Main\fR, such as defining application-specific
commands.  The procedure must have an interface that matches the
type \fBTcl_AppInitProc\fR:
d56 3
a58 48

\fIAppInitProc\fR is almost always a pointer to \fBTcl_AppInit\fR; for more
details on this procedure, see the documentation for \fBTcl_AppInit\fR.
.PP
When the \fIappInitProc\fR is finished, \fBTcl_Main\fR enters one
of its two modes.  If a startup script has been provided, \fBTcl_Main\fR
attempts to evaluate it.  Otherwise, interactive mode begins with
examination of the variable \fItcl_rcFileName\fR in the master
interpreter.  If that variable exists and holds the name of a readable
file, the contents of that file are evaluated in the master interpreter.
Then interactive operations begin,
with prompts and command evaluation results written to the standard
output channel, and commands read from the standard input channel
and then evaluated.  The prompts written to the standard output
channel may be customized by defining the Tcl variables \fItcl_prompt1\fR
and \fItcl_prompt2\fR as described in the documentation for \fBtclsh\fR.
The prompts and command evaluation results are written to the standard
output channel only if the Tcl variable \fItcl_interactive\fR in the
master interpreter holds a non-zero integer value.
.PP
.VS 8.4
\fBTcl_SetMainLoop\fR allows setting an event loop procedure to be run.
This allows, for example, Tk to be dynamically loaded and set its event
loop.  The event loop will run following the startup script.  If you
are in interactive mode, setting the main loop procedure will cause the
prompt to become fileevent based and then the loop procedure is called.
When the loop procedure returns in interactive mode, interactive operation
will continue.
The main loop procedure must have an interface that matches the type
\fBTcl_MainLoopProc\fR:
.CS
typedef void Tcl_MainLoopProc(void);
.CE
.VE 8.4
.PP
\fBTcl_Main\fR does not return.  Normally a program based on
\fBTcl_Main\fR will terminate when the \fBexit\fR command is
evaluated.  In interactive mode, if an EOF or channel error
is encountered on the standard input channel, then \fBTcl_Main\fR
itself will evaluate the \fBexit\fR command after the main loop
procedure (if any) returns.  In non-interactive mode, after
\fBTcl_Main\fR evaluates the startup script, and the main loop
procedure (if any) returns, \fBTcl_Main\fR will also evaluate
the \fBexit\fR command.

.SH "SEE ALSO"
tclsh(1), Tcl_GetStdChannel(3), Tcl_StandardChannels(3), Tcl_AppInit(3),
exit(n)
@


1.1
log
@Initial revision
@
text
@d8 1
a8 1
'\" RCS: @@(#) $Id: Tcl_Main.3,v 1.9 1999/01/26 03:53:01 jingham Exp $
@


1.1.1.1
log
@import dejagnu-1999-11-08 snapshot
@
text
@@


1.1.1.2
log
@Tcl 8.3 upgrade
@
text
@d8 1
a8 1
'\" RCS: @@(#) $Id: Tcl_Main.3,v 1.6.8.1 2000/04/06 22:38:26 spolk Exp $
@


1.1.1.3
log
@import tcl 8.4.0
@
text
@a3 1
'\" Copyright (c) 2000 Ajuba Solutions.
d8 1
a8 1
'\" RCS: @@(#) $Id: Tcl_Main.3,v 1.9 2002/07/01 18:24:39 jenglish Exp $
d11 1
a11 1
.TH Tcl_Main 3 8.4 Tcl "Tcl Library Procedures"
d14 1
a14 1
Tcl_Main, Tcl_SetMainLoop \- main program and event loop definition for Tcl-based applications
a19 2
.sp
\fBTcl_SetMainLoop\fR(\fImainLoopProc\fR)
a28 2
.AP Tcl_MainLoopProc *mainLoopProc in
Address of an application-specific event loop procedure.
d33 5
a37 17
\fBTcl_Main\fR can serve as the main program for Tcl-based shell
applications.  A ``shell application'' is a program
like tclsh or wish that supports both interactive interpretation
of Tcl and evaluation of a script contained in a file given as
a command line argument.  \fBTcl_Main\fR is offered as a convenience
to developers of shell applications, so they do not have to 
reproduce all of the code for proper initialization of the Tcl
library and interactive shell operation.  Other styles of embedding
Tcl in an application are not supported by \fBTcl_Main\fR.  Those
must be achieved by calling lower level functions in the Tcl library
directly.

The \fBTcl_Main\fR function has been offered by the Tcl library
since release Tcl 7.4.  In older releases of Tcl, the Tcl library
itself defined a function \fBmain\fR, but that lacks flexibility
of embedding style and having a function \fBmain\fR in a library
(particularly a shared library) causes problems on many systems.
d42 2
a43 2
Normally each shell application contains a small \fBmain\fR function
that does nothing but invoke \fBTcl_Main\fR.
d47 6
a52 32
\fBTcl_Main\fR is not provided by the public interface of Tcl's
stub library.  Programs that call \fBTcl_Main\fR must be linked
against the standard Tcl library.  Extensions (stub-enabled or
not) are not intended to call \fBTcl_Main\fR.
.PP
\fBTcl_Main\fR is not thread-safe.  It should only be called by
a single master thread of a multi-threaded application.  This
restriction is not a problem with normal use described above.
.PP
\fBTcl_Main\fR and therefore all applications based upon it, like
\fBtclsh\fR, use \fBTcl_GetStdChannel\fR to initialize the standard
channels to their default values. See \fBTcl_StandardChannels\fR for
more information.
.PP
\fBTcl_Main\fR supports two modes of operation, depending on the
values of \fIargc\fR and \fIargv\fR.  If \fIargv[1]\fR exists and
does not begin with the character \fI-\fR, it is taken to be the
name of a file containing a \fIstartup script\fR, which \fBTcl_Main\fR
will attempt to evaluate.  Otherwise, \fBTcl_Main\fR will enter an
interactive mode.
.PP
In either mode, \fBTcl_Main\fR will define in its master interpreter
the Tcl variables \fIargc\fR, \fIargv\fR, \fIargv0\fR, and
\fItcl_interactive\fR, as described in the documentation for \fBtclsh\fR.
.PP
When it has finished its own initialization, but before it processes
commands, \fBTcl_Main\fR calls the procedure given by the
\fIappInitProc\fR argument.  This procedure provides a ``hook'' for
the application to perform its own initialization of the interpreter
created by \fBTcl_Main\fR, such as defining application-specific
commands.  The procedure must have an interface that matches the
type \fBTcl_AppInitProc\fR:
d56 3
a58 48

\fIAppInitProc\fR is almost always a pointer to \fBTcl_AppInit\fR; for more
details on this procedure, see the documentation for \fBTcl_AppInit\fR.
.PP
When the \fIappInitProc\fR is finished, \fBTcl_Main\fR enters one
of its two modes.  If a startup script has been provided, \fBTcl_Main\fR
attempts to evaluate it.  Otherwise, interactive mode begins with
examination of the variable \fItcl_rcFileName\fR in the master
interpreter.  If that variable exists and holds the name of a readable
file, the contents of that file are evaluated in the master interpreter.
Then interactive operations begin,
with prompts and command evaluation results written to the standard
output channel, and commands read from the standard input channel
and then evaluated.  The prompts written to the standard output
channel may be customized by defining the Tcl variables \fItcl_prompt1\fR
and \fItcl_prompt2\fR as described in the documentation for \fBtclsh\fR.
The prompts and command evaluation results are written to the standard
output channel only if the Tcl variable \fItcl_interactive\fR in the
master interpreter holds a non-zero integer value.
.PP
.VS 8.4
\fBTcl_SetMainLoop\fR allows setting an event loop procedure to be run.
This allows, for example, Tk to be dynamically loaded and set its event
loop.  The event loop will run following the startup script.  If you
are in interactive mode, setting the main loop procedure will cause the
prompt to become fileevent based and then the loop procedure is called.
When the loop procedure returns in interactive mode, interactive operation
will continue.
The main loop procedure must have an interface that matches the type
\fBTcl_MainLoopProc\fR:
.CS
typedef void Tcl_MainLoopProc(void);
.CE
.VE 8.4
.PP
\fBTcl_Main\fR does not return.  Normally a program based on
\fBTcl_Main\fR will terminate when the \fBexit\fR command is
evaluated.  In interactive mode, if an EOF or channel error
is encountered on the standard input channel, then \fBTcl_Main\fR
itself will evaluate the \fBexit\fR command after the main loop
procedure (if any) returns.  In non-interactive mode, after
\fBTcl_Main\fR evaluates the startup script, and the main loop
procedure (if any) returns, \fBTcl_Main\fR will also evaluate
the \fBexit\fR command.

.SH "SEE ALSO"
tclsh(1), Tcl_GetStdChannel(3), Tcl_StandardChannels(3), Tcl_AppInit(3),
exit(n)
@


