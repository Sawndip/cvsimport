head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.58
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.56
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.54
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.52
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.50
	gdb_7_0-branch:1.5.0.48
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tcl8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.46
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.44
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.42
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.40
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.38
	gdb_6_5-2006-05-14-branchpoint:1.5
	readline_5_1-import-branch:1.5.0.36
	readline_5_1-import-branchpoint:1.5
	gdb_6_4-branch:1.5.0.34
	gdb_6_4-2005-11-01-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.32
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	ezannoni_pie-20040323-branch:1.5.0.30
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.28
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.26
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.24
	cagney_x86i386-20030821-branch:1.5.0.22
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.20
	gdb_6_0-2003-06-23-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.18
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.16
	cagney_writestrings-20030508-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.14
	cagney_fileio-20030521-branchpoint:1.5
	carlton_dictionary-20030430-merge:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.12
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.10
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.8
	cagney_lazyid-20030317-branchpoint:1.5
	offbyone-20030313-branch:1.5.0.6
	offbyone-20030313-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.4
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.2
	interps-20030202-branchpoint:1.5
	TCL8_4_1:1.1.1.3
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.2
	TCL_8_4_1:1.1.1.3
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.4
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TCL_8_4_0:1.1.1.3
	carlton_dictionary-branch:1.2.0.16
	carlton_dictionary-20020920-branchpoint:1.2
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.14
	gdb_5_3-branch:1.2.0.12
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.10
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.8
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.6
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TCL_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	dejagnu-2000-02-04:1.1.1.1
	dejagnu-2000-01-31:1.1.1.1
	dejagnu-2000-01-24:1.1.1.1
	dejagnu-2000-01-17:1.1.1.1
	dejagnu-2000-01-10:1.1.1.1
	dejagnu-2000-01-04:1.1.1.1
	dejagnu-1999-12-21:1.1.1.1
	dejagnu-1999-12-13:1.1.1.1
	dejagnu-1999-12-07:1.1.1.1
	dejagnu-1999-12-06:1.1.1.1
	dejagnu-1999-11-15:1.1.1.1
	dejagnu-1999-11-08:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@.\" @;
expand	@o@;


1.5
date	2003.01.21.19.39.59;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.26.19.47.49;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.37.01;	author kseitz;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2001.09.09.23.56.04;	author irox;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	99.11.09.01.28.43;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2002.09.27.21.49.01;	author kseitz;	state Exp;
branches;
next	;

1.3.4.1
date	2003.12.14.20.28.41;	author drow;	state Exp;
branches;
next	;

1.2.16.1
date	2002.12.23.19.40.07;	author carlton;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2003.02.07.19.18.08;	author carlton;	state Exp;
branches;
next	;

1.1.1.1
date	99.11.09.01.28.43;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.09.22.40.53;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.19.56.27;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tcl 8.4.1
@
text
@'\"
'\" Copyright (c) 1989-1993 The Regents of the University of California.
'\" Copyright (c) 1994-1996 Sun Microsystems, Inc.
'\"
'\" See the file "license.terms" for information on usage and redistribution
'\" of this file, and for a DISCLAIMER OF ALL WARRANTIES.
'\" 
'\" RCS: @@(#) $Id: Hash.3,v 1.10 2002/07/11 15:40:19 dgp Exp $
'\" 
.so man.macros
.TH Tcl_Hash 3 "" Tcl "Tcl Library Procedures"
.BS
.SH NAME
Tcl_InitHashTable, Tcl_InitCustomHashTable, Tcl_InitObjHashTable, Tcl_DeleteHashTable, Tcl_CreateHashEntry, Tcl_DeleteHashEntry, Tcl_FindHashEntry, Tcl_GetHashValue, Tcl_SetHashValue, Tcl_GetHashKey, Tcl_FirstHashEntry, Tcl_NextHashEntry, Tcl_HashStats \- procedures to manage hash tables
.SH SYNOPSIS
.nf
\fB#include <tcl.h>\fR
.sp
\fBTcl_InitHashTable\fR(\fItablePtr, keyType\fR)
.sp
\fBTcl_InitCustomHashTable\fR(\fItablePtr, keyType, typePtr\fR)
.sp
\fBTcl_InitObjHashTable\fR(\fItablePtr\fR)
.sp
\fBTcl_DeleteHashTable\fR(\fItablePtr\fR)
.sp
Tcl_HashEntry *
\fBTcl_CreateHashEntry\fR(\fItablePtr, key, newPtr\fR)
.sp
\fBTcl_DeleteHashEntry\fR(\fIentryPtr\fR)
.sp
Tcl_HashEntry *
\fBTcl_FindHashEntry\fR(\fItablePtr, key\fR)
.sp
ClientData
\fBTcl_GetHashValue\fR(\fIentryPtr\fR)
.sp
\fBTcl_SetHashValue\fR(\fIentryPtr, value\fR)
.sp
char *
\fBTcl_GetHashKey\fR(\fItablePtr, entryPtr\fR)
.sp
Tcl_HashEntry *
\fBTcl_FirstHashEntry\fR(\fItablePtr, searchPtr\fR)
.sp
Tcl_HashEntry *
\fBTcl_NextHashEntry\fR(\fIsearchPtr\fR)
.sp
CONST char *
\fBTcl_HashStats\fR(\fItablePtr\fR)
.SH ARGUMENTS
.AS Tcl_HashSearch *searchPtr
.AP Tcl_HashTable *tablePtr in
Address of hash table structure (for all procedures but
\fBTcl_InitHashTable\fR, this must have been initialized by
previous call to \fBTcl_InitHashTable\fR).
.AP int keyType in
Kind of keys to use for new hash table.  Must be either
TCL_STRING_KEYS, TCL_ONE_WORD_KEYS, TCL_CUSTOM_TYPE_KEYS,
TCL_CUSTOM_PTR_KEYS, or an integer value greater than 1.
.AP Tcl_HashKeyType *typePtr in
Address of structure which defines the behaviour of the hash table.
.AP "CONST char" *key in
Key to use for probe into table.  Exact form depends on
\fIkeyType\fR used to create table.
.AP int *newPtr out
The word at \fI*newPtr\fR is set to 1 if a new entry was created
and 0 if there was already an entry for \fIkey\fR.
.AP Tcl_HashEntry *entryPtr in
Pointer to hash table entry.
.AP ClientData value in
New value to assign to hash table entry.  Need not have type
ClientData, but must fit in same space as ClientData.
.AP Tcl_HashSearch *searchPtr in
Pointer to record to use to keep track of progress in enumerating
all the entries in a hash table.
.BE
.SH DESCRIPTION
.PP
A hash table consists of zero or more entries, each consisting of a
key and a value.  Given the key for an entry, the hashing routines can
very quickly locate the entry, and hence its value. There may be at
most one entry in a hash table with a particular key, but many entries
may have the same value.  Keys can take one of four forms: strings,
one-word values, integer arrays, or custom keys defined by a
Tcl_HashKeyType structure (See section \fBTHE TCL_HASHKEYTYPE
STRUCTURE\fR below). All of the keys in a given table have the same
form, which is specified when the table is initialized.
.PP
The value of a hash table entry can be anything that fits in the same
space as a ``char *'' pointer.  Values for hash table entries are
managed entirely by clients, not by the hash module itself.  Typically
each entry's value is a pointer to a data structure managed by client
code.
.PP
Hash tables grow gracefully as the number of entries increases, so
that there are always less than three entries per hash bucket, on
average. This allows for fast lookups regardless of the number of
entries in a table.
.PP
The core provides three functions for the initialization of hash
tables, Tcl_InitHashTable, Tcl_InitObjHashTable and
Tcl_InitCustomHashTable.
.PP
\fBTcl_InitHashTable\fR initializes a structure that describes a new
hash table.  The space for the structure is provided by the caller,
not by the hash module.  The value of \fIkeyType\fR indicates what
kinds of keys will be used for all entries in the table. All of the
key types described later are allowed, with the exception of
\fBTCL_CUSTOM_TYPE_KEYS\fR and \fBTCL_CUSTOM_PTR_KEYS\fR.
.PP
\fBTcl_InitObjHashTable\fR is a wrapper around
\fBTcl_InitCustomHashTable\fR and initializes a hash table whose keys
are Tcl_Obj *.
.PP
\fBTcl_InitCustomHashTable\fR initializes a structure that describes a
new hash table. The space for the structure is provided by the
caller, not by the hash module.  The value of \fIkeyType\fR indicates
what kinds of keys will be used for all entries in the table.
\fIKeyType\fR must have one of the following values:
.IP \fBTCL_STRING_KEYS\fR 25
Keys are null-terminated ASCII strings.
They are passed to hashing routines using the address of the
first character of the string.
.IP \fBTCL_ONE_WORD_KEYS\fR 25
Keys are single-word values;  they are passed to hashing routines
and stored in hash table entries as ``char *'' values.
The pointer value is the key;  it need not (and usually doesn't)
actually point to a string.
.IP \fBTCL_CUSTOM_TYPE_KEYS\fR 25
Keys are of arbitrary type, and are stored in the entry. Hashing
and comparison is determined by \fItypePtr\fR. The Tcl_HashKeyType 
structure is described in the section 
\fBTHE TCL_HASHKEYTYPE STRUCTURE\fR below.
.IP \fBTCL_CUSTOM_PTR_KEYS\fR 25
Keys are pointers to an arbitrary type, and are stored in the entry. Hashing
and comparison is determined by \fItypePtr\fR. The Tcl_HashKeyType 
structure is described in the section 
\fBTHE TCL_HASHKEYTYPE STRUCTURE\fR below.
.IP \fIother\fR 25
If \fIkeyType\fR is not one of the above,
then it must be an integer value greater than 1.
In this case the keys will be arrays of ``int'' values, where
\fIkeyType\fR gives the number of ints in each key.
This allows structures to be used as keys.
All keys must have the same size.
Array keys are passed into hashing functions using the address
of the first int in the array.
.PP
\fBTcl_DeleteHashTable\fR deletes all of the entries in a hash
table and frees up the memory associated with the table's
bucket array and entries.
It does not free the actual table structure (pointed to
by \fItablePtr\fR), since that memory is assumed to be managed
by the client.
\fBTcl_DeleteHashTable\fR also does not free or otherwise
manipulate the values of the hash table entries.
If the entry values point to dynamically-allocated memory, then
it is the client's responsibility to free these structures
before deleting the table.
.PP
\fBTcl_CreateHashEntry\fR locates the entry corresponding to a
particular key, creating a new entry in the table if there
wasn't already one with the given key.
If an entry already existed with the given key then \fI*newPtr\fR
is set to zero.
If a new entry was created, then \fI*newPtr\fR is set to a non-zero
value and the value of the new entry will be set to zero.
The return value from \fBTcl_CreateHashEntry\fR is a pointer to
the entry, which may be used to retrieve and modify the entry's
value or to delete the entry from the table.
.PP
\fBTcl_DeleteHashEntry\fR will remove an existing entry from a
table.
The memory associated with the entry itself will be freed, but
the client is responsible for any cleanup associated with the
entry's value, such as freeing a structure that it points to.
.PP
\fBTcl_FindHashEntry\fR is similar to \fBTcl_CreateHashEntry\fR
except that it doesn't create a new entry if the key doesn't exist;
instead, it returns NULL as result.
.PP
\fBTcl_GetHashValue\fR and \fBTcl_SetHashValue\fR are used to
read and write an entry's value, respectively.
Values are stored and retrieved as type ``ClientData'', which is
large enough to hold a pointer value.  On almost all machines this is
large enough to hold an integer value too.
.PP
\fBTcl_GetHashKey\fR returns the key for a given hash table entry,
either as a pointer to a string, a one-word (``char *'') key, or
as a pointer to the first word of an array of integers, depending
on the \fIkeyType\fR used to create a hash table.
In all cases \fBTcl_GetHashKey\fR returns a result with type
``char *''.
When the key is a string or array, the result of \fBTcl_GetHashKey\fR
points to information in the table entry;  this information will
remain valid until the entry is deleted or its table is deleted.
.PP
\fBTcl_FirstHashEntry\fR and \fBTcl_NextHashEntry\fR may be used
to scan all of the entries in a hash table.
A structure of type ``Tcl_HashSearch'', provided by the client,
is used to keep track of progress through the table.
\fBTcl_FirstHashEntry\fR initializes the search record and
returns the first entry in the table (or NULL if the table is
empty).
Each subsequent call to \fBTcl_NextHashEntry\fR returns the
next entry in the table or
NULL if the end of the table has been reached.
A call to \fBTcl_FirstHashEntry\fR followed by calls to
\fBTcl_NextHashEntry\fR will return each of the entries in
the table exactly once, in an arbitrary order.
It is unadvisable to modify the structure of the table, e.g.
by creating or deleting entries, while the search is in
progress.
.PP
\fBTcl_HashStats\fR returns a dynamically-allocated string with
overall information about a hash table, such as the number of
entries it contains, the number of buckets in its hash array,
and the utilization of the buckets.
It is the caller's responsibility to free the result string
by passing it to \fBckfree\fR.
.PP
The header file \fBtcl.h\fR defines the actual data structures
used to implement hash tables.
This is necessary so that clients can allocate Tcl_HashTable
structures and so that macros can be used to read and write
the values of entries.
However, users of the hashing routines should never refer directly
to any of the fields of any of the hash-related data structures;
use the procedures and macros defined here.
.SH "THE TCL_HASHKEYTYPE STRUCTURE"
.PP
Extension writers can define new hash key types by defining four
procedures, initializing a Tcl_HashKeyType structure to describe
the type, and calling \fBTcl_InitCustomHashTable\fR.
The \fBTcl_HashKeyType\fR structure is defined as follows:
.CS
typedef struct Tcl_HashKeyType {
    int \fIversion\fR;
    int \fIflags\fR;
    Tcl_HashKeyProc *\fIhashKeyProc\fR;
    Tcl_CompareHashKeysProc *\fIcompareKeysProc\fR;
    Tcl_AllocHashEntryProc *\fIallocEntryProc\fR;
    Tcl_FreeHashEntryProc *\fIfreeEntryProc\fR;
} Tcl_HashKeyType;
.CE
.PP
The \fIversion\fR member is the version of the table. If this
structure is extended in future then the version can be used
to distinguish between different structures. It should be set
to \fBTCL_HASH_KEY_TYPE_VERSION\fR.
.PP
The \fIflags\fR member is one or more of the following values OR'ed together:
.IP \fBTCL_HASH_KEY_RANDOMIZE_HASH\fR 25
There are some things, pointers for example which don't hash well 
because they do not use the lower bits. If this flag is set then the
hash table will attempt to rectify this by randomising the bits and 
then using the upper N bits as the index into the table.
.PP
The \fIhashKeyProc\fR member contains the address of a function 
called to calculate a hash value for the key.
.CS
typedef unsigned int (Tcl_HashKeyProc) (
    Tcl_HashTable *\fItablePtr\fR,
    VOID *\fIkeyPtr\fR);
.CE
If this is NULL then \fIkeyPtr\fR is used and 
\fBTCL_HASH_KEY_RANDOMIZE_HASH\fR is assumed.
.PP
The \fIcompareKeysProc\fR member contains the address of a function 
called to compare two keys.
.CS
typedef int (Tcl_CompareHashKeysProc) (VOID *\fIkeyPtr\fR,
    Tcl_HashEntry *\fIhPtr\fR);
.CE
If this is NULL then the \fIkeyPtr\fR pointers are compared.
If the keys don't match then the function returns 0, otherwise
it returns 1.
.PP
The \fIallocEntryProc\fR member contains the address of a function 
called to allocate space for an entry and initialise the key.
.CS
typedef Tcl_HashEntry *(Tcl_AllocHashEntryProc) (
    Tcl_HashTable *\fItablePtr\fR, VOID *\fIkeyPtr\fR);
.CE
If this is NULL then Tcl_Alloc is used to allocate enough space for a
Tcl_HashEntry and the key pointer is assigned to key.oneWordValue.
String keys and array keys use this function to allocate enough 
space for the entry and the key in one block, rather than doing
it in two blocks. This saves space for a pointer to the key from
the entry and another memory allocation. Tcl_Obj * keys use this 
function to allocate enough space for an entry and increment the 
reference count on the object.
If 
.PP
The \fIfreeEntryProc\fR member contains the address of a function 
called to free space for an entry.
.CS
typedef void (Tcl_FreeHashEntryProc) (Tcl_HashEntry *\fIhPtr\fR);
.CE
If this is NULL then Tcl_Free is used to free the space for the 
entry. Tcl_Obj * keys use this function to decrement the
reference count on the object.
.SH KEYWORDS
hash table, key, lookup, search, value
@


1.4
log
@touched all sources to ease next import
@
text
@d8 1
a8 1
'\" RCS: @@(#) $Id: Hash.3,v 1.6.8.1 2000/04/06 22:38:26 spolk Exp $
d14 1
a14 1
Tcl_InitHashTable, Tcl_DeleteHashTable, Tcl_CreateHashEntry, Tcl_DeleteHashEntry, Tcl_FindHashEntry, Tcl_GetHashValue, Tcl_SetHashValue, Tcl_GetHashKey, Tcl_FirstHashEntry, Tcl_NextHashEntry, Tcl_HashStats \- procedures to manage hash tables
d21 4
d49 1
a49 1
char *
d59 5
a63 3
TCL_STRING_KEYS, TCL_ONE_WORD_KEYS, or an integer value
greater than 1.
.AP char *key in
a77 1

d80 41
a120 31
A hash table consists of zero or more entries, each consisting of
a key and a value.
Given the key for an entry, the hashing routines can very quickly
locate the entry, and hence its value.
There may be at most one entry in a hash table with a
particular key, but many entries may have the same value.
Keys can take one of three forms:  strings,
one-word values, or integer arrays.
All of the keys in a given table have the same form, which is
specified when the table is initialized.
.PP
The value of a hash table entry can be anything that fits in
the same space as a ``char *'' pointer.
Values for hash table entries are managed entirely by clients,
not by the hash module itself.
Typically each entry's value is a pointer to a data structure
managed by client code.
.PP
Hash tables grow gracefully as the number of entries increases,
so that there are always less than three entries per hash bucket,
on average.
This allows for fast lookups regardless of the number of entries
in a table.
.PP
\fBTcl_InitHashTable\fR initializes a structure that describes
a new hash table.
The space for the structure is provided by the caller, not by
the hash module.
The value of \fIkeyType\fR indicates what kinds of keys will
be used for all entries in the table.  \fIKeyType\fR must have
one of the following values:
d130 10
d141 1
a141 1
If \fIkeyType\fR is not TCL_STRING_KEYS or TCL_ONE_WORD_KEYS,
d231 73
a303 1

@


1.3
log
@touched all sources to ease next import
@
text
@@


1.3.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d8 1
a8 1
'\" RCS: @@(#) $Id: Hash.3,v 1.10 2002/07/11 15:40:19 dgp Exp $
d14 1
a14 1
Tcl_InitHashTable, Tcl_InitCustomHashTable, Tcl_InitObjHashTable, Tcl_DeleteHashTable, Tcl_CreateHashEntry, Tcl_DeleteHashEntry, Tcl_FindHashEntry, Tcl_GetHashValue, Tcl_SetHashValue, Tcl_GetHashKey, Tcl_FirstHashEntry, Tcl_NextHashEntry, Tcl_HashStats \- procedures to manage hash tables
a20 4
\fBTcl_InitCustomHashTable\fR(\fItablePtr, keyType, typePtr\fR)
.sp
\fBTcl_InitObjHashTable\fR(\fItablePtr\fR)
.sp
d45 1
a45 1
CONST char *
d55 3
a57 5
TCL_STRING_KEYS, TCL_ONE_WORD_KEYS, TCL_CUSTOM_TYPE_KEYS,
TCL_CUSTOM_PTR_KEYS, or an integer value greater than 1.
.AP Tcl_HashKeyType *typePtr in
Address of structure which defines the behaviour of the hash table.
.AP "CONST char" *key in
d72 1
d75 31
a105 41
A hash table consists of zero or more entries, each consisting of a
key and a value.  Given the key for an entry, the hashing routines can
very quickly locate the entry, and hence its value. There may be at
most one entry in a hash table with a particular key, but many entries
may have the same value.  Keys can take one of four forms: strings,
one-word values, integer arrays, or custom keys defined by a
Tcl_HashKeyType structure (See section \fBTHE TCL_HASHKEYTYPE
STRUCTURE\fR below). All of the keys in a given table have the same
form, which is specified when the table is initialized.
.PP
The value of a hash table entry can be anything that fits in the same
space as a ``char *'' pointer.  Values for hash table entries are
managed entirely by clients, not by the hash module itself.  Typically
each entry's value is a pointer to a data structure managed by client
code.
.PP
Hash tables grow gracefully as the number of entries increases, so
that there are always less than three entries per hash bucket, on
average. This allows for fast lookups regardless of the number of
entries in a table.
.PP
The core provides three functions for the initialization of hash
tables, Tcl_InitHashTable, Tcl_InitObjHashTable and
Tcl_InitCustomHashTable.
.PP
\fBTcl_InitHashTable\fR initializes a structure that describes a new
hash table.  The space for the structure is provided by the caller,
not by the hash module.  The value of \fIkeyType\fR indicates what
kinds of keys will be used for all entries in the table. All of the
key types described later are allowed, with the exception of
\fBTCL_CUSTOM_TYPE_KEYS\fR and \fBTCL_CUSTOM_PTR_KEYS\fR.
.PP
\fBTcl_InitObjHashTable\fR is a wrapper around
\fBTcl_InitCustomHashTable\fR and initializes a hash table whose keys
are Tcl_Obj *.
.PP
\fBTcl_InitCustomHashTable\fR initializes a structure that describes a
new hash table. The space for the structure is provided by the
caller, not by the hash module.  The value of \fIkeyType\fR indicates
what kinds of keys will be used for all entries in the table.
\fIKeyType\fR must have one of the following values:
a114 10
.IP \fBTCL_CUSTOM_TYPE_KEYS\fR 25
Keys are of arbitrary type, and are stored in the entry. Hashing
and comparison is determined by \fItypePtr\fR. The Tcl_HashKeyType 
structure is described in the section 
\fBTHE TCL_HASHKEYTYPE STRUCTURE\fR below.
.IP \fBTCL_CUSTOM_PTR_KEYS\fR 25
Keys are pointers to an arbitrary type, and are stored in the entry. Hashing
and comparison is determined by \fItypePtr\fR. The Tcl_HashKeyType 
structure is described in the section 
\fBTHE TCL_HASHKEYTYPE STRUCTURE\fR below.
d116 1
a116 1
If \fIkeyType\fR is not one of the above,
d206 1
a206 73
.SH "THE TCL_HASHKEYTYPE STRUCTURE"
.PP
Extension writers can define new hash key types by defining four
procedures, initializing a Tcl_HashKeyType structure to describe
the type, and calling \fBTcl_InitCustomHashTable\fR.
The \fBTcl_HashKeyType\fR structure is defined as follows:
.CS
typedef struct Tcl_HashKeyType {
    int \fIversion\fR;
    int \fIflags\fR;
    Tcl_HashKeyProc *\fIhashKeyProc\fR;
    Tcl_CompareHashKeysProc *\fIcompareKeysProc\fR;
    Tcl_AllocHashEntryProc *\fIallocEntryProc\fR;
    Tcl_FreeHashEntryProc *\fIfreeEntryProc\fR;
} Tcl_HashKeyType;
.CE
.PP
The \fIversion\fR member is the version of the table. If this
structure is extended in future then the version can be used
to distinguish between different structures. It should be set
to \fBTCL_HASH_KEY_TYPE_VERSION\fR.
.PP
The \fIflags\fR member is one or more of the following values OR'ed together:
.IP \fBTCL_HASH_KEY_RANDOMIZE_HASH\fR 25
There are some things, pointers for example which don't hash well 
because they do not use the lower bits. If this flag is set then the
hash table will attempt to rectify this by randomising the bits and 
then using the upper N bits as the index into the table.
.PP
The \fIhashKeyProc\fR member contains the address of a function 
called to calculate a hash value for the key.
.CS
typedef unsigned int (Tcl_HashKeyProc) (
    Tcl_HashTable *\fItablePtr\fR,
    VOID *\fIkeyPtr\fR);
.CE
If this is NULL then \fIkeyPtr\fR is used and 
\fBTCL_HASH_KEY_RANDOMIZE_HASH\fR is assumed.
.PP
The \fIcompareKeysProc\fR member contains the address of a function 
called to compare two keys.
.CS
typedef int (Tcl_CompareHashKeysProc) (VOID *\fIkeyPtr\fR,
    Tcl_HashEntry *\fIhPtr\fR);
.CE
If this is NULL then the \fIkeyPtr\fR pointers are compared.
If the keys don't match then the function returns 0, otherwise
it returns 1.
.PP
The \fIallocEntryProc\fR member contains the address of a function 
called to allocate space for an entry and initialise the key.
.CS
typedef Tcl_HashEntry *(Tcl_AllocHashEntryProc) (
    Tcl_HashTable *\fItablePtr\fR, VOID *\fIkeyPtr\fR);
.CE
If this is NULL then Tcl_Alloc is used to allocate enough space for a
Tcl_HashEntry and the key pointer is assigned to key.oneWordValue.
String keys and array keys use this function to allocate enough 
space for the entry and the key in one block, rather than doing
it in two blocks. This saves space for a pointer to the key from
the entry and another memory allocation. Tcl_Obj * keys use this 
function to allocate enough space for an entry and increment the 
reference count on the object.
If 
.PP
The \fIfreeEntryProc\fR member contains the address of a function 
called to free space for an entry.
.CS
typedef void (Tcl_FreeHashEntryProc) (Tcl_HashEntry *\fIhPtr\fR);
.CE
If this is NULL then Tcl_Free is used to free the space for the 
entry. Tcl_Obj * keys use this function to decrement the
reference count on the object.
@


1.3.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@d8 1
a8 1
'\" RCS: @@(#) $Id: Hash.3,v 1.10 2002/07/11 15:40:19 dgp Exp $
d14 1
a14 1
Tcl_InitHashTable, Tcl_InitCustomHashTable, Tcl_InitObjHashTable, Tcl_DeleteHashTable, Tcl_CreateHashEntry, Tcl_DeleteHashEntry, Tcl_FindHashEntry, Tcl_GetHashValue, Tcl_SetHashValue, Tcl_GetHashKey, Tcl_FirstHashEntry, Tcl_NextHashEntry, Tcl_HashStats \- procedures to manage hash tables
a20 4
\fBTcl_InitCustomHashTable\fR(\fItablePtr, keyType, typePtr\fR)
.sp
\fBTcl_InitObjHashTable\fR(\fItablePtr\fR)
.sp
d45 1
a45 1
CONST char *
d55 3
a57 5
TCL_STRING_KEYS, TCL_ONE_WORD_KEYS, TCL_CUSTOM_TYPE_KEYS,
TCL_CUSTOM_PTR_KEYS, or an integer value greater than 1.
.AP Tcl_HashKeyType *typePtr in
Address of structure which defines the behaviour of the hash table.
.AP "CONST char" *key in
d72 1
d75 31
a105 41
A hash table consists of zero or more entries, each consisting of a
key and a value.  Given the key for an entry, the hashing routines can
very quickly locate the entry, and hence its value. There may be at
most one entry in a hash table with a particular key, but many entries
may have the same value.  Keys can take one of four forms: strings,
one-word values, integer arrays, or custom keys defined by a
Tcl_HashKeyType structure (See section \fBTHE TCL_HASHKEYTYPE
STRUCTURE\fR below). All of the keys in a given table have the same
form, which is specified when the table is initialized.
.PP
The value of a hash table entry can be anything that fits in the same
space as a ``char *'' pointer.  Values for hash table entries are
managed entirely by clients, not by the hash module itself.  Typically
each entry's value is a pointer to a data structure managed by client
code.
.PP
Hash tables grow gracefully as the number of entries increases, so
that there are always less than three entries per hash bucket, on
average. This allows for fast lookups regardless of the number of
entries in a table.
.PP
The core provides three functions for the initialization of hash
tables, Tcl_InitHashTable, Tcl_InitObjHashTable and
Tcl_InitCustomHashTable.
.PP
\fBTcl_InitHashTable\fR initializes a structure that describes a new
hash table.  The space for the structure is provided by the caller,
not by the hash module.  The value of \fIkeyType\fR indicates what
kinds of keys will be used for all entries in the table. All of the
key types described later are allowed, with the exception of
\fBTCL_CUSTOM_TYPE_KEYS\fR and \fBTCL_CUSTOM_PTR_KEYS\fR.
.PP
\fBTcl_InitObjHashTable\fR is a wrapper around
\fBTcl_InitCustomHashTable\fR and initializes a hash table whose keys
are Tcl_Obj *.
.PP
\fBTcl_InitCustomHashTable\fR initializes a structure that describes a
new hash table. The space for the structure is provided by the
caller, not by the hash module.  The value of \fIkeyType\fR indicates
what kinds of keys will be used for all entries in the table.
\fIKeyType\fR must have one of the following values:
a114 10
.IP \fBTCL_CUSTOM_TYPE_KEYS\fR 25
Keys are of arbitrary type, and are stored in the entry. Hashing
and comparison is determined by \fItypePtr\fR. The Tcl_HashKeyType 
structure is described in the section 
\fBTHE TCL_HASHKEYTYPE STRUCTURE\fR below.
.IP \fBTCL_CUSTOM_PTR_KEYS\fR 25
Keys are pointers to an arbitrary type, and are stored in the entry. Hashing
and comparison is determined by \fItypePtr\fR. The Tcl_HashKeyType 
structure is described in the section 
\fBTHE TCL_HASHKEYTYPE STRUCTURE\fR below.
d116 1
a116 1
If \fIkeyType\fR is not one of the above,
d206 1
a206 73
.SH "THE TCL_HASHKEYTYPE STRUCTURE"
.PP
Extension writers can define new hash key types by defining four
procedures, initializing a Tcl_HashKeyType structure to describe
the type, and calling \fBTcl_InitCustomHashTable\fR.
The \fBTcl_HashKeyType\fR structure is defined as follows:
.CS
typedef struct Tcl_HashKeyType {
    int \fIversion\fR;
    int \fIflags\fR;
    Tcl_HashKeyProc *\fIhashKeyProc\fR;
    Tcl_CompareHashKeysProc *\fIcompareKeysProc\fR;
    Tcl_AllocHashEntryProc *\fIallocEntryProc\fR;
    Tcl_FreeHashEntryProc *\fIfreeEntryProc\fR;
} Tcl_HashKeyType;
.CE
.PP
The \fIversion\fR member is the version of the table. If this
structure is extended in future then the version can be used
to distinguish between different structures. It should be set
to \fBTCL_HASH_KEY_TYPE_VERSION\fR.
.PP
The \fIflags\fR member is one or more of the following values OR'ed together:
.IP \fBTCL_HASH_KEY_RANDOMIZE_HASH\fR 25
There are some things, pointers for example which don't hash well 
because they do not use the lower bits. If this flag is set then the
hash table will attempt to rectify this by randomising the bits and 
then using the upper N bits as the index into the table.
.PP
The \fIhashKeyProc\fR member contains the address of a function 
called to calculate a hash value for the key.
.CS
typedef unsigned int (Tcl_HashKeyProc) (
    Tcl_HashTable *\fItablePtr\fR,
    VOID *\fIkeyPtr\fR);
.CE
If this is NULL then \fIkeyPtr\fR is used and 
\fBTCL_HASH_KEY_RANDOMIZE_HASH\fR is assumed.
.PP
The \fIcompareKeysProc\fR member contains the address of a function 
called to compare two keys.
.CS
typedef int (Tcl_CompareHashKeysProc) (VOID *\fIkeyPtr\fR,
    Tcl_HashEntry *\fIhPtr\fR);
.CE
If this is NULL then the \fIkeyPtr\fR pointers are compared.
If the keys don't match then the function returns 0, otherwise
it returns 1.
.PP
The \fIallocEntryProc\fR member contains the address of a function 
called to allocate space for an entry and initialise the key.
.CS
typedef Tcl_HashEntry *(Tcl_AllocHashEntryProc) (
    Tcl_HashTable *\fItablePtr\fR, VOID *\fIkeyPtr\fR);
.CE
If this is NULL then Tcl_Alloc is used to allocate enough space for a
Tcl_HashEntry and the key pointer is assigned to key.oneWordValue.
String keys and array keys use this function to allocate enough 
space for the entry and the key in one block, rather than doing
it in two blocks. This saves space for a pointer to the key from
the entry and another memory allocation. Tcl_Obj * keys use this 
function to allocate enough space for an entry and increment the 
reference count on the object.
If 
.PP
The \fIfreeEntryProc\fR member contains the address of a function 
called to free space for an entry.
.CS
typedef void (Tcl_FreeHashEntryProc) (Tcl_HashEntry *\fIhPtr\fR);
.CE
If this is NULL then Tcl_Free is used to free the space for the 
entry. Tcl_Obj * keys use this function to decrement the
reference count on the object.
@


1.2
log
@touched all Tcl files to ease next import.
@
text
@@


1.2.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.2.16.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d14 1
a14 1
Tcl_InitHashTable, Tcl_InitCustomHashTable, Tcl_InitObjHashTable, Tcl_DeleteHashTable, Tcl_CreateHashEntry, Tcl_DeleteHashEntry, Tcl_FindHashEntry, Tcl_GetHashValue, Tcl_SetHashValue, Tcl_GetHashKey, Tcl_FirstHashEntry, Tcl_NextHashEntry, Tcl_HashStats \- procedures to manage hash tables
a20 4
\fBTcl_InitCustomHashTable\fR(\fItablePtr, keyType, typePtr\fR)
.sp
\fBTcl_InitObjHashTable\fR(\fItablePtr\fR)
.sp
d45 1
a45 1
CONST char *
d55 3
a57 5
TCL_STRING_KEYS, TCL_ONE_WORD_KEYS, TCL_CUSTOM_TYPE_KEYS,
TCL_CUSTOM_PTR_KEYS, or an integer value greater than 1.
.AP Tcl_HashKeyType *typePtr in
Address of structure which defines the behaviour of the hash table.
.AP "CONST char" *key in
d72 1
d75 31
a105 41
A hash table consists of zero or more entries, each consisting of a
key and a value.  Given the key for an entry, the hashing routines can
very quickly locate the entry, and hence its value. There may be at
most one entry in a hash table with a particular key, but many entries
may have the same value.  Keys can take one of four forms: strings,
one-word values, integer arrays, or custom keys defined by a
Tcl_HashKeyType structure (See section \fBTHE TCL_HASHKEYTYPE
STRUCTURE\fR below). All of the keys in a given table have the same
form, which is specified when the table is initialized.
.PP
The value of a hash table entry can be anything that fits in the same
space as a ``char *'' pointer.  Values for hash table entries are
managed entirely by clients, not by the hash module itself.  Typically
each entry's value is a pointer to a data structure managed by client
code.
.PP
Hash tables grow gracefully as the number of entries increases, so
that there are always less than three entries per hash bucket, on
average. This allows for fast lookups regardless of the number of
entries in a table.
.PP
The core provides three functions for the initialization of hash
tables, Tcl_InitHashTable, Tcl_InitObjHashTable and
Tcl_InitCustomHashTable.
.PP
\fBTcl_InitHashTable\fR initializes a structure that describes a new
hash table.  The space for the structure is provided by the caller,
not by the hash module.  The value of \fIkeyType\fR indicates what
kinds of keys will be used for all entries in the table. All of the
key types described later are allowed, with the exception of
\fBTCL_CUSTOM_TYPE_KEYS\fR and \fBTCL_CUSTOM_PTR_KEYS\fR.
.PP
\fBTcl_InitObjHashTable\fR is a wrapper around
\fBTcl_InitCustomHashTable\fR and initializes a hash table whose keys
are Tcl_Obj *.
.PP
\fBTcl_InitCustomHashTable\fR initializes a structure that describes a
new hash table. The space for the structure is provided by the
caller, not by the hash module.  The value of \fIkeyType\fR indicates
what kinds of keys will be used for all entries in the table.
\fIKeyType\fR must have one of the following values:
a114 10
.IP \fBTCL_CUSTOM_TYPE_KEYS\fR 25
Keys are of arbitrary type, and are stored in the entry. Hashing
and comparison is determined by \fItypePtr\fR. The Tcl_HashKeyType 
structure is described in the section 
\fBTHE TCL_HASHKEYTYPE STRUCTURE\fR below.
.IP \fBTCL_CUSTOM_PTR_KEYS\fR 25
Keys are pointers to an arbitrary type, and are stored in the entry. Hashing
and comparison is determined by \fItypePtr\fR. The Tcl_HashKeyType 
structure is described in the section 
\fBTHE TCL_HASHKEYTYPE STRUCTURE\fR below.
d116 1
a116 1
If \fIkeyType\fR is not one of the above,
d206 1
a206 73
.SH "THE TCL_HASHKEYTYPE STRUCTURE"
.PP
Extension writers can define new hash key types by defining four
procedures, initializing a Tcl_HashKeyType structure to describe
the type, and calling \fBTcl_InitCustomHashTable\fR.
The \fBTcl_HashKeyType\fR structure is defined as follows:
.CS
typedef struct Tcl_HashKeyType {
    int \fIversion\fR;
    int \fIflags\fR;
    Tcl_HashKeyProc *\fIhashKeyProc\fR;
    Tcl_CompareHashKeysProc *\fIcompareKeysProc\fR;
    Tcl_AllocHashEntryProc *\fIallocEntryProc\fR;
    Tcl_FreeHashEntryProc *\fIfreeEntryProc\fR;
} Tcl_HashKeyType;
.CE
.PP
The \fIversion\fR member is the version of the table. If this
structure is extended in future then the version can be used
to distinguish between different structures. It should be set
to \fBTCL_HASH_KEY_TYPE_VERSION\fR.
.PP
The \fIflags\fR member is one or more of the following values OR'ed together:
.IP \fBTCL_HASH_KEY_RANDOMIZE_HASH\fR 25
There are some things, pointers for example which don't hash well 
because they do not use the lower bits. If this flag is set then the
hash table will attempt to rectify this by randomising the bits and 
then using the upper N bits as the index into the table.
.PP
The \fIhashKeyProc\fR member contains the address of a function 
called to calculate a hash value for the key.
.CS
typedef unsigned int (Tcl_HashKeyProc) (
    Tcl_HashTable *\fItablePtr\fR,
    VOID *\fIkeyPtr\fR);
.CE
If this is NULL then \fIkeyPtr\fR is used and 
\fBTCL_HASH_KEY_RANDOMIZE_HASH\fR is assumed.
.PP
The \fIcompareKeysProc\fR member contains the address of a function 
called to compare two keys.
.CS
typedef int (Tcl_CompareHashKeysProc) (VOID *\fIkeyPtr\fR,
    Tcl_HashEntry *\fIhPtr\fR);
.CE
If this is NULL then the \fIkeyPtr\fR pointers are compared.
If the keys don't match then the function returns 0, otherwise
it returns 1.
.PP
The \fIallocEntryProc\fR member contains the address of a function 
called to allocate space for an entry and initialise the key.
.CS
typedef Tcl_HashEntry *(Tcl_AllocHashEntryProc) (
    Tcl_HashTable *\fItablePtr\fR, VOID *\fIkeyPtr\fR);
.CE
If this is NULL then Tcl_Alloc is used to allocate enough space for a
Tcl_HashEntry and the key pointer is assigned to key.oneWordValue.
String keys and array keys use this function to allocate enough 
space for the entry and the key in one block, rather than doing
it in two blocks. This saves space for a pointer to the key from
the entry and another memory allocation. Tcl_Obj * keys use this 
function to allocate enough space for an entry and increment the 
reference count on the object.
If 
.PP
The \fIfreeEntryProc\fR member contains the address of a function 
called to free space for an entry.
.CS
typedef void (Tcl_FreeHashEntryProc) (Tcl_HashEntry *\fIhPtr\fR);
.CE
If this is NULL then Tcl_Free is used to free the space for the 
entry. Tcl_Obj * keys use this function to decrement the
reference count on the object.
@


1.1
log
@Initial revision
@
text
@d8 1
a8 1
'\" RCS: @@(#) $Id: Hash.3,v 1.2 1998/09/14 18:39:49 stanton Exp $
d196 1
a196 1
by passing it to \fBfree\fR.
@


1.1.1.1
log
@import dejagnu-1999-11-08 snapshot
@
text
@@


1.1.1.2
log
@Tcl 8.3 upgrade
@
text
@d8 1
a8 1
'\" RCS: @@(#) $Id: Hash.3,v 1.6.8.1 2000/04/06 22:38:26 spolk Exp $
d196 1
a196 1
by passing it to \fBckfree\fR.
@


1.1.1.3
log
@import tcl 8.4.0
@
text
@d8 1
a8 1
'\" RCS: @@(#) $Id: Hash.3,v 1.10 2002/07/11 15:40:19 dgp Exp $
d14 1
a14 1
Tcl_InitHashTable, Tcl_InitCustomHashTable, Tcl_InitObjHashTable, Tcl_DeleteHashTable, Tcl_CreateHashEntry, Tcl_DeleteHashEntry, Tcl_FindHashEntry, Tcl_GetHashValue, Tcl_SetHashValue, Tcl_GetHashKey, Tcl_FirstHashEntry, Tcl_NextHashEntry, Tcl_HashStats \- procedures to manage hash tables
a20 4
\fBTcl_InitCustomHashTable\fR(\fItablePtr, keyType, typePtr\fR)
.sp
\fBTcl_InitObjHashTable\fR(\fItablePtr\fR)
.sp
d45 1
a45 1
CONST char *
d55 3
a57 5
TCL_STRING_KEYS, TCL_ONE_WORD_KEYS, TCL_CUSTOM_TYPE_KEYS,
TCL_CUSTOM_PTR_KEYS, or an integer value greater than 1.
.AP Tcl_HashKeyType *typePtr in
Address of structure which defines the behaviour of the hash table.
.AP "CONST char" *key in
d72 1
d75 31
a105 41
A hash table consists of zero or more entries, each consisting of a
key and a value.  Given the key for an entry, the hashing routines can
very quickly locate the entry, and hence its value. There may be at
most one entry in a hash table with a particular key, but many entries
may have the same value.  Keys can take one of four forms: strings,
one-word values, integer arrays, or custom keys defined by a
Tcl_HashKeyType structure (See section \fBTHE TCL_HASHKEYTYPE
STRUCTURE\fR below). All of the keys in a given table have the same
form, which is specified when the table is initialized.
.PP
The value of a hash table entry can be anything that fits in the same
space as a ``char *'' pointer.  Values for hash table entries are
managed entirely by clients, not by the hash module itself.  Typically
each entry's value is a pointer to a data structure managed by client
code.
.PP
Hash tables grow gracefully as the number of entries increases, so
that there are always less than three entries per hash bucket, on
average. This allows for fast lookups regardless of the number of
entries in a table.
.PP
The core provides three functions for the initialization of hash
tables, Tcl_InitHashTable, Tcl_InitObjHashTable and
Tcl_InitCustomHashTable.
.PP
\fBTcl_InitHashTable\fR initializes a structure that describes a new
hash table.  The space for the structure is provided by the caller,
not by the hash module.  The value of \fIkeyType\fR indicates what
kinds of keys will be used for all entries in the table. All of the
key types described later are allowed, with the exception of
\fBTCL_CUSTOM_TYPE_KEYS\fR and \fBTCL_CUSTOM_PTR_KEYS\fR.
.PP
\fBTcl_InitObjHashTable\fR is a wrapper around
\fBTcl_InitCustomHashTable\fR and initializes a hash table whose keys
are Tcl_Obj *.
.PP
\fBTcl_InitCustomHashTable\fR initializes a structure that describes a
new hash table. The space for the structure is provided by the
caller, not by the hash module.  The value of \fIkeyType\fR indicates
what kinds of keys will be used for all entries in the table.
\fIKeyType\fR must have one of the following values:
a114 10
.IP \fBTCL_CUSTOM_TYPE_KEYS\fR 25
Keys are of arbitrary type, and are stored in the entry. Hashing
and comparison is determined by \fItypePtr\fR. The Tcl_HashKeyType 
structure is described in the section 
\fBTHE TCL_HASHKEYTYPE STRUCTURE\fR below.
.IP \fBTCL_CUSTOM_PTR_KEYS\fR 25
Keys are pointers to an arbitrary type, and are stored in the entry. Hashing
and comparison is determined by \fItypePtr\fR. The Tcl_HashKeyType 
structure is described in the section 
\fBTHE TCL_HASHKEYTYPE STRUCTURE\fR below.
d116 1
a116 1
If \fIkeyType\fR is not one of the above,
d206 1
a206 73
.SH "THE TCL_HASHKEYTYPE STRUCTURE"
.PP
Extension writers can define new hash key types by defining four
procedures, initializing a Tcl_HashKeyType structure to describe
the type, and calling \fBTcl_InitCustomHashTable\fR.
The \fBTcl_HashKeyType\fR structure is defined as follows:
.CS
typedef struct Tcl_HashKeyType {
    int \fIversion\fR;
    int \fIflags\fR;
    Tcl_HashKeyProc *\fIhashKeyProc\fR;
    Tcl_CompareHashKeysProc *\fIcompareKeysProc\fR;
    Tcl_AllocHashEntryProc *\fIallocEntryProc\fR;
    Tcl_FreeHashEntryProc *\fIfreeEntryProc\fR;
} Tcl_HashKeyType;
.CE
.PP
The \fIversion\fR member is the version of the table. If this
structure is extended in future then the version can be used
to distinguish between different structures. It should be set
to \fBTCL_HASH_KEY_TYPE_VERSION\fR.
.PP
The \fIflags\fR member is one or more of the following values OR'ed together:
.IP \fBTCL_HASH_KEY_RANDOMIZE_HASH\fR 25
There are some things, pointers for example which don't hash well 
because they do not use the lower bits. If this flag is set then the
hash table will attempt to rectify this by randomising the bits and 
then using the upper N bits as the index into the table.
.PP
The \fIhashKeyProc\fR member contains the address of a function 
called to calculate a hash value for the key.
.CS
typedef unsigned int (Tcl_HashKeyProc) (
    Tcl_HashTable *\fItablePtr\fR,
    VOID *\fIkeyPtr\fR);
.CE
If this is NULL then \fIkeyPtr\fR is used and 
\fBTCL_HASH_KEY_RANDOMIZE_HASH\fR is assumed.
.PP
The \fIcompareKeysProc\fR member contains the address of a function 
called to compare two keys.
.CS
typedef int (Tcl_CompareHashKeysProc) (VOID *\fIkeyPtr\fR,
    Tcl_HashEntry *\fIhPtr\fR);
.CE
If this is NULL then the \fIkeyPtr\fR pointers are compared.
If the keys don't match then the function returns 0, otherwise
it returns 1.
.PP
The \fIallocEntryProc\fR member contains the address of a function 
called to allocate space for an entry and initialise the key.
.CS
typedef Tcl_HashEntry *(Tcl_AllocHashEntryProc) (
    Tcl_HashTable *\fItablePtr\fR, VOID *\fIkeyPtr\fR);
.CE
If this is NULL then Tcl_Alloc is used to allocate enough space for a
Tcl_HashEntry and the key pointer is assigned to key.oneWordValue.
String keys and array keys use this function to allocate enough 
space for the entry and the key in one block, rather than doing
it in two blocks. This saves space for a pointer to the key from
the entry and another memory allocation. Tcl_Obj * keys use this 
function to allocate enough space for an entry and increment the 
reference count on the object.
If 
.PP
The \fIfreeEntryProc\fR member contains the address of a function 
called to free space for an entry.
.CS
typedef void (Tcl_FreeHashEntryProc) (Tcl_HashEntry *\fIhPtr\fR);
.CE
If this is NULL then Tcl_Free is used to free the space for the 
entry. Tcl_Obj * keys use this function to decrement the
reference count on the object.
@


