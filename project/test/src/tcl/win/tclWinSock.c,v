head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.58
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.56
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.54
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.52
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.50
	gdb_7_0-branch:1.5.0.48
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tcl8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.46
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.44
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.42
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.40
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.38
	gdb_6_5-2006-05-14-branchpoint:1.5
	readline_5_1-import-branch:1.5.0.36
	readline_5_1-import-branchpoint:1.5
	gdb_6_4-branch:1.5.0.34
	gdb_6_4-2005-11-01-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.32
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	ezannoni_pie-20040323-branch:1.5.0.30
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.28
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.26
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.24
	cagney_x86i386-20030821-branch:1.5.0.22
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.20
	gdb_6_0-2003-06-23-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.18
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.16
	cagney_writestrings-20030508-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.14
	cagney_fileio-20030521-branchpoint:1.5
	carlton_dictionary-20030430-merge:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.12
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.10
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.8
	cagney_lazyid-20030317-branchpoint:1.5
	offbyone-20030313-branch:1.5.0.6
	offbyone-20030313-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.4
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.2
	interps-20030202-branchpoint:1.5
	TCL8_4_1:1.1.1.3
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.2
	TCL_8_4_1:1.1.1.3
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.4
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TCL_8_4_0:1.1.1.3
	carlton_dictionary-branch:1.2.0.16
	carlton_dictionary-20020920-branchpoint:1.2
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.14
	gdb_5_3-branch:1.2.0.12
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.10
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.8
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.6
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TCL_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	dejagnu-2000-02-04:1.1.1.1
	dejagnu-2000-01-31:1.1.1.1
	dejagnu-2000-01-24:1.1.1.1
	dejagnu-2000-01-17:1.1.1.1
	dejagnu-2000-01-10:1.1.1.1
	dejagnu-2000-01-04:1.1.1.1
	dejagnu-1999-12-21:1.1.1.1
	dejagnu-1999-12-13:1.1.1.1
	dejagnu-1999-12-07:1.1.1.1
	dejagnu-1999-12-06:1.1.1.1
	dejagnu-1999-11-15:1.1.1.1
	dejagnu-1999-11-08:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.5
date	2003.01.21.19.40.23;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.26.19.48.07;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.37.11;	author kseitz;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2001.09.09.23.56.11;	author irox;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2002.09.27.21.49.15;	author kseitz;	state Exp;
branches;
next	;

1.3.4.1
date	2003.12.14.20.28.56;	author drow;	state Exp;
branches;
next	;

1.2.16.1
date	2002.12.23.19.40.58;	author carlton;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2003.02.07.19.18.25;	author carlton;	state Exp;
branches;
next	;

1.1.1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.09.22.41.00;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.19.56.46;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tcl 8.4.1
@
text
@/* 
 * tclWinSock.c --
 *
 *	This file contains Windows-specific socket related code.
 *
 * Copyright (c) 1995-1997 Sun Microsystems, Inc.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tclWinSock.c,v 1.26 2002/05/24 18:57:09 andreas_kupries Exp $
 */

#include "tclWinInt.h"

/*
 * The following variable is used to tell whether this module has been
 * initialized.
 */

static int initialized = 0;

static int  hostnameInitialized = 0;
static char hostname[255];	/* This buffer should be big enough for
                                 * hostname plus domain name. */

TCL_DECLARE_MUTEX(socketMutex)

/*
 * The following structure contains pointers to all of the WinSock API entry
 * points used by Tcl.  It is initialized by InitSockets.  Since we
 * dynamically load Winsock.dll on demand, we must use this function table
 * to refer to functions in the socket API.
 */

static struct {
    HINSTANCE hInstance;	/* Handle to WinSock library. */
    SOCKET (PASCAL FAR *accept)(SOCKET s, struct sockaddr FAR *addr,
	    int FAR *addrlen);
    int (PASCAL FAR *bind)(SOCKET s, const struct sockaddr FAR *addr,
	    int namelen);
    int (PASCAL FAR *closesocket)(SOCKET s);
    int (PASCAL FAR *connect)(SOCKET s, const struct sockaddr FAR *name,
	    int namelen);
    int (PASCAL FAR *ioctlsocket)(SOCKET s, long cmd, u_long FAR *argp);
    int (PASCAL FAR *getsockopt)(SOCKET s, int level, int optname,
	    char FAR * optval, int FAR *optlen);
    u_short (PASCAL FAR *htons)(u_short hostshort);
    unsigned long (PASCAL FAR *inet_addr)(const char FAR * cp);
    char FAR * (PASCAL FAR *inet_ntoa)(struct in_addr in);
    int (PASCAL FAR *listen)(SOCKET s, int backlog);
    u_short (PASCAL FAR *ntohs)(u_short netshort);
    int (PASCAL FAR *recv)(SOCKET s, char FAR * buf, int len, int flags);
    int (PASCAL FAR *select)(int nfds, fd_set FAR * readfds,
	    fd_set FAR * writefds, fd_set FAR * exceptfds,
	    const struct timeval FAR * tiemout);
    int (PASCAL FAR *send)(SOCKET s, const char FAR * buf, int len, int flags);
    int (PASCAL FAR *setsockopt)(SOCKET s, int level, int optname,
	    const char FAR * optval, int optlen);
    int (PASCAL FAR *shutdown)(SOCKET s, int how);
    SOCKET (PASCAL FAR *socket)(int af, int type, int protocol);
    struct hostent FAR * (PASCAL FAR *gethostbyname)(const char FAR * name);
    struct hostent FAR * (PASCAL FAR *gethostbyaddr)(const char FAR *addr,
            int addrlen, int addrtype);
    int (PASCAL FAR *gethostname)(char FAR * name, int namelen);
    int (PASCAL FAR *getpeername)(SOCKET sock, struct sockaddr FAR *name,
            int FAR *namelen);
    struct servent FAR * (PASCAL FAR *getservbyname)(const char FAR * name,
	    const char FAR * proto);
    int (PASCAL FAR *getsockname)(SOCKET sock, struct sockaddr FAR *name,
            int FAR *namelen);
    int (PASCAL FAR *WSAStartup)(WORD wVersionRequired, LPWSADATA lpWSAData);
    int (PASCAL FAR *WSACleanup)(void);
    int (PASCAL FAR *WSAGetLastError)(void);
    int (PASCAL FAR *WSAAsyncSelect)(SOCKET s, HWND hWnd, u_int wMsg,
	    long lEvent);
} winSock;

/*
 * The following defines declare the messages used on socket windows.
 */

#define SOCKET_MESSAGE	WM_USER+1
#define SOCKET_SELECT	WM_USER+2
#define SOCKET_TERMINATE WM_USER+3
#define SELECT          TRUE
#define UNSELECT	FALSE

/*
 * The following structure is used to store the data associated with
 * each socket.
 */

typedef struct SocketInfo {
    Tcl_Channel channel;	   /* Channel associated with this socket. */
    SOCKET socket;		   /* Windows SOCKET handle. */
    int flags;			   /* Bit field comprised of the flags
				    * described below.  */
    int watchEvents;		   /* OR'ed combination of FD_READ, FD_WRITE,
                                    * FD_CLOSE, FD_ACCEPT and FD_CONNECT that
				    * indicate which events are interesting. */
    int readyEvents;		   /* OR'ed combination of FD_READ, FD_WRITE,
                                    * FD_CLOSE, FD_ACCEPT and FD_CONNECT that
				    * indicate which events have occurred. */
    int selectEvents;		   /* OR'ed combination of FD_READ, FD_WRITE,
                                    * FD_CLOSE, FD_ACCEPT and FD_CONNECT that
				    * indicate which events are currently
				    * being selected. */
    int acceptEventCount;          /* Count of the current number of FD_ACCEPTs
				    * that have arrived and not processed. */
    Tcl_TcpAcceptProc *acceptProc; /* Proc to call on accept. */
    ClientData acceptProcData;	   /* The data for the accept proc. */
    int lastError;		   /* Error code from last message. */
    struct SocketInfo *nextPtr;	   /* The next socket on the global socket
				    * list. */
} SocketInfo;

/*
 * The following structure is what is added to the Tcl event queue when
 * a socket event occurs.
 */

typedef struct SocketEvent {
    Tcl_Event header;		/* Information that is standard for
				 * all events. */
    SOCKET socket;		/* Socket descriptor that is ready.  Used
				 * to find the SocketInfo structure for
				 * the file (can't point directly to the
				 * SocketInfo structure because it could
				 * go away while the event is queued). */
} SocketEvent;

/*
 * This defines the minimum buffersize maintained by the kernel.
 */

#define TCP_BUFFER_SIZE 4096

/*
 * The following macros may be used to set the flags field of
 * a SocketInfo structure.
 */

#define SOCKET_ASYNC		(1<<0)	/* The socket is in blocking mode. */
#define SOCKET_EOF		(1<<1)	/* A zero read happened on
					 * the socket. */
#define SOCKET_ASYNC_CONNECT	(1<<2)	/* This socket uses async connect. */
#define SOCKET_PENDING		(1<<3)	/* A message has been sent
					 * for this socket */

typedef struct ThreadSpecificData {
    /*
     * Every open socket has an entry on the following list.
     */
    
    HWND hwnd;		    /* Handle to window for socket messages. */
    HANDLE socketThread;    /* Thread handling the window */
    Tcl_ThreadId threadId;  /* Parent thread. */
    HANDLE readyEvent;      /* Event indicating that a socket event is ready.
			     * Also used to indicate that the socketThread has
			     * been initialized and has started. */
    HANDLE socketListLock;  /* Win32 Event to lock the socketList */
    SocketInfo *socketList;
} ThreadSpecificData;

static Tcl_ThreadDataKey dataKey;
static WNDCLASSA windowClass;

/*
 * Static functions defined in this file.
 */

static SocketInfo *	CreateSocket _ANSI_ARGS_((Tcl_Interp *interp,
			    int port, CONST char *host, int server,
			    CONST char *myaddr, int myport, int async));
static int		CreateSocketAddress _ANSI_ARGS_(
			    (struct sockaddr_in *sockaddrPtr,
			    CONST char *host, int port));
static void		InitSockets _ANSI_ARGS_((void));
static SocketInfo *	NewSocketInfo _ANSI_ARGS_((SOCKET socket));
static void		SocketCheckProc _ANSI_ARGS_((ClientData clientData,
			    int flags));
static int		SocketEventProc _ANSI_ARGS_((Tcl_Event *evPtr,
			    int flags));
static void		SocketExitHandler _ANSI_ARGS_((ClientData clientData));
static LRESULT CALLBACK	SocketProc _ANSI_ARGS_((HWND hwnd, UINT message,
			    WPARAM wParam, LPARAM lParam));
static void		SocketSetupProc _ANSI_ARGS_((ClientData clientData,
			    int flags));
static void		SocketThreadExitHandler _ANSI_ARGS_((ClientData clientData));
static int		SocketsEnabled _ANSI_ARGS_((void));
static void		TcpAccept _ANSI_ARGS_((SocketInfo *infoPtr));
static int		TcpBlockProc _ANSI_ARGS_((ClientData instanceData,
			    int mode));
static int		TcpCloseProc _ANSI_ARGS_((ClientData instanceData,
	            	    Tcl_Interp *interp));
static int		TcpGetOptionProc _ANSI_ARGS_((ClientData instanceData,
		            Tcl_Interp *interp, CONST char *optionName,
			    Tcl_DString *optionValue));
static int		TcpInputProc _ANSI_ARGS_((ClientData instanceData,
	            	    char *buf, int toRead, int *errorCode));
static int		TcpOutputProc _ANSI_ARGS_((ClientData instanceData,
	            	    CONST char *buf, int toWrite, int *errorCode));
static void		TcpWatchProc _ANSI_ARGS_((ClientData instanceData,
		            int mask));
static int		TcpGetHandleProc _ANSI_ARGS_((ClientData instanceData,
		            int direction, ClientData *handlePtr));
static int		WaitForSocketEvent _ANSI_ARGS_((SocketInfo *infoPtr,
		            int events, int *errorCodePtr));
static DWORD WINAPI     SocketThread _ANSI_ARGS_((LPVOID arg));

/*
 * This structure describes the channel type structure for TCP socket
 * based IO.
 */

static Tcl_ChannelType tcpChannelType = {
    "tcp",			/* Type name. */
    TCL_CHANNEL_VERSION_2,	/* v2 channel */
    TcpCloseProc,		/* Close proc. */
    TcpInputProc,		/* Input proc. */
    TcpOutputProc,		/* Output proc. */
    NULL,			/* Seek proc. */
    NULL,			/* Set option proc. */
    TcpGetOptionProc,		/* Get option proc. */
    TcpWatchProc,		/* Set up notifier to watch this channel. */
    TcpGetHandleProc,		/* Get an OS handle from channel. */
    NULL,			/* close2proc. */
    TcpBlockProc,		/* Set socket into (non-)blocking mode. */
    NULL,			/* flush proc. */
    NULL,			/* handler proc. */
};

/*
 * Define version of Winsock required by Tcl.
 */

#define WSA_VERSION_REQD MAKEWORD(1,1)

/*
 *----------------------------------------------------------------------
 *
 * InitSockets --
 *
 *	Initialize the socket module.  Attempts to load the wsock32.dll
 *	library and set up the winSock function table.  If successful,
 *	registers the event window for the socket notifier code.
 *
 *	Assumes Mutex is held.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Dynamically loads wsock32.dll, and registers a new window
 *	class and creates a window for use in asynchronous socket
 *	notification.
 *
 *----------------------------------------------------------------------
 */

static void
InitSockets()
{
    DWORD id;
    WSADATA wsaData;
    ThreadSpecificData *tsdPtr = 
	(ThreadSpecificData *)TclThreadDataKeyGet(&dataKey);

    if (! initialized) {
	initialized = 1;
	Tcl_CreateExitHandler(SocketExitHandler, (ClientData) NULL);

	winSock.hInstance = LoadLibraryA("wsock32.dll");

	/*
	 * Initialize the function table.
	 */

	if (!SocketsEnabled()) {
	    return;
	}
    
	winSock.accept = (SOCKET (PASCAL FAR *)(SOCKET s,
		struct sockaddr FAR *addr, int FAR *addrlen))
	    GetProcAddress(winSock.hInstance, "accept");
	winSock.bind = (int (PASCAL FAR *)(SOCKET s,
		const struct sockaddr FAR *addr, int namelen))
	    GetProcAddress(winSock.hInstance, "bind");
	winSock.closesocket = (int (PASCAL FAR *)(SOCKET s))
	    GetProcAddress(winSock.hInstance, "closesocket");
	winSock.connect = (int (PASCAL FAR *)(SOCKET s,
		const struct sockaddr FAR *name, int namelen))
	    GetProcAddress(winSock.hInstance, "connect");
	winSock.ioctlsocket = (int (PASCAL FAR *)(SOCKET s, long cmd,
		u_long FAR *argp))
	    GetProcAddress(winSock.hInstance, "ioctlsocket");
	winSock.getsockopt = (int (PASCAL FAR *)(SOCKET s,
		int level, int optname, char FAR * optval, int FAR *optlen))
	    GetProcAddress(winSock.hInstance, "getsockopt");
	winSock.htons = (u_short (PASCAL FAR *)(u_short hostshort))
	    GetProcAddress(winSock.hInstance, "htons");
	winSock.inet_addr = (unsigned long (PASCAL FAR *)(const char FAR *cp))
	    GetProcAddress(winSock.hInstance, "inet_addr");
	winSock.inet_ntoa = (char FAR * (PASCAL FAR *)(struct in_addr in))
	    GetProcAddress(winSock.hInstance, "inet_ntoa");
	winSock.listen = (int (PASCAL FAR *)(SOCKET s, int backlog))
	    GetProcAddress(winSock.hInstance, "listen");
	winSock.ntohs = (u_short (PASCAL FAR *)(u_short netshort))
	    GetProcAddress(winSock.hInstance, "ntohs");
	winSock.recv = (int (PASCAL FAR *)(SOCKET s, char FAR * buf,
		int len, int flags)) GetProcAddress(winSock.hInstance, "recv");
	winSock.select = (int (PASCAL FAR *)(int nfds, fd_set FAR * readfds,
		fd_set FAR * writefds, fd_set FAR * exceptfds,
		const struct timeval FAR * tiemout))
	    GetProcAddress(winSock.hInstance, "select");
	winSock.send = (int (PASCAL FAR *)(SOCKET s, const char FAR * buf,
		int len, int flags)) GetProcAddress(winSock.hInstance, "send");
	winSock.setsockopt = (int (PASCAL FAR *)(SOCKET s, int level,
		int optname, const char FAR * optval, int optlen))
	    GetProcAddress(winSock.hInstance, "setsockopt");
	winSock.shutdown = (int (PASCAL FAR *)(SOCKET s, int how))
	    GetProcAddress(winSock.hInstance, "shutdown");
	winSock.socket = (SOCKET (PASCAL FAR *)(int af, int type,
		int protocol)) GetProcAddress(winSock.hInstance, "socket");
	winSock.gethostbyaddr = (struct hostent FAR * (PASCAL FAR *)
		(const char FAR *addr, int addrlen, int addrtype))
	    GetProcAddress(winSock.hInstance, "gethostbyaddr");
	winSock.gethostbyname = (struct hostent FAR * (PASCAL FAR *)
		(const char FAR *name))
	    GetProcAddress(winSock.hInstance, "gethostbyname");
	winSock.gethostname = (int (PASCAL FAR *)(char FAR * name,
		int namelen)) GetProcAddress(winSock.hInstance, "gethostname");
	winSock.getpeername = (int (PASCAL FAR *)(SOCKET sock,
		struct sockaddr FAR *name, int FAR *namelen))
	    GetProcAddress(winSock.hInstance, "getpeername");
	winSock.getservbyname = (struct servent FAR * (PASCAL FAR *)
		(const char FAR * name, const char FAR * proto))
	    GetProcAddress(winSock.hInstance, "getservbyname");
	winSock.getsockname = (int (PASCAL FAR *)(SOCKET sock,
		struct sockaddr FAR *name, int FAR *namelen))
	    GetProcAddress(winSock.hInstance, "getsockname");
	winSock.WSAStartup = (int (PASCAL FAR *)(WORD wVersionRequired,
		LPWSADATA lpWSAData)) GetProcAddress(winSock.hInstance, "WSAStartup");
	winSock.WSACleanup = (int (PASCAL FAR *)(void))
	    GetProcAddress(winSock.hInstance, "WSACleanup");
	winSock.WSAGetLastError = (int (PASCAL FAR *)(void))
	    GetProcAddress(winSock.hInstance, "WSAGetLastError");
	winSock.WSAAsyncSelect = (int (PASCAL FAR *)(SOCKET s, HWND hWnd,
		u_int wMsg, long lEvent))
	    GetProcAddress(winSock.hInstance, "WSAAsyncSelect");
    
	/*
	 * Now check that all fields are properly initialized. If not, return
	 * zero to indicate that we failed to initialize properly.
	 */
    
	if ((winSock.hInstance == NULL) ||
		(winSock.accept == NULL) ||
		(winSock.bind == NULL) ||
		(winSock.closesocket == NULL) ||
		(winSock.connect == NULL) ||
		(winSock.ioctlsocket == NULL) ||
		(winSock.getsockopt == NULL) ||
		(winSock.htons == NULL) ||
		(winSock.inet_addr == NULL) ||
		(winSock.inet_ntoa == NULL) ||
		(winSock.listen == NULL) ||
		(winSock.ntohs == NULL) ||
		(winSock.recv == NULL) ||
		(winSock.select == NULL) ||
		(winSock.send == NULL) ||
		(winSock.setsockopt == NULL) ||
		(winSock.socket == NULL) ||
		(winSock.gethostbyname == NULL) ||
		(winSock.gethostbyaddr == NULL) ||
		(winSock.gethostname == NULL) ||
		(winSock.getpeername == NULL) ||
		(winSock.getservbyname == NULL) ||
		(winSock.getsockname == NULL) ||
		(winSock.WSAStartup == NULL) ||
		(winSock.WSACleanup == NULL) ||
		(winSock.WSAGetLastError == NULL) ||
		(winSock.WSAAsyncSelect == NULL)) {
	    goto unloadLibrary;
	}
	
	/*
	 * Create the async notification window with a new class.  We
	 * must create a new class to avoid a Windows 95 bug that causes
	 * us to get the wrong message number for socket events if the
	 * message window is a subclass of a static control.
	 */
    
	windowClass.style = 0;
	windowClass.cbClsExtra = 0;
	windowClass.cbWndExtra = 0;
	windowClass.hInstance = TclWinGetTclInstance();
	windowClass.hbrBackground = NULL;
	windowClass.lpszMenuName = NULL;
	windowClass.lpszClassName = "TclSocket";
	windowClass.lpfnWndProc = SocketProc;
	windowClass.hIcon = NULL;
	windowClass.hCursor = NULL;

	if (!RegisterClassA(&windowClass)) {
	    TclWinConvertError(GetLastError());
	    (*winSock.WSACleanup)();
	    goto unloadLibrary;
	}
	
	/*
	 * Initialize the winsock library and check the version number.
	 */
    
	if ((*winSock.WSAStartup)(WSA_VERSION_REQD, &wsaData) != 0) {
	    goto unloadLibrary;
	}
	if (wsaData.wVersion != WSA_VERSION_REQD) {
	    (*winSock.WSACleanup)();
	    goto unloadLibrary;
	}
    }

    /*
     * Check for per-thread initialization.
     */

    if (tsdPtr == NULL) {
	tsdPtr = TCL_TSD_INIT(&dataKey);
	tsdPtr->socketList = NULL;
	tsdPtr->hwnd = NULL;

	tsdPtr->threadId = Tcl_GetCurrentThread();
	
	tsdPtr->readyEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	tsdPtr->socketListLock = CreateEvent(NULL, FALSE, TRUE, NULL);
	tsdPtr->socketThread = CreateThread(NULL, 8000, SocketThread,
		tsdPtr, 0, &id);
	SetThreadPriority(tsdPtr->socketThread, THREAD_PRIORITY_HIGHEST); 

	if (tsdPtr->socketThread == NULL) {
	    goto unloadLibrary;
	}
	

	/*
	 * Wait for the thread to signal that the window has
	 * been created and is ready to go.  Timeout after twenty
	 * seconds.
	 */
	
	if (WaitForSingleObject(tsdPtr->readyEvent, 20000) == WAIT_TIMEOUT) {
	    goto unloadLibrary;
	}

	if (tsdPtr->hwnd == NULL) {
	    goto unloadLibrary;
	}
	
	Tcl_CreateEventSource(SocketSetupProc, SocketCheckProc, NULL);
	Tcl_CreateThreadExitHandler(SocketThreadExitHandler, NULL);
    }
    return;

unloadLibrary:
    if (tsdPtr != NULL) {
	if (tsdPtr->hwnd != NULL) {
	    DestroyWindow(tsdPtr->hwnd);
	}
	if (tsdPtr->socketThread != NULL) {
	    TerminateThread(tsdPtr->socketThread, 0);
	    tsdPtr->socketThread = NULL;
	}
	CloseHandle(tsdPtr->readyEvent);
	CloseHandle(tsdPtr->socketListLock);
    }
    FreeLibrary(winSock.hInstance);
    winSock.hInstance = NULL;
    return;
}

/*
 *----------------------------------------------------------------------
 *
 * SocketsEnabled --
 *
 *	Check that the WinSock DLL is loaded and ready.
 *
 * Results:
 *	1 if it is.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

    /* ARGSUSED */
static int
SocketsEnabled()
{
    int enabled;
    Tcl_MutexLock(&socketMutex);
    enabled = (winSock.hInstance != NULL);
    Tcl_MutexUnlock(&socketMutex);
    return enabled;
}


/*
 *----------------------------------------------------------------------
 *
 * SocketExitHandler --
 *
 *	Callback invoked during exit clean up to delete the socket
 *	communication window and to release the WinSock DLL.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

    /* ARGSUSED */
static void
SocketExitHandler(clientData)
    ClientData clientData;              /* Not used. */
{
    Tcl_MutexLock(&socketMutex);
    if (winSock.hInstance) {
	UnregisterClassA("TclSocket", TclWinGetTclInstance());
	(*winSock.WSACleanup)();
	FreeLibrary(winSock.hInstance);
	winSock.hInstance = NULL;
    }
    initialized = 0;
    hostnameInitialized = 0;
    Tcl_MutexUnlock(&socketMutex);
}

/*
 *----------------------------------------------------------------------
 *
 * SocketThreadExitHandler --
 *
 *	Callback invoked during thread clean up to delete the socket
 *	event source.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Delete the event source.
 *
 *----------------------------------------------------------------------
 */

    /* ARGSUSED */
static void
SocketThreadExitHandler(clientData)
    ClientData clientData;              /* Not used. */
{
    ThreadSpecificData *tsdPtr = 
	(ThreadSpecificData *)TclThreadDataKeyGet(&dataKey);

    if (tsdPtr->socketThread != NULL) {

	PostMessage(tsdPtr->hwnd, SOCKET_TERMINATE, 0, 0);

        /*
	 * Wait for the thread to terminate.  This ensures that we are
	 * completely cleaned up before we leave this function. 
	 */

	WaitForSingleObject(tsdPtr->socketThread, INFINITE);
	CloseHandle(tsdPtr->socketThread);
	CloseHandle(tsdPtr->readyEvent);
	CloseHandle(tsdPtr->socketListLock);

    }
    if (tsdPtr->hwnd != NULL) {
	DestroyWindow(tsdPtr->hwnd);
    }
    
    Tcl_DeleteEventSource(SocketSetupProc, SocketCheckProc, NULL);
}

/*
 *----------------------------------------------------------------------
 *
 * TclpHasSockets --
 *
 *	This function determines whether sockets are available on the
 *	current system and returns an error in interp if they are not.
 *	Note that interp may be NULL.
 *
 * Results:
 *	Returns TCL_OK if the system supports sockets, or TCL_ERROR with
 *	an error in interp.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
TclpHasSockets(interp)
    Tcl_Interp *interp;
{
    Tcl_MutexLock(&socketMutex);
    InitSockets();
    Tcl_MutexUnlock(&socketMutex);

    if (SocketsEnabled()) {
	return TCL_OK;
    }
    if (interp != NULL) {
	Tcl_AppendResult(interp, "sockets are not available on this system",
		NULL);
    }
    return TCL_ERROR;
}

/*
 *----------------------------------------------------------------------
 *
 * SocketSetupProc --
 *
 *	This procedure is invoked before Tcl_DoOneEvent blocks waiting
 *	for an event.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Adjusts the block time if needed.
 *
 *----------------------------------------------------------------------
 */

void
SocketSetupProc(data, flags)
    ClientData data;		/* Not used. */
    int flags;			/* Event flags as passed to Tcl_DoOneEvent. */
{
    SocketInfo *infoPtr;
    Tcl_Time blockTime = { 0, 0 };
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    if (!(flags & TCL_FILE_EVENTS)) {
	return;
    }
    
    /*
     * Check to see if there is a ready socket.  If so, poll.
     */

    WaitForSingleObject(tsdPtr->socketListLock, INFINITE);
    for (infoPtr = tsdPtr->socketList; infoPtr != NULL; 
	    infoPtr = infoPtr->nextPtr) {
	if (infoPtr->readyEvents & infoPtr->watchEvents) {
	    Tcl_SetMaxBlockTime(&blockTime);
	    break;
	}
    }
    SetEvent(tsdPtr->socketListLock);
}

/*
 *----------------------------------------------------------------------
 *
 * SocketCheckProc --
 *
 *	This procedure is called by Tcl_DoOneEvent to check the socket
 *	event source for events. 
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	May queue an event.
 *
 *----------------------------------------------------------------------
 */

static void
SocketCheckProc(data, flags)
    ClientData data;		/* Not used. */
    int flags;			/* Event flags as passed to Tcl_DoOneEvent. */
{
    SocketInfo *infoPtr;
    SocketEvent *evPtr;
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    if (!(flags & TCL_FILE_EVENTS)) {
	return;
    }
    
    /*
     * Queue events for any ready sockets that don't already have events
     * queued (caused by persistent states that won't generate WinSock
     * events).
     */

    WaitForSingleObject(tsdPtr->socketListLock, INFINITE);
    for (infoPtr = tsdPtr->socketList; infoPtr != NULL; 
	    infoPtr = infoPtr->nextPtr) {
	if ((infoPtr->readyEvents & infoPtr->watchEvents)
		&& !(infoPtr->flags & SOCKET_PENDING)) {
	    infoPtr->flags |= SOCKET_PENDING;
	    evPtr = (SocketEvent *) ckalloc(sizeof(SocketEvent));
	    evPtr->header.proc = SocketEventProc;
	    evPtr->socket = infoPtr->socket;
	    Tcl_QueueEvent((Tcl_Event *) evPtr, TCL_QUEUE_TAIL);
	}
    }
    SetEvent(tsdPtr->socketListLock);
}

/*
 *----------------------------------------------------------------------
 *
 * SocketEventProc --
 *
 *	This procedure is called by Tcl_ServiceEvent when a socket event
 *	reaches the front of the event queue.  This procedure is
 *	responsible for notifying the generic channel code.
 *
 * Results:
 *	Returns 1 if the event was handled, meaning it should be removed
 *	from the queue.  Returns 0 if the event was not handled, meaning
 *	it should stay on the queue.  The only time the event isn't
 *	handled is if the TCL_FILE_EVENTS flag bit isn't set.
 *
 * Side effects:
 *	Whatever the channel callback procedures do.
 *
 *----------------------------------------------------------------------
 */

static int
SocketEventProc(evPtr, flags)
    Tcl_Event *evPtr;		/* Event to service. */
    int flags;			/* Flags that indicate what events to
				 * handle, such as TCL_FILE_EVENTS. */
{
    SocketInfo *infoPtr;
    SocketEvent *eventPtr = (SocketEvent *) evPtr;
    int mask = 0;
    int events;
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    if (!(flags & TCL_FILE_EVENTS)) {
	return 0;
    }

    /*
     * Find the specified socket on the socket list.
     */

    WaitForSingleObject(tsdPtr->socketListLock, INFINITE);
    for (infoPtr = tsdPtr->socketList; infoPtr != NULL; 
	    infoPtr = infoPtr->nextPtr) {
	if (infoPtr->socket == eventPtr->socket) {
	    break;
	}
    }
    SetEvent(tsdPtr->socketListLock);
    
    /*
     * Discard events that have gone stale.
     */

    if (!infoPtr) {
	return 1;
    }

    infoPtr->flags &= ~SOCKET_PENDING;

    /*
     * Handle connection requests directly.
     */

    if (infoPtr->readyEvents & FD_ACCEPT) {
	TcpAccept(infoPtr);
	return 1;
    }


    /*
     * Mask off unwanted events and compute the read/write mask so 
     * we can notify the channel.
     */

    events = infoPtr->readyEvents & infoPtr->watchEvents;

    if (events & FD_CLOSE) {
	/*
	 * If the socket was closed and the channel is still interested
	 * in read events, then we need to ensure that we keep polling
	 * for this event until someone does something with the channel.
	 * Note that we do this before calling Tcl_NotifyChannel so we don't
	 * have to watch out for the channel being deleted out from under
	 * us.  This may cause a redundant trip through the event loop, but
	 * it's simpler than trying to do unwind protection.
	 */

	Tcl_Time blockTime = { 0, 0 };
	Tcl_SetMaxBlockTime(&blockTime);
	mask |= TCL_READABLE;
    } else if (events & FD_READ) {
	fd_set readFds;
	struct timeval timeout;

	/*
	 * We must check to see if data is really available, since someone
	 * could have consumed the data in the meantime.  Turn off async
	 * notification so select will work correctly.	If the socket is
	 * still readable, notify the channel driver, otherwise reset the
	 * async select handler and keep waiting.
	 */

	SendMessage(tsdPtr->hwnd, SOCKET_SELECT,
		(WPARAM) UNSELECT, (LPARAM) infoPtr);

	FD_ZERO(&readFds);
	FD_SET(infoPtr->socket, &readFds);
	timeout.tv_usec = 0;
	timeout.tv_sec = 0;
 
	if ((*winSock.select)(0, &readFds, NULL, NULL, &timeout) != 0) {
	    mask |= TCL_READABLE;
	} else {
	    infoPtr->readyEvents &= ~(FD_READ);
	    SendMessage(tsdPtr->hwnd, SOCKET_SELECT,
		    (WPARAM) SELECT, (LPARAM) infoPtr);
	}
    }
    if (events & (FD_WRITE | FD_CONNECT)) {
	mask |= TCL_WRITABLE;
    }

    if (mask) {
	Tcl_NotifyChannel(infoPtr->channel, mask);
    }
    return 1;
}

/*
 *----------------------------------------------------------------------
 *
 * TcpBlockProc --
 *
 *	Sets a socket into blocking or non-blocking mode.
 *
 * Results:
 *	0 if successful, errno if there was an error.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static int
TcpBlockProc(instanceData, mode)
    ClientData	instanceData;	/* The socket to block/un-block. */
    int mode;			/* TCL_MODE_BLOCKING or
                                 * TCL_MODE_NONBLOCKING. */
{
    SocketInfo *infoPtr = (SocketInfo *) instanceData;

    if (mode == TCL_MODE_NONBLOCKING) {
	infoPtr->flags |= SOCKET_ASYNC;
    } else {
	infoPtr->flags &= ~(SOCKET_ASYNC);
    }
    return 0;
}

/*
 *----------------------------------------------------------------------
 *
 * TcpCloseProc --
 *
 *	This procedure is called by the generic IO level to perform
 *	channel type specific cleanup on a socket based channel
 *	when the channel is closed.
 *
 * Results:
 *	0 if successful, the value of errno if failed.
 *
 * Side effects:
 *	Closes the socket.
 *
 *----------------------------------------------------------------------
 */

    /* ARGSUSED */
static int
TcpCloseProc(instanceData, interp)
    ClientData instanceData;	/* The socket to close. */
    Tcl_Interp *interp;		/* Unused. */
{
    SocketInfo *infoPtr = (SocketInfo *) instanceData;
    SocketInfo **nextPtrPtr;
    int errorCode = 0;
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    /*
     * Check that WinSock is initialized; do not call it if not, to
     * prevent system crashes. This can happen at exit time if the exit
     * handler for WinSock ran before other exit handlers that want to
     * use sockets.
     */

    if (SocketsEnabled()) {
        
	/*
         * Clean up the OS socket handle.  The default Windows setting
	 * for a socket is SO_DONTLINGER, which does a graceful shutdown
	 * in the background.
         */
    
        if ((*winSock.closesocket)(infoPtr->socket) == SOCKET_ERROR) {
            TclWinConvertWSAError((*winSock.WSAGetLastError)());
            errorCode = Tcl_GetErrno();
        }
    }

    /*
     * Remove the socket from socketList.
     */

    WaitForSingleObject(tsdPtr->socketListLock, INFINITE);
    for (nextPtrPtr = &(tsdPtr->socketList); (*nextPtrPtr) != NULL;
	 nextPtrPtr = &((*nextPtrPtr)->nextPtr)) {
	if ((*nextPtrPtr) == infoPtr) {
	    (*nextPtrPtr) = infoPtr->nextPtr;
	    break;
	}
    }
    SetEvent(tsdPtr->socketListLock);
    
    ckfree((char *) infoPtr);
    return errorCode;
}

/*
 *----------------------------------------------------------------------
 *
 * NewSocketInfo --
 *
 *	This function allocates and initializes a new SocketInfo
 *	structure.
 *
 * Results:
 *	Returns a newly allocated SocketInfo.
 *
 * Side effects:
 *	Adds the socket to the global socket list.
 *
 *----------------------------------------------------------------------
 */

static SocketInfo *
NewSocketInfo(socket)
    SOCKET socket;
{
    SocketInfo *infoPtr;
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    infoPtr = (SocketInfo *) ckalloc((unsigned) sizeof(SocketInfo));
    infoPtr->socket = socket;
    infoPtr->flags = 0;
    infoPtr->watchEvents = 0;
    infoPtr->readyEvents = 0;
    infoPtr->selectEvents = 0;
    infoPtr->acceptEventCount = 0;
    infoPtr->acceptProc = NULL;
    infoPtr->lastError = 0;

    WaitForSingleObject(tsdPtr->socketListLock, INFINITE);
    infoPtr->nextPtr = tsdPtr->socketList;
    tsdPtr->socketList = infoPtr;
    SetEvent(tsdPtr->socketListLock);
    
    return infoPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * CreateSocket --
 *
 *	This function opens a new socket and initializes the
 *	SocketInfo structure.
 *
 * Results:
 *	Returns a new SocketInfo, or NULL with an error in interp.
 *
 * Side effects:
 *	Adds a new socket to the socketList.
 *
 *----------------------------------------------------------------------
 */

static SocketInfo *
CreateSocket(interp, port, host, server, myaddr, myport, async)
    Tcl_Interp *interp;		/* For error reporting; can be NULL. */
    int port;			/* Port number to open. */
    CONST char *host;		/* Name of host on which to open port. */
    int server;			/* 1 if socket should be a server socket,
				 * else 0 for a client socket. */
    CONST char *myaddr;		/* Optional client-side address */
    int myport;			/* Optional client-side port */
    int async;			/* If nonzero, connect client socket
                                 * asynchronously. */
{
    u_long flag = 1;			/* Indicates nonblocking mode. */
    int asyncConnect = 0;		/* Will be 1 if async connect is
                                         * in progress. */
    struct sockaddr_in sockaddr;	/* Socket address */
    struct sockaddr_in mysockaddr;	/* Socket address for client */
    SOCKET sock;
    SocketInfo *infoPtr;		/* The returned value. */
    ThreadSpecificData *tsdPtr = 
	(ThreadSpecificData *)TclThreadDataKeyGet(&dataKey);

    /*
     * Check that WinSock is initialized; do not call it if not, to
     * prevent system crashes. This can happen at exit time if the exit
     * handler for WinSock ran before other exit handlers that want to
     * use sockets.
     */

    if (!SocketsEnabled()) {
        return NULL;
    }

    if (! CreateSocketAddress(&sockaddr, host, port)) {
	goto error;
    }
    if ((myaddr != NULL || myport != 0) &&
	    ! CreateSocketAddress(&mysockaddr, myaddr, myport)) {
	goto error;
    }

    sock = (*winSock.socket)(AF_INET, SOCK_STREAM, 0);
    if (sock == INVALID_SOCKET) {
	goto error;
    }

    /*
     * Win-NT has a misfeature that sockets are inherited in child
     * processes by default.  Turn off the inherit bit.
     */

    SetHandleInformation( (HANDLE) sock, HANDLE_FLAG_INHERIT, 0 );
	
    /*
     * Set kernel space buffering
     */

    TclSockMinimumBuffers(sock, TCP_BUFFER_SIZE);

    if (server) {
	/*
	 * Bind to the specified port.  Note that we must not call setsockopt
	 * with SO_REUSEADDR because Microsoft allows addresses to be reused
	 * even if they are still in use.
         *
         * Bind should not be affected by the socket having already been
         * set into nonblocking mode. If there is trouble, this is one place
         * to look for bugs.
	 */
    
	if ((*winSock.bind)(sock, (struct sockaddr *) &sockaddr,
		sizeof(sockaddr)) == SOCKET_ERROR) {
            goto error;
        }

        /*
         * Set the maximum number of pending connect requests to the
         * max value allowed on each platform (Win32 and Win32s may be
         * different, and there may be differences between TCP/IP stacks).
         */
        
	if ((*winSock.listen)(sock, SOMAXCONN) == SOCKET_ERROR) {
	    goto error;
	}

	/*
	 * Add this socket to the global list of sockets.
	 */

	infoPtr = NewSocketInfo(sock);

	/*
	 * Set up the select mask for connection request events.
	 */

	infoPtr->selectEvents = FD_ACCEPT;
	infoPtr->watchEvents |= FD_ACCEPT;

    } else {

        /*
         * Try to bind to a local port, if specified.
         */
        
	if (myaddr != NULL || myport != 0) { 
	    if ((*winSock.bind)(sock, (struct sockaddr *) &mysockaddr,
		    sizeof(struct sockaddr)) == SOCKET_ERROR) {
		goto error;
	    }
	}            
    
	/*
	 * Set the socket into nonblocking mode if the connect should be
	 * done in the background.
	 */
    
	if (async) {
	    if ((*winSock.ioctlsocket)(sock, FIONBIO, &flag) == SOCKET_ERROR) {
		goto error;
	    }
	}

	/*
	 * Attempt to connect to the remote socket.
	 */

	if ((*winSock.connect)(sock, (struct sockaddr *) &sockaddr,
		sizeof(sockaddr)) == SOCKET_ERROR) {
            TclWinConvertWSAError((*winSock.WSAGetLastError)());
	    if (Tcl_GetErrno() != EWOULDBLOCK) {
		goto error;
	    }

	    /*
	     * The connection is progressing in the background.
	     */

	    asyncConnect = 1;
        }

	/*
	 * Add this socket to the global list of sockets.
	 */

	infoPtr = NewSocketInfo(sock);

	/*
	 * Set up the select mask for read/write events.  If the connect
	 * attempt has not completed, include connect events.
	 */

	infoPtr->selectEvents = FD_READ | FD_WRITE | FD_CLOSE;
	if (asyncConnect) {
	    infoPtr->flags |= SOCKET_ASYNC_CONNECT;
	    infoPtr->selectEvents |= FD_CONNECT;
	}
    }

    /*
     * Register for interest in events in the select mask.  Note that this
     * automatically places the socket into non-blocking mode.
     */

    (*winSock.ioctlsocket)(sock, FIONBIO, &flag);
    SendMessage(tsdPtr->hwnd, SOCKET_SELECT,
	    (WPARAM) SELECT, (LPARAM) infoPtr);

    return infoPtr;

error:
    TclWinConvertWSAError((*winSock.WSAGetLastError)());
    if (interp != NULL) {
	Tcl_AppendResult(interp, "couldn't open socket: ",
		Tcl_PosixError(interp), (char *) NULL);
    }
    if (sock != INVALID_SOCKET) {
	(*winSock.closesocket)(sock);
    }
    return NULL;
}

/*
 *----------------------------------------------------------------------
 *
 * CreateSocketAddress --
 *
 *	This function initializes a sockaddr structure for a host and port.
 *
 * Results:
 *	1 if the host was valid, 0 if the host could not be converted to
 *	an IP address.
 *
 * Side effects:
 *	Fills in the *sockaddrPtr structure.
 *
 *----------------------------------------------------------------------
 */

static int
CreateSocketAddress(sockaddrPtr, host, port)
    struct sockaddr_in *sockaddrPtr;	/* Socket address */
    CONST char *host;			/* Host.  NULL implies INADDR_ANY */
    int port;				/* Port number */
{
    struct hostent *hostent;		/* Host database entry */
    struct in_addr addr;		/* For 64/32 bit madness */

    /*
     * Check that WinSock is initialized; do not call it if not, to
     * prevent system crashes. This can happen at exit time if the exit
     * handler for WinSock ran before other exit handlers that want to
     * use sockets.
     */

    if (!SocketsEnabled()) {
        Tcl_SetErrno(EFAULT);
        return 0;
    }

    (void) memset((char *) sockaddrPtr, '\0', sizeof(struct sockaddr_in));
    sockaddrPtr->sin_family = AF_INET;
    sockaddrPtr->sin_port = (*winSock.htons)((short) (port & 0xFFFF));
    if (host == NULL) {
	addr.s_addr = INADDR_ANY;
    } else {
        addr.s_addr = (*winSock.inet_addr)(host);
        if (addr.s_addr == INADDR_NONE) {
            hostent = (*winSock.gethostbyname)(host);
            if (hostent != NULL) {
                memcpy((char *) &addr,
                        (char *) hostent->h_addr_list[0],
                        (size_t) hostent->h_length);
            } else {
#ifdef	EHOSTUNREACH
                Tcl_SetErrno(EHOSTUNREACH);
#else
#ifdef ENXIO
                Tcl_SetErrno(ENXIO);
#endif
#endif
		return 0;	/* Error. */
	    }
	}
    }

    /*
     * NOTE: On 64 bit machines the assignment below is rumored to not
     * do the right thing. Please report errors related to this if you
     * observe incorrect behavior on 64 bit machines such as DEC Alphas.
     * Should we modify this code to do an explicit memcpy?
     */

    sockaddrPtr->sin_addr.s_addr = addr.s_addr;
    return 1;	/* Success. */
}

/*
 *----------------------------------------------------------------------
 *
 * WaitForSocketEvent --
 *
 *	Waits until one of the specified events occurs on a socket.
 *
 * Results:
 *	Returns 1 on success or 0 on failure, with an error code in
 *	errorCodePtr.
 *
 * Side effects:
 *	Processes socket events off the system queue.
 *
 *----------------------------------------------------------------------
 */

static int
WaitForSocketEvent(infoPtr, events, errorCodePtr)
    SocketInfo *infoPtr;	/* Information about this socket. */
    int events;			/* Events to look for. */
    int *errorCodePtr;		/* Where to store errors? */
{
    int result = 1;
    int oldMode;
    ThreadSpecificData *tsdPtr = 
	(ThreadSpecificData *)TclThreadDataKeyGet(&dataKey);

    /*
     * Be sure to disable event servicing so we are truly modal.
     */

    oldMode = Tcl_SetServiceMode(TCL_SERVICE_NONE);
    
    /*
     * Reset WSAAsyncSelect so we have a fresh set of events pending.
     */

    SendMessage(tsdPtr->hwnd, SOCKET_SELECT,
	    (WPARAM) UNSELECT, (LPARAM) infoPtr);

    SendMessage(tsdPtr->hwnd, SOCKET_SELECT,
	    (WPARAM) SELECT, (LPARAM) infoPtr);

    while (1) {

	if (infoPtr->lastError) {
	    *errorCodePtr = infoPtr->lastError;
	    result = 0;
	    break;
	} else if (infoPtr->readyEvents & events) {
	    break;
	} else if (infoPtr->flags & SOCKET_ASYNC) {
	    *errorCodePtr = EWOULDBLOCK;
	    result = 0;
	    break;
	}

	/*
	 * Wait until something happens.
	 */
	WaitForSingleObject(tsdPtr->readyEvent, INFINITE);
    }
    
    (void) Tcl_SetServiceMode(oldMode);
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_OpenTcpClient --
 *
 *	Opens a TCP client socket and creates a channel around it.
 *
 * Results:
 *	The channel or NULL if failed.  An error message is returned
 *	in the interpreter on failure.
 *
 * Side effects:
 *	Opens a client socket and creates a new channel.
 *
 *----------------------------------------------------------------------
 */

Tcl_Channel
Tcl_OpenTcpClient(interp, port, host, myaddr, myport, async)
    Tcl_Interp *interp;			/* For error reporting; can be NULL. */
    int port;				/* Port number to open. */
    CONST char *host;			/* Host on which to open port. */
    CONST char *myaddr;			/* Client-side address */
    int myport;				/* Client-side port */
    int async;				/* If nonzero, should connect
                                         * client socket asynchronously. */
{
    SocketInfo *infoPtr;
    char channelName[16 + TCL_INTEGER_SPACE];

    if (TclpHasSockets(interp) != TCL_OK) {
	return NULL;
    }

    /*
     * Create a new client socket and wrap it in a channel.
     */

    infoPtr = CreateSocket(interp, port, host, 0, myaddr, myport, async);
    if (infoPtr == NULL) {
	return NULL;
    }

    wsprintfA(channelName, "sock%d", infoPtr->socket);

    infoPtr->channel = Tcl_CreateChannel(&tcpChannelType, channelName,
	    (ClientData) infoPtr, (TCL_READABLE | TCL_WRITABLE));
    if (Tcl_SetChannelOption(interp, infoPtr->channel, "-translation",
	    "auto crlf") == TCL_ERROR) {
        Tcl_Close((Tcl_Interp *) NULL, infoPtr->channel);
        return (Tcl_Channel) NULL;
    }
    if (Tcl_SetChannelOption(NULL, infoPtr->channel, "-eofchar", "")
	    == TCL_ERROR) {
        Tcl_Close((Tcl_Interp *) NULL, infoPtr->channel);
        return (Tcl_Channel) NULL;
    }
    return infoPtr->channel;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_MakeTcpClientChannel --
 *
 *	Creates a Tcl_Channel from an existing client TCP socket.
 *
 * Results:
 *	The Tcl_Channel wrapped around the preexisting TCP socket.
 *
 * Side effects:
 *	None.
 *
 * NOTE: Code contributed by Mark Diekhans (markd@@grizzly.com)
 *
 *----------------------------------------------------------------------
 */

Tcl_Channel
Tcl_MakeTcpClientChannel(sock)
    ClientData sock;		/* The socket to wrap up into a channel. */
{
    SocketInfo *infoPtr;
    char channelName[16 + TCL_INTEGER_SPACE];
    ThreadSpecificData *tsdPtr;

    if (TclpHasSockets(NULL) != TCL_OK) {
	return NULL;
    }

    tsdPtr = (ThreadSpecificData *)TclThreadDataKeyGet(&dataKey);

    /*
     * Set kernel space buffering and non-blocking.
     */

    TclSockMinimumBuffers((SOCKET) sock, TCP_BUFFER_SIZE);

    infoPtr = NewSocketInfo((SOCKET) sock);

    /*
     * Start watching for read/write events on the socket.
     */

    infoPtr->selectEvents = FD_READ | FD_CLOSE | FD_WRITE;
    SendMessage(tsdPtr->hwnd, SOCKET_SELECT,
	    (WPARAM) SELECT, (LPARAM) infoPtr);

    wsprintfA(channelName, "sock%d", infoPtr->socket);
    infoPtr->channel = Tcl_CreateChannel(&tcpChannelType, channelName,
	    (ClientData) infoPtr, (TCL_READABLE | TCL_WRITABLE));
    Tcl_SetChannelOption(NULL, infoPtr->channel, "-translation", "auto crlf");
    return infoPtr->channel;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_OpenTcpServer --
 *
 *	Opens a TCP server socket and creates a channel around it.
 *
 * Results:
 *	The channel or NULL if failed.  An error message is returned
 *	in the interpreter on failure.
 *
 * Side effects:
 *	Opens a server socket and creates a new channel.
 *
 *----------------------------------------------------------------------
 */

Tcl_Channel
Tcl_OpenTcpServer(interp, port, host, acceptProc, acceptProcData)
    Tcl_Interp *interp;			/* For error reporting - may be
                                         * NULL. */
    int port;				/* Port number to open. */
    CONST char *host;			/* Name of local host. */
    Tcl_TcpAcceptProc *acceptProc;	/* Callback for accepting connections
                                         * from new clients. */
    ClientData acceptProcData;		/* Data for the callback. */
{
    SocketInfo *infoPtr;
    char channelName[16 + TCL_INTEGER_SPACE];

    if (TclpHasSockets(interp) != TCL_OK) {
	return NULL;
    }

    /*
     * Create a new client socket and wrap it in a channel.
     */

    infoPtr = CreateSocket(interp, port, host, 1, NULL, 0, 0);
    if (infoPtr == NULL) {
	return NULL;
    }

    infoPtr->acceptProc = acceptProc;
    infoPtr->acceptProcData = acceptProcData;

    wsprintfA(channelName, "sock%d", infoPtr->socket);

    infoPtr->channel = Tcl_CreateChannel(&tcpChannelType, channelName,
	    (ClientData) infoPtr, 0);
    if (Tcl_SetChannelOption(interp, infoPtr->channel, "-eofchar", "")
	    == TCL_ERROR) {
        Tcl_Close((Tcl_Interp *) NULL, infoPtr->channel);
        return (Tcl_Channel) NULL;
    }

    return infoPtr->channel;
}

/*
 *----------------------------------------------------------------------
 *
 * TcpAccept --
 *	Accept a TCP socket connection.  This is called by
 *	SocketEventProc and it in turns calls the registered accept
 *	procedure.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Invokes the accept proc which may invoke arbitrary Tcl code.
 *
 *----------------------------------------------------------------------
 */

static void
TcpAccept(infoPtr)
    SocketInfo *infoPtr;	/* Socket to accept. */
{
    SOCKET newSocket;
    SocketInfo *newInfoPtr;
    struct sockaddr_in addr;
    int len;
    char channelName[16 + TCL_INTEGER_SPACE];
    ThreadSpecificData *tsdPtr = 
	(ThreadSpecificData *)TclThreadDataKeyGet(&dataKey);

    /*
     * Accept the incoming connection request.
     */

    len = sizeof(struct sockaddr_in);

    newSocket = (*winSock.accept)(infoPtr->socket,
	    (struct sockaddr *)&addr,
	    &len);
    
    /*
     * Clear the ready mask so we can detect the next connection request.
     * Note that connection requests are level triggered, so if there is
     * a request already pending, a new event will be generated.
     */
    
    if (newSocket == INVALID_SOCKET) {
	infoPtr->acceptEventCount = 0;
	infoPtr->readyEvents &= ~(FD_ACCEPT);
	return;
    } 

    /*
     * It is possible that more than one FD_ACCEPT has been sent, so an extra
     * count must be kept.  Decrement the count, and reset the readyEvent bit
     * if the count is no longer > 0.
     */
    
    infoPtr->acceptEventCount--;

    if (infoPtr->acceptEventCount <= 0) {
	infoPtr->readyEvents &= ~(FD_ACCEPT);
    }

    /*
     * Win-NT has a misfeature that sockets are inherited in child
     * processes by default.  Turn off the inherit bit.
     */
    
    SetHandleInformation( (HANDLE) newSocket, HANDLE_FLAG_INHERIT, 0 );
    
    /*
     * Add this socket to the global list of sockets.
     */
    
    newInfoPtr = NewSocketInfo(newSocket);
    
    /*
     * Select on read/write events and create the channel.
     */
    
    newInfoPtr->selectEvents = (FD_READ | FD_WRITE | FD_CLOSE);
    SendMessage(tsdPtr->hwnd, SOCKET_SELECT,
	    (WPARAM) SELECT, (LPARAM) newInfoPtr);
    
    wsprintfA(channelName, "sock%d", newInfoPtr->socket);
    newInfoPtr->channel = Tcl_CreateChannel(&tcpChannelType, channelName,
	    (ClientData) newInfoPtr, (TCL_READABLE | TCL_WRITABLE));
    if (Tcl_SetChannelOption(NULL, newInfoPtr->channel, "-translation",
	    "auto crlf") == TCL_ERROR) {
	Tcl_Close((Tcl_Interp *) NULL, newInfoPtr->channel);
	return;
    }
    if (Tcl_SetChannelOption(NULL, newInfoPtr->channel, "-eofchar", "")
	    == TCL_ERROR) {
	Tcl_Close((Tcl_Interp *) NULL, newInfoPtr->channel);
	return;
    }
    
    /*
     * Invoke the accept callback procedure.
     */
    
    if (infoPtr->acceptProc != NULL) {
	(infoPtr->acceptProc) (infoPtr->acceptProcData,
		newInfoPtr->channel,
		(*winSock.inet_ntoa)(addr.sin_addr),
		(*winSock.ntohs)(addr.sin_port));
    }
}

/*
 *----------------------------------------------------------------------
 *
 * TcpInputProc --
 *
 *	This procedure is called by the generic IO level to read data from
 *	a socket based channel.
 *
 * Results:
 *	The number of bytes read or -1 on error.
 *
 * Side effects:
 *	Consumes input from the socket.
 *
 *----------------------------------------------------------------------
 */

static int
TcpInputProc(instanceData, buf, toRead, errorCodePtr)
    ClientData instanceData;		/* The socket state. */
    char *buf;				/* Where to store data. */
    int toRead;				/* Maximum number of bytes to read. */
    int *errorCodePtr;			/* Where to store error codes. */
{
    SocketInfo *infoPtr = (SocketInfo *) instanceData;
    int bytesRead;
    int error;
    ThreadSpecificData *tsdPtr = 
	(ThreadSpecificData *)TclThreadDataKeyGet(&dataKey);
    
    *errorCodePtr = 0;

    /*
     * Check that WinSock is initialized; do not call it if not, to
     * prevent system crashes. This can happen at exit time if the exit
     * handler for WinSock ran before other exit handlers that want to
     * use sockets.
     */

    if (!SocketsEnabled()) {
        *errorCodePtr = EFAULT;
        return -1;
    }

    /*
     * First check to see if EOF was already detected, to prevent
     * calling the socket stack after the first time EOF is detected.
     */

    if (infoPtr->flags & SOCKET_EOF) {
	return 0;
    }

    /*
     * Check to see if the socket is connected before trying to read.
     */

    if ((infoPtr->flags & SOCKET_ASYNC_CONNECT)
	    && ! WaitForSocketEvent(infoPtr,  FD_CONNECT, errorCodePtr)) {
	return -1;
    }
    
    /*
     * No EOF, and it is connected, so try to read more from the socket.
     * Note that we clear the FD_READ bit because read events are level
     * triggered so a new event will be generated if there is still data
     * available to be read.  We have to simulate blocking behavior here
     * since we are always using non-blocking sockets.
     */

    while (1) {
	SendMessage(tsdPtr->hwnd, SOCKET_SELECT,
		(WPARAM) UNSELECT, (LPARAM) infoPtr);
	bytesRead = (*winSock.recv)(infoPtr->socket, buf, toRead, 0);
	infoPtr->readyEvents &= ~(FD_READ);
  
	/*
	 * Check for end-of-file condition or successful read.
	 */
  
	if (bytesRead == 0) {
	    infoPtr->flags |= SOCKET_EOF;
	}
	if (bytesRead != SOCKET_ERROR) {
	    break;
	}
  
	/*
	 * If an error occurs after the FD_CLOSE has arrived,
	 * then ignore the error and report an EOF.
	 */
  
	if (infoPtr->readyEvents & FD_CLOSE) {
	    infoPtr->flags |= SOCKET_EOF;
	    bytesRead = 0;
	    break;
	}
  
	/*
	 * Check for error condition or underflow in non-blocking case.
	 */
  
	error = (*winSock.WSAGetLastError)();
	if ((infoPtr->flags & SOCKET_ASYNC) || (error != WSAEWOULDBLOCK)) {
	    TclWinConvertWSAError(error);
	    *errorCodePtr = Tcl_GetErrno();
	    bytesRead = -1;
	    break;
	}

	/*
	 * In the blocking case, wait until the file becomes readable
	 * or closed and try again.
	 */

	if (!WaitForSocketEvent(infoPtr, FD_READ|FD_CLOSE, errorCodePtr)) {
	    bytesRead = -1;
	    break;
  	}
    }
    
    SendMessage(tsdPtr->hwnd, SOCKET_SELECT,
	    (WPARAM) SELECT, (LPARAM) infoPtr);
    
    return bytesRead;
}

/*
 *----------------------------------------------------------------------
 *
 * TcpOutputProc --
 *
 *	This procedure is called by the generic IO level to write data
 *	to a socket based channel.
 *
 * Results:
 *	The number of bytes written or -1 on failure.
 *
 * Side effects:
 *	Produces output on the socket.
 *
 *----------------------------------------------------------------------
 */

static int
TcpOutputProc(instanceData, buf, toWrite, errorCodePtr)
    ClientData instanceData;		/* The socket state. */
    CONST char *buf;			/* Where to get data. */
    int toWrite;			/* Maximum number of bytes to write. */
    int *errorCodePtr;			/* Where to store error codes. */
{
    SocketInfo *infoPtr = (SocketInfo *) instanceData;
    int bytesWritten;
    int error;
    ThreadSpecificData *tsdPtr = 
	(ThreadSpecificData *)TclThreadDataKeyGet(&dataKey);

    *errorCodePtr = 0;

    /*
     * Check that WinSock is initialized; do not call it if not, to
     * prevent system crashes. This can happen at exit time if the exit
     * handler for WinSock ran before other exit handlers that want to
     * use sockets.
     */

    if (!SocketsEnabled()) {
        *errorCodePtr = EFAULT;
        return -1;
    }

    /*
     * Check to see if the socket is connected before trying to write.
     */
    
    if ((infoPtr->flags & SOCKET_ASYNC_CONNECT)
	    && ! WaitForSocketEvent(infoPtr,  FD_CONNECT, errorCodePtr)) {
	return -1;
    }

    while (1) {
	SendMessage(tsdPtr->hwnd, SOCKET_SELECT,
		(WPARAM) UNSELECT, (LPARAM) infoPtr);

	bytesWritten = (*winSock.send)(infoPtr->socket, buf, toWrite, 0);
	if (bytesWritten != SOCKET_ERROR) {
	    /*
	     * Since Windows won't generate a new write event until we hit
	     * an overflow condition, we need to force the event loop to
	     * poll until the condition changes.
	     */

	    if (infoPtr->watchEvents & FD_WRITE) {
		Tcl_Time blockTime = { 0, 0 };
		Tcl_SetMaxBlockTime(&blockTime);
	    }		
	    break;
	}
	
	/*
	 * Check for error condition or overflow.  In the event of overflow, we
	 * need to clear the FD_WRITE flag so we can detect the next writable
	 * event.  Note that Windows only sends a new writable event after a
	 * send fails with WSAEWOULDBLOCK.
	 */

	error = (*winSock.WSAGetLastError)();
	if (error == WSAEWOULDBLOCK) {
	    infoPtr->readyEvents &= ~(FD_WRITE);
	    if (infoPtr->flags & SOCKET_ASYNC) {
		*errorCodePtr = EWOULDBLOCK;
		bytesWritten = -1;
		break;
	    } 
	} else {
	    TclWinConvertWSAError(error);
	    *errorCodePtr = Tcl_GetErrno();
	    bytesWritten = -1;
	    break;
	}

	/*
	 * In the blocking case, wait until the file becomes writable
	 * or closed and try again.
	 */

	if (!WaitForSocketEvent(infoPtr, FD_WRITE|FD_CLOSE, errorCodePtr)) {
	    bytesWritten = -1;
	    break;
	}
    }

    SendMessage(tsdPtr->hwnd, SOCKET_SELECT,
	    (WPARAM) SELECT, (LPARAM) infoPtr);
    
    return bytesWritten;
}

/*
 *----------------------------------------------------------------------
 *
 * TcpGetOptionProc --
 *
 *	Computes an option value for a TCP socket based channel, or a
 *	list of all options and their values.
 *
 *	Note: This code is based on code contributed by John Haxby.
 *
 * Results:
 *	A standard Tcl result. The value of the specified option or a
 *	list of all options and	their values is returned in the
 *	supplied DString.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static int
TcpGetOptionProc(instanceData, interp, optionName, dsPtr)
    ClientData instanceData;		/* Socket state. */
    Tcl_Interp *interp;                 /* For error reporting - can be NULL */
    CONST char *optionName;		/* Name of the option to
                                         * retrieve the value for, or
                                         * NULL to get all options and
                                         * their values. */
    Tcl_DString *dsPtr;			/* Where to store the computed
                                         * value; initialized by caller. */
{
    SocketInfo *infoPtr;
    struct sockaddr_in sockname;
    struct sockaddr_in peername;
    struct hostent *hostEntPtr;
    SOCKET sock;
    int size = sizeof(struct sockaddr_in);
    size_t len = 0;
    char buf[TCL_INTEGER_SPACE];

    /*
     * Check that WinSock is initialized; do not call it if not, to
     * prevent system crashes. This can happen at exit time if the exit
     * handler for WinSock ran before other exit handlers that want to
     * use sockets.
     */

    if (!SocketsEnabled()) {
	if (interp) {
	    Tcl_AppendResult(interp, "winsock is not initialized", NULL);
	}
        return TCL_ERROR;
    }
    
    infoPtr = (SocketInfo *) instanceData;
    sock = (int) infoPtr->socket;
    if (optionName != (char *) NULL) {
        len = strlen(optionName);
    }

    if ((len > 1) && (optionName[1] == 'e') &&
	    (strncmp(optionName, "-error", len) == 0)) {
	int optlen;
	int err, ret;
    
	optlen = sizeof(int);
	ret = TclWinGetSockOpt(sock, SOL_SOCKET, SO_ERROR,
		(char *)&err, &optlen);
	if (ret == SOCKET_ERROR) {
	    err = (*winSock.WSAGetLastError)();
	}
	if (err) {
	    TclWinConvertWSAError(err);
	    Tcl_DStringAppend(dsPtr, Tcl_ErrnoMsg(Tcl_GetErrno()), -1);
	}
	return TCL_OK;
    }

    if ((len == 0) ||
            ((len > 1) && (optionName[1] == 'p') &&
                    (strncmp(optionName, "-peername", len) == 0))) {
        if ((*winSock.getpeername)(sock, (struct sockaddr *) &peername, &size)
                == 0) {
            if (len == 0) {
                Tcl_DStringAppendElement(dsPtr, "-peername");
                Tcl_DStringStartSublist(dsPtr);
            }
            Tcl_DStringAppendElement(dsPtr,
                    (*winSock.inet_ntoa)(peername.sin_addr));

	    if (peername.sin_addr.s_addr == 0) {
	        hostEntPtr = (struct hostent *) NULL;
	    } else {
	        hostEntPtr = (*winSock.gethostbyaddr)(
                    (char *) &(peername.sin_addr), sizeof(peername.sin_addr),
		    AF_INET);
	    }
            if (hostEntPtr != (struct hostent *) NULL) {
                Tcl_DStringAppendElement(dsPtr, hostEntPtr->h_name);
            } else {
                Tcl_DStringAppendElement(dsPtr,
                        (*winSock.inet_ntoa)(peername.sin_addr));
            }
	    TclFormatInt(buf, (*winSock.ntohs)(peername.sin_port));
            Tcl_DStringAppendElement(dsPtr, buf);
            if (len == 0) {
                Tcl_DStringEndSublist(dsPtr);
            } else {
                return TCL_OK;
            }
        } else {
            /*
             * getpeername failed - but if we were asked for all the options
             * (len==0), don't flag an error at that point because it could
             * be an fconfigure request on a server socket. (which have
             * no peer). {copied from unix/tclUnixChan.c}
             */
            if (len) {
		TclWinConvertWSAError((*winSock.WSAGetLastError)());
                if (interp) {
                    Tcl_AppendResult(interp, "can't get peername: ",
                                     Tcl_PosixError(interp),
                                     (char *) NULL);
                }
                return TCL_ERROR;
            }
        }
    }

    if ((len == 0) ||
            ((len > 1) && (optionName[1] == 's') &&
                    (strncmp(optionName, "-sockname", len) == 0))) {
        if ((*winSock.getsockname)(sock, (struct sockaddr *) &sockname, &size)
                == 0) {
            if (len == 0) {
                Tcl_DStringAppendElement(dsPtr, "-sockname");
                Tcl_DStringStartSublist(dsPtr);
            }
            Tcl_DStringAppendElement(dsPtr,
                    (*winSock.inet_ntoa)(sockname.sin_addr));
	    if (sockname.sin_addr.s_addr == 0) {
	        hostEntPtr = (struct hostent *) NULL;
	    } else {
	        hostEntPtr = (*winSock.gethostbyaddr)(
                    (char *) &(sockname.sin_addr), sizeof(peername.sin_addr),
		    AF_INET);
	    }
            if (hostEntPtr != (struct hostent *) NULL) {
                Tcl_DStringAppendElement(dsPtr, hostEntPtr->h_name);
            } else {
                Tcl_DStringAppendElement(dsPtr,
                        (*winSock.inet_ntoa)(sockname.sin_addr));
            }
            TclFormatInt(buf, (*winSock.ntohs)(sockname.sin_port));
            Tcl_DStringAppendElement(dsPtr, buf);
            if (len == 0) {
                Tcl_DStringEndSublist(dsPtr);
            } else {
                return TCL_OK;
            }
        } else {
	    if (interp) {
		TclWinConvertWSAError((*winSock.WSAGetLastError)());
		Tcl_AppendResult(interp, "can't get sockname: ",
				 Tcl_PosixError(interp),
				 (char *) NULL);
	    }
	    return TCL_ERROR;
	}
    }

    if (len > 0) {
        return Tcl_BadChannelOption(interp, optionName, "peername sockname");
    }

    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * TcpWatchProc --
 *
 *	Informs the channel driver of the events that the generic
 *	channel code wishes to receive on this socket.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	May cause the notifier to poll if any of the specified 
 *	conditions are already true.
 *
 *----------------------------------------------------------------------
 */

static void
TcpWatchProc(instanceData, mask)
    ClientData instanceData;		/* The socket state. */
    int mask;				/* Events of interest; an OR-ed
                                         * combination of TCL_READABLE,
                                         * TCL_WRITABLE and TCL_EXCEPTION. */
{
    SocketInfo *infoPtr = (SocketInfo *) instanceData;
    
    /*
     * Update the watch events mask. Only if the socket is not a
     * server socket. Fix for SF Tcl Bug #557878.
     */

    if (!infoPtr->acceptProc) {    
        infoPtr->watchEvents = 0;
	if (mask & TCL_READABLE) {
	    infoPtr->watchEvents |= (FD_READ|FD_CLOSE|FD_ACCEPT);
	}
	if (mask & TCL_WRITABLE) {
	    infoPtr->watchEvents |= (FD_WRITE|FD_CONNECT);
	}
      
	/*
	 * If there are any conditions already set, then tell the notifier to poll
	 * rather than block.
	 */

	if (infoPtr->readyEvents & infoPtr->watchEvents) {
	    Tcl_Time blockTime = { 0, 0 };
	    Tcl_SetMaxBlockTime(&blockTime);
	}
    }
}

/*
 *----------------------------------------------------------------------
 *
 * TcpGetProc --
 *
 *	Called from Tcl_GetChannelHandle to retrieve an OS handle from inside
 *	a TCP socket based channel.
 *
 * Results:
 *	Returns TCL_OK with the socket in handlePtr.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static int
TcpGetHandleProc(instanceData, direction, handlePtr)
    ClientData instanceData;	/* The socket state. */
    int direction;		/* Not used. */
    ClientData *handlePtr;	/* Where to store the handle.  */
{
    SocketInfo *statePtr = (SocketInfo *) instanceData;

    *handlePtr = (ClientData) statePtr->socket;
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * SocketThread --
 *
 *	Helper thread used to manage the socket event handling window.
 *
 * Results:
 *	1 if unable to create socket event window, 0 otherwise.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static DWORD WINAPI
SocketThread(LPVOID arg)
{
    MSG msg;
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *)(arg);

    tsdPtr->hwnd = CreateWindowA("TclSocket", "TclSocket", 
	    WS_TILED, 0, 0, 0, 0, NULL, NULL, windowClass.hInstance, NULL);

    /*
     * Signal the main thread that the window has been created
     * and that the socket thread is ready to go.
     */
    
    SetEvent(tsdPtr->readyEvent);
    
    if (tsdPtr->hwnd == NULL) {
	return 1;
    } else {
	/*
	 * store the tsdPtr, it's from a different thread, so it's
	 * not directly accessible, but needed.
	 */

#ifdef _WIN64
	SetWindowLongPtr(tsdPtr->hwnd, GWLP_USERDATA, (LONG_PTR) tsdPtr);
#else
	SetWindowLong(tsdPtr->hwnd, GWL_USERDATA, (LONG) tsdPtr);
#endif
    }

    while (1) {
	/*
	 * Process all outstanding messages on the socket window.
	 */

	while (PeekMessage(&msg, tsdPtr->hwnd, 0, 0, PM_REMOVE)) {
	    DispatchMessage(&msg);
	}
	WaitMessage();
    }
}


/*
 *----------------------------------------------------------------------
 *
 * SocketProc --
 *
 *	This function is called when WSAAsyncSelect has been used
 *	to register interest in a socket event, and the event has
 *	occurred.
 *
 * Results:
 *	0 on success.
 *
 * Side effects:
 *	The flags for the given socket are updated to reflect the
 *	event that occured.
 *
 *----------------------------------------------------------------------
 */

static LRESULT CALLBACK
SocketProc(hwnd, message, wParam, lParam)
    HWND hwnd;
    UINT message;
    WPARAM wParam;
    LPARAM lParam;
{
    int event, error;
    SOCKET socket;
    SocketInfo *infoPtr;
    ThreadSpecificData *tsdPtr =
#ifdef _WIN64
	(ThreadSpecificData *) GetWindowLongPtr(hwnd, GWLP_USERDATA);
#else
	(ThreadSpecificData *) GetWindowLong(hwnd, GWL_USERDATA);
#endif

    switch (message) {

	default:
	    return DefWindowProc(hwnd, message, wParam, lParam);
	    break;
	    
	case SOCKET_MESSAGE:
	    event = WSAGETSELECTEVENT(lParam);
	    error = WSAGETSELECTERROR(lParam);
	    socket = (SOCKET) wParam;

	    /*
	     * Find the specified socket on the socket list and update its
	     * eventState flag.
	     */

	    WaitForSingleObject(tsdPtr->socketListLock, INFINITE);
	    for (infoPtr = tsdPtr->socketList; infoPtr != NULL; 
		 infoPtr = infoPtr->nextPtr) {
		if (infoPtr->socket == socket) {
		    /*
		     * Update the socket state.
		     */

		    /*
		     * A count of FD_ACCEPTS is stored, so if an FD_CLOSE event
		     * happens, then clear the FD_ACCEPT count.  Otherwise,
		     * increment the count if the current event is and
		     * FD_ACCEPT.
		     */
		    
		    if (event & FD_CLOSE) {
			infoPtr->acceptEventCount = 0;
			infoPtr->readyEvents &= ~(FD_WRITE|FD_ACCEPT);
		    } else if (event & FD_ACCEPT) {
			infoPtr->acceptEventCount++;
		    }

		    if (event & FD_CONNECT) {
			/*
			 * The socket is now connected,
			 * clear the async connect flag.
			 */
			
			infoPtr->flags &= ~(SOCKET_ASYNC_CONNECT);
			
			/*
			 * Remember any error that occurred so we can report
			 * connection failures.
			 */
			
			if (error != ERROR_SUCCESS) {
			    TclWinConvertWSAError(error);
			    infoPtr->lastError = Tcl_GetErrno();
			}
			
		    } 
		    if(infoPtr->flags & SOCKET_ASYNC_CONNECT) {
			infoPtr->flags &= ~(SOCKET_ASYNC_CONNECT);
			if (error != ERROR_SUCCESS) {
			    TclWinConvertWSAError(error);
			    infoPtr->lastError = Tcl_GetErrno();
			}
			infoPtr->readyEvents |= FD_WRITE;
		    }
		    infoPtr->readyEvents |= event;

		    /*
		     * Wake up the Main Thread.
		     */
		    SetEvent(tsdPtr->readyEvent);
		    Tcl_ThreadAlert(tsdPtr->threadId);
		    break;
		}
	    }
	    SetEvent(tsdPtr->socketListLock);
	    break;
	case SOCKET_SELECT:
	    infoPtr = (SocketInfo *) lParam;
	    if (wParam == SELECT) {

		(void) (*winSock.WSAAsyncSelect)(infoPtr->socket, hwnd,
			SOCKET_MESSAGE, infoPtr->selectEvents);
	    } else {
		/*
		 * Clear the selection mask
		 */
		
		(void) (*winSock.WSAAsyncSelect)(infoPtr->socket, hwnd, 0, 0);
	    }
	    break;
	case SOCKET_TERMINATE:
	    ExitThread(0);
	    break;
    }

    return 0;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetHostName --
 *
 *	Returns the name of the local host.
 *
 * Results:
 *	A string containing the network name for this machine, or
 *	an empty string if we can't figure out the name.  The caller 
 *	must not modify or free this string.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

CONST char *
Tcl_GetHostName()
{
    DWORD length;
    WCHAR wbuf[MAX_COMPUTERNAME_LENGTH + 1];

    Tcl_MutexLock(&socketMutex);
    InitSockets();

    if (hostnameInitialized) {
	Tcl_MutexUnlock(&socketMutex);
        return hostname;
    }
    Tcl_MutexUnlock(&socketMutex);
	
    if (TclpHasSockets(NULL) == TCL_OK) {
	/*
	 * INTL: bug
	 */

	if ((*winSock.gethostname)(hostname, sizeof(hostname)) == 0) {
	    Tcl_MutexLock(&socketMutex);
	    hostnameInitialized = 1;
	    Tcl_MutexUnlock(&socketMutex);
	    return hostname;
	}
    }
    Tcl_MutexLock(&socketMutex);
    length = sizeof(hostname);
    if ((*tclWinProcs->getComputerNameProc)(wbuf, &length) != 0) {
	/*
	 * Convert string from native to UTF then change to lowercase.
	 */

	Tcl_DString ds;

	lstrcpynA(hostname, Tcl_WinTCharToUtf((TCHAR *) wbuf, -1, &ds),
		sizeof(hostname));
	Tcl_DStringFree(&ds);
	Tcl_UtfToLower(hostname);
    } else {
	hostname[0] = '\0';
    }
    hostnameInitialized = 1;
    Tcl_MutexUnlock(&socketMutex);
    return hostname;
}

/*
 *----------------------------------------------------------------------
 *
 * TclWinGetSockOpt, et al. --
 *
 *	These functions are wrappers that let us bind the WinSock
 *	API dynamically so we can run on systems that don't have
 *	the wsock32.dll.  We need wrappers for these interfaces
 *	because they are called from the generic Tcl code.
 *
 * Results:
 *	As defined for each function.
 *
 * Side effects:
 *	As defined for each function.
 *
 *----------------------------------------------------------------------
 */

int
TclWinGetSockOpt(SOCKET s, int level, int optname, char * optval,
	int FAR *optlen)
{
    /*
     * Check that WinSock is initialized; do not call it if not, to
     * prevent system crashes. This can happen at exit time if the exit
     * handler for WinSock ran before other exit handlers that want to
     * use sockets.
     */

    if (!SocketsEnabled()) {
        return SOCKET_ERROR;
    }
    
    return (*winSock.getsockopt)(s, level, optname, optval, optlen);
}

int
TclWinSetSockOpt(SOCKET s, int level, int optname, const char * optval,
	int optlen)
{
    /*
     * Check that WinSock is initialized; do not call it if not, to
     * prevent system crashes. This can happen at exit time if the exit
     * handler for WinSock ran before other exit handlers that want to
     * use sockets.
     */
    if (!SocketsEnabled()) {
        return SOCKET_ERROR;
    }

    return (*winSock.setsockopt)(s, level, optname, optval, optlen);
}

u_short
TclWinNToHS(u_short netshort)
{
    /*
     * Check that WinSock is initialized; do not call it if not, to
     * prevent system crashes. This can happen at exit time if the exit
     * handler for WinSock ran before other exit handlers that want to
     * use sockets.
     */

    if (!SocketsEnabled()) {
        return (u_short) -1;
    }

    return (*winSock.ntohs)(netshort);
}

struct servent *
TclWinGetServByName(const char * name, const char * proto)
{
    /*
     * Check that WinSock is initialized; do not call it if not, to
     * prevent system crashes. This can happen at exit time if the exit
     * handler for WinSock ran before other exit handlers that want to
     * use sockets.
     */
    if (!SocketsEnabled()) {
        return (struct servent *) NULL;
    }

    return (*winSock.getservbyname)(name, proto);
}


@


1.4
log
@touched all sources to ease next import
@
text
@d11 1
a11 1
 * RCS: @@(#) $Id: tclWinSock.c,v 1.7.8.2 2000/09/15 16:58:54 spolk Exp $
d174 2
a175 2
			    int port, char *host, int server, char *myaddr,
			    int myport, int async));
d178 1
a178 1
			    char *host, int port));
d198 1
a198 1
		            Tcl_Interp *interp, char *optionName,
d203 1
a203 1
	            	    char *buf, int toWrite, int *errorCode));
d229 1
a229 1
    TcpBlockProc,		/* Set blocking/non-blocking mode. */
d839 1
a841 1
	    infoPtr->readyEvents &= ~(FD_READ);
d1017 1
a1017 1
    char *host;			/* Name of host on which to open port. */
d1020 1
a1020 1
    char *myaddr;		/* Optional client-side address */
d1214 1
a1214 1
    char *host;				/* Host.  NULL implies INADDR_ANY */
d1358 2
a1359 2
    char *host;				/* Host on which to open port. */
    char *myaddr;			/* Client-side address */
d1474 1
a1474 1
    char *host;				/* Name of local host. */
d1768 1
a1768 1
    char *buf;				/* Where to get data. */
d1884 1
a1884 1
    char *optionName;			/* Name of the option to
d1949 8
a1956 3
            hostEntPtr = (*winSock.gethostbyaddr)(
                (char *) &(peername.sin_addr), sizeof(peername.sin_addr),
                AF_INET);
d2000 7
a2006 3
            hostEntPtr = (*winSock.gethostbyaddr)(
                (char *) &(sockname.sin_addr), sizeof(peername.sin_addr),
                AF_INET);
d2066 2
a2067 1
     * Update the watch events mask.
a2068 8
    
    infoPtr->watchEvents = 0;
    if (mask & TCL_READABLE) {
	infoPtr->watchEvents |= (FD_READ|FD_CLOSE|FD_ACCEPT);
    }
    if (mask & TCL_WRITABLE) {
	infoPtr->watchEvents |= (FD_WRITE|FD_CONNECT);
    }
d2070 13
a2082 4
    /*
     * If there are any conditions already set, then tell the notifier to poll
     * rather than block.
     */
d2084 5
a2088 4
    if (infoPtr->readyEvents & infoPtr->watchEvents) {
	Tcl_Time blockTime = { 0, 0 };
	Tcl_SetMaxBlockTime(&blockTime);
    }		
d2161 1
a2161 1
	SetWindowLongPtr(tsdPtr->hwnd, GWLP_USERDATA, (LONG) tsdPtr);
d2333 1
a2333 1
char *
a2466 1

@


1.3
log
@touched all sources to ease next import
@
text
@@


1.3.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d11 1
a11 1
 * RCS: @@(#) $Id: tclWinSock.c,v 1.26 2002/05/24 18:57:09 andreas_kupries Exp $
d174 2
a175 2
			    int port, CONST char *host, int server,
			    CONST char *myaddr, int myport, int async));
d178 1
a178 1
			    CONST char *host, int port));
d198 1
a198 1
		            Tcl_Interp *interp, CONST char *optionName,
d203 1
a203 1
	            	    CONST char *buf, int toWrite, int *errorCode));
d229 1
a229 1
    TcpBlockProc,		/* Set socket into (non-)blocking mode. */
a838 1
	    infoPtr->readyEvents &= ~(FD_READ);
d841 1
d1017 1
a1017 1
    CONST char *host;		/* Name of host on which to open port. */
d1020 1
a1020 1
    CONST char *myaddr;		/* Optional client-side address */
d1214 1
a1214 1
    CONST char *host;			/* Host.  NULL implies INADDR_ANY */
d1358 2
a1359 2
    CONST char *host;			/* Host on which to open port. */
    CONST char *myaddr;			/* Client-side address */
d1474 1
a1474 1
    CONST char *host;			/* Name of local host. */
d1768 1
a1768 1
    CONST char *buf;			/* Where to get data. */
d1884 1
a1884 1
    CONST char *optionName;		/* Name of the option to
d1949 3
a1951 8

	    if (peername.sin_addr.s_addr == 0) {
	        hostEntPtr = (struct hostent *) NULL;
	    } else {
	        hostEntPtr = (*winSock.gethostbyaddr)(
                    (char *) &(peername.sin_addr), sizeof(peername.sin_addr),
		    AF_INET);
	    }
d1995 3
a1997 7
	    if (sockname.sin_addr.s_addr == 0) {
	        hostEntPtr = (struct hostent *) NULL;
	    } else {
	        hostEntPtr = (*winSock.gethostbyaddr)(
                    (char *) &(sockname.sin_addr), sizeof(peername.sin_addr),
		    AF_INET);
	    }
d2057 1
a2057 2
     * Update the watch events mask. Only if the socket is not a
     * server socket. Fix for SF Tcl Bug #557878.
d2059 8
d2068 4
a2071 13
    if (!infoPtr->acceptProc) {    
        infoPtr->watchEvents = 0;
	if (mask & TCL_READABLE) {
	    infoPtr->watchEvents |= (FD_READ|FD_CLOSE|FD_ACCEPT);
	}
	if (mask & TCL_WRITABLE) {
	    infoPtr->watchEvents |= (FD_WRITE|FD_CONNECT);
	}
      
	/*
	 * If there are any conditions already set, then tell the notifier to poll
	 * rather than block.
	 */
d2073 4
a2076 5
	if (infoPtr->readyEvents & infoPtr->watchEvents) {
	    Tcl_Time blockTime = { 0, 0 };
	    Tcl_SetMaxBlockTime(&blockTime);
	}
    }
d2149 1
a2149 1
	SetWindowLongPtr(tsdPtr->hwnd, GWLP_USERDATA, (LONG_PTR) tsdPtr);
d2321 1
a2321 1
CONST char *
d2455 1
@


1.3.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@d11 1
a11 1
 * RCS: @@(#) $Id: tclWinSock.c,v 1.26 2002/05/24 18:57:09 andreas_kupries Exp $
d174 2
a175 2
			    int port, CONST char *host, int server,
			    CONST char *myaddr, int myport, int async));
d178 1
a178 1
			    CONST char *host, int port));
d198 1
a198 1
		            Tcl_Interp *interp, CONST char *optionName,
d203 1
a203 1
	            	    CONST char *buf, int toWrite, int *errorCode));
d229 1
a229 1
    TcpBlockProc,		/* Set socket into (non-)blocking mode. */
a838 1
	    infoPtr->readyEvents &= ~(FD_READ);
d841 1
d1017 1
a1017 1
    CONST char *host;		/* Name of host on which to open port. */
d1020 1
a1020 1
    CONST char *myaddr;		/* Optional client-side address */
d1214 1
a1214 1
    CONST char *host;			/* Host.  NULL implies INADDR_ANY */
d1358 2
a1359 2
    CONST char *host;			/* Host on which to open port. */
    CONST char *myaddr;			/* Client-side address */
d1474 1
a1474 1
    CONST char *host;			/* Name of local host. */
d1768 1
a1768 1
    CONST char *buf;			/* Where to get data. */
d1884 1
a1884 1
    CONST char *optionName;		/* Name of the option to
d1949 3
a1951 8

	    if (peername.sin_addr.s_addr == 0) {
	        hostEntPtr = (struct hostent *) NULL;
	    } else {
	        hostEntPtr = (*winSock.gethostbyaddr)(
                    (char *) &(peername.sin_addr), sizeof(peername.sin_addr),
		    AF_INET);
	    }
d1995 3
a1997 7
	    if (sockname.sin_addr.s_addr == 0) {
	        hostEntPtr = (struct hostent *) NULL;
	    } else {
	        hostEntPtr = (*winSock.gethostbyaddr)(
                    (char *) &(sockname.sin_addr), sizeof(peername.sin_addr),
		    AF_INET);
	    }
d2057 1
a2057 2
     * Update the watch events mask. Only if the socket is not a
     * server socket. Fix for SF Tcl Bug #557878.
d2059 8
d2068 4
a2071 13
    if (!infoPtr->acceptProc) {    
        infoPtr->watchEvents = 0;
	if (mask & TCL_READABLE) {
	    infoPtr->watchEvents |= (FD_READ|FD_CLOSE|FD_ACCEPT);
	}
	if (mask & TCL_WRITABLE) {
	    infoPtr->watchEvents |= (FD_WRITE|FD_CONNECT);
	}
      
	/*
	 * If there are any conditions already set, then tell the notifier to poll
	 * rather than block.
	 */
d2073 4
a2076 5
	if (infoPtr->readyEvents & infoPtr->watchEvents) {
	    Tcl_Time blockTime = { 0, 0 };
	    Tcl_SetMaxBlockTime(&blockTime);
	}
    }
d2149 1
a2149 1
	SetWindowLongPtr(tsdPtr->hwnd, GWLP_USERDATA, (LONG_PTR) tsdPtr);
d2321 1
a2321 1
CONST char *
d2455 1
@


1.2
log
@touched all Tcl files to ease next import.
@
text
@@


1.2.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.2.16.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d174 2
a175 2
			    int port, CONST char *host, int server,
			    CONST char *myaddr, int myport, int async));
d178 1
a178 1
			    CONST char *host, int port));
d198 1
a198 1
		            Tcl_Interp *interp, CONST char *optionName,
d203 1
a203 1
	            	    CONST char *buf, int toWrite, int *errorCode));
d229 1
a229 1
    TcpBlockProc,		/* Set socket into (non-)blocking mode. */
a838 1
	    infoPtr->readyEvents &= ~(FD_READ);
d841 1
d1017 1
a1017 1
    CONST char *host;		/* Name of host on which to open port. */
d1020 1
a1020 1
    CONST char *myaddr;		/* Optional client-side address */
d1214 1
a1214 1
    CONST char *host;			/* Host.  NULL implies INADDR_ANY */
d1358 2
a1359 2
    CONST char *host;			/* Host on which to open port. */
    CONST char *myaddr;			/* Client-side address */
d1474 1
a1474 1
    CONST char *host;			/* Name of local host. */
d1768 1
a1768 1
    CONST char *buf;			/* Where to get data. */
d1884 1
a1884 1
    CONST char *optionName;		/* Name of the option to
d1949 3
a1951 8

	    if (peername.sin_addr.s_addr == 0) {
	        hostEntPtr = (struct hostent *) NULL;
	    } else {
	        hostEntPtr = (*winSock.gethostbyaddr)(
                    (char *) &(peername.sin_addr), sizeof(peername.sin_addr),
		    AF_INET);
	    }
d1995 3
a1997 7
	    if (sockname.sin_addr.s_addr == 0) {
	        hostEntPtr = (struct hostent *) NULL;
	    } else {
	        hostEntPtr = (*winSock.gethostbyaddr)(
                    (char *) &(sockname.sin_addr), sizeof(peername.sin_addr),
		    AF_INET);
	    }
d2057 1
a2057 2
     * Update the watch events mask. Only if the socket is not a
     * server socket. Fix for SF Tcl Bug #557878.
d2059 8
d2068 4
a2071 13
    if (!infoPtr->acceptProc) {    
        infoPtr->watchEvents = 0;
	if (mask & TCL_READABLE) {
	    infoPtr->watchEvents |= (FD_READ|FD_CLOSE|FD_ACCEPT);
	}
	if (mask & TCL_WRITABLE) {
	    infoPtr->watchEvents |= (FD_WRITE|FD_CONNECT);
	}
      
	/*
	 * If there are any conditions already set, then tell the notifier to poll
	 * rather than block.
	 */
d2073 4
a2076 5
	if (infoPtr->readyEvents & infoPtr->watchEvents) {
	    Tcl_Time blockTime = { 0, 0 };
	    Tcl_SetMaxBlockTime(&blockTime);
	}
    }
d2149 1
a2149 1
	SetWindowLongPtr(tsdPtr->hwnd, GWLP_USERDATA, (LONG_PTR) tsdPtr);
d2321 1
a2321 1
CONST char *
d2455 1
@


1.1
log
@Initial revision
@
text
@d11 1
a11 1
 * RCS: @@(#) $Id: tclWinSock.c,v 1.16 1999/01/26 03:53:45 jingham Exp $
d14 1
a14 6
#include "tclInt.h"
#include "tclPort.h"

#ifdef _MSC_VER
#define PASCAL
#endif
d27 2
a37 1
    HWND hwnd;			/* Handle to window for socket messages. */
d84 4
d109 2
a113 3
    /* CYGNUS LOCAL */
    int clientChannel;		   /* Created by Tcp_MakeTcpClientChannel. */
    /* END CYGNUS LOCAL */
d151 14
a164 3
/*
 * Every open socket has an entry on the following list.
 */
d166 2
a167 1
static SocketInfo *socketList;
d190 2
d210 1
d218 14
a231 10
    "tcp",		/* Type name. */
    TcpBlockProc,	/* Set socket into blocking/non-blocking mode. */
    TcpCloseProc,	/* Close proc. */
    TcpInputProc,	/* Input proc. */
    TcpOutputProc,	/* Output proc. */
    NULL,		/* Seek proc. */
    NULL,		/* Set option proc. */
    TcpGetOptionProc,	/* Get option proc. */
    TcpWatchProc,	/* Initialize notifier to watch this channel. */
    TcpGetHandleProc,	/* Get an OS handle from channel. */
d249 2
d265 1
d267 2
a268 2
    OSVERSIONINFO info;
    WNDCLASS class;
d270 3
a272 2
    initialized = 1;
    Tcl_CreateExitHandler(SocketExitHandler, (ClientData) NULL);
d274 1
a274 3
    /*
     * Find out if we're running on Win32s.
     */
d276 3
a278 2
    info.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&info);
d280 143
a422 13
    /*
     * Check to see if Sockets are supported on this system.  Since
     * win32s panics if we call WSAStartup on a system that doesn't
     * have winsock.dll, we need to look for it on the system first.
     * If we find winsock, then load the library and initialize the
     * stub table.
     */

    if ((info.dwPlatformId != VER_PLATFORM_WIN32s)
	    || (SearchPath(NULL, "WINSOCK", ".DLL", 0, NULL, NULL) != 0)) {
	winSock.hInstance = LoadLibrary("wsock32.dll");
    } else {
	winSock.hInstance = NULL;
d426 1
a426 1
     * Initialize the function table.
d429 4
a432 3
    if (winSock.hInstance == NULL) {
	return;
    }
d434 7
a440 7
/* CYGNUS LOCAL */
#ifdef __GNUC__
/* gcc can't handle `PASCAL FAR' in a cast.  */
#define PASCAL_FAR
#else
#define PASCAL_FAR PASCAL FAR
#endif
d442 4
a445 107
    winSock.accept = (SOCKET (PASCAL_FAR *)(SOCKET s,
            struct sockaddr FAR *addr, int FAR *addrlen))
        GetProcAddress(winSock.hInstance, "accept");
    winSock.bind = (int (PASCAL_FAR *)(SOCKET s,
            const struct sockaddr FAR *addr, int namelen))
        GetProcAddress(winSock.hInstance, "bind");
    winSock.closesocket = (int (PASCAL_FAR *)(SOCKET s))
        GetProcAddress(winSock.hInstance, "closesocket");
    winSock.connect = (int (PASCAL_FAR *)(SOCKET s,
            const struct sockaddr FAR *name, int namelen))
        GetProcAddress(winSock.hInstance, "connect");
    winSock.ioctlsocket = (int (PASCAL_FAR *)(SOCKET s, long cmd,
            u_long FAR *argp)) GetProcAddress(winSock.hInstance, "ioctlsocket");
    winSock.getsockopt = (int (PASCAL_FAR *)(SOCKET s,
            int level, int optname, char FAR * optval, int FAR *optlen))
        GetProcAddress(winSock.hInstance, "getsockopt");
    winSock.htons = (u_short (PASCAL_FAR *)(u_short hostshort))
        GetProcAddress(winSock.hInstance, "htons");
    winSock.inet_addr = (unsigned long (PASCAL_FAR *)(const char FAR *cp))
        GetProcAddress(winSock.hInstance, "inet_addr");
    winSock.inet_ntoa = (char FAR * (PASCAL_FAR *)(struct in_addr in))
        GetProcAddress(winSock.hInstance, "inet_ntoa");
    winSock.listen = (int (PASCAL_FAR *)(SOCKET s, int backlog))
        GetProcAddress(winSock.hInstance, "listen");
    winSock.ntohs = (u_short (PASCAL_FAR *)(u_short netshort))
        GetProcAddress(winSock.hInstance, "ntohs");
    winSock.recv = (int (PASCAL_FAR *)(SOCKET s, char FAR * buf,
            int len, int flags)) GetProcAddress(winSock.hInstance, "recv");
    winSock.select = (int (PASCAL_FAR *)(int nfds, fd_set FAR * readfds,
	    fd_set FAR * writefds, fd_set FAR * exceptfds,
	    const struct timeval FAR * tiemout))
	GetProcAddress(winSock.hInstance, "select");
    winSock.send = (int (PASCAL_FAR *)(SOCKET s, const char FAR * buf,
            int len, int flags)) GetProcAddress(winSock.hInstance, "send");
    winSock.setsockopt = (int (PASCAL_FAR *)(SOCKET s, int level,
            int optname, const char FAR * optval, int optlen))
        GetProcAddress(winSock.hInstance, "setsockopt");
    winSock.shutdown = (int (PASCAL_FAR *)(SOCKET s, int how))
        GetProcAddress(winSock.hInstance, "shutdown");
    winSock.socket = (SOCKET (PASCAL_FAR *)(int af, int type,
            int protocol)) GetProcAddress(winSock.hInstance, "socket");
    winSock.gethostbyaddr = (struct hostent FAR * (PASCAL_FAR *)
            (const char FAR *addr, int addrlen, int addrtype))
        GetProcAddress(winSock.hInstance, "gethostbyaddr");
    winSock.gethostbyname = (struct hostent FAR * (PASCAL_FAR *)
            (const char FAR *name))
        GetProcAddress(winSock.hInstance, "gethostbyname");
    winSock.gethostname = (int (PASCAL_FAR *)(char FAR * name,
            int namelen)) GetProcAddress(winSock.hInstance, "gethostname");
    winSock.getpeername = (int (PASCAL_FAR *)(SOCKET sock,
            struct sockaddr FAR *name, int FAR *namelen))
        GetProcAddress(winSock.hInstance, "getpeername");
    winSock.getservbyname = (struct servent FAR * (PASCAL_FAR *)
            (const char FAR * name, const char FAR * proto))
        GetProcAddress(winSock.hInstance, "getservbyname");
    winSock.getsockname = (int (PASCAL_FAR *)(SOCKET sock,
            struct sockaddr FAR *name, int FAR *namelen))
        GetProcAddress(winSock.hInstance, "getsockname");
    winSock.WSAStartup = (int (PASCAL_FAR *)(WORD wVersionRequired,
            LPWSADATA lpWSAData)) GetProcAddress(winSock.hInstance, "WSAStartup");
    winSock.WSACleanup = (int (PASCAL_FAR *)(void))
        GetProcAddress(winSock.hInstance, "WSACleanup");
    winSock.WSAGetLastError = (int (PASCAL_FAR *)(void))
        GetProcAddress(winSock.hInstance, "WSAGetLastError");
    winSock.WSAAsyncSelect = (int (PASCAL_FAR *)(SOCKET s, HWND hWnd,
            u_int wMsg, long lEvent))
        GetProcAddress(winSock.hInstance, "WSAAsyncSelect");
/* END CYGNUS LOCAL */

    /*
     * Now check that all fields are properly initialized. If not, return
     * zero to indicate that we failed to initialize properly.
     */

    if ((winSock.hInstance == NULL) ||
            (winSock.accept == NULL) ||
            (winSock.bind == NULL) ||
            (winSock.closesocket == NULL) ||
            (winSock.connect == NULL) ||
            (winSock.ioctlsocket == NULL) ||
            (winSock.getsockopt == NULL) ||
            (winSock.htons == NULL) ||
            (winSock.inet_addr == NULL) ||
            (winSock.inet_ntoa == NULL) ||
            (winSock.listen == NULL) ||
            (winSock.ntohs == NULL) ||
            (winSock.recv == NULL) ||
            (winSock.select == NULL) ||
            (winSock.send == NULL) ||
            (winSock.setsockopt == NULL) ||
            (winSock.socket == NULL) ||
            (winSock.gethostbyname == NULL) ||
            (winSock.gethostbyaddr == NULL) ||
            (winSock.gethostname == NULL) ||
            (winSock.getpeername == NULL) ||
            (winSock.getservbyname == NULL) ||
            (winSock.getsockname == NULL) ||
            (winSock.WSAStartup == NULL) ||
            (winSock.WSACleanup == NULL) ||
            (winSock.WSAGetLastError == NULL) ||
            (winSock.WSAAsyncSelect == NULL)) {
	goto unloadLibrary;
    }
    
    /*
     * Initialize the winsock library and check the version number.
     */
d447 9
a455 7
    if ((*winSock.WSAStartup)(WSA_VERSION_REQD, &wsaData) != 0) {
	goto unloadLibrary;
    }
    if (wsaData.wVersion != WSA_VERSION_REQD) {
	(*winSock.WSACleanup)();
	goto unloadLibrary;
    }
d457 6
a462 23
    /*
     * Create the async notification window with a new class.  We
     * must create a new class to avoid a Windows 95 bug that causes
     * us to get the wrong message number for socket events if the
     * message window is a subclass of a static control.
     */

    class.style = 0;
    class.cbClsExtra = 0;
    class.cbWndExtra = 0;
    class.hInstance = TclWinGetTclInstance();
    class.hbrBackground = NULL;
    class.lpszMenuName = NULL;
    class.lpszClassName = "TclSocket";
    class.lpfnWndProc = SocketProc;
    class.hIcon = NULL;
    class.hCursor = NULL;

    if (RegisterClass(&class)) {
	winSock.hwnd = CreateWindow("TclSocket", "TclSocket", WS_TILED, 0, 0,
		0, 0, NULL, NULL, class.hInstance, NULL);
    } else {
	winSock.hwnd = NULL;
a463 6
    if (winSock.hwnd == NULL) {
	TclWinConvertError(GetLastError());
	(*winSock.WSACleanup)();
	goto unloadLibrary;
    }
    Tcl_CreateEventSource(SocketSetupProc, SocketCheckProc, NULL);
d467 11
d486 28
d533 1
d535 1
a535 2
	DestroyWindow(winSock.hwnd);
	UnregisterClass("TclSocket", TclWinGetTclInstance());
a539 1
    Tcl_DeleteEventSource(SocketSetupProc, SocketCheckProc, NULL);
d542 48
d595 1
a595 1
 * TclHasSockets --
d612 1
a612 1
TclHasSockets(interp)
d615 5
a619 5
    if (!initialized) {
	InitSockets();
    }
    
    if (winSock.hInstance != NULL) {
d653 1
d663 3
a665 1
    for (infoPtr = socketList; infoPtr != NULL; infoPtr = infoPtr->nextPtr) {
d671 1
d698 1
d710 3
a712 1
    for (infoPtr = socketList; infoPtr != NULL; infoPtr = infoPtr->nextPtr) {
d722 1
d756 1
d766 3
a768 1
    for (infoPtr = socketList; infoPtr != NULL; infoPtr = infoPtr->nextPtr) {
d773 2
a774 1

d790 2
a791 9
	/* CYGNUS LOCAL: If we get an FD_ACCEPT on a client channel,
	   don't accept it; just set TCL_READABLE.  */
	if (infoPtr->clientChannel) {
	    mask |= TCL_READABLE;
	    infoPtr->readyEvents &= ~(FD_ACCEPT);
	} else {
	    TcpAccept(infoPtr);
	    return 1;
	}
a793 7
    /* CYGNUS LOCAL: Treat FD_CONNECT on a client channel as meaning
       that the socket is now readable and writable.  Otherwise we
       won't pick up a failed connect.  */
    if ((infoPtr->readyEvents & FD_CONNECT) && infoPtr->clientChannel) {
	mask |= TCL_READABLE | TCL_WRITABLE;
	infoPtr->readyEvents &= ~(FD_CONNECT);
    }
a815 9

	/* CYGNUS LOCAL: For a client channel, set TCL_WRITABLE for
           FD_CLOSE.  Otherwise a program waiting to write will hang
           forever.  Besides, select returns if a descriptor selected
           for write is closed.  */
	if (infoPtr->clientChannel) {
	    mask |= TCL_WRITABLE;
	}
	/* END CYGNUS LOCAL.  */
d823 1
a823 1
	 * notification so select will work correctly.  If the socket is
d828 2
a829 1
	(void) (*winSock.WSAAsyncSelect)(infoPtr->socket, winSock.hwnd, 0, 0);
d835 1
a835 1

d839 2
a840 2
	    (void) (*winSock.WSAAsyncSelect)(infoPtr->socket, winSock.hwnd,
		    SOCKET_MESSAGE, infoPtr->selectEvents);
a842 1

d844 1
a844 1
    if (events & FD_WRITE) {
d913 1
d922 1
a922 1
    if (winSock.hInstance != NULL) {
d940 2
a941 1
    for (nextPtrPtr = &socketList; (*nextPtrPtr) != NULL;
d948 2
d976 1
d984 1
d987 6
a992 5
    /* CYGNUS LOCAL.  */
    infoPtr->clientChannel = 0;
    /* END CYGNUS LOCAL.  */
    infoPtr->nextPtr = socketList;
    socketList = infoPtr;
d1032 2
d1041 2
a1042 2
    
    if (winSock.hInstance == NULL) {
d1045 1
a1045 1
    
d1060 7
d1177 2
a1178 2
    (void) (*winSock.WSAAsyncSelect)(infoPtr->socket, winSock.hwnd,
	    SOCKET_MESSAGE, infoPtr->selectEvents);
d1227 1
a1227 1
    if (winSock.hInstance == NULL) {
d1231 1
a1231 1
    
a1291 1
    MSG msg;
d1294 2
d1307 5
a1311 3
    (void) (*winSock.WSAAsyncSelect)(infoPtr->socket, winSock.hwnd, 0, 0);
    (void) (*winSock.WSAAsyncSelect)(infoPtr->socket, winSock.hwnd,
	    SOCKET_MESSAGE, infoPtr->selectEvents);
a1313 3
	/*
	 * Process all outstanding messages on the socket window.
	 */
a1314 4
	while (PeekMessage(&msg, winSock.hwnd, 0, 0, PM_REMOVE)) {
	    DispatchMessage(&msg);
	}
	
d1330 1
a1330 2

	WaitMessage();
d1365 1
a1365 1
    char channelName[20];
d1367 1
a1367 1
    if (TclHasSockets(interp) != TCL_OK) {
d1380 1
a1380 1
    sprintf(channelName, "sock%d", infoPtr->socket);
d1420 2
a1421 1
    char channelName[20];
d1423 1
a1423 1
    if (TclHasSockets(NULL) != TCL_OK) {
d1427 2
a1436 3
    /* CYGNUS LOCAL: Set clientChannel.  */
    infoPtr->clientChannel = 1;

d1441 3
a1443 5
    /* CYGNUS LOCAL: Select for FD_ACCEPT and FD_CONNECT.  */
    infoPtr->selectEvents = (FD_READ | FD_CLOSE | FD_WRITE
			     | FD_ACCEPT | FD_CONNECT);
    (void) (*winSock.WSAAsyncSelect)(infoPtr->socket, winSock.hwnd,
	    SOCKET_MESSAGE, infoPtr->selectEvents);
d1445 1
a1445 1
    sprintf(channelName, "sock%d", infoPtr->socket);
d1480 1
a1480 1
    char channelName[20];
d1482 1
a1482 1
    if (TclHasSockets(interp) != TCL_OK) {
d1498 1
a1498 1
    sprintf(channelName, "sock%d", infoPtr->socket);
d1536 3
a1538 1
    char channelName[20];
d1545 3
a1547 1
    newSocket = (*winSock.accept)(infoPtr->socket, (struct sockaddr *)&addr,
d1549 1
a1549 1

d1555 6
d1562 7
a1568 1
    infoPtr->readyEvents &= ~(FD_ACCEPT);
d1570 2
a1571 2
    if (newSocket == INVALID_SOCKET) {
        return;
d1575 7
d1584 1
a1584 1

d1586 1
a1586 1

d1590 1
a1590 1

d1592 4
a1595 4
    (void) (*winSock.WSAAsyncSelect)(newInfoPtr->socket, winSock.hwnd, 
	    SOCKET_MESSAGE, newInfoPtr->selectEvents);

    sprintf(channelName, "sock%d", newInfoPtr->socket);
d1600 2
a1601 2
        Tcl_Close((Tcl_Interp *) NULL, newInfoPtr->channel);
        return;
d1605 2
a1606 2
        Tcl_Close((Tcl_Interp *) NULL, newInfoPtr->channel);
        return;
d1608 1
a1608 1

d1612 1
a1612 1

d1614 2
a1615 1
	(infoPtr->acceptProc) (infoPtr->acceptProcData, newInfoPtr->channel,
d1648 2
d1660 1
a1660 1
    if (winSock.hInstance == NULL) {
d1692 2
a1693 2
	(void) (*winSock.WSAAsyncSelect)(infoPtr->socket, winSock.hwnd,
		0, 0);
d1696 1
a1696 1

d1700 1
a1700 1

d1707 1
a1707 1

d1712 1
a1712 1

d1718 1
a1718 1

d1722 1
a1722 1

d1739 1
a1739 1
	}
d1742 3
a1744 2
    (void) (*winSock.WSAAsyncSelect)(infoPtr->socket, winSock.hwnd,
	    SOCKET_MESSAGE, infoPtr->selectEvents);
d1775 2
d1787 1
a1787 1
    if (winSock.hInstance == NULL) {
d1791 1
a1791 1
    
d1802 3
a1804 2
	(void) (*winSock.WSAAsyncSelect)(infoPtr->socket, winSock.hwnd,
		0, 0);
d1853 3
a1855 2
    (void) (*winSock.WSAAsyncSelect)(infoPtr->socket, winSock.hwnd,
	    SOCKET_MESSAGE, infoPtr->selectEvents);
d1898 1
a1898 1
    char buf[128];
d1907 1
a1907 1
    if (winSock.hInstance == NULL) {
d1920 18
d1958 1
a1958 1
            sprintf(buf, "%d", (*winSock.ntohs)(peername.sin_port));
d2004 1
a2004 1
            sprintf(buf, "%d", (*winSock.ntohs)(sockname.sin_port));
d2065 1
a2065 12
	infoPtr->watchEvents |= (FD_WRITE);
	/* CYGNUS LOCAL: For a client channel, also look for FD_CLOSE
           when waiting for a socket to be writable.  */
	if (infoPtr->clientChannel) {
	    infoPtr->watchEvents |= (FD_CLOSE);
	}
    }

    /* CYGNUS LOCAL: For a client channel, also look for FD_CONNECT
       events.  */
    if (infoPtr->clientChannel) {
	infoPtr->watchEvents |= (FD_CONNECT);
d2084 1
a2084 1
 *	Called from Tcl_GetChannelFile to retrieve an OS handle from inside
d2111 60
d2197 6
d2204 1
a2204 3
    if (message != SOCKET_MESSAGE) {
	return DefWindowProc(hwnd, message, wParam, lParam);
    }
d2206 8
a2213 8
    event = WSAGETSELECTEVENT(lParam);
    error = WSAGETSELECTERROR(lParam);
    socket = (SOCKET) wParam;

    /*
     * Find the specified socket on the socket list and update its
     * eventState flag.
     */
a2214 2
    for (infoPtr = socketList; infoPtr != NULL; infoPtr = infoPtr->nextPtr) {
	if (infoPtr->socket == socket) {
d2216 2
a2217 1
	     * Update the socket state.
d2220 58
a2277 2
	    if (event & FD_CLOSE) {
		infoPtr->readyEvents &= ~(FD_WRITE|FD_ACCEPT);
d2279 9
a2287 1
	    if (event & FD_CONNECT) {
d2289 1
a2289 2
		 * The socket is now connected, so clear the async connect
		 * flag.
d2291 6
a2296 15

		infoPtr->flags &= ~(SOCKET_ASYNC_CONNECT);

		/*
		 * Remember any error that occurred so we can report
		 * connection failures.
		 */

		if (error != ERROR_SUCCESS) {
		    TclWinConvertWSAError(error);
		    infoPtr->lastError = Tcl_GetErrno();
		}

	    } 
	    infoPtr->readyEvents |= event;
a2297 1
	}
a2299 6
    /*
     * Flush the Tcl event queue before returning to the event loop.
     */

    Tcl_ServiceAll();

d2325 4
a2328 1
    char *p;
d2331 1
d2334 6
a2340 1
    if (TclHasSockets(NULL) == TCL_OK) {
d2342 1
d2344 1
d2348 1
d2350 11
a2360 6
    if (GetComputerName(hostname, &length) != 0) {
	for (p = hostname; *p != '\0'; p++) {
	    if (isupper(*((unsigned char *) p))) {
		*p = (char) tolower(*((unsigned char *) p));
	    }
	}
d2365 1
d2388 2
a2389 2
int PASCAL FAR
TclWinGetSockOpt(SOCKET s, int level, int optname, char FAR * optval,
d2399 1
a2399 1
    if (winSock.hInstance == NULL) {
d2406 2
a2407 2
int PASCAL FAR
TclWinSetSockOpt(SOCKET s, int level, int optname, const char FAR * optval,
d2416 1
a2416 2

    if (winSock.hInstance == NULL) {
d2423 1
a2423 1
u_short PASCAL FAR
d2433 1
a2433 1
    if (winSock.hInstance == NULL) {
d2440 2
a2441 2
struct servent FAR * PASCAL FAR
TclWinGetServByName(const char FAR * name, const char FAR * proto)
d2449 2
a2450 3

    if (winSock.hInstance == NULL) {
        return (struct servent FAR *) NULL;
d2455 3
@


1.1.1.1
log
@import dejagnu-1999-11-08 snapshot
@
text
@@


1.1.1.2
log
@Tcl 8.3 upgrade
@
text
@d11 1
a11 1
 * RCS: @@(#) $Id: tclWinSock.c,v 1.7.8.2 2000/09/15 16:58:54 spolk Exp $
d14 6
a19 1
#include "tclWinInt.h"
a31 2
TCL_DECLARE_MUTEX(socketMutex)

d41 1
a87 4
#define SOCKET_SELECT	WM_USER+2
#define SOCKET_TERMINATE WM_USER+3
#define SELECT          TRUE
#define UNSELECT	FALSE
a108 2
    int acceptEventCount;          /* Count of the current number of FD_ACCEPTs
				    * that have arrived and not processed. */
d112 3
d152 3
a154 14
typedef struct ThreadSpecificData {
    /*
     * Every open socket has an entry on the following list.
     */
    
    HWND hwnd;		    /* Handle to window for socket messages. */
    HANDLE socketThread;    /* Thread handling the window */
    Tcl_ThreadId threadId;  /* Parent thread. */
    HANDLE readyEvent;      /* Event indicating that a socket event is ready.
			     * Also used to indicate that the socketThread has
			     * been initialized and has started. */
    HANDLE socketListLock;  /* Win32 Event to lock the socketList */
    SocketInfo *socketList;
} ThreadSpecificData;
d156 1
a156 2
static Tcl_ThreadDataKey dataKey;
static WNDCLASSA windowClass;
a178 2
static void		SocketThreadExitHandler _ANSI_ARGS_((ClientData clientData));
static int		SocketsEnabled _ANSI_ARGS_((void));
a196 1
static DWORD WINAPI     SocketThread _ANSI_ARGS_((LPVOID arg));
d204 10
a213 14
    "tcp",			/* Type name. */
    TCL_CHANNEL_VERSION_2,	/* v2 channel */
    TcpCloseProc,		/* Close proc. */
    TcpInputProc,		/* Input proc. */
    TcpOutputProc,		/* Output proc. */
    NULL,			/* Seek proc. */
    NULL,			/* Set option proc. */
    TcpGetOptionProc,		/* Get option proc. */
    TcpWatchProc,		/* Set up notifier to watch this channel. */
    TcpGetHandleProc,		/* Get an OS handle from channel. */
    NULL,			/* close2proc. */
    TcpBlockProc,		/* Set blocking/non-blocking mode. */
    NULL,			/* flush proc. */
    NULL,			/* handler proc. */
a230 2
 *	Assumes Mutex is held.
 *
a244 1
    DWORD id;
d246 2
a247 2
    ThreadSpecificData *tsdPtr = 
	(ThreadSpecificData *)TclThreadDataKeyGet(&dataKey);
d249 2
a250 3
    if (! initialized) {
	initialized = 1;
	Tcl_CreateExitHandler(SocketExitHandler, (ClientData) NULL);
d252 6
a257 1
	winSock.hInstance = LoadLibraryA("wsock32.dll");
d259 7
a265 3
	/*
	 * Initialize the function table.
	 */
d267 5
a271 143
	if (!SocketsEnabled()) {
	    return;
	}
    
	winSock.accept = (SOCKET (PASCAL FAR *)(SOCKET s,
		struct sockaddr FAR *addr, int FAR *addrlen))
	    GetProcAddress(winSock.hInstance, "accept");
	winSock.bind = (int (PASCAL FAR *)(SOCKET s,
		const struct sockaddr FAR *addr, int namelen))
	    GetProcAddress(winSock.hInstance, "bind");
	winSock.closesocket = (int (PASCAL FAR *)(SOCKET s))
	    GetProcAddress(winSock.hInstance, "closesocket");
	winSock.connect = (int (PASCAL FAR *)(SOCKET s,
		const struct sockaddr FAR *name, int namelen))
	    GetProcAddress(winSock.hInstance, "connect");
	winSock.ioctlsocket = (int (PASCAL FAR *)(SOCKET s, long cmd,
		u_long FAR *argp))
	    GetProcAddress(winSock.hInstance, "ioctlsocket");
	winSock.getsockopt = (int (PASCAL FAR *)(SOCKET s,
		int level, int optname, char FAR * optval, int FAR *optlen))
	    GetProcAddress(winSock.hInstance, "getsockopt");
	winSock.htons = (u_short (PASCAL FAR *)(u_short hostshort))
	    GetProcAddress(winSock.hInstance, "htons");
	winSock.inet_addr = (unsigned long (PASCAL FAR *)(const char FAR *cp))
	    GetProcAddress(winSock.hInstance, "inet_addr");
	winSock.inet_ntoa = (char FAR * (PASCAL FAR *)(struct in_addr in))
	    GetProcAddress(winSock.hInstance, "inet_ntoa");
	winSock.listen = (int (PASCAL FAR *)(SOCKET s, int backlog))
	    GetProcAddress(winSock.hInstance, "listen");
	winSock.ntohs = (u_short (PASCAL FAR *)(u_short netshort))
	    GetProcAddress(winSock.hInstance, "ntohs");
	winSock.recv = (int (PASCAL FAR *)(SOCKET s, char FAR * buf,
		int len, int flags)) GetProcAddress(winSock.hInstance, "recv");
	winSock.select = (int (PASCAL FAR *)(int nfds, fd_set FAR * readfds,
		fd_set FAR * writefds, fd_set FAR * exceptfds,
		const struct timeval FAR * tiemout))
	    GetProcAddress(winSock.hInstance, "select");
	winSock.send = (int (PASCAL FAR *)(SOCKET s, const char FAR * buf,
		int len, int flags)) GetProcAddress(winSock.hInstance, "send");
	winSock.setsockopt = (int (PASCAL FAR *)(SOCKET s, int level,
		int optname, const char FAR * optval, int optlen))
	    GetProcAddress(winSock.hInstance, "setsockopt");
	winSock.shutdown = (int (PASCAL FAR *)(SOCKET s, int how))
	    GetProcAddress(winSock.hInstance, "shutdown");
	winSock.socket = (SOCKET (PASCAL FAR *)(int af, int type,
		int protocol)) GetProcAddress(winSock.hInstance, "socket");
	winSock.gethostbyaddr = (struct hostent FAR * (PASCAL FAR *)
		(const char FAR *addr, int addrlen, int addrtype))
	    GetProcAddress(winSock.hInstance, "gethostbyaddr");
	winSock.gethostbyname = (struct hostent FAR * (PASCAL FAR *)
		(const char FAR *name))
	    GetProcAddress(winSock.hInstance, "gethostbyname");
	winSock.gethostname = (int (PASCAL FAR *)(char FAR * name,
		int namelen)) GetProcAddress(winSock.hInstance, "gethostname");
	winSock.getpeername = (int (PASCAL FAR *)(SOCKET sock,
		struct sockaddr FAR *name, int FAR *namelen))
	    GetProcAddress(winSock.hInstance, "getpeername");
	winSock.getservbyname = (struct servent FAR * (PASCAL FAR *)
		(const char FAR * name, const char FAR * proto))
	    GetProcAddress(winSock.hInstance, "getservbyname");
	winSock.getsockname = (int (PASCAL FAR *)(SOCKET sock,
		struct sockaddr FAR *name, int FAR *namelen))
	    GetProcAddress(winSock.hInstance, "getsockname");
	winSock.WSAStartup = (int (PASCAL FAR *)(WORD wVersionRequired,
		LPWSADATA lpWSAData)) GetProcAddress(winSock.hInstance, "WSAStartup");
	winSock.WSACleanup = (int (PASCAL FAR *)(void))
	    GetProcAddress(winSock.hInstance, "WSACleanup");
	winSock.WSAGetLastError = (int (PASCAL FAR *)(void))
	    GetProcAddress(winSock.hInstance, "WSAGetLastError");
	winSock.WSAAsyncSelect = (int (PASCAL FAR *)(SOCKET s, HWND hWnd,
		u_int wMsg, long lEvent))
	    GetProcAddress(winSock.hInstance, "WSAAsyncSelect");
    
	/*
	 * Now check that all fields are properly initialized. If not, return
	 * zero to indicate that we failed to initialize properly.
	 */
    
	if ((winSock.hInstance == NULL) ||
		(winSock.accept == NULL) ||
		(winSock.bind == NULL) ||
		(winSock.closesocket == NULL) ||
		(winSock.connect == NULL) ||
		(winSock.ioctlsocket == NULL) ||
		(winSock.getsockopt == NULL) ||
		(winSock.htons == NULL) ||
		(winSock.inet_addr == NULL) ||
		(winSock.inet_ntoa == NULL) ||
		(winSock.listen == NULL) ||
		(winSock.ntohs == NULL) ||
		(winSock.recv == NULL) ||
		(winSock.select == NULL) ||
		(winSock.send == NULL) ||
		(winSock.setsockopt == NULL) ||
		(winSock.socket == NULL) ||
		(winSock.gethostbyname == NULL) ||
		(winSock.gethostbyaddr == NULL) ||
		(winSock.gethostname == NULL) ||
		(winSock.getpeername == NULL) ||
		(winSock.getservbyname == NULL) ||
		(winSock.getsockname == NULL) ||
		(winSock.WSAStartup == NULL) ||
		(winSock.WSACleanup == NULL) ||
		(winSock.WSAGetLastError == NULL) ||
		(winSock.WSAAsyncSelect == NULL)) {
	    goto unloadLibrary;
	}
	
	/*
	 * Create the async notification window with a new class.  We
	 * must create a new class to avoid a Windows 95 bug that causes
	 * us to get the wrong message number for socket events if the
	 * message window is a subclass of a static control.
	 */
    
	windowClass.style = 0;
	windowClass.cbClsExtra = 0;
	windowClass.cbWndExtra = 0;
	windowClass.hInstance = TclWinGetTclInstance();
	windowClass.hbrBackground = NULL;
	windowClass.lpszMenuName = NULL;
	windowClass.lpszClassName = "TclSocket";
	windowClass.lpfnWndProc = SocketProc;
	windowClass.hIcon = NULL;
	windowClass.hCursor = NULL;

	if (!RegisterClassA(&windowClass)) {
	    TclWinConvertError(GetLastError());
	    (*winSock.WSACleanup)();
	    goto unloadLibrary;
	}
	
	/*
	 * Initialize the winsock library and check the version number.
	 */
    
	if ((*winSock.WSAStartup)(WSA_VERSION_REQD, &wsaData) != 0) {
	    goto unloadLibrary;
	}
	if (wsaData.wVersion != WSA_VERSION_REQD) {
	    (*winSock.WSACleanup)();
	    goto unloadLibrary;
	}
d275 1
a275 1
     * Check for per-thread initialization.
d278 3
a280 4
    if (tsdPtr == NULL) {
	tsdPtr = TCL_TSD_INIT(&dataKey);
	tsdPtr->socketList = NULL;
	tsdPtr->hwnd = NULL;
d282 7
a288 7
	tsdPtr->threadId = Tcl_GetCurrentThread();
	
	tsdPtr->readyEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	tsdPtr->socketListLock = CreateEvent(NULL, FALSE, TRUE, NULL);
	tsdPtr->socketThread = CreateThread(NULL, 8000, SocketThread,
		tsdPtr, 0, &id);
	SetThreadPriority(tsdPtr->socketThread, THREAD_PRIORITY_HIGHEST); 
d290 107
a396 4
	if (tsdPtr->socketThread == NULL) {
	    goto unloadLibrary;
	}
	
d398 7
a404 9
	/*
	 * Wait for the thread to signal that the window has
	 * been created and is ready to go.  Timeout after twenty
	 * seconds.
	 */
	
	if (WaitForSingleObject(tsdPtr->readyEvent, 20000) == WAIT_TIMEOUT) {
	    goto unloadLibrary;
	}
d406 28
a433 6
	if (tsdPtr->hwnd == NULL) {
	    goto unloadLibrary;
	}
	
	Tcl_CreateEventSource(SocketSetupProc, SocketCheckProc, NULL);
	Tcl_CreateThreadExitHandler(SocketThreadExitHandler, NULL);
d435 1
a438 11
    if (tsdPtr != NULL) {
	if (tsdPtr->hwnd != NULL) {
	    DestroyWindow(tsdPtr->hwnd);
	}
	if (tsdPtr->socketThread != NULL) {
	    TerminateThread(tsdPtr->socketThread, 0);
	    tsdPtr->socketThread = NULL;
	}
	CloseHandle(tsdPtr->readyEvent);
	CloseHandle(tsdPtr->socketListLock);
    }
a446 28
 * SocketsEnabled --
 *
 *	Check that the WinSock DLL is loaded and ready.
 *
 * Results:
 *	1 if it is.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

    /* ARGSUSED */
static int
SocketsEnabled()
{
    int enabled;
    Tcl_MutexLock(&socketMutex);
    enabled = (winSock.hInstance != NULL);
    Tcl_MutexUnlock(&socketMutex);
    return enabled;
}


/*
 *----------------------------------------------------------------------
 *
a465 1
    Tcl_MutexLock(&socketMutex);
d467 2
a468 1
	UnregisterClassA("TclSocket", TclWinGetTclInstance());
d473 1
a475 48
    Tcl_MutexUnlock(&socketMutex);
}

/*
 *----------------------------------------------------------------------
 *
 * SocketThreadExitHandler --
 *
 *	Callback invoked during thread clean up to delete the socket
 *	event source.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Delete the event source.
 *
 *----------------------------------------------------------------------
 */

    /* ARGSUSED */
static void
SocketThreadExitHandler(clientData)
    ClientData clientData;              /* Not used. */
{
    ThreadSpecificData *tsdPtr = 
	(ThreadSpecificData *)TclThreadDataKeyGet(&dataKey);

    if (tsdPtr->socketThread != NULL) {

	PostMessage(tsdPtr->hwnd, SOCKET_TERMINATE, 0, 0);

        /*
	 * Wait for the thread to terminate.  This ensures that we are
	 * completely cleaned up before we leave this function. 
	 */

	WaitForSingleObject(tsdPtr->socketThread, INFINITE);
	CloseHandle(tsdPtr->socketThread);
	CloseHandle(tsdPtr->readyEvent);
	CloseHandle(tsdPtr->socketListLock);

    }
    if (tsdPtr->hwnd != NULL) {
	DestroyWindow(tsdPtr->hwnd);
    }
    
    Tcl_DeleteEventSource(SocketSetupProc, SocketCheckProc, NULL);
d481 1
a481 1
 * TclpHasSockets --
d498 1
a498 1
TclpHasSockets(interp)
d501 5
a505 5
    Tcl_MutexLock(&socketMutex);
    InitSockets();
    Tcl_MutexUnlock(&socketMutex);

    if (SocketsEnabled()) {
a538 1
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
d548 1
a548 3
    WaitForSingleObject(tsdPtr->socketListLock, INFINITE);
    for (infoPtr = tsdPtr->socketList; infoPtr != NULL; 
	    infoPtr = infoPtr->nextPtr) {
a553 1
    SetEvent(tsdPtr->socketListLock);
a579 1
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
d591 1
a591 3
    WaitForSingleObject(tsdPtr->socketListLock, INFINITE);
    for (infoPtr = tsdPtr->socketList; infoPtr != NULL; 
	    infoPtr = infoPtr->nextPtr) {
a600 1
    SetEvent(tsdPtr->socketListLock);
a633 1
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
d643 1
a643 3
    WaitForSingleObject(tsdPtr->socketListLock, INFINITE);
    for (infoPtr = tsdPtr->socketList; infoPtr != NULL; 
	    infoPtr = infoPtr->nextPtr) {
d648 1
a648 2
    SetEvent(tsdPtr->socketListLock);
    
d664 9
a672 2
	TcpAccept(infoPtr);
	return 1;
d675 7
d704 9
d720 1
a720 1
	 * notification so select will work correctly.	If the socket is
d725 1
a725 2
	SendMessage(tsdPtr->hwnd, SOCKET_SELECT,
		(WPARAM) UNSELECT, (LPARAM) infoPtr);
d731 1
a731 1
 
d735 2
a736 2
	    SendMessage(tsdPtr->hwnd, SOCKET_SELECT,
		    (WPARAM) SELECT, (LPARAM) infoPtr);
d739 1
d741 1
a741 1
    if (events & (FD_WRITE | FD_CONNECT)) {
a809 1
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
d818 1
a818 1
    if (SocketsEnabled()) {
d836 1
a836 2
    WaitForSingleObject(tsdPtr->socketListLock, INFINITE);
    for (nextPtrPtr = &(tsdPtr->socketList); (*nextPtrPtr) != NULL;
a842 2
    SetEvent(tsdPtr->socketListLock);
    
a868 1
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
a875 1
    infoPtr->acceptEventCount = 0;
d878 5
a882 6

    WaitForSingleObject(tsdPtr->socketListLock, INFINITE);
    infoPtr->nextPtr = tsdPtr->socketList;
    tsdPtr->socketList = infoPtr;
    SetEvent(tsdPtr->socketListLock);
    
a921 2
    ThreadSpecificData *tsdPtr = 
	(ThreadSpecificData *)TclThreadDataKeyGet(&dataKey);
d929 2
a930 2

    if (!SocketsEnabled()) {
d933 1
a933 1

a947 7
     * Win-NT has a misfeature that sockets are inherited in child
     * processes by default.  Turn off the inherit bit.
     */

    SetHandleInformation( (HANDLE) sock, HANDLE_FLAG_INHERIT, 0 );
	
    /*
d1058 2
a1059 2
    SendMessage(tsdPtr->hwnd, SOCKET_SELECT,
	    (WPARAM) SELECT, (LPARAM) infoPtr);
d1108 1
a1108 1
    if (!SocketsEnabled()) {
d1112 1
a1112 1

d1173 1
a1175 2
    ThreadSpecificData *tsdPtr = 
	(ThreadSpecificData *)TclThreadDataKeyGet(&dataKey);
d1187 3
a1189 5
    SendMessage(tsdPtr->hwnd, SOCKET_SELECT,
	    (WPARAM) UNSELECT, (LPARAM) infoPtr);

    SendMessage(tsdPtr->hwnd, SOCKET_SELECT,
	    (WPARAM) SELECT, (LPARAM) infoPtr);
d1192 3
d1196 4
d1215 2
a1216 1
	WaitForSingleObject(tsdPtr->readyEvent, INFINITE);
d1251 1
a1251 1
    char channelName[16 + TCL_INTEGER_SPACE];
d1253 1
a1253 1
    if (TclpHasSockets(interp) != TCL_OK) {
d1266 1
a1266 1
    wsprintfA(channelName, "sock%d", infoPtr->socket);
d1306 1
a1306 2
    char channelName[16 + TCL_INTEGER_SPACE];
    ThreadSpecificData *tsdPtr;
d1308 1
a1308 1
    if (TclpHasSockets(NULL) != TCL_OK) {
a1311 2
    tsdPtr = (ThreadSpecificData *)TclThreadDataKeyGet(&dataKey);

d1320 3
d1327 5
a1331 3
    infoPtr->selectEvents = FD_READ | FD_CLOSE | FD_WRITE;
    SendMessage(tsdPtr->hwnd, SOCKET_SELECT,
	    (WPARAM) SELECT, (LPARAM) infoPtr);
d1333 1
a1333 1
    wsprintfA(channelName, "sock%d", infoPtr->socket);
d1368 1
a1368 1
    char channelName[16 + TCL_INTEGER_SPACE];
d1370 1
a1370 1
    if (TclpHasSockets(interp) != TCL_OK) {
d1386 1
a1386 1
    wsprintfA(channelName, "sock%d", infoPtr->socket);
d1424 1
a1424 3
    char channelName[16 + TCL_INTEGER_SPACE];
    ThreadSpecificData *tsdPtr = 
	(ThreadSpecificData *)TclThreadDataKeyGet(&dataKey);
d1431 2
a1433 4
    newSocket = (*winSock.accept)(infoPtr->socket,
	    (struct sockaddr *)&addr,
	    &len);
    
a1438 6
    
    if (newSocket == INVALID_SOCKET) {
	infoPtr->acceptEventCount = 0;
	infoPtr->readyEvents &= ~(FD_ACCEPT);
	return;
    } 
d1440 1
a1440 7
    /*
     * It is possible that more than one FD_ACCEPT has been sent, so an extra
     * count must be kept.  Decrement the count, and reset the readyEvent bit
     * if the count is no longer > 0.
     */
    
    infoPtr->acceptEventCount--;
d1442 2
a1443 2
    if (infoPtr->acceptEventCount <= 0) {
	infoPtr->readyEvents &= ~(FD_ACCEPT);
a1446 7
     * Win-NT has a misfeature that sockets are inherited in child
     * processes by default.  Turn off the inherit bit.
     */
    
    SetHandleInformation( (HANDLE) newSocket, HANDLE_FLAG_INHERIT, 0 );
    
    /*
d1449 1
a1449 1
    
d1451 1
a1451 1
    
d1455 1
a1455 1
    
d1457 4
a1460 4
    SendMessage(tsdPtr->hwnd, SOCKET_SELECT,
	    (WPARAM) SELECT, (LPARAM) newInfoPtr);
    
    wsprintfA(channelName, "sock%d", newInfoPtr->socket);
d1465 2
a1466 2
	Tcl_Close((Tcl_Interp *) NULL, newInfoPtr->channel);
	return;
d1470 2
a1471 2
	Tcl_Close((Tcl_Interp *) NULL, newInfoPtr->channel);
	return;
d1473 1
a1473 1
    
d1477 1
a1477 1
    
d1479 1
a1479 2
	(infoPtr->acceptProc) (infoPtr->acceptProcData,
		newInfoPtr->channel,
a1511 2
    ThreadSpecificData *tsdPtr = 
	(ThreadSpecificData *)TclThreadDataKeyGet(&dataKey);
d1522 1
a1522 1
    if (!SocketsEnabled()) {
d1554 2
a1555 2
	SendMessage(tsdPtr->hwnd, SOCKET_SELECT,
		(WPARAM) UNSELECT, (LPARAM) infoPtr);
d1558 1
a1558 1
  
d1562 1
a1562 1
  
d1569 1
a1569 1
  
d1574 1
a1574 1
  
d1580 1
a1580 1
  
d1584 1
a1584 1
  
d1601 1
a1601 1
  	}
d1604 2
a1605 3
    SendMessage(tsdPtr->hwnd, SOCKET_SELECT,
	    (WPARAM) SELECT, (LPARAM) infoPtr);
    
a1635 2
    ThreadSpecificData *tsdPtr = 
	(ThreadSpecificData *)TclThreadDataKeyGet(&dataKey);
d1646 1
a1646 1
    if (!SocketsEnabled()) {
d1650 1
a1650 1

d1661 2
a1662 3
	SendMessage(tsdPtr->hwnd, SOCKET_SELECT,
		(WPARAM) UNSELECT, (LPARAM) infoPtr);

d1711 2
a1712 3
    SendMessage(tsdPtr->hwnd, SOCKET_SELECT,
	    (WPARAM) SELECT, (LPARAM) infoPtr);
    
d1755 1
a1755 1
    char buf[TCL_INTEGER_SPACE];
d1764 1
a1764 1
    if (!SocketsEnabled()) {
a1776 18
    if ((len > 1) && (optionName[1] == 'e') &&
	    (strncmp(optionName, "-error", len) == 0)) {
	int optlen;
	int err, ret;
    
	optlen = sizeof(int);
	ret = TclWinGetSockOpt(sock, SOL_SOCKET, SO_ERROR,
		(char *)&err, &optlen);
	if (ret == SOCKET_ERROR) {
	    err = (*winSock.WSAGetLastError)();
	}
	if (err) {
	    TclWinConvertWSAError(err);
	    Tcl_DStringAppend(dsPtr, Tcl_ErrnoMsg(Tcl_GetErrno()), -1);
	}
	return TCL_OK;
    }

d1797 1
a1797 1
	    TclFormatInt(buf, (*winSock.ntohs)(peername.sin_port));
d1843 1
a1843 1
            TclFormatInt(buf, (*winSock.ntohs)(sockname.sin_port));
d1904 12
a1915 1
	infoPtr->watchEvents |= (FD_WRITE|FD_CONNECT);
d1934 1
a1934 1
 *	Called from Tcl_GetChannelHandle to retrieve an OS handle from inside
a1960 60
 * SocketThread --
 *
 *	Helper thread used to manage the socket event handling window.
 *
 * Results:
 *	1 if unable to create socket event window, 0 otherwise.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static DWORD WINAPI
SocketThread(LPVOID arg)
{
    MSG msg;
    ThreadSpecificData *tsdPtr = (ThreadSpecificData *)(arg);

    tsdPtr->hwnd = CreateWindowA("TclSocket", "TclSocket", 
	    WS_TILED, 0, 0, 0, 0, NULL, NULL, windowClass.hInstance, NULL);

    /*
     * Signal the main thread that the window has been created
     * and that the socket thread is ready to go.
     */
    
    SetEvent(tsdPtr->readyEvent);
    
    if (tsdPtr->hwnd == NULL) {
	return 1;
    } else {
	/*
	 * store the tsdPtr, it's from a different thread, so it's
	 * not directly accessible, but needed.
	 */

#ifdef _WIN64
	SetWindowLongPtr(tsdPtr->hwnd, GWLP_USERDATA, (LONG) tsdPtr);
#else
	SetWindowLong(tsdPtr->hwnd, GWL_USERDATA, (LONG) tsdPtr);
#endif
    }

    while (1) {
	/*
	 * Process all outstanding messages on the socket window.
	 */

	while (PeekMessage(&msg, tsdPtr->hwnd, 0, 0, PM_REMOVE)) {
	    DispatchMessage(&msg);
	}
	WaitMessage();
    }
}


/*
 *----------------------------------------------------------------------
 *
a1986 6
    ThreadSpecificData *tsdPtr =
#ifdef _WIN64
	(ThreadSpecificData *) GetWindowLongPtr(hwnd, GWLP_USERDATA);
#else
	(ThreadSpecificData *) GetWindowLong(hwnd, GWL_USERDATA);
#endif
d1988 7
a1994 1
    switch (message) {
d1996 4
a1999 8
	default:
	    return DefWindowProc(hwnd, message, wParam, lParam);
	    break;
	    
	case SOCKET_MESSAGE:
	    event = WSAGETSELECTEVENT(lParam);
	    error = WSAGETSELECTERROR(lParam);
	    socket = (SOCKET) wParam;
d2001 2
d2004 1
a2004 2
	     * Find the specified socket on the socket list and update its
	     * eventState flag.
d2007 2
a2008 58
	    WaitForSingleObject(tsdPtr->socketListLock, INFINITE);
	    for (infoPtr = tsdPtr->socketList; infoPtr != NULL; 
		 infoPtr = infoPtr->nextPtr) {
		if (infoPtr->socket == socket) {
		    /*
		     * Update the socket state.
		     */

		    /*
		     * A count of FD_ACCEPTS is stored, so if an FD_CLOSE event
		     * happens, then clear the FD_ACCEPT count.  Otherwise,
		     * increment the count if the current event is and
		     * FD_ACCEPT.
		     */
		    
		    if (event & FD_CLOSE) {
			infoPtr->acceptEventCount = 0;
			infoPtr->readyEvents &= ~(FD_WRITE|FD_ACCEPT);
		    } else if (event & FD_ACCEPT) {
			infoPtr->acceptEventCount++;
		    }

		    if (event & FD_CONNECT) {
			/*
			 * The socket is now connected,
			 * clear the async connect flag.
			 */
			
			infoPtr->flags &= ~(SOCKET_ASYNC_CONNECT);
			
			/*
			 * Remember any error that occurred so we can report
			 * connection failures.
			 */
			
			if (error != ERROR_SUCCESS) {
			    TclWinConvertWSAError(error);
			    infoPtr->lastError = Tcl_GetErrno();
			}
			
		    } 
		    if(infoPtr->flags & SOCKET_ASYNC_CONNECT) {
			infoPtr->flags &= ~(SOCKET_ASYNC_CONNECT);
			if (error != ERROR_SUCCESS) {
			    TclWinConvertWSAError(error);
			    infoPtr->lastError = Tcl_GetErrno();
			}
			infoPtr->readyEvents |= FD_WRITE;
		    }
		    infoPtr->readyEvents |= event;

		    /*
		     * Wake up the Main Thread.
		     */
		    SetEvent(tsdPtr->readyEvent);
		    Tcl_ThreadAlert(tsdPtr->threadId);
		    break;
		}
d2010 8
a2017 9
	    SetEvent(tsdPtr->socketListLock);
	    break;
	case SOCKET_SELECT:
	    infoPtr = (SocketInfo *) lParam;
	    if (wParam == SELECT) {

		(void) (*winSock.WSAAsyncSelect)(infoPtr->socket, hwnd,
			SOCKET_MESSAGE, infoPtr->selectEvents);
	    } else {
d2019 2
a2020 1
		 * Clear the selection mask
d2022 8
a2029 6
		
		(void) (*winSock.WSAAsyncSelect)(infoPtr->socket, hwnd, 0, 0);
	    }
	    break;
	case SOCKET_TERMINATE:
	    ExitThread(0);
d2031 1
d2034 6
d2065 1
a2065 4
    WCHAR wbuf[MAX_COMPUTERNAME_LENGTH + 1];

    Tcl_MutexLock(&socketMutex);
    InitSockets();
a2067 1
	Tcl_MutexUnlock(&socketMutex);
a2069 6
    Tcl_MutexUnlock(&socketMutex);
	
    if (TclpHasSockets(NULL) == TCL_OK) {
	/*
	 * INTL: bug
	 */
d2071 1
a2072 1
	    Tcl_MutexLock(&socketMutex);
a2073 1
	    Tcl_MutexUnlock(&socketMutex);
a2076 1
    Tcl_MutexLock(&socketMutex);
d2078 6
a2083 11
    if ((*tclWinProcs->getComputerNameProc)(wbuf, &length) != 0) {
	/*
	 * Convert string from native to UTF then change to lowercase.
	 */

	Tcl_DString ds;

	lstrcpynA(hostname, Tcl_WinTCharToUtf((TCHAR *) wbuf, -1, &ds),
		sizeof(hostname));
	Tcl_DStringFree(&ds);
	Tcl_UtfToLower(hostname);
a2087 1
    Tcl_MutexUnlock(&socketMutex);
d2110 2
a2111 2
int
TclWinGetSockOpt(SOCKET s, int level, int optname, char * optval,
d2121 1
a2121 1
    if (!SocketsEnabled()) {
d2128 2
a2129 2
int
TclWinSetSockOpt(SOCKET s, int level, int optname, const char * optval,
d2138 2
a2139 1
    if (!SocketsEnabled()) {
d2146 1
a2146 1
u_short
d2156 1
a2156 1
    if (!SocketsEnabled()) {
d2163 2
a2164 2
struct servent *
TclWinGetServByName(const char * name, const char * proto)
d2172 3
a2174 2
    if (!SocketsEnabled()) {
        return (struct servent *) NULL;
a2178 3



@


1.1.1.3
log
@import tcl 8.4.0
@
text
@d11 1
a11 1
 * RCS: @@(#) $Id: tclWinSock.c,v 1.26 2002/05/24 18:57:09 andreas_kupries Exp $
d174 2
a175 2
			    int port, CONST char *host, int server,
			    CONST char *myaddr, int myport, int async));
d178 1
a178 1
			    CONST char *host, int port));
d198 1
a198 1
		            Tcl_Interp *interp, CONST char *optionName,
d203 1
a203 1
	            	    CONST char *buf, int toWrite, int *errorCode));
d229 1
a229 1
    TcpBlockProc,		/* Set socket into (non-)blocking mode. */
a838 1
	    infoPtr->readyEvents &= ~(FD_READ);
d841 1
d1017 1
a1017 1
    CONST char *host;		/* Name of host on which to open port. */
d1020 1
a1020 1
    CONST char *myaddr;		/* Optional client-side address */
d1214 1
a1214 1
    CONST char *host;			/* Host.  NULL implies INADDR_ANY */
d1358 2
a1359 2
    CONST char *host;			/* Host on which to open port. */
    CONST char *myaddr;			/* Client-side address */
d1474 1
a1474 1
    CONST char *host;			/* Name of local host. */
d1768 1
a1768 1
    CONST char *buf;			/* Where to get data. */
d1884 1
a1884 1
    CONST char *optionName;		/* Name of the option to
d1949 3
a1951 8

	    if (peername.sin_addr.s_addr == 0) {
	        hostEntPtr = (struct hostent *) NULL;
	    } else {
	        hostEntPtr = (*winSock.gethostbyaddr)(
                    (char *) &(peername.sin_addr), sizeof(peername.sin_addr),
		    AF_INET);
	    }
d1995 3
a1997 7
	    if (sockname.sin_addr.s_addr == 0) {
	        hostEntPtr = (struct hostent *) NULL;
	    } else {
	        hostEntPtr = (*winSock.gethostbyaddr)(
                    (char *) &(sockname.sin_addr), sizeof(peername.sin_addr),
		    AF_INET);
	    }
d2057 1
a2057 2
     * Update the watch events mask. Only if the socket is not a
     * server socket. Fix for SF Tcl Bug #557878.
d2059 8
d2068 4
a2071 13
    if (!infoPtr->acceptProc) {    
        infoPtr->watchEvents = 0;
	if (mask & TCL_READABLE) {
	    infoPtr->watchEvents |= (FD_READ|FD_CLOSE|FD_ACCEPT);
	}
	if (mask & TCL_WRITABLE) {
	    infoPtr->watchEvents |= (FD_WRITE|FD_CONNECT);
	}
      
	/*
	 * If there are any conditions already set, then tell the notifier to poll
	 * rather than block.
	 */
d2073 4
a2076 5
	if (infoPtr->readyEvents & infoPtr->watchEvents) {
	    Tcl_Time blockTime = { 0, 0 };
	    Tcl_SetMaxBlockTime(&blockTime);
	}
    }
d2149 1
a2149 1
	SetWindowLongPtr(tsdPtr->hwnd, GWLP_USERDATA, (LONG_PTR) tsdPtr);
d2321 1
a2321 1
CONST char *
d2455 1
@


