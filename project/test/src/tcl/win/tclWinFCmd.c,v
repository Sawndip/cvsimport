head	1.7;
access;
symbols
	sid-snapshot-20180601:1.7
	sid-snapshot-20180501:1.7
	sid-snapshot-20180401:1.7
	sid-snapshot-20180301:1.7
	sid-snapshot-20180201:1.7
	sid-snapshot-20180101:1.7
	sid-snapshot-20171201:1.7
	sid-snapshot-20171101:1.7
	sid-snapshot-20171001:1.7
	sid-snapshot-20170901:1.7
	sid-snapshot-20170801:1.7
	sid-snapshot-20170701:1.7
	sid-snapshot-20170601:1.7
	sid-snapshot-20170501:1.7
	sid-snapshot-20170401:1.7
	sid-snapshot-20170301:1.7
	sid-snapshot-20170201:1.7
	sid-snapshot-20170101:1.7
	sid-snapshot-20161201:1.7
	sid-snapshot-20161101:1.7
	sid-snapshot-20160901:1.7
	sid-snapshot-20160801:1.7
	sid-snapshot-20160701:1.7
	sid-snapshot-20160601:1.7
	sid-snapshot-20160501:1.7
	sid-snapshot-20160401:1.7
	sid-snapshot-20160301:1.7
	sid-snapshot-20160201:1.7
	sid-snapshot-20160101:1.7
	sid-snapshot-20151201:1.7
	sid-snapshot-20151101:1.7
	sid-snapshot-20151001:1.7
	sid-snapshot-20150901:1.7
	sid-snapshot-20150801:1.7
	sid-snapshot-20150701:1.7
	sid-snapshot-20150601:1.7
	sid-snapshot-20150501:1.7
	sid-snapshot-20150401:1.7
	sid-snapshot-20150301:1.7
	sid-snapshot-20150201:1.7
	sid-snapshot-20150101:1.7
	sid-snapshot-20141201:1.7
	sid-snapshot-20141101:1.7
	sid-snapshot-20141001:1.7
	sid-snapshot-20140901:1.7
	sid-snapshot-20140801:1.7
	sid-snapshot-20140701:1.7
	sid-snapshot-20140601:1.7
	sid-snapshot-20140501:1.7
	sid-snapshot-20140401:1.7
	sid-snapshot-20140301:1.7
	sid-snapshot-20140201:1.7
	sid-snapshot-20140101:1.7
	sid-snapshot-20131201:1.7
	sid-snapshot-20131101:1.7
	sid-snapshot-20131001:1.7
	sid-snapshot-20130901:1.7
	sid-snapshot-20130801:1.7
	sid-snapshot-20130701:1.7
	sid-snapshot-20130601:1.7
	insight_7_6-2013-04-10-branchpoint:1.7
	gdb_7_6-branch:1.7.0.24
	sid-snapshot-20130501:1.7
	sid-snapshot-20130401:1.7
	sid-snapshot-20130301:1.7
	sid-snapshot-20130201:1.7
	sid-snapshot-20130101:1.7
	sid-snapshot-20121201:1.7
	sid-snapshot-20121101:1.7
	sid-snapshot-20121001:1.7
	sid-snapshot-20120901:1.7
	gdb_7_5-branch:1.7.0.22
	sid-snapshot-20120801:1.7
	sid-snapshot-20120701:1.7
	sid-snapshot-20120601:1.7
	sid-snapshot-20120501:1.7
	sid-snapshot-20120401:1.7
	gdb_7_4-branch:1.7.0.20
	sid-snapshot-20120301:1.7
	sid-snapshot-20120201:1.7
	sid-snapshot-20120101:1.7
	sid-snapshot-20111201:1.7
	sid-snapshot-20111101:1.7
	sid-snapshot-20111001:1.7
	sid-snapshot-20110901:1.7
	gdb_7_3-branch:1.7.0.18
	sid-snapshot-20110801:1.7
	sid-snapshot-20110701:1.7
	sid-snapshot-20110601:1.7
	sid-snapshot-20110501:1.7
	sid-snapshot-20110401:1.7
	sid-snapshot-20110301:1.7
	sid-snapshot-20110201:1.7
	sid-snapshot-20110101:1.7
	sid-snapshot-20101201:1.7
	sid-snapshot-20101101:1.7
	sid-snapshot-20101001:1.7
	sid-snapshot-20100901:1.7
	sid-snapshot-20100801:1.7
	sid-snapshot-20100701:1.7
	sid-snapshot-20100601:1.7
	sid-snapshot-20100501:1.7
	sid-snapshot-20100401:1.7
	sid-snapshot-20100301:1.7
	gdb_7_1-branch:1.7.0.16
	gdb_7_0-branch:1.7.0.14
	sid-snapshot-20100201:1.7
	sid-snapshot-20100101:1.7
	sid-snapshot-20091201:1.7
	sid-snapshot-20091101:1.7
	sid-snapshot-20091001:1.7
	arc-sim-20090309:1.7
	sid-snapshot-20090901:1.7
	sid-snapshot-20090801:1.7
	sid-snapshot-20090701:1.7
	sid-snapshot-20090601:1.7
	sid-snapshot-20090501:1.7
	kevinb-pre-tcl8_5_7_merge:1.7
	sid-snapshot-20090401:1.7
	arc-insight_6_8-branch:1.7.0.12
	arc-insight_6_8-branchpoint:1.7
	insight_6_8-branch:1.7.0.10
	insight_6_8-branchpoint:1.7
	sid-snapshot-20090301:1.7
	sid-snapshot-20090201:1.7
	sid-snapshot-20090101:1.7
	sid-snapshot-20081201:1.7
	sid-snapshot-20081101:1.7
	sid-snapshot-20081001:1.7
	sid-snapshot-20080901:1.7
	sid-snapshot-20080801:1.7
	sid-snapshot-20080701:1.7
	sid-snapshot-20080601:1.7
	sid-snapshot-20080501:1.7
	sid-snapshot-20080403:1.7
	sid-snapshot-20080401:1.7
	gdb_6_8-branch:1.7.0.8
	sid-snapshot-20080301:1.7
	sid-snapshot-20080201:1.7
	sid-snapshot-20080101:1.7
	sid-snapshot-20071201:1.7
	sid-snapshot-20071101:1.7
	sid-snapshot-20071001:1.7
	insight_6_6-20070208-release:1.7
	gdb_6_6-branch:1.7.0.6
	gdb_6_6-2006-11-15-branchpoint:1.7
	insight_6_5-20061003-release:1.7
	gdb_6_5-branch:1.7.0.4
	gdb_6_5-2006-05-14-branchpoint:1.7
	readline_5_1-import-branch:1.7.0.2
	readline_5_1-import-branchpoint:1.7
	gdb_6_4-branch:1.6.0.32
	gdb_6_4-2005-11-01-branchpoint:1.6
	msnyder-tracepoint-checkpoint-branch:1.6.0.30
	msnyder-tracepoint-checkpoint-branchpoint:1.6
	gdb_6_1-2004-04-05-release:1.6
	ezannoni_pie-20040323-branch:1.6.0.28
	ezannoni_pie-20040323-branchpoint:1.6
	cagney_tramp-20040321-mergepoint:1.6
	cagney_tramp-20040309-branch:1.6.0.26
	cagney_tramp-20040309-branchpoint:1.6
	gdb_6_1-branch:1.6.0.24
	gdb_6_1-2004-03-01-gmt-branchpoint:1.6
	drow-cplus-merge-20040208:1.6
	carlton_dictionary-20040126-merge:1.6
	drow-cplus-merge-20040113:1.6
	drow-cplus-merge-20031224:1.6
	drow-cplus-merge-20031220:1.6
	carlton_dictionary-20031215-merge:1.6
	drow-cplus-merge-20031214:1.6
	carlton-dictionary-20031111-merge:1.6
	gdb_6_0-2003-10-04-release:1.6
	carlton_dictionary-20030917-merge:1.6
	ezannoni_pie-20030916-branchpoint:1.6
	ezannoni_pie-20030916-branch:1.6.0.22
	cagney_x86i386-20030821-branch:1.6.0.20
	cagney_x86i386-20030821-branchpoint:1.6
	carlton_dictionary-20030805-merge:1.6
	carlton_dictionary-20030627-merge:1.6
	gdb_6_0-branch:1.6.0.18
	gdb_6_0-2003-06-23-branchpoint:1.6
	cagney_convert-20030606-branch:1.6.0.16
	cagney_convert-20030606-branchpoint:1.6
	cagney_writestrings-20030508-branch:1.6.0.14
	cagney_writestrings-20030508-branchpoint:1.6
	carlton_dictionary-20030523-merge:1.6
	cagney_fileio-20030521-branch:1.6.0.12
	cagney_fileio-20030521-branchpoint:1.6
	carlton_dictionary-20030430-merge:1.6
	carlton_dictionary-20030416-merge:1.6
	cagney_frameaddr-20030409-mergepoint:1.6
	cagney_frameaddr-20030403-branchpoint:1.6
	cagney_frameaddr-20030403-branch:1.6.0.10
	cagney_framebase-20030330-mergepoint:1.6
	cagney_framebase-20030326-branch:1.6.0.8
	cagney_framebase-20030326-branchpoint:1.6
	cagney_lazyid-20030317-branch:1.6.0.6
	cagney_lazyid-20030317-branchpoint:1.6
	offbyone-20030313-branch:1.6.0.4
	offbyone-20030313-branchpoint:1.6
	carlton_dictionary-20030305-merge:1.6
	cagney_offbyone-20030303-branch:1.6.0.2
	cagney_offbyone-20030303-branchpoint:1.6
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.2
	interps-20030202-branchpoint:1.5
	TCL8_4_1:1.1.1.3
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.2
	TCL_8_4_1:1.1.1.3
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.4
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TCL_8_4_0:1.1.1.3
	carlton_dictionary-branch:1.2.0.16
	carlton_dictionary-20020920-branchpoint:1.2
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.14
	gdb_5_3-branch:1.2.0.12
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.10
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.8
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.6
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TCL_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	dejagnu-2000-02-04:1.1.1.1
	dejagnu-2000-01-31:1.1.1.1
	dejagnu-2000-01-24:1.1.1.1
	dejagnu-2000-01-17:1.1.1.1
	dejagnu-2000-01-10:1.1.1.1
	dejagnu-2000-01-04:1.1.1.1
	dejagnu-1999-12-21:1.1.1.1
	dejagnu-1999-12-13:1.1.1.1
	dejagnu-1999-12-07:1.1.1.1
	dejagnu-1999-12-06:1.1.1.1
	dejagnu-1999-11-15:1.1.1.1
	dejagnu-1999-11-08:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.7
date	2006.02.02.20.02.09;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2003.02.07.19.52.00;	author hunt;	state Exp;
branches;
next	1.5;

1.5
date	2003.01.21.19.40.22;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.26.19.48.06;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.37.11;	author kseitz;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2001.09.09.23.56.10;	author irox;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2002.09.27.21.49.14;	author kseitz;	state Exp;
branches;
next	;

1.3.4.1
date	2003.12.14.20.28.54;	author drow;	state Exp;
branches;
next	;

1.2.16.1
date	2002.12.23.19.40.57;	author carlton;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2003.02.07.19.18.24;	author carlton;	state Exp;
branches;
next	1.2.16.3;

1.2.16.3
date	2003.03.06.00.56.45;	author carlton;	state Exp;
branches;
next	;

1.1.1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.09.22.41.00;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.19.56.44;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.7
log
@* win/tclWin32Dll.c (_except_checkstackspace_handler): Define with proper
attribute to prevent this static function from being deleted due to aggressive
gcc optimization.
* win/tclWinChan.c (_except_makefilechannel_handler): Ditto.
* win/tclWinFCmd.c (_except_dorenamefile_handler): Ditto.
* configure.in: Make sure that TCL_LIB_SPEC is properly filled out.
* configure: Regenerate.
@
text
@/*
 * tclWinFCmd.c
 *
 *      This file implements the Windows specific portion of file manipulation 
 *      subcommands of the "file" command. 
 *
 * Copyright (c) 1996-1998 Sun Microsystems, Inc.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tclWinFCmd.c,v 1.34 2003/02/04 17:06:53 vincentdarley Exp $
 */

#include "tclWinInt.h"

/*
 * The following constants specify the type of callback when
 * TraverseWinTree() calls the traverseProc()
 */

#define DOTREE_PRED   1     /* pre-order directory  */
#define DOTREE_POSTD  2     /* post-order directory */
#define DOTREE_F      3     /* regular file */

/*
 * Callbacks for file attributes code.
 */

static int		GetWinFileAttributes _ANSI_ARGS_((Tcl_Interp *interp,
			    int objIndex, Tcl_Obj *fileName,
			    Tcl_Obj **attributePtrPtr));
static int		GetWinFileLongName _ANSI_ARGS_((Tcl_Interp *interp,
			    int objIndex, Tcl_Obj *fileName,
			    Tcl_Obj **attributePtrPtr));
static int		GetWinFileShortName _ANSI_ARGS_((Tcl_Interp *interp,
			    int objIndex, Tcl_Obj *fileName,
			    Tcl_Obj **attributePtrPtr));
static int		SetWinFileAttributes _ANSI_ARGS_((Tcl_Interp *interp,
			    int objIndex, Tcl_Obj *fileName,
			    Tcl_Obj *attributePtr));
static int		CannotSetAttribute _ANSI_ARGS_((Tcl_Interp *interp,
			    int objIndex, Tcl_Obj *fileName,
			    Tcl_Obj *attributePtr));

/*
 * Constants and variables necessary for file attributes subcommand.
 */

enum {
    WIN_ARCHIVE_ATTRIBUTE,
    WIN_HIDDEN_ATTRIBUTE,
    WIN_LONGNAME_ATTRIBUTE,
    WIN_READONLY_ATTRIBUTE,
    WIN_SHORTNAME_ATTRIBUTE,
    WIN_SYSTEM_ATTRIBUTE
};

static int attributeArray[] = {FILE_ATTRIBUTE_ARCHIVE, FILE_ATTRIBUTE_HIDDEN,
	0, FILE_ATTRIBUTE_READONLY, 0, FILE_ATTRIBUTE_SYSTEM};


CONST char *tclpFileAttrStrings[] = {
	"-archive", "-hidden", "-longname", "-readonly",
	"-shortname", "-system", (char *) NULL
};

CONST TclFileAttrProcs tclpFileAttrProcs[] = {
	{GetWinFileAttributes, SetWinFileAttributes},
	{GetWinFileAttributes, SetWinFileAttributes},
	{GetWinFileLongName, CannotSetAttribute},
	{GetWinFileAttributes, SetWinFileAttributes},
	{GetWinFileShortName, CannotSetAttribute},
	{GetWinFileAttributes, SetWinFileAttributes}};

#if defined(HAVE_NO_SEH) && defined(TCL_MEM_DEBUG)
static void *INITIAL_ESP,
            *INITIAL_EBP,
            *INITIAL_HANDLER,
            *RESTORED_ESP,
            *RESTORED_EBP,
            *RESTORED_HANDLER;
#endif /* HAVE_NO_SEH && TCL_MEM_DEBUG */

/*
 * Prototype for the TraverseWinTree callback function.
 */

typedef int (TraversalProc)(CONST TCHAR *srcPtr, CONST TCHAR *dstPtr, 
	int type, Tcl_DString *errorPtr);

/*
 * Declarations for local procedures defined in this file:
 */

static void		StatError(Tcl_Interp *interp, Tcl_Obj *fileName);
static int		ConvertFileNameFormat(Tcl_Interp *interp, 
			    int objIndex, Tcl_Obj *fileName, int longShort,
			    Tcl_Obj **attributePtrPtr);
static int		DoCopyFile(CONST TCHAR *srcPtr, CONST TCHAR *dstPtr);
static int		DoCreateDirectory(CONST TCHAR *pathPtr);
static int		DoRemoveJustDirectory(CONST TCHAR *nativeSrc, 
			    int ignoreError, Tcl_DString *errorPtr);
static int		DoRemoveDirectory(Tcl_DString *pathPtr, int recursive, 
			    Tcl_DString *errorPtr);
static int		DoRenameFile(CONST TCHAR *nativeSrc, CONST TCHAR *dstPtr);
static int		TraversalCopy(CONST TCHAR *srcPtr, CONST TCHAR *dstPtr, 
			    int type, Tcl_DString *errorPtr);
static int		TraversalDelete(CONST TCHAR *srcPtr, CONST TCHAR *dstPtr, 
			    int type, Tcl_DString *errorPtr);
static int		TraverseWinTree(TraversalProc *traverseProc,
			    Tcl_DString *sourcePtr, Tcl_DString *dstPtr, 
			    Tcl_DString *errorPtr);


/*
 *---------------------------------------------------------------------------
 *
 * TclpObjRenameFile, DoRenameFile --
 *
 *      Changes the name of an existing file or directory, from src to dst.
 *	If src and dst refer to the same file or directory, does nothing
 *	and returns success.  Otherwise if dst already exists, it will be
 *	deleted and replaced by src subject to the following conditions:
 *	    If src is a directory, dst may be an empty directory.
 *	    If src is a file, dst may be a file.
 *	In any other situation where dst already exists, the rename will
 *	fail.  
 *
 * Results:
 *	If the file or directory was successfully renamed, returns TCL_OK.
 *	Otherwise the return value is TCL_ERROR and errno is set to
 *	indicate the error.  Some possible values for errno are:
 *
 *	ENAMETOOLONG: src or dst names are too long.
 *	EACCES:     src or dst parent directory can't be read and/or written.
 *	EEXIST:	    dst is a non-empty directory.
 *	EINVAL:	    src is a root directory or dst is a subdirectory of src.
 *	EISDIR:	    dst is a directory, but src is not.
 *	ENOENT:	    src doesn't exist.  src or dst is "".
 *	ENOTDIR:    src is a directory, but dst is not.  
 *	EXDEV:	    src and dst are on different filesystems.
 *
 *	EACCES:     exists an open file already referring to src or dst.
 *	EACCES:     src or dst specify the current working directory (NT).
 *	EACCES:	    src specifies a char device (nul:, com1:, etc.) 
 *	EEXIST:	    dst specifies a char device (nul:, com1:, etc.) (NT)
 *	EACCES:	    dst specifies a char device (nul:, com1:, etc.) (95)
 *	
 * Side effects:
 *	The implementation supports cross-filesystem renames of files,
 *	but the caller should be prepared to emulate cross-filesystem
 *	renames of directories if errno is EXDEV.
 *
 *---------------------------------------------------------------------------
 */

int 
TclpObjRenameFile(srcPathPtr, destPathPtr)
    Tcl_Obj *srcPathPtr;
    Tcl_Obj *destPathPtr;
{
    return DoRenameFile(Tcl_FSGetNativePath(srcPathPtr), 
			Tcl_FSGetNativePath(destPathPtr));
}

static int
DoRenameFile(
    CONST TCHAR *nativeSrc,	/* Pathname of file or dir to be renamed
				 * (native). */ 
    CONST TCHAR *nativeDst)	/* New pathname for file or directory
				 * (native). */
{    
    DWORD srcAttr, dstAttr;
    int retval = -1;

    /*
     * The MoveFile API acts differently under Win95/98 and NT
     * WRT NULL and "". Avoid passing these values.
     */

    if (nativeSrc == NULL || nativeSrc[0] == '\0' ||
        nativeDst == NULL || nativeDst[0] == '\0') {
	Tcl_SetErrno(ENOENT);
	return TCL_ERROR;
    }

    /*
     * The MoveFile API would throw an exception under NT
     * if one of the arguments is a char block device.
     */

#ifdef HAVE_NO_SEH
# ifdef TCL_MEM_DEBUG
    __asm__ __volatile__ (
            "movl %%esp,  %0" "\n\t"
            "movl %%ebp,  %1" "\n\t"
            "movl %%fs:0, %2" "\n\t"
            : "=m"(INITIAL_ESP),
              "=m"(INITIAL_EBP),
              "=r"(INITIAL_HANDLER) );
# endif /* TCL_MEM_DEBUG */

    __asm__ __volatile__ (
            "pushl %ebp" "\n\t"
            "pushl $__except_dorenamefile_handler" "\n\t"
            "pushl %fs:0" "\n\t"
            "movl  %esp, %fs:0");
#else
    __try {
#endif /* HAVE_NO_SEH */
	if ((*tclWinProcs->moveFileProc)(nativeSrc, nativeDst) != FALSE) {
	    retval = TCL_OK;
	}
#ifdef HAVE_NO_SEH
    __asm__ __volatile__ (
            "jmp  dorenamefile_pop" "\n"
        "dorenamefile_reentry:" "\n\t"
            "movl %%fs:0, %%eax" "\n\t"
            "movl 0x8(%%eax), %%esp" "\n\t"
            "movl 0x8(%%esp), %%ebp" "\n"
        "dorenamefile_pop:" "\n\t"
            "movl (%%esp), %%eax" "\n\t"
            "movl %%eax, %%fs:0" "\n\t"
            "add  $12, %%esp" "\n\t"
            :
            :
            : "%eax");

# ifdef TCL_MEM_DEBUG
    __asm__ __volatile__ (
            "movl  %%esp,  %0" "\n\t"
            "movl  %%ebp,  %1" "\n\t"
            "movl  %%fs:0, %2" "\n\t"
            : "=m"(RESTORED_ESP),
              "=m"(RESTORED_EBP),
              "=r"(RESTORED_HANDLER) );

    if (INITIAL_ESP != RESTORED_ESP)
        panic("ESP restored incorrectly");
    if (INITIAL_EBP != RESTORED_EBP)
        panic("EBP restored incorrectly");
    if (INITIAL_HANDLER != RESTORED_HANDLER)
        panic("HANDLER restored incorrectly");
# endif /* TCL_MEM_DEBUG */
#else
    } __except (EXCEPTION_EXECUTE_HANDLER) {}
#endif /* HAVE_NO_SEH */

    /*
     * Avoid using control flow statements in the SEH guarded block!
     */
    if (retval != -1)
        return retval;

    TclWinConvertError(GetLastError());

    srcAttr = (*tclWinProcs->getFileAttributesProc)(nativeSrc);
    dstAttr = (*tclWinProcs->getFileAttributesProc)(nativeDst);
    if (srcAttr == 0xffffffff) {
	if ((*tclWinProcs->getFullPathNameProc)(nativeSrc, 0, NULL, NULL) >= MAX_PATH) {
	    errno = ENAMETOOLONG;
	    return TCL_ERROR;
	}
	srcAttr = 0;
    }
    if (dstAttr == 0xffffffff) {
	if ((*tclWinProcs->getFullPathNameProc)(nativeDst, 0, NULL, NULL) >= MAX_PATH) {
	    errno = ENAMETOOLONG;
	    return TCL_ERROR;
	}
	dstAttr = 0;
    }

    if (errno == EBADF) {
	errno = EACCES;
	return TCL_ERROR;
    }
    if (errno == EACCES) {
	decode:
	if (srcAttr & FILE_ATTRIBUTE_DIRECTORY) {
	    TCHAR *nativeSrcRest, *nativeDstRest;
	    CONST char **srcArgv, **dstArgv;
	    int size, srcArgc, dstArgc;
	    WCHAR nativeSrcPath[MAX_PATH];
	    WCHAR nativeDstPath[MAX_PATH];
	    Tcl_DString srcString, dstString;
	    CONST char *src, *dst;

	    size = (*tclWinProcs->getFullPathNameProc)(nativeSrc, MAX_PATH, 
		    nativeSrcPath, &nativeSrcRest);
	    if ((size == 0) || (size > MAX_PATH)) {
		return TCL_ERROR;
	    }
	    size = (*tclWinProcs->getFullPathNameProc)(nativeDst, MAX_PATH, 
		    nativeDstPath, &nativeDstRest);
	    if ((size == 0) || (size > MAX_PATH)) {
		return TCL_ERROR;
	    }
	    (*tclWinProcs->charLowerProc)((TCHAR *) nativeSrcPath);
	    (*tclWinProcs->charLowerProc)((TCHAR *) nativeDstPath);

	    src = Tcl_WinTCharToUtf((TCHAR *) nativeSrcPath, -1, &srcString);
	    dst = Tcl_WinTCharToUtf((TCHAR *) nativeDstPath, -1, &dstString);
	    if (strncmp(src, dst, (size_t) Tcl_DStringLength(&srcString)) == 0) {
		/*
		 * Trying to move a directory into itself.
		 */

		errno = EINVAL;
		Tcl_DStringFree(&srcString);
		Tcl_DStringFree(&dstString);
		return TCL_ERROR;
	    }
	    Tcl_SplitPath(src, &srcArgc, &srcArgv);
	    Tcl_SplitPath(dst, &dstArgc, &dstArgv);
	    Tcl_DStringFree(&srcString);
	    Tcl_DStringFree(&dstString);

	    if (srcArgc == 1) {
		/*
		 * They are trying to move a root directory.  Whether
		 * or not it is across filesystems, this cannot be
		 * done.
		 */

		Tcl_SetErrno(EINVAL);
	    } else if ((srcArgc > 0) && (dstArgc > 0) &&
		    (strcmp(srcArgv[0], dstArgv[0]) != 0)) {
		/*
		 * If src is a directory and dst filesystem != src
		 * filesystem, errno should be EXDEV.  It is very
		 * important to get this behavior, so that the caller
		 * can respond to a cross filesystem rename by
		 * simulating it with copy and delete.  The MoveFile
		 * system call already handles the case of moving a
		 * file between filesystems.
		 */

		Tcl_SetErrno(EXDEV);
	    }

	    ckfree((char *) srcArgv);
	    ckfree((char *) dstArgv);
	}

	/*
	 * Other types of access failure is that dst is a read-only
	 * filesystem, that an open file referred to src or dest, or that
	 * src or dest specified the current working directory on the
	 * current filesystem.  EACCES is returned for those cases.
	 */

    } else if (Tcl_GetErrno() == EEXIST) {
	/*
	 * Reports EEXIST any time the target already exists.  If it makes
	 * sense, remove the old file and try renaming again.
	 */

	if (srcAttr & FILE_ATTRIBUTE_DIRECTORY) {
	    if (dstAttr & FILE_ATTRIBUTE_DIRECTORY) {
		/*
		 * Overwrite empty dst directory with src directory.  The
		 * following call will remove an empty directory.  If it
		 * fails, it's because it wasn't empty.
		 */

		if (DoRemoveJustDirectory(nativeDst, 0, NULL) == TCL_OK) {
		    /*
		     * Now that that empty directory is gone, we can try
		     * renaming again.  If that fails, we'll put this empty
		     * directory back, for completeness.
		     */

		    if ((*tclWinProcs->moveFileProc)(nativeSrc, nativeDst) != FALSE) {
			return TCL_OK;
		    }

		    /*
		     * Some new error has occurred.  Don't know what it
		     * could be, but report this one.
		     */

		    TclWinConvertError(GetLastError());
		    (*tclWinProcs->createDirectoryProc)(nativeDst, NULL);
		    (*tclWinProcs->setFileAttributesProc)(nativeDst, dstAttr);
		    if (Tcl_GetErrno() == EACCES) {
			/*
			 * Decode the EACCES to a more meaningful error.
			 */

			goto decode;
		    }
		}
	    } else {	/* (dstAttr & FILE_ATTRIBUTE_DIRECTORY) == 0 */
		Tcl_SetErrno(ENOTDIR);
	    }
	} else {    /* (srcAttr & FILE_ATTRIBUTE_DIRECTORY) == 0 */
	    if (dstAttr & FILE_ATTRIBUTE_DIRECTORY) {
		Tcl_SetErrno(EISDIR);
	    } else {
		/*
		 * Overwrite existing file by:
		 * 
		 * 1. Rename existing file to temp name.
		 * 2. Rename old file to new name.
		 * 3. If success, delete temp file.  If failure,
		 *    put temp file back to old name.
		 */

		TCHAR *nativeRest, *nativeTmp, *nativePrefix;
		int result, size;
		WCHAR tempBuf[MAX_PATH];
		
		size = (*tclWinProcs->getFullPathNameProc)(nativeDst, MAX_PATH, 
			tempBuf, &nativeRest);
		if ((size == 0) || (size > MAX_PATH) || (nativeRest == NULL)) {
		    return TCL_ERROR;
		}
		nativeTmp = (TCHAR *) tempBuf;
		((char *) nativeRest)[0] = '\0';
		((char *) nativeRest)[1] = '\0';    /* In case it's Unicode. */

		result = TCL_ERROR;
		nativePrefix = (tclWinProcs->useWide) 
			? (TCHAR *) L"tclr" : (TCHAR *) "tclr";
		if ((*tclWinProcs->getTempFileNameProc)(nativeTmp, 
			nativePrefix, 0, tempBuf) != 0) {
		    /*
		     * Strictly speaking, need the following DeleteFile and
		     * MoveFile to be joined as an atomic operation so no
		     * other app comes along in the meantime and creates the
		     * same temp file.
		     */
		     
		    nativeTmp = (TCHAR *) tempBuf;
		    (*tclWinProcs->deleteFileProc)(nativeTmp);
		    if ((*tclWinProcs->moveFileProc)(nativeDst, nativeTmp) != FALSE) {
			if ((*tclWinProcs->moveFileProc)(nativeSrc, nativeDst) != FALSE) {
			    (*tclWinProcs->setFileAttributesProc)(nativeTmp, 
				    FILE_ATTRIBUTE_NORMAL);
			    (*tclWinProcs->deleteFileProc)(nativeTmp);
			    return TCL_OK;
			} else {
			    (*tclWinProcs->deleteFileProc)(nativeDst);
			    (*tclWinProcs->moveFileProc)(nativeTmp, nativeDst);
			}
		    } 

		    /*
		     * Can't backup dst file or move src file.  Return that
		     * error.  Could happen if an open file refers to dst.
		     */

		    TclWinConvertError(GetLastError());
		    if (Tcl_GetErrno() == EACCES) {
			/*
			 * Decode the EACCES to a more meaningful error.
			 */

			goto decode;
		    }
		}
		return result;
	    }
	}
    }
    return TCL_ERROR;
}
#ifdef HAVE_NO_SEH
static
__attribute__ ((cdecl,used))
EXCEPTION_DISPOSITION
_except_dorenamefile_handler(
    struct _EXCEPTION_RECORD *ExceptionRecord,
    void *EstablisherFrame,
    struct _CONTEXT *ContextRecord,
    void *DispatcherContext)
{
    __asm__ __volatile__ (
            "jmp dorenamefile_reentry");
    /* Nuke compiler warning about unused static function */
    _except_dorenamefile_handler(NULL, NULL, NULL, NULL);
    return 0; /* Function does not return */
}
#endif /* HAVE_NO_SEH */

/*
 *---------------------------------------------------------------------------
 *
 * TclpObjCopyFile, DoCopyFile --
 *
 *      Copy a single file (not a directory).  If dst already exists and
 *	is not a directory, it is removed.
 *
 * Results:
 *	If the file was successfully copied, returns TCL_OK.  Otherwise
 *	the return value is TCL_ERROR and errno is set to indicate the
 *	error.  Some possible values for errno are:
 *
 *	EACCES:     src or dst parent directory can't be read and/or written.
 *	EISDIR:	    src or dst is a directory.
 *	ENOENT:	    src doesn't exist.  src or dst is "".
 *
 *	EACCES:     exists an open file already referring to dst (95).
 *	EACCES:	    src specifies a char device (nul:, com1:, etc.) (NT)
 *	ENOENT:	    src specifies a char device (nul:, com1:, etc.) (95)
 *
 * Side effects:
 *	It is not an error to copy to a char device.
 *
 *---------------------------------------------------------------------------
 */

int 
TclpObjCopyFile(srcPathPtr, destPathPtr)
    Tcl_Obj *srcPathPtr;
    Tcl_Obj *destPathPtr;
{
    return DoCopyFile(Tcl_FSGetNativePath(srcPathPtr),
		      Tcl_FSGetNativePath(destPathPtr));
}

static int
DoCopyFile(
   CONST TCHAR *nativeSrc,	/* Pathname of file to be copied (native). */
   CONST TCHAR *nativeDst)	/* Pathname of file to copy to (native). */
{
    int retval = -1;

    /*
     * The CopyFile API acts differently under Win95/98 and NT
     * WRT NULL and "". Avoid passing these values.
     */

    if (nativeSrc == NULL || nativeSrc[0] == '\0' ||
        nativeDst == NULL || nativeDst[0] == '\0') {
	Tcl_SetErrno(ENOENT);
	return TCL_ERROR;
    }
    
    /*
     * The CopyFile API would throw an exception under NT if one
     * of the arguments is a char block device.
     */

#ifdef HAVE_NO_SEH
# ifdef TCL_MEM_DEBUG
    __asm__ __volatile__ (
            "movl %%esp,  %0" "\n\t"
            "movl %%ebp,  %1" "\n\t"
            "movl %%fs:0, %2" "\n\t"
            : "=m"(INITIAL_ESP),
              "=m"(INITIAL_EBP),
              "=r"(INITIAL_HANDLER) );
# endif /* TCL_MEM_DEBUG */

    __asm__ __volatile__ (
            "pushl %ebp" "\n\t"
            "pushl $__except_docopyfile_handler" "\n\t"
            "pushl %fs:0" "\n\t"
            "movl  %esp, %fs:0");
#else
    __try {
#endif /* HAVE_NO_SEH */
	if ((*tclWinProcs->copyFileProc)(nativeSrc, nativeDst, 0) != FALSE) {
	    retval = TCL_OK;
	}
#ifdef HAVE_NO_SEH
    __asm__ __volatile__ (
            "jmp  docopyfile_pop" "\n"
        "docopyfile_reentry:" "\n\t"
            "movl %%fs:0, %%eax" "\n\t"
            "movl 0x8(%%eax), %%esp" "\n\t"
            "movl 0x8(%%esp), %%ebp" "\n"
        "docopyfile_pop:" "\n\t"
            "movl (%%esp), %%eax" "\n\t"
            "movl %%eax, %%fs:0" "\n\t"
            "add  $12, %%esp" "\n\t"
            :
            :
            : "%eax");

# ifdef TCL_MEM_DEBUG
    __asm__ __volatile__ (
            "movl  %%esp,  %0" "\n\t"
            "movl  %%ebp,  %1" "\n\t"
            "movl  %%fs:0, %2" "\n\t"
            : "=m"(RESTORED_ESP),
              "=m"(RESTORED_EBP),
              "=r"(RESTORED_HANDLER) );

    if (INITIAL_ESP != RESTORED_ESP)
        panic("ESP restored incorrectly");
    if (INITIAL_EBP != RESTORED_EBP)
        panic("EBP restored incorrectly");
    if (INITIAL_HANDLER != RESTORED_HANDLER)
        panic("HANDLER restored incorrectly");
# endif /* TCL_MEM_DEBUG */
#else
    } __except (EXCEPTION_EXECUTE_HANDLER) {}
#endif /* HAVE_NO_SEH */

    /*
     * Avoid using control flow statements in the SEH guarded block!
     */
    if (retval != -1)
        return retval;

    TclWinConvertError(GetLastError());
    if (Tcl_GetErrno() == EBADF) {
	Tcl_SetErrno(EACCES);
	return TCL_ERROR;
    }
    if (Tcl_GetErrno() == EACCES) {
	DWORD srcAttr, dstAttr;

	srcAttr = (*tclWinProcs->getFileAttributesProc)(nativeSrc);
	dstAttr = (*tclWinProcs->getFileAttributesProc)(nativeDst);
	if (srcAttr != 0xffffffff) {
	    if (dstAttr == 0xffffffff) {
		dstAttr = 0;
	    }
	    if ((srcAttr & FILE_ATTRIBUTE_DIRECTORY) ||
		    (dstAttr & FILE_ATTRIBUTE_DIRECTORY)) {
		if (srcAttr & FILE_ATTRIBUTE_REPARSE_POINT) {
		    /* Source is a symbolic link -- copy it */
		    if (TclWinSymLinkCopyDirectory(nativeSrc, nativeDst) == 0) {
		        return TCL_OK;
		    }
		}
		Tcl_SetErrno(EISDIR);
	    }
	    if (dstAttr & FILE_ATTRIBUTE_READONLY) {
		(*tclWinProcs->setFileAttributesProc)(nativeDst, 
			dstAttr & ~((DWORD)FILE_ATTRIBUTE_READONLY));
		if ((*tclWinProcs->copyFileProc)(nativeSrc, nativeDst, 0) != FALSE) {
		    return TCL_OK;
		}
		/*
		 * Still can't copy onto dst.  Return that error, and
		 * restore attributes of dst.
		 */

		TclWinConvertError(GetLastError());
		(*tclWinProcs->setFileAttributesProc)(nativeDst, dstAttr);
	    }
	}
    }
    return TCL_ERROR;
}
#ifdef HAVE_NO_SEH
static
__attribute__ ((cdecl,used))
EXCEPTION_DISPOSITION
_except_docopyfile_handler(
    struct _EXCEPTION_RECORD *ExceptionRecord,
    void *EstablisherFrame,
    struct _CONTEXT *ContextRecord,
    void *DispatcherContext)
{
    __asm__ __volatile__ (
            "jmp docopyfile_reentry");
    _except_docopyfile_handler(NULL,NULL,NULL,NULL);
    return 0; /* Function does not return */
}
#endif /* HAVE_NO_SEH */

/*
 *---------------------------------------------------------------------------
 *
 * TclpObjDeleteFile, TclpDeleteFile --
 *
 *      Removes a single file (not a directory).
 *
 * Results:
 *	If the file was successfully deleted, returns TCL_OK.  Otherwise
 *	the return value is TCL_ERROR and errno is set to indicate the
 *	error.  Some possible values for errno are:
 *
 *	EACCES:     a parent directory can't be read and/or written.
 *	EISDIR:	    path is a directory.
 *	ENOENT:	    path doesn't exist or is "".
 *
 *	EACCES:     exists an open file already referring to path.
 *	EACCES:	    path is a char device (nul:, com1:, etc.)
 *
 * Side effects:
 *      The file is deleted, even if it is read-only.
 *
 *---------------------------------------------------------------------------
 */

int 
TclpObjDeleteFile(pathPtr)
    Tcl_Obj *pathPtr;
{
    return TclpDeleteFile(Tcl_FSGetNativePath(pathPtr));
}

int
TclpDeleteFile(
    CONST TCHAR *nativePath)	/* Pathname of file to be removed (native). */
{
    DWORD attr;

    /*
     * The DeleteFile API acts differently under Win95/98 and NT
     * WRT NULL and "". Avoid passing these values.
     */

    if (nativePath == NULL || nativePath[0] == '\0') {
	Tcl_SetErrno(ENOENT);
	return TCL_ERROR;
    }

    if ((*tclWinProcs->deleteFileProc)(nativePath) != FALSE) {
	return TCL_OK;
    }
    TclWinConvertError(GetLastError());

    if (Tcl_GetErrno() == EACCES) {
        attr = (*tclWinProcs->getFileAttributesProc)(nativePath);
	if (attr != 0xffffffff) {
	    if (attr & FILE_ATTRIBUTE_DIRECTORY) {
		if (attr & FILE_ATTRIBUTE_REPARSE_POINT) {
		    /* It is a symbolic link -- remove it */
		    if (TclWinSymLinkDelete(nativePath, 0) == 0) {
		        return TCL_OK;
		    }
		}
		
		/* 
		 * If we fall through here, it is a directory.
		 * 
		 * Windows NT reports removing a directory as EACCES instead
		 * of EISDIR.
		 */

		Tcl_SetErrno(EISDIR);
	    } else if (attr & FILE_ATTRIBUTE_READONLY) {
		int res = (*tclWinProcs->setFileAttributesProc)(nativePath, 
			attr & ~((DWORD)FILE_ATTRIBUTE_READONLY));
		if ((res != 0) && ((*tclWinProcs->deleteFileProc)(nativePath)
			!= FALSE)) {
		    return TCL_OK;
		}
		TclWinConvertError(GetLastError());
		if (res != 0) {
		    (*tclWinProcs->setFileAttributesProc)(nativePath, attr);
		}
	    }
	}
    } else if (Tcl_GetErrno() == ENOENT) {
        attr = (*tclWinProcs->getFileAttributesProc)(nativePath);
	if (attr != 0xffffffff) {
	    if (attr & FILE_ATTRIBUTE_DIRECTORY) {
	    	/*
		 * Windows 95 reports removing a directory as ENOENT instead 
		 * of EISDIR. 
		 */

		Tcl_SetErrno(EISDIR);
	    }
	}
    } else if (Tcl_GetErrno() == EINVAL) {
	/*
	 * Windows NT reports removing a char device as EINVAL instead of
	 * EACCES.
	 */

	Tcl_SetErrno(EACCES);
    }

    return TCL_ERROR;
}

/*
 *---------------------------------------------------------------------------
 *
 * TclpObjCreateDirectory --
 *
 *      Creates the specified directory.  All parent directories of the
 *	specified directory must already exist.  The directory is
 *	automatically created with permissions so that user can access
 *	the new directory and create new files or subdirectories in it.
 *
 * Results:
 *	If the directory was successfully created, returns TCL_OK.
 *	Otherwise the return value is TCL_ERROR and errno is set to
 *	indicate the error.  Some possible values for errno are:
 *
 *	EACCES:     a parent directory can't be read and/or written.
 *	EEXIST:	    path already exists.
 *	ENOENT:	    a parent directory doesn't exist.
 *
 * Side effects:
 *      A directory is created.
 *
 *---------------------------------------------------------------------------
 */

int 
TclpObjCreateDirectory(pathPtr)
    Tcl_Obj *pathPtr;
{
    return DoCreateDirectory(Tcl_FSGetNativePath(pathPtr));
}

static int
DoCreateDirectory(
    CONST TCHAR *nativePath)	/* Pathname of directory to create (native). */
{
    DWORD error;
    if ((*tclWinProcs->createDirectoryProc)(nativePath, NULL) == 0) {
	error = GetLastError();
	TclWinConvertError(error);
	return TCL_ERROR;
    }   
    return TCL_OK;
}

/*
 *---------------------------------------------------------------------------
 *
 * TclpObjCopyDirectory --
 *
 *      Recursively copies a directory.  The target directory dst must
 *	not already exist.  Note that this function does not merge two
 *	directory hierarchies, even if the target directory is an an
 *	empty directory.
 *
 * Results:
 *	If the directory was successfully copied, returns TCL_OK.
 *	Otherwise the return value is TCL_ERROR, errno is set to indicate
 *	the error, and the pathname of the file that caused the error
 *	is stored in errorPtr.  See TclpCreateDirectory and TclpCopyFile
 *	for a description of possible values for errno.
 *
 * Side effects:
 *      An exact copy of the directory hierarchy src will be created
 *	with the name dst.  If an error occurs, the error will
 *      be returned immediately, and remaining files will not be
 *	processed.
 *
 *---------------------------------------------------------------------------
 */

int 
TclpObjCopyDirectory(srcPathPtr, destPathPtr, errorPtr)
    Tcl_Obj *srcPathPtr;
    Tcl_Obj *destPathPtr;
    Tcl_Obj **errorPtr;
{
    Tcl_DString ds;
    Tcl_DString srcString, dstString;
    int ret;

    Tcl_WinUtfToTChar(Tcl_FSGetTranslatedStringPath(NULL,srcPathPtr), 
		      -1, &srcString);
    Tcl_WinUtfToTChar(Tcl_FSGetTranslatedStringPath(NULL,destPathPtr), 
		      -1, &dstString);

    ret = TraverseWinTree(TraversalCopy, &srcString, &dstString, &ds);

    Tcl_DStringFree(&srcString);
    Tcl_DStringFree(&dstString);

    if (ret != TCL_OK) {
	*errorPtr = Tcl_NewStringObj(Tcl_DStringValue(&ds), -1);
	Tcl_DStringFree(&ds);
	Tcl_IncrRefCount(*errorPtr);
    }
    return ret;
}

/*
 *----------------------------------------------------------------------
 *
 * TclpObjRemoveDirectory, DoRemoveDirectory -- 
 *
 *	Removes directory (and its contents, if the recursive flag is set).
 *
 * Results:
 *	If the directory was successfully removed, returns TCL_OK.
 *	Otherwise the return value is TCL_ERROR, errno is set to indicate
 *	the error, and the pathname of the file that caused the error
 *	is stored in errorPtr.  Some possible values for errno are:
 *
 *	EACCES:     path directory can't be read and/or written.
 *	EEXIST:	    path is a non-empty directory.
 *	EINVAL:	    path is root directory or current directory.
 *	ENOENT:	    path doesn't exist or is "".
 * 	ENOTDIR:    path is not a directory.
 *
 *	EACCES:	    path is a char device (nul:, com1:, etc.) (95)
 *	EINVAL:	    path is a char device (nul:, com1:, etc.) (NT)
 *
 * Side effects:
 *	Directory removed.  If an error occurs, the error will be returned
 *	immediately, and remaining files will not be deleted.
 *
 *----------------------------------------------------------------------
 */

int 
TclpObjRemoveDirectory(pathPtr, recursive, errorPtr)
    Tcl_Obj *pathPtr;
    int recursive;
    Tcl_Obj **errorPtr;
{
    Tcl_DString ds;
    int ret;
    if (recursive) {
	/* 
	 * In the recursive case, the string rep is used to construct a
	 * Tcl_DString which may be used extensively, so we can't
	 * optimize this case easily.
	 */
	Tcl_DString native;
	Tcl_WinUtfToTChar(Tcl_FSGetTranslatedStringPath(NULL, pathPtr), 
			  -1, &native);
	ret = DoRemoveDirectory(&native, recursive, &ds);
	Tcl_DStringFree(&native);
    } else {
	ret = DoRemoveJustDirectory(Tcl_FSGetNativePath(pathPtr), 
				    0, &ds);
    }
    if (ret != TCL_OK) {
	int len = Tcl_DStringLength(&ds);
	if (len > 0) {
	    *errorPtr = Tcl_NewStringObj(Tcl_DStringValue(&ds), -1);
	    Tcl_IncrRefCount(*errorPtr);
	}
	Tcl_DStringFree(&ds);
    }
    return ret;
}

static int
DoRemoveJustDirectory(
    CONST TCHAR *nativePath,	/* Pathname of directory to be removed
				 * (native). */
    int ignoreError,		/* If non-zero, don't initialize the
                  		 * errorPtr under some circumstances
                  		 * on return. */
    Tcl_DString *errorPtr)	/* If non-NULL, uninitialized or free
				 * DString filled with UTF-8 name of file
				 * causing error. */
{
    /*
     * The RemoveDirectory API acts differently under Win95/98 and NT
     * WRT NULL and "". Avoid passing these values.
     */

    if (nativePath == NULL || nativePath[0] == '\0') {
	Tcl_SetErrno(ENOENT);
	goto end;
    }

    if ((*tclWinProcs->removeDirectoryProc)(nativePath) != FALSE) {
	return TCL_OK;
    }
    TclWinConvertError(GetLastError());

    if (Tcl_GetErrno() == EACCES) {
	DWORD attr = (*tclWinProcs->getFileAttributesProc)(nativePath);
	if (attr != 0xffffffff) {
	    if ((attr & FILE_ATTRIBUTE_DIRECTORY) == 0) {
		/* 
		 * Windows 95 reports calling RemoveDirectory on a file as an 
		 * EACCES, not an ENOTDIR.
		 */
		
		Tcl_SetErrno(ENOTDIR);
		goto end;
	    }

	    if (attr & FILE_ATTRIBUTE_REPARSE_POINT) {
		/* It is a symbolic link -- remove it */
		if (TclWinSymLinkDelete(nativePath, 1) != 0) {
		    goto end;
		}
	    }
	    
	    if (attr & FILE_ATTRIBUTE_READONLY) {
		attr &= ~FILE_ATTRIBUTE_READONLY;
		if ((*tclWinProcs->setFileAttributesProc)(nativePath, attr) == FALSE) {
		    goto end;
		}
		if ((*tclWinProcs->removeDirectoryProc)(nativePath) != FALSE) {
		    return TCL_OK;
		}
		TclWinConvertError(GetLastError());
		(*tclWinProcs->setFileAttributesProc)(nativePath, 
			attr | FILE_ATTRIBUTE_READONLY);
	    }

	    /* 
	     * Windows 95 and Win32s report removing a non-empty directory 
	     * as EACCES, not EEXIST.  If the directory is not empty,
	     * change errno so caller knows what's going on.
	     */

	    if (TclWinGetPlatformId() != VER_PLATFORM_WIN32_NT) {
		CONST char *path, *find;
		HANDLE handle;
		WIN32_FIND_DATAA data;
		Tcl_DString buffer;
		int len;

		path = (CONST char *) nativePath;

		Tcl_DStringInit(&buffer);
		len = strlen(path);
		find = Tcl_DStringAppend(&buffer, path, len);
		if ((len > 0) && (find[len - 1] != '\\')) {
		    Tcl_DStringAppend(&buffer, "\\", 1);
		}
		find = Tcl_DStringAppend(&buffer, "*.*", 3);
		handle = FindFirstFileA(find, &data);
		if (handle != INVALID_HANDLE_VALUE) {
		    while (1) {
			if ((strcmp(data.cFileName, ".") != 0)
				&& (strcmp(data.cFileName, "..") != 0)) {
			    /*
			     * Found something in this directory.
			     */

			    Tcl_SetErrno(EEXIST);
			    break;
			}
			if (FindNextFileA(handle, &data) == FALSE) {
			    break;
			}
		    }
		    FindClose(handle);
		}
		Tcl_DStringFree(&buffer);
	    }
	}
    }
    if (Tcl_GetErrno() == ENOTEMPTY) {
	/* 
	 * The caller depends on EEXIST to signify that the directory is
	 * not empty, not ENOTEMPTY. 
	 */

	Tcl_SetErrno(EEXIST);
    }
    if ((ignoreError != 0) && (Tcl_GetErrno() == EEXIST)) {
	/* 
	 * If we're being recursive, this error may actually
	 * be ok, so we don't want to initialise the errorPtr
	 * yet.
	 */
	return TCL_ERROR;
    }

    end:
    if (errorPtr != NULL) {
	Tcl_WinTCharToUtf(nativePath, -1, errorPtr);
    }
    return TCL_ERROR;

}

static int
DoRemoveDirectory(
    Tcl_DString *pathPtr,	/* Pathname of directory to be removed
				 * (native). */
    int recursive,		/* If non-zero, removes directories that
				 * are nonempty.  Otherwise, will only remove
				 * empty directories. */
    Tcl_DString *errorPtr)	/* If non-NULL, uninitialized or free
				 * DString filled with UTF-8 name of file
				 * causing error. */
{
    int res = DoRemoveJustDirectory(Tcl_DStringValue(pathPtr), recursive, 
				    errorPtr);
    
    if ((res == TCL_ERROR) && (recursive != 0) && (Tcl_GetErrno() == EEXIST)) {
	/*
	 * The directory is nonempty, but the recursive flag has been
	 * specified, so we recursively remove all the files in the directory.
	 */
	return TraverseWinTree(TraversalDelete, pathPtr, NULL, errorPtr);
    } else {
	return res;
    }
}

/*
 *---------------------------------------------------------------------------
 *
 * TraverseWinTree --
 *
 *      Traverse directory tree specified by sourcePtr, calling the function 
 *	traverseProc for each file and directory encountered.  If destPtr 
 *	is non-null, each of name in the sourcePtr directory is appended to 
 *	the directory specified by destPtr and passed as the second argument 
 *	to traverseProc() .
 *
 * Results:
 *      Standard Tcl result.
 *
 * Side effects:
 *      None caused by TraverseWinTree, however the user specified 
 *	traverseProc() may change state.  If an error occurs, the error will
 *      be returned immediately, and remaining files will not be processed.
 *
 *---------------------------------------------------------------------------
 */

static int 
TraverseWinTree(
    TraversalProc *traverseProc,/* Function to call for every file and
				 * directory in source hierarchy. */
    Tcl_DString *sourcePtr,	/* Pathname of source directory to be
				 * traversed (native). */
    Tcl_DString *targetPtr,	/* Pathname of directory to traverse in
				 * parallel with source directory (native),
				 * may be NULL. */
    Tcl_DString *errorPtr)	/* If non-NULL, uninitialized or free
				 * DString filled with UTF-8 name of file
				 * causing error. */
{
    DWORD sourceAttr;
    TCHAR *nativeSource, *nativeTarget, *nativeErrfile;
    int result, found, sourceLen, targetLen, oldSourceLen, oldTargetLen;
    HANDLE handle;
    WIN32_FIND_DATAT data;

    nativeErrfile = NULL;
    result = TCL_OK;
    oldTargetLen = 0;		/* lint. */

    nativeSource = (TCHAR *) Tcl_DStringValue(sourcePtr);
    nativeTarget = (TCHAR *) (targetPtr == NULL ? NULL : Tcl_DStringValue(targetPtr));
    
    oldSourceLen = Tcl_DStringLength(sourcePtr);
    sourceAttr = (*tclWinProcs->getFileAttributesProc)(nativeSource);
    if (sourceAttr == 0xffffffff) {
	nativeErrfile = nativeSource;
	goto end;
    }
    if ((sourceAttr & FILE_ATTRIBUTE_DIRECTORY) == 0) {
	/*
	 * Process the regular file
	 */

	return (*traverseProc)(nativeSource, nativeTarget, DOTREE_F, errorPtr);
    }

    if (tclWinProcs->useWide) {
	Tcl_DStringAppend(sourcePtr, (char *) L"\\*.*", 4 * sizeof(WCHAR) + 1);
	Tcl_DStringSetLength(sourcePtr, Tcl_DStringLength(sourcePtr) - 1);
    } else {
	Tcl_DStringAppend(sourcePtr, "\\*.*", 4);
    }
    nativeSource = (TCHAR *) Tcl_DStringValue(sourcePtr);
    handle = (*tclWinProcs->findFirstFileProc)(nativeSource, &data);
    if (handle == INVALID_HANDLE_VALUE) {      
	/* 
	 * Can't read directory
	 */

	TclWinConvertError(GetLastError());
	nativeErrfile = nativeSource;
	goto end;
    }

    nativeSource[oldSourceLen + 1] = '\0';
    Tcl_DStringSetLength(sourcePtr, oldSourceLen);
    result = (*traverseProc)(nativeSource, nativeTarget, DOTREE_PRED, errorPtr);
    if (result != TCL_OK) {
	FindClose(handle);
	return result;
    }

    sourceLen = oldSourceLen;

    if (tclWinProcs->useWide) {
	sourceLen += sizeof(WCHAR);
	Tcl_DStringAppend(sourcePtr, (char *) L"\\", sizeof(WCHAR) + 1);
	Tcl_DStringSetLength(sourcePtr, sourceLen);
    } else {
	sourceLen += 1;
	Tcl_DStringAppend(sourcePtr, "\\", 1);
    }
    if (targetPtr != NULL) {
	oldTargetLen = Tcl_DStringLength(targetPtr);

	targetLen = oldTargetLen;
	if (tclWinProcs->useWide) {
	    targetLen += sizeof(WCHAR);
	    Tcl_DStringAppend(targetPtr, (char *) L"\\", sizeof(WCHAR) + 1);
	    Tcl_DStringSetLength(targetPtr, targetLen);
	} else {
	    targetLen += 1;
	    Tcl_DStringAppend(targetPtr, "\\", 1);
	}
    }

    found = 1;
    for ( ; found; found = (*tclWinProcs->findNextFileProc)(handle, &data)) {
	TCHAR *nativeName;
	int len;

	if (tclWinProcs->useWide) {
	    WCHAR *wp;

	    wp = data.w.cFileName;
	    if (*wp == '.') {
		wp++;
		if (*wp == '.') {
		    wp++;
		}
		if (*wp == '\0') {
		    continue;
		}
	    }
	    nativeName = (TCHAR *) data.w.cFileName;
	    len = Tcl_UniCharLen(data.w.cFileName) * sizeof(WCHAR);
	} else {
	    if ((strcmp(data.a.cFileName, ".") == 0) 
		    || (strcmp(data.a.cFileName, "..") == 0)) {
		continue;
	    }
	    nativeName = (TCHAR *) data.a.cFileName;
	    len = strlen(data.a.cFileName);
	}

	/* 
	 * Append name after slash, and recurse on the file. 
	 */

	Tcl_DStringAppend(sourcePtr, (char *) nativeName, len + 1);
	Tcl_DStringSetLength(sourcePtr, Tcl_DStringLength(sourcePtr) - 1);
	if (targetPtr != NULL) {
	    Tcl_DStringAppend(targetPtr, (char *) nativeName, len + 1);
	    Tcl_DStringSetLength(targetPtr, Tcl_DStringLength(targetPtr) - 1);
	}
	result = TraverseWinTree(traverseProc, sourcePtr, targetPtr, 
		errorPtr);
	if (result != TCL_OK) {
	    break;
	}

	/*
	 * Remove name after slash.
	 */

	Tcl_DStringSetLength(sourcePtr, sourceLen);
	if (targetPtr != NULL) {
	    Tcl_DStringSetLength(targetPtr, targetLen);
	}
    }
    FindClose(handle);

    /*
     * Strip off the trailing slash we added
     */

    Tcl_DStringSetLength(sourcePtr, oldSourceLen + 1);
    Tcl_DStringSetLength(sourcePtr, oldSourceLen);
    if (targetPtr != NULL) {
	Tcl_DStringSetLength(targetPtr, oldTargetLen + 1);
	Tcl_DStringSetLength(targetPtr, oldTargetLen);
    }
    if (result == TCL_OK) {
	/*
	 * Call traverseProc() on a directory after visiting all the
	 * files in that directory.
	 */

	result = (*traverseProc)(Tcl_DStringValue(sourcePtr), 
			(targetPtr == NULL ? NULL : Tcl_DStringValue(targetPtr)), 
			DOTREE_POSTD, errorPtr);
    }
    end:
    if (nativeErrfile != NULL) {
	TclWinConvertError(GetLastError());
	if (errorPtr != NULL) {
	    Tcl_WinTCharToUtf(nativeErrfile, -1, errorPtr);
	}
	result = TCL_ERROR;
    }
	    
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * TraversalCopy
 *
 *      Called from TraverseUnixTree in order to execute a recursive
 *      copy of a directory.
 *
 * Results:
 *      Standard Tcl result.
 *
 * Side effects:
 *      Depending on the value of type, src may be copied to dst.
 *      
 *----------------------------------------------------------------------
 */

static int 
TraversalCopy(
    CONST TCHAR *nativeSrc,	/* Source pathname to copy. */
    CONST TCHAR *nativeDst,	/* Destination pathname of copy. */
    int type,			/* Reason for call - see TraverseWinTree() */
    Tcl_DString *errorPtr)	/* If non-NULL, initialized DString filled
				 * with UTF-8 name of file causing error. */
{
    switch (type) {
	case DOTREE_F: {
	    if (DoCopyFile(nativeSrc, nativeDst) == TCL_OK) {
		return TCL_OK;
	    }
	    break;
	}
	case DOTREE_PRED: {
	    if (DoCreateDirectory(nativeDst) == TCL_OK) {
		DWORD attr = (*tclWinProcs->getFileAttributesProc)(nativeSrc);
		if ((*tclWinProcs->setFileAttributesProc)(nativeDst, attr) != FALSE) {
		    return TCL_OK;
		}
		TclWinConvertError(GetLastError());
	    }
	    break;
	}
        case DOTREE_POSTD: {
	    return TCL_OK;
	}
    }

    /*
     * There shouldn't be a problem with src, because we already
     * checked it to get here.
     */

    if (errorPtr != NULL) {
	Tcl_WinTCharToUtf(nativeDst, -1, errorPtr);
    }
    return TCL_ERROR;
}

/*
 *----------------------------------------------------------------------
 *
 * TraversalDelete --
 *
 *      Called by procedure TraverseWinTree for every file and
 *      directory that it encounters in a directory hierarchy. This
 *      procedure unlinks files, and removes directories after all the
 *      containing files have been processed.
 *
 * Results:
 *      Standard Tcl result.
 *
 * Side effects:
 *      Files or directory specified by src will be deleted. If an
 *      error occurs, the windows error is converted to a Posix error
 *      and errno is set accordingly.
 *
 *----------------------------------------------------------------------
 */

static int
TraversalDelete( 
    CONST TCHAR *nativeSrc,	/* Source pathname to delete. */
    CONST TCHAR *dstPtr,	/* Not used. */
    int type,			/* Reason for call - see TraverseWinTree() */
    Tcl_DString *errorPtr)	/* If non-NULL, initialized DString filled
				 * with UTF-8 name of file causing error. */
{
    switch (type) {
	case DOTREE_F: {
	    if (TclpDeleteFile(nativeSrc) == TCL_OK) {
		return TCL_OK;
	    }
	    break;
	}
	case DOTREE_PRED: {
	    return TCL_OK;
	}
	case DOTREE_POSTD: {
	    if (DoRemoveJustDirectory(nativeSrc, 0, NULL) == TCL_OK) {
		return TCL_OK;
	    }
	    break;
	}
    }

    if (errorPtr != NULL) {
	Tcl_WinTCharToUtf(nativeSrc, -1, errorPtr);
    }
    return TCL_ERROR;
}

/*
 *----------------------------------------------------------------------
 *
 * StatError --
 *
 *	Sets the object result with the appropriate error.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      The interp's object result is set with an error message
 *	based on the objIndex, fileName and errno.
 *
 *----------------------------------------------------------------------
 */

static void
StatError(
    Tcl_Interp *interp,		/* The interp that has the error */
    Tcl_Obj *fileName)	        /* The name of the file which caused the 
				 * error. */
{
    TclWinConvertError(GetLastError());
    Tcl_AppendStringsToObj(Tcl_GetObjResult(interp), 
			   "could not read \"", Tcl_GetString(fileName), 
			   "\": ", Tcl_PosixError(interp), 
			   (char *) NULL);
}

/*
 *----------------------------------------------------------------------
 *
 * GetWinFileAttributes --
 *
 *      Returns a Tcl_Obj containing the value of a file attribute.
 *	This routine gets the -hidden, -readonly or -system attribute.
 *
 * Results:
 *      Standard Tcl result and a Tcl_Obj in attributePtrPtr. The object
 *	will have ref count 0. If the return value is not TCL_OK,
 *	attributePtrPtr is not touched.
 *
 * Side effects:
 *      A new object is allocated if the file is valid.
 *
 *----------------------------------------------------------------------
 */

static int
GetWinFileAttributes(
    Tcl_Interp *interp,		/* The interp we are using for errors. */
    int objIndex,		/* The index of the attribute. */
    Tcl_Obj *fileName,	        /* The name of the file. */
    Tcl_Obj **attributePtrPtr)	/* A pointer to return the object with. */
{
    DWORD result;
    CONST TCHAR *nativeName;
    int attr;
    
    nativeName = Tcl_FSGetNativePath(fileName);
    result = (*tclWinProcs->getFileAttributesProc)(nativeName);

    if (result == 0xffffffff) {
	StatError(interp, fileName);
	return TCL_ERROR;
    }

    attr = (int)(result & attributeArray[objIndex]);
    if ((objIndex == WIN_HIDDEN_ATTRIBUTE) && (attr != 0)) {
	/* 
	 * It is hidden.  However there is a bug on some Windows
	 * OSes in which root volumes (drives) formatted as NTFS
	 * are declared hidden when they are not (and cannot be).
	 * 
	 * We test for, and fix that case, here.
	 */
	int len;
	char *str = Tcl_GetStringFromObj(fileName,&len);
	if (len < 4) {
	    if (len == 0) {
		/* 
		 * Not sure if this is possible, but we pass it on
		 * anyway 
		 */
	    } else if (len == 1 && (str[0] == '/' || str[0] == '\\')) {
		/* Path is pointing to the root volume */
		attr = 0;
	    } else if ((str[1] == ':') 
		       && (len == 2 || (str[2] == '/' || str[2] == '\\'))) {
		/* Path is of the form 'x:' or 'x:/' or 'x:\' */
		attr = 0;
	    }
	}
    }
    *attributePtrPtr = Tcl_NewBooleanObj(attr);
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * ConvertFileNameFormat --
 *
 *      Returns a Tcl_Obj containing either the long or short version of the 
 *	file name.
 *
 * Results:
 *      Standard Tcl result and a Tcl_Obj in attributePtrPtr. The object
 *	will have ref count 0. If the return value is not TCL_OK,
 *	attributePtrPtr is not touched.
 *	
 *	Warning: if you pass this function a drive name like 'c:' it
 *	will actually return the current working directory on that
 *	drive.  To avoid this, make sure the drive name ends in a
 *	slash, like this 'c:/'.
 *
 * Side effects:
 *      A new object is allocated if the file is valid.
 *
 *----------------------------------------------------------------------
 */

static int
ConvertFileNameFormat(
    Tcl_Interp *interp,		/* The interp we are using for errors. */
    int objIndex,		/* The index of the attribute. */
    Tcl_Obj *fileName,   	/* The name of the file. */
    int longShort,		/* 0 to short name, 1 to long name. */
    Tcl_Obj **attributePtrPtr)	/* A pointer to return the object with. */
{
    int pathc, i;
    Tcl_Obj *splitPath;
    int result = TCL_OK;

    splitPath = Tcl_FSSplitPath(fileName, &pathc);

    if (splitPath == NULL || pathc == 0) {
	if (interp != NULL) {
	    Tcl_AppendStringsToObj(Tcl_GetObjResult(interp), 
		"could not read \"", Tcl_GetString(fileName),
		"\": no such file or directory", 
		(char *) NULL);
	}
	result = TCL_ERROR;
	goto cleanup;
    }
    
    for (i = 0; i < pathc; i++) {
	Tcl_Obj *elt;
	char *pathv;
	int pathLen;
	Tcl_ListObjIndex(NULL, splitPath, i, &elt);
	
	pathv = Tcl_GetStringFromObj(elt, &pathLen);
	if ((pathv[0] == '/')
		|| ((pathLen == 3) && (pathv[1] == ':'))
		|| (strcmp(pathv, ".") == 0)
		|| (strcmp(pathv, "..") == 0)) {
	    /*
	     * Handle "/", "//machine/export", "c:/", "." or ".." by just
	     * copying the string literally.  Uppercase the drive letter,
	     * just because it looks better under Windows to do so.
	     */

	    simple:
	    /* Here we are modifying the string representation in place */
	    /* I believe this is legal, since this won't affect any 
	     * file representation this thing may have. */
	    pathv[0] = (char) Tcl_UniCharToUpper(UCHAR(pathv[0]));
	} else {
	    Tcl_Obj *tempPath;
	    Tcl_DString ds;
	    Tcl_DString dsTemp;
	    TCHAR *nativeName;
	    char *tempString;
	    int tempLen;
	    WIN32_FIND_DATAT data;
	    HANDLE handle;
	    DWORD attr;

	    tempPath = Tcl_FSJoinPath(splitPath, i+1);
	    Tcl_IncrRefCount(tempPath);
	    /* 
	     * We'd like to call Tcl_FSGetNativePath(tempPath)
	     * but that is likely to lead to infinite loops 
	     */
	    Tcl_DStringInit(&ds);
	    tempString = Tcl_GetStringFromObj(tempPath,&tempLen);
	    nativeName = Tcl_WinUtfToTChar(tempString, tempLen, &ds);
	    Tcl_DecrRefCount(tempPath);
	    handle = (*tclWinProcs->findFirstFileProc)(nativeName, &data);
	    if (handle == INVALID_HANDLE_VALUE) {
		/*
		 * FindFirstFile() doesn't like root directories.  We 
		 * would only get a root directory here if the caller
		 * specified "c:" or "c:." and the current directory on the
		 * drive was the root directory
		 */

		attr = (*tclWinProcs->getFileAttributesProc)(nativeName);
		if ((attr != 0xFFFFFFFF) && (attr & FILE_ATTRIBUTE_DIRECTORY)) {
		    Tcl_DStringFree(&ds);
		    goto simple;
		}
	    }

	    if (handle == INVALID_HANDLE_VALUE) {
		Tcl_DStringFree(&ds);
		if (interp != NULL) {
		    StatError(interp, fileName);
		}
		result = TCL_ERROR;
		goto cleanup;
	    }
	    if (tclWinProcs->useWide) {
		nativeName = (TCHAR *) data.w.cAlternateFileName;
		if (longShort) {
		    if (data.w.cFileName[0] != '\0') {
			nativeName = (TCHAR *) data.w.cFileName;
		    } 
		} else {
		    if (data.w.cAlternateFileName[0] == '\0') {
			nativeName = (TCHAR *) data.w.cFileName;
		    }
		}
	    } else {
		nativeName = (TCHAR *) data.a.cAlternateFileName;
		if (longShort) {
		    if (data.a.cFileName[0] != '\0') {
			nativeName = (TCHAR *) data.a.cFileName;
		    } 
		} else {
		    if (data.a.cAlternateFileName[0] == '\0') {
			nativeName = (TCHAR *) data.a.cFileName;
		    }
		}
	    }

	    /*
	     * Purify reports a extraneous UMR in Tcl_WinTCharToUtf() trying 
	     * to dereference nativeName as a Unicode string.  I have proven 
	     * to myself that purify is wrong by running the following 
	     * example when nativeName == data.w.cAlternateFileName and 
	     * noting that purify doesn't complain about the first line,
	     * but does complain about the second.
	     *
	     *	fprintf(stderr, "%d\n", data.w.cAlternateFileName[0]);
	     *	fprintf(stderr, "%d\n", ((WCHAR *) nativeName)[0]);
	     */

	    Tcl_DStringInit(&dsTemp);
	    Tcl_WinTCharToUtf(nativeName, -1, &dsTemp);
	    /* Deal with issues of tildes being absolute */
	    if (Tcl_DStringValue(&dsTemp)[0] == '~') {
		tempPath = Tcl_NewStringObj("./",2);
		Tcl_AppendToObj(tempPath, Tcl_DStringValue(&dsTemp), 
				Tcl_DStringLength(&dsTemp));
	    } else {
		tempPath = Tcl_NewStringObj(Tcl_DStringValue(&dsTemp), 
					    Tcl_DStringLength(&dsTemp));
	    }
	    Tcl_ListObjReplace(NULL, splitPath, i, 1, 1, &tempPath);
	    Tcl_DStringFree(&ds);
	    Tcl_DStringFree(&dsTemp);
	    FindClose(handle);
	}
    }

    *attributePtrPtr = Tcl_FSJoinPath(splitPath, -1);

cleanup:
    if (splitPath != NULL) {
	Tcl_DecrRefCount(splitPath);
    }
  
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * GetWinFileLongName --
 *
 *      Returns a Tcl_Obj containing the long version of the file
 *	name.
 *
 * Results:
 *      Standard Tcl result and a Tcl_Obj in attributePtrPtr. The object
 *	will have ref count 0. If the return value is not TCL_OK,
 *	attributePtrPtr is not touched.
 *
 * Side effects:
 *      A new object is allocated if the file is valid.
 *
 *----------------------------------------------------------------------
 */

static int
GetWinFileLongName(
    Tcl_Interp *interp,		/* The interp we are using for errors. */
    int objIndex,		/* The index of the attribute. */
    Tcl_Obj *fileName,  	/* The name of the file. */
    Tcl_Obj **attributePtrPtr)	/* A pointer to return the object with. */
{
    return ConvertFileNameFormat(interp, objIndex, fileName, 1, attributePtrPtr);
}

/*
 *----------------------------------------------------------------------
 *
 * GetWinFileShortName --
 *
 *      Returns a Tcl_Obj containing the short version of the file
 *	name.
 *
 * Results:
 *      Standard Tcl result and a Tcl_Obj in attributePtrPtr. The object
 *	will have ref count 0. If the return value is not TCL_OK,
 *	attributePtrPtr is not touched.
 *
 * Side effects:
 *      A new object is allocated if the file is valid.
 *
 *----------------------------------------------------------------------
 */

static int
GetWinFileShortName(
    Tcl_Interp *interp,		/* The interp we are using for errors. */
    int objIndex,		/* The index of the attribute. */
    Tcl_Obj *fileName,  	/* The name of the file. */
    Tcl_Obj **attributePtrPtr)	/* A pointer to return the object with. */
{
    return ConvertFileNameFormat(interp, objIndex, fileName, 0, attributePtrPtr);
}

/*
 *----------------------------------------------------------------------
 *
 * SetWinFileAttributes --
 *
 *	Set the file attributes to the value given by attributePtr.
 *	This routine sets the -hidden, -readonly, or -system attributes.
 *
 * Results:
 *      Standard TCL error.
 *
 * Side effects:
 *      The file's attribute is set.
 *
 *----------------------------------------------------------------------
 */

static int
SetWinFileAttributes(
    Tcl_Interp *interp,		/* The interp we are using for errors. */
    int objIndex,		/* The index of the attribute. */
    Tcl_Obj *fileName,  	/* The name of the file. */
    Tcl_Obj *attributePtr)	/* The new value of the attribute. */
{
    DWORD fileAttributes;
    int yesNo;
    int result;
    CONST TCHAR *nativeName;

    nativeName = Tcl_FSGetNativePath(fileName);
    fileAttributes = (*tclWinProcs->getFileAttributesProc)(nativeName);

    if (fileAttributes == 0xffffffff) {
	StatError(interp, fileName);
	return TCL_ERROR;
    }

    result = Tcl_GetBooleanFromObj(interp, attributePtr, &yesNo);
    if (result != TCL_OK) {
	return result;
    }

    if (yesNo) {
	fileAttributes |= (attributeArray[objIndex]);
    } else {
	fileAttributes &= ~(attributeArray[objIndex]);
    }

    if (!(*tclWinProcs->setFileAttributesProc)(nativeName, fileAttributes)) {
	StatError(interp, fileName);
	return TCL_ERROR;
    }

    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * SetWinFileLongName --
 *
 *	The attribute in question is a readonly attribute and cannot
 *	be set.
 *
 * Results:
 *      TCL_ERROR
 *
 * Side effects:
 *      The object result is set to a pertinent error message.
 *
 *----------------------------------------------------------------------
 */

static int
CannotSetAttribute(
    Tcl_Interp *interp,		/* The interp we are using for errors. */
    int objIndex,		/* The index of the attribute. */
    Tcl_Obj *fileName,	        /* The name of the file. */
    Tcl_Obj *attributePtr)	/* The new value of the attribute. */
{
    Tcl_AppendStringsToObj(Tcl_GetObjResult(interp), 
	    "cannot set attribute \"", tclpFileAttrStrings[objIndex],
	    "\" for file \"", Tcl_GetString(fileName), 
	    "\": attribute is readonly", 
	    (char *) NULL);
    return TCL_ERROR;
}


/*
 *---------------------------------------------------------------------------
 *
 * TclpObjListVolumes --
 *
 *	Lists the currently mounted volumes
 *
 * Results:
 *	The list of volumes.
 *
 * Side effects:
 *	None
 *
 *---------------------------------------------------------------------------
 */

Tcl_Obj*
TclpObjListVolumes(void)
{
    Tcl_Obj *resultPtr, *elemPtr;
    char buf[40 * 4];		/* There couldn't be more than 30 drives??? */
    int i;
    char *p;

    resultPtr = Tcl_NewObj();

    /*
     * On Win32s:
     * GetLogicalDriveStrings() isn't implemented.
     * GetLogicalDrives() returns incorrect information.
     */

    if (GetLogicalDriveStringsA(sizeof(buf), buf) == 0) {
	/*
	 * GetVolumeInformation() will detects all drives, but causes
	 * chattering on empty floppy drives.  We only do this if 
	 * GetLogicalDriveStrings() didn't work.  It has also been reported
	 * that on some laptops it takes a while for GetVolumeInformation()
	 * to return when pinging an empty floppy drive, another reason to 
	 * try to avoid calling it.
	 */

	buf[1] = ':';
	buf[2] = '/';
	buf[3] = '\0';

	for (i = 0; i < 26; i++) {
	    buf[0] = (char) ('a' + i);
	    if (GetVolumeInformationA(buf, NULL, 0, NULL, NULL, NULL, NULL, 0)  
		    || (GetLastError() == ERROR_NOT_READY)) {
		elemPtr = Tcl_NewStringObj(buf, -1);
		Tcl_ListObjAppendElement(NULL, resultPtr, elemPtr);
	    }
	}
    } else {
	for (p = buf; *p != '\0'; p += 4) {
	    p[2] = '/';
	    elemPtr = Tcl_NewStringObj(p, -1);
	    Tcl_ListObjAppendElement(NULL, resultPtr, elemPtr);
	}
    }
    
    Tcl_IncrRefCount(resultPtr);
    return resultPtr;
}
@


1.6
log
@2003-02-06  Martin M. Hunt  <hunt@@redhat.com>

	* win/tcl.m4 (SC_CONFIG_CFLAGS): Don't default to -O.
	* unix/tcl.m4 (SC_CONFIG_CFLAGS): Don't default to -O.
	CFLAGS gets set to "-O2" by default in top level
	configure. Adding "-O" here causes the "-O2" to be
	ignored, but only when the user types "make" within
	the tcl subdirectory. This caused some confusion.
	* win/configure: Rebuilt.
	* unix/configure: Rebuilt.

	* generic/tclEnv.c (TclUnsetEnv): Cast arg to unsigned.

	Import from latest tcl sources to fix a bug with
	"file copy"
	2003-01-25  Mo DeJong  <mdejong@@users.sourceforge.net>
	* win/tclWinFCmd.c (DoRenameFile, DoCopyFile, squelch_warnings):
	Re-implement inline ASM SEH handlers for gcc.
	The esp and ebp registers are now saved on the
	stack instead of in global variables so that
	the code is thread safe. Add additional checks
	when TCL_MEM_DEBUG is defined to be sure the
	values were recovered from the stack properly.
	Remove squelch_warnings functions and add
	a dummy call in the handler methods to squelch
	compiler warnings.
	* win/tclWinReg.c: Add casts to avoid compiler
	warning. Fix assignment in if expression bug.
@
text
@d472 1
a472 1
__attribute__ ((cdecl))
d654 1
a654 1
__attribute__ ((cdecl))
@


1.5
log
@Updated to tcl 8.4.1
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tclWinFCmd.c,v 1.31 2002/07/15 09:53:21 vincentdarley Exp $
d76 8
a83 4
#ifdef HAVE_NO_SEH
static void *ESP;
static void *EBP;
#endif /* HAVE_NO_SEH */
a101 1
static int		DoDeleteFile(CONST TCHAR *pathPtr);
d194 1
d196 7
a202 2
            "movl  %esp, _ESP" "\n\t"
            "movl  %ebp, _EBP");
d205 1
d208 1
a208 1
            "mov   %esp, %fs:0");
d217 12
a228 4
            "jmp   dorenamefile_pop" "\n"
            "dorenamefile_reentry:" "\n\t"
            "movl  _ESP, %esp" "\n\t"
            "movl  _EBP, %ebp");
d230 1
d232 14
a245 4
            "dorenamefile_pop:" "\n\t"
            "mov   (%esp), %eax" "\n\t"
            "mov   %eax, %fs:0" "\n\t"
            "add   $8, %esp");
d283 1
a283 1
	    char **srcArgv, **dstArgv;
d482 2
d548 1
d550 7
a556 2
            "movl  %esp, _ESP" "\n\t"
            "movl  %ebp, _EBP");
d559 1
d562 1
a562 1
            "mov   %esp, %fs:0");
d571 12
a582 4
            "jmp   docopyfile_pop" "\n"
            "docopyfile_reentry:" "\n\t"
            "movl  _ESP, %esp" "\n\t"
            "movl  _EBP, %ebp");
d584 1
d586 14
a599 4
            "docopyfile_pop:" "\n\t"
            "mov   (%esp), %eax" "\n\t"
            "mov   %eax, %fs:0" "\n\t"
            "add   $8, %esp");
d636 1
a636 1
			dstAttr & ~FILE_ATTRIBUTE_READONLY);
d664 1
d672 1
a672 1
 * TclpObjDeleteFile, DoDeleteFile --
d698 1
a698 1
    return DoDeleteFile(Tcl_FSGetNativePath(pathPtr));
d701 2
a702 2
static int
DoDeleteFile(
d743 1
a743 1
			attr & ~FILE_ATTRIBUTE_READONLY);
d1382 1
a1382 1
	    if (DoDeleteFile(nativeSrc) == TCL_OK) {
@


1.4
log
@touched all sources to ease next import
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tclWinFCmd.c,v 1.6.8.3 2000/09/15 16:58:47 spolk Exp $
d31 1
a31 1
			    int objIndex, CONST char *fileName,
d34 1
a34 1
			    int objIndex, CONST char *fileName,
d37 1
a37 1
			    int objIndex, CONST char *fileName,
d40 1
a40 1
			    int objIndex, CONST char *fileName,
d43 1
a43 1
			    int objIndex, CONST char *fileName,
d63 1
a63 1
char *tclpFileAttrStrings[] = {
d68 1
a68 1
const TclFileAttrProcs tclpFileAttrProcs[] = {
d76 5
d85 1
a85 1
typedef int (TraversalProc)(Tcl_DString *srcPtr, Tcl_DString *dstPtr, 
d92 1
a92 1
static void		StatError(Tcl_Interp *interp, CONST char *fileName);
d94 1
a94 1
			    int objIndex, CONST char *fileName, int longShort,
d96 5
a100 3
static int		DoCopyFile(Tcl_DString *srcPtr, Tcl_DString *dstPtr);
static int		DoCreateDirectory(Tcl_DString *pathPtr);
static int		DoDeleteFile(Tcl_DString *pathPtr);
d103 2
a104 2
static int		DoRenameFile(const TCHAR *nativeSrc, Tcl_DString *dstPtr);
static int		TraversalCopy(Tcl_DString *srcPtr, Tcl_DString *dstPtr, 
d106 1
a106 1
static int		TraversalDelete(Tcl_DString *srcPtr, Tcl_DString *dstPtr, 
d116 1
a116 1
 * TclpRenameFile, DoRenameFile --
d155 4
a158 6
int
TclpRenameFile(
    CONST char *src,		/* Pathname of file or dir to be renamed
				 * (UTF-8). */
    CONST char *dst)		/* New pathname of file or directory
				 * (UTF-8). */
d160 2
a161 11
    int result;
    TCHAR *nativeSrc;
    Tcl_DString srcString, dstString;

    nativeSrc = Tcl_WinUtfToTChar(src, -1, &srcString);
    Tcl_WinUtfToTChar(dst, -1, &dstString);

    result = DoRenameFile(nativeSrc, &dstString);
    Tcl_DStringFree(&srcString);
    Tcl_DStringFree(&dstString);
    return result;
d168 1
a168 1
    Tcl_DString *dstPtr)	/* New pathname for file or directory
a170 1
    const TCHAR *nativeDst;
d172 1
d174 10
a183 1
    nativeDst = (TCHAR *) Tcl_DStringValue(dstPtr);
d186 2
a187 2
     * Would throw an exception under NT if one of the arguments is a 
     * char block device.
d190 10
a199 2
    /* CYGNUS LOCAL */
#ifndef __GNUC__
d201 1
a201 1
#endif
d203 1
a203 1
	    return TCL_OK;
d205 21
a225 5
    /* CYGNUS LOCAL */
#ifndef __GNUC__
    } __except (-1) {}
#endif
    /* END CYGNUS LOCAL */
d339 1
a339 1
		if (DoRemoveDirectory(dstPtr, 0, NULL) == TCL_OK) {
d441 15
d460 1
a460 1
 * TclpCopyFile, DoCopyFile --
d485 3
a487 3
TclpCopyFile(
    CONST char *src,		/* Pathname of file to be copied (UTF-8). */
    CONST char *dst)		/* Pathname of file to copy to (UTF-8). */
d489 2
a490 9
    int result;
    Tcl_DString srcString, dstString;

    Tcl_WinUtfToTChar(src, -1, &srcString);
    Tcl_WinUtfToTChar(dst, -1, &dstString);
    result = DoCopyFile(&srcString, &dstString);
    Tcl_DStringFree(&srcString);
    Tcl_DStringFree(&dstString);
    return result;
d495 2
a496 2
    Tcl_DString *srcPtr,	/* Pathname of file to be copied (native). */
    Tcl_DString *dstPtr)	/* Pathname of file to copy to (native). */
d498 1
a498 1
    CONST TCHAR *nativeSrc, *nativeDst;
d500 4
a503 2
    nativeSrc = (TCHAR *) Tcl_DStringValue(srcPtr);
    nativeDst = (TCHAR *) Tcl_DStringValue(dstPtr);
d505 6
d512 2
a513 2
     * Would throw an exception under NT if one of the arguments is a char
     * block device.
d516 10
a525 2
    /* CYGNUS LOCAL */
#ifndef __GNUC__
d527 1
d529 1
a529 4
#endif
    /* END CYGNUS LOCAL */
	    return TCL_OK;
#ifndef __GNUC__
d531 21
a551 4
    /* CYGNUS LOCAL */
    } __except (-1) {}
#endif
    /* END CYGNUS LOCAL */
d569 6
d595 15
d614 1
a614 1
 * TclpDeleteFile, DoDeleteFile --
d636 3
a638 3
int
TclpDeleteFile(
    CONST char *path)		/* Pathname of file to be removed (UTF-8). */
d640 1
a640 7
    int result;
    Tcl_DString pathString;

    Tcl_WinUtfToTChar(path, -1, &pathString);
    result = DoDeleteFile(&pathString);
    Tcl_DStringFree(&pathString);
    return result;
d645 1
a645 1
    Tcl_DString *pathPtr)	/* Pathname of file to be removed (native). */
a647 1
    CONST TCHAR *nativePath;
d649 10
a658 2
    nativePath = (TCHAR *) Tcl_DStringValue(pathPtr);
    
a663 16
    /*
     * Win32s thinks that "" is the same as "." and then reports EISDIR
     * instead of ENOENT.
     */

    if (tclWinProcs->useWide) {
	if (((WCHAR *) nativePath)[0] == '\0') {
	    Tcl_SetErrno(ENOENT);
	    return TCL_ERROR;
	}
    } else {
	if (((char *) nativePath)[0] == '\0') {
	    Tcl_SetErrno(ENOENT);
	    return TCL_ERROR;
	}
    }
d668 10
a677 1
		/*
d684 1
a684 1
		(*tclWinProcs->setFileAttributesProc)(nativePath, 
d686 2
a687 1
		if ((*tclWinProcs->deleteFileProc)(nativePath) != FALSE) {
d691 3
a693 1
		(*tclWinProcs->setFileAttributesProc)(nativePath, attr);
d723 1
a723 1
 * TclpCreateDirectory --
d745 3
a747 3
int
TclpCreateDirectory(
    CONST char *path)		/* Pathname of directory to create (UTF-8). */
d749 1
a749 7
    int result;
    Tcl_DString pathString;

    Tcl_WinUtfToTChar(path, -1, &pathString);
    result = DoCreateDirectory(&pathString);
    Tcl_DStringFree(&pathString);
    return result;
d754 1
a754 1
    Tcl_DString *pathPtr)	/* Pathname of directory to create (native). */
a756 3
    CONST TCHAR *nativePath;

    nativePath = (TCHAR *) Tcl_DStringValue(pathPtr);
d768 1
a768 1
 * TclpCopyDirectory --
d791 5
a795 8
int
TclpCopyDirectory(
    CONST char *src,		/* Pathname of directory to be copied
				 * (UTF-8). */
    CONST char *dst,		/* Pathname of target directory (UTF-8). */
    Tcl_DString *errorPtr)	/* If non-NULL, uninitialized or free
				 * DString filled with UTF-8 name of file
				 * causing error. */
d797 1
a797 1
    int result;
d799 1
d801 4
a804 2
    Tcl_WinUtfToTChar(src, -1, &srcString);
    Tcl_WinUtfToTChar(dst, -1, &dstString);
d806 1
a806 1
    result = TraverseWinTree(TraversalCopy, &srcString, &dstString, errorPtr);
d810 7
a816 1
    return result;
d822 1
a822 1
 * TclpRemoveDirectory, DoRemoveDirectory -- 
d848 5
a852 10
int
TclpRemoveDirectory(
    CONST char *path,		/* Pathname of directory to be removed
				 * (UTF-8). */
    int recursive,		/* If non-zero, removes directories that
				 * are nonempty.  Otherwise, will only remove
				 * empty directories. */
    Tcl_DString *errorPtr)	/* If non-NULL, uninitialized or free
				 * DString filled with UTF-8 name of file
				 * causing error. */
d854 26
a879 8
    int result;
    Tcl_DString pathString;

    Tcl_WinUtfToTChar(path, -1, &pathString);
    result = DoRemoveDirectory(&pathString, recursive, errorPtr);
    Tcl_DStringFree(&pathString);

    return result;
d883 2
a884 2
DoRemoveDirectory(
    Tcl_DString *pathPtr,	/* Pathname of directory to be removed
d886 3
a888 3
    int recursive,		/* If non-zero, removes directories that
				 * are nonempty.  Otherwise, will only remove
				 * empty directories. */
d893 4
a896 2
    CONST TCHAR *nativePath;
    DWORD attr;
d898 4
a901 1
    nativePath = (TCHAR *) Tcl_DStringValue(pathPtr);
a907 17
    /*
     * Win32s thinks that "" is the same as "." and then reports EACCES
     * instead of ENOENT.
     */


    if (tclWinProcs->useWide) {
	if (((WCHAR *) nativePath)[0] == '\0') {
	    Tcl_SetErrno(ENOENT);
	    return TCL_ERROR;
	}
    } else {
	if (((char *) nativePath)[0] == '\0') {
	    Tcl_SetErrno(ENOENT);
	    return TCL_ERROR;
	}
    }
d909 1
a909 1
	attr = (*tclWinProcs->getFileAttributesProc)(nativePath);
d921 7
d948 1
a948 1
		char *path, *find;
d954 1
a954 1
		path = (char *) nativePath;
d993 5
a997 4
    if ((recursive != 0) && (Tcl_GetErrno() == EEXIST)) {
	/*
	 * The directory is nonempty, but the recursive flag has been
	 * specified, so we recursively remove all the files in the directory.
d999 2
a1001 3
	return TraverseWinTree(TraversalDelete, pathPtr, NULL, errorPtr);
    }
    
d1007 26
d1064 2
a1065 1
				 * parallel with source directory (native). */
d1071 1
a1071 1
    TCHAR *nativeSource, *nativeErrfile;
d1081 2
d1094 1
a1094 1
	return (*traverseProc)(sourcePtr, targetPtr, DOTREE_F, errorPtr);
d1117 1
a1117 1
    result = (*traverseProc)(sourcePtr, targetPtr, DOTREE_PRED, errorPtr);
d1219 3
a1221 2
	result = (*traverseProc)(sourcePtr, targetPtr, DOTREE_POSTD, 
		errorPtr);
d1254 2
a1255 2
    Tcl_DString *srcPtr,	/* Source pathname to copy. */
    Tcl_DString *dstPtr,	/* Destination pathname of copy. */
a1259 3
    TCHAR *nativeDst, *nativeSrc;
    DWORD attr;

d1262 1
a1262 1
	    if (DoCopyFile(srcPtr, dstPtr) == TCL_OK) {
d1268 2
a1269 4
	    if (DoCreateDirectory(dstPtr) == TCL_OK) {
		nativeSrc = (TCHAR *) Tcl_DStringValue(srcPtr);
		nativeDst = (TCHAR *) Tcl_DStringValue(dstPtr);
		attr = (*tclWinProcs->getFileAttributesProc)(nativeSrc);
a1287 1
	nativeDst = (TCHAR *) Tcl_DStringValue(dstPtr);
d1316 2
a1317 2
    Tcl_DString *srcPtr,	/* Source pathname to delete. */
    Tcl_DString *dstPtr,	/* Not used. */
a1321 2
    TCHAR *nativeSrc;

d1324 1
a1324 1
	    if (DoDeleteFile(srcPtr) == TCL_OK) {
d1333 1
a1333 1
	    if (DoRemoveDirectory(srcPtr, 0, NULL) == TCL_OK) {
a1340 1
	nativeSrc = (TCHAR *) Tcl_DStringValue(srcPtr);
d1366 1
a1366 1
    CONST char *fileName)	/* The name of the file which caused the 
d1371 3
a1373 2
	    "could not read \"", fileName, "\": ", Tcl_PosixError(interp), 
	    (char *) NULL);
d1399 1
a1399 1
    CONST char *fileName,	/* The name of the file. */
d1403 4
a1406 4
    Tcl_DString ds;
    TCHAR *nativeName;

    nativeName = Tcl_WinUtfToTChar(fileName, -1, &ds);
a1407 1
    Tcl_DStringFree(&ds);
d1414 28
a1441 1
    *attributePtrPtr = Tcl_NewBooleanObj((int) (result & attributeArray[objIndex]));
d1457 5
d1473 1
a1473 1
    CONST char *fileName,	/* The name of the file. */
d1478 1
a1478 3
    char **pathv, **newv;
    char *resultStr;
    Tcl_DString resultDString;
d1481 1
a1481 2
    Tcl_SplitPath(fileName, &pathc, &pathv);
    newv = (char **) ckalloc(pathc * sizeof(char *));
d1483 4
a1486 3
    if (pathc == 0) {
	Tcl_AppendStringsToObj(Tcl_GetObjResult(interp), 
		"could not read \"", fileName,
d1489 1
d1495 10
a1504 4
	if ((pathv[i][0] == '/')
		|| ((strlen(pathv[i]) == 3) && (pathv[i][1] == ':'))
		|| (strcmp(pathv[i], ".") == 0)
		|| (strcmp(pathv[i], "..") == 0)) {
d1512 4
a1515 3
	    pathv[i][0] = (char) Tcl_UniCharToUpper(UCHAR(pathv[i][0]));
	    newv[i] = (char *) ckalloc(strlen(pathv[i]) + 1);
	    lstrcpyA(newv[i], pathv[i]);
d1517 3
a1519 1
	    char *str;
d1521 2
a1522 1
	    Tcl_DString ds;
d1527 10
a1536 3
	    Tcl_DStringInit(&resultDString);
	    str = Tcl_JoinPath(i + 1, pathv, &resultDString);
	    nativeName = Tcl_WinUtfToTChar(str, -1, &ds);
a1548 2
		    Tcl_DStringFree(&resultDString);

a1551 2
	    Tcl_DStringFree(&ds);
	    Tcl_DStringFree(&resultDString);
d1554 4
a1557 2
		pathc = i - 1;
		StatError(interp, fileName);
d1597 12
a1608 3
	    Tcl_WinTCharToUtf(nativeName, -1, &ds);
	    newv[i] = ckalloc((unsigned int) (Tcl_DStringLength(&ds) + 1));
	    lstrcpyA(newv[i], Tcl_DStringValue(&ds));
d1610 1
d1615 1
a1615 5
    Tcl_DStringInit(&resultDString);
    resultStr = Tcl_JoinPath(pathc, newv, &resultDString);
    *attributePtrPtr = Tcl_NewStringObj(resultStr, 
	    Tcl_DStringLength(&resultDString));
    Tcl_DStringFree(&resultDString);
d1618 2
a1619 2
    for (i = 0; i < pathc; i++) {
	ckfree(newv[i]);
d1621 1
a1621 2
    ckfree((char *) newv);
    ckfree((char *) pathv);
d1630 1
a1630 1
 *      Returns a Tcl_Obj containing the short version of the file
d1648 1
a1648 1
    CONST char *fileName,	/* The name of the file. */
d1677 1
a1677 1
    CONST char *fileName,	/* The name of the file. */
d1704 1
a1704 1
    CONST char *fileName,	/* The name of the file. */
d1710 1
a1710 2
    Tcl_DString ds;
    TCHAR *nativeName;
d1712 1
a1712 1
    nativeName = Tcl_WinUtfToTChar(fileName, -1, &ds);
d1717 1
a1717 2
	result = TCL_ERROR;
	goto end;
d1722 1
a1722 1
	goto end;
d1733 1
a1733 2
	result = TCL_ERROR;
	goto end;
a1735 3
    end:
    Tcl_DStringFree(&ds);

d1751 1
a1751 1
 *      The object result is set to a pertinant error message.
d1760 1
a1760 1
    CONST char *fileName,	/* The name of the file. */
d1765 2
a1766 1
	    "\" for file \"", fileName, "\": attribute is readonly", 
d1775 1
a1775 1
 * TclpListVolumes --
d1780 1
a1780 3
 *	A standard Tcl result.  Will always be TCL_OK, since there is no way
 *	that this command can fail.  Also, the interpreter's result is set to 
 *	the list of volumes.
d1788 2
a1789 3
int
TclpListVolumes( 
    Tcl_Interp *interp)		/* Interpreter for returning volume list. */
d1796 1
a1796 1
    resultPtr = Tcl_GetObjResult(interp);
d1833 3
a1835 1
    return TCL_OK;	
a1836 3



@


1.3
log
@touched all sources to ease next import
@
text
@@


1.3.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tclWinFCmd.c,v 1.34 2003/02/04 17:06:53 vincentdarley Exp $
d31 1
a31 1
			    int objIndex, Tcl_Obj *fileName,
d34 1
a34 1
			    int objIndex, Tcl_Obj *fileName,
d37 1
a37 1
			    int objIndex, Tcl_Obj *fileName,
d40 1
a40 1
			    int objIndex, Tcl_Obj *fileName,
d43 1
a43 1
			    int objIndex, Tcl_Obj *fileName,
d63 1
a63 1
CONST char *tclpFileAttrStrings[] = {
d68 1
a68 1
CONST TclFileAttrProcs tclpFileAttrProcs[] = {
a75 9
#if defined(HAVE_NO_SEH) && defined(TCL_MEM_DEBUG)
static void *INITIAL_ESP,
            *INITIAL_EBP,
            *INITIAL_HANDLER,
            *RESTORED_ESP,
            *RESTORED_EBP,
            *RESTORED_HANDLER;
#endif /* HAVE_NO_SEH && TCL_MEM_DEBUG */

d80 1
a80 1
typedef int (TraversalProc)(CONST TCHAR *srcPtr, CONST TCHAR *dstPtr, 
d87 1
a87 1
static void		StatError(Tcl_Interp *interp, Tcl_Obj *fileName);
d89 1
a89 1
			    int objIndex, Tcl_Obj *fileName, int longShort,
d91 3
a93 4
static int		DoCopyFile(CONST TCHAR *srcPtr, CONST TCHAR *dstPtr);
static int		DoCreateDirectory(CONST TCHAR *pathPtr);
static int		DoRemoveJustDirectory(CONST TCHAR *nativeSrc, 
			    int ignoreError, Tcl_DString *errorPtr);
d96 2
a97 2
static int		DoRenameFile(CONST TCHAR *nativeSrc, CONST TCHAR *dstPtr);
static int		TraversalCopy(CONST TCHAR *srcPtr, CONST TCHAR *dstPtr, 
d99 1
a99 1
static int		TraversalDelete(CONST TCHAR *srcPtr, CONST TCHAR *dstPtr, 
d109 1
a109 1
 * TclpObjRenameFile, DoRenameFile --
d148 6
a153 4
int 
TclpObjRenameFile(srcPathPtr, destPathPtr)
    Tcl_Obj *srcPathPtr;
    Tcl_Obj *destPathPtr;
d155 11
a165 2
    return DoRenameFile(Tcl_FSGetNativePath(srcPathPtr), 
			Tcl_FSGetNativePath(destPathPtr));
d172 1
a172 1
    CONST TCHAR *nativeDst)	/* New pathname for file or directory
d175 1
a176 1
    int retval = -1;
d178 1
a178 10
    /*
     * The MoveFile API acts differently under Win95/98 and NT
     * WRT NULL and "". Avoid passing these values.
     */

    if (nativeSrc == NULL || nativeSrc[0] == '\0' ||
        nativeDst == NULL || nativeDst[0] == '\0') {
	Tcl_SetErrno(ENOENT);
	return TCL_ERROR;
    }
d181 2
a182 2
     * The MoveFile API would throw an exception under NT
     * if one of the arguments is a char block device.
d185 2
a186 17
#ifdef HAVE_NO_SEH
# ifdef TCL_MEM_DEBUG
    __asm__ __volatile__ (
            "movl %%esp,  %0" "\n\t"
            "movl %%ebp,  %1" "\n\t"
            "movl %%fs:0, %2" "\n\t"
            : "=m"(INITIAL_ESP),
              "=m"(INITIAL_EBP),
              "=r"(INITIAL_HANDLER) );
# endif /* TCL_MEM_DEBUG */

    __asm__ __volatile__ (
            "pushl %ebp" "\n\t"
            "pushl $__except_dorenamefile_handler" "\n\t"
            "pushl %fs:0" "\n\t"
            "movl  %esp, %fs:0");
#else
d188 1
a188 1
#endif /* HAVE_NO_SEH */
d190 1
a190 1
	    retval = TCL_OK;
d192 5
a196 40
#ifdef HAVE_NO_SEH
    __asm__ __volatile__ (
            "jmp  dorenamefile_pop" "\n"
        "dorenamefile_reentry:" "\n\t"
            "movl %%fs:0, %%eax" "\n\t"
            "movl 0x8(%%eax), %%esp" "\n\t"
            "movl 0x8(%%esp), %%ebp" "\n"
        "dorenamefile_pop:" "\n\t"
            "movl (%%esp), %%eax" "\n\t"
            "movl %%eax, %%fs:0" "\n\t"
            "add  $12, %%esp" "\n\t"
            :
            :
            : "%eax");

# ifdef TCL_MEM_DEBUG
    __asm__ __volatile__ (
            "movl  %%esp,  %0" "\n\t"
            "movl  %%ebp,  %1" "\n\t"
            "movl  %%fs:0, %2" "\n\t"
            : "=m"(RESTORED_ESP),
              "=m"(RESTORED_EBP),
              "=r"(RESTORED_HANDLER) );

    if (INITIAL_ESP != RESTORED_ESP)
        panic("ESP restored incorrectly");
    if (INITIAL_EBP != RESTORED_EBP)
        panic("EBP restored incorrectly");
    if (INITIAL_HANDLER != RESTORED_HANDLER)
        panic("HANDLER restored incorrectly");
# endif /* TCL_MEM_DEBUG */
#else
    } __except (EXCEPTION_EXECUTE_HANDLER) {}
#endif /* HAVE_NO_SEH */

    /*
     * Avoid using control flow statements in the SEH guarded block!
     */
    if (retval != -1)
        return retval;
d225 1
a225 1
	    CONST char **srcArgv, **dstArgv;
d310 1
a310 1
		if (DoRemoveJustDirectory(nativeDst, 0, NULL) == TCL_OK) {
a411 17
#ifdef HAVE_NO_SEH
static
__attribute__ ((cdecl))
EXCEPTION_DISPOSITION
_except_dorenamefile_handler(
    struct _EXCEPTION_RECORD *ExceptionRecord,
    void *EstablisherFrame,
    struct _CONTEXT *ContextRecord,
    void *DispatcherContext)
{
    __asm__ __volatile__ (
            "jmp dorenamefile_reentry");
    /* Nuke compiler warning about unused static function */
    _except_dorenamefile_handler(NULL, NULL, NULL, NULL);
    return 0; /* Function does not return */
}
#endif /* HAVE_NO_SEH */
d416 1
a416 1
 * TclpObjCopyFile, DoCopyFile --
d441 3
a443 3
TclpObjCopyFile(srcPathPtr, destPathPtr)
    Tcl_Obj *srcPathPtr;
    Tcl_Obj *destPathPtr;
d445 9
a453 2
    return DoCopyFile(Tcl_FSGetNativePath(srcPathPtr),
		      Tcl_FSGetNativePath(destPathPtr));
d458 2
a459 2
   CONST TCHAR *nativeSrc,	/* Pathname of file to be copied (native). */
   CONST TCHAR *nativeDst)	/* Pathname of file to copy to (native). */
d461 1
a461 1
    int retval = -1;
d463 2
a464 4
    /*
     * The CopyFile API acts differently under Win95/98 and NT
     * WRT NULL and "". Avoid passing these values.
     */
a465 6
    if (nativeSrc == NULL || nativeSrc[0] == '\0' ||
        nativeDst == NULL || nativeDst[0] == '\0') {
	Tcl_SetErrno(ENOENT);
	return TCL_ERROR;
    }
    
d467 2
a468 2
     * The CopyFile API would throw an exception under NT if one
     * of the arguments is a char block device.
d471 2
a472 17
#ifdef HAVE_NO_SEH
# ifdef TCL_MEM_DEBUG
    __asm__ __volatile__ (
            "movl %%esp,  %0" "\n\t"
            "movl %%ebp,  %1" "\n\t"
            "movl %%fs:0, %2" "\n\t"
            : "=m"(INITIAL_ESP),
              "=m"(INITIAL_EBP),
              "=r"(INITIAL_HANDLER) );
# endif /* TCL_MEM_DEBUG */

    __asm__ __volatile__ (
            "pushl %ebp" "\n\t"
            "pushl $__except_docopyfile_handler" "\n\t"
            "pushl %fs:0" "\n\t"
            "movl  %esp, %fs:0");
#else
a473 1
#endif /* HAVE_NO_SEH */
d475 4
a478 1
	    retval = TCL_OK;
d480 4
a483 40
#ifdef HAVE_NO_SEH
    __asm__ __volatile__ (
            "jmp  docopyfile_pop" "\n"
        "docopyfile_reentry:" "\n\t"
            "movl %%fs:0, %%eax" "\n\t"
            "movl 0x8(%%eax), %%esp" "\n\t"
            "movl 0x8(%%esp), %%ebp" "\n"
        "docopyfile_pop:" "\n\t"
            "movl (%%esp), %%eax" "\n\t"
            "movl %%eax, %%fs:0" "\n\t"
            "add  $12, %%esp" "\n\t"
            :
            :
            : "%eax");

# ifdef TCL_MEM_DEBUG
    __asm__ __volatile__ (
            "movl  %%esp,  %0" "\n\t"
            "movl  %%ebp,  %1" "\n\t"
            "movl  %%fs:0, %2" "\n\t"
            : "=m"(RESTORED_ESP),
              "=m"(RESTORED_EBP),
              "=r"(RESTORED_HANDLER) );

    if (INITIAL_ESP != RESTORED_ESP)
        panic("ESP restored incorrectly");
    if (INITIAL_EBP != RESTORED_EBP)
        panic("EBP restored incorrectly");
    if (INITIAL_HANDLER != RESTORED_HANDLER)
        panic("HANDLER restored incorrectly");
# endif /* TCL_MEM_DEBUG */
#else
    } __except (EXCEPTION_EXECUTE_HANDLER) {}
#endif /* HAVE_NO_SEH */

    /*
     * Avoid using control flow statements in the SEH guarded block!
     */
    if (retval != -1)
        return retval;
a500 6
		if (srcAttr & FILE_ATTRIBUTE_REPARSE_POINT) {
		    /* Source is a symbolic link -- copy it */
		    if (TclWinSymLinkCopyDirectory(nativeSrc, nativeDst) == 0) {
		        return TCL_OK;
		    }
		}
d505 1
a505 1
			dstAttr & ~((DWORD)FILE_ATTRIBUTE_READONLY));
a520 16
#ifdef HAVE_NO_SEH
static
__attribute__ ((cdecl))
EXCEPTION_DISPOSITION
_except_docopyfile_handler(
    struct _EXCEPTION_RECORD *ExceptionRecord,
    void *EstablisherFrame,
    struct _CONTEXT *ContextRecord,
    void *DispatcherContext)
{
    __asm__ __volatile__ (
            "jmp docopyfile_reentry");
    _except_docopyfile_handler(NULL,NULL,NULL,NULL);
    return 0; /* Function does not return */
}
#endif /* HAVE_NO_SEH */
d525 1
a525 1
 * TclpObjDeleteFile, TclpDeleteFile --
d547 3
a549 3
int 
TclpObjDeleteFile(pathPtr)
    Tcl_Obj *pathPtr;
d551 7
a557 1
    return TclpDeleteFile(Tcl_FSGetNativePath(pathPtr));
d560 3
a562 3
int
TclpDeleteFile(
    CONST TCHAR *nativePath)	/* Pathname of file to be removed (native). */
d565 1
d567 2
a568 10
    /*
     * The DeleteFile API acts differently under Win95/98 and NT
     * WRT NULL and "". Avoid passing these values.
     */

    if (nativePath == NULL || nativePath[0] == '\0') {
	Tcl_SetErrno(ENOENT);
	return TCL_ERROR;
    }

d574 16
d594 1
a594 10
		if (attr & FILE_ATTRIBUTE_REPARSE_POINT) {
		    /* It is a symbolic link -- remove it */
		    if (TclWinSymLinkDelete(nativePath, 0) == 0) {
		        return TCL_OK;
		    }
		}
		
		/* 
		 * If we fall through here, it is a directory.
		 * 
d601 3
a603 4
		int res = (*tclWinProcs->setFileAttributesProc)(nativePath, 
			attr & ~((DWORD)FILE_ATTRIBUTE_READONLY));
		if ((res != 0) && ((*tclWinProcs->deleteFileProc)(nativePath)
			!= FALSE)) {
d607 1
a607 3
		if (res != 0) {
		    (*tclWinProcs->setFileAttributesProc)(nativePath, attr);
		}
d637 1
a637 1
 * TclpObjCreateDirectory --
d659 3
a661 3
int 
TclpObjCreateDirectory(pathPtr)
    Tcl_Obj *pathPtr;
d663 7
a669 1
    return DoCreateDirectory(Tcl_FSGetNativePath(pathPtr));
d674 1
a674 1
    CONST TCHAR *nativePath)	/* Pathname of directory to create (native). */
d677 3
d691 1
a691 1
 * TclpObjCopyDirectory --
d714 8
a721 5
int 
TclpObjCopyDirectory(srcPathPtr, destPathPtr, errorPtr)
    Tcl_Obj *srcPathPtr;
    Tcl_Obj *destPathPtr;
    Tcl_Obj **errorPtr;
d723 1
a723 1
    Tcl_DString ds;
a724 1
    int ret;
d726 2
a727 4
    Tcl_WinUtfToTChar(Tcl_FSGetTranslatedStringPath(NULL,srcPathPtr), 
		      -1, &srcString);
    Tcl_WinUtfToTChar(Tcl_FSGetTranslatedStringPath(NULL,destPathPtr), 
		      -1, &dstString);
d729 1
a729 1
    ret = TraverseWinTree(TraversalCopy, &srcString, &dstString, &ds);
d733 1
a733 7

    if (ret != TCL_OK) {
	*errorPtr = Tcl_NewStringObj(Tcl_DStringValue(&ds), -1);
	Tcl_DStringFree(&ds);
	Tcl_IncrRefCount(*errorPtr);
    }
    return ret;
d739 1
a739 1
 * TclpObjRemoveDirectory, DoRemoveDirectory -- 
d765 10
a774 5
int 
TclpObjRemoveDirectory(pathPtr, recursive, errorPtr)
    Tcl_Obj *pathPtr;
    int recursive;
    Tcl_Obj **errorPtr;
d776 8
a783 26
    Tcl_DString ds;
    int ret;
    if (recursive) {
	/* 
	 * In the recursive case, the string rep is used to construct a
	 * Tcl_DString which may be used extensively, so we can't
	 * optimize this case easily.
	 */
	Tcl_DString native;
	Tcl_WinUtfToTChar(Tcl_FSGetTranslatedStringPath(NULL, pathPtr), 
			  -1, &native);
	ret = DoRemoveDirectory(&native, recursive, &ds);
	Tcl_DStringFree(&native);
    } else {
	ret = DoRemoveJustDirectory(Tcl_FSGetNativePath(pathPtr), 
				    0, &ds);
    }
    if (ret != TCL_OK) {
	int len = Tcl_DStringLength(&ds);
	if (len > 0) {
	    *errorPtr = Tcl_NewStringObj(Tcl_DStringValue(&ds), -1);
	    Tcl_IncrRefCount(*errorPtr);
	}
	Tcl_DStringFree(&ds);
    }
    return ret;
d787 2
a788 2
DoRemoveJustDirectory(
    CONST TCHAR *nativePath,	/* Pathname of directory to be removed
d790 3
a792 3
    int ignoreError,		/* If non-zero, don't initialize the
                  		 * errorPtr under some circumstances
                  		 * on return. */
d797 2
a798 4
    /*
     * The RemoveDirectory API acts differently under Win95/98 and NT
     * WRT NULL and "". Avoid passing these values.
     */
d800 1
a800 4
    if (nativePath == NULL || nativePath[0] == '\0') {
	Tcl_SetErrno(ENOENT);
	goto end;
    }
d807 17
d825 1
a825 1
	DWORD attr = (*tclWinProcs->getFileAttributesProc)(nativePath);
a836 7
	    if (attr & FILE_ATTRIBUTE_REPARSE_POINT) {
		/* It is a symbolic link -- remove it */
		if (TclWinSymLinkDelete(nativePath, 1) != 0) {
		    goto end;
		}
	    }
	    
d857 1
a857 1
		CONST char *path, *find;
d863 1
a863 1
		path = (CONST char *) nativePath;
d902 4
a905 5
    if ((ignoreError != 0) && (Tcl_GetErrno() == EEXIST)) {
	/* 
	 * If we're being recursive, this error may actually
	 * be ok, so we don't want to initialise the errorPtr
	 * yet.
d907 2
a908 1
	return TCL_ERROR;
d910 1
a910 1

a915 26

}

static int
DoRemoveDirectory(
    Tcl_DString *pathPtr,	/* Pathname of directory to be removed
				 * (native). */
    int recursive,		/* If non-zero, removes directories that
				 * are nonempty.  Otherwise, will only remove
				 * empty directories. */
    Tcl_DString *errorPtr)	/* If non-NULL, uninitialized or free
				 * DString filled with UTF-8 name of file
				 * causing error. */
{
    int res = DoRemoveJustDirectory(Tcl_DStringValue(pathPtr), recursive, 
				    errorPtr);
    
    if ((res == TCL_ERROR) && (recursive != 0) && (Tcl_GetErrno() == EEXIST)) {
	/*
	 * The directory is nonempty, but the recursive flag has been
	 * specified, so we recursively remove all the files in the directory.
	 */
	return TraverseWinTree(TraversalDelete, pathPtr, NULL, errorPtr);
    } else {
	return res;
    }
d947 1
a947 2
				 * parallel with source directory (native),
				 * may be NULL. */
d953 1
a953 1
    TCHAR *nativeSource, *nativeTarget, *nativeErrfile;
a962 2
    nativeTarget = (TCHAR *) (targetPtr == NULL ? NULL : Tcl_DStringValue(targetPtr));
    
d974 1
a974 1
	return (*traverseProc)(nativeSource, nativeTarget, DOTREE_F, errorPtr);
d997 1
a997 1
    result = (*traverseProc)(nativeSource, nativeTarget, DOTREE_PRED, errorPtr);
d1099 2
a1100 3
	result = (*traverseProc)(Tcl_DStringValue(sourcePtr), 
			(targetPtr == NULL ? NULL : Tcl_DStringValue(targetPtr)), 
			DOTREE_POSTD, errorPtr);
d1133 2
a1134 2
    CONST TCHAR *nativeSrc,	/* Source pathname to copy. */
    CONST TCHAR *nativeDst,	/* Destination pathname of copy. */
d1139 3
d1144 1
a1144 1
	    if (DoCopyFile(nativeSrc, nativeDst) == TCL_OK) {
d1150 4
a1153 2
	    if (DoCreateDirectory(nativeDst) == TCL_OK) {
		DWORD attr = (*tclWinProcs->getFileAttributesProc)(nativeSrc);
d1172 1
d1201 2
a1202 2
    CONST TCHAR *nativeSrc,	/* Source pathname to delete. */
    CONST TCHAR *dstPtr,	/* Not used. */
d1207 2
d1211 1
a1211 1
	    if (TclpDeleteFile(nativeSrc) == TCL_OK) {
d1220 1
a1220 1
	    if (DoRemoveJustDirectory(nativeSrc, 0, NULL) == TCL_OK) {
d1228 1
d1254 1
a1254 1
    Tcl_Obj *fileName)	        /* The name of the file which caused the 
d1259 2
a1260 3
			   "could not read \"", Tcl_GetString(fileName), 
			   "\": ", Tcl_PosixError(interp), 
			   (char *) NULL);
d1286 1
a1286 1
    Tcl_Obj *fileName,	        /* The name of the file. */
d1290 4
a1293 4
    CONST TCHAR *nativeName;
    int attr;
    
    nativeName = Tcl_FSGetNativePath(fileName);
d1295 1
d1302 1
a1302 28
    attr = (int)(result & attributeArray[objIndex]);
    if ((objIndex == WIN_HIDDEN_ATTRIBUTE) && (attr != 0)) {
	/* 
	 * It is hidden.  However there is a bug on some Windows
	 * OSes in which root volumes (drives) formatted as NTFS
	 * are declared hidden when they are not (and cannot be).
	 * 
	 * We test for, and fix that case, here.
	 */
	int len;
	char *str = Tcl_GetStringFromObj(fileName,&len);
	if (len < 4) {
	    if (len == 0) {
		/* 
		 * Not sure if this is possible, but we pass it on
		 * anyway 
		 */
	    } else if (len == 1 && (str[0] == '/' || str[0] == '\\')) {
		/* Path is pointing to the root volume */
		attr = 0;
	    } else if ((str[1] == ':') 
		       && (len == 2 || (str[2] == '/' || str[2] == '\\'))) {
		/* Path is of the form 'x:' or 'x:/' or 'x:\' */
		attr = 0;
	    }
	}
    }
    *attributePtrPtr = Tcl_NewBooleanObj(attr);
a1317 5
 *	
 *	Warning: if you pass this function a drive name like 'c:' it
 *	will actually return the current working directory on that
 *	drive.  To avoid this, make sure the drive name ends in a
 *	slash, like this 'c:/'.
d1329 1
a1329 1
    Tcl_Obj *fileName,   	/* The name of the file. */
d1334 3
a1336 1
    Tcl_Obj *splitPath;
d1339 2
a1340 1
    splitPath = Tcl_FSSplitPath(fileName, &pathc);
d1342 3
a1344 4
    if (splitPath == NULL || pathc == 0) {
	if (interp != NULL) {
	    Tcl_AppendStringsToObj(Tcl_GetObjResult(interp), 
		"could not read \"", Tcl_GetString(fileName),
a1346 1
	}
d1352 4
a1355 10
	Tcl_Obj *elt;
	char *pathv;
	int pathLen;
	Tcl_ListObjIndex(NULL, splitPath, i, &elt);
	
	pathv = Tcl_GetStringFromObj(elt, &pathLen);
	if ((pathv[0] == '/')
		|| ((pathLen == 3) && (pathv[1] == ':'))
		|| (strcmp(pathv, ".") == 0)
		|| (strcmp(pathv, "..") == 0)) {
d1363 3
a1365 4
	    /* Here we are modifying the string representation in place */
	    /* I believe this is legal, since this won't affect any 
	     * file representation this thing may have. */
	    pathv[0] = (char) Tcl_UniCharToUpper(UCHAR(pathv[0]));
d1367 2
a1368 1
	    Tcl_Obj *tempPath;
a1369 4
	    Tcl_DString dsTemp;
	    TCHAR *nativeName;
	    char *tempString;
	    int tempLen;
d1374 3
a1376 10
	    tempPath = Tcl_FSJoinPath(splitPath, i+1);
	    Tcl_IncrRefCount(tempPath);
	    /* 
	     * We'd like to call Tcl_FSGetNativePath(tempPath)
	     * but that is likely to lead to infinite loops 
	     */
	    Tcl_DStringInit(&ds);
	    tempString = Tcl_GetStringFromObj(tempPath,&tempLen);
	    nativeName = Tcl_WinUtfToTChar(tempString, tempLen, &ds);
	    Tcl_DecrRefCount(tempPath);
d1389 2
d1394 2
d1398 2
a1399 4
		Tcl_DStringFree(&ds);
		if (interp != NULL) {
		    StatError(interp, fileName);
		}
d1439 3
a1441 12
	    Tcl_DStringInit(&dsTemp);
	    Tcl_WinTCharToUtf(nativeName, -1, &dsTemp);
	    /* Deal with issues of tildes being absolute */
	    if (Tcl_DStringValue(&dsTemp)[0] == '~') {
		tempPath = Tcl_NewStringObj("./",2);
		Tcl_AppendToObj(tempPath, Tcl_DStringValue(&dsTemp), 
				Tcl_DStringLength(&dsTemp));
	    } else {
		tempPath = Tcl_NewStringObj(Tcl_DStringValue(&dsTemp), 
					    Tcl_DStringLength(&dsTemp));
	    }
	    Tcl_ListObjReplace(NULL, splitPath, i, 1, 1, &tempPath);
a1442 1
	    Tcl_DStringFree(&dsTemp);
d1447 5
a1451 1
    *attributePtrPtr = Tcl_FSJoinPath(splitPath, -1);
d1454 2
a1455 2
    if (splitPath != NULL) {
	Tcl_DecrRefCount(splitPath);
d1457 2
a1458 1
  
d1467 1
a1467 1
 *      Returns a Tcl_Obj containing the long version of the file
d1485 1
a1485 1
    Tcl_Obj *fileName,  	/* The name of the file. */
d1514 1
a1514 1
    Tcl_Obj *fileName,  	/* The name of the file. */
d1541 1
a1541 1
    Tcl_Obj *fileName,  	/* The name of the file. */
d1547 2
a1548 1
    CONST TCHAR *nativeName;
d1550 1
a1550 1
    nativeName = Tcl_FSGetNativePath(fileName);
d1555 2
a1556 1
	return TCL_ERROR;
d1561 1
a1561 1
	return result;
d1572 2
a1573 1
	return TCL_ERROR;
d1576 3
d1594 1
a1594 1
 *      The object result is set to a pertinent error message.
d1603 1
a1603 1
    Tcl_Obj *fileName,	        /* The name of the file. */
d1608 1
a1608 2
	    "\" for file \"", Tcl_GetString(fileName), 
	    "\": attribute is readonly", 
d1617 1
a1617 1
 * TclpObjListVolumes --
d1622 3
a1624 1
 *	The list of volumes.
d1632 3
a1634 2
Tcl_Obj*
TclpObjListVolumes(void)
d1641 1
a1641 1
    resultPtr = Tcl_NewObj();
d1678 1
a1678 3
    
    Tcl_IncrRefCount(resultPtr);
    return resultPtr;
d1680 3
@


1.3.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tclWinFCmd.c,v 1.31 2002/07/15 09:53:21 vincentdarley Exp $
d31 1
a31 1
			    int objIndex, Tcl_Obj *fileName,
d34 1
a34 1
			    int objIndex, Tcl_Obj *fileName,
d37 1
a37 1
			    int objIndex, Tcl_Obj *fileName,
d40 1
a40 1
			    int objIndex, Tcl_Obj *fileName,
d43 1
a43 1
			    int objIndex, Tcl_Obj *fileName,
d63 1
a63 1
CONST char *tclpFileAttrStrings[] = {
d68 1
a68 1
CONST TclFileAttrProcs tclpFileAttrProcs[] = {
a75 5
#ifdef HAVE_NO_SEH
static void *ESP;
static void *EBP;
#endif /* HAVE_NO_SEH */

d80 1
a80 1
typedef int (TraversalProc)(CONST TCHAR *srcPtr, CONST TCHAR *dstPtr, 
d87 1
a87 1
static void		StatError(Tcl_Interp *interp, Tcl_Obj *fileName);
d89 1
a89 1
			    int objIndex, Tcl_Obj *fileName, int longShort,
d91 3
a93 5
static int		DoCopyFile(CONST TCHAR *srcPtr, CONST TCHAR *dstPtr);
static int		DoCreateDirectory(CONST TCHAR *pathPtr);
static int		DoDeleteFile(CONST TCHAR *pathPtr);
static int		DoRemoveJustDirectory(CONST TCHAR *nativeSrc, 
			    int ignoreError, Tcl_DString *errorPtr);
d96 2
a97 2
static int		DoRenameFile(CONST TCHAR *nativeSrc, CONST TCHAR *dstPtr);
static int		TraversalCopy(CONST TCHAR *srcPtr, CONST TCHAR *dstPtr, 
d99 1
a99 1
static int		TraversalDelete(CONST TCHAR *srcPtr, CONST TCHAR *dstPtr, 
d109 1
a109 1
 * TclpObjRenameFile, DoRenameFile --
d148 6
a153 4
int 
TclpObjRenameFile(srcPathPtr, destPathPtr)
    Tcl_Obj *srcPathPtr;
    Tcl_Obj *destPathPtr;
d155 11
a165 2
    return DoRenameFile(Tcl_FSGetNativePath(srcPathPtr), 
			Tcl_FSGetNativePath(destPathPtr));
d172 1
a172 1
    CONST TCHAR *nativeDst)	/* New pathname for file or directory
d175 1
a176 1
    int retval = -1;
d178 1
a178 10
    /*
     * The MoveFile API acts differently under Win95/98 and NT
     * WRT NULL and "". Avoid passing these values.
     */

    if (nativeSrc == NULL || nativeSrc[0] == '\0' ||
        nativeDst == NULL || nativeDst[0] == '\0') {
	Tcl_SetErrno(ENOENT);
	return TCL_ERROR;
    }
d181 2
a182 2
     * The MoveFile API would throw an exception under NT
     * if one of the arguments is a char block device.
d185 2
a186 11
#ifndef __CYGWIN__
#ifdef HAVE_NO_SEH
    __asm__ __volatile__ (
            "movl  %esp, _ESP" "\n\t"
            "movl  %ebp, _EBP");

    __asm__ __volatile__ (
            "pushl $__except_dorenamefile_handler" "\n\t"
            "pushl %fs:0" "\n\t"
            "mov   %esp, %fs:0");
#else
d188 1
a188 2
#endif /* HAVE_NO_SEH */
#endif /* !__CYGWIN__ */
d190 1
a190 1
	    retval = TCL_OK;
d192 5
a196 23
#ifndef __CYGWIN__
#ifdef HAVE_NO_SEH
    __asm__ __volatile__ (
            "jmp   dorenamefile_pop" "\n"
            "dorenamefile_reentry:" "\n\t"
            "movl  _ESP, %esp" "\n\t"
            "movl  _EBP, %ebp");

    __asm__ __volatile__ (
            "dorenamefile_pop:" "\n\t"
            "mov   (%esp), %eax" "\n\t"
            "mov   %eax, %fs:0" "\n\t"
            "add   $8, %esp");
#else
    } __except (EXCEPTION_EXECUTE_HANDLER) {}
#endif /* HAVE_NO_SEH */
#endif /* !__CYGWIN__ */

    /*
     * Avoid using control flow statements in the SEH guarded block!
     */
    if (retval != -1)
        return retval;
d310 1
a310 1
		if (DoRemoveJustDirectory(nativeDst, 0, NULL) == TCL_OK) {
a411 17
#ifndef __CYGWIN__
#ifdef HAVE_NO_SEH
static
__attribute__ ((cdecl))
EXCEPTION_DISPOSITION
_except_dorenamefile_handler(
    struct _EXCEPTION_RECORD *ExceptionRecord,
    void *EstablisherFrame,
    struct _CONTEXT *ContextRecord,
    void *DispatcherContext)
{
    __asm__ __volatile__ (
            "jmp dorenamefile_reentry");
    return 0; /* Function does not return */
}
#endif /* HAVE_NO_SEH */
#endif /* !__CYGWIN__ */
d416 1
a416 1
 * TclpObjCopyFile, DoCopyFile --
d441 3
a443 3
TclpObjCopyFile(srcPathPtr, destPathPtr)
    Tcl_Obj *srcPathPtr;
    Tcl_Obj *destPathPtr;
d445 9
a453 2
    return DoCopyFile(Tcl_FSGetNativePath(srcPathPtr),
		      Tcl_FSGetNativePath(destPathPtr));
d458 2
a459 2
   CONST TCHAR *nativeSrc,	/* Pathname of file to be copied (native). */
   CONST TCHAR *nativeDst)	/* Pathname of file to copy to (native). */
d461 1
a461 1
    int retval = -1;
d463 2
a464 4
    /*
     * The CopyFile API acts differently under Win95/98 and NT
     * WRT NULL and "". Avoid passing these values.
     */
a465 6
    if (nativeSrc == NULL || nativeSrc[0] == '\0' ||
        nativeDst == NULL || nativeDst[0] == '\0') {
	Tcl_SetErrno(ENOENT);
	return TCL_ERROR;
    }
    
d467 2
a468 2
     * The CopyFile API would throw an exception under NT if one
     * of the arguments is a char block device.
d471 2
a472 11
#ifndef __CYGWIN__
#ifdef HAVE_NO_SEH
    __asm__ __volatile__ (
            "movl  %esp, _ESP" "\n\t"
            "movl  %ebp, _EBP");

    __asm__ __volatile__ (
            "pushl $__except_docopyfile_handler" "\n\t"
            "pushl %fs:0" "\n\t"
            "mov   %esp, %fs:0");
#else
a473 2
#endif /* HAVE_NO_SEH */
#endif /* !__CYGWIN__ */
d475 4
a478 1
	    retval = TCL_OK;
d480 4
a483 23
#ifndef __CYGWIN__
#ifdef HAVE_NO_SEH
    __asm__ __volatile__ (
            "jmp   docopyfile_pop" "\n"
            "docopyfile_reentry:" "\n\t"
            "movl  _ESP, %esp" "\n\t"
            "movl  _EBP, %ebp");

    __asm__ __volatile__ (
            "docopyfile_pop:" "\n\t"
            "mov   (%esp), %eax" "\n\t"
            "mov   %eax, %fs:0" "\n\t"
            "add   $8, %esp");
#else
    } __except (EXCEPTION_EXECUTE_HANDLER) {}
#endif /* HAVE_NO_SEH */
#endif /* !__CYGWIN__ */

    /*
     * Avoid using control flow statements in the SEH guarded block!
     */
    if (retval != -1)
        return retval;
a500 6
		if (srcAttr & FILE_ATTRIBUTE_REPARSE_POINT) {
		    /* Source is a symbolic link -- copy it */
		    if (TclWinSymLinkCopyDirectory(nativeSrc, nativeDst) == 0) {
		        return TCL_OK;
		    }
		}
a520 17
#ifndef __CYGWIN__
#ifdef HAVE_NO_SEH
static
__attribute__ ((cdecl))
EXCEPTION_DISPOSITION
_except_docopyfile_handler(
    struct _EXCEPTION_RECORD *ExceptionRecord,
    void *EstablisherFrame,
    struct _CONTEXT *ContextRecord,
    void *DispatcherContext)
{
    __asm__ __volatile__ (
            "jmp docopyfile_reentry");
    return 0; /* Function does not return */
}
#endif /* HAVE_NO_SEH */
#endif /* __CYGWIN__ */
d525 1
a525 1
 * TclpObjDeleteFile, DoDeleteFile --
d547 3
a549 3
int 
TclpObjDeleteFile(pathPtr)
    Tcl_Obj *pathPtr;
d551 7
a557 1
    return DoDeleteFile(Tcl_FSGetNativePath(pathPtr));
d562 1
a562 1
    CONST TCHAR *nativePath)	/* Pathname of file to be removed (native). */
d565 1
d567 2
a568 10
    /*
     * The DeleteFile API acts differently under Win95/98 and NT
     * WRT NULL and "". Avoid passing these values.
     */

    if (nativePath == NULL || nativePath[0] == '\0') {
	Tcl_SetErrno(ENOENT);
	return TCL_ERROR;
    }

d574 16
d594 1
a594 10
		if (attr & FILE_ATTRIBUTE_REPARSE_POINT) {
		    /* It is a symbolic link -- remove it */
		    if (TclWinSymLinkDelete(nativePath, 0) == 0) {
		        return TCL_OK;
		    }
		}
		
		/* 
		 * If we fall through here, it is a directory.
		 * 
d601 1
a601 1
		int res = (*tclWinProcs->setFileAttributesProc)(nativePath, 
d603 1
a603 2
		if ((res != 0) && ((*tclWinProcs->deleteFileProc)(nativePath)
			!= FALSE)) {
d607 1
a607 3
		if (res != 0) {
		    (*tclWinProcs->setFileAttributesProc)(nativePath, attr);
		}
d637 1
a637 1
 * TclpObjCreateDirectory --
d659 3
a661 3
int 
TclpObjCreateDirectory(pathPtr)
    Tcl_Obj *pathPtr;
d663 7
a669 1
    return DoCreateDirectory(Tcl_FSGetNativePath(pathPtr));
d674 1
a674 1
    CONST TCHAR *nativePath)	/* Pathname of directory to create (native). */
d677 3
d691 1
a691 1
 * TclpObjCopyDirectory --
d714 8
a721 5
int 
TclpObjCopyDirectory(srcPathPtr, destPathPtr, errorPtr)
    Tcl_Obj *srcPathPtr;
    Tcl_Obj *destPathPtr;
    Tcl_Obj **errorPtr;
d723 1
a723 1
    Tcl_DString ds;
a724 1
    int ret;
d726 2
a727 4
    Tcl_WinUtfToTChar(Tcl_FSGetTranslatedStringPath(NULL,srcPathPtr), 
		      -1, &srcString);
    Tcl_WinUtfToTChar(Tcl_FSGetTranslatedStringPath(NULL,destPathPtr), 
		      -1, &dstString);
d729 1
a729 1
    ret = TraverseWinTree(TraversalCopy, &srcString, &dstString, &ds);
d733 1
a733 7

    if (ret != TCL_OK) {
	*errorPtr = Tcl_NewStringObj(Tcl_DStringValue(&ds), -1);
	Tcl_DStringFree(&ds);
	Tcl_IncrRefCount(*errorPtr);
    }
    return ret;
d739 1
a739 1
 * TclpObjRemoveDirectory, DoRemoveDirectory -- 
d765 10
a774 5
int 
TclpObjRemoveDirectory(pathPtr, recursive, errorPtr)
    Tcl_Obj *pathPtr;
    int recursive;
    Tcl_Obj **errorPtr;
d776 8
a783 26
    Tcl_DString ds;
    int ret;
    if (recursive) {
	/* 
	 * In the recursive case, the string rep is used to construct a
	 * Tcl_DString which may be used extensively, so we can't
	 * optimize this case easily.
	 */
	Tcl_DString native;
	Tcl_WinUtfToTChar(Tcl_FSGetTranslatedStringPath(NULL, pathPtr), 
			  -1, &native);
	ret = DoRemoveDirectory(&native, recursive, &ds);
	Tcl_DStringFree(&native);
    } else {
	ret = DoRemoveJustDirectory(Tcl_FSGetNativePath(pathPtr), 
				    0, &ds);
    }
    if (ret != TCL_OK) {
	int len = Tcl_DStringLength(&ds);
	if (len > 0) {
	    *errorPtr = Tcl_NewStringObj(Tcl_DStringValue(&ds), -1);
	    Tcl_IncrRefCount(*errorPtr);
	}
	Tcl_DStringFree(&ds);
    }
    return ret;
d787 2
a788 2
DoRemoveJustDirectory(
    CONST TCHAR *nativePath,	/* Pathname of directory to be removed
d790 3
a792 3
    int ignoreError,		/* If non-zero, don't initialize the
                  		 * errorPtr under some circumstances
                  		 * on return. */
d797 2
a798 4
    /*
     * The RemoveDirectory API acts differently under Win95/98 and NT
     * WRT NULL and "". Avoid passing these values.
     */
d800 1
a800 4
    if (nativePath == NULL || nativePath[0] == '\0') {
	Tcl_SetErrno(ENOENT);
	goto end;
    }
d807 17
d825 1
a825 1
	DWORD attr = (*tclWinProcs->getFileAttributesProc)(nativePath);
a836 7
	    if (attr & FILE_ATTRIBUTE_REPARSE_POINT) {
		/* It is a symbolic link -- remove it */
		if (TclWinSymLinkDelete(nativePath, 1) != 0) {
		    goto end;
		}
	    }
	    
d857 1
a857 1
		CONST char *path, *find;
d863 1
a863 1
		path = (CONST char *) nativePath;
d902 4
a905 5
    if ((ignoreError != 0) && (Tcl_GetErrno() == EEXIST)) {
	/* 
	 * If we're being recursive, this error may actually
	 * be ok, so we don't want to initialise the errorPtr
	 * yet.
d907 2
a908 1
	return TCL_ERROR;
d910 1
a910 1

a915 26

}

static int
DoRemoveDirectory(
    Tcl_DString *pathPtr,	/* Pathname of directory to be removed
				 * (native). */
    int recursive,		/* If non-zero, removes directories that
				 * are nonempty.  Otherwise, will only remove
				 * empty directories. */
    Tcl_DString *errorPtr)	/* If non-NULL, uninitialized or free
				 * DString filled with UTF-8 name of file
				 * causing error. */
{
    int res = DoRemoveJustDirectory(Tcl_DStringValue(pathPtr), recursive, 
				    errorPtr);
    
    if ((res == TCL_ERROR) && (recursive != 0) && (Tcl_GetErrno() == EEXIST)) {
	/*
	 * The directory is nonempty, but the recursive flag has been
	 * specified, so we recursively remove all the files in the directory.
	 */
	return TraverseWinTree(TraversalDelete, pathPtr, NULL, errorPtr);
    } else {
	return res;
    }
d947 1
a947 2
				 * parallel with source directory (native),
				 * may be NULL. */
d953 1
a953 1
    TCHAR *nativeSource, *nativeTarget, *nativeErrfile;
a962 2
    nativeTarget = (TCHAR *) (targetPtr == NULL ? NULL : Tcl_DStringValue(targetPtr));
    
d974 1
a974 1
	return (*traverseProc)(nativeSource, nativeTarget, DOTREE_F, errorPtr);
d997 1
a997 1
    result = (*traverseProc)(nativeSource, nativeTarget, DOTREE_PRED, errorPtr);
d1099 2
a1100 3
	result = (*traverseProc)(Tcl_DStringValue(sourcePtr), 
			(targetPtr == NULL ? NULL : Tcl_DStringValue(targetPtr)), 
			DOTREE_POSTD, errorPtr);
d1133 2
a1134 2
    CONST TCHAR *nativeSrc,	/* Source pathname to copy. */
    CONST TCHAR *nativeDst,	/* Destination pathname of copy. */
d1139 3
d1144 1
a1144 1
	    if (DoCopyFile(nativeSrc, nativeDst) == TCL_OK) {
d1150 4
a1153 2
	    if (DoCreateDirectory(nativeDst) == TCL_OK) {
		DWORD attr = (*tclWinProcs->getFileAttributesProc)(nativeSrc);
d1172 1
d1201 2
a1202 2
    CONST TCHAR *nativeSrc,	/* Source pathname to delete. */
    CONST TCHAR *dstPtr,	/* Not used. */
d1207 2
d1211 1
a1211 1
	    if (DoDeleteFile(nativeSrc) == TCL_OK) {
d1220 1
a1220 1
	    if (DoRemoveJustDirectory(nativeSrc, 0, NULL) == TCL_OK) {
d1228 1
d1254 1
a1254 1
    Tcl_Obj *fileName)	        /* The name of the file which caused the 
d1259 2
a1260 3
			   "could not read \"", Tcl_GetString(fileName), 
			   "\": ", Tcl_PosixError(interp), 
			   (char *) NULL);
d1286 1
a1286 1
    Tcl_Obj *fileName,	        /* The name of the file. */
d1290 4
a1293 4
    CONST TCHAR *nativeName;
    int attr;
    
    nativeName = Tcl_FSGetNativePath(fileName);
d1295 1
d1302 1
a1302 28
    attr = (int)(result & attributeArray[objIndex]);
    if ((objIndex == WIN_HIDDEN_ATTRIBUTE) && (attr != 0)) {
	/* 
	 * It is hidden.  However there is a bug on some Windows
	 * OSes in which root volumes (drives) formatted as NTFS
	 * are declared hidden when they are not (and cannot be).
	 * 
	 * We test for, and fix that case, here.
	 */
	int len;
	char *str = Tcl_GetStringFromObj(fileName,&len);
	if (len < 4) {
	    if (len == 0) {
		/* 
		 * Not sure if this is possible, but we pass it on
		 * anyway 
		 */
	    } else if (len == 1 && (str[0] == '/' || str[0] == '\\')) {
		/* Path is pointing to the root volume */
		attr = 0;
	    } else if ((str[1] == ':') 
		       && (len == 2 || (str[2] == '/' || str[2] == '\\'))) {
		/* Path is of the form 'x:' or 'x:/' or 'x:\' */
		attr = 0;
	    }
	}
    }
    *attributePtrPtr = Tcl_NewBooleanObj(attr);
a1317 5
 *	
 *	Warning: if you pass this function a drive name like 'c:' it
 *	will actually return the current working directory on that
 *	drive.  To avoid this, make sure the drive name ends in a
 *	slash, like this 'c:/'.
d1329 1
a1329 1
    Tcl_Obj *fileName,   	/* The name of the file. */
d1334 3
a1336 1
    Tcl_Obj *splitPath;
d1339 2
a1340 1
    splitPath = Tcl_FSSplitPath(fileName, &pathc);
d1342 3
a1344 4
    if (splitPath == NULL || pathc == 0) {
	if (interp != NULL) {
	    Tcl_AppendStringsToObj(Tcl_GetObjResult(interp), 
		"could not read \"", Tcl_GetString(fileName),
a1346 1
	}
d1352 4
a1355 10
	Tcl_Obj *elt;
	char *pathv;
	int pathLen;
	Tcl_ListObjIndex(NULL, splitPath, i, &elt);
	
	pathv = Tcl_GetStringFromObj(elt, &pathLen);
	if ((pathv[0] == '/')
		|| ((pathLen == 3) && (pathv[1] == ':'))
		|| (strcmp(pathv, ".") == 0)
		|| (strcmp(pathv, "..") == 0)) {
d1363 3
a1365 4
	    /* Here we are modifying the string representation in place */
	    /* I believe this is legal, since this won't affect any 
	     * file representation this thing may have. */
	    pathv[0] = (char) Tcl_UniCharToUpper(UCHAR(pathv[0]));
d1367 2
a1368 1
	    Tcl_Obj *tempPath;
a1369 4
	    Tcl_DString dsTemp;
	    TCHAR *nativeName;
	    char *tempString;
	    int tempLen;
d1374 3
a1376 10
	    tempPath = Tcl_FSJoinPath(splitPath, i+1);
	    Tcl_IncrRefCount(tempPath);
	    /* 
	     * We'd like to call Tcl_FSGetNativePath(tempPath)
	     * but that is likely to lead to infinite loops 
	     */
	    Tcl_DStringInit(&ds);
	    tempString = Tcl_GetStringFromObj(tempPath,&tempLen);
	    nativeName = Tcl_WinUtfToTChar(tempString, tempLen, &ds);
	    Tcl_DecrRefCount(tempPath);
d1389 2
d1394 2
d1398 2
a1399 4
		Tcl_DStringFree(&ds);
		if (interp != NULL) {
		    StatError(interp, fileName);
		}
d1439 3
a1441 12
	    Tcl_DStringInit(&dsTemp);
	    Tcl_WinTCharToUtf(nativeName, -1, &dsTemp);
	    /* Deal with issues of tildes being absolute */
	    if (Tcl_DStringValue(&dsTemp)[0] == '~') {
		tempPath = Tcl_NewStringObj("./",2);
		Tcl_AppendToObj(tempPath, Tcl_DStringValue(&dsTemp), 
				Tcl_DStringLength(&dsTemp));
	    } else {
		tempPath = Tcl_NewStringObj(Tcl_DStringValue(&dsTemp), 
					    Tcl_DStringLength(&dsTemp));
	    }
	    Tcl_ListObjReplace(NULL, splitPath, i, 1, 1, &tempPath);
a1442 1
	    Tcl_DStringFree(&dsTemp);
d1447 5
a1451 1
    *attributePtrPtr = Tcl_FSJoinPath(splitPath, -1);
d1454 2
a1455 2
    if (splitPath != NULL) {
	Tcl_DecrRefCount(splitPath);
d1457 2
a1458 1
  
d1467 1
a1467 1
 *      Returns a Tcl_Obj containing the long version of the file
d1485 1
a1485 1
    Tcl_Obj *fileName,  	/* The name of the file. */
d1514 1
a1514 1
    Tcl_Obj *fileName,  	/* The name of the file. */
d1541 1
a1541 1
    Tcl_Obj *fileName,  	/* The name of the file. */
d1547 2
a1548 1
    CONST TCHAR *nativeName;
d1550 1
a1550 1
    nativeName = Tcl_FSGetNativePath(fileName);
d1555 2
a1556 1
	return TCL_ERROR;
d1561 1
a1561 1
	return result;
d1572 2
a1573 1
	return TCL_ERROR;
d1576 3
d1594 1
a1594 1
 *      The object result is set to a pertinent error message.
d1603 1
a1603 1
    Tcl_Obj *fileName,	        /* The name of the file. */
d1608 1
a1608 2
	    "\" for file \"", Tcl_GetString(fileName), 
	    "\": attribute is readonly", 
d1617 1
a1617 1
 * TclpObjListVolumes --
d1622 3
a1624 1
 *	The list of volumes.
d1632 3
a1634 2
Tcl_Obj*
TclpObjListVolumes(void)
d1641 1
a1641 1
    resultPtr = Tcl_NewObj();
d1678 1
a1678 3
    
    Tcl_IncrRefCount(resultPtr);
    return resultPtr;
d1680 3
@


1.2
log
@touched all Tcl files to ease next import.
@
text
@@


1.2.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.2.16.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d31 1
a31 1
			    int objIndex, Tcl_Obj *fileName,
d34 1
a34 1
			    int objIndex, Tcl_Obj *fileName,
d37 1
a37 1
			    int objIndex, Tcl_Obj *fileName,
d40 1
a40 1
			    int objIndex, Tcl_Obj *fileName,
d43 1
a43 1
			    int objIndex, Tcl_Obj *fileName,
d63 1
a63 1
CONST char *tclpFileAttrStrings[] = {
d68 1
a68 1
CONST TclFileAttrProcs tclpFileAttrProcs[] = {
a75 5
#ifdef HAVE_NO_SEH
static void *ESP;
static void *EBP;
#endif /* HAVE_NO_SEH */

d80 1
a80 1
typedef int (TraversalProc)(CONST TCHAR *srcPtr, CONST TCHAR *dstPtr, 
d87 1
a87 1
static void		StatError(Tcl_Interp *interp, Tcl_Obj *fileName);
d89 1
a89 1
			    int objIndex, Tcl_Obj *fileName, int longShort,
d91 3
a93 5
static int		DoCopyFile(CONST TCHAR *srcPtr, CONST TCHAR *dstPtr);
static int		DoCreateDirectory(CONST TCHAR *pathPtr);
static int		DoDeleteFile(CONST TCHAR *pathPtr);
static int		DoRemoveJustDirectory(CONST TCHAR *nativeSrc, 
			    int ignoreError, Tcl_DString *errorPtr);
d96 2
a97 2
static int		DoRenameFile(CONST TCHAR *nativeSrc, CONST TCHAR *dstPtr);
static int		TraversalCopy(CONST TCHAR *srcPtr, CONST TCHAR *dstPtr, 
d99 1
a99 1
static int		TraversalDelete(CONST TCHAR *srcPtr, CONST TCHAR *dstPtr, 
d109 1
a109 1
 * TclpObjRenameFile, DoRenameFile --
d148 6
a153 4
int 
TclpObjRenameFile(srcPathPtr, destPathPtr)
    Tcl_Obj *srcPathPtr;
    Tcl_Obj *destPathPtr;
d155 11
a165 2
    return DoRenameFile(Tcl_FSGetNativePath(srcPathPtr), 
			Tcl_FSGetNativePath(destPathPtr));
d172 1
a172 1
    CONST TCHAR *nativeDst)	/* New pathname for file or directory
d175 1
a176 1
    int retval = -1;
d178 1
a178 10
    /*
     * The MoveFile API acts differently under Win95/98 and NT
     * WRT NULL and "". Avoid passing these values.
     */

    if (nativeSrc == NULL || nativeSrc[0] == '\0' ||
        nativeDst == NULL || nativeDst[0] == '\0') {
	Tcl_SetErrno(ENOENT);
	return TCL_ERROR;
    }
d181 2
a182 2
     * The MoveFile API would throw an exception under NT
     * if one of the arguments is a char block device.
d185 2
a186 10
#ifdef HAVE_NO_SEH
    __asm__ __volatile__ (
            "movl  %esp, _ESP" "\n\t"
            "movl  %ebp, _EBP");

    __asm__ __volatile__ (
            "pushl $__except_dorenamefile_handler" "\n\t"
            "pushl %fs:0" "\n\t"
            "mov   %esp, %fs:0");
#else
d188 1
a188 1
#endif /* HAVE_NO_SEH */
d190 1
a190 1
	    retval = TCL_OK;
d192 5
a196 21
#ifdef HAVE_NO_SEH
    __asm__ __volatile__ (
            "jmp   dorenamefile_pop" "\n"
            "dorenamefile_reentry:" "\n\t"
            "movl  _ESP, %esp" "\n\t"
            "movl  _EBP, %ebp");

    __asm__ __volatile__ (
            "dorenamefile_pop:" "\n\t"
            "mov   (%esp), %eax" "\n\t"
            "mov   %eax, %fs:0" "\n\t"
            "add   $8, %esp");
#else
    } __except (EXCEPTION_EXECUTE_HANDLER) {}
#endif /* HAVE_NO_SEH */

    /*
     * Avoid using control flow statements in the SEH guarded block!
     */
    if (retval != -1)
        return retval;
d310 1
a310 1
		if (DoRemoveJustDirectory(nativeDst, 0, NULL) == TCL_OK) {
a411 15
#ifdef HAVE_NO_SEH
static
__attribute__ ((cdecl))
EXCEPTION_DISPOSITION
_except_dorenamefile_handler(
    struct _EXCEPTION_RECORD *ExceptionRecord,
    void *EstablisherFrame,
    struct _CONTEXT *ContextRecord,
    void *DispatcherContext)
{
    __asm__ __volatile__ (
            "jmp dorenamefile_reentry");
    return 0; /* Function does not return */
}
#endif /* HAVE_NO_SEH */
d416 1
a416 1
 * TclpObjCopyFile, DoCopyFile --
d441 3
a443 3
TclpObjCopyFile(srcPathPtr, destPathPtr)
    Tcl_Obj *srcPathPtr;
    Tcl_Obj *destPathPtr;
d445 9
a453 2
    return DoCopyFile(Tcl_FSGetNativePath(srcPathPtr),
		      Tcl_FSGetNativePath(destPathPtr));
d458 2
a459 2
   CONST TCHAR *nativeSrc,	/* Pathname of file to be copied (native). */
   CONST TCHAR *nativeDst)	/* Pathname of file to copy to (native). */
d461 1
a461 1
    int retval = -1;
d463 2
a464 4
    /*
     * The CopyFile API acts differently under Win95/98 and NT
     * WRT NULL and "". Avoid passing these values.
     */
a465 6
    if (nativeSrc == NULL || nativeSrc[0] == '\0' ||
        nativeDst == NULL || nativeDst[0] == '\0') {
	Tcl_SetErrno(ENOENT);
	return TCL_ERROR;
    }
    
d467 2
a468 2
     * The CopyFile API would throw an exception under NT if one
     * of the arguments is a char block device.
d471 2
a472 10
#ifdef HAVE_NO_SEH
    __asm__ __volatile__ (
            "movl  %esp, _ESP" "\n\t"
            "movl  %ebp, _EBP");

    __asm__ __volatile__ (
            "pushl $__except_docopyfile_handler" "\n\t"
            "pushl %fs:0" "\n\t"
            "mov   %esp, %fs:0");
#else
a473 1
#endif /* HAVE_NO_SEH */
d475 4
a478 1
	    retval = TCL_OK;
d480 4
a483 21
#ifdef HAVE_NO_SEH
    __asm__ __volatile__ (
            "jmp   docopyfile_pop" "\n"
            "docopyfile_reentry:" "\n\t"
            "movl  _ESP, %esp" "\n\t"
            "movl  _EBP, %ebp");

    __asm__ __volatile__ (
            "docopyfile_pop:" "\n\t"
            "mov   (%esp), %eax" "\n\t"
            "mov   %eax, %fs:0" "\n\t"
            "add   $8, %esp");
#else
    } __except (EXCEPTION_EXECUTE_HANDLER) {}
#endif /* HAVE_NO_SEH */

    /*
     * Avoid using control flow statements in the SEH guarded block!
     */
    if (retval != -1)
        return retval;
a500 6
		if (srcAttr & FILE_ATTRIBUTE_REPARSE_POINT) {
		    /* Source is a symbolic link -- copy it */
		    if (TclWinSymLinkCopyDirectory(nativeSrc, nativeDst) == 0) {
		        return TCL_OK;
		    }
		}
a520 15
#ifdef HAVE_NO_SEH
static
__attribute__ ((cdecl))
EXCEPTION_DISPOSITION
_except_docopyfile_handler(
    struct _EXCEPTION_RECORD *ExceptionRecord,
    void *EstablisherFrame,
    struct _CONTEXT *ContextRecord,
    void *DispatcherContext)
{
    __asm__ __volatile__ (
            "jmp docopyfile_reentry");
    return 0; /* Function does not return */
}
#endif /* HAVE_NO_SEH */
d525 1
a525 1
 * TclpObjDeleteFile, DoDeleteFile --
d547 3
a549 3
int 
TclpObjDeleteFile(pathPtr)
    Tcl_Obj *pathPtr;
d551 7
a557 1
    return DoDeleteFile(Tcl_FSGetNativePath(pathPtr));
d562 1
a562 1
    CONST TCHAR *nativePath)	/* Pathname of file to be removed (native). */
d565 1
d567 2
a568 10
    /*
     * The DeleteFile API acts differently under Win95/98 and NT
     * WRT NULL and "". Avoid passing these values.
     */

    if (nativePath == NULL || nativePath[0] == '\0') {
	Tcl_SetErrno(ENOENT);
	return TCL_ERROR;
    }

d574 16
d594 1
a594 10
		if (attr & FILE_ATTRIBUTE_REPARSE_POINT) {
		    /* It is a symbolic link -- remove it */
		    if (TclWinSymLinkDelete(nativePath, 0) == 0) {
		        return TCL_OK;
		    }
		}
		
		/* 
		 * If we fall through here, it is a directory.
		 * 
d601 1
a601 1
		int res = (*tclWinProcs->setFileAttributesProc)(nativePath, 
d603 1
a603 2
		if ((res != 0) && ((*tclWinProcs->deleteFileProc)(nativePath)
			!= FALSE)) {
d607 1
a607 3
		if (res != 0) {
		    (*tclWinProcs->setFileAttributesProc)(nativePath, attr);
		}
d637 1
a637 1
 * TclpObjCreateDirectory --
d659 3
a661 3
int 
TclpObjCreateDirectory(pathPtr)
    Tcl_Obj *pathPtr;
d663 7
a669 1
    return DoCreateDirectory(Tcl_FSGetNativePath(pathPtr));
d674 1
a674 1
    CONST TCHAR *nativePath)	/* Pathname of directory to create (native). */
d677 3
d691 1
a691 1
 * TclpObjCopyDirectory --
d714 8
a721 5
int 
TclpObjCopyDirectory(srcPathPtr, destPathPtr, errorPtr)
    Tcl_Obj *srcPathPtr;
    Tcl_Obj *destPathPtr;
    Tcl_Obj **errorPtr;
d723 1
a723 1
    Tcl_DString ds;
a724 1
    int ret;
d726 2
a727 4
    Tcl_WinUtfToTChar(Tcl_FSGetTranslatedStringPath(NULL,srcPathPtr), 
		      -1, &srcString);
    Tcl_WinUtfToTChar(Tcl_FSGetTranslatedStringPath(NULL,destPathPtr), 
		      -1, &dstString);
d729 1
a729 1
    ret = TraverseWinTree(TraversalCopy, &srcString, &dstString, &ds);
d733 1
a733 7

    if (ret != TCL_OK) {
	*errorPtr = Tcl_NewStringObj(Tcl_DStringValue(&ds), -1);
	Tcl_DStringFree(&ds);
	Tcl_IncrRefCount(*errorPtr);
    }
    return ret;
d739 1
a739 1
 * TclpObjRemoveDirectory, DoRemoveDirectory -- 
d765 10
a774 5
int 
TclpObjRemoveDirectory(pathPtr, recursive, errorPtr)
    Tcl_Obj *pathPtr;
    int recursive;
    Tcl_Obj **errorPtr;
d776 8
a783 26
    Tcl_DString ds;
    int ret;
    if (recursive) {
	/* 
	 * In the recursive case, the string rep is used to construct a
	 * Tcl_DString which may be used extensively, so we can't
	 * optimize this case easily.
	 */
	Tcl_DString native;
	Tcl_WinUtfToTChar(Tcl_FSGetTranslatedStringPath(NULL, pathPtr), 
			  -1, &native);
	ret = DoRemoveDirectory(&native, recursive, &ds);
	Tcl_DStringFree(&native);
    } else {
	ret = DoRemoveJustDirectory(Tcl_FSGetNativePath(pathPtr), 
				    0, &ds);
    }
    if (ret != TCL_OK) {
	int len = Tcl_DStringLength(&ds);
	if (len > 0) {
	    *errorPtr = Tcl_NewStringObj(Tcl_DStringValue(&ds), -1);
	    Tcl_IncrRefCount(*errorPtr);
	}
	Tcl_DStringFree(&ds);
    }
    return ret;
d787 2
a788 2
DoRemoveJustDirectory(
    CONST TCHAR *nativePath,	/* Pathname of directory to be removed
d790 3
a792 3
    int ignoreError,		/* If non-zero, don't initialize the
                  		 * errorPtr under some circumstances
                  		 * on return. */
d797 2
a798 4
    /*
     * The RemoveDirectory API acts differently under Win95/98 and NT
     * WRT NULL and "". Avoid passing these values.
     */
d800 1
a800 4
    if (nativePath == NULL || nativePath[0] == '\0') {
	Tcl_SetErrno(ENOENT);
	goto end;
    }
d807 17
d825 1
a825 1
	DWORD attr = (*tclWinProcs->getFileAttributesProc)(nativePath);
a836 7
	    if (attr & FILE_ATTRIBUTE_REPARSE_POINT) {
		/* It is a symbolic link -- remove it */
		if (TclWinSymLinkDelete(nativePath, 1) != 0) {
		    goto end;
		}
	    }
	    
d857 1
a857 1
		CONST char *path, *find;
d863 1
a863 1
		path = (CONST char *) nativePath;
d902 4
a905 5
    if ((ignoreError != 0) && (Tcl_GetErrno() == EEXIST)) {
	/* 
	 * If we're being recursive, this error may actually
	 * be ok, so we don't want to initialise the errorPtr
	 * yet.
d907 2
a908 1
	return TCL_ERROR;
d910 1
a910 1

a915 26

}

static int
DoRemoveDirectory(
    Tcl_DString *pathPtr,	/* Pathname of directory to be removed
				 * (native). */
    int recursive,		/* If non-zero, removes directories that
				 * are nonempty.  Otherwise, will only remove
				 * empty directories. */
    Tcl_DString *errorPtr)	/* If non-NULL, uninitialized or free
				 * DString filled with UTF-8 name of file
				 * causing error. */
{
    int res = DoRemoveJustDirectory(Tcl_DStringValue(pathPtr), recursive, 
				    errorPtr);
    
    if ((res == TCL_ERROR) && (recursive != 0) && (Tcl_GetErrno() == EEXIST)) {
	/*
	 * The directory is nonempty, but the recursive flag has been
	 * specified, so we recursively remove all the files in the directory.
	 */
	return TraverseWinTree(TraversalDelete, pathPtr, NULL, errorPtr);
    } else {
	return res;
    }
d947 1
a947 2
				 * parallel with source directory (native),
				 * may be NULL. */
d953 1
a953 1
    TCHAR *nativeSource, *nativeTarget, *nativeErrfile;
a962 2
    nativeTarget = (TCHAR *) (targetPtr == NULL ? NULL : Tcl_DStringValue(targetPtr));
    
d974 1
a974 1
	return (*traverseProc)(nativeSource, nativeTarget, DOTREE_F, errorPtr);
d997 1
a997 1
    result = (*traverseProc)(nativeSource, nativeTarget, DOTREE_PRED, errorPtr);
d1099 2
a1100 3
	result = (*traverseProc)(Tcl_DStringValue(sourcePtr), 
			(targetPtr == NULL ? NULL : Tcl_DStringValue(targetPtr)), 
			DOTREE_POSTD, errorPtr);
d1133 2
a1134 2
    CONST TCHAR *nativeSrc,	/* Source pathname to copy. */
    CONST TCHAR *nativeDst,	/* Destination pathname of copy. */
d1139 3
d1144 1
a1144 1
	    if (DoCopyFile(nativeSrc, nativeDst) == TCL_OK) {
d1150 4
a1153 2
	    if (DoCreateDirectory(nativeDst) == TCL_OK) {
		DWORD attr = (*tclWinProcs->getFileAttributesProc)(nativeSrc);
d1172 1
d1201 2
a1202 2
    CONST TCHAR *nativeSrc,	/* Source pathname to delete. */
    CONST TCHAR *dstPtr,	/* Not used. */
d1207 2
d1211 1
a1211 1
	    if (DoDeleteFile(nativeSrc) == TCL_OK) {
d1220 1
a1220 1
	    if (DoRemoveJustDirectory(nativeSrc, 0, NULL) == TCL_OK) {
d1228 1
d1254 1
a1254 1
    Tcl_Obj *fileName)	        /* The name of the file which caused the 
d1259 2
a1260 3
			   "could not read \"", Tcl_GetString(fileName), 
			   "\": ", Tcl_PosixError(interp), 
			   (char *) NULL);
d1286 1
a1286 1
    Tcl_Obj *fileName,	        /* The name of the file. */
d1290 4
a1293 4
    CONST TCHAR *nativeName;
    int attr;
    
    nativeName = Tcl_FSGetNativePath(fileName);
d1295 1
d1302 1
a1302 28
    attr = (int)(result & attributeArray[objIndex]);
    if ((objIndex == WIN_HIDDEN_ATTRIBUTE) && (attr != 0)) {
	/* 
	 * It is hidden.  However there is a bug on some Windows
	 * OSes in which root volumes (drives) formatted as NTFS
	 * are declared hidden when they are not (and cannot be).
	 * 
	 * We test for, and fix that case, here.
	 */
	int len;
	char *str = Tcl_GetStringFromObj(fileName,&len);
	if (len < 4) {
	    if (len == 0) {
		/* 
		 * Not sure if this is possible, but we pass it on
		 * anyway 
		 */
	    } else if (len == 1 && (str[0] == '/' || str[0] == '\\')) {
		/* Path is pointing to the root volume */
		attr = 0;
	    } else if ((str[1] == ':') 
		       && (len == 2 || (str[2] == '/' || str[2] == '\\'))) {
		/* Path is of the form 'x:' or 'x:/' or 'x:\' */
		attr = 0;
	    }
	}
    }
    *attributePtrPtr = Tcl_NewBooleanObj(attr);
a1317 5
 *	
 *	Warning: if you pass this function a drive name like 'c:' it
 *	will actually return the current working directory on that
 *	drive.  To avoid this, make sure the drive name ends in a
 *	slash, like this 'c:/'.
d1329 1
a1329 1
    Tcl_Obj *fileName,   	/* The name of the file. */
d1334 3
a1336 1
    Tcl_Obj *splitPath;
d1339 2
a1340 1
    splitPath = Tcl_FSSplitPath(fileName, &pathc);
d1342 3
a1344 4
    if (splitPath == NULL || pathc == 0) {
	if (interp != NULL) {
	    Tcl_AppendStringsToObj(Tcl_GetObjResult(interp), 
		"could not read \"", Tcl_GetString(fileName),
a1346 1
	}
d1352 4
a1355 10
	Tcl_Obj *elt;
	char *pathv;
	int pathLen;
	Tcl_ListObjIndex(NULL, splitPath, i, &elt);
	
	pathv = Tcl_GetStringFromObj(elt, &pathLen);
	if ((pathv[0] == '/')
		|| ((pathLen == 3) && (pathv[1] == ':'))
		|| (strcmp(pathv, ".") == 0)
		|| (strcmp(pathv, "..") == 0)) {
d1363 3
a1365 4
	    /* Here we are modifying the string representation in place */
	    /* I believe this is legal, since this won't affect any 
	     * file representation this thing may have. */
	    pathv[0] = (char) Tcl_UniCharToUpper(UCHAR(pathv[0]));
d1367 2
a1368 1
	    Tcl_Obj *tempPath;
a1369 4
	    Tcl_DString dsTemp;
	    TCHAR *nativeName;
	    char *tempString;
	    int tempLen;
d1374 3
a1376 10
	    tempPath = Tcl_FSJoinPath(splitPath, i+1);
	    Tcl_IncrRefCount(tempPath);
	    /* 
	     * We'd like to call Tcl_FSGetNativePath(tempPath)
	     * but that is likely to lead to infinite loops 
	     */
	    Tcl_DStringInit(&ds);
	    tempString = Tcl_GetStringFromObj(tempPath,&tempLen);
	    nativeName = Tcl_WinUtfToTChar(tempString, tempLen, &ds);
	    Tcl_DecrRefCount(tempPath);
d1389 2
d1394 2
d1398 2
a1399 4
		Tcl_DStringFree(&ds);
		if (interp != NULL) {
		    StatError(interp, fileName);
		}
d1439 3
a1441 12
	    Tcl_DStringInit(&dsTemp);
	    Tcl_WinTCharToUtf(nativeName, -1, &dsTemp);
	    /* Deal with issues of tildes being absolute */
	    if (Tcl_DStringValue(&dsTemp)[0] == '~') {
		tempPath = Tcl_NewStringObj("./",2);
		Tcl_AppendToObj(tempPath, Tcl_DStringValue(&dsTemp), 
				Tcl_DStringLength(&dsTemp));
	    } else {
		tempPath = Tcl_NewStringObj(Tcl_DStringValue(&dsTemp), 
					    Tcl_DStringLength(&dsTemp));
	    }
	    Tcl_ListObjReplace(NULL, splitPath, i, 1, 1, &tempPath);
a1442 1
	    Tcl_DStringFree(&dsTemp);
d1447 5
a1451 1
    *attributePtrPtr = Tcl_FSJoinPath(splitPath, -1);
d1454 2
a1455 2
    if (splitPath != NULL) {
	Tcl_DecrRefCount(splitPath);
d1457 2
a1458 1
  
d1467 1
a1467 1
 *      Returns a Tcl_Obj containing the long version of the file
d1485 1
a1485 1
    Tcl_Obj *fileName,  	/* The name of the file. */
d1514 1
a1514 1
    Tcl_Obj *fileName,  	/* The name of the file. */
d1541 1
a1541 1
    Tcl_Obj *fileName,  	/* The name of the file. */
d1547 2
a1548 1
    CONST TCHAR *nativeName;
d1550 1
a1550 1
    nativeName = Tcl_FSGetNativePath(fileName);
d1555 2
a1556 1
	return TCL_ERROR;
d1561 1
a1561 1
	return result;
d1572 2
a1573 1
	return TCL_ERROR;
d1576 3
d1594 1
a1594 1
 *      The object result is set to a pertinent error message.
d1603 1
a1603 1
    Tcl_Obj *fileName,	        /* The name of the file. */
d1608 1
a1608 2
	    "\" for file \"", Tcl_GetString(fileName), 
	    "\": attribute is readonly", 
d1617 1
a1617 1
 * TclpObjListVolumes --
d1622 3
a1624 1
 *	The list of volumes.
d1632 3
a1634 2
Tcl_Obj*
TclpObjListVolumes(void)
d1641 1
a1641 1
    resultPtr = Tcl_NewObj();
d1678 1
a1678 3
    
    Tcl_IncrRefCount(resultPtr);
    return resultPtr;
d1680 3
@


1.2.16.3
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d76 4
a79 8
#if defined(HAVE_NO_SEH) && defined(TCL_MEM_DEBUG)
static void *INITIAL_ESP,
            *INITIAL_EBP,
            *INITIAL_HANDLER,
            *RESTORED_ESP,
            *RESTORED_EBP,
            *RESTORED_HANDLER;
#endif /* HAVE_NO_SEH && TCL_MEM_DEBUG */
d98 1
a190 1
# ifdef TCL_MEM_DEBUG
d192 2
a193 7
            "movl %%esp,  %0" "\n\t"
            "movl %%ebp,  %1" "\n\t"
            "movl %%fs:0, %2" "\n\t"
            : "=m"(INITIAL_ESP),
              "=m"(INITIAL_EBP),
              "=r"(INITIAL_HANDLER) );
# endif /* TCL_MEM_DEBUG */
a195 1
            "pushl %ebp" "\n\t"
d198 1
a198 1
            "movl  %esp, %fs:0");
d207 4
a210 12
            "jmp  dorenamefile_pop" "\n"
        "dorenamefile_reentry:" "\n\t"
            "movl %%fs:0, %%eax" "\n\t"
            "movl 0x8(%%eax), %%esp" "\n\t"
            "movl 0x8(%%esp), %%ebp" "\n"
        "dorenamefile_pop:" "\n\t"
            "movl (%%esp), %%eax" "\n\t"
            "movl %%eax, %%fs:0" "\n\t"
            "add  $12, %%esp" "\n\t"
            :
            :
            : "%eax");
a211 1
# ifdef TCL_MEM_DEBUG
d213 4
a216 14
            "movl  %%esp,  %0" "\n\t"
            "movl  %%ebp,  %1" "\n\t"
            "movl  %%fs:0, %2" "\n\t"
            : "=m"(RESTORED_ESP),
              "=m"(RESTORED_EBP),
              "=r"(RESTORED_HANDLER) );

    if (INITIAL_ESP != RESTORED_ESP)
        panic("ESP restored incorrectly");
    if (INITIAL_EBP != RESTORED_EBP)
        panic("EBP restored incorrectly");
    if (INITIAL_HANDLER != RESTORED_HANDLER)
        panic("HANDLER restored incorrectly");
# endif /* TCL_MEM_DEBUG */
d254 1
a254 1
	    CONST char **srcArgv, **dstArgv;
a452 2
    /* Nuke compiler warning about unused static function */
    _except_dorenamefile_handler(NULL, NULL, NULL, NULL);
a516 1
# ifdef TCL_MEM_DEBUG
d518 2
a519 7
            "movl %%esp,  %0" "\n\t"
            "movl %%ebp,  %1" "\n\t"
            "movl %%fs:0, %2" "\n\t"
            : "=m"(INITIAL_ESP),
              "=m"(INITIAL_EBP),
              "=r"(INITIAL_HANDLER) );
# endif /* TCL_MEM_DEBUG */
a521 1
            "pushl %ebp" "\n\t"
d524 1
a524 1
            "movl  %esp, %fs:0");
d533 4
a536 12
            "jmp  docopyfile_pop" "\n"
        "docopyfile_reentry:" "\n\t"
            "movl %%fs:0, %%eax" "\n\t"
            "movl 0x8(%%eax), %%esp" "\n\t"
            "movl 0x8(%%esp), %%ebp" "\n"
        "docopyfile_pop:" "\n\t"
            "movl (%%esp), %%eax" "\n\t"
            "movl %%eax, %%fs:0" "\n\t"
            "add  $12, %%esp" "\n\t"
            :
            :
            : "%eax");
a537 1
# ifdef TCL_MEM_DEBUG
d539 4
a542 14
            "movl  %%esp,  %0" "\n\t"
            "movl  %%ebp,  %1" "\n\t"
            "movl  %%fs:0, %2" "\n\t"
            : "=m"(RESTORED_ESP),
              "=m"(RESTORED_EBP),
              "=r"(RESTORED_HANDLER) );

    if (INITIAL_ESP != RESTORED_ESP)
        panic("ESP restored incorrectly");
    if (INITIAL_EBP != RESTORED_EBP)
        panic("EBP restored incorrectly");
    if (INITIAL_HANDLER != RESTORED_HANDLER)
        panic("HANDLER restored incorrectly");
# endif /* TCL_MEM_DEBUG */
d579 1
a579 1
			dstAttr & ~((DWORD)FILE_ATTRIBUTE_READONLY));
a606 1
    _except_docopyfile_handler(NULL,NULL,NULL,NULL);
d614 1
a614 1
 * TclpObjDeleteFile, TclpDeleteFile --
d640 1
a640 1
    return TclpDeleteFile(Tcl_FSGetNativePath(pathPtr));
d643 2
a644 2
int
TclpDeleteFile(
d685 1
a685 1
			attr & ~((DWORD)FILE_ATTRIBUTE_READONLY));
d1324 1
a1324 1
	    if (TclpDeleteFile(nativeSrc) == TCL_OK) {
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
 * Copyright (c) 1996-1997 Sun Microsystems, Inc.
d12 1
a12 1
 * RCS: @@(#) $Id: tclWinFCmd.c,v 1.10 1999/01/26 03:53:42 jingham Exp $
d31 1
a31 1
			    int objIndex, char *fileName,
d34 1
a34 1
			    int objIndex, char *fileName,
d37 1
a37 1
			    int objIndex, char *fileName,
d40 1
a40 1
			    int objIndex, char *fileName,
d43 1
a43 1
			    int objIndex, char *fileName,
d63 6
a68 3
char *tclpFileAttrStrings[] = {"-archive", "-hidden", "-longname", "-readonly",
	"-shortname", "-system", (char *) NULL};
CONST TclFileAttrProcs tclpFileAttrProcs[] = {
d80 2
a81 2
typedef int (TraversalProc)(char *src, char *dst, DWORD attr, int type, 
	Tcl_DString *errorPtr);
d87 14
a100 9
static void		AttributesPosixError _ANSI_ARGS_((Tcl_Interp *interp,
			    int objIndex, char *fileName, int getOrSet));
static int		ConvertFileNameFormat _ANSI_ARGS_((Tcl_Interp *interp,
			    int objIndex, char *fileName, int longShort,
			    Tcl_Obj **attributePtrPtr));
static int		TraversalCopy(char *src, char *dst, DWORD attr, 
				int type, Tcl_DString *errorPtr);
static int		TraversalDelete(char *src, char *dst, DWORD attr,
				int type, Tcl_DString *errorPtr);
d102 1
a102 1
			    Tcl_DString *sourcePtr, Tcl_DString *destPtr,
d109 1
a109 1
 * TclpRenameFile --
d121 1
a121 1
 *	If the directory was successfully created, returns TCL_OK.
d125 1
d150 4
a153 2
    char *src,			/* Pathname of file or dir to be renamed. */ 
    char *dst)			/* New pathname for file or directory. */
d155 21
d177 3
a179 1
    
d187 1
a187 1
    try {
d189 1
a189 2
    /* END CYGNUS LOCAL */
	if (MoveFile(src, dst) != FALSE) {
d194 1
a194 1
    } except (-1) {}
d200 7
a206 3
    srcAttr = GetFileAttributes(src);
    dstAttr = GetFileAttributes(dst);
    if (srcAttr == (DWORD) -1) {
d209 5
a213 1
    if (dstAttr == (DWORD) -1) {
a220 10
    if ((errno == EACCES) && (TclWinGetPlatformId() == VER_PLATFORM_WIN32s)) {
	if ((srcAttr != 0) && (dstAttr != 0)) {
	    /*
	     * Win32s reports trying to overwrite an existing file or directory
	     * as EACCES.
	     */

	    errno = EEXIST;
	}
    }
d224 1
a224 2
	    char srcPath[MAX_PATH], dstPath[MAX_PATH];
	    int srcArgc, dstArgc;
d226 9
a234 5
	    char *srcRest, *dstRest;
	    int size;

	    size = GetFullPathName(src, sizeof(srcPath), srcPath, &srcRest);
	    if ((size == 0) || (size > sizeof(srcPath))) {
d237 3
a239 2
	    size = GetFullPathName(dst, sizeof(dstPath), dstPath, &dstRest);
	    if ((size == 0) || (size > sizeof(dstPath))) {
d242 6
a247 4
	    if (srcRest == NULL) {
		srcRest = srcPath + strlen(srcPath);
	    }
	    if (strnicmp(srcPath, dstPath, srcRest - srcPath) == 0) {
d253 2
d257 5
a261 2
	    Tcl_SplitPath(srcPath, &srcArgc, &srcArgv);
	    Tcl_SplitPath(dstPath, &dstArgc, &dstArgv);
d269 1
a269 1
		errno = EINVAL;
d271 1
a271 1
		    (stricmp(srcArgv[0], dstArgv[0]) != 0)) {
d282 1
a282 1
		errno = EXDEV;
d296 1
a296 1
    } else if (errno == EEXIST) {
d310 1
a310 1
		if (TclpRemoveDirectory(dst, 0, NULL) == TCL_OK) {
d317 1
a317 1
		    if (MoveFile(src, dst) != FALSE) {
d327 3
a329 3
		    CreateDirectory(dst, NULL);
		    SetFileAttributes(dst, dstAttr);
		    if (errno == EACCES) {
d338 1
a338 1
		errno = ENOTDIR;
d342 1
a342 1
		errno = EISDIR;
d353 1
a353 1
		char tempName[MAX_PATH];
d355 1
a355 1
		char *rest;
d357 3
a359 2
		size = GetFullPathName(dst, sizeof(tempName), tempName, &rest);
		if ((size == 0) || (size > sizeof(tempName)) || (rest == NULL)) {
d362 4
a365 1
		*rest = '\0';
d367 4
a370 1
		if (GetTempFileName(tempName, "tclr", 0, tempName) != 0) {
d378 7
a384 5
		    DeleteFile(tempName);
		    if (MoveFile(dst, tempName) != FALSE) {
			if (MoveFile(src, dst) != FALSE) {
			    SetFileAttributes(tempName, FILE_ATTRIBUTE_NORMAL);
			    DeleteFile(tempName);
d387 2
a388 2
			    DeleteFile(dst);
			    MoveFile(tempName, dst);
d398 1
a398 1
		    if (errno == EACCES) {
d416 1
a416 1
 * TclpCopyFile --
d442 2
a443 2
    char *src,			/* Pathname of file to be copied. */
    char *dst)			/* Pathname of file to copy to. */
d445 21
d473 4
a476 3
    try {
#endif /* __GNUC__ */
      if (CopyFile(src, dst, 0) != FALSE) {
d478 1
d481 3
a483 3
#ifndef __GNUC__
    } except (-1) {}
#endif /* __GNUC__ */
d486 2
a487 2
    if (errno == EBADF) {
	errno = EACCES;
d490 1
a490 1
    if (errno == EACCES) {
d493 4
a496 4
	srcAttr = GetFileAttributes(src);
	dstAttr = GetFileAttributes(dst);
	if (srcAttr != (DWORD) -1) {
	    if (dstAttr == (DWORD) -1) {
d501 1
a501 1
		errno = EISDIR;
d504 3
a506 2
		SetFileAttributes(dst, dstAttr & ~FILE_ATTRIBUTE_READONLY);
		if (CopyFile(src, dst, 0) != FALSE) {
d515 1
a515 1
		SetFileAttributes(dst, dstAttr);
d525 1
a525 1
 * TclpDeleteFile --
d549 14
a562 1
    char *path)			/* Pathname of file to be removed. */
d565 1
d567 3
a569 1
    if (DeleteFile(path) != FALSE) {
a572 5
    if (path[0] == '\0') {
	/*
	 * Win32s thinks that "" is the same as "." and then reports EISDIR
	 * instead of ENOENT.
	 */
d574 19
a592 4
	errno = ENOENT;
    } else if (errno == EACCES) {
        attr = GetFileAttributes(path);
	if (attr != (DWORD) -1) {
d599 1
a599 1
		errno = EISDIR;
d601 3
a603 2
		SetFileAttributes(path, attr & ~FILE_ATTRIBUTE_READONLY);
		if (DeleteFile(path) != FALSE) {
d607 1
a607 1
		SetFileAttributes(path, attr);
d610 3
a612 3
    } else if (errno == ENOENT) {
        attr = GetFileAttributes(path);
	if (attr != (DWORD) -1) {
d619 1
a619 1
		errno = EISDIR;
d622 1
a622 1
    } else if (errno == EINVAL) {
d628 1
a628 1
	errno = EACCES;
d661 14
a674 1
    char *path)			/* Pathname of directory to create */
d676 2
a677 1
    int error;
d679 2
a680 1
    if (CreateDirectory(path, NULL) == 0) {
a681 6
	if (TclWinGetPlatformId() == VER_PLATFORM_WIN32s) {
	    if ((error == ERROR_ACCESS_DENIED) 
		    && (GetFileAttributes(path) != (DWORD) -1)) {
		error = ERROR_FILE_EXISTS;
	    }
	}
d716 6
a721 4
    char *src,			/* Pathname of directory to be copied. */
    char *dst,			/* Pathname of target directory. */
    Tcl_DString *errorPtr)	/* If non-NULL, initialized DString for
				 * error reporting. */
d724 6
a729 2
    Tcl_DString srcBuffer;
    Tcl_DString dstBuffer;
d731 2
a732 8
    Tcl_DStringInit(&srcBuffer);
    Tcl_DStringInit(&dstBuffer);
    Tcl_DStringAppend(&srcBuffer, src, -1);
    Tcl_DStringAppend(&dstBuffer, dst, -1);
    result = TraverseWinTree(TraversalCopy, &srcBuffer, &dstBuffer, 
	    errorPtr);
    Tcl_DStringFree(&srcBuffer);
    Tcl_DStringFree(&dstBuffer);
d739 1
a739 1
 * TclpRemoveDirectory -- 
d767 2
a768 1
    char *path,			/* Pathname of directory to be removed. */
d772 3
a774 2
    Tcl_DString *errorPtr)	/* If non-NULL, initialized DString for
				 * error reporting. */
d777 21
a797 1
    Tcl_DString buffer;
d800 3
a802 1
    if (RemoveDirectory(path) != FALSE) {
a805 5
    if (path[0] == '\0') {
	/*
	 * Win32s thinks that "" is the same as "." and then reports EACCES
	 * instead of ENOENT.
	 */
d807 16
a822 1
	errno = ENOENT;
d824 3
a826 3
    if (errno == EACCES) {
	attr = GetFileAttributes(path);
	if (attr != (DWORD) -1) {
d833 1
a833 1
		errno = ENOTDIR;
d839 1
a839 1
		if (SetFileAttributes(path, attr) == FALSE) {
d842 1
a842 1
		if (RemoveDirectory(path) != FALSE) {
d846 2
a847 1
		SetFileAttributes(path, attr | FILE_ATTRIBUTE_READONLY);
d857 1
d859 1
a859 1
		WIN32_FIND_DATA data;
a860 1
		char *find;
d863 2
d866 2
a867 2
		find = Tcl_DStringAppend(&buffer, path, -1);
		len = Tcl_DStringLength(&buffer);
d872 1
a872 1
		handle = FindFirstFile(find, &data);
d881 1
a881 1
			    errno = EEXIST;
d884 1
a884 1
			if (FindNextFile(handle, &data) == FALSE) {
d894 1
a894 1
    if (errno == ENOTEMPTY) {
d900 1
a900 1
	errno = EEXIST;
d902 1
a902 1
    if ((recursive != 0) && (errno == EEXIST)) {
d908 1
a908 5
	Tcl_DStringInit(&buffer);
	Tcl_DStringAppend(&buffer, path, -1);
	result = TraverseWinTree(TraversalDelete, &buffer, NULL, errorPtr);
	Tcl_DStringFree(&buffer);
	return result;
d910 1
a910 1

d913 1
a913 1
        Tcl_DStringAppend(errorPtr, path, -1);
d945 1
a945 1
				 * traversed. */
d947 4
a950 3
				 * parallel with source directory. */
    Tcl_DString *errorPtr)	/* If non-NULL, an initialized DString for
				 * error reporting. */
d953 2
a954 2
    char *source, *target, *errfile;
    int result, sourceLen, targetLen, sourceLenOriginal, targetLenOriginal;
d956 1
a956 1
    WIN32_FIND_DATA data;
d958 1
d960 1
a960 11
    source = Tcl_DStringValue(sourcePtr);
    sourceLenOriginal = Tcl_DStringLength(sourcePtr);
    if (targetPtr != NULL) {
	target = Tcl_DStringValue(targetPtr);
	targetLenOriginal = Tcl_DStringLength(targetPtr);
    } else {
	target = NULL;
	targetLenOriginal = 0;
    }

    errfile = NULL;
d962 5
a966 3
    sourceAttr = GetFileAttributes(source);
    if (sourceAttr == (DWORD) -1) {
	errfile = source;
d974 1
a974 1
	return (*traverseProc)(source, target, sourceAttr, DOTREE_F, errorPtr);
d977 5
a981 10
    /*
     * When given the pathname of the form "c:\" (one that already ends
     * with a backslash), must make sure not to add another "\" to the end
     * otherwise it will try to access a network drive.  
     */

    sourceLen = sourceLenOriginal;
    if ((sourceLen > 0) && (source[sourceLen - 1] != '\\')) {
	Tcl_DStringAppend(sourcePtr, "\\", 1);
	sourceLen++;
d983 3
a985 4
    source = Tcl_DStringAppend(sourcePtr, "*.*", 3); 
    handle = FindFirstFile(source, &data);
    Tcl_DStringSetLength(sourcePtr, sourceLen);
    if (handle == INVALID_HANDLE_VALUE) {
d991 1
a991 1
	errfile = source;
d995 3
a997 1
    result = (*traverseProc)(source, target, sourceAttr, DOTREE_PRED, errorPtr);
d1003 10
d1014 10
a1023 4
	targetLen = targetLenOriginal;
	if ((targetLen > 0) && (target[targetLen - 1] != '\\')) {
	    target = Tcl_DStringAppend(targetPtr, "\\", 1);
	    targetLen++;
d1027 24
a1050 15
    while (1) {
	if ((strcmp(data.cFileName, ".") != 0)
	        && (strcmp(data.cFileName, "..") != 0)) {
	    /* 
	     * Append name after slash, and recurse on the file. 
	     */

	    Tcl_DStringAppend(sourcePtr, data.cFileName, -1);
	    if (targetPtr != NULL) {
		Tcl_DStringAppend(targetPtr, data.cFileName, -1);
	    }
	    result = TraverseWinTree(traverseProc, sourcePtr, targetPtr, 
		    errorPtr);
	    if (result != TCL_OK) {
		break;
d1052 3
d1056 3
a1058 3
	    /*
	     * Remove name after slash.
	     */
d1060 5
a1064 4
	    Tcl_DStringSetLength(sourcePtr, sourceLen);
	    if (targetPtr != NULL) {
		Tcl_DStringSetLength(targetPtr, targetLen);
	    }
d1066 3
a1068 1
	if (FindNextFile(handle, &data) == FALSE) {
d1071 9
d1087 2
a1088 2
    Tcl_DStringSetLength(sourcePtr, sourceLenOriginal);
    source = Tcl_DStringValue(sourcePtr);
d1090 2
a1091 2
	Tcl_DStringSetLength(targetPtr, targetLenOriginal);
	target = Tcl_DStringValue(targetPtr);
a1092 1

d1099 2
a1100 2
	result = (*traverseProc)(source, target, sourceAttr, 
		DOTREE_POSTD, errorPtr);
d1103 1
a1103 1
    if (errfile != NULL) {
d1106 1
a1106 1
	    Tcl_DStringAppend(errorPtr, errfile, -1);
d1133 2
a1134 3
    char *src,			/* Source pathname to copy. */
    char *dst,			/* Destination pathname of copy. */
    DWORD srcAttr,		/* File attributes for src. */
d1136 2
a1137 2
    Tcl_DString *errorPtr)	/* If non-NULL, initialized DString for
				 * error return. */
d1139 3
d1143 2
a1144 2
	case DOTREE_F:
	    if (TclpCopyFile(src, dst) == TCL_OK) {
d1148 7
a1154 4

	case DOTREE_PRED:
	    if (TclpCreateDirectory(dst) == TCL_OK) {
		if (SetFileAttributes(dst, srcAttr) != FALSE) {
d1160 2
a1161 2

        case DOTREE_POSTD:
d1163 1
a1163 1

d1172 2
a1173 1
	Tcl_DStringAppend(errorPtr, dst, -1);
d1201 5
a1205 6
    char *src,			/* Source pathname. */
    char *ignore,		/* Destination pathname (not used). */
    DWORD srcAttr,		/* File attributes for src (not used). */
    int type,			/* Reason for call - see TraverseWinTree(). */
    Tcl_DString *errorPtr)	/* If non-NULL, initialized DString for
				 * error return. */
d1207 2
d1210 2
a1211 2
	case DOTREE_F:
	    if (TclpDeleteFile(src) == TCL_OK) {
d1215 2
a1216 2

	case DOTREE_PRED:
d1218 3
a1220 3

	case DOTREE_POSTD:
	    if (TclpRemoveDirectory(src, 0, NULL) == TCL_OK) {
d1224 1
a1224 1

d1228 2
a1229 1
	Tcl_DStringAppend(errorPtr, src, -1);
d1237 1
a1237 1
 * AttributesPosixError --
d1252 1
a1252 1
AttributesPosixError(
d1254 1
a1254 2
    int objIndex,		/* The attribute which caused the problem. */
    char *fileName,		/* The name of the file which caused the 
a1255 1
    int getOrSet)		/* 0 for get; 1 for set */
d1259 2
a1260 3
	    "cannot ", getOrSet ? "set" : "get", " attribute \"", 
	    tclpFileAttrStrings[objIndex], "\" for file \"", fileName, 
	    "\": ", Tcl_PosixError(interp), (char *) NULL);
d1284 4
a1287 4
    Tcl_Interp *interp,		    /* The interp we are using for errors. */
    int objIndex,		    /* The index of the attribute. */
    char *fileName,		    /* The name of the file. */
    Tcl_Obj **attributePtrPtr)	    /* A pointer to return the object with. */
d1289 7
a1295 1
    DWORD result = GetFileAttributes(fileName);
d1297 2
a1298 2
    if (result == 0xFFFFFFFF) {
	AttributesPosixError(interp, objIndex, fileName, 0);
d1302 1
a1302 1
    *attributePtrPtr = Tcl_NewBooleanObj(result & attributeArray[objIndex]);
d1327 9
a1335 11
    Tcl_Interp *interp,		    /* The interp we are using for errors. */
    int objIndex,		    /* The index of the attribute. */
    char *fileName,		    /* The name of the file. */
    int longShort,		    /* 0 to short name, 1 to long name. */
    Tcl_Obj **attributePtrPtr)	    /* A pointer to return the object with. */
{
    HANDLE findHandle;
    WIN32_FIND_DATA findData;
    int pathArgc, i;
    char **pathArgv, **newPathArgv;
    char *currentElement, *resultStr;
d1339 22
a1360 2
    Tcl_SplitPath(fileName, &pathArgc, &pathArgv);
    newPathArgv = (char **) ckalloc(pathArgc * sizeof(char *));
d1362 4
a1365 14
    i = 0;
    if ((pathArgv[0][0] == '/') 
	    || ((strlen(pathArgv[0]) == 3) && (pathArgv[0][1] == ':'))) {
	newPathArgv[0] = (char *) ckalloc(strlen(pathArgv[0]) + 1);
	strcpy(newPathArgv[0], pathArgv[0]);
	i = 1;
    } 
    for ( ; i < pathArgc; i++) {
	if (strcmp(pathArgv[i], ".") == 0) {
	    currentElement = ckalloc(2);
	    strcpy(currentElement, ".");
	} else if (strcmp(pathArgv[i], "..") == 0) {
	    currentElement = ckalloc(3);
	    strcpy(currentElement, "..");
d1367 6
a1372 1
	    int useLong;
d1375 25
a1399 5
	    resultStr = Tcl_JoinPath(i + 1, pathArgv, &resultDString);
	    findHandle = FindFirstFile(resultStr, &findData);
	    if (findHandle == INVALID_HANDLE_VALUE) {
		pathArgc = i - 1;
		AttributesPosixError(interp, objIndex, fileName, 0);
a1400 1
		Tcl_DStringFree(&resultDString);
d1403 6
a1408 3
	    if (longShort) {
		if (findData.cFileName[0] != '\0') {
		    useLong = 1;
d1410 3
a1412 1
		    useLong = 0;
d1415 5
a1419 2
		if (findData.cAlternateFileName[0] == '\0') {
		    useLong = 1;
d1421 3
a1423 1
		    useLong = 0;
d1426 18
a1443 10
	    if (useLong) {
		currentElement = ckalloc(strlen(findData.cFileName) + 1);
		strcpy(currentElement, findData.cFileName);
	    } else {
		currentElement = ckalloc(strlen(findData.cAlternateFileName) 
			+ 1);
		strcpy(currentElement, findData.cAlternateFileName);
	    }
	    Tcl_DStringFree(&resultDString);
	    FindClose(findHandle);
a1444 1
	newPathArgv[i] = currentElement;
d1448 3
a1450 2
    resultStr = Tcl_JoinPath(pathArgc, newPathArgv, &resultDString);
    *attributePtrPtr = Tcl_NewStringObj(resultStr, Tcl_DStringLength(&resultDString));
d1454 2
a1455 2
    for (i = 0; i < pathArgc; i++) {
	ckfree(newPathArgv[i]);
d1457 2
a1458 1
    ckfree((char *) newPathArgv);
d1483 4
a1486 4
    Tcl_Interp *interp,		    /* The interp we are using for errors. */
    int objIndex,		    /* The index of the attribute. */
    char *fileName,		    /* The name of the file. */
    Tcl_Obj **attributePtrPtr)	    /* A pointer to return the object with. */
d1512 4
a1515 4
    Tcl_Interp *interp,		    /* The interp we are using for errors. */
    int objIndex,		    /* The index of the attribute. */
    char *fileName,		    /* The name of the file. */
    Tcl_Obj **attributePtrPtr)	    /* A pointer to return the object with. */
d1539 4
a1542 4
    Tcl_Interp *interp,		    /* The interp we are using for errors. */
    int objIndex,		    /* The index of the attribute. */
    char *fileName,		    /* The name of the file. */
    Tcl_Obj *attributePtr)	    /* The new value of the attribute. */
d1544 1
a1544 1
    DWORD fileAttributes = GetFileAttributes(fileName);
d1547 5
d1553 4
a1556 3
    if (fileAttributes == 0xFFFFFFFF) {
	AttributesPosixError(interp, objIndex, fileName, 1);
	return TCL_ERROR;
d1561 1
a1561 1
	return result;
d1570 4
a1573 3
    if (!SetFileAttributes(fileName, fileAttributes)) {
	AttributesPosixError(interp, objIndex, fileName, 1);
	return TCL_ERROR;
d1575 5
a1579 1
    return TCL_OK;
d1601 4
a1604 4
    Tcl_Interp *interp,		    /* The interp we are using for errors. */
    int objIndex,		    /* The index of the attribute. */
    char *fileName,		    /* The name of the file. */
    Tcl_Obj *attributePtr)	    /* The new value of the attribute. */
d1608 1
a1608 1
	    "\" for file \"", fileName, "\" : attribute is readonly", 
d1634 1
a1634 1
    Tcl_Interp *interp)    /* Interpreter to which to pass the volume list */
d1637 1
a1637 1
    char buf[4];
d1639 1
a1642 4
    buf[1] = ':';
    buf[2] = '/';
    buf[3] = '\0';

d1644 1
a1644 1
     * On Win32s: 
d1649 26
a1674 5
    for (i = 0; i < 26; i++) {
        buf[0] = (char) ('a' + i);
	if (GetVolumeInformation(buf, NULL, 0, NULL, NULL, NULL, NULL, 0)  
		|| (GetLastError() == ERROR_NOT_READY)) {
	    elemPtr = Tcl_NewStringObj(buf, -1);
d1680 3
@


1.1.1.1
log
@import dejagnu-1999-11-08 snapshot
@
text
@@


1.1.1.2
log
@Tcl 8.3 upgrade
@
text
@d7 1
a7 1
 * Copyright (c) 1996-1998 Sun Microsystems, Inc.
d12 1
a12 1
 * RCS: @@(#) $Id: tclWinFCmd.c,v 1.6.8.3 2000/09/15 16:58:47 spolk Exp $
d31 1
a31 1
			    int objIndex, CONST char *fileName,
d34 1
a34 1
			    int objIndex, CONST char *fileName,
d37 1
a37 1
			    int objIndex, CONST char *fileName,
d40 1
a40 1
			    int objIndex, CONST char *fileName,
d43 1
a43 1
			    int objIndex, CONST char *fileName,
d63 3
a65 6
char *tclpFileAttrStrings[] = {
	"-archive", "-hidden", "-longname", "-readonly",
	"-shortname", "-system", (char *) NULL
};

const TclFileAttrProcs tclpFileAttrProcs[] = {
d77 2
a78 2
typedef int (TraversalProc)(Tcl_DString *srcPtr, Tcl_DString *dstPtr, 
	int type, Tcl_DString *errorPtr);
d84 9
a92 14
static void		StatError(Tcl_Interp *interp, CONST char *fileName);
static int		ConvertFileNameFormat(Tcl_Interp *interp, 
			    int objIndex, CONST char *fileName, int longShort,
			    Tcl_Obj **attributePtrPtr);
static int		DoCopyFile(Tcl_DString *srcPtr, Tcl_DString *dstPtr);
static int		DoCreateDirectory(Tcl_DString *pathPtr);
static int		DoDeleteFile(Tcl_DString *pathPtr);
static int		DoRemoveDirectory(Tcl_DString *pathPtr, int recursive, 
			    Tcl_DString *errorPtr);
static int		DoRenameFile(const TCHAR *nativeSrc, Tcl_DString *dstPtr);
static int		TraversalCopy(Tcl_DString *srcPtr, Tcl_DString *dstPtr, 
			    int type, Tcl_DString *errorPtr);
static int		TraversalDelete(Tcl_DString *srcPtr, Tcl_DString *dstPtr, 
			    int type, Tcl_DString *errorPtr);
d94 1
a94 1
			    Tcl_DString *sourcePtr, Tcl_DString *dstPtr, 
d101 1
a101 1
 * TclpRenameFile, DoRenameFile --
d113 1
a113 1
 *	If the file or directory was successfully renamed, returns TCL_OK.
a116 1
 *	ENAMETOOLONG: src or dst names are too long.
d141 2
a142 4
    CONST char *src,		/* Pathname of file or dir to be renamed
				 * (UTF-8). */
    CONST char *dst)		/* New pathname of file or directory
				 * (UTF-8). */
a143 21
    int result;
    TCHAR *nativeSrc;
    Tcl_DString srcString, dstString;

    nativeSrc = Tcl_WinUtfToTChar(src, -1, &srcString);
    Tcl_WinUtfToTChar(dst, -1, &dstString);

    result = DoRenameFile(nativeSrc, &dstString);
    Tcl_DStringFree(&srcString);
    Tcl_DStringFree(&dstString);
    return result;
}

static int
DoRenameFile(
    CONST TCHAR *nativeSrc,	/* Pathname of file or dir to be renamed
				 * (native). */ 
    Tcl_DString *dstPtr)	/* New pathname for file or directory
				 * (native). */
{    
    const TCHAR *nativeDst;
d145 1
a145 3

    nativeDst = (TCHAR *) Tcl_DStringValue(dstPtr);

d153 1
a153 1
    __try {
d155 2
a156 1
	if ((*tclWinProcs->moveFileProc)(nativeSrc, nativeDst) != FALSE) {
d161 1
a161 1
    } __except (-1) {}
d167 3
a169 7
    srcAttr = (*tclWinProcs->getFileAttributesProc)(nativeSrc);
    dstAttr = (*tclWinProcs->getFileAttributesProc)(nativeDst);
    if (srcAttr == 0xffffffff) {
	if ((*tclWinProcs->getFullPathNameProc)(nativeSrc, 0, NULL, NULL) >= MAX_PATH) {
	    errno = ENAMETOOLONG;
	    return TCL_ERROR;
	}
d172 1
a172 5
    if (dstAttr == 0xffffffff) {
	if ((*tclWinProcs->getFullPathNameProc)(nativeDst, 0, NULL, NULL) >= MAX_PATH) {
	    errno = ENAMETOOLONG;
	    return TCL_ERROR;
	}
d180 10
d193 2
a194 1
	    TCHAR *nativeSrcRest, *nativeDstRest;
d196 5
a200 9
	    int size, srcArgc, dstArgc;
	    WCHAR nativeSrcPath[MAX_PATH];
	    WCHAR nativeDstPath[MAX_PATH];
	    Tcl_DString srcString, dstString;
	    CONST char *src, *dst;

	    size = (*tclWinProcs->getFullPathNameProc)(nativeSrc, MAX_PATH, 
		    nativeSrcPath, &nativeSrcRest);
	    if ((size == 0) || (size > MAX_PATH)) {
d203 2
a204 3
	    size = (*tclWinProcs->getFullPathNameProc)(nativeDst, MAX_PATH, 
		    nativeDstPath, &nativeDstRest);
	    if ((size == 0) || (size > MAX_PATH)) {
d207 4
a210 6
	    (*tclWinProcs->charLowerProc)((TCHAR *) nativeSrcPath);
	    (*tclWinProcs->charLowerProc)((TCHAR *) nativeDstPath);

	    src = Tcl_WinTCharToUtf((TCHAR *) nativeSrcPath, -1, &srcString);
	    dst = Tcl_WinTCharToUtf((TCHAR *) nativeDstPath, -1, &dstString);
	    if (strncmp(src, dst, (size_t) Tcl_DStringLength(&srcString)) == 0) {
a215 2
		Tcl_DStringFree(&srcString);
		Tcl_DStringFree(&dstString);
d218 2
a219 5
	    Tcl_SplitPath(src, &srcArgc, &srcArgv);
	    Tcl_SplitPath(dst, &dstArgc, &dstArgv);
	    Tcl_DStringFree(&srcString);
	    Tcl_DStringFree(&dstString);

d227 1
a227 1
		Tcl_SetErrno(EINVAL);
d229 1
a229 1
		    (strcmp(srcArgv[0], dstArgv[0]) != 0)) {
d240 1
a240 1
		Tcl_SetErrno(EXDEV);
d254 1
a254 1
    } else if (Tcl_GetErrno() == EEXIST) {
d268 1
a268 1
		if (DoRemoveDirectory(dstPtr, 0, NULL) == TCL_OK) {
d275 1
a275 1
		    if ((*tclWinProcs->moveFileProc)(nativeSrc, nativeDst) != FALSE) {
d285 3
a287 3
		    (*tclWinProcs->createDirectoryProc)(nativeDst, NULL);
		    (*tclWinProcs->setFileAttributesProc)(nativeDst, dstAttr);
		    if (Tcl_GetErrno() == EACCES) {
d296 1
a296 1
		Tcl_SetErrno(ENOTDIR);
d300 1
a300 1
		Tcl_SetErrno(EISDIR);
d311 1
a311 1
		TCHAR *nativeRest, *nativeTmp, *nativePrefix;
d313 1
a313 1
		WCHAR tempBuf[MAX_PATH];
d315 2
a316 3
		size = (*tclWinProcs->getFullPathNameProc)(nativeDst, MAX_PATH, 
			tempBuf, &nativeRest);
		if ((size == 0) || (size > MAX_PATH) || (nativeRest == NULL)) {
d319 1
a319 4
		nativeTmp = (TCHAR *) tempBuf;
		((char *) nativeRest)[0] = '\0';
		((char *) nativeRest)[1] = '\0';    /* In case it's Unicode. */

d321 1
a321 4
		nativePrefix = (tclWinProcs->useWide) 
			? (TCHAR *) L"tclr" : (TCHAR *) "tclr";
		if ((*tclWinProcs->getTempFileNameProc)(nativeTmp, 
			nativePrefix, 0, tempBuf) != 0) {
d329 5
a333 7
		    nativeTmp = (TCHAR *) tempBuf;
		    (*tclWinProcs->deleteFileProc)(nativeTmp);
		    if ((*tclWinProcs->moveFileProc)(nativeDst, nativeTmp) != FALSE) {
			if ((*tclWinProcs->moveFileProc)(nativeSrc, nativeDst) != FALSE) {
			    (*tclWinProcs->setFileAttributesProc)(nativeTmp, 
				    FILE_ATTRIBUTE_NORMAL);
			    (*tclWinProcs->deleteFileProc)(nativeTmp);
d336 2
a337 2
			    (*tclWinProcs->deleteFileProc)(nativeDst);
			    (*tclWinProcs->moveFileProc)(nativeTmp, nativeDst);
d347 1
a347 1
		    if (Tcl_GetErrno() == EACCES) {
d365 1
a365 1
 * TclpCopyFile, DoCopyFile --
d391 2
a392 2
    CONST char *src,		/* Pathname of file to be copied (UTF-8). */
    CONST char *dst)		/* Pathname of file to copy to (UTF-8). */
a393 21
    int result;
    Tcl_DString srcString, dstString;

    Tcl_WinUtfToTChar(src, -1, &srcString);
    Tcl_WinUtfToTChar(dst, -1, &dstString);
    result = DoCopyFile(&srcString, &dstString);
    Tcl_DStringFree(&srcString);
    Tcl_DStringFree(&dstString);
    return result;
}

static int
DoCopyFile(
    Tcl_DString *srcPtr,	/* Pathname of file to be copied (native). */
    Tcl_DString *dstPtr)	/* Pathname of file to copy to (native). */
{
    CONST TCHAR *nativeSrc, *nativeDst;

    nativeSrc = (TCHAR *) Tcl_DStringValue(srcPtr);
    nativeDst = (TCHAR *) Tcl_DStringValue(dstPtr);

d401 3
a403 4
    __try {
	if ((*tclWinProcs->copyFileProc)(nativeSrc, nativeDst, 0) != FALSE) {
#endif
    /* END CYGNUS LOCAL */
a404 1
#ifndef __GNUC__
d407 3
a409 3
    } __except (-1) {}
#endif
    /* END CYGNUS LOCAL */
d412 2
a413 2
    if (Tcl_GetErrno() == EBADF) {
	Tcl_SetErrno(EACCES);
d416 1
a416 1
    if (Tcl_GetErrno() == EACCES) {
d419 4
a422 4
	srcAttr = (*tclWinProcs->getFileAttributesProc)(nativeSrc);
	dstAttr = (*tclWinProcs->getFileAttributesProc)(nativeDst);
	if (srcAttr != 0xffffffff) {
	    if (dstAttr == 0xffffffff) {
d427 1
a427 1
		Tcl_SetErrno(EISDIR);
d430 2
a431 3
		(*tclWinProcs->setFileAttributesProc)(nativeDst, 
			dstAttr & ~FILE_ATTRIBUTE_READONLY);
		if ((*tclWinProcs->copyFileProc)(nativeSrc, nativeDst, 0) != FALSE) {
d440 1
a440 1
		(*tclWinProcs->setFileAttributesProc)(nativeDst, dstAttr);
d450 1
a450 1
 * TclpDeleteFile, DoDeleteFile --
d474 1
a474 14
    CONST char *path)		/* Pathname of file to be removed (UTF-8). */
{
    int result;
    Tcl_DString pathString;

    Tcl_WinUtfToTChar(path, -1, &pathString);
    result = DoDeleteFile(&pathString);
    Tcl_DStringFree(&pathString);
    return result;
}

static int
DoDeleteFile(
    Tcl_DString *pathPtr)	/* Pathname of file to be removed (native). */
a476 1
    CONST TCHAR *nativePath;
d478 1
a478 3
    nativePath = (TCHAR *) Tcl_DStringValue(pathPtr);
    
    if ((*tclWinProcs->deleteFileProc)(nativePath) != FALSE) {
d482 5
d488 4
a491 19
    /*
     * Win32s thinks that "" is the same as "." and then reports EISDIR
     * instead of ENOENT.
     */

    if (tclWinProcs->useWide) {
	if (((WCHAR *) nativePath)[0] == '\0') {
	    Tcl_SetErrno(ENOENT);
	    return TCL_ERROR;
	}
    } else {
	if (((char *) nativePath)[0] == '\0') {
	    Tcl_SetErrno(ENOENT);
	    return TCL_ERROR;
	}
    }
    if (Tcl_GetErrno() == EACCES) {
        attr = (*tclWinProcs->getFileAttributesProc)(nativePath);
	if (attr != 0xffffffff) {
d498 1
a498 1
		Tcl_SetErrno(EISDIR);
d500 2
a501 3
		(*tclWinProcs->setFileAttributesProc)(nativePath, 
			attr & ~FILE_ATTRIBUTE_READONLY);
		if ((*tclWinProcs->deleteFileProc)(nativePath) != FALSE) {
d505 1
a505 1
		(*tclWinProcs->setFileAttributesProc)(nativePath, attr);
d508 3
a510 3
    } else if (Tcl_GetErrno() == ENOENT) {
        attr = (*tclWinProcs->getFileAttributesProc)(nativePath);
	if (attr != 0xffffffff) {
d517 1
a517 1
		Tcl_SetErrno(EISDIR);
d520 1
a520 1
    } else if (Tcl_GetErrno() == EINVAL) {
d526 1
a526 1
	Tcl_SetErrno(EACCES);
d559 1
a559 14
    CONST char *path)		/* Pathname of directory to create (UTF-8). */
{
    int result;
    Tcl_DString pathString;

    Tcl_WinUtfToTChar(path, -1, &pathString);
    result = DoCreateDirectory(&pathString);
    Tcl_DStringFree(&pathString);
    return result;
}

static int
DoCreateDirectory(
    Tcl_DString *pathPtr)	/* Pathname of directory to create (native). */
d561 1
a561 2
    DWORD error;
    CONST TCHAR *nativePath;
d563 1
a563 2
    nativePath = (TCHAR *) Tcl_DStringValue(pathPtr);
    if ((*tclWinProcs->createDirectoryProc)(nativePath, NULL) == 0) {
d565 6
d605 4
a608 6
    CONST char *src,		/* Pathname of directory to be copied
				 * (UTF-8). */
    CONST char *dst,		/* Pathname of target directory (UTF-8). */
    Tcl_DString *errorPtr)	/* If non-NULL, uninitialized or free
				 * DString filled with UTF-8 name of file
				 * causing error. */
d611 2
a612 6
    Tcl_DString srcString, dstString;

    Tcl_WinUtfToTChar(src, -1, &srcString);
    Tcl_WinUtfToTChar(dst, -1, &dstString);

    result = TraverseWinTree(TraversalCopy, &srcString, &dstString, errorPtr);
d614 8
a621 2
    Tcl_DStringFree(&srcString);
    Tcl_DStringFree(&dstString);
d628 1
a628 1
 * TclpRemoveDirectory, DoRemoveDirectory -- 
d656 1
a656 2
    CONST char *path,		/* Pathname of directory to be removed
				 * (UTF-8). */
d660 2
a661 3
    Tcl_DString *errorPtr)	/* If non-NULL, uninitialized or free
				 * DString filled with UTF-8 name of file
				 * causing error. */
d664 1
a664 21
    Tcl_DString pathString;

    Tcl_WinUtfToTChar(path, -1, &pathString);
    result = DoRemoveDirectory(&pathString, recursive, errorPtr);
    Tcl_DStringFree(&pathString);

    return result;
}

static int
DoRemoveDirectory(
    Tcl_DString *pathPtr,	/* Pathname of directory to be removed
				 * (native). */
    int recursive,		/* If non-zero, removes directories that
				 * are nonempty.  Otherwise, will only remove
				 * empty directories. */
    Tcl_DString *errorPtr)	/* If non-NULL, uninitialized or free
				 * DString filled with UTF-8 name of file
				 * causing error. */
{
    CONST TCHAR *nativePath;
d667 1
a667 3
    nativePath = (TCHAR *) Tcl_DStringValue(pathPtr);

    if ((*tclWinProcs->removeDirectoryProc)(nativePath) != FALSE) {
d671 5
d677 1
a677 16
    /*
     * Win32s thinks that "" is the same as "." and then reports EACCES
     * instead of ENOENT.
     */


    if (tclWinProcs->useWide) {
	if (((WCHAR *) nativePath)[0] == '\0') {
	    Tcl_SetErrno(ENOENT);
	    return TCL_ERROR;
	}
    } else {
	if (((char *) nativePath)[0] == '\0') {
	    Tcl_SetErrno(ENOENT);
	    return TCL_ERROR;
	}
d679 3
a681 3
    if (Tcl_GetErrno() == EACCES) {
	attr = (*tclWinProcs->getFileAttributesProc)(nativePath);
	if (attr != 0xffffffff) {
d688 1
a688 1
		Tcl_SetErrno(ENOTDIR);
d694 1
a694 1
		if ((*tclWinProcs->setFileAttributesProc)(nativePath, attr) == FALSE) {
d697 1
a697 1
		if ((*tclWinProcs->removeDirectoryProc)(nativePath) != FALSE) {
d701 1
a701 2
		(*tclWinProcs->setFileAttributesProc)(nativePath, 
			attr | FILE_ATTRIBUTE_READONLY);
a710 1
		char *path, *find;
d712 1
a712 1
		WIN32_FIND_DATAA data;
d714 1
a716 2
		path = (char *) nativePath;

d718 2
a719 2
		len = strlen(path);
		find = Tcl_DStringAppend(&buffer, path, len);
d724 1
a724 1
		handle = FindFirstFileA(find, &data);
d733 1
a733 1
			    Tcl_SetErrno(EEXIST);
d736 1
a736 1
			if (FindNextFileA(handle, &data) == FALSE) {
d746 1
a746 1
    if (Tcl_GetErrno() == ENOTEMPTY) {
d752 1
a752 1
	Tcl_SetErrno(EEXIST);
d754 1
a754 1
    if ((recursive != 0) && (Tcl_GetErrno() == EEXIST)) {
d760 5
a764 1
	return TraverseWinTree(TraversalDelete, pathPtr, NULL, errorPtr);
d766 1
a766 1
    
d769 1
a769 1
	Tcl_WinTCharToUtf(nativePath, -1, errorPtr);
d801 1
a801 1
				 * traversed (native). */
d803 3
a805 4
				 * parallel with source directory (native). */
    Tcl_DString *errorPtr)	/* If non-NULL, uninitialized or free
				 * DString filled with UTF-8 name of file
				 * causing error. */
d808 2
a809 2
    TCHAR *nativeSource, *nativeErrfile;
    int result, found, sourceLen, targetLen, oldSourceLen, oldTargetLen;
d811 1
a811 1
    WIN32_FIND_DATAT data;
a812 1
    nativeErrfile = NULL;
d814 11
a824 1
    oldTargetLen = 0;		/* lint. */
d826 3
a828 5
    nativeSource = (TCHAR *) Tcl_DStringValue(sourcePtr);
    oldSourceLen = Tcl_DStringLength(sourcePtr);
    sourceAttr = (*tclWinProcs->getFileAttributesProc)(nativeSource);
    if (sourceAttr == 0xffffffff) {
	nativeErrfile = nativeSource;
d836 1
a836 1
	return (*traverseProc)(sourcePtr, targetPtr, DOTREE_F, errorPtr);
d839 10
a848 5
    if (tclWinProcs->useWide) {
	Tcl_DStringAppend(sourcePtr, (char *) L"\\*.*", 4 * sizeof(WCHAR) + 1);
	Tcl_DStringSetLength(sourcePtr, Tcl_DStringLength(sourcePtr) - 1);
    } else {
	Tcl_DStringAppend(sourcePtr, "\\*.*", 4);
d850 4
a853 3
    nativeSource = (TCHAR *) Tcl_DStringValue(sourcePtr);
    handle = (*tclWinProcs->findFirstFileProc)(nativeSource, &data);
    if (handle == INVALID_HANDLE_VALUE) {      
d859 1
a859 1
	nativeErrfile = nativeSource;
d863 1
a863 3
    nativeSource[oldSourceLen + 1] = '\0';
    Tcl_DStringSetLength(sourcePtr, oldSourceLen);
    result = (*traverseProc)(sourcePtr, targetPtr, DOTREE_PRED, errorPtr);
a868 10
    sourceLen = oldSourceLen;

    if (tclWinProcs->useWide) {
	sourceLen += sizeof(WCHAR);
	Tcl_DStringAppend(sourcePtr, (char *) L"\\", sizeof(WCHAR) + 1);
	Tcl_DStringSetLength(sourcePtr, sourceLen);
    } else {
	sourceLen += 1;
	Tcl_DStringAppend(sourcePtr, "\\", 1);
    }
d870 4
a873 10
	oldTargetLen = Tcl_DStringLength(targetPtr);

	targetLen = oldTargetLen;
	if (tclWinProcs->useWide) {
	    targetLen += sizeof(WCHAR);
	    Tcl_DStringAppend(targetPtr, (char *) L"\\", sizeof(WCHAR) + 1);
	    Tcl_DStringSetLength(targetPtr, targetLen);
	} else {
	    targetLen += 1;
	    Tcl_DStringAppend(targetPtr, "\\", 1);
d877 15
a891 17
    found = 1;
    for ( ; found; found = (*tclWinProcs->findNextFileProc)(handle, &data)) {
	TCHAR *nativeName;
	int len;

	if (tclWinProcs->useWide) {
	    WCHAR *wp;

	    wp = data.w.cFileName;
	    if (*wp == '.') {
		wp++;
		if (*wp == '.') {
		    wp++;
		}
		if (*wp == '\0') {
		    continue;
		}
a892 10
	    nativeName = (TCHAR *) data.w.cFileName;
	    len = Tcl_UniCharLen(data.w.cFileName) * sizeof(WCHAR);
	} else {
	    if ((strcmp(data.a.cFileName, ".") == 0) 
		    || (strcmp(data.a.cFileName, "..") == 0)) {
		continue;
	    }
	    nativeName = (TCHAR *) data.a.cFileName;
	    len = strlen(data.a.cFileName);
	}
d894 3
a896 3
	/* 
	 * Append name after slash, and recurse on the file. 
	 */
d898 4
a901 5
	Tcl_DStringAppend(sourcePtr, (char *) nativeName, len + 1);
	Tcl_DStringSetLength(sourcePtr, Tcl_DStringLength(sourcePtr) - 1);
	if (targetPtr != NULL) {
	    Tcl_DStringAppend(targetPtr, (char *) nativeName, len + 1);
	    Tcl_DStringSetLength(targetPtr, Tcl_DStringLength(targetPtr) - 1);
d903 1
a903 3
	result = TraverseWinTree(traverseProc, sourcePtr, targetPtr, 
		errorPtr);
	if (result != TCL_OK) {
a905 9

	/*
	 * Remove name after slash.
	 */

	Tcl_DStringSetLength(sourcePtr, sourceLen);
	if (targetPtr != NULL) {
	    Tcl_DStringSetLength(targetPtr, targetLen);
	}
d913 2
a914 2
    Tcl_DStringSetLength(sourcePtr, oldSourceLen + 1);
    Tcl_DStringSetLength(sourcePtr, oldSourceLen);
d916 2
a917 2
	Tcl_DStringSetLength(targetPtr, oldTargetLen + 1);
	Tcl_DStringSetLength(targetPtr, oldTargetLen);
d919 1
d926 2
a927 2
	result = (*traverseProc)(sourcePtr, targetPtr, DOTREE_POSTD, 
		errorPtr);
d930 1
a930 1
    if (nativeErrfile != NULL) {
d933 1
a933 1
	    Tcl_WinTCharToUtf(nativeErrfile, -1, errorPtr);
d960 3
a962 2
    Tcl_DString *srcPtr,	/* Source pathname to copy. */
    Tcl_DString *dstPtr,	/* Destination pathname of copy. */
d964 2
a965 2
    Tcl_DString *errorPtr)	/* If non-NULL, initialized DString filled
				 * with UTF-8 name of file causing error. */
a966 3
    TCHAR *nativeDst, *nativeSrc;
    DWORD attr;

d968 2
a969 2
	case DOTREE_F: {
	    if (DoCopyFile(srcPtr, dstPtr) == TCL_OK) {
d973 4
a976 7
	}
	case DOTREE_PRED: {
	    if (DoCreateDirectory(dstPtr) == TCL_OK) {
		nativeSrc = (TCHAR *) Tcl_DStringValue(srcPtr);
		nativeDst = (TCHAR *) Tcl_DStringValue(dstPtr);
		attr = (*tclWinProcs->getFileAttributesProc)(nativeSrc);
		if ((*tclWinProcs->setFileAttributesProc)(nativeDst, attr) != FALSE) {
d982 2
a983 2
	}
        case DOTREE_POSTD: {
d985 1
a985 1
	}
d994 1
a994 2
	nativeDst = (TCHAR *) Tcl_DStringValue(dstPtr);
	Tcl_WinTCharToUtf(nativeDst, -1, errorPtr);
d1022 6
a1027 5
    Tcl_DString *srcPtr,	/* Source pathname to delete. */
    Tcl_DString *dstPtr,	/* Not used. */
    int type,			/* Reason for call - see TraverseWinTree() */
    Tcl_DString *errorPtr)	/* If non-NULL, initialized DString filled
				 * with UTF-8 name of file causing error. */
a1028 2
    TCHAR *nativeSrc;

d1030 2
a1031 2
	case DOTREE_F: {
	    if (DoDeleteFile(srcPtr) == TCL_OK) {
d1035 2
a1036 2
	}
	case DOTREE_PRED: {
d1038 3
a1040 3
	}
	case DOTREE_POSTD: {
	    if (DoRemoveDirectory(srcPtr, 0, NULL) == TCL_OK) {
d1044 1
a1044 1
	}
d1048 1
a1048 2
	nativeSrc = (TCHAR *) Tcl_DStringValue(srcPtr);
	Tcl_WinTCharToUtf(nativeSrc, -1, errorPtr);
d1056 1
a1056 1
 * StatError --
d1071 1
a1071 1
StatError(
d1073 2
a1074 1
    CONST char *fileName)	/* The name of the file which caused the 
d1076 1
d1080 3
a1082 2
	    "could not read \"", fileName, "\": ", Tcl_PosixError(interp), 
	    (char *) NULL);
d1106 4
a1109 4
    Tcl_Interp *interp,		/* The interp we are using for errors. */
    int objIndex,		/* The index of the attribute. */
    CONST char *fileName,	/* The name of the file. */
    Tcl_Obj **attributePtrPtr)	/* A pointer to return the object with. */
d1111 1
a1111 7
    DWORD result;
    Tcl_DString ds;
    TCHAR *nativeName;

    nativeName = Tcl_WinUtfToTChar(fileName, -1, &ds);
    result = (*tclWinProcs->getFileAttributesProc)(nativeName);
    Tcl_DStringFree(&ds);
d1113 2
a1114 2
    if (result == 0xffffffff) {
	StatError(interp, fileName);
d1118 1
a1118 1
    *attributePtrPtr = Tcl_NewBooleanObj((int) (result & attributeArray[objIndex]));
d1143 11
a1153 9
    Tcl_Interp *interp,		/* The interp we are using for errors. */
    int objIndex,		/* The index of the attribute. */
    CONST char *fileName,	/* The name of the file. */
    int longShort,		/* 0 to short name, 1 to long name. */
    Tcl_Obj **attributePtrPtr)	/* A pointer to return the object with. */
{
    int pathc, i;
    char **pathv, **newv;
    char *resultStr;
d1157 2
a1158 22
    Tcl_SplitPath(fileName, &pathc, &pathv);
    newv = (char **) ckalloc(pathc * sizeof(char *));

    if (pathc == 0) {
	Tcl_AppendStringsToObj(Tcl_GetObjResult(interp), 
		"could not read \"", fileName,
		"\": no such file or directory", 
		(char *) NULL);
	result = TCL_ERROR;
	goto cleanup;
    }
    
    for (i = 0; i < pathc; i++) {
	if ((pathv[i][0] == '/')
		|| ((strlen(pathv[i]) == 3) && (pathv[i][1] == ':'))
		|| (strcmp(pathv[i], ".") == 0)
		|| (strcmp(pathv[i], "..") == 0)) {
	    /*
	     * Handle "/", "//machine/export", "c:/", "." or ".." by just
	     * copying the string literally.  Uppercase the drive letter,
	     * just because it looks better under Windows to do so.
	     */
d1160 14
a1173 4
	    simple:
	    pathv[i][0] = (char) Tcl_UniCharToUpper(UCHAR(pathv[i][0]));
	    newv[i] = (char *) ckalloc(strlen(pathv[i]) + 1);
	    lstrcpyA(newv[i], pathv[i]);
d1175 1
a1175 6
	    char *str;
	    TCHAR *nativeName;
	    Tcl_DString ds;
	    WIN32_FIND_DATAT data;
	    HANDLE handle;
	    DWORD attr;
d1178 5
a1182 25
	    str = Tcl_JoinPath(i + 1, pathv, &resultDString);
	    nativeName = Tcl_WinUtfToTChar(str, -1, &ds);
	    handle = (*tclWinProcs->findFirstFileProc)(nativeName, &data);
	    if (handle == INVALID_HANDLE_VALUE) {
		/*
		 * FindFirstFile() doesn't like root directories.  We 
		 * would only get a root directory here if the caller
		 * specified "c:" or "c:." and the current directory on the
		 * drive was the root directory
		 */

		attr = (*tclWinProcs->getFileAttributesProc)(nativeName);
		if ((attr != 0xFFFFFFFF) && (attr & FILE_ATTRIBUTE_DIRECTORY)) {
		    Tcl_DStringFree(&ds);
		    Tcl_DStringFree(&resultDString);

		    goto simple;
		}
	    }
	    Tcl_DStringFree(&ds);
	    Tcl_DStringFree(&resultDString);

	    if (handle == INVALID_HANDLE_VALUE) {
		pathc = i - 1;
		StatError(interp, fileName);
d1184 1
d1187 3
a1189 6
	    if (tclWinProcs->useWide) {
		nativeName = (TCHAR *) data.w.cAlternateFileName;
		if (longShort) {
		    if (data.w.cFileName[0] != '\0') {
			nativeName = (TCHAR *) data.w.cFileName;
		    } 
d1191 1
a1191 3
		    if (data.w.cAlternateFileName[0] == '\0') {
			nativeName = (TCHAR *) data.w.cFileName;
		    }
d1194 2
a1195 5
		nativeName = (TCHAR *) data.a.cAlternateFileName;
		if (longShort) {
		    if (data.a.cFileName[0] != '\0') {
			nativeName = (TCHAR *) data.a.cFileName;
		    } 
d1197 1
a1197 3
		    if (data.a.cAlternateFileName[0] == '\0') {
			nativeName = (TCHAR *) data.a.cFileName;
		    }
d1200 10
a1209 18

	    /*
	     * Purify reports a extraneous UMR in Tcl_WinTCharToUtf() trying 
	     * to dereference nativeName as a Unicode string.  I have proven 
	     * to myself that purify is wrong by running the following 
	     * example when nativeName == data.w.cAlternateFileName and 
	     * noting that purify doesn't complain about the first line,
	     * but does complain about the second.
	     *
	     *	fprintf(stderr, "%d\n", data.w.cAlternateFileName[0]);
	     *	fprintf(stderr, "%d\n", ((WCHAR *) nativeName)[0]);
	     */

	    Tcl_WinTCharToUtf(nativeName, -1, &ds);
	    newv[i] = ckalloc((unsigned int) (Tcl_DStringLength(&ds) + 1));
	    lstrcpyA(newv[i], Tcl_DStringValue(&ds));
	    Tcl_DStringFree(&ds);
	    FindClose(handle);
d1211 1
d1215 2
a1216 3
    resultStr = Tcl_JoinPath(pathc, newv, &resultDString);
    *attributePtrPtr = Tcl_NewStringObj(resultStr, 
	    Tcl_DStringLength(&resultDString));
d1220 2
a1221 2
    for (i = 0; i < pathc; i++) {
	ckfree(newv[i]);
d1223 1
a1223 2
    ckfree((char *) newv);
    ckfree((char *) pathv);
d1248 4
a1251 4
    Tcl_Interp *interp,		/* The interp we are using for errors. */
    int objIndex,		/* The index of the attribute. */
    CONST char *fileName,	/* The name of the file. */
    Tcl_Obj **attributePtrPtr)	/* A pointer to return the object with. */
d1277 4
a1280 4
    Tcl_Interp *interp,		/* The interp we are using for errors. */
    int objIndex,		/* The index of the attribute. */
    CONST char *fileName,	/* The name of the file. */
    Tcl_Obj **attributePtrPtr)	/* A pointer to return the object with. */
d1304 4
a1307 4
    Tcl_Interp *interp,		/* The interp we are using for errors. */
    int objIndex,		/* The index of the attribute. */
    CONST char *fileName,	/* The name of the file. */
    Tcl_Obj *attributePtr)	/* The new value of the attribute. */
d1309 1
a1309 1
    DWORD fileAttributes;
a1311 2
    Tcl_DString ds;
    TCHAR *nativeName;
d1313 3
a1315 7
    nativeName = Tcl_WinUtfToTChar(fileName, -1, &ds);
    fileAttributes = (*tclWinProcs->getFileAttributesProc)(nativeName);

    if (fileAttributes == 0xffffffff) {
	StatError(interp, fileName);
	result = TCL_ERROR;
	goto end;
d1320 1
a1320 1
	goto end;
d1329 3
a1331 4
    if (!(*tclWinProcs->setFileAttributesProc)(nativeName, fileAttributes)) {
	StatError(interp, fileName);
	result = TCL_ERROR;
	goto end;
d1333 1
a1333 5

    end:
    Tcl_DStringFree(&ds);

    return result;
d1355 4
a1358 4
    Tcl_Interp *interp,		/* The interp we are using for errors. */
    int objIndex,		/* The index of the attribute. */
    CONST char *fileName,	/* The name of the file. */
    Tcl_Obj *attributePtr)	/* The new value of the attribute. */
d1362 1
a1362 1
	    "\" for file \"", fileName, "\": attribute is readonly", 
d1388 1
a1388 1
    Tcl_Interp *interp)		/* Interpreter for returning volume list. */
d1391 1
a1391 1
    char buf[40 * 4];		/* There couldn't be more than 30 drives??? */
a1392 1
    char *p;
d1396 4
d1401 1
a1401 1
     * On Win32s:
d1406 5
a1410 26
    if (GetLogicalDriveStringsA(sizeof(buf), buf) == 0) {
	/*
	 * GetVolumeInformation() will detects all drives, but causes
	 * chattering on empty floppy drives.  We only do this if 
	 * GetLogicalDriveStrings() didn't work.  It has also been reported
	 * that on some laptops it takes a while for GetVolumeInformation()
	 * to return when pinging an empty floppy drive, another reason to 
	 * try to avoid calling it.
	 */

	buf[1] = ':';
	buf[2] = '/';
	buf[3] = '\0';

	for (i = 0; i < 26; i++) {
	    buf[0] = (char) ('a' + i);
	    if (GetVolumeInformationA(buf, NULL, 0, NULL, NULL, NULL, NULL, 0)  
		    || (GetLastError() == ERROR_NOT_READY)) {
		elemPtr = Tcl_NewStringObj(buf, -1);
		Tcl_ListObjAppendElement(NULL, resultPtr, elemPtr);
	    }
	}
    } else {
	for (p = buf; *p != '\0'; p += 4) {
	    p[2] = '/';
	    elemPtr = Tcl_NewStringObj(p, -1);
a1415 3



@


1.1.1.3
log
@import tcl 8.4.0
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tclWinFCmd.c,v 1.31 2002/07/15 09:53:21 vincentdarley Exp $
d31 1
a31 1
			    int objIndex, Tcl_Obj *fileName,
d34 1
a34 1
			    int objIndex, Tcl_Obj *fileName,
d37 1
a37 1
			    int objIndex, Tcl_Obj *fileName,
d40 1
a40 1
			    int objIndex, Tcl_Obj *fileName,
d43 1
a43 1
			    int objIndex, Tcl_Obj *fileName,
d63 1
a63 1
CONST char *tclpFileAttrStrings[] = {
d68 1
a68 1
CONST TclFileAttrProcs tclpFileAttrProcs[] = {
a75 5
#ifdef HAVE_NO_SEH
static void *ESP;
static void *EBP;
#endif /* HAVE_NO_SEH */

d80 1
a80 1
typedef int (TraversalProc)(CONST TCHAR *srcPtr, CONST TCHAR *dstPtr, 
d87 1
a87 1
static void		StatError(Tcl_Interp *interp, Tcl_Obj *fileName);
d89 1
a89 1
			    int objIndex, Tcl_Obj *fileName, int longShort,
d91 3
a93 5
static int		DoCopyFile(CONST TCHAR *srcPtr, CONST TCHAR *dstPtr);
static int		DoCreateDirectory(CONST TCHAR *pathPtr);
static int		DoDeleteFile(CONST TCHAR *pathPtr);
static int		DoRemoveJustDirectory(CONST TCHAR *nativeSrc, 
			    int ignoreError, Tcl_DString *errorPtr);
d96 2
a97 2
static int		DoRenameFile(CONST TCHAR *nativeSrc, CONST TCHAR *dstPtr);
static int		TraversalCopy(CONST TCHAR *srcPtr, CONST TCHAR *dstPtr, 
d99 1
a99 1
static int		TraversalDelete(CONST TCHAR *srcPtr, CONST TCHAR *dstPtr, 
d109 1
a109 1
 * TclpObjRenameFile, DoRenameFile --
d148 6
a153 4
int 
TclpObjRenameFile(srcPathPtr, destPathPtr)
    Tcl_Obj *srcPathPtr;
    Tcl_Obj *destPathPtr;
d155 11
a165 2
    return DoRenameFile(Tcl_FSGetNativePath(srcPathPtr), 
			Tcl_FSGetNativePath(destPathPtr));
d172 1
a172 1
    CONST TCHAR *nativeDst)	/* New pathname for file or directory
d175 1
a176 1
    int retval = -1;
d178 1
a178 10
    /*
     * The MoveFile API acts differently under Win95/98 and NT
     * WRT NULL and "". Avoid passing these values.
     */

    if (nativeSrc == NULL || nativeSrc[0] == '\0' ||
        nativeDst == NULL || nativeDst[0] == '\0') {
	Tcl_SetErrno(ENOENT);
	return TCL_ERROR;
    }
d181 2
a182 2
     * The MoveFile API would throw an exception under NT
     * if one of the arguments is a char block device.
d185 2
a186 10
#ifdef HAVE_NO_SEH
    __asm__ __volatile__ (
            "movl  %esp, _ESP" "\n\t"
            "movl  %ebp, _EBP");

    __asm__ __volatile__ (
            "pushl $__except_dorenamefile_handler" "\n\t"
            "pushl %fs:0" "\n\t"
            "mov   %esp, %fs:0");
#else
d188 1
a188 1
#endif /* HAVE_NO_SEH */
d190 1
a190 1
	    retval = TCL_OK;
d192 5
a196 21
#ifdef HAVE_NO_SEH
    __asm__ __volatile__ (
            "jmp   dorenamefile_pop" "\n"
            "dorenamefile_reentry:" "\n\t"
            "movl  _ESP, %esp" "\n\t"
            "movl  _EBP, %ebp");

    __asm__ __volatile__ (
            "dorenamefile_pop:" "\n\t"
            "mov   (%esp), %eax" "\n\t"
            "mov   %eax, %fs:0" "\n\t"
            "add   $8, %esp");
#else
    } __except (EXCEPTION_EXECUTE_HANDLER) {}
#endif /* HAVE_NO_SEH */

    /*
     * Avoid using control flow statements in the SEH guarded block!
     */
    if (retval != -1)
        return retval;
d310 1
a310 1
		if (DoRemoveJustDirectory(nativeDst, 0, NULL) == TCL_OK) {
a411 15
#ifdef HAVE_NO_SEH
static
__attribute__ ((cdecl))
EXCEPTION_DISPOSITION
_except_dorenamefile_handler(
    struct _EXCEPTION_RECORD *ExceptionRecord,
    void *EstablisherFrame,
    struct _CONTEXT *ContextRecord,
    void *DispatcherContext)
{
    __asm__ __volatile__ (
            "jmp dorenamefile_reentry");
    return 0; /* Function does not return */
}
#endif /* HAVE_NO_SEH */
d416 1
a416 1
 * TclpObjCopyFile, DoCopyFile --
d441 3
a443 3
TclpObjCopyFile(srcPathPtr, destPathPtr)
    Tcl_Obj *srcPathPtr;
    Tcl_Obj *destPathPtr;
d445 9
a453 2
    return DoCopyFile(Tcl_FSGetNativePath(srcPathPtr),
		      Tcl_FSGetNativePath(destPathPtr));
d458 2
a459 2
   CONST TCHAR *nativeSrc,	/* Pathname of file to be copied (native). */
   CONST TCHAR *nativeDst)	/* Pathname of file to copy to (native). */
d461 1
a461 1
    int retval = -1;
d463 2
a464 4
    /*
     * The CopyFile API acts differently under Win95/98 and NT
     * WRT NULL and "". Avoid passing these values.
     */
a465 6
    if (nativeSrc == NULL || nativeSrc[0] == '\0' ||
        nativeDst == NULL || nativeDst[0] == '\0') {
	Tcl_SetErrno(ENOENT);
	return TCL_ERROR;
    }
    
d467 2
a468 2
     * The CopyFile API would throw an exception under NT if one
     * of the arguments is a char block device.
d471 2
a472 10
#ifdef HAVE_NO_SEH
    __asm__ __volatile__ (
            "movl  %esp, _ESP" "\n\t"
            "movl  %ebp, _EBP");

    __asm__ __volatile__ (
            "pushl $__except_docopyfile_handler" "\n\t"
            "pushl %fs:0" "\n\t"
            "mov   %esp, %fs:0");
#else
a473 1
#endif /* HAVE_NO_SEH */
d475 4
a478 1
	    retval = TCL_OK;
d480 4
a483 21
#ifdef HAVE_NO_SEH
    __asm__ __volatile__ (
            "jmp   docopyfile_pop" "\n"
            "docopyfile_reentry:" "\n\t"
            "movl  _ESP, %esp" "\n\t"
            "movl  _EBP, %ebp");

    __asm__ __volatile__ (
            "docopyfile_pop:" "\n\t"
            "mov   (%esp), %eax" "\n\t"
            "mov   %eax, %fs:0" "\n\t"
            "add   $8, %esp");
#else
    } __except (EXCEPTION_EXECUTE_HANDLER) {}
#endif /* HAVE_NO_SEH */

    /*
     * Avoid using control flow statements in the SEH guarded block!
     */
    if (retval != -1)
        return retval;
a500 6
		if (srcAttr & FILE_ATTRIBUTE_REPARSE_POINT) {
		    /* Source is a symbolic link -- copy it */
		    if (TclWinSymLinkCopyDirectory(nativeSrc, nativeDst) == 0) {
		        return TCL_OK;
		    }
		}
a520 15
#ifdef HAVE_NO_SEH
static
__attribute__ ((cdecl))
EXCEPTION_DISPOSITION
_except_docopyfile_handler(
    struct _EXCEPTION_RECORD *ExceptionRecord,
    void *EstablisherFrame,
    struct _CONTEXT *ContextRecord,
    void *DispatcherContext)
{
    __asm__ __volatile__ (
            "jmp docopyfile_reentry");
    return 0; /* Function does not return */
}
#endif /* HAVE_NO_SEH */
d525 1
a525 1
 * TclpObjDeleteFile, DoDeleteFile --
d547 3
a549 3
int 
TclpObjDeleteFile(pathPtr)
    Tcl_Obj *pathPtr;
d551 7
a557 1
    return DoDeleteFile(Tcl_FSGetNativePath(pathPtr));
d562 1
a562 1
    CONST TCHAR *nativePath)	/* Pathname of file to be removed (native). */
d565 1
d567 2
a568 10
    /*
     * The DeleteFile API acts differently under Win95/98 and NT
     * WRT NULL and "". Avoid passing these values.
     */

    if (nativePath == NULL || nativePath[0] == '\0') {
	Tcl_SetErrno(ENOENT);
	return TCL_ERROR;
    }

d574 16
d594 1
a594 10
		if (attr & FILE_ATTRIBUTE_REPARSE_POINT) {
		    /* It is a symbolic link -- remove it */
		    if (TclWinSymLinkDelete(nativePath, 0) == 0) {
		        return TCL_OK;
		    }
		}
		
		/* 
		 * If we fall through here, it is a directory.
		 * 
d601 1
a601 1
		int res = (*tclWinProcs->setFileAttributesProc)(nativePath, 
d603 1
a603 2
		if ((res != 0) && ((*tclWinProcs->deleteFileProc)(nativePath)
			!= FALSE)) {
d607 1
a607 3
		if (res != 0) {
		    (*tclWinProcs->setFileAttributesProc)(nativePath, attr);
		}
d637 1
a637 1
 * TclpObjCreateDirectory --
d659 3
a661 3
int 
TclpObjCreateDirectory(pathPtr)
    Tcl_Obj *pathPtr;
d663 7
a669 1
    return DoCreateDirectory(Tcl_FSGetNativePath(pathPtr));
d674 1
a674 1
    CONST TCHAR *nativePath)	/* Pathname of directory to create (native). */
d677 3
d691 1
a691 1
 * TclpObjCopyDirectory --
d714 8
a721 5
int 
TclpObjCopyDirectory(srcPathPtr, destPathPtr, errorPtr)
    Tcl_Obj *srcPathPtr;
    Tcl_Obj *destPathPtr;
    Tcl_Obj **errorPtr;
d723 1
a723 1
    Tcl_DString ds;
a724 1
    int ret;
d726 2
a727 4
    Tcl_WinUtfToTChar(Tcl_FSGetTranslatedStringPath(NULL,srcPathPtr), 
		      -1, &srcString);
    Tcl_WinUtfToTChar(Tcl_FSGetTranslatedStringPath(NULL,destPathPtr), 
		      -1, &dstString);
d729 1
a729 1
    ret = TraverseWinTree(TraversalCopy, &srcString, &dstString, &ds);
d733 1
a733 7

    if (ret != TCL_OK) {
	*errorPtr = Tcl_NewStringObj(Tcl_DStringValue(&ds), -1);
	Tcl_DStringFree(&ds);
	Tcl_IncrRefCount(*errorPtr);
    }
    return ret;
d739 1
a739 1
 * TclpObjRemoveDirectory, DoRemoveDirectory -- 
d765 10
a774 5
int 
TclpObjRemoveDirectory(pathPtr, recursive, errorPtr)
    Tcl_Obj *pathPtr;
    int recursive;
    Tcl_Obj **errorPtr;
d776 8
a783 26
    Tcl_DString ds;
    int ret;
    if (recursive) {
	/* 
	 * In the recursive case, the string rep is used to construct a
	 * Tcl_DString which may be used extensively, so we can't
	 * optimize this case easily.
	 */
	Tcl_DString native;
	Tcl_WinUtfToTChar(Tcl_FSGetTranslatedStringPath(NULL, pathPtr), 
			  -1, &native);
	ret = DoRemoveDirectory(&native, recursive, &ds);
	Tcl_DStringFree(&native);
    } else {
	ret = DoRemoveJustDirectory(Tcl_FSGetNativePath(pathPtr), 
				    0, &ds);
    }
    if (ret != TCL_OK) {
	int len = Tcl_DStringLength(&ds);
	if (len > 0) {
	    *errorPtr = Tcl_NewStringObj(Tcl_DStringValue(&ds), -1);
	    Tcl_IncrRefCount(*errorPtr);
	}
	Tcl_DStringFree(&ds);
    }
    return ret;
d787 2
a788 2
DoRemoveJustDirectory(
    CONST TCHAR *nativePath,	/* Pathname of directory to be removed
d790 3
a792 3
    int ignoreError,		/* If non-zero, don't initialize the
                  		 * errorPtr under some circumstances
                  		 * on return. */
d797 2
a798 4
    /*
     * The RemoveDirectory API acts differently under Win95/98 and NT
     * WRT NULL and "". Avoid passing these values.
     */
d800 1
a800 4
    if (nativePath == NULL || nativePath[0] == '\0') {
	Tcl_SetErrno(ENOENT);
	goto end;
    }
d807 17
d825 1
a825 1
	DWORD attr = (*tclWinProcs->getFileAttributesProc)(nativePath);
a836 7
	    if (attr & FILE_ATTRIBUTE_REPARSE_POINT) {
		/* It is a symbolic link -- remove it */
		if (TclWinSymLinkDelete(nativePath, 1) != 0) {
		    goto end;
		}
	    }
	    
d857 1
a857 1
		CONST char *path, *find;
d863 1
a863 1
		path = (CONST char *) nativePath;
d902 4
a905 5
    if ((ignoreError != 0) && (Tcl_GetErrno() == EEXIST)) {
	/* 
	 * If we're being recursive, this error may actually
	 * be ok, so we don't want to initialise the errorPtr
	 * yet.
d907 2
a908 1
	return TCL_ERROR;
d910 1
a910 1

a915 26

}

static int
DoRemoveDirectory(
    Tcl_DString *pathPtr,	/* Pathname of directory to be removed
				 * (native). */
    int recursive,		/* If non-zero, removes directories that
				 * are nonempty.  Otherwise, will only remove
				 * empty directories. */
    Tcl_DString *errorPtr)	/* If non-NULL, uninitialized or free
				 * DString filled with UTF-8 name of file
				 * causing error. */
{
    int res = DoRemoveJustDirectory(Tcl_DStringValue(pathPtr), recursive, 
				    errorPtr);
    
    if ((res == TCL_ERROR) && (recursive != 0) && (Tcl_GetErrno() == EEXIST)) {
	/*
	 * The directory is nonempty, but the recursive flag has been
	 * specified, so we recursively remove all the files in the directory.
	 */
	return TraverseWinTree(TraversalDelete, pathPtr, NULL, errorPtr);
    } else {
	return res;
    }
d947 1
a947 2
				 * parallel with source directory (native),
				 * may be NULL. */
d953 1
a953 1
    TCHAR *nativeSource, *nativeTarget, *nativeErrfile;
a962 2
    nativeTarget = (TCHAR *) (targetPtr == NULL ? NULL : Tcl_DStringValue(targetPtr));
    
d974 1
a974 1
	return (*traverseProc)(nativeSource, nativeTarget, DOTREE_F, errorPtr);
d997 1
a997 1
    result = (*traverseProc)(nativeSource, nativeTarget, DOTREE_PRED, errorPtr);
d1099 2
a1100 3
	result = (*traverseProc)(Tcl_DStringValue(sourcePtr), 
			(targetPtr == NULL ? NULL : Tcl_DStringValue(targetPtr)), 
			DOTREE_POSTD, errorPtr);
d1133 2
a1134 2
    CONST TCHAR *nativeSrc,	/* Source pathname to copy. */
    CONST TCHAR *nativeDst,	/* Destination pathname of copy. */
d1139 3
d1144 1
a1144 1
	    if (DoCopyFile(nativeSrc, nativeDst) == TCL_OK) {
d1150 4
a1153 2
	    if (DoCreateDirectory(nativeDst) == TCL_OK) {
		DWORD attr = (*tclWinProcs->getFileAttributesProc)(nativeSrc);
d1172 1
d1201 2
a1202 2
    CONST TCHAR *nativeSrc,	/* Source pathname to delete. */
    CONST TCHAR *dstPtr,	/* Not used. */
d1207 2
d1211 1
a1211 1
	    if (DoDeleteFile(nativeSrc) == TCL_OK) {
d1220 1
a1220 1
	    if (DoRemoveJustDirectory(nativeSrc, 0, NULL) == TCL_OK) {
d1228 1
d1254 1
a1254 1
    Tcl_Obj *fileName)	        /* The name of the file which caused the 
d1259 2
a1260 3
			   "could not read \"", Tcl_GetString(fileName), 
			   "\": ", Tcl_PosixError(interp), 
			   (char *) NULL);
d1286 1
a1286 1
    Tcl_Obj *fileName,	        /* The name of the file. */
d1290 4
a1293 4
    CONST TCHAR *nativeName;
    int attr;
    
    nativeName = Tcl_FSGetNativePath(fileName);
d1295 1
d1302 1
a1302 28
    attr = (int)(result & attributeArray[objIndex]);
    if ((objIndex == WIN_HIDDEN_ATTRIBUTE) && (attr != 0)) {
	/* 
	 * It is hidden.  However there is a bug on some Windows
	 * OSes in which root volumes (drives) formatted as NTFS
	 * are declared hidden when they are not (and cannot be).
	 * 
	 * We test for, and fix that case, here.
	 */
	int len;
	char *str = Tcl_GetStringFromObj(fileName,&len);
	if (len < 4) {
	    if (len == 0) {
		/* 
		 * Not sure if this is possible, but we pass it on
		 * anyway 
		 */
	    } else if (len == 1 && (str[0] == '/' || str[0] == '\\')) {
		/* Path is pointing to the root volume */
		attr = 0;
	    } else if ((str[1] == ':') 
		       && (len == 2 || (str[2] == '/' || str[2] == '\\'))) {
		/* Path is of the form 'x:' or 'x:/' or 'x:\' */
		attr = 0;
	    }
	}
    }
    *attributePtrPtr = Tcl_NewBooleanObj(attr);
a1317 5
 *	
 *	Warning: if you pass this function a drive name like 'c:' it
 *	will actually return the current working directory on that
 *	drive.  To avoid this, make sure the drive name ends in a
 *	slash, like this 'c:/'.
d1329 1
a1329 1
    Tcl_Obj *fileName,   	/* The name of the file. */
d1334 3
a1336 1
    Tcl_Obj *splitPath;
d1339 2
a1340 1
    splitPath = Tcl_FSSplitPath(fileName, &pathc);
d1342 3
a1344 4
    if (splitPath == NULL || pathc == 0) {
	if (interp != NULL) {
	    Tcl_AppendStringsToObj(Tcl_GetObjResult(interp), 
		"could not read \"", Tcl_GetString(fileName),
a1346 1
	}
d1352 4
a1355 10
	Tcl_Obj *elt;
	char *pathv;
	int pathLen;
	Tcl_ListObjIndex(NULL, splitPath, i, &elt);
	
	pathv = Tcl_GetStringFromObj(elt, &pathLen);
	if ((pathv[0] == '/')
		|| ((pathLen == 3) && (pathv[1] == ':'))
		|| (strcmp(pathv, ".") == 0)
		|| (strcmp(pathv, "..") == 0)) {
d1363 3
a1365 4
	    /* Here we are modifying the string representation in place */
	    /* I believe this is legal, since this won't affect any 
	     * file representation this thing may have. */
	    pathv[0] = (char) Tcl_UniCharToUpper(UCHAR(pathv[0]));
d1367 2
a1368 1
	    Tcl_Obj *tempPath;
a1369 4
	    Tcl_DString dsTemp;
	    TCHAR *nativeName;
	    char *tempString;
	    int tempLen;
d1374 3
a1376 10
	    tempPath = Tcl_FSJoinPath(splitPath, i+1);
	    Tcl_IncrRefCount(tempPath);
	    /* 
	     * We'd like to call Tcl_FSGetNativePath(tempPath)
	     * but that is likely to lead to infinite loops 
	     */
	    Tcl_DStringInit(&ds);
	    tempString = Tcl_GetStringFromObj(tempPath,&tempLen);
	    nativeName = Tcl_WinUtfToTChar(tempString, tempLen, &ds);
	    Tcl_DecrRefCount(tempPath);
d1389 2
d1394 2
d1398 2
a1399 4
		Tcl_DStringFree(&ds);
		if (interp != NULL) {
		    StatError(interp, fileName);
		}
d1439 3
a1441 12
	    Tcl_DStringInit(&dsTemp);
	    Tcl_WinTCharToUtf(nativeName, -1, &dsTemp);
	    /* Deal with issues of tildes being absolute */
	    if (Tcl_DStringValue(&dsTemp)[0] == '~') {
		tempPath = Tcl_NewStringObj("./",2);
		Tcl_AppendToObj(tempPath, Tcl_DStringValue(&dsTemp), 
				Tcl_DStringLength(&dsTemp));
	    } else {
		tempPath = Tcl_NewStringObj(Tcl_DStringValue(&dsTemp), 
					    Tcl_DStringLength(&dsTemp));
	    }
	    Tcl_ListObjReplace(NULL, splitPath, i, 1, 1, &tempPath);
a1442 1
	    Tcl_DStringFree(&dsTemp);
d1447 5
a1451 1
    *attributePtrPtr = Tcl_FSJoinPath(splitPath, -1);
d1454 2
a1455 2
    if (splitPath != NULL) {
	Tcl_DecrRefCount(splitPath);
d1457 2
a1458 1
  
d1467 1
a1467 1
 *      Returns a Tcl_Obj containing the long version of the file
d1485 1
a1485 1
    Tcl_Obj *fileName,  	/* The name of the file. */
d1514 1
a1514 1
    Tcl_Obj *fileName,  	/* The name of the file. */
d1541 1
a1541 1
    Tcl_Obj *fileName,  	/* The name of the file. */
d1547 2
a1548 1
    CONST TCHAR *nativeName;
d1550 1
a1550 1
    nativeName = Tcl_FSGetNativePath(fileName);
d1555 2
a1556 1
	return TCL_ERROR;
d1561 1
a1561 1
	return result;
d1572 2
a1573 1
	return TCL_ERROR;
d1576 3
d1594 1
a1594 1
 *      The object result is set to a pertinent error message.
d1603 1
a1603 1
    Tcl_Obj *fileName,	        /* The name of the file. */
d1608 1
a1608 2
	    "\" for file \"", Tcl_GetString(fileName), 
	    "\": attribute is readonly", 
d1617 1
a1617 1
 * TclpObjListVolumes --
d1622 3
a1624 1
 *	The list of volumes.
d1632 3
a1634 2
Tcl_Obj*
TclpObjListVolumes(void)
d1641 1
a1641 1
    resultPtr = Tcl_NewObj();
d1678 1
a1678 3
    
    Tcl_IncrRefCount(resultPtr);
    return resultPtr;
d1680 3
@


