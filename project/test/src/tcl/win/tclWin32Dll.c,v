head	1.12;
access;
symbols
	sid-snapshot-20180601:1.12
	sid-snapshot-20180501:1.12
	sid-snapshot-20180401:1.12
	sid-snapshot-20180301:1.12
	sid-snapshot-20180201:1.12
	sid-snapshot-20180101:1.12
	sid-snapshot-20171201:1.12
	sid-snapshot-20171101:1.12
	sid-snapshot-20171001:1.12
	sid-snapshot-20170901:1.12
	sid-snapshot-20170801:1.12
	sid-snapshot-20170701:1.12
	sid-snapshot-20170601:1.12
	sid-snapshot-20170501:1.12
	sid-snapshot-20170401:1.12
	sid-snapshot-20170301:1.12
	sid-snapshot-20170201:1.12
	sid-snapshot-20170101:1.12
	sid-snapshot-20161201:1.12
	sid-snapshot-20161101:1.12
	sid-snapshot-20160901:1.12
	sid-snapshot-20160801:1.12
	sid-snapshot-20160701:1.12
	sid-snapshot-20160601:1.12
	sid-snapshot-20160501:1.12
	sid-snapshot-20160401:1.12
	sid-snapshot-20160301:1.12
	sid-snapshot-20160201:1.12
	sid-snapshot-20160101:1.12
	sid-snapshot-20151201:1.12
	sid-snapshot-20151101:1.12
	sid-snapshot-20151001:1.12
	sid-snapshot-20150901:1.12
	sid-snapshot-20150801:1.12
	sid-snapshot-20150701:1.12
	sid-snapshot-20150601:1.12
	sid-snapshot-20150501:1.12
	sid-snapshot-20150401:1.12
	sid-snapshot-20150301:1.12
	sid-snapshot-20150201:1.12
	sid-snapshot-20150101:1.12
	sid-snapshot-20141201:1.12
	sid-snapshot-20141101:1.12
	sid-snapshot-20141001:1.12
	sid-snapshot-20140901:1.12
	sid-snapshot-20140801:1.12
	sid-snapshot-20140701:1.12
	sid-snapshot-20140601:1.12
	sid-snapshot-20140501:1.12
	sid-snapshot-20140401:1.12
	sid-snapshot-20140301:1.12
	sid-snapshot-20140201:1.12
	sid-snapshot-20140101:1.12
	sid-snapshot-20131201:1.12
	sid-snapshot-20131101:1.12
	sid-snapshot-20131001:1.12
	sid-snapshot-20130901:1.12
	sid-snapshot-20130801:1.12
	sid-snapshot-20130701:1.12
	sid-snapshot-20130601:1.12
	insight_7_6-2013-04-10-branchpoint:1.12
	gdb_7_6-branch:1.12.0.18
	sid-snapshot-20130501:1.12
	sid-snapshot-20130401:1.12
	sid-snapshot-20130301:1.12
	sid-snapshot-20130201:1.12
	sid-snapshot-20130101:1.12
	sid-snapshot-20121201:1.12
	sid-snapshot-20121101:1.12
	sid-snapshot-20121001:1.12
	sid-snapshot-20120901:1.12
	gdb_7_5-branch:1.12.0.16
	sid-snapshot-20120801:1.12
	sid-snapshot-20120701:1.12
	sid-snapshot-20120601:1.12
	sid-snapshot-20120501:1.12
	sid-snapshot-20120401:1.12
	gdb_7_4-branch:1.12.0.14
	sid-snapshot-20120301:1.12
	sid-snapshot-20120201:1.12
	sid-snapshot-20120101:1.12
	sid-snapshot-20111201:1.12
	sid-snapshot-20111101:1.12
	sid-snapshot-20111001:1.12
	sid-snapshot-20110901:1.12
	gdb_7_3-branch:1.12.0.12
	sid-snapshot-20110801:1.12
	sid-snapshot-20110701:1.12
	sid-snapshot-20110601:1.12
	sid-snapshot-20110501:1.12
	sid-snapshot-20110401:1.12
	sid-snapshot-20110301:1.12
	sid-snapshot-20110201:1.12
	sid-snapshot-20110101:1.12
	sid-snapshot-20101201:1.12
	sid-snapshot-20101101:1.12
	sid-snapshot-20101001:1.12
	sid-snapshot-20100901:1.12
	sid-snapshot-20100801:1.12
	sid-snapshot-20100701:1.12
	sid-snapshot-20100601:1.12
	sid-snapshot-20100501:1.12
	sid-snapshot-20100401:1.12
	sid-snapshot-20100301:1.12
	gdb_7_1-branch:1.12.0.10
	gdb_7_0-branch:1.12.0.8
	sid-snapshot-20100201:1.12
	sid-snapshot-20100101:1.12
	sid-snapshot-20091201:1.12
	sid-snapshot-20091101:1.12
	sid-snapshot-20091001:1.12
	arc-sim-20090309:1.12
	sid-snapshot-20090901:1.12
	sid-snapshot-20090801:1.12
	sid-snapshot-20090701:1.12
	sid-snapshot-20090601:1.12
	sid-snapshot-20090501:1.12
	kevinb-pre-tcl8_5_7_merge:1.12
	sid-snapshot-20090401:1.12
	arc-insight_6_8-branch:1.12.0.6
	arc-insight_6_8-branchpoint:1.12
	insight_6_8-branch:1.12.0.4
	insight_6_8-branchpoint:1.12
	sid-snapshot-20090301:1.12
	sid-snapshot-20090201:1.12
	sid-snapshot-20090101:1.12
	sid-snapshot-20081201:1.12
	sid-snapshot-20081101:1.12
	sid-snapshot-20081001:1.12
	sid-snapshot-20080901:1.12
	sid-snapshot-20080801:1.12
	sid-snapshot-20080701:1.12
	sid-snapshot-20080601:1.12
	sid-snapshot-20080501:1.12
	sid-snapshot-20080403:1.12
	sid-snapshot-20080401:1.12
	gdb_6_8-branch:1.12.0.2
	sid-snapshot-20080301:1.11
	sid-snapshot-20080201:1.11
	sid-snapshot-20080101:1.11
	sid-snapshot-20071201:1.11
	sid-snapshot-20071101:1.11
	sid-snapshot-20071001:1.11
	insight_6_6-20070208-release:1.10.6.1
	gdb_6_6-branch:1.10.0.6
	gdb_6_6-2006-11-15-branchpoint:1.10
	insight_6_5-20061003-release:1.10
	gdb_6_5-branch:1.10.0.4
	gdb_6_5-2006-05-14-branchpoint:1.10
	readline_5_1-import-branch:1.10.0.2
	readline_5_1-import-branchpoint:1.10
	gdb_6_4-branch:1.9.0.34
	gdb_6_4-2005-11-01-branchpoint:1.9
	msnyder-tracepoint-checkpoint-branch:1.9.0.32
	msnyder-tracepoint-checkpoint-branchpoint:1.9
	gdb_6_1-2004-04-05-release:1.9
	ezannoni_pie-20040323-branch:1.9.0.30
	ezannoni_pie-20040323-branchpoint:1.9
	cagney_tramp-20040321-mergepoint:1.9
	cagney_tramp-20040309-branch:1.9.0.28
	cagney_tramp-20040309-branchpoint:1.9
	gdb_6_1-branch:1.9.0.26
	gdb_6_1-2004-03-01-gmt-branchpoint:1.9
	drow-cplus-merge-20040208:1.9
	carlton_dictionary-20040126-merge:1.9
	drow-cplus-merge-20040113:1.9
	drow-cplus-merge-20031224:1.9
	drow-cplus-merge-20031220:1.9
	carlton_dictionary-20031215-merge:1.9
	drow-cplus-merge-20031214:1.9
	carlton-dictionary-20031111-merge:1.9
	gdb_6_0-2003-10-04-release:1.9
	carlton_dictionary-20030917-merge:1.9
	ezannoni_pie-20030916-branchpoint:1.9
	ezannoni_pie-20030916-branch:1.9.0.24
	cagney_x86i386-20030821-branch:1.9.0.22
	cagney_x86i386-20030821-branchpoint:1.9
	carlton_dictionary-20030805-merge:1.9
	carlton_dictionary-20030627-merge:1.9
	gdb_6_0-branch:1.9.0.20
	gdb_6_0-2003-06-23-branchpoint:1.9
	cagney_convert-20030606-branch:1.9.0.18
	cagney_convert-20030606-branchpoint:1.9
	cagney_writestrings-20030508-branch:1.9.0.16
	cagney_writestrings-20030508-branchpoint:1.9
	carlton_dictionary-20030523-merge:1.9
	cagney_fileio-20030521-branch:1.9.0.14
	cagney_fileio-20030521-branchpoint:1.9
	carlton_dictionary-20030430-merge:1.9
	carlton_dictionary-20030416-merge:1.9
	cagney_frameaddr-20030409-mergepoint:1.9
	cagney_frameaddr-20030403-branchpoint:1.9
	cagney_frameaddr-20030403-branch:1.9.0.12
	cagney_framebase-20030330-mergepoint:1.9
	cagney_framebase-20030326-branch:1.9.0.10
	cagney_framebase-20030326-branchpoint:1.9
	cagney_lazyid-20030317-branch:1.9.0.8
	cagney_lazyid-20030317-branchpoint:1.9
	offbyone-20030313-branch:1.9.0.6
	offbyone-20030313-branchpoint:1.9
	carlton_dictionary-20030305-merge:1.9
	cagney_offbyone-20030303-branch:1.9.0.4
	cagney_offbyone-20030303-branchpoint:1.9
	carlton_dictionary-20030207-merge:1.9
	interps-20030202-branch:1.9.0.2
	interps-20030202-branchpoint:1.9
	TCL8_4_1:1.1.1.4
	cagney-unwind-20030108-branch:1.8.0.2
	cagney-unwind-20030108-branchpoint:1.8
	carlton_dictionary-20021223-merge:1.8
	gdb_5_3-2002-12-12-release:1.4
	TCL_8_4_1:1.1.1.4
	carlton_dictionary-20021115-merge:1.7
	kseitz_interps-20021105-merge:1.7
	kseitz_interps-20021103-merge:1.7
	drow-cplus-merge-20021020:1.7
	drow-cplus-merge-20021025:1.7
	carlton_dictionary-20021025-merge:1.7
	carlton_dictionary-20021011-merge:1.7
	drow-cplus-branch:1.6.0.4
	drow-cplus-branchpoint:1.6
	kseitz_interps-20020930-merge:1.6
	carlton_dictionary-20020927-merge:1.6
	tcltk840-20020924-branch:1.6.0.2
	tcltk840-20020924-branchpoint:1.6
	TCL_8_4_0:1.1.1.4
	carlton_dictionary-branch:1.5.0.2
	carlton_dictionary-20020920-branchpoint:1.5
	sid-20020905-branchpoint:1.4
	sid-20020905-branch:1.4.0.14
	gdb_5_3-branch:1.4.0.12
	gdb_5_3-2002-09-04-branchpoint:1.4
	kseitz_interps-20020829-merge:1.4
	cagney_sysregs-20020825-branch:1.4.0.10
	cagney_sysregs-20020825-branchpoint:1.4
	readline_4_3-import-branch:1.4.0.8
	readline_4_3-import-branchpoint:1.4
	gdb_5_2_1-2002-07-23-release:1.4
	kseitz_interps-20020528-branch:1.4.0.6
	kseitz_interps-20020528-branchpoint:1.4
	cagney_regbuf-20020515-branch:1.4.0.4
	cagney_regbuf-20020515-branchpoint:1.4
	gdb_5_2-2002-04-29-release:1.4
	gdb_5_2-branch:1.4.0.2
	gdb_5_2-2002-03-03-branchpoint:1.4
	gdb_5_1_1-2002-01-24-release:1.2
	cygnus_cvs_20020108_pre:1.4
	gdb_5_1_0_1-2002-01-03-branch:1.2.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.2
	gdb_5_1-2001-11-21-release:1.2
	gdb_s390-2001-09-26-branch:1.2.0.4
	gdb_s390-2001-09-26-branchpoint:1.2
	TCL_8_3:1.1.1.3
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.2.0.2
	gdb_5_1-2001-07-29-branchpoint:1.2
	insight-precleanup-2001-01-01:1.1.1.2
	gdb_5_0-2000-05-19-release:1.1.1.2
	gdb_4_18_2-2000-05-18-release:1.1.1.2
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.2
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.2
	gdb_5_0-2000-04-10-branch:1.1.1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.2
	repo-unification-2000-02-06:1.1.1.2
	dejagnu-2000-02-04:1.1.1.2
	dejagnu-2000-01-31:1.1.1.2
	dejagnu-2000-01-24:1.1.1.1
	dejagnu-2000-01-17:1.1.1.1
	dejagnu-2000-01-10:1.1.1.1
	dejagnu-2000-01-04:1.1.1.1
	dejagnu-1999-12-21:1.1.1.1
	dejagnu-1999-12-13:1.1.1.1
	dejagnu-1999-12-07:1.1.1.1
	dejagnu-1999-12-06:1.1.1.1
	dejagnu-1999-11-15:1.1.1.1
	dejagnu-1999-11-08:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.12
date	2008.03.03.23.26.42;	author kseitz;	state Exp;
branches;
next	1.11;

1.11
date	2006.12.01.20.35.55;	author corinna;	state Exp;
branches;
next	1.10;

1.10
date	2006.02.02.20.02.09;	author cgf;	state Exp;
branches
	1.10.6.1;
next	1.9;

1.9
date	2003.01.21.19.40.22;	author hunt;	state Exp;
branches;
next	1.8;

1.8
date	2002.11.26.19.48.06;	author hunt;	state Exp;
branches;
next	1.7;

1.7
date	2002.10.06.20.00.35;	author cgf;	state Exp;
branches;
next	1.6;

1.6
date	2002.09.24.18.37.11;	author kseitz;	state Exp;
branches
	1.6.2.1
	1.6.4.1;
next	1.5;

1.5
date	2002.09.13.14.40.59;	author kseitz;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2001.09.09.23.56.10;	author irox;	state Exp;
branches
	1.4.6.1;
next	1.3;

1.3
date	2001.09.09.23.26.07;	author irox;	state Exp;
branches;
next	1.2;

1.2
date	2001.04.10.20.08.27;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.10.6.1
date	2007.02.09.03.55.41;	author kseitz;	state Exp;
branches;
next	;

1.6.2.1
date	2002.09.27.21.49.14;	author kseitz;	state Exp;
branches;
next	;

1.6.4.1
date	2002.10.26.17.12.36;	author drow;	state Exp;
branches;
next	1.6.4.2;

1.6.4.2
date	2003.12.14.20.28.52;	author drow;	state Exp;
branches;
next	;

1.5.2.1
date	2002.10.11.22.23.12;	author carlton;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2002.12.23.19.40.56;	author carlton;	state Exp;
branches;
next	1.5.2.3;

1.5.2.3
date	2003.02.07.19.18.24;	author carlton;	state Exp;
branches;
next	;

1.4.6.1
date	2002.10.01.00.46.58;	author kseitz;	state Exp;
branches;
next	1.4.6.2;

1.4.6.2
date	2002.11.03.21.48.43;	author ezannoni;	state Exp;
branches;
next	;

1.1.1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.02.01.03.15.29;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.09.09.22.41.00;	author irox;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.09.24.19.56.43;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.12
log
@        From Dave Murphy  <davem@@devkitpro.org>:
        * win/tclWin32Dll.c (TclpCheckStackSpace): Backport
        EXCEPTION_REGISTRATION code from Tcl mainline.
@
text
@/* 
 * tclWin32Dll.c --
 *
 *	This file contains the DLL entry point.
 *
 * Copyright (c) 1995-1996 Sun Microsystems, Inc.
 * Copyright (c) 1998-2000 Scriptics Corporation.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tclWin32Dll.c,v 1.16 2002/06/13 09:40:01 vincentdarley Exp $
 */

#include "tclWinInt.h"
#ifdef __CYGWIN__
#include <sys/cygwin.h>
#endif

/*
 * The following data structures are used when loading the thunking 
 * library for execing child processes under Win32s.
 */

typedef DWORD (WINAPI UT32PROC)(LPVOID lpBuff, DWORD dwUserDefined,
	LPVOID *lpTranslationList);

typedef BOOL (WINAPI UTREGISTER)(HANDLE hModule, LPCSTR SixteenBitDLL,
	LPCSTR InitName, LPCSTR ProcName, UT32PROC **ThirtyTwoBitThunk,
	FARPROC UT32Callback, LPVOID Buff);

typedef VOID (WINAPI UTUNREGISTER)(HANDLE hModule);

/* 
 * The following variables keep track of information about this DLL
 * on a per-instance basis.  Each time this DLL is loaded, it gets its own 
 * new data segment with its own copy of all static and global information.
 */

static HINSTANCE hInstance;	/* HINSTANCE of this DLL. */
static int platformId;		/* Running under NT, or 95/98? */

#ifdef HAVE_NO_SEH
/*
 * Unlike Borland and Microsoft, we don't register exception handlers by
 * pushing registration records onto the runtime stack. Instead, we register
 * them by creating an EXCEPTION_REGISTRATION within the activation record.
 */

typedef struct EXCEPTION_REGISTRATION {
    struct EXCEPTION_REGISTRATION *link;
    EXCEPTION_DISPOSITION (*handler)(
	    struct _EXCEPTION_RECORD*, void*, struct _CONTEXT*, void*);
    void *ebp;
    void *esp;
    int status;
} EXCEPTION_REGISTRATION;
#endif

/*
 * The following function tables are used to dispatch to either the
 * wide-character or multi-byte versions of the operating system calls,
 * depending on whether the Unicode calls are available.
 */

static TclWinProcs asciiProcs = {
    0,

    (BOOL (WINAPI *)(CONST TCHAR *, LPDCB)) BuildCommDCBA,
    (TCHAR *(WINAPI *)(TCHAR *)) CharLowerA,
    (BOOL (WINAPI *)(CONST TCHAR *, CONST TCHAR *, BOOL)) CopyFileA,
    (BOOL (WINAPI *)(CONST TCHAR *, LPSECURITY_ATTRIBUTES)) CreateDirectoryA,
    (HANDLE (WINAPI *)(CONST TCHAR *, DWORD, DWORD, SECURITY_ATTRIBUTES *, 
	    DWORD, DWORD, HANDLE)) CreateFileA,
    (BOOL (WINAPI *)(CONST TCHAR *, TCHAR *, LPSECURITY_ATTRIBUTES, 
	    LPSECURITY_ATTRIBUTES, BOOL, DWORD, LPVOID, CONST TCHAR *, 
	    LPSTARTUPINFOA, LPPROCESS_INFORMATION)) CreateProcessA,
    (BOOL (WINAPI *)(CONST TCHAR *)) DeleteFileA,
    (HANDLE (WINAPI *)(CONST TCHAR *, WIN32_FIND_DATAT *)) FindFirstFileA,
    (BOOL (WINAPI *)(HANDLE, WIN32_FIND_DATAT *)) FindNextFileA,
    (BOOL (WINAPI *)(WCHAR *, LPDWORD)) GetComputerNameA,
    (DWORD (WINAPI *)(DWORD, WCHAR *)) GetCurrentDirectoryA,
    (DWORD (WINAPI *)(CONST TCHAR *)) GetFileAttributesA,
    (DWORD (WINAPI *)(CONST TCHAR *, DWORD nBufferLength, WCHAR *, 
	    TCHAR **)) GetFullPathNameA,
    (DWORD (WINAPI *)(HMODULE, WCHAR *, int)) GetModuleFileNameA,
    (DWORD (WINAPI *)(CONST TCHAR *, WCHAR *, DWORD)) GetShortPathNameA,
    (UINT (WINAPI *)(CONST TCHAR *, CONST TCHAR *, UINT uUnique, 
	    WCHAR *)) GetTempFileNameA,
    (DWORD (WINAPI *)(DWORD, WCHAR *)) GetTempPathA,
    (BOOL (WINAPI *)(CONST TCHAR *, WCHAR *, DWORD, LPDWORD, LPDWORD, LPDWORD,
	    WCHAR *, DWORD)) GetVolumeInformationA,
    (HINSTANCE (WINAPI *)(CONST TCHAR *)) LoadLibraryA,
    (TCHAR (WINAPI *)(WCHAR *, CONST TCHAR *)) lstrcpyA,
    (BOOL (WINAPI *)(CONST TCHAR *, CONST TCHAR *)) MoveFileA,
    (BOOL (WINAPI *)(CONST TCHAR *)) RemoveDirectoryA,
    (DWORD (WINAPI *)(CONST TCHAR *, CONST TCHAR *, CONST TCHAR *, DWORD, 
	    WCHAR *, TCHAR **)) SearchPathA,
    (BOOL (WINAPI *)(CONST TCHAR *)) SetCurrentDirectoryA,
    (BOOL (WINAPI *)(CONST TCHAR *, DWORD)) SetFileAttributesA,
    NULL,
    NULL,
};

static TclWinProcs unicodeProcs = {
    1,

    (BOOL (WINAPI *)(CONST TCHAR *, LPDCB)) BuildCommDCBW,
    (TCHAR *(WINAPI *)(TCHAR *)) CharLowerW,
    (BOOL (WINAPI *)(CONST TCHAR *, CONST TCHAR *, BOOL)) CopyFileW,
    (BOOL (WINAPI *)(CONST TCHAR *, LPSECURITY_ATTRIBUTES)) CreateDirectoryW,
    (HANDLE (WINAPI *)(CONST TCHAR *, DWORD, DWORD, SECURITY_ATTRIBUTES *, 
	    DWORD, DWORD, HANDLE)) CreateFileW,
    (BOOL (WINAPI *)(CONST TCHAR *, TCHAR *, LPSECURITY_ATTRIBUTES, 
	    LPSECURITY_ATTRIBUTES, BOOL, DWORD, LPVOID, CONST TCHAR *, 
	    LPSTARTUPINFOA, LPPROCESS_INFORMATION)) CreateProcessW,
    (BOOL (WINAPI *)(CONST TCHAR *)) DeleteFileW,
    (HANDLE (WINAPI *)(CONST TCHAR *, WIN32_FIND_DATAT *)) FindFirstFileW,
    (BOOL (WINAPI *)(HANDLE, WIN32_FIND_DATAT *)) FindNextFileW,
    (BOOL (WINAPI *)(WCHAR *, LPDWORD)) GetComputerNameW,
    (DWORD (WINAPI *)(DWORD, WCHAR *)) GetCurrentDirectoryW,
    (DWORD (WINAPI *)(CONST TCHAR *)) GetFileAttributesW,
    (DWORD (WINAPI *)(CONST TCHAR *, DWORD nBufferLength, WCHAR *, 
	    TCHAR **)) GetFullPathNameW,
    (DWORD (WINAPI *)(HMODULE, WCHAR *, int)) GetModuleFileNameW,
    (DWORD (WINAPI *)(CONST TCHAR *, WCHAR *, DWORD)) GetShortPathNameW,
    (UINT (WINAPI *)(CONST TCHAR *, CONST TCHAR *, UINT uUnique, 
	    WCHAR *)) GetTempFileNameW,
    (DWORD (WINAPI *)(DWORD, WCHAR *)) GetTempPathW,
    (BOOL (WINAPI *)(CONST TCHAR *, WCHAR *, DWORD, LPDWORD, LPDWORD, LPDWORD, 
	    WCHAR *, DWORD)) GetVolumeInformationW,
    (HINSTANCE (WINAPI *)(CONST TCHAR *)) LoadLibraryW,
    (TCHAR (WINAPI *)(WCHAR *, CONST TCHAR *)) lstrcpyW,
    (BOOL (WINAPI *)(CONST TCHAR *, CONST TCHAR *)) MoveFileW,
    (BOOL (WINAPI *)(CONST TCHAR *)) RemoveDirectoryW,
    (DWORD (WINAPI *)(CONST TCHAR *, CONST TCHAR *, CONST TCHAR *, DWORD, 
	    WCHAR *, TCHAR **)) SearchPathW,
    (BOOL (WINAPI *)(CONST TCHAR *)) SetCurrentDirectoryW,
    (BOOL (WINAPI *)(CONST TCHAR *, DWORD)) SetFileAttributesW,
    NULL,
    NULL,
};

TclWinProcs *tclWinProcs;
static Tcl_Encoding tclWinTCharEncoding;

/*
 * The following declaration is for the VC++ DLL entry point.
 */

BOOL APIENTRY		DllMain(HINSTANCE hInst, DWORD reason, 
				LPVOID reserved);


#ifdef __WIN32__
#ifndef STATIC_BUILD


/*
 *----------------------------------------------------------------------
 *
 * DllEntryPoint --
 *
 *	This wrapper function is used by Borland to invoke the
 *	initialization code for Tcl.  It simply calls the DllMain
 *	routine.
 *
 * Results:
 *	See DllMain.
 *
 * Side effects:
 *	See DllMain.
 *
 *----------------------------------------------------------------------
 */

BOOL APIENTRY
DllEntryPoint(hInst, reason, reserved)
    HINSTANCE hInst;		/* Library instance handle. */
    DWORD reason;		/* Reason this function is being called. */
    LPVOID reserved;		/* Not used. */
{
    return DllMain(hInst, reason, reserved);
}

/*
 *----------------------------------------------------------------------
 *
 * DllMain --
 *
 *	This routine is called by the VC++ C run time library init
 *	code, or the DllEntryPoint routine.  It is responsible for
 *	initializing various dynamically loaded libraries.
 *
 * Results:
 *	TRUE on sucess, FALSE on failure.
 *
 * Side effects:
 *	Establishes 32-to-16 bit thunk and initializes sockets library.
 *
 *----------------------------------------------------------------------
 */
BOOL APIENTRY
DllMain(hInst, reason, reserved)
    HINSTANCE hInst;		/* Library instance handle. */
    DWORD reason;		/* Reason this function is being called. */
    LPVOID reserved;		/* Not used. */
{
    switch (reason) {
    case DLL_PROCESS_ATTACH:
	TclWinInit(hInst);
	return TRUE;

    case DLL_PROCESS_DETACH:
	if (hInst == hInstance) {
	    Tcl_Finalize();
	}
	break;
    }

    return TRUE; 
}

#endif /* !STATIC_BUILD */
#endif /* __WIN32__ */

/*
 *----------------------------------------------------------------------
 *
 * TclWinGetTclInstance --
 *
 *	Retrieves the global library instance handle.
 *
 * Results:
 *	Returns the global library instance handle.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

HINSTANCE
TclWinGetTclInstance()
{
    return hInstance;
}

/*
 *----------------------------------------------------------------------
 *
 * TclWinInit --
 *
 *	This function initializes the internal state of the tcl library.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Initializes the tclPlatformId variable.
 *
 *----------------------------------------------------------------------
 */

void
TclWinInit(hInst)
    HINSTANCE hInst;		/* Library instance handle. */
{
    OSVERSIONINFO os;

    hInstance = hInst;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&os);
    platformId = os.dwPlatformId;

    /*
     * We no longer support Win32s, so just in case someone manages to
     * get a runtime there, make sure they know that.
     */

    if (platformId == VER_PLATFORM_WIN32s) {
	panic("Win32s is not a supported platform");	
    }

#ifdef __CYGWIN__
    {
      char cwd_posix[MAX_PATH], cwd_win32[MAX_PATH];
      cygwin_conv_to_full_win32_path (getcwd (cwd_posix, MAX_PATH), cwd_win32);
      SetCurrentDirectory (cwd_win32);
    }
#endif

    tclWinProcs = &asciiProcs;
}

/*
 *----------------------------------------------------------------------
 *
 * TclWinGetPlatformId --
 *
 *	Determines whether running under NT, 95, or Win32s, to allow 
 *	runtime conditional code.
 *
 * Results:
 *	The return value is one of:
 *	    VER_PLATFORM_WIN32s		Win32s on Windows 3.1. (not supported)
 *	    VER_PLATFORM_WIN32_WINDOWS	Win32 on Windows 95.
 *	    VER_PLATFORM_WIN32_NT	Win32 on Windows NT
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int		
TclWinGetPlatformId()
{
    return platformId;
}

/*
 *-------------------------------------------------------------------------
 *
 * TclWinNoBackslash --
 *
 *	We're always iterating through a string in Windows, changing the
 *	backslashes to slashes for use in Tcl.
 *
 * Results:
 *	All backslashes in given string are changed to slashes.
 *
 * Side effects:
 *	None.
 *
 *-------------------------------------------------------------------------
 */

char *
TclWinNoBackslash(
    char *path)			/* String to change. */
{
    char *p;

    for (p = path; *p != '\0'; p++) {
	if (*p == '\\') {
	    *p = '/';
	}
    }
    return path;
}

/*
 *----------------------------------------------------------------------
 *
 * TclpCheckStackSpace --
 *
 *	Detect if we are about to blow the stack.  Called before an 
 *	evaluation can happen when nesting depth is checked.
 *
 * Results:
 *	1 if there is enough stack space to continue; 0 if not.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
TclpCheckStackSpace()
{

#ifdef HAVE_NO_SEH
    EXCEPTION_REGISTRATION registration;
#endif
    int retval = 0;

    /*
     * We can recurse only if there is at least TCL_WIN_STACK_THRESHOLD bytes
     * of stack space left. alloca() is cheap on windows; basically it just
     * subtracts from the stack pointer causing the OS to throw an exception
     * if the stack pointer is set below the bottom of the stack.
     */

#ifdef HAVE_NO_SEH
    __asm__ __volatile__ (

	/*
	 * Construct an EXCEPTION_REGISTRATION to protect the call to __alloca
	 */

	"leal	%[registration], %%edx"		"\n\t"
	"movl	%%fs:0,		%%eax"		"\n\t"
	"movl	%%eax,		0x0(%%edx)"	"\n\t" /* link */
	"leal	1f,		%%eax"		"\n\t"
	"movl	%%eax,		0x4(%%edx)"	"\n\t" /* handler */
	"movl	%%ebp,		0x8(%%edx)"	"\n\t" /* ebp */
	"movl	%%esp,		0xc(%%edx)"	"\n\t" /* esp */
	"movl	%[error],	0x10(%%edx)"	"\n\t" /* status */

	/*
	 * Link the EXCEPTION_REGISTRATION on the chain
	 */

	"movl	%%edx,		%%fs:0"		"\n\t"

	/*
	 * Attempt a call to __alloca, to determine whether there's sufficient
	 * memory to be had.
	 */

	"movl	%[size],	%%eax"		"\n\t"
	"pushl	%%eax"				"\n\t"
	"call	__alloca"			"\n\t"

	/*
	 * Come here on a normal exit. Recover the EXCEPTION_REGISTRATION and
	 * store a TCL_OK status
	 */

	"movl	%%fs:0,		%%edx"		"\n\t"
	"movl	%[ok],		%%eax"		"\n\t"
	"movl	%%eax,		0x10(%%edx)"	"\n\t"
	"jmp	2f"				"\n"

	/*
	 * Come here on an exception. Get the EXCEPTION_REGISTRATION that we
	 * previously put on the chain.
	 */

	"1:"					"\t"
	"movl	%%fs:0,		%%edx"		"\n\t"
	"movl	0x8(%%edx),	%%edx"		"\n\t"

	/*
	 * Come here however we exited. Restore context from the
	 * EXCEPTION_REGISTRATION in case the stack is unbalanced.
	 */

	"2:"					"\t"
	"movl	0xc(%%edx),	%%esp"		"\n\t"
	"movl	0x8(%%edx),	%%ebp"		"\n\t"
	"movl	0x0(%%edx),	%%eax"		"\n\t"
	"movl	%%eax,		%%fs:0"		"\n\t"

	:
	/* No outputs */
	:
	[registration]	"m"	(registration),
	[ok]		"i"	(TCL_OK),
	[error]		"i"	(TCL_ERROR),
	[size]		"i"	(TCL_WIN_STACK_THRESHOLD)
	:
	"%eax", "%ebx", "%ecx", "%edx", "%esi", "%edi", "memory"
	);
    retval = (registration.status == TCL_OK);

#else /* !HAVE_NO_SEH */
    __try {
	alloca(TCL_WIN_STACK_THRESHOLD);
	retval = 1;
    } __except (EXCEPTION_EXECUTE_HANDLER) {}
#endif /* HAVE_NO_SEH */

    return retval;
}


/*
 *----------------------------------------------------------------------
 *
 * TclWinGetPlatform --
 *
 *	This is a kludge that allows the test library to get access
 *	the internal tclPlatform variable.
 *
 * Results:
 *	Returns a pointer to the tclPlatform variable.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

TclPlatformType *
TclWinGetPlatform()
{
    return &tclPlatform;
}

/*
 *---------------------------------------------------------------------------
 *
 * TclWinSetInterfaces --
 *
 *	A helper proc that allows the test library to change the
 *	tclWinProcs structure to dispatch to either the wide-character
 *	or multi-byte versions of the operating system calls, depending
 *	on whether Unicode is the system encoding.
 *	
 *	As well as this, we can also try to load in some additional
 *	procs which may/may not be present depending on the current
 *	Windows version (e.g. Win95 will not have the procs below).
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
 */

void
TclWinSetInterfaces(
    int wide)			/* Non-zero to use wide interfaces, 0
				 * otherwise. */
{
    Tcl_FreeEncoding(tclWinTCharEncoding);

    if (wide) {
	tclWinProcs = &unicodeProcs;
	tclWinTCharEncoding = Tcl_GetEncoding(NULL, "unicode");
	if (tclWinProcs->getFileAttributesExProc == NULL) {
	    HINSTANCE hInstance = LoadLibraryA("kernel32");
	    if (hInstance != NULL) {
	        tclWinProcs->getFileAttributesExProc = 
		  (BOOL (WINAPI *)(CONST TCHAR *, GET_FILEEX_INFO_LEVELS, 
		  LPVOID)) GetProcAddress(hInstance, "GetFileAttributesExW");
		tclWinProcs->createHardLinkProc = 
		  (BOOL (WINAPI *)(CONST TCHAR *, CONST TCHAR*, 
		  LPSECURITY_ATTRIBUTES)) GetProcAddress(hInstance, 
		  "CreateHardLinkW");
		FreeLibrary(hInstance);
	    }
	}
    } else {
	tclWinProcs = &asciiProcs;
	tclWinTCharEncoding = NULL;
	if (tclWinProcs->getFileAttributesExProc == NULL) {
	    HINSTANCE hInstance = LoadLibraryA("kernel32");
	    if (hInstance != NULL) {
		tclWinProcs->getFileAttributesExProc = 
		  (BOOL (WINAPI *)(CONST TCHAR *, GET_FILEEX_INFO_LEVELS, 
		  LPVOID)) GetProcAddress(hInstance, "GetFileAttributesExA");
		tclWinProcs->createHardLinkProc = 
		  (BOOL (WINAPI *)(CONST TCHAR *, CONST TCHAR*, 
		  LPSECURITY_ATTRIBUTES)) GetProcAddress(hInstance, 
		  "CreateHardLinkA");
		FreeLibrary(hInstance);
	    }
	}
    }
}

/*
 *---------------------------------------------------------------------------
 *
 * Tcl_WinUtfToTChar, Tcl_WinTCharToUtf --
 *
 *	Convert between UTF-8 and Unicode when running Windows NT or 
 *	the current ANSI code page when running Windows 95.
 *
 *	On Mac, Unix, and Windows 95, all strings exchanged between Tcl
 *	and the OS are "char" oriented.  We need only one Tcl_Encoding to
 *	convert between UTF-8 and the system's native encoding.  We use
 *	NULL to represent that encoding.
 *
 *	On NT, some strings exchanged between Tcl and the OS are "char"
 *	oriented, while others are in Unicode.  We need two Tcl_Encoding
 *	APIs depending on whether we are targeting a "char" or Unicode
 *	interface.  
 *
 *	Calling Tcl_UtfToExternal() or Tcl_ExternalToUtf() with an
 *	encoding of NULL should always used to convert between UTF-8
 *	and the system's "char" oriented encoding.  The following two
 *	functions are used in Windows-specific code to convert between
 *	UTF-8 and Unicode strings (NT) or "char" strings(95).  This saves
 *	you the trouble of writing the following type of fragment over and
 *	over:
 *
 *		if (running NT) {
 *		    encoding <- Tcl_GetEncoding("unicode");
 *		    nativeBuffer <- UtfToExternal(encoding, utfBuffer);
 *		    Tcl_FreeEncoding(encoding);
 *		} else {
 *		    nativeBuffer <- UtfToExternal(NULL, utfBuffer);
 *		}
 *
 *	By convention, in Windows a TCHAR is a character in the ANSI code
 *	page on Windows 95, a Unicode character on Windows NT.  If you
 *	plan on targeting a Unicode interfaces when running on NT and a
 *	"char" oriented interface while running on 95, these functions
 *	should be used.  If you plan on targetting the same "char"
 *	oriented function on both 95 and NT, use Tcl_UtfToExternal()
 *	with an encoding of NULL.
 *
 * Results:
 *	The result is a pointer to the string in the desired target
 *	encoding.  Storage for the result string is allocated in
 *	dsPtr; the caller must call Tcl_DStringFree() when the result
 *	is no longer needed.
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
 */

TCHAR *
Tcl_WinUtfToTChar(string, len, dsPtr)
    CONST char *string;		/* Source string in UTF-8. */
    int len;			/* Source string length in bytes, or < 0 for
				 * strlen(). */
    Tcl_DString *dsPtr;		/* Uninitialized or free DString in which 
				 * the converted string is stored. */
{
    return (TCHAR *) Tcl_UtfToExternalDString(tclWinTCharEncoding, 
	    string, len, dsPtr);
}

char *
Tcl_WinTCharToUtf(string, len, dsPtr)
    CONST TCHAR *string;	/* Source string in Unicode when running
				 * NT, ANSI when running 95. */
    int len;			/* Source string length in bytes, or < 0 for
				 * platform-specific string length. */
    Tcl_DString *dsPtr;		/* Uninitialized or free DString in which 
				 * the converted string is stored. */
{
    return Tcl_ExternalToUtfDString(tclWinTCharEncoding, 
	    (CONST char *) string, len, dsPtr);
}
@


1.11
log
@	* win/tclWin32Dll.c (TclWinInit): Set native cwd to Cygwin's cwd.
	* win/tclWinFile.c (TclpObjChdir): Keep native and Cygwin's cwd
	synched.
@
text
@d44 15
a58 3
static void *ESP;
static void *EBP;
#endif /* HAVE_NO_SEH */
d373 4
d380 4
a383 4
     * We can recurse only if there is at least TCL_WIN_STACK_THRESHOLD
     * bytes of stack space left.  alloca() is cheap on windows; basically
     * it just subtracts from the stack pointer causing the OS to throw an
     * exception if the stack pointer is set below the bottom of the stack.
a387 2
            "movl  %esp, _ESP" "\n\t"
            "movl  %ebp, _EBP");
d389 71
a459 5
    __asm__ __volatile__ (
            "pushl $__except_checkstackspace_handler" "\n\t"
            "pushl %fs:0" "\n\t"
            "mov   %esp, %fs:0");
#else
a460 1
#endif /* HAVE_NO_SEH */
a462 13
#ifdef HAVE_NO_SEH
    __asm__ __volatile__ (
            "jmp   checkstackspace_pop" "\n"
            "checkstackspace_reentry:" "\n\t"
            "movl  _ESP, %esp" "\n\t"
            "movl  _EBP, %ebp");

    __asm__ __volatile__ (
            "checkstackspace_pop:" "\n\t"
            "mov   (%esp), %eax" "\n\t"
            "mov   %eax, %fs:0" "\n\t"
            "add   $8, %esp");
#else
a465 3
    /*
     * Avoid using control flow statements in the SEH guarded block!
     */
d468 1
a468 15
#ifdef HAVE_NO_SEH
static
__attribute__ ((cdecl,used))
EXCEPTION_DISPOSITION
_except_checkstackspace_handler(
    struct _EXCEPTION_RECORD *ExceptionRecord,
    void *EstablisherFrame,
    struct _CONTEXT *ContextRecord,
    void *DispatcherContext)
{
    __asm__ __volatile__ (
            "jmp checkstackspace_reentry");
    return 0; /* Function does not return */
}
#endif /* HAVE_NO_SEH */
@


1.10
log
@* win/tclWin32Dll.c (_except_checkstackspace_handler): Define with proper
attribute to prevent this static function from being deleted due to aggressive
gcc optimization.
* win/tclWinChan.c (_except_makefilechannel_handler): Ditto.
* win/tclWinFCmd.c (_except_dorenamefile_handler): Ditto.
* configure.in: Make sure that TCL_LIB_SPEC is properly filled out.
* configure: Regenerate.
@
text
@d16 3
d273 8
@


1.10.6.1
log
@update to HEAD
@
text
@a15 3
#ifdef __CYGWIN__
#include <sys/cygwin.h>
#endif
a269 8
#ifdef __CYGWIN__
    {
      char cwd_posix[MAX_PATH], cwd_win32[MAX_PATH];
      cygwin_conv_to_full_win32_path (getcwd (cwd_posix, MAX_PATH), cwd_win32);
      SetCurrentDirectory (cwd_win32);
    }
#endif

@


1.9
log
@Updated to tcl 8.4.1
@
text
@d396 1
a396 1
__attribute__ ((cdecl))
@


1.8
log
@touched all sources to ease next import
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tclWin32Dll.c,v 1.6.8.4 2000/09/15 16:58:44 spolk Exp $
d40 5
d86 2
d125 2
d130 1
a130 1
Tcl_Encoding tclWinTCharEncoding;
a138 8
/* CYGNUS LOCAL */
#ifdef __CYGWIN__0
/* CYGWIN requires an impure pointer variable, which must be
   explicitly initialized when the DLL starts up.  */
struct _reent *_impure_ptr;
extern struct _reent __declspec(dllimport) reent_data;
#endif
/* END CYGNUS LOCAL */
a193 8
    /* CYGNUS LOCAL */
#ifdef __CYGWIN__0
    /* Cygwin requires the impure data pointer to be initialized
       when the DLL starts up.  */
    _impure_ptr = &reent_data;
#endif
    /* END CYGNUS LOCAL */

d350 2
d359 10
a368 1
#ifndef __GNUC__
d370 1
d372 13
a384 3
	return 1;
    /* CYGNUS LOCAL */
    } __except (1) {}
d386 2
a387 2
    return alloca(TCL_WIN_STACK_THRESHOLD) != NULL;
#endif
d389 18
a406 1
    return 0;
d408 1
a408 1

d442 4
d466 13
d482 13
a575 3



@


1.7
log
@* win/tclWin32Dll.c (tclWinTCharEncoding): Remove 'static' since it is declared
in header as exportable extern.
@
text
@@


1.6
log
@touched all sources to ease next import
@
text
@d121 1
a121 1
static Tcl_Encoding tclWinTCharEncoding;
@


1.6.4.1
log
@Merge drow-cplus-merge-20021025 to drow-cplus-branch.
@
text
@d121 1
a121 1
Tcl_Encoding tclWinTCharEncoding;
@


1.6.4.2
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tclWin32Dll.c,v 1.16 2002/06/13 09:40:01 vincentdarley Exp $
a39 5
#ifdef HAVE_NO_SEH
static void *ESP;
static void *EBP;
#endif /* HAVE_NO_SEH */

a80 2
    NULL,
    NULL,
a117 2
    NULL,
    NULL,
d121 1
a121 1
static Tcl_Encoding tclWinTCharEncoding;
d130 8
d193 8
a356 2
    int retval = 0;

d364 1
a364 10
#ifdef HAVE_NO_SEH
    __asm__ __volatile__ (
            "movl  %esp, _ESP" "\n\t"
            "movl  %ebp, _EBP");

    __asm__ __volatile__ (
            "pushl $__except_checkstackspace_handler" "\n\t"
            "pushl %fs:0" "\n\t"
            "mov   %esp, %fs:0");
#else
a365 1
#endif /* HAVE_NO_SEH */
d367 3
a369 13
	retval = 1;
#ifdef HAVE_NO_SEH
    __asm__ __volatile__ (
            "jmp   checkstackspace_pop" "\n"
            "checkstackspace_reentry:" "\n\t"
            "movl  _ESP, %esp" "\n\t"
            "movl  _EBP, %ebp");

    __asm__ __volatile__ (
            "checkstackspace_pop:" "\n\t"
            "mov   (%esp), %eax" "\n\t"
            "mov   %eax, %fs:0" "\n\t"
            "add   $8, %esp");
d371 2
a372 2
    } __except (EXCEPTION_EXECUTE_HANDLER) {}
#endif /* HAVE_NO_SEH */
d374 1
a374 4
    /*
     * Avoid using control flow statements in the SEH guarded block!
     */
    return retval;
d376 1
a376 15
#ifdef HAVE_NO_SEH
static
__attribute__ ((cdecl))
EXCEPTION_DISPOSITION
_except_checkstackspace_handler(
    struct _EXCEPTION_RECORD *ExceptionRecord,
    void *EstablisherFrame,
    struct _CONTEXT *ContextRecord,
    void *DispatcherContext)
{
    __asm__ __volatile__ (
            "jmp checkstackspace_reentry");
    return 0; /* Function does not return */
}
#endif /* HAVE_NO_SEH */
a409 4
 *	
 *	As well as this, we can also try to load in some additional
 *	procs which may/may not be present depending on the current
 *	Windows version (e.g. Win95 will not have the procs below).
a429 13
	if (tclWinProcs->getFileAttributesExProc == NULL) {
	    HINSTANCE hInstance = LoadLibraryA("kernel32");
	    if (hInstance != NULL) {
	        tclWinProcs->getFileAttributesExProc = 
		  (BOOL (WINAPI *)(CONST TCHAR *, GET_FILEEX_INFO_LEVELS, 
		  LPVOID)) GetProcAddress(hInstance, "GetFileAttributesExW");
		tclWinProcs->createHardLinkProc = 
		  (BOOL (WINAPI *)(CONST TCHAR *, CONST TCHAR*, 
		  LPSECURITY_ATTRIBUTES)) GetProcAddress(hInstance, 
		  "CreateHardLinkW");
		FreeLibrary(hInstance);
	    }
	}
a432 13
	if (tclWinProcs->getFileAttributesExProc == NULL) {
	    HINSTANCE hInstance = LoadLibraryA("kernel32");
	    if (hInstance != NULL) {
		tclWinProcs->getFileAttributesExProc = 
		  (BOOL (WINAPI *)(CONST TCHAR *, GET_FILEEX_INFO_LEVELS, 
		  LPVOID)) GetProcAddress(hInstance, "GetFileAttributesExA");
		tclWinProcs->createHardLinkProc = 
		  (BOOL (WINAPI *)(CONST TCHAR *, CONST TCHAR*, 
		  LPSECURITY_ATTRIBUTES)) GetProcAddress(hInstance, 
		  "CreateHardLinkA");
		FreeLibrary(hInstance);
	    }
	}
d514 3
@


1.6.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tclWin32Dll.c,v 1.16 2002/06/13 09:40:01 vincentdarley Exp $
a39 5
#ifdef HAVE_NO_SEH
static void *ESP;
static void *EBP;
#endif /* HAVE_NO_SEH */

a80 2
    NULL,
    NULL,
a117 2
    NULL,
    NULL,
d130 10
a139 1
#if defined(__WIN32__) || defined(__CYGWIN__)
d193 8
d217 1
a217 1
#endif /* __WIN32__ || __CYGWIN__ */
a356 2
    int retval = 0;

d364 1
a364 13
#ifdef __CYGWIN__
	retval = (alloca (TCL_WIN_STACK_THRESHOLD) != NULL);
#else /* !__CYGWIN__ */
#ifdef HAVE_NO_SEH
    __asm__ __volatile__ (
            "movl  %esp, _ESP" "\n\t"
            "movl  %ebp, _EBP");

    __asm__ __volatile__ (
            "pushl $__except_checkstackspace_handler" "\n\t"
            "pushl %fs:0" "\n\t"
            "mov   %esp, %fs:0");
#else
a365 1
#endif /* HAVE_NO_SEH */
d367 3
a369 13
	retval = 1;
#ifdef HAVE_NO_SEH
    __asm__ __volatile__ (
            "jmp   checkstackspace_pop" "\n"
            "checkstackspace_reentry:" "\n\t"
            "movl  _ESP, %esp" "\n\t"
            "movl  _EBP, %ebp");

    __asm__ __volatile__ (
            "checkstackspace_pop:" "\n\t"
            "mov   (%esp), %eax" "\n\t"
            "mov   %eax, %fs:0" "\n\t"
            "add   $8, %esp");
d371 2
a372 3
    } __except (EXCEPTION_EXECUTE_HANDLER) {}
#endif /* HAVE_NO_SEH */
#endif /* !__CYGWIN__ */
d374 1
a374 4
    /*
     * Avoid using control flow statements in the SEH guarded block!
     */
    return retval;
d376 1
a376 17
#ifndef __CYGWIN__
#ifdef HAVE_NO_SEH
static
__attribute__ ((cdecl))
EXCEPTION_DISPOSITION
_except_checkstackspace_handler(
    struct _EXCEPTION_RECORD *ExceptionRecord,
    void *EstablisherFrame,
    struct _CONTEXT *ContextRecord,
    void *DispatcherContext)
{
    __asm__ __volatile__ (
            "jmp checkstackspace_reentry");
    return 0; /* Function does not return */
}
#endif /* HAVE_NO_SEH */
#endif /* !__CYGWIN__ */
a409 4
 *	
 *	As well as this, we can also try to load in some additional
 *	procs which may/may not be present depending on the current
 *	Windows version (e.g. Win95 will not have the procs below).
a429 13
	if (tclWinProcs->getFileAttributesExProc == NULL) {
	    HINSTANCE hInstance = LoadLibraryA("kernel32");
	    if (hInstance != NULL) {
	        tclWinProcs->getFileAttributesExProc = 
		  (BOOL (WINAPI *)(CONST TCHAR *, GET_FILEEX_INFO_LEVELS, 
		  LPVOID)) GetProcAddress(hInstance, "GetFileAttributesExW");
		tclWinProcs->createHardLinkProc = 
		  (BOOL (WINAPI *)(CONST TCHAR *, CONST TCHAR*, 
		  LPSECURITY_ATTRIBUTES)) GetProcAddress(hInstance, 
		  "CreateHardLinkW");
		FreeLibrary(hInstance);
	    }
	}
a432 13
	if (tclWinProcs->getFileAttributesExProc == NULL) {
	    HINSTANCE hInstance = LoadLibraryA("kernel32");
	    if (hInstance != NULL) {
		tclWinProcs->getFileAttributesExProc = 
		  (BOOL (WINAPI *)(CONST TCHAR *, GET_FILEEX_INFO_LEVELS, 
		  LPVOID)) GetProcAddress(hInstance, "GetFileAttributesExA");
		tclWinProcs->createHardLinkProc = 
		  (BOOL (WINAPI *)(CONST TCHAR *, CONST TCHAR*, 
		  LPSECURITY_ATTRIBUTES)) GetProcAddress(hInstance, 
		  "CreateHardLinkA");
		FreeLibrary(hInstance);
	    }
	}
d514 3
@


1.5
log
@        From Mo Dejong  <supermo@@bayarea.net>:
        * win/tclWin32Dll.c (DllMain): Remove unused os
        variable since VC++ treats warnings as errors
        when compiling with symbols.

        * win/tclWinPort.h: Remove undefine of PASCAL
        symbol added on 2001-09-12. It caused
        crashing problems with sockets.
@
text
@@


1.5.2.1
log
@Merge with mainline; merge tag carlton_dictionary-20021011-merge.
@
text
@d121 1
a121 1
Tcl_Encoding tclWinTCharEncoding;
@


1.5.2.2
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.5.2.3
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@a39 5
#ifdef HAVE_NO_SEH
static void *ESP;
static void *EBP;
#endif /* HAVE_NO_SEH */

a80 2
    NULL,
    NULL,
a117 2
    NULL,
    NULL,
d121 1
a121 1
static Tcl_Encoding tclWinTCharEncoding;
d130 8
d193 8
a356 2
    int retval = 0;

d364 1
a364 10
#ifdef HAVE_NO_SEH
    __asm__ __volatile__ (
            "movl  %esp, _ESP" "\n\t"
            "movl  %ebp, _EBP");

    __asm__ __volatile__ (
            "pushl $__except_checkstackspace_handler" "\n\t"
            "pushl %fs:0" "\n\t"
            "mov   %esp, %fs:0");
#else
a365 1
#endif /* HAVE_NO_SEH */
d367 3
a369 13
	retval = 1;
#ifdef HAVE_NO_SEH
    __asm__ __volatile__ (
            "jmp   checkstackspace_pop" "\n"
            "checkstackspace_reentry:" "\n\t"
            "movl  _ESP, %esp" "\n\t"
            "movl  _EBP, %ebp");

    __asm__ __volatile__ (
            "checkstackspace_pop:" "\n\t"
            "mov   (%esp), %eax" "\n\t"
            "mov   %eax, %fs:0" "\n\t"
            "add   $8, %esp");
d371 2
a372 2
    } __except (EXCEPTION_EXECUTE_HANDLER) {}
#endif /* HAVE_NO_SEH */
d374 1
a374 4
    /*
     * Avoid using control flow statements in the SEH guarded block!
     */
    return retval;
d376 1
a376 15
#ifdef HAVE_NO_SEH
static
__attribute__ ((cdecl))
EXCEPTION_DISPOSITION
_except_checkstackspace_handler(
    struct _EXCEPTION_RECORD *ExceptionRecord,
    void *EstablisherFrame,
    struct _CONTEXT *ContextRecord,
    void *DispatcherContext)
{
    __asm__ __volatile__ (
            "jmp checkstackspace_reentry");
    return 0; /* Function does not return */
}
#endif /* HAVE_NO_SEH */
a409 4
 *	
 *	As well as this, we can also try to load in some additional
 *	procs which may/may not be present depending on the current
 *	Windows version (e.g. Win95 will not have the procs below).
a429 13
	if (tclWinProcs->getFileAttributesExProc == NULL) {
	    HINSTANCE hInstance = LoadLibraryA("kernel32");
	    if (hInstance != NULL) {
	        tclWinProcs->getFileAttributesExProc = 
		  (BOOL (WINAPI *)(CONST TCHAR *, GET_FILEEX_INFO_LEVELS, 
		  LPVOID)) GetProcAddress(hInstance, "GetFileAttributesExW");
		tclWinProcs->createHardLinkProc = 
		  (BOOL (WINAPI *)(CONST TCHAR *, CONST TCHAR*, 
		  LPSECURITY_ATTRIBUTES)) GetProcAddress(hInstance, 
		  "CreateHardLinkW");
		FreeLibrary(hInstance);
	    }
	}
a432 13
	if (tclWinProcs->getFileAttributesExProc == NULL) {
	    HINSTANCE hInstance = LoadLibraryA("kernel32");
	    if (hInstance != NULL) {
		tclWinProcs->getFileAttributesExProc = 
		  (BOOL (WINAPI *)(CONST TCHAR *, GET_FILEEX_INFO_LEVELS, 
		  LPVOID)) GetProcAddress(hInstance, "GetFileAttributesExA");
		tclWinProcs->createHardLinkProc = 
		  (BOOL (WINAPI *)(CONST TCHAR *, CONST TCHAR*, 
		  LPSECURITY_ATTRIBUTES)) GetProcAddress(hInstance, 
		  "CreateHardLinkA");
		FreeLibrary(hInstance);
	    }
	}
d514 3
@


1.4
log
@touched all Tcl files to ease next import.
@
text
@a192 2
    OSVERSIONINFO os;

@


1.4.6.1
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d193 2
@


1.4.6.2
log
@merge from main line
@
text
@d121 1
a121 1
Tcl_Encoding tclWinTCharEncoding;
@


1.3
log
@Tcl8.3 upgrade merge.
@
text
@@


1.2
log
@Fixes for newer cygwin gccs.
Use modern Cygwin conditional.
@
text
@d4 1
a4 2
 *	This file contains the DLL entry point which sets up the 32-to-16-bit
 *	thunking code for SynchSpawn if the library is running under Win32s.
d7 1
d12 1
a12 1
 * RCS: @@(#) $Id: tclWin32Dll.c,v 1.15 2000/01/26 20:03:51 dj Exp $
a16 12
typedef DWORD (WINAPI * UT32PROC)(LPVOID lpBuff, DWORD dwUserDefined,
	LPVOID *lpTranslationList);

typedef BOOL (WINAPI * PUTREGISTER)(HANDLE hModule, LPCSTR SixteenBitDLL,
	LPCSTR InitName, LPCSTR ProcName, UT32PROC* ThirtyTwoBitThunk,
	FARPROC UT32Callback, LPVOID Buff);

typedef VOID (WINAPI * PUTUNREGISTER)(HANDLE hModule);

static PUTUNREGISTER UTUnRegister = NULL;
static int           tclProcessesAttached = 0;

d18 2
a19 2
 * The following data structure is used to keep track of all of the DLL's
 * opened by Tcl so that they can be freed with the Tcl.dll is unloaded.
d22 2
a23 4
typedef struct LibraryList {
    HINSTANCE handle;
    struct LibraryList *nextPtr;
} LibraryList;
d25 3
a27 1
static LibraryList *libraryList = NULL;	/* List of currently loaded DLL's.  */
d29 1
a29 2
static HINSTANCE tclInstance;	/* Global library instance handle. */
static int tclPlatformId;	/* Running under NT, 95, or Win32s? */
d31 88
a118 3
/*
 * Declarations for functions that are only used in this file.
 */
d120 2
a121 1
static void 		UnloadLibraries _ANSI_ARGS_((void));
d127 2
a128 5
BOOL APIENTRY		DllMain _ANSI_ARGS_((HINSTANCE hInst,
			    DWORD reason, LPVOID reserved));

#ifdef __WIN32__
#ifndef STATIC_BUILD
d135 1
a135 1
extern struct _reent *_imp__reent_data;
d138 4
d199 1
a199 1
    _impure_ptr = _imp__reent_data;
a204 4
	if (tclProcessesAttached++) {
	    return FALSE;         /* Not the first initialization. */
	}

d209 2
a210 4

	tclProcessesAttached--;
	if (tclProcessesAttached == 0) {
            Tcl_Finalize();
d224 22
d254 1
a254 2
 *	Initializes the 16-bit thunking library, and the tclPlatformId
 *	variable.
d265 2
a266 2
    tclInstance = hInst;
    os.dwOSVersionInfoSize = sizeof(os);
d268 1
a268 1
    tclPlatformId = os.dwPlatformId;
d271 2
a272 8
     * The following code stops Windows 3.x from automatically putting 
     * up Sharing Violation dialogs, e.g, when someone tries to
     * access a file that is locked or a drive with no disk in it.
     * Tcl already returns the appropriate error to the caller, and they 
     * can decide to put up their own dialog in response to that failure.  
     *
     * Under 95 and NT, the system doesn't automatically put up dialogs 
     * when the above operations fail.
d275 2
a276 2
    if (tclPlatformId == VER_PLATFORM_WIN32s) {
	SetErrorMode(SetErrorMode(0) | SEM_FAILCRITICALERRORS);
d278 2
d285 1
a285 1
 * TclpFinalize --
d287 2
a288 1
 *	Clean up the Windows specific library state.
d291 4
a294 1
 *	None.
d297 1
a297 2
 *	Unloads any DLLs and cleans up the thunking library, if
 *	necessary.
d302 2
a303 2
void
TclpFinalize()
d305 1
a305 14
    /*
     * Unregister the Tcl thunk.
     */

    if (UTUnRegister != NULL) {
	UTUnRegister(tclInstance);
	UTUnRegister = NULL;
    }

    /*
     * Cleanup any dynamically loaded libraries.
     */

    UnloadLibraries();
d309 1
a309 1
 *----------------------------------------------------------------------
d311 1
a311 1
 * TclWinLoadLibrary --
d313 2
a314 3
 *	This function is a wrapper for the system LoadLibrary.  It is
 *	responsible for adding library handles to the library list so
 *	the libraries can be freed when tcl.dll is unloaded.
d317 1
a317 2
 *	Returns the handle of the newly loaded library, or NULL on
 *	failure.
d320 1
a320 1
 *	Loads the specified library into the process.
d322 1
a322 1
 *----------------------------------------------------------------------
d325 3
a327 3
HINSTANCE
TclWinLoadLibrary(name)
    char *name;			/* Library file to load. */
d329 1
a329 2
    HINSTANCE handle;
    LibraryList *ptr;
d331 4
a334 8
    handle = LoadLibrary(name);
    if (handle != NULL) {
	ptr = (LibraryList*) ckalloc(sizeof(LibraryList));
	ptr->handle = handle;
	ptr->nextPtr = libraryList;
	libraryList = ptr;
    } else {
	TclWinConvertError(GetLastError());
d336 1
a336 1
    return handle;
d342 1
a342 1
 * UnloadLibraries --
d344 2
a345 1
 *	Frees any dynamically allocated libraries loaded by Tcl.
d348 1
a348 1
 *	None.
d351 1
a351 1
 *	Frees the libraries on the library list as well as the list.
d356 2
a357 2
static void
UnloadLibraries()
d359 6
a364 1
    LibraryList *ptr;
d366 11
a376 6
    while (libraryList != NULL) {
	FreeLibrary(libraryList->handle);
	ptr = libraryList->nextPtr;
	ckfree((char*)libraryList);
	libraryList = ptr;
    }
d378 1
d383 1
a383 1
 * TclWinSynchSpawn --
d385 2
a386 1
 *	32-bit entry point to the 16-bit SynchSpawn code.
d389 1
a389 1
 *	1 on success, 0 on failure.
d392 1
a392 1
 *	Spawns a command and waits for it to complete.
d396 3
a398 2
int 
TclWinSynchSpawn(void *args, int type, void **trans, Tcl_Pid *pidPtr)
d400 1
a400 54
    static UT32PROC UTProc = NULL;
    static int utErrorCode;

    if (UTUnRegister == NULL) {
	/*
	 * Load the Universal Thunking routines from kernel32.dll.
	 */

	HINSTANCE hKernel;
	PUTREGISTER UTRegister;
	char buffer[] = "TCL16xx.DLL";

	hKernel = TclWinLoadLibrary("Kernel32.Dll");
	if (hKernel == NULL) {
	    return 0;
	}

	UTRegister = (PUTREGISTER) GetProcAddress(hKernel, "UTRegister");
	UTUnRegister = (PUTUNREGISTER) GetProcAddress(hKernel, "UTUnRegister");
	if (!UTRegister || !UTUnRegister) {
	    UnloadLibraries();
	    return 0;
	}

	/*
	 * Construct the complete name of tcl16xx.dll.
	 */

	buffer[5] = '0' + TCL_MAJOR_VERSION;
	buffer[6] = '0' + TCL_MINOR_VERSION;

	/*
	 * Register the Tcl thunk.
	 */

	if (UTRegister(tclInstance, buffer, NULL, "UTProc", &UTProc, NULL,
		NULL) == FALSE) {
	    utErrorCode = GetLastError();
	}
    }

    if (UTProc == NULL) {
	/*
	 * The 16-bit thunking DLL wasn't found.  Return error code that
	 * indicates this problem.
	 */

	SetLastError(utErrorCode);
	return 0;
    }

    UTProc(args, type, trans);
    *pidPtr = 0;
    return 1;
d404 1
a404 1
 *----------------------------------------------------------------------
d406 1
a406 1
 * TclWinGetTclInstance --
d408 4
a411 1
 *	Retrieves the global library instance handle.
d414 1
a414 1
 *	Returns the global library instance handle.
d419 1
a419 1
 *----------------------------------------------------------------------
d422 4
a425 2
HINSTANCE
TclWinGetTclInstance()
d427 9
a435 1
    return tclInstance;
d439 3
a441 1
 *----------------------------------------------------------------------
d443 2
a444 1
 * TclWinGetPlatformId --
d446 33
a478 2
 *	Determines whether running under NT, 95, or Win32s, to allow 
 *	runtime conditional code.
d481 4
a484 4
 *	The return value is one of:
 *	    VER_PLATFORM_WIN32s		Win32s on Windows 3.1. 
 *	    VER_PLATFORM_WIN32_WINDOWS	Win32 on Windows 95.
 *	    VER_PLATFORM_WIN32_NT	Win32 on Windows NT
d489 1
a489 1
 *----------------------------------------------------------------------
d492 20
a511 2
int		
TclWinGetPlatformId()
d513 2
a514 1
    return tclPlatformId;
d516 3
@


1.1
log
@Initial revision
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tclWin32Dll.c,v 1.14 1999/01/26 03:53:41 jingham Exp $
d61 2
a62 2
#ifdef __CYGWIN32__
/* cygwin32 requires an impure pointer variable, which must be
d65 1
a65 1
extern struct _reent *__imp_reent_data;
d122 2
a123 2
#ifdef __CYGWIN32__
    /* cygwin32 requires the impure data pointer to be initialized
d125 1
a125 1
    _impure_ptr = __imp_reent_data;
@


1.1.1.1
log
@import dejagnu-1999-11-08 snapshot
@
text
@@


1.1.1.2
log
@import dejagnu-2000-01-31 snapshot
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tclWin32Dll.c,v 1.15 2000/01/26 20:03:51 dj Exp $
d65 1
a65 1
extern struct _reent *_imp__reent_data;
d125 1
a125 1
    _impure_ptr = _imp__reent_data;
@


1.1.1.3
log
@Tcl 8.3 upgrade
@
text
@d4 2
a5 1
 *	This file contains the DLL entry point.
a7 1
 * Copyright (c) 1998-2000 Scriptics Corporation.
d12 1
a12 1
 * RCS: @@(#) $Id: tclWin32Dll.c,v 1.6.8.4 2000/09/15 16:58:44 spolk Exp $
d17 12
d30 2
a31 2
 * The following data structures are used when loading the thunking 
 * library for execing child processes under Win32s.
d34 4
a37 2
typedef DWORD (WINAPI UT32PROC)(LPVOID lpBuff, DWORD dwUserDefined,
	LPVOID *lpTranslationList);
d39 1
a39 3
typedef BOOL (WINAPI UTREGISTER)(HANDLE hModule, LPCSTR SixteenBitDLL,
	LPCSTR InitName, LPCSTR ProcName, UT32PROC **ThirtyTwoBitThunk,
	FARPROC UT32Callback, LPVOID Buff);
d41 2
a42 1
typedef VOID (WINAPI UTUNREGISTER)(HANDLE hModule);
d44 3
a46 88
/* 
 * The following variables keep track of information about this DLL
 * on a per-instance basis.  Each time this DLL is loaded, it gets its own 
 * new data segment with its own copy of all static and global information.
 */

static HINSTANCE hInstance;	/* HINSTANCE of this DLL. */
static int platformId;		/* Running under NT, or 95/98? */

/*
 * The following function tables are used to dispatch to either the
 * wide-character or multi-byte versions of the operating system calls,
 * depending on whether the Unicode calls are available.
 */

static TclWinProcs asciiProcs = {
    0,

    (BOOL (WINAPI *)(CONST TCHAR *, LPDCB)) BuildCommDCBA,
    (TCHAR *(WINAPI *)(TCHAR *)) CharLowerA,
    (BOOL (WINAPI *)(CONST TCHAR *, CONST TCHAR *, BOOL)) CopyFileA,
    (BOOL (WINAPI *)(CONST TCHAR *, LPSECURITY_ATTRIBUTES)) CreateDirectoryA,
    (HANDLE (WINAPI *)(CONST TCHAR *, DWORD, DWORD, SECURITY_ATTRIBUTES *, 
	    DWORD, DWORD, HANDLE)) CreateFileA,
    (BOOL (WINAPI *)(CONST TCHAR *, TCHAR *, LPSECURITY_ATTRIBUTES, 
	    LPSECURITY_ATTRIBUTES, BOOL, DWORD, LPVOID, CONST TCHAR *, 
	    LPSTARTUPINFOA, LPPROCESS_INFORMATION)) CreateProcessA,
    (BOOL (WINAPI *)(CONST TCHAR *)) DeleteFileA,
    (HANDLE (WINAPI *)(CONST TCHAR *, WIN32_FIND_DATAT *)) FindFirstFileA,
    (BOOL (WINAPI *)(HANDLE, WIN32_FIND_DATAT *)) FindNextFileA,
    (BOOL (WINAPI *)(WCHAR *, LPDWORD)) GetComputerNameA,
    (DWORD (WINAPI *)(DWORD, WCHAR *)) GetCurrentDirectoryA,
    (DWORD (WINAPI *)(CONST TCHAR *)) GetFileAttributesA,
    (DWORD (WINAPI *)(CONST TCHAR *, DWORD nBufferLength, WCHAR *, 
	    TCHAR **)) GetFullPathNameA,
    (DWORD (WINAPI *)(HMODULE, WCHAR *, int)) GetModuleFileNameA,
    (DWORD (WINAPI *)(CONST TCHAR *, WCHAR *, DWORD)) GetShortPathNameA,
    (UINT (WINAPI *)(CONST TCHAR *, CONST TCHAR *, UINT uUnique, 
	    WCHAR *)) GetTempFileNameA,
    (DWORD (WINAPI *)(DWORD, WCHAR *)) GetTempPathA,
    (BOOL (WINAPI *)(CONST TCHAR *, WCHAR *, DWORD, LPDWORD, LPDWORD, LPDWORD,
	    WCHAR *, DWORD)) GetVolumeInformationA,
    (HINSTANCE (WINAPI *)(CONST TCHAR *)) LoadLibraryA,
    (TCHAR (WINAPI *)(WCHAR *, CONST TCHAR *)) lstrcpyA,
    (BOOL (WINAPI *)(CONST TCHAR *, CONST TCHAR *)) MoveFileA,
    (BOOL (WINAPI *)(CONST TCHAR *)) RemoveDirectoryA,
    (DWORD (WINAPI *)(CONST TCHAR *, CONST TCHAR *, CONST TCHAR *, DWORD, 
	    WCHAR *, TCHAR **)) SearchPathA,
    (BOOL (WINAPI *)(CONST TCHAR *)) SetCurrentDirectoryA,
    (BOOL (WINAPI *)(CONST TCHAR *, DWORD)) SetFileAttributesA,
};

static TclWinProcs unicodeProcs = {
    1,

    (BOOL (WINAPI *)(CONST TCHAR *, LPDCB)) BuildCommDCBW,
    (TCHAR *(WINAPI *)(TCHAR *)) CharLowerW,
    (BOOL (WINAPI *)(CONST TCHAR *, CONST TCHAR *, BOOL)) CopyFileW,
    (BOOL (WINAPI *)(CONST TCHAR *, LPSECURITY_ATTRIBUTES)) CreateDirectoryW,
    (HANDLE (WINAPI *)(CONST TCHAR *, DWORD, DWORD, SECURITY_ATTRIBUTES *, 
	    DWORD, DWORD, HANDLE)) CreateFileW,
    (BOOL (WINAPI *)(CONST TCHAR *, TCHAR *, LPSECURITY_ATTRIBUTES, 
	    LPSECURITY_ATTRIBUTES, BOOL, DWORD, LPVOID, CONST TCHAR *, 
	    LPSTARTUPINFOA, LPPROCESS_INFORMATION)) CreateProcessW,
    (BOOL (WINAPI *)(CONST TCHAR *)) DeleteFileW,
    (HANDLE (WINAPI *)(CONST TCHAR *, WIN32_FIND_DATAT *)) FindFirstFileW,
    (BOOL (WINAPI *)(HANDLE, WIN32_FIND_DATAT *)) FindNextFileW,
    (BOOL (WINAPI *)(WCHAR *, LPDWORD)) GetComputerNameW,
    (DWORD (WINAPI *)(DWORD, WCHAR *)) GetCurrentDirectoryW,
    (DWORD (WINAPI *)(CONST TCHAR *)) GetFileAttributesW,
    (DWORD (WINAPI *)(CONST TCHAR *, DWORD nBufferLength, WCHAR *, 
	    TCHAR **)) GetFullPathNameW,
    (DWORD (WINAPI *)(HMODULE, WCHAR *, int)) GetModuleFileNameW,
    (DWORD (WINAPI *)(CONST TCHAR *, WCHAR *, DWORD)) GetShortPathNameW,
    (UINT (WINAPI *)(CONST TCHAR *, CONST TCHAR *, UINT uUnique, 
	    WCHAR *)) GetTempFileNameW,
    (DWORD (WINAPI *)(DWORD, WCHAR *)) GetTempPathW,
    (BOOL (WINAPI *)(CONST TCHAR *, WCHAR *, DWORD, LPDWORD, LPDWORD, LPDWORD, 
	    WCHAR *, DWORD)) GetVolumeInformationW,
    (HINSTANCE (WINAPI *)(CONST TCHAR *)) LoadLibraryW,
    (TCHAR (WINAPI *)(WCHAR *, CONST TCHAR *)) lstrcpyW,
    (BOOL (WINAPI *)(CONST TCHAR *, CONST TCHAR *)) MoveFileW,
    (BOOL (WINAPI *)(CONST TCHAR *)) RemoveDirectoryW,
    (DWORD (WINAPI *)(CONST TCHAR *, CONST TCHAR *, CONST TCHAR *, DWORD, 
	    WCHAR *, TCHAR **)) SearchPathW,
    (BOOL (WINAPI *)(CONST TCHAR *)) SetCurrentDirectoryW,
    (BOOL (WINAPI *)(CONST TCHAR *, DWORD)) SetFileAttributesW,
};
d48 1
a48 2
TclWinProcs *tclWinProcs;
static Tcl_Encoding tclWinTCharEncoding;
d54 5
a58 2
BOOL APIENTRY		DllMain(HINSTANCE hInst, DWORD reason, 
				LPVOID reserved);
d65 1
a65 1
extern struct _reent __declspec(dllimport) reent_data;
a67 4

#ifdef __WIN32__
#ifndef STATIC_BUILD

d125 1
a125 1
    _impure_ptr = &reent_data;
d131 4
d139 4
a142 2
	if (hInst == hInstance) {
	    Tcl_Finalize();
a155 22
 * TclWinGetTclInstance --
 *
 *	Retrieves the global library instance handle.
 *
 * Results:
 *	Returns the global library instance handle.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

HINSTANCE
TclWinGetTclInstance()
{
    return hInstance;
}

/*
 *----------------------------------------------------------------------
 *
d164 2
a165 1
 *	Initializes the tclPlatformId variable.
d176 2
a177 2
    hInstance = hInst;
    os.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
d179 1
a179 1
    platformId = os.dwPlatformId;
d182 8
a189 2
     * We no longer support Win32s, so just in case someone manages to
     * get a runtime there, make sure they know that.
d192 2
a193 2
    if (platformId == VER_PLATFORM_WIN32s) {
	panic("Win32s is not a supported platform");	
a194 2

    tclWinProcs = &asciiProcs;
d200 1
a200 1
 * TclWinGetPlatformId --
d202 1
a202 2
 *	Determines whether running under NT, 95, or Win32s, to allow 
 *	runtime conditional code.
d205 1
a205 4
 *	The return value is one of:
 *	    VER_PLATFORM_WIN32s		Win32s on Windows 3.1. (not supported)
 *	    VER_PLATFORM_WIN32_WINDOWS	Win32 on Windows 95.
 *	    VER_PLATFORM_WIN32_NT	Win32 on Windows NT
d208 2
a209 1
 *	None.
d214 2
a215 2
int		
TclWinGetPlatformId()
d217 14
a230 1
    return platformId;
d234 1
a234 1
 *-------------------------------------------------------------------------
d236 1
a236 1
 * TclWinNoBackslash --
d238 3
a240 2
 *	We're always iterating through a string in Windows, changing the
 *	backslashes to slashes for use in Tcl.
d243 2
a244 1
 *	All backslashes in given string are changed to slashes.
d247 1
a247 1
 *	None.
d249 1
a249 1
 *-------------------------------------------------------------------------
d252 3
a254 3
char *
TclWinNoBackslash(
    char *path)			/* String to change. */
d256 2
a257 1
    char *p;
d259 8
a266 4
    for (p = path; *p != '\0'; p++) {
	if (*p == '\\') {
	    *p = '/';
	}
d268 1
a268 1
    return path;
d274 1
a274 1
 * TclpCheckStackSpace --
d276 1
a276 2
 *	Detect if we are about to blow the stack.  Called before an 
 *	evaluation can happen when nesting depth is checked.
d279 1
a279 1
 *	1 if there is enough stack space to continue; 0 if not.
d282 1
a282 1
 *	None.
d287 2
a288 2
int
TclpCheckStackSpace()
d290 1
a290 6
    /*
     * We can recurse only if there is at least TCL_WIN_STACK_THRESHOLD
     * bytes of stack space left.  alloca() is cheap on windows; basically
     * it just subtracts from the stack pointer causing the OS to throw an
     * exception if the stack pointer is set below the bottom of the stack.
     */
d292 6
a297 11
#ifndef __GNUC__
    __try {
	alloca(TCL_WIN_STACK_THRESHOLD);
	return 1;
    /* CYGNUS LOCAL */
    } __except (1) {}
#else
    return alloca(TCL_WIN_STACK_THRESHOLD) != NULL;
#endif

    return 0;
a298 1

d303 1
a303 1
 * TclWinGetPlatform --
d305 1
a305 2
 *	This is a kludge that allows the test library to get access
 *	the internal tclPlatform variable.
d308 1
a308 1
 *	Returns a pointer to the tclPlatform variable.
d311 1
a311 1
 *	None.
d315 53
d369 3
a371 4
TclPlatformType *
TclWinGetPlatform()
{
    return &tclPlatform;
d375 1
a375 1
 *---------------------------------------------------------------------------
d377 1
a377 1
 * TclWinSetInterfaces --
d379 1
a379 4
 *	A helper proc that allows the test library to change the
 *	tclWinProcs structure to dispatch to either the wide-character
 *	or multi-byte versions of the operating system calls, depending
 *	on whether Unicode is the system encoding.
d382 1
a382 1
 *	None.
d387 1
a387 1
 *---------------------------------------------------------------------------
d390 2
a391 4
void
TclWinSetInterfaces(
    int wide)			/* Non-zero to use wide interfaces, 0
				 * otherwise. */
d393 1
a393 9
    Tcl_FreeEncoding(tclWinTCharEncoding);

    if (wide) {
	tclWinProcs = &unicodeProcs;
	tclWinTCharEncoding = Tcl_GetEncoding(NULL, "unicode");
    } else {
	tclWinProcs = &asciiProcs;
	tclWinTCharEncoding = NULL;
    }
d397 1
a397 1
 *---------------------------------------------------------------------------
d399 1
a399 1
 * Tcl_WinUtfToTChar, Tcl_WinTCharToUtf --
d401 2
a402 36
 *	Convert between UTF-8 and Unicode when running Windows NT or 
 *	the current ANSI code page when running Windows 95.
 *
 *	On Mac, Unix, and Windows 95, all strings exchanged between Tcl
 *	and the OS are "char" oriented.  We need only one Tcl_Encoding to
 *	convert between UTF-8 and the system's native encoding.  We use
 *	NULL to represent that encoding.
 *
 *	On NT, some strings exchanged between Tcl and the OS are "char"
 *	oriented, while others are in Unicode.  We need two Tcl_Encoding
 *	APIs depending on whether we are targeting a "char" or Unicode
 *	interface.  
 *
 *	Calling Tcl_UtfToExternal() or Tcl_ExternalToUtf() with an
 *	encoding of NULL should always used to convert between UTF-8
 *	and the system's "char" oriented encoding.  The following two
 *	functions are used in Windows-specific code to convert between
 *	UTF-8 and Unicode strings (NT) or "char" strings(95).  This saves
 *	you the trouble of writing the following type of fragment over and
 *	over:
 *
 *		if (running NT) {
 *		    encoding <- Tcl_GetEncoding("unicode");
 *		    nativeBuffer <- UtfToExternal(encoding, utfBuffer);
 *		    Tcl_FreeEncoding(encoding);
 *		} else {
 *		    nativeBuffer <- UtfToExternal(NULL, utfBuffer);
 *		}
 *
 *	By convention, in Windows a TCHAR is a character in the ANSI code
 *	page on Windows 95, a Unicode character on Windows NT.  If you
 *	plan on targeting a Unicode interfaces when running on NT and a
 *	"char" oriented interface while running on 95, these functions
 *	should be used.  If you plan on targetting the same "char"
 *	oriented function on both 95 and NT, use Tcl_UtfToExternal()
 *	with an encoding of NULL.
d405 4
a408 4
 *	The result is a pointer to the string in the desired target
 *	encoding.  Storage for the result string is allocated in
 *	dsPtr; the caller must call Tcl_DStringFree() when the result
 *	is no longer needed.
d413 1
a413 1
 *---------------------------------------------------------------------------
d416 2
a417 20
TCHAR *
Tcl_WinUtfToTChar(string, len, dsPtr)
    CONST char *string;		/* Source string in UTF-8. */
    int len;			/* Source string length in bytes, or < 0 for
				 * strlen(). */
    Tcl_DString *dsPtr;		/* Uninitialized or free DString in which 
				 * the converted string is stored. */
{
    return (TCHAR *) Tcl_UtfToExternalDString(tclWinTCharEncoding, 
	    string, len, dsPtr);
}

char *
Tcl_WinTCharToUtf(string, len, dsPtr)
    CONST TCHAR *string;	/* Source string in Unicode when running
				 * NT, ANSI when running 95. */
    int len;			/* Source string length in bytes, or < 0 for
				 * platform-specific string length. */
    Tcl_DString *dsPtr;		/* Uninitialized or free DString in which 
				 * the converted string is stored. */
d419 1
a419 2
    return Tcl_ExternalToUtfDString(tclWinTCharEncoding, 
	    (CONST char *) string, len, dsPtr);
a420 3



@


1.1.1.4
log
@import tcl 8.4.0
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tclWin32Dll.c,v 1.16 2002/06/13 09:40:01 vincentdarley Exp $
a39 5
#ifdef HAVE_NO_SEH
static void *ESP;
static void *EBP;
#endif /* HAVE_NO_SEH */

a80 2
    NULL,
    NULL,
a117 2
    NULL,
    NULL,
d130 8
d193 10
a358 2
    int retval = 0;

d366 1
a366 10
#ifdef HAVE_NO_SEH
    __asm__ __volatile__ (
            "movl  %esp, _ESP" "\n\t"
            "movl  %ebp, _EBP");

    __asm__ __volatile__ (
            "pushl $__except_checkstackspace_handler" "\n\t"
            "pushl %fs:0" "\n\t"
            "mov   %esp, %fs:0");
#else
a367 1
#endif /* HAVE_NO_SEH */
d369 3
a371 13
	retval = 1;
#ifdef HAVE_NO_SEH
    __asm__ __volatile__ (
            "jmp   checkstackspace_pop" "\n"
            "checkstackspace_reentry:" "\n\t"
            "movl  _ESP, %esp" "\n\t"
            "movl  _EBP, %ebp");

    __asm__ __volatile__ (
            "checkstackspace_pop:" "\n\t"
            "mov   (%esp), %eax" "\n\t"
            "mov   %eax, %fs:0" "\n\t"
            "add   $8, %esp");
d373 2
a374 2
    } __except (EXCEPTION_EXECUTE_HANDLER) {}
#endif /* HAVE_NO_SEH */
d376 1
a376 4
    /*
     * Avoid using control flow statements in the SEH guarded block!
     */
    return retval;
d378 1
a378 15
#ifdef HAVE_NO_SEH
static
__attribute__ ((cdecl))
EXCEPTION_DISPOSITION
_except_checkstackspace_handler(
    struct _EXCEPTION_RECORD *ExceptionRecord,
    void *EstablisherFrame,
    struct _CONTEXT *ContextRecord,
    void *DispatcherContext)
{
    __asm__ __volatile__ (
            "jmp checkstackspace_reentry");
    return 0; /* Function does not return */
}
#endif /* HAVE_NO_SEH */
a411 4
 *	
 *	As well as this, we can also try to load in some additional
 *	procs which may/may not be present depending on the current
 *	Windows version (e.g. Win95 will not have the procs below).
a431 13
	if (tclWinProcs->getFileAttributesExProc == NULL) {
	    HINSTANCE hInstance = LoadLibraryA("kernel32");
	    if (hInstance != NULL) {
	        tclWinProcs->getFileAttributesExProc = 
		  (BOOL (WINAPI *)(CONST TCHAR *, GET_FILEEX_INFO_LEVELS, 
		  LPVOID)) GetProcAddress(hInstance, "GetFileAttributesExW");
		tclWinProcs->createHardLinkProc = 
		  (BOOL (WINAPI *)(CONST TCHAR *, CONST TCHAR*, 
		  LPSECURITY_ATTRIBUTES)) GetProcAddress(hInstance, 
		  "CreateHardLinkW");
		FreeLibrary(hInstance);
	    }
	}
a434 13
	if (tclWinProcs->getFileAttributesExProc == NULL) {
	    HINSTANCE hInstance = LoadLibraryA("kernel32");
	    if (hInstance != NULL) {
		tclWinProcs->getFileAttributesExProc = 
		  (BOOL (WINAPI *)(CONST TCHAR *, GET_FILEEX_INFO_LEVELS, 
		  LPVOID)) GetProcAddress(hInstance, "GetFileAttributesExA");
		tclWinProcs->createHardLinkProc = 
		  (BOOL (WINAPI *)(CONST TCHAR *, CONST TCHAR*, 
		  LPSECURITY_ATTRIBUTES)) GetProcAddress(hInstance, 
		  "CreateHardLinkA");
		FreeLibrary(hInstance);
	    }
	}
d516 3
@


