head	1.6;
access;
symbols
	sid-snapshot-20180601:1.6
	sid-snapshot-20180501:1.6
	sid-snapshot-20180401:1.6
	sid-snapshot-20180301:1.6
	sid-snapshot-20180201:1.6
	sid-snapshot-20180101:1.6
	sid-snapshot-20171201:1.6
	sid-snapshot-20171101:1.6
	sid-snapshot-20171001:1.6
	sid-snapshot-20170901:1.6
	sid-snapshot-20170801:1.6
	sid-snapshot-20170701:1.6
	sid-snapshot-20170601:1.6
	sid-snapshot-20170501:1.6
	sid-snapshot-20170401:1.6
	sid-snapshot-20170301:1.6
	sid-snapshot-20170201:1.6
	sid-snapshot-20170101:1.6
	sid-snapshot-20161201:1.6
	sid-snapshot-20161101:1.6
	sid-snapshot-20160901:1.6
	sid-snapshot-20160801:1.6
	sid-snapshot-20160701:1.6
	sid-snapshot-20160601:1.6
	sid-snapshot-20160501:1.6
	sid-snapshot-20160401:1.6
	sid-snapshot-20160301:1.6
	sid-snapshot-20160201:1.6
	sid-snapshot-20160101:1.6
	sid-snapshot-20151201:1.6
	sid-snapshot-20151101:1.6
	sid-snapshot-20151001:1.6
	sid-snapshot-20150901:1.6
	sid-snapshot-20150801:1.6
	sid-snapshot-20150701:1.6
	sid-snapshot-20150601:1.6
	sid-snapshot-20150501:1.6
	sid-snapshot-20150401:1.6
	sid-snapshot-20150301:1.6
	sid-snapshot-20150201:1.6
	sid-snapshot-20150101:1.6
	sid-snapshot-20141201:1.6
	sid-snapshot-20141101:1.6
	sid-snapshot-20141001:1.6
	sid-snapshot-20140901:1.6
	sid-snapshot-20140801:1.6
	sid-snapshot-20140701:1.6
	sid-snapshot-20140601:1.6
	sid-snapshot-20140501:1.6
	sid-snapshot-20140401:1.6
	sid-snapshot-20140301:1.6
	sid-snapshot-20140201:1.6
	sid-snapshot-20140101:1.6
	sid-snapshot-20131201:1.6
	sid-snapshot-20131101:1.6
	sid-snapshot-20131001:1.6
	sid-snapshot-20130901:1.6
	sid-snapshot-20130801:1.6
	sid-snapshot-20130701:1.6
	sid-snapshot-20130601:1.6
	insight_7_6-2013-04-10-branchpoint:1.6
	gdb_7_6-branch:1.6.0.58
	sid-snapshot-20130501:1.6
	sid-snapshot-20130401:1.6
	sid-snapshot-20130301:1.6
	sid-snapshot-20130201:1.6
	sid-snapshot-20130101:1.6
	sid-snapshot-20121201:1.6
	sid-snapshot-20121101:1.6
	sid-snapshot-20121001:1.6
	sid-snapshot-20120901:1.6
	gdb_7_5-branch:1.6.0.56
	sid-snapshot-20120801:1.6
	sid-snapshot-20120701:1.6
	sid-snapshot-20120601:1.6
	sid-snapshot-20120501:1.6
	sid-snapshot-20120401:1.6
	gdb_7_4-branch:1.6.0.54
	sid-snapshot-20120301:1.6
	sid-snapshot-20120201:1.6
	sid-snapshot-20120101:1.6
	sid-snapshot-20111201:1.6
	sid-snapshot-20111101:1.6
	sid-snapshot-20111001:1.6
	sid-snapshot-20110901:1.6
	gdb_7_3-branch:1.6.0.52
	sid-snapshot-20110801:1.6
	sid-snapshot-20110701:1.6
	sid-snapshot-20110601:1.6
	sid-snapshot-20110501:1.6
	sid-snapshot-20110401:1.6
	sid-snapshot-20110301:1.6
	sid-snapshot-20110201:1.6
	sid-snapshot-20110101:1.6
	sid-snapshot-20101201:1.6
	sid-snapshot-20101101:1.6
	sid-snapshot-20101001:1.6
	sid-snapshot-20100901:1.6
	sid-snapshot-20100801:1.6
	sid-snapshot-20100701:1.6
	sid-snapshot-20100601:1.6
	sid-snapshot-20100501:1.6
	sid-snapshot-20100401:1.6
	sid-snapshot-20100301:1.6
	gdb_7_1-branch:1.6.0.50
	gdb_7_0-branch:1.6.0.48
	sid-snapshot-20100201:1.6
	sid-snapshot-20100101:1.6
	sid-snapshot-20091201:1.6
	sid-snapshot-20091101:1.6
	sid-snapshot-20091001:1.6
	arc-sim-20090309:1.6
	sid-snapshot-20090901:1.6
	sid-snapshot-20090801:1.6
	sid-snapshot-20090701:1.6
	sid-snapshot-20090601:1.6
	sid-snapshot-20090501:1.6
	kevinb-pre-tcl8_5_7_merge:1.6
	sid-snapshot-20090401:1.6
	arc-insight_6_8-branch:1.6.0.46
	arc-insight_6_8-branchpoint:1.6
	insight_6_8-branch:1.6.0.44
	insight_6_8-branchpoint:1.6
	sid-snapshot-20090301:1.6
	sid-snapshot-20090201:1.6
	sid-snapshot-20090101:1.6
	sid-snapshot-20081201:1.6
	sid-snapshot-20081101:1.6
	sid-snapshot-20081001:1.6
	sid-snapshot-20080901:1.6
	sid-snapshot-20080801:1.6
	sid-snapshot-20080701:1.6
	sid-snapshot-20080601:1.6
	sid-snapshot-20080501:1.6
	sid-snapshot-20080403:1.6
	sid-snapshot-20080401:1.6
	gdb_6_8-branch:1.6.0.42
	sid-snapshot-20080301:1.6
	sid-snapshot-20080201:1.6
	sid-snapshot-20080101:1.6
	sid-snapshot-20071201:1.6
	sid-snapshot-20071101:1.6
	sid-snapshot-20071001:1.6
	insight_6_6-20070208-release:1.6
	gdb_6_6-branch:1.6.0.40
	gdb_6_6-2006-11-15-branchpoint:1.6
	insight_6_5-20061003-release:1.6
	gdb_6_5-branch:1.6.0.38
	gdb_6_5-2006-05-14-branchpoint:1.6
	readline_5_1-import-branch:1.6.0.36
	readline_5_1-import-branchpoint:1.6
	gdb_6_4-branch:1.6.0.34
	gdb_6_4-2005-11-01-branchpoint:1.6
	msnyder-tracepoint-checkpoint-branch:1.6.0.32
	msnyder-tracepoint-checkpoint-branchpoint:1.6
	gdb_6_1-2004-04-05-release:1.6
	ezannoni_pie-20040323-branch:1.6.0.30
	ezannoni_pie-20040323-branchpoint:1.6
	cagney_tramp-20040321-mergepoint:1.6
	cagney_tramp-20040309-branch:1.6.0.28
	cagney_tramp-20040309-branchpoint:1.6
	gdb_6_1-branch:1.6.0.26
	gdb_6_1-2004-03-01-gmt-branchpoint:1.6
	drow-cplus-merge-20040208:1.6
	carlton_dictionary-20040126-merge:1.6
	drow-cplus-merge-20040113:1.6
	drow-cplus-merge-20031224:1.6
	drow-cplus-merge-20031220:1.6
	carlton_dictionary-20031215-merge:1.6
	drow-cplus-merge-20031214:1.6
	carlton-dictionary-20031111-merge:1.6
	gdb_6_0-2003-10-04-release:1.6
	carlton_dictionary-20030917-merge:1.6
	ezannoni_pie-20030916-branchpoint:1.6
	ezannoni_pie-20030916-branch:1.6.0.24
	cagney_x86i386-20030821-branch:1.6.0.22
	cagney_x86i386-20030821-branchpoint:1.6
	carlton_dictionary-20030805-merge:1.6
	carlton_dictionary-20030627-merge:1.6
	gdb_6_0-branch:1.6.0.20
	gdb_6_0-2003-06-23-branchpoint:1.6
	cagney_convert-20030606-branch:1.6.0.18
	cagney_convert-20030606-branchpoint:1.6
	cagney_writestrings-20030508-branch:1.6.0.16
	cagney_writestrings-20030508-branchpoint:1.6
	carlton_dictionary-20030523-merge:1.6
	cagney_fileio-20030521-branch:1.6.0.14
	cagney_fileio-20030521-branchpoint:1.6
	carlton_dictionary-20030430-merge:1.6
	carlton_dictionary-20030416-merge:1.6
	cagney_frameaddr-20030409-mergepoint:1.6
	cagney_frameaddr-20030403-branchpoint:1.6
	cagney_frameaddr-20030403-branch:1.6.0.12
	cagney_framebase-20030330-mergepoint:1.6
	cagney_framebase-20030326-branch:1.6.0.10
	cagney_framebase-20030326-branchpoint:1.6
	cagney_lazyid-20030317-branch:1.6.0.8
	cagney_lazyid-20030317-branchpoint:1.6
	offbyone-20030313-branch:1.6.0.6
	offbyone-20030313-branchpoint:1.6
	carlton_dictionary-20030305-merge:1.6
	cagney_offbyone-20030303-branch:1.6.0.4
	cagney_offbyone-20030303-branchpoint:1.6
	carlton_dictionary-20030207-merge:1.6
	interps-20030202-branch:1.6.0.2
	interps-20030202-branchpoint:1.6
	TCL8_4_1:1.1.1.3
	cagney-unwind-20030108-branch:1.5.0.2
	cagney-unwind-20030108-branchpoint:1.5
	carlton_dictionary-20021223-merge:1.5
	gdb_5_3-2002-12-12-release:1.2
	TCL_8_4_1:1.1.1.3
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.4
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TCL_8_4_0:1.1.1.3
	carlton_dictionary-branch:1.2.0.16
	carlton_dictionary-20020920-branchpoint:1.2
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.14
	gdb_5_3-branch:1.2.0.12
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.10
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.8
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.6
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TCL_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	dejagnu-2000-02-04:1.1.1.1
	dejagnu-2000-01-31:1.1.1.1
	dejagnu-2000-01-24:1.1.1.1
	dejagnu-2000-01-17:1.1.1.1
	dejagnu-2000-01-10:1.1.1.1
	dejagnu-2000-01-04:1.1.1.1
	dejagnu-1999-12-21:1.1.1.1
	dejagnu-1999-12-13:1.1.1.1
	dejagnu-1999-12-07:1.1.1.1
	dejagnu-1999-12-06:1.1.1.1
	dejagnu-1999-11-15:1.1.1.1
	dejagnu-1999-11-08:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.6
date	2003.01.21.19.40.23;	author hunt;	state Exp;
branches;
next	1.5;

1.5
date	2002.12.20.02.09.18;	author cgf;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.26.19.48.07;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.37.11;	author kseitz;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2001.09.09.23.56.10;	author irox;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2002.09.27.21.49.15;	author kseitz;	state Exp;
branches;
next	;

1.3.4.1
date	2003.12.14.20.28.56;	author drow;	state Exp;
branches;
next	;

1.2.16.1
date	2002.12.23.19.40.57;	author carlton;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2003.02.07.19.18.24;	author carlton;	state Exp;
branches;
next	;

1.1.1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.09.22.41.00;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.19.56.44;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.6
log
@Updated to tcl 8.4.1
@
text
@/* 
 * tclWinInit.c --
 *
 *	Contains the Windows-specific interpreter initialization functions.
 *
 * Copyright (c) 1994-1997 Sun Microsystems, Inc.
 * Copyright (c) 1998-1999 by Scriptics Corporation.
 * All rights reserved.
 *
 * RCS: @@(#) $Id: tclWinInit.c,v 1.35 2002/02/08 02:52:55 dgp Exp $
 */

#include "tclWinInt.h"
#include <winnt.h>
#include <winbase.h>

/*
 * The following declaration is a workaround for some Microsoft brain damage.
 * The SYSTEM_INFO structure is different in various releases, even though the
 * layout is the same.  So we overlay our own structure on top of it so we
 * can access the interesting slots in a uniform way.
 */

typedef struct {
    WORD wProcessorArchitecture;
    WORD wReserved;
} OemId;

/*
 * The following macros are missing from some versions of winnt.h.
 */

#ifndef PROCESSOR_ARCHITECTURE_INTEL
#define PROCESSOR_ARCHITECTURE_INTEL 0
#endif
#ifndef PROCESSOR_ARCHITECTURE_MIPS
#define PROCESSOR_ARCHITECTURE_MIPS  1
#endif
#ifndef PROCESSOR_ARCHITECTURE_ALPHA
#define PROCESSOR_ARCHITECTURE_ALPHA 2
#endif
#ifndef PROCESSOR_ARCHITECTURE_PPC
#define PROCESSOR_ARCHITECTURE_PPC   3
#endif
#ifndef PROCESSOR_ARCHITECTURE_SHX  
#define PROCESSOR_ARCHITECTURE_SHX   4
#endif
#ifndef PROCESSOR_ARCHITECTURE_ARM
#define PROCESSOR_ARCHITECTURE_ARM   5
#endif
#ifndef PROCESSOR_ARCHITECTURE_IA64
#define PROCESSOR_ARCHITECTURE_IA64  6
#endif
#ifndef PROCESSOR_ARCHITECTURE_ALPHA64
#define PROCESSOR_ARCHITECTURE_ALPHA64 7
#endif
#ifndef PROCESSOR_ARCHITECTURE_MSIL
#define PROCESSOR_ARCHITECTURE_MSIL  8
#endif
#ifndef PROCESSOR_ARCHITECTURE_UNKNOWN
#define PROCESSOR_ARCHITECTURE_UNKNOWN 0xFFFF
#endif

/*
 * The following arrays contain the human readable strings for the Windows
 * platform and processor values.
 */


#define NUMPLATFORMS 3
static char* platforms[NUMPLATFORMS] = {
    "Win32s", "Windows 95", "Windows NT"
};

#define NUMPROCESSORS 9
static char* processors[NUMPROCESSORS] = {
    "intel", "mips", "alpha", "ppc", "shx", "arm", "ia64", "alpha64", "msil"
};

/* Used to store the encoding used for binary files */
static Tcl_Encoding binaryEncoding = NULL;
/* Has the basic library path encoding issue been fixed */
static int libraryPathEncodingFixed = 0;

/*
 * The Init script (common to Windows and Unix platforms) is
 * defined in tkInitScript.h
 */

#include "tclInitScript.h"

static void		AppendEnvironment(Tcl_Obj *listPtr, CONST char *lib);
static void		AppendDllPath(Tcl_Obj *listPtr, HMODULE hModule,
			    CONST char *lib);
static int		ToUtf(CONST WCHAR *wSrc, char *dst);

/*
 *---------------------------------------------------------------------------
 *
 * TclpInitPlatform --
 *
 *	Initialize all the platform-dependant things like signals and
 *	floating-point error handling.
 *
 *	Called at process initialization time.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
 */

void
TclpInitPlatform()
{
    tclPlatform = TCL_PLATFORM_WINDOWS;

    /*
     * The following code stops Windows 3.X and Windows NT 3.51 from 
     * automatically putting up Sharing Violation dialogs, e.g, when 
     * someone tries to access a file that is locked or a drive with no 
     * disk in it.  Tcl already returns the appropriate error to the 
     * caller, and they can decide to put up their own dialog in response 
     * to that failure.  
     *
     * Under 95 and NT 4.0, this is a NOOP because the system doesn't 
     * automatically put up dialogs when the above operations fail.
     */

    SetErrorMode(SetErrorMode(0) | SEM_FAILCRITICALERRORS);

#ifdef STATIC_BUILD
    /*
     * If we are in a statically linked executable, then we need to
     * explicitly initialize the Windows function tables here since
     * DllMain() will not be invoked.
     */

    TclWinInit(GetModuleHandle(NULL));
#endif
}

/*
 *---------------------------------------------------------------------------
 *
 * TclpInitLibraryPath --
 *
 *	Initialize the library path at startup.  
 *
 *	This call sets the library path to strings in UTF-8. Any 
 *	pre-existing library path information is assumed to have been 
 *	in the native multibyte encoding.
 *
 *	Called at process initialization time.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
 */

void
TclpInitLibraryPath(path)
    CONST char *path;		/* Potentially dirty UTF string that is */
				/* the path to the executable name.     */
{
#define LIBRARY_SIZE	    32
    Tcl_Obj *pathPtr, *objPtr;
    CONST char *str;
    Tcl_DString ds;
    int pathc;
    CONST char **pathv;
    char installLib[LIBRARY_SIZE], developLib[LIBRARY_SIZE];
#ifdef __CYGWIN__
    char installLib2[LIBRARY_SIZE];
#endif
    Tcl_DStringInit(&ds);
    pathPtr = Tcl_NewObj();

    /*
     * Initialize the substrings used when locating an executable.  The
     * installLib variable computes the path as though the executable
     * is installed.  The developLib computes the path as though the
     * executable is run from a develpment directory.
     */

    /* REDHAT LOCAL */
    /* Due to cygwin standard practice, the tcl binary will be
       installed in /bin rather than /usr/bin.  This means that, without
       this change, tcl will search in x:\share rather than x:\usr\share. */

    /* sprintf(installLib, "lib/tcl%s", TCL_VERSION); */
    sprintf(installLib, "share/tcl%s", TCL_VERSION);
#ifdef __CYGWIN__
    sprintf(installLib2, "usr/share/tcl%s", TCL_VERSION);
#endif
    /* END REDHAT LOCAL */

    sprintf(developLib, "../tcl%s/library", TCL_PATCH_LEVEL);

    /*
     * Look for the library relative to default encoding dir.
     */

    str = Tcl_GetDefaultEncodingDir();
    if ((str != NULL) && (str[0] != '\0')) {
	objPtr = Tcl_NewStringObj(str, -1);
	Tcl_ListObjAppendElement(NULL, pathPtr, objPtr);
    }

    /*
     * Look for the library relative to the TCL_LIBRARY env variable.
     * If the last dirname in the TCL_LIBRARY path does not match the
     * last dirname in the installLib variable, use the last dir name
     * of installLib in addition to the orginal TCL_LIBRARY path.
     */

    AppendEnvironment(pathPtr, installLib);

    /*
     * Look for the library relative to the DLL.  Only use the installLib
     * because in practice, the DLL is always installed.
     */

    AppendDllPath(pathPtr, TclWinGetTclInstance(), installLib);
    

    /*
     * Look for the library relative to the executable.  This algorithm
     * should be the same as the one in the tcl_findLibrary procedure.
     *
     * This code looks in the following directories:
     *
     *	<bindir>/../<installLib>
     *	  (e.g. /usr/local/bin/../lib/tcl8.4)
     *	<bindir>/../../<installLib>
     * 	  (e.g. /usr/local/TclPro/solaris-sparc/bin/../../lib/tcl8.4)
     *	<bindir>/../library
     * 	  (e.g. /usr/src/tcl8.4.0/unix/../library)
     *	<bindir>/../../library
     *	  (e.g. /usr/src/tcl8.4.0/unix/solaris-sparc/../../library)
     *	<bindir>/../../<developLib>
     *	  (e.g. /usr/src/tcl8.4.0/unix/../../tcl8.4.0/library)
     *	<bindir>/../../../<developLib>
     *	   (e.g. /usr/src/tcl8.4.0/unix/solaris-sparc/../../../tcl8.4.0/library)
     */
     
    /*
     * The variable path holds an absolute path.  Take care not to
     * overwrite pathv[0] since that might produce a relative path.
     */

    if (path != NULL) {
	Tcl_SplitPath(path, &pathc, &pathv);


	if (pathc > 2) {
	    str = pathv[pathc - 2];
	    pathv[pathc - 2] = installLib;
	    path = Tcl_JoinPath(pathc - 1, pathv, &ds);
	    pathv[pathc - 2] = str;
	    objPtr = Tcl_NewStringObj(path, Tcl_DStringLength(&ds));
	    Tcl_ListObjAppendElement(NULL, pathPtr, objPtr);
	    Tcl_DStringFree(&ds);
	    /* REDHAT LOCAL */
#ifdef __CYGWIN__
	    pathv[pathc - 2] = installLib2;
	    path = Tcl_JoinPath(pathc - 1, pathv, &ds);
	    pathv[pathc - 2] = str;
	    objPtr = Tcl_NewStringObj(path, Tcl_DStringLength(&ds));
	    Tcl_ListObjAppendElement(NULL, pathPtr, objPtr);
	    Tcl_DStringFree(&ds);
#endif
	    /* END REDHAT LOCAL */

	}
	if (pathc > 3) {
	    str = pathv[pathc - 3];
	    pathv[pathc - 3] = installLib;
	    path = Tcl_JoinPath(pathc - 2, pathv, &ds);
	    pathv[pathc - 3] = str;
	    objPtr = Tcl_NewStringObj(path, Tcl_DStringLength(&ds));
	    Tcl_ListObjAppendElement(NULL, pathPtr, objPtr);
	    Tcl_DStringFree(&ds);
	}
	if (pathc > 2) {
	    str = pathv[pathc - 2];
	    pathv[pathc - 2] = "library";
	    path = Tcl_JoinPath(pathc - 1, pathv, &ds);
	    pathv[pathc - 2] = str;
	    objPtr = Tcl_NewStringObj(path, Tcl_DStringLength(&ds));
	    Tcl_ListObjAppendElement(NULL, pathPtr, objPtr);
	    Tcl_DStringFree(&ds);
	}
	if (pathc > 3) {
	    str = pathv[pathc - 3];
	    pathv[pathc - 3] = "library";
	    path = Tcl_JoinPath(pathc - 2, pathv, &ds);
	    pathv[pathc - 3] = str;
	    objPtr = Tcl_NewStringObj(path, Tcl_DStringLength(&ds));
	    Tcl_ListObjAppendElement(NULL, pathPtr, objPtr);
	    Tcl_DStringFree(&ds);
	}
	if (pathc > 3) {
	    str = pathv[pathc - 3];
	    pathv[pathc - 3] = developLib;
	    path = Tcl_JoinPath(pathc - 2, pathv, &ds);
	    pathv[pathc - 3] = str;
	    objPtr = Tcl_NewStringObj(path, Tcl_DStringLength(&ds));
	    Tcl_ListObjAppendElement(NULL, pathPtr, objPtr);
	    Tcl_DStringFree(&ds);
	}
	if (pathc > 4) {
	    str = pathv[pathc - 4];
	    pathv[pathc - 4] = developLib;
	    path = Tcl_JoinPath(pathc - 3, pathv, &ds);
	    pathv[pathc - 4] = str;
	    objPtr = Tcl_NewStringObj(path, Tcl_DStringLength(&ds));
	    Tcl_ListObjAppendElement(NULL, pathPtr, objPtr);
	    Tcl_DStringFree(&ds);
	}
	ckfree((char *) pathv);
    }

    TclSetLibraryPath(pathPtr);
}

/*
 *---------------------------------------------------------------------------
 *
 * AppendEnvironment --
 *
 *	Append the value of the TCL_LIBRARY environment variable onto the
 *	path pointer.  If the env variable points to another version of
 *	tcl (e.g. "tcl7.6") also append the path to this version (e.g.,
 *	"tcl7.6/../tcl8.2")
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
 */

static void
AppendEnvironment(
    Tcl_Obj *pathPtr,
    CONST char *lib)
{
    int pathc;
    WCHAR wBuf[MAX_PATH];
    char buf[MAX_PATH * TCL_UTF_MAX];
    Tcl_Obj *objPtr;
    Tcl_DString ds;
    CONST char **pathv;

    /*
     * The "L" preceeding the TCL_LIBRARY string is used to tell VC++
     * that this is a unicode string.
     */
    
    if (GetEnvironmentVariableW(L"TCL_LIBRARY", wBuf, MAX_PATH) == 0) {
        buf[0] = '\0';
	GetEnvironmentVariableA("TCL_LIBRARY", buf, MAX_PATH);
    } else {
	ToUtf(wBuf, buf);
    }

    if (buf[0] != '\0') {
	objPtr = Tcl_NewStringObj(buf, -1);
	Tcl_ListObjAppendElement(NULL, pathPtr, objPtr);

	TclWinNoBackslash(buf);
	Tcl_SplitPath(buf, &pathc, &pathv);

	/* 
	 * The lstrcmpi() will work even if pathv[pathc - 1] is random
	 * UTF-8 chars because I know lib is ascii.
	 */

	if ((pathc > 0) && (lstrcmpiA(lib + 4, pathv[pathc - 1]) != 0)) {
	    CONST char *str;
	    /*
	     * TCL_LIBRARY is set but refers to a different tcl
	     * installation than the current version.  Try fiddling with the
	     * specified directory to make it refer to this installation by
	     * removing the old "tclX.Y" and substituting the current
	     * version string.
	     */
	    
	    pathv[pathc - 1] = (lib + 4);
	    Tcl_DStringInit(&ds);
	    str = Tcl_JoinPath(pathc, pathv, &ds);
	    objPtr = Tcl_NewStringObj(str, Tcl_DStringLength(&ds));
	    Tcl_DStringFree(&ds);
	} else {
	    objPtr = Tcl_NewStringObj(buf, -1);
	}
	Tcl_ListObjAppendElement(NULL, pathPtr, objPtr);
	ckfree((char *) pathv);
    }
}

/*
 *---------------------------------------------------------------------------
 *
 * AppendDllPath --
 *
 *	Append a path onto the path pointer that tries to locate the Tcl
 *	library relative to the location of the Tcl DLL.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
 */

static void 
AppendDllPath(
    Tcl_Obj *pathPtr, 
    HMODULE hModule,
    CONST char *lib)
{
    WCHAR wName[MAX_PATH + LIBRARY_SIZE];
    char name[(MAX_PATH + LIBRARY_SIZE) * TCL_UTF_MAX];

    if (GetModuleFileNameW(hModule, wName, MAX_PATH) == 0) {
	GetModuleFileNameA(hModule, name, MAX_PATH);
    } else {
	ToUtf(wName, name);
    }
    if (lib != NULL) {
	char *end, *p;

	end = strrchr(name, '\\');
	*end = '\0';
	p = strrchr(name, '\\');
	if (p != NULL) {
	    end = p;
	}
	*end = '\\';
	strcpy(end + 1, lib);
    }
    TclWinNoBackslash(name);
    Tcl_ListObjAppendElement(NULL, pathPtr, Tcl_NewStringObj(name, -1));
}

/*
 *---------------------------------------------------------------------------
 *
 * ToUtf --
 *
 *	Convert a char string to a UTF string.  
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
 */

static int
ToUtf(
    CONST WCHAR *wSrc,
    char *dst)
{
    char *start;

    start = dst;
    while (*wSrc != '\0') {
	dst += Tcl_UniCharToUtf(*wSrc, dst);
	wSrc++;
    }
    *dst = '\0';
    return (int) (dst - start);
}


/*
 *---------------------------------------------------------------------------
 *
 * TclpSetInitialEncodings --
 *
 *	Based on the locale, determine the encoding of the operating
 *	system and the default encoding for newly opened files.
 *
 *	Called at process initialization time, and part way through
 *	startup, we verify that the initial encodings were correctly
 *	setup.  Depending on Tcl's environment, there may not have been
 *	enough information first time through (above).
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The Tcl library path is converted from native encoding to UTF-8,
 *	on the first call, and the encodings may be changed on first or
 *	second call.
 *
 *---------------------------------------------------------------------------
 */

void
TclpSetInitialEncodings()
{
    CONST char *encoding;
    char buf[4 + TCL_INTEGER_SPACE];

    if (libraryPathEncodingFixed == 0) {
	int platformId;
	platformId = TclWinGetPlatformId();
	TclWinSetInterfaces(platformId == VER_PLATFORM_WIN32_NT);
	
	wsprintfA(buf, "cp%d", GetACP());
	Tcl_SetSystemEncoding(NULL, buf);

	if (platformId != VER_PLATFORM_WIN32_NT) {
	    Tcl_Obj *pathPtr = TclGetLibraryPath();
	    if (pathPtr != NULL) {
		int i, objc;
		Tcl_Obj **objv;
		
		objc = 0;
		Tcl_ListObjGetElements(NULL, pathPtr, &objc, &objv);
		for (i = 0; i < objc; i++) {
		    int length;
		    char *string;
		    Tcl_DString ds;

		    string = Tcl_GetStringFromObj(objv[i], &length);
		    Tcl_ExternalToUtfDString(NULL, string, length, &ds);
		    Tcl_SetStringObj(objv[i], Tcl_DStringValue(&ds), 
			    Tcl_DStringLength(&ds));
		    Tcl_DStringFree(&ds);
		}
	    }
	}
	
	libraryPathEncodingFixed = 1;
    } else {
	wsprintfA(buf, "cp%d", GetACP());
	Tcl_SetSystemEncoding(NULL, buf);
    }

    /* This is only ever called from the startup thread */
    if (binaryEncoding == NULL) {
	/*
	 * Keep this encoding preloaded.  The IO package uses it for
	 * gets on a binary channel.
	 */
	encoding = "iso8859-1";
	binaryEncoding = Tcl_GetEncoding(NULL, encoding);
    }
}

/*
 *---------------------------------------------------------------------------
 *
 * TclpSetVariables --
 *
 *	Performs platform-specific interpreter initialization related to
 *	the tcl_platform and env variables, and other platform-specific
 *	things.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Sets "tcl_platform", and "env(HOME)" Tcl variables.
 *
 *----------------------------------------------------------------------
 */

void
TclpSetVariables(interp)
    Tcl_Interp *interp;		/* Interp to initialize. */	
{	    
    CONST char *ptr;
    char buffer[TCL_INTEGER_SPACE * 2];
    SYSTEM_INFO sysInfo;
    OemId *oemId;
    OSVERSIONINFOA osInfo;
    Tcl_DString ds;

    osInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
    GetVersionExA(&osInfo);

    oemId = (OemId *) &sysInfo;
    GetSystemInfo(&sysInfo);

    /*
     * Define the tcl_platform array.
     */

    Tcl_SetVar2(interp, "tcl_platform", "platform", "windows",
	    TCL_GLOBAL_ONLY);
    if (osInfo.dwPlatformId < NUMPLATFORMS) {
	Tcl_SetVar2(interp, "tcl_platform", "os",
		platforms[osInfo.dwPlatformId], TCL_GLOBAL_ONLY);
    }
    wsprintfA(buffer, "%d.%d", osInfo.dwMajorVersion, osInfo.dwMinorVersion);
    Tcl_SetVar2(interp, "tcl_platform", "osVersion", buffer, TCL_GLOBAL_ONLY);
    if (oemId->wProcessorArchitecture < NUMPROCESSORS) {
	Tcl_SetVar2(interp, "tcl_platform", "machine",
		processors[oemId->wProcessorArchitecture],
		TCL_GLOBAL_ONLY);
    }

#ifdef _DEBUG
    /*
     * The existence of the "debug" element of the tcl_platform array indicates
     * that this particular Tcl shell has been compiled with debug information.
     * Using "info exists tcl_platform(debug)" a Tcl script can direct the 
     * interpreter to load debug versions of DLLs with the load command.
     */

    Tcl_SetVar2(interp, "tcl_platform", "debug", "1",
	    TCL_GLOBAL_ONLY);
#endif

    /*
     * Set up the HOME environment variable from the HOMEDRIVE & HOMEPATH
     * environment variables, if necessary.
     */

    Tcl_DStringInit(&ds);
    ptr = Tcl_GetVar2(interp, "env", "HOME", TCL_GLOBAL_ONLY);
    if (ptr == NULL) {
	ptr = Tcl_GetVar2(interp, "env", "HOMEDRIVE", TCL_GLOBAL_ONLY);
	if (ptr != NULL) {
	    Tcl_DStringAppend(&ds, ptr, -1);
	}
	ptr = Tcl_GetVar2(interp, "env", "HOMEPATH", TCL_GLOBAL_ONLY);
	if (ptr != NULL) {
	    Tcl_DStringAppend(&ds, ptr, -1);
	}
	if (Tcl_DStringLength(&ds) > 0) {
	    Tcl_SetVar2(interp, "env", "HOME", Tcl_DStringValue(&ds),
		    TCL_GLOBAL_ONLY);
	} else {
	    Tcl_SetVar2(interp, "env", "HOME", "c:\\", TCL_GLOBAL_ONLY);
	}
    }

    /*
     * Initialize the user name from the environment first, since this is much
     * faster than asking the system.
     */

    Tcl_DStringSetLength(&ds, 100);
    if (TclGetEnv("USERNAME", &ds) == NULL) {
	if (GetUserName(Tcl_DStringValue(&ds), (LPDWORD) &Tcl_DStringLength(&ds)) == 0) {
	    Tcl_DStringSetLength(&ds, 0);
	}
    }
    Tcl_SetVar2(interp, "tcl_platform", "user", Tcl_DStringValue(&ds),
	    TCL_GLOBAL_ONLY);
    Tcl_DStringFree(&ds);
}

/*
 *----------------------------------------------------------------------
 *
 * TclpFindVariable --
 *
 *	Locate the entry in environ for a given name.  On Unix this 
 *	routine is case sensetive, on Windows this matches mioxed case.
 *
 * Results:
 *	The return value is the index in environ of an entry with the
 *	name "name", or -1 if there is no such entry.   The integer at
 *	*lengthPtr is filled in with the length of name (if a matching
 *	entry is found) or the length of the environ array (if no matching
 *	entry is found).
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
TclpFindVariable(name, lengthPtr)
    CONST char *name;		/* Name of desired environment variable
				 * (UTF-8). */
    int *lengthPtr;		/* Used to return length of name (for
				 * successful searches) or number of non-NULL
				 * entries in environ (for unsuccessful
				 * searches). */
{
    int i, length, result = -1;
    register CONST char *env, *p1, *p2;
    char *envUpper, *nameUpper;
    Tcl_DString envString;

    /*
     * Convert the name to all upper case for the case insensitive
     * comparison.
     */

    length = strlen(name);
    nameUpper = (char *) ckalloc((unsigned) length+1);
    memcpy((VOID *) nameUpper, (VOID *) name, (size_t) length+1);
    Tcl_UtfToUpper(nameUpper);
    
    Tcl_DStringInit(&envString);
    for (i = 0, env = environ[i]; env != NULL; i++, env = environ[i]) {
	/*
	 * Chop the env string off after the equal sign, then Convert
	 * the name to all upper case, so we do not have to convert
	 * all the characters after the equal sign.
	 */
	
	envUpper = Tcl_ExternalToUtfDString(NULL, env, -1, &envString);
	p1 = strchr(envUpper, '=');
	if (p1 == NULL) {
	    continue;
	}
	length = (int) (p1 - envUpper);
	Tcl_DStringSetLength(&envString, length+1);
	Tcl_UtfToUpper(envUpper);

	p1 = envUpper;
	p2 = nameUpper;
	for (; *p2 == *p1; p1++, p2++) {
	    /* NULL loop body. */
	}
	if ((*p1 == '=') && (*p2 == '\0')) {
	    *lengthPtr = length;
	    result = i;
	    goto done;
	}
	
	Tcl_DStringFree(&envString);
    }
    
    *lengthPtr = i;

    done:
    Tcl_DStringFree(&envString);
    ckfree(nameUpper);
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_Init --
 *
 *	This procedure is typically invoked by Tcl_AppInit procedures
 *	to perform additional initialization for a Tcl interpreter,
 *	such as sourcing the "init.tcl" script.
 *
 * Results:
 *	Returns a standard Tcl completion code and sets the interp's
 *	result if there is an error.
 *
 * Side effects:
 *	Depends on what's in the init.tcl script.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_Init(interp)
    Tcl_Interp *interp;		/* Interpreter to initialize. */
{
    Tcl_Obj *pathPtr;

    if (tclPreInitScript != NULL) {
	if (Tcl_Eval(interp, tclPreInitScript) == TCL_ERROR) {
	    return (TCL_ERROR);
	};
    }

    pathPtr = TclGetLibraryPath();
    if (pathPtr == NULL) {
	pathPtr = Tcl_NewObj();
    }
    Tcl_SetVar2Ex(interp, "tcl_libPath", NULL, pathPtr, TCL_GLOBAL_ONLY);
    return Tcl_Eval(interp, initScript);
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_SourceRCFile --
 *
 *	This procedure is typically invoked by Tcl_Main of Tk_Main
 *	procedure to source an application specific rc file into the
 *	interpreter at startup time.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Depends on what's in the rc script.
 *
 *----------------------------------------------------------------------
 */

void
Tcl_SourceRCFile(interp)
    Tcl_Interp *interp;		/* Interpreter to source rc file into. */
{
    Tcl_DString temp;
    CONST char *fileName;
    Tcl_Channel errChannel;

    fileName = Tcl_GetVar(interp, "tcl_rcFileName", TCL_GLOBAL_ONLY);

    if (fileName != NULL) {
        Tcl_Channel c;
	CONST char *fullName;

        Tcl_DStringInit(&temp);
	fullName = Tcl_TranslateFileName(interp, fileName, &temp);
	if (fullName == NULL) {
	    /*
	     * Couldn't translate the file name (e.g. it referred to a
	     * bogus user or there was no HOME environment variable).
	     * Just do nothing.
	     */
	} else {

	    /*
	     * Test for the existence of the rc file before trying to read it.
	     */

            c = Tcl_OpenFileChannel(NULL, fullName, "r", 0);
            if (c != (Tcl_Channel) NULL) {
                Tcl_Close(NULL, c);
		if (Tcl_EvalFile(interp, fullName) != TCL_OK) {
		    errChannel = Tcl_GetStdChannel(TCL_STDERR);
		    if (errChannel) {
			Tcl_WriteObj(errChannel, Tcl_GetObjResult(interp));
			Tcl_WriteChars(errChannel, "\n", 1);
		    }
		}
	    }
	}
        Tcl_DStringFree(&temp);
    }
}
@


1.5
log
@* win/tclWinInit.c (TclpInitLibraryPath): Default to correct location for
installLib on cygwin.
@
text
@d10 1
a10 1
 * RCS: @@(#) $Id: tclWinInit.c,v 1.6.8.4 2001/06/15 05:19:08 mdejong Exp $
a13 1
#include <winreg.h>
a17 9
 * The following macro can be defined at compile time to specify
 * the root of the Tcl registry keys.
 */
 
#ifndef TCL_REGISTRY_KEY
#define TCL_REGISTRY_KEY "Software\\Scriptics\\Tcl\\" TCL_VERSION
#endif

/*
d45 15
d75 1
a75 1
#define NUMPROCESSORS 4
d77 1
a77 1
    "intel", "mips", "alpha", "ppc"
d80 4
a83 5
/*
 * Thread id used for asynchronous notification from signal handlers.
 */

static DWORD mainThreadId;
a94 1
static void		AppendRegistry(Tcl_Obj *listPtr, CONST char *lib);
a134 10
    /*
     * Save the id of the first thread to intialize the Tcl library.  This
     * thread will be used to handle notifications from async event
     * procedures.  This is not strictly correct.  A better solution involves
     * using a designated "main" notifier that is kept up to date as threads
     * come and go.
     */

    mainThreadId = GetCurrentThreadId();

d175 1
a175 1
    char *str;
d178 1
a178 1
    char **pathv;
d180 3
a182 1

d193 1
a193 1
    /* CYGNUS LOCAL */
d197 3
d201 1
a201 3
    sprintf(installLib, "usr/share/tcl%s", TCL_VERSION);
#else
    sprintf(installLib, "share/tcl%s", TCL_VERSION);
d203 3
a205 3
    /* END CYGNUS LOCAL */
    sprintf(developLib, "../tcl%s/library",
	    ((TCL_RELEASE_LEVEL < 2) ? TCL_PATCH_LEVEL : TCL_VERSION));
d241 1
a241 1
     *		(e.g. /usr/local/bin/../lib/tcl8.2)
d243 1
a243 1
     *		(e.g. /usr/local/TclPro/solaris-sparc/bin/../../lib/tcl8.2)
d245 1
a245 1
     *		(e.g. /usr/src/tcl8.2/unix/../library)
d247 1
a247 1
     *		(e.g. /usr/src/tcl8.2/unix/solaris-sparc/../../library)
d249 3
a251 3
     *		(e.g. /usr/src/tcl8.2/unix/../../tcl8.2/library)
     *	<bindir>/../../../<devlopLib>
     *		(e.g. /usr/src/tcl8.2/unix/solaris-sparc/../../../tcl8.2/library)
d254 5
d261 4
a264 1
	if (pathc > 1) {
d267 1
d271 11
d283 2
a284 1
	if (pathc > 2) {
d287 1
d292 2
a293 1
	if (pathc > 1) {
d296 1
d301 2
a302 1
	if (pathc > 2) {
d305 1
d310 2
a311 1
	if (pathc > 1) {
d314 1
d319 2
a320 1
	if (pathc > 3) {
d323 1
a361 1
    char *str;
d363 1
a363 1
    char **pathv;
d390 1
d399 1
a399 1
	    pathv[pathc - 1] = (char *) (lib + 4);
d488 1
a488 1
    return dst - start;
d500 4
a503 1
 *	Called at process initialization time.
d509 3
a511 1
 *	The Tcl library path is converted from native encoding to UTF-8.
a520 2
    int platformId;
    Tcl_Obj *pathPtr;
d522 7
a528 1
    platformId = TclWinGetPlatformId();
d530 19
a548 23
    TclWinSetInterfaces(platformId == VER_PLATFORM_WIN32_NT);

    wsprintfA(buf, "cp%d", GetACP());
    Tcl_SetSystemEncoding(NULL, buf);

    if (platformId != VER_PLATFORM_WIN32_NT) {
	pathPtr = TclGetLibraryPath();
	if (pathPtr != NULL) {
	    int i, objc;
	    Tcl_Obj **objv;
	    
	    objc = 0;
	    Tcl_ListObjGetElements(NULL, pathPtr, &objc, &objv);
	    for (i = 0; i < objc; i++) {
		int length;
		char *string;
		Tcl_DString ds;

		string = Tcl_GetStringFromObj(objv[i], &length);
		Tcl_ExternalToUtfDString(NULL, string, length, &ds);
		Tcl_SetStringObj(objv[i], Tcl_DStringValue(&ds), 
			Tcl_DStringLength(&ds));
		Tcl_DStringFree(&ds);
d551 5
d558 9
a566 7
    /*
     * Keep this encoding preloaded.  The IO package uses it for gets on a
     * binary channel.  
     */

    encoding = "iso8859-1";
    Tcl_GetEncoding(NULL, encoding);
d582 1
a582 2
 *	Sets "tclDefaultLibrary", "tcl_platform", and "env(HOME)" Tcl
 *	variables.
d591 1
a591 1
    char *ptr;
a604 6
     * Initialize the tclDefaultLibrary variable from the registry.
     */

    Tcl_SetVar(interp, "tclDefaultLibrary", "", TCL_GLOBAL_ONLY);

    /*
d665 1
a665 1
	if (GetUserName(Tcl_DStringValue(&ds), &Tcl_DStringLength(&ds)) == 0) {
d732 1
a732 1
	length = p1 - envUpper;
d820 1
a820 1
    char *fileName;
d827 1
a827 1
	char *fullName;
a857 31

/*
 *----------------------------------------------------------------------
 *
 * TclpAsyncMark --
 *
 *	Wake up the main thread from a signal handler.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Sends a message to the main thread.
 *
 *----------------------------------------------------------------------
 */

void
TclpAsyncMark(async)
    Tcl_AsyncHandler async;		/* Token for handler. */
{
    /*
     * Need a way to kick the Windows event loop and tell it to go look at
     * asynchronous events.
     */

    PostThreadMessage(mainThreadId, WM_USER, 0, 0);
}



@


1.4
log
@touched all sources to ease next import
@
text
@d199 6
d206 1
@


1.3
log
@touched all sources to ease next import
@
text
@@


1.3.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d10 1
a10 1
 * RCS: @@(#) $Id: tclWinInit.c,v 1.35 2002/02/08 02:52:55 dgp Exp $
d14 1
d19 9
a54 15
#ifndef PROCESSOR_ARCHITECTURE_SHX  
#define PROCESSOR_ARCHITECTURE_SHX   4
#endif
#ifndef PROCESSOR_ARCHITECTURE_ARM
#define PROCESSOR_ARCHITECTURE_ARM   5
#endif
#ifndef PROCESSOR_ARCHITECTURE_IA64
#define PROCESSOR_ARCHITECTURE_IA64  6
#endif
#ifndef PROCESSOR_ARCHITECTURE_ALPHA64
#define PROCESSOR_ARCHITECTURE_ALPHA64 7
#endif
#ifndef PROCESSOR_ARCHITECTURE_MSIL
#define PROCESSOR_ARCHITECTURE_MSIL  8
#endif
d70 1
a70 1
#define NUMPROCESSORS 9
d72 1
a72 1
    "intel", "mips", "alpha", "ppc", "shx", "arm", "ia64", "alpha64", "msil"
d75 5
a79 4
/* Used to store the encoding used for binary files */
static Tcl_Encoding binaryEncoding = NULL;
/* Has the basic library path encoding issue been fixed */
static int libraryPathEncodingFixed = 0;
d91 1
d132 10
d182 1
a182 1
    CONST char *str;
d185 1
a185 1
    CONST char **pathv;
d187 1
a187 3
#ifdef __CYGWIN__
    char installLib2[LIBRARY_SIZE];
#endif
d198 1
a198 6
    /* REDHAT LOCAL */
    /* Due to cygwin standard practice, the tcl binary will be
       installed in /bin rather than /usr/bin.  This means that, without
       this change, tcl will search in x:\share rather than x:\usr\share. */

    /* sprintf(installLib, "lib/tcl%s", TCL_VERSION); */
d200 3
a202 6
#ifdef __CYGWIN__
    sprintf(installLib2, "usr/share/tcl%s", TCL_VERSION);
#endif
    /* END REDHAT LOCAL */

    sprintf(developLib, "../tcl%s/library", TCL_PATCH_LEVEL);
d238 1
a238 1
     *	  (e.g. /usr/local/bin/../lib/tcl8.4)
d240 1
a240 1
     * 	  (e.g. /usr/local/TclPro/solaris-sparc/bin/../../lib/tcl8.4)
d242 1
a242 1
     * 	  (e.g. /usr/src/tcl8.4.0/unix/../library)
d244 1
a244 1
     *	  (e.g. /usr/src/tcl8.4.0/unix/solaris-sparc/../../library)
d246 3
a248 3
     *	  (e.g. /usr/src/tcl8.4.0/unix/../../tcl8.4.0/library)
     *	<bindir>/../../../<developLib>
     *	   (e.g. /usr/src/tcl8.4.0/unix/solaris-sparc/../../../tcl8.4.0/library)
a250 5
    /*
     * The variable path holds an absolute path.  Take care not to
     * overwrite pathv[0] since that might produce a relative path.
     */

d253 1
a253 4


	if (pathc > 2) {
	    str = pathv[pathc - 2];
a255 9
	    pathv[pathc - 2] = str;
	    objPtr = Tcl_NewStringObj(path, Tcl_DStringLength(&ds));
	    Tcl_ListObjAppendElement(NULL, pathPtr, objPtr);
	    Tcl_DStringFree(&ds);
	    /* REDHAT LOCAL */
#ifdef __CYGWIN__
	    pathv[pathc - 2] = installLib2;
	    path = Tcl_JoinPath(pathc - 1, pathv, &ds);
	    pathv[pathc - 2] = str;
a258 3
#endif
	    /* END REDHAT LOCAL */

d260 1
a260 2
	if (pathc > 3) {
	    str = pathv[pathc - 3];
a262 1
	    pathv[pathc - 3] = str;
d267 1
a267 2
	if (pathc > 2) {
	    str = pathv[pathc - 2];
a269 1
	    pathv[pathc - 2] = str;
d274 1
a274 2
	if (pathc > 3) {
	    str = pathv[pathc - 3];
a276 1
	    pathv[pathc - 3] = str;
d281 1
a281 2
	if (pathc > 3) {
	    str = pathv[pathc - 3];
a283 1
	    pathv[pathc - 3] = str;
d288 1
a288 2
	if (pathc > 4) {
	    str = pathv[pathc - 4];
a290 1
	    pathv[pathc - 4] = str;
d329 1
d331 1
a331 1
    CONST char **pathv;
a357 1
	    CONST char *str;
d366 1
a366 1
	    pathv[pathc - 1] = (lib + 4);
d455 1
a455 1
    return (int) (dst - start);
d467 1
a467 4
 *	Called at process initialization time, and part way through
 *	startup, we verify that the initial encodings were correctly
 *	setup.  Depending on Tcl's environment, there may not have been
 *	enough information first time through (above).
d473 1
a473 3
 *	The Tcl library path is converted from native encoding to UTF-8,
 *	on the first call, and the encodings may be changed on first or
 *	second call.
d483 6
d490 2
a491 7
    if (libraryPathEncodingFixed == 0) {
	int platformId;
	platformId = TclWinGetPlatformId();
	TclWinSetInterfaces(platformId == VER_PLATFORM_WIN32_NT);
	
	wsprintfA(buf, "cp%d", GetACP());
	Tcl_SetSystemEncoding(NULL, buf);
d493 18
a510 19
	if (platformId != VER_PLATFORM_WIN32_NT) {
	    Tcl_Obj *pathPtr = TclGetLibraryPath();
	    if (pathPtr != NULL) {
		int i, objc;
		Tcl_Obj **objv;
		
		objc = 0;
		Tcl_ListObjGetElements(NULL, pathPtr, &objc, &objv);
		for (i = 0; i < objc; i++) {
		    int length;
		    char *string;
		    Tcl_DString ds;

		    string = Tcl_GetStringFromObj(objv[i], &length);
		    Tcl_ExternalToUtfDString(NULL, string, length, &ds);
		    Tcl_SetStringObj(objv[i], Tcl_DStringValue(&ds), 
			    Tcl_DStringLength(&ds));
		    Tcl_DStringFree(&ds);
		}
a512 5
	
	libraryPathEncodingFixed = 1;
    } else {
	wsprintfA(buf, "cp%d", GetACP());
	Tcl_SetSystemEncoding(NULL, buf);
d515 7
a521 9
    /* This is only ever called from the startup thread */
    if (binaryEncoding == NULL) {
	/*
	 * Keep this encoding preloaded.  The IO package uses it for
	 * gets on a binary channel.
	 */
	encoding = "iso8859-1";
	binaryEncoding = Tcl_GetEncoding(NULL, encoding);
    }
d537 2
a538 1
 *	Sets "tcl_platform", and "env(HOME)" Tcl variables.
d547 1
a547 1
    CONST char *ptr;
d561 6
d627 1
a627 1
	if (GetUserName(Tcl_DStringValue(&ds), (LPDWORD) &Tcl_DStringLength(&ds)) == 0) {
d694 1
a694 1
	length = (int) (p1 - envUpper);
d782 1
a782 1
    CONST char *fileName;
d789 1
a789 1
	CONST char *fullName;
d820 31
@


1.3.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@d10 1
a10 1
 * RCS: @@(#) $Id: tclWinInit.c,v 1.35 2002/02/08 02:52:55 dgp Exp $
d14 1
d19 9
a54 15
#ifndef PROCESSOR_ARCHITECTURE_SHX  
#define PROCESSOR_ARCHITECTURE_SHX   4
#endif
#ifndef PROCESSOR_ARCHITECTURE_ARM
#define PROCESSOR_ARCHITECTURE_ARM   5
#endif
#ifndef PROCESSOR_ARCHITECTURE_IA64
#define PROCESSOR_ARCHITECTURE_IA64  6
#endif
#ifndef PROCESSOR_ARCHITECTURE_ALPHA64
#define PROCESSOR_ARCHITECTURE_ALPHA64 7
#endif
#ifndef PROCESSOR_ARCHITECTURE_MSIL
#define PROCESSOR_ARCHITECTURE_MSIL  8
#endif
d70 1
a70 1
#define NUMPROCESSORS 9
d72 1
a72 1
    "intel", "mips", "alpha", "ppc", "shx", "arm", "ia64", "alpha64", "msil"
d75 5
a79 4
/* Used to store the encoding used for binary files */
static Tcl_Encoding binaryEncoding = NULL;
/* Has the basic library path encoding issue been fixed */
static int libraryPathEncodingFixed = 0;
d91 1
d132 10
d182 1
a182 1
    CONST char *str;
d185 1
a185 1
    CONST char **pathv;
d198 5
a202 2
    sprintf(installLib, "lib/tcl%s", TCL_VERSION);
    sprintf(developLib, "../tcl%s/library", TCL_PATCH_LEVEL);
d238 1
a238 1
     *	  (e.g. /usr/local/bin/../lib/tcl8.4)
d240 1
a240 1
     * 	  (e.g. /usr/local/TclPro/solaris-sparc/bin/../../lib/tcl8.4)
d242 1
a242 1
     * 	  (e.g. /usr/src/tcl8.4.0/unix/../library)
d244 1
a244 1
     *	  (e.g. /usr/src/tcl8.4.0/unix/solaris-sparc/../../library)
d246 3
a248 3
     *	  (e.g. /usr/src/tcl8.4.0/unix/../../tcl8.4.0/library)
     *	<bindir>/../../../<developLib>
     *	   (e.g. /usr/src/tcl8.4.0/unix/solaris-sparc/../../../tcl8.4.0/library)
a250 5
    /*
     * The variable path holds an absolute path.  Take care not to
     * overwrite pathv[0] since that might produce a relative path.
     */

d253 1
a253 2
	if (pathc > 2) {
	    str = pathv[pathc - 2];
a255 1
	    pathv[pathc - 2] = str;
d260 1
a260 2
	if (pathc > 3) {
	    str = pathv[pathc - 3];
a262 1
	    pathv[pathc - 3] = str;
d267 1
a267 2
	if (pathc > 2) {
	    str = pathv[pathc - 2];
a269 1
	    pathv[pathc - 2] = str;
d274 1
a274 2
	if (pathc > 3) {
	    str = pathv[pathc - 3];
a276 1
	    pathv[pathc - 3] = str;
d281 1
a281 2
	if (pathc > 3) {
	    str = pathv[pathc - 3];
a283 1
	    pathv[pathc - 3] = str;
d288 1
a288 2
	if (pathc > 4) {
	    str = pathv[pathc - 4];
a290 1
	    pathv[pathc - 4] = str;
d329 1
d331 1
a331 1
    CONST char **pathv;
a357 1
	    CONST char *str;
d366 1
a366 1
	    pathv[pathc - 1] = (lib + 4);
d455 1
a455 1
    return (int) (dst - start);
d467 1
a467 4
 *	Called at process initialization time, and part way through
 *	startup, we verify that the initial encodings were correctly
 *	setup.  Depending on Tcl's environment, there may not have been
 *	enough information first time through (above).
d473 1
a473 3
 *	The Tcl library path is converted from native encoding to UTF-8,
 *	on the first call, and the encodings may be changed on first or
 *	second call.
d483 6
d490 2
a491 7
    if (libraryPathEncodingFixed == 0) {
	int platformId;
	platformId = TclWinGetPlatformId();
	TclWinSetInterfaces(platformId == VER_PLATFORM_WIN32_NT);
	
	wsprintfA(buf, "cp%d", GetACP());
	Tcl_SetSystemEncoding(NULL, buf);
d493 18
a510 19
	if (platformId != VER_PLATFORM_WIN32_NT) {
	    Tcl_Obj *pathPtr = TclGetLibraryPath();
	    if (pathPtr != NULL) {
		int i, objc;
		Tcl_Obj **objv;
		
		objc = 0;
		Tcl_ListObjGetElements(NULL, pathPtr, &objc, &objv);
		for (i = 0; i < objc; i++) {
		    int length;
		    char *string;
		    Tcl_DString ds;

		    string = Tcl_GetStringFromObj(objv[i], &length);
		    Tcl_ExternalToUtfDString(NULL, string, length, &ds);
		    Tcl_SetStringObj(objv[i], Tcl_DStringValue(&ds), 
			    Tcl_DStringLength(&ds));
		    Tcl_DStringFree(&ds);
		}
a512 5
	
	libraryPathEncodingFixed = 1;
    } else {
	wsprintfA(buf, "cp%d", GetACP());
	Tcl_SetSystemEncoding(NULL, buf);
d515 7
a521 9
    /* This is only ever called from the startup thread */
    if (binaryEncoding == NULL) {
	/*
	 * Keep this encoding preloaded.  The IO package uses it for
	 * gets on a binary channel.
	 */
	encoding = "iso8859-1";
	binaryEncoding = Tcl_GetEncoding(NULL, encoding);
    }
d537 2
a538 1
 *	Sets "tcl_platform", and "env(HOME)" Tcl variables.
d547 1
a547 1
    CONST char *ptr;
d561 6
d627 1
a627 1
	if (GetUserName(Tcl_DStringValue(&ds), (LPDWORD) &Tcl_DStringLength(&ds)) == 0) {
d694 1
a694 1
	length = (int) (p1 - envUpper);
d782 1
a782 1
    CONST char *fileName;
d789 1
a789 1
	CONST char *fullName;
d820 31
@


1.2
log
@touched all Tcl files to ease next import.
@
text
@@


1.2.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@a198 6
    /* Due to cygwin standard practice, the tcl binary will be
       installed in /bin rather than /usr/bin.  This means that, without
       this change, tcl will search in x:\share rather than x:\usr\share. */
#ifdef __CYGWIN__
    sprintf(installLib, "usr/share/tcl%s", TCL_VERSION);
#else
a199 1
#endif
@


1.2.16.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d14 1
d19 9
a54 15
#ifndef PROCESSOR_ARCHITECTURE_SHX  
#define PROCESSOR_ARCHITECTURE_SHX   4
#endif
#ifndef PROCESSOR_ARCHITECTURE_ARM
#define PROCESSOR_ARCHITECTURE_ARM   5
#endif
#ifndef PROCESSOR_ARCHITECTURE_IA64
#define PROCESSOR_ARCHITECTURE_IA64  6
#endif
#ifndef PROCESSOR_ARCHITECTURE_ALPHA64
#define PROCESSOR_ARCHITECTURE_ALPHA64 7
#endif
#ifndef PROCESSOR_ARCHITECTURE_MSIL
#define PROCESSOR_ARCHITECTURE_MSIL  8
#endif
d70 1
a70 1
#define NUMPROCESSORS 9
d72 1
a72 1
    "intel", "mips", "alpha", "ppc", "shx", "arm", "ia64", "alpha64", "msil"
d75 5
a79 4
/* Used to store the encoding used for binary files */
static Tcl_Encoding binaryEncoding = NULL;
/* Has the basic library path encoding issue been fixed */
static int libraryPathEncodingFixed = 0;
d91 1
d132 10
d182 1
a182 1
    CONST char *str;
d185 1
a185 1
    CONST char **pathv;
d187 1
a187 3
#ifdef __CYGWIN__
    char installLib2[LIBRARY_SIZE];
#endif
d198 1
a198 1
    /* REDHAT LOCAL */
d202 3
a204 2

    /* sprintf(installLib, "lib/tcl%s", TCL_VERSION); */
a205 2
#ifdef __CYGWIN__
    sprintf(installLib2, "usr/share/tcl%s", TCL_VERSION);
d207 3
a209 3
    /* END REDHAT LOCAL */

    sprintf(developLib, "../tcl%s/library", TCL_PATCH_LEVEL);
d245 1
a245 1
     *	  (e.g. /usr/local/bin/../lib/tcl8.4)
d247 1
a247 1
     * 	  (e.g. /usr/local/TclPro/solaris-sparc/bin/../../lib/tcl8.4)
d249 1
a249 1
     * 	  (e.g. /usr/src/tcl8.4.0/unix/../library)
d251 1
a251 1
     *	  (e.g. /usr/src/tcl8.4.0/unix/solaris-sparc/../../library)
d253 3
a255 3
     *	  (e.g. /usr/src/tcl8.4.0/unix/../../tcl8.4.0/library)
     *	<bindir>/../../../<developLib>
     *	   (e.g. /usr/src/tcl8.4.0/unix/solaris-sparc/../../../tcl8.4.0/library)
a257 5
    /*
     * The variable path holds an absolute path.  Take care not to
     * overwrite pathv[0] since that might produce a relative path.
     */

d260 1
a260 4


	if (pathc > 2) {
	    str = pathv[pathc - 2];
a262 1
	    pathv[pathc - 2] = str;
a265 11
	    /* REDHAT LOCAL */
#ifdef __CYGWIN__
	    pathv[pathc - 2] = installLib2;
	    path = Tcl_JoinPath(pathc - 1, pathv, &ds);
	    pathv[pathc - 2] = str;
	    objPtr = Tcl_NewStringObj(path, Tcl_DStringLength(&ds));
	    Tcl_ListObjAppendElement(NULL, pathPtr, objPtr);
	    Tcl_DStringFree(&ds);
#endif
	    /* END REDHAT LOCAL */

d267 1
a267 2
	if (pathc > 3) {
	    str = pathv[pathc - 3];
a269 1
	    pathv[pathc - 3] = str;
d274 1
a274 2
	if (pathc > 2) {
	    str = pathv[pathc - 2];
a276 1
	    pathv[pathc - 2] = str;
d281 1
a281 2
	if (pathc > 3) {
	    str = pathv[pathc - 3];
a283 1
	    pathv[pathc - 3] = str;
d288 1
a288 2
	if (pathc > 3) {
	    str = pathv[pathc - 3];
a290 1
	    pathv[pathc - 3] = str;
d295 1
a295 2
	if (pathc > 4) {
	    str = pathv[pathc - 4];
a297 1
	    pathv[pathc - 4] = str;
d336 1
d338 1
a338 1
    CONST char **pathv;
a364 1
	    CONST char *str;
d373 1
a373 1
	    pathv[pathc - 1] = (lib + 4);
d462 1
a462 1
    return (int) (dst - start);
d474 1
a474 4
 *	Called at process initialization time, and part way through
 *	startup, we verify that the initial encodings were correctly
 *	setup.  Depending on Tcl's environment, there may not have been
 *	enough information first time through (above).
d480 1
a480 3
 *	The Tcl library path is converted from native encoding to UTF-8,
 *	on the first call, and the encodings may be changed on first or
 *	second call.
d490 4
d495 4
a498 7
    if (libraryPathEncodingFixed == 0) {
	int platformId;
	platformId = TclWinGetPlatformId();
	TclWinSetInterfaces(platformId == VER_PLATFORM_WIN32_NT);
	
	wsprintfA(buf, "cp%d", GetACP());
	Tcl_SetSystemEncoding(NULL, buf);
d500 18
a517 19
	if (platformId != VER_PLATFORM_WIN32_NT) {
	    Tcl_Obj *pathPtr = TclGetLibraryPath();
	    if (pathPtr != NULL) {
		int i, objc;
		Tcl_Obj **objv;
		
		objc = 0;
		Tcl_ListObjGetElements(NULL, pathPtr, &objc, &objv);
		for (i = 0; i < objc; i++) {
		    int length;
		    char *string;
		    Tcl_DString ds;

		    string = Tcl_GetStringFromObj(objv[i], &length);
		    Tcl_ExternalToUtfDString(NULL, string, length, &ds);
		    Tcl_SetStringObj(objv[i], Tcl_DStringValue(&ds), 
			    Tcl_DStringLength(&ds));
		    Tcl_DStringFree(&ds);
		}
a519 5
	
	libraryPathEncodingFixed = 1;
    } else {
	wsprintfA(buf, "cp%d", GetACP());
	Tcl_SetSystemEncoding(NULL, buf);
d522 7
a528 9
    /* This is only ever called from the startup thread */
    if (binaryEncoding == NULL) {
	/*
	 * Keep this encoding preloaded.  The IO package uses it for
	 * gets on a binary channel.
	 */
	encoding = "iso8859-1";
	binaryEncoding = Tcl_GetEncoding(NULL, encoding);
    }
d544 2
a545 1
 *	Sets "tcl_platform", and "env(HOME)" Tcl variables.
d554 1
a554 1
    CONST char *ptr;
d568 6
d634 1
a634 1
	if (GetUserName(Tcl_DStringValue(&ds), (LPDWORD) &Tcl_DStringLength(&ds)) == 0) {
d701 1
a701 1
	length = (int) (p1 - envUpper);
d789 1
a789 1
    CONST char *fileName;
d796 1
a796 1
	CONST char *fullName;
d827 31
@


1.1
log
@Initial revision
@
text
@d6 3
a8 1
 * Copyright (c) 1994-1996 Sun Microsystems, Inc.
d10 1
a10 4
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tclWinInit.c,v 1.13 1999/08/06 00:50:59 dj Exp $
d13 1
a13 2
#include "tclInt.h"
#include "tclPort.h"
d76 8
a83 3
 * The Init script, tclPreInitScript variable, and the routine
 * TclSetPreInitScript (common to Windows and Unix platforms) are defined
 * in generic/tclInitScript.h
d88 5
d95 64
a158 1
 *----------------------------------------------------------------------
d160 3
a162 1
 * TclPlatformInit --
d164 1
a164 3
 *	Performs Windows-specific interpreter initialization related to the
 *	tcl_library variable.  Also sets up the HOME environment variable
 *	if it is not already set.
d170 1
a170 1
 *	Sets "tcl_library" and "env(HOME)" Tcl variables
d172 1
a172 1
 *----------------------------------------------------------------------
d176 3
a178 2
TclPlatformInit(interp)
    Tcl_Interp *interp;
d180 3
a182 2
    char *p;
    char buffer[13];
d184 6
a189 6
    OSVERSIONINFO osInfo;
    SYSTEM_INFO sysInfo;
    int isWin32s;		/* True if we are running under Win32s. */
    OemId *oemId;
    HKEY key;
    DWORD size, result, type;
d191 6
a196 1
    tclPlatform = TCL_PLATFORM_WINDOWS;
d198 5
a202 1
    Tcl_DStringInit(&ds);
d205 1
a205 1
     * Find out what kind of system we are running on.
d208 12
a219 2
    osInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFO);
    GetVersionEx(&osInfo);
d221 1
a221 1
    isWin32s = (osInfo.dwPlatformId == VER_PLATFORM_WIN32s);
d224 2
a225 1
     * Since Win32s doesn't support GetSystemInfo, we use a default value.
d228 179
a406 3
    oemId = (OemId *) &sysInfo;
    if (!isWin32s) {
	GetSystemInfo(&sysInfo);
d408 13
a420 1
	oemId->wProcessorArchitecture = PROCESSOR_ARCHITECTURE_INTEL;
d422 141
a563 3
    /* CYGNUS LOCAL: don't set tclDefaultLibrary from the registry; instead
       always compute it at runtime.  We do have to set it to
       something, though, so that initScript will work correctly.  */
d565 1
a565 4
    /* ditto, but this is a hack - dj */
    Tcl_SetVar(interp, "tcl_pkgPath", "", TCL_GLOBAL_ONLY);
    /* END CYGNUS LOCAL */
    
d576 1
a576 1
    sprintf(buffer, "%d.%d", osInfo.dwMajorVersion, osInfo.dwMinorVersion);
d593 1
a593 1
		TCL_GLOBAL_ONLY);
d601 6
a606 6
    p = Tcl_GetVar2(interp, "env", "HOME", TCL_GLOBAL_ONLY);
    if (p == NULL) {
	Tcl_DStringSetLength(&ds, 0);
	p = Tcl_GetVar2(interp, "env", "HOMEDRIVE", TCL_GLOBAL_ONLY);
	if (p != NULL) {
	    Tcl_DStringAppend(&ds, p, -1);
d608 3
a610 3
	p = Tcl_GetVar2(interp, "env", "HOMEPATH", TCL_GLOBAL_ONLY);
	if (p != NULL) {
	    Tcl_DStringAppend(&ds, p, -1);
d620 13
d639 1
a639 1
 * Tcl_Init --
d641 2
a642 3
 *	This procedure is typically invoked by Tcl_AppInit procedures
 *	to perform additional initialization for a Tcl interpreter,
 *	such as sourcing the "init.tcl" script.
d645 5
a649 2
 *	Returns a standard Tcl completion code and sets interp->result
 *	if there is an error.
d652 1
a652 1
 *	Depends on what's in the init.tcl script.
d658 7
a664 2
Tcl_Init(interp)
    Tcl_Interp *interp;		/* Interpreter to initialize. */
d666 44
a709 4
    if (tclPreInitScript != NULL) {
	if (Tcl_Eval(interp, tclPreInitScript) == TCL_ERROR) {
	    return (TCL_ERROR);
	};
d711 7
a717 1
    return(Tcl_Eval(interp, initScript));
d723 1
a723 1
 * TclWinGetPlatform --
d725 3
a727 2
 *	This is a kludge that allows the test library to get access
 *	the internal tclPlatform variable.
d730 2
a731 1
 *	Returns a pointer to the tclPlatform variable.
d734 1
a734 1
 *	None.
d739 3
a741 2
TclPlatformType *
TclWinGetPlatform()
d743 14
a756 1
    return &tclPlatform;
d811 2
a812 2
			Tcl_Write(errChannel, interp->result, -1);
			Tcl_Write(errChannel, "\n", 1);
d820 31
@


1.1.1.1
log
@import dejagnu-1999-11-08 snapshot
@
text
@@


1.1.1.2
log
@Tcl 8.3 upgrade
@
text
@d6 1
a6 3
 * Copyright (c) 1994-1997 Sun Microsystems, Inc.
 * Copyright (c) 1998-1999 by Scriptics Corporation.
 * All rights reserved.
d8 4
a11 1
 * RCS: @@(#) $Id: tclWinInit.c,v 1.6.8.4 2001/06/15 05:19:08 mdejong Exp $
d14 2
a15 1
#include "tclWinInt.h"
d78 3
a80 8
 * Thread id used for asynchronous notification from signal handlers.
 */

static DWORD mainThreadId;

/*
 * The Init script (common to Windows and Unix platforms) is
 * defined in tkInitScript.h
a84 5
static void		AppendEnvironment(Tcl_Obj *listPtr, CONST char *lib);
static void		AppendDllPath(Tcl_Obj *listPtr, HMODULE hModule,
			    CONST char *lib);
static void		AppendRegistry(Tcl_Obj *listPtr, CONST char *lib);
static int		ToUtf(CONST WCHAR *wSrc, char *dst);
d87 1
a87 3
 *---------------------------------------------------------------------------
 *
 * TclpInitPlatform --
d89 1
a89 2
 *	Initialize all the platform-dependant things like signals and
 *	floating-point error handling.
d91 3
a93 1
 *	Called at process initialization time.
d99 1
a99 1
 *	None.
d101 1
a101 1
 *---------------------------------------------------------------------------
d105 2
a106 1
TclpInitPlatform()
d108 10
a119 70
    /*
     * The following code stops Windows 3.X and Windows NT 3.51 from 
     * automatically putting up Sharing Violation dialogs, e.g, when 
     * someone tries to access a file that is locked or a drive with no 
     * disk in it.  Tcl already returns the appropriate error to the 
     * caller, and they can decide to put up their own dialog in response 
     * to that failure.  
     *
     * Under 95 and NT 4.0, this is a NOOP because the system doesn't 
     * automatically put up dialogs when the above operations fail.
     */

    SetErrorMode(SetErrorMode(0) | SEM_FAILCRITICALERRORS);

    /*
     * Save the id of the first thread to intialize the Tcl library.  This
     * thread will be used to handle notifications from async event
     * procedures.  This is not strictly correct.  A better solution involves
     * using a designated "main" notifier that is kept up to date as threads
     * come and go.
     */

    mainThreadId = GetCurrentThreadId();

#ifdef STATIC_BUILD
    /*
     * If we are in a statically linked executable, then we need to
     * explicitly initialize the Windows function tables here since
     * DllMain() will not be invoked.
     */

    TclWinInit(GetModuleHandle(NULL));
#endif
}

/*
 *---------------------------------------------------------------------------
 *
 * TclpInitLibraryPath --
 *
 *	Initialize the library path at startup.  
 *
 *	This call sets the library path to strings in UTF-8. Any 
 *	pre-existing library path information is assumed to have been 
 *	in the native multibyte encoding.
 *
 *	Called at process initialization time.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
 */

void
TclpInitLibraryPath(path)
    CONST char *path;		/* Potentially dirty UTF string that is */
				/* the path to the executable name.     */
{
#define LIBRARY_SIZE	    32
    Tcl_Obj *pathPtr, *objPtr;
    char *str;
    Tcl_DString ds;
    int pathc;
    char **pathv;
    char installLib[LIBRARY_SIZE], developLib[LIBRARY_SIZE];

a120 14
    pathPtr = Tcl_NewObj();

    /*
     * Initialize the substrings used when locating an executable.  The
     * installLib variable computes the path as though the executable
     * is installed.  The developLib computes the path as though the
     * executable is run from a develpment directory.
     */

    /* CYGNUS LOCAL */
    sprintf(installLib, "share/tcl%s", TCL_VERSION);
    /* END CYGNUS LOCAL */
    sprintf(developLib, "../tcl%s/library",
	    ((TCL_RELEASE_LEVEL < 2) ? TCL_PATCH_LEVEL : TCL_VERSION));
d123 1
a123 1
     * Look for the library relative to default encoding dir.
d126 2
a127 12
    str = Tcl_GetDefaultEncodingDir();
    if ((str != NULL) && (str[0] != '\0')) {
	objPtr = Tcl_NewStringObj(str, -1);
	Tcl_ListObjAppendElement(NULL, pathPtr, objPtr);
    }

    /*
     * Look for the library relative to the TCL_LIBRARY env variable.
     * If the last dirname in the TCL_LIBRARY path does not match the
     * last dirname in the installLib variable, use the last dir name
     * of installLib in addition to the orginal TCL_LIBRARY path.
     */
d129 1
a129 1
    AppendEnvironment(pathPtr, installLib);
d132 1
a132 2
     * Look for the library relative to the DLL.  Only use the installLib
     * because in practice, the DLL is always installed.
d135 3
a137 179
    AppendDllPath(pathPtr, TclWinGetTclInstance(), installLib);
    

    /*
     * Look for the library relative to the executable.  This algorithm
     * should be the same as the one in the tcl_findLibrary procedure.
     *
     * This code looks in the following directories:
     *
     *	<bindir>/../<installLib>
     *		(e.g. /usr/local/bin/../lib/tcl8.2)
     *	<bindir>/../../<installLib>
     *		(e.g. /usr/local/TclPro/solaris-sparc/bin/../../lib/tcl8.2)
     *	<bindir>/../library
     *		(e.g. /usr/src/tcl8.2/unix/../library)
     *	<bindir>/../../library
     *		(e.g. /usr/src/tcl8.2/unix/solaris-sparc/../../library)
     *	<bindir>/../../<developLib>
     *		(e.g. /usr/src/tcl8.2/unix/../../tcl8.2/library)
     *	<bindir>/../../../<devlopLib>
     *		(e.g. /usr/src/tcl8.2/unix/solaris-sparc/../../../tcl8.2/library)
     */
     
    if (path != NULL) {
	Tcl_SplitPath(path, &pathc, &pathv);
	if (pathc > 1) {
	    pathv[pathc - 2] = installLib;
	    path = Tcl_JoinPath(pathc - 1, pathv, &ds);
	    objPtr = Tcl_NewStringObj(path, Tcl_DStringLength(&ds));
	    Tcl_ListObjAppendElement(NULL, pathPtr, objPtr);
	    Tcl_DStringFree(&ds);
	}
	if (pathc > 2) {
	    pathv[pathc - 3] = installLib;
	    path = Tcl_JoinPath(pathc - 2, pathv, &ds);
	    objPtr = Tcl_NewStringObj(path, Tcl_DStringLength(&ds));
	    Tcl_ListObjAppendElement(NULL, pathPtr, objPtr);
	    Tcl_DStringFree(&ds);
	}
	if (pathc > 1) {
	    pathv[pathc - 2] = "library";
	    path = Tcl_JoinPath(pathc - 1, pathv, &ds);
	    objPtr = Tcl_NewStringObj(path, Tcl_DStringLength(&ds));
	    Tcl_ListObjAppendElement(NULL, pathPtr, objPtr);
	    Tcl_DStringFree(&ds);
	}
	if (pathc > 2) {
	    pathv[pathc - 3] = "library";
	    path = Tcl_JoinPath(pathc - 2, pathv, &ds);
	    objPtr = Tcl_NewStringObj(path, Tcl_DStringLength(&ds));
	    Tcl_ListObjAppendElement(NULL, pathPtr, objPtr);
	    Tcl_DStringFree(&ds);
	}
	if (pathc > 1) {
	    pathv[pathc - 3] = developLib;
	    path = Tcl_JoinPath(pathc - 2, pathv, &ds);
	    objPtr = Tcl_NewStringObj(path, Tcl_DStringLength(&ds));
	    Tcl_ListObjAppendElement(NULL, pathPtr, objPtr);
	    Tcl_DStringFree(&ds);
	}
	if (pathc > 3) {
	    pathv[pathc - 4] = developLib;
	    path = Tcl_JoinPath(pathc - 3, pathv, &ds);
	    objPtr = Tcl_NewStringObj(path, Tcl_DStringLength(&ds));
	    Tcl_ListObjAppendElement(NULL, pathPtr, objPtr);
	    Tcl_DStringFree(&ds);
	}
	ckfree((char *) pathv);
    }

    TclSetLibraryPath(pathPtr);
}

/*
 *---------------------------------------------------------------------------
 *
 * AppendEnvironment --
 *
 *	Append the value of the TCL_LIBRARY environment variable onto the
 *	path pointer.  If the env variable points to another version of
 *	tcl (e.g. "tcl7.6") also append the path to this version (e.g.,
 *	"tcl7.6/../tcl8.2")
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
 */

static void
AppendEnvironment(
    Tcl_Obj *pathPtr,
    CONST char *lib)
{
    int pathc;
    WCHAR wBuf[MAX_PATH];
    char buf[MAX_PATH * TCL_UTF_MAX];
    Tcl_Obj *objPtr;
    char *str;
    Tcl_DString ds;
    char **pathv;

    /*
     * The "L" preceeding the TCL_LIBRARY string is used to tell VC++
     * that this is a unicode string.
     */
    
    if (GetEnvironmentVariableW(L"TCL_LIBRARY", wBuf, MAX_PATH) == 0) {
        buf[0] = '\0';
	GetEnvironmentVariableA("TCL_LIBRARY", buf, MAX_PATH);
    } else {
	ToUtf(wBuf, buf);
    }

    if (buf[0] != '\0') {
	objPtr = Tcl_NewStringObj(buf, -1);
	Tcl_ListObjAppendElement(NULL, pathPtr, objPtr);

	TclWinNoBackslash(buf);
	Tcl_SplitPath(buf, &pathc, &pathv);

	/* 
	 * The lstrcmpi() will work even if pathv[pathc - 1] is random
	 * UTF-8 chars because I know lib is ascii.
	 */

	if ((pathc > 0) && (lstrcmpiA(lib + 4, pathv[pathc - 1]) != 0)) {
	    /*
	     * TCL_LIBRARY is set but refers to a different tcl
	     * installation than the current version.  Try fiddling with the
	     * specified directory to make it refer to this installation by
	     * removing the old "tclX.Y" and substituting the current
	     * version string.
	     */
	    
	    pathv[pathc - 1] = (char *) (lib + 4);
	    Tcl_DStringInit(&ds);
	    str = Tcl_JoinPath(pathc, pathv, &ds);
	    objPtr = Tcl_NewStringObj(str, Tcl_DStringLength(&ds));
	    Tcl_DStringFree(&ds);
	} else {
	    objPtr = Tcl_NewStringObj(buf, -1);
	}
	Tcl_ListObjAppendElement(NULL, pathPtr, objPtr);
	ckfree((char *) pathv);
    }
}

/*
 *---------------------------------------------------------------------------
 *
 * AppendDllPath --
 *
 *	Append a path onto the path pointer that tries to locate the Tcl
 *	library relative to the location of the Tcl DLL.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
 */

static void 
AppendDllPath(
    Tcl_Obj *pathPtr, 
    HMODULE hModule,
    CONST char *lib)
{
    WCHAR wName[MAX_PATH + LIBRARY_SIZE];
    char name[(MAX_PATH + LIBRARY_SIZE) * TCL_UTF_MAX];

    if (GetModuleFileNameW(hModule, wName, MAX_PATH) == 0) {
	GetModuleFileNameA(hModule, name, MAX_PATH);
d139 1
a139 13
	ToUtf(wName, name);
    }
    if (lib != NULL) {
	char *end, *p;

	end = strrchr(name, '\\');
	*end = '\0';
	p = strrchr(name, '\\');
	if (p != NULL) {
	    end = p;
	}
	*end = '\\';
	strcpy(end + 1, lib);
a140 141
    TclWinNoBackslash(name);
    Tcl_ListObjAppendElement(NULL, pathPtr, Tcl_NewStringObj(name, -1));
}

/*
 *---------------------------------------------------------------------------
 *
 * ToUtf --
 *
 *	Convert a char string to a UTF string.  
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
 */

static int
ToUtf(
    CONST WCHAR *wSrc,
    char *dst)
{
    char *start;

    start = dst;
    while (*wSrc != '\0') {
	dst += Tcl_UniCharToUtf(*wSrc, dst);
	wSrc++;
    }
    *dst = '\0';
    return dst - start;
}


/*
 *---------------------------------------------------------------------------
 *
 * TclpSetInitialEncodings --
 *
 *	Based on the locale, determine the encoding of the operating
 *	system and the default encoding for newly opened files.
 *
 *	Called at process initialization time.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The Tcl library path is converted from native encoding to UTF-8.
 *
 *---------------------------------------------------------------------------
 */

void
TclpSetInitialEncodings()
{
    CONST char *encoding;
    char buf[4 + TCL_INTEGER_SPACE];
    int platformId;
    Tcl_Obj *pathPtr;

    platformId = TclWinGetPlatformId();

    TclWinSetInterfaces(platformId == VER_PLATFORM_WIN32_NT);

    wsprintfA(buf, "cp%d", GetACP());
    Tcl_SetSystemEncoding(NULL, buf);

    if (platformId != VER_PLATFORM_WIN32_NT) {
	pathPtr = TclGetLibraryPath();
	if (pathPtr != NULL) {
	    int i, objc;
	    Tcl_Obj **objv;
	    
	    objc = 0;
	    Tcl_ListObjGetElements(NULL, pathPtr, &objc, &objv);
	    for (i = 0; i < objc; i++) {
		int length;
		char *string;
		Tcl_DString ds;

		string = Tcl_GetStringFromObj(objv[i], &length);
		Tcl_ExternalToUtfDString(NULL, string, length, &ds);
		Tcl_SetStringObj(objv[i], Tcl_DStringValue(&ds), 
			Tcl_DStringLength(&ds));
		Tcl_DStringFree(&ds);
	    }
	}
    }

    /*
     * Keep this encoding preloaded.  The IO package uses it for gets on a
     * binary channel.  
     */

    encoding = "iso8859-1";
    Tcl_GetEncoding(NULL, encoding);
}

/*
 *---------------------------------------------------------------------------
 *
 * TclpSetVariables --
 *
 *	Performs platform-specific interpreter initialization related to
 *	the tcl_platform and env variables, and other platform-specific
 *	things.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Sets "tclDefaultLibrary", "tcl_platform", and "env(HOME)" Tcl
 *	variables.
 *
 *----------------------------------------------------------------------
 */

void
TclpSetVariables(interp)
    Tcl_Interp *interp;		/* Interp to initialize. */	
{	    
    char *ptr;
    char buffer[TCL_INTEGER_SPACE * 2];
    SYSTEM_INFO sysInfo;
    OemId *oemId;
    OSVERSIONINFOA osInfo;
    Tcl_DString ds;

    osInfo.dwOSVersionInfoSize = sizeof(OSVERSIONINFOA);
    GetVersionExA(&osInfo);

    oemId = (OemId *) &sysInfo;
    GetSystemInfo(&sysInfo);

    /*
     * Initialize the tclDefaultLibrary variable from the registry.
     */
d142 3
d146 4
a149 1

d160 1
a160 1
    wsprintfA(buffer, "%d.%d", osInfo.dwMajorVersion, osInfo.dwMinorVersion);
d177 1
a177 1
	    TCL_GLOBAL_ONLY);
d185 6
a190 6
    Tcl_DStringInit(&ds);
    ptr = Tcl_GetVar2(interp, "env", "HOME", TCL_GLOBAL_ONLY);
    if (ptr == NULL) {
	ptr = Tcl_GetVar2(interp, "env", "HOMEDRIVE", TCL_GLOBAL_ONLY);
	if (ptr != NULL) {
	    Tcl_DStringAppend(&ds, ptr, -1);
d192 3
a194 3
	ptr = Tcl_GetVar2(interp, "env", "HOMEPATH", TCL_GLOBAL_ONLY);
	if (ptr != NULL) {
	    Tcl_DStringAppend(&ds, ptr, -1);
a203 13
    /*
     * Initialize the user name from the environment first, since this is much
     * faster than asking the system.
     */

    Tcl_DStringSetLength(&ds, 100);
    if (TclGetEnv("USERNAME", &ds) == NULL) {
	if (GetUserName(Tcl_DStringValue(&ds), &Tcl_DStringLength(&ds)) == 0) {
	    Tcl_DStringSetLength(&ds, 0);
	}
    }
    Tcl_SetVar2(interp, "tcl_platform", "user", Tcl_DStringValue(&ds),
	    TCL_GLOBAL_ONLY);
d210 1
a210 1
 * TclpFindVariable --
d212 3
a214 2
 *	Locate the entry in environ for a given name.  On Unix this 
 *	routine is case sensetive, on Windows this matches mioxed case.
d217 2
a218 5
 *	The return value is the index in environ of an entry with the
 *	name "name", or -1 if there is no such entry.   The integer at
 *	*lengthPtr is filled in with the length of name (if a matching
 *	entry is found) or the length of the environ array (if no matching
 *	entry is found).
d221 1
a221 1
 *	None.
d227 2
a228 7
TclpFindVariable(name, lengthPtr)
    CONST char *name;		/* Name of desired environment variable
				 * (UTF-8). */
    int *lengthPtr;		/* Used to return length of name (for
				 * successful searches) or number of non-NULL
				 * entries in environ (for unsuccessful
				 * searches). */
d230 4
a233 44
    int i, length, result = -1;
    register CONST char *env, *p1, *p2;
    char *envUpper, *nameUpper;
    Tcl_DString envString;

    /*
     * Convert the name to all upper case for the case insensitive
     * comparison.
     */

    length = strlen(name);
    nameUpper = (char *) ckalloc((unsigned) length+1);
    memcpy((VOID *) nameUpper, (VOID *) name, (size_t) length+1);
    Tcl_UtfToUpper(nameUpper);
    
    Tcl_DStringInit(&envString);
    for (i = 0, env = environ[i]; env != NULL; i++, env = environ[i]) {
	/*
	 * Chop the env string off after the equal sign, then Convert
	 * the name to all upper case, so we do not have to convert
	 * all the characters after the equal sign.
	 */
	
	envUpper = Tcl_ExternalToUtfDString(NULL, env, -1, &envString);
	p1 = strchr(envUpper, '=');
	if (p1 == NULL) {
	    continue;
	}
	length = p1 - envUpper;
	Tcl_DStringSetLength(&envString, length+1);
	Tcl_UtfToUpper(envUpper);

	p1 = envUpper;
	p2 = nameUpper;
	for (; *p2 == *p1; p1++, p2++) {
	    /* NULL loop body. */
	}
	if ((*p1 == '=') && (*p2 == '\0')) {
	    *lengthPtr = length;
	    result = i;
	    goto done;
	}
	
	Tcl_DStringFree(&envString);
d235 1
a235 7
    
    *lengthPtr = i;

    done:
    Tcl_DStringFree(&envString);
    ckfree(nameUpper);
    return result;
d241 1
a241 1
 * Tcl_Init --
d243 2
a244 3
 *	This procedure is typically invoked by Tcl_AppInit procedures
 *	to perform additional initialization for a Tcl interpreter,
 *	such as sourcing the "init.tcl" script.
d247 1
a247 2
 *	Returns a standard Tcl completion code and sets the interp's
 *	result if there is an error.
d250 1
a250 1
 *	Depends on what's in the init.tcl script.
d255 2
a256 3
int
Tcl_Init(interp)
    Tcl_Interp *interp;		/* Interpreter to initialize. */
d258 1
a258 14
    Tcl_Obj *pathPtr;

    if (tclPreInitScript != NULL) {
	if (Tcl_Eval(interp, tclPreInitScript) == TCL_ERROR) {
	    return (TCL_ERROR);
	};
    }

    pathPtr = TclGetLibraryPath();
    if (pathPtr == NULL) {
	pathPtr = Tcl_NewObj();
    }
    Tcl_SetVar2Ex(interp, "tcl_libPath", NULL, pathPtr, TCL_GLOBAL_ONLY);
    return Tcl_Eval(interp, initScript);
d313 2
a314 2
			Tcl_WriteObj(errChannel, Tcl_GetObjResult(interp));
			Tcl_WriteChars(errChannel, "\n", 1);
a321 31

/*
 *----------------------------------------------------------------------
 *
 * TclpAsyncMark --
 *
 *	Wake up the main thread from a signal handler.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Sends a message to the main thread.
 *
 *----------------------------------------------------------------------
 */

void
TclpAsyncMark(async)
    Tcl_AsyncHandler async;		/* Token for handler. */
{
    /*
     * Need a way to kick the Windows event loop and tell it to go look at
     * asynchronous events.
     */

    PostThreadMessage(mainThreadId, WM_USER, 0, 0);
}



@


1.1.1.3
log
@import tcl 8.4.0
@
text
@d10 1
a10 1
 * RCS: @@(#) $Id: tclWinInit.c,v 1.35 2002/02/08 02:52:55 dgp Exp $
d14 1
d19 9
a54 15
#ifndef PROCESSOR_ARCHITECTURE_SHX  
#define PROCESSOR_ARCHITECTURE_SHX   4
#endif
#ifndef PROCESSOR_ARCHITECTURE_ARM
#define PROCESSOR_ARCHITECTURE_ARM   5
#endif
#ifndef PROCESSOR_ARCHITECTURE_IA64
#define PROCESSOR_ARCHITECTURE_IA64  6
#endif
#ifndef PROCESSOR_ARCHITECTURE_ALPHA64
#define PROCESSOR_ARCHITECTURE_ALPHA64 7
#endif
#ifndef PROCESSOR_ARCHITECTURE_MSIL
#define PROCESSOR_ARCHITECTURE_MSIL  8
#endif
d70 1
a70 1
#define NUMPROCESSORS 9
d72 1
a72 1
    "intel", "mips", "alpha", "ppc", "shx", "arm", "ia64", "alpha64", "msil"
d75 5
a79 4
/* Used to store the encoding used for binary files */
static Tcl_Encoding binaryEncoding = NULL;
/* Has the basic library path encoding issue been fixed */
static int libraryPathEncodingFixed = 0;
d91 1
d132 10
d182 1
a182 1
    CONST char *str;
d185 1
a185 1
    CONST char **pathv;
d198 5
a202 2
    sprintf(installLib, "lib/tcl%s", TCL_VERSION);
    sprintf(developLib, "../tcl%s/library", TCL_PATCH_LEVEL);
d238 1
a238 1
     *	  (e.g. /usr/local/bin/../lib/tcl8.4)
d240 1
a240 1
     * 	  (e.g. /usr/local/TclPro/solaris-sparc/bin/../../lib/tcl8.4)
d242 1
a242 1
     * 	  (e.g. /usr/src/tcl8.4.0/unix/../library)
d244 1
a244 1
     *	  (e.g. /usr/src/tcl8.4.0/unix/solaris-sparc/../../library)
d246 3
a248 3
     *	  (e.g. /usr/src/tcl8.4.0/unix/../../tcl8.4.0/library)
     *	<bindir>/../../../<developLib>
     *	   (e.g. /usr/src/tcl8.4.0/unix/solaris-sparc/../../../tcl8.4.0/library)
a250 5
    /*
     * The variable path holds an absolute path.  Take care not to
     * overwrite pathv[0] since that might produce a relative path.
     */

d253 1
a253 2
	if (pathc > 2) {
	    str = pathv[pathc - 2];
a255 1
	    pathv[pathc - 2] = str;
d260 1
a260 2
	if (pathc > 3) {
	    str = pathv[pathc - 3];
a262 1
	    pathv[pathc - 3] = str;
d267 1
a267 2
	if (pathc > 2) {
	    str = pathv[pathc - 2];
a269 1
	    pathv[pathc - 2] = str;
d274 1
a274 2
	if (pathc > 3) {
	    str = pathv[pathc - 3];
a276 1
	    pathv[pathc - 3] = str;
d281 1
a281 2
	if (pathc > 3) {
	    str = pathv[pathc - 3];
a283 1
	    pathv[pathc - 3] = str;
d288 1
a288 2
	if (pathc > 4) {
	    str = pathv[pathc - 4];
a290 1
	    pathv[pathc - 4] = str;
d329 1
d331 1
a331 1
    CONST char **pathv;
a357 1
	    CONST char *str;
d366 1
a366 1
	    pathv[pathc - 1] = (lib + 4);
d455 1
a455 1
    return (int) (dst - start);
d467 1
a467 4
 *	Called at process initialization time, and part way through
 *	startup, we verify that the initial encodings were correctly
 *	setup.  Depending on Tcl's environment, there may not have been
 *	enough information first time through (above).
d473 1
a473 3
 *	The Tcl library path is converted from native encoding to UTF-8,
 *	on the first call, and the encodings may be changed on first or
 *	second call.
d483 6
d490 2
a491 7
    if (libraryPathEncodingFixed == 0) {
	int platformId;
	platformId = TclWinGetPlatformId();
	TclWinSetInterfaces(platformId == VER_PLATFORM_WIN32_NT);
	
	wsprintfA(buf, "cp%d", GetACP());
	Tcl_SetSystemEncoding(NULL, buf);
d493 18
a510 19
	if (platformId != VER_PLATFORM_WIN32_NT) {
	    Tcl_Obj *pathPtr = TclGetLibraryPath();
	    if (pathPtr != NULL) {
		int i, objc;
		Tcl_Obj **objv;
		
		objc = 0;
		Tcl_ListObjGetElements(NULL, pathPtr, &objc, &objv);
		for (i = 0; i < objc; i++) {
		    int length;
		    char *string;
		    Tcl_DString ds;

		    string = Tcl_GetStringFromObj(objv[i], &length);
		    Tcl_ExternalToUtfDString(NULL, string, length, &ds);
		    Tcl_SetStringObj(objv[i], Tcl_DStringValue(&ds), 
			    Tcl_DStringLength(&ds));
		    Tcl_DStringFree(&ds);
		}
a512 5
	
	libraryPathEncodingFixed = 1;
    } else {
	wsprintfA(buf, "cp%d", GetACP());
	Tcl_SetSystemEncoding(NULL, buf);
d515 7
a521 9
    /* This is only ever called from the startup thread */
    if (binaryEncoding == NULL) {
	/*
	 * Keep this encoding preloaded.  The IO package uses it for
	 * gets on a binary channel.
	 */
	encoding = "iso8859-1";
	binaryEncoding = Tcl_GetEncoding(NULL, encoding);
    }
d537 2
a538 1
 *	Sets "tcl_platform", and "env(HOME)" Tcl variables.
d547 1
a547 1
    CONST char *ptr;
d561 6
d627 1
a627 1
	if (GetUserName(Tcl_DStringValue(&ds), (LPDWORD) &Tcl_DStringLength(&ds)) == 0) {
d694 1
a694 1
	length = (int) (p1 - envUpper);
d782 1
a782 1
    CONST char *fileName;
d789 1
a789 1
	CONST char *fullName;
d820 31
@


