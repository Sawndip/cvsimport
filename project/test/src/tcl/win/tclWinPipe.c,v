head	1.9;
access;
symbols
	sid-snapshot-20180601:1.9
	sid-snapshot-20180501:1.9
	sid-snapshot-20180401:1.9
	sid-snapshot-20180301:1.9
	sid-snapshot-20180201:1.9
	sid-snapshot-20180101:1.9
	sid-snapshot-20171201:1.9
	sid-snapshot-20171101:1.9
	sid-snapshot-20171001:1.9
	sid-snapshot-20170901:1.9
	sid-snapshot-20170801:1.9
	sid-snapshot-20170701:1.9
	sid-snapshot-20170601:1.9
	sid-snapshot-20170501:1.9
	sid-snapshot-20170401:1.9
	sid-snapshot-20170301:1.9
	sid-snapshot-20170201:1.9
	sid-snapshot-20170101:1.9
	sid-snapshot-20161201:1.9
	sid-snapshot-20161101:1.9
	sid-snapshot-20160901:1.9
	sid-snapshot-20160801:1.9
	sid-snapshot-20160701:1.9
	sid-snapshot-20160601:1.9
	sid-snapshot-20160501:1.9
	sid-snapshot-20160401:1.9
	sid-snapshot-20160301:1.9
	sid-snapshot-20160201:1.9
	sid-snapshot-20160101:1.9
	sid-snapshot-20151201:1.9
	sid-snapshot-20151101:1.9
	sid-snapshot-20151001:1.9
	sid-snapshot-20150901:1.9
	sid-snapshot-20150801:1.9
	sid-snapshot-20150701:1.9
	sid-snapshot-20150601:1.9
	sid-snapshot-20150501:1.9
	sid-snapshot-20150401:1.9
	sid-snapshot-20150301:1.9
	sid-snapshot-20150201:1.9
	sid-snapshot-20150101:1.9
	sid-snapshot-20141201:1.9
	sid-snapshot-20141101:1.9
	sid-snapshot-20141001:1.9
	sid-snapshot-20140901:1.9
	sid-snapshot-20140801:1.9
	sid-snapshot-20140701:1.9
	sid-snapshot-20140601:1.9
	sid-snapshot-20140501:1.9
	sid-snapshot-20140401:1.9
	sid-snapshot-20140301:1.9
	sid-snapshot-20140201:1.9
	sid-snapshot-20140101:1.9
	sid-snapshot-20131201:1.9
	sid-snapshot-20131101:1.9
	sid-snapshot-20131001:1.9
	sid-snapshot-20130901:1.9
	sid-snapshot-20130801:1.9
	sid-snapshot-20130701:1.9
	sid-snapshot-20130601:1.9
	insight_7_6-2013-04-10-branchpoint:1.9
	gdb_7_6-branch:1.9.0.18
	sid-snapshot-20130501:1.9
	sid-snapshot-20130401:1.9
	sid-snapshot-20130301:1.9
	sid-snapshot-20130201:1.9
	sid-snapshot-20130101:1.9
	sid-snapshot-20121201:1.9
	sid-snapshot-20121101:1.9
	sid-snapshot-20121001:1.9
	sid-snapshot-20120901:1.9
	gdb_7_5-branch:1.9.0.16
	sid-snapshot-20120801:1.9
	sid-snapshot-20120701:1.9
	sid-snapshot-20120601:1.9
	sid-snapshot-20120501:1.9
	sid-snapshot-20120401:1.9
	gdb_7_4-branch:1.9.0.14
	sid-snapshot-20120301:1.9
	sid-snapshot-20120201:1.9
	sid-snapshot-20120101:1.9
	sid-snapshot-20111201:1.9
	sid-snapshot-20111101:1.9
	sid-snapshot-20111001:1.9
	sid-snapshot-20110901:1.9
	gdb_7_3-branch:1.9.0.12
	sid-snapshot-20110801:1.9
	sid-snapshot-20110701:1.9
	sid-snapshot-20110601:1.9
	sid-snapshot-20110501:1.9
	sid-snapshot-20110401:1.9
	sid-snapshot-20110301:1.9
	sid-snapshot-20110201:1.9
	sid-snapshot-20110101:1.9
	sid-snapshot-20101201:1.9
	sid-snapshot-20101101:1.9
	sid-snapshot-20101001:1.9
	sid-snapshot-20100901:1.9
	sid-snapshot-20100801:1.9
	sid-snapshot-20100701:1.9
	sid-snapshot-20100601:1.9
	sid-snapshot-20100501:1.9
	sid-snapshot-20100401:1.9
	sid-snapshot-20100301:1.9
	gdb_7_1-branch:1.9.0.10
	gdb_7_0-branch:1.9.0.8
	sid-snapshot-20100201:1.9
	sid-snapshot-20100101:1.9
	sid-snapshot-20091201:1.9
	sid-snapshot-20091101:1.9
	sid-snapshot-20091001:1.9
	arc-sim-20090309:1.9
	sid-snapshot-20090901:1.9
	sid-snapshot-20090801:1.9
	sid-snapshot-20090701:1.9
	sid-snapshot-20090601:1.9
	sid-snapshot-20090501:1.9
	kevinb-pre-tcl8_5_7_merge:1.9
	sid-snapshot-20090401:1.9
	arc-insight_6_8-branch:1.9.0.6
	arc-insight_6_8-branchpoint:1.9
	insight_6_8-branch:1.9.0.4
	insight_6_8-branchpoint:1.9
	sid-snapshot-20090301:1.9
	sid-snapshot-20090201:1.9
	sid-snapshot-20090101:1.9
	sid-snapshot-20081201:1.9
	sid-snapshot-20081101:1.9
	sid-snapshot-20081001:1.9
	sid-snapshot-20080901:1.9
	sid-snapshot-20080801:1.9
	sid-snapshot-20080701:1.9
	sid-snapshot-20080601:1.9
	sid-snapshot-20080501:1.9
	sid-snapshot-20080403:1.9
	sid-snapshot-20080401:1.9
	gdb_6_8-branch:1.9.0.2
	sid-snapshot-20080301:1.9
	sid-snapshot-20080201:1.9
	sid-snapshot-20080101:1.9
	sid-snapshot-20071201:1.9
	sid-snapshot-20071101:1.9
	sid-snapshot-20071001:1.9
	insight_6_6-20070208-release:1.7.40.1
	gdb_6_6-branch:1.7.0.40
	gdb_6_6-2006-11-15-branchpoint:1.7
	insight_6_5-20061003-release:1.7
	gdb_6_5-branch:1.7.0.38
	gdb_6_5-2006-05-14-branchpoint:1.7
	readline_5_1-import-branch:1.7.0.36
	readline_5_1-import-branchpoint:1.7
	gdb_6_4-branch:1.7.0.34
	gdb_6_4-2005-11-01-branchpoint:1.7
	msnyder-tracepoint-checkpoint-branch:1.7.0.32
	msnyder-tracepoint-checkpoint-branchpoint:1.7
	gdb_6_1-2004-04-05-release:1.7
	ezannoni_pie-20040323-branch:1.7.0.30
	ezannoni_pie-20040323-branchpoint:1.7
	cagney_tramp-20040321-mergepoint:1.7
	cagney_tramp-20040309-branch:1.7.0.28
	cagney_tramp-20040309-branchpoint:1.7
	gdb_6_1-branch:1.7.0.26
	gdb_6_1-2004-03-01-gmt-branchpoint:1.7
	drow-cplus-merge-20040208:1.7
	carlton_dictionary-20040126-merge:1.7
	drow-cplus-merge-20040113:1.7
	drow-cplus-merge-20031224:1.7
	drow-cplus-merge-20031220:1.7
	carlton_dictionary-20031215-merge:1.7
	drow-cplus-merge-20031214:1.7
	carlton-dictionary-20031111-merge:1.7
	gdb_6_0-2003-10-04-release:1.7
	carlton_dictionary-20030917-merge:1.7
	ezannoni_pie-20030916-branchpoint:1.7
	ezannoni_pie-20030916-branch:1.7.0.24
	cagney_x86i386-20030821-branch:1.7.0.22
	cagney_x86i386-20030821-branchpoint:1.7
	carlton_dictionary-20030805-merge:1.7
	carlton_dictionary-20030627-merge:1.7
	gdb_6_0-branch:1.7.0.20
	gdb_6_0-2003-06-23-branchpoint:1.7
	cagney_convert-20030606-branch:1.7.0.18
	cagney_convert-20030606-branchpoint:1.7
	cagney_writestrings-20030508-branch:1.7.0.16
	cagney_writestrings-20030508-branchpoint:1.7
	carlton_dictionary-20030523-merge:1.7
	cagney_fileio-20030521-branch:1.7.0.14
	cagney_fileio-20030521-branchpoint:1.7
	carlton_dictionary-20030430-merge:1.7
	carlton_dictionary-20030416-merge:1.7
	cagney_frameaddr-20030409-mergepoint:1.7
	cagney_frameaddr-20030403-branchpoint:1.7
	cagney_frameaddr-20030403-branch:1.7.0.12
	cagney_framebase-20030330-mergepoint:1.7
	cagney_framebase-20030326-branch:1.7.0.10
	cagney_framebase-20030326-branchpoint:1.7
	cagney_lazyid-20030317-branch:1.7.0.8
	cagney_lazyid-20030317-branchpoint:1.7
	offbyone-20030313-branch:1.7.0.6
	offbyone-20030313-branchpoint:1.7
	carlton_dictionary-20030305-merge:1.7
	cagney_offbyone-20030303-branch:1.7.0.4
	cagney_offbyone-20030303-branchpoint:1.7
	carlton_dictionary-20030207-merge:1.7
	interps-20030202-branch:1.7.0.2
	interps-20030202-branchpoint:1.7
	TCL8_4_1:1.1.1.3
	cagney-unwind-20030108-branch:1.6.0.2
	cagney-unwind-20030108-branchpoint:1.6
	carlton_dictionary-20021223-merge:1.6
	gdb_5_3-2002-12-12-release:1.4
	TCL_8_4_1:1.1.1.3
	carlton_dictionary-20021115-merge:1.5
	kseitz_interps-20021105-merge:1.5
	kseitz_interps-20021103-merge:1.5
	drow-cplus-merge-20021020:1.5
	drow-cplus-merge-20021025:1.5
	carlton_dictionary-20021025-merge:1.5
	carlton_dictionary-20021011-merge:1.5
	drow-cplus-branch:1.5.0.4
	drow-cplus-branchpoint:1.5
	kseitz_interps-20020930-merge:1.5
	carlton_dictionary-20020927-merge:1.5
	tcltk840-20020924-branch:1.5.0.2
	tcltk840-20020924-branchpoint:1.5
	TCL_8_4_0:1.1.1.3
	carlton_dictionary-branch:1.4.0.16
	carlton_dictionary-20020920-branchpoint:1.4
	sid-20020905-branchpoint:1.4
	sid-20020905-branch:1.4.0.14
	gdb_5_3-branch:1.4.0.12
	gdb_5_3-2002-09-04-branchpoint:1.4
	kseitz_interps-20020829-merge:1.4
	cagney_sysregs-20020825-branch:1.4.0.10
	cagney_sysregs-20020825-branchpoint:1.4
	readline_4_3-import-branch:1.4.0.8
	readline_4_3-import-branchpoint:1.4
	gdb_5_2_1-2002-07-23-release:1.4
	kseitz_interps-20020528-branch:1.4.0.6
	kseitz_interps-20020528-branchpoint:1.4
	cagney_regbuf-20020515-branch:1.4.0.4
	cagney_regbuf-20020515-branchpoint:1.4
	gdb_5_2-2002-04-29-release:1.4
	gdb_5_2-branch:1.4.0.2
	gdb_5_2-2002-03-03-branchpoint:1.4
	gdb_5_1_1-2002-01-24-release:1.2
	cygnus_cvs_20020108_pre:1.4
	gdb_5_1_0_1-2002-01-03-branch:1.2.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.2
	gdb_5_1-2001-11-21-release:1.2
	gdb_s390-2001-09-26-branch:1.2.0.4
	gdb_s390-2001-09-26-branchpoint:1.2
	TCL_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.2.0.2
	gdb_5_1-2001-07-29-branchpoint:1.2
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	dejagnu-2000-02-04:1.1.1.1
	dejagnu-2000-01-31:1.1.1.1
	dejagnu-2000-01-24:1.1.1.1
	dejagnu-2000-01-17:1.1.1.1
	dejagnu-2000-01-10:1.1.1.1
	dejagnu-2000-01-04:1.1.1.1
	dejagnu-1999-12-21:1.1.1.1
	dejagnu-1999-12-13:1.1.1.1
	dejagnu-1999-12-07:1.1.1.1
	dejagnu-1999-12-06:1.1.1.1
	dejagnu-1999-11-15:1.1.1.1
	dejagnu-1999-11-08:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.9
date	2007.05.14.17.11.42;	author cgf;	state Exp;
branches;
next	1.8;

1.8
date	2006.11.30.17.08.31;	author cgf;	state Exp;
branches;
next	1.7;

1.7
date	2003.01.21.19.40.23;	author hunt;	state Exp;
branches
	1.7.40.1;
next	1.6;

1.6
date	2002.11.26.19.48.07;	author hunt;	state Exp;
branches;
next	1.5;

1.5
date	2002.09.24.18.37.11;	author kseitz;	state Exp;
branches
	1.5.2.1
	1.5.4.1;
next	1.4;

1.4
date	2001.09.09.23.56.10;	author irox;	state Exp;
branches
	1.4.16.1;
next	1.3;

1.3
date	2001.09.09.23.26.07;	author irox;	state Exp;
branches;
next	1.2;

1.2
date	2001.04.10.20.08.27;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.7.40.1
date	2007.02.09.03.55.41;	author kseitz;	state Exp;
branches;
next	;

1.5.2.1
date	2002.09.27.21.49.15;	author kseitz;	state Exp;
branches;
next	;

1.5.4.1
date	2003.12.14.20.28.56;	author drow;	state Exp;
branches;
next	;

1.4.16.1
date	2002.12.23.19.40.57;	author carlton;	state Exp;
branches;
next	1.4.16.2;

1.4.16.2
date	2003.02.07.19.18.24;	author carlton;	state Exp;
branches;
next	;

1.1.1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.09.22.41.00;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.19.56.45;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.9
log
@2007-05-14  Maciej W. Rozycki  <macro@@mips.com>

	* win/tclWinPipe.c (TclpCreateProcess): Only use CW_SYNC_WINENV if
	supported by the compilation environment.
@
text
@/* 
 * tclWinPipe.c --
 *
 *	This file implements the Windows-specific exec pipeline functions,
 *	the "pipe" channel driver, and the "pid" Tcl command.
 *
 * Copyright (c) 1996-1997 by Sun Microsystems, Inc.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tclWinPipe.c,v 1.25 2002/06/17 20:05:49 andreas_kupries Exp $
 */

#include "tclWinInt.h"

#include <fcntl.h>
#include <io.h>
#include <sys/stat.h>
#ifdef __CYGWIN__
#include <sys/cygwin.h>
#endif

/*
 * The following variable is used to tell whether this module has been
 * initialized.
 */

static int initialized = 0;

/*
 * The pipeMutex locks around access to the initialized and procList variables,
 * and it is used to protect background threads from being terminated while
 * they are using APIs that hold locks.
 */

TCL_DECLARE_MUTEX(pipeMutex)

/*
 * The following defines identify the various types of applications that 
 * run under windows.  There is special case code for the various types.
 */

#define APPL_NONE	0
#define APPL_DOS	1
#define APPL_WIN3X	2
#define APPL_WIN32	3

/*
 * The following constants and structures are used to encapsulate the state
 * of various types of files used in a pipeline.
 * This used to have a 1 && 2 that supported Win32s.
 */

#define WIN_FILE 3		/* Basic Win32 file. */

/*
 * This structure encapsulates the common state associated with all file
 * types used in a pipeline.
 */

typedef struct WinFile {
    int type;			/* One of the file types defined above. */
    HANDLE handle;		/* Open file handle. */
} WinFile;

/*
 * This list is used to map from pids to process handles.
 */

typedef struct ProcInfo {
    HANDLE hProcess;
    DWORD dwProcessId;
    struct ProcInfo *nextPtr;
} ProcInfo;

static ProcInfo *procList;

/*
 * Bit masks used in the flags field of the PipeInfo structure below.
 */

#define PIPE_PENDING	(1<<0)	/* Message is pending in the queue. */
#define PIPE_ASYNC	(1<<1)	/* Channel is non-blocking. */

/*
 * Bit masks used in the sharedFlags field of the PipeInfo structure below.
 */

#define PIPE_EOF	(1<<2)	/* Pipe has reached EOF. */
#define PIPE_EXTRABYTE	(1<<3)	/* The reader thread has consumed one byte. */

/*
 * This structure describes per-instance data for a pipe based channel.
 */

typedef struct PipeInfo {
    struct PipeInfo *nextPtr;	/* Pointer to next registered pipe. */
    Tcl_Channel channel;	/* Pointer to channel structure. */
    int validMask;		/* OR'ed combination of TCL_READABLE,
				 * TCL_WRITABLE, or TCL_EXCEPTION: indicates
				 * which operations are valid on the file. */
    int watchMask;		/* OR'ed combination of TCL_READABLE,
				 * TCL_WRITABLE, or TCL_EXCEPTION: indicates
				 * which events should be reported. */
    int flags;			/* State flags, see above for a list. */
    TclFile readFile;		/* Output from pipe. */
    TclFile writeFile;		/* Input from pipe. */
    TclFile errorFile;		/* Error output from pipe. */
    int numPids;		/* Number of processes attached to pipe. */
    Tcl_Pid *pidPtr;		/* Pids of attached processes. */
    Tcl_ThreadId threadId;	/* Thread to which events should be reported.
				 * This value is used by the reader/writer
				 * threads. */
    HANDLE writeThread;		/* Handle to writer thread. */
    HANDLE readThread;		/* Handle to reader thread. */
    HANDLE writable;		/* Manual-reset event to signal when the
				 * writer thread has finished waiting for
				 * the current buffer to be written. */
    HANDLE readable;		/* Manual-reset event to signal when the
				 * reader thread has finished waiting for
				 * input. */
    HANDLE startWriter;		/* Auto-reset event used by the main thread to
				 * signal when the writer thread should attempt
				 * to write to the pipe. */
    HANDLE startReader;		/* Auto-reset event used by the main thread to
				 * signal when the reader thread should attempt
				 * to read from the pipe. */
    HANDLE stopReader;		/* Manual-reset event used to alert the reader
				 * thread to fall-out and exit */
    DWORD writeError;		/* An error caused by the last background
				 * write.  Set to 0 if no error has been
				 * detected.  This word is shared with the
				 * writer thread so access must be
				 * synchronized with the writable object.
				 */
    char *writeBuf;		/* Current background output buffer.
				 * Access is synchronized with the writable
				 * object. */
    int writeBufLen;		/* Size of write buffer.  Access is
				 * synchronized with the writable
				 * object. */
    int toWrite;		/* Current amount to be written.  Access is
				 * synchronized with the writable object. */
    int readFlags;		/* Flags that are shared with the reader
				 * thread.  Access is synchronized with the
				 * readable object.  */
    char extraByte;		/* Buffer for extra character consumed by
				 * reader thread.  This byte is shared with
				 * the reader thread so access must be
				 * synchronized with the readable object. */
} PipeInfo;

typedef struct ThreadSpecificData {
    /*
     * The following pointer refers to the head of the list of pipes
     * that are being watched for file events.
     */
    
    PipeInfo *firstPipePtr;
} ThreadSpecificData;

static Tcl_ThreadDataKey dataKey;

/*
 * The following structure is what is added to the Tcl event queue when
 * pipe events are generated.
 */

typedef struct PipeEvent {
    Tcl_Event header;		/* Information that is standard for
				 * all events. */
    PipeInfo *infoPtr;		/* Pointer to pipe info structure.  Note
				 * that we still have to verify that the
				 * pipe exists before dereferencing this
				 * pointer. */
} PipeEvent;

/*
 * Declarations for functions used only in this file.
 */

static int		ApplicationType(Tcl_Interp *interp,
			    const char *fileName, char *fullName);
static void		BuildCommandLine(const char *executable, int argc, 
			    CONST char **argv, Tcl_DString *linePtr);
static BOOL		HasConsole(void);
static int		PipeBlockModeProc(ClientData instanceData, int mode);
static void		PipeCheckProc(ClientData clientData, int flags);
static int		PipeClose2Proc(ClientData instanceData,
			    Tcl_Interp *interp, int flags);
static int		PipeEventProc(Tcl_Event *evPtr, int flags);
static void		PipeExitHandler(ClientData clientData);
static int		PipeGetHandleProc(ClientData instanceData,
			    int direction, ClientData *handlePtr);
static void		PipeInit(void);
static int		PipeInputProc(ClientData instanceData, char *buf,
			    int toRead, int *errorCode);
static int		PipeOutputProc(ClientData instanceData,
			    CONST char *buf, int toWrite, int *errorCode);
static DWORD WINAPI	PipeReaderThread(LPVOID arg);
static void		PipeSetupProc(ClientData clientData, int flags);
static void		PipeWatchProc(ClientData instanceData, int mask);
static DWORD WINAPI	PipeWriterThread(LPVOID arg);
static void		ProcExitHandler(ClientData clientData);
static int		TempFileName(WCHAR name[MAX_PATH]);
static int		WaitForRead(PipeInfo *infoPtr, int blocking);

/*
 * This structure describes the channel type structure for command pipe
 * based IO.
 */

static Tcl_ChannelType pipeChannelType = {
    "pipe",			/* Type name. */
    TCL_CHANNEL_VERSION_2,	/* v2 channel */
    TCL_CLOSE2PROC,		/* Close proc. */
    PipeInputProc,		/* Input proc. */
    PipeOutputProc,		/* Output proc. */
    NULL,			/* Seek proc. */
    NULL,			/* Set option proc. */
    NULL,			/* Get option proc. */
    PipeWatchProc,		/* Set up notifier to watch the channel. */
    PipeGetHandleProc,		/* Get an OS handle from channel. */
    PipeClose2Proc,		/* close2proc */
    PipeBlockModeProc,		/* Set blocking or non-blocking mode.*/
    NULL,			/* flush proc. */
    NULL,			/* handler proc. */
};

/*
 *----------------------------------------------------------------------
 *
 * PipeInit --
 *
 *	This function initializes the static variables for this file.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Creates a new event source.
 *
 *----------------------------------------------------------------------
 */

static void
PipeInit()
{
    ThreadSpecificData *tsdPtr;

    /*
     * Check the initialized flag first, then check again in the mutex.
     * This is a speed enhancement.
     */

    if (!initialized) {
	Tcl_MutexLock(&pipeMutex);
	if (!initialized) {
	    initialized = 1;
	    procList = NULL;
	    Tcl_CreateExitHandler(ProcExitHandler, NULL);
	}
	Tcl_MutexUnlock(&pipeMutex);
    }

    tsdPtr = (ThreadSpecificData *)TclThreadDataKeyGet(&dataKey);
    if (tsdPtr == NULL) {
	tsdPtr = TCL_TSD_INIT(&dataKey);
	tsdPtr->firstPipePtr = NULL;
	Tcl_CreateEventSource(PipeSetupProc, PipeCheckProc, NULL);
	Tcl_CreateThreadExitHandler(PipeExitHandler, NULL);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * PipeExitHandler --
 *
 *	This function is called to cleanup the pipe module before
 *	Tcl is unloaded.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Removes the pipe event source.
 *
 *----------------------------------------------------------------------
 */

static void
PipeExitHandler(
    ClientData clientData)	/* Old window proc */
{
    Tcl_DeleteEventSource(PipeSetupProc, PipeCheckProc, NULL);
}

/*
 *----------------------------------------------------------------------
 *
 * ProcExitHandler --
 *
 *	This function is called to cleanup the process list before
 *	Tcl is unloaded.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Resets the process list.
 *
 *----------------------------------------------------------------------
 */

static void
ProcExitHandler(
    ClientData clientData)	/* Old window proc */
{
    Tcl_MutexLock(&pipeMutex);
    initialized = 0;
    Tcl_MutexUnlock(&pipeMutex);
}

/*
 *----------------------------------------------------------------------
 *
 * PipeSetupProc --
 *
 *	This procedure is invoked before Tcl_DoOneEvent blocks waiting
 *	for an event.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Adjusts the block time if needed.
 *
 *----------------------------------------------------------------------
 */

void
PipeSetupProc(
    ClientData data,		/* Not used. */
    int flags)			/* Event flags as passed to Tcl_DoOneEvent. */
{
    PipeInfo *infoPtr;
    Tcl_Time blockTime = { 0, 0 };
    int block = 1;
    WinFile *filePtr;
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    if (!(flags & TCL_FILE_EVENTS)) {
	return;
    }
    
    /*
     * Look to see if any events are already pending.  If they are, poll.
     */

    for (infoPtr = tsdPtr->firstPipePtr; infoPtr != NULL; 
	    infoPtr = infoPtr->nextPtr) {
	if (infoPtr->watchMask & TCL_WRITABLE) {
	    filePtr = (WinFile*) infoPtr->writeFile;
	    if (WaitForSingleObject(infoPtr->writable, 0) != WAIT_TIMEOUT) {
		block = 0;
	    }
	}
	if (infoPtr->watchMask & TCL_READABLE) {
	    filePtr = (WinFile*) infoPtr->readFile;
	    if (WaitForRead(infoPtr, 0) >= 0) {
		block = 0;
	    }
	}
    }
    if (!block) {
	Tcl_SetMaxBlockTime(&blockTime);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * PipeCheckProc --
 *
 *	This procedure is called by Tcl_DoOneEvent to check the pipe
 *	event source for events. 
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	May queue an event.
 *
 *----------------------------------------------------------------------
 */

static void
PipeCheckProc(
    ClientData data,		/* Not used. */
    int flags)			/* Event flags as passed to Tcl_DoOneEvent. */
{
    PipeInfo *infoPtr;
    PipeEvent *evPtr;
    WinFile *filePtr;
    int needEvent;
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    if (!(flags & TCL_FILE_EVENTS)) {
	return;
    }
    
    /*
     * Queue events for any ready pipes that don't already have events
     * queued.
     */

    for (infoPtr = tsdPtr->firstPipePtr; infoPtr != NULL; 
	    infoPtr = infoPtr->nextPtr) {
	if (infoPtr->flags & PIPE_PENDING) {
	    continue;
	}
	
	/*
	 * Queue an event if the pipe is signaled for reading or writing.
	 */

	needEvent = 0;
	filePtr = (WinFile*) infoPtr->writeFile;
	if ((infoPtr->watchMask & TCL_WRITABLE) &&
		(WaitForSingleObject(infoPtr->writable, 0) != WAIT_TIMEOUT)) {
	    needEvent = 1;
	}
	
	filePtr = (WinFile*) infoPtr->readFile;
	if ((infoPtr->watchMask & TCL_READABLE) &&
		(WaitForRead(infoPtr, 0) >= 0)) {
	    needEvent = 1;
	}

	if (needEvent) {
	    infoPtr->flags |= PIPE_PENDING;
	    evPtr = (PipeEvent *) ckalloc(sizeof(PipeEvent));
	    evPtr->header.proc = PipeEventProc;
	    evPtr->infoPtr = infoPtr;
	    Tcl_QueueEvent((Tcl_Event *) evPtr, TCL_QUEUE_TAIL);
	}
    }
}

/*
 *----------------------------------------------------------------------
 *
 * TclWinMakeFile --
 *
 *	This function constructs a new TclFile from a given data and
 *	type value.
 *
 * Results:
 *	Returns a newly allocated WinFile as a TclFile.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

TclFile
TclWinMakeFile(
    HANDLE handle)		/* Type-specific data. */
{
    WinFile *filePtr;

    filePtr = (WinFile *) ckalloc(sizeof(WinFile));
    filePtr->type = WIN_FILE;
    filePtr->handle = handle;

    return (TclFile)filePtr;
}

/*
 *----------------------------------------------------------------------
 *
 * TempFileName --
 *
 *	Gets a temporary file name and deals with the fact that the
 *	temporary file path provided by Windows may not actually exist
 *	if the TMP or TEMP environment variables refer to a 
 *	non-existent directory.
 *
 * Results:    
 *	0 if error, non-zero otherwise.  If non-zero is returned, the
 *	name buffer will be filled with a name that can be used to 
 *	construct a temporary file.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static int
TempFileName(name)
    WCHAR name[MAX_PATH];	/* Buffer in which name for temporary 
				 * file gets stored. */
{
    TCHAR *prefix;

    prefix = (tclWinProcs->useWide) ? (TCHAR *) L"TCL" : (TCHAR *) "TCL";
    if ((*tclWinProcs->getTempPathProc)(MAX_PATH, name) != 0) {
	if ((*tclWinProcs->getTempFileNameProc)((TCHAR *) name, prefix, 0, 
		name) != 0) {
	    return 1;
	}
    }
    if (tclWinProcs->useWide) {
	((WCHAR *) name)[0] = '.';
	((WCHAR *) name)[1] = '\0';
    } else {
	((char *) name)[0] = '.';
	((char *) name)[1] = '\0';
    }
    return (*tclWinProcs->getTempFileNameProc)((TCHAR *) name, prefix, 0, 
	    name);
}

/*
 *----------------------------------------------------------------------
 *
 * TclpMakeFile --
 *
 *	Make a TclFile from a channel.
 *
 * Results:
 *	Returns a new TclFile or NULL on failure.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

TclFile
TclpMakeFile(channel, direction)
    Tcl_Channel channel;	/* Channel to get file from. */
    int direction;		/* Either TCL_READABLE or TCL_WRITABLE. */
{
    HANDLE handle;

    if (Tcl_GetChannelHandle(channel, direction, 
	    (ClientData *) &handle) == TCL_OK) {
	return TclWinMakeFile(handle);
    } else {
	return (TclFile) NULL;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * TclpOpenFile --
 *
 *	This function opens files for use in a pipeline.
 *
 * Results:
 *	Returns a newly allocated TclFile structure containing the
 *	file handle.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

TclFile
TclpOpenFile(path, mode)
    CONST char *path;		/* The name of the file to open. */
    int mode;			/* In what mode to open the file? */
{
    HANDLE handle;
    DWORD accessMode, createMode, shareMode, flags;
    Tcl_DString ds;
    CONST TCHAR *nativePath;
    
    /*
     * Map the access bits to the NT access mode.
     */

    switch (mode & (O_RDONLY | O_WRONLY | O_RDWR)) {
	case O_RDONLY:
	    accessMode = GENERIC_READ;
	    break;
	case O_WRONLY:
	    accessMode = GENERIC_WRITE;
	    break;
	case O_RDWR:
	    accessMode = (GENERIC_READ | GENERIC_WRITE);
	    break;
	default:
	    TclWinConvertError(ERROR_INVALID_FUNCTION);
	    return NULL;
    }

    /*
     * Map the creation flags to the NT create mode.
     */

    switch (mode & (O_CREAT | O_EXCL | O_TRUNC)) {
	case (O_CREAT | O_EXCL):
	case (O_CREAT | O_EXCL | O_TRUNC):
	    createMode = CREATE_NEW;
	    break;
	case (O_CREAT | O_TRUNC):
	    createMode = CREATE_ALWAYS;
	    break;
	case O_CREAT:
	    createMode = OPEN_ALWAYS;
	    break;
	case O_TRUNC:
	case (O_TRUNC | O_EXCL):
	    createMode = TRUNCATE_EXISTING;
	    break;
	default:
	    createMode = OPEN_EXISTING;
	    break;
    }

    nativePath = Tcl_WinUtfToTChar(path, -1, &ds);

    /*
     * If the file is not being created, use the existing file attributes.
     */

    flags = 0;
    if (!(mode & O_CREAT)) {
	flags = (*tclWinProcs->getFileAttributesProc)(nativePath);
	if (flags == 0xFFFFFFFF) {
	    flags = 0;
	}
    }

    /*
     * Set up the file sharing mode.  We want to allow simultaneous access.
     */

    shareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;

    /*
     * Now we get to create the file.
     */

    handle = (*tclWinProcs->createFileProc)(nativePath, accessMode, 
	    shareMode, NULL, createMode, flags, NULL);
    Tcl_DStringFree(&ds);

    if (handle == INVALID_HANDLE_VALUE) {
	DWORD err;
	
	err = GetLastError();
	if ((err & 0xffffL) == ERROR_OPEN_FAILED) {
	    err = (mode & O_CREAT) ? ERROR_FILE_EXISTS : ERROR_FILE_NOT_FOUND;
	}
        TclWinConvertError(err);
        return NULL;
    }

    /*
     * Seek to the end of file if we are writing.
     */

    if (mode & O_WRONLY) {
	SetFilePointer(handle, 0, NULL, FILE_END);
    }

    return TclWinMakeFile(handle);
}

/*
 *----------------------------------------------------------------------
 *
 * TclpCreateTempFile --
 *
 *	This function opens a unique file with the property that it
 *	will be deleted when its file handle is closed.  The temporary
 *	file is created in the system temporary directory.
 *
 * Results:
 *	Returns a valid TclFile, or NULL on failure.
 *
 * Side effects:
 *	Creates a new temporary file.
 *
 *----------------------------------------------------------------------
 */

TclFile
TclpCreateTempFile(contents)
    CONST char *contents;	/* String to write into temp file, or NULL. */
{
    WCHAR name[MAX_PATH];
    CONST char *native;
    Tcl_DString dstring;
    HANDLE handle;

    if (TempFileName(name) == 0) {
	return NULL;
    }

    handle = (*tclWinProcs->createFileProc)((TCHAR *) name, 
	    GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 
	    FILE_ATTRIBUTE_TEMPORARY|FILE_FLAG_DELETE_ON_CLOSE, NULL);
    if (handle == INVALID_HANDLE_VALUE) {
	goto error;
    }

    /*
     * Write the file out, doing line translations on the way.
     */

    if (contents != NULL) {
	DWORD result, length;
	CONST char *p;

	/*
	 * Convert the contents from UTF to native encoding
	 */
	native = Tcl_UtfToExternalDString(NULL, contents, -1, &dstring);
	
	for (p = native; *p != '\0'; p++) {
	    if (*p == '\n') {
		length = p - native;
		if (length > 0) {
		    if (!WriteFile(handle, native, length, &result, NULL)) {
			goto error;
		    }
		}
		if (!WriteFile(handle, "\r\n", 2, &result, NULL)) {
		    goto error;
		}
		native = p+1;
	    }
	}
	length = p - native;
	if (length > 0) {
	    if (!WriteFile(handle, native, length, &result, NULL)) {
		goto error;
	    }
	}
	Tcl_DStringFree(&dstring);
	if (SetFilePointer(handle, 0, NULL, FILE_BEGIN) == 0xFFFFFFFF) {
	    goto error;
	}
    }

    return TclWinMakeFile(handle);

  error:
    /* Free the native representation of the contents if necessary */
    if (contents != NULL) {
	Tcl_DStringFree(&dstring);
    }

    TclWinConvertError(GetLastError());
    CloseHandle(handle);
    (*tclWinProcs->deleteFileProc)((TCHAR *) name);
    return NULL;
}

/*
 *----------------------------------------------------------------------
 *
 * TclpTempFileName --
 *
 *	This function returns a unique filename.
 *
 * Results:
 *	Returns a valid Tcl_Obj* with refCount 0, or NULL on failure.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_Obj* 
TclpTempFileName()
{
    WCHAR fileName[MAX_PATH];

    if (TempFileName(fileName) == 0) {
	return NULL;
    }

    return TclpNativeToNormalized((ClientData) fileName);
}

/*
 *----------------------------------------------------------------------
 *
 * TclpCreatePipe --
 *
 *      Creates an anonymous pipe.
 *
 * Results:
 *      Returns 1 on success, 0 on failure. 
 *
 * Side effects:
 *      Creates a pipe.
 *
 *----------------------------------------------------------------------
 */

int
TclpCreatePipe(
    TclFile *readPipe,	/* Location to store file handle for
				 * read side of pipe. */
    TclFile *writePipe)	/* Location to store file handle for
				 * write side of pipe. */
{
    HANDLE readHandle, writeHandle;

    if (CreatePipe(&readHandle, &writeHandle, NULL, 0) != 0) {
	*readPipe = TclWinMakeFile(readHandle);
	*writePipe = TclWinMakeFile(writeHandle);
	return 1;
    }

    TclWinConvertError(GetLastError());
    return 0;
}

/*
 *----------------------------------------------------------------------
 *
 * TclpCloseFile --
 *
 *	Closes a pipeline file handle.  These handles are created by
 *	TclpOpenFile, TclpCreatePipe, or TclpMakeFile.
 *
 * Results:
 *	0 on success, -1 on failure.
 *
 * Side effects:
 *	The file is closed and deallocated.
 *
 *----------------------------------------------------------------------
 */

int
TclpCloseFile(
    TclFile file)	/* The file to close. */
{
    WinFile *filePtr = (WinFile *) file;

    switch (filePtr->type) {
	case WIN_FILE:
	    /*
	     * Don't close the Win32 handle if the handle is a standard channel
	     * during the exit process.  Otherwise, one thread may kill the
	     * stdio of another.
	     */

	    if (!TclInExit() 
		    || ((GetStdHandle(STD_INPUT_HANDLE) != filePtr->handle)
			    && (GetStdHandle(STD_OUTPUT_HANDLE) != filePtr->handle)
			    && (GetStdHandle(STD_ERROR_HANDLE) != filePtr->handle))) {
		if (filePtr->handle != NULL &&
			CloseHandle(filePtr->handle) == FALSE) {
		    TclWinConvertError(GetLastError());
		    ckfree((char *) filePtr);
		    return -1;
		}
	    }
	    break;

	default:
	    panic("TclpCloseFile: unexpected file type");
    }

    ckfree((char *) filePtr);
    return 0;
}

/*
 *--------------------------------------------------------------------------
 *
 * TclpGetPid --
 *
 *	Given a HANDLE to a child process, return the process id for that
 *	child process.
 *
 * Results:
 *	Returns the process id for the child process.  If the pid was not 
 *	known by Tcl, either because the pid was not created by Tcl or the 
 *	child process has already been reaped, -1 is returned.
 *
 * Side effects:
 *	None.
 *
 *--------------------------------------------------------------------------
 */

unsigned long
TclpGetPid(
    Tcl_Pid pid)		/* The HANDLE of the child process. */
{
    ProcInfo *infoPtr;

    Tcl_MutexLock(&pipeMutex);
    for (infoPtr = procList; infoPtr != NULL; infoPtr = infoPtr->nextPtr) {
	if (infoPtr->hProcess == (HANDLE) pid) {
	    Tcl_MutexUnlock(&pipeMutex);
	    return infoPtr->dwProcessId;
	}
    }
    Tcl_MutexUnlock(&pipeMutex);
    return (unsigned long) -1;
}

/*
 *----------------------------------------------------------------------
 *
 * TclpCreateProcess --
 *
 *	Create a child process that has the specified files as its 
 *	standard input, output, and error.  The child process runs
 *	asynchronously under Windows NT and Windows 9x, and runs
 *	with the same environment variables as the creating process.
 *
 *	The complete Windows search path is searched to find the specified 
 *	executable.  If an executable by the given name is not found, 
 *	automatically tries appending ".com", ".exe", and ".bat" to the 
 *	executable name.
 *
 * Results:
 *	The return value is TCL_ERROR and an error message is left in
 *	the interp's result if there was a problem creating the child 
 *	process.  Otherwise, the return value is TCL_OK and *pidPtr is
 *	filled with the process id of the child process.
 * 
 * Side effects:
 *	A process is created.
 *	
 *----------------------------------------------------------------------
 */

int
TclpCreateProcess(
    Tcl_Interp *interp,		/* Interpreter in which to leave errors that
				 * occurred when creating the child process.
				 * Error messages from the child process
				 * itself are sent to errorFile. */
    int argc,			/* Number of arguments in following array. */
    CONST char **argv,		/* Array of argument strings.  argv[0]
				 * contains the name of the executable
				 * converted to native format (using the
				 * Tcl_TranslateFileName call).  Additional
				 * arguments have not been converted. */
    TclFile inputFile,		/* If non-NULL, gives the file to use as
				 * input for the child process.  If inputFile
				 * file is not readable or is NULL, the child
				 * will receive no standard input. */
    TclFile outputFile,		/* If non-NULL, gives the file that
				 * receives output from the child process.  If
				 * outputFile file is not writeable or is
				 * NULL, output from the child will be
				 * discarded. */
    TclFile errorFile,		/* If non-NULL, gives the file that
				 * receives errors from the child process.  If
				 * errorFile file is not writeable or is NULL,
				 * errors from the child will be discarded.
				 * errorFile may be the same as outputFile. */
    Tcl_Pid *pidPtr)		/* If this procedure is successful, pidPtr
				 * is filled with the process id of the child
				 * process. */
{
    int result, applType, createFlags;
    Tcl_DString cmdLine;	/* Complete command line (TCHAR). */
    STARTUPINFOA startInfo;
    PROCESS_INFORMATION procInfo;
    SECURITY_ATTRIBUTES secAtts;
    HANDLE hProcess, h, inputHandle, outputHandle, errorHandle;
    char execPath[MAX_PATH * TCL_UTF_MAX];
    WinFile *filePtr;

    PipeInit();

    applType = ApplicationType(interp, argv[0], execPath);
    if (applType == APPL_NONE) {
	return TCL_ERROR;
    }

    result = TCL_ERROR;
    Tcl_DStringInit(&cmdLine);
    hProcess = GetCurrentProcess();

    /*
     * STARTF_USESTDHANDLES must be used to pass handles to child process.
     * Using SetStdHandle() and/or dup2() only works when a console mode 
     * parent process is spawning an attached console mode child process.
     */

    ZeroMemory(&startInfo, sizeof(startInfo));
    startInfo.cb = sizeof(startInfo);
    startInfo.dwFlags   = STARTF_USESTDHANDLES;
    startInfo.hStdInput	= INVALID_HANDLE_VALUE;
    startInfo.hStdOutput= INVALID_HANDLE_VALUE;
    startInfo.hStdError = INVALID_HANDLE_VALUE;

    secAtts.nLength = sizeof(SECURITY_ATTRIBUTES);
    secAtts.lpSecurityDescriptor = NULL;
    secAtts.bInheritHandle = TRUE;

    /*
     * We have to check the type of each file, since we cannot duplicate 
     * some file types.  
     */

    inputHandle = INVALID_HANDLE_VALUE;
    if (inputFile != NULL) {
	filePtr = (WinFile *)inputFile;
	if (filePtr->type == WIN_FILE) {
	    inputHandle = filePtr->handle;
	}
    }
    outputHandle = INVALID_HANDLE_VALUE;
    if (outputFile != NULL) {
	filePtr = (WinFile *)outputFile;
	if (filePtr->type == WIN_FILE) {
	    outputHandle = filePtr->handle;
	}
    }
    errorHandle = INVALID_HANDLE_VALUE;
    if (errorFile != NULL) {
	filePtr = (WinFile *)errorFile;
	if (filePtr->type == WIN_FILE) {
	    errorHandle = filePtr->handle;
	}
    }

    /*
     * Duplicate all the handles which will be passed off as stdin, stdout
     * and stderr of the child process. The duplicate handles are set to
     * be inheritable, so the child process can use them.
     */

    if (inputHandle == INVALID_HANDLE_VALUE) {
	/* 
	 * If handle was not set, stdin should return immediate EOF.
	 * Under Windows95, some applications (both 16 and 32 bit!) 
	 * cannot read from the NUL device; they read from console
	 * instead.  When running tk, this is fatal because the child 
	 * process would hang forever waiting for EOF from the unmapped 
	 * console window used by the helper application.
	 *
	 * Fortunately, the helper application detects a closed pipe 
	 * as an immediate EOF and can pass that information to the 
	 * child process.
	 */

	if (CreatePipe(&startInfo.hStdInput, &h, &secAtts, 0) != FALSE) {
	    CloseHandle(h);
	}
    } else {
	DuplicateHandle(hProcess, inputHandle, hProcess, &startInfo.hStdInput,
		0, TRUE, DUPLICATE_SAME_ACCESS);
    }
    if (startInfo.hStdInput == INVALID_HANDLE_VALUE) {
	TclWinConvertError(GetLastError());
	Tcl_AppendResult(interp, "couldn't duplicate input handle: ",
		Tcl_PosixError(interp), (char *) NULL);
	goto end;
    }

    if (outputHandle == INVALID_HANDLE_VALUE) {
	/*
	 * If handle was not set, output should be sent to an infinitely 
	 * deep sink.  Under Windows 95, some 16 bit applications cannot
	 * have stdout redirected to NUL; they send their output to
	 * the console instead.  Some applications, like "more" or "dir /p", 
	 * when outputting multiple pages to the console, also then try and
	 * read from the console to go the next page.  When running tk, this
	 * is fatal because the child process would hang forever waiting
	 * for input from the unmapped console window used by the helper
	 * application.
	 *
	 * Fortunately, the helper application will detect a closed pipe
	 * as a sink.
	 */

	if ((TclWinGetPlatformId() == VER_PLATFORM_WIN32_WINDOWS) 
		&& (applType == APPL_DOS)) {
	    if (CreatePipe(&h, &startInfo.hStdOutput, &secAtts, 0) != FALSE) {
		CloseHandle(h);
	    }
	} else {
	    startInfo.hStdOutput = CreateFileA("NUL:", GENERIC_WRITE, 0,
		    &secAtts, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	}
    } else {
	DuplicateHandle(hProcess, outputHandle, hProcess, &startInfo.hStdOutput, 
		0, TRUE, DUPLICATE_SAME_ACCESS);
    }
    if (startInfo.hStdOutput == INVALID_HANDLE_VALUE) {
	TclWinConvertError(GetLastError());
	Tcl_AppendResult(interp, "couldn't duplicate output handle: ",
		Tcl_PosixError(interp), (char *) NULL);
	goto end;
    }

    if (errorHandle == INVALID_HANDLE_VALUE) {
	/*
	 * If handle was not set, errors should be sent to an infinitely
	 * deep sink.
	 */

	startInfo.hStdError = CreateFileA("NUL:", GENERIC_WRITE, 0,
		&secAtts, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
    } else {
	DuplicateHandle(hProcess, errorHandle, hProcess, &startInfo.hStdError, 
		0, TRUE, DUPLICATE_SAME_ACCESS);
    } 
    if (startInfo.hStdError == INVALID_HANDLE_VALUE) {
	TclWinConvertError(GetLastError());
	Tcl_AppendResult(interp, "couldn't duplicate error handle: ",
		Tcl_PosixError(interp), (char *) NULL);
	goto end;
    }
    /* 
     * If we do not have a console window, then we must run DOS and
     * WIN32 console mode applications as detached processes. This tells
     * the loader that the child application should not inherit the
     * console, and that it should not create a new console window for
     * the child application.  The child application should get its stdio 
     * from the redirection handles provided by this application, and run
     * in the background.
     *
     * If we are starting a GUI process, they don't automatically get a 
     * console, so it doesn't matter if they are started as foreground or
     * detached processes.  The GUI window will still pop up to the
     * foreground.
     */

    if (TclWinGetPlatformId() == VER_PLATFORM_WIN32_NT) {
	if (HasConsole()) {
	    createFlags = 0;
	} else if (applType == APPL_DOS) {
	    /*
	     * Under NT, 16-bit DOS applications will not run unless they
	     * can be attached to a console.  If we are running without a
	     * console, run the 16-bit program as an normal process inside
	     * of a hidden console application, and then run that hidden
	     * console as a detached process.
	     */

	    startInfo.wShowWindow = SW_HIDE;
	    startInfo.dwFlags |= STARTF_USESHOWWINDOW;
	    createFlags = CREATE_NEW_CONSOLE;
	    Tcl_DStringAppend(&cmdLine, "cmd.exe /c ", -1);
	} else {
	    createFlags = DETACHED_PROCESS;
	} 
    } else {
	if (HasConsole()) {
	    createFlags = 0;
	} else {
	    createFlags = DETACHED_PROCESS;
	}
	
	if (applType == APPL_DOS) {
	    /*
	     * Under Windows 95, 16-bit DOS applications do not work well 
	     * with pipes:
	     *
	     * 1. EOF on a pipe between a detached 16-bit DOS application 
	     * and another application is not seen at the other
	     * end of the pipe, so the listening process blocks forever on 
	     * reads.  This inablity to detect EOF happens when either a 
	     * 16-bit app or the 32-bit app is the listener.  
	     *
	     * 2. If a 16-bit DOS application (detached or not) blocks when 
	     * writing to a pipe, it will never wake up again, and it
	     * eventually brings the whole system down around it.
	     *
	     * The 16-bit application is run as a normal process inside
	     * of a hidden helper console app, and this helper may be run
	     * as a detached process.  If any of the stdio handles is
	     * a pipe, the helper application accumulates information 
	     * into temp files and forwards it to or from the DOS 
	     * application as appropriate.  This means that DOS apps 
	     * must receive EOF from a stdin pipe before they will actually
	     * begin, and must finish generating stdout or stderr before 
	     * the data will be sent to the next stage of the pipe.
	     *
	     * The helper app should be located in the same directory as
	     * the tcl dll.
	     */

	    if (createFlags != 0) {
		startInfo.wShowWindow = SW_HIDE;
		startInfo.dwFlags |= STARTF_USESHOWWINDOW;
		createFlags = CREATE_NEW_CONSOLE;
	    }
	    Tcl_DStringAppend(&cmdLine, "tclpip" STRINGIFY(TCL_MAJOR_VERSION) 
		    STRINGIFY(TCL_MINOR_VERSION) ".dll ", -1);
	}
    }
    
    /*
     * cmdLine gets the full command line used to invoke the executable,
     * including the name of the executable itself.  The command line
     * arguments in argv[] are stored in cmdLine separated by spaces. 
     * Special characters in individual arguments from argv[] must be 
     * quoted when being stored in cmdLine.
     *
     * When calling any application, bear in mind that arguments that 
     * specify a path name are not converted.  If an argument contains 
     * forward slashes as path separators, it may or may not be 
     * recognized as a path name, depending on the program.  In general,
     * most applications accept forward slashes only as option 
     * delimiters and backslashes only as paths.
     *
     * Additionally, when calling a 16-bit dos or windows application, 
     * all path names must use the short, cryptic, path format (e.g., 
     * using ab~1.def instead of "a b.default").  
     */

    BuildCommandLine(execPath, argc, argv, &cmdLine);

#if defined(__CYGWIN__) && \
    (CYGWIN_VERSION_API_MAJOR > 0 || CYGWIN_VERSION_API_MINOR >= 154)
    /* Only available in Cygwin 1.5.20+. */
    cygwin_internal (CW_SYNC_WINENV);
#endif

    if ((*tclWinProcs->createProcessProc)(NULL, 
	    (TCHAR *) Tcl_DStringValue(&cmdLine), NULL, NULL, TRUE, 
	    (DWORD) createFlags, NULL, NULL, &startInfo, &procInfo) == 0) {
	TclWinConvertError(GetLastError());
	Tcl_AppendResult(interp, "couldn't execute \"", argv[0],
		"\": ", Tcl_PosixError(interp), (char *) NULL);
	goto end;
    }

    /*
     * This wait is used to force the OS to give some time to the DOS
     * process.
     */

    if (applType == APPL_DOS) {
	WaitForSingleObject(procInfo.hProcess, 50);
    }

    /* 
     * "When an application spawns a process repeatedly, a new thread 
     * instance will be created for each process but the previous 
     * instances may not be cleaned up.  This results in a significant 
     * virtual memory loss each time the process is spawned.  If there 
     * is a WaitForInputIdle() call between CreateProcess() and
     * CloseHandle(), the problem does not occur." PSS ID Number: Q124121
     */

    WaitForInputIdle(procInfo.hProcess, 5000);
    CloseHandle(procInfo.hThread);

    *pidPtr = (Tcl_Pid) procInfo.hProcess;
    if (*pidPtr != 0) {
	TclWinAddProcess(procInfo.hProcess, procInfo.dwProcessId);
    }
    result = TCL_OK;

    end:
    Tcl_DStringFree(&cmdLine);
    if (startInfo.hStdInput != INVALID_HANDLE_VALUE) {
        CloseHandle(startInfo.hStdInput);
    }
    if (startInfo.hStdOutput != INVALID_HANDLE_VALUE) {
        CloseHandle(startInfo.hStdOutput);
    }
    if (startInfo.hStdError != INVALID_HANDLE_VALUE) {
	CloseHandle(startInfo.hStdError);
    }
    return result;
}


/*
 *----------------------------------------------------------------------
 *
 * HasConsole --
 *
 *	Determines whether the current application is attached to a
 *	console.
 *
 * Results:
 *	Returns TRUE if this application has a console, else FALSE.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static BOOL
HasConsole()
{
    HANDLE handle;
    
    handle = CreateFileA("CONOUT$", GENERIC_WRITE, FILE_SHARE_WRITE,
	    NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    if (handle != INVALID_HANDLE_VALUE) {
        CloseHandle(handle);
	return TRUE;
    } else {
        return FALSE;
    }
}

/*
 *--------------------------------------------------------------------
 *
 * ApplicationType --
 *
 *	Search for the specified program and identify if it refers to a DOS,
 *	Windows 3.X, or Win32 program.  Used to determine how to invoke 
 *	a program, or if it can even be invoked.
 *
 *	It is possible to almost positively identify DOS and Windows 
 *	applications that contain the appropriate magic numbers.  However, 
 *	DOS .com files do not seem to contain a magic number; if the program 
 *	name ends with .com and could not be identified as a Windows .com
 *	file, it will be assumed to be a DOS application, even if it was
 *	just random data.  If the program name does not end with .com, no 
 *	such assumption is made.
 *
 *	The Win32 procedure GetBinaryType incorrectly identifies any 
 *	junk file that ends with .exe as a dos executable and some 
 *	executables that don't end with .exe as not executable.  Plus it 
 *	doesn't exist under win95, so I won't feel bad about reimplementing
 *	functionality.
 *
 * Results:
 *	The return value is one of APPL_DOS, APPL_WIN3X, or APPL_WIN32
 *	if the filename referred to the corresponding application type.
 *	If the file name could not be found or did not refer to any known 
 *	application type, APPL_NONE is returned and an error message is 
 *	left in interp.  .bat files are identified as APPL_DOS.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static int
ApplicationType(interp, originalName, fullName)
    Tcl_Interp *interp;		/* Interp, for error message. */
    const char *originalName;	/* Name of the application to find. */
    char fullName[];		/* Filled with complete path to 
				 * application. */
{
    int applType, i, nameLen, found;
    HANDLE hFile;
    TCHAR *rest;
    char *ext;
    char buf[2];
    DWORD attr, read;
    IMAGE_DOS_HEADER header;
    Tcl_DString nameBuf, ds;
    CONST TCHAR *nativeName;
    WCHAR nativeFullPath[MAX_PATH];
    static char extensions[][5] = {"", ".com", ".exe", ".bat"};

    /* Look for the program as an external program.  First try the name
     * as it is, then try adding .com, .exe, and .bat, in that order, to
     * the name, looking for an executable.
     *
     * Using the raw SearchPath() procedure doesn't do quite what is 
     * necessary.  If the name of the executable already contains a '.' 
     * character, it will not try appending the specified extension when
     * searching (in other words, SearchPath will not find the program 
     * "a.b.exe" if the arguments specified "a.b" and ".exe").   
     * So, first look for the file as it is named.  Then manually append 
     * the extensions, looking for a match.  
     */

    applType = APPL_NONE;
    Tcl_DStringInit(&nameBuf);
    Tcl_DStringAppend(&nameBuf, originalName, -1);
    nameLen = Tcl_DStringLength(&nameBuf);

    for (i = 0; i < (int) (sizeof(extensions) / sizeof(extensions[0])); i++) {
	Tcl_DStringSetLength(&nameBuf, nameLen);
	Tcl_DStringAppend(&nameBuf, extensions[i], -1);
        nativeName = Tcl_WinUtfToTChar(Tcl_DStringValue(&nameBuf), 
		Tcl_DStringLength(&nameBuf), &ds);
	found = (*tclWinProcs->searchPathProc)(NULL, nativeName, NULL, 
		MAX_PATH, nativeFullPath, &rest);
	Tcl_DStringFree(&ds);
	if (found == 0) {
	    continue;
	}

	/*
	 * Ignore matches on directories or data files, return if identified
	 * a known type.
	 */

	attr = (*tclWinProcs->getFileAttributesProc)((TCHAR *) nativeFullPath);
	if ((attr == 0xffffffff) || (attr & FILE_ATTRIBUTE_DIRECTORY)) {
	    continue;
	}
	strcpy(fullName, Tcl_WinTCharToUtf((TCHAR *) nativeFullPath, -1, &ds));
	Tcl_DStringFree(&ds);

	ext = strrchr(fullName, '.');
	if ((ext != NULL) && (stricmp(ext, ".bat") == 0)) {
	    applType = APPL_DOS;
	    break;
	}
	
	hFile = (*tclWinProcs->createFileProc)((TCHAR *) nativeFullPath, 
		GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 
		FILE_ATTRIBUTE_NORMAL, NULL);
	if (hFile == INVALID_HANDLE_VALUE) {
	    continue;
	}

	header.e_magic = 0;
	ReadFile(hFile, (void *) &header, sizeof(header), &read, NULL);
	if (header.e_magic != IMAGE_DOS_SIGNATURE) {
	    /* 
	     * Doesn't have the magic number for relocatable executables.  If 
	     * filename ends with .com, assume it's a DOS application anyhow.
	     * Note that we didn't make this assumption at first, because some
	     * supposed .com files are really 32-bit executables with all the
	     * magic numbers and everything.  
	     */

	    CloseHandle(hFile);
	    if ((ext != NULL) && (stricmp(ext, ".com") == 0)) {
		applType = APPL_DOS;
		break;
	    }
	    continue;
	}
	if (header.e_lfarlc != sizeof(header)) {
	    /* 
	     * All Windows 3.X and Win32 and some DOS programs have this value
	     * set here.  If it doesn't, assume that since it already had the 
	     * other magic number it was a DOS application.
	     */

	    CloseHandle(hFile);
	    applType = APPL_DOS;
	    break;
	}

	/* 
	 * The DWORD at header.e_lfanew points to yet another magic number.
	 */

	buf[0] = '\0';
	SetFilePointer(hFile, header.e_lfanew, NULL, FILE_BEGIN);
	ReadFile(hFile, (void *) buf, 2, &read, NULL);
	CloseHandle(hFile);

	if ((buf[0] == 'N') && (buf[1] == 'E')) {
	    applType = APPL_WIN3X;
	} else if ((buf[0] == 'P') && (buf[1] == 'E')) {
	    applType = APPL_WIN32;
	} else {
	    /*
	     * Strictly speaking, there should be a test that there
	     * is an 'L' and 'E' at buf[0..1], to identify the type as 
	     * DOS, but of course we ran into a DOS executable that 
	     * _doesn't_ have the magic number -- specifically, one
	     * compiled using the Lahey Fortran90 compiler.
	     */

	    applType = APPL_DOS;
	}
	break;
    }
    Tcl_DStringFree(&nameBuf);

    if (applType == APPL_NONE) {
	TclWinConvertError(GetLastError());
	Tcl_AppendResult(interp, "couldn't execute \"", originalName,
		"\": ", Tcl_PosixError(interp), (char *) NULL);
	return APPL_NONE;
    }

    if ((applType == APPL_DOS) || (applType == APPL_WIN3X)) {
	/* 
	 * Replace long path name of executable with short path name for 
	 * 16-bit applications.  Otherwise the application may not be able
	 * to correctly parse its own command line to separate off the 
	 * application name from the arguments.
	 */

	(*tclWinProcs->getShortPathNameProc)((TCHAR *) nativeFullPath, 
		nativeFullPath, MAX_PATH);
	strcpy(fullName, Tcl_WinTCharToUtf((TCHAR *) nativeFullPath, -1, &ds));
	Tcl_DStringFree(&ds);
    }
    return applType;
}

/*    
 *----------------------------------------------------------------------
 *
 * BuildCommandLine --
 *
 *	The command line arguments are stored in linePtr separated
 *	by spaces, in a form that CreateProcess() understands.  Special 
 *	characters in individual arguments from argv[] must be quoted 
 *	when being stored in cmdLine.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static void
BuildCommandLine(
    CONST char *executable,	/* Full path of executable (including 
				 * extension).  Replacement for argv[0]. */
    int argc,			/* Number of arguments. */
    CONST char **argv,		/* Argument strings in UTF. */
    Tcl_DString *linePtr)	/* Initialized Tcl_DString that receives the
				 * command line (TCHAR). */
{
    CONST char *arg, *start, *special;
    int quote, i;
    Tcl_DString ds;

    Tcl_DStringInit(&ds);

    /*
     * Prime the path.
     */
    
    Tcl_DStringAppend(&ds, Tcl_DStringValue(linePtr), -1);
    
    for (i = 0; i < argc; i++) {
	if (i == 0) {
	    arg = executable;
	} else {
	    arg = argv[i];
	    Tcl_DStringAppend(&ds, " ", 1);
	}

	quote = 0;
	if (arg[0] == '\0') {
	    quote = 1;
	} else {
	    for (start = arg; *start != '\0'; start++) {
		if (isspace(*start)) { /* INTL: ISO space. */
		    quote = 1;
		    break;
		}
	    }
	}
	if (quote) {
	    Tcl_DStringAppend(&ds, "\"", 1);
	}

	start = arg;	    
	for (special = arg; ; ) {
	    if ((*special == '\\') && 
		    (special[1] == '\\' || special[1] == '"')) {
		Tcl_DStringAppend(&ds, start, special - start);
		start = special;
		while (1) {
		    special++;
		    if (*special == '"') {
			/* 
			 * N backslashes followed a quote -> insert 
			 * N * 2 + 1 backslashes then a quote.
			 */

			Tcl_DStringAppend(&ds, start, special - start);
			break;
		    }
		    if (*special != '\\') {
			break;
		    }
		}
		Tcl_DStringAppend(&ds, start, special - start);
		start = special;
	    }
	    if (*special == '"') {
		Tcl_DStringAppend(&ds, start, special - start);
		Tcl_DStringAppend(&ds, "\\\"", 2);
		start = special + 1;
	    }
	    if (*special == '{') {
		Tcl_DStringAppend(&ds, start, special - start);
		Tcl_DStringAppend(&ds, "\\{", 2);
		start = special + 1;
	    }
	    if (*special == '\0') {
		break;
	    }
	    special++;
	}
	Tcl_DStringAppend(&ds, start, special - start);
	if (quote) {
	    Tcl_DStringAppend(&ds, "\"", 1);
	}
    }
    Tcl_DStringFree(linePtr);
    Tcl_WinUtfToTChar(Tcl_DStringValue(&ds), Tcl_DStringLength(&ds), linePtr);
    Tcl_DStringFree(&ds);
}

/*
 *----------------------------------------------------------------------
 *
 * TclpCreateCommandChannel --
 *
 *	This function is called by Tcl_OpenCommandChannel to perform
 *	the platform specific channel initialization for a command
 *	channel.
 *
 * Results:
 *	Returns a new channel or NULL on failure.
 *
 * Side effects:
 *	Allocates a new channel.
 *
 *----------------------------------------------------------------------
 */

Tcl_Channel
TclpCreateCommandChannel(
    TclFile readFile,		/* If non-null, gives the file for reading. */
    TclFile writeFile,		/* If non-null, gives the file for writing. */
    TclFile errorFile,		/* If non-null, gives the file where errors
				 * can be read. */
    int numPids,		/* The number of pids in the pid array. */
    Tcl_Pid *pidPtr)		/* An array of process identifiers. */
{
    char channelName[16 + TCL_INTEGER_SPACE];
    int channelId;
    DWORD id;
    PipeInfo *infoPtr = (PipeInfo *) ckalloc((unsigned) sizeof(PipeInfo));

    PipeInit();

    infoPtr->watchMask = 0;
    infoPtr->flags = 0;
    infoPtr->readFlags = 0;
    infoPtr->readFile = readFile;
    infoPtr->writeFile = writeFile;
    infoPtr->errorFile = errorFile;
    infoPtr->numPids = numPids;
    infoPtr->pidPtr = pidPtr;
    infoPtr->writeBuf = 0;
    infoPtr->writeBufLen = 0;
    infoPtr->writeError = 0;

    /*
     * Use one of the fds associated with the channel as the
     * channel id.
     */

    if (readFile) {
	channelId = (int) ((WinFile*)readFile)->handle;
    } else if (writeFile) {
	channelId = (int) ((WinFile*)writeFile)->handle;
    } else if (errorFile) {
	channelId = (int) ((WinFile*)errorFile)->handle;
    } else {
	channelId = 0;
    }

    infoPtr->validMask = 0;

    infoPtr->threadId = Tcl_GetCurrentThread();

    if (readFile != NULL) {
	/*
	 * Start the background reader thread.
	 */

	infoPtr->readable = CreateEvent(NULL, TRUE, TRUE, NULL);
	infoPtr->startReader = CreateEvent(NULL, FALSE, FALSE, NULL);
	infoPtr->stopReader = CreateEvent(NULL, TRUE, FALSE, NULL);
	infoPtr->readThread = CreateThread(NULL, 512, PipeReaderThread,
		infoPtr, 0, &id);
	SetThreadPriority(infoPtr->readThread, THREAD_PRIORITY_HIGHEST); 
        infoPtr->validMask |= TCL_READABLE;
    } else {
	infoPtr->readThread = 0;
    }
    if (writeFile != NULL) {
	/*
	 * Start the background writer thread.
	 */

	infoPtr->writable = CreateEvent(NULL, TRUE, TRUE, NULL);
	infoPtr->startWriter = CreateEvent(NULL, FALSE, FALSE, NULL);
	infoPtr->writeThread = CreateThread(NULL, 512, PipeWriterThread,
		infoPtr, 0, &id);
	SetThreadPriority(infoPtr->readThread, THREAD_PRIORITY_HIGHEST); 
        infoPtr->validMask |= TCL_WRITABLE;
    }

    /*
     * For backward compatibility with previous versions of Tcl, we
     * use "file%d" as the base name for pipes even though it would
     * be more natural to use "pipe%d".
     * Use the pointer to keep the channel names unique, in case
     * channels share handles (stdin/stdout).
     */

    wsprintfA(channelName, "file%lx", infoPtr);
    infoPtr->channel = Tcl_CreateChannel(&pipeChannelType, channelName,
            (ClientData) infoPtr, infoPtr->validMask);

    /*
     * Pipes have AUTO translation mode on Windows and ^Z eof char, which
     * means that a ^Z will be appended to them at close. This is needed
     * for Windows programs that expect a ^Z at EOF.
     */

    Tcl_SetChannelOption((Tcl_Interp *) NULL, infoPtr->channel,
	    "-translation", "auto");
    Tcl_SetChannelOption((Tcl_Interp *) NULL, infoPtr->channel,
	    "-eofchar", "\032 {}");
    return infoPtr->channel;
}

/*
 *----------------------------------------------------------------------
 *
 * TclGetAndDetachPids --
 *
 *	Stores a list of the command PIDs for a command channel in
 *	the interp's result.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Modifies the interp's result.
 *
 *----------------------------------------------------------------------
 */

void
TclGetAndDetachPids(
    Tcl_Interp *interp,
    Tcl_Channel chan)
{
    PipeInfo *pipePtr;
    Tcl_ChannelType *chanTypePtr;
    int i;
    char buf[TCL_INTEGER_SPACE];

    /*
     * Punt if the channel is not a command channel.
     */

    chanTypePtr = Tcl_GetChannelType(chan);
    if (chanTypePtr != &pipeChannelType) {
        return;
    }

    pipePtr = (PipeInfo *) Tcl_GetChannelInstanceData(chan);
    for (i = 0; i < pipePtr->numPids; i++) {
        wsprintfA(buf, "%lu", TclpGetPid(pipePtr->pidPtr[i]));
        Tcl_AppendElement(interp, buf);
        Tcl_DetachPids(1, &(pipePtr->pidPtr[i]));
    }
    if (pipePtr->numPids > 0) {
        ckfree((char *) pipePtr->pidPtr);
        pipePtr->numPids = 0;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * PipeBlockModeProc --
 *
 *	Set blocking or non-blocking mode on channel.
 *
 * Results:
 *	0 if successful, errno when failed.
 *
 * Side effects:
 *	Sets the device into blocking or non-blocking mode.
 *
 *----------------------------------------------------------------------
 */

static int
PipeBlockModeProc(
    ClientData instanceData,	/* Instance data for channel. */
    int mode)			/* TCL_MODE_BLOCKING or
                                 * TCL_MODE_NONBLOCKING. */
{
    PipeInfo *infoPtr = (PipeInfo *) instanceData;
    
    /*
     * Pipes on Windows can not be switched between blocking and nonblocking,
     * hence we have to emulate the behavior. This is done in the input
     * function by checking against a bit in the state. We set or unset the
     * bit here to cause the input function to emulate the correct behavior.
     */

    if (mode == TCL_MODE_NONBLOCKING) {
	infoPtr->flags |= PIPE_ASYNC;
    } else {
	infoPtr->flags &= ~(PIPE_ASYNC);
    }
    return 0;
}

/*
 *----------------------------------------------------------------------
 *
 * PipeClose2Proc --
 *
 *	Closes a pipe based IO channel.
 *
 * Results:
 *	0 on success, errno otherwise.
 *
 * Side effects:
 *	Closes the physical channel.
 *
 *----------------------------------------------------------------------
 */

static int
PipeClose2Proc(
    ClientData instanceData,	/* Pointer to PipeInfo structure. */
    Tcl_Interp *interp,		/* For error reporting. */
    int flags)			/* Flags that indicate which side to close. */
{
    PipeInfo *pipePtr = (PipeInfo *) instanceData;
    Tcl_Channel errChan;
    int errorCode, result;
    PipeInfo *infoPtr, **nextPtrPtr;
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    DWORD exitCode;

    errorCode = 0;
    if ((!flags || (flags == TCL_CLOSE_READ))
	    && (pipePtr->readFile != NULL)) {
	/*
	 * Clean up the background thread if necessary.  Note that this
	 * must be done before we can close the file, since the 
	 * thread may be blocking trying to read from the pipe.
	 */

	if (pipePtr->readThread) {
	    /*
	     * The thread may already have closed on it's own.  Check it's
	     * exit code.
	     */

	    GetExitCodeThread(pipePtr->readThread, &exitCode);

	    if (exitCode == STILL_ACTIVE) {
		/*
		 * Set the stop event so that if the reader thread is blocked
		 * in PipeReaderThread on WaitForMultipleEvents, it will exit
		 * cleanly.
		 */

		SetEvent(pipePtr->stopReader);

		/*
		 * Wait at most 10 milliseconds for the reader thread to close.
		 */

		WaitForSingleObject(pipePtr->readThread, 10);
		GetExitCodeThread(pipePtr->readThread, &exitCode);

		if (exitCode == STILL_ACTIVE) {
		    /*
		     * The thread must be blocked waiting for the pipe to
		     * become readable in ReadFile().  There isn't a clean way
		     * to exit the thread from this condition.  We should
		     * terminate the child process instead to get the reader
		     * thread to fall out of ReadFile with a FALSE.  (below) is
		     * not the correct way to do this, but will stay here until
		     * a better solution is found.
		     *
		     * Note that we need to guard against terminating the
		     * thread while it is in the middle of Tcl_ThreadAlert
		     * because it won't be able to release the notifier lock.
		     */

		    Tcl_MutexLock(&pipeMutex);

		    /* BUG: this leaks memory */
		    TerminateThread(pipePtr->readThread, 0);

		    /* Wait for the thread to terminate. */
		    WaitForSingleObject(pipePtr->readThread, INFINITE);

		    Tcl_MutexUnlock(&pipeMutex);
		}
	    }

	    CloseHandle(pipePtr->readThread);
	    CloseHandle(pipePtr->readable);
	    CloseHandle(pipePtr->startReader);
	    CloseHandle(pipePtr->stopReader);
	    pipePtr->readThread = NULL;
	}
	if (TclpCloseFile(pipePtr->readFile) != 0) {
	    errorCode = errno;
	}
	pipePtr->validMask &= ~TCL_READABLE;
	pipePtr->readFile = NULL;
    }
    if ((!flags || (flags & TCL_CLOSE_WRITE))
	    && (pipePtr->writeFile != NULL)) {
	/*
	 * Wait for the writer thread to finish the current buffer, then
	 * terminate the thread and close the handles.  If the channel is
	 * nonblocking, there should be no pending write operations.
	 */

	if (pipePtr->writeThread) {
	    WaitForSingleObject(pipePtr->writable, INFINITE);

	    /*
	     * Forcibly terminate the background thread.  We cannot rely on the
	     * thread to cleanly terminate itself because we have no way of
	     * closing the pipe handle without blocking in the case where the
	     * thread is in the middle of an I/O operation.  Note that we need
	     * to guard against terminating the thread while it is in the
	     * middle of Tcl_ThreadAlert because it won't be able to release
	     * the notifier lock.
	     */

	    Tcl_MutexLock(&pipeMutex);
	    TerminateThread(pipePtr->writeThread, 0);

	    /*
	     * Wait for the thread to terminate.  This ensures that we are
	     * completely cleaned up before we leave this function. 
	     */

	    WaitForSingleObject(pipePtr->writeThread, INFINITE);
	    Tcl_MutexUnlock(&pipeMutex);


	    CloseHandle(pipePtr->writeThread);
	    CloseHandle(pipePtr->writable);
	    CloseHandle(pipePtr->startWriter);
	    pipePtr->writeThread = NULL;
	}
	if (TclpCloseFile(pipePtr->writeFile) != 0) {
	    if (errorCode == 0) {
		errorCode = errno;
	    }
	}
	pipePtr->validMask &= ~TCL_WRITABLE;
	pipePtr->writeFile = NULL;
    }

    pipePtr->watchMask &= pipePtr->validMask;

    /*
     * Don't free the channel if any of the flags were set.
     */

    if (flags) {
	return errorCode;
    }

    /*
     * Remove the file from the list of watched files.
     */

    for (nextPtrPtr = &(tsdPtr->firstPipePtr), infoPtr = *nextPtrPtr;
	    infoPtr != NULL;
	    nextPtrPtr = &infoPtr->nextPtr, infoPtr = *nextPtrPtr) {
	if (infoPtr == (PipeInfo *)pipePtr) {
	    *nextPtrPtr = infoPtr->nextPtr;
	    break;
	}
    }

    /*
     * Wrap the error file into a channel and give it to the cleanup
     * routine.
     */

    if (pipePtr->errorFile) {
	WinFile *filePtr;

	filePtr = (WinFile*)pipePtr->errorFile;
	errChan = Tcl_MakeFileChannel((ClientData) filePtr->handle,
		TCL_READABLE);
	ckfree((char *) filePtr);
    } else {
        errChan = NULL;
    }

    result = TclCleanupChildren(interp, pipePtr->numPids, pipePtr->pidPtr,
            errChan);

    if (pipePtr->numPids > 0) {
        ckfree((char *) pipePtr->pidPtr);
    }

    if (pipePtr->writeBuf != NULL) {
	ckfree(pipePtr->writeBuf);
    }

    ckfree((char*) pipePtr);

    if (errorCode == 0) {
        return result;
    }
    return errorCode;
}

/*
 *----------------------------------------------------------------------
 *
 * PipeInputProc --
 *
 *	Reads input from the IO channel into the buffer given. Returns
 *	count of how many bytes were actually read, and an error indication.
 *
 * Results:
 *	A count of how many bytes were read is returned and an error
 *	indication is returned in an output argument.
 *
 * Side effects:
 *	Reads input from the actual channel.
 *
 *----------------------------------------------------------------------
 */

static int
PipeInputProc(
    ClientData instanceData,		/* Pipe state. */
    char *buf,				/* Where to store data read. */
    int bufSize,			/* How much space is available
                                         * in the buffer? */
    int *errorCode)			/* Where to store error code. */
{
    PipeInfo *infoPtr = (PipeInfo *) instanceData;
    WinFile *filePtr = (WinFile*) infoPtr->readFile;
    DWORD count, bytesRead = 0;
    int result;

    *errorCode = 0;
    /*
     * Synchronize with the reader thread.
     */

    result = WaitForRead(infoPtr, (infoPtr->flags & PIPE_ASYNC) ? 0 : 1);

    /*
     * If an error occurred, return immediately.
     */

    if (result == -1) {
	*errorCode = errno;
	return -1;
    }

    if (infoPtr->readFlags & PIPE_EXTRABYTE) {
	/*
	 * The reader thread consumed 1 byte as a side effect of
	 * waiting so we need to move it into the buffer.
	 */

	*buf = infoPtr->extraByte;
	infoPtr->readFlags &= ~PIPE_EXTRABYTE;
	buf++;
	bufSize--;
	bytesRead = 1;

	/*
	 * If further read attempts would block, return what we have.
	 */

	if (result == 0) {
	    return bytesRead;
	}
    }

    /*
     * Attempt to read bufSize bytes.  The read will return immediately
     * if there is any data available.  Otherwise it will block until
     * at least one byte is available or an EOF occurs.
     */

    if (ReadFile(filePtr->handle, (LPVOID) buf, (DWORD) bufSize, &count,
	    (LPOVERLAPPED) NULL) == TRUE) {
	return bytesRead + count;
    } else if (bytesRead) {
	/*
	 * Ignore errors if we have data to return.
	 */

	return bytesRead;
    }

    TclWinConvertError(GetLastError());
    if (errno == EPIPE) {
	infoPtr->readFlags |= PIPE_EOF;
	return 0;
    }
    *errorCode = errno;
    return -1;
}

/*
 *----------------------------------------------------------------------
 *
 * PipeOutputProc --
 *
 *	Writes the given output on the IO channel. Returns count of how
 *	many characters were actually written, and an error indication.
 *
 * Results:
 *	A count of how many characters were written is returned and an
 *	error indication is returned in an output argument.
 *
 * Side effects:
 *	Writes output on the actual channel.
 *
 *----------------------------------------------------------------------
 */

static int
PipeOutputProc(
    ClientData instanceData,		/* Pipe state. */
    CONST char *buf,			/* The data buffer. */
    int toWrite,			/* How many bytes to write? */
    int *errorCode)			/* Where to store error code. */
{
    PipeInfo *infoPtr = (PipeInfo *) instanceData;
    WinFile *filePtr = (WinFile*) infoPtr->writeFile;
    DWORD bytesWritten, timeout;
    
    *errorCode = 0;
    timeout = (infoPtr->flags & PIPE_ASYNC) ? 0 : INFINITE;
    if (WaitForSingleObject(infoPtr->writable, timeout) == WAIT_TIMEOUT) {
	/*
	 * The writer thread is blocked waiting for a write to complete
	 * and the channel is in non-blocking mode.
	 */

	errno = EAGAIN;
	goto error;
    }
    
    /*
     * Check for a background error on the last write.
     */

    if (infoPtr->writeError) {
	TclWinConvertError(infoPtr->writeError);
	infoPtr->writeError = 0;
	goto error;
    }

    if (infoPtr->flags & PIPE_ASYNC) {
	/*
	 * The pipe is non-blocking, so copy the data into the output
	 * buffer and restart the writer thread.
	 */

	if (toWrite > infoPtr->writeBufLen) {
	    /*
	     * Reallocate the buffer to be large enough to hold the data.
	     */

	    if (infoPtr->writeBuf) {
		ckfree(infoPtr->writeBuf);
	    }
	    infoPtr->writeBufLen = toWrite;
	    infoPtr->writeBuf = ckalloc((unsigned int) toWrite);
	}
	memcpy(infoPtr->writeBuf, buf, (size_t) toWrite);
	infoPtr->toWrite = toWrite;
	ResetEvent(infoPtr->writable);
	SetEvent(infoPtr->startWriter);
	bytesWritten = toWrite;
    } else {
	/*
	 * In the blocking case, just try to write the buffer directly.
	 * This avoids an unnecessary copy.
	 */

	if (WriteFile(filePtr->handle, (LPVOID) buf, (DWORD) toWrite,
		&bytesWritten, (LPOVERLAPPED) NULL) == FALSE) {
	    TclWinConvertError(GetLastError());
	    goto error;
	}
    }
    return bytesWritten;

    error:
    *errorCode = errno;
    return -1;

}

/*
 *----------------------------------------------------------------------
 *
 * PipeEventProc --
 *
 *	This function is invoked by Tcl_ServiceEvent when a file event
 *	reaches the front of the event queue.  This procedure invokes
 *	Tcl_NotifyChannel on the pipe.
 *
 * Results:
 *	Returns 1 if the event was handled, meaning it should be removed
 *	from the queue.  Returns 0 if the event was not handled, meaning
 *	it should stay on the queue.  The only time the event isn't
 *	handled is if the TCL_FILE_EVENTS flag bit isn't set.
 *
 * Side effects:
 *	Whatever the notifier callback does.
 *
 *----------------------------------------------------------------------
 */

static int
PipeEventProc(
    Tcl_Event *evPtr,		/* Event to service. */
    int flags)			/* Flags that indicate what events to
				 * handle, such as TCL_FILE_EVENTS. */
{
    PipeEvent *pipeEvPtr = (PipeEvent *)evPtr;
    PipeInfo *infoPtr;
    WinFile *filePtr;
    int mask;
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    if (!(flags & TCL_FILE_EVENTS)) {
	return 0;
    }

    /*
     * Search through the list of watched pipes for the one whose handle
     * matches the event.  We do this rather than simply dereferencing
     * the handle in the event so that pipes can be deleted while the
     * event is in the queue.
     */

    for (infoPtr = tsdPtr->firstPipePtr; infoPtr != NULL;
	    infoPtr = infoPtr->nextPtr) {
	if (pipeEvPtr->infoPtr == infoPtr) {
	    infoPtr->flags &= ~(PIPE_PENDING);
	    break;
	}
    }

    /*
     * Remove stale events.
     */

    if (!infoPtr) {
	return 1;
    }

    /*
     * Check to see if the pipe is readable.  Note
     * that we can't tell if a pipe is writable, so we always report it
     * as being writable unless we have detected EOF.
     */

    filePtr = (WinFile*) ((PipeInfo*)infoPtr)->writeFile;
    mask = 0;
    if ((infoPtr->watchMask & TCL_WRITABLE) &&
	    (WaitForSingleObject(infoPtr->writable, 0) != WAIT_TIMEOUT)) {
	mask = TCL_WRITABLE;
    }

    filePtr = (WinFile*) ((PipeInfo*)infoPtr)->readFile;
    if ((infoPtr->watchMask & TCL_READABLE) &&
	    (WaitForRead(infoPtr, 0) >= 0)) {
	if (infoPtr->readFlags & PIPE_EOF) {
	    mask = TCL_READABLE;
	} else {
	    mask |= TCL_READABLE;
	}
    }

    /*
     * Inform the channel of the events.
     */

    Tcl_NotifyChannel(infoPtr->channel, infoPtr->watchMask & mask);
    return 1;
}

/*
 *----------------------------------------------------------------------
 *
 * PipeWatchProc --
 *
 *	Called by the notifier to set up to watch for events on this
 *	channel.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static void
PipeWatchProc(
    ClientData instanceData,		/* Pipe state. */
    int mask)				/* What events to watch for, OR-ed
                                         * combination of TCL_READABLE,
                                         * TCL_WRITABLE and TCL_EXCEPTION. */
{
    PipeInfo **nextPtrPtr, *ptr;
    PipeInfo *infoPtr = (PipeInfo *) instanceData;
    int oldMask = infoPtr->watchMask;
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    /*
     * Since most of the work is handled by the background threads,
     * we just need to update the watchMask and then force the notifier
     * to poll once. 
     */

    infoPtr->watchMask = mask & infoPtr->validMask;
    if (infoPtr->watchMask) {
	Tcl_Time blockTime = { 0, 0 };
	if (!oldMask) {
	    infoPtr->nextPtr = tsdPtr->firstPipePtr;
	    tsdPtr->firstPipePtr = infoPtr;
	}
	Tcl_SetMaxBlockTime(&blockTime);
    } else {
	if (oldMask) {
	    /*
	     * Remove the pipe from the list of watched pipes.
	     */

	    for (nextPtrPtr = &(tsdPtr->firstPipePtr), ptr = *nextPtrPtr;
		 ptr != NULL;
		 nextPtrPtr = &ptr->nextPtr, ptr = *nextPtrPtr) {
		if (infoPtr == ptr) {
		    *nextPtrPtr = ptr->nextPtr;
		    break;
		}
	    }
	}
    }
}

/*
 *----------------------------------------------------------------------
 *
 * PipeGetHandleProc --
 *
 *	Called from Tcl_GetChannelHandle to retrieve OS handles from
 *	inside a command pipeline based channel.
 *
 * Results:
 *	Returns TCL_OK with the fd in handlePtr, or TCL_ERROR if
 *	there is no handle for the specified direction. 
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static int
PipeGetHandleProc(
    ClientData instanceData,	/* The pipe state. */
    int direction,		/* TCL_READABLE or TCL_WRITABLE */
    ClientData *handlePtr)	/* Where to store the handle.  */
{
    PipeInfo *infoPtr = (PipeInfo *) instanceData;
    WinFile *filePtr; 

    if (direction == TCL_READABLE && infoPtr->readFile) {
	filePtr = (WinFile*) infoPtr->readFile;
	*handlePtr = (ClientData) filePtr->handle;
	return TCL_OK;
    }
    if (direction == TCL_WRITABLE && infoPtr->writeFile) {
	filePtr = (WinFile*) infoPtr->writeFile;
	*handlePtr = (ClientData) filePtr->handle;
	return TCL_OK;
    }
    return TCL_ERROR;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_WaitPid --
 *
 *	Emulates the waitpid system call.
 *
 * Results:
 *	Returns 0 if the process is still alive, -1 on an error, or
 *	the pid on a clean close.  
 *
 * Side effects:
 *	Unless WNOHANG is set and the wait times out, the process
 *	information record will be deleted and the process handle
 *	will be closed.
 *
 *----------------------------------------------------------------------
 */

Tcl_Pid
Tcl_WaitPid(
    Tcl_Pid pid,
    int *statPtr,
    int options)
{
    ProcInfo *infoPtr, **prevPtrPtr;
    DWORD flags;
    Tcl_Pid result;
    DWORD ret;

    PipeInit();

    /*
     * If no pid is specified, do nothing.
     */
    
    if (pid == 0) {
	*statPtr = 0;
	return 0;
    }

    /*
     * Find the process on the process list.
     */

    Tcl_MutexLock(&pipeMutex);
    prevPtrPtr = &procList;
    for (infoPtr = procList; infoPtr != NULL;
	    prevPtrPtr = &infoPtr->nextPtr, infoPtr = infoPtr->nextPtr) {
	 if (infoPtr->hProcess == (HANDLE) pid) {
	    break;
	}
    }
    Tcl_MutexUnlock(&pipeMutex);

    /*
     * If the pid is not one of the processes we know about (we started it)
     * then do nothing.
     */
    		     
    if (infoPtr == NULL) {
        *statPtr = 0;
	return 0;
    }

    /*
     * Officially "wait" for it to finish. We either poll (WNOHANG) or
     * wait for an infinite amount of time.
     */
    
    if (options & WNOHANG) {
	flags = 0;
    } else {
	flags = INFINITE;
    }
    ret = WaitForSingleObject(infoPtr->hProcess, flags);
    if (ret == WAIT_TIMEOUT) {
	*statPtr = 0;
	if (options & WNOHANG) {
	    return 0;
	} else {
	    result = 0;
	}
    } else if (ret != WAIT_FAILED) {
	GetExitCodeProcess(infoPtr->hProcess, (DWORD*)statPtr);
	*statPtr = ((*statPtr << 8) & 0xff00);
	result = pid;
    } else {
	errno = ECHILD;
        *statPtr = ECHILD;
	result = (Tcl_Pid) -1;
    }

    /*
     * Remove the process from the process list and close the process handle.
     */

    CloseHandle(infoPtr->hProcess);
    *prevPtrPtr = infoPtr->nextPtr;
    ckfree((char*)infoPtr);

    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * TclWinAddProcess --
 *
 *     Add a process to the process list so that we can use
 *     Tcl_WaitPid on the process.
 *
 * Results:
 *     None
 *
 * Side effects:
 *	Adds the specified process handle to the process list so
 *	Tcl_WaitPid knows about it.
 *
 *----------------------------------------------------------------------
 */

void
TclWinAddProcess(hProcess, id)
    HANDLE hProcess;           /* Handle to process */
    DWORD id;                  /* Global process identifier */
{
    ProcInfo *procPtr = (ProcInfo *) ckalloc(sizeof(ProcInfo));
    procPtr->hProcess = hProcess;
    procPtr->dwProcessId = id;
    Tcl_MutexLock(&pipeMutex);
    procPtr->nextPtr = procList;
    procList = procPtr;
    Tcl_MutexUnlock(&pipeMutex);
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_PidObjCmd --
 *
 *	This procedure is invoked to process the "pid" Tcl command.
 *	See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
int
Tcl_PidObjCmd(
    ClientData dummy,		/* Not used. */
    Tcl_Interp *interp,		/* Current interpreter. */
    int objc,			/* Number of arguments. */
    Tcl_Obj *CONST *objv)	/* Argument strings. */
{
    Tcl_Channel chan;
    Tcl_ChannelType *chanTypePtr;
    PipeInfo *pipePtr;
    int i;
    Tcl_Obj *resultPtr;
    char buf[TCL_INTEGER_SPACE];

    if (objc > 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "?channelId?");
	return TCL_ERROR;
    }
    if (objc == 1) {
	resultPtr = Tcl_GetObjResult(interp);
	wsprintfA(buf, "%lu", (unsigned long) getpid());
	Tcl_SetStringObj(resultPtr, buf, -1);
    } else {
        chan = Tcl_GetChannel(interp, Tcl_GetStringFromObj(objv[1], NULL),
		NULL);
        if (chan == (Tcl_Channel) NULL) {
	    return TCL_ERROR;
	}
	chanTypePtr = Tcl_GetChannelType(chan);
	if (chanTypePtr != &pipeChannelType) {
	    return TCL_OK;
	}

        pipePtr = (PipeInfo *) Tcl_GetChannelInstanceData(chan);
	resultPtr = Tcl_GetObjResult(interp);
        for (i = 0; i < pipePtr->numPids; i++) {
	    wsprintfA(buf, "%lu", TclpGetPid(pipePtr->pidPtr[i]));
	    Tcl_ListObjAppendElement(/*interp*/ NULL, resultPtr,
		    Tcl_NewStringObj(buf, -1));
	}
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * WaitForRead --
 *
 *	Wait until some data is available, the pipe is at
 *	EOF or the reader thread is blocked waiting for data (if the
 *	channel is in non-blocking mode).
 *
 * Results:
 *	Returns 1 if pipe is readable.  Returns 0 if there is no data
 *	on the pipe, but there is buffered data.  Returns -1 if an
 *	error occurred.  If an error occurred, the threads may not
 *	be synchronized.
 *
 * Side effects:
 *	Updates the shared state flags and may consume 1 byte of data
 *	from the pipe.  If no error occurred, the reader thread is
 *	blocked waiting for a signal from the main thread.
 *
 *----------------------------------------------------------------------
 */

static int
WaitForRead(
    PipeInfo *infoPtr,		/* Pipe state. */
    int blocking)		/* Indicates whether call should be
				 * blocking or not. */
{
    DWORD timeout, count;
    HANDLE *handle = ((WinFile *) infoPtr->readFile)->handle;

    while (1) {
	/*
	 * Synchronize with the reader thread.
	 */
       
	timeout = blocking ? INFINITE : 0;
	if (WaitForSingleObject(infoPtr->readable, timeout) == WAIT_TIMEOUT) {
	    /*
	     * The reader thread is blocked waiting for data and the channel
	     * is in non-blocking mode.
	     */

	    errno = EAGAIN;
	    return -1;
	}

	/*
	 * At this point, the two threads are synchronized, so it is safe
	 * to access shared state.
	 */


	/*
	 * If the pipe has hit EOF, it is always readable.
	 */

	if (infoPtr->readFlags & PIPE_EOF) {
	    return 1;
	}
    
	/*
	 * Check to see if there is any data sitting in the pipe.
	 */

	if (PeekNamedPipe(handle, (LPVOID) NULL, (DWORD) 0,
		(LPDWORD) NULL, &count, (LPDWORD) NULL) != TRUE) {
	    TclWinConvertError(GetLastError());
	    /*
	     * Check to see if the peek failed because of EOF.
	     */

	    if (errno == EPIPE) {
		infoPtr->readFlags |= PIPE_EOF;
		return 1;
	    }

	    /*
	     * Ignore errors if there is data in the buffer.
	     */

	    if (infoPtr->readFlags & PIPE_EXTRABYTE) {
		return 0;
	    } else {
		return -1;
	    }
	}

	/*
	 * We found some data in the pipe, so it must be readable.
	 */

	if (count > 0) {
	    return 1;
	}

	/*
	 * The pipe isn't readable, but there is some data sitting
	 * in the buffer, so return immediately.
	 */

	if (infoPtr->readFlags & PIPE_EXTRABYTE) {
	    return 0;
	}

	/*
	 * There wasn't any data available, so reset the thread and
	 * try again.
	 */
    
	ResetEvent(infoPtr->readable);
	SetEvent(infoPtr->startReader);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * PipeReaderThread --
 *
 *	This function runs in a separate thread and waits for input
 *	to become available on a pipe.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Signals the main thread when input become available.  May
 *	cause the main thread to wake up by posting a message.  May
 *	consume one byte from the pipe for each wait operation.  Will
 *	cause a memory leak of ~4k, if forcefully terminated with
 *	TerminateThread().
 *
 *----------------------------------------------------------------------
 */

static DWORD WINAPI
PipeReaderThread(LPVOID arg)
{
    PipeInfo *infoPtr = (PipeInfo *)arg;
    HANDLE *handle = ((WinFile *) infoPtr->readFile)->handle;
    DWORD count, err;
    int done = 0;
    HANDLE wEvents[2];
    DWORD dwWait;

    wEvents[0] = infoPtr->stopReader;
    wEvents[1] = infoPtr->startReader;

    while (!done) {
	/*
	 * Wait for the main thread to signal before attempting to wait
	 * on the pipe becoming readable.
	 */

	dwWait = WaitForMultipleObjects(2, wEvents, FALSE, INFINITE);

	if (dwWait != (WAIT_OBJECT_0 + 1)) {
	    /*
	     * The start event was not signaled.  It might be the stop event
	     * or an error, so exit.
	     */

	    return 0;
	}

	/*
	 * Try waiting for 0 bytes.  This will block until some data is
	 * available on NT, but will return immediately on Win 95.  So,
	 * if no data is available after the first read, we block until
	 * we can read a single byte off of the pipe.
	 */

	if ((ReadFile(handle, NULL, 0, &count, NULL) == FALSE)
		|| (PeekNamedPipe(handle, NULL, 0, NULL, &count,
			NULL) == FALSE)) {
	    /*
	     * The error is a result of an EOF condition, so set the
	     * EOF bit before signalling the main thread.
	     */

	    err = GetLastError();
	    if (err == ERROR_BROKEN_PIPE) {
		infoPtr->readFlags |= PIPE_EOF;
		done = 1;
	    } else if (err == ERROR_INVALID_HANDLE) {
		break;
	    }
	} else if (count == 0) {
	    if (ReadFile(handle, &(infoPtr->extraByte), 1, &count, NULL)
		    != FALSE) {
		/*
		 * One byte was consumed as a side effect of waiting
		 * for the pipe to become readable.
		 */

		infoPtr->readFlags |= PIPE_EXTRABYTE;
	    } else {
		err = GetLastError();
		if (err == ERROR_BROKEN_PIPE) {
		    /*
		     * The error is a result of an EOF condition, so set the
		     * EOF bit before signalling the main thread.
		     */

		    infoPtr->readFlags |= PIPE_EOF;
		    done = 1;
		} else if (err == ERROR_INVALID_HANDLE) {
		    break;
		}
	    }
	}

		
	/*
	 * Signal the main thread by signalling the readable event and
	 * then waking up the notifier thread.
	 */

	SetEvent(infoPtr->readable);
	
	/*
	 * Alert the foreground thread.  Note that we need to treat this like
	 * a critical section so the foreground thread does not terminate
	 * this thread while we are holding a mutex in the notifier code.
	 */

	Tcl_MutexLock(&pipeMutex);
	Tcl_ThreadAlert(infoPtr->threadId);
	Tcl_MutexUnlock(&pipeMutex);
    }
    return 0;
}

/*
 *----------------------------------------------------------------------
 *
 * PipeWriterThread --
 *
 *	This function runs in a separate thread and writes data
 *	onto a pipe.
 *
 * Results:
 *	Always returns 0.
 *
 * Side effects:
 *	Signals the main thread when an output operation is completed.
 *	May cause the main thread to wake up by posting a message.  
 *
 *----------------------------------------------------------------------
 */

static DWORD WINAPI
PipeWriterThread(LPVOID arg)
{

    PipeInfo *infoPtr = (PipeInfo *)arg;
    HANDLE *handle = ((WinFile *) infoPtr->writeFile)->handle;
    DWORD count, toWrite;
    char *buf;
    int done = 0;

    while (!done) {
	/*
	 * Wait for the main thread to signal before attempting to write.
	 */

	WaitForSingleObject(infoPtr->startWriter, INFINITE);

	buf = infoPtr->writeBuf;
	toWrite = infoPtr->toWrite;

	/*
	 * Loop until all of the bytes are written or an error occurs.
	 */

	while (toWrite > 0) {
	    if (WriteFile(handle, buf, toWrite, &count, NULL) == FALSE) {
		infoPtr->writeError = GetLastError();
		done = 1; 
		break;
	    } else {
		toWrite -= count;
		buf += count;
	    }
	}
	
	/*
	 * Signal the main thread by signalling the writable event and
	 * then waking up the notifier thread.
	 */

	SetEvent(infoPtr->writable);

	/*
	 * Alert the foreground thread.  Note that we need to treat this like
	 * a critical section so the foreground thread does not terminate
	 * this thread while we are holding a mutex in the notifier code.
	 */

	Tcl_MutexLock(&pipeMutex);
	Tcl_ThreadAlert(infoPtr->threadId);
	Tcl_MutexUnlock(&pipeMutex);
    }
    return 0;
}

@


1.8
log
@* win/tclWinPipe.c (TclpCreateProcess): Call cygwin-specific routine to set up
windows environment.
@
text
@d1231 3
a1233 1
#ifdef __CYGWIN__
@


1.7
log
@Updated to tcl 8.4.1
@
text
@d20 3
d1231 4
@


1.7.40.1
log
@update to HEAD
@
text
@a19 3
#ifdef __CYGWIN__
#include <sys/cygwin.h>
#endif
a1227 4
#ifdef __CYGWIN__
    cygwin_internal (CW_SYNC_WINENV);
#endif

@


1.6
log
@touched all sources to ease next import
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tclWinPipe.c,v 1.6.8.4 2001/07/16 23:51:56 mdejong Exp $
a16 6
/* CYGNUS LOCAL */
#ifndef __CYGWIN__
#include <dos.h>
#endif
/* END CYGNUS LOCAL */

d126 2
d183 1
a183 1
			    char **argv, Tcl_DString *linePtr);
d196 2
a197 2
static int		PipeOutputProc(ClientData instanceData, char *buf,
			    int toWrite, int *errorCode);
d581 1
a581 1
    TCHAR *nativePath;
d770 28
d865 2
a866 1
		if (CloseHandle(filePtr->handle) == FALSE) {
d952 1
a952 1
    char **argv,		/* Array of argument strings.  argv[0]
d1230 1
a1230 1
	    createFlags, NULL, NULL, &startInfo, &procInfo) == 0) {
d1363 1
a1363 1
    TCHAR *nativeName;
d1434 1
a1434 1
	    if ((ext != NULL) && (strcmp(ext, ".com") == 0)) {
d1527 1
a1527 1
    char **argv,		/* Argument strings in UTF. */
d1552 1
a1552 1
	if (argv[i][0] == '\0') {
d1555 1
a1555 1
	    for (start = argv[i]; *start != '\0'; start++) {
d1595 5
d1610 1
d1687 2
a1688 1
	infoPtr->readThread = CreateThread(NULL, 8000, PipeReaderThread,
d1697 1
a1697 1
	 * Start the background writeer thwrite.
d1702 1
a1702 1
	infoPtr->writeThread = CreateThread(NULL, 8000, PipeWriterThread,
d1847 1
d1860 2
a1861 7
	     * Forcibly terminate the background thread.  We cannot rely on the
	     * thread to cleanly terminate itself because we have no way of
	     * closing the pipe handle without blocking in the case where the
	     * thread is in the middle of an I/O operation.  Note that we need
	     * to guard against terminating the thread while it is in the
	     * middle of Tcl_ThreadAlert because it won't be able to release
	     * the notifier lock.
d1864 37
a1900 2
	    Tcl_MutexLock(&pipeMutex);
	    TerminateThread(pipePtr->readThread, 0);
d1902 2
a1903 4
	    /*
	     * Wait for the thread to terminate.  This ensures that we are
	     * completely cleaned up before we leave this function. 
	     */
d1905 3
a1907 2
	    WaitForSingleObject(pipePtr->readThread, INFINITE);
	    Tcl_MutexUnlock(&pipeMutex);
d1912 1
d2141 1
a2141 1
    char *buf,				/* The data buffer. */
d2186 1
a2186 1
	    infoPtr->writeBuf = ckalloc(toWrite);
d2188 1
a2188 1
	memcpy(infoPtr->writeBuf, buf, toWrite);
d2431 1
a2431 1
    int flags;
a2489 10
#ifdef __OLD_CYGWIN__
	/* A cygwin program that exits because of a signal will set
           the exit status to 0x10000 | (sig << 8).  Fix that back
           into a standard Unix wait status.  */
       if ((*statPtr & 0x10000) != 0
           && (*statPtr & 0xff00) != 0
           && (*statPtr & ~ 0x1ff00) == 0) {
           *statPtr = (*statPtr >> 8) & 0xff;
       } else
#endif
d2733 3
a2735 1
 *	consume one byte from the pipe for each wait operation.
d2747 5
d2755 2
a2756 1
	 * Wait for the main thread to signal before attempting to wait.
d2759 10
a2768 1
	WaitForSingleObject(infoPtr->startReader, INFINITE);
a2909 3



@


1.5
log
@touched all sources to ease next import
@
text
@@


1.5.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tclWinPipe.c,v 1.25 2002/06/17 20:05:49 andreas_kupries Exp $
d17 6
a131 2
    HANDLE stopReader;		/* Manual-reset event used to alert the reader
				 * thread to fall-out and exit */
d187 1
a187 1
			    CONST char **argv, Tcl_DString *linePtr);
d200 2
a201 2
static int		PipeOutputProc(ClientData instanceData,
			    CONST char *buf, int toWrite, int *errorCode);
d585 1
a585 1
    CONST TCHAR *nativePath;
a773 28
 * TclpTempFileName --
 *
 *	This function returns a unique filename.
 *
 * Results:
 *	Returns a valid Tcl_Obj* with refCount 0, or NULL on failure.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_Obj* 
TclpTempFileName()
{
    WCHAR fileName[MAX_PATH];

    if (TempFileName(fileName) == 0) {
	return NULL;
    }

    return TclpNativeToNormalized((ClientData) fileName);
}

/*
 *----------------------------------------------------------------------
 *
d841 1
a841 2
		if (filePtr->handle != NULL &&
			CloseHandle(filePtr->handle) == FALSE) {
d927 1
a927 1
    CONST char **argv,		/* Array of argument strings.  argv[0]
d1205 1
a1205 1
	    (DWORD) createFlags, NULL, NULL, &startInfo, &procInfo) == 0) {
d1338 1
a1338 1
    CONST TCHAR *nativeName;
d1409 1
a1409 1
	    if ((ext != NULL) && (stricmp(ext, ".com") == 0)) {
d1502 1
a1502 1
    CONST char **argv,		/* Argument strings in UTF. */
d1527 1
a1527 1
	if (arg[0] == '\0') {
d1530 1
a1530 1
	    for (start = arg; *start != '\0'; start++) {
a1569 5
	    if (*special == '{') {
		Tcl_DStringAppend(&ds, start, special - start);
		Tcl_DStringAppend(&ds, "\\{", 2);
		start = special + 1;
	    }
a1579 1
    Tcl_DStringFree(linePtr);
d1656 1
a1656 2
	infoPtr->stopReader = CreateEvent(NULL, TRUE, FALSE, NULL);
	infoPtr->readThread = CreateThread(NULL, 512, PipeReaderThread,
d1665 1
a1665 1
	 * Start the background writer thread.
d1670 1
a1670 1
	infoPtr->writeThread = CreateThread(NULL, 512, PipeWriterThread,
a1814 1
    DWORD exitCode;
d1827 7
a1833 2
	     * The thread may already have closed on it's own.  Check it's
	     * exit code.
d1836 2
a1837 1
	    GetExitCodeThread(pipePtr->readThread, &exitCode);
d1839 4
a1842 6
	    if (exitCode == STILL_ACTIVE) {
		/*
		 * Set the stop event so that if the reader thread is blocked
		 * in PipeReaderThread on WaitForMultipleEvents, it will exit
		 * cleanly.
		 */
d1844 2
a1845 35
		SetEvent(pipePtr->stopReader);

		/*
		 * Wait at most 10 milliseconds for the reader thread to close.
		 */

		WaitForSingleObject(pipePtr->readThread, 10);
		GetExitCodeThread(pipePtr->readThread, &exitCode);

		if (exitCode == STILL_ACTIVE) {
		    /*
		     * The thread must be blocked waiting for the pipe to
		     * become readable in ReadFile().  There isn't a clean way
		     * to exit the thread from this condition.  We should
		     * terminate the child process instead to get the reader
		     * thread to fall out of ReadFile with a FALSE.  (below) is
		     * not the correct way to do this, but will stay here until
		     * a better solution is found.
		     *
		     * Note that we need to guard against terminating the
		     * thread while it is in the middle of Tcl_ThreadAlert
		     * because it won't be able to release the notifier lock.
		     */

		    Tcl_MutexLock(&pipeMutex);

		    /* BUG: this leaks memory */
		    TerminateThread(pipePtr->readThread, 0);

		    /* Wait for the thread to terminate. */
		    WaitForSingleObject(pipePtr->readThread, INFINITE);

		    Tcl_MutexUnlock(&pipeMutex);
		}
	    }
a1849 1
	    CloseHandle(pipePtr->stopReader);
d2078 1
a2078 1
    CONST char *buf,			/* The data buffer. */
d2123 1
a2123 1
	    infoPtr->writeBuf = ckalloc((unsigned int) toWrite);
d2125 1
a2125 1
	memcpy(infoPtr->writeBuf, buf, (size_t) toWrite);
d2368 1
a2368 1
    DWORD flags;
d2427 10
d2680 1
a2680 3
 *	consume one byte from the pipe for each wait operation.  Will
 *	cause a memory leak of ~4k, if forcefully terminated with
 *	TerminateThread().
a2691 5
    HANDLE wEvents[2];
    DWORD dwWait;

    wEvents[0] = infoPtr->stopReader;
    wEvents[1] = infoPtr->startReader;
d2695 1
a2695 2
	 * Wait for the main thread to signal before attempting to wait
	 * on the pipe becoming readable.
d2698 1
a2698 10
	dwWait = WaitForMultipleObjects(2, wEvents, FALSE, INFINITE);

	if (dwWait != (WAIT_OBJECT_0 + 1)) {
	    /*
	     * The start event was not signaled.  It might be the stop event
	     * or an error, so exit.
	     */

	    return 0;
	}
d2840 3
@


1.5.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tclWinPipe.c,v 1.25 2002/06/17 20:05:49 andreas_kupries Exp $
d17 6
a131 2
    HANDLE stopReader;		/* Manual-reset event used to alert the reader
				 * thread to fall-out and exit */
d187 1
a187 1
			    CONST char **argv, Tcl_DString *linePtr);
d200 2
a201 2
static int		PipeOutputProc(ClientData instanceData,
			    CONST char *buf, int toWrite, int *errorCode);
d585 1
a585 1
    CONST TCHAR *nativePath;
a773 28
 * TclpTempFileName --
 *
 *	This function returns a unique filename.
 *
 * Results:
 *	Returns a valid Tcl_Obj* with refCount 0, or NULL on failure.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_Obj* 
TclpTempFileName()
{
    WCHAR fileName[MAX_PATH];

    if (TempFileName(fileName) == 0) {
	return NULL;
    }

    return TclpNativeToNormalized((ClientData) fileName);
}

/*
 *----------------------------------------------------------------------
 *
d841 1
a841 2
		if (filePtr->handle != NULL &&
			CloseHandle(filePtr->handle) == FALSE) {
d927 1
a927 1
    CONST char **argv,		/* Array of argument strings.  argv[0]
d1205 1
a1205 1
	    (DWORD) createFlags, NULL, NULL, &startInfo, &procInfo) == 0) {
d1338 1
a1338 1
    CONST TCHAR *nativeName;
d1409 1
a1409 1
	    if ((ext != NULL) && (stricmp(ext, ".com") == 0)) {
d1502 1
a1502 1
    CONST char **argv,		/* Argument strings in UTF. */
d1527 1
a1527 1
	if (arg[0] == '\0') {
d1530 1
a1530 1
	    for (start = arg; *start != '\0'; start++) {
a1569 5
	    if (*special == '{') {
		Tcl_DStringAppend(&ds, start, special - start);
		Tcl_DStringAppend(&ds, "\\{", 2);
		start = special + 1;
	    }
a1579 1
    Tcl_DStringFree(linePtr);
d1656 1
a1656 2
	infoPtr->stopReader = CreateEvent(NULL, TRUE, FALSE, NULL);
	infoPtr->readThread = CreateThread(NULL, 512, PipeReaderThread,
d1665 1
a1665 1
	 * Start the background writer thread.
d1670 1
a1670 1
	infoPtr->writeThread = CreateThread(NULL, 512, PipeWriterThread,
a1814 1
    DWORD exitCode;
d1827 7
a1833 2
	     * The thread may already have closed on it's own.  Check it's
	     * exit code.
d1836 2
a1837 1
	    GetExitCodeThread(pipePtr->readThread, &exitCode);
d1839 4
a1842 6
	    if (exitCode == STILL_ACTIVE) {
		/*
		 * Set the stop event so that if the reader thread is blocked
		 * in PipeReaderThread on WaitForMultipleEvents, it will exit
		 * cleanly.
		 */
d1844 2
a1845 35
		SetEvent(pipePtr->stopReader);

		/*
		 * Wait at most 10 milliseconds for the reader thread to close.
		 */

		WaitForSingleObject(pipePtr->readThread, 10);
		GetExitCodeThread(pipePtr->readThread, &exitCode);

		if (exitCode == STILL_ACTIVE) {
		    /*
		     * The thread must be blocked waiting for the pipe to
		     * become readable in ReadFile().  There isn't a clean way
		     * to exit the thread from this condition.  We should
		     * terminate the child process instead to get the reader
		     * thread to fall out of ReadFile with a FALSE.  (below) is
		     * not the correct way to do this, but will stay here until
		     * a better solution is found.
		     *
		     * Note that we need to guard against terminating the
		     * thread while it is in the middle of Tcl_ThreadAlert
		     * because it won't be able to release the notifier lock.
		     */

		    Tcl_MutexLock(&pipeMutex);

		    /* BUG: this leaks memory */
		    TerminateThread(pipePtr->readThread, 0);

		    /* Wait for the thread to terminate. */
		    WaitForSingleObject(pipePtr->readThread, INFINITE);

		    Tcl_MutexUnlock(&pipeMutex);
		}
	    }
a1849 1
	    CloseHandle(pipePtr->stopReader);
d2078 1
a2078 1
    CONST char *buf,			/* The data buffer. */
d2123 1
a2123 1
	    infoPtr->writeBuf = ckalloc((unsigned int) toWrite);
d2125 1
a2125 1
	memcpy(infoPtr->writeBuf, buf, (size_t) toWrite);
d2368 1
a2368 1
    DWORD flags;
d2427 10
d2680 1
a2680 3
 *	consume one byte from the pipe for each wait operation.  Will
 *	cause a memory leak of ~4k, if forcefully terminated with
 *	TerminateThread().
a2691 5
    HANDLE wEvents[2];
    DWORD dwWait;

    wEvents[0] = infoPtr->stopReader;
    wEvents[1] = infoPtr->startReader;
d2695 1
a2695 2
	 * Wait for the main thread to signal before attempting to wait
	 * on the pipe becoming readable.
d2698 1
a2698 10
	dwWait = WaitForMultipleObjects(2, wEvents, FALSE, INFINITE);

	if (dwWait != (WAIT_OBJECT_0 + 1)) {
	    /*
	     * The start event was not signaled.  It might be the stop event
	     * or an error, so exit.
	     */

	    return 0;
	}
d2840 3
@


1.4
log
@touched all Tcl files to ease next import.
@
text
@@


1.4.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.4.16.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d17 6
a131 2
    HANDLE stopReader;		/* Manual-reset event used to alert the reader
				 * thread to fall-out and exit */
d187 1
a187 1
			    CONST char **argv, Tcl_DString *linePtr);
d200 2
a201 2
static int		PipeOutputProc(ClientData instanceData,
			    CONST char *buf, int toWrite, int *errorCode);
d585 1
a585 1
    CONST TCHAR *nativePath;
a773 28
 * TclpTempFileName --
 *
 *	This function returns a unique filename.
 *
 * Results:
 *	Returns a valid Tcl_Obj* with refCount 0, or NULL on failure.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_Obj* 
TclpTempFileName()
{
    WCHAR fileName[MAX_PATH];

    if (TempFileName(fileName) == 0) {
	return NULL;
    }

    return TclpNativeToNormalized((ClientData) fileName);
}

/*
 *----------------------------------------------------------------------
 *
d841 1
a841 2
		if (filePtr->handle != NULL &&
			CloseHandle(filePtr->handle) == FALSE) {
d927 1
a927 1
    CONST char **argv,		/* Array of argument strings.  argv[0]
d1205 1
a1205 1
	    (DWORD) createFlags, NULL, NULL, &startInfo, &procInfo) == 0) {
d1338 1
a1338 1
    CONST TCHAR *nativeName;
d1409 1
a1409 1
	    if ((ext != NULL) && (stricmp(ext, ".com") == 0)) {
d1502 1
a1502 1
    CONST char **argv,		/* Argument strings in UTF. */
d1527 1
a1527 1
	if (arg[0] == '\0') {
d1530 1
a1530 1
	    for (start = arg; *start != '\0'; start++) {
a1569 5
	    if (*special == '{') {
		Tcl_DStringAppend(&ds, start, special - start);
		Tcl_DStringAppend(&ds, "\\{", 2);
		start = special + 1;
	    }
a1579 1
    Tcl_DStringFree(linePtr);
d1656 1
a1656 2
	infoPtr->stopReader = CreateEvent(NULL, TRUE, FALSE, NULL);
	infoPtr->readThread = CreateThread(NULL, 512, PipeReaderThread,
d1665 1
a1665 1
	 * Start the background writer thread.
d1670 1
a1670 1
	infoPtr->writeThread = CreateThread(NULL, 512, PipeWriterThread,
a1814 1
    DWORD exitCode;
d1827 7
a1833 2
	     * The thread may already have closed on it's own.  Check it's
	     * exit code.
d1836 2
a1837 1
	    GetExitCodeThread(pipePtr->readThread, &exitCode);
d1839 4
a1842 6
	    if (exitCode == STILL_ACTIVE) {
		/*
		 * Set the stop event so that if the reader thread is blocked
		 * in PipeReaderThread on WaitForMultipleEvents, it will exit
		 * cleanly.
		 */
d1844 2
a1845 35
		SetEvent(pipePtr->stopReader);

		/*
		 * Wait at most 10 milliseconds for the reader thread to close.
		 */

		WaitForSingleObject(pipePtr->readThread, 10);
		GetExitCodeThread(pipePtr->readThread, &exitCode);

		if (exitCode == STILL_ACTIVE) {
		    /*
		     * The thread must be blocked waiting for the pipe to
		     * become readable in ReadFile().  There isn't a clean way
		     * to exit the thread from this condition.  We should
		     * terminate the child process instead to get the reader
		     * thread to fall out of ReadFile with a FALSE.  (below) is
		     * not the correct way to do this, but will stay here until
		     * a better solution is found.
		     *
		     * Note that we need to guard against terminating the
		     * thread while it is in the middle of Tcl_ThreadAlert
		     * because it won't be able to release the notifier lock.
		     */

		    Tcl_MutexLock(&pipeMutex);

		    /* BUG: this leaks memory */
		    TerminateThread(pipePtr->readThread, 0);

		    /* Wait for the thread to terminate. */
		    WaitForSingleObject(pipePtr->readThread, INFINITE);

		    Tcl_MutexUnlock(&pipeMutex);
		}
	    }
a1849 1
	    CloseHandle(pipePtr->stopReader);
d2078 1
a2078 1
    CONST char *buf,			/* The data buffer. */
d2123 1
a2123 1
	    infoPtr->writeBuf = ckalloc((unsigned int) toWrite);
d2125 1
a2125 1
	memcpy(infoPtr->writeBuf, buf, (size_t) toWrite);
d2368 1
a2368 1
    DWORD flags;
d2427 10
d2680 1
a2680 3
 *	consume one byte from the pipe for each wait operation.  Will
 *	cause a memory leak of ~4k, if forcefully terminated with
 *	TerminateThread().
a2691 5
    HANDLE wEvents[2];
    DWORD dwWait;

    wEvents[0] = infoPtr->stopReader;
    wEvents[1] = infoPtr->startReader;
d2695 1
a2695 2
	 * Wait for the main thread to signal before attempting to wait
	 * on the pipe becoming readable.
d2698 1
a2698 10
	dwWait = WaitForMultipleObjects(2, wEvents, FALSE, INFINITE);

	if (dwWait != (WAIT_OBJECT_0 + 1)) {
	    /*
	     * The start event was not signaled.  It might be the stop event
	     * or an error, so exit.
	     */

	    return 0;
	}
d2840 3
@


1.3
log
@Tcl8.3 upgrade merge.
@
text
@@


1.2
log
@Fixes for newer cygwin gccs.
Use modern Cygwin conditional.
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tclWinPipe.c,v 1.14 1999/01/26 03:53:44 jingham Exp $
d22 1
d35 8
d55 1
a57 2
#define WIN32S_PIPE 1		/* Win32s emulated pipe. */
#define WIN32S_TMPFILE 2	/* Win32s emulated temporary file. */
a70 30
 * The following structure is used to keep track of temporary files under
 * Win32s and delete the disk file when the open handle is closed.
 * The type field will be WIN32S_TMPFILE.
 */

typedef struct TmpFile {
    WinFile file;		/* Common part. */
    char name[MAX_PATH];	/* Name of temp file. */
} TmpFile;

/*
 * The following structure represents a synchronous pipe under Win32s.
 * The type field will be WIN32S_PIPE.  The handle field will refer to
 * an open file when Tcl is reading from the "pipe", otherwise it is
 * INVALID_HANDLE_VALUE.
 */

typedef struct WinPipe {
    WinFile file;		/* Common part. */
    struct WinPipe *otherPtr;	/* Pointer to the WinPipe structure that
				 * corresponds to the other end of this 
				 * pipe. */
    char *fileName;		/* The name of the staging file that gets 
				 * the data written to this pipe.  Malloc'd.
				 * and shared by both ends of the pipe.  Only
				 * when both ends are freed will fileName be
				 * freed and the file it refers to deleted. */
} WinPipe;

/*
d83 1
a83 1
 * State flags used in the PipeInfo structure below.
d88 7
a94 4
#define PIPE_READABLE	(1<<2)	/* Pipe is readable. */
#define PIPE_CLOSED	(1<<3)	/* Pipe is being closed. */
#define PIPE_HAS_THREAD	(1<<4)	/* Pipe has an associated thread. */
#define PIPE_READAHEAD	(1<<5)	/* Readahead byte is valid. */
d101 1
d115 38
a152 6
    struct PipeInfo *nextPtr;	/* Pointer to next registered pipe. */
    /* CYGNUS LOCAL: Several new fields.  */
    HANDLE flagsMutex;		/* Mutex to control access to flags. */
    HANDLE mutex;		/* Mutex for read fields.  */
    HANDLE tryReadEvent;	/* Event to tell thread to try a read.  */
    char readAhead;		/* Read ahead byte.  */
d155 8
a162 4
/*
 * The following pointer refers to the head of the list of pipes
 * that are being watched for file events.
 */
d164 1
a164 1
static PipeInfo *firstPipePtr;
d184 25
a208 32
static int	ApplicationType(Tcl_Interp *interp, const char *fileName,
		    char *fullName);
static void	BuildCommandLine(int argc, char **argv, Tcl_DString *linePtr);
static void	CopyChannel(HANDLE dst, HANDLE src);
static BOOL	HasConsole(void);
static TclFile	MakeFile(HANDLE handle);
static char *	MakeTempFile(Tcl_DString *namePtr);
static int	PipeBlockModeProc(ClientData instanceData, int mode);
static void	PipeCheckProc _ANSI_ARGS_((ClientData clientData,
		    int flags));
static int	PipeCloseProc(ClientData instanceData, Tcl_Interp *interp);
static int	PipeEventProc(Tcl_Event *evPtr, int flags);
static void	PipeExitHandler(ClientData clientData);
static int	PipeGetHandleProc(ClientData instanceData, int direction,
		    ClientData *handlePtr);
static void	PipeInit(void);
static int	PipeInputProc(ClientData instanceData, char *buf, int toRead,
		    int *errorCode);
static int	PipeOutputProc(ClientData instanceData, char *buf, int toWrite,
		    int *errorCode);
static void	PipeWatchProc(ClientData instanceData, int mask);
static void	PipeSetupProc _ANSI_ARGS_((ClientData clientData,
		    int flags));
static int	TempFileName(char name[MAX_PATH]);

/* CYGNUS LOCAL.  */
static int	PipeGetFlags _ANSI_ARGS_((PipeInfo *));
static void	PipeSetFlag _ANSI_ARGS_((PipeInfo *, int));
static void	PipeResetFlag _ANSI_ARGS_((PipeInfo *, int));
static DWORD	PipeThread _ANSI_ARGS_((LPVOID arg));
static LRESULT CALLBACK	PipeProc _ANSI_ARGS_((HWND hwnd, UINT message,
			    WPARAM wParam, LPARAM lParam));
d217 2
a218 2
    PipeBlockModeProc,		/* Set blocking or non-blocking mode.*/
    PipeCloseProc,		/* Close proc. */
d226 4
a230 6

/* CYGNUS LOCAL: Event notification window.  */

static HWND pipeHwnd;

#define PIPE_MESSAGE (WM_USER + 1)
d232 15
a246 14
/* CYGNUS LOCAL: Because we use a thread that manipulates the flags
   field, we use helper routines for the field.  */

static int
PipeGetFlags(pipe)
    PipeInfo *pipe;
{
    int flags;

    WaitForSingleObject(pipe->flagsMutex, INFINITE);
    flags = pipe->flags;
    ReleaseMutex(pipe->flagsMutex);
    return flags;
}
d249 1
a249 13
PipeSetFlag(pipe, flag)
    PipeInfo *pipe;
    int flag;
{
    WaitForSingleObject(pipe->flagsMutex, INFINITE);
    pipe->flags |= flag;
    ReleaseMutex(pipe->flagsMutex);
}

static void
PipeResetFlag(pipe, flag)
    PipeInfo *pipe;
    int flag;
d251 1
a251 4
    WaitForSingleObject(pipe->flagsMutex, INFINITE);
    pipe->flags &= ~ (flag);
    ReleaseMutex(pipe->flagsMutex);
}
d253 4
a256 2
/* CYGNUS LOCAL: We use a thread to detect when a pipe may be read.
   The thread runs this function.  The argument is the pipe to read.  */
d258 8
a265 41
static DWORD
PipeThread(arg)
    LPVOID arg;
{
    PipeInfo *pipe = (PipeInfo *) arg;
    WinFile *file = (WinFile*) pipe->readFile;
    HANDLE handle = file->handle;

    while (1) {
	char b;
	DWORD got;

	WaitForSingleObject(pipe->tryReadEvent, INFINITE);

	if (PipeGetFlags(pipe) & PIPE_CLOSED) {
	    break;
	}

	WaitForSingleObject(pipe->mutex, INFINITE);

	if ((PipeGetFlags(pipe) & PIPE_READAHEAD) == 0) {
	    if (ReadFile(handle, &b, 1, &got, NULL) && got == 1) {
		pipe->readAhead = b;
		PipeSetFlag(pipe, PIPE_READAHEAD);
	    }
	}

	PipeSetFlag(pipe, PIPE_READABLE);

	/* We've indicated that the pipe is readable, so ignore any
           recent requests to do so.  */
	ResetEvent(pipe->tryReadEvent);

	ReleaseMutex(pipe->mutex);

	if (PipeGetFlags(pipe) & PIPE_CLOSED) {
	    break;
	}

	/* Post a message to wake up the event loop.  */
	PostMessage(pipeHwnd, PIPE_MESSAGE, 0, (LPARAM) pipe);
d268 6
a273 22
    /* PipeCloseProc will set PIPE_CLOSED when the pipe is ready to be
       closed and freed.  */

    CloseHandle(pipe->flagsMutex);
    CloseHandle(pipe->tryReadEvent);
    CloseHandle(pipe->mutex);
    ckfree((char *)pipe);
    return 0;
}

/* CYGNUS LOCAL: This function is called when the PipeThread posts a
   message.  */

static LRESULT CALLBACK
PipeProc(hwnd, message, wParam, lParam)
    HWND hwnd;
    UINT message;
    WPARAM wParam;
    LPARAM lParam;
{
    if (message != PIPE_MESSAGE) {
	return DefWindowProc(hwnd, message, wParam, lParam);
a274 5

    /* This function really only exists to wake up the event loop.  We
       don't actually have to do anything.  */

    return 0;
d280 1
a280 1
 * PipeInit --
d282 2
a283 1
 *	This function initializes the static variables for this file.
d289 1
a289 1
 *	Creates a new event source.
d295 2
a296 1
PipeInit()
d298 1
a298 28
    WNDCLASS class;

    initialized = 1;
    firstPipePtr = NULL;
    procList = NULL;
    Tcl_CreateEventSource(PipeSetupProc, PipeCheckProc, NULL);
    Tcl_CreateExitHandler(PipeExitHandler, NULL);

    /* CYGNUS LOCAL: Create a window for asynchronous notification.  */

    class.style = 0;
    class.cbClsExtra = 0;
    class.cbWndExtra = 0;
    class.hInstance = TclWinGetTclInstance();
    class.hbrBackground = NULL;
    class.lpszMenuName = NULL;
    class.lpszClassName = "TclPipe";
    class.lpfnWndProc = PipeProc;
    class.hIcon = NULL;
    class.hCursor = NULL;

    if (RegisterClass(&class)) {
	pipeHwnd = CreateWindow("TclPipe", "TclPipe", WS_TILED, 0, 0,
		0, 0, NULL, NULL, class.hInstance, NULL);
    } else {
	pipeHwnd = NULL;
	TclWinConvertError(GetLastError());
    }
d304 1
a304 1
 * PipeExitHandler --
d306 1
a306 1
 *	This function is called to cleanup the pipe module before
d313 1
a313 1
 *	Removes the pipe event source.
d319 2
a320 2
PipeExitHandler(clientData)
    ClientData clientData;	/* Old window proc */
d322 1
a322 1
    Tcl_DeleteEventSource(PipeSetupProc, PipeCheckProc, NULL);
d324 1
a324 6
    /* CYGNUS LOCAL: Delete the window.  */
    UnregisterClass("TclPipe", TclWinGetTclInstance());
    if (pipeHwnd != NULL) {
	DestroyWindow(pipeHwnd);
	pipeHwnd = NULL;
    }
d345 3
a347 3
PipeSetupProc(data, flags)
    ClientData data;		/* Not used. */
    int flags;			/* Event flags as passed to Tcl_DoOneEvent. */
d351 3
d360 1
a360 1
     * Check to see if there is a watched pipe.  If so, poll.
d363 13
a375 13
    for (infoPtr = firstPipePtr; infoPtr != NULL; infoPtr = infoPtr->nextPtr) {
	/* CYGNUS LOCAL: Only poll for a readable pipe if it really is
           readable.  */
	if ((infoPtr->watchMask &~ TCL_READABLE)
	    || ((infoPtr->watchMask & TCL_READABLE)
		&& ((PipeGetFlags(infoPtr) & PIPE_HAS_THREAD) == 0
		    || (PipeGetFlags(infoPtr) & PIPE_READABLE)))) {
	    Tcl_SetMaxBlockTime(&blockTime);
	    break;
	} else if (infoPtr->watchMask & TCL_READABLE) {
	    /* CYGNUS LOCAL: Tell the thread to try a read, and let us
               know when it is done.  */
	    SetEvent(infoPtr->tryReadEvent);
d378 3
d401 3
a403 3
PipeCheckProc(data, flags)
    ClientData data;		/* Not used. */
    int flags;			/* Event flags as passed to Tcl_DoOneEvent. */
d407 3
d416 1
a416 1
     * Queue events for any watched pipes that don't already have events
d420 25
a444 9
    for (infoPtr = firstPipePtr; infoPtr != NULL; infoPtr = infoPtr->nextPtr) {
	/* CYGNUS LOCAL: Only poll for a readable pipe if it really is
           readable.  */
	if (((infoPtr->watchMask &~ TCL_READABLE)
	    || ((infoPtr->watchMask & TCL_READABLE)
		&& ((PipeGetFlags(infoPtr) & PIPE_HAS_THREAD) == 0
		    || (PipeGetFlags(infoPtr) & PIPE_READABLE))))
	    && !(PipeGetFlags(infoPtr) & PIPE_PENDING)) {
	    PipeSetFlag(infoPtr, PIPE_PENDING);
d456 1
a456 1
 * MakeFile --
d470 3
a472 3
static TclFile
MakeFile(handle)
    HANDLE handle;		/* Type-specific data. */
a485 31
 * TclpMakeFile --
 *
 *	Make a TclFile from a channel.
 *
 * Results:
 *	Returns a new TclFile or NULL on failure.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

TclFile
TclpMakeFile(channel, direction)
    Tcl_Channel channel;	/* Channel to get file from. */
    int direction;		/* Either TCL_READABLE or TCL_WRITABLE. */
{
    HANDLE handle;

    if (Tcl_GetChannelHandle(channel, direction, 
	    (ClientData *) &handle) == TCL_OK) {
	return MakeFile(handle);
    } else {
	return (TclFile) NULL;
    }
}

/*
 *----------------------------------------------------------------------
 *
d506 1
a506 1
    char name[MAX_PATH];	/* Buffer in which name for temporary 
d509 7
a515 6
    if ((GetTempPath(MAX_PATH, name) == 0) ||
	    (GetTempFileName(name, "TCL", 0, name) == 0)) {
	name[0] = '.';
	name[1] = '\0';
	if (GetTempFileName(name, "TCL", 0, name) == 0) {
	    return 0;
d518 9
a526 1
    return 1;
d532 1
a532 1
 * TclpCreateTempFile --
d534 1
a534 3
 *	This function opens a unique file with the property that it
 *	will be deleted when its file handle is closed.  The temporary
 *	file is created in the system temporary directory.
d537 1
a537 1
 *	Returns a valid TclFile, or NULL on failure.
d540 1
a540 1
 *	Creates a new temporary file.
d546 3
a548 5
TclpCreateTempFile(contents, namePtr)
    char *contents;		/* String to write into temp file, or NULL. */
    Tcl_DString *namePtr;	/* If non-NULL, pointer to initialized 
				 * DString that is filled with the name of 
				 * the temp file that was created. */
a549 1
    char name[MAX_PATH];
d552 3
a554 60
    if (TempFileName(name) == 0) {
	return NULL;
    }

    handle = CreateFile(name, GENERIC_READ | GENERIC_WRITE, 0, NULL,
	    CREATE_ALWAYS, FILE_ATTRIBUTE_TEMPORARY|FILE_FLAG_DELETE_ON_CLOSE,
	    NULL);
    if (handle == INVALID_HANDLE_VALUE) {
	goto error;
    }

    /*
     * Write the file out, doing line translations on the way.
     */

    if (contents != NULL) {
	DWORD result, length;
	char *p;
	
	for (p = contents; *p != '\0'; p++) {
	    if (*p == '\n') {
		length = p - contents;
		if (length > 0) {
		    if (!WriteFile(handle, contents, length, &result, NULL)) {
			goto error;
		    }
		}
		if (!WriteFile(handle, "\r\n", 2, &result, NULL)) {
		    goto error;
		}
		contents = p+1;
	    }
	}
	length = p - contents;
	if (length > 0) {
	    if (!WriteFile(handle, contents, length, &result, NULL)) {
		goto error;
	    }
	}
    }

    if (SetFilePointer(handle, 0, NULL, FILE_BEGIN) == 0xFFFFFFFF) {
	goto error;
    }

    if (namePtr != NULL) {
        Tcl_DStringAppend(namePtr, name, -1);
    }

    /*
     * Under Win32s a file created with FILE_FLAG_DELETE_ON_CLOSE won't
     * actually be deleted when it is closed, so we have to do it ourselves.
     */

    if (TclWinGetPlatformId() == VER_PLATFORM_WIN32s) {
	TmpFile *tmpFilePtr = (TmpFile *) ckalloc(sizeof(TmpFile));
	tmpFilePtr->file.type = WIN32S_TMPFILE;
	tmpFilePtr->file.handle = handle;
	strcpy(tmpFilePtr->name, name);
	return (TclFile)tmpFilePtr;
d556 1
a556 1
	return MakeFile(handle);
a557 6

  error:
    TclWinConvertError(GetLastError());
    CloseHandle(handle);
    DeleteFile(name);
    return NULL;
d579 2
a580 2
    char *path;
    int mode;
d584 3
a586 2
    SECURITY_ATTRIBUTES sec;

d630 2
d638 1
a638 1
	flags = GetFileAttributes(path);
a644 9
     * Set up the security attributes so this file is not inherited by
     * child processes.
     */

    sec.nLength = sizeof(sec);
    sec.lpSecurityDescriptor = NULL;
    sec.bInheritHandle = 0;

    /*
d654 4
a657 2
    handle = CreateFile(path, accessMode, shareMode, &sec, createMode, flags,
            (HANDLE) NULL);
d659 3
a661 1
	DWORD err = GetLastError();
d677 1
a677 1
    return MakeFile(handle);
d683 1
a683 1
 * TclpCreatePipe --
d685 3
a687 2
 *      Creates an anonymous pipe.  Under Win32s, creates a temp file
 *	that is used to simulate a pipe.
d690 1
a690 1
 *      Returns 1 on success, 0 on failure. 
d693 1
a693 1
 *      Creates a pipe.
d698 3
a700 6
int
TclpCreatePipe(readPipe, writePipe)
    TclFile *readPipe;	/* Location to store file handle for
				 * read side of pipe. */
    TclFile *writePipe;	/* Location to store file handle for
				 * write side of pipe. */
d702 4
a705 1
    HANDLE readHandle, writeHandle;
d707 2
a708 4
    if (CreatePipe(&readHandle, &writeHandle, NULL, 0) != 0) {
	*readPipe = MakeFile(readHandle);
	*writePipe = MakeFile(writeHandle);
	return 1;
d711 6
a716 16
    if (TclWinGetPlatformId() == VER_PLATFORM_WIN32s) {
	WinPipe *readPipePtr, *writePipePtr;
	char buf[MAX_PATH];

	if (TempFileName(buf) != 0) {
	    readPipePtr = (WinPipe *) ckalloc(sizeof(WinPipe));
	    writePipePtr = (WinPipe *) ckalloc(sizeof(WinPipe));

	    readPipePtr->file.type = WIN32S_PIPE;
	    readPipePtr->otherPtr = writePipePtr;
	    readPipePtr->fileName = strcpy(ckalloc(strlen(buf) + 1), buf);
	    readPipePtr->file.handle = INVALID_HANDLE_VALUE;
	    writePipePtr->file.type = WIN32S_PIPE;
	    writePipePtr->otherPtr = readPipePtr;
	    writePipePtr->fileName = readPipePtr->fileName;
	    writePipePtr->file.handle = INVALID_HANDLE_VALUE;
d718 3
a720 2
	    *readPipe = (TclFile)readPipePtr;
	    *writePipe = (TclFile)writePipePtr;
d722 79
a800 3
	    return 1;
	}
    }
d824 2
a825 2
TclpCloseFile(file)
    TclFile file;	/* The file to close. */
a827 1
    WinPipe *pipePtr;
a830 6
	case WIN32S_TMPFILE:
	    if (CloseHandle(filePtr->handle) == FALSE) {
		TclWinConvertError(GetLastError());
		ckfree((char *) filePtr);
		return -1;
	    }
d832 3
a834 1
	     * Simulate deleting the file on close for Win32s.
d837 8
a844 13
	    if (filePtr->type == WIN32S_TMPFILE) {
		DeleteFile(((TmpFile*)filePtr)->name);
	    }
	    break;

	case WIN32S_PIPE:
	    pipePtr = (WinPipe *) file;

	    if (pipePtr->otherPtr != NULL) {
		pipePtr->otherPtr->otherPtr = NULL;
	    } else {
		if (pipePtr->file.handle != INVALID_HANDLE_VALUE) {
		    CloseHandle(pipePtr->file.handle);
a845 2
		DeleteFile(pipePtr->fileName);
		ckfree((char *) pipePtr->fileName);
d850 1
a850 1
	    panic("Tcl_CloseFile: unexpected file type");
d877 2
a878 2
TclpGetPid(pid)
    Tcl_Pid pid;		/* The HANDLE of the child process. */
d881 2
a882 1
    
d885 1
d889 1
d900 2
a901 3
 *	synchronously under Win32s and asynchronously under Windows NT
 *	and Windows 95, and runs with the same environment variables
 *	as the creating process.
d910 1
a910 1
 *	interp->result if there was a problem creating the child 
d921 2
a922 3
TclpCreateProcess(interp, argc, argv, inputFile, outputFile, errorFile, 
	pidPtr)
    Tcl_Interp *interp;		/* Interpreter in which to leave errors that
d926 2
a927 2
    int argc;			/* Number of arguments in following array. */
    char **argv;		/* Array of argument strings.  argv[0]
d932 1
a932 1
    TclFile inputFile;		/* If non-NULL, gives the file to use as
d936 1
a936 1
    TclFile outputFile;		/* If non-NULL, gives the file that
d941 1
a941 1
    TclFile errorFile;		/* If non-NULL, gives the file that
d946 1
a946 1
    Tcl_Pid *pidPtr;		/* If this procedure is successful, pidPtr
d951 2
a952 2
    Tcl_DString cmdLine;
    STARTUPINFO startInfo;
d956 1
a956 2
    char execPath[MAX_PATH];
    char *originalName;
d959 1
a959 3
    if (!initialized) {
	PipeInit();
    }
a964 2
    originalName = argv[0];
    argv[0] = execPath;
a967 155

    if (TclWinGetPlatformId() == VER_PLATFORM_WIN32s) {
	/*
	 * Under Win32s, there are no pipes.  In order to simulate pipe
	 * behavior, the child processes are run synchronously and their
	 * I/O is redirected from/to temporary files before the next 
	 * stage of the pipeline is started.
	 */

	MSG msg;
	DWORD status;
	DWORD args[4];
	void *trans[5];
	char *inputFileName, *outputFileName;
	Tcl_DString inputTempFile, outputTempFile;

	BuildCommandLine(argc, argv, &cmdLine);

	ZeroMemory(&startInfo, sizeof(startInfo));
	startInfo.cb = sizeof(startInfo);

	Tcl_DStringInit(&inputTempFile);
	Tcl_DStringInit(&outputTempFile);
	outputHandle = INVALID_HANDLE_VALUE;

	inputFileName = NULL;
	outputFileName = NULL;
	if (inputFile != NULL) {
	    filePtr = (WinFile *) inputFile;
	    switch (filePtr->type) {
		case WIN_FILE:
		case WIN32S_TMPFILE: {
		    h = INVALID_HANDLE_VALUE;
		    inputFileName = MakeTempFile(&inputTempFile);
		    if (inputFileName != NULL) {
			h = CreateFile(inputFileName, GENERIC_WRITE, 0, 
				NULL, CREATE_ALWAYS, 0, NULL);
		    }
		    if (h == INVALID_HANDLE_VALUE) {
			Tcl_AppendResult(interp, "couldn't duplicate input handle: ", 
				Tcl_PosixError(interp), (char *) NULL);
			goto end32s;
		    }
		    CopyChannel(h, filePtr->handle);
		    CloseHandle(h);
		    break;
		}
		case WIN32S_PIPE: {
		    inputFileName = ((WinPipe*)inputFile)->fileName;
		    break;
		}
	    }
	}
	if (inputFileName == NULL) {
	    inputFileName = "nul";
	}
	if (outputFile != NULL) {
	    filePtr = (WinFile *)outputFile;
	    if (filePtr->type == WIN_FILE) {
		outputFileName = MakeTempFile(&outputTempFile);
		if (outputFileName == NULL) {
		    Tcl_AppendResult(interp, "couldn't duplicate output handle: ",
			    Tcl_PosixError(interp), (char *) NULL);
		    goto end32s;
		}
		outputHandle = filePtr->handle;
	    } else if (filePtr->type == WIN32S_PIPE) {
		outputFileName = ((WinPipe*)outputFile)->fileName;
	    }
	}
	if (outputFileName == NULL) {
	    outputFileName = "nul";
	}

	if (applType == APPL_DOS) {
	    args[0] = (DWORD) Tcl_DStringValue(&cmdLine);
	    args[1] = (DWORD) inputFileName;
	    args[2] = (DWORD) outputFileName;
	    trans[0] = &args[0];
	    trans[1] = &args[1];
	    trans[2] = &args[2];
	    trans[3] = NULL;
	    if (TclWinSynchSpawn(args, 0, trans, pidPtr) != 0) {
		result = TCL_OK;
	    }
	} else if (applType == APPL_WIN3X) {
	    args[0] = (DWORD) Tcl_DStringValue(&cmdLine);
	    trans[0] = &args[0];
	    trans[1] = NULL;
	    if (TclWinSynchSpawn(args, 1, trans, pidPtr) != 0) {
		result = TCL_OK;
	    }
	} else {
	    if (CreateProcess(NULL, Tcl_DStringValue(&cmdLine), NULL, NULL, 
		    FALSE, DETACHED_PROCESS, NULL, NULL, &startInfo, 
		    &procInfo) != 0) {
		CloseHandle(procInfo.hThread);
		while (1) {
		    if (GetExitCodeProcess(procInfo.hProcess, &status) == FALSE) {
			break;
		    }
		    if (status != STILL_ACTIVE) {
			break;
		    }
		    if (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE) == TRUE) {
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		    }
		}
		*pidPtr = (Tcl_Pid) procInfo.hProcess;
		if (*pidPtr != 0) {
		    ProcInfo *procPtr = (ProcInfo *) ckalloc(sizeof(ProcInfo));
		    procPtr->hProcess = procInfo.hProcess;
		    procPtr->dwProcessId = procInfo.dwProcessId;
		    procPtr->nextPtr = procList;
		    procList = procPtr;
		}
		result = TCL_OK;
	    }
	}
	if (result != TCL_OK) {
	    TclWinConvertError(GetLastError());
	    Tcl_AppendResult(interp, "couldn't execute \"", originalName,
		    "\": ", Tcl_PosixError(interp), (char *) NULL);
	}

	end32s:
	if (outputHandle != INVALID_HANDLE_VALUE) {
	    /*
	     * Now copy stuff from temp file to actual output handle. Don't
	     * close outputHandle because it is associated with the output
	     * file owned by the caller.
	     */

	    h = CreateFile(outputFileName, GENERIC_READ, 0, NULL, OPEN_ALWAYS,
		    0, NULL);
	    if (h != INVALID_HANDLE_VALUE) {
		CopyChannel(outputHandle, h);
	    }
	    CloseHandle(h);
	}

	if (inputFileName == Tcl_DStringValue(&inputTempFile)) {
	    DeleteFile(inputFileName);
	}
	
	if (outputFileName == Tcl_DStringValue(&outputTempFile)) {
	    DeleteFile(outputFileName);
	}

	Tcl_DStringFree(&inputTempFile);
	Tcl_DStringFree(&outputTempFile);
        Tcl_DStringFree(&cmdLine);
	return result;
    }
d1070 1
a1070 1
	    startInfo.hStdOutput = CreateFile("NUL:", GENERIC_WRITE, 0,
d1090 1
a1090 1
	startInfo.hStdError = CreateFile("NUL:", GENERIC_WRITE, 0,
d1177 1
a1177 2
	    /* CYGNUS LOCAL: We name the DLL cygtclpip.  */
	    Tcl_DStringAppend(&cmdLine, "cygtclpip" STRINGIFY(TCL_MAJOR_VERSION) 
d1201 1
a1201 1
    BuildCommandLine(argc, argv, &cmdLine);
d1203 3
a1205 2
    if (!CreateProcess(NULL, Tcl_DStringValue(&cmdLine), NULL, NULL, TRUE, 
	    createFlags, NULL, NULL, &startInfo, &procInfo)) {
d1207 1
a1207 1
	Tcl_AppendResult(interp, "couldn't execute \"", originalName,
d1212 5
d1218 1
a1218 1
	WaitForSingleObject(hProcess, 50);
d1235 1
a1235 5
	ProcInfo *procPtr = (ProcInfo *) ckalloc(sizeof(ProcInfo));
	procPtr->hProcess = procInfo.hProcess;
	procPtr->dwProcessId = procInfo.dwProcessId;
	procPtr->nextPtr = procList;
	procList = procPtr;
d1274 3
a1276 1
    HANDLE handle = CreateFile("CONOUT$", GENERIC_WRITE, FILE_SHARE_WRITE,
d1324 1
a1324 1
ApplicationType(interp, originalName, fullPath)
d1327 1
a1327 1
    char fullPath[MAX_PATH];	/* Filled with complete path to 
d1330 1
a1330 1
    int applType, i;
d1332 2
a1333 1
    char *ext, *rest;
d1335 1
a1335 1
    DWORD read;
d1337 3
d1356 4
d1361 10
a1370 4
	lstrcpyn(fullPath, originalName, MAX_PATH - 5);
        lstrcat(fullPath, extensions[i]);
	
	SearchPath(NULL, fullPath, NULL, MAX_PATH, fullPath, &rest);
d1377 2
a1378 1
	if (GetFileAttributes(fullPath) & FILE_ATTRIBUTE_DIRECTORY) {
d1381 2
d1384 2
a1385 2
	ext = strrchr(fullPath, '.');
	if ((ext != NULL) && (strcmpi(ext, ".bat") == 0)) {
d1389 4
a1392 3

	hFile = CreateFile(fullPath, GENERIC_READ, FILE_SHARE_READ, NULL, 
		OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
d1409 1
a1409 1
	    if ((ext != NULL) && (strcmpi(ext, ".com") == 0)) {
d1453 1
d1470 4
a1473 1
	GetShortPathName(fullPath, fullPath, MAX_PATH);
d1498 7
a1504 5
BuildCommandLine(argc, argv, linePtr)
    int argc;			/* Number of arguments. */
    char **argv;		/* Argument strings. */
    Tcl_DString *linePtr;	/* Initialized Tcl_DString that receives the
				 * command line. */
d1506 1
a1506 1
    char *start, *special;
d1508 1
d1510 8
d1519 5
a1523 2
	if (i > 0) {
	    Tcl_DStringAppend(linePtr, " ", 1);	
d1531 1
a1531 1
		if (isspace(*start)) {
d1538 1
a1538 1
	    Tcl_DStringAppend(linePtr, "\"", 1);
d1541 2
a1542 2
	start = argv[i];	    
	for (special = argv[i]; ; ) {
d1545 1
a1545 1
		Tcl_DStringAppend(linePtr, start, special - start);
d1555 1
a1555 1
			Tcl_DStringAppend(linePtr, start, special - start);
d1562 1
a1562 1
		Tcl_DStringAppend(linePtr, start, special - start);
d1566 2
a1567 2
		Tcl_DStringAppend(linePtr, start, special - start);
		Tcl_DStringAppend(linePtr, "\\\"", 2);
d1575 1
a1575 1
	Tcl_DStringAppend(linePtr, start, special - start);
d1577 1
a1577 75
	    Tcl_DStringAppend(linePtr, "\"", 1);
	}
    }
}

/*
 *----------------------------------------------------------------------
 *
 * MakeTempFile --
 *
 *	Helper function for TclpCreateProcess under Win32s.  Makes a 
 *	temporary file that _won't_ go away automatically when it's file
 *	handle is closed.  Used for simulated pipes, which are written
 *	in one pass and reopened and read in the next pass.
 *
 * Results:
 *	namePtr is filled with the name of the temporary file.
 *
 * Side effects:
 *	A temporary file with the name specified by namePtr is created.  
 *	The caller is responsible for deleting this temporary file.
 *
 *----------------------------------------------------------------------
 */

static char *
MakeTempFile(namePtr)
    Tcl_DString *namePtr;	/* Initialized Tcl_DString that is filled 
				 * with the name of the temporary file that 
				 * was created. */
{
    char name[MAX_PATH];

    if (TempFileName(name) == 0) {
	return NULL;
    }

    Tcl_DStringAppend(namePtr, name, -1);
    return Tcl_DStringValue(namePtr);
}

/*
 *----------------------------------------------------------------------
 *
 * CopyChannel --
 *
 *	Helper function used by TclpCreateProcess under Win32s.  Copies
 *	what remains of source file to destination file; source file 
 *	pointer need not be positioned at the beginning of the file if
 *	all of source file is not desired, but data is copied up to end 
 *	of source file.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static void
CopyChannel(dst, src)
    HANDLE dst;			/* Destination file. */
    HANDLE src;			/* Source file. */
{
    char buf[8192];
    DWORD dwRead, dwWrite;

    while (ReadFile(src, buf, sizeof(buf), &dwRead, NULL) != FALSE) {
	if (dwRead == 0) {
	    break;
	}
	if (WriteFile(dst, buf, dwRead, &dwWrite, NULL) == FALSE) {
	    break;
d1580 2
d1603 4
a1606 4
TclpCreateCommandChannel(readFile, writeFile, errorFile, numPids, pidPtr)
    TclFile readFile;		/* If non-null, gives the file for reading. */
    TclFile writeFile;		/* If non-null, gives the file for writing. */
    TclFile errorFile;		/* If non-null, gives the file where errors
d1608 2
a1609 2
    int numPids;		/* The number of pids in the pid array. */
    Tcl_Pid *pidPtr;		/* An array of process identifiers. */
d1611 1
a1611 1
    char channelName[20];
d1613 1
d1616 1
a1616 3
    if (!initialized) {
	PipeInit();
    }
d1620 1
d1626 3
a1628 3

    /* CYGNUS LOCAL: Mutex for flags.  */
    infoPtr->flagsMutex = CreateMutex(NULL, FALSE, NULL);
d1636 1
a1636 7
	WinPipe *pipePtr = (WinPipe *) readFile;
	if (pipePtr->file.type == WIN32S_PIPE
		&& pipePtr->file.handle == INVALID_HANDLE_VALUE) {
	    pipePtr->file.handle = CreateFile(pipePtr->fileName, GENERIC_READ,
		    0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL);
	}
	channelId = (int) pipePtr->file.handle;
d1646 3
d1650 9
d1660 2
d1664 9
d1680 2
d1684 1
a1684 1
    sprintf(channelName, "file%d", channelId);
d1707 1
a1707 1
 *	interp->result.
d1713 1
a1713 1
 *	Modifies interp->result.
d1719 3
a1721 3
TclGetAndDetachPids(interp, chan)
    Tcl_Interp *interp;
    Tcl_Channel chan;
d1726 1
a1726 1
    char buf[20];
d1739 1
a1739 1
        sprintf(buf, "%lu", TclpGetPid(pipePtr->pidPtr[i]));
d1766 3
a1768 3
PipeBlockModeProc(instanceData, mode)
    ClientData instanceData;	/* Instance data for channel. */
    int mode;			/* TCL_MODE_BLOCKING or
d1781 1
a1781 1
	PipeSetFlag(infoPtr, PIPE_ASYNC);
d1783 1
a1783 1
	PipeResetFlag(infoPtr, PIPE_ASYNC);
d1791 1
a1791 1
 * PipeCloseProc --
d1805 4
a1808 3
PipeCloseProc(instanceData, interp)
    ClientData instanceData;	/* Pointer to PipeInfo structure. */
    Tcl_Interp *interp;		/* For error reporting. */
d1814 10
d1825 21
a1845 3
    /*
     * Remove the file from the list of watched files.
     */
d1847 4
a1850 5
    for (nextPtrPtr = &firstPipePtr, infoPtr = *nextPtrPtr; infoPtr != NULL;
	    nextPtrPtr = &infoPtr->nextPtr, infoPtr = *nextPtrPtr) {
	if (infoPtr == (PipeInfo *)pipePtr) {
	    *nextPtrPtr = infoPtr->nextPtr;
	    break;
a1851 4
    }

    errorCode = 0;
    if (pipePtr->readFile != NULL) {
d1855 2
d1858 38
a1895 1
    if (pipePtr->writeFile != NULL) {
d1901 2
d1904 24
a1927 1
    
d1930 1
a1930 2
     * routine.  If we are running in Win32s, just delete the error file
     * immediately, because it was never used.
a1934 1
	OSVERSIONINFO os;
d1936 4
a1939 10
	os.dwOSVersionInfoSize = sizeof(os);
	GetVersionEx(&os);
	if (os.dwPlatformId == VER_PLATFORM_WIN32s) {
	    TclpCloseFile(pipePtr->errorFile);
	    errChan = NULL;
	} else {
	    filePtr = (WinFile*)pipePtr->errorFile;
	    errChan = Tcl_MakeFileChannel((ClientData) filePtr->handle,
		    TCL_READABLE);
	}
d1943 1
d1946 1
d1951 2
a1952 10
    /* CYGNUS LOCAL: If the pipe has a thread, let the thread free the
       structure.  */
    if (PipeGetFlags(pipePtr) & PIPE_HAS_THREAD) {
	WaitForSingleObject(pipePtr->flagsMutex, INFINITE);
	pipePtr->flags |= PIPE_CLOSED;
	SetEvent(pipePtr->tryReadEvent);
	ReleaseMutex(pipePtr->flagsMutex);
    } else {
	CloseHandle(pipePtr->flagsMutex);
	ckfree((char*) pipePtr);
d1955 2
d1982 4
a1985 4
PipeInputProc(instanceData, buf, bufSize, errorCode)
    ClientData instanceData;		/* Pipe state. */
    char *buf;				/* Where to store data read. */
    int bufSize;			/* How much space is available
d1987 1
a1987 1
    int *errorCode;			/* Where to store error code. */
d1991 17
a2007 8
    DWORD count;
    DWORD bytesRead;
    int gotReadAhead = 0;
    int origBufSize = bufSize;

    /* CYGNUS LOCAL: If the pipe has a thread, lock it.  */
    if (PipeGetFlags(infoPtr) & PIPE_HAS_THREAD) {
	WaitForSingleObject(infoPtr->mutex, INFINITE);
d2010 1
a2010 14
    *errorCode = 0;
    if (filePtr->type == WIN32S_PIPE) {
	if (((WinPipe *)filePtr)->otherPtr != NULL) {
	    panic("PipeInputProc: child process isn't finished writing");
	}
	if (filePtr->handle == INVALID_HANDLE_VALUE) {
	    filePtr->handle = CreateFile(((WinPipe *)filePtr)->fileName,
		    GENERIC_READ, 0, NULL, OPEN_ALWAYS, FILE_ATTRIBUTE_NORMAL,
		    NULL);
	}
	if (filePtr->handle == INVALID_HANDLE_VALUE) {
	    goto error;
	}
    } else {
d2012 2
a2013 3
	 * Pipes will block until the requested number of bytes has been
	 * read.  To avoid blocking unnecessarily, we look ahead and only
	 * read as much as is available.
d2016 5
a2020 4
	if (PeekNamedPipe(filePtr->handle, (LPVOID) NULL, (DWORD) 0,
		(LPDWORD) NULL, &count, (LPDWORD) NULL) == TRUE) {
	    if ((count != 0) && ((DWORD) bufSize > count)) {
		bufSize = (int) count;
d2022 3
a2024 16
		/*
		 * This code is commented out because on Win95 we don't get
		 * notifier of eof on a pipe unless we try to read it.
		 * The correct solution is to move to threads.
		 */

/* 	    } else if ((count == 0) && (PipeGetFlags(infoPtr) & PIPE_ASYNC)) { */
/* 		errno = *errorCode = EAGAIN; */
/* 		return -1; */
	    } else if ((count == 0) && !(PipeGetFlags(infoPtr) & PIPE_ASYNC)) {
		bufSize = 1;
	    }
	} else {
	    goto error;
	}
    }
d2026 2
a2027 12
    /* CYGNUS LOCAL: Check for the readahead byte.  */
    if (PipeGetFlags(infoPtr) & PIPE_READAHEAD) {
	*buf++ = infoPtr->readAhead;
	PipeResetFlag(infoPtr, PIPE_READAHEAD);
	if (bufSize <= 1) {
	    PipeResetFlag(infoPtr, PIPE_READABLE);
	    ReleaseMutex(infoPtr->mutex);
	    return 1;
	}
	gotReadAhead = 1;
	if (bufSize == origBufSize) {
	    --bufSize;
d2032 3
a2034 4
     * Note that we will block on reads from a console buffer until a
     * full line has been entered.  The only way I know of to get
     * around this is to write a console driver.  We should probably
     * do this at some point, but for now, we just block.
d2037 9
a2045 8
    if (ReadFile(filePtr->handle, (LPVOID) buf, (DWORD) bufSize, &bytesRead,
            (LPOVERLAPPED) NULL) == FALSE) {
	goto error;
    }
    
    if (PipeGetFlags(infoPtr) & PIPE_HAS_THREAD) {
	PipeResetFlag(infoPtr, PIPE_READABLE);
	ReleaseMutex(infoPtr->mutex);
a2047 3
    return bytesRead + gotReadAhead;

    error:
a2048 3
    if (PipeGetFlags(infoPtr) & PIPE_HAS_THREAD) {
	ReleaseMutex(infoPtr->mutex);
    }
d2050 1
d2076 5
a2080 5
PipeOutputProc(instanceData, buf, toWrite, errorCode)
    ClientData instanceData;		/* Pipe state. */
    char *buf;				/* The data buffer. */
    int toWrite;			/* How many bytes to write? */
    int *errorCode;			/* Where to store error code. */
d2084 1
a2084 1
    DWORD bytesWritten;
d2087 54
a2140 8
    if (WriteFile(filePtr->handle, (LPVOID) buf, (DWORD) toWrite,
	    &bytesWritten, (LPOVERLAPPED) NULL) == FALSE) {
        TclWinConvertError(GetLastError());
        if (errno == EPIPE) {
            return 0;
        }
        *errorCode = errno;
        return -1;
d2143 5
d2172 3
a2174 3
PipeEventProc(evPtr, flags)
    Tcl_Event *evPtr;		/* Event to service. */
    int flags;			/* Flags that indicate what events to
d2181 1
a2181 1
/*    DWORD count;*/
d2194 2
a2195 1
    for (infoPtr = firstPipePtr; infoPtr != NULL; infoPtr = infoPtr->nextPtr) {
d2197 1
a2197 1
	    PipeResetFlag(infoPtr, PIPE_PENDING);
d2211 1
a2211 1
     * If we aren't on Win32s, check to see if the pipe is readable.  Note
d2213 1
a2213 1
     * as being writable.
d2216 7
d2224 4
a2227 8
    if (filePtr->type != WIN32S_PIPE) {

	/* CYGNUS LOCAL: Check PIPE_READABLE if we have a thread.  */
	if (PipeGetFlags(infoPtr) & PIPE_HAS_THREAD) {
	    mask = TCL_WRITABLE;
	    if (PipeGetFlags(infoPtr) & PIPE_READABLE) {
		mask |= TCL_READABLE;
	    }
d2229 1
a2229 1
	    mask = TCL_WRITABLE|TCL_READABLE;
a2230 19

/* 	if (PeekNamedPipe(filePtr->handle, (LPVOID) NULL, (DWORD) 0, */
/* 		(LPDWORD) NULL, &count, (LPDWORD) NULL) == TRUE) { */
/* 	    if (count != 0) { */
/* 		mask |= TCL_READABLE; */
/* 	    } */
/* 	} else { */

	    /*
	     * If the pipe has been closed by the other side, then 
	     * mark the pipe as readable, but not writable.
	     */

/* 	    if (GetLastError() == ERROR_BROKEN_PIPE) { */
/* 		mask = TCL_READABLE; */
/* 	    } */
/* 	} */
    } else {
	mask = TCL_READABLE | TCL_WRITABLE;
d2259 3
a2261 3
PipeWatchProc(instanceData, mask)
    ClientData instanceData;		/* Pipe state. */
    int mask;				/* What events to watch for; OR-ed
d2268 1
d2271 3
a2273 2
     * For now, we just send a message to ourselves so we can poll the
     * channel for readable events.
a2278 14

	/* CYGNUS LOCAL: Set up a thread if necessary.  */
	if ((infoPtr->watchMask & TCL_READABLE) != 0
	    && (PipeGetFlags(infoPtr) & PIPE_HAS_THREAD) == 0) {
	    HANDLE thread;
	    DWORD tid;

	    infoPtr->tryReadEvent = CreateEvent(NULL, FALSE, FALSE, NULL);
	    infoPtr->mutex = CreateMutex(NULL, FALSE, NULL);
	    PipeSetFlag(infoPtr, PIPE_HAS_THREAD);
	    thread = CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE) PipeThread, infoPtr, 0, &tid);
	    CloseHandle(thread);
	}

d2280 2
a2281 2
	    infoPtr->nextPtr = firstPipePtr;
	    firstPipePtr = infoPtr;
d2290 1
a2290 1
	    for (nextPtrPtr = &firstPipePtr, ptr = *nextPtrPtr;
d2321 4
a2324 4
PipeGetHandleProc(instanceData, direction, handlePtr)
    ClientData instanceData;	/* The pipe state. */
    int direction;		/* TCL_READABLE or TCL_WRITABLE */
    ClientData *handlePtr;	/* Where to store the handle.  */
a2330 10
	if (filePtr->type == WIN32S_PIPE) {
	    if (filePtr->handle == INVALID_HANDLE_VALUE) {
		filePtr->handle = CreateFile(((WinPipe *)filePtr)->fileName,
			GENERIC_READ, 0, NULL, OPEN_ALWAYS,
			FILE_ATTRIBUTE_NORMAL, NULL);
	    }
	    if (filePtr->handle == INVALID_HANDLE_VALUE) {
		return TCL_ERROR;
	    }
	}
d2362 4
a2365 4
Tcl_WaitPid(pid, statPtr, options)
    Tcl_Pid pid;
    int *statPtr;
    int options;
d2372 1
a2372 3
    if (!initialized) {
	PipeInit();
    }
d2387 1
d2395 1
d2401 1
a2401 1
    
d2431 5
a2435 5
	if ((*statPtr & 0x10000) != 0
	    && (*statPtr & 0xff00) != 0
	    && (*statPtr & ~ 0x1ff00) == 0) {
	    *statPtr = (*statPtr >> 8) & 0xff;
	} else
d2459 32
d2507 5
a2511 5
Tcl_PidObjCmd(dummy, interp, objc, objv)
    ClientData dummy;		/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST *objv;	/* Argument strings. */
d2518 1
a2518 1
    char buf[20];
d2526 1
a2526 1
	sprintf(buf, "%lu", (unsigned long) getpid());
d2542 1
a2542 1
	    sprintf(buf, "%lu", TclpGetPid(pipePtr->pidPtr[i]));
d2549 295
@


1.1
log
@Initial revision
@
text
@d18 1
a18 1
#ifndef __CYGWIN32__
d2642 2
a2643 2
#ifdef __CYGWIN32__
	/* A cygwin32 program that exits because of a signal will set
@


1.1.1.1
log
@import dejagnu-1999-11-08 snapshot
@
text
@@


1.1.1.2
log
@Tcl 8.3 upgrade
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tclWinPipe.c,v 1.6.8.4 2001/07/16 23:51:56 mdejong Exp $
d17 5
a33 8
 * The pipeMutex locks around access to the initialized and procList variables,
 * and it is used to protect background threads from being terminated while
 * they are using APIs that hold locks.
 */

TCL_DECLARE_MUTEX(pipeMutex)

/*
a45 1
 * This used to have a 1 && 2 that supported Win32s.
d48 2
d63 30
d105 1
a105 1
 * Bit masks used in the flags field of the PipeInfo structure below.
d110 4
a113 7

/*
 * Bit masks used in the sharedFlags field of the PipeInfo structure below.
 */

#define PIPE_EOF	(1<<2)	/* Pipe has reached EOF. */
#define PIPE_EXTRABYTE	(1<<3)	/* The reader thread has consumed one byte. */
a119 1
    struct PipeInfo *nextPtr;	/* Pointer to next registered pipe. */
d133 6
a138 38
    Tcl_ThreadId threadId;	/* Thread to which events should be reported.
				 * This value is used by the reader/writer
				 * threads. */
    HANDLE writeThread;		/* Handle to writer thread. */
    HANDLE readThread;		/* Handle to reader thread. */
    HANDLE writable;		/* Manual-reset event to signal when the
				 * writer thread has finished waiting for
				 * the current buffer to be written. */
    HANDLE readable;		/* Manual-reset event to signal when the
				 * reader thread has finished waiting for
				 * input. */
    HANDLE startWriter;		/* Auto-reset event used by the main thread to
				 * signal when the writer thread should attempt
				 * to write to the pipe. */
    HANDLE startReader;		/* Auto-reset event used by the main thread to
				 * signal when the reader thread should attempt
				 * to read from the pipe. */
    DWORD writeError;		/* An error caused by the last background
				 * write.  Set to 0 if no error has been
				 * detected.  This word is shared with the
				 * writer thread so access must be
				 * synchronized with the writable object.
				 */
    char *writeBuf;		/* Current background output buffer.
				 * Access is synchronized with the writable
				 * object. */
    int writeBufLen;		/* Size of write buffer.  Access is
				 * synchronized with the writable
				 * object. */
    int toWrite;		/* Current amount to be written.  Access is
				 * synchronized with the writable object. */
    int readFlags;		/* Flags that are shared with the reader
				 * thread.  Access is synchronized with the
				 * readable object.  */
    char extraByte;		/* Buffer for extra character consumed by
				 * reader thread.  This byte is shared with
				 * the reader thread so access must be
				 * synchronized with the readable object. */
d141 4
a144 8
typedef struct ThreadSpecificData {
    /*
     * The following pointer refers to the head of the list of pipes
     * that are being watched for file events.
     */
    
    PipeInfo *firstPipePtr;
} ThreadSpecificData;
d146 1
a146 1
static Tcl_ThreadDataKey dataKey;
d166 32
a197 25
static int		ApplicationType(Tcl_Interp *interp,
			    const char *fileName, char *fullName);
static void		BuildCommandLine(const char *executable, int argc, 
			    char **argv, Tcl_DString *linePtr);
static BOOL		HasConsole(void);
static int		PipeBlockModeProc(ClientData instanceData, int mode);
static void		PipeCheckProc(ClientData clientData, int flags);
static int		PipeClose2Proc(ClientData instanceData,
			    Tcl_Interp *interp, int flags);
static int		PipeEventProc(Tcl_Event *evPtr, int flags);
static void		PipeExitHandler(ClientData clientData);
static int		PipeGetHandleProc(ClientData instanceData,
			    int direction, ClientData *handlePtr);
static void		PipeInit(void);
static int		PipeInputProc(ClientData instanceData, char *buf,
			    int toRead, int *errorCode);
static int		PipeOutputProc(ClientData instanceData, char *buf,
			    int toWrite, int *errorCode);
static DWORD WINAPI	PipeReaderThread(LPVOID arg);
static void		PipeSetupProc(ClientData clientData, int flags);
static void		PipeWatchProc(ClientData instanceData, int mask);
static DWORD WINAPI	PipeWriterThread(LPVOID arg);
static void		ProcExitHandler(ClientData clientData);
static int		TempFileName(WCHAR name[MAX_PATH]);
static int		WaitForRead(PipeInfo *infoPtr, int blocking);
d206 2
a207 2
    TCL_CHANNEL_VERSION_2,	/* v2 channel */
    TCL_CLOSE2PROC,		/* Close proc. */
a214 4
    PipeClose2Proc,		/* close2proc */
    PipeBlockModeProc,		/* Set blocking or non-blocking mode.*/
    NULL,			/* flush proc. */
    NULL,			/* handler proc. */
d216 117
d353 1
a353 1
    ThreadSpecificData *tsdPtr;
d355 25
a379 21
    /*
     * Check the initialized flag first, then check again in the mutex.
     * This is a speed enhancement.
     */

    if (!initialized) {
	Tcl_MutexLock(&pipeMutex);
	if (!initialized) {
	    initialized = 1;
	    procList = NULL;
	    Tcl_CreateExitHandler(ProcExitHandler, NULL);
	}
	Tcl_MutexUnlock(&pipeMutex);
    }

    tsdPtr = (ThreadSpecificData *)TclThreadDataKeyGet(&dataKey);
    if (tsdPtr == NULL) {
	tsdPtr = TCL_TSD_INIT(&dataKey);
	tsdPtr->firstPipePtr = NULL;
	Tcl_CreateEventSource(PipeSetupProc, PipeCheckProc, NULL);
	Tcl_CreateThreadExitHandler(PipeExitHandler, NULL);
d401 2
a402 2
PipeExitHandler(
    ClientData clientData)	/* Old window proc */
a404 24
}

/*
 *----------------------------------------------------------------------
 *
 * ProcExitHandler --
 *
 *	This function is called to cleanup the process list before
 *	Tcl is unloaded.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Resets the process list.
 *
 *----------------------------------------------------------------------
 */

static void
ProcExitHandler(
    ClientData clientData)	/* Old window proc */
{
    Tcl_MutexLock(&pipeMutex);
d406 6
a411 1
    Tcl_MutexUnlock(&pipeMutex);
d432 3
a434 3
PipeSetupProc(
    ClientData data,		/* Not used. */
    int flags)			/* Event flags as passed to Tcl_DoOneEvent. */
a437 3
    int block = 1;
    WinFile *filePtr;
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
d444 1
a444 1
     * Look to see if any events are already pending.  If they are, poll.
d447 13
a459 7
    for (infoPtr = tsdPtr->firstPipePtr; infoPtr != NULL; 
	    infoPtr = infoPtr->nextPtr) {
	if (infoPtr->watchMask & TCL_WRITABLE) {
	    filePtr = (WinFile*) infoPtr->writeFile;
	    if (WaitForSingleObject(infoPtr->writable, 0) != WAIT_TIMEOUT) {
		block = 0;
	    }
a460 9
	if (infoPtr->watchMask & TCL_READABLE) {
	    filePtr = (WinFile*) infoPtr->readFile;
	    if (WaitForRead(infoPtr, 0) >= 0) {
		block = 0;
	    }
	}
    }
    if (!block) {
	Tcl_SetMaxBlockTime(&blockTime);
d482 3
a484 3
PipeCheckProc(
    ClientData data,		/* Not used. */
    int flags)			/* Event flags as passed to Tcl_DoOneEvent. */
a487 3
    WinFile *filePtr;
    int needEvent;
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
d494 1
a494 1
     * Queue events for any ready pipes that don't already have events
d498 9
a506 25
    for (infoPtr = tsdPtr->firstPipePtr; infoPtr != NULL; 
	    infoPtr = infoPtr->nextPtr) {
	if (infoPtr->flags & PIPE_PENDING) {
	    continue;
	}
	
	/*
	 * Queue an event if the pipe is signaled for reading or writing.
	 */

	needEvent = 0;
	filePtr = (WinFile*) infoPtr->writeFile;
	if ((infoPtr->watchMask & TCL_WRITABLE) &&
		(WaitForSingleObject(infoPtr->writable, 0) != WAIT_TIMEOUT)) {
	    needEvent = 1;
	}
	
	filePtr = (WinFile*) infoPtr->readFile;
	if ((infoPtr->watchMask & TCL_READABLE) &&
		(WaitForRead(infoPtr, 0) >= 0)) {
	    needEvent = 1;
	}

	if (needEvent) {
	    infoPtr->flags |= PIPE_PENDING;
d518 1
a518 1
 * TclWinMakeFile --
d532 3
a534 3
TclFile
TclWinMakeFile(
    HANDLE handle)		/* Type-specific data. */
d548 31
d599 1
a599 1
    WCHAR name[MAX_PATH];	/* Buffer in which name for temporary 
d602 6
a607 7
    TCHAR *prefix;

    prefix = (tclWinProcs->useWide) ? (TCHAR *) L"TCL" : (TCHAR *) "TCL";
    if ((*tclWinProcs->getTempPathProc)(MAX_PATH, name) != 0) {
	if ((*tclWinProcs->getTempFileNameProc)((TCHAR *) name, prefix, 0, 
		name) != 0) {
	    return 1;
d610 1
a610 9
    if (tclWinProcs->useWide) {
	((WCHAR *) name)[0] = '.';
	((WCHAR *) name)[1] = '\0';
    } else {
	((char *) name)[0] = '.';
	((char *) name)[1] = '\0';
    }
    return (*tclWinProcs->getTempFileNameProc)((TCHAR *) name, prefix, 0, 
	    name);
d616 1
a616 1
 * TclpMakeFile --
d618 3
a620 1
 *	Make a TclFile from a channel.
d623 1
a623 1
 *	Returns a new TclFile or NULL on failure.
d626 1
a626 1
 *	None.
d632 5
a636 3
TclpMakeFile(channel, direction)
    Tcl_Channel channel;	/* Channel to get file from. */
    int direction;		/* Either TCL_READABLE or TCL_WRITABLE. */
d638 1
d641 60
a700 3
    if (Tcl_GetChannelHandle(channel, direction, 
	    (ClientData *) &handle) == TCL_OK) {
	return TclWinMakeFile(handle);
d702 1
a702 1
	return (TclFile) NULL;
d704 6
d731 2
a732 2
    CONST char *path;		/* The name of the file to open. */
    int mode;			/* In what mode to open the file? */
d736 2
a737 3
    Tcl_DString ds;
    TCHAR *nativePath;
    
a780 2
    nativePath = Tcl_WinUtfToTChar(path, -1, &ds);

d787 1
a787 1
	flags = (*tclWinProcs->getFileAttributesProc)(nativePath);
d794 9
d812 2
a813 4
    handle = (*tclWinProcs->createFileProc)(nativePath, accessMode, 
	    shareMode, NULL, createMode, flags, NULL);
    Tcl_DStringFree(&ds);

d815 1
a815 3
	DWORD err;
	
	err = GetLastError();
d831 1
a831 1
    return TclWinMakeFile(handle);
d837 1
a837 1
 * TclpCreateTempFile --
d839 2
a840 3
 *	This function opens a unique file with the property that it
 *	will be deleted when its file handle is closed.  The temporary
 *	file is created in the system temporary directory.
d843 1
a843 1
 *	Returns a valid TclFile, or NULL on failure.
d846 1
a846 1
 *	Creates a new temporary file.
d851 6
a856 3
TclFile
TclpCreateTempFile(contents)
    CONST char *contents;	/* String to write into temp file, or NULL. */
d858 1
a858 4
    WCHAR name[MAX_PATH];
    CONST char *native;
    Tcl_DString dstring;
    HANDLE handle;
d860 4
a863 2
    if (TempFileName(name) == 0) {
	return NULL;
d866 16
a881 6
    handle = (*tclWinProcs->createFileProc)((TCHAR *) name, 
	    GENERIC_READ | GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, 
	    FILE_ATTRIBUTE_TEMPORARY|FILE_FLAG_DELETE_ON_CLOSE, NULL);
    if (handle == INVALID_HANDLE_VALUE) {
	goto error;
    }
d883 2
a884 3
    /*
     * Write the file out, doing line translations on the way.
     */
d886 3
a888 3
    if (contents != NULL) {
	DWORD result, length;
	CONST char *p;
d890 3
a892 79
	/*
	 * Convert the contents from UTF to native encoding
	 */
	native = Tcl_UtfToExternalDString(NULL, contents, -1, &dstring);
	
	for (p = native; *p != '\0'; p++) {
	    if (*p == '\n') {
		length = p - native;
		if (length > 0) {
		    if (!WriteFile(handle, native, length, &result, NULL)) {
			goto error;
		    }
		}
		if (!WriteFile(handle, "\r\n", 2, &result, NULL)) {
		    goto error;
		}
		native = p+1;
	    }
	}
	length = p - native;
	if (length > 0) {
	    if (!WriteFile(handle, native, length, &result, NULL)) {
		goto error;
	    }
	}
	Tcl_DStringFree(&dstring);
	if (SetFilePointer(handle, 0, NULL, FILE_BEGIN) == 0xFFFFFFFF) {
	    goto error;
	}
    }

    return TclWinMakeFile(handle);

  error:
    /* Free the native representation of the contents if necessary */
    if (contents != NULL) {
	Tcl_DStringFree(&dstring);
    }

    TclWinConvertError(GetLastError());
    CloseHandle(handle);
    (*tclWinProcs->deleteFileProc)((TCHAR *) name);
    return NULL;
}

/*
 *----------------------------------------------------------------------
 *
 * TclpCreatePipe --
 *
 *      Creates an anonymous pipe.
 *
 * Results:
 *      Returns 1 on success, 0 on failure. 
 *
 * Side effects:
 *      Creates a pipe.
 *
 *----------------------------------------------------------------------
 */

int
TclpCreatePipe(
    TclFile *readPipe,	/* Location to store file handle for
				 * read side of pipe. */
    TclFile *writePipe)	/* Location to store file handle for
				 * write side of pipe. */
{
    HANDLE readHandle, writeHandle;

    if (CreatePipe(&readHandle, &writeHandle, NULL, 0) != 0) {
	*readPipe = TclWinMakeFile(readHandle);
	*writePipe = TclWinMakeFile(writeHandle);
	return 1;
    }

    TclWinConvertError(GetLastError());
    return 0;
}
d912 2
a913 2
TclpCloseFile(
    TclFile file)	/* The file to close. */
d916 1
d920 6
d927 1
a927 3
	     * Don't close the Win32 handle if the handle is a standard channel
	     * during the exit process.  Otherwise, one thread may kill the
	     * stdio of another.
d930 13
a942 8
	    if (!TclInExit() 
		    || ((GetStdHandle(STD_INPUT_HANDLE) != filePtr->handle)
			    && (GetStdHandle(STD_OUTPUT_HANDLE) != filePtr->handle)
			    && (GetStdHandle(STD_ERROR_HANDLE) != filePtr->handle))) {
		if (CloseHandle(filePtr->handle) == FALSE) {
		    TclWinConvertError(GetLastError());
		    ckfree((char *) filePtr);
		    return -1;
d944 2
d950 1
a950 1
	    panic("TclpCloseFile: unexpected file type");
d977 2
a978 2
TclpGetPid(
    Tcl_Pid pid)		/* The HANDLE of the child process. */
d981 1
a981 2

    Tcl_MutexLock(&pipeMutex);
a983 1
	    Tcl_MutexUnlock(&pipeMutex);
a986 1
    Tcl_MutexUnlock(&pipeMutex);
d997 3
a999 2
 *	asynchronously under Windows NT and Windows 9x, and runs
 *	with the same environment variables as the creating process.
d1008 1
a1008 1
 *	the interp's result if there was a problem creating the child 
d1019 3
a1021 2
TclpCreateProcess(
    Tcl_Interp *interp,		/* Interpreter in which to leave errors that
d1025 2
a1026 2
    int argc,			/* Number of arguments in following array. */
    char **argv,		/* Array of argument strings.  argv[0]
d1031 1
a1031 1
    TclFile inputFile,		/* If non-NULL, gives the file to use as
d1035 1
a1035 1
    TclFile outputFile,		/* If non-NULL, gives the file that
d1040 1
a1040 1
    TclFile errorFile,		/* If non-NULL, gives the file that
d1045 1
a1045 1
    Tcl_Pid *pidPtr)		/* If this procedure is successful, pidPtr
d1050 2
a1051 2
    Tcl_DString cmdLine;	/* Complete command line (TCHAR). */
    STARTUPINFOA startInfo;
d1055 2
a1056 1
    char execPath[MAX_PATH * TCL_UTF_MAX];
d1059 3
a1061 1
    PipeInit();
d1067 2
d1072 155
d1329 1
a1329 1
	    startInfo.hStdOutput = CreateFileA("NUL:", GENERIC_WRITE, 0,
d1349 1
a1349 1
	startInfo.hStdError = CreateFileA("NUL:", GENERIC_WRITE, 0,
d1436 2
a1437 1
	    Tcl_DStringAppend(&cmdLine, "tclpip" STRINGIFY(TCL_MAJOR_VERSION) 
d1461 1
a1461 1
    BuildCommandLine(execPath, argc, argv, &cmdLine);
d1463 2
a1464 3
    if ((*tclWinProcs->createProcessProc)(NULL, 
	    (TCHAR *) Tcl_DStringValue(&cmdLine), NULL, NULL, TRUE, 
	    createFlags, NULL, NULL, &startInfo, &procInfo) == 0) {
d1466 1
a1466 1
	Tcl_AppendResult(interp, "couldn't execute \"", argv[0],
a1470 5
    /*
     * This wait is used to force the OS to give some time to the DOS
     * process.
     */

d1472 1
a1472 1
	WaitForSingleObject(procInfo.hProcess, 50);
d1489 5
a1493 1
	TclWinAddProcess(procInfo.hProcess, procInfo.dwProcessId);
d1532 1
a1532 3
    HANDLE handle;
    
    handle = CreateFileA("CONOUT$", GENERIC_WRITE, FILE_SHARE_WRITE,
d1580 1
a1580 1
ApplicationType(interp, originalName, fullName)
d1583 1
a1583 1
    char fullName[];		/* Filled with complete path to 
d1586 1
a1586 1
    int applType, i, nameLen, found;
d1588 1
a1588 2
    TCHAR *rest;
    char *ext;
d1590 1
a1590 1
    DWORD attr, read;
a1591 3
    Tcl_DString nameBuf, ds;
    TCHAR *nativeName;
    WCHAR nativeFullPath[MAX_PATH];
a1607 4
    Tcl_DStringInit(&nameBuf);
    Tcl_DStringAppend(&nameBuf, originalName, -1);
    nameLen = Tcl_DStringLength(&nameBuf);

d1609 4
a1612 10
	Tcl_DStringSetLength(&nameBuf, nameLen);
	Tcl_DStringAppend(&nameBuf, extensions[i], -1);
        nativeName = Tcl_WinUtfToTChar(Tcl_DStringValue(&nameBuf), 
		Tcl_DStringLength(&nameBuf), &ds);
	found = (*tclWinProcs->searchPathProc)(NULL, nativeName, NULL, 
		MAX_PATH, nativeFullPath, &rest);
	Tcl_DStringFree(&ds);
	if (found == 0) {
	    continue;
	}
d1619 1
a1619 2
	attr = (*tclWinProcs->getFileAttributesProc)((TCHAR *) nativeFullPath);
	if ((attr == 0xffffffff) || (attr & FILE_ATTRIBUTE_DIRECTORY)) {
a1621 2
	strcpy(fullName, Tcl_WinTCharToUtf((TCHAR *) nativeFullPath, -1, &ds));
	Tcl_DStringFree(&ds);
d1623 2
a1624 2
	ext = strrchr(fullName, '.');
	if ((ext != NULL) && (stricmp(ext, ".bat") == 0)) {
d1628 3
a1630 4
	
	hFile = (*tclWinProcs->createFileProc)((TCHAR *) nativeFullPath, 
		GENERIC_READ, FILE_SHARE_READ, NULL, OPEN_EXISTING, 
		FILE_ATTRIBUTE_NORMAL, NULL);
d1647 1
a1647 1
	    if ((ext != NULL) && (strcmp(ext, ".com") == 0)) {
a1690 1
    Tcl_DStringFree(&nameBuf);
d1707 1
a1707 4
	(*tclWinProcs->getShortPathNameProc)((TCHAR *) nativeFullPath, 
		nativeFullPath, MAX_PATH);
	strcpy(fullName, Tcl_WinTCharToUtf((TCHAR *) nativeFullPath, -1, &ds));
	Tcl_DStringFree(&ds);
d1732 5
a1736 7
BuildCommandLine(
    CONST char *executable,	/* Full path of executable (including 
				 * extension).  Replacement for argv[0]. */
    int argc,			/* Number of arguments. */
    char **argv,		/* Argument strings in UTF. */
    Tcl_DString *linePtr)	/* Initialized Tcl_DString that receives the
				 * command line (TCHAR). */
d1738 1
a1738 1
    CONST char *arg, *start, *special;
a1739 3
    Tcl_DString ds;

    Tcl_DStringInit(&ds);
a1740 6
    /*
     * Prime the path.
     */
    
    Tcl_DStringAppend(&ds, Tcl_DStringValue(linePtr), -1);
    
d1742 2
a1743 5
	if (i == 0) {
	    arg = executable;
	} else {
	    arg = argv[i];
	    Tcl_DStringAppend(&ds, " ", 1);
d1751 1
a1751 1
		if (isspace(*start)) { /* INTL: ISO space. */
d1758 1
a1758 1
	    Tcl_DStringAppend(&ds, "\"", 1);
d1761 2
a1762 2
	start = arg;	    
	for (special = arg; ; ) {
d1765 1
a1765 1
		Tcl_DStringAppend(&ds, start, special - start);
d1775 1
a1775 1
			Tcl_DStringAppend(&ds, start, special - start);
d1782 1
a1782 1
		Tcl_DStringAppend(&ds, start, special - start);
d1786 2
a1787 2
		Tcl_DStringAppend(&ds, start, special - start);
		Tcl_DStringAppend(&ds, "\\\"", 2);
d1795 1
a1795 1
	Tcl_DStringAppend(&ds, start, special - start);
d1797 75
a1871 1
	    Tcl_DStringAppend(&ds, "\"", 1);
a1873 2
    Tcl_WinUtfToTChar(Tcl_DStringValue(&ds), Tcl_DStringLength(&ds), linePtr);
    Tcl_DStringFree(&ds);
d1895 4
a1898 4
TclpCreateCommandChannel(
    TclFile readFile,		/* If non-null, gives the file for reading. */
    TclFile writeFile,		/* If non-null, gives the file for writing. */
    TclFile errorFile,		/* If non-null, gives the file where errors
d1900 2
a1901 2
    int numPids,		/* The number of pids in the pid array. */
    Tcl_Pid *pidPtr)		/* An array of process identifiers. */
d1903 1
a1903 1
    char channelName[16 + TCL_INTEGER_SPACE];
a1904 1
    DWORD id;
d1907 3
a1909 1
    PipeInit();
a1912 1
    infoPtr->readFlags = 0;
d1918 3
a1920 3
    infoPtr->writeBuf = 0;
    infoPtr->writeBufLen = 0;
    infoPtr->writeError = 0;
d1928 7
a1934 1
	channelId = (int) ((WinFile*)readFile)->handle;
a1943 3

    infoPtr->threadId = Tcl_GetCurrentThread();

a1944 9
	/*
	 * Start the background reader thread.
	 */

	infoPtr->readable = CreateEvent(NULL, TRUE, TRUE, NULL);
	infoPtr->startReader = CreateEvent(NULL, FALSE, FALSE, NULL);
	infoPtr->readThread = CreateThread(NULL, 8000, PipeReaderThread,
		infoPtr, 0, &id);
	SetThreadPriority(infoPtr->readThread, THREAD_PRIORITY_HIGHEST); 
a1945 2
    } else {
	infoPtr->readThread = 0;
a1947 9
	/*
	 * Start the background writeer thwrite.
	 */

	infoPtr->writable = CreateEvent(NULL, TRUE, TRUE, NULL);
	infoPtr->startWriter = CreateEvent(NULL, FALSE, FALSE, NULL);
	infoPtr->writeThread = CreateThread(NULL, 8000, PipeWriterThread,
		infoPtr, 0, &id);
	SetThreadPriority(infoPtr->readThread, THREAD_PRIORITY_HIGHEST); 
a1954 2
     * Use the pointer to keep the channel names unique, in case
     * channels share handles (stdin/stdout).
d1957 1
a1957 1
    wsprintfA(channelName, "file%lx", infoPtr);
d1980 1
a1980 1
 *	the interp's result.
d1986 1
a1986 1
 *	Modifies the interp's result.
d1992 3
a1994 3
TclGetAndDetachPids(
    Tcl_Interp *interp,
    Tcl_Channel chan)
d1999 1
a1999 1
    char buf[TCL_INTEGER_SPACE];
d2012 1
a2012 1
        wsprintfA(buf, "%lu", TclpGetPid(pipePtr->pidPtr[i]));
d2039 3
a2041 3
PipeBlockModeProc(
    ClientData instanceData,	/* Instance data for channel. */
    int mode)			/* TCL_MODE_BLOCKING or
d2054 1
a2054 1
	infoPtr->flags |= PIPE_ASYNC;
d2056 1
a2056 1
	infoPtr->flags &= ~(PIPE_ASYNC);
d2064 1
a2064 1
 * PipeClose2Proc --
d2078 3
a2080 4
PipeClose2Proc(
    ClientData instanceData,	/* Pointer to PipeInfo structure. */
    Tcl_Interp *interp,		/* For error reporting. */
    int flags)			/* Flags that indicate which side to close. */
a2085 1
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
d2087 3
a2089 8
    errorCode = 0;
    if ((!flags || (flags == TCL_CLOSE_READ))
	    && (pipePtr->readFile != NULL)) {
	/*
	 * Clean up the background thread if necessary.  Note that this
	 * must be done before we can close the file, since the 
	 * thread may be blocking trying to read from the pipe.
	 */
d2091 7
a2097 10
	if (pipePtr->readThread) {
	    /*
	     * Forcibly terminate the background thread.  We cannot rely on the
	     * thread to cleanly terminate itself because we have no way of
	     * closing the pipe handle without blocking in the case where the
	     * thread is in the middle of an I/O operation.  Note that we need
	     * to guard against terminating the thread while it is in the
	     * middle of Tcl_ThreadAlert because it won't be able to release
	     * the notifier lock.
	     */
d2099 2
a2100 16
	    Tcl_MutexLock(&pipeMutex);
	    TerminateThread(pipePtr->readThread, 0);

	    /*
	     * Wait for the thread to terminate.  This ensures that we are
	     * completely cleaned up before we leave this function. 
	     */

	    WaitForSingleObject(pipePtr->readThread, INFINITE);
	    Tcl_MutexUnlock(&pipeMutex);

	    CloseHandle(pipePtr->readThread);
	    CloseHandle(pipePtr->readable);
	    CloseHandle(pipePtr->startReader);
	    pipePtr->readThread = NULL;
	}
a2103 2
	pipePtr->validMask &= ~TCL_READABLE;
	pipePtr->readFile = NULL;
d2105 1
a2105 38
    if ((!flags || (flags & TCL_CLOSE_WRITE))
	    && (pipePtr->writeFile != NULL)) {
	/*
	 * Wait for the writer thread to finish the current buffer, then
	 * terminate the thread and close the handles.  If the channel is
	 * nonblocking, there should be no pending write operations.
	 */

	if (pipePtr->writeThread) {
	    WaitForSingleObject(pipePtr->writable, INFINITE);

	    /*
	     * Forcibly terminate the background thread.  We cannot rely on the
	     * thread to cleanly terminate itself because we have no way of
	     * closing the pipe handle without blocking in the case where the
	     * thread is in the middle of an I/O operation.  Note that we need
	     * to guard against terminating the thread while it is in the
	     * middle of Tcl_ThreadAlert because it won't be able to release
	     * the notifier lock.
	     */

	    Tcl_MutexLock(&pipeMutex);
	    TerminateThread(pipePtr->writeThread, 0);

	    /*
	     * Wait for the thread to terminate.  This ensures that we are
	     * completely cleaned up before we leave this function. 
	     */

	    WaitForSingleObject(pipePtr->writeThread, INFINITE);
	    Tcl_MutexUnlock(&pipeMutex);


	    CloseHandle(pipePtr->writeThread);
	    CloseHandle(pipePtr->writable);
	    CloseHandle(pipePtr->startWriter);
	    pipePtr->writeThread = NULL;
	}
a2110 2
	pipePtr->validMask &= ~TCL_WRITABLE;
	pipePtr->writeFile = NULL;
d2112 1
a2112 24

    pipePtr->watchMask &= pipePtr->validMask;

    /*
     * Don't free the channel if any of the flags were set.
     */

    if (flags) {
	return errorCode;
    }

    /*
     * Remove the file from the list of watched files.
     */

    for (nextPtrPtr = &(tsdPtr->firstPipePtr), infoPtr = *nextPtrPtr;
	    infoPtr != NULL;
	    nextPtrPtr = &infoPtr->nextPtr, infoPtr = *nextPtrPtr) {
	if (infoPtr == (PipeInfo *)pipePtr) {
	    *nextPtrPtr = infoPtr->nextPtr;
	    break;
	}
    }

d2115 2
a2116 1
     * routine.
d2121 1
d2123 10
a2132 4
	filePtr = (WinFile*)pipePtr->errorFile;
	errChan = Tcl_MakeFileChannel((ClientData) filePtr->handle,
		TCL_READABLE);
	ckfree((char *) filePtr);
a2135 1

a2137 1

d2142 10
a2151 2
    if (pipePtr->writeBuf != NULL) {
	ckfree(pipePtr->writeBuf);
a2153 2
    ckfree((char*) pipePtr);

d2179 4
a2182 4
PipeInputProc(
    ClientData instanceData,		/* Pipe state. */
    char *buf,				/* Where to store data read. */
    int bufSize,			/* How much space is available
d2184 1
a2184 1
    int *errorCode)			/* Where to store error code. */
d2188 9
a2196 2
    DWORD count, bytesRead = 0;
    int result;
d2199 18
a2216 3
    /*
     * Synchronize with the reader thread.
     */
d2218 4
a2221 1
    result = WaitForRead(infoPtr, (infoPtr->flags & PIPE_ASYNC) ? 0 : 1);
d2223 5
a2227 3
    /*
     * If an error occurred, return immediately.
     */
d2229 9
a2237 3
    if (result == -1) {
	*errorCode = errno;
	return -1;
d2240 12
a2251 18
    if (infoPtr->readFlags & PIPE_EXTRABYTE) {
	/*
	 * The reader thread consumed 1 byte as a side effect of
	 * waiting so we need to move it into the buffer.
	 */

	*buf = infoPtr->extraByte;
	infoPtr->readFlags &= ~PIPE_EXTRABYTE;
	buf++;
	bufSize--;
	bytesRead = 1;

	/*
	 * If further read attempts would block, return what we have.
	 */

	if (result == 0) {
	    return bytesRead;
d2256 4
a2259 3
     * Attempt to read bufSize bytes.  The read will return immediately
     * if there is any data available.  Otherwise it will block until
     * at least one byte is available or an EOF occurs.
d2262 9
a2270 7
    if (ReadFile(filePtr->handle, (LPVOID) buf, (DWORD) bufSize, &count,
	    (LPOVERLAPPED) NULL) == TRUE) {
	return bytesRead + count;
    } else if (bytesRead) {
	/*
	 * Ignore errors if we have data to return.
	 */
d2272 1
a2272 2
	return bytesRead;
    }
d2274 1
d2276 3
a2279 1
	infoPtr->readFlags |= PIPE_EOF;
d2305 5
a2309 5
PipeOutputProc(
    ClientData instanceData,		/* Pipe state. */
    char *buf,				/* The data buffer. */
    int toWrite,			/* How many bytes to write? */
    int *errorCode)			/* Where to store error code. */
d2313 1
a2313 1
    DWORD bytesWritten, timeout;
d2316 8
a2323 54
    timeout = (infoPtr->flags & PIPE_ASYNC) ? 0 : INFINITE;
    if (WaitForSingleObject(infoPtr->writable, timeout) == WAIT_TIMEOUT) {
	/*
	 * The writer thread is blocked waiting for a write to complete
	 * and the channel is in non-blocking mode.
	 */

	errno = EAGAIN;
	goto error;
    }
    
    /*
     * Check for a background error on the last write.
     */

    if (infoPtr->writeError) {
	TclWinConvertError(infoPtr->writeError);
	infoPtr->writeError = 0;
	goto error;
    }

    if (infoPtr->flags & PIPE_ASYNC) {
	/*
	 * The pipe is non-blocking, so copy the data into the output
	 * buffer and restart the writer thread.
	 */

	if (toWrite > infoPtr->writeBufLen) {
	    /*
	     * Reallocate the buffer to be large enough to hold the data.
	     */

	    if (infoPtr->writeBuf) {
		ckfree(infoPtr->writeBuf);
	    }
	    infoPtr->writeBufLen = toWrite;
	    infoPtr->writeBuf = ckalloc(toWrite);
	}
	memcpy(infoPtr->writeBuf, buf, toWrite);
	infoPtr->toWrite = toWrite;
	ResetEvent(infoPtr->writable);
	SetEvent(infoPtr->startWriter);
	bytesWritten = toWrite;
    } else {
	/*
	 * In the blocking case, just try to write the buffer directly.
	 * This avoids an unnecessary copy.
	 */

	if (WriteFile(filePtr->handle, (LPVOID) buf, (DWORD) toWrite,
		&bytesWritten, (LPOVERLAPPED) NULL) == FALSE) {
	    TclWinConvertError(GetLastError());
	    goto error;
	}
a2325 5

    error:
    *errorCode = errno;
    return -1;

d2350 3
a2352 3
PipeEventProc(
    Tcl_Event *evPtr,		/* Event to service. */
    int flags)			/* Flags that indicate what events to
d2359 1
a2359 1
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
d2372 1
a2372 2
    for (infoPtr = tsdPtr->firstPipePtr; infoPtr != NULL;
	    infoPtr = infoPtr->nextPtr) {
d2374 1
a2374 1
	    infoPtr->flags &= ~(PIPE_PENDING);
d2388 1
a2388 1
     * Check to see if the pipe is readable.  Note
d2390 1
a2390 1
     * as being writable unless we have detected EOF.
d2393 2
a2394 6
    filePtr = (WinFile*) ((PipeInfo*)infoPtr)->writeFile;
    mask = 0;
    if ((infoPtr->watchMask & TCL_WRITABLE) &&
	    (WaitForSingleObject(infoPtr->writable, 0) != WAIT_TIMEOUT)) {
	mask = TCL_WRITABLE;
    }
d2396 6
a2401 5
    filePtr = (WinFile*) ((PipeInfo*)infoPtr)->readFile;
    if ((infoPtr->watchMask & TCL_READABLE) &&
	    (WaitForRead(infoPtr, 0) >= 0)) {
	if (infoPtr->readFlags & PIPE_EOF) {
	    mask = TCL_READABLE;
d2403 1
a2403 1
	    mask |= TCL_READABLE;
d2405 19
d2452 3
a2454 3
PipeWatchProc(
    ClientData instanceData,		/* Pipe state. */
    int mask)				/* What events to watch for, OR-ed
a2460 1
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
d2463 2
a2464 3
     * Since most of the work is handled by the background threads,
     * we just need to update the watchMask and then force the notifier
     * to poll once. 
d2470 14
d2485 2
a2486 2
	    infoPtr->nextPtr = tsdPtr->firstPipePtr;
	    tsdPtr->firstPipePtr = infoPtr;
d2495 1
a2495 1
	    for (nextPtrPtr = &(tsdPtr->firstPipePtr), ptr = *nextPtrPtr;
d2526 4
a2529 4
PipeGetHandleProc(
    ClientData instanceData,	/* The pipe state. */
    int direction,		/* TCL_READABLE or TCL_WRITABLE */
    ClientData *handlePtr)	/* Where to store the handle.  */
d2536 10
d2577 4
a2580 4
Tcl_WaitPid(
    Tcl_Pid pid,
    int *statPtr,
    int options)
d2587 3
a2589 1
    PipeInit();
a2603 1
    Tcl_MutexLock(&pipeMutex);
a2610 1
    Tcl_MutexUnlock(&pipeMutex);
d2616 1
a2616 1
    		     
d2642 2
a2643 2
#ifdef __CYGWIN__
       /* A Cygwin program that exits because of a signal will set
d2646 5
a2650 5
       if ((*statPtr & 0x10000) != 0
           && (*statPtr & 0xff00) != 0
           && (*statPtr & ~ 0x1ff00) == 0) {
           *statPtr = (*statPtr >> 8) & 0xff;
       } else
a2673 32
 * TclWinAddProcess --
 *
 *     Add a process to the process list so that we can use
 *     Tcl_WaitPid on the process.
 *
 * Results:
 *     None
 *
 * Side effects:
 *	Adds the specified process handle to the process list so
 *	Tcl_WaitPid knows about it.
 *
 *----------------------------------------------------------------------
 */

void
TclWinAddProcess(hProcess, id)
    HANDLE hProcess;           /* Handle to process */
    DWORD id;                  /* Global process identifier */
{
    ProcInfo *procPtr = (ProcInfo *) ckalloc(sizeof(ProcInfo));
    procPtr->hProcess = hProcess;
    procPtr->dwProcessId = id;
    Tcl_MutexLock(&pipeMutex);
    procPtr->nextPtr = procList;
    procList = procPtr;
    Tcl_MutexUnlock(&pipeMutex);
}

/*
 *----------------------------------------------------------------------
 *
d2690 5
a2694 5
Tcl_PidObjCmd(
    ClientData dummy,		/* Not used. */
    Tcl_Interp *interp,		/* Current interpreter. */
    int objc,			/* Number of arguments. */
    Tcl_Obj *CONST *objv)	/* Argument strings. */
d2701 1
a2701 1
    char buf[TCL_INTEGER_SPACE];
d2709 1
a2709 1
	wsprintfA(buf, "%lu", (unsigned long) getpid());
d2725 1
a2725 1
	    wsprintfA(buf, "%lu", TclpGetPid(pipePtr->pidPtr[i]));
a2731 295

/*
 *----------------------------------------------------------------------
 *
 * WaitForRead --
 *
 *	Wait until some data is available, the pipe is at
 *	EOF or the reader thread is blocked waiting for data (if the
 *	channel is in non-blocking mode).
 *
 * Results:
 *	Returns 1 if pipe is readable.  Returns 0 if there is no data
 *	on the pipe, but there is buffered data.  Returns -1 if an
 *	error occurred.  If an error occurred, the threads may not
 *	be synchronized.
 *
 * Side effects:
 *	Updates the shared state flags and may consume 1 byte of data
 *	from the pipe.  If no error occurred, the reader thread is
 *	blocked waiting for a signal from the main thread.
 *
 *----------------------------------------------------------------------
 */

static int
WaitForRead(
    PipeInfo *infoPtr,		/* Pipe state. */
    int blocking)		/* Indicates whether call should be
				 * blocking or not. */
{
    DWORD timeout, count;
    HANDLE *handle = ((WinFile *) infoPtr->readFile)->handle;

    while (1) {
	/*
	 * Synchronize with the reader thread.
	 */
       
	timeout = blocking ? INFINITE : 0;
	if (WaitForSingleObject(infoPtr->readable, timeout) == WAIT_TIMEOUT) {
	    /*
	     * The reader thread is blocked waiting for data and the channel
	     * is in non-blocking mode.
	     */

	    errno = EAGAIN;
	    return -1;
	}

	/*
	 * At this point, the two threads are synchronized, so it is safe
	 * to access shared state.
	 */


	/*
	 * If the pipe has hit EOF, it is always readable.
	 */

	if (infoPtr->readFlags & PIPE_EOF) {
	    return 1;
	}
    
	/*
	 * Check to see if there is any data sitting in the pipe.
	 */

	if (PeekNamedPipe(handle, (LPVOID) NULL, (DWORD) 0,
		(LPDWORD) NULL, &count, (LPDWORD) NULL) != TRUE) {
	    TclWinConvertError(GetLastError());
	    /*
	     * Check to see if the peek failed because of EOF.
	     */

	    if (errno == EPIPE) {
		infoPtr->readFlags |= PIPE_EOF;
		return 1;
	    }

	    /*
	     * Ignore errors if there is data in the buffer.
	     */

	    if (infoPtr->readFlags & PIPE_EXTRABYTE) {
		return 0;
	    } else {
		return -1;
	    }
	}

	/*
	 * We found some data in the pipe, so it must be readable.
	 */

	if (count > 0) {
	    return 1;
	}

	/*
	 * The pipe isn't readable, but there is some data sitting
	 * in the buffer, so return immediately.
	 */

	if (infoPtr->readFlags & PIPE_EXTRABYTE) {
	    return 0;
	}

	/*
	 * There wasn't any data available, so reset the thread and
	 * try again.
	 */
    
	ResetEvent(infoPtr->readable);
	SetEvent(infoPtr->startReader);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * PipeReaderThread --
 *
 *	This function runs in a separate thread and waits for input
 *	to become available on a pipe.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Signals the main thread when input become available.  May
 *	cause the main thread to wake up by posting a message.  May
 *	consume one byte from the pipe for each wait operation.
 *
 *----------------------------------------------------------------------
 */

static DWORD WINAPI
PipeReaderThread(LPVOID arg)
{
    PipeInfo *infoPtr = (PipeInfo *)arg;
    HANDLE *handle = ((WinFile *) infoPtr->readFile)->handle;
    DWORD count, err;
    int done = 0;

    while (!done) {
	/*
	 * Wait for the main thread to signal before attempting to wait.
	 */

	WaitForSingleObject(infoPtr->startReader, INFINITE);

	/*
	 * Try waiting for 0 bytes.  This will block until some data is
	 * available on NT, but will return immediately on Win 95.  So,
	 * if no data is available after the first read, we block until
	 * we can read a single byte off of the pipe.
	 */

	if ((ReadFile(handle, NULL, 0, &count, NULL) == FALSE)
		|| (PeekNamedPipe(handle, NULL, 0, NULL, &count,
			NULL) == FALSE)) {
	    /*
	     * The error is a result of an EOF condition, so set the
	     * EOF bit before signalling the main thread.
	     */

	    err = GetLastError();
	    if (err == ERROR_BROKEN_PIPE) {
		infoPtr->readFlags |= PIPE_EOF;
		done = 1;
	    } else if (err == ERROR_INVALID_HANDLE) {
		break;
	    }
	} else if (count == 0) {
	    if (ReadFile(handle, &(infoPtr->extraByte), 1, &count, NULL)
		    != FALSE) {
		/*
		 * One byte was consumed as a side effect of waiting
		 * for the pipe to become readable.
		 */

		infoPtr->readFlags |= PIPE_EXTRABYTE;
	    } else {
		err = GetLastError();
		if (err == ERROR_BROKEN_PIPE) {
		    /*
		     * The error is a result of an EOF condition, so set the
		     * EOF bit before signalling the main thread.
		     */

		    infoPtr->readFlags |= PIPE_EOF;
		    done = 1;
		} else if (err == ERROR_INVALID_HANDLE) {
		    break;
		}
	    }
	}

		
	/*
	 * Signal the main thread by signalling the readable event and
	 * then waking up the notifier thread.
	 */

	SetEvent(infoPtr->readable);
	
	/*
	 * Alert the foreground thread.  Note that we need to treat this like
	 * a critical section so the foreground thread does not terminate
	 * this thread while we are holding a mutex in the notifier code.
	 */

	Tcl_MutexLock(&pipeMutex);
	Tcl_ThreadAlert(infoPtr->threadId);
	Tcl_MutexUnlock(&pipeMutex);
    }
    return 0;
}

/*
 *----------------------------------------------------------------------
 *
 * PipeWriterThread --
 *
 *	This function runs in a separate thread and writes data
 *	onto a pipe.
 *
 * Results:
 *	Always returns 0.
 *
 * Side effects:
 *	Signals the main thread when an output operation is completed.
 *	May cause the main thread to wake up by posting a message.  
 *
 *----------------------------------------------------------------------
 */

static DWORD WINAPI
PipeWriterThread(LPVOID arg)
{

    PipeInfo *infoPtr = (PipeInfo *)arg;
    HANDLE *handle = ((WinFile *) infoPtr->writeFile)->handle;
    DWORD count, toWrite;
    char *buf;
    int done = 0;

    while (!done) {
	/*
	 * Wait for the main thread to signal before attempting to write.
	 */

	WaitForSingleObject(infoPtr->startWriter, INFINITE);

	buf = infoPtr->writeBuf;
	toWrite = infoPtr->toWrite;

	/*
	 * Loop until all of the bytes are written or an error occurs.
	 */

	while (toWrite > 0) {
	    if (WriteFile(handle, buf, toWrite, &count, NULL) == FALSE) {
		infoPtr->writeError = GetLastError();
		done = 1; 
		break;
	    } else {
		toWrite -= count;
		buf += count;
	    }
	}
	
	/*
	 * Signal the main thread by signalling the writable event and
	 * then waking up the notifier thread.
	 */

	SetEvent(infoPtr->writable);

	/*
	 * Alert the foreground thread.  Note that we need to treat this like
	 * a critical section so the foreground thread does not terminate
	 * this thread while we are holding a mutex in the notifier code.
	 */

	Tcl_MutexLock(&pipeMutex);
	Tcl_ThreadAlert(infoPtr->threadId);
	Tcl_MutexUnlock(&pipeMutex);
    }
    return 0;
}




@


1.1.1.3
log
@import tcl 8.4.0
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tclWinPipe.c,v 1.25 2002/06/17 20:05:49 andreas_kupries Exp $
a125 2
    HANDLE stopReader;		/* Manual-reset event used to alert the reader
				 * thread to fall-out and exit */
d181 1
a181 1
			    CONST char **argv, Tcl_DString *linePtr);
d194 2
a195 2
static int		PipeOutputProc(ClientData instanceData,
			    CONST char *buf, int toWrite, int *errorCode);
d579 1
a579 1
    CONST TCHAR *nativePath;
a767 28
 * TclpTempFileName --
 *
 *	This function returns a unique filename.
 *
 * Results:
 *	Returns a valid Tcl_Obj* with refCount 0, or NULL on failure.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_Obj* 
TclpTempFileName()
{
    WCHAR fileName[MAX_PATH];

    if (TempFileName(fileName) == 0) {
	return NULL;
    }

    return TclpNativeToNormalized((ClientData) fileName);
}

/*
 *----------------------------------------------------------------------
 *
d835 1
a835 2
		if (filePtr->handle != NULL &&
			CloseHandle(filePtr->handle) == FALSE) {
d921 1
a921 1
    CONST char **argv,		/* Array of argument strings.  argv[0]
d1199 1
a1199 1
	    (DWORD) createFlags, NULL, NULL, &startInfo, &procInfo) == 0) {
d1332 1
a1332 1
    CONST TCHAR *nativeName;
d1403 1
a1403 1
	    if ((ext != NULL) && (stricmp(ext, ".com") == 0)) {
d1496 1
a1496 1
    CONST char **argv,		/* Argument strings in UTF. */
d1521 1
a1521 1
	if (arg[0] == '\0') {
d1524 1
a1524 1
	    for (start = arg; *start != '\0'; start++) {
a1563 5
	    if (*special == '{') {
		Tcl_DStringAppend(&ds, start, special - start);
		Tcl_DStringAppend(&ds, "\\{", 2);
		start = special + 1;
	    }
a1573 1
    Tcl_DStringFree(linePtr);
d1650 1
a1650 2
	infoPtr->stopReader = CreateEvent(NULL, TRUE, FALSE, NULL);
	infoPtr->readThread = CreateThread(NULL, 512, PipeReaderThread,
d1659 1
a1659 1
	 * Start the background writer thread.
d1664 1
a1664 1
	infoPtr->writeThread = CreateThread(NULL, 512, PipeWriterThread,
a1808 1
    DWORD exitCode;
d1821 7
a1827 2
	     * The thread may already have closed on it's own.  Check it's
	     * exit code.
d1830 2
a1831 1
	    GetExitCodeThread(pipePtr->readThread, &exitCode);
d1833 4
a1836 6
	    if (exitCode == STILL_ACTIVE) {
		/*
		 * Set the stop event so that if the reader thread is blocked
		 * in PipeReaderThread on WaitForMultipleEvents, it will exit
		 * cleanly.
		 */
d1838 2
a1839 35
		SetEvent(pipePtr->stopReader);

		/*
		 * Wait at most 10 milliseconds for the reader thread to close.
		 */

		WaitForSingleObject(pipePtr->readThread, 10);
		GetExitCodeThread(pipePtr->readThread, &exitCode);

		if (exitCode == STILL_ACTIVE) {
		    /*
		     * The thread must be blocked waiting for the pipe to
		     * become readable in ReadFile().  There isn't a clean way
		     * to exit the thread from this condition.  We should
		     * terminate the child process instead to get the reader
		     * thread to fall out of ReadFile with a FALSE.  (below) is
		     * not the correct way to do this, but will stay here until
		     * a better solution is found.
		     *
		     * Note that we need to guard against terminating the
		     * thread while it is in the middle of Tcl_ThreadAlert
		     * because it won't be able to release the notifier lock.
		     */

		    Tcl_MutexLock(&pipeMutex);

		    /* BUG: this leaks memory */
		    TerminateThread(pipePtr->readThread, 0);

		    /* Wait for the thread to terminate. */
		    WaitForSingleObject(pipePtr->readThread, INFINITE);

		    Tcl_MutexUnlock(&pipeMutex);
		}
	    }
a1843 1
	    CloseHandle(pipePtr->stopReader);
d2072 1
a2072 1
    CONST char *buf,			/* The data buffer. */
d2117 1
a2117 1
	    infoPtr->writeBuf = ckalloc((unsigned int) toWrite);
d2119 1
a2119 1
	memcpy(infoPtr->writeBuf, buf, (size_t) toWrite);
d2362 1
a2362 1
    DWORD flags;
d2421 10
d2674 1
a2674 3
 *	consume one byte from the pipe for each wait operation.  Will
 *	cause a memory leak of ~4k, if forcefully terminated with
 *	TerminateThread().
a2685 5
    HANDLE wEvents[2];
    DWORD dwWait;

    wEvents[0] = infoPtr->stopReader;
    wEvents[1] = infoPtr->startReader;
d2689 1
a2689 2
	 * Wait for the main thread to signal before attempting to wait
	 * on the pipe becoming readable.
d2692 1
a2692 10
	dwWait = WaitForMultipleObjects(2, wEvents, FALSE, INFINITE);

	if (dwWait != (WAIT_OBJECT_0 + 1)) {
	    /*
	     * The start event was not signaled.  It might be the stop event
	     * or an error, so exit.
	     */

	    return 0;
	}
d2834 3
@


