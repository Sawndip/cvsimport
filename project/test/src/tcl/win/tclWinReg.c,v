head	1.6;
access;
symbols
	sid-snapshot-20180601:1.6
	sid-snapshot-20180501:1.6
	sid-snapshot-20180401:1.6
	sid-snapshot-20180301:1.6
	sid-snapshot-20180201:1.6
	sid-snapshot-20180101:1.6
	sid-snapshot-20171201:1.6
	sid-snapshot-20171101:1.6
	sid-snapshot-20171001:1.6
	sid-snapshot-20170901:1.6
	sid-snapshot-20170801:1.6
	sid-snapshot-20170701:1.6
	sid-snapshot-20170601:1.6
	sid-snapshot-20170501:1.6
	sid-snapshot-20170401:1.6
	sid-snapshot-20170301:1.6
	sid-snapshot-20170201:1.6
	sid-snapshot-20170101:1.6
	sid-snapshot-20161201:1.6
	sid-snapshot-20161101:1.6
	sid-snapshot-20160901:1.6
	sid-snapshot-20160801:1.6
	sid-snapshot-20160701:1.6
	sid-snapshot-20160601:1.6
	sid-snapshot-20160501:1.6
	sid-snapshot-20160401:1.6
	sid-snapshot-20160301:1.6
	sid-snapshot-20160201:1.6
	sid-snapshot-20160101:1.6
	sid-snapshot-20151201:1.6
	sid-snapshot-20151101:1.6
	sid-snapshot-20151001:1.6
	sid-snapshot-20150901:1.6
	sid-snapshot-20150801:1.6
	sid-snapshot-20150701:1.6
	sid-snapshot-20150601:1.6
	sid-snapshot-20150501:1.6
	sid-snapshot-20150401:1.6
	sid-snapshot-20150301:1.6
	sid-snapshot-20150201:1.6
	sid-snapshot-20150101:1.6
	sid-snapshot-20141201:1.6
	sid-snapshot-20141101:1.6
	sid-snapshot-20141001:1.6
	sid-snapshot-20140901:1.6
	sid-snapshot-20140801:1.6
	sid-snapshot-20140701:1.6
	sid-snapshot-20140601:1.6
	sid-snapshot-20140501:1.6
	sid-snapshot-20140401:1.6
	sid-snapshot-20140301:1.6
	sid-snapshot-20140201:1.6
	sid-snapshot-20140101:1.6
	sid-snapshot-20131201:1.6
	sid-snapshot-20131101:1.6
	sid-snapshot-20131001:1.6
	sid-snapshot-20130901:1.6
	sid-snapshot-20130801:1.6
	sid-snapshot-20130701:1.6
	sid-snapshot-20130601:1.6
	insight_7_6-2013-04-10-branchpoint:1.6
	gdb_7_6-branch:1.6.0.56
	sid-snapshot-20130501:1.6
	sid-snapshot-20130401:1.6
	sid-snapshot-20130301:1.6
	sid-snapshot-20130201:1.6
	sid-snapshot-20130101:1.6
	sid-snapshot-20121201:1.6
	sid-snapshot-20121101:1.6
	sid-snapshot-20121001:1.6
	sid-snapshot-20120901:1.6
	gdb_7_5-branch:1.6.0.54
	sid-snapshot-20120801:1.6
	sid-snapshot-20120701:1.6
	sid-snapshot-20120601:1.6
	sid-snapshot-20120501:1.6
	sid-snapshot-20120401:1.6
	gdb_7_4-branch:1.6.0.52
	sid-snapshot-20120301:1.6
	sid-snapshot-20120201:1.6
	sid-snapshot-20120101:1.6
	sid-snapshot-20111201:1.6
	sid-snapshot-20111101:1.6
	sid-snapshot-20111001:1.6
	sid-snapshot-20110901:1.6
	gdb_7_3-branch:1.6.0.50
	sid-snapshot-20110801:1.6
	sid-snapshot-20110701:1.6
	sid-snapshot-20110601:1.6
	sid-snapshot-20110501:1.6
	sid-snapshot-20110401:1.6
	sid-snapshot-20110301:1.6
	sid-snapshot-20110201:1.6
	sid-snapshot-20110101:1.6
	sid-snapshot-20101201:1.6
	sid-snapshot-20101101:1.6
	sid-snapshot-20101001:1.6
	sid-snapshot-20100901:1.6
	sid-snapshot-20100801:1.6
	sid-snapshot-20100701:1.6
	sid-snapshot-20100601:1.6
	sid-snapshot-20100501:1.6
	sid-snapshot-20100401:1.6
	sid-snapshot-20100301:1.6
	gdb_7_1-branch:1.6.0.48
	gdb_7_0-branch:1.6.0.46
	sid-snapshot-20100201:1.6
	sid-snapshot-20100101:1.6
	sid-snapshot-20091201:1.6
	sid-snapshot-20091101:1.6
	sid-snapshot-20091001:1.6
	arc-sim-20090309:1.6
	sid-snapshot-20090901:1.6
	sid-snapshot-20090801:1.6
	sid-snapshot-20090701:1.6
	sid-snapshot-20090601:1.6
	sid-snapshot-20090501:1.6
	kevinb-pre-tcl8_5_7_merge:1.6
	sid-snapshot-20090401:1.6
	arc-insight_6_8-branch:1.6.0.44
	arc-insight_6_8-branchpoint:1.6
	insight_6_8-branch:1.6.0.42
	insight_6_8-branchpoint:1.6
	sid-snapshot-20090301:1.6
	sid-snapshot-20090201:1.6
	sid-snapshot-20090101:1.6
	sid-snapshot-20081201:1.6
	sid-snapshot-20081101:1.6
	sid-snapshot-20081001:1.6
	sid-snapshot-20080901:1.6
	sid-snapshot-20080801:1.6
	sid-snapshot-20080701:1.6
	sid-snapshot-20080601:1.6
	sid-snapshot-20080501:1.6
	sid-snapshot-20080403:1.6
	sid-snapshot-20080401:1.6
	gdb_6_8-branch:1.6.0.40
	sid-snapshot-20080301:1.6
	sid-snapshot-20080201:1.6
	sid-snapshot-20080101:1.6
	sid-snapshot-20071201:1.6
	sid-snapshot-20071101:1.6
	sid-snapshot-20071001:1.6
	insight_6_6-20070208-release:1.6
	gdb_6_6-branch:1.6.0.38
	gdb_6_6-2006-11-15-branchpoint:1.6
	insight_6_5-20061003-release:1.6
	gdb_6_5-branch:1.6.0.36
	gdb_6_5-2006-05-14-branchpoint:1.6
	readline_5_1-import-branch:1.6.0.34
	readline_5_1-import-branchpoint:1.6
	gdb_6_4-branch:1.6.0.32
	gdb_6_4-2005-11-01-branchpoint:1.6
	msnyder-tracepoint-checkpoint-branch:1.6.0.30
	msnyder-tracepoint-checkpoint-branchpoint:1.6
	gdb_6_1-2004-04-05-release:1.6
	ezannoni_pie-20040323-branch:1.6.0.28
	ezannoni_pie-20040323-branchpoint:1.6
	cagney_tramp-20040321-mergepoint:1.6
	cagney_tramp-20040309-branch:1.6.0.26
	cagney_tramp-20040309-branchpoint:1.6
	gdb_6_1-branch:1.6.0.24
	gdb_6_1-2004-03-01-gmt-branchpoint:1.6
	drow-cplus-merge-20040208:1.6
	carlton_dictionary-20040126-merge:1.6
	drow-cplus-merge-20040113:1.6
	drow-cplus-merge-20031224:1.6
	drow-cplus-merge-20031220:1.6
	carlton_dictionary-20031215-merge:1.6
	drow-cplus-merge-20031214:1.6
	carlton-dictionary-20031111-merge:1.6
	gdb_6_0-2003-10-04-release:1.6
	carlton_dictionary-20030917-merge:1.6
	ezannoni_pie-20030916-branchpoint:1.6
	ezannoni_pie-20030916-branch:1.6.0.22
	cagney_x86i386-20030821-branch:1.6.0.20
	cagney_x86i386-20030821-branchpoint:1.6
	carlton_dictionary-20030805-merge:1.6
	carlton_dictionary-20030627-merge:1.6
	gdb_6_0-branch:1.6.0.18
	gdb_6_0-2003-06-23-branchpoint:1.6
	cagney_convert-20030606-branch:1.6.0.16
	cagney_convert-20030606-branchpoint:1.6
	cagney_writestrings-20030508-branch:1.6.0.14
	cagney_writestrings-20030508-branchpoint:1.6
	carlton_dictionary-20030523-merge:1.6
	cagney_fileio-20030521-branch:1.6.0.12
	cagney_fileio-20030521-branchpoint:1.6
	carlton_dictionary-20030430-merge:1.6
	carlton_dictionary-20030416-merge:1.6
	cagney_frameaddr-20030409-mergepoint:1.6
	cagney_frameaddr-20030403-branchpoint:1.6
	cagney_frameaddr-20030403-branch:1.6.0.10
	cagney_framebase-20030330-mergepoint:1.6
	cagney_framebase-20030326-branch:1.6.0.8
	cagney_framebase-20030326-branchpoint:1.6
	cagney_lazyid-20030317-branch:1.6.0.6
	cagney_lazyid-20030317-branchpoint:1.6
	offbyone-20030313-branch:1.6.0.4
	offbyone-20030313-branchpoint:1.6
	carlton_dictionary-20030305-merge:1.6
	cagney_offbyone-20030303-branch:1.6.0.2
	cagney_offbyone-20030303-branchpoint:1.6
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.2
	interps-20030202-branchpoint:1.5
	TCL8_4_1:1.1.1.4
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.2
	TCL_8_4_1:1.1.1.4
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.4
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TCL_8_4_0:1.1.1.3
	carlton_dictionary-branch:1.2.0.16
	carlton_dictionary-20020920-branchpoint:1.2
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.14
	gdb_5_3-branch:1.2.0.12
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.10
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.8
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.6
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TCL_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	dejagnu-2000-02-04:1.1.1.1
	dejagnu-2000-01-31:1.1.1.1
	dejagnu-2000-01-24:1.1.1.1
	dejagnu-2000-01-17:1.1.1.1
	dejagnu-2000-01-10:1.1.1.1
	dejagnu-2000-01-04:1.1.1.1
	dejagnu-1999-12-21:1.1.1.1
	dejagnu-1999-12-13:1.1.1.1
	dejagnu-1999-12-07:1.1.1.1
	dejagnu-1999-12-06:1.1.1.1
	dejagnu-1999-11-15:1.1.1.1
	dejagnu-1999-11-08:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.6
date	2003.02.07.19.52.00;	author hunt;	state Exp;
branches;
next	1.5;

1.5
date	2003.01.21.19.40.23;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.26.19.48.07;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.37.11;	author kseitz;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2001.09.09.23.56.10;	author irox;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2002.09.27.21.49.15;	author kseitz;	state Exp;
branches;
next	;

1.3.4.1
date	2003.12.14.20.28.56;	author drow;	state Exp;
branches;
next	;

1.2.16.1
date	2002.12.23.19.40.58;	author carlton;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2003.02.07.19.18.24;	author carlton;	state Exp;
branches;
next	1.2.16.3;

1.2.16.3
date	2003.03.06.00.56.45;	author carlton;	state Exp;
branches;
next	;

1.1.1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.09.22.41.00;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.19.56.45;	author kseitz;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.11.26.20.01.20;	author hunt;	state Exp;
branches;
next	;


desc
@@


1.6
log
@2003-02-06  Martin M. Hunt  <hunt@@redhat.com>

	* win/tcl.m4 (SC_CONFIG_CFLAGS): Don't default to -O.
	* unix/tcl.m4 (SC_CONFIG_CFLAGS): Don't default to -O.
	CFLAGS gets set to "-O2" by default in top level
	configure. Adding "-O" here causes the "-O2" to be
	ignored, but only when the user types "make" within
	the tcl subdirectory. This caused some confusion.
	* win/configure: Rebuilt.
	* unix/configure: Rebuilt.

	* generic/tclEnv.c (TclUnsetEnv): Cast arg to unsigned.

	Import from latest tcl sources to fix a bug with
	"file copy"
	2003-01-25  Mo DeJong  <mdejong@@users.sourceforge.net>
	* win/tclWinFCmd.c (DoRenameFile, DoCopyFile, squelch_warnings):
	Re-implement inline ASM SEH handlers for gcc.
	The esp and ebp registers are now saved on the
	stack instead of in global variables so that
	the code is thread safe. Add additional checks
	when TCL_MEM_DEBUG is defined to be sure the
	values were recovered from the stack properly.
	Remove squelch_warnings functions and add
	a dummy call in the handler methods to squelch
	compiler warnings.
	* win/tclWinReg.c: Add casts to avoid compiler
	warning. Fix assignment in if expression bug.
@
text
@/*
 * tclWinReg.c --
 *
 *	This file contains the implementation of the "registry" Tcl
 *	built-in command.  This command is built as a dynamically
 *	loadable extension in a separate DLL.
 *
 * Copyright (c) 1997 by Sun Microsystems, Inc.
 * Copyright (c) 1998-1999 by Scriptics Corporation.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tclWinReg.c,v 1.20 2003/01/16 19:02:00 mdejong Exp $
 */

#include <tclPort.h>
#include <stdlib.h>

/*
 * TCL_STORAGE_CLASS is set unconditionally to DLLEXPORT because the
 * Registry_Init declaration is in the source file itself, which is only
 * accessed when we are building a library.
 */

#undef TCL_STORAGE_CLASS
#define TCL_STORAGE_CLASS DLLEXPORT

/*
 * The following macros convert between different endian ints.
 */

#define SWAPWORD(x) MAKEWORD(HIBYTE(x), LOBYTE(x))
#define SWAPLONG(x) MAKELONG(SWAPWORD(HIWORD(x)), SWAPWORD(LOWORD(x)))

/*
 * The following flag is used in OpenKeys to indicate that the specified
 * key should be created if it doesn't currently exist.
 */

#define REG_CREATE 1

/*
 * The following tables contain the mapping from registry root names
 * to the system predefined keys.
 */

static CONST char *rootKeyNames[] = {
    "HKEY_LOCAL_MACHINE", "HKEY_USERS", "HKEY_CLASSES_ROOT",
    "HKEY_CURRENT_USER", "HKEY_CURRENT_CONFIG",
    "HKEY_PERFORMANCE_DATA", "HKEY_DYN_DATA", NULL
};

static HKEY rootKeys[] = {
    HKEY_LOCAL_MACHINE, HKEY_USERS, HKEY_CLASSES_ROOT, HKEY_CURRENT_USER,
    HKEY_CURRENT_CONFIG, HKEY_PERFORMANCE_DATA, HKEY_DYN_DATA
};

/*
 * The following table maps from registry types to strings.  Note that
 * the indices for this array are the same as the constants for the
 * known registry types so we don't need a separate table to hold the
 * mapping.
 */

static CONST char *typeNames[] = {
    "none", "sz", "expand_sz", "binary", "dword",
    "dword_big_endian", "link", "multi_sz", "resource_list", NULL
};

static DWORD lastType = REG_RESOURCE_LIST;

/*
 * The following structures allow us to select between the Unicode and ASCII
 * interfaces at run time based on whether Unicode APIs are available.  The
 * Unicode APIs are preferable because they will handle characters outside
 * of the current code page.
 */

typedef struct RegWinProcs {
    int useWide;

    LONG (WINAPI *regConnectRegistryProc)(CONST TCHAR *, HKEY, PHKEY);
    LONG (WINAPI *regCreateKeyExProc)(HKEY, CONST TCHAR *, DWORD, TCHAR *,
	    DWORD, REGSAM, SECURITY_ATTRIBUTES *, HKEY *, DWORD *); 
    LONG (WINAPI *regDeleteKeyProc)(HKEY, CONST TCHAR *);
    LONG (WINAPI *regDeleteValueProc)(HKEY, CONST TCHAR *);
    LONG (WINAPI *regEnumKeyProc)(HKEY, DWORD, TCHAR *, DWORD);
    LONG (WINAPI *regEnumKeyExProc)(HKEY, DWORD, TCHAR *, DWORD *, DWORD *,
	    TCHAR *, DWORD *, FILETIME *);
    LONG (WINAPI *regEnumValueProc)(HKEY, DWORD, TCHAR *, DWORD *, DWORD *,
	    DWORD *, BYTE *, DWORD *);
    LONG (WINAPI *regOpenKeyExProc)(HKEY, CONST TCHAR *, DWORD, REGSAM,
	    HKEY *);
    LONG (WINAPI *regQueryInfoKeyProc)(HKEY, TCHAR *, DWORD *, DWORD *,
	    DWORD *, DWORD *, DWORD *, DWORD *, DWORD *, DWORD *, DWORD *,
	    FILETIME *);
    LONG (WINAPI *regQueryValueExProc)(HKEY, CONST TCHAR *, DWORD *, DWORD *,
	    BYTE *, DWORD *);
    LONG (WINAPI *regSetValueExProc)(HKEY, CONST TCHAR *, DWORD, DWORD,
	    CONST BYTE*, DWORD);
} RegWinProcs;

static RegWinProcs *regWinProcs;

static RegWinProcs asciiProcs = {
    0,

    (LONG (WINAPI *)(CONST TCHAR *, HKEY, PHKEY)) RegConnectRegistryA,
    (LONG (WINAPI *)(HKEY, CONST TCHAR *, DWORD, TCHAR *,
	    DWORD, REGSAM, SECURITY_ATTRIBUTES *, HKEY *,
	    DWORD *)) RegCreateKeyExA, 
    (LONG (WINAPI *)(HKEY, CONST TCHAR *)) RegDeleteKeyA,
    (LONG (WINAPI *)(HKEY, CONST TCHAR *)) RegDeleteValueA,
    (LONG (WINAPI *)(HKEY, DWORD, TCHAR *, DWORD)) RegEnumKeyA,
    (LONG (WINAPI *)(HKEY, DWORD, TCHAR *, DWORD *, DWORD *,
	    TCHAR *, DWORD *, FILETIME *)) RegEnumKeyExA,
    (LONG (WINAPI *)(HKEY, DWORD, TCHAR *, DWORD *, DWORD *,
	    DWORD *, BYTE *, DWORD *)) RegEnumValueA,
    (LONG (WINAPI *)(HKEY, CONST TCHAR *, DWORD, REGSAM,
	    HKEY *)) RegOpenKeyExA,
    (LONG (WINAPI *)(HKEY, TCHAR *, DWORD *, DWORD *,
	    DWORD *, DWORD *, DWORD *, DWORD *, DWORD *, DWORD *, DWORD *,
	    FILETIME *)) RegQueryInfoKeyA,
    (LONG (WINAPI *)(HKEY, CONST TCHAR *, DWORD *, DWORD *,
	    BYTE *, DWORD *)) RegQueryValueExA,
    (LONG (WINAPI *)(HKEY, CONST TCHAR *, DWORD, DWORD,
	    CONST BYTE*, DWORD)) RegSetValueExA,
};

static RegWinProcs unicodeProcs = {
    1,

    (LONG (WINAPI *)(CONST TCHAR *, HKEY, PHKEY)) RegConnectRegistryW,
    (LONG (WINAPI *)(HKEY, CONST TCHAR *, DWORD, TCHAR *,
	    DWORD, REGSAM, SECURITY_ATTRIBUTES *, HKEY *,
	    DWORD *)) RegCreateKeyExW, 
    (LONG (WINAPI *)(HKEY, CONST TCHAR *)) RegDeleteKeyW,
    (LONG (WINAPI *)(HKEY, CONST TCHAR *)) RegDeleteValueW,
    (LONG (WINAPI *)(HKEY, DWORD, TCHAR *, DWORD)) RegEnumKeyW,
    (LONG (WINAPI *)(HKEY, DWORD, TCHAR *, DWORD *, DWORD *,
	    TCHAR *, DWORD *, FILETIME *)) RegEnumKeyExW,
    (LONG (WINAPI *)(HKEY, DWORD, TCHAR *, DWORD *, DWORD *,
	    DWORD *, BYTE *, DWORD *)) RegEnumValueW,
    (LONG (WINAPI *)(HKEY, CONST TCHAR *, DWORD, REGSAM,
	    HKEY *)) RegOpenKeyExW,
    (LONG (WINAPI *)(HKEY, TCHAR *, DWORD *, DWORD *,
	    DWORD *, DWORD *, DWORD *, DWORD *, DWORD *, DWORD *, DWORD *,
	    FILETIME *)) RegQueryInfoKeyW,
    (LONG (WINAPI *)(HKEY, CONST TCHAR *, DWORD *, DWORD *,
	    BYTE *, DWORD *)) RegQueryValueExW,
    (LONG (WINAPI *)(HKEY, CONST TCHAR *, DWORD, DWORD,
	    CONST BYTE*, DWORD)) RegSetValueExW,
};


/*
 * Declarations for functions defined in this file.
 */

static void		AppendSystemError(Tcl_Interp *interp, DWORD error);
static int		BroadcastValue(Tcl_Interp *interp, int objc,
			    Tcl_Obj * CONST objv[]);
static DWORD		ConvertDWORD(DWORD type, DWORD value);
static int		DeleteKey(Tcl_Interp *interp, Tcl_Obj *keyNameObj);
static int		DeleteValue(Tcl_Interp *interp, Tcl_Obj *keyNameObj,
			    Tcl_Obj *valueNameObj);
static int		GetKeyNames(Tcl_Interp *interp, Tcl_Obj *keyNameObj,
			    Tcl_Obj *patternObj);
static int		GetType(Tcl_Interp *interp, Tcl_Obj *keyNameObj,
			    Tcl_Obj *valueNameObj);
static int		GetValue(Tcl_Interp *interp, Tcl_Obj *keyNameObj,
			    Tcl_Obj *valueNameObj);
static int		GetValueNames(Tcl_Interp *interp, Tcl_Obj *keyNameObj,
			    Tcl_Obj *patternObj);
static int		OpenKey(Tcl_Interp *interp, Tcl_Obj *keyNameObj,
			    REGSAM mode, int flags, HKEY *keyPtr);
static DWORD		OpenSubKey(char *hostName, HKEY rootKey,
			    char *keyName, REGSAM mode, int flags,
			    HKEY *keyPtr);
static int		ParseKeyName(Tcl_Interp *interp, char *name,
			    char **hostNamePtr, HKEY *rootKeyPtr,
			    char **keyNamePtr);
static DWORD		RecursiveDeleteKey(HKEY hStartKey,
			    CONST TCHAR * pKeyName);
static int		RegistryObjCmd(ClientData clientData,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj * CONST objv[]);
static int		SetValue(Tcl_Interp *interp, Tcl_Obj *keyNameObj,
			    Tcl_Obj *valueNameObj, Tcl_Obj *dataObj,
			    Tcl_Obj *typeObj);

EXTERN int Registry_Init(Tcl_Interp *interp);

/*
 *----------------------------------------------------------------------
 *
 * Registry_Init --
 *
 *	This procedure initializes the registry command.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
Registry_Init(
    Tcl_Interp *interp)
{
    if (!Tcl_InitStubs(interp, "8.0", 0)) {
	return TCL_ERROR;
    }

    /*
     * Determine if the unicode interfaces are available and select the
     * appropriate registry function table.
     */

    if (TclWinGetPlatformId() == VER_PLATFORM_WIN32_NT) {
	regWinProcs = &unicodeProcs;
    } else {
	regWinProcs = &asciiProcs;
    }

    Tcl_CreateObjCommand(interp, "registry", RegistryObjCmd, NULL, NULL);
    return Tcl_PkgProvide(interp, "registry", "1.1");
}

/*
 *----------------------------------------------------------------------
 *
 * RegistryObjCmd --
 *
 *	This function implements the Tcl "registry" command.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static int
RegistryObjCmd(
    ClientData clientData,	/* Not used. */
    Tcl_Interp *interp,		/* Current interpreter. */
    int objc,			/* Number of arguments. */
    Tcl_Obj * CONST objv[])	/* Argument values. */
{
    int index;
    char *errString;

    static CONST char *subcommands[] = {
	"broadcast", "delete", "get", "keys", "set", "type", "values",
	(char *) NULL
    };
    enum SubCmdIdx {
	BroadcastIdx, DeleteIdx, GetIdx, KeysIdx, SetIdx, TypeIdx, ValuesIdx
    };

    if (objc < 2) {
	Tcl_WrongNumArgs(interp, objc, objv, "option ?arg arg ...?");
	return TCL_ERROR;
    }

    if (Tcl_GetIndexFromObj(interp, objv[1], subcommands, "option", 0, &index)
	    != TCL_OK) {
	return TCL_ERROR;
    }

    switch (index) {
	case BroadcastIdx:		/* broadcast */
	    return BroadcastValue(interp, objc, objv);
	    break;
	case DeleteIdx:			/* delete */
	    if (objc == 3) {
		return DeleteKey(interp, objv[2]);
	    } else if (objc == 4) {
		return DeleteValue(interp, objv[2], objv[3]);
	    }
	    errString = "keyName ?valueName?";
	    break;
	case GetIdx:			/* get */
	    if (objc == 4) {
		return GetValue(interp, objv[2], objv[3]);
	    }
	    errString = "keyName valueName";
	    break;
	case KeysIdx:			/* keys */
	    if (objc == 3) {
		return GetKeyNames(interp, objv[2], NULL);
	    } else if (objc == 4) {
		return GetKeyNames(interp, objv[2], objv[3]);
	    }
	    errString = "keyName ?pattern?";
	    break;
	case SetIdx:			/* set */
	    if (objc == 3) {
		HKEY key;

		/*
		 * Create the key and then close it immediately.
		 */

		if (OpenKey(interp, objv[2], KEY_ALL_ACCESS, 1, &key)
			!= TCL_OK) {
		    return TCL_ERROR;
		}
		RegCloseKey(key);
		return TCL_OK;
	    } else if (objc == 5 || objc == 6) {
		Tcl_Obj *typeObj = (objc == 5) ? NULL : objv[5];
		return SetValue(interp, objv[2], objv[3], objv[4], typeObj);
	    }
	    errString = "keyName ?valueName data ?type??";
	    break;
	case TypeIdx:			/* type */
	    if (objc == 4) {
		return GetType(interp, objv[2], objv[3]);
	    }
	    errString = "keyName valueName";
	    break;
	case ValuesIdx:			/* values */
	    if (objc == 3) {
 		return GetValueNames(interp, objv[2], NULL);
	    } else if (objc == 4) {
 		return GetValueNames(interp, objv[2], objv[3]);
	    }
	    errString = "keyName ?pattern?";
	    break;
    }
    Tcl_WrongNumArgs(interp, 2, objv, errString);
    return TCL_ERROR;
}

/*
 *----------------------------------------------------------------------
 *
 * DeleteKey --
 *
 *	This function deletes a registry key.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static int
DeleteKey(
    Tcl_Interp *interp,		/* Current interpreter. */
    Tcl_Obj *keyNameObj)	/* Name of key to delete. */
{
    char *tail, *buffer, *hostName, *keyName;
    CONST char *nativeTail;
    HKEY rootKey, subkey;
    DWORD result;
    int length;
    Tcl_Obj *resultPtr;
    Tcl_DString buf;

    /*
     * Find the parent of the key being deleted and open it.
     */

    keyName = Tcl_GetStringFromObj(keyNameObj, &length);
    buffer = ckalloc((unsigned int) length + 1);
    strcpy(buffer, keyName);

    if (ParseKeyName(interp, buffer, &hostName, &rootKey, &keyName)
	    != TCL_OK) {
	ckfree(buffer);
	return TCL_ERROR;
    }

    resultPtr = Tcl_GetObjResult(interp);
    if (*keyName == '\0') {
	Tcl_AppendToObj(resultPtr, "bad key: cannot delete root keys", -1);
	ckfree(buffer);
	return TCL_ERROR;
    }

    tail = strrchr(keyName, '\\');
    if (tail) {
	*tail++ = '\0';
    } else {
	tail = keyName;
	keyName = NULL;
    }

    result = OpenSubKey(hostName, rootKey, keyName,
	    KEY_ENUMERATE_SUB_KEYS | DELETE, 0, &subkey);
    if (result != ERROR_SUCCESS) {
	ckfree(buffer);
	if (result == ERROR_FILE_NOT_FOUND) {
	    return TCL_OK;
	} else {
	    Tcl_AppendToObj(resultPtr, "unable to delete key: ", -1);
	    AppendSystemError(interp, result);
	    return TCL_ERROR;
	}
    }

    /*
     * Now we recursively delete the key and everything below it.
     */

    nativeTail = Tcl_WinUtfToTChar(tail, -1, &buf);
    result = RecursiveDeleteKey(subkey, nativeTail);
    Tcl_DStringFree(&buf);

    if (result != ERROR_SUCCESS && result != ERROR_FILE_NOT_FOUND) {
	Tcl_AppendToObj(resultPtr, "unable to delete key: ", -1);
	AppendSystemError(interp, result);
	result = TCL_ERROR;
    } else {
	result = TCL_OK;
    }

    RegCloseKey(subkey);
    ckfree(buffer);
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * DeleteValue --
 *
 *	This function deletes a value from a registry key.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static int
DeleteValue(
    Tcl_Interp *interp,		/* Current interpreter. */
    Tcl_Obj *keyNameObj,	/* Name of key. */
    Tcl_Obj *valueNameObj)	/* Name of value to delete. */
{
    HKEY key;
    char *valueName;
    int length;
    DWORD result;
    Tcl_Obj *resultPtr;
    Tcl_DString ds;

    /*
     * Attempt to open the key for deletion.
     */

    if (OpenKey(interp, keyNameObj, KEY_SET_VALUE, 0, &key)
	    != TCL_OK) {
	return TCL_ERROR;
    }

    resultPtr = Tcl_GetObjResult(interp);
    valueName = Tcl_GetStringFromObj(valueNameObj, &length);
    Tcl_WinUtfToTChar(valueName, length, &ds);
    result = (*regWinProcs->regDeleteValueProc)(key, Tcl_DStringValue(&ds));
    Tcl_DStringFree(&ds);
    if (result != ERROR_SUCCESS) {
	Tcl_AppendStringsToObj(resultPtr, "unable to delete value \"",
		Tcl_GetString(valueNameObj), "\" from key \"",
		Tcl_GetString(keyNameObj), "\": ", NULL);
	AppendSystemError(interp, result);
	result = TCL_ERROR;
    } else {
	result = TCL_OK;
    }
    RegCloseKey(key);
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * GetKeyNames --
 *
 *	This function enumerates the subkeys of a given key.  If the
 *	optional pattern is supplied, then only keys that match the
 *	pattern will be returned.
 *
 * Results:
 *	Returns the list of subkeys in the result object of the
 *	interpreter, or an error message on failure.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static int
GetKeyNames(
    Tcl_Interp *interp,		/* Current interpreter. */
    Tcl_Obj *keyNameObj,	/* Key to enumerate. */
    Tcl_Obj *patternObj)	/* Optional match pattern. */
{
    HKEY key;
    DWORD index;
    char buffer[MAX_PATH+1], *pattern, *name;
    Tcl_Obj *resultPtr;
    int result = TCL_OK;
    Tcl_DString ds;

    /*
     * Attempt to open the key for enumeration.
     */

    if (OpenKey(interp, keyNameObj, KEY_ENUMERATE_SUB_KEYS, 0, &key)
	    != TCL_OK) {
	return TCL_ERROR;
    }

    if (patternObj) {
	pattern = Tcl_GetString(patternObj);
    } else {
	pattern = NULL;
    }

    /*
     * Enumerate over the subkeys until we get an error, indicating the
     * end of the list.
     */

    resultPtr = Tcl_GetObjResult(interp);
    for (index = 0; (*regWinProcs->regEnumKeyProc)(key, index, buffer,
	    MAX_PATH+1) == ERROR_SUCCESS; index++) {
	Tcl_WinTCharToUtf((TCHAR *) buffer, -1, &ds);
	name = Tcl_DStringValue(&ds);
	if (pattern && !Tcl_StringMatch(name, pattern)) {
	    Tcl_DStringFree(&ds);
	    continue;
	}
	result = Tcl_ListObjAppendElement(interp, resultPtr,
		Tcl_NewStringObj(name, Tcl_DStringLength(&ds)));
	Tcl_DStringFree(&ds);
	if (result != TCL_OK) {
	    break;
	}
    }

    RegCloseKey(key);
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * GetType --
 *
 *	This function gets the type of a given registry value and
 *	places it in the interpreter result.
 *
 * Results:
 *	Returns a normal Tcl result.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static int
GetType(
    Tcl_Interp *interp,		/* Current interpreter. */
    Tcl_Obj *keyNameObj,	/* Name of key. */
    Tcl_Obj *valueNameObj)	/* Name of value to get. */
{
    HKEY key;
    Tcl_Obj *resultPtr;
    DWORD result;
    DWORD type;
    Tcl_DString ds;
    char *valueName;
    CONST char *nativeValue;
    int length;

    /*
     * Attempt to open the key for reading.
     */

    if (OpenKey(interp, keyNameObj, KEY_QUERY_VALUE, 0, &key)
	    != TCL_OK) {
	return TCL_ERROR;
    }

    /*
     * Get the type of the value.
     */

    resultPtr = Tcl_GetObjResult(interp);

    valueName = Tcl_GetStringFromObj(valueNameObj, &length);
    nativeValue = Tcl_WinUtfToTChar(valueName, length, &ds);
    result = (*regWinProcs->regQueryValueExProc)(key, nativeValue, NULL, &type,
	    NULL, NULL);
    Tcl_DStringFree(&ds);
    RegCloseKey(key);

    if (result != ERROR_SUCCESS) {
	Tcl_AppendStringsToObj(resultPtr, "unable to get type of value \"",
		Tcl_GetString(valueNameObj), "\" from key \"",
		Tcl_GetString(keyNameObj), "\": ", NULL);
	AppendSystemError(interp, result);
	return TCL_ERROR;
    }

    /*
     * Set the type into the result.  Watch out for unknown types.
     * If we don't know about the type, just use the numeric value.
     */

    if (type > lastType || type < 0) {
	Tcl_SetIntObj(resultPtr, (int) type);
    } else {
	Tcl_SetStringObj(resultPtr, typeNames[type], -1);
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * GetValue --
 *
 *	This function gets the contents of a registry value and places
 *	a list containing the data and the type in the interpreter
 *	result.
 *
 * Results:
 *	Returns a normal Tcl result.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static int
GetValue(
    Tcl_Interp *interp,		/* Current interpreter. */
    Tcl_Obj *keyNameObj,	/* Name of key. */
    Tcl_Obj *valueNameObj)	/* Name of value to get. */
{
    HKEY key;
    char *valueName;
    CONST char *nativeValue;
    DWORD result, length, type;
    Tcl_Obj *resultPtr;
    Tcl_DString data, buf;
    int nameLen;

    /*
     * Attempt to open the key for reading.
     */

    if (OpenKey(interp, keyNameObj, KEY_QUERY_VALUE, 0, &key)
	    != TCL_OK) {
	return TCL_ERROR;
    }

    /*
     * Initialize a Dstring to maximum statically allocated size
     * we could get one more byte by avoiding Tcl_DStringSetLength()
     * and just setting length to TCL_DSTRING_STATIC_SIZE, but this
     * should be safer if the implementation of Dstrings changes.
     *
     * This allows short values to be read from the registy in one call.
     * Longer values need a second call with an expanded DString.
     */

    Tcl_DStringInit(&data);
    length = TCL_DSTRING_STATIC_SIZE - 1;
    Tcl_DStringSetLength(&data, (int) length);

    resultPtr = Tcl_GetObjResult(interp);

    valueName = Tcl_GetStringFromObj(valueNameObj, &nameLen);
    nativeValue = Tcl_WinUtfToTChar(valueName, nameLen, &buf);

    result = (*regWinProcs->regQueryValueExProc)(key, nativeValue, NULL, &type,
	    (BYTE *) Tcl_DStringValue(&data), &length);
    while (result == ERROR_MORE_DATA) {
	/*
	 * The Windows docs say that in this error case, we just need
	 * to expand our buffer and request more data.
	 * Required for HKEY_PERFORMANCE_DATA
	 */
	length *= 2;
        Tcl_DStringSetLength(&data, (int) length);
        result = (*regWinProcs->regQueryValueExProc)(key, (char *) nativeValue,
		NULL, &type, (BYTE *) Tcl_DStringValue(&data), &length);
    }
    Tcl_DStringFree(&buf);
    RegCloseKey(key);
    if (result != ERROR_SUCCESS) {
	Tcl_AppendStringsToObj(resultPtr, "unable to get value \"",
		Tcl_GetString(valueNameObj), "\" from key \"",
		Tcl_GetString(keyNameObj), "\": ", NULL);
	AppendSystemError(interp, result);
	Tcl_DStringFree(&data);
	return TCL_ERROR;
    }

    /*
     * If the data is a 32-bit quantity, store it as an integer object.  If it
     * is a multi-string, store it as a list of strings.  For null-terminated
     * strings, append up the to first null.  Otherwise, store it as a binary
     * string.
     */

    if (type == REG_DWORD || type == REG_DWORD_BIG_ENDIAN) {
	Tcl_SetIntObj(resultPtr, (int) ConvertDWORD(type,
		*((DWORD*) Tcl_DStringValue(&data))));
    } else if (type == REG_MULTI_SZ) {
	char *p = Tcl_DStringValue(&data);
	char *end = Tcl_DStringValue(&data) + length;

	/*
	 * Multistrings are stored as an array of null-terminated strings,
	 * terminated by two null characters.  Also do a bounds check in
	 * case we get bogus data.
	 */
 
	while (p < end 	&& ((regWinProcs->useWide) 
		? *((Tcl_UniChar *)p) : *p) != 0) {
	    Tcl_WinTCharToUtf((TCHAR *) p, -1, &buf);
	    Tcl_ListObjAppendElement(interp, resultPtr,
		    Tcl_NewStringObj(Tcl_DStringValue(&buf),
			    Tcl_DStringLength(&buf)));
	    if (regWinProcs->useWide) {
		while (*((Tcl_UniChar *)p)++ != 0) {}
	    } else {
		while (*p++ != '\0') {}
	    }
	    Tcl_DStringFree(&buf);
	}
    } else if ((type == REG_SZ) || (type == REG_EXPAND_SZ)) {
	Tcl_WinTCharToUtf((TCHAR *) Tcl_DStringValue(&data), -1, &buf);
	Tcl_SetStringObj(resultPtr, Tcl_DStringValue(&buf),
		Tcl_DStringLength(&buf));
	Tcl_DStringFree(&buf);
    } else {
	/*
	 * Save binary data as a byte array.
	 */

	Tcl_SetByteArrayObj(resultPtr, Tcl_DStringValue(&data), (int) length);
    }
    Tcl_DStringFree(&data);
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * GetValueNames --
 *
 *	This function enumerates the values of the a given key.  If
 *	the optional pattern is supplied, then only value names that
 *	match the pattern will be returned.
 *
 * Results:
 *	Returns the list of value names in the result object of the
 *	interpreter, or an error message on failure.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static int
GetValueNames(
    Tcl_Interp *interp,		/* Current interpreter. */
    Tcl_Obj *keyNameObj,	/* Key to enumerate. */
    Tcl_Obj *patternObj)	/* Optional match pattern. */
{
    HKEY key;
    Tcl_Obj *resultPtr;
    DWORD index, size, maxSize, result;
    Tcl_DString buffer, ds;
    char *pattern, *name;

    /*
     * Attempt to open the key for enumeration.
     */

    if (OpenKey(interp, keyNameObj, KEY_QUERY_VALUE, 0, &key)
	    != TCL_OK) {
	return TCL_ERROR;
    }

    resultPtr = Tcl_GetObjResult(interp);

    /*
     * Query the key to determine the appropriate buffer size to hold the
     * largest value name plus the terminating null.
     */

    result = (*regWinProcs->regQueryInfoKeyProc)(key, NULL, NULL, NULL, NULL,
	    NULL, NULL, &index, &maxSize, NULL, NULL, NULL);
    if (result != ERROR_SUCCESS) {
	Tcl_AppendStringsToObj(resultPtr, "unable to query key \"",
		Tcl_GetString(keyNameObj), "\": ", NULL);
	AppendSystemError(interp, result);
	RegCloseKey(key);
	result = TCL_ERROR;
	goto done;
    }
    maxSize++;


    Tcl_DStringInit(&buffer);
    Tcl_DStringSetLength(&buffer,
	    (int) ((regWinProcs->useWide) ? maxSize*2 : maxSize));
    index = 0;
    result = TCL_OK;

    if (patternObj) {
	pattern = Tcl_GetString(patternObj);
    } else {
	pattern = NULL;
    }

    /*
     * Enumerate the values under the given subkey until we get an error,
     * indicating the end of the list.  Note that we need to reset size
     * after each iteration because RegEnumValue smashes the old value.
     */

    size = maxSize;
    while ((*regWinProcs->regEnumValueProc)(key, index,
	    Tcl_DStringValue(&buffer), &size, NULL, NULL, NULL, NULL)
	    == ERROR_SUCCESS) {

	if (regWinProcs->useWide) {
	    size *= 2;
	}

	Tcl_WinTCharToUtf((TCHAR *) Tcl_DStringValue(&buffer), (int) size, &ds);
	name = Tcl_DStringValue(&ds);
	if (!pattern || Tcl_StringMatch(name, pattern)) {
	    result = Tcl_ListObjAppendElement(interp, resultPtr,
		    Tcl_NewStringObj(name, Tcl_DStringLength(&ds)));
	    if (result != TCL_OK) {
		Tcl_DStringFree(&ds);
		break;
	    }
	}
	Tcl_DStringFree(&ds);

	index++;
	size = maxSize;
    }
    Tcl_DStringFree(&buffer);

    done:
    RegCloseKey(key);
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * OpenKey --
 *
 *	This function opens the specified key.  This function is a
 *	simple wrapper around ParseKeyName and OpenSubKey.
 *
 * Results:
 *	Returns the opened key in the keyPtr argument and a Tcl
 *	result code.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static int
OpenKey(
    Tcl_Interp *interp,		/* Current interpreter. */
    Tcl_Obj *keyNameObj,	/* Key to open. */
    REGSAM mode,		/* Access mode. */
    int flags,			/* 0 or REG_CREATE. */
    HKEY *keyPtr)		/* Returned HKEY. */
{
    char *keyName, *buffer, *hostName;
    int length;
    HKEY rootKey;
    DWORD result;

    keyName = Tcl_GetStringFromObj(keyNameObj, &length);
    buffer = ckalloc((unsigned int) length + 1);
    strcpy(buffer, keyName);

    result = ParseKeyName(interp, buffer, &hostName, &rootKey, &keyName);
    if (result == TCL_OK) {
	result = OpenSubKey(hostName, rootKey, keyName, mode, flags, keyPtr);
	if (result != ERROR_SUCCESS) {
	    Tcl_Obj *resultPtr = Tcl_GetObjResult(interp);
	    Tcl_AppendToObj(resultPtr, "unable to open key: ", -1);
	    AppendSystemError(interp, result);
	    result = TCL_ERROR;
	} else {
	    result = TCL_OK;
	}
    }

    ckfree(buffer);
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * OpenSubKey --
 *
 *	This function opens a given subkey of a root key on the
 *	specified host.
 *
 * Results:
 *	Returns the opened key in the keyPtr and a Windows error code
 *	as the return value.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static DWORD
OpenSubKey(
    char *hostName,		/* Host to access, or NULL for local. */
    HKEY rootKey,		/* Root registry key. */
    char *keyName,		/* Subkey name. */
    REGSAM mode,		/* Access mode. */
    int flags,			/* 0 or REG_CREATE. */
    HKEY *keyPtr)		/* Returned HKEY. */
{
    DWORD result;
    Tcl_DString buf;

    /*
     * Attempt to open the root key on a remote host if necessary.
     */

    if (hostName) {
	hostName = (char *) Tcl_WinUtfToTChar(hostName, -1, &buf);
	result = (*regWinProcs->regConnectRegistryProc)(hostName, rootKey,
		&rootKey);
	Tcl_DStringFree(&buf);
	if (result != ERROR_SUCCESS) {
	    return result;
	}
    }

    /*
     * Now open the specified key with the requested permissions.  Note
     * that this key must be closed by the caller.
     */

    keyName = (char *) Tcl_WinUtfToTChar(keyName, -1, &buf);
    if (flags & REG_CREATE) {
	DWORD create;
	result = (*regWinProcs->regCreateKeyExProc)(rootKey, keyName, 0, "",
		REG_OPTION_NON_VOLATILE, mode, NULL, keyPtr, &create);
    } else {
	if (rootKey == HKEY_PERFORMANCE_DATA) {
	    /*
	     * Here we fudge it for this special root key.
	     * See MSDN for more info on HKEY_PERFORMANCE_DATA and
	     * the peculiarities surrounding it
	     */
	    *keyPtr = HKEY_PERFORMANCE_DATA;
	    result = ERROR_SUCCESS;
	} else {
	    result = (*regWinProcs->regOpenKeyExProc)(rootKey, keyName, 0,
		    mode, keyPtr);
	}
    }
    Tcl_DStringFree(&buf);

    /*
     * Be sure to close the root key since we are done with it now.
     */

    if (hostName) {
	RegCloseKey(rootKey);
    }
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * ParseKeyName --
 *
 *	This function parses a key name into the host, root, and subkey
 *	parts.
 *
 * Results:
 *	The pointers to the start of the host and subkey names are
 *	returned in the hostNamePtr and keyNamePtr variables.  The
 *	specified root HKEY is returned in rootKeyPtr.  Returns
 *	a standard Tcl result.
 *
 *
 * Side effects:
 *	Modifies the name string by inserting nulls.
 *
 *----------------------------------------------------------------------
 */

static int
ParseKeyName(
    Tcl_Interp *interp,		/* Current interpreter. */
    char *name,
    char **hostNamePtr,
    HKEY *rootKeyPtr,
    char **keyNamePtr)
{
    char *rootName;
    int result, index;
    Tcl_Obj *rootObj, *resultPtr = Tcl_GetObjResult(interp);

    /*
     * Split the key into host and root portions.
     */

    *hostNamePtr = *keyNamePtr = rootName = NULL;
    if (name[0] == '\\') {
	if (name[1] == '\\') {
	    *hostNamePtr = name;
	    for (rootName = name+2; *rootName != '\0'; rootName++) {
		if (*rootName == '\\') {
		    *rootName++ = '\0';
		    break;
		}
	    }
	}
    } else {
	rootName = name;
    }
    if (!rootName) {
	Tcl_AppendStringsToObj(resultPtr, "bad key \"", name,
		"\": must start with a valid root", NULL);
	return TCL_ERROR;
    }

    /*
     * Split the root into root and subkey portions.
     */

    for (*keyNamePtr = rootName; **keyNamePtr != '\0'; (*keyNamePtr)++) {
	if (**keyNamePtr == '\\') {
	    **keyNamePtr = '\0';
	    (*keyNamePtr)++;
	    break;
	}
    }

    /*
     * Look for a matching root name.
     */

    rootObj = Tcl_NewStringObj(rootName, -1);
    result = Tcl_GetIndexFromObj(interp, rootObj, rootKeyNames, "root name",
	    TCL_EXACT, &index);
    Tcl_DecrRefCount(rootObj);
    if (result != TCL_OK) {
	return TCL_ERROR;
    }
    *rootKeyPtr = rootKeys[index];
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * RecursiveDeleteKey --
 *
 *	This function recursively deletes all the keys below a starting
 *	key.  Although Windows 95 does this automatically, we still need
 *	to do this for Windows NT.
 *
 * Results:
 *	Returns a Windows error code.
 *
 * Side effects:
 *	Deletes all of the keys and values below the given key.
 *
 *----------------------------------------------------------------------
 */

static DWORD
RecursiveDeleteKey(
    HKEY startKey,		/* Parent of key to be deleted. */
    CONST char *keyName)	/* Name of key to be deleted in external
				 * encoding, not UTF. */
{
    DWORD result, size, maxSize;
    Tcl_DString subkey;
    HKEY hKey;

    /*
     * Do not allow NULL or empty key name.
     */

    if (!keyName || *keyName == '\0') {
	return ERROR_BADKEY;
    }

    result = (*regWinProcs->regOpenKeyExProc)(startKey, keyName, 0,
	    KEY_ENUMERATE_SUB_KEYS | DELETE | KEY_QUERY_VALUE, &hKey);
    if (result != ERROR_SUCCESS) {
	return result;
    }
    result = (*regWinProcs->regQueryInfoKeyProc)(hKey, NULL, NULL, NULL, NULL,
	    &maxSize, NULL, NULL, NULL, NULL, NULL, NULL);
    maxSize++;
    if (result != ERROR_SUCCESS) {
	return result;
    }

    Tcl_DStringInit(&subkey);
    Tcl_DStringSetLength(&subkey,
	    (int) ((regWinProcs->useWide) ? maxSize * 2 : maxSize));

    while (result == ERROR_SUCCESS) {
	/*
	 * Always get index 0 because key deletion changes ordering.
	 */

	size = maxSize;
	result=(*regWinProcs->regEnumKeyExProc)(hKey, 0,
		Tcl_DStringValue(&subkey), &size, NULL, NULL, NULL, NULL);
	if (result == ERROR_NO_MORE_ITEMS) {
	    result = (*regWinProcs->regDeleteKeyProc)(startKey, keyName);
	    break;
	} else if (result == ERROR_SUCCESS) {
	    result = RecursiveDeleteKey(hKey, Tcl_DStringValue(&subkey));
	}
    }
    Tcl_DStringFree(&subkey);
    RegCloseKey(hKey);
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * SetValue --
 *
 *	This function sets the contents of a registry value.  If
 *	the key or value does not exist, it will be created.  If it
 *	does exist, then the data and type will be replaced.
 *
 * Results:
 *	Returns a normal Tcl result.
 *
 * Side effects:
 *	May create new keys or values.
 *
 *----------------------------------------------------------------------
 */

static int
SetValue(
    Tcl_Interp *interp,		/* Current interpreter. */
    Tcl_Obj *keyNameObj,	/* Name of key. */
    Tcl_Obj *valueNameObj,	/* Name of value to set. */
    Tcl_Obj *dataObj,		/* Data to be written. */
    Tcl_Obj *typeObj)		/* Type of data to be written. */
{
    DWORD type, result;
    HKEY key;
    int length;
    char *valueName;
    Tcl_Obj *resultPtr;
    Tcl_DString nameBuf;

    if (typeObj == NULL) {
	type = REG_SZ;
    } else if (Tcl_GetIndexFromObj(interp, typeObj, typeNames, "type",
	    0, (int *) &type) != TCL_OK) {
	if (Tcl_GetIntFromObj(NULL, typeObj, (int*) &type) != TCL_OK) {
	    return TCL_ERROR;
	}
	Tcl_ResetResult(interp);
    }
    if (OpenKey(interp, keyNameObj, KEY_ALL_ACCESS, 1, &key) != TCL_OK) {
	return TCL_ERROR;
    }

    valueName = Tcl_GetStringFromObj(valueNameObj, &length);
    valueName = (char *) Tcl_WinUtfToTChar(valueName, length, &nameBuf);
    resultPtr = Tcl_GetObjResult(interp);

    if (type == REG_DWORD || type == REG_DWORD_BIG_ENDIAN) {
	DWORD value;
	if (Tcl_GetIntFromObj(interp, dataObj, (int*) &value) != TCL_OK) {
	    RegCloseKey(key);
	    Tcl_DStringFree(&nameBuf);
	    return TCL_ERROR;
	}

	value = ConvertDWORD(type, value);
	result = (*regWinProcs->regSetValueExProc)(key, valueName, 0, type,
		(BYTE*) &value, sizeof(DWORD));
    } else if (type == REG_MULTI_SZ) {
	Tcl_DString data, buf;
	int objc, i;
	Tcl_Obj **objv;

	if (Tcl_ListObjGetElements(interp, dataObj, &objc, &objv) != TCL_OK) {
	    RegCloseKey(key);
	    Tcl_DStringFree(&nameBuf);
	    return TCL_ERROR;
	}

	/*
	 * Append the elements as null terminated strings.  Note that
	 * we must not assume the length of the string in case there are
	 * embedded nulls, which aren't allowed in REG_MULTI_SZ values.
	 */

	Tcl_DStringInit(&data);
	for (i = 0; i < objc; i++) {
	    Tcl_DStringAppend(&data, Tcl_GetString(objv[i]), -1);

	    /*
	     * Add a null character to separate this value from the next.
	     * We accomplish this by growing the string by one byte.  Since the
	     * DString always tacks on an extra null byte, the new byte will
	     * already be set to null.
	     */

	    Tcl_DStringSetLength(&data, Tcl_DStringLength(&data)+1);
	}

	Tcl_WinUtfToTChar(Tcl_DStringValue(&data), Tcl_DStringLength(&data)+1,
		&buf);
	result = (*regWinProcs->regSetValueExProc)(key, valueName, 0, type,
		(BYTE *) Tcl_DStringValue(&buf),
		(DWORD) Tcl_DStringLength(&buf));
	Tcl_DStringFree(&data);
	Tcl_DStringFree(&buf);
    } else if (type == REG_SZ || type == REG_EXPAND_SZ) {
	Tcl_DString buf;
	char *data = Tcl_GetStringFromObj(dataObj, &length);

	data = (char *) Tcl_WinUtfToTChar(data, length, &buf);

	/*
	 * Include the null in the length, padding if needed for Unicode.
	 */

	if (regWinProcs->useWide) {
	    Tcl_DStringSetLength(&buf, Tcl_DStringLength(&buf)+1);
	}
	length = Tcl_DStringLength(&buf) + 1;

	result = (*regWinProcs->regSetValueExProc)(key, valueName, 0, type,
		(BYTE*)data, (DWORD) length);
	Tcl_DStringFree(&buf);
    } else {
	char *data;

	/*
	 * Store binary data in the registry.
	 */

	data = Tcl_GetByteArrayFromObj(dataObj, &length);
	result = (*regWinProcs->regSetValueExProc)(key, valueName, 0, type,
		(BYTE *)data, (DWORD) length);
    }
    Tcl_DStringFree(&nameBuf);
    RegCloseKey(key);
    if (result != ERROR_SUCCESS) {
	Tcl_AppendToObj(resultPtr, "unable to set value: ", -1);
	AppendSystemError(interp, result);
	return TCL_ERROR;
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * BroadcastValue --
 *
 *	This function broadcasts a WM_SETTINGCHANGE message to indicate
 *	to other programs that we have changed the contents of a registry
 *	value.
 *
 * Results:
 *	Returns a normal Tcl result.
 *
 * Side effects:
 *	Will cause other programs to reload their system settings.
 *
 *----------------------------------------------------------------------
 */

static int
BroadcastValue(
    Tcl_Interp *interp,		/* Current interpreter. */
    int objc,			/* Number of arguments. */
    Tcl_Obj * CONST objv[])	/* Argument values. */
{
    DWORD result, sendResult;
    UINT timeout = 3000;
    int len;
    char *str;
    Tcl_Obj *objPtr;

    if ((objc != 3) && (objc != 5)) {
	Tcl_WrongNumArgs(interp, 2, objv, "keyName ?-timeout millisecs?");
	return TCL_ERROR;
    }

    if (objc > 3) {
	str = Tcl_GetStringFromObj(objv[3], &len);
	if ((len < 2) || (*str != '-') || strncmp(str, "-timeout", (size_t) len)) {
	    Tcl_WrongNumArgs(interp, 2, objv, "keyName ?-timeout millisecs?");
	    return TCL_ERROR;
	}
	if (Tcl_GetIntFromObj(interp, objv[4], (int *) &timeout) != TCL_OK) {
	    return TCL_ERROR;
	}
    }

    str = Tcl_GetStringFromObj(objv[2], &len);
    if (len == 0) {
	str = NULL;
    }

    /*
     * Use the ignore the result.
     */
    result = SendMessageTimeout(HWND_BROADCAST, WM_SETTINGCHANGE,
	    (WPARAM) 0, (LPARAM) str, SMTO_ABORTIFHUNG, timeout, &sendResult);

    objPtr = Tcl_NewObj();
    Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewIntObj((int) result));
    Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewIntObj((int) sendResult));
    Tcl_SetObjResult(interp, objPtr);

    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * AppendSystemError --
 *
 *	This routine formats a Windows system error message and places
 *	it into the interpreter result.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static void
AppendSystemError(
    Tcl_Interp *interp,		/* Current interpreter. */
    DWORD error)		/* Result code from error. */
{
    int length;
    WCHAR *wMsgPtr;
    char *msg;
    char id[TCL_INTEGER_SPACE], msgBuf[24 + TCL_INTEGER_SPACE];
    Tcl_DString ds;
    Tcl_Obj *resultPtr = Tcl_GetObjResult(interp);

    length = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM
	    | FORMAT_MESSAGE_ALLOCATE_BUFFER, NULL, error,
	    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (WCHAR *) &wMsgPtr,
	    0, NULL);
    if (length == 0) {
	char *msgPtr;

	length = FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM
		| FORMAT_MESSAGE_ALLOCATE_BUFFER, NULL, error,
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (char *) &msgPtr,
		0, NULL);
	if (length > 0) {
	    wMsgPtr = (WCHAR *) LocalAlloc(LPTR, (length + 1) * sizeof(WCHAR));
	    MultiByteToWideChar(CP_ACP, 0, msgPtr, length + 1, wMsgPtr,
		    length + 1);
	    LocalFree(msgPtr);
	}
    }
    if (length == 0) {
	if (error == ERROR_CALL_NOT_IMPLEMENTED) {
	    msg = "function not supported under Win32s";
	} else {
	    sprintf(msgBuf, "unknown error: %ld", error);
	    msg = msgBuf;
	}
    } else {
	Tcl_Encoding encoding;

	encoding = Tcl_GetEncoding(NULL, "unicode");
	Tcl_ExternalToUtfDString(encoding, (char *) wMsgPtr, -1, &ds);
	Tcl_FreeEncoding(encoding);
	LocalFree(wMsgPtr);

	msg = Tcl_DStringValue(&ds);
	length = Tcl_DStringLength(&ds);

	/*
	 * Trim the trailing CR/LF from the system message.
	 */
	if (msg[length-1] == '\n') {
	    msg[--length] = 0;
	}
	if (msg[length-1] == '\r') {
	    msg[--length] = 0;
	}
    }

    sprintf(id, "%ld", error);
    Tcl_SetErrorCode(interp, "WINDOWS", id, msg, (char *) NULL);
    Tcl_AppendToObj(resultPtr, msg, length);

    if (length != 0) {
	Tcl_DStringFree(&ds);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * ConvertDWORD --
 *
 *	This function determines whether a DWORD needs to be byte
 *	swapped, and returns the appropriately swapped value.
 *
 * Results:
 *	Returns a converted DWORD.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static DWORD
ConvertDWORD(
    DWORD type,			/* Either REG_DWORD or REG_DWORD_BIG_ENDIAN */
    DWORD value)		/* The value to be converted. */
{
    DWORD order = 1;
    DWORD localType;

    /*
     * Check to see if the low bit is in the first byte.
     */

    localType = (*((char*)(&order)) == 1) ? REG_DWORD : REG_DWORD_BIG_ENDIAN;
    return (type != localType) ? SWAPLONG(value) : value;
}
@


1.5
log
@Updated to tcl 8.4.1
@
text
@d14 1
a14 1
 * RCS: @@(#) $Id: tclWinReg.c,v 1.18 2002/10/18 23:58:18 hobbs Exp $
d231 1
a231 1
    return Tcl_PkgProvide(interp, "registry", "1.0");
d1344 1
a1344 1
	if ((len < 2) || (*str != '-') || strncmp(str, "-timeout", len)) {
d1354 1
a1354 1
    if (len = 0) {
d1365 2
a1366 2
    Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewIntObj(result));
    Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewIntObj(sendResult));
@


1.4
log
@touched all sources to ease next import
@
text
@d14 1
a14 1
 * RCS: @@(#) $Id: tclWinReg.c,v 1.6.8.2 2000/09/15 16:58:52 spolk Exp $
a19 4
#define WIN32_LEAN_AND_MEAN
#include <windows.h>
#undef WIN32_LEAN_AND_MEAN

d48 1
a48 1
static char *rootKeyNames[] = {
d66 1
a66 1
static char *typeNames[] = {
d83 1
a83 1
    LONG (WINAPI *regConnectRegistryProc)(TCHAR *, HKEY, PHKEY);
d109 1
a109 1
    (LONG (WINAPI *)(TCHAR *, HKEY, PHKEY)) RegConnectRegistryA,
d134 1
a134 1
    (LONG (WINAPI *)(TCHAR *, HKEY, PHKEY)) RegConnectRegistryW,
d162 2
d184 2
a185 1
static DWORD		RecursiveDeleteKey(HKEY hStartKey, TCHAR * pKeyName);
d260 7
a266 3
    static char *subcommands[] = { "delete", "get", "keys", "set", "type",
				   "values", (char *) NULL };
    enum SubCmdIdx { DeleteIdx, GetIdx, KeysIdx, SetIdx, TypeIdx, ValuesIdx };
d279 3
d365 1
d377 1
a377 1
    buffer = ckalloc(length + 1);
d418 2
a419 2
    tail = Tcl_WinUtfToTChar(tail, -1, &buf);
    result = RecursiveDeleteKey(subkey, tail);
d593 1
d612 2
a613 2
    valueName = Tcl_WinUtfToTChar(valueName, length, &ds);
    result = (*regWinProcs->regQueryValueExProc)(key, valueName, NULL, &type,
d632 1
a632 1
	Tcl_SetIntObj(resultPtr, type);
d665 1
d692 1
a692 1
    Tcl_DStringSetLength(&data, length);
d697 1
a697 1
    valueName = Tcl_WinUtfToTChar(valueName, nameLen, &buf);
d699 1
a699 1
    result = (*regWinProcs->regQueryValueExProc)(key, valueName, NULL, &type,
d708 3
a710 3
        Tcl_DStringSetLength(&data, length);
        result = (*regWinProcs->regQueryValueExProc)(key, valueName, NULL,
		&type, (BYTE *) Tcl_DStringValue(&data), &length);
d731 1
a731 1
	Tcl_SetIntObj(resultPtr, ConvertDWORD(type,
d766 1
a766 1
	Tcl_SetByteArrayObj(resultPtr, Tcl_DStringValue(&data), length);
d834 1
a834 1
	    (regWinProcs->useWide) ? maxSize*2 : maxSize);
d859 1
a859 1
	Tcl_WinTCharToUtf((TCHAR *) Tcl_DStringValue(&buffer), size, &ds);
d913 1
a913 1
    buffer = ckalloc(length + 1);
d968 1
a968 1
	hostName = Tcl_WinUtfToTChar(hostName, -1, &buf);
d982 1
a982 1
    keyName = Tcl_WinUtfToTChar(keyName, -1, &buf);
d1118 1
a1118 1
    char *keyName)		/* Name of key to be deleted in external
d1147 1
a1147 1
	    (regWinProcs->useWide) ? maxSize * 2 : maxSize);
d1216 1
a1216 1
    valueName = Tcl_WinUtfToTChar(valueName, length, &nameBuf);
d1272 1
a1272 1
	data = Tcl_WinUtfToTChar(data, length, &buf);
d1284 1
a1284 1
		(BYTE*)data, length);
d1295 1
a1295 1
		(BYTE *)data, length);
d1310 65
d1423 1
a1423 1
	    sprintf(msgBuf, "unknown error: %d", error);
d1448 1
a1448 1
    sprintf(id, "%d", error);
a1488 3



@


1.3
log
@touched all sources to ease next import
@
text
@@


1.3.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d14 1
a14 1
 * RCS: @@(#) $Id: tclWinReg.c,v 1.20 2003/01/16 19:02:00 mdejong Exp $
d20 4
d52 1
a52 1
static CONST char *rootKeyNames[] = {
d70 1
a70 1
static CONST char *typeNames[] = {
d87 1
a87 1
    LONG (WINAPI *regConnectRegistryProc)(CONST TCHAR *, HKEY, PHKEY);
d113 1
a113 1
    (LONG (WINAPI *)(CONST TCHAR *, HKEY, PHKEY)) RegConnectRegistryA,
d138 1
a138 1
    (LONG (WINAPI *)(CONST TCHAR *, HKEY, PHKEY)) RegConnectRegistryW,
a165 2
static int		BroadcastValue(Tcl_Interp *interp, int objc,
			    Tcl_Obj * CONST objv[]);
d186 1
a186 2
static DWORD		RecursiveDeleteKey(HKEY hStartKey,
			    CONST TCHAR * pKeyName);
d232 1
a232 1
    return Tcl_PkgProvide(interp, "registry", "1.1");
d261 3
a263 7
    static CONST char *subcommands[] = {
	"broadcast", "delete", "get", "keys", "set", "type", "values",
	(char *) NULL
    };
    enum SubCmdIdx {
	BroadcastIdx, DeleteIdx, GetIdx, KeysIdx, SetIdx, TypeIdx, ValuesIdx
    };
a275 3
	case BroadcastIdx:		/* broadcast */
	    return BroadcastValue(interp, objc, objv);
	    break;
a358 1
    CONST char *nativeTail;
d370 1
a370 1
    buffer = ckalloc((unsigned int) length + 1);
d411 2
a412 2
    nativeTail = Tcl_WinUtfToTChar(tail, -1, &buf);
    result = RecursiveDeleteKey(subkey, nativeTail);
a585 1
    CONST char *nativeValue;
d604 2
a605 2
    nativeValue = Tcl_WinUtfToTChar(valueName, length, &ds);
    result = (*regWinProcs->regQueryValueExProc)(key, nativeValue, NULL, &type,
d624 1
a624 1
	Tcl_SetIntObj(resultPtr, (int) type);
a656 1
    CONST char *nativeValue;
d683 1
a683 1
    Tcl_DStringSetLength(&data, (int) length);
d688 1
a688 1
    nativeValue = Tcl_WinUtfToTChar(valueName, nameLen, &buf);
d690 1
a690 1
    result = (*regWinProcs->regQueryValueExProc)(key, nativeValue, NULL, &type,
d699 3
a701 3
        Tcl_DStringSetLength(&data, (int) length);
        result = (*regWinProcs->regQueryValueExProc)(key, (char *) nativeValue,
		NULL, &type, (BYTE *) Tcl_DStringValue(&data), &length);
d722 1
a722 1
	Tcl_SetIntObj(resultPtr, (int) ConvertDWORD(type,
d757 1
a757 1
	Tcl_SetByteArrayObj(resultPtr, Tcl_DStringValue(&data), (int) length);
d825 1
a825 1
	    (int) ((regWinProcs->useWide) ? maxSize*2 : maxSize));
d850 1
a850 1
	Tcl_WinTCharToUtf((TCHAR *) Tcl_DStringValue(&buffer), (int) size, &ds);
d904 1
a904 1
    buffer = ckalloc((unsigned int) length + 1);
d959 1
a959 1
	hostName = (char *) Tcl_WinUtfToTChar(hostName, -1, &buf);
d973 1
a973 1
    keyName = (char *) Tcl_WinUtfToTChar(keyName, -1, &buf);
d1109 1
a1109 1
    CONST char *keyName)	/* Name of key to be deleted in external
d1138 1
a1138 1
	    (int) ((regWinProcs->useWide) ? maxSize * 2 : maxSize));
d1207 1
a1207 1
    valueName = (char *) Tcl_WinUtfToTChar(valueName, length, &nameBuf);
d1263 1
a1263 1
	data = (char *) Tcl_WinUtfToTChar(data, length, &buf);
d1275 1
a1275 1
		(BYTE*)data, (DWORD) length);
d1286 1
a1286 1
		(BYTE *)data, (DWORD) length);
a1300 65
 * BroadcastValue --
 *
 *	This function broadcasts a WM_SETTINGCHANGE message to indicate
 *	to other programs that we have changed the contents of a registry
 *	value.
 *
 * Results:
 *	Returns a normal Tcl result.
 *
 * Side effects:
 *	Will cause other programs to reload their system settings.
 *
 *----------------------------------------------------------------------
 */

static int
BroadcastValue(
    Tcl_Interp *interp,		/* Current interpreter. */
    int objc,			/* Number of arguments. */
    Tcl_Obj * CONST objv[])	/* Argument values. */
{
    DWORD result, sendResult;
    UINT timeout = 3000;
    int len;
    char *str;
    Tcl_Obj *objPtr;

    if ((objc != 3) && (objc != 5)) {
	Tcl_WrongNumArgs(interp, 2, objv, "keyName ?-timeout millisecs?");
	return TCL_ERROR;
    }

    if (objc > 3) {
	str = Tcl_GetStringFromObj(objv[3], &len);
	if ((len < 2) || (*str != '-') || strncmp(str, "-timeout", (size_t) len)) {
	    Tcl_WrongNumArgs(interp, 2, objv, "keyName ?-timeout millisecs?");
	    return TCL_ERROR;
	}
	if (Tcl_GetIntFromObj(interp, objv[4], (int *) &timeout) != TCL_OK) {
	    return TCL_ERROR;
	}
    }

    str = Tcl_GetStringFromObj(objv[2], &len);
    if (len == 0) {
	str = NULL;
    }

    /*
     * Use the ignore the result.
     */
    result = SendMessageTimeout(HWND_BROADCAST, WM_SETTINGCHANGE,
	    (WPARAM) 0, (LPARAM) str, SMTO_ABORTIFHUNG, timeout, &sendResult);

    objPtr = Tcl_NewObj();
    Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewIntObj((int) result));
    Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewIntObj((int) sendResult));
    Tcl_SetObjResult(interp, objPtr);

    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
d1349 1
a1349 1
	    sprintf(msgBuf, "unknown error: %ld", error);
d1374 1
a1374 1
    sprintf(id, "%ld", error);
d1415 3
@


1.3.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@d14 1
a14 1
 * RCS: @@(#) $Id: tclWinReg.c,v 1.17 2002/01/29 03:18:46 hobbs Exp $
d20 4
d52 1
a52 1
static CONST char *rootKeyNames[] = {
d70 1
a70 1
static CONST char *typeNames[] = {
d87 1
a87 1
    LONG (WINAPI *regConnectRegistryProc)(CONST TCHAR *, HKEY, PHKEY);
d113 1
a113 1
    (LONG (WINAPI *)(CONST TCHAR *, HKEY, PHKEY)) RegConnectRegistryA,
d138 1
a138 1
    (LONG (WINAPI *)(CONST TCHAR *, HKEY, PHKEY)) RegConnectRegistryW,
d186 1
a186 2
static DWORD		RecursiveDeleteKey(HKEY hStartKey,
			    CONST TCHAR * pKeyName);
d261 2
a262 3
    static CONST char *subcommands[] = {
	"delete", "get", "keys", "set", "type", "values", (char *) NULL
    };
a358 1
    CONST char *nativeTail;
d370 1
a370 1
    buffer = ckalloc((unsigned int) length + 1);
d411 2
a412 2
    nativeTail = Tcl_WinUtfToTChar(tail, -1, &buf);
    result = RecursiveDeleteKey(subkey, nativeTail);
a585 1
    CONST char *nativeValue;
d604 2
a605 2
    nativeValue = Tcl_WinUtfToTChar(valueName, length, &ds);
    result = (*regWinProcs->regQueryValueExProc)(key, nativeValue, NULL, &type,
d624 1
a624 1
	Tcl_SetIntObj(resultPtr, (int) type);
a656 1
    CONST char *nativeValue;
d683 1
a683 1
    Tcl_DStringSetLength(&data, (int) length);
d688 1
a688 1
    nativeValue = Tcl_WinUtfToTChar(valueName, nameLen, &buf);
d690 1
a690 1
    result = (*regWinProcs->regQueryValueExProc)(key, nativeValue, NULL, &type,
d699 3
a701 3
        Tcl_DStringSetLength(&data, (int) length);
        result = (*regWinProcs->regQueryValueExProc)(key, (char *) nativeValue,
		NULL, &type, (BYTE *) Tcl_DStringValue(&data), &length);
d722 1
a722 1
	Tcl_SetIntObj(resultPtr, (int) ConvertDWORD(type,
d757 1
a757 1
	Tcl_SetByteArrayObj(resultPtr, Tcl_DStringValue(&data), (int) length);
d825 1
a825 1
	    (int) ((regWinProcs->useWide) ? maxSize*2 : maxSize));
d850 1
a850 1
	Tcl_WinTCharToUtf((TCHAR *) Tcl_DStringValue(&buffer), (int) size, &ds);
d904 1
a904 1
    buffer = ckalloc((unsigned int) length + 1);
d959 1
a959 1
	hostName = (char *) Tcl_WinUtfToTChar(hostName, -1, &buf);
d973 1
a973 1
    keyName = (char *) Tcl_WinUtfToTChar(keyName, -1, &buf);
d1109 1
a1109 1
    CONST char *keyName)	/* Name of key to be deleted in external
d1138 1
a1138 1
	    (int) ((regWinProcs->useWide) ? maxSize * 2 : maxSize));
d1207 1
a1207 1
    valueName = (char *) Tcl_WinUtfToTChar(valueName, length, &nameBuf);
d1263 1
a1263 1
	data = (char *) Tcl_WinUtfToTChar(data, length, &buf);
d1275 1
a1275 1
		(BYTE*)data, (DWORD) length);
d1286 1
a1286 1
		(BYTE *)data, (DWORD) length);
d1349 1
a1349 1
	    sprintf(msgBuf, "unknown error: %ld", error);
d1374 1
a1374 1
    sprintf(id, "%ld", error);
d1415 3
@


1.2
log
@touched all Tcl files to ease next import.
@
text
@@


1.2.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.2.16.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d20 4
d52 1
a52 1
static CONST char *rootKeyNames[] = {
d70 1
a70 1
static CONST char *typeNames[] = {
d87 1
a87 1
    LONG (WINAPI *regConnectRegistryProc)(CONST TCHAR *, HKEY, PHKEY);
d113 1
a113 1
    (LONG (WINAPI *)(CONST TCHAR *, HKEY, PHKEY)) RegConnectRegistryA,
d138 1
a138 1
    (LONG (WINAPI *)(CONST TCHAR *, HKEY, PHKEY)) RegConnectRegistryW,
a165 2
static int		BroadcastValue(Tcl_Interp *interp, int objc,
			    Tcl_Obj * CONST objv[]);
d186 1
a186 2
static DWORD		RecursiveDeleteKey(HKEY hStartKey,
			    CONST TCHAR * pKeyName);
d261 3
a263 7
    static CONST char *subcommands[] = {
	"broadcast", "delete", "get", "keys", "set", "type", "values",
	(char *) NULL
    };
    enum SubCmdIdx {
	BroadcastIdx, DeleteIdx, GetIdx, KeysIdx, SetIdx, TypeIdx, ValuesIdx
    };
a275 3
	case BroadcastIdx:		/* broadcast */
	    return BroadcastValue(interp, objc, objv);
	    break;
a358 1
    CONST char *nativeTail;
d370 1
a370 1
    buffer = ckalloc((unsigned int) length + 1);
d411 2
a412 2
    nativeTail = Tcl_WinUtfToTChar(tail, -1, &buf);
    result = RecursiveDeleteKey(subkey, nativeTail);
a585 1
    CONST char *nativeValue;
d604 2
a605 2
    nativeValue = Tcl_WinUtfToTChar(valueName, length, &ds);
    result = (*regWinProcs->regQueryValueExProc)(key, nativeValue, NULL, &type,
d624 1
a624 1
	Tcl_SetIntObj(resultPtr, (int) type);
a656 1
    CONST char *nativeValue;
d683 1
a683 1
    Tcl_DStringSetLength(&data, (int) length);
d688 1
a688 1
    nativeValue = Tcl_WinUtfToTChar(valueName, nameLen, &buf);
d690 1
a690 1
    result = (*regWinProcs->regQueryValueExProc)(key, nativeValue, NULL, &type,
d699 3
a701 3
        Tcl_DStringSetLength(&data, (int) length);
        result = (*regWinProcs->regQueryValueExProc)(key, (char *) nativeValue,
		NULL, &type, (BYTE *) Tcl_DStringValue(&data), &length);
d722 1
a722 1
	Tcl_SetIntObj(resultPtr, (int) ConvertDWORD(type,
d757 1
a757 1
	Tcl_SetByteArrayObj(resultPtr, Tcl_DStringValue(&data), (int) length);
d825 1
a825 1
	    (int) ((regWinProcs->useWide) ? maxSize*2 : maxSize));
d850 1
a850 1
	Tcl_WinTCharToUtf((TCHAR *) Tcl_DStringValue(&buffer), (int) size, &ds);
d904 1
a904 1
    buffer = ckalloc((unsigned int) length + 1);
d959 1
a959 1
	hostName = (char *) Tcl_WinUtfToTChar(hostName, -1, &buf);
d973 1
a973 1
    keyName = (char *) Tcl_WinUtfToTChar(keyName, -1, &buf);
d1109 1
a1109 1
    CONST char *keyName)	/* Name of key to be deleted in external
d1138 1
a1138 1
	    (int) ((regWinProcs->useWide) ? maxSize * 2 : maxSize));
d1207 1
a1207 1
    valueName = (char *) Tcl_WinUtfToTChar(valueName, length, &nameBuf);
d1263 1
a1263 1
	data = (char *) Tcl_WinUtfToTChar(data, length, &buf);
d1275 1
a1275 1
		(BYTE*)data, (DWORD) length);
d1286 1
a1286 1
		(BYTE *)data, (DWORD) length);
a1300 65
 * BroadcastValue --
 *
 *	This function broadcasts a WM_SETTINGCHANGE message to indicate
 *	to other programs that we have changed the contents of a registry
 *	value.
 *
 * Results:
 *	Returns a normal Tcl result.
 *
 * Side effects:
 *	Will cause other programs to reload their system settings.
 *
 *----------------------------------------------------------------------
 */

static int
BroadcastValue(
    Tcl_Interp *interp,		/* Current interpreter. */
    int objc,			/* Number of arguments. */
    Tcl_Obj * CONST objv[])	/* Argument values. */
{
    DWORD result, sendResult;
    UINT timeout = 3000;
    int len;
    char *str;
    Tcl_Obj *objPtr;

    if ((objc != 3) && (objc != 5)) {
	Tcl_WrongNumArgs(interp, 2, objv, "keyName ?-timeout millisecs?");
	return TCL_ERROR;
    }

    if (objc > 3) {
	str = Tcl_GetStringFromObj(objv[3], &len);
	if ((len < 2) || (*str != '-') || strncmp(str, "-timeout", len)) {
	    Tcl_WrongNumArgs(interp, 2, objv, "keyName ?-timeout millisecs?");
	    return TCL_ERROR;
	}
	if (Tcl_GetIntFromObj(interp, objv[4], (int *) &timeout) != TCL_OK) {
	    return TCL_ERROR;
	}
    }

    str = Tcl_GetStringFromObj(objv[2], &len);
    if (len = 0) {
	str = NULL;
    }

    /*
     * Use the ignore the result.
     */
    result = SendMessageTimeout(HWND_BROADCAST, WM_SETTINGCHANGE,
	    (WPARAM) 0, (LPARAM) str, SMTO_ABORTIFHUNG, timeout, &sendResult);

    objPtr = Tcl_NewObj();
    Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewIntObj(result));
    Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewIntObj(sendResult));
    Tcl_SetObjResult(interp, objPtr);

    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
d1349 1
a1349 1
	    sprintf(msgBuf, "unknown error: %ld", error);
d1374 1
a1374 1
    sprintf(id, "%ld", error);
d1415 3
@


1.2.16.3
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d231 1
a231 1
    return Tcl_PkgProvide(interp, "registry", "1.1");
d1344 1
a1344 1
	if ((len < 2) || (*str != '-') || strncmp(str, "-timeout", (size_t) len)) {
d1354 1
a1354 1
    if (len == 0) {
d1365 2
a1366 2
    Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewIntObj((int) result));
    Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewIntObj((int) sendResult));
@


1.1
log
@Initial revision
@
text
@d1 1
a1 1
/* 
d9 1
d14 1
a14 1
 * RCS: @@(#) $Id: tclWinReg.c,v 1.6 1998/09/14 18:40:20 stanton Exp $
d17 1
a17 1
#include <tcl.h>
a33 11
 * VC++ has an alternate entry point called DllMain, so we need to rename
 * our entry point.
 */

#ifdef DLL_BUILD
# if defined(_MSC_VER)
#  define DllEntryPoint DllMain
# endif
#endif

/*
d39 1
a39 1
 
d54 2
a55 1
    "HKEY_CURRENT_USER", "HKEY_CURRENT_CONFIG", NULL
d71 1
a71 1
    "none", "sz", "expand_sz", "binary", "dword", 
d77 83
d186 1
a186 1
static DWORD		RecursiveDeleteKey(HKEY hStartKey, LPTSTR pKeyName);
d188 2
a189 1
			    Tcl_Interp *interp, int objc, Tcl_Obj * CONST objv[]);
a198 32
 * DllEntryPoint --
 *
 *	This wrapper function is used by Windows to invoke the
 *	initialization code for the DLL.  If we are compiling
 *	with Visual C++, this routine will be renamed to DllMain.
 *	routine.
 *
 * Results:
 *	Returns TRUE;
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

#ifdef __WIN32__
#ifdef DLL_BUILD
BOOL APIENTRY
DllEntryPoint(
    HINSTANCE hInst,		/* Library instance handle. */
    DWORD reason,		/* Reason this function is being called. */
    LPVOID reserved)		/* Not used. */
{
    return TRUE;
}
#endif
#endif

/*
 *----------------------------------------------------------------------
 *
d216 15
d363 1
d411 1
d413 1
d455 2
a456 1
    
d468 3
a470 1
    result = RegDeleteValue(key, valueName);
d473 2
a474 2
		Tcl_GetStringFromObj(valueNameObj, NULL), "\" from key \"",
		Tcl_GetStringFromObj(keyNameObj, NULL), "\": ", NULL);
d511 1
a511 1
    char buffer[MAX_PATH+1], *pattern;
d514 1
d526 1
a526 1
	pattern = Tcl_GetStringFromObj(patternObj, NULL);
d537 6
a542 3
    for (index = 0; RegEnumKey(key, index, buffer, MAX_PATH+1)
	     == ERROR_SUCCESS; index++) {
	if (pattern && !Tcl_StringMatch(buffer, pattern)) {
d546 2
a547 1
		Tcl_NewStringObj(buffer, -1));
d584 4
a587 1
    
d603 5
a607 2
    result = RegQueryValueEx(key, Tcl_GetStringFromObj(valueNameObj, NULL),
	    NULL, &type, NULL, NULL);
d612 2
a613 2
		Tcl_GetStringFromObj(valueNameObj, NULL), "\" from key \"",
		Tcl_GetStringFromObj(keyNameObj, NULL), "\": ", NULL);
d659 2
a660 1
    Tcl_DString data;
d675 1
a675 1
     * should be safer if the implementation Dstrings changes.
d682 2
a683 1
    Tcl_DStringSetLength(&data, length = TCL_DSTRING_STATIC_SIZE - 1);
d686 13
a698 5
  
    valueName = Tcl_GetStringFromObj(valueNameObj, NULL);
    result = RegQueryValueEx(key, valueName, NULL, &type,
	    (LPBYTE) Tcl_DStringValue(&data), &length);
    if (result == ERROR_MORE_DATA) {
d700 2
a701 2
        result = RegQueryValueEx(key, valueName, NULL, &type,
                (LPBYTE) Tcl_DStringValue(&data), &length);
d703 1
d707 2
a708 2
		Tcl_GetStringFromObj(valueNameObj, NULL), "\" from key \"",
		Tcl_GetStringFromObj(keyNameObj, NULL), "\": ", NULL);
d726 1
a726 1
	char *lastChar = Tcl_DStringValue(&data) + Tcl_DStringLength(&data);
d733 4
a736 2

	while (p < lastChar && *p != '\0') {
d738 8
a745 2
		    Tcl_NewStringObj(p, -1));
	    while (*p++ != '\0') {}
d748 4
a751 1
	Tcl_SetStringObj(resultPtr, Tcl_DStringValue(&data), -1);
d753 5
a757 1
	Tcl_SetStringObj(resultPtr, Tcl_DStringValue(&data), length);
d790 3
a792 3
    DWORD index, size, result;
    Tcl_DString buffer;
    char *pattern;
d810 2
a811 2
    result = RegQueryInfoKey(key, NULL, NULL, NULL, NULL, NULL, NULL, &index,
	&size, NULL, NULL, NULL);
d814 1
a814 1
		Tcl_GetStringFromObj(keyNameObj, NULL), "\": ", NULL);
d820 1
a820 1
    size++;
d824 2
a825 1
    Tcl_DStringSetLength(&buffer, size);
d830 1
a830 1
	pattern = Tcl_GetStringFromObj(patternObj, NULL);
d841 12
a852 3
    while (RegEnumValue(key, index, Tcl_DStringValue(&buffer), &size, NULL,
	    NULL, NULL, NULL) == ERROR_SUCCESS) {
	if (!pattern || Tcl_StringMatch(Tcl_DStringValue(&buffer), pattern)) {
d854 1
a854 1
		    Tcl_NewStringObj(Tcl_DStringValue(&buffer), size));
d856 1
d860 2
d863 1
a863 1
	size = Tcl_DStringLength(&buffer);
d952 1
d959 4
a962 1
	result = RegConnectRegistry(hostName, rootKey, &rootKey);
d973 1
d976 1
a976 1
	result = RegCreateKeyEx(rootKey, keyName, 0, "",
d979 12
a990 1
	result = RegOpenKeyEx(rootKey, keyName, 0, mode, keyPtr);
d992 1
d1001 1
a1001 1
    return result; 
d1010 1
a1010 1
 *	parts. 
d1109 2
a1110 1
    char *keyName)		/* Name of key to be deleted. */
d1112 1
a1112 1
    DWORD result, subKeyLength;
d1120 1
a1120 1
    if (!keyName || lstrlen(keyName) == '\0') {
d1124 1
a1124 1
    result = RegOpenKeyEx(startKey, keyName, 0,
d1129 3
a1131 3
    result = RegQueryInfoKey(hKey, NULL, NULL, NULL, NULL, &subKeyLength,
	    NULL, NULL, NULL, NULL, NULL, NULL);
    subKeyLength++;
d1137 2
a1138 1
    Tcl_DStringSetLength(&subkey, subKeyLength);
d1145 3
a1147 3
	subKeyLength = Tcl_DStringLength(&subkey);
	result=RegEnumKeyEx(hKey, 0, Tcl_DStringValue(&subkey), &subKeyLength,
		NULL, NULL, NULL, NULL);
d1149 1
a1149 1
	    result = RegDeleteKey(startKey, keyName);
d1191 1
d1207 1
d1214 1
d1219 2
a1220 2
	result = RegSetValueEx(key, valueName, 0, type, (BYTE*) &value,
		sizeof(DWORD));
d1222 1
a1222 1
	Tcl_DString data;
a1224 1
	char *element;
d1228 1
d1240 9
a1248 2
	    element = Tcl_GetStringFromObj(objv[i], NULL);
	    Tcl_DStringAppend(&data, element, -1);
d1251 6
a1256 3
	result = RegSetValueEx(key, valueName, 0, type,
		(LPBYTE) Tcl_DStringValue(&data),
		(DWORD) (Tcl_DStringLength(&data)+1));
d1258 3
a1260 1
    } else {
d1263 2
d1266 1
a1266 3
	 * Include the null in the length if we are storing a null terminated
	 * string.  Note that we also need to call strlen to find the first
	 * null so we don't pass bad data to the registry.
d1269 2
a1270 2
	if (type == REG_SZ || type == REG_EXPAND_SZ) {
	    length = strlen(data) + 1;
d1272 11
d1284 3
a1286 1
	result = RegSetValueEx(key, valueName, 0, type, (LPBYTE)data, length);
d1288 1
d1321 4
a1324 1
    char *msgbuf, id[10];
d1327 1
a1327 2
    sprintf(id, "%d", error);
    length = FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM
d1329 1
a1329 1
	    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (LPTSTR)&msgbuf,
d1332 14
d1347 1
a1347 1
	    msgbuf = "function not supported under Win32s";
d1349 2
a1350 1
	    msgbuf = id;
d1353 10
d1366 2
a1367 2
	if (msgbuf[length-1] == '\n') {
	    msgbuf[--length] = 0;
d1369 2
a1370 2
	if (msgbuf[length-1] == '\r') {
	    msgbuf[--length] = 0;
d1373 4
a1376 2
    Tcl_SetErrorCode(interp, "WINDOWS", id, msgbuf, (char *) NULL);
    Tcl_AppendToObj(resultPtr, msgbuf, -1);
d1379 1
a1379 1
	LocalFree(msgbuf);
d1415 3
@


1.1.1.1
log
@import dejagnu-1999-11-08 snapshot
@
text
@@


1.1.1.2
log
@Tcl 8.3 upgrade
@
text
@d1 1
a1 1
/*
a8 1
 * Copyright (c) 1998-1999 by Scriptics Corporation.
d13 1
a13 1
 * RCS: @@(#) $Id: tclWinReg.c,v 1.6.8.2 2000/09/15 16:58:52 spolk Exp $
d16 1
a16 1
#include <tclPort.h>
d33 11
d49 1
a49 1

d64 1
a64 2
    "HKEY_CURRENT_USER", "HKEY_CURRENT_CONFIG",
    "HKEY_PERFORMANCE_DATA", "HKEY_DYN_DATA", NULL
d80 1
a80 1
    "none", "sz", "expand_sz", "binary", "dword",
a85 83
/*
 * The following structures allow us to select between the Unicode and ASCII
 * interfaces at run time based on whether Unicode APIs are available.  The
 * Unicode APIs are preferable because they will handle characters outside
 * of the current code page.
 */

typedef struct RegWinProcs {
    int useWide;

    LONG (WINAPI *regConnectRegistryProc)(TCHAR *, HKEY, PHKEY);
    LONG (WINAPI *regCreateKeyExProc)(HKEY, CONST TCHAR *, DWORD, TCHAR *,
	    DWORD, REGSAM, SECURITY_ATTRIBUTES *, HKEY *, DWORD *); 
    LONG (WINAPI *regDeleteKeyProc)(HKEY, CONST TCHAR *);
    LONG (WINAPI *regDeleteValueProc)(HKEY, CONST TCHAR *);
    LONG (WINAPI *regEnumKeyProc)(HKEY, DWORD, TCHAR *, DWORD);
    LONG (WINAPI *regEnumKeyExProc)(HKEY, DWORD, TCHAR *, DWORD *, DWORD *,
	    TCHAR *, DWORD *, FILETIME *);
    LONG (WINAPI *regEnumValueProc)(HKEY, DWORD, TCHAR *, DWORD *, DWORD *,
	    DWORD *, BYTE *, DWORD *);
    LONG (WINAPI *regOpenKeyExProc)(HKEY, CONST TCHAR *, DWORD, REGSAM,
	    HKEY *);
    LONG (WINAPI *regQueryInfoKeyProc)(HKEY, TCHAR *, DWORD *, DWORD *,
	    DWORD *, DWORD *, DWORD *, DWORD *, DWORD *, DWORD *, DWORD *,
	    FILETIME *);
    LONG (WINAPI *regQueryValueExProc)(HKEY, CONST TCHAR *, DWORD *, DWORD *,
	    BYTE *, DWORD *);
    LONG (WINAPI *regSetValueExProc)(HKEY, CONST TCHAR *, DWORD, DWORD,
	    CONST BYTE*, DWORD);
} RegWinProcs;

static RegWinProcs *regWinProcs;

static RegWinProcs asciiProcs = {
    0,

    (LONG (WINAPI *)(TCHAR *, HKEY, PHKEY)) RegConnectRegistryA,
    (LONG (WINAPI *)(HKEY, CONST TCHAR *, DWORD, TCHAR *,
	    DWORD, REGSAM, SECURITY_ATTRIBUTES *, HKEY *,
	    DWORD *)) RegCreateKeyExA, 
    (LONG (WINAPI *)(HKEY, CONST TCHAR *)) RegDeleteKeyA,
    (LONG (WINAPI *)(HKEY, CONST TCHAR *)) RegDeleteValueA,
    (LONG (WINAPI *)(HKEY, DWORD, TCHAR *, DWORD)) RegEnumKeyA,
    (LONG (WINAPI *)(HKEY, DWORD, TCHAR *, DWORD *, DWORD *,
	    TCHAR *, DWORD *, FILETIME *)) RegEnumKeyExA,
    (LONG (WINAPI *)(HKEY, DWORD, TCHAR *, DWORD *, DWORD *,
	    DWORD *, BYTE *, DWORD *)) RegEnumValueA,
    (LONG (WINAPI *)(HKEY, CONST TCHAR *, DWORD, REGSAM,
	    HKEY *)) RegOpenKeyExA,
    (LONG (WINAPI *)(HKEY, TCHAR *, DWORD *, DWORD *,
	    DWORD *, DWORD *, DWORD *, DWORD *, DWORD *, DWORD *, DWORD *,
	    FILETIME *)) RegQueryInfoKeyA,
    (LONG (WINAPI *)(HKEY, CONST TCHAR *, DWORD *, DWORD *,
	    BYTE *, DWORD *)) RegQueryValueExA,
    (LONG (WINAPI *)(HKEY, CONST TCHAR *, DWORD, DWORD,
	    CONST BYTE*, DWORD)) RegSetValueExA,
};

static RegWinProcs unicodeProcs = {
    1,

    (LONG (WINAPI *)(TCHAR *, HKEY, PHKEY)) RegConnectRegistryW,
    (LONG (WINAPI *)(HKEY, CONST TCHAR *, DWORD, TCHAR *,
	    DWORD, REGSAM, SECURITY_ATTRIBUTES *, HKEY *,
	    DWORD *)) RegCreateKeyExW, 
    (LONG (WINAPI *)(HKEY, CONST TCHAR *)) RegDeleteKeyW,
    (LONG (WINAPI *)(HKEY, CONST TCHAR *)) RegDeleteValueW,
    (LONG (WINAPI *)(HKEY, DWORD, TCHAR *, DWORD)) RegEnumKeyW,
    (LONG (WINAPI *)(HKEY, DWORD, TCHAR *, DWORD *, DWORD *,
	    TCHAR *, DWORD *, FILETIME *)) RegEnumKeyExW,
    (LONG (WINAPI *)(HKEY, DWORD, TCHAR *, DWORD *, DWORD *,
	    DWORD *, BYTE *, DWORD *)) RegEnumValueW,
    (LONG (WINAPI *)(HKEY, CONST TCHAR *, DWORD, REGSAM,
	    HKEY *)) RegOpenKeyExW,
    (LONG (WINAPI *)(HKEY, TCHAR *, DWORD *, DWORD *,
	    DWORD *, DWORD *, DWORD *, DWORD *, DWORD *, DWORD *, DWORD *,
	    FILETIME *)) RegQueryInfoKeyW,
    (LONG (WINAPI *)(HKEY, CONST TCHAR *, DWORD *, DWORD *,
	    BYTE *, DWORD *)) RegQueryValueExW,
    (LONG (WINAPI *)(HKEY, CONST TCHAR *, DWORD, DWORD,
	    CONST BYTE*, DWORD)) RegSetValueExW,
};

d112 1
a112 1
static DWORD		RecursiveDeleteKey(HKEY hStartKey, TCHAR * pKeyName);
d114 1
a114 2
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj * CONST objv[]);
d124 32
a172 15
    if (!Tcl_InitStubs(interp, "8.0", 0)) {
	return TCL_ERROR;
    }

    /*
     * Determine if the unicode interfaces are available and select the
     * appropriate registry function table.
     */

    if (TclWinGetPlatformId() == VER_PLATFORM_WIN32_NT) {
	regWinProcs = &unicodeProcs;
    } else {
	regWinProcs = &asciiProcs;
    }

a304 1
    Tcl_DString buf;
a351 1
    tail = Tcl_WinUtfToTChar(tail, -1, &buf);
a352 1
    Tcl_DStringFree(&buf);
d394 1
a394 2
    Tcl_DString ds;

d406 1
a406 3
    Tcl_WinUtfToTChar(valueName, length, &ds);
    result = (*regWinProcs->regDeleteValueProc)(key, Tcl_DStringValue(&ds));
    Tcl_DStringFree(&ds);
d409 2
a410 2
		Tcl_GetString(valueNameObj), "\" from key \"",
		Tcl_GetString(keyNameObj), "\": ", NULL);
d447 1
a447 1
    char buffer[MAX_PATH+1], *pattern, *name;
a449 1
    Tcl_DString ds;
d461 1
a461 1
	pattern = Tcl_GetString(patternObj);
d472 3
a474 6
    for (index = 0; (*regWinProcs->regEnumKeyProc)(key, index, buffer,
	    MAX_PATH+1) == ERROR_SUCCESS; index++) {
	Tcl_WinTCharToUtf((TCHAR *) buffer, -1, &ds);
	name = Tcl_DStringValue(&ds);
	if (pattern && !Tcl_StringMatch(name, pattern)) {
	    Tcl_DStringFree(&ds);
d478 1
a478 2
		Tcl_NewStringObj(name, Tcl_DStringLength(&ds)));
	Tcl_DStringFree(&ds);
d515 1
a515 4
    Tcl_DString ds;
    char *valueName;
    int length;

d531 2
a532 5
    valueName = Tcl_GetStringFromObj(valueNameObj, &length);
    valueName = Tcl_WinUtfToTChar(valueName, length, &ds);
    result = (*regWinProcs->regQueryValueExProc)(key, valueName, NULL, &type,
	    NULL, NULL);
    Tcl_DStringFree(&ds);
d537 2
a538 2
		Tcl_GetString(valueNameObj), "\" from key \"",
		Tcl_GetString(keyNameObj), "\": ", NULL);
d584 1
a584 2
    Tcl_DString data, buf;
    int nameLen;
d599 1
a599 1
     * should be safer if the implementation of Dstrings changes.
d606 1
a606 2
    length = TCL_DSTRING_STATIC_SIZE - 1;
    Tcl_DStringSetLength(&data, length);
d609 5
a613 13

    valueName = Tcl_GetStringFromObj(valueNameObj, &nameLen);
    valueName = Tcl_WinUtfToTChar(valueName, nameLen, &buf);

    result = (*regWinProcs->regQueryValueExProc)(key, valueName, NULL, &type,
	    (BYTE *) Tcl_DStringValue(&data), &length);
    while (result == ERROR_MORE_DATA) {
	/*
	 * The Windows docs say that in this error case, we just need
	 * to expand our buffer and request more data.
	 * Required for HKEY_PERFORMANCE_DATA
	 */
	length *= 2;
d615 2
a616 2
        result = (*regWinProcs->regQueryValueExProc)(key, valueName, NULL,
		&type, (BYTE *) Tcl_DStringValue(&data), &length);
a617 1
    Tcl_DStringFree(&buf);
d621 2
a622 2
		Tcl_GetString(valueNameObj), "\" from key \"",
		Tcl_GetString(keyNameObj), "\": ", NULL);
d640 1
a640 1
	char *end = Tcl_DStringValue(&data) + length;
d647 2
a648 4
 
	while (p < end 	&& ((regWinProcs->useWide) 
		? *((Tcl_UniChar *)p) : *p) != 0) {
	    Tcl_WinTCharToUtf((TCHAR *) p, -1, &buf);
d650 2
a651 8
		    Tcl_NewStringObj(Tcl_DStringValue(&buf),
			    Tcl_DStringLength(&buf)));
	    if (regWinProcs->useWide) {
		while (*((Tcl_UniChar *)p)++ != 0) {}
	    } else {
		while (*p++ != '\0') {}
	    }
	    Tcl_DStringFree(&buf);
d654 1
a654 4
	Tcl_WinTCharToUtf((TCHAR *) Tcl_DStringValue(&data), -1, &buf);
	Tcl_SetStringObj(resultPtr, Tcl_DStringValue(&buf),
		Tcl_DStringLength(&buf));
	Tcl_DStringFree(&buf);
d656 1
a656 5
	/*
	 * Save binary data as a byte array.
	 */

	Tcl_SetByteArrayObj(resultPtr, Tcl_DStringValue(&data), length);
d689 3
a691 3
    DWORD index, size, maxSize, result;
    Tcl_DString buffer, ds;
    char *pattern, *name;
d709 2
a710 2
    result = (*regWinProcs->regQueryInfoKeyProc)(key, NULL, NULL, NULL, NULL,
	    NULL, NULL, &index, &maxSize, NULL, NULL, NULL);
d713 1
a713 1
		Tcl_GetString(keyNameObj), "\": ", NULL);
d719 1
a719 1
    maxSize++;
d723 1
a723 2
    Tcl_DStringSetLength(&buffer,
	    (regWinProcs->useWide) ? maxSize*2 : maxSize);
d728 1
a728 1
	pattern = Tcl_GetString(patternObj);
d739 3
a741 12
    size = maxSize;
    while ((*regWinProcs->regEnumValueProc)(key, index,
	    Tcl_DStringValue(&buffer), &size, NULL, NULL, NULL, NULL)
	    == ERROR_SUCCESS) {

	if (regWinProcs->useWide) {
	    size *= 2;
	}

	Tcl_WinTCharToUtf((TCHAR *) Tcl_DStringValue(&buffer), size, &ds);
	name = Tcl_DStringValue(&ds);
	if (!pattern || Tcl_StringMatch(name, pattern)) {
d743 1
a743 1
		    Tcl_NewStringObj(name, Tcl_DStringLength(&ds)));
a744 1
		Tcl_DStringFree(&ds);
a747 2
	Tcl_DStringFree(&ds);

d749 1
a749 1
	size = maxSize;
a837 1
    Tcl_DString buf;
d844 1
a844 4
	hostName = Tcl_WinUtfToTChar(hostName, -1, &buf);
	result = (*regWinProcs->regConnectRegistryProc)(hostName, rootKey,
		&rootKey);
	Tcl_DStringFree(&buf);
a854 1
    keyName = Tcl_WinUtfToTChar(keyName, -1, &buf);
d857 1
a857 1
	result = (*regWinProcs->regCreateKeyExProc)(rootKey, keyName, 0, "",
d860 1
a860 12
	if (rootKey == HKEY_PERFORMANCE_DATA) {
	    /*
	     * Here we fudge it for this special root key.
	     * See MSDN for more info on HKEY_PERFORMANCE_DATA and
	     * the peculiarities surrounding it
	     */
	    *keyPtr = HKEY_PERFORMANCE_DATA;
	    result = ERROR_SUCCESS;
	} else {
	    result = (*regWinProcs->regOpenKeyExProc)(rootKey, keyName, 0,
		    mode, keyPtr);
	}
a861 1
    Tcl_DStringFree(&buf);
d870 1
a870 1
    return result;
d879 1
a879 1
 *	parts.
d978 1
a978 2
    char *keyName)		/* Name of key to be deleted in external
				 * encoding, not UTF. */
d980 1
a980 1
    DWORD result, size, maxSize;
d988 1
a988 1
    if (!keyName || *keyName == '\0') {
d992 1
a992 1
    result = (*regWinProcs->regOpenKeyExProc)(startKey, keyName, 0,
d997 3
a999 3
    result = (*regWinProcs->regQueryInfoKeyProc)(hKey, NULL, NULL, NULL, NULL,
	    &maxSize, NULL, NULL, NULL, NULL, NULL, NULL);
    maxSize++;
d1005 1
a1005 2
    Tcl_DStringSetLength(&subkey,
	    (regWinProcs->useWide) ? maxSize * 2 : maxSize);
d1012 3
a1014 3
	size = maxSize;
	result=(*regWinProcs->regEnumKeyExProc)(hKey, 0,
		Tcl_DStringValue(&subkey), &size, NULL, NULL, NULL, NULL);
d1016 1
a1016 1
	    result = (*regWinProcs->regDeleteKeyProc)(startKey, keyName);
a1057 1
    Tcl_DString nameBuf;
a1072 1
    valueName = Tcl_WinUtfToTChar(valueName, length, &nameBuf);
a1078 1
	    Tcl_DStringFree(&nameBuf);
d1083 2
a1084 2
	result = (*regWinProcs->regSetValueExProc)(key, valueName, 0, type,
		(BYTE*) &value, sizeof(DWORD));
d1086 1
a1086 1
	Tcl_DString data, buf;
d1089 1
a1092 1
	    Tcl_DStringFree(&nameBuf);
d1104 2
a1105 9
	    Tcl_DStringAppend(&data, Tcl_GetString(objv[i]), -1);

	    /*
	     * Add a null character to separate this value from the next.
	     * We accomplish this by growing the string by one byte.  Since the
	     * DString always tacks on an extra null byte, the new byte will
	     * already be set to null.
	     */

d1108 3
a1110 6

	Tcl_WinUtfToTChar(Tcl_DStringValue(&data), Tcl_DStringLength(&data)+1,
		&buf);
	result = (*regWinProcs->regSetValueExProc)(key, valueName, 0, type,
		(BYTE *) Tcl_DStringValue(&buf),
		(DWORD) Tcl_DStringLength(&buf));
d1112 1
a1112 3
	Tcl_DStringFree(&buf);
    } else if (type == REG_SZ || type == REG_EXPAND_SZ) {
	Tcl_DString buf;
a1114 2
	data = Tcl_WinUtfToTChar(data, length, &buf);

d1116 3
a1118 1
	 * Include the null in the length, padding if needed for Unicode.
d1121 2
a1122 2
	if (regWinProcs->useWide) {
	    Tcl_DStringSetLength(&buf, Tcl_DStringLength(&buf)+1);
a1123 11
	length = Tcl_DStringLength(&buf) + 1;

	result = (*regWinProcs->regSetValueExProc)(key, valueName, 0, type,
		(BYTE*)data, length);
	Tcl_DStringFree(&buf);
    } else {
	char *data;

	/*
	 * Store binary data in the registry.
	 */
d1125 1
a1125 3
	data = Tcl_GetByteArrayFromObj(dataObj, &length);
	result = (*regWinProcs->regSetValueExProc)(key, valueName, 0, type,
		(BYTE *)data, length);
a1126 1
    Tcl_DStringFree(&nameBuf);
d1159 1
a1159 4
    WCHAR *wMsgPtr;
    char *msg;
    char id[TCL_INTEGER_SPACE], msgBuf[24 + TCL_INTEGER_SPACE];
    Tcl_DString ds;
d1162 2
a1163 1
    length = FormatMessageW(FORMAT_MESSAGE_FROM_SYSTEM
d1165 1
a1165 1
	    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (WCHAR *) &wMsgPtr,
a1167 14
	char *msgPtr;

	length = FormatMessageA(FORMAT_MESSAGE_FROM_SYSTEM
		| FORMAT_MESSAGE_ALLOCATE_BUFFER, NULL, error,
		MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), (char *) &msgPtr,
		0, NULL);
	if (length > 0) {
	    wMsgPtr = (WCHAR *) LocalAlloc(LPTR, (length + 1) * sizeof(WCHAR));
	    MultiByteToWideChar(CP_ACP, 0, msgPtr, length + 1, wMsgPtr,
		    length + 1);
	    LocalFree(msgPtr);
	}
    }
    if (length == 0) {
d1169 1
a1169 1
	    msg = "function not supported under Win32s";
d1171 1
a1171 2
	    sprintf(msgBuf, "unknown error: %d", error);
	    msg = msgBuf;
a1173 10
	Tcl_Encoding encoding;

	encoding = Tcl_GetEncoding(NULL, "unicode");
	Tcl_ExternalToUtfDString(encoding, (char *) wMsgPtr, -1, &ds);
	Tcl_FreeEncoding(encoding);
	LocalFree(wMsgPtr);

	msg = Tcl_DStringValue(&ds);
	length = Tcl_DStringLength(&ds);

d1177 2
a1178 2
	if (msg[length-1] == '\n') {
	    msg[--length] = 0;
d1180 2
a1181 2
	if (msg[length-1] == '\r') {
	    msg[--length] = 0;
d1184 2
a1185 4

    sprintf(id, "%d", error);
    Tcl_SetErrorCode(interp, "WINDOWS", id, msg, (char *) NULL);
    Tcl_AppendToObj(resultPtr, msg, length);
d1188 1
a1188 1
	Tcl_DStringFree(&ds);
a1223 3



@


1.1.1.3
log
@import tcl 8.4.0
@
text
@d14 1
a14 1
 * RCS: @@(#) $Id: tclWinReg.c,v 1.17 2002/01/29 03:18:46 hobbs Exp $
d20 4
d52 1
a52 1
static CONST char *rootKeyNames[] = {
d70 1
a70 1
static CONST char *typeNames[] = {
d87 1
a87 1
    LONG (WINAPI *regConnectRegistryProc)(CONST TCHAR *, HKEY, PHKEY);
d113 1
a113 1
    (LONG (WINAPI *)(CONST TCHAR *, HKEY, PHKEY)) RegConnectRegistryA,
d138 1
a138 1
    (LONG (WINAPI *)(CONST TCHAR *, HKEY, PHKEY)) RegConnectRegistryW,
d186 1
a186 2
static DWORD		RecursiveDeleteKey(HKEY hStartKey,
			    CONST TCHAR * pKeyName);
d261 2
a262 3
    static CONST char *subcommands[] = {
	"delete", "get", "keys", "set", "type", "values", (char *) NULL
    };
a358 1
    CONST char *nativeTail;
d370 1
a370 1
    buffer = ckalloc((unsigned int) length + 1);
d411 2
a412 2
    nativeTail = Tcl_WinUtfToTChar(tail, -1, &buf);
    result = RecursiveDeleteKey(subkey, nativeTail);
a585 1
    CONST char *nativeValue;
d604 2
a605 2
    nativeValue = Tcl_WinUtfToTChar(valueName, length, &ds);
    result = (*regWinProcs->regQueryValueExProc)(key, nativeValue, NULL, &type,
d624 1
a624 1
	Tcl_SetIntObj(resultPtr, (int) type);
a656 1
    CONST char *nativeValue;
d683 1
a683 1
    Tcl_DStringSetLength(&data, (int) length);
d688 1
a688 1
    nativeValue = Tcl_WinUtfToTChar(valueName, nameLen, &buf);
d690 1
a690 1
    result = (*regWinProcs->regQueryValueExProc)(key, nativeValue, NULL, &type,
d699 3
a701 3
        Tcl_DStringSetLength(&data, (int) length);
        result = (*regWinProcs->regQueryValueExProc)(key, (char *) nativeValue,
		NULL, &type, (BYTE *) Tcl_DStringValue(&data), &length);
d722 1
a722 1
	Tcl_SetIntObj(resultPtr, (int) ConvertDWORD(type,
d757 1
a757 1
	Tcl_SetByteArrayObj(resultPtr, Tcl_DStringValue(&data), (int) length);
d825 1
a825 1
	    (int) ((regWinProcs->useWide) ? maxSize*2 : maxSize));
d850 1
a850 1
	Tcl_WinTCharToUtf((TCHAR *) Tcl_DStringValue(&buffer), (int) size, &ds);
d904 1
a904 1
    buffer = ckalloc((unsigned int) length + 1);
d959 1
a959 1
	hostName = (char *) Tcl_WinUtfToTChar(hostName, -1, &buf);
d973 1
a973 1
    keyName = (char *) Tcl_WinUtfToTChar(keyName, -1, &buf);
d1109 1
a1109 1
    CONST char *keyName)	/* Name of key to be deleted in external
d1138 1
a1138 1
	    (int) ((regWinProcs->useWide) ? maxSize * 2 : maxSize));
d1207 1
a1207 1
    valueName = (char *) Tcl_WinUtfToTChar(valueName, length, &nameBuf);
d1263 1
a1263 1
	data = (char *) Tcl_WinUtfToTChar(data, length, &buf);
d1275 1
a1275 1
		(BYTE*)data, (DWORD) length);
d1286 1
a1286 1
		(BYTE *)data, (DWORD) length);
d1349 1
a1349 1
	    sprintf(msgBuf, "unknown error: %ld", error);
d1374 1
a1374 1
    sprintf(id, "%ld", error);
d1415 3
@


1.1.1.4
log
@import tcl 8.4.1
@
text
@d14 1
a14 1
 * RCS: @@(#) $Id: tclWinReg.c,v 1.18 2002/10/18 23:58:18 hobbs Exp $
a161 2
static int		BroadcastValue(Tcl_Interp *interp, int objc,
			    Tcl_Obj * CONST objv[]);
d259 1
a259 5
	"broadcast", "delete", "get", "keys", "set", "type", "values",
	(char *) NULL
    };
    enum SubCmdIdx {
	BroadcastIdx, DeleteIdx, GetIdx, KeysIdx, SetIdx, TypeIdx, ValuesIdx
d261 1
a273 3
	case BroadcastIdx:		/* broadcast */
	    return BroadcastValue(interp, objc, objv);
	    break;
a1295 65
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * BroadcastValue --
 *
 *	This function broadcasts a WM_SETTINGCHANGE message to indicate
 *	to other programs that we have changed the contents of a registry
 *	value.
 *
 * Results:
 *	Returns a normal Tcl result.
 *
 * Side effects:
 *	Will cause other programs to reload their system settings.
 *
 *----------------------------------------------------------------------
 */

static int
BroadcastValue(
    Tcl_Interp *interp,		/* Current interpreter. */
    int objc,			/* Number of arguments. */
    Tcl_Obj * CONST objv[])	/* Argument values. */
{
    DWORD result, sendResult;
    UINT timeout = 3000;
    int len;
    char *str;
    Tcl_Obj *objPtr;

    if ((objc != 3) && (objc != 5)) {
	Tcl_WrongNumArgs(interp, 2, objv, "keyName ?-timeout millisecs?");
	return TCL_ERROR;
    }

    if (objc > 3) {
	str = Tcl_GetStringFromObj(objv[3], &len);
	if ((len < 2) || (*str != '-') || strncmp(str, "-timeout", len)) {
	    Tcl_WrongNumArgs(interp, 2, objv, "keyName ?-timeout millisecs?");
	    return TCL_ERROR;
	}
	if (Tcl_GetIntFromObj(interp, objv[4], (int *) &timeout) != TCL_OK) {
	    return TCL_ERROR;
	}
    }

    str = Tcl_GetStringFromObj(objv[2], &len);
    if (len = 0) {
	str = NULL;
    }

    /*
     * Use the ignore the result.
     */
    result = SendMessageTimeout(HWND_BROADCAST, WM_SETTINGCHANGE,
	    (WPARAM) 0, (LPARAM) str, SMTO_ABORTIFHUNG, timeout, &sendResult);

    objPtr = Tcl_NewObj();
    Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewIntObj(result));
    Tcl_ListObjAppendElement(NULL, objPtr, Tcl_NewIntObj(sendResult));
    Tcl_SetObjResult(interp, objPtr);

@


