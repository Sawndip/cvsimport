head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.58
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.56
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.54
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.52
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.50
	gdb_7_0-branch:1.5.0.48
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tcl8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.46
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.44
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.42
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.40
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.38
	gdb_6_5-2006-05-14-branchpoint:1.5
	readline_5_1-import-branch:1.5.0.36
	readline_5_1-import-branchpoint:1.5
	gdb_6_4-branch:1.5.0.34
	gdb_6_4-2005-11-01-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.32
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	ezannoni_pie-20040323-branch:1.5.0.30
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.28
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.26
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.24
	cagney_x86i386-20030821-branch:1.5.0.22
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.20
	gdb_6_0-2003-06-23-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.18
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.16
	cagney_writestrings-20030508-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.14
	cagney_fileio-20030521-branchpoint:1.5
	carlton_dictionary-20030430-merge:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.12
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.10
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.8
	cagney_lazyid-20030317-branchpoint:1.5
	offbyone-20030313-branch:1.5.0.6
	offbyone-20030313-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.4
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.2
	interps-20030202-branchpoint:1.5
	TCL8_4_1:1.1.1.3
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.2
	TCL_8_4_1:1.1.1.3
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.4
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TCL_8_4_0:1.1.1.3
	carlton_dictionary-branch:1.2.0.16
	carlton_dictionary-20020920-branchpoint:1.2
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.14
	gdb_5_3-branch:1.2.0.12
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.10
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.8
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.6
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TCL_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	dejagnu-2000-02-04:1.1.1.1
	dejagnu-2000-01-31:1.1.1.1
	dejagnu-2000-01-24:1.1.1.1
	dejagnu-2000-01-17:1.1.1.1
	dejagnu-2000-01-10:1.1.1.1
	dejagnu-2000-01-04:1.1.1.1
	dejagnu-1999-12-21:1.1.1.1
	dejagnu-1999-12-13:1.1.1.1
	dejagnu-1999-12-07:1.1.1.1
	dejagnu-1999-12-06:1.1.1.1
	dejagnu-1999-11-15:1.1.1.1
	dejagnu-1999-11-08:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2003.01.21.19.40.08;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.26.19.47.54;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.37.03;	author kseitz;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2001.09.09.23.56.06;	author irox;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	99.11.09.01.28.43;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2002.09.27.21.49.06;	author kseitz;	state Exp;
branches;
next	;

1.3.4.1
date	2003.12.14.20.28.45;	author drow;	state Exp;
branches;
next	;

1.2.16.1
date	2002.12.23.19.40.28;	author carlton;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2003.02.07.19.18.15;	author carlton;	state Exp;
branches;
next	;

1.1.1.1
date	99.11.09.01.28.43;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.09.22.40.57;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.19.56.14;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tcl 8.4.1
@
text
@# safe.tcl --
#
# This file provide a safe loading/sourcing mechanism for safe interpreters.
# It implements a virtual path mecanism to hide the real pathnames from the
# slave. It runs in a master interpreter and sets up data structure and
# aliases that will be invoked when used from a slave interpreter.
# 
# See the safe.n man page for details.
#
# Copyright (c) 1996-1997 Sun Microsystems, Inc.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# RCS: @@(#) $Id: safe.tcl,v 1.8 2002/02/22 19:51:29 hobbs Exp $

#
# The implementation is based on namespaces. These naming conventions
# are followed:
# Private procs starts with uppercase.
# Public  procs are exported and starts with lowercase
#

# Needed utilities package
package require opt 0.4.1;

# Create the safe namespace
namespace eval ::safe {

    # Exported API:
    namespace export interpCreate interpInit interpConfigure interpDelete \
	    interpAddToAccessPath interpFindInAccessPath setLogCmd

    ####
    #
    # Setup the arguments parsing
    #
    ####

    # Share the descriptions
    set temp [::tcl::OptKeyRegister {
	{-accessPath -list {} "access path for the slave"}
	{-noStatics "prevent loading of statically linked pkgs"}
	{-statics true "loading of statically linked pkgs"}
	{-nestedLoadOk "allow nested loading"}
	{-nested false "nested loading"}
	{-deleteHook -script {} "delete hook"}
    }]

    # create case (slave is optional)
    ::tcl::OptKeyRegister {
	{?slave? -name {} "name of the slave (optional)"}
    } ::safe::interpCreate
    # adding the flags sub programs to the command program
    # (relying on Opt's internal implementation details)
    lappend ::tcl::OptDesc(::safe::interpCreate) $::tcl::OptDesc($temp)

    # init and configure (slave is needed)
    ::tcl::OptKeyRegister {
	{slave -name {} "name of the slave"}
    } ::safe::interpIC
    # adding the flags sub programs to the command program
    # (relying on Opt's internal implementation details)
    lappend ::tcl::OptDesc(::safe::interpIC) $::tcl::OptDesc($temp)
    # temp not needed anymore
    ::tcl::OptKeyDelete $temp


    # Helper function to resolve the dual way of specifying staticsok
    # (either by -noStatics or -statics 0)
    proc InterpStatics {} {
	foreach v {Args statics noStatics} {
	    upvar $v $v
	}
	set flag [::tcl::OptProcArgGiven -noStatics];
	if {$flag && ($noStatics == $statics) 
	          && ([::tcl::OptProcArgGiven -statics])} {
	    return -code error\
		    "conflicting values given for -statics and -noStatics"
	}
	if {$flag} {
	    return [expr {!$noStatics}]
	} else {
	    return $statics
	}
    }

    # Helper function to resolve the dual way of specifying nested loading
    # (either by -nestedLoadOk or -nested 1)
    proc InterpNested {} {
	foreach v {Args nested nestedLoadOk} {
	    upvar $v $v
	}
	set flag [::tcl::OptProcArgGiven -nestedLoadOk];
	# note that the test here is the opposite of the "InterpStatics"
	# one (it is not -noNested... because of the wanted default value)
	if {$flag && ($nestedLoadOk != $nested) 
	          && ([::tcl::OptProcArgGiven -nested])} {
	    return -code error\
		    "conflicting values given for -nested and -nestedLoadOk"
	}
	if {$flag} {
	    # another difference with "InterpStatics"
	    return $nestedLoadOk
	} else {
	    return $nested
	}
    }

    ####
    #
    #  API entry points that needs argument parsing :
    #
    ####


    # Interface/entry point function and front end for "Create"
    proc interpCreate {args} {
	set Args [::tcl::OptKeyParse ::safe::interpCreate $args]
	InterpCreate $slave $accessPath \
		[InterpStatics] [InterpNested] $deleteHook
    }

    proc interpInit {args} {
	set Args [::tcl::OptKeyParse ::safe::interpIC $args]
	if {![::interp exists $slave]} {
	    return -code error "\"$slave\" is not an interpreter"
	}
	InterpInit $slave $accessPath \
		[InterpStatics] [InterpNested] $deleteHook;
    }

    proc CheckInterp {slave} {
	if {![IsInterp $slave]} {
	    return -code error \
		    "\"$slave\" is not an interpreter managed by ::safe::"
	}
    }

    # Interface/entry point function and front end for "Configure"
    # This code is awfully pedestrian because it would need
    # more coupling and support between the way we store the
    # configuration values in safe::interp's and the Opt package
    # Obviously we would like an OptConfigure
    # to avoid duplicating all this code everywhere. -> TODO
    # (the app should share or access easily the program/value
    #  stored by opt)
    # This is even more complicated by the boolean flags with no values
    # that we had the bad idea to support for the sake of user simplicity
    # in create/init but which makes life hard in configure...
    # So this will be hopefully written and some integrated with opt1.0
    # (hopefully for tcl8.1 ?)
    proc interpConfigure {args} {
	switch [llength $args] {
	    1 {
		# If we have exactly 1 argument
		# the semantic is to return all the current configuration
		# We still call OptKeyParse though we know that "slave"
		# is our given argument because it also checks
		# for the "-help" option.
		set Args [::tcl::OptKeyParse ::safe::interpIC $args]
		CheckInterp $slave
		set res {}
		lappend res [list -accessPath [Set [PathListName $slave]]]
		lappend res [list -statics    [Set [StaticsOkName $slave]]]
		lappend res [list -nested     [Set [NestedOkName $slave]]]
		lappend res [list -deleteHook [Set [DeleteHookName $slave]]]
		join $res
	    }
	    2 {
		# If we have exactly 2 arguments
		# the semantic is a "configure get"
		::tcl::Lassign $args slave arg
		# get the flag sub program (we 'know' about Opt's internal
		# representation of data)
		set desc [lindex [::tcl::OptKeyGetDesc ::safe::interpIC] 2]
		set hits [::tcl::OptHits desc $arg]
                if {$hits > 1} {
                    return -code error [::tcl::OptAmbigous $desc $arg]
                } elseif {$hits == 0} {
                    return -code error [::tcl::OptFlagUsage $desc $arg]
                }
		CheckInterp $slave
		set item [::tcl::OptCurDesc $desc]
		set name [::tcl::OptName $item]
		switch -exact -- $name {
		    -accessPath {
			return [list -accessPath [Set [PathListName $slave]]]
		    }
		    -statics {
			return [list -statics    [Set [StaticsOkName $slave]]]
		    }
		    -nested {
			return [list -nested     [Set [NestedOkName $slave]]]
		    }
		    -deleteHook {
			return [list -deleteHook [Set [DeleteHookName $slave]]]
		    }
		    -noStatics {
			# it is most probably a set in fact
			# but we would need then to jump to the set part
			# and it is not *sure* that it is a set action
			# that the user want, so force it to use the
			# unambigous -statics ?value? instead:
			return -code error\
				"ambigous query (get or set -noStatics ?)\
				use -statics instead"
		    }
		    -nestedLoadOk {
			return -code error\
				"ambigous query (get or set -nestedLoadOk ?)\
				use -nested instead"
		    }
		    default {
			return -code error "unknown flag $name (bug)"
		    }
		}
	    }
	    default {
		# Otherwise we want to parse the arguments like init and create
		# did
		set Args [::tcl::OptKeyParse ::safe::interpIC $args]
		CheckInterp $slave
		# Get the current (and not the default) values of
		# whatever has not been given:
		if {![::tcl::OptProcArgGiven -accessPath]} {
		    set doreset 1
		    set accessPath [Set [PathListName $slave]]
		} else {
		    set doreset 0
		}
		if {(![::tcl::OptProcArgGiven -statics]) \
			&& (![::tcl::OptProcArgGiven -noStatics]) } {
		    set statics    [Set [StaticsOkName $slave]]
		} else {
		    set statics    [InterpStatics]
		}
		if {([::tcl::OptProcArgGiven -nested]) \
			|| ([::tcl::OptProcArgGiven -nestedLoadOk]) } {
		    set nested     [InterpNested]
		} else {
		    set nested     [Set [NestedOkName $slave]]
		}
		if {![::tcl::OptProcArgGiven -deleteHook]} {
		    set deleteHook [Set [DeleteHookName $slave]]
		}
		# we can now reconfigure :
		InterpSetConfig $slave $accessPath $statics $nested $deleteHook
		# auto_reset the slave (to completly synch the new access_path)
		if {$doreset} {
		    if {[catch {::interp eval $slave {auto_reset}} msg]} {
			Log $slave "auto_reset failed: $msg"
		    } else {
			Log $slave "successful auto_reset" NOTICE
		    }
		}
	    }
	}
    }


    ####
    #
    #  Functions that actually implements the exported APIs
    #
    ####


    #
    # safe::InterpCreate : doing the real job
    #
    # This procedure creates a safe slave and initializes it with the
    # safe base aliases.
    # NB: slave name must be simple alphanumeric string, no spaces,
    # no (), no {},...  {because the state array is stored as part of the name}
    #
    # Returns the slave name.
    #
    # Optional Arguments : 
    # + slave name : if empty, generated name will be used
    # + access_path: path list controlling where load/source can occur,
    #                if empty: the master auto_path will be used.
    # + staticsok  : flag, if 0 :no static package can be loaded (load {} Xxx)
    #                      if 1 :static packages are ok.
    # + nestedok: flag, if 0 :no loading to sub-sub interps (load xx xx sub)
    #                      if 1 : multiple levels are ok.
    
    # use the full name and no indent so auto_mkIndex can find us
    proc ::safe::InterpCreate {
	slave 
	access_path
	staticsok
	nestedok
	deletehook
    } {
	# Create the slave.
	if {[string compare "" $slave]} {
	    ::interp create -safe $slave
	} else {
	    # empty argument: generate slave name
	    set slave [::interp create -safe]
	}
	Log $slave "Created" NOTICE

	# Initialize it. (returns slave name)
	InterpInit $slave $access_path $staticsok $nestedok $deletehook
    }


    #
    # InterpSetConfig (was setAccessPath) :
    #    Sets up slave virtual auto_path and corresponding structure
    #    within the master. Also sets the tcl_library in the slave
    #    to be the first directory in the path.
    #    Nb: If you change the path after the slave has been initialized
    #    you probably need to call "auto_reset" in the slave in order that it
    #    gets the right auto_index() array values.

    proc ::safe::InterpSetConfig {slave access_path staticsok\
	    nestedok deletehook} {

	# determine and store the access path if empty
	if {[string equal "" $access_path]} {
	    set access_path [uplevel #0 set auto_path]
	    # Make sure that tcl_library is in auto_path
	    # and at the first position (needed by setAccessPath)
	    set where [lsearch -exact $access_path [info library]]
	    if {$where == -1} {
		# not found, add it.
		set access_path [concat [list [info library]] $access_path]
		Log $slave "tcl_library was not in auto_path,\
			added it to slave's access_path" NOTICE
	    } elseif {$where != 0} {
		# not first, move it first
		set access_path [concat [list [info library]]\
			[lreplace $access_path $where $where]]
		Log $slave "tcl_libray was not in first in auto_path,\
			moved it to front of slave's access_path" NOTICE
	    
	    }

	    # Add 1st level sub dirs (will searched by auto loading from tcl
	    # code in the slave using glob and thus fail, so we add them
	    # here so by default it works the same).
	    set access_path [AddSubDirs $access_path]
	}

	Log $slave "Setting accessPath=($access_path) staticsok=$staticsok\
		nestedok=$nestedok deletehook=($deletehook)" NOTICE

	# clear old autopath if it existed
	set nname [PathNumberName $slave]
	if {[Exists $nname]} {
	    set n [Set $nname]
	    for {set i 0} {$i<$n} {incr i} {
		Unset [PathToken $i $slave]
	    }
	}

	# build new one
	set slave_auto_path {}
	set i 0
	foreach dir $access_path {
	    Set [PathToken $i $slave] $dir
	    lappend slave_auto_path "\$[PathToken $i]"
	    incr i
	}
	Set $nname $i
	Set [PathListName $slave] $access_path
	Set [VirtualPathListName $slave] $slave_auto_path

	Set [StaticsOkName $slave] $staticsok
	Set [NestedOkName $slave] $nestedok
	Set [DeleteHookName $slave] $deletehook

	SyncAccessPath $slave
    }

    #
    #
    # FindInAccessPath:
    #    Search for a real directory and returns its virtual Id
    #    (including the "$")
proc ::safe::interpFindInAccessPath {slave path} {
	set access_path [GetAccessPath $slave]
	set where [lsearch -exact $access_path $path]
	if {$where == -1} {
	    return -code error "$path not found in access path $access_path"
	}
	return "\$[PathToken $where]"
    }

    #
    # addToAccessPath:
    #    add (if needed) a real directory to access path
    #    and return its virtual token (including the "$").
proc ::safe::interpAddToAccessPath {slave path} {
	# first check if the directory is already in there
	if {![catch {interpFindInAccessPath $slave $path} res]} {
	    return $res
	}
	# new one, add it:
	set nname [PathNumberName $slave]
	set n [Set $nname]
	Set [PathToken $n $slave] $path

	set token "\$[PathToken $n]"

	Lappend [VirtualPathListName $slave] $token
	Lappend [PathListName $slave] $path
	Set $nname [expr {$n+1}]

	SyncAccessPath $slave

	return $token
    }

    # This procedure applies the initializations to an already existing
    # interpreter. It is useful when you want to install the safe base
    # aliases into a preexisting safe interpreter.
    proc ::safe::InterpInit {
	slave 
	access_path
	staticsok
	nestedok
	deletehook
    } {

	# Configure will generate an access_path when access_path is
	# empty.
	InterpSetConfig $slave $access_path $staticsok $nestedok $deletehook

	# These aliases let the slave load files to define new commands

	# NB we need to add [namespace current], aliases are always
	# absolute paths.
	::interp alias $slave source {} [namespace current]::AliasSource $slave
	::interp alias $slave load {} [namespace current]::AliasLoad $slave

	# This alias lets the slave use the encoding names, convertfrom,
	# convertto, and system, but not "encoding system <name>" to set
	# the system encoding.

	::interp alias $slave encoding {} [namespace current]::AliasEncoding \
		$slave

	# This alias lets the slave have access to a subset of the 'file'
	# command functionality.

	AliasSubset $slave file file dir.* join root.* ext.* tail \
		path.* split

	# This alias interposes on the 'exit' command and cleanly terminates
	# the slave.

	::interp alias $slave exit {} [namespace current]::interpDelete $slave

	# The allowed slave variables already have been set
	# by Tcl_MakeSafe(3)


	# Source init.tcl into the slave, to get auto_load and other
	# procedures defined:

	# We don't try to use the -rsrc on the mac because it would get
	# confusing if you would want to customize init.tcl
	# for a given set of safe slaves, on all the platforms
	# you just need to give a specific access_path and
	# the mac should be no exception. As there is no
	# obvious full "safe ressources" design nor implementation
	# for the mac, safe interps there will just don't
	# have that ability. (A specific app can still reenable
	# that using custom aliases if they want to).
	# It would also make the security analysis and the Safe Tcl security
	# model platform dependant and thus more error prone.

	if {[catch {::interp eval $slave\
		{source [file join $tcl_library init.tcl]}} msg]} {
	    Log $slave "can't source init.tcl ($msg)"
	    error "can't source init.tcl into slave $slave ($msg)"
	}

	return $slave
    }


    # Add (only if needed, avoid duplicates) 1 level of
    # sub directories to an existing path list.
    # Also removes non directories from the returned list.
    proc AddSubDirs {pathList} {
	set res {}
	foreach dir $pathList {
	    if {[file isdirectory $dir]} {
		# check that we don't have it yet as a children
		# of a previous dir
		if {[lsearch -exact $res $dir]<0} {
		    lappend res $dir
		}
		foreach sub [glob -directory $dir -nocomplain *] {
		    if {([file isdirectory $sub]) \
			    && ([lsearch -exact $res $sub]<0) } {
			# new sub dir, add it !
	                lappend res $sub
	            }
		}
	    }
	}
	return $res
    }

    # This procedure deletes a safe slave managed by Safe Tcl and
    # cleans up associated state:

proc ::safe::interpDelete {slave} {

        Log $slave "About to delete" NOTICE

	# If the slave has a cleanup hook registered, call it.
	# check the existance because we might be called to delete an interp
	# which has not been registered with us at all
	set hookname [DeleteHookName $slave]
	if {[Exists $hookname]} {
	    set hook [Set $hookname]
	    if {![::tcl::Lempty $hook]} {
		# remove the hook now, otherwise if the hook
		# calls us somehow, we'll loop
		Unset $hookname
		if {[catch {eval $hook [list $slave]} err]} {
		    Log $slave "Delete hook error ($err)"
		}
	    }
	}

	# Discard the global array of state associated with the slave, and
	# delete the interpreter.

	set statename [InterpStateName $slave]
	if {[Exists $statename]} {
	    Unset $statename
	}

	# if we have been called twice, the interp might have been deleted
	# already
	if {[::interp exists $slave]} {
	    ::interp delete $slave
	    Log $slave "Deleted" NOTICE
	}

	return
    }

    # Set (or get) the loging mecanism 

proc ::safe::setLogCmd {args} {
    variable Log
    if {[llength $args] == 0} {
	return $Log
    } else {
	if {[llength $args] == 1} {
	    set Log [lindex $args 0]
	} else {
	    set Log $args
	}
    }
}

    # internal variable
    variable Log {}

    # ------------------- END OF PUBLIC METHODS ------------


    #
    # sets the slave auto_path to the master recorded value.
    # also sets tcl_library to the first token of the virtual path.
    #
    proc SyncAccessPath {slave} {
	set slave_auto_path [Set [VirtualPathListName $slave]]
	::interp eval $slave [list set auto_path $slave_auto_path]
	Log $slave "auto_path in $slave has been set to $slave_auto_path"\
		NOTICE
	::interp eval $slave [list set tcl_library [lindex $slave_auto_path 0]]
    }

    # base name for storing all the slave states
    # the array variable name for slave foo is thus "Sfoo"
    # and for sub slave {foo bar} "Sfoo bar" (spaces are handled
    # ok everywhere (or should))
    # We add the S prefix to avoid that a slave interp called "Log"
    # would smash our "Log" variable.
    proc InterpStateName {slave} {
	return "S$slave"
    }

    # Check that the given slave is "one of us"
    proc IsInterp {slave} {
	expr {[Exists [InterpStateName $slave]] && [::interp exists $slave]}
    }

    # returns the virtual token for directory number N
    # if the slave argument is given, 
    # it will return the corresponding master global variable name
    proc PathToken {n {slave ""}} {
	if {[string compare "" $slave]} {
	    return "[InterpStateName $slave](access_path,$n)"
	} else {
	    # We need to have a ":" in the token string so
	    # [file join] on the mac won't turn it into a relative
	    # path.
	    return "p(:$n:)"
	}
    }
    # returns the variable name of the complete path list
    proc PathListName {slave} {
	return "[InterpStateName $slave](access_path)"
    }
    # returns the variable name of the complete path list
    proc VirtualPathListName {slave} {
	return "[InterpStateName $slave](access_path_slave)"
    }
    # returns the variable name of the number of items
    proc PathNumberName {slave} {
	return "[InterpStateName $slave](access_path,n)"
    }
    # returns the staticsok flag var name
    proc StaticsOkName {slave} {
	return "[InterpStateName $slave](staticsok)"
    }
    # returns the nestedok flag var name
    proc NestedOkName {slave} {
	return "[InterpStateName $slave](nestedok)"
    }
    # Run some code at the namespace toplevel
    proc Toplevel {args} {
	namespace eval [namespace current] $args
    }
    # set/get values
    proc Set {args} {
	eval Toplevel set $args
    }
    # lappend on toplevel vars
    proc Lappend {args} {
	eval Toplevel lappend $args
    }
    # unset a var/token (currently just an global level eval)
    proc Unset {args} {
	eval Toplevel unset $args
    }
    # test existance 
    proc Exists {varname} {
	Toplevel info exists $varname
    }
    # short cut for access path getting
    proc GetAccessPath {slave} {
	Set [PathListName $slave]
    }
    # short cut for statics ok flag getting
    proc StaticsOk {slave} {
	Set [StaticsOkName $slave]
    }
    # short cut for getting the multiples interps sub loading ok flag
    proc NestedOk {slave} {
	Set [NestedOkName $slave]
    }
    # interp deletion storing hook name
    proc DeleteHookName {slave} {
	return [InterpStateName $slave](cleanupHook)
    }

    #
    # translate virtual path into real path
    #
    proc TranslatePath {slave path} {
	# somehow strip the namespaces 'functionality' out (the danger
	# is that we would strip valid macintosh "../" queries... :
	if {[regexp {(::)|(\.\.)} $path]} {
	    error "invalid characters in path $path"
	}
	set n [expr {[Set [PathNumberName $slave]]-1}]
	for {} {$n>=0} {incr n -1} {
	    # fill the token virtual names with their real value
	    set [PathToken $n] [Set [PathToken $n $slave]]
	}
	# replaces the token by their value
	subst -nobackslashes -nocommands $path
    }


    # Log eventually log an error
    # to enable error logging, set Log to {puts stderr} for instance
    proc Log {slave msg {type ERROR}} {
	variable Log
	if {[info exists Log] && [llength $Log]} {
	    eval $Log [list "$type for slave $slave : $msg"]
	}
    }


    # file name control (limit access to files/ressources that should be
    # a valid tcl source file)
    proc CheckFileName {slave file} {
	# This used to limit what can be sourced to ".tcl" and forbid files
	# with more than 1 dot and longer than 14 chars, but I changed that
	# for 8.4 as a safe interp has enough internal protection already
	# to allow sourcing anything. - hobbs

	if {![file exists $file]} {
	    # don't tell the file path
	    error "no such file or directory"
	}

	if {![file readable $file]} {
	    # don't tell the file path
	    error "not readable"
	}
    }


    # AliasSource is the target of the "source" alias in safe interpreters.

    proc AliasSource {slave args} {

	set argc [llength $args]
	# Allow only "source filename"
	# (and not mac specific -rsrc for instance - see comment in ::init
	# for current rationale)
	if {$argc != 1} {
	    set msg "wrong # args: should be \"source fileName\""
	    Log $slave "$msg ($args)"
	    return -code error $msg
	}
	set file [lindex $args 0]
	
	# get the real path from the virtual one.
	if {[catch {set file [TranslatePath $slave $file]} msg]} {
	    Log $slave $msg
	    return -code error "permission denied"
	}
	
	# check that the path is in the access path of that slave
	if {[catch {FileInAccessPath $slave $file} msg]} {
	    Log $slave $msg
	    return -code error "permission denied"
	}

	# do the checks on the filename :
	if {[catch {CheckFileName $slave $file} msg]} {
	    Log $slave "$file:$msg"
	    return -code error $msg
	}

	# passed all the tests , lets source it:
	if {[catch {::interp invokehidden $slave source $file} msg]} {
	    Log $slave $msg
	    return -code error "script error"
	}
	return $msg
    }

    # AliasLoad is the target of the "load" alias in safe interpreters.

    proc AliasLoad {slave file args} {

	set argc [llength $args]
	if {$argc > 2} {
	    set msg "load error: too many arguments"
	    Log $slave "$msg ($argc) {$file $args}"
	    return -code error $msg
	}

	# package name (can be empty if file is not).
	set package [lindex $args 0]

	# Determine where to load. load use a relative interp path
	# and {} means self, so we can directly and safely use passed arg.
	set target [lindex $args 1]
	if {[string length $target]} {
	    # we will try to load into a sub sub interp
	    # check that we want to authorize that.
	    if {![NestedOk $slave]} {
		Log $slave "loading to a sub interp (nestedok)\
			disabled (trying to load $package to $target)"
		return -code error "permission denied (nested load)"
	    }
	    
	}

	# Determine what kind of load is requested
	if {[string length $file] == 0} {
	    # static package loading
	    if {[string length $package] == 0} {
		set msg "load error: empty filename and no package name"
		Log $slave $msg
		return -code error $msg
	    }
	    if {![StaticsOk $slave]} {
		Log $slave "static packages loading disabled\
			(trying to load $package to $target)"
		return -code error "permission denied (static package)"
	    }
	} else {
	    # file loading

	    # get the real path from the virtual one.
	    if {[catch {set file [TranslatePath $slave $file]} msg]} {
		Log $slave $msg
		return -code error "permission denied"
	    }

	    # check the translated path
	    if {[catch {FileInAccessPath $slave $file} msg]} {
		Log $slave $msg
		return -code error "permission denied (path)"
	    }
	}

	if {[catch {::interp invokehidden\
		$slave load $file $package $target} msg]} {
	    Log $slave $msg
	    return -code error $msg
	}

	return $msg
    }

    # FileInAccessPath raises an error if the file is not found in
    # the list of directories contained in the (master side recorded) slave's
    # access path.

    # the security here relies on "file dirname" answering the proper
    # result.... needs checking ?
    proc FileInAccessPath {slave file} {

	set access_path [GetAccessPath $slave]

	if {[file isdirectory $file]} {
	    error "\"$file\": is a directory"
	}
	set parent [file dirname $file]
	if {[lsearch -exact $access_path $parent] == -1} {
	    error "\"$file\": not in access_path"
	}
    }

    # This procedure enables access from a safe interpreter to only a subset of
    # the subcommands of a command:

    proc Subset {slave command okpat args} {
	set subcommand [lindex $args 0]
	if {[regexp $okpat $subcommand]} {
	    return [eval {$command $subcommand} [lrange $args 1 end]]
	}
	set msg "not allowed to invoke subcommand $subcommand of $command"
	Log $slave $msg
	error $msg
    }

    # This procedure installs an alias in a slave that invokes "safesubset"
    # in the master to execute allowed subcommands. It precomputes the pattern
    # of allowed subcommands; you can use wildcards in the pattern if you wish
    # to allow subcommand abbreviation.
    #
    # Syntax is: AliasSubset slave alias target subcommand1 subcommand2...

    proc AliasSubset {slave alias target args} {
	set pat ^(; set sep ""
	foreach sub $args {
	    append pat $sep$sub
	    set sep |
	}
	append pat )\$
	::interp alias $slave $alias {}\
		[namespace current]::Subset $slave $target $pat
    }

    # AliasEncoding is the target of the "encoding" alias in safe interpreters.

    proc AliasEncoding {slave args} {

	set argc [llength $args]

	set okpat "^(name.*|convert.*)\$"
	set subcommand [lindex $args 0]

	if {[regexp $okpat $subcommand]} {
	    return [eval ::interp invokehidden $slave encoding $subcommand \
		    [lrange $args 1 end]]
	}

	if {[string match $subcommand system]} {
	    if {$argc == 1} {
		# passed all the tests , lets source it:
		if {[catch {::interp invokehidden \
			$slave encoding system} msg]} {
		    Log $slave $msg
		    return -code error "script error"
		}
	    } else {
		set msg "wrong # args: should be \"encoding system\""
		Log $slave $msg
		error $msg
	    }
	} else {
	    set msg "wrong # args: should be \"encoding option ?arg ...?\""
	    Log $slave $msg
	    error $msg
	}

	return $msg
    }

}
@


1.4
log
@touched all sources to ease next import
@
text
@d15 1
a15 1
# RCS: @@(#) $Id: safe.tcl,v 1.6.8.1 2000/04/06 22:38:30 spolk Exp $
d499 1
a499 1
		foreach sub [glob -nocomplain -- [file join $dir *]] {
d698 1
a698 1
    
d702 4
a705 14
	# limit what can be sourced to .tcl
	# and forbid files with more than 1 dot and
	# longer than 14 chars
	set ftail [file tail $file]
	if {[string length $ftail]>14} {
	    error "$ftail: filename too long"
	}
	if {[regexp {\..*\.} $ftail]} {
	    error "$ftail: more than one dot is forbidden"
	}
	if {[string compare $ftail "tclIndex"] && \
		[string compare -nocase [file extension $ftail]	".tcl"]} {
	    error "$ftail: must be a *.tcl or tclIndex"
	}
@


1.3
log
@touched all sources to ease next import
@
text
@@


1.3.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d15 1
a15 1
# RCS: @@(#) $Id: safe.tcl,v 1.8 2002/02/22 19:51:29 hobbs Exp $
d499 1
a499 1
		foreach sub [glob -directory $dir -nocomplain *] {
d698 1
a698 1

d702 14
a715 4
	# This used to limit what can be sourced to ".tcl" and forbid files
	# with more than 1 dot and longer than 14 chars, but I changed that
	# for 8.4 as a safe interp has enough internal protection already
	# to allow sourcing anything. - hobbs
@


1.3.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@d15 1
a15 1
# RCS: @@(#) $Id: safe.tcl,v 1.8 2002/02/22 19:51:29 hobbs Exp $
d499 1
a499 1
		foreach sub [glob -directory $dir -nocomplain *] {
d698 1
a698 1

d702 14
a715 4
	# This used to limit what can be sourced to ".tcl" and forbid files
	# with more than 1 dot and longer than 14 chars, but I changed that
	# for 8.4 as a safe interp has enough internal protection already
	# to allow sourcing anything. - hobbs
@


1.2
log
@touched all Tcl files to ease next import.
@
text
@@


1.2.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.2.16.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d499 1
a499 1
		foreach sub [glob -directory $dir -nocomplain *] {
d698 1
a698 1

d702 14
a715 4
	# This used to limit what can be sourced to ".tcl" and forbid files
	# with more than 1 dot and longer than 14 chars, but I changed that
	# for 8.4 as a safe interp has enough internal protection already
	# to allow sourcing anything. - hobbs
@


1.1
log
@Initial revision
@
text
@d15 1
a15 1
# RCS: @@(#) $Id: safe.tcl,v 1.4 1998/11/11 02:39:31 welch Exp $
d25 1
a25 1
package require opt 0.2;
d32 1
a32 2
	    interpAddToAccessPath interpFindInAccessPath \
	    setLogCmd ;
d53 1
a53 1
    } ::safe::interpCreate ;
d56 1
a56 1
    lappend ::tcl::OptDesc(::safe::interpCreate) $::tcl::OptDesc($temp);
d61 1
a61 1
    } ::safe::interpIC;
d64 1
a64 1
    lappend ::tcl::OptDesc(::safe::interpIC) $::tcl::OptDesc($temp);
d66 1
a66 1
    ::tcl::OptKeyDelete $temp;
d79 1
a79 1
		    "conflicting values given for -statics and -noStatics";
d82 1
a82 1
	    return [expr {!$noStatics}];
d100 1
a100 1
		    "conflicting values given for -nested and -nestedLoadOk";
d121 1
a121 1
		[InterpStatics] [InterpNested] $deleteHook;
d127 1
a127 2
	    return -code error \
		    "\"$slave\" is not an interpreter";
d136 1
a136 1
		    "\"$slave\" is not an interpreter managed by ::safe::" ;
d161 2
a162 2
		set Args [::tcl::OptKeyParse ::safe::interpIC $args];
		CheckInterp $slave;
d173 1
a173 1
		::tcl::Lassign $args slave arg;
d177 1
a177 1
		set hits [::tcl::OptHits desc $arg];
d183 3
a185 3
		CheckInterp $slave;
		set item [::tcl::OptCurDesc $desc];
		set name [::tcl::OptName $item];
d207 1
a207 1
				use -statics instead";
d212 1
a212 1
				use -nested instead";
d215 1
a215 1
			return -code error "unknown flag $name (bug)";
d222 2
a223 2
		set Args [::tcl::OptKeyParse ::safe::interpIC $args];
		CheckInterp $slave;
d232 2
a233 2
		if {    (![::tcl::OptProcArgGiven -statics]) 
                     && (![::tcl::OptProcArgGiven -noStatics]) } {
d238 2
a239 2
		if {    ([::tcl::OptProcArgGiven -nested]) 
                     || ([::tcl::OptProcArgGiven -nestedLoadOk]) } {
d248 1
a248 2
		InterpSetConfig $slave $accessPath \
			$statics $nested $deleteHook;
d252 1
a252 1
			Log $slave "auto_reset failed: $msg";
d254 1
a254 1
			Log $slave "successful auto_reset" NOTICE;
d298 1
a298 1
	    ::interp create -safe $slave;
d301 1
a301 1
	    set slave [::interp create -safe];
d303 1
a303 1
	Log $slave "Created" NOTICE;
d306 1
a306 1
	InterpInit $slave $access_path $staticsok $nestedok $deletehook;
d323 2
a324 2
	if {[string match "" $access_path]} {
	    set access_path [uplevel #0 set auto_path];
d327 1
a327 1
	    set where [lsearch -exact $access_path [info library]];
d330 1
a330 1
		set access_path [concat [list [info library]] $access_path];
d332 1
a332 1
			added it to slave's access_path" NOTICE;
d336 1
a336 1
			[lreplace $access_path $where $where]];
d338 1
a338 1
			moved it to front of slave's access_path" NOTICE;
d345 1
a345 1
	    set access_path [AddSubDirs $access_path];
d349 1
a349 1
		nestedok=$nestedok deletehook=($deletehook)" NOTICE;
d352 1
a352 1
	set nname [PathNumberName $slave];
d354 1
a354 1
	    set n [Set $nname];
d356 1
a356 1
		Unset [PathToken $i $slave];
d362 1
a362 1
	set i 0;
d364 7
a370 7
	    Set [PathToken $i $slave] $dir;
	    lappend slave_auto_path "\$[PathToken $i]";
	    incr i;
	}
	Set $nname $i;
	Set [PathListName $slave] $access_path;
	Set [VirtualPathListName $slave] $slave_auto_path;
d376 1
a376 1
	SyncAccessPath $slave;
d385 2
a386 2
	set access_path [GetAccessPath $slave];
	set where [lsearch -exact $access_path $path];
d388 1
a388 1
	    return -code error "$path not found in access path $access_path";
d390 1
a390 1
	return "\$[PathToken $where]";
d400 1
a400 1
	    return $res;
d403 3
a405 3
	set nname [PathNumberName $slave];
	set n [Set $nname];
	Set [PathToken $n $slave] $path;
d407 1
a407 1
	set token "\$[PathToken $n]";
d409 3
a411 3
	Lappend [VirtualPathListName $slave] $token;
	Lappend [PathListName $slave] $path;
	Set $nname [expr {$n+1}];
d413 1
a413 1
	SyncAccessPath $slave;
d415 1
a415 1
	return $token;
d431 1
a431 1
	InterpSetConfig $slave $access_path $staticsok $nestedok $deletehook;
d440 7
d478 2
a479 3
		{source [file join $tcl_library init.tcl]}}\
		msg]} {
	    Log $slave "can't source init.tcl ($msg)";
d497 1
a497 1
		    lappend res $dir;
d500 2
a501 2
		    if {    ([file isdirectory $sub])
		         && ([lsearch -exact $res $sub]<0) } {
d503 1
a503 1
	                lappend res $sub;
d508 1
a508 1
	return $res;
d516 1
a516 1
        Log $slave "About to delete" NOTICE;
d521 1
a521 1
	set hookname [DeleteHookName $slave];
d523 1
a523 1
	    set hook [Set $hookname];
d527 1
a527 1
		Unset $hookname;
d529 1
a529 1
		    Log $slave "Delete hook error ($err)";
d537 1
a537 1
	set statename [InterpStateName $slave];
d539 1
a539 1
	    Unset $statename;
d545 2
a546 2
	    ::interp delete $slave;
	    Log $slave "Deleted" NOTICE;
d555 1
a555 1
    variable Log;
d557 1
a557 1
	return $Log;
d560 1
a560 1
	    set Log [lindex $args 0];
d578 5
a582 6
	set slave_auto_path [Set [VirtualPathListName $slave]];
	::interp eval $slave [list set auto_path $slave_auto_path];
	Log $slave \
		"auto_path in $slave has been set to $slave_auto_path"\
		NOTICE;
	::interp eval $slave [list set tcl_library [lindex $slave_auto_path 0]];
d592 1
a592 1
	return "S$slave";
d597 1
a597 2
	expr {    ([Exists [InterpStateName $slave]]) 
	       && ([::interp exists $slave])}
d605 1
a605 1
	    return "[InterpStateName $slave](access_path,$n)";
d610 1
a610 1
	    return "p(:$n:)";
d615 1
a615 1
	return "[InterpStateName $slave](access_path)";
d619 1
a619 1
	return "[InterpStateName $slave](access_path_slave)";
d623 1
a623 1
	return "[InterpStateName $slave](access_path,n)";
d627 1
a627 1
	return "[InterpStateName $slave](staticsok)";
d631 1
a631 1
	return "[InterpStateName $slave](nestedok)";
d635 1
a635 1
	namespace eval [namespace current] $args;
d639 1
a639 1
	eval Toplevel set $args;
d643 1
a643 1
	eval Toplevel lappend $args;
d647 1
a647 1
	eval Toplevel unset $args;
d651 1
a651 1
	Toplevel info exists $varname;
d677 1
a677 1
	    error "invalid characters in path $path";
d679 1
a679 1
	set n [expr {[Set [PathNumberName $slave]]-1}];
d682 1
a682 1
	    set [PathToken $n] [Set [PathToken $n $slave]];
d685 1
a685 1
	subst -nobackslashes -nocommands $path;
d692 1
a692 1
	variable Log;
d694 1
a694 1
	    eval $Log [list "$type for slave $slave : $msg"];
d705 1
a705 1
	set ftail [file tail $file];
d707 1
a707 1
	    error "$ftail: filename too long";
d710 1
a710 1
	    error "$ftail: more than one dot is forbidden";
d713 2
a714 3
		[string compare [string tolower [file extension $ftail]]\
		".tcl"]} {
	    error "$ftail: must be a *.tcl or tclIndex";
d719 1
a719 1
	    error "no such file or directory";
d724 1
a724 1
	    error "not readable";
a725 1

d733 1
a733 1
	set argc [llength $args];
d739 2
a740 2
	    Log $slave "$msg ($args)";
	    return -code error $msg;
d746 1
a746 1
	    Log $slave $msg;
d752 1
a752 1
	    Log $slave $msg;
d758 2
a759 2
	    Log $slave "$file:$msg";
	    return -code error $msg;
d764 2
a765 2
	    Log $slave $msg;
	    return -code error "script error";
d774 1
a774 1
	set argc [llength $args];
d776 3
a778 3
	    set msg "load error: too many arguments";
	    Log $slave "$msg ($argc) {$file $args}";
	    return -code error $msg;
d782 1
a782 1
	set package [lindex $args 0];
d786 1
a786 1
	set target [lindex $args 1];
d792 2
a793 2
			disabled (trying to load $package to $target)";
		return -code error "permission denied (nested load)";
d802 3
a804 3
		set msg "load error: empty filename and no package name";
		Log $slave $msg;
		return -code error $msg;
d808 2
a809 2
			(trying to load $package to $target)";
		return -code error "permission denied (static package)";
d816 1
a816 1
		Log $slave $msg;
d822 1
a822 1
		Log $slave $msg;
d829 1
a829 1
	    Log $slave $msg;
d844 1
a844 1
	set access_path [GetAccessPath $slave];
d851 1
a851 1
	    error "\"$file\": not in access_path";
d863 3
a865 3
	set msg "not allowed to invoke subcommand $subcommand of $command";
	Log $slave $msg;
	error $msg;
d884 36
@


1.1.1.1
log
@import dejagnu-1999-11-08 snapshot
@
text
@@


1.1.1.2
log
@Tcl 8.3 upgrade
@
text
@d15 1
a15 1
# RCS: @@(#) $Id: safe.tcl,v 1.6.8.1 2000/04/06 22:38:30 spolk Exp $
d25 1
a25 1
package require opt 0.4.1;
d32 2
a33 1
	    interpAddToAccessPath interpFindInAccessPath setLogCmd
d54 1
a54 1
    } ::safe::interpCreate
d57 1
a57 1
    lappend ::tcl::OptDesc(::safe::interpCreate) $::tcl::OptDesc($temp)
d62 1
a62 1
    } ::safe::interpIC
d65 1
a65 1
    lappend ::tcl::OptDesc(::safe::interpIC) $::tcl::OptDesc($temp)
d67 1
a67 1
    ::tcl::OptKeyDelete $temp
d80 1
a80 1
		    "conflicting values given for -statics and -noStatics"
d83 1
a83 1
	    return [expr {!$noStatics}]
d101 1
a101 1
		    "conflicting values given for -nested and -nestedLoadOk"
d122 1
a122 1
		[InterpStatics] [InterpNested] $deleteHook
d128 2
a129 1
	    return -code error "\"$slave\" is not an interpreter"
d138 1
a138 1
		    "\"$slave\" is not an interpreter managed by ::safe::"
d163 2
a164 2
		set Args [::tcl::OptKeyParse ::safe::interpIC $args]
		CheckInterp $slave
d175 1
a175 1
		::tcl::Lassign $args slave arg
d179 1
a179 1
		set hits [::tcl::OptHits desc $arg]
d185 3
a187 3
		CheckInterp $slave
		set item [::tcl::OptCurDesc $desc]
		set name [::tcl::OptName $item]
d209 1
a209 1
				use -statics instead"
d214 1
a214 1
				use -nested instead"
d217 1
a217 1
			return -code error "unknown flag $name (bug)"
d224 2
a225 2
		set Args [::tcl::OptKeyParse ::safe::interpIC $args]
		CheckInterp $slave
d234 2
a235 2
		if {(![::tcl::OptProcArgGiven -statics]) \
			&& (![::tcl::OptProcArgGiven -noStatics]) } {
d240 2
a241 2
		if {([::tcl::OptProcArgGiven -nested]) \
			|| ([::tcl::OptProcArgGiven -nestedLoadOk]) } {
d250 2
a251 1
		InterpSetConfig $slave $accessPath $statics $nested $deleteHook
d255 1
a255 1
			Log $slave "auto_reset failed: $msg"
d257 1
a257 1
			Log $slave "successful auto_reset" NOTICE
d301 1
a301 1
	    ::interp create -safe $slave
d304 1
a304 1
	    set slave [::interp create -safe]
d306 1
a306 1
	Log $slave "Created" NOTICE
d309 1
a309 1
	InterpInit $slave $access_path $staticsok $nestedok $deletehook
d326 2
a327 2
	if {[string equal "" $access_path]} {
	    set access_path [uplevel #0 set auto_path]
d330 1
a330 1
	    set where [lsearch -exact $access_path [info library]]
d333 1
a333 1
		set access_path [concat [list [info library]] $access_path]
d335 1
a335 1
			added it to slave's access_path" NOTICE
d339 1
a339 1
			[lreplace $access_path $where $where]]
d341 1
a341 1
			moved it to front of slave's access_path" NOTICE
d348 1
a348 1
	    set access_path [AddSubDirs $access_path]
d352 1
a352 1
		nestedok=$nestedok deletehook=($deletehook)" NOTICE
d355 1
a355 1
	set nname [PathNumberName $slave]
d357 1
a357 1
	    set n [Set $nname]
d359 1
a359 1
		Unset [PathToken $i $slave]
d365 1
a365 1
	set i 0
d367 7
a373 7
	    Set [PathToken $i $slave] $dir
	    lappend slave_auto_path "\$[PathToken $i]"
	    incr i
	}
	Set $nname $i
	Set [PathListName $slave] $access_path
	Set [VirtualPathListName $slave] $slave_auto_path
d379 1
a379 1
	SyncAccessPath $slave
d388 2
a389 2
	set access_path [GetAccessPath $slave]
	set where [lsearch -exact $access_path $path]
d391 1
a391 1
	    return -code error "$path not found in access path $access_path"
d393 1
a393 1
	return "\$[PathToken $where]"
d403 1
a403 1
	    return $res
d406 3
a408 3
	set nname [PathNumberName $slave]
	set n [Set $nname]
	Set [PathToken $n $slave] $path
d410 1
a410 1
	set token "\$[PathToken $n]"
d412 3
a414 3
	Lappend [VirtualPathListName $slave] $token
	Lappend [PathListName $slave] $path
	Set $nname [expr {$n+1}]
d416 1
a416 1
	SyncAccessPath $slave
d418 1
a418 1
	return $token
d434 1
a434 1
	InterpSetConfig $slave $access_path $staticsok $nestedok $deletehook
a442 7
	# This alias lets the slave use the encoding names, convertfrom,
	# convertto, and system, but not "encoding system <name>" to set
	# the system encoding.

	::interp alias $slave encoding {} [namespace current]::AliasEncoding \
		$slave

d474 3
a476 2
		{source [file join $tcl_library init.tcl]}} msg]} {
	    Log $slave "can't source init.tcl ($msg)"
d494 1
a494 1
		    lappend res $dir
d497 2
a498 2
		    if {([file isdirectory $sub]) \
			    && ([lsearch -exact $res $sub]<0) } {
d500 1
a500 1
	                lappend res $sub
d505 1
a505 1
	return $res
d513 1
a513 1
        Log $slave "About to delete" NOTICE
d518 1
a518 1
	set hookname [DeleteHookName $slave]
d520 1
a520 1
	    set hook [Set $hookname]
d524 1
a524 1
		Unset $hookname
d526 1
a526 1
		    Log $slave "Delete hook error ($err)"
d534 1
a534 1
	set statename [InterpStateName $slave]
d536 1
a536 1
	    Unset $statename
d542 2
a543 2
	    ::interp delete $slave
	    Log $slave "Deleted" NOTICE
d552 1
a552 1
    variable Log
d554 1
a554 1
	return $Log
d557 1
a557 1
	    set Log [lindex $args 0]
d575 6
a580 5
	set slave_auto_path [Set [VirtualPathListName $slave]]
	::interp eval $slave [list set auto_path $slave_auto_path]
	Log $slave "auto_path in $slave has been set to $slave_auto_path"\
		NOTICE
	::interp eval $slave [list set tcl_library [lindex $slave_auto_path 0]]
d590 1
a590 1
	return "S$slave"
d595 2
a596 1
	expr {[Exists [InterpStateName $slave]] && [::interp exists $slave]}
d604 1
a604 1
	    return "[InterpStateName $slave](access_path,$n)"
d609 1
a609 1
	    return "p(:$n:)"
d614 1
a614 1
	return "[InterpStateName $slave](access_path)"
d618 1
a618 1
	return "[InterpStateName $slave](access_path_slave)"
d622 1
a622 1
	return "[InterpStateName $slave](access_path,n)"
d626 1
a626 1
	return "[InterpStateName $slave](staticsok)"
d630 1
a630 1
	return "[InterpStateName $slave](nestedok)"
d634 1
a634 1
	namespace eval [namespace current] $args
d638 1
a638 1
	eval Toplevel set $args
d642 1
a642 1
	eval Toplevel lappend $args
d646 1
a646 1
	eval Toplevel unset $args
d650 1
a650 1
	Toplevel info exists $varname
d676 1
a676 1
	    error "invalid characters in path $path"
d678 1
a678 1
	set n [expr {[Set [PathNumberName $slave]]-1}]
d681 1
a681 1
	    set [PathToken $n] [Set [PathToken $n $slave]]
d684 1
a684 1
	subst -nobackslashes -nocommands $path
d691 1
a691 1
	variable Log
d693 1
a693 1
	    eval $Log [list "$type for slave $slave : $msg"]
d704 1
a704 1
	set ftail [file tail $file]
d706 1
a706 1
	    error "$ftail: filename too long"
d709 1
a709 1
	    error "$ftail: more than one dot is forbidden"
d712 3
a714 2
		[string compare -nocase [file extension $ftail]	".tcl"]} {
	    error "$ftail: must be a *.tcl or tclIndex"
d719 1
a719 1
	    error "no such file or directory"
d724 1
a724 1
	    error "not readable"
d726 1
d734 1
a734 1
	set argc [llength $args]
d740 2
a741 2
	    Log $slave "$msg ($args)"
	    return -code error $msg
d747 1
a747 1
	    Log $slave $msg
d753 1
a753 1
	    Log $slave $msg
d759 2
a760 2
	    Log $slave "$file:$msg"
	    return -code error $msg
d765 2
a766 2
	    Log $slave $msg
	    return -code error "script error"
d775 1
a775 1
	set argc [llength $args]
d777 3
a779 3
	    set msg "load error: too many arguments"
	    Log $slave "$msg ($argc) {$file $args}"
	    return -code error $msg
d783 1
a783 1
	set package [lindex $args 0]
d787 1
a787 1
	set target [lindex $args 1]
d793 2
a794 2
			disabled (trying to load $package to $target)"
		return -code error "permission denied (nested load)"
d803 3
a805 3
		set msg "load error: empty filename and no package name"
		Log $slave $msg
		return -code error $msg
d809 2
a810 2
			(trying to load $package to $target)"
		return -code error "permission denied (static package)"
d817 1
a817 1
		Log $slave $msg
d823 1
a823 1
		Log $slave $msg
d830 1
a830 1
	    Log $slave $msg
d845 1
a845 1
	set access_path [GetAccessPath $slave]
d852 1
a852 1
	    error "\"$file\": not in access_path"
d864 3
a866 3
	set msg "not allowed to invoke subcommand $subcommand of $command"
	Log $slave $msg
	error $msg
a884 36
    }

    # AliasEncoding is the target of the "encoding" alias in safe interpreters.

    proc AliasEncoding {slave args} {

	set argc [llength $args]

	set okpat "^(name.*|convert.*)\$"
	set subcommand [lindex $args 0]

	if {[regexp $okpat $subcommand]} {
	    return [eval ::interp invokehidden $slave encoding $subcommand \
		    [lrange $args 1 end]]
	}

	if {[string match $subcommand system]} {
	    if {$argc == 1} {
		# passed all the tests , lets source it:
		if {[catch {::interp invokehidden \
			$slave encoding system} msg]} {
		    Log $slave $msg
		    return -code error "script error"
		}
	    } else {
		set msg "wrong # args: should be \"encoding system\""
		Log $slave $msg
		error $msg
	    }
	} else {
	    set msg "wrong # args: should be \"encoding option ?arg ...?\""
	    Log $slave $msg
	    error $msg
	}

	return $msg
@


1.1.1.3
log
@import tcl 8.4.0
@
text
@d15 1
a15 1
# RCS: @@(#) $Id: safe.tcl,v 1.8 2002/02/22 19:51:29 hobbs Exp $
d499 1
a499 1
		foreach sub [glob -directory $dir -nocomplain *] {
d698 1
a698 1

d702 14
a715 4
	# This used to limit what can be sourced to ".tcl" and forbid files
	# with more than 1 dot and longer than 14 chars, but I changed that
	# for 8.4 as a safe interp has enough internal protection already
	# to allow sourcing anything. - hobbs
@


