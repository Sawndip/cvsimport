head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.58
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.56
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.54
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.52
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.50
	gdb_7_0-branch:1.5.0.48
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tcl8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.46
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.44
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.42
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.40
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.38
	gdb_6_5-2006-05-14-branchpoint:1.5
	readline_5_1-import-branch:1.5.0.36
	readline_5_1-import-branchpoint:1.5
	gdb_6_4-branch:1.5.0.34
	gdb_6_4-2005-11-01-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.32
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	ezannoni_pie-20040323-branch:1.5.0.30
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.28
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.26
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.24
	cagney_x86i386-20030821-branch:1.5.0.22
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.20
	gdb_6_0-2003-06-23-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.18
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.16
	cagney_writestrings-20030508-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.14
	cagney_fileio-20030521-branchpoint:1.5
	carlton_dictionary-20030430-merge:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.12
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.10
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.8
	cagney_lazyid-20030317-branchpoint:1.5
	offbyone-20030313-branch:1.5.0.6
	offbyone-20030313-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.4
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.2
	interps-20030202-branchpoint:1.5
	TCL8_4_1:1.1.1.3
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.2
	TCL_8_4_1:1.1.1.3
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.4
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TCL_8_4_0:1.1.1.3
	carlton_dictionary-branch:1.2.0.16
	carlton_dictionary-20020920-branchpoint:1.2
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.14
	gdb_5_3-branch:1.2.0.12
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.10
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.8
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.6
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TCL_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	dejagnu-2000-02-04:1.1.1.1
	dejagnu-2000-01-31:1.1.1.1
	dejagnu-2000-01-24:1.1.1.1
	dejagnu-2000-01-17:1.1.1.1
	dejagnu-2000-01-10:1.1.1.1
	dejagnu-2000-01-04:1.1.1.1
	dejagnu-1999-12-21:1.1.1.1
	dejagnu-1999-12-13:1.1.1.1
	dejagnu-1999-12-07:1.1.1.1
	dejagnu-1999-12-06:1.1.1.1
	dejagnu-1999-11-15:1.1.1.1
	dejagnu-1999-11-08:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.5
date	2003.01.21.19.40.20;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.26.19.48.05;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.37.10;	author kseitz;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2001.09.09.23.56.09;	author irox;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2002.09.27.21.49.13;	author kseitz;	state Exp;
branches;
next	;

1.3.4.1
date	2003.12.14.20.28.51;	author drow;	state Exp;
branches;
next	;

1.2.16.1
date	2002.12.23.19.40.51;	author carlton;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2003.02.07.19.18.22;	author carlton;	state Exp;
branches;
next	;

1.1.1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.09.22.40.59;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.19.55.48;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tcl 8.4.1
@
text
@/* 
 * tclUnixChan.c
 *
 *	Common channel driver for Unix channels based on files, command
 *	pipes and TCP sockets.
 *
 * Copyright (c) 1995-1997 Sun Microsystems, Inc.
 * Copyright (c) 1998-1999 by Scriptics Corporation.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tclUnixChan.c,v 1.39 2002/09/03 02:01:25 hobbs Exp $
 */

#include "tclInt.h"	/* Internal definitions for Tcl. */
#include "tclPort.h"	/* Portability features for Tcl. */

/*
 * sys/ioctl.h has already been included by tclPort.h.	Including termios.h
 * or termio.h causes a bunch of warning messages because some duplicate
 * (but not contradictory) #defines exist in termios.h and/or termio.h
 */
#undef NL0
#undef NL1
#undef CR0
#undef CR1
#undef CR2
#undef CR3
#undef TAB0
#undef TAB1
#undef TAB2
#undef XTABS
#undef BS0
#undef BS1
#undef FF0
#undef FF1
#undef ECHO
#undef NOFLSH
#undef TOSTOP
#undef FLUSHO
#undef PENDIN

#define SUPPORTS_TTY

#ifdef USE_TERMIOS
#   include <termios.h>
#   ifdef HAVE_SYS_IOCTL_H
#	include <sys/ioctl.h>
#   endif /* HAVE_SYS_IOCTL_H */
#   ifdef HAVE_SYS_MODEM_H
#	include <sys/modem.h>
#   endif /* HAVE_SYS_MODEM_H */
#   define IOSTATE			struct termios
#   define GETIOSTATE(fd, statePtr)	tcgetattr((fd), (statePtr))
#   define SETIOSTATE(fd, statePtr)	tcsetattr((fd), TCSADRAIN, (statePtr))
#   define GETCONTROL(fd, intPtr)	ioctl((fd), TIOCMGET, (intPtr))
#   define SETCONTROL(fd, intPtr)	ioctl((fd), TIOCMSET, (intPtr))
    /*
     * TIP #35 introduced a different on exit flush/close behavior that
     * doesn't work correctly with standard channels on all systems.
     * The problem is tcflush throws away waiting channel data.	 This may
     * be necessary for true serial channels that may block, but isn't
     * correct in the standard case.  This might be replaced with tcdrain
     * instead, but that can block.  For now, we revert to making this do
     * nothing, and TtyOutputProc being the same old FileOutputProc.
     * -- hobbs [Bug #525783]
     */
#   define BAD_TIP35_FLUSH 0
#   if BAD_TIP35_FLUSH
#	define TTYFLUSH(fd)		tcflush((fd), TCIOFLUSH);
#   else
#	define TTYFLUSH(fd)
#   endif /* BAD_TIP35_FLUSH */
#   ifdef FIONREAD
#	define GETREADQUEUE(fd, int)	ioctl((fd), FIONREAD, &(int))
#   elif defined(FIORDCHK)
#	define GETREADQUEUE(fd, int)	int = ioctl((fd), FIORDCHK, NULL)
#   endif /* FIONREAD */
#   ifdef TIOCOUTQ
#	define GETWRITEQUEUE(fd, int)	ioctl((fd), TIOCOUTQ, &(int))
#   endif /* TIOCOUTQ */
#   if defined(TIOCSBRK) && defined(TIOCCBRK)
/*
 * Can't use ?: operator below because that messes up types on either
 * Linux or Solaris (the two are mutually exclusive!)
 */
#	define SETBREAK(fd, flag) \
		if (flag) {				\
		    ioctl((fd), TIOCSBRK, NULL);	\
		} else {				\
		    ioctl((fd), TIOCCBRK, NULL);	\
		}
#   endif /* TIOCSBRK&TIOCCBRK */
#   if !defined(CRTSCTS) && defined(CNEW_RTSCTS)
#	define CRTSCTS CNEW_RTSCTS
#   endif /* !CRTSCTS&CNEW_RTSCTS */
#else	/* !USE_TERMIOS */

#ifdef USE_TERMIO
#   include <termio.h>
#   define IOSTATE			struct termio
#   define GETIOSTATE(fd, statePtr)	ioctl((fd), TCGETA, (statePtr))
#   define SETIOSTATE(fd, statePtr)	ioctl((fd), TCSETAW, (statePtr))
#else	/* !USE_TERMIO */

#ifdef USE_SGTTY
#   include <sgtty.h>
#   define IOSTATE			struct sgttyb
#   define GETIOSTATE(fd, statePtr)	ioctl((fd), TIOCGETP, (statePtr))
#   define SETIOSTATE(fd, statePtr)	ioctl((fd), TIOCSETP, (statePtr))
#else	/* !USE_SGTTY */
#   undef SUPPORTS_TTY
#endif	/* !USE_SGTTY */

#endif	/* !USE_TERMIO */
#endif	/* !USE_TERMIOS */

/*
 * This structure describes per-instance state of a file based channel.
 */

typedef struct FileState {
    Tcl_Channel channel;	/* Channel associated with this file. */
    int fd;			/* File handle. */
    int validMask;		/* OR'ed combination of TCL_READABLE,
				 * TCL_WRITABLE, or TCL_EXCEPTION: indicates
				 * which operations are valid on the file. */
#ifdef DEPRECATED
    struct FileState *nextPtr;	/* Pointer to next file in list of all
				 * file channels. */
#endif /* DEPRECATED */
} FileState;

#ifdef SUPPORTS_TTY

/*
 * The following structure describes per-instance state of a tty-based
 * channel.
 */

typedef struct TtyState {
    FileState fs;		/* Per-instance state of the file
				 * descriptor.	Must be the first field. */
    int stateUpdated;		/* Flag to say if the state has been
				 * modified and needs resetting. */
    IOSTATE savedState;		/* Initial state of device.  Used to reset
				 * state when device closed. */
} TtyState;

/*
 * The following structure is used to set or get the serial port
 * attributes in a platform-independant manner.
 */

typedef struct TtyAttrs {
    int baud;
    int parity;
    int data;
    int stop;
} TtyAttrs;

#endif	/* !SUPPORTS_TTY */

#define UNSUPPORTED_OPTION(detail) \
	if (interp) {							\
	    Tcl_AppendResult(interp, (detail),				\
		    " not supported for this platform", (char *) NULL); \
	}

#ifdef DEPRECATED
typedef struct ThreadSpecificData {
    /*
     * List of all file channels currently open.  This is per thread and is
     * used to match up fd's to channels, which rarely occurs.
     */

    FileState *firstFilePtr;
} ThreadSpecificData;

static Tcl_ThreadDataKey dataKey;
#endif /* DEPRECATED */

/*
 * This structure describes per-instance state of a tcp based channel.
 */

typedef struct TcpState {
    Tcl_Channel channel;	/* Channel associated with this file. */
    int fd;			/* The socket itself. */
    int flags;			/* ORed combination of the bitfields
				 * defined below. */
    Tcl_TcpAcceptProc *acceptProc;
				/* Proc to call on accept. */
    ClientData acceptProcData;	/* The data for the accept proc. */
} TcpState;

/*
 * These bits may be ORed together into the "flags" field of a TcpState
 * structure.
 */

#define TCP_ASYNC_SOCKET	(1<<0)	/* Asynchronous socket. */
#define TCP_ASYNC_CONNECT	(1<<1)	/* Async connect in progress. */

/*
 * The following defines the maximum length of the listen queue. This is
 * the number of outstanding yet-to-be-serviced requests for a connection
 * on a server socket, more than this number of outstanding requests and
 * the connection request will fail.
 */

#ifndef SOMAXCONN
#   define SOMAXCONN	100
#endif /* SOMAXCONN */

#if (SOMAXCONN < 100)
#   undef  SOMAXCONN
#   define SOMAXCONN	100
#endif /* SOMAXCONN < 100 */

/*
 * The following defines how much buffer space the kernel should maintain
 * for a socket.
 */

#define SOCKET_BUFSIZE	4096

/*
 * Static routines for this file:
 */

static TcpState *	CreateSocket _ANSI_ARGS_((Tcl_Interp *interp,
			    int port, CONST char *host, int server,
			    CONST char *myaddr, int myport, int async));
static int		CreateSocketAddress _ANSI_ARGS_(
			    (struct sockaddr_in *sockaddrPtr,
			    CONST char *host, int port));
static int		FileBlockModeProc _ANSI_ARGS_((
			    ClientData instanceData, int mode));
static int		FileCloseProc _ANSI_ARGS_((ClientData instanceData,
			    Tcl_Interp *interp));
static int		FileGetHandleProc _ANSI_ARGS_((ClientData instanceData,
			    int direction, ClientData *handlePtr));
static int		FileInputProc _ANSI_ARGS_((ClientData instanceData,
			    char *buf, int toRead, int *errorCode));
static int		FileOutputProc _ANSI_ARGS_((
			    ClientData instanceData, CONST char *buf,
			    int toWrite, int *errorCode));
static int		FileSeekProc _ANSI_ARGS_((ClientData instanceData,
			    long offset, int mode, int *errorCode));
static Tcl_WideInt	FileWideSeekProc _ANSI_ARGS_((ClientData instanceData,
			    Tcl_WideInt offset, int mode, int *errorCode));
static void		FileWatchProc _ANSI_ARGS_((ClientData instanceData,
			    int mask));
static void		TcpAccept _ANSI_ARGS_((ClientData data, int mask));
static int		TcpBlockModeProc _ANSI_ARGS_((ClientData data,
			    int mode));
static int		TcpCloseProc _ANSI_ARGS_((ClientData instanceData,
			    Tcl_Interp *interp));
static int		TcpGetHandleProc _ANSI_ARGS_((ClientData instanceData,
			    int direction, ClientData *handlePtr));
static int		TcpGetOptionProc _ANSI_ARGS_((ClientData instanceData,
			    Tcl_Interp *interp, CONST char *optionName,
			    Tcl_DString *dsPtr));
static int		TcpInputProc _ANSI_ARGS_((ClientData instanceData,
			    char *buf, int toRead,  int *errorCode));
static int		TcpOutputProc _ANSI_ARGS_((ClientData instanceData,
			    CONST char *buf, int toWrite, int *errorCode));
static void		TcpWatchProc _ANSI_ARGS_((ClientData instanceData,
			    int mask));
#ifdef SUPPORTS_TTY
static int		TtyCloseProc _ANSI_ARGS_((ClientData instanceData,
			    Tcl_Interp *interp));
static void		TtyGetAttributes _ANSI_ARGS_((int fd,
			    TtyAttrs *ttyPtr));
static int		TtyGetOptionProc _ANSI_ARGS_((ClientData instanceData,
			    Tcl_Interp *interp, CONST char *optionName,
			    Tcl_DString *dsPtr));
static FileState *	TtyInit _ANSI_ARGS_((int fd, int initialize));
#if BAD_TIP35_FLUSH
static int		TtyOutputProc _ANSI_ARGS_((ClientData instanceData,
			    CONST char *buf, int toWrite, int *errorCode));
#endif /* BAD_TIP35_FLUSH */
static int		TtyParseMode _ANSI_ARGS_((Tcl_Interp *interp,
			    CONST char *mode, int *speedPtr, int *parityPtr,
			    int *dataPtr, int *stopPtr));
static void		TtySetAttributes _ANSI_ARGS_((int fd,
			    TtyAttrs *ttyPtr));
static int		TtySetOptionProc _ANSI_ARGS_((ClientData instanceData,
			    Tcl_Interp *interp, CONST char *optionName, 
			    CONST char *value));
#endif	/* SUPPORTS_TTY */
static int		WaitForConnect _ANSI_ARGS_((TcpState *statePtr,
			    int *errorCodePtr));

/*
 * This structure describes the channel type structure for file based IO:
 */

static Tcl_ChannelType fileChannelType = {
    "file",			/* Type name. */
    TCL_CHANNEL_VERSION_3,	/* v3 channel */
    FileCloseProc,		/* Close proc. */
    FileInputProc,		/* Input proc. */
    FileOutputProc,		/* Output proc. */
    FileSeekProc,		/* Seek proc. */
    NULL,			/* Set option proc. */
    NULL,			/* Get option proc. */
    FileWatchProc,		/* Initialize notifier. */
    FileGetHandleProc,		/* Get OS handles out of channel. */
    NULL,			/* close2proc. */
    FileBlockModeProc,		/* Set blocking or non-blocking mode.*/
    NULL,			/* flush proc. */
    NULL,			/* handler proc. */
    FileWideSeekProc,		/* wide seek proc. */
};

#ifdef SUPPORTS_TTY
/*
 * This structure describes the channel type structure for serial IO.
 * Note that this type is a subclass of the "file" type.
 */

static Tcl_ChannelType ttyChannelType = {
    "tty",			/* Type name. */
    TCL_CHANNEL_VERSION_2,	/* v2 channel */
    TtyCloseProc,		/* Close proc. */
    FileInputProc,		/* Input proc. */
#if BAD_TIP35_FLUSH
    TtyOutputProc,		/* Output proc. */
#else /* !BAD_TIP35_FLUSH */
    FileOutputProc,		/* Output proc. */
#endif /* BAD_TIP35_FLUSH */
    NULL,			/* Seek proc. */
    TtySetOptionProc,		/* Set option proc. */
    TtyGetOptionProc,		/* Get option proc. */
    FileWatchProc,		/* Initialize notifier. */
    FileGetHandleProc,		/* Get OS handles out of channel. */
    NULL,			/* close2proc. */
    FileBlockModeProc,		/* Set blocking or non-blocking mode.*/
    NULL,			/* flush proc. */
    NULL,			/* handler proc. */
};
#endif	/* SUPPORTS_TTY */

/*
 * This structure describes the channel type structure for TCP socket
 * based IO:
 */

static Tcl_ChannelType tcpChannelType = {
    "tcp",			/* Type name. */
    TCL_CHANNEL_VERSION_2,	/* v2 channel */
    TcpCloseProc,		/* Close proc. */
    TcpInputProc,		/* Input proc. */
    TcpOutputProc,		/* Output proc. */
    NULL,			/* Seek proc. */
    NULL,			/* Set option proc. */
    TcpGetOptionProc,		/* Get option proc. */
    TcpWatchProc,		/* Initialize notifier. */
    TcpGetHandleProc,		/* Get OS handles out of channel. */
    NULL,			/* close2proc. */
    TcpBlockModeProc,		/* Set blocking or non-blocking mode.*/
    NULL,			/* flush proc. */
    NULL,			/* handler proc. */
};


/*
 *----------------------------------------------------------------------
 *
 * FileBlockModeProc --
 *
 *	Helper procedure to set blocking and nonblocking modes on a
 *	file based channel. Invoked by generic IO level code.
 *
 * Results:
 *	0 if successful, errno when failed.
 *
 * Side effects:
 *	Sets the device into blocking or non-blocking mode.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
static int
FileBlockModeProc(instanceData, mode)
    ClientData instanceData;		/* File state. */
    int mode;				/* The mode to set. Can be one of
					 * TCL_MODE_BLOCKING or
					 * TCL_MODE_NONBLOCKING. */
{
    FileState *fsPtr = (FileState *) instanceData;
    int curStatus;

#ifndef USE_FIONBIO
    curStatus = fcntl(fsPtr->fd, F_GETFL);
    if (mode == TCL_MODE_BLOCKING) {
	curStatus &= (~(O_NONBLOCK));
    } else {
	curStatus |= O_NONBLOCK;
    }
    if (fcntl(fsPtr->fd, F_SETFL, curStatus) < 0) {
	return errno;
    }
    curStatus = fcntl(fsPtr->fd, F_GETFL);
#else /* USE_FIONBIO */
    if (mode == TCL_MODE_BLOCKING) {
	curStatus = 0;
    } else {
	curStatus = 1;
    }
    if (ioctl(fsPtr->fd, (int) FIONBIO, &curStatus) < 0) {
	return errno;
    }
#endif /* !USE_FIONBIO */
    return 0;
}

/*
 *----------------------------------------------------------------------
 *
 * FileInputProc --
 *
 *	This procedure is invoked from the generic IO level to read
 *	input from a file based channel.
 *
 * Results:
 *	The number of bytes read is returned or -1 on error. An output
 *	argument contains a POSIX error code if an error occurs, or zero.
 *
 * Side effects:
 *	Reads input from the input device of the channel.
 *
 *----------------------------------------------------------------------
 */

static int
FileInputProc(instanceData, buf, toRead, errorCodePtr)
    ClientData instanceData;		/* File state. */
    char *buf;				/* Where to store data read. */
    int toRead;				/* How much space is available
					 * in the buffer? */
    int *errorCodePtr;			/* Where to store error code. */
{
    FileState *fsPtr = (FileState *) instanceData;
    int bytesRead;			/* How many bytes were actually
					 * read from the input device? */

    *errorCodePtr = 0;

    /*
     * Assume there is always enough input available. This will block
     * appropriately, and read will unblock as soon as a short read is
     * possible, if the channel is in blocking mode. If the channel is
     * nonblocking, the read will never block.
     */

    bytesRead = read(fsPtr->fd, buf, (size_t) toRead);
    if (bytesRead > -1) {
	return bytesRead;
    }
    *errorCodePtr = errno;
    return -1;
}

/*
 *----------------------------------------------------------------------
 *
 * FileOutputProc--
 *
 *	This procedure is invoked from the generic IO level to write
 *	output to a file channel.
 *
 * Results:
 *	The number of bytes written is returned or -1 on error. An
 *	output argument contains a POSIX error code if an error occurred,
 *	or zero.
 *
 * Side effects:
 *	Writes output on the output device of the channel.
 *
 *----------------------------------------------------------------------
 */

static int
FileOutputProc(instanceData, buf, toWrite, errorCodePtr)
    ClientData instanceData;		/* File state. */
    CONST char *buf;			/* The data buffer. */
    int toWrite;			/* How many bytes to write? */
    int *errorCodePtr;			/* Where to store error code. */
{
    FileState *fsPtr = (FileState *) instanceData;
    int written;

    *errorCodePtr = 0;

    if (toWrite == 0) {
	/*
	 * SF Tcl Bug 465765.
	 * Do not try to write nothing into a file. STREAM based
	 * implementations will considers this as EOF (if there is a
	 * pipe behind the file).
	 */

	return 0;
    }
    written = write(fsPtr->fd, buf, (size_t) toWrite);
    if (written > -1) {
	return written;
    }
    *errorCodePtr = errno;
    return -1;
}

/*
 *----------------------------------------------------------------------
 *
 * FileCloseProc --
 *
 *	This procedure is called from the generic IO level to perform
 *	channel-type-specific cleanup when a file based channel is closed.
 *
 * Results:
 *	0 if successful, errno if failed.
 *
 * Side effects:
 *	Closes the device of the channel.
 *
 *----------------------------------------------------------------------
 */

static int
FileCloseProc(instanceData, interp)
    ClientData instanceData;	/* File state. */
    Tcl_Interp *interp;		/* For error reporting - unused. */
{
    FileState *fsPtr = (FileState *) instanceData;
    int errorCode = 0;
#ifdef DEPRECATED
    FileState **nextPtrPtr;
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
#endif /* DEPRECATED */
    Tcl_DeleteFileHandler(fsPtr->fd);

    /*
     * Do not close standard channels while in thread-exit.
     */

    if (!TclInExit()
	    || ((fsPtr->fd != 0) && (fsPtr->fd != 1) && (fsPtr->fd != 2))) {
	if (close(fsPtr->fd) < 0) {
	    errorCode = errno;
	}
    }
#ifdef DEPRECATED
    for (nextPtrPtr = &(tsdPtr->firstFilePtr); (*nextPtrPtr) != NULL;
	 nextPtrPtr = &((*nextPtrPtr)->nextPtr)) {
	if ((*nextPtrPtr) == fsPtr) {
	    (*nextPtrPtr) = fsPtr->nextPtr;
	    break;
	}
    }
#endif /* DEPRECATED */
    ckfree((char *) fsPtr);
    return errorCode;
}

/*
 *----------------------------------------------------------------------
 *
 * FileSeekProc --
 *
 *	This procedure is called by the generic IO level to move the
 *	access point in a file based channel.
 *
 * Results:
 *	-1 if failed, the new position if successful. An output
 *	argument contains the POSIX error code if an error occurred,
 *	or zero.
 *
 * Side effects:
 *	Moves the location at which the channel will be accessed in
 *	future operations.
 *
 *----------------------------------------------------------------------
 */

static int
FileSeekProc(instanceData, offset, mode, errorCodePtr)
    ClientData instanceData;	/* File state. */
    long offset;		/* Offset to seek to. */
    int mode;			/* Relative to where should we seek? Can be
				 * one of SEEK_START, SEEK_SET or SEEK_END. */
    int *errorCodePtr;		/* To store error code. */
{
    FileState *fsPtr = (FileState *) instanceData;
    Tcl_WideInt oldLoc, newLoc;

    /*
     * Save our current place in case we need to roll-back the seek.
     */
    oldLoc = TclOSseek(fsPtr->fd, (Tcl_SeekOffset) 0, SEEK_CUR);
    if (oldLoc == Tcl_LongAsWide(-1)) {
	/*
	 * Bad things are happening.  Error out...
	 */
	*errorCodePtr = errno;
	return -1;
    }
 
    newLoc = TclOSseek(fsPtr->fd, (Tcl_SeekOffset) offset, mode);
 
    /*
     * Check for expressability in our return type, and roll-back otherwise.
     */
    if (newLoc > Tcl_LongAsWide(INT_MAX)) {
	*errorCodePtr = EOVERFLOW;
	TclOSseek(fsPtr->fd, (Tcl_SeekOffset) oldLoc, SEEK_SET);
	return -1;
    } else {
	*errorCodePtr = (newLoc == Tcl_LongAsWide(-1)) ? errno : 0;
    }
    return (int) Tcl_WideAsLong(newLoc);
}

/*
 *----------------------------------------------------------------------
 *
 * FileWideSeekProc --
 *
 *	This procedure is called by the generic IO level to move the
 *	access point in a file based channel, with offsets expressed
 *	as wide integers.
 *
 * Results:
 *	-1 if failed, the new position if successful. An output
 *	argument contains the POSIX error code if an error occurred,
 *	or zero.
 *
 * Side effects:
 *	Moves the location at which the channel will be accessed in
 *	future operations.
 *
 *----------------------------------------------------------------------
 */

static Tcl_WideInt
FileWideSeekProc(instanceData, offset, mode, errorCodePtr)
    ClientData instanceData;	/* File state. */
    Tcl_WideInt offset;		/* Offset to seek to. */
    int mode;			/* Relative to where should we seek? Can be
				 * one of SEEK_START, SEEK_CUR or SEEK_END. */
    int *errorCodePtr;		/* To store error code. */
{
    FileState *fsPtr = (FileState *) instanceData;
    Tcl_WideInt newLoc;

    newLoc = TclOSseek(fsPtr->fd, (Tcl_SeekOffset) offset, mode);

    *errorCodePtr = (newLoc == -1) ? errno : 0;
    return newLoc;
}

/*
 *----------------------------------------------------------------------
 *
 * FileWatchProc --
 *
 *	Initialize the notifier to watch the fd from this channel.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Sets up the notifier so that a future event on the channel will
 *	be seen by Tcl.
 *
 *----------------------------------------------------------------------
 */

static void
FileWatchProc(instanceData, mask)
    ClientData instanceData;		/* The file state. */
    int mask;				/* Events of interest; an OR-ed
					 * combination of TCL_READABLE,
					 * TCL_WRITABLE and TCL_EXCEPTION. */
{
    FileState *fsPtr = (FileState *) instanceData;

    /*
     * Make sure we only register for events that are valid on this file.
     * Note that we are passing Tcl_NotifyChannel directly to
     * Tcl_CreateFileHandler with the channel pointer as the client data.
     */

    mask &= fsPtr->validMask;
    if (mask) {
	Tcl_CreateFileHandler(fsPtr->fd, mask,
		(Tcl_FileProc *) Tcl_NotifyChannel,
		(ClientData) fsPtr->channel);
    } else {
	Tcl_DeleteFileHandler(fsPtr->fd);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * FileGetHandleProc --
 *
 *	Called from Tcl_GetChannelHandle to retrieve OS handles from
 *	a file based channel.
 *
 * Results:
 *	Returns TCL_OK with the fd in handlePtr, or TCL_ERROR if
 *	there is no handle for the specified direction. 
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static int
FileGetHandleProc(instanceData, direction, handlePtr)
    ClientData instanceData;	/* The file state. */
    int direction;		/* TCL_READABLE or TCL_WRITABLE */
    ClientData *handlePtr;	/* Where to store the handle.  */
{
    FileState *fsPtr = (FileState *) instanceData;

    if (direction & fsPtr->validMask) {
	*handlePtr = (ClientData) fsPtr->fd;
	return TCL_OK;
    } else {
	return TCL_ERROR;
    }
}

#ifdef SUPPORTS_TTY 

/*
 *----------------------------------------------------------------------
 *
 * TtyCloseProc --
 *
 *	This procedure is called from the generic IO level to perform
 *	channel-type-specific cleanup when a tty based channel is closed.
 *
 * Results:
 *	0 if successful, errno if failed.
 *
 * Side effects:
 *	Closes the device of the channel.
 *
 *----------------------------------------------------------------------
 */
static int
TtyCloseProc(instanceData, interp)
    ClientData instanceData;	/* Tty state. */
    Tcl_Interp *interp;		/* For error reporting - unused. */
{
#if BAD_TIP35_FLUSH
    TtyState *ttyPtr = (TtyState *) instanceData;
#endif /* BAD_TIP35_FLUSH */
#ifdef TTYFLUSH
    TTYFLUSH(ttyPtr->fs.fd);
#endif /* TTYFLUSH */
#if 0
    /*
     * TIP#35 agreed to remove the unsave so that TCL could be used as a 
     * simple stty. 
     * It would be cleaner to remove all the stuff related to 
     *	  TtyState.stateUpdated
     *	  TtyState.savedState
     * Then the structure TtyState would be the same as FileState.
     * IMO this cleanup could better be done for the final 8.4 release
     * after nobody complained about the missing unsave. -- schroedter
     */
    if (ttyPtr->stateUpdated) {
	SETIOSTATE(ttyPtr->fs.fd, &ttyPtr->savedState);
    }
#endif
    return FileCloseProc(instanceData, interp);
}

/*
 *----------------------------------------------------------------------
 *
 * TtyOutputProc--
 *
 *	This procedure is invoked from the generic IO level to write
 *	output to a TTY channel.
 *
 * Results:
 *	The number of bytes written is returned or -1 on error. An
 *	output argument contains a POSIX error code if an error occurred,
 *	or zero.
 *
 * Side effects:
 *	Writes output on the output device of the channel
 *	if the channel is not designated to be closed.
 *
 *----------------------------------------------------------------------
 */

#if BAD_TIP35_FLUSH
static int
TtyOutputProc(instanceData, buf, toWrite, errorCodePtr)
    ClientData instanceData;		/* File state. */
    CONST char *buf;			/* The data buffer. */
    int toWrite;			/* How many bytes to write? */
    int *errorCodePtr;			/* Where to store error code. */
{
    if (TclInExit()) {
	/*
	 * Do not write data during Tcl exit.
	 * Serial port may block preventing Tcl from exit.
	 */
	return toWrite;
    } else {
	return FileOutputProc(instanceData, buf, toWrite, errorCodePtr);
    }
}
#endif /* BAD_TIP35_FLUSH */

#ifdef USE_TERMIOS
/*
 *----------------------------------------------------------------------
 *
 * TtyModemStatusStr --
 *
 *  Converts a RS232 modem status list of readable flags
 *
 *----------------------------------------------------------------------
 */
static void
TtyModemStatusStr(status, dsPtr)
    int status;		   /* RS232 modem status */
    Tcl_DString *dsPtr;	   /* Where to store string */
{
#ifdef TIOCM_CTS
    Tcl_DStringAppendElement(dsPtr, "CTS");
    Tcl_DStringAppendElement(dsPtr, (status & TIOCM_CTS) ? "1" : "0");
#endif /* TIOCM_CTS */
#ifdef TIOCM_DSR
    Tcl_DStringAppendElement(dsPtr, "DSR");
    Tcl_DStringAppendElement(dsPtr, (status & TIOCM_DSR) ? "1" : "0");
#endif /* TIOCM_DSR */
#ifdef TIOCM_RNG
    Tcl_DStringAppendElement(dsPtr, "RING");
    Tcl_DStringAppendElement(dsPtr, (status & TIOCM_RNG) ? "1" : "0");
#endif /* TIOCM_RNG */
#ifdef TIOCM_CD
    Tcl_DStringAppendElement(dsPtr, "DCD");
    Tcl_DStringAppendElement(dsPtr, (status & TIOCM_CD) ? "1" : "0");
#endif /* TIOCM_CD */
}
#endif /* USE_TERMIOS */

/*
 *----------------------------------------------------------------------
 *
 * TtySetOptionProc --
 *
 *	Sets an option on a channel.
 *
 * Results:
 *	A standard Tcl result. Also sets the interp's result on error if
 *	interp is not NULL.
 *
 * Side effects:
 *	May modify an option on a device.
 *	Sets Error message if needed (by calling Tcl_BadChannelOption).
 *
 *----------------------------------------------------------------------
 */

static int		
TtySetOptionProc(instanceData, interp, optionName, value)
    ClientData instanceData;	/* File state. */
    Tcl_Interp *interp;		/* For error reporting - can be NULL. */
    CONST char *optionName;	/* Which option to set? */
    CONST char *value;		/* New value for option. */
{
    FileState *fsPtr = (FileState *) instanceData;
    unsigned int len, vlen;
    TtyAttrs tty;
#ifdef USE_TERMIOS
    int flag, control, argc;
    CONST char **argv;
    IOSTATE iostate;
#endif /* USE_TERMIOS */

    len = strlen(optionName);
    vlen = strlen(value);

    /*
     * Option -mode baud,parity,databits,stopbits
     */
    if ((len > 2) && (strncmp(optionName, "-mode", len) == 0)) {
	if (TtyParseMode(interp, value, &tty.baud, &tty.parity, &tty.data,
		&tty.stop) != TCL_OK) {
	    return TCL_ERROR;
	}
	/*
	 * system calls results should be checked there. -- dl
	 */

	TtySetAttributes(fsPtr->fd, &tty);
	((TtyState *) fsPtr)->stateUpdated = 1;
	return TCL_OK;
    }

#ifdef USE_TERMIOS

    /*
     * Option -handshake none|xonxoff|rtscts|dtrdsr
     */
    if ((len > 1) && (strncmp(optionName, "-handshake", len) == 0)) {
	/*
	 * Reset all handshake options
	 * DTR and RTS are ON by default
	 */
	GETIOSTATE(fsPtr->fd, &iostate);
	iostate.c_iflag &= ~(IXON | IXOFF | IXANY);
#ifdef CRTSCTS
	iostate.c_cflag &= ~CRTSCTS;
#endif /* CRTSCTS */
	if (strncasecmp(value, "NONE", vlen) == 0) {
	    /* leave all handshake options disabled */
	} else if (strncasecmp(value, "XONXOFF", vlen) == 0) {
	    iostate.c_iflag |= (IXON | IXOFF | IXANY);
	} else if (strncasecmp(value, "RTSCTS", vlen) == 0) {
#ifdef CRTSCTS
	    iostate.c_cflag |= CRTSCTS;
#else /* !CRTSTS */
	    UNSUPPORTED_OPTION("-handshake RTSCTS");
	    return TCL_ERROR;
#endif /* CRTSCTS */
	} else if (strncasecmp(value, "DTRDSR", vlen) == 0) {
	    UNSUPPORTED_OPTION("-handshake DTRDSR");
	    return TCL_ERROR;
	} else {
	    if (interp) {
		Tcl_AppendResult(interp, "bad value for -handshake: ",
			"must be one of xonxoff, rtscts, dtrdsr or none",
			(char *) NULL);
	    }
	    return TCL_ERROR;
	}
	SETIOSTATE(fsPtr->fd, &iostate);
	return TCL_OK;
    }

    /*
     * Option -xchar {\x11 \x13}
     */
    if ((len > 1) && (strncmp(optionName, "-xchar", len) == 0)) {
	GETIOSTATE(fsPtr->fd, &iostate);
	if (Tcl_SplitList(interp, value, &argc, &argv) == TCL_ERROR) {
	    return TCL_ERROR;
	}
	if (argc == 2) {
	    iostate.c_cc[VSTART] = argv[0][0];
	    iostate.c_cc[VSTOP]	 = argv[1][0];
	} else {
	    if (interp) {
		Tcl_AppendResult(interp,
		    "bad value for -xchar: should be a list of two elements",
		    (char *) NULL);
	    }
	    return TCL_ERROR;
	}
	SETIOSTATE(fsPtr->fd, &iostate);
	return TCL_OK;
    }

    /*
     * Option -timeout msec
     */
    if ((len > 2) && (strncmp(optionName, "-timeout", len) == 0)) {
	int msec;

	GETIOSTATE(fsPtr->fd, &iostate);
	if (Tcl_GetInt(interp, value, &msec) != TCL_OK) {
	    return TCL_ERROR;
	}
	iostate.c_cc[VMIN]  = 0;
	iostate.c_cc[VTIME] = (msec == 0) ? 0 : (msec < 100) ? 1 : (msec+50)/100;
	SETIOSTATE(fsPtr->fd, &iostate);
	return TCL_OK;
    }

    /*
     * Option -ttycontrol {DTR 1 RTS 0 BREAK 0}
     */
    if ((len > 4) && (strncmp(optionName, "-ttycontrol", len) == 0)) {
	if (Tcl_SplitList(interp, value, &argc, &argv) == TCL_ERROR) {
	    return TCL_ERROR;
	}
	if ((argc % 2) == 1) {
	    if (interp) {
		Tcl_AppendResult(interp,
			"bad value for -ttycontrol: should be a list of",
			"signal,value pairs", (char *) NULL);
	    }
	    return TCL_ERROR;
	}

	GETCONTROL(fsPtr->fd, &control);
	while (argc > 1) {
	    if (Tcl_GetBoolean(interp, argv[1], &flag) == TCL_ERROR) {
		return TCL_ERROR;
	    }
	    if (strncasecmp(argv[0], "DTR", strlen(argv[0])) == 0) {
#ifdef TIOCM_DTR
		if (flag) {
		    control |= TIOCM_DTR;
		} else {
		    control &= ~TIOCM_DTR;
		}
#else /* !TIOCM_DTR */
		UNSUPPORTED_OPTION("-ttycontrol DTR");
		return TCL_ERROR;
#endif /* TIOCM_DTR */
	    } else if (strncasecmp(argv[0], "RTS", strlen(argv[0])) == 0) {
#ifdef TIOCM_RTS
		if (flag) {
		    control |= TIOCM_RTS;
		} else {
		    control &= ~TIOCM_RTS;
		}
#else /* !TIOCM_RTS*/
		UNSUPPORTED_OPTION("-ttycontrol RTS");
		return TCL_ERROR;
#endif /* TIOCM_RTS*/
	    } else if (strncasecmp(argv[0], "BREAK", strlen(argv[0])) == 0) {
#ifdef SETBREAK
		SETBREAK(fsPtr->fd, flag);
#else /* !SETBREAK */
		UNSUPPORTED_OPTION("-ttycontrol BREAK");
		return TCL_ERROR;
#endif /* SETBREAK */
	    } else {
		if (interp) {
		    Tcl_AppendResult(interp,
			    "bad signal for -ttycontrol: must be ",
			    "DTR, RTS or BREAK", (char *) NULL);
		}
		return TCL_ERROR;
	    }
	    argc -= 2, argv += 2;
	} /* while (argc > 1) */

	SETCONTROL(fsPtr->fd, &control);
	return TCL_OK;
    }

    return Tcl_BadChannelOption(interp, optionName,
	    "mode handshake timeout ttycontrol xchar ");

#else /* !USE_TERMIOS */
    return Tcl_BadChannelOption(interp, optionName, "mode");
#endif /* USE_TERMIOS */
}

/*
 *----------------------------------------------------------------------
 *
 * TtyGetOptionProc --
 *
 *	Gets a mode associated with an IO channel. If the optionName arg
 *	is non NULL, retrieves the value of that option. If the optionName
 *	arg is NULL, retrieves a list of alternating option names and
 *	values for the given channel.
 *
 * Results:
 *	A standard Tcl result. Also sets the supplied DString to the
 *	string value of the option(s) returned.
 *
 * Side effects:
 *	The string returned by this function is in static storage and
 *	may be reused at any time subsequent to the call.
 *	Sets Error message if needed (by calling Tcl_BadChannelOption).
 *
 *----------------------------------------------------------------------
 */

static int		
TtyGetOptionProc(instanceData, interp, optionName, dsPtr)
    ClientData instanceData;	/* File state. */
    Tcl_Interp *interp;		/* For error reporting - can be NULL. */
    CONST char *optionName;	/* Option to get. */
    Tcl_DString *dsPtr;		/* Where to store value(s). */
{
    FileState *fsPtr = (FileState *) instanceData;
    unsigned int len;
    char buf[3 * TCL_INTEGER_SPACE + 16];
    TtyAttrs tty;
    int valid = 0;  /* flag if valid option parsed */

    if (optionName == NULL) {
	len = 0;
    } else {
	len = strlen(optionName);
    }
    if (len == 0) {
	Tcl_DStringAppendElement(dsPtr, "-mode");
    }
    if (len==0 || (len>2 && strncmp(optionName, "-mode", len)==0)) {
	valid = 1;
	TtyGetAttributes(fsPtr->fd, &tty);
	sprintf(buf, "%d,%c,%d,%d", tty.baud, tty.parity, tty.data, tty.stop);
	Tcl_DStringAppendElement(dsPtr, buf);
    }

#ifdef USE_TERMIOS
    /*
     * get option -xchar
     */
    if (len == 0) {
	Tcl_DStringAppendElement(dsPtr, "-xchar");
	Tcl_DStringStartSublist(dsPtr);
    }
    if (len==0 || (len>1 && strncmp(optionName, "-xchar", len)==0)) {
	IOSTATE iostate;
	valid = 1;

	GETIOSTATE(fsPtr->fd, &iostate);
	sprintf(buf, "%c", iostate.c_cc[VSTART]);
	Tcl_DStringAppendElement(dsPtr, buf);
	sprintf(buf, "%c", iostate.c_cc[VSTOP]);
	Tcl_DStringAppendElement(dsPtr, buf);
    }
    if (len == 0) {
	Tcl_DStringEndSublist(dsPtr);
    }

    /*
     * get option -queue
     * option is readonly and returned by [fconfigure chan -queue]
     * but not returned by unnamed [fconfigure chan]
     */
    if ((len > 1) && (strncmp(optionName, "-queue", len) == 0)) {
	int inQueue=0, outQueue=0;
	int inBuffered, outBuffered;
	valid = 1;
#ifdef GETREADQUEUE
	GETREADQUEUE(fsPtr->fd, inQueue);
#endif /* GETREADQUEUE */
#ifdef GETWRITEQUEUE
	GETWRITEQUEUE(fsPtr->fd, outQueue);
#endif /* GETWRITEQUEUE */
	inBuffered  = Tcl_InputBuffered(fsPtr->channel);
	outBuffered = Tcl_OutputBuffered(fsPtr->channel);

	sprintf(buf, "%d", inBuffered+inQueue);
	Tcl_DStringAppendElement(dsPtr, buf);
	sprintf(buf, "%d", outBuffered+outQueue);
	Tcl_DStringAppendElement(dsPtr, buf);
    }

    /*
     * get option -ttystatus
     * option is readonly and returned by [fconfigure chan -ttystatus]
     * but not returned by unnamed [fconfigure chan]
     */
    if ((len > 4) && (strncmp(optionName, "-ttystatus", len) == 0)) {
	int status;
	valid = 1;
	GETCONTROL(fsPtr->fd, &status);
	TtyModemStatusStr(status, dsPtr);
    }
#endif /* USE_TERMIOS */

    if (valid) {
	return TCL_OK;
    } else {
	return Tcl_BadChannelOption(interp, optionName,
#ifdef USE_TERMIOS
	    "mode queue ttystatus xchar");
#else /* !USE_TERMIOS */
	    "mode");
#endif /* USE_TERMIOS */
    }
}

#undef DIRECT_BAUD
#ifdef B4800
#   if (B4800 == 4800)
#	define DIRECT_BAUD
#   endif /* B4800 == 4800 */
#endif /* B4800 */

#ifdef DIRECT_BAUD
#   define TtyGetSpeed(baud)   ((unsigned) (baud))
#   define TtyGetBaud(speed)   ((int) (speed))
#else /* !DIRECT_BAUD */

static struct {int baud; unsigned long speed;} speeds[] = {
#ifdef B0
    {0, B0},
#endif
#ifdef B50
    {50, B50},
#endif
#ifdef B75
    {75, B75},
#endif
#ifdef B110
    {110, B110},
#endif
#ifdef B134
    {134, B134},
#endif
#ifdef B150
    {150, B150},
#endif
#ifdef B200
    {200, B200},
#endif
#ifdef B300
    {300, B300},
#endif
#ifdef B600
    {600, B600},
#endif
#ifdef B1200
    {1200, B1200},
#endif
#ifdef B1800
    {1800, B1800},
#endif
#ifdef B2400
    {2400, B2400},
#endif
#ifdef B4800
    {4800, B4800},
#endif
#ifdef B9600
    {9600, B9600},
#endif
#ifdef B14400
    {14400, B14400},
#endif
#ifdef B19200
    {19200, B19200},
#endif
#ifdef EXTA
    {19200, EXTA},
#endif
#ifdef B28800
    {28800, B28800},
#endif
#ifdef B38400
    {38400, B38400},
#endif
#ifdef EXTB
    {38400, EXTB},
#endif
#ifdef B57600
    {57600, B57600},
#endif
#ifdef _B57600
    {57600, _B57600},
#endif
#ifdef B76800
    {76800, B76800},
#endif
#ifdef B115200
    {115200, B115200},
#endif
#ifdef _B115200
    {115200, _B115200},
#endif
#ifdef B153600
    {153600, B153600},
#endif
#ifdef B230400
    {230400, B230400},
#endif
#ifdef B307200
    {307200, B307200},
#endif
#ifdef B460800
    {460800, B460800},
#endif
    {-1, 0}
};

/*
 *---------------------------------------------------------------------------
 *
 * TtyGetSpeed --
 *
 *	Given a baud rate, get the mask value that should be stored in
 *	the termios, termio, or sgttyb structure in order to select that
 *	baud rate.
 *
 * Results:
 *	As above.
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
 */

static unsigned long
TtyGetSpeed(baud)
    int baud;			/* The baud rate to look up. */
{
    int bestIdx, bestDiff, i, diff;

    bestIdx = 0;
    bestDiff = 1000000;

    /*
     * If the baud rate does not correspond to one of the known mask values,
     * choose the mask value whose baud rate is closest to the specified
     * baud rate.
     */

    for (i = 0; speeds[i].baud >= 0; i++) {
	diff = speeds[i].baud - baud;
	if (diff < 0) {
	    diff = -diff;
	}
	if (diff < bestDiff) {
	    bestIdx = i;
	    bestDiff = diff;
	}
    }
    return speeds[bestIdx].speed;
}

/*
 *---------------------------------------------------------------------------
 *
 * TtyGetBaud --
 *
 *	Given a speed mask value from a termios, termio, or sgttyb
 *	structure, get the baus rate that corresponds to that mask value.
 *
 * Results:
 *	As above.  If the mask value was not recognized, 0 is returned.
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
 */

static int
TtyGetBaud(speed)
    unsigned long speed;	/* Speed mask value to look up. */
{
    int i;

    for (i = 0; speeds[i].baud >= 0; i++) {
	if (speeds[i].speed == speed) {
	    return speeds[i].baud;
	}
    }
    return 0;
}

#endif /* !DIRECT_BAUD */


/*
 *---------------------------------------------------------------------------
 *
 * TtyGetAttributes --
 *
 *	Get the current attributes of the specified serial device.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
 */

static void
TtyGetAttributes(fd, ttyPtr)
    int fd;			/* Open file descriptor for serial port to
				 * be queried. */
    TtyAttrs *ttyPtr;		/* Buffer filled with serial port
				 * attributes. */
{
    IOSTATE iostate;
    int baud, parity, data, stop;

    GETIOSTATE(fd, &iostate);

#ifdef USE_TERMIOS
    baud = TtyGetBaud(cfgetospeed(&iostate));

    parity = 'n';
#ifdef PAREXT
    switch ((int) (iostate.c_cflag & (PARENB | PARODD | PAREXT))) {
	case PARENB		      : parity = 'e'; break;
	case PARENB | PARODD	      : parity = 'o'; break;
	case PARENB |	       PAREXT : parity = 's'; break;
	case PARENB | PARODD | PAREXT : parity = 'm'; break;
    }
#else /* !PAREXT */
    switch ((int) (iostate.c_cflag & (PARENB | PARODD))) {
	case PARENB		      : parity = 'e'; break;
	case PARENB | PARODD	      : parity = 'o'; break;
    }
#endif /* !PAREXT */

    data = iostate.c_cflag & CSIZE;
    data = (data == CS5) ? 5 : (data == CS6) ? 6 : (data == CS7) ? 7 : 8;

    stop = (iostate.c_cflag & CSTOPB) ? 2 : 1;
#endif /* USE_TERMIOS */

#ifdef USE_TERMIO
    baud = TtyGetBaud(iostate.c_cflag & CBAUD);

    parity = 'n';
    switch (iostate.c_cflag & (PARENB | PARODD | PAREXT)) {
	case PARENB		      : parity = 'e'; break;
	case PARENB | PARODD	      : parity = 'o'; break;
	case PARENB |	       PAREXT : parity = 's'; break;
	case PARENB | PARODD | PAREXT : parity = 'm'; break;
    }

    data = iostate.c_cflag & CSIZE;
    data = (data == CS5) ? 5 : (data == CS6) ? 6 : (data == CS7) ? 7 : 8;

    stop = (iostate.c_cflag & CSTOPB) ? 2 : 1;
#endif /* USE_TERMIO */

#ifdef USE_SGTTY
    baud = TtyGetBaud(iostate.sg_ospeed);

    parity = 'n';
    if (iostate.sg_flags & EVENP) {
	parity = 'e';
    } else if (iostate.sg_flags & ODDP) {
	parity = 'o';
    }

    data = (iostate.sg_flags & (EVENP | ODDP)) ? 7 : 8;

    stop = 1;
#endif /* USE_SGTTY */

    ttyPtr->baud    = baud;
    ttyPtr->parity  = parity;
    ttyPtr->data    = data;
    ttyPtr->stop    = stop;
}

/*
 *---------------------------------------------------------------------------
 *
 * TtySetAttributes --
 *
 *	Set the current attributes of the specified serial device. 
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
 */

static void
TtySetAttributes(fd, ttyPtr)
    int fd;			/* Open file descriptor for serial port to
				 * be modified. */
    TtyAttrs *ttyPtr;		/* Buffer containing new attributes for
				 * serial port. */
{
    IOSTATE iostate;

#ifdef USE_TERMIOS
    int parity, data, flag;

    GETIOSTATE(fd, &iostate);
    cfsetospeed(&iostate, TtyGetSpeed(ttyPtr->baud));
    cfsetispeed(&iostate, TtyGetSpeed(ttyPtr->baud));

    flag = 0;
    parity = ttyPtr->parity;
    if (parity != 'n') {
	flag |= PARENB;
#ifdef PAREXT
	iostate.c_cflag &= ~PAREXT;
	if ((parity == 'm') || (parity == 's')) {
	    flag |= PAREXT;
	}
#endif /* PAREXT */
	if ((parity == 'm') || (parity == 'o')) {
	    flag |= PARODD;
	}
    }
    data = ttyPtr->data;
    flag |= (data == 5) ? CS5 : (data == 6) ? CS6 : (data == 7) ? CS7 : CS8;
    if (ttyPtr->stop == 2) {
	flag |= CSTOPB;
    }

    iostate.c_cflag &= ~(PARENB | PARODD | CSIZE | CSTOPB);
    iostate.c_cflag |= flag;

#endif	/* USE_TERMIOS */

#ifdef USE_TERMIO
    int parity, data, flag;

    GETIOSTATE(fd, &iostate);
    iostate.c_cflag &= ~CBAUD;
    iostate.c_cflag |= TtyGetSpeed(ttyPtr->baud);

    flag = 0;
    parity = ttyPtr->parity;
    if (parity != 'n') {
	flag |= PARENB;
	if ((parity == 'm') || (parity == 's')) {
	    flag |= PAREXT;
	}
	if ((parity == 'm') || (parity == 'o')) {
	    flag |= PARODD;
	}
    }
    data = ttyPtr->data;
    flag |= (data == 5) ? CS5 : (data == 6) ? CS6 : (data == 7) ? CS7 : CS8;
    if (ttyPtr->stop == 2) {
	flag |= CSTOPB;
    }

    iostate.c_cflag &= ~(PARENB | PARODD | PAREXT | CSIZE | CSTOPB);
    iostate.c_cflag |= flag;

#endif	/* USE_TERMIO */

#ifdef USE_SGTTY
    int parity;

    GETIOSTATE(fd, &iostate);
    iostate.sg_ospeed = TtyGetSpeed(ttyPtr->baud);
    iostate.sg_ispeed = TtyGetSpeed(ttyPtr->baud);

    parity = ttyPtr->parity;
    if (parity == 'e') {
	iostate.sg_flags &= ~ODDP;
	iostate.sg_flags |= EVENP;
    } else if (parity == 'o') {
	iostate.sg_flags &= ~EVENP;
	iostate.sg_flags |= ODDP;
    }
#endif	/* USE_SGTTY */

    SETIOSTATE(fd, &iostate);
}

/*
 *---------------------------------------------------------------------------
 *
 * TtyParseMode --
 *
 *	Parse the "-mode" argument to the fconfigure command.  The argument
 *	is of the form baud,parity,data,stop.
 *
 * Results:
 *	The return value is TCL_OK if the argument was successfully
 *	parsed, TCL_ERROR otherwise.  If TCL_ERROR is returned, an
 *	error message is left in the interp's result (if interp is non-NULL).
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
 */

static int
TtyParseMode(interp, mode, speedPtr, parityPtr, dataPtr, stopPtr)
    Tcl_Interp *interp;		/* If non-NULL, interp for error return. */
    CONST char *mode;		/* Mode string to be parsed. */
    int *speedPtr;		/* Filled with baud rate from mode string. */
    int *parityPtr;		/* Filled with parity from mode string. */
    int *dataPtr;		/* Filled with data bits from mode string. */
    int *stopPtr;		/* Filled with stop bits from mode string. */
{
    int i, end;
    char parity;
    static char *bad = "bad value for -mode";

    i = sscanf(mode, "%d,%c,%d,%d%n", speedPtr, &parity, dataPtr,
	    stopPtr, &end);
    if ((i != 4) || (mode[end] != '\0')) {
	if (interp != NULL) {
	    Tcl_AppendResult(interp, bad, ": should be baud,parity,data,stop",
		    NULL);
	}
	return TCL_ERROR;
    }
    /*
     * Only allow setting mark/space parity on platforms that support it
     * Make sure to allow for the case where strchr is a macro.
     * [Bug: 5089]
     */
    if (
#if defined(PAREXT) || defined(USE_TERMIO)
	strchr("noems", parity) == NULL
#else
	strchr("noe", parity) == NULL
#endif /* PAREXT|USE_TERMIO */
	) {
	if (interp != NULL) {
	    Tcl_AppendResult(interp, bad,
#if defined(PAREXT) || defined(USE_TERMIO)
		    " parity: should be n, o, e, m, or s",
#else
		    " parity: should be n, o, or e",
#endif /* PAREXT|USE_TERMIO */
		    NULL);
	}
	return TCL_ERROR;
    }
    *parityPtr = parity;
    if ((*dataPtr < 5) || (*dataPtr > 8)) {
	if (interp != NULL) {
	    Tcl_AppendResult(interp, bad, " data: should be 5, 6, 7, or 8",
		    NULL);
	}
	return TCL_ERROR;
    }
    if ((*stopPtr < 0) || (*stopPtr > 2)) {
	if (interp != NULL) {
	    Tcl_AppendResult(interp, bad, " stop: should be 1 or 2", NULL);
	}
	return TCL_ERROR;
    }
    return TCL_OK;
}

/*
 *---------------------------------------------------------------------------
 *
 * TtyInit --
 *
 *	Given file descriptor that refers to a serial port, 
 *	initialize the serial port to a set of sane values so that
 *	Tcl can talk to a device located on the serial port.
 *	Note that no initialization happens if the initialize flag
 *	is not set; this is necessary for the correct handling of
 *	UNIX console TTYs at startup.
 *
 * Results:
 *	A pointer to a FileState suitable for use with Tcl_CreateChannel
 *	and the ttyChannelType structure.
 *
 * Side effects:
 *	Serial device initialized to non-blocking raw mode, similar to
 *	sockets (if initialize flag is non-zero.)  All other modes can
 *	be simulated on top of this in Tcl.
 *
 *---------------------------------------------------------------------------
 */

static FileState *
TtyInit(fd, initialize)
    int fd;			/* Open file descriptor for serial port to
				 * be initialized. */
    int initialize;
{
    TtyState *ttyPtr;

    ttyPtr = (TtyState *) ckalloc((unsigned) sizeof(TtyState));
    GETIOSTATE(fd, &ttyPtr->savedState);
    ttyPtr->stateUpdated = 0;
    if (initialize) {
	IOSTATE iostate = ttyPtr->savedState;

#if defined(USE_TERMIOS) || defined(USE_TERMIO)
	if (iostate.c_iflag != IGNBRK ||
		iostate.c_oflag != 0 ||
		iostate.c_lflag != 0 ||
		iostate.c_cflag & CREAD ||
		iostate.c_cc[VMIN] != 1 ||
		iostate.c_cc[VTIME] != 0) {
	    ttyPtr->stateUpdated = 1;
	}
	iostate.c_iflag = IGNBRK;
	iostate.c_oflag = 0;
	iostate.c_lflag = 0;
	iostate.c_cflag |= CREAD;
	iostate.c_cc[VMIN] = 1;
	iostate.c_cc[VTIME] = 0;
#endif	/* USE_TERMIOS|USE_TERMIO */

#ifdef USE_SGTTY
	if ((iostate.sg_flags & (EVENP | ODDP)) ||
		!(iostate.sg_flags & RAW)) {
	    ttyPtr->stateUpdated = 1;
	}
	iostate.sg_flags &= (EVENP | ODDP);
	iostate.sg_flags |= RAW;
#endif	/* USE_SGTTY */

	/*
	 * Only update if we're changing anything to avoid possible
	 * blocking.
	 */
	if (ttyPtr->stateUpdated) {
	    SETIOSTATE(fd, &iostate);
	}
    }

    return &ttyPtr->fs;
}
#endif	/* SUPPORTS_TTY */

/*
 *----------------------------------------------------------------------
 *
 * TclpOpenFileChannel --
 *
 *	Open an file based channel on Unix systems.
 *
 * Results:
 *	The new channel or NULL. If NULL, the output argument
 *	errorCodePtr is set to a POSIX error and an error message is
 *	left in the interp's result if interp is not NULL.
 *
 * Side effects:
 *	May open the channel and may cause creation of a file on the
 *	file system.
 *
 *----------------------------------------------------------------------
 */

Tcl_Channel
TclpOpenFileChannel(interp, pathPtr, mode, permissions)
    Tcl_Interp *interp;			/* Interpreter for error reporting;
					 * can be NULL. */
    Tcl_Obj *pathPtr;			/* Name of file to open. */
    int mode;				/* POSIX open mode. */
    int permissions;			/* If the open involves creating a
					 * file, with what modes to create
					 * it? */
{
    int fd, channelPermissions;
    FileState *fsPtr;
    CONST char *native, *translation;
    char channelName[16 + TCL_INTEGER_SPACE];
    Tcl_ChannelType *channelTypePtr;
#ifdef SUPPORTS_TTY
    int ctl_tty;
#endif /* SUPPORTS_TTY */
#ifdef DEPRECATED
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
#endif /* DEPRECATED */

    switch (mode & (O_RDONLY | O_WRONLY | O_RDWR)) {
	case O_RDONLY:
	    channelPermissions = TCL_READABLE;
	    break;
	case O_WRONLY:
	    channelPermissions = TCL_WRITABLE;
	    break;
	case O_RDWR:
	    channelPermissions = (TCL_READABLE | TCL_WRITABLE);
	    break;
	default:
	    /*
	     * This may occurr if modeString was "", for example.
	     */
	    panic("TclpOpenFileChannel: invalid mode value");
	    return NULL;
    }

    native = Tcl_FSGetNativePath(pathPtr);
    if (native == NULL) {
	return NULL;
    }
    fd = TclOSopen(native, mode, permissions);
#ifdef SUPPORTS_TTY
    ctl_tty = (strcmp (native, "/dev/tty") == 0);
#endif /* SUPPORTS_TTY */

    if (fd < 0) {
	if (interp != (Tcl_Interp *) NULL) {
	    Tcl_AppendResult(interp, "couldn't open \"", 
		    Tcl_GetString(pathPtr), "\": ",
		    Tcl_PosixError(interp), (char *) NULL);
	}
	return NULL;
    }

    /*
     * Set close-on-exec flag on the fd so that child processes will not
     * inherit this fd.
     */

    fcntl(fd, F_SETFD, FD_CLOEXEC);

    sprintf(channelName, "file%d", fd);

#ifdef SUPPORTS_TTY
    if (!ctl_tty && isatty(fd)) {
	/*
	 * Initialize the serial port to a set of sane parameters.
	 * Especially important if the remote device is set to echo and
	 * the serial port driver was also set to echo -- as soon as a char
	 * were sent to the serial port, the remote device would echo it,
	 * then the serial driver would echo it back to the device, etc.
	 */

	translation = "auto crlf";
	channelTypePtr = &ttyChannelType;
	fsPtr = TtyInit(fd, 1);
    } else 
#endif	/* SUPPORTS_TTY */
    {
	translation = NULL;
	channelTypePtr = &fileChannelType;
	fsPtr = (FileState *) ckalloc((unsigned) sizeof(FileState));
    }

#ifdef DEPRECATED
    fsPtr->nextPtr = tsdPtr->firstFilePtr;
    tsdPtr->firstFilePtr = fsPtr;
#endif /* DEPRECATED */
    fsPtr->validMask = channelPermissions | TCL_EXCEPTION;
    fsPtr->fd = fd;

    fsPtr->channel = Tcl_CreateChannel(channelTypePtr, channelName,
	    (ClientData) fsPtr, channelPermissions);

    if (translation != NULL) {
	/*
	 * Gotcha.  Most modems need a "\r" at the end of the command
	 * sequence.  If you just send "at\n", the modem will not respond
	 * with "OK" because it never got a "\r" to actually invoke the
	 * command.  So, by default, newlines are translated to "\r\n" on
	 * output to avoid "bug" reports that the serial port isn't working.
	 */

	if (Tcl_SetChannelOption(interp, fsPtr->channel, "-translation",
		translation) != TCL_OK) {
	    Tcl_Close(NULL, fsPtr->channel);
	    return NULL;
	}
    }

    return fsPtr->channel;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_MakeFileChannel --
 *
 *	Makes a Tcl_Channel from an existing OS level file handle.
 *
 * Results:
 *	The Tcl_Channel created around the preexisting OS level file handle.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_Channel
Tcl_MakeFileChannel(handle, mode)
    ClientData handle;		/* OS level handle. */
    int mode;			/* ORed combination of TCL_READABLE and
				 * TCL_WRITABLE to indicate file mode. */
{
    FileState *fsPtr;
    char channelName[16 + TCL_INTEGER_SPACE];
    int fd = (int) handle;
    Tcl_ChannelType *channelTypePtr;
#ifdef DEPRECATED
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
#endif /* DEPRECATED */
    int socketType = 0;
    socklen_t argLength = sizeof(int);

    if (mode == 0) {
	return NULL;
    }


    /*
     * Look to see if a channel with this fd and the same mode already exists.
     * If the fd is used, but the mode doesn't match, return NULL.
     */

#ifdef DEPRECATED
    for (fsPtr = tsdPtr->firstFilePtr; fsPtr != NULL; fsPtr = fsPtr->nextPtr) {
	if (fsPtr->fd == fd) {
	    return ((mode|TCL_EXCEPTION) == fsPtr->validMask) ?
		    fsPtr->channel : NULL;
	}
    }
#endif /* DEPRECATED */

#ifdef SUPPORTS_TTY
    if (isatty(fd)) {
	fsPtr = TtyInit(fd, 0);
	channelTypePtr = &ttyChannelType;
	sprintf(channelName, "serial%d", fd);
    } else
#endif /* SUPPORTS_TTY */
    if (getsockopt(fd, SOL_SOCKET, SO_TYPE, (VOID *)&socketType,
		   &argLength) == 0  &&	 socketType == SOCK_STREAM) {
	/*
	 * The mode parameter gets lost here, unfortunately.
	 */
	return Tcl_MakeTcpClientChannel((ClientData) fd);
    } else {
	channelTypePtr = &fileChannelType;
	fsPtr = (FileState *) ckalloc((unsigned) sizeof(FileState));
	sprintf(channelName, "file%d", fd);
    }

#ifdef DEPRECATED
    fsPtr->nextPtr = tsdPtr->firstFilePtr;
    tsdPtr->firstFilePtr = fsPtr;
#endif /* DEPRECATED */
    fsPtr->fd = fd;
    fsPtr->validMask = mode | TCL_EXCEPTION;
    fsPtr->channel = Tcl_CreateChannel(channelTypePtr, channelName,
	    (ClientData) fsPtr, mode);

    return fsPtr->channel;
}

/*
 *----------------------------------------------------------------------
 *
 * TcpBlockModeProc --
 *
 *	This procedure is invoked by the generic IO level to set blocking
 *	and nonblocking mode on a TCP socket based channel.
 *
 * Results:
 *	0 if successful, errno when failed.
 *
 * Side effects:
 *	Sets the device into blocking or nonblocking mode.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
static int
TcpBlockModeProc(instanceData, mode)
    ClientData instanceData;		/* Socket state. */
    int mode;				/* The mode to set. Can be one of
					 * TCL_MODE_BLOCKING or
					 * TCL_MODE_NONBLOCKING. */
{
    TcpState *statePtr = (TcpState *) instanceData;
    int setting;

#ifndef USE_FIONBIO
    setting = fcntl(statePtr->fd, F_GETFL);
    if (mode == TCL_MODE_BLOCKING) {
	statePtr->flags &= (~(TCP_ASYNC_SOCKET));
	setting &= (~(O_NONBLOCK));
    } else {
	statePtr->flags |= TCP_ASYNC_SOCKET;
	setting |= O_NONBLOCK;
    }
    if (fcntl(statePtr->fd, F_SETFL, setting) < 0) {
	return errno;
    }
#else /* USE_FIONBIO */
    if (mode == TCL_MODE_BLOCKING) {
	statePtr->flags &= (~(TCP_ASYNC_SOCKET));
	setting = 0;
	if (ioctl(statePtr->fd, (int) FIONBIO, &setting) == -1) {
	    return errno;
	}
    } else {
	statePtr->flags |= TCP_ASYNC_SOCKET;
	setting = 1;
	if (ioctl(statePtr->fd, (int) FIONBIO, &setting) == -1) {
	    return errno;
	}
    }
#endif /* !USE_FIONBIO */

    return 0;
}

/*
 *----------------------------------------------------------------------
 *
 * WaitForConnect --
 *
 *	Waits for a connection on an asynchronously opened socket to
 *	be completed.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The socket is connected after this function returns.
 *
 *----------------------------------------------------------------------
 */

static int
WaitForConnect(statePtr, errorCodePtr)
    TcpState *statePtr;		/* State of the socket. */
    int *errorCodePtr;		/* Where to store errors? */
{
    int timeOut;		/* How long to wait. */
    int state;			/* Of calling TclWaitForFile. */
    int flags;			/* fcntl flags for the socket. */

    /*
     * If an asynchronous connect is in progress, attempt to wait for it
     * to complete before reading.
     */

    if (statePtr->flags & TCP_ASYNC_CONNECT) {
	if (statePtr->flags & TCP_ASYNC_SOCKET) {
	    timeOut = 0;
	} else {
	    timeOut = -1;
	}
	errno = 0;
	state = TclUnixWaitForFile(statePtr->fd,
		TCL_WRITABLE | TCL_EXCEPTION, timeOut);
	if (!(statePtr->flags & TCP_ASYNC_SOCKET)) {
#ifndef USE_FIONBIO
	    flags = fcntl(statePtr->fd, F_GETFL);
	    flags &= (~(O_NONBLOCK));
	    (void) fcntl(statePtr->fd, F_SETFL, flags);
#else /* USE_FIONBIO */
	    flags = 0;
	    (void) ioctl(statePtr->fd, FIONBIO, &flags);
#endif /* !USE_FIONBIO */
	}
	if (state & TCL_EXCEPTION) {
	    return -1;
	}
	if (state & TCL_WRITABLE) {
	    statePtr->flags &= (~(TCP_ASYNC_CONNECT));
	} else if (timeOut == 0) {
	    *errorCodePtr = errno = EWOULDBLOCK;
	    return -1;
	}
    }
    return 0;
}

/*
 *----------------------------------------------------------------------
 *
 * TcpInputProc --
 *
 *	This procedure is invoked by the generic IO level to read input
 *	from a TCP socket based channel.
 *
 *	NOTE: We cannot share code with FilePipeInputProc because here
 *	we must use recv to obtain the input from the channel, not read.
 *
 * Results:
 *	The number of bytes read is returned or -1 on error. An output
 *	argument contains the POSIX error code on error, or zero if no
 *	error occurred.
 *
 * Side effects:
 *	Reads input from the input device of the channel.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
static int
TcpInputProc(instanceData, buf, bufSize, errorCodePtr)
    ClientData instanceData;		/* Socket state. */
    char *buf;				/* Where to store data read. */
    int bufSize;			/* How much space is available
					 * in the buffer? */
    int *errorCodePtr;			/* Where to store error code. */
{
    TcpState *statePtr = (TcpState *) instanceData;
    int bytesRead, state;

    *errorCodePtr = 0;
    state = WaitForConnect(statePtr, errorCodePtr);
    if (state != 0) {
	return -1;
    }
    bytesRead = recv(statePtr->fd, buf, (size_t) bufSize, 0);
    if (bytesRead > -1) {
	return bytesRead;
    }
    if (errno == ECONNRESET) {
	/*
	 * Turn ECONNRESET into a soft EOF condition.
	 */

	return 0;
    }
    *errorCodePtr = errno;
    return -1;
}

/*
 *----------------------------------------------------------------------
 *
 * TcpOutputProc --
 *
 *	This procedure is invoked by the generic IO level to write output
 *	to a TCP socket based channel.
 *
 *	NOTE: We cannot share code with FilePipeOutputProc because here
 *	we must use send, not write, to get reliable error reporting.
 *
 * Results:
 *	The number of bytes written is returned. An output argument is
 *	set to a POSIX error code if an error occurred, or zero.
 *
 * Side effects:
 *	Writes output on the output device of the channel.
 *
 *----------------------------------------------------------------------
 */

static int
TcpOutputProc(instanceData, buf, toWrite, errorCodePtr)
    ClientData instanceData;		/* Socket state. */
    CONST char *buf;			/* The data buffer. */
    int toWrite;			/* How many bytes to write? */
    int *errorCodePtr;			/* Where to store error code. */
{
    TcpState *statePtr = (TcpState *) instanceData;
    int written;
    int state;				/* Of waiting for connection. */

    *errorCodePtr = 0;
    state = WaitForConnect(statePtr, errorCodePtr);
    if (state != 0) {
	return -1;
    }
    written = send(statePtr->fd, buf, (size_t) toWrite, 0);
    if (written > -1) {
	return written;
    }
    *errorCodePtr = errno;
    return -1;
}

/*
 *----------------------------------------------------------------------
 *
 * TcpCloseProc --
 *
 *	This procedure is invoked by the generic IO level to perform
 *	channel-type-specific cleanup when a TCP socket based channel
 *	is closed.
 *
 * Results:
 *	0 if successful, the value of errno if failed.
 *
 * Side effects:
 *	Closes the socket of the channel.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
static int
TcpCloseProc(instanceData, interp)
    ClientData instanceData;	/* The socket to close. */
    Tcl_Interp *interp;		/* For error reporting - unused. */
{
    TcpState *statePtr = (TcpState *) instanceData;
    int errorCode = 0;

    /*
     * Delete a file handler that may be active for this socket if this
     * is a server socket - the file handler was created automatically
     * by Tcl as part of the mechanism to accept new client connections.
     * Channel handlers are already deleted in the generic IO channel
     * closing code that called this function, so we do not have to
     * delete them here.
     */

    Tcl_DeleteFileHandler(statePtr->fd);

    if (close(statePtr->fd) < 0) {
	errorCode = errno;
    }
    ckfree((char *) statePtr);

    return errorCode;
}

/*
 *----------------------------------------------------------------------
 *
 * TcpGetOptionProc --
 *
 *	Computes an option value for a TCP socket based channel, or a
 *	list of all options and their values.
 *
 *	Note: This code is based on code contributed by John Haxby.
 *
 * Results:
 *	A standard Tcl result. The value of the specified option or a
 *	list of all options and their values is returned in the
 *	supplied DString. Sets Error message if needed.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static int
TcpGetOptionProc(instanceData, interp, optionName, dsPtr)
    ClientData instanceData;	 /* Socket state. */
    Tcl_Interp *interp;		 /* For error reporting - can be NULL. */
    CONST char *optionName;	 /* Name of the option to
				  * retrieve the value for, or
				  * NULL to get all options and
				  * their values. */
    Tcl_DString *dsPtr;		 /* Where to store the computed
				  * value; initialized by caller. */
{
    TcpState *statePtr = (TcpState *) instanceData;
    struct sockaddr_in sockname;
    struct sockaddr_in peername;
    struct hostent *hostEntPtr;
    socklen_t size = sizeof(struct sockaddr_in);
    size_t len = 0;
    char buf[TCL_INTEGER_SPACE];

    if (optionName != (char *) NULL) {
	len = strlen(optionName);
    }

    if ((len > 1) && (optionName[1] == 'e') &&
	    (strncmp(optionName, "-error", len) == 0)) {
	socklen_t optlen = sizeof(int);
	int err, ret;

	ret = getsockopt(statePtr->fd, SOL_SOCKET, SO_ERROR,
		(char *)&err, &optlen);
	if (ret < 0) {
	    err = errno;
	}
	if (err != 0) {
	    Tcl_DStringAppend(dsPtr, Tcl_ErrnoMsg(err), -1);
	}
	return TCL_OK;
    }

    if ((len == 0) ||
	    ((len > 1) && (optionName[1] == 'p') &&
		    (strncmp(optionName, "-peername", len) == 0))) {
	if (getpeername(statePtr->fd, (struct sockaddr *) &peername,
		&size) >= 0) {
	    if (len == 0) {
		Tcl_DStringAppendElement(dsPtr, "-peername");
		Tcl_DStringStartSublist(dsPtr);
	    }
	    Tcl_DStringAppendElement(dsPtr, inet_ntoa(peername.sin_addr));
	    hostEntPtr = gethostbyaddr(			/* INTL: Native. */
		    (char *) &peername.sin_addr,
		    sizeof(peername.sin_addr), AF_INET);
	    if (hostEntPtr != NULL) {
		Tcl_DString ds;

		Tcl_ExternalToUtfDString(NULL, hostEntPtr->h_name, -1, &ds);
		Tcl_DStringAppendElement(dsPtr, Tcl_DStringValue(&ds));
	    } else {
		Tcl_DStringAppendElement(dsPtr, inet_ntoa(peername.sin_addr));
	    }
	    TclFormatInt(buf, ntohs(peername.sin_port));
	    Tcl_DStringAppendElement(dsPtr, buf);
	    if (len == 0) {
		Tcl_DStringEndSublist(dsPtr);
	    } else {
		return TCL_OK;
	    }
	} else {
	    /*
	     * getpeername failed - but if we were asked for all the options
	     * (len==0), don't flag an error at that point because it could
	     * be an fconfigure request on a server socket. (which have
	     * no peer). same must be done on win&mac.
	     */

	    if (len) {
		if (interp) {
		    Tcl_AppendResult(interp, "can't get peername: ",
			    Tcl_PosixError(interp), (char *) NULL);
		}
		return TCL_ERROR;
	    }
	}
    }

    if ((len == 0) ||
	    ((len > 1) && (optionName[1] == 's') &&
	    (strncmp(optionName, "-sockname", len) == 0))) {
	if (getsockname(statePtr->fd, (struct sockaddr *) &sockname,
		&size) >= 0) {
	    if (len == 0) {
		Tcl_DStringAppendElement(dsPtr, "-sockname");
		Tcl_DStringStartSublist(dsPtr);
	    }
	    Tcl_DStringAppendElement(dsPtr, inet_ntoa(sockname.sin_addr));
	    hostEntPtr = gethostbyaddr(			/* INTL: Native. */
		    (char *) &sockname.sin_addr,
		    sizeof(sockname.sin_addr), AF_INET);
	    if (hostEntPtr != (struct hostent *) NULL) {
		Tcl_DString ds;

		Tcl_ExternalToUtfDString(NULL, hostEntPtr->h_name, -1, &ds);
		Tcl_DStringAppendElement(dsPtr, Tcl_DStringValue(&ds));
	    } else {
		Tcl_DStringAppendElement(dsPtr, inet_ntoa(sockname.sin_addr));
	    }
	    TclFormatInt(buf, ntohs(sockname.sin_port));
	    Tcl_DStringAppendElement(dsPtr, buf);
	    if (len == 0) {
		Tcl_DStringEndSublist(dsPtr);
	    } else {
		return TCL_OK;
	    }
	} else {
	    if (interp) {
		Tcl_AppendResult(interp, "can't get sockname: ",
			Tcl_PosixError(interp), (char *) NULL);
	    }
	    return TCL_ERROR;
	}
    }

    if (len > 0) {
	return Tcl_BadChannelOption(interp, optionName, "peername sockname");
    }

    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * TcpWatchProc --
 *
 *	Initialize the notifier to watch the fd from this channel.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Sets up the notifier so that a future event on the channel will
 *	be seen by Tcl.
 *
 *----------------------------------------------------------------------
 */

static void
TcpWatchProc(instanceData, mask)
    ClientData instanceData;		/* The socket state. */
    int mask;				/* Events of interest; an OR-ed
					 * combination of TCL_READABLE,
					 * TCL_WRITABLE and TCL_EXCEPTION. */
{
    TcpState *statePtr = (TcpState *) instanceData;

    /*
     * Make sure we don't mess with server sockets since they will never
     * be readable or writable at the Tcl level.  This keeps Tcl scripts
     * from interfering with the -accept behavior.
     */

    if (!statePtr->acceptProc) {
	if (mask) {
	    Tcl_CreateFileHandler(statePtr->fd, mask,
		    (Tcl_FileProc *) Tcl_NotifyChannel,
		    (ClientData) statePtr->channel);
	} else {
	    Tcl_DeleteFileHandler(statePtr->fd);
	}
    }
}

/*
 *----------------------------------------------------------------------
 *
 * TcpGetHandleProc --
 *
 *	Called from Tcl_GetChannelHandle to retrieve OS handles from inside
 *	a TCP socket based channel.
 *
 * Results:
 *	Returns TCL_OK with the fd in handlePtr, or TCL_ERROR if
 *	there is no handle for the specified direction. 
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
static int
TcpGetHandleProc(instanceData, direction, handlePtr)
    ClientData instanceData;	/* The socket state. */
    int direction;		/* Not used. */
    ClientData *handlePtr;	/* Where to store the handle.  */
{
    TcpState *statePtr = (TcpState *) instanceData;

    *handlePtr = (ClientData)statePtr->fd;
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * CreateSocket --
 *
 *	This function opens a new socket in client or server mode
 *	and initializes the TcpState structure.
 *
 * Results:
 *	Returns a new TcpState, or NULL with an error in the interp's
 *	result, if interp is not NULL.
 *
 * Side effects:
 *	Opens a socket.
 *
 *----------------------------------------------------------------------
 */

static TcpState *
CreateSocket(interp, port, host, server, myaddr, myport, async)
    Tcl_Interp *interp;		/* For error reporting; can be NULL. */
    int port;			/* Port number to open. */
    CONST char *host;		/* Name of host on which to open port.
				 * NULL implies INADDR_ANY */
    int server;			/* 1 if socket should be a server socket,
				 * else 0 for a client socket. */
    CONST char *myaddr;		/* Optional client-side address */
    int myport;			/* Optional client-side port */
    int async;			/* If nonzero and creating a client socket,
				 * attempt to do an async connect. Otherwise
				 * do a synchronous connect or bind. */
{
    int status, sock, asyncConnect, curState, origState;
    struct sockaddr_in sockaddr;	/* socket address */
    struct sockaddr_in mysockaddr;	/* Socket address for client */
    TcpState *statePtr;

    sock = -1;
    origState = 0;
    if (! CreateSocketAddress(&sockaddr, host, port)) {
	goto addressError;
    }
    if ((myaddr != NULL || myport != 0) &&
	    ! CreateSocketAddress(&mysockaddr, myaddr, myport)) {
	goto addressError;
    }

    sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock < 0) {
	goto addressError;
    }

    /*
     * Set the close-on-exec flag so that the socket will not get
     * inherited by child processes.
     */

    fcntl(sock, F_SETFD, FD_CLOEXEC);

    /*
     * Set kernel space buffering
     */

    TclSockMinimumBuffers(sock, SOCKET_BUFSIZE);

    asyncConnect = 0;
    status = 0;
    if (server) {
	/*
	 * Set up to reuse server addresses automatically and bind to the
	 * specified port.
	 */

	status = 1;
	(void) setsockopt(sock, SOL_SOCKET, SO_REUSEADDR, (char *) &status,
		sizeof(status));
	status = bind(sock, (struct sockaddr *) &sockaddr,
		sizeof(struct sockaddr));
	if (status != -1) {
	    status = listen(sock, SOMAXCONN);
	} 
    } else {
	if (myaddr != NULL || myport != 0) { 
	    curState = 1;
	    (void) setsockopt(sock, SOL_SOCKET, SO_REUSEADDR,
		    (char *) &curState, sizeof(curState));
	    status = bind(sock, (struct sockaddr *) &mysockaddr,
		    sizeof(struct sockaddr));
	    if (status < 0) {
		goto bindError;
	    }
	}

	/*
	 * Attempt to connect. The connect may fail at present with an
	 * EINPROGRESS but at a later time it will complete. The caller
	 * will set up a file handler on the socket if she is interested in
	 * being informed when the connect completes.
	 */

	if (async) {
#ifndef USE_FIONBIO
	    origState = fcntl(sock, F_GETFL);
	    curState = origState | O_NONBLOCK;
	    status = fcntl(sock, F_SETFL, curState);
#else /* USE_FIONBIO */
	    curState = 1;
	    status = ioctl(sock, FIONBIO, &curState);
#endif /* !USE_FIONBIO */
	} else {
	    status = 0;
	}
	if (status > -1) {
	    status = connect(sock, (struct sockaddr *) &sockaddr,
		    sizeof(sockaddr));
	    if (status < 0) {
		if (errno == EINPROGRESS) {
		    asyncConnect = 1;
		    status = 0;
		}
	    } else {
		/*
		 * Here we are if the connect succeeds. In case of an
		 * asynchronous connect we have to reset the channel to
		 * blocking mode.  This appears to happen not very often,
		 * but e.g. on a HP 9000/800 under HP-UX B.11.00 we enter
		 * this stage. [Bug: 4388]
		 */
		if (async) {
#ifndef USE_FIONBIO
		    origState = fcntl(sock, F_GETFL);
		    curState = origState & ~(O_NONBLOCK);
		    status = fcntl(sock, F_SETFL, curState);
#else /* USE_FIONBIO */
		    curState = 0;
		    status = ioctl(sock, FIONBIO, &curState);
#endif /* !USE_FIONBIO */
		}
	    }
	}
    }

bindError:
    if (status < 0) {
	if (interp != NULL) {
	    Tcl_AppendResult(interp, "couldn't open socket: ",
		    Tcl_PosixError(interp), (char *) NULL);
	}
	if (sock != -1) {
	    close(sock);
	}
	return NULL;
    }

    /*
     * Allocate a new TcpState for this socket.
     */

    statePtr = (TcpState *) ckalloc((unsigned) sizeof(TcpState));
    statePtr->flags = 0;
    if (asyncConnect) {
	statePtr->flags = TCP_ASYNC_CONNECT;
    }
    statePtr->fd = sock;

    return statePtr;

addressError:
    if (sock != -1) {
	close(sock);
    }
    if (interp != NULL) {
	Tcl_AppendResult(interp, "couldn't open socket: ",
		Tcl_PosixError(interp), (char *) NULL);
    }
    return NULL;
}

/*
 *----------------------------------------------------------------------
 *
 * CreateSocketAddress --
 *
 *	This function initializes a sockaddr structure for a host and port.
 *
 * Results:
 *	1 if the host was valid, 0 if the host could not be converted to
 *	an IP address.
 *
 * Side effects:
 *	Fills in the *sockaddrPtr structure.
 *
 *----------------------------------------------------------------------
 */

static int
CreateSocketAddress(sockaddrPtr, host, port)
    struct sockaddr_in *sockaddrPtr;	/* Socket address */
    CONST char *host;			/* Host.  NULL implies INADDR_ANY */
    int port;				/* Port number */
{
    struct hostent *hostent;		/* Host database entry */
    struct in_addr addr;		/* For 64/32 bit madness */

    (void) memset((VOID *) sockaddrPtr, '\0', sizeof(struct sockaddr_in));
    sockaddrPtr->sin_family = AF_INET;
    sockaddrPtr->sin_port = htons((unsigned short) (port & 0xFFFF));
    if (host == NULL) {
	addr.s_addr = INADDR_ANY;
    } else {
	Tcl_DString ds;
	CONST char *native;

	if (host == NULL) {
	    native = NULL;
	} else {
	    native = Tcl_UtfToExternalDString(NULL, host, -1, &ds);
	}
	addr.s_addr = inet_addr(native);		/* INTL: Native. */
	/*
	 * This is 0xFFFFFFFF to ensure that it compares as a 32bit -1
	 * on either 32 or 64 bits systems.
	 */
	if (addr.s_addr == 0xFFFFFFFF) {
	    hostent = gethostbyname(native);		/* INTL: Native. */
	    if (hostent != NULL) {
		memcpy((VOID *) &addr,
			(VOID *) hostent->h_addr_list[0],
			(size_t) hostent->h_length);
	    } else {
#ifdef	EHOSTUNREACH
		errno = EHOSTUNREACH;
#else /* !EHOSTUNREACH */
#ifdef ENXIO
		errno = ENXIO;
#endif /* ENXIO */
#endif /* EHOSTUNREACH */
		if (native != NULL) {
		    Tcl_DStringFree(&ds);
		}
		return 0;	/* error */
	    }
	}
	if (native != NULL) {
	    Tcl_DStringFree(&ds);
	}
    }

    /*
     * NOTE: On 64 bit machines the assignment below is rumored to not
     * do the right thing. Please report errors related to this if you
     * observe incorrect behavior on 64 bit machines such as DEC Alphas.
     * Should we modify this code to do an explicit memcpy?
     */

    sockaddrPtr->sin_addr.s_addr = addr.s_addr;
    return 1;	/* Success. */
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_OpenTcpClient --
 *
 *	Opens a TCP client socket and creates a channel around it.
 *
 * Results:
 *	The channel or NULL if failed.	An error message is returned
 *	in the interpreter on failure.
 *
 * Side effects:
 *	Opens a client socket and creates a new channel.
 *
 *----------------------------------------------------------------------
 */

Tcl_Channel
Tcl_OpenTcpClient(interp, port, host, myaddr, myport, async)
    Tcl_Interp *interp;			/* For error reporting; can be NULL. */
    int port;				/* Port number to open. */
    CONST char *host;			/* Host on which to open port. */
    CONST char *myaddr;			/* Client-side address */
    int myport;				/* Client-side port */
    int async;				/* If nonzero, attempt to do an
					 * asynchronous connect. Otherwise
					 * we do a blocking connect. */
{
    TcpState *statePtr;
    char channelName[16 + TCL_INTEGER_SPACE];

    /*
     * Create a new client socket and wrap it in a channel.
     */

    statePtr = CreateSocket(interp, port, host, 0, myaddr, myport, async);
    if (statePtr == NULL) {
	return NULL;
    }

    statePtr->acceptProc = NULL;
    statePtr->acceptProcData = (ClientData) NULL;

    sprintf(channelName, "sock%d", statePtr->fd);

    statePtr->channel = Tcl_CreateChannel(&tcpChannelType, channelName,
	    (ClientData) statePtr, (TCL_READABLE | TCL_WRITABLE));
    if (Tcl_SetChannelOption(interp, statePtr->channel, "-translation",
	    "auto crlf") == TCL_ERROR) {
	Tcl_Close((Tcl_Interp *) NULL, statePtr->channel);
	return NULL;
    }
    return statePtr->channel;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_MakeTcpClientChannel --
 *
 *	Creates a Tcl_Channel from an existing client TCP socket.
 *
 * Results:
 *	The Tcl_Channel wrapped around the preexisting TCP socket.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_Channel
Tcl_MakeTcpClientChannel(sock)
    ClientData sock;		/* The socket to wrap up into a channel. */
{
    TcpState *statePtr;
    char channelName[16 + TCL_INTEGER_SPACE];

    statePtr = (TcpState *) ckalloc((unsigned) sizeof(TcpState));
    statePtr->fd = (int) sock;
    statePtr->flags = 0;
    statePtr->acceptProc = NULL;
    statePtr->acceptProcData = (ClientData) NULL;

    sprintf(channelName, "sock%d", statePtr->fd);

    statePtr->channel = Tcl_CreateChannel(&tcpChannelType, channelName,
	    (ClientData) statePtr, (TCL_READABLE | TCL_WRITABLE));
    if (Tcl_SetChannelOption((Tcl_Interp *) NULL, statePtr->channel,
	    "-translation", "auto crlf") == TCL_ERROR) {
	Tcl_Close((Tcl_Interp *) NULL, statePtr->channel);
	return NULL;
    }
    return statePtr->channel;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_OpenTcpServer --
 *
 *	Opens a TCP server socket and creates a channel around it.
 *
 * Results:
 *	The channel or NULL if failed. If an error occurred, an
 *	error message is left in the interp's result if interp is
 *	not NULL.
 *
 * Side effects:
 *	Opens a server socket and creates a new channel.
 *
 *----------------------------------------------------------------------
 */

Tcl_Channel
Tcl_OpenTcpServer(interp, port, myHost, acceptProc, acceptProcData)
    Tcl_Interp *interp;			/* For error reporting - may be
					 * NULL. */
    int port;				/* Port number to open. */
    CONST char *myHost;			/* Name of local host. */
    Tcl_TcpAcceptProc *acceptProc;	/* Callback for accepting connections
					 * from new clients. */
    ClientData acceptProcData;		/* Data for the callback. */
{
    TcpState *statePtr;
    char channelName[16 + TCL_INTEGER_SPACE];

    /*
     * Create a new client socket and wrap it in a channel.
     */

    statePtr = CreateSocket(interp, port, myHost, 1, NULL, 0, 0);
    if (statePtr == NULL) {
	return NULL;
    }

    statePtr->acceptProc = acceptProc;
    statePtr->acceptProcData = acceptProcData;

    /*
     * Set up the callback mechanism for accepting connections
     * from new clients.
     */

    Tcl_CreateFileHandler(statePtr->fd, TCL_READABLE, TcpAccept,
	    (ClientData) statePtr);
    sprintf(channelName, "sock%d", statePtr->fd);
    statePtr->channel = Tcl_CreateChannel(&tcpChannelType, channelName,
	    (ClientData) statePtr, 0);
    return statePtr->channel;
}

/*
 *----------------------------------------------------------------------
 *
 * TcpAccept --
 *	Accept a TCP socket connection.	 This is called by the event loop.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Creates a new connection socket. Calls the registered callback
 *	for the connection acceptance mechanism.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
static void
TcpAccept(data, mask)
    ClientData data;			/* Callback token. */
    int mask;				/* Not used. */
{
    TcpState *sockState;		/* Client data of server socket. */
    int newsock;			/* The new client socket */
    TcpState *newSockState;		/* State for new socket. */
    struct sockaddr_in addr;		/* The remote address */
    socklen_t len;				/* For accept interface */
    char channelName[16 + TCL_INTEGER_SPACE];

    sockState = (TcpState *) data;

    len = sizeof(struct sockaddr_in);
    newsock = accept(sockState->fd, (struct sockaddr *) &addr, &len);
    if (newsock < 0) {
	return;
    }

    /*
     * Set close-on-exec flag to prevent the newly accepted socket from
     * being inherited by child processes.
     */

    (void) fcntl(newsock, F_SETFD, FD_CLOEXEC);

    newSockState = (TcpState *) ckalloc((unsigned) sizeof(TcpState));

    newSockState->flags = 0;
    newSockState->fd = newsock;
    newSockState->acceptProc = NULL;
    newSockState->acceptProcData = NULL;

    sprintf(channelName, "sock%d", newsock);
    newSockState->channel = Tcl_CreateChannel(&tcpChannelType, channelName,
	    (ClientData) newSockState, (TCL_READABLE | TCL_WRITABLE));

    Tcl_SetChannelOption(NULL, newSockState->channel, "-translation",
	    "auto crlf");

    if (sockState->acceptProc != NULL) {
	(*sockState->acceptProc)(sockState->acceptProcData,
		newSockState->channel, inet_ntoa(addr.sin_addr),
		ntohs(addr.sin_port));
    }
}

/*
 *----------------------------------------------------------------------
 *
 * TclpGetDefaultStdChannel --
 *
 *	Creates channels for standard input, standard output or standard
 *	error output if they do not already exist.
 *
 * Results:
 *	Returns the specified default standard channel, or NULL.
 *
 * Side effects:
 *	May cause the creation of a standard channel and the underlying
 *	file.
 *
 *----------------------------------------------------------------------
 */

Tcl_Channel
TclpGetDefaultStdChannel(type)
    int type;			/* One of TCL_STDIN, TCL_STDOUT, TCL_STDERR. */
{
    Tcl_Channel channel = NULL;
    int fd = 0;			/* Initializations needed to prevent */
    int mode = 0;		/* compiler warning (used before set). */
    char *bufMode = NULL;

    /*
     * Some #def's to make the code a little clearer!
     */
#define ZERO_OFFSET	((Tcl_SeekOffset) 0)
#define ERROR_OFFSET	((Tcl_SeekOffset) -1)

    switch (type) {
	case TCL_STDIN:
	    if ((TclOSseek(0, ZERO_OFFSET, SEEK_CUR) == ERROR_OFFSET)
		    && (errno == EBADF)) {
		return (Tcl_Channel) NULL;
	    }
	    fd = 0;
	    mode = TCL_READABLE;
	    bufMode = "line";
	    break;
	case TCL_STDOUT:
	    if ((TclOSseek(1, ZERO_OFFSET, SEEK_CUR) == ERROR_OFFSET)
		    && (errno == EBADF)) {
		return (Tcl_Channel) NULL;
	    }
	    fd = 1;
	    mode = TCL_WRITABLE;
	    bufMode = "line";
	    break;
	case TCL_STDERR:
	    if ((TclOSseek(2, ZERO_OFFSET, SEEK_CUR) == ERROR_OFFSET)
		    && (errno == EBADF)) {
		return (Tcl_Channel) NULL;
	    }
	    fd = 2;
	    mode = TCL_WRITABLE;
	    bufMode = "none";
	    break;
	default:
	    panic("TclGetDefaultStdChannel: Unexpected channel type");
	    break;
    }

#undef ZERO_OFFSET
#undef ERROR_OFFSET

    channel = Tcl_MakeFileChannel((ClientData) fd, mode);
    if (channel == NULL) {
	return NULL;
    }

    /*
     * Set up the normal channel options for stdio handles.
     */

    if (Tcl_GetChannelType(channel) == &fileChannelType) {
	Tcl_SetChannelOption(NULL, channel, "-translation", "auto");
    } else {
	Tcl_SetChannelOption(NULL, channel, "-translation", "auto crlf");
    }
    Tcl_SetChannelOption(NULL, channel, "-buffering", bufMode);
    return channel;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetOpenFile --
 *
 *	Given a name of a channel registered in the given interpreter,
 *	returns a FILE * for it.
 *
 * Results:
 *	A standard Tcl result. If the channel is registered in the given
 *	interpreter and it is managed by the "file" channel driver, and
 *	it is open for the requested mode, then the output parameter
 *	filePtr is set to a FILE * for the underlying file. On error, the
 *	filePtr is not set, TCL_ERROR is returned and an error message is
 *	left in the interp's result.
 *
 * Side effects:
 *	May invoke fdopen to create the FILE * for the requested file.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_GetOpenFile(interp, string, forWriting, checkUsage, filePtr)
    Tcl_Interp *interp;		/* Interpreter in which to find file. */
    CONST char *string;		/* String that identifies file. */
    int forWriting;		/* 1 means the file is going to be used
				 * for writing, 0 means for reading. */
    int checkUsage;		/* 1 means verify that the file was opened
				 * in a mode that allows the access specified
				 * by "forWriting". Ignored, we always
				 * check that the channel is open for the
				 * requested mode. */
    ClientData *filePtr;	/* Store pointer to FILE structure here. */
{
    Tcl_Channel chan;
    int chanMode;
    Tcl_ChannelType *chanTypePtr;
    ClientData data;
    int fd;
    FILE *f;

    chan = Tcl_GetChannel(interp, string, &chanMode);
    if (chan == (Tcl_Channel) NULL) {
	return TCL_ERROR;
    }
    if ((forWriting) && ((chanMode & TCL_WRITABLE) == 0)) {
	Tcl_AppendResult(interp,
		"\"", string, "\" wasn't opened for writing", (char *) NULL);
	return TCL_ERROR;
    } else if ((!(forWriting)) && ((chanMode & TCL_READABLE) == 0)) {
	Tcl_AppendResult(interp,
		"\"", string, "\" wasn't opened for reading", (char *) NULL);
	return TCL_ERROR;
    }

    /*
     * We allow creating a FILE * out of file based, pipe based and socket
     * based channels. We currently do not allow any other channel types,
     * because it is likely that stdio will not know what to do with them.
     */

    chanTypePtr = Tcl_GetChannelType(chan);
    if ((chanTypePtr == &fileChannelType)
#ifdef SUPPORTS_TTY
	    || (chanTypePtr == &ttyChannelType)
#endif /* SUPPORTS_TTY */
	    || (chanTypePtr == &tcpChannelType)
	    || (strcmp(chanTypePtr->typeName, "pipe") == 0)) {
	if (Tcl_GetChannelHandle(chan,
		(forWriting ? TCL_WRITABLE : TCL_READABLE),
		(ClientData*) &data) == TCL_OK) {
	    fd = (int) data;

	    /*
	     * The call to fdopen below is probably dangerous, since it will
	     * truncate an existing file if the file is being opened
	     * for writing....
	     */

	    f = fdopen(fd, (forWriting ? "w" : "r"));
	    if (f == NULL) {
		Tcl_AppendResult(interp, "cannot get a FILE * for \"", string,
			"\"", (char *) NULL);
		return TCL_ERROR;
	    }
	    *filePtr = (ClientData) f;
	    return TCL_OK;
	}
    }

    Tcl_AppendResult(interp, "\"", string,
	    "\" cannot be used to get a FILE *", (char *) NULL);
    return TCL_ERROR;	     
}

/*
 *----------------------------------------------------------------------
 *
 * TclUnixWaitForFile --
 *
 *	This procedure waits synchronously for a file to become readable
 *	or writable, with an optional timeout.
 *
 * Results:
 *	The return value is an OR'ed combination of TCL_READABLE,
 *	TCL_WRITABLE, and TCL_EXCEPTION, indicating the conditions
 *	that are present on file at the time of the return.  This
 *	procedure will not return until either "timeout" milliseconds
 *	have elapsed or at least one of the conditions given by mask
 *	has occurred for file (a return value of 0 means that a timeout
 *	occurred).  No normal events will be serviced during the
 *	execution of this procedure.
 *
 * Side effects:
 *	Time passes.
 *
 *----------------------------------------------------------------------
 */

int
TclUnixWaitForFile(fd, mask, timeout)
    int fd;			/* Handle for file on which to wait. */
    int mask;			/* What to wait for: OR'ed combination of
				 * TCL_READABLE, TCL_WRITABLE, and
				 * TCL_EXCEPTION. */
    int timeout;		/* Maximum amount of time to wait for one
				 * of the conditions in mask to occur, in
				 * milliseconds.  A value of 0 means don't
				 * wait at all, and a value of -1 means
				 * wait forever. */
{
    Tcl_Time abortTime, now;
    struct timeval blockTime, *timeoutPtr;
    int index, bit, numFound, result = 0;
    fd_mask readyMasks[3*MASK_SIZE];
				/* This array reflects the readable/writable
				 * conditions that were found to exist by the
				 * last call to select. */

    /*
     * If there is a non-zero finite timeout, compute the time when
     * we give up.
     */

    if (timeout > 0) {
	Tcl_GetTime(&now);
	abortTime.sec = now.sec + timeout/1000;
	abortTime.usec = now.usec + (timeout%1000)*1000;
	if (abortTime.usec >= 1000000) {
	    abortTime.usec -= 1000000;
	    abortTime.sec += 1;
	}
	timeoutPtr = &blockTime;
    } else if (timeout == 0) {
	timeoutPtr = &blockTime;
	blockTime.tv_sec = 0;
	blockTime.tv_usec = 0;
    } else {
	timeoutPtr = NULL;
    }

    /*
     * Initialize the ready masks and compute the mask offsets.
     */

    if (fd >= FD_SETSIZE) {
	panic("TclWaitForFile can't handle file id %d", fd);
    }
    memset((VOID *) readyMasks, 0, 3*MASK_SIZE*sizeof(fd_mask));
    index = fd/(NBBY*sizeof(fd_mask));
    bit = 1 << (fd%(NBBY*sizeof(fd_mask)));

    /*
     * Loop in a mini-event loop of our own, waiting for either the
     * file to become ready or a timeout to occur.
     */

    while (1) {
	if (timeout > 0) {
	    blockTime.tv_sec = abortTime.sec - now.sec;
	    blockTime.tv_usec = abortTime.usec - now.usec;
	    if (blockTime.tv_usec < 0) {
		blockTime.tv_sec -= 1;
		blockTime.tv_usec += 1000000;
	    }
	    if (blockTime.tv_sec < 0) {
		blockTime.tv_sec = 0;
		blockTime.tv_usec = 0;
	    }
	}

	/*
	 * Set the appropriate bit in the ready masks for the fd.
	 */

	if (mask & TCL_READABLE) {
	    readyMasks[index] |= bit;
	}
	if (mask & TCL_WRITABLE) {
	    (readyMasks+MASK_SIZE)[index] |= bit;
	}
	if (mask & TCL_EXCEPTION) {
	    (readyMasks+2*(MASK_SIZE))[index] |= bit;
	}

	/*
	 * Wait for the event or a timeout.
	 */

	numFound = select(fd+1, (SELECT_MASK *) &readyMasks[0],
		(SELECT_MASK *) &readyMasks[MASK_SIZE],
		(SELECT_MASK *) &readyMasks[2*MASK_SIZE], timeoutPtr);
	if (numFound == 1) {
	    if (readyMasks[index] & bit) {
		result |= TCL_READABLE;
	    }
	    if ((readyMasks+MASK_SIZE)[index] & bit) {
		result |= TCL_WRITABLE;
	    }
	    if ((readyMasks+2*(MASK_SIZE))[index] & bit) {
		result |= TCL_EXCEPTION;
	    }
	    result &= mask;
	    if (result) {
		break;
	    }
	}
	if (timeout == 0) {
	    break;
	}

	/*
	 * The select returned early, so we need to recompute the timeout.
	 */

	Tcl_GetTime(&now);
	if ((abortTime.sec < now.sec)
		|| ((abortTime.sec == now.sec)
		&& (abortTime.usec <= now.usec))) {
	    break;
	}
    }
    return result;
}
@


1.4
log
@touched all sources to ease next import
@
text
@d13 1
a13 1
 * RCS: @@(#) $Id: tclUnixChan.c,v 1.6.8.2 2000/09/15 16:58:22 spolk Exp $
d16 2
a17 2
#include	"tclInt.h"	/* Internal definitions for Tcl. */
#include	"tclPort.h"	/* Portability features for Tcl. */
d20 1
a20 1
 * sys/ioctl.h has already been included by tclPort.h.  Including termios.h
d48 6
d57 41
d99 1
d106 1
d115 1
d129 1
d132 1
d144 3
a146 1
				 * descriptor.  Must be the first field. */
d155 1
a155 1
 
d165 7
d177 1
a177 1
    
d182 1
d213 8
a220 8
#ifndef	SOMAXCONN
#define SOMAXCONN	100
#endif

#if	(SOMAXCONN < 100)
#undef	SOMAXCONN
#define	SOMAXCONN	100
#endif
d234 2
a235 2
			    int port, char *host, int server,
			    char *myaddr, int myport, int async));
d238 1
a238 1
			    char *host, int port));
d240 1
a240 1
    			    ClientData instanceData, int mode));
d244 1
a244 1
		            int direction, ClientData *handlePtr));
d246 1
a246 1
		            char *buf, int toRead, int *errorCode));
d248 2
a249 2
			    ClientData instanceData, char *buf, int toWrite,
                            int *errorCode));
d252 2
d255 1
a255 1
		            int mask));
d258 1
a258 1
        		    int mode));
d262 1
a262 1
		            int direction, ClientData *handlePtr));
d264 1
a264 1
			    Tcl_Interp *interp, char *optionName,
d267 1
a267 1
		            char *buf, int toRead,  int *errorCode));
d269 1
a269 1
		            char *buf, int toWrite, int *errorCode));
d271 1
a271 1
		            int mask));
d278 1
a278 1
			    Tcl_Interp *interp, char *optionName,
d280 5
a284 1
static FileState *	TtyInit _ANSI_ARGS_((int fd));
d291 2
a292 2
			    Tcl_Interp *interp, char *optionName, 
			    char *value));
d295 1
a295 1
		            int *errorCodePtr));
d302 15
a316 10
    "file",				/* Type name. */
    FileBlockModeProc,			/* Set blocking/nonblocking mode.*/
    FileCloseProc,			/* Close proc. */
    FileInputProc,			/* Input proc. */
    FileOutputProc,			/* Output proc. */
    FileSeekProc,			/* Seek proc. */
    NULL,				/* Set option proc. */
    NULL,				/* Get option proc. */
    FileWatchProc,			/* Initialize notifier. */
    FileGetHandleProc,			/* Get OS handles out of channel. */
d326 18
a343 10
    "tty",				/* Type name. */
    FileBlockModeProc,			/* Set blocking/nonblocking mode.*/
    TtyCloseProc,			/* Close proc. */
    FileInputProc,			/* Input proc. */
    FileOutputProc,			/* Output proc. */
    NULL,				/* Seek proc. */
    TtySetOptionProc,			/* Set option proc. */
    TtyGetOptionProc,			/* Get option proc. */
    FileWatchProc,			/* Initialize notifier. */
    FileGetHandleProc,			/* Get OS handles out of channel. */
d353 14
a366 10
    "tcp",				/* Type name. */
    TcpBlockModeProc,			/* Set blocking/nonblocking mode.*/
    TcpCloseProc,			/* Close proc. */
    TcpInputProc,			/* Input proc. */
    TcpOutputProc,			/* Output proc. */
    NULL,				/* Seek proc. */
    NULL,				/* Set option proc. */
    TcpGetOptionProc,			/* Get option proc. */
    TcpWatchProc,			/* Initialize notifier. */
    TcpGetHandleProc,			/* Get OS handles out of channel. */
d392 2
a393 2
                                         * TCL_MODE_BLOCKING or
                                         * TCL_MODE_NONBLOCKING. */
d409 1
a409 1
#else
d418 1
a418 1
#endif
d445 1
a445 1
                                         * in the buffer? */
d450 1
a450 1
                                         * read from the input device? */
d453 1
a453 1
    
d463 1
a463 1
        return bytesRead;
d479 1
a479 1
 *	output argument	contains a POSIX error code if an error occurred,
d491 1
a491 1
    char *buf;				/* The data buffer. */
d499 11
d512 1
a512 1
        return written;
d541 2
a543 1
    int errorCode = 0;
d545 1
a545 1

d558 1
d566 1
d593 5
a597 7
    ClientData instanceData;			/* File state. */
    long offset;				/* Offset to seek to. */
    int mode;					/* Relative to where
                                                 * should we seek? Can be
                                                 * one of SEEK_START,
                                                 * SEEK_SET or SEEK_END. */
    int *errorCodePtr;				/* To store error code. */
d600 1
a600 1
    int newLoc;
d602 60
a661 1
    newLoc = lseek(fsPtr->fd, (off_t) offset, mode);
d688 2
a689 2
                                         * combination of TCL_READABLE,
                                         * TCL_WRITABLE and TCL_EXCEPTION. */
d757 1
a757 1
 *	Restores the settings and closes the device of the channel.
a760 1

d766 43
a808 1
    TtyState *ttyPtr;
d810 51
a860 3
    ttyPtr = (TtyState *) instanceData;
    SETIOSTATE(ttyPtr->fs.fd, &ttyPtr->savedState);
    return FileCloseProc(instanceData, interp);
d862 1
d877 1
a877 1
 *      Sets Error message if needed (by calling Tcl_BadChannelOption).
d886 2
a887 2
    char *optionName;		/* Which option to set? */
    char *value;		/* New value for option. */
d890 1
a890 1
    unsigned int len;
d892 5
d899 6
a904 1
    if ((len > 1) && (strncmp(optionName, "-mode", len) == 0)) {
d914 146
a1060 2
    } else {
	return Tcl_BadChannelOption(interp, optionName, "mode");
d1062 7
d1088 1
a1088 1
 *      Sets Error message if needed (by calling Tcl_BadChannelOption).
d1097 1
a1097 1
    char *optionName;		/* Option to get. */
d1104 1
a1106 1
	Tcl_DStringAppendElement(dsPtr, "-mode");
d1111 5
a1115 2
    if ((len == 0) || 
	    ((len > 1) && (strncmp(optionName, "-mode", len) == 0))) {
d1119 62
d1183 6
a1188 1
	return Tcl_BadChannelOption(interp, optionName, "mode");
d1196 2
a1197 2
#   endif
#endif
d1202 1
a1202 1
#else
d1318 1
a1318 1
    
d1321 1
a1321 1
    
d1363 1
a1363 1
    
d1372 1
a1372 1
#endif	/* !DIRECT_BAUD */
d1390 1
a1390 1
 
d1405 1
a1405 1
    
d1410 1
a1410 1
	case PARENB | PARODD	      :	parity = 'o'; break;
d1412 1
a1412 1
	case PARENB | PARODD | PAREXT :	parity = 'm'; break;
d1414 1
a1414 1
#else	/* !PAREXT */
d1417 1
a1417 1
	case PARENB | PARODD	      :	parity = 'o'; break;
d1419 1
a1419 1
#endif	/* !PAREXT */
d1425 1
a1425 1
#endif	/* USE_TERMIOS */
d1433 1
a1433 1
	case PARENB | PARODD	      :	parity = 'o'; break;
d1435 1
a1435 1
	case PARENB | PARODD | PAREXT :	parity = 'm'; break;
d1442 1
a1442 1
#endif	/* USE_TERMIO */
d1457 1
a1457 1
#endif	/* USE_SGTTY */
d1480 1
a1480 1
 
d1506 1
a1506 1
#endif
d1589 1
a1589 1
 
d1622 1
a1622 1
#endif
d1630 1
a1630 1
#endif
d1660 3
d1665 2
a1666 1
 *	None.
d1670 2
a1671 1
 *	sockets.  All other modes can be simulated on top of this in Tcl.
d1677 1
a1677 1
TtyInit(fd)
d1680 1
a1681 1
    IOSTATE iostate;
d1686 20
a1705 20

    iostate = ttyPtr->savedState;

#ifdef USE_TERMIOS
    iostate.c_iflag = IGNBRK;
    iostate.c_oflag = 0;
    iostate.c_lflag = 0;
    iostate.c_cflag |= CREAD;
    iostate.c_cc[VMIN] = 1;
    iostate.c_cc[VTIME] = 0;
#endif	/* USE_TERMIOS */

#ifdef USE_TERMIO
    iostate.c_iflag = IGNBRK;
    iostate.c_oflag = 0;
    iostate.c_lflag = 0;
    iostate.c_cflag |= CREAD;
    iostate.c_cc[VMIN] = 1;
    iostate.c_cc[VTIME] = 0;
#endif	/* USE_TERMIO */
d1708 6
a1713 2
    iostate.sg_flags &= (EVENP | ODDP);
    iostate.sg_flags |= RAW;
d1716 8
a1723 1
    SETIOSTATE(fd, &iostate);
d1749 1
a1749 1
TclpOpenFileChannel(interp, fileName, modeString, permissions)
d1751 3
a1753 4
                                         * can be NULL. */
    char *fileName;			/* Name of file to open. */
    char *modeString;			/* A list of POSIX open modes or
                                         * a string such as "rw". */
d1755 2
a1756 2
                                         * file, with what modes to create
                                         * it? */
d1758 1
a1758 1
    int fd, seekFlag, mode, channelPermissions;
d1760 1
a1760 1
    char *native, *translation;
a1761 1
    Tcl_DString ds, buffer;
d1763 4
d1768 1
a1769 4
    mode = TclGetOpenMode(interp, modeString, &seekFlag);
    if (mode == -1) {
        return NULL;
    }
d1781 3
a1783 3
            /*
             * This may occurr if modeString was "", for example.
             */
d1788 1
a1788 1
    native = Tcl_TranslateFileName(interp, fileName, &buffer);
d1792 4
a1795 4
    native = Tcl_UtfToExternalDString(NULL, native, -1, &ds);
    fd = open(native, mode, permissions);		/* INTL: Native. */
    Tcl_DStringFree(&ds);    
    Tcl_DStringFree(&buffer);
d1798 6
a1803 5
        if (interp != (Tcl_Interp *) NULL) {
            Tcl_AppendResult(interp, "couldn't open \"", fileName, "\": ",
                    Tcl_PosixError(interp), (char *) NULL);
        }
        return NULL;
d1810 1
a1810 1
  
d1812 1
a1812 1
    
d1814 1
a1814 1
    
d1816 1
a1816 1
    if (isatty(fd)) {
d1824 1
a1824 1
	 
d1827 1
a1827 1
	fsPtr = TtyInit(fd);
d1836 1
d1839 1
d1842 1
a1842 1
    
a1845 11
    if (seekFlag) {
        if (Tcl_Seek(fsPtr->channel, 0, SEEK_END) < 0) {
            if (interp != (Tcl_Interp *) NULL) {
                Tcl_AppendResult(interp, "couldn't seek to end of file on \"",
                        channelName, "\": ", Tcl_PosixError(interp), NULL);
            }
            Tcl_Close(NULL, fsPtr->channel);
            return NULL;
        }
    }

d1854 1
a1854 1
	 
d1885 1
a1885 1
                                 * TCL_WRITABLE to indicate file mode. */
d1890 2
d1893 3
d1898 1
a1898 1
        return NULL;
a1900 1
    sprintf(channelName, "file%d", fd);
d1906 2
a1907 1
    
d1914 20
d1935 1
a1935 1
    fsPtr = (FileState *) ckalloc((unsigned) sizeof(FileState));
d1938 1
a1938 1

d1941 3
a1943 3
    fsPtr->channel = Tcl_CreateChannel(&fileChannelType, channelName,
            (ClientData) fsPtr, mode);
    
d1969 2
a1970 2
                                         * TCL_MODE_BLOCKING or
                                         * TCL_MODE_NONBLOCKING. */
d1974 2
a1975 2
    
#ifndef	USE_FIONBIO
d1978 2
a1979 2
        statePtr->flags &= (~(TCP_ASYNC_SOCKET));
        setting &= (~(O_NONBLOCK));
d1981 2
a1982 2
        statePtr->flags |= TCP_ASYNC_SOCKET;
        setting |= O_NONBLOCK;
d1985 1
a1985 1
        return errno;
d1987 1
a1987 3
#endif

#ifdef	USE_FIONBIO
d1989 5
a1993 5
        statePtr->flags &= (~(TCP_ASYNC_SOCKET));
        setting = 0;
        if (ioctl(statePtr->fd, (int) FIONBIO, &setting) == -1) {
            return errno;
        }
d1995 5
a1999 5
        statePtr->flags |= TCP_ASYNC_SOCKET;
        setting = 1;
        if (ioctl(statePtr->fd, (int) FIONBIO, &setting) == -1) {
            return errno;
        }
d2001 1
a2001 1
#endif
d2036 1
a2036 1
    
d2038 7
a2044 7
        if (statePtr->flags & TCP_ASYNC_SOCKET) {
            timeOut = 0;
        } else {
            timeOut = -1;
        }
        errno = 0;
        state = TclUnixWaitForFile(statePtr->fd,
d2046 19
a2064 21
        if (!(statePtr->flags & TCP_ASYNC_SOCKET)) {
#ifndef	USE_FIONBIO
            flags = fcntl(statePtr->fd, F_GETFL);
            flags &= (~(O_NONBLOCK));
            (void) fcntl(statePtr->fd, F_SETFL, flags);
#endif

#ifdef	USE_FIONBIO
            flags = 0;
            (void) ioctl(statePtr->fd, FIONBIO, &flags);
#endif
        }
        if (state & TCL_EXCEPTION) {
            return -1;
        }
        if (state & TCL_WRITABLE) {
            statePtr->flags &= (~(TCP_ASYNC_CONNECT));
        } else if (timeOut == 0) {
            *errorCodePtr = errno = EWOULDBLOCK;
            return -1;
        }
d2097 1
a2097 1
                                         * in the buffer? */
d2106 1
a2106 1
        return -1;
d2110 1
a2110 1
        return bytesRead;
d2113 3
d2117 1
a2117 5
        /*
         * Turn ECONNRESET into a soft EOF condition.
         */
        
        return 0;
d2147 1
a2147 1
    char *buf;				/* The data buffer. */
d2158 1
a2158 1
        return -1;
d2162 1
a2162 1
        return written;
d2226 1
a2226 1
 *	list of all options and	their values is returned in the
d2237 3
a2239 3
    ClientData instanceData;     /* Socket state. */
    Tcl_Interp *interp;          /* For error reporting - can be NULL. */
    char *optionName;	         /* Name of the option to
d2243 1
a2243 1
    Tcl_DString *dsPtr;	         /* Where to store the computed
d2250 1
a2250 1
    int size = sizeof(struct sockaddr_in);
d2255 1
a2255 1
        len = strlen(optionName);
d2260 1
a2260 1
	int optlen;
d2262 1
a2262 2
    
	optlen = sizeof(int);
d2271 1
a2271 1
       return TCL_OK;
d2275 3
a2277 3
            ((len > 1) && (optionName[1] == 'p') &&
                    (strncmp(optionName, "-peername", len) == 0))) {
        if (getpeername(statePtr->fd, (struct sockaddr *) &peername,
d2279 6
a2284 6
            if (len == 0) {
                Tcl_DStringAppendElement(dsPtr, "-peername");
                Tcl_DStringStartSublist(dsPtr);
            }
            Tcl_DStringAppendElement(dsPtr, inet_ntoa(peername.sin_addr));
            hostEntPtr = gethostbyaddr(			/* INTL: Native. */
d2287 1
a2287 1
            if (hostEntPtr != NULL) {
d2291 27
a2317 28
                Tcl_DStringAppendElement(dsPtr, Tcl_DStringValue(&ds));
            } else {
                Tcl_DStringAppendElement(dsPtr, inet_ntoa(peername.sin_addr));
            }
            TclFormatInt(buf, ntohs(peername.sin_port));
            Tcl_DStringAppendElement(dsPtr, buf);
            if (len == 0) {
                Tcl_DStringEndSublist(dsPtr);
            } else {
                return TCL_OK;
            }
        } else {
            /*
             * getpeername failed - but if we were asked for all the options
             * (len==0), don't flag an error at that point because it could
             * be an fconfigure request on a server socket. (which have
             * no peer). same must be done on win&mac.
             */

            if (len) {
                if (interp) {
                    Tcl_AppendResult(interp, "can't get peername: ",
                                     Tcl_PosixError(interp),
                                     (char *) NULL);
                }
                return TCL_ERROR;
            }
        }
d2321 10
a2330 10
            ((len > 1) && (optionName[1] == 's') &&
                    (strncmp(optionName, "-sockname", len) == 0))) {
        if (getsockname(statePtr->fd, (struct sockaddr *) &sockname, &size)
		>= 0) {
            if (len == 0) {
                Tcl_DStringAppendElement(dsPtr, "-sockname");
                Tcl_DStringStartSublist(dsPtr);
            }
            Tcl_DStringAppendElement(dsPtr, inet_ntoa(sockname.sin_addr));
            hostEntPtr = gethostbyaddr(			/* INTL: Native. */
d2332 2
a2333 2
                    sizeof(sockname.sin_addr), AF_INET);
            if (hostEntPtr != (struct hostent *) NULL) {
d2337 12
a2348 12
                Tcl_DStringAppendElement(dsPtr, Tcl_DStringValue(&ds));
            } else {
                Tcl_DStringAppendElement(dsPtr, inet_ntoa(sockname.sin_addr));
            }
            TclFormatInt(buf, ntohs(sockname.sin_port));
            Tcl_DStringAppendElement(dsPtr, buf);
            if (len == 0) {
                Tcl_DStringEndSublist(dsPtr);
            } else {
                return TCL_OK;
            }
        } else {
d2351 1
a2351 2
				 Tcl_PosixError(interp),
				 (char *) NULL);
d2358 1
a2358 1
        return Tcl_BadChannelOption(interp, optionName, "peername sockname");
d2385 2
a2386 2
                                         * combination of TCL_READABLE,
                                         * TCL_WRITABLE and TCL_EXCEPTION. */
d2460 1
a2460 1
    char *host;			/* Name of host on which to open port.
d2464 1
a2464 1
    char *myaddr;		/* Optional client-side address */
d2467 2
a2468 2
                                 * attempt to do an async connect. Otherwise
                                 * do a synchronous connect or bind. */
d2496 1
a2496 1
    
a2505 1

d2510 1
a2510 1
    
d2515 1
a2515 1
                sizeof(struct sockaddr));
d2523 1
a2523 1
                    (char *) &curState, sizeof(curState));
d2538 20
a2557 22
        if (async) {
#ifndef	USE_FIONBIO
            origState = fcntl(sock, F_GETFL);
            curState = origState | O_NONBLOCK;
            status = fcntl(sock, F_SETFL, curState);
#endif

#ifdef	USE_FIONBIO
            curState = 1;
            status = ioctl(sock, FIONBIO, &curState);
#endif            
        } else {
            status = 0;
        }
        if (status > -1) {
            status = connect(sock, (struct sockaddr *) &sockaddr,
                    sizeof(sockaddr));
            if (status < 0) {
                if (errno == EINPROGRESS) {
                    asyncConnect = 1;
                    status = 0;
                }
d2571 1
a2571 3
#endif

#ifdef  USE_FIONBIO
d2574 1
a2574 1
#endif
d2577 1
a2577 1
        }
d2582 8
a2589 8
        if (interp != NULL) {
            Tcl_AppendResult(interp, "couldn't open socket: ",
                    Tcl_PosixError(interp), (char *) NULL);
        }
        if (sock != -1) {
            close(sock);
        }
        return NULL;
d2599 1
a2599 1
        statePtr->flags = TCP_ASYNC_CONNECT;
d2607 1
a2607 1
        close(sock);
d2636 1
a2636 1
    char *host;				/* Host.  NULL implies INADDR_ANY */
d2656 1
a2656 1
        addr.s_addr = inet_addr(native);		/* INTL: Native. */
d2661 7
a2667 7
        if (addr.s_addr == 0xFFFFFFFF) {
            hostent = gethostbyname(native);		/* INTL: Native. */
            if (hostent != NULL) {
                memcpy((VOID *) &addr,
                        (VOID *) hostent->h_addr_list[0],
                        (size_t) hostent->h_length);
            } else {
d2669 2
a2670 2
                errno = EHOSTUNREACH;
#else
d2672 3
a2674 3
                errno = ENXIO;
#endif
#endif
d2678 3
a2680 3
                return 0;	/* error */
            }
        }
d2685 1
a2685 1
        
d2705 1
a2705 1
 *	The channel or NULL if failed.  An error message is returned
d2718 2
a2719 2
    char *host;				/* Host on which to open port. */
    char *myaddr;			/* Client-side address */
d2722 2
a2723 2
                                         * asynchronous connect. Otherwise
                                         * we do a blocking connect. */
d2743 1
a2743 1
            (ClientData) statePtr, (TCL_READABLE | TCL_WRITABLE));
d2746 2
a2747 2
        Tcl_Close((Tcl_Interp *) NULL, statePtr->channel);
        return NULL;
d2777 1
d2782 1
a2782 1
    
d2784 1
a2784 1
            (ClientData) statePtr, (TCL_READABLE | TCL_WRITABLE));
d2787 2
a2788 2
        Tcl_Close((Tcl_Interp *) NULL, statePtr->channel);
        return NULL;
d2814 1
a2814 1
                                         * NULL. */
d2816 1
a2816 1
    char *myHost;			/* Name of local host. */
d2818 1
a2818 1
                                         * from new clients. */
d2842 1
a2842 1
            (ClientData) statePtr);
d2845 1
a2845 1
            (ClientData) statePtr, 0);
d2853 1
a2853 1
 *	Accept a TCP socket connection.  This is called by the event loop.
d2875 1
a2875 1
    int len;				/* For accept interface */
d2883 1
a2883 1
        return;
d2892 1
a2892 1
    
d2899 1
a2899 1
        
d2941 6
d2948 5
a2952 5
        case TCL_STDIN:
            if ((lseek(0, (off_t) 0, SEEK_CUR) == -1) &&
                    (errno == EBADF)) {
                return (Tcl_Channel) NULL;
            }
d2955 7
a2961 7
            bufMode = "line";
            break;
        case TCL_STDOUT:
            if ((lseek(1, (off_t) 0, SEEK_CUR) == -1) &&
                    (errno == EBADF)) {
                return (Tcl_Channel) NULL;
            }
d2964 7
a2970 7
            bufMode = "line";
            break;
        case TCL_STDERR:
            if ((lseek(2, (off_t) 0, SEEK_CUR) == -1) &&
                    (errno == EBADF)) {
                return (Tcl_Channel) NULL;
            }
d2974 1
a2974 1
            break;
d2980 3
d2992 5
a2996 1
    Tcl_SetChannelOption(NULL, channel, "-translation", "auto");
d3026 1
a3026 1
    char *string;		/* String that identifies file. */
d3032 2
a3033 2
                                 * check that the channel is open for the
                                 * requested mode. */
d3042 1
a3042 1
    
d3045 1
a3045 1
        return TCL_ERROR;
d3048 3
a3050 3
        Tcl_AppendResult(interp,
                "\"", string, "\" wasn't opened for writing", (char *) NULL);
        return TCL_ERROR;
d3052 3
a3054 3
        Tcl_AppendResult(interp,
                "\"", string, "\" wasn't opened for reading", (char *) NULL);
        return TCL_ERROR;
d3067 1
a3067 1
#endif	/* SUPPORTS_TTY */
d3070 1
a3070 1
        if (Tcl_GetChannelHandle(chan,
d3080 1
a3080 1
        
d3093 2
a3094 2
            "\" cannot be used to get a FILE *", (char *) NULL);
    return TCL_ERROR;        
d3147 1
a3147 1
	TclpGetTime(&now);
d3173 1
a3173 1
    
d3192 1
a3192 1
	
d3237 1
a3237 1
	TclpGetTime(&now);
a3245 2


@


1.3
log
@touched all sources to ease next import
@
text
@@


1.3.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d13 1
a13 1
 * RCS: @@(#) $Id: tclUnixChan.c,v 1.39 2002/09/03 02:01:25 hobbs Exp $
d16 2
a17 2
#include "tclInt.h"	/* Internal definitions for Tcl. */
#include "tclPort.h"	/* Portability features for Tcl. */
d20 1
a20 1
 * sys/ioctl.h has already been included by tclPort.h.	Including termios.h
a47 6
#   ifdef HAVE_SYS_IOCTL_H
#	include <sys/ioctl.h>
#   endif /* HAVE_SYS_IOCTL_H */
#   ifdef HAVE_SYS_MODEM_H
#	include <sys/modem.h>
#   endif /* HAVE_SYS_MODEM_H */
a50 41
#   define GETCONTROL(fd, intPtr)	ioctl((fd), TIOCMGET, (intPtr))
#   define SETCONTROL(fd, intPtr)	ioctl((fd), TIOCMSET, (intPtr))
    /*
     * TIP #35 introduced a different on exit flush/close behavior that
     * doesn't work correctly with standard channels on all systems.
     * The problem is tcflush throws away waiting channel data.	 This may
     * be necessary for true serial channels that may block, but isn't
     * correct in the standard case.  This might be replaced with tcdrain
     * instead, but that can block.  For now, we revert to making this do
     * nothing, and TtyOutputProc being the same old FileOutputProc.
     * -- hobbs [Bug #525783]
     */
#   define BAD_TIP35_FLUSH 0
#   if BAD_TIP35_FLUSH
#	define TTYFLUSH(fd)		tcflush((fd), TCIOFLUSH);
#   else
#	define TTYFLUSH(fd)
#   endif /* BAD_TIP35_FLUSH */
#   ifdef FIONREAD
#	define GETREADQUEUE(fd, int)	ioctl((fd), FIONREAD, &(int))
#   elif defined(FIORDCHK)
#	define GETREADQUEUE(fd, int)	int = ioctl((fd), FIORDCHK, NULL)
#   endif /* FIONREAD */
#   ifdef TIOCOUTQ
#	define GETWRITEQUEUE(fd, int)	ioctl((fd), TIOCOUTQ, &(int))
#   endif /* TIOCOUTQ */
#   if defined(TIOCSBRK) && defined(TIOCCBRK)
/*
 * Can't use ?: operator below because that messes up types on either
 * Linux or Solaris (the two are mutually exclusive!)
 */
#	define SETBREAK(fd, flag) \
		if (flag) {				\
		    ioctl((fd), TIOCSBRK, NULL);	\
		} else {				\
		    ioctl((fd), TIOCCBRK, NULL);	\
		}
#   endif /* TIOCSBRK&TIOCCBRK */
#   if !defined(CRTSCTS) && defined(CNEW_RTSCTS)
#	define CRTSCTS CNEW_RTSCTS
#   endif /* !CRTSCTS&CNEW_RTSCTS */
a51 1

a57 1

a65 1

a78 1
#ifdef DEPRECATED
a80 1
#endif /* DEPRECATED */
d92 1
a92 3
				 * descriptor.	Must be the first field. */
    int stateUpdated;		/* Flag to say if the state has been
				 * modified and needs resetting. */
d101 1
a101 1

a110 7
#define UNSUPPORTED_OPTION(detail) \
	if (interp) {							\
	    Tcl_AppendResult(interp, (detail),				\
		    " not supported for this platform", (char *) NULL); \
	}

#ifdef DEPRECATED
d116 1
a116 1

a120 1
#endif /* DEPRECATED */
d151 8
a158 8
#ifndef SOMAXCONN
#   define SOMAXCONN	100
#endif /* SOMAXCONN */

#if (SOMAXCONN < 100)
#   undef  SOMAXCONN
#   define SOMAXCONN	100
#endif /* SOMAXCONN < 100 */
d172 2
a173 2
			    int port, CONST char *host, int server,
			    CONST char *myaddr, int myport, int async));
d176 1
a176 1
			    CONST char *host, int port));
d178 1
a178 1
			    ClientData instanceData, int mode));
d182 1
a182 1
			    int direction, ClientData *handlePtr));
d184 1
a184 1
			    char *buf, int toRead, int *errorCode));
d186 2
a187 2
			    ClientData instanceData, CONST char *buf,
			    int toWrite, int *errorCode));
a189 2
static Tcl_WideInt	FileWideSeekProc _ANSI_ARGS_((ClientData instanceData,
			    Tcl_WideInt offset, int mode, int *errorCode));
d191 1
a191 1
			    int mask));
d194 1
a194 1
			    int mode));
d198 1
a198 1
			    int direction, ClientData *handlePtr));
d200 1
a200 1
			    Tcl_Interp *interp, CONST char *optionName,
d203 1
a203 1
			    char *buf, int toRead,  int *errorCode));
d205 1
a205 1
			    CONST char *buf, int toWrite, int *errorCode));
d207 1
a207 1
			    int mask));
d214 1
a214 1
			    Tcl_Interp *interp, CONST char *optionName,
d216 1
a216 5
static FileState *	TtyInit _ANSI_ARGS_((int fd, int initialize));
#if BAD_TIP35_FLUSH
static int		TtyOutputProc _ANSI_ARGS_((ClientData instanceData,
			    CONST char *buf, int toWrite, int *errorCode));
#endif /* BAD_TIP35_FLUSH */
d223 2
a224 2
			    Tcl_Interp *interp, CONST char *optionName, 
			    CONST char *value));
d227 1
a227 1
			    int *errorCodePtr));
d234 10
a243 15
    "file",			/* Type name. */
    TCL_CHANNEL_VERSION_3,	/* v3 channel */
    FileCloseProc,		/* Close proc. */
    FileInputProc,		/* Input proc. */
    FileOutputProc,		/* Output proc. */
    FileSeekProc,		/* Seek proc. */
    NULL,			/* Set option proc. */
    NULL,			/* Get option proc. */
    FileWatchProc,		/* Initialize notifier. */
    FileGetHandleProc,		/* Get OS handles out of channel. */
    NULL,			/* close2proc. */
    FileBlockModeProc,		/* Set blocking or non-blocking mode.*/
    NULL,			/* flush proc. */
    NULL,			/* handler proc. */
    FileWideSeekProc,		/* wide seek proc. */
d253 10
a262 18
    "tty",			/* Type name. */
    TCL_CHANNEL_VERSION_2,	/* v2 channel */
    TtyCloseProc,		/* Close proc. */
    FileInputProc,		/* Input proc. */
#if BAD_TIP35_FLUSH
    TtyOutputProc,		/* Output proc. */
#else /* !BAD_TIP35_FLUSH */
    FileOutputProc,		/* Output proc. */
#endif /* BAD_TIP35_FLUSH */
    NULL,			/* Seek proc. */
    TtySetOptionProc,		/* Set option proc. */
    TtyGetOptionProc,		/* Get option proc. */
    FileWatchProc,		/* Initialize notifier. */
    FileGetHandleProc,		/* Get OS handles out of channel. */
    NULL,			/* close2proc. */
    FileBlockModeProc,		/* Set blocking or non-blocking mode.*/
    NULL,			/* flush proc. */
    NULL,			/* handler proc. */
d272 10
a281 14
    "tcp",			/* Type name. */
    TCL_CHANNEL_VERSION_2,	/* v2 channel */
    TcpCloseProc,		/* Close proc. */
    TcpInputProc,		/* Input proc. */
    TcpOutputProc,		/* Output proc. */
    NULL,			/* Seek proc. */
    NULL,			/* Set option proc. */
    TcpGetOptionProc,		/* Get option proc. */
    TcpWatchProc,		/* Initialize notifier. */
    TcpGetHandleProc,		/* Get OS handles out of channel. */
    NULL,			/* close2proc. */
    TcpBlockModeProc,		/* Set blocking or non-blocking mode.*/
    NULL,			/* flush proc. */
    NULL,			/* handler proc. */
d307 2
a308 2
					 * TCL_MODE_BLOCKING or
					 * TCL_MODE_NONBLOCKING. */
d324 1
a324 1
#else /* USE_FIONBIO */
d333 1
a333 1
#endif /* !USE_FIONBIO */
d360 1
a360 1
					 * in the buffer? */
d365 1
a365 1
					 * read from the input device? */
d368 1
a368 1

d378 1
a378 1
	return bytesRead;
d394 1
a394 1
 *	output argument contains a POSIX error code if an error occurred,
d406 1
a406 1
    CONST char *buf;			/* The data buffer. */
a413 11

    if (toWrite == 0) {
	/*
	 * SF Tcl Bug 465765.
	 * Do not try to write nothing into a file. STREAM based
	 * implementations will considers this as EOF (if there is a
	 * pipe behind the file).
	 */

	return 0;
    }
d416 1
a416 1
	return written;
d445 1
a446 2
#ifdef DEPRECATED
    FileState **nextPtrPtr;
d448 1
a448 1
#endif /* DEPRECATED */
a460 1
#ifdef DEPRECATED
a467 1
#endif /* DEPRECATED */
d494 7
a500 5
    ClientData instanceData;	/* File state. */
    long offset;		/* Offset to seek to. */
    int mode;			/* Relative to where should we seek? Can be
				 * one of SEEK_START, SEEK_SET or SEEK_END. */
    int *errorCodePtr;		/* To store error code. */
d503 1
a503 1
    Tcl_WideInt oldLoc, newLoc;
d505 1
a505 60
    /*
     * Save our current place in case we need to roll-back the seek.
     */
    oldLoc = TclOSseek(fsPtr->fd, (Tcl_SeekOffset) 0, SEEK_CUR);
    if (oldLoc == Tcl_LongAsWide(-1)) {
	/*
	 * Bad things are happening.  Error out...
	 */
	*errorCodePtr = errno;
	return -1;
    }
 
    newLoc = TclOSseek(fsPtr->fd, (Tcl_SeekOffset) offset, mode);
 
    /*
     * Check for expressability in our return type, and roll-back otherwise.
     */
    if (newLoc > Tcl_LongAsWide(INT_MAX)) {
	*errorCodePtr = EOVERFLOW;
	TclOSseek(fsPtr->fd, (Tcl_SeekOffset) oldLoc, SEEK_SET);
	return -1;
    } else {
	*errorCodePtr = (newLoc == Tcl_LongAsWide(-1)) ? errno : 0;
    }
    return (int) Tcl_WideAsLong(newLoc);
}

/*
 *----------------------------------------------------------------------
 *
 * FileWideSeekProc --
 *
 *	This procedure is called by the generic IO level to move the
 *	access point in a file based channel, with offsets expressed
 *	as wide integers.
 *
 * Results:
 *	-1 if failed, the new position if successful. An output
 *	argument contains the POSIX error code if an error occurred,
 *	or zero.
 *
 * Side effects:
 *	Moves the location at which the channel will be accessed in
 *	future operations.
 *
 *----------------------------------------------------------------------
 */

static Tcl_WideInt
FileWideSeekProc(instanceData, offset, mode, errorCodePtr)
    ClientData instanceData;	/* File state. */
    Tcl_WideInt offset;		/* Offset to seek to. */
    int mode;			/* Relative to where should we seek? Can be
				 * one of SEEK_START, SEEK_CUR or SEEK_END. */
    int *errorCodePtr;		/* To store error code. */
{
    FileState *fsPtr = (FileState *) instanceData;
    Tcl_WideInt newLoc;

    newLoc = TclOSseek(fsPtr->fd, (Tcl_SeekOffset) offset, mode);
d532 2
a533 2
					 * combination of TCL_READABLE,
					 * TCL_WRITABLE and TCL_EXCEPTION. */
d601 1
a601 1
 *	Closes the device of the channel.
d605 1
d611 4
a614 21
#if BAD_TIP35_FLUSH
    TtyState *ttyPtr = (TtyState *) instanceData;
#endif /* BAD_TIP35_FLUSH */
#ifdef TTYFLUSH
    TTYFLUSH(ttyPtr->fs.fd);
#endif /* TTYFLUSH */
#if 0
    /*
     * TIP#35 agreed to remove the unsave so that TCL could be used as a 
     * simple stty. 
     * It would be cleaner to remove all the stuff related to 
     *	  TtyState.stateUpdated
     *	  TtyState.savedState
     * Then the structure TtyState would be the same as FileState.
     * IMO this cleanup could better be done for the final 8.4 release
     * after nobody complained about the missing unsave. -- schroedter
     */
    if (ttyPtr->stateUpdated) {
	SETIOSTATE(ttyPtr->fs.fd, &ttyPtr->savedState);
    }
#endif
a620 74
 * TtyOutputProc--
 *
 *	This procedure is invoked from the generic IO level to write
 *	output to a TTY channel.
 *
 * Results:
 *	The number of bytes written is returned or -1 on error. An
 *	output argument contains a POSIX error code if an error occurred,
 *	or zero.
 *
 * Side effects:
 *	Writes output on the output device of the channel
 *	if the channel is not designated to be closed.
 *
 *----------------------------------------------------------------------
 */

#if BAD_TIP35_FLUSH
static int
TtyOutputProc(instanceData, buf, toWrite, errorCodePtr)
    ClientData instanceData;		/* File state. */
    CONST char *buf;			/* The data buffer. */
    int toWrite;			/* How many bytes to write? */
    int *errorCodePtr;			/* Where to store error code. */
{
    if (TclInExit()) {
	/*
	 * Do not write data during Tcl exit.
	 * Serial port may block preventing Tcl from exit.
	 */
	return toWrite;
    } else {
	return FileOutputProc(instanceData, buf, toWrite, errorCodePtr);
    }
}
#endif /* BAD_TIP35_FLUSH */

#ifdef USE_TERMIOS
/*
 *----------------------------------------------------------------------
 *
 * TtyModemStatusStr --
 *
 *  Converts a RS232 modem status list of readable flags
 *
 *----------------------------------------------------------------------
 */
static void
TtyModemStatusStr(status, dsPtr)
    int status;		   /* RS232 modem status */
    Tcl_DString *dsPtr;	   /* Where to store string */
{
#ifdef TIOCM_CTS
    Tcl_DStringAppendElement(dsPtr, "CTS");
    Tcl_DStringAppendElement(dsPtr, (status & TIOCM_CTS) ? "1" : "0");
#endif /* TIOCM_CTS */
#ifdef TIOCM_DSR
    Tcl_DStringAppendElement(dsPtr, "DSR");
    Tcl_DStringAppendElement(dsPtr, (status & TIOCM_DSR) ? "1" : "0");
#endif /* TIOCM_DSR */
#ifdef TIOCM_RNG
    Tcl_DStringAppendElement(dsPtr, "RING");
    Tcl_DStringAppendElement(dsPtr, (status & TIOCM_RNG) ? "1" : "0");
#endif /* TIOCM_RNG */
#ifdef TIOCM_CD
    Tcl_DStringAppendElement(dsPtr, "DCD");
    Tcl_DStringAppendElement(dsPtr, (status & TIOCM_CD) ? "1" : "0");
#endif /* TIOCM_CD */
}
#endif /* USE_TERMIOS */

/*
 *----------------------------------------------------------------------
 *
d631 1
a631 1
 *	Sets Error message if needed (by calling Tcl_BadChannelOption).
d640 2
a641 2
    CONST char *optionName;	/* Which option to set? */
    CONST char *value;		/* New value for option. */
d644 1
a644 1
    unsigned int len, vlen;
a645 5
#ifdef USE_TERMIOS
    int flag, control, argc;
    CONST char **argv;
    IOSTATE iostate;
#endif /* USE_TERMIOS */
d648 1
a648 6
    vlen = strlen(value);

    /*
     * Option -mode baud,parity,databits,stopbits
     */
    if ((len > 2) && (strncmp(optionName, "-mode", len) == 0)) {
a657 146
	((TtyState *) fsPtr)->stateUpdated = 1;
	return TCL_OK;
    }

#ifdef USE_TERMIOS

    /*
     * Option -handshake none|xonxoff|rtscts|dtrdsr
     */
    if ((len > 1) && (strncmp(optionName, "-handshake", len) == 0)) {
	/*
	 * Reset all handshake options
	 * DTR and RTS are ON by default
	 */
	GETIOSTATE(fsPtr->fd, &iostate);
	iostate.c_iflag &= ~(IXON | IXOFF | IXANY);
#ifdef CRTSCTS
	iostate.c_cflag &= ~CRTSCTS;
#endif /* CRTSCTS */
	if (strncasecmp(value, "NONE", vlen) == 0) {
	    /* leave all handshake options disabled */
	} else if (strncasecmp(value, "XONXOFF", vlen) == 0) {
	    iostate.c_iflag |= (IXON | IXOFF | IXANY);
	} else if (strncasecmp(value, "RTSCTS", vlen) == 0) {
#ifdef CRTSCTS
	    iostate.c_cflag |= CRTSCTS;
#else /* !CRTSTS */
	    UNSUPPORTED_OPTION("-handshake RTSCTS");
	    return TCL_ERROR;
#endif /* CRTSCTS */
	} else if (strncasecmp(value, "DTRDSR", vlen) == 0) {
	    UNSUPPORTED_OPTION("-handshake DTRDSR");
	    return TCL_ERROR;
	} else {
	    if (interp) {
		Tcl_AppendResult(interp, "bad value for -handshake: ",
			"must be one of xonxoff, rtscts, dtrdsr or none",
			(char *) NULL);
	    }
	    return TCL_ERROR;
	}
	SETIOSTATE(fsPtr->fd, &iostate);
	return TCL_OK;
    }

    /*
     * Option -xchar {\x11 \x13}
     */
    if ((len > 1) && (strncmp(optionName, "-xchar", len) == 0)) {
	GETIOSTATE(fsPtr->fd, &iostate);
	if (Tcl_SplitList(interp, value, &argc, &argv) == TCL_ERROR) {
	    return TCL_ERROR;
	}
	if (argc == 2) {
	    iostate.c_cc[VSTART] = argv[0][0];
	    iostate.c_cc[VSTOP]	 = argv[1][0];
	} else {
	    if (interp) {
		Tcl_AppendResult(interp,
		    "bad value for -xchar: should be a list of two elements",
		    (char *) NULL);
	    }
	    return TCL_ERROR;
	}
	SETIOSTATE(fsPtr->fd, &iostate);
	return TCL_OK;
    }

    /*
     * Option -timeout msec
     */
    if ((len > 2) && (strncmp(optionName, "-timeout", len) == 0)) {
	int msec;

	GETIOSTATE(fsPtr->fd, &iostate);
	if (Tcl_GetInt(interp, value, &msec) != TCL_OK) {
	    return TCL_ERROR;
	}
	iostate.c_cc[VMIN]  = 0;
	iostate.c_cc[VTIME] = (msec == 0) ? 0 : (msec < 100) ? 1 : (msec+50)/100;
	SETIOSTATE(fsPtr->fd, &iostate);
	return TCL_OK;
    }

    /*
     * Option -ttycontrol {DTR 1 RTS 0 BREAK 0}
     */
    if ((len > 4) && (strncmp(optionName, "-ttycontrol", len) == 0)) {
	if (Tcl_SplitList(interp, value, &argc, &argv) == TCL_ERROR) {
	    return TCL_ERROR;
	}
	if ((argc % 2) == 1) {
	    if (interp) {
		Tcl_AppendResult(interp,
			"bad value for -ttycontrol: should be a list of",
			"signal,value pairs", (char *) NULL);
	    }
	    return TCL_ERROR;
	}

	GETCONTROL(fsPtr->fd, &control);
	while (argc > 1) {
	    if (Tcl_GetBoolean(interp, argv[1], &flag) == TCL_ERROR) {
		return TCL_ERROR;
	    }
	    if (strncasecmp(argv[0], "DTR", strlen(argv[0])) == 0) {
#ifdef TIOCM_DTR
		if (flag) {
		    control |= TIOCM_DTR;
		} else {
		    control &= ~TIOCM_DTR;
		}
#else /* !TIOCM_DTR */
		UNSUPPORTED_OPTION("-ttycontrol DTR");
		return TCL_ERROR;
#endif /* TIOCM_DTR */
	    } else if (strncasecmp(argv[0], "RTS", strlen(argv[0])) == 0) {
#ifdef TIOCM_RTS
		if (flag) {
		    control |= TIOCM_RTS;
		} else {
		    control &= ~TIOCM_RTS;
		}
#else /* !TIOCM_RTS*/
		UNSUPPORTED_OPTION("-ttycontrol RTS");
		return TCL_ERROR;
#endif /* TIOCM_RTS*/
	    } else if (strncasecmp(argv[0], "BREAK", strlen(argv[0])) == 0) {
#ifdef SETBREAK
		SETBREAK(fsPtr->fd, flag);
#else /* !SETBREAK */
		UNSUPPORTED_OPTION("-ttycontrol BREAK");
		return TCL_ERROR;
#endif /* SETBREAK */
	    } else {
		if (interp) {
		    Tcl_AppendResult(interp,
			    "bad signal for -ttycontrol: must be ",
			    "DTR, RTS or BREAK", (char *) NULL);
		}
		return TCL_ERROR;
	    }
	    argc -= 2, argv += 2;
	} /* while (argc > 1) */

	SETCONTROL(fsPtr->fd, &control);
d659 2
a661 7

    return Tcl_BadChannelOption(interp, optionName,
	    "mode handshake timeout ttycontrol xchar ");

#else /* !USE_TERMIOS */
    return Tcl_BadChannelOption(interp, optionName, "mode");
#endif /* USE_TERMIOS */
d681 1
a681 1
 *	Sets Error message if needed (by calling Tcl_BadChannelOption).
d690 1
a690 1
    CONST char *optionName;	/* Option to get. */
a696 1
    int valid = 0;  /* flag if valid option parsed */
d699 1
d704 2
a705 5
    if (len == 0) {
	Tcl_DStringAppendElement(dsPtr, "-mode");
    }
    if (len==0 || (len>2 && strncmp(optionName, "-mode", len)==0)) {
	valid = 1;
a708 62
    }

#ifdef USE_TERMIOS
    /*
     * get option -xchar
     */
    if (len == 0) {
	Tcl_DStringAppendElement(dsPtr, "-xchar");
	Tcl_DStringStartSublist(dsPtr);
    }
    if (len==0 || (len>1 && strncmp(optionName, "-xchar", len)==0)) {
	IOSTATE iostate;
	valid = 1;

	GETIOSTATE(fsPtr->fd, &iostate);
	sprintf(buf, "%c", iostate.c_cc[VSTART]);
	Tcl_DStringAppendElement(dsPtr, buf);
	sprintf(buf, "%c", iostate.c_cc[VSTOP]);
	Tcl_DStringAppendElement(dsPtr, buf);
    }
    if (len == 0) {
	Tcl_DStringEndSublist(dsPtr);
    }

    /*
     * get option -queue
     * option is readonly and returned by [fconfigure chan -queue]
     * but not returned by unnamed [fconfigure chan]
     */
    if ((len > 1) && (strncmp(optionName, "-queue", len) == 0)) {
	int inQueue=0, outQueue=0;
	int inBuffered, outBuffered;
	valid = 1;
#ifdef GETREADQUEUE
	GETREADQUEUE(fsPtr->fd, inQueue);
#endif /* GETREADQUEUE */
#ifdef GETWRITEQUEUE
	GETWRITEQUEUE(fsPtr->fd, outQueue);
#endif /* GETWRITEQUEUE */
	inBuffered  = Tcl_InputBuffered(fsPtr->channel);
	outBuffered = Tcl_OutputBuffered(fsPtr->channel);

	sprintf(buf, "%d", inBuffered+inQueue);
	Tcl_DStringAppendElement(dsPtr, buf);
	sprintf(buf, "%d", outBuffered+outQueue);
	Tcl_DStringAppendElement(dsPtr, buf);
    }

    /*
     * get option -ttystatus
     * option is readonly and returned by [fconfigure chan -ttystatus]
     * but not returned by unnamed [fconfigure chan]
     */
    if ((len > 4) && (strncmp(optionName, "-ttystatus", len) == 0)) {
	int status;
	valid = 1;
	GETCONTROL(fsPtr->fd, &status);
	TtyModemStatusStr(status, dsPtr);
    }
#endif /* USE_TERMIOS */

    if (valid) {
d711 1
a711 6
	return Tcl_BadChannelOption(interp, optionName,
#ifdef USE_TERMIOS
	    "mode queue ttystatus xchar");
#else /* !USE_TERMIOS */
	    "mode");
#endif /* USE_TERMIOS */
d719 2
a720 2
#   endif /* B4800 == 4800 */
#endif /* B4800 */
d725 1
a725 1
#else /* !DIRECT_BAUD */
d841 1
a841 1

d844 1
a844 1

d886 1
a886 1

d895 1
a895 1
#endif /* !DIRECT_BAUD */
d913 1
a913 1

d928 1
a928 1

d933 1
a933 1
	case PARENB | PARODD	      : parity = 'o'; break;
d935 1
a935 1
	case PARENB | PARODD | PAREXT : parity = 'm'; break;
d937 1
a937 1
#else /* !PAREXT */
d940 1
a940 1
	case PARENB | PARODD	      : parity = 'o'; break;
d942 1
a942 1
#endif /* !PAREXT */
d948 1
a948 1
#endif /* USE_TERMIOS */
d956 1
a956 1
	case PARENB | PARODD	      : parity = 'o'; break;
d958 1
a958 1
	case PARENB | PARODD | PAREXT : parity = 'm'; break;
d965 1
a965 1
#endif /* USE_TERMIO */
d980 1
a980 1
#endif /* USE_SGTTY */
d1003 1
a1003 1

d1029 1
a1029 1
#endif /* PAREXT */
d1112 1
a1112 1

d1145 1
a1145 1
#endif /* PAREXT|USE_TERMIO */
d1153 1
a1153 1
#endif /* PAREXT|USE_TERMIO */
a1182 3
 *	Note that no initialization happens if the initialize flag
 *	is not set; this is necessary for the correct handling of
 *	UNIX console TTYs at startup.
d1185 1
a1185 2
 *	A pointer to a FileState suitable for use with Tcl_CreateChannel
 *	and the ttyChannelType structure.
d1189 1
a1189 2
 *	sockets (if initialize flag is non-zero.)  All other modes can
 *	be simulated on top of this in Tcl.
d1195 1
a1195 1
TtyInit(fd, initialize)
a1197 1
    int initialize;
d1199 1
d1204 20
a1223 20
    ttyPtr->stateUpdated = 0;
    if (initialize) {
	IOSTATE iostate = ttyPtr->savedState;

#if defined(USE_TERMIOS) || defined(USE_TERMIO)
	if (iostate.c_iflag != IGNBRK ||
		iostate.c_oflag != 0 ||
		iostate.c_lflag != 0 ||
		iostate.c_cflag & CREAD ||
		iostate.c_cc[VMIN] != 1 ||
		iostate.c_cc[VTIME] != 0) {
	    ttyPtr->stateUpdated = 1;
	}
	iostate.c_iflag = IGNBRK;
	iostate.c_oflag = 0;
	iostate.c_lflag = 0;
	iostate.c_cflag |= CREAD;
	iostate.c_cc[VMIN] = 1;
	iostate.c_cc[VTIME] = 0;
#endif	/* USE_TERMIOS|USE_TERMIO */
d1226 2
a1227 6
	if ((iostate.sg_flags & (EVENP | ODDP)) ||
		!(iostate.sg_flags & RAW)) {
	    ttyPtr->stateUpdated = 1;
	}
	iostate.sg_flags &= (EVENP | ODDP);
	iostate.sg_flags |= RAW;
d1230 1
a1230 8
	/*
	 * Only update if we're changing anything to avoid possible
	 * blocking.
	 */
	if (ttyPtr->stateUpdated) {
	    SETIOSTATE(fd, &iostate);
	}
    }
d1256 1
a1256 1
TclpOpenFileChannel(interp, pathPtr, mode, permissions)
d1258 4
a1261 3
					 * can be NULL. */
    Tcl_Obj *pathPtr;			/* Name of file to open. */
    int mode;				/* POSIX open mode. */
d1263 2
a1264 2
					 * file, with what modes to create
					 * it? */
d1266 1
a1266 1
    int fd, channelPermissions;
d1268 1
a1268 1
    CONST char *native, *translation;
d1270 1
a1271 4
#ifdef SUPPORTS_TTY
    int ctl_tty;
#endif /* SUPPORTS_TTY */
#ifdef DEPRECATED
a1272 1
#endif /* DEPRECATED */
d1274 4
d1289 3
a1291 3
	    /*
	     * This may occurr if modeString was "", for example.
	     */
d1296 1
a1296 1
    native = Tcl_FSGetNativePath(pathPtr);
d1300 4
a1303 4
    fd = TclOSopen(native, mode, permissions);
#ifdef SUPPORTS_TTY
    ctl_tty = (strcmp (native, "/dev/tty") == 0);
#endif /* SUPPORTS_TTY */
d1306 5
a1310 6
	if (interp != (Tcl_Interp *) NULL) {
	    Tcl_AppendResult(interp, "couldn't open \"", 
		    Tcl_GetString(pathPtr), "\": ",
		    Tcl_PosixError(interp), (char *) NULL);
	}
	return NULL;
d1317 1
a1317 1

d1319 1
a1319 1

d1321 1
a1321 1

d1323 1
a1323 1
    if (!ctl_tty && isatty(fd)) {
d1331 1
a1331 1

d1334 1
a1334 1
	fsPtr = TtyInit(fd, 1);
a1342 1
#ifdef DEPRECATED
a1344 1
#endif /* DEPRECATED */
d1347 1
a1347 1

d1351 11
d1370 1
a1370 1

d1401 1
a1401 1
				 * TCL_WRITABLE to indicate file mode. */
a1405 2
    Tcl_ChannelType *channelTypePtr;
#ifdef DEPRECATED
a1406 3
#endif /* DEPRECATED */
    int socketType = 0;
    socklen_t argLength = sizeof(int);
d1409 1
a1409 1
	return NULL;
d1412 1
d1418 1
a1418 2

#ifdef DEPRECATED
a1424 20
#endif /* DEPRECATED */

#ifdef SUPPORTS_TTY
    if (isatty(fd)) {
	fsPtr = TtyInit(fd, 0);
	channelTypePtr = &ttyChannelType;
	sprintf(channelName, "serial%d", fd);
    } else
#endif /* SUPPORTS_TTY */
    if (getsockopt(fd, SOL_SOCKET, SO_TYPE, (VOID *)&socketType,
		   &argLength) == 0  &&	 socketType == SOCK_STREAM) {
	/*
	 * The mode parameter gets lost here, unfortunately.
	 */
	return Tcl_MakeTcpClientChannel((ClientData) fd);
    } else {
	channelTypePtr = &fileChannelType;
	fsPtr = (FileState *) ckalloc((unsigned) sizeof(FileState));
	sprintf(channelName, "file%d", fd);
    }
d1426 1
a1426 1
#ifdef DEPRECATED
d1429 1
a1429 1
#endif /* DEPRECATED */
d1432 3
a1434 3
    fsPtr->channel = Tcl_CreateChannel(channelTypePtr, channelName,
	    (ClientData) fsPtr, mode);

d1460 2
a1461 2
					 * TCL_MODE_BLOCKING or
					 * TCL_MODE_NONBLOCKING. */
d1465 2
a1466 2

#ifndef USE_FIONBIO
d1469 2
a1470 2
	statePtr->flags &= (~(TCP_ASYNC_SOCKET));
	setting &= (~(O_NONBLOCK));
d1472 2
a1473 2
	statePtr->flags |= TCP_ASYNC_SOCKET;
	setting |= O_NONBLOCK;
d1476 1
a1476 1
	return errno;
d1478 3
a1480 1
#else /* USE_FIONBIO */
d1482 5
a1486 5
	statePtr->flags &= (~(TCP_ASYNC_SOCKET));
	setting = 0;
	if (ioctl(statePtr->fd, (int) FIONBIO, &setting) == -1) {
	    return errno;
	}
d1488 5
a1492 5
	statePtr->flags |= TCP_ASYNC_SOCKET;
	setting = 1;
	if (ioctl(statePtr->fd, (int) FIONBIO, &setting) == -1) {
	    return errno;
	}
d1494 1
a1494 1
#endif /* !USE_FIONBIO */
d1529 1
a1529 1

d1531 7
a1537 7
	if (statePtr->flags & TCP_ASYNC_SOCKET) {
	    timeOut = 0;
	} else {
	    timeOut = -1;
	}
	errno = 0;
	state = TclUnixWaitForFile(statePtr->fd,
d1539 21
a1559 19
	if (!(statePtr->flags & TCP_ASYNC_SOCKET)) {
#ifndef USE_FIONBIO
	    flags = fcntl(statePtr->fd, F_GETFL);
	    flags &= (~(O_NONBLOCK));
	    (void) fcntl(statePtr->fd, F_SETFL, flags);
#else /* USE_FIONBIO */
	    flags = 0;
	    (void) ioctl(statePtr->fd, FIONBIO, &flags);
#endif /* !USE_FIONBIO */
	}
	if (state & TCL_EXCEPTION) {
	    return -1;
	}
	if (state & TCL_WRITABLE) {
	    statePtr->flags &= (~(TCP_ASYNC_CONNECT));
	} else if (timeOut == 0) {
	    *errorCodePtr = errno = EWOULDBLOCK;
	    return -1;
	}
d1592 1
a1592 1
					 * in the buffer? */
d1601 1
a1601 1
	return -1;
d1605 1
a1605 1
	return bytesRead;
a1607 3
	/*
	 * Turn ECONNRESET into a soft EOF condition.
	 */
d1609 5
a1613 1
	return 0;
d1643 1
a1643 1
    CONST char *buf;			/* The data buffer. */
d1654 1
a1654 1
	return -1;
d1658 1
a1658 1
	return written;
d1722 1
a1722 1
 *	list of all options and their values is returned in the
d1733 3
a1735 3
    ClientData instanceData;	 /* Socket state. */
    Tcl_Interp *interp;		 /* For error reporting - can be NULL. */
    CONST char *optionName;	 /* Name of the option to
d1739 1
a1739 1
    Tcl_DString *dsPtr;		 /* Where to store the computed
d1746 1
a1746 1
    socklen_t size = sizeof(struct sockaddr_in);
d1751 1
a1751 1
	len = strlen(optionName);
d1756 1
a1756 1
	socklen_t optlen = sizeof(int);
d1758 2
a1759 1

d1768 1
a1768 1
	return TCL_OK;
d1772 3
a1774 3
	    ((len > 1) && (optionName[1] == 'p') &&
		    (strncmp(optionName, "-peername", len) == 0))) {
	if (getpeername(statePtr->fd, (struct sockaddr *) &peername,
d1776 6
a1781 6
	    if (len == 0) {
		Tcl_DStringAppendElement(dsPtr, "-peername");
		Tcl_DStringStartSublist(dsPtr);
	    }
	    Tcl_DStringAppendElement(dsPtr, inet_ntoa(peername.sin_addr));
	    hostEntPtr = gethostbyaddr(			/* INTL: Native. */
d1784 1
a1784 1
	    if (hostEntPtr != NULL) {
d1788 28
a1815 27
		Tcl_DStringAppendElement(dsPtr, Tcl_DStringValue(&ds));
	    } else {
		Tcl_DStringAppendElement(dsPtr, inet_ntoa(peername.sin_addr));
	    }
	    TclFormatInt(buf, ntohs(peername.sin_port));
	    Tcl_DStringAppendElement(dsPtr, buf);
	    if (len == 0) {
		Tcl_DStringEndSublist(dsPtr);
	    } else {
		return TCL_OK;
	    }
	} else {
	    /*
	     * getpeername failed - but if we were asked for all the options
	     * (len==0), don't flag an error at that point because it could
	     * be an fconfigure request on a server socket. (which have
	     * no peer). same must be done on win&mac.
	     */

	    if (len) {
		if (interp) {
		    Tcl_AppendResult(interp, "can't get peername: ",
			    Tcl_PosixError(interp), (char *) NULL);
		}
		return TCL_ERROR;
	    }
	}
d1819 10
a1828 10
	    ((len > 1) && (optionName[1] == 's') &&
	    (strncmp(optionName, "-sockname", len) == 0))) {
	if (getsockname(statePtr->fd, (struct sockaddr *) &sockname,
		&size) >= 0) {
	    if (len == 0) {
		Tcl_DStringAppendElement(dsPtr, "-sockname");
		Tcl_DStringStartSublist(dsPtr);
	    }
	    Tcl_DStringAppendElement(dsPtr, inet_ntoa(sockname.sin_addr));
	    hostEntPtr = gethostbyaddr(			/* INTL: Native. */
d1830 2
a1831 2
		    sizeof(sockname.sin_addr), AF_INET);
	    if (hostEntPtr != (struct hostent *) NULL) {
d1835 12
a1846 12
		Tcl_DStringAppendElement(dsPtr, Tcl_DStringValue(&ds));
	    } else {
		Tcl_DStringAppendElement(dsPtr, inet_ntoa(sockname.sin_addr));
	    }
	    TclFormatInt(buf, ntohs(sockname.sin_port));
	    Tcl_DStringAppendElement(dsPtr, buf);
	    if (len == 0) {
		Tcl_DStringEndSublist(dsPtr);
	    } else {
		return TCL_OK;
	    }
	} else {
d1849 2
a1850 1
			Tcl_PosixError(interp), (char *) NULL);
d1857 1
a1857 1
	return Tcl_BadChannelOption(interp, optionName, "peername sockname");
d1884 2
a1885 2
					 * combination of TCL_READABLE,
					 * TCL_WRITABLE and TCL_EXCEPTION. */
d1959 1
a1959 1
    CONST char *host;		/* Name of host on which to open port.
d1963 1
a1963 1
    CONST char *myaddr;		/* Optional client-side address */
d1966 2
a1967 2
				 * attempt to do an async connect. Otherwise
				 * do a synchronous connect or bind. */
d1995 1
a1995 1

d2005 1
d2010 1
a2010 1

d2015 1
a2015 1
		sizeof(struct sockaddr));
d2023 1
a2023 1
		    (char *) &curState, sizeof(curState));
d2038 22
a2059 20
	if (async) {
#ifndef USE_FIONBIO
	    origState = fcntl(sock, F_GETFL);
	    curState = origState | O_NONBLOCK;
	    status = fcntl(sock, F_SETFL, curState);
#else /* USE_FIONBIO */
	    curState = 1;
	    status = ioctl(sock, FIONBIO, &curState);
#endif /* !USE_FIONBIO */
	} else {
	    status = 0;
	}
	if (status > -1) {
	    status = connect(sock, (struct sockaddr *) &sockaddr,
		    sizeof(sockaddr));
	    if (status < 0) {
		if (errno == EINPROGRESS) {
		    asyncConnect = 1;
		    status = 0;
		}
d2073 3
a2075 1
#else /* USE_FIONBIO */
d2078 1
a2078 1
#endif /* !USE_FIONBIO */
d2081 1
a2081 1
	}
d2086 8
a2093 8
	if (interp != NULL) {
	    Tcl_AppendResult(interp, "couldn't open socket: ",
		    Tcl_PosixError(interp), (char *) NULL);
	}
	if (sock != -1) {
	    close(sock);
	}
	return NULL;
d2103 1
a2103 1
	statePtr->flags = TCP_ASYNC_CONNECT;
d2111 1
a2111 1
	close(sock);
d2140 1
a2140 1
    CONST char *host;			/* Host.  NULL implies INADDR_ANY */
d2160 1
a2160 1
	addr.s_addr = inet_addr(native);		/* INTL: Native. */
d2165 7
a2171 7
	if (addr.s_addr == 0xFFFFFFFF) {
	    hostent = gethostbyname(native);		/* INTL: Native. */
	    if (hostent != NULL) {
		memcpy((VOID *) &addr,
			(VOID *) hostent->h_addr_list[0],
			(size_t) hostent->h_length);
	    } else {
d2173 2
a2174 2
		errno = EHOSTUNREACH;
#else /* !EHOSTUNREACH */
d2176 3
a2178 3
		errno = ENXIO;
#endif /* ENXIO */
#endif /* EHOSTUNREACH */
d2182 3
a2184 3
		return 0;	/* error */
	    }
	}
d2189 1
a2189 1

d2209 1
a2209 1
 *	The channel or NULL if failed.	An error message is returned
d2222 2
a2223 2
    CONST char *host;			/* Host on which to open port. */
    CONST char *myaddr;			/* Client-side address */
d2226 2
a2227 2
					 * asynchronous connect. Otherwise
					 * we do a blocking connect. */
d2247 1
a2247 1
	    (ClientData) statePtr, (TCL_READABLE | TCL_WRITABLE));
d2250 2
a2251 2
	Tcl_Close((Tcl_Interp *) NULL, statePtr->channel);
	return NULL;
a2280 1
    statePtr->flags = 0;
d2285 1
a2285 1

d2287 1
a2287 1
	    (ClientData) statePtr, (TCL_READABLE | TCL_WRITABLE));
d2290 2
a2291 2
	Tcl_Close((Tcl_Interp *) NULL, statePtr->channel);
	return NULL;
d2317 1
a2317 1
					 * NULL. */
d2319 1
a2319 1
    CONST char *myHost;			/* Name of local host. */
d2321 1
a2321 1
					 * from new clients. */
d2345 1
a2345 1
	    (ClientData) statePtr);
d2348 1
a2348 1
	    (ClientData) statePtr, 0);
d2356 1
a2356 1
 *	Accept a TCP socket connection.	 This is called by the event loop.
d2378 1
a2378 1
    socklen_t len;				/* For accept interface */
d2386 1
a2386 1
	return;
d2395 1
a2395 1

d2402 1
a2402 1

a2443 6
    /*
     * Some #def's to make the code a little clearer!
     */
#define ZERO_OFFSET	((Tcl_SeekOffset) 0)
#define ERROR_OFFSET	((Tcl_SeekOffset) -1)

d2445 5
a2449 5
	case TCL_STDIN:
	    if ((TclOSseek(0, ZERO_OFFSET, SEEK_CUR) == ERROR_OFFSET)
		    && (errno == EBADF)) {
		return (Tcl_Channel) NULL;
	    }
d2452 7
a2458 7
	    bufMode = "line";
	    break;
	case TCL_STDOUT:
	    if ((TclOSseek(1, ZERO_OFFSET, SEEK_CUR) == ERROR_OFFSET)
		    && (errno == EBADF)) {
		return (Tcl_Channel) NULL;
	    }
d2461 7
a2467 7
	    bufMode = "line";
	    break;
	case TCL_STDERR:
	    if ((TclOSseek(2, ZERO_OFFSET, SEEK_CUR) == ERROR_OFFSET)
		    && (errno == EBADF)) {
		return (Tcl_Channel) NULL;
	    }
d2471 1
a2471 1
	    break;
a2476 3
#undef ZERO_OFFSET
#undef ERROR_OFFSET

d2486 1
a2486 5
    if (Tcl_GetChannelType(channel) == &fileChannelType) {
	Tcl_SetChannelOption(NULL, channel, "-translation", "auto");
    } else {
	Tcl_SetChannelOption(NULL, channel, "-translation", "auto crlf");
    }
d2516 1
a2516 1
    CONST char *string;		/* String that identifies file. */
d2522 2
a2523 2
				 * check that the channel is open for the
				 * requested mode. */
d2532 1
a2532 1

d2535 1
a2535 1
	return TCL_ERROR;
d2538 3
a2540 3
	Tcl_AppendResult(interp,
		"\"", string, "\" wasn't opened for writing", (char *) NULL);
	return TCL_ERROR;
d2542 3
a2544 3
	Tcl_AppendResult(interp,
		"\"", string, "\" wasn't opened for reading", (char *) NULL);
	return TCL_ERROR;
d2557 1
a2557 1
#endif /* SUPPORTS_TTY */
d2560 1
a2560 1
	if (Tcl_GetChannelHandle(chan,
d2570 1
a2570 1

d2583 2
a2584 2
	    "\" cannot be used to get a FILE *", (char *) NULL);
    return TCL_ERROR;	     
d2637 1
a2637 1
	Tcl_GetTime(&now);
d2663 1
a2663 1

d2682 1
a2682 1

d2727 1
a2727 1
	Tcl_GetTime(&now);
d2736 2
@


1.3.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@d13 1
a13 1
 * RCS: @@(#) $Id: tclUnixChan.c,v 1.39 2002/09/03 02:01:25 hobbs Exp $
d16 2
a17 2
#include "tclInt.h"	/* Internal definitions for Tcl. */
#include "tclPort.h"	/* Portability features for Tcl. */
d20 1
a20 1
 * sys/ioctl.h has already been included by tclPort.h.	Including termios.h
a47 6
#   ifdef HAVE_SYS_IOCTL_H
#	include <sys/ioctl.h>
#   endif /* HAVE_SYS_IOCTL_H */
#   ifdef HAVE_SYS_MODEM_H
#	include <sys/modem.h>
#   endif /* HAVE_SYS_MODEM_H */
a50 41
#   define GETCONTROL(fd, intPtr)	ioctl((fd), TIOCMGET, (intPtr))
#   define SETCONTROL(fd, intPtr)	ioctl((fd), TIOCMSET, (intPtr))
    /*
     * TIP #35 introduced a different on exit flush/close behavior that
     * doesn't work correctly with standard channels on all systems.
     * The problem is tcflush throws away waiting channel data.	 This may
     * be necessary for true serial channels that may block, but isn't
     * correct in the standard case.  This might be replaced with tcdrain
     * instead, but that can block.  For now, we revert to making this do
     * nothing, and TtyOutputProc being the same old FileOutputProc.
     * -- hobbs [Bug #525783]
     */
#   define BAD_TIP35_FLUSH 0
#   if BAD_TIP35_FLUSH
#	define TTYFLUSH(fd)		tcflush((fd), TCIOFLUSH);
#   else
#	define TTYFLUSH(fd)
#   endif /* BAD_TIP35_FLUSH */
#   ifdef FIONREAD
#	define GETREADQUEUE(fd, int)	ioctl((fd), FIONREAD, &(int))
#   elif defined(FIORDCHK)
#	define GETREADQUEUE(fd, int)	int = ioctl((fd), FIORDCHK, NULL)
#   endif /* FIONREAD */
#   ifdef TIOCOUTQ
#	define GETWRITEQUEUE(fd, int)	ioctl((fd), TIOCOUTQ, &(int))
#   endif /* TIOCOUTQ */
#   if defined(TIOCSBRK) && defined(TIOCCBRK)
/*
 * Can't use ?: operator below because that messes up types on either
 * Linux or Solaris (the two are mutually exclusive!)
 */
#	define SETBREAK(fd, flag) \
		if (flag) {				\
		    ioctl((fd), TIOCSBRK, NULL);	\
		} else {				\
		    ioctl((fd), TIOCCBRK, NULL);	\
		}
#   endif /* TIOCSBRK&TIOCCBRK */
#   if !defined(CRTSCTS) && defined(CNEW_RTSCTS)
#	define CRTSCTS CNEW_RTSCTS
#   endif /* !CRTSCTS&CNEW_RTSCTS */
a51 1

a57 1

a65 1

a78 1
#ifdef DEPRECATED
a80 1
#endif /* DEPRECATED */
d92 1
a92 3
				 * descriptor.	Must be the first field. */
    int stateUpdated;		/* Flag to say if the state has been
				 * modified and needs resetting. */
d101 1
a101 1

a110 7
#define UNSUPPORTED_OPTION(detail) \
	if (interp) {							\
	    Tcl_AppendResult(interp, (detail),				\
		    " not supported for this platform", (char *) NULL); \
	}

#ifdef DEPRECATED
d116 1
a116 1

a120 1
#endif /* DEPRECATED */
d151 8
a158 8
#ifndef SOMAXCONN
#   define SOMAXCONN	100
#endif /* SOMAXCONN */

#if (SOMAXCONN < 100)
#   undef  SOMAXCONN
#   define SOMAXCONN	100
#endif /* SOMAXCONN < 100 */
d172 2
a173 2
			    int port, CONST char *host, int server,
			    CONST char *myaddr, int myport, int async));
d176 1
a176 1
			    CONST char *host, int port));
d178 1
a178 1
			    ClientData instanceData, int mode));
d182 1
a182 1
			    int direction, ClientData *handlePtr));
d184 1
a184 1
			    char *buf, int toRead, int *errorCode));
d186 2
a187 2
			    ClientData instanceData, CONST char *buf,
			    int toWrite, int *errorCode));
a189 2
static Tcl_WideInt	FileWideSeekProc _ANSI_ARGS_((ClientData instanceData,
			    Tcl_WideInt offset, int mode, int *errorCode));
d191 1
a191 1
			    int mask));
d194 1
a194 1
			    int mode));
d198 1
a198 1
			    int direction, ClientData *handlePtr));
d200 1
a200 1
			    Tcl_Interp *interp, CONST char *optionName,
d203 1
a203 1
			    char *buf, int toRead,  int *errorCode));
d205 1
a205 1
			    CONST char *buf, int toWrite, int *errorCode));
d207 1
a207 1
			    int mask));
d214 1
a214 1
			    Tcl_Interp *interp, CONST char *optionName,
d216 1
a216 5
static FileState *	TtyInit _ANSI_ARGS_((int fd, int initialize));
#if BAD_TIP35_FLUSH
static int		TtyOutputProc _ANSI_ARGS_((ClientData instanceData,
			    CONST char *buf, int toWrite, int *errorCode));
#endif /* BAD_TIP35_FLUSH */
d223 2
a224 2
			    Tcl_Interp *interp, CONST char *optionName, 
			    CONST char *value));
d227 1
a227 1
			    int *errorCodePtr));
d234 10
a243 15
    "file",			/* Type name. */
    TCL_CHANNEL_VERSION_3,	/* v3 channel */
    FileCloseProc,		/* Close proc. */
    FileInputProc,		/* Input proc. */
    FileOutputProc,		/* Output proc. */
    FileSeekProc,		/* Seek proc. */
    NULL,			/* Set option proc. */
    NULL,			/* Get option proc. */
    FileWatchProc,		/* Initialize notifier. */
    FileGetHandleProc,		/* Get OS handles out of channel. */
    NULL,			/* close2proc. */
    FileBlockModeProc,		/* Set blocking or non-blocking mode.*/
    NULL,			/* flush proc. */
    NULL,			/* handler proc. */
    FileWideSeekProc,		/* wide seek proc. */
d253 10
a262 18
    "tty",			/* Type name. */
    TCL_CHANNEL_VERSION_2,	/* v2 channel */
    TtyCloseProc,		/* Close proc. */
    FileInputProc,		/* Input proc. */
#if BAD_TIP35_FLUSH
    TtyOutputProc,		/* Output proc. */
#else /* !BAD_TIP35_FLUSH */
    FileOutputProc,		/* Output proc. */
#endif /* BAD_TIP35_FLUSH */
    NULL,			/* Seek proc. */
    TtySetOptionProc,		/* Set option proc. */
    TtyGetOptionProc,		/* Get option proc. */
    FileWatchProc,		/* Initialize notifier. */
    FileGetHandleProc,		/* Get OS handles out of channel. */
    NULL,			/* close2proc. */
    FileBlockModeProc,		/* Set blocking or non-blocking mode.*/
    NULL,			/* flush proc. */
    NULL,			/* handler proc. */
d272 10
a281 14
    "tcp",			/* Type name. */
    TCL_CHANNEL_VERSION_2,	/* v2 channel */
    TcpCloseProc,		/* Close proc. */
    TcpInputProc,		/* Input proc. */
    TcpOutputProc,		/* Output proc. */
    NULL,			/* Seek proc. */
    NULL,			/* Set option proc. */
    TcpGetOptionProc,		/* Get option proc. */
    TcpWatchProc,		/* Initialize notifier. */
    TcpGetHandleProc,		/* Get OS handles out of channel. */
    NULL,			/* close2proc. */
    TcpBlockModeProc,		/* Set blocking or non-blocking mode.*/
    NULL,			/* flush proc. */
    NULL,			/* handler proc. */
d307 2
a308 2
					 * TCL_MODE_BLOCKING or
					 * TCL_MODE_NONBLOCKING. */
d324 1
a324 1
#else /* USE_FIONBIO */
d333 1
a333 1
#endif /* !USE_FIONBIO */
d360 1
a360 1
					 * in the buffer? */
d365 1
a365 1
					 * read from the input device? */
d368 1
a368 1

d378 1
a378 1
	return bytesRead;
d394 1
a394 1
 *	output argument contains a POSIX error code if an error occurred,
d406 1
a406 1
    CONST char *buf;			/* The data buffer. */
a413 11

    if (toWrite == 0) {
	/*
	 * SF Tcl Bug 465765.
	 * Do not try to write nothing into a file. STREAM based
	 * implementations will considers this as EOF (if there is a
	 * pipe behind the file).
	 */

	return 0;
    }
d416 1
a416 1
	return written;
d445 1
a446 2
#ifdef DEPRECATED
    FileState **nextPtrPtr;
d448 1
a448 1
#endif /* DEPRECATED */
a460 1
#ifdef DEPRECATED
a467 1
#endif /* DEPRECATED */
d494 7
a500 5
    ClientData instanceData;	/* File state. */
    long offset;		/* Offset to seek to. */
    int mode;			/* Relative to where should we seek? Can be
				 * one of SEEK_START, SEEK_SET or SEEK_END. */
    int *errorCodePtr;		/* To store error code. */
d503 1
a503 1
    Tcl_WideInt oldLoc, newLoc;
d505 1
a505 60
    /*
     * Save our current place in case we need to roll-back the seek.
     */
    oldLoc = TclOSseek(fsPtr->fd, (Tcl_SeekOffset) 0, SEEK_CUR);
    if (oldLoc == Tcl_LongAsWide(-1)) {
	/*
	 * Bad things are happening.  Error out...
	 */
	*errorCodePtr = errno;
	return -1;
    }
 
    newLoc = TclOSseek(fsPtr->fd, (Tcl_SeekOffset) offset, mode);
 
    /*
     * Check for expressability in our return type, and roll-back otherwise.
     */
    if (newLoc > Tcl_LongAsWide(INT_MAX)) {
	*errorCodePtr = EOVERFLOW;
	TclOSseek(fsPtr->fd, (Tcl_SeekOffset) oldLoc, SEEK_SET);
	return -1;
    } else {
	*errorCodePtr = (newLoc == Tcl_LongAsWide(-1)) ? errno : 0;
    }
    return (int) Tcl_WideAsLong(newLoc);
}

/*
 *----------------------------------------------------------------------
 *
 * FileWideSeekProc --
 *
 *	This procedure is called by the generic IO level to move the
 *	access point in a file based channel, with offsets expressed
 *	as wide integers.
 *
 * Results:
 *	-1 if failed, the new position if successful. An output
 *	argument contains the POSIX error code if an error occurred,
 *	or zero.
 *
 * Side effects:
 *	Moves the location at which the channel will be accessed in
 *	future operations.
 *
 *----------------------------------------------------------------------
 */

static Tcl_WideInt
FileWideSeekProc(instanceData, offset, mode, errorCodePtr)
    ClientData instanceData;	/* File state. */
    Tcl_WideInt offset;		/* Offset to seek to. */
    int mode;			/* Relative to where should we seek? Can be
				 * one of SEEK_START, SEEK_CUR or SEEK_END. */
    int *errorCodePtr;		/* To store error code. */
{
    FileState *fsPtr = (FileState *) instanceData;
    Tcl_WideInt newLoc;

    newLoc = TclOSseek(fsPtr->fd, (Tcl_SeekOffset) offset, mode);
d532 2
a533 2
					 * combination of TCL_READABLE,
					 * TCL_WRITABLE and TCL_EXCEPTION. */
d601 1
a601 1
 *	Closes the device of the channel.
d605 1
d611 4
a614 21
#if BAD_TIP35_FLUSH
    TtyState *ttyPtr = (TtyState *) instanceData;
#endif /* BAD_TIP35_FLUSH */
#ifdef TTYFLUSH
    TTYFLUSH(ttyPtr->fs.fd);
#endif /* TTYFLUSH */
#if 0
    /*
     * TIP#35 agreed to remove the unsave so that TCL could be used as a 
     * simple stty. 
     * It would be cleaner to remove all the stuff related to 
     *	  TtyState.stateUpdated
     *	  TtyState.savedState
     * Then the structure TtyState would be the same as FileState.
     * IMO this cleanup could better be done for the final 8.4 release
     * after nobody complained about the missing unsave. -- schroedter
     */
    if (ttyPtr->stateUpdated) {
	SETIOSTATE(ttyPtr->fs.fd, &ttyPtr->savedState);
    }
#endif
a620 74
 * TtyOutputProc--
 *
 *	This procedure is invoked from the generic IO level to write
 *	output to a TTY channel.
 *
 * Results:
 *	The number of bytes written is returned or -1 on error. An
 *	output argument contains a POSIX error code if an error occurred,
 *	or zero.
 *
 * Side effects:
 *	Writes output on the output device of the channel
 *	if the channel is not designated to be closed.
 *
 *----------------------------------------------------------------------
 */

#if BAD_TIP35_FLUSH
static int
TtyOutputProc(instanceData, buf, toWrite, errorCodePtr)
    ClientData instanceData;		/* File state. */
    CONST char *buf;			/* The data buffer. */
    int toWrite;			/* How many bytes to write? */
    int *errorCodePtr;			/* Where to store error code. */
{
    if (TclInExit()) {
	/*
	 * Do not write data during Tcl exit.
	 * Serial port may block preventing Tcl from exit.
	 */
	return toWrite;
    } else {
	return FileOutputProc(instanceData, buf, toWrite, errorCodePtr);
    }
}
#endif /* BAD_TIP35_FLUSH */

#ifdef USE_TERMIOS
/*
 *----------------------------------------------------------------------
 *
 * TtyModemStatusStr --
 *
 *  Converts a RS232 modem status list of readable flags
 *
 *----------------------------------------------------------------------
 */
static void
TtyModemStatusStr(status, dsPtr)
    int status;		   /* RS232 modem status */
    Tcl_DString *dsPtr;	   /* Where to store string */
{
#ifdef TIOCM_CTS
    Tcl_DStringAppendElement(dsPtr, "CTS");
    Tcl_DStringAppendElement(dsPtr, (status & TIOCM_CTS) ? "1" : "0");
#endif /* TIOCM_CTS */
#ifdef TIOCM_DSR
    Tcl_DStringAppendElement(dsPtr, "DSR");
    Tcl_DStringAppendElement(dsPtr, (status & TIOCM_DSR) ? "1" : "0");
#endif /* TIOCM_DSR */
#ifdef TIOCM_RNG
    Tcl_DStringAppendElement(dsPtr, "RING");
    Tcl_DStringAppendElement(dsPtr, (status & TIOCM_RNG) ? "1" : "0");
#endif /* TIOCM_RNG */
#ifdef TIOCM_CD
    Tcl_DStringAppendElement(dsPtr, "DCD");
    Tcl_DStringAppendElement(dsPtr, (status & TIOCM_CD) ? "1" : "0");
#endif /* TIOCM_CD */
}
#endif /* USE_TERMIOS */

/*
 *----------------------------------------------------------------------
 *
d631 1
a631 1
 *	Sets Error message if needed (by calling Tcl_BadChannelOption).
d640 2
a641 2
    CONST char *optionName;	/* Which option to set? */
    CONST char *value;		/* New value for option. */
d644 1
a644 1
    unsigned int len, vlen;
a645 5
#ifdef USE_TERMIOS
    int flag, control, argc;
    CONST char **argv;
    IOSTATE iostate;
#endif /* USE_TERMIOS */
d648 1
a648 6
    vlen = strlen(value);

    /*
     * Option -mode baud,parity,databits,stopbits
     */
    if ((len > 2) && (strncmp(optionName, "-mode", len) == 0)) {
a657 146
	((TtyState *) fsPtr)->stateUpdated = 1;
	return TCL_OK;
    }

#ifdef USE_TERMIOS

    /*
     * Option -handshake none|xonxoff|rtscts|dtrdsr
     */
    if ((len > 1) && (strncmp(optionName, "-handshake", len) == 0)) {
	/*
	 * Reset all handshake options
	 * DTR and RTS are ON by default
	 */
	GETIOSTATE(fsPtr->fd, &iostate);
	iostate.c_iflag &= ~(IXON | IXOFF | IXANY);
#ifdef CRTSCTS
	iostate.c_cflag &= ~CRTSCTS;
#endif /* CRTSCTS */
	if (strncasecmp(value, "NONE", vlen) == 0) {
	    /* leave all handshake options disabled */
	} else if (strncasecmp(value, "XONXOFF", vlen) == 0) {
	    iostate.c_iflag |= (IXON | IXOFF | IXANY);
	} else if (strncasecmp(value, "RTSCTS", vlen) == 0) {
#ifdef CRTSCTS
	    iostate.c_cflag |= CRTSCTS;
#else /* !CRTSTS */
	    UNSUPPORTED_OPTION("-handshake RTSCTS");
	    return TCL_ERROR;
#endif /* CRTSCTS */
	} else if (strncasecmp(value, "DTRDSR", vlen) == 0) {
	    UNSUPPORTED_OPTION("-handshake DTRDSR");
	    return TCL_ERROR;
	} else {
	    if (interp) {
		Tcl_AppendResult(interp, "bad value for -handshake: ",
			"must be one of xonxoff, rtscts, dtrdsr or none",
			(char *) NULL);
	    }
	    return TCL_ERROR;
	}
	SETIOSTATE(fsPtr->fd, &iostate);
	return TCL_OK;
    }

    /*
     * Option -xchar {\x11 \x13}
     */
    if ((len > 1) && (strncmp(optionName, "-xchar", len) == 0)) {
	GETIOSTATE(fsPtr->fd, &iostate);
	if (Tcl_SplitList(interp, value, &argc, &argv) == TCL_ERROR) {
	    return TCL_ERROR;
	}
	if (argc == 2) {
	    iostate.c_cc[VSTART] = argv[0][0];
	    iostate.c_cc[VSTOP]	 = argv[1][0];
	} else {
	    if (interp) {
		Tcl_AppendResult(interp,
		    "bad value for -xchar: should be a list of two elements",
		    (char *) NULL);
	    }
	    return TCL_ERROR;
	}
	SETIOSTATE(fsPtr->fd, &iostate);
	return TCL_OK;
    }

    /*
     * Option -timeout msec
     */
    if ((len > 2) && (strncmp(optionName, "-timeout", len) == 0)) {
	int msec;

	GETIOSTATE(fsPtr->fd, &iostate);
	if (Tcl_GetInt(interp, value, &msec) != TCL_OK) {
	    return TCL_ERROR;
	}
	iostate.c_cc[VMIN]  = 0;
	iostate.c_cc[VTIME] = (msec == 0) ? 0 : (msec < 100) ? 1 : (msec+50)/100;
	SETIOSTATE(fsPtr->fd, &iostate);
	return TCL_OK;
    }

    /*
     * Option -ttycontrol {DTR 1 RTS 0 BREAK 0}
     */
    if ((len > 4) && (strncmp(optionName, "-ttycontrol", len) == 0)) {
	if (Tcl_SplitList(interp, value, &argc, &argv) == TCL_ERROR) {
	    return TCL_ERROR;
	}
	if ((argc % 2) == 1) {
	    if (interp) {
		Tcl_AppendResult(interp,
			"bad value for -ttycontrol: should be a list of",
			"signal,value pairs", (char *) NULL);
	    }
	    return TCL_ERROR;
	}

	GETCONTROL(fsPtr->fd, &control);
	while (argc > 1) {
	    if (Tcl_GetBoolean(interp, argv[1], &flag) == TCL_ERROR) {
		return TCL_ERROR;
	    }
	    if (strncasecmp(argv[0], "DTR", strlen(argv[0])) == 0) {
#ifdef TIOCM_DTR
		if (flag) {
		    control |= TIOCM_DTR;
		} else {
		    control &= ~TIOCM_DTR;
		}
#else /* !TIOCM_DTR */
		UNSUPPORTED_OPTION("-ttycontrol DTR");
		return TCL_ERROR;
#endif /* TIOCM_DTR */
	    } else if (strncasecmp(argv[0], "RTS", strlen(argv[0])) == 0) {
#ifdef TIOCM_RTS
		if (flag) {
		    control |= TIOCM_RTS;
		} else {
		    control &= ~TIOCM_RTS;
		}
#else /* !TIOCM_RTS*/
		UNSUPPORTED_OPTION("-ttycontrol RTS");
		return TCL_ERROR;
#endif /* TIOCM_RTS*/
	    } else if (strncasecmp(argv[0], "BREAK", strlen(argv[0])) == 0) {
#ifdef SETBREAK
		SETBREAK(fsPtr->fd, flag);
#else /* !SETBREAK */
		UNSUPPORTED_OPTION("-ttycontrol BREAK");
		return TCL_ERROR;
#endif /* SETBREAK */
	    } else {
		if (interp) {
		    Tcl_AppendResult(interp,
			    "bad signal for -ttycontrol: must be ",
			    "DTR, RTS or BREAK", (char *) NULL);
		}
		return TCL_ERROR;
	    }
	    argc -= 2, argv += 2;
	} /* while (argc > 1) */

	SETCONTROL(fsPtr->fd, &control);
d659 2
a661 7

    return Tcl_BadChannelOption(interp, optionName,
	    "mode handshake timeout ttycontrol xchar ");

#else /* !USE_TERMIOS */
    return Tcl_BadChannelOption(interp, optionName, "mode");
#endif /* USE_TERMIOS */
d681 1
a681 1
 *	Sets Error message if needed (by calling Tcl_BadChannelOption).
d690 1
a690 1
    CONST char *optionName;	/* Option to get. */
a696 1
    int valid = 0;  /* flag if valid option parsed */
d699 1
d704 2
a705 5
    if (len == 0) {
	Tcl_DStringAppendElement(dsPtr, "-mode");
    }
    if (len==0 || (len>2 && strncmp(optionName, "-mode", len)==0)) {
	valid = 1;
a708 62
    }

#ifdef USE_TERMIOS
    /*
     * get option -xchar
     */
    if (len == 0) {
	Tcl_DStringAppendElement(dsPtr, "-xchar");
	Tcl_DStringStartSublist(dsPtr);
    }
    if (len==0 || (len>1 && strncmp(optionName, "-xchar", len)==0)) {
	IOSTATE iostate;
	valid = 1;

	GETIOSTATE(fsPtr->fd, &iostate);
	sprintf(buf, "%c", iostate.c_cc[VSTART]);
	Tcl_DStringAppendElement(dsPtr, buf);
	sprintf(buf, "%c", iostate.c_cc[VSTOP]);
	Tcl_DStringAppendElement(dsPtr, buf);
    }
    if (len == 0) {
	Tcl_DStringEndSublist(dsPtr);
    }

    /*
     * get option -queue
     * option is readonly and returned by [fconfigure chan -queue]
     * but not returned by unnamed [fconfigure chan]
     */
    if ((len > 1) && (strncmp(optionName, "-queue", len) == 0)) {
	int inQueue=0, outQueue=0;
	int inBuffered, outBuffered;
	valid = 1;
#ifdef GETREADQUEUE
	GETREADQUEUE(fsPtr->fd, inQueue);
#endif /* GETREADQUEUE */
#ifdef GETWRITEQUEUE
	GETWRITEQUEUE(fsPtr->fd, outQueue);
#endif /* GETWRITEQUEUE */
	inBuffered  = Tcl_InputBuffered(fsPtr->channel);
	outBuffered = Tcl_OutputBuffered(fsPtr->channel);

	sprintf(buf, "%d", inBuffered+inQueue);
	Tcl_DStringAppendElement(dsPtr, buf);
	sprintf(buf, "%d", outBuffered+outQueue);
	Tcl_DStringAppendElement(dsPtr, buf);
    }

    /*
     * get option -ttystatus
     * option is readonly and returned by [fconfigure chan -ttystatus]
     * but not returned by unnamed [fconfigure chan]
     */
    if ((len > 4) && (strncmp(optionName, "-ttystatus", len) == 0)) {
	int status;
	valid = 1;
	GETCONTROL(fsPtr->fd, &status);
	TtyModemStatusStr(status, dsPtr);
    }
#endif /* USE_TERMIOS */

    if (valid) {
d711 1
a711 6
	return Tcl_BadChannelOption(interp, optionName,
#ifdef USE_TERMIOS
	    "mode queue ttystatus xchar");
#else /* !USE_TERMIOS */
	    "mode");
#endif /* USE_TERMIOS */
d719 2
a720 2
#   endif /* B4800 == 4800 */
#endif /* B4800 */
d725 1
a725 1
#else /* !DIRECT_BAUD */
d841 1
a841 1

d844 1
a844 1

d886 1
a886 1

d895 1
a895 1
#endif /* !DIRECT_BAUD */
d913 1
a913 1

d928 1
a928 1

d933 1
a933 1
	case PARENB | PARODD	      : parity = 'o'; break;
d935 1
a935 1
	case PARENB | PARODD | PAREXT : parity = 'm'; break;
d937 1
a937 1
#else /* !PAREXT */
d940 1
a940 1
	case PARENB | PARODD	      : parity = 'o'; break;
d942 1
a942 1
#endif /* !PAREXT */
d948 1
a948 1
#endif /* USE_TERMIOS */
d956 1
a956 1
	case PARENB | PARODD	      : parity = 'o'; break;
d958 1
a958 1
	case PARENB | PARODD | PAREXT : parity = 'm'; break;
d965 1
a965 1
#endif /* USE_TERMIO */
d980 1
a980 1
#endif /* USE_SGTTY */
d1003 1
a1003 1

d1029 1
a1029 1
#endif /* PAREXT */
d1112 1
a1112 1

d1145 1
a1145 1
#endif /* PAREXT|USE_TERMIO */
d1153 1
a1153 1
#endif /* PAREXT|USE_TERMIO */
a1182 3
 *	Note that no initialization happens if the initialize flag
 *	is not set; this is necessary for the correct handling of
 *	UNIX console TTYs at startup.
d1185 1
a1185 2
 *	A pointer to a FileState suitable for use with Tcl_CreateChannel
 *	and the ttyChannelType structure.
d1189 1
a1189 2
 *	sockets (if initialize flag is non-zero.)  All other modes can
 *	be simulated on top of this in Tcl.
d1195 1
a1195 1
TtyInit(fd, initialize)
a1197 1
    int initialize;
d1199 1
d1204 20
a1223 20
    ttyPtr->stateUpdated = 0;
    if (initialize) {
	IOSTATE iostate = ttyPtr->savedState;

#if defined(USE_TERMIOS) || defined(USE_TERMIO)
	if (iostate.c_iflag != IGNBRK ||
		iostate.c_oflag != 0 ||
		iostate.c_lflag != 0 ||
		iostate.c_cflag & CREAD ||
		iostate.c_cc[VMIN] != 1 ||
		iostate.c_cc[VTIME] != 0) {
	    ttyPtr->stateUpdated = 1;
	}
	iostate.c_iflag = IGNBRK;
	iostate.c_oflag = 0;
	iostate.c_lflag = 0;
	iostate.c_cflag |= CREAD;
	iostate.c_cc[VMIN] = 1;
	iostate.c_cc[VTIME] = 0;
#endif	/* USE_TERMIOS|USE_TERMIO */
d1226 2
a1227 6
	if ((iostate.sg_flags & (EVENP | ODDP)) ||
		!(iostate.sg_flags & RAW)) {
	    ttyPtr->stateUpdated = 1;
	}
	iostate.sg_flags &= (EVENP | ODDP);
	iostate.sg_flags |= RAW;
d1230 1
a1230 8
	/*
	 * Only update if we're changing anything to avoid possible
	 * blocking.
	 */
	if (ttyPtr->stateUpdated) {
	    SETIOSTATE(fd, &iostate);
	}
    }
d1256 1
a1256 1
TclpOpenFileChannel(interp, pathPtr, mode, permissions)
d1258 4
a1261 3
					 * can be NULL. */
    Tcl_Obj *pathPtr;			/* Name of file to open. */
    int mode;				/* POSIX open mode. */
d1263 2
a1264 2
					 * file, with what modes to create
					 * it? */
d1266 1
a1266 1
    int fd, channelPermissions;
d1268 1
a1268 1
    CONST char *native, *translation;
d1270 1
a1271 4
#ifdef SUPPORTS_TTY
    int ctl_tty;
#endif /* SUPPORTS_TTY */
#ifdef DEPRECATED
a1272 1
#endif /* DEPRECATED */
d1274 4
d1289 3
a1291 3
	    /*
	     * This may occurr if modeString was "", for example.
	     */
d1296 1
a1296 1
    native = Tcl_FSGetNativePath(pathPtr);
d1300 4
a1303 4
    fd = TclOSopen(native, mode, permissions);
#ifdef SUPPORTS_TTY
    ctl_tty = (strcmp (native, "/dev/tty") == 0);
#endif /* SUPPORTS_TTY */
d1306 5
a1310 6
	if (interp != (Tcl_Interp *) NULL) {
	    Tcl_AppendResult(interp, "couldn't open \"", 
		    Tcl_GetString(pathPtr), "\": ",
		    Tcl_PosixError(interp), (char *) NULL);
	}
	return NULL;
d1317 1
a1317 1

d1319 1
a1319 1

d1321 1
a1321 1

d1323 1
a1323 1
    if (!ctl_tty && isatty(fd)) {
d1331 1
a1331 1

d1334 1
a1334 1
	fsPtr = TtyInit(fd, 1);
a1342 1
#ifdef DEPRECATED
a1344 1
#endif /* DEPRECATED */
d1347 1
a1347 1

d1351 11
d1370 1
a1370 1

d1401 1
a1401 1
				 * TCL_WRITABLE to indicate file mode. */
a1405 2
    Tcl_ChannelType *channelTypePtr;
#ifdef DEPRECATED
a1406 3
#endif /* DEPRECATED */
    int socketType = 0;
    socklen_t argLength = sizeof(int);
d1409 1
a1409 1
	return NULL;
d1412 1
d1418 1
a1418 2

#ifdef DEPRECATED
a1424 20
#endif /* DEPRECATED */

#ifdef SUPPORTS_TTY
    if (isatty(fd)) {
	fsPtr = TtyInit(fd, 0);
	channelTypePtr = &ttyChannelType;
	sprintf(channelName, "serial%d", fd);
    } else
#endif /* SUPPORTS_TTY */
    if (getsockopt(fd, SOL_SOCKET, SO_TYPE, (VOID *)&socketType,
		   &argLength) == 0  &&	 socketType == SOCK_STREAM) {
	/*
	 * The mode parameter gets lost here, unfortunately.
	 */
	return Tcl_MakeTcpClientChannel((ClientData) fd);
    } else {
	channelTypePtr = &fileChannelType;
	fsPtr = (FileState *) ckalloc((unsigned) sizeof(FileState));
	sprintf(channelName, "file%d", fd);
    }
d1426 1
a1426 1
#ifdef DEPRECATED
d1429 1
a1429 1
#endif /* DEPRECATED */
d1432 3
a1434 3
    fsPtr->channel = Tcl_CreateChannel(channelTypePtr, channelName,
	    (ClientData) fsPtr, mode);

d1460 2
a1461 2
					 * TCL_MODE_BLOCKING or
					 * TCL_MODE_NONBLOCKING. */
d1465 2
a1466 2

#ifndef USE_FIONBIO
d1469 2
a1470 2
	statePtr->flags &= (~(TCP_ASYNC_SOCKET));
	setting &= (~(O_NONBLOCK));
d1472 2
a1473 2
	statePtr->flags |= TCP_ASYNC_SOCKET;
	setting |= O_NONBLOCK;
d1476 1
a1476 1
	return errno;
d1478 3
a1480 1
#else /* USE_FIONBIO */
d1482 5
a1486 5
	statePtr->flags &= (~(TCP_ASYNC_SOCKET));
	setting = 0;
	if (ioctl(statePtr->fd, (int) FIONBIO, &setting) == -1) {
	    return errno;
	}
d1488 5
a1492 5
	statePtr->flags |= TCP_ASYNC_SOCKET;
	setting = 1;
	if (ioctl(statePtr->fd, (int) FIONBIO, &setting) == -1) {
	    return errno;
	}
d1494 1
a1494 1
#endif /* !USE_FIONBIO */
d1529 1
a1529 1

d1531 7
a1537 7
	if (statePtr->flags & TCP_ASYNC_SOCKET) {
	    timeOut = 0;
	} else {
	    timeOut = -1;
	}
	errno = 0;
	state = TclUnixWaitForFile(statePtr->fd,
d1539 21
a1559 19
	if (!(statePtr->flags & TCP_ASYNC_SOCKET)) {
#ifndef USE_FIONBIO
	    flags = fcntl(statePtr->fd, F_GETFL);
	    flags &= (~(O_NONBLOCK));
	    (void) fcntl(statePtr->fd, F_SETFL, flags);
#else /* USE_FIONBIO */
	    flags = 0;
	    (void) ioctl(statePtr->fd, FIONBIO, &flags);
#endif /* !USE_FIONBIO */
	}
	if (state & TCL_EXCEPTION) {
	    return -1;
	}
	if (state & TCL_WRITABLE) {
	    statePtr->flags &= (~(TCP_ASYNC_CONNECT));
	} else if (timeOut == 0) {
	    *errorCodePtr = errno = EWOULDBLOCK;
	    return -1;
	}
d1592 1
a1592 1
					 * in the buffer? */
d1601 1
a1601 1
	return -1;
d1605 1
a1605 1
	return bytesRead;
a1607 3
	/*
	 * Turn ECONNRESET into a soft EOF condition.
	 */
d1609 5
a1613 1
	return 0;
d1643 1
a1643 1
    CONST char *buf;			/* The data buffer. */
d1654 1
a1654 1
	return -1;
d1658 1
a1658 1
	return written;
d1722 1
a1722 1
 *	list of all options and their values is returned in the
d1733 3
a1735 3
    ClientData instanceData;	 /* Socket state. */
    Tcl_Interp *interp;		 /* For error reporting - can be NULL. */
    CONST char *optionName;	 /* Name of the option to
d1739 1
a1739 1
    Tcl_DString *dsPtr;		 /* Where to store the computed
d1746 1
a1746 1
    socklen_t size = sizeof(struct sockaddr_in);
d1751 1
a1751 1
	len = strlen(optionName);
d1756 1
a1756 1
	socklen_t optlen = sizeof(int);
d1758 2
a1759 1

d1768 1
a1768 1
	return TCL_OK;
d1772 3
a1774 3
	    ((len > 1) && (optionName[1] == 'p') &&
		    (strncmp(optionName, "-peername", len) == 0))) {
	if (getpeername(statePtr->fd, (struct sockaddr *) &peername,
d1776 6
a1781 6
	    if (len == 0) {
		Tcl_DStringAppendElement(dsPtr, "-peername");
		Tcl_DStringStartSublist(dsPtr);
	    }
	    Tcl_DStringAppendElement(dsPtr, inet_ntoa(peername.sin_addr));
	    hostEntPtr = gethostbyaddr(			/* INTL: Native. */
d1784 1
a1784 1
	    if (hostEntPtr != NULL) {
d1788 28
a1815 27
		Tcl_DStringAppendElement(dsPtr, Tcl_DStringValue(&ds));
	    } else {
		Tcl_DStringAppendElement(dsPtr, inet_ntoa(peername.sin_addr));
	    }
	    TclFormatInt(buf, ntohs(peername.sin_port));
	    Tcl_DStringAppendElement(dsPtr, buf);
	    if (len == 0) {
		Tcl_DStringEndSublist(dsPtr);
	    } else {
		return TCL_OK;
	    }
	} else {
	    /*
	     * getpeername failed - but if we were asked for all the options
	     * (len==0), don't flag an error at that point because it could
	     * be an fconfigure request on a server socket. (which have
	     * no peer). same must be done on win&mac.
	     */

	    if (len) {
		if (interp) {
		    Tcl_AppendResult(interp, "can't get peername: ",
			    Tcl_PosixError(interp), (char *) NULL);
		}
		return TCL_ERROR;
	    }
	}
d1819 10
a1828 10
	    ((len > 1) && (optionName[1] == 's') &&
	    (strncmp(optionName, "-sockname", len) == 0))) {
	if (getsockname(statePtr->fd, (struct sockaddr *) &sockname,
		&size) >= 0) {
	    if (len == 0) {
		Tcl_DStringAppendElement(dsPtr, "-sockname");
		Tcl_DStringStartSublist(dsPtr);
	    }
	    Tcl_DStringAppendElement(dsPtr, inet_ntoa(sockname.sin_addr));
	    hostEntPtr = gethostbyaddr(			/* INTL: Native. */
d1830 2
a1831 2
		    sizeof(sockname.sin_addr), AF_INET);
	    if (hostEntPtr != (struct hostent *) NULL) {
d1835 12
a1846 12
		Tcl_DStringAppendElement(dsPtr, Tcl_DStringValue(&ds));
	    } else {
		Tcl_DStringAppendElement(dsPtr, inet_ntoa(sockname.sin_addr));
	    }
	    TclFormatInt(buf, ntohs(sockname.sin_port));
	    Tcl_DStringAppendElement(dsPtr, buf);
	    if (len == 0) {
		Tcl_DStringEndSublist(dsPtr);
	    } else {
		return TCL_OK;
	    }
	} else {
d1849 2
a1850 1
			Tcl_PosixError(interp), (char *) NULL);
d1857 1
a1857 1
	return Tcl_BadChannelOption(interp, optionName, "peername sockname");
d1884 2
a1885 2
					 * combination of TCL_READABLE,
					 * TCL_WRITABLE and TCL_EXCEPTION. */
d1959 1
a1959 1
    CONST char *host;		/* Name of host on which to open port.
d1963 1
a1963 1
    CONST char *myaddr;		/* Optional client-side address */
d1966 2
a1967 2
				 * attempt to do an async connect. Otherwise
				 * do a synchronous connect or bind. */
d1995 1
a1995 1

d2005 1
d2010 1
a2010 1

d2015 1
a2015 1
		sizeof(struct sockaddr));
d2023 1
a2023 1
		    (char *) &curState, sizeof(curState));
d2038 22
a2059 20
	if (async) {
#ifndef USE_FIONBIO
	    origState = fcntl(sock, F_GETFL);
	    curState = origState | O_NONBLOCK;
	    status = fcntl(sock, F_SETFL, curState);
#else /* USE_FIONBIO */
	    curState = 1;
	    status = ioctl(sock, FIONBIO, &curState);
#endif /* !USE_FIONBIO */
	} else {
	    status = 0;
	}
	if (status > -1) {
	    status = connect(sock, (struct sockaddr *) &sockaddr,
		    sizeof(sockaddr));
	    if (status < 0) {
		if (errno == EINPROGRESS) {
		    asyncConnect = 1;
		    status = 0;
		}
d2073 3
a2075 1
#else /* USE_FIONBIO */
d2078 1
a2078 1
#endif /* !USE_FIONBIO */
d2081 1
a2081 1
	}
d2086 8
a2093 8
	if (interp != NULL) {
	    Tcl_AppendResult(interp, "couldn't open socket: ",
		    Tcl_PosixError(interp), (char *) NULL);
	}
	if (sock != -1) {
	    close(sock);
	}
	return NULL;
d2103 1
a2103 1
	statePtr->flags = TCP_ASYNC_CONNECT;
d2111 1
a2111 1
	close(sock);
d2140 1
a2140 1
    CONST char *host;			/* Host.  NULL implies INADDR_ANY */
d2160 1
a2160 1
	addr.s_addr = inet_addr(native);		/* INTL: Native. */
d2165 7
a2171 7
	if (addr.s_addr == 0xFFFFFFFF) {
	    hostent = gethostbyname(native);		/* INTL: Native. */
	    if (hostent != NULL) {
		memcpy((VOID *) &addr,
			(VOID *) hostent->h_addr_list[0],
			(size_t) hostent->h_length);
	    } else {
d2173 2
a2174 2
		errno = EHOSTUNREACH;
#else /* !EHOSTUNREACH */
d2176 3
a2178 3
		errno = ENXIO;
#endif /* ENXIO */
#endif /* EHOSTUNREACH */
d2182 3
a2184 3
		return 0;	/* error */
	    }
	}
d2189 1
a2189 1

d2209 1
a2209 1
 *	The channel or NULL if failed.	An error message is returned
d2222 2
a2223 2
    CONST char *host;			/* Host on which to open port. */
    CONST char *myaddr;			/* Client-side address */
d2226 2
a2227 2
					 * asynchronous connect. Otherwise
					 * we do a blocking connect. */
d2247 1
a2247 1
	    (ClientData) statePtr, (TCL_READABLE | TCL_WRITABLE));
d2250 2
a2251 2
	Tcl_Close((Tcl_Interp *) NULL, statePtr->channel);
	return NULL;
a2280 1
    statePtr->flags = 0;
d2285 1
a2285 1

d2287 1
a2287 1
	    (ClientData) statePtr, (TCL_READABLE | TCL_WRITABLE));
d2290 2
a2291 2
	Tcl_Close((Tcl_Interp *) NULL, statePtr->channel);
	return NULL;
d2317 1
a2317 1
					 * NULL. */
d2319 1
a2319 1
    CONST char *myHost;			/* Name of local host. */
d2321 1
a2321 1
					 * from new clients. */
d2345 1
a2345 1
	    (ClientData) statePtr);
d2348 1
a2348 1
	    (ClientData) statePtr, 0);
d2356 1
a2356 1
 *	Accept a TCP socket connection.	 This is called by the event loop.
d2378 1
a2378 1
    socklen_t len;				/* For accept interface */
d2386 1
a2386 1
	return;
d2395 1
a2395 1

d2402 1
a2402 1

a2443 6
    /*
     * Some #def's to make the code a little clearer!
     */
#define ZERO_OFFSET	((Tcl_SeekOffset) 0)
#define ERROR_OFFSET	((Tcl_SeekOffset) -1)

d2445 5
a2449 5
	case TCL_STDIN:
	    if ((TclOSseek(0, ZERO_OFFSET, SEEK_CUR) == ERROR_OFFSET)
		    && (errno == EBADF)) {
		return (Tcl_Channel) NULL;
	    }
d2452 7
a2458 7
	    bufMode = "line";
	    break;
	case TCL_STDOUT:
	    if ((TclOSseek(1, ZERO_OFFSET, SEEK_CUR) == ERROR_OFFSET)
		    && (errno == EBADF)) {
		return (Tcl_Channel) NULL;
	    }
d2461 7
a2467 7
	    bufMode = "line";
	    break;
	case TCL_STDERR:
	    if ((TclOSseek(2, ZERO_OFFSET, SEEK_CUR) == ERROR_OFFSET)
		    && (errno == EBADF)) {
		return (Tcl_Channel) NULL;
	    }
d2471 1
a2471 1
	    break;
a2476 3
#undef ZERO_OFFSET
#undef ERROR_OFFSET

d2486 1
a2486 5
    if (Tcl_GetChannelType(channel) == &fileChannelType) {
	Tcl_SetChannelOption(NULL, channel, "-translation", "auto");
    } else {
	Tcl_SetChannelOption(NULL, channel, "-translation", "auto crlf");
    }
d2516 1
a2516 1
    CONST char *string;		/* String that identifies file. */
d2522 2
a2523 2
				 * check that the channel is open for the
				 * requested mode. */
d2532 1
a2532 1

d2535 1
a2535 1
	return TCL_ERROR;
d2538 3
a2540 3
	Tcl_AppendResult(interp,
		"\"", string, "\" wasn't opened for writing", (char *) NULL);
	return TCL_ERROR;
d2542 3
a2544 3
	Tcl_AppendResult(interp,
		"\"", string, "\" wasn't opened for reading", (char *) NULL);
	return TCL_ERROR;
d2557 1
a2557 1
#endif /* SUPPORTS_TTY */
d2560 1
a2560 1
	if (Tcl_GetChannelHandle(chan,
d2570 1
a2570 1

d2583 2
a2584 2
	    "\" cannot be used to get a FILE *", (char *) NULL);
    return TCL_ERROR;	     
d2637 1
a2637 1
	Tcl_GetTime(&now);
d2663 1
a2663 1

d2682 1
a2682 1

d2727 1
a2727 1
	Tcl_GetTime(&now);
d2736 2
@


1.2
log
@touched all Tcl files to ease next import.
@
text
@@


1.2.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.2.16.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d16 2
a17 2
#include "tclInt.h"	/* Internal definitions for Tcl. */
#include "tclPort.h"	/* Portability features for Tcl. */
d20 1
a20 1
 * sys/ioctl.h has already been included by tclPort.h.	Including termios.h
a47 6
#   ifdef HAVE_SYS_IOCTL_H
#	include <sys/ioctl.h>
#   endif /* HAVE_SYS_IOCTL_H */
#   ifdef HAVE_SYS_MODEM_H
#	include <sys/modem.h>
#   endif /* HAVE_SYS_MODEM_H */
a50 41
#   define GETCONTROL(fd, intPtr)	ioctl((fd), TIOCMGET, (intPtr))
#   define SETCONTROL(fd, intPtr)	ioctl((fd), TIOCMSET, (intPtr))
    /*
     * TIP #35 introduced a different on exit flush/close behavior that
     * doesn't work correctly with standard channels on all systems.
     * The problem is tcflush throws away waiting channel data.	 This may
     * be necessary for true serial channels that may block, but isn't
     * correct in the standard case.  This might be replaced with tcdrain
     * instead, but that can block.  For now, we revert to making this do
     * nothing, and TtyOutputProc being the same old FileOutputProc.
     * -- hobbs [Bug #525783]
     */
#   define BAD_TIP35_FLUSH 0
#   if BAD_TIP35_FLUSH
#	define TTYFLUSH(fd)		tcflush((fd), TCIOFLUSH);
#   else
#	define TTYFLUSH(fd)
#   endif /* BAD_TIP35_FLUSH */
#   ifdef FIONREAD
#	define GETREADQUEUE(fd, int)	ioctl((fd), FIONREAD, &(int))
#   elif defined(FIORDCHK)
#	define GETREADQUEUE(fd, int)	int = ioctl((fd), FIORDCHK, NULL)
#   endif /* FIONREAD */
#   ifdef TIOCOUTQ
#	define GETWRITEQUEUE(fd, int)	ioctl((fd), TIOCOUTQ, &(int))
#   endif /* TIOCOUTQ */
#   if defined(TIOCSBRK) && defined(TIOCCBRK)
/*
 * Can't use ?: operator below because that messes up types on either
 * Linux or Solaris (the two are mutually exclusive!)
 */
#	define SETBREAK(fd, flag) \
		if (flag) {				\
		    ioctl((fd), TIOCSBRK, NULL);	\
		} else {				\
		    ioctl((fd), TIOCCBRK, NULL);	\
		}
#   endif /* TIOCSBRK&TIOCCBRK */
#   if !defined(CRTSCTS) && defined(CNEW_RTSCTS)
#	define CRTSCTS CNEW_RTSCTS
#   endif /* !CRTSCTS&CNEW_RTSCTS */
a51 1

a57 1

a65 1

a78 1
#ifdef DEPRECATED
a80 1
#endif /* DEPRECATED */
d92 1
a92 3
				 * descriptor.	Must be the first field. */
    int stateUpdated;		/* Flag to say if the state has been
				 * modified and needs resetting. */
d101 1
a101 1

a110 7
#define UNSUPPORTED_OPTION(detail) \
	if (interp) {							\
	    Tcl_AppendResult(interp, (detail),				\
		    " not supported for this platform", (char *) NULL); \
	}

#ifdef DEPRECATED
d116 1
a116 1

a120 1
#endif /* DEPRECATED */
d151 8
a158 8
#ifndef SOMAXCONN
#   define SOMAXCONN	100
#endif /* SOMAXCONN */

#if (SOMAXCONN < 100)
#   undef  SOMAXCONN
#   define SOMAXCONN	100
#endif /* SOMAXCONN < 100 */
d172 2
a173 2
			    int port, CONST char *host, int server,
			    CONST char *myaddr, int myport, int async));
d176 1
a176 1
			    CONST char *host, int port));
d178 1
a178 1
			    ClientData instanceData, int mode));
d182 1
a182 1
			    int direction, ClientData *handlePtr));
d184 1
a184 1
			    char *buf, int toRead, int *errorCode));
d186 2
a187 2
			    ClientData instanceData, CONST char *buf,
			    int toWrite, int *errorCode));
a189 2
static Tcl_WideInt	FileWideSeekProc _ANSI_ARGS_((ClientData instanceData,
			    Tcl_WideInt offset, int mode, int *errorCode));
d191 1
a191 1
			    int mask));
d194 1
a194 1
			    int mode));
d198 1
a198 1
			    int direction, ClientData *handlePtr));
d200 1
a200 1
			    Tcl_Interp *interp, CONST char *optionName,
d203 1
a203 1
			    char *buf, int toRead,  int *errorCode));
d205 1
a205 1
			    CONST char *buf, int toWrite, int *errorCode));
d207 1
a207 1
			    int mask));
d214 1
a214 1
			    Tcl_Interp *interp, CONST char *optionName,
d216 1
a216 5
static FileState *	TtyInit _ANSI_ARGS_((int fd, int initialize));
#if BAD_TIP35_FLUSH
static int		TtyOutputProc _ANSI_ARGS_((ClientData instanceData,
			    CONST char *buf, int toWrite, int *errorCode));
#endif /* BAD_TIP35_FLUSH */
d223 2
a224 2
			    Tcl_Interp *interp, CONST char *optionName, 
			    CONST char *value));
d227 1
a227 1
			    int *errorCodePtr));
d234 10
a243 15
    "file",			/* Type name. */
    TCL_CHANNEL_VERSION_3,	/* v3 channel */
    FileCloseProc,		/* Close proc. */
    FileInputProc,		/* Input proc. */
    FileOutputProc,		/* Output proc. */
    FileSeekProc,		/* Seek proc. */
    NULL,			/* Set option proc. */
    NULL,			/* Get option proc. */
    FileWatchProc,		/* Initialize notifier. */
    FileGetHandleProc,		/* Get OS handles out of channel. */
    NULL,			/* close2proc. */
    FileBlockModeProc,		/* Set blocking or non-blocking mode.*/
    NULL,			/* flush proc. */
    NULL,			/* handler proc. */
    FileWideSeekProc,		/* wide seek proc. */
d253 10
a262 18
    "tty",			/* Type name. */
    TCL_CHANNEL_VERSION_2,	/* v2 channel */
    TtyCloseProc,		/* Close proc. */
    FileInputProc,		/* Input proc. */
#if BAD_TIP35_FLUSH
    TtyOutputProc,		/* Output proc. */
#else /* !BAD_TIP35_FLUSH */
    FileOutputProc,		/* Output proc. */
#endif /* BAD_TIP35_FLUSH */
    NULL,			/* Seek proc. */
    TtySetOptionProc,		/* Set option proc. */
    TtyGetOptionProc,		/* Get option proc. */
    FileWatchProc,		/* Initialize notifier. */
    FileGetHandleProc,		/* Get OS handles out of channel. */
    NULL,			/* close2proc. */
    FileBlockModeProc,		/* Set blocking or non-blocking mode.*/
    NULL,			/* flush proc. */
    NULL,			/* handler proc. */
d272 10
a281 14
    "tcp",			/* Type name. */
    TCL_CHANNEL_VERSION_2,	/* v2 channel */
    TcpCloseProc,		/* Close proc. */
    TcpInputProc,		/* Input proc. */
    TcpOutputProc,		/* Output proc. */
    NULL,			/* Seek proc. */
    NULL,			/* Set option proc. */
    TcpGetOptionProc,		/* Get option proc. */
    TcpWatchProc,		/* Initialize notifier. */
    TcpGetHandleProc,		/* Get OS handles out of channel. */
    NULL,			/* close2proc. */
    TcpBlockModeProc,		/* Set blocking or non-blocking mode.*/
    NULL,			/* flush proc. */
    NULL,			/* handler proc. */
d307 2
a308 2
					 * TCL_MODE_BLOCKING or
					 * TCL_MODE_NONBLOCKING. */
d324 1
a324 1
#else /* USE_FIONBIO */
d333 1
a333 1
#endif /* !USE_FIONBIO */
d360 1
a360 1
					 * in the buffer? */
d365 1
a365 1
					 * read from the input device? */
d368 1
a368 1

d378 1
a378 1
	return bytesRead;
d394 1
a394 1
 *	output argument contains a POSIX error code if an error occurred,
d406 1
a406 1
    CONST char *buf;			/* The data buffer. */
a413 11

    if (toWrite == 0) {
	/*
	 * SF Tcl Bug 465765.
	 * Do not try to write nothing into a file. STREAM based
	 * implementations will considers this as EOF (if there is a
	 * pipe behind the file).
	 */

	return 0;
    }
d416 1
a416 1
	return written;
d445 1
a446 2
#ifdef DEPRECATED
    FileState **nextPtrPtr;
d448 1
a448 1
#endif /* DEPRECATED */
a460 1
#ifdef DEPRECATED
a467 1
#endif /* DEPRECATED */
d494 7
a500 5
    ClientData instanceData;	/* File state. */
    long offset;		/* Offset to seek to. */
    int mode;			/* Relative to where should we seek? Can be
				 * one of SEEK_START, SEEK_SET or SEEK_END. */
    int *errorCodePtr;		/* To store error code. */
d503 1
a503 1
    Tcl_WideInt oldLoc, newLoc;
d505 1
a505 60
    /*
     * Save our current place in case we need to roll-back the seek.
     */
    oldLoc = TclOSseek(fsPtr->fd, (Tcl_SeekOffset) 0, SEEK_CUR);
    if (oldLoc == Tcl_LongAsWide(-1)) {
	/*
	 * Bad things are happening.  Error out...
	 */
	*errorCodePtr = errno;
	return -1;
    }
 
    newLoc = TclOSseek(fsPtr->fd, (Tcl_SeekOffset) offset, mode);
 
    /*
     * Check for expressability in our return type, and roll-back otherwise.
     */
    if (newLoc > Tcl_LongAsWide(INT_MAX)) {
	*errorCodePtr = EOVERFLOW;
	TclOSseek(fsPtr->fd, (Tcl_SeekOffset) oldLoc, SEEK_SET);
	return -1;
    } else {
	*errorCodePtr = (newLoc == Tcl_LongAsWide(-1)) ? errno : 0;
    }
    return (int) Tcl_WideAsLong(newLoc);
}

/*
 *----------------------------------------------------------------------
 *
 * FileWideSeekProc --
 *
 *	This procedure is called by the generic IO level to move the
 *	access point in a file based channel, with offsets expressed
 *	as wide integers.
 *
 * Results:
 *	-1 if failed, the new position if successful. An output
 *	argument contains the POSIX error code if an error occurred,
 *	or zero.
 *
 * Side effects:
 *	Moves the location at which the channel will be accessed in
 *	future operations.
 *
 *----------------------------------------------------------------------
 */

static Tcl_WideInt
FileWideSeekProc(instanceData, offset, mode, errorCodePtr)
    ClientData instanceData;	/* File state. */
    Tcl_WideInt offset;		/* Offset to seek to. */
    int mode;			/* Relative to where should we seek? Can be
				 * one of SEEK_START, SEEK_CUR or SEEK_END. */
    int *errorCodePtr;		/* To store error code. */
{
    FileState *fsPtr = (FileState *) instanceData;
    Tcl_WideInt newLoc;

    newLoc = TclOSseek(fsPtr->fd, (Tcl_SeekOffset) offset, mode);
d532 2
a533 2
					 * combination of TCL_READABLE,
					 * TCL_WRITABLE and TCL_EXCEPTION. */
d601 1
a601 1
 *	Closes the device of the channel.
d605 1
d611 4
a614 21
#if BAD_TIP35_FLUSH
    TtyState *ttyPtr = (TtyState *) instanceData;
#endif /* BAD_TIP35_FLUSH */
#ifdef TTYFLUSH
    TTYFLUSH(ttyPtr->fs.fd);
#endif /* TTYFLUSH */
#if 0
    /*
     * TIP#35 agreed to remove the unsave so that TCL could be used as a 
     * simple stty. 
     * It would be cleaner to remove all the stuff related to 
     *	  TtyState.stateUpdated
     *	  TtyState.savedState
     * Then the structure TtyState would be the same as FileState.
     * IMO this cleanup could better be done for the final 8.4 release
     * after nobody complained about the missing unsave. -- schroedter
     */
    if (ttyPtr->stateUpdated) {
	SETIOSTATE(ttyPtr->fs.fd, &ttyPtr->savedState);
    }
#endif
a620 74
 * TtyOutputProc--
 *
 *	This procedure is invoked from the generic IO level to write
 *	output to a TTY channel.
 *
 * Results:
 *	The number of bytes written is returned or -1 on error. An
 *	output argument contains a POSIX error code if an error occurred,
 *	or zero.
 *
 * Side effects:
 *	Writes output on the output device of the channel
 *	if the channel is not designated to be closed.
 *
 *----------------------------------------------------------------------
 */

#if BAD_TIP35_FLUSH
static int
TtyOutputProc(instanceData, buf, toWrite, errorCodePtr)
    ClientData instanceData;		/* File state. */
    CONST char *buf;			/* The data buffer. */
    int toWrite;			/* How many bytes to write? */
    int *errorCodePtr;			/* Where to store error code. */
{
    if (TclInExit()) {
	/*
	 * Do not write data during Tcl exit.
	 * Serial port may block preventing Tcl from exit.
	 */
	return toWrite;
    } else {
	return FileOutputProc(instanceData, buf, toWrite, errorCodePtr);
    }
}
#endif /* BAD_TIP35_FLUSH */

#ifdef USE_TERMIOS
/*
 *----------------------------------------------------------------------
 *
 * TtyModemStatusStr --
 *
 *  Converts a RS232 modem status list of readable flags
 *
 *----------------------------------------------------------------------
 */
static void
TtyModemStatusStr(status, dsPtr)
    int status;		   /* RS232 modem status */
    Tcl_DString *dsPtr;	   /* Where to store string */
{
#ifdef TIOCM_CTS
    Tcl_DStringAppendElement(dsPtr, "CTS");
    Tcl_DStringAppendElement(dsPtr, (status & TIOCM_CTS) ? "1" : "0");
#endif /* TIOCM_CTS */
#ifdef TIOCM_DSR
    Tcl_DStringAppendElement(dsPtr, "DSR");
    Tcl_DStringAppendElement(dsPtr, (status & TIOCM_DSR) ? "1" : "0");
#endif /* TIOCM_DSR */
#ifdef TIOCM_RNG
    Tcl_DStringAppendElement(dsPtr, "RING");
    Tcl_DStringAppendElement(dsPtr, (status & TIOCM_RNG) ? "1" : "0");
#endif /* TIOCM_RNG */
#ifdef TIOCM_CD
    Tcl_DStringAppendElement(dsPtr, "DCD");
    Tcl_DStringAppendElement(dsPtr, (status & TIOCM_CD) ? "1" : "0");
#endif /* TIOCM_CD */
}
#endif /* USE_TERMIOS */

/*
 *----------------------------------------------------------------------
 *
d631 1
a631 1
 *	Sets Error message if needed (by calling Tcl_BadChannelOption).
d640 2
a641 2
    CONST char *optionName;	/* Which option to set? */
    CONST char *value;		/* New value for option. */
d644 1
a644 1
    unsigned int len, vlen;
a645 5
#ifdef USE_TERMIOS
    int flag, control, argc;
    CONST char **argv;
    IOSTATE iostate;
#endif /* USE_TERMIOS */
d648 1
a648 6
    vlen = strlen(value);

    /*
     * Option -mode baud,parity,databits,stopbits
     */
    if ((len > 2) && (strncmp(optionName, "-mode", len) == 0)) {
a657 146
	((TtyState *) fsPtr)->stateUpdated = 1;
	return TCL_OK;
    }

#ifdef USE_TERMIOS

    /*
     * Option -handshake none|xonxoff|rtscts|dtrdsr
     */
    if ((len > 1) && (strncmp(optionName, "-handshake", len) == 0)) {
	/*
	 * Reset all handshake options
	 * DTR and RTS are ON by default
	 */
	GETIOSTATE(fsPtr->fd, &iostate);
	iostate.c_iflag &= ~(IXON | IXOFF | IXANY);
#ifdef CRTSCTS
	iostate.c_cflag &= ~CRTSCTS;
#endif /* CRTSCTS */
	if (strncasecmp(value, "NONE", vlen) == 0) {
	    /* leave all handshake options disabled */
	} else if (strncasecmp(value, "XONXOFF", vlen) == 0) {
	    iostate.c_iflag |= (IXON | IXOFF | IXANY);
	} else if (strncasecmp(value, "RTSCTS", vlen) == 0) {
#ifdef CRTSCTS
	    iostate.c_cflag |= CRTSCTS;
#else /* !CRTSTS */
	    UNSUPPORTED_OPTION("-handshake RTSCTS");
	    return TCL_ERROR;
#endif /* CRTSCTS */
	} else if (strncasecmp(value, "DTRDSR", vlen) == 0) {
	    UNSUPPORTED_OPTION("-handshake DTRDSR");
	    return TCL_ERROR;
	} else {
	    if (interp) {
		Tcl_AppendResult(interp, "bad value for -handshake: ",
			"must be one of xonxoff, rtscts, dtrdsr or none",
			(char *) NULL);
	    }
	    return TCL_ERROR;
	}
	SETIOSTATE(fsPtr->fd, &iostate);
	return TCL_OK;
    }

    /*
     * Option -xchar {\x11 \x13}
     */
    if ((len > 1) && (strncmp(optionName, "-xchar", len) == 0)) {
	GETIOSTATE(fsPtr->fd, &iostate);
	if (Tcl_SplitList(interp, value, &argc, &argv) == TCL_ERROR) {
	    return TCL_ERROR;
	}
	if (argc == 2) {
	    iostate.c_cc[VSTART] = argv[0][0];
	    iostate.c_cc[VSTOP]	 = argv[1][0];
	} else {
	    if (interp) {
		Tcl_AppendResult(interp,
		    "bad value for -xchar: should be a list of two elements",
		    (char *) NULL);
	    }
	    return TCL_ERROR;
	}
	SETIOSTATE(fsPtr->fd, &iostate);
	return TCL_OK;
    }

    /*
     * Option -timeout msec
     */
    if ((len > 2) && (strncmp(optionName, "-timeout", len) == 0)) {
	int msec;

	GETIOSTATE(fsPtr->fd, &iostate);
	if (Tcl_GetInt(interp, value, &msec) != TCL_OK) {
	    return TCL_ERROR;
	}
	iostate.c_cc[VMIN]  = 0;
	iostate.c_cc[VTIME] = (msec == 0) ? 0 : (msec < 100) ? 1 : (msec+50)/100;
	SETIOSTATE(fsPtr->fd, &iostate);
	return TCL_OK;
    }

    /*
     * Option -ttycontrol {DTR 1 RTS 0 BREAK 0}
     */
    if ((len > 4) && (strncmp(optionName, "-ttycontrol", len) == 0)) {
	if (Tcl_SplitList(interp, value, &argc, &argv) == TCL_ERROR) {
	    return TCL_ERROR;
	}
	if ((argc % 2) == 1) {
	    if (interp) {
		Tcl_AppendResult(interp,
			"bad value for -ttycontrol: should be a list of",
			"signal,value pairs", (char *) NULL);
	    }
	    return TCL_ERROR;
	}

	GETCONTROL(fsPtr->fd, &control);
	while (argc > 1) {
	    if (Tcl_GetBoolean(interp, argv[1], &flag) == TCL_ERROR) {
		return TCL_ERROR;
	    }
	    if (strncasecmp(argv[0], "DTR", strlen(argv[0])) == 0) {
#ifdef TIOCM_DTR
		if (flag) {
		    control |= TIOCM_DTR;
		} else {
		    control &= ~TIOCM_DTR;
		}
#else /* !TIOCM_DTR */
		UNSUPPORTED_OPTION("-ttycontrol DTR");
		return TCL_ERROR;
#endif /* TIOCM_DTR */
	    } else if (strncasecmp(argv[0], "RTS", strlen(argv[0])) == 0) {
#ifdef TIOCM_RTS
		if (flag) {
		    control |= TIOCM_RTS;
		} else {
		    control &= ~TIOCM_RTS;
		}
#else /* !TIOCM_RTS*/
		UNSUPPORTED_OPTION("-ttycontrol RTS");
		return TCL_ERROR;
#endif /* TIOCM_RTS*/
	    } else if (strncasecmp(argv[0], "BREAK", strlen(argv[0])) == 0) {
#ifdef SETBREAK
		SETBREAK(fsPtr->fd, flag);
#else /* !SETBREAK */
		UNSUPPORTED_OPTION("-ttycontrol BREAK");
		return TCL_ERROR;
#endif /* SETBREAK */
	    } else {
		if (interp) {
		    Tcl_AppendResult(interp,
			    "bad signal for -ttycontrol: must be ",
			    "DTR, RTS or BREAK", (char *) NULL);
		}
		return TCL_ERROR;
	    }
	    argc -= 2, argv += 2;
	} /* while (argc > 1) */

	SETCONTROL(fsPtr->fd, &control);
d659 2
a661 7

    return Tcl_BadChannelOption(interp, optionName,
	    "mode handshake timeout ttycontrol xchar ");

#else /* !USE_TERMIOS */
    return Tcl_BadChannelOption(interp, optionName, "mode");
#endif /* USE_TERMIOS */
d681 1
a681 1
 *	Sets Error message if needed (by calling Tcl_BadChannelOption).
d690 1
a690 1
    CONST char *optionName;	/* Option to get. */
a696 1
    int valid = 0;  /* flag if valid option parsed */
d699 1
d704 2
a705 5
    if (len == 0) {
	Tcl_DStringAppendElement(dsPtr, "-mode");
    }
    if (len==0 || (len>2 && strncmp(optionName, "-mode", len)==0)) {
	valid = 1;
a708 62
    }

#ifdef USE_TERMIOS
    /*
     * get option -xchar
     */
    if (len == 0) {
	Tcl_DStringAppendElement(dsPtr, "-xchar");
	Tcl_DStringStartSublist(dsPtr);
    }
    if (len==0 || (len>1 && strncmp(optionName, "-xchar", len)==0)) {
	IOSTATE iostate;
	valid = 1;

	GETIOSTATE(fsPtr->fd, &iostate);
	sprintf(buf, "%c", iostate.c_cc[VSTART]);
	Tcl_DStringAppendElement(dsPtr, buf);
	sprintf(buf, "%c", iostate.c_cc[VSTOP]);
	Tcl_DStringAppendElement(dsPtr, buf);
    }
    if (len == 0) {
	Tcl_DStringEndSublist(dsPtr);
    }

    /*
     * get option -queue
     * option is readonly and returned by [fconfigure chan -queue]
     * but not returned by unnamed [fconfigure chan]
     */
    if ((len > 1) && (strncmp(optionName, "-queue", len) == 0)) {
	int inQueue=0, outQueue=0;
	int inBuffered, outBuffered;
	valid = 1;
#ifdef GETREADQUEUE
	GETREADQUEUE(fsPtr->fd, inQueue);
#endif /* GETREADQUEUE */
#ifdef GETWRITEQUEUE
	GETWRITEQUEUE(fsPtr->fd, outQueue);
#endif /* GETWRITEQUEUE */
	inBuffered  = Tcl_InputBuffered(fsPtr->channel);
	outBuffered = Tcl_OutputBuffered(fsPtr->channel);

	sprintf(buf, "%d", inBuffered+inQueue);
	Tcl_DStringAppendElement(dsPtr, buf);
	sprintf(buf, "%d", outBuffered+outQueue);
	Tcl_DStringAppendElement(dsPtr, buf);
    }

    /*
     * get option -ttystatus
     * option is readonly and returned by [fconfigure chan -ttystatus]
     * but not returned by unnamed [fconfigure chan]
     */
    if ((len > 4) && (strncmp(optionName, "-ttystatus", len) == 0)) {
	int status;
	valid = 1;
	GETCONTROL(fsPtr->fd, &status);
	TtyModemStatusStr(status, dsPtr);
    }
#endif /* USE_TERMIOS */

    if (valid) {
d711 1
a711 6
	return Tcl_BadChannelOption(interp, optionName,
#ifdef USE_TERMIOS
	    "mode queue ttystatus xchar");
#else /* !USE_TERMIOS */
	    "mode");
#endif /* USE_TERMIOS */
d719 2
a720 2
#   endif /* B4800 == 4800 */
#endif /* B4800 */
d725 1
a725 1
#else /* !DIRECT_BAUD */
d841 1
a841 1

d844 1
a844 1

d886 1
a886 1

d895 1
a895 1
#endif /* !DIRECT_BAUD */
d913 1
a913 1

d928 1
a928 1

d933 1
a933 1
	case PARENB | PARODD	      : parity = 'o'; break;
d935 1
a935 1
	case PARENB | PARODD | PAREXT : parity = 'm'; break;
d937 1
a937 1
#else /* !PAREXT */
d940 1
a940 1
	case PARENB | PARODD	      : parity = 'o'; break;
d942 1
a942 1
#endif /* !PAREXT */
d948 1
a948 1
#endif /* USE_TERMIOS */
d956 1
a956 1
	case PARENB | PARODD	      : parity = 'o'; break;
d958 1
a958 1
	case PARENB | PARODD | PAREXT : parity = 'm'; break;
d965 1
a965 1
#endif /* USE_TERMIO */
d980 1
a980 1
#endif /* USE_SGTTY */
d1003 1
a1003 1

d1029 1
a1029 1
#endif /* PAREXT */
d1112 1
a1112 1

d1145 1
a1145 1
#endif /* PAREXT|USE_TERMIO */
d1153 1
a1153 1
#endif /* PAREXT|USE_TERMIO */
a1182 3
 *	Note that no initialization happens if the initialize flag
 *	is not set; this is necessary for the correct handling of
 *	UNIX console TTYs at startup.
d1185 1
a1185 2
 *	A pointer to a FileState suitable for use with Tcl_CreateChannel
 *	and the ttyChannelType structure.
d1189 1
a1189 2
 *	sockets (if initialize flag is non-zero.)  All other modes can
 *	be simulated on top of this in Tcl.
d1195 1
a1195 1
TtyInit(fd, initialize)
a1197 1
    int initialize;
d1199 1
d1204 20
a1223 20
    ttyPtr->stateUpdated = 0;
    if (initialize) {
	IOSTATE iostate = ttyPtr->savedState;

#if defined(USE_TERMIOS) || defined(USE_TERMIO)
	if (iostate.c_iflag != IGNBRK ||
		iostate.c_oflag != 0 ||
		iostate.c_lflag != 0 ||
		iostate.c_cflag & CREAD ||
		iostate.c_cc[VMIN] != 1 ||
		iostate.c_cc[VTIME] != 0) {
	    ttyPtr->stateUpdated = 1;
	}
	iostate.c_iflag = IGNBRK;
	iostate.c_oflag = 0;
	iostate.c_lflag = 0;
	iostate.c_cflag |= CREAD;
	iostate.c_cc[VMIN] = 1;
	iostate.c_cc[VTIME] = 0;
#endif	/* USE_TERMIOS|USE_TERMIO */
d1226 2
a1227 6
	if ((iostate.sg_flags & (EVENP | ODDP)) ||
		!(iostate.sg_flags & RAW)) {
	    ttyPtr->stateUpdated = 1;
	}
	iostate.sg_flags &= (EVENP | ODDP);
	iostate.sg_flags |= RAW;
d1230 1
a1230 8
	/*
	 * Only update if we're changing anything to avoid possible
	 * blocking.
	 */
	if (ttyPtr->stateUpdated) {
	    SETIOSTATE(fd, &iostate);
	}
    }
d1256 1
a1256 1
TclpOpenFileChannel(interp, pathPtr, mode, permissions)
d1258 4
a1261 3
					 * can be NULL. */
    Tcl_Obj *pathPtr;			/* Name of file to open. */
    int mode;				/* POSIX open mode. */
d1263 2
a1264 2
					 * file, with what modes to create
					 * it? */
d1266 1
a1266 1
    int fd, channelPermissions;
d1268 1
a1268 1
    CONST char *native, *translation;
d1270 1
a1271 4
#ifdef SUPPORTS_TTY
    int ctl_tty;
#endif /* SUPPORTS_TTY */
#ifdef DEPRECATED
a1272 1
#endif /* DEPRECATED */
d1274 4
d1289 3
a1291 3
	    /*
	     * This may occurr if modeString was "", for example.
	     */
d1296 1
a1296 1
    native = Tcl_FSGetNativePath(pathPtr);
d1300 4
a1303 4
    fd = TclOSopen(native, mode, permissions);
#ifdef SUPPORTS_TTY
    ctl_tty = (strcmp (native, "/dev/tty") == 0);
#endif /* SUPPORTS_TTY */
d1306 5
a1310 6
	if (interp != (Tcl_Interp *) NULL) {
	    Tcl_AppendResult(interp, "couldn't open \"", 
		    Tcl_GetString(pathPtr), "\": ",
		    Tcl_PosixError(interp), (char *) NULL);
	}
	return NULL;
d1317 1
a1317 1

d1319 1
a1319 1

d1321 1
a1321 1

d1323 1
a1323 1
    if (!ctl_tty && isatty(fd)) {
d1331 1
a1331 1

d1334 1
a1334 1
	fsPtr = TtyInit(fd, 1);
a1342 1
#ifdef DEPRECATED
a1344 1
#endif /* DEPRECATED */
d1347 1
a1347 1

d1351 11
d1370 1
a1370 1

d1401 1
a1401 1
				 * TCL_WRITABLE to indicate file mode. */
a1405 2
    Tcl_ChannelType *channelTypePtr;
#ifdef DEPRECATED
a1406 3
#endif /* DEPRECATED */
    int socketType = 0;
    socklen_t argLength = sizeof(int);
d1409 1
a1409 1
	return NULL;
d1412 1
d1418 1
a1418 2

#ifdef DEPRECATED
a1424 20
#endif /* DEPRECATED */

#ifdef SUPPORTS_TTY
    if (isatty(fd)) {
	fsPtr = TtyInit(fd, 0);
	channelTypePtr = &ttyChannelType;
	sprintf(channelName, "serial%d", fd);
    } else
#endif /* SUPPORTS_TTY */
    if (getsockopt(fd, SOL_SOCKET, SO_TYPE, (VOID *)&socketType,
		   &argLength) == 0  &&	 socketType == SOCK_STREAM) {
	/*
	 * The mode parameter gets lost here, unfortunately.
	 */
	return Tcl_MakeTcpClientChannel((ClientData) fd);
    } else {
	channelTypePtr = &fileChannelType;
	fsPtr = (FileState *) ckalloc((unsigned) sizeof(FileState));
	sprintf(channelName, "file%d", fd);
    }
d1426 1
a1426 1
#ifdef DEPRECATED
d1429 1
a1429 1
#endif /* DEPRECATED */
d1432 3
a1434 3
    fsPtr->channel = Tcl_CreateChannel(channelTypePtr, channelName,
	    (ClientData) fsPtr, mode);

d1460 2
a1461 2
					 * TCL_MODE_BLOCKING or
					 * TCL_MODE_NONBLOCKING. */
d1465 2
a1466 2

#ifndef USE_FIONBIO
d1469 2
a1470 2
	statePtr->flags &= (~(TCP_ASYNC_SOCKET));
	setting &= (~(O_NONBLOCK));
d1472 2
a1473 2
	statePtr->flags |= TCP_ASYNC_SOCKET;
	setting |= O_NONBLOCK;
d1476 1
a1476 1
	return errno;
d1478 3
a1480 1
#else /* USE_FIONBIO */
d1482 5
a1486 5
	statePtr->flags &= (~(TCP_ASYNC_SOCKET));
	setting = 0;
	if (ioctl(statePtr->fd, (int) FIONBIO, &setting) == -1) {
	    return errno;
	}
d1488 5
a1492 5
	statePtr->flags |= TCP_ASYNC_SOCKET;
	setting = 1;
	if (ioctl(statePtr->fd, (int) FIONBIO, &setting) == -1) {
	    return errno;
	}
d1494 1
a1494 1
#endif /* !USE_FIONBIO */
d1529 1
a1529 1

d1531 7
a1537 7
	if (statePtr->flags & TCP_ASYNC_SOCKET) {
	    timeOut = 0;
	} else {
	    timeOut = -1;
	}
	errno = 0;
	state = TclUnixWaitForFile(statePtr->fd,
d1539 21
a1559 19
	if (!(statePtr->flags & TCP_ASYNC_SOCKET)) {
#ifndef USE_FIONBIO
	    flags = fcntl(statePtr->fd, F_GETFL);
	    flags &= (~(O_NONBLOCK));
	    (void) fcntl(statePtr->fd, F_SETFL, flags);
#else /* USE_FIONBIO */
	    flags = 0;
	    (void) ioctl(statePtr->fd, FIONBIO, &flags);
#endif /* !USE_FIONBIO */
	}
	if (state & TCL_EXCEPTION) {
	    return -1;
	}
	if (state & TCL_WRITABLE) {
	    statePtr->flags &= (~(TCP_ASYNC_CONNECT));
	} else if (timeOut == 0) {
	    *errorCodePtr = errno = EWOULDBLOCK;
	    return -1;
	}
d1592 1
a1592 1
					 * in the buffer? */
d1601 1
a1601 1
	return -1;
d1605 1
a1605 1
	return bytesRead;
a1607 3
	/*
	 * Turn ECONNRESET into a soft EOF condition.
	 */
d1609 5
a1613 1
	return 0;
d1643 1
a1643 1
    CONST char *buf;			/* The data buffer. */
d1654 1
a1654 1
	return -1;
d1658 1
a1658 1
	return written;
d1722 1
a1722 1
 *	list of all options and their values is returned in the
d1733 3
a1735 3
    ClientData instanceData;	 /* Socket state. */
    Tcl_Interp *interp;		 /* For error reporting - can be NULL. */
    CONST char *optionName;	 /* Name of the option to
d1739 1
a1739 1
    Tcl_DString *dsPtr;		 /* Where to store the computed
d1746 1
a1746 1
    socklen_t size = sizeof(struct sockaddr_in);
d1751 1
a1751 1
	len = strlen(optionName);
d1756 1
a1756 1
	socklen_t optlen = sizeof(int);
d1758 2
a1759 1

d1768 1
a1768 1
	return TCL_OK;
d1772 3
a1774 3
	    ((len > 1) && (optionName[1] == 'p') &&
		    (strncmp(optionName, "-peername", len) == 0))) {
	if (getpeername(statePtr->fd, (struct sockaddr *) &peername,
d1776 6
a1781 6
	    if (len == 0) {
		Tcl_DStringAppendElement(dsPtr, "-peername");
		Tcl_DStringStartSublist(dsPtr);
	    }
	    Tcl_DStringAppendElement(dsPtr, inet_ntoa(peername.sin_addr));
	    hostEntPtr = gethostbyaddr(			/* INTL: Native. */
d1784 1
a1784 1
	    if (hostEntPtr != NULL) {
d1788 28
a1815 27
		Tcl_DStringAppendElement(dsPtr, Tcl_DStringValue(&ds));
	    } else {
		Tcl_DStringAppendElement(dsPtr, inet_ntoa(peername.sin_addr));
	    }
	    TclFormatInt(buf, ntohs(peername.sin_port));
	    Tcl_DStringAppendElement(dsPtr, buf);
	    if (len == 0) {
		Tcl_DStringEndSublist(dsPtr);
	    } else {
		return TCL_OK;
	    }
	} else {
	    /*
	     * getpeername failed - but if we were asked for all the options
	     * (len==0), don't flag an error at that point because it could
	     * be an fconfigure request on a server socket. (which have
	     * no peer). same must be done on win&mac.
	     */

	    if (len) {
		if (interp) {
		    Tcl_AppendResult(interp, "can't get peername: ",
			    Tcl_PosixError(interp), (char *) NULL);
		}
		return TCL_ERROR;
	    }
	}
d1819 10
a1828 10
	    ((len > 1) && (optionName[1] == 's') &&
	    (strncmp(optionName, "-sockname", len) == 0))) {
	if (getsockname(statePtr->fd, (struct sockaddr *) &sockname,
		&size) >= 0) {
	    if (len == 0) {
		Tcl_DStringAppendElement(dsPtr, "-sockname");
		Tcl_DStringStartSublist(dsPtr);
	    }
	    Tcl_DStringAppendElement(dsPtr, inet_ntoa(sockname.sin_addr));
	    hostEntPtr = gethostbyaddr(			/* INTL: Native. */
d1830 2
a1831 2
		    sizeof(sockname.sin_addr), AF_INET);
	    if (hostEntPtr != (struct hostent *) NULL) {
d1835 12
a1846 12
		Tcl_DStringAppendElement(dsPtr, Tcl_DStringValue(&ds));
	    } else {
		Tcl_DStringAppendElement(dsPtr, inet_ntoa(sockname.sin_addr));
	    }
	    TclFormatInt(buf, ntohs(sockname.sin_port));
	    Tcl_DStringAppendElement(dsPtr, buf);
	    if (len == 0) {
		Tcl_DStringEndSublist(dsPtr);
	    } else {
		return TCL_OK;
	    }
	} else {
d1849 2
a1850 1
			Tcl_PosixError(interp), (char *) NULL);
d1857 1
a1857 1
	return Tcl_BadChannelOption(interp, optionName, "peername sockname");
d1884 2
a1885 2
					 * combination of TCL_READABLE,
					 * TCL_WRITABLE and TCL_EXCEPTION. */
d1959 1
a1959 1
    CONST char *host;		/* Name of host on which to open port.
d1963 1
a1963 1
    CONST char *myaddr;		/* Optional client-side address */
d1966 2
a1967 2
				 * attempt to do an async connect. Otherwise
				 * do a synchronous connect or bind. */
d1995 1
a1995 1

d2005 1
d2010 1
a2010 1

d2015 1
a2015 1
		sizeof(struct sockaddr));
d2023 1
a2023 1
		    (char *) &curState, sizeof(curState));
d2038 22
a2059 20
	if (async) {
#ifndef USE_FIONBIO
	    origState = fcntl(sock, F_GETFL);
	    curState = origState | O_NONBLOCK;
	    status = fcntl(sock, F_SETFL, curState);
#else /* USE_FIONBIO */
	    curState = 1;
	    status = ioctl(sock, FIONBIO, &curState);
#endif /* !USE_FIONBIO */
	} else {
	    status = 0;
	}
	if (status > -1) {
	    status = connect(sock, (struct sockaddr *) &sockaddr,
		    sizeof(sockaddr));
	    if (status < 0) {
		if (errno == EINPROGRESS) {
		    asyncConnect = 1;
		    status = 0;
		}
d2073 3
a2075 1
#else /* USE_FIONBIO */
d2078 1
a2078 1
#endif /* !USE_FIONBIO */
d2081 1
a2081 1
	}
d2086 8
a2093 8
	if (interp != NULL) {
	    Tcl_AppendResult(interp, "couldn't open socket: ",
		    Tcl_PosixError(interp), (char *) NULL);
	}
	if (sock != -1) {
	    close(sock);
	}
	return NULL;
d2103 1
a2103 1
	statePtr->flags = TCP_ASYNC_CONNECT;
d2111 1
a2111 1
	close(sock);
d2140 1
a2140 1
    CONST char *host;			/* Host.  NULL implies INADDR_ANY */
d2160 1
a2160 1
	addr.s_addr = inet_addr(native);		/* INTL: Native. */
d2165 7
a2171 7
	if (addr.s_addr == 0xFFFFFFFF) {
	    hostent = gethostbyname(native);		/* INTL: Native. */
	    if (hostent != NULL) {
		memcpy((VOID *) &addr,
			(VOID *) hostent->h_addr_list[0],
			(size_t) hostent->h_length);
	    } else {
d2173 2
a2174 2
		errno = EHOSTUNREACH;
#else /* !EHOSTUNREACH */
d2176 3
a2178 3
		errno = ENXIO;
#endif /* ENXIO */
#endif /* EHOSTUNREACH */
d2182 3
a2184 3
		return 0;	/* error */
	    }
	}
d2189 1
a2189 1

d2209 1
a2209 1
 *	The channel or NULL if failed.	An error message is returned
d2222 2
a2223 2
    CONST char *host;			/* Host on which to open port. */
    CONST char *myaddr;			/* Client-side address */
d2226 2
a2227 2
					 * asynchronous connect. Otherwise
					 * we do a blocking connect. */
d2247 1
a2247 1
	    (ClientData) statePtr, (TCL_READABLE | TCL_WRITABLE));
d2250 2
a2251 2
	Tcl_Close((Tcl_Interp *) NULL, statePtr->channel);
	return NULL;
a2280 1
    statePtr->flags = 0;
d2285 1
a2285 1

d2287 1
a2287 1
	    (ClientData) statePtr, (TCL_READABLE | TCL_WRITABLE));
d2290 2
a2291 2
	Tcl_Close((Tcl_Interp *) NULL, statePtr->channel);
	return NULL;
d2317 1
a2317 1
					 * NULL. */
d2319 1
a2319 1
    CONST char *myHost;			/* Name of local host. */
d2321 1
a2321 1
					 * from new clients. */
d2345 1
a2345 1
	    (ClientData) statePtr);
d2348 1
a2348 1
	    (ClientData) statePtr, 0);
d2356 1
a2356 1
 *	Accept a TCP socket connection.	 This is called by the event loop.
d2378 1
a2378 1
    socklen_t len;				/* For accept interface */
d2386 1
a2386 1
	return;
d2395 1
a2395 1

d2402 1
a2402 1

a2443 6
    /*
     * Some #def's to make the code a little clearer!
     */
#define ZERO_OFFSET	((Tcl_SeekOffset) 0)
#define ERROR_OFFSET	((Tcl_SeekOffset) -1)

d2445 5
a2449 5
	case TCL_STDIN:
	    if ((TclOSseek(0, ZERO_OFFSET, SEEK_CUR) == ERROR_OFFSET)
		    && (errno == EBADF)) {
		return (Tcl_Channel) NULL;
	    }
d2452 7
a2458 7
	    bufMode = "line";
	    break;
	case TCL_STDOUT:
	    if ((TclOSseek(1, ZERO_OFFSET, SEEK_CUR) == ERROR_OFFSET)
		    && (errno == EBADF)) {
		return (Tcl_Channel) NULL;
	    }
d2461 7
a2467 7
	    bufMode = "line";
	    break;
	case TCL_STDERR:
	    if ((TclOSseek(2, ZERO_OFFSET, SEEK_CUR) == ERROR_OFFSET)
		    && (errno == EBADF)) {
		return (Tcl_Channel) NULL;
	    }
d2471 1
a2471 1
	    break;
a2476 3
#undef ZERO_OFFSET
#undef ERROR_OFFSET

d2486 1
a2486 5
    if (Tcl_GetChannelType(channel) == &fileChannelType) {
	Tcl_SetChannelOption(NULL, channel, "-translation", "auto");
    } else {
	Tcl_SetChannelOption(NULL, channel, "-translation", "auto crlf");
    }
d2516 1
a2516 1
    CONST char *string;		/* String that identifies file. */
d2522 2
a2523 2
				 * check that the channel is open for the
				 * requested mode. */
d2532 1
a2532 1

d2535 1
a2535 1
	return TCL_ERROR;
d2538 3
a2540 3
	Tcl_AppendResult(interp,
		"\"", string, "\" wasn't opened for writing", (char *) NULL);
	return TCL_ERROR;
d2542 3
a2544 3
	Tcl_AppendResult(interp,
		"\"", string, "\" wasn't opened for reading", (char *) NULL);
	return TCL_ERROR;
d2557 1
a2557 1
#endif /* SUPPORTS_TTY */
d2560 1
a2560 1
	if (Tcl_GetChannelHandle(chan,
d2570 1
a2570 1

d2583 2
a2584 2
	    "\" cannot be used to get a FILE *", (char *) NULL);
    return TCL_ERROR;	     
d2637 1
a2637 1
	Tcl_GetTime(&now);
d2663 1
a2663 1

d2682 1
a2682 1

d2727 1
a2727 1
	Tcl_GetTime(&now);
d2736 2
@


1.1
log
@Initial revision
@
text
@d8 1
d13 1
a13 1
 * RCS: @@(#) $Id: tclUnixChan.c,v 1.10 1999/01/26 03:53:39 jingham Exp $
d44 2
d48 3
d54 3
d60 6
a65 1
#endif	/* USE_SGTTY */
a69 12
 * The following structure is used to set or get the serial port
 * attributes in a platform-independant manner.
 */
 
typedef struct TtyAttrs {
    int baud;
    int parity;
    int data;
    int stop;
} TtyAttrs;

/*
d83 2
d86 2
a87 1
 * List of all file channels currently open.
d90 31
a120 1
static FileState *firstFilePtr = NULL;
d208 3
a210 3
static int		TtyParseMode _ANSI_ARGS_((Tcl_Interp *interp,
			    CONST char *mode, int *speedPtr, int *parityPtr,
			    int *dataPtr, int *stopPtr));
d216 4
a219 1
static void		TtyInit _ANSI_ARGS_((int fd));
d225 1
d246 1
d255 1
a255 1
    FileCloseProc,			/* Close proc. */
d264 1
d447 1
d450 5
d461 1
a461 1
    for (nextPtrPtr = &firstFilePtr; (*nextPtrPtr) != NULL;
d505 1
a505 1
    newLoc = lseek(fsPtr->fd, offset, mode);
d558 1
a558 1
 *	Called from Tcl_GetChannelFile to retrieve OS handles from
d586 31
d626 1
a626 1
 *	A standard Tcl result. Also sets interp->result on error if
d695 1
a695 1
    char buf[32];
a900 59
 * TtyInit --
 *
 *	Given file descriptor that refers to a serial port, 
 *	initialize the serial port to a set of sane values so that
 *	Tcl can talk to a device located on the serial port.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Serial device initialized.
 *
 *---------------------------------------------------------------------------
 */

static void
TtyInit(fd)
    int fd;			/* Open file descriptor for serial port to
				 * be initialized. */
{
#ifdef USE_TERMIOS
    struct termios termios;

    tcgetattr(fd, &termios);
    termios.c_iflag = IGNBRK;
    termios.c_oflag = 0;
    termios.c_lflag = 0;
    termios.c_cflag |= CREAD;
    termios.c_cc[VMIN] = 60;
    termios.c_cc[VTIME] = 2;
    tcsetattr(fd, TCSANOW, &termios);
#else	/* !USE_TERMIOS */
#ifdef USE_TERMIO
    struct termio termio;

    ioctl(fd, TCGETA, &termio);
    termio.c_iflag = IGNBRK;
    termio.c_oflag = 0;
    termio.c_lflag = 0;
    termio.c_cflag |= CREAD;
    termio.c_cc[VMIN] = 60;
    termio.c_cc[VTIME] = 2;
    ioctl(fd, TCSETAW, &termio);
#else	/* !USE_TERMIO */
#ifdef USE_SGTTY
    struct sgttyb sgttyb;

    ioctl(fd, TIOCGETP, &sgttyb);
    sgttyb.sg_flags &= (EVENP | ODDP);
    sgttyb.sg_flags |= RAW;
    ioctl(fd, TIOCSETP, &sgttyb);
#endif	/* USE_SGTTY */
#endif	/* !USE_TERMIO */
#endif	/* !USE_TERMIOS */
}

/*
 *---------------------------------------------------------------------------
 *
d921 5
d927 1
a927 5
    int parity, data;
    struct termios termios;

    tcgetattr(fd, &termios);
    ttyPtr->baud = TtyGetBaud(cfgetospeed(&termios));
d931 1
a931 1
    switch ((int) (termios.c_cflag & (PARENB | PARODD | PAREXT))) {
d938 1
a938 1
    switch ((int) (termios.c_cflag & (PARENB | PARODD))) {
a942 1
    ttyPtr->parity = parity;
d944 5
a948 3
    data = termios.c_cflag & CSIZE;
    ttyPtr->data = (data == CS5) ? 5 : (data == CS6) ? 6 :
	    (data == CS7) ? 7 : 8;
a949 2
    ttyPtr->stop = (termios.c_cflag & CSTOPB) ? 2 : 1;
#else	/* !USE_TERMIOS */
d951 1
a951 2
    int parity, data;
    struct termio termio;
a952 2
    ioctl(fd, TCGETA, &termio);
    ttyPtr->baud = TtyGetBaud(termio.c_cflag & CBAUD);
d954 1
a954 1
    switch (termio.c_cflag & (PARENB | PARODD | PAREXT)) {
a959 1
    ttyPtr->parity = parity;
d961 5
a965 3
    data = termio.c_cflag & CSIZE;
    ttyPtr->data = (data == CS5) ? 5 : (data == CS6) ? 6 :
	    (data == CS7) ? 7 : 8;
a966 2
    ttyPtr->stop = (termio.c_cflag & CSTOPB) ? 2 : 1;
#else	/* !USE_TERMIO */
d968 1
a968 2
    int parity;
    struct sgttyb sgttyb;
a969 2
    ioctl(fd, TIOCGETP, &sgttyb);
    ttyPtr->baud = TtyGetBaud(sgttyb.sg_ospeed);
d971 1
a971 1
    if (sgttyb.sg_flags & EVENP) {
d973 1
a973 1
    } else if (sgttyb.sg_flags & ODDP) {
d976 10
a985 11
    ttyPtr->parity = parity;
    ttyPtr->data = (sgttyb.sg_flags & (EVENP | ODDP)) ? 7 : 8;
    ttyPtr->stop = 1;
#else	/* !USE_SGTTY */
    ttyPtr->baud = 0;
    ttyPtr->parity = 'n';
    ttyPtr->data = 0;
    ttyPtr->stop = 0;
#endif	/* !USE_SGTTY */
#endif	/* !USE_TERMIO */
#endif	/* !USE_TERMIOS */
d1011 2
a1014 1
    struct termios termios;
d1016 3
a1018 3
    tcgetattr(fd, &termios);
    cfsetospeed(&termios, TtyGetSpeed(ttyPtr->baud));
    cfsetispeed(&termios, TtyGetSpeed(ttyPtr->baud));
d1025 1
a1025 1
	termios.c_cflag &= ~PAREXT;
d1040 4
a1043 3
    termios.c_cflag &= ~(PARENB | PARODD | CSIZE | CSTOPB);
    termios.c_cflag |= flag;
    tcsetattr(fd, TCSANOW, &termios);
a1044 1
#else	/* !USE_TERMIOS */
a1046 1
    struct termio termio;
d1048 3
a1050 3
    ioctl(fd, TCGETA, &termio);
    termio.c_cflag &= ~CBAUD;
    termio.c_cflag |= TtyGetSpeed(ttyPtr->baud);
d1069 4
a1072 3
    termio.c_cflag &= ~(PARENB | PARODD | PAREXT | CSIZE | CSTOPB);
    termio.c_cflag |= flag;
    ioctl(fd, TCSETAW, &termio);
a1073 1
#else	/* !USE_TERMIO */
a1075 1
    struct sgttyb sgttyb;
d1077 3
a1079 3
    ioctl(fd, TIOCGETP, &sgttyb);
    sgttyb.sg_ospeed = TtyGetSpeed(ttyPtr->baud);
    sgttyb.sg_ispeed = TtyGetSpeed(ttyPtr->baud);
d1083 2
a1084 2
	sgttyb.sg_flags &= ~ODDP;
	sgttyb.sg_flags |= EVENP;
d1086 2
a1087 2
	sgttyb.sg_flags &= ~EVENP;
	sgttyb.sg_flags |= ODDP;
a1088 1
    ioctl(fd, TIOCSETP, &sgttyb);
d1090 2
a1091 2
#endif	/* !USE_TERMIO */
#endif	/* !USE_TERMIOS */
d1105 1
a1105 1
 *	error message is left in interp->result (if interp is non-NULL).
d1135 12
a1146 1
    if (strchr("noems", parity) == NULL) {
d1149 6
a1154 1
		    " parity: should be n, o, e, m, or s", NULL);
d1176 61
d1246 1
a1246 1
 *	left in interp->result if interp is not NULL.
d1268 3
a1270 2
    char *nativeName, channelName[20];
    Tcl_DString buffer;
d1272 1
d1296 2
a1297 2
    nativeName = Tcl_TranslateFileName(interp, fileName, &buffer);
    if (nativeName == NULL) {
d1300 3
a1302 7
    fd = open(nativeName, mode, permissions);

    /*
     * If nativeName is not NULL, the buffer is valid and we must free
     * the storage.
     */
    
d1322 1
a1322 6
    fsPtr = (FileState *) ckalloc((unsigned) sizeof(FileState));
    fsPtr->nextPtr = firstFilePtr;
    firstFilePtr = fsPtr;
    fsPtr->validMask = channelPermissions | TCL_EXCEPTION;
    fsPtr->fd = fd;
    
d1332 1
a1332 1
	TtyInit(fd);
d1334 5
a1338 1
    } else {
d1340 1
d1343 5
d1362 1
a1362 1
    if (channelTypePtr == &ttyChannelType) {
d1372 1
a1372 1
		"auto crlf") != TCL_OK) {
d1404 1
a1404 1
    char channelName[20];
d1406 1
d1419 1
a1419 1
    for (fsPtr = firstFilePtr; fsPtr != NULL; fsPtr = fsPtr->nextPtr) {
d1421 2
a1422 1
	    return (mode == fsPtr->validMask) ? fsPtr->channel : NULL;
d1427 3
a1429 2
    fsPtr->nextPtr = firstFilePtr;
    firstFilePtr = fsPtr;
d1603 1
a1603 1
    bytesRead = recv(statePtr->fd, buf, bufSize, 0);
d1656 1
a1656 1
    written = send(statePtr->fd, buf, toWrite, 0);
d1699 1
a1699 1
    
d1748 1
a1748 1
    char buf[128];
d1754 17
d1774 2
a1775 2
        if (getpeername(statePtr->fd, (struct sockaddr *) &peername, &size)
		>= 0) {
d1781 8
a1788 4
            hostEntPtr = gethostbyaddr((char *) &(peername.sin_addr),
                    sizeof(peername.sin_addr), AF_INET);
            if (hostEntPtr != (struct hostent *) NULL) {
                Tcl_DStringAppendElement(dsPtr, hostEntPtr->h_name);
d1792 1
a1792 1
            sprintf(buf, "%d", ntohs(peername.sin_port));
d1828 2
a1829 1
            hostEntPtr = gethostbyaddr((char *) &(sockname.sin_addr),
d1832 4
a1835 1
                Tcl_DStringAppendElement(dsPtr, hostEntPtr->h_name);
d1839 1
a1839 1
            sprintf(buf, "%d", ntohs(sockname.sin_port));
d1911 1
a1911 1
 *	Called from Tcl_GetChannelFile to retrieve OS handles from inside
d1946 2
a1947 2
 *	Returns a new TcpState, or NULL with an error in interp->result,
 *	if interp is not NULL.
d2060 21
a2080 1
            }
d2106 1
a2106 1
    
d2152 15
a2166 3
        addr.s_addr = inet_addr(host);
        if (addr.s_addr == -1) {
            hostent = gethostbyname(host);
d2179 3
d2185 3
d2230 1
a2230 1
    char channelName[20];
d2277 1
a2277 1
    char channelName[20];
d2305 1
a2305 1
 *	error message is left in interp->result if interp is
d2325 1
a2325 1
    char channelName[20];
d2379 1
a2379 1
    char channelName[20];
d2384 1
a2384 1
    newsock = accept(sockState->fd, (struct sockaddr *)&addr, &len);
d2400 2
a2401 2
    newSockState->acceptProc = (Tcl_TcpAcceptProc *) NULL;
    newSockState->acceptProcData = (ClientData) NULL;
d2407 2
a2408 2
    Tcl_SetChannelOption((Tcl_Interp *) NULL, newSockState->channel,
	    "-translation", "auto crlf");
d2410 2
a2411 2
    if (sockState->acceptProc != (Tcl_TcpAcceptProc *) NULL) {
	(sockState->acceptProc) (sockState->acceptProcData,
d2420 1
a2420 1
 * TclGetDefaultStdChannel --
d2436 1
a2436 1
TclGetDefaultStdChannel(type)
d2478 3
d2505 1
a2505 1
 *	left in interp->result.
d2554 5
a2558 1
    if ((chanTypePtr == &fileChannelType) || (chanTypePtr == &tcpChannelType)
d2626 1
a2626 1
    static fd_mask readyMasks[3*MASK_SIZE];
d2736 2
@


1.1.1.1
log
@import dejagnu-1999-11-08 snapshot
@
text
@@


1.1.1.2
log
@Tcl 8.3 upgrade
@
text
@a7 1
 * Copyright (c) 1998-1999 by Scriptics Corporation.
d12 1
a12 1
 * RCS: @@(#) $Id: tclUnixChan.c,v 1.6.8.2 2000/09/15 16:58:22 spolk Exp $
a42 2
#define SUPPORTS_TTY

a44 3
#   define IOSTATE			struct termios
#   define GETIOSTATE(fd, statePtr)	tcgetattr((fd), (statePtr))
#   define SETIOSTATE(fd, statePtr)	tcsetattr((fd), TCSADRAIN, (statePtr))
a47 3
#   define IOSTATE			struct termio
#   define GETIOSTATE(fd, statePtr)	ioctl((fd), TCGETA, (statePtr))
#   define SETIOSTATE(fd, statePtr)	ioctl((fd), TCSETAW, (statePtr))
d51 1
a51 6
#   define IOSTATE			struct sgttyb
#   define GETIOSTATE(fd, statePtr)	ioctl((fd), TIOCGETP, (statePtr))
#   define SETIOSTATE(fd, statePtr)	ioctl((fd), TIOCSETP, (statePtr))
#else	/* !USE_SGTTY */
#   undef SUPPORTS_TTY
#endif	/* !USE_SGTTY */
d56 12
a80 2
#ifdef SUPPORTS_TTY

d82 1
a82 2
 * The following structure describes per-instance state of a tty-based
 * channel.
d85 1
a85 31
typedef struct TtyState {
    FileState fs;		/* Per-instance state of the file
				 * descriptor.  Must be the first field. */
    IOSTATE savedState;		/* Initial state of device.  Used to reset
				 * state when device closed. */
} TtyState;

/*
 * The following structure is used to set or get the serial port
 * attributes in a platform-independant manner.
 */
 
typedef struct TtyAttrs {
    int baud;
    int parity;
    int data;
    int stop;
} TtyAttrs;

#endif	/* !SUPPORTS_TTY */

typedef struct ThreadSpecificData {
    /*
     * List of all file channels currently open.  This is per thread and is
     * used to match up fd's to channels, which rarely occurs.
     */
    
    FileState *firstFilePtr;
} ThreadSpecificData;

static Tcl_ThreadDataKey dataKey;
d173 3
a175 3
#ifdef SUPPORTS_TTY
static int		TtyCloseProc _ANSI_ARGS_((ClientData instanceData,
			    Tcl_Interp *interp));
d181 1
a181 4
static FileState *	TtyInit _ANSI_ARGS_((int fd));
static int		TtyParseMode _ANSI_ARGS_((Tcl_Interp *interp,
			    CONST char *mode, int *speedPtr, int *parityPtr,
			    int *dataPtr, int *stopPtr));
a186 1
#endif	/* SUPPORTS_TTY */
a206 1
#ifdef SUPPORTS_TTY
d215 1
a215 1
    TtyCloseProc,			/* Close proc. */
a223 1
#endif	/* SUPPORTS_TTY */
a405 1
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
a407 5

    /*
     * Do not close standard channels while in thread-exit.
     */

d414 1
a414 1
    for (nextPtrPtr = &(tsdPtr->firstFilePtr); (*nextPtrPtr) != NULL;
d458 1
a458 1
    newLoc = lseek(fsPtr->fd, (off_t) offset, mode);
d511 1
a511 1
 *	Called from Tcl_GetChannelHandle to retrieve OS handles from
a538 31

#ifdef SUPPORTS_TTY 

/*
 *----------------------------------------------------------------------
 *
 * TtyCloseProc --
 *
 *	This procedure is called from the generic IO level to perform
 *	channel-type-specific cleanup when a tty based channel is closed.
 *
 * Results:
 *	0 if successful, errno if failed.
 *
 * Side effects:
 *	Restores the settings and closes the device of the channel.
 *
 *----------------------------------------------------------------------
 */

static int
TtyCloseProc(instanceData, interp)
    ClientData instanceData;	/* Tty state. */
    Tcl_Interp *interp;		/* For error reporting - unused. */
{
    TtyState *ttyPtr;

    ttyPtr = (TtyState *) instanceData;
    SETIOSTATE(ttyPtr->fs.fd, &ttyPtr->savedState);
    return FileCloseProc(instanceData, interp);
}
d548 1
a548 1
 *	A standard Tcl result. Also sets the interp's result on error if
d617 1
a617 1
    char buf[3 * TCL_INTEGER_SPACE + 16];
d823 59
d902 3
a904 2
    IOSTATE iostate;
    int baud, parity, data, stop;
d906 2
a907 4
    GETIOSTATE(fd, &iostate);

#ifdef USE_TERMIOS
    baud = TtyGetBaud(cfgetospeed(&iostate));
d911 1
a911 1
    switch ((int) (iostate.c_cflag & (PARENB | PARODD | PAREXT))) {
d918 1
a918 1
    switch ((int) (iostate.c_cflag & (PARENB | PARODD))) {
d923 1
d925 3
a927 5
    data = iostate.c_cflag & CSIZE;
    data = (data == CS5) ? 5 : (data == CS6) ? 6 : (data == CS7) ? 7 : 8;

    stop = (iostate.c_cflag & CSTOPB) ? 2 : 1;
#endif	/* USE_TERMIOS */
d929 2
d932 2
a933 1
    baud = TtyGetBaud(iostate.c_cflag & CBAUD);
d935 2
d938 1
a938 1
    switch (iostate.c_cflag & (PARENB | PARODD | PAREXT)) {
d944 1
d946 3
a948 5
    data = iostate.c_cflag & CSIZE;
    data = (data == CS5) ? 5 : (data == CS6) ? 6 : (data == CS7) ? 7 : 8;

    stop = (iostate.c_cflag & CSTOPB) ? 2 : 1;
#endif	/* USE_TERMIO */
d950 2
d953 2
a954 1
    baud = TtyGetBaud(iostate.sg_ospeed);
d956 2
d959 1
a959 1
    if (iostate.sg_flags & EVENP) {
d961 1
a961 1
    } else if (iostate.sg_flags & ODDP) {
d964 11
a974 10

    data = (iostate.sg_flags & (EVENP | ODDP)) ? 7 : 8;

    stop = 1;
#endif	/* USE_SGTTY */

    ttyPtr->baud    = baud;
    ttyPtr->parity  = parity;
    ttyPtr->data    = data;
    ttyPtr->stop    = stop;
a999 2
    IOSTATE iostate;

d1002 1
d1004 3
a1006 3
    GETIOSTATE(fd, &iostate);
    cfsetospeed(&iostate, TtyGetSpeed(ttyPtr->baud));
    cfsetispeed(&iostate, TtyGetSpeed(ttyPtr->baud));
d1013 1
a1013 1
	iostate.c_cflag &= ~PAREXT;
d1028 3
a1030 4
    iostate.c_cflag &= ~(PARENB | PARODD | CSIZE | CSTOPB);
    iostate.c_cflag |= flag;

#endif	/* USE_TERMIOS */
d1032 1
d1035 1
d1037 3
a1039 3
    GETIOSTATE(fd, &iostate);
    iostate.c_cflag &= ~CBAUD;
    iostate.c_cflag |= TtyGetSpeed(ttyPtr->baud);
d1058 3
a1060 4
    iostate.c_cflag &= ~(PARENB | PARODD | PAREXT | CSIZE | CSTOPB);
    iostate.c_cflag |= flag;

#endif	/* USE_TERMIO */
d1062 1
d1065 1
d1067 3
a1069 3
    GETIOSTATE(fd, &iostate);
    iostate.sg_ospeed = TtyGetSpeed(ttyPtr->baud);
    iostate.sg_ispeed = TtyGetSpeed(ttyPtr->baud);
d1073 2
a1074 2
	iostate.sg_flags &= ~ODDP;
	iostate.sg_flags |= EVENP;
d1076 2
a1077 2
	iostate.sg_flags &= ~EVENP;
	iostate.sg_flags |= ODDP;
d1079 1
d1081 2
a1082 2

    SETIOSTATE(fd, &iostate);
d1096 1
a1096 1
 *	error message is left in the interp's result (if interp is non-NULL).
d1126 1
a1126 12
    /*
     * Only allow setting mark/space parity on platforms that support it
     * Make sure to allow for the case where strchr is a macro.
     * [Bug: 5089]
     */
    if (
#if defined(PAREXT) || defined(USE_TERMIO)
	strchr("noems", parity) == NULL
#else
	strchr("noe", parity) == NULL
#endif
	) {
d1129 1
a1129 6
#if defined(PAREXT) || defined(USE_TERMIO)
		    " parity: should be n, o, e, m, or s",
#else
		    " parity: should be n, o, or e",
#endif
		    NULL);
a1150 61
 *---------------------------------------------------------------------------
 *
 * TtyInit --
 *
 *	Given file descriptor that refers to a serial port, 
 *	initialize the serial port to a set of sane values so that
 *	Tcl can talk to a device located on the serial port.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Serial device initialized to non-blocking raw mode, similar to
 *	sockets.  All other modes can be simulated on top of this in Tcl.
 *
 *---------------------------------------------------------------------------
 */

static FileState *
TtyInit(fd)
    int fd;			/* Open file descriptor for serial port to
				 * be initialized. */
{
    IOSTATE iostate;
    TtyState *ttyPtr;

    ttyPtr = (TtyState *) ckalloc((unsigned) sizeof(TtyState));
    GETIOSTATE(fd, &ttyPtr->savedState);

    iostate = ttyPtr->savedState;

#ifdef USE_TERMIOS
    iostate.c_iflag = IGNBRK;
    iostate.c_oflag = 0;
    iostate.c_lflag = 0;
    iostate.c_cflag |= CREAD;
    iostate.c_cc[VMIN] = 1;
    iostate.c_cc[VTIME] = 0;
#endif	/* USE_TERMIOS */

#ifdef USE_TERMIO
    iostate.c_iflag = IGNBRK;
    iostate.c_oflag = 0;
    iostate.c_lflag = 0;
    iostate.c_cflag |= CREAD;
    iostate.c_cc[VMIN] = 1;
    iostate.c_cc[VTIME] = 0;
#endif	/* USE_TERMIO */

#ifdef USE_SGTTY
    iostate.sg_flags &= (EVENP | ODDP);
    iostate.sg_flags |= RAW;
#endif	/* USE_SGTTY */

    SETIOSTATE(fd, &iostate);

    return &ttyPtr->fs;
}
#endif	/* SUPPORTS_TTY */

/*
d1160 1
a1160 1
 *	left in the interp's result if interp is not NULL.
d1182 2
a1183 3
    char *native, *translation;
    char channelName[16 + TCL_INTEGER_SPACE];
    Tcl_DString ds, buffer;
a1184 1
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
d1208 2
a1209 2
    native = Tcl_TranslateFileName(interp, fileName, &buffer);
    if (native == NULL) {
d1212 7
a1218 3
    native = Tcl_UtfToExternalDString(NULL, native, -1, &ds);
    fd = open(native, mode, permissions);		/* INTL: Native. */
    Tcl_DStringFree(&ds);    
d1238 6
a1243 1
#ifdef SUPPORTS_TTY
d1253 1
a1253 1
	translation = "auto crlf";
d1255 1
a1255 5
	fsPtr = TtyInit(fd);
    } else 
#endif	/* SUPPORTS_TTY */
    {
	translation = NULL;
a1256 1
	fsPtr = (FileState *) ckalloc((unsigned) sizeof(FileState));
a1258 5
    fsPtr->nextPtr = tsdPtr->firstFilePtr;
    tsdPtr->firstFilePtr = fsPtr;
    fsPtr->validMask = channelPermissions | TCL_EXCEPTION;
    fsPtr->fd = fd;
    
d1273 1
a1273 1
    if (translation != NULL) {
d1283 1
a1283 1
		translation) != TCL_OK) {
d1315 1
a1315 1
    char channelName[16 + TCL_INTEGER_SPACE];
a1316 1
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
d1329 1
a1329 1
    for (fsPtr = tsdPtr->firstFilePtr; fsPtr != NULL; fsPtr = fsPtr->nextPtr) {
d1331 1
a1331 2
	    return ((mode|TCL_EXCEPTION) == fsPtr->validMask) ?
		    fsPtr->channel : NULL;
d1336 2
a1337 3
    fsPtr->nextPtr = tsdPtr->firstFilePtr;
    tsdPtr->firstFilePtr = fsPtr;

d1511 1
a1511 1
    bytesRead = recv(statePtr->fd, buf, (size_t) bufSize, 0);
d1564 1
a1564 1
    written = send(statePtr->fd, buf, (size_t) toWrite, 0);
d1607 1
a1607 1

d1656 1
a1656 1
    char buf[TCL_INTEGER_SPACE];
a1661 17
    if ((len > 1) && (optionName[1] == 'e') &&
	    (strncmp(optionName, "-error", len) == 0)) {
	int optlen;
	int err, ret;
    
	optlen = sizeof(int);
	ret = getsockopt(statePtr->fd, SOL_SOCKET, SO_ERROR,
		(char *)&err, &optlen);
	if (ret < 0) {
	    err = errno;
	}
	if (err != 0) {
	    Tcl_DStringAppend(dsPtr, Tcl_ErrnoMsg(err), -1);
	}
       return TCL_OK;
    }

d1665 2
a1666 2
        if (getpeername(statePtr->fd, (struct sockaddr *) &peername,
		&size) >= 0) {
d1672 4
a1675 8
            hostEntPtr = gethostbyaddr(			/* INTL: Native. */
		    (char *) &peername.sin_addr,
		    sizeof(peername.sin_addr), AF_INET);
            if (hostEntPtr != NULL) {
		Tcl_DString ds;

		Tcl_ExternalToUtfDString(NULL, hostEntPtr->h_name, -1, &ds);
                Tcl_DStringAppendElement(dsPtr, Tcl_DStringValue(&ds));
d1679 1
a1679 1
            TclFormatInt(buf, ntohs(peername.sin_port));
d1715 1
a1715 2
            hostEntPtr = gethostbyaddr(			/* INTL: Native. */
		    (char *) &sockname.sin_addr,
d1718 1
a1718 4
		Tcl_DString ds;

		Tcl_ExternalToUtfDString(NULL, hostEntPtr->h_name, -1, &ds);
                Tcl_DStringAppendElement(dsPtr, Tcl_DStringValue(&ds));
d1722 1
a1722 1
            TclFormatInt(buf, ntohs(sockname.sin_port));
d1794 1
a1794 1
 *	Called from Tcl_GetChannelHandle to retrieve OS handles from inside
d1829 2
a1830 2
 *	Returns a new TcpState, or NULL with an error in the interp's
 *	result, if interp is not NULL.
d1943 1
a1943 21
	    } else {
		/*
		 * Here we are if the connect succeeds. In case of an
		 * asynchronous connect we have to reset the channel to
		 * blocking mode.  This appears to happen not very often,
		 * but e.g. on a HP 9000/800 under HP-UX B.11.00 we enter
		 * this stage. [Bug: 4388]
		 */
		if (async) {
#ifndef USE_FIONBIO
		    origState = fcntl(sock, F_GETFL);
		    curState = origState & ~(O_NONBLOCK);
		    status = fcntl(sock, F_SETFL, curState);
#endif

#ifdef  USE_FIONBIO
		    curState = 0;
		    status = ioctl(sock, FIONBIO, &curState);
#endif
		}
	    }
d1969 1
a1969 1

d2015 3
a2017 15
	Tcl_DString ds;
	CONST char *native;

	if (host == NULL) {
	    native = NULL;
	} else {
	    native = Tcl_UtfToExternalDString(NULL, host, -1, &ds);
	}
        addr.s_addr = inet_addr(native);		/* INTL: Native. */
	/*
	 * This is 0xFFFFFFFF to ensure that it compares as a 32bit -1
	 * on either 32 or 64 bits systems.
	 */
        if (addr.s_addr == 0xFFFFFFFF) {
            hostent = gethostbyname(native);		/* INTL: Native. */
a2029 3
		if (native != NULL) {
		    Tcl_DStringFree(&ds);
		}
a2032 3
	if (native != NULL) {
	    Tcl_DStringFree(&ds);
	}
d2075 1
a2075 1
    char channelName[16 + TCL_INTEGER_SPACE];
d2122 1
a2122 1
    char channelName[16 + TCL_INTEGER_SPACE];
d2150 1
a2150 1
 *	error message is left in the interp's result if interp is
d2170 1
a2170 1
    char channelName[16 + TCL_INTEGER_SPACE];
d2224 1
a2224 1
    char channelName[16 + TCL_INTEGER_SPACE];
d2229 1
a2229 1
    newsock = accept(sockState->fd, (struct sockaddr *) &addr, &len);
d2245 2
a2246 2
    newSockState->acceptProc = NULL;
    newSockState->acceptProcData = NULL;
d2252 2
a2253 2
    Tcl_SetChannelOption(NULL, newSockState->channel, "-translation",
	    "auto crlf");
d2255 2
a2256 2
    if (sockState->acceptProc != NULL) {
	(*sockState->acceptProc)(sockState->acceptProcData,
d2265 1
a2265 1
 * TclpGetDefaultStdChannel --
d2281 1
a2281 1
TclpGetDefaultStdChannel(type)
a2322 3
    if (channel == NULL) {
	return NULL;
    }
d2347 1
a2347 1
 *	left in the interp's result.
d2396 1
a2396 5
    if ((chanTypePtr == &fileChannelType)
#ifdef SUPPORTS_TTY
	    || (chanTypePtr == &ttyChannelType)
#endif	/* SUPPORTS_TTY */
	    || (chanTypePtr == &tcpChannelType)
d2464 1
a2464 1
    fd_mask readyMasks[3*MASK_SIZE];
a2573 2


@


1.1.1.3
log
@import tcl 8.4.0
@
text
@d13 1
a13 1
 * RCS: @@(#) $Id: tclUnixChan.c,v 1.39 2002/09/03 02:01:25 hobbs Exp $
d16 2
a17 2
#include "tclInt.h"	/* Internal definitions for Tcl. */
#include "tclPort.h"	/* Portability features for Tcl. */
d20 1
a20 1
 * sys/ioctl.h has already been included by tclPort.h.	Including termios.h
a47 6
#   ifdef HAVE_SYS_IOCTL_H
#	include <sys/ioctl.h>
#   endif /* HAVE_SYS_IOCTL_H */
#   ifdef HAVE_SYS_MODEM_H
#	include <sys/modem.h>
#   endif /* HAVE_SYS_MODEM_H */
a50 41
#   define GETCONTROL(fd, intPtr)	ioctl((fd), TIOCMGET, (intPtr))
#   define SETCONTROL(fd, intPtr)	ioctl((fd), TIOCMSET, (intPtr))
    /*
     * TIP #35 introduced a different on exit flush/close behavior that
     * doesn't work correctly with standard channels on all systems.
     * The problem is tcflush throws away waiting channel data.	 This may
     * be necessary for true serial channels that may block, but isn't
     * correct in the standard case.  This might be replaced with tcdrain
     * instead, but that can block.  For now, we revert to making this do
     * nothing, and TtyOutputProc being the same old FileOutputProc.
     * -- hobbs [Bug #525783]
     */
#   define BAD_TIP35_FLUSH 0
#   if BAD_TIP35_FLUSH
#	define TTYFLUSH(fd)		tcflush((fd), TCIOFLUSH);
#   else
#	define TTYFLUSH(fd)
#   endif /* BAD_TIP35_FLUSH */
#   ifdef FIONREAD
#	define GETREADQUEUE(fd, int)	ioctl((fd), FIONREAD, &(int))
#   elif defined(FIORDCHK)
#	define GETREADQUEUE(fd, int)	int = ioctl((fd), FIORDCHK, NULL)
#   endif /* FIONREAD */
#   ifdef TIOCOUTQ
#	define GETWRITEQUEUE(fd, int)	ioctl((fd), TIOCOUTQ, &(int))
#   endif /* TIOCOUTQ */
#   if defined(TIOCSBRK) && defined(TIOCCBRK)
/*
 * Can't use ?: operator below because that messes up types on either
 * Linux or Solaris (the two are mutually exclusive!)
 */
#	define SETBREAK(fd, flag) \
		if (flag) {				\
		    ioctl((fd), TIOCSBRK, NULL);	\
		} else {				\
		    ioctl((fd), TIOCCBRK, NULL);	\
		}
#   endif /* TIOCSBRK&TIOCCBRK */
#   if !defined(CRTSCTS) && defined(CNEW_RTSCTS)
#	define CRTSCTS CNEW_RTSCTS
#   endif /* !CRTSCTS&CNEW_RTSCTS */
a51 1

a57 1

a65 1

a78 1
#ifdef DEPRECATED
a80 1
#endif /* DEPRECATED */
d92 1
a92 3
				 * descriptor.	Must be the first field. */
    int stateUpdated;		/* Flag to say if the state has been
				 * modified and needs resetting. */
d101 1
a101 1

a110 7
#define UNSUPPORTED_OPTION(detail) \
	if (interp) {							\
	    Tcl_AppendResult(interp, (detail),				\
		    " not supported for this platform", (char *) NULL); \
	}

#ifdef DEPRECATED
d116 1
a116 1

a120 1
#endif /* DEPRECATED */
d151 8
a158 8
#ifndef SOMAXCONN
#   define SOMAXCONN	100
#endif /* SOMAXCONN */

#if (SOMAXCONN < 100)
#   undef  SOMAXCONN
#   define SOMAXCONN	100
#endif /* SOMAXCONN < 100 */
d172 2
a173 2
			    int port, CONST char *host, int server,
			    CONST char *myaddr, int myport, int async));
d176 1
a176 1
			    CONST char *host, int port));
d178 1
a178 1
			    ClientData instanceData, int mode));
d182 1
a182 1
			    int direction, ClientData *handlePtr));
d184 1
a184 1
			    char *buf, int toRead, int *errorCode));
d186 2
a187 2
			    ClientData instanceData, CONST char *buf,
			    int toWrite, int *errorCode));
a189 2
static Tcl_WideInt	FileWideSeekProc _ANSI_ARGS_((ClientData instanceData,
			    Tcl_WideInt offset, int mode, int *errorCode));
d191 1
a191 1
			    int mask));
d194 1
a194 1
			    int mode));
d198 1
a198 1
			    int direction, ClientData *handlePtr));
d200 1
a200 1
			    Tcl_Interp *interp, CONST char *optionName,
d203 1
a203 1
			    char *buf, int toRead,  int *errorCode));
d205 1
a205 1
			    CONST char *buf, int toWrite, int *errorCode));
d207 1
a207 1
			    int mask));
d214 1
a214 1
			    Tcl_Interp *interp, CONST char *optionName,
d216 1
a216 5
static FileState *	TtyInit _ANSI_ARGS_((int fd, int initialize));
#if BAD_TIP35_FLUSH
static int		TtyOutputProc _ANSI_ARGS_((ClientData instanceData,
			    CONST char *buf, int toWrite, int *errorCode));
#endif /* BAD_TIP35_FLUSH */
d223 2
a224 2
			    Tcl_Interp *interp, CONST char *optionName, 
			    CONST char *value));
d227 1
a227 1
			    int *errorCodePtr));
d234 10
a243 15
    "file",			/* Type name. */
    TCL_CHANNEL_VERSION_3,	/* v3 channel */
    FileCloseProc,		/* Close proc. */
    FileInputProc,		/* Input proc. */
    FileOutputProc,		/* Output proc. */
    FileSeekProc,		/* Seek proc. */
    NULL,			/* Set option proc. */
    NULL,			/* Get option proc. */
    FileWatchProc,		/* Initialize notifier. */
    FileGetHandleProc,		/* Get OS handles out of channel. */
    NULL,			/* close2proc. */
    FileBlockModeProc,		/* Set blocking or non-blocking mode.*/
    NULL,			/* flush proc. */
    NULL,			/* handler proc. */
    FileWideSeekProc,		/* wide seek proc. */
d253 10
a262 18
    "tty",			/* Type name. */
    TCL_CHANNEL_VERSION_2,	/* v2 channel */
    TtyCloseProc,		/* Close proc. */
    FileInputProc,		/* Input proc. */
#if BAD_TIP35_FLUSH
    TtyOutputProc,		/* Output proc. */
#else /* !BAD_TIP35_FLUSH */
    FileOutputProc,		/* Output proc. */
#endif /* BAD_TIP35_FLUSH */
    NULL,			/* Seek proc. */
    TtySetOptionProc,		/* Set option proc. */
    TtyGetOptionProc,		/* Get option proc. */
    FileWatchProc,		/* Initialize notifier. */
    FileGetHandleProc,		/* Get OS handles out of channel. */
    NULL,			/* close2proc. */
    FileBlockModeProc,		/* Set blocking or non-blocking mode.*/
    NULL,			/* flush proc. */
    NULL,			/* handler proc. */
d272 10
a281 14
    "tcp",			/* Type name. */
    TCL_CHANNEL_VERSION_2,	/* v2 channel */
    TcpCloseProc,		/* Close proc. */
    TcpInputProc,		/* Input proc. */
    TcpOutputProc,		/* Output proc. */
    NULL,			/* Seek proc. */
    NULL,			/* Set option proc. */
    TcpGetOptionProc,		/* Get option proc. */
    TcpWatchProc,		/* Initialize notifier. */
    TcpGetHandleProc,		/* Get OS handles out of channel. */
    NULL,			/* close2proc. */
    TcpBlockModeProc,		/* Set blocking or non-blocking mode.*/
    NULL,			/* flush proc. */
    NULL,			/* handler proc. */
d307 2
a308 2
					 * TCL_MODE_BLOCKING or
					 * TCL_MODE_NONBLOCKING. */
d324 1
a324 1
#else /* USE_FIONBIO */
d333 1
a333 1
#endif /* !USE_FIONBIO */
d360 1
a360 1
					 * in the buffer? */
d365 1
a365 1
					 * read from the input device? */
d368 1
a368 1

d378 1
a378 1
	return bytesRead;
d394 1
a394 1
 *	output argument contains a POSIX error code if an error occurred,
d406 1
a406 1
    CONST char *buf;			/* The data buffer. */
a413 11

    if (toWrite == 0) {
	/*
	 * SF Tcl Bug 465765.
	 * Do not try to write nothing into a file. STREAM based
	 * implementations will considers this as EOF (if there is a
	 * pipe behind the file).
	 */

	return 0;
    }
d416 1
a416 1
	return written;
d445 1
a446 2
#ifdef DEPRECATED
    FileState **nextPtrPtr;
d448 1
a448 1
#endif /* DEPRECATED */
a460 1
#ifdef DEPRECATED
a467 1
#endif /* DEPRECATED */
d494 7
a500 5
    ClientData instanceData;	/* File state. */
    long offset;		/* Offset to seek to. */
    int mode;			/* Relative to where should we seek? Can be
				 * one of SEEK_START, SEEK_SET or SEEK_END. */
    int *errorCodePtr;		/* To store error code. */
d503 1
a503 1
    Tcl_WideInt oldLoc, newLoc;
d505 1
a505 60
    /*
     * Save our current place in case we need to roll-back the seek.
     */
    oldLoc = TclOSseek(fsPtr->fd, (Tcl_SeekOffset) 0, SEEK_CUR);
    if (oldLoc == Tcl_LongAsWide(-1)) {
	/*
	 * Bad things are happening.  Error out...
	 */
	*errorCodePtr = errno;
	return -1;
    }
 
    newLoc = TclOSseek(fsPtr->fd, (Tcl_SeekOffset) offset, mode);
 
    /*
     * Check for expressability in our return type, and roll-back otherwise.
     */
    if (newLoc > Tcl_LongAsWide(INT_MAX)) {
	*errorCodePtr = EOVERFLOW;
	TclOSseek(fsPtr->fd, (Tcl_SeekOffset) oldLoc, SEEK_SET);
	return -1;
    } else {
	*errorCodePtr = (newLoc == Tcl_LongAsWide(-1)) ? errno : 0;
    }
    return (int) Tcl_WideAsLong(newLoc);
}

/*
 *----------------------------------------------------------------------
 *
 * FileWideSeekProc --
 *
 *	This procedure is called by the generic IO level to move the
 *	access point in a file based channel, with offsets expressed
 *	as wide integers.
 *
 * Results:
 *	-1 if failed, the new position if successful. An output
 *	argument contains the POSIX error code if an error occurred,
 *	or zero.
 *
 * Side effects:
 *	Moves the location at which the channel will be accessed in
 *	future operations.
 *
 *----------------------------------------------------------------------
 */

static Tcl_WideInt
FileWideSeekProc(instanceData, offset, mode, errorCodePtr)
    ClientData instanceData;	/* File state. */
    Tcl_WideInt offset;		/* Offset to seek to. */
    int mode;			/* Relative to where should we seek? Can be
				 * one of SEEK_START, SEEK_CUR or SEEK_END. */
    int *errorCodePtr;		/* To store error code. */
{
    FileState *fsPtr = (FileState *) instanceData;
    Tcl_WideInt newLoc;

    newLoc = TclOSseek(fsPtr->fd, (Tcl_SeekOffset) offset, mode);
d532 2
a533 2
					 * combination of TCL_READABLE,
					 * TCL_WRITABLE and TCL_EXCEPTION. */
d601 1
a601 1
 *	Closes the device of the channel.
d605 1
d611 4
a614 21
#if BAD_TIP35_FLUSH
    TtyState *ttyPtr = (TtyState *) instanceData;
#endif /* BAD_TIP35_FLUSH */
#ifdef TTYFLUSH
    TTYFLUSH(ttyPtr->fs.fd);
#endif /* TTYFLUSH */
#if 0
    /*
     * TIP#35 agreed to remove the unsave so that TCL could be used as a 
     * simple stty. 
     * It would be cleaner to remove all the stuff related to 
     *	  TtyState.stateUpdated
     *	  TtyState.savedState
     * Then the structure TtyState would be the same as FileState.
     * IMO this cleanup could better be done for the final 8.4 release
     * after nobody complained about the missing unsave. -- schroedter
     */
    if (ttyPtr->stateUpdated) {
	SETIOSTATE(ttyPtr->fs.fd, &ttyPtr->savedState);
    }
#endif
a620 74
 * TtyOutputProc--
 *
 *	This procedure is invoked from the generic IO level to write
 *	output to a TTY channel.
 *
 * Results:
 *	The number of bytes written is returned or -1 on error. An
 *	output argument contains a POSIX error code if an error occurred,
 *	or zero.
 *
 * Side effects:
 *	Writes output on the output device of the channel
 *	if the channel is not designated to be closed.
 *
 *----------------------------------------------------------------------
 */

#if BAD_TIP35_FLUSH
static int
TtyOutputProc(instanceData, buf, toWrite, errorCodePtr)
    ClientData instanceData;		/* File state. */
    CONST char *buf;			/* The data buffer. */
    int toWrite;			/* How many bytes to write? */
    int *errorCodePtr;			/* Where to store error code. */
{
    if (TclInExit()) {
	/*
	 * Do not write data during Tcl exit.
	 * Serial port may block preventing Tcl from exit.
	 */
	return toWrite;
    } else {
	return FileOutputProc(instanceData, buf, toWrite, errorCodePtr);
    }
}
#endif /* BAD_TIP35_FLUSH */

#ifdef USE_TERMIOS
/*
 *----------------------------------------------------------------------
 *
 * TtyModemStatusStr --
 *
 *  Converts a RS232 modem status list of readable flags
 *
 *----------------------------------------------------------------------
 */
static void
TtyModemStatusStr(status, dsPtr)
    int status;		   /* RS232 modem status */
    Tcl_DString *dsPtr;	   /* Where to store string */
{
#ifdef TIOCM_CTS
    Tcl_DStringAppendElement(dsPtr, "CTS");
    Tcl_DStringAppendElement(dsPtr, (status & TIOCM_CTS) ? "1" : "0");
#endif /* TIOCM_CTS */
#ifdef TIOCM_DSR
    Tcl_DStringAppendElement(dsPtr, "DSR");
    Tcl_DStringAppendElement(dsPtr, (status & TIOCM_DSR) ? "1" : "0");
#endif /* TIOCM_DSR */
#ifdef TIOCM_RNG
    Tcl_DStringAppendElement(dsPtr, "RING");
    Tcl_DStringAppendElement(dsPtr, (status & TIOCM_RNG) ? "1" : "0");
#endif /* TIOCM_RNG */
#ifdef TIOCM_CD
    Tcl_DStringAppendElement(dsPtr, "DCD");
    Tcl_DStringAppendElement(dsPtr, (status & TIOCM_CD) ? "1" : "0");
#endif /* TIOCM_CD */
}
#endif /* USE_TERMIOS */

/*
 *----------------------------------------------------------------------
 *
d631 1
a631 1
 *	Sets Error message if needed (by calling Tcl_BadChannelOption).
d640 2
a641 2
    CONST char *optionName;	/* Which option to set? */
    CONST char *value;		/* New value for option. */
d644 1
a644 1
    unsigned int len, vlen;
a645 5
#ifdef USE_TERMIOS
    int flag, control, argc;
    CONST char **argv;
    IOSTATE iostate;
#endif /* USE_TERMIOS */
d648 1
a648 6
    vlen = strlen(value);

    /*
     * Option -mode baud,parity,databits,stopbits
     */
    if ((len > 2) && (strncmp(optionName, "-mode", len) == 0)) {
a657 146
	((TtyState *) fsPtr)->stateUpdated = 1;
	return TCL_OK;
    }

#ifdef USE_TERMIOS

    /*
     * Option -handshake none|xonxoff|rtscts|dtrdsr
     */
    if ((len > 1) && (strncmp(optionName, "-handshake", len) == 0)) {
	/*
	 * Reset all handshake options
	 * DTR and RTS are ON by default
	 */
	GETIOSTATE(fsPtr->fd, &iostate);
	iostate.c_iflag &= ~(IXON | IXOFF | IXANY);
#ifdef CRTSCTS
	iostate.c_cflag &= ~CRTSCTS;
#endif /* CRTSCTS */
	if (strncasecmp(value, "NONE", vlen) == 0) {
	    /* leave all handshake options disabled */
	} else if (strncasecmp(value, "XONXOFF", vlen) == 0) {
	    iostate.c_iflag |= (IXON | IXOFF | IXANY);
	} else if (strncasecmp(value, "RTSCTS", vlen) == 0) {
#ifdef CRTSCTS
	    iostate.c_cflag |= CRTSCTS;
#else /* !CRTSTS */
	    UNSUPPORTED_OPTION("-handshake RTSCTS");
	    return TCL_ERROR;
#endif /* CRTSCTS */
	} else if (strncasecmp(value, "DTRDSR", vlen) == 0) {
	    UNSUPPORTED_OPTION("-handshake DTRDSR");
	    return TCL_ERROR;
	} else {
	    if (interp) {
		Tcl_AppendResult(interp, "bad value for -handshake: ",
			"must be one of xonxoff, rtscts, dtrdsr or none",
			(char *) NULL);
	    }
	    return TCL_ERROR;
	}
	SETIOSTATE(fsPtr->fd, &iostate);
	return TCL_OK;
    }

    /*
     * Option -xchar {\x11 \x13}
     */
    if ((len > 1) && (strncmp(optionName, "-xchar", len) == 0)) {
	GETIOSTATE(fsPtr->fd, &iostate);
	if (Tcl_SplitList(interp, value, &argc, &argv) == TCL_ERROR) {
	    return TCL_ERROR;
	}
	if (argc == 2) {
	    iostate.c_cc[VSTART] = argv[0][0];
	    iostate.c_cc[VSTOP]	 = argv[1][0];
	} else {
	    if (interp) {
		Tcl_AppendResult(interp,
		    "bad value for -xchar: should be a list of two elements",
		    (char *) NULL);
	    }
	    return TCL_ERROR;
	}
	SETIOSTATE(fsPtr->fd, &iostate);
	return TCL_OK;
    }

    /*
     * Option -timeout msec
     */
    if ((len > 2) && (strncmp(optionName, "-timeout", len) == 0)) {
	int msec;

	GETIOSTATE(fsPtr->fd, &iostate);
	if (Tcl_GetInt(interp, value, &msec) != TCL_OK) {
	    return TCL_ERROR;
	}
	iostate.c_cc[VMIN]  = 0;
	iostate.c_cc[VTIME] = (msec == 0) ? 0 : (msec < 100) ? 1 : (msec+50)/100;
	SETIOSTATE(fsPtr->fd, &iostate);
	return TCL_OK;
    }

    /*
     * Option -ttycontrol {DTR 1 RTS 0 BREAK 0}
     */
    if ((len > 4) && (strncmp(optionName, "-ttycontrol", len) == 0)) {
	if (Tcl_SplitList(interp, value, &argc, &argv) == TCL_ERROR) {
	    return TCL_ERROR;
	}
	if ((argc % 2) == 1) {
	    if (interp) {
		Tcl_AppendResult(interp,
			"bad value for -ttycontrol: should be a list of",
			"signal,value pairs", (char *) NULL);
	    }
	    return TCL_ERROR;
	}

	GETCONTROL(fsPtr->fd, &control);
	while (argc > 1) {
	    if (Tcl_GetBoolean(interp, argv[1], &flag) == TCL_ERROR) {
		return TCL_ERROR;
	    }
	    if (strncasecmp(argv[0], "DTR", strlen(argv[0])) == 0) {
#ifdef TIOCM_DTR
		if (flag) {
		    control |= TIOCM_DTR;
		} else {
		    control &= ~TIOCM_DTR;
		}
#else /* !TIOCM_DTR */
		UNSUPPORTED_OPTION("-ttycontrol DTR");
		return TCL_ERROR;
#endif /* TIOCM_DTR */
	    } else if (strncasecmp(argv[0], "RTS", strlen(argv[0])) == 0) {
#ifdef TIOCM_RTS
		if (flag) {
		    control |= TIOCM_RTS;
		} else {
		    control &= ~TIOCM_RTS;
		}
#else /* !TIOCM_RTS*/
		UNSUPPORTED_OPTION("-ttycontrol RTS");
		return TCL_ERROR;
#endif /* TIOCM_RTS*/
	    } else if (strncasecmp(argv[0], "BREAK", strlen(argv[0])) == 0) {
#ifdef SETBREAK
		SETBREAK(fsPtr->fd, flag);
#else /* !SETBREAK */
		UNSUPPORTED_OPTION("-ttycontrol BREAK");
		return TCL_ERROR;
#endif /* SETBREAK */
	    } else {
		if (interp) {
		    Tcl_AppendResult(interp,
			    "bad signal for -ttycontrol: must be ",
			    "DTR, RTS or BREAK", (char *) NULL);
		}
		return TCL_ERROR;
	    }
	    argc -= 2, argv += 2;
	} /* while (argc > 1) */

	SETCONTROL(fsPtr->fd, &control);
d659 2
a661 7

    return Tcl_BadChannelOption(interp, optionName,
	    "mode handshake timeout ttycontrol xchar ");

#else /* !USE_TERMIOS */
    return Tcl_BadChannelOption(interp, optionName, "mode");
#endif /* USE_TERMIOS */
d681 1
a681 1
 *	Sets Error message if needed (by calling Tcl_BadChannelOption).
d690 1
a690 1
    CONST char *optionName;	/* Option to get. */
a696 1
    int valid = 0;  /* flag if valid option parsed */
d699 1
d704 2
a705 5
    if (len == 0) {
	Tcl_DStringAppendElement(dsPtr, "-mode");
    }
    if (len==0 || (len>2 && strncmp(optionName, "-mode", len)==0)) {
	valid = 1;
a708 62
    }

#ifdef USE_TERMIOS
    /*
     * get option -xchar
     */
    if (len == 0) {
	Tcl_DStringAppendElement(dsPtr, "-xchar");
	Tcl_DStringStartSublist(dsPtr);
    }
    if (len==0 || (len>1 && strncmp(optionName, "-xchar", len)==0)) {
	IOSTATE iostate;
	valid = 1;

	GETIOSTATE(fsPtr->fd, &iostate);
	sprintf(buf, "%c", iostate.c_cc[VSTART]);
	Tcl_DStringAppendElement(dsPtr, buf);
	sprintf(buf, "%c", iostate.c_cc[VSTOP]);
	Tcl_DStringAppendElement(dsPtr, buf);
    }
    if (len == 0) {
	Tcl_DStringEndSublist(dsPtr);
    }

    /*
     * get option -queue
     * option is readonly and returned by [fconfigure chan -queue]
     * but not returned by unnamed [fconfigure chan]
     */
    if ((len > 1) && (strncmp(optionName, "-queue", len) == 0)) {
	int inQueue=0, outQueue=0;
	int inBuffered, outBuffered;
	valid = 1;
#ifdef GETREADQUEUE
	GETREADQUEUE(fsPtr->fd, inQueue);
#endif /* GETREADQUEUE */
#ifdef GETWRITEQUEUE
	GETWRITEQUEUE(fsPtr->fd, outQueue);
#endif /* GETWRITEQUEUE */
	inBuffered  = Tcl_InputBuffered(fsPtr->channel);
	outBuffered = Tcl_OutputBuffered(fsPtr->channel);

	sprintf(buf, "%d", inBuffered+inQueue);
	Tcl_DStringAppendElement(dsPtr, buf);
	sprintf(buf, "%d", outBuffered+outQueue);
	Tcl_DStringAppendElement(dsPtr, buf);
    }

    /*
     * get option -ttystatus
     * option is readonly and returned by [fconfigure chan -ttystatus]
     * but not returned by unnamed [fconfigure chan]
     */
    if ((len > 4) && (strncmp(optionName, "-ttystatus", len) == 0)) {
	int status;
	valid = 1;
	GETCONTROL(fsPtr->fd, &status);
	TtyModemStatusStr(status, dsPtr);
    }
#endif /* USE_TERMIOS */

    if (valid) {
d711 1
a711 6
	return Tcl_BadChannelOption(interp, optionName,
#ifdef USE_TERMIOS
	    "mode queue ttystatus xchar");
#else /* !USE_TERMIOS */
	    "mode");
#endif /* USE_TERMIOS */
d719 2
a720 2
#   endif /* B4800 == 4800 */
#endif /* B4800 */
d725 1
a725 1
#else /* !DIRECT_BAUD */
d841 1
a841 1

d844 1
a844 1

d886 1
a886 1

d895 1
a895 1
#endif /* !DIRECT_BAUD */
d913 1
a913 1

d928 1
a928 1

d933 1
a933 1
	case PARENB | PARODD	      : parity = 'o'; break;
d935 1
a935 1
	case PARENB | PARODD | PAREXT : parity = 'm'; break;
d937 1
a937 1
#else /* !PAREXT */
d940 1
a940 1
	case PARENB | PARODD	      : parity = 'o'; break;
d942 1
a942 1
#endif /* !PAREXT */
d948 1
a948 1
#endif /* USE_TERMIOS */
d956 1
a956 1
	case PARENB | PARODD	      : parity = 'o'; break;
d958 1
a958 1
	case PARENB | PARODD | PAREXT : parity = 'm'; break;
d965 1
a965 1
#endif /* USE_TERMIO */
d980 1
a980 1
#endif /* USE_SGTTY */
d1003 1
a1003 1

d1029 1
a1029 1
#endif /* PAREXT */
d1112 1
a1112 1

d1145 1
a1145 1
#endif /* PAREXT|USE_TERMIO */
d1153 1
a1153 1
#endif /* PAREXT|USE_TERMIO */
a1182 3
 *	Note that no initialization happens if the initialize flag
 *	is not set; this is necessary for the correct handling of
 *	UNIX console TTYs at startup.
d1185 1
a1185 2
 *	A pointer to a FileState suitable for use with Tcl_CreateChannel
 *	and the ttyChannelType structure.
d1189 1
a1189 2
 *	sockets (if initialize flag is non-zero.)  All other modes can
 *	be simulated on top of this in Tcl.
d1195 1
a1195 1
TtyInit(fd, initialize)
a1197 1
    int initialize;
d1199 1
d1204 20
a1223 20
    ttyPtr->stateUpdated = 0;
    if (initialize) {
	IOSTATE iostate = ttyPtr->savedState;

#if defined(USE_TERMIOS) || defined(USE_TERMIO)
	if (iostate.c_iflag != IGNBRK ||
		iostate.c_oflag != 0 ||
		iostate.c_lflag != 0 ||
		iostate.c_cflag & CREAD ||
		iostate.c_cc[VMIN] != 1 ||
		iostate.c_cc[VTIME] != 0) {
	    ttyPtr->stateUpdated = 1;
	}
	iostate.c_iflag = IGNBRK;
	iostate.c_oflag = 0;
	iostate.c_lflag = 0;
	iostate.c_cflag |= CREAD;
	iostate.c_cc[VMIN] = 1;
	iostate.c_cc[VTIME] = 0;
#endif	/* USE_TERMIOS|USE_TERMIO */
d1226 2
a1227 6
	if ((iostate.sg_flags & (EVENP | ODDP)) ||
		!(iostate.sg_flags & RAW)) {
	    ttyPtr->stateUpdated = 1;
	}
	iostate.sg_flags &= (EVENP | ODDP);
	iostate.sg_flags |= RAW;
d1230 1
a1230 8
	/*
	 * Only update if we're changing anything to avoid possible
	 * blocking.
	 */
	if (ttyPtr->stateUpdated) {
	    SETIOSTATE(fd, &iostate);
	}
    }
d1256 1
a1256 1
TclpOpenFileChannel(interp, pathPtr, mode, permissions)
d1258 4
a1261 3
					 * can be NULL. */
    Tcl_Obj *pathPtr;			/* Name of file to open. */
    int mode;				/* POSIX open mode. */
d1263 2
a1264 2
					 * file, with what modes to create
					 * it? */
d1266 1
a1266 1
    int fd, channelPermissions;
d1268 1
a1268 1
    CONST char *native, *translation;
d1270 1
a1271 4
#ifdef SUPPORTS_TTY
    int ctl_tty;
#endif /* SUPPORTS_TTY */
#ifdef DEPRECATED
a1272 1
#endif /* DEPRECATED */
d1274 4
d1289 3
a1291 3
	    /*
	     * This may occurr if modeString was "", for example.
	     */
d1296 1
a1296 1
    native = Tcl_FSGetNativePath(pathPtr);
d1300 4
a1303 4
    fd = TclOSopen(native, mode, permissions);
#ifdef SUPPORTS_TTY
    ctl_tty = (strcmp (native, "/dev/tty") == 0);
#endif /* SUPPORTS_TTY */
d1306 5
a1310 6
	if (interp != (Tcl_Interp *) NULL) {
	    Tcl_AppendResult(interp, "couldn't open \"", 
		    Tcl_GetString(pathPtr), "\": ",
		    Tcl_PosixError(interp), (char *) NULL);
	}
	return NULL;
d1317 1
a1317 1

d1319 1
a1319 1

d1321 1
a1321 1

d1323 1
a1323 1
    if (!ctl_tty && isatty(fd)) {
d1331 1
a1331 1

d1334 1
a1334 1
	fsPtr = TtyInit(fd, 1);
a1342 1
#ifdef DEPRECATED
a1344 1
#endif /* DEPRECATED */
d1347 1
a1347 1

d1351 11
d1370 1
a1370 1

d1401 1
a1401 1
				 * TCL_WRITABLE to indicate file mode. */
a1405 2
    Tcl_ChannelType *channelTypePtr;
#ifdef DEPRECATED
a1406 3
#endif /* DEPRECATED */
    int socketType = 0;
    socklen_t argLength = sizeof(int);
d1409 1
a1409 1
	return NULL;
d1412 1
d1418 1
a1418 2

#ifdef DEPRECATED
a1424 20
#endif /* DEPRECATED */

#ifdef SUPPORTS_TTY
    if (isatty(fd)) {
	fsPtr = TtyInit(fd, 0);
	channelTypePtr = &ttyChannelType;
	sprintf(channelName, "serial%d", fd);
    } else
#endif /* SUPPORTS_TTY */
    if (getsockopt(fd, SOL_SOCKET, SO_TYPE, (VOID *)&socketType,
		   &argLength) == 0  &&	 socketType == SOCK_STREAM) {
	/*
	 * The mode parameter gets lost here, unfortunately.
	 */
	return Tcl_MakeTcpClientChannel((ClientData) fd);
    } else {
	channelTypePtr = &fileChannelType;
	fsPtr = (FileState *) ckalloc((unsigned) sizeof(FileState));
	sprintf(channelName, "file%d", fd);
    }
d1426 1
a1426 1
#ifdef DEPRECATED
d1429 1
a1429 1
#endif /* DEPRECATED */
d1432 3
a1434 3
    fsPtr->channel = Tcl_CreateChannel(channelTypePtr, channelName,
	    (ClientData) fsPtr, mode);

d1460 2
a1461 2
					 * TCL_MODE_BLOCKING or
					 * TCL_MODE_NONBLOCKING. */
d1465 2
a1466 2

#ifndef USE_FIONBIO
d1469 2
a1470 2
	statePtr->flags &= (~(TCP_ASYNC_SOCKET));
	setting &= (~(O_NONBLOCK));
d1472 2
a1473 2
	statePtr->flags |= TCP_ASYNC_SOCKET;
	setting |= O_NONBLOCK;
d1476 1
a1476 1
	return errno;
d1478 3
a1480 1
#else /* USE_FIONBIO */
d1482 5
a1486 5
	statePtr->flags &= (~(TCP_ASYNC_SOCKET));
	setting = 0;
	if (ioctl(statePtr->fd, (int) FIONBIO, &setting) == -1) {
	    return errno;
	}
d1488 5
a1492 5
	statePtr->flags |= TCP_ASYNC_SOCKET;
	setting = 1;
	if (ioctl(statePtr->fd, (int) FIONBIO, &setting) == -1) {
	    return errno;
	}
d1494 1
a1494 1
#endif /* !USE_FIONBIO */
d1529 1
a1529 1

d1531 7
a1537 7
	if (statePtr->flags & TCP_ASYNC_SOCKET) {
	    timeOut = 0;
	} else {
	    timeOut = -1;
	}
	errno = 0;
	state = TclUnixWaitForFile(statePtr->fd,
d1539 21
a1559 19
	if (!(statePtr->flags & TCP_ASYNC_SOCKET)) {
#ifndef USE_FIONBIO
	    flags = fcntl(statePtr->fd, F_GETFL);
	    flags &= (~(O_NONBLOCK));
	    (void) fcntl(statePtr->fd, F_SETFL, flags);
#else /* USE_FIONBIO */
	    flags = 0;
	    (void) ioctl(statePtr->fd, FIONBIO, &flags);
#endif /* !USE_FIONBIO */
	}
	if (state & TCL_EXCEPTION) {
	    return -1;
	}
	if (state & TCL_WRITABLE) {
	    statePtr->flags &= (~(TCP_ASYNC_CONNECT));
	} else if (timeOut == 0) {
	    *errorCodePtr = errno = EWOULDBLOCK;
	    return -1;
	}
d1592 1
a1592 1
					 * in the buffer? */
d1601 1
a1601 1
	return -1;
d1605 1
a1605 1
	return bytesRead;
a1607 3
	/*
	 * Turn ECONNRESET into a soft EOF condition.
	 */
d1609 5
a1613 1
	return 0;
d1643 1
a1643 1
    CONST char *buf;			/* The data buffer. */
d1654 1
a1654 1
	return -1;
d1658 1
a1658 1
	return written;
d1722 1
a1722 1
 *	list of all options and their values is returned in the
d1733 3
a1735 3
    ClientData instanceData;	 /* Socket state. */
    Tcl_Interp *interp;		 /* For error reporting - can be NULL. */
    CONST char *optionName;	 /* Name of the option to
d1739 1
a1739 1
    Tcl_DString *dsPtr;		 /* Where to store the computed
d1746 1
a1746 1
    socklen_t size = sizeof(struct sockaddr_in);
d1751 1
a1751 1
	len = strlen(optionName);
d1756 1
a1756 1
	socklen_t optlen = sizeof(int);
d1758 2
a1759 1

d1768 1
a1768 1
	return TCL_OK;
d1772 3
a1774 3
	    ((len > 1) && (optionName[1] == 'p') &&
		    (strncmp(optionName, "-peername", len) == 0))) {
	if (getpeername(statePtr->fd, (struct sockaddr *) &peername,
d1776 6
a1781 6
	    if (len == 0) {
		Tcl_DStringAppendElement(dsPtr, "-peername");
		Tcl_DStringStartSublist(dsPtr);
	    }
	    Tcl_DStringAppendElement(dsPtr, inet_ntoa(peername.sin_addr));
	    hostEntPtr = gethostbyaddr(			/* INTL: Native. */
d1784 1
a1784 1
	    if (hostEntPtr != NULL) {
d1788 28
a1815 27
		Tcl_DStringAppendElement(dsPtr, Tcl_DStringValue(&ds));
	    } else {
		Tcl_DStringAppendElement(dsPtr, inet_ntoa(peername.sin_addr));
	    }
	    TclFormatInt(buf, ntohs(peername.sin_port));
	    Tcl_DStringAppendElement(dsPtr, buf);
	    if (len == 0) {
		Tcl_DStringEndSublist(dsPtr);
	    } else {
		return TCL_OK;
	    }
	} else {
	    /*
	     * getpeername failed - but if we were asked for all the options
	     * (len==0), don't flag an error at that point because it could
	     * be an fconfigure request on a server socket. (which have
	     * no peer). same must be done on win&mac.
	     */

	    if (len) {
		if (interp) {
		    Tcl_AppendResult(interp, "can't get peername: ",
			    Tcl_PosixError(interp), (char *) NULL);
		}
		return TCL_ERROR;
	    }
	}
d1819 10
a1828 10
	    ((len > 1) && (optionName[1] == 's') &&
	    (strncmp(optionName, "-sockname", len) == 0))) {
	if (getsockname(statePtr->fd, (struct sockaddr *) &sockname,
		&size) >= 0) {
	    if (len == 0) {
		Tcl_DStringAppendElement(dsPtr, "-sockname");
		Tcl_DStringStartSublist(dsPtr);
	    }
	    Tcl_DStringAppendElement(dsPtr, inet_ntoa(sockname.sin_addr));
	    hostEntPtr = gethostbyaddr(			/* INTL: Native. */
d1830 2
a1831 2
		    sizeof(sockname.sin_addr), AF_INET);
	    if (hostEntPtr != (struct hostent *) NULL) {
d1835 12
a1846 12
		Tcl_DStringAppendElement(dsPtr, Tcl_DStringValue(&ds));
	    } else {
		Tcl_DStringAppendElement(dsPtr, inet_ntoa(sockname.sin_addr));
	    }
	    TclFormatInt(buf, ntohs(sockname.sin_port));
	    Tcl_DStringAppendElement(dsPtr, buf);
	    if (len == 0) {
		Tcl_DStringEndSublist(dsPtr);
	    } else {
		return TCL_OK;
	    }
	} else {
d1849 2
a1850 1
			Tcl_PosixError(interp), (char *) NULL);
d1857 1
a1857 1
	return Tcl_BadChannelOption(interp, optionName, "peername sockname");
d1884 2
a1885 2
					 * combination of TCL_READABLE,
					 * TCL_WRITABLE and TCL_EXCEPTION. */
d1959 1
a1959 1
    CONST char *host;		/* Name of host on which to open port.
d1963 1
a1963 1
    CONST char *myaddr;		/* Optional client-side address */
d1966 2
a1967 2
				 * attempt to do an async connect. Otherwise
				 * do a synchronous connect or bind. */
d1995 1
a1995 1

d2005 1
d2010 1
a2010 1

d2015 1
a2015 1
		sizeof(struct sockaddr));
d2023 1
a2023 1
		    (char *) &curState, sizeof(curState));
d2038 22
a2059 20
	if (async) {
#ifndef USE_FIONBIO
	    origState = fcntl(sock, F_GETFL);
	    curState = origState | O_NONBLOCK;
	    status = fcntl(sock, F_SETFL, curState);
#else /* USE_FIONBIO */
	    curState = 1;
	    status = ioctl(sock, FIONBIO, &curState);
#endif /* !USE_FIONBIO */
	} else {
	    status = 0;
	}
	if (status > -1) {
	    status = connect(sock, (struct sockaddr *) &sockaddr,
		    sizeof(sockaddr));
	    if (status < 0) {
		if (errno == EINPROGRESS) {
		    asyncConnect = 1;
		    status = 0;
		}
d2073 3
a2075 1
#else /* USE_FIONBIO */
d2078 1
a2078 1
#endif /* !USE_FIONBIO */
d2081 1
a2081 1
	}
d2086 8
a2093 8
	if (interp != NULL) {
	    Tcl_AppendResult(interp, "couldn't open socket: ",
		    Tcl_PosixError(interp), (char *) NULL);
	}
	if (sock != -1) {
	    close(sock);
	}
	return NULL;
d2103 1
a2103 1
	statePtr->flags = TCP_ASYNC_CONNECT;
d2111 1
a2111 1
	close(sock);
d2140 1
a2140 1
    CONST char *host;			/* Host.  NULL implies INADDR_ANY */
d2160 1
a2160 1
	addr.s_addr = inet_addr(native);		/* INTL: Native. */
d2165 7
a2171 7
	if (addr.s_addr == 0xFFFFFFFF) {
	    hostent = gethostbyname(native);		/* INTL: Native. */
	    if (hostent != NULL) {
		memcpy((VOID *) &addr,
			(VOID *) hostent->h_addr_list[0],
			(size_t) hostent->h_length);
	    } else {
d2173 2
a2174 2
		errno = EHOSTUNREACH;
#else /* !EHOSTUNREACH */
d2176 3
a2178 3
		errno = ENXIO;
#endif /* ENXIO */
#endif /* EHOSTUNREACH */
d2182 3
a2184 3
		return 0;	/* error */
	    }
	}
d2189 1
a2189 1

d2209 1
a2209 1
 *	The channel or NULL if failed.	An error message is returned
d2222 2
a2223 2
    CONST char *host;			/* Host on which to open port. */
    CONST char *myaddr;			/* Client-side address */
d2226 2
a2227 2
					 * asynchronous connect. Otherwise
					 * we do a blocking connect. */
d2247 1
a2247 1
	    (ClientData) statePtr, (TCL_READABLE | TCL_WRITABLE));
d2250 2
a2251 2
	Tcl_Close((Tcl_Interp *) NULL, statePtr->channel);
	return NULL;
a2280 1
    statePtr->flags = 0;
d2285 1
a2285 1

d2287 1
a2287 1
	    (ClientData) statePtr, (TCL_READABLE | TCL_WRITABLE));
d2290 2
a2291 2
	Tcl_Close((Tcl_Interp *) NULL, statePtr->channel);
	return NULL;
d2317 1
a2317 1
					 * NULL. */
d2319 1
a2319 1
    CONST char *myHost;			/* Name of local host. */
d2321 1
a2321 1
					 * from new clients. */
d2345 1
a2345 1
	    (ClientData) statePtr);
d2348 1
a2348 1
	    (ClientData) statePtr, 0);
d2356 1
a2356 1
 *	Accept a TCP socket connection.	 This is called by the event loop.
d2378 1
a2378 1
    socklen_t len;				/* For accept interface */
d2386 1
a2386 1
	return;
d2395 1
a2395 1

d2402 1
a2402 1

a2443 6
    /*
     * Some #def's to make the code a little clearer!
     */
#define ZERO_OFFSET	((Tcl_SeekOffset) 0)
#define ERROR_OFFSET	((Tcl_SeekOffset) -1)

d2445 5
a2449 5
	case TCL_STDIN:
	    if ((TclOSseek(0, ZERO_OFFSET, SEEK_CUR) == ERROR_OFFSET)
		    && (errno == EBADF)) {
		return (Tcl_Channel) NULL;
	    }
d2452 7
a2458 7
	    bufMode = "line";
	    break;
	case TCL_STDOUT:
	    if ((TclOSseek(1, ZERO_OFFSET, SEEK_CUR) == ERROR_OFFSET)
		    && (errno == EBADF)) {
		return (Tcl_Channel) NULL;
	    }
d2461 7
a2467 7
	    bufMode = "line";
	    break;
	case TCL_STDERR:
	    if ((TclOSseek(2, ZERO_OFFSET, SEEK_CUR) == ERROR_OFFSET)
		    && (errno == EBADF)) {
		return (Tcl_Channel) NULL;
	    }
d2471 1
a2471 1
	    break;
a2476 3
#undef ZERO_OFFSET
#undef ERROR_OFFSET

d2486 1
a2486 5
    if (Tcl_GetChannelType(channel) == &fileChannelType) {
	Tcl_SetChannelOption(NULL, channel, "-translation", "auto");
    } else {
	Tcl_SetChannelOption(NULL, channel, "-translation", "auto crlf");
    }
d2516 1
a2516 1
    CONST char *string;		/* String that identifies file. */
d2522 2
a2523 2
				 * check that the channel is open for the
				 * requested mode. */
d2532 1
a2532 1

d2535 1
a2535 1
	return TCL_ERROR;
d2538 3
a2540 3
	Tcl_AppendResult(interp,
		"\"", string, "\" wasn't opened for writing", (char *) NULL);
	return TCL_ERROR;
d2542 3
a2544 3
	Tcl_AppendResult(interp,
		"\"", string, "\" wasn't opened for reading", (char *) NULL);
	return TCL_ERROR;
d2557 1
a2557 1
#endif /* SUPPORTS_TTY */
d2560 1
a2560 1
	if (Tcl_GetChannelHandle(chan,
d2570 1
a2570 1

d2583 2
a2584 2
	    "\" cannot be used to get a FILE *", (char *) NULL);
    return TCL_ERROR;	     
d2637 1
a2637 1
	Tcl_GetTime(&now);
d2663 1
a2663 1

d2682 1
a2682 1

d2727 1
a2727 1
	Tcl_GetTime(&now);
d2736 2
@


