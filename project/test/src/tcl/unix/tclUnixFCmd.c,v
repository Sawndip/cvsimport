head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.58
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.56
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.54
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.52
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.50
	gdb_7_0-branch:1.5.0.48
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tcl8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.46
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.44
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.42
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.40
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.38
	gdb_6_5-2006-05-14-branchpoint:1.5
	readline_5_1-import-branch:1.5.0.36
	readline_5_1-import-branchpoint:1.5
	gdb_6_4-branch:1.5.0.34
	gdb_6_4-2005-11-01-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.32
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	ezannoni_pie-20040323-branch:1.5.0.30
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.28
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.26
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.24
	cagney_x86i386-20030821-branch:1.5.0.22
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.20
	gdb_6_0-2003-06-23-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.18
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.16
	cagney_writestrings-20030508-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.14
	cagney_fileio-20030521-branchpoint:1.5
	carlton_dictionary-20030430-merge:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.12
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.10
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.8
	cagney_lazyid-20030317-branchpoint:1.5
	offbyone-20030313-branch:1.5.0.6
	offbyone-20030313-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.4
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.2
	interps-20030202-branchpoint:1.5
	TCL8_4_1:1.1.1.3
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.2
	TCL_8_4_1:1.1.1.3
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.4
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TCL_8_4_0:1.1.1.3
	carlton_dictionary-branch:1.2.0.16
	carlton_dictionary-20020920-branchpoint:1.2
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.14
	gdb_5_3-branch:1.2.0.12
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.10
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.8
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.6
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TCL_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	dejagnu-2000-02-04:1.1.1.1
	dejagnu-2000-01-31:1.1.1.1
	dejagnu-2000-01-24:1.1.1.1
	dejagnu-2000-01-17:1.1.1.1
	dejagnu-2000-01-10:1.1.1.1
	dejagnu-2000-01-04:1.1.1.1
	dejagnu-1999-12-21:1.1.1.1
	dejagnu-1999-12-13:1.1.1.1
	dejagnu-1999-12-07:1.1.1.1
	dejagnu-1999-12-06:1.1.1.1
	dejagnu-1999-11-15:1.1.1.1
	dejagnu-1999-11-08:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.5
date	2003.01.21.19.40.20;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.26.19.48.05;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.37.10;	author kseitz;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2001.09.09.23.56.09;	author irox;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2002.09.27.21.49.14;	author kseitz;	state Exp;
branches;
next	;

1.3.4.1
date	2003.12.14.20.28.51;	author drow;	state Exp;
branches;
next	;

1.2.16.1
date	2002.12.23.19.40.51;	author carlton;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2003.02.07.19.18.22;	author carlton;	state Exp;
branches;
next	;

1.1.1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.09.22.40.59;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.19.55.48;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tcl 8.4.1
@
text
@/*
 * tclUnixFCmd.c
 *
 *      This file implements the unix specific portion of file manipulation 
 *      subcommands of the "file" command.  All filename arguments should
 *	already be translated to native format.
 *
 * Copyright (c) 1996-1998 Sun Microsystems, Inc.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tclUnixFCmd.c,v 1.25 2002/06/28 09:56:54 dkf Exp $
 *
 * Portions of this code were derived from NetBSD source code which has
 * the following copyright notice:
 *
 * Copyright (c) 1988, 1993, 1994
 *      The Regents of the University of California.  All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. All advertising materials mentioning features or use of this software
 *    must display the following acknowledgement:
 *      This product includes software developed by the University of
 *      California, Berkeley and its contributors.
 * 4. Neither the name of the University nor the names of its contributors
 *    may be used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
 * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
 * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
 * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
 * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
 * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

#include "tclInt.h"
#include "tclPort.h"
#include <utime.h>
#include <grp.h>
#ifndef HAVE_ST_BLKSIZE
#ifndef NO_FSTATFS
#include <sys/statfs.h>
#endif
#endif

/*
 * The following constants specify the type of callback when
 * TraverseUnixTree() calls the traverseProc()
 */

#define DOTREE_PRED   1     /* pre-order directory  */
#define DOTREE_POSTD  2     /* post-order directory */
#define DOTREE_F      3     /* regular file */

/*
 * Callbacks for file attributes code.
 */

static int		GetGroupAttribute _ANSI_ARGS_((Tcl_Interp *interp,
			    int objIndex, Tcl_Obj *fileName,
			    Tcl_Obj **attributePtrPtr));
static int		GetOwnerAttribute _ANSI_ARGS_((Tcl_Interp *interp,
			    int objIndex, Tcl_Obj *fileName,
			    Tcl_Obj **attributePtrPtr));
static int		GetPermissionsAttribute _ANSI_ARGS_((
			    Tcl_Interp *interp, int objIndex,
			    Tcl_Obj *fileName, Tcl_Obj **attributePtrPtr));
static int		SetGroupAttribute _ANSI_ARGS_((Tcl_Interp *interp,
			    int objIndex, Tcl_Obj *fileName,
			    Tcl_Obj *attributePtr));
static int		SetOwnerAttribute _ANSI_ARGS_((Tcl_Interp *interp,
			    int objIndex, Tcl_Obj *fileName,
			    Tcl_Obj *attributePtr));
static int		SetPermissionsAttribute _ANSI_ARGS_((
			    Tcl_Interp *interp, int objIndex,
			    Tcl_Obj *fileName, Tcl_Obj *attributePtr));
static int		GetModeFromPermString _ANSI_ARGS_((
			    Tcl_Interp *interp, char *modeStringPtr,
			    mode_t *modePtr));

/*
 * Prototype for the TraverseUnixTree callback function.
 */

typedef int (TraversalProc) _ANSI_ARGS_((Tcl_DString *srcPtr,
	Tcl_DString *dstPtr, CONST Tcl_StatBuf *statBufPtr, int type,
	Tcl_DString *errorPtr));

/*
 * Constants and variables necessary for file attributes subcommand.
 */

enum {
    UNIX_GROUP_ATTRIBUTE,
    UNIX_OWNER_ATTRIBUTE,
    UNIX_PERMISSIONS_ATTRIBUTE
};

CONST char *tclpFileAttrStrings[] = {
    "-group",
    "-owner",
    "-permissions",
    (char *) NULL
};

CONST TclFileAttrProcs tclpFileAttrProcs[] = {
    {GetGroupAttribute,		SetGroupAttribute},
    {GetOwnerAttribute,		SetOwnerAttribute},
    {GetPermissionsAttribute,	SetPermissionsAttribute}
};

/*
 * Declarations for local procedures defined in this file:
 */

static int		CopyFile _ANSI_ARGS_((CONST char *src,
			    CONST char *dst, CONST Tcl_StatBuf *statBufPtr));
static int		CopyFileAtts _ANSI_ARGS_((CONST char *src,
			    CONST char *dst, CONST Tcl_StatBuf *statBufPtr));
static int		DoCopyFile _ANSI_ARGS_((CONST char *srcPtr,
			    CONST char *dstPtr));
static int		DoCreateDirectory _ANSI_ARGS_((CONST char *pathPtr));
static int		DoDeleteFile _ANSI_ARGS_((CONST char *path));
static int		DoRemoveDirectory _ANSI_ARGS_((Tcl_DString *pathPtr,
			    int recursive, Tcl_DString *errorPtr));
static int		DoRenameFile _ANSI_ARGS_((CONST char *src,
			    CONST char *dst));
static int		TraversalCopy _ANSI_ARGS_((Tcl_DString *srcPtr,
			    Tcl_DString *dstPtr, CONST Tcl_StatBuf *statBufPtr,
			    int type, Tcl_DString *errorPtr));
static int		TraversalDelete _ANSI_ARGS_((Tcl_DString *srcPtr,
			    Tcl_DString *dstPtr, CONST Tcl_StatBuf *statBufPtr,
			    int type, Tcl_DString *errorPtr));
static int		TraverseUnixTree _ANSI_ARGS_((
			    TraversalProc *traversalProc,
			    Tcl_DString *sourcePtr, Tcl_DString *destPtr,
			    Tcl_DString *errorPtr));

#ifdef PURIFY
/*
 * realpath and purify don't mix happily.  It has been noted that realpath
 * should not be used with purify because of bogus warnings, but just
 * memset'ing the resolved path will squelch those.  This assumes we are
 * passing the standard MAXPATHLEN size resolved arg.
 */
static char *		Realpath _ANSI_ARGS_((CONST char *path,
			    char *resolved));

char *
Realpath(path, resolved)
    CONST char *path;
    char *resolved;
{
    memset(resolved, 0, MAXPATHLEN);
    return realpath(path, resolved);
}
#else
#define Realpath realpath
#endif


/*
 *---------------------------------------------------------------------------
 *
 * TclpObjRenameFile, DoRenameFile --
 *
 *      Changes the name of an existing file or directory, from src to dst.
 *	If src and dst refer to the same file or directory, does nothing
 *	and returns success.  Otherwise if dst already exists, it will be
 *	deleted and replaced by src subject to the following conditions:
 *	    If src is a directory, dst may be an empty directory.
 *	    If src is a file, dst may be a file.
 *	In any other situation where dst already exists, the rename will
 *	fail.  
 *
 * Results:
 *	If the directory was successfully created, returns TCL_OK.
 *	Otherwise the return value is TCL_ERROR and errno is set to
 *	indicate the error.  Some possible values for errno are:
 *
 *	EACCES:     src or dst parent directory can't be read and/or written.
 *	EEXIST:	    dst is a non-empty directory.
 *	EINVAL:	    src is a root directory or dst is a subdirectory of src.
 *	EISDIR:	    dst is a directory, but src is not.
 *	ENOENT:	    src doesn't exist, or src or dst is "".
 *	ENOTDIR:    src is a directory, but dst is not.  
 *	EXDEV:	    src and dst are on different filesystems.
 *	
 * Side effects:
 *	The implementation of rename may allow cross-filesystem renames,
 *	but the caller should be prepared to emulate it with copy and
 *	delete if errno is EXDEV.
 *
 *---------------------------------------------------------------------------
 */

int 
TclpObjRenameFile(srcPathPtr, destPathPtr)
    Tcl_Obj *srcPathPtr;
    Tcl_Obj *destPathPtr;
{
    return DoRenameFile(Tcl_FSGetNativePath(srcPathPtr), 
			Tcl_FSGetNativePath(destPathPtr));
}

static int
DoRenameFile(src, dst)
    CONST char *src;		/* Pathname of file or dir to be renamed
				 * (native). */
    CONST char *dst;		/* New pathname of file or directory
				 * (native). */
{
    if (rename(src, dst) == 0) {			/* INTL: Native. */
	return TCL_OK;
    }
    if (errno == ENOTEMPTY) {
	errno = EEXIST;
    }

    /*
     * IRIX returns EIO when you attept to move a directory into
     * itself.  We just map EIO to EINVAL get the right message on SGI.
     * Most platforms don't return EIO except in really strange cases.
     */
    
    if (errno == EIO) {
	errno = EINVAL;
    }
    
#ifndef NO_REALPATH
    /*
     * SunOS 4.1.4 reports overwriting a non-empty directory with a
     * directory as EINVAL instead of EEXIST (first rule out the correct
     * EINVAL result code for moving a directory into itself).  Must be
     * conditionally compiled because realpath() not defined on all systems.
     */

    if (errno == EINVAL) {
	char srcPath[MAXPATHLEN], dstPath[MAXPATHLEN];
	DIR *dirPtr;
	Tcl_DirEntry *dirEntPtr;

	if ((Realpath((char *) src, srcPath) != NULL)	/* INTL: Native. */
		&& (Realpath((char *) dst, dstPath) != NULL) /* INTL: Native. */
		&& (strncmp(srcPath, dstPath, strlen(srcPath)) != 0)) {
	    dirPtr = opendir(dst);			/* INTL: Native. */
	    if (dirPtr != NULL) {
		while (1) {
		    dirEntPtr = TclOSreaddir(dirPtr); /* INTL: Native. */
		    if (dirEntPtr == NULL) {
			break;
		    }
		    if ((strcmp(dirEntPtr->d_name, ".") != 0) &&
			    (strcmp(dirEntPtr->d_name, "..") != 0)) {
			errno = EEXIST;
			closedir(dirPtr);
			return TCL_ERROR;
		    }
		}
		closedir(dirPtr);
	    }
	}
	errno = EINVAL;
    }
#endif	/* !NO_REALPATH */

    if (strcmp(src, "/") == 0) {
	/*
	 * Alpha reports renaming / as EBUSY and Linux reports it as EACCES,
	 * instead of EINVAL.
	 */
	 
	errno = EINVAL;
    }

    /*
     * DEC Alpha OSF1 V3.0 returns EACCES when attempting to move a
     * file across filesystems and the parent directory of that file is
     * not writable.  Most other systems return EXDEV.  Does nothing to
     * correct this behavior.
     */

    return TCL_ERROR;
}

/*
 *---------------------------------------------------------------------------
 *
 * TclpObjCopyFile, DoCopyFile --
 *
 *      Copy a single file (not a directory).  If dst already exists and
 *	is not a directory, it is removed.
 *
 * Results:
 *	If the file was successfully copied, returns TCL_OK.  Otherwise
 *	the return value is TCL_ERROR and errno is set to indicate the
 *	error.  Some possible values for errno are:
 *
 *	EACCES:     src or dst parent directory can't be read and/or written.
 *	EISDIR:	    src or dst is a directory.
 *	ENOENT:	    src doesn't exist.  src or dst is "".
 *
 * Side effects:
 *      This procedure will also copy symbolic links, block, and
 *      character devices, and fifos.  For symbolic links, the links 
 *      themselves will be copied and not what they point to.  For the
 *	other special file types, the directory entry will be copied and
 *	not the contents of the device that it refers to.
 *
 *---------------------------------------------------------------------------
 */

int 
TclpObjCopyFile(srcPathPtr, destPathPtr)
    Tcl_Obj *srcPathPtr;
    Tcl_Obj *destPathPtr;
{
    return DoCopyFile(Tcl_FSGetNativePath(srcPathPtr), 
		      Tcl_FSGetNativePath(destPathPtr));
}

static int
DoCopyFile(src, dst)
    CONST char *src;	/* Pathname of file to be copied (native). */
    CONST char *dst;	/* Pathname of file to copy to (native). */
{
    Tcl_StatBuf srcStatBuf, dstStatBuf;

    /*
     * Have to do a stat() to determine the filetype.
     */
    
    if (TclOSlstat(src, &srcStatBuf) != 0) {		/* INTL: Native. */
	return TCL_ERROR;
    }
    if (S_ISDIR(srcStatBuf.st_mode)) {
	errno = EISDIR;
	return TCL_ERROR;
    }

    /*
     * symlink, and some of the other calls will fail if the target 
     * exists, so we remove it first
     */
    
    if (TclOSlstat(dst, &dstStatBuf) == 0) {		/* INTL: Native. */
	if (S_ISDIR(dstStatBuf.st_mode)) {
	    errno = EISDIR;
	    return TCL_ERROR;
	}
    }
    if (unlink(dst) != 0) {				/* INTL: Native. */
	if (errno != ENOENT) {
	    return TCL_ERROR;
	} 
    }

    switch ((int) (srcStatBuf.st_mode & S_IFMT)) {
#ifndef DJGPP
        case S_IFLNK: {
	    char link[MAXPATHLEN];
	    int length;

	    length = readlink(src, link, sizeof(link)); /* INTL: Native. */
	    if (length == -1) {
		return TCL_ERROR;
	    }
	    link[length] = '\0';
	    if (symlink(link, dst) < 0) {		/* INTL: Native. */
		return TCL_ERROR;
	    }
	    break;
	}
#endif
        case S_IFBLK:
        case S_IFCHR: {
	    if (mknod(dst, srcStatBuf.st_mode,		/* INTL: Native. */
		    srcStatBuf.st_rdev) < 0) {
		return TCL_ERROR;
	    }
	    return CopyFileAtts(src, dst, &srcStatBuf);
	}
        case S_IFIFO: {
	    if (mkfifo(dst, srcStatBuf.st_mode) < 0) {	/* INTL: Native. */
		return TCL_ERROR;
	    }
	    return CopyFileAtts(src, dst, &srcStatBuf);
	}
        default: {
	    return CopyFile(src, dst, &srcStatBuf);
	}
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * CopyFile - 
 *
 *      Helper function for TclpCopyFile.  Copies one regular file,
 *	using read() and write().
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *      A file is copied.  Dst will be overwritten if it exists.
 *
 *----------------------------------------------------------------------
 */

static int 
CopyFile(src, dst, statBufPtr) 
    CONST char *src;		/* Pathname of file to copy (native). */
    CONST char *dst;		/* Pathname of file to create/overwrite
				 * (native). */
    CONST Tcl_StatBuf *statBufPtr;
				/* Used to determine mode and blocksize. */
{
    int srcFd;
    int dstFd;
    u_int blockSize;   /* Optimal I/O blocksize for filesystem */
    char *buffer;      /* Data buffer for copy */
    size_t nread;

    if ((srcFd = TclOSopen(src, O_RDONLY, 0)) < 0) {	/* INTL: Native. */
	return TCL_ERROR;
    }

    dstFd = TclOSopen(dst, O_CREAT|O_TRUNC|O_WRONLY,	/* INTL: Native. */
	    statBufPtr->st_mode);
    if (dstFd < 0) {
	close(srcFd); 
	return TCL_ERROR;
    }

#ifdef HAVE_ST_BLKSIZE
    blockSize = statBufPtr->st_blksize;
#else
#ifndef NO_FSTATFS
    {
	struct statfs fs;
	if (fstatfs(srcFd, &fs, sizeof(fs), 0) == 0) {
	    blockSize = fs.f_bsize;
	} else {
	    blockSize = 4096;
	}
    }
#else 
    blockSize = 4096;
#endif
#endif

    buffer = ckalloc(blockSize);
    while (1) {
	nread = read(srcFd, buffer, blockSize);
	if ((nread == -1) || (nread == 0)) {
	    break;
	}
	if (write(dstFd, buffer, nread) != nread) {
	    nread = (size_t) -1;
	    break;
	}
    }
	
    ckfree(buffer);
    close(srcFd);
    if ((close(dstFd) != 0) || (nread == -1)) {
	unlink(dst);					/* INTL: Native. */
	return TCL_ERROR;
    }
    if (CopyFileAtts(src, dst, statBufPtr) == TCL_ERROR) {
	/*
	 * The copy succeeded, but setting the permissions failed, so be in
	 * a consistent state, we remove the file that was created by the
	 * copy.
	 */

	unlink(dst);					/* INTL: Native. */
	return TCL_ERROR;
    }
    return TCL_OK;
}

/*
 *---------------------------------------------------------------------------
 *
 * TclpObjDeleteFile, DoDeleteFile --
 *
 *      Removes a single file (not a directory).
 *
 * Results:
 *	If the file was successfully deleted, returns TCL_OK.  Otherwise
 *	the return value is TCL_ERROR and errno is set to indicate the
 *	error.  Some possible values for errno are:
 *
 *	EACCES:     a parent directory can't be read and/or written.
 *	EISDIR:	    path is a directory.
 *	ENOENT:	    path doesn't exist or is "".
 *
 * Side effects:
 *      The file is deleted, even if it is read-only.
 *
 *---------------------------------------------------------------------------
 */

int 
TclpObjDeleteFile(pathPtr)
    Tcl_Obj *pathPtr;
{
    return DoDeleteFile(Tcl_FSGetNativePath(pathPtr));
}

static int
DoDeleteFile(path)
    CONST char *path;	/* Pathname of file to be removed (native). */
{
    if (unlink(path) != 0) {				/* INTL: Native. */
	return TCL_ERROR;
    }
    return TCL_OK;
}

/*
 *---------------------------------------------------------------------------
 *
 * TclpCreateDirectory, DoCreateDirectory --
 *
 *      Creates the specified directory.  All parent directories of the
 *	specified directory must already exist.  The directory is
 *	automatically created with permissions so that user can access
 *	the new directory and create new files or subdirectories in it.
 *
 * Results:
 *	If the directory was successfully created, returns TCL_OK.
 *	Otherwise the return value is TCL_ERROR and errno is set to
 *	indicate the error.  Some possible values for errno are:
 *
 *	EACCES:     a parent directory can't be read and/or written.
 *	EEXIST:	    path already exists.
 *	ENOENT:	    a parent directory doesn't exist.
 *
 * Side effects:
 *      A directory is created with the current umask, except that
 *	permission for u+rwx will always be added.
 *
 *---------------------------------------------------------------------------
 */

int 
TclpObjCreateDirectory(pathPtr)
    Tcl_Obj *pathPtr;
{
    return DoCreateDirectory(Tcl_FSGetNativePath(pathPtr));
}

static int
DoCreateDirectory(path)
    CONST char *path;	/* Pathname of directory to create (native). */
{
    mode_t mode;

    mode = umask(0);
    umask(mode);

    /*
     * umask return value is actually the inverse of the permissions.
     */

    mode = (0777 & ~mode) | S_IRUSR | S_IWUSR | S_IXUSR;

    if (mkdir(path, mode) != 0) {			/* INTL: Native. */
	return TCL_ERROR;
    }
    return TCL_OK;
}

/*
 *---------------------------------------------------------------------------
 *
 * TclpObjCopyDirectory --
 *
 *      Recursively copies a directory.  The target directory dst must
 *	not already exist.  Note that this function does not merge two
 *	directory hierarchies, even if the target directory is an an
 *	empty directory.
 *
 * Results:
 *	If the directory was successfully copied, returns TCL_OK.
 *	Otherwise the return value is TCL_ERROR, errno is set to indicate
 *	the error, and the pathname of the file that caused the error
 *	is stored in errorPtr.  See TclpObjCreateDirectory and 
 *	TclpObjCopyFile for a description of possible values for errno.
 *
 * Side effects:
 *      An exact copy of the directory hierarchy src will be created
 *	with the name dst.  If an error occurs, the error will
 *      be returned immediately, and remaining files will not be
 *	processed.
 *
 *---------------------------------------------------------------------------
 */

int 
TclpObjCopyDirectory(srcPathPtr, destPathPtr, errorPtr)
    Tcl_Obj *srcPathPtr;
    Tcl_Obj *destPathPtr;
    Tcl_Obj **errorPtr;
{
    Tcl_DString ds;
    Tcl_DString srcString, dstString;
    int ret;

    Tcl_UtfToExternalDString(NULL, 
			     Tcl_FSGetTranslatedStringPath(NULL,srcPathPtr), 
			     -1, &srcString);
    Tcl_UtfToExternalDString(NULL, 
			     Tcl_FSGetTranslatedStringPath(NULL,destPathPtr), 
			     -1, &dstString);

    ret = TraverseUnixTree(TraversalCopy, &srcString, &dstString, &ds);

    Tcl_DStringFree(&srcString);
    Tcl_DStringFree(&dstString);

    if (ret != TCL_OK) {
	*errorPtr = Tcl_NewStringObj(Tcl_DStringValue(&ds), -1);
	Tcl_DStringFree(&ds);
	Tcl_IncrRefCount(*errorPtr);
    }
    return ret;
}


/*
 *---------------------------------------------------------------------------
 *
 * TclpRemoveDirectory, DoRemoveDirectory --
 *
 *	Removes directory (and its contents, if the recursive flag is set).
 *
 * Results:
 *	If the directory was successfully removed, returns TCL_OK.
 *	Otherwise the return value is TCL_ERROR, errno is set to indicate
 *	the error, and the pathname of the file that caused the error
 *	is stored in errorPtr.  Some possible values for errno are:
 *
 *	EACCES:     path directory can't be read and/or written.
 *	EEXIST:	    path is a non-empty directory.
 *	EINVAL:	    path is a root directory.
 *	ENOENT:	    path doesn't exist or is "".
 * 	ENOTDIR:    path is not a directory.
 *
 * Side effects:
 *	Directory removed.  If an error occurs, the error will be returned
 *	immediately, and remaining files will not be deleted.
 *
 *---------------------------------------------------------------------------
 */
 
int 
TclpObjRemoveDirectory(pathPtr, recursive, errorPtr)
    Tcl_Obj *pathPtr;
    int recursive;
    Tcl_Obj **errorPtr;
{
    Tcl_DString ds;
    Tcl_DString pathString;
    int ret;

    Tcl_UtfToExternalDString(NULL, Tcl_FSGetTranslatedStringPath(NULL, pathPtr), 
			     -1, &pathString);
    ret = DoRemoveDirectory(&pathString, recursive, &ds);
    Tcl_DStringFree(&pathString);

    if (ret != TCL_OK) {
	*errorPtr = Tcl_NewStringObj(Tcl_DStringValue(&ds), -1);
	Tcl_DStringFree(&ds);
	Tcl_IncrRefCount(*errorPtr);
    }
    return ret;
}

static int
DoRemoveDirectory(pathPtr, recursive, errorPtr)
    Tcl_DString *pathPtr;	/* Pathname of directory to be removed
				 * (native). */
    int recursive;		/* If non-zero, removes directories that
				 * are nonempty.  Otherwise, will only remove
				 * empty directories. */
    Tcl_DString *errorPtr;	/* If non-NULL, uninitialized or free
				 * DString filled with UTF-8 name of file
				 * causing error. */
{
    CONST char *path;
    mode_t oldPerm = 0;
    int result;
    
    path = Tcl_DStringValue(pathPtr);
    
    if (recursive != 0) {
	/* We should try to change permissions so this can be deleted */
	Tcl_StatBuf statBuf;
	int newPerm;

	if (TclOSstat(path, &statBuf) == 0) {
	    oldPerm = (mode_t) (statBuf.st_mode & 0x00007FFF);
	}
	
	newPerm = oldPerm | (64+128+256);
	chmod(path, (mode_t) newPerm);
    }
    
    if (rmdir(path) == 0) {				/* INTL: Native. */
	return TCL_OK;
    }
    if (errno == ENOTEMPTY) {
	errno = EEXIST;
    }

    result = TCL_OK;
    if ((errno != EEXIST) || (recursive == 0)) {
	if (errorPtr != NULL) {
	    Tcl_ExternalToUtfDString(NULL, path, -1, errorPtr);
	}
	result = TCL_ERROR;
    }
    
    /*
     * The directory is nonempty, but the recursive flag has been
     * specified, so we recursively remove all the files in the directory.
     */

    if (result == TCL_OK) {
	result = TraverseUnixTree(TraversalDelete, pathPtr, NULL, errorPtr);
    }
    
    if ((result != TCL_OK) && (recursive != 0)) {
        /* Try to restore permissions */
        chmod(path, oldPerm);
    }
    return result;
}
	
/*
 *---------------------------------------------------------------------------
 *
 * TraverseUnixTree --
 *
 *      Traverse directory tree specified by sourcePtr, calling the function 
 *	traverseProc for each file and directory encountered.  If destPtr 
 *	is non-null, each of name in the sourcePtr directory is appended to 
 *	the directory specified by destPtr and passed as the second argument 
 *	to traverseProc() .
 *
 * Results:
 *      Standard Tcl result.
 *
 * Side effects:
 *      None caused by TraverseUnixTree, however the user specified 
 *	traverseProc() may change state.  If an error occurs, the error will
 *      be returned immediately, and remaining files will not be processed.
 *
 *---------------------------------------------------------------------------
 */

static int 
TraverseUnixTree(traverseProc, sourcePtr, targetPtr, errorPtr)
    TraversalProc *traverseProc;/* Function to call for every file and
				 * directory in source hierarchy. */
    Tcl_DString *sourcePtr;	/* Pathname of source directory to be
				 * traversed (native). */
    Tcl_DString *targetPtr;	/* Pathname of directory to traverse in
				 * parallel with source directory (native). */
    Tcl_DString *errorPtr;	/* If non-NULL, uninitialized or free
				 * DString filled with UTF-8 name of file
				 * causing error. */
{
    Tcl_StatBuf statBuf;
    CONST char *source, *errfile;
    int result, sourceLen;
    int targetLen;
    Tcl_DirEntry *dirEntPtr;
    DIR *dirPtr;

    errfile = NULL;
    result = TCL_OK;
    targetLen = 0;		/* lint. */

    source = Tcl_DStringValue(sourcePtr);
    if (TclOSlstat(source, &statBuf) != 0) {		/* INTL: Native. */
	errfile = source;
	goto end;
    }
    if (!S_ISDIR(statBuf.st_mode)) {
	/*
	 * Process the regular file
	 */

	return (*traverseProc)(sourcePtr, targetPtr, &statBuf, DOTREE_F,
		errorPtr);
    }
    dirPtr = opendir(source);				/* INTL: Native. */
    if (dirPtr == NULL) {
	/* 
	 * Can't read directory
	 */

	errfile = source;
	goto end;
    }
    result = (*traverseProc)(sourcePtr, targetPtr, &statBuf, DOTREE_PRED,
	    errorPtr);
    if (result != TCL_OK) {
	closedir(dirPtr);
	return result;
    }
    
    Tcl_DStringAppend(sourcePtr, "/", 1);
    sourceLen = Tcl_DStringLength(sourcePtr);	

    if (targetPtr != NULL) {
	Tcl_DStringAppend(targetPtr, "/", 1);
	targetLen = Tcl_DStringLength(targetPtr);
    }

    while ((dirEntPtr = TclOSreaddir(dirPtr)) != NULL) { /* INTL: Native. */
	if ((strcmp(dirEntPtr->d_name, ".") == 0)
	        || (strcmp(dirEntPtr->d_name, "..") == 0)) {
	    continue;
	}

	/* 
	 * Append name after slash, and recurse on the file.
	 */

	Tcl_DStringAppend(sourcePtr, dirEntPtr->d_name, -1);
	if (targetPtr != NULL) {
	    Tcl_DStringAppend(targetPtr, dirEntPtr->d_name, -1);
	}
	result = TraverseUnixTree(traverseProc, sourcePtr, targetPtr,
		errorPtr);
	if (result != TCL_OK) {
	    break;
	}
	
	/*
	 * Remove name after slash.
	 */

	Tcl_DStringSetLength(sourcePtr, sourceLen);
	if (targetPtr != NULL) {
	    Tcl_DStringSetLength(targetPtr, targetLen);
	}
    }
    closedir(dirPtr);
    
    /*
     * Strip off the trailing slash we added
     */

    Tcl_DStringSetLength(sourcePtr, sourceLen - 1);
    if (targetPtr != NULL) {
	Tcl_DStringSetLength(targetPtr, targetLen - 1);
    }

    if (result == TCL_OK) {
	/*
	 * Call traverseProc() on a directory after visiting all the
	 * files in that directory.
	 */

	result = (*traverseProc)(sourcePtr, targetPtr, &statBuf, DOTREE_POSTD,
		errorPtr);
    }
    end:
    if (errfile != NULL) {
	if (errorPtr != NULL) {
	    Tcl_ExternalToUtfDString(NULL, errfile, -1, errorPtr);
	}
	result = TCL_ERROR;
    }
	    
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * TraversalCopy
 *
 *      Called from TraverseUnixTree in order to execute a recursive copy
 *      of a directory.
 *
 * Results:
 *      Standard Tcl result.
 *
 * Side effects:
 *      The file or directory src may be copied to dst, depending on 
 *      the value of type.
 *      
 *----------------------------------------------------------------------
 */

static int 
TraversalCopy(srcPtr, dstPtr, statBufPtr, type, errorPtr) 
    Tcl_DString *srcPtr;	/* Source pathname to copy (native). */
    Tcl_DString *dstPtr;	/* Destination pathname of copy (native). */
    CONST Tcl_StatBuf *statBufPtr;
				/* Stat info for file specified by srcPtr. */
    int type;                   /* Reason for call - see TraverseUnixTree(). */
    Tcl_DString *errorPtr;	/* If non-NULL, uninitialized or free
				 * DString filled with UTF-8 name of file
				 * causing error. */
{
    switch (type) {
	case DOTREE_F:
	    if (DoCopyFile(Tcl_DStringValue(srcPtr), 
		    Tcl_DStringValue(dstPtr)) == TCL_OK) {
		return TCL_OK;
	    }
	    break;

	case DOTREE_PRED:
	    if (DoCreateDirectory(Tcl_DStringValue(dstPtr)) == TCL_OK) {
		return TCL_OK;
	    }
	    break;

	case DOTREE_POSTD:
	    if (CopyFileAtts(Tcl_DStringValue(srcPtr),
		    Tcl_DStringValue(dstPtr), statBufPtr) == TCL_OK) {
		return TCL_OK;
	    }
	    break;

    }

    /*
     * There shouldn't be a problem with src, because we already checked it
     * to get here.
     */

    if (errorPtr != NULL) {
	Tcl_ExternalToUtfDString(NULL, Tcl_DStringValue(dstPtr),
		Tcl_DStringLength(dstPtr), errorPtr);
    }
    return TCL_ERROR;
}

/*
 *---------------------------------------------------------------------------
 *
 * TraversalDelete --
 *
 *      Called by procedure TraverseUnixTree for every file and directory
 *	that it encounters in a directory hierarchy. This procedure unlinks
 *      files, and removes directories after all the containing files 
 *      have been processed.
 *
 * Results:
 *      Standard Tcl result.
 *
 * Side effects:
 *      Files or directory specified by src will be deleted.
 *
 *----------------------------------------------------------------------
 */

static int
TraversalDelete(srcPtr, ignore, statBufPtr, type, errorPtr) 
    Tcl_DString *srcPtr;	/* Source pathname (native). */
    Tcl_DString *ignore;	/* Destination pathname (not used). */
    CONST Tcl_StatBuf *statBufPtr;
				/* Stat info for file specified by srcPtr. */
    int type;                   /* Reason for call - see TraverseUnixTree(). */
    Tcl_DString *errorPtr;	/* If non-NULL, uninitialized or free
				 * DString filled with UTF-8 name of file
				 * causing error. */
{
    switch (type) {
        case DOTREE_F: {
	    if (DoDeleteFile(Tcl_DStringValue(srcPtr)) == 0) {
		return TCL_OK;
	    }
	    break;
	}
        case DOTREE_PRED: {
	    return TCL_OK;
	}
        case DOTREE_POSTD: {
	    if (DoRemoveDirectory(srcPtr, 0, NULL) == 0) {
		return TCL_OK;
	    }
	    break;
	}	    
    }
    if (errorPtr != NULL) {
	Tcl_ExternalToUtfDString(NULL, Tcl_DStringValue(srcPtr),
		Tcl_DStringLength(srcPtr), errorPtr);
    }
    return TCL_ERROR;
}

/*
 *---------------------------------------------------------------------------
 *
 * CopyFileAtts --
 *
 *	Copy the file attributes such as owner, group, permissions,
 *	and modification date from one file to another.
 *
 * Results:
 *	Standard Tcl result.
 *
 * Side effects:
 *	user id, group id, permission bits, last modification time, and
 *	last access time are updated in the new file to reflect the
 *	old file.
 *
 *---------------------------------------------------------------------------
 */

static int
CopyFileAtts(src, dst, statBufPtr) 
    CONST char *src;		/* Path name of source file (native). */
    CONST char *dst;		/* Path name of target file (native). */
    CONST Tcl_StatBuf *statBufPtr;
				/* Stat info for source file */
{
    struct utimbuf tval;
    mode_t newMode;
    
    newMode = statBufPtr->st_mode
	    & (S_ISUID | S_ISGID | S_IRWXU | S_IRWXG | S_IRWXO);
	
    /* 
     * Note that if you copy a setuid file that is owned by someone
     * else, and you are not root, then the copy will be setuid to you.
     * The most correct implementation would probably be to have the
     * copy not setuid to anyone if the original file was owned by 
     * someone else, but this corner case isn't currently handled.
     * It would require another lstat(), or getuid().
     */
    
    if (chmod(dst, newMode)) {				/* INTL: Native. */
	newMode &= ~(S_ISUID | S_ISGID);
	if (chmod(dst, newMode)) {			/* INTL: Native. */
	    return TCL_ERROR;
	}
    }

    tval.actime = statBufPtr->st_atime; 
    tval.modtime = statBufPtr->st_mtime; 

    if (utime(dst, &tval)) {				/* INTL: Native. */
	return TCL_ERROR;
    }
    return TCL_OK;
}


/*
 *----------------------------------------------------------------------
 *
 * GetGroupAttribute
 *
 *      Gets the group attribute of a file.
 *
 * Results:
 *      Standard TCL result. Returns a new Tcl_Obj in attributePtrPtr
 *	if there is no error.
 *
 * Side effects:
 *      A new object is allocated.
 *      
 *----------------------------------------------------------------------
 */

static int
GetGroupAttribute(interp, objIndex, fileName, attributePtrPtr)
    Tcl_Interp *interp;		/* The interp we are using for errors. */
    int objIndex;		/* The index of the attribute. */
    Tcl_Obj *fileName;  	/* The name of the file (UTF-8). */
    Tcl_Obj **attributePtrPtr;	/* A pointer to return the object with. */
{
    Tcl_StatBuf statBuf;
    struct group *groupPtr;
    int result;

    result = TclpObjStat(fileName, &statBuf);
    
    if (result != 0) {
	Tcl_AppendResult(interp, "could not read \"", 
		Tcl_GetString(fileName), "\": ",
		Tcl_PosixError(interp), (char *) NULL);
	return TCL_ERROR;
    }

    groupPtr = getgrgid(statBuf.st_gid);		/* INTL: Native. */
    if (groupPtr == NULL) {
	*attributePtrPtr = Tcl_NewIntObj((int) statBuf.st_gid);
    } else {
	Tcl_DString ds;
	CONST char *utf;

	utf = Tcl_ExternalToUtfDString(NULL, groupPtr->gr_name, -1, &ds); 
	*attributePtrPtr = Tcl_NewStringObj(utf, -1);
	Tcl_DStringFree(&ds);
    }
    endgrent();
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * GetOwnerAttribute
 *
 *      Gets the owner attribute of a file.
 *
 * Results:
 *      Standard TCL result. Returns a new Tcl_Obj in attributePtrPtr
 *	if there is no error.
 *
 * Side effects:
 *      A new object is allocated.
 *      
 *----------------------------------------------------------------------
 */

static int
GetOwnerAttribute(interp, objIndex, fileName, attributePtrPtr)
    Tcl_Interp *interp;		/* The interp we are using for errors. */
    int objIndex;		/* The index of the attribute. */
    Tcl_Obj *fileName;  	/* The name of the file (UTF-8). */
    Tcl_Obj **attributePtrPtr;	/* A pointer to return the object with. */
{
    Tcl_StatBuf statBuf;
    struct passwd *pwPtr;
    int result;

    result = TclpObjStat(fileName, &statBuf);
    
    if (result != 0) {
	Tcl_AppendResult(interp, "could not read \"", 
		Tcl_GetString(fileName), "\": ",
		Tcl_PosixError(interp), (char *) NULL);
	return TCL_ERROR;
    }

    pwPtr = getpwuid(statBuf.st_uid);			/* INTL: Native. */
    if (pwPtr == NULL) {
	*attributePtrPtr = Tcl_NewIntObj((int) statBuf.st_uid);
    } else {
	Tcl_DString ds;
	CONST char *utf;

	utf = Tcl_ExternalToUtfDString(NULL, pwPtr->pw_name, -1, &ds); 
	*attributePtrPtr = Tcl_NewStringObj(utf, Tcl_DStringLength(&ds));
	Tcl_DStringFree(&ds);
    }
    endpwent();
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * GetPermissionsAttribute
 *
 *      Gets the group attribute of a file.
 *
 * Results:
 *      Standard TCL result. Returns a new Tcl_Obj in attributePtrPtr
 *	if there is no error. The object will have ref count 0.
 *
 * Side effects:
 *      A new object is allocated.
 *      
 *----------------------------------------------------------------------
 */

static int
GetPermissionsAttribute(interp, objIndex, fileName, attributePtrPtr)
    Tcl_Interp *interp;		    /* The interp we are using for errors. */
    int objIndex;		    /* The index of the attribute. */
    Tcl_Obj *fileName;  	    /* The name of the file (UTF-8). */
    Tcl_Obj **attributePtrPtr;	    /* A pointer to return the object with. */
{
    Tcl_StatBuf statBuf;
    char returnString[7];
    int result;

    result = TclpObjStat(fileName, &statBuf);
    
    if (result != 0) {
	Tcl_AppendResult(interp, "could not read \"", 
		Tcl_GetString(fileName), "\": ",
		Tcl_PosixError(interp), (char *) NULL);
	return TCL_ERROR;
    }

    sprintf(returnString, "%0#5lo", (long) (statBuf.st_mode & 0x00007FFF));

    *attributePtrPtr = Tcl_NewStringObj(returnString, -1);
    
    return TCL_OK;
}

/*
 *---------------------------------------------------------------------------
 *
 * SetGroupAttribute --
 *
 *      Sets the group of the file to the specified group.
 *
 * Results:
 *      Standard TCL result.
 *
 * Side effects:
 *      As above.
 *      
 *---------------------------------------------------------------------------
 */

static int
SetGroupAttribute(interp, objIndex, fileName, attributePtr)
    Tcl_Interp *interp;		    /* The interp for error reporting. */
    int objIndex;		    /* The index of the attribute. */
    Tcl_Obj *fileName;	            /* The name of the file (UTF-8). */
    Tcl_Obj *attributePtr;	    /* New group for file. */
{
    long gid;
    int result;
    CONST char *native;

    if (Tcl_GetLongFromObj(NULL, attributePtr, &gid) != TCL_OK) {
	Tcl_DString ds;
	struct group *groupPtr;
	CONST char *string;
	int length;

	string = Tcl_GetStringFromObj(attributePtr, &length);

	native = Tcl_UtfToExternalDString(NULL, string, length, &ds);
	groupPtr = getgrnam(native);			/* INTL: Native. */
	Tcl_DStringFree(&ds);

	if (groupPtr == NULL) {
	    endgrent();
	    Tcl_AppendResult(interp, "could not set group for file \"",
		    Tcl_GetString(fileName), "\": group \"", 
		    string, "\" does not exist",
		    (char *) NULL);
	    return TCL_ERROR;
	}
	gid = groupPtr->gr_gid;
    }

    native = Tcl_FSGetNativePath(fileName);
    result = chown(native, (uid_t) -1, (gid_t) gid);	/* INTL: Native. */

    endgrent();
    if (result != 0) {
	Tcl_AppendResult(interp, "could not set group for file \"",
	    Tcl_GetString(fileName), "\": ", Tcl_PosixError(interp), 
	    (char *) NULL);
	return TCL_ERROR;
    }    
    return TCL_OK;
}

/*
 *---------------------------------------------------------------------------
 *
 * SetOwnerAttribute --
 *
 *      Sets the owner of the file to the specified owner.
 *
 * Results:
 *      Standard TCL result.
 *
 * Side effects:
 *      As above.
 *      
 *---------------------------------------------------------------------------
 */

static int
SetOwnerAttribute(interp, objIndex, fileName, attributePtr)
    Tcl_Interp *interp;		    /* The interp for error reporting. */
    int objIndex;		    /* The index of the attribute. */
    Tcl_Obj *fileName;   	    /* The name of the file (UTF-8). */
    Tcl_Obj *attributePtr;	    /* New owner for file. */
{
    long uid;
    int result;
    CONST char *native;

    if (Tcl_GetLongFromObj(NULL, attributePtr, &uid) != TCL_OK) {
	Tcl_DString ds;
	struct passwd *pwPtr;
	CONST char *string;
	int length;

	string = Tcl_GetStringFromObj(attributePtr, &length);

	native = Tcl_UtfToExternalDString(NULL, string, length, &ds);
	pwPtr = getpwnam(native);			/* INTL: Native. */
	Tcl_DStringFree(&ds);

	if (pwPtr == NULL) {
	    Tcl_AppendResult(interp, "could not set owner for file \"",
			     Tcl_GetString(fileName), "\": user \"", 
			     string, "\" does not exist",
		    (char *) NULL);
	    return TCL_ERROR;
	}
	uid = pwPtr->pw_uid;
    }

    native = Tcl_FSGetNativePath(fileName);
    result = chown(native, (uid_t) uid, (gid_t) -1);   /* INTL: Native. */

    if (result != 0) {
	Tcl_AppendResult(interp, "could not set owner for file \"", 
			 Tcl_GetString(fileName), "\": ", 
			 Tcl_PosixError(interp), (char *) NULL);
	return TCL_ERROR;
    }
    return TCL_OK;
}

/*
 *---------------------------------------------------------------------------
 *
 * SetPermissionsAttribute
 *
 *      Sets the file to the given permission.
 *
 * Results:
 *      Standard TCL result.
 *
 * Side effects:
 *      The permission of the file is changed.
 *      
 *---------------------------------------------------------------------------
 */

static int
SetPermissionsAttribute(interp, objIndex, fileName, attributePtr)
    Tcl_Interp *interp;		    /* The interp we are using for errors. */
    int objIndex;		    /* The index of the attribute. */
    Tcl_Obj *fileName;  	    /* The name of the file (UTF-8). */
    Tcl_Obj *attributePtr;	    /* The attribute to set. */
{
    long mode;
    mode_t newMode;
    int result;
    CONST char *native;

    /*
     * First try if the string is a number
     */
    if (Tcl_GetLongFromObj(NULL, attributePtr, &mode) == TCL_OK) {
        newMode = (mode_t) (mode & 0x00007FFF);
    } else {
	Tcl_StatBuf buf;
	char *modeStringPtr = Tcl_GetString(attributePtr);

	/*
	 * Try the forms "rwxrwxrwx" and "ugo=rwx"
	 *
	 * We get the current mode of the file, in order to allow for
	 * ug+-=rwx style chmod strings.
	 */
	result = TclpObjStat(fileName, &buf);
	if (result != 0) {
	    Tcl_AppendResult(interp, "could not read \"", 
		    Tcl_GetString(fileName), "\": ",
		    Tcl_PosixError(interp), (char *) NULL);
	    return TCL_ERROR;
	}
	newMode = (mode_t) (buf.st_mode & 0x00007FFF);

	if (GetModeFromPermString(NULL, modeStringPtr, &newMode) != TCL_OK) {
	    Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
		    "unknown permission string format \"",
		    modeStringPtr, "\"", (char *) NULL);
	    return TCL_ERROR;
	}
    }

    native = Tcl_FSGetNativePath(fileName);
    result = chmod(native, newMode);		/* INTL: Native. */
    if (result != 0) {
	Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
		"could not set permissions for file \"", 
		Tcl_GetString(fileName), "\": ",
		Tcl_PosixError(interp), (char *) NULL);
	return TCL_ERROR;
    }
    return TCL_OK;
}

/*
 *---------------------------------------------------------------------------
 *
 * TclpObjListVolumes --
 *
 *	Lists the currently mounted volumes, which on UNIX is just /.
 *
 * Results:
 *	The list of volumes.
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
 */

Tcl_Obj*
TclpObjListVolumes(void)
{
    Tcl_Obj *resultPtr = Tcl_NewStringObj("/",1);

    Tcl_IncrRefCount(resultPtr);
    return resultPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * GetModeFromPermString --
 *
 *	This procedure is invoked to process the "file permissions"
 *	Tcl command, to check for a "rwxrwxrwx" or "ugoa+-=rwxst" string.
 *	See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

static int
GetModeFromPermString(interp, modeStringPtr, modePtr)
    Tcl_Interp *interp;		/* The interp we are using for errors. */
    char *modeStringPtr;	/* Permissions string */
    mode_t *modePtr;		/* pointer to the mode value */
{
    mode_t newMode;
    mode_t oldMode;		/* Storage for the value of the old mode
				 * (that is passed in), to allow for the
				 * chmod style manipulation */
    int i,n, who, op, what, op_found, who_found;

    /*
     * We start off checking for an "rwxrwxrwx" style permissions string
     */
    if (strlen(modeStringPtr) != 9) {
        goto chmodStyleCheck;
    }

    newMode = 0;
    for (i = 0; i < 9; i++) {
	switch (*(modeStringPtr+i)) {
	    case 'r':
		if ((i%3) != 0) {
		    goto chmodStyleCheck;
		}
		newMode |= (1<<(8-i));
		break;
	    case 'w':
		if ((i%3) != 1) {
		    goto chmodStyleCheck;
		}
		newMode |= (1<<(8-i));
		break;
	    case 'x':
		if ((i%3) != 2) {
		    goto chmodStyleCheck;
		}
		newMode |= (1<<(8-i));
		break;
	    case 's':
		if (((i%3) != 2) || (i > 5)) {
		    goto chmodStyleCheck;
		}
		newMode |= (1<<(8-i));
		newMode |= (1<<(11-(i/3)));
		break;
	    case 'S':
		if (((i%3) != 2) || (i > 5)) {
		    goto chmodStyleCheck;
		}
		newMode |= (1<<(11-(i/3)));
		break;
	    case 't':
		if (i != 8) {
		    goto chmodStyleCheck;
		}
		newMode |= (1<<(8-i));
		newMode |= (1<<9);
		break;
	    case 'T':
		if (i != 8) {
		    goto chmodStyleCheck;
		}
		newMode |= (1<<9);
		break;
	    case '-':
		break;
	    default:
		/*
		 * Oops, not what we thought it was, so go on
		 */
		goto chmodStyleCheck;
	}
    }
    *modePtr = newMode;
    return TCL_OK;

    chmodStyleCheck:
    /*
     * We now check for an "ugoa+-=rwxst" style permissions string
     */

    for (n = 0 ; *(modeStringPtr+n) != '\0' ; n = n + i) {
	oldMode = *modePtr;
	who = op = what = op_found = who_found = 0;
	for (i = 0 ; *(modeStringPtr+n+i) != '\0' ; i++ ) {
	    if (!who_found) {
		/* who */
		switch (*(modeStringPtr+n+i)) {
		    case 'u' :
			who |= 0x9c0;
			continue;
		    case 'g' :
			who |= 0x438;
			continue;
		    case 'o' :
			who |= 0x207;
			continue;
		    case 'a' :
			who |= 0xfff;
			continue;
		}
	    }
	    who_found = 1;
	    if (who == 0) {
		who = 0xfff;
	    }
	    if (!op_found) {
		/* op */
		switch (*(modeStringPtr+n+i)) {
		    case '+' :
			op = 1;
			op_found = 1;
			continue;
		    case '-' :
			op = 2;
			op_found = 1;
			continue;
		    case '=' :
			op = 3;
			op_found = 1;
			continue;
		    default  :
			return TCL_ERROR;
			break;
		}
	    }
	    /* what */
	    switch (*(modeStringPtr+n+i)) {
		case 'r' :
		    what |= 0x124;
		    continue;
		case 'w' :
		    what |= 0x92;
		    continue;
		case 'x' :
		    what |= 0x49;
		    continue;
		case 's' :
		    what |= 0xc00;
		    continue;
		case 't' :
		    what |= 0x200;
		    continue;
		case ',' :
		    break;
		default  :
		    return TCL_ERROR;
		    break;
	    }
	    if (*(modeStringPtr+n+i) == ',') {
		i++;
		break;
	    }
	}
	switch (op) {
	    case 1 :
		*modePtr = oldMode | (who & what);
		continue;
	    case 2 :
		*modePtr = oldMode & ~(who & what);
		continue;
	    case 3 :
		*modePtr = (oldMode & ~who) | (who & what);
		continue;
	}
    }
    return TCL_OK;
}

/*
 *---------------------------------------------------------------------------
 *
 * TclpObjNormalizePath --
 *
 *	This function scans through a path specification and replaces
 *	it, in place, with a normalized version.  A normalized version
 *	is one in which all symlinks in the path are replaced with
 *	their expanded form (except a symlink at the very end of the
 *	path).
 *
 * Results:
 *	The new 'nextCheckpoint' value, giving as far as we could
 *	understand in the path.
 *
 * Side effects:
 *	The pathPtr string, is modified.
 *
 *---------------------------------------------------------------------------
 */

int
TclpObjNormalizePath(interp, pathPtr, nextCheckpoint)
    Tcl_Interp *interp;
    Tcl_Obj *pathPtr;
    int nextCheckpoint;
{
    char *currentPathEndPosition;
    int pathLen;
    char cur;
    char *path = Tcl_GetStringFromObj(pathPtr, &pathLen);
#ifndef NO_REALPATH
    char normPath[MAXPATHLEN];
    Tcl_DString ds;
    CONST char *nativePath; 
#endif

    currentPathEndPosition = path + nextCheckpoint;

    while (1) {
	cur = *currentPathEndPosition;
	if ((cur == '/') && (path != currentPathEndPosition)) {
	    /* Reached directory separator */
	    Tcl_DString ds;
	    CONST char *nativePath;
	    int accessOk;

	    nativePath = Tcl_UtfToExternalDString(NULL, path, 
		    currentPathEndPosition - path, &ds);
	    accessOk = access(nativePath, F_OK);
	    Tcl_DStringFree(&ds);
	    if (accessOk != 0) {
		/* File doesn't exist */
		break;
	    }
	    /* Update the acceptable point */
	    nextCheckpoint = currentPathEndPosition - path;
	} else if (cur == 0) {
	    /* Reached end of string */
	    break;
	}
	currentPathEndPosition++;
    }
    /* 
     * We should really now convert this to a canonical path.  We do
     * that with 'realpath' if we have it available.  Otherwise we could
     * step through every single path component, checking whether it is a 
     * symlink, but that would be a lot of work, and most modern OSes 
     * have 'realpath'.
     */
#ifndef NO_REALPATH
    /* 
     * If we only had '/foo' or '/' then we never increment nextCheckpoint
     * and we don't need or want to go through 'Realpath'.  Also, on some
     * platforms, passing an empty string to 'Realpath' will give us the
     * normalized pwd, which is not what we want at all!
     */
    if (nextCheckpoint == 0) return 0;
    
    nativePath = Tcl_UtfToExternalDString(NULL, path, nextCheckpoint, &ds);
    if (Realpath(nativePath, normPath) != NULL) {
	/* 
	 * Free up the native path and put in its place the
	 * converted, normalized path.
	 */
	Tcl_DStringFree(&ds);
	Tcl_ExternalToUtfDString(NULL, normPath, (int) strlen(normPath), &ds);

	if (path[nextCheckpoint] != '\0') {
	    /* not at end, append remaining path */
	    int normLen = Tcl_DStringLength(&ds);
	    Tcl_DStringAppend(&ds, path + nextCheckpoint,
		    pathLen - nextCheckpoint);
	    /* 
	     * We recognise up to and including the directory
	     * separator.
	     */	
	    nextCheckpoint = normLen + 1;
	} else {
	    /* We recognise the whole string */ 
	    nextCheckpoint = Tcl_DStringLength(&ds);
	}
	/* 
	 * Overwrite with the normalized path.
	 */
	Tcl_SetStringObj(pathPtr, Tcl_DStringValue(&ds),
		Tcl_DStringLength(&ds));
    }
    Tcl_DStringFree(&ds);
#endif	/* !NO_REALPATH */

    return nextCheckpoint;
}
@


1.4
log
@touched all sources to ease next import
@
text
@d13 1
a13 1
 * RCS: @@(#) $Id: tclUnixFCmd.c,v 1.6.8.2 2000/09/15 16:58:23 spolk Exp $
d74 1
a74 1
			    int objIndex, CONST char *fileName,
d77 1
a77 1
			    int objIndex, CONST char *fileName,
d81 1
a81 1
			    CONST char *fileName, Tcl_Obj **attributePtrPtr));
d83 1
a83 1
			    int objIndex, CONST char *fileName,
d86 1
a86 1
			    int objIndex, CONST char *fileName,
d90 1
a90 1
			    CONST char *fileName, Tcl_Obj *attributePtr));
d100 1
a100 1
	Tcl_DString *dstPtr, CONST struct stat *statBufPtr, int type,
d113 1
a113 1
char *tclpFileAttrStrings[] = {
d131 1
a131 1
			    CONST char *dst, CONST struct stat *statBufPtr));
d133 5
a137 5
			    CONST char *dst, CONST struct stat *statBufPtr));
static int		DoCopyFile _ANSI_ARGS_((Tcl_DString *srcPtr,
			    Tcl_DString *dstPtr));
static int		DoCreateDirectory _ANSI_ARGS_((Tcl_DString *pathPtr));
static int		DoDeleteFile _ANSI_ARGS_((Tcl_DString *pathPtr));
d143 1
a143 1
			    Tcl_DString *dstPtr, CONST struct stat *statBufPtr,
d146 1
a146 1
			    Tcl_DString *dstPtr, CONST struct stat *statBufPtr,
d152 23
d179 1
a179 1
 * TclpRenameFile, DoRenameFile --
d211 4
a214 6
int
TclpRenameFile(src, dst)
    CONST char *src;		/* Pathname of file or dir to be renamed
				 * (UTF-8). */
    CONST char *dst;		/* New pathname of file or directory
				 * (UTF-8). */
d216 2
a217 10
    int result;
    Tcl_DString srcString, dstString;

    Tcl_UtfToExternalDString(NULL, src, -1, &srcString);
    Tcl_UtfToExternalDString(NULL, dst, -1, &dstString);
    result = DoRenameFile(Tcl_DStringValue(&srcString),
	    Tcl_DStringValue(&dstString));
    Tcl_DStringFree(&srcString);
    Tcl_DStringFree(&dstString);
    return result;
d255 1
a255 1
	struct dirent *dirEntPtr;
d257 2
a258 2
	if ((realpath((char *) src, srcPath) != NULL)	/* INTL: Native. */
		&& (realpath((char *) dst, dstPath) != NULL) /* INTL: Native. */
d263 1
a263 1
		    dirEntPtr = readdir(dirPtr);	/* INTL: Native. */
a298 1

d303 1
a303 1
 * TclpCopyFile, DoCopyFile --
d328 3
a330 3
TclpCopyFile(src, dst)
    CONST char *src;		/* Pathname of file to be copied (UTF-8). */
    CONST char *dst;		/* Pathname of file to copy to (UTF-8). */
d332 2
a333 9
    int result;
    Tcl_DString srcString, dstString;

    Tcl_UtfToExternalDString(NULL, src, -1, &srcString);
    Tcl_UtfToExternalDString(NULL, dst, -1, &dstString);
    result = DoCopyFile(&srcString, &dstString);
    Tcl_DStringFree(&srcString);
    Tcl_DStringFree(&dstString);
    return result;
d337 3
a339 3
DoCopyFile(srcPtr, dstPtr)
    Tcl_DString *srcPtr;	/* Pathname of file to be copied (native). */
    Tcl_DString *dstPtr;	/* Pathname of file to copy to (native). */
d341 1
a341 5
    struct stat srcStatBuf, dstStatBuf;
    CONST char *src, *dst;

    src = Tcl_DStringValue(srcPtr);
    dst = Tcl_DStringValue(dstPtr);
d347 1
a347 1
    if (lstat(src, &srcStatBuf) != 0) {			/* INTL: Native. */
d360 1
a360 1
    if (lstat(dst, &dstStatBuf) == 0) {			/* INTL: Native. */
d373 1
d388 1
d432 1
a432 1
    CONST struct stat *statBufPtr;
d441 1
a441 1
    if ((srcFd = open(src, O_RDONLY, 0)) < 0) {		/* INTL: Native. */
d445 1
a445 1
    dstFd = open(dst, O_CREAT | O_TRUNC | O_WRONLY,	/* INTL: Native. */
d503 1
a503 1
 * TclpDeleteFile, DoDeleteFile --
d522 3
a524 3
int
TclpDeleteFile(path) 
    CONST char *path;		/* Pathname of file to be removed (UTF-8). */
d526 1
a526 7
    int result;
    Tcl_DString pathString;

    Tcl_UtfToExternalDString(NULL, path, -1, &pathString);
    result = DoDeleteFile(&pathString);
    Tcl_DStringFree(&pathString);
    return result;
d530 2
a531 2
DoDeleteFile(pathPtr)
    Tcl_DString *pathPtr;	/* Pathname of file to be removed (native). */
a532 3
    CONST char *path;

    path = Tcl_DStringValue(pathPtr);
d565 3
a567 3
int
TclpCreateDirectory(path)
    CONST char *path;		/* Pathname of directory to create (UTF-8). */
d569 1
a569 7
    int result;
    Tcl_DString pathString;

    Tcl_UtfToExternalDString(NULL, path, -1, &pathString);
    result = DoCreateDirectory(&pathString);
    Tcl_DStringFree(&pathString);
    return result;
d573 2
a574 2
DoCreateDirectory(pathPtr)
    Tcl_DString *pathPtr;	/* Pathname of directory to create (native). */
a576 3
    CONST char *path;

    path = Tcl_DStringValue(pathPtr);
d596 1
a596 1
 * TclpCopyDirectory --
d607 2
a608 2
 *	is stored in errorPtr.  See TclpCreateDirectory and TclpCopyFile
 *	for a description of possible values for errno.
d619 5
a623 8
int
TclpCopyDirectory(src, dst, errorPtr)
    CONST char *src;		/* Pathname of directory to be copied
				 * (UTF-8). */
    CONST char *dst;		/* Pathname of target directory (UTF-8). */
    Tcl_DString *errorPtr;	/* If non-NULL, uninitialized or free
				 * DString filled with UTF-8 name of file
				 * causing error. */
d625 1
d627 1
a627 1
    int result;
d629 6
a634 2
    Tcl_UtfToExternalDString(NULL, src, -1, &srcString);
    Tcl_UtfToExternalDString(NULL, dst, -1, &dstString);
d636 1
a636 1
    result = TraverseUnixTree(TraversalCopy, &srcString, &dstString, errorPtr);
d640 7
a646 1
    return result;
d648 1
d676 5
a680 10
int
TclpRemoveDirectory(path, recursive, errorPtr) 
    CONST char *path;		/* Pathname of directory to be removed
				 * (UTF-8). */
    int recursive;		/* If non-zero, removes directories that
				 * are nonempty.  Otherwise, will only remove
				 * empty directories. */
    Tcl_DString *errorPtr;	/* If non-NULL, uninitialized or free
				 * DString filled with UTF-8 name of file
				 * causing error. */
d682 1
a682 1
    int result;
d684 1
d686 3
a688 2
    Tcl_UtfToExternalDString(NULL, path, -1, &pathString);
    result = DoRemoveDirectory(&pathString, recursive, errorPtr);
d691 6
a696 1
    return result;
d711 9
d721 8
a728 1
    path = Tcl_DStringValue(pathPtr);
d735 2
d741 1
a741 1
	return TCL_ERROR;
d749 9
a757 1
    return TraverseUnixTree(TraversalDelete, pathPtr, NULL, errorPtr);
d794 1
a794 1
    struct stat statBuf;
d798 1
a798 1
    struct dirent *dirEntPtr;
d806 1
a806 1
    if (lstat(source, &statBuf) != 0) {			/* INTL: Native. */
d841 2
a842 2
				  
    while ((dirEntPtr = readdir(dirPtr)) != NULL) {	/* INTL: Native. */
d907 2
a908 2
 *      Called from TraverseUnixTree in order to execute a recursive copy of a 
 *      directory. 
d924 1
a924 1
    CONST struct stat *statBufPtr;
d933 2
a934 1
	    if (DoCopyFile(srcPtr, dstPtr) == TCL_OK) {
d940 1
a940 1
	    if (DoCreateDirectory(dstPtr) == TCL_OK) {
d989 1
a989 1
    CONST struct stat *statBufPtr;
d998 1
a998 1
	    if (DoDeleteFile(srcPtr) == 0) {
d1043 1
a1043 1
    CONST struct stat *statBufPtr;
d1099 1
a1099 1
    CONST char *fileName;	/* The name of the file (UTF-8). */
d1102 1
a1102 1
    struct stat statBuf;
d1106 1
a1106 1
    result = TclStat(fileName, &statBuf);
d1109 2
a1110 1
	Tcl_AppendResult(interp, "could not read \"", fileName, "\": ",
d1117 1
a1117 1
	*attributePtrPtr = Tcl_NewIntObj(statBuf.st_gid);
d1151 1
a1151 1
    CONST char *fileName;	/* The name of the file (UTF-8). */
d1154 1
a1154 1
    struct stat statBuf;
d1158 1
a1158 1
    result = TclStat(fileName, &statBuf);
d1161 2
a1162 1
	Tcl_AppendResult(interp, "could not read \"", fileName, "\": ",
d1169 1
a1169 1
	*attributePtrPtr = Tcl_NewIntObj(statBuf.st_uid);
d1203 1
a1203 1
    CONST char *fileName;	    /* The name of the file (UTF-8). */
d1206 1
a1206 1
    struct stat statBuf;
d1210 1
a1210 1
    result = TclStat(fileName, &statBuf);
d1213 2
a1214 1
	Tcl_AppendResult(interp, "could not read \"", fileName, "\": ",
d1219 1
a1219 1
    sprintf(returnString, "%0#5lo", (statBuf.st_mode & 0x00007FFF));
d1246 1
a1246 1
    CONST char *fileName;	    /* The name of the file (UTF-8). */
a1250 1
    Tcl_DString ds;
d1254 1
d1268 2
a1269 1
		    fileName, "\": group \"", string, "\" does not exist",
d1276 1
a1276 1
    native = Tcl_UtfToExternalDString(NULL, fileName, -1, &ds);
a1277 1
    Tcl_DStringFree(&ds);
d1282 2
a1283 1
		fileName, "\": ", Tcl_PosixError(interp), (char *) NULL);
d1309 1
a1309 1
    CONST char *fileName;	    /* The name of the file (UTF-8). */
a1313 1
    Tcl_DString ds;
d1317 1
d1330 2
a1331 1
		    fileName, "\": user \"", string, "\" does not exist",
d1338 1
a1338 1
    native = Tcl_UtfToExternalDString(NULL, fileName, -1, &ds);
a1339 1
    Tcl_DStringFree(&ds);
d1342 3
a1344 2
	Tcl_AppendResult(interp, "could not set owner for file \"", fileName,
		"\": ", Tcl_PosixError(interp), (char *) NULL);
d1370 1
a1370 1
    CONST char *fileName;	    /* The name of the file (UTF-8). */
a1376 1
    Tcl_DString ds;
d1384 1
a1384 1
	struct stat buf;
d1393 1
a1393 1
	result = TclStat(fileName, &buf);
d1395 2
a1396 1
	    Tcl_AppendResult(interp, "could not read \"", fileName, "\": ",
d1410 1
a1410 1
    native = Tcl_UtfToExternalDString(NULL, fileName, -1, &ds);
a1411 1
    Tcl_DStringFree(&ds);
d1414 2
a1415 1
		"could not set permissions for file \"", fileName, "\": ",
d1425 1
a1425 1
 * TclpListVolumes --
d1430 1
a1430 3
 *	A standard Tcl result.  Will always be TCL_OK, since there is no way
 *	that this command can fail.  Also, the interpreter's result is set to 
 *	the list of volumes.
d1438 2
a1439 4
int
TclpListVolumes(interp)
    Tcl_Interp *interp;			/* Interpreter to which to pass
					 * the volume list. */
d1441 4
a1444 5
    Tcl_Obj *resultPtr;
    
    resultPtr = Tcl_GetObjResult(interp);
    Tcl_SetStringObj(resultPtr, "/", 1);
    return TCL_OK;	
d1635 88
d1724 22
d1747 2
@


1.3
log
@touched all sources to ease next import
@
text
@@


1.3.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d13 1
a13 1
 * RCS: @@(#) $Id: tclUnixFCmd.c,v 1.25 2002/06/28 09:56:54 dkf Exp $
d74 1
a74 1
			    int objIndex, Tcl_Obj *fileName,
d77 1
a77 1
			    int objIndex, Tcl_Obj *fileName,
d81 1
a81 1
			    Tcl_Obj *fileName, Tcl_Obj **attributePtrPtr));
d83 1
a83 1
			    int objIndex, Tcl_Obj *fileName,
d86 1
a86 1
			    int objIndex, Tcl_Obj *fileName,
d90 1
a90 1
			    Tcl_Obj *fileName, Tcl_Obj *attributePtr));
d100 1
a100 1
	Tcl_DString *dstPtr, CONST Tcl_StatBuf *statBufPtr, int type,
d113 1
a113 1
CONST char *tclpFileAttrStrings[] = {
d131 1
a131 1
			    CONST char *dst, CONST Tcl_StatBuf *statBufPtr));
d133 5
a137 5
			    CONST char *dst, CONST Tcl_StatBuf *statBufPtr));
static int		DoCopyFile _ANSI_ARGS_((CONST char *srcPtr,
			    CONST char *dstPtr));
static int		DoCreateDirectory _ANSI_ARGS_((CONST char *pathPtr));
static int		DoDeleteFile _ANSI_ARGS_((CONST char *path));
d143 1
a143 1
			    Tcl_DString *dstPtr, CONST Tcl_StatBuf *statBufPtr,
d146 1
a146 1
			    Tcl_DString *dstPtr, CONST Tcl_StatBuf *statBufPtr,
a151 23

#ifdef PURIFY
/*
 * realpath and purify don't mix happily.  It has been noted that realpath
 * should not be used with purify because of bogus warnings, but just
 * memset'ing the resolved path will squelch those.  This assumes we are
 * passing the standard MAXPATHLEN size resolved arg.
 */
static char *		Realpath _ANSI_ARGS_((CONST char *path,
			    char *resolved));

char *
Realpath(path, resolved)
    CONST char *path;
    char *resolved;
{
    memset(resolved, 0, MAXPATHLEN);
    return realpath(path, resolved);
}
#else
#define Realpath realpath
#endif

d156 1
a156 1
 * TclpObjRenameFile, DoRenameFile --
d188 6
a193 4
int 
TclpObjRenameFile(srcPathPtr, destPathPtr)
    Tcl_Obj *srcPathPtr;
    Tcl_Obj *destPathPtr;
d195 10
a204 2
    return DoRenameFile(Tcl_FSGetNativePath(srcPathPtr), 
			Tcl_FSGetNativePath(destPathPtr));
d242 1
a242 1
	Tcl_DirEntry *dirEntPtr;
d244 2
a245 2
	if ((Realpath((char *) src, srcPath) != NULL)	/* INTL: Native. */
		&& (Realpath((char *) dst, dstPath) != NULL) /* INTL: Native. */
d250 1
a250 1
		    dirEntPtr = TclOSreaddir(dirPtr); /* INTL: Native. */
d286 1
d291 1
a291 1
 * TclpObjCopyFile, DoCopyFile --
d316 3
a318 3
TclpObjCopyFile(srcPathPtr, destPathPtr)
    Tcl_Obj *srcPathPtr;
    Tcl_Obj *destPathPtr;
d320 9
a328 2
    return DoCopyFile(Tcl_FSGetNativePath(srcPathPtr), 
		      Tcl_FSGetNativePath(destPathPtr));
d332 3
a334 3
DoCopyFile(src, dst)
    CONST char *src;	/* Pathname of file to be copied (native). */
    CONST char *dst;	/* Pathname of file to copy to (native). */
d336 5
a340 1
    Tcl_StatBuf srcStatBuf, dstStatBuf;
d346 1
a346 1
    if (TclOSlstat(src, &srcStatBuf) != 0) {		/* INTL: Native. */
d359 1
a359 1
    if (TclOSlstat(dst, &dstStatBuf) == 0) {		/* INTL: Native. */
a371 1
#ifndef DJGPP
a385 1
#endif
d429 1
a429 1
    CONST Tcl_StatBuf *statBufPtr;
d438 1
a438 1
    if ((srcFd = TclOSopen(src, O_RDONLY, 0)) < 0) {	/* INTL: Native. */
d442 1
a442 1
    dstFd = TclOSopen(dst, O_CREAT|O_TRUNC|O_WRONLY,	/* INTL: Native. */
d500 1
a500 1
 * TclpObjDeleteFile, DoDeleteFile --
d519 3
a521 3
int 
TclpObjDeleteFile(pathPtr)
    Tcl_Obj *pathPtr;
d523 7
a529 1
    return DoDeleteFile(Tcl_FSGetNativePath(pathPtr));
d533 2
a534 2
DoDeleteFile(path)
    CONST char *path;	/* Pathname of file to be removed (native). */
d536 3
d571 3
a573 3
int 
TclpObjCreateDirectory(pathPtr)
    Tcl_Obj *pathPtr;
d575 7
a581 1
    return DoCreateDirectory(Tcl_FSGetNativePath(pathPtr));
d585 2
a586 2
DoCreateDirectory(path)
    CONST char *path;	/* Pathname of directory to create (native). */
d589 3
d611 1
a611 1
 * TclpObjCopyDirectory --
d622 2
a623 2
 *	is stored in errorPtr.  See TclpObjCreateDirectory and 
 *	TclpObjCopyFile for a description of possible values for errno.
d634 8
a641 5
int 
TclpObjCopyDirectory(srcPathPtr, destPathPtr, errorPtr)
    Tcl_Obj *srcPathPtr;
    Tcl_Obj *destPathPtr;
    Tcl_Obj **errorPtr;
a642 1
    Tcl_DString ds;
d644 1
a644 1
    int ret;
d646 2
a647 6
    Tcl_UtfToExternalDString(NULL, 
			     Tcl_FSGetTranslatedStringPath(NULL,srcPathPtr), 
			     -1, &srcString);
    Tcl_UtfToExternalDString(NULL, 
			     Tcl_FSGetTranslatedStringPath(NULL,destPathPtr), 
			     -1, &dstString);
d649 1
a649 1
    ret = TraverseUnixTree(TraversalCopy, &srcString, &dstString, &ds);
d653 1
a653 7

    if (ret != TCL_OK) {
	*errorPtr = Tcl_NewStringObj(Tcl_DStringValue(&ds), -1);
	Tcl_DStringFree(&ds);
	Tcl_IncrRefCount(*errorPtr);
    }
    return ret;
a654 1

d682 10
a691 5
int 
TclpObjRemoveDirectory(pathPtr, recursive, errorPtr)
    Tcl_Obj *pathPtr;
    int recursive;
    Tcl_Obj **errorPtr;
d693 1
a693 1
    Tcl_DString ds;
a694 1
    int ret;
d696 2
a697 3
    Tcl_UtfToExternalDString(NULL, Tcl_FSGetTranslatedStringPath(NULL, pathPtr), 
			     -1, &pathString);
    ret = DoRemoveDirectory(&pathString, recursive, &ds);
d700 1
a700 6
    if (ret != TCL_OK) {
	*errorPtr = Tcl_NewStringObj(Tcl_DStringValue(&ds), -1);
	Tcl_DStringFree(&ds);
	Tcl_IncrRefCount(*errorPtr);
    }
    return ret;
d715 1
a715 3
    mode_t oldPerm = 0;
    int result;
    
a716 14
    
    if (recursive != 0) {
	/* We should try to change permissions so this can be deleted */
	Tcl_StatBuf statBuf;
	int newPerm;

	if (TclOSstat(path, &statBuf) == 0) {
	    oldPerm = (mode_t) (statBuf.st_mode & 0x00007FFF);
	}
	
	newPerm = oldPerm | (64+128+256);
	chmod(path, (mode_t) newPerm);
    }
    
a722 2

    result = TCL_OK;
d727 1
a727 1
	result = TCL_ERROR;
d735 1
a735 9
    if (result == TCL_OK) {
	result = TraverseUnixTree(TraversalDelete, pathPtr, NULL, errorPtr);
    }
    
    if ((result != TCL_OK) && (recursive != 0)) {
        /* Try to restore permissions */
        chmod(path, oldPerm);
    }
    return result;
d772 1
a772 1
    Tcl_StatBuf statBuf;
d776 1
a776 1
    Tcl_DirEntry *dirEntPtr;
d784 1
a784 1
    if (TclOSlstat(source, &statBuf) != 0) {		/* INTL: Native. */
d819 2
a820 2

    while ((dirEntPtr = TclOSreaddir(dirPtr)) != NULL) { /* INTL: Native. */
d885 2
a886 2
 *      Called from TraverseUnixTree in order to execute a recursive copy
 *      of a directory.
d902 1
a902 1
    CONST Tcl_StatBuf *statBufPtr;
d911 1
a911 2
	    if (DoCopyFile(Tcl_DStringValue(srcPtr), 
		    Tcl_DStringValue(dstPtr)) == TCL_OK) {
d917 1
a917 1
	    if (DoCreateDirectory(Tcl_DStringValue(dstPtr)) == TCL_OK) {
d966 1
a966 1
    CONST Tcl_StatBuf *statBufPtr;
d975 1
a975 1
	    if (DoDeleteFile(Tcl_DStringValue(srcPtr)) == 0) {
d1020 1
a1020 1
    CONST Tcl_StatBuf *statBufPtr;
d1076 1
a1076 1
    Tcl_Obj *fileName;  	/* The name of the file (UTF-8). */
d1079 1
a1079 1
    Tcl_StatBuf statBuf;
d1083 1
a1083 1
    result = TclpObjStat(fileName, &statBuf);
d1086 1
a1086 2
	Tcl_AppendResult(interp, "could not read \"", 
		Tcl_GetString(fileName), "\": ",
d1093 1
a1093 1
	*attributePtrPtr = Tcl_NewIntObj((int) statBuf.st_gid);
d1127 1
a1127 1
    Tcl_Obj *fileName;  	/* The name of the file (UTF-8). */
d1130 1
a1130 1
    Tcl_StatBuf statBuf;
d1134 1
a1134 1
    result = TclpObjStat(fileName, &statBuf);
d1137 1
a1137 2
	Tcl_AppendResult(interp, "could not read \"", 
		Tcl_GetString(fileName), "\": ",
d1144 1
a1144 1
	*attributePtrPtr = Tcl_NewIntObj((int) statBuf.st_uid);
d1178 1
a1178 1
    Tcl_Obj *fileName;  	    /* The name of the file (UTF-8). */
d1181 1
a1181 1
    Tcl_StatBuf statBuf;
d1185 1
a1185 1
    result = TclpObjStat(fileName, &statBuf);
d1188 1
a1188 2
	Tcl_AppendResult(interp, "could not read \"", 
		Tcl_GetString(fileName), "\": ",
d1193 1
a1193 1
    sprintf(returnString, "%0#5lo", (long) (statBuf.st_mode & 0x00007FFF));
d1220 1
a1220 1
    Tcl_Obj *fileName;	            /* The name of the file (UTF-8). */
d1225 1
a1228 1
	Tcl_DString ds;
d1242 1
a1242 2
		    Tcl_GetString(fileName), "\": group \"", 
		    string, "\" does not exist",
d1249 1
a1249 1
    native = Tcl_FSGetNativePath(fileName);
d1251 1
d1256 1
a1256 2
	    Tcl_GetString(fileName), "\": ", Tcl_PosixError(interp), 
	    (char *) NULL);
d1282 1
a1282 1
    Tcl_Obj *fileName;   	    /* The name of the file (UTF-8). */
d1287 1
a1290 1
	Tcl_DString ds;
d1303 1
a1303 2
			     Tcl_GetString(fileName), "\": user \"", 
			     string, "\" does not exist",
d1310 1
a1310 1
    native = Tcl_FSGetNativePath(fileName);
d1312 1
d1315 2
a1316 3
	Tcl_AppendResult(interp, "could not set owner for file \"", 
			 Tcl_GetString(fileName), "\": ", 
			 Tcl_PosixError(interp), (char *) NULL);
d1342 1
a1342 1
    Tcl_Obj *fileName;  	    /* The name of the file (UTF-8). */
d1349 1
d1357 1
a1357 1
	Tcl_StatBuf buf;
d1366 1
a1366 1
	result = TclpObjStat(fileName, &buf);
d1368 1
a1368 2
	    Tcl_AppendResult(interp, "could not read \"", 
		    Tcl_GetString(fileName), "\": ",
d1382 1
a1382 1
    native = Tcl_FSGetNativePath(fileName);
d1384 1
d1387 1
a1387 2
		"could not set permissions for file \"", 
		Tcl_GetString(fileName), "\": ",
d1397 1
a1397 1
 * TclpObjListVolumes --
d1402 3
a1404 1
 *	The list of volumes.
d1412 4
a1415 2
Tcl_Obj*
TclpObjListVolumes(void)
d1417 5
a1421 4
    Tcl_Obj *resultPtr = Tcl_NewStringObj("/",1);

    Tcl_IncrRefCount(resultPtr);
    return resultPtr;
a1611 88

/*
 *---------------------------------------------------------------------------
 *
 * TclpObjNormalizePath --
 *
 *	This function scans through a path specification and replaces
 *	it, in place, with a normalized version.  A normalized version
 *	is one in which all symlinks in the path are replaced with
 *	their expanded form (except a symlink at the very end of the
 *	path).
 *
 * Results:
 *	The new 'nextCheckpoint' value, giving as far as we could
 *	understand in the path.
 *
 * Side effects:
 *	The pathPtr string, is modified.
 *
 *---------------------------------------------------------------------------
 */

int
TclpObjNormalizePath(interp, pathPtr, nextCheckpoint)
    Tcl_Interp *interp;
    Tcl_Obj *pathPtr;
    int nextCheckpoint;
{
    char *currentPathEndPosition;
    int pathLen;
    char cur;
    char *path = Tcl_GetStringFromObj(pathPtr, &pathLen);
#ifndef NO_REALPATH
    char normPath[MAXPATHLEN];
    Tcl_DString ds;
    CONST char *nativePath; 
#endif

    currentPathEndPosition = path + nextCheckpoint;

    while (1) {
	cur = *currentPathEndPosition;
	if ((cur == '/') && (path != currentPathEndPosition)) {
	    /* Reached directory separator */
	    Tcl_DString ds;
	    CONST char *nativePath;
	    int accessOk;

	    nativePath = Tcl_UtfToExternalDString(NULL, path, 
		    currentPathEndPosition - path, &ds);
	    accessOk = access(nativePath, F_OK);
	    Tcl_DStringFree(&ds);
	    if (accessOk != 0) {
		/* File doesn't exist */
		break;
	    }
	    /* Update the acceptable point */
	    nextCheckpoint = currentPathEndPosition - path;
	} else if (cur == 0) {
	    /* Reached end of string */
	    break;
	}
	currentPathEndPosition++;
    }
    /* 
     * We should really now convert this to a canonical path.  We do
     * that with 'realpath' if we have it available.  Otherwise we could
     * step through every single path component, checking whether it is a 
     * symlink, but that would be a lot of work, and most modern OSes 
     * have 'realpath'.
     */
#ifndef NO_REALPATH
    /* 
     * If we only had '/foo' or '/' then we never increment nextCheckpoint
     * and we don't need or want to go through 'Realpath'.  Also, on some
     * platforms, passing an empty string to 'Realpath' will give us the
     * normalized pwd, which is not what we want at all!
     */
    if (nextCheckpoint == 0) return 0;
    
    nativePath = Tcl_UtfToExternalDString(NULL, path, nextCheckpoint, &ds);
    if (Realpath(nativePath, normPath) != NULL) {
	/* 
	 * Free up the native path and put in its place the
	 * converted, normalized path.
	 */
	Tcl_DStringFree(&ds);
	Tcl_ExternalToUtfDString(NULL, normPath, (int) strlen(normPath), &ds);
a1612 22
	if (path[nextCheckpoint] != '\0') {
	    /* not at end, append remaining path */
	    int normLen = Tcl_DStringLength(&ds);
	    Tcl_DStringAppend(&ds, path + nextCheckpoint,
		    pathLen - nextCheckpoint);
	    /* 
	     * We recognise up to and including the directory
	     * separator.
	     */	
	    nextCheckpoint = normLen + 1;
	} else {
	    /* We recognise the whole string */ 
	    nextCheckpoint = Tcl_DStringLength(&ds);
	}
	/* 
	 * Overwrite with the normalized path.
	 */
	Tcl_SetStringObj(pathPtr, Tcl_DStringValue(&ds),
		Tcl_DStringLength(&ds));
    }
    Tcl_DStringFree(&ds);
#endif	/* !NO_REALPATH */
a1613 2
    return nextCheckpoint;
}
@


1.3.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@d13 1
a13 1
 * RCS: @@(#) $Id: tclUnixFCmd.c,v 1.25 2002/06/28 09:56:54 dkf Exp $
d74 1
a74 1
			    int objIndex, Tcl_Obj *fileName,
d77 1
a77 1
			    int objIndex, Tcl_Obj *fileName,
d81 1
a81 1
			    Tcl_Obj *fileName, Tcl_Obj **attributePtrPtr));
d83 1
a83 1
			    int objIndex, Tcl_Obj *fileName,
d86 1
a86 1
			    int objIndex, Tcl_Obj *fileName,
d90 1
a90 1
			    Tcl_Obj *fileName, Tcl_Obj *attributePtr));
d100 1
a100 1
	Tcl_DString *dstPtr, CONST Tcl_StatBuf *statBufPtr, int type,
d113 1
a113 1
CONST char *tclpFileAttrStrings[] = {
d131 1
a131 1
			    CONST char *dst, CONST Tcl_StatBuf *statBufPtr));
d133 5
a137 5
			    CONST char *dst, CONST Tcl_StatBuf *statBufPtr));
static int		DoCopyFile _ANSI_ARGS_((CONST char *srcPtr,
			    CONST char *dstPtr));
static int		DoCreateDirectory _ANSI_ARGS_((CONST char *pathPtr));
static int		DoDeleteFile _ANSI_ARGS_((CONST char *path));
d143 1
a143 1
			    Tcl_DString *dstPtr, CONST Tcl_StatBuf *statBufPtr,
d146 1
a146 1
			    Tcl_DString *dstPtr, CONST Tcl_StatBuf *statBufPtr,
a151 23

#ifdef PURIFY
/*
 * realpath and purify don't mix happily.  It has been noted that realpath
 * should not be used with purify because of bogus warnings, but just
 * memset'ing the resolved path will squelch those.  This assumes we are
 * passing the standard MAXPATHLEN size resolved arg.
 */
static char *		Realpath _ANSI_ARGS_((CONST char *path,
			    char *resolved));

char *
Realpath(path, resolved)
    CONST char *path;
    char *resolved;
{
    memset(resolved, 0, MAXPATHLEN);
    return realpath(path, resolved);
}
#else
#define Realpath realpath
#endif

d156 1
a156 1
 * TclpObjRenameFile, DoRenameFile --
d188 6
a193 4
int 
TclpObjRenameFile(srcPathPtr, destPathPtr)
    Tcl_Obj *srcPathPtr;
    Tcl_Obj *destPathPtr;
d195 10
a204 2
    return DoRenameFile(Tcl_FSGetNativePath(srcPathPtr), 
			Tcl_FSGetNativePath(destPathPtr));
d242 1
a242 1
	Tcl_DirEntry *dirEntPtr;
d244 2
a245 2
	if ((Realpath((char *) src, srcPath) != NULL)	/* INTL: Native. */
		&& (Realpath((char *) dst, dstPath) != NULL) /* INTL: Native. */
d250 1
a250 1
		    dirEntPtr = TclOSreaddir(dirPtr); /* INTL: Native. */
d286 1
d291 1
a291 1
 * TclpObjCopyFile, DoCopyFile --
d316 3
a318 3
TclpObjCopyFile(srcPathPtr, destPathPtr)
    Tcl_Obj *srcPathPtr;
    Tcl_Obj *destPathPtr;
d320 9
a328 2
    return DoCopyFile(Tcl_FSGetNativePath(srcPathPtr), 
		      Tcl_FSGetNativePath(destPathPtr));
d332 3
a334 3
DoCopyFile(src, dst)
    CONST char *src;	/* Pathname of file to be copied (native). */
    CONST char *dst;	/* Pathname of file to copy to (native). */
d336 5
a340 1
    Tcl_StatBuf srcStatBuf, dstStatBuf;
d346 1
a346 1
    if (TclOSlstat(src, &srcStatBuf) != 0) {		/* INTL: Native. */
d359 1
a359 1
    if (TclOSlstat(dst, &dstStatBuf) == 0) {		/* INTL: Native. */
a371 1
#ifndef DJGPP
a385 1
#endif
d429 1
a429 1
    CONST Tcl_StatBuf *statBufPtr;
d438 1
a438 1
    if ((srcFd = TclOSopen(src, O_RDONLY, 0)) < 0) {	/* INTL: Native. */
d442 1
a442 1
    dstFd = TclOSopen(dst, O_CREAT|O_TRUNC|O_WRONLY,	/* INTL: Native. */
d500 1
a500 1
 * TclpObjDeleteFile, DoDeleteFile --
d519 3
a521 3
int 
TclpObjDeleteFile(pathPtr)
    Tcl_Obj *pathPtr;
d523 7
a529 1
    return DoDeleteFile(Tcl_FSGetNativePath(pathPtr));
d533 2
a534 2
DoDeleteFile(path)
    CONST char *path;	/* Pathname of file to be removed (native). */
d536 3
d571 3
a573 3
int 
TclpObjCreateDirectory(pathPtr)
    Tcl_Obj *pathPtr;
d575 7
a581 1
    return DoCreateDirectory(Tcl_FSGetNativePath(pathPtr));
d585 2
a586 2
DoCreateDirectory(path)
    CONST char *path;	/* Pathname of directory to create (native). */
d589 3
d611 1
a611 1
 * TclpObjCopyDirectory --
d622 2
a623 2
 *	is stored in errorPtr.  See TclpObjCreateDirectory and 
 *	TclpObjCopyFile for a description of possible values for errno.
d634 8
a641 5
int 
TclpObjCopyDirectory(srcPathPtr, destPathPtr, errorPtr)
    Tcl_Obj *srcPathPtr;
    Tcl_Obj *destPathPtr;
    Tcl_Obj **errorPtr;
a642 1
    Tcl_DString ds;
d644 1
a644 1
    int ret;
d646 2
a647 6
    Tcl_UtfToExternalDString(NULL, 
			     Tcl_FSGetTranslatedStringPath(NULL,srcPathPtr), 
			     -1, &srcString);
    Tcl_UtfToExternalDString(NULL, 
			     Tcl_FSGetTranslatedStringPath(NULL,destPathPtr), 
			     -1, &dstString);
d649 1
a649 1
    ret = TraverseUnixTree(TraversalCopy, &srcString, &dstString, &ds);
d653 1
a653 7

    if (ret != TCL_OK) {
	*errorPtr = Tcl_NewStringObj(Tcl_DStringValue(&ds), -1);
	Tcl_DStringFree(&ds);
	Tcl_IncrRefCount(*errorPtr);
    }
    return ret;
a654 1

d682 10
a691 5
int 
TclpObjRemoveDirectory(pathPtr, recursive, errorPtr)
    Tcl_Obj *pathPtr;
    int recursive;
    Tcl_Obj **errorPtr;
d693 1
a693 1
    Tcl_DString ds;
a694 1
    int ret;
d696 2
a697 3
    Tcl_UtfToExternalDString(NULL, Tcl_FSGetTranslatedStringPath(NULL, pathPtr), 
			     -1, &pathString);
    ret = DoRemoveDirectory(&pathString, recursive, &ds);
d700 1
a700 6
    if (ret != TCL_OK) {
	*errorPtr = Tcl_NewStringObj(Tcl_DStringValue(&ds), -1);
	Tcl_DStringFree(&ds);
	Tcl_IncrRefCount(*errorPtr);
    }
    return ret;
d715 1
a715 3
    mode_t oldPerm = 0;
    int result;
    
a716 14
    
    if (recursive != 0) {
	/* We should try to change permissions so this can be deleted */
	Tcl_StatBuf statBuf;
	int newPerm;

	if (TclOSstat(path, &statBuf) == 0) {
	    oldPerm = (mode_t) (statBuf.st_mode & 0x00007FFF);
	}
	
	newPerm = oldPerm | (64+128+256);
	chmod(path, (mode_t) newPerm);
    }
    
a722 2

    result = TCL_OK;
d727 1
a727 1
	result = TCL_ERROR;
d735 1
a735 9
    if (result == TCL_OK) {
	result = TraverseUnixTree(TraversalDelete, pathPtr, NULL, errorPtr);
    }
    
    if ((result != TCL_OK) && (recursive != 0)) {
        /* Try to restore permissions */
        chmod(path, oldPerm);
    }
    return result;
d772 1
a772 1
    Tcl_StatBuf statBuf;
d776 1
a776 1
    Tcl_DirEntry *dirEntPtr;
d784 1
a784 1
    if (TclOSlstat(source, &statBuf) != 0) {		/* INTL: Native. */
d819 2
a820 2

    while ((dirEntPtr = TclOSreaddir(dirPtr)) != NULL) { /* INTL: Native. */
d885 2
a886 2
 *      Called from TraverseUnixTree in order to execute a recursive copy
 *      of a directory.
d902 1
a902 1
    CONST Tcl_StatBuf *statBufPtr;
d911 1
a911 2
	    if (DoCopyFile(Tcl_DStringValue(srcPtr), 
		    Tcl_DStringValue(dstPtr)) == TCL_OK) {
d917 1
a917 1
	    if (DoCreateDirectory(Tcl_DStringValue(dstPtr)) == TCL_OK) {
d966 1
a966 1
    CONST Tcl_StatBuf *statBufPtr;
d975 1
a975 1
	    if (DoDeleteFile(Tcl_DStringValue(srcPtr)) == 0) {
d1020 1
a1020 1
    CONST Tcl_StatBuf *statBufPtr;
d1076 1
a1076 1
    Tcl_Obj *fileName;  	/* The name of the file (UTF-8). */
d1079 1
a1079 1
    Tcl_StatBuf statBuf;
d1083 1
a1083 1
    result = TclpObjStat(fileName, &statBuf);
d1086 1
a1086 2
	Tcl_AppendResult(interp, "could not read \"", 
		Tcl_GetString(fileName), "\": ",
d1093 1
a1093 1
	*attributePtrPtr = Tcl_NewIntObj((int) statBuf.st_gid);
d1127 1
a1127 1
    Tcl_Obj *fileName;  	/* The name of the file (UTF-8). */
d1130 1
a1130 1
    Tcl_StatBuf statBuf;
d1134 1
a1134 1
    result = TclpObjStat(fileName, &statBuf);
d1137 1
a1137 2
	Tcl_AppendResult(interp, "could not read \"", 
		Tcl_GetString(fileName), "\": ",
d1144 1
a1144 1
	*attributePtrPtr = Tcl_NewIntObj((int) statBuf.st_uid);
d1178 1
a1178 1
    Tcl_Obj *fileName;  	    /* The name of the file (UTF-8). */
d1181 1
a1181 1
    Tcl_StatBuf statBuf;
d1185 1
a1185 1
    result = TclpObjStat(fileName, &statBuf);
d1188 1
a1188 2
	Tcl_AppendResult(interp, "could not read \"", 
		Tcl_GetString(fileName), "\": ",
d1193 1
a1193 1
    sprintf(returnString, "%0#5lo", (long) (statBuf.st_mode & 0x00007FFF));
d1220 1
a1220 1
    Tcl_Obj *fileName;	            /* The name of the file (UTF-8). */
d1225 1
a1228 1
	Tcl_DString ds;
d1242 1
a1242 2
		    Tcl_GetString(fileName), "\": group \"", 
		    string, "\" does not exist",
d1249 1
a1249 1
    native = Tcl_FSGetNativePath(fileName);
d1251 1
d1256 1
a1256 2
	    Tcl_GetString(fileName), "\": ", Tcl_PosixError(interp), 
	    (char *) NULL);
d1282 1
a1282 1
    Tcl_Obj *fileName;   	    /* The name of the file (UTF-8). */
d1287 1
a1290 1
	Tcl_DString ds;
d1303 1
a1303 2
			     Tcl_GetString(fileName), "\": user \"", 
			     string, "\" does not exist",
d1310 1
a1310 1
    native = Tcl_FSGetNativePath(fileName);
d1312 1
d1315 2
a1316 3
	Tcl_AppendResult(interp, "could not set owner for file \"", 
			 Tcl_GetString(fileName), "\": ", 
			 Tcl_PosixError(interp), (char *) NULL);
d1342 1
a1342 1
    Tcl_Obj *fileName;  	    /* The name of the file (UTF-8). */
d1349 1
d1357 1
a1357 1
	Tcl_StatBuf buf;
d1366 1
a1366 1
	result = TclpObjStat(fileName, &buf);
d1368 1
a1368 2
	    Tcl_AppendResult(interp, "could not read \"", 
		    Tcl_GetString(fileName), "\": ",
d1382 1
a1382 1
    native = Tcl_FSGetNativePath(fileName);
d1384 1
d1387 1
a1387 2
		"could not set permissions for file \"", 
		Tcl_GetString(fileName), "\": ",
d1397 1
a1397 1
 * TclpObjListVolumes --
d1402 3
a1404 1
 *	The list of volumes.
d1412 4
a1415 2
Tcl_Obj*
TclpObjListVolumes(void)
d1417 5
a1421 4
    Tcl_Obj *resultPtr = Tcl_NewStringObj("/",1);

    Tcl_IncrRefCount(resultPtr);
    return resultPtr;
a1611 88

/*
 *---------------------------------------------------------------------------
 *
 * TclpObjNormalizePath --
 *
 *	This function scans through a path specification and replaces
 *	it, in place, with a normalized version.  A normalized version
 *	is one in which all symlinks in the path are replaced with
 *	their expanded form (except a symlink at the very end of the
 *	path).
 *
 * Results:
 *	The new 'nextCheckpoint' value, giving as far as we could
 *	understand in the path.
 *
 * Side effects:
 *	The pathPtr string, is modified.
 *
 *---------------------------------------------------------------------------
 */

int
TclpObjNormalizePath(interp, pathPtr, nextCheckpoint)
    Tcl_Interp *interp;
    Tcl_Obj *pathPtr;
    int nextCheckpoint;
{
    char *currentPathEndPosition;
    int pathLen;
    char cur;
    char *path = Tcl_GetStringFromObj(pathPtr, &pathLen);
#ifndef NO_REALPATH
    char normPath[MAXPATHLEN];
    Tcl_DString ds;
    CONST char *nativePath; 
#endif

    currentPathEndPosition = path + nextCheckpoint;

    while (1) {
	cur = *currentPathEndPosition;
	if ((cur == '/') && (path != currentPathEndPosition)) {
	    /* Reached directory separator */
	    Tcl_DString ds;
	    CONST char *nativePath;
	    int accessOk;

	    nativePath = Tcl_UtfToExternalDString(NULL, path, 
		    currentPathEndPosition - path, &ds);
	    accessOk = access(nativePath, F_OK);
	    Tcl_DStringFree(&ds);
	    if (accessOk != 0) {
		/* File doesn't exist */
		break;
	    }
	    /* Update the acceptable point */
	    nextCheckpoint = currentPathEndPosition - path;
	} else if (cur == 0) {
	    /* Reached end of string */
	    break;
	}
	currentPathEndPosition++;
    }
    /* 
     * We should really now convert this to a canonical path.  We do
     * that with 'realpath' if we have it available.  Otherwise we could
     * step through every single path component, checking whether it is a 
     * symlink, but that would be a lot of work, and most modern OSes 
     * have 'realpath'.
     */
#ifndef NO_REALPATH
    /* 
     * If we only had '/foo' or '/' then we never increment nextCheckpoint
     * and we don't need or want to go through 'Realpath'.  Also, on some
     * platforms, passing an empty string to 'Realpath' will give us the
     * normalized pwd, which is not what we want at all!
     */
    if (nextCheckpoint == 0) return 0;
    
    nativePath = Tcl_UtfToExternalDString(NULL, path, nextCheckpoint, &ds);
    if (Realpath(nativePath, normPath) != NULL) {
	/* 
	 * Free up the native path and put in its place the
	 * converted, normalized path.
	 */
	Tcl_DStringFree(&ds);
	Tcl_ExternalToUtfDString(NULL, normPath, (int) strlen(normPath), &ds);
a1612 22
	if (path[nextCheckpoint] != '\0') {
	    /* not at end, append remaining path */
	    int normLen = Tcl_DStringLength(&ds);
	    Tcl_DStringAppend(&ds, path + nextCheckpoint,
		    pathLen - nextCheckpoint);
	    /* 
	     * We recognise up to and including the directory
	     * separator.
	     */	
	    nextCheckpoint = normLen + 1;
	} else {
	    /* We recognise the whole string */ 
	    nextCheckpoint = Tcl_DStringLength(&ds);
	}
	/* 
	 * Overwrite with the normalized path.
	 */
	Tcl_SetStringObj(pathPtr, Tcl_DStringValue(&ds),
		Tcl_DStringLength(&ds));
    }
    Tcl_DStringFree(&ds);
#endif	/* !NO_REALPATH */
a1613 2
    return nextCheckpoint;
}
@


1.2
log
@touched all Tcl files to ease next import.
@
text
@@


1.2.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.2.16.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d74 1
a74 1
			    int objIndex, Tcl_Obj *fileName,
d77 1
a77 1
			    int objIndex, Tcl_Obj *fileName,
d81 1
a81 1
			    Tcl_Obj *fileName, Tcl_Obj **attributePtrPtr));
d83 1
a83 1
			    int objIndex, Tcl_Obj *fileName,
d86 1
a86 1
			    int objIndex, Tcl_Obj *fileName,
d90 1
a90 1
			    Tcl_Obj *fileName, Tcl_Obj *attributePtr));
d100 1
a100 1
	Tcl_DString *dstPtr, CONST Tcl_StatBuf *statBufPtr, int type,
d113 1
a113 1
CONST char *tclpFileAttrStrings[] = {
d131 1
a131 1
			    CONST char *dst, CONST Tcl_StatBuf *statBufPtr));
d133 5
a137 5
			    CONST char *dst, CONST Tcl_StatBuf *statBufPtr));
static int		DoCopyFile _ANSI_ARGS_((CONST char *srcPtr,
			    CONST char *dstPtr));
static int		DoCreateDirectory _ANSI_ARGS_((CONST char *pathPtr));
static int		DoDeleteFile _ANSI_ARGS_((CONST char *path));
d143 1
a143 1
			    Tcl_DString *dstPtr, CONST Tcl_StatBuf *statBufPtr,
d146 1
a146 1
			    Tcl_DString *dstPtr, CONST Tcl_StatBuf *statBufPtr,
a151 23

#ifdef PURIFY
/*
 * realpath and purify don't mix happily.  It has been noted that realpath
 * should not be used with purify because of bogus warnings, but just
 * memset'ing the resolved path will squelch those.  This assumes we are
 * passing the standard MAXPATHLEN size resolved arg.
 */
static char *		Realpath _ANSI_ARGS_((CONST char *path,
			    char *resolved));

char *
Realpath(path, resolved)
    CONST char *path;
    char *resolved;
{
    memset(resolved, 0, MAXPATHLEN);
    return realpath(path, resolved);
}
#else
#define Realpath realpath
#endif

d156 1
a156 1
 * TclpObjRenameFile, DoRenameFile --
d188 6
a193 4
int 
TclpObjRenameFile(srcPathPtr, destPathPtr)
    Tcl_Obj *srcPathPtr;
    Tcl_Obj *destPathPtr;
d195 10
a204 2
    return DoRenameFile(Tcl_FSGetNativePath(srcPathPtr), 
			Tcl_FSGetNativePath(destPathPtr));
d242 1
a242 1
	Tcl_DirEntry *dirEntPtr;
d244 2
a245 2
	if ((Realpath((char *) src, srcPath) != NULL)	/* INTL: Native. */
		&& (Realpath((char *) dst, dstPath) != NULL) /* INTL: Native. */
d250 1
a250 1
		    dirEntPtr = TclOSreaddir(dirPtr); /* INTL: Native. */
d286 1
d291 1
a291 1
 * TclpObjCopyFile, DoCopyFile --
d316 3
a318 3
TclpObjCopyFile(srcPathPtr, destPathPtr)
    Tcl_Obj *srcPathPtr;
    Tcl_Obj *destPathPtr;
d320 9
a328 2
    return DoCopyFile(Tcl_FSGetNativePath(srcPathPtr), 
		      Tcl_FSGetNativePath(destPathPtr));
d332 3
a334 3
DoCopyFile(src, dst)
    CONST char *src;	/* Pathname of file to be copied (native). */
    CONST char *dst;	/* Pathname of file to copy to (native). */
d336 5
a340 1
    Tcl_StatBuf srcStatBuf, dstStatBuf;
d346 1
a346 1
    if (TclOSlstat(src, &srcStatBuf) != 0) {		/* INTL: Native. */
d359 1
a359 1
    if (TclOSlstat(dst, &dstStatBuf) == 0) {		/* INTL: Native. */
a371 1
#ifndef DJGPP
a385 1
#endif
d429 1
a429 1
    CONST Tcl_StatBuf *statBufPtr;
d438 1
a438 1
    if ((srcFd = TclOSopen(src, O_RDONLY, 0)) < 0) {	/* INTL: Native. */
d442 1
a442 1
    dstFd = TclOSopen(dst, O_CREAT|O_TRUNC|O_WRONLY,	/* INTL: Native. */
d500 1
a500 1
 * TclpObjDeleteFile, DoDeleteFile --
d519 3
a521 3
int 
TclpObjDeleteFile(pathPtr)
    Tcl_Obj *pathPtr;
d523 7
a529 1
    return DoDeleteFile(Tcl_FSGetNativePath(pathPtr));
d533 2
a534 2
DoDeleteFile(path)
    CONST char *path;	/* Pathname of file to be removed (native). */
d536 3
d571 3
a573 3
int 
TclpObjCreateDirectory(pathPtr)
    Tcl_Obj *pathPtr;
d575 7
a581 1
    return DoCreateDirectory(Tcl_FSGetNativePath(pathPtr));
d585 2
a586 2
DoCreateDirectory(path)
    CONST char *path;	/* Pathname of directory to create (native). */
d589 3
d611 1
a611 1
 * TclpObjCopyDirectory --
d622 2
a623 2
 *	is stored in errorPtr.  See TclpObjCreateDirectory and 
 *	TclpObjCopyFile for a description of possible values for errno.
d634 8
a641 5
int 
TclpObjCopyDirectory(srcPathPtr, destPathPtr, errorPtr)
    Tcl_Obj *srcPathPtr;
    Tcl_Obj *destPathPtr;
    Tcl_Obj **errorPtr;
a642 1
    Tcl_DString ds;
d644 1
a644 1
    int ret;
d646 2
a647 6
    Tcl_UtfToExternalDString(NULL, 
			     Tcl_FSGetTranslatedStringPath(NULL,srcPathPtr), 
			     -1, &srcString);
    Tcl_UtfToExternalDString(NULL, 
			     Tcl_FSGetTranslatedStringPath(NULL,destPathPtr), 
			     -1, &dstString);
d649 1
a649 1
    ret = TraverseUnixTree(TraversalCopy, &srcString, &dstString, &ds);
d653 1
a653 7

    if (ret != TCL_OK) {
	*errorPtr = Tcl_NewStringObj(Tcl_DStringValue(&ds), -1);
	Tcl_DStringFree(&ds);
	Tcl_IncrRefCount(*errorPtr);
    }
    return ret;
a654 1

d682 10
a691 5
int 
TclpObjRemoveDirectory(pathPtr, recursive, errorPtr)
    Tcl_Obj *pathPtr;
    int recursive;
    Tcl_Obj **errorPtr;
d693 1
a693 1
    Tcl_DString ds;
a694 1
    int ret;
d696 2
a697 3
    Tcl_UtfToExternalDString(NULL, Tcl_FSGetTranslatedStringPath(NULL, pathPtr), 
			     -1, &pathString);
    ret = DoRemoveDirectory(&pathString, recursive, &ds);
d700 1
a700 6
    if (ret != TCL_OK) {
	*errorPtr = Tcl_NewStringObj(Tcl_DStringValue(&ds), -1);
	Tcl_DStringFree(&ds);
	Tcl_IncrRefCount(*errorPtr);
    }
    return ret;
d715 1
a715 3
    mode_t oldPerm = 0;
    int result;
    
a716 14
    
    if (recursive != 0) {
	/* We should try to change permissions so this can be deleted */
	Tcl_StatBuf statBuf;
	int newPerm;

	if (TclOSstat(path, &statBuf) == 0) {
	    oldPerm = (mode_t) (statBuf.st_mode & 0x00007FFF);
	}
	
	newPerm = oldPerm | (64+128+256);
	chmod(path, (mode_t) newPerm);
    }
    
a722 2

    result = TCL_OK;
d727 1
a727 1
	result = TCL_ERROR;
d735 1
a735 9
    if (result == TCL_OK) {
	result = TraverseUnixTree(TraversalDelete, pathPtr, NULL, errorPtr);
    }
    
    if ((result != TCL_OK) && (recursive != 0)) {
        /* Try to restore permissions */
        chmod(path, oldPerm);
    }
    return result;
d772 1
a772 1
    Tcl_StatBuf statBuf;
d776 1
a776 1
    Tcl_DirEntry *dirEntPtr;
d784 1
a784 1
    if (TclOSlstat(source, &statBuf) != 0) {		/* INTL: Native. */
d819 2
a820 2

    while ((dirEntPtr = TclOSreaddir(dirPtr)) != NULL) { /* INTL: Native. */
d885 2
a886 2
 *      Called from TraverseUnixTree in order to execute a recursive copy
 *      of a directory.
d902 1
a902 1
    CONST Tcl_StatBuf *statBufPtr;
d911 1
a911 2
	    if (DoCopyFile(Tcl_DStringValue(srcPtr), 
		    Tcl_DStringValue(dstPtr)) == TCL_OK) {
d917 1
a917 1
	    if (DoCreateDirectory(Tcl_DStringValue(dstPtr)) == TCL_OK) {
d966 1
a966 1
    CONST Tcl_StatBuf *statBufPtr;
d975 1
a975 1
	    if (DoDeleteFile(Tcl_DStringValue(srcPtr)) == 0) {
d1020 1
a1020 1
    CONST Tcl_StatBuf *statBufPtr;
d1076 1
a1076 1
    Tcl_Obj *fileName;  	/* The name of the file (UTF-8). */
d1079 1
a1079 1
    Tcl_StatBuf statBuf;
d1083 1
a1083 1
    result = TclpObjStat(fileName, &statBuf);
d1086 1
a1086 2
	Tcl_AppendResult(interp, "could not read \"", 
		Tcl_GetString(fileName), "\": ",
d1093 1
a1093 1
	*attributePtrPtr = Tcl_NewIntObj((int) statBuf.st_gid);
d1127 1
a1127 1
    Tcl_Obj *fileName;  	/* The name of the file (UTF-8). */
d1130 1
a1130 1
    Tcl_StatBuf statBuf;
d1134 1
a1134 1
    result = TclpObjStat(fileName, &statBuf);
d1137 1
a1137 2
	Tcl_AppendResult(interp, "could not read \"", 
		Tcl_GetString(fileName), "\": ",
d1144 1
a1144 1
	*attributePtrPtr = Tcl_NewIntObj((int) statBuf.st_uid);
d1178 1
a1178 1
    Tcl_Obj *fileName;  	    /* The name of the file (UTF-8). */
d1181 1
a1181 1
    Tcl_StatBuf statBuf;
d1185 1
a1185 1
    result = TclpObjStat(fileName, &statBuf);
d1188 1
a1188 2
	Tcl_AppendResult(interp, "could not read \"", 
		Tcl_GetString(fileName), "\": ",
d1193 1
a1193 1
    sprintf(returnString, "%0#5lo", (long) (statBuf.st_mode & 0x00007FFF));
d1220 1
a1220 1
    Tcl_Obj *fileName;	            /* The name of the file (UTF-8). */
d1225 1
a1228 1
	Tcl_DString ds;
d1242 1
a1242 2
		    Tcl_GetString(fileName), "\": group \"", 
		    string, "\" does not exist",
d1249 1
a1249 1
    native = Tcl_FSGetNativePath(fileName);
d1251 1
d1256 1
a1256 2
	    Tcl_GetString(fileName), "\": ", Tcl_PosixError(interp), 
	    (char *) NULL);
d1282 1
a1282 1
    Tcl_Obj *fileName;   	    /* The name of the file (UTF-8). */
d1287 1
a1290 1
	Tcl_DString ds;
d1303 1
a1303 2
			     Tcl_GetString(fileName), "\": user \"", 
			     string, "\" does not exist",
d1310 1
a1310 1
    native = Tcl_FSGetNativePath(fileName);
d1312 1
d1315 2
a1316 3
	Tcl_AppendResult(interp, "could not set owner for file \"", 
			 Tcl_GetString(fileName), "\": ", 
			 Tcl_PosixError(interp), (char *) NULL);
d1342 1
a1342 1
    Tcl_Obj *fileName;  	    /* The name of the file (UTF-8). */
d1349 1
d1357 1
a1357 1
	Tcl_StatBuf buf;
d1366 1
a1366 1
	result = TclpObjStat(fileName, &buf);
d1368 1
a1368 2
	    Tcl_AppendResult(interp, "could not read \"", 
		    Tcl_GetString(fileName), "\": ",
d1382 1
a1382 1
    native = Tcl_FSGetNativePath(fileName);
d1384 1
d1387 1
a1387 2
		"could not set permissions for file \"", 
		Tcl_GetString(fileName), "\": ",
d1397 1
a1397 1
 * TclpObjListVolumes --
d1402 3
a1404 1
 *	The list of volumes.
d1412 4
a1415 2
Tcl_Obj*
TclpObjListVolumes(void)
d1417 5
a1421 4
    Tcl_Obj *resultPtr = Tcl_NewStringObj("/",1);

    Tcl_IncrRefCount(resultPtr);
    return resultPtr;
a1611 88

/*
 *---------------------------------------------------------------------------
 *
 * TclpObjNormalizePath --
 *
 *	This function scans through a path specification and replaces
 *	it, in place, with a normalized version.  A normalized version
 *	is one in which all symlinks in the path are replaced with
 *	their expanded form (except a symlink at the very end of the
 *	path).
 *
 * Results:
 *	The new 'nextCheckpoint' value, giving as far as we could
 *	understand in the path.
 *
 * Side effects:
 *	The pathPtr string, is modified.
 *
 *---------------------------------------------------------------------------
 */

int
TclpObjNormalizePath(interp, pathPtr, nextCheckpoint)
    Tcl_Interp *interp;
    Tcl_Obj *pathPtr;
    int nextCheckpoint;
{
    char *currentPathEndPosition;
    int pathLen;
    char cur;
    char *path = Tcl_GetStringFromObj(pathPtr, &pathLen);
#ifndef NO_REALPATH
    char normPath[MAXPATHLEN];
    Tcl_DString ds;
    CONST char *nativePath; 
#endif

    currentPathEndPosition = path + nextCheckpoint;

    while (1) {
	cur = *currentPathEndPosition;
	if ((cur == '/') && (path != currentPathEndPosition)) {
	    /* Reached directory separator */
	    Tcl_DString ds;
	    CONST char *nativePath;
	    int accessOk;

	    nativePath = Tcl_UtfToExternalDString(NULL, path, 
		    currentPathEndPosition - path, &ds);
	    accessOk = access(nativePath, F_OK);
	    Tcl_DStringFree(&ds);
	    if (accessOk != 0) {
		/* File doesn't exist */
		break;
	    }
	    /* Update the acceptable point */
	    nextCheckpoint = currentPathEndPosition - path;
	} else if (cur == 0) {
	    /* Reached end of string */
	    break;
	}
	currentPathEndPosition++;
    }
    /* 
     * We should really now convert this to a canonical path.  We do
     * that with 'realpath' if we have it available.  Otherwise we could
     * step through every single path component, checking whether it is a 
     * symlink, but that would be a lot of work, and most modern OSes 
     * have 'realpath'.
     */
#ifndef NO_REALPATH
    /* 
     * If we only had '/foo' or '/' then we never increment nextCheckpoint
     * and we don't need or want to go through 'Realpath'.  Also, on some
     * platforms, passing an empty string to 'Realpath' will give us the
     * normalized pwd, which is not what we want at all!
     */
    if (nextCheckpoint == 0) return 0;
    
    nativePath = Tcl_UtfToExternalDString(NULL, path, nextCheckpoint, &ds);
    if (Realpath(nativePath, normPath) != NULL) {
	/* 
	 * Free up the native path and put in its place the
	 * converted, normalized path.
	 */
	Tcl_DStringFree(&ds);
	Tcl_ExternalToUtfDString(NULL, normPath, (int) strlen(normPath), &ds);
a1612 22
	if (path[nextCheckpoint] != '\0') {
	    /* not at end, append remaining path */
	    int normLen = Tcl_DStringLength(&ds);
	    Tcl_DStringAppend(&ds, path + nextCheckpoint,
		    pathLen - nextCheckpoint);
	    /* 
	     * We recognise up to and including the directory
	     * separator.
	     */	
	    nextCheckpoint = normLen + 1;
	} else {
	    /* We recognise the whole string */ 
	    nextCheckpoint = Tcl_DStringLength(&ds);
	}
	/* 
	 * Overwrite with the normalized path.
	 */
	Tcl_SetStringObj(pathPtr, Tcl_DStringValue(&ds),
		Tcl_DStringLength(&ds));
    }
    Tcl_DStringFree(&ds);
#endif	/* !NO_REALPATH */
a1613 2
    return nextCheckpoint;
}
@


1.1
log
@Initial revision
@
text
@d8 1
a8 1
 * Copyright (c) 1996-1997 Sun Microsystems, Inc.
d13 1
a13 1
 * RCS: @@(#) $Id: tclUnixFCmd.c,v 1.14 1999/10/19 21:38:01 dj Exp $
d54 5
d74 1
a74 1
			    int objIndex, char *fileName,
d77 1
a77 1
			    int objIndex, char *fileName,
d80 2
a81 2
			    Tcl_Interp *interp, int objIndex, char *fileName,
			    Tcl_Obj **attributePtrPtr));
d83 1
a83 1
			    int objIndex, char *fileName,
d86 1
a86 1
			    int objIndex, char *fileName,
d89 6
a94 3
			    Tcl_Interp *interp, int objIndex, char *fileName,
			    Tcl_Obj *attributePtr));
			  
d99 3
a101 2
typedef int (TraversalProc) _ANSI_ARGS_((char *src, char *dst, 
        struct stat *sb, int type, Tcl_DString *errorPtr));
d113 7
a119 2
char *tclpFileAttrStrings[] = {"-group", "-owner", "-permissions",
	(char *) NULL};
d121 4
a124 3
	{GetGroupAttribute, SetGroupAttribute},
	{GetOwnerAttribute, SetOwnerAttribute},
	{GetPermissionsAttribute, SetPermissionsAttribute}};
d130 18
a147 10
static int		CopyFile _ANSI_ARGS_((char *src, char *dst, 
			    struct stat *srcStatBufPtr));
static int		CopyFileAtts _ANSI_ARGS_((char *src, char *dst, 
			    struct stat *srcStatBufPtr));
static int		TraversalCopy _ANSI_ARGS_((char *src, char *dst, 
			    struct stat *sbPtr, int type,
			    Tcl_DString *errorPtr));
static int		TraversalDelete _ANSI_ARGS_((char *src, char *dst, 
			    struct stat *sbPtr, int type,
			    Tcl_DString *errorPtr));
d150 1
a150 1
			    Tcl_DString *sourcePath, Tcl_DString *destPath,
d156 1
a156 1
 * TclpRenameFile --
d190 23
a212 2
    char *src;			/* Pathname of file or dir to be renamed. */
    char *dst;			/* New pathname of file or directory. */
d214 1
a214 1
    if (rename(src, dst) == 0) {
d221 11
a231 1
#ifdef sparc
d236 1
a236 1
     * conditionally compiled because realpath() is only defined on SunOS.
d244 2
a245 2
	if ((realpath(src, srcPath) != NULL)
		&& (realpath(dst, dstPath) != NULL)
d247 1
a247 1
	    dirPtr = opendir(dst);
d249 5
a253 1
		while ((dirEntPtr = readdir(dirPtr)) != NULL) {
d266 1
a266 1
#endif	/* sparc */
d291 1
a291 1
 * TclpCopyFile --
d317 18
a334 2
    char *src;			/* Pathname of file to be copied. */
    char *dst;			/* Pathname of file to copy to. */
d337 4
a340 2
    char link[MAXPATHLEN];
    int length;
d346 1
a346 1
    if (lstat(src, &srcStatBuf) != 0) {
d359 1
a359 1
    if (lstat(dst, &dstStatBuf) == 0) {
d365 1
a365 1
    if (unlink(dst) != 0) {
d372 5
a376 2
        case S_IFLNK:
	    length = readlink(src, link, sizeof(link)); 
d381 1
a381 1
	    if (symlink(link, dst) < 0) {
d385 1
a385 1

d387 3
a389 2
        case S_IFCHR:
	    if (mknod(dst, srcStatBuf.st_mode, srcStatBuf.st_rdev) < 0) {
d393 3
a395 4

#ifndef __CYGWIN__
        case S_IFIFO:
	    if (mkfifo(dst, srcStatBuf.st_mode) < 0) {
d399 2
a400 3
#endif

        default:
d402 1
a403 1
    
d425 6
a430 4
CopyFile(src, dst, srcStatBufPtr) 
    char *src;                   /* Pathname of file to copy. */
    char *dst;                   /* Pathname of file to create/overwrite. */
    struct stat *srcStatBufPtr;  /* Used to determine mode and blocksize */
d438 1
a438 1
    if ((srcFd = open(src, O_RDONLY, 0)) < 0) { 
d442 2
a443 1
    dstFd = open(dst, O_CREAT | O_TRUNC | O_WRONLY, srcStatBufPtr->st_mode);
d449 2
a450 2
#if HAVE_ST_BLKSIZE
    blockSize = srcStatBufPtr->st_blksize;
d452 10
d464 1
d481 1
a481 1
	unlink(dst);
d484 1
a484 1
    if (CopyFileAtts(src, dst, srcStatBufPtr) == TCL_ERROR) {
d491 1
a491 1
	unlink(dst);
d500 1
a500 1
 * TclpDeleteFile --
d521 1
a521 1
    char *path;			/* Pathname of file to be removed. */
d523 17
a539 1
    if (unlink(path) != 0) {
d548 1
a548 1
 * TclpCreateDirectory --
d573 14
a586 1
    char *path;			/* Pathname of directory to create. */
d589 3
a598 2
    
    mode = (0777 & ~mode);
d600 3
a602 1
    if (mkdir(path, mode | S_IRUSR | S_IWUSR | S_IXUSR) != 0) {
d636 6
a641 4
    char *src;			/* Pathname of directory to be copied.  */
    char *dst;			/* Pathname of target directory. */
    Tcl_DString *errorPtr;	/* If non-NULL, initialized DString for
				 * error reporting. */
d643 1
a644 2
    Tcl_DString srcBuffer;
    Tcl_DString dstBuffer;
d646 7
a652 8
    Tcl_DStringInit(&srcBuffer);
    Tcl_DStringInit(&dstBuffer);
    Tcl_DStringAppend(&srcBuffer, src, -1);
    Tcl_DStringAppend(&dstBuffer, dst, -1);
    result = TraverseUnixTree(TraversalCopy, &srcBuffer, &dstBuffer,
	    errorPtr);
    Tcl_DStringFree(&srcBuffer);
    Tcl_DStringFree(&dstBuffer);
d659 1
a659 1
 * TclpRemoveDirectory --
d684 2
a685 1
    char *path;			/* Pathname of directory to be removed. */
d689 3
a691 2
    Tcl_DString *errorPtr;	/* If non-NULL, initialized DString for
				 * error reporting. */
d694 1
a694 1
    Tcl_DString buffer;
d696 22
a717 1
    if (rmdir(path) == 0) {
d725 1
a725 1
	    Tcl_DStringAppend(errorPtr, path, -1);
d735 1
a735 5
    Tcl_DStringInit(&buffer);
    Tcl_DStringAppend(&buffer, path, -1);
    result = TraverseUnixTree(TraversalDelete, &buffer, NULL, errorPtr);
    Tcl_DStringFree(&buffer);
    return result;
d765 1
a765 1
				 * traversed. */
d767 4
a770 3
				 * parallel with source directory. */
    Tcl_DString *errorPtr;	/* If non-NULL, an initialized DString for
				 * error reporting. */
d772 2
a773 2
    struct stat statbuf;
    char *source, *target, *errfile;
d775 3
a777 4
    int targetLen = 0;		/* Initialization needed only to prevent
				 * warning in gcc. */
    struct dirent *dirp;
    DIR *dp;
d779 1
d781 2
d784 1
a784 8
    if (targetPtr != NULL) {
	target = Tcl_DStringValue(targetPtr);
    } else {
	target = NULL;
    }

    errfile = NULL;
    if (lstat(source, &statbuf) != 0) {
d788 1
a788 1
    if (!S_ISDIR(statbuf.st_mode)) {
d793 2
a794 1
	return (*traverseProc)(source, target, &statbuf, DOTREE_F, errorPtr);
d796 2
a797 3

    dp = opendir(source);
    if (dp == NULL) {
d805 2
a806 1
    result = (*traverseProc)(source, target, &statbuf, DOTREE_PRED, errorPtr);
d808 1
a808 1
	closedir(dp);
a812 1
    source = Tcl_DStringValue(sourcePtr);
a816 1
	target = Tcl_DStringValue(targetPtr);
d820 3
a822 3
    while ((dirp = readdir(dp)) != NULL) {
	if ((strcmp(dirp->d_name, ".") == 0)
	        || (strcmp(dirp->d_name, "..") == 0)) {
d830 1
a830 1
	Tcl_DStringAppend(sourcePtr, dirp->d_name, -1);
d832 1
a832 1
	    Tcl_DStringAppend(targetPtr, dirp->d_name, -1);
d849 1
a849 1
    closedir(dp);
a855 1
    source = Tcl_DStringValue(sourcePtr);
a857 1
	target = Tcl_DStringValue(targetPtr);
d866 1
a866 1
	result = (*traverseProc)(source, target, &statbuf, DOTREE_POSTD,
d872 1
a872 1
	    Tcl_DStringAppend(errorPtr, errfile, -1);
d899 5
a903 4
TraversalCopy(src, dst, sbPtr, type, errorPtr) 
    char *src;			/* Source pathname to copy. */
    char *dst;                  /* Destination pathname of copy. */
    struct stat *sbPtr;		/* Stat info for file specified by src. */
d905 3
a907 2
    Tcl_DString *errorPtr;	/* If non-NULL, initialized DString for
				 * error return. */
d911 1
a911 1
	    if (TclpCopyFile(src, dst) == TCL_OK) {
d917 1
a917 1
	    if (TclpCreateDirectory(dst) == TCL_OK) {
d923 2
a924 1
	    if (CopyFileAtts(src, dst, sbPtr) == TCL_OK) {
d932 2
a933 2
     * There shouldn't be a problem with src, because we already
     * checked it to get here.
d937 2
a938 1
	Tcl_DStringAppend(errorPtr, dst, -1);
d963 5
a967 4
TraversalDelete(src, ignore, sbPtr, type, errorPtr) 
    char *src;			/* Source pathname. */
    char *ignore;		/* Destination pathname (not used). */
    struct stat *sbPtr;		/* Stat info for file specified by src. */
d969 3
a971 2
    Tcl_DString *errorPtr;	/* If non-NULL, initialized DString for
				 * error return. */
d974 2
a975 2
        case DOTREE_F:
	    if (unlink(src) == 0) {
d979 2
a980 2

        case DOTREE_PRED:
d982 3
a984 3

        case DOTREE_POSTD:
	    if (rmdir(src) == 0) {
d988 1
a988 1
	    
a989 1

d991 2
a992 1
	Tcl_DStringAppend(errorPtr, src, -1);
d998 1
a998 1
 *----------------------------------------------------------------------
d1000 1
a1000 1
 * CopyFileAtts
d1002 2
a1003 2
 *      Copy the file attributes such as owner, group, permissions, and
 *      modification date from one file to another.
d1006 1
a1006 1
 *      Standard Tcl result.
d1009 5
a1013 5
 *      user id, group id, permission bits, last modification time, and 
 *      last access time are updated in the new file to reflect the old
 *      file.
 *      
 *----------------------------------------------------------------------
d1018 4
a1021 3
    char *src;                 /* Path name of source file */
    char *dst;                 /* Path name of target file */
    struct stat *statBufPtr;   /* ptr to stat info for source file */
d1038 1
a1038 1
    if (chmod(dst, newMode)) {
d1040 1
a1040 1
	if (chmod(dst, newMode)) {
d1048 1
a1048 1
    if (utime(dst, &tval)) {
d1053 1
d1076 1
a1076 1
    char *fileName;		/* The name of the file. */
d1081 1
d1083 4
a1086 3
    if (TclStat(fileName, &statBuf) != 0) {
	Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
		"could not stat file \"", fileName, "\": ",
d1091 1
a1091 1
    groupPtr = getgrgid(statBuf.st_gid);
d1095 6
a1100 1
	*attributePtrPtr = Tcl_NewStringObj(groupPtr->gr_name, -1);
d1127 1
a1127 1
    char *fileName;		/* The name of the file. */
d1132 1
d1134 4
a1137 3
    if (TclStat(fileName, &statBuf) != 0) {
	Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
		"could not stat file \"", fileName, "\": ",
d1142 1
a1142 1
    pwPtr = getpwuid(statBuf.st_uid);
d1146 6
a1151 1
	*attributePtrPtr = Tcl_NewStringObj(pwPtr->pw_name, -1);
d1178 1
a1178 1
    char *fileName;		    /* The name of the file. */
d1182 2
a1183 1
    char returnString[6];
d1185 4
a1188 3
    if (TclStat(fileName, &statBuf) != 0) {
	Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
		"could not stat file \"", fileName, "\": ",
d1201 1
a1201 1
 *----------------------------------------------------------------------
d1203 1
a1203 1
 * SetGroupAttribute
d1205 1
a1205 1
 *      Sets the file to the given group.
d1211 1
a1211 1
 *      The group of the file is changed.
d1213 1
a1213 1
 *----------------------------------------------------------------------
d1218 1
a1218 1
    Tcl_Interp *interp;		    /* The interp we are using for errors. */
d1220 2
a1221 2
    char *fileName;		    /* The name of the file. */
    Tcl_Obj *attributePtr;	    /* The attribute to set. */
d1223 4
a1226 2
    gid_t groupNumber;
    long placeHolder;
d1228 1
a1228 1
    if (Tcl_GetLongFromObj(interp, attributePtr, &placeHolder) != TCL_OK) {
d1230 8
a1237 1
	char *groupString = Tcl_GetStringFromObj(attributePtr, NULL);
a1238 2
	Tcl_ResetResult(interp);
	groupPtr = getgrnam(groupString);
d1241 2
a1242 3
	    Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
		    "could not set group for file \"", fileName,
		    "\": group \"", groupString, "\" does not exist",
d1246 1
a1246 3
	groupNumber = groupPtr->gr_gid;
    } else {
	groupNumber = (gid_t) placeHolder;
d1249 8
a1256 5
    if (chown(fileName, -1, groupNumber) != 0) {
	endgrent();
	Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
		"could not set group for file \"", fileName, "\": ",
		Tcl_PosixError(interp), (char *) NULL);
a1258 1
    endgrent();
d1263 1
a1263 1
 *----------------------------------------------------------------------
d1265 1
a1265 1
 * SetOwnerAttribute
d1267 1
a1267 1
 *      Sets the file to the given owner.
d1273 1
a1273 1
 *      The group of the file is changed.
d1275 1
a1275 1
 *----------------------------------------------------------------------
d1280 1
a1280 1
    Tcl_Interp *interp;		    /* The interp we are using for errors. */
d1282 2
a1283 2
    char *fileName;		    /* The name of the file. */
    Tcl_Obj *attributePtr;	    /* The attribute to set. */
d1285 4
a1288 2
    uid_t userNumber;
    long placeHolder;
d1290 1
a1290 1
    if (Tcl_GetLongFromObj(interp, attributePtr, &placeHolder) != TCL_OK) {
d1292 8
a1299 1
	char *ownerString = Tcl_GetStringFromObj(attributePtr, NULL);
a1300 2
	Tcl_ResetResult(interp);
	pwPtr = getpwnam(ownerString);
d1302 2
a1303 3
	    Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
		    "could not set owner for file \"", fileName,
		    "\": user \"", ownerString, "\" does not exist",
d1307 1
a1307 3
	userNumber = pwPtr->pw_uid;
    } else {
	userNumber = (uid_t) placeHolder;
d1310 7
a1316 4
    if (chown(fileName, userNumber, -1) != 0) {
	Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
		"could not set owner for file \"", fileName, "\": ",
		Tcl_PosixError(interp), (char *) NULL);
d1318 1
a1318 2
    }    
	
d1323 1
a1323 1
 *----------------------------------------------------------------------
d1327 1
a1327 1
 *      Sets the file to the given group.
d1333 1
a1333 1
 *      The group of the file is changed.
d1335 1
a1335 1
 *----------------------------------------------------------------------
d1342 1
a1342 1
    char *fileName;		    /* The name of the file. */
d1345 1
a1345 1
    long modeInt;
d1347 3
d1352 1
a1352 3
     * mode_t is a long under SPARC; an int under SunOS. Since we do not
     * know how big it really is, we get the long and then cast it
     * down to a mode_t.
d1354 26
a1379 4
    
    if (Tcl_GetLongFromObj(interp, attributePtr, &modeInt)
	    != TCL_OK) {
	return TCL_ERROR;
d1382 4
a1385 3
    newMode = (mode_t) modeInt;

    if (chmod(fileName, newMode) != 0) {
d1393 1
d1423 190
@


1.1.1.1
log
@import dejagnu-1999-11-08 snapshot
@
text
@@


1.1.1.2
log
@Tcl 8.3 upgrade
@
text
@d8 1
a8 1
 * Copyright (c) 1996-1998 Sun Microsystems, Inc.
d13 1
a13 1
 * RCS: @@(#) $Id: tclUnixFCmd.c,v 1.6.8.2 2000/09/15 16:58:23 spolk Exp $
a53 5
#ifndef HAVE_ST_BLKSIZE
#ifndef NO_FSTATFS
#include <sys/statfs.h>
#endif
#endif
d69 1
a69 1
			    int objIndex, CONST char *fileName,
d72 1
a72 1
			    int objIndex, CONST char *fileName,
d75 2
a76 2
			    Tcl_Interp *interp, int objIndex,
			    CONST char *fileName, Tcl_Obj **attributePtrPtr));
d78 1
a78 1
			    int objIndex, CONST char *fileName,
d81 1
a81 1
			    int objIndex, CONST char *fileName,
d84 3
a86 6
			    Tcl_Interp *interp, int objIndex,
			    CONST char *fileName, Tcl_Obj *attributePtr));
static int		GetModeFromPermString _ANSI_ARGS_((
			    Tcl_Interp *interp, char *modeStringPtr,
			    mode_t *modePtr));

d91 2
a92 3
typedef int (TraversalProc) _ANSI_ARGS_((Tcl_DString *srcPtr,
	Tcl_DString *dstPtr, CONST struct stat *statBufPtr, int type,
	Tcl_DString *errorPtr));
d104 2
a105 7
char *tclpFileAttrStrings[] = {
    "-group",
    "-owner",
    "-permissions",
    (char *) NULL
};

d107 3
a109 4
    {GetGroupAttribute,		SetGroupAttribute},
    {GetOwnerAttribute,		SetOwnerAttribute},
    {GetPermissionsAttribute,	SetPermissionsAttribute}
};
d115 10
a124 18
static int		CopyFile _ANSI_ARGS_((CONST char *src,
			    CONST char *dst, CONST struct stat *statBufPtr));
static int		CopyFileAtts _ANSI_ARGS_((CONST char *src,
			    CONST char *dst, CONST struct stat *statBufPtr));
static int		DoCopyFile _ANSI_ARGS_((Tcl_DString *srcPtr,
			    Tcl_DString *dstPtr));
static int		DoCreateDirectory _ANSI_ARGS_((Tcl_DString *pathPtr));
static int		DoDeleteFile _ANSI_ARGS_((Tcl_DString *pathPtr));
static int		DoRemoveDirectory _ANSI_ARGS_((Tcl_DString *pathPtr,
			    int recursive, Tcl_DString *errorPtr));
static int		DoRenameFile _ANSI_ARGS_((CONST char *src,
			    CONST char *dst));
static int		TraversalCopy _ANSI_ARGS_((Tcl_DString *srcPtr,
			    Tcl_DString *dstPtr, CONST struct stat *statBufPtr,
			    int type, Tcl_DString *errorPtr));
static int		TraversalDelete _ANSI_ARGS_((Tcl_DString *srcPtr,
			    Tcl_DString *dstPtr, CONST struct stat *statBufPtr,
			    int type, Tcl_DString *errorPtr));
d127 1
a127 1
			    Tcl_DString *sourcePtr, Tcl_DString *destPtr,
d133 1
a133 1
 * TclpRenameFile, DoRenameFile --
d167 2
a168 23
    CONST char *src;		/* Pathname of file or dir to be renamed
				 * (UTF-8). */
    CONST char *dst;		/* New pathname of file or directory
				 * (UTF-8). */
{
    int result;
    Tcl_DString srcString, dstString;

    Tcl_UtfToExternalDString(NULL, src, -1, &srcString);
    Tcl_UtfToExternalDString(NULL, dst, -1, &dstString);
    result = DoRenameFile(Tcl_DStringValue(&srcString),
	    Tcl_DStringValue(&dstString));
    Tcl_DStringFree(&srcString);
    Tcl_DStringFree(&dstString);
    return result;
}

static int
DoRenameFile(src, dst)
    CONST char *src;		/* Pathname of file or dir to be renamed
				 * (native). */
    CONST char *dst;		/* New pathname of file or directory
				 * (native). */
d170 1
a170 1
    if (rename(src, dst) == 0) {			/* INTL: Native. */
d177 1
a177 11
    /*
     * IRIX returns EIO when you attept to move a directory into
     * itself.  We just map EIO to EINVAL get the right message on SGI.
     * Most platforms don't return EIO except in really strange cases.
     */
    
    if (errno == EIO) {
	errno = EINVAL;
    }
    
#ifndef NO_REALPATH
d182 1
a182 1
     * conditionally compiled because realpath() not defined on all systems.
d190 2
a191 2
	if ((realpath((char *) src, srcPath) != NULL)	/* INTL: Native. */
		&& (realpath((char *) dst, dstPath) != NULL) /* INTL: Native. */
d193 1
a193 1
	    dirPtr = opendir(dst);			/* INTL: Native. */
d195 1
a195 5
		while (1) {
		    dirEntPtr = readdir(dirPtr);	/* INTL: Native. */
		    if (dirEntPtr == NULL) {
			break;
		    }
d208 1
a208 1
#endif	/* !NO_REALPATH */
d233 1
a233 1
 * TclpCopyFile, DoCopyFile --
d259 2
a260 18
    CONST char *src;		/* Pathname of file to be copied (UTF-8). */
    CONST char *dst;		/* Pathname of file to copy to (UTF-8). */
{
    int result;
    Tcl_DString srcString, dstString;

    Tcl_UtfToExternalDString(NULL, src, -1, &srcString);
    Tcl_UtfToExternalDString(NULL, dst, -1, &dstString);
    result = DoCopyFile(&srcString, &dstString);
    Tcl_DStringFree(&srcString);
    Tcl_DStringFree(&dstString);
    return result;
}

static int
DoCopyFile(srcPtr, dstPtr)
    Tcl_DString *srcPtr;	/* Pathname of file to be copied (native). */
    Tcl_DString *dstPtr;	/* Pathname of file to copy to (native). */
d263 2
a264 4
    CONST char *src, *dst;

    src = Tcl_DStringValue(srcPtr);
    dst = Tcl_DStringValue(dstPtr);
d270 1
a270 1
    if (lstat(src, &srcStatBuf) != 0) {			/* INTL: Native. */
d283 1
a283 1
    if (lstat(dst, &dstStatBuf) == 0) {			/* INTL: Native. */
d289 1
a289 1
    if (unlink(dst) != 0) {				/* INTL: Native. */
d296 2
a297 5
        case S_IFLNK: {
	    char link[MAXPATHLEN];
	    int length;

	    length = readlink(src, link, sizeof(link)); /* INTL: Native. */
d302 1
a302 1
	    if (symlink(link, dst) < 0) {		/* INTL: Native. */
d306 1
a306 1
	}
d308 2
a309 3
        case S_IFCHR: {
	    if (mknod(dst, srcStatBuf.st_mode,		/* INTL: Native. */
		    srcStatBuf.st_rdev) < 0) {
d313 4
a316 3
	}
        case S_IFIFO: {
	    if (mkfifo(dst, srcStatBuf.st_mode) < 0) {	/* INTL: Native. */
d320 3
a322 2
	}
        default: {
a323 1
	}
d325 1
d347 4
a350 6
CopyFile(src, dst, statBufPtr) 
    CONST char *src;		/* Pathname of file to copy (native). */
    CONST char *dst;		/* Pathname of file to create/overwrite
				 * (native). */
    CONST struct stat *statBufPtr;
				/* Used to determine mode and blocksize. */
d358 1
a358 1
    if ((srcFd = open(src, O_RDONLY, 0)) < 0) {		/* INTL: Native. */
d362 1
a362 2
    dstFd = open(dst, O_CREAT | O_TRUNC | O_WRONLY,	/* INTL: Native. */
	    statBufPtr->st_mode);
d368 2
a369 2
#ifdef HAVE_ST_BLKSIZE
    blockSize = statBufPtr->st_blksize;
a370 10
#ifndef NO_FSTATFS
    {
	struct statfs fs;
	if (fstatfs(srcFd, &fs, sizeof(fs), 0) == 0) {
	    blockSize = fs.f_bsize;
	} else {
	    blockSize = 4096;
	}
    }
#else 
a372 1
#endif
d389 1
a389 1
	unlink(dst);					/* INTL: Native. */
d392 1
a392 1
    if (CopyFileAtts(src, dst, statBufPtr) == TCL_ERROR) {
d399 1
a399 1
	unlink(dst);					/* INTL: Native. */
d408 1
a408 1
 * TclpDeleteFile, DoDeleteFile --
d429 1
a429 1
    CONST char *path;		/* Pathname of file to be removed (UTF-8). */
d431 1
a431 17
    int result;
    Tcl_DString pathString;

    Tcl_UtfToExternalDString(NULL, path, -1, &pathString);
    result = DoDeleteFile(&pathString);
    Tcl_DStringFree(&pathString);
    return result;
}

static int
DoDeleteFile(pathPtr)
    Tcl_DString *pathPtr;	/* Pathname of file to be removed (native). */
{
    CONST char *path;

    path = Tcl_DStringValue(pathPtr);
    if (unlink(path) != 0) {				/* INTL: Native. */
d440 1
a440 1
 * TclpCreateDirectory, DoCreateDirectory --
d465 1
a465 14
    CONST char *path;		/* Pathname of directory to create (UTF-8). */
{
    int result;
    Tcl_DString pathString;

    Tcl_UtfToExternalDString(NULL, path, -1, &pathString);
    result = DoCreateDirectory(&pathString);
    Tcl_DStringFree(&pathString);
    return result;
}

static int
DoCreateDirectory(pathPtr)
    Tcl_DString *pathPtr;	/* Pathname of directory to create (native). */
a467 3
    CONST char *path;

    path = Tcl_DStringValue(pathPtr);
d475 2
d478 1
a478 3
    mode = (0777 & ~mode) | S_IRUSR | S_IWUSR | S_IXUSR;

    if (mkdir(path, mode) != 0) {			/* INTL: Native. */
d512 4
a515 6
    CONST char *src;		/* Pathname of directory to be copied
				 * (UTF-8). */
    CONST char *dst;		/* Pathname of target directory (UTF-8). */
    Tcl_DString *errorPtr;	/* If non-NULL, uninitialized or free
				 * DString filled with UTF-8 name of file
				 * causing error. */
a516 1
    Tcl_DString srcString, dstString;
d518 2
d521 8
a528 7
    Tcl_UtfToExternalDString(NULL, src, -1, &srcString);
    Tcl_UtfToExternalDString(NULL, dst, -1, &dstString);

    result = TraverseUnixTree(TraversalCopy, &srcString, &dstString, errorPtr);

    Tcl_DStringFree(&srcString);
    Tcl_DStringFree(&dstString);
d535 1
a535 1
 * TclpRemoveDirectory, DoRemoveDirectory --
d560 1
a560 2
    CONST char *path;		/* Pathname of directory to be removed
				 * (UTF-8). */
d564 2
a565 3
    Tcl_DString *errorPtr;	/* If non-NULL, uninitialized or free
				 * DString filled with UTF-8 name of file
				 * causing error. */
d568 1
a568 1
    Tcl_DString pathString;
d570 1
a570 22
    Tcl_UtfToExternalDString(NULL, path, -1, &pathString);
    result = DoRemoveDirectory(&pathString, recursive, errorPtr);
    Tcl_DStringFree(&pathString);

    return result;
}

static int
DoRemoveDirectory(pathPtr, recursive, errorPtr)
    Tcl_DString *pathPtr;	/* Pathname of directory to be removed
				 * (native). */
    int recursive;		/* If non-zero, removes directories that
				 * are nonempty.  Otherwise, will only remove
				 * empty directories. */
    Tcl_DString *errorPtr;	/* If non-NULL, uninitialized or free
				 * DString filled with UTF-8 name of file
				 * causing error. */
{
    CONST char *path;

    path = Tcl_DStringValue(pathPtr);
    if (rmdir(path) == 0) {				/* INTL: Native. */
d578 1
a578 1
	    Tcl_ExternalToUtfDString(NULL, path, -1, errorPtr);
d588 5
a592 1
    return TraverseUnixTree(TraversalDelete, pathPtr, NULL, errorPtr);
d622 1
a622 1
				 * traversed (native). */
d624 3
a626 4
				 * parallel with source directory (native). */
    Tcl_DString *errorPtr;	/* If non-NULL, uninitialized or free
				 * DString filled with UTF-8 name of file
				 * causing error. */
d628 2
a629 2
    struct stat statBuf;
    CONST char *source, *errfile;
d631 4
a634 3
    int targetLen;
    struct dirent *dirEntPtr;
    DIR *dirPtr;
a635 1
    errfile = NULL;
d637 6
a642 1
    targetLen = 0;		/* lint. */
d644 2
a645 2
    source = Tcl_DStringValue(sourcePtr);
    if (lstat(source, &statBuf) != 0) {			/* INTL: Native. */
d649 1
a649 1
    if (!S_ISDIR(statBuf.st_mode)) {
d654 1
a654 2
	return (*traverseProc)(sourcePtr, targetPtr, &statBuf, DOTREE_F,
		errorPtr);
d656 3
a658 2
    dirPtr = opendir(source);				/* INTL: Native. */
    if (dirPtr == NULL) {
d666 1
a666 2
    result = (*traverseProc)(sourcePtr, targetPtr, &statBuf, DOTREE_PRED,
	    errorPtr);
d668 1
a668 1
	closedir(dirPtr);
d673 1
d678 1
d682 3
a684 3
    while ((dirEntPtr = readdir(dirPtr)) != NULL) {	/* INTL: Native. */
	if ((strcmp(dirEntPtr->d_name, ".") == 0)
	        || (strcmp(dirEntPtr->d_name, "..") == 0)) {
d692 1
a692 1
	Tcl_DStringAppend(sourcePtr, dirEntPtr->d_name, -1);
d694 1
a694 1
	    Tcl_DStringAppend(targetPtr, dirEntPtr->d_name, -1);
d711 1
a711 1
    closedir(dirPtr);
d718 1
d721 1
d730 1
a730 1
	result = (*traverseProc)(sourcePtr, targetPtr, &statBuf, DOTREE_POSTD,
d736 1
a736 1
	    Tcl_ExternalToUtfDString(NULL, errfile, -1, errorPtr);
d763 4
a766 5
TraversalCopy(srcPtr, dstPtr, statBufPtr, type, errorPtr) 
    Tcl_DString *srcPtr;	/* Source pathname to copy (native). */
    Tcl_DString *dstPtr;	/* Destination pathname of copy (native). */
    CONST struct stat *statBufPtr;
				/* Stat info for file specified by srcPtr. */
d768 2
a769 3
    Tcl_DString *errorPtr;	/* If non-NULL, uninitialized or free
				 * DString filled with UTF-8 name of file
				 * causing error. */
d773 1
a773 1
	    if (DoCopyFile(srcPtr, dstPtr) == TCL_OK) {
d779 1
a779 1
	    if (DoCreateDirectory(dstPtr) == TCL_OK) {
d785 1
a785 2
	    if (CopyFileAtts(Tcl_DStringValue(srcPtr),
		    Tcl_DStringValue(dstPtr), statBufPtr) == TCL_OK) {
d793 2
a794 2
     * There shouldn't be a problem with src, because we already checked it
     * to get here.
d798 1
a798 2
	Tcl_ExternalToUtfDString(NULL, Tcl_DStringValue(dstPtr),
		Tcl_DStringLength(dstPtr), errorPtr);
d823 4
a826 5
TraversalDelete(srcPtr, ignore, statBufPtr, type, errorPtr) 
    Tcl_DString *srcPtr;	/* Source pathname (native). */
    Tcl_DString *ignore;	/* Destination pathname (not used). */
    CONST struct stat *statBufPtr;
				/* Stat info for file specified by srcPtr. */
d828 2
a829 3
    Tcl_DString *errorPtr;	/* If non-NULL, uninitialized or free
				 * DString filled with UTF-8 name of file
				 * causing error. */
d832 2
a833 2
        case DOTREE_F: {
	    if (DoDeleteFile(srcPtr) == 0) {
d837 2
a838 2
	}
        case DOTREE_PRED: {
d840 3
a842 3
	}
        case DOTREE_POSTD: {
	    if (DoRemoveDirectory(srcPtr, 0, NULL) == 0) {
d846 1
a846 1
	}	    
d848 1
d850 1
a850 2
	Tcl_ExternalToUtfDString(NULL, Tcl_DStringValue(srcPtr),
		Tcl_DStringLength(srcPtr), errorPtr);
d856 1
a856 1
 *---------------------------------------------------------------------------
d858 1
a858 1
 * CopyFileAtts --
d860 2
a861 2
 *	Copy the file attributes such as owner, group, permissions,
 *	and modification date from one file to another.
d864 1
a864 1
 *	Standard Tcl result.
d867 5
a871 5
 *	user id, group id, permission bits, last modification time, and
 *	last access time are updated in the new file to reflect the
 *	old file.
 *
 *---------------------------------------------------------------------------
d876 3
a878 4
    CONST char *src;		/* Path name of source file (native). */
    CONST char *dst;		/* Path name of target file (native). */
    CONST struct stat *statBufPtr;
				/* Stat info for source file */
d895 1
a895 1
    if (chmod(dst, newMode)) {				/* INTL: Native. */
d897 1
a897 1
	if (chmod(dst, newMode)) {			/* INTL: Native. */
d905 1
a905 1
    if (utime(dst, &tval)) {				/* INTL: Native. */
a909 1

d932 1
a932 1
    CONST char *fileName;	/* The name of the file (UTF-8). */
a936 1
    int result;
d938 3
a940 4
    result = TclStat(fileName, &statBuf);
    
    if (result != 0) {
	Tcl_AppendResult(interp, "could not read \"", fileName, "\": ",
d945 1
a945 1
    groupPtr = getgrgid(statBuf.st_gid);		/* INTL: Native. */
d949 1
a949 6
	Tcl_DString ds;
	CONST char *utf;

	utf = Tcl_ExternalToUtfDString(NULL, groupPtr->gr_name, -1, &ds); 
	*attributePtrPtr = Tcl_NewStringObj(utf, -1);
	Tcl_DStringFree(&ds);
d976 1
a976 1
    CONST char *fileName;	/* The name of the file (UTF-8). */
a980 1
    int result;
d982 3
a984 4
    result = TclStat(fileName, &statBuf);
    
    if (result != 0) {
	Tcl_AppendResult(interp, "could not read \"", fileName, "\": ",
d989 1
a989 1
    pwPtr = getpwuid(statBuf.st_uid);			/* INTL: Native. */
d993 1
a993 6
	Tcl_DString ds;
	CONST char *utf;

	utf = Tcl_ExternalToUtfDString(NULL, pwPtr->pw_name, -1, &ds); 
	*attributePtrPtr = Tcl_NewStringObj(utf, Tcl_DStringLength(&ds));
	Tcl_DStringFree(&ds);
d1020 1
a1020 1
    CONST char *fileName;	    /* The name of the file (UTF-8). */
d1024 1
a1024 2
    char returnString[7];
    int result;
d1026 3
a1028 4
    result = TclStat(fileName, &statBuf);
    
    if (result != 0) {
	Tcl_AppendResult(interp, "could not read \"", fileName, "\": ",
d1041 1
a1041 1
 *---------------------------------------------------------------------------
d1043 1
a1043 1
 * SetGroupAttribute --
d1045 1
a1045 1
 *      Sets the group of the file to the specified group.
d1051 1
a1051 1
 *      As above.
d1053 1
a1053 1
 *---------------------------------------------------------------------------
d1058 1
a1058 1
    Tcl_Interp *interp;		    /* The interp for error reporting. */
d1060 2
a1061 2
    CONST char *fileName;	    /* The name of the file (UTF-8). */
    Tcl_Obj *attributePtr;	    /* New group for file. */
d1063 2
a1064 4
    long gid;
    int result;
    Tcl_DString ds;
    CONST char *native;
d1066 1
a1066 1
    if (Tcl_GetLongFromObj(NULL, attributePtr, &gid) != TCL_OK) {
d1068 1
a1068 8
	CONST char *string;
	int length;

	string = Tcl_GetStringFromObj(attributePtr, &length);

	native = Tcl_UtfToExternalDString(NULL, string, length, &ds);
	groupPtr = getgrnam(native);			/* INTL: Native. */
	Tcl_DStringFree(&ds);
d1070 2
d1074 3
a1076 2
	    Tcl_AppendResult(interp, "could not set group for file \"",
		    fileName, "\": group \"", string, "\" does not exist",
d1080 3
a1082 1
	gid = groupPtr->gr_gid;
d1085 5
a1089 8
    native = Tcl_UtfToExternalDString(NULL, fileName, -1, &ds);
    result = chown(native, (uid_t) -1, (gid_t) gid);	/* INTL: Native. */
    Tcl_DStringFree(&ds);

    endgrent();
    if (result != 0) {
	Tcl_AppendResult(interp, "could not set group for file \"",
		fileName, "\": ", Tcl_PosixError(interp), (char *) NULL);
d1092 1
d1097 1
a1097 1
 *---------------------------------------------------------------------------
d1099 1
a1099 1
 * SetOwnerAttribute --
d1101 1
a1101 1
 *      Sets the owner of the file to the specified owner.
d1107 1
a1107 1
 *      As above.
d1109 1
a1109 1
 *---------------------------------------------------------------------------
d1114 1
a1114 1
    Tcl_Interp *interp;		    /* The interp for error reporting. */
d1116 2
a1117 2
    CONST char *fileName;	    /* The name of the file (UTF-8). */
    Tcl_Obj *attributePtr;	    /* New owner for file. */
d1119 2
a1120 4
    long uid;
    int result;
    Tcl_DString ds;
    CONST char *native;
d1122 1
a1122 1
    if (Tcl_GetLongFromObj(NULL, attributePtr, &uid) != TCL_OK) {
d1124 1
a1124 8
	CONST char *string;
	int length;

	string = Tcl_GetStringFromObj(attributePtr, &length);

	native = Tcl_UtfToExternalDString(NULL, string, length, &ds);
	pwPtr = getpwnam(native);			/* INTL: Native. */
	Tcl_DStringFree(&ds);
d1126 2
d1129 3
a1131 2
	    Tcl_AppendResult(interp, "could not set owner for file \"",
		    fileName, "\": user \"", string, "\" does not exist",
d1135 3
a1137 1
	uid = pwPtr->pw_uid;
d1140 4
a1143 7
    native = Tcl_UtfToExternalDString(NULL, fileName, -1, &ds);
    result = chown(native, (uid_t) uid, (gid_t) -1);   /* INTL: Native. */
    Tcl_DStringFree(&ds);

    if (result != 0) {
	Tcl_AppendResult(interp, "could not set owner for file \"", fileName,
		"\": ", Tcl_PosixError(interp), (char *) NULL);
d1145 2
a1146 1
    }
d1151 1
a1151 1
 *---------------------------------------------------------------------------
d1155 1
a1155 1
 *      Sets the file to the given permission.
d1161 1
a1161 1
 *      The permission of the file is changed.
d1163 1
a1163 1
 *---------------------------------------------------------------------------
d1170 1
a1170 1
    CONST char *fileName;	    /* The name of the file (UTF-8). */
d1173 1
a1173 1
    long mode;
a1174 3
    int result;
    CONST char *native;
    Tcl_DString ds;
d1177 3
a1179 1
     * First try if the string is a number
d1181 5
a1185 5
    if (Tcl_GetLongFromObj(NULL, attributePtr, &mode) == TCL_OK) {
        newMode = (mode_t) (mode & 0x00007FFF);
    } else {
	struct stat buf;
	char *modeStringPtr = Tcl_GetString(attributePtr);
d1187 1
a1187 13
	/*
	 * Try the forms "rwxrwxrwx" and "ugo=rwx"
	 *
	 * We get the current mode of the file, in order to allow for
	 * ug+-=rwx style chmod strings.
	 */
	result = TclStat(fileName, &buf);
	if (result != 0) {
	    Tcl_AppendResult(interp, "could not read \"", fileName, "\": ",
		    Tcl_PosixError(interp), (char *) NULL);
	    return TCL_ERROR;
	}
	newMode = (mode_t) (buf.st_mode & 0x00007FFF);
d1189 1
a1189 12
	if (GetModeFromPermString(NULL, modeStringPtr, &newMode) != TCL_OK) {
	    Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
		    "unknown permission string format \"",
		    modeStringPtr, "\"", (char *) NULL);
	    return TCL_ERROR;
	}
    }

    native = Tcl_UtfToExternalDString(NULL, fileName, -1, &ds);
    result = chmod(native, newMode);		/* INTL: Native. */
    Tcl_DStringFree(&ds);
    if (result != 0) {
a1196 1

a1225 190

/*
 *----------------------------------------------------------------------
 *
 * GetModeFromPermString --
 *
 *	This procedure is invoked to process the "file permissions"
 *	Tcl command, to check for a "rwxrwxrwx" or "ugoa+-=rwxst" string.
 *	See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

static int
GetModeFromPermString(interp, modeStringPtr, modePtr)
    Tcl_Interp *interp;		/* The interp we are using for errors. */
    char *modeStringPtr;	/* Permissions string */
    mode_t *modePtr;		/* pointer to the mode value */
{
    mode_t newMode;
    mode_t oldMode;		/* Storage for the value of the old mode
				 * (that is passed in), to allow for the
				 * chmod style manipulation */
    int i,n, who, op, what, op_found, who_found;

    /*
     * We start off checking for an "rwxrwxrwx" style permissions string
     */
    if (strlen(modeStringPtr) != 9) {
        goto chmodStyleCheck;
    }

    newMode = 0;
    for (i = 0; i < 9; i++) {
	switch (*(modeStringPtr+i)) {
	    case 'r':
		if ((i%3) != 0) {
		    goto chmodStyleCheck;
		}
		newMode |= (1<<(8-i));
		break;
	    case 'w':
		if ((i%3) != 1) {
		    goto chmodStyleCheck;
		}
		newMode |= (1<<(8-i));
		break;
	    case 'x':
		if ((i%3) != 2) {
		    goto chmodStyleCheck;
		}
		newMode |= (1<<(8-i));
		break;
	    case 's':
		if (((i%3) != 2) || (i > 5)) {
		    goto chmodStyleCheck;
		}
		newMode |= (1<<(8-i));
		newMode |= (1<<(11-(i/3)));
		break;
	    case 'S':
		if (((i%3) != 2) || (i > 5)) {
		    goto chmodStyleCheck;
		}
		newMode |= (1<<(11-(i/3)));
		break;
	    case 't':
		if (i != 8) {
		    goto chmodStyleCheck;
		}
		newMode |= (1<<(8-i));
		newMode |= (1<<9);
		break;
	    case 'T':
		if (i != 8) {
		    goto chmodStyleCheck;
		}
		newMode |= (1<<9);
		break;
	    case '-':
		break;
	    default:
		/*
		 * Oops, not what we thought it was, so go on
		 */
		goto chmodStyleCheck;
	}
    }
    *modePtr = newMode;
    return TCL_OK;

    chmodStyleCheck:
    /*
     * We now check for an "ugoa+-=rwxst" style permissions string
     */

    for (n = 0 ; *(modeStringPtr+n) != '\0' ; n = n + i) {
	oldMode = *modePtr;
	who = op = what = op_found = who_found = 0;
	for (i = 0 ; *(modeStringPtr+n+i) != '\0' ; i++ ) {
	    if (!who_found) {
		/* who */
		switch (*(modeStringPtr+n+i)) {
		    case 'u' :
			who |= 0x9c0;
			continue;
		    case 'g' :
			who |= 0x438;
			continue;
		    case 'o' :
			who |= 0x207;
			continue;
		    case 'a' :
			who |= 0xfff;
			continue;
		}
	    }
	    who_found = 1;
	    if (who == 0) {
		who = 0xfff;
	    }
	    if (!op_found) {
		/* op */
		switch (*(modeStringPtr+n+i)) {
		    case '+' :
			op = 1;
			op_found = 1;
			continue;
		    case '-' :
			op = 2;
			op_found = 1;
			continue;
		    case '=' :
			op = 3;
			op_found = 1;
			continue;
		    default  :
			return TCL_ERROR;
			break;
		}
	    }
	    /* what */
	    switch (*(modeStringPtr+n+i)) {
		case 'r' :
		    what |= 0x124;
		    continue;
		case 'w' :
		    what |= 0x92;
		    continue;
		case 'x' :
		    what |= 0x49;
		    continue;
		case 's' :
		    what |= 0xc00;
		    continue;
		case 't' :
		    what |= 0x200;
		    continue;
		case ',' :
		    break;
		default  :
		    return TCL_ERROR;
		    break;
	    }
	    if (*(modeStringPtr+n+i) == ',') {
		i++;
		break;
	    }
	}
	switch (op) {
	    case 1 :
		*modePtr = oldMode | (who & what);
		continue;
	    case 2 :
		*modePtr = oldMode & ~(who & what);
		continue;
	    case 3 :
		*modePtr = (oldMode & ~who) | (who & what);
		continue;
	}
    }
    return TCL_OK;
}

@


1.1.1.3
log
@import tcl 8.4.0
@
text
@d13 1
a13 1
 * RCS: @@(#) $Id: tclUnixFCmd.c,v 1.25 2002/06/28 09:56:54 dkf Exp $
d74 1
a74 1
			    int objIndex, Tcl_Obj *fileName,
d77 1
a77 1
			    int objIndex, Tcl_Obj *fileName,
d81 1
a81 1
			    Tcl_Obj *fileName, Tcl_Obj **attributePtrPtr));
d83 1
a83 1
			    int objIndex, Tcl_Obj *fileName,
d86 1
a86 1
			    int objIndex, Tcl_Obj *fileName,
d90 1
a90 1
			    Tcl_Obj *fileName, Tcl_Obj *attributePtr));
d100 1
a100 1
	Tcl_DString *dstPtr, CONST Tcl_StatBuf *statBufPtr, int type,
d113 1
a113 1
CONST char *tclpFileAttrStrings[] = {
d131 1
a131 1
			    CONST char *dst, CONST Tcl_StatBuf *statBufPtr));
d133 5
a137 5
			    CONST char *dst, CONST Tcl_StatBuf *statBufPtr));
static int		DoCopyFile _ANSI_ARGS_((CONST char *srcPtr,
			    CONST char *dstPtr));
static int		DoCreateDirectory _ANSI_ARGS_((CONST char *pathPtr));
static int		DoDeleteFile _ANSI_ARGS_((CONST char *path));
d143 1
a143 1
			    Tcl_DString *dstPtr, CONST Tcl_StatBuf *statBufPtr,
d146 1
a146 1
			    Tcl_DString *dstPtr, CONST Tcl_StatBuf *statBufPtr,
a151 23

#ifdef PURIFY
/*
 * realpath and purify don't mix happily.  It has been noted that realpath
 * should not be used with purify because of bogus warnings, but just
 * memset'ing the resolved path will squelch those.  This assumes we are
 * passing the standard MAXPATHLEN size resolved arg.
 */
static char *		Realpath _ANSI_ARGS_((CONST char *path,
			    char *resolved));

char *
Realpath(path, resolved)
    CONST char *path;
    char *resolved;
{
    memset(resolved, 0, MAXPATHLEN);
    return realpath(path, resolved);
}
#else
#define Realpath realpath
#endif

d156 1
a156 1
 * TclpObjRenameFile, DoRenameFile --
d188 6
a193 4
int 
TclpObjRenameFile(srcPathPtr, destPathPtr)
    Tcl_Obj *srcPathPtr;
    Tcl_Obj *destPathPtr;
d195 10
a204 2
    return DoRenameFile(Tcl_FSGetNativePath(srcPathPtr), 
			Tcl_FSGetNativePath(destPathPtr));
d242 1
a242 1
	Tcl_DirEntry *dirEntPtr;
d244 2
a245 2
	if ((Realpath((char *) src, srcPath) != NULL)	/* INTL: Native. */
		&& (Realpath((char *) dst, dstPath) != NULL) /* INTL: Native. */
d250 1
a250 1
		    dirEntPtr = TclOSreaddir(dirPtr); /* INTL: Native. */
d286 1
d291 1
a291 1
 * TclpObjCopyFile, DoCopyFile --
d316 3
a318 3
TclpObjCopyFile(srcPathPtr, destPathPtr)
    Tcl_Obj *srcPathPtr;
    Tcl_Obj *destPathPtr;
d320 9
a328 2
    return DoCopyFile(Tcl_FSGetNativePath(srcPathPtr), 
		      Tcl_FSGetNativePath(destPathPtr));
d332 3
a334 3
DoCopyFile(src, dst)
    CONST char *src;	/* Pathname of file to be copied (native). */
    CONST char *dst;	/* Pathname of file to copy to (native). */
d336 5
a340 1
    Tcl_StatBuf srcStatBuf, dstStatBuf;
d346 1
a346 1
    if (TclOSlstat(src, &srcStatBuf) != 0) {		/* INTL: Native. */
d359 1
a359 1
    if (TclOSlstat(dst, &dstStatBuf) == 0) {		/* INTL: Native. */
a371 1
#ifndef DJGPP
a385 1
#endif
d429 1
a429 1
    CONST Tcl_StatBuf *statBufPtr;
d438 1
a438 1
    if ((srcFd = TclOSopen(src, O_RDONLY, 0)) < 0) {	/* INTL: Native. */
d442 1
a442 1
    dstFd = TclOSopen(dst, O_CREAT|O_TRUNC|O_WRONLY,	/* INTL: Native. */
d500 1
a500 1
 * TclpObjDeleteFile, DoDeleteFile --
d519 3
a521 3
int 
TclpObjDeleteFile(pathPtr)
    Tcl_Obj *pathPtr;
d523 7
a529 1
    return DoDeleteFile(Tcl_FSGetNativePath(pathPtr));
d533 2
a534 2
DoDeleteFile(path)
    CONST char *path;	/* Pathname of file to be removed (native). */
d536 3
d571 3
a573 3
int 
TclpObjCreateDirectory(pathPtr)
    Tcl_Obj *pathPtr;
d575 7
a581 1
    return DoCreateDirectory(Tcl_FSGetNativePath(pathPtr));
d585 2
a586 2
DoCreateDirectory(path)
    CONST char *path;	/* Pathname of directory to create (native). */
d589 3
d611 1
a611 1
 * TclpObjCopyDirectory --
d622 2
a623 2
 *	is stored in errorPtr.  See TclpObjCreateDirectory and 
 *	TclpObjCopyFile for a description of possible values for errno.
d634 8
a641 5
int 
TclpObjCopyDirectory(srcPathPtr, destPathPtr, errorPtr)
    Tcl_Obj *srcPathPtr;
    Tcl_Obj *destPathPtr;
    Tcl_Obj **errorPtr;
a642 1
    Tcl_DString ds;
d644 1
a644 1
    int ret;
d646 2
a647 6
    Tcl_UtfToExternalDString(NULL, 
			     Tcl_FSGetTranslatedStringPath(NULL,srcPathPtr), 
			     -1, &srcString);
    Tcl_UtfToExternalDString(NULL, 
			     Tcl_FSGetTranslatedStringPath(NULL,destPathPtr), 
			     -1, &dstString);
d649 1
a649 1
    ret = TraverseUnixTree(TraversalCopy, &srcString, &dstString, &ds);
d653 1
a653 7

    if (ret != TCL_OK) {
	*errorPtr = Tcl_NewStringObj(Tcl_DStringValue(&ds), -1);
	Tcl_DStringFree(&ds);
	Tcl_IncrRefCount(*errorPtr);
    }
    return ret;
a654 1

d682 10
a691 5
int 
TclpObjRemoveDirectory(pathPtr, recursive, errorPtr)
    Tcl_Obj *pathPtr;
    int recursive;
    Tcl_Obj **errorPtr;
d693 1
a693 1
    Tcl_DString ds;
a694 1
    int ret;
d696 2
a697 3
    Tcl_UtfToExternalDString(NULL, Tcl_FSGetTranslatedStringPath(NULL, pathPtr), 
			     -1, &pathString);
    ret = DoRemoveDirectory(&pathString, recursive, &ds);
d700 1
a700 6
    if (ret != TCL_OK) {
	*errorPtr = Tcl_NewStringObj(Tcl_DStringValue(&ds), -1);
	Tcl_DStringFree(&ds);
	Tcl_IncrRefCount(*errorPtr);
    }
    return ret;
d715 1
a715 3
    mode_t oldPerm = 0;
    int result;
    
a716 14
    
    if (recursive != 0) {
	/* We should try to change permissions so this can be deleted */
	Tcl_StatBuf statBuf;
	int newPerm;

	if (TclOSstat(path, &statBuf) == 0) {
	    oldPerm = (mode_t) (statBuf.st_mode & 0x00007FFF);
	}
	
	newPerm = oldPerm | (64+128+256);
	chmod(path, (mode_t) newPerm);
    }
    
a722 2

    result = TCL_OK;
d727 1
a727 1
	result = TCL_ERROR;
d735 1
a735 9
    if (result == TCL_OK) {
	result = TraverseUnixTree(TraversalDelete, pathPtr, NULL, errorPtr);
    }
    
    if ((result != TCL_OK) && (recursive != 0)) {
        /* Try to restore permissions */
        chmod(path, oldPerm);
    }
    return result;
d772 1
a772 1
    Tcl_StatBuf statBuf;
d776 1
a776 1
    Tcl_DirEntry *dirEntPtr;
d784 1
a784 1
    if (TclOSlstat(source, &statBuf) != 0) {		/* INTL: Native. */
d819 2
a820 2

    while ((dirEntPtr = TclOSreaddir(dirPtr)) != NULL) { /* INTL: Native. */
d885 2
a886 2
 *      Called from TraverseUnixTree in order to execute a recursive copy
 *      of a directory.
d902 1
a902 1
    CONST Tcl_StatBuf *statBufPtr;
d911 1
a911 2
	    if (DoCopyFile(Tcl_DStringValue(srcPtr), 
		    Tcl_DStringValue(dstPtr)) == TCL_OK) {
d917 1
a917 1
	    if (DoCreateDirectory(Tcl_DStringValue(dstPtr)) == TCL_OK) {
d966 1
a966 1
    CONST Tcl_StatBuf *statBufPtr;
d975 1
a975 1
	    if (DoDeleteFile(Tcl_DStringValue(srcPtr)) == 0) {
d1020 1
a1020 1
    CONST Tcl_StatBuf *statBufPtr;
d1076 1
a1076 1
    Tcl_Obj *fileName;  	/* The name of the file (UTF-8). */
d1079 1
a1079 1
    Tcl_StatBuf statBuf;
d1083 1
a1083 1
    result = TclpObjStat(fileName, &statBuf);
d1086 1
a1086 2
	Tcl_AppendResult(interp, "could not read \"", 
		Tcl_GetString(fileName), "\": ",
d1093 1
a1093 1
	*attributePtrPtr = Tcl_NewIntObj((int) statBuf.st_gid);
d1127 1
a1127 1
    Tcl_Obj *fileName;  	/* The name of the file (UTF-8). */
d1130 1
a1130 1
    Tcl_StatBuf statBuf;
d1134 1
a1134 1
    result = TclpObjStat(fileName, &statBuf);
d1137 1
a1137 2
	Tcl_AppendResult(interp, "could not read \"", 
		Tcl_GetString(fileName), "\": ",
d1144 1
a1144 1
	*attributePtrPtr = Tcl_NewIntObj((int) statBuf.st_uid);
d1178 1
a1178 1
    Tcl_Obj *fileName;  	    /* The name of the file (UTF-8). */
d1181 1
a1181 1
    Tcl_StatBuf statBuf;
d1185 1
a1185 1
    result = TclpObjStat(fileName, &statBuf);
d1188 1
a1188 2
	Tcl_AppendResult(interp, "could not read \"", 
		Tcl_GetString(fileName), "\": ",
d1193 1
a1193 1
    sprintf(returnString, "%0#5lo", (long) (statBuf.st_mode & 0x00007FFF));
d1220 1
a1220 1
    Tcl_Obj *fileName;	            /* The name of the file (UTF-8). */
d1225 1
a1228 1
	Tcl_DString ds;
d1242 1
a1242 2
		    Tcl_GetString(fileName), "\": group \"", 
		    string, "\" does not exist",
d1249 1
a1249 1
    native = Tcl_FSGetNativePath(fileName);
d1251 1
d1256 1
a1256 2
	    Tcl_GetString(fileName), "\": ", Tcl_PosixError(interp), 
	    (char *) NULL);
d1282 1
a1282 1
    Tcl_Obj *fileName;   	    /* The name of the file (UTF-8). */
d1287 1
a1290 1
	Tcl_DString ds;
d1303 1
a1303 2
			     Tcl_GetString(fileName), "\": user \"", 
			     string, "\" does not exist",
d1310 1
a1310 1
    native = Tcl_FSGetNativePath(fileName);
d1312 1
d1315 2
a1316 3
	Tcl_AppendResult(interp, "could not set owner for file \"", 
			 Tcl_GetString(fileName), "\": ", 
			 Tcl_PosixError(interp), (char *) NULL);
d1342 1
a1342 1
    Tcl_Obj *fileName;  	    /* The name of the file (UTF-8). */
d1349 1
d1357 1
a1357 1
	Tcl_StatBuf buf;
d1366 1
a1366 1
	result = TclpObjStat(fileName, &buf);
d1368 1
a1368 2
	    Tcl_AppendResult(interp, "could not read \"", 
		    Tcl_GetString(fileName), "\": ",
d1382 1
a1382 1
    native = Tcl_FSGetNativePath(fileName);
d1384 1
d1387 1
a1387 2
		"could not set permissions for file \"", 
		Tcl_GetString(fileName), "\": ",
d1397 1
a1397 1
 * TclpObjListVolumes --
d1402 3
a1404 1
 *	The list of volumes.
d1412 4
a1415 2
Tcl_Obj*
TclpObjListVolumes(void)
d1417 5
a1421 4
    Tcl_Obj *resultPtr = Tcl_NewStringObj("/",1);

    Tcl_IncrRefCount(resultPtr);
    return resultPtr;
a1611 88

/*
 *---------------------------------------------------------------------------
 *
 * TclpObjNormalizePath --
 *
 *	This function scans through a path specification and replaces
 *	it, in place, with a normalized version.  A normalized version
 *	is one in which all symlinks in the path are replaced with
 *	their expanded form (except a symlink at the very end of the
 *	path).
 *
 * Results:
 *	The new 'nextCheckpoint' value, giving as far as we could
 *	understand in the path.
 *
 * Side effects:
 *	The pathPtr string, is modified.
 *
 *---------------------------------------------------------------------------
 */

int
TclpObjNormalizePath(interp, pathPtr, nextCheckpoint)
    Tcl_Interp *interp;
    Tcl_Obj *pathPtr;
    int nextCheckpoint;
{
    char *currentPathEndPosition;
    int pathLen;
    char cur;
    char *path = Tcl_GetStringFromObj(pathPtr, &pathLen);
#ifndef NO_REALPATH
    char normPath[MAXPATHLEN];
    Tcl_DString ds;
    CONST char *nativePath; 
#endif

    currentPathEndPosition = path + nextCheckpoint;

    while (1) {
	cur = *currentPathEndPosition;
	if ((cur == '/') && (path != currentPathEndPosition)) {
	    /* Reached directory separator */
	    Tcl_DString ds;
	    CONST char *nativePath;
	    int accessOk;

	    nativePath = Tcl_UtfToExternalDString(NULL, path, 
		    currentPathEndPosition - path, &ds);
	    accessOk = access(nativePath, F_OK);
	    Tcl_DStringFree(&ds);
	    if (accessOk != 0) {
		/* File doesn't exist */
		break;
	    }
	    /* Update the acceptable point */
	    nextCheckpoint = currentPathEndPosition - path;
	} else if (cur == 0) {
	    /* Reached end of string */
	    break;
	}
	currentPathEndPosition++;
    }
    /* 
     * We should really now convert this to a canonical path.  We do
     * that with 'realpath' if we have it available.  Otherwise we could
     * step through every single path component, checking whether it is a 
     * symlink, but that would be a lot of work, and most modern OSes 
     * have 'realpath'.
     */
#ifndef NO_REALPATH
    /* 
     * If we only had '/foo' or '/' then we never increment nextCheckpoint
     * and we don't need or want to go through 'Realpath'.  Also, on some
     * platforms, passing an empty string to 'Realpath' will give us the
     * normalized pwd, which is not what we want at all!
     */
    if (nextCheckpoint == 0) return 0;
    
    nativePath = Tcl_UtfToExternalDString(NULL, path, nextCheckpoint, &ds);
    if (Realpath(nativePath, normPath) != NULL) {
	/* 
	 * Free up the native path and put in its place the
	 * converted, normalized path.
	 */
	Tcl_DStringFree(&ds);
	Tcl_ExternalToUtfDString(NULL, normPath, (int) strlen(normPath), &ds);
a1612 22
	if (path[nextCheckpoint] != '\0') {
	    /* not at end, append remaining path */
	    int normLen = Tcl_DStringLength(&ds);
	    Tcl_DStringAppend(&ds, path + nextCheckpoint,
		    pathLen - nextCheckpoint);
	    /* 
	     * We recognise up to and including the directory
	     * separator.
	     */	
	    nextCheckpoint = normLen + 1;
	} else {
	    /* We recognise the whole string */ 
	    nextCheckpoint = Tcl_DStringLength(&ds);
	}
	/* 
	 * Overwrite with the normalized path.
	 */
	Tcl_SetStringObj(pathPtr, Tcl_DStringValue(&ds),
		Tcl_DStringLength(&ds));
    }
    Tcl_DStringFree(&ds);
#endif	/* !NO_REALPATH */
a1613 2
    return nextCheckpoint;
}
@


