head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.58
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.56
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.54
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.52
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.50
	gdb_7_0-branch:1.5.0.48
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tcl8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.46
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.44
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.42
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.40
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.38
	gdb_6_5-2006-05-14-branchpoint:1.5
	readline_5_1-import-branch:1.5.0.36
	readline_5_1-import-branchpoint:1.5
	gdb_6_4-branch:1.5.0.34
	gdb_6_4-2005-11-01-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.32
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	ezannoni_pie-20040323-branch:1.5.0.30
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.28
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.26
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.24
	cagney_x86i386-20030821-branch:1.5.0.22
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.20
	gdb_6_0-2003-06-23-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.18
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.16
	cagney_writestrings-20030508-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.14
	cagney_fileio-20030521-branchpoint:1.5
	carlton_dictionary-20030430-merge:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.12
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.10
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.8
	cagney_lazyid-20030317-branchpoint:1.5
	offbyone-20030313-branch:1.5.0.6
	offbyone-20030313-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.4
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.2
	interps-20030202-branchpoint:1.5
	TCL8_4_1:1.1.1.3
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.2
	TCL_8_4_1:1.1.1.3
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.4
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TCL_8_4_0:1.1.1.3
	carlton_dictionary-branch:1.2.0.16
	carlton_dictionary-20020920-branchpoint:1.2
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.14
	gdb_5_3-branch:1.2.0.12
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.10
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.8
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.6
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TCL_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	dejagnu-2000-02-04:1.1.1.1
	dejagnu-2000-01-31:1.1.1.1
	dejagnu-2000-01-24:1.1.1.1
	dejagnu-2000-01-17:1.1.1.1
	dejagnu-2000-01-10:1.1.1.1
	dejagnu-2000-01-04:1.1.1.1
	dejagnu-1999-12-21:1.1.1.1
	dejagnu-1999-12-13:1.1.1.1
	dejagnu-1999-12-07:1.1.1.1
	dejagnu-1999-12-06:1.1.1.1
	dejagnu-1999-11-15:1.1.1.1
	dejagnu-1999-11-08:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.5
date	2003.01.21.19.40.21;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.26.19.48.05;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.37.10;	author kseitz;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2001.09.09.23.56.09;	author irox;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2002.09.27.21.49.14;	author kseitz;	state Exp;
branches;
next	;

1.3.4.1
date	2003.12.14.20.28.51;	author drow;	state Exp;
branches;
next	;

1.2.16.1
date	2002.12.23.19.40.52;	author carlton;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2003.02.07.19.18.23;	author carlton;	state Exp;
branches;
next	;

1.1.1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.09.22.41.00;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.19.55.49;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tcl 8.4.1
@
text
@/* 
 * tclUnixTime.c --
 *
 *	Contains Unix specific versions of Tcl functions that
 *	obtain time values from the operating system.
 *
 * Copyright (c) 1995 Sun Microsystems, Inc.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tclUnixTime.c,v 1.15 2002/07/19 12:31:10 dkf Exp $
 */

#include "tclInt.h"
#include "tclPort.h"
#include <locale.h>
#define TM_YEAR_BASE 1900
#define IsLeapYear(x)   ((x % 4 == 0) && (x % 100 != 0 || x % 400 == 0))

/*
 * TclpGetDate is coded to return a pointer to a 'struct tm'.  For
 * thread safety, this structure must be in thread-specific data.
 * The 'tmKey' variable is the key to this buffer.
 */

static Tcl_ThreadDataKey tmKey;

/*
 * If we fall back on the thread-unsafe versions of gmtime and localtime,
 * use this mutex to try to protect them.
 */

#if !defined(HAVE_GMTIME_R) || !defined(HAVE_LOCALTIME_R)
TCL_DECLARE_MUTEX(tmMutex)
#endif

/*
 * Forward declarations for procedures defined later in this file.
 */

static struct tm *ThreadSafeGMTime _ANSI_ARGS_(( CONST time_t* ));
static struct tm *ThreadSafeLocalTime _ANSI_ARGS_(( CONST time_t* ));

/*
 *-----------------------------------------------------------------------------
 *
 * TclpGetSeconds --
 *
 *	This procedure returns the number of seconds from the epoch.  On
 *	most Unix systems the epoch is Midnight Jan 1, 1970 GMT.
 *
 * Results:
 *	Number of seconds from the epoch.
 *
 * Side effects:
 *	None.
 *
 *-----------------------------------------------------------------------------
 */

unsigned long
TclpGetSeconds()
{
    return time((time_t *) NULL);
}

/*
 *-----------------------------------------------------------------------------
 *
 * TclpGetClicks --
 *
 *	This procedure returns a value that represents the highest resolution
 *	clock available on the system.  There are no garantees on what the
 *	resolution will be.  In Tcl we will call this value a "click".  The
 *	start time is also system dependant.
 *
 * Results:
 *	Number of clicks from some start time.
 *
 * Side effects:
 *	None.
 *
 *-----------------------------------------------------------------------------
 */

unsigned long
TclpGetClicks()
{
    unsigned long now;
#ifdef NO_GETTOD
    struct tms dummy;
#else
    struct timeval date;
    struct timezone tz;
#endif

#ifdef NO_GETTOD
    now = (unsigned long) times(&dummy);
#else
    gettimeofday(&date, &tz);
    now = date.tv_sec*1000000 + date.tv_usec;
#endif

    return now;
}

/*
 *----------------------------------------------------------------------
 *
 * TclpGetTimeZone --
 *
 *	Determines the current timezone.  The method varies wildly
 *	between different platform implementations, so its hidden in
 *	this function.
 *
 * Results:
 *	The return value is the local time zone, measured in
 *	minutes away from GMT (-ve for east, +ve for west).
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
TclpGetTimeZone (currentTime)
    unsigned long  currentTime;
{
    /*
     * Determine how a timezone is obtained from "struct tm".  If there is no
     * time zone in this struct (very lame) then use the timezone variable.
     * This is done in a way to make the timezone variable the method of last
     * resort, as some systems have it in addition to a field in "struct tm".
     * The gettimeofday system call can also be used to determine the time
     * zone.
     */
    
#if defined(HAVE_TM_TZADJ)
#   define TCL_GOT_TIMEZONE
    time_t      curTime = (time_t) currentTime;
    struct tm  *timeDataPtr = ThreadSafeLocalTime(&curTime);
    int         timeZone;

    timeZone = timeDataPtr->tm_tzadj  / 60;
    if (timeDataPtr->tm_isdst) {
        timeZone += 60;
    }
    
    return timeZone;
#endif

#if defined(HAVE_TM_GMTOFF) && !defined (TCL_GOT_TIMEZONE)
#   define TCL_GOT_TIMEZONE
    time_t     curTime = (time_t) currentTime;
    struct tm *timeDataPtr = ThreadSafeLocalTime(&curTime);
    int        timeZone;

    timeZone = -(timeDataPtr->tm_gmtoff / 60);
    if (timeDataPtr->tm_isdst) {
        timeZone += 60;
    }
    
    return timeZone;
#endif

#if defined(USE_DELTA_FOR_TZ)
#define TCL_GOT_TIMEZONE 1
    /*
     * This hack replaces using global var timezone or gettimeofday
     * in situations where they are buggy such as on AIX when libbsd.a
     * is linked in.
     */

    int timeZone;
    time_t tt;
    struct tm *stm;
    tt = 849268800L;      /*    1996-11-29 12:00:00  GMT */
    stm = ThreadSafeLocalTime(&tt); /* eg 1996-11-29  6:00:00  CST6CDT */
    /* The calculation below assumes a max of +12 or -12 hours from GMT */
    timeZone = (12 - stm->tm_hour)*60 + (0 - stm->tm_min);
    return timeZone;  /* eg +360 for CST6CDT */
#endif

    /*
     * Must prefer timezone variable over gettimeofday, as gettimeofday does
     * not return timezone information on many systems that have moved this
     * information outside of the kernel.
     */
    
#if defined(HAVE_TIMEZONE_VAR) && !defined (TCL_GOT_TIMEZONE)
#   define TCL_GOT_TIMEZONE
    static int setTZ = 0;
#ifdef TCL_THREADS
    static Tcl_Mutex tzMutex;
#endif
    int        timeZone;

    Tcl_MutexLock(&tzMutex);
    if (!setTZ) {
        tzset();
        setTZ = 1;
    }
    Tcl_MutexUnlock(&tzMutex);

    /*
     * Note: this is not a typo in "timezone" below!  See tzset
     * documentation for details.
     */

    timeZone = timezone / 60;

    return timeZone;
#endif

#if !defined(NO_GETTOD) && !defined (TCL_GOT_TIMEZONE)
#   define TCL_GOT_TIMEZONE
    struct timeval  tv;
    struct timezone tz;
    int timeZone;

    gettimeofday(&tv, &tz);
    timeZone = tz.tz_minuteswest;
    if (tz.tz_dsttime) {
        timeZone += 60;
    }
    
    return timeZone;
#endif

#ifndef TCL_GOT_TIMEZONE
    /*
     * Cause compile error, we don't know how to get timezone.
     */
    error: autoconf did not figure out how to determine the timezone. 
#endif

}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetTime --
 *
 *	Gets the current system time in seconds and microseconds
 *	since the beginning of the epoch: 00:00 UCT, January 1, 1970.
 *
 * Results:
 *	Returns the current time in timePtr.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

void
Tcl_GetTime(timePtr)
    Tcl_Time *timePtr;		/* Location to store time information. */
{
    struct timeval tv;
    struct timezone tz;
    
    (void) gettimeofday(&tv, &tz);
    timePtr->sec = tv.tv_sec;
    timePtr->usec = tv.tv_usec;
}

/*
 *----------------------------------------------------------------------
 *
 * TclpGetDate --
 *
 *	This function converts between seconds and struct tm.  If
 *	useGMT is true, then the returned date will be in Greenwich
 *	Mean Time (GMT).  Otherwise, it will be in the local time zone.
 *
 * Results:
 *	Returns a static tm structure.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

struct tm *
TclpGetDate(time, useGMT)
    TclpTime_t time;
    int useGMT;
{
    CONST time_t *tp = (CONST time_t *)time;

    if (useGMT) {
	return ThreadSafeGMTime(tp);
    } else {
	return ThreadSafeLocalTime(tp);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * TclpStrftime --
 *
 *	On Unix, we can safely call the native strftime implementation,
 *	and also ignore the useGMT parameter.
 *
 * Results:
 *	The normal strftime result.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

size_t
TclpStrftime(s, maxsize, format, t, useGMT)
    char *s;
    size_t maxsize;
    CONST char *format;
    CONST struct tm *t;
    int useGMT;
{
    if (format[0] == '%' && format[1] == 'Q') {
	/* Format as a stardate */
	sprintf(s, "Stardate %2d%03d.%01d",
		(((t->tm_year + TM_YEAR_BASE) + 377) - 2323),
		(((t->tm_yday + 1) * 1000) /
			(365 + IsLeapYear((t->tm_year + TM_YEAR_BASE)))),
		(((t->tm_hour * 60) + t->tm_min)/144));
	return(strlen(s));
    }
    setlocale(LC_TIME, "");
    return strftime(s, maxsize, format, t);
}

/*
 *----------------------------------------------------------------------
 *
 * ThreadSafeGMTime --
 *
 *	Wrapper around the 'gmtime' library function to make it thread
 *	safe.
 *
 * Results:
 *	Returns a pointer to a 'struct tm' in thread-specific data.
 *
 * Side effects:
 *	Invokes gmtime or gmtime_r as appropriate.
 *
 *----------------------------------------------------------------------
 */

static struct tm *
ThreadSafeGMTime(timePtr)
    CONST time_t *timePtr;	/* Pointer to the number of seconds
				 * since the local system's epoch
				 */

{
    /*
     * Get a thread-local buffer to hold the returned time.
     */

    struct tm *tmPtr = (struct tm *)
	    Tcl_GetThreadData(&tmKey, sizeof(struct tm));
#ifdef HAVE_GMTIME_R
    gmtime_r(timePtr, tmPtr);
#else
    Tcl_MutexLock(&tmMutex);
    memcpy((VOID *) tmPtr, (VOID *) gmtime(timePtr), sizeof(struct tm));
    Tcl_MutexUnlock(&tmMutex);
#endif    
    return tmPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * ThreadSafeLocalTime --
 *
 *	Wrapper around the 'localtime' library function to make it thread
 *	safe.
 *
 * Results:
 *	Returns a pointer to a 'struct tm' in thread-specific data.
 *
 * Side effects:
 *	Invokes localtime or localtime_r as appropriate.
 *
 *----------------------------------------------------------------------
 */

static struct tm *
ThreadSafeLocalTime(timePtr)
    CONST time_t *timePtr;	/* Pointer to the number of seconds
				 * since the local system's epoch
				 */

{
    /*
     * Get a thread-local buffer to hold the returned time.
     */

    struct tm *tmPtr = (struct tm *)
	    Tcl_GetThreadData(&tmKey, sizeof(struct tm));
#ifdef HAVE_LOCALTIME_R
    localtime_r(timePtr, tmPtr);
#else
    Tcl_MutexLock(&tmMutex);
    memcpy((VOID *) tmPtr, (VOID *) localtime(timePtr), sizeof(struct tm));
    Tcl_MutexUnlock(&tmMutex);
#endif    
    return tmPtr;
}
@


1.4
log
@touched all sources to ease next import
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tclUnixTime.c,v 1.6.8.2 2000/04/17 22:46:20 spolk Exp $
d17 1
d20 24
d143 1
a143 1
    struct tm  *timeDataPtr = localtime(&curTime);
d157 1
a157 1
    struct tm *timeDataPtr = localtime(&curTime);
d180 1
a180 1
    stm = localtime(&tt); /* eg 1996-11-29  6:00:00  CST6CDT */
d244 1
a244 1
 * TclpGetTime --
d259 1
a259 1
TclpGetTime(timePtr)
d296 1
a296 1
	return gmtime(tp);
d298 1
a298 1
	return localtime(tp);
d307 2
a308 1
 *	On Unix, we can safely call the native strftime implementation.
d320 1
a320 1
TclpStrftime(s, maxsize, format, t)
d325 1
d336 1
d338 80
@


1.3
log
@touched all sources to ease next import
@
text
@@


1.3.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tclUnixTime.c,v 1.15 2002/07/19 12:31:10 dkf Exp $
a16 1
#include <locale.h>
a18 24

/*
 * TclpGetDate is coded to return a pointer to a 'struct tm'.  For
 * thread safety, this structure must be in thread-specific data.
 * The 'tmKey' variable is the key to this buffer.
 */

static Tcl_ThreadDataKey tmKey;

/*
 * If we fall back on the thread-unsafe versions of gmtime and localtime,
 * use this mutex to try to protect them.
 */

#if !defined(HAVE_GMTIME_R) || !defined(HAVE_LOCALTIME_R)
TCL_DECLARE_MUTEX(tmMutex)
#endif

/*
 * Forward declarations for procedures defined later in this file.
 */

static struct tm *ThreadSafeGMTime _ANSI_ARGS_(( CONST time_t* ));
static struct tm *ThreadSafeLocalTime _ANSI_ARGS_(( CONST time_t* ));
d118 1
a118 1
    struct tm  *timeDataPtr = ThreadSafeLocalTime(&curTime);
d132 1
a132 1
    struct tm *timeDataPtr = ThreadSafeLocalTime(&curTime);
d155 1
a155 1
    stm = ThreadSafeLocalTime(&tt); /* eg 1996-11-29  6:00:00  CST6CDT */
d219 1
a219 1
 * Tcl_GetTime --
d234 1
a234 1
Tcl_GetTime(timePtr)
d271 1
a271 1
	return ThreadSafeGMTime(tp);
d273 1
a273 1
	return ThreadSafeLocalTime(tp);
d282 1
a282 2
 *	On Unix, we can safely call the native strftime implementation,
 *	and also ignore the useGMT parameter.
d294 1
a294 1
TclpStrftime(s, maxsize, format, t, useGMT)
a298 1
    int useGMT;
a308 1
    setlocale(LC_TIME, "");
a309 80
}

/*
 *----------------------------------------------------------------------
 *
 * ThreadSafeGMTime --
 *
 *	Wrapper around the 'gmtime' library function to make it thread
 *	safe.
 *
 * Results:
 *	Returns a pointer to a 'struct tm' in thread-specific data.
 *
 * Side effects:
 *	Invokes gmtime or gmtime_r as appropriate.
 *
 *----------------------------------------------------------------------
 */

static struct tm *
ThreadSafeGMTime(timePtr)
    CONST time_t *timePtr;	/* Pointer to the number of seconds
				 * since the local system's epoch
				 */

{
    /*
     * Get a thread-local buffer to hold the returned time.
     */

    struct tm *tmPtr = (struct tm *)
	    Tcl_GetThreadData(&tmKey, sizeof(struct tm));
#ifdef HAVE_GMTIME_R
    gmtime_r(timePtr, tmPtr);
#else
    Tcl_MutexLock(&tmMutex);
    memcpy((VOID *) tmPtr, (VOID *) gmtime(timePtr), sizeof(struct tm));
    Tcl_MutexUnlock(&tmMutex);
#endif    
    return tmPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * ThreadSafeLocalTime --
 *
 *	Wrapper around the 'localtime' library function to make it thread
 *	safe.
 *
 * Results:
 *	Returns a pointer to a 'struct tm' in thread-specific data.
 *
 * Side effects:
 *	Invokes localtime or localtime_r as appropriate.
 *
 *----------------------------------------------------------------------
 */

static struct tm *
ThreadSafeLocalTime(timePtr)
    CONST time_t *timePtr;	/* Pointer to the number of seconds
				 * since the local system's epoch
				 */

{
    /*
     * Get a thread-local buffer to hold the returned time.
     */

    struct tm *tmPtr = (struct tm *)
	    Tcl_GetThreadData(&tmKey, sizeof(struct tm));
#ifdef HAVE_LOCALTIME_R
    localtime_r(timePtr, tmPtr);
#else
    Tcl_MutexLock(&tmMutex);
    memcpy((VOID *) tmPtr, (VOID *) localtime(timePtr), sizeof(struct tm));
    Tcl_MutexUnlock(&tmMutex);
#endif    
    return tmPtr;
@


1.3.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tclUnixTime.c,v 1.15 2002/07/19 12:31:10 dkf Exp $
a16 1
#include <locale.h>
a18 24

/*
 * TclpGetDate is coded to return a pointer to a 'struct tm'.  For
 * thread safety, this structure must be in thread-specific data.
 * The 'tmKey' variable is the key to this buffer.
 */

static Tcl_ThreadDataKey tmKey;

/*
 * If we fall back on the thread-unsafe versions of gmtime and localtime,
 * use this mutex to try to protect them.
 */

#if !defined(HAVE_GMTIME_R) || !defined(HAVE_LOCALTIME_R)
TCL_DECLARE_MUTEX(tmMutex)
#endif

/*
 * Forward declarations for procedures defined later in this file.
 */

static struct tm *ThreadSafeGMTime _ANSI_ARGS_(( CONST time_t* ));
static struct tm *ThreadSafeLocalTime _ANSI_ARGS_(( CONST time_t* ));
d118 1
a118 1
    struct tm  *timeDataPtr = ThreadSafeLocalTime(&curTime);
d132 1
a132 1
    struct tm *timeDataPtr = ThreadSafeLocalTime(&curTime);
d155 1
a155 1
    stm = ThreadSafeLocalTime(&tt); /* eg 1996-11-29  6:00:00  CST6CDT */
d219 1
a219 1
 * Tcl_GetTime --
d234 1
a234 1
Tcl_GetTime(timePtr)
d271 1
a271 1
	return ThreadSafeGMTime(tp);
d273 1
a273 1
	return ThreadSafeLocalTime(tp);
d282 1
a282 2
 *	On Unix, we can safely call the native strftime implementation,
 *	and also ignore the useGMT parameter.
d294 1
a294 1
TclpStrftime(s, maxsize, format, t, useGMT)
a298 1
    int useGMT;
a308 1
    setlocale(LC_TIME, "");
a309 80
}

/*
 *----------------------------------------------------------------------
 *
 * ThreadSafeGMTime --
 *
 *	Wrapper around the 'gmtime' library function to make it thread
 *	safe.
 *
 * Results:
 *	Returns a pointer to a 'struct tm' in thread-specific data.
 *
 * Side effects:
 *	Invokes gmtime or gmtime_r as appropriate.
 *
 *----------------------------------------------------------------------
 */

static struct tm *
ThreadSafeGMTime(timePtr)
    CONST time_t *timePtr;	/* Pointer to the number of seconds
				 * since the local system's epoch
				 */

{
    /*
     * Get a thread-local buffer to hold the returned time.
     */

    struct tm *tmPtr = (struct tm *)
	    Tcl_GetThreadData(&tmKey, sizeof(struct tm));
#ifdef HAVE_GMTIME_R
    gmtime_r(timePtr, tmPtr);
#else
    Tcl_MutexLock(&tmMutex);
    memcpy((VOID *) tmPtr, (VOID *) gmtime(timePtr), sizeof(struct tm));
    Tcl_MutexUnlock(&tmMutex);
#endif    
    return tmPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * ThreadSafeLocalTime --
 *
 *	Wrapper around the 'localtime' library function to make it thread
 *	safe.
 *
 * Results:
 *	Returns a pointer to a 'struct tm' in thread-specific data.
 *
 * Side effects:
 *	Invokes localtime or localtime_r as appropriate.
 *
 *----------------------------------------------------------------------
 */

static struct tm *
ThreadSafeLocalTime(timePtr)
    CONST time_t *timePtr;	/* Pointer to the number of seconds
				 * since the local system's epoch
				 */

{
    /*
     * Get a thread-local buffer to hold the returned time.
     */

    struct tm *tmPtr = (struct tm *)
	    Tcl_GetThreadData(&tmKey, sizeof(struct tm));
#ifdef HAVE_LOCALTIME_R
    localtime_r(timePtr, tmPtr);
#else
    Tcl_MutexLock(&tmMutex);
    memcpy((VOID *) tmPtr, (VOID *) localtime(timePtr), sizeof(struct tm));
    Tcl_MutexUnlock(&tmMutex);
#endif    
    return tmPtr;
@


1.2
log
@touched all Tcl files to ease next import.
@
text
@@


1.2.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.2.16.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@a16 1
#include <locale.h>
a18 24

/*
 * TclpGetDate is coded to return a pointer to a 'struct tm'.  For
 * thread safety, this structure must be in thread-specific data.
 * The 'tmKey' variable is the key to this buffer.
 */

static Tcl_ThreadDataKey tmKey;

/*
 * If we fall back on the thread-unsafe versions of gmtime and localtime,
 * use this mutex to try to protect them.
 */

#if !defined(HAVE_GMTIME_R) || !defined(HAVE_LOCALTIME_R)
TCL_DECLARE_MUTEX(tmMutex)
#endif

/*
 * Forward declarations for procedures defined later in this file.
 */

static struct tm *ThreadSafeGMTime _ANSI_ARGS_(( CONST time_t* ));
static struct tm *ThreadSafeLocalTime _ANSI_ARGS_(( CONST time_t* ));
d118 1
a118 1
    struct tm  *timeDataPtr = ThreadSafeLocalTime(&curTime);
d132 1
a132 1
    struct tm *timeDataPtr = ThreadSafeLocalTime(&curTime);
d155 1
a155 1
    stm = ThreadSafeLocalTime(&tt); /* eg 1996-11-29  6:00:00  CST6CDT */
d219 1
a219 1
 * Tcl_GetTime --
d234 1
a234 1
Tcl_GetTime(timePtr)
d271 1
a271 1
	return ThreadSafeGMTime(tp);
d273 1
a273 1
	return ThreadSafeLocalTime(tp);
d282 1
a282 2
 *	On Unix, we can safely call the native strftime implementation,
 *	and also ignore the useGMT parameter.
d294 1
a294 1
TclpStrftime(s, maxsize, format, t, useGMT)
a298 1
    int useGMT;
a308 1
    setlocale(LC_TIME, "");
a309 80
}

/*
 *----------------------------------------------------------------------
 *
 * ThreadSafeGMTime --
 *
 *	Wrapper around the 'gmtime' library function to make it thread
 *	safe.
 *
 * Results:
 *	Returns a pointer to a 'struct tm' in thread-specific data.
 *
 * Side effects:
 *	Invokes gmtime or gmtime_r as appropriate.
 *
 *----------------------------------------------------------------------
 */

static struct tm *
ThreadSafeGMTime(timePtr)
    CONST time_t *timePtr;	/* Pointer to the number of seconds
				 * since the local system's epoch
				 */

{
    /*
     * Get a thread-local buffer to hold the returned time.
     */

    struct tm *tmPtr = (struct tm *)
	    Tcl_GetThreadData(&tmKey, sizeof(struct tm));
#ifdef HAVE_GMTIME_R
    gmtime_r(timePtr, tmPtr);
#else
    Tcl_MutexLock(&tmMutex);
    memcpy((VOID *) tmPtr, (VOID *) gmtime(timePtr), sizeof(struct tm));
    Tcl_MutexUnlock(&tmMutex);
#endif    
    return tmPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * ThreadSafeLocalTime --
 *
 *	Wrapper around the 'localtime' library function to make it thread
 *	safe.
 *
 * Results:
 *	Returns a pointer to a 'struct tm' in thread-specific data.
 *
 * Side effects:
 *	Invokes localtime or localtime_r as appropriate.
 *
 *----------------------------------------------------------------------
 */

static struct tm *
ThreadSafeLocalTime(timePtr)
    CONST time_t *timePtr;	/* Pointer to the number of seconds
				 * since the local system's epoch
				 */

{
    /*
     * Get a thread-local buffer to hold the returned time.
     */

    struct tm *tmPtr = (struct tm *)
	    Tcl_GetThreadData(&tmKey, sizeof(struct tm));
#ifdef HAVE_LOCALTIME_R
    localtime_r(timePtr, tmPtr);
#else
    Tcl_MutexLock(&tmMutex);
    memcpy((VOID *) tmPtr, (VOID *) localtime(timePtr), sizeof(struct tm));
    Tcl_MutexUnlock(&tmMutex);
#endif    
    return tmPtr;
@


1.1
log
@Initial revision
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tclUnixTime.c,v 1.9 1999/01/26 03:53:40 jingham Exp $
d17 2
d170 3
d175 1
d180 1
d243 67
@


1.1.1.1
log
@import dejagnu-1999-11-08 snapshot
@
text
@@


1.1.1.2
log
@Tcl 8.3 upgrade
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tclUnixTime.c,v 1.6.8.2 2000/04/17 22:46:20 spolk Exp $
a16 2
#define TM_YEAR_BASE 1900
#define IsLeapYear(x)   ((x % 4 == 0) && (x % 100 != 0 || x % 400 == 0))
a167 3
#ifdef TCL_THREADS
    static Tcl_Mutex tzMutex;
#endif
a169 1
    Tcl_MutexLock(&tzMutex);
a173 1
    Tcl_MutexUnlock(&tzMutex);
a235 67
}

/*
 *----------------------------------------------------------------------
 *
 * TclpGetDate --
 *
 *	This function converts between seconds and struct tm.  If
 *	useGMT is true, then the returned date will be in Greenwich
 *	Mean Time (GMT).  Otherwise, it will be in the local time zone.
 *
 * Results:
 *	Returns a static tm structure.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

struct tm *
TclpGetDate(time, useGMT)
    TclpTime_t time;
    int useGMT;
{
    CONST time_t *tp = (CONST time_t *)time;

    if (useGMT) {
	return gmtime(tp);
    } else {
	return localtime(tp);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * TclpStrftime --
 *
 *	On Unix, we can safely call the native strftime implementation.
 *
 * Results:
 *	The normal strftime result.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

size_t
TclpStrftime(s, maxsize, format, t)
    char *s;
    size_t maxsize;
    CONST char *format;
    CONST struct tm *t;
{
    if (format[0] == '%' && format[1] == 'Q') {
	/* Format as a stardate */
	sprintf(s, "Stardate %2d%03d.%01d",
		(((t->tm_year + TM_YEAR_BASE) + 377) - 2323),
		(((t->tm_yday + 1) * 1000) /
			(365 + IsLeapYear((t->tm_year + TM_YEAR_BASE)))),
		(((t->tm_hour * 60) + t->tm_min)/144));
	return(strlen(s));
    }
    return strftime(s, maxsize, format, t);
@


1.1.1.3
log
@import tcl 8.4.0
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tclUnixTime.c,v 1.15 2002/07/19 12:31:10 dkf Exp $
a16 1
#include <locale.h>
a18 24

/*
 * TclpGetDate is coded to return a pointer to a 'struct tm'.  For
 * thread safety, this structure must be in thread-specific data.
 * The 'tmKey' variable is the key to this buffer.
 */

static Tcl_ThreadDataKey tmKey;

/*
 * If we fall back on the thread-unsafe versions of gmtime and localtime,
 * use this mutex to try to protect them.
 */

#if !defined(HAVE_GMTIME_R) || !defined(HAVE_LOCALTIME_R)
TCL_DECLARE_MUTEX(tmMutex)
#endif

/*
 * Forward declarations for procedures defined later in this file.
 */

static struct tm *ThreadSafeGMTime _ANSI_ARGS_(( CONST time_t* ));
static struct tm *ThreadSafeLocalTime _ANSI_ARGS_(( CONST time_t* ));
d118 1
a118 1
    struct tm  *timeDataPtr = ThreadSafeLocalTime(&curTime);
d132 1
a132 1
    struct tm *timeDataPtr = ThreadSafeLocalTime(&curTime);
d155 1
a155 1
    stm = ThreadSafeLocalTime(&tt); /* eg 1996-11-29  6:00:00  CST6CDT */
d219 1
a219 1
 * Tcl_GetTime --
d234 1
a234 1
Tcl_GetTime(timePtr)
d271 1
a271 1
	return ThreadSafeGMTime(tp);
d273 1
a273 1
	return ThreadSafeLocalTime(tp);
d282 1
a282 2
 *	On Unix, we can safely call the native strftime implementation,
 *	and also ignore the useGMT parameter.
d294 1
a294 1
TclpStrftime(s, maxsize, format, t, useGMT)
a298 1
    int useGMT;
a308 1
    setlocale(LC_TIME, "");
a309 80
}

/*
 *----------------------------------------------------------------------
 *
 * ThreadSafeGMTime --
 *
 *	Wrapper around the 'gmtime' library function to make it thread
 *	safe.
 *
 * Results:
 *	Returns a pointer to a 'struct tm' in thread-specific data.
 *
 * Side effects:
 *	Invokes gmtime or gmtime_r as appropriate.
 *
 *----------------------------------------------------------------------
 */

static struct tm *
ThreadSafeGMTime(timePtr)
    CONST time_t *timePtr;	/* Pointer to the number of seconds
				 * since the local system's epoch
				 */

{
    /*
     * Get a thread-local buffer to hold the returned time.
     */

    struct tm *tmPtr = (struct tm *)
	    Tcl_GetThreadData(&tmKey, sizeof(struct tm));
#ifdef HAVE_GMTIME_R
    gmtime_r(timePtr, tmPtr);
#else
    Tcl_MutexLock(&tmMutex);
    memcpy((VOID *) tmPtr, (VOID *) gmtime(timePtr), sizeof(struct tm));
    Tcl_MutexUnlock(&tmMutex);
#endif    
    return tmPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * ThreadSafeLocalTime --
 *
 *	Wrapper around the 'localtime' library function to make it thread
 *	safe.
 *
 * Results:
 *	Returns a pointer to a 'struct tm' in thread-specific data.
 *
 * Side effects:
 *	Invokes localtime or localtime_r as appropriate.
 *
 *----------------------------------------------------------------------
 */

static struct tm *
ThreadSafeLocalTime(timePtr)
    CONST time_t *timePtr;	/* Pointer to the number of seconds
				 * since the local system's epoch
				 */

{
    /*
     * Get a thread-local buffer to hold the returned time.
     */

    struct tm *tmPtr = (struct tm *)
	    Tcl_GetThreadData(&tmKey, sizeof(struct tm));
#ifdef HAVE_LOCALTIME_R
    localtime_r(timePtr, tmPtr);
#else
    Tcl_MutexLock(&tmMutex);
    memcpy((VOID *) tmPtr, (VOID *) localtime(timePtr), sizeof(struct tm));
    Tcl_MutexUnlock(&tmMutex);
#endif    
    return tmPtr;
@


