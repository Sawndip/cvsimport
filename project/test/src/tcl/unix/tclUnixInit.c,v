head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.58
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.56
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.54
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.52
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.50
	gdb_7_0-branch:1.5.0.48
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tcl8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.46
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.44
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.42
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.40
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.38
	gdb_6_5-2006-05-14-branchpoint:1.5
	readline_5_1-import-branch:1.5.0.36
	readline_5_1-import-branchpoint:1.5
	gdb_6_4-branch:1.5.0.34
	gdb_6_4-2005-11-01-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.32
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	ezannoni_pie-20040323-branch:1.5.0.30
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.28
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.26
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.24
	cagney_x86i386-20030821-branch:1.5.0.22
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.20
	gdb_6_0-2003-06-23-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.18
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.16
	cagney_writestrings-20030508-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.14
	cagney_fileio-20030521-branchpoint:1.5
	carlton_dictionary-20030430-merge:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.12
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.10
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.8
	cagney_lazyid-20030317-branchpoint:1.5
	offbyone-20030313-branch:1.5.0.6
	offbyone-20030313-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.4
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.2
	interps-20030202-branchpoint:1.5
	TCL8_4_1:1.1.1.4
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.2
	TCL_8_4_1:1.1.1.4
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.4
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TCL_8_4_0:1.1.1.3
	carlton_dictionary-branch:1.2.0.16
	carlton_dictionary-20020920-branchpoint:1.2
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.14
	gdb_5_3-branch:1.2.0.12
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.10
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.8
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.6
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TCL_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	dejagnu-2000-02-04:1.1.1.1
	dejagnu-2000-01-31:1.1.1.1
	dejagnu-2000-01-24:1.1.1.1
	dejagnu-2000-01-17:1.1.1.1
	dejagnu-2000-01-10:1.1.1.1
	dejagnu-2000-01-04:1.1.1.1
	dejagnu-1999-12-21:1.1.1.1
	dejagnu-1999-12-13:1.1.1.1
	dejagnu-1999-12-07:1.1.1.1
	dejagnu-1999-12-06:1.1.1.1
	dejagnu-1999-11-15:1.1.1.1
	dejagnu-1999-11-08:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.5
date	2003.01.21.19.40.20;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.26.19.48.05;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.37.10;	author kseitz;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2001.09.09.23.56.09;	author irox;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2002.09.27.21.49.14;	author kseitz;	state Exp;
branches;
next	;

1.3.4.1
date	2003.12.14.20.28.51;	author drow;	state Exp;
branches;
next	;

1.2.16.1
date	2002.12.23.19.40.51;	author carlton;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2003.02.07.19.18.23;	author carlton;	state Exp;
branches;
next	;

1.1.1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.09.22.40.59;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.19.55.48;	author kseitz;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.11.26.20.00.01;	author hunt;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tcl 8.4.1
@
text
@/* 
 * tclUnixInit.c --
 *
 *	Contains the Unix-specific interpreter initialization functions.
 *
 * Copyright (c) 1995-1997 Sun Microsystems, Inc.
 * Copyright (c) 1999 by Scriptics Corporation.
 * All rights reserved.
 *
 * RCS: @@(#) $Id: tclUnixInit.c,v 1.34 2002/10/22 16:41:28 das Exp $
 */

#if defined(HAVE_CFBUNDLE)
#include <CoreFoundation/CoreFoundation.h>
#endif
#include "tclInt.h"
#include "tclPort.h"
#include <locale.h>
#ifdef HAVE_LANGINFO
#include <langinfo.h>
#endif
#if defined(__FreeBSD__)
#   include <floatingpoint.h>
#endif
#if defined(__bsdi__)
#   include <sys/param.h>
#   if _BSDI_VERSION > 199501
#	include <dlfcn.h>
#   endif
#endif

/*
 * The Init script (common to Windows and Unix platforms) is
 * defined in tkInitScript.h
 */
#include "tclInitScript.h"

/* Used to store the encoding used for binary files */
static Tcl_Encoding binaryEncoding = NULL;
/* Has the basic library path encoding issue been fixed */
static int libraryPathEncodingFixed = 0;

/*
 * Tcl tries to use standard and homebrew methods to guess the right
 * encoding on the platform.  However, there is always a final fallback,
 * and this value is it.  Make sure it is a real Tcl encoding.
 */

#ifndef TCL_DEFAULT_ENCODING
#define TCL_DEFAULT_ENCODING "iso8859-1"
#endif

/*
 * Default directory in which to look for Tcl library scripts.  The
 * symbol is defined by Makefile.
 */

static char defaultLibraryDir[sizeof(TCL_LIBRARY)+200] = TCL_LIBRARY;

/*
 * Directory in which to look for packages (each package is typically
 * installed as a subdirectory of this directory).  The symbol is
 * defined by Makefile.
 */

static char pkgPath[sizeof(TCL_PACKAGE_PATH)+200] = TCL_PACKAGE_PATH;

/*
 * The following table is used to map from Unix locale strings to
 * encoding files.  If HAVE_LANGINFO is defined, then this is a fallback
 * table when the result from nl_langinfo isn't a recognized encoding.
 * Otherwise this is the first list checked for a mapping from env
 * encoding to Tcl encoding name.
 */

typedef struct LocaleTable {
    CONST char *lang;
    CONST char *encoding;
} LocaleTable;

static CONST LocaleTable localeTable[] = {
#ifdef HAVE_LANGINFO
    {"gb2312-1980",	"gb2312"},
#ifdef __hpux
    {"SJIS",		"shiftjis"},
    {"eucjp",		"euc-jp"},
    {"euckr",		"euc-kr"},
    {"euctw",		"euc-cn"},
    {"greek8",		"cp869"},
    {"iso88591",	"iso8859-1"},
    {"iso88592",	"iso8859-2"},
    {"iso88595",	"iso8859-5"},
    {"iso88596",	"iso8859-6"},
    {"iso88597",	"iso8859-7"},
    {"iso88598",	"iso8859-8"},
    {"iso88599",	"iso8859-9"},
    {"iso885915",	"iso8859-15"},
    {"roman8",		"iso8859-1"},
    {"tis620",		"tis-620"},
    {"turkish8",	"cp857"},
    {"utf8",		"utf-8"},
#endif /* __hpux */
#endif /* HAVE_LANGINFO */

    {"ja_JP.SJIS",	"shiftjis"},
    {"ja_JP.EUC",	"euc-jp"},
    {"ja_JP.eucJP",     "euc-jp"},
    {"ja_JP.JIS",	"iso2022-jp"},
    {"ja_JP.mscode",	"shiftjis"},
    {"ja_JP.ujis",	"euc-jp"},
    {"ja_JP",		"euc-jp"},
    {"Ja_JP",		"shiftjis"},
    {"Jp_JP",		"shiftjis"},
    {"japan",		"euc-jp"},
#ifdef hpux
    {"japanese",	"shiftjis"},	
    {"ja",		"shiftjis"},	
#else
    {"japanese",	"euc-jp"},
    {"ja",		"euc-jp"},
#endif
    {"japanese.sjis",	"shiftjis"},
    {"japanese.euc",	"euc-jp"},
    {"japanese-sjis",	"shiftjis"},
    {"japanese-ujis",	"euc-jp"},

    {"ko",              "euc-kr"},
    {"ko_KR",           "euc-kr"},
    {"ko_KR.EUC",       "euc-kr"},
    {"ko_KR.euc",       "euc-kr"},
    {"ko_KR.eucKR",     "euc-kr"},
    {"korean",          "euc-kr"},

    {"ru",		"iso8859-5"},		
    {"ru_RU",		"iso8859-5"},		
    {"ru_SU",		"iso8859-5"},		

    {"zh",		"cp936"},

    {NULL, NULL}
};

#ifdef HAVE_CFBUNDLE
static int Tcl_MacOSXGetLibraryPath(Tcl_Interp *interp, int maxPathLen, char *tclLibPath);
#endif /* HAVE_CFBUNDLE */


/*
 *---------------------------------------------------------------------------
 *
 * TclpInitPlatform --
 *
 *	Initialize all the platform-dependant things like signals and
 *	floating-point error handling.
 *
 *	Called at process initialization time.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
 */

void
TclpInitPlatform()
{
    tclPlatform = TCL_PLATFORM_UNIX;

    /*
     * The code below causes SIGPIPE (broken pipe) errors to
     * be ignored.  This is needed so that Tcl processes don't
     * die if they create child processes (e.g. using "exec" or
     * "open") that terminate prematurely.  The signal handler
     * is only set up when the first interpreter is created;
     * after this the application can override the handler with
     * a different one of its own, if it wants.
     */

#ifdef SIGPIPE
    (void) signal(SIGPIPE, SIG_IGN);
#endif /* SIGPIPE */

#ifdef __FreeBSD__
    fpsetround(FP_RN);
    fpsetmask(0L);
#endif

#if defined(__bsdi__) && (_BSDI_VERSION > 199501)
    /*
     * Find local symbols. Don't report an error if we fail.
     */
    (void) dlopen (NULL, RTLD_NOW);			/* INTL: Native. */
#endif
}

/*
 *---------------------------------------------------------------------------
 *
 * TclpInitLibraryPath --
 *
 *	Initialize the library path at startup.  We have a minor
 *	metacircular problem that we don't know the encoding of the
 *	operating system but we may need to talk to operating system
 *	to find the library directories so that we know how to talk to
 *	the operating system.
 *
 *	We do not know the encoding of the operating system.
 *	We do know that the encoding is some multibyte encoding.
 *	In that multibyte encoding, the characters 0..127 are equivalent
 *	    to ascii.
 *
 *	So although we don't know the encoding, it's safe:
 *	    to look for the last slash character in a path in the encoding.
 *	    to append an ascii string to a path.
 *	    to pass those strings back to the operating system.
 *
 *	But any strings that we remembered before we knew the encoding of
 *	the operating system must be translated to UTF-8 once we know the
 *	encoding so that the rest of Tcl can use those strings.
 *
 *	This call sets the library path to strings in the unknown native
 *	encoding.  TclpSetInitialEncodings() will translate the library
 *	path from the native encoding to UTF-8 as soon as it determines
 *	what the native encoding actually is.
 *
 *	Called at process initialization time.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
 */

void
TclpInitLibraryPath(path)
CONST char *path;		/* Path to the executable in native 
				 * multi-byte encoding. */
{
#define LIBRARY_SIZE	    32
    Tcl_Obj *pathPtr, *objPtr;
    CONST char *str;
    Tcl_DString buffer, ds;
    int pathc;
    CONST char **pathv;
    char installLib[LIBRARY_SIZE], developLib[LIBRARY_SIZE];

    Tcl_DStringInit(&ds);
    pathPtr = Tcl_NewObj();

    /*
     * Initialize the substrings used when locating an executable.  The
     * installLib variable computes the path as though the executable
     * is installed.  The developLib computes the path as though the
     * executable is run from a develpment directory.
     */
     
    /* REDHAT LOCAL */
    sprintf(installLib, "share/tcl%s", TCL_VERSION);
    /* sprintf(installLib, "lib/tcl%s", TCL_VERSION); */
    /* END REDHAT LOCAL */

    sprintf(developLib, "tcl%s/library", TCL_PATCH_LEVEL);

    /*
     * Look for the library relative to default encoding dir.
     */

    str = Tcl_GetDefaultEncodingDir();
    if ((str != NULL) && (str[0] != '\0')) {
	objPtr = Tcl_NewStringObj(str, -1);
	Tcl_ListObjAppendElement(NULL, pathPtr, objPtr);
    }

    /*
     * Look for the library relative to the TCL_LIBRARY env variable.
     * If the last dirname in the TCL_LIBRARY path does not match the
     * last dirname in the installLib variable, use the last dir name
     * of installLib in addition to the orginal TCL_LIBRARY path.
     */

    str = getenv("TCL_LIBRARY");			/* INTL: Native. */
    Tcl_ExternalToUtfDString(NULL, str, -1, &buffer);
    str = Tcl_DStringValue(&buffer);

    if ((str != NULL) && (str[0] != '\0')) {
	/*
	 * If TCL_LIBRARY is set, search there.
	 */
	 
	objPtr = Tcl_NewStringObj(str, -1);
	Tcl_ListObjAppendElement(NULL, pathPtr, objPtr);

	Tcl_SplitPath(str, &pathc, &pathv);
	if ((pathc > 0) && (strcasecmp(installLib + 4, pathv[pathc-1]) != 0)) {
	    /*
	     * If TCL_LIBRARY is set but refers to a different tcl
	     * installation than the current version, try fiddling with the
	     * specified directory to make it refer to this installation by
	     * removing the old "tclX.Y" and substituting the current
	     * version string.
	     */
	    
	    pathv[pathc - 1] = installLib + 4;
	    str = Tcl_JoinPath(pathc, pathv, &ds);
	    objPtr = Tcl_NewStringObj(str, Tcl_DStringLength(&ds));
	    Tcl_ListObjAppendElement(NULL, pathPtr, objPtr);
	    Tcl_DStringFree(&ds);
	}
	ckfree((char *) pathv);
    }

    /*
     * Look for the library relative to the executable.  This algorithm
     * should be the same as the one in the tcl_findLibrary procedure.
     *
     * This code looks in the following directories:
     *
     *	<bindir>/../<installLib>
     *	  (e.g. /usr/local/bin/../lib/tcl8.4)
     *	<bindir>/../../<installLib>
     *	  (e.g. /usr/local/TclPro/solaris-sparc/bin/../../lib/tcl8.4)
     *	<bindir>/../library
     *	  (e.g. /usr/src/tcl8.4.0/unix/../library)
     *	<bindir>/../../library
     *	  (e.g. /usr/src/tcl8.4.0/unix/solaris-sparc/../../library)
     *	<bindir>/../../<developLib>
     *	  (e.g. /usr/src/tcl8.4.0/unix/../../tcl8.4.0/library)
     *	<bindir>/../../../<developLib>
     *	  (e.g. /usr/src/tcl8.4.0/unix/solaris-sparc/../../../tcl8.4.0/library)
     */
     

     /*
      * The variable path holds an absolute path.  Take care not to
      * overwrite pathv[0] since that might produce a relative path.
      */

    if (path != NULL) {
	Tcl_SplitPath(path, &pathc, &pathv);
	if (pathc > 2) {
	    str = pathv[pathc - 2];
	    pathv[pathc - 2] = installLib;
	    path = Tcl_JoinPath(pathc - 1, pathv, &ds);
	    pathv[pathc - 2] = str;
	    objPtr = Tcl_NewStringObj(path, Tcl_DStringLength(&ds));
	    Tcl_ListObjAppendElement(NULL, pathPtr, objPtr);
	    Tcl_DStringFree(&ds);
	}
	if (pathc > 3) {
	    str = pathv[pathc - 3];
	    pathv[pathc - 3] = installLib;
	    path = Tcl_JoinPath(pathc - 2, pathv, &ds);
	    pathv[pathc - 3] = str;
	    objPtr = Tcl_NewStringObj(path, Tcl_DStringLength(&ds));
	    Tcl_ListObjAppendElement(NULL, pathPtr, objPtr);
	    Tcl_DStringFree(&ds);
	}
	if (pathc > 2) {
	    str = pathv[pathc - 2];
	    pathv[pathc - 2] = "library";
	    path = Tcl_JoinPath(pathc - 1, pathv, &ds);
	    pathv[pathc - 2] = str;
	    objPtr = Tcl_NewStringObj(path, Tcl_DStringLength(&ds));
	    Tcl_ListObjAppendElement(NULL, pathPtr, objPtr);
	    Tcl_DStringFree(&ds);
	}
	if (pathc > 3) {
	    str = pathv[pathc - 3];
	    pathv[pathc - 3] = "library";
	    path = Tcl_JoinPath(pathc - 2, pathv, &ds);
	    pathv[pathc - 3] = str;
	    objPtr = Tcl_NewStringObj(path, Tcl_DStringLength(&ds));
	    Tcl_ListObjAppendElement(NULL, pathPtr, objPtr);
	    Tcl_DStringFree(&ds);
	}
	if (pathc > 3) {
	    str = pathv[pathc - 3];
	    pathv[pathc - 3] = developLib;
	    path = Tcl_JoinPath(pathc - 2, pathv, &ds);
	    pathv[pathc - 3] = str;
	    objPtr = Tcl_NewStringObj(path, Tcl_DStringLength(&ds));
	    Tcl_ListObjAppendElement(NULL, pathPtr, objPtr);
	    Tcl_DStringFree(&ds);
	}
	if (pathc > 4) {
	    str = pathv[pathc - 4];
	    pathv[pathc - 4] = developLib;
	    path = Tcl_JoinPath(pathc - 3, pathv, &ds);
	    pathv[pathc - 4] = str;
	    objPtr = Tcl_NewStringObj(path, Tcl_DStringLength(&ds));
	    Tcl_ListObjAppendElement(NULL, pathPtr, objPtr);
	    Tcl_DStringFree(&ds);
	}
	ckfree((char *) pathv);
    }

    /*
     * Finally, look for the library relative to the compiled-in path.
     * This is needed when users install Tcl with an exec-prefix that
     * is different from the prtefix.
     */
			      
    {
#ifdef HAVE_CFBUNDLE
    char tclLibPath[MAXPATHLEN + 1];
    
    if (Tcl_MacOSXGetLibraryPath(NULL, MAXPATHLEN, tclLibPath) == TCL_OK) {
        str = tclLibPath;
    } else
#endif /* HAVE_CFBUNDLE */
    {
        str = defaultLibraryDir;
    }
    if (str[0] != '\0') {
        objPtr = Tcl_NewStringObj(str, -1);
        Tcl_ListObjAppendElement(NULL, pathPtr, objPtr);
    }
    }

    TclSetLibraryPath(pathPtr);    
    Tcl_DStringFree(&buffer);
}

/*
 *---------------------------------------------------------------------------
 *
 * TclpSetInitialEncodings --
 *
 *	Based on the locale, determine the encoding of the operating
 *	system and the default encoding for newly opened files.
 *
 *	Called at process initialization time, and part way through
 *	startup, we verify that the initial encodings were correctly
 *	setup.  Depending on Tcl's environment, there may not have been
 *	enough information first time through (above).
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The Tcl library path is converted from native encoding to UTF-8,
 *	on the first call, and the encodings may be changed on first or
 *	second call.
 *
 *---------------------------------------------------------------------------
 */

void
TclpSetInitialEncodings()
{
    if (libraryPathEncodingFixed == 0) {
	CONST char *encoding = NULL;
	int i, setSysEncCode = TCL_ERROR;
	Tcl_Obj *pathPtr;

	/*
	 * Determine the current encoding from the LC_* or LANG environment
	 * variables.  We previously used setlocale() to determine the locale,
	 * but this does not work on some systems (e.g. Linux/i386 RH 5.0).
	 */
#ifdef HAVE_LANGINFO
	if (setlocale(LC_CTYPE, "") != NULL) {
	    Tcl_DString ds;

	    /*
	     * Use a DString so we can overwrite it in name compatability
	     * checks below.
	     */

	    Tcl_DStringInit(&ds);
	    encoding = Tcl_DStringAppend(&ds, nl_langinfo(CODESET), -1);

	    Tcl_UtfToLower(Tcl_DStringValue(&ds));
#ifdef HAVE_LANGINFO_DEBUG
	    fprintf(stderr, "encoding '%s'", encoding);
#endif
	    if (encoding[0] == 'i' && encoding[1] == 's' && encoding[2] == 'o'
		    && encoding[3] == '-') {
		char *p, *q;
		/* need to strip '-' from iso-* encoding */
		for(p = Tcl_DStringValue(&ds)+3, q = Tcl_DStringValue(&ds)+4;
		    *p; *p++ = *q++);
	    } else if (encoding[0] == 'i' && encoding[1] == 'b'
		    && encoding[2] == 'm' && encoding[3] >= '0'
		    && encoding[3] <= '9') {
		char *p, *q;
		/* if langinfo reports "ibm*" we should use "cp*" */
		p = Tcl_DStringValue(&ds);
		*p++ = 'c'; *p++ = 'p';
		for(q = p+1; *p ; *p++ = *q++);
	    } else if ((*encoding == '\0')
		    || !strcmp(encoding, "ansi_x3.4-1968")) {
		/* Use iso8859-1 for empty or 'ansi_x3.4-1968' encoding */
		encoding = "iso8859-1";
	    }
#ifdef HAVE_LANGINFO_DEBUG
	    fprintf(stderr, " ?%s?", encoding);
#endif
	    setSysEncCode = Tcl_SetSystemEncoding(NULL, encoding);
	    if (setSysEncCode != TCL_OK) {
		/*
		 * If this doesn't return TCL_OK, the encoding returned by
		 * nl_langinfo or as we translated it wasn't accepted.  Do
		 * this fallback check.  If this fails, we will enter the
		 * old fallback below.
		 */

		for (i = 0; localeTable[i].lang != NULL; i++) {
		    if (strcmp(localeTable[i].lang, encoding) == 0) {
			setSysEncCode = Tcl_SetSystemEncoding(NULL,
				localeTable[i].encoding);
			break;
		    }
		}
	    }
#ifdef HAVE_LANGINFO_DEBUG
	    fprintf(stderr, " => '%s'\n", encoding);
#endif
	    Tcl_DStringFree(&ds);
	}
#ifdef HAVE_LANGINFO_DEBUG
	else {
	    fprintf(stderr, "setlocale returned NULL\n");
	}
#endif
#endif /* HAVE_LANGINFO */

	if (setSysEncCode != TCL_OK) {
	    /*
	     * Classic fallback check.  This tries a homebrew algorithm to
	     * determine what encoding should be used based on env vars.
	     */
	    char *langEnv = getenv("LC_ALL");
	    encoding = NULL;

	    if (langEnv == NULL || langEnv[0] == '\0') {
		langEnv = getenv("LC_CTYPE");
	    }
	    if (langEnv == NULL || langEnv[0] == '\0') {
		langEnv = getenv("LANG");
	    }
	    if (langEnv == NULL || langEnv[0] == '\0') {
		langEnv = NULL;
	    }

	    if (langEnv != NULL) {
		for (i = 0; localeTable[i].lang != NULL; i++) {
		    if (strcmp(localeTable[i].lang, langEnv) == 0) {
			encoding = localeTable[i].encoding;
			break;
		    }
		}
		/*
		 * There was no mapping in the locale table.  If there is an
		 * encoding subfield, we can try to guess from that.
		 */

		if (encoding == NULL) {
		    char *p;
		    for (p = langEnv; *p != '\0'; p++) {
			if (*p == '.') {
			    p++;
			    break;
			}
		    }
		    if (*p != '\0') {
			Tcl_DString ds;
			Tcl_DStringInit(&ds);
			encoding = Tcl_DStringAppend(&ds, p, -1);

			Tcl_UtfToLower(Tcl_DStringValue(&ds));
			setSysEncCode = Tcl_SetSystemEncoding(NULL, encoding);
			if (setSysEncCode != TCL_OK) {
			    encoding = NULL;
			}
			Tcl_DStringFree(&ds);
		    }
		}
#ifdef HAVE_LANGINFO_DEBUG
		fprintf(stderr, "encoding fallback check '%s' => '%s'\n",
			langEnv, encoding);
#endif
	    }
	    if (setSysEncCode != TCL_OK) {
		if (encoding == NULL) {
		    encoding = TCL_DEFAULT_ENCODING;
		}

		Tcl_SetSystemEncoding(NULL, encoding);
	    }

	    /*
	     * Initialize the C library's locale subsystem.  This is required
	     * for input methods to work properly on X11.  We only do this for
	     * LC_CTYPE because that's the necessary one, and we don't want to
	     * affect LC_TIME here.  The side effect of setting the default
	     * locale should be to load any locale specific modules that are
	     * needed by X.  [BUG: 5422 3345 4236 2522 2521].
	     * In HAVE_LANGINFO, this call is already done above.
	     */
#ifndef HAVE_LANGINFO
	    setlocale(LC_CTYPE, "");
#endif
	}

	/*
	 * In case the initial locale is not "C", ensure that the numeric
	 * processing is done in "C" locale regardless.  This is needed because
	 * Tcl relies on routines like strtod, but should not have locale
	 * dependent behavior.
	 */

	setlocale(LC_NUMERIC, "C");

	/*
	 * Until the system encoding was actually set, the library path was
	 * actually in the native multi-byte encoding, and not really UTF-8
	 * as advertised.  We cheated as follows:
	 *
	 * 1. It was safe to allow the Tcl_SetSystemEncoding() call to 
	 * append the ASCII chars that make up the encoding's filename to 
	 * the names (in the native encoding) of directories in the library 
	 * path, since all Unix multi-byte encodings have ASCII in the
	 * beginning.
	 *
	 * 2. To open the encoding file, the native bytes in the file name
	 * were passed to the OS, without translating from UTF-8 to native,
	 * because the name was already in the native encoding.
	 *
	 * Now that the system encoding was actually successfully set,
	 * translate all the names in the library path to UTF-8.  That way,
	 * next time we search the library path, we'll translate the names 
	 * from UTF-8 to the system encoding which will be the native 
	 * encoding.
	 */

	pathPtr = TclGetLibraryPath();
	if (pathPtr != NULL) {
	    int objc;
	    Tcl_Obj **objv;
	    
	    objc = 0;
	    Tcl_ListObjGetElements(NULL, pathPtr, &objc, &objv);
	    for (i = 0; i < objc; i++) {
		int length;
		char *string;
		Tcl_DString ds;

		string = Tcl_GetStringFromObj(objv[i], &length);
		Tcl_ExternalToUtfDString(NULL, string, length, &ds);
		Tcl_SetStringObj(objv[i], Tcl_DStringValue(&ds), 
			Tcl_DStringLength(&ds));
		Tcl_DStringFree(&ds);
	    }
	}

	libraryPathEncodingFixed = 1;
    }
    
    /* This is only ever called from the startup thread */
    if (binaryEncoding == NULL) {
	/*
	 * Keep the iso8859-1 encoding preloaded.  The IO package uses
	 * it for gets on a binary channel.
	 */
	binaryEncoding = Tcl_GetEncoding(NULL, "iso8859-1");
    }
}

/*
 *---------------------------------------------------------------------------
 *
 * TclpSetVariables --
 *
 *	Performs platform-specific interpreter initialization related to
 *	the tcl_library and tcl_platform variables, and other platform-
 *	specific things.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Sets "tclDefaultLibrary", "tcl_pkgPath", and "tcl_platform" Tcl
 *	variables.
 *
 *----------------------------------------------------------------------
 */

void
TclpSetVariables(interp)
    Tcl_Interp *interp;
{
#ifndef NO_UNAME
    struct utsname name;
#endif
    int unameOK;
    CONST char *user;
    Tcl_DString ds;

#ifdef HAVE_CFBUNDLE
    char tclLibPath[MAXPATHLEN + 1];
    
    if (Tcl_MacOSXGetLibraryPath(interp, MAXPATHLEN, tclLibPath) == TCL_OK) {
        CONST char *str;
        Tcl_DString ds;
        CFBundleRef bundleRef;

        Tcl_SetVar(interp, "tclDefaultLibrary", tclLibPath, 
                TCL_GLOBAL_ONLY);
        Tcl_SetVar(interp, "tcl_pkgPath", tclLibPath,
                TCL_GLOBAL_ONLY);
        Tcl_SetVar(interp, "tcl_pkgPath", " ",
                TCL_GLOBAL_ONLY | TCL_APPEND_VALUE);
        str = TclGetEnv("DYLD_FRAMEWORK_PATH", &ds);
        if ((str != NULL) && (str[0] != '\0')) {
            char *p = Tcl_DStringValue(&ds);
            /* convert DYLD_FRAMEWORK_PATH from colon to space separated */
            do {
                if(*p == ':') *p = ' ';
            } while (*p++);
            Tcl_SetVar(interp, "tcl_pkgPath", Tcl_DStringValue(&ds),
                    TCL_GLOBAL_ONLY | TCL_APPEND_VALUE);
            Tcl_SetVar(interp, "tcl_pkgPath", " ",
                    TCL_GLOBAL_ONLY | TCL_APPEND_VALUE);
            Tcl_DStringFree(&ds);
        }
        if ((bundleRef = CFBundleGetMainBundle())) {
            CFURLRef frameworksURL;
            Tcl_StatBuf statBuf;
            if((frameworksURL = CFBundleCopyPrivateFrameworksURL(bundleRef))) {
                if(CFURLGetFileSystemRepresentation(frameworksURL, TRUE,
                            tclLibPath, MAXPATHLEN) &&
                        ! TclOSstat(tclLibPath, &statBuf) &&
                        S_ISDIR(statBuf.st_mode)) {
                    Tcl_SetVar(interp, "tcl_pkgPath", tclLibPath,
                            TCL_GLOBAL_ONLY | TCL_APPEND_VALUE);
                    Tcl_SetVar(interp, "tcl_pkgPath", " ",
                            TCL_GLOBAL_ONLY | TCL_APPEND_VALUE);
                }
                CFRelease(frameworksURL);
            }
            if((frameworksURL = CFBundleCopySharedFrameworksURL(bundleRef))) {
                if(CFURLGetFileSystemRepresentation(frameworksURL, TRUE,
                            tclLibPath, MAXPATHLEN) &&
                        ! TclOSstat(tclLibPath, &statBuf) &&
                        S_ISDIR(statBuf.st_mode)) {
                    Tcl_SetVar(interp, "tcl_pkgPath", tclLibPath,
                            TCL_GLOBAL_ONLY | TCL_APPEND_VALUE);
                    Tcl_SetVar(interp, "tcl_pkgPath", " ",
                            TCL_GLOBAL_ONLY | TCL_APPEND_VALUE);
                }
                CFRelease(frameworksURL);
            }
        }
        Tcl_SetVar(interp, "tcl_pkgPath", pkgPath,
                TCL_GLOBAL_ONLY | TCL_APPEND_VALUE);
    } else
#endif /* HAVE_CFBUNDLE */
    {
        Tcl_SetVar(interp, "tclDefaultLibrary", defaultLibraryDir, 
                TCL_GLOBAL_ONLY);
        Tcl_SetVar(interp, "tcl_pkgPath", pkgPath, TCL_GLOBAL_ONLY);
    }

#ifdef DJGPP
    Tcl_SetVar2(interp, "tcl_platform", "platform", "dos", TCL_GLOBAL_ONLY);
#else
    Tcl_SetVar2(interp, "tcl_platform", "platform", "unix", TCL_GLOBAL_ONLY);
#endif
    unameOK = 0;
#ifndef NO_UNAME
    if (uname(&name) >= 0) {
	CONST char *native;
	
	unameOK = 1;

	native = Tcl_ExternalToUtfDString(NULL, name.sysname, -1, &ds);
	Tcl_SetVar2(interp, "tcl_platform", "os", native, TCL_GLOBAL_ONLY);
	Tcl_DStringFree(&ds);
	
	/*
	 * The following code is a special hack to handle differences in
	 * the way version information is returned by uname.  On most
	 * systems the full version number is available in name.release.
	 * However, under AIX the major version number is in
	 * name.version and the minor version number is in name.release.
	 */

	if ((strchr(name.release, '.') != NULL)
		|| !isdigit(UCHAR(name.version[0]))) {	/* INTL: digit */
	    Tcl_SetVar2(interp, "tcl_platform", "osVersion", name.release,
		    TCL_GLOBAL_ONLY);
	} else {
	    Tcl_SetVar2(interp, "tcl_platform", "osVersion", name.version,
		    TCL_GLOBAL_ONLY);
	    Tcl_SetVar2(interp, "tcl_platform", "osVersion", ".",
		    TCL_GLOBAL_ONLY|TCL_APPEND_VALUE);
	    Tcl_SetVar2(interp, "tcl_platform", "osVersion", name.release,
		    TCL_GLOBAL_ONLY|TCL_APPEND_VALUE);
	}
	Tcl_SetVar2(interp, "tcl_platform", "machine", name.machine,
		TCL_GLOBAL_ONLY);
    }
#endif
    if (!unameOK) {
	Tcl_SetVar2(interp, "tcl_platform", "os", "", TCL_GLOBAL_ONLY);
	Tcl_SetVar2(interp, "tcl_platform", "osVersion", "", TCL_GLOBAL_ONLY);
	Tcl_SetVar2(interp, "tcl_platform", "machine", "", TCL_GLOBAL_ONLY);
    }

    /*
     * Copy USER or LOGNAME environment variable into tcl_platform(user)
     */

    Tcl_DStringInit(&ds);
    user = TclGetEnv("USER", &ds);
    if (user == NULL) {
	user = TclGetEnv("LOGNAME", &ds);
	if (user == NULL) {
	    user = "";
	}
    }
    Tcl_SetVar2(interp, "tcl_platform", "user", user, TCL_GLOBAL_ONLY);
    Tcl_DStringFree(&ds);

}

/*
 *----------------------------------------------------------------------
 *
 * TclpFindVariable --
 *
 *	Locate the entry in environ for a given name.  On Unix this 
 *	routine is case sensetive, on Windows this matches mixed case.
 *
 * Results:
 *	The return value is the index in environ of an entry with the
 *	name "name", or -1 if there is no such entry.   The integer at
 *	*lengthPtr is filled in with the length of name (if a matching
 *	entry is found) or the length of the environ array (if no matching
 *	entry is found).
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
TclpFindVariable(name, lengthPtr)
    CONST char *name;		/* Name of desired environment variable
				 * (native). */
    int *lengthPtr;		/* Used to return length of name (for
				 * successful searches) or number of non-NULL
				 * entries in environ (for unsuccessful
				 * searches). */
{
    int i, result = -1;
    register CONST char *env, *p1, *p2;
    Tcl_DString envString;

    Tcl_DStringInit(&envString);
    for (i = 0, env = environ[i]; env != NULL; i++, env = environ[i]) {
	p1 = Tcl_ExternalToUtfDString(NULL, env, -1, &envString);
	p2 = name;

	for (; *p2 == *p1; p1++, p2++) {
	    /* NULL loop body. */
	}
	if ((*p1 == '=') && (*p2 == '\0')) {
	    *lengthPtr = p2 - name;
	    result = i;
	    goto done;
	}
	
	Tcl_DStringFree(&envString);
    }
    
    *lengthPtr = i;

    done:
    Tcl_DStringFree(&envString);
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_Init --
 *
 *	This procedure is typically invoked by Tcl_AppInit procedures
 *	to find and source the "init.tcl" script, which should exist
 *	somewhere on the Tcl library path.
 *
 * Results:
 *	Returns a standard Tcl completion code and sets the interp's
 *	result if there is an error.
 *
 * Side effects:
 *	Depends on what's in the init.tcl script.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_Init(interp)
    Tcl_Interp *interp;		/* Interpreter to initialize. */
{
    Tcl_Obj *pathPtr;

    if (tclPreInitScript != NULL) {
	if (Tcl_Eval(interp, tclPreInitScript) == TCL_ERROR) {
	    return (TCL_ERROR);
	};
    }
    
    pathPtr = TclGetLibraryPath();
    if (pathPtr == NULL) {
	pathPtr = Tcl_NewObj();
    }
    Tcl_SetVar2Ex(interp, "tcl_libPath", NULL, pathPtr, TCL_GLOBAL_ONLY);
    return Tcl_Eval(interp, initScript);
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_SourceRCFile --
 *
 *	This procedure is typically invoked by Tcl_Main of Tk_Main
 *	procedure to source an application specific rc file into the
 *	interpreter at startup time.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Depends on what's in the rc script.
 *
 *----------------------------------------------------------------------
 */

void
Tcl_SourceRCFile(interp)
    Tcl_Interp *interp;		/* Interpreter to source rc file into. */
{
    Tcl_DString temp;
    CONST char *fileName;
    Tcl_Channel errChannel;

    fileName = Tcl_GetVar(interp, "tcl_rcFileName", TCL_GLOBAL_ONLY);

    if (fileName != NULL) {
        Tcl_Channel c;
	CONST char *fullName;

        Tcl_DStringInit(&temp);
	fullName = Tcl_TranslateFileName(interp, fileName, &temp);
	if (fullName == NULL) {
	    /*
	     * Couldn't translate the file name (e.g. it referred to a
	     * bogus user or there was no HOME environment variable).
	     * Just do nothing.
	     */
	} else {

	    /*
	     * Test for the existence of the rc file before trying to read it.
	     */

            c = Tcl_OpenFileChannel(NULL, fullName, "r", 0);
            if (c != (Tcl_Channel) NULL) {
                Tcl_Close(NULL, c);
		if (Tcl_EvalFile(interp, fullName) != TCL_OK) {
		    errChannel = Tcl_GetStdChannel(TCL_STDERR);
		    if (errChannel) {
			Tcl_WriteObj(errChannel, Tcl_GetObjResult(interp));
			Tcl_WriteChars(errChannel, "\n", 1);
		    }
		}
	    }
	}
        Tcl_DStringFree(&temp);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * TclpCheckStackSpace --
 *
 *	Detect if we are about to blow the stack.  Called before an 
 *	evaluation can happen when nesting depth is checked.
 *
 * Results:
 *	1 if there is enough stack space to continue; 0 if not.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
TclpCheckStackSpace()
{
    /*
     * This function is unimplemented on Unix platforms.
     */

    return 1;
}

#ifdef HAVE_CFBUNDLE
/*
 *----------------------------------------------------------------------
 *
 * Tcl_MacOSXGetLibraryPath --
 *
 *	If we have a bundle structure for the Tcl installation,
 *	then check there first to see if we can find the libraries
 *	there.
 *
 * Results:
 *	TCL_OK if we have found the tcl library; TCL_ERROR otherwise.
 *
 * Side effects:
 *	Same as for Tcl_MacOSXOpenBundleResources.
 *
 *----------------------------------------------------------------------
 */
static int Tcl_MacOSXGetLibraryPath(Tcl_Interp *interp, int maxPathLen, char *tclLibPath)
{
    int foundInFramework = TCL_ERROR;
    if (strcmp(defaultLibraryDir, "@@TCL_IN_FRAMEWORK@@") == 0) {
	foundInFramework = Tcl_MacOSXOpenBundleResources(interp, 
	    "com.tcltk.tcllibrary", 0, maxPathLen, tclLibPath);
    }
    return foundInFramework;
}
#endif /* HAVE_CFBUNDLE */

@


1.4
log
@touched all sources to ease next import
@
text
@d10 1
a10 1
 * RCS: @@(#) $Id: tclUnixInit.c,v 1.6.8.3 2001/06/15 05:19:08 mdejong Exp $
d13 3
d19 3
d38 14
d70 4
a73 1
 * encoding files.
d82 23
d107 1
d142 5
d247 1
a247 1
    char *str;
d250 1
a250 1
    char **pathv;
d262 5
d268 1
a268 5
    /* CYGNUS LOCAL */
    sprintf(installLib, "share/tcl%s", TCL_VERSION);
    /* END CYGNUS LOCAL */
    sprintf(developLib, "tcl%s/library",
	    ((TCL_RELEASE_LEVEL < 2) ? TCL_PATCH_LEVEL : TCL_VERSION));
d325 1
a325 1
     *		(e.g. /usr/local/bin/../lib/tcl8.2)
d327 1
a327 1
     *		(e.g. /usr/local/TclPro/solaris-sparc/bin/../../lib/tcl8.2)
d329 1
a329 1
     *		(e.g. /usr/src/tcl8.2/unix/../library)
d331 1
a331 1
     *		(e.g. /usr/src/tcl8.2/unix/solaris-sparc/../../library)
d333 3
a335 3
     *		(e.g. /usr/src/tcl8.2/unix/../../tcl8.2/library)
     *	<bindir>/../../../<devlopLib>
     *		(e.g. /usr/src/tcl8.2/unix/solaris-sparc/../../../tcl8.2/library)
d338 6
d346 2
a347 1
	if (pathc > 1) {
d350 1
d355 2
a356 1
	if (pathc > 2) {
d359 1
d364 2
a365 1
	if (pathc > 1) {
d368 1
d373 2
a374 1
	if (pathc > 2) {
d377 1
d382 2
a383 1
	if (pathc > 1) {
d386 1
d391 2
a392 1
	if (pathc > 3) {
d395 1
d409 11
a419 1
    str = defaultLibraryDir;
d424 1
d438 4
a441 1
 *	Called at process initialization time.
d447 3
a449 1
 *	The Tcl library path is converted from native encoding to UTF-8.
d457 4
a460 4
    CONST char *encoding;
    int i;
    Tcl_Obj *pathPtr;
    char *langEnv;
d462 8
a469 5
    /*
     * Determine the current encoding from the LC_* or LANG environment
     * variables.  We previously used setlocale() to determine the locale,
     * but this does not work on some systems (e.g. Linux/i386 RH 5.0).
     */
d471 4
a474 1
    langEnv = getenv("LC_ALL");
d476 2
a477 9
    if (langEnv == NULL || langEnv[0] == '\0') {
	langEnv = getenv("LC_CTYPE");
    }
    if (langEnv == NULL || langEnv[0] == '\0') {
	langEnv = getenv("LANG");
    }
    if (langEnv == NULL || langEnv[0] == '\0') {
	langEnv = NULL;
    }
d479 42
a520 6
    encoding = NULL;
    if (langEnv != NULL) {
	for (i = 0; localeTable[i].lang != NULL; i++) {
	    if (strcmp(localeTable[i].lang, langEnv) == 0) {
		encoding = localeTable[i].encoding;
		break;
d522 8
d531 10
a540 4
	/*
	 * There was no mapping in the locale table.  If there is an
	 * encoding subfield, we can try to guess from that.
	 */
d542 8
a549 7
	if (encoding == NULL) {
	    char *p;
	    for (p = langEnv; *p != '\0'; p++) {
		if (*p == '.') {
		    p++;
		    break;
		}
a550 4
	    if (*p != '\0') {
		Tcl_DString ds;
		Tcl_DStringInit(&ds);
		Tcl_DStringAppend(&ds, p, -1);
d552 6
a557 5
		encoding = Tcl_DStringValue(&ds);
		Tcl_UtfToLower(Tcl_DStringValue(&ds));
		if (Tcl_SetSystemEncoding(NULL, encoding) == TCL_OK) {
		    Tcl_DStringFree(&ds);
		    goto resetPath;
d559 30
a588 2
		Tcl_DStringFree(&ds);
		encoding = NULL;
d590 4
a593 5
	}
    }
    if (encoding == NULL) {
	encoding = "iso8859-1";
    }
d595 2
a596 1
    Tcl_SetSystemEncoding(NULL, encoding);
d598 13
a610 9
    resetPath:
    /*
     * Initialize the C library's locale subsystem.  This is required
     * for input methods to work properly on X11.  We only do this for
     * LC_CTYPE because that's the necessary one, and we don't want to
     * affect LC_TIME here.  The side effect of setting the default locale
     * should be to load any locale specific modules that are needed by X.
     * [BUG: 5422 3345 4236 2522 2521].
     */
d612 6
a617 1
    setlocale(LC_CTYPE, "");
d619 1
a619 6
    /*
     * In case the initial locale is not "C", ensure that the numeric
     * processing is done in "C" locale regardless.  This is needed because
     * Tcl relies on routines like strtod, but should not have locale
     * dependent behavior.
     */
d621 21
a641 1
    setlocale(LC_NUMERIC, "C");
d643 11
a653 21
    /*
     * Until the system encoding was actually set, the library path was
     * actually in the native multi-byte encoding, and not really UTF-8
     * as advertised.  We cheated as follows:
     *
     * 1. It was safe to allow the Tcl_SetSystemEncoding() call to 
     * append the ASCII chars that make up the encoding's filename to 
     * the names (in the native encoding) of directories in the library 
     * path, since all Unix multi-byte encodings have ASCII in the
     * beginning.
     *
     * 2. To open the encoding file, the native bytes in the file name
     * were passed to the OS, without translating from UTF-8 to native,
     * because the name was already in the native encoding.
     *
     * Now that the system encoding was actually successfully set,
     * translate all the names in the library path to UTF-8.  That way,
     * next time we search the library path, we'll translate the names 
     * from UTF-8 to the system encoding which will be the native 
     * encoding.
     */
d655 7
a661 11
    pathPtr = TclGetLibraryPath();
    if (pathPtr != NULL) {
	int objc;
	Tcl_Obj **objv;
	
	objc = 0;
	Tcl_ListObjGetElements(NULL, pathPtr, &objc, &objv);
	for (i = 0; i < objc; i++) {
	    int length;
	    char *string;
	    Tcl_DString ds;
d663 10
a672 6
	    string = Tcl_GetStringFromObj(objv[i], &length);
	    Tcl_ExternalToUtfDString(NULL, string, length, &ds);
	    Tcl_SetStringObj(objv[i], Tcl_DStringValue(&ds), 
		    Tcl_DStringLength(&ds));
	    Tcl_DStringFree(&ds);
	}
a673 7

    /*
     * Keep the iso8859-1 encoding preloaded.  The IO package uses it for
     * gets on a binary channel.
     */

    Tcl_GetEncoding(NULL, "iso8859-1");
d703 1
a703 1
    char *user;
d706 68
a773 2
    Tcl_SetVar(interp, "tclDefaultLibrary", defaultLibraryDir, TCL_GLOBAL_ONLY);
    Tcl_SetVar(interp, "tcl_pkgPath", pkgPath, TCL_GLOBAL_ONLY);
d775 1
d779 1
a779 1
	char *native;
d954 1
a954 1
    char *fileName;
d961 1
a961 1
	char *fullName;
d1019 29
@


1.3
log
@touched all sources to ease next import
@
text
@@


1.3.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d10 1
a10 1
 * RCS: @@(#) $Id: tclUnixInit.c,v 1.34 2002/10/22 16:41:28 das Exp $
a12 3
#if defined(HAVE_CFBUNDLE)
#include <CoreFoundation/CoreFoundation.h>
#endif
a15 3
#ifdef HAVE_LANGINFO
#include <langinfo.h>
#endif
a31 14
/* Used to store the encoding used for binary files */
static Tcl_Encoding binaryEncoding = NULL;
/* Has the basic library path encoding issue been fixed */
static int libraryPathEncodingFixed = 0;

/*
 * Tcl tries to use standard and homebrew methods to guess the right
 * encoding on the platform.  However, there is always a final fallback,
 * and this value is it.  Make sure it is a real Tcl encoding.
 */

#ifndef TCL_DEFAULT_ENCODING
#define TCL_DEFAULT_ENCODING "iso8859-1"
#endif
d50 1
a50 4
 * encoding files.  If HAVE_LANGINFO is defined, then this is a fallback
 * table when the result from nl_langinfo isn't a recognized encoding.
 * Otherwise this is the first list checked for a mapping from env
 * encoding to Tcl encoding name.
a58 23
#ifdef HAVE_LANGINFO
    {"gb2312-1980",	"gb2312"},
#ifdef __hpux
    {"SJIS",		"shiftjis"},
    {"eucjp",		"euc-jp"},
    {"euckr",		"euc-kr"},
    {"euctw",		"euc-cn"},
    {"greek8",		"cp869"},
    {"iso88591",	"iso8859-1"},
    {"iso88592",	"iso8859-2"},
    {"iso88595",	"iso8859-5"},
    {"iso88596",	"iso8859-6"},
    {"iso88597",	"iso8859-7"},
    {"iso88598",	"iso8859-8"},
    {"iso88599",	"iso8859-9"},
    {"iso885915",	"iso8859-15"},
    {"roman8",		"iso8859-1"},
    {"tis620",		"tis-620"},
    {"turkish8",	"cp857"},
    {"utf8",		"utf-8"},
#endif /* __hpux */
#endif /* HAVE_LANGINFO */

a60 1
    {"ja_JP.eucJP",     "euc-jp"},
a94 5

#ifdef HAVE_CFBUNDLE
static int Tcl_MacOSXGetLibraryPath(Tcl_Interp *interp, int maxPathLen, char *tclLibPath);
#endif /* HAVE_CFBUNDLE */

d195 1
a195 1
    CONST char *str;
d198 1
a198 1
    CONST char **pathv;
d210 2
a211 2
     
    /* REDHAT LOCAL */
d213 3
a215 4
    /* sprintf(installLib, "lib/tcl%s", TCL_VERSION); */
    /* END REDHAT LOCAL */

    sprintf(developLib, "tcl%s/library", TCL_PATCH_LEVEL);
d272 1
a272 1
     *	  (e.g. /usr/local/bin/../lib/tcl8.4)
d274 1
a274 1
     *	  (e.g. /usr/local/TclPro/solaris-sparc/bin/../../lib/tcl8.4)
d276 1
a276 1
     *	  (e.g. /usr/src/tcl8.4.0/unix/../library)
d278 1
a278 1
     *	  (e.g. /usr/src/tcl8.4.0/unix/solaris-sparc/../../library)
d280 3
a282 3
     *	  (e.g. /usr/src/tcl8.4.0/unix/../../tcl8.4.0/library)
     *	<bindir>/../../../<developLib>
     *	  (e.g. /usr/src/tcl8.4.0/unix/solaris-sparc/../../../tcl8.4.0/library)
a284 6

     /*
      * The variable path holds an absolute path.  Take care not to
      * overwrite pathv[0] since that might produce a relative path.
      */

d287 1
a287 2
	if (pathc > 2) {
	    str = pathv[pathc - 2];
a289 1
	    pathv[pathc - 2] = str;
d294 1
a294 2
	if (pathc > 3) {
	    str = pathv[pathc - 3];
a296 1
	    pathv[pathc - 3] = str;
d301 1
a301 2
	if (pathc > 2) {
	    str = pathv[pathc - 2];
a303 1
	    pathv[pathc - 2] = str;
d308 1
a308 2
	if (pathc > 3) {
	    str = pathv[pathc - 3];
a310 1
	    pathv[pathc - 3] = str;
d315 1
a315 2
	if (pathc > 3) {
	    str = pathv[pathc - 3];
a317 1
	    pathv[pathc - 3] = str;
d322 1
a322 2
	if (pathc > 4) {
	    str = pathv[pathc - 4];
a324 1
	    pathv[pathc - 4] = str;
d338 1
a338 11
    {
#ifdef HAVE_CFBUNDLE
    char tclLibPath[MAXPATHLEN + 1];
    
    if (Tcl_MacOSXGetLibraryPath(NULL, MAXPATHLEN, tclLibPath) == TCL_OK) {
        str = tclLibPath;
    } else
#endif /* HAVE_CFBUNDLE */
    {
        str = defaultLibraryDir;
    }
a342 1
    }
d356 1
a356 4
 *	Called at process initialization time, and part way through
 *	startup, we verify that the initial encodings were correctly
 *	setup.  Depending on Tcl's environment, there may not have been
 *	enough information first time through (above).
d362 1
a362 3
 *	The Tcl library path is converted from native encoding to UTF-8,
 *	on the first call, and the encodings may be changed on first or
 *	second call.
d370 4
a373 4
    if (libraryPathEncodingFixed == 0) {
	CONST char *encoding = NULL;
	int i, setSysEncCode = TCL_ERROR;
	Tcl_Obj *pathPtr;
d375 5
a379 8
	/*
	 * Determine the current encoding from the LC_* or LANG environment
	 * variables.  We previously used setlocale() to determine the locale,
	 * but this does not work on some systems (e.g. Linux/i386 RH 5.0).
	 */
#ifdef HAVE_LANGINFO
	if (setlocale(LC_CTYPE, "") != NULL) {
	    Tcl_DString ds;
d381 1
a381 4
	    /*
	     * Use a DString so we can overwrite it in name compatability
	     * checks below.
	     */
d383 9
a391 2
	    Tcl_DStringInit(&ds);
	    encoding = Tcl_DStringAppend(&ds, nl_langinfo(CODESET), -1);
d393 6
a398 42
	    Tcl_UtfToLower(Tcl_DStringValue(&ds));
#ifdef HAVE_LANGINFO_DEBUG
	    fprintf(stderr, "encoding '%s'", encoding);
#endif
	    if (encoding[0] == 'i' && encoding[1] == 's' && encoding[2] == 'o'
		    && encoding[3] == '-') {
		char *p, *q;
		/* need to strip '-' from iso-* encoding */
		for(p = Tcl_DStringValue(&ds)+3, q = Tcl_DStringValue(&ds)+4;
		    *p; *p++ = *q++);
	    } else if (encoding[0] == 'i' && encoding[1] == 'b'
		    && encoding[2] == 'm' && encoding[3] >= '0'
		    && encoding[3] <= '9') {
		char *p, *q;
		/* if langinfo reports "ibm*" we should use "cp*" */
		p = Tcl_DStringValue(&ds);
		*p++ = 'c'; *p++ = 'p';
		for(q = p+1; *p ; *p++ = *q++);
	    } else if ((*encoding == '\0')
		    || !strcmp(encoding, "ansi_x3.4-1968")) {
		/* Use iso8859-1 for empty or 'ansi_x3.4-1968' encoding */
		encoding = "iso8859-1";
	    }
#ifdef HAVE_LANGINFO_DEBUG
	    fprintf(stderr, " ?%s?", encoding);
#endif
	    setSysEncCode = Tcl_SetSystemEncoding(NULL, encoding);
	    if (setSysEncCode != TCL_OK) {
		/*
		 * If this doesn't return TCL_OK, the encoding returned by
		 * nl_langinfo or as we translated it wasn't accepted.  Do
		 * this fallback check.  If this fails, we will enter the
		 * old fallback below.
		 */

		for (i = 0; localeTable[i].lang != NULL; i++) {
		    if (strcmp(localeTable[i].lang, encoding) == 0) {
			setSysEncCode = Tcl_SetSystemEncoding(NULL,
				localeTable[i].encoding);
			break;
		    }
		}
a399 4
#ifdef HAVE_LANGINFO_DEBUG
	    fprintf(stderr, " => '%s'\n", encoding);
#endif
	    Tcl_DStringFree(&ds);
d401 4
a404 6
#ifdef HAVE_LANGINFO_DEBUG
	else {
	    fprintf(stderr, "setlocale returned NULL\n");
	}
#endif
#endif /* HAVE_LANGINFO */
d406 7
a412 16
	if (setSysEncCode != TCL_OK) {
	    /*
	     * Classic fallback check.  This tries a homebrew algorithm to
	     * determine what encoding should be used based on env vars.
	     */
	    char *langEnv = getenv("LC_ALL");
	    encoding = NULL;

	    if (langEnv == NULL || langEnv[0] == '\0') {
		langEnv = getenv("LC_CTYPE");
	    }
	    if (langEnv == NULL || langEnv[0] == '\0') {
		langEnv = getenv("LANG");
	    }
	    if (langEnv == NULL || langEnv[0] == '\0') {
		langEnv = NULL;
d414 4
d419 5
a423 6
	    if (langEnv != NULL) {
		for (i = 0; localeTable[i].lang != NULL; i++) {
		    if (strcmp(localeTable[i].lang, langEnv) == 0) {
			encoding = localeTable[i].encoding;
			break;
		    }
d425 2
a426 30
		/*
		 * There was no mapping in the locale table.  If there is an
		 * encoding subfield, we can try to guess from that.
		 */

		if (encoding == NULL) {
		    char *p;
		    for (p = langEnv; *p != '\0'; p++) {
			if (*p == '.') {
			    p++;
			    break;
			}
		    }
		    if (*p != '\0') {
			Tcl_DString ds;
			Tcl_DStringInit(&ds);
			encoding = Tcl_DStringAppend(&ds, p, -1);

			Tcl_UtfToLower(Tcl_DStringValue(&ds));
			setSysEncCode = Tcl_SetSystemEncoding(NULL, encoding);
			if (setSysEncCode != TCL_OK) {
			    encoding = NULL;
			}
			Tcl_DStringFree(&ds);
		    }
		}
#ifdef HAVE_LANGINFO_DEBUG
		fprintf(stderr, "encoding fallback check '%s' => '%s'\n",
			langEnv, encoding);
#endif
d428 7
a434 4
	    if (setSysEncCode != TCL_OK) {
		if (encoding == NULL) {
		    encoding = TCL_DEFAULT_ENCODING;
		}
d436 9
a444 2
		Tcl_SetSystemEncoding(NULL, encoding);
	    }
d446 1
a446 13
	    /*
	     * Initialize the C library's locale subsystem.  This is required
	     * for input methods to work properly on X11.  We only do this for
	     * LC_CTYPE because that's the necessary one, and we don't want to
	     * affect LC_TIME here.  The side effect of setting the default
	     * locale should be to load any locale specific modules that are
	     * needed by X.  [BUG: 5422 3345 4236 2522 2521].
	     * In HAVE_LANGINFO, this call is already done above.
	     */
#ifndef HAVE_LANGINFO
	    setlocale(LC_CTYPE, "");
#endif
	}
d448 6
a453 6
	/*
	 * In case the initial locale is not "C", ensure that the numeric
	 * processing is done in "C" locale regardless.  This is needed because
	 * Tcl relies on routines like strtod, but should not have locale
	 * dependent behavior.
	 */
d455 1
a455 1
	setlocale(LC_NUMERIC, "C");
d457 21
a477 21
	/*
	 * Until the system encoding was actually set, the library path was
	 * actually in the native multi-byte encoding, and not really UTF-8
	 * as advertised.  We cheated as follows:
	 *
	 * 1. It was safe to allow the Tcl_SetSystemEncoding() call to 
	 * append the ASCII chars that make up the encoding's filename to 
	 * the names (in the native encoding) of directories in the library 
	 * path, since all Unix multi-byte encodings have ASCII in the
	 * beginning.
	 *
	 * 2. To open the encoding file, the native bytes in the file name
	 * were passed to the OS, without translating from UTF-8 to native,
	 * because the name was already in the native encoding.
	 *
	 * Now that the system encoding was actually successfully set,
	 * translate all the names in the library path to UTF-8.  That way,
	 * next time we search the library path, we'll translate the names 
	 * from UTF-8 to the system encoding which will be the native 
	 * encoding.
	 */
d479 11
a489 11
	pathPtr = TclGetLibraryPath();
	if (pathPtr != NULL) {
	    int objc;
	    Tcl_Obj **objv;
	    
	    objc = 0;
	    Tcl_ListObjGetElements(NULL, pathPtr, &objc, &objv);
	    for (i = 0; i < objc; i++) {
		int length;
		char *string;
		Tcl_DString ds;
d491 5
a495 6
		string = Tcl_GetStringFromObj(objv[i], &length);
		Tcl_ExternalToUtfDString(NULL, string, length, &ds);
		Tcl_SetStringObj(objv[i], Tcl_DStringValue(&ds), 
			Tcl_DStringLength(&ds));
		Tcl_DStringFree(&ds);
	    }
d497 6
d504 1
a504 11
	libraryPathEncodingFixed = 1;
    }
    
    /* This is only ever called from the startup thread */
    if (binaryEncoding == NULL) {
	/*
	 * Keep the iso8859-1 encoding preloaded.  The IO package uses
	 * it for gets on a binary channel.
	 */
	binaryEncoding = Tcl_GetEncoding(NULL, "iso8859-1");
    }
d534 1
a534 1
    CONST char *user;
d537 2
a538 68
#ifdef HAVE_CFBUNDLE
    char tclLibPath[MAXPATHLEN + 1];
    
    if (Tcl_MacOSXGetLibraryPath(interp, MAXPATHLEN, tclLibPath) == TCL_OK) {
        CONST char *str;
        Tcl_DString ds;
        CFBundleRef bundleRef;

        Tcl_SetVar(interp, "tclDefaultLibrary", tclLibPath, 
                TCL_GLOBAL_ONLY);
        Tcl_SetVar(interp, "tcl_pkgPath", tclLibPath,
                TCL_GLOBAL_ONLY);
        Tcl_SetVar(interp, "tcl_pkgPath", " ",
                TCL_GLOBAL_ONLY | TCL_APPEND_VALUE);
        str = TclGetEnv("DYLD_FRAMEWORK_PATH", &ds);
        if ((str != NULL) && (str[0] != '\0')) {
            char *p = Tcl_DStringValue(&ds);
            /* convert DYLD_FRAMEWORK_PATH from colon to space separated */
            do {
                if(*p == ':') *p = ' ';
            } while (*p++);
            Tcl_SetVar(interp, "tcl_pkgPath", Tcl_DStringValue(&ds),
                    TCL_GLOBAL_ONLY | TCL_APPEND_VALUE);
            Tcl_SetVar(interp, "tcl_pkgPath", " ",
                    TCL_GLOBAL_ONLY | TCL_APPEND_VALUE);
            Tcl_DStringFree(&ds);
        }
        if ((bundleRef = CFBundleGetMainBundle())) {
            CFURLRef frameworksURL;
            Tcl_StatBuf statBuf;
            if((frameworksURL = CFBundleCopyPrivateFrameworksURL(bundleRef))) {
                if(CFURLGetFileSystemRepresentation(frameworksURL, TRUE,
                            tclLibPath, MAXPATHLEN) &&
                        ! TclOSstat(tclLibPath, &statBuf) &&
                        S_ISDIR(statBuf.st_mode)) {
                    Tcl_SetVar(interp, "tcl_pkgPath", tclLibPath,
                            TCL_GLOBAL_ONLY | TCL_APPEND_VALUE);
                    Tcl_SetVar(interp, "tcl_pkgPath", " ",
                            TCL_GLOBAL_ONLY | TCL_APPEND_VALUE);
                }
                CFRelease(frameworksURL);
            }
            if((frameworksURL = CFBundleCopySharedFrameworksURL(bundleRef))) {
                if(CFURLGetFileSystemRepresentation(frameworksURL, TRUE,
                            tclLibPath, MAXPATHLEN) &&
                        ! TclOSstat(tclLibPath, &statBuf) &&
                        S_ISDIR(statBuf.st_mode)) {
                    Tcl_SetVar(interp, "tcl_pkgPath", tclLibPath,
                            TCL_GLOBAL_ONLY | TCL_APPEND_VALUE);
                    Tcl_SetVar(interp, "tcl_pkgPath", " ",
                            TCL_GLOBAL_ONLY | TCL_APPEND_VALUE);
                }
                CFRelease(frameworksURL);
            }
        }
        Tcl_SetVar(interp, "tcl_pkgPath", pkgPath,
                TCL_GLOBAL_ONLY | TCL_APPEND_VALUE);
    } else
#endif /* HAVE_CFBUNDLE */
    {
        Tcl_SetVar(interp, "tclDefaultLibrary", defaultLibraryDir, 
                TCL_GLOBAL_ONLY);
        Tcl_SetVar(interp, "tcl_pkgPath", pkgPath, TCL_GLOBAL_ONLY);
    }

#ifdef DJGPP
    Tcl_SetVar2(interp, "tcl_platform", "platform", "dos", TCL_GLOBAL_ONLY);
#else
a539 1
#endif
d543 1
a543 1
	CONST char *native;
d718 1
a718 1
    CONST char *fileName;
d725 1
a725 1
	CONST char *fullName;
a782 29

#ifdef HAVE_CFBUNDLE
/*
 *----------------------------------------------------------------------
 *
 * Tcl_MacOSXGetLibraryPath --
 *
 *	If we have a bundle structure for the Tcl installation,
 *	then check there first to see if we can find the libraries
 *	there.
 *
 * Results:
 *	TCL_OK if we have found the tcl library; TCL_ERROR otherwise.
 *
 * Side effects:
 *	Same as for Tcl_MacOSXOpenBundleResources.
 *
 *----------------------------------------------------------------------
 */
static int Tcl_MacOSXGetLibraryPath(Tcl_Interp *interp, int maxPathLen, char *tclLibPath)
{
    int foundInFramework = TCL_ERROR;
    if (strcmp(defaultLibraryDir, "@@TCL_IN_FRAMEWORK@@") == 0) {
	foundInFramework = Tcl_MacOSXOpenBundleResources(interp, 
	    "com.tcltk.tcllibrary", 0, maxPathLen, tclLibPath);
    }
    return foundInFramework;
}
#endif /* HAVE_CFBUNDLE */
@


1.3.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@d10 1
a10 1
 * RCS: @@(#) $Id: tclUnixInit.c,v 1.33 2002/09/02 19:27:42 hobbs Exp $
a12 3
#if defined(HAVE_CFBUNDLE)
#include <CoreFoundation/CoreFoundation.h>
#endif
a15 3
#ifdef HAVE_LANGINFO
#include <langinfo.h>
#endif
a31 14
/* Used to store the encoding used for binary files */
static Tcl_Encoding binaryEncoding = NULL;
/* Has the basic library path encoding issue been fixed */
static int libraryPathEncodingFixed = 0;

/*
 * Tcl tries to use standard and homebrew methods to guess the right
 * encoding on the platform.  However, there is always a final fallback,
 * and this value is it.  Make sure it is a real Tcl encoding.
 */

#ifndef TCL_DEFAULT_ENCODING
#define TCL_DEFAULT_ENCODING "iso8859-1"
#endif
d50 1
a50 4
 * encoding files.  If HAVE_LANGINFO is defined, then this is a fallback
 * table when the result from nl_langinfo isn't a recognized encoding.
 * Otherwise this is the first list checked for a mapping from env
 * encoding to Tcl encoding name.
a58 23
#ifdef HAVE_LANGINFO
    {"gb2312-1980",	"gb2312"},
#ifdef __hpux
    {"SJIS",		"shiftjis"},
    {"eucjp",		"euc-jp"},
    {"euckr",		"euc-kr"},
    {"euctw",		"euc-cn"},
    {"greek8",		"cp869"},
    {"iso88591",	"iso8859-1"},
    {"iso88592",	"iso8859-2"},
    {"iso88595",	"iso8859-5"},
    {"iso88596",	"iso8859-6"},
    {"iso88597",	"iso8859-7"},
    {"iso88598",	"iso8859-8"},
    {"iso88599",	"iso8859-9"},
    {"iso885915",	"iso8859-15"},
    {"roman8",		"iso8859-1"},
    {"tis620",		"tis-620"},
    {"turkish8",	"cp857"},
    {"utf8",		"utf-8"},
#endif /* __hpux */
#endif /* HAVE_LANGINFO */

a60 1
    {"ja_JP.eucJP",     "euc-jp"},
a94 5

#ifdef HAVE_CFBUNDLE
static int Tcl_MacOSXGetLibraryPath(Tcl_Interp *interp, int maxPathLen, char *tclLibPath);
#endif /* HAVE_CFBUNDLE */

d195 1
a195 1
    CONST char *str;
d198 1
a198 1
    CONST char **pathv;
d210 6
a215 3
     
    sprintf(installLib, "lib/tcl%s", TCL_VERSION);
    sprintf(developLib, "tcl%s/library", TCL_PATCH_LEVEL);
d272 1
a272 1
     *	  (e.g. /usr/local/bin/../lib/tcl8.4)
d274 1
a274 1
     *	  (e.g. /usr/local/TclPro/solaris-sparc/bin/../../lib/tcl8.4)
d276 1
a276 1
     *	  (e.g. /usr/src/tcl8.4.0/unix/../library)
d278 1
a278 1
     *	  (e.g. /usr/src/tcl8.4.0/unix/solaris-sparc/../../library)
d280 3
a282 3
     *	  (e.g. /usr/src/tcl8.4.0/unix/../../tcl8.4.0/library)
     *	<bindir>/../../../<developLib>
     *	  (e.g. /usr/src/tcl8.4.0/unix/solaris-sparc/../../../tcl8.4.0/library)
a284 6

     /*
      * The variable path holds an absolute path.  Take care not to
      * overwrite pathv[0] since that might produce a relative path.
      */

d287 1
a287 2
	if (pathc > 2) {
	    str = pathv[pathc - 2];
a289 1
	    pathv[pathc - 2] = str;
d294 1
a294 2
	if (pathc > 3) {
	    str = pathv[pathc - 3];
a296 1
	    pathv[pathc - 3] = str;
d301 1
a301 2
	if (pathc > 2) {
	    str = pathv[pathc - 2];
a303 1
	    pathv[pathc - 2] = str;
d308 1
a308 2
	if (pathc > 3) {
	    str = pathv[pathc - 3];
a310 1
	    pathv[pathc - 3] = str;
d315 1
a315 2
	if (pathc > 3) {
	    str = pathv[pathc - 3];
a317 1
	    pathv[pathc - 3] = str;
d322 1
a322 2
	if (pathc > 4) {
	    str = pathv[pathc - 4];
a324 1
	    pathv[pathc - 4] = str;
d338 1
a338 11
    {
#ifdef HAVE_CFBUNDLE
    char tclLibPath[1024];
    
    if (Tcl_MacOSXGetLibraryPath(NULL, 1024, tclLibPath) == TCL_OK) {
        str = tclLibPath;
    } else
#endif /* HAVE_CFBUNDLE */
    {
        str = defaultLibraryDir;
    }
a342 1
    }
d356 1
a356 4
 *	Called at process initialization time, and part way through
 *	startup, we verify that the initial encodings were correctly
 *	setup.  Depending on Tcl's environment, there may not have been
 *	enough information first time through (above).
d362 1
a362 3
 *	The Tcl library path is converted from native encoding to UTF-8,
 *	on the first call, and the encodings may be changed on first or
 *	second call.
d370 4
a373 4
    if (libraryPathEncodingFixed == 0) {
	CONST char *encoding = NULL;
	int i, setSysEncCode = TCL_ERROR;
	Tcl_Obj *pathPtr;
d375 5
a379 8
	/*
	 * Determine the current encoding from the LC_* or LANG environment
	 * variables.  We previously used setlocale() to determine the locale,
	 * but this does not work on some systems (e.g. Linux/i386 RH 5.0).
	 */
#ifdef HAVE_LANGINFO
	if (setlocale(LC_CTYPE, "") != NULL) {
	    Tcl_DString ds;
d381 1
a381 4
	    /*
	     * Use a DString so we can overwrite it in name compatability
	     * checks below.
	     */
d383 9
a391 2
	    Tcl_DStringInit(&ds);
	    encoding = Tcl_DStringAppend(&ds, nl_langinfo(CODESET), -1);
d393 6
a398 22
	    Tcl_UtfToLower(Tcl_DStringValue(&ds));
#ifdef HAVE_LANGINFO_DEBUG
	    fprintf(stderr, "encoding '%s'", encoding);
#endif
	    if (encoding[0] == 'i' && encoding[1] == 's' && encoding[2] == 'o'
		    && encoding[3] == '-') {
		char *p, *q;
		/* need to strip '-' from iso-* encoding */
		for(p = Tcl_DStringValue(&ds)+3, q = Tcl_DStringValue(&ds)+4;
		    *p; *p++ = *q++);
	    } else if (encoding[0] == 'i' && encoding[1] == 'b'
		    && encoding[2] == 'm' && encoding[3] >= '0'
		    && encoding[3] <= '9') {
		char *p, *q;
		/* if langinfo reports "ibm*" we should use "cp*" */
		p = Tcl_DStringValue(&ds);
		*p++ = 'c'; *p++ = 'p';
		for(q = p+1; *p ; *p++ = *q++);
	    } else if ((*encoding == '\0')
		    || !strcmp(encoding, "ansi_x3.4-1968")) {
		/* Use iso8859-1 for empty or 'ansi_x3.4-1968' encoding */
		encoding = "iso8859-1";
a399 24
#ifdef HAVE_LANGINFO_DEBUG
	    fprintf(stderr, " ?%s?", encoding);
#endif
	    setSysEncCode = Tcl_SetSystemEncoding(NULL, encoding);
	    if (setSysEncCode != TCL_OK) {
		/*
		 * If this doesn't return TCL_OK, the encoding returned by
		 * nl_langinfo or as we translated it wasn't accepted.  Do
		 * this fallback check.  If this fails, we will enter the
		 * old fallback below.
		 */

		for (i = 0; localeTable[i].lang != NULL; i++) {
		    if (strcmp(localeTable[i].lang, encoding) == 0) {
			setSysEncCode = Tcl_SetSystemEncoding(NULL,
				localeTable[i].encoding);
			break;
		    }
		}
	    }
#ifdef HAVE_LANGINFO_DEBUG
	    fprintf(stderr, " => '%s'\n", encoding);
#endif
	    Tcl_DStringFree(&ds);
d401 4
a404 6
#ifdef HAVE_LANGINFO_DEBUG
	else {
	    fprintf(stderr, "setlocale returned NULL\n");
	}
#endif
#endif /* HAVE_LANGINFO */
d406 7
a412 16
	if (setSysEncCode != TCL_OK) {
	    /*
	     * Classic fallback check.  This tries a homebrew algorithm to
	     * determine what encoding should be used based on env vars.
	     */
	    char *langEnv = getenv("LC_ALL");
	    encoding = NULL;

	    if (langEnv == NULL || langEnv[0] == '\0') {
		langEnv = getenv("LC_CTYPE");
	    }
	    if (langEnv == NULL || langEnv[0] == '\0') {
		langEnv = getenv("LANG");
	    }
	    if (langEnv == NULL || langEnv[0] == '\0') {
		langEnv = NULL;
d414 4
d419 5
a423 6
	    if (langEnv != NULL) {
		for (i = 0; localeTable[i].lang != NULL; i++) {
		    if (strcmp(localeTable[i].lang, langEnv) == 0) {
			encoding = localeTable[i].encoding;
			break;
		    }
d425 2
a426 30
		/*
		 * There was no mapping in the locale table.  If there is an
		 * encoding subfield, we can try to guess from that.
		 */

		if (encoding == NULL) {
		    char *p;
		    for (p = langEnv; *p != '\0'; p++) {
			if (*p == '.') {
			    p++;
			    break;
			}
		    }
		    if (*p != '\0') {
			Tcl_DString ds;
			Tcl_DStringInit(&ds);
			encoding = Tcl_DStringAppend(&ds, p, -1);

			Tcl_UtfToLower(Tcl_DStringValue(&ds));
			setSysEncCode = Tcl_SetSystemEncoding(NULL, encoding);
			if (setSysEncCode != TCL_OK) {
			    encoding = NULL;
			}
			Tcl_DStringFree(&ds);
		    }
		}
#ifdef HAVE_LANGINFO_DEBUG
		fprintf(stderr, "encoding fallback check '%s' => '%s'\n",
			langEnv, encoding);
#endif
d428 7
a434 4
	    if (setSysEncCode != TCL_OK) {
		if (encoding == NULL) {
		    encoding = TCL_DEFAULT_ENCODING;
		}
d436 9
a444 2
		Tcl_SetSystemEncoding(NULL, encoding);
	    }
d446 1
a446 13
	    /*
	     * Initialize the C library's locale subsystem.  This is required
	     * for input methods to work properly on X11.  We only do this for
	     * LC_CTYPE because that's the necessary one, and we don't want to
	     * affect LC_TIME here.  The side effect of setting the default
	     * locale should be to load any locale specific modules that are
	     * needed by X.  [BUG: 5422 3345 4236 2522 2521].
	     * In HAVE_LANGINFO, this call is already done above.
	     */
#ifndef HAVE_LANGINFO
	    setlocale(LC_CTYPE, "");
#endif
	}
d448 6
a453 6
	/*
	 * In case the initial locale is not "C", ensure that the numeric
	 * processing is done in "C" locale regardless.  This is needed because
	 * Tcl relies on routines like strtod, but should not have locale
	 * dependent behavior.
	 */
d455 1
a455 1
	setlocale(LC_NUMERIC, "C");
d457 21
a477 21
	/*
	 * Until the system encoding was actually set, the library path was
	 * actually in the native multi-byte encoding, and not really UTF-8
	 * as advertised.  We cheated as follows:
	 *
	 * 1. It was safe to allow the Tcl_SetSystemEncoding() call to 
	 * append the ASCII chars that make up the encoding's filename to 
	 * the names (in the native encoding) of directories in the library 
	 * path, since all Unix multi-byte encodings have ASCII in the
	 * beginning.
	 *
	 * 2. To open the encoding file, the native bytes in the file name
	 * were passed to the OS, without translating from UTF-8 to native,
	 * because the name was already in the native encoding.
	 *
	 * Now that the system encoding was actually successfully set,
	 * translate all the names in the library path to UTF-8.  That way,
	 * next time we search the library path, we'll translate the names 
	 * from UTF-8 to the system encoding which will be the native 
	 * encoding.
	 */
d479 11
a489 11
	pathPtr = TclGetLibraryPath();
	if (pathPtr != NULL) {
	    int objc;
	    Tcl_Obj **objv;
	    
	    objc = 0;
	    Tcl_ListObjGetElements(NULL, pathPtr, &objc, &objv);
	    for (i = 0; i < objc; i++) {
		int length;
		char *string;
		Tcl_DString ds;
d491 5
a495 6
		string = Tcl_GetStringFromObj(objv[i], &length);
		Tcl_ExternalToUtfDString(NULL, string, length, &ds);
		Tcl_SetStringObj(objv[i], Tcl_DStringValue(&ds), 
			Tcl_DStringLength(&ds));
		Tcl_DStringFree(&ds);
	    }
d497 6
d504 1
a504 11
	libraryPathEncodingFixed = 1;
    }
    
    /* This is only ever called from the startup thread */
    if (binaryEncoding == NULL) {
	/*
	 * Keep the iso8859-1 encoding preloaded.  The IO package uses
	 * it for gets on a binary channel.
	 */
	binaryEncoding = Tcl_GetEncoding(NULL, "iso8859-1");
    }
d534 1
a534 1
    CONST char *user;
d537 2
a538 23
#ifdef HAVE_CFBUNDLE
    char tclLibPath[1024];
    
    if (Tcl_MacOSXGetLibraryPath(interp, 1024, tclLibPath) == TCL_OK) {
        Tcl_SetVar(interp, "tclDefaultLibrary", tclLibPath, 
                TCL_GLOBAL_ONLY);
        Tcl_SetVar(interp, "tcl_pkgPath", tclLibPath,
                TCL_GLOBAL_ONLY);
        Tcl_SetVar(interp, "tcl_pkgPath", " ",
                TCL_GLOBAL_ONLY | TCL_APPEND_VALUE);
        Tcl_SetVar(interp, "tcl_pkgPath", pkgPath,
                TCL_GLOBAL_ONLY | TCL_APPEND_VALUE);
    } else
#endif /* HAVE_CFBUNDLE */
    {
        Tcl_SetVar(interp, "tclDefaultLibrary", defaultLibraryDir, 
                TCL_GLOBAL_ONLY);
        Tcl_SetVar(interp, "tcl_pkgPath", pkgPath, TCL_GLOBAL_ONLY);
    }

#ifdef DJGPP
    Tcl_SetVar2(interp, "tcl_platform", "platform", "dos", TCL_GLOBAL_ONLY);
#else
a539 1
#endif
d543 1
a543 1
	CONST char *native;
d718 1
a718 1
    CONST char *fileName;
d725 1
a725 1
	CONST char *fullName;
a782 29

#ifdef HAVE_CFBUNDLE
/*
 *----------------------------------------------------------------------
 *
 * Tcl_MacOSXGetLibraryPath --
 *
 *	If we have a bundle structure for the Tcl installation,
 *	then check there first to see if we can find the libraries
 *	there.
 *
 * Results:
 *	TCL_OK if we have found the tcl library; TCL_ERROR otherwise.
 *
 * Side effects:
 *	Same as for Tcl_MacOSXOpenBundleResources.
 *
 *----------------------------------------------------------------------
 */
static int Tcl_MacOSXGetLibraryPath(Tcl_Interp *interp, int maxPathLen, char *tclLibPath)
{
    int foundInFramework = TCL_ERROR;
    if (strcmp(defaultLibraryDir, "@@TCL_IN_FRAMEWORK@@") == 0) {
	foundInFramework = Tcl_MacOSXOpenBundleResources(interp, 
	    "com.tcltk.tcllibrary", 0, maxPathLen, tclLibPath);
    }
    return foundInFramework;
}
#endif /* HAVE_CFBUNDLE */
@


1.2
log
@touched all Tcl files to ease next import.
@
text
@@


1.2.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.2.16.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@a12 3
#if defined(HAVE_CFBUNDLE)
#include <CoreFoundation/CoreFoundation.h>
#endif
a15 3
#ifdef HAVE_LANGINFO
#include <langinfo.h>
#endif
a31 14
/* Used to store the encoding used for binary files */
static Tcl_Encoding binaryEncoding = NULL;
/* Has the basic library path encoding issue been fixed */
static int libraryPathEncodingFixed = 0;

/*
 * Tcl tries to use standard and homebrew methods to guess the right
 * encoding on the platform.  However, there is always a final fallback,
 * and this value is it.  Make sure it is a real Tcl encoding.
 */

#ifndef TCL_DEFAULT_ENCODING
#define TCL_DEFAULT_ENCODING "iso8859-1"
#endif
d50 1
a50 4
 * encoding files.  If HAVE_LANGINFO is defined, then this is a fallback
 * table when the result from nl_langinfo isn't a recognized encoding.
 * Otherwise this is the first list checked for a mapping from env
 * encoding to Tcl encoding name.
a58 23
#ifdef HAVE_LANGINFO
    {"gb2312-1980",	"gb2312"},
#ifdef __hpux
    {"SJIS",		"shiftjis"},
    {"eucjp",		"euc-jp"},
    {"euckr",		"euc-kr"},
    {"euctw",		"euc-cn"},
    {"greek8",		"cp869"},
    {"iso88591",	"iso8859-1"},
    {"iso88592",	"iso8859-2"},
    {"iso88595",	"iso8859-5"},
    {"iso88596",	"iso8859-6"},
    {"iso88597",	"iso8859-7"},
    {"iso88598",	"iso8859-8"},
    {"iso88599",	"iso8859-9"},
    {"iso885915",	"iso8859-15"},
    {"roman8",		"iso8859-1"},
    {"tis620",		"tis-620"},
    {"turkish8",	"cp857"},
    {"utf8",		"utf-8"},
#endif /* __hpux */
#endif /* HAVE_LANGINFO */

a60 1
    {"ja_JP.eucJP",     "euc-jp"},
a94 5

#ifdef HAVE_CFBUNDLE
static int Tcl_MacOSXGetLibraryPath(Tcl_Interp *interp, int maxPathLen, char *tclLibPath);
#endif /* HAVE_CFBUNDLE */

d195 1
a195 1
    CONST char *str;
d198 1
a198 1
    CONST char **pathv;
d210 2
a211 2
     
    /* REDHAT LOCAL */
d213 3
a215 4
    /* sprintf(installLib, "lib/tcl%s", TCL_VERSION); */
    /* END REDHAT LOCAL */

    sprintf(developLib, "tcl%s/library", TCL_PATCH_LEVEL);
d272 1
a272 1
     *	  (e.g. /usr/local/bin/../lib/tcl8.4)
d274 1
a274 1
     *	  (e.g. /usr/local/TclPro/solaris-sparc/bin/../../lib/tcl8.4)
d276 1
a276 1
     *	  (e.g. /usr/src/tcl8.4.0/unix/../library)
d278 1
a278 1
     *	  (e.g. /usr/src/tcl8.4.0/unix/solaris-sparc/../../library)
d280 3
a282 3
     *	  (e.g. /usr/src/tcl8.4.0/unix/../../tcl8.4.0/library)
     *	<bindir>/../../../<developLib>
     *	  (e.g. /usr/src/tcl8.4.0/unix/solaris-sparc/../../../tcl8.4.0/library)
a284 6

     /*
      * The variable path holds an absolute path.  Take care not to
      * overwrite pathv[0] since that might produce a relative path.
      */

d287 1
a287 2
	if (pathc > 2) {
	    str = pathv[pathc - 2];
a289 1
	    pathv[pathc - 2] = str;
d294 1
a294 2
	if (pathc > 3) {
	    str = pathv[pathc - 3];
a296 1
	    pathv[pathc - 3] = str;
d301 1
a301 2
	if (pathc > 2) {
	    str = pathv[pathc - 2];
a303 1
	    pathv[pathc - 2] = str;
d308 1
a308 2
	if (pathc > 3) {
	    str = pathv[pathc - 3];
a310 1
	    pathv[pathc - 3] = str;
d315 1
a315 2
	if (pathc > 3) {
	    str = pathv[pathc - 3];
a317 1
	    pathv[pathc - 3] = str;
d322 1
a322 2
	if (pathc > 4) {
	    str = pathv[pathc - 4];
a324 1
	    pathv[pathc - 4] = str;
d338 1
a338 11
    {
#ifdef HAVE_CFBUNDLE
    char tclLibPath[MAXPATHLEN + 1];
    
    if (Tcl_MacOSXGetLibraryPath(NULL, MAXPATHLEN, tclLibPath) == TCL_OK) {
        str = tclLibPath;
    } else
#endif /* HAVE_CFBUNDLE */
    {
        str = defaultLibraryDir;
    }
a342 1
    }
d356 1
a356 4
 *	Called at process initialization time, and part way through
 *	startup, we verify that the initial encodings were correctly
 *	setup.  Depending on Tcl's environment, there may not have been
 *	enough information first time through (above).
d362 1
a362 3
 *	The Tcl library path is converted from native encoding to UTF-8,
 *	on the first call, and the encodings may be changed on first or
 *	second call.
d370 4
a373 4
    if (libraryPathEncodingFixed == 0) {
	CONST char *encoding = NULL;
	int i, setSysEncCode = TCL_ERROR;
	Tcl_Obj *pathPtr;
d375 5
a379 8
	/*
	 * Determine the current encoding from the LC_* or LANG environment
	 * variables.  We previously used setlocale() to determine the locale,
	 * but this does not work on some systems (e.g. Linux/i386 RH 5.0).
	 */
#ifdef HAVE_LANGINFO
	if (setlocale(LC_CTYPE, "") != NULL) {
	    Tcl_DString ds;
d381 1
a381 4
	    /*
	     * Use a DString so we can overwrite it in name compatability
	     * checks below.
	     */
d383 9
a391 2
	    Tcl_DStringInit(&ds);
	    encoding = Tcl_DStringAppend(&ds, nl_langinfo(CODESET), -1);
d393 6
a398 42
	    Tcl_UtfToLower(Tcl_DStringValue(&ds));
#ifdef HAVE_LANGINFO_DEBUG
	    fprintf(stderr, "encoding '%s'", encoding);
#endif
	    if (encoding[0] == 'i' && encoding[1] == 's' && encoding[2] == 'o'
		    && encoding[3] == '-') {
		char *p, *q;
		/* need to strip '-' from iso-* encoding */
		for(p = Tcl_DStringValue(&ds)+3, q = Tcl_DStringValue(&ds)+4;
		    *p; *p++ = *q++);
	    } else if (encoding[0] == 'i' && encoding[1] == 'b'
		    && encoding[2] == 'm' && encoding[3] >= '0'
		    && encoding[3] <= '9') {
		char *p, *q;
		/* if langinfo reports "ibm*" we should use "cp*" */
		p = Tcl_DStringValue(&ds);
		*p++ = 'c'; *p++ = 'p';
		for(q = p+1; *p ; *p++ = *q++);
	    } else if ((*encoding == '\0')
		    || !strcmp(encoding, "ansi_x3.4-1968")) {
		/* Use iso8859-1 for empty or 'ansi_x3.4-1968' encoding */
		encoding = "iso8859-1";
	    }
#ifdef HAVE_LANGINFO_DEBUG
	    fprintf(stderr, " ?%s?", encoding);
#endif
	    setSysEncCode = Tcl_SetSystemEncoding(NULL, encoding);
	    if (setSysEncCode != TCL_OK) {
		/*
		 * If this doesn't return TCL_OK, the encoding returned by
		 * nl_langinfo or as we translated it wasn't accepted.  Do
		 * this fallback check.  If this fails, we will enter the
		 * old fallback below.
		 */

		for (i = 0; localeTable[i].lang != NULL; i++) {
		    if (strcmp(localeTable[i].lang, encoding) == 0) {
			setSysEncCode = Tcl_SetSystemEncoding(NULL,
				localeTable[i].encoding);
			break;
		    }
		}
a399 4
#ifdef HAVE_LANGINFO_DEBUG
	    fprintf(stderr, " => '%s'\n", encoding);
#endif
	    Tcl_DStringFree(&ds);
d401 4
a404 6
#ifdef HAVE_LANGINFO_DEBUG
	else {
	    fprintf(stderr, "setlocale returned NULL\n");
	}
#endif
#endif /* HAVE_LANGINFO */
d406 7
a412 16
	if (setSysEncCode != TCL_OK) {
	    /*
	     * Classic fallback check.  This tries a homebrew algorithm to
	     * determine what encoding should be used based on env vars.
	     */
	    char *langEnv = getenv("LC_ALL");
	    encoding = NULL;

	    if (langEnv == NULL || langEnv[0] == '\0') {
		langEnv = getenv("LC_CTYPE");
	    }
	    if (langEnv == NULL || langEnv[0] == '\0') {
		langEnv = getenv("LANG");
	    }
	    if (langEnv == NULL || langEnv[0] == '\0') {
		langEnv = NULL;
d414 4
d419 5
a423 6
	    if (langEnv != NULL) {
		for (i = 0; localeTable[i].lang != NULL; i++) {
		    if (strcmp(localeTable[i].lang, langEnv) == 0) {
			encoding = localeTable[i].encoding;
			break;
		    }
d425 2
a426 30
		/*
		 * There was no mapping in the locale table.  If there is an
		 * encoding subfield, we can try to guess from that.
		 */

		if (encoding == NULL) {
		    char *p;
		    for (p = langEnv; *p != '\0'; p++) {
			if (*p == '.') {
			    p++;
			    break;
			}
		    }
		    if (*p != '\0') {
			Tcl_DString ds;
			Tcl_DStringInit(&ds);
			encoding = Tcl_DStringAppend(&ds, p, -1);

			Tcl_UtfToLower(Tcl_DStringValue(&ds));
			setSysEncCode = Tcl_SetSystemEncoding(NULL, encoding);
			if (setSysEncCode != TCL_OK) {
			    encoding = NULL;
			}
			Tcl_DStringFree(&ds);
		    }
		}
#ifdef HAVE_LANGINFO_DEBUG
		fprintf(stderr, "encoding fallback check '%s' => '%s'\n",
			langEnv, encoding);
#endif
d428 7
a434 4
	    if (setSysEncCode != TCL_OK) {
		if (encoding == NULL) {
		    encoding = TCL_DEFAULT_ENCODING;
		}
d436 9
a444 2
		Tcl_SetSystemEncoding(NULL, encoding);
	    }
d446 1
a446 13
	    /*
	     * Initialize the C library's locale subsystem.  This is required
	     * for input methods to work properly on X11.  We only do this for
	     * LC_CTYPE because that's the necessary one, and we don't want to
	     * affect LC_TIME here.  The side effect of setting the default
	     * locale should be to load any locale specific modules that are
	     * needed by X.  [BUG: 5422 3345 4236 2522 2521].
	     * In HAVE_LANGINFO, this call is already done above.
	     */
#ifndef HAVE_LANGINFO
	    setlocale(LC_CTYPE, "");
#endif
	}
d448 6
a453 6
	/*
	 * In case the initial locale is not "C", ensure that the numeric
	 * processing is done in "C" locale regardless.  This is needed because
	 * Tcl relies on routines like strtod, but should not have locale
	 * dependent behavior.
	 */
d455 1
a455 1
	setlocale(LC_NUMERIC, "C");
d457 21
a477 21
	/*
	 * Until the system encoding was actually set, the library path was
	 * actually in the native multi-byte encoding, and not really UTF-8
	 * as advertised.  We cheated as follows:
	 *
	 * 1. It was safe to allow the Tcl_SetSystemEncoding() call to 
	 * append the ASCII chars that make up the encoding's filename to 
	 * the names (in the native encoding) of directories in the library 
	 * path, since all Unix multi-byte encodings have ASCII in the
	 * beginning.
	 *
	 * 2. To open the encoding file, the native bytes in the file name
	 * were passed to the OS, without translating from UTF-8 to native,
	 * because the name was already in the native encoding.
	 *
	 * Now that the system encoding was actually successfully set,
	 * translate all the names in the library path to UTF-8.  That way,
	 * next time we search the library path, we'll translate the names 
	 * from UTF-8 to the system encoding which will be the native 
	 * encoding.
	 */
d479 11
a489 11
	pathPtr = TclGetLibraryPath();
	if (pathPtr != NULL) {
	    int objc;
	    Tcl_Obj **objv;
	    
	    objc = 0;
	    Tcl_ListObjGetElements(NULL, pathPtr, &objc, &objv);
	    for (i = 0; i < objc; i++) {
		int length;
		char *string;
		Tcl_DString ds;
d491 5
a495 6
		string = Tcl_GetStringFromObj(objv[i], &length);
		Tcl_ExternalToUtfDString(NULL, string, length, &ds);
		Tcl_SetStringObj(objv[i], Tcl_DStringValue(&ds), 
			Tcl_DStringLength(&ds));
		Tcl_DStringFree(&ds);
	    }
d497 6
d504 1
a504 11
	libraryPathEncodingFixed = 1;
    }
    
    /* This is only ever called from the startup thread */
    if (binaryEncoding == NULL) {
	/*
	 * Keep the iso8859-1 encoding preloaded.  The IO package uses
	 * it for gets on a binary channel.
	 */
	binaryEncoding = Tcl_GetEncoding(NULL, "iso8859-1");
    }
d534 1
a534 1
    CONST char *user;
d537 2
a538 68
#ifdef HAVE_CFBUNDLE
    char tclLibPath[MAXPATHLEN + 1];
    
    if (Tcl_MacOSXGetLibraryPath(interp, MAXPATHLEN, tclLibPath) == TCL_OK) {
        CONST char *str;
        Tcl_DString ds;
        CFBundleRef bundleRef;

        Tcl_SetVar(interp, "tclDefaultLibrary", tclLibPath, 
                TCL_GLOBAL_ONLY);
        Tcl_SetVar(interp, "tcl_pkgPath", tclLibPath,
                TCL_GLOBAL_ONLY);
        Tcl_SetVar(interp, "tcl_pkgPath", " ",
                TCL_GLOBAL_ONLY | TCL_APPEND_VALUE);
        str = TclGetEnv("DYLD_FRAMEWORK_PATH", &ds);
        if ((str != NULL) && (str[0] != '\0')) {
            char *p = Tcl_DStringValue(&ds);
            /* convert DYLD_FRAMEWORK_PATH from colon to space separated */
            do {
                if(*p == ':') *p = ' ';
            } while (*p++);
            Tcl_SetVar(interp, "tcl_pkgPath", Tcl_DStringValue(&ds),
                    TCL_GLOBAL_ONLY | TCL_APPEND_VALUE);
            Tcl_SetVar(interp, "tcl_pkgPath", " ",
                    TCL_GLOBAL_ONLY | TCL_APPEND_VALUE);
            Tcl_DStringFree(&ds);
        }
        if ((bundleRef = CFBundleGetMainBundle())) {
            CFURLRef frameworksURL;
            Tcl_StatBuf statBuf;
            if((frameworksURL = CFBundleCopyPrivateFrameworksURL(bundleRef))) {
                if(CFURLGetFileSystemRepresentation(frameworksURL, TRUE,
                            tclLibPath, MAXPATHLEN) &&
                        ! TclOSstat(tclLibPath, &statBuf) &&
                        S_ISDIR(statBuf.st_mode)) {
                    Tcl_SetVar(interp, "tcl_pkgPath", tclLibPath,
                            TCL_GLOBAL_ONLY | TCL_APPEND_VALUE);
                    Tcl_SetVar(interp, "tcl_pkgPath", " ",
                            TCL_GLOBAL_ONLY | TCL_APPEND_VALUE);
                }
                CFRelease(frameworksURL);
            }
            if((frameworksURL = CFBundleCopySharedFrameworksURL(bundleRef))) {
                if(CFURLGetFileSystemRepresentation(frameworksURL, TRUE,
                            tclLibPath, MAXPATHLEN) &&
                        ! TclOSstat(tclLibPath, &statBuf) &&
                        S_ISDIR(statBuf.st_mode)) {
                    Tcl_SetVar(interp, "tcl_pkgPath", tclLibPath,
                            TCL_GLOBAL_ONLY | TCL_APPEND_VALUE);
                    Tcl_SetVar(interp, "tcl_pkgPath", " ",
                            TCL_GLOBAL_ONLY | TCL_APPEND_VALUE);
                }
                CFRelease(frameworksURL);
            }
        }
        Tcl_SetVar(interp, "tcl_pkgPath", pkgPath,
                TCL_GLOBAL_ONLY | TCL_APPEND_VALUE);
    } else
#endif /* HAVE_CFBUNDLE */
    {
        Tcl_SetVar(interp, "tclDefaultLibrary", defaultLibraryDir, 
                TCL_GLOBAL_ONLY);
        Tcl_SetVar(interp, "tcl_pkgPath", pkgPath, TCL_GLOBAL_ONLY);
    }

#ifdef DJGPP
    Tcl_SetVar2(interp, "tcl_platform", "platform", "dos", TCL_GLOBAL_ONLY);
#else
a539 1
#endif
d543 1
a543 1
	CONST char *native;
d718 1
a718 1
    CONST char *fileName;
d725 1
a725 1
	CONST char *fullName;
a782 29

#ifdef HAVE_CFBUNDLE
/*
 *----------------------------------------------------------------------
 *
 * Tcl_MacOSXGetLibraryPath --
 *
 *	If we have a bundle structure for the Tcl installation,
 *	then check there first to see if we can find the libraries
 *	there.
 *
 * Results:
 *	TCL_OK if we have found the tcl library; TCL_ERROR otherwise.
 *
 * Side effects:
 *	Same as for Tcl_MacOSXOpenBundleResources.
 *
 *----------------------------------------------------------------------
 */
static int Tcl_MacOSXGetLibraryPath(Tcl_Interp *interp, int maxPathLen, char *tclLibPath)
{
    int foundInFramework = TCL_ERROR;
    if (strcmp(defaultLibraryDir, "@@TCL_IN_FRAMEWORK@@") == 0) {
	foundInFramework = Tcl_MacOSXOpenBundleResources(interp, 
	    "com.tcltk.tcllibrary", 0, maxPathLen, tclLibPath);
    }
    return foundInFramework;
}
#endif /* HAVE_CFBUNDLE */
@


1.1
log
@Initial revision
@
text
@d6 3
a8 1
 * Copyright (c) 1995-1996 Sun Microsystems, Inc.
d10 1
a10 4
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tclUnixInit.c,v 1.13 1999/01/26 03:53:39 jingham Exp $
d15 1
d27 7
d49 2
a50 1
 * Is this module initialized?
d53 39
a91 1
static int initialized = 0;
d93 3
d97 16
a112 3
 * The Init script, tclPreInitScript variable, and the routine
 * TclSetPreInitScript (common to Windows and Unix platforms) are defined
 * in generic/tclInitScript.h.
d115 23
a137 1
#include "tclInitScript.h"
d139 8
d148 38
a185 1
 * Static routines in this file:
d188 159
a346 1
static void	PlatformInitExitHandler _ANSI_ARGS_((ClientData clientData));
d349 3
a351 1
 *----------------------------------------------------------------------
d353 2
a354 1
 * PlatformInitExitHandler --
d356 1
a356 2
 *	Uninitializes all values on unload, so that this module can
 *	be later reinitialized.
d362 1
a362 1
 *	Returns the module to uninitialized state.
d364 1
a364 1
 *----------------------------------------------------------------------
d367 2
a368 3
static void
PlatformInitExitHandler(clientData)
    ClientData clientData;		/* Unused. */
d370 135
a504 1
    initialized = 0;
d508 1
a508 1
 *----------------------------------------------------------------------
d510 1
a510 1
 * TclPlatformInit --
d512 2
a513 2
 *	Performs Unix-specific interpreter initialization related to the
 *      tcl_library and tcl_platform variables, and other platform-
d520 2
a521 1
 *	Sets "tcl_library" and "tcl_platform" Tcl variables.
d527 1
a527 1
TclPlatformInit(interp)
d534 2
d537 1
a537 3
    tclPlatform = TCL_PLATFORM_UNIX;
    Tcl_SetVar(interp, "tclDefaultLibrary", defaultLibraryDir,
	    TCL_GLOBAL_ONLY);
d543 2
d546 5
a550 2
	Tcl_SetVar2(interp, "tcl_platform", "os", name.sysname,
		TCL_GLOBAL_ONLY);
d560 1
a560 1
		|| !isdigit(UCHAR(name.version[0]))) {
d581 14
a594 1
    if (!initialized) {
d596 22
a617 20
        /*
         * Create an exit handler so that uninitialization will be done
         * on unload.
         */
        
        Tcl_CreateExitHandler(PlatformInitExitHandler, NULL);
        
	/*
	 * The code below causes SIGPIPE (broken pipe) errors to
	 * be ignored.  This is needed so that Tcl processes don't
	 * die if they create child processes (e.g. using "exec" or
	 * "open") that terminate prematurely.  The signal handler
	 * is only set up when the first interpreter is created;
	 * after this the application can override the handler with
	 * a different one of its own, if it wants.
	 */
    
#ifdef SIGPIPE
	(void) signal(SIGPIPE, SIG_IGN);
#endif /* SIGPIPE */
d619 17
a635 4
#ifdef __FreeBSD__
	fpsetround(FP_RN);
	fpsetmask(0L);
#endif
d637 10
a646 7
#if defined(__bsdi__) && (_BSDI_VERSION > 199501)
	/*
	 * Find local symbols. Don't report an error if we fail.
	 */
	(void) dlopen (NULL, RTLD_NOW);
#endif
	initialized = 1;
d648 6
d662 2
a663 2
 *	to perform additional initialization for a Tcl interpreter,
 *	such as sourcing the "init.tcl" script.
d666 2
a667 2
 *	Returns a standard Tcl completion code and sets interp->result
 *	if there is an error.
d679 2
d686 7
a692 1
    return(Tcl_Eval(interp, initScript));
d747 2
a748 2
			Tcl_Write(errChannel, interp->result, -1);
			Tcl_Write(errChannel, "\n", 1);
d756 28
@


1.1.1.1
log
@import dejagnu-1999-11-08 snapshot
@
text
@@


1.1.1.2
log
@Tcl 8.3 upgrade
@
text
@d6 1
a6 3
 * Copyright (c) 1995-1997 Sun Microsystems, Inc.
 * Copyright (c) 1999 by Scriptics Corporation.
 * All rights reserved.
d8 4
a11 1
 * RCS: @@(#) $Id: tclUnixInit.c,v 1.6.8.3 2001/06/15 05:19:08 mdejong Exp $
a15 1
#include <locale.h>
a26 7
 * The Init script (common to Windows and Unix platforms) is
 * defined in tkInitScript.h
 */
#include "tclInitScript.h"


/*
d42 1
a42 2
 * The following table is used to map from Unix locale strings to
 * encoding files.
d45 1
a45 39
typedef struct LocaleTable {
    CONST char *lang;
    CONST char *encoding;
} LocaleTable;

static CONST LocaleTable localeTable[] = {
    {"ja_JP.SJIS",	"shiftjis"},
    {"ja_JP.EUC",	"euc-jp"},
    {"ja_JP.JIS",	"iso2022-jp"},
    {"ja_JP.mscode",	"shiftjis"},
    {"ja_JP.ujis",	"euc-jp"},
    {"ja_JP",		"euc-jp"},
    {"Ja_JP",		"shiftjis"},
    {"Jp_JP",		"shiftjis"},
    {"japan",		"euc-jp"},
#ifdef hpux
    {"japanese",	"shiftjis"},	
    {"ja",		"shiftjis"},	
#else
    {"japanese",	"euc-jp"},
    {"ja",		"euc-jp"},
#endif
    {"japanese.sjis",	"shiftjis"},
    {"japanese.euc",	"euc-jp"},
    {"japanese-sjis",	"shiftjis"},
    {"japanese-ujis",	"euc-jp"},

    {"ko",              "euc-kr"},
    {"ko_KR",           "euc-kr"},
    {"ko_KR.EUC",       "euc-kr"},
    {"ko_KR.euc",       "euc-kr"},
    {"ko_KR.eucKR",     "euc-kr"},
    {"korean",          "euc-kr"},

    {"ru",		"iso8859-5"},		
    {"ru_RU",		"iso8859-5"},		
    {"ru_SU",		"iso8859-5"},		

    {"zh",		"cp936"},
a46 3
    {NULL, NULL}
};

d48 3
a50 16
 *---------------------------------------------------------------------------
 *
 * TclpInitPlatform --
 *
 *	Initialize all the platform-dependant things like signals and
 *	floating-point error handling.
 *
 *	Called at process initialization time.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
d53 1
a53 23
void
TclpInitPlatform()
{
    tclPlatform = TCL_PLATFORM_UNIX;

    /*
     * The code below causes SIGPIPE (broken pipe) errors to
     * be ignored.  This is needed so that Tcl processes don't
     * die if they create child processes (e.g. using "exec" or
     * "open") that terminate prematurely.  The signal handler
     * is only set up when the first interpreter is created;
     * after this the application can override the handler with
     * a different one of its own, if it wants.
     */

#ifdef SIGPIPE
    (void) signal(SIGPIPE, SIG_IGN);
#endif /* SIGPIPE */

#ifdef __FreeBSD__
    fpsetround(FP_RN);
    fpsetmask(0L);
#endif
a54 8
#if defined(__bsdi__) && (_BSDI_VERSION > 199501)
    /*
     * Find local symbols. Don't report an error if we fail.
     */
    (void) dlopen (NULL, RTLD_NOW);			/* INTL: Native. */
#endif
}

d56 1
a56 38
 *---------------------------------------------------------------------------
 *
 * TclpInitLibraryPath --
 *
 *	Initialize the library path at startup.  We have a minor
 *	metacircular problem that we don't know the encoding of the
 *	operating system but we may need to talk to operating system
 *	to find the library directories so that we know how to talk to
 *	the operating system.
 *
 *	We do not know the encoding of the operating system.
 *	We do know that the encoding is some multibyte encoding.
 *	In that multibyte encoding, the characters 0..127 are equivalent
 *	    to ascii.
 *
 *	So although we don't know the encoding, it's safe:
 *	    to look for the last slash character in a path in the encoding.
 *	    to append an ascii string to a path.
 *	    to pass those strings back to the operating system.
 *
 *	But any strings that we remembered before we knew the encoding of
 *	the operating system must be translated to UTF-8 once we know the
 *	encoding so that the rest of Tcl can use those strings.
 *
 *	This call sets the library path to strings in the unknown native
 *	encoding.  TclpSetInitialEncodings() will translate the library
 *	path from the native encoding to UTF-8 as soon as it determines
 *	what the native encoding actually is.
 *
 *	Called at process initialization time.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
d59 1
a59 159
void
TclpInitLibraryPath(path)
CONST char *path;		/* Path to the executable in native 
				 * multi-byte encoding. */
{
#define LIBRARY_SIZE	    32
    Tcl_Obj *pathPtr, *objPtr;
    char *str;
    Tcl_DString buffer, ds;
    int pathc;
    char **pathv;
    char installLib[LIBRARY_SIZE], developLib[LIBRARY_SIZE];

    Tcl_DStringInit(&ds);
    pathPtr = Tcl_NewObj();

    /*
     * Initialize the substrings used when locating an executable.  The
     * installLib variable computes the path as though the executable
     * is installed.  The developLib computes the path as though the
     * executable is run from a develpment directory.
     */

    /* CYGNUS LOCAL */
    sprintf(installLib, "share/tcl%s", TCL_VERSION);
    /* END CYGNUS LOCAL */
    sprintf(developLib, "tcl%s/library",
	    ((TCL_RELEASE_LEVEL < 2) ? TCL_PATCH_LEVEL : TCL_VERSION));

    /*
     * Look for the library relative to default encoding dir.
     */

    str = Tcl_GetDefaultEncodingDir();
    if ((str != NULL) && (str[0] != '\0')) {
	objPtr = Tcl_NewStringObj(str, -1);
	Tcl_ListObjAppendElement(NULL, pathPtr, objPtr);
    }

    /*
     * Look for the library relative to the TCL_LIBRARY env variable.
     * If the last dirname in the TCL_LIBRARY path does not match the
     * last dirname in the installLib variable, use the last dir name
     * of installLib in addition to the orginal TCL_LIBRARY path.
     */

    str = getenv("TCL_LIBRARY");			/* INTL: Native. */
    Tcl_ExternalToUtfDString(NULL, str, -1, &buffer);
    str = Tcl_DStringValue(&buffer);

    if ((str != NULL) && (str[0] != '\0')) {
	/*
	 * If TCL_LIBRARY is set, search there.
	 */
	 
	objPtr = Tcl_NewStringObj(str, -1);
	Tcl_ListObjAppendElement(NULL, pathPtr, objPtr);

	Tcl_SplitPath(str, &pathc, &pathv);
	if ((pathc > 0) && (strcasecmp(installLib + 4, pathv[pathc-1]) != 0)) {
	    /*
	     * If TCL_LIBRARY is set but refers to a different tcl
	     * installation than the current version, try fiddling with the
	     * specified directory to make it refer to this installation by
	     * removing the old "tclX.Y" and substituting the current
	     * version string.
	     */
	    
	    pathv[pathc - 1] = installLib + 4;
	    str = Tcl_JoinPath(pathc, pathv, &ds);
	    objPtr = Tcl_NewStringObj(str, Tcl_DStringLength(&ds));
	    Tcl_ListObjAppendElement(NULL, pathPtr, objPtr);
	    Tcl_DStringFree(&ds);
	}
	ckfree((char *) pathv);
    }

    /*
     * Look for the library relative to the executable.  This algorithm
     * should be the same as the one in the tcl_findLibrary procedure.
     *
     * This code looks in the following directories:
     *
     *	<bindir>/../<installLib>
     *		(e.g. /usr/local/bin/../lib/tcl8.2)
     *	<bindir>/../../<installLib>
     *		(e.g. /usr/local/TclPro/solaris-sparc/bin/../../lib/tcl8.2)
     *	<bindir>/../library
     *		(e.g. /usr/src/tcl8.2/unix/../library)
     *	<bindir>/../../library
     *		(e.g. /usr/src/tcl8.2/unix/solaris-sparc/../../library)
     *	<bindir>/../../<developLib>
     *		(e.g. /usr/src/tcl8.2/unix/../../tcl8.2/library)
     *	<bindir>/../../../<devlopLib>
     *		(e.g. /usr/src/tcl8.2/unix/solaris-sparc/../../../tcl8.2/library)
     */
     
    if (path != NULL) {
	Tcl_SplitPath(path, &pathc, &pathv);
	if (pathc > 1) {
	    pathv[pathc - 2] = installLib;
	    path = Tcl_JoinPath(pathc - 1, pathv, &ds);
	    objPtr = Tcl_NewStringObj(path, Tcl_DStringLength(&ds));
	    Tcl_ListObjAppendElement(NULL, pathPtr, objPtr);
	    Tcl_DStringFree(&ds);
	}
	if (pathc > 2) {
	    pathv[pathc - 3] = installLib;
	    path = Tcl_JoinPath(pathc - 2, pathv, &ds);
	    objPtr = Tcl_NewStringObj(path, Tcl_DStringLength(&ds));
	    Tcl_ListObjAppendElement(NULL, pathPtr, objPtr);
	    Tcl_DStringFree(&ds);
	}
	if (pathc > 1) {
	    pathv[pathc - 2] = "library";
	    path = Tcl_JoinPath(pathc - 1, pathv, &ds);
	    objPtr = Tcl_NewStringObj(path, Tcl_DStringLength(&ds));
	    Tcl_ListObjAppendElement(NULL, pathPtr, objPtr);
	    Tcl_DStringFree(&ds);
	}
	if (pathc > 2) {
	    pathv[pathc - 3] = "library";
	    path = Tcl_JoinPath(pathc - 2, pathv, &ds);
	    objPtr = Tcl_NewStringObj(path, Tcl_DStringLength(&ds));
	    Tcl_ListObjAppendElement(NULL, pathPtr, objPtr);
	    Tcl_DStringFree(&ds);
	}
	if (pathc > 1) {
	    pathv[pathc - 3] = developLib;
	    path = Tcl_JoinPath(pathc - 2, pathv, &ds);
	    objPtr = Tcl_NewStringObj(path, Tcl_DStringLength(&ds));
	    Tcl_ListObjAppendElement(NULL, pathPtr, objPtr);
	    Tcl_DStringFree(&ds);
	}
	if (pathc > 3) {
	    pathv[pathc - 4] = developLib;
	    path = Tcl_JoinPath(pathc - 3, pathv, &ds);
	    objPtr = Tcl_NewStringObj(path, Tcl_DStringLength(&ds));
	    Tcl_ListObjAppendElement(NULL, pathPtr, objPtr);
	    Tcl_DStringFree(&ds);
	}
	ckfree((char *) pathv);
    }

    /*
     * Finally, look for the library relative to the compiled-in path.
     * This is needed when users install Tcl with an exec-prefix that
     * is different from the prtefix.
     */
			      
    str = defaultLibraryDir;
    if (str[0] != '\0') {
        objPtr = Tcl_NewStringObj(str, -1);
        Tcl_ListObjAppendElement(NULL, pathPtr, objPtr);
    }

    TclSetLibraryPath(pathPtr);    
    Tcl_DStringFree(&buffer);
}
d62 1
a62 1
 *---------------------------------------------------------------------------
d64 1
a64 1
 * TclpSetInitialEncodings --
d66 2
a67 4
 *	Based on the locale, determine the encoding of the operating
 *	system and the default encoding for newly opened files.
 *
 *	Called at process initialization time.
d73 1
a73 1
 *	The Tcl library path is converted from native encoding to UTF-8.
d75 1
a75 1
 *---------------------------------------------------------------------------
d78 3
a80 2
void
TclpSetInitialEncodings()
d82 1
a82 135
    CONST char *encoding;
    int i;
    Tcl_Obj *pathPtr;
    char *langEnv;

    /*
     * Determine the current encoding from the LC_* or LANG environment
     * variables.  We previously used setlocale() to determine the locale,
     * but this does not work on some systems (e.g. Linux/i386 RH 5.0).
     */

    langEnv = getenv("LC_ALL");

    if (langEnv == NULL || langEnv[0] == '\0') {
	langEnv = getenv("LC_CTYPE");
    }
    if (langEnv == NULL || langEnv[0] == '\0') {
	langEnv = getenv("LANG");
    }
    if (langEnv == NULL || langEnv[0] == '\0') {
	langEnv = NULL;
    }

    encoding = NULL;
    if (langEnv != NULL) {
	for (i = 0; localeTable[i].lang != NULL; i++) {
	    if (strcmp(localeTable[i].lang, langEnv) == 0) {
		encoding = localeTable[i].encoding;
		break;
	    }
	}
	/*
	 * There was no mapping in the locale table.  If there is an
	 * encoding subfield, we can try to guess from that.
	 */

	if (encoding == NULL) {
	    char *p;
	    for (p = langEnv; *p != '\0'; p++) {
		if (*p == '.') {
		    p++;
		    break;
		}
	    }
	    if (*p != '\0') {
		Tcl_DString ds;
		Tcl_DStringInit(&ds);
		Tcl_DStringAppend(&ds, p, -1);

		encoding = Tcl_DStringValue(&ds);
		Tcl_UtfToLower(Tcl_DStringValue(&ds));
		if (Tcl_SetSystemEncoding(NULL, encoding) == TCL_OK) {
		    Tcl_DStringFree(&ds);
		    goto resetPath;
		}
		Tcl_DStringFree(&ds);
		encoding = NULL;
	    }
	}
    }
    if (encoding == NULL) {
	encoding = "iso8859-1";
    }

    Tcl_SetSystemEncoding(NULL, encoding);

    resetPath:
    /*
     * Initialize the C library's locale subsystem.  This is required
     * for input methods to work properly on X11.  We only do this for
     * LC_CTYPE because that's the necessary one, and we don't want to
     * affect LC_TIME here.  The side effect of setting the default locale
     * should be to load any locale specific modules that are needed by X.
     * [BUG: 5422 3345 4236 2522 2521].
     */

    setlocale(LC_CTYPE, "");

    /*
     * In case the initial locale is not "C", ensure that the numeric
     * processing is done in "C" locale regardless.  This is needed because
     * Tcl relies on routines like strtod, but should not have locale
     * dependent behavior.
     */

    setlocale(LC_NUMERIC, "C");

    /*
     * Until the system encoding was actually set, the library path was
     * actually in the native multi-byte encoding, and not really UTF-8
     * as advertised.  We cheated as follows:
     *
     * 1. It was safe to allow the Tcl_SetSystemEncoding() call to 
     * append the ASCII chars that make up the encoding's filename to 
     * the names (in the native encoding) of directories in the library 
     * path, since all Unix multi-byte encodings have ASCII in the
     * beginning.
     *
     * 2. To open the encoding file, the native bytes in the file name
     * were passed to the OS, without translating from UTF-8 to native,
     * because the name was already in the native encoding.
     *
     * Now that the system encoding was actually successfully set,
     * translate all the names in the library path to UTF-8.  That way,
     * next time we search the library path, we'll translate the names 
     * from UTF-8 to the system encoding which will be the native 
     * encoding.
     */

    pathPtr = TclGetLibraryPath();
    if (pathPtr != NULL) {
	int objc;
	Tcl_Obj **objv;
	
	objc = 0;
	Tcl_ListObjGetElements(NULL, pathPtr, &objc, &objv);
	for (i = 0; i < objc; i++) {
	    int length;
	    char *string;
	    Tcl_DString ds;

	    string = Tcl_GetStringFromObj(objv[i], &length);
	    Tcl_ExternalToUtfDString(NULL, string, length, &ds);
	    Tcl_SetStringObj(objv[i], Tcl_DStringValue(&ds), 
		    Tcl_DStringLength(&ds));
	    Tcl_DStringFree(&ds);
	}
    }

    /*
     * Keep the iso8859-1 encoding preloaded.  The IO package uses it for
     * gets on a binary channel.
     */

    Tcl_GetEncoding(NULL, "iso8859-1");
d86 1
a86 1
 *---------------------------------------------------------------------------
d88 1
a88 1
 * TclpSetVariables --
d90 2
a91 2
 *	Performs platform-specific interpreter initialization related to
 *	the tcl_library and tcl_platform variables, and other platform-
d98 1
a98 2
 *	Sets "tclDefaultLibrary", "tcl_pkgPath", and "tcl_platform" Tcl
 *	variables.
d104 1
a104 1
TclpSetVariables(interp)
a110 2
    char *user;
    Tcl_DString ds;
d112 3
a114 1
    Tcl_SetVar(interp, "tclDefaultLibrary", defaultLibraryDir, TCL_GLOBAL_ONLY);
a119 2
	char *native;
	
d121 2
a122 5

	native = Tcl_ExternalToUtfDString(NULL, name.sysname, -1, &ds);
	Tcl_SetVar2(interp, "tcl_platform", "os", native, TCL_GLOBAL_ONLY);
	Tcl_DStringFree(&ds);
	
d132 1
a132 1
		|| !isdigit(UCHAR(name.version[0]))) {	/* INTL: digit */
d153 1
a153 14
    /*
     * Copy USER or LOGNAME environment variable into tcl_platform(user)
     */

    Tcl_DStringInit(&ds);
    user = TclGetEnv("USER", &ds);
    if (user == NULL) {
	user = TclGetEnv("LOGNAME", &ds);
	if (user == NULL) {
	    user = "";
	}
    }
    Tcl_SetVar2(interp, "tcl_platform", "user", user, TCL_GLOBAL_ONLY);
    Tcl_DStringFree(&ds);
d155 20
a174 22
}

/*
 *----------------------------------------------------------------------
 *
 * TclpFindVariable --
 *
 *	Locate the entry in environ for a given name.  On Unix this 
 *	routine is case sensetive, on Windows this matches mixed case.
 *
 * Results:
 *	The return value is the index in environ of an entry with the
 *	name "name", or -1 if there is no such entry.   The integer at
 *	*lengthPtr is filled in with the length of name (if a matching
 *	entry is found) or the length of the environ array (if no matching
 *	entry is found).
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
d176 4
a179 17
int
TclpFindVariable(name, lengthPtr)
    CONST char *name;		/* Name of desired environment variable
				 * (native). */
    int *lengthPtr;		/* Used to return length of name (for
				 * successful searches) or number of non-NULL
				 * entries in environ (for unsuccessful
				 * searches). */
{
    int i, result = -1;
    register CONST char *env, *p1, *p2;
    Tcl_DString envString;

    Tcl_DStringInit(&envString);
    for (i = 0, env = environ[i]; env != NULL; i++, env = environ[i]) {
	p1 = Tcl_ExternalToUtfDString(NULL, env, -1, &envString);
	p2 = name;
d181 7
a187 10
	for (; *p2 == *p1; p1++, p2++) {
	    /* NULL loop body. */
	}
	if ((*p1 == '=') && (*p2 == '\0')) {
	    *lengthPtr = p2 - name;
	    result = i;
	    goto done;
	}
	
	Tcl_DStringFree(&envString);
a188 6
    
    *lengthPtr = i;

    done:
    Tcl_DStringFree(&envString);
    return result;
d197 2
a198 2
 *	to find and source the "init.tcl" script, which should exist
 *	somewhere on the Tcl library path.
d201 2
a202 2
 *	Returns a standard Tcl completion code and sets the interp's
 *	result if there is an error.
a213 2
    Tcl_Obj *pathPtr;

d219 1
a219 7
    
    pathPtr = TclGetLibraryPath();
    if (pathPtr == NULL) {
	pathPtr = Tcl_NewObj();
    }
    Tcl_SetVar2Ex(interp, "tcl_libPath", NULL, pathPtr, TCL_GLOBAL_ONLY);
    return Tcl_Eval(interp, initScript);
d274 2
a275 2
			Tcl_WriteObj(errChannel, Tcl_GetObjResult(interp));
			Tcl_WriteChars(errChannel, "\n", 1);
a282 28

/*
 *----------------------------------------------------------------------
 *
 * TclpCheckStackSpace --
 *
 *	Detect if we are about to blow the stack.  Called before an 
 *	evaluation can happen when nesting depth is checked.
 *
 * Results:
 *	1 if there is enough stack space to continue; 0 if not.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
TclpCheckStackSpace()
{
    /*
     * This function is unimplemented on Unix platforms.
     */

    return 1;
}

@


1.1.1.3
log
@import tcl 8.4.0
@
text
@d10 1
a10 1
 * RCS: @@(#) $Id: tclUnixInit.c,v 1.33 2002/09/02 19:27:42 hobbs Exp $
a12 3
#if defined(HAVE_CFBUNDLE)
#include <CoreFoundation/CoreFoundation.h>
#endif
a15 3
#ifdef HAVE_LANGINFO
#include <langinfo.h>
#endif
a31 14
/* Used to store the encoding used for binary files */
static Tcl_Encoding binaryEncoding = NULL;
/* Has the basic library path encoding issue been fixed */
static int libraryPathEncodingFixed = 0;

/*
 * Tcl tries to use standard and homebrew methods to guess the right
 * encoding on the platform.  However, there is always a final fallback,
 * and this value is it.  Make sure it is a real Tcl encoding.
 */

#ifndef TCL_DEFAULT_ENCODING
#define TCL_DEFAULT_ENCODING "iso8859-1"
#endif
d50 1
a50 4
 * encoding files.  If HAVE_LANGINFO is defined, then this is a fallback
 * table when the result from nl_langinfo isn't a recognized encoding.
 * Otherwise this is the first list checked for a mapping from env
 * encoding to Tcl encoding name.
a58 23
#ifdef HAVE_LANGINFO
    {"gb2312-1980",	"gb2312"},
#ifdef __hpux
    {"SJIS",		"shiftjis"},
    {"eucjp",		"euc-jp"},
    {"euckr",		"euc-kr"},
    {"euctw",		"euc-cn"},
    {"greek8",		"cp869"},
    {"iso88591",	"iso8859-1"},
    {"iso88592",	"iso8859-2"},
    {"iso88595",	"iso8859-5"},
    {"iso88596",	"iso8859-6"},
    {"iso88597",	"iso8859-7"},
    {"iso88598",	"iso8859-8"},
    {"iso88599",	"iso8859-9"},
    {"iso885915",	"iso8859-15"},
    {"roman8",		"iso8859-1"},
    {"tis620",		"tis-620"},
    {"turkish8",	"cp857"},
    {"utf8",		"utf-8"},
#endif /* __hpux */
#endif /* HAVE_LANGINFO */

a60 1
    {"ja_JP.eucJP",     "euc-jp"},
a94 5

#ifdef HAVE_CFBUNDLE
static int Tcl_MacOSXGetLibraryPath(Tcl_Interp *interp, int maxPathLen, char *tclLibPath);
#endif /* HAVE_CFBUNDLE */

d195 1
a195 1
    CONST char *str;
d198 1
a198 1
    CONST char **pathv;
d210 6
a215 3
     
    sprintf(installLib, "lib/tcl%s", TCL_VERSION);
    sprintf(developLib, "tcl%s/library", TCL_PATCH_LEVEL);
d272 1
a272 1
     *	  (e.g. /usr/local/bin/../lib/tcl8.4)
d274 1
a274 1
     *	  (e.g. /usr/local/TclPro/solaris-sparc/bin/../../lib/tcl8.4)
d276 1
a276 1
     *	  (e.g. /usr/src/tcl8.4.0/unix/../library)
d278 1
a278 1
     *	  (e.g. /usr/src/tcl8.4.0/unix/solaris-sparc/../../library)
d280 3
a282 3
     *	  (e.g. /usr/src/tcl8.4.0/unix/../../tcl8.4.0/library)
     *	<bindir>/../../../<developLib>
     *	  (e.g. /usr/src/tcl8.4.0/unix/solaris-sparc/../../../tcl8.4.0/library)
a284 6

     /*
      * The variable path holds an absolute path.  Take care not to
      * overwrite pathv[0] since that might produce a relative path.
      */

d287 1
a287 2
	if (pathc > 2) {
	    str = pathv[pathc - 2];
a289 1
	    pathv[pathc - 2] = str;
d294 1
a294 2
	if (pathc > 3) {
	    str = pathv[pathc - 3];
a296 1
	    pathv[pathc - 3] = str;
d301 1
a301 2
	if (pathc > 2) {
	    str = pathv[pathc - 2];
a303 1
	    pathv[pathc - 2] = str;
d308 1
a308 2
	if (pathc > 3) {
	    str = pathv[pathc - 3];
a310 1
	    pathv[pathc - 3] = str;
d315 1
a315 2
	if (pathc > 3) {
	    str = pathv[pathc - 3];
a317 1
	    pathv[pathc - 3] = str;
d322 1
a322 2
	if (pathc > 4) {
	    str = pathv[pathc - 4];
a324 1
	    pathv[pathc - 4] = str;
d338 1
a338 11
    {
#ifdef HAVE_CFBUNDLE
    char tclLibPath[1024];
    
    if (Tcl_MacOSXGetLibraryPath(NULL, 1024, tclLibPath) == TCL_OK) {
        str = tclLibPath;
    } else
#endif /* HAVE_CFBUNDLE */
    {
        str = defaultLibraryDir;
    }
a342 1
    }
d356 1
a356 4
 *	Called at process initialization time, and part way through
 *	startup, we verify that the initial encodings were correctly
 *	setup.  Depending on Tcl's environment, there may not have been
 *	enough information first time through (above).
d362 1
a362 3
 *	The Tcl library path is converted from native encoding to UTF-8,
 *	on the first call, and the encodings may be changed on first or
 *	second call.
d370 4
a373 4
    if (libraryPathEncodingFixed == 0) {
	CONST char *encoding = NULL;
	int i, setSysEncCode = TCL_ERROR;
	Tcl_Obj *pathPtr;
d375 5
a379 8
	/*
	 * Determine the current encoding from the LC_* or LANG environment
	 * variables.  We previously used setlocale() to determine the locale,
	 * but this does not work on some systems (e.g. Linux/i386 RH 5.0).
	 */
#ifdef HAVE_LANGINFO
	if (setlocale(LC_CTYPE, "") != NULL) {
	    Tcl_DString ds;
d381 1
a381 4
	    /*
	     * Use a DString so we can overwrite it in name compatability
	     * checks below.
	     */
d383 9
a391 2
	    Tcl_DStringInit(&ds);
	    encoding = Tcl_DStringAppend(&ds, nl_langinfo(CODESET), -1);
d393 6
a398 22
	    Tcl_UtfToLower(Tcl_DStringValue(&ds));
#ifdef HAVE_LANGINFO_DEBUG
	    fprintf(stderr, "encoding '%s'", encoding);
#endif
	    if (encoding[0] == 'i' && encoding[1] == 's' && encoding[2] == 'o'
		    && encoding[3] == '-') {
		char *p, *q;
		/* need to strip '-' from iso-* encoding */
		for(p = Tcl_DStringValue(&ds)+3, q = Tcl_DStringValue(&ds)+4;
		    *p; *p++ = *q++);
	    } else if (encoding[0] == 'i' && encoding[1] == 'b'
		    && encoding[2] == 'm' && encoding[3] >= '0'
		    && encoding[3] <= '9') {
		char *p, *q;
		/* if langinfo reports "ibm*" we should use "cp*" */
		p = Tcl_DStringValue(&ds);
		*p++ = 'c'; *p++ = 'p';
		for(q = p+1; *p ; *p++ = *q++);
	    } else if ((*encoding == '\0')
		    || !strcmp(encoding, "ansi_x3.4-1968")) {
		/* Use iso8859-1 for empty or 'ansi_x3.4-1968' encoding */
		encoding = "iso8859-1";
a399 24
#ifdef HAVE_LANGINFO_DEBUG
	    fprintf(stderr, " ?%s?", encoding);
#endif
	    setSysEncCode = Tcl_SetSystemEncoding(NULL, encoding);
	    if (setSysEncCode != TCL_OK) {
		/*
		 * If this doesn't return TCL_OK, the encoding returned by
		 * nl_langinfo or as we translated it wasn't accepted.  Do
		 * this fallback check.  If this fails, we will enter the
		 * old fallback below.
		 */

		for (i = 0; localeTable[i].lang != NULL; i++) {
		    if (strcmp(localeTable[i].lang, encoding) == 0) {
			setSysEncCode = Tcl_SetSystemEncoding(NULL,
				localeTable[i].encoding);
			break;
		    }
		}
	    }
#ifdef HAVE_LANGINFO_DEBUG
	    fprintf(stderr, " => '%s'\n", encoding);
#endif
	    Tcl_DStringFree(&ds);
d401 4
a404 6
#ifdef HAVE_LANGINFO_DEBUG
	else {
	    fprintf(stderr, "setlocale returned NULL\n");
	}
#endif
#endif /* HAVE_LANGINFO */
d406 7
a412 16
	if (setSysEncCode != TCL_OK) {
	    /*
	     * Classic fallback check.  This tries a homebrew algorithm to
	     * determine what encoding should be used based on env vars.
	     */
	    char *langEnv = getenv("LC_ALL");
	    encoding = NULL;

	    if (langEnv == NULL || langEnv[0] == '\0') {
		langEnv = getenv("LC_CTYPE");
	    }
	    if (langEnv == NULL || langEnv[0] == '\0') {
		langEnv = getenv("LANG");
	    }
	    if (langEnv == NULL || langEnv[0] == '\0') {
		langEnv = NULL;
d414 4
d419 5
a423 6
	    if (langEnv != NULL) {
		for (i = 0; localeTable[i].lang != NULL; i++) {
		    if (strcmp(localeTable[i].lang, langEnv) == 0) {
			encoding = localeTable[i].encoding;
			break;
		    }
d425 2
a426 30
		/*
		 * There was no mapping in the locale table.  If there is an
		 * encoding subfield, we can try to guess from that.
		 */

		if (encoding == NULL) {
		    char *p;
		    for (p = langEnv; *p != '\0'; p++) {
			if (*p == '.') {
			    p++;
			    break;
			}
		    }
		    if (*p != '\0') {
			Tcl_DString ds;
			Tcl_DStringInit(&ds);
			encoding = Tcl_DStringAppend(&ds, p, -1);

			Tcl_UtfToLower(Tcl_DStringValue(&ds));
			setSysEncCode = Tcl_SetSystemEncoding(NULL, encoding);
			if (setSysEncCode != TCL_OK) {
			    encoding = NULL;
			}
			Tcl_DStringFree(&ds);
		    }
		}
#ifdef HAVE_LANGINFO_DEBUG
		fprintf(stderr, "encoding fallback check '%s' => '%s'\n",
			langEnv, encoding);
#endif
d428 7
a434 4
	    if (setSysEncCode != TCL_OK) {
		if (encoding == NULL) {
		    encoding = TCL_DEFAULT_ENCODING;
		}
d436 9
a444 2
		Tcl_SetSystemEncoding(NULL, encoding);
	    }
d446 1
a446 13
	    /*
	     * Initialize the C library's locale subsystem.  This is required
	     * for input methods to work properly on X11.  We only do this for
	     * LC_CTYPE because that's the necessary one, and we don't want to
	     * affect LC_TIME here.  The side effect of setting the default
	     * locale should be to load any locale specific modules that are
	     * needed by X.  [BUG: 5422 3345 4236 2522 2521].
	     * In HAVE_LANGINFO, this call is already done above.
	     */
#ifndef HAVE_LANGINFO
	    setlocale(LC_CTYPE, "");
#endif
	}
d448 6
a453 6
	/*
	 * In case the initial locale is not "C", ensure that the numeric
	 * processing is done in "C" locale regardless.  This is needed because
	 * Tcl relies on routines like strtod, but should not have locale
	 * dependent behavior.
	 */
d455 1
a455 1
	setlocale(LC_NUMERIC, "C");
d457 21
a477 21
	/*
	 * Until the system encoding was actually set, the library path was
	 * actually in the native multi-byte encoding, and not really UTF-8
	 * as advertised.  We cheated as follows:
	 *
	 * 1. It was safe to allow the Tcl_SetSystemEncoding() call to 
	 * append the ASCII chars that make up the encoding's filename to 
	 * the names (in the native encoding) of directories in the library 
	 * path, since all Unix multi-byte encodings have ASCII in the
	 * beginning.
	 *
	 * 2. To open the encoding file, the native bytes in the file name
	 * were passed to the OS, without translating from UTF-8 to native,
	 * because the name was already in the native encoding.
	 *
	 * Now that the system encoding was actually successfully set,
	 * translate all the names in the library path to UTF-8.  That way,
	 * next time we search the library path, we'll translate the names 
	 * from UTF-8 to the system encoding which will be the native 
	 * encoding.
	 */
d479 11
a489 11
	pathPtr = TclGetLibraryPath();
	if (pathPtr != NULL) {
	    int objc;
	    Tcl_Obj **objv;
	    
	    objc = 0;
	    Tcl_ListObjGetElements(NULL, pathPtr, &objc, &objv);
	    for (i = 0; i < objc; i++) {
		int length;
		char *string;
		Tcl_DString ds;
d491 5
a495 6
		string = Tcl_GetStringFromObj(objv[i], &length);
		Tcl_ExternalToUtfDString(NULL, string, length, &ds);
		Tcl_SetStringObj(objv[i], Tcl_DStringValue(&ds), 
			Tcl_DStringLength(&ds));
		Tcl_DStringFree(&ds);
	    }
d497 6
d504 1
a504 11
	libraryPathEncodingFixed = 1;
    }
    
    /* This is only ever called from the startup thread */
    if (binaryEncoding == NULL) {
	/*
	 * Keep the iso8859-1 encoding preloaded.  The IO package uses
	 * it for gets on a binary channel.
	 */
	binaryEncoding = Tcl_GetEncoding(NULL, "iso8859-1");
    }
d534 1
a534 1
    CONST char *user;
d537 2
a538 23
#ifdef HAVE_CFBUNDLE
    char tclLibPath[1024];
    
    if (Tcl_MacOSXGetLibraryPath(interp, 1024, tclLibPath) == TCL_OK) {
        Tcl_SetVar(interp, "tclDefaultLibrary", tclLibPath, 
                TCL_GLOBAL_ONLY);
        Tcl_SetVar(interp, "tcl_pkgPath", tclLibPath,
                TCL_GLOBAL_ONLY);
        Tcl_SetVar(interp, "tcl_pkgPath", " ",
                TCL_GLOBAL_ONLY | TCL_APPEND_VALUE);
        Tcl_SetVar(interp, "tcl_pkgPath", pkgPath,
                TCL_GLOBAL_ONLY | TCL_APPEND_VALUE);
    } else
#endif /* HAVE_CFBUNDLE */
    {
        Tcl_SetVar(interp, "tclDefaultLibrary", defaultLibraryDir, 
                TCL_GLOBAL_ONLY);
        Tcl_SetVar(interp, "tcl_pkgPath", pkgPath, TCL_GLOBAL_ONLY);
    }

#ifdef DJGPP
    Tcl_SetVar2(interp, "tcl_platform", "platform", "dos", TCL_GLOBAL_ONLY);
#else
a539 1
#endif
d543 1
a543 1
	CONST char *native;
d718 1
a718 1
    CONST char *fileName;
d725 1
a725 1
	CONST char *fullName;
a782 29

#ifdef HAVE_CFBUNDLE
/*
 *----------------------------------------------------------------------
 *
 * Tcl_MacOSXGetLibraryPath --
 *
 *	If we have a bundle structure for the Tcl installation,
 *	then check there first to see if we can find the libraries
 *	there.
 *
 * Results:
 *	TCL_OK if we have found the tcl library; TCL_ERROR otherwise.
 *
 * Side effects:
 *	Same as for Tcl_MacOSXOpenBundleResources.
 *
 *----------------------------------------------------------------------
 */
static int Tcl_MacOSXGetLibraryPath(Tcl_Interp *interp, int maxPathLen, char *tclLibPath)
{
    int foundInFramework = TCL_ERROR;
    if (strcmp(defaultLibraryDir, "@@TCL_IN_FRAMEWORK@@") == 0) {
	foundInFramework = Tcl_MacOSXOpenBundleResources(interp, 
	    "com.tcltk.tcllibrary", 0, maxPathLen, tclLibPath);
    }
    return foundInFramework;
}
#endif /* HAVE_CFBUNDLE */
@


1.1.1.4
log
@import tcl 8.4.1
@
text
@d10 1
a10 1
 * RCS: @@(#) $Id: tclUnixInit.c,v 1.34 2002/10/22 16:41:28 das Exp $
d407 1
a407 1
    char tclLibPath[MAXPATHLEN + 1];
d409 1
a409 1
    if (Tcl_MacOSXGetLibraryPath(NULL, MAXPATHLEN, tclLibPath) == TCL_OK) {
d703 1
a703 1
    char tclLibPath[MAXPATHLEN + 1];
d705 1
a705 5
    if (Tcl_MacOSXGetLibraryPath(interp, MAXPATHLEN, tclLibPath) == TCL_OK) {
        CONST char *str;
        Tcl_DString ds;
        CFBundleRef bundleRef;

a711 41
        str = TclGetEnv("DYLD_FRAMEWORK_PATH", &ds);
        if ((str != NULL) && (str[0] != '\0')) {
            char *p = Tcl_DStringValue(&ds);
            /* convert DYLD_FRAMEWORK_PATH from colon to space separated */
            do {
                if(*p == ':') *p = ' ';
            } while (*p++);
            Tcl_SetVar(interp, "tcl_pkgPath", Tcl_DStringValue(&ds),
                    TCL_GLOBAL_ONLY | TCL_APPEND_VALUE);
            Tcl_SetVar(interp, "tcl_pkgPath", " ",
                    TCL_GLOBAL_ONLY | TCL_APPEND_VALUE);
            Tcl_DStringFree(&ds);
        }
        if ((bundleRef = CFBundleGetMainBundle())) {
            CFURLRef frameworksURL;
            Tcl_StatBuf statBuf;
            if((frameworksURL = CFBundleCopyPrivateFrameworksURL(bundleRef))) {
                if(CFURLGetFileSystemRepresentation(frameworksURL, TRUE,
                            tclLibPath, MAXPATHLEN) &&
                        ! TclOSstat(tclLibPath, &statBuf) &&
                        S_ISDIR(statBuf.st_mode)) {
                    Tcl_SetVar(interp, "tcl_pkgPath", tclLibPath,
                            TCL_GLOBAL_ONLY | TCL_APPEND_VALUE);
                    Tcl_SetVar(interp, "tcl_pkgPath", " ",
                            TCL_GLOBAL_ONLY | TCL_APPEND_VALUE);
                }
                CFRelease(frameworksURL);
            }
            if((frameworksURL = CFBundleCopySharedFrameworksURL(bundleRef))) {
                if(CFURLGetFileSystemRepresentation(frameworksURL, TRUE,
                            tclLibPath, MAXPATHLEN) &&
                        ! TclOSstat(tclLibPath, &statBuf) &&
                        S_ISDIR(statBuf.st_mode)) {
                    Tcl_SetVar(interp, "tcl_pkgPath", tclLibPath,
                            TCL_GLOBAL_ONLY | TCL_APPEND_VALUE);
                    Tcl_SetVar(interp, "tcl_pkgPath", " ",
                            TCL_GLOBAL_ONLY | TCL_APPEND_VALUE);
                }
                CFRelease(frameworksURL);
            }
        }
@


