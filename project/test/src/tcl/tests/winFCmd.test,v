head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.58
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.56
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.54
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.52
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.50
	gdb_7_0-branch:1.5.0.48
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tcl8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.46
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.44
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.42
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.40
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.38
	gdb_6_5-2006-05-14-branchpoint:1.5
	readline_5_1-import-branch:1.5.0.36
	readline_5_1-import-branchpoint:1.5
	gdb_6_4-branch:1.5.0.34
	gdb_6_4-2005-11-01-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.32
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	ezannoni_pie-20040323-branch:1.5.0.30
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.28
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.26
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.24
	cagney_x86i386-20030821-branch:1.5.0.22
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.20
	gdb_6_0-2003-06-23-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.18
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.16
	cagney_writestrings-20030508-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.14
	cagney_fileio-20030521-branchpoint:1.5
	carlton_dictionary-20030430-merge:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.12
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.10
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.8
	cagney_lazyid-20030317-branchpoint:1.5
	offbyone-20030313-branch:1.5.0.6
	offbyone-20030313-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.4
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.2
	interps-20030202-branchpoint:1.5
	TCL8_4_1:1.1.1.4
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.2
	TCL_8_4_1:1.1.1.4
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.4
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TCL_8_4_0:1.1.1.3
	carlton_dictionary-branch:1.2.0.16
	carlton_dictionary-20020920-branchpoint:1.2
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.14
	gdb_5_3-branch:1.2.0.12
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.10
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.8
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.6
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TCL_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	dejagnu-2000-02-04:1.1.1.1
	dejagnu-2000-01-31:1.1.1.1
	dejagnu-2000-01-24:1.1.1.1
	dejagnu-2000-01-17:1.1.1.1
	dejagnu-2000-01-10:1.1.1.1
	dejagnu-2000-01-04:1.1.1.1
	dejagnu-1999-12-21:1.1.1.1
	dejagnu-1999-12-13:1.1.1.1
	dejagnu-1999-12-07:1.1.1.1
	dejagnu-1999-12-06:1.1.1.1
	dejagnu-1999-11-15:1.1.1.1
	dejagnu-1999-11-08:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2003.01.21.19.40.17;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.26.19.48.03;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.37.08;	author kseitz;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2001.09.09.23.56.08;	author irox;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2002.09.27.21.49.11;	author kseitz;	state Exp;
branches;
next	;

1.3.4.1
date	2003.12.14.20.28.50;	author drow;	state Exp;
branches;
next	;

1.2.16.1
date	2002.12.23.19.40.46;	author carlton;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2003.02.07.19.18.20;	author carlton;	state Exp;
branches;
next	;

1.1.1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.09.22.40.59;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.19.56.42;	author kseitz;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.11.26.20.01.15;	author hunt;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tcl 8.4.1
@
text
@# This file tests the tclWinFCmd.c file.
#
# This file contains a collection of tests for one or more of the Tcl
# built-in commands.  Sourcing this file into Tcl runs the tests and
# generates output for errors.  No output means no errors were found.
#
# Copyright (c) 1996-1997 Sun Microsystems, Inc.
# Copyright (c) 1998-1999 by Scriptics Corporation.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# RCS: @@(#) $Id: winFCmd.test,v 1.20 2002/10/04 08:25:14 dkf Exp $
#

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import -force ::tcltest::*
}

proc createfile {file {string a}} {
    set f [open $file w]
    puts -nonewline $f $string
    close $f
    return $string
}

proc contents {file} {
    set f [open $file r]
    set r [read $f]
    close $f
    set r
}

proc cleanup {args} {
    foreach p ". $args" {
	set x ""
	catch {
	    set x [glob -directory $p tf* td*]
	}
	if {$x != ""} {
	    catch {eval file delete -force -- $x}
	}
    }
}

if {[string equal $tcl_platform(platform) "windows"]} {
    if {[string equal $tcl_platform(os) "Windows NT"] \
      && [string equal [string index $tcl_platform(osVersion) 0] "5"]} {
	tcltest::testConstraint win2000orXP 1
	tcltest::testConstraint winOlderThan2000 0
    } else {
	tcltest::testConstraint win2000orXP 0
	tcltest::testConstraint winOlderThan2000 1
    }
} else {
    tcltest::testConstraint win2000orXP 0
    tcltest::testConstraint winOlderThan2000 0
}

set ::tcltest::testConstraints(cdrom) 0
set ::tcltest::testConstraints(exdev) 0

# find a CD-ROM so we can test read-only filesystems.

set cdrom {}
set nodrive x:
foreach p {d e f g h i j k l m n o p q r s t u v w x y z} {
    set name ${p}:/dummy~~.fil
    if [catch {set fd [open $name w]}] {
	set err [lindex $errorCode 1]
        if {$cdrom == "" && $err == "EACCES"} {
	    set cdrom ${p}:
	}
	if {$err == "ENOENT"} {
	    set nodrive ${p}:
	}
    } else {
        close $fd
	file delete $name
    }
}

proc findfile {dir} {
    foreach p [glob $dir/*] {
        if {[file type $p] == "file"} {
	    return $p
	}
    }
    foreach p [glob $dir/*] {
        if {[file type $p] == "directory"} {
	    set f [findfile $p]
	    if {$f != ""} {
	        return $f
	    }
	}
    }
    return ""
}

if {$cdrom != ""} {
    set ::tcltest::testConstraints(cdrom) 1
    set cdfile [findfile $cdrom]
}

if {[file exists c:/] && [file exists d:/]} {
    catch {file delete d:/tf1}
    if {[catch {close [open d:/tf1 w]}] == 0} {
	file delete d:/tf1
	set ::tcltest::testConstraints(exdev) 1
    }
}

file delete -force -- td1
set foo [catch {open td1 w} testfile]
if {$foo} {
    set ::tcltest::testConstraints(longFileNames) 0
} else {
    close $testfile
    set ::tcltest::testConstraints(longFileNames) 1
    file delete -force -- td1
}

# A really long file name
# length of longname is 1216 chars, which should be greater than any static
# buffer or allowable filename.

set longname "abcdefghihjllmnopqrstuvwxyz01234567890"
append longname $longname
append longname $longname
append longname $longname
append longname $longname
append longname $longname

# Uses the "testfile" command instead of the "file" command.  The "file"
# command provides several layers of sanity checks on the arguments and
# it can be difficult to actually forward "insane" arguments to the
# low-level posix emulation layer.

test winFCmd-1.1 {TclpRenameFile: errno: EACCES} {pcOnly cdrom} {
    list [catch {testfile mv $cdfile $cdrom/dummy~~.fil} msg] $msg
} {1 EACCES}
test winFCmd-1.2 {TclpRenameFile: errno: EEXIST} {pcOnly} {
    cleanup
    file mkdir td1/td2/td3
    file mkdir td2
    list [catch {testfile mv td2 td1/td2} msg] $msg
} {1 EEXIST} 
test winFCmd-1.3 {TclpRenameFile: errno: EINVAL} {pcOnly} {
    cleanup
    list [catch {testfile mv / td1} msg] $msg
} {1 EINVAL}
test winFCmd-1.4 {TclpRenameFile: errno: EINVAL} {pcOnly} {
    cleanup
    file mkdir td1
    list [catch {testfile mv td1 td1/td2} msg] $msg
} {1 EINVAL}
test winFCmd-1.5 {TclpRenameFile: errno: EISDIR} {pcOnly} {
    cleanup
    file mkdir td1
    createfile tf1
    list [catch {testfile mv tf1 td1} msg] $msg
} {1 EISDIR}
test winFCmd-1.6 {TclpRenameFile: errno: ENOENT} {pcOnly} {
    cleanup
    list [catch {testfile mv tf1 tf2} msg] $msg
} {1 ENOENT}
test winFCmd-1.7 {TclpRenameFile: errno: ENOENT} {pcOnly} {
    cleanup
    list [catch {testfile mv "" tf2} msg] $msg
} {1 ENOENT}
test winFCmd-1.8 {TclpRenameFile: errno: ENOENT} {pcOnly} {
    cleanup
    createfile tf1
    list [catch {testfile mv tf1 ""} msg] $msg
} {1 ENOENT}
test winFCmd-1.9 {TclpRenameFile: errno: ENOTDIR} {pcOnly} {
    cleanup
    file mkdir td1
    createfile tf1
    list [catch {testfile mv td1 tf1} msg] $msg
} {1 ENOTDIR}
test winFCmd-1.10 {TclpRenameFile: errno: EXDEV} {pcOnly exdev} {
    file delete -force d:/tf1
    file mkdir c:/tf1
    set msg [list [catch {testfile mv c:/tf1 d:/tf1} msg] $msg]
    file delete -force c:/tf1
    set msg
} {1 EXDEV}
test winFCmd-1.11 {TclpRenameFile: errno: EACCES} {pcOnly} {
    cleanup
    set fd [open tf1 w]
    set msg [list [catch {testfile mv tf1 tf2} msg] $msg]
    close $fd
    set msg
} {1 EACCES}
test winFCmd-1.12 {TclpRenameFile: errno: EACCES} {pcOnly} {
    cleanup
    createfile tf1
    set fd [open tf2 w]
    set msg [list [catch {testfile mv tf1 tf2} msg] $msg]
    close $fd
    set msg
} {1 EACCES}
test winFCmd-1.13 {TclpRenameFile: errno: EACCES} {pcOnly win2000orXP} {
    cleanup
    list [catch {testfile mv nul tf1} msg] $msg
} {1 EINVAL}
test winFCmd-1.13.1 {TclpRenameFile: errno: EACCES} {pcOnly winOlderThan2000} {
    cleanup
    list [catch {testfile mv nul tf1} msg] $msg
} {1 EACCES}
test winFCmd-1.14 {TclpRenameFile: errno: EACCES} {pcOnly 95} {
    cleanup
    createfile tf1
    list [catch {testfile mv tf1 nul} msg] $msg
} {1 EACCES}
test winFCmd-1.15 {TclpRenameFile: errno: EEXIST} {pcOnly nt} {
    cleanup
    createfile tf1
    list [catch {testfile mv tf1 nul} msg] $msg
} {1 EEXIST}
test winFCmd-1.16 {TclpRenameFile: MoveFile() != FALSE} {pcOnly} {
    cleanup
    createfile tf1 tf1
    testfile mv tf1 tf2
    list [file exists tf1] [contents tf2]
} {0 tf1}
test winFCmd-1.17 {TclpRenameFile: MoveFile() == FALSE} {pcOnly} {
    cleanup
    list [catch {testfile mv tf1 tf2} msg] $msg
} {1 ENOENT} 
test winFCmd-1.18 {TclpRenameFile: srcAttr == -1} {pcOnly} {
    cleanup
    list [catch {testfile mv tf1 tf2} msg] $msg
} {1 ENOENT} 
test winFCmd-1.19 {TclpRenameFile: errno == EACCES} {pcOnly win2000orXP} {
    cleanup
    list [catch {testfile mv nul tf1} msg] $msg
} {1 EINVAL}
test winFCmd-1.19.1 {TclpRenameFile: errno == EACCES} {pcOnly winOlderThan2000} {
    cleanup
    list [catch {testfile mv nul tf1} msg] $msg
} {1 EACCES}
test winFCmd-1.20 {TclpRenameFile: src is dir} {pcOnly nt} {
    # under 95, this would actually succeed and move the current dir out from 
    # under the current process!
    cleanup
    file delete /tf1
    list [catch {testfile mv [pwd] /tf1} msg] $msg
} {1 EACCES}
test winFCmd-1.21 {TclpRenameFile: long src} {pcOnly} {
    cleanup
    list [catch {testfile mv $longname tf1} msg] $msg
} {1 ENAMETOOLONG}
test winFCmd-1.22 {TclpRenameFile: long dst} {pcOnly} {
    cleanup
    createfile tf1
    list [catch {testfile mv tf1 $longname} msg] $msg
} {1 ENAMETOOLONG}
test winFCmd-1.23 {TclpRenameFile: move dir into self} {pcOnly} {
    cleanup
    file mkdir td1
    list [catch {testfile mv [pwd]/td1 td1/td2} msg] $msg
} {1 EINVAL}
test winFCmd-1.24 {TclpRenameFile: move a root dir} {pcOnly} {
    cleanup
    list [catch {testfile mv / c:/} msg] $msg
} {1 EINVAL}
test winFCmd-1.25 {TclpRenameFile: cross file systems} {pcOnly cdrom} {
    cleanup
    file mkdir td1
    list [catch {testfile mv td1 $cdrom/td1} msg] $msg
} {1 EXDEV} 
test winFCmd-1.26 {TclpRenameFile: readonly fs} {pcOnly cdrom} {
    cleanup
    list [catch {testfile mv $cdfile $cdrom/dummy~~.fil} msg] $msg
} {1 EACCES}
test winFCmd-1.27 {TclpRenameFile: open file} {pcOnly} {
    cleanup
    set fd [open tf1 w]
    set msg [list [catch {testfile mv tf1 tf2} msg] $msg]
    close $fd
    set msg
} {1 EACCES}    
test winFCmd-1.28 {TclpRenameFile: errno == EEXIST} {pcOnly} {
    cleanup
    createfile tf1
    createfile tf2
    testfile mv tf1 tf2
    list [file exists tf1] [file exists tf2]
} {0 1}
test winFCmd-1.29 {TclpRenameFile: src is dir} {pcOnly} {
    cleanup
    file mkdir td1
    createfile tf1
    list [catch {testfile mv td1 tf1} msg] $msg
} {1 ENOTDIR} 
test winFCmd-1.30 {TclpRenameFile: dst is dir} {pcOnly} {
    cleanup
    file mkdir td1
    file mkdir td2/td2
    list [catch {testfile mv td1 td2} msg] $msg
} {1 EEXIST}
test winFCmd-1.31 {TclpRenameFile: TclpRemoveDirectory fails} {pcOnly} {
    cleanup
    file mkdir td1
    file mkdir td2/td2
    list [catch {testfile mv td1 td2} msg] $msg
} {1 EEXIST}
test winFCmd-1.32 {TclpRenameFile: TclpRemoveDirectory succeeds} {pcOnly} {
    cleanup
    file mkdir td1/td2
    file mkdir td2
    testfile mv td1 td2
    list [file exists td1] [file exists td2] [file exists td2/td2]
} {0 1 1}
test winFCmd-1.33 {TclpRenameFile: After removing dst dir, MoveFile fails} \
	{pcOnly exdev} {
    file mkdir d:/td1
    testchmod 000 d:/td1
    file mkdir c:/tf1
    set msg [list [catch {testfile mv c:/tf1 d:/td1} msg] $msg]
    set msg "$msg [file writable d:/td1]"
    file delete d:/td1
    file delete -force c:/tf1
    set msg
} {1 EXDEV 0}
test winFCmd-1.34 {TclpRenameFile: src is dir, dst is not} {pcOnly} {
    file mkdir td1
    createfile tf1
    list [catch {testfile mv td1 tf1} msg] $msg
} {1 ENOTDIR}
test winFCmd-1.35 {TclpRenameFile: src is not dir, dst is} {pcOnly} {
    file mkdir td1
    createfile tf1
    list [catch {testfile mv tf1 td1} msg] $msg
} {1 EISDIR}
test winFCmd-1.36 {TclpRenameFile: src and dst not dir} {pcOnly} {
    createfile tf1 tf1
    createfile tf2 tf2
    testfile mv tf1 tf2
    contents tf2
} {tf1}
test winFCmd-1.37 {TclpRenameFile: need to restore temp file} {pcOnly} {
    # Can't figure out how to cause this. 
    # Need a file that can't be copied.
} {}

test winFCmd-2.1 {TclpCopyFile: errno: EACCES} {pcOnly cdrom} {
    cleanup
    list [catch {testfile cp $cdfile $cdrom/dummy~~.fil} msg] $msg
} {1 EACCES}
test winFCmd-2.2 {TclpCopyFile: errno: EISDIR} {pcOnly} {
    cleanup
    file mkdir td1
    list [catch {testfile cp td1 tf1} msg] $msg
} {1 EISDIR}
test winFCmd-2.3 {TclpCopyFile: errno: EISDIR} {pcOnly} {
    cleanup
    createfile tf1
    file mkdir td1
    list [catch {testfile cp tf1 td1} msg] $msg
} {1 EISDIR}
test winFCmd-2.4 {TclpCopyFile: errno: ENOENT} {pcOnly} {
    cleanup
    list [catch {testfile cp tf1 tf2} msg] $msg
} {1 ENOENT}
test winFCmd-2.5 {TclpCopyFile: errno: ENOENT} {pcOnly} {
    cleanup
    list [catch {testfile cp "" tf2} msg] $msg
} {1 ENOENT}
test winFCmd-2.6 {TclpCopyFile: errno: ENOENT} {pcOnly} {
    cleanup
    createfile tf1
    list [catch {testfile cp tf1 ""} msg] $msg
} {1 ENOENT}
test winFCmd-2.7 {TclpCopyFile: errno: EACCES} {pcOnly 95} {
    cleanup
    createfile tf1
    set fd [open tf2 w]
    set msg [list [catch {testfile cp tf1 tf2} msg] $msg]
    close $fd
    set msg
} {1 EACCES}
test winFCmd-2.8 {TclpCopyFile: errno: EACCES} {pcOnly win2000orXP} {
    cleanup
    list [catch {testfile cp nul tf1} msg] $msg
} {1 EINVAL}
test winFCmd-2.8.1 {TclpCopyFile: errno: EACCES} {pcOnly nt winOlderThan2000} {
    cleanup
    list [catch {testfile cp nul tf1} msg] $msg
} {1 EACCES}
test winFCmd-2.9 {TclpCopyFile: errno: ENOENT} {pcOnly 95} {
    cleanup
    list [catch {testfile cp nul tf1} msg] $msg
} {1 ENOENT}
test winFCmd-2.10 {TclpCopyFile: CopyFile succeeds} {pcOnly} {
    cleanup
    createfile tf1 tf1
    testfile cp tf1 tf2
    list [contents tf1] [contents tf2]
} {tf1 tf1}
test winFCmd-2.11 {TclpCopyFile: CopyFile succeeds} {pcOnly} {
    cleanup
    createfile tf1 tf1
    createfile tf2 tf2
    testfile cp tf1 tf2
    list [contents tf1] [contents tf2]
} {tf1 tf1}
test winFCmd-2.12 {TclpCopyFile: CopyFile succeeds} {pcOnly} {
    cleanup
    createfile tf1 tf1
    testchmod 000 tf1
    testfile cp tf1 tf2
    list [contents tf2] [file writable tf2]
} {tf1 0}
test winFCmd-2.13 {TclpCopyFile: CopyFile fails} {pcOnly} {
    cleanup
    createfile tf1
    file mkdir td1
    list [catch {testfile cp tf1 td1} msg] $msg
} {1 EISDIR} 
test winFCmd-2.14 {TclpCopyFile: errno == EACCES} {pcOnly} {
    cleanup
    file mkdir td1
    list [catch {testfile cp td1 tf1} msg] $msg
} {1 EISDIR}
test winFCmd-2.15 {TclpCopyFile: src is directory} {pcOnly} {
    cleanup
    file mkdir td1
    list [catch {testfile cp td1 tf1} msg] $msg
} {1 EISDIR}
test winFCmd-2.16 {TclpCopyFile: dst is directory} {pcOnly} {
    cleanup
    createfile tf1
    file mkdir td1
    list [catch {testfile cp tf1 td1} msg] $msg
} {1 EISDIR}
test winFCmd-2.17 {TclpCopyFile: dst is readonly} {pcOnly} {
    cleanup
    createfile tf1 tf1
    createfile tf2 tf2
    testchmod 000 tf2
    testfile cp tf1 tf2
    list [file writable tf2] [contents tf2]
} {1 tf1}
test winFCmd-2.18 {TclpCopyFile: still can't copy onto dst} {pcOnly 95} {
    cleanup
    createfile tf1
    createfile tf2
    testchmod 000 tf2
    set fd [open tf2]
    set msg [list [catch {testfile cp tf1 tf2} msg] $msg]
    close $fd
    set msg "$msg [file writable tf2]"
} {1 EACCES 0}    

test winFCmd-3.1 {TclpDeleteFile: errno: EACCES} {pcOnly cdrom} {
    list [catch {testfile rm $cdfile $cdrom/dummy~~.fil} msg] $msg
} {1 EACCES}
test winFCmd-3.2 {TclpDeleteFile: errno: EISDIR} {pcOnly} {
    cleanup
    file mkdir td1
    list [catch {testfile rm td1} msg] $msg
} {1 EISDIR} 
test winFCmd-3.3 {TclpDeleteFile: errno: ENOENT} {pcOnly} {
    cleanup
    list [catch {testfile rm tf1} msg] $msg
} {1 ENOENT}
test winFCmd-3.4 {TclpDeleteFile: errno: ENOENT} {pcOnly} {
    cleanup
    list [catch {testfile rm ""} msg] $msg
} {1 ENOENT}
test winFCmd-3.5 {TclpDeleteFile: errno: EACCES} {pcOnly} {
    cleanup
    set fd [open tf1 w]
    set msg [list [catch {testfile rm tf1} msg] $msg]
    close $fd
    set msg
} {1 EACCES}
test winFCmd-3.6 {TclpDeleteFile: errno: EACCES} {pcOnly} {
    cleanup
    list [catch {testfile rm nul} msg] $msg
} {1 EACCES}
test winFCmd-3.7 {TclpDeleteFile: DeleteFile succeeds} {pcOnly} {
    cleanup
    createfile tf1
    testfile rm tf1
    file exists tf1
} {0}
test winFCmd-3.8 {TclpDeleteFile: DeleteFile fails} {pcOnly} {
    cleanup
    file mkdir td1
    list [catch {testfile rm td1} msg] $msg
} {1 EISDIR}
test winFCmd-3.9 {TclpDeleteFile: errno == EACCES} {pcOnly} {
    cleanup
    set fd [open tf1 w]
    set msg [list [catch {testfile rm tf1} msg] $msg]
    close $fd
    set msg
} {1 EACCES}
test winFCmd-3.10 {TclpDeleteFile: path is readonly} {pcOnly} {
    cleanup
    createfile tf1
    testchmod 000 tf1
    testfile rm tf1
    file exists tf1
} {0}
test winFCmd-3.11 {TclpDeleteFile: still can't remove path} {pcOnly} {
    cleanup
    set fd [open tf1 w]
    testchmod 000 tf1
    set msg [list [catch {testfile rm tf1} msg] $msg]
    close $fd
    set msg
} {1 EACCES}

test winFCmd-4.1 {TclpCreateDirectory: errno: EACCES} {pcOnly nt cdrom} {
    list [catch {testfile mkdir $cdrom/dummy~~.dir} msg] $msg
} {1 EACCES}
test winFCmd-4.2 {TclpCreateDirectory: errno: EACCES} {pcOnly 95 cdrom} {
    list [catch {testfile mkdir $cdrom/dummy~~.dir} msg] $msg
} {1 ENOSPC}
test winFCmd-4.3 {TclpCreateDirectory: errno: EEXIST} {pcOnly} {
    cleanup
    file mkdir td1
    list [catch {testfile mkdir td1} msg] $msg
} {1 EEXIST}
test winFCmd-4.4 {TclpCreateDirectory: errno: ENOENT} {pcOnly} {
    cleanup
    list [catch {testfile mkdir td1/td2} msg] $msg
} {1 ENOENT}
test winFCmd-4.5 {TclpCreateDirectory: CreateDirectory succeeds} {pcOnly} {
    cleanup
    testfile mkdir td1
    file type td1
} {directory}

test winFCmd-5.1 {TclpCopyDirectory: calls TraverseWinTree} {pcOnly} {
    cleanup
    file mkdir td1
    testfile cpdir td1 td2
    list [file type td1] [file type td2]
} {directory directory}

test winFCmd-6.1 {TclpRemoveDirectory: errno: EACCES} {pcOnly} {
    cleanup
    file mkdir td1
    testchmod 000 td1
    testfile rmdir td1
    file exists td1
} {0}
test winFCmd-6.2 {TclpRemoveDirectory: errno: EEXIST} {pcOnly} {
    cleanup
    file mkdir td1/td2
    list [catch {testfile rmdir td1} msg] [file tail $msg]
} {1 {td1 EEXIST}}
test winFCmd-6.3 {TclpRemoveDirectory: errno: EACCES} {pcOnly} {
    # can't test this w/o removing everything on your hard disk first!
    # testfile rmdir /
} {}
test winFCmd-6.4 {TclpRemoveDirectory: errno: ENOENT} {pcOnly} {
    cleanup
    list [catch {testfile rmdir td1} msg] [file tail $msg]
} {1 {td1 ENOENT}}
test winFCmd-6.5 {TclpRemoveDirectory: errno: ENOENT} {pcOnly} {
    cleanup
    list [catch {testfile rmdir ""} msg] $msg
} {1 ENOENT}
test winFCmd-6.6 {TclpRemoveDirectory: errno: ENOTDIR} {pcOnly} {
    cleanup
    createfile tf1
    list [catch {testfile rmdir tf1} msg] [file tail $msg]
} {1 {tf1 ENOTDIR}}
test winFCmd-6.7 {TclpRemoveDirectory: RemoveDirectory succeeds} {pcOnly} {
    cleanup
    file mkdir td1
    testfile rmdir td1
    file exists td1
} {0}
test winFCmd-6.8 {TclpRemoveDirectory: RemoveDirectory fails} {pcOnly} {
    cleanup
    createfile tf1
    list [catch {testfile rmdir tf1} msg] [file tail $msg]
} {1 {tf1 ENOTDIR}}
test winFCmd-6.9 {TclpRemoveDirectory: errno == EACCES} {pcOnly} {
    cleanup
    file mkdir td1
    testchmod 000 td1
    testfile rmdir td1
    file exists td1
} {0}
test winFCmd-6.10 {TclpRemoveDirectory: attr == -1} {pcOnly 95} {
    cleanup
    list [catch {testfile rmdir nul} msg] $msg
} {1 {nul EACCES}}
test winFCmd-6.11 {TclpRemoveDirectory: attr == -1} {pcOnly nt} {
    cleanup
    list [catch {testfile rmdir /} msg] $msg
} {1 {/ EACCES}}
test winFCmd-6.12 {TclpRemoveDirectory: errno == EACCES} {pcOnly 95} {
    cleanup
    createfile tf1
    list [catch {testfile rmdir tf1} msg] $msg
} {1 {tf1 ENOTDIR}}
test winFCmd-6.13 {TclpRemoveDirectory: write-protected} {pcOnly} {
    cleanup
    file mkdir td1
    testchmod 000 td1
    testfile rmdir td1
    file exists td1
} {0}
test winFCmd-6.14 {TclpRemoveDirectory: check if empty dir} {pcOnly 95} {
    cleanup
    file mkdir td1/td2
    list [catch {testfile rmdir td1} msg] $msg
} {1 {td1 EEXIST}}
test winFCmd-6.15 {TclpRemoveDirectory: !recursive} {pcOnly} {
    cleanup
    file mkdir td1/td2
    list [catch {testfile rmdir td1} msg] [file tail $msg]
} {1 {td1 EEXIST}}
test winFCmd-6.16 {TclpRemoveDirectory: recursive, but errno != EEXIST} {pcOnly} {
    cleanup
    createfile tf1
    list [catch {testfile rmdir -force tf1} msg] $msg
} {1 {tf1 ENOTDIR}}
test winFCmd-6.17 {TclpRemoveDirectory: calls TraverseWinTree} {pcOnly} {
    cleanup
    file mkdir td1/td2
    testfile rmdir -force td1
    file exists td1
} {0}

test winFCmd-7.1 {TraverseWinTree: targetPtr == NULL} {pcOnly} {
    cleanup
    file mkdir td1/td2/td3
    testfile rmdir -force td1
    file exists td1
} {0}
test winFCmd-7.2 {TraverseWinTree: targetPtr != NULL} {pcOnly} {
    cleanup
    file mkdir td1/td2/td3
    testfile cpdir td1 td2
    list [file exists td1] [file exists td2]
} {1 1}
test winFCmd-7.3 {TraverseWinTree: sourceAttr == -1} {pcOnly} {
    cleanup
    list [catch {testfile cpdir td1 td2} msg] $msg
} {1 {td1 ENOENT}}
test winFCmd-7.4 {TraverseWinTree: source isn't directory} {pcOnly} {
    cleanup
    file mkdir td1
    createfile td1/tf1 tf1
    testfile cpdir td1 td2
    contents td2/tf1
} {tf1}
test winFCmd-7.5 {TraverseWinTree: call TraversalCopy: DOTREE_F} {pcOnly} {
    cleanup
    file mkdir td1
    createfile td1/tf1 tf1
    testfile cpdir td1 td2
    contents td2/tf1
} {tf1}
test winFCmd-7.6 {TraverseWinTree: call TraversalDelete: DOTREE_F} {pcOnly} {
    cleanup
    file mkdir td1
    createfile td1/tf1 tf1
    testfile rmdir -force td1
    file exists td1
} {0}
test winFCmd-7.7 {TraverseWinTree: append \ to source if necessary} {pcOnly} {
    cleanup
    file mkdir td1
    createfile td1/tf1 tf1
    testfile cpdir td1 td2
    contents td2/tf1
} {tf1}    
test winFCmd-7.8 {TraverseWinTree: append \ to source if necessary} {pcOnly 95 cdrom} {
    # cdrom can return either d:\ or D:/, but we only care about the errcode
    list [catch {testfile rmdir $cdrom/} msg] [lindex $msg 1]
} {1 EEXIST}
test winFCmd-7.9 {TraverseWinTree: append \ to source if necessary} {pcOnly nt cdrom} {
    list [catch {testfile rmdir $cdrom/} msg]  [lindex $msg 1]
} {1 EACCES}
test winFCmd-7.10 {TraverseWinTree: can't read directory: handle == INVALID} \
	{pcOnly} {
    # can't make it happen
} {}
test winFCmd-7.11 {TraverseWinTree: call TraversalCopy: DOTREE_PRED} {pcOnly} {
    cleanup
    file mkdir td1
    testchmod 000 td1
    createfile td1/tf1 tf1
    testfile cpdir td1 td2
    list [file exists td2] [file writable td2]
} {1 0}
test winFCmd-7.12 {TraverseWinTree: call TraversalDelete: DOTREE_PRED} {pcOnly} {
    cleanup
    file mkdir td1
    createfile td1/tf1 tf1
    testfile rmdir -force td1
    file exists td1
} {0}
test winFCmd-7.13 {TraverseWinTree: append \ to target if necessary} {pcOnly} {
    cleanup
    file mkdir td1
    createfile td1/tf1 tf1
    testfile cpdir td1 td2
    contents td2/tf1
} {tf1}    
test winFCmd-7.14 {TraverseWinTree: append \ to target if necessary} {pcOnly 95} {
    cleanup
    file mkdir td1
    list [catch {testfile cpdir td1 /} msg] $msg
} {1 {/ EEXIST}}
test winFCmd-7.15 {TraverseWinTree: append \ to target if necessary} {pcOnly nt} {
    cleanup
    file mkdir td1
    list [catch {testfile cpdir td1 /} msg] $msg
} {1 {/ EACCES}}
test winFCmd-7.16 {TraverseWinTree: recurse on files: no files} {pcOnly} {
    cleanup
    file mkdir td1
    testfile cpdir td1 td2
} {}
test winFCmd-7.17 {TraverseWinTree: recurse on files: one file} {pcOnly} {
    cleanup
    file mkdir td1
    createfile td1/td2
    testfile cpdir td1 td2
    glob td2/*
} {td2/td2}
test winFCmd-7.18 {TraverseWinTree: recurse on files: several files and dir} \
	{pcOnly} {
    cleanup
    file mkdir td1
    createfile td1/tf1
    createfile td1/tf2
    file mkdir td1/td2/td3
    createfile td1/tf3
    createfile td1/tf4
    testfile cpdir td1 td2
    lsort [glob td2/*]
} {td2/td2 td2/tf1 td2/tf2 td2/tf3 td2/tf4}
test winFCmd-7.19 {TraverseWinTree: call TraversalCopy: DOTREE_POSTD} {pcOnly} {
    cleanup
    file mkdir td1
    testchmod 000 td1
    createfile td1/tf1 tf1
    testfile cpdir td1 td2
    list [file exists td2] [file writable td2]
} {1 0}
test winFCmd-7.20 {TraverseWinTree: call TraversalDelete: DOTREE_POSTD} \
	{pcOnly} {
    cleanup
    file mkdir td1
    createfile td1/tf1 tf1
    testfile rmdir -force td1
    file exists td1
} {0}
test winFCmd-7.21 {TraverseWinTree: fill errorPtr} {pcOnly} {
    cleanup
    list [catch {testfile cpdir td1 td2} msg] $msg
} {1 {td1 ENOENT}}

test winFCmd-8.1 {TraversalCopy: DOTREE_F} {pcOnly} {
    cleanup
    file mkdir td1
    list [catch {testfile cpdir td1 td1} msg] $msg
} {1 {td1 EEXIST}}
test winFCmd-8.2 {TraversalCopy: DOTREE_PRED} {pcOnly} {
    cleanup
    file mkdir td1/td2
    testchmod 000 td1
    testfile cpdir td1 td2
    list [file writable td1] [file writable td1/td2]
} {0 1}
test winFCmd-8.3 {TraversalCopy: DOTREE_POSTD} {pcOnly} {
    cleanup
    file mkdir td1
    testfile cpdir td1 td2
} {}

test winFCmd-9.1 {TraversalDelete: DOTREE_F} {pcOnly} {
    cleanup
    file mkdir td1
    createfile td1/tf1
    testfile rmdir -force td1
} {}
test winFCmd-9.2 {TraversalDelete: DOTREE_F} {pcOnly 95} {
    cleanup
    file mkdir td1
    set fd [open td1/tf1 w]
    set msg [list [catch {testfile rmdir -force td1} msg] $msg]
    close $fd
    set msg
} {1 {td1\tf1 EACCES}}
test winFCmd-9.3 {TraversalDelete: DOTREE_PRED} {pcOnly} {
    cleanup
    file mkdir td1/td2
    testchmod 000 td1
    testfile rmdir -force td1
    file exists td1
} {0}
test winFCmd-9.4 {TraversalDelete: DOTREE_POSTD} {pcOnly} {
    cleanup
    file mkdir td1/td1/td3/td4/td5
    testfile rmdir -force td1
} {}

test winFCmd-10.1 {AttributesPosixError - get} {pcOnly} {
    cleanup
    list [catch {file attributes td1 -archive} msg] $msg
} {1 {could not read "td1": no such file or directory}}
test winFCmd-10.2 {AttributesPosixError - set} {pcOnly} {
    cleanup
    list [catch {file attributes td1 -archive 0} msg] $msg
} {1 {could not read "td1": no such file or directory}}

test winFCmd-11.1 {GetWinFileAttributes} {pcOnly} {
    cleanup
    close [open td1 w]
    list [catch {file attributes td1 -archive} msg] $msg [cleanup]
} {0 1 {}}
test winFCmd-11.2 {GetWinFileAttributes} {pcOnly} {
    cleanup
    close [open td1 w]
    list [catch {file attributes td1 -readonly} msg] $msg [cleanup]
} {0 0 {}}
test winFCmd-11.3 {GetWinFileAttributes} {pcOnly} {
    cleanup
    close [open td1 w]
    list [catch {file attributes td1 -hidden} msg] $msg [cleanup]
} {0 0 {}}
test winFCmd-11.4 {GetWinFileAttributes} {pcOnly} {
    cleanup
    close [open td1 w]
    list [catch {file attributes td1 -system} msg] $msg [cleanup]
} {0 0 {}}
test winFCmd-11.5 {GetWinFileAttributes} {pcOnly} {
    # attr of relative paths that resolve to root was failing
    # don't care about answer, just that test runs.

    set old [pwd]
    cd c:/
    file attr c:	    
    file attr c:.
    file attr . 
    cd $old
} {}
test winFCmd-11.6 {GetWinFileAttributes} {pcOnly} {
    file attr c:/ -hidden
} {0}

test winFCmd-12.1 {ConvertFileNameFormat} {pcOnly} {
    cleanup
    close [open td1 w]
    list [catch {string tolower [file attributes td1 -longname]} msg] $msg [cleanup]
} {0 td1 {}}
test winFCmd-12.2 {ConvertFileNameFormat} {pcOnly} {
    cleanup
    file mkdir td1
    close [open td1/td1 w]
    list [catch {string tolower [file attributes td1/td1 -longname]} msg] $msg [cleanup]
} {0 td1/td1 {}}
test winFCmd-12.3 {ConvertFileNameFormat} {pcOnly} {
    cleanup
    file mkdir td1
    file mkdir td1/td2
    close [open td1/td3 w]
    list [catch {string tolower [file attributes td1/td2/../td3 -longname]} msg] $msg [cleanup]
} {0 td1/td2/../td3 {}}
test winFCmd-12.4 {ConvertFileNameFormat} {pcOnly} {
    cleanup
    close [open td1 w]
    list [catch {string tolower [file attributes ./td1 -longname]} msg] $msg [cleanup]
} {0 ./td1 {}}
test winFCmd-12.5 {ConvertFileNameFormat: absolute path} {pcOnly} {
    list [file attributes / -longname] [file attributes \\ -longname]
} {/ /}
test winFCmd-12.6 {ConvertFileNameFormat: absolute path with drive} {pcOnly} {
    catch {file delete -force -- c:/td1}
    close [open c:/td1 w]
    list [catch {string tolower [file attributes c:/td1 -longname]} msg] $msg [file delete -force -- c:/td1]
} {0 c:/td1 {}}
test winFCmd-12.7 {ConvertFileNameFormat} {nonPortable pcOnly} {
    string tolower [file attributes //bisque/tcl/ws -longname]
} {//bisque/tcl/ws}
test winFCmd-12.8 {ConvertFileNameFormat} {pcOnly longFileNames} {
    cleanup
    close [open td1 w]
    list [catch {string tolower [file attributes td1 -longname]} msg] $msg [cleanup]
} {0 td1 {}}
test winFCmd-12.10 {ConvertFileNameFormat} {longFileNames pcOnly} {
    cleanup
    close [open td1td1td1 w]
    list [catch {file attributes td1td1td1 -shortname}] [cleanup]
} {0 {}}
test winFCmd-12.11 {ConvertFileNameFormat} {longFileNames pcOnly} {
    cleanup
    close [open td1 w]
    list [catch {string tolower [file attributes td1 -shortname]} msg] $msg [cleanup]
} {0 td1 {}}

test winFCmd-13.1 {GetWinFileLongName} {pcOnly} {
    cleanup
    close [open td1 w]
    list [catch {string tolower [file attributes td1 -longname]} msg] $msg [cleanup]
} {0 td1 {}}

test winFCmd-14.1 {GetWinFileShortName} {pcOnly} {
    cleanup
    close [open td1 w]
    list [catch {string tolower [file attributes td1 -shortname]} msg] $msg [cleanup]
} {0 td1 {}}

test winFCmd-15.1 {SetWinFileAttributes} {pcOnly} {
    cleanup
    list [catch {file attributes td1 -archive 0} msg] $msg
} {1 {could not read "td1": no such file or directory}}
test winFCmd-15.2 {SetWinFileAttributes - archive} {pcOnly} {
    cleanup
    close [open td1 w]
    list [catch {file attributes td1 -archive 1} msg] $msg [file attributes td1 -archive] [cleanup]
} {0 {} 1 {}}
test winFCmd-15.3 {SetWinFileAttributes - archive} {pcOnly} {
    cleanup
    close [open td1 w]
    list [catch {file attributes td1 -archive 0} msg] $msg [file attributes td1 -archive] [cleanup]
} {0 {} 0 {}}
test winFCmd-15.4 {SetWinFileAttributes - hidden} {pcOnly} {
    cleanup
    close [open td1 w]
    list [catch {file attributes td1 -hidden 1} msg] $msg [file attributes td1 -hidden] [file attributes td1 -hidden 0] [cleanup]
} {0 {} 1 {} {}}
test winFCmd-15.5 {SetWinFileAttributes - hidden} {pcOnly} {
    cleanup
    close [open td1 w]
    list [catch {file attributes td1 -hidden 0} msg] $msg [file attributes td1 -hidden] [cleanup]
} {0 {} 0 {}}
test winFCmd-15.6 {SetWinFileAttributes - readonly} {pcOnly} {
    cleanup
    close [open td1 w]
    list [catch {file attributes td1 -readonly 1} msg] $msg [file attributes td1 -readonly] [cleanup]
} {0 {} 1 {}}
test winFCmd-15.7 {SetWinFileAttributes - readonly} {pcOnly} {
    cleanup
    close [open td1 w]
    list [catch {file attributes td1 -readonly 0} msg] $msg [file attributes td1 -readonly] [cleanup]
} {0 {} 0 {}}
test winFCmd-15.8 {SetWinFileAttributes - system} {pcOnly} {
    cleanup
    close [open td1 w]
    list [catch {file attributes td1 -system 1} msg] $msg [file attributes td1 -system] [cleanup]
} {0 {} 1 {}}
test winFCmd-15.9 {SetWinFileAttributes - system} {pcOnly} {
    cleanup
    close [open td1 w]
    list [catch {file attributes td1 -system 0} msg] $msg [file attributes td1 -system] [cleanup]
} {0 {} 0 {}}
test winFCmd-15.10 {SetWinFileAttributes - failing} {pcOnly cdrom} {
    cleanup
    catch {file attributes $cdfile -archive 1}
} {1}
test winFCmd-16.1 {Windows file normalization} {pcOnly} {
    list [file normalize c:/] [file normalize C:/]
} {C:/ C:/}

# This block of code used to occur after the "return" call, so I'm
# commenting it out and assuming that this code is still under construction.
#foreach source {tef ted tnf tnd "" nul com1} {
#    foreach chmodsrc {000 755} {
#        foreach dest "tfn tfe tdn tdempty tdfull td1/td2 $p $p/td1 {} nul" {
#	    foreach chmoddst {000 755} {
#		puts hi
#		cleanup
#		file delete -force ted tef
#		file mkdir ted
#		createfile tef
#		createfile tfe
#		file mkdir tdempty
#		file mkdir tdfull/td1/td2
#
#		catch {testchmod $chmodsrc $source}
#		catch {testchmod $chmoddst $dest}
#
#		if [catch {file rename $source $dest} msg] {
#		    puts "file rename $source ($chmodsrc) $dest ($chmoddst)"
#		    puts $msg
#		}
#	    }
#	}
#    }
#}

# cleanup
cleanup
::tcltest::cleanupTests
return
@


1.4
log
@touched all sources to ease next import
@
text
@d13 1
a13 1
# RCS: @@(#) $Id: winFCmd.test,v 1.6.8.2 2000/09/15 16:58:00 spolk Exp $
d39 1
a39 1
	    set x [glob [file join $p tf*] [file join $p td*]]
d47 14
d205 5
a209 1
test winFCmd-1.13 {TclpRenameFile: errno: EACCES} {pcOnly} {
d213 1
a213 1
test winFCmd-1.14 {TclpRenameFile: errno: EACCES} {95} {
d218 1
a218 1
test winFCmd-1.15 {TclpRenameFile: errno: EEXIST} {nt} {
d237 5
a241 1
test winFCmd-1.19 {TclpRenameFile: errno == EACCES} {pcOnly} {
d245 1
a245 1
test winFCmd-1.20 {TclpRenameFile: src is dir} {nt} {
d291 1
a291 1
    list [file exist tf1] [file exist tf2]
d316 1
a316 1
    list [file exist td1] [file exist td2] [file exist td2/td2]
d378 1
a378 1
test winFCmd-2.7 {TclpCopyFile: errno: EACCES} {95} {
d386 5
a390 1
test winFCmd-2.8 {TclpCopyFile: errno: EACCES} {nt} {
d394 1
a394 1
test winFCmd-2.9 {TclpCopyFile: errno: ENOENT} {95} {
d448 1
a448 1
test winFCmd-2.18 {TclpCopyFile: still can't copy onto dst} {95} {
d490 1
a490 1
    file exist tf1
d520 1
a520 1
test winFCmd-4.1 {TclpCreateDirectory: errno: EACCES} {nt cdrom} {
d523 1
a523 1
test winFCmd-4.2 {TclpCreateDirectory: errno: EACCES} {95 cdrom} {
d553 1
a553 1
    file exist td1
d558 1
a558 1
    list [catch {testfile rmdir td1} msg] $msg
d566 1
a566 1
    list [catch {testfile rmdir td1} msg] $msg
d575 1
a575 1
    list [catch {testfile rmdir tf1} msg] $msg
d586 1
a586 1
    list [catch {testfile rmdir tf1} msg] $msg
d595 1
a595 1
test winFCmd-6.10 {TclpRemoveDirectory: attr == -1} {95} {
d599 1
a599 1
test winFCmd-6.11 {TclpRemoveDirectory: attr == -1} {nt} {
d602 2
a603 2
} {1 {\ EACCES}}
test winFCmd-6.12 {TclpRemoveDirectory: errno == EACCES} {95} {
d615 1
a615 1
test winFCmd-6.14 {TclpRemoveDirectory: check if empty dir} {95} {
d623 1
a623 1
    list [catch {testfile rmdir td1} msg] $msg
d681 7
a687 6
test winFCmd-7.8 {TraverseWinTree: append \ to source if necessary} {95 cdrom} {
    list [catch {testfile rmdir $cdrom/} msg] $msg
} "1 {$cdrom\\ EEXIST}"
test winFCmd-7.9 {TraverseWinTree: append \ to source if necessary} {nt cdrom} {
    list [catch {testfile rmdir $cdrom/} msg] $msg
} "1 {$cdrom\\ EACCES}"
d714 1
a714 1
test winFCmd-7.14 {TraverseWinTree: append \ to target if necessary} {95} {
d718 2
a719 2
} {1 {\ EEXIST}}
test winFCmd-7.15 {TraverseWinTree: append \ to target if necessary} {nt} {
d723 1
a723 1
} {1 {\ EACCES}}
d793 1
a793 1
test winFCmd-9.2 {TraversalDelete: DOTREE_F} {95} {
d843 1
a843 1
test winfcmd-11.5 {GetWinFileAttributes} {pcOnly} {
d854 3
d968 3
a1002 13













@


1.3
log
@touched all sources to ease next import
@
text
@@


1.3.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d13 1
a13 1
# RCS: @@(#) $Id: winFCmd.test,v 1.20 2002/10/04 08:25:14 dkf Exp $
d39 1
a39 1
	    set x [glob -directory $p tf* td*]
a46 14
if {[string equal $tcl_platform(platform) "windows"]} {
    if {[string equal $tcl_platform(os) "Windows NT"] \
      && [string equal [string index $tcl_platform(osVersion) 0] "5"]} {
	tcltest::testConstraint win2000orXP 1
	tcltest::testConstraint winOlderThan2000 0
    } else {
	tcltest::testConstraint win2000orXP 0
	tcltest::testConstraint winOlderThan2000 1
    }
} else {
    tcltest::testConstraint win2000orXP 0
    tcltest::testConstraint winOlderThan2000 0
}

d191 1
a191 5
test winFCmd-1.13 {TclpRenameFile: errno: EACCES} {pcOnly win2000orXP} {
    cleanup
    list [catch {testfile mv nul tf1} msg] $msg
} {1 EINVAL}
test winFCmd-1.13.1 {TclpRenameFile: errno: EACCES} {pcOnly winOlderThan2000} {
d195 1
a195 1
test winFCmd-1.14 {TclpRenameFile: errno: EACCES} {pcOnly 95} {
d200 1
a200 1
test winFCmd-1.15 {TclpRenameFile: errno: EEXIST} {pcOnly nt} {
d219 1
a219 5
test winFCmd-1.19 {TclpRenameFile: errno == EACCES} {pcOnly win2000orXP} {
    cleanup
    list [catch {testfile mv nul tf1} msg] $msg
} {1 EINVAL}
test winFCmd-1.19.1 {TclpRenameFile: errno == EACCES} {pcOnly winOlderThan2000} {
d223 1
a223 1
test winFCmd-1.20 {TclpRenameFile: src is dir} {pcOnly nt} {
d269 1
a269 1
    list [file exists tf1] [file exists tf2]
d294 1
a294 1
    list [file exists td1] [file exists td2] [file exists td2/td2]
d356 1
a356 1
test winFCmd-2.7 {TclpCopyFile: errno: EACCES} {pcOnly 95} {
d364 1
a364 5
test winFCmd-2.8 {TclpCopyFile: errno: EACCES} {pcOnly win2000orXP} {
    cleanup
    list [catch {testfile cp nul tf1} msg] $msg
} {1 EINVAL}
test winFCmd-2.8.1 {TclpCopyFile: errno: EACCES} {pcOnly nt winOlderThan2000} {
d368 1
a368 1
test winFCmd-2.9 {TclpCopyFile: errno: ENOENT} {pcOnly 95} {
d422 1
a422 1
test winFCmd-2.18 {TclpCopyFile: still can't copy onto dst} {pcOnly 95} {
d464 1
a464 1
    file exists tf1
d494 1
a494 1
test winFCmd-4.1 {TclpCreateDirectory: errno: EACCES} {pcOnly nt cdrom} {
d497 1
a497 1
test winFCmd-4.2 {TclpCreateDirectory: errno: EACCES} {pcOnly 95 cdrom} {
d527 1
a527 1
    file exists td1
d532 1
a532 1
    list [catch {testfile rmdir td1} msg] [file tail $msg]
d540 1
a540 1
    list [catch {testfile rmdir td1} msg] [file tail $msg]
d549 1
a549 1
    list [catch {testfile rmdir tf1} msg] [file tail $msg]
d560 1
a560 1
    list [catch {testfile rmdir tf1} msg] [file tail $msg]
d569 1
a569 1
test winFCmd-6.10 {TclpRemoveDirectory: attr == -1} {pcOnly 95} {
d573 1
a573 1
test winFCmd-6.11 {TclpRemoveDirectory: attr == -1} {pcOnly nt} {
d576 2
a577 2
} {1 {/ EACCES}}
test winFCmd-6.12 {TclpRemoveDirectory: errno == EACCES} {pcOnly 95} {
d589 1
a589 1
test winFCmd-6.14 {TclpRemoveDirectory: check if empty dir} {pcOnly 95} {
d597 1
a597 1
    list [catch {testfile rmdir td1} msg] [file tail $msg]
d655 6
a660 7
test winFCmd-7.8 {TraverseWinTree: append \ to source if necessary} {pcOnly 95 cdrom} {
    # cdrom can return either d:\ or D:/, but we only care about the errcode
    list [catch {testfile rmdir $cdrom/} msg] [lindex $msg 1]
} {1 EEXIST}
test winFCmd-7.9 {TraverseWinTree: append \ to source if necessary} {pcOnly nt cdrom} {
    list [catch {testfile rmdir $cdrom/} msg]  [lindex $msg 1]
} {1 EACCES}
d687 1
a687 1
test winFCmd-7.14 {TraverseWinTree: append \ to target if necessary} {pcOnly 95} {
d691 2
a692 2
} {1 {/ EEXIST}}
test winFCmd-7.15 {TraverseWinTree: append \ to target if necessary} {pcOnly nt} {
d696 1
a696 1
} {1 {/ EACCES}}
d766 1
a766 1
test winFCmd-9.2 {TraversalDelete: DOTREE_F} {pcOnly 95} {
d816 1
a816 1
test winFCmd-11.5 {GetWinFileAttributes} {pcOnly} {
a826 3
test winFCmd-11.6 {GetWinFileAttributes} {pcOnly} {
    file attr c:/ -hidden
} {0}
a937 3
test winFCmd-16.1 {Windows file normalization} {pcOnly} {
    list [file normalize c:/] [file normalize C:/]
} {C:/ C:/}
d970 13
@


1.3.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@d13 1
a13 1
# RCS: @@(#) $Id: winFCmd.test,v 1.19 2002/07/18 16:35:12 vincentdarley Exp $
d39 1
a39 1
	    set x [glob -directory $p tf* td*]
a46 14
if {[string equal $tcl_platform(platform) "windows"]} {
    if {[string equal $tcl_platform(os) "Windows NT"] \
      && [string equal [string index $tcl_platform(osVersion) 0] "5"]} {
	tcltest::testConstraint win2000orXP 1
	tcltest::testConstraint winOlderThan2000 0
    } else {
	tcltest::testConstraint win2000orXP 0
	tcltest::testConstraint winOlderThan2000 1
    }
} else {
    tcltest::testConstraint win2000orXP 0
    tcltest::testConstraint winOlderThan2000 0
}

d191 1
a191 5
test winFCmd-1.13 {TclpRenameFile: errno: EACCES} {pcOnly win2000orXP} {
    cleanup
    list [catch {testfile mv nul tf1} msg] $msg
} {1 EINVAL}
test winFCmd-1.13.1 {TclpRenameFile: errno: EACCES} {pcOnly winOlderThan2000} {
d195 1
a195 1
test winFCmd-1.14 {TclpRenameFile: errno: EACCES} {pcOnly 95} {
d200 1
a200 1
test winFCmd-1.15 {TclpRenameFile: errno: EEXIST} {pcOnly nt} {
d219 1
a219 5
test winFCmd-1.19 {TclpRenameFile: errno == EACCES} {pcOnly win2000orXP} {
    cleanup
    list [catch {testfile mv nul tf1} msg] $msg
} {1 EINVAL}
test winFCmd-1.19.1 {TclpRenameFile: errno == EACCES} {pcOnly winOlderThan2000} {
d223 1
a223 1
test winFCmd-1.20 {TclpRenameFile: src is dir} {pcOnly nt} {
d356 1
a356 1
test winFCmd-2.7 {TclpCopyFile: errno: EACCES} {pcOnly 95} {
d364 1
a364 5
test winFCmd-2.8 {TclpCopyFile: errno: EACCES} {pcOnly win2000orXP} {
    cleanup
    list [catch {testfile cp nul tf1} msg] $msg
} {1 EINVAL}
test winFCmd-2.8.1 {TclpCopyFile: errno: EACCES} {pcOnly nt winOlderThan2000} {
d368 1
a368 1
test winFCmd-2.9 {TclpCopyFile: errno: ENOENT} {pcOnly 95} {
d422 1
a422 1
test winFCmd-2.18 {TclpCopyFile: still can't copy onto dst} {pcOnly 95} {
d494 1
a494 1
test winFCmd-4.1 {TclpCreateDirectory: errno: EACCES} {pcOnly nt cdrom} {
d497 1
a497 1
test winFCmd-4.2 {TclpCreateDirectory: errno: EACCES} {pcOnly 95 cdrom} {
d532 1
a532 1
    list [catch {testfile rmdir td1} msg] [file tail $msg]
d540 1
a540 1
    list [catch {testfile rmdir td1} msg] [file tail $msg]
d549 1
a549 1
    list [catch {testfile rmdir tf1} msg] [file tail $msg]
d560 1
a560 1
    list [catch {testfile rmdir tf1} msg] [file tail $msg]
d569 1
a569 1
test winFCmd-6.10 {TclpRemoveDirectory: attr == -1} {pcOnly 95} {
d573 1
a573 1
test winFCmd-6.11 {TclpRemoveDirectory: attr == -1} {pcOnly nt} {
d576 2
a577 2
} {1 {/ EACCES}}
test winFCmd-6.12 {TclpRemoveDirectory: errno == EACCES} {pcOnly 95} {
d589 1
a589 1
test winFCmd-6.14 {TclpRemoveDirectory: check if empty dir} {pcOnly 95} {
d597 1
a597 1
    list [catch {testfile rmdir td1} msg] [file tail $msg]
d655 6
a660 7
test winFCmd-7.8 {TraverseWinTree: append \ to source if necessary} {pcOnly 95 cdrom} {
    # cdrom can return either d:\ or D:/, but we only care about the errcode
    list [catch {testfile rmdir $cdrom/} msg] [lindex $msg 1]
} {1 EEXIST}
test winFCmd-7.9 {TraverseWinTree: append \ to source if necessary} {pcOnly nt cdrom} {
    list [catch {testfile rmdir $cdrom/} msg]  [lindex $msg 1]
} {1 EACCES}
d687 1
a687 1
test winFCmd-7.14 {TraverseWinTree: append \ to target if necessary} {pcOnly 95} {
d691 2
a692 2
} {1 {/ EEXIST}}
test winFCmd-7.15 {TraverseWinTree: append \ to target if necessary} {pcOnly nt} {
d696 1
a696 1
} {1 {/ EACCES}}
d766 1
a766 1
test winFCmd-9.2 {TraversalDelete: DOTREE_F} {pcOnly 95} {
d816 1
a816 1
test winFCmd-11.5 {GetWinFileAttributes} {pcOnly} {
a826 3
test winFCmd-11.6 {GetWinFileAttributes} {pcOnly} {
    file attr c:/ -hidden
} {0}
a937 3
test winFCmd-16.1 {Windows file normalization} {pcOnly} {
    list [file normalize c:/] [file normalize C:/]
} {C:/ C:/}
d970 13
@


1.2
log
@touched all Tcl files to ease next import.
@
text
@@


1.2.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.2.16.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d39 1
a39 1
	    set x [glob -directory $p tf* td*]
a46 14
if {[string equal $tcl_platform(platform) "windows"]} {
    if {[string equal $tcl_platform(os) "Windows NT"] \
      && [string equal [string index $tcl_platform(osVersion) 0] "5"]} {
	tcltest::testConstraint win2000orXP 1
	tcltest::testConstraint winOlderThan2000 0
    } else {
	tcltest::testConstraint win2000orXP 0
	tcltest::testConstraint winOlderThan2000 1
    }
} else {
    tcltest::testConstraint win2000orXP 0
    tcltest::testConstraint winOlderThan2000 0
}

d191 1
a191 5
test winFCmd-1.13 {TclpRenameFile: errno: EACCES} {pcOnly win2000orXP} {
    cleanup
    list [catch {testfile mv nul tf1} msg] $msg
} {1 EINVAL}
test winFCmd-1.13.1 {TclpRenameFile: errno: EACCES} {pcOnly winOlderThan2000} {
d195 1
a195 1
test winFCmd-1.14 {TclpRenameFile: errno: EACCES} {pcOnly 95} {
d200 1
a200 1
test winFCmd-1.15 {TclpRenameFile: errno: EEXIST} {pcOnly nt} {
d219 1
a219 5
test winFCmd-1.19 {TclpRenameFile: errno == EACCES} {pcOnly win2000orXP} {
    cleanup
    list [catch {testfile mv nul tf1} msg] $msg
} {1 EINVAL}
test winFCmd-1.19.1 {TclpRenameFile: errno == EACCES} {pcOnly winOlderThan2000} {
d223 1
a223 1
test winFCmd-1.20 {TclpRenameFile: src is dir} {pcOnly nt} {
d269 1
a269 1
    list [file exists tf1] [file exists tf2]
d294 1
a294 1
    list [file exists td1] [file exists td2] [file exists td2/td2]
d356 1
a356 1
test winFCmd-2.7 {TclpCopyFile: errno: EACCES} {pcOnly 95} {
d364 1
a364 5
test winFCmd-2.8 {TclpCopyFile: errno: EACCES} {pcOnly win2000orXP} {
    cleanup
    list [catch {testfile cp nul tf1} msg] $msg
} {1 EINVAL}
test winFCmd-2.8.1 {TclpCopyFile: errno: EACCES} {pcOnly nt winOlderThan2000} {
d368 1
a368 1
test winFCmd-2.9 {TclpCopyFile: errno: ENOENT} {pcOnly 95} {
d422 1
a422 1
test winFCmd-2.18 {TclpCopyFile: still can't copy onto dst} {pcOnly 95} {
d464 1
a464 1
    file exists tf1
d494 1
a494 1
test winFCmd-4.1 {TclpCreateDirectory: errno: EACCES} {pcOnly nt cdrom} {
d497 1
a497 1
test winFCmd-4.2 {TclpCreateDirectory: errno: EACCES} {pcOnly 95 cdrom} {
d527 1
a527 1
    file exists td1
d532 1
a532 1
    list [catch {testfile rmdir td1} msg] [file tail $msg]
d540 1
a540 1
    list [catch {testfile rmdir td1} msg] [file tail $msg]
d549 1
a549 1
    list [catch {testfile rmdir tf1} msg] [file tail $msg]
d560 1
a560 1
    list [catch {testfile rmdir tf1} msg] [file tail $msg]
d569 1
a569 1
test winFCmd-6.10 {TclpRemoveDirectory: attr == -1} {pcOnly 95} {
d573 1
a573 1
test winFCmd-6.11 {TclpRemoveDirectory: attr == -1} {pcOnly nt} {
d576 2
a577 2
} {1 {/ EACCES}}
test winFCmd-6.12 {TclpRemoveDirectory: errno == EACCES} {pcOnly 95} {
d589 1
a589 1
test winFCmd-6.14 {TclpRemoveDirectory: check if empty dir} {pcOnly 95} {
d597 1
a597 1
    list [catch {testfile rmdir td1} msg] [file tail $msg]
d655 6
a660 7
test winFCmd-7.8 {TraverseWinTree: append \ to source if necessary} {pcOnly 95 cdrom} {
    # cdrom can return either d:\ or D:/, but we only care about the errcode
    list [catch {testfile rmdir $cdrom/} msg] [lindex $msg 1]
} {1 EEXIST}
test winFCmd-7.9 {TraverseWinTree: append \ to source if necessary} {pcOnly nt cdrom} {
    list [catch {testfile rmdir $cdrom/} msg]  [lindex $msg 1]
} {1 EACCES}
d687 1
a687 1
test winFCmd-7.14 {TraverseWinTree: append \ to target if necessary} {pcOnly 95} {
d691 2
a692 2
} {1 {/ EEXIST}}
test winFCmd-7.15 {TraverseWinTree: append \ to target if necessary} {pcOnly nt} {
d696 1
a696 1
} {1 {/ EACCES}}
d766 1
a766 1
test winFCmd-9.2 {TraversalDelete: DOTREE_F} {pcOnly 95} {
d816 1
a816 1
test winFCmd-11.5 {GetWinFileAttributes} {pcOnly} {
a826 3
test winFCmd-11.6 {GetWinFileAttributes} {pcOnly} {
    file attr c:/ -hidden
} {0}
a937 3
test winFCmd-16.1 {Windows file normalization} {pcOnly} {
    list [file normalize c:/] [file normalize C:/]
} {C:/ C:/}
d970 13
@


1.1
log
@Initial revision
@
text
@d8 1
d13 1
a13 1
# RCS: @@(#) $Id: winFCmd.test,v 1.9 1999/01/26 03:53:35 jingham Exp $
d16 3
a18 4
if {[string compare test [info procs test]] == 1} then {source defs}

if {$tcl_platform(platform) != "windows"} {
    return
d47 2
a48 3
set testConfig(cdrom) 0
set testConfig(exdev) 0
set testConfig(UNCPath} 0
d87 2
a88 5
if {$cdrom == ""} {
    puts "Couldn't find a CD-ROM.  Skipping tests that access CD-ROM."
    puts "If you have a CD-ROM, insert a data disk and rerun tests."
} else {
    set testConfig(cdrom) 1
d96 1
a96 1
	set testConfig(exdev) 1
a99 4
if {[file exists //bisque/icepick]} {
    set testConfig(UNCPath) 1
}

d103 1
a103 1
    set testConfig(longFileNames) 0
d106 1
a106 1
    set testConfig(longFileNames) 1
d126 1
a126 1
test winFCmd-1.1 {TclpRenameFile: errno: EACCES} {cdrom} {
d129 1
a129 1
test winFCmd-1.2 {TclpRenameFile: errno: EEXIST} {
d135 1
a135 4
test winFCmd-1.3 {TclpRenameFile: errno: EINVAL} {!$testConfig(win32s) || ("[lindex [file split [pwd]] end]" == "C:/")} {
    # Don't run this test under Win32s on a drive mounted from an NT 
    # machine; it causes the NT machine to die.

d139 1
a139 1
test winFCmd-1.4 {TclpRenameFile: errno: EINVAL} {
d144 1
a144 1
test winFCmd-1.5 {TclpRenameFile: errno: EISDIR} {
d150 1
a150 1
test winFCmd-1.6 {TclpRenameFile: errno: ENOENT} {
d154 1
a154 1
test winFCmd-1.7 {TclpRenameFile: errno: ENOENT} {
d158 1
a158 1
test winFCmd-1.8 {TclpRenameFile: errno: ENOENT} {
d163 1
a163 1
test winFCmd-1.9 {TclpRenameFile: errno: ENOTDIR} {
d169 1
a169 1
test winFCmd-1.10 {TclpRenameFile: errno: EXDEV} {exdev} {
d176 1
a176 1
test winFCmd-1.11 {TclpRenameFile: errno: EACCES} {
d183 1
a183 1
test winFCmd-1.12 {TclpRenameFile: errno: EACCES} {
d191 1
a191 1
test winFCmd-1.13 {TclpRenameFile: errno: EACCES} {
d205 1
a205 1
test winFCmd-1.16 {TclpRenameFile: MoveFile() != FALSE} {
d211 1
a211 1
test winFCmd-1.17 {TclpRenameFile: MoveFile() == FALSE} {
d215 1
a215 1
test winFCmd-1.18 {TclpRenameFile: srcAttr == -1} {
d219 1
a219 1
test winFCmd-1.19 {TclpRenameFile: errno == EACCES} {
d223 3
a225 3
# under 95, this would actually succed and move the current dir out from 
# under yourself.
test winFCmd-1.20 {TclpRenameFile: src is dir} {!95} {
d230 2
a231 4
test winFCmd-1.21 {TclpRenameFile: obscenely long src} {!win32s} {
    # Really long file names cause all the file system calls to lock up,
    # endlessly throwing an access violation and retrying the operation.

d234 1
a234 7
test winFCmd-1.22 {TclpRenameFile: obscenely long dst} {nt} {
    # return ENOENT if name is too long!
    cleanup
    createfile tf1
    list [catch {testfile mv tf1 $longname} msg] $msg
} {1 ENOENT}
test winFCmd-1.23 {TclpRenameFile: obscenely long dst} {95} {
d239 1
a239 1
test winFCmd-1.24 {TclpRenameFile: move dir into self} {
d244 1
a244 4
test winFCmd-1.25 {TclpRenameFile: move a root dir} {!$testConfig(win32s) || ("[lindex [file split [pwd]] end]" == "C:/")} {
    # Don't run this test under Win32s on a drive mounted from an NT 
    # machine; it causes the NT machine to die.

d248 1
a248 1
test winFCmd-1.26 {TclpRenameFile: cross file systems} {cdrom} {
d253 1
a253 1
test winFCmd-1.27 {TclpRenameFile: readonly fs} {cdrom} {
d257 1
a257 1
test winFCmd-1.28 {TclpRenameFile: open file} {
d264 1
a264 1
test winFCmd-1.29 {TclpRenameFile: errno == EEXIST} {
d271 1
a271 1
test winFCmd-1.30 {TclpRenameFile: src is dir} {
d277 1
a277 1
test winFCmd-1.31 {TclpRenameFile: dst is dir} {
d283 1
a283 1
test winFCmd-1.32 {TclpRenameFile: TclpRemoveDirectory fails} {
d289 1
a289 1
test winFCmd-1.33 {TclpRenameFile: TclpRemoveDirectory succeeds} {
d296 2
a297 1
test winFCmd-1.34 {TclpRenameFile: After removing dst dir, MoveFile fails} {exdev} {
d300 2
a301 1
    set msg [list [catch {testfile mv c:/windows d:/td1} msg] $msg]
d304 1
d307 1
a307 1
test winFCmd-1.35 {TclpRenameFile: src is dir, dst is not} {
d312 1
a312 1
test winFCmd-1.36 {TclpRenameFile: src is not dir, dst is} {
d317 1
a317 1
test winFCmd-1.37 {TclpRenameFile: src and dst not dir} {
d323 1
a323 1
test winFCmd-1.38 {TclpRenameFile: need to restore temp file} {
d328 1
a328 1
test winFCmd-2.1 {TclpCopyFile: errno: EACCES} {cdrom} {
d332 1
a332 1
test winFCmd-2.2 {TclpCopyFile: errno: EISDIR} {
d337 1
a337 1
test winFCmd-2.3 {TclpCopyFile: errno: EISDIR} {
d343 1
a343 1
test winFCmd-2.4 {TclpCopyFile: errno: ENOENT} {
d347 1
a347 1
test winFCmd-2.5 {TclpCopyFile: errno: ENOENT} {
d351 1
a351 1
test winFCmd-2.6 {TclpCopyFile: errno: ENOENT} {
d356 1
a356 1
test winFCmd-2.7 {TclpCopyFile: errno: EACCES} {!nt} {
d372 1
a372 1
test winFCmd-2.10 {TclpCopyFile: CopyFile succeeds} {
d378 1
a378 1
test winFCmd-2.11 {TclpCopyFile: CopyFile succeeds} {
d385 1
a385 1
test winFCmd-2.12 {TclpCopyFile: CopyFile succeeds} {
d392 1
a392 1
test winFCmd-2.13 {TclpCopyFile: CopyFile fails} {
d398 1
a398 1
test winFCmd-2.14 {TclpCopyFile: errno == EACCES} {
d403 1
a403 1
test winFCmd-2.15 {TclpCopyFile: src is directory} {
d408 1
a408 1
test winFCmd-2.16 {TclpCopyFile: dst is directory} {
d414 1
a414 1
test winFCmd-2.17 {TclpCopyFile: dst is readonly} {
d433 1
a433 1
test winFCmd-3.1 {TclpDeleteFile: errno: EACCES} {cdrom} {
d436 1
a436 1
test winFCmd-3.2 {TclpDeleteFile: errno: EISDIR} {
d441 1
a441 1
test winFCmd-3.3 {TclpDeleteFile: errno: ENOENT} {
d445 1
a445 1
test winFCmd-3.4 {TclpDeleteFile: errno: ENOENT} {
d449 1
a449 1
test winFCmd-3.5 {TclpDeleteFile: errno: EACCES} {
d456 1
a456 1
test winFCmd-3.6 {TclpDeleteFile: errno: EACCES} {
d460 1
a460 1
test winFCmd-3.7 {TclpDeleteFile: DeleteFile succeeds} {
d466 1
a466 1
test winFCmd-3.8 {TclpDeleteFile: DeleteFile fails} {
d471 1
a471 1
test winFCmd-3.9 {TclpDeleteFile: errno == EACCES} {
d478 1
a478 1
test winFCmd-3.10 {TclpDeleteFile: path is readonly} {
d485 1
a485 1
test winFCmd-3.11 {TclpDeleteFile: still can't remove path} {
d494 1
a494 1
test winFCmd-4.1 {TclpCreateDirectory: errno: EACCES} {cdrom nt} {
d497 1
a497 1
test winFCmd-4.2 {TclpCreateDirectory: errno: EACCES} {cdrom 95} {
d500 1
a500 1
test winFCmd-4.3 {TclpCreateDirectory: errno: EEXIST} {
d505 1
a505 1
test winFCmd-4.4 {TclpCreateDirectory: errno: ENOENT} {
d509 1
a509 1
test winFCmd-4.5 {TclpCreateDirectory: CreateDirectory succeeds} {
d515 1
a515 1
test winFCmd-5.1 {TclpCopyDirectory: calls TraverseWinTree} {
d522 1
a522 1
test winFCmd-6.1 {TclpRemoveDirectory: errno: EACCES} {
d529 1
a529 1
test winFCmd-6.2 {TclpRemoveDirectory: errno: EEXIST} {
d534 1
a534 1
test winFCmd-6.3 {TclpRemoveDirectory: errno: EACCES} {
d538 1
a538 1
test winFCmd-6.4 {TclpRemoveDirectory: errno: ENOENT} {
d542 1
a542 1
test winFCmd-6.5 {TclpRemoveDirectory: errno: ENOENT} {
d546 1
a546 1
test winFCmd-6.6 {TclpRemoveDirectory: errno: ENOTDIR} {
d551 1
a551 1
test winFCmd-6.7 {TclpRemoveDirectory: RemoveDirectory succeeds} {
d557 1
a557 1
test winFCmd-6.8 {TclpRemoveDirectory: RemoveDirectory fails} {
d562 1
a562 1
test winFCmd-6.9 {TclpRemoveDirectory: errno == EACCES} {
d569 1
a569 1
test winFCmd-6.10 {TclpRemoveDirectory: attr == -1} {!nt} {
d577 1
a577 1
test winFCmd-6.12 {TclpRemoveDirectory: errno == EACCES} {!nt} {
d582 1
a582 1
test winFCmd-6.13 {TclpRemoveDirectory: write-protected} {
d589 1
a589 1
test winFCmd-6.14 {TclpRemoveDirectory: check if empty dir} {!nt} {
d594 1
a594 1
test winFCmd-6.15 {TclpRemoveDirectory: !recursive} {
d599 1
a599 1
test winFCmd-6.16 {TclpRemoveDirectory: recursive, but errno != EEXIST} {
d604 1
a604 1
test winFCmd-6.17 {TclpRemoveDirectory: calls TraverseWinTree} {
d611 1
a611 1
test winFCmd-7.1 {TraverseWinTree: targetPtr == NULL} {
d617 1
a617 1
test winFCmd-7.2 {TraverseWinTree: targetPtr != NULL} {
d623 1
a623 1
test winFCmd-7.3 {TraverseWinTree: sourceAttr == -1} {
d627 1
a627 1
test winFCmd-7.4 {TraverseWinTree: source isn't directory} {
d634 1
a634 1
test winFCmd-7.5 {TraverseWinTree: call TraversalCopy: DOTREE_F} {
d641 1
a641 1
test winFCmd-7.6 {TraverseWinTree: call TraversalDelete: DOTREE_F} {
d648 1
a648 1
test winFCmd-7.7 {TraverseWinTree: append \ to source if necessary} {
d655 1
a655 1
test winFCmd-7.8 {TraverseWinTree: append \ to source if necessary} {!nt && cdrom} {
d661 2
a662 1
test winFCmd-7.10 {TraverseWinTree: can't read directory: handle == INVALID} {
d665 1
a665 1
test winFCmd-7.11 {TraverseWinTree: call TraversalCopy: DOTREE_PRED} {
d673 1
a673 1
test winFCmd-7.12 {TraverseWinTree: call TraversalDelete: DOTREE_PRED} {
d680 1
a680 1
test winFCmd-7.13 {TraverseWinTree: append \ to target if necessary} {
d687 1
a687 1
test winFCmd-7.14 {TraverseWinTree: append \ to target if necessary} {!nt} {
d697 1
a697 1
test winFCmd-7.16 {TraverseWinTree: recurse on files: no files} {
d702 1
a702 1
test winFCmd-7.17 {TraverseWinTree: recurse on files: one file} {
d709 2
a710 1
test winFCmd-7.18 {TraverseWinTree: recurse on files: several files and dir} {
d719 3
a721 3
    glob td2/*
} {td2/tf1 td2/tf2 td2/td2 td2/tf3 td2/tf4}
test winFCmd-7.19 {TraverseWinTree: call TraversalCopy: DOTREE_POSTD} {
d729 2
a730 1
test winFCmd-7.20 {TraverseWinTree: call TraversalDelete: DOTREE_POSTD} {
d737 1
a737 1
test winFCmd-7.21 {TraverseWinTree: fill errorPtr} {
d742 1
a742 1
test winFCmd-8.1 {TraversalCopy: DOTREE_F} {
d747 1
a747 1
test winFCmd-8.2 {TraversalCopy: DOTREE_PRED} {
d754 1
a754 1
test winFCmd-8.3 {TraversalCopy: DOTREE_POSTD} {
d760 1
a760 1
test winFCmd-9.1 {TraversalDelete: DOTREE_F} {
d774 1
a774 1
test winFCmd-9.3 {TraversalDelete: DOTREE_PRED} {
d781 1
a781 1
test winFCmd-9.4 {TraversalDelete: DOTREE_POSTD} {
d787 1
a787 1
test winFCmd-10.1 {AttributesPosixError - get} {
d790 2
a791 2
} {1 {cannot get attribute "-archive" for file "td1": no such file or directory}}
test winFCmd-10.2 {AttributesPosixError - set} {
d794 1
a794 1
} {1 {cannot set attribute "-archive" for file "td1": no such file or directory}}
d796 1
a796 1
test winFCmd-11.1 {GetWinFileAttributes} {
d801 1
a801 1
test winFCmd-11.2 {GetWinFileAttributes} {
d806 1
a806 1
test winFCmd-11.3 {GetWinFileAttributes} {
d811 1
a811 1
test winFCmd-11.4 {GetWinFileAttributes} {
d816 11
d828 1
a828 1
test winFCmd-12.1 {ConvertFileNameFormat} {
d833 1
a833 1
test winFCmd-12.2 {ConvertFileNameFormat} {
d839 1
a839 1
test winFCmd-12.3 {ConvertFileNameFormat} {
d846 1
a846 1
test winFCmd-12.4 {ConvertFileNameFormat} {
d851 1
a851 1
test winFCmd-12.5 {ConvertFileNameFormat: absolute path} {
d854 1
a854 1
test winFCmd-12.6 {ConvertFileNameFormat: absolute path with drive} {
d859 4
a862 11
test winFCmd-12.7 {ConvertFileNameFormat} {UNCPath} {
    catch {file delete -force -- //bisque/icepick/test/td1}
    close [open //bisque/icepick/test/td1 w]
    list [catch {string tolower [file attributes //bisque/icepick/test/td1 -longname]} msg] $msg [file delete -force -- //bisque/icepick/test/td1]
} {0 //bisque/icepick/test/td1 {}}
test winFCmd-12.8 {ConvertFileNameFormat} {longFileNames} {
    cleanup
    close [open td1 w]
    list [catch {string tolower [file attributes td1 -longname]} msg] $msg [cleanup]
} {0 td1 {}}
test winFCmd-12.9 {ConvertFileNameFormat} {win32s} {
d867 1
a867 1
test winFCmd-12.10 {ConvertFileNameFormat} {longFileNames} {
d872 1
a872 1
test winFCmd-12.11 {ConvertFileNameFormat} {longFileNames} {
d878 1
a878 1
test winFCmd-13.1 {GetWinFileLongName} {
d884 1
a884 1
test winFCmd-14.1 {GetWinFileShortName} {
d890 1
a890 1
test winFCmd-15.1 {SetWinFileAttributes} {
d893 2
a894 2
} {1 {cannot set attribute "-archive" for file "td1": no such file or directory}}
test winFCmd-15.2 {SetWinFileAttributes - archive} {
d899 1
a899 1
test winFCmd-15.3 {SetWinFileAttributes - archive} {
d904 1
a904 1
test winFCmd-15.4 {SetWinFileAttributes - hidden} {
d909 1
a909 1
test winFCmd-15.5 {SetWinFileAttributes - hidden} {
d914 1
a914 1
test winFCmd-15.6 {SetWinFileAttributes - readonly} {
d919 1
a919 1
test winFCmd-15.7 {SetWinFileAttributes - readonly} {
d924 1
a924 1
test winFCmd-15.8 {SetWinFileAttributes - system} {
d929 1
a929 1
test winFCmd-15.9 {SetWinFileAttributes - system} {
d934 1
a934 1
test winFCmd-15.10 {SetWinFileAttributes - failing} {cdrom} {
d939 28
d968 12
a980 1
return
a981 24
foreach source {tef ted tnf tnd "" nul com1} {
    foreach chmodsrc {000 755} {
        foreach dest "tfn tfe tdn tdempty tdfull td1/td2 $p $p/td1 {} nul" {
	    foreach chmoddst {000 755} {
		puts hi
		cleanup
		file delete -force ted tef
		file mkdir ted
		createfile tef
		createfile tfe
		file mkdir tdempty
		file mkdir tdfull/td1/td2

		catch {testchmod $chmodsrc $source}
		catch {testchmod $chmoddst $dest}

		if [catch {file rename $source $dest} msg] {
		    puts "file rename $source ($chmodsrc) $dest ($chmoddst)"
		    puts $msg
		}
	    }
	}
    }
}
@


1.1.1.1
log
@import dejagnu-1999-11-08 snapshot
@
text
@@


1.1.1.2
log
@Tcl 8.3 upgrade
@
text
@a7 1
# Copyright (c) 1998-1999 by Scriptics Corporation.
d12 1
a12 1
# RCS: @@(#) $Id: winFCmd.test,v 1.6.8.2 2000/09/15 16:58:00 spolk Exp $
d15 4
a18 3
if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import -force ::tcltest::*
d47 3
a49 2
set ::tcltest::testConstraints(cdrom) 0
set ::tcltest::testConstraints(exdev) 0
d88 5
a92 2
if {$cdrom != ""} {
    set ::tcltest::testConstraints(cdrom) 1
d100 1
a100 1
	set ::tcltest::testConstraints(exdev) 1
d104 4
d111 1
a111 1
    set ::tcltest::testConstraints(longFileNames) 0
d114 1
a114 1
    set ::tcltest::testConstraints(longFileNames) 1
d134 1
a134 1
test winFCmd-1.1 {TclpRenameFile: errno: EACCES} {pcOnly cdrom} {
d137 1
a137 1
test winFCmd-1.2 {TclpRenameFile: errno: EEXIST} {pcOnly} {
d143 4
a146 1
test winFCmd-1.3 {TclpRenameFile: errno: EINVAL} {pcOnly} {
d150 1
a150 1
test winFCmd-1.4 {TclpRenameFile: errno: EINVAL} {pcOnly} {
d155 1
a155 1
test winFCmd-1.5 {TclpRenameFile: errno: EISDIR} {pcOnly} {
d161 1
a161 1
test winFCmd-1.6 {TclpRenameFile: errno: ENOENT} {pcOnly} {
d165 1
a165 1
test winFCmd-1.7 {TclpRenameFile: errno: ENOENT} {pcOnly} {
d169 1
a169 1
test winFCmd-1.8 {TclpRenameFile: errno: ENOENT} {pcOnly} {
d174 1
a174 1
test winFCmd-1.9 {TclpRenameFile: errno: ENOTDIR} {pcOnly} {
d180 1
a180 1
test winFCmd-1.10 {TclpRenameFile: errno: EXDEV} {pcOnly exdev} {
d187 1
a187 1
test winFCmd-1.11 {TclpRenameFile: errno: EACCES} {pcOnly} {
d194 1
a194 1
test winFCmd-1.12 {TclpRenameFile: errno: EACCES} {pcOnly} {
d202 1
a202 1
test winFCmd-1.13 {TclpRenameFile: errno: EACCES} {pcOnly} {
d216 1
a216 1
test winFCmd-1.16 {TclpRenameFile: MoveFile() != FALSE} {pcOnly} {
d222 1
a222 1
test winFCmd-1.17 {TclpRenameFile: MoveFile() == FALSE} {pcOnly} {
d226 1
a226 1
test winFCmd-1.18 {TclpRenameFile: srcAttr == -1} {pcOnly} {
d230 1
a230 1
test winFCmd-1.19 {TclpRenameFile: errno == EACCES} {pcOnly} {
d234 3
a236 3
test winFCmd-1.20 {TclpRenameFile: src is dir} {nt} {
    # under 95, this would actually succeed and move the current dir out from 
    # under the current process!
d241 4
a244 2
test winFCmd-1.21 {TclpRenameFile: long src} {pcOnly} {
    cleanup
d247 7
a253 1
test winFCmd-1.22 {TclpRenameFile: long dst} {pcOnly} {
d258 1
a258 1
test winFCmd-1.23 {TclpRenameFile: move dir into self} {pcOnly} {
d263 4
a266 1
test winFCmd-1.24 {TclpRenameFile: move a root dir} {pcOnly} {
d270 1
a270 1
test winFCmd-1.25 {TclpRenameFile: cross file systems} {pcOnly cdrom} {
d275 1
a275 1
test winFCmd-1.26 {TclpRenameFile: readonly fs} {pcOnly cdrom} {
d279 1
a279 1
test winFCmd-1.27 {TclpRenameFile: open file} {pcOnly} {
d286 1
a286 1
test winFCmd-1.28 {TclpRenameFile: errno == EEXIST} {pcOnly} {
d293 1
a293 1
test winFCmd-1.29 {TclpRenameFile: src is dir} {pcOnly} {
d299 1
a299 1
test winFCmd-1.30 {TclpRenameFile: dst is dir} {pcOnly} {
d305 1
a305 1
test winFCmd-1.31 {TclpRenameFile: TclpRemoveDirectory fails} {pcOnly} {
d311 1
a311 1
test winFCmd-1.32 {TclpRenameFile: TclpRemoveDirectory succeeds} {pcOnly} {
d318 1
a318 2
test winFCmd-1.33 {TclpRenameFile: After removing dst dir, MoveFile fails} \
	{pcOnly exdev} {
d321 1
a321 2
    file mkdir c:/tf1
    set msg [list [catch {testfile mv c:/tf1 d:/td1} msg] $msg]
a323 1
    file delete -force c:/tf1
d326 1
a326 1
test winFCmd-1.34 {TclpRenameFile: src is dir, dst is not} {pcOnly} {
d331 1
a331 1
test winFCmd-1.35 {TclpRenameFile: src is not dir, dst is} {pcOnly} {
d336 1
a336 1
test winFCmd-1.36 {TclpRenameFile: src and dst not dir} {pcOnly} {
d342 1
a342 1
test winFCmd-1.37 {TclpRenameFile: need to restore temp file} {pcOnly} {
d347 1
a347 1
test winFCmd-2.1 {TclpCopyFile: errno: EACCES} {pcOnly cdrom} {
d351 1
a351 1
test winFCmd-2.2 {TclpCopyFile: errno: EISDIR} {pcOnly} {
d356 1
a356 1
test winFCmd-2.3 {TclpCopyFile: errno: EISDIR} {pcOnly} {
d362 1
a362 1
test winFCmd-2.4 {TclpCopyFile: errno: ENOENT} {pcOnly} {
d366 1
a366 1
test winFCmd-2.5 {TclpCopyFile: errno: ENOENT} {pcOnly} {
d370 1
a370 1
test winFCmd-2.6 {TclpCopyFile: errno: ENOENT} {pcOnly} {
d375 1
a375 1
test winFCmd-2.7 {TclpCopyFile: errno: EACCES} {95} {
d391 1
a391 1
test winFCmd-2.10 {TclpCopyFile: CopyFile succeeds} {pcOnly} {
d397 1
a397 1
test winFCmd-2.11 {TclpCopyFile: CopyFile succeeds} {pcOnly} {
d404 1
a404 1
test winFCmd-2.12 {TclpCopyFile: CopyFile succeeds} {pcOnly} {
d411 1
a411 1
test winFCmd-2.13 {TclpCopyFile: CopyFile fails} {pcOnly} {
d417 1
a417 1
test winFCmd-2.14 {TclpCopyFile: errno == EACCES} {pcOnly} {
d422 1
a422 1
test winFCmd-2.15 {TclpCopyFile: src is directory} {pcOnly} {
d427 1
a427 1
test winFCmd-2.16 {TclpCopyFile: dst is directory} {pcOnly} {
d433 1
a433 1
test winFCmd-2.17 {TclpCopyFile: dst is readonly} {pcOnly} {
d452 1
a452 1
test winFCmd-3.1 {TclpDeleteFile: errno: EACCES} {pcOnly cdrom} {
d455 1
a455 1
test winFCmd-3.2 {TclpDeleteFile: errno: EISDIR} {pcOnly} {
d460 1
a460 1
test winFCmd-3.3 {TclpDeleteFile: errno: ENOENT} {pcOnly} {
d464 1
a464 1
test winFCmd-3.4 {TclpDeleteFile: errno: ENOENT} {pcOnly} {
d468 1
a468 1
test winFCmd-3.5 {TclpDeleteFile: errno: EACCES} {pcOnly} {
d475 1
a475 1
test winFCmd-3.6 {TclpDeleteFile: errno: EACCES} {pcOnly} {
d479 1
a479 1
test winFCmd-3.7 {TclpDeleteFile: DeleteFile succeeds} {pcOnly} {
d485 1
a485 1
test winFCmd-3.8 {TclpDeleteFile: DeleteFile fails} {pcOnly} {
d490 1
a490 1
test winFCmd-3.9 {TclpDeleteFile: errno == EACCES} {pcOnly} {
d497 1
a497 1
test winFCmd-3.10 {TclpDeleteFile: path is readonly} {pcOnly} {
d504 1
a504 1
test winFCmd-3.11 {TclpDeleteFile: still can't remove path} {pcOnly} {
d513 1
a513 1
test winFCmd-4.1 {TclpCreateDirectory: errno: EACCES} {nt cdrom} {
d516 1
a516 1
test winFCmd-4.2 {TclpCreateDirectory: errno: EACCES} {95 cdrom} {
d519 1
a519 1
test winFCmd-4.3 {TclpCreateDirectory: errno: EEXIST} {pcOnly} {
d524 1
a524 1
test winFCmd-4.4 {TclpCreateDirectory: errno: ENOENT} {pcOnly} {
d528 1
a528 1
test winFCmd-4.5 {TclpCreateDirectory: CreateDirectory succeeds} {pcOnly} {
d534 1
a534 1
test winFCmd-5.1 {TclpCopyDirectory: calls TraverseWinTree} {pcOnly} {
d541 1
a541 1
test winFCmd-6.1 {TclpRemoveDirectory: errno: EACCES} {pcOnly} {
d548 1
a548 1
test winFCmd-6.2 {TclpRemoveDirectory: errno: EEXIST} {pcOnly} {
d553 1
a553 1
test winFCmd-6.3 {TclpRemoveDirectory: errno: EACCES} {pcOnly} {
d557 1
a557 1
test winFCmd-6.4 {TclpRemoveDirectory: errno: ENOENT} {pcOnly} {
d561 1
a561 1
test winFCmd-6.5 {TclpRemoveDirectory: errno: ENOENT} {pcOnly} {
d565 1
a565 1
test winFCmd-6.6 {TclpRemoveDirectory: errno: ENOTDIR} {pcOnly} {
d570 1
a570 1
test winFCmd-6.7 {TclpRemoveDirectory: RemoveDirectory succeeds} {pcOnly} {
d576 1
a576 1
test winFCmd-6.8 {TclpRemoveDirectory: RemoveDirectory fails} {pcOnly} {
d581 1
a581 1
test winFCmd-6.9 {TclpRemoveDirectory: errno == EACCES} {pcOnly} {
d588 1
a588 1
test winFCmd-6.10 {TclpRemoveDirectory: attr == -1} {95} {
d596 1
a596 1
test winFCmd-6.12 {TclpRemoveDirectory: errno == EACCES} {95} {
d601 1
a601 1
test winFCmd-6.13 {TclpRemoveDirectory: write-protected} {pcOnly} {
d608 1
a608 1
test winFCmd-6.14 {TclpRemoveDirectory: check if empty dir} {95} {
d613 1
a613 1
test winFCmd-6.15 {TclpRemoveDirectory: !recursive} {pcOnly} {
d618 1
a618 1
test winFCmd-6.16 {TclpRemoveDirectory: recursive, but errno != EEXIST} {pcOnly} {
d623 1
a623 1
test winFCmd-6.17 {TclpRemoveDirectory: calls TraverseWinTree} {pcOnly} {
d630 1
a630 1
test winFCmd-7.1 {TraverseWinTree: targetPtr == NULL} {pcOnly} {
d636 1
a636 1
test winFCmd-7.2 {TraverseWinTree: targetPtr != NULL} {pcOnly} {
d642 1
a642 1
test winFCmd-7.3 {TraverseWinTree: sourceAttr == -1} {pcOnly} {
d646 1
a646 1
test winFCmd-7.4 {TraverseWinTree: source isn't directory} {pcOnly} {
d653 1
a653 1
test winFCmd-7.5 {TraverseWinTree: call TraversalCopy: DOTREE_F} {pcOnly} {
d660 1
a660 1
test winFCmd-7.6 {TraverseWinTree: call TraversalDelete: DOTREE_F} {pcOnly} {
d667 1
a667 1
test winFCmd-7.7 {TraverseWinTree: append \ to source if necessary} {pcOnly} {
d674 1
a674 1
test winFCmd-7.8 {TraverseWinTree: append \ to source if necessary} {95 cdrom} {
d680 1
a680 2
test winFCmd-7.10 {TraverseWinTree: can't read directory: handle == INVALID} \
	{pcOnly} {
d683 1
a683 1
test winFCmd-7.11 {TraverseWinTree: call TraversalCopy: DOTREE_PRED} {pcOnly} {
d691 1
a691 1
test winFCmd-7.12 {TraverseWinTree: call TraversalDelete: DOTREE_PRED} {pcOnly} {
d698 1
a698 1
test winFCmd-7.13 {TraverseWinTree: append \ to target if necessary} {pcOnly} {
d705 1
a705 1
test winFCmd-7.14 {TraverseWinTree: append \ to target if necessary} {95} {
d715 1
a715 1
test winFCmd-7.16 {TraverseWinTree: recurse on files: no files} {pcOnly} {
d720 1
a720 1
test winFCmd-7.17 {TraverseWinTree: recurse on files: one file} {pcOnly} {
d727 1
a727 2
test winFCmd-7.18 {TraverseWinTree: recurse on files: several files and dir} \
	{pcOnly} {
d736 3
a738 3
    lsort [glob td2/*]
} {td2/td2 td2/tf1 td2/tf2 td2/tf3 td2/tf4}
test winFCmd-7.19 {TraverseWinTree: call TraversalCopy: DOTREE_POSTD} {pcOnly} {
d746 1
a746 2
test winFCmd-7.20 {TraverseWinTree: call TraversalDelete: DOTREE_POSTD} \
	{pcOnly} {
d753 1
a753 1
test winFCmd-7.21 {TraverseWinTree: fill errorPtr} {pcOnly} {
d758 1
a758 1
test winFCmd-8.1 {TraversalCopy: DOTREE_F} {pcOnly} {
d763 1
a763 1
test winFCmd-8.2 {TraversalCopy: DOTREE_PRED} {pcOnly} {
d770 1
a770 1
test winFCmd-8.3 {TraversalCopy: DOTREE_POSTD} {pcOnly} {
d776 1
a776 1
test winFCmd-9.1 {TraversalDelete: DOTREE_F} {pcOnly} {
d790 1
a790 1
test winFCmd-9.3 {TraversalDelete: DOTREE_PRED} {pcOnly} {
d797 1
a797 1
test winFCmd-9.4 {TraversalDelete: DOTREE_POSTD} {pcOnly} {
d803 1
a803 1
test winFCmd-10.1 {AttributesPosixError - get} {pcOnly} {
d806 2
a807 2
} {1 {could not read "td1": no such file or directory}}
test winFCmd-10.2 {AttributesPosixError - set} {pcOnly} {
d810 1
a810 1
} {1 {could not read "td1": no such file or directory}}
d812 1
a812 1
test winFCmd-11.1 {GetWinFileAttributes} {pcOnly} {
d817 1
a817 1
test winFCmd-11.2 {GetWinFileAttributes} {pcOnly} {
d822 1
a822 1
test winFCmd-11.3 {GetWinFileAttributes} {pcOnly} {
d827 1
a827 1
test winFCmd-11.4 {GetWinFileAttributes} {pcOnly} {
a831 11
test winfcmd-11.5 {GetWinFileAttributes} {pcOnly} {
    # attr of relative paths that resolve to root was failing
    # don't care about answer, just that test runs.

    set old [pwd]
    cd c:/
    file attr c:	    
    file attr c:.
    file attr . 
    cd $old
} {}
d833 1
a833 1
test winFCmd-12.1 {ConvertFileNameFormat} {pcOnly} {
d838 1
a838 1
test winFCmd-12.2 {ConvertFileNameFormat} {pcOnly} {
d844 1
a844 1
test winFCmd-12.3 {ConvertFileNameFormat} {pcOnly} {
d851 1
a851 1
test winFCmd-12.4 {ConvertFileNameFormat} {pcOnly} {
d856 1
a856 1
test winFCmd-12.5 {ConvertFileNameFormat: absolute path} {pcOnly} {
d859 1
a859 1
test winFCmd-12.6 {ConvertFileNameFormat: absolute path with drive} {pcOnly} {
d864 11
a874 4
test winFCmd-12.7 {ConvertFileNameFormat} {nonPortable pcOnly} {
    string tolower [file attributes //bisque/tcl/ws -longname]
} {//bisque/tcl/ws}
test winFCmd-12.8 {ConvertFileNameFormat} {pcOnly longFileNames} {
d879 1
a879 1
test winFCmd-12.10 {ConvertFileNameFormat} {longFileNames pcOnly} {
d884 1
a884 1
test winFCmd-12.11 {ConvertFileNameFormat} {longFileNames pcOnly} {
d890 1
a890 1
test winFCmd-13.1 {GetWinFileLongName} {pcOnly} {
d896 1
a896 1
test winFCmd-14.1 {GetWinFileShortName} {pcOnly} {
d902 1
a902 1
test winFCmd-15.1 {SetWinFileAttributes} {pcOnly} {
d905 2
a906 2
} {1 {could not read "td1": no such file or directory}}
test winFCmd-15.2 {SetWinFileAttributes - archive} {pcOnly} {
d911 1
a911 1
test winFCmd-15.3 {SetWinFileAttributes - archive} {pcOnly} {
d916 1
a916 1
test winFCmd-15.4 {SetWinFileAttributes - hidden} {pcOnly} {
d921 1
a921 1
test winFCmd-15.5 {SetWinFileAttributes - hidden} {pcOnly} {
d926 1
a926 1
test winFCmd-15.6 {SetWinFileAttributes - readonly} {pcOnly} {
d931 1
a931 1
test winFCmd-15.7 {SetWinFileAttributes - readonly} {pcOnly} {
d936 1
a936 1
test winFCmd-15.8 {SetWinFileAttributes - system} {pcOnly} {
d941 1
a941 1
test winFCmd-15.9 {SetWinFileAttributes - system} {pcOnly} {
d946 1
a946 1
test winFCmd-15.10 {SetWinFileAttributes - failing} {pcOnly cdrom} {
d951 1
a951 26
# This block of code used to occur after the "return" call, so I'm
# commenting it out and assuming that this code is still under construction.
#foreach source {tef ted tnf tnd "" nul com1} {
#    foreach chmodsrc {000 755} {
#        foreach dest "tfn tfe tdn tdempty tdfull td1/td2 $p $p/td1 {} nul" {
#	    foreach chmoddst {000 755} {
#		puts hi
#		cleanup
#		file delete -force ted tef
#		file mkdir ted
#		createfile tef
#		createfile tfe
#		file mkdir tdempty
#		file mkdir tdfull/td1/td2
#
#		catch {testchmod $chmodsrc $source}
#		catch {testchmod $chmoddst $dest}
#
#		if [catch {file rename $source $dest} msg] {
#		    puts "file rename $source ($chmodsrc) $dest ($chmoddst)"
#		    puts $msg
#		}
#	    }
#	}
#    }
#}
a952 3
# cleanup
cleanup
::tcltest::cleanupTests
d955 24
a978 11











@


1.1.1.3
log
@import tcl 8.4.0
@
text
@d13 1
a13 1
# RCS: @@(#) $Id: winFCmd.test,v 1.19 2002/07/18 16:35:12 vincentdarley Exp $
d39 1
a39 1
	    set x [glob -directory $p tf* td*]
a46 14
if {[string equal $tcl_platform(platform) "windows"]} {
    if {[string equal $tcl_platform(os) "Windows NT"] \
      && [string equal [string index $tcl_platform(osVersion) 0] "5"]} {
	tcltest::testConstraint win2000orXP 1
	tcltest::testConstraint winOlderThan2000 0
    } else {
	tcltest::testConstraint win2000orXP 0
	tcltest::testConstraint winOlderThan2000 1
    }
} else {
    tcltest::testConstraint win2000orXP 0
    tcltest::testConstraint winOlderThan2000 0
}

d191 1
a191 5
test winFCmd-1.13 {TclpRenameFile: errno: EACCES} {pcOnly win2000orXP} {
    cleanup
    list [catch {testfile mv nul tf1} msg] $msg
} {1 EINVAL}
test winFCmd-1.13.1 {TclpRenameFile: errno: EACCES} {pcOnly winOlderThan2000} {
d195 1
a195 1
test winFCmd-1.14 {TclpRenameFile: errno: EACCES} {pcOnly 95} {
d200 1
a200 1
test winFCmd-1.15 {TclpRenameFile: errno: EEXIST} {pcOnly nt} {
d219 1
a219 5
test winFCmd-1.19 {TclpRenameFile: errno == EACCES} {pcOnly win2000orXP} {
    cleanup
    list [catch {testfile mv nul tf1} msg] $msg
} {1 EINVAL}
test winFCmd-1.19.1 {TclpRenameFile: errno == EACCES} {pcOnly winOlderThan2000} {
d223 1
a223 1
test winFCmd-1.20 {TclpRenameFile: src is dir} {pcOnly nt} {
d356 1
a356 1
test winFCmd-2.7 {TclpCopyFile: errno: EACCES} {pcOnly 95} {
d364 1
a364 5
test winFCmd-2.8 {TclpCopyFile: errno: EACCES} {pcOnly win2000orXP} {
    cleanup
    list [catch {testfile cp nul tf1} msg] $msg
} {1 EINVAL}
test winFCmd-2.8.1 {TclpCopyFile: errno: EACCES} {pcOnly nt winOlderThan2000} {
d368 1
a368 1
test winFCmd-2.9 {TclpCopyFile: errno: ENOENT} {pcOnly 95} {
d422 1
a422 1
test winFCmd-2.18 {TclpCopyFile: still can't copy onto dst} {pcOnly 95} {
d494 1
a494 1
test winFCmd-4.1 {TclpCreateDirectory: errno: EACCES} {pcOnly nt cdrom} {
d497 1
a497 1
test winFCmd-4.2 {TclpCreateDirectory: errno: EACCES} {pcOnly 95 cdrom} {
d532 1
a532 1
    list [catch {testfile rmdir td1} msg] [file tail $msg]
d540 1
a540 1
    list [catch {testfile rmdir td1} msg] [file tail $msg]
d549 1
a549 1
    list [catch {testfile rmdir tf1} msg] [file tail $msg]
d560 1
a560 1
    list [catch {testfile rmdir tf1} msg] [file tail $msg]
d569 1
a569 1
test winFCmd-6.10 {TclpRemoveDirectory: attr == -1} {pcOnly 95} {
d573 1
a573 1
test winFCmd-6.11 {TclpRemoveDirectory: attr == -1} {pcOnly nt} {
d576 2
a577 2
} {1 {/ EACCES}}
test winFCmd-6.12 {TclpRemoveDirectory: errno == EACCES} {pcOnly 95} {
d589 1
a589 1
test winFCmd-6.14 {TclpRemoveDirectory: check if empty dir} {pcOnly 95} {
d597 1
a597 1
    list [catch {testfile rmdir td1} msg] [file tail $msg]
d655 6
a660 7
test winFCmd-7.8 {TraverseWinTree: append \ to source if necessary} {pcOnly 95 cdrom} {
    # cdrom can return either d:\ or D:/, but we only care about the errcode
    list [catch {testfile rmdir $cdrom/} msg] [lindex $msg 1]
} {1 EEXIST}
test winFCmd-7.9 {TraverseWinTree: append \ to source if necessary} {pcOnly nt cdrom} {
    list [catch {testfile rmdir $cdrom/} msg]  [lindex $msg 1]
} {1 EACCES}
d687 1
a687 1
test winFCmd-7.14 {TraverseWinTree: append \ to target if necessary} {pcOnly 95} {
d691 2
a692 2
} {1 {/ EEXIST}}
test winFCmd-7.15 {TraverseWinTree: append \ to target if necessary} {pcOnly nt} {
d696 1
a696 1
} {1 {/ EACCES}}
d766 1
a766 1
test winFCmd-9.2 {TraversalDelete: DOTREE_F} {pcOnly 95} {
d816 1
a816 1
test winFCmd-11.5 {GetWinFileAttributes} {pcOnly} {
a826 3
test winFCmd-11.6 {GetWinFileAttributes} {pcOnly} {
    file attr c:/ -hidden
} {0}
a937 3
test winFCmd-16.1 {Windows file normalization} {pcOnly} {
    list [file normalize c:/] [file normalize C:/]
} {C:/ C:/}
d970 13
@


1.1.1.4
log
@import tcl 8.4.1
@
text
@d13 1
a13 1
# RCS: @@(#) $Id: winFCmd.test,v 1.20 2002/10/04 08:25:14 dkf Exp $
d291 1
a291 1
    list [file exists tf1] [file exists tf2]
d316 1
a316 1
    list [file exists td1] [file exists td2] [file exists td2/td2]
d490 1
a490 1
    file exists tf1
d553 1
a553 1
    file exists td1
@


