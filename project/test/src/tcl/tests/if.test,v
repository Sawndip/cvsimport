head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.58
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.56
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.54
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.52
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.50
	gdb_7_0-branch:1.5.0.48
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tcl8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.46
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.44
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.42
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.40
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.38
	gdb_6_5-2006-05-14-branchpoint:1.5
	readline_5_1-import-branch:1.5.0.36
	readline_5_1-import-branchpoint:1.5
	gdb_6_4-branch:1.5.0.34
	gdb_6_4-2005-11-01-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.32
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	ezannoni_pie-20040323-branch:1.5.0.30
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.28
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.26
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.24
	cagney_x86i386-20030821-branch:1.5.0.22
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.20
	gdb_6_0-2003-06-23-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.18
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.16
	cagney_writestrings-20030508-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.14
	cagney_fileio-20030521-branchpoint:1.5
	carlton_dictionary-20030430-merge:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.12
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.10
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.8
	cagney_lazyid-20030317-branchpoint:1.5
	offbyone-20030313-branch:1.5.0.6
	offbyone-20030313-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.4
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.2
	interps-20030202-branchpoint:1.5
	TCL8_4_1:1.1.1.3
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.2
	TCL_8_4_1:1.1.1.3
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.4
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TCL_8_4_0:1.1.1.3
	carlton_dictionary-branch:1.2.0.16
	carlton_dictionary-20020920-branchpoint:1.2
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.14
	gdb_5_3-branch:1.2.0.12
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.10
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.8
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.6
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TCL_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	dejagnu-2000-02-04:1.1.1.1
	dejagnu-2000-01-31:1.1.1.1
	dejagnu-2000-01-24:1.1.1.1
	dejagnu-2000-01-17:1.1.1.1
	dejagnu-2000-01-10:1.1.1.1
	dejagnu-2000-01-04:1.1.1.1
	dejagnu-1999-12-21:1.1.1.1
	dejagnu-1999-12-13:1.1.1.1
	dejagnu-1999-12-07:1.1.1.1
	dejagnu-1999-12-06:1.1.1.1
	dejagnu-1999-11-15:1.1.1.1
	dejagnu-1999-11-08:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2003.01.21.19.40.15;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.26.19.48.01;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.37.07;	author kseitz;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2001.09.09.23.56.08;	author irox;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2002.09.27.21.49.10;	author kseitz;	state Exp;
branches;
next	;

1.3.4.1
date	2003.12.14.20.28.49;	author drow;	state Exp;
branches;
next	;

1.2.16.1
date	2002.12.23.19.40.40;	author carlton;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2003.02.07.19.18.18;	author carlton;	state Exp;
branches;
next	;

1.1.1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.09.22.40.58;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.19.56.36;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tcl 8.4.1
@
text
@# Commands covered:  if
#
# This file contains a collection of tests for one or more of the Tcl
# built-in commands.  Sourcing this file into Tcl runs the tests and
# generates output for errors.  No output means no errors were found.
#
# Copyright (c) 1996 Sun Microsystems, Inc.
# Copyright (c) 1998-1999 by Scriptics Corporation.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# RCS: @@(#) $Id: if.test,v 1.7 2001/12/04 15:36:29 dkf Exp $

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import -force ::tcltest::*
}

# Basic "if" operation.

catch {unset a}
test if-1.1 {TclCompileIfCmd: missing if/elseif test} {
    list [catch {if} msg] $msg
} {1 {wrong # args: no expression after "if" argument}}
test if-1.2 {TclCompileIfCmd: error in if/elseif test} {
    list [catch {if {[error "error in condition"]} foo} msg] $msg
} {1 {error in condition}}
test if-1.3 {TclCompileIfCmd: error in if/elseif test} {
    list [catch {if {1+}} msg] $msg $errorInfo
} {1 {syntax error in expression "1+": premature end of expression} {syntax error in expression "1+": premature end of expression
    ("if" test expression)
    while compiling
"if {1+}"}}
test if-1.4 {TclCompileIfCmd: if/elseif test in braces} {
    set a {}
    if {1<2} {set a 1}
    set a
} {1}
test if-1.5 {TclCompileIfCmd: if/elseif test not in braces} {
    set a {}
    if 1<2 {set a 1}
    set a
} {1}
test if-1.6 {TclCompileIfCmd: multiline test expr} {
    set a {}
    if {($tcl_platform(platform) != "foobar1") && \
	($tcl_platform(platform) != "foobar2")} {set a 3} else {set a 4}
    set a
} 3
test if-1.7 {TclCompileIfCmd: "then" after if/elseif test} {
    set a {}
    if 4>3 then {set a 1}
    set a
} {1}
test if-1.8 {TclCompileIfCmd: keyword other than "then" after if/elseif test} {
    set a {}
    catch {if 1<2 therefore {set a 1}} msg 
    set msg
} {invalid command name "therefore"}
test if-1.9 {TclCompileIfCmd: missing "then" body} {
    set a {}
    catch {if 1<2 then} msg 
    set msg
} {wrong # args: no script following "then" argument}
test if-1.10 {TclCompileIfCmd: error in "then" body} {
    set a {}
    list [catch {if {$a!="xxx"} then {set}} msg] $msg $errorInfo
} {1 {wrong # args: should be "set varName ?newValue?"} {wrong # args: should be "set varName ?newValue?"
    while compiling
"set"
    ("if" then script line 1)
    while compiling
"if {$a!="xxx"} then {set}"}}
test if-1.11 {TclCompileIfCmd: error in "then" body} {
    list [catch {if 2 then {[error "error in then clause"]}} msg] $msg
} {1 {error in then clause}}
test if-1.12 {TclCompileIfCmd: "then" body in quotes} {
    set a {}
    if 27>17 "append a x"
    set a
} {x}
test if-1.13 {TclCompileIfCmd: computed "then" body} {
    catch {unset x1}
    catch {unset x2}
    set a {}
    set x1 {append a x1}
    set x2 {; append a x2}
    set a {}
    if 1 $x1$x2
    set a
} {x1x2}
test if-1.14 {TclCompileIfCmd: taking proper branch} {
    set a {}
    if 1<2 {set a 1}
    set a
} 1
test if-1.15 {TclCompileIfCmd: taking proper branch} {
    set a {}
    if 1>2 {set a 1}
    set a
} {}
test if-1.16 {TclCompileIfCmd: test jumpFalse instruction replacement after long "then" body} {
    catch {unset i}
    set a {}
    if 1<2 {
	set a 1
	while {$a != "xxx"} {
	    break;
	    while {$i >= 0} {
		if {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		if {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		if {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		if {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		set i [expr $i-1]
	    }
	}
	set a 2
	while {$a != "xxx"} {
	    break;
	    while {$i >= 0} {
		if {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		if {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		if {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		if {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		set i [expr $i-1]
	    }
	}
	set a 3
    }
    set a
} 3
test if-1.17 {TclCompileIfCmd: if/elseif test in quotes} {
    set a {}
    list [catch {if {"0 < 3"} {set a 1}} msg] $msg
} {1 {expected boolean value but got "0 < 3"}}


test if-2.1 {TclCompileIfCmd: "elseif" after if/elseif test} {
    set a {}
    if 3>4 {set a 1} elseif 1 {set a 2}
    set a
} {2}
# Since "else" is optional, the "elwood" below is treated as a command.
# But then there shouldn't be any additional argument words for the "if".
test if-2.2 {TclCompileIfCmd: keyword other than "elseif"} {
    set a {}
    catch {if 1<2 {set a 1} elwood {set a 2}} msg 
    set msg
} {wrong # args: extra words after "else" clause in "if" command}
test if-2.3 {TclCompileIfCmd: missing expression after "elseif"} {
    set a {}
    catch {if 1<2 {set a 1} elseif} msg 
    set msg
} {wrong # args: no expression after "elseif" argument}
test if-2.4 {TclCompileIfCmd: error in expression after "elseif"} {
    set a {}
    list [catch {if 3>4 {set a 1} elseif {1>}} msg] $msg $errorInfo
} {1 {syntax error in expression "1>": premature end of expression} {syntax error in expression "1>": premature end of expression
    ("if" test expression)
    while compiling
"if 3>4 {set a 1} elseif {1>}"}}
test if-2.5 {TclCompileIfCmd: test jumpFalse instruction replacement after long "elseif" body} {
    catch {unset i}
    set a {}
    if 1>2 {
	set a 1
	while {$a != "xxx"} {
	    break;
	    while {$i >= 0} {
		if {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		if {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		if {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		if {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		set i [expr $i-1]
	    }
	}
	set a 2
	while {$a != "xxx"} {
	    break;
	    while {$i >= 0} {
		if {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		if {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		if {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		if {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		set i [expr $i-1]
	    }
	}
	set a 3
    } elseif 1<2 then { #; this if arm should be taken
	set a 4
	while {$a != "xxx"} {
	    break;
	    while {$i >= 0} {
		if {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		if {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		if {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		if {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		set i [expr $i-1]
	    }
	}
	set a 5
	while {$a != "xxx"} {
	    break;
	    while {$i >= 0} {
		if {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		if {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		if {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		if {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		set i [expr $i-1]
	    }
	}
	set a 6
    }
    set a
} 6

test if-3.1 {TclCompileIfCmd: "else" clause} {
    set a {}
    if 3>4 {set a 1} elseif {$a == "foo"} {set a 2} else {set a 3}
    set a
} 3
# Since "else" is optional, the "elsex" below is treated as a command.
# But then there shouldn't be any additional argument words for the "if".
test if-3.2 {TclCompileIfCmd: keyword other than "else"} {
    set a {}
    catch {if 1<2 then {set a 1} elsex {set a 2}} msg 
    set msg
} {wrong # args: extra words after "else" clause in "if" command}
test if-3.3 {TclCompileIfCmd: missing body after "else"} {
    set a {}
    catch {if 2<1 {set a 1} else} msg 
    set msg
} {wrong # args: no script following "else" argument}
test if-3.4 {TclCompileIfCmd: error compiling body after "else"} {
    set a {}
    catch {if 2<1 {set a 1} else {set}} msg 
    set errorInfo
} {wrong # args: should be "set varName ?newValue?"
    while compiling
"set"
    ("if" else script line 1)
    while compiling
"if 2<1 {set a 1} else {set}"}
test if-3.5 {TclCompileIfCmd: extra arguments after "else" argument} {
    set a {}
    catch {if 2<1 {set a 1} else {set a 2} or something} msg 
    set msg
} {wrong # args: extra words after "else" clause in "if" command}
# The following test also checks whether contained loops and other
# commands are properly relocated because a short jump must be replaced
# by a "long distance" one.
test if-3.6 {TclCompileIfCmd: test jumpFalse instruction replacement after long "else" clause} {
    catch {unset i}
    set a {}
    if 1>2 {
	set a 1
	while {$a != "xxx"} {
	    break;
	    while {$i >= 0} {
		if {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		if {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		if {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		if {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		set i [expr $i-1]
	    }
	}
	set a 2
	while {$a != "xxx"} {
	    break;
	    while {$i >= 0} {
		if {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		if {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		if {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		if {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		set i [expr $i-1]
	    }
	}
	set a 3
    } elseif 1==2 then { #; this if arm should be taken
	set a 4
	while {$a != "xxx"} {
	    break;
	    while {$i >= 0} {
		if {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		if {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		if {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		if {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		set i [expr $i-1]
	    }
	}
	set a 5
	while {$a != "xxx"} {
	    break;
	    while {$i >= 0} {
		if {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		if {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		if {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		if {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		set i [expr $i-1]
	    }
	}
	set a 6
    } else {
	set a 7
	while {$a != "xxx"} {
	    break;
	    while {$i >= 0} {
		if {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		if {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		if {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		if {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		set i [expr $i-1]
	    }
	}
	set a 8
	while {$a != "xxx"} {
	    break;
	    while {$i >= 0} {
		if {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		if {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		if {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		if {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		set i [expr $i-1]
	    }
	}
	set a 9
    }
    set a
} 9

test if-4.1 {TclCompileIfCmd: "if" command result} {
    set a {}
    set a [if 3<4 {set i 27}]
    set a
} 27
test if-4.2 {TclCompileIfCmd: "if" command result} {
    set a {}
    set a [if 3>4 {set i 27}]
    set a
} {}
test if-4.3 {TclCompileIfCmd: "if" command result} {
    set a {}
    set a [if 0 {set i 1} elseif 1 {set i 2}]
    set a
} 2
test if-4.4 {TclCompileIfCmd: "if" command result} {
    set a {}
    set a [if 0 {set i 1} elseif 0 {set i 2} elseif 2>5 {set i 3} else {set i 4}]
    set a
} 4
test if-4.5 {TclCompileIfCmd: return value} {
    if 0 then {set a 22; concat abc} elseif 1 {concat def} {concat ghi}
} def

# Check "if" and computed command names.

catch {unset a}
test if-5.1 {if cmd with computed command names: missing if/elseif test} {
    set z if
    list [catch {$z} msg] $msg
} {1 {wrong # args: no expression after "if" argument}}

test if-5.2 {if cmd with computed command names: error in if/elseif test} {
    set z if
    list [catch {$z {[error "error in condition"]} foo} msg] $msg
} {1 {error in condition}}
test if-5.3 {if cmd with computed command names: error in if/elseif test} {
    set z if
    list [catch {$z {1+}} msg] $msg $errorInfo
} {1 {syntax error in expression "1+": premature end of expression} {syntax error in expression "1+": premature end of expression
    while executing
"$z {1+}"}}
test if-5.4 {if cmd with computed command names: if/elseif test in braces} {
    set z if
    set a {}
    $z {1<2} {set a 1}
    set a
} {1}
test if-5.5 {if cmd with computed command names: if/elseif test not in braces} {
    set z if
    set a {}
    $z 1<2 {set a 1}
    set a
} {1}
test if-5.6 {if cmd with computed command names: multiline test expr} {
    set z if
    set a {}
    $z {($tcl_platform(platform) != "foobar1") && \
	($tcl_platform(platform) != "foobar2")} {set a 3} else {set a 4}
    set a
} 3
test if-5.7 {if cmd with computed command names: "then" after if/elseif test} {
    set z if
    set a {}
    $z 4>3 then {set a 1}
    set a
} {1}
test if-5.8 {if cmd with computed command names: keyword other than "then" after if/elseif test} {
    set z if
    set a {}
    catch {$z 1<2 therefore {set a 1}} msg 
    set msg
} {invalid command name "therefore"}
test if-5.9 {if cmd with computed command names: missing "then" body} {
    set z if
    set a {}
    catch {$z 1<2 then} msg 
    set msg
} {wrong # args: no script following "then" argument}
test if-5.10 {if cmd with computed command names: error in "then" body} {
    set z if
    set a {}
    list [catch {$z {$a!="xxx"} then {set}} msg] $msg $errorInfo
} {1 {wrong # args: should be "set varName ?newValue?"} {wrong # args: should be "set varName ?newValue?"
    while compiling
"set"
    invoked from within
"$z {$a!="xxx"} then {set}"}}
test if-5.11 {if cmd with computed command names: error in "then" body} {
    set z if
    list [catch {$z 2 then {[error "error in then clause"]}} msg] $msg
} {1 {error in then clause}}
test if-5.12 {if cmd with computed command names: "then" body in quotes} {
    set z if
    set a {}
    $z 27>17 "append a x"
    set a
} {x}
test if-5.13 {if cmd with computed command names: computed "then" body} {
    set z if
    catch {unset x1}
    catch {unset x2}
    set a {}
    set x1 {append a x1}
    set x2 {; append a x2}
    set a {}
    $z 1 $x1$x2
    set a
} {x1x2}
test if-5.14 {if cmd with computed command names: taking proper branch} {
    set z if
    set a {}
    $z 1<2 {set a 1}
    set a
} 1
test if-5.15 {if cmd with computed command names: taking proper branch} {
    set z if
    set a {}
    $z 1>2 {set a 1}
    set a
} {}
test if-5.16 {if cmd with computed command names: test jumpFalse instruction replacement after long "then" body} {
    set z if
    catch {unset i}
    set a {}
    $z 1<2 {
	set a 1
	while {$a != "xxx"} {
	    break;
	    while {$i >= 0} {
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		set i [expr $i-1]
	    }
	}
	set a 2
	while {$a != "xxx"} {
	    break;
	    while {$i >= 0} {
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		set i [expr $i-1]
	    }
	}
	set a 3
    }
    set a
} 3
test if-5.17 {if cmd with computed command names: if/elseif test in quotes} {
    set z if
    set a {}
    list [catch {$z {"0 < 3"} {set a 1}} msg] $msg
} {1 {expected boolean value but got "0 < 3"}}


test if-6.1 {if cmd with computed command names: "elseif" after if/elseif test} {
    set z if
    set a {}
    $z 3>4 {set a 1} elseif 1 {set a 2}
    set a
} {2}
# Since "else" is optional, the "elwood" below is treated as a command.
# But then there shouldn't be any additional argument words for the "if".
test if-6.2 {if cmd with computed command names: keyword other than "elseif"} {
    set z if
    set a {}
    catch {$z 1<2 {set a 1} elwood {set a 2}} msg 
    set msg
} {wrong # args: extra words after "else" clause in "if" command}
test if-6.3 {if cmd with computed command names: missing expression after "elseif"} {
    set z if
    set a {}
    catch {$z 1<2 {set a 1} elseif} msg 
    set msg
} {wrong # args: no expression after "elseif" argument}
test if-6.4 {if cmd with computed command names: error in expression after "elseif"} {
    set z if
    set a {}
    list [catch {$z 3>4 {set a 1} elseif {1>}} msg] $msg $errorInfo
} {1 {syntax error in expression "1>": premature end of expression} {syntax error in expression "1>": premature end of expression
    while executing
"$z 3>4 {set a 1} elseif {1>}"}}
test if-6.5 {if cmd with computed command names: test jumpFalse instruction replacement after long "elseif" body} {
    set z if
    catch {unset i}
    set a {}
    $z 1>2 {
	set a 1
	while {$a != "xxx"} {
	    break;
	    while {$i >= 0} {
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		set i [expr $i-1]
	    }
	}
	set a 2
	while {$a != "xxx"} {
	    break;
	    while {$i >= 0} {
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		set i [expr $i-1]
	    }
	}
	set a 3
    } elseif 1<2 then { #; this if arm should be taken
	set a 4
	while {$a != "xxx"} {
	    break;
	    while {$i >= 0} {
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		set i [expr $i-1]
	    }
	}
	set a 5
	while {$a != "xxx"} {
	    break;
	    while {$i >= 0} {
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		set i [expr $i-1]
	    }
	}
	set a 6
    }
    set a
} 6

test if-7.1 {if cmd with computed command names: "else" clause} {
    set z if
    set a {}
    $z 3>4 {set a 1} elseif {$a == "foo"} {set a 2} else {set a 3}
    set a
} 3
# Since "else" is optional, the "elsex" below is treated as a command.
# But then there shouldn't be any additional argument words for the "if".
test if-7.2 {if cmd with computed command names: keyword other than "else"} {
    set z if
    set a {}
    catch {$z 1<2 then {set a 1} elsex {set a 2}} msg 
    set msg
} {wrong # args: extra words after "else" clause in "if" command}
test if-7.3 {if cmd with computed command names: missing body after "else"} {
    set z if
    set a {}
    catch {$z 2<1 {set a 1} else} msg 
    set msg
} {wrong # args: no script following "else" argument}
test if-7.4 {if cmd with computed command names: error compiling body after "else"} {
    set z if
    set a {}
    catch {$z 2<1 {set a 1} else {set}} msg 
    set errorInfo
} {wrong # args: should be "set varName ?newValue?"
    while compiling
"set"
    invoked from within
"$z 2<1 {set a 1} else {set}"}
test if-7.5 {if cmd with computed command names: extra arguments after "else" argument} {
    set z if
    set a {}
    catch {$z 2<1 {set a 1} else {set a 2} or something} msg 
    set msg
} {wrong # args: extra words after "else" clause in "if" command}
# The following test also checks whether contained loops and other
# commands are properly relocated because a short jump must be replaced
# by a "long distance" one.
test if-7.6 {if cmd with computed command names: test jumpFalse instruction replacement after long "else" clause} {
    set z if
    catch {unset i}
    set a {}
    $z 1>2 {
	set a 1
	while {$a != "xxx"} {
	    break;
	    while {$i >= 0} {
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		set i [expr $i-1]
	    }
	}
	set a 2
	while {$a != "xxx"} {
	    break;
	    while {$i >= 0} {
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		set i [expr $i-1]
	    }
	}
	set a 3
    } elseif 1==2 then { #; this if arm should be taken
	set a 4
	while {$a != "xxx"} {
	    break;
	    while {$i >= 0} {
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		set i [expr $i-1]
	    }
	}
	set a 5
	while {$a != "xxx"} {
	    break;
	    while {$i >= 0} {
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		set i [expr $i-1]
	    }
	}
	set a 6
    } else {
	set a 7
	while {$a != "xxx"} {
	    break;
	    while {$i >= 0} {
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		set i [expr $i-1]
	    }
	}
	set a 8
	while {$a != "xxx"} {
	    break;
	    while {$i >= 0} {
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		set i [expr $i-1]
	    }
	}
	set a 9
    }
    set a
} 9

test if-8.1 {if cmd with computed command names: "if" command result} {
    set z if
    set a {}
    set a [$z 3<4 {set i 27}]
    set a
} 27
test if-8.2 {if cmd with computed command names: "if" command result} {
    set z if
    set a {}
    set a [$z 3>4 {set i 27}]
    set a
} {}
test if-8.3 {if cmd with computed command names: "if" command result} {
    set z if
    set a {}
    set a [$z 0 {set i 1} elseif 1 {set i 2}]
    set a
} 2
test if-8.4 {if cmd with computed command names: "if" command result} {
    set z if
    set a {}
    set a [$z 0 {set i 1} elseif 0 {set i 2} elseif 2>5 {set i 3} else {set i 4}]
    set a
} 4
test if-8.5 {if cmd with computed command names: return value} {
    set z if
    $z 0 then {set a 22; concat abc} elseif 1 {concat def} {concat ghi}
} def

test if-9.1 {if cmd with namespace qualifiers} {
    ::if {1} {set x 4}
} 4

# Test for incorrect "double evaluation semantics"

test if-10.1 {delayed substitution of then body} {
    set j 0
    set if if
    # this is not compiled
    $if {[incr j] == 1} "
       set result $j
    "
    # this will be compiled
    proc p {} {
	set j 0
	if {[incr j]} "
	    set result $j
	"
	set result
    }
    append result [p]
} {00}
test if-10.2 {delayed substitution of elseif expression} {
    set j 0
    set if if
    # this is not compiled
    $if {[incr j] == 0} {
       set result badthen
    } elseif "$j == 1" {
       set result badelseif
    } else {
       set result 0
    }
    # this will be compiled
    proc p {} {
	set j 0
	if {[incr j] == 0} {
	    set result badthen
	} elseif "$j == 1" {
	    set result badelseif
	} else {
	    set result 0
	}
	set result
    }
    append result [p]
} {00}
test if-10.3 {delayed substitution of elseif body} {
    set j 0
    set if if
    # this is not compiled
    $if {[incr j] == 0} {
       set result badthen
    } elseif {1} "
       set result $j
    "
    # this will be compiled
    proc p {} {
	set j 0
	if {[incr j] == 0} {
	    set result badthen
	} elseif {1} "
	    set result $j
	"
    }
    append result [p]
} {00}
test if-10.4 {delayed substitution of else body} {
    set j 0
    if {[incr j] == 0} {
       set result badthen
    } else "
       set result $j
    "
    set result
} {0}
test if-10.5 {substituted control words} {
    set then then; proc then {} {return badthen}
    set else else; proc else {} {return badelse}
    set elseif elseif; proc elseif {} {return badelseif}
    list [catch {if 1 $then {if 0 {} $elseif 1 {if 0 {} $else {list ok}}}} a] $a
} {0 ok}
test if-10.6 {double invocation of variable traces} {
    set iftracecounter 0
    proc iftraceproc {args} {
       upvar #0 iftracecounter counter
       set argc [llength $args]
       set extraargs [lrange $args 0 [expr {$argc - 4}]]
       set name [lindex $args [expr {$argc - 3}]]
       upvar 1 $name var
       if {[incr counter] % 2 == 1} {
           set var "$counter oops [concat $extraargs]"
       } else {
           set var "$counter + [concat $extraargs]"
       }
    }
    trace variable iftracevar r [list iftraceproc 10]
    list [catch {if "$iftracevar + 20" {}} a] $a \
        [catch {if "$iftracevar + 20" {}} b] $b \
        [unset iftracevar iftracecounter]
} {1 {syntax error in expression "1 oops 10 + 20": extra tokens at end of expression} 0 {} {}}

# cleanup
::tcltest::cleanupTests
return
@


1.4
log
@touched all sources to ease next import
@
text
@d13 1
a13 1
# RCS: @@(#) $Id: if.test,v 1.6.8.2 2000/09/15 16:56:37 spolk Exp $
d31 1
a31 1
} {1 {syntax error in expression "1+"} {syntax error in expression "1+"
d183 1
a183 1
} {1 {syntax error in expression "1>"} {syntax error in expression "1>"
d515 1
a515 1
} {1 {syntax error in expression "1+"} {syntax error in expression "1+"
d683 1
a683 1
} {1 {syntax error in expression "1>"} {syntax error in expression "1>"
d1016 1
a1016 1
test if-10.1 {delayed substitution of then body} {knownBug} {
d1018 3
a1020 1
    if {[incr j] == 1} "
d1023 11
a1033 3
    set result
} {0}
test if-10.2 {delayed substitution of elseif expression} {knownBug} {
d1035 3
a1037 1
    if {[incr j] == 0} {
d1042 13
a1054 1
       set result ok
d1056 3
a1058 3
    set result
} {ok}
test if-10.3 {delayed substitution of elseif body} {knownBug} {
d1060 3
a1062 1
    if {[incr j] == 0} {
d1067 12
a1078 3
    set result
} {0}
test if-10.4 {delayed substitution of else body} {knownBug} {
d1087 1
a1087 1
test if-10.5 {substituted control words} {knownBug} {
d1093 1
a1093 1
test if-10.6 {double invocation of variable traces} {knownBug} {
d1111 1
a1111 1
} {1 {syntax error in expression "1 oops 10 + 20"} 0 {} {}}
a1115 13













@


1.3
log
@touched all sources to ease next import
@
text
@@


1.3.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d13 1
a13 1
# RCS: @@(#) $Id: if.test,v 1.7 2001/12/04 15:36:29 dkf Exp $
d31 1
a31 1
} {1 {syntax error in expression "1+": premature end of expression} {syntax error in expression "1+": premature end of expression
d183 1
a183 1
} {1 {syntax error in expression "1>": premature end of expression} {syntax error in expression "1>": premature end of expression
d515 1
a515 1
} {1 {syntax error in expression "1+": premature end of expression} {syntax error in expression "1+": premature end of expression
d683 1
a683 1
} {1 {syntax error in expression "1>": premature end of expression} {syntax error in expression "1>": premature end of expression
d1016 1
a1016 1
test if-10.1 {delayed substitution of then body} {
d1018 1
a1018 3
    set if if
    # this is not compiled
    $if {[incr j] == 1} "
d1021 3
a1023 11
    # this will be compiled
    proc p {} {
	set j 0
	if {[incr j]} "
	    set result $j
	"
	set result
    }
    append result [p]
} {00}
test if-10.2 {delayed substitution of elseif expression} {
d1025 1
a1025 3
    set if if
    # this is not compiled
    $if {[incr j] == 0} {
d1030 1
a1030 1
       set result 0
d1032 3
a1034 15
    # this will be compiled
    proc p {} {
	set j 0
	if {[incr j] == 0} {
	    set result badthen
	} elseif "$j == 1" {
	    set result badelseif
	} else {
	    set result 0
	}
	set result
    }
    append result [p]
} {00}
test if-10.3 {delayed substitution of elseif body} {
d1036 1
a1036 3
    set if if
    # this is not compiled
    $if {[incr j] == 0} {
d1041 3
a1043 12
    # this will be compiled
    proc p {} {
	set j 0
	if {[incr j] == 0} {
	    set result badthen
	} elseif {1} "
	    set result $j
	"
    }
    append result [p]
} {00}
test if-10.4 {delayed substitution of else body} {
d1052 1
a1052 1
test if-10.5 {substituted control words} {
d1058 1
a1058 1
test if-10.6 {double invocation of variable traces} {
d1076 1
a1076 1
} {1 {syntax error in expression "1 oops 10 + 20": extra tokens at end of expression} 0 {} {}}
d1081 13
@


1.3.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@d13 1
a13 1
# RCS: @@(#) $Id: if.test,v 1.7 2001/12/04 15:36:29 dkf Exp $
d31 1
a31 1
} {1 {syntax error in expression "1+": premature end of expression} {syntax error in expression "1+": premature end of expression
d183 1
a183 1
} {1 {syntax error in expression "1>": premature end of expression} {syntax error in expression "1>": premature end of expression
d515 1
a515 1
} {1 {syntax error in expression "1+": premature end of expression} {syntax error in expression "1+": premature end of expression
d683 1
a683 1
} {1 {syntax error in expression "1>": premature end of expression} {syntax error in expression "1>": premature end of expression
d1016 1
a1016 1
test if-10.1 {delayed substitution of then body} {
d1018 1
a1018 3
    set if if
    # this is not compiled
    $if {[incr j] == 1} "
d1021 3
a1023 11
    # this will be compiled
    proc p {} {
	set j 0
	if {[incr j]} "
	    set result $j
	"
	set result
    }
    append result [p]
} {00}
test if-10.2 {delayed substitution of elseif expression} {
d1025 1
a1025 3
    set if if
    # this is not compiled
    $if {[incr j] == 0} {
d1030 1
a1030 1
       set result 0
d1032 3
a1034 15
    # this will be compiled
    proc p {} {
	set j 0
	if {[incr j] == 0} {
	    set result badthen
	} elseif "$j == 1" {
	    set result badelseif
	} else {
	    set result 0
	}
	set result
    }
    append result [p]
} {00}
test if-10.3 {delayed substitution of elseif body} {
d1036 1
a1036 3
    set if if
    # this is not compiled
    $if {[incr j] == 0} {
d1041 3
a1043 12
    # this will be compiled
    proc p {} {
	set j 0
	if {[incr j] == 0} {
	    set result badthen
	} elseif {1} "
	    set result $j
	"
    }
    append result [p]
} {00}
test if-10.4 {delayed substitution of else body} {
d1052 1
a1052 1
test if-10.5 {substituted control words} {
d1058 1
a1058 1
test if-10.6 {double invocation of variable traces} {
d1076 1
a1076 1
} {1 {syntax error in expression "1 oops 10 + 20": extra tokens at end of expression} 0 {} {}}
d1081 13
@


1.2
log
@touched all Tcl files to ease next import.
@
text
@@


1.2.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.2.16.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d31 1
a31 1
} {1 {syntax error in expression "1+": premature end of expression} {syntax error in expression "1+": premature end of expression
d183 1
a183 1
} {1 {syntax error in expression "1>": premature end of expression} {syntax error in expression "1>": premature end of expression
d515 1
a515 1
} {1 {syntax error in expression "1+": premature end of expression} {syntax error in expression "1+": premature end of expression
d683 1
a683 1
} {1 {syntax error in expression "1>": premature end of expression} {syntax error in expression "1>": premature end of expression
d1016 1
a1016 1
test if-10.1 {delayed substitution of then body} {
d1018 1
a1018 3
    set if if
    # this is not compiled
    $if {[incr j] == 1} "
d1021 3
a1023 11
    # this will be compiled
    proc p {} {
	set j 0
	if {[incr j]} "
	    set result $j
	"
	set result
    }
    append result [p]
} {00}
test if-10.2 {delayed substitution of elseif expression} {
d1025 1
a1025 3
    set if if
    # this is not compiled
    $if {[incr j] == 0} {
d1030 1
a1030 1
       set result 0
d1032 3
a1034 15
    # this will be compiled
    proc p {} {
	set j 0
	if {[incr j] == 0} {
	    set result badthen
	} elseif "$j == 1" {
	    set result badelseif
	} else {
	    set result 0
	}
	set result
    }
    append result [p]
} {00}
test if-10.3 {delayed substitution of elseif body} {
d1036 1
a1036 3
    set if if
    # this is not compiled
    $if {[incr j] == 0} {
d1041 3
a1043 12
    # this will be compiled
    proc p {} {
	set j 0
	if {[incr j] == 0} {
	    set result badthen
	} elseif {1} "
	    set result $j
	"
    }
    append result [p]
} {00}
test if-10.4 {delayed substitution of else body} {
d1052 1
a1052 1
test if-10.5 {substituted control words} {
d1058 1
a1058 1
test if-10.6 {double invocation of variable traces} {
d1076 1
a1076 1
} {1 {syntax error in expression "1 oops 10 + 20": extra tokens at end of expression} 0 {} {}}
d1081 13
@


1.1
log
@Initial revision
@
text
@d8 1
d13 1
a13 1
# RCS: @@(#) $Id: if.test,v 1.2 1998/09/14 18:40:10 stanton Exp $
d15 4
a18 1
if {[string compare test [info procs test]] == 1} then {source defs}
d502 84
a585 2
test if-5.1 {if and computed command names} {
    set i 0
d587 62
a648 2
    $z 1 {
        set i 1
d650 444
a1093 2
    set i
} 1
@


1.1.1.1
log
@import dejagnu-1999-11-08 snapshot
@
text
@@


1.1.1.2
log
@Tcl 8.3 upgrade
@
text
@a7 1
# Copyright (c) 1998-1999 by Scriptics Corporation.
d12 1
a12 1
# RCS: @@(#) $Id: if.test,v 1.6.8.2 2000/09/15 16:56:37 spolk Exp $
d14 1
a14 4
if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import -force ::tcltest::*
}
d498 2
a499 2
catch {unset a}
test if-5.1 {if cmd with computed command names: missing if/elseif test} {
d501 4
a504 85
    list [catch {$z} msg] $msg
} {1 {wrong # args: no expression after "if" argument}}

test if-5.2 {if cmd with computed command names: error in if/elseif test} {
    set z if
    list [catch {$z {[error "error in condition"]} foo} msg] $msg
} {1 {error in condition}}
test if-5.3 {if cmd with computed command names: error in if/elseif test} {
    set z if
    list [catch {$z {1+}} msg] $msg $errorInfo
} {1 {syntax error in expression "1+"} {syntax error in expression "1+"
    while executing
"$z {1+}"}}
test if-5.4 {if cmd with computed command names: if/elseif test in braces} {
    set z if
    set a {}
    $z {1<2} {set a 1}
    set a
} {1}
test if-5.5 {if cmd with computed command names: if/elseif test not in braces} {
    set z if
    set a {}
    $z 1<2 {set a 1}
    set a
} {1}
test if-5.6 {if cmd with computed command names: multiline test expr} {
    set z if
    set a {}
    $z {($tcl_platform(platform) != "foobar1") && \
	($tcl_platform(platform) != "foobar2")} {set a 3} else {set a 4}
    set a
} 3
test if-5.7 {if cmd with computed command names: "then" after if/elseif test} {
    set z if
    set a {}
    $z 4>3 then {set a 1}
    set a
} {1}
test if-5.8 {if cmd with computed command names: keyword other than "then" after if/elseif test} {
    set z if
    set a {}
    catch {$z 1<2 therefore {set a 1}} msg 
    set msg
} {invalid command name "therefore"}
test if-5.9 {if cmd with computed command names: missing "then" body} {
    set z if
    set a {}
    catch {$z 1<2 then} msg 
    set msg
} {wrong # args: no script following "then" argument}
test if-5.10 {if cmd with computed command names: error in "then" body} {
    set z if
    set a {}
    list [catch {$z {$a!="xxx"} then {set}} msg] $msg $errorInfo
} {1 {wrong # args: should be "set varName ?newValue?"} {wrong # args: should be "set varName ?newValue?"
    while compiling
"set"
    invoked from within
"$z {$a!="xxx"} then {set}"}}
test if-5.11 {if cmd with computed command names: error in "then" body} {
    set z if
    list [catch {$z 2 then {[error "error in then clause"]}} msg] $msg
} {1 {error in then clause}}
test if-5.12 {if cmd with computed command names: "then" body in quotes} {
    set z if
    set a {}
    $z 27>17 "append a x"
    set a
} {x}
test if-5.13 {if cmd with computed command names: computed "then" body} {
    set z if
    catch {unset x1}
    catch {unset x2}
    set a {}
    set x1 {append a x1}
    set x2 {; append a x2}
    set a {}
    $z 1 $x1$x2
    set a
} {x1x2}
test if-5.14 {if cmd with computed command names: taking proper branch} {
    set z if
    set a {}
    $z 1<2 {set a 1}
    set a
a505 503
test if-5.15 {if cmd with computed command names: taking proper branch} {
    set z if
    set a {}
    $z 1>2 {set a 1}
    set a
} {}
test if-5.16 {if cmd with computed command names: test jumpFalse instruction replacement after long "then" body} {
    set z if
    catch {unset i}
    set a {}
    $z 1<2 {
	set a 1
	while {$a != "xxx"} {
	    break;
	    while {$i >= 0} {
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		set i [expr $i-1]
	    }
	}
	set a 2
	while {$a != "xxx"} {
	    break;
	    while {$i >= 0} {
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		set i [expr $i-1]
	    }
	}
	set a 3
    }
    set a
} 3
test if-5.17 {if cmd with computed command names: if/elseif test in quotes} {
    set z if
    set a {}
    list [catch {$z {"0 < 3"} {set a 1}} msg] $msg
} {1 {expected boolean value but got "0 < 3"}}


test if-6.1 {if cmd with computed command names: "elseif" after if/elseif test} {
    set z if
    set a {}
    $z 3>4 {set a 1} elseif 1 {set a 2}
    set a
} {2}
# Since "else" is optional, the "elwood" below is treated as a command.
# But then there shouldn't be any additional argument words for the "if".
test if-6.2 {if cmd with computed command names: keyword other than "elseif"} {
    set z if
    set a {}
    catch {$z 1<2 {set a 1} elwood {set a 2}} msg 
    set msg
} {wrong # args: extra words after "else" clause in "if" command}
test if-6.3 {if cmd with computed command names: missing expression after "elseif"} {
    set z if
    set a {}
    catch {$z 1<2 {set a 1} elseif} msg 
    set msg
} {wrong # args: no expression after "elseif" argument}
test if-6.4 {if cmd with computed command names: error in expression after "elseif"} {
    set z if
    set a {}
    list [catch {$z 3>4 {set a 1} elseif {1>}} msg] $msg $errorInfo
} {1 {syntax error in expression "1>"} {syntax error in expression "1>"
    while executing
"$z 3>4 {set a 1} elseif {1>}"}}
test if-6.5 {if cmd with computed command names: test jumpFalse instruction replacement after long "elseif" body} {
    set z if
    catch {unset i}
    set a {}
    $z 1>2 {
	set a 1
	while {$a != "xxx"} {
	    break;
	    while {$i >= 0} {
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		set i [expr $i-1]
	    }
	}
	set a 2
	while {$a != "xxx"} {
	    break;
	    while {$i >= 0} {
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		set i [expr $i-1]
	    }
	}
	set a 3
    } elseif 1<2 then { #; this if arm should be taken
	set a 4
	while {$a != "xxx"} {
	    break;
	    while {$i >= 0} {
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		set i [expr $i-1]
	    }
	}
	set a 5
	while {$a != "xxx"} {
	    break;
	    while {$i >= 0} {
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		set i [expr $i-1]
	    }
	}
	set a 6
    }
    set a
} 6

test if-7.1 {if cmd with computed command names: "else" clause} {
    set z if
    set a {}
    $z 3>4 {set a 1} elseif {$a == "foo"} {set a 2} else {set a 3}
    set a
} 3
# Since "else" is optional, the "elsex" below is treated as a command.
# But then there shouldn't be any additional argument words for the "if".
test if-7.2 {if cmd with computed command names: keyword other than "else"} {
    set z if
    set a {}
    catch {$z 1<2 then {set a 1} elsex {set a 2}} msg 
    set msg
} {wrong # args: extra words after "else" clause in "if" command}
test if-7.3 {if cmd with computed command names: missing body after "else"} {
    set z if
    set a {}
    catch {$z 2<1 {set a 1} else} msg 
    set msg
} {wrong # args: no script following "else" argument}
test if-7.4 {if cmd with computed command names: error compiling body after "else"} {
    set z if
    set a {}
    catch {$z 2<1 {set a 1} else {set}} msg 
    set errorInfo
} {wrong # args: should be "set varName ?newValue?"
    while compiling
"set"
    invoked from within
"$z 2<1 {set a 1} else {set}"}
test if-7.5 {if cmd with computed command names: extra arguments after "else" argument} {
    set z if
    set a {}
    catch {$z 2<1 {set a 1} else {set a 2} or something} msg 
    set msg
} {wrong # args: extra words after "else" clause in "if" command}
# The following test also checks whether contained loops and other
# commands are properly relocated because a short jump must be replaced
# by a "long distance" one.
test if-7.6 {if cmd with computed command names: test jumpFalse instruction replacement after long "else" clause} {
    set z if
    catch {unset i}
    set a {}
    $z 1>2 {
	set a 1
	while {$a != "xxx"} {
	    break;
	    while {$i >= 0} {
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		set i [expr $i-1]
	    }
	}
	set a 2
	while {$a != "xxx"} {
	    break;
	    while {$i >= 0} {
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		set i [expr $i-1]
	    }
	}
	set a 3
    } elseif 1==2 then { #; this if arm should be taken
	set a 4
	while {$a != "xxx"} {
	    break;
	    while {$i >= 0} {
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		set i [expr $i-1]
	    }
	}
	set a 5
	while {$a != "xxx"} {
	    break;
	    while {$i >= 0} {
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		set i [expr $i-1]
	    }
	}
	set a 6
    } else {
	set a 7
	while {$a != "xxx"} {
	    break;
	    while {$i >= 0} {
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		set i [expr $i-1]
	    }
	}
	set a 8
	while {$a != "xxx"} {
	    break;
	    while {$i >= 0} {
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		$z {[string compare $a "bar"] < 0} {
		    set i $i
		    set i [lindex $s $i]
		}
		set i [expr $i-1]
	    }
	}
	set a 9
    }
    set a
} 9

test if-8.1 {if cmd with computed command names: "if" command result} {
    set z if
    set a {}
    set a [$z 3<4 {set i 27}]
    set a
} 27
test if-8.2 {if cmd with computed command names: "if" command result} {
    set z if
    set a {}
    set a [$z 3>4 {set i 27}]
    set a
} {}
test if-8.3 {if cmd with computed command names: "if" command result} {
    set z if
    set a {}
    set a [$z 0 {set i 1} elseif 1 {set i 2}]
    set a
} 2
test if-8.4 {if cmd with computed command names: "if" command result} {
    set z if
    set a {}
    set a [$z 0 {set i 1} elseif 0 {set i 2} elseif 2>5 {set i 3} else {set i 4}]
    set a
} 4
test if-8.5 {if cmd with computed command names: return value} {
    set z if
    $z 0 then {set a 22; concat abc} elseif 1 {concat def} {concat ghi}
} def

test if-9.1 {if cmd with namespace qualifiers} {
    ::if {1} {set x 4}
} 4

# Test for incorrect "double evaluation semantics"

test if-10.1 {delayed substitution of then body} {knownBug} {
    set j 0
    if {[incr j] == 1} "
       set result $j
    "
    set result
} {0}
test if-10.2 {delayed substitution of elseif expression} {knownBug} {
    set j 0
    if {[incr j] == 0} {
       set result badthen
    } elseif "$j == 1" {
       set result badelseif
    } else {
       set result ok
    }
    set result
} {ok}
test if-10.3 {delayed substitution of elseif body} {knownBug} {
    set j 0
    if {[incr j] == 0} {
       set result badthen
    } elseif {1} "
       set result $j
    "
    set result
} {0}
test if-10.4 {delayed substitution of else body} {knownBug} {
    set j 0
    if {[incr j] == 0} {
       set result badthen
    } else "
       set result $j
    "
    set result
} {0}
test if-10.5 {substituted control words} {knownBug} {
    set then then; proc then {} {return badthen}
    set else else; proc else {} {return badelse}
    set elseif elseif; proc elseif {} {return badelseif}
    list [catch {if 1 $then {if 0 {} $elseif 1 {if 0 {} $else {list ok}}}} a] $a
} {0 ok}
test if-10.6 {double invocation of variable traces} {knownBug} {
    set iftracecounter 0
    proc iftraceproc {args} {
       upvar #0 iftracecounter counter
       set argc [llength $args]
       set extraargs [lrange $args 0 [expr {$argc - 4}]]
       set name [lindex $args [expr {$argc - 3}]]
       upvar 1 $name var
       if {[incr counter] % 2 == 1} {
           set var "$counter oops [concat $extraargs]"
       } else {
           set var "$counter + [concat $extraargs]"
       }
    }
    trace variable iftracevar r [list iftraceproc 10]
    list [catch {if "$iftracevar + 20" {}} a] $a \
        [catch {if "$iftracevar + 20" {}} b] $b \
        [unset iftracevar iftracecounter]
} {1 {syntax error in expression "1 oops 10 + 20"} 0 {} {}}

# cleanup
::tcltest::cleanupTests
return













@


1.1.1.3
log
@import tcl 8.4.0
@
text
@d13 1
a13 1
# RCS: @@(#) $Id: if.test,v 1.7 2001/12/04 15:36:29 dkf Exp $
d31 1
a31 1
} {1 {syntax error in expression "1+": premature end of expression} {syntax error in expression "1+": premature end of expression
d183 1
a183 1
} {1 {syntax error in expression "1>": premature end of expression} {syntax error in expression "1>": premature end of expression
d515 1
a515 1
} {1 {syntax error in expression "1+": premature end of expression} {syntax error in expression "1+": premature end of expression
d683 1
a683 1
} {1 {syntax error in expression "1>": premature end of expression} {syntax error in expression "1>": premature end of expression
d1016 1
a1016 1
test if-10.1 {delayed substitution of then body} {
d1018 1
a1018 3
    set if if
    # this is not compiled
    $if {[incr j] == 1} "
d1021 3
a1023 11
    # this will be compiled
    proc p {} {
	set j 0
	if {[incr j]} "
	    set result $j
	"
	set result
    }
    append result [p]
} {00}
test if-10.2 {delayed substitution of elseif expression} {
d1025 1
a1025 3
    set if if
    # this is not compiled
    $if {[incr j] == 0} {
d1030 1
a1030 1
       set result 0
d1032 3
a1034 15
    # this will be compiled
    proc p {} {
	set j 0
	if {[incr j] == 0} {
	    set result badthen
	} elseif "$j == 1" {
	    set result badelseif
	} else {
	    set result 0
	}
	set result
    }
    append result [p]
} {00}
test if-10.3 {delayed substitution of elseif body} {
d1036 1
a1036 3
    set if if
    # this is not compiled
    $if {[incr j] == 0} {
d1041 3
a1043 12
    # this will be compiled
    proc p {} {
	set j 0
	if {[incr j] == 0} {
	    set result badthen
	} elseif {1} "
	    set result $j
	"
    }
    append result [p]
} {00}
test if-10.4 {delayed substitution of else body} {
d1052 1
a1052 1
test if-10.5 {substituted control words} {
d1058 1
a1058 1
test if-10.6 {double invocation of variable traces} {
d1076 1
a1076 1
} {1 {syntax error in expression "1 oops 10 + 20": extra tokens at end of expression} 0 {} {}}
d1081 13
@


