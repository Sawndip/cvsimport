head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.60
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.58
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.56
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.54
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.52
	gdb_7_0-branch:1.5.0.50
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tcl8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.48
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.46
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.44
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.42
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.40
	gdb_6_5-2006-05-14-branchpoint:1.5
	readline_5_1-import-branch:1.5.0.38
	readline_5_1-import-branchpoint:1.5
	gdb_6_4-branch:1.5.0.36
	gdb_6_4-2005-11-01-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.34
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	ezannoni_pie-20040323-branch:1.5.0.32
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.30
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.28
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.26
	gdb_5_1-2001-07-29-branch:1.5.0.24
	cagney_x86i386-20030821-branch:1.5.0.22
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.20
	gdb_6_0-2003-06-23-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.18
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.16
	cagney_writestrings-20030508-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.14
	cagney_fileio-20030521-branchpoint:1.5
	carlton_dictionary-20030430-merge:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.12
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.10
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.8
	cagney_lazyid-20030317-branchpoint:1.5
	offbyone-20030313-branch:1.5.0.6
	offbyone-20030313-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.4
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.2
	interps-20030202-branchpoint:1.5
	TCL8_4_1:1.1.1.3
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.2
	TCL_8_4_1:1.1.1.3
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.4
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TCL_8_4_0:1.1.1.2
	carlton_dictionary-branch:1.2.0.16
	carlton_dictionary-20020920-branchpoint:1.2
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.14
	gdb_5_3-branch:1.2.0.12
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.10
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.8
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.6
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	cygnus_cvs_20020108_pre:1.2
	TCL_8_3:1.1.1.1
	NET:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2003.01.21.19.40.17;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.26.19.48.02;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.37.08;	author kseitz;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2001.09.09.23.56.08;	author irox;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	2001.09.09.22.40.59;	author irox;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2002.09.27.21.49.11;	author kseitz;	state Exp;
branches;
next	;

1.3.4.1
date	2003.12.14.20.28.50;	author drow;	state Exp;
branches;
next	;

1.2.16.1
date	2002.12.23.19.40.45;	author carlton;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2003.02.07.19.18.20;	author carlton;	state Exp;
branches;
next	;

1.1.1.1
date	2001.09.09.22.40.59;	author irox;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.24.19.56.41;	author kseitz;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.11.26.20.01.14;	author hunt;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tcl 8.4.1
@
text
@# This file contains a collection of tests for one or more of the Tcl
# built-in commands.  Sourcing this file into Tcl runs the tests and
# generates output for errors.  No output means no errors were found.
#
# Copyright (c) 1998-1999 by Scriptics Corporation. 
# Copyright (c) 2000 by Ajuba Solutions
# All rights reserved.
#
# RCS: @@(#) $Id: tcltest.test,v 1.35 2002/09/22 18:19:26 dgp Exp $

# Note that there are several places where the value of 
# tcltest::currentFailure is stored/reset in the -setup/-cleanup
# of a test that has a body that runs [test] that will fail.
# This is a workaround of using the same tcltest code that we are
# testing to run the test itself.  Ditto on things like [verbose].
#
# It would be better to have the -body of the tests run the tcltest
# commands in a slave interp so the [test] being tested would not
# interfere with the [test] doing the testing.  
#

if {[catch {package require tcltest 2.1}]} {
    puts stderr "Skipping tests in [info script].  tcltest 2.1 required."
    return
}

namespace eval ::tcltest::test {

namespace import ::tcltest::*

makeFile {
    package require tcltest
    namespace import ::tcltest::test
    test a-1.0 {test a} {
	list 0
    } {0}
    test b-1.0 {test b} {
	list 1
    } {0}
    test c-1.0 {test c} {knownBug} {
    } {}
    test d-1.0 {test d} {
	error "foo" foo 9
    } {}
    tcltest::cleanupTests
    exit
} test.tcl

cd [temporaryDirectory]
testConstraint exec [llength [info commands exec]]
# test -help
# Child processes because -help [exit]s.
test tcltest-1.1 {tcltest -help} {exec} {
    set result [catch {exec [interpreter] test.tcl -help} msg]
    list $result [regexp Usage $msg]
} {1 1} 
test tcltest-1.2 {tcltest -help -something} {exec} {
    set result [catch {exec [interpreter] test.tcl -help -something} msg]
    list $result [regexp Usage $msg]
} {1 1}
test tcltest-1.3 {tcltest -h} {exec} {
    set result [catch {exec [interpreter] test.tcl -h} msg]
    list $result [regexp Usage $msg]
} {1 0} 

# -verbose, implicit & explicit testing of [verbose]
proc slave {msgVar args} {
    upvar 1 $msgVar msg

    interp create [namespace current]::i
    # Fake the slave interp into dumping output to a file
    i eval {namespace eval ::tcltest {}}
    i eval "set tcltest::outputChannel \[open [makeFile {} output] w]"
    i eval "set tcltest::errorChannel \[open [makeFile {} error] w]"
    i eval [list set argv0 [lindex $args 0]]
    i eval [list set argv [lrange $args 1 end]]
    i eval [list package ifneeded tcltest [package provide tcltest] \
	    [package ifneeded tcltest [package provide tcltest]]]
    i eval {proc exit args {}}

    # Need to capture output in msg

    set code [catch {i eval {source $argv0}} foo]
if $code {
#puts "$code: $foo\n$::errorInfo"
}
    i eval {close $tcltest::outputChannel}
    interp delete [namespace current]::i
    set f [open [file join [temporaryDirectory] output]]
    set msg [read -nonewline $f]
    close $f
    set f [open [file join [temporaryDirectory] error]]
    set err [read -nonewline $f]
    close $f
    if {[string length $err]} {
	set code 1
	append msg \n$err
    }
    return $code

#    return [catch {uplevel 1 [linsert $args 0  exec [interpreter]]} msg]
}
test tcltest-2.0 {tcltest (verbose default - 'b')} {unixOrPc} {
    set result [slave msg test.tcl]
    list $result [regexp "Contents of test case" $msg] [regexp a-1.0 $msg] \
	    [regexp c-1.0 $msg] \
	    [regexp "Total.+4.+Passed.+1.+Skipped.+1.+Failed.+2" $msg]
} {0 1 0 0 1}
test tcltest-2.1 {tcltest -verbose 'b'} {unixOrPc} {
    set result [slave msg test.tcl -verbose 'b']
    list $result [regexp "Contents of test case" $msg] [regexp a-1.0 $msg] \
	    [regexp c-1.0 $msg] \
	    [regexp "Total.+4.+Passed.+1.+Skipped.+1.+Failed.+2" $msg]
} {0 1 0 0 1}
test tcltest-2.2 {tcltest -verbose 'p'} {unixOrPc} {
    set result [slave msg test.tcl -verbose 'p']
    list $result [regexp "Contents of test case" $msg] [regexp a-1.0 $msg] \
	    [regexp c-1.0 $msg] \
	    [regexp "Total.+4.+Passed.+1.+Skipped.+1.+Failed.+2" $msg]
} {0 0 1 0 1}
test tcltest-2.3 {tcltest -verbose 's'} {unixOrPc} {
    set result [slave msg test.tcl -verbose 's']
    list $result [regexp "Contents of test case" $msg] [regexp a-1.0 $msg] \
	    [regexp c-1.0 $msg] \
	    [regexp "Total.+4.+Passed.+1.+Skipped.+1.+Failed.+2" $msg]
} {0 0 0 1 1}
test tcltest-2.4 {tcltest -verbose 'ps'} {unixOrPc} {
    set result [slave msg test.tcl -verbose 'ps']
    list $result [regexp "Contents of test case" $msg] [regexp a-1.0 $msg] \
	    [regexp c-1.0 $msg] \
	    [regexp "Total.+4.+Passed.+1.+Skipped.+1.+Failed.+2" $msg]
} {0 0 1 1 1}
test tcltest-2.5 {tcltest -verbose 'psb'} {unixOrPc} {
    set result [slave msg test.tcl -verbose 'psb']
    list $result [regexp "Contents of test case" $msg] [regexp a-1.0 $msg] \
	    [regexp c-1.0 $msg] \
	    [regexp "Total.+4.+Passed.+1.+Skipped.+1.+Failed.+2" $msg]
} {0 1 1 1 1}

test tcltest-2.5a {tcltest -verbose 'pass skip body'} {unixOrPc} {
    set result [slave msg test.tcl -verbose "pass skip body"]
    list $result [regexp "Contents of test case" $msg] [regexp a-1.0 $msg] \
	    [regexp c-1.0 $msg] \
	    [regexp "Total.+4.+Passed.+1.+Skipped.+1.+Failed.+2" $msg]
} {0 1 1 1 1}

test tcltest-2.6 {tcltest -verbose 't'}  {
    -constraints {unixOrPc} 
    -body {
	set result [slave msg test.tcl -verbose 't']
	list $result $msg
    }
    -result {^0 .*a-1.0 start.*b-1.0 start}
    -match regexp
}

test tcltest-2.6a {tcltest -verbose 'start'}  {
    -constraints {unixOrPc} 
    -body {
	set result [slave msg test.tcl -verbose start]
	list $result $msg
    }
    -result {^0 .*a-1.0 start.*b-1.0 start}
    -match regexp
}

test tcltest-2.7 {tcltest::verbose}  {
    -body {
	set oldVerbosity [verbose]
	verbose bar
	set currentVerbosity [verbose]
	verbose foo
	set newVerbosity [verbose]
	verbose $oldVerbosity
	list $currentVerbosity $newVerbosity 
    }
    -result {body {}}
}

test tcltest-2.8 {tcltest -verbose 'error'} {
    -constraints {unixOrPc}
    -body {
	set result [slave msg test.tcl -verbose error]
	list $result $msg
    }
    -result {errorInfo: foo.*errorCode: 9}
    -match regexp
}
# -match, [match]
test tcltest-3.1 {tcltest -match 'a*'} {unixOrPc} {
    set result [slave msg test.tcl -match a* -verbose 'ps']
    list $result [regexp a-1.0 $msg] [regexp b-1.0 $msg] [regexp c-1.0 $msg] \
	    [regexp "Total.+4.+Passed.+1.+Skipped.+3.+Failed.+0" $msg]
} {0 1 0 0 1}
test tcltest-3.2 {tcltest -match 'b*'} {unixOrPc} {
    set result [slave msg test.tcl -match b* -verbose 'ps']
    list $result [regexp a-1.0 $msg] [regexp b-1.0 $msg] [regexp c-1.0 $msg] \
	    [regexp "Total.+4.+Passed.+0.+Skipped.+3.+Failed.+1" $msg]
} {0 0 1 0 1}
test tcltest-3.3 {tcltest -match 'c*'} {unixOrPc} {
    set result [slave msg test.tcl -match c* -verbose 'ps']
    list $result [regexp a-1.0 $msg] [regexp b-1.0 $msg] [regexp c-1.0 $msg] \
	    [regexp "Total.+4.+Passed.+0.+Skipped.+4.+Failed.+0" $msg]
} {0 0 0 1 1}
test tcltest-3.4 {tcltest -match 'a* b*'} {unixOrPc} {
    set result [slave msg test.tcl -match {a* b*} -verbose 'ps']
    list $result [regexp a-1.0 $msg] [regexp b-1.0 $msg] [regexp c-1.0 $msg] \
	    [regexp "Total.+4.+Passed.+1.+Skipped.+2.+Failed.+1" $msg]
} {0 1 1 0 1}

test tcltest-3.5 {tcltest::match}  {
    -body {
	set oldMatch [match]
	match foo
	set currentMatch [match]
	match bar
	set newMatch [match]
	match $oldMatch
	list $currentMatch $newMatch
    }
    -result {foo bar}
}
	
# -skip, [skip]
test tcltest-4.1 {tcltest -skip 'a*'} {unixOrPc} {
    set result [slave msg test.tcl -skip a* -verbose 'ps']
    list $result [regexp a-1.0 $msg] [regexp b-1.0 $msg] [regexp c-1.0 $msg] \
	    [regexp "Total.+4.+Passed.+0.+Skipped.+2.+Failed.+1" $msg]
} {0 0 1 1 1}
test tcltest-4.2 {tcltest -skip 'b*'} {unixOrPc} {
    set result [slave msg test.tcl -skip b* -verbose 'ps']
    list $result [regexp a-1.0 $msg] [regexp b-1.0 $msg] [regexp c-1.0 $msg] \
	    [regexp "Total.+4.+Passed.+1.+Skipped.+2.+Failed.+1" $msg]
} {0 1 0 1 1}
test tcltest-4.3 {tcltest -skip 'c*'} {unixOrPc} {
    set result [slave msg test.tcl -skip c* -verbose 'ps']
    list $result [regexp a-1.0 $msg] [regexp b-1.0 $msg] [regexp c-1.0 $msg] \
	    [regexp "Total.+4.+Passed.+1.+Skipped.+1.+Failed.+2" $msg]
} {0 1 1 0 1}
test tcltest-4.4 {tcltest -skip 'a* b*'} {unixOrPc} {
    set result [slave msg test.tcl -skip {a* b*} -verbose 'ps']
    list $result [regexp a-1.0 $msg] [regexp b-1.0 $msg] [regexp c-1.0 $msg] \
	    [regexp "Total.+4.+Passed.+0.+Skipped.+3.+Failed.+1" $msg]
} {0 0 0 1 1}
test tcltest-4.5 {tcltest -match 'a* b*' -skip 'b*'} {unixOrPc} {
    set result [slave msg test.tcl -match {a* b*} -skip b* -verbose 'ps']
    list $result [regexp a-1.0 $msg] [regexp b-1.0 $msg] [regexp c-1.0 $msg] \
	    [regexp "Total.+4.+Passed.+1.+Skipped.+3.+Failed.+0" $msg]
} {0 1 0 0 1}

test tcltest-4.6 {tcltest::skip} {
    -body {
	set oldSkip [skip]
	skip foo
	set currentSkip [skip]
	skip bar
	set newSkip [skip]
	skip $oldSkip
	list $currentSkip $newSkip
    }
    -result {foo bar}
}

# -constraints, -limitconstraints, [testConstraint],
# $constraintsSpecified, [limitConstraints]
test tcltest-5.1 {tcltest -constraints 'knownBug'} {unixOrPc} {
    set result [slave msg test.tcl -constraints knownBug -verbose 'ps']
    list $result [regexp a-1.0 $msg] [regexp b-1.0 $msg] [regexp c-1.0 $msg] \
	    [regexp "Total.+4.+Passed.+2.+Skipped.+0.+Failed.+2" $msg]
} {0 1 1 1 1}
test tcltest-5.2 {tcltest -constraints 'knownBug' -limitconstraints 1} {unixOrPc} {
    set result [slave msg test.tcl -constraints knownBug -verbose 'p' -limitconstraints 1]
    list $result [regexp a-1.0 $msg] [regexp b-1.0 $msg] [regexp c-1.0 $msg] \
	    [regexp "Total.+4.+Passed.+1.+Skipped.+3.+Failed.+0" $msg]
} {0 0 0 1 1}

test tcltest-5.3 {testConstraint - constraint empty (tcltest::safeFetch)}  {
    -body {
	set r1 [testConstraint tcltestFakeConstraint]
	set r2 [testConstraint tcltestFakeConstraint 4]
	set r3 [testConstraint tcltestFakeConstraint]
	list $r1 $r2 $r3
    }
    -result {0 4 4}
    -cleanup {unset ::tcltest::testConstraints(tcltestFakeConstraint)}
}

# Removed this test of internals of tcltest.  Those internals have changed.
#test tcltest-5.4 {tcltest::constraintsSpecified} {
#    -setup {
#	set constraintlist $::tcltest::constraintsSpecified
#	set ::tcltest::constraintsSpecified {}
#    }
#    -body {
#	set r1 $::tcltest::constraintsSpecified
#	testConstraint tcltestFakeConstraint1 1
#	set r2 $::tcltest::constraintsSpecified
#	testConstraint tcltestFakeConstraint2 1
#	set r3 $::tcltest::constraintsSpecified
#	list $r1 $r2 $r3
#    }
#    -result {{} tcltestFakeConstraint1 {tcltestFakeConstraint1 tcltestFakeConstraint2}}
#    -cleanup {
#	set ::tcltest::constraintsSpecified $constraintlist
#	unset ::tcltest::testConstraints(tcltestFakeConstraint1) 
#	unset ::tcltest::testConstraints(tcltestFakeConstraint2) 
#    }
#}

test tcltest-5.5 {InitConstraints: list of built-in constraints} \
	-constraints {!singleTestInterp} \
	-setup {tcltest::InitConstraints} \
	-body { lsort [array names ::tcltest::testConstraints] } \
	-result [lsort {
    95 98 asyncPipeClose eformat emptyTest exec hasIsoLocale interactive
    knownBug mac macCrash macOnly macOrPc macOrUnix macOrWin nonBlockFiles
    nonPortable notRoot nt pc pcCrash pcOnly root singleTestInterp socket
    stdio tempNotMac tempNotPc tempNotUnix tempNotWin unix unixCrash unixExecs
    unixOnly unixOrPc unixOrWin userInteraction win winCrash winOnly
}]

# Removed this broken test.  Its usage of [limitConstraints] was not
# in agreement with the documentation.  [limitConstraints] is supposed
# to take an optional boolean argument, and "knownBug" ain't no boolean!
#test tcltest-5.6 {tcltest::limitConstraints} {
#    -setup {
#        set keeplc $::tcltest::limitConstraints
#        set keepkb [testConstraint knownBug]
#    }
#    -body {
#        set r1 [limitConstraints]
#        set r2 [limitConstraints knownBug]
#        set r3 [limitConstraints]
#        list $r1 $r2 $r3
#    }
#    -cleanup {
#        limitConstraints $keeplc
#        testConstraint knownBug $keepkb
#    }
#    -result {false knownBug knownBug}
#}

# -outfile, -errfile, [outputChannel], [outputFile], [errorChannel], [errorFile]
set printerror [makeFile {
    package require tcltest
    namespace import ::tcltest::*
    puts [outputChannel] "a test"
    ::tcltest::PrintError "a really short string"
    ::tcltest::PrintError "a really really really really really really long \
	    string containing \"quotes\" and other bad bad stuff"
    ::tcltest::PrintError "a really really long string containing a \
	    \"Path/that/is/really/long/and/contains/no/spaces\""
    ::tcltest::PrintError "a really really long string containing a \
	    \"Really/Long/Path/that/contains/no/spaces/and/is/longer/than/eighty/characters/to/see/what/happens\"" 
    ::tcltest::PrintError "Problem renaming file: error renaming \"Z:/ws/tcl8.2/win32-ix86/tests/core\" to \"Z:/ws/tcl8.2/win32-ix86/tests/movecore-core\""
    exit
} printerror.tcl]

test tcltest-6.1 {tcltest -outfile, -errfile defaults} {
    -constraints unixOrPc
    -body {
	slave msg $printerror
	return $msg
    }
    -result {a test.*a really}
    -match regexp
}
test tcltest-6.2 {tcltest -outfile a.tmp} {unixOrPc unixExecs} {
    slave msg $printerror -outfile a.tmp
    set result1 [catch {exec grep "a test" a.tmp}]
    set result2 [catch {exec grep "a really" a.tmp}]
    list [regexp "a test" $msg] [regexp "a really" $msg] \
	    $result1 $result2 [file exists a.tmp] [file delete a.tmp] 
} {0 1 0 1 1 {}}
test tcltest-6.3 {tcltest -errfile a.tmp} {unixOrPc unixExecs} {
    slave msg $printerror -errfile a.tmp
    set result1 [catch {exec grep "a test" a.tmp}]
    set result2 [catch {exec grep "a really" a.tmp}]
    list [regexp "a test" $msg] [regexp "a really" $msg] \
	    $result1 $result2 [file exists a.tmp] [file delete a.tmp]
} {1 0 1 0 1 {}}
test tcltest-6.4 {tcltest -outfile a.tmp -errfile b.tmp} {unixOrPc unixExecs} {
    slave msg printerror.tcl -outfile a.tmp -errfile b.tmp
    set result1 [catch {exec grep "a test" a.tmp}]
    set result2 [catch {exec grep "a really" b.tmp}]
    list [regexp "a test" $msg] [regexp "a really" $msg] \
	    $result1 $result2 \
	    [file exists a.tmp] [file delete a.tmp] \
	    [file exists b.tmp] [file delete b.tmp]
} {0 0 0 0 1 {} 1 {}}

test tcltest-6.5 {tcltest::errorChannel - retrieval} {
    -setup {
	set of [errorChannel]
	set ::tcltest::errorChannel stderr
    }
    -body {
	errorChannel
    }
    -result {stderr}
    -cleanup {
	set ::tcltest::errorChannel $of
    }
}

test tcltest-6.6 {tcltest::errorFile (implicit errorChannel)} {
    -setup {
	set ef [makeFile {} efile]
	set of [errorFile]
	set ::tcltest::errorChannel stderr
	set ::tcltest::errorFile stderr
    }
    -body {
	set f0 [errorChannel]
	set f1 [errorFile]
	set f2 [errorFile $ef]
	set f3 [errorChannel]
	set f4 [errorFile]
	subst {$f0;$f1;$f2;$f3;$f4} 
    }
    -result {stderr;stderr;.*efile;file[0-9a-f]+;.*efile}
    -match regexp
    -cleanup {
	errorFile $of
    }
}
test tcltest-6.7 {tcltest::outputChannel - retrieval} {
    -setup {
	set of [outputChannel]
	set ::tcltest::outputChannel stdout
    }
    -body {
	outputChannel
    }
    -result {stdout}
    -cleanup {
	set tcltest::outputChannel $of
    }
}

test tcltest-6.8 {tcltest::outputFile (implicit outputFile)} {
    -setup {
	set ef [makeFile {} efile]
	set of [outputFile]
	set ::tcltest::outputChannel stdout
	set ::tcltest::outputFile stdout
    }
    -body {
	set f0 [outputChannel]
	set f1 [outputFile]
	set f2 [outputFile $ef]
	set f3 [outputChannel]
	set f4 [outputFile]
	subst {$f0;$f1;$f2;$f3;$f4} 
    }
    -result {stdout;stdout;.*efile;file[0-9a-f]+;.*efile}
    -match regexp
    -cleanup {
	outputFile $of
    }
}

# -debug, [debug]
# Must use child processes to test -debug because it always writes
# messages to stdout, and we have no way to capture stdout of a
# slave interp
test tcltest-7.1 {tcltest test.tcl -debug 0} {unixOrPc} {
    catch {exec [interpreter] test.tcl -debug 0} msg
    regexp "Flags passed into tcltest" $msg
} {0}
test tcltest-7.2 {tcltest test.tcl -debug 1} {unixOrPc} {
    catch {exec [interpreter] test.tcl -debug 1 -skip b*} msg
    list [regexp userSpecifiedSkip $msg] \
	    [regexp "Flags passed into tcltest" $msg]
} {1 0}
test tcltest-7.3 {tcltest test.tcl -debug 1} {unixOrPc} {
    catch {exec [interpreter] test.tcl -debug 1 -match b*} msg
    list [regexp userSpecifiedNonMatch $msg] \
	    [regexp "Flags passed into tcltest" $msg]
} {1 0}
test tcltest-7.4 {tcltest test.tcl -debug 2} {unixOrPc} {
    catch {exec [interpreter] test.tcl -debug 2} msg
    list [regexp "Flags passed into tcltest" $msg] [regexp "Running" $msg]
} {1 0}
test tcltest-7.5 {tcltest test.tcl -debug 3} {unixOrPc} {
    catch {exec [interpreter] test.tcl -debug 3} msg
    list [regexp "Flags passed into tcltest" $msg] [regexp "Running" $msg]
} {1 1}

test tcltest-7.6 {tcltest::debug} {
    -setup {
	set old $::tcltest::debug
	set ::tcltest::debug 0
    }
    -body {
	set f1 [debug]
	set f2 [debug 1]
	set f3 [debug]
	set f4 [debug 2]
	set f5 [debug]
	list $f1 $f2 $f3 $f4 $f5
    }
    -result {0 1 1 2 2}
    -cleanup {
	set ::tcltest::debug $old
    }
}

# directory tests

makeFile {
    package require tcltest
    tcltest::makeFile {} a.tmp
    puts [tcltest::outputChannel] "testdir: [tcltest::testsDirectory]"
    exit
} a.tcl

makeFile {} thisdirectoryisafile  

set normaldirectory [makeDirectory normaldirectory]
if {$::tcl_platform(platform) == "macintosh"} {
set normaldirectory [file normalize $normaldirectory]
}

# -tmpdir, [temporaryDirectory]
test tcltest-8.1 {tcltest a.tcl -tmpdir a} {unixOrPc} {
    file delete -force thisdirectorydoesnotexist
    slave msg a.tcl -tmpdir thisdirectorydoesnotexist
    list [file exists [file join thisdirectorydoesnotexist a.tmp]] \
	    [file delete -force thisdirectorydoesnotexist] 
} {1 {}}
test tcltest-8.2 {tcltest a.tcl -tmpdir thisdirectoryisafile} {
    -constraints unixOrPc
    -body {
	slave msg a.tcl -tmpdir thisdirectoryisafile
	set msg
    }
    -result {*not a directory*}
    -match glob
}

# Test non-writeable directories, non-readable directories with directory flags
set notReadableDir [file join [temporaryDirectory] notreadable]
set notWriteableDir [file join [temporaryDirectory] notwriteable]

makeDirectory notreadable
makeDirectory notwriteable

switch $tcl_platform(platform) {
    "unix" {
	file attributes $notReadableDir -permissions 00333
	file attributes $notWriteableDir -permissions 00555
    }
    default {
	catch {file attributes $notWriteableDir -readonly 1}
    }
}

test tcltest-8.3 {tcltest a.tcl -tmpdir notReadableDir} {unixOnly nonRoot} {
    slave msg a.tcl -tmpdir $notReadableDir 
    string match {*not readable*} $msg
} {1}

test tcltest-8.4 {tcltest a.tcl -tmpdir notWriteableDir} {unixOrPc nonRoot} {
    slave msg a.tcl -tmpdir $notWriteableDir
    string match {*not writeable*} $msg
} {1}

test tcltest-8.5 {tcltest a.tcl -tmpdir normaldirectory} {unixOrPc} {
    slave msg a.tcl -tmpdir $normaldirectory
    # The join is necessary because the message can be split on multiple lines
    list [file exists [file join $normaldirectory a.tmp]] \
	    [file delete [file join $normaldirectory a.tmp]] 
} {1 {}}   
cd [workingDirectory]

test tcltest-8.6 {temporaryDirectory}  {
    -setup {
	set old $::tcltest::temporaryDirectory
	set ::tcltest::temporaryDirectory $normaldirectory
    }
    -body {
	set f1 [temporaryDirectory]
	set f2 [temporaryDirectory [workingDirectory]]
	set f3 [temporaryDirectory]
	list $f1 $f2 $f3
    }
    -result "[list $normaldirectory [workingDirectory] [workingDirectory]]"
    -cleanup {
	set ::tcltest::temporaryDirectory $old
    }
}

test tcltest-8.6a {temporaryDirectory - test format 2} -setup {
    set old $::tcltest::temporaryDirectory
    set ::tcltest::temporaryDirectory $normaldirectory
} -body {
    set f1 [temporaryDirectory]
    set f2 [temporaryDirectory [workingDirectory]]
    set f3 [temporaryDirectory]
    list $f1 $f2 $f3
} -cleanup {
    set ::tcltest::temporaryDirectory $old
} -result [list $normaldirectory [workingDirectory] [workingDirectory]]

cd [temporaryDirectory]
# -testdir, [testsDirectory]
test tcltest-8.10 {tcltest a.tcl -testdir thisdirectorydoesnotexist} {unixOrPc} {
    file delete -force thisdirectorydoesnotexist
    slave msg a.tcl -testdir thisdirectorydoesnotexist
    string match "*does not exist*" $msg
} {1}

test tcltest-8.11 {tcltest a.tcl -testdir thisdirectoryisafile} {unixOrPc} {
    slave msg a.tcl -testdir thisdirectoryisafile
    string match "*not a directory*" $msg 
} {1}

test tcltest-8.12 {tcltest a.tcl -testdir notReadableDir} {unixOnly nonRoot} {
    slave msg a.tcl -testdir $notReadableDir 
    string match {*not readable*} $msg
} {1}


test tcltest-8.13 {tcltest a.tcl -testdir normaldirectory} {unixOrPc} {
    slave msg a.tcl -testdir $normaldirectory
    # The join is necessary because the message can be split on multiple lines
    list [string first "testdir: $normaldirectory" [join $msg]] \
	    [file exists [file join [temporaryDirectory] a.tmp]] \
	    [file delete [file join [temporaryDirectory] a.tmp]] 
} {0 1 {}} 
cd [workingDirectory]

set current [pwd]
test tcltest-8.14 {testsDirectory} {
    -setup {
	set old $::tcltest::testsDirectory
	set ::tcltest::testsDirectory $normaldirectory
    }
    -body {
	set f1 [testsDirectory]
	set f2 [testsDirectory $current]
	set f3 [testsDirectory]
	list $f1 $f2 $f3
    }
    -result "[list $normaldirectory $current $current]"
    -cleanup {
	set ::tcltest::testsDirectory $old
    }
}

# [workingDirectory]
test tcltest-8.60 {::workingDirectory}  {
    -setup {
	set old $::tcltest::workingDirectory
	set current [pwd]
	set ::tcltest::workingDirectory $normaldirectory
	cd $normaldirectory
    }
    -body {
	set f1 [workingDirectory]
	set f2 [pwd]
	set f3 [workingDirectory $current]
	set f4 [pwd] 
	set f5 [workingDirectory]
	list $f1 $f2 $f3 $f4 $f5
    }
    -result "[list $normaldirectory \
                   $normaldirectory \
                   $current \
                   $current \
                   $current]"
    -cleanup {
	set ::tcltest::workingDirectory $old
	cd $current
    }
}

# clean up from directory testing

switch $tcl_platform(platform) {
    "unix" {
	file attributes $notReadableDir -permissions 777
	file attributes $notWriteableDir -permissions 777
    }
    default {
	catch {file attributes $notWriteableDir -readonly 0}
    }
}

file delete -force $notReadableDir $notWriteableDir

# -file, -notfile, [matchFiles], [skipFiles]
test tcltest-9.1 {-file a*.tcl} {unixOrPc} {
    slave msg [file join [testsDirectory] all.tcl] -file a*.test
    list [regexp assocd\.test $msg]
} {1}
test tcltest-9.2 {-file a*.tcl} {unixOrPc} {
    slave msg [file join [testsDirectory] all.tcl] \
	    -file a*.test -notfile assocd*
    list [regexp assocd\.test $msg]
} {0}

test tcltest-9.3 {matchFiles}  {
    -body {
	set old [matchFiles]
	matchFiles foo
	set current [matchFiles]
	matchFiles bar
	set new [matchFiles]
	matchFiles $old
	list $current $new
    } 
    -result {foo bar}
}

test tcltest-9.4 {skipFiles} {
    -body {
	set old [skipFiles]
	skipFiles foo
	set current [skipFiles]
	skipFiles bar
	set new [skipFiles]
	skipFiles $old
	list $current $new
    } 
    -result {foo bar}
}

# -preservecore, [preserveCore]
makeFile {
    package require tcltest
    namespace import ::tcltest::test
    test makecore {make a core file} {
	set f [open core w]
	close $f
    } {}
    ::tcltest::cleanupTests
    return
} makecore.tcl

cd [temporaryDirectory]
test tcltest-10.1 {-preservecore 0} {unixOrPc} {
    slave msg makecore.tcl -preservecore 0
    file delete core
    regexp "Core file produced" $msg
} {0}
test tcltest-10.2 {-preservecore 1} {unixOrPc} {
    slave msg makecore.tcl -preservecore 1
    file delete core
    regexp "Core file produced" $msg
} {1}
test tcltest-10.3 {-preservecore 2} {unixOrPc} {
    slave msg makecore.tcl -preservecore 2
    file delete core
    list [regexp "Core file produced" $msg] [regexp "Moving file to" $msg] \
	    [regexp "core-" $msg] [file delete core-makecore]
} {1 1 1 {}}
test tcltest-10.4 {-preservecore 3} {unixOrPc} {
    slave msg makecore.tcl -preservecore 3
    file delete core
    list [regexp "Core file produced" $msg] [regexp "Moving file to" $msg] \
	    [regexp "core-" $msg] [file delete core-makecore]
} {1 1 1 {}}

# Removing this test.  It makes no sense to test the ability of
# [preserveCore] to accept an invalid value that will cause errors
# in other parts of tcltest's operation.
#test tcltest-10.5 {preserveCore} {
#    -body {
#	set old [preserveCore]
#	set result [preserveCore foo]
#	set result2 [preserveCore]
#	preserveCore $old
#	list $result $result2
#    }
#    -result {foo foo}
#}

# -load, -loadfile, [loadScript], [loadFile]
set contents { 
    package require tcltest
    namespace import tcltest::*
    puts [outputChannel] $::tcltest::loadScript
    exit
} 
set loadfile [makeFile $contents load.tcl]

test tcltest-12.1 {-load xxx} {unixOrPc} {
    slave msg load.tcl -load xxx
    set msg
} {xxx}

# Using child process because of -debug usage.
test tcltest-12.2 {-loadfile load.tcl} {unixOrPc} {
    catch {exec [interpreter] load.tcl -debug 2 -loadfile load.tcl} msg
    list \
	    [regexp {tcltest} [join [list $msg] [split $msg \n]]] \
	    [regexp {loadScript} [join [list $msg] [split $msg \n]]]
} {1 1}

test tcltest-12.3 {loadScript} {
    -setup {
	set old $::tcltest::loadScript
    }
    -body {
	set f1 [loadScript]
	set f2 [loadScript xxx]
	set f3 [loadScript]
	list $f1 $f2 $f3
    }
    -result {{} xxx xxx}
    -cleanup {
	set ::tcltest::loadScript $old
    }
}

test tcltest-12.4 {loadFile} {
    -setup {
	set olds $::tcltest::loadScript
	set oldf $::tcltest::loadFile
	set ::tcltest::loadFile {}
    }
    -body {
	set f1 [loadScript]
	set f2 [loadFile]
	set f3 [loadFile load.tcl]
	set f4 [loadScript]
	set f5 [loadFile]
	list $f1 $f2 $f3 $f4 $f5
    }
    -result "[list {} {} $loadfile $contents $loadfile]\n"
    -cleanup {
	set ::tcltest::loadScript $olds
	set ::tcltest::loadFile $oldf
    }
}

# [interpreter]
test tcltest-13.1 {interpreter} {
    -setup {
	set old $::tcltest::tcltest
	set ::tcltest::tcltest tcltest
    }
    -body {
	set f1 [interpreter]
	set f2 [interpreter tclsh]
	set f3 [interpreter]
	list $f1 $f2 $f3
    }
    -result {tcltest tclsh tclsh}
    -cleanup {
	set ::tcltest::tcltest $old
    }
}

# -singleproc, [singleProcess]
makeDirectory singleprocdir
makeFile {
    set foo 1
} [file join singleprocdir single1.test]

makeFile {
    unset foo
} [file join singleprocdir single2.test]

set allfile [makeFile {
    package require tcltest
    namespace import tcltest::*
    testsDirectory [file join [temporaryDirectory] singleprocdir]
    runAllTests
} [file join singleprocdir all-single.tcl]]
cd [workingDirectory]

test tcltest-14.1 {-singleproc - single process} {
    -constraints {unixOrPc}
    -body {
	slave msg $allfile -singleproc 0 -tmpdir [temporaryDirectory]
	set msg
    }
    -result {Test file error: can't unset .foo.: no such variable}
    -match regexp
}

test tcltest-14.2 {-singleproc - multiple process} {
    -constraints {unixOrPc}
    -body {
	slave msg $allfile -singleproc 1 -tmpdir [temporaryDirectory]
	set msg
    }
    -result {single1.test.*single2.test.*all\-single.tcl:.*Total.*0.*Passed.*0.*Skipped.*0.*Failed.*0}
    -match regexp
}

test tcltest-14.3 {singleProcess} {
    -setup {
	set old $::tcltest::singleProcess
	set ::tcltest::singleProcess 0
    }
    -body {
	set f1 [singleProcess]
	set f2 [singleProcess 1]
	set f3 [singleProcess]
	list $f1 $f2 $f3
    }
    -result {0 1 1}
    -cleanup {
	set ::tcltest::singleProcess $old
    }
}

# -asidefromdir, -relateddir, [matchDirectories], [skipDirectories]

# Before running these tests, need to set up test subdirectories with their own
# all.tcl files.

makeDirectory dirtestdir
makeDirectory [file join dirtestdir dirtestdir2.1]
makeDirectory [file join dirtestdir dirtestdir2.2]
makeDirectory [file join dirtestdir dirtestdir2.3]
makeFile {
    package require tcltest
    namespace import -force tcltest::*
    testsDirectory [file join [temporaryDirectory] dirtestdir]
    runAllTests
} [file join dirtestdir all.tcl]
makeFile {
    package require tcltest
    namespace import -force tcltest::*
    testsDirectory [file join [temporaryDirectory] dirtestdir dirtestdir2.1]
    runAllTests
} [file join dirtestdir dirtestdir2.1 all.tcl]
makeFile {
    package require tcltest
    namespace import -force tcltest::*
    testsDirectory [file join [temporaryDirectory]  dirtestdir dirtestdir2.2]
    runAllTests
} [file join dirtestdir dirtestdir2.2 all.tcl]
makeFile {
    package require tcltest
    namespace import -force tcltest::*
    testsDirectory [file join [temporaryDirectory] dirtestdir dirtestdir2.3]
    runAllTests
} [file join dirtestdir dirtestdir2.3 all.tcl]

test tcltest-15.1 {basic directory walking} {
    -constraints {unixOrPc}
    -body {
	if {[slave msg \
		[file join [temporaryDirectory] dirtestdir all.tcl] \
		-tmpdir [temporaryDirectory]] == 1} {
	    error $msg
	}
    }
    -match regexp
    -returnCodes 1
    -result {Tests located in:.*dirtestdir.*Tests located in:.*dirtestdir2.1.*Tests located in:.*dirtestdir2.2.*Tests located in:.*dirtestdir2.3}
}

test tcltest-15.2 {-asidefromdir} {
    -constraints {unixOrPc}
    -body {
	if {[slave msg \
		[file join [temporaryDirectory] dirtestdir all.tcl] \
		-asidefromdir dirtestdir2.3 \
		-tmpdir [temporaryDirectory]] == 1} {
	    error $msg
	}
    }
    -match regexp
    -returnCodes 1
    -result {Tests located in:.*dirtestdir.*Tests located in:.*dirtestdir2.1.*Tests located in:.*dirtestdir2.2.*dirtestdir2.2 test ended at .*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Error:  No test files remain after applying your match and skip patterns!
Error:  No test files remain after applying your match and skip patterns!
Error:  No test files remain after applying your match and skip patterns!$}
}

test tcltest-15.3 {-relateddir, non-existent dir} {
    -constraints {unixOrPc}
    -body {
	if {[slave msg \
		[file join [temporaryDirectory] dirtestdir all.tcl] \
		-relateddir [file join [temporaryDirectory] dirtestdir0] \
		-tmpdir [temporaryDirectory]] == 1} {
	    error $msg
	}
    }
    -returnCodes 1
    -match regexp
    -result {[^~]|dirtestdir[^2]}
}

test tcltest-15.4 {-relateddir, subdir} {
    -constraints {unixOrPc}
    -body {
	if {[slave msg \
		[file join [temporaryDirectory] dirtestdir all.tcl] \
		-relateddir dirtestdir2.1 -tmpdir [temporaryDirectory]] == 1} {
	    error $msg
	}
    }
    -returnCodes 1
    -match regexp
    -result {Tests located in:.*dirtestdir2.[^23]}
}
test tcltest-15.5 {-relateddir, -asidefromdir} {
    -constraints {unixOrPc}
    -body {
	if {[slave msg \
		[file join [temporaryDirectory] dirtestdir all.tcl] \
		-relateddir "dirtestdir2.1 dirtestdir2.2" \
		-asidefromdir dirtestdir2.2 \
		-tmpdir [temporaryDirectory]] == 1} {
	    error $msg
	}
    }
    -match regexp
    -returnCodes 1
    -result {Tests located in:.*dirtestdir2.[^23]}
}

test tcltest-15.6 {matchDirectories} {
    -setup {
	set old [matchDirectories]
	set ::tcltest::matchDirectories {}
    }
    -body {
	set r1 [matchDirectories]
	set r2 [matchDirectories foo]
	set r3 [matchDirectories]
	list $r1 $r2 $r3
    }
    -cleanup {
	set ::tcltest::matchDirectories $old
    }
    -result {{} foo foo}
}

test tcltest-15.7 {skipDirectories} {
    -setup {
	set old [skipDirectories]
	set ::tcltest::skipDirectories {}
    }
    -body {
	set r1 [skipDirectories]
	set r2 [skipDirectories foo]
	set r3 [skipDirectories]
	list $r1 $r2 $r3
    }
    -cleanup {
	set ::tcltest::skipDirectories $old
    }
    -result {{} foo foo}
}

# TCLTEST_OPTIONS
test tcltest-19.1 {TCLTEST_OPTIONS default} {
    -constraints {unixOrPc singleTestInterp}
    -setup {
	if {[info exists ::env(TCLTEST_OPTIONS)]} {
	    set oldoptions $::env(TCLTEST_OPTIONS)
	    unset ::env(TCLTEST_OPTIONS)
	} else {
	    set oldoptions none
	}
	# set this to { } instead of just {} to get around quirk in
	# Windows env handling that removes empty elements from env array.
	set ::env(TCLTEST_OPTIONS) { }
	set olddebug [debug]
	debug 2
    }
    -cleanup {
	if {$oldoptions == "none"} {
	    unset ::env(TCLTEST_OPTIONS) 
	} else {
	    set ::env(TCLTEST_OPTIONS) $oldoptions
	}
	debug $olddebug
    }
    -body {
	::tcltest::ProcessCmdLineArgs
	set ::env(TCLTEST_OPTIONS) "-debug 3"
	::tcltest::ProcessCmdLineArgs
    }
    -result {^$}
    -match regexp
    -output {tcltest::debug\s+= 2.*tcltest::debug\s+= 3}
}

# Begin testing of tcltest procs ...

cd [temporaryDirectory]
# PrintError
test tcltest-20.1 {PrintError} {unixOrPc} {
    set result [slave msg printerror.tcl]
    list $result [regexp "Error:  a really short string" $msg] \
	    [regexp "     \"quotes\"" $msg] [regexp "    \"Path" $msg] \
	    [regexp "    \"Really" $msg] [regexp Problem $msg]
} {1 1 1 1 1 1}
cd [workingDirectory]

# test::test
test tcltest-21.0 {name and desc but no args specified} -setup {
    set v [verbose]
} -cleanup {
    verbose $v
} -body {
   verbose {}
   test tcltest-21.0.0 bar
} -result {}

test tcltest-21.1 {expect with glob} {
    -body {
	list a b c d e
    }
    -match glob
    -result {[ab] b c d e}
}

test tcltest-21.2 {force a test command failure} {
    -body {
	test tcltest-21.2.0 {
	    return 2
	} {1}
    }
    -returnCodes 1
    -result {bad option "1": must be -body, -cleanup, -constraints, -errorOutput, -match, -output, -result, -returnCodes, or -setup}
}

test tcltest-21.3 {test command with setup} {
    -setup {
	set foo 1
    }
    -body {
	set foo
    }
    -cleanup {unset foo}
    -result {1}
}

test tcltest-21.4 {test command with cleanup failure} {
    -setup {
	if {[info exists foo]} {
	    unset foo
	}
	set fail $::tcltest::currentFailure
	set v [verbose]
    }
    -body {
	verbose {}
	test tcltest-21.4.0 {foo-1} {
	    -cleanup {unset foo}
	}
    }
    -result {^$}
    -match regexp
    -cleanup {verbose $v; set ::tcltest::currentFailure $fail}
    -output "Test cleanup failed:.*can't unset \"foo\": no such variable"
}

test tcltest-21.5 {test command with setup failure} {
    -setup {
	if {[info exists foo]} {
	    unset foo
	}
	set fail $::tcltest::currentFailure
    }
    -body {
	test tcltest-21.5.0 {foo-2} {
	    -setup {unset foo}
	}
    }
    -result {^$}
    -match regexp
    -cleanup {set ::tcltest::currentFailure $fail}
    -output "Test setup failed:.*can't unset \"foo\": no such variable"
}

test tcltest-21.6 {test command - setup occurs before cleanup & before script} {
    -setup {set v [verbose]; set fail $::tcltest::currentFailure}
    -body {
	verbose {}
	test tcltest-21.6.0 {foo-3} {
	    -setup {
		if {[info exists foo]} {
		    unset foo
		}
		set foo 1
		set expected 2
	    } 
	    -body {
		incr foo
		set foo
	    }
	    -cleanup {
		if {$foo != 2} {
		    puts [outputChannel] "foo is wrong"
		} else {
		    puts [outputChannel] "foo is 2"
		}
	    }
	    -result {$expected}
	}
    }
    -cleanup {verbose $v; set ::tcltest::currentFailure $fail}
    -result {^$}
    -match regexp
    -output "foo is 2"
}

test tcltest-21.7 {test command - bad flag} {
    -setup {set fail $::tcltest::currentFailure}
    -cleanup {set ::tcltest::currentFailure $fail}
    -body {
	test tcltest-21.7.0 {foo-4} {
	    -foobar {}
	}
    }
    -returnCodes 1
    -result {bad option "-foobar": must be -body, -cleanup, -constraints, -errorOutput, -match, -output, -result, -returnCodes, or -setup}
}

# alternate test command format (these are the same as 21.1-21.6, with the
# exception of being in the all-inline format)

test tcltest-21.7a {expect with glob} \
	-body {list a b c d e} \
	-result {[ab] b c d e} \
	-match glob

test tcltest-21.8 {force a test command failure} \
    -setup {set fail $::tcltest::currentFailure} \
    -body {
        test tcltest-21.8.0 {
            return 2
        } {1}
    } \
    -returnCodes 1 \
    -cleanup {set ::tcltest::currentFailure $fail} \
    -result {bad option "1": must be -body, -cleanup, -constraints, -errorOutput, -match, -output, -result, -returnCodes, or -setup}

test tcltest-21.9 {test command with setup} \
	-setup {set foo 1} \
	-body {set foo} \
	-cleanup {unset foo} \
	-result {1}

test tcltest-21.10 {test command with cleanup failure} -setup {
    if {[info exists foo]} {
	unset foo
    }
    set fail $::tcltest::currentFailure
    set v [verbose]
} -cleanup {
    verbose $v
    set ::tcltest::currentFailure $fail
} -body {
    verbose {}
    test tcltest-21.10.0 {foo-1} -cleanup {unset foo}
} -result {^$} -match regexp \
	-output {Test cleanup failed:.*can't unset \"foo\": no such variable}

test tcltest-21.11 {test command with setup failure} -setup {
    if {[info exists foo]} {
	unset foo
    }
    set fail $::tcltest::currentFailure
} -cleanup {set ::tcltest::currentFailure $fail} -body {
    test tcltest-21.11.0 {foo-2} -setup {unset foo}
} -result {^$} -output {Test setup failed:.*can't unset \"foo\": no such variable} -match regexp

test tcltest-21.12 {
	test command - setup occurs before cleanup & before script
} -setup {
	set fail $::tcltest::currentFailure
	set v [verbose]
} -cleanup {
	verbose $v
	set ::tcltest::currentFailure $fail
} -body {
    verbose {}
    test tcltest-21.12.0 {foo-3} -setup {
	if {[info exists foo]} {
	    unset foo
	}
	set foo 1
	set expected 2
    }  -body {
	incr foo
	set foo
    }  -cleanup {
	if {$foo != 2} {
	    puts [outputChannel] "foo is wrong"
	} else {
	    puts [outputChannel] "foo is 2"
	}
    }  -result {$expected}
} -result {^$} -output {foo is 2} -match regexp

# test all.tcl usage (runAllTests); simulate .test file failure, as well as
# crashes to determine whether or not these errors are logged.

makeDirectory alltestdir
makeFile {
    package require tcltest
    namespace import -force tcltest::*
    testsDirectory [file join [temporaryDirectory] alltestdir]
    runAllTests
} [file join alltestdir all.tcl]
makeFile {
    exit 1
} [file join alltestdir exit.test]
makeFile {
    error "throw an error"
} [file join alltestdir error.test]
makeFile {
    package require tcltest
    namespace import -force tcltest::*
    test foo-1.1 {foo} {
	-body { return 1 }
	-result {1}
    }
    cleanupTests
} [file join alltestdir test.test]

# Must use a child process because stdout/stderr parsing can't be
# duplicated in slave interp.
test tcltest-22.1 {runAllTests} {
    -constraints {unixOrPc}
    -body {
	exec [interpreter] \
		[file join [temporaryDirectory] alltestdir all.tcl] \
		-verbose t -tmpdir [temporaryDirectory]
    }
    -match regexp
    -result "Test files exiting with errors:.*error.test.*exit.test"
}

# makeFile, removeFile, makeDirectory, removeDirectory, viewFile
test tcltest-23.1 {makeFile} {
    -setup {
	set mfdir [file join [temporaryDirectory] mfdir]
	file mkdir $mfdir
    }
    -body {
	makeFile {} t1.tmp
	makeFile {} et1.tmp $mfdir
	list [file exists [file join [temporaryDirectory] t1.tmp]] \
		[file exists [file join $mfdir et1.tmp]]
    }
    -cleanup {
	file delete -force $mfdir \
		[file join [temporaryDirectory] t1.tmp] 
    }
    -result {1 1}
}
test tcltest-23.2 {removeFile} {
    -setup {
	set mfdir [file join [temporaryDirectory] mfdir]
	file mkdir $mfdir
	makeFile {} t1.tmp
	makeFile {} et1.tmp $mfdir
	if  {![file exists [file join [temporaryDirectory] t1.tmp]] || \
		![file exists [file join $mfdir et1.tmp]]} {
	    error "file creation didn't work"
	}
    }
    -body {
	removeFile t1.tmp
	removeFile et1.tmp $mfdir
	list [file exists [file join [temporaryDirectory] t1.tmp]] \
		[file exists [file join $mfdir et1.tmp]]
    }
    -cleanup {
	file delete -force $mfdir \
		[file join [temporaryDirectory] t1.tmp] 
    }
    -result {0 0}
}
test tcltest-23.3 {makeDirectory} {
    -body {
	set mfdir [file join [temporaryDirectory] mfdir]
	file mkdir $mfdir
	makeDirectory d1
	makeDirectory d2 $mfdir
	list [file exists [file join [temporaryDirectory] d1]] \
		[file exists [file join $mfdir d2]]
    }
    -cleanup {
	file delete -force [file join [temporaryDirectory] d1] $mfdir
    }
    -result {1 1}
}
test tcltest-23.4 {removeDirectory} {
    -body {
	set mfdir [file join [temporaryDirectory] mfdir]
	file mkdir $mfdir
	file mkdir [file join [temporaryDirectory] t1]
	file mkdir [file join [temporaryDirectory] $mfdir t2]
	if {![file exists $mfdir] || \
		![file exists [file join [temporaryDirectory] $mfdir t2]]} {
	    return "setup failed - directory not created"
	}
	removeDirectory t1
	removeDirectory t2 $mfdir
	list [file exists [file join [temporaryDirectory] t1]] \
		[file exists [file join $mfdir t2]]
    }
    -result {0 0}
}
test tcltest-23.5 {viewFile} {
    -body {
	set mfdir [file join [temporaryDirectory] mfdir]
	file mkdir $mfdir
	makeFile {foobar} t1.tmp
	makeFile {foobarbaz} t2.tmp $mfdir
	list [viewFile t1.tmp] [viewFile t2.tmp $mfdir]
    }
    -result {foobar foobarbaz}
    -cleanup {
	file delete -force $mfdir
    }
}

# customMatch
proc matchNegative { expected actual } {
   set match 0
   foreach a $actual e $expected {
      if { $a != $e } {
         set match 1
        break
      }
   }
   return $match
}

test tcltest-24.0 {
	customMatch: syntax
} -body {
	list [catch {customMatch} result] $result
} -result [list 1 "wrong # args: should be \"customMatch mode script\""]

test tcltest-24.1 {
	customMatch: syntax
} -body {
	list [catch {customMatch foo} result] $result
} -result [list 1 "wrong # args: should be \"customMatch mode script\""]

test tcltest-24.2 {
	customMatch: syntax
} -body {
	list [catch {customMatch foo bar baz} result] $result
} -result [list 1 "wrong # args: should be \"customMatch mode script\""]

test tcltest-24.3 {
	customMatch: argument checking
} -body {
	list [catch {customMatch bad "a \{ b"} result] $result
} -result [list 1 "invalid customMatch script; can't evaluate after completion"]

test tcltest-24.4 {
	test: valid -match values
} -body {
	list [catch {
		test tcltest-24.4.0 {} \
			-match [namespace current]::noSuchMode
	} result] $result
} -match glob -result {1 *bad -match value*}

test tcltest-24.5 {
	test: valid -match values
} -setup {
	customMatch [namespace current]::alwaysMatch "format 1 ;#"
} -body {
	list [catch {
		test tcltest-24.5.0 {} \
			-match [namespace current]::noSuchMode
	} result] $result
} -match glob -result {1 *bad -match value*: must be *alwaysMatch,*}

test tcltest-24.6 {
	customMatch: -match script that always matches
} -setup {
	customMatch [namespace current]::alwaysMatch "format 1 ;#"
	set v [verbose]
} -body {
	verbose {}
	test tcltest-24.6.0 {} -match [namespace current]::alwaysMatch \
		-body {format 1} -result 0
} -cleanup {
	verbose $v
} -result {} -output {} -errorOutput {}

test tcltest-24.7 {
	customMatch: replace default -exact matching
} -setup {
	set saveExactMatchScript $::tcltest::CustomMatch(exact)
	customMatch exact "format 1 ;#"
	set v [verbose]
} -body {
	verbose {}
	test tcltest-24.7.0 {} -body {format 1} -result 0
} -cleanup {
	verbose $v
	customMatch exact $saveExactMatchScript
	unset saveExactMatchScript
} -result {} -output {}

test tcltest-24.9 {
	customMatch: error during match
} -setup {
	proc errorDuringMatch args {return -code error "match returned error"}
	customMatch [namespace current]::errorDuringMatch \
		[namespace code errorDuringMatch]
	set v [verbose]
	set fail $::tcltest::currentFailure
} -body {
	verbose {}
	test tcltest-24.9.0 {} -match [namespace current]::errorDuringMatch
} -cleanup {
	verbose $v
	set ::tcltest::currentFailure $fail
} -match glob -result {} -output {*FAILED*match returned error*}

test tcltest-24.10 {
	customMatch: bad return from match command
} -setup {
	proc nonBooleanReturn args {return foo}
	customMatch nonBooleanReturn [namespace code nonBooleanReturn]
	set v [verbose]
	set fail $::tcltest::currentFailure
} -body {
	verbose {}
	test tcltest-24.10.0 {} -match nonBooleanReturn
} -cleanup {
	verbose $v
	set ::tcltest::currentFailure $fail
} -match glob -result {} -output {*FAILED*expected boolean value*}

test tcltest-24.11 {
	test: -match exact
} -body {
	set result {A B C}
} -match exact -result {A B C}

test tcltest-24.12 {
	test: -match exact	match command eval in ::, not caller namespace
} -setup {
	set saveExactMatchScript $::tcltest::CustomMatch(exact)
	customMatch exact [list string equal]
	set v [verbose]
	proc string args {error {called [string] in caller namespace}}
} -body {
	verbose {}
	test tcltest-24.12.0 {} -body {format 1} -result 1
} -cleanup {
	rename string {}
	verbose $v
	customMatch exact $saveExactMatchScript
	unset saveExactMatchScript
} -match exact -result {} -output {}

test tcltest-24.13 {
	test: -match exact	failure
} -setup {
	set saveExactMatchScript $::tcltest::CustomMatch(exact)
	customMatch exact [list string equal]
	set v [verbose]
	set fail $::tcltest::currentFailure
} -body {
	verbose {}
	test tcltest-24.13.0 {} -body {format 1} -result 0
} -cleanup {
	set ::tcltest::currentFailure $fail
	verbose $v
	customMatch exact $saveExactMatchScript
	unset saveExactMatchScript
} -match glob -result {} -output {*FAILED*Result was:
1*(exact matching):
0*}

test tcltest-24.14 {
	test: -match glob
} -body {
	set result {A B C}
} -match glob -result {A B*}

test tcltest-24.15 {
	test: -match glob	failure
} -setup {
	set v [verbose]
	set fail $::tcltest::currentFailure
} -body {
	verbose {}
	test tcltest-24.15.0 {} -match glob -body {format {A B C}} \
		-result {A B* }
} -cleanup {
	set ::tcltest::currentFailure $fail
	verbose $v
} -match glob -result {} -output {*FAILED*Result was:
*(glob matching):
*}

test tcltest-24.16 {
	test: -match regexp
} -body {
	set result {A B C}
} -match regexp -result {A B.*}

test tcltest-24.17 {
	test: -match regexp	failure
} -setup {
	set fail $::tcltest::currentFailure
	set v [verbose]
} -body {
	verbose {}
	test tcltest-24.17.0 {} -match regexp -body {format {A B C}} \
		-result {A B.* X}
} -cleanup {
	set ::tcltest::currentFailure $fail
	verbose $v
} -match glob -result {} -output {*FAILED*Result was:
*(regexp matching):
*}

test tcltest-24.18 {
	test: -match custom	forget namespace qualification
} -setup {
	set fail $::tcltest::currentFailure
	set v [verbose]
	customMatch negative matchNegative
} -body {
	verbose {}
	test tcltest-24.18.0 {} -match negative -body {format {A B C}} \
		-result {A B X}
} -cleanup {
	set ::tcltest::currentFailure $fail
	verbose $v
} -match glob -result {} -output {*FAILED*Error testing result:*}

test tcltest-24.19 {
	test: -match custom
} -setup {
	set v [verbose]
	customMatch negative [namespace code matchNegative]
} -body {
	verbose {}
	test tcltest-24.19.0 {} -match negative -body {format {A B C}} \
		-result {A B X}
} -cleanup {
	verbose $v
} -match exact -result {} -output {}

test tcltest-24.20 {
	test: -match custom	failure
} -setup {
	set fail $::tcltest::currentFailure
	set v [verbose]
	customMatch negative [namespace code matchNegative]
} -body {
	verbose {}
	test tcltest-24.20.0 {} -match negative -body {format {A B C}} \
		-result {A B C}
} -cleanup {
	set ::tcltest::currentFailure $fail
	verbose $v
} -match glob -result {} -output {*FAILED*Result was:
*(negative matching):
*}

test tcltest-25.1 {
	constraint of setup/cleanup (Bug 589859)
} -setup {
	set foo 0
} -body {
	# Buggy tcltest will generate result of 2
	test tcltest-25.1.0 {} -constraints knownBug -setup {
	    incr foo
	} -body {
	    incr foo
	} -cleanup {
	    incr foo
	} -match glob -result *
	set foo
} -cleanup {
	unset foo
} -result 0

test tcltest-25.2 {
	puts -nonewline (Bug 612786)
} -body {
	puts -nonewline stdout bla
	puts -nonewline stdout bla
} -output {blabla}

test tcltest-25.3 {
	reported return code (Bug 611922)
} -body {
	# Buggy tcltest will generate result of 2
	test tcltest-25.3.0 {} -body {
	    error foo
	}
} -match glob -output {*generated error; Return code was: 1*}

cleanupTests
}

namespace delete ::tcltest::test
return
@


1.4
log
@touched all sources to ease next import
@
text
@a0 5
# Command line options covered:
#  -help, -verbose, -match, -skip, -file, -notfile, -constraints,
#  -limitconstraints, -preservecore, -tmpdir, -debug, -outfile, 
#  -errfile, -args
#
d5 2
a6 1
# Copyright (c) 1998-1999 by Scriptics Corporation.
d9 12
a20 1
# RCS: @@(#) $Id: tcltest.test,v 1.1.1.1.8.2 2000/09/15 16:57:41 spolk Exp $
d22 3
a24 3
if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import -force ::tcltest::*
d27 4
d33 1
a33 1
    namespace import -force ::tcltest::*
d42 4
a45 1
    ::tcltest::cleanupTests
d49 2
d52 3
a54 3
test tcltest-1.1 {tcltest -help} {unixOrPc} {
    set result [catch {exec $::tcltest::tcltest test.tcl -help} msg]
    set result [catch {runCmd $cmd}]
d57 2
a58 2
test tcltest-1.2 {tcltest -help -something} {unixOrPc} {
    set result [catch {exec $::tcltest::tcltest test.tcl -help -something} msg]
d61 2
a62 2
test tcltest-1.3 {tcltest -h} {unixOrPc} {
    set result [catch {exec $::tcltest::tcltest test.tcl -h} msg]
d64 36
a99 1
} {1 1} 
d101 2
a102 1
# -verbose
d104 1
a104 1
    set result [catch {exec $::tcltest::tcltest test.tcl} msg]
d107 1
a107 1
	    [regexp "Total.+3.+Passed.+1.+Skipped.+1.+Failed.+1" $msg]
d109 2
a110 2
test tcltest-2.1 {tcltest -v 'b'} {unixOrPc} {
    set result [catch {exec $::tcltest::tcltest test.tcl -v 'b'} msg]
d113 1
a113 1
	    [regexp "Total.+3.+Passed.+1.+Skipped.+1.+Failed.+1" $msg]
d115 2
a116 2
test tcltest-2.2 {tcltest -v 'p'} {unixOrPc} {
    set result [catch {exec $::tcltest::tcltest test.tcl -v 'p'} msg]
d119 1
a119 1
	    [regexp "Total.+3.+Passed.+1.+Skipped.+1.+Failed.+1" $msg]
d121 2
a122 2
test tcltest-2.3 {tcltest -v 's'} {unixOrPc} {
    set result [catch {exec $::tcltest::tcltest test.tcl -v 's'} msg]
d125 1
a125 1
	    [regexp "Total.+3.+Passed.+1.+Skipped.+1.+Failed.+1" $msg]
d127 2
a128 2
test tcltest-2.4 {tcltest -v 'ps'} {unixOrPc} {
    set result [catch {exec $::tcltest::tcltest test.tcl -verbose 'ps'} msg]
d131 1
a131 1
	    [regexp "Total.+3.+Passed.+1.+Skipped.+1.+Failed.+1" $msg]
d133 2
a134 2
test tcltest-2.5 {tcltest -v 'psb'} {unixOrPc} {
    set result [catch {exec $::tcltest::tcltest test.tcl -v 'psb'} msg]
d137 1
a137 1
	    [regexp "Total.+3.+Passed.+1.+Skipped.+1.+Failed.+1" $msg]
d140 50
a189 1
# -match
d191 1
a191 1
    set result [catch {exec $::tcltest::tcltest test.tcl -match a* -v 'ps'} msg]
d193 1
a193 1
	    [regexp "Total.+3.+Passed.+1.+Skipped.+2.+Failed.+0" $msg]
d196 1
a196 1
    set result [catch {exec $::tcltest::tcltest test.tcl -m b* -v 'ps'} msg]
d198 1
a198 1
	    [regexp "Total.+3.+Passed.+0.+Skipped.+2.+Failed.+1" $msg]
d201 1
a201 1
    set result [catch {exec $::tcltest::tcltest test.tcl -match c* -v 'ps'} msg]
d203 1
a203 1
	    [regexp "Total.+3.+Passed.+0.+Skipped.+3.+Failed.+0" $msg]
d206 1
a206 1
    set result [catch {exec $::tcltest::tcltest test.tcl -match {a* b*} -v 'ps'} msg]
d208 1
a208 1
	    [regexp "Total.+3.+Passed.+1.+Skipped.+1.+Failed.+1" $msg]
d211 14
a224 1
# -skip
d226 1
a226 1
    set result [catch {exec $::tcltest::tcltest test.tcl -skip a* -v 'ps'} msg]
d228 1
a228 1
	    [regexp "Total.+3.+Passed.+0.+Skipped.+2.+Failed.+1" $msg]
d231 1
a231 1
    set result [catch {exec $::tcltest::tcltest test.tcl -s b* -v 'ps'} msg]
d233 1
a233 1
	    [regexp "Total.+3.+Passed.+1.+Skipped.+2.+Failed.+0" $msg]
d236 1
a236 1
    set result [catch {exec $::tcltest::tcltest test.tcl -skip c* -v 'ps'} msg]
d238 1
a238 1
	    [regexp "Total.+3.+Passed.+1.+Skipped.+1.+Failed.+1" $msg]
d241 1
a241 1
    set result [catch {exec $::tcltest::tcltest test.tcl -skip {a* b*} -v 'ps'} msg]
d243 1
a243 1
	    [regexp "Total.+3.+Passed.+0.+Skipped.+3.+Failed.+0" $msg]
d246 1
a246 1
    set result [catch {exec $::tcltest::tcltest test.tcl -match {a* b*} -skip b* -v 'ps'} msg]
d248 1
a248 1
	    [regexp "Total.+3.+Passed.+1.+Skipped.+2.+Failed.+0" $msg]
d251 15
a265 1
# -constraints, -limitconstraints
d267 1
a267 1
    set result [catch {exec $::tcltest::tcltest test.tcl -constraints knownBug -v 'ps'} msg]
d269 1
a269 1
	    [regexp "Total.+3.+Passed.+2.+Skipped.+0.+Failed.+1" $msg]
d271 2
a272 2
test tcltest-5.1 {tcltest -constraints 'knownBug'} {unixOrPc} {
    set result [catch {exec $::tcltest::tcltest test.tcl -constraints knownBug -v 'p' -limitconstraints 1} msg]
d274 1
a274 1
	    [regexp "Total.+3.+Passed.+1.+Skipped.+2.+Failed.+0" $msg]
d277 68
a344 1
makeFile {
d346 2
a347 2
    namespace import -force ::tcltest::*
    puts $::tcltest::outputChannel "a test"
d357 1
a357 1
} printerror.tcl
d359 11
a369 7
# -outfile, -errfile
test tcltest-6.1 {tcltest -outfile, -errfile defaults} {unixOrPc} {
    catch {exec $::tcltest::tcltest printerror.tcl} msg
    list [regexp "a test" $msg] [regexp "a really" $msg]
} {1 1}
test tcltest-6.2 {tcltest -outfile a.tmp} {unixOrPc} {
    catch {exec $::tcltest::tcltest printerror.tcl -outfile a.tmp} msg
d375 2
a376 2
test tcltest-6.3 {tcltest -errfile a.tmp} {unixOrPc} {
    catch {exec $::tcltest::tcltest printerror.tcl -errfile a.tmp} msg
d382 2
a383 2
test tcltest-6.4 {tcltest -outfile a.tmp -errfile b.tmp} {unixOrPc} {
    catch {exec $::tcltest::tcltest printerror.tcl -o a.tmp -e b.tmp} msg
d392 77
a468 3
# -debug
test tcltest-7.1 {tcltest test.tcl -d 0} {unixOrPc} {
    catch {exec $::tcltest::tcltest test.tcl -d 0} msg
d471 2
a472 2
test tcltest-7.2 {tcltest test.tcl -d 1} {unixOrPc} {
    catch {exec $::tcltest::tcltest test.tcl -d 1 -s b*} msg
d476 2
a477 2
test tcltest-7.3 {tcltest test.tcl -d 1} {unixOrPc} {
    catch {exec $::tcltest::tcltest test.tcl -d 1 -m b*} msg
d481 2
a482 2
test tcltest-7.4 {tcltest test.tcl -d 2} {unixOrPc} {
    catch {exec $::tcltest::tcltest test.tcl -d 2} msg
d485 2
a486 2
test tcltest-7.5 {tcltest test.tcl -d 3} {unixOrPc} {
    catch {exec $::tcltest::tcltest test.tcl -d 3} msg
d490 21
d513 2
a514 2
    namespace import -force ::tcltest::*
    makeFile {} a.tmp
d518 6
a523 1
makeFile {} thisdirectoryisafile
d525 1
a525 1
# -tmpdir
d528 1
a528 1
    exec $::tcltest::tcltest a.tcl -tmpdir thisdirectorydoesnotexist
d532 9
a540 5
test tcltest-8.2 {tcltest a.tcl -tmpdir thisdirectoryisafile} {unixOrPc} {
    catch {exec $::tcltest::tcltest a.tcl -tmpdir thisdirectoryisafile} msg
    # The join is necessary because the message can be split on multiple lines
    list [regexp "not a directory" [join $msg]]
} {1}
d542 3
a544 3
# Test non-writeable directories, non-readable directories with tmpdir
set notReadableDir [file join $::tcltest::temporaryDirectory notreadable]
set notWriteableDir [file join $::tcltest::temporaryDirectory notwriteable]
d546 2
a547 2
::tcltest::makeDirectory notreadable
::tcltest::makeDirectory notwriteable
d555 1
a555 1
	file attributes $notWriteableDir -readonly 1
d559 8
a566 4
test tcltest-8.3 {tcltest a.tcl -tmpdir notReadableDir} {unixOnly} {
    catch {exec $::tcltest::tcltest a.tcl -tmpdir $notReadableDir} msg 
    # The join is necessary because the message can be split on multiple lines
    list [regexp {not readable} [join $msg]]
d569 2
a570 2
test tcltest-8.4 {tcltest a.tcl -tmpdir notWriteableDir} {unixOrPc} {
    catch {exec $::tcltest::tcltest a.tcl -tmpdir $notWriteableDir} msg
d572 40
a611 1
    list [regexp {not writeable} [join $msg]]
d614 3
a616 5
# -testdir
test tcltest-8.5 {tcltest a.tcl -testdir thisdirectorydoesnotexist} {
    file delete -force thisdirectorydoesnotexist
    catch {exec $::tcltest::tcltest a.tcl -testdir thisdirectorydoesnotexist}  msg
    list [regexp "does not exist" [join $msg]]
d619 3
a621 4
test tcltest-8.6 {tcltest a.tcl -testdir thisdirectoryisafile} {
    catch {exec $::tcltest::tcltest a.tcl -testdir thisdirectoryisafile} msg
    # The join is necessary because the message can be split on multiple lines
    list [regexp "not a directory" [join $msg]] 
d624 3
a626 2
test tcltest-8.7 {tcltest a.tcl -testdir notReadableDir} {unixOnly} {
    catch {exec $::tcltest::tcltest a.tcl -testdir $notReadableDir} msg 
d628 50
a677 2
    list [regexp {not readable} [join $msg]]
} {1}
d679 1
d687 1
a687 1
	file attributes $notWriteableDir -readonly 0
d693 1
a693 1
# -file -notfile
d695 1
a695 2
    catch {exec $::tcltest::tcltest \
	    [file join $::tcltest::testsDirectory all.tcl] -file a*.test} msg
d699 2
a700 3
    catch {exec $::tcltest::tcltest \
	    [file join $::tcltest::testsDirectory all.tcl] \
	    -file a*.test -notfile assocd*} msg
d704 12
d717 12
d730 1
d733 1
a733 2
    namespace import -force ::tcltest::*

d742 1
a742 1
# -preservecore 
d744 1
a744 1
    catch {exec $::tcltest::tcltest makecore.tcl -preservecore 0} msg
d746 1
a746 1
    regexp "produced core file" $msg
d749 1
a749 1
    catch {exec $::tcltest::tcltest makecore.tcl -preservecore 1} msg
d751 1
a751 1
    regexp "produced core file" $msg
d754 1
a754 1
    catch {exec $::tcltest::tcltest makecore.tcl -preservecore 2} msg
d756 1
a756 1
    list [regexp "==== makecore produced core file" $msg] [regexp "Moving file to" $msg] \
d760 1
a760 1
    catch {exec $::tcltest::tcltest makecore.tcl -preservecore 3} msg
d762 1
a762 1
    list [regexp "produced core file" $msg] [regexp "Moving file to" $msg] \
d766 97
d864 4
d869 25
a893 4
    namespace import -force ::tcltest::*
    puts "=$::tcltest::parameters="
    exit
} args.tcl
d895 16
a910 5
# -args
test tcltest-11.1 {-args foo} {unixOrPc} {
    catch {exec $::tcltest::tcltest args.tcl -args foo} msg
    list $msg
} {=foo=}
d912 1
a912 4
test tcltest-11.2 {-args {}} {unixOrPc} {
    catch {exec $::tcltest::tcltest args.tcl -args {}} msg
    list $msg
} {==}
d914 2
a915 4
test tcltest-11.3 {-args {-foo bar -baz}} {unixOrPc} {
    catch {exec $::tcltest::tcltest args.tcl -args {-foo bar -baz}} msg
    list $msg
} {{=-foo bar -baz=}}
d917 16
a932 1
# -load -loadfile
d935 103
a1037 4
    namespace import -force ::tcltest::*
    puts $::tcltest::loadScript
    exit
} load.tcl
d1039 16
a1054 4
test tcltest-12.1 {-load xxx} {
    catch {exec $::tcltest::tcltest load.tcl -load xxx} msg
    set msg
} {xxx}
d1056 33
a1088 6
test tcltest-12.1 {-loadfile load.tcl} {
    catch {exec $::tcltest::tcltest load.tcl -d 2 -loadfile load.tcl} msg
    list \
	    [regexp {tcltest} [join $msg [split $msg \n]]] \
	    [regexp {loadScript} [join $msg [split $msg \n]]]
} {1 1}
d1092 1
d1095 1
a1095 1
    set result [catch {exec $::tcltest::tcltest printerror.tcl} msg]
d1100 1
d1102 607
a1708 2
# cleanup
::tcltest::cleanupTests
a1709 1

@


1.3
log
@touched all sources to ease next import
@
text
@@


1.3.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d1 5
d10 1
a10 2
# Copyright (c) 1998-1999 by Scriptics Corporation. 
# Copyright (c) 2000 by Ajuba Solutions
d13 1
a13 1
# RCS: @@(#) $Id: tcltest.test,v 1.35 2002/09/22 18:19:26 dgp Exp $
d15 3
a17 14
# Note that there are several places where the value of 
# tcltest::currentFailure is stored/reset in the -setup/-cleanup
# of a test that has a body that runs [test] that will fail.
# This is a workaround of using the same tcltest code that we are
# testing to run the test itself.  Ditto on things like [verbose].
#
# It would be better to have the -body of the tests run the tcltest
# commands in a slave interp so the [test] being tested would not
# interfere with the [test] doing the testing.  
#

if {[catch {package require tcltest 2.1}]} {
    puts stderr "Skipping tests in [info script].  tcltest 2.1 required."
    return
a19 4
namespace eval ::tcltest::test {

namespace import ::tcltest::*

d22 1
a22 1
    namespace import ::tcltest::test
d31 1
a31 4
    test d-1.0 {test d} {
	error "foo" foo 9
    } {}
    tcltest::cleanupTests
a34 2
cd [temporaryDirectory]
testConstraint exec [llength [info commands exec]]
d36 3
a38 3
# Child processes because -help [exit]s.
test tcltest-1.1 {tcltest -help} {exec} {
    set result [catch {exec [interpreter] test.tcl -help} msg]
d41 2
a42 2
test tcltest-1.2 {tcltest -help -something} {exec} {
    set result [catch {exec [interpreter] test.tcl -help -something} msg]
d45 2
a46 2
test tcltest-1.3 {tcltest -h} {exec} {
    set result [catch {exec [interpreter] test.tcl -h} msg]
d48 1
a48 1
} {1 0} 
d50 1
a50 37
# -verbose, implicit & explicit testing of [verbose]
proc slave {msgVar args} {
    upvar 1 $msgVar msg

    interp create [namespace current]::i
    # Fake the slave interp into dumping output to a file
    i eval {namespace eval ::tcltest {}}
    i eval "set tcltest::outputChannel \[open [makeFile {} output] w]"
    i eval "set tcltest::errorChannel \[open [makeFile {} error] w]"
    i eval [list set argv0 [lindex $args 0]]
    i eval [list set argv [lrange $args 1 end]]
    i eval [list package ifneeded tcltest [package provide tcltest] \
	    [package ifneeded tcltest [package provide tcltest]]]
    i eval {proc exit args {}}

    # Need to capture output in msg

    set code [catch {i eval {source $argv0}} foo]
if $code {
#puts "$code: $foo\n$::errorInfo"
}
    i eval {close $tcltest::outputChannel}
    interp delete [namespace current]::i
    set f [open [file join [temporaryDirectory] output]]
    set msg [read -nonewline $f]
    close $f
    set f [open [file join [temporaryDirectory] error]]
    set err [read -nonewline $f]
    close $f
    if {[string length $err]} {
	set code 1
	append msg \n$err
    }
    return $code

#    return [catch {uplevel 1 [linsert $args 0  exec [interpreter]]} msg]
}
d52 1
a52 1
    set result [slave msg test.tcl]
d55 1
a55 1
	    [regexp "Total.+4.+Passed.+1.+Skipped.+1.+Failed.+2" $msg]
d57 2
a58 2
test tcltest-2.1 {tcltest -verbose 'b'} {unixOrPc} {
    set result [slave msg test.tcl -verbose 'b']
d61 1
a61 1
	    [regexp "Total.+4.+Passed.+1.+Skipped.+1.+Failed.+2" $msg]
d63 2
a64 2
test tcltest-2.2 {tcltest -verbose 'p'} {unixOrPc} {
    set result [slave msg test.tcl -verbose 'p']
d67 1
a67 1
	    [regexp "Total.+4.+Passed.+1.+Skipped.+1.+Failed.+2" $msg]
d69 2
a70 2
test tcltest-2.3 {tcltest -verbose 's'} {unixOrPc} {
    set result [slave msg test.tcl -verbose 's']
d73 1
a73 1
	    [regexp "Total.+4.+Passed.+1.+Skipped.+1.+Failed.+2" $msg]
d75 2
a76 2
test tcltest-2.4 {tcltest -verbose 'ps'} {unixOrPc} {
    set result [slave msg test.tcl -verbose 'ps']
d79 1
a79 1
	    [regexp "Total.+4.+Passed.+1.+Skipped.+1.+Failed.+2" $msg]
d81 2
a82 2
test tcltest-2.5 {tcltest -verbose 'psb'} {unixOrPc} {
    set result [slave msg test.tcl -verbose 'psb']
d85 1
a85 1
	    [regexp "Total.+4.+Passed.+1.+Skipped.+1.+Failed.+2" $msg]
d88 1
a88 50
test tcltest-2.5a {tcltest -verbose 'pass skip body'} {unixOrPc} {
    set result [slave msg test.tcl -verbose "pass skip body"]
    list $result [regexp "Contents of test case" $msg] [regexp a-1.0 $msg] \
	    [regexp c-1.0 $msg] \
	    [regexp "Total.+4.+Passed.+1.+Skipped.+1.+Failed.+2" $msg]
} {0 1 1 1 1}

test tcltest-2.6 {tcltest -verbose 't'}  {
    -constraints {unixOrPc} 
    -body {
	set result [slave msg test.tcl -verbose 't']
	list $result $msg
    }
    -result {^0 .*a-1.0 start.*b-1.0 start}
    -match regexp
}

test tcltest-2.6a {tcltest -verbose 'start'}  {
    -constraints {unixOrPc} 
    -body {
	set result [slave msg test.tcl -verbose start]
	list $result $msg
    }
    -result {^0 .*a-1.0 start.*b-1.0 start}
    -match regexp
}

test tcltest-2.7 {tcltest::verbose}  {
    -body {
	set oldVerbosity [verbose]
	verbose bar
	set currentVerbosity [verbose]
	verbose foo
	set newVerbosity [verbose]
	verbose $oldVerbosity
	list $currentVerbosity $newVerbosity 
    }
    -result {body {}}
}

test tcltest-2.8 {tcltest -verbose 'error'} {
    -constraints {unixOrPc}
    -body {
	set result [slave msg test.tcl -verbose error]
	list $result $msg
    }
    -result {errorInfo: foo.*errorCode: 9}
    -match regexp
}
# -match, [match]
d90 1
a90 1
    set result [slave msg test.tcl -match a* -verbose 'ps']
d92 1
a92 1
	    [regexp "Total.+4.+Passed.+1.+Skipped.+3.+Failed.+0" $msg]
d95 1
a95 1
    set result [slave msg test.tcl -match b* -verbose 'ps']
d97 1
a97 1
	    [regexp "Total.+4.+Passed.+0.+Skipped.+3.+Failed.+1" $msg]
d100 1
a100 1
    set result [slave msg test.tcl -match c* -verbose 'ps']
d102 1
a102 1
	    [regexp "Total.+4.+Passed.+0.+Skipped.+4.+Failed.+0" $msg]
d105 1
a105 1
    set result [slave msg test.tcl -match {a* b*} -verbose 'ps']
d107 1
a107 1
	    [regexp "Total.+4.+Passed.+1.+Skipped.+2.+Failed.+1" $msg]
d110 1
a110 14
test tcltest-3.5 {tcltest::match}  {
    -body {
	set oldMatch [match]
	match foo
	set currentMatch [match]
	match bar
	set newMatch [match]
	match $oldMatch
	list $currentMatch $newMatch
    }
    -result {foo bar}
}
	
# -skip, [skip]
d112 1
a112 1
    set result [slave msg test.tcl -skip a* -verbose 'ps']
d114 1
a114 1
	    [regexp "Total.+4.+Passed.+0.+Skipped.+2.+Failed.+1" $msg]
d117 1
a117 1
    set result [slave msg test.tcl -skip b* -verbose 'ps']
d119 1
a119 1
	    [regexp "Total.+4.+Passed.+1.+Skipped.+2.+Failed.+1" $msg]
d122 1
a122 1
    set result [slave msg test.tcl -skip c* -verbose 'ps']
d124 1
a124 1
	    [regexp "Total.+4.+Passed.+1.+Skipped.+1.+Failed.+2" $msg]
d127 1
a127 1
    set result [slave msg test.tcl -skip {a* b*} -verbose 'ps']
d129 1
a129 1
	    [regexp "Total.+4.+Passed.+0.+Skipped.+3.+Failed.+1" $msg]
d132 1
a132 1
    set result [slave msg test.tcl -match {a* b*} -skip b* -verbose 'ps']
d134 1
a134 1
	    [regexp "Total.+4.+Passed.+1.+Skipped.+3.+Failed.+0" $msg]
d137 1
a137 15
test tcltest-4.6 {tcltest::skip} {
    -body {
	set oldSkip [skip]
	skip foo
	set currentSkip [skip]
	skip bar
	set newSkip [skip]
	skip $oldSkip
	list $currentSkip $newSkip
    }
    -result {foo bar}
}

# -constraints, -limitconstraints, [testConstraint],
# $constraintsSpecified, [limitConstraints]
d139 1
a139 1
    set result [slave msg test.tcl -constraints knownBug -verbose 'ps']
d141 1
a141 1
	    [regexp "Total.+4.+Passed.+2.+Skipped.+0.+Failed.+2" $msg]
d143 2
a144 2
test tcltest-5.2 {tcltest -constraints 'knownBug' -limitconstraints 1} {unixOrPc} {
    set result [slave msg test.tcl -constraints knownBug -verbose 'p' -limitconstraints 1]
d146 1
a146 1
	    [regexp "Total.+4.+Passed.+1.+Skipped.+3.+Failed.+0" $msg]
d149 1
a149 68
test tcltest-5.3 {testConstraint - constraint empty (tcltest::safeFetch)}  {
    -body {
	set r1 [testConstraint tcltestFakeConstraint]
	set r2 [testConstraint tcltestFakeConstraint 4]
	set r3 [testConstraint tcltestFakeConstraint]
	list $r1 $r2 $r3
    }
    -result {0 4 4}
    -cleanup {unset ::tcltest::testConstraints(tcltestFakeConstraint)}
}

# Removed this test of internals of tcltest.  Those internals have changed.
#test tcltest-5.4 {tcltest::constraintsSpecified} {
#    -setup {
#	set constraintlist $::tcltest::constraintsSpecified
#	set ::tcltest::constraintsSpecified {}
#    }
#    -body {
#	set r1 $::tcltest::constraintsSpecified
#	testConstraint tcltestFakeConstraint1 1
#	set r2 $::tcltest::constraintsSpecified
#	testConstraint tcltestFakeConstraint2 1
#	set r3 $::tcltest::constraintsSpecified
#	list $r1 $r2 $r3
#    }
#    -result {{} tcltestFakeConstraint1 {tcltestFakeConstraint1 tcltestFakeConstraint2}}
#    -cleanup {
#	set ::tcltest::constraintsSpecified $constraintlist
#	unset ::tcltest::testConstraints(tcltestFakeConstraint1) 
#	unset ::tcltest::testConstraints(tcltestFakeConstraint2) 
#    }
#}

test tcltest-5.5 {InitConstraints: list of built-in constraints} \
	-constraints {!singleTestInterp} \
	-setup {tcltest::InitConstraints} \
	-body { lsort [array names ::tcltest::testConstraints] } \
	-result [lsort {
    95 98 asyncPipeClose eformat emptyTest exec hasIsoLocale interactive
    knownBug mac macCrash macOnly macOrPc macOrUnix macOrWin nonBlockFiles
    nonPortable notRoot nt pc pcCrash pcOnly root singleTestInterp socket
    stdio tempNotMac tempNotPc tempNotUnix tempNotWin unix unixCrash unixExecs
    unixOnly unixOrPc unixOrWin userInteraction win winCrash winOnly
}]

# Removed this broken test.  Its usage of [limitConstraints] was not
# in agreement with the documentation.  [limitConstraints] is supposed
# to take an optional boolean argument, and "knownBug" ain't no boolean!
#test tcltest-5.6 {tcltest::limitConstraints} {
#    -setup {
#        set keeplc $::tcltest::limitConstraints
#        set keepkb [testConstraint knownBug]
#    }
#    -body {
#        set r1 [limitConstraints]
#        set r2 [limitConstraints knownBug]
#        set r3 [limitConstraints]
#        list $r1 $r2 $r3
#    }
#    -cleanup {
#        limitConstraints $keeplc
#        testConstraint knownBug $keepkb
#    }
#    -result {false knownBug knownBug}
#}

# -outfile, -errfile, [outputChannel], [outputFile], [errorChannel], [errorFile]
set printerror [makeFile {
d151 2
a152 2
    namespace import ::tcltest::*
    puts [outputChannel] "a test"
d162 1
a162 1
} printerror.tcl]
d164 7
a170 11
test tcltest-6.1 {tcltest -outfile, -errfile defaults} {
    -constraints unixOrPc
    -body {
	slave msg $printerror
	return $msg
    }
    -result {a test.*a really}
    -match regexp
}
test tcltest-6.2 {tcltest -outfile a.tmp} {unixOrPc unixExecs} {
    slave msg $printerror -outfile a.tmp
d176 2
a177 2
test tcltest-6.3 {tcltest -errfile a.tmp} {unixOrPc unixExecs} {
    slave msg $printerror -errfile a.tmp
d183 2
a184 2
test tcltest-6.4 {tcltest -outfile a.tmp -errfile b.tmp} {unixOrPc unixExecs} {
    slave msg printerror.tcl -outfile a.tmp -errfile b.tmp
d193 3
a195 77
test tcltest-6.5 {tcltest::errorChannel - retrieval} {
    -setup {
	set of [errorChannel]
	set ::tcltest::errorChannel stderr
    }
    -body {
	errorChannel
    }
    -result {stderr}
    -cleanup {
	set ::tcltest::errorChannel $of
    }
}

test tcltest-6.6 {tcltest::errorFile (implicit errorChannel)} {
    -setup {
	set ef [makeFile {} efile]
	set of [errorFile]
	set ::tcltest::errorChannel stderr
	set ::tcltest::errorFile stderr
    }
    -body {
	set f0 [errorChannel]
	set f1 [errorFile]
	set f2 [errorFile $ef]
	set f3 [errorChannel]
	set f4 [errorFile]
	subst {$f0;$f1;$f2;$f3;$f4} 
    }
    -result {stderr;stderr;.*efile;file[0-9a-f]+;.*efile}
    -match regexp
    -cleanup {
	errorFile $of
    }
}
test tcltest-6.7 {tcltest::outputChannel - retrieval} {
    -setup {
	set of [outputChannel]
	set ::tcltest::outputChannel stdout
    }
    -body {
	outputChannel
    }
    -result {stdout}
    -cleanup {
	set tcltest::outputChannel $of
    }
}

test tcltest-6.8 {tcltest::outputFile (implicit outputFile)} {
    -setup {
	set ef [makeFile {} efile]
	set of [outputFile]
	set ::tcltest::outputChannel stdout
	set ::tcltest::outputFile stdout
    }
    -body {
	set f0 [outputChannel]
	set f1 [outputFile]
	set f2 [outputFile $ef]
	set f3 [outputChannel]
	set f4 [outputFile]
	subst {$f0;$f1;$f2;$f3;$f4} 
    }
    -result {stdout;stdout;.*efile;file[0-9a-f]+;.*efile}
    -match regexp
    -cleanup {
	outputFile $of
    }
}

# -debug, [debug]
# Must use child processes to test -debug because it always writes
# messages to stdout, and we have no way to capture stdout of a
# slave interp
test tcltest-7.1 {tcltest test.tcl -debug 0} {unixOrPc} {
    catch {exec [interpreter] test.tcl -debug 0} msg
d198 2
a199 2
test tcltest-7.2 {tcltest test.tcl -debug 1} {unixOrPc} {
    catch {exec [interpreter] test.tcl -debug 1 -skip b*} msg
d203 2
a204 2
test tcltest-7.3 {tcltest test.tcl -debug 1} {unixOrPc} {
    catch {exec [interpreter] test.tcl -debug 1 -match b*} msg
d208 2
a209 2
test tcltest-7.4 {tcltest test.tcl -debug 2} {unixOrPc} {
    catch {exec [interpreter] test.tcl -debug 2} msg
d212 2
a213 2
test tcltest-7.5 {tcltest test.tcl -debug 3} {unixOrPc} {
    catch {exec [interpreter] test.tcl -debug 3} msg
a216 21
test tcltest-7.6 {tcltest::debug} {
    -setup {
	set old $::tcltest::debug
	set ::tcltest::debug 0
    }
    -body {
	set f1 [debug]
	set f2 [debug 1]
	set f3 [debug]
	set f4 [debug 2]
	set f5 [debug]
	list $f1 $f2 $f3 $f4 $f5
    }
    -result {0 1 1 2 2}
    -cleanup {
	set ::tcltest::debug $old
    }
}

# directory tests

d219 2
a220 2
    tcltest::makeFile {} a.tmp
    puts [tcltest::outputChannel] "testdir: [tcltest::testsDirectory]"
d224 1
a224 6
makeFile {} thisdirectoryisafile  

set normaldirectory [makeDirectory normaldirectory]
if {$::tcl_platform(platform) == "macintosh"} {
set normaldirectory [file normalize $normaldirectory]
}
d226 1
a226 1
# -tmpdir, [temporaryDirectory]
d229 1
a229 1
    slave msg a.tcl -tmpdir thisdirectorydoesnotexist
d233 5
a237 9
test tcltest-8.2 {tcltest a.tcl -tmpdir thisdirectoryisafile} {
    -constraints unixOrPc
    -body {
	slave msg a.tcl -tmpdir thisdirectoryisafile
	set msg
    }
    -result {*not a directory*}
    -match glob
}
d239 3
a241 3
# Test non-writeable directories, non-readable directories with directory flags
set notReadableDir [file join [temporaryDirectory] notreadable]
set notWriteableDir [file join [temporaryDirectory] notwriteable]
d243 2
a244 2
makeDirectory notreadable
makeDirectory notwriteable
d252 1
a252 1
	catch {file attributes $notWriteableDir -readonly 1}
d256 4
a259 3
test tcltest-8.3 {tcltest a.tcl -tmpdir notReadableDir} {unixOnly nonRoot} {
    slave msg a.tcl -tmpdir $notReadableDir 
    string match {*not readable*} $msg
d262 4
a265 3
test tcltest-8.4 {tcltest a.tcl -tmpdir notWriteableDir} {unixOrPc nonRoot} {
    slave msg a.tcl -tmpdir $notWriteableDir
    string match {*not writeable*} $msg
d268 2
a269 40
test tcltest-8.5 {tcltest a.tcl -tmpdir normaldirectory} {unixOrPc} {
    slave msg a.tcl -tmpdir $normaldirectory
    # The join is necessary because the message can be split on multiple lines
    list [file exists [file join $normaldirectory a.tmp]] \
	    [file delete [file join $normaldirectory a.tmp]] 
} {1 {}}   
cd [workingDirectory]

test tcltest-8.6 {temporaryDirectory}  {
    -setup {
	set old $::tcltest::temporaryDirectory
	set ::tcltest::temporaryDirectory $normaldirectory
    }
    -body {
	set f1 [temporaryDirectory]
	set f2 [temporaryDirectory [workingDirectory]]
	set f3 [temporaryDirectory]
	list $f1 $f2 $f3
    }
    -result "[list $normaldirectory [workingDirectory] [workingDirectory]]"
    -cleanup {
	set ::tcltest::temporaryDirectory $old
    }
}

test tcltest-8.6a {temporaryDirectory - test format 2} -setup {
    set old $::tcltest::temporaryDirectory
    set ::tcltest::temporaryDirectory $normaldirectory
} -body {
    set f1 [temporaryDirectory]
    set f2 [temporaryDirectory [workingDirectory]]
    set f3 [temporaryDirectory]
    list $f1 $f2 $f3
} -cleanup {
    set ::tcltest::temporaryDirectory $old
} -result [list $normaldirectory [workingDirectory] [workingDirectory]]

cd [temporaryDirectory]
# -testdir, [testsDirectory]
test tcltest-8.10 {tcltest a.tcl -testdir thisdirectorydoesnotexist} {unixOrPc} {
d271 2
a272 2
    slave msg a.tcl -testdir thisdirectorydoesnotexist
    string match "*does not exist*" $msg
d275 4
a278 3
test tcltest-8.11 {tcltest a.tcl -testdir thisdirectoryisafile} {unixOrPc} {
    slave msg a.tcl -testdir thisdirectoryisafile
    string match "*not a directory*" $msg 
d281 4
a284 3
test tcltest-8.12 {tcltest a.tcl -testdir notReadableDir} {unixOnly nonRoot} {
    slave msg a.tcl -testdir $notReadableDir 
    string match {*not readable*} $msg
a287 56
test tcltest-8.13 {tcltest a.tcl -testdir normaldirectory} {unixOrPc} {
    slave msg a.tcl -testdir $normaldirectory
    # The join is necessary because the message can be split on multiple lines
    list [string first "testdir: $normaldirectory" [join $msg]] \
	    [file exists [file join [temporaryDirectory] a.tmp]] \
	    [file delete [file join [temporaryDirectory] a.tmp]] 
} {0 1 {}} 
cd [workingDirectory]

set current [pwd]
test tcltest-8.14 {testsDirectory} {
    -setup {
	set old $::tcltest::testsDirectory
	set ::tcltest::testsDirectory $normaldirectory
    }
    -body {
	set f1 [testsDirectory]
	set f2 [testsDirectory $current]
	set f3 [testsDirectory]
	list $f1 $f2 $f3
    }
    -result "[list $normaldirectory $current $current]"
    -cleanup {
	set ::tcltest::testsDirectory $old
    }
}

# [workingDirectory]
test tcltest-8.60 {::workingDirectory}  {
    -setup {
	set old $::tcltest::workingDirectory
	set current [pwd]
	set ::tcltest::workingDirectory $normaldirectory
	cd $normaldirectory
    }
    -body {
	set f1 [workingDirectory]
	set f2 [pwd]
	set f3 [workingDirectory $current]
	set f4 [pwd] 
	set f5 [workingDirectory]
	list $f1 $f2 $f3 $f4 $f5
    }
    -result "[list $normaldirectory \
                   $normaldirectory \
                   $current \
                   $current \
                   $current]"
    -cleanup {
	set ::tcltest::workingDirectory $old
	cd $current
    }
}

# clean up from directory testing

d294 1
a294 1
	catch {file attributes $notWriteableDir -readonly 0}
d300 1
a300 1
# -file, -notfile, [matchFiles], [skipFiles]
d302 2
a303 1
    slave msg [file join [testsDirectory] all.tcl] -file a*.test
d307 3
a309 2
    slave msg [file join [testsDirectory] all.tcl] \
	    -file a*.test -notfile assocd*
a312 12
test tcltest-9.3 {matchFiles}  {
    -body {
	set old [matchFiles]
	matchFiles foo
	set current [matchFiles]
	matchFiles bar
	set new [matchFiles]
	matchFiles $old
	list $current $new
    } 
    -result {foo bar}
}
a313 12
test tcltest-9.4 {skipFiles} {
    -body {
	set old [skipFiles]
	skipFiles foo
	set current [skipFiles]
	skipFiles bar
	set new [skipFiles]
	skipFiles $old
	list $current $new
    } 
    -result {foo bar}
}
a314 1
# -preservecore, [preserveCore]
d317 2
a318 1
    namespace import ::tcltest::test
d327 1
a327 1
cd [temporaryDirectory]
d329 1
a329 1
    slave msg makecore.tcl -preservecore 0
d331 1
a331 1
    regexp "Core file produced" $msg
d334 1
a334 1
    slave msg makecore.tcl -preservecore 1
d336 1
a336 1
    regexp "Core file produced" $msg
d339 1
a339 1
    slave msg makecore.tcl -preservecore 2
d341 1
a341 1
    list [regexp "Core file produced" $msg] [regexp "Moving file to" $msg] \
d345 1
a345 1
    slave msg makecore.tcl -preservecore 3
d347 1
a347 1
    list [regexp "Core file produced" $msg] [regexp "Moving file to" $msg] \
d351 1
a351 16
# Removing this test.  It makes no sense to test the ability of
# [preserveCore] to accept an invalid value that will cause errors
# in other parts of tcltest's operation.
#test tcltest-10.5 {preserveCore} {
#    -body {
#	set old [preserveCore]
#	set result [preserveCore foo]
#	set result2 [preserveCore]
#	preserveCore $old
#	list $result $result2
#    }
#    -result {foo foo}
#}

# -load, -loadfile, [loadScript], [loadFile]
set contents { 
d353 2
a354 2
    namespace import tcltest::*
    puts [outputChannel] $::tcltest::loadScript
d356 1
a356 108
} 
set loadfile [makeFile $contents load.tcl]

test tcltest-12.1 {-load xxx} {unixOrPc} {
    slave msg load.tcl -load xxx
    set msg
} {xxx}

# Using child process because of -debug usage.
test tcltest-12.2 {-loadfile load.tcl} {unixOrPc} {
    catch {exec [interpreter] load.tcl -debug 2 -loadfile load.tcl} msg
    list \
	    [regexp {tcltest} [join [list $msg] [split $msg \n]]] \
	    [regexp {loadScript} [join [list $msg] [split $msg \n]]]
} {1 1}

test tcltest-12.3 {loadScript} {
    -setup {
	set old $::tcltest::loadScript
    }
    -body {
	set f1 [loadScript]
	set f2 [loadScript xxx]
	set f3 [loadScript]
	list $f1 $f2 $f3
    }
    -result {{} xxx xxx}
    -cleanup {
	set ::tcltest::loadScript $old
    }
}

test tcltest-12.4 {loadFile} {
    -setup {
	set olds $::tcltest::loadScript
	set oldf $::tcltest::loadFile
	set ::tcltest::loadFile {}
    }
    -body {
	set f1 [loadScript]
	set f2 [loadFile]
	set f3 [loadFile load.tcl]
	set f4 [loadScript]
	set f5 [loadFile]
	list $f1 $f2 $f3 $f4 $f5
    }
    -result "[list {} {} $loadfile $contents $loadfile]\n"
    -cleanup {
	set ::tcltest::loadScript $olds
	set ::tcltest::loadFile $oldf
    }
}

# [interpreter]
test tcltest-13.1 {interpreter} {
    -setup {
	set old $::tcltest::tcltest
	set ::tcltest::tcltest tcltest
    }
    -body {
	set f1 [interpreter]
	set f2 [interpreter tclsh]
	set f3 [interpreter]
	list $f1 $f2 $f3
    }
    -result {tcltest tclsh tclsh}
    -cleanup {
	set ::tcltest::tcltest $old
    }
}

# -singleproc, [singleProcess]
makeDirectory singleprocdir
makeFile {
    set foo 1
} [file join singleprocdir single1.test]

makeFile {
    unset foo
} [file join singleprocdir single2.test]

set allfile [makeFile {
    package require tcltest
    namespace import tcltest::*
    testsDirectory [file join [temporaryDirectory] singleprocdir]
    runAllTests
} [file join singleprocdir all-single.tcl]]
cd [workingDirectory]

test tcltest-14.1 {-singleproc - single process} {
    -constraints {unixOrPc}
    -body {
	slave msg $allfile -singleproc 0 -tmpdir [temporaryDirectory]
	set msg
    }
    -result {Test file error: can't unset .foo.: no such variable}
    -match regexp
}

test tcltest-14.2 {-singleproc - multiple process} {
    -constraints {unixOrPc}
    -body {
	slave msg $allfile -singleproc 1 -tmpdir [temporaryDirectory]
	set msg
    }
    -result {single1.test.*single2.test.*all\-single.tcl:.*Total.*0.*Passed.*0.*Skipped.*0.*Failed.*0}
    -match regexp
}
d358 5
a362 16
test tcltest-14.3 {singleProcess} {
    -setup {
	set old $::tcltest::singleProcess
	set ::tcltest::singleProcess 0
    }
    -body {
	set f1 [singleProcess]
	set f2 [singleProcess 1]
	set f3 [singleProcess]
	list $f1 $f2 $f3
    }
    -result {0 1 1}
    -cleanup {
	set ::tcltest::singleProcess $old
    }
}
d364 4
a367 1
# -asidefromdir, -relateddir, [matchDirectories], [skipDirectories]
d369 4
a372 2
# Before running these tests, need to set up test subdirectories with their own
# all.tcl files.
d374 1
a374 4
makeDirectory dirtestdir
makeDirectory [file join dirtestdir dirtestdir2.1]
makeDirectory [file join dirtestdir dirtestdir2.2]
makeDirectory [file join dirtestdir dirtestdir2.3]
d377 4
a380 36
    namespace import -force tcltest::*
    testsDirectory [file join [temporaryDirectory] dirtestdir]
    runAllTests
} [file join dirtestdir all.tcl]
makeFile {
    package require tcltest
    namespace import -force tcltest::*
    testsDirectory [file join [temporaryDirectory] dirtestdir dirtestdir2.1]
    runAllTests
} [file join dirtestdir dirtestdir2.1 all.tcl]
makeFile {
    package require tcltest
    namespace import -force tcltest::*
    testsDirectory [file join [temporaryDirectory]  dirtestdir dirtestdir2.2]
    runAllTests
} [file join dirtestdir dirtestdir2.2 all.tcl]
makeFile {
    package require tcltest
    namespace import -force tcltest::*
    testsDirectory [file join [temporaryDirectory] dirtestdir dirtestdir2.3]
    runAllTests
} [file join dirtestdir dirtestdir2.3 all.tcl]

test tcltest-15.1 {basic directory walking} {
    -constraints {unixOrPc}
    -body {
	if {[slave msg \
		[file join [temporaryDirectory] dirtestdir all.tcl] \
		-tmpdir [temporaryDirectory]] == 1} {
	    error $msg
	}
    }
    -match regexp
    -returnCodes 1
    -result {Tests located in:.*dirtestdir.*Tests located in:.*dirtestdir2.1.*Tests located in:.*dirtestdir2.2.*Tests located in:.*dirtestdir2.3}
}
d382 4
a385 17
test tcltest-15.2 {-asidefromdir} {
    -constraints {unixOrPc}
    -body {
	if {[slave msg \
		[file join [temporaryDirectory] dirtestdir all.tcl] \
		-asidefromdir dirtestdir2.3 \
		-tmpdir [temporaryDirectory]] == 1} {
	    error $msg
	}
    }
    -match regexp
    -returnCodes 1
    -result {Tests located in:.*dirtestdir.*Tests located in:.*dirtestdir2.1.*Tests located in:.*dirtestdir2.2.*dirtestdir2.2 test ended at .*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Error:  No test files remain after applying your match and skip patterns!
Error:  No test files remain after applying your match and skip patterns!
Error:  No test files remain after applying your match and skip patterns!$}
}
d387 6
a392 111
test tcltest-15.3 {-relateddir, non-existent dir} {
    -constraints {unixOrPc}
    -body {
	if {[slave msg \
		[file join [temporaryDirectory] dirtestdir all.tcl] \
		-relateddir [file join [temporaryDirectory] dirtestdir0] \
		-tmpdir [temporaryDirectory]] == 1} {
	    error $msg
	}
    }
    -returnCodes 1
    -match regexp
    -result {[^~]|dirtestdir[^2]}
}

test tcltest-15.4 {-relateddir, subdir} {
    -constraints {unixOrPc}
    -body {
	if {[slave msg \
		[file join [temporaryDirectory] dirtestdir all.tcl] \
		-relateddir dirtestdir2.1 -tmpdir [temporaryDirectory]] == 1} {
	    error $msg
	}
    }
    -returnCodes 1
    -match regexp
    -result {Tests located in:.*dirtestdir2.[^23]}
}
test tcltest-15.5 {-relateddir, -asidefromdir} {
    -constraints {unixOrPc}
    -body {
	if {[slave msg \
		[file join [temporaryDirectory] dirtestdir all.tcl] \
		-relateddir "dirtestdir2.1 dirtestdir2.2" \
		-asidefromdir dirtestdir2.2 \
		-tmpdir [temporaryDirectory]] == 1} {
	    error $msg
	}
    }
    -match regexp
    -returnCodes 1
    -result {Tests located in:.*dirtestdir2.[^23]}
}

test tcltest-15.6 {matchDirectories} {
    -setup {
	set old [matchDirectories]
	set ::tcltest::matchDirectories {}
    }
    -body {
	set r1 [matchDirectories]
	set r2 [matchDirectories foo]
	set r3 [matchDirectories]
	list $r1 $r2 $r3
    }
    -cleanup {
	set ::tcltest::matchDirectories $old
    }
    -result {{} foo foo}
}

test tcltest-15.7 {skipDirectories} {
    -setup {
	set old [skipDirectories]
	set ::tcltest::skipDirectories {}
    }
    -body {
	set r1 [skipDirectories]
	set r2 [skipDirectories foo]
	set r3 [skipDirectories]
	list $r1 $r2 $r3
    }
    -cleanup {
	set ::tcltest::skipDirectories $old
    }
    -result {{} foo foo}
}

# TCLTEST_OPTIONS
test tcltest-19.1 {TCLTEST_OPTIONS default} {
    -constraints {unixOrPc singleTestInterp}
    -setup {
	if {[info exists ::env(TCLTEST_OPTIONS)]} {
	    set oldoptions $::env(TCLTEST_OPTIONS)
	    unset ::env(TCLTEST_OPTIONS)
	} else {
	    set oldoptions none
	}
	# set this to { } instead of just {} to get around quirk in
	# Windows env handling that removes empty elements from env array.
	set ::env(TCLTEST_OPTIONS) { }
	set olddebug [debug]
	debug 2
    }
    -cleanup {
	if {$oldoptions == "none"} {
	    unset ::env(TCLTEST_OPTIONS) 
	} else {
	    set ::env(TCLTEST_OPTIONS) $oldoptions
	}
	debug $olddebug
    }
    -body {
	::tcltest::ProcessCmdLineArgs
	set ::env(TCLTEST_OPTIONS) "-debug 3"
	::tcltest::ProcessCmdLineArgs
    }
    -result {^$}
    -match regexp
    -output {tcltest::debug\s+= 2.*tcltest::debug\s+= 3}
}
a395 1
cd [temporaryDirectory]
d398 1
a398 1
    set result [slave msg printerror.tcl]
a402 1
cd [workingDirectory]
d404 3
a406 17
# test::test
test tcltest-21.0 {name and desc but no args specified} -setup {
    set v [verbose]
} -cleanup {
    verbose $v
} -body {
   verbose {}
   test tcltest-21.0.0 bar
} -result {}

test tcltest-21.1 {expect with glob} {
    -body {
	list a b c d e
    }
    -match glob
    -result {[ab] b c d e}
}
a407 590
test tcltest-21.2 {force a test command failure} {
    -body {
	test tcltest-21.2.0 {
	    return 2
	} {1}
    }
    -returnCodes 1
    -result {bad option "1": must be -body, -cleanup, -constraints, -errorOutput, -match, -output, -result, -returnCodes, or -setup}
}

test tcltest-21.3 {test command with setup} {
    -setup {
	set foo 1
    }
    -body {
	set foo
    }
    -cleanup {unset foo}
    -result {1}
}

test tcltest-21.4 {test command with cleanup failure} {
    -setup {
	if {[info exists foo]} {
	    unset foo
	}
	set fail $::tcltest::currentFailure
	set v [verbose]
    }
    -body {
	verbose {}
	test tcltest-21.4.0 {foo-1} {
	    -cleanup {unset foo}
	}
    }
    -result {^$}
    -match regexp
    -cleanup {verbose $v; set ::tcltest::currentFailure $fail}
    -output "Test cleanup failed:.*can't unset \"foo\": no such variable"
}

test tcltest-21.5 {test command with setup failure} {
    -setup {
	if {[info exists foo]} {
	    unset foo
	}
	set fail $::tcltest::currentFailure
    }
    -body {
	test tcltest-21.5.0 {foo-2} {
	    -setup {unset foo}
	}
    }
    -result {^$}
    -match regexp
    -cleanup {set ::tcltest::currentFailure $fail}
    -output "Test setup failed:.*can't unset \"foo\": no such variable"
}

test tcltest-21.6 {test command - setup occurs before cleanup & before script} {
    -setup {set v [verbose]; set fail $::tcltest::currentFailure}
    -body {
	verbose {}
	test tcltest-21.6.0 {foo-3} {
	    -setup {
		if {[info exists foo]} {
		    unset foo
		}
		set foo 1
		set expected 2
	    } 
	    -body {
		incr foo
		set foo
	    }
	    -cleanup {
		if {$foo != 2} {
		    puts [outputChannel] "foo is wrong"
		} else {
		    puts [outputChannel] "foo is 2"
		}
	    }
	    -result {$expected}
	}
    }
    -cleanup {verbose $v; set ::tcltest::currentFailure $fail}
    -result {^$}
    -match regexp
    -output "foo is 2"
}

test tcltest-21.7 {test command - bad flag} {
    -setup {set fail $::tcltest::currentFailure}
    -cleanup {set ::tcltest::currentFailure $fail}
    -body {
	test tcltest-21.7.0 {foo-4} {
	    -foobar {}
	}
    }
    -returnCodes 1
    -result {bad option "-foobar": must be -body, -cleanup, -constraints, -errorOutput, -match, -output, -result, -returnCodes, or -setup}
}

# alternate test command format (these are the same as 21.1-21.6, with the
# exception of being in the all-inline format)

test tcltest-21.7a {expect with glob} \
	-body {list a b c d e} \
	-result {[ab] b c d e} \
	-match glob

test tcltest-21.8 {force a test command failure} \
    -setup {set fail $::tcltest::currentFailure} \
    -body {
        test tcltest-21.8.0 {
            return 2
        } {1}
    } \
    -returnCodes 1 \
    -cleanup {set ::tcltest::currentFailure $fail} \
    -result {bad option "1": must be -body, -cleanup, -constraints, -errorOutput, -match, -output, -result, -returnCodes, or -setup}

test tcltest-21.9 {test command with setup} \
	-setup {set foo 1} \
	-body {set foo} \
	-cleanup {unset foo} \
	-result {1}

test tcltest-21.10 {test command with cleanup failure} -setup {
    if {[info exists foo]} {
	unset foo
    }
    set fail $::tcltest::currentFailure
    set v [verbose]
} -cleanup {
    verbose $v
    set ::tcltest::currentFailure $fail
} -body {
    verbose {}
    test tcltest-21.10.0 {foo-1} -cleanup {unset foo}
} -result {^$} -match regexp \
	-output {Test cleanup failed:.*can't unset \"foo\": no such variable}

test tcltest-21.11 {test command with setup failure} -setup {
    if {[info exists foo]} {
	unset foo
    }
    set fail $::tcltest::currentFailure
} -cleanup {set ::tcltest::currentFailure $fail} -body {
    test tcltest-21.11.0 {foo-2} -setup {unset foo}
} -result {^$} -output {Test setup failed:.*can't unset \"foo\": no such variable} -match regexp

test tcltest-21.12 {
	test command - setup occurs before cleanup & before script
} -setup {
	set fail $::tcltest::currentFailure
	set v [verbose]
} -cleanup {
	verbose $v
	set ::tcltest::currentFailure $fail
} -body {
    verbose {}
    test tcltest-21.12.0 {foo-3} -setup {
	if {[info exists foo]} {
	    unset foo
	}
	set foo 1
	set expected 2
    }  -body {
	incr foo
	set foo
    }  -cleanup {
	if {$foo != 2} {
	    puts [outputChannel] "foo is wrong"
	} else {
	    puts [outputChannel] "foo is 2"
	}
    }  -result {$expected}
} -result {^$} -output {foo is 2} -match regexp

# test all.tcl usage (runAllTests); simulate .test file failure, as well as
# crashes to determine whether or not these errors are logged.

makeDirectory alltestdir
makeFile {
    package require tcltest
    namespace import -force tcltest::*
    testsDirectory [file join [temporaryDirectory] alltestdir]
    runAllTests
} [file join alltestdir all.tcl]
makeFile {
    exit 1
} [file join alltestdir exit.test]
makeFile {
    error "throw an error"
} [file join alltestdir error.test]
makeFile {
    package require tcltest
    namespace import -force tcltest::*
    test foo-1.1 {foo} {
	-body { return 1 }
	-result {1}
    }
    cleanupTests
} [file join alltestdir test.test]

# Must use a child process because stdout/stderr parsing can't be
# duplicated in slave interp.
test tcltest-22.1 {runAllTests} {
    -constraints {unixOrPc}
    -body {
	exec [interpreter] \
		[file join [temporaryDirectory] alltestdir all.tcl] \
		-verbose t -tmpdir [temporaryDirectory]
    }
    -match regexp
    -result "Test files exiting with errors:.*error.test.*exit.test"
}

# makeFile, removeFile, makeDirectory, removeDirectory, viewFile
test tcltest-23.1 {makeFile} {
    -setup {
	set mfdir [file join [temporaryDirectory] mfdir]
	file mkdir $mfdir
    }
    -body {
	makeFile {} t1.tmp
	makeFile {} et1.tmp $mfdir
	list [file exists [file join [temporaryDirectory] t1.tmp]] \
		[file exists [file join $mfdir et1.tmp]]
    }
    -cleanup {
	file delete -force $mfdir \
		[file join [temporaryDirectory] t1.tmp] 
    }
    -result {1 1}
}
test tcltest-23.2 {removeFile} {
    -setup {
	set mfdir [file join [temporaryDirectory] mfdir]
	file mkdir $mfdir
	makeFile {} t1.tmp
	makeFile {} et1.tmp $mfdir
	if  {![file exists [file join [temporaryDirectory] t1.tmp]] || \
		![file exists [file join $mfdir et1.tmp]]} {
	    error "file creation didn't work"
	}
    }
    -body {
	removeFile t1.tmp
	removeFile et1.tmp $mfdir
	list [file exists [file join [temporaryDirectory] t1.tmp]] \
		[file exists [file join $mfdir et1.tmp]]
    }
    -cleanup {
	file delete -force $mfdir \
		[file join [temporaryDirectory] t1.tmp] 
    }
    -result {0 0}
}
test tcltest-23.3 {makeDirectory} {
    -body {
	set mfdir [file join [temporaryDirectory] mfdir]
	file mkdir $mfdir
	makeDirectory d1
	makeDirectory d2 $mfdir
	list [file exists [file join [temporaryDirectory] d1]] \
		[file exists [file join $mfdir d2]]
    }
    -cleanup {
	file delete -force [file join [temporaryDirectory] d1] $mfdir
    }
    -result {1 1}
}
test tcltest-23.4 {removeDirectory} {
    -body {
	set mfdir [file join [temporaryDirectory] mfdir]
	file mkdir $mfdir
	file mkdir [file join [temporaryDirectory] t1]
	file mkdir [file join [temporaryDirectory] $mfdir t2]
	if {![file exists $mfdir] || \
		![file exists [file join [temporaryDirectory] $mfdir t2]]} {
	    return "setup failed - directory not created"
	}
	removeDirectory t1
	removeDirectory t2 $mfdir
	list [file exists [file join [temporaryDirectory] t1]] \
		[file exists [file join $mfdir t2]]
    }
    -result {0 0}
}
test tcltest-23.5 {viewFile} {
    -body {
	set mfdir [file join [temporaryDirectory] mfdir]
	file mkdir $mfdir
	makeFile {foobar} t1.tmp
	makeFile {foobarbaz} t2.tmp $mfdir
	list [viewFile t1.tmp] [viewFile t2.tmp $mfdir]
    }
    -result {foobar foobarbaz}
    -cleanup {
	file delete -force $mfdir
    }
}

# customMatch
proc matchNegative { expected actual } {
   set match 0
   foreach a $actual e $expected {
      if { $a != $e } {
         set match 1
        break
      }
   }
   return $match
}

test tcltest-24.0 {
	customMatch: syntax
} -body {
	list [catch {customMatch} result] $result
} -result [list 1 "wrong # args: should be \"customMatch mode script\""]

test tcltest-24.1 {
	customMatch: syntax
} -body {
	list [catch {customMatch foo} result] $result
} -result [list 1 "wrong # args: should be \"customMatch mode script\""]

test tcltest-24.2 {
	customMatch: syntax
} -body {
	list [catch {customMatch foo bar baz} result] $result
} -result [list 1 "wrong # args: should be \"customMatch mode script\""]

test tcltest-24.3 {
	customMatch: argument checking
} -body {
	list [catch {customMatch bad "a \{ b"} result] $result
} -result [list 1 "invalid customMatch script; can't evaluate after completion"]

test tcltest-24.4 {
	test: valid -match values
} -body {
	list [catch {
		test tcltest-24.4.0 {} \
			-match [namespace current]::noSuchMode
	} result] $result
} -match glob -result {1 *bad -match value*}

test tcltest-24.5 {
	test: valid -match values
} -setup {
	customMatch [namespace current]::alwaysMatch "format 1 ;#"
} -body {
	list [catch {
		test tcltest-24.5.0 {} \
			-match [namespace current]::noSuchMode
	} result] $result
} -match glob -result {1 *bad -match value*: must be *alwaysMatch,*}

test tcltest-24.6 {
	customMatch: -match script that always matches
} -setup {
	customMatch [namespace current]::alwaysMatch "format 1 ;#"
	set v [verbose]
} -body {
	verbose {}
	test tcltest-24.6.0 {} -match [namespace current]::alwaysMatch \
		-body {format 1} -result 0
} -cleanup {
	verbose $v
} -result {} -output {} -errorOutput {}

test tcltest-24.7 {
	customMatch: replace default -exact matching
} -setup {
	set saveExactMatchScript $::tcltest::CustomMatch(exact)
	customMatch exact "format 1 ;#"
	set v [verbose]
} -body {
	verbose {}
	test tcltest-24.7.0 {} -body {format 1} -result 0
} -cleanup {
	verbose $v
	customMatch exact $saveExactMatchScript
	unset saveExactMatchScript
} -result {} -output {}

test tcltest-24.9 {
	customMatch: error during match
} -setup {
	proc errorDuringMatch args {return -code error "match returned error"}
	customMatch [namespace current]::errorDuringMatch \
		[namespace code errorDuringMatch]
	set v [verbose]
	set fail $::tcltest::currentFailure
} -body {
	verbose {}
	test tcltest-24.9.0 {} -match [namespace current]::errorDuringMatch
} -cleanup {
	verbose $v
	set ::tcltest::currentFailure $fail
} -match glob -result {} -output {*FAILED*match returned error*}

test tcltest-24.10 {
	customMatch: bad return from match command
} -setup {
	proc nonBooleanReturn args {return foo}
	customMatch nonBooleanReturn [namespace code nonBooleanReturn]
	set v [verbose]
	set fail $::tcltest::currentFailure
} -body {
	verbose {}
	test tcltest-24.10.0 {} -match nonBooleanReturn
} -cleanup {
	verbose $v
	set ::tcltest::currentFailure $fail
} -match glob -result {} -output {*FAILED*expected boolean value*}

test tcltest-24.11 {
	test: -match exact
} -body {
	set result {A B C}
} -match exact -result {A B C}

test tcltest-24.12 {
	test: -match exact	match command eval in ::, not caller namespace
} -setup {
	set saveExactMatchScript $::tcltest::CustomMatch(exact)
	customMatch exact [list string equal]
	set v [verbose]
	proc string args {error {called [string] in caller namespace}}
} -body {
	verbose {}
	test tcltest-24.12.0 {} -body {format 1} -result 1
} -cleanup {
	rename string {}
	verbose $v
	customMatch exact $saveExactMatchScript
	unset saveExactMatchScript
} -match exact -result {} -output {}

test tcltest-24.13 {
	test: -match exact	failure
} -setup {
	set saveExactMatchScript $::tcltest::CustomMatch(exact)
	customMatch exact [list string equal]
	set v [verbose]
	set fail $::tcltest::currentFailure
} -body {
	verbose {}
	test tcltest-24.13.0 {} -body {format 1} -result 0
} -cleanup {
	set ::tcltest::currentFailure $fail
	verbose $v
	customMatch exact $saveExactMatchScript
	unset saveExactMatchScript
} -match glob -result {} -output {*FAILED*Result was:
1*(exact matching):
0*}

test tcltest-24.14 {
	test: -match glob
} -body {
	set result {A B C}
} -match glob -result {A B*}

test tcltest-24.15 {
	test: -match glob	failure
} -setup {
	set v [verbose]
	set fail $::tcltest::currentFailure
} -body {
	verbose {}
	test tcltest-24.15.0 {} -match glob -body {format {A B C}} \
		-result {A B* }
} -cleanup {
	set ::tcltest::currentFailure $fail
	verbose $v
} -match glob -result {} -output {*FAILED*Result was:
*(glob matching):
*}

test tcltest-24.16 {
	test: -match regexp
} -body {
	set result {A B C}
} -match regexp -result {A B.*}

test tcltest-24.17 {
	test: -match regexp	failure
} -setup {
	set fail $::tcltest::currentFailure
	set v [verbose]
} -body {
	verbose {}
	test tcltest-24.17.0 {} -match regexp -body {format {A B C}} \
		-result {A B.* X}
} -cleanup {
	set ::tcltest::currentFailure $fail
	verbose $v
} -match glob -result {} -output {*FAILED*Result was:
*(regexp matching):
*}

test tcltest-24.18 {
	test: -match custom	forget namespace qualification
} -setup {
	set fail $::tcltest::currentFailure
	set v [verbose]
	customMatch negative matchNegative
} -body {
	verbose {}
	test tcltest-24.18.0 {} -match negative -body {format {A B C}} \
		-result {A B X}
} -cleanup {
	set ::tcltest::currentFailure $fail
	verbose $v
} -match glob -result {} -output {*FAILED*Error testing result:*}

test tcltest-24.19 {
	test: -match custom
} -setup {
	set v [verbose]
	customMatch negative [namespace code matchNegative]
} -body {
	verbose {}
	test tcltest-24.19.0 {} -match negative -body {format {A B C}} \
		-result {A B X}
} -cleanup {
	verbose $v
} -match exact -result {} -output {}

test tcltest-24.20 {
	test: -match custom	failure
} -setup {
	set fail $::tcltest::currentFailure
	set v [verbose]
	customMatch negative [namespace code matchNegative]
} -body {
	verbose {}
	test tcltest-24.20.0 {} -match negative -body {format {A B C}} \
		-result {A B C}
} -cleanup {
	set ::tcltest::currentFailure $fail
	verbose $v
} -match glob -result {} -output {*FAILED*Result was:
*(negative matching):
*}

test tcltest-25.1 {
	constraint of setup/cleanup (Bug 589859)
} -setup {
	set foo 0
} -body {
	# Buggy tcltest will generate result of 2
	test tcltest-25.1.0 {} -constraints knownBug -setup {
	    incr foo
	} -body {
	    incr foo
	} -cleanup {
	    incr foo
	} -match glob -result *
	set foo
} -cleanup {
	unset foo
} -result 0

test tcltest-25.2 {
	puts -nonewline (Bug 612786)
} -body {
	puts -nonewline stdout bla
	puts -nonewline stdout bla
} -output {blabla}

test tcltest-25.3 {
	reported return code (Bug 611922)
} -body {
	# Buggy tcltest will generate result of 2
	test tcltest-25.3.0 {} -body {
	    error foo
	}
} -match glob -output {*generated error; Return code was: 1*}

cleanupTests
}

namespace delete ::tcltest::test
return
@


1.3.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@d1 5
d10 1
a10 2
# Copyright (c) 1998-1999 by Scriptics Corporation. 
# Copyright (c) 2000 by Ajuba Solutions
d13 1
a13 1
# RCS: @@(#) $Id: tcltest.test,v 1.34 2002/09/06 15:10:32 rmax Exp $
d15 3
a17 14
# Note that there are several places where the value of 
# tcltest::currentFailure is stored/reset in the -setup/-cleanup
# of a test that has a body that runs [test] that will fail.
# This is a workaround of using the same tcltest code that we are
# testing to run the test itself.  Ditto on things like [verbose].
#
# It would be better to have the -body of the tests run the tcltest
# commands in a slave interp so the [test] being tested would not
# interfere with the [test] doing the testing.  
#

if {[catch {package require tcltest 2.1}]} {
    puts stderr "Skipping tests in [info script].  tcltest 2.1 required."
    return
a19 4
namespace eval ::tcltest::test {

namespace import ::tcltest::*

d22 1
a22 1
    namespace import ::tcltest::test
d31 1
a31 4
    test d-1.0 {test d} {
	error "foo" foo 9
    } {}
    tcltest::cleanupTests
a34 2
cd [temporaryDirectory]
testConstraint exec [llength [info commands exec]]
d36 3
a38 3
# Child processes because -help [exit]s.
test tcltest-1.1 {tcltest -help} {exec} {
    set result [catch {exec [interpreter] test.tcl -help} msg]
d41 2
a42 2
test tcltest-1.2 {tcltest -help -something} {exec} {
    set result [catch {exec [interpreter] test.tcl -help -something} msg]
d45 2
a46 2
test tcltest-1.3 {tcltest -h} {exec} {
    set result [catch {exec [interpreter] test.tcl -h} msg]
d48 1
a48 1
} {1 0} 
d50 1
a50 37
# -verbose, implicit & explicit testing of [verbose]
proc slave {msgVar args} {
    upvar 1 $msgVar msg

    interp create [namespace current]::i
    # Fake the slave interp into dumping output to a file
    i eval {namespace eval ::tcltest {}}
    i eval "set tcltest::outputChannel \[open [makeFile {} output] w]"
    i eval "set tcltest::errorChannel \[open [makeFile {} error] w]"
    i eval [list set argv0 [lindex $args 0]]
    i eval [list set argv [lrange $args 1 end]]
    i eval [list package ifneeded tcltest [package provide tcltest] \
	    [package ifneeded tcltest [package provide tcltest]]]
    i eval {proc exit args {}}

    # Need to capture output in msg

    set code [catch {i eval {source $argv0}} foo]
if $code {
#puts "$code: $foo\n$::errorInfo"
}
    i eval {close $tcltest::outputChannel}
    interp delete [namespace current]::i
    set f [open [file join [temporaryDirectory] output]]
    set msg [read -nonewline $f]
    close $f
    set f [open [file join [temporaryDirectory] error]]
    set err [read -nonewline $f]
    close $f
    if {[string length $err]} {
	set code 1
	append msg \n$err
    }
    return $code

#    return [catch {uplevel 1 [linsert $args 0  exec [interpreter]]} msg]
}
d52 1
a52 1
    set result [slave msg test.tcl]
d55 1
a55 1
	    [regexp "Total.+4.+Passed.+1.+Skipped.+1.+Failed.+2" $msg]
d57 2
a58 2
test tcltest-2.1 {tcltest -verbose 'b'} {unixOrPc} {
    set result [slave msg test.tcl -verbose 'b']
d61 1
a61 1
	    [regexp "Total.+4.+Passed.+1.+Skipped.+1.+Failed.+2" $msg]
d63 2
a64 2
test tcltest-2.2 {tcltest -verbose 'p'} {unixOrPc} {
    set result [slave msg test.tcl -verbose 'p']
d67 1
a67 1
	    [regexp "Total.+4.+Passed.+1.+Skipped.+1.+Failed.+2" $msg]
d69 2
a70 2
test tcltest-2.3 {tcltest -verbose 's'} {unixOrPc} {
    set result [slave msg test.tcl -verbose 's']
d73 1
a73 1
	    [regexp "Total.+4.+Passed.+1.+Skipped.+1.+Failed.+2" $msg]
d75 2
a76 2
test tcltest-2.4 {tcltest -verbose 'ps'} {unixOrPc} {
    set result [slave msg test.tcl -verbose 'ps']
d79 1
a79 1
	    [regexp "Total.+4.+Passed.+1.+Skipped.+1.+Failed.+2" $msg]
d81 2
a82 2
test tcltest-2.5 {tcltest -verbose 'psb'} {unixOrPc} {
    set result [slave msg test.tcl -verbose 'psb']
d85 1
a85 1
	    [regexp "Total.+4.+Passed.+1.+Skipped.+1.+Failed.+2" $msg]
d88 1
a88 50
test tcltest-2.5a {tcltest -verbose 'pass skip body'} {unixOrPc} {
    set result [slave msg test.tcl -verbose "pass skip body"]
    list $result [regexp "Contents of test case" $msg] [regexp a-1.0 $msg] \
	    [regexp c-1.0 $msg] \
	    [regexp "Total.+4.+Passed.+1.+Skipped.+1.+Failed.+2" $msg]
} {0 1 1 1 1}

test tcltest-2.6 {tcltest -verbose 't'}  {
    -constraints {unixOrPc} 
    -body {
	set result [slave msg test.tcl -verbose 't']
	list $result $msg
    }
    -result {^0 .*a-1.0 start.*b-1.0 start}
    -match regexp
}

test tcltest-2.6a {tcltest -verbose 'start'}  {
    -constraints {unixOrPc} 
    -body {
	set result [slave msg test.tcl -verbose start]
	list $result $msg
    }
    -result {^0 .*a-1.0 start.*b-1.0 start}
    -match regexp
}

test tcltest-2.7 {tcltest::verbose}  {
    -body {
	set oldVerbosity [verbose]
	verbose bar
	set currentVerbosity [verbose]
	verbose foo
	set newVerbosity [verbose]
	verbose $oldVerbosity
	list $currentVerbosity $newVerbosity 
    }
    -result {body {}}
}

test tcltest-2.8 {tcltest -verbose 'error'} {
    -constraints {unixOrPc}
    -body {
	set result [slave msg test.tcl -verbose error]
	list $result $msg
    }
    -result {errorInfo: foo.*errorCode: 9}
    -match regexp
}
# -match, [match]
d90 1
a90 1
    set result [slave msg test.tcl -match a* -verbose 'ps']
d92 1
a92 1
	    [regexp "Total.+4.+Passed.+1.+Skipped.+3.+Failed.+0" $msg]
d95 1
a95 1
    set result [slave msg test.tcl -match b* -verbose 'ps']
d97 1
a97 1
	    [regexp "Total.+4.+Passed.+0.+Skipped.+3.+Failed.+1" $msg]
d100 1
a100 1
    set result [slave msg test.tcl -match c* -verbose 'ps']
d102 1
a102 1
	    [regexp "Total.+4.+Passed.+0.+Skipped.+4.+Failed.+0" $msg]
d105 1
a105 1
    set result [slave msg test.tcl -match {a* b*} -verbose 'ps']
d107 1
a107 1
	    [regexp "Total.+4.+Passed.+1.+Skipped.+2.+Failed.+1" $msg]
d110 1
a110 14
test tcltest-3.5 {tcltest::match}  {
    -body {
	set oldMatch [match]
	match foo
	set currentMatch [match]
	match bar
	set newMatch [match]
	match $oldMatch
	list $currentMatch $newMatch
    }
    -result {foo bar}
}
	
# -skip, [skip]
d112 1
a112 1
    set result [slave msg test.tcl -skip a* -verbose 'ps']
d114 1
a114 1
	    [regexp "Total.+4.+Passed.+0.+Skipped.+2.+Failed.+1" $msg]
d117 1
a117 1
    set result [slave msg test.tcl -skip b* -verbose 'ps']
d119 1
a119 1
	    [regexp "Total.+4.+Passed.+1.+Skipped.+2.+Failed.+1" $msg]
d122 1
a122 1
    set result [slave msg test.tcl -skip c* -verbose 'ps']
d124 1
a124 1
	    [regexp "Total.+4.+Passed.+1.+Skipped.+1.+Failed.+2" $msg]
d127 1
a127 1
    set result [slave msg test.tcl -skip {a* b*} -verbose 'ps']
d129 1
a129 1
	    [regexp "Total.+4.+Passed.+0.+Skipped.+3.+Failed.+1" $msg]
d132 1
a132 1
    set result [slave msg test.tcl -match {a* b*} -skip b* -verbose 'ps']
d134 1
a134 1
	    [regexp "Total.+4.+Passed.+1.+Skipped.+3.+Failed.+0" $msg]
d137 1
a137 15
test tcltest-4.6 {tcltest::skip} {
    -body {
	set oldSkip [skip]
	skip foo
	set currentSkip [skip]
	skip bar
	set newSkip [skip]
	skip $oldSkip
	list $currentSkip $newSkip
    }
    -result {foo bar}
}

# -constraints, -limitconstraints, [testConstraint],
# $constraintsSpecified, [limitConstraints]
d139 1
a139 1
    set result [slave msg test.tcl -constraints knownBug -verbose 'ps']
d141 1
a141 1
	    [regexp "Total.+4.+Passed.+2.+Skipped.+0.+Failed.+2" $msg]
d143 2
a144 2
test tcltest-5.2 {tcltest -constraints 'knownBug' -limitconstraints 1} {unixOrPc} {
    set result [slave msg test.tcl -constraints knownBug -verbose 'p' -limitconstraints 1]
d146 1
a146 1
	    [regexp "Total.+4.+Passed.+1.+Skipped.+3.+Failed.+0" $msg]
d149 1
a149 68
test tcltest-5.3 {testConstraint - constraint empty (tcltest::safeFetch)}  {
    -body {
	set r1 [testConstraint tcltestFakeConstraint]
	set r2 [testConstraint tcltestFakeConstraint 4]
	set r3 [testConstraint tcltestFakeConstraint]
	list $r1 $r2 $r3
    }
    -result {0 4 4}
    -cleanup {unset ::tcltest::testConstraints(tcltestFakeConstraint)}
}

# Removed this test of internals of tcltest.  Those internals have changed.
#test tcltest-5.4 {tcltest::constraintsSpecified} {
#    -setup {
#	set constraintlist $::tcltest::constraintsSpecified
#	set ::tcltest::constraintsSpecified {}
#    }
#    -body {
#	set r1 $::tcltest::constraintsSpecified
#	testConstraint tcltestFakeConstraint1 1
#	set r2 $::tcltest::constraintsSpecified
#	testConstraint tcltestFakeConstraint2 1
#	set r3 $::tcltest::constraintsSpecified
#	list $r1 $r2 $r3
#    }
#    -result {{} tcltestFakeConstraint1 {tcltestFakeConstraint1 tcltestFakeConstraint2}}
#    -cleanup {
#	set ::tcltest::constraintsSpecified $constraintlist
#	unset ::tcltest::testConstraints(tcltestFakeConstraint1) 
#	unset ::tcltest::testConstraints(tcltestFakeConstraint2) 
#    }
#}

test tcltest-5.5 {InitConstraints: list of built-in constraints} \
	-constraints {!singleTestInterp} \
	-setup {tcltest::InitConstraints} \
	-body { lsort [array names ::tcltest::testConstraints] } \
	-result [lsort {
    95 98 asyncPipeClose eformat emptyTest exec hasIsoLocale interactive
    knownBug mac macCrash macOnly macOrPc macOrUnix macOrWin nonBlockFiles
    nonPortable notRoot nt pc pcCrash pcOnly root singleTestInterp socket
    stdio tempNotMac tempNotPc tempNotUnix tempNotWin unix unixCrash unixExecs
    unixOnly unixOrPc unixOrWin userInteraction win winCrash winOnly
}]

# Removed this broken test.  Its usage of [limitConstraints] was not
# in agreement with the documentation.  [limitConstraints] is supposed
# to take an optional boolean argument, and "knownBug" ain't no boolean!
#test tcltest-5.6 {tcltest::limitConstraints} {
#    -setup {
#        set keeplc $::tcltest::limitConstraints
#        set keepkb [testConstraint knownBug]
#    }
#    -body {
#        set r1 [limitConstraints]
#        set r2 [limitConstraints knownBug]
#        set r3 [limitConstraints]
#        list $r1 $r2 $r3
#    }
#    -cleanup {
#        limitConstraints $keeplc
#        testConstraint knownBug $keepkb
#    }
#    -result {false knownBug knownBug}
#}

# -outfile, -errfile, [outputChannel], [outputFile], [errorChannel], [errorFile]
set printerror [makeFile {
d151 2
a152 2
    namespace import ::tcltest::*
    puts [outputChannel] "a test"
d162 1
a162 1
} printerror.tcl]
d164 7
a170 11
test tcltest-6.1 {tcltest -outfile, -errfile defaults} {
    -constraints unixOrPc
    -body {
	slave msg $printerror
	return $msg
    }
    -result {a test.*a really}
    -match regexp
}
test tcltest-6.2 {tcltest -outfile a.tmp} {unixOrPc unixExecs} {
    slave msg $printerror -outfile a.tmp
d176 2
a177 2
test tcltest-6.3 {tcltest -errfile a.tmp} {unixOrPc unixExecs} {
    slave msg $printerror -errfile a.tmp
d183 2
a184 2
test tcltest-6.4 {tcltest -outfile a.tmp -errfile b.tmp} {unixOrPc unixExecs} {
    slave msg printerror.tcl -outfile a.tmp -errfile b.tmp
d193 3
a195 77
test tcltest-6.5 {tcltest::errorChannel - retrieval} {
    -setup {
	set of [errorChannel]
	set ::tcltest::errorChannel stderr
    }
    -body {
	errorChannel
    }
    -result {stderr}
    -cleanup {
	set ::tcltest::errorChannel $of
    }
}

test tcltest-6.6 {tcltest::errorFile (implicit errorChannel)} {
    -setup {
	set ef [makeFile {} efile]
	set of [errorFile]
	set ::tcltest::errorChannel stderr
	set ::tcltest::errorFile stderr
    }
    -body {
	set f0 [errorChannel]
	set f1 [errorFile]
	set f2 [errorFile $ef]
	set f3 [errorChannel]
	set f4 [errorFile]
	subst {$f0;$f1;$f2;$f3;$f4} 
    }
    -result {stderr;stderr;.*efile;file[0-9a-f]+;.*efile}
    -match regexp
    -cleanup {
	errorFile $of
    }
}
test tcltest-6.7 {tcltest::outputChannel - retrieval} {
    -setup {
	set of [outputChannel]
	set ::tcltest::outputChannel stdout
    }
    -body {
	outputChannel
    }
    -result {stdout}
    -cleanup {
	set tcltest::outputChannel $of
    }
}

test tcltest-6.8 {tcltest::outputFile (implicit outputFile)} {
    -setup {
	set ef [makeFile {} efile]
	set of [outputFile]
	set ::tcltest::outputChannel stdout
	set ::tcltest::outputFile stdout
    }
    -body {
	set f0 [outputChannel]
	set f1 [outputFile]
	set f2 [outputFile $ef]
	set f3 [outputChannel]
	set f4 [outputFile]
	subst {$f0;$f1;$f2;$f3;$f4} 
    }
    -result {stdout;stdout;.*efile;file[0-9a-f]+;.*efile}
    -match regexp
    -cleanup {
	outputFile $of
    }
}

# -debug, [debug]
# Must use child processes to test -debug because it always writes
# messages to stdout, and we have no way to capture stdout of a
# slave interp
test tcltest-7.1 {tcltest test.tcl -debug 0} {unixOrPc} {
    catch {exec [interpreter] test.tcl -debug 0} msg
d198 2
a199 2
test tcltest-7.2 {tcltest test.tcl -debug 1} {unixOrPc} {
    catch {exec [interpreter] test.tcl -debug 1 -skip b*} msg
d203 2
a204 2
test tcltest-7.3 {tcltest test.tcl -debug 1} {unixOrPc} {
    catch {exec [interpreter] test.tcl -debug 1 -match b*} msg
d208 2
a209 2
test tcltest-7.4 {tcltest test.tcl -debug 2} {unixOrPc} {
    catch {exec [interpreter] test.tcl -debug 2} msg
d212 2
a213 2
test tcltest-7.5 {tcltest test.tcl -debug 3} {unixOrPc} {
    catch {exec [interpreter] test.tcl -debug 3} msg
a216 21
test tcltest-7.6 {tcltest::debug} {
    -setup {
	set old $::tcltest::debug
	set ::tcltest::debug 0
    }
    -body {
	set f1 [debug]
	set f2 [debug 1]
	set f3 [debug]
	set f4 [debug 2]
	set f5 [debug]
	list $f1 $f2 $f3 $f4 $f5
    }
    -result {0 1 1 2 2}
    -cleanup {
	set ::tcltest::debug $old
    }
}

# directory tests

d219 2
a220 2
    tcltest::makeFile {} a.tmp
    puts [tcltest::outputChannel] "testdir: [tcltest::testsDirectory]"
d224 1
a224 6
makeFile {} thisdirectoryisafile  

set normaldirectory [makeDirectory normaldirectory]
if {$::tcl_platform(platform) == "macintosh"} {
set normaldirectory [file normalize $normaldirectory]
}
d226 1
a226 1
# -tmpdir, [temporaryDirectory]
d229 1
a229 1
    slave msg a.tcl -tmpdir thisdirectorydoesnotexist
d233 5
a237 9
test tcltest-8.2 {tcltest a.tcl -tmpdir thisdirectoryisafile} {
    -constraints unixOrPc
    -body {
	slave msg a.tcl -tmpdir thisdirectoryisafile
	set msg
    }
    -result {*not a directory*}
    -match glob
}
d239 3
a241 3
# Test non-writeable directories, non-readable directories with directory flags
set notReadableDir [file join [temporaryDirectory] notreadable]
set notWriteableDir [file join [temporaryDirectory] notwriteable]
d243 2
a244 2
makeDirectory notreadable
makeDirectory notwriteable
d252 1
a252 1
	catch {file attributes $notWriteableDir -readonly 1}
d256 4
a259 3
test tcltest-8.3 {tcltest a.tcl -tmpdir notReadableDir} {unixOnly nonRoot} {
    slave msg a.tcl -tmpdir $notReadableDir 
    string match {*not readable*} $msg
d262 4
a265 3
test tcltest-8.4 {tcltest a.tcl -tmpdir notWriteableDir} {unixOrPc nonRoot} {
    slave msg a.tcl -tmpdir $notWriteableDir
    string match {*not writeable*} $msg
d268 2
a269 40
test tcltest-8.5 {tcltest a.tcl -tmpdir normaldirectory} {unixOrPc} {
    slave msg a.tcl -tmpdir $normaldirectory
    # The join is necessary because the message can be split on multiple lines
    list [file exists [file join $normaldirectory a.tmp]] \
	    [file delete [file join $normaldirectory a.tmp]] 
} {1 {}}   
cd [workingDirectory]

test tcltest-8.6 {temporaryDirectory}  {
    -setup {
	set old $::tcltest::temporaryDirectory
	set ::tcltest::temporaryDirectory $normaldirectory
    }
    -body {
	set f1 [temporaryDirectory]
	set f2 [temporaryDirectory [workingDirectory]]
	set f3 [temporaryDirectory]
	list $f1 $f2 $f3
    }
    -result "[list $normaldirectory [workingDirectory] [workingDirectory]]"
    -cleanup {
	set ::tcltest::temporaryDirectory $old
    }
}

test tcltest-8.6a {temporaryDirectory - test format 2} -setup {
    set old $::tcltest::temporaryDirectory
    set ::tcltest::temporaryDirectory $normaldirectory
} -body {
    set f1 [temporaryDirectory]
    set f2 [temporaryDirectory [workingDirectory]]
    set f3 [temporaryDirectory]
    list $f1 $f2 $f3
} -cleanup {
    set ::tcltest::temporaryDirectory $old
} -result [list $normaldirectory [workingDirectory] [workingDirectory]]

cd [temporaryDirectory]
# -testdir, [testsDirectory]
test tcltest-8.10 {tcltest a.tcl -testdir thisdirectorydoesnotexist} {unixOrPc} {
d271 2
a272 2
    slave msg a.tcl -testdir thisdirectorydoesnotexist
    string match "*does not exist*" $msg
d275 4
a278 3
test tcltest-8.11 {tcltest a.tcl -testdir thisdirectoryisafile} {unixOrPc} {
    slave msg a.tcl -testdir thisdirectoryisafile
    string match "*not a directory*" $msg 
d281 4
a284 3
test tcltest-8.12 {tcltest a.tcl -testdir notReadableDir} {unixOnly nonRoot} {
    slave msg a.tcl -testdir $notReadableDir 
    string match {*not readable*} $msg
a287 56
test tcltest-8.13 {tcltest a.tcl -testdir normaldirectory} {unixOrPc} {
    slave msg a.tcl -testdir $normaldirectory
    # The join is necessary because the message can be split on multiple lines
    list [string first "testdir: $normaldirectory" [join $msg]] \
	    [file exists [file join [temporaryDirectory] a.tmp]] \
	    [file delete [file join [temporaryDirectory] a.tmp]] 
} {0 1 {}} 
cd [workingDirectory]

set current [pwd]
test tcltest-8.14 {testsDirectory} {
    -setup {
	set old $::tcltest::testsDirectory
	set ::tcltest::testsDirectory $normaldirectory
    }
    -body {
	set f1 [testsDirectory]
	set f2 [testsDirectory $current]
	set f3 [testsDirectory]
	list $f1 $f2 $f3
    }
    -result "[list $normaldirectory $current $current]"
    -cleanup {
	set ::tcltest::testsDirectory $old
    }
}

# [workingDirectory]
test tcltest-8.60 {::workingDirectory}  {
    -setup {
	set old $::tcltest::workingDirectory
	set current [pwd]
	set ::tcltest::workingDirectory $normaldirectory
	cd $normaldirectory
    }
    -body {
	set f1 [workingDirectory]
	set f2 [pwd]
	set f3 [workingDirectory $current]
	set f4 [pwd] 
	set f5 [workingDirectory]
	list $f1 $f2 $f3 $f4 $f5
    }
    -result "[list $normaldirectory \
                   $normaldirectory \
                   $current \
                   $current \
                   $current]"
    -cleanup {
	set ::tcltest::workingDirectory $old
	cd $current
    }
}

# clean up from directory testing

d294 1
a294 1
	catch {file attributes $notWriteableDir -readonly 0}
d300 1
a300 1
# -file, -notfile, [matchFiles], [skipFiles]
d302 2
a303 1
    slave msg [file join [testsDirectory] all.tcl] -file a*.test
d307 3
a309 2
    slave msg [file join [testsDirectory] all.tcl] \
	    -file a*.test -notfile assocd*
a312 12
test tcltest-9.3 {matchFiles}  {
    -body {
	set old [matchFiles]
	matchFiles foo
	set current [matchFiles]
	matchFiles bar
	set new [matchFiles]
	matchFiles $old
	list $current $new
    } 
    -result {foo bar}
}
a313 12
test tcltest-9.4 {skipFiles} {
    -body {
	set old [skipFiles]
	skipFiles foo
	set current [skipFiles]
	skipFiles bar
	set new [skipFiles]
	skipFiles $old
	list $current $new
    } 
    -result {foo bar}
}
a314 1
# -preservecore, [preserveCore]
d317 2
a318 1
    namespace import ::tcltest::test
d327 1
a327 1
cd [temporaryDirectory]
d329 1
a329 1
    slave msg makecore.tcl -preservecore 0
d331 1
a331 1
    regexp "Core file produced" $msg
d334 1
a334 1
    slave msg makecore.tcl -preservecore 1
d336 1
a336 1
    regexp "Core file produced" $msg
d339 1
a339 1
    slave msg makecore.tcl -preservecore 2
d341 1
a341 1
    list [regexp "Core file produced" $msg] [regexp "Moving file to" $msg] \
d345 1
a345 1
    slave msg makecore.tcl -preservecore 3
d347 1
a347 1
    list [regexp "Core file produced" $msg] [regexp "Moving file to" $msg] \
d351 1
a351 16
# Removing this test.  It makes no sense to test the ability of
# [preserveCore] to accept an invalid value that will cause errors
# in other parts of tcltest's operation.
#test tcltest-10.5 {preserveCore} {
#    -body {
#	set old [preserveCore]
#	set result [preserveCore foo]
#	set result2 [preserveCore]
#	preserveCore $old
#	list $result $result2
#    }
#    -result {foo foo}
#}

# -load, -loadfile, [loadScript], [loadFile]
set contents { 
d353 2
a354 2
    namespace import tcltest::*
    puts [outputChannel] $::tcltest::loadScript
d356 1
a356 108
} 
set loadfile [makeFile $contents load.tcl]

test tcltest-12.1 {-load xxx} {unixOrPc} {
    slave msg load.tcl -load xxx
    set msg
} {xxx}

# Using child process because of -debug usage.
test tcltest-12.2 {-loadfile load.tcl} {unixOrPc} {
    catch {exec [interpreter] load.tcl -debug 2 -loadfile load.tcl} msg
    list \
	    [regexp {tcltest} [join [list $msg] [split $msg \n]]] \
	    [regexp {loadScript} [join [list $msg] [split $msg \n]]]
} {1 1}

test tcltest-12.3 {loadScript} {
    -setup {
	set old $::tcltest::loadScript
    }
    -body {
	set f1 [loadScript]
	set f2 [loadScript xxx]
	set f3 [loadScript]
	list $f1 $f2 $f3
    }
    -result {{} xxx xxx}
    -cleanup {
	set ::tcltest::loadScript $old
    }
}

test tcltest-12.4 {loadFile} {
    -setup {
	set olds $::tcltest::loadScript
	set oldf $::tcltest::loadFile
	set ::tcltest::loadFile {}
    }
    -body {
	set f1 [loadScript]
	set f2 [loadFile]
	set f3 [loadFile load.tcl]
	set f4 [loadScript]
	set f5 [loadFile]
	list $f1 $f2 $f3 $f4 $f5
    }
    -result "[list {} {} $loadfile $contents $loadfile]\n"
    -cleanup {
	set ::tcltest::loadScript $olds
	set ::tcltest::loadFile $oldf
    }
}

# [interpreter]
test tcltest-13.1 {interpreter} {
    -setup {
	set old $::tcltest::tcltest
	set ::tcltest::tcltest tcltest
    }
    -body {
	set f1 [interpreter]
	set f2 [interpreter tclsh]
	set f3 [interpreter]
	list $f1 $f2 $f3
    }
    -result {tcltest tclsh tclsh}
    -cleanup {
	set ::tcltest::tcltest $old
    }
}

# -singleproc, [singleProcess]
makeDirectory singleprocdir
makeFile {
    set foo 1
} [file join singleprocdir single1.test]

makeFile {
    unset foo
} [file join singleprocdir single2.test]

set allfile [makeFile {
    package require tcltest
    namespace import tcltest::*
    testsDirectory [file join [temporaryDirectory] singleprocdir]
    runAllTests
} [file join singleprocdir all-single.tcl]]
cd [workingDirectory]

test tcltest-14.1 {-singleproc - single process} {
    -constraints {unixOrPc}
    -body {
	slave msg $allfile -singleproc 0 -tmpdir [temporaryDirectory]
	set msg
    }
    -result {Test file error: can't unset .foo.: no such variable}
    -match regexp
}

test tcltest-14.2 {-singleproc - multiple process} {
    -constraints {unixOrPc}
    -body {
	slave msg $allfile -singleproc 1 -tmpdir [temporaryDirectory]
	set msg
    }
    -result {single1.test.*single2.test.*all\-single.tcl:.*Total.*0.*Passed.*0.*Skipped.*0.*Failed.*0}
    -match regexp
}
d358 5
a362 16
test tcltest-14.3 {singleProcess} {
    -setup {
	set old $::tcltest::singleProcess
	set ::tcltest::singleProcess 0
    }
    -body {
	set f1 [singleProcess]
	set f2 [singleProcess 1]
	set f3 [singleProcess]
	list $f1 $f2 $f3
    }
    -result {0 1 1}
    -cleanup {
	set ::tcltest::singleProcess $old
    }
}
d364 4
a367 1
# -asidefromdir, -relateddir, [matchDirectories], [skipDirectories]
d369 4
a372 2
# Before running these tests, need to set up test subdirectories with their own
# all.tcl files.
d374 1
a374 4
makeDirectory dirtestdir
makeDirectory [file join dirtestdir dirtestdir2.1]
makeDirectory [file join dirtestdir dirtestdir2.2]
makeDirectory [file join dirtestdir dirtestdir2.3]
d377 4
a380 36
    namespace import -force tcltest::*
    testsDirectory [file join [temporaryDirectory] dirtestdir]
    runAllTests
} [file join dirtestdir all.tcl]
makeFile {
    package require tcltest
    namespace import -force tcltest::*
    testsDirectory [file join [temporaryDirectory] dirtestdir dirtestdir2.1]
    runAllTests
} [file join dirtestdir dirtestdir2.1 all.tcl]
makeFile {
    package require tcltest
    namespace import -force tcltest::*
    testsDirectory [file join [temporaryDirectory]  dirtestdir dirtestdir2.2]
    runAllTests
} [file join dirtestdir dirtestdir2.2 all.tcl]
makeFile {
    package require tcltest
    namespace import -force tcltest::*
    testsDirectory [file join [temporaryDirectory] dirtestdir dirtestdir2.3]
    runAllTests
} [file join dirtestdir dirtestdir2.3 all.tcl]

test tcltest-15.1 {basic directory walking} {
    -constraints {unixOrPc}
    -body {
	if {[slave msg \
		[file join [temporaryDirectory] dirtestdir all.tcl] \
		-tmpdir [temporaryDirectory]] == 1} {
	    error $msg
	}
    }
    -match regexp
    -returnCodes 1
    -result {Tests located in:.*dirtestdir.*Tests located in:.*dirtestdir2.1.*Tests located in:.*dirtestdir2.2.*Tests located in:.*dirtestdir2.3}
}
d382 4
a385 17
test tcltest-15.2 {-asidefromdir} {
    -constraints {unixOrPc}
    -body {
	if {[slave msg \
		[file join [temporaryDirectory] dirtestdir all.tcl] \
		-asidefromdir dirtestdir2.3 \
		-tmpdir [temporaryDirectory]] == 1} {
	    error $msg
	}
    }
    -match regexp
    -returnCodes 1
    -result {Tests located in:.*dirtestdir.*Tests located in:.*dirtestdir2.1.*Tests located in:.*dirtestdir2.2.*dirtestdir2.2 test ended at .*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Error:  No test files remain after applying your match and skip patterns!
Error:  No test files remain after applying your match and skip patterns!
Error:  No test files remain after applying your match and skip patterns!$}
}
d387 6
a392 111
test tcltest-15.3 {-relateddir, non-existent dir} {
    -constraints {unixOrPc}
    -body {
	if {[slave msg \
		[file join [temporaryDirectory] dirtestdir all.tcl] \
		-relateddir [file join [temporaryDirectory] dirtestdir0] \
		-tmpdir [temporaryDirectory]] == 1} {
	    error $msg
	}
    }
    -returnCodes 1
    -match regexp
    -result {[^~]|dirtestdir[^2]}
}

test tcltest-15.4 {-relateddir, subdir} {
    -constraints {unixOrPc}
    -body {
	if {[slave msg \
		[file join [temporaryDirectory] dirtestdir all.tcl] \
		-relateddir dirtestdir2.1 -tmpdir [temporaryDirectory]] == 1} {
	    error $msg
	}
    }
    -returnCodes 1
    -match regexp
    -result {Tests located in:.*dirtestdir2.[^23]}
}
test tcltest-15.5 {-relateddir, -asidefromdir} {
    -constraints {unixOrPc}
    -body {
	if {[slave msg \
		[file join [temporaryDirectory] dirtestdir all.tcl] \
		-relateddir "dirtestdir2.1 dirtestdir2.2" \
		-asidefromdir dirtestdir2.2 \
		-tmpdir [temporaryDirectory]] == 1} {
	    error $msg
	}
    }
    -match regexp
    -returnCodes 1
    -result {Tests located in:.*dirtestdir2.[^23]}
}

test tcltest-15.6 {matchDirectories} {
    -setup {
	set old [matchDirectories]
	set ::tcltest::matchDirectories {}
    }
    -body {
	set r1 [matchDirectories]
	set r2 [matchDirectories foo]
	set r3 [matchDirectories]
	list $r1 $r2 $r3
    }
    -cleanup {
	set ::tcltest::matchDirectories $old
    }
    -result {{} foo foo}
}

test tcltest-15.7 {skipDirectories} {
    -setup {
	set old [skipDirectories]
	set ::tcltest::skipDirectories {}
    }
    -body {
	set r1 [skipDirectories]
	set r2 [skipDirectories foo]
	set r3 [skipDirectories]
	list $r1 $r2 $r3
    }
    -cleanup {
	set ::tcltest::skipDirectories $old
    }
    -result {{} foo foo}
}

# TCLTEST_OPTIONS
test tcltest-19.1 {TCLTEST_OPTIONS default} {
    -constraints {unixOrPc singleTestInterp}
    -setup {
	if {[info exists ::env(TCLTEST_OPTIONS)]} {
	    set oldoptions $::env(TCLTEST_OPTIONS)
	    unset ::env(TCLTEST_OPTIONS)
	} else {
	    set oldoptions none
	}
	# set this to { } instead of just {} to get around quirk in
	# Windows env handling that removes empty elements from env array.
	set ::env(TCLTEST_OPTIONS) { }
	set olddebug [debug]
	debug 2
    }
    -cleanup {
	if {$oldoptions == "none"} {
	    unset ::env(TCLTEST_OPTIONS) 
	} else {
	    set ::env(TCLTEST_OPTIONS) $oldoptions
	}
	debug $olddebug
    }
    -body {
	::tcltest::ProcessCmdLineArgs
	set ::env(TCLTEST_OPTIONS) "-debug 3"
	::tcltest::ProcessCmdLineArgs
    }
    -result {^$}
    -match regexp
    -output {tcltest::debug\s+= 2.*tcltest::debug\s+= 3}
}
a395 1
cd [temporaryDirectory]
d398 1
a398 1
    set result [slave msg printerror.tcl]
a402 1
cd [workingDirectory]
d404 3
a406 17
# test::test
test tcltest-21.0 {name and desc but no args specified} -setup {
    set v [verbose]
} -cleanup {
    verbose $v
} -body {
   verbose {}
   test tcltest-21.0.0 bar
} -result {}

test tcltest-21.1 {expect with glob} {
    -body {
	list a b c d e
    }
    -match glob
    -result {[ab] b c d e}
}
a407 574
test tcltest-21.2 {force a test command failure} {
    -body {
	test tcltest-21.2.0 {
	    return 2
	} {1}
    }
    -returnCodes 1
    -result {bad option "1": must be -body, -cleanup, -constraints, -errorOutput, -match, -output, -result, -returnCodes, or -setup}
}

test tcltest-21.3 {test command with setup} {
    -setup {
	set foo 1
    }
    -body {
	set foo
    }
    -cleanup {unset foo}
    -result {1}
}

test tcltest-21.4 {test command with cleanup failure} {
    -setup {
	if {[info exists foo]} {
	    unset foo
	}
	set fail $::tcltest::currentFailure
	set v [verbose]
    }
    -body {
	verbose {}
	test tcltest-21.4.0 {foo-1} {
	    -cleanup {unset foo}
	}
    }
    -result {^$}
    -match regexp
    -cleanup {verbose $v; set ::tcltest::currentFailure $fail}
    -output "Test cleanup failed:.*can't unset \"foo\": no such variable"
}

test tcltest-21.5 {test command with setup failure} {
    -setup {
	if {[info exists foo]} {
	    unset foo
	}
	set fail $::tcltest::currentFailure
    }
    -body {
	test tcltest-21.5.0 {foo-2} {
	    -setup {unset foo}
	}
    }
    -result {^$}
    -match regexp
    -cleanup {set ::tcltest::currentFailure $fail}
    -output "Test setup failed:.*can't unset \"foo\": no such variable"
}

test tcltest-21.6 {test command - setup occurs before cleanup & before script} {
    -setup {set v [verbose]; set fail $::tcltest::currentFailure}
    -body {
	verbose {}
	test tcltest-21.6.0 {foo-3} {
	    -setup {
		if {[info exists foo]} {
		    unset foo
		}
		set foo 1
		set expected 2
	    } 
	    -body {
		incr foo
		set foo
	    }
	    -cleanup {
		if {$foo != 2} {
		    puts [outputChannel] "foo is wrong"
		} else {
		    puts [outputChannel] "foo is 2"
		}
	    }
	    -result {$expected}
	}
    }
    -cleanup {verbose $v; set ::tcltest::currentFailure $fail}
    -result {^$}
    -match regexp
    -output "foo is 2"
}

test tcltest-21.7 {test command - bad flag} {
    -setup {set fail $::tcltest::currentFailure}
    -cleanup {set ::tcltest::currentFailure $fail}
    -body {
	test tcltest-21.7.0 {foo-4} {
	    -foobar {}
	}
    }
    -returnCodes 1
    -result {bad option "-foobar": must be -body, -cleanup, -constraints, -errorOutput, -match, -output, -result, -returnCodes, or -setup}
}

# alternate test command format (these are the same as 21.1-21.6, with the
# exception of being in the all-inline format)

test tcltest-21.7a {expect with glob} \
	-body {list a b c d e} \
	-result {[ab] b c d e} \
	-match glob

test tcltest-21.8 {force a test command failure} \
    -setup {set fail $::tcltest::currentFailure} \
    -body {
        test tcltest-21.8.0 {
            return 2
        } {1}
    } \
    -returnCodes 1 \
    -cleanup {set ::tcltest::currentFailure $fail} \
    -result {bad option "1": must be -body, -cleanup, -constraints, -errorOutput, -match, -output, -result, -returnCodes, or -setup}

test tcltest-21.9 {test command with setup} \
	-setup {set foo 1} \
	-body {set foo} \
	-cleanup {unset foo} \
	-result {1}

test tcltest-21.10 {test command with cleanup failure} -setup {
    if {[info exists foo]} {
	unset foo
    }
    set fail $::tcltest::currentFailure
    set v [verbose]
} -cleanup {
    verbose $v
    set ::tcltest::currentFailure $fail
} -body {
    verbose {}
    test tcltest-21.10.0 {foo-1} -cleanup {unset foo}
} -result {^$} -match regexp \
	-output {Test cleanup failed:.*can't unset \"foo\": no such variable}

test tcltest-21.11 {test command with setup failure} -setup {
    if {[info exists foo]} {
	unset foo
    }
    set fail $::tcltest::currentFailure
} -cleanup {set ::tcltest::currentFailure $fail} -body {
    test tcltest-21.11.0 {foo-2} -setup {unset foo}
} -result {^$} -output {Test setup failed:.*can't unset \"foo\": no such variable} -match regexp

test tcltest-21.12 {
	test command - setup occurs before cleanup & before script
} -setup {
	set fail $::tcltest::currentFailure
	set v [verbose]
} -cleanup {
	verbose $v
	set ::tcltest::currentFailure $fail
} -body {
    verbose {}
    test tcltest-21.12.0 {foo-3} -setup {
	if {[info exists foo]} {
	    unset foo
	}
	set foo 1
	set expected 2
    }  -body {
	incr foo
	set foo
    }  -cleanup {
	if {$foo != 2} {
	    puts [outputChannel] "foo is wrong"
	} else {
	    puts [outputChannel] "foo is 2"
	}
    }  -result {$expected}
} -result {^$} -output {foo is 2} -match regexp

# test all.tcl usage (runAllTests); simulate .test file failure, as well as
# crashes to determine whether or not these errors are logged.

makeDirectory alltestdir
makeFile {
    package require tcltest
    namespace import -force tcltest::*
    testsDirectory [file join [temporaryDirectory] alltestdir]
    runAllTests
} [file join alltestdir all.tcl]
makeFile {
    exit 1
} [file join alltestdir exit.test]
makeFile {
    error "throw an error"
} [file join alltestdir error.test]
makeFile {
    package require tcltest
    namespace import -force tcltest::*
    test foo-1.1 {foo} {
	-body { return 1 }
	-result {1}
    }
    cleanupTests
} [file join alltestdir test.test]

# Must use a child process because stdout/stderr parsing can't be
# duplicated in slave interp.
test tcltest-22.1 {runAllTests} {
    -constraints {unixOrPc}
    -body {
	exec [interpreter] \
		[file join [temporaryDirectory] alltestdir all.tcl] \
		-verbose t -tmpdir [temporaryDirectory]
    }
    -match regexp
    -result "Test files exiting with errors:.*error.test.*exit.test"
}

# makeFile, removeFile, makeDirectory, removeDirectory, viewFile
test tcltest-23.1 {makeFile} {
    -setup {
	set mfdir [file join [temporaryDirectory] mfdir]
	file mkdir $mfdir
    }
    -body {
	makeFile {} t1.tmp
	makeFile {} et1.tmp $mfdir
	list [file exists [file join [temporaryDirectory] t1.tmp]] \
		[file exists [file join $mfdir et1.tmp]]
    }
    -cleanup {
	file delete -force $mfdir \
		[file join [temporaryDirectory] t1.tmp] 
    }
    -result {1 1}
}
test tcltest-23.2 {removeFile} {
    -setup {
	set mfdir [file join [temporaryDirectory] mfdir]
	file mkdir $mfdir
	makeFile {} t1.tmp
	makeFile {} et1.tmp $mfdir
	if  {![file exists [file join [temporaryDirectory] t1.tmp]] || \
		![file exists [file join $mfdir et1.tmp]]} {
	    error "file creation didn't work"
	}
    }
    -body {
	removeFile t1.tmp
	removeFile et1.tmp $mfdir
	list [file exists [file join [temporaryDirectory] t1.tmp]] \
		[file exists [file join $mfdir et1.tmp]]
    }
    -cleanup {
	file delete -force $mfdir \
		[file join [temporaryDirectory] t1.tmp] 
    }
    -result {0 0}
}
test tcltest-23.3 {makeDirectory} {
    -body {
	set mfdir [file join [temporaryDirectory] mfdir]
	file mkdir $mfdir
	makeDirectory d1
	makeDirectory d2 $mfdir
	list [file exists [file join [temporaryDirectory] d1]] \
		[file exists [file join $mfdir d2]]
    }
    -cleanup {
	file delete -force [file join [temporaryDirectory] d1] $mfdir
    }
    -result {1 1}
}
test tcltest-23.4 {removeDirectory} {
    -body {
	set mfdir [file join [temporaryDirectory] mfdir]
	file mkdir $mfdir
	file mkdir [file join [temporaryDirectory] t1]
	file mkdir [file join [temporaryDirectory] $mfdir t2]
	if {![file exists $mfdir] || \
		![file exists [file join [temporaryDirectory] $mfdir t2]]} {
	    return "setup failed - directory not created"
	}
	removeDirectory t1
	removeDirectory t2 $mfdir
	list [file exists [file join [temporaryDirectory] t1]] \
		[file exists [file join $mfdir t2]]
    }
    -result {0 0}
}
test tcltest-23.5 {viewFile} {
    -body {
	set mfdir [file join [temporaryDirectory] mfdir]
	file mkdir $mfdir
	makeFile {foobar} t1.tmp
	makeFile {foobarbaz} t2.tmp $mfdir
	list [viewFile t1.tmp] [viewFile t2.tmp $mfdir]
    }
    -result {foobar foobarbaz}
    -cleanup {
	file delete -force $mfdir
    }
}

# customMatch
proc matchNegative { expected actual } {
   set match 0
   foreach a $actual e $expected {
      if { $a != $e } {
         set match 1
        break
      }
   }
   return $match
}

test tcltest-24.0 {
	customMatch: syntax
} -body {
	list [catch {customMatch} result] $result
} -result [list 1 "wrong # args: should be \"customMatch mode script\""]

test tcltest-24.1 {
	customMatch: syntax
} -body {
	list [catch {customMatch foo} result] $result
} -result [list 1 "wrong # args: should be \"customMatch mode script\""]

test tcltest-24.2 {
	customMatch: syntax
} -body {
	list [catch {customMatch foo bar baz} result] $result
} -result [list 1 "wrong # args: should be \"customMatch mode script\""]

test tcltest-24.3 {
	customMatch: argument checking
} -body {
	list [catch {customMatch bad "a \{ b"} result] $result
} -result [list 1 "invalid customMatch script; can't evaluate after completion"]

test tcltest-24.4 {
	test: valid -match values
} -body {
	list [catch {
		test tcltest-24.4.0 {} \
			-match [namespace current]::noSuchMode
	} result] $result
} -match glob -result {1 *bad -match value*}

test tcltest-24.5 {
	test: valid -match values
} -setup {
	customMatch [namespace current]::alwaysMatch "format 1 ;#"
} -body {
	list [catch {
		test tcltest-24.5.0 {} \
			-match [namespace current]::noSuchMode
	} result] $result
} -match glob -result {1 *bad -match value*: must be *alwaysMatch,*}

test tcltest-24.6 {
	customMatch: -match script that always matches
} -setup {
	customMatch [namespace current]::alwaysMatch "format 1 ;#"
	set v [verbose]
} -body {
	verbose {}
	test tcltest-24.6.0 {} -match [namespace current]::alwaysMatch \
		-body {format 1} -result 0
} -cleanup {
	verbose $v
} -result {} -output {} -errorOutput {}

test tcltest-24.7 {
	customMatch: replace default -exact matching
} -setup {
	set saveExactMatchScript $::tcltest::CustomMatch(exact)
	customMatch exact "format 1 ;#"
	set v [verbose]
} -body {
	verbose {}
	test tcltest-24.7.0 {} -body {format 1} -result 0
} -cleanup {
	verbose $v
	customMatch exact $saveExactMatchScript
	unset saveExactMatchScript
} -result {} -output {}

test tcltest-24.9 {
	customMatch: error during match
} -setup {
	proc errorDuringMatch args {return -code error "match returned error"}
	customMatch [namespace current]::errorDuringMatch \
		[namespace code errorDuringMatch]
	set v [verbose]
	set fail $::tcltest::currentFailure
} -body {
	verbose {}
	test tcltest-24.9.0 {} -match [namespace current]::errorDuringMatch
} -cleanup {
	verbose $v
	set ::tcltest::currentFailure $fail
} -match glob -result {} -output {*FAILED*match returned error*}

test tcltest-24.10 {
	customMatch: bad return from match command
} -setup {
	proc nonBooleanReturn args {return foo}
	customMatch nonBooleanReturn [namespace code nonBooleanReturn]
	set v [verbose]
	set fail $::tcltest::currentFailure
} -body {
	verbose {}
	test tcltest-24.10.0 {} -match nonBooleanReturn
} -cleanup {
	verbose $v
	set ::tcltest::currentFailure $fail
} -match glob -result {} -output {*FAILED*expected boolean value*}

test tcltest-24.11 {
	test: -match exact
} -body {
	set result {A B C}
} -match exact -result {A B C}

test tcltest-24.12 {
	test: -match exact	match command eval in ::, not caller namespace
} -setup {
	set saveExactMatchScript $::tcltest::CustomMatch(exact)
	customMatch exact [list string equal]
	set v [verbose]
	proc string args {error {called [string] in caller namespace}}
} -body {
	verbose {}
	test tcltest-24.12.0 {} -body {format 1} -result 1
} -cleanup {
	rename string {}
	verbose $v
	customMatch exact $saveExactMatchScript
	unset saveExactMatchScript
} -match exact -result {} -output {}

test tcltest-24.13 {
	test: -match exact	failure
} -setup {
	set saveExactMatchScript $::tcltest::CustomMatch(exact)
	customMatch exact [list string equal]
	set v [verbose]
	set fail $::tcltest::currentFailure
} -body {
	verbose {}
	test tcltest-24.13.0 {} -body {format 1} -result 0
} -cleanup {
	set ::tcltest::currentFailure $fail
	verbose $v
	customMatch exact $saveExactMatchScript
	unset saveExactMatchScript
} -match glob -result {} -output {*FAILED*Result was:
1*(exact matching):
0*}

test tcltest-24.14 {
	test: -match glob
} -body {
	set result {A B C}
} -match glob -result {A B*}

test tcltest-24.15 {
	test: -match glob	failure
} -setup {
	set v [verbose]
	set fail $::tcltest::currentFailure
} -body {
	verbose {}
	test tcltest-24.15.0 {} -match glob -body {format {A B C}} \
		-result {A B* }
} -cleanup {
	set ::tcltest::currentFailure $fail
	verbose $v
} -match glob -result {} -output {*FAILED*Result was:
*(glob matching):
*}

test tcltest-24.16 {
	test: -match regexp
} -body {
	set result {A B C}
} -match regexp -result {A B.*}

test tcltest-24.17 {
	test: -match regexp	failure
} -setup {
	set fail $::tcltest::currentFailure
	set v [verbose]
} -body {
	verbose {}
	test tcltest-24.17.0 {} -match regexp -body {format {A B C}} \
		-result {A B.* X}
} -cleanup {
	set ::tcltest::currentFailure $fail
	verbose $v
} -match glob -result {} -output {*FAILED*Result was:
*(regexp matching):
*}

test tcltest-24.18 {
	test: -match custom	forget namespace qualification
} -setup {
	set fail $::tcltest::currentFailure
	set v [verbose]
	customMatch negative matchNegative
} -body {
	verbose {}
	test tcltest-24.18.0 {} -match negative -body {format {A B C}} \
		-result {A B X}
} -cleanup {
	set ::tcltest::currentFailure $fail
	verbose $v
} -match glob -result {} -output {*FAILED*Error testing result:*}

test tcltest-24.19 {
	test: -match custom
} -setup {
	set v [verbose]
	customMatch negative [namespace code matchNegative]
} -body {
	verbose {}
	test tcltest-24.19.0 {} -match negative -body {format {A B C}} \
		-result {A B X}
} -cleanup {
	verbose $v
} -match exact -result {} -output {}

test tcltest-24.20 {
	test: -match custom	failure
} -setup {
	set fail $::tcltest::currentFailure
	set v [verbose]
	customMatch negative [namespace code matchNegative]
} -body {
	verbose {}
	test tcltest-24.20.0 {} -match negative -body {format {A B C}} \
		-result {A B C}
} -cleanup {
	set ::tcltest::currentFailure $fail
	verbose $v
} -match glob -result {} -output {*FAILED*Result was:
*(negative matching):
*}

test tcltest-25.1 {
	constraint of setup/cleanup (Bug 589859)
} -setup {
	set foo 0
} -body {
	# Buggy tcltest will generate result of 2
	test tcltest-25.1.0 {} -constraints knownBug -setup {
	    incr foo
	} -body {
	    incr foo
	} -cleanup {
	    incr foo
	} -match glob -result *
	set foo
} -cleanup {
	unset foo
} -result 0

cleanupTests
}

namespace delete ::tcltest::test
return
@


1.2
log
@touched all Tcl files to ease next import.
@
text
@@


1.2.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.2.16.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d1 5
d10 1
a10 2
# Copyright (c) 1998-1999 by Scriptics Corporation. 
# Copyright (c) 2000 by Ajuba Solutions
d15 3
a17 14
# Note that there are several places where the value of 
# tcltest::currentFailure is stored/reset in the -setup/-cleanup
# of a test that has a body that runs [test] that will fail.
# This is a workaround of using the same tcltest code that we are
# testing to run the test itself.  Ditto on things like [verbose].
#
# It would be better to have the -body of the tests run the tcltest
# commands in a slave interp so the [test] being tested would not
# interfere with the [test] doing the testing.  
#

if {[catch {package require tcltest 2.1}]} {
    puts stderr "Skipping tests in [info script].  tcltest 2.1 required."
    return
a19 4
namespace eval ::tcltest::test {

namespace import ::tcltest::*

d22 1
a22 1
    namespace import ::tcltest::test
d31 1
a31 4
    test d-1.0 {test d} {
	error "foo" foo 9
    } {}
    tcltest::cleanupTests
a34 2
cd [temporaryDirectory]
testConstraint exec [llength [info commands exec]]
d36 3
a38 3
# Child processes because -help [exit]s.
test tcltest-1.1 {tcltest -help} {exec} {
    set result [catch {exec [interpreter] test.tcl -help} msg]
d41 2
a42 2
test tcltest-1.2 {tcltest -help -something} {exec} {
    set result [catch {exec [interpreter] test.tcl -help -something} msg]
d45 2
a46 2
test tcltest-1.3 {tcltest -h} {exec} {
    set result [catch {exec [interpreter] test.tcl -h} msg]
d48 1
a48 1
} {1 0} 
d50 1
a50 37
# -verbose, implicit & explicit testing of [verbose]
proc slave {msgVar args} {
    upvar 1 $msgVar msg

    interp create [namespace current]::i
    # Fake the slave interp into dumping output to a file
    i eval {namespace eval ::tcltest {}}
    i eval "set tcltest::outputChannel \[open [makeFile {} output] w]"
    i eval "set tcltest::errorChannel \[open [makeFile {} error] w]"
    i eval [list set argv0 [lindex $args 0]]
    i eval [list set argv [lrange $args 1 end]]
    i eval [list package ifneeded tcltest [package provide tcltest] \
	    [package ifneeded tcltest [package provide tcltest]]]
    i eval {proc exit args {}}

    # Need to capture output in msg

    set code [catch {i eval {source $argv0}} foo]
if $code {
#puts "$code: $foo\n$::errorInfo"
}
    i eval {close $tcltest::outputChannel}
    interp delete [namespace current]::i
    set f [open [file join [temporaryDirectory] output]]
    set msg [read -nonewline $f]
    close $f
    set f [open [file join [temporaryDirectory] error]]
    set err [read -nonewline $f]
    close $f
    if {[string length $err]} {
	set code 1
	append msg \n$err
    }
    return $code

#    return [catch {uplevel 1 [linsert $args 0  exec [interpreter]]} msg]
}
d52 1
a52 1
    set result [slave msg test.tcl]
d55 1
a55 1
	    [regexp "Total.+4.+Passed.+1.+Skipped.+1.+Failed.+2" $msg]
d57 2
a58 2
test tcltest-2.1 {tcltest -verbose 'b'} {unixOrPc} {
    set result [slave msg test.tcl -verbose 'b']
d61 1
a61 1
	    [regexp "Total.+4.+Passed.+1.+Skipped.+1.+Failed.+2" $msg]
d63 2
a64 2
test tcltest-2.2 {tcltest -verbose 'p'} {unixOrPc} {
    set result [slave msg test.tcl -verbose 'p']
d67 1
a67 1
	    [regexp "Total.+4.+Passed.+1.+Skipped.+1.+Failed.+2" $msg]
d69 2
a70 2
test tcltest-2.3 {tcltest -verbose 's'} {unixOrPc} {
    set result [slave msg test.tcl -verbose 's']
d73 1
a73 1
	    [regexp "Total.+4.+Passed.+1.+Skipped.+1.+Failed.+2" $msg]
d75 2
a76 2
test tcltest-2.4 {tcltest -verbose 'ps'} {unixOrPc} {
    set result [slave msg test.tcl -verbose 'ps']
d79 1
a79 1
	    [regexp "Total.+4.+Passed.+1.+Skipped.+1.+Failed.+2" $msg]
d81 2
a82 2
test tcltest-2.5 {tcltest -verbose 'psb'} {unixOrPc} {
    set result [slave msg test.tcl -verbose 'psb']
d85 1
a85 1
	    [regexp "Total.+4.+Passed.+1.+Skipped.+1.+Failed.+2" $msg]
d88 1
a88 50
test tcltest-2.5a {tcltest -verbose 'pass skip body'} {unixOrPc} {
    set result [slave msg test.tcl -verbose "pass skip body"]
    list $result [regexp "Contents of test case" $msg] [regexp a-1.0 $msg] \
	    [regexp c-1.0 $msg] \
	    [regexp "Total.+4.+Passed.+1.+Skipped.+1.+Failed.+2" $msg]
} {0 1 1 1 1}

test tcltest-2.6 {tcltest -verbose 't'}  {
    -constraints {unixOrPc} 
    -body {
	set result [slave msg test.tcl -verbose 't']
	list $result $msg
    }
    -result {^0 .*a-1.0 start.*b-1.0 start}
    -match regexp
}

test tcltest-2.6a {tcltest -verbose 'start'}  {
    -constraints {unixOrPc} 
    -body {
	set result [slave msg test.tcl -verbose start]
	list $result $msg
    }
    -result {^0 .*a-1.0 start.*b-1.0 start}
    -match regexp
}

test tcltest-2.7 {tcltest::verbose}  {
    -body {
	set oldVerbosity [verbose]
	verbose bar
	set currentVerbosity [verbose]
	verbose foo
	set newVerbosity [verbose]
	verbose $oldVerbosity
	list $currentVerbosity $newVerbosity 
    }
    -result {body {}}
}

test tcltest-2.8 {tcltest -verbose 'error'} {
    -constraints {unixOrPc}
    -body {
	set result [slave msg test.tcl -verbose error]
	list $result $msg
    }
    -result {errorInfo: foo.*errorCode: 9}
    -match regexp
}
# -match, [match]
d90 1
a90 1
    set result [slave msg test.tcl -match a* -verbose 'ps']
d92 1
a92 1
	    [regexp "Total.+4.+Passed.+1.+Skipped.+3.+Failed.+0" $msg]
d95 1
a95 1
    set result [slave msg test.tcl -match b* -verbose 'ps']
d97 1
a97 1
	    [regexp "Total.+4.+Passed.+0.+Skipped.+3.+Failed.+1" $msg]
d100 1
a100 1
    set result [slave msg test.tcl -match c* -verbose 'ps']
d102 1
a102 1
	    [regexp "Total.+4.+Passed.+0.+Skipped.+4.+Failed.+0" $msg]
d105 1
a105 1
    set result [slave msg test.tcl -match {a* b*} -verbose 'ps']
d107 1
a107 1
	    [regexp "Total.+4.+Passed.+1.+Skipped.+2.+Failed.+1" $msg]
d110 1
a110 14
test tcltest-3.5 {tcltest::match}  {
    -body {
	set oldMatch [match]
	match foo
	set currentMatch [match]
	match bar
	set newMatch [match]
	match $oldMatch
	list $currentMatch $newMatch
    }
    -result {foo bar}
}
	
# -skip, [skip]
d112 1
a112 1
    set result [slave msg test.tcl -skip a* -verbose 'ps']
d114 1
a114 1
	    [regexp "Total.+4.+Passed.+0.+Skipped.+2.+Failed.+1" $msg]
d117 1
a117 1
    set result [slave msg test.tcl -skip b* -verbose 'ps']
d119 1
a119 1
	    [regexp "Total.+4.+Passed.+1.+Skipped.+2.+Failed.+1" $msg]
d122 1
a122 1
    set result [slave msg test.tcl -skip c* -verbose 'ps']
d124 1
a124 1
	    [regexp "Total.+4.+Passed.+1.+Skipped.+1.+Failed.+2" $msg]
d127 1
a127 1
    set result [slave msg test.tcl -skip {a* b*} -verbose 'ps']
d129 1
a129 1
	    [regexp "Total.+4.+Passed.+0.+Skipped.+3.+Failed.+1" $msg]
d132 1
a132 1
    set result [slave msg test.tcl -match {a* b*} -skip b* -verbose 'ps']
d134 1
a134 1
	    [regexp "Total.+4.+Passed.+1.+Skipped.+3.+Failed.+0" $msg]
d137 1
a137 15
test tcltest-4.6 {tcltest::skip} {
    -body {
	set oldSkip [skip]
	skip foo
	set currentSkip [skip]
	skip bar
	set newSkip [skip]
	skip $oldSkip
	list $currentSkip $newSkip
    }
    -result {foo bar}
}

# -constraints, -limitconstraints, [testConstraint],
# $constraintsSpecified, [limitConstraints]
d139 1
a139 1
    set result [slave msg test.tcl -constraints knownBug -verbose 'ps']
d141 1
a141 1
	    [regexp "Total.+4.+Passed.+2.+Skipped.+0.+Failed.+2" $msg]
d143 2
a144 2
test tcltest-5.2 {tcltest -constraints 'knownBug' -limitconstraints 1} {unixOrPc} {
    set result [slave msg test.tcl -constraints knownBug -verbose 'p' -limitconstraints 1]
d146 1
a146 1
	    [regexp "Total.+4.+Passed.+1.+Skipped.+3.+Failed.+0" $msg]
d149 1
a149 68
test tcltest-5.3 {testConstraint - constraint empty (tcltest::safeFetch)}  {
    -body {
	set r1 [testConstraint tcltestFakeConstraint]
	set r2 [testConstraint tcltestFakeConstraint 4]
	set r3 [testConstraint tcltestFakeConstraint]
	list $r1 $r2 $r3
    }
    -result {0 4 4}
    -cleanup {unset ::tcltest::testConstraints(tcltestFakeConstraint)}
}

# Removed this test of internals of tcltest.  Those internals have changed.
#test tcltest-5.4 {tcltest::constraintsSpecified} {
#    -setup {
#	set constraintlist $::tcltest::constraintsSpecified
#	set ::tcltest::constraintsSpecified {}
#    }
#    -body {
#	set r1 $::tcltest::constraintsSpecified
#	testConstraint tcltestFakeConstraint1 1
#	set r2 $::tcltest::constraintsSpecified
#	testConstraint tcltestFakeConstraint2 1
#	set r3 $::tcltest::constraintsSpecified
#	list $r1 $r2 $r3
#    }
#    -result {{} tcltestFakeConstraint1 {tcltestFakeConstraint1 tcltestFakeConstraint2}}
#    -cleanup {
#	set ::tcltest::constraintsSpecified $constraintlist
#	unset ::tcltest::testConstraints(tcltestFakeConstraint1) 
#	unset ::tcltest::testConstraints(tcltestFakeConstraint2) 
#    }
#}

test tcltest-5.5 {InitConstraints: list of built-in constraints} \
	-constraints {!singleTestInterp} \
	-setup {tcltest::InitConstraints} \
	-body { lsort [array names ::tcltest::testConstraints] } \
	-result [lsort {
    95 98 asyncPipeClose eformat emptyTest exec hasIsoLocale interactive
    knownBug mac macCrash macOnly macOrPc macOrUnix macOrWin nonBlockFiles
    nonPortable notRoot nt pc pcCrash pcOnly root singleTestInterp socket
    stdio tempNotMac tempNotPc tempNotUnix tempNotWin unix unixCrash unixExecs
    unixOnly unixOrPc unixOrWin userInteraction win winCrash winOnly
}]

# Removed this broken test.  Its usage of [limitConstraints] was not
# in agreement with the documentation.  [limitConstraints] is supposed
# to take an optional boolean argument, and "knownBug" ain't no boolean!
#test tcltest-5.6 {tcltest::limitConstraints} {
#    -setup {
#        set keeplc $::tcltest::limitConstraints
#        set keepkb [testConstraint knownBug]
#    }
#    -body {
#        set r1 [limitConstraints]
#        set r2 [limitConstraints knownBug]
#        set r3 [limitConstraints]
#        list $r1 $r2 $r3
#    }
#    -cleanup {
#        limitConstraints $keeplc
#        testConstraint knownBug $keepkb
#    }
#    -result {false knownBug knownBug}
#}

# -outfile, -errfile, [outputChannel], [outputFile], [errorChannel], [errorFile]
set printerror [makeFile {
d151 2
a152 2
    namespace import ::tcltest::*
    puts [outputChannel] "a test"
d162 1
a162 1
} printerror.tcl]
d164 7
a170 11
test tcltest-6.1 {tcltest -outfile, -errfile defaults} {
    -constraints unixOrPc
    -body {
	slave msg $printerror
	return $msg
    }
    -result {a test.*a really}
    -match regexp
}
test tcltest-6.2 {tcltest -outfile a.tmp} {unixOrPc unixExecs} {
    slave msg $printerror -outfile a.tmp
d176 2
a177 2
test tcltest-6.3 {tcltest -errfile a.tmp} {unixOrPc unixExecs} {
    slave msg $printerror -errfile a.tmp
d183 2
a184 2
test tcltest-6.4 {tcltest -outfile a.tmp -errfile b.tmp} {unixOrPc unixExecs} {
    slave msg printerror.tcl -outfile a.tmp -errfile b.tmp
d193 3
a195 77
test tcltest-6.5 {tcltest::errorChannel - retrieval} {
    -setup {
	set of [errorChannel]
	set ::tcltest::errorChannel stderr
    }
    -body {
	errorChannel
    }
    -result {stderr}
    -cleanup {
	set ::tcltest::errorChannel $of
    }
}

test tcltest-6.6 {tcltest::errorFile (implicit errorChannel)} {
    -setup {
	set ef [makeFile {} efile]
	set of [errorFile]
	set ::tcltest::errorChannel stderr
	set ::tcltest::errorFile stderr
    }
    -body {
	set f0 [errorChannel]
	set f1 [errorFile]
	set f2 [errorFile $ef]
	set f3 [errorChannel]
	set f4 [errorFile]
	subst {$f0;$f1;$f2;$f3;$f4} 
    }
    -result {stderr;stderr;.*efile;file[0-9a-f]+;.*efile}
    -match regexp
    -cleanup {
	errorFile $of
    }
}
test tcltest-6.7 {tcltest::outputChannel - retrieval} {
    -setup {
	set of [outputChannel]
	set ::tcltest::outputChannel stdout
    }
    -body {
	outputChannel
    }
    -result {stdout}
    -cleanup {
	set tcltest::outputChannel $of
    }
}

test tcltest-6.8 {tcltest::outputFile (implicit outputFile)} {
    -setup {
	set ef [makeFile {} efile]
	set of [outputFile]
	set ::tcltest::outputChannel stdout
	set ::tcltest::outputFile stdout
    }
    -body {
	set f0 [outputChannel]
	set f1 [outputFile]
	set f2 [outputFile $ef]
	set f3 [outputChannel]
	set f4 [outputFile]
	subst {$f0;$f1;$f2;$f3;$f4} 
    }
    -result {stdout;stdout;.*efile;file[0-9a-f]+;.*efile}
    -match regexp
    -cleanup {
	outputFile $of
    }
}

# -debug, [debug]
# Must use child processes to test -debug because it always writes
# messages to stdout, and we have no way to capture stdout of a
# slave interp
test tcltest-7.1 {tcltest test.tcl -debug 0} {unixOrPc} {
    catch {exec [interpreter] test.tcl -debug 0} msg
d198 2
a199 2
test tcltest-7.2 {tcltest test.tcl -debug 1} {unixOrPc} {
    catch {exec [interpreter] test.tcl -debug 1 -skip b*} msg
d203 2
a204 2
test tcltest-7.3 {tcltest test.tcl -debug 1} {unixOrPc} {
    catch {exec [interpreter] test.tcl -debug 1 -match b*} msg
d208 2
a209 2
test tcltest-7.4 {tcltest test.tcl -debug 2} {unixOrPc} {
    catch {exec [interpreter] test.tcl -debug 2} msg
d212 2
a213 2
test tcltest-7.5 {tcltest test.tcl -debug 3} {unixOrPc} {
    catch {exec [interpreter] test.tcl -debug 3} msg
a216 21
test tcltest-7.6 {tcltest::debug} {
    -setup {
	set old $::tcltest::debug
	set ::tcltest::debug 0
    }
    -body {
	set f1 [debug]
	set f2 [debug 1]
	set f3 [debug]
	set f4 [debug 2]
	set f5 [debug]
	list $f1 $f2 $f3 $f4 $f5
    }
    -result {0 1 1 2 2}
    -cleanup {
	set ::tcltest::debug $old
    }
}

# directory tests

d219 2
a220 2
    tcltest::makeFile {} a.tmp
    puts [tcltest::outputChannel] "testdir: [tcltest::testsDirectory]"
d224 1
a224 6
makeFile {} thisdirectoryisafile  

set normaldirectory [makeDirectory normaldirectory]
if {$::tcl_platform(platform) == "macintosh"} {
set normaldirectory [file normalize $normaldirectory]
}
d226 1
a226 1
# -tmpdir, [temporaryDirectory]
d229 1
a229 1
    slave msg a.tcl -tmpdir thisdirectorydoesnotexist
d233 5
a237 9
test tcltest-8.2 {tcltest a.tcl -tmpdir thisdirectoryisafile} {
    -constraints unixOrPc
    -body {
	slave msg a.tcl -tmpdir thisdirectoryisafile
	set msg
    }
    -result {*not a directory*}
    -match glob
}
d239 3
a241 3
# Test non-writeable directories, non-readable directories with directory flags
set notReadableDir [file join [temporaryDirectory] notreadable]
set notWriteableDir [file join [temporaryDirectory] notwriteable]
d243 2
a244 2
makeDirectory notreadable
makeDirectory notwriteable
d252 1
a252 1
	catch {file attributes $notWriteableDir -readonly 1}
d256 4
a259 3
test tcltest-8.3 {tcltest a.tcl -tmpdir notReadableDir} {unixOnly nonRoot} {
    slave msg a.tcl -tmpdir $notReadableDir 
    string match {*not readable*} $msg
d262 4
a265 3
test tcltest-8.4 {tcltest a.tcl -tmpdir notWriteableDir} {unixOrPc nonRoot} {
    slave msg a.tcl -tmpdir $notWriteableDir
    string match {*not writeable*} $msg
d268 2
a269 40
test tcltest-8.5 {tcltest a.tcl -tmpdir normaldirectory} {unixOrPc} {
    slave msg a.tcl -tmpdir $normaldirectory
    # The join is necessary because the message can be split on multiple lines
    list [file exists [file join $normaldirectory a.tmp]] \
	    [file delete [file join $normaldirectory a.tmp]] 
} {1 {}}   
cd [workingDirectory]

test tcltest-8.6 {temporaryDirectory}  {
    -setup {
	set old $::tcltest::temporaryDirectory
	set ::tcltest::temporaryDirectory $normaldirectory
    }
    -body {
	set f1 [temporaryDirectory]
	set f2 [temporaryDirectory [workingDirectory]]
	set f3 [temporaryDirectory]
	list $f1 $f2 $f3
    }
    -result "[list $normaldirectory [workingDirectory] [workingDirectory]]"
    -cleanup {
	set ::tcltest::temporaryDirectory $old
    }
}

test tcltest-8.6a {temporaryDirectory - test format 2} -setup {
    set old $::tcltest::temporaryDirectory
    set ::tcltest::temporaryDirectory $normaldirectory
} -body {
    set f1 [temporaryDirectory]
    set f2 [temporaryDirectory [workingDirectory]]
    set f3 [temporaryDirectory]
    list $f1 $f2 $f3
} -cleanup {
    set ::tcltest::temporaryDirectory $old
} -result [list $normaldirectory [workingDirectory] [workingDirectory]]

cd [temporaryDirectory]
# -testdir, [testsDirectory]
test tcltest-8.10 {tcltest a.tcl -testdir thisdirectorydoesnotexist} {unixOrPc} {
d271 2
a272 2
    slave msg a.tcl -testdir thisdirectorydoesnotexist
    string match "*does not exist*" $msg
d275 4
a278 3
test tcltest-8.11 {tcltest a.tcl -testdir thisdirectoryisafile} {unixOrPc} {
    slave msg a.tcl -testdir thisdirectoryisafile
    string match "*not a directory*" $msg 
d281 4
a284 3
test tcltest-8.12 {tcltest a.tcl -testdir notReadableDir} {unixOnly nonRoot} {
    slave msg a.tcl -testdir $notReadableDir 
    string match {*not readable*} $msg
a287 56
test tcltest-8.13 {tcltest a.tcl -testdir normaldirectory} {unixOrPc} {
    slave msg a.tcl -testdir $normaldirectory
    # The join is necessary because the message can be split on multiple lines
    list [string first "testdir: $normaldirectory" [join $msg]] \
	    [file exists [file join [temporaryDirectory] a.tmp]] \
	    [file delete [file join [temporaryDirectory] a.tmp]] 
} {0 1 {}} 
cd [workingDirectory]

set current [pwd]
test tcltest-8.14 {testsDirectory} {
    -setup {
	set old $::tcltest::testsDirectory
	set ::tcltest::testsDirectory $normaldirectory
    }
    -body {
	set f1 [testsDirectory]
	set f2 [testsDirectory $current]
	set f3 [testsDirectory]
	list $f1 $f2 $f3
    }
    -result "[list $normaldirectory $current $current]"
    -cleanup {
	set ::tcltest::testsDirectory $old
    }
}

# [workingDirectory]
test tcltest-8.60 {::workingDirectory}  {
    -setup {
	set old $::tcltest::workingDirectory
	set current [pwd]
	set ::tcltest::workingDirectory $normaldirectory
	cd $normaldirectory
    }
    -body {
	set f1 [workingDirectory]
	set f2 [pwd]
	set f3 [workingDirectory $current]
	set f4 [pwd] 
	set f5 [workingDirectory]
	list $f1 $f2 $f3 $f4 $f5
    }
    -result "[list $normaldirectory \
                   $normaldirectory \
                   $current \
                   $current \
                   $current]"
    -cleanup {
	set ::tcltest::workingDirectory $old
	cd $current
    }
}

# clean up from directory testing

d294 1
a294 1
	catch {file attributes $notWriteableDir -readonly 0}
d300 1
a300 1
# -file, -notfile, [matchFiles], [skipFiles]
d302 2
a303 1
    slave msg [file join [testsDirectory] all.tcl] -file a*.test
d307 3
a309 2
    slave msg [file join [testsDirectory] all.tcl] \
	    -file a*.test -notfile assocd*
a312 12
test tcltest-9.3 {matchFiles}  {
    -body {
	set old [matchFiles]
	matchFiles foo
	set current [matchFiles]
	matchFiles bar
	set new [matchFiles]
	matchFiles $old
	list $current $new
    } 
    -result {foo bar}
}
a313 12
test tcltest-9.4 {skipFiles} {
    -body {
	set old [skipFiles]
	skipFiles foo
	set current [skipFiles]
	skipFiles bar
	set new [skipFiles]
	skipFiles $old
	list $current $new
    } 
    -result {foo bar}
}
a314 1
# -preservecore, [preserveCore]
d317 2
a318 1
    namespace import ::tcltest::test
d327 1
a327 1
cd [temporaryDirectory]
d329 1
a329 1
    slave msg makecore.tcl -preservecore 0
d331 1
a331 1
    regexp "Core file produced" $msg
d334 1
a334 1
    slave msg makecore.tcl -preservecore 1
d336 1
a336 1
    regexp "Core file produced" $msg
d339 1
a339 1
    slave msg makecore.tcl -preservecore 2
d341 1
a341 1
    list [regexp "Core file produced" $msg] [regexp "Moving file to" $msg] \
d345 1
a345 1
    slave msg makecore.tcl -preservecore 3
d347 1
a347 1
    list [regexp "Core file produced" $msg] [regexp "Moving file to" $msg] \
d351 1
a351 16
# Removing this test.  It makes no sense to test the ability of
# [preserveCore] to accept an invalid value that will cause errors
# in other parts of tcltest's operation.
#test tcltest-10.5 {preserveCore} {
#    -body {
#	set old [preserveCore]
#	set result [preserveCore foo]
#	set result2 [preserveCore]
#	preserveCore $old
#	list $result $result2
#    }
#    -result {foo foo}
#}

# -load, -loadfile, [loadScript], [loadFile]
set contents { 
d353 2
a354 2
    namespace import tcltest::*
    puts [outputChannel] $::tcltest::loadScript
d356 1
a356 108
} 
set loadfile [makeFile $contents load.tcl]

test tcltest-12.1 {-load xxx} {unixOrPc} {
    slave msg load.tcl -load xxx
    set msg
} {xxx}

# Using child process because of -debug usage.
test tcltest-12.2 {-loadfile load.tcl} {unixOrPc} {
    catch {exec [interpreter] load.tcl -debug 2 -loadfile load.tcl} msg
    list \
	    [regexp {tcltest} [join [list $msg] [split $msg \n]]] \
	    [regexp {loadScript} [join [list $msg] [split $msg \n]]]
} {1 1}

test tcltest-12.3 {loadScript} {
    -setup {
	set old $::tcltest::loadScript
    }
    -body {
	set f1 [loadScript]
	set f2 [loadScript xxx]
	set f3 [loadScript]
	list $f1 $f2 $f3
    }
    -result {{} xxx xxx}
    -cleanup {
	set ::tcltest::loadScript $old
    }
}

test tcltest-12.4 {loadFile} {
    -setup {
	set olds $::tcltest::loadScript
	set oldf $::tcltest::loadFile
	set ::tcltest::loadFile {}
    }
    -body {
	set f1 [loadScript]
	set f2 [loadFile]
	set f3 [loadFile load.tcl]
	set f4 [loadScript]
	set f5 [loadFile]
	list $f1 $f2 $f3 $f4 $f5
    }
    -result "[list {} {} $loadfile $contents $loadfile]\n"
    -cleanup {
	set ::tcltest::loadScript $olds
	set ::tcltest::loadFile $oldf
    }
}

# [interpreter]
test tcltest-13.1 {interpreter} {
    -setup {
	set old $::tcltest::tcltest
	set ::tcltest::tcltest tcltest
    }
    -body {
	set f1 [interpreter]
	set f2 [interpreter tclsh]
	set f3 [interpreter]
	list $f1 $f2 $f3
    }
    -result {tcltest tclsh tclsh}
    -cleanup {
	set ::tcltest::tcltest $old
    }
}

# -singleproc, [singleProcess]
makeDirectory singleprocdir
makeFile {
    set foo 1
} [file join singleprocdir single1.test]

makeFile {
    unset foo
} [file join singleprocdir single2.test]

set allfile [makeFile {
    package require tcltest
    namespace import tcltest::*
    testsDirectory [file join [temporaryDirectory] singleprocdir]
    runAllTests
} [file join singleprocdir all-single.tcl]]
cd [workingDirectory]

test tcltest-14.1 {-singleproc - single process} {
    -constraints {unixOrPc}
    -body {
	slave msg $allfile -singleproc 0 -tmpdir [temporaryDirectory]
	set msg
    }
    -result {Test file error: can't unset .foo.: no such variable}
    -match regexp
}

test tcltest-14.2 {-singleproc - multiple process} {
    -constraints {unixOrPc}
    -body {
	slave msg $allfile -singleproc 1 -tmpdir [temporaryDirectory]
	set msg
    }
    -result {single1.test.*single2.test.*all\-single.tcl:.*Total.*0.*Passed.*0.*Skipped.*0.*Failed.*0}
    -match regexp
}
d358 5
a362 16
test tcltest-14.3 {singleProcess} {
    -setup {
	set old $::tcltest::singleProcess
	set ::tcltest::singleProcess 0
    }
    -body {
	set f1 [singleProcess]
	set f2 [singleProcess 1]
	set f3 [singleProcess]
	list $f1 $f2 $f3
    }
    -result {0 1 1}
    -cleanup {
	set ::tcltest::singleProcess $old
    }
}
d364 4
a367 1
# -asidefromdir, -relateddir, [matchDirectories], [skipDirectories]
d369 4
a372 2
# Before running these tests, need to set up test subdirectories with their own
# all.tcl files.
d374 1
a374 4
makeDirectory dirtestdir
makeDirectory [file join dirtestdir dirtestdir2.1]
makeDirectory [file join dirtestdir dirtestdir2.2]
makeDirectory [file join dirtestdir dirtestdir2.3]
d377 4
a380 36
    namespace import -force tcltest::*
    testsDirectory [file join [temporaryDirectory] dirtestdir]
    runAllTests
} [file join dirtestdir all.tcl]
makeFile {
    package require tcltest
    namespace import -force tcltest::*
    testsDirectory [file join [temporaryDirectory] dirtestdir dirtestdir2.1]
    runAllTests
} [file join dirtestdir dirtestdir2.1 all.tcl]
makeFile {
    package require tcltest
    namespace import -force tcltest::*
    testsDirectory [file join [temporaryDirectory]  dirtestdir dirtestdir2.2]
    runAllTests
} [file join dirtestdir dirtestdir2.2 all.tcl]
makeFile {
    package require tcltest
    namespace import -force tcltest::*
    testsDirectory [file join [temporaryDirectory] dirtestdir dirtestdir2.3]
    runAllTests
} [file join dirtestdir dirtestdir2.3 all.tcl]

test tcltest-15.1 {basic directory walking} {
    -constraints {unixOrPc}
    -body {
	if {[slave msg \
		[file join [temporaryDirectory] dirtestdir all.tcl] \
		-tmpdir [temporaryDirectory]] == 1} {
	    error $msg
	}
    }
    -match regexp
    -returnCodes 1
    -result {Tests located in:.*dirtestdir.*Tests located in:.*dirtestdir2.1.*Tests located in:.*dirtestdir2.2.*Tests located in:.*dirtestdir2.3}
}
d382 4
a385 17
test tcltest-15.2 {-asidefromdir} {
    -constraints {unixOrPc}
    -body {
	if {[slave msg \
		[file join [temporaryDirectory] dirtestdir all.tcl] \
		-asidefromdir dirtestdir2.3 \
		-tmpdir [temporaryDirectory]] == 1} {
	    error $msg
	}
    }
    -match regexp
    -returnCodes 1
    -result {Tests located in:.*dirtestdir.*Tests located in:.*dirtestdir2.1.*Tests located in:.*dirtestdir2.2.*dirtestdir2.2 test ended at .*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Error:  No test files remain after applying your match and skip patterns!
Error:  No test files remain after applying your match and skip patterns!
Error:  No test files remain after applying your match and skip patterns!$}
}
d387 6
a392 111
test tcltest-15.3 {-relateddir, non-existent dir} {
    -constraints {unixOrPc}
    -body {
	if {[slave msg \
		[file join [temporaryDirectory] dirtestdir all.tcl] \
		-relateddir [file join [temporaryDirectory] dirtestdir0] \
		-tmpdir [temporaryDirectory]] == 1} {
	    error $msg
	}
    }
    -returnCodes 1
    -match regexp
    -result {[^~]|dirtestdir[^2]}
}

test tcltest-15.4 {-relateddir, subdir} {
    -constraints {unixOrPc}
    -body {
	if {[slave msg \
		[file join [temporaryDirectory] dirtestdir all.tcl] \
		-relateddir dirtestdir2.1 -tmpdir [temporaryDirectory]] == 1} {
	    error $msg
	}
    }
    -returnCodes 1
    -match regexp
    -result {Tests located in:.*dirtestdir2.[^23]}
}
test tcltest-15.5 {-relateddir, -asidefromdir} {
    -constraints {unixOrPc}
    -body {
	if {[slave msg \
		[file join [temporaryDirectory] dirtestdir all.tcl] \
		-relateddir "dirtestdir2.1 dirtestdir2.2" \
		-asidefromdir dirtestdir2.2 \
		-tmpdir [temporaryDirectory]] == 1} {
	    error $msg
	}
    }
    -match regexp
    -returnCodes 1
    -result {Tests located in:.*dirtestdir2.[^23]}
}

test tcltest-15.6 {matchDirectories} {
    -setup {
	set old [matchDirectories]
	set ::tcltest::matchDirectories {}
    }
    -body {
	set r1 [matchDirectories]
	set r2 [matchDirectories foo]
	set r3 [matchDirectories]
	list $r1 $r2 $r3
    }
    -cleanup {
	set ::tcltest::matchDirectories $old
    }
    -result {{} foo foo}
}

test tcltest-15.7 {skipDirectories} {
    -setup {
	set old [skipDirectories]
	set ::tcltest::skipDirectories {}
    }
    -body {
	set r1 [skipDirectories]
	set r2 [skipDirectories foo]
	set r3 [skipDirectories]
	list $r1 $r2 $r3
    }
    -cleanup {
	set ::tcltest::skipDirectories $old
    }
    -result {{} foo foo}
}

# TCLTEST_OPTIONS
test tcltest-19.1 {TCLTEST_OPTIONS default} {
    -constraints {unixOrPc singleTestInterp}
    -setup {
	if {[info exists ::env(TCLTEST_OPTIONS)]} {
	    set oldoptions $::env(TCLTEST_OPTIONS)
	    unset ::env(TCLTEST_OPTIONS)
	} else {
	    set oldoptions none
	}
	# set this to { } instead of just {} to get around quirk in
	# Windows env handling that removes empty elements from env array.
	set ::env(TCLTEST_OPTIONS) { }
	set olddebug [debug]
	debug 2
    }
    -cleanup {
	if {$oldoptions == "none"} {
	    unset ::env(TCLTEST_OPTIONS) 
	} else {
	    set ::env(TCLTEST_OPTIONS) $oldoptions
	}
	debug $olddebug
    }
    -body {
	::tcltest::ProcessCmdLineArgs
	set ::env(TCLTEST_OPTIONS) "-debug 3"
	::tcltest::ProcessCmdLineArgs
    }
    -result {^$}
    -match regexp
    -output {tcltest::debug\s+= 2.*tcltest::debug\s+= 3}
}
a395 1
cd [temporaryDirectory]
d398 1
a398 1
    set result [slave msg printerror.tcl]
a402 1
cd [workingDirectory]
d404 3
a406 17
# test::test
test tcltest-21.0 {name and desc but no args specified} -setup {
    set v [verbose]
} -cleanup {
    verbose $v
} -body {
   verbose {}
   test tcltest-21.0.0 bar
} -result {}

test tcltest-21.1 {expect with glob} {
    -body {
	list a b c d e
    }
    -match glob
    -result {[ab] b c d e}
}
a407 590
test tcltest-21.2 {force a test command failure} {
    -body {
	test tcltest-21.2.0 {
	    return 2
	} {1}
    }
    -returnCodes 1
    -result {bad option "1": must be -body, -cleanup, -constraints, -errorOutput, -match, -output, -result, -returnCodes, or -setup}
}

test tcltest-21.3 {test command with setup} {
    -setup {
	set foo 1
    }
    -body {
	set foo
    }
    -cleanup {unset foo}
    -result {1}
}

test tcltest-21.4 {test command with cleanup failure} {
    -setup {
	if {[info exists foo]} {
	    unset foo
	}
	set fail $::tcltest::currentFailure
	set v [verbose]
    }
    -body {
	verbose {}
	test tcltest-21.4.0 {foo-1} {
	    -cleanup {unset foo}
	}
    }
    -result {^$}
    -match regexp
    -cleanup {verbose $v; set ::tcltest::currentFailure $fail}
    -output "Test cleanup failed:.*can't unset \"foo\": no such variable"
}

test tcltest-21.5 {test command with setup failure} {
    -setup {
	if {[info exists foo]} {
	    unset foo
	}
	set fail $::tcltest::currentFailure
    }
    -body {
	test tcltest-21.5.0 {foo-2} {
	    -setup {unset foo}
	}
    }
    -result {^$}
    -match regexp
    -cleanup {set ::tcltest::currentFailure $fail}
    -output "Test setup failed:.*can't unset \"foo\": no such variable"
}

test tcltest-21.6 {test command - setup occurs before cleanup & before script} {
    -setup {set v [verbose]; set fail $::tcltest::currentFailure}
    -body {
	verbose {}
	test tcltest-21.6.0 {foo-3} {
	    -setup {
		if {[info exists foo]} {
		    unset foo
		}
		set foo 1
		set expected 2
	    } 
	    -body {
		incr foo
		set foo
	    }
	    -cleanup {
		if {$foo != 2} {
		    puts [outputChannel] "foo is wrong"
		} else {
		    puts [outputChannel] "foo is 2"
		}
	    }
	    -result {$expected}
	}
    }
    -cleanup {verbose $v; set ::tcltest::currentFailure $fail}
    -result {^$}
    -match regexp
    -output "foo is 2"
}

test tcltest-21.7 {test command - bad flag} {
    -setup {set fail $::tcltest::currentFailure}
    -cleanup {set ::tcltest::currentFailure $fail}
    -body {
	test tcltest-21.7.0 {foo-4} {
	    -foobar {}
	}
    }
    -returnCodes 1
    -result {bad option "-foobar": must be -body, -cleanup, -constraints, -errorOutput, -match, -output, -result, -returnCodes, or -setup}
}

# alternate test command format (these are the same as 21.1-21.6, with the
# exception of being in the all-inline format)

test tcltest-21.7a {expect with glob} \
	-body {list a b c d e} \
	-result {[ab] b c d e} \
	-match glob

test tcltest-21.8 {force a test command failure} \
    -setup {set fail $::tcltest::currentFailure} \
    -body {
        test tcltest-21.8.0 {
            return 2
        } {1}
    } \
    -returnCodes 1 \
    -cleanup {set ::tcltest::currentFailure $fail} \
    -result {bad option "1": must be -body, -cleanup, -constraints, -errorOutput, -match, -output, -result, -returnCodes, or -setup}

test tcltest-21.9 {test command with setup} \
	-setup {set foo 1} \
	-body {set foo} \
	-cleanup {unset foo} \
	-result {1}

test tcltest-21.10 {test command with cleanup failure} -setup {
    if {[info exists foo]} {
	unset foo
    }
    set fail $::tcltest::currentFailure
    set v [verbose]
} -cleanup {
    verbose $v
    set ::tcltest::currentFailure $fail
} -body {
    verbose {}
    test tcltest-21.10.0 {foo-1} -cleanup {unset foo}
} -result {^$} -match regexp \
	-output {Test cleanup failed:.*can't unset \"foo\": no such variable}

test tcltest-21.11 {test command with setup failure} -setup {
    if {[info exists foo]} {
	unset foo
    }
    set fail $::tcltest::currentFailure
} -cleanup {set ::tcltest::currentFailure $fail} -body {
    test tcltest-21.11.0 {foo-2} -setup {unset foo}
} -result {^$} -output {Test setup failed:.*can't unset \"foo\": no such variable} -match regexp

test tcltest-21.12 {
	test command - setup occurs before cleanup & before script
} -setup {
	set fail $::tcltest::currentFailure
	set v [verbose]
} -cleanup {
	verbose $v
	set ::tcltest::currentFailure $fail
} -body {
    verbose {}
    test tcltest-21.12.0 {foo-3} -setup {
	if {[info exists foo]} {
	    unset foo
	}
	set foo 1
	set expected 2
    }  -body {
	incr foo
	set foo
    }  -cleanup {
	if {$foo != 2} {
	    puts [outputChannel] "foo is wrong"
	} else {
	    puts [outputChannel] "foo is 2"
	}
    }  -result {$expected}
} -result {^$} -output {foo is 2} -match regexp

# test all.tcl usage (runAllTests); simulate .test file failure, as well as
# crashes to determine whether or not these errors are logged.

makeDirectory alltestdir
makeFile {
    package require tcltest
    namespace import -force tcltest::*
    testsDirectory [file join [temporaryDirectory] alltestdir]
    runAllTests
} [file join alltestdir all.tcl]
makeFile {
    exit 1
} [file join alltestdir exit.test]
makeFile {
    error "throw an error"
} [file join alltestdir error.test]
makeFile {
    package require tcltest
    namespace import -force tcltest::*
    test foo-1.1 {foo} {
	-body { return 1 }
	-result {1}
    }
    cleanupTests
} [file join alltestdir test.test]

# Must use a child process because stdout/stderr parsing can't be
# duplicated in slave interp.
test tcltest-22.1 {runAllTests} {
    -constraints {unixOrPc}
    -body {
	exec [interpreter] \
		[file join [temporaryDirectory] alltestdir all.tcl] \
		-verbose t -tmpdir [temporaryDirectory]
    }
    -match regexp
    -result "Test files exiting with errors:.*error.test.*exit.test"
}

# makeFile, removeFile, makeDirectory, removeDirectory, viewFile
test tcltest-23.1 {makeFile} {
    -setup {
	set mfdir [file join [temporaryDirectory] mfdir]
	file mkdir $mfdir
    }
    -body {
	makeFile {} t1.tmp
	makeFile {} et1.tmp $mfdir
	list [file exists [file join [temporaryDirectory] t1.tmp]] \
		[file exists [file join $mfdir et1.tmp]]
    }
    -cleanup {
	file delete -force $mfdir \
		[file join [temporaryDirectory] t1.tmp] 
    }
    -result {1 1}
}
test tcltest-23.2 {removeFile} {
    -setup {
	set mfdir [file join [temporaryDirectory] mfdir]
	file mkdir $mfdir
	makeFile {} t1.tmp
	makeFile {} et1.tmp $mfdir
	if  {![file exists [file join [temporaryDirectory] t1.tmp]] || \
		![file exists [file join $mfdir et1.tmp]]} {
	    error "file creation didn't work"
	}
    }
    -body {
	removeFile t1.tmp
	removeFile et1.tmp $mfdir
	list [file exists [file join [temporaryDirectory] t1.tmp]] \
		[file exists [file join $mfdir et1.tmp]]
    }
    -cleanup {
	file delete -force $mfdir \
		[file join [temporaryDirectory] t1.tmp] 
    }
    -result {0 0}
}
test tcltest-23.3 {makeDirectory} {
    -body {
	set mfdir [file join [temporaryDirectory] mfdir]
	file mkdir $mfdir
	makeDirectory d1
	makeDirectory d2 $mfdir
	list [file exists [file join [temporaryDirectory] d1]] \
		[file exists [file join $mfdir d2]]
    }
    -cleanup {
	file delete -force [file join [temporaryDirectory] d1] $mfdir
    }
    -result {1 1}
}
test tcltest-23.4 {removeDirectory} {
    -body {
	set mfdir [file join [temporaryDirectory] mfdir]
	file mkdir $mfdir
	file mkdir [file join [temporaryDirectory] t1]
	file mkdir [file join [temporaryDirectory] $mfdir t2]
	if {![file exists $mfdir] || \
		![file exists [file join [temporaryDirectory] $mfdir t2]]} {
	    return "setup failed - directory not created"
	}
	removeDirectory t1
	removeDirectory t2 $mfdir
	list [file exists [file join [temporaryDirectory] t1]] \
		[file exists [file join $mfdir t2]]
    }
    -result {0 0}
}
test tcltest-23.5 {viewFile} {
    -body {
	set mfdir [file join [temporaryDirectory] mfdir]
	file mkdir $mfdir
	makeFile {foobar} t1.tmp
	makeFile {foobarbaz} t2.tmp $mfdir
	list [viewFile t1.tmp] [viewFile t2.tmp $mfdir]
    }
    -result {foobar foobarbaz}
    -cleanup {
	file delete -force $mfdir
    }
}

# customMatch
proc matchNegative { expected actual } {
   set match 0
   foreach a $actual e $expected {
      if { $a != $e } {
         set match 1
        break
      }
   }
   return $match
}

test tcltest-24.0 {
	customMatch: syntax
} -body {
	list [catch {customMatch} result] $result
} -result [list 1 "wrong # args: should be \"customMatch mode script\""]

test tcltest-24.1 {
	customMatch: syntax
} -body {
	list [catch {customMatch foo} result] $result
} -result [list 1 "wrong # args: should be \"customMatch mode script\""]

test tcltest-24.2 {
	customMatch: syntax
} -body {
	list [catch {customMatch foo bar baz} result] $result
} -result [list 1 "wrong # args: should be \"customMatch mode script\""]

test tcltest-24.3 {
	customMatch: argument checking
} -body {
	list [catch {customMatch bad "a \{ b"} result] $result
} -result [list 1 "invalid customMatch script; can't evaluate after completion"]

test tcltest-24.4 {
	test: valid -match values
} -body {
	list [catch {
		test tcltest-24.4.0 {} \
			-match [namespace current]::noSuchMode
	} result] $result
} -match glob -result {1 *bad -match value*}

test tcltest-24.5 {
	test: valid -match values
} -setup {
	customMatch [namespace current]::alwaysMatch "format 1 ;#"
} -body {
	list [catch {
		test tcltest-24.5.0 {} \
			-match [namespace current]::noSuchMode
	} result] $result
} -match glob -result {1 *bad -match value*: must be *alwaysMatch,*}

test tcltest-24.6 {
	customMatch: -match script that always matches
} -setup {
	customMatch [namespace current]::alwaysMatch "format 1 ;#"
	set v [verbose]
} -body {
	verbose {}
	test tcltest-24.6.0 {} -match [namespace current]::alwaysMatch \
		-body {format 1} -result 0
} -cleanup {
	verbose $v
} -result {} -output {} -errorOutput {}

test tcltest-24.7 {
	customMatch: replace default -exact matching
} -setup {
	set saveExactMatchScript $::tcltest::CustomMatch(exact)
	customMatch exact "format 1 ;#"
	set v [verbose]
} -body {
	verbose {}
	test tcltest-24.7.0 {} -body {format 1} -result 0
} -cleanup {
	verbose $v
	customMatch exact $saveExactMatchScript
	unset saveExactMatchScript
} -result {} -output {}

test tcltest-24.9 {
	customMatch: error during match
} -setup {
	proc errorDuringMatch args {return -code error "match returned error"}
	customMatch [namespace current]::errorDuringMatch \
		[namespace code errorDuringMatch]
	set v [verbose]
	set fail $::tcltest::currentFailure
} -body {
	verbose {}
	test tcltest-24.9.0 {} -match [namespace current]::errorDuringMatch
} -cleanup {
	verbose $v
	set ::tcltest::currentFailure $fail
} -match glob -result {} -output {*FAILED*match returned error*}

test tcltest-24.10 {
	customMatch: bad return from match command
} -setup {
	proc nonBooleanReturn args {return foo}
	customMatch nonBooleanReturn [namespace code nonBooleanReturn]
	set v [verbose]
	set fail $::tcltest::currentFailure
} -body {
	verbose {}
	test tcltest-24.10.0 {} -match nonBooleanReturn
} -cleanup {
	verbose $v
	set ::tcltest::currentFailure $fail
} -match glob -result {} -output {*FAILED*expected boolean value*}

test tcltest-24.11 {
	test: -match exact
} -body {
	set result {A B C}
} -match exact -result {A B C}

test tcltest-24.12 {
	test: -match exact	match command eval in ::, not caller namespace
} -setup {
	set saveExactMatchScript $::tcltest::CustomMatch(exact)
	customMatch exact [list string equal]
	set v [verbose]
	proc string args {error {called [string] in caller namespace}}
} -body {
	verbose {}
	test tcltest-24.12.0 {} -body {format 1} -result 1
} -cleanup {
	rename string {}
	verbose $v
	customMatch exact $saveExactMatchScript
	unset saveExactMatchScript
} -match exact -result {} -output {}

test tcltest-24.13 {
	test: -match exact	failure
} -setup {
	set saveExactMatchScript $::tcltest::CustomMatch(exact)
	customMatch exact [list string equal]
	set v [verbose]
	set fail $::tcltest::currentFailure
} -body {
	verbose {}
	test tcltest-24.13.0 {} -body {format 1} -result 0
} -cleanup {
	set ::tcltest::currentFailure $fail
	verbose $v
	customMatch exact $saveExactMatchScript
	unset saveExactMatchScript
} -match glob -result {} -output {*FAILED*Result was:
1*(exact matching):
0*}

test tcltest-24.14 {
	test: -match glob
} -body {
	set result {A B C}
} -match glob -result {A B*}

test tcltest-24.15 {
	test: -match glob	failure
} -setup {
	set v [verbose]
	set fail $::tcltest::currentFailure
} -body {
	verbose {}
	test tcltest-24.15.0 {} -match glob -body {format {A B C}} \
		-result {A B* }
} -cleanup {
	set ::tcltest::currentFailure $fail
	verbose $v
} -match glob -result {} -output {*FAILED*Result was:
*(glob matching):
*}

test tcltest-24.16 {
	test: -match regexp
} -body {
	set result {A B C}
} -match regexp -result {A B.*}

test tcltest-24.17 {
	test: -match regexp	failure
} -setup {
	set fail $::tcltest::currentFailure
	set v [verbose]
} -body {
	verbose {}
	test tcltest-24.17.0 {} -match regexp -body {format {A B C}} \
		-result {A B.* X}
} -cleanup {
	set ::tcltest::currentFailure $fail
	verbose $v
} -match glob -result {} -output {*FAILED*Result was:
*(regexp matching):
*}

test tcltest-24.18 {
	test: -match custom	forget namespace qualification
} -setup {
	set fail $::tcltest::currentFailure
	set v [verbose]
	customMatch negative matchNegative
} -body {
	verbose {}
	test tcltest-24.18.0 {} -match negative -body {format {A B C}} \
		-result {A B X}
} -cleanup {
	set ::tcltest::currentFailure $fail
	verbose $v
} -match glob -result {} -output {*FAILED*Error testing result:*}

test tcltest-24.19 {
	test: -match custom
} -setup {
	set v [verbose]
	customMatch negative [namespace code matchNegative]
} -body {
	verbose {}
	test tcltest-24.19.0 {} -match negative -body {format {A B C}} \
		-result {A B X}
} -cleanup {
	verbose $v
} -match exact -result {} -output {}

test tcltest-24.20 {
	test: -match custom	failure
} -setup {
	set fail $::tcltest::currentFailure
	set v [verbose]
	customMatch negative [namespace code matchNegative]
} -body {
	verbose {}
	test tcltest-24.20.0 {} -match negative -body {format {A B C}} \
		-result {A B C}
} -cleanup {
	set ::tcltest::currentFailure $fail
	verbose $v
} -match glob -result {} -output {*FAILED*Result was:
*(negative matching):
*}

test tcltest-25.1 {
	constraint of setup/cleanup (Bug 589859)
} -setup {
	set foo 0
} -body {
	# Buggy tcltest will generate result of 2
	test tcltest-25.1.0 {} -constraints knownBug -setup {
	    incr foo
	} -body {
	    incr foo
	} -cleanup {
	    incr foo
	} -match glob -result *
	set foo
} -cleanup {
	unset foo
} -result 0

test tcltest-25.2 {
	puts -nonewline (Bug 612786)
} -body {
	puts -nonewline stdout bla
	puts -nonewline stdout bla
} -output {blabla}

test tcltest-25.3 {
	reported return code (Bug 611922)
} -body {
	# Buggy tcltest will generate result of 2
	test tcltest-25.3.0 {} -body {
	    error foo
	}
} -match glob -output {*generated error; Return code was: 1*}

cleanupTests
}

namespace delete ::tcltest::test
return
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Tcl 8.3 upgrade
@
text
@@


1.1.1.2
log
@import tcl 8.4.0
@
text
@d1 5
d10 1
a10 2
# Copyright (c) 1998-1999 by Scriptics Corporation. 
# Copyright (c) 2000 by Ajuba Solutions
d13 1
a13 1
# RCS: @@(#) $Id: tcltest.test,v 1.34 2002/09/06 15:10:32 rmax Exp $
d15 3
a17 14
# Note that there are several places where the value of 
# tcltest::currentFailure is stored/reset in the -setup/-cleanup
# of a test that has a body that runs [test] that will fail.
# This is a workaround of using the same tcltest code that we are
# testing to run the test itself.  Ditto on things like [verbose].
#
# It would be better to have the -body of the tests run the tcltest
# commands in a slave interp so the [test] being tested would not
# interfere with the [test] doing the testing.  
#

if {[catch {package require tcltest 2.1}]} {
    puts stderr "Skipping tests in [info script].  tcltest 2.1 required."
    return
a19 4
namespace eval ::tcltest::test {

namespace import ::tcltest::*

d22 1
a22 1
    namespace import ::tcltest::test
d31 1
a31 4
    test d-1.0 {test d} {
	error "foo" foo 9
    } {}
    tcltest::cleanupTests
a34 2
cd [temporaryDirectory]
testConstraint exec [llength [info commands exec]]
d36 3
a38 3
# Child processes because -help [exit]s.
test tcltest-1.1 {tcltest -help} {exec} {
    set result [catch {exec [interpreter] test.tcl -help} msg]
d41 2
a42 2
test tcltest-1.2 {tcltest -help -something} {exec} {
    set result [catch {exec [interpreter] test.tcl -help -something} msg]
d45 2
a46 2
test tcltest-1.3 {tcltest -h} {exec} {
    set result [catch {exec [interpreter] test.tcl -h} msg]
d48 1
a48 1
} {1 0} 
d50 1
a50 37
# -verbose, implicit & explicit testing of [verbose]
proc slave {msgVar args} {
    upvar 1 $msgVar msg

    interp create [namespace current]::i
    # Fake the slave interp into dumping output to a file
    i eval {namespace eval ::tcltest {}}
    i eval "set tcltest::outputChannel \[open [makeFile {} output] w]"
    i eval "set tcltest::errorChannel \[open [makeFile {} error] w]"
    i eval [list set argv0 [lindex $args 0]]
    i eval [list set argv [lrange $args 1 end]]
    i eval [list package ifneeded tcltest [package provide tcltest] \
	    [package ifneeded tcltest [package provide tcltest]]]
    i eval {proc exit args {}}

    # Need to capture output in msg

    set code [catch {i eval {source $argv0}} foo]
if $code {
#puts "$code: $foo\n$::errorInfo"
}
    i eval {close $tcltest::outputChannel}
    interp delete [namespace current]::i
    set f [open [file join [temporaryDirectory] output]]
    set msg [read -nonewline $f]
    close $f
    set f [open [file join [temporaryDirectory] error]]
    set err [read -nonewline $f]
    close $f
    if {[string length $err]} {
	set code 1
	append msg \n$err
    }
    return $code

#    return [catch {uplevel 1 [linsert $args 0  exec [interpreter]]} msg]
}
d52 1
a52 1
    set result [slave msg test.tcl]
d55 1
a55 1
	    [regexp "Total.+4.+Passed.+1.+Skipped.+1.+Failed.+2" $msg]
d57 2
a58 2
test tcltest-2.1 {tcltest -verbose 'b'} {unixOrPc} {
    set result [slave msg test.tcl -verbose 'b']
d61 1
a61 1
	    [regexp "Total.+4.+Passed.+1.+Skipped.+1.+Failed.+2" $msg]
d63 2
a64 2
test tcltest-2.2 {tcltest -verbose 'p'} {unixOrPc} {
    set result [slave msg test.tcl -verbose 'p']
d67 1
a67 1
	    [regexp "Total.+4.+Passed.+1.+Skipped.+1.+Failed.+2" $msg]
d69 2
a70 2
test tcltest-2.3 {tcltest -verbose 's'} {unixOrPc} {
    set result [slave msg test.tcl -verbose 's']
d73 1
a73 1
	    [regexp "Total.+4.+Passed.+1.+Skipped.+1.+Failed.+2" $msg]
d75 2
a76 2
test tcltest-2.4 {tcltest -verbose 'ps'} {unixOrPc} {
    set result [slave msg test.tcl -verbose 'ps']
d79 1
a79 1
	    [regexp "Total.+4.+Passed.+1.+Skipped.+1.+Failed.+2" $msg]
d81 2
a82 2
test tcltest-2.5 {tcltest -verbose 'psb'} {unixOrPc} {
    set result [slave msg test.tcl -verbose 'psb']
d85 1
a85 1
	    [regexp "Total.+4.+Passed.+1.+Skipped.+1.+Failed.+2" $msg]
d88 1
a88 50
test tcltest-2.5a {tcltest -verbose 'pass skip body'} {unixOrPc} {
    set result [slave msg test.tcl -verbose "pass skip body"]
    list $result [regexp "Contents of test case" $msg] [regexp a-1.0 $msg] \
	    [regexp c-1.0 $msg] \
	    [regexp "Total.+4.+Passed.+1.+Skipped.+1.+Failed.+2" $msg]
} {0 1 1 1 1}

test tcltest-2.6 {tcltest -verbose 't'}  {
    -constraints {unixOrPc} 
    -body {
	set result [slave msg test.tcl -verbose 't']
	list $result $msg
    }
    -result {^0 .*a-1.0 start.*b-1.0 start}
    -match regexp
}

test tcltest-2.6a {tcltest -verbose 'start'}  {
    -constraints {unixOrPc} 
    -body {
	set result [slave msg test.tcl -verbose start]
	list $result $msg
    }
    -result {^0 .*a-1.0 start.*b-1.0 start}
    -match regexp
}

test tcltest-2.7 {tcltest::verbose}  {
    -body {
	set oldVerbosity [verbose]
	verbose bar
	set currentVerbosity [verbose]
	verbose foo
	set newVerbosity [verbose]
	verbose $oldVerbosity
	list $currentVerbosity $newVerbosity 
    }
    -result {body {}}
}

test tcltest-2.8 {tcltest -verbose 'error'} {
    -constraints {unixOrPc}
    -body {
	set result [slave msg test.tcl -verbose error]
	list $result $msg
    }
    -result {errorInfo: foo.*errorCode: 9}
    -match regexp
}
# -match, [match]
d90 1
a90 1
    set result [slave msg test.tcl -match a* -verbose 'ps']
d92 1
a92 1
	    [regexp "Total.+4.+Passed.+1.+Skipped.+3.+Failed.+0" $msg]
d95 1
a95 1
    set result [slave msg test.tcl -match b* -verbose 'ps']
d97 1
a97 1
	    [regexp "Total.+4.+Passed.+0.+Skipped.+3.+Failed.+1" $msg]
d100 1
a100 1
    set result [slave msg test.tcl -match c* -verbose 'ps']
d102 1
a102 1
	    [regexp "Total.+4.+Passed.+0.+Skipped.+4.+Failed.+0" $msg]
d105 1
a105 1
    set result [slave msg test.tcl -match {a* b*} -verbose 'ps']
d107 1
a107 1
	    [regexp "Total.+4.+Passed.+1.+Skipped.+2.+Failed.+1" $msg]
d110 1
a110 14
test tcltest-3.5 {tcltest::match}  {
    -body {
	set oldMatch [match]
	match foo
	set currentMatch [match]
	match bar
	set newMatch [match]
	match $oldMatch
	list $currentMatch $newMatch
    }
    -result {foo bar}
}
	
# -skip, [skip]
d112 1
a112 1
    set result [slave msg test.tcl -skip a* -verbose 'ps']
d114 1
a114 1
	    [regexp "Total.+4.+Passed.+0.+Skipped.+2.+Failed.+1" $msg]
d117 1
a117 1
    set result [slave msg test.tcl -skip b* -verbose 'ps']
d119 1
a119 1
	    [regexp "Total.+4.+Passed.+1.+Skipped.+2.+Failed.+1" $msg]
d122 1
a122 1
    set result [slave msg test.tcl -skip c* -verbose 'ps']
d124 1
a124 1
	    [regexp "Total.+4.+Passed.+1.+Skipped.+1.+Failed.+2" $msg]
d127 1
a127 1
    set result [slave msg test.tcl -skip {a* b*} -verbose 'ps']
d129 1
a129 1
	    [regexp "Total.+4.+Passed.+0.+Skipped.+3.+Failed.+1" $msg]
d132 1
a132 1
    set result [slave msg test.tcl -match {a* b*} -skip b* -verbose 'ps']
d134 1
a134 1
	    [regexp "Total.+4.+Passed.+1.+Skipped.+3.+Failed.+0" $msg]
d137 1
a137 15
test tcltest-4.6 {tcltest::skip} {
    -body {
	set oldSkip [skip]
	skip foo
	set currentSkip [skip]
	skip bar
	set newSkip [skip]
	skip $oldSkip
	list $currentSkip $newSkip
    }
    -result {foo bar}
}

# -constraints, -limitconstraints, [testConstraint],
# $constraintsSpecified, [limitConstraints]
d139 1
a139 1
    set result [slave msg test.tcl -constraints knownBug -verbose 'ps']
d141 1
a141 1
	    [regexp "Total.+4.+Passed.+2.+Skipped.+0.+Failed.+2" $msg]
d143 2
a144 2
test tcltest-5.2 {tcltest -constraints 'knownBug' -limitconstraints 1} {unixOrPc} {
    set result [slave msg test.tcl -constraints knownBug -verbose 'p' -limitconstraints 1]
d146 1
a146 1
	    [regexp "Total.+4.+Passed.+1.+Skipped.+3.+Failed.+0" $msg]
d149 1
a149 68
test tcltest-5.3 {testConstraint - constraint empty (tcltest::safeFetch)}  {
    -body {
	set r1 [testConstraint tcltestFakeConstraint]
	set r2 [testConstraint tcltestFakeConstraint 4]
	set r3 [testConstraint tcltestFakeConstraint]
	list $r1 $r2 $r3
    }
    -result {0 4 4}
    -cleanup {unset ::tcltest::testConstraints(tcltestFakeConstraint)}
}

# Removed this test of internals of tcltest.  Those internals have changed.
#test tcltest-5.4 {tcltest::constraintsSpecified} {
#    -setup {
#	set constraintlist $::tcltest::constraintsSpecified
#	set ::tcltest::constraintsSpecified {}
#    }
#    -body {
#	set r1 $::tcltest::constraintsSpecified
#	testConstraint tcltestFakeConstraint1 1
#	set r2 $::tcltest::constraintsSpecified
#	testConstraint tcltestFakeConstraint2 1
#	set r3 $::tcltest::constraintsSpecified
#	list $r1 $r2 $r3
#    }
#    -result {{} tcltestFakeConstraint1 {tcltestFakeConstraint1 tcltestFakeConstraint2}}
#    -cleanup {
#	set ::tcltest::constraintsSpecified $constraintlist
#	unset ::tcltest::testConstraints(tcltestFakeConstraint1) 
#	unset ::tcltest::testConstraints(tcltestFakeConstraint2) 
#    }
#}

test tcltest-5.5 {InitConstraints: list of built-in constraints} \
	-constraints {!singleTestInterp} \
	-setup {tcltest::InitConstraints} \
	-body { lsort [array names ::tcltest::testConstraints] } \
	-result [lsort {
    95 98 asyncPipeClose eformat emptyTest exec hasIsoLocale interactive
    knownBug mac macCrash macOnly macOrPc macOrUnix macOrWin nonBlockFiles
    nonPortable notRoot nt pc pcCrash pcOnly root singleTestInterp socket
    stdio tempNotMac tempNotPc tempNotUnix tempNotWin unix unixCrash unixExecs
    unixOnly unixOrPc unixOrWin userInteraction win winCrash winOnly
}]

# Removed this broken test.  Its usage of [limitConstraints] was not
# in agreement with the documentation.  [limitConstraints] is supposed
# to take an optional boolean argument, and "knownBug" ain't no boolean!
#test tcltest-5.6 {tcltest::limitConstraints} {
#    -setup {
#        set keeplc $::tcltest::limitConstraints
#        set keepkb [testConstraint knownBug]
#    }
#    -body {
#        set r1 [limitConstraints]
#        set r2 [limitConstraints knownBug]
#        set r3 [limitConstraints]
#        list $r1 $r2 $r3
#    }
#    -cleanup {
#        limitConstraints $keeplc
#        testConstraint knownBug $keepkb
#    }
#    -result {false knownBug knownBug}
#}

# -outfile, -errfile, [outputChannel], [outputFile], [errorChannel], [errorFile]
set printerror [makeFile {
d151 2
a152 2
    namespace import ::tcltest::*
    puts [outputChannel] "a test"
d162 1
a162 1
} printerror.tcl]
d164 7
a170 11
test tcltest-6.1 {tcltest -outfile, -errfile defaults} {
    -constraints unixOrPc
    -body {
	slave msg $printerror
	return $msg
    }
    -result {a test.*a really}
    -match regexp
}
test tcltest-6.2 {tcltest -outfile a.tmp} {unixOrPc unixExecs} {
    slave msg $printerror -outfile a.tmp
d176 2
a177 2
test tcltest-6.3 {tcltest -errfile a.tmp} {unixOrPc unixExecs} {
    slave msg $printerror -errfile a.tmp
d183 2
a184 2
test tcltest-6.4 {tcltest -outfile a.tmp -errfile b.tmp} {unixOrPc unixExecs} {
    slave msg printerror.tcl -outfile a.tmp -errfile b.tmp
d193 3
a195 77
test tcltest-6.5 {tcltest::errorChannel - retrieval} {
    -setup {
	set of [errorChannel]
	set ::tcltest::errorChannel stderr
    }
    -body {
	errorChannel
    }
    -result {stderr}
    -cleanup {
	set ::tcltest::errorChannel $of
    }
}

test tcltest-6.6 {tcltest::errorFile (implicit errorChannel)} {
    -setup {
	set ef [makeFile {} efile]
	set of [errorFile]
	set ::tcltest::errorChannel stderr
	set ::tcltest::errorFile stderr
    }
    -body {
	set f0 [errorChannel]
	set f1 [errorFile]
	set f2 [errorFile $ef]
	set f3 [errorChannel]
	set f4 [errorFile]
	subst {$f0;$f1;$f2;$f3;$f4} 
    }
    -result {stderr;stderr;.*efile;file[0-9a-f]+;.*efile}
    -match regexp
    -cleanup {
	errorFile $of
    }
}
test tcltest-6.7 {tcltest::outputChannel - retrieval} {
    -setup {
	set of [outputChannel]
	set ::tcltest::outputChannel stdout
    }
    -body {
	outputChannel
    }
    -result {stdout}
    -cleanup {
	set tcltest::outputChannel $of
    }
}

test tcltest-6.8 {tcltest::outputFile (implicit outputFile)} {
    -setup {
	set ef [makeFile {} efile]
	set of [outputFile]
	set ::tcltest::outputChannel stdout
	set ::tcltest::outputFile stdout
    }
    -body {
	set f0 [outputChannel]
	set f1 [outputFile]
	set f2 [outputFile $ef]
	set f3 [outputChannel]
	set f4 [outputFile]
	subst {$f0;$f1;$f2;$f3;$f4} 
    }
    -result {stdout;stdout;.*efile;file[0-9a-f]+;.*efile}
    -match regexp
    -cleanup {
	outputFile $of
    }
}

# -debug, [debug]
# Must use child processes to test -debug because it always writes
# messages to stdout, and we have no way to capture stdout of a
# slave interp
test tcltest-7.1 {tcltest test.tcl -debug 0} {unixOrPc} {
    catch {exec [interpreter] test.tcl -debug 0} msg
d198 2
a199 2
test tcltest-7.2 {tcltest test.tcl -debug 1} {unixOrPc} {
    catch {exec [interpreter] test.tcl -debug 1 -skip b*} msg
d203 2
a204 2
test tcltest-7.3 {tcltest test.tcl -debug 1} {unixOrPc} {
    catch {exec [interpreter] test.tcl -debug 1 -match b*} msg
d208 2
a209 2
test tcltest-7.4 {tcltest test.tcl -debug 2} {unixOrPc} {
    catch {exec [interpreter] test.tcl -debug 2} msg
d212 2
a213 2
test tcltest-7.5 {tcltest test.tcl -debug 3} {unixOrPc} {
    catch {exec [interpreter] test.tcl -debug 3} msg
a216 21
test tcltest-7.6 {tcltest::debug} {
    -setup {
	set old $::tcltest::debug
	set ::tcltest::debug 0
    }
    -body {
	set f1 [debug]
	set f2 [debug 1]
	set f3 [debug]
	set f4 [debug 2]
	set f5 [debug]
	list $f1 $f2 $f3 $f4 $f5
    }
    -result {0 1 1 2 2}
    -cleanup {
	set ::tcltest::debug $old
    }
}

# directory tests

d219 2
a220 2
    tcltest::makeFile {} a.tmp
    puts [tcltest::outputChannel] "testdir: [tcltest::testsDirectory]"
d224 1
a224 6
makeFile {} thisdirectoryisafile  

set normaldirectory [makeDirectory normaldirectory]
if {$::tcl_platform(platform) == "macintosh"} {
set normaldirectory [file normalize $normaldirectory]
}
d226 1
a226 1
# -tmpdir, [temporaryDirectory]
d229 1
a229 1
    slave msg a.tcl -tmpdir thisdirectorydoesnotexist
d233 5
a237 9
test tcltest-8.2 {tcltest a.tcl -tmpdir thisdirectoryisafile} {
    -constraints unixOrPc
    -body {
	slave msg a.tcl -tmpdir thisdirectoryisafile
	set msg
    }
    -result {*not a directory*}
    -match glob
}
d239 3
a241 3
# Test non-writeable directories, non-readable directories with directory flags
set notReadableDir [file join [temporaryDirectory] notreadable]
set notWriteableDir [file join [temporaryDirectory] notwriteable]
d243 2
a244 2
makeDirectory notreadable
makeDirectory notwriteable
d252 1
a252 1
	catch {file attributes $notWriteableDir -readonly 1}
d256 4
a259 3
test tcltest-8.3 {tcltest a.tcl -tmpdir notReadableDir} {unixOnly nonRoot} {
    slave msg a.tcl -tmpdir $notReadableDir 
    string match {*not readable*} $msg
d262 4
a265 3
test tcltest-8.4 {tcltest a.tcl -tmpdir notWriteableDir} {unixOrPc nonRoot} {
    slave msg a.tcl -tmpdir $notWriteableDir
    string match {*not writeable*} $msg
d268 2
a269 40
test tcltest-8.5 {tcltest a.tcl -tmpdir normaldirectory} {unixOrPc} {
    slave msg a.tcl -tmpdir $normaldirectory
    # The join is necessary because the message can be split on multiple lines
    list [file exists [file join $normaldirectory a.tmp]] \
	    [file delete [file join $normaldirectory a.tmp]] 
} {1 {}}   
cd [workingDirectory]

test tcltest-8.6 {temporaryDirectory}  {
    -setup {
	set old $::tcltest::temporaryDirectory
	set ::tcltest::temporaryDirectory $normaldirectory
    }
    -body {
	set f1 [temporaryDirectory]
	set f2 [temporaryDirectory [workingDirectory]]
	set f3 [temporaryDirectory]
	list $f1 $f2 $f3
    }
    -result "[list $normaldirectory [workingDirectory] [workingDirectory]]"
    -cleanup {
	set ::tcltest::temporaryDirectory $old
    }
}

test tcltest-8.6a {temporaryDirectory - test format 2} -setup {
    set old $::tcltest::temporaryDirectory
    set ::tcltest::temporaryDirectory $normaldirectory
} -body {
    set f1 [temporaryDirectory]
    set f2 [temporaryDirectory [workingDirectory]]
    set f3 [temporaryDirectory]
    list $f1 $f2 $f3
} -cleanup {
    set ::tcltest::temporaryDirectory $old
} -result [list $normaldirectory [workingDirectory] [workingDirectory]]

cd [temporaryDirectory]
# -testdir, [testsDirectory]
test tcltest-8.10 {tcltest a.tcl -testdir thisdirectorydoesnotexist} {unixOrPc} {
d271 2
a272 2
    slave msg a.tcl -testdir thisdirectorydoesnotexist
    string match "*does not exist*" $msg
d275 4
a278 3
test tcltest-8.11 {tcltest a.tcl -testdir thisdirectoryisafile} {unixOrPc} {
    slave msg a.tcl -testdir thisdirectoryisafile
    string match "*not a directory*" $msg 
d281 4
a284 3
test tcltest-8.12 {tcltest a.tcl -testdir notReadableDir} {unixOnly nonRoot} {
    slave msg a.tcl -testdir $notReadableDir 
    string match {*not readable*} $msg
a287 56
test tcltest-8.13 {tcltest a.tcl -testdir normaldirectory} {unixOrPc} {
    slave msg a.tcl -testdir $normaldirectory
    # The join is necessary because the message can be split on multiple lines
    list [string first "testdir: $normaldirectory" [join $msg]] \
	    [file exists [file join [temporaryDirectory] a.tmp]] \
	    [file delete [file join [temporaryDirectory] a.tmp]] 
} {0 1 {}} 
cd [workingDirectory]

set current [pwd]
test tcltest-8.14 {testsDirectory} {
    -setup {
	set old $::tcltest::testsDirectory
	set ::tcltest::testsDirectory $normaldirectory
    }
    -body {
	set f1 [testsDirectory]
	set f2 [testsDirectory $current]
	set f3 [testsDirectory]
	list $f1 $f2 $f3
    }
    -result "[list $normaldirectory $current $current]"
    -cleanup {
	set ::tcltest::testsDirectory $old
    }
}

# [workingDirectory]
test tcltest-8.60 {::workingDirectory}  {
    -setup {
	set old $::tcltest::workingDirectory
	set current [pwd]
	set ::tcltest::workingDirectory $normaldirectory
	cd $normaldirectory
    }
    -body {
	set f1 [workingDirectory]
	set f2 [pwd]
	set f3 [workingDirectory $current]
	set f4 [pwd] 
	set f5 [workingDirectory]
	list $f1 $f2 $f3 $f4 $f5
    }
    -result "[list $normaldirectory \
                   $normaldirectory \
                   $current \
                   $current \
                   $current]"
    -cleanup {
	set ::tcltest::workingDirectory $old
	cd $current
    }
}

# clean up from directory testing

d294 1
a294 1
	catch {file attributes $notWriteableDir -readonly 0}
d300 1
a300 1
# -file, -notfile, [matchFiles], [skipFiles]
d302 2
a303 1
    slave msg [file join [testsDirectory] all.tcl] -file a*.test
d307 3
a309 2
    slave msg [file join [testsDirectory] all.tcl] \
	    -file a*.test -notfile assocd*
a312 12
test tcltest-9.3 {matchFiles}  {
    -body {
	set old [matchFiles]
	matchFiles foo
	set current [matchFiles]
	matchFiles bar
	set new [matchFiles]
	matchFiles $old
	list $current $new
    } 
    -result {foo bar}
}
a313 12
test tcltest-9.4 {skipFiles} {
    -body {
	set old [skipFiles]
	skipFiles foo
	set current [skipFiles]
	skipFiles bar
	set new [skipFiles]
	skipFiles $old
	list $current $new
    } 
    -result {foo bar}
}
a314 1
# -preservecore, [preserveCore]
d317 2
a318 1
    namespace import ::tcltest::test
d327 1
a327 1
cd [temporaryDirectory]
d329 1
a329 1
    slave msg makecore.tcl -preservecore 0
d331 1
a331 1
    regexp "Core file produced" $msg
d334 1
a334 1
    slave msg makecore.tcl -preservecore 1
d336 1
a336 1
    regexp "Core file produced" $msg
d339 1
a339 1
    slave msg makecore.tcl -preservecore 2
d341 1
a341 1
    list [regexp "Core file produced" $msg] [regexp "Moving file to" $msg] \
d345 1
a345 1
    slave msg makecore.tcl -preservecore 3
d347 1
a347 1
    list [regexp "Core file produced" $msg] [regexp "Moving file to" $msg] \
d351 1
a351 16
# Removing this test.  It makes no sense to test the ability of
# [preserveCore] to accept an invalid value that will cause errors
# in other parts of tcltest's operation.
#test tcltest-10.5 {preserveCore} {
#    -body {
#	set old [preserveCore]
#	set result [preserveCore foo]
#	set result2 [preserveCore]
#	preserveCore $old
#	list $result $result2
#    }
#    -result {foo foo}
#}

# -load, -loadfile, [loadScript], [loadFile]
set contents { 
d353 2
a354 2
    namespace import tcltest::*
    puts [outputChannel] $::tcltest::loadScript
d356 1
a356 108
} 
set loadfile [makeFile $contents load.tcl]

test tcltest-12.1 {-load xxx} {unixOrPc} {
    slave msg load.tcl -load xxx
    set msg
} {xxx}

# Using child process because of -debug usage.
test tcltest-12.2 {-loadfile load.tcl} {unixOrPc} {
    catch {exec [interpreter] load.tcl -debug 2 -loadfile load.tcl} msg
    list \
	    [regexp {tcltest} [join [list $msg] [split $msg \n]]] \
	    [regexp {loadScript} [join [list $msg] [split $msg \n]]]
} {1 1}

test tcltest-12.3 {loadScript} {
    -setup {
	set old $::tcltest::loadScript
    }
    -body {
	set f1 [loadScript]
	set f2 [loadScript xxx]
	set f3 [loadScript]
	list $f1 $f2 $f3
    }
    -result {{} xxx xxx}
    -cleanup {
	set ::tcltest::loadScript $old
    }
}

test tcltest-12.4 {loadFile} {
    -setup {
	set olds $::tcltest::loadScript
	set oldf $::tcltest::loadFile
	set ::tcltest::loadFile {}
    }
    -body {
	set f1 [loadScript]
	set f2 [loadFile]
	set f3 [loadFile load.tcl]
	set f4 [loadScript]
	set f5 [loadFile]
	list $f1 $f2 $f3 $f4 $f5
    }
    -result "[list {} {} $loadfile $contents $loadfile]\n"
    -cleanup {
	set ::tcltest::loadScript $olds
	set ::tcltest::loadFile $oldf
    }
}

# [interpreter]
test tcltest-13.1 {interpreter} {
    -setup {
	set old $::tcltest::tcltest
	set ::tcltest::tcltest tcltest
    }
    -body {
	set f1 [interpreter]
	set f2 [interpreter tclsh]
	set f3 [interpreter]
	list $f1 $f2 $f3
    }
    -result {tcltest tclsh tclsh}
    -cleanup {
	set ::tcltest::tcltest $old
    }
}

# -singleproc, [singleProcess]
makeDirectory singleprocdir
makeFile {
    set foo 1
} [file join singleprocdir single1.test]

makeFile {
    unset foo
} [file join singleprocdir single2.test]

set allfile [makeFile {
    package require tcltest
    namespace import tcltest::*
    testsDirectory [file join [temporaryDirectory] singleprocdir]
    runAllTests
} [file join singleprocdir all-single.tcl]]
cd [workingDirectory]

test tcltest-14.1 {-singleproc - single process} {
    -constraints {unixOrPc}
    -body {
	slave msg $allfile -singleproc 0 -tmpdir [temporaryDirectory]
	set msg
    }
    -result {Test file error: can't unset .foo.: no such variable}
    -match regexp
}

test tcltest-14.2 {-singleproc - multiple process} {
    -constraints {unixOrPc}
    -body {
	slave msg $allfile -singleproc 1 -tmpdir [temporaryDirectory]
	set msg
    }
    -result {single1.test.*single2.test.*all\-single.tcl:.*Total.*0.*Passed.*0.*Skipped.*0.*Failed.*0}
    -match regexp
}
d358 5
a362 16
test tcltest-14.3 {singleProcess} {
    -setup {
	set old $::tcltest::singleProcess
	set ::tcltest::singleProcess 0
    }
    -body {
	set f1 [singleProcess]
	set f2 [singleProcess 1]
	set f3 [singleProcess]
	list $f1 $f2 $f3
    }
    -result {0 1 1}
    -cleanup {
	set ::tcltest::singleProcess $old
    }
}
d364 4
a367 1
# -asidefromdir, -relateddir, [matchDirectories], [skipDirectories]
d369 4
a372 2
# Before running these tests, need to set up test subdirectories with their own
# all.tcl files.
d374 1
a374 4
makeDirectory dirtestdir
makeDirectory [file join dirtestdir dirtestdir2.1]
makeDirectory [file join dirtestdir dirtestdir2.2]
makeDirectory [file join dirtestdir dirtestdir2.3]
d377 4
a380 36
    namespace import -force tcltest::*
    testsDirectory [file join [temporaryDirectory] dirtestdir]
    runAllTests
} [file join dirtestdir all.tcl]
makeFile {
    package require tcltest
    namespace import -force tcltest::*
    testsDirectory [file join [temporaryDirectory] dirtestdir dirtestdir2.1]
    runAllTests
} [file join dirtestdir dirtestdir2.1 all.tcl]
makeFile {
    package require tcltest
    namespace import -force tcltest::*
    testsDirectory [file join [temporaryDirectory]  dirtestdir dirtestdir2.2]
    runAllTests
} [file join dirtestdir dirtestdir2.2 all.tcl]
makeFile {
    package require tcltest
    namespace import -force tcltest::*
    testsDirectory [file join [temporaryDirectory] dirtestdir dirtestdir2.3]
    runAllTests
} [file join dirtestdir dirtestdir2.3 all.tcl]

test tcltest-15.1 {basic directory walking} {
    -constraints {unixOrPc}
    -body {
	if {[slave msg \
		[file join [temporaryDirectory] dirtestdir all.tcl] \
		-tmpdir [temporaryDirectory]] == 1} {
	    error $msg
	}
    }
    -match regexp
    -returnCodes 1
    -result {Tests located in:.*dirtestdir.*Tests located in:.*dirtestdir2.1.*Tests located in:.*dirtestdir2.2.*Tests located in:.*dirtestdir2.3}
}
d382 4
a385 17
test tcltest-15.2 {-asidefromdir} {
    -constraints {unixOrPc}
    -body {
	if {[slave msg \
		[file join [temporaryDirectory] dirtestdir all.tcl] \
		-asidefromdir dirtestdir2.3 \
		-tmpdir [temporaryDirectory]] == 1} {
	    error $msg
	}
    }
    -match regexp
    -returnCodes 1
    -result {Tests located in:.*dirtestdir.*Tests located in:.*dirtestdir2.1.*Tests located in:.*dirtestdir2.2.*dirtestdir2.2 test ended at .*~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
Error:  No test files remain after applying your match and skip patterns!
Error:  No test files remain after applying your match and skip patterns!
Error:  No test files remain after applying your match and skip patterns!$}
}
d387 6
a392 111
test tcltest-15.3 {-relateddir, non-existent dir} {
    -constraints {unixOrPc}
    -body {
	if {[slave msg \
		[file join [temporaryDirectory] dirtestdir all.tcl] \
		-relateddir [file join [temporaryDirectory] dirtestdir0] \
		-tmpdir [temporaryDirectory]] == 1} {
	    error $msg
	}
    }
    -returnCodes 1
    -match regexp
    -result {[^~]|dirtestdir[^2]}
}

test tcltest-15.4 {-relateddir, subdir} {
    -constraints {unixOrPc}
    -body {
	if {[slave msg \
		[file join [temporaryDirectory] dirtestdir all.tcl] \
		-relateddir dirtestdir2.1 -tmpdir [temporaryDirectory]] == 1} {
	    error $msg
	}
    }
    -returnCodes 1
    -match regexp
    -result {Tests located in:.*dirtestdir2.[^23]}
}
test tcltest-15.5 {-relateddir, -asidefromdir} {
    -constraints {unixOrPc}
    -body {
	if {[slave msg \
		[file join [temporaryDirectory] dirtestdir all.tcl] \
		-relateddir "dirtestdir2.1 dirtestdir2.2" \
		-asidefromdir dirtestdir2.2 \
		-tmpdir [temporaryDirectory]] == 1} {
	    error $msg
	}
    }
    -match regexp
    -returnCodes 1
    -result {Tests located in:.*dirtestdir2.[^23]}
}

test tcltest-15.6 {matchDirectories} {
    -setup {
	set old [matchDirectories]
	set ::tcltest::matchDirectories {}
    }
    -body {
	set r1 [matchDirectories]
	set r2 [matchDirectories foo]
	set r3 [matchDirectories]
	list $r1 $r2 $r3
    }
    -cleanup {
	set ::tcltest::matchDirectories $old
    }
    -result {{} foo foo}
}

test tcltest-15.7 {skipDirectories} {
    -setup {
	set old [skipDirectories]
	set ::tcltest::skipDirectories {}
    }
    -body {
	set r1 [skipDirectories]
	set r2 [skipDirectories foo]
	set r3 [skipDirectories]
	list $r1 $r2 $r3
    }
    -cleanup {
	set ::tcltest::skipDirectories $old
    }
    -result {{} foo foo}
}

# TCLTEST_OPTIONS
test tcltest-19.1 {TCLTEST_OPTIONS default} {
    -constraints {unixOrPc singleTestInterp}
    -setup {
	if {[info exists ::env(TCLTEST_OPTIONS)]} {
	    set oldoptions $::env(TCLTEST_OPTIONS)
	    unset ::env(TCLTEST_OPTIONS)
	} else {
	    set oldoptions none
	}
	# set this to { } instead of just {} to get around quirk in
	# Windows env handling that removes empty elements from env array.
	set ::env(TCLTEST_OPTIONS) { }
	set olddebug [debug]
	debug 2
    }
    -cleanup {
	if {$oldoptions == "none"} {
	    unset ::env(TCLTEST_OPTIONS) 
	} else {
	    set ::env(TCLTEST_OPTIONS) $oldoptions
	}
	debug $olddebug
    }
    -body {
	::tcltest::ProcessCmdLineArgs
	set ::env(TCLTEST_OPTIONS) "-debug 3"
	::tcltest::ProcessCmdLineArgs
    }
    -result {^$}
    -match regexp
    -output {tcltest::debug\s+= 2.*tcltest::debug\s+= 3}
}
a395 1
cd [temporaryDirectory]
d398 1
a398 1
    set result [slave msg printerror.tcl]
a402 1
cd [workingDirectory]
d404 3
a406 17
# test::test
test tcltest-21.0 {name and desc but no args specified} -setup {
    set v [verbose]
} -cleanup {
    verbose $v
} -body {
   verbose {}
   test tcltest-21.0.0 bar
} -result {}

test tcltest-21.1 {expect with glob} {
    -body {
	list a b c d e
    }
    -match glob
    -result {[ab] b c d e}
}
a407 574
test tcltest-21.2 {force a test command failure} {
    -body {
	test tcltest-21.2.0 {
	    return 2
	} {1}
    }
    -returnCodes 1
    -result {bad option "1": must be -body, -cleanup, -constraints, -errorOutput, -match, -output, -result, -returnCodes, or -setup}
}

test tcltest-21.3 {test command with setup} {
    -setup {
	set foo 1
    }
    -body {
	set foo
    }
    -cleanup {unset foo}
    -result {1}
}

test tcltest-21.4 {test command with cleanup failure} {
    -setup {
	if {[info exists foo]} {
	    unset foo
	}
	set fail $::tcltest::currentFailure
	set v [verbose]
    }
    -body {
	verbose {}
	test tcltest-21.4.0 {foo-1} {
	    -cleanup {unset foo}
	}
    }
    -result {^$}
    -match regexp
    -cleanup {verbose $v; set ::tcltest::currentFailure $fail}
    -output "Test cleanup failed:.*can't unset \"foo\": no such variable"
}

test tcltest-21.5 {test command with setup failure} {
    -setup {
	if {[info exists foo]} {
	    unset foo
	}
	set fail $::tcltest::currentFailure
    }
    -body {
	test tcltest-21.5.0 {foo-2} {
	    -setup {unset foo}
	}
    }
    -result {^$}
    -match regexp
    -cleanup {set ::tcltest::currentFailure $fail}
    -output "Test setup failed:.*can't unset \"foo\": no such variable"
}

test tcltest-21.6 {test command - setup occurs before cleanup & before script} {
    -setup {set v [verbose]; set fail $::tcltest::currentFailure}
    -body {
	verbose {}
	test tcltest-21.6.0 {foo-3} {
	    -setup {
		if {[info exists foo]} {
		    unset foo
		}
		set foo 1
		set expected 2
	    } 
	    -body {
		incr foo
		set foo
	    }
	    -cleanup {
		if {$foo != 2} {
		    puts [outputChannel] "foo is wrong"
		} else {
		    puts [outputChannel] "foo is 2"
		}
	    }
	    -result {$expected}
	}
    }
    -cleanup {verbose $v; set ::tcltest::currentFailure $fail}
    -result {^$}
    -match regexp
    -output "foo is 2"
}

test tcltest-21.7 {test command - bad flag} {
    -setup {set fail $::tcltest::currentFailure}
    -cleanup {set ::tcltest::currentFailure $fail}
    -body {
	test tcltest-21.7.0 {foo-4} {
	    -foobar {}
	}
    }
    -returnCodes 1
    -result {bad option "-foobar": must be -body, -cleanup, -constraints, -errorOutput, -match, -output, -result, -returnCodes, or -setup}
}

# alternate test command format (these are the same as 21.1-21.6, with the
# exception of being in the all-inline format)

test tcltest-21.7a {expect with glob} \
	-body {list a b c d e} \
	-result {[ab] b c d e} \
	-match glob

test tcltest-21.8 {force a test command failure} \
    -setup {set fail $::tcltest::currentFailure} \
    -body {
        test tcltest-21.8.0 {
            return 2
        } {1}
    } \
    -returnCodes 1 \
    -cleanup {set ::tcltest::currentFailure $fail} \
    -result {bad option "1": must be -body, -cleanup, -constraints, -errorOutput, -match, -output, -result, -returnCodes, or -setup}

test tcltest-21.9 {test command with setup} \
	-setup {set foo 1} \
	-body {set foo} \
	-cleanup {unset foo} \
	-result {1}

test tcltest-21.10 {test command with cleanup failure} -setup {
    if {[info exists foo]} {
	unset foo
    }
    set fail $::tcltest::currentFailure
    set v [verbose]
} -cleanup {
    verbose $v
    set ::tcltest::currentFailure $fail
} -body {
    verbose {}
    test tcltest-21.10.0 {foo-1} -cleanup {unset foo}
} -result {^$} -match regexp \
	-output {Test cleanup failed:.*can't unset \"foo\": no such variable}

test tcltest-21.11 {test command with setup failure} -setup {
    if {[info exists foo]} {
	unset foo
    }
    set fail $::tcltest::currentFailure
} -cleanup {set ::tcltest::currentFailure $fail} -body {
    test tcltest-21.11.0 {foo-2} -setup {unset foo}
} -result {^$} -output {Test setup failed:.*can't unset \"foo\": no such variable} -match regexp

test tcltest-21.12 {
	test command - setup occurs before cleanup & before script
} -setup {
	set fail $::tcltest::currentFailure
	set v [verbose]
} -cleanup {
	verbose $v
	set ::tcltest::currentFailure $fail
} -body {
    verbose {}
    test tcltest-21.12.0 {foo-3} -setup {
	if {[info exists foo]} {
	    unset foo
	}
	set foo 1
	set expected 2
    }  -body {
	incr foo
	set foo
    }  -cleanup {
	if {$foo != 2} {
	    puts [outputChannel] "foo is wrong"
	} else {
	    puts [outputChannel] "foo is 2"
	}
    }  -result {$expected}
} -result {^$} -output {foo is 2} -match regexp

# test all.tcl usage (runAllTests); simulate .test file failure, as well as
# crashes to determine whether or not these errors are logged.

makeDirectory alltestdir
makeFile {
    package require tcltest
    namespace import -force tcltest::*
    testsDirectory [file join [temporaryDirectory] alltestdir]
    runAllTests
} [file join alltestdir all.tcl]
makeFile {
    exit 1
} [file join alltestdir exit.test]
makeFile {
    error "throw an error"
} [file join alltestdir error.test]
makeFile {
    package require tcltest
    namespace import -force tcltest::*
    test foo-1.1 {foo} {
	-body { return 1 }
	-result {1}
    }
    cleanupTests
} [file join alltestdir test.test]

# Must use a child process because stdout/stderr parsing can't be
# duplicated in slave interp.
test tcltest-22.1 {runAllTests} {
    -constraints {unixOrPc}
    -body {
	exec [interpreter] \
		[file join [temporaryDirectory] alltestdir all.tcl] \
		-verbose t -tmpdir [temporaryDirectory]
    }
    -match regexp
    -result "Test files exiting with errors:.*error.test.*exit.test"
}

# makeFile, removeFile, makeDirectory, removeDirectory, viewFile
test tcltest-23.1 {makeFile} {
    -setup {
	set mfdir [file join [temporaryDirectory] mfdir]
	file mkdir $mfdir
    }
    -body {
	makeFile {} t1.tmp
	makeFile {} et1.tmp $mfdir
	list [file exists [file join [temporaryDirectory] t1.tmp]] \
		[file exists [file join $mfdir et1.tmp]]
    }
    -cleanup {
	file delete -force $mfdir \
		[file join [temporaryDirectory] t1.tmp] 
    }
    -result {1 1}
}
test tcltest-23.2 {removeFile} {
    -setup {
	set mfdir [file join [temporaryDirectory] mfdir]
	file mkdir $mfdir
	makeFile {} t1.tmp
	makeFile {} et1.tmp $mfdir
	if  {![file exists [file join [temporaryDirectory] t1.tmp]] || \
		![file exists [file join $mfdir et1.tmp]]} {
	    error "file creation didn't work"
	}
    }
    -body {
	removeFile t1.tmp
	removeFile et1.tmp $mfdir
	list [file exists [file join [temporaryDirectory] t1.tmp]] \
		[file exists [file join $mfdir et1.tmp]]
    }
    -cleanup {
	file delete -force $mfdir \
		[file join [temporaryDirectory] t1.tmp] 
    }
    -result {0 0}
}
test tcltest-23.3 {makeDirectory} {
    -body {
	set mfdir [file join [temporaryDirectory] mfdir]
	file mkdir $mfdir
	makeDirectory d1
	makeDirectory d2 $mfdir
	list [file exists [file join [temporaryDirectory] d1]] \
		[file exists [file join $mfdir d2]]
    }
    -cleanup {
	file delete -force [file join [temporaryDirectory] d1] $mfdir
    }
    -result {1 1}
}
test tcltest-23.4 {removeDirectory} {
    -body {
	set mfdir [file join [temporaryDirectory] mfdir]
	file mkdir $mfdir
	file mkdir [file join [temporaryDirectory] t1]
	file mkdir [file join [temporaryDirectory] $mfdir t2]
	if {![file exists $mfdir] || \
		![file exists [file join [temporaryDirectory] $mfdir t2]]} {
	    return "setup failed - directory not created"
	}
	removeDirectory t1
	removeDirectory t2 $mfdir
	list [file exists [file join [temporaryDirectory] t1]] \
		[file exists [file join $mfdir t2]]
    }
    -result {0 0}
}
test tcltest-23.5 {viewFile} {
    -body {
	set mfdir [file join [temporaryDirectory] mfdir]
	file mkdir $mfdir
	makeFile {foobar} t1.tmp
	makeFile {foobarbaz} t2.tmp $mfdir
	list [viewFile t1.tmp] [viewFile t2.tmp $mfdir]
    }
    -result {foobar foobarbaz}
    -cleanup {
	file delete -force $mfdir
    }
}

# customMatch
proc matchNegative { expected actual } {
   set match 0
   foreach a $actual e $expected {
      if { $a != $e } {
         set match 1
        break
      }
   }
   return $match
}

test tcltest-24.0 {
	customMatch: syntax
} -body {
	list [catch {customMatch} result] $result
} -result [list 1 "wrong # args: should be \"customMatch mode script\""]

test tcltest-24.1 {
	customMatch: syntax
} -body {
	list [catch {customMatch foo} result] $result
} -result [list 1 "wrong # args: should be \"customMatch mode script\""]

test tcltest-24.2 {
	customMatch: syntax
} -body {
	list [catch {customMatch foo bar baz} result] $result
} -result [list 1 "wrong # args: should be \"customMatch mode script\""]

test tcltest-24.3 {
	customMatch: argument checking
} -body {
	list [catch {customMatch bad "a \{ b"} result] $result
} -result [list 1 "invalid customMatch script; can't evaluate after completion"]

test tcltest-24.4 {
	test: valid -match values
} -body {
	list [catch {
		test tcltest-24.4.0 {} \
			-match [namespace current]::noSuchMode
	} result] $result
} -match glob -result {1 *bad -match value*}

test tcltest-24.5 {
	test: valid -match values
} -setup {
	customMatch [namespace current]::alwaysMatch "format 1 ;#"
} -body {
	list [catch {
		test tcltest-24.5.0 {} \
			-match [namespace current]::noSuchMode
	} result] $result
} -match glob -result {1 *bad -match value*: must be *alwaysMatch,*}

test tcltest-24.6 {
	customMatch: -match script that always matches
} -setup {
	customMatch [namespace current]::alwaysMatch "format 1 ;#"
	set v [verbose]
} -body {
	verbose {}
	test tcltest-24.6.0 {} -match [namespace current]::alwaysMatch \
		-body {format 1} -result 0
} -cleanup {
	verbose $v
} -result {} -output {} -errorOutput {}

test tcltest-24.7 {
	customMatch: replace default -exact matching
} -setup {
	set saveExactMatchScript $::tcltest::CustomMatch(exact)
	customMatch exact "format 1 ;#"
	set v [verbose]
} -body {
	verbose {}
	test tcltest-24.7.0 {} -body {format 1} -result 0
} -cleanup {
	verbose $v
	customMatch exact $saveExactMatchScript
	unset saveExactMatchScript
} -result {} -output {}

test tcltest-24.9 {
	customMatch: error during match
} -setup {
	proc errorDuringMatch args {return -code error "match returned error"}
	customMatch [namespace current]::errorDuringMatch \
		[namespace code errorDuringMatch]
	set v [verbose]
	set fail $::tcltest::currentFailure
} -body {
	verbose {}
	test tcltest-24.9.0 {} -match [namespace current]::errorDuringMatch
} -cleanup {
	verbose $v
	set ::tcltest::currentFailure $fail
} -match glob -result {} -output {*FAILED*match returned error*}

test tcltest-24.10 {
	customMatch: bad return from match command
} -setup {
	proc nonBooleanReturn args {return foo}
	customMatch nonBooleanReturn [namespace code nonBooleanReturn]
	set v [verbose]
	set fail $::tcltest::currentFailure
} -body {
	verbose {}
	test tcltest-24.10.0 {} -match nonBooleanReturn
} -cleanup {
	verbose $v
	set ::tcltest::currentFailure $fail
} -match glob -result {} -output {*FAILED*expected boolean value*}

test tcltest-24.11 {
	test: -match exact
} -body {
	set result {A B C}
} -match exact -result {A B C}

test tcltest-24.12 {
	test: -match exact	match command eval in ::, not caller namespace
} -setup {
	set saveExactMatchScript $::tcltest::CustomMatch(exact)
	customMatch exact [list string equal]
	set v [verbose]
	proc string args {error {called [string] in caller namespace}}
} -body {
	verbose {}
	test tcltest-24.12.0 {} -body {format 1} -result 1
} -cleanup {
	rename string {}
	verbose $v
	customMatch exact $saveExactMatchScript
	unset saveExactMatchScript
} -match exact -result {} -output {}

test tcltest-24.13 {
	test: -match exact	failure
} -setup {
	set saveExactMatchScript $::tcltest::CustomMatch(exact)
	customMatch exact [list string equal]
	set v [verbose]
	set fail $::tcltest::currentFailure
} -body {
	verbose {}
	test tcltest-24.13.0 {} -body {format 1} -result 0
} -cleanup {
	set ::tcltest::currentFailure $fail
	verbose $v
	customMatch exact $saveExactMatchScript
	unset saveExactMatchScript
} -match glob -result {} -output {*FAILED*Result was:
1*(exact matching):
0*}

test tcltest-24.14 {
	test: -match glob
} -body {
	set result {A B C}
} -match glob -result {A B*}

test tcltest-24.15 {
	test: -match glob	failure
} -setup {
	set v [verbose]
	set fail $::tcltest::currentFailure
} -body {
	verbose {}
	test tcltest-24.15.0 {} -match glob -body {format {A B C}} \
		-result {A B* }
} -cleanup {
	set ::tcltest::currentFailure $fail
	verbose $v
} -match glob -result {} -output {*FAILED*Result was:
*(glob matching):
*}

test tcltest-24.16 {
	test: -match regexp
} -body {
	set result {A B C}
} -match regexp -result {A B.*}

test tcltest-24.17 {
	test: -match regexp	failure
} -setup {
	set fail $::tcltest::currentFailure
	set v [verbose]
} -body {
	verbose {}
	test tcltest-24.17.0 {} -match regexp -body {format {A B C}} \
		-result {A B.* X}
} -cleanup {
	set ::tcltest::currentFailure $fail
	verbose $v
} -match glob -result {} -output {*FAILED*Result was:
*(regexp matching):
*}

test tcltest-24.18 {
	test: -match custom	forget namespace qualification
} -setup {
	set fail $::tcltest::currentFailure
	set v [verbose]
	customMatch negative matchNegative
} -body {
	verbose {}
	test tcltest-24.18.0 {} -match negative -body {format {A B C}} \
		-result {A B X}
} -cleanup {
	set ::tcltest::currentFailure $fail
	verbose $v
} -match glob -result {} -output {*FAILED*Error testing result:*}

test tcltest-24.19 {
	test: -match custom
} -setup {
	set v [verbose]
	customMatch negative [namespace code matchNegative]
} -body {
	verbose {}
	test tcltest-24.19.0 {} -match negative -body {format {A B C}} \
		-result {A B X}
} -cleanup {
	verbose $v
} -match exact -result {} -output {}

test tcltest-24.20 {
	test: -match custom	failure
} -setup {
	set fail $::tcltest::currentFailure
	set v [verbose]
	customMatch negative [namespace code matchNegative]
} -body {
	verbose {}
	test tcltest-24.20.0 {} -match negative -body {format {A B C}} \
		-result {A B C}
} -cleanup {
	set ::tcltest::currentFailure $fail
	verbose $v
} -match glob -result {} -output {*FAILED*Result was:
*(negative matching):
*}

test tcltest-25.1 {
	constraint of setup/cleanup (Bug 589859)
} -setup {
	set foo 0
} -body {
	# Buggy tcltest will generate result of 2
	test tcltest-25.1.0 {} -constraints knownBug -setup {
	    incr foo
	} -body {
	    incr foo
	} -cleanup {
	    incr foo
	} -match glob -result *
	set foo
} -cleanup {
	unset foo
} -result 0

cleanupTests
}

namespace delete ::tcltest::test
return
@


1.1.1.3
log
@import tcl 8.4.1
@
text
@d9 1
a9 1
# RCS: @@(#) $Id: tcltest.test,v 1.35 2002/09/22 18:19:26 dgp Exp $
a1687 16

test tcltest-25.2 {
	puts -nonewline (Bug 612786)
} -body {
	puts -nonewline stdout bla
	puts -nonewline stdout bla
} -output {blabla}

test tcltest-25.3 {
	reported return code (Bug 611922)
} -body {
	# Buggy tcltest will generate result of 2
	test tcltest-25.3.0 {} -body {
	    error foo
	}
} -match glob -output {*generated error; Return code was: 1*}
@


