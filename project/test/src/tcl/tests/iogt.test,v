head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.60
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.58
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.56
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.54
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.52
	gdb_7_0-branch:1.5.0.50
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tcl8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.48
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.46
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.44
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.42
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.40
	gdb_6_5-2006-05-14-branchpoint:1.5
	readline_5_1-import-branch:1.5.0.38
	readline_5_1-import-branchpoint:1.5
	gdb_6_4-branch:1.5.0.36
	gdb_6_4-2005-11-01-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.34
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	ezannoni_pie-20040323-branch:1.5.0.32
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.30
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.28
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.26
	gdb_5_1-2001-07-29-branch:1.5.0.24
	cagney_x86i386-20030821-branch:1.5.0.22
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.20
	gdb_6_0-2003-06-23-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.18
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.16
	cagney_writestrings-20030508-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.14
	cagney_fileio-20030521-branchpoint:1.5
	carlton_dictionary-20030430-merge:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.12
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.10
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.8
	cagney_lazyid-20030317-branchpoint:1.5
	offbyone-20030313-branch:1.5.0.6
	offbyone-20030313-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.4
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.2
	interps-20030202-branchpoint:1.5
	TCL8_4_1:1.1.1.2
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.2
	TCL_8_4_1:1.1.1.2
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.4
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TCL_8_4_0:1.1.1.2
	carlton_dictionary-branch:1.2.0.16
	carlton_dictionary-20020920-branchpoint:1.2
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.14
	gdb_5_3-branch:1.2.0.12
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.10
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.8
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.6
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	cygnus_cvs_20020108_pre:1.2
	TCL_8_3:1.1.1.1
	NET:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2003.01.21.19.40.15;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.26.19.48.01;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.37.07;	author kseitz;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2001.09.09.23.56.08;	author irox;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	2001.09.09.22.40.58;	author irox;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2002.09.27.21.49.10;	author kseitz;	state Exp;
branches;
next	;

1.3.4.1
date	2003.12.14.20.28.49;	author drow;	state Exp;
branches;
next	;

1.2.16.1
date	2002.12.23.19.40.41;	author carlton;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2003.02.07.19.18.19;	author carlton;	state Exp;
branches;
next	;

1.1.1.1
date	2001.09.09.22.40.58;	author irox;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.24.19.56.37;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tcl 8.4.1
@
text
@# -*- tcl -*-
# Commands covered:  transform, and stacking in general
#
# This file contains a collection of tests for Giot
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
# 
# Copyright (c) 2000 Ajuba Solutions.
# Copyright (c) 2000 Andreas Kupries.
# All rights reserved.
# 
# RCS: @@(#) $Id: iogt.test,v 1.7 2002/07/04 15:46:55 andreas_kupries Exp $

if {[catch {package require tcltest 2.1}]} {
    puts stderr "Skipping tests in [info script].  tcltest 2.1 required."
    return
}
namespace eval ::tcl::test::iogt {

    namespace import ::tcltest::cleanupTests
    namespace import ::tcltest::makeFile
    namespace import ::tcltest::removeFile
    namespace import ::tcltest::test
    namespace import ::tcltest::testConstraint

    testConstraint testchannel [llength [info commands testchannel]]

set path(dummy) [makeFile {abcdefghijklmnopqrstuvwxyz0123456789,./?><;'\|":[]\}\{`~!@@#$%^&*()_+-=
} dummy]

# " capture coloring of quotes

set path(dummyout) [makeFile {} dummyout]

set path(__echo_srv__.tcl) [makeFile {
#!/usr/local/bin/tclsh
# -*- tcl -*-
# echo server
#
# arguments, options: port to listen on for connections.
#                     delay till echo of first block
#                     delay between blocks
#                     blocksize ...

set port   [lindex $argv 0]
set fdelay [lindex $argv 1]
set idelay [lindex $argv 2]
set bsizes [lrange $argv 3 end]
set c      0

proc newconn {sock rhost rport} {
    variable fdelay
    variable c
    incr   c
    variable c$c

    #puts stdout "C $sock $rhost $rport / $fdelay" ; flush stdout

    upvar 0 c$c conn
    set conn(after) {}
    set conn(state) 0
    set conn(size)  0
    set conn(data)  ""
    set conn(delay) $fdelay

    fileevent  $sock readable [list echoGet $c $sock]
    fconfigure $sock -translation binary -buffering none -blocking 0
}

proc echoGet {c sock} {
    variable fdelay
    variable c$c
    upvar 0 c$c conn

    if {[eof $sock]} {
	# one-shot echo
	exit
    }

    append conn(data) [read $sock]

    #puts stdout "G $c $sock $conn(data) <<$conn(data)>>" ; flush stdout

    if {$conn(after) == {}} {
	set conn(after) [after $conn(delay) [list echoPut $c $sock]]
    }
}

proc echoPut {c sock} {
    variable idelay
    variable fdelay
    variable bsizes
    variable c$c
    upvar 0 c$c conn

    if {[string length $conn(data)] == 0} {
	#puts stdout "C $c $sock" ; flush stdout
	# auto terminate
	close $sock
	exit
	#set conn(delay) $fdelay
	return
    }


    set conn(delay) $idelay

    set n [lindex $bsizes $conn(size)]

    #puts stdout "P $c $sock $n >>" ; flush stdout

    #puts __________________________________________
    #parray conn
    #puts n=<$n>


    if {[string length $conn(data)] >= $n} {
	puts -nonewline $sock [string range $conn(data) 0 $n]
	set conn(data) [string range $conn(data) [incr n] end]
    }

    incr conn(size)
    if {$conn(size) >= [llength $bsizes]} {
	set conn(size) [expr {[llength $bsizes]-1}]
    }

    set conn(after) [after $conn(delay) [list echoPut $c $sock]]
}

#fileevent stdin readable {exit ;#cut}

# main
socket -server newconn $port
vwait forever
} __echo_srv__.tcl]


########################################################################

proc fevent {fdelay idelay blocks script data} {
    # start and initialize an echo server, prepare data
    # transmission, then hand over to the test script.
    # this has to start real transmission via 'flush'.
    # The server is stopped after completion of the test.

    # fixed port, not so good. lets hope for the best, for now.
    set port 4000

    eval exec tclsh __echo_srv__.tcl \
	    $port $fdelay $idelay $blocks >@@stdout &

    after 500

    #puts stdout "> $port" ; flush stdout

    set         sk [socket localhost $port]
    fconfigure $sk           \
	    -blocking   0    \
	    -buffering  full \
	    -buffersize [expr {10+[llength $data]}]

    puts -nonewline $sk $data

    # The channel is prepared to go off.

    #puts stdout ">>>>>" ; flush stdout

    uplevel #0 set sock $sk
    set res [uplevel #0 $script]

    catch {close $sk}
    return $res
}

# --------------------------------------------------------------
# utility transformations ...

proc id {op data} {
    switch -- $op {
	create/write -
	create/read  -
	delete/write -
	delete/read  -
	clear_read   {;#ignore}
	flush/write -
	flush/read  -
	write       -
	read        {
	    return $data
	}
	query/maxRead {return -1}
    }
}

proc id_optrail {var op data} {
    variable $var
    upvar 0 $var trail

    lappend trail $op

    switch -- $op {
	create/write	-	create/read	-
	delete/write	-	delete/read	-
	flush/read	-
	clear/read	{ #ignore }
	flush/write	-
	write		-
	read		{
	    return $data
	}
	query/maxRead	{
	    return -1
	}
	default		{
	    lappend trail "error $op"
	    error $op
	}
    }
}


proc id_fulltrail {var op data} {
    variable $var
    upvar 0 $var trail

    #puts stdout ">> $var $op $data" ; flush stdout

    switch -- $op {
	create/write -	create/read  -
	delete/write -	delete/read  -
	clear_read   {
	    set res *ignored*
	}
	flush/write -	flush/read  -
	write       -
	read        {
	    set res $data
	}
	query/maxRead {
	    set res -1
	}
    }

    #catch {puts stdout "\t>* $res" ; flush stdout}
    #catch {puts stdout "x$res"} msg

    lappend trail [list $op $data $res]
    return $res
}

proc counter {var op data} {
    variable $var
    upvar 0 $var n

    switch -- $op {
	create/write -	create/read  -
	delete/write -	delete/read  -
	clear_read   {;#ignore}
	flush/write  -	flush/read   {return {}}
	write {
	    return $data
	}
	read  {
	    if {$n > 0} {
		incr n -[string length $data]
		if {$n < 0} {
		    set n 0
		}
	    }
	    return $data
	}
	query/maxRead {
	    return $n
	}
    }
}


proc counter_audit {var vtrail op data} {
    variable $var
    variable $vtrail
    upvar 0 $var n $vtrail trail

    switch -- $op {
	create/write -	create/read  -
	delete/write -	delete/read  -
	clear_read   {
	    set res {}
	}
	flush/write  -	flush/read   {
	    set res {}
	}
	write {
	    set res $data
	}
	read  {
	    if {$n > 0} {
		incr n -[string length $data]
		if {$n < 0} {
		    set n 0
		}
	    }
	    set res $data
	}
	query/maxRead {
	    set res $n
	}
    }

    lappend trail [list counter:$op $data $res]
    return $res
}


proc rblocks {var vtrail n op data} {
    variable $var
    variable $vtrail
    upvar 0 $var buf $vtrail trail

    set res {}

    switch -- $op {
	create/write -	create/read  -
	delete/write -	delete/read  -
	clear_read   {
	    set buf {}
	}
	flush/write {
	}
	flush/read  {
	    set res $buf
	    set buf {}
	}
	write       {
	    set data
	}
	read        {
	    append buf $data

	    set b [expr {$n * ([string length $buf] / $n)}]

	    append op " $n [string length $buf] :- $b"

	    set res [string range $buf 0 [incr b -1]]
	    set buf [string range $buf [incr b] end]
	    #return $res
	}
	query/maxRead {
	    set res -1
	}
    }

    lappend trail [list rblock | $op $data $res | $buf]
    return $res
}


# --------------------------------------------------------------
# ... and convenience procedures to stack them

proc identity {-attach channel} {
    testchannel transform $channel -command [namespace code id]
}

proc audit_ops {var -attach channel} {
    testchannel transform $channel -command [namespace code [list id_optrail $var]]
}

proc audit_flow {var -attach channel} {
    testchannel transform $channel -command [namespace code [list id_fulltrail $var]]
}

proc stopafter {var n -attach channel} {
    variable $var
    upvar 0 $var vn
    set vn $n
    testchannel transform $channel -command [namespace code [list counter $var]]
}

proc stopafter_audit {var trail n -attach channel} {
    variable $var
    upvar 0 $var vn
    set vn $n
    testchannel transform $channel -command [namespace code [list counter_audit $var $trail]]
}

proc rblocks_t {var trail n -attach channel} {
    testchannel transform $channel -command [namespace code [list rblocks $var $trail $n]]
}

# --------------------------------------------------------------
# serialize an array, with keys in sorted order.

proc array_sget {v} {
    upvar $v a

    set res [list]
    foreach n [lsort [array names a]] {
	lappend res $n $a($n)
    }
    set res
}

proc asort {alist} {
    # sort a list of key/value pairs by key, removes duplicates too.

    array set  a $alist
    array_sget a
}

########################################################################

test iogt-1.1 {stack/unstack} testchannel {
    set fh [open $path(dummy) r]
    identity -attach $fh
    testchannel unstack $fh
    close   $fh
} {}

test iogt-1.2 {stack/close} testchannel {
    set fh [open $path(dummy) r]
    identity -attach $fh
    close   $fh
} {}

test iogt-1.3 {stack/unstack, configuration, options} testchannel {
    set fh [open $path(dummy) r]
    set ca [asort [fconfigure $fh]]
    identity -attach $fh
    set cb [asort [fconfigure $fh]]
    testchannel unstack $fh
    set cc [asort [fconfigure $fh]]
    close $fh

    # With this system none of the buffering, translation and
    # encoding option may change their values with channels
    # stacked upon each other or not.

    # cb == ca == cc

    list [string equal $ca $cb] [string equal $cb $cc] [string equal $ca $cc]
} {1 1 1}

test iogt-1.4 {stack/unstack, configuration} testchannel {
    set fh [open $path(dummy) r]
    set ca [asort [fconfigure $fh]]
    identity -attach $fh
    fconfigure $fh \
	    -buffering   line \
	    -translation cr   \
	    -encoding    shiftjis
    testchannel unstack $fh
    set cc [asort [fconfigure $fh]]

    set res [list \
	    [string equal $ca $cc]   \
	    [fconfigure $fh -buffering]  \
	    [fconfigure $fh -translation] \
	    [fconfigure $fh -encoding]    \
	    ]

    close $fh
    set res
} {0 line cr shiftjis}

test iogt-2.0 {basic I/O going through transform} testchannel {
    set fin  [open $path(dummy)    r]
    set fout [open $path(dummyout) w]

    identity -attach $fin
    identity -attach $fout

    fcopy $fin $fout

    close $fin
    close $fout

    set fin  [open $path(dummy)    r]
    set fout [open $path(dummyout) r]

    set res     [string equal [set in [read $fin]] [set out [read $fout]]]
    lappend res [string length $in] [string length $out]

    close $fin
    close $fout

    set res
} {1 71 71}


test iogt-2.1 {basic I/O, operation trail} {testchannel unixOnly} {
    set fin  [open $path(dummy)    r]
    set fout [open $path(dummyout) w]

    set ain [list] ; set aout [list]
    audit_ops ain  -attach $fin
    audit_ops aout -attach $fout

    fconfigure $fin  -buffersize 10
    fconfigure $fout -buffersize 5

    fcopy $fin $fout

    close $fin
    close $fout

    set res "[join $ain \n]\n--------\n[join $aout \n]"
} {create/read
query/maxRead
read
query/maxRead
read
query/maxRead
read
query/maxRead
read
query/maxRead
read
query/maxRead
read
query/maxRead
read
query/maxRead
read
query/maxRead
flush/read
delete/read
--------
create/write
write
write
write
write
write
write
write
write
flush/write
delete/write}

test iogt-2.2 {basic I/O, data trail} {testchannel unixOnly} {
    set fin  [open $path(dummy)    r]
    set fout [open $path(dummyout) w]

    set ain [list] ; set aout [list]
    audit_flow ain  -attach $fin
    audit_flow aout -attach $fout

    fconfigure $fin  -buffersize 10
    fconfigure $fout -buffersize 5

    fcopy $fin $fout

    close $fin
    close $fout

    set res "[join $ain \n]\n--------\n[join $aout \n]"
} {create/read {} *ignored*
query/maxRead {} -1
read abcdefghij abcdefghij
query/maxRead {} -1
read klmnopqrst klmnopqrst
query/maxRead {} -1
read uvwxyz0123 uvwxyz0123
query/maxRead {} -1
read 456789,./? 456789,./?
query/maxRead {} -1
read {><;'\|":[]} {><;'\|":[]}
query/maxRead {} -1
read {\}\{`~!@@#$} {\}\{`~!@@#$}
query/maxRead {} -1
read %^&*()_+-= %^&*()_+-=
query/maxRead {} -1
read {
} {
}
query/maxRead {} -1
flush/read {} {}
delete/read {} *ignored*
--------
create/write {} *ignored*
write abcdefghij abcdefghij
write klmnopqrst klmnopqrst
write uvwxyz0123 uvwxyz0123
write 456789,./? 456789,./?
write {><;'\|":[]} {><;'\|":[]}
write {\}\{`~!@@#$} {\}\{`~!@@#$}
write %^&*()_+-= %^&*()_+-=
write {
} {
}
flush/write {} {}
delete/write {} *ignored*}


test iogt-2.3 {basic I/O, mixed trail} {testchannel unixOnly} {
    set fin  [open $path(dummy)    r]
    set fout [open $path(dummyout) w]

    set trail [list]
    audit_flow trail -attach $fin
    audit_flow trail -attach $fout

    fconfigure $fin  -buffersize 20
    fconfigure $fout -buffersize 10

    fcopy $fin $fout

    close $fin
    close $fout

    join $trail \n
} {create/read {} *ignored*
create/write {} *ignored*
query/maxRead {} -1
read abcdefghijklmnopqrst abcdefghijklmnopqrst
write abcdefghij abcdefghij
write klmnopqrst klmnopqrst
query/maxRead {} -1
read uvwxyz0123456789,./? uvwxyz0123456789,./?
write uvwxyz0123 uvwxyz0123
write 456789,./? 456789,./?
query/maxRead {} -1
read {><;'\|":[]\}\{`~!@@#$} {><;'\|":[]\}\{`~!@@#$}
write {><;'\|":[]} {><;'\|":[]}
write {\}\{`~!@@#$} {\}\{`~!@@#$}
query/maxRead {} -1
read {%^&*()_+-=
} {%^&*()_+-=
}
query/maxRead {} -1
flush/read {} {}
write %^&*()_+-= %^&*()_+-=
write {
} {
}
delete/read {} *ignored*
flush/write {} {}
delete/write {} *ignored*}


test iogt-3.0 {Tcl_Channel valid after stack/unstack, fevent handling} \
	{testchannel unknownFailure} {
    # This test to check the validity of aquired Tcl_Channel references is
    # not possible because even a backgrounded fcopy will immediately start
    # to copy data, without waiting for the event loop. This is done only in
    # case of an underflow on the read size!. So stacking transforms after the
    # fcopy will miss information, or are not used at all.
    #
    # I was able to circumvent this by using the echo.tcl server with a big
    # delay, causing the fcopy to underflow immediately.

    proc DoneCopy {n {err {}}} {
	variable copy ; set copy 1
    }

    set fin  [open $path(dummy) r]

    fevent 1000 500 {20 20 20 10 1 1} {
	close $fin

	set          fout [open dummyout w]

	flush $sock ; # now, or fcopy will error us out
	# But the 1 second delay should be enough to
	# initialize everything else here.

	fcopy $sock $fout -command [namespace code DoneCopy]

	# transform after fcopy got its handles !
	# They should be still valid for fcopy.

	set trail [list]
	audit_ops trail -attach $fout

	vwait [namespace which -variable copy]
    } [read $fin] ; # {}

    close $fout

    rename DoneCopy {}

    # Check result of copy.

    set fin  [open $path(dummy)    r]
    set fout [open $path(dummyout) r]

    set res [string equal [read $fin] [read $fout]]

    close $fin
    close $fout

    list $res $trail
} {1 {create/write create/read write flush/write flush/read delete/write delete/read}}


test iogt-4.0 {fileevent readable, after transform} {testchannel unknownFailure} {
    set fin  [open $path(dummy) r]
    set data [read $fin]
    close $fin

    set trail [list]
    set got   [list]

    proc Done {args} {
	variable stop
	set    stop 1
    }

    proc Get {sock} {
	variable trail
	variable got
	if {[eof $sock]} {
	    Done
	    lappend trail "xxxxxxxxxxxxx"
	    close $sock
	    return
	}
	lappend trail "vvvvvvvvvvvvv"
	lappend trail "\tgot: [lappend got "\[\[[read $sock]\]\]"]"
	lappend trail "============="
	#puts stdout $__ ; flush stdout
	#read $sock
    }

    fevent 1000 500 {20 20 20 10 1} {
	audit_flow trail   -attach $sock
	rblocks_t  rbuf trail 23 -attach $sock

	fileevent $sock readable [list Get $sock]

	flush $sock ; # now, or fcopy will error us out
	# But the 1 second delay should be enough to
	# initialize everything else here.

	vwait [namespace which -variable stop]
    } $data


    rename Done {}
    rename Get {}

    join [list [join $got \n] ~~~~~~~~ [join $trail \n]] \n
} {[[]]
[[abcdefghijklmnopqrstuvw]]
[[xyz0123456789,./?><;'\|]]
[[]]
[[]]
[[":[]\}\{`~!@@#$%^&*()]]
[[]]
~~~~~~~~
create/write {} *ignored*
create/read {} *ignored*
rblock | create/write {} {} | {}
rblock | create/read {} {} | {}
vvvvvvvvvvvvv
rblock | query/maxRead {} -1 | {}
query/maxRead {} -1
read abcdefghijklmnopqrstu abcdefghijklmnopqrstu
query/maxRead {} -1
rblock | {read 23 21 :- 0} abcdefghijklmnopqrstu {} | abcdefghijklmnopqrstu
rblock | query/maxRead {} -1 | abcdefghijklmnopqrstu
query/maxRead {} -1
	got: {[[]]}
=============
vvvvvvvvvvvvv
rblock | query/maxRead {} -1 | abcdefghijklmnopqrstu
query/maxRead {} -1
read vwxyz0123456789,./?>< vwxyz0123456789,./?><
query/maxRead {} -1
rblock | {read 23 42 :- 23} vwxyz0123456789,./?>< abcdefghijklmnopqrstuvw | xyz0123456789,./?><
rblock | query/maxRead {} -1 | xyz0123456789,./?><
query/maxRead {} -1
	got: {[[]]} {[[abcdefghijklmnopqrstuvw]]}
=============
vvvvvvvvvvvvv
rblock | query/maxRead {} -1 | xyz0123456789,./?><
query/maxRead {} -1
read {;'\|":[]\}\{`~!@@#$%^&} {;'\|":[]\}\{`~!@@#$%^&}
query/maxRead {} -1
rblock | {read 23 40 :- 23} {;'\|":[]\}\{`~!@@#$%^&} {xyz0123456789,./?><;'\|} | {":[]\}\{`~!@@#$%^&}
rblock | query/maxRead {} -1 | {":[]\}\{`~!@@#$%^&}
query/maxRead {} -1
	got: {[[]]} {[[abcdefghijklmnopqrstuvw]]} {[[xyz0123456789,./?><;'\|]]}
=============
vvvvvvvvvvvvv
rblock | query/maxRead {} -1 | {":[]\}\{`~!@@#$%^&}
query/maxRead {} -1
read *( *(
query/maxRead {} -1
rblock | {read 23 19 :- 0} *( {} | {":[]\}\{`~!@@#$%^&*(}
rblock | query/maxRead {} -1 | {":[]\}\{`~!@@#$%^&*(}
query/maxRead {} -1
	got: {[[]]} {[[abcdefghijklmnopqrstuvw]]} {[[xyz0123456789,./?><;'\|]]} {[[]]}
=============
vvvvvvvvvvvvv
rblock | query/maxRead {} -1 | {":[]\}\{`~!@@#$%^&*(}
query/maxRead {} -1
read ) )
query/maxRead {} -1
rblock | {read 23 20 :- 0} ) {} | {":[]\}\{`~!@@#$%^&*()}
rblock | query/maxRead {} -1 | {":[]\}\{`~!@@#$%^&*()}
query/maxRead {} -1
	got: {[[]]} {[[abcdefghijklmnopqrstuvw]]} {[[xyz0123456789,./?><;'\|]]} {[[]]} {[[]]}
=============
vvvvvvvvvvvvv
rblock | query/maxRead {} -1 | {":[]\}\{`~!@@#$%^&*()}
query/maxRead {} -1
flush/read {} {}
rblock | flush/read {} {":[]\}\{`~!@@#$%^&*()} | {}
rblock | query/maxRead {} -1 | {}
query/maxRead {} -1
	got: {[[]]} {[[abcdefghijklmnopqrstuvw]]} {[[xyz0123456789,./?><;'\|]]} {[[]]} {[[]]} {[[":[]\}\{`~!@@#$%^&*()]]}
=============
vvvvvvvvvvvvv
rblock | query/maxRead {} -1 | {}
query/maxRead {} -1
	got: {[[]]} {[[abcdefghijklmnopqrstuvw]]} {[[xyz0123456789,./?><;'\|]]} {[[]]} {[[]]} {[[":[]\}\{`~!@@#$%^&*()]]} {[[]]}
xxxxxxxxxxxxx
rblock | flush/write {} {} | {}
rblock | delete/write {} {} | {}
rblock | delete/read {} {} | {}
flush/write {} {}
delete/write {} *ignored*
delete/read {} *ignored*}  ; # catch unescaped quote "


test iogt-5.0 {EOF simulation} {testchannel unknownFailure} {
    set fin  [open $path(dummy)    r]
    set fout [open $path(dummyout) w]

    set trail [list]

    audit_flow trail -attach $fin
    stopafter_audit d trail 20 -attach   $fin
    audit_flow trail -attach $fout

    fconfigure $fin  -buffersize 20
    fconfigure $fout -buffersize 10

    fcopy   $fin $fout
    testchannel unstack $fin

    # now copy the rest in the channel
    lappend trail {**after unstack**}

    fcopy $fin $fout

    close $fin
    close $fout

    join $trail \n
} {create/read {} *ignored*
counter:create/read {} {}
create/write {} *ignored*
counter:query/maxRead {} 20
query/maxRead {} -1
read {abcdefghijklmnopqrstuvwxyz0123456789,./?><;'\|":[]\}\{`~!@@#$%^&*()_+-=
} {abcdefghijklmnopqrstuvwxyz0123456789,./?><;'\|":[]\}\{`~!@@#$%^&*()_+-=
}
query/maxRead {} -1
flush/read {} {}
counter:read abcdefghijklmnopqrst abcdefghijklmnopqrst
write abcdefghij abcdefghij
write klmnopqrst klmnopqrst
counter:query/maxRead {} 0
counter:flush/read {} {}
counter:delete/read {} {}
**after unstack**
query/maxRead {} -1
write uvwxyz0123 uvwxyz0123
write 456789,./? 456789,./?
write {><;'\|":[]} {><;'\|":[]}
write {\}\{`~!@@#$} {\}\{`~!@@#$}
write %^&*()_+-= %^&*()_+-=
write {
} {
}
query/maxRead {} -1
delete/read {} *ignored*
flush/write {} {}
delete/write {} *ignored*}





proc constX {op data} {
    # replace anything coming in with a same-length string of x'es.
    switch -- $op {
	create/write -	create/read  -
	delete/write -	delete/read  -
	clear_read   {;#ignore}
	flush/write -	flush/read  -
	write       -
	read        {
	    return [string repeat x [string length $data]]
	}
	query/maxRead {return -1}
    }
}

proc constx {-attach channel} {
    testchannel transform $channel -command [namespace code constX]
}

test iogt-6.0 {Push back} testchannel {
    set f [open $path(dummy) r]

    # contents of dummy = "abcdefghi..."
    read $f 3 ; # skip behind "abc"

    constx -attach $f

    # expect to get "xxx" from the transform because
    # of unread "def" input to transform which returns "xxx".
    #
    # Actually the IO layer pre-read the whole file and will
    # read "def" directly from the buffer without bothering
    # to consult the newly stacked transformation. This is
    # wrong.

    set res [read $f 3]
    close $f
    set res
} {xxx}

test iogt-6.1 {Push back and up} {testchannel knownBug} {
    set f [open $path(dummy) r]

    # contents of dummy = "abcdefghi..."
    read $f 3 ; # skip behind "abc"

    constx -attach $f
    set res [read $f 3]

    testchannel unstack $f
    append res [read $f 3]
    close $f
    set res
} {xxxghi}


# cleanup
foreach file [list dummy dummyout __echo_srv__.tcl] {
    removeFile $file
}
cleanupTests
}
namespace delete ::tcl::test::iogt
return
@


1.4
log
@touched all sources to ease next import
@
text
@d13 1
a13 1
# RCS: @@(#) $Id: iogt.test,v 1.1.4.1 2000/07/27 01:39:20 hobbs Exp $
d15 2
a16 9

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import -force ::tcltest::*
}

if {[info commands testchannel] == ""} {
    puts "Skipping io tests. This application does not seem to have the"
    puts "testchannel command that is needed to run these tests."
d19 1
d21 5
a25 1
::tcltest::saveState
d27 1
a27 1
#::tcltest::makeFile contents name
d29 2
a30 1
::tcltest::makeFile {abcdefghijklmnopqrstuvwxyz0123456789,./?><;'\|":[]\}\{`~!@@#$%^&*()_+-=} dummy
d34 1
a34 1
::tcltest::makeFile {} dummyout
d36 1
a36 1
::tcltest::makeFile {
d53 2
a54 1
    global c fdelay
d56 1
d60 1
a60 1
    upvar #0 c$c conn
d72 3
a74 2
    global fdelay
    upvar #0 c$c conn
d91 5
a95 2
    global idelay fdelay bsizes
    upvar #0 c$c conn
d136 1
a136 1
} __echo_srv__.tcl
d197 2
a198 1
    upvar #0 $var trail
d224 2
a225 1
    upvar #0 $var trail
d253 2
a254 1
    upvar #0 $var n
d281 3
a283 1
    upvar #0 $var n $vtrail trail
d317 3
a319 1
    upvar #0 $var buf $vtrail trail
d363 1
a363 1
    testchannel transform $channel -command id
d367 1
a367 1
    testchannel transform $channel -command [list id_optrail $var]
d371 1
a371 1
    testchannel transform $channel -command [list id_fulltrail $var]
d375 2
a376 1
    upvar #0 $var vn
d378 1
a378 1
    testchannel transform $channel -command [list counter $var]
d382 2
a383 1
    upvar #0 $var vn
d385 1
a385 1
    testchannel transform $channel -command [list counter_audit $var $trail]
d389 1
a389 1
    testchannel transform $channel -command [list rblocks $var $trail $n]
d414 2
a415 3

test iogt-1.1 {stack/unstack} {
    set fh [open dummy r]
d421 2
a422 2
test iogt-1.2 {stack/close} {
    set fh [open dummy r]
d427 2
a428 2
test iogt-1.3 {stack/unstack, configuration, options} {
    set fh [open dummy r]
d445 2
a446 2
test iogt-1.4 {stack/unstack, configuration} {
    set fh [open dummy r]
d467 3
a469 3
test iogt-2.0 {basic I/O going through transform} {
    set fin  [open dummy    r]
    set fout [open dummyout w]
d479 2
a480 2
    set fin  [open dummy    r]
    set fout [open dummyout r]
d492 3
a494 3
test iogt-2.1 {basic I/O, operation trail} {unixOnly} {
    set fin  [open dummy    r]
    set fout [open dummyout w]
a527 1
query/maxRead
d542 3
a544 3
test iogt-2.2 {basic I/O, data trail} {unixOnly} {
    set fin  [open dummy    r]
    set fout [open dummyout w]
a579 1
query/maxRead {} -1
d597 3
a599 3
test iogt-2.3 {basic I/O, mixed trail} {unixOnly} {
    set fin  [open dummy    r]
    set fout [open dummyout w]
a637 1
query/maxRead {} -1
d644 1
a644 1
	{unknownFailure} {
d655 1
a655 1
	global copy ; set copy 1
d658 1
a658 1
    set fin  [open dummy    r]
d669 1
a669 1
	fcopy $sock $fout -command DoneCopy
d677 1
a677 1
	vwait copy
d686 2
a687 2
    set fin  [open dummy    r]
    set fout [open dummyout r]
d698 2
a699 2
test iogt-4.0 {fileevent readable, after transform} {unknownFailure} {
    set fin  [open dummy    r]
d707 1
a707 1
	global stop
d712 2
a713 1
	global trail got
d737 1
a737 1
	vwait stop
d829 3
a831 3
test iogt-5.0 {EOF simulation} {unknownFailure} {
    set fin  [open dummy    r]
    set fout [open dummyout w]
d905 1
a905 1
    testchannel transform $channel -command constX
d908 2
a909 2
test iogt-6.0 {Push back} {
    set f [open dummy r]
d929 2
a930 2
test iogt-6.1 {Push back and up} {knownBug} {
    set f [open dummy r]
d947 3
a949 1
    ::tcltest::removeFile $file
d951 1
a951 2
::tcltest::restoreState
::tcltest::cleanupTests
@


1.3
log
@touched all sources to ease next import
@
text
@@


1.3.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d13 1
a13 1
# RCS: @@(#) $Id: iogt.test,v 1.7 2002/07/04 15:46:55 andreas_kupries Exp $
d15 9
a23 2
if {[catch {package require tcltest 2.1}]} {
    puts stderr "Skipping tests in [info script].  tcltest 2.1 required."
a25 1
namespace eval ::tcl::test::iogt {
d27 1
a27 5
    namespace import ::tcltest::cleanupTests
    namespace import ::tcltest::makeFile
    namespace import ::tcltest::removeFile
    namespace import ::tcltest::test
    namespace import ::tcltest::testConstraint
d29 1
a29 1
    testConstraint testchannel [llength [info commands testchannel]]
d31 1
a31 2
set path(dummy) [makeFile {abcdefghijklmnopqrstuvwxyz0123456789,./?><;'\|":[]\}\{`~!@@#$%^&*()_+-=
} dummy]
d35 1
a35 1
set path(dummyout) [makeFile {} dummyout]
d37 1
a37 1
set path(__echo_srv__.tcl) [makeFile {
d54 1
a54 2
    variable fdelay
    variable c
a55 1
    variable c$c
d59 1
a59 1
    upvar 0 c$c conn
d71 2
a72 3
    variable fdelay
    variable c$c
    upvar 0 c$c conn
d89 2
a90 5
    variable idelay
    variable fdelay
    variable bsizes
    variable c$c
    upvar 0 c$c conn
d131 1
a131 1
} __echo_srv__.tcl]
d192 1
a192 2
    variable $var
    upvar 0 $var trail
d218 1
a218 2
    variable $var
    upvar 0 $var trail
d246 1
a246 2
    variable $var
    upvar 0 $var n
d273 1
a273 3
    variable $var
    variable $vtrail
    upvar 0 $var n $vtrail trail
d307 1
a307 3
    variable $var
    variable $vtrail
    upvar 0 $var buf $vtrail trail
d351 1
a351 1
    testchannel transform $channel -command [namespace code id]
d355 1
a355 1
    testchannel transform $channel -command [namespace code [list id_optrail $var]]
d359 1
a359 1
    testchannel transform $channel -command [namespace code [list id_fulltrail $var]]
d363 1
a363 2
    variable $var
    upvar 0 $var vn
d365 1
a365 1
    testchannel transform $channel -command [namespace code [list counter $var]]
d369 1
a369 2
    variable $var
    upvar 0 $var vn
d371 1
a371 1
    testchannel transform $channel -command [namespace code [list counter_audit $var $trail]]
d375 1
a375 1
    testchannel transform $channel -command [namespace code [list rblocks $var $trail $n]]
d400 3
a402 2
test iogt-1.1 {stack/unstack} testchannel {
    set fh [open $path(dummy) r]
d408 2
a409 2
test iogt-1.2 {stack/close} testchannel {
    set fh [open $path(dummy) r]
d414 2
a415 2
test iogt-1.3 {stack/unstack, configuration, options} testchannel {
    set fh [open $path(dummy) r]
d432 2
a433 2
test iogt-1.4 {stack/unstack, configuration} testchannel {
    set fh [open $path(dummy) r]
d454 3
a456 3
test iogt-2.0 {basic I/O going through transform} testchannel {
    set fin  [open $path(dummy)    r]
    set fout [open $path(dummyout) w]
d466 2
a467 2
    set fin  [open $path(dummy)    r]
    set fout [open $path(dummyout) r]
d479 3
a481 3
test iogt-2.1 {basic I/O, operation trail} {testchannel unixOnly} {
    set fin  [open $path(dummy)    r]
    set fout [open $path(dummyout) w]
d515 1
d530 3
a532 3
test iogt-2.2 {basic I/O, data trail} {testchannel unixOnly} {
    set fin  [open $path(dummy)    r]
    set fout [open $path(dummyout) w]
d568 1
d586 3
a588 3
test iogt-2.3 {basic I/O, mixed trail} {testchannel unixOnly} {
    set fin  [open $path(dummy)    r]
    set fout [open $path(dummyout) w]
d627 1
d634 1
a634 1
	{testchannel unknownFailure} {
d645 1
a645 1
	variable copy ; set copy 1
d648 1
a648 1
    set fin  [open $path(dummy) r]
d659 1
a659 1
	fcopy $sock $fout -command [namespace code DoneCopy]
d667 1
a667 1
	vwait [namespace which -variable copy]
d676 2
a677 2
    set fin  [open $path(dummy)    r]
    set fout [open $path(dummyout) r]
d688 2
a689 2
test iogt-4.0 {fileevent readable, after transform} {testchannel unknownFailure} {
    set fin  [open $path(dummy) r]
d697 1
a697 1
	variable stop
d702 1
a702 2
	variable trail
	variable got
d726 1
a726 1
	vwait [namespace which -variable stop]
d818 3
a820 3
test iogt-5.0 {EOF simulation} {testchannel unknownFailure} {
    set fin  [open $path(dummy)    r]
    set fout [open $path(dummyout) w]
d894 1
a894 1
    testchannel transform $channel -command [namespace code constX]
d897 2
a898 2
test iogt-6.0 {Push back} testchannel {
    set f [open $path(dummy) r]
d918 2
a919 2
test iogt-6.1 {Push back and up} {testchannel knownBug} {
    set f [open $path(dummy) r]
d936 1
a936 3
    removeFile $file
}
cleanupTests
d938 2
a939 1
namespace delete ::tcl::test::iogt
@


1.3.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@d13 1
a13 1
# RCS: @@(#) $Id: iogt.test,v 1.7 2002/07/04 15:46:55 andreas_kupries Exp $
d15 9
a23 2
if {[catch {package require tcltest 2.1}]} {
    puts stderr "Skipping tests in [info script].  tcltest 2.1 required."
a25 1
namespace eval ::tcl::test::iogt {
d27 1
a27 5
    namespace import ::tcltest::cleanupTests
    namespace import ::tcltest::makeFile
    namespace import ::tcltest::removeFile
    namespace import ::tcltest::test
    namespace import ::tcltest::testConstraint
d29 1
a29 1
    testConstraint testchannel [llength [info commands testchannel]]
d31 1
a31 2
set path(dummy) [makeFile {abcdefghijklmnopqrstuvwxyz0123456789,./?><;'\|":[]\}\{`~!@@#$%^&*()_+-=
} dummy]
d35 1
a35 1
set path(dummyout) [makeFile {} dummyout]
d37 1
a37 1
set path(__echo_srv__.tcl) [makeFile {
d54 1
a54 2
    variable fdelay
    variable c
a55 1
    variable c$c
d59 1
a59 1
    upvar 0 c$c conn
d71 2
a72 3
    variable fdelay
    variable c$c
    upvar 0 c$c conn
d89 2
a90 5
    variable idelay
    variable fdelay
    variable bsizes
    variable c$c
    upvar 0 c$c conn
d131 1
a131 1
} __echo_srv__.tcl]
d192 1
a192 2
    variable $var
    upvar 0 $var trail
d218 1
a218 2
    variable $var
    upvar 0 $var trail
d246 1
a246 2
    variable $var
    upvar 0 $var n
d273 1
a273 3
    variable $var
    variable $vtrail
    upvar 0 $var n $vtrail trail
d307 1
a307 3
    variable $var
    variable $vtrail
    upvar 0 $var buf $vtrail trail
d351 1
a351 1
    testchannel transform $channel -command [namespace code id]
d355 1
a355 1
    testchannel transform $channel -command [namespace code [list id_optrail $var]]
d359 1
a359 1
    testchannel transform $channel -command [namespace code [list id_fulltrail $var]]
d363 1
a363 2
    variable $var
    upvar 0 $var vn
d365 1
a365 1
    testchannel transform $channel -command [namespace code [list counter $var]]
d369 1
a369 2
    variable $var
    upvar 0 $var vn
d371 1
a371 1
    testchannel transform $channel -command [namespace code [list counter_audit $var $trail]]
d375 1
a375 1
    testchannel transform $channel -command [namespace code [list rblocks $var $trail $n]]
d400 3
a402 2
test iogt-1.1 {stack/unstack} testchannel {
    set fh [open $path(dummy) r]
d408 2
a409 2
test iogt-1.2 {stack/close} testchannel {
    set fh [open $path(dummy) r]
d414 2
a415 2
test iogt-1.3 {stack/unstack, configuration, options} testchannel {
    set fh [open $path(dummy) r]
d432 2
a433 2
test iogt-1.4 {stack/unstack, configuration} testchannel {
    set fh [open $path(dummy) r]
d454 3
a456 3
test iogt-2.0 {basic I/O going through transform} testchannel {
    set fin  [open $path(dummy)    r]
    set fout [open $path(dummyout) w]
d466 2
a467 2
    set fin  [open $path(dummy)    r]
    set fout [open $path(dummyout) r]
d479 3
a481 3
test iogt-2.1 {basic I/O, operation trail} {testchannel unixOnly} {
    set fin  [open $path(dummy)    r]
    set fout [open $path(dummyout) w]
d515 1
d530 3
a532 3
test iogt-2.2 {basic I/O, data trail} {testchannel unixOnly} {
    set fin  [open $path(dummy)    r]
    set fout [open $path(dummyout) w]
d568 1
d586 3
a588 3
test iogt-2.3 {basic I/O, mixed trail} {testchannel unixOnly} {
    set fin  [open $path(dummy)    r]
    set fout [open $path(dummyout) w]
d627 1
d634 1
a634 1
	{testchannel unknownFailure} {
d645 1
a645 1
	variable copy ; set copy 1
d648 1
a648 1
    set fin  [open $path(dummy) r]
d659 1
a659 1
	fcopy $sock $fout -command [namespace code DoneCopy]
d667 1
a667 1
	vwait [namespace which -variable copy]
d676 2
a677 2
    set fin  [open $path(dummy)    r]
    set fout [open $path(dummyout) r]
d688 2
a689 2
test iogt-4.0 {fileevent readable, after transform} {testchannel unknownFailure} {
    set fin  [open $path(dummy) r]
d697 1
a697 1
	variable stop
d702 1
a702 2
	variable trail
	variable got
d726 1
a726 1
	vwait [namespace which -variable stop]
d818 3
a820 3
test iogt-5.0 {EOF simulation} {testchannel unknownFailure} {
    set fin  [open $path(dummy)    r]
    set fout [open $path(dummyout) w]
d894 1
a894 1
    testchannel transform $channel -command [namespace code constX]
d897 2
a898 2
test iogt-6.0 {Push back} testchannel {
    set f [open $path(dummy) r]
d918 2
a919 2
test iogt-6.1 {Push back and up} {testchannel knownBug} {
    set f [open $path(dummy) r]
d936 1
a936 3
    removeFile $file
}
cleanupTests
d938 2
a939 1
namespace delete ::tcl::test::iogt
@


1.2
log
@touched all Tcl files to ease next import.
@
text
@@


1.2.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.2.16.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d15 9
a23 2
if {[catch {package require tcltest 2.1}]} {
    puts stderr "Skipping tests in [info script].  tcltest 2.1 required."
a25 1
namespace eval ::tcl::test::iogt {
d27 1
a27 5
    namespace import ::tcltest::cleanupTests
    namespace import ::tcltest::makeFile
    namespace import ::tcltest::removeFile
    namespace import ::tcltest::test
    namespace import ::tcltest::testConstraint
d29 1
a29 1
    testConstraint testchannel [llength [info commands testchannel]]
d31 1
a31 2
set path(dummy) [makeFile {abcdefghijklmnopqrstuvwxyz0123456789,./?><;'\|":[]\}\{`~!@@#$%^&*()_+-=
} dummy]
d35 1
a35 1
set path(dummyout) [makeFile {} dummyout]
d37 1
a37 1
set path(__echo_srv__.tcl) [makeFile {
d54 1
a54 2
    variable fdelay
    variable c
a55 1
    variable c$c
d59 1
a59 1
    upvar 0 c$c conn
d71 2
a72 3
    variable fdelay
    variable c$c
    upvar 0 c$c conn
d89 2
a90 5
    variable idelay
    variable fdelay
    variable bsizes
    variable c$c
    upvar 0 c$c conn
d131 1
a131 1
} __echo_srv__.tcl]
d192 1
a192 2
    variable $var
    upvar 0 $var trail
d218 1
a218 2
    variable $var
    upvar 0 $var trail
d246 1
a246 2
    variable $var
    upvar 0 $var n
d273 1
a273 3
    variable $var
    variable $vtrail
    upvar 0 $var n $vtrail trail
d307 1
a307 3
    variable $var
    variable $vtrail
    upvar 0 $var buf $vtrail trail
d351 1
a351 1
    testchannel transform $channel -command [namespace code id]
d355 1
a355 1
    testchannel transform $channel -command [namespace code [list id_optrail $var]]
d359 1
a359 1
    testchannel transform $channel -command [namespace code [list id_fulltrail $var]]
d363 1
a363 2
    variable $var
    upvar 0 $var vn
d365 1
a365 1
    testchannel transform $channel -command [namespace code [list counter $var]]
d369 1
a369 2
    variable $var
    upvar 0 $var vn
d371 1
a371 1
    testchannel transform $channel -command [namespace code [list counter_audit $var $trail]]
d375 1
a375 1
    testchannel transform $channel -command [namespace code [list rblocks $var $trail $n]]
d400 3
a402 2
test iogt-1.1 {stack/unstack} testchannel {
    set fh [open $path(dummy) r]
d408 2
a409 2
test iogt-1.2 {stack/close} testchannel {
    set fh [open $path(dummy) r]
d414 2
a415 2
test iogt-1.3 {stack/unstack, configuration, options} testchannel {
    set fh [open $path(dummy) r]
d432 2
a433 2
test iogt-1.4 {stack/unstack, configuration} testchannel {
    set fh [open $path(dummy) r]
d454 3
a456 3
test iogt-2.0 {basic I/O going through transform} testchannel {
    set fin  [open $path(dummy)    r]
    set fout [open $path(dummyout) w]
d466 2
a467 2
    set fin  [open $path(dummy)    r]
    set fout [open $path(dummyout) r]
d479 3
a481 3
test iogt-2.1 {basic I/O, operation trail} {testchannel unixOnly} {
    set fin  [open $path(dummy)    r]
    set fout [open $path(dummyout) w]
d515 1
d530 3
a532 3
test iogt-2.2 {basic I/O, data trail} {testchannel unixOnly} {
    set fin  [open $path(dummy)    r]
    set fout [open $path(dummyout) w]
d568 1
d586 3
a588 3
test iogt-2.3 {basic I/O, mixed trail} {testchannel unixOnly} {
    set fin  [open $path(dummy)    r]
    set fout [open $path(dummyout) w]
d627 1
d634 1
a634 1
	{testchannel unknownFailure} {
d645 1
a645 1
	variable copy ; set copy 1
d648 1
a648 1
    set fin  [open $path(dummy) r]
d659 1
a659 1
	fcopy $sock $fout -command [namespace code DoneCopy]
d667 1
a667 1
	vwait [namespace which -variable copy]
d676 2
a677 2
    set fin  [open $path(dummy)    r]
    set fout [open $path(dummyout) r]
d688 2
a689 2
test iogt-4.0 {fileevent readable, after transform} {testchannel unknownFailure} {
    set fin  [open $path(dummy) r]
d697 1
a697 1
	variable stop
d702 1
a702 2
	variable trail
	variable got
d726 1
a726 1
	vwait [namespace which -variable stop]
d818 3
a820 3
test iogt-5.0 {EOF simulation} {testchannel unknownFailure} {
    set fin  [open $path(dummy)    r]
    set fout [open $path(dummyout) w]
d894 1
a894 1
    testchannel transform $channel -command [namespace code constX]
d897 2
a898 2
test iogt-6.0 {Push back} testchannel {
    set f [open $path(dummy) r]
d918 2
a919 2
test iogt-6.1 {Push back and up} {testchannel knownBug} {
    set f [open $path(dummy) r]
d936 1
a936 3
    removeFile $file
}
cleanupTests
d938 2
a939 1
namespace delete ::tcl::test::iogt
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Tcl 8.3 upgrade
@
text
@@


1.1.1.2
log
@import tcl 8.4.0
@
text
@d13 1
a13 1
# RCS: @@(#) $Id: iogt.test,v 1.7 2002/07/04 15:46:55 andreas_kupries Exp $
d15 9
a23 2
if {[catch {package require tcltest 2.1}]} {
    puts stderr "Skipping tests in [info script].  tcltest 2.1 required."
a25 1
namespace eval ::tcl::test::iogt {
d27 1
a27 5
    namespace import ::tcltest::cleanupTests
    namespace import ::tcltest::makeFile
    namespace import ::tcltest::removeFile
    namespace import ::tcltest::test
    namespace import ::tcltest::testConstraint
d29 1
a29 1
    testConstraint testchannel [llength [info commands testchannel]]
d31 1
a31 2
set path(dummy) [makeFile {abcdefghijklmnopqrstuvwxyz0123456789,./?><;'\|":[]\}\{`~!@@#$%^&*()_+-=
} dummy]
d35 1
a35 1
set path(dummyout) [makeFile {} dummyout]
d37 1
a37 1
set path(__echo_srv__.tcl) [makeFile {
d54 1
a54 2
    variable fdelay
    variable c
a55 1
    variable c$c
d59 1
a59 1
    upvar 0 c$c conn
d71 2
a72 3
    variable fdelay
    variable c$c
    upvar 0 c$c conn
d89 2
a90 5
    variable idelay
    variable fdelay
    variable bsizes
    variable c$c
    upvar 0 c$c conn
d131 1
a131 1
} __echo_srv__.tcl]
d192 1
a192 2
    variable $var
    upvar 0 $var trail
d218 1
a218 2
    variable $var
    upvar 0 $var trail
d246 1
a246 2
    variable $var
    upvar 0 $var n
d273 1
a273 3
    variable $var
    variable $vtrail
    upvar 0 $var n $vtrail trail
d307 1
a307 3
    variable $var
    variable $vtrail
    upvar 0 $var buf $vtrail trail
d351 1
a351 1
    testchannel transform $channel -command [namespace code id]
d355 1
a355 1
    testchannel transform $channel -command [namespace code [list id_optrail $var]]
d359 1
a359 1
    testchannel transform $channel -command [namespace code [list id_fulltrail $var]]
d363 1
a363 2
    variable $var
    upvar 0 $var vn
d365 1
a365 1
    testchannel transform $channel -command [namespace code [list counter $var]]
d369 1
a369 2
    variable $var
    upvar 0 $var vn
d371 1
a371 1
    testchannel transform $channel -command [namespace code [list counter_audit $var $trail]]
d375 1
a375 1
    testchannel transform $channel -command [namespace code [list rblocks $var $trail $n]]
d400 3
a402 2
test iogt-1.1 {stack/unstack} testchannel {
    set fh [open $path(dummy) r]
d408 2
a409 2
test iogt-1.2 {stack/close} testchannel {
    set fh [open $path(dummy) r]
d414 2
a415 2
test iogt-1.3 {stack/unstack, configuration, options} testchannel {
    set fh [open $path(dummy) r]
d432 2
a433 2
test iogt-1.4 {stack/unstack, configuration} testchannel {
    set fh [open $path(dummy) r]
d454 3
a456 3
test iogt-2.0 {basic I/O going through transform} testchannel {
    set fin  [open $path(dummy)    r]
    set fout [open $path(dummyout) w]
d466 2
a467 2
    set fin  [open $path(dummy)    r]
    set fout [open $path(dummyout) r]
d479 3
a481 3
test iogt-2.1 {basic I/O, operation trail} {testchannel unixOnly} {
    set fin  [open $path(dummy)    r]
    set fout [open $path(dummyout) w]
d515 1
d530 3
a532 3
test iogt-2.2 {basic I/O, data trail} {testchannel unixOnly} {
    set fin  [open $path(dummy)    r]
    set fout [open $path(dummyout) w]
d568 1
d586 3
a588 3
test iogt-2.3 {basic I/O, mixed trail} {testchannel unixOnly} {
    set fin  [open $path(dummy)    r]
    set fout [open $path(dummyout) w]
d627 1
d634 1
a634 1
	{testchannel unknownFailure} {
d645 1
a645 1
	variable copy ; set copy 1
d648 1
a648 1
    set fin  [open $path(dummy) r]
d659 1
a659 1
	fcopy $sock $fout -command [namespace code DoneCopy]
d667 1
a667 1
	vwait [namespace which -variable copy]
d676 2
a677 2
    set fin  [open $path(dummy)    r]
    set fout [open $path(dummyout) r]
d688 2
a689 2
test iogt-4.0 {fileevent readable, after transform} {testchannel unknownFailure} {
    set fin  [open $path(dummy) r]
d697 1
a697 1
	variable stop
d702 1
a702 2
	variable trail
	variable got
d726 1
a726 1
	vwait [namespace which -variable stop]
d818 3
a820 3
test iogt-5.0 {EOF simulation} {testchannel unknownFailure} {
    set fin  [open $path(dummy)    r]
    set fout [open $path(dummyout) w]
d894 1
a894 1
    testchannel transform $channel -command [namespace code constX]
d897 2
a898 2
test iogt-6.0 {Push back} testchannel {
    set f [open $path(dummy) r]
d918 2
a919 2
test iogt-6.1 {Push back and up} {testchannel knownBug} {
    set f [open $path(dummy) r]
d936 1
a936 3
    removeFile $file
}
cleanupTests
d938 2
a939 1
namespace delete ::tcl::test::iogt
@

