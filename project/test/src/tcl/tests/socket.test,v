head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.58
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.56
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.54
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.52
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.50
	gdb_7_0-branch:1.5.0.48
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tcl8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.46
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.44
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.42
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.40
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.38
	gdb_6_5-2006-05-14-branchpoint:1.5
	readline_5_1-import-branch:1.5.0.36
	readline_5_1-import-branchpoint:1.5
	gdb_6_4-branch:1.5.0.34
	gdb_6_4-2005-11-01-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.32
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	ezannoni_pie-20040323-branch:1.5.0.30
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.28
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.26
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.24
	cagney_x86i386-20030821-branch:1.5.0.22
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.20
	gdb_6_0-2003-06-23-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.18
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.16
	cagney_writestrings-20030508-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.14
	cagney_fileio-20030521-branchpoint:1.5
	carlton_dictionary-20030430-merge:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.12
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.10
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.8
	cagney_lazyid-20030317-branchpoint:1.5
	offbyone-20030313-branch:1.5.0.6
	offbyone-20030313-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.4
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.2
	interps-20030202-branchpoint:1.5
	TCL8_4_1:1.1.1.3
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.2
	TCL_8_4_1:1.1.1.3
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.4
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TCL_8_4_0:1.1.1.3
	carlton_dictionary-branch:1.2.0.16
	carlton_dictionary-20020920-branchpoint:1.2
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.14
	gdb_5_3-branch:1.2.0.12
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.10
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.8
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.6
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TCL_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	dejagnu-2000-02-04:1.1.1.1
	dejagnu-2000-01-31:1.1.1.1
	dejagnu-2000-01-24:1.1.1.1
	dejagnu-2000-01-17:1.1.1.1
	dejagnu-2000-01-10:1.1.1.1
	dejagnu-2000-01-04:1.1.1.1
	dejagnu-1999-12-21:1.1.1.1
	dejagnu-1999-12-13:1.1.1.1
	dejagnu-1999-12-07:1.1.1.1
	dejagnu-1999-12-06:1.1.1.1
	dejagnu-1999-11-15:1.1.1.1
	dejagnu-1999-11-08:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2003.01.21.19.40.16;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.26.19.48.02;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.37.08;	author kseitz;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2001.09.09.23.56.08;	author irox;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2002.09.27.21.49.11;	author kseitz;	state Exp;
branches;
next	;

1.3.4.1
date	2003.12.14.20.28.50;	author drow;	state Exp;
branches;
next	;

1.2.16.1
date	2002.12.23.19.40.44;	author carlton;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2003.02.07.19.18.20;	author carlton;	state Exp;
branches;
next	;

1.1.1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.09.22.40.59;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.19.56.40;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tcl 8.4.1
@
text
@# Commands tested in this file: socket.
#
# This file contains a collection of tests for one or more of the Tcl
# built-in commands.  Sourcing this file into Tcl runs the tests and
# generates output for errors.  No output means no errors were found.
#
# Copyright (c) 1994-1996 Sun Microsystems, Inc.
# Copyright (c) 1998-2000 Ajuba Solutions.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# RCS: @@(#) $Id: socket.test,v 1.26 2002/07/10 11:56:45 dgp Exp $

# Running socket tests with a remote server:
# ------------------------------------------
# 
# Some tests in socket.test depend on the existence of a remote server to
# which they connect. The remote server must be an instance of tcltest and it
# must run the script found in the file "remote.tcl" in this directory. You
# can start the remote server on any machine reachable from the machine on
# which you want to run the socket tests, by issuing:
# 
#     tcltest remote.tcl -port 2048	# Or choose another port number.
# 
# If the machine you are running the remote server on has several IP
# interfaces, you can choose which interface the server listens on for
# connections by specifying the -address command line flag, so:
# 
#     tcltest remote.tcl -address your.machine.com
# 
# These options can also be set by environment variables. On Unix, you can
# type these commands to the shell from which the remote server is started:
# 
#     shell% setenv serverPort 2048
#     shell% setenv serverAddress your.machine.com
# 
# and subsequently you can start the remote server with:
# 
#     tcltest remote.tcl
# 
# to have it listen on port 2048 on the interface your.machine.com.
#     
# When the server starts, it prints out a detailed message containing its
# configuration information, and it will block until killed with a Ctrl-C.
# Once the remote server exists, you can run the tests in socket.test with
# the server by setting two Tcl variables:
# 
#     % set remoteServerIP <name or address of machine on which server runs>
#     % set remoteServerPort 2048
# 
# These variables are also settable from the environment. On Unix, you can:
# 
#     shell% setenv remoteServerIP machine.where.server.runs
#     shell% senetv remoteServerPort 2048
# 
# The preamble of the socket.test file checks to see if the variables are set
# either in Tcl or in the environment; if they are, it attempts to connect to
# the server. If the connection is successful, the tests using the remote
# server will be performed; otherwise, it will attempt to start the remote
# server (via exec) on platforms that support this, on the local host,
# listening at port 2048. If all fails, a message is printed and the tests
# using the remote server are not performed.

package require tcltest 2
namespace import -force ::tcltest::*

# Some tests require the testthread and exec commands
testConstraint testthread [llength [info commands testthread]]
testConstraint exec [llength [info commands exec]]

# If remoteServerIP or remoteServerPort are not set, check in the
# environment variables for externally set values.
#

if {![info exists remoteServerIP]} {
    if {[info exists env(remoteServerIP)]} {
	set remoteServerIP $env(remoteServerIP)
    }
}
if {![info exists remoteServerPort]} {
    if {[info exists env(remoteServerIP)]} {
	set remoteServerPort $env(remoteServerPort)
    } else {
        if {[info exists remoteServerIP]} {
	    set remoteServerPort 2048
        }
    }
}

#
# Check if we're supposed to do tests against the remote server
#

set doTestsWithRemoteServer 1
if {![info exists remoteServerIP] && ($tcl_platform(platform) != "macintosh")} {
    set remoteServerIP 127.0.0.1
}
if {($doTestsWithRemoteServer == 1) && (![info exists remoteServerPort])} {
    set remoteServerPort 2048
}

# Attempt to connect to a remote server if one is already running. If it
# is not running or for some other reason the connect fails, attempt to
# start the remote server on the local host listening on port 2048. This
# is only done on platforms that support exec (i.e. not on the Mac). On
# platforms that do not support exec, the remote server must be started
# by the user before running the tests.

set remoteProcChan ""
set commandSocket ""
if {$doTestsWithRemoteServer} {
    catch {close $commandSocket}
    if {[catch {set commandSocket [socket $remoteServerIP \
						$remoteServerPort]}] != 0} {
	if {[info commands exec] == ""} {
	    set noRemoteTestReason "can't exec"
	    set doTestsWithRemoteServer 0
	} else {
	    set remoteServerIP 127.0.0.1
	    # Be *extra* careful in case this file is sourced from
	    # a directory other than the current one...
	    set remoteFile [file join [pwd] [file dirname [info script]] \
		    remote.tcl]
	    if {[catch {set remoteProcChan \
				[open "|[list [interpreter] $remoteFile \
					-serverIsSilent \
					-port $remoteServerPort \
					-address $remoteServerIP]" \
					w+]} \
		   msg] == 0} {
		after 1000
		if {[catch {set commandSocket [socket $remoteServerIP \
				$remoteServerPort]} msg] == 0} {
		    fconfigure $commandSocket -translation crlf -buffering line
		} else {
		    set noRemoteTestReason $msg
		    set doTestsWithRemoteServer 0
		}
	    } else {
		set noRemoteTestReason "$msg [interpreter]"
		set doTestsWithRemoteServer 0
	    }
	}
    } else {
	fconfigure $commandSocket -translation crlf -buffering line
    }
}

# Some tests are run only if we are doing testing against a remote server.
set ::tcltest::testConstraints(doTestsWithRemoteServer) $doTestsWithRemoteServer
if {$doTestsWithRemoteServer == 0} {
    if {[string first s $::tcltest::verbose] != -1} {
    	puts "Skipping tests with remote server. See tests/socket.test for"
	puts "information on how to run remote server."
	puts "Reason for not doing remote tests: $noRemoteTestReason"
    }
}

#
# If we do the tests, define a command to send a command to the
# remote server.
#

if {$doTestsWithRemoteServer == 1} {
    proc sendCommand {c} {
	global commandSocket

	if {[eof $commandSocket]} {
	    error "remote server disappeared"
	}

	if {[catch {puts $commandSocket $c} msg]} {
	    error "remote server disappaered: $msg"
	}
	if {[catch {puts $commandSocket "--Marker--Marker--Marker--"} msg]} {
	    error "remote server disappeared: $msg"
	}

	set resp ""
	while {1} {
	    set line [gets $commandSocket]
	    if {[eof $commandSocket]} {
		error "remote server disappaered"
	    }
	    if {[string compare $line "--Marker--Marker--Marker--"] == 0} {
		if {[string compare [lindex $resp 0] error] == 0} {
		    error [lindex $resp 1]
		} else {
		    return [lindex $resp 1]
		}
	    } else {
		append resp $line "\n"
	    }
	}
    }
}

test socket-1.1 {arg parsing for socket command} {socket} {
    list [catch {socket -server} msg] $msg
} {1 {no argument given for -server option}}
test socket-1.2 {arg parsing for socket command} {socket} {
    list [catch {socket -server foo} msg] $msg
} {1 {wrong # args: should be either:
socket ?-myaddr addr? ?-myport myport? ?-async? host port
socket -server command ?-myaddr addr? port}}
test socket-1.3 {arg parsing for socket command} {socket} {
    list [catch {socket -myaddr} msg] $msg
} {1 {no argument given for -myaddr option}}
test socket-1.4 {arg parsing for socket command} {socket} {
    list [catch {socket -myaddr 127.0.0.1} msg] $msg
} {1 {wrong # args: should be either:
socket ?-myaddr addr? ?-myport myport? ?-async? host port
socket -server command ?-myaddr addr? port}}
test socket-1.5 {arg parsing for socket command} {socket} {
    list [catch {socket -myport} msg] $msg
} {1 {no argument given for -myport option}}
test socket-1.6 {arg parsing for socket command} {socket} {
    list [catch {socket -myport xxxx} msg] $msg
} {1 {expected integer but got "xxxx"}}
test socket-1.7 {arg parsing for socket command} {socket} {
    list [catch {socket -myport 2522} msg] $msg
} {1 {wrong # args: should be either:
socket ?-myaddr addr? ?-myport myport? ?-async? host port
socket -server command ?-myaddr addr? port}}
test socket-1.8 {arg parsing for socket command} {socket} {
    list [catch {socket -froboz} msg] $msg
} {1 {bad option "-froboz": must be -async, -myaddr, -myport, or -server}}
test socket-1.9 {arg parsing for socket command} {socket} {
    list [catch {socket -server foo -myport 2521 3333} msg] $msg
} {1 {Option -myport is not valid for servers}}
test socket-1.10 {arg parsing for socket command} {socket} {
    list [catch {socket host 2528 -junk} msg] $msg
} {1 {wrong # args: should be either:
socket ?-myaddr addr? ?-myport myport? ?-async? host port
socket -server command ?-myaddr addr? port}}
test socket-1.11 {arg parsing for socket command} {socket} {
    list [catch {socket -server callback 2520 --} msg] $msg
} {1 {wrong # args: should be either:
socket ?-myaddr addr? ?-myport myport? ?-async? host port
socket -server command ?-myaddr addr? port}}
test socket-1.12 {arg parsing for socket command} {socket} {
    list [catch {socket foo badport} msg] $msg
} {1 {expected integer but got "badport"}}

set path(script) [makeFile {} script]

test socket-2.1 {tcp connection} {socket stdio} {
    removeFile script
    set f [open $path(script) w]
    puts $f {
	set timer [after 10000 "set x timed_out"]
	set f [socket -server accept 0]
	proc accept {file addr port} {
	    global x
	    set x done
            close $file
	}
	puts ready
	puts [lindex [fconfigure $f -sockname] 2]
	vwait x
	after cancel $timer
	close $f
	puts $x
    }
    close $f
    set f [open "|[list [interpreter] $path(script)]" r]
    gets $f x
    gets $f listen
    if {[catch {socket 127.0.0.1 $listen} msg]} {
        set x $msg
    } else {
        lappend x [gets $f]
        close $msg
    }
    lappend x [gets $f]
    close $f
    set x
} {ready done {}}

if [info exists port] {
    incr port
} else { 
    set port [expr 2048 + [pid]%1024]
}
test socket-2.2 {tcp connection with client port specified} {socket stdio} {
    removeFile script
    set f [open $path(script) w]
    puts $f {
	set timer [after 10000 "set x timeout"]
        set f [socket -server accept 0]
	proc accept {file addr port} {
            global x
            puts "[gets $file] $port"
            close $file
            set x done
	}
	puts ready
	puts [lindex [fconfigure $f -sockname] 2]
	vwait x
	after cancel $timer
	close $f
    }
    close $f
    set f [open "|[list [interpreter] $path(script)]" r]
    gets $f x
    gets $f listen
    global port
    if {[catch {socket -myport $port 127.0.0.1 $listen} sock]} {
        set x $sock
	close [socket 127.0.0.1 $listen]
	puts stderr $sock
    } else {
        puts $sock hello
	flush $sock
        lappend x [gets $f]
        close $sock
    }
    close $f
    set x
} [list ready "hello $port"]
test socket-2.3 {tcp connection with client interface specified} {socket stdio} {
    removeFile script
    set f [open $path(script) w]
    puts $f {
	set timer [after 2000 "set x done"]
        set f [socket  -server accept 2830]
	proc accept {file addr port} {
            global x
            puts "[gets $file] $addr"
            close $file
            set x done
	}
	puts ready
	vwait x
	after cancel $timer
	close $f
    }
    close $f
    set f [open "|[list [interpreter] $path(script)]" r]
    gets $f x
    if {[catch {socket -myaddr 127.0.0.1 127.0.0.1 2830} sock]} {
        set x $sock
    } else {
        puts $sock hello
	flush $sock
        lappend x [gets $f]
        close $sock
    }
    close $f
    set x
} {ready {hello 127.0.0.1}}
test socket-2.4 {tcp connection with server interface specified} {socket stdio} {
    removeFile script
    set f [open $path(script) w]
    puts $f {
	set timer [after 2000 "set x done"]
        set f [socket -server accept -myaddr 127.0.0.1 0]
	proc accept {file addr port} {
            global x
            puts "[gets $file]"
            close $file
            set x done
	}
	puts ready
	puts [lindex [fconfigure $f -sockname] 2]
	vwait x
	after cancel $timer
	close $f
    }
    close $f
    set f [open "|[list [interpreter] $path(script)]" r]
    gets $f x
    gets $f listen
    if {[catch {socket 127.0.0.1 $listen} sock]} {
        set x $sock
    } else {
        puts $sock hello
	flush $sock
        lappend x [gets $f]
        close $sock
    }
    close $f
    set x
} {ready hello}
test socket-2.5 {tcp connection with redundant server port} {socket stdio} {
    removeFile script
    set f [open $path(script) w]
    puts $f {
	set timer [after 10000 "set x timeout"]
        set f [socket -server accept 0]
	proc accept {file addr port} {
            global x
            puts "[gets $file]"
            close $file
            set x done
	}
	puts ready
	puts [lindex [fconfigure $f -sockname] 2]
	vwait x
	after cancel $timer
	close $f
    }
    close $f
    set f [open "|[list [interpreter] $path(script)]" r]
    gets $f x
    gets $f listen
    if {[catch {socket 127.0.0.1 $listen} sock]} {
        set x $sock
    } else {
        puts $sock hello
	flush $sock
        lappend x [gets $f]
        close $sock
    }
    close $f
    set x
} {ready hello}
test socket-2.6 {tcp connection} {socket} {
    set status ok
    if {![catch {set sock [socket 127.0.0.1 2833]}]} {
	if {![catch {gets $sock}]} {
	    set status broken
	}
	close $sock
    }
    set status
} ok
test socket-2.7 {echo server, one line} {socket stdio} {
    removeFile script
    set f [open $path(script) w]
    puts $f {
	set timer [after 10000 "set x timeout"]
	set f [socket -server accept 0]
	proc accept {s a p} {
            fileevent $s readable [list echo $s]
	    fconfigure $s -translation lf -buffering line
        }
	proc echo {s} {
	     set l [gets $s]
             if {[eof $s]} {
                 global x
                 close $s
                 set x done
             } else {
                 puts $s $l
             }
	}
	puts ready
	puts [lindex [fconfigure $f -sockname] 2]
	vwait x
	after cancel $timer
	close $f
	puts $x
    }
    close $f
    set f [open "|[list [interpreter] $path(script)]" r]
    gets $f
    gets $f listen
    set s [socket 127.0.0.1 $listen]
    fconfigure $s -buffering line -translation lf
    puts $s "hello abcdefghijklmnop"
    after 1000
    set x [gets $s]
    close $s
    set y [gets $f]
    close $f
    list $x $y
} {{hello abcdefghijklmnop} done}
test socket-2.8 {echo server, loop 50 times, single connection} {socket stdio} {
    makeFile {
	set f [socket -server accept 0]
	proc accept {s a p} {
            fileevent $s readable [list echo $s]
            fconfigure $s -buffering line
        }
	proc echo {s} {
	     global i
             set l [gets $s]
             if {[eof $s]} {
                 global x
                 close $s
                 set x done
             } else { 
	         incr i
                 puts $s $l
             }
	}
	set i 0
	puts ready
	puts [lindex [fconfigure $f -sockname] 2]
	set timer [after 20000 "set x done"]
	vwait x
	after cancel $timer
	close $f
	puts "done $i"
    } script
    set f [open "|[list [interpreter] $path(script)]" r]
    gets $f
    gets $f listen
    set s [socket 127.0.0.1 $listen]
    fconfigure $s -buffering line
    catch {
	for {set x 0} {$x < 50} {incr x} {
	    puts $s "hello abcdefghijklmnop"
	    gets $s
	}
    }
    close $s
    catch {set x [gets $f]}
    close $f
    set x
} {done 50}
test socket-2.9 {socket conflict} {socket stdio} {
    set s [socket -server accept 0]
    removeFile script
    set f [open $path(script) w]
    puts -nonewline $f "socket -server accept [lindex [fconfigure $s -sockname] 2]"
    close $f
    set f [open "|[list [interpreter] $path(script)]" r]
    gets $f
    after 100
    set x [list [catch {close $f} msg]]
    regsub "\n.*$" $msg {} msg ; # cut part of the error message containing the port number
    lappend x $msg
    close $s
    set x
} {1 {couldn't open socket: address already in use}}
test socket-2.10 {close on accept, accepted socket lives} {socket} {
    set done 0
    set timer [after 20000 "set done timed_out"]
    set ss [socket -server accept 0]
    proc accept {s a p} {
	global ss
	close $ss
	fileevent $s readable "readit $s"
	fconfigure $s -trans lf
    }
    proc readit {s} {
	global done
	gets $s
	close $s
	set done 1
    }
    set cs [socket [info hostname] [lindex [fconfigure $ss -sockname] 2]]
    puts $cs hello
    close $cs
    vwait done
    after cancel $timer
    set done
} 1
test socket-2.11 {detecting new data} {socket} {
    proc accept {s a p} {
	global sock
	set sock $s
    }

    set s [socket -server accept 0]
    set sock ""
    set s2 [socket 127.0.0.1 [lindex [fconfigure $s -sockname] 2]]
    vwait sock
    puts $s2 one
    flush $s2
    after 500
    fconfigure $sock -blocking 0
    set result a:[gets $sock]
    lappend result b:[gets $sock]
    fconfigure $sock -blocking 1
    puts $s2 two
    flush $s2
    fconfigure $sock -blocking 0
    lappend result c:[gets $sock]
    fconfigure $sock -blocking 1
    close $s2
    close $s
    close $sock
    set result
} {a:one b: c:two}


test socket-3.1 {socket conflict} {socket stdio} {
    removeFile script
    set f [open $path(script) w]
    puts $f {
	set f [socket -server accept 0]
	puts ready
	puts [lindex [fconfigure $f -sockname] 2]
	gets stdin
	close $f
    }
    close $f
    set f [open "|[list [interpreter] $path(script)]" r+]
    gets $f
    gets $f listen
    set x [list [catch {socket -server accept $listen} msg] \
		$msg]
    puts $f bye
    close $f
    set x
} {1 {couldn't open socket: address already in use}}
test socket-3.2 {server with several clients} {socket stdio} {
    removeFile script
    set f [open $path(script) w]
    puts $f {
	set t1 [after 30000 "set x timed_out"]
	set t2 [after 31000 "set x timed_out"]
	set t3 [after 32000 "set x timed_out"]
	set counter 0
	set s [socket -server accept 0]
	proc accept {s a p} {
	    fileevent $s readable [list echo $s]
	    fconfigure $s -buffering line
	}
	proc echo {s} {
	     global x
             set l [gets $s]
             if {[eof $s]} {
                 close $s
                 set x done
             } else {
                 puts $s $l
             }
	}
	puts ready
	puts [lindex [fconfigure $s -sockname] 2]
	vwait x
	after cancel $t1
	vwait x
	after cancel $t2
	vwait x
	after cancel $t3
	close $s
	puts $x
    }
    close $f
    set f [open "|[list [interpreter] $path(script)]" r+]
    set x [gets $f]
    gets $f listen
    set s1 [socket 127.0.0.1 $listen]
    fconfigure $s1 -buffering line
    set s2 [socket 127.0.0.1 $listen]
    fconfigure $s2 -buffering line
    set s3 [socket 127.0.0.1 $listen]
    fconfigure $s3 -buffering line
    for {set i 0} {$i < 100} {incr i} {
	puts $s1 hello,s1
	gets $s1
	puts $s2 hello,s2
	gets $s2
	puts $s3 hello,s3
	gets $s3
    }
    close $s1
    close $s2
    close $s3
    lappend x [gets $f]
    close $f
    set x
} {ready done}

test socket-4.1 {server with several clients} {socket stdio} {
    removeFile script
    set f [open $path(script) w]
    puts $f {
	set port [gets stdin]
	set s [socket 127.0.0.1 $port]
	fconfigure $s -buffering line
	for {set i 0} {$i < 100} {incr i} {
	    puts $s hello
	    gets $s
	}
	close $s
	puts bye
	gets stdin
    }
    close $f
    set p1 [open "|[list [interpreter] $path(script)]" r+]
    fconfigure $p1 -buffering line
    set p2 [open "|[list [interpreter] $path(script)]" r+]
    fconfigure $p2 -buffering line
    set p3 [open "|[list [interpreter] $path(script)]" r+]
    fconfigure $p3 -buffering line
    proc accept {s a p} {
	fconfigure $s -buffering line
	fileevent $s readable [list echo $s]
    }
    proc echo {s} {
	global x
        set l [gets $s]
        if {[eof $s]} {
            close $s
            set x done
        } else {
            puts $s $l
        }
    }
    set t1 [after 30000 "set x timed_out"]
    set t2 [after 31000 "set x timed_out"]
    set t3 [after 32000 "set x timed_out"]
    set s [socket -server accept 0]
    set listen [lindex [fconfigure $s -sockname] 2]
    puts $p1 $listen
    puts $p2 $listen
    puts $p3 $listen
    vwait x
    vwait x
    vwait x
    after cancel $t1
    after cancel $t2
    after cancel $t3
    close $s
    set l ""
    lappend l [list p1 [gets $p1] $x]
    lappend l [list p2 [gets $p2] $x]
    lappend l [list p3 [gets $p3] $x]
    puts $p1 bye
    puts $p2 bye
    puts $p3 bye
    close $p1
    close $p2
    close $p3
    set l
} {{p1 bye done} {p2 bye done} {p3 bye done}}
test socket-4.2 {byte order problems, socket numbers, htons} {socket} {
    set x ok
    if {[catch {socket -server dodo 0x3000} msg]} {
	set x $msg
    } else {
	close $msg
    }
    set x
} ok

test socket-5.1 {byte order problems, socket numbers, htons} \
	{socket unixOnly notRoot} {
    set x {couldn't open socket: not owner}
    if {![catch {socket -server dodo 0x1} msg]} {
        set x {htons problem, should be disallowed, are you running as SU?}
	close $msg
    }
    set x
} {couldn't open socket: not owner}
test socket-5.2 {byte order problems, socket numbers, htons} {socket} {
    set x {couldn't open socket: port number too high}
    if {![catch {socket -server dodo 0x10000} msg]} {
	set x {port resolution problem, should be disallowed}
	close $msg
    }
    set x
} {couldn't open socket: port number too high}
test socket-5.3 {byte order problems, socket numbers, htons} \
	{socket unixOnly notRoot} {
    set x {couldn't open socket: not owner}
    if {![catch {socket -server dodo 21} msg]} {
	set x {htons problem, should be disallowed, are you running as SU?}
	close $msg
    }
    set x
} {couldn't open socket: not owner}

test socket-6.1 {accept callback error} {socket stdio} {
    removeFile script
    set f [open $path(script) w]
    puts $f {
	gets stdin port
	socket 127.0.0.1 $port
    }
    close $f
    set f [open "|[list [interpreter] $path(script)]" r+]
    proc bgerror args {
	global x
	set x $args
    }
    proc accept {s a p} {expr 10 / 0}
    set s [socket -server accept 0]
    puts $f [lindex [fconfigure $s -sockname] 2]
    close $f
    set timer [after 10000 "set x timed_out"]
    vwait x
    after cancel $timer
    close $s
    rename bgerror {}
    set x
} {{divide by zero}}

test socket-7.1 {testing socket specific options} {socket stdio} {
    removeFile script
    set f [open $path(script) w]
    puts $f {
	set ss [socket -server accept 0]
	proc accept args {
	    global x
	    set x done
	}
	puts ready
	puts [lindex [fconfigure $ss -sockname] 2]
	set timer [after 10000 "set x timed_out"]
	vwait x
	after cancel $timer
    }
    close $f
    set f [open "|[list [interpreter] $path(script)]" r]
    gets $f
    gets $f listen
    set s [socket 127.0.0.1 $listen]
    set p [fconfigure $s -peername]
    close $s
    close $f
    set l ""
    lappend l [string compare [lindex $p 0] 127.0.0.1]
    lappend l [string compare [lindex $p 2] $listen]
    lappend l [llength $p]
} {0 0 3}
test socket-7.2 {testing socket specific options} {socket stdio} {
    removeFile script
    set f [open $path(script) w]
    puts $f {
	set ss [socket -server accept 2821]
	proc accept args {
	    global x
	    set x done
	}
	puts ready
	puts [lindex [fconfigure $ss -sockname] 2]
	set timer [after 10000 "set x timed_out"]
	vwait x
	after cancel $timer
    }
    close $f
    set f [open "|[list [interpreter] $path(script)]" r]
    gets $f
    gets $f listen
    set s [socket 127.0.0.1 $listen]
    set p [fconfigure $s -sockname]
    close $s
    close $f
    list [llength $p] \
	    [regexp {^(127\.0\.0\.1|0\.0\.0\.0)$} [lindex $p 0]] \
	    [expr {[lindex $p 2] == $listen}]
} {3 1 0}
test socket-7.3 {testing socket specific options} {socket} {
    set s [socket -server accept 0]
    set l [fconfigure $s]
    close $s
    update
    llength $l
} 14
test socket-7.4 {testing socket specific options} {socket} {
    set s [socket -server accept 0]
    proc accept {s a p} {
	global x
	set x [fconfigure $s -sockname]
	close $s
    }
    set listen [lindex [fconfigure $s -sockname] 2]
    set s1 [socket [info hostname] $listen]
    set timer [after 10000 "set x timed_out"]
    vwait x
    after cancel $timer
    close $s
    close $s1
    set l ""
    lappend l [expr {[lindex $x 2] == $listen}] [llength $x]
} {1 3}
test socket-7.5 {testing socket specific options} {socket unixOrPc} {
    set s [socket -server accept 0]
    proc accept {s a p} {
	global x
	set x [fconfigure $s -sockname]
	close $s
    }
    set listen [lindex [fconfigure $s -sockname] 2]
    set s1 [socket 127.0.0.1 $listen]
    set timer [after 10000 "set x timed_out"]
    vwait x
    after cancel $timer
    close $s
    close $s1
    set l ""
    lappend l [lindex $x 0] [expr {[lindex $x 2] == $listen}] [llength $x]
} {127.0.0.1 1 3}

test socket-8.1 {testing -async flag on sockets} {socket} {
    # NOTE: This test may fail on some Solaris 2.4 systems. If it does,
    # check that you have these patches installed (using showrev -p):
    #
    # 101907-05, 101925-02, 101945-14, 101959-03, 101969-05, 101973-03,
    # 101977-03, 101981-02, 101985-01, 102001-03, 102003-01, 102007-01,
    # 102011-02, 102024-01, 102039-01, 102044-01, 102048-01, 102062-03,
    # 102066-04, 102070-01, 102105-01, 102153-03, 102216-01, 102232-01,
    # 101878-03, 101879-01, 101880-03, 101933-01, 101950-01, 102030-01,
    # 102057-08, 102140-01, 101920-02, 101921-09, 101922-07, 101923-03
    #
    # If after installing these patches you are still experiencing a
    # problem, please email jyl@@eng.sun.com. We have not observed this
    # failure on Solaris 2.5, so another option (instead of installing
    # these patches) is to upgrade to Solaris 2.5.
    set s [socket -server accept 0]
    proc accept {s a p} {
	global x
	puts $s bye
	close $s
	set x done
    }
    set s1 [socket -async [info hostname] [lindex [fconfigure $s -sockname] 2]]
    vwait x
    set z [gets $s1]
    close $s
    close $s1
    set z
} bye

test socket-9.1 {testing spurious events} {socket} {
    set len 0
    set spurious 0
    set done 0
    proc readlittle {s} {
	global spurious done len
	set l [read $s 1]
	if {[string length $l] == 0} {
	    if {![eof $s]} {
		incr spurious
	    } else {
		close $s
		set done 1
	    }
	} else {
	    incr len [string length $l]
	}
    }
    proc accept {s a p} {
	fconfigure $s -buffering none -blocking off
	fileevent $s readable [list readlittle $s]
    }
    set s [socket -server accept 0]
    set c [socket [info hostname] [lindex [fconfigure $s -sockname] 2]]
    puts -nonewline $c 01234567890123456789012345678901234567890123456789
    close $c
    set timer [after 10000 "set done timed_out"]
    vwait done
    after cancel $timer
    close $s
    list $spurious $len
} {0 50}
test socket-9.2 {testing async write, fileevents, flush on close} {socket} {
    set firstblock ""
    for {set i 0} {$i < 5} {incr i} {set firstblock "a$firstblock$firstblock"}
    set secondblock ""
    for {set i 0} {$i < 16} {incr i} {
	set secondblock "b$secondblock$secondblock"
    }
    set l [socket -server accept 0]
    proc accept {s a p} {
	fconfigure $s -blocking 0 -translation lf -buffersize 16384 \
		-buffering line
	fileevent $s readable "readable $s"
    }
    proc readable {s} {
	set l [gets $s]
	fileevent $s readable {}
	after 1000 respond $s
    }
    proc respond {s} {
	global firstblock
	puts -nonewline $s $firstblock
	after 1000 writedata $s
    }
    proc writedata {s} {
	global secondblock
	puts -nonewline $s $secondblock
	close $s
    }
    set s [socket [info hostname] [lindex [fconfigure $l -sockname] 2]]
    fconfigure $s -blocking 0 -trans lf -buffering line
    set count 0
    puts $s hello
    proc readit {s} {
	global count done
	set l [read $s]
	incr count [string length $l]
	if {[eof $s]} {
	    close $s
	    set done 1
	}
    }
    fileevent $s readable "readit $s"
    set timer [after 10000 "set done timed_out"]
    vwait done
    after cancel $timer
    close $l
    set count
} 65566
test socket-9.3 {testing EOF stickyness} {socket} {
    proc count_to_eof {s} {
	global count done timer
	set l [gets $s]
	if {[eof $s]} {
	    incr count
	    if {$count > 9} {
		close $s
		set done true
		set count {eof is sticky}
		after cancel $timer
	    }
	}
    }
    proc timerproc {} {
	global done count c
	set done true
	set count {timer went off, eof is not sticky}
	close $c
    }	
    set count 0
    set done false
    proc write_then_close {s} {
	puts $s bye
	close $s
    }
    proc accept {s a p} {
	fconfigure $s -buffering line -translation lf
	fileevent $s writable "write_then_close $s"
    }
    set s [socket -server accept 0]
    set c [socket [info hostname] [lindex [fconfigure $s -sockname] 2]]
    fconfigure $c -blocking off -buffering line -translation lf
    fileevent $c readable "count_to_eof $c"
    set timer [after 1000 timerproc]
    vwait done
    close $s
    set count
} {eof is sticky}

removeFile script

test socket-10.1 {testing socket accept callback error handling} {socket} {
    set goterror 0
    proc bgerror args {global goterror; set goterror 1}
    set s [socket -server accept 0]
    proc accept {s a p} {close $s; error}
    set c [socket 127.0.0.1 [lindex [fconfigure $s -sockname] 2]]
    vwait goterror
    close $s
    close $c
    set goterror
} 1

test socket-11.1 {tcp connection} {socket doTestsWithRemoteServer} {
    sendCommand {
	set socket9_1_test_server [socket -server accept 2834]
	proc accept {s a p} {
	    puts $s done
	    close $s
	}
    }
    set s [socket $remoteServerIP 2834]
    set r [gets $s]
    close $s
    sendCommand {close $socket9_1_test_server}
    set r
} done
test socket-11.2 {client specifies its port} {socket doTestsWithRemoteServer} {
    if {[info exists port]} {
	incr port
    } else {
	set port [expr 2048 + [pid]%1024]
    }
    sendCommand {
	set socket9_2_test_server [socket -server accept 2835]
	proc accept {s a p} {
	    puts $s $p
	    close $s
	}
    }
    set s [socket -myport $port $remoteServerIP 2835]
    set r [gets $s]
    close $s
    sendCommand {close $socket9_2_test_server}
    if {$r == $port} {
	set result ok
    } else {
	set result broken
    }
    set result
} ok
test socket-11.3 {trying to connect, no server} {socket doTestsWithRemoteServer} {
    set status ok
    if {![catch {set s [socket $remoteServerIp 2836]}]} {
	if {![catch {gets $s}]} {
	    set status broken
	}
	close $s
    }
    set status
} ok
test socket-11.4 {remote echo, one line} {socket doTestsWithRemoteServer} {
    sendCommand {
	set socket10_6_test_server [socket -server accept 2836]
	proc accept {s a p} {
	    fileevent $s readable [list echo $s]
	    fconfigure $s -buffering line -translation crlf
	}
	proc echo {s} {
	    set l [gets $s]
	    if {[eof $s]} {
		close $s
	    } else {
		puts $s $l
	    }
	}
    }
    set f [socket $remoteServerIP 2836]
    fconfigure $f -translation crlf -buffering line
    puts $f hello
    set r [gets $f]
    close $f
    sendCommand {close $socket10_6_test_server}
    set r
} hello
test socket-11.5 {remote echo, 50 lines} {socket doTestsWithRemoteServer} {
    sendCommand {
	set socket10_7_test_server [socket -server accept 2836]
	proc accept {s a p} {
	    fileevent $s readable [list echo $s]
	    fconfigure $s -buffering line -translation crlf
	}
	proc echo {s} {
	    set l [gets $s]
	    if {[eof $s]} {
		close $s
	    } else {
		puts $s $l
	    }
	}
    }
    set f [socket $remoteServerIP 2836]
    fconfigure $f -translation crlf -buffering line
    for {set cnt 0} {$cnt < 50} {incr cnt} {
	puts $f "hello, $cnt"
	if {[string compare [gets $f] "hello, $cnt"] != 0} {
	    break
	}
    }
    close $f
    sendCommand {close $socket10_7_test_server}
    set cnt
} 50
# Macintosh sockets can have more than one server per port
if {$tcl_platform(platform) == "macintosh"} {
    set conflictResult {0 2836}
} else {
    set conflictResult {1 {couldn't open socket: address already in use}}
}
test socket-11.6 {socket conflict} {socket doTestsWithRemoteServer} {
    set s1 [socket -server accept 2836]
    if {[catch {set s2 [socket -server accept 2836]} msg]} {
	set result [list 1 $msg]
    } else {
	set result [list 0 [lindex [fconfigure $s2 -sockname] 2]]
	close $s2
    }
    close $s1
    set result
} $conflictResult
test socket-11.7 {server with several clients} {socket doTestsWithRemoteServer} {
    sendCommand {
	set socket10_9_test_server [socket -server accept 2836]
	proc accept {s a p} {
	    fconfigure $s -buffering line
	    fileevent $s readable [list echo $s]
	}
	proc echo {s} {
	    set l [gets $s]
	    if {[eof $s]} {
		close $s
	    } else {
		puts $s $l
	    }
	}
    }
    set s1 [socket $remoteServerIP 2836]
    fconfigure $s1 -buffering line
    set s2 [socket $remoteServerIP 2836]
    fconfigure $s2 -buffering line
    set s3 [socket $remoteServerIP 2836]
    fconfigure $s3 -buffering line
    for {set i 0} {$i < 100} {incr i} {
	puts $s1 hello,s1
	gets $s1
	puts $s2 hello,s2
	gets $s2
	puts $s3 hello,s3
	gets $s3
    }
    close $s1
    close $s2
    close $s3
    sendCommand {close $socket10_9_test_server}
    set i
} 100    
test socket-11.8 {client with several servers} {socket doTestsWithRemoteServer} {
    sendCommand {
	set s1 [socket -server "accept 4003" 4003]
	set s2 [socket -server "accept 4004" 4004]
	set s3 [socket -server "accept 4005" 4005]
	proc accept {mp s a p} {
	    puts $s $mp
	    close $s
	}
    }
    set s1 [socket $remoteServerIP 4003]
    set s2 [socket $remoteServerIP 4004]
    set s3 [socket $remoteServerIP 4005]
    set l ""
    lappend l [gets $s1] [gets $s1] [eof $s1] [gets $s2] [gets $s2] [eof $s2] \
	[gets $s3] [gets $s3] [eof $s3]
    close $s1
    close $s2
    close $s3
    sendCommand {
	close $s1
	close $s2
	close $s3
    }
    set l
} {4003 {} 1 4004 {} 1 4005 {} 1}
test socket-11.9 {accept callback error} {socket doTestsWithRemoteServer} {
    set s [socket -server accept 2836]
    proc accept {s a p} {expr 10 / 0}
    proc bgerror args {
	global x
	set x $args
    }
    if {[catch {sendCommand {
	    set peername [fconfigure $callerSocket -peername]
	    set s [socket [lindex $peername 0] 2836]
	    close $s
    	 }} msg]} {
	close $s
	error $msg
    }
    set timer [after 10000 "set x timed_out"]
    vwait x
    after cancel $timer
    close $s
    rename bgerror {}
    set x
} {{divide by zero}}
test socket-11.10 {testing socket specific options} {socket doTestsWithRemoteServer} {
    sendCommand {
	set socket10_12_test_server [socket -server accept 2836]
	proc accept {s a p} {close $s}
    }
    set s [socket $remoteServerIP 2836]
    set p [fconfigure $s -peername]
    set n [fconfigure $s -sockname]
    set l ""
    lappend l [lindex $p 2] [llength $p] [llength $p]
    close $s
    sendCommand {close $socket10_12_test_server}
    set l
} {2836 3 3}
test socket-11.11 {testing spurious events} {socket doTestsWithRemoteServer} {
    sendCommand {
	set socket10_13_test_server [socket -server accept 2836]
	proc accept {s a p} {
	    fconfigure $s -translation "auto lf"
	    after 100 writesome $s
	}
	proc writesome {s} {
	    for {set i 0} {$i < 100} {incr i} {
		puts $s "line $i from remote server"
	    }
	    close $s
	}
    }
    set len 0
    set spurious 0
    set done 0
    proc readlittle {s} {
	global spurious done len
	set l [read $s 1]
	if {[string length $l] == 0} {
	    if {![eof $s]} {
		incr spurious
	    } else {
		close $s
		set done 1
	    }
	} else {
	    incr len [string length $l]
	}
    }
    set c [socket $remoteServerIP 2836]
    fileevent $c readable "readlittle $c"
    set timer [after 10000 "set done timed_out"]
    vwait done
    after cancel $timer
    sendCommand {close $socket10_13_test_server}
    list $spurious $len
} {0 2690}

test socket-11.12 {testing EOF stickyness} {socket doTestsWithRemoteServer} {
    set counter 0
    set done 0
    proc count_up {s} {
	global counter done after_id
	set l [gets $s]
	if {[eof $s]} {
	    incr counter
	    if {$counter > 9} {
		set done {EOF is sticky}
		after cancel $after_id
		close $s
	    }
	}
    }
    proc timed_out {} {
	global c done
	set done {timed_out, EOF is not sticky}
	close $c
    }
    sendCommand {
	set socket10_14_test_server [socket -server accept 2836]
	proc accept {s a p} {
	    after 100 close $s
	}
    }
    set c [socket $remoteServerIP 2836]
    fileevent $c readable [list count_up $c]
    set after_id [after 1000 timed_out]
    vwait done
    sendCommand {close $socket10_14_test_server}
    set done
} {EOF is sticky}

test socket-11.13 {testing async write, async flush, async close} \
	{socket doTestsWithRemoteServer} {
    proc readit {s} {
	global count done
	set l [read $s]
	incr count [string length $l]
	if {[eof $s]} {
	    close $s
	    set done 1
	}
    }
    sendCommand {
	set firstblock ""
	for {set i 0} {$i < 5} {incr i} {
		set firstblock "a$firstblock$firstblock"
	}
	set secondblock ""
	for {set i 0} {$i < 16} {incr i} {
	    set secondblock "b$secondblock$secondblock"
	}
	set l [socket -server accept 2845]
	proc accept {s a p} {
	    fconfigure $s -blocking 0 -translation lf -buffersize 16384 \
		-buffering line
	    fileevent $s readable "readable $s"
	}
	proc readable {s} {
	    set l [gets $s]
	    fileevent $s readable {}
	    after 1000 respond $s
	}
	proc respond {s} {
	    global firstblock
	    puts -nonewline $s $firstblock
	    after 1000 writedata $s
	}
	proc writedata {s} {
	    global secondblock
	    puts -nonewline $s $secondblock
	    close $s
	}
    }
    set s [socket $remoteServerIP 2845]
    fconfigure $s -blocking 0 -trans lf -buffering line
    set count 0
    puts $s hello
    fileevent $s readable "readit $s"
    set timer [after 10000 "set done timed_out"]
    vwait done
    after cancel $timer
    sendCommand {close $l}
    set count
} 65566

set path(script1) [makeFile {} script1]
set path(script2) [makeFile {} script2]

test socket-12.1 {testing inheritance of server sockets} {socket stdio exec} {
    removeFile script1
    removeFile script2

    # Script1 is just a 10 second delay.  If the server socket
    # is inherited, it will be held open for 10 seconds

    set f [open $path(script1) w]
    puts $f {
	after 10000 exit
	vwait forever
    }
    close $f

    # Script2 creates the server socket, launches script1,
    # waits a second, and exits.  The server socket will now
    # be closed unless script1 inherited it.

    set f [open $path(script2) w]
    puts $f [list set tcltest [interpreter]]
    puts $f [format {
	set f [socket -server accept 0]
	puts [lindex [fconfigure $f -sockname] 2]
	proc accept { file addr port } {
	    close $file
	}
	exec $tcltest "%s" &
	close $f
	after 1000 exit
	vwait forever
    } $path(script1)]
    close $f
	
    # Launch script2 and wait 5 seconds

    ### exec [interpreter] script2 &
    set p [open "|[list [interpreter] $path(script2)]" r]
    gets $p listen

    after 5000 { set ok_to_proceed 1 }
    vwait ok_to_proceed

    # If we can still connect to the server, the socket got inherited.

    if {[catch {socket 127.0.0.1 $listen} msg]} {
	set x {server socket was not inherited}
    } else {
	close $msg
	set x {server socket was inherited}
    }

    removeFile script1
    removeFile script2
    close $p
    set x
} {server socket was not inherited}
test socket-12.2 {testing inheritance of client sockets} {socket stdio exec} {
    removeFile script1
    removeFile script2

    # Script1 is just a 20 second delay.  If the server socket
    # is inherited, it will be held open for 10 seconds

    set f [open $path(script1) w]
    puts $f {
	after 20000 exit
	vwait forever
    }
    close $f

    # Script2 opens the client socket and writes to it.  It then
    # launches script1 and exits.  If the child process inherited the
    # client socket, the socket will still be open.

    set f [open $path(script2) w]
    puts $f [list set tcltest [interpreter]]
    puts $f [format {
        gets stdin port
	set f [socket 127.0.0.1 $port]
	exec $tcltest "%s" &
	puts $f testing
	flush $f
	after 1000 exit
	vwait forever
    } $path(script1)]
    close $f

    # Create the server socket

    set server [socket -server accept 0]
    proc accept { file host port } {
	# When the client connects, establish the read handler
	global server
	close $server
	fileevent $file readable [list getdata $file]
	fconfigure $file -buffering line -blocking 0
	return
    }
    proc getdata { file } {
	# Read handler on the accepted socket.
	global x
	global failed
	set status [catch {read $file} data]
	if {$status != 0} {
	    set x {read failed, error was $data}
	    catch { close $file }
	} elseif {[string compare {} $data]} {
	} elseif {[fblocked $file]} {
	} elseif {[eof $file]} {
	    if {$failed} {
		set x {client socket was inherited}
	    } else {
		set x {client socket was not inherited}
	    }
	    catch { close $file }
	} else {
	    set x {impossible case}
	    catch { close $file }
	}
	return
    }

    # If the socket doesn't hit end-of-file in 10 seconds, the
    # script1 process must have inherited the client.

    set failed 0
    after 10000 [list set failed 1]

    # Launch the script2 process
    ### exec [interpreter] script2 &

    set p [open "|[list [interpreter] $path(script2)]" w]
    puts $p [lindex [fconfigure $server -sockname] 2] ; flush $p

    vwait x
    if {!$failed} {
	vwait failed
    }
    removeFile script1
    removeFile script2
    close $p
    set x
} {client socket was not inherited}
test socket-12.3 {testing inheritance of accepted sockets} {socket stdio exec} {
    removeFile script1
    removeFile script2

    set f [open $path(script1) w]
    puts $f {
	after 10000 exit
	vwait forever
    }
    close $f

    set f [open $path(script2) w]
    puts $f [list set tcltest [interpreter]]
    puts $f [format {
	set server [socket -server accept 0]
	puts stdout [lindex [fconfigure $server -sockname] 2]
	proc accept { file host port } {
	    global tcltest
	    puts $file {test data on socket}
	    exec $tcltest "%s" &
	    after 1000 exit
	}
	vwait forever
    } $path(script1)]
    close $f

    # Launch the script2 process and connect to it.  See how long
    # the socket stays open

    ## exec [interpreter] script2 &
    set p [open "|[list [interpreter] $path(script2)]" r]
    gets $p listen

    after 1000 set ok_to_proceed 1
    vwait ok_to_proceed

    set f [socket 127.0.0.1 $listen]
    fconfigure $f -buffering full -blocking 0
    fileevent $f readable [list getdata $f]

    # If the socket is still open after 5 seconds, the script1 process
    # must have inherited the accepted socket.

    set failed 0
    after 5000 set failed 1

    proc getdata { file } {
	# Read handler on the client socket.
	global x
	global failed
	set status [catch {read $file} data]
	if {$status != 0} {
	    set x {read failed, error was $data}
	    catch { close $file }
	} elseif {[string compare {} $data]} {
	} elseif {[fblocked $file]} {
	} elseif {[eof $file]} {
	    if {$failed} {
		set x {accepted socket was inherited}
	    } else {
		set x {accepted socket was not inherited}
	    }
	    catch { close $file }
	} else {
	    set x {impossible case}
	    catch { close $file }
	}
	return
    }
    
    vwait x

    removeFile script1
    removeFile script2
    close $p
    set x
} {accepted socket was not inherited}

test socket-13.1 {Testing use of shared socket between two threads} \
	{socket testthread} {

    removeFile script
    threadReap

    makeFile {
	set f [socket -server accept 0]
	set listen [lindex [fconfigure $f -sockname] 2]
	proc accept {s a p} {
            fileevent $s readable [list echo $s]
            fconfigure $s -buffering line
        }
	proc echo {s} {
	     global i
             set l [gets $s]
             if {[eof $s]} {
                 global x
                 close $s
                 set x done
             } else { 
	         incr i
                 puts $s $l
             }
	}
	set i 0
	vwait x
	close $f

	# thread cleans itself up.
	testthread exit
    } script
    
    # create a thread
    set serverthread [testthread create { source script } ]
    update
    set port [testthread send $serverthread {set listen}]
    update

    after 1000
    set s [socket 127.0.0.1 $port]
    fconfigure $s -buffering line

    catch {
	puts $s "hello"
	gets $s result
    }
    close $s
    update

    after 2000
    lappend result [threadReap]
    
    set result

} {hello 1}

# cleanup
if {[string match sock* $commandSocket] == 1} {
   puts $commandSocket exit
   flush $commandSocket
}
catch {close $commandSocket}
catch {close $remoteProcChan}
::tcltest::cleanupTests
flush stdout
return
@


1.4
log
@touched all sources to ease next import
@
text
@d13 1
a13 1
# RCS: @@(#) $Id: socket.test,v 1.6.8.2 2000/09/15 16:57:33 spolk Exp $
d65 2
a66 4
if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import -force ::tcltest::*
}
d69 2
a71 5
set ::tcltest::testConstraints(testthread) \
	[expr {[info commands testthread] != {}}]
set ::tcltest::testConstraints(exec) [expr {[info commands exec] != {}}]

#
d121 4
a124 1
	    set remoteFile [file join [pwd] remote.tcl]
d126 1
a126 1
				[open "|[list $::tcltest::tcltest $remoteFile \
d141 1
a141 1
		set noRemoteTestReason "$msg $::tcltest::tcltest"
d246 2
d250 1
a250 1
    set f [open script w]
d252 2
a253 2
	set timer [after 2000 "set x timed_out"]
	set f [socket -server accept 2828]
d260 1
d267 1
a267 1
    set f [open "|[list $::tcltest::tcltest script]" r]
d269 2
a270 1
    if {[catch {socket 127.0.0.1 2828} msg]} {
d288 1
a288 1
    set f [open script w]
d290 2
a291 2
	set timer [after 2000 "set x done"]
        set f [socket -server accept 2829]
d299 1
d305 1
a305 1
    set f [open "|[list $::tcltest::tcltest script]" r]
d307 1
d309 1
a309 1
    if {[catch {socket -myport $port 127.0.0.1 2829} sock]} {
d311 1
a311 1
	close [socket 127.0.0.1 2829]
d324 1
a324 1
    set f [open script w]
d340 1
a340 1
    set f [open "|[list $::tcltest::tcltest script]" r]
d355 1
a355 1
    set f [open script w]
d358 1
a358 1
        set f [socket -server accept -myaddr [info hostname] 2831]
d366 1
d372 1
a372 1
    set f [open "|[list $::tcltest::tcltest script]" r]
d374 2
a375 1
    if {[catch {socket [info hostname] 2831} sock]} {
d388 1
a388 1
    set f [open script w]
d390 2
a391 2
	set timer [after 2000 "set x done"]
        set f [socket -server accept 2832]
d399 1
d405 1
a405 1
    set f [open "|[list $::tcltest::tcltest script]" r]
d407 2
a408 1
    if {[catch {socket 127.0.0.1 2832} sock]} {
d431 1
a431 1
    set f [open script w]
d433 2
a434 2
	set timer [after 2000 "set x done"]
	set f [socket -server accept 2834]
d450 1
d454 1
a454 1
	puts done
d457 1
a457 1
    set f [open "|[list $::tcltest::tcltest script]" r]
d459 2
a460 1
    set s [socket 127.0.0.1 2834]
d472 1
a472 1
	set f [socket -server accept 2835]
d491 1
d498 1
a498 1
    set f [open "|[list $::tcltest::tcltest script]" r]
d500 2
a501 1
    set s [socket 127.0.0.1 2835]
d515 1
a515 1
    set s [socket -server accept 2828]
d517 2
a518 2
    set f [open script w]
    puts -nonewline $f {socket -server accept 2828}
d520 1
a520 1
    set f [open "|[list $::tcltest::tcltest script]" r]
d523 3
a525 1
    set x [list [catch {close $f} msg] $msg]
d528 1
a528 4
} {1 {couldn't open socket: address already in use
    while executing
"socket -server accept 2828"
    (file "script" line 1)}}
d532 1
a532 1
    set ss [socket -server accept 2830]
d545 1
a545 1
    set cs [socket [info hostname] 2830]
d558 1
a558 1
    set s [socket -server accept 2400]
d560 1
a560 1
    set s2 [socket 127.0.0.1 2400]
d583 1
a583 1
    set f [open script w]
d585 1
a585 1
	set f [socket -server accept 2828]
d587 1
d592 1
a592 1
    set f [open "|[list $::tcltest::tcltest script]" r+]
d594 2
a595 1
    set x [list [catch {socket -server accept 2828} msg] \
d603 1
a603 1
    set f [open script w]
d609 1
a609 1
	set s [socket -server accept 2828]
d625 1
d636 1
a636 1
    set f [open "|[list $::tcltest::tcltest script]" r+]
d638 2
a639 1
    set s1 [socket 127.0.0.1 2828]
d641 1
a641 1
    set s2 [socket 127.0.0.1 2828]
d643 1
a643 1
    set s3 [socket 127.0.0.1 2828]
d663 1
a663 1
    set f [open script w]
d665 2
a666 2
	gets stdin
	set s [socket 127.0.0.1 2828]
d677 1
a677 1
    set p1 [open "|[list $::tcltest::tcltest script]" r+]
d679 1
a679 1
    set p2 [open "|[list $::tcltest::tcltest script]" r+]
d681 1
a681 1
    set p3 [open "|[list $::tcltest::tcltest script]" r+]
d700 5
a704 4
    set s [socket -server accept 2828]
    puts $p1 open
    puts $p2 open
    puts $p3 open
d763 1
a763 1
    set f [open script w]
d765 2
a766 2
	gets stdin
	socket 127.0.0.1 2848
d769 1
a769 1
    set f [open "|[list $::tcltest::tcltest script]" r+]
d775 2
a776 2
    set s [socket -server accept 2848]
    puts $f hello
d788 1
a788 1
    set f [open script w]
d790 1
a790 1
	socket -server accept 2820
d796 1
d802 1
a802 1
    set f [open "|[list $::tcltest::tcltest script]" r]
d804 2
a805 1
    set s [socket 127.0.0.1 2820]
d811 1
a811 1
    lappend l [string compare [lindex $p 2] 2820]
d816 1
a816 1
    set f [open script w]
d818 1
a818 1
	socket -server accept 2821
d824 1
d830 1
a830 1
    set f [open "|[list $::tcltest::tcltest script]" r]
d832 2
a833 1
    set s [socket 127.0.0.1 2821]
d837 4
a840 5
    set l ""
    lappend l [llength $p]
    lappend l [lindex $p 0]
    lappend l [expr [lindex $p 2] == 2821]
} {3 127.0.0.1 0}
d842 1
a842 1
    set s [socket -server accept 2822]
d847 1
a847 1
} 12
d849 1
a849 1
    set s [socket -server accept 2823]
d855 2
a856 1
    set s1 [socket [info hostname] 2823]
d863 2
a864 2
    lappend l [lindex $x 2] [llength $x]
} {2823 3}
d866 1
a866 1
    set s [socket -server accept 2829]
d872 2
a873 1
    set s1 [socket 127.0.0.1 2829]
d880 2
a881 2
    lappend l [lindex $x 0] [lindex $x 2] [llength $x]
} {127.0.0.1 2829 3}
d898 1
a898 1
    set s [socket -server accept 2830]
d905 1
a905 1
    set s1 [socket -async [info hostname] 2830]
d935 2
a936 2
    set s [socket -server accept 2831]
    set c [socket [info hostname] 2831]
d952 1
a952 1
    set l [socket -server accept 2832]
d973 1
a973 1
    set s [socket [info hostname] 2832]
d1023 2
a1024 2
    set s [socket -server accept 2833]
    set c [socket [info hostname] 2833]
d1038 1
a1038 1
    set s [socket -server accept 2898]
d1040 1
a1040 1
    set c [socket 127.0.0.1 2898]
d1390 4
a1393 1
test socket-12.1 {testing inheritance of server sockets} {socket exec} {
d1400 1
a1400 1
    set f [open script1 w]
d1411 5
a1415 4
    set f [open script2 w]
    puts $f [list set tclsh $::tcltest::tcltest]
    puts $f {
	set f [socket -server accept 2828]
d1419 1
a1419 1
	exec $tclsh script1 &
d1423 1
a1423 1
    }
d1428 4
a1431 1
    exec $::tcltest::tcltest script2 &
d1437 1
a1437 1
    if {[catch {socket 127.0.0.1 2828} msg]} {
d1446 1
d1449 1
a1449 1
test socket-12.2 {testing inheritance of client sockets} {socket exec} {
d1453 1
a1453 1
    # Script1 is just a 10 second delay.  If the server socket
d1456 1
a1456 1
    set f [open script1 w]
d1458 1
a1458 1
	after 10000 exit
d1467 6
a1472 5
    set f [open script2 w]
    puts $f [list set tclsh $::tcltest::tcltest]
    puts $f {
	set f [socket 127.0.0.1 2829]
	exec $tclsh script1 &
d1477 1
a1477 1
    }
d1482 1
a1482 1
    set server [socket -server accept 2829]
d1515 1
a1515 1
    # If the socket doesn't hit end-of-file in 5 seconds, the
d1519 1
a1519 1
    after 5000 [list set failed 1]
d1522 1
d1524 2
a1525 1
    exec $::tcltest::tcltest script2 &
d1533 1
d1536 1
a1536 1
test socket-12.3 {testing inheritance of accepted sockets} {socket exec} {
d1540 1
a1540 1
    set f [open script1 w]
d1547 5
a1551 4
    set f [open script2 w]
    puts $f [list set tclsh $::tcltest::tcltest]
    puts $f {
	set server [socket -server accept 2931]
d1553 1
a1553 1
	    global tclsh
d1555 1
a1555 1
	    exec $tclsh script1 &
d1559 1
a1559 1
    }
d1565 3
a1567 1
    exec $::tcltest::tcltest script2 &
d1572 1
a1572 1
    set f [socket 127.0.0.1 2931]
d1610 1
d1621 2
a1622 1
	set f [socket -server accept 2828]
d1650 3
a1652 1
    
d1654 1
a1654 1
    set s [socket 127.0.0.1 2828]
a1680 1

@


1.3
log
@touched all sources to ease next import
@
text
@@


1.3.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d13 1
a13 1
# RCS: @@(#) $Id: socket.test,v 1.26 2002/07/10 11:56:45 dgp Exp $
d65 4
a68 2
package require tcltest 2
namespace import -force ::tcltest::*
a70 2
testConstraint testthread [llength [info commands testthread]]
testConstraint exec [llength [info commands exec]]
d72 5
d126 1
a126 4
	    # Be *extra* careful in case this file is sourced from
	    # a directory other than the current one...
	    set remoteFile [file join [pwd] [file dirname [info script]] \
		    remote.tcl]
d128 1
a128 1
				[open "|[list [interpreter] $remoteFile \
d143 1
a143 1
		set noRemoteTestReason "$msg [interpreter]"
a247 2
set path(script) [makeFile {} script]

d250 1
a250 1
    set f [open $path(script) w]
d252 2
a253 2
	set timer [after 10000 "set x timed_out"]
	set f [socket -server accept 0]
a259 1
	puts [lindex [fconfigure $f -sockname] 2]
d266 1
a266 1
    set f [open "|[list [interpreter] $path(script)]" r]
d268 1
a268 2
    gets $f listen
    if {[catch {socket 127.0.0.1 $listen} msg]} {
d286 1
a286 1
    set f [open $path(script) w]
d288 2
a289 2
	set timer [after 10000 "set x timeout"]
        set f [socket -server accept 0]
a296 1
	puts [lindex [fconfigure $f -sockname] 2]
d302 1
a302 1
    set f [open "|[list [interpreter] $path(script)]" r]
a303 1
    gets $f listen
d305 1
a305 1
    if {[catch {socket -myport $port 127.0.0.1 $listen} sock]} {
d307 1
a307 1
	close [socket 127.0.0.1 $listen]
d320 1
a320 1
    set f [open $path(script) w]
d336 1
a336 1
    set f [open "|[list [interpreter] $path(script)]" r]
d351 1
a351 1
    set f [open $path(script) w]
d354 1
a354 1
        set f [socket -server accept -myaddr 127.0.0.1 0]
a361 1
	puts [lindex [fconfigure $f -sockname] 2]
d367 1
a367 1
    set f [open "|[list [interpreter] $path(script)]" r]
d369 1
a369 2
    gets $f listen
    if {[catch {socket 127.0.0.1 $listen} sock]} {
d382 1
a382 1
    set f [open $path(script) w]
d384 2
a385 2
	set timer [after 10000 "set x timeout"]
        set f [socket -server accept 0]
a392 1
	puts [lindex [fconfigure $f -sockname] 2]
d398 1
a398 1
    set f [open "|[list [interpreter] $path(script)]" r]
d400 1
a400 2
    gets $f listen
    if {[catch {socket 127.0.0.1 $listen} sock]} {
d423 1
a423 1
    set f [open $path(script) w]
d425 2
a426 2
	set timer [after 10000 "set x timeout"]
	set f [socket -server accept 0]
a441 1
	puts [lindex [fconfigure $f -sockname] 2]
d445 1
a445 1
	puts $x
d448 1
a448 1
    set f [open "|[list [interpreter] $path(script)]" r]
d450 1
a450 2
    gets $f listen
    set s [socket 127.0.0.1 $listen]
d462 1
a462 1
	set f [socket -server accept 0]
a480 1
	puts [lindex [fconfigure $f -sockname] 2]
d487 1
a487 1
    set f [open "|[list [interpreter] $path(script)]" r]
d489 1
a489 2
    gets $f listen
    set s [socket 127.0.0.1 $listen]
d503 1
a503 1
    set s [socket -server accept 0]
d505 2
a506 2
    set f [open $path(script) w]
    puts -nonewline $f "socket -server accept [lindex [fconfigure $s -sockname] 2]"
d508 1
a508 1
    set f [open "|[list [interpreter] $path(script)]" r]
d511 1
a511 3
    set x [list [catch {close $f} msg]]
    regsub "\n.*$" $msg {} msg ; # cut part of the error message containing the port number
    lappend x $msg
d514 4
a517 1
} {1 {couldn't open socket: address already in use}}
d521 1
a521 1
    set ss [socket -server accept 0]
d534 1
a534 1
    set cs [socket [info hostname] [lindex [fconfigure $ss -sockname] 2]]
d547 1
a547 1
    set s [socket -server accept 0]
d549 1
a549 1
    set s2 [socket 127.0.0.1 [lindex [fconfigure $s -sockname] 2]]
d572 1
a572 1
    set f [open $path(script) w]
d574 1
a574 1
	set f [socket -server accept 0]
a575 1
	puts [lindex [fconfigure $f -sockname] 2]
d580 1
a580 1
    set f [open "|[list [interpreter] $path(script)]" r+]
d582 1
a582 2
    gets $f listen
    set x [list [catch {socket -server accept $listen} msg] \
d590 1
a590 1
    set f [open $path(script) w]
d596 1
a596 1
	set s [socket -server accept 0]
a611 1
	puts [lindex [fconfigure $s -sockname] 2]
d622 1
a622 1
    set f [open "|[list [interpreter] $path(script)]" r+]
d624 1
a624 2
    gets $f listen
    set s1 [socket 127.0.0.1 $listen]
d626 1
a626 1
    set s2 [socket 127.0.0.1 $listen]
d628 1
a628 1
    set s3 [socket 127.0.0.1 $listen]
d648 1
a648 1
    set f [open $path(script) w]
d650 2
a651 2
	set port [gets stdin]
	set s [socket 127.0.0.1 $port]
d662 1
a662 1
    set p1 [open "|[list [interpreter] $path(script)]" r+]
d664 1
a664 1
    set p2 [open "|[list [interpreter] $path(script)]" r+]
d666 1
a666 1
    set p3 [open "|[list [interpreter] $path(script)]" r+]
d685 4
a688 5
    set s [socket -server accept 0]
    set listen [lindex [fconfigure $s -sockname] 2]
    puts $p1 $listen
    puts $p2 $listen
    puts $p3 $listen
d747 1
a747 1
    set f [open $path(script) w]
d749 2
a750 2
	gets stdin port
	socket 127.0.0.1 $port
d753 1
a753 1
    set f [open "|[list [interpreter] $path(script)]" r+]
d759 2
a760 2
    set s [socket -server accept 0]
    puts $f [lindex [fconfigure $s -sockname] 2]
d772 1
a772 1
    set f [open $path(script) w]
d774 1
a774 1
	set ss [socket -server accept 0]
a779 1
	puts [lindex [fconfigure $ss -sockname] 2]
d785 1
a785 1
    set f [open "|[list [interpreter] $path(script)]" r]
d787 1
a787 2
    gets $f listen
    set s [socket 127.0.0.1 $listen]
d793 1
a793 1
    lappend l [string compare [lindex $p 2] $listen]
d798 1
a798 1
    set f [open $path(script) w]
d800 1
a800 1
	set ss [socket -server accept 2821]
a805 1
	puts [lindex [fconfigure $ss -sockname] 2]
d811 1
a811 1
    set f [open "|[list [interpreter] $path(script)]" r]
d813 1
a813 2
    gets $f listen
    set s [socket 127.0.0.1 $listen]
d817 5
a821 4
    list [llength $p] \
	    [regexp {^(127\.0\.0\.1|0\.0\.0\.0)$} [lindex $p 0]] \
	    [expr {[lindex $p 2] == $listen}]
} {3 1 0}
d823 1
a823 1
    set s [socket -server accept 0]
d828 1
a828 1
} 14
d830 1
a830 1
    set s [socket -server accept 0]
d836 1
a836 2
    set listen [lindex [fconfigure $s -sockname] 2]
    set s1 [socket [info hostname] $listen]
d843 2
a844 2
    lappend l [expr {[lindex $x 2] == $listen}] [llength $x]
} {1 3}
d846 1
a846 1
    set s [socket -server accept 0]
d852 1
a852 2
    set listen [lindex [fconfigure $s -sockname] 2]
    set s1 [socket 127.0.0.1 $listen]
d859 2
a860 2
    lappend l [lindex $x 0] [expr {[lindex $x 2] == $listen}] [llength $x]
} {127.0.0.1 1 3}
d877 1
a877 1
    set s [socket -server accept 0]
d884 1
a884 1
    set s1 [socket -async [info hostname] [lindex [fconfigure $s -sockname] 2]]
d914 2
a915 2
    set s [socket -server accept 0]
    set c [socket [info hostname] [lindex [fconfigure $s -sockname] 2]]
d931 1
a931 1
    set l [socket -server accept 0]
d952 1
a952 1
    set s [socket [info hostname] [lindex [fconfigure $l -sockname] 2]]
d1002 2
a1003 2
    set s [socket -server accept 0]
    set c [socket [info hostname] [lindex [fconfigure $s -sockname] 2]]
d1017 1
a1017 1
    set s [socket -server accept 0]
d1019 1
a1019 1
    set c [socket 127.0.0.1 [lindex [fconfigure $s -sockname] 2]]
d1369 1
a1369 4
set path(script1) [makeFile {} script1]
set path(script2) [makeFile {} script2]

test socket-12.1 {testing inheritance of server sockets} {socket stdio exec} {
d1376 1
a1376 1
    set f [open $path(script1) w]
d1387 4
a1390 5
    set f [open $path(script2) w]
    puts $f [list set tcltest [interpreter]]
    puts $f [format {
	set f [socket -server accept 0]
	puts [lindex [fconfigure $f -sockname] 2]
d1394 1
a1394 1
	exec $tcltest "%s" &
d1398 1
a1398 1
    } $path(script1)]
d1403 1
a1403 4
    ### exec [interpreter] script2 &
    set p [open "|[list [interpreter] $path(script2)]" r]
    gets $p listen

d1409 1
a1409 1
    if {[catch {socket 127.0.0.1 $listen} msg]} {
a1417 1
    close $p
d1420 1
a1420 1
test socket-12.2 {testing inheritance of client sockets} {socket stdio exec} {
d1424 1
a1424 1
    # Script1 is just a 20 second delay.  If the server socket
d1427 1
a1427 1
    set f [open $path(script1) w]
d1429 1
a1429 1
	after 20000 exit
d1438 5
a1442 6
    set f [open $path(script2) w]
    puts $f [list set tcltest [interpreter]]
    puts $f [format {
        gets stdin port
	set f [socket 127.0.0.1 $port]
	exec $tcltest "%s" &
d1447 1
a1447 1
    } $path(script1)]
d1452 1
a1452 1
    set server [socket -server accept 0]
d1485 1
a1485 1
    # If the socket doesn't hit end-of-file in 10 seconds, the
d1489 1
a1489 1
    after 10000 [list set failed 1]
a1491 1
    ### exec [interpreter] script2 &
d1493 1
a1493 2
    set p [open "|[list [interpreter] $path(script2)]" w]
    puts $p [lindex [fconfigure $server -sockname] 2] ; flush $p
a1500 1
    close $p
d1503 1
a1503 1
test socket-12.3 {testing inheritance of accepted sockets} {socket stdio exec} {
d1507 1
a1507 1
    set f [open $path(script1) w]
d1514 4
a1517 5
    set f [open $path(script2) w]
    puts $f [list set tcltest [interpreter]]
    puts $f [format {
	set server [socket -server accept 0]
	puts stdout [lindex [fconfigure $server -sockname] 2]
d1519 1
a1519 1
	    global tcltest
d1521 1
a1521 1
	    exec $tcltest "%s" &
d1525 1
a1525 1
    } $path(script1)]
d1531 1
a1531 3
    ## exec [interpreter] script2 &
    set p [open "|[list [interpreter] $path(script2)]" r]
    gets $p listen
d1536 1
a1536 1
    set f [socket 127.0.0.1 $listen]
a1573 1
    close $p
d1584 1
a1584 2
	set f [socket -server accept 0]
	set listen [lindex [fconfigure $f -sockname] 2]
d1612 1
a1612 3
    set port [testthread send $serverthread {set listen}]
    update

d1614 1
a1614 1
    set s [socket 127.0.0.1 $port]
d1641 1
@


1.3.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@d13 1
a13 1
# RCS: @@(#) $Id: socket.test,v 1.26 2002/07/10 11:56:45 dgp Exp $
d65 4
a68 2
package require tcltest 2
namespace import -force ::tcltest::*
a70 2
testConstraint testthread [llength [info commands testthread]]
testConstraint exec [llength [info commands exec]]
d72 5
d126 1
a126 4
	    # Be *extra* careful in case this file is sourced from
	    # a directory other than the current one...
	    set remoteFile [file join [pwd] [file dirname [info script]] \
		    remote.tcl]
d128 1
a128 1
				[open "|[list [interpreter] $remoteFile \
d143 1
a143 1
		set noRemoteTestReason "$msg [interpreter]"
a247 2
set path(script) [makeFile {} script]

d250 1
a250 1
    set f [open $path(script) w]
d252 2
a253 2
	set timer [after 10000 "set x timed_out"]
	set f [socket -server accept 0]
a259 1
	puts [lindex [fconfigure $f -sockname] 2]
d266 1
a266 1
    set f [open "|[list [interpreter] $path(script)]" r]
d268 1
a268 2
    gets $f listen
    if {[catch {socket 127.0.0.1 $listen} msg]} {
d286 1
a286 1
    set f [open $path(script) w]
d288 2
a289 2
	set timer [after 10000 "set x timeout"]
        set f [socket -server accept 0]
a296 1
	puts [lindex [fconfigure $f -sockname] 2]
d302 1
a302 1
    set f [open "|[list [interpreter] $path(script)]" r]
a303 1
    gets $f listen
d305 1
a305 1
    if {[catch {socket -myport $port 127.0.0.1 $listen} sock]} {
d307 1
a307 1
	close [socket 127.0.0.1 $listen]
d320 1
a320 1
    set f [open $path(script) w]
d336 1
a336 1
    set f [open "|[list [interpreter] $path(script)]" r]
d351 1
a351 1
    set f [open $path(script) w]
d354 1
a354 1
        set f [socket -server accept -myaddr 127.0.0.1 0]
a361 1
	puts [lindex [fconfigure $f -sockname] 2]
d367 1
a367 1
    set f [open "|[list [interpreter] $path(script)]" r]
d369 1
a369 2
    gets $f listen
    if {[catch {socket 127.0.0.1 $listen} sock]} {
d382 1
a382 1
    set f [open $path(script) w]
d384 2
a385 2
	set timer [after 10000 "set x timeout"]
        set f [socket -server accept 0]
a392 1
	puts [lindex [fconfigure $f -sockname] 2]
d398 1
a398 1
    set f [open "|[list [interpreter] $path(script)]" r]
d400 1
a400 2
    gets $f listen
    if {[catch {socket 127.0.0.1 $listen} sock]} {
d423 1
a423 1
    set f [open $path(script) w]
d425 2
a426 2
	set timer [after 10000 "set x timeout"]
	set f [socket -server accept 0]
a441 1
	puts [lindex [fconfigure $f -sockname] 2]
d445 1
a445 1
	puts $x
d448 1
a448 1
    set f [open "|[list [interpreter] $path(script)]" r]
d450 1
a450 2
    gets $f listen
    set s [socket 127.0.0.1 $listen]
d462 1
a462 1
	set f [socket -server accept 0]
a480 1
	puts [lindex [fconfigure $f -sockname] 2]
d487 1
a487 1
    set f [open "|[list [interpreter] $path(script)]" r]
d489 1
a489 2
    gets $f listen
    set s [socket 127.0.0.1 $listen]
d503 1
a503 1
    set s [socket -server accept 0]
d505 2
a506 2
    set f [open $path(script) w]
    puts -nonewline $f "socket -server accept [lindex [fconfigure $s -sockname] 2]"
d508 1
a508 1
    set f [open "|[list [interpreter] $path(script)]" r]
d511 1
a511 3
    set x [list [catch {close $f} msg]]
    regsub "\n.*$" $msg {} msg ; # cut part of the error message containing the port number
    lappend x $msg
d514 4
a517 1
} {1 {couldn't open socket: address already in use}}
d521 1
a521 1
    set ss [socket -server accept 0]
d534 1
a534 1
    set cs [socket [info hostname] [lindex [fconfigure $ss -sockname] 2]]
d547 1
a547 1
    set s [socket -server accept 0]
d549 1
a549 1
    set s2 [socket 127.0.0.1 [lindex [fconfigure $s -sockname] 2]]
d572 1
a572 1
    set f [open $path(script) w]
d574 1
a574 1
	set f [socket -server accept 0]
a575 1
	puts [lindex [fconfigure $f -sockname] 2]
d580 1
a580 1
    set f [open "|[list [interpreter] $path(script)]" r+]
d582 1
a582 2
    gets $f listen
    set x [list [catch {socket -server accept $listen} msg] \
d590 1
a590 1
    set f [open $path(script) w]
d596 1
a596 1
	set s [socket -server accept 0]
a611 1
	puts [lindex [fconfigure $s -sockname] 2]
d622 1
a622 1
    set f [open "|[list [interpreter] $path(script)]" r+]
d624 1
a624 2
    gets $f listen
    set s1 [socket 127.0.0.1 $listen]
d626 1
a626 1
    set s2 [socket 127.0.0.1 $listen]
d628 1
a628 1
    set s3 [socket 127.0.0.1 $listen]
d648 1
a648 1
    set f [open $path(script) w]
d650 2
a651 2
	set port [gets stdin]
	set s [socket 127.0.0.1 $port]
d662 1
a662 1
    set p1 [open "|[list [interpreter] $path(script)]" r+]
d664 1
a664 1
    set p2 [open "|[list [interpreter] $path(script)]" r+]
d666 1
a666 1
    set p3 [open "|[list [interpreter] $path(script)]" r+]
d685 4
a688 5
    set s [socket -server accept 0]
    set listen [lindex [fconfigure $s -sockname] 2]
    puts $p1 $listen
    puts $p2 $listen
    puts $p3 $listen
d747 1
a747 1
    set f [open $path(script) w]
d749 2
a750 2
	gets stdin port
	socket 127.0.0.1 $port
d753 1
a753 1
    set f [open "|[list [interpreter] $path(script)]" r+]
d759 2
a760 2
    set s [socket -server accept 0]
    puts $f [lindex [fconfigure $s -sockname] 2]
d772 1
a772 1
    set f [open $path(script) w]
d774 1
a774 1
	set ss [socket -server accept 0]
a779 1
	puts [lindex [fconfigure $ss -sockname] 2]
d785 1
a785 1
    set f [open "|[list [interpreter] $path(script)]" r]
d787 1
a787 2
    gets $f listen
    set s [socket 127.0.0.1 $listen]
d793 1
a793 1
    lappend l [string compare [lindex $p 2] $listen]
d798 1
a798 1
    set f [open $path(script) w]
d800 1
a800 1
	set ss [socket -server accept 2821]
a805 1
	puts [lindex [fconfigure $ss -sockname] 2]
d811 1
a811 1
    set f [open "|[list [interpreter] $path(script)]" r]
d813 1
a813 2
    gets $f listen
    set s [socket 127.0.0.1 $listen]
d817 5
a821 4
    list [llength $p] \
	    [regexp {^(127\.0\.0\.1|0\.0\.0\.0)$} [lindex $p 0]] \
	    [expr {[lindex $p 2] == $listen}]
} {3 1 0}
d823 1
a823 1
    set s [socket -server accept 0]
d828 1
a828 1
} 14
d830 1
a830 1
    set s [socket -server accept 0]
d836 1
a836 2
    set listen [lindex [fconfigure $s -sockname] 2]
    set s1 [socket [info hostname] $listen]
d843 2
a844 2
    lappend l [expr {[lindex $x 2] == $listen}] [llength $x]
} {1 3}
d846 1
a846 1
    set s [socket -server accept 0]
d852 1
a852 2
    set listen [lindex [fconfigure $s -sockname] 2]
    set s1 [socket 127.0.0.1 $listen]
d859 2
a860 2
    lappend l [lindex $x 0] [expr {[lindex $x 2] == $listen}] [llength $x]
} {127.0.0.1 1 3}
d877 1
a877 1
    set s [socket -server accept 0]
d884 1
a884 1
    set s1 [socket -async [info hostname] [lindex [fconfigure $s -sockname] 2]]
d914 2
a915 2
    set s [socket -server accept 0]
    set c [socket [info hostname] [lindex [fconfigure $s -sockname] 2]]
d931 1
a931 1
    set l [socket -server accept 0]
d952 1
a952 1
    set s [socket [info hostname] [lindex [fconfigure $l -sockname] 2]]
d1002 2
a1003 2
    set s [socket -server accept 0]
    set c [socket [info hostname] [lindex [fconfigure $s -sockname] 2]]
d1017 1
a1017 1
    set s [socket -server accept 0]
d1019 1
a1019 1
    set c [socket 127.0.0.1 [lindex [fconfigure $s -sockname] 2]]
d1369 1
a1369 4
set path(script1) [makeFile {} script1]
set path(script2) [makeFile {} script2]

test socket-12.1 {testing inheritance of server sockets} {socket stdio exec} {
d1376 1
a1376 1
    set f [open $path(script1) w]
d1387 4
a1390 5
    set f [open $path(script2) w]
    puts $f [list set tcltest [interpreter]]
    puts $f [format {
	set f [socket -server accept 0]
	puts [lindex [fconfigure $f -sockname] 2]
d1394 1
a1394 1
	exec $tcltest "%s" &
d1398 1
a1398 1
    } $path(script1)]
d1403 1
a1403 4
    ### exec [interpreter] script2 &
    set p [open "|[list [interpreter] $path(script2)]" r]
    gets $p listen

d1409 1
a1409 1
    if {[catch {socket 127.0.0.1 $listen} msg]} {
a1417 1
    close $p
d1420 1
a1420 1
test socket-12.2 {testing inheritance of client sockets} {socket stdio exec} {
d1424 1
a1424 1
    # Script1 is just a 20 second delay.  If the server socket
d1427 1
a1427 1
    set f [open $path(script1) w]
d1429 1
a1429 1
	after 20000 exit
d1438 5
a1442 6
    set f [open $path(script2) w]
    puts $f [list set tcltest [interpreter]]
    puts $f [format {
        gets stdin port
	set f [socket 127.0.0.1 $port]
	exec $tcltest "%s" &
d1447 1
a1447 1
    } $path(script1)]
d1452 1
a1452 1
    set server [socket -server accept 0]
d1485 1
a1485 1
    # If the socket doesn't hit end-of-file in 10 seconds, the
d1489 1
a1489 1
    after 10000 [list set failed 1]
a1491 1
    ### exec [interpreter] script2 &
d1493 1
a1493 2
    set p [open "|[list [interpreter] $path(script2)]" w]
    puts $p [lindex [fconfigure $server -sockname] 2] ; flush $p
a1500 1
    close $p
d1503 1
a1503 1
test socket-12.3 {testing inheritance of accepted sockets} {socket stdio exec} {
d1507 1
a1507 1
    set f [open $path(script1) w]
d1514 4
a1517 5
    set f [open $path(script2) w]
    puts $f [list set tcltest [interpreter]]
    puts $f [format {
	set server [socket -server accept 0]
	puts stdout [lindex [fconfigure $server -sockname] 2]
d1519 1
a1519 1
	    global tcltest
d1521 1
a1521 1
	    exec $tcltest "%s" &
d1525 1
a1525 1
    } $path(script1)]
d1531 1
a1531 3
    ## exec [interpreter] script2 &
    set p [open "|[list [interpreter] $path(script2)]" r]
    gets $p listen
d1536 1
a1536 1
    set f [socket 127.0.0.1 $listen]
a1573 1
    close $p
d1584 1
a1584 2
	set f [socket -server accept 0]
	set listen [lindex [fconfigure $f -sockname] 2]
d1612 1
a1612 3
    set port [testthread send $serverthread {set listen}]
    update

d1614 1
a1614 1
    set s [socket 127.0.0.1 $port]
d1641 1
@


1.2
log
@touched all Tcl files to ease next import.
@
text
@@


1.2.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.2.16.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d65 4
a68 2
package require tcltest 2
namespace import -force ::tcltest::*
a70 2
testConstraint testthread [llength [info commands testthread]]
testConstraint exec [llength [info commands exec]]
d72 5
d126 1
a126 4
	    # Be *extra* careful in case this file is sourced from
	    # a directory other than the current one...
	    set remoteFile [file join [pwd] [file dirname [info script]] \
		    remote.tcl]
d128 1
a128 1
				[open "|[list [interpreter] $remoteFile \
d143 1
a143 1
		set noRemoteTestReason "$msg [interpreter]"
a247 2
set path(script) [makeFile {} script]

d250 1
a250 1
    set f [open $path(script) w]
d252 2
a253 2
	set timer [after 10000 "set x timed_out"]
	set f [socket -server accept 0]
a259 1
	puts [lindex [fconfigure $f -sockname] 2]
d266 1
a266 1
    set f [open "|[list [interpreter] $path(script)]" r]
d268 1
a268 2
    gets $f listen
    if {[catch {socket 127.0.0.1 $listen} msg]} {
d286 1
a286 1
    set f [open $path(script) w]
d288 2
a289 2
	set timer [after 10000 "set x timeout"]
        set f [socket -server accept 0]
a296 1
	puts [lindex [fconfigure $f -sockname] 2]
d302 1
a302 1
    set f [open "|[list [interpreter] $path(script)]" r]
a303 1
    gets $f listen
d305 1
a305 1
    if {[catch {socket -myport $port 127.0.0.1 $listen} sock]} {
d307 1
a307 1
	close [socket 127.0.0.1 $listen]
d320 1
a320 1
    set f [open $path(script) w]
d336 1
a336 1
    set f [open "|[list [interpreter] $path(script)]" r]
d351 1
a351 1
    set f [open $path(script) w]
d354 1
a354 1
        set f [socket -server accept -myaddr 127.0.0.1 0]
a361 1
	puts [lindex [fconfigure $f -sockname] 2]
d367 1
a367 1
    set f [open "|[list [interpreter] $path(script)]" r]
d369 1
a369 2
    gets $f listen
    if {[catch {socket 127.0.0.1 $listen} sock]} {
d382 1
a382 1
    set f [open $path(script) w]
d384 2
a385 2
	set timer [after 10000 "set x timeout"]
        set f [socket -server accept 0]
a392 1
	puts [lindex [fconfigure $f -sockname] 2]
d398 1
a398 1
    set f [open "|[list [interpreter] $path(script)]" r]
d400 1
a400 2
    gets $f listen
    if {[catch {socket 127.0.0.1 $listen} sock]} {
d423 1
a423 1
    set f [open $path(script) w]
d425 2
a426 2
	set timer [after 10000 "set x timeout"]
	set f [socket -server accept 0]
a441 1
	puts [lindex [fconfigure $f -sockname] 2]
d445 1
a445 1
	puts $x
d448 1
a448 1
    set f [open "|[list [interpreter] $path(script)]" r]
d450 1
a450 2
    gets $f listen
    set s [socket 127.0.0.1 $listen]
d462 1
a462 1
	set f [socket -server accept 0]
a480 1
	puts [lindex [fconfigure $f -sockname] 2]
d487 1
a487 1
    set f [open "|[list [interpreter] $path(script)]" r]
d489 1
a489 2
    gets $f listen
    set s [socket 127.0.0.1 $listen]
d503 1
a503 1
    set s [socket -server accept 0]
d505 2
a506 2
    set f [open $path(script) w]
    puts -nonewline $f "socket -server accept [lindex [fconfigure $s -sockname] 2]"
d508 1
a508 1
    set f [open "|[list [interpreter] $path(script)]" r]
d511 1
a511 3
    set x [list [catch {close $f} msg]]
    regsub "\n.*$" $msg {} msg ; # cut part of the error message containing the port number
    lappend x $msg
d514 4
a517 1
} {1 {couldn't open socket: address already in use}}
d521 1
a521 1
    set ss [socket -server accept 0]
d534 1
a534 1
    set cs [socket [info hostname] [lindex [fconfigure $ss -sockname] 2]]
d547 1
a547 1
    set s [socket -server accept 0]
d549 1
a549 1
    set s2 [socket 127.0.0.1 [lindex [fconfigure $s -sockname] 2]]
d572 1
a572 1
    set f [open $path(script) w]
d574 1
a574 1
	set f [socket -server accept 0]
a575 1
	puts [lindex [fconfigure $f -sockname] 2]
d580 1
a580 1
    set f [open "|[list [interpreter] $path(script)]" r+]
d582 1
a582 2
    gets $f listen
    set x [list [catch {socket -server accept $listen} msg] \
d590 1
a590 1
    set f [open $path(script) w]
d596 1
a596 1
	set s [socket -server accept 0]
a611 1
	puts [lindex [fconfigure $s -sockname] 2]
d622 1
a622 1
    set f [open "|[list [interpreter] $path(script)]" r+]
d624 1
a624 2
    gets $f listen
    set s1 [socket 127.0.0.1 $listen]
d626 1
a626 1
    set s2 [socket 127.0.0.1 $listen]
d628 1
a628 1
    set s3 [socket 127.0.0.1 $listen]
d648 1
a648 1
    set f [open $path(script) w]
d650 2
a651 2
	set port [gets stdin]
	set s [socket 127.0.0.1 $port]
d662 1
a662 1
    set p1 [open "|[list [interpreter] $path(script)]" r+]
d664 1
a664 1
    set p2 [open "|[list [interpreter] $path(script)]" r+]
d666 1
a666 1
    set p3 [open "|[list [interpreter] $path(script)]" r+]
d685 4
a688 5
    set s [socket -server accept 0]
    set listen [lindex [fconfigure $s -sockname] 2]
    puts $p1 $listen
    puts $p2 $listen
    puts $p3 $listen
d747 1
a747 1
    set f [open $path(script) w]
d749 2
a750 2
	gets stdin port
	socket 127.0.0.1 $port
d753 1
a753 1
    set f [open "|[list [interpreter] $path(script)]" r+]
d759 2
a760 2
    set s [socket -server accept 0]
    puts $f [lindex [fconfigure $s -sockname] 2]
d772 1
a772 1
    set f [open $path(script) w]
d774 1
a774 1
	set ss [socket -server accept 0]
a779 1
	puts [lindex [fconfigure $ss -sockname] 2]
d785 1
a785 1
    set f [open "|[list [interpreter] $path(script)]" r]
d787 1
a787 2
    gets $f listen
    set s [socket 127.0.0.1 $listen]
d793 1
a793 1
    lappend l [string compare [lindex $p 2] $listen]
d798 1
a798 1
    set f [open $path(script) w]
d800 1
a800 1
	set ss [socket -server accept 2821]
a805 1
	puts [lindex [fconfigure $ss -sockname] 2]
d811 1
a811 1
    set f [open "|[list [interpreter] $path(script)]" r]
d813 1
a813 2
    gets $f listen
    set s [socket 127.0.0.1 $listen]
d817 5
a821 4
    list [llength $p] \
	    [regexp {^(127\.0\.0\.1|0\.0\.0\.0)$} [lindex $p 0]] \
	    [expr {[lindex $p 2] == $listen}]
} {3 1 0}
d823 1
a823 1
    set s [socket -server accept 0]
d828 1
a828 1
} 14
d830 1
a830 1
    set s [socket -server accept 0]
d836 1
a836 2
    set listen [lindex [fconfigure $s -sockname] 2]
    set s1 [socket [info hostname] $listen]
d843 2
a844 2
    lappend l [expr {[lindex $x 2] == $listen}] [llength $x]
} {1 3}
d846 1
a846 1
    set s [socket -server accept 0]
d852 1
a852 2
    set listen [lindex [fconfigure $s -sockname] 2]
    set s1 [socket 127.0.0.1 $listen]
d859 2
a860 2
    lappend l [lindex $x 0] [expr {[lindex $x 2] == $listen}] [llength $x]
} {127.0.0.1 1 3}
d877 1
a877 1
    set s [socket -server accept 0]
d884 1
a884 1
    set s1 [socket -async [info hostname] [lindex [fconfigure $s -sockname] 2]]
d914 2
a915 2
    set s [socket -server accept 0]
    set c [socket [info hostname] [lindex [fconfigure $s -sockname] 2]]
d931 1
a931 1
    set l [socket -server accept 0]
d952 1
a952 1
    set s [socket [info hostname] [lindex [fconfigure $l -sockname] 2]]
d1002 2
a1003 2
    set s [socket -server accept 0]
    set c [socket [info hostname] [lindex [fconfigure $s -sockname] 2]]
d1017 1
a1017 1
    set s [socket -server accept 0]
d1019 1
a1019 1
    set c [socket 127.0.0.1 [lindex [fconfigure $s -sockname] 2]]
d1369 1
a1369 4
set path(script1) [makeFile {} script1]
set path(script2) [makeFile {} script2]

test socket-12.1 {testing inheritance of server sockets} {socket stdio exec} {
d1376 1
a1376 1
    set f [open $path(script1) w]
d1387 4
a1390 5
    set f [open $path(script2) w]
    puts $f [list set tcltest [interpreter]]
    puts $f [format {
	set f [socket -server accept 0]
	puts [lindex [fconfigure $f -sockname] 2]
d1394 1
a1394 1
	exec $tcltest "%s" &
d1398 1
a1398 1
    } $path(script1)]
d1403 1
a1403 4
    ### exec [interpreter] script2 &
    set p [open "|[list [interpreter] $path(script2)]" r]
    gets $p listen

d1409 1
a1409 1
    if {[catch {socket 127.0.0.1 $listen} msg]} {
a1417 1
    close $p
d1420 1
a1420 1
test socket-12.2 {testing inheritance of client sockets} {socket stdio exec} {
d1424 1
a1424 1
    # Script1 is just a 20 second delay.  If the server socket
d1427 1
a1427 1
    set f [open $path(script1) w]
d1429 1
a1429 1
	after 20000 exit
d1438 5
a1442 6
    set f [open $path(script2) w]
    puts $f [list set tcltest [interpreter]]
    puts $f [format {
        gets stdin port
	set f [socket 127.0.0.1 $port]
	exec $tcltest "%s" &
d1447 1
a1447 1
    } $path(script1)]
d1452 1
a1452 1
    set server [socket -server accept 0]
d1485 1
a1485 1
    # If the socket doesn't hit end-of-file in 10 seconds, the
d1489 1
a1489 1
    after 10000 [list set failed 1]
a1491 1
    ### exec [interpreter] script2 &
d1493 1
a1493 2
    set p [open "|[list [interpreter] $path(script2)]" w]
    puts $p [lindex [fconfigure $server -sockname] 2] ; flush $p
a1500 1
    close $p
d1503 1
a1503 1
test socket-12.3 {testing inheritance of accepted sockets} {socket stdio exec} {
d1507 1
a1507 1
    set f [open $path(script1) w]
d1514 4
a1517 5
    set f [open $path(script2) w]
    puts $f [list set tcltest [interpreter]]
    puts $f [format {
	set server [socket -server accept 0]
	puts stdout [lindex [fconfigure $server -sockname] 2]
d1519 1
a1519 1
	    global tcltest
d1521 1
a1521 1
	    exec $tcltest "%s" &
d1525 1
a1525 1
    } $path(script1)]
d1531 1
a1531 3
    ## exec [interpreter] script2 &
    set p [open "|[list [interpreter] $path(script2)]" r]
    gets $p listen
d1536 1
a1536 1
    set f [socket 127.0.0.1 $listen]
a1573 1
    close $p
d1584 1
a1584 2
	set f [socket -server accept 0]
	set listen [lindex [fconfigure $f -sockname] 2]
d1612 1
a1612 3
    set port [testthread send $serverthread {set listen}]
    update

d1614 1
a1614 1
    set s [socket 127.0.0.1 $port]
d1641 1
@


1.1
log
@Initial revision
@
text
@d8 1
d13 2
a63 2
#
# RCS: @@(#) $Id: socket.test,v 1.12 1999/01/26 03:53:34 jingham Exp $
d65 6
a70 1
if {[string compare test [info procs test]] == 1} then {source defs}
d72 3
a74 3
if {$testConfig(socket) == 0} {
    return
}
d102 1
a102 1
    set remoteServerIP localhost
a123 3
	} elseif {$testConfig(win32s)} {
	    set noRemoteTestReason "\ncan't run multiple instances of tcltest under win32s."
	    set doTestsWithRemoteServer 0
d125 2
a126 1
	    set remoteServerIP localhost
d128 1
a128 1
				[open "|[list $tcltest remote.tcl \
d143 1
a143 1
		set noRemoteTestReason "$msg $tcltest"
d152 2
d155 3
a157 3
    puts "Skipping tests with remote server. See tests/socket.test for"
    puts "information on how to run remote server."
    if {[info exists VERBOSE] && ($VERBOSE != 0)} {
d201 1
a201 1
test socket-1.1 {arg parsing for socket command} {
d204 1
a204 1
test socket-1.2 {arg parsing for socket command} {
d209 1
a209 1
test socket-1.3 {arg parsing for socket command} {
d212 1
a212 1
test socket-1.4 {arg parsing for socket command} {
d217 1
a217 1
test socket-1.5 {arg parsing for socket command} {
d220 1
a220 1
test socket-1.6 {arg parsing for socket command} {
d223 1
a223 1
test socket-1.7 {arg parsing for socket command} {
d228 1
a228 1
test socket-1.8 {arg parsing for socket command} {
d230 2
a231 2
} {1 {bad option "-froboz", must be -async, -myaddr, -myport, or -server}}
test socket-1.9 {arg parsing for socket command} {
d234 1
a234 1
test socket-1.10 {arg parsing for socket command} {
d239 1
a239 1
test socket-1.11 {arg parsing for socket command} {
d244 1
a244 1
test socket-1.12 {arg parsing for socket command} {
d248 1
a248 1
test socket-2.1 {tcp connection} {stdio} {
d266 1
a266 1
    set f [open "|[list $tcltest script]" r]
d268 1
a268 1
    if {[catch {socket localhost 2828} msg]} {
d284 1
a284 1
test socket-2.2 {tcp connection with client port specified} {stdio} {
d289 1
a289 1
        set f [socket -server accept 2828]
d302 1
a302 1
    set f [open "|[list $tcltest script]" r]
d305 1
a305 1
    if {[catch {socket -myport $port localhost 2828} sock]} {
d307 1
a307 1
	close [socket localhost 2828]
d318 1
a318 1
test socket-2.3 {tcp connection with client interface specified} {stdio} {
d323 1
a323 1
        set f [socket  -server accept 2828]
d336 1
a336 1
    set f [open "|[list $tcltest script]" r]
d338 1
a338 1
    if {[catch {socket -myaddr localhost localhost 2828} sock]} {
d349 1
a349 1
test socket-2.4 {tcp connection with server interface specified} {stdio} {
d354 1
a354 1
        set f [socket -server accept -myaddr [info hostname] 2828]
d367 1
a367 1
    set f [open "|[list $tcltest script]" r]
d369 1
a369 1
    if {[catch {socket [info hostname] 2828} sock]} {
d380 1
a380 1
test socket-2.5 {tcp connection with redundant server port} {stdio} {
d385 1
a385 1
        set f [socket -server accept 2828]
d398 1
a398 1
    set f [open "|[list $tcltest script]" r]
d400 1
a400 1
    if {[catch {socket localhost 2828} sock]} {
d411 1
a411 1
test socket-2.6 {tcp connection} {} {
d413 1
a413 1
    if {![catch {set sock [socket localhost 2828]}]} {
d421 1
a421 1
test socket-2.7 {echo server, one line} {stdio} {
d426 1
a426 1
	set f [socket -server accept 2828]
d448 1
a448 1
    set f [open "|[list $tcltest script]" r]
d450 1
a450 1
    set s [socket localhost 2828]
d453 1
d460 3
a462 5
test socket-2.8 {echo server, loop 50 times, single connection} {stdio} {
    removeFile script
    set f [open script w]
    puts $f {
	set f [socket -server accept 2828]
d486 2
a487 3
    }
    close $f
    set f [open "|[list $tcltest script]" r]
d489 1
a489 1
    set s [socket localhost 2828]
d491 5
a495 3
    for {set x 0} {$x < 50} {incr x} {
        puts $s "hello abcdefghijklmnop"
        gets $s
d498 1
a498 1
    set x [gets $f]
d502 1
a502 1
test socket-2.9 {socket conflict} {stdio} {
d506 1
a506 1
    puts $f {set f [socket -server accept 2828]}
d508 1
a508 1
    set f [open "|[list $tcltest script]" r]
d518 1
a518 1
test socket-2.10 {close on accept, accepted socket lives} {
d541 1
a541 1
test socket-2.11 {detecting new data} {
d549 1
a549 1
    set s2 [socket localhost 2400]
d555 2
a556 2
    set result [gets $sock]
    lappend result [gets $sock]
d561 1
a561 1
    lappend result [gets $sock]
d567 1
a567 1
} {one {} two}
d570 1
a570 1
test socket-3.1 {socket conflict} {stdio} {
d580 1
a580 1
    set f [open "|[list $tcltest script]" r+]
d588 1
a588 1
test socket-3.2 {server with several clients} {stdio} {
d622 1
a622 1
    set f [open "|[list $tcltest script]" r+]
d624 1
a624 1
    set s1 [socket localhost 2828]
d626 1
a626 1
    set s2 [socket localhost 2828]
d628 1
a628 1
    set s3 [socket localhost 2828]
d646 1
a646 1
test socket-4.1 {server with several clients} {stdio} {
d651 1
a651 1
	set s [socket localhost 2828]
d662 1
a662 1
    set p1 [open "|[list $tcltest script]" r+]
d664 1
a664 1
    set p2 [open "|[list $tcltest script]" r+]
d666 1
a666 1
    set p3 [open "|[list $tcltest script]" r+]
d708 1
a708 1
test socket-4.2 {byte order problems, socket numbers, htons} {
d718 2
a719 4
test socket-5.1 {byte order problems, socket numbers, htons} {unixOnly} {
    #
    # THIS TEST WILL FAIL if you are running as superuser.
    #
d727 1
a727 1
test socket-5.2 {byte order problems, socket numbers, htons} {
d735 2
a736 4
test socket-5.3 {byte order problems, socket numbers, htons} {unixOnly} {
    #
    # THIS TEST WILL FAIL if you are running as superuser.
    #
d745 1
a745 1
test socket-6.1 {accept callback error} {stdio} {
d750 1
a750 1
	socket localhost 2848
d753 1
a753 1
    set f [open "|[list $tcltest script]" r+]
d770 1
a770 1
test socket-7.1 {testing socket specific options} {stdio} {
d785 1
a785 1
    set f [open "|[list $tcltest script]" r]
d787 1
a787 1
    set s [socket localhost 2820]
d796 1
a796 1
test socket-7.2 {testing socket specific options} {stdio} {
d811 1
a811 1
    set f [open "|[list $tcltest script]" r]
d813 1
a813 1
    set s [socket localhost 2821]
d822 1
a822 1
test socket-7.3 {testing socket specific options} {
d828 2
a829 2
} 10
test socket-7.4 {testing socket specific options} {
d845 1
a845 1
test socket-7.5 {testing socket specific options} {unixOrPc} {
d852 1
a852 1
    set s1 [socket localhost 2829]
d862 1
a862 1
test socket-8.1 {testing -async flag on sockets} {
d892 1
a892 1
test socket-9.1 {testing spurious events} {
d924 1
a924 1
test socket-9.2 {testing async write, fileevents, flush on close} {} {
d972 1
a972 1
test socket-9.3 {testing EOF stickyness} {
d1012 3
a1014 1
test socket-10.1 {testing socket accept callback error handling} {
d1019 1
a1019 1
    set c [socket localhost 2898]
d1026 1
a1026 12
removeFile script

#
# The rest of the tests are run only if we are doing testing against
# a remote server.
#

if {$doTestsWithRemoteServer == 0} {
    return
}

test socket-11.1 {tcp connection} {
d1040 1
a1040 1
test socket-11.2 {client specifies its port} {
d1064 1
a1064 1
test socket-11.3 {trying to connect, no server} {
d1074 1
a1074 1
test socket-11.4 {remote echo, one line} {
d1098 1
a1098 1
test socket-11.5 {remote echo, 50 lines} {
d1132 1
a1132 1
test socket-11.6 {socket conflict} {
d1143 1
a1143 1
test socket-11.7 {server with several clients} {
d1179 1
a1179 1
test socket-11.8 {client with several servers} {
d1205 1
a1205 1
test socket-11.9 {accept callback error} {
d1227 1
a1227 1
test socket-11.10 {testing socket specific options} {
d1241 1
a1241 1
test socket-11.11 {testing spurious events} {
d1280 2
a1281 1
test socket-11.12 {testing EOF stickyness} {
d1308 1
a1308 1
    fileevent $c readable "count_up $c"
d1314 3
a1316 1
test socket-11.13 {testing async write, async flush, async close} {
d1369 263
d1638 3
a1641 2
set x ""
unset x
@


1.1.1.1
log
@import dejagnu-1999-11-08 snapshot
@
text
@@


1.1.1.2
log
@Tcl 8.3 upgrade
@
text
@a7 1
# Copyright (c) 1998-2000 Ajuba Solutions.
a11 2
# RCS: @@(#) $Id: socket.test,v 1.6.8.2 2000/09/15 16:57:33 spolk Exp $

d61 4
d66 2
a67 3
if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import -force ::tcltest::*
a69 6
# Some tests require the testthread and exec commands

set ::tcltest::testConstraints(testthread) \
	[expr {[info commands testthread] != {}}]
set ::tcltest::testConstraints(exec) [expr {[info commands exec] != {}}]

d96 1
a96 1
    set remoteServerIP 127.0.0.1
d118 3
d122 1
a122 2
	    set remoteServerIP 127.0.0.1
	    set remoteFile [file join [pwd] remote.tcl]
d124 1
a124 1
				[open "|[list $::tcltest::tcltest $remoteFile \
d139 1
a139 1
		set noRemoteTestReason "$msg $::tcltest::tcltest"
a147 2
# Some tests are run only if we are doing testing against a remote server.
set ::tcltest::testConstraints(doTestsWithRemoteServer) $doTestsWithRemoteServer
d149 3
a151 3
    if {[string first s $::tcltest::verbose] != -1} {
    	puts "Skipping tests with remote server. See tests/socket.test for"
	puts "information on how to run remote server."
d195 1
a195 1
test socket-1.1 {arg parsing for socket command} {socket} {
d198 1
a198 1
test socket-1.2 {arg parsing for socket command} {socket} {
d203 1
a203 1
test socket-1.3 {arg parsing for socket command} {socket} {
d206 1
a206 1
test socket-1.4 {arg parsing for socket command} {socket} {
d211 1
a211 1
test socket-1.5 {arg parsing for socket command} {socket} {
d214 1
a214 1
test socket-1.6 {arg parsing for socket command} {socket} {
d217 1
a217 1
test socket-1.7 {arg parsing for socket command} {socket} {
d222 1
a222 1
test socket-1.8 {arg parsing for socket command} {socket} {
d224 2
a225 2
} {1 {bad option "-froboz": must be -async, -myaddr, -myport, or -server}}
test socket-1.9 {arg parsing for socket command} {socket} {
d228 1
a228 1
test socket-1.10 {arg parsing for socket command} {socket} {
d233 1
a233 1
test socket-1.11 {arg parsing for socket command} {socket} {
d238 1
a238 1
test socket-1.12 {arg parsing for socket command} {socket} {
d242 1
a242 1
test socket-2.1 {tcp connection} {socket stdio} {
d260 1
a260 1
    set f [open "|[list $::tcltest::tcltest script]" r]
d262 1
a262 1
    if {[catch {socket 127.0.0.1 2828} msg]} {
d278 1
a278 1
test socket-2.2 {tcp connection with client port specified} {socket stdio} {
d283 1
a283 1
        set f [socket -server accept 2829]
d296 1
a296 1
    set f [open "|[list $::tcltest::tcltest script]" r]
d299 1
a299 1
    if {[catch {socket -myport $port 127.0.0.1 2829} sock]} {
d301 1
a301 1
	close [socket 127.0.0.1 2829]
d312 1
a312 1
test socket-2.3 {tcp connection with client interface specified} {socket stdio} {
d317 1
a317 1
        set f [socket  -server accept 2830]
d330 1
a330 1
    set f [open "|[list $::tcltest::tcltest script]" r]
d332 1
a332 1
    if {[catch {socket -myaddr 127.0.0.1 127.0.0.1 2830} sock]} {
d343 1
a343 1
test socket-2.4 {tcp connection with server interface specified} {socket stdio} {
d348 1
a348 1
        set f [socket -server accept -myaddr [info hostname] 2831]
d361 1
a361 1
    set f [open "|[list $::tcltest::tcltest script]" r]
d363 1
a363 1
    if {[catch {socket [info hostname] 2831} sock]} {
d374 1
a374 1
test socket-2.5 {tcp connection with redundant server port} {socket stdio} {
d379 1
a379 1
        set f [socket -server accept 2832]
d392 1
a392 1
    set f [open "|[list $::tcltest::tcltest script]" r]
d394 1
a394 1
    if {[catch {socket 127.0.0.1 2832} sock]} {
d405 1
a405 1
test socket-2.6 {tcp connection} {socket} {
d407 1
a407 1
    if {![catch {set sock [socket 127.0.0.1 2833]}]} {
d415 1
a415 1
test socket-2.7 {echo server, one line} {socket stdio} {
d420 1
a420 1
	set f [socket -server accept 2834]
d442 1
a442 1
    set f [open "|[list $::tcltest::tcltest script]" r]
d444 1
a444 1
    set s [socket 127.0.0.1 2834]
a446 1
    after 1000
d453 5
a457 3
test socket-2.8 {echo server, loop 50 times, single connection} {socket stdio} {
    makeFile {
	set f [socket -server accept 2835]
d481 3
a483 2
    } script
    set f [open "|[list $::tcltest::tcltest script]" r]
d485 1
a485 1
    set s [socket 127.0.0.1 2835]
d487 3
a489 5
    catch {
	for {set x 0} {$x < 50} {incr x} {
	    puts $s "hello abcdefghijklmnop"
	    gets $s
	}
d492 1
a492 1
    catch {set x [gets $f]}
d496 1
a496 1
test socket-2.9 {socket conflict} {socket stdio} {
d500 1
a500 1
    puts -nonewline $f {socket -server accept 2828}
d502 1
a502 1
    set f [open "|[list $::tcltest::tcltest script]" r]
d512 1
a512 1
test socket-2.10 {close on accept, accepted socket lives} {socket} {
d535 1
a535 1
test socket-2.11 {detecting new data} {socket} {
d543 1
a543 1
    set s2 [socket 127.0.0.1 2400]
d549 2
a550 2
    set result a:[gets $sock]
    lappend result b:[gets $sock]
d555 1
a555 1
    lappend result c:[gets $sock]
d561 1
a561 1
} {a:one b: c:two}
d564 1
a564 1
test socket-3.1 {socket conflict} {socket stdio} {
d574 1
a574 1
    set f [open "|[list $::tcltest::tcltest script]" r+]
d582 1
a582 1
test socket-3.2 {server with several clients} {socket stdio} {
d616 1
a616 1
    set f [open "|[list $::tcltest::tcltest script]" r+]
d618 1
a618 1
    set s1 [socket 127.0.0.1 2828]
d620 1
a620 1
    set s2 [socket 127.0.0.1 2828]
d622 1
a622 1
    set s3 [socket 127.0.0.1 2828]
d640 1
a640 1
test socket-4.1 {server with several clients} {socket stdio} {
d645 1
a645 1
	set s [socket 127.0.0.1 2828]
d656 1
a656 1
    set p1 [open "|[list $::tcltest::tcltest script]" r+]
d658 1
a658 1
    set p2 [open "|[list $::tcltest::tcltest script]" r+]
d660 1
a660 1
    set p3 [open "|[list $::tcltest::tcltest script]" r+]
d702 1
a702 1
test socket-4.2 {byte order problems, socket numbers, htons} {socket} {
d712 4
a715 2
test socket-5.1 {byte order problems, socket numbers, htons} \
	{socket unixOnly notRoot} {
d723 1
a723 1
test socket-5.2 {byte order problems, socket numbers, htons} {socket} {
d731 4
a734 2
test socket-5.3 {byte order problems, socket numbers, htons} \
	{socket unixOnly notRoot} {
d743 1
a743 1
test socket-6.1 {accept callback error} {socket stdio} {
d748 1
a748 1
	socket 127.0.0.1 2848
d751 1
a751 1
    set f [open "|[list $::tcltest::tcltest script]" r+]
d768 1
a768 1
test socket-7.1 {testing socket specific options} {socket stdio} {
d783 1
a783 1
    set f [open "|[list $::tcltest::tcltest script]" r]
d785 1
a785 1
    set s [socket 127.0.0.1 2820]
d794 1
a794 1
test socket-7.2 {testing socket specific options} {socket stdio} {
d809 1
a809 1
    set f [open "|[list $::tcltest::tcltest script]" r]
d811 1
a811 1
    set s [socket 127.0.0.1 2821]
d820 1
a820 1
test socket-7.3 {testing socket specific options} {socket} {
d826 2
a827 2
} 12
test socket-7.4 {testing socket specific options} {socket} {
d843 1
a843 1
test socket-7.5 {testing socket specific options} {socket unixOrPc} {
d850 1
a850 1
    set s1 [socket 127.0.0.1 2829]
d860 1
a860 1
test socket-8.1 {testing -async flag on sockets} {socket} {
d890 1
a890 1
test socket-9.1 {testing spurious events} {socket} {
d922 1
a922 1
test socket-9.2 {testing async write, fileevents, flush on close} {socket} {
d970 1
a970 1
test socket-9.3 {testing EOF stickyness} {socket} {
d1010 1
a1010 3
removeFile script

test socket-10.1 {testing socket accept callback error handling} {socket} {
d1015 1
a1015 1
    set c [socket 127.0.0.1 2898]
d1022 12
a1033 1
test socket-11.1 {tcp connection} {socket doTestsWithRemoteServer} {
d1047 1
a1047 1
test socket-11.2 {client specifies its port} {socket doTestsWithRemoteServer} {
d1071 1
a1071 1
test socket-11.3 {trying to connect, no server} {socket doTestsWithRemoteServer} {
d1081 1
a1081 1
test socket-11.4 {remote echo, one line} {socket doTestsWithRemoteServer} {
d1105 1
a1105 1
test socket-11.5 {remote echo, 50 lines} {socket doTestsWithRemoteServer} {
d1139 1
a1139 1
test socket-11.6 {socket conflict} {socket doTestsWithRemoteServer} {
d1150 1
a1150 1
test socket-11.7 {server with several clients} {socket doTestsWithRemoteServer} {
d1186 1
a1186 1
test socket-11.8 {client with several servers} {socket doTestsWithRemoteServer} {
d1212 1
a1212 1
test socket-11.9 {accept callback error} {socket doTestsWithRemoteServer} {
d1234 1
a1234 1
test socket-11.10 {testing socket specific options} {socket doTestsWithRemoteServer} {
d1248 1
a1248 1
test socket-11.11 {testing spurious events} {socket doTestsWithRemoteServer} {
d1287 1
a1287 2

test socket-11.12 {testing EOF stickyness} {socket doTestsWithRemoteServer} {
d1314 1
a1314 1
    fileevent $c readable [list count_up $c]
d1320 1
a1320 3

test socket-11.13 {testing async write, async flush, async close} \
	{socket doTestsWithRemoteServer} {
a1372 263
test socket-12.1 {testing inheritance of server sockets} {socket exec} {
    removeFile script1
    removeFile script2

    # Script1 is just a 10 second delay.  If the server socket
    # is inherited, it will be held open for 10 seconds

    set f [open script1 w]
    puts $f {
	after 10000 exit
	vwait forever
    }
    close $f

    # Script2 creates the server socket, launches script1,
    # waits a second, and exits.  The server socket will now
    # be closed unless script1 inherited it.

    set f [open script2 w]
    puts $f [list set tclsh $::tcltest::tcltest]
    puts $f {
	set f [socket -server accept 2828]
	proc accept { file addr port } {
	    close $file
	}
	exec $tclsh script1 &
	close $f
	after 1000 exit
	vwait forever
    }
    close $f
	
    # Launch script2 and wait 5 seconds

    exec $::tcltest::tcltest script2 &
    after 5000 { set ok_to_proceed 1 }
    vwait ok_to_proceed

    # If we can still connect to the server, the socket got inherited.

    if {[catch {socket 127.0.0.1 2828} msg]} {
	set x {server socket was not inherited}
    } else {
	close $msg
	set x {server socket was inherited}
    }

    removeFile script1
    removeFile script2
    set x
} {server socket was not inherited}
test socket-12.2 {testing inheritance of client sockets} {socket exec} {
    removeFile script1
    removeFile script2

    # Script1 is just a 10 second delay.  If the server socket
    # is inherited, it will be held open for 10 seconds

    set f [open script1 w]
    puts $f {
	after 10000 exit
	vwait forever
    }
    close $f

    # Script2 opens the client socket and writes to it.  It then
    # launches script1 and exits.  If the child process inherited the
    # client socket, the socket will still be open.

    set f [open script2 w]
    puts $f [list set tclsh $::tcltest::tcltest]
    puts $f {
	set f [socket 127.0.0.1 2829]
	exec $tclsh script1 &
	puts $f testing
	flush $f
	after 1000 exit
	vwait forever
    }
    close $f

    # Create the server socket

    set server [socket -server accept 2829]
    proc accept { file host port } {
	# When the client connects, establish the read handler
	global server
	close $server
	fileevent $file readable [list getdata $file]
	fconfigure $file -buffering line -blocking 0
	return
    }
    proc getdata { file } {
	# Read handler on the accepted socket.
	global x
	global failed
	set status [catch {read $file} data]
	if {$status != 0} {
	    set x {read failed, error was $data}
	    catch { close $file }
	} elseif {[string compare {} $data]} {
	} elseif {[fblocked $file]} {
	} elseif {[eof $file]} {
	    if {$failed} {
		set x {client socket was inherited}
	    } else {
		set x {client socket was not inherited}
	    }
	    catch { close $file }
	} else {
	    set x {impossible case}
	    catch { close $file }
	}
	return
    }

    # If the socket doesn't hit end-of-file in 5 seconds, the
    # script1 process must have inherited the client.

    set failed 0
    after 5000 [list set failed 1]

    # Launch the script2 process

    exec $::tcltest::tcltest script2 &

    vwait x
    if {!$failed} {
	vwait failed
    }
    removeFile script1
    removeFile script2
    set x
} {client socket was not inherited}
test socket-12.3 {testing inheritance of accepted sockets} {socket exec} {
    removeFile script1
    removeFile script2

    set f [open script1 w]
    puts $f {
	after 10000 exit
	vwait forever
    }
    close $f

    set f [open script2 w]
    puts $f [list set tclsh $::tcltest::tcltest]
    puts $f {
	set server [socket -server accept 2931]
	proc accept { file host port } {
	    global tclsh
	    puts $file {test data on socket}
	    exec $tclsh script1 &
	    after 1000 exit
	}
	vwait forever
    }
    close $f

    # Launch the script2 process and connect to it.  See how long
    # the socket stays open

    exec $::tcltest::tcltest script2 &

    after 1000 set ok_to_proceed 1
    vwait ok_to_proceed

    set f [socket 127.0.0.1 2931]
    fconfigure $f -buffering full -blocking 0
    fileevent $f readable [list getdata $f]

    # If the socket is still open after 5 seconds, the script1 process
    # must have inherited the accepted socket.

    set failed 0
    after 5000 set failed 1

    proc getdata { file } {
	# Read handler on the client socket.
	global x
	global failed
	set status [catch {read $file} data]
	if {$status != 0} {
	    set x {read failed, error was $data}
	    catch { close $file }
	} elseif {[string compare {} $data]} {
	} elseif {[fblocked $file]} {
	} elseif {[eof $file]} {
	    if {$failed} {
		set x {accepted socket was inherited}
	    } else {
		set x {accepted socket was not inherited}
	    }
	    catch { close $file }
	} else {
	    set x {impossible case}
	    catch { close $file }
	}
	return
    }
    
    vwait x

    removeFile script1
    removeFile script2
    set x
} {accepted socket was not inherited}

test socket-13.1 {Testing use of shared socket between two threads} \
	{socket testthread} {

    removeFile script
    threadReap

    makeFile {
	set f [socket -server accept 2828]
	proc accept {s a p} {
            fileevent $s readable [list echo $s]
            fconfigure $s -buffering line
        }
	proc echo {s} {
	     global i
             set l [gets $s]
             if {[eof $s]} {
                 global x
                 close $s
                 set x done
             } else { 
	         incr i
                 puts $s $l
             }
	}
	set i 0
	vwait x
	close $f

	# thread cleans itself up.
	testthread exit
    } script
    
    # create a thread
    set serverthread [testthread create { source script } ]
    update
    
    after 1000
    set s [socket 127.0.0.1 2828]
    fconfigure $s -buffering line

    catch {
	puts $s "hello"
	gets $s result
    }
    close $s
    update

    after 2000
    lappend result [threadReap]
    
    set result

} {hello 1}

# cleanup
a1378 3
::tcltest::cleanupTests
flush stdout
return
d1380 2
@


1.1.1.3
log
@import tcl 8.4.0
@
text
@d13 1
a13 1
# RCS: @@(#) $Id: socket.test,v 1.26 2002/07/10 11:56:45 dgp Exp $
d65 4
a68 2
package require tcltest 2
namespace import -force ::tcltest::*
a70 2
testConstraint testthread [llength [info commands testthread]]
testConstraint exec [llength [info commands exec]]
d72 5
d126 1
a126 4
	    # Be *extra* careful in case this file is sourced from
	    # a directory other than the current one...
	    set remoteFile [file join [pwd] [file dirname [info script]] \
		    remote.tcl]
d128 1
a128 1
				[open "|[list [interpreter] $remoteFile \
d143 1
a143 1
		set noRemoteTestReason "$msg [interpreter]"
a247 2
set path(script) [makeFile {} script]

d250 1
a250 1
    set f [open $path(script) w]
d252 2
a253 2
	set timer [after 10000 "set x timed_out"]
	set f [socket -server accept 0]
a259 1
	puts [lindex [fconfigure $f -sockname] 2]
d266 1
a266 1
    set f [open "|[list [interpreter] $path(script)]" r]
d268 1
a268 2
    gets $f listen
    if {[catch {socket 127.0.0.1 $listen} msg]} {
d286 1
a286 1
    set f [open $path(script) w]
d288 2
a289 2
	set timer [after 10000 "set x timeout"]
        set f [socket -server accept 0]
a296 1
	puts [lindex [fconfigure $f -sockname] 2]
d302 1
a302 1
    set f [open "|[list [interpreter] $path(script)]" r]
a303 1
    gets $f listen
d305 1
a305 1
    if {[catch {socket -myport $port 127.0.0.1 $listen} sock]} {
d307 1
a307 1
	close [socket 127.0.0.1 $listen]
d320 1
a320 1
    set f [open $path(script) w]
d336 1
a336 1
    set f [open "|[list [interpreter] $path(script)]" r]
d351 1
a351 1
    set f [open $path(script) w]
d354 1
a354 1
        set f [socket -server accept -myaddr 127.0.0.1 0]
a361 1
	puts [lindex [fconfigure $f -sockname] 2]
d367 1
a367 1
    set f [open "|[list [interpreter] $path(script)]" r]
d369 1
a369 2
    gets $f listen
    if {[catch {socket 127.0.0.1 $listen} sock]} {
d382 1
a382 1
    set f [open $path(script) w]
d384 2
a385 2
	set timer [after 10000 "set x timeout"]
        set f [socket -server accept 0]
a392 1
	puts [lindex [fconfigure $f -sockname] 2]
d398 1
a398 1
    set f [open "|[list [interpreter] $path(script)]" r]
d400 1
a400 2
    gets $f listen
    if {[catch {socket 127.0.0.1 $listen} sock]} {
d423 1
a423 1
    set f [open $path(script) w]
d425 2
a426 2
	set timer [after 10000 "set x timeout"]
	set f [socket -server accept 0]
a441 1
	puts [lindex [fconfigure $f -sockname] 2]
d445 1
a445 1
	puts $x
d448 1
a448 1
    set f [open "|[list [interpreter] $path(script)]" r]
d450 1
a450 2
    gets $f listen
    set s [socket 127.0.0.1 $listen]
d462 1
a462 1
	set f [socket -server accept 0]
a480 1
	puts [lindex [fconfigure $f -sockname] 2]
d487 1
a487 1
    set f [open "|[list [interpreter] $path(script)]" r]
d489 1
a489 2
    gets $f listen
    set s [socket 127.0.0.1 $listen]
d503 1
a503 1
    set s [socket -server accept 0]
d505 2
a506 2
    set f [open $path(script) w]
    puts -nonewline $f "socket -server accept [lindex [fconfigure $s -sockname] 2]"
d508 1
a508 1
    set f [open "|[list [interpreter] $path(script)]" r]
d511 1
a511 3
    set x [list [catch {close $f} msg]]
    regsub "\n.*$" $msg {} msg ; # cut part of the error message containing the port number
    lappend x $msg
d514 4
a517 1
} {1 {couldn't open socket: address already in use}}
d521 1
a521 1
    set ss [socket -server accept 0]
d534 1
a534 1
    set cs [socket [info hostname] [lindex [fconfigure $ss -sockname] 2]]
d547 1
a547 1
    set s [socket -server accept 0]
d549 1
a549 1
    set s2 [socket 127.0.0.1 [lindex [fconfigure $s -sockname] 2]]
d572 1
a572 1
    set f [open $path(script) w]
d574 1
a574 1
	set f [socket -server accept 0]
a575 1
	puts [lindex [fconfigure $f -sockname] 2]
d580 1
a580 1
    set f [open "|[list [interpreter] $path(script)]" r+]
d582 1
a582 2
    gets $f listen
    set x [list [catch {socket -server accept $listen} msg] \
d590 1
a590 1
    set f [open $path(script) w]
d596 1
a596 1
	set s [socket -server accept 0]
a611 1
	puts [lindex [fconfigure $s -sockname] 2]
d622 1
a622 1
    set f [open "|[list [interpreter] $path(script)]" r+]
d624 1
a624 2
    gets $f listen
    set s1 [socket 127.0.0.1 $listen]
d626 1
a626 1
    set s2 [socket 127.0.0.1 $listen]
d628 1
a628 1
    set s3 [socket 127.0.0.1 $listen]
d648 1
a648 1
    set f [open $path(script) w]
d650 2
a651 2
	set port [gets stdin]
	set s [socket 127.0.0.1 $port]
d662 1
a662 1
    set p1 [open "|[list [interpreter] $path(script)]" r+]
d664 1
a664 1
    set p2 [open "|[list [interpreter] $path(script)]" r+]
d666 1
a666 1
    set p3 [open "|[list [interpreter] $path(script)]" r+]
d685 4
a688 5
    set s [socket -server accept 0]
    set listen [lindex [fconfigure $s -sockname] 2]
    puts $p1 $listen
    puts $p2 $listen
    puts $p3 $listen
d747 1
a747 1
    set f [open $path(script) w]
d749 2
a750 2
	gets stdin port
	socket 127.0.0.1 $port
d753 1
a753 1
    set f [open "|[list [interpreter] $path(script)]" r+]
d759 2
a760 2
    set s [socket -server accept 0]
    puts $f [lindex [fconfigure $s -sockname] 2]
d772 1
a772 1
    set f [open $path(script) w]
d774 1
a774 1
	set ss [socket -server accept 0]
a779 1
	puts [lindex [fconfigure $ss -sockname] 2]
d785 1
a785 1
    set f [open "|[list [interpreter] $path(script)]" r]
d787 1
a787 2
    gets $f listen
    set s [socket 127.0.0.1 $listen]
d793 1
a793 1
    lappend l [string compare [lindex $p 2] $listen]
d798 1
a798 1
    set f [open $path(script) w]
d800 1
a800 1
	set ss [socket -server accept 2821]
a805 1
	puts [lindex [fconfigure $ss -sockname] 2]
d811 1
a811 1
    set f [open "|[list [interpreter] $path(script)]" r]
d813 1
a813 2
    gets $f listen
    set s [socket 127.0.0.1 $listen]
d817 5
a821 4
    list [llength $p] \
	    [regexp {^(127\.0\.0\.1|0\.0\.0\.0)$} [lindex $p 0]] \
	    [expr {[lindex $p 2] == $listen}]
} {3 1 0}
d823 1
a823 1
    set s [socket -server accept 0]
d828 1
a828 1
} 14
d830 1
a830 1
    set s [socket -server accept 0]
d836 1
a836 2
    set listen [lindex [fconfigure $s -sockname] 2]
    set s1 [socket [info hostname] $listen]
d843 2
a844 2
    lappend l [expr {[lindex $x 2] == $listen}] [llength $x]
} {1 3}
d846 1
a846 1
    set s [socket -server accept 0]
d852 1
a852 2
    set listen [lindex [fconfigure $s -sockname] 2]
    set s1 [socket 127.0.0.1 $listen]
d859 2
a860 2
    lappend l [lindex $x 0] [expr {[lindex $x 2] == $listen}] [llength $x]
} {127.0.0.1 1 3}
d877 1
a877 1
    set s [socket -server accept 0]
d884 1
a884 1
    set s1 [socket -async [info hostname] [lindex [fconfigure $s -sockname] 2]]
d914 2
a915 2
    set s [socket -server accept 0]
    set c [socket [info hostname] [lindex [fconfigure $s -sockname] 2]]
d931 1
a931 1
    set l [socket -server accept 0]
d952 1
a952 1
    set s [socket [info hostname] [lindex [fconfigure $l -sockname] 2]]
d1002 2
a1003 2
    set s [socket -server accept 0]
    set c [socket [info hostname] [lindex [fconfigure $s -sockname] 2]]
d1017 1
a1017 1
    set s [socket -server accept 0]
d1019 1
a1019 1
    set c [socket 127.0.0.1 [lindex [fconfigure $s -sockname] 2]]
d1369 1
a1369 4
set path(script1) [makeFile {} script1]
set path(script2) [makeFile {} script2]

test socket-12.1 {testing inheritance of server sockets} {socket stdio exec} {
d1376 1
a1376 1
    set f [open $path(script1) w]
d1387 4
a1390 5
    set f [open $path(script2) w]
    puts $f [list set tcltest [interpreter]]
    puts $f [format {
	set f [socket -server accept 0]
	puts [lindex [fconfigure $f -sockname] 2]
d1394 1
a1394 1
	exec $tcltest "%s" &
d1398 1
a1398 1
    } $path(script1)]
d1403 1
a1403 4
    ### exec [interpreter] script2 &
    set p [open "|[list [interpreter] $path(script2)]" r]
    gets $p listen

d1409 1
a1409 1
    if {[catch {socket 127.0.0.1 $listen} msg]} {
a1417 1
    close $p
d1420 1
a1420 1
test socket-12.2 {testing inheritance of client sockets} {socket stdio exec} {
d1424 1
a1424 1
    # Script1 is just a 20 second delay.  If the server socket
d1427 1
a1427 1
    set f [open $path(script1) w]
d1429 1
a1429 1
	after 20000 exit
d1438 5
a1442 6
    set f [open $path(script2) w]
    puts $f [list set tcltest [interpreter]]
    puts $f [format {
        gets stdin port
	set f [socket 127.0.0.1 $port]
	exec $tcltest "%s" &
d1447 1
a1447 1
    } $path(script1)]
d1452 1
a1452 1
    set server [socket -server accept 0]
d1485 1
a1485 1
    # If the socket doesn't hit end-of-file in 10 seconds, the
d1489 1
a1489 1
    after 10000 [list set failed 1]
a1491 1
    ### exec [interpreter] script2 &
d1493 1
a1493 2
    set p [open "|[list [interpreter] $path(script2)]" w]
    puts $p [lindex [fconfigure $server -sockname] 2] ; flush $p
a1500 1
    close $p
d1503 1
a1503 1
test socket-12.3 {testing inheritance of accepted sockets} {socket stdio exec} {
d1507 1
a1507 1
    set f [open $path(script1) w]
d1514 4
a1517 5
    set f [open $path(script2) w]
    puts $f [list set tcltest [interpreter]]
    puts $f [format {
	set server [socket -server accept 0]
	puts stdout [lindex [fconfigure $server -sockname] 2]
d1519 1
a1519 1
	    global tcltest
d1521 1
a1521 1
	    exec $tcltest "%s" &
d1525 1
a1525 1
    } $path(script1)]
d1531 1
a1531 3
    ## exec [interpreter] script2 &
    set p [open "|[list [interpreter] $path(script2)]" r]
    gets $p listen
d1536 1
a1536 1
    set f [socket 127.0.0.1 $listen]
a1573 1
    close $p
d1584 1
a1584 2
	set f [socket -server accept 0]
	set listen [lindex [fconfigure $f -sockname] 2]
d1612 1
a1612 3
    set port [testthread send $serverthread {set listen}]
    update

d1614 1
a1614 1
    set s [socket 127.0.0.1 $port]
d1641 1
@


