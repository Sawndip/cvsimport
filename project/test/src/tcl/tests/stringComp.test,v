head	1.3;
access;
symbols
	sid-snapshot-20180601:1.3
	sid-snapshot-20180501:1.3
	sid-snapshot-20180401:1.3
	sid-snapshot-20180301:1.3
	sid-snapshot-20180201:1.3
	sid-snapshot-20180101:1.3
	sid-snapshot-20171201:1.3
	sid-snapshot-20171101:1.3
	sid-snapshot-20171001:1.3
	sid-snapshot-20170901:1.3
	sid-snapshot-20170801:1.3
	sid-snapshot-20170701:1.3
	sid-snapshot-20170601:1.3
	sid-snapshot-20170501:1.3
	sid-snapshot-20170401:1.3
	sid-snapshot-20170301:1.3
	sid-snapshot-20170201:1.3
	sid-snapshot-20170101:1.3
	sid-snapshot-20161201:1.3
	sid-snapshot-20161101:1.3
	sid-snapshot-20160901:1.3
	sid-snapshot-20160801:1.3
	sid-snapshot-20160701:1.3
	sid-snapshot-20160601:1.3
	sid-snapshot-20160501:1.3
	sid-snapshot-20160401:1.3
	sid-snapshot-20160301:1.3
	sid-snapshot-20160201:1.3
	sid-snapshot-20160101:1.3
	sid-snapshot-20151201:1.3
	sid-snapshot-20151101:1.3
	sid-snapshot-20151001:1.3
	sid-snapshot-20150901:1.3
	sid-snapshot-20150801:1.3
	sid-snapshot-20150701:1.3
	sid-snapshot-20150601:1.3
	sid-snapshot-20150501:1.3
	sid-snapshot-20150401:1.3
	sid-snapshot-20150301:1.3
	sid-snapshot-20150201:1.3
	sid-snapshot-20150101:1.3
	sid-snapshot-20141201:1.3
	sid-snapshot-20141101:1.3
	sid-snapshot-20141001:1.3
	sid-snapshot-20140901:1.3
	sid-snapshot-20140801:1.3
	sid-snapshot-20140701:1.3
	sid-snapshot-20140601:1.3
	sid-snapshot-20140501:1.3
	sid-snapshot-20140401:1.3
	sid-snapshot-20140301:1.3
	sid-snapshot-20140201:1.3
	sid-snapshot-20140101:1.3
	sid-snapshot-20131201:1.3
	sid-snapshot-20131101:1.3
	sid-snapshot-20131001:1.3
	sid-snapshot-20130901:1.3
	sid-snapshot-20130801:1.3
	sid-snapshot-20130701:1.3
	sid-snapshot-20130601:1.3
	insight_7_6-2013-04-10-branchpoint:1.3
	gdb_7_6-branch:1.3.0.60
	sid-snapshot-20130501:1.3
	sid-snapshot-20130401:1.3
	sid-snapshot-20130301:1.3
	sid-snapshot-20130201:1.3
	sid-snapshot-20130101:1.3
	sid-snapshot-20121201:1.3
	sid-snapshot-20121101:1.3
	sid-snapshot-20121001:1.3
	sid-snapshot-20120901:1.3
	gdb_7_5-branch:1.3.0.58
	sid-snapshot-20120801:1.3
	sid-snapshot-20120701:1.3
	sid-snapshot-20120601:1.3
	sid-snapshot-20120501:1.3
	sid-snapshot-20120401:1.3
	gdb_7_4-branch:1.3.0.56
	sid-snapshot-20120301:1.3
	sid-snapshot-20120201:1.3
	sid-snapshot-20120101:1.3
	sid-snapshot-20111201:1.3
	sid-snapshot-20111101:1.3
	sid-snapshot-20111001:1.3
	sid-snapshot-20110901:1.3
	gdb_7_3-branch:1.3.0.54
	sid-snapshot-20110801:1.3
	sid-snapshot-20110701:1.3
	sid-snapshot-20110601:1.3
	sid-snapshot-20110501:1.3
	sid-snapshot-20110401:1.3
	sid-snapshot-20110301:1.3
	sid-snapshot-20110201:1.3
	sid-snapshot-20110101:1.3
	sid-snapshot-20101201:1.3
	sid-snapshot-20101101:1.3
	sid-snapshot-20101001:1.3
	sid-snapshot-20100901:1.3
	sid-snapshot-20100801:1.3
	sid-snapshot-20100701:1.3
	sid-snapshot-20100601:1.3
	sid-snapshot-20100501:1.3
	sid-snapshot-20100401:1.3
	sid-snapshot-20100301:1.3
	gdb_7_1-branch:1.3.0.52
	gdb_7_0-branch:1.3.0.50
	sid-snapshot-20100201:1.3
	sid-snapshot-20100101:1.3
	sid-snapshot-20091201:1.3
	sid-snapshot-20091101:1.3
	sid-snapshot-20091001:1.3
	arc-sim-20090309:1.3
	sid-snapshot-20090901:1.3
	sid-snapshot-20090801:1.3
	sid-snapshot-20090701:1.3
	sid-snapshot-20090601:1.3
	sid-snapshot-20090501:1.3
	kevinb-pre-tcl8_5_7_merge:1.3
	sid-snapshot-20090401:1.3
	arc-insight_6_8-branch:1.3.0.48
	arc-insight_6_8-branchpoint:1.3
	insight_6_8-branch:1.3.0.46
	insight_6_8-branchpoint:1.3
	sid-snapshot-20090301:1.3
	sid-snapshot-20090201:1.3
	sid-snapshot-20090101:1.3
	sid-snapshot-20081201:1.3
	sid-snapshot-20081101:1.3
	sid-snapshot-20081001:1.3
	sid-snapshot-20080901:1.3
	sid-snapshot-20080801:1.3
	sid-snapshot-20080701:1.3
	sid-snapshot-20080601:1.3
	sid-snapshot-20080501:1.3
	sid-snapshot-20080403:1.3
	sid-snapshot-20080401:1.3
	gdb_6_8-branch:1.3.0.44
	sid-snapshot-20080301:1.3
	sid-snapshot-20080201:1.3
	sid-snapshot-20080101:1.3
	sid-snapshot-20071201:1.3
	sid-snapshot-20071101:1.3
	sid-snapshot-20071001:1.3
	insight_6_6-20070208-release:1.3
	gdb_6_6-branch:1.3.0.42
	gdb_6_6-2006-11-15-branchpoint:1.3
	insight_6_5-20061003-release:1.3
	gdb_6_5-branch:1.3.0.40
	gdb_6_5-2006-05-14-branchpoint:1.3
	readline_5_1-import-branch:1.3.0.38
	readline_5_1-import-branchpoint:1.3
	gdb_6_4-branch:1.3.0.36
	gdb_6_4-2005-11-01-branchpoint:1.3
	msnyder-tracepoint-checkpoint-branch:1.3.0.34
	msnyder-tracepoint-checkpoint-branchpoint:1.3
	gdb_6_1-2004-04-05-release:1.3
	ezannoni_pie-20040323-branch:1.3.0.32
	ezannoni_pie-20040323-branchpoint:1.3
	cagney_tramp-20040321-mergepoint:1.3
	cagney_tramp-20040309-branch:1.3.0.30
	cagney_tramp-20040309-branchpoint:1.3
	gdb_6_1-branch:1.3.0.28
	gdb_6_1-2004-03-01-gmt-branchpoint:1.3
	drow-cplus-merge-20040208:1.3
	carlton_dictionary-20040126-merge:1.3
	drow-cplus-merge-20040113:1.3
	drow-cplus-merge-20031224:1.3
	drow-cplus-merge-20031220:1.3
	carlton_dictionary-20031215-merge:1.3
	drow-cplus-merge-20031214:1.3
	carlton-dictionary-20031111-merge:1.3
	gdb_6_0-2003-10-04-release:1.3
	carlton_dictionary-20030917-merge:1.3
	ezannoni_pie-20030916-branchpoint:1.3
	ezannoni_pie-20030916-branch:1.3.0.26
	gdb_5_1-2001-07-29-branch:1.3.0.24
	cagney_x86i386-20030821-branch:1.3.0.22
	cagney_x86i386-20030821-branchpoint:1.3
	carlton_dictionary-20030805-merge:1.3
	carlton_dictionary-20030627-merge:1.3
	gdb_6_0-branch:1.3.0.20
	gdb_6_0-2003-06-23-branchpoint:1.3
	cagney_convert-20030606-branch:1.3.0.18
	cagney_convert-20030606-branchpoint:1.3
	cagney_writestrings-20030508-branch:1.3.0.16
	cagney_writestrings-20030508-branchpoint:1.3
	carlton_dictionary-20030523-merge:1.3
	cagney_fileio-20030521-branch:1.3.0.14
	cagney_fileio-20030521-branchpoint:1.3
	carlton_dictionary-20030430-merge:1.3
	carlton_dictionary-20030416-merge:1.3
	cagney_frameaddr-20030409-mergepoint:1.3
	cagney_frameaddr-20030403-branchpoint:1.3
	cagney_frameaddr-20030403-branch:1.3.0.12
	cagney_framebase-20030330-mergepoint:1.3
	cagney_framebase-20030326-branch:1.3.0.10
	cagney_framebase-20030326-branchpoint:1.3
	cagney_lazyid-20030317-branch:1.3.0.8
	cagney_lazyid-20030317-branchpoint:1.3
	offbyone-20030313-branch:1.3.0.6
	offbyone-20030313-branchpoint:1.3
	carlton_dictionary-20030305-merge:1.3
	cagney_offbyone-20030303-branch:1.3.0.4
	cagney_offbyone-20030303-branchpoint:1.3
	carlton_dictionary-20030207-merge:1.3
	interps-20030202-branch:1.3.0.2
	interps-20030202-branchpoint:1.3
	TCL8_4_1:1.1.1.1
	cagney-unwind-20030108-branch:1.2.0.2
	cagney-unwind-20030108-branchpoint:1.2
	carlton_dictionary-20021223-merge:1.2
	TCL_8_4_1:1.1.1.1
	carlton_dictionary-20021115-merge:1.1
	kseitz_interps-20021105-merge:1.1
	kseitz_interps-20021103-merge:1.1
	drow-cplus-merge-20021020:1.1
	drow-cplus-merge-20021025:1.1
	carlton_dictionary-20021025-merge:1.1
	carlton_dictionary-20021011-merge:1.1
	drow-cplus-branch:1.1.0.6
	drow-cplus-branchpoint:1.1
	kseitz_interps-20020528-branch:1.1.0.4
	kseitz_interps-20020930-merge:1.1
	carlton_dictionary-branch:1.1.0.2
	carlton_dictionary-20020927-merge:1.1.1.1
	tcltk840-20020924-branch:1.1.1.1.0.2
	tcltk840-20020924-branchpoint:1.1.1.1
	TCL_8_4_0:1.1.1.1
	NET:1.1.1;
locks; strict;
comment	@# @;


1.3
date	2003.01.21.19.40.17;	author hunt;	state Exp;
branches
	1.3.48.1;
next	1.2;

1.2
date	2002.11.26.19.48.02;	author hunt;	state Exp;
branches;
next	1.1;

1.1
date	2002.09.24.19.56.40;	author kseitz;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.4.1
	1.1.6.1;
next	;

1.3.48.1
date	2009.09.11.04.46.02;	author amylaar;	state Exp;
branches;
next	;

1.1.1.1
date	2002.09.24.19.56.40;	author kseitz;	state Exp;
branches;
next	;

1.1.2.1
date	2002.09.27.20.03.39;	author carlton;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2002.10.11.22.23.12;	author carlton;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2002.12.23.19.40.45;	author carlton;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2003.02.07.19.18.20;	author carlton;	state Exp;
branches;
next	;

1.1.4.1
date	2002.10.01.00.46.57;	author kseitz;	state Exp;
branches;
next	;

1.1.6.1
date	2003.12.14.20.28.50;	author drow;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Updated to tcl 8.4.1
@
text
@# Commands covered:  string
#
# This file contains a collection of tests for one or more of the Tcl
# built-in commands.  Sourcing this file into Tcl runs the tests and
# generates output for errors.  No output means no errors were found.
#
# This differs from the original string tests in that the tests call
# things in procs, which uses the compiled string code instead of
# the runtime parse string code.  The tests of import should match
# their equivalent number in string.test.
#
# Copyright (c) 2001 by ActiveState Corporation.
# Copyright (c) 2001 by Kevin B. Kenny.  All rights reserved.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# RCS: @@(#) $Id: stringComp.test,v 1.5 2002/05/29 09:09:00 hobbs Exp $

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import -force ::tcltest::*
}

# Some tests require the testobj command

set ::tcltest::testConstraints(testobj) \
	[expr {[info commands testobj] != {}}]

test string-1.1 {error conditions} {
    proc foo {} {string gorp a b}
    list [catch {foo} msg] $msg
} {1 {bad option "gorp": must be bytelength, compare, equal, first, index, is, last, length, map, match, range, repeat, replace, tolower, toupper, totitle, trim, trimleft, trimright, wordend, or wordstart}}
test string-1.2 {error conditions} {
    proc foo {} {string}
    list [catch {foo} msg] $msg
} {1 {wrong # args: should be "string option arg ?arg ...?"}}
test string-1.3 {error condition - undefined method during compile} {
    # We don't want this to complain about 'never' because it may never
    # be called, or string may get redefined.  This must compile OK.
    proc foo {str i} {
        if {"yes" == "no"} { string never called but complains here }
        string index $str $i
    }
    foo abc 0
} a

test string-2.1 {string compare, too few args} {
    proc foo {} {string compare a}
    list [catch {foo} msg] $msg
} {1 {wrong # args: should be "string compare ?-nocase? ?-length int? string1 string2"}}
test string-2.2 {string compare, bad args} {
    proc foo {} {string compare a b c}
    list [catch {foo} msg] $msg
} {1 {bad option "a": must be -nocase or -length}}
test string-2.3 {string compare, bad args} {
    list [catch {string compare -length -nocase str1 str2} msg] $msg
} {1 {expected integer but got "-nocase"}}
test string-2.4 {string compare, too many args} {
    list [catch {string compare -length 10 -nocase str1 str2 str3} msg] $msg
} {1 {wrong # args: should be "string compare ?-nocase? ?-length int? string1 string2"}}
test string-2.5 {string compare with length unspecified} {
    list [catch {string compare -length 10 10} msg] $msg
} {1 {wrong # args: should be "string compare ?-nocase? ?-length int? string1 string2"}}
test string-2.6 {string compare} {
    proc foo {} {string compare abcde abdef}
    foo
} -1
test string-2.7 {string compare, shortest method name} {
    proc foo {} {string c abcde ABCDE}
    foo
} 1
test string-2.8 {string compare} {
    proc foo {} {string compare abcde abcde}
    foo
} 0
test string-2.9 {string compare with length} {
    proc foo {} {string compare -length 2 abcde abxyz}
    foo
} 0
test string-2.10 {string compare with special index} {
    proc foo {} {string compare -length end-3 abcde abxyz}
    list [catch {foo} msg] $msg
} {1 {expected integer but got "end-3"}}
test string-2.11 {string compare, unicode} {
    proc foo {} {string compare ab\u7266 ab\u7267}
    foo
} -1
test string-2.12 {string compare, high bit} {
    # This test will fail if the underlying comparaison
    # is using signed chars instead of unsigned chars.
    # (like SunOS's default memcmp thus the compat/memcmp.c)
    proc foo {} {string compare "\x80" "@@"}
    foo
    # Nb this tests works also in utf8 space because \x80 is
    # translated into a 2 or more bytelength but whose first byte has
    # the high bit set.
} 1
test string-2.13 {string compare -nocase} {
    proc foo {} {string compare -nocase abcde abdef}
    foo
} -1
test string-2.14 {string compare -nocase} {
    proc foo {} {string c -nocase abcde ABCDE}
    foo
} 0
test string-2.15 {string compare -nocase} {
    proc foo {} {string compare -nocase abcde abcde}
    foo
} 0
test string-2.16 {string compare -nocase with length} {
    proc foo {} {string compare -length 2 -nocase abcde Abxyz}
    foo
} 0
test string-2.17 {string compare -nocase with length} {
    proc foo {} {string compare -nocase -length 3 abcde Abxyz}
    foo
} -1
test string-2.18 {string compare -nocase with length <= 0} {
    proc foo {} {string compare -nocase -length -1 abcde AbCdEf}
    foo
} -1
test string-2.19 {string compare -nocase with excessive length} {
    proc foo {} {string compare -nocase -length 50 AbCdEf abcde}
    foo
} 1
test string-2.20 {string compare -len unicode} {
    # These are strings that are 6 BYTELENGTH long, but the length
    # shouldn't make a different because there are actually 3 CHARS long
    proc foo {} {string compare -len 5 \334\334\334 \334\334\374}
    foo
} -1
test string-2.21 {string compare -nocase with special index} {
    proc foo {} {string compare -nocase -length end-3 Abcde abxyz}
    list [catch {foo} msg] $msg
} {1 {expected integer but got "end-3"}}
test string-2.22 {string compare, null strings} {
    proc foo {} {string compare "" ""}
    foo
} 0
test string-2.23 {string compare, null strings} {
    proc foo {} {string compare "" foo}
    foo
} -1
test string-2.24 {string compare, null strings} {
    proc foo {} {string compare foo ""}
    foo
} 1
test string-2.25 {string compare -nocase, null strings} {
    proc foo {} {string compare -nocase "" ""}
    foo
} 0
test string-2.26 {string compare -nocase, null strings} {
    proc foo {} {string compare -nocase "" foo}
    foo
} -1
test string-2.27 {string compare -nocase, null strings} {
    proc foo {} {string compare -nocase foo ""}
    foo
} 1
test string-2.28 {string compare with length, unequal strings} {
    proc foo {} {string compare -length 2 abc abde}
    foo
} 0
test string-2.29 {string compare with length, unequal strings} {
    proc foo {} {string compare -length 2 ab abde}
    foo
} 0
test string-2.30 {string compare with NUL character vs. other ASCII} {
    # Be careful here, since UTF-8 rep comparison with memcmp() of
    # these puts chars in the wrong order
    proc foo {} {string compare \x00 \x01}
    foo
} -1
test string-2.31 {string compare, high bit} {
    proc foo {} {string compare "a\x80" "a@@"}
    foo
} 1
test string-2.32 {string compare, high bit} {
    proc foo {} {string compare "a\x00" "a\x01"}
    foo
} -1
test string-2.33 {string compare, high bit} {
    proc foo {} {string compare "\x00\x00" "\x00\x01"}
    foo
} -1

# only need a few tests on equal, since it uses the same code as
# string compare, but just modifies the return output
test string-3.1 {string equal} {
    proc foo {} {string equal abcde abdef}
    foo
} 0
test string-3.2 {string equal} {
    proc foo {} {string eq abcde ABCDE}
    foo
} 0
test string-3.3 {string equal} {
    proc foo {} {string equal abcde abcde}
    foo
} 1
test string-3.4 {string equal -nocase} {
    proc foo {} {string equal -nocase \334\334\334\334\374\374\374\374 \334\334\334\334\334\334\334\334}
    foo
} 1
test string-3.5 {string equal -nocase} {
    proc foo {} {string equal -nocase abcde abdef}
    foo
} 0
test string-3.6 {string equal -nocase} {
    proc foo {} {string eq -nocase abcde ABCDE}
    foo
} 1
test string-3.7 {string equal -nocase} {
    proc foo {} {string equal -nocase abcde abcde}
    foo
} 1
test string-3.8 {string equal with length, unequal strings} {
    proc foo {} {string equal -length 2 abc abde}
    foo
} 1

test string-4.1 {string first, too few args} {
    proc foo {} {string first a}
    list [catch {foo} msg] $msg
} {1 {wrong # args: should be "string first subString string ?startIndex?"}}
test string-4.2 {string first, bad args} {
    proc foo {} {string first a b c}
    list [catch {foo} msg] $msg
} {1 {bad index "c": must be integer or end?-integer?}}
test string-4.3 {string first, too many args} {
    proc foo {} {string first a b 5 d}
    list [catch {foo} msg] $msg
} {1 {wrong # args: should be "string first subString string ?startIndex?"}}
test string-4.4 {string first} {
    proc foo {} {string first bq abcdefgbcefgbqrs}
    foo
} 12
test string-4.5 {string first} {
    proc foo {} {string fir bcd abcdefgbcefgbqrs}
    foo
} 1
test string-4.6 {string first} {
    proc foo {} {string f b abcdefgbcefgbqrs}
    foo
} 1
test string-4.7 {string first} {
    proc foo {} {string first xxx x123xx345xxx789xxx012}
    foo
} 9
test string-4.8 {string first} {
    proc foo {} {string first "" x123xx345xxx789xxx012}
    foo
} -1
test string-4.9 {string first, unicode} {
    proc foo {} {string first x abc\u7266x}
    foo
} 4
test string-4.10 {string first, unicode} {
    proc foo {} {string first \u7266 abc\u7266x}
    foo
} 3
test string-4.11 {string first, start index} {
    proc foo {} {string first \u7266 abc\u7266x 3}
    foo
} 3
test string-4.12 {string first, start index} {
    proc foo {} {string first \u7266 abc\u7266x 4}
    foo
} -1
test string-4.13 {string first, start index} {
    proc foo {} {string first \u7266 abc\u7266x end-2}
    foo
} 3
test string-4.14 {string first, negative start index} {
    proc foo {} {string first b abc -1}
    foo
} 1

test string-5.1 {string index} {
    proc foo {} {string index}
    list [catch {foo} msg] $msg
} {1 {wrong # args: should be "string index string charIndex"}}
test string-5.2 {string index} {
    proc foo {} {string index a b c}
    list [catch {foo} msg] $msg
} {1 {wrong # args: should be "string index string charIndex"}}
test string-5.3 {string index} {
    proc foo {} {string index abcde 0}
    foo
} a
test string-5.4 {string index} {
    proc foo {} {string in abcde 4}
    foo
} e
test string-5.5 {string index} {
    proc foo {} {string index abcde 5}
    foo
} {}
test string-5.6 {string index} {
    proc foo {} {string index abcde -10}
    list [catch {foo} msg] $msg
} {0 {}}
test string-5.7 {string index} {
    proc foo {} {string index a xyz}
    list [catch {foo} msg] $msg
} {1 {bad index "xyz": must be integer or end?-integer?}}
test string-5.8 {string index} {
    proc foo {} {string index abc end}
    foo
} c
test string-5.9 {string index} {
    proc foo {} {string index abc end-1}
    foo
} b
test string-5.10 {string index, unicode} {
    proc foo {} {string index abc\u7266d 4}
    foo
} d
test string-5.11 {string index, unicode} {
    proc foo {} {string index abc\u7266d 3}
    foo
} \u7266
test string-5.12 {string index, unicode over char length, under byte length} {
    proc foo {} {string index \334\374\334\374 6}
    foo
} {}
test string-5.13 {string index, bytearray object} {
    proc foo {} {string index [binary format a5 fuz] 0}
    foo
} f
test string-5.14 {string index, bytearray object} {
    proc foo {} {string index [binary format I* {0x50515253 0x52}] 3}
    foo
} S
test string-5.15 {string index, bytearray object} {
    proc foo {} {
	set b [binary format I* {0x50515253 0x52}]
	set i1 [string index $b end-6]
	set i2 [string index $b 1]
	string compare $i1 $i2
    }
    foo
} 0
test string-5.16 {string index, bytearray object with string obj shimmering} {
    proc foo {} {
	set str "0123456789\x00 abcdedfghi"
	binary scan $str H* dump
	string compare [string index $str 10] \x00
    }
    foo
} 0
test string-5.17 {string index, bad integer} {
    proc foo {} {string index "abc" 08}
    list [catch {foo} msg] $msg
} {1 {bad index "08": must be integer or end?-integer? (looks like invalid octal number)}}
test string-5.18 {string index, bad integer} {
    proc foo {} {string index "abc" end-00289}
    list [catch {foo} msg] $msg
} {1 {bad index "end-00289": must be integer or end?-integer? (looks like invalid octal number)}}
test string-5.19 {string index, bytearray object out of bounds} {
    proc foo {} {string index [binary format I* {0x50515253 0x52}] -1}
    foo
} {}
test string-5.20 {string index, bytearray object out of bounds} {
    proc foo {} {string index [binary format I* {0x50515253 0x52}] 20}
    foo
} {}


proc largest_int {} {
    # This will give us what the largest valid int on this machine is,
    # so we can test for overflow properly below on >32 bit systems
    set int 1
    set exp 7; # assume we get at least 8 bits
    while {$int > 0} { set int [expr {1 << [incr exp]}] }
    return [expr {$int-1}]
}

## string is
## not yet bc

catch {rename largest_int {}}

## string last
## not yet bc

## string length
## not yet bc
test string-8.1 {string bytelength} {
    proc foo {} {string bytelength}
    list [catch {foo} msg] $msg
} {1 {wrong # args: should be "string bytelength string"}}
test string-8.2 {string bytelength} {
    proc foo {} {string bytelength a b}
    list [catch {foo} msg] $msg
} {1 {wrong # args: should be "string bytelength string"}}
test string-8.3 {string bytelength} {
    proc foo {} {string bytelength "\u00c7"}
    foo
} 2
test string-8.4 {string bytelength} {
    proc foo {} {string b ""}
    foo
} 0

## string length
##
test string-9.1 {string length} {
    proc foo {} {string length}
    list [catch {foo} msg] $msg
} {1 {wrong # args: should be "string length string"}}
test string-9.2 {string length} {
    proc foo {} {string length a b}
    list [catch {foo} msg] $msg
} {1 {wrong # args: should be "string length string"}}
test string-9.3 {string length} {
    proc foo {} {string length "a little string"}
    foo
} 15
test string-9.4 {string length} {
    proc foo {} {string le ""}
    foo
} 0
test string-9.5 {string length, unicode} {
    proc foo {} {string le "abcd\u7266"}
    foo
} 5
test string-9.6 {string length, bytearray object} {
    proc foo {} {string length [binary format a5 foo]}
    foo
} 5
test string-9.7 {string length, bytearray object} {
    proc foo {} {string length [binary format I* {0x50515253 0x52}]}
    foo
} 8

## string map
## not yet bc

## string match
##
test string-11.1 {string match, too few args} {
    proc foo {} {string match a}
    list [catch {foo} msg] $msg
} {1 {wrong # args: should be "string match ?-nocase? pattern string"}}
test string-11.2 {string match, too many args} {
    proc foo {} {string match a b c d}
    list [catch {foo} msg] $msg
} {1 {wrong # args: should be "string match ?-nocase? pattern string"}}
test string-11.3 {string match} {
    proc foo {} {string match abc abc}
    foo
} 1
test string-11.4 {string match} {
    proc foo {} {string mat abc abd}
    foo
} 0
test string-11.5 {string match} {
    proc foo {} {string match ab*c abc}
    foo
} 1
test string-11.6 {string match} {
    proc foo {} {string match ab**c abc}
    foo
} 1
test string-11.7 {string match} {
    proc foo {} {string match ab* abcdef}
    foo
} 1
test string-11.8 {string match} {
    proc foo {} {string match *c abc}
    foo
} 1
test string-11.9 {string match} {
    proc foo {} {string match *3*6*9 0123456789}
    foo
} 1
test string-11.10 {string match} {
    proc foo {} {string match *3*6*9 01234567890}
    foo
} 0
test string-11.11 {string match} {
    proc foo {} {string match a?c abc}
    foo
} 1
test string-11.12 {string match} {
    proc foo {} {string match a??c abc}
    foo
} 0
test string-11.13 {string match} {
    proc foo {} {string match ?1??4???8? 0123456789}
    foo
} 1
test string-11.14 {string match} {
    proc foo {} {string match {[abc]bc} abc}
    foo
} 1
test string-11.15 {string match} {
    proc foo {} {string match {a[abc]c} abc}
    foo
} 1
test string-11.16 {string match} {
    proc foo {} {string match {a[xyz]c} abc}
    foo
} 0
test string-11.17 {string match} {
    proc foo {} {string match {12[2-7]45} 12345}
    foo
} 1
test string-11.18 {string match} {
    proc foo {} {string match {12[ab2-4cd]45} 12345}
    foo
} 1
test string-11.19 {string match} {
    proc foo {} {string match {12[ab2-4cd]45} 12b45}
    foo
} 1
test string-11.20 {string match} {
    proc foo {} {string match {12[ab2-4cd]45} 12d45}
    foo
} 1
test string-11.21 {string match} {
    proc foo {} {string match {12[ab2-4cd]45} 12145}
    foo
} 0
test string-11.22 {string match} {
    proc foo {} {string match {12[ab2-4cd]45} 12545}
    foo
} 0
test string-11.23 {string match} {
    proc foo {} {string match {a\*b} a*b}
    foo
} 1
test string-11.24 {string match} {
    proc foo {} {string match {a\*b} ab}
    foo
} 0
test string-11.25 {string match} {
    proc foo {} {string match {a\*\?\[\]\\\x} "a*?\[\]\\x"}
    foo
} 1
test string-11.26 {string match} {
    proc foo {} {string match ** ""}
    foo
} 1
test string-11.27 {string match} {
    proc foo {} {string match *. ""}
    foo
} 0
test string-11.28 {string match} {
    proc foo {} {string match "" ""}
    foo
} 1
test string-11.29 {string match} {
    proc foo {} {string match \[a a}
    foo
} 1
test string-11.30 {string match, bad args} {
    proc foo {} {string match - b c}
    list [catch {foo} msg] $msg
} {1 {bad option "-": must be -nocase}}
test string-11.31 {string match case} {
    proc foo {} {string match a A}
    foo
} 0
test string-11.32 {string match nocase} {
    proc foo {} {string match -n a A}
    foo
} 1
test string-11.33 {string match nocase} {
    proc foo {} {string match -nocase a\334 A\374}
    foo
} 1
test string-11.34 {string match nocase} {
    proc foo {} {string match -nocase a*f ABCDEf}
    foo
} 1
test string-11.35 {string match case, false hope} {
    # This is true because '_' lies between the A-Z and a-z ranges
    proc foo {} {string match {[A-z]} _}
    foo
} 1
test string-11.36 {string match nocase range} {
    # This is false because although '_' lies between the A-Z and a-z ranges,
    # we lower case the end points before checking the ranges.
    proc foo {} {string match -nocase {[A-z]} _}
    foo
} 0
test string-11.37 {string match nocase} {
    proc foo {} {string match -nocase {[A-fh-Z]} g}
    foo
} 0
test string-11.38 {string match case, reverse range} {
    proc foo {} {string match {[A-fh-Z]} g}
    foo
} 1
test string-11.39 {string match, *\ case} {
    proc foo {} {string match {*\abc} abc}
    foo
} 1
test string-11.40 {string match, *special case} {
    proc foo {} {string match {*[ab]} abc}
    foo
} 0
test string-11.41 {string match, *special case} {
    proc foo {} {string match {*[ab]*} abc}
    foo
} 1
test string-11.42 {string match, *special case} {
    proc foo {} {string match "*\\" "\\"}
    foo
} 0
test string-11.43 {string match, *special case} {
    proc foo {} {string match "*\\\\" "\\"}
    foo
} 1
test string-11.44 {string match, *special case} {
    proc foo {} {string match "*???" "12345"}
    foo
} 1
test string-11.45 {string match, *special case} {
    proc foo {} {string match "*???" "12"}
    foo
} 0
test string-11.46 {string match, *special case} {
    proc foo {} {string match "*\\*" "abc*"}
    foo
} 1
test string-11.47 {string match, *special case} {
    proc foo {} {string match "*\\*" "*"}
    foo
} 1
test string-11.48 {string match, *special case} {
    proc foo {} {string match "*\\*" "*abc"}
    foo
} 0
test string-11.49 {string match, *special case} {
    proc foo {} {string match "?\\*" "a*"}
    foo
} 1
test string-11.50 {string match, *special case} {
    proc foo {} {string match "\\" "\\"}
    foo
} 0

## string range
## not yet bc

## string repeat
## not yet bc

## string replace
## not yet bc

## string tolower
## not yet bc

## string toupper
## not yet bc

## string totitle
## not yet bc

## string trim*
## not yet bc

## string word*
## not yet bc

# cleanup
::tcltest::cleanupTests
return
@


1.3.48.1
log
@gdb/insight for ARCompact (from Richard Stuckey)
@
text
@d18 1
a18 1
# RCS: @@(#) $Id: stringComp.test,v 1.3 2003/01/21 19:40:17 hunt Exp $
@


1.2
log
@touched all sources to ease next import
@
text
@d18 1
a18 1
# RCS: @@(#) $Id: stringComp.test,v 1.1 2002/09/24 19:56:40 kseitz Exp $
@


1.1
log
@Initial revision
@
text
@d18 1
a18 1
# RCS: @@(#) $Id: stringComp.test,v 1.5 2002/05/29 09:09:00 hobbs Exp $
@


1.1.6.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d18 1
a18 1
# RCS: @@(#) $Id: stringComp.test,v 1.3 2003/01/21 19:40:17 hunt Exp $
@


1.1.4.1
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d18 1
a18 1
# RCS: @@(#) $Id: stringComp.test,v 1.1 2002/09/24 19:56:40 kseitz Exp $
@


1.1.2.1
log
@Merge with mainline; tag is carlton_dictionary-20020927-merge
@
text
@d18 1
a18 1
# RCS: @@(#) $Id: stringComp.test,v 1.1.1.1 2002/09/24 19:56:40 kseitz Exp $
@


1.1.2.2
log
@Merge with mainline; merge tag carlton_dictionary-20021011-merge.
@
text
@d18 1
a18 1
# RCS: @@(#) $Id: stringComp.test,v 1.1 2002/09/24 19:56:40 kseitz Exp $
@


1.1.2.3
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d18 1
a18 1
# RCS: @@(#) $Id: stringComp.test,v 1.1.2.2 2002/10/11 22:23:12 carlton Exp $
@


1.1.2.4
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d18 1
a18 1
# RCS: @@(#) $Id: stringComp.test,v 1.1.2.3 2002/12/23 19:40:45 carlton Exp $
@


1.1.1.1
log
@import tcl 8.4.0
@
text
@@
