head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.58
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.56
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.54
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.52
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.50
	gdb_7_0-branch:1.5.0.48
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tcl8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.46
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.44
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.42
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.40
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.38
	gdb_6_5-2006-05-14-branchpoint:1.5
	readline_5_1-import-branch:1.5.0.36
	readline_5_1-import-branchpoint:1.5
	gdb_6_4-branch:1.5.0.34
	gdb_6_4-2005-11-01-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.32
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	ezannoni_pie-20040323-branch:1.5.0.30
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.28
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.26
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.24
	cagney_x86i386-20030821-branch:1.5.0.22
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.20
	gdb_6_0-2003-06-23-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.18
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.16
	cagney_writestrings-20030508-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.14
	cagney_fileio-20030521-branchpoint:1.5
	carlton_dictionary-20030430-merge:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.12
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.10
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.8
	cagney_lazyid-20030317-branchpoint:1.5
	offbyone-20030313-branch:1.5.0.6
	offbyone-20030313-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.4
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.2
	interps-20030202-branchpoint:1.5
	TCL8_4_1:1.1.1.3
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.2
	TCL_8_4_1:1.1.1.3
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.4
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TCL_8_4_0:1.1.1.3
	carlton_dictionary-branch:1.2.0.16
	carlton_dictionary-20020920-branchpoint:1.2
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.14
	gdb_5_3-branch:1.2.0.12
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.10
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.8
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.6
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TCL_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	dejagnu-2000-02-04:1.1.1.1
	dejagnu-2000-01-31:1.1.1.1
	dejagnu-2000-01-24:1.1.1.1
	dejagnu-2000-01-17:1.1.1.1
	dejagnu-2000-01-10:1.1.1.1
	dejagnu-2000-01-04:1.1.1.1
	dejagnu-1999-12-21:1.1.1.1
	dejagnu-1999-12-13:1.1.1.1
	dejagnu-1999-12-07:1.1.1.1
	dejagnu-1999-12-06:1.1.1.1
	dejagnu-1999-11-15:1.1.1.1
	dejagnu-1999-11-08:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2003.01.21.19.40.14;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.26.19.48.00;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.37.07;	author kseitz;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2001.09.09.23.56.08;	author irox;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2002.09.27.21.49.10;	author kseitz;	state Exp;
branches;
next	;

1.3.4.1
date	2003.12.14.20.28.49;	author drow;	state Exp;
branches;
next	;

1.2.16.1
date	2002.12.23.19.40.37;	author carlton;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2003.02.07.19.18.17;	author carlton;	state Exp;
branches;
next	;

1.1.1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.09.22.40.58;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.19.56.34;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tcl 8.4.1
@
text
@# The tests in this file cover the procedures in tclCmdMZ.c.
#
# This file contains a collection of tests for one or more of the Tcl
# built-in commands.  Sourcing this file into Tcl runs the tests and
# generates output for errors.  No output means no errors were found.
#
# Copyright (c) 1991-1993 The Regents of the University of California.
# Copyright (c) 1994 Sun Microsystems, Inc.
# Copyright (c) 1998-1999 by Scriptics Corporation.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# RCS: @@(#) $Id: cmdMZ.test,v 1.13 2002/07/19 08:52:27 dkf Exp $

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import -force ::tcltest::*
}
set tcltest::testConstraints(nonLinuxOnly) \
	[expr {![string equal Linux $tcl_platform(os)]}]

# Tcl_PwdObjCmd

test cmdMZ-1.1 {Tcl_PwdObjCmd} {
    list [catch {pwd a} msg] $msg
} {1 {wrong # args: should be "pwd"}}
test cmdMZ-1.2 {Tcl_PwdObjCmd: simple pwd} {
    catch pwd
} 0
test cmdMZ-1.3 {Tcl_PwdObjCmd: simple pwd} {
    expr [string length pwd]>0
} 1
test cmdMZ-1.4 {Tcl_PwdObjCmd: failure} {unixOnly nonLinuxOnly} {
    # We don't want this test to run on Linux because they do a
    # permissions caching trick which causes this to fail.  The
    # caching is incorrect, but we have no control over that.
    set foodir [file join [temporaryDirectory] foo]
    file delete -force $foodir
    file mkdir $foodir
    set cwd [pwd]
    cd $foodir
    file attr . -permissions 000
    set result [list [catch {pwd} msg] $msg]
    cd $cwd
    file delete -force $foodir
    set result
} {1 {error getting working directory name: permission denied}}

# The tests for Tcl_RegexpObjCmd, Tcl_RegsubObjCmd are in regexp.test

# Tcl_RenameObjCmd

test cmdMZ-2.1 {Tcl_RenameObjCmd: error conditions} {
    list [catch {rename r1} msg] $msg $errorCode
} {1 {wrong # args: should be "rename oldName newName"} NONE}
test cmdMZ-2.2 {Tcl_RenameObjCmd: error conditions} {
    list [catch {rename r1 r2 r3} msg] $msg $errorCode
} {1 {wrong # args: should be "rename oldName newName"} NONE}
test cmdMZ-2.3 {Tcl_RenameObjCmd: success} {
    catch {rename r2 {}}
    proc r1 {} {return "r1"}
    rename r1 r2
    r2
} {r1}
test cmdMZ-2.4 {Tcl_RenameObjCmd: success} {
    proc r1 {} {return "r1"}
    rename r1 {}
    list [catch {r1} msg] $msg
} {1 {invalid command name "r1"}}

# The tests for Tcl_ReturnObjCmd are in proc-old.test
# The tests for Tcl_ScanObjCmd are in scan.test

# Tcl_SourceObjCmd

test cmdMZ-3.1 {Tcl_SourceObjCmd: error conditions} {macOnly} {
    list [catch {source} msg] $msg
} {1 {wrong # args: should be "source fileName" or "source -rsrc name ?fileName?" or "source -rsrcid id ?fileName?"}}
test cmdMZ-3.2 {Tcl_SourceObjCmd: error conditions} {macOnly} {
    list [catch {source a b} msg] $msg
} {1 {bad argument: should be "source fileName" or "source -rsrc name ?fileName?" or "source -rsrcid id ?fileName?"}}
test cmdMZ-3.3 {Tcl_SourceObjCmd: error conditions} {unixOrPc} {
    list [catch {source} msg] $msg
} {1 {wrong # args: should be "source fileName"}}
test cmdMZ-3.4 {Tcl_SourceObjCmd: error conditions} {unixOrPc} {
    list [catch {source a b} msg] $msg
} {1 {wrong # args: should be "source fileName"}}
test cmdMZ-3.5 {Tcl_SourceObjCmd: error in script} -body {
    set file [makeFile {
	set x 146
	error "error in sourced file"
	set y $x
    } source.file]
    set result [list [catch {source $file} msg] $msg $errorInfo]
    removeFile source.file
    set result
} -match glob -result {1 {error in sourced file} {error in sourced file
    while executing
"error "error in sourced file""
    (file "*" line 3)
    invoked from within
"source $file"}}
test cmdMZ-3.6 {Tcl_SourceObjCmd: simple script} {
    set file [makeFile {list result} source.file]
    set result [source $file]
    removeFile source.file
    set result
} result

# Tcl_SplitObjCmd

test cmdMZ-4.1 {Tcl_SplitObjCmd: split errors} {
    list [catch split msg] $msg $errorCode
} {1 {wrong # args: should be "split string ?splitChars?"} NONE}
test cmdMZ-4.2 {Tcl_SplitObjCmd: split errors} {
    list [catch {split a b c} msg] $msg $errorCode
} {1 {wrong # args: should be "split string ?splitChars?"} NONE}
test cmdMZ-4.3 {Tcl_SplitObjCmd: basic split commands} {
    split "a\n b\t\r c\n "
} {a {} b {} {} c {} {}}
test cmdMZ-4.4 {Tcl_SplitObjCmd: basic split commands} {
    split "word 1xyzword 2zword 3" xyz
} {{word 1} {} {} {word 2} {word 3}}
test cmdMZ-4.5 {Tcl_SplitObjCmd: basic split commands} {
    split "12345" {}
} {1 2 3 4 5}
test cmdMZ-4.6 {Tcl_SplitObjCmd: basic split commands} {
    split "a\}b\[c\{\]\$"
} "a\\}b\\\[c\\{\\\]\\\$"
test cmdMZ-4.7 {Tcl_SplitObjCmd: basic split commands} {
    split {} {}
} {}
test cmdMZ-4.8 {Tcl_SplitObjCmd: basic split commands} {
    split {}
} {}
test cmdMZ-4.9 {Tcl_SplitObjCmd: basic split commands} {
    split {   }
} {{} {} {} {}}
test cmdMZ-4.10 {Tcl_SplitObjCmd: basic split commands} {
    proc foo {} {
        set x {}
        foreach f [split {]\n} {}] {
            append x $f
        }
        return $x	
    }
    foo
} {]\n}
test cmdMZ-4.11 {Tcl_SplitObjCmd: basic split commands} {
    proc foo {} {
        set x ab\000c
        set y [split $x {}]
        return $y
    }
    foo
} "a b \000 c"
test cmdMZ-4.12 {Tcl_SplitObjCmd: basic split commands} {
    split "a0ab1b2bbb3\000c4" ab\000c
} {{} 0 {} 1 2 {} {} 3 {} 4}
test cmdMZ-4.13 {Tcl_SplitObjCmd: basic split commands} {
    # if not UTF-8 aware, result is "a {} {} b qw\xe5 {} N wq"
    split "a\u4e4eb qw\u5e4e\x4e wq" " \u4e4e"
} "a b qw\u5e4eN wq"

# The tests for Tcl_StringObjCmd are in string.test
# The tests for Tcl_SubstObjCmd are in subst.test
# The tests for Tcl_SwitchObjCmd are in switch.test

test cmdMZ-5.1 {Tcl_TimeObjCmd: basic format of command} {
    list [catch {time} msg] $msg
} {1 {wrong # args: should be "time command ?count?"}}
test cmdMZ-5.2 {Tcl_TimeObjCmd: basic format of command} {
    list [catch {time a b c} msg] $msg
} {1 {wrong # args: should be "time command ?count?"}}
test cmdMZ-5.3 {Tcl_TimeObjCmd: basic format of command} {
    list [catch {time a b} msg] $msg
} {1 {expected integer but got "b"}}
test cmdMZ-5.4 {Tcl_TimeObjCmd: nothing happens with negative iteration counts} {
    time bogusCmd -12456
} {0 microseconds per iteration}
test cmdMZ-5.5 {Tcl_TimeObjCmd: result format} {
    regexp {^\d+ microseconds per iteration} [time {format 1}]
} 1
test cmdMZ-5.6 {Tcl_TimeObjCmd: slower commands take longer} {
    expr {[lindex [time {after 2}] 0] < [lindex [time {after 1000}] 0]}
} 1
test cmdMZ-5.7 {Tcl_TimeObjCmd: errors generate right trace} {
    list [catch {time {error foo}} msg] $msg $::errorInfo
} {1 foo {foo
    while executing
"error foo"
    invoked from within
"time {error foo}"}}

# The tests for Tcl_TraceObjCmd and TraceVarProc are in trace.test
# The tests for Tcl_WhileObjCmd are in while.test

# cleanup
::tcltest::cleanupTests
return
@


1.4
log
@touched all sources to ease next import
@
text
@d14 1
a14 1
# RCS: @@(#) $Id: cmdMZ.test,v 1.6.8.2 2000/09/15 16:56:07 spolk Exp $
d20 2
d34 7
a40 3
test cmdMZ-1.4 {Tcl_PwdObjCmd: failure} {unixOnly} {
    file delete -force foo
    file mkdir foo
d42 1
a42 1
    cd foo
d46 1
a46 1
    file delete -force foo
d82 1
a82 1
} {1 {wrong # args: should be "source fileName" or "source -rsrc name ?fileName?" or "source -rsrcid id ?fileName?"}}
d89 2
a90 2
test cmdMZ-3.5 {Tcl_SourceObjCmd: error in script} {
    makeFile {
d94 5
a98 3
    } source.file
    list [catch {source source.file} msg] $msg $errorInfo
} {1 {error in sourced file} {error in sourced file
d101 1
a101 1
    (file "source.file" line 3)
d103 1
a103 1
"source source.file"}}
d105 4
a108 2
    makeFile {list result} source.file
    source source.file
d169 27
a195 1
# There are no tests for Tcl_TimeObjCmd
a201 1

@


1.3
log
@touched all sources to ease next import
@
text
@@


1.3.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d14 1
a14 1
# RCS: @@(#) $Id: cmdMZ.test,v 1.13 2002/07/19 08:52:27 dkf Exp $
a19 2
set tcltest::testConstraints(nonLinuxOnly) \
	[expr {![string equal Linux $tcl_platform(os)]}]
d32 3
a34 7
test cmdMZ-1.4 {Tcl_PwdObjCmd: failure} {unixOnly nonLinuxOnly} {
    # We don't want this test to run on Linux because they do a
    # permissions caching trick which causes this to fail.  The
    # caching is incorrect, but we have no control over that.
    set foodir [file join [temporaryDirectory] foo]
    file delete -force $foodir
    file mkdir $foodir
d36 1
a36 1
    cd $foodir
d40 1
a40 1
    file delete -force $foodir
d76 1
a76 1
} {1 {bad argument: should be "source fileName" or "source -rsrc name ?fileName?" or "source -rsrcid id ?fileName?"}}
d83 2
a84 2
test cmdMZ-3.5 {Tcl_SourceObjCmd: error in script} -body {
    set file [makeFile {
d88 3
a90 5
    } source.file]
    set result [list [catch {source $file} msg] $msg $errorInfo]
    removeFile source.file
    set result
} -match glob -result {1 {error in sourced file} {error in sourced file
d93 1
a93 1
    (file "*" line 3)
d95 1
a95 1
"source $file"}}
d97 2
a98 4
    set file [makeFile {list result} source.file]
    set result [source $file]
    removeFile source.file
    set result
d159 1
a159 27

test cmdMZ-5.1 {Tcl_TimeObjCmd: basic format of command} {
    list [catch {time} msg] $msg
} {1 {wrong # args: should be "time command ?count?"}}
test cmdMZ-5.2 {Tcl_TimeObjCmd: basic format of command} {
    list [catch {time a b c} msg] $msg
} {1 {wrong # args: should be "time command ?count?"}}
test cmdMZ-5.3 {Tcl_TimeObjCmd: basic format of command} {
    list [catch {time a b} msg] $msg
} {1 {expected integer but got "b"}}
test cmdMZ-5.4 {Tcl_TimeObjCmd: nothing happens with negative iteration counts} {
    time bogusCmd -12456
} {0 microseconds per iteration}
test cmdMZ-5.5 {Tcl_TimeObjCmd: result format} {
    regexp {^\d+ microseconds per iteration} [time {format 1}]
} 1
test cmdMZ-5.6 {Tcl_TimeObjCmd: slower commands take longer} {
    expr {[lindex [time {after 2}] 0] < [lindex [time {after 1000}] 0]}
} 1
test cmdMZ-5.7 {Tcl_TimeObjCmd: errors generate right trace} {
    list [catch {time {error foo}} msg] $msg $::errorInfo
} {1 foo {foo
    while executing
"error foo"
    invoked from within
"time {error foo}"}}

d166 1
@


1.3.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@d14 1
a14 1
# RCS: @@(#) $Id: cmdMZ.test,v 1.13 2002/07/19 08:52:27 dkf Exp $
a19 2
set tcltest::testConstraints(nonLinuxOnly) \
	[expr {![string equal Linux $tcl_platform(os)]}]
d32 3
a34 7
test cmdMZ-1.4 {Tcl_PwdObjCmd: failure} {unixOnly nonLinuxOnly} {
    # We don't want this test to run on Linux because they do a
    # permissions caching trick which causes this to fail.  The
    # caching is incorrect, but we have no control over that.
    set foodir [file join [temporaryDirectory] foo]
    file delete -force $foodir
    file mkdir $foodir
d36 1
a36 1
    cd $foodir
d40 1
a40 1
    file delete -force $foodir
d76 1
a76 1
} {1 {bad argument: should be "source fileName" or "source -rsrc name ?fileName?" or "source -rsrcid id ?fileName?"}}
d83 2
a84 2
test cmdMZ-3.5 {Tcl_SourceObjCmd: error in script} -body {
    set file [makeFile {
d88 3
a90 5
    } source.file]
    set result [list [catch {source $file} msg] $msg $errorInfo]
    removeFile source.file
    set result
} -match glob -result {1 {error in sourced file} {error in sourced file
d93 1
a93 1
    (file "*" line 3)
d95 1
a95 1
"source $file"}}
d97 2
a98 4
    set file [makeFile {list result} source.file]
    set result [source $file]
    removeFile source.file
    set result
d159 1
a159 27

test cmdMZ-5.1 {Tcl_TimeObjCmd: basic format of command} {
    list [catch {time} msg] $msg
} {1 {wrong # args: should be "time command ?count?"}}
test cmdMZ-5.2 {Tcl_TimeObjCmd: basic format of command} {
    list [catch {time a b c} msg] $msg
} {1 {wrong # args: should be "time command ?count?"}}
test cmdMZ-5.3 {Tcl_TimeObjCmd: basic format of command} {
    list [catch {time a b} msg] $msg
} {1 {expected integer but got "b"}}
test cmdMZ-5.4 {Tcl_TimeObjCmd: nothing happens with negative iteration counts} {
    time bogusCmd -12456
} {0 microseconds per iteration}
test cmdMZ-5.5 {Tcl_TimeObjCmd: result format} {
    regexp {^\d+ microseconds per iteration} [time {format 1}]
} 1
test cmdMZ-5.6 {Tcl_TimeObjCmd: slower commands take longer} {
    expr {[lindex [time {after 2}] 0] < [lindex [time {after 1000}] 0]}
} 1
test cmdMZ-5.7 {Tcl_TimeObjCmd: errors generate right trace} {
    list [catch {time {error foo}} msg] $msg $::errorInfo
} {1 foo {foo
    while executing
"error foo"
    invoked from within
"time {error foo}"}}

d166 1
@


1.2
log
@touched all Tcl files to ease next import.
@
text
@@


1.2.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.2.16.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@a19 2
set tcltest::testConstraints(nonLinuxOnly) \
	[expr {![string equal Linux $tcl_platform(os)]}]
d32 3
a34 7
test cmdMZ-1.4 {Tcl_PwdObjCmd: failure} {unixOnly nonLinuxOnly} {
    # We don't want this test to run on Linux because they do a
    # permissions caching trick which causes this to fail.  The
    # caching is incorrect, but we have no control over that.
    set foodir [file join [temporaryDirectory] foo]
    file delete -force $foodir
    file mkdir $foodir
d36 1
a36 1
    cd $foodir
d40 1
a40 1
    file delete -force $foodir
d76 1
a76 1
} {1 {bad argument: should be "source fileName" or "source -rsrc name ?fileName?" or "source -rsrcid id ?fileName?"}}
d83 2
a84 2
test cmdMZ-3.5 {Tcl_SourceObjCmd: error in script} -body {
    set file [makeFile {
d88 3
a90 5
    } source.file]
    set result [list [catch {source $file} msg] $msg $errorInfo]
    removeFile source.file
    set result
} -match glob -result {1 {error in sourced file} {error in sourced file
d93 1
a93 1
    (file "*" line 3)
d95 1
a95 1
"source $file"}}
d97 2
a98 4
    set file [makeFile {list result} source.file]
    set result [source $file]
    removeFile source.file
    set result
d159 1
a159 27

test cmdMZ-5.1 {Tcl_TimeObjCmd: basic format of command} {
    list [catch {time} msg] $msg
} {1 {wrong # args: should be "time command ?count?"}}
test cmdMZ-5.2 {Tcl_TimeObjCmd: basic format of command} {
    list [catch {time a b c} msg] $msg
} {1 {wrong # args: should be "time command ?count?"}}
test cmdMZ-5.3 {Tcl_TimeObjCmd: basic format of command} {
    list [catch {time a b} msg] $msg
} {1 {expected integer but got "b"}}
test cmdMZ-5.4 {Tcl_TimeObjCmd: nothing happens with negative iteration counts} {
    time bogusCmd -12456
} {0 microseconds per iteration}
test cmdMZ-5.5 {Tcl_TimeObjCmd: result format} {
    regexp {^\d+ microseconds per iteration} [time {format 1}]
} 1
test cmdMZ-5.6 {Tcl_TimeObjCmd: slower commands take longer} {
    expr {[lindex [time {after 2}] 0] < [lindex [time {after 1000}] 0]}
} 1
test cmdMZ-5.7 {Tcl_TimeObjCmd: errors generate right trace} {
    list [catch {time {error foo}} msg] $msg $::errorInfo
} {1 foo {foo
    while executing
"error foo"
    invoked from within
"time {error foo}"}}

d166 1
@


1.1
log
@Initial revision
@
text
@d9 1
d14 1
a14 1
# SCCS: @@(#) cmdMZ.test 1.20 98/01/08 18:23:43
d16 4
a19 1
if {[string compare test [info procs test]] == 1} then {source defs}
d156 1
a156 401
# Tcl_StringObjCmd

test cmdMZ-5.1 {Tcl_StringObjCmd: error conditions} {
    list [catch {string} msg] $msg
} {1 {wrong # args: should be "string option arg ?arg ...?"}}
test cmdMZ-5.2 {Tcl_StringObjCmd: error conditions} {
    list [catch {string gorp a b} msg] $msg
} {1 {bad option "gorp": must be compare, first, index, last, length, match, range, tolower, toupper, trim, trimleft, trimright, wordend, or wordstart}}

test cmdMZ-6.1 {Tcl_StringObjCmd: string compare} {
    list [catch {string compare a} msg] $msg
} {1 {wrong # args: should be "string compare string1 string2"}}
test cmdMZ-6.2 {Tcl_StringObjCmd: string compare} {
    list [catch {string compare a b c} msg] $msg
} {1 {wrong # args: should be "string compare string1 string2"}}
test cmdMZ-6.3 {Tcl_StringObjCmd: string compare} {
    string compare abcde abdef
} -1
test cmdMZ-6.4 {Tcl_StringObjCmd: string compare} {
    string c abcde ABCDE
} 1
test cmdMZ-6.5 {Tcl_StringObjCmd: string compare} {
    string compare abcde abcde
} 0
test cmdMZ-6.6 {Tcl_StringObjCmd: string compare} {
    string compare ab abcde
} -1
test cmdMZ-6.7 {Tcl_StringObjCmd: string compare} {
    string compare abcde ab
} 1
test cmdMZ-6.8 {Tcl_StringObjCmd: string compare} {
    string compare cde ab
} 1
test cmdMZ-6.9 {Tcl_StringObjCmd: string compare} {
    string compare ab cde
} -1
test cmdMZ-6.10 {Tcl_StringObjCmd: string compare, unicode} {
    string compare ab\u7266 ab\u7267
} -1
test cmdMZ-6.11 {Tcl_StringObjCmd: string compare, high bit} {
    # This test will fail if the underlying comparaison
    # is using signed chars instead of unsigned chars.
    # (like SunOS's default memcmp thus the compat/memcmp.c)
    string compare "\x80" "@@"
    # Nb this tests works also in utf8 space because \x80 is
    # translated into a 2 or more bytes but whose first byte has
    # the high bit set.
} 1

test cmdMZ-7.1 {Tcl_StringObjCmd: string first} {
    list [catch {string first a} msg] $msg
} {1 {wrong # args: should be "string first string1 string2"}}
test cmdMZ-7.2 {Tcl_StringObjCmd: string first} {
    list [catch {string first a b c} msg] $msg
} {1 {wrong # args: should be "string first string1 string2"}}
test cmdMZ-7.3 {Tcl_StringObjCmd: string first} {
    string first bq abcdefgbcefgbqrs
} 12
test cmdMZ-7.4 {Tcl_StringObjCmd: string first} {
    string fir bcd abcdefgbcefgbqrs
} 1
test cmdMZ-7.5 {Tcl_StringObjCmd: string first} {
    string f b abcdefgbcefgbqrs
} 1
test cmdMZ-7.6 {Tcl_StringObjCmd: string first} {
    string first xxx x123xx345xxx789xxx012
} 9
test cmdMZ-7.7 {Tcl_StringObjCmd: string first} {
    string first "" x123xx345xxx789xxx012
} -1
test cmdMZ-7.8 {Tcl_StringObjCmd: string first, unicode} {
    string first x abc\u7266x
} 4
test cmdMZ-7.9 {Tcl_StringObjCmd: string first, unicode} {
    string first \u7266 abc\u7266x
} 3

test cmdMZ-8.1 {Tcl_StringObjCmd: string index} {
    list [catch {string index} msg] $msg
} {1 {wrong # args: should be "string index string charIndex"}}
test cmdMZ-8.2 {Tcl_StringObjCmd: string index} {
    list [catch {string index a b c} msg] $msg
} {1 {wrong # args: should be "string index string charIndex"}}
test cmdMZ-8.3 {Tcl_StringObjCmd: string index} {
    list [catch {string index a xyz} msg] $msg
} {1 {expected integer but got "xyz"}}
test cmdMZ-8.4 {Tcl_StringObjCmd: string index} {
    string index abcde 0
} a
test cmdMZ-8.5 {Tcl_StringObjCmd: string index} {
    string i abcde 4
} e
test cmdMZ-8.6 {Tcl_StringObjCmd: string index} {
    string index abcde 5
} {}
test cmdMZ-8.7 {Tcl_StringObjCmd: string index} {
    list [catch {string index abcde -10} msg] $msg
} {0 {}}
test cmdMZ-8.8 {Tcl_StringObjCmd: string index, unicode} {
    string index abc\u7266d 4
} d
test cmdMZ-8.9 {Tcl_StringObjCmd: string index, unicode} {
    string index abc\u7266d 3
} \u7266

test cmdMZ-9.1 {Tcl_StringObjCmd: string last} {
    list [catch {string last a} msg] $msg
} {1 {wrong # args: should be "string last string1 string2"}}
test cmdMZ-9.2 {Tcl_StringObjCmd: string last} {
    list [catch {string last a b c} msg] $msg
} {1 {wrong # args: should be "string last string1 string2"}}
test cmdMZ-9.3 {Tcl_StringObjCmd: string last} {
    string la xxx xxxx123xx345x678
} 1
test cmdMZ-9.4 {Tcl_StringObjCmd: string last} {
    string last xx xxxx123xx345x678
} 7
test cmdMZ-9.5 {Tcl_StringObjCmd: string last} {
    string las x xxxx123xx345x678
} 12
test cmdMZ-9.6 {Tcl_StringObjCmd: string last, unicode} {
    string las x xxxx12\u7266xx345x678
} 12
test cmdMZ-9.7 {Tcl_StringObjCmd: string last, unicode} {
    string las \u7266 xxxx12\u7266xx345x678
} 6

test cmdMZ-10.1 {Tcl_StringObjCmd: string length} {
    list [catch {string length} msg] $msg
} {1 {wrong # args: should be "string length string"}}
test cmdMZ-10.2 {Tcl_StringObjCmd: string length} {
    list [catch {string length a b} msg] $msg
} {1 {wrong # args: should be "string length string"}}
test cmdMZ-10.3 {Tcl_StringObjCmd: string length} {
    string length "a little string"
} 15
test cmdMZ-10.4 {Tcl_StringObjCmd: string length} {
    string le ""
} 0
test cmdMZ-10.5 {Tcl_StringObjCmd: string length, unicode} {
    string le "abcd\u7266"
} 5

test cmdMZ-11.1 {Tcl_StringObjCmd: string match} {
    list [catch {string match a} msg] $msg
} {1 {wrong # args: should be "string match pattern string"}}
test cmdMZ-11.2 {Tcl_StringObjCmd: string match} {
    list [catch {string match a b c} msg] $msg
} {1 {wrong # args: should be "string match pattern string"}}
test cmdMZ-11.3 {Tcl_StringObjCmd: string match} {
    string match abc abc
} 1
test cmdMZ-11.4 {Tcl_StringObjCmd: string match} {
    string m abc abd
} 0

test cmdMZ-12.1 {Tcl_StringObjCmd: string range} {
    list [catch {string range} msg] $msg
} {1 {wrong # args: should be "string range string first last"}}
test cmdMZ-12.2 {Tcl_StringObjCmd: string range} {
    list [catch {string range a 1} msg] $msg
} {1 {wrong # args: should be "string range string first last"}}
test cmdMZ-12.3 {Tcl_StringObjCmd: string range} {
    list [catch {string range a 1 2 3} msg] $msg
} {1 {wrong # args: should be "string range string first last"}}
test cmdMZ-12.4 {Tcl_StringObjCmd: string range} {
    list [catch {string range abc abc 1} msg] $msg
} {1 {bad index "abc": must be integer or "end"}}
test cmdMZ-12.5 {Tcl_StringObjCmd: string range} {
    list [catch {string range abc 1 eof} msg] $msg
} {1 {bad index "eof": must be integer or "end"}}
test cmdMZ-12.6 {Tcl_StringObjCmd: string range, first < 0} {
    string range abcdefghijklmnop -3 2
} {abc}
test cmdMZ-12.7 {Tcl_StringObjCmd: string range} {
    string range abcdefghijklmnop 2 14
} {cdefghijklmno}
test cmdMZ-12.8 {Tcl_StringObjCmd: string range, last > length} {
    string range abcdefghijklmnop 7 1000
} {hijklmnop}
test cmdMZ-12.9 {Tcl_StringObjCmd: string range} {
    string range abcdefghijklmnop 10 e
} {klmnop}
test cmdMZ-12.10 {Tcl_StringObjCmd: string range, last < first} {
    string range abcdefghijklmnop 10 9
} {}
test cmdMZ-12.11 {Tcl_StringObjCmd: string range} {
    string range abcdefghijklmnop -3 -2
} {}
test cmdMZ-12.12 {Tcl_StringObjCmd: string range} {
    string range abcdefghijklmnop 1000 1010
} {}
test cmdMZ-12.13 {Tcl_StringObjCmd: string range} {
    string range abcdefghijklmnop -100 end
} {abcdefghijklmnop}
test cmdMZ-12.14 {Tcl_StringObjCmd: string range} {
    string range abcdefghijklmnop end end
} {p}
test cmdMZ-12.15 {Tcl_StringObjCmd: string range} {
    string range abcdefghijklmnop e 1000
} {p}
test cmdMZ-12.16 {Tcl_StringObjCmd: string range, unicode} {
    string range ab\u7266cdefghijklmnop 5 5
} e
test cmdMZ-12.17 {Tcl_StringObjCmd: string range, unicode} {
    string range ab\u7266cdefghijklmnop 2 3
} \u7266c

test cmdMZ-13.1 {Tcl_StringObjCmd: string tolower} {
    list [catch {string tolower} msg] $msg
} {1 {wrong # args: should be "string tolower string"}}
test cmdMZ-13.2 {Tcl_StringObjCmd: string tolower} {
    list [catch {string tolower a b} msg] $msg
} {1 {wrong # args: should be "string tolower string"}}
test cmdMZ-13.3 {Tcl_StringObjCmd: string tolower} {
    string tolower ABCDeF
} {abcdef}
test cmdMZ-13.4 {Tcl_StringObjCmd: string tolower} {
    string tolower "ABC  XyZ"
} {abc  xyz}
test cmdMZ-13.5 {Tcl_StringObjCmd: string tolower} {
    string tolower {123#$&*()}
} {123#$&*()}
test cmdMZ-13.6 {Tcl_StringObjCmd: string tolower, unicode} {hasIsoLocale} {
    set_iso8859_1_locale
    set result [string tolower ABCabc\xc7\xe7]
    restore_locale
    set result
} "abcabc\xe7\xe7"

test cmdMZ-14.1 {Tcl_StringObjCmd: string toupper} {
    list [catch {string toupper} msg] $msg
} {1 {wrong # args: should be "string toupper string"}}
test cmdMZ-14.2 {Tcl_StringObjCmd: string toupper} {
    list [catch {string toupper a b} msg] $msg
} {1 {wrong # args: should be "string toupper string"}}
test cmdMZ-14.3 {Tcl_StringObjCmd: string toupper} {
    string toupper abCDEf
} {ABCDEF}
test cmdMZ-14.4 {Tcl_StringObjCmd: string toupper} {
    string toupper "abc xYz"
} {ABC XYZ}
test cmdMZ-14.5 {Tcl_StringObjCmd: string toupper} {
    string toupper {123#$&*()}
} {123#$&*()}
test cmdMZ-14.6 {Tcl_StringObjCmd: string toupper, unicode} {hasIsoLocale} {
    set_iso8859_1_locale
    set result [string toupper ABCabc\xc7\xe7]
    restore_locale
    set result
} "ABCABC\xc7\xc7"

test cmdMZ-15.1 {Tcl_StringObjCmd: string trim} {
    list [catch {string trim} msg] $msg
} {1 {wrong # args: should be "string trim string ?chars?"}}
test cmdMZ-15.2 {Tcl_StringObjCmd: string trim} {
    list [catch {string trim a b c} msg] $msg
} {1 {wrong # args: should be "string trim string ?chars?"}}
test cmdMZ-15.3 {Tcl_StringObjCmd: string trim} {
    string trim "    XYZ      "
} {XYZ}
test cmdMZ-15.4 {Tcl_StringObjCmd: string trim} {
    string trim "\t\nXYZ\t\n\r\n"
} {XYZ}
test cmdMZ-15.5 {Tcl_StringObjCmd: string trim} {
    string trim "  A XYZ A    "
} {A XYZ A}
test cmdMZ-15.6 {Tcl_StringObjCmd: string trim} {
    string trim "XXYYZZABC XXYYZZ" ZYX
} {ABC }
test cmdMZ-15.7 {Tcl_StringObjCmd: string trim} {
    string trim "    \t\r      "
} {}
test cmdMZ-15.8 {Tcl_StringObjCmd: string trim} {
    string trim {abcdefg} {}
} {abcdefg}
test cmdMZ-15.9 {Tcl_StringObjCmd: string trim} {
    string trim {}
} {}
test cmdMZ-15.10 {Tcl_StringObjCmd: string trim} {
    string trim ABC DEF
} {ABC}
test cmdMZ-15.11 {Tcl_StringObjCmd: string trim, unicode} {
    string trim "\xe7\xe8 AB\xe7C \xe8\xe7" \xe7\xe8
} " AB\xe7C "

test cmdMZ-16.1 {Tcl_StringObjCmd: string trimleft} {
    string trimleft "    XYZ      "
} {XYZ      }
test cmdMZ-16.2 {Tcl_StringObjCmd: string trimleft} {
    list [catch {string trimleft} msg] $msg
} {1 {wrong # args: should be "string trimleft string ?chars?"}}
test cmdMZ-16.3 {Tcl_StringObjCmd: string trimleft} {
    string length [string trimleft " "]
} {0}

test cmdMZ-17.1 {Tcl_StringObjCmd: string trimright} {
    string trimright "    XYZ      "
} {    XYZ}
test cmdMZ-17.2 {Tcl_StringObjCmd: string trimright} {
    string trimright "   "
} {}
test cmdMZ-17.3 {Tcl_StringObjCmd: string trimright} {
    string trimright ""
} {}
test cmdMZ-17.4 {Tcl_StringObjCmd: string trimright errors} {
    list [catch {string trimright} msg] $msg
} {1 {wrong # args: should be "string trimright string ?chars?"}}
test cmdMZ-17.5 {Tcl_StringObjCmd: string trimright errors} {
    list [catch {string trimg a} msg] $msg
} {1 {bad option "trimg": must be compare, first, index, last, length, match, range, tolower, toupper, trim, trimleft, trimright, wordend, or wordstart}}

test cmdMZ-18.1 {Tcl_StringObjCmd: string wordend} {
    list [catch {string wordend a} msg] $msg
} {1 {wrong # args: should be "string wordend string index"}}
test cmdMZ-18.2 {Tcl_StringObjCmd: string wordend} {
    list [catch {string wordend a b c} msg] $msg
} {1 {wrong # args: should be "string wordend string index"}}
test cmdMZ-18.3 {Tcl_StringObjCmd: string wordend} {
    list [catch {string wordend a gorp} msg] $msg
} {1 {expected integer but got "gorp"}}
test cmdMZ-18.4 {Tcl_StringObjCmd: string wordend} {
    string wordend abc. -1
} 3
test cmdMZ-18.5 {Tcl_StringObjCmd: string wordend} {
    string wordend abc. 100
} 4
test cmdMZ-18.6 {Tcl_StringObjCmd: string wordend} {
    string wordend "word_one two three" 2
} 8
test cmdMZ-18.7 {Tcl_StringObjCmd: string wordend} {
    string wordend "one .&# three" 5
} 6
test cmdMZ-18.8 {Tcl_StringObjCmd: string wordend} {
    string worde "x.y" 0
} 1
test cmdMZ-18.9 {Tcl_StringObjCmd: string wordend, unicode} {hasIsoLocale} {
    set_iso8859_1_locale
    set result [string wordend "xyz\u00c7de fg" 0]
    restore_locale
    set result
} 6
test cmdMZ-18.10 {Tcl_StringObjCmd: string wordend, unicode} {hasIsoLocale} {
    set_iso8859_1_locale
    set result [string wordend "xyz\uc700de fg" 0]
    restore_locale
    set result
} 3
test cmdMZ-18.11 {Tcl_StringObjCmd: string wordend, unicode} {hasIsoLocale} {
    set_iso8859_1_locale
    set result [string wordend "xyz\uc700de fg" 0]
    restore_locale
    set result
} 3
test cmdMZ-18.12 {Tcl_StringObjCmd: string wordend, unicode} {
    string wordend "\uc700\uc700 abc" 8
} 6

test cmdMZ-19.1 {Tcl_StringObjCmd: string wordstart} {
    list [catch {string word a} msg] $msg
} {1 {ambiguous option "word": must be compare, first, index, last, length, match, range, tolower, toupper, trim, trimleft, trimright, wordend, or wordstart}}
test cmdMZ-19.2 {Tcl_StringObjCmd: string wordstart} {
    list [catch {string wordstart a} msg] $msg
} {1 {wrong # args: should be "string wordstart string index"}}
test cmdMZ-19.3 {Tcl_StringObjCmd: string wordstart} {
    list [catch {string wordstart a b c} msg] $msg
} {1 {wrong # args: should be "string wordstart string index"}}
test cmdMZ-19.4 {Tcl_StringObjCmd: string wordstart} {
    list [catch {string wordstart a gorp} msg] $msg
} {1 {expected integer but got "gorp"}}
test cmdMZ-19.5 {Tcl_StringObjCmd: string wordstart} {
    string wordstart "one two three_words" 400
} 8
test cmdMZ-19.6 {Tcl_StringObjCmd: string wordstart} {
    string wordstart "one two three_words" 2
} 0
test cmdMZ-19.7 {Tcl_StringObjCmd: string wordstart} {
    string wordstart "one two three_words" -2
} 0
test cmdMZ-19.8 {Tcl_StringObjCmd: string wordstart} {
    string wordstart "one .*&^ three" 6
} 6
test cmdMZ-19.9 {Tcl_StringObjCmd: string wordstart} {
    string wordstart "one two three" 4
} 4
test cmdMZ-19.10 {Tcl_StringObjCmd: string wordstart, unicode} {hasIsoLocale} {
    set_iso8859_1_locale
    set result [string wordstart "one tw\u00c7o three" 7]
    restore_locale
    set result
} 4
test cmdMZ-19.11 {Tcl_StringObjCmd: string wordstart, unicode} {hasIsoLocale} {
    set_iso8859_1_locale
    set result [string wordstart "ab\uc700\uc700 cdef ghi" 12]
    restore_locale
    set result
} 10
test cmdMZ-19.12 {Tcl_StringObjCmd: string wordstart, unicode} {
    string wordstart "\uc700\uc700 abc" 8
} 3

d163 2
d166 1
@


1.1.1.1
log
@import dejagnu-1999-11-08 snapshot
@
text
@@


1.1.1.2
log
@Tcl 8.3 upgrade
@
text
@a8 1
# Copyright (c) 1998-1999 by Scriptics Corporation.
d13 1
a13 1
# RCS: @@(#) $Id: cmdMZ.test,v 1.6.8.2 2000/09/15 16:56:07 spolk Exp $
d15 1
a15 4
if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import -force ::tcltest::*
}
d152 401
a552 1
# The tests for Tcl_StringObjCmd are in string.test
a558 2
# cleanup
::tcltest::cleanupTests
a559 1

@


1.1.1.3
log
@import tcl 8.4.0
@
text
@d14 1
a14 1
# RCS: @@(#) $Id: cmdMZ.test,v 1.13 2002/07/19 08:52:27 dkf Exp $
a19 2
set tcltest::testConstraints(nonLinuxOnly) \
	[expr {![string equal Linux $tcl_platform(os)]}]
d32 3
a34 7
test cmdMZ-1.4 {Tcl_PwdObjCmd: failure} {unixOnly nonLinuxOnly} {
    # We don't want this test to run on Linux because they do a
    # permissions caching trick which causes this to fail.  The
    # caching is incorrect, but we have no control over that.
    set foodir [file join [temporaryDirectory] foo]
    file delete -force $foodir
    file mkdir $foodir
d36 1
a36 1
    cd $foodir
d40 1
a40 1
    file delete -force $foodir
d76 1
a76 1
} {1 {bad argument: should be "source fileName" or "source -rsrc name ?fileName?" or "source -rsrcid id ?fileName?"}}
d83 2
a84 2
test cmdMZ-3.5 {Tcl_SourceObjCmd: error in script} -body {
    set file [makeFile {
d88 3
a90 5
    } source.file]
    set result [list [catch {source $file} msg] $msg $errorInfo]
    removeFile source.file
    set result
} -match glob -result {1 {error in sourced file} {error in sourced file
d93 1
a93 1
    (file "*" line 3)
d95 1
a95 1
"source $file"}}
d97 2
a98 4
    set file [makeFile {list result} source.file]
    set result [source $file]
    removeFile source.file
    set result
d159 1
a159 27

test cmdMZ-5.1 {Tcl_TimeObjCmd: basic format of command} {
    list [catch {time} msg] $msg
} {1 {wrong # args: should be "time command ?count?"}}
test cmdMZ-5.2 {Tcl_TimeObjCmd: basic format of command} {
    list [catch {time a b c} msg] $msg
} {1 {wrong # args: should be "time command ?count?"}}
test cmdMZ-5.3 {Tcl_TimeObjCmd: basic format of command} {
    list [catch {time a b} msg] $msg
} {1 {expected integer but got "b"}}
test cmdMZ-5.4 {Tcl_TimeObjCmd: nothing happens with negative iteration counts} {
    time bogusCmd -12456
} {0 microseconds per iteration}
test cmdMZ-5.5 {Tcl_TimeObjCmd: result format} {
    regexp {^\d+ microseconds per iteration} [time {format 1}]
} 1
test cmdMZ-5.6 {Tcl_TimeObjCmd: slower commands take longer} {
    expr {[lindex [time {after 2}] 0] < [lindex [time {after 1000}] 0]}
} 1
test cmdMZ-5.7 {Tcl_TimeObjCmd: errors generate right trace} {
    list [catch {time {error foo}} msg] $msg $::errorInfo
} {1 foo {foo
    while executing
"error foo"
    invoked from within
"time {error foo}"}}

d166 1
@


