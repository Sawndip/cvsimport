head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.58
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.56
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.54
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.52
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.50
	gdb_7_0-branch:1.5.0.48
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tcl8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.46
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.44
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.42
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.40
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.38
	gdb_6_5-2006-05-14-branchpoint:1.5
	readline_5_1-import-branch:1.5.0.36
	readline_5_1-import-branchpoint:1.5
	gdb_6_4-branch:1.5.0.34
	gdb_6_4-2005-11-01-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.32
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	ezannoni_pie-20040323-branch:1.5.0.30
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.28
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.26
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.24
	cagney_x86i386-20030821-branch:1.5.0.22
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.20
	gdb_6_0-2003-06-23-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.18
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.16
	cagney_writestrings-20030508-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.14
	cagney_fileio-20030521-branchpoint:1.5
	carlton_dictionary-20030430-merge:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.12
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.10
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.8
	cagney_lazyid-20030317-branchpoint:1.5
	offbyone-20030313-branch:1.5.0.6
	offbyone-20030313-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.4
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.2
	interps-20030202-branchpoint:1.5
	TCL8_4_1:1.1.1.3
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.2
	TCL_8_4_1:1.1.1.3
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.4
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TCL_8_4_0:1.1.1.3
	carlton_dictionary-branch:1.2.0.16
	carlton_dictionary-20020920-branchpoint:1.2
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.14
	gdb_5_3-branch:1.2.0.12
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.10
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.8
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.6
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TCL_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	dejagnu-2000-02-04:1.1.1.1
	dejagnu-2000-01-31:1.1.1.1
	dejagnu-2000-01-24:1.1.1.1
	dejagnu-2000-01-17:1.1.1.1
	dejagnu-2000-01-10:1.1.1.1
	dejagnu-2000-01-04:1.1.1.1
	dejagnu-1999-12-21:1.1.1.1
	dejagnu-1999-12-13:1.1.1.1
	dejagnu-1999-12-07:1.1.1.1
	dejagnu-1999-12-06:1.1.1.1
	dejagnu-1999-11-15:1.1.1.1
	dejagnu-1999-11-08:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2003.01.21.19.40.14;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.26.19.48.00;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.37.07;	author kseitz;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2001.09.09.23.56.08;	author irox;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2002.09.27.21.49.10;	author kseitz;	state Exp;
branches;
next	;

1.3.4.1
date	2003.12.14.20.28.49;	author drow;	state Exp;
branches;
next	;

1.2.16.1
date	2002.12.23.19.40.38;	author carlton;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2003.02.07.19.18.18;	author carlton;	state Exp;
branches;
next	;

1.1.1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.09.22.40.58;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.19.56.34;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tcl 8.4.1
@
text
@# Commands covered:  exec
#
# This file contains a collection of tests for one or more of the Tcl
# built-in commands.  Sourcing this file into Tcl runs the tests and
# generates output for errors.  No output means no errors were found.
#
# Copyright (c) 1991-1994 The Regents of the University of California.
# Copyright (c) 1994-1997 Sun Microsystems, Inc.
# Copyright (c) 1998-1999 by Scriptics Corporation.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# RCS: @@(#) $Id: exec.test,v 1.14 2002/09/02 19:27:15 hobbs Exp $

package require tcltest 2
namespace import -force ::tcltest::*

# All tests require the "exec" command.
# Skip them if exec is not defined.
testConstraint exec [llength [info commands exec]]

set path(echo) [makeFile {
    puts -nonewline [lindex $argv 0]
    foreach str [lrange $argv 1 end] {
	puts -nonewline " $str"
    }
    puts {}
    exit
} echo]

set path(cat) [makeFile {
    if {$argv == {}} {
	set argv -
    }
    foreach name $argv {
	if {$name == "-"} {
	    set f stdin
	} elseif {[catch {open $name r} f] != 0} {
	    puts stderr $f
	    continue
	}
	while {[eof $f] == 0} {
	    puts -nonewline [read $f]
	}
	if {$f != "stdin"} {
	    close $f
	}
    }
    exit
} cat]

set path(wc) [makeFile {
    set data [read stdin]
    set lines [regsub -all "\n" $data {} dummy]
    set words [regsub -all "\[^ \t\n]+" $data {} dummy]
    set chars [string length $data]
    puts [format "%8.d%8.d%8.d" $lines $words $chars]
    exit
} wc]

set path(sh) [makeFile {
    if {[lindex $argv 0] != "-c"} {
	error "sh: unexpected arguments $argv"
    }
    set cmd [lindex $argv 1]
    lappend cmd ";"

    set newcmd {}
    
    foreach arg $cmd {
	if {$arg == ";"} {
	    eval exec >@@stdout 2>@@stderr [list [info nameofexecutable]] $newcmd
	    set newcmd {}
	    continue
	}
	if {$arg == "1>&2"} {
	    set arg >@@stderr
	}
	lappend newcmd $arg
    }
    exit
} sh]

set path(sleep) [makeFile {
    after [expr $argv*1000]
    exit
} sleep]

set path(exit) [makeFile {
    exit $argv
} exit]

# Basic operations.

test exec-1.1 {basic exec operation} {exec} {
    exec [interpreter] $path(echo) a b c
} "a b c"
test exec-1.2 {pipelining} {exec stdio} {
    exec [interpreter] $path(echo) a b c d | [interpreter] $path(cat) | [interpreter] $path(cat)
} "a b c d"
test exec-1.3 {pipelining} {exec stdio} {
    set a [exec [interpreter] $path(echo) a b c d | [interpreter] $path(cat) | [interpreter] $path(wc)]
    list [scan $a "%d %d %d" b c d] $b $c
} {3 1 4}
set arg {12345678901234567890123456789012345678901234567890}
set arg "$arg$arg$arg$arg$arg$arg"
test exec-1.4 {long command lines} {exec} {
    exec [interpreter] $path(echo) $arg
} $arg
set arg {}

# I/O redirection: input from Tcl command.

test exec-2.1 {redirecting input from immediate source} {exec stdio} {
    exec [interpreter] $path(cat) << "Sample text"
} {Sample text}
test exec-2.2 {redirecting input from immediate source} {exec stdio} {
    exec << "Sample text" [interpreter] $path(cat) | [interpreter] $path(cat)
} {Sample text}
test exec-2.3 {redirecting input from immediate source} {exec stdio} {
    exec [interpreter] $path(cat) << "Sample text" | [interpreter] $path(cat)
} {Sample text}
test exec-2.4 {redirecting input from immediate source} {exec stdio} {
    exec [interpreter] $path(cat) | [interpreter] $path(cat) << "Sample text"
} {Sample text}
test exec-2.5 {redirecting input from immediate source} {exec} {
    exec [interpreter] $path(cat) "<<Joined to arrows"
} {Joined to arrows}
test exec-2.6 {redirecting input from immediate source, with UTF} {exec} {
    # If this fails, it may give back:
    # "\uC3\uA9\uC3\uA0\uC3\uBC\uC3\uB1"
    # If it does, this means that the UTF -> external conversion did not 
    # occur before writing out the temp file.
    exec [interpreter] $path(cat) << "\uE9\uE0\uFC\uF1"
} "\uE9\uE0\uFC\uF1"

# I/O redirection: output to file.

set path(gorp.file) [makeFile {} gorp.file]
removeFile gorp.file

test exec-3.1 {redirecting output to file} {exec} {
    exec [interpreter] $path(echo) "Some simple words" > $path(gorp.file)
    exec [interpreter] $path(cat) $path(gorp.file)
} "Some simple words"
test exec-3.2 {redirecting output to file} {exec stdio} {
    exec [interpreter] $path(echo) "More simple words" | >$path(gorp.file) [interpreter] $path(cat) | [interpreter] $path(cat)
    exec [interpreter] $path(cat) $path(gorp.file)
} "More simple words"
test exec-3.3 {redirecting output to file} {exec stdio} {
    exec > $path(gorp.file) [interpreter] $path(echo) "Different simple words" | [interpreter] $path(cat) | [interpreter] $path(cat)
    exec [interpreter] $path(cat) $path(gorp.file)
} "Different simple words"
test exec-3.4 {redirecting output to file} {exec} {
    exec [interpreter] $path(echo) "Some simple words" >$path(gorp.file)
    exec [interpreter] $path(cat) $path(gorp.file)
} "Some simple words"
test exec-3.5 {redirecting output to file} {exec} {
    exec [interpreter] $path(echo) "First line" >$path(gorp.file)
    exec [interpreter] $path(echo) "Second line" >> $path(gorp.file)
    exec [interpreter] $path(cat) $path(gorp.file)
} "First line\nSecond line"
test exec-3.6 {redirecting output to file} {exec} {
    exec [interpreter] $path(echo) "First line" >$path(gorp.file)
    exec [interpreter] $path(echo) "Second line" >>$path(gorp.file)
    exec [interpreter] $path(cat) $path(gorp.file)
} "First line\nSecond line"
test exec-3.7 {redirecting output to file} {exec} {
    set f [open $path(gorp.file) w]
    puts $f "Line 1"
    flush $f
    exec [interpreter] $path(echo) "More text" >@@ $f
    exec [interpreter] $path(echo) >@@$f "Even more"
    puts $f "Line 3"
    close $f
    exec [interpreter] $path(cat) $path(gorp.file)
} "Line 1\nMore text\nEven more\nLine 3"

# I/O redirection: output and stderr to file.

removeFile gorp.file

test exec-4.1 {redirecting output and stderr to file} {exec} {
    exec [interpreter] $path(echo) "test output" >& $path(gorp.file)
    exec [interpreter] $path(cat) $path(gorp.file)
} "test output"
test exec-4.2 {redirecting output and stderr to file} {exec} {
    list [exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" >&$path(gorp.file)] \
	    [exec [interpreter] $path(cat) $path(gorp.file)]
} {{} {foo bar}}
test exec-4.3 {redirecting output and stderr to file} {exec} {
    exec [interpreter] $path(echo) "first line" > $path(gorp.file)
    list [exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" >>&$path(gorp.file)] \
	    [exec [interpreter] $path(cat) $path(gorp.file)]
} "{} {first line\nfoo bar}"
test exec-4.4 {redirecting output and stderr to file} {exec} {
    set f [open $path(gorp.file) w]
    puts $f "Line 1"
    flush $f
    exec [interpreter] $path(echo) "More text" >&@@ $f
    exec [interpreter] $path(echo) >&@@$f "Even more"
    puts $f "Line 3"
    close $f
    exec [interpreter] $path(cat) $path(gorp.file)
} "Line 1\nMore text\nEven more\nLine 3"
test exec-4.5 {redirecting output and stderr to file} {exec} {
    set f [open $path(gorp.file) w]
    puts $f "Line 1"
    flush $f
    exec >&@@ $f [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2"
    exec >&@@$f [interpreter] $path(sh) -c "$path(echo) xyzzy 1>&2"
    puts $f "Line 3"
    close $f
    exec [interpreter] $path(cat) $path(gorp.file)
} "Line 1\nfoo bar\nxyzzy\nLine 3"

# I/O redirection: input from file.

if { [set ::tcltest::testConstraints(exec)] } {
exec [interpreter] $path(echo) "Just a few thoughts" > $path(gorp.file)
}
test exec-5.1 {redirecting input from file} {exec} {
    exec [interpreter] $path(cat) < $path(gorp.file)
} {Just a few thoughts}
test exec-5.2 {redirecting input from file} {exec stdio} {
    exec [interpreter] $path(cat) | [interpreter] $path(cat) < $path(gorp.file)
} {Just a few thoughts}
test exec-5.3 {redirecting input from file} {exec stdio} {
    exec [interpreter] $path(cat) < $path(gorp.file) | [interpreter] $path(cat)
} {Just a few thoughts}
test exec-5.4 {redirecting input from file} {exec stdio} {
    exec < $path(gorp.file) [interpreter] $path(cat) | [interpreter] $path(cat)
} {Just a few thoughts}
test exec-5.5 {redirecting input from file} {exec} {
    exec [interpreter] $path(cat) <$path(gorp.file)
} {Just a few thoughts}
test exec-5.6 {redirecting input from file} {exec} {
    set f [open $path(gorp.file) r]
    set result [exec [interpreter] $path(cat) <@@ $f]
    close $f
    set result
} {Just a few thoughts}
test exec-5.7 {redirecting input from file} {exec} {
    set f [open $path(gorp.file) r]
    set result [exec <@@$f [interpreter] $path(cat)]
    close $f
    set result
} {Just a few thoughts}

# I/O redirection: standard error through a pipeline.

test exec-6.1 {redirecting stderr through a pipeline} {exec stdio} {
    exec [interpreter] $path(sh) -c "$path(echo) foo bar" |& [interpreter] $path(cat)
} "foo bar"
test exec-6.2 {redirecting stderr through a pipeline} {exec stdio} {
    exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" |& [interpreter] $path(cat)
} "foo bar"
test exec-6.3 {redirecting stderr through a pipeline} {exec stdio} {
    exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" \
	|& [interpreter] $path(sh) -c "$path(echo) second msg 1>&2 ; $path(cat)" |& [interpreter] $path(cat)
} "second msg\nfoo bar"

# I/O redirection: combinations.

set path(gorp.file2) [makeFile {} gorp.file2]
removeFile gorp.file2

test exec-7.1 {multiple I/O redirections} {exec} {
    exec << "command input" > $path(gorp.file2) [interpreter] $path(cat) < $path(gorp.file)
    exec [interpreter] $path(cat) $path(gorp.file2)
} {Just a few thoughts}
test exec-7.2 {multiple I/O redirections} {exec} {
    exec < $path(gorp.file) << "command input" [interpreter] $path(cat)
} {command input}

# Long input to command and output from command.

set a "0123456789 xxxxxxxxx abcdefghi ABCDEFGHIJK\n"
set a [concat $a $a $a $a]
set a [concat $a $a $a $a]
set a [concat $a $a $a $a]
set a [concat $a $a $a $a]
test exec-8.1 {long input and output} {exec} {
    exec [interpreter] $path(cat) << $a
} $a

# More than 20 arguments to exec.

test exec-8.2 {long input and output} {exec} {
    exec [interpreter] $path(echo) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
} {1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23}

# Commands that return errors.

test exec-9.1 {commands returning errors} {exec} {
    set x [catch {exec gorp456} msg]
    list $x [string tolower $msg] [string tolower $errorCode]
} {1 {couldn't execute "gorp456": no such file or directory} {posix enoent {no such file or directory}}}
test exec-9.2 {commands returning errors} {exec} {
    string tolower [list [catch {exec [interpreter] echo foo | foo123} msg] $msg $errorCode]
} {1 {couldn't execute "foo123": no such file or directory} {posix enoent {no such file or directory}}}
test exec-9.3 {commands returning errors} {exec stdio} {
    list [catch {exec [interpreter] $path(sleep) 1 | [interpreter] $path(exit) 43 | [interpreter] $path(sleep) 1} msg] $msg
} {1 {child process exited abnormally}}
test exec-9.4 {commands returning errors} {exec stdio} {
    list [catch {exec [interpreter] $path(exit) 43 | [interpreter] $path(echo) "foo bar"} msg] $msg
} {1 {foo bar
child process exited abnormally}}
test exec-9.5 {commands returning errors} {exec stdio} {
    list [catch {exec gorp456 | [interpreter] echo a b c} msg] [string tolower $msg]
} {1 {couldn't execute "gorp456": no such file or directory}}
test exec-9.6 {commands returning errors} {exec} {
    list [catch {exec [interpreter] $path(sh) -c "$path(echo) error msg 1>&2"} msg] $msg
} {1 {error msg}}
test exec-9.7 {commands returning errors} {exec stdio} {
    list [catch {exec [interpreter] $path(sh) -c "$path(echo) error msg 1>&2" \
		     | [interpreter] $path(sh) -c "$path(echo) error msg 1>&2"} msg] $msg
} {1 {error msg
error msg}}

set path(err) [makeFile {} err]

test exec-9.8 {commands returning errors} {exec} {
    set f [open $path(err) w]
    puts $f {
	puts stdout out
	puts stderr err
    }
    close $f
    list [catch {exec [interpreter] $path(err)} msg] $msg
} {1 {out
err}}

# Errors in executing the Tcl command, as opposed to errors in the
# processes that are invoked.

test exec-10.1 {errors in exec invocation} {exec} {
    list [catch {exec} msg] $msg
} {1 {wrong # args: should be "exec ?switches? arg ?arg ...?"}}
test exec-10.2 {errors in exec invocation} {exec} {
    list [catch {exec | cat} msg] $msg
} {1 {illegal use of | or |& in command}}
test exec-10.3 {errors in exec invocation} {exec} {
    list [catch {exec cat |} msg] $msg
} {1 {illegal use of | or |& in command}}
test exec-10.4 {errors in exec invocation} {exec} {
    list [catch {exec cat | | cat} msg] $msg
} {1 {illegal use of | or |& in command}}
test exec-10.5 {errors in exec invocation} {exec} {
    list [catch {exec cat | |& cat} msg] $msg
} {1 {illegal use of | or |& in command}}
test exec-10.6 {errors in exec invocation} {exec} {
    list [catch {exec cat |&} msg] $msg
} {1 {illegal use of | or |& in command}}
test exec-10.7 {errors in exec invocation} {exec} {
    list [catch {exec cat <} msg] $msg
} {1 {can't specify "<" as last word in command}}
test exec-10.8 {errors in exec invocation} {exec} {
    list [catch {exec cat >} msg] $msg
} {1 {can't specify ">" as last word in command}}
test exec-10.9 {errors in exec invocation} {exec} {
    list [catch {exec cat <<} msg] $msg
} {1 {can't specify "<<" as last word in command}}
test exec-10.10 {errors in exec invocation} {exec} {
    list [catch {exec cat >>} msg] $msg
} {1 {can't specify ">>" as last word in command}}
test exec-10.11 {errors in exec invocation} {exec} {
    list [catch {exec cat >&} msg] $msg
} {1 {can't specify ">&" as last word in command}}
test exec-10.12 {errors in exec invocation} {exec} {
    list [catch {exec cat >>&} msg] $msg
} {1 {can't specify ">>&" as last word in command}}
test exec-10.13 {errors in exec invocation} {exec} {
    list [catch {exec cat >@@} msg] $msg
} {1 {can't specify ">@@" as last word in command}}
test exec-10.14 {errors in exec invocation} {exec} {
    list [catch {exec cat <@@} msg] $msg
} {1 {can't specify "<@@" as last word in command}}
test exec-10.15 {errors in exec invocation} {exec} {
    list [catch {exec cat < a/b/c} msg] [string tolower $msg]
} {1 {couldn't read file "a/b/c": no such file or directory}}
test exec-10.16 {errors in exec invocation} {exec} {
    list [catch {exec cat << foo > a/b/c} msg] [string tolower $msg]
} {1 {couldn't write file "a/b/c": no such file or directory}}
test exec-10.17 {errors in exec invocation} {exec} {
    list [catch {exec cat << foo > a/b/c} msg] [string tolower $msg]
} {1 {couldn't write file "a/b/c": no such file or directory}}
set f [open $path(gorp.file) w]
test exec-10.18 {errors in exec invocation} {exec} {
    list [catch {exec cat <@@ $f} msg] $msg
} "1 {channel \"$f\" wasn't opened for reading}"
close $f
set f [open $path(gorp.file) r]
test exec-10.19 {errors in exec invocation} {exec} {
    list [catch {exec cat >@@ $f} msg] $msg
} "1 {channel \"$f\" wasn't opened for writing}"
close $f
test exec-10.20 {errors in exec invocation} {exec} {
    list [catch {exec ~non_existent_user/foo/bar} msg] $msg
} {1 {user "non_existent_user" doesn't exist}}
test exec-10.21 {errors in exec invocation} {exec} {
    list [catch {exec [interpreter] true | ~xyzzy_bad_user/x | false} msg] $msg
} {1 {user "xyzzy_bad_user" doesn't exist}}

# Commands in background.

test exec-11.1 {commands in background} {exec} {
    set x [lindex [time {exec [interpreter] $path(sleep) 2 &}] 0]
    expr $x<1000000
} 1
test exec-11.2 {commands in background} {exec} {
    list [catch {exec [interpreter] $path(echo) a &b} msg] $msg
} {0 {a &b}}
test exec-11.3 {commands in background} {exec} {
    llength [exec [interpreter] $path(sleep) 1 &]
} 1
test exec-11.4 {commands in background} {exec stdio} {
    llength [exec [interpreter] $path(sleep) 1 | [interpreter] $path(sleep) 1 | [interpreter] $path(sleep) 1 &]
} 3
test exec-11.5 {commands in background} {exec} {
    set f [open $path(gorp.file) w]
    puts $f [format { catch { exec [info nameofexecutable] %s foo & } } $path(echo)]
    close $f
    string compare "foo" [exec [interpreter] $path(gorp.file)]
} 0

# Make sure that background commands are properly reaped when
# they eventually die.

if { [set ::tcltest::testConstraints(exec)] } {
exec [interpreter] $path(sleep) 3
}
test exec-12.1 {reaping background processes} \
	{exec unixOnly nonPortable} {
    for {set i 0} {$i < 20} {incr i} {
	exec echo foo > /dev/null &
    }
    exec sleep 1
    catch {exec ps | fgrep "echo foo" | fgrep -v fgrep | wc} msg
    lindex $msg 0
} 0
test exec-12.2 {reaping background processes} \
	{exec unixOnly nonPortable} {
    exec sleep 2 | sleep 2 | sleep 2 &
    catch {exec ps | fgrep -i "sleep" | fgrep -i -v fgrep | wc} msg
    set x [lindex $msg 0]
    exec sleep 3
    catch {exec ps | fgrep -i "sleep" | fgrep -i -v fgrep | wc} msg
    list $x [lindex $msg 0]
} {3 0}
test exec-12.3 {reaping background processes} \
	{exec unixOnly nonPortable} {
    exec sleep 1000 &
    exec sleep 1000 &
    set x [exec ps | fgrep "sleep" | fgrep -v fgrep]
    set pids {}
    foreach i [split $x \n] {
	lappend pids [lindex $i 0]
    }
    foreach i $pids {
	catch {exec kill -STOP $i}
    }
    catch {exec ps | fgrep "sleep" | fgrep -v fgrep | wc} msg
    set x [lindex $msg 0]

    foreach i $pids {
	catch {exec kill -KILL $i}
    }
    catch {exec ps | fgrep "sleep" | fgrep -v fgrep | wc} msg
    list $x [lindex $msg 0]
} {2 0}

# Make sure "errorCode" is set correctly.

test exec-13.1 {setting errorCode variable} {exec} {
    list [catch {exec [interpreter] $path(cat) < a/b/c} msg] [string tolower $errorCode]
} {1 {posix enoent {no such file or directory}}}
test exec-13.2 {setting errorCode variable} {exec} {
    list [catch {exec [interpreter] $path(cat) > a/b/c} msg] [string tolower $errorCode]
} {1 {posix enoent {no such file or directory}}}
test exec-13.3 {setting errorCode variable} {exec} {
    set x [catch {exec _weird_cmd_} msg]
    list $x [string tolower $msg] [lindex $errorCode 0] \
	    [string tolower [lrange $errorCode 2 end]]
} {1 {couldn't execute "_weird_cmd_": no such file or directory} POSIX {{no such file or directory}}}

# Switches before the first argument

test exec-14.1 {-keepnewline switch} {exec} {
    exec -keepnewline [interpreter] $path(echo) foo
} "foo\n"
test exec-14.2 {-keepnewline switch} {exec} {
    list [catch {exec -keepnewline} msg] $msg
} {1 {wrong # args: should be "exec ?switches? arg ?arg ...?"}}
test exec-14.3 {unknown switch} {exec} {
    list [catch {exec -gorp} msg] $msg
} {1 {bad switch "-gorp": must be -keepnewline or --}}
test exec-14.4 {-- switch} {exec} {
    list [catch {exec -- -gorp} msg] [string tolower $msg]
} {1 {couldn't execute "-gorp": no such file or directory}}

# Redirecting standard error separately from standard output

test exec-15.1 {standard error redirection} {exec} {
    exec [interpreter] $path(echo) "First line" > $path(gorp.file)
    list [exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" 2> $path(gorp.file)] \
	    [exec [interpreter] $path(cat) $path(gorp.file)]
} {{} {foo bar}}
test exec-15.2 {standard error redirection} {exec stdio} {
    list [exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" \
		| [interpreter] $path(echo) biz baz >$path(gorp.file) 2> $path(gorp.file2)] \
	    [exec [interpreter] $path(cat) $path(gorp.file)] \
	    [exec [interpreter] $path(cat) $path(gorp.file2)]
} {{} {biz baz} {foo bar}}
test exec-15.3 {standard error redirection} {exec stdio} {
    list [exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" \
	        | [interpreter] $path(echo) biz baz 2>$path(gorp.file) > $path(gorp.file2)] \
	    [exec [interpreter] $path(cat) $path(gorp.file)] \
	    [exec [interpreter] $path(cat) $path(gorp.file2)]
} {{} {foo bar} {biz baz}}
test exec-15.4 {standard error redirection} {exec} {
    set f [open $path(gorp.file) w]
    puts $f "Line 1"
    flush $f
    exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" 2>@@ $f
    puts $f "Line 3"
    close $f
    exec [interpreter] $path(cat) $path(gorp.file)
} {Line 1
foo bar
Line 3}
test exec-15.5 {standard error redirection} {exec} {
    exec [interpreter] $path(echo) "First line" > $path(gorp.file)
    exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" 2>> $path(gorp.file)
    exec [interpreter] $path(cat) $path(gorp.file)
} {First line
foo bar}
test exec-15.6 {standard error redirection} {exec stdio} {
    exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" > $path(gorp.file2) 2> $path(gorp.file) \
	    >& $path(gorp.file) 2> $path(gorp.file2) | [interpreter] $path(echo) biz baz
    list [exec [interpreter] $path(cat) $path(gorp.file)] [exec [interpreter] $path(cat) $path(gorp.file2)]
} {{biz baz} {foo bar}}

test exec-16.1 {flush output before exec} {exec} {
    set f [open $path(gorp.file) w]
    puts $f "First line"
    exec [interpreter] $path(echo) "Second line" >@@ $f
    puts $f "Third line"
    close $f
    exec [interpreter] $path(cat) $path(gorp.file)
} {First line
Second line
Third line}
test exec-16.2 {flush output before exec} {exec} {
    set f [open $path(gorp.file) w]
    puts $f "First line"
    exec [interpreter] << {puts stderr {Second line}} >&@@ $f > $path(gorp.file2)
    puts $f "Third line"
    close $f
    exec [interpreter] $path(cat) $path(gorp.file)
} {First line
Second line
Third line}

set path(script) [makeFile {} script]

test exec-17.1 { inheriting standard I/O } {exec} {
    set f [open $path(script) w]
    puts $f [format {close stdout
	set f [open %s w]
	catch {exec [info nameofexecutable] %s foobar &}
	exec [info nameofexecutable] %s 2
	close $f
    } $path(gorp.file) $path(echo) $path(sleep)]
    close $f
    catch {exec [interpreter] $path(script)} result
    set f [open $path(gorp.file) r]
    lappend result [read $f]
    close $f
    set result
} {{foobar
}}

test exec-18.1 { exec cat deals with weird file names} {exec unixOnly} {
    # This is cross-platform, but the cat isn't predictably correct on
    # Windows.
    set f "foo\[\{blah"
    set path(fooblah) [makeFile {} $f]
    set fout [open $path(fooblah) w]
    puts $fout "contents"
    close $fout
    set res [list [catch {exec cat $path(fooblah)} msg] $msg]
    removeFile $f
    set res
} {0 contents}

# cleanup

foreach file {script gorp.file gorp.file2 echo cat wc sh sleep exit err} {
	removeFile $file
}

::tcltest::cleanupTests
return
@


1.4
log
@touched all sources to ease next import
@
text
@d14 1
a14 1
# RCS: @@(#) $Id: exec.test,v 1.6.8.2 2000/09/15 16:56:20 spolk Exp $
d16 2
a17 4
if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import -force ::tcltest::*
}
d21 1
a21 1
set ::tcltest::testConstraints(execCommandExists) [expr {[info commands exec] != ""}]
d23 1
a23 2
set f [open echo w]
puts $f {
d30 1
a30 2
}
close $f
d32 1
a32 2
set f [open cat w]
puts $f {
d51 1
a51 2
}
close $f
d53 1
a53 2
set f [open wc w]
puts $f {
d60 1
a60 2
}
close $f
d62 1
a62 2
set f [open sh w]
puts $f {
d83 1
a83 2
}
close $f
d85 1
a85 2
set f [open sleep w]
puts $f {
d88 1
a88 2
}
close $f
d90 1
a90 2
set f [open exit w]
puts $f {
d92 1
a92 2
}
close $f
d96 2
a97 2
test exec-1.1 {basic exec operation} {execCommandExists stdio} {
    exec $::tcltest::tcltest echo a b c
d99 2
a100 2
test exec-1.2 {pipelining} {execCommandExists stdio} {
    exec $::tcltest::tcltest echo a b c d | $::tcltest::tcltest cat | $::tcltest::tcltest cat
d102 2
a103 2
test exec-1.3 {pipelining} {execCommandExists stdio} {
    set a [exec $::tcltest::tcltest echo a b c d | $::tcltest::tcltest cat | $::tcltest::tcltest wc]
d108 2
a109 2
test exec-1.4 {long command lines} {execCommandExists stdio} {
    exec $::tcltest::tcltest echo $arg
d115 2
a116 2
test exec-2.1 {redirecting input from immediate source} {execCommandExists stdio} {
    exec $::tcltest::tcltest cat << "Sample text"
d118 2
a119 2
test exec-2.2 {redirecting input from immediate source} {execCommandExists stdio} {
    exec << "Sample text" $::tcltest::tcltest cat | $::tcltest::tcltest cat
d121 2
a122 2
test exec-2.3 {redirecting input from immediate source} {execCommandExists stdio} {
    exec $::tcltest::tcltest cat << "Sample text" | $::tcltest::tcltest cat
d124 2
a125 2
test exec-2.4 {redirecting input from immediate source} {execCommandExists stdio} {
    exec $::tcltest::tcltest cat | $::tcltest::tcltest cat << "Sample text"
d127 2
a128 2
test exec-2.5 {redirecting input from immediate source} {execCommandExists stdio} {
    exec $::tcltest::tcltest cat "<<Joined to arrows"
d130 1
a130 1
test exec-2.6 {redirecting input from immediate source, with UTF} {execCommandExists stdio} {
d135 1
a135 1
    exec $::tcltest::tcltest cat << "\uE9\uE0\uFC\uF1"
d140 6
a145 4
file delete gorp.file
test exec-3.1 {redirecting output to file} {execCommandExists stdio} {
    exec $::tcltest::tcltest echo "Some simple words" > gorp.file
    exec $::tcltest::tcltest cat gorp.file
d147 3
a149 3
test exec-3.2 {redirecting output to file} {execCommandExists stdio} {
    exec $::tcltest::tcltest echo "More simple words" | >gorp.file $::tcltest::tcltest cat | $::tcltest::tcltest cat
    exec $::tcltest::tcltest cat gorp.file
d151 3
a153 3
test exec-3.3 {redirecting output to file} {execCommandExists stdio} {
    exec > gorp.file $::tcltest::tcltest echo "Different simple words" | $::tcltest::tcltest cat | $::tcltest::tcltest cat
    exec $::tcltest::tcltest cat gorp.file
d155 3
a157 3
test exec-3.4 {redirecting output to file} {execCommandExists stdio} {
    exec $::tcltest::tcltest echo "Some simple words" >gorp.file
    exec $::tcltest::tcltest cat gorp.file
d159 4
a162 4
test exec-3.5 {redirecting output to file} {execCommandExists stdio} {
    exec $::tcltest::tcltest echo "First line" >gorp.file
    exec $::tcltest::tcltest echo "Second line" >> gorp.file
    exec $::tcltest::tcltest cat gorp.file
d164 4
a167 4
test exec-3.6 {redirecting output to file} {execCommandExists stdio} {
    exec $::tcltest::tcltest echo "First line" >gorp.file
    exec $::tcltest::tcltest echo "Second line" >>gorp.file
    exec $::tcltest::tcltest cat gorp.file
d169 2
a170 2
test exec-3.7 {redirecting output to file} {execCommandExists stdio} {
    set f [open gorp.file w]
d173 2
a174 2
    exec $::tcltest::tcltest echo "More text" >@@ $f
    exec $::tcltest::tcltest echo >@@$f "Even more"
d177 1
a177 1
    exec $::tcltest::tcltest cat gorp.file
d182 5
a186 4
file delete gorp.file
test exec-4.1 {redirecting output and stderr to file} {execCommandExists stdio} {
    exec $::tcltest::tcltest echo "test output" >& gorp.file
    exec $::tcltest::tcltest cat gorp.file
d188 3
a190 3
test exec-4.2 {redirecting output and stderr to file} {execCommandExists stdio} {
    list [exec $::tcltest::tcltest sh -c "echo foo bar 1>&2" >&gorp.file] \
	    [exec $::tcltest::tcltest cat gorp.file]
d192 4
a195 4
test exec-4.3 {redirecting output and stderr to file} {execCommandExists stdio} {
    exec $::tcltest::tcltest echo "first line" > gorp.file
    list [exec $::tcltest::tcltest sh -c "echo foo bar 1>&2" >>&gorp.file] \
	    [exec $::tcltest::tcltest cat gorp.file]
d197 2
a198 2
test exec-4.4 {redirecting output and stderr to file} {execCommandExists stdio} {
    set f [open gorp.file w]
d201 2
a202 2
    exec $::tcltest::tcltest echo "More text" >&@@ $f
    exec $::tcltest::tcltest echo >&@@$f "Even more"
d205 1
a205 1
    exec $::tcltest::tcltest cat gorp.file
d207 2
a208 2
test exec-4.5 {redirecting output and stderr to file} {execCommandExists stdio} {
    set f [open gorp.file w]
d211 2
a212 2
    exec >&@@ $f $::tcltest::tcltest sh -c "echo foo bar 1>&2"
    exec >&@@$f $::tcltest::tcltest sh -c "echo xyzzy 1>&2"
d215 1
a215 1
    exec $::tcltest::tcltest cat gorp.file
d220 5
a224 3
exec $::tcltest::tcltest echo "Just a few thoughts" > gorp.file
test exec-5.1 {redirecting input from file} {execCommandExists stdio} {
    exec $::tcltest::tcltest cat < gorp.file
d226 2
a227 2
test exec-5.2 {redirecting input from file} {execCommandExists stdio} {
    exec $::tcltest::tcltest cat | $::tcltest::tcltest cat < gorp.file
d229 2
a230 2
test exec-5.3 {redirecting input from file} {execCommandExists stdio} {
    exec $::tcltest::tcltest cat < gorp.file | $::tcltest::tcltest cat
d232 2
a233 2
test exec-5.4 {redirecting input from file} {execCommandExists stdio} {
    exec < gorp.file $::tcltest::tcltest cat | $::tcltest::tcltest cat
d235 2
a236 2
test exec-5.5 {redirecting input from file} {execCommandExists stdio} {
    exec $::tcltest::tcltest cat <gorp.file
d238 3
a240 3
test exec-5.6 {redirecting input from file} {execCommandExists stdio} {
    set f [open gorp.file r]
    set result [exec $::tcltest::tcltest cat <@@ $f]
d244 3
a246 3
test exec-5.7 {redirecting input from file} {execCommandExists stdio} {
    set f [open gorp.file r]
    set result [exec <@@$f $::tcltest::tcltest cat]
d253 2
a254 2
test exec-6.1 {redirecting stderr through a pipeline} {execCommandExists stdio} {
    exec $::tcltest::tcltest sh -c "echo foo bar" |& $::tcltest::tcltest cat
d256 2
a257 2
test exec-6.2 {redirecting stderr through a pipeline} {execCommandExists stdio} {
    exec $::tcltest::tcltest sh -c "echo foo bar 1>&2" |& $::tcltest::tcltest cat
d259 3
a261 3
test exec-6.3 {redirecting stderr through a pipeline} {execCommandExists stdio} {
    exec $::tcltest::tcltest sh -c "echo foo bar 1>&2" \
	|& $::tcltest::tcltest sh -c "echo second msg 1>&2 ; cat" |& $::tcltest::tcltest cat
d266 6
a271 4
file delete gorp.file2
test exec-7.1 {multiple I/O redirections} {execCommandExists stdio} {
    exec << "command input" > gorp.file2 $::tcltest::tcltest cat < gorp.file
    exec $::tcltest::tcltest cat gorp.file2
d273 2
a274 2
test exec-7.2 {multiple I/O redirections} {execCommandExists stdio} {
    exec < gorp.file << "command input" $::tcltest::tcltest cat
d284 2
a285 2
test exec-8.1 {long input and output} {execCommandExists stdio} {
    exec $::tcltest::tcltest cat << $a
d290 2
a291 2
test exec-8.1 {long input and output} {execCommandExists stdio} {
    exec $::tcltest::tcltest echo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
d296 1
a296 1
test exec-9.1 {commands returning errors} {execCommandExists stdio} {
d300 2
a301 2
test exec-9.2 {commands returning errors} {execCommandExists stdio} {
    string tolower [list [catch {exec $::tcltest::tcltest echo foo | foo123} msg] $msg $errorCode]
d303 2
a304 2
test exec-9.3 {commands returning errors} {execCommandExists stdio} {
    list [catch {exec $::tcltest::tcltest sleep 1 | $::tcltest::tcltest exit 43 | $::tcltest::tcltest sleep 1} msg] $msg
d306 2
a307 2
test exec-9.4 {commands returning errors} {execCommandExists stdio} {
    list [catch {exec $::tcltest::tcltest exit 43 | $::tcltest::tcltest echo "foo bar"} msg] $msg
d310 2
a311 2
test exec-9.5 {commands returning errors} {execCommandExists stdio} {
    list [catch {exec gorp456 | $::tcltest::tcltest echo a b c} msg] [string tolower $msg]
d313 2
a314 2
test exec-9.6 {commands returning errors} {execCommandExists stdio} {
    list [catch {exec $::tcltest::tcltest sh -c "echo error msg 1>&2"} msg] $msg
d316 3
a318 3
test exec-9.7 {commands returning errors} {execCommandExists stdio} {
    list [catch {exec $::tcltest::tcltest sh -c "echo error msg 1>&2" \
		     | $::tcltest::tcltest sh -c "echo error msg 1>&2"} msg] $msg
d321 5
a325 2
test exec-9.8 {commands returning errors} {execCommandExists stdio} {
    set f [open err w]
d331 1
a331 1
    list [catch {exec $::tcltest::tcltest err} msg] $msg
d338 1
a338 1
test exec-10.1 {errors in exec invocation} {execCommandExists stdio} {
d341 1
a341 1
test exec-10.2 {errors in exec invocation} {execCommandExists stdio} {
d344 1
a344 1
test exec-10.3 {errors in exec invocation} {execCommandExists stdio} {
d347 1
a347 1
test exec-10.4 {errors in exec invocation} {execCommandExists stdio} {
d350 1
a350 1
test exec-10.5 {errors in exec invocation} {execCommandExists stdio} {
d353 1
a353 1
test exec-10.6 {errors in exec invocation} {execCommandExists stdio} {
d356 1
a356 1
test exec-10.7 {errors in exec invocation} {execCommandExists stdio} {
d359 1
a359 1
test exec-10.8 {errors in exec invocation} {execCommandExists stdio} {
d362 1
a362 1
test exec-10.9 {errors in exec invocation} {execCommandExists stdio} {
d365 1
a365 1
test exec-10.10 {errors in exec invocation} {execCommandExists stdio} {
d368 1
a368 1
test exec-10.11 {errors in exec invocation} {execCommandExists stdio} {
d371 1
a371 1
test exec-10.12 {errors in exec invocation} {execCommandExists stdio} {
d374 1
a374 1
test exec-10.13 {errors in exec invocation} {execCommandExists stdio} {
d377 1
a377 1
test exec-10.14 {errors in exec invocation} {execCommandExists stdio} {
d380 1
a380 1
test exec-10.15 {errors in exec invocation} {execCommandExists stdio} {
d383 1
a383 1
test exec-10.16 {errors in exec invocation} {execCommandExists stdio} {
d386 1
a386 1
test exec-10.17 {errors in exec invocation} {execCommandExists stdio} {
d389 2
a390 2
set f [open gorp.file w]
test exec-10.18 {errors in exec invocation} {execCommandExists stdio} {
d394 2
a395 2
set f [open gorp.file r]
test exec-10.19 {errors in exec invocation} {execCommandExists stdio} {
d399 1
a399 1
test exec-10.20 {errors in exec invocation} {execCommandExists stdio} {
d402 2
a403 2
test exec-10.21 {errors in exec invocation} {execCommandExists stdio} {
    list [catch {exec $::tcltest::tcltest true | ~xyzzy_bad_user/x | false} msg] $msg
d408 2
a409 2
test exec-11.1 {commands in background} {execCommandExists stdio} {
    set x [lindex [time {exec $::tcltest::tcltest sleep 2 &}] 0]
d412 2
a413 2
test exec-11.2 {commands in background} {execCommandExists stdio} {
    list [catch {exec $::tcltest::tcltest echo a &b} msg] $msg
d415 2
a416 2
test exec-11.3 {commands in background} {execCommandExists stdio} {
    llength [exec $::tcltest::tcltest sleep 1 &]
d418 2
a419 2
test exec-11.4 {commands in background} {execCommandExists stdio} {
    llength [exec $::tcltest::tcltest sleep 1 | $::tcltest::tcltest sleep 1 | $::tcltest::tcltest sleep 1 &]
d421 3
a423 3
test exec-11.5 {commands in background} {execCommandExists stdio} {
    set f [open gorp.file w]
    puts $f { catch { exec [info nameofexecutable] echo foo & } }
d425 1
a425 1
    string compare "foo" [exec $::tcltest::tcltest gorp.file]
d431 3
a433 1
exec $::tcltest::tcltest sleep 3
d435 1
a435 1
	{execCommandExists stdio unixOnly nonPortable} {
d444 1
a444 1
	{execCommandExists stdio unixOnly nonPortable} {
d453 1
a453 1
	{execCommandExists stdio unixOnly nonPortable} {
d476 2
a477 2
test exec-13.1 {setting errorCode variable} {execCommandExists stdio} {
    list [catch {exec $::tcltest::tcltest cat < a/b/c} msg] [string tolower $errorCode]
d479 2
a480 2
test exec-13.2 {setting errorCode variable} {execCommandExists stdio} {
    list [catch {exec $::tcltest::tcltest cat > a/b/c} msg] [string tolower $errorCode]
d482 1
a482 1
test exec-13.3 {setting errorCode variable} {execCommandExists stdio} {
d490 2
a491 2
test exec-14.1 {-keepnewline switch} {execCommandExists stdio} {
    exec -keepnewline $::tcltest::tcltest echo foo
d493 1
a493 1
test exec-14.2 {-keepnewline switch} {execCommandExists stdio} {
d496 1
a496 1
test exec-14.3 {unknown switch} {execCommandExists stdio} {
d499 1
a499 1
test exec-14.4 {-- switch} {execCommandExists stdio} {
d505 4
a508 4
test exec-15.1 {standard error redirection} {execCommandExists stdio} {
    exec $::tcltest::tcltest echo "First line" > gorp.file
    list [exec $::tcltest::tcltest sh -c "echo foo bar 1>&2" 2> gorp.file] \
	    [exec $::tcltest::tcltest cat gorp.file]
d510 5
a514 5
test exec-15.2 {standard error redirection} {execCommandExists stdio} {
    list [exec $::tcltest::tcltest sh -c "echo foo bar 1>&2" \
		| $::tcltest::tcltest echo biz baz >gorp.file 2> gorp.file2] \
	    [exec $::tcltest::tcltest cat gorp.file] \
	    [exec $::tcltest::tcltest cat gorp.file2]
d516 5
a520 5
test exec-15.3 {standard error redirection} {execCommandExists stdio} {
    list [exec $::tcltest::tcltest sh -c "echo foo bar 1>&2" \
	        | $::tcltest::tcltest echo biz baz 2>gorp.file > gorp.file2] \
	    [exec $::tcltest::tcltest cat gorp.file] \
	    [exec $::tcltest::tcltest cat gorp.file2]
d522 2
a523 2
test exec-15.4 {standard error redirection} {execCommandExists stdio} {
    set f [open gorp.file w]
d526 1
a526 1
    exec $::tcltest::tcltest sh -c "echo foo bar 1>&2" 2>@@ $f
d529 1
a529 1
    exec $::tcltest::tcltest cat gorp.file
d533 4
a536 4
test exec-15.5 {standard error redirection} {execCommandExists stdio} {
    exec $::tcltest::tcltest echo "First line" > gorp.file
    exec $::tcltest::tcltest sh -c "echo foo bar 1>&2" 2>> gorp.file
    exec $::tcltest::tcltest cat gorp.file
d539 4
a542 4
test exec-15.6 {standard error redirection} {execCommandExists stdio} {
    exec $::tcltest::tcltest sh -c "echo foo bar 1>&2" > gorp.file2 2> gorp.file \
	    >& gorp.file 2> gorp.file2 | $::tcltest::tcltest echo biz baz
    list [exec $::tcltest::tcltest cat gorp.file] [exec $::tcltest::tcltest cat gorp.file2]
d545 2
a546 2
test exec-16.1 {flush output before exec} {execCommandExists stdio} {
    set f [open gorp.file w]
d548 1
a548 1
    exec $::tcltest::tcltest echo "Second line" >@@ $f
d551 1
a551 1
    exec $::tcltest::tcltest cat gorp.file
d555 2
a556 2
test exec-16.2 {flush output before exec} {execCommandExists stdio} {
    set f [open gorp.file w]
d558 1
a558 1
    exec $::tcltest::tcltest << {puts stderr {Second line}} >&@@ $f > gorp.file2
d561 1
a561 1
    exec $::tcltest::tcltest cat gorp.file
d566 8
a573 6
test exec-17.1 { inheriting standard I/O } {execCommandExists stdio} {
    set f [open script w]
    puts $f {close stdout
	set f [open gorp.file w]
	catch {exec [info nameofexecutable] echo foobar &}
	exec [info nameofexecutable] sleep 2
d575 1
a575 1
    }
d577 2
a578 2
    catch {exec $::tcltest::tcltest script} result
    set f [open gorp.file r]
d585 13
d599 5
a603 3
file delete script gorp.file gorp.file2
file delete echo cat wc sh sleep exit
file delete err
a605 13













@


1.3
log
@touched all sources to ease next import
@
text
@@


1.3.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d14 1
a14 1
# RCS: @@(#) $Id: exec.test,v 1.14 2002/09/02 19:27:15 hobbs Exp $
d16 4
a19 2
package require tcltest 2
namespace import -force ::tcltest::*
d23 1
a23 1
testConstraint exec [llength [info commands exec]]
d25 2
a26 1
set path(echo) [makeFile {
d33 2
a34 1
} echo]
d36 2
a37 1
set path(cat) [makeFile {
d56 2
a57 1
} cat]
d59 2
a60 1
set path(wc) [makeFile {
d67 2
a68 1
} wc]
d70 2
a71 1
set path(sh) [makeFile {
d92 2
a93 1
} sh]
d95 2
a96 1
set path(sleep) [makeFile {
d99 2
a100 1
} sleep]
d102 2
a103 1
set path(exit) [makeFile {
d105 2
a106 1
} exit]
d110 2
a111 2
test exec-1.1 {basic exec operation} {exec} {
    exec [interpreter] $path(echo) a b c
d113 2
a114 2
test exec-1.2 {pipelining} {exec stdio} {
    exec [interpreter] $path(echo) a b c d | [interpreter] $path(cat) | [interpreter] $path(cat)
d116 2
a117 2
test exec-1.3 {pipelining} {exec stdio} {
    set a [exec [interpreter] $path(echo) a b c d | [interpreter] $path(cat) | [interpreter] $path(wc)]
d122 2
a123 2
test exec-1.4 {long command lines} {exec} {
    exec [interpreter] $path(echo) $arg
d129 2
a130 2
test exec-2.1 {redirecting input from immediate source} {exec stdio} {
    exec [interpreter] $path(cat) << "Sample text"
d132 2
a133 2
test exec-2.2 {redirecting input from immediate source} {exec stdio} {
    exec << "Sample text" [interpreter] $path(cat) | [interpreter] $path(cat)
d135 2
a136 2
test exec-2.3 {redirecting input from immediate source} {exec stdio} {
    exec [interpreter] $path(cat) << "Sample text" | [interpreter] $path(cat)
d138 2
a139 2
test exec-2.4 {redirecting input from immediate source} {exec stdio} {
    exec [interpreter] $path(cat) | [interpreter] $path(cat) << "Sample text"
d141 2
a142 2
test exec-2.5 {redirecting input from immediate source} {exec} {
    exec [interpreter] $path(cat) "<<Joined to arrows"
d144 1
a144 1
test exec-2.6 {redirecting input from immediate source, with UTF} {exec} {
d149 1
a149 1
    exec [interpreter] $path(cat) << "\uE9\uE0\uFC\uF1"
d154 4
a157 6
set path(gorp.file) [makeFile {} gorp.file]
removeFile gorp.file

test exec-3.1 {redirecting output to file} {exec} {
    exec [interpreter] $path(echo) "Some simple words" > $path(gorp.file)
    exec [interpreter] $path(cat) $path(gorp.file)
d159 3
a161 3
test exec-3.2 {redirecting output to file} {exec stdio} {
    exec [interpreter] $path(echo) "More simple words" | >$path(gorp.file) [interpreter] $path(cat) | [interpreter] $path(cat)
    exec [interpreter] $path(cat) $path(gorp.file)
d163 3
a165 3
test exec-3.3 {redirecting output to file} {exec stdio} {
    exec > $path(gorp.file) [interpreter] $path(echo) "Different simple words" | [interpreter] $path(cat) | [interpreter] $path(cat)
    exec [interpreter] $path(cat) $path(gorp.file)
d167 3
a169 3
test exec-3.4 {redirecting output to file} {exec} {
    exec [interpreter] $path(echo) "Some simple words" >$path(gorp.file)
    exec [interpreter] $path(cat) $path(gorp.file)
d171 4
a174 4
test exec-3.5 {redirecting output to file} {exec} {
    exec [interpreter] $path(echo) "First line" >$path(gorp.file)
    exec [interpreter] $path(echo) "Second line" >> $path(gorp.file)
    exec [interpreter] $path(cat) $path(gorp.file)
d176 4
a179 4
test exec-3.6 {redirecting output to file} {exec} {
    exec [interpreter] $path(echo) "First line" >$path(gorp.file)
    exec [interpreter] $path(echo) "Second line" >>$path(gorp.file)
    exec [interpreter] $path(cat) $path(gorp.file)
d181 2
a182 2
test exec-3.7 {redirecting output to file} {exec} {
    set f [open $path(gorp.file) w]
d185 2
a186 2
    exec [interpreter] $path(echo) "More text" >@@ $f
    exec [interpreter] $path(echo) >@@$f "Even more"
d189 1
a189 1
    exec [interpreter] $path(cat) $path(gorp.file)
d194 4
a197 5
removeFile gorp.file

test exec-4.1 {redirecting output and stderr to file} {exec} {
    exec [interpreter] $path(echo) "test output" >& $path(gorp.file)
    exec [interpreter] $path(cat) $path(gorp.file)
d199 3
a201 3
test exec-4.2 {redirecting output and stderr to file} {exec} {
    list [exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" >&$path(gorp.file)] \
	    [exec [interpreter] $path(cat) $path(gorp.file)]
d203 4
a206 4
test exec-4.3 {redirecting output and stderr to file} {exec} {
    exec [interpreter] $path(echo) "first line" > $path(gorp.file)
    list [exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" >>&$path(gorp.file)] \
	    [exec [interpreter] $path(cat) $path(gorp.file)]
d208 2
a209 2
test exec-4.4 {redirecting output and stderr to file} {exec} {
    set f [open $path(gorp.file) w]
d212 2
a213 2
    exec [interpreter] $path(echo) "More text" >&@@ $f
    exec [interpreter] $path(echo) >&@@$f "Even more"
d216 1
a216 1
    exec [interpreter] $path(cat) $path(gorp.file)
d218 2
a219 2
test exec-4.5 {redirecting output and stderr to file} {exec} {
    set f [open $path(gorp.file) w]
d222 2
a223 2
    exec >&@@ $f [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2"
    exec >&@@$f [interpreter] $path(sh) -c "$path(echo) xyzzy 1>&2"
d226 1
a226 1
    exec [interpreter] $path(cat) $path(gorp.file)
d231 3
a233 5
if { [set ::tcltest::testConstraints(exec)] } {
exec [interpreter] $path(echo) "Just a few thoughts" > $path(gorp.file)
}
test exec-5.1 {redirecting input from file} {exec} {
    exec [interpreter] $path(cat) < $path(gorp.file)
d235 2
a236 2
test exec-5.2 {redirecting input from file} {exec stdio} {
    exec [interpreter] $path(cat) | [interpreter] $path(cat) < $path(gorp.file)
d238 2
a239 2
test exec-5.3 {redirecting input from file} {exec stdio} {
    exec [interpreter] $path(cat) < $path(gorp.file) | [interpreter] $path(cat)
d241 2
a242 2
test exec-5.4 {redirecting input from file} {exec stdio} {
    exec < $path(gorp.file) [interpreter] $path(cat) | [interpreter] $path(cat)
d244 2
a245 2
test exec-5.5 {redirecting input from file} {exec} {
    exec [interpreter] $path(cat) <$path(gorp.file)
d247 3
a249 3
test exec-5.6 {redirecting input from file} {exec} {
    set f [open $path(gorp.file) r]
    set result [exec [interpreter] $path(cat) <@@ $f]
d253 3
a255 3
test exec-5.7 {redirecting input from file} {exec} {
    set f [open $path(gorp.file) r]
    set result [exec <@@$f [interpreter] $path(cat)]
d262 2
a263 2
test exec-6.1 {redirecting stderr through a pipeline} {exec stdio} {
    exec [interpreter] $path(sh) -c "$path(echo) foo bar" |& [interpreter] $path(cat)
d265 2
a266 2
test exec-6.2 {redirecting stderr through a pipeline} {exec stdio} {
    exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" |& [interpreter] $path(cat)
d268 3
a270 3
test exec-6.3 {redirecting stderr through a pipeline} {exec stdio} {
    exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" \
	|& [interpreter] $path(sh) -c "$path(echo) second msg 1>&2 ; $path(cat)" |& [interpreter] $path(cat)
d275 4
a278 6
set path(gorp.file2) [makeFile {} gorp.file2]
removeFile gorp.file2

test exec-7.1 {multiple I/O redirections} {exec} {
    exec << "command input" > $path(gorp.file2) [interpreter] $path(cat) < $path(gorp.file)
    exec [interpreter] $path(cat) $path(gorp.file2)
d280 2
a281 2
test exec-7.2 {multiple I/O redirections} {exec} {
    exec < $path(gorp.file) << "command input" [interpreter] $path(cat)
d291 2
a292 2
test exec-8.1 {long input and output} {exec} {
    exec [interpreter] $path(cat) << $a
d297 2
a298 2
test exec-8.2 {long input and output} {exec} {
    exec [interpreter] $path(echo) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
d303 1
a303 1
test exec-9.1 {commands returning errors} {exec} {
d307 2
a308 2
test exec-9.2 {commands returning errors} {exec} {
    string tolower [list [catch {exec [interpreter] echo foo | foo123} msg] $msg $errorCode]
d310 2
a311 2
test exec-9.3 {commands returning errors} {exec stdio} {
    list [catch {exec [interpreter] $path(sleep) 1 | [interpreter] $path(exit) 43 | [interpreter] $path(sleep) 1} msg] $msg
d313 2
a314 2
test exec-9.4 {commands returning errors} {exec stdio} {
    list [catch {exec [interpreter] $path(exit) 43 | [interpreter] $path(echo) "foo bar"} msg] $msg
d317 2
a318 2
test exec-9.5 {commands returning errors} {exec stdio} {
    list [catch {exec gorp456 | [interpreter] echo a b c} msg] [string tolower $msg]
d320 2
a321 2
test exec-9.6 {commands returning errors} {exec} {
    list [catch {exec [interpreter] $path(sh) -c "$path(echo) error msg 1>&2"} msg] $msg
d323 3
a325 3
test exec-9.7 {commands returning errors} {exec stdio} {
    list [catch {exec [interpreter] $path(sh) -c "$path(echo) error msg 1>&2" \
		     | [interpreter] $path(sh) -c "$path(echo) error msg 1>&2"} msg] $msg
d328 2
a329 5

set path(err) [makeFile {} err]

test exec-9.8 {commands returning errors} {exec} {
    set f [open $path(err) w]
d335 1
a335 1
    list [catch {exec [interpreter] $path(err)} msg] $msg
d342 1
a342 1
test exec-10.1 {errors in exec invocation} {exec} {
d345 1
a345 1
test exec-10.2 {errors in exec invocation} {exec} {
d348 1
a348 1
test exec-10.3 {errors in exec invocation} {exec} {
d351 1
a351 1
test exec-10.4 {errors in exec invocation} {exec} {
d354 1
a354 1
test exec-10.5 {errors in exec invocation} {exec} {
d357 1
a357 1
test exec-10.6 {errors in exec invocation} {exec} {
d360 1
a360 1
test exec-10.7 {errors in exec invocation} {exec} {
d363 1
a363 1
test exec-10.8 {errors in exec invocation} {exec} {
d366 1
a366 1
test exec-10.9 {errors in exec invocation} {exec} {
d369 1
a369 1
test exec-10.10 {errors in exec invocation} {exec} {
d372 1
a372 1
test exec-10.11 {errors in exec invocation} {exec} {
d375 1
a375 1
test exec-10.12 {errors in exec invocation} {exec} {
d378 1
a378 1
test exec-10.13 {errors in exec invocation} {exec} {
d381 1
a381 1
test exec-10.14 {errors in exec invocation} {exec} {
d384 1
a384 1
test exec-10.15 {errors in exec invocation} {exec} {
d387 1
a387 1
test exec-10.16 {errors in exec invocation} {exec} {
d390 1
a390 1
test exec-10.17 {errors in exec invocation} {exec} {
d393 2
a394 2
set f [open $path(gorp.file) w]
test exec-10.18 {errors in exec invocation} {exec} {
d398 2
a399 2
set f [open $path(gorp.file) r]
test exec-10.19 {errors in exec invocation} {exec} {
d403 1
a403 1
test exec-10.20 {errors in exec invocation} {exec} {
d406 2
a407 2
test exec-10.21 {errors in exec invocation} {exec} {
    list [catch {exec [interpreter] true | ~xyzzy_bad_user/x | false} msg] $msg
d412 2
a413 2
test exec-11.1 {commands in background} {exec} {
    set x [lindex [time {exec [interpreter] $path(sleep) 2 &}] 0]
d416 2
a417 2
test exec-11.2 {commands in background} {exec} {
    list [catch {exec [interpreter] $path(echo) a &b} msg] $msg
d419 2
a420 2
test exec-11.3 {commands in background} {exec} {
    llength [exec [interpreter] $path(sleep) 1 &]
d422 2
a423 2
test exec-11.4 {commands in background} {exec stdio} {
    llength [exec [interpreter] $path(sleep) 1 | [interpreter] $path(sleep) 1 | [interpreter] $path(sleep) 1 &]
d425 3
a427 3
test exec-11.5 {commands in background} {exec} {
    set f [open $path(gorp.file) w]
    puts $f [format { catch { exec [info nameofexecutable] %s foo & } } $path(echo)]
d429 1
a429 1
    string compare "foo" [exec [interpreter] $path(gorp.file)]
d435 1
a435 3
if { [set ::tcltest::testConstraints(exec)] } {
exec [interpreter] $path(sleep) 3
}
d437 1
a437 1
	{exec unixOnly nonPortable} {
d446 1
a446 1
	{exec unixOnly nonPortable} {
d455 1
a455 1
	{exec unixOnly nonPortable} {
d478 2
a479 2
test exec-13.1 {setting errorCode variable} {exec} {
    list [catch {exec [interpreter] $path(cat) < a/b/c} msg] [string tolower $errorCode]
d481 2
a482 2
test exec-13.2 {setting errorCode variable} {exec} {
    list [catch {exec [interpreter] $path(cat) > a/b/c} msg] [string tolower $errorCode]
d484 1
a484 1
test exec-13.3 {setting errorCode variable} {exec} {
d492 2
a493 2
test exec-14.1 {-keepnewline switch} {exec} {
    exec -keepnewline [interpreter] $path(echo) foo
d495 1
a495 1
test exec-14.2 {-keepnewline switch} {exec} {
d498 1
a498 1
test exec-14.3 {unknown switch} {exec} {
d501 1
a501 1
test exec-14.4 {-- switch} {exec} {
d507 4
a510 4
test exec-15.1 {standard error redirection} {exec} {
    exec [interpreter] $path(echo) "First line" > $path(gorp.file)
    list [exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" 2> $path(gorp.file)] \
	    [exec [interpreter] $path(cat) $path(gorp.file)]
d512 5
a516 5
test exec-15.2 {standard error redirection} {exec stdio} {
    list [exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" \
		| [interpreter] $path(echo) biz baz >$path(gorp.file) 2> $path(gorp.file2)] \
	    [exec [interpreter] $path(cat) $path(gorp.file)] \
	    [exec [interpreter] $path(cat) $path(gorp.file2)]
d518 5
a522 5
test exec-15.3 {standard error redirection} {exec stdio} {
    list [exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" \
	        | [interpreter] $path(echo) biz baz 2>$path(gorp.file) > $path(gorp.file2)] \
	    [exec [interpreter] $path(cat) $path(gorp.file)] \
	    [exec [interpreter] $path(cat) $path(gorp.file2)]
d524 2
a525 2
test exec-15.4 {standard error redirection} {exec} {
    set f [open $path(gorp.file) w]
d528 1
a528 1
    exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" 2>@@ $f
d531 1
a531 1
    exec [interpreter] $path(cat) $path(gorp.file)
d535 4
a538 4
test exec-15.5 {standard error redirection} {exec} {
    exec [interpreter] $path(echo) "First line" > $path(gorp.file)
    exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" 2>> $path(gorp.file)
    exec [interpreter] $path(cat) $path(gorp.file)
d541 4
a544 4
test exec-15.6 {standard error redirection} {exec stdio} {
    exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" > $path(gorp.file2) 2> $path(gorp.file) \
	    >& $path(gorp.file) 2> $path(gorp.file2) | [interpreter] $path(echo) biz baz
    list [exec [interpreter] $path(cat) $path(gorp.file)] [exec [interpreter] $path(cat) $path(gorp.file2)]
d547 2
a548 2
test exec-16.1 {flush output before exec} {exec} {
    set f [open $path(gorp.file) w]
d550 1
a550 1
    exec [interpreter] $path(echo) "Second line" >@@ $f
d553 1
a553 1
    exec [interpreter] $path(cat) $path(gorp.file)
d557 2
a558 2
test exec-16.2 {flush output before exec} {exec} {
    set f [open $path(gorp.file) w]
d560 1
a560 1
    exec [interpreter] << {puts stderr {Second line}} >&@@ $f > $path(gorp.file2)
d563 1
a563 1
    exec [interpreter] $path(cat) $path(gorp.file)
d568 6
a573 8
set path(script) [makeFile {} script]

test exec-17.1 { inheriting standard I/O } {exec} {
    set f [open $path(script) w]
    puts $f [format {close stdout
	set f [open %s w]
	catch {exec [info nameofexecutable] %s foobar &}
	exec [info nameofexecutable] %s 2
d575 1
a575 1
    } $path(gorp.file) $path(echo) $path(sleep)]
d577 2
a578 2
    catch {exec [interpreter] $path(script)} result
    set f [open $path(gorp.file) r]
d585 16
a600 12
test exec-18.1 { exec cat deals with weird file names} {exec unixOnly} {
    # This is cross-platform, but the cat isn't predictably correct on
    # Windows.
    set f "foo\[\{blah"
    set path(fooblah) [makeFile {} $f]
    set fout [open $path(fooblah) w]
    puts $fout "contents"
    close $fout
    set res [list [catch {exec cat $path(fooblah)} msg] $msg]
    removeFile $f
    set res
} {0 contents}
a601 1
# cleanup
a602 3
foreach file {script gorp.file gorp.file2 echo cat wc sh sleep exit err} {
	removeFile $file
}
a603 2
::tcltest::cleanupTests
return
@


1.3.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@d14 1
a14 1
# RCS: @@(#) $Id: exec.test,v 1.14 2002/09/02 19:27:15 hobbs Exp $
d16 4
a19 2
package require tcltest 2
namespace import -force ::tcltest::*
d23 1
a23 1
testConstraint exec [llength [info commands exec]]
d25 2
a26 1
set path(echo) [makeFile {
d33 2
a34 1
} echo]
d36 2
a37 1
set path(cat) [makeFile {
d56 2
a57 1
} cat]
d59 2
a60 1
set path(wc) [makeFile {
d67 2
a68 1
} wc]
d70 2
a71 1
set path(sh) [makeFile {
d92 2
a93 1
} sh]
d95 2
a96 1
set path(sleep) [makeFile {
d99 2
a100 1
} sleep]
d102 2
a103 1
set path(exit) [makeFile {
d105 2
a106 1
} exit]
d110 2
a111 2
test exec-1.1 {basic exec operation} {exec} {
    exec [interpreter] $path(echo) a b c
d113 2
a114 2
test exec-1.2 {pipelining} {exec stdio} {
    exec [interpreter] $path(echo) a b c d | [interpreter] $path(cat) | [interpreter] $path(cat)
d116 2
a117 2
test exec-1.3 {pipelining} {exec stdio} {
    set a [exec [interpreter] $path(echo) a b c d | [interpreter] $path(cat) | [interpreter] $path(wc)]
d122 2
a123 2
test exec-1.4 {long command lines} {exec} {
    exec [interpreter] $path(echo) $arg
d129 2
a130 2
test exec-2.1 {redirecting input from immediate source} {exec stdio} {
    exec [interpreter] $path(cat) << "Sample text"
d132 2
a133 2
test exec-2.2 {redirecting input from immediate source} {exec stdio} {
    exec << "Sample text" [interpreter] $path(cat) | [interpreter] $path(cat)
d135 2
a136 2
test exec-2.3 {redirecting input from immediate source} {exec stdio} {
    exec [interpreter] $path(cat) << "Sample text" | [interpreter] $path(cat)
d138 2
a139 2
test exec-2.4 {redirecting input from immediate source} {exec stdio} {
    exec [interpreter] $path(cat) | [interpreter] $path(cat) << "Sample text"
d141 2
a142 2
test exec-2.5 {redirecting input from immediate source} {exec} {
    exec [interpreter] $path(cat) "<<Joined to arrows"
d144 1
a144 1
test exec-2.6 {redirecting input from immediate source, with UTF} {exec} {
d149 1
a149 1
    exec [interpreter] $path(cat) << "\uE9\uE0\uFC\uF1"
d154 4
a157 6
set path(gorp.file) [makeFile {} gorp.file]
removeFile gorp.file

test exec-3.1 {redirecting output to file} {exec} {
    exec [interpreter] $path(echo) "Some simple words" > $path(gorp.file)
    exec [interpreter] $path(cat) $path(gorp.file)
d159 3
a161 3
test exec-3.2 {redirecting output to file} {exec stdio} {
    exec [interpreter] $path(echo) "More simple words" | >$path(gorp.file) [interpreter] $path(cat) | [interpreter] $path(cat)
    exec [interpreter] $path(cat) $path(gorp.file)
d163 3
a165 3
test exec-3.3 {redirecting output to file} {exec stdio} {
    exec > $path(gorp.file) [interpreter] $path(echo) "Different simple words" | [interpreter] $path(cat) | [interpreter] $path(cat)
    exec [interpreter] $path(cat) $path(gorp.file)
d167 3
a169 3
test exec-3.4 {redirecting output to file} {exec} {
    exec [interpreter] $path(echo) "Some simple words" >$path(gorp.file)
    exec [interpreter] $path(cat) $path(gorp.file)
d171 4
a174 4
test exec-3.5 {redirecting output to file} {exec} {
    exec [interpreter] $path(echo) "First line" >$path(gorp.file)
    exec [interpreter] $path(echo) "Second line" >> $path(gorp.file)
    exec [interpreter] $path(cat) $path(gorp.file)
d176 4
a179 4
test exec-3.6 {redirecting output to file} {exec} {
    exec [interpreter] $path(echo) "First line" >$path(gorp.file)
    exec [interpreter] $path(echo) "Second line" >>$path(gorp.file)
    exec [interpreter] $path(cat) $path(gorp.file)
d181 2
a182 2
test exec-3.7 {redirecting output to file} {exec} {
    set f [open $path(gorp.file) w]
d185 2
a186 2
    exec [interpreter] $path(echo) "More text" >@@ $f
    exec [interpreter] $path(echo) >@@$f "Even more"
d189 1
a189 1
    exec [interpreter] $path(cat) $path(gorp.file)
d194 4
a197 5
removeFile gorp.file

test exec-4.1 {redirecting output and stderr to file} {exec} {
    exec [interpreter] $path(echo) "test output" >& $path(gorp.file)
    exec [interpreter] $path(cat) $path(gorp.file)
d199 3
a201 3
test exec-4.2 {redirecting output and stderr to file} {exec} {
    list [exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" >&$path(gorp.file)] \
	    [exec [interpreter] $path(cat) $path(gorp.file)]
d203 4
a206 4
test exec-4.3 {redirecting output and stderr to file} {exec} {
    exec [interpreter] $path(echo) "first line" > $path(gorp.file)
    list [exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" >>&$path(gorp.file)] \
	    [exec [interpreter] $path(cat) $path(gorp.file)]
d208 2
a209 2
test exec-4.4 {redirecting output and stderr to file} {exec} {
    set f [open $path(gorp.file) w]
d212 2
a213 2
    exec [interpreter] $path(echo) "More text" >&@@ $f
    exec [interpreter] $path(echo) >&@@$f "Even more"
d216 1
a216 1
    exec [interpreter] $path(cat) $path(gorp.file)
d218 2
a219 2
test exec-4.5 {redirecting output and stderr to file} {exec} {
    set f [open $path(gorp.file) w]
d222 2
a223 2
    exec >&@@ $f [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2"
    exec >&@@$f [interpreter] $path(sh) -c "$path(echo) xyzzy 1>&2"
d226 1
a226 1
    exec [interpreter] $path(cat) $path(gorp.file)
d231 3
a233 5
if { [set ::tcltest::testConstraints(exec)] } {
exec [interpreter] $path(echo) "Just a few thoughts" > $path(gorp.file)
}
test exec-5.1 {redirecting input from file} {exec} {
    exec [interpreter] $path(cat) < $path(gorp.file)
d235 2
a236 2
test exec-5.2 {redirecting input from file} {exec stdio} {
    exec [interpreter] $path(cat) | [interpreter] $path(cat) < $path(gorp.file)
d238 2
a239 2
test exec-5.3 {redirecting input from file} {exec stdio} {
    exec [interpreter] $path(cat) < $path(gorp.file) | [interpreter] $path(cat)
d241 2
a242 2
test exec-5.4 {redirecting input from file} {exec stdio} {
    exec < $path(gorp.file) [interpreter] $path(cat) | [interpreter] $path(cat)
d244 2
a245 2
test exec-5.5 {redirecting input from file} {exec} {
    exec [interpreter] $path(cat) <$path(gorp.file)
d247 3
a249 3
test exec-5.6 {redirecting input from file} {exec} {
    set f [open $path(gorp.file) r]
    set result [exec [interpreter] $path(cat) <@@ $f]
d253 3
a255 3
test exec-5.7 {redirecting input from file} {exec} {
    set f [open $path(gorp.file) r]
    set result [exec <@@$f [interpreter] $path(cat)]
d262 2
a263 2
test exec-6.1 {redirecting stderr through a pipeline} {exec stdio} {
    exec [interpreter] $path(sh) -c "$path(echo) foo bar" |& [interpreter] $path(cat)
d265 2
a266 2
test exec-6.2 {redirecting stderr through a pipeline} {exec stdio} {
    exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" |& [interpreter] $path(cat)
d268 3
a270 3
test exec-6.3 {redirecting stderr through a pipeline} {exec stdio} {
    exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" \
	|& [interpreter] $path(sh) -c "$path(echo) second msg 1>&2 ; $path(cat)" |& [interpreter] $path(cat)
d275 4
a278 6
set path(gorp.file2) [makeFile {} gorp.file2]
removeFile gorp.file2

test exec-7.1 {multiple I/O redirections} {exec} {
    exec << "command input" > $path(gorp.file2) [interpreter] $path(cat) < $path(gorp.file)
    exec [interpreter] $path(cat) $path(gorp.file2)
d280 2
a281 2
test exec-7.2 {multiple I/O redirections} {exec} {
    exec < $path(gorp.file) << "command input" [interpreter] $path(cat)
d291 2
a292 2
test exec-8.1 {long input and output} {exec} {
    exec [interpreter] $path(cat) << $a
d297 2
a298 2
test exec-8.2 {long input and output} {exec} {
    exec [interpreter] $path(echo) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
d303 1
a303 1
test exec-9.1 {commands returning errors} {exec} {
d307 2
a308 2
test exec-9.2 {commands returning errors} {exec} {
    string tolower [list [catch {exec [interpreter] echo foo | foo123} msg] $msg $errorCode]
d310 2
a311 2
test exec-9.3 {commands returning errors} {exec stdio} {
    list [catch {exec [interpreter] $path(sleep) 1 | [interpreter] $path(exit) 43 | [interpreter] $path(sleep) 1} msg] $msg
d313 2
a314 2
test exec-9.4 {commands returning errors} {exec stdio} {
    list [catch {exec [interpreter] $path(exit) 43 | [interpreter] $path(echo) "foo bar"} msg] $msg
d317 2
a318 2
test exec-9.5 {commands returning errors} {exec stdio} {
    list [catch {exec gorp456 | [interpreter] echo a b c} msg] [string tolower $msg]
d320 2
a321 2
test exec-9.6 {commands returning errors} {exec} {
    list [catch {exec [interpreter] $path(sh) -c "$path(echo) error msg 1>&2"} msg] $msg
d323 3
a325 3
test exec-9.7 {commands returning errors} {exec stdio} {
    list [catch {exec [interpreter] $path(sh) -c "$path(echo) error msg 1>&2" \
		     | [interpreter] $path(sh) -c "$path(echo) error msg 1>&2"} msg] $msg
d328 2
a329 5

set path(err) [makeFile {} err]

test exec-9.8 {commands returning errors} {exec} {
    set f [open $path(err) w]
d335 1
a335 1
    list [catch {exec [interpreter] $path(err)} msg] $msg
d342 1
a342 1
test exec-10.1 {errors in exec invocation} {exec} {
d345 1
a345 1
test exec-10.2 {errors in exec invocation} {exec} {
d348 1
a348 1
test exec-10.3 {errors in exec invocation} {exec} {
d351 1
a351 1
test exec-10.4 {errors in exec invocation} {exec} {
d354 1
a354 1
test exec-10.5 {errors in exec invocation} {exec} {
d357 1
a357 1
test exec-10.6 {errors in exec invocation} {exec} {
d360 1
a360 1
test exec-10.7 {errors in exec invocation} {exec} {
d363 1
a363 1
test exec-10.8 {errors in exec invocation} {exec} {
d366 1
a366 1
test exec-10.9 {errors in exec invocation} {exec} {
d369 1
a369 1
test exec-10.10 {errors in exec invocation} {exec} {
d372 1
a372 1
test exec-10.11 {errors in exec invocation} {exec} {
d375 1
a375 1
test exec-10.12 {errors in exec invocation} {exec} {
d378 1
a378 1
test exec-10.13 {errors in exec invocation} {exec} {
d381 1
a381 1
test exec-10.14 {errors in exec invocation} {exec} {
d384 1
a384 1
test exec-10.15 {errors in exec invocation} {exec} {
d387 1
a387 1
test exec-10.16 {errors in exec invocation} {exec} {
d390 1
a390 1
test exec-10.17 {errors in exec invocation} {exec} {
d393 2
a394 2
set f [open $path(gorp.file) w]
test exec-10.18 {errors in exec invocation} {exec} {
d398 2
a399 2
set f [open $path(gorp.file) r]
test exec-10.19 {errors in exec invocation} {exec} {
d403 1
a403 1
test exec-10.20 {errors in exec invocation} {exec} {
d406 2
a407 2
test exec-10.21 {errors in exec invocation} {exec} {
    list [catch {exec [interpreter] true | ~xyzzy_bad_user/x | false} msg] $msg
d412 2
a413 2
test exec-11.1 {commands in background} {exec} {
    set x [lindex [time {exec [interpreter] $path(sleep) 2 &}] 0]
d416 2
a417 2
test exec-11.2 {commands in background} {exec} {
    list [catch {exec [interpreter] $path(echo) a &b} msg] $msg
d419 2
a420 2
test exec-11.3 {commands in background} {exec} {
    llength [exec [interpreter] $path(sleep) 1 &]
d422 2
a423 2
test exec-11.4 {commands in background} {exec stdio} {
    llength [exec [interpreter] $path(sleep) 1 | [interpreter] $path(sleep) 1 | [interpreter] $path(sleep) 1 &]
d425 3
a427 3
test exec-11.5 {commands in background} {exec} {
    set f [open $path(gorp.file) w]
    puts $f [format { catch { exec [info nameofexecutable] %s foo & } } $path(echo)]
d429 1
a429 1
    string compare "foo" [exec [interpreter] $path(gorp.file)]
d435 1
a435 3
if { [set ::tcltest::testConstraints(exec)] } {
exec [interpreter] $path(sleep) 3
}
d437 1
a437 1
	{exec unixOnly nonPortable} {
d446 1
a446 1
	{exec unixOnly nonPortable} {
d455 1
a455 1
	{exec unixOnly nonPortable} {
d478 2
a479 2
test exec-13.1 {setting errorCode variable} {exec} {
    list [catch {exec [interpreter] $path(cat) < a/b/c} msg] [string tolower $errorCode]
d481 2
a482 2
test exec-13.2 {setting errorCode variable} {exec} {
    list [catch {exec [interpreter] $path(cat) > a/b/c} msg] [string tolower $errorCode]
d484 1
a484 1
test exec-13.3 {setting errorCode variable} {exec} {
d492 2
a493 2
test exec-14.1 {-keepnewline switch} {exec} {
    exec -keepnewline [interpreter] $path(echo) foo
d495 1
a495 1
test exec-14.2 {-keepnewline switch} {exec} {
d498 1
a498 1
test exec-14.3 {unknown switch} {exec} {
d501 1
a501 1
test exec-14.4 {-- switch} {exec} {
d507 4
a510 4
test exec-15.1 {standard error redirection} {exec} {
    exec [interpreter] $path(echo) "First line" > $path(gorp.file)
    list [exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" 2> $path(gorp.file)] \
	    [exec [interpreter] $path(cat) $path(gorp.file)]
d512 5
a516 5
test exec-15.2 {standard error redirection} {exec stdio} {
    list [exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" \
		| [interpreter] $path(echo) biz baz >$path(gorp.file) 2> $path(gorp.file2)] \
	    [exec [interpreter] $path(cat) $path(gorp.file)] \
	    [exec [interpreter] $path(cat) $path(gorp.file2)]
d518 5
a522 5
test exec-15.3 {standard error redirection} {exec stdio} {
    list [exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" \
	        | [interpreter] $path(echo) biz baz 2>$path(gorp.file) > $path(gorp.file2)] \
	    [exec [interpreter] $path(cat) $path(gorp.file)] \
	    [exec [interpreter] $path(cat) $path(gorp.file2)]
d524 2
a525 2
test exec-15.4 {standard error redirection} {exec} {
    set f [open $path(gorp.file) w]
d528 1
a528 1
    exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" 2>@@ $f
d531 1
a531 1
    exec [interpreter] $path(cat) $path(gorp.file)
d535 4
a538 4
test exec-15.5 {standard error redirection} {exec} {
    exec [interpreter] $path(echo) "First line" > $path(gorp.file)
    exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" 2>> $path(gorp.file)
    exec [interpreter] $path(cat) $path(gorp.file)
d541 4
a544 4
test exec-15.6 {standard error redirection} {exec stdio} {
    exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" > $path(gorp.file2) 2> $path(gorp.file) \
	    >& $path(gorp.file) 2> $path(gorp.file2) | [interpreter] $path(echo) biz baz
    list [exec [interpreter] $path(cat) $path(gorp.file)] [exec [interpreter] $path(cat) $path(gorp.file2)]
d547 2
a548 2
test exec-16.1 {flush output before exec} {exec} {
    set f [open $path(gorp.file) w]
d550 1
a550 1
    exec [interpreter] $path(echo) "Second line" >@@ $f
d553 1
a553 1
    exec [interpreter] $path(cat) $path(gorp.file)
d557 2
a558 2
test exec-16.2 {flush output before exec} {exec} {
    set f [open $path(gorp.file) w]
d560 1
a560 1
    exec [interpreter] << {puts stderr {Second line}} >&@@ $f > $path(gorp.file2)
d563 1
a563 1
    exec [interpreter] $path(cat) $path(gorp.file)
d568 6
a573 8
set path(script) [makeFile {} script]

test exec-17.1 { inheriting standard I/O } {exec} {
    set f [open $path(script) w]
    puts $f [format {close stdout
	set f [open %s w]
	catch {exec [info nameofexecutable] %s foobar &}
	exec [info nameofexecutable] %s 2
d575 1
a575 1
    } $path(gorp.file) $path(echo) $path(sleep)]
d577 2
a578 2
    catch {exec [interpreter] $path(script)} result
    set f [open $path(gorp.file) r]
d585 16
a600 12
test exec-18.1 { exec cat deals with weird file names} {exec unixOnly} {
    # This is cross-platform, but the cat isn't predictably correct on
    # Windows.
    set f "foo\[\{blah"
    set path(fooblah) [makeFile {} $f]
    set fout [open $path(fooblah) w]
    puts $fout "contents"
    close $fout
    set res [list [catch {exec cat $path(fooblah)} msg] $msg]
    removeFile $f
    set res
} {0 contents}
a601 1
# cleanup
a602 3
foreach file {script gorp.file gorp.file2 echo cat wc sh sleep exit err} {
	removeFile $file
}
a603 2
::tcltest::cleanupTests
return
@


1.2
log
@touched all Tcl files to ease next import.
@
text
@@


1.2.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.2.16.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d16 4
a19 2
package require tcltest 2
namespace import -force ::tcltest::*
d23 1
a23 1
testConstraint exec [llength [info commands exec]]
d25 2
a26 1
set path(echo) [makeFile {
d33 2
a34 1
} echo]
d36 2
a37 1
set path(cat) [makeFile {
d56 2
a57 1
} cat]
d59 2
a60 1
set path(wc) [makeFile {
d67 2
a68 1
} wc]
d70 2
a71 1
set path(sh) [makeFile {
d92 2
a93 1
} sh]
d95 2
a96 1
set path(sleep) [makeFile {
d99 2
a100 1
} sleep]
d102 2
a103 1
set path(exit) [makeFile {
d105 2
a106 1
} exit]
d110 2
a111 2
test exec-1.1 {basic exec operation} {exec} {
    exec [interpreter] $path(echo) a b c
d113 2
a114 2
test exec-1.2 {pipelining} {exec stdio} {
    exec [interpreter] $path(echo) a b c d | [interpreter] $path(cat) | [interpreter] $path(cat)
d116 2
a117 2
test exec-1.3 {pipelining} {exec stdio} {
    set a [exec [interpreter] $path(echo) a b c d | [interpreter] $path(cat) | [interpreter] $path(wc)]
d122 2
a123 2
test exec-1.4 {long command lines} {exec} {
    exec [interpreter] $path(echo) $arg
d129 2
a130 2
test exec-2.1 {redirecting input from immediate source} {exec stdio} {
    exec [interpreter] $path(cat) << "Sample text"
d132 2
a133 2
test exec-2.2 {redirecting input from immediate source} {exec stdio} {
    exec << "Sample text" [interpreter] $path(cat) | [interpreter] $path(cat)
d135 2
a136 2
test exec-2.3 {redirecting input from immediate source} {exec stdio} {
    exec [interpreter] $path(cat) << "Sample text" | [interpreter] $path(cat)
d138 2
a139 2
test exec-2.4 {redirecting input from immediate source} {exec stdio} {
    exec [interpreter] $path(cat) | [interpreter] $path(cat) << "Sample text"
d141 2
a142 2
test exec-2.5 {redirecting input from immediate source} {exec} {
    exec [interpreter] $path(cat) "<<Joined to arrows"
d144 1
a144 1
test exec-2.6 {redirecting input from immediate source, with UTF} {exec} {
d149 1
a149 1
    exec [interpreter] $path(cat) << "\uE9\uE0\uFC\uF1"
d154 4
a157 6
set path(gorp.file) [makeFile {} gorp.file]
removeFile gorp.file

test exec-3.1 {redirecting output to file} {exec} {
    exec [interpreter] $path(echo) "Some simple words" > $path(gorp.file)
    exec [interpreter] $path(cat) $path(gorp.file)
d159 3
a161 3
test exec-3.2 {redirecting output to file} {exec stdio} {
    exec [interpreter] $path(echo) "More simple words" | >$path(gorp.file) [interpreter] $path(cat) | [interpreter] $path(cat)
    exec [interpreter] $path(cat) $path(gorp.file)
d163 3
a165 3
test exec-3.3 {redirecting output to file} {exec stdio} {
    exec > $path(gorp.file) [interpreter] $path(echo) "Different simple words" | [interpreter] $path(cat) | [interpreter] $path(cat)
    exec [interpreter] $path(cat) $path(gorp.file)
d167 3
a169 3
test exec-3.4 {redirecting output to file} {exec} {
    exec [interpreter] $path(echo) "Some simple words" >$path(gorp.file)
    exec [interpreter] $path(cat) $path(gorp.file)
d171 4
a174 4
test exec-3.5 {redirecting output to file} {exec} {
    exec [interpreter] $path(echo) "First line" >$path(gorp.file)
    exec [interpreter] $path(echo) "Second line" >> $path(gorp.file)
    exec [interpreter] $path(cat) $path(gorp.file)
d176 4
a179 4
test exec-3.6 {redirecting output to file} {exec} {
    exec [interpreter] $path(echo) "First line" >$path(gorp.file)
    exec [interpreter] $path(echo) "Second line" >>$path(gorp.file)
    exec [interpreter] $path(cat) $path(gorp.file)
d181 2
a182 2
test exec-3.7 {redirecting output to file} {exec} {
    set f [open $path(gorp.file) w]
d185 2
a186 2
    exec [interpreter] $path(echo) "More text" >@@ $f
    exec [interpreter] $path(echo) >@@$f "Even more"
d189 1
a189 1
    exec [interpreter] $path(cat) $path(gorp.file)
d194 4
a197 5
removeFile gorp.file

test exec-4.1 {redirecting output and stderr to file} {exec} {
    exec [interpreter] $path(echo) "test output" >& $path(gorp.file)
    exec [interpreter] $path(cat) $path(gorp.file)
d199 3
a201 3
test exec-4.2 {redirecting output and stderr to file} {exec} {
    list [exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" >&$path(gorp.file)] \
	    [exec [interpreter] $path(cat) $path(gorp.file)]
d203 4
a206 4
test exec-4.3 {redirecting output and stderr to file} {exec} {
    exec [interpreter] $path(echo) "first line" > $path(gorp.file)
    list [exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" >>&$path(gorp.file)] \
	    [exec [interpreter] $path(cat) $path(gorp.file)]
d208 2
a209 2
test exec-4.4 {redirecting output and stderr to file} {exec} {
    set f [open $path(gorp.file) w]
d212 2
a213 2
    exec [interpreter] $path(echo) "More text" >&@@ $f
    exec [interpreter] $path(echo) >&@@$f "Even more"
d216 1
a216 1
    exec [interpreter] $path(cat) $path(gorp.file)
d218 2
a219 2
test exec-4.5 {redirecting output and stderr to file} {exec} {
    set f [open $path(gorp.file) w]
d222 2
a223 2
    exec >&@@ $f [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2"
    exec >&@@$f [interpreter] $path(sh) -c "$path(echo) xyzzy 1>&2"
d226 1
a226 1
    exec [interpreter] $path(cat) $path(gorp.file)
d231 3
a233 5
if { [set ::tcltest::testConstraints(exec)] } {
exec [interpreter] $path(echo) "Just a few thoughts" > $path(gorp.file)
}
test exec-5.1 {redirecting input from file} {exec} {
    exec [interpreter] $path(cat) < $path(gorp.file)
d235 2
a236 2
test exec-5.2 {redirecting input from file} {exec stdio} {
    exec [interpreter] $path(cat) | [interpreter] $path(cat) < $path(gorp.file)
d238 2
a239 2
test exec-5.3 {redirecting input from file} {exec stdio} {
    exec [interpreter] $path(cat) < $path(gorp.file) | [interpreter] $path(cat)
d241 2
a242 2
test exec-5.4 {redirecting input from file} {exec stdio} {
    exec < $path(gorp.file) [interpreter] $path(cat) | [interpreter] $path(cat)
d244 2
a245 2
test exec-5.5 {redirecting input from file} {exec} {
    exec [interpreter] $path(cat) <$path(gorp.file)
d247 3
a249 3
test exec-5.6 {redirecting input from file} {exec} {
    set f [open $path(gorp.file) r]
    set result [exec [interpreter] $path(cat) <@@ $f]
d253 3
a255 3
test exec-5.7 {redirecting input from file} {exec} {
    set f [open $path(gorp.file) r]
    set result [exec <@@$f [interpreter] $path(cat)]
d262 2
a263 2
test exec-6.1 {redirecting stderr through a pipeline} {exec stdio} {
    exec [interpreter] $path(sh) -c "$path(echo) foo bar" |& [interpreter] $path(cat)
d265 2
a266 2
test exec-6.2 {redirecting stderr through a pipeline} {exec stdio} {
    exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" |& [interpreter] $path(cat)
d268 3
a270 3
test exec-6.3 {redirecting stderr through a pipeline} {exec stdio} {
    exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" \
	|& [interpreter] $path(sh) -c "$path(echo) second msg 1>&2 ; $path(cat)" |& [interpreter] $path(cat)
d275 4
a278 6
set path(gorp.file2) [makeFile {} gorp.file2]
removeFile gorp.file2

test exec-7.1 {multiple I/O redirections} {exec} {
    exec << "command input" > $path(gorp.file2) [interpreter] $path(cat) < $path(gorp.file)
    exec [interpreter] $path(cat) $path(gorp.file2)
d280 2
a281 2
test exec-7.2 {multiple I/O redirections} {exec} {
    exec < $path(gorp.file) << "command input" [interpreter] $path(cat)
d291 2
a292 2
test exec-8.1 {long input and output} {exec} {
    exec [interpreter] $path(cat) << $a
d297 2
a298 2
test exec-8.2 {long input and output} {exec} {
    exec [interpreter] $path(echo) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
d303 1
a303 1
test exec-9.1 {commands returning errors} {exec} {
d307 2
a308 2
test exec-9.2 {commands returning errors} {exec} {
    string tolower [list [catch {exec [interpreter] echo foo | foo123} msg] $msg $errorCode]
d310 2
a311 2
test exec-9.3 {commands returning errors} {exec stdio} {
    list [catch {exec [interpreter] $path(sleep) 1 | [interpreter] $path(exit) 43 | [interpreter] $path(sleep) 1} msg] $msg
d313 2
a314 2
test exec-9.4 {commands returning errors} {exec stdio} {
    list [catch {exec [interpreter] $path(exit) 43 | [interpreter] $path(echo) "foo bar"} msg] $msg
d317 2
a318 2
test exec-9.5 {commands returning errors} {exec stdio} {
    list [catch {exec gorp456 | [interpreter] echo a b c} msg] [string tolower $msg]
d320 2
a321 2
test exec-9.6 {commands returning errors} {exec} {
    list [catch {exec [interpreter] $path(sh) -c "$path(echo) error msg 1>&2"} msg] $msg
d323 3
a325 3
test exec-9.7 {commands returning errors} {exec stdio} {
    list [catch {exec [interpreter] $path(sh) -c "$path(echo) error msg 1>&2" \
		     | [interpreter] $path(sh) -c "$path(echo) error msg 1>&2"} msg] $msg
d328 2
a329 5

set path(err) [makeFile {} err]

test exec-9.8 {commands returning errors} {exec} {
    set f [open $path(err) w]
d335 1
a335 1
    list [catch {exec [interpreter] $path(err)} msg] $msg
d342 1
a342 1
test exec-10.1 {errors in exec invocation} {exec} {
d345 1
a345 1
test exec-10.2 {errors in exec invocation} {exec} {
d348 1
a348 1
test exec-10.3 {errors in exec invocation} {exec} {
d351 1
a351 1
test exec-10.4 {errors in exec invocation} {exec} {
d354 1
a354 1
test exec-10.5 {errors in exec invocation} {exec} {
d357 1
a357 1
test exec-10.6 {errors in exec invocation} {exec} {
d360 1
a360 1
test exec-10.7 {errors in exec invocation} {exec} {
d363 1
a363 1
test exec-10.8 {errors in exec invocation} {exec} {
d366 1
a366 1
test exec-10.9 {errors in exec invocation} {exec} {
d369 1
a369 1
test exec-10.10 {errors in exec invocation} {exec} {
d372 1
a372 1
test exec-10.11 {errors in exec invocation} {exec} {
d375 1
a375 1
test exec-10.12 {errors in exec invocation} {exec} {
d378 1
a378 1
test exec-10.13 {errors in exec invocation} {exec} {
d381 1
a381 1
test exec-10.14 {errors in exec invocation} {exec} {
d384 1
a384 1
test exec-10.15 {errors in exec invocation} {exec} {
d387 1
a387 1
test exec-10.16 {errors in exec invocation} {exec} {
d390 1
a390 1
test exec-10.17 {errors in exec invocation} {exec} {
d393 2
a394 2
set f [open $path(gorp.file) w]
test exec-10.18 {errors in exec invocation} {exec} {
d398 2
a399 2
set f [open $path(gorp.file) r]
test exec-10.19 {errors in exec invocation} {exec} {
d403 1
a403 1
test exec-10.20 {errors in exec invocation} {exec} {
d406 2
a407 2
test exec-10.21 {errors in exec invocation} {exec} {
    list [catch {exec [interpreter] true | ~xyzzy_bad_user/x | false} msg] $msg
d412 2
a413 2
test exec-11.1 {commands in background} {exec} {
    set x [lindex [time {exec [interpreter] $path(sleep) 2 &}] 0]
d416 2
a417 2
test exec-11.2 {commands in background} {exec} {
    list [catch {exec [interpreter] $path(echo) a &b} msg] $msg
d419 2
a420 2
test exec-11.3 {commands in background} {exec} {
    llength [exec [interpreter] $path(sleep) 1 &]
d422 2
a423 2
test exec-11.4 {commands in background} {exec stdio} {
    llength [exec [interpreter] $path(sleep) 1 | [interpreter] $path(sleep) 1 | [interpreter] $path(sleep) 1 &]
d425 3
a427 3
test exec-11.5 {commands in background} {exec} {
    set f [open $path(gorp.file) w]
    puts $f [format { catch { exec [info nameofexecutable] %s foo & } } $path(echo)]
d429 1
a429 1
    string compare "foo" [exec [interpreter] $path(gorp.file)]
d435 1
a435 3
if { [set ::tcltest::testConstraints(exec)] } {
exec [interpreter] $path(sleep) 3
}
d437 1
a437 1
	{exec unixOnly nonPortable} {
d446 1
a446 1
	{exec unixOnly nonPortable} {
d455 1
a455 1
	{exec unixOnly nonPortable} {
d478 2
a479 2
test exec-13.1 {setting errorCode variable} {exec} {
    list [catch {exec [interpreter] $path(cat) < a/b/c} msg] [string tolower $errorCode]
d481 2
a482 2
test exec-13.2 {setting errorCode variable} {exec} {
    list [catch {exec [interpreter] $path(cat) > a/b/c} msg] [string tolower $errorCode]
d484 1
a484 1
test exec-13.3 {setting errorCode variable} {exec} {
d492 2
a493 2
test exec-14.1 {-keepnewline switch} {exec} {
    exec -keepnewline [interpreter] $path(echo) foo
d495 1
a495 1
test exec-14.2 {-keepnewline switch} {exec} {
d498 1
a498 1
test exec-14.3 {unknown switch} {exec} {
d501 1
a501 1
test exec-14.4 {-- switch} {exec} {
d507 4
a510 4
test exec-15.1 {standard error redirection} {exec} {
    exec [interpreter] $path(echo) "First line" > $path(gorp.file)
    list [exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" 2> $path(gorp.file)] \
	    [exec [interpreter] $path(cat) $path(gorp.file)]
d512 5
a516 5
test exec-15.2 {standard error redirection} {exec stdio} {
    list [exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" \
		| [interpreter] $path(echo) biz baz >$path(gorp.file) 2> $path(gorp.file2)] \
	    [exec [interpreter] $path(cat) $path(gorp.file)] \
	    [exec [interpreter] $path(cat) $path(gorp.file2)]
d518 5
a522 5
test exec-15.3 {standard error redirection} {exec stdio} {
    list [exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" \
	        | [interpreter] $path(echo) biz baz 2>$path(gorp.file) > $path(gorp.file2)] \
	    [exec [interpreter] $path(cat) $path(gorp.file)] \
	    [exec [interpreter] $path(cat) $path(gorp.file2)]
d524 2
a525 2
test exec-15.4 {standard error redirection} {exec} {
    set f [open $path(gorp.file) w]
d528 1
a528 1
    exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" 2>@@ $f
d531 1
a531 1
    exec [interpreter] $path(cat) $path(gorp.file)
d535 4
a538 4
test exec-15.5 {standard error redirection} {exec} {
    exec [interpreter] $path(echo) "First line" > $path(gorp.file)
    exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" 2>> $path(gorp.file)
    exec [interpreter] $path(cat) $path(gorp.file)
d541 4
a544 4
test exec-15.6 {standard error redirection} {exec stdio} {
    exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" > $path(gorp.file2) 2> $path(gorp.file) \
	    >& $path(gorp.file) 2> $path(gorp.file2) | [interpreter] $path(echo) biz baz
    list [exec [interpreter] $path(cat) $path(gorp.file)] [exec [interpreter] $path(cat) $path(gorp.file2)]
d547 2
a548 2
test exec-16.1 {flush output before exec} {exec} {
    set f [open $path(gorp.file) w]
d550 1
a550 1
    exec [interpreter] $path(echo) "Second line" >@@ $f
d553 1
a553 1
    exec [interpreter] $path(cat) $path(gorp.file)
d557 2
a558 2
test exec-16.2 {flush output before exec} {exec} {
    set f [open $path(gorp.file) w]
d560 1
a560 1
    exec [interpreter] << {puts stderr {Second line}} >&@@ $f > $path(gorp.file2)
d563 1
a563 1
    exec [interpreter] $path(cat) $path(gorp.file)
d568 6
a573 8
set path(script) [makeFile {} script]

test exec-17.1 { inheriting standard I/O } {exec} {
    set f [open $path(script) w]
    puts $f [format {close stdout
	set f [open %s w]
	catch {exec [info nameofexecutable] %s foobar &}
	exec [info nameofexecutable] %s 2
d575 1
a575 1
    } $path(gorp.file) $path(echo) $path(sleep)]
d577 2
a578 2
    catch {exec [interpreter] $path(script)} result
    set f [open $path(gorp.file) r]
d585 16
a600 12
test exec-18.1 { exec cat deals with weird file names} {exec unixOnly} {
    # This is cross-platform, but the cat isn't predictably correct on
    # Windows.
    set f "foo\[\{blah"
    set path(fooblah) [makeFile {} $f]
    set fout [open $path(fooblah) w]
    puts $fout "contents"
    close $fout
    set res [list [catch {exec cat $path(fooblah)} msg] $msg]
    removeFile $f
    set res
} {0 contents}
a601 1
# cleanup
a602 3
foreach file {script gorp.file gorp.file2 echo cat wc sh sleep exit err} {
	removeFile $file
}
a603 2
::tcltest::cleanupTests
return
@


1.1
log
@Initial revision
@
text
@d9 1
d14 1
a14 1
# RCS: @@(#) $Id: exec.test,v 1.2 1998/09/14 18:40:08 stanton Exp $
d16 4
a19 1
if {[string compare test [info procs test]] == 1} then {source defs}
d21 3
a23 9
# If exec is not defined just return with no error
# Some platforms like the Macintosh do not have the exec command
if {[info commands exec] == ""} {
    puts "exec not implemented for this machine"
    return
}
if {$testConfig(stdio) == 0} {
    return
}
d32 1
d55 1
d66 1
d91 1
d98 1
d110 2
a111 2
test exec-1.1 {basic exec operation} {
    exec $tcltest echo a b c
d113 2
a114 2
test exec-1.2 {pipelining} {
    exec $tcltest echo a b c d | $tcltest cat | $tcltest cat
d116 2
a117 2
test exec-1.3 {pipelining} {
    set a [exec $tcltest echo a b c d | $tcltest cat | $tcltest wc]
d122 2
a123 2
test exec-1.4 {long command lines} {
    exec $tcltest echo $arg
d129 2
a130 2
test exec-2.1 {redirecting input from immediate source} {
    exec $tcltest cat << "Sample text"
d132 2
a133 2
test exec-2.2 {redirecting input from immediate source} {
    exec << "Sample text" $tcltest cat | $tcltest cat
d135 2
a136 2
test exec-2.3 {redirecting input from immediate source} {
    exec $tcltest cat << "Sample text" | $tcltest cat
d138 2
a139 2
test exec-2.4 {redirecting input from immediate source} {
    exec $tcltest cat | $tcltest cat << "Sample text"
d141 2
a142 2
test exec-2.5 {redirecting input from immediate source} {
    exec $tcltest cat "<<Joined to arrows"
d144 7
d155 3
a157 3
test exec-3.1 {redirecting output to file} {
    exec $tcltest echo "Some simple words" > gorp.file
    exec $tcltest cat gorp.file
d159 3
a161 3
test exec-3.2 {redirecting output to file} {
    exec $tcltest echo "More simple words" | >gorp.file $tcltest cat | $tcltest cat
    exec $tcltest cat gorp.file
d163 3
a165 3
test exec-3.3 {redirecting output to file} {
    exec > gorp.file $tcltest echo "Different simple words" | $tcltest cat | $tcltest cat
    exec $tcltest cat gorp.file
d167 3
a169 3
test exec-3.4 {redirecting output to file} {
    exec $tcltest echo "Some simple words" >gorp.file
    exec $tcltest cat gorp.file
d171 4
a174 4
test exec-3.5 {redirecting output to file} {
    exec $tcltest echo "First line" >gorp.file
    exec $tcltest echo "Second line" >> gorp.file
    exec $tcltest cat gorp.file
d176 4
a179 4
test exec-3.6 {redirecting output to file} {
    exec $tcltest echo "First line" >gorp.file
    exec $tcltest echo "Second line" >>gorp.file
    exec $tcltest cat gorp.file
d181 1
a181 1
test exec-3.7 {redirecting output to file} {
d185 2
a186 2
    exec $tcltest echo "More text" >@@ $f
    exec $tcltest echo >@@$f "Even more"
d189 1
a189 1
    exec $tcltest cat gorp.file
d195 3
a197 3
test exec-4.1 {redirecting output and stderr to file} {
    exec $tcltest echo "test output" >& gorp.file
    exec $tcltest cat gorp.file
d199 3
a201 3
test exec-4.2 {redirecting output and stderr to file} {
    list [exec $tcltest sh -c "echo foo bar 1>&2" >&gorp.file] \
	    [exec $tcltest cat gorp.file]
d203 4
a206 4
test exec-4.3 {redirecting output and stderr to file} {
    exec $tcltest echo "first line" > gorp.file
    list [exec $tcltest sh -c "echo foo bar 1>&2" >>&gorp.file] \
	    [exec $tcltest cat gorp.file]
d208 1
a208 1
test exec-4.4 {redirecting output and stderr to file} {
d212 2
a213 2
    exec $tcltest echo "More text" >&@@ $f
    exec $tcltest echo >&@@$f "Even more"
d216 1
a216 1
    exec $tcltest cat gorp.file
d218 1
a218 1
test exec-4.5 {redirecting output and stderr to file} {
d222 2
a223 2
    exec >&@@ $f $tcltest sh -c "echo foo bar 1>&2"
    exec >&@@$f $tcltest sh -c "echo xyzzy 1>&2"
d226 1
a226 1
    exec $tcltest cat gorp.file
d231 3
a233 3
exec $tcltest echo "Just a few thoughts" > gorp.file
test exec-5.1 {redirecting input from file} {
    exec $tcltest cat < gorp.file
d235 2
a236 2
test exec-5.2 {redirecting input from file} {
    exec $tcltest cat | $tcltest cat < gorp.file
d238 2
a239 2
test exec-5.3 {redirecting input from file} {
    exec $tcltest cat < gorp.file | $tcltest cat
d241 2
a242 2
test exec-5.4 {redirecting input from file} {
    exec < gorp.file $tcltest cat | $tcltest cat
d244 2
a245 2
test exec-5.5 {redirecting input from file} {
    exec $tcltest cat <gorp.file
d247 1
a247 1
test exec-5.6 {redirecting input from file} {
d249 1
a249 1
    set result [exec $tcltest cat <@@ $f]
d253 1
a253 1
test exec-5.7 {redirecting input from file} {
d255 1
a255 1
    set result [exec <@@$f $tcltest cat]
d262 2
a263 2
test exec-6.1 {redirecting stderr through a pipeline} {
    exec $tcltest sh -c "echo foo bar" |& $tcltest cat
d265 2
a266 2
test exec-6.2 {redirecting stderr through a pipeline} {
    exec $tcltest sh -c "echo foo bar 1>&2" |& $tcltest cat
d268 3
a270 3
test exec-6.3 {redirecting stderr through a pipeline} {
    exec $tcltest sh -c "echo foo bar 1>&2" \
	|& $tcltest sh -c "echo second msg 1>&2 ; cat" |& $tcltest cat
d275 4
a278 4
catch {exec rm -f gorp.file2}
test exec-7.1 {multiple I/O redirections} {
    exec << "command input" > gorp.file2 $tcltest cat < gorp.file
    exec $tcltest cat gorp.file2
d280 2
a281 2
test exec-7.2 {multiple I/O redirections} {
    exec < gorp.file << "command input" $tcltest cat
d291 2
a292 2
test exec-8.1 {long input and output} {
    exec $tcltest cat << $a
d295 6
d303 1
a303 1
test exec-9.1 {commands returning errors} {
d307 2
a308 2
test exec-9.2 {commands returning errors} {
    string tolower [list [catch {exec $tcltest echo foo | foo123} msg] $msg $errorCode]
d310 2
a311 2
test exec-9.3 {commands returning errors} {
    list [catch {exec $tcltest sleep 1 | $tcltest exit 43 | $tcltest sleep 1} msg] $msg
d313 2
a314 2
test exec-9.4 {commands returning errors} {
    list [catch {exec $tcltest exit 43 | $tcltest echo "foo bar"} msg] $msg
d317 2
a318 2
test exec-9.5 {commands returning errors} {
    list [catch {exec gorp456 | $tcltest echo a b c} msg] [string tolower $msg]
d320 2
a321 2
test exec-9.6 {commands returning errors} {
    list [catch {exec $tcltest sh -c "echo error msg 1>&2"} msg] $msg
d323 3
a325 3
test exec-9.7 {commands returning errors} {
    list [catch {exec $tcltest sh -c "echo error msg 1>&2" \
		     | $tcltest sh -c "echo error msg 1>&2"} msg] $msg
d328 10
d342 1
a342 1
test exec-10.1 {errors in exec invocation} {
d345 1
a345 1
test exec-10.2 {errors in exec invocation} {
d348 1
a348 1
test exec-10.3 {errors in exec invocation} {
d351 1
a351 1
test exec-10.4 {errors in exec invocation} {
d354 1
a354 1
test exec-10.5 {errors in exec invocation} {
d357 1
a357 1
test exec-10.6 {errors in exec invocation} {
d360 1
a360 1
test exec-10.7 {errors in exec invocation} {
d363 1
a363 1
test exec-10.8 {errors in exec invocation} {
d366 1
a366 1
test exec-10.9 {errors in exec invocation} {
d369 1
a369 1
test exec-10.10 {errors in exec invocation} {
d372 1
a372 1
test exec-10.11 {errors in exec invocation} {
d375 1
a375 1
test exec-10.12 {errors in exec invocation} {
d378 1
a378 1
test exec-10.13 {errors in exec invocation} {
d381 1
a381 1
test exec-10.14 {errors in exec invocation} {
d384 1
a384 1
test exec-10.15 {errors in exec invocation} {
d387 1
a387 1
test exec-10.16 {errors in exec invocation} {
d390 1
a390 1
test exec-10.17 {errors in exec invocation} {
d394 1
a394 1
test exec-10.18 {errors in exec invocation} {
d399 1
a399 1
test exec-10.19 {errors in exec invocation} {
d403 1
a403 1
test exec-10.20 {errors in exec invocation} {
d406 2
a407 2
test exec-10.21 {errors in exec invocation} {
    list [catch {exec $tcltest true | ~xyzzy_bad_user/x | false} msg] $msg
d412 2
a413 2
test exec-11.1 {commands in background} {
    set x [lindex [time {exec $tcltest sleep 2 &}] 0]
d416 2
a417 2
test exec-11.2 {commands in background} {
    list [catch {exec $tcltest echo a &b} msg] $msg
d419 2
a420 2
test exec-11.3 {commands in background} {
    llength [exec $tcltest sleep 1 &]
d422 2
a423 2
test exec-11.4 {commands in background} {
    llength [exec $tcltest sleep 1 | $tcltest sleep 1 | $tcltest sleep 1 &]
d425 1
a425 1
test exec-11.5 {commands in background} {
d429 1
a429 1
    string compare "foo" [exec $tcltest gorp.file]
d435 3
a437 2
exec $tcltest sleep 3
test exec-12.1 {reaping background processes} {unixOnly nonPortable} {
d445 2
a446 1
test exec-12.2 {reaping background processes} {unixOnly nonPortable} {
d454 2
a455 1
test exec-12.3 {reaping background processes} {unixOnly nonPortable} {
d478 2
a479 2
test exec-13.1 {setting errorCode variable} {
    list [catch {exec $tcltest cat < a/b/c} msg] [string tolower $errorCode]
d481 2
a482 2
test exec-13.2 {setting errorCode variable} {
    list [catch {exec $tcltest cat > a/b/c} msg] [string tolower $errorCode]
d484 1
a484 1
test exec-13.3 {setting errorCode variable} {
d492 2
a493 2
test exec-14.1 {-keepnewline switch} {
    exec -keepnewline $tcltest echo foo
d495 1
a495 1
test exec-14.2 {-keepnewline switch} {
d498 1
a498 1
test exec-14.3 {unknown switch} {
d501 1
a501 1
test exec-14.4 {-- switch} {
d507 4
a510 4
test exec-15.1 {standard error redirection} {
    exec $tcltest echo "First line" > gorp.file
    list [exec $tcltest sh -c "echo foo bar 1>&2" 2> gorp.file] \
	    [exec $tcltest cat gorp.file]
d512 5
a516 5
test exec-15.2 {standard error redirection} {
    list [exec $tcltest sh -c "echo foo bar 1>&2" \
		| $tcltest echo biz baz >gorp.file 2> gorp.file2] \
	    [exec $tcltest cat gorp.file] \
	    [exec $tcltest cat gorp.file2]
d518 5
a522 5
test exec-15.3 {standard error redirection} {
    list [exec $tcltest sh -c "echo foo bar 1>&2" \
	        | $tcltest echo biz baz 2>gorp.file > gorp.file2] \
	    [exec $tcltest cat gorp.file] \
	    [exec $tcltest cat gorp.file2]
d524 1
a524 1
test exec-15.4 {standard error redirection} {
d528 1
a528 1
    exec $tcltest sh -c "echo foo bar 1>&2" 2>@@ $f
d531 1
a531 1
    exec $tcltest cat gorp.file
d535 4
a538 4
test exec-15.5 {standard error redirection} {
    exec $tcltest echo "First line" > gorp.file
    exec $tcltest sh -c "echo foo bar 1>&2" 2>> gorp.file
    exec $tcltest cat gorp.file
d541 4
a544 4
test exec-15.6 {standard error redirection} {
    exec $tcltest sh -c "echo foo bar 1>&2" > gorp.file2 2> gorp.file \
	    >& gorp.file 2> gorp.file2 | $tcltest echo biz baz
    list [exec $tcltest cat gorp.file] [exec $tcltest cat gorp.file2]
d547 1
a547 1
test exec-16.1 {flush output before exec} {
d550 1
a550 1
    exec $tcltest echo "Second line" >@@ $f
d553 1
a553 1
    exec $tcltest cat gorp.file
d557 1
a557 1
test exec-16.2 {flush output before exec} {} {
d560 1
a560 1
    exec $tcltest << {puts stderr {Second line}} >&@@ $f > gorp.file2
d563 1
a563 1
    exec $tcltest cat gorp.file
d568 1
a568 1
test exec-17.1 { inheriting standard I/O } {
d577 1
a577 1
    catch {exec $tcltest script} result
d585 1
d588 16
@


1.1.1.1
log
@import dejagnu-1999-11-08 snapshot
@
text
@@


1.1.1.2
log
@Tcl 8.3 upgrade
@
text
@a8 1
# Copyright (c) 1998-1999 by Scriptics Corporation.
d13 1
a13 1
# RCS: @@(#) $Id: exec.test,v 1.6.8.2 2000/09/15 16:56:20 spolk Exp $
d15 10
a24 3
if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import -force ::tcltest::*
a26 4
# All tests require the "exec" command.
# Skip them if exec is not defined.
set ::tcltest::testConstraints(execCommandExists) [expr {[info commands exec] != ""}]

a33 1
    exit
a55 1
    exit
a65 1
    exit
a89 1
    exit
a95 1
    exit
d107 2
a108 2
test exec-1.1 {basic exec operation} {execCommandExists stdio} {
    exec $::tcltest::tcltest echo a b c
d110 2
a111 2
test exec-1.2 {pipelining} {execCommandExists stdio} {
    exec $::tcltest::tcltest echo a b c d | $::tcltest::tcltest cat | $::tcltest::tcltest cat
d113 2
a114 2
test exec-1.3 {pipelining} {execCommandExists stdio} {
    set a [exec $::tcltest::tcltest echo a b c d | $::tcltest::tcltest cat | $::tcltest::tcltest wc]
d119 2
a120 2
test exec-1.4 {long command lines} {execCommandExists stdio} {
    exec $::tcltest::tcltest echo $arg
d126 2
a127 2
test exec-2.1 {redirecting input from immediate source} {execCommandExists stdio} {
    exec $::tcltest::tcltest cat << "Sample text"
d129 2
a130 2
test exec-2.2 {redirecting input from immediate source} {execCommandExists stdio} {
    exec << "Sample text" $::tcltest::tcltest cat | $::tcltest::tcltest cat
d132 2
a133 2
test exec-2.3 {redirecting input from immediate source} {execCommandExists stdio} {
    exec $::tcltest::tcltest cat << "Sample text" | $::tcltest::tcltest cat
d135 2
a136 2
test exec-2.4 {redirecting input from immediate source} {execCommandExists stdio} {
    exec $::tcltest::tcltest cat | $::tcltest::tcltest cat << "Sample text"
d138 2
a139 2
test exec-2.5 {redirecting input from immediate source} {execCommandExists stdio} {
    exec $::tcltest::tcltest cat "<<Joined to arrows"
a140 7
test exec-2.6 {redirecting input from immediate source, with UTF} {execCommandExists stdio} {
    # If this fails, it may give back:
    # "\uC3\uA9\uC3\uA0\uC3\uBC\uC3\uB1"
    # If it does, this means that the UTF -> external conversion did not 
    # occur before writing out the temp file.
    exec $::tcltest::tcltest cat << "\uE9\uE0\uFC\uF1"
} "\uE9\uE0\uFC\uF1"
d145 3
a147 3
test exec-3.1 {redirecting output to file} {execCommandExists stdio} {
    exec $::tcltest::tcltest echo "Some simple words" > gorp.file
    exec $::tcltest::tcltest cat gorp.file
d149 3
a151 3
test exec-3.2 {redirecting output to file} {execCommandExists stdio} {
    exec $::tcltest::tcltest echo "More simple words" | >gorp.file $::tcltest::tcltest cat | $::tcltest::tcltest cat
    exec $::tcltest::tcltest cat gorp.file
d153 3
a155 3
test exec-3.3 {redirecting output to file} {execCommandExists stdio} {
    exec > gorp.file $::tcltest::tcltest echo "Different simple words" | $::tcltest::tcltest cat | $::tcltest::tcltest cat
    exec $::tcltest::tcltest cat gorp.file
d157 3
a159 3
test exec-3.4 {redirecting output to file} {execCommandExists stdio} {
    exec $::tcltest::tcltest echo "Some simple words" >gorp.file
    exec $::tcltest::tcltest cat gorp.file
d161 4
a164 4
test exec-3.5 {redirecting output to file} {execCommandExists stdio} {
    exec $::tcltest::tcltest echo "First line" >gorp.file
    exec $::tcltest::tcltest echo "Second line" >> gorp.file
    exec $::tcltest::tcltest cat gorp.file
d166 4
a169 4
test exec-3.6 {redirecting output to file} {execCommandExists stdio} {
    exec $::tcltest::tcltest echo "First line" >gorp.file
    exec $::tcltest::tcltest echo "Second line" >>gorp.file
    exec $::tcltest::tcltest cat gorp.file
d171 1
a171 1
test exec-3.7 {redirecting output to file} {execCommandExists stdio} {
d175 2
a176 2
    exec $::tcltest::tcltest echo "More text" >@@ $f
    exec $::tcltest::tcltest echo >@@$f "Even more"
d179 1
a179 1
    exec $::tcltest::tcltest cat gorp.file
d185 3
a187 3
test exec-4.1 {redirecting output and stderr to file} {execCommandExists stdio} {
    exec $::tcltest::tcltest echo "test output" >& gorp.file
    exec $::tcltest::tcltest cat gorp.file
d189 3
a191 3
test exec-4.2 {redirecting output and stderr to file} {execCommandExists stdio} {
    list [exec $::tcltest::tcltest sh -c "echo foo bar 1>&2" >&gorp.file] \
	    [exec $::tcltest::tcltest cat gorp.file]
d193 4
a196 4
test exec-4.3 {redirecting output and stderr to file} {execCommandExists stdio} {
    exec $::tcltest::tcltest echo "first line" > gorp.file
    list [exec $::tcltest::tcltest sh -c "echo foo bar 1>&2" >>&gorp.file] \
	    [exec $::tcltest::tcltest cat gorp.file]
d198 1
a198 1
test exec-4.4 {redirecting output and stderr to file} {execCommandExists stdio} {
d202 2
a203 2
    exec $::tcltest::tcltest echo "More text" >&@@ $f
    exec $::tcltest::tcltest echo >&@@$f "Even more"
d206 1
a206 1
    exec $::tcltest::tcltest cat gorp.file
d208 1
a208 1
test exec-4.5 {redirecting output and stderr to file} {execCommandExists stdio} {
d212 2
a213 2
    exec >&@@ $f $::tcltest::tcltest sh -c "echo foo bar 1>&2"
    exec >&@@$f $::tcltest::tcltest sh -c "echo xyzzy 1>&2"
d216 1
a216 1
    exec $::tcltest::tcltest cat gorp.file
d221 3
a223 3
exec $::tcltest::tcltest echo "Just a few thoughts" > gorp.file
test exec-5.1 {redirecting input from file} {execCommandExists stdio} {
    exec $::tcltest::tcltest cat < gorp.file
d225 2
a226 2
test exec-5.2 {redirecting input from file} {execCommandExists stdio} {
    exec $::tcltest::tcltest cat | $::tcltest::tcltest cat < gorp.file
d228 2
a229 2
test exec-5.3 {redirecting input from file} {execCommandExists stdio} {
    exec $::tcltest::tcltest cat < gorp.file | $::tcltest::tcltest cat
d231 2
a232 2
test exec-5.4 {redirecting input from file} {execCommandExists stdio} {
    exec < gorp.file $::tcltest::tcltest cat | $::tcltest::tcltest cat
d234 2
a235 2
test exec-5.5 {redirecting input from file} {execCommandExists stdio} {
    exec $::tcltest::tcltest cat <gorp.file
d237 1
a237 1
test exec-5.6 {redirecting input from file} {execCommandExists stdio} {
d239 1
a239 1
    set result [exec $::tcltest::tcltest cat <@@ $f]
d243 1
a243 1
test exec-5.7 {redirecting input from file} {execCommandExists stdio} {
d245 1
a245 1
    set result [exec <@@$f $::tcltest::tcltest cat]
d252 2
a253 2
test exec-6.1 {redirecting stderr through a pipeline} {execCommandExists stdio} {
    exec $::tcltest::tcltest sh -c "echo foo bar" |& $::tcltest::tcltest cat
d255 2
a256 2
test exec-6.2 {redirecting stderr through a pipeline} {execCommandExists stdio} {
    exec $::tcltest::tcltest sh -c "echo foo bar 1>&2" |& $::tcltest::tcltest cat
d258 3
a260 3
test exec-6.3 {redirecting stderr through a pipeline} {execCommandExists stdio} {
    exec $::tcltest::tcltest sh -c "echo foo bar 1>&2" \
	|& $::tcltest::tcltest sh -c "echo second msg 1>&2 ; cat" |& $::tcltest::tcltest cat
d265 4
a268 4
file delete gorp.file2
test exec-7.1 {multiple I/O redirections} {execCommandExists stdio} {
    exec << "command input" > gorp.file2 $::tcltest::tcltest cat < gorp.file
    exec $::tcltest::tcltest cat gorp.file2
d270 2
a271 2
test exec-7.2 {multiple I/O redirections} {execCommandExists stdio} {
    exec < gorp.file << "command input" $::tcltest::tcltest cat
d281 2
a282 2
test exec-8.1 {long input and output} {execCommandExists stdio} {
    exec $::tcltest::tcltest cat << $a
a284 6
# More than 20 arguments to exec.

test exec-8.1 {long input and output} {execCommandExists stdio} {
    exec $::tcltest::tcltest echo 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
} {1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23}

d287 1
a287 1
test exec-9.1 {commands returning errors} {execCommandExists stdio} {
d291 2
a292 2
test exec-9.2 {commands returning errors} {execCommandExists stdio} {
    string tolower [list [catch {exec $::tcltest::tcltest echo foo | foo123} msg] $msg $errorCode]
d294 2
a295 2
test exec-9.3 {commands returning errors} {execCommandExists stdio} {
    list [catch {exec $::tcltest::tcltest sleep 1 | $::tcltest::tcltest exit 43 | $::tcltest::tcltest sleep 1} msg] $msg
d297 2
a298 2
test exec-9.4 {commands returning errors} {execCommandExists stdio} {
    list [catch {exec $::tcltest::tcltest exit 43 | $::tcltest::tcltest echo "foo bar"} msg] $msg
d301 2
a302 2
test exec-9.5 {commands returning errors} {execCommandExists stdio} {
    list [catch {exec gorp456 | $::tcltest::tcltest echo a b c} msg] [string tolower $msg]
d304 2
a305 2
test exec-9.6 {commands returning errors} {execCommandExists stdio} {
    list [catch {exec $::tcltest::tcltest sh -c "echo error msg 1>&2"} msg] $msg
d307 3
a309 3
test exec-9.7 {commands returning errors} {execCommandExists stdio} {
    list [catch {exec $::tcltest::tcltest sh -c "echo error msg 1>&2" \
		     | $::tcltest::tcltest sh -c "echo error msg 1>&2"} msg] $msg
a311 10
test exec-9.8 {commands returning errors} {execCommandExists stdio} {
    set f [open err w]
    puts $f {
	puts stdout out
	puts stderr err
    }
    close $f
    list [catch {exec $::tcltest::tcltest err} msg] $msg
} {1 {out
err}}
d316 1
a316 1
test exec-10.1 {errors in exec invocation} {execCommandExists stdio} {
d319 1
a319 1
test exec-10.2 {errors in exec invocation} {execCommandExists stdio} {
d322 1
a322 1
test exec-10.3 {errors in exec invocation} {execCommandExists stdio} {
d325 1
a325 1
test exec-10.4 {errors in exec invocation} {execCommandExists stdio} {
d328 1
a328 1
test exec-10.5 {errors in exec invocation} {execCommandExists stdio} {
d331 1
a331 1
test exec-10.6 {errors in exec invocation} {execCommandExists stdio} {
d334 1
a334 1
test exec-10.7 {errors in exec invocation} {execCommandExists stdio} {
d337 1
a337 1
test exec-10.8 {errors in exec invocation} {execCommandExists stdio} {
d340 1
a340 1
test exec-10.9 {errors in exec invocation} {execCommandExists stdio} {
d343 1
a343 1
test exec-10.10 {errors in exec invocation} {execCommandExists stdio} {
d346 1
a346 1
test exec-10.11 {errors in exec invocation} {execCommandExists stdio} {
d349 1
a349 1
test exec-10.12 {errors in exec invocation} {execCommandExists stdio} {
d352 1
a352 1
test exec-10.13 {errors in exec invocation} {execCommandExists stdio} {
d355 1
a355 1
test exec-10.14 {errors in exec invocation} {execCommandExists stdio} {
d358 1
a358 1
test exec-10.15 {errors in exec invocation} {execCommandExists stdio} {
d361 1
a361 1
test exec-10.16 {errors in exec invocation} {execCommandExists stdio} {
d364 1
a364 1
test exec-10.17 {errors in exec invocation} {execCommandExists stdio} {
d368 1
a368 1
test exec-10.18 {errors in exec invocation} {execCommandExists stdio} {
d373 1
a373 1
test exec-10.19 {errors in exec invocation} {execCommandExists stdio} {
d377 1
a377 1
test exec-10.20 {errors in exec invocation} {execCommandExists stdio} {
d380 2
a381 2
test exec-10.21 {errors in exec invocation} {execCommandExists stdio} {
    list [catch {exec $::tcltest::tcltest true | ~xyzzy_bad_user/x | false} msg] $msg
d386 2
a387 2
test exec-11.1 {commands in background} {execCommandExists stdio} {
    set x [lindex [time {exec $::tcltest::tcltest sleep 2 &}] 0]
d390 2
a391 2
test exec-11.2 {commands in background} {execCommandExists stdio} {
    list [catch {exec $::tcltest::tcltest echo a &b} msg] $msg
d393 2
a394 2
test exec-11.3 {commands in background} {execCommandExists stdio} {
    llength [exec $::tcltest::tcltest sleep 1 &]
d396 2
a397 2
test exec-11.4 {commands in background} {execCommandExists stdio} {
    llength [exec $::tcltest::tcltest sleep 1 | $::tcltest::tcltest sleep 1 | $::tcltest::tcltest sleep 1 &]
d399 1
a399 1
test exec-11.5 {commands in background} {execCommandExists stdio} {
d403 1
a403 1
    string compare "foo" [exec $::tcltest::tcltest gorp.file]
d409 2
a410 3
exec $::tcltest::tcltest sleep 3
test exec-12.1 {reaping background processes} \
	{execCommandExists stdio unixOnly nonPortable} {
d418 1
a418 2
test exec-12.2 {reaping background processes} \
	{execCommandExists stdio unixOnly nonPortable} {
d426 1
a426 2
test exec-12.3 {reaping background processes} \
	{execCommandExists stdio unixOnly nonPortable} {
d449 2
a450 2
test exec-13.1 {setting errorCode variable} {execCommandExists stdio} {
    list [catch {exec $::tcltest::tcltest cat < a/b/c} msg] [string tolower $errorCode]
d452 2
a453 2
test exec-13.2 {setting errorCode variable} {execCommandExists stdio} {
    list [catch {exec $::tcltest::tcltest cat > a/b/c} msg] [string tolower $errorCode]
d455 1
a455 1
test exec-13.3 {setting errorCode variable} {execCommandExists stdio} {
d463 2
a464 2
test exec-14.1 {-keepnewline switch} {execCommandExists stdio} {
    exec -keepnewline $::tcltest::tcltest echo foo
d466 1
a466 1
test exec-14.2 {-keepnewline switch} {execCommandExists stdio} {
d469 1
a469 1
test exec-14.3 {unknown switch} {execCommandExists stdio} {
d472 1
a472 1
test exec-14.4 {-- switch} {execCommandExists stdio} {
d478 4
a481 4
test exec-15.1 {standard error redirection} {execCommandExists stdio} {
    exec $::tcltest::tcltest echo "First line" > gorp.file
    list [exec $::tcltest::tcltest sh -c "echo foo bar 1>&2" 2> gorp.file] \
	    [exec $::tcltest::tcltest cat gorp.file]
d483 5
a487 5
test exec-15.2 {standard error redirection} {execCommandExists stdio} {
    list [exec $::tcltest::tcltest sh -c "echo foo bar 1>&2" \
		| $::tcltest::tcltest echo biz baz >gorp.file 2> gorp.file2] \
	    [exec $::tcltest::tcltest cat gorp.file] \
	    [exec $::tcltest::tcltest cat gorp.file2]
d489 5
a493 5
test exec-15.3 {standard error redirection} {execCommandExists stdio} {
    list [exec $::tcltest::tcltest sh -c "echo foo bar 1>&2" \
	        | $::tcltest::tcltest echo biz baz 2>gorp.file > gorp.file2] \
	    [exec $::tcltest::tcltest cat gorp.file] \
	    [exec $::tcltest::tcltest cat gorp.file2]
d495 1
a495 1
test exec-15.4 {standard error redirection} {execCommandExists stdio} {
d499 1
a499 1
    exec $::tcltest::tcltest sh -c "echo foo bar 1>&2" 2>@@ $f
d502 1
a502 1
    exec $::tcltest::tcltest cat gorp.file
d506 4
a509 4
test exec-15.5 {standard error redirection} {execCommandExists stdio} {
    exec $::tcltest::tcltest echo "First line" > gorp.file
    exec $::tcltest::tcltest sh -c "echo foo bar 1>&2" 2>> gorp.file
    exec $::tcltest::tcltest cat gorp.file
d512 4
a515 4
test exec-15.6 {standard error redirection} {execCommandExists stdio} {
    exec $::tcltest::tcltest sh -c "echo foo bar 1>&2" > gorp.file2 2> gorp.file \
	    >& gorp.file 2> gorp.file2 | $::tcltest::tcltest echo biz baz
    list [exec $::tcltest::tcltest cat gorp.file] [exec $::tcltest::tcltest cat gorp.file2]
d518 1
a518 1
test exec-16.1 {flush output before exec} {execCommandExists stdio} {
d521 1
a521 1
    exec $::tcltest::tcltest echo "Second line" >@@ $f
d524 1
a524 1
    exec $::tcltest::tcltest cat gorp.file
d528 1
a528 1
test exec-16.2 {flush output before exec} {execCommandExists stdio} {
d531 1
a531 1
    exec $::tcltest::tcltest << {puts stderr {Second line}} >&@@ $f > gorp.file2
d534 1
a534 1
    exec $::tcltest::tcltest cat gorp.file
d539 1
a539 1
test exec-17.1 { inheriting standard I/O } {execCommandExists stdio} {
d548 1
a548 1
    catch {exec $::tcltest::tcltest script} result
a555 1
# cleanup
a557 16
file delete err
::tcltest::cleanupTests
return













@


1.1.1.3
log
@import tcl 8.4.0
@
text
@d14 1
a14 1
# RCS: @@(#) $Id: exec.test,v 1.14 2002/09/02 19:27:15 hobbs Exp $
d16 4
a19 2
package require tcltest 2
namespace import -force ::tcltest::*
d23 1
a23 1
testConstraint exec [llength [info commands exec]]
d25 2
a26 1
set path(echo) [makeFile {
d33 2
a34 1
} echo]
d36 2
a37 1
set path(cat) [makeFile {
d56 2
a57 1
} cat]
d59 2
a60 1
set path(wc) [makeFile {
d67 2
a68 1
} wc]
d70 2
a71 1
set path(sh) [makeFile {
d92 2
a93 1
} sh]
d95 2
a96 1
set path(sleep) [makeFile {
d99 2
a100 1
} sleep]
d102 2
a103 1
set path(exit) [makeFile {
d105 2
a106 1
} exit]
d110 2
a111 2
test exec-1.1 {basic exec operation} {exec} {
    exec [interpreter] $path(echo) a b c
d113 2
a114 2
test exec-1.2 {pipelining} {exec stdio} {
    exec [interpreter] $path(echo) a b c d | [interpreter] $path(cat) | [interpreter] $path(cat)
d116 2
a117 2
test exec-1.3 {pipelining} {exec stdio} {
    set a [exec [interpreter] $path(echo) a b c d | [interpreter] $path(cat) | [interpreter] $path(wc)]
d122 2
a123 2
test exec-1.4 {long command lines} {exec} {
    exec [interpreter] $path(echo) $arg
d129 2
a130 2
test exec-2.1 {redirecting input from immediate source} {exec stdio} {
    exec [interpreter] $path(cat) << "Sample text"
d132 2
a133 2
test exec-2.2 {redirecting input from immediate source} {exec stdio} {
    exec << "Sample text" [interpreter] $path(cat) | [interpreter] $path(cat)
d135 2
a136 2
test exec-2.3 {redirecting input from immediate source} {exec stdio} {
    exec [interpreter] $path(cat) << "Sample text" | [interpreter] $path(cat)
d138 2
a139 2
test exec-2.4 {redirecting input from immediate source} {exec stdio} {
    exec [interpreter] $path(cat) | [interpreter] $path(cat) << "Sample text"
d141 2
a142 2
test exec-2.5 {redirecting input from immediate source} {exec} {
    exec [interpreter] $path(cat) "<<Joined to arrows"
d144 1
a144 1
test exec-2.6 {redirecting input from immediate source, with UTF} {exec} {
d149 1
a149 1
    exec [interpreter] $path(cat) << "\uE9\uE0\uFC\uF1"
d154 4
a157 6
set path(gorp.file) [makeFile {} gorp.file]
removeFile gorp.file

test exec-3.1 {redirecting output to file} {exec} {
    exec [interpreter] $path(echo) "Some simple words" > $path(gorp.file)
    exec [interpreter] $path(cat) $path(gorp.file)
d159 3
a161 3
test exec-3.2 {redirecting output to file} {exec stdio} {
    exec [interpreter] $path(echo) "More simple words" | >$path(gorp.file) [interpreter] $path(cat) | [interpreter] $path(cat)
    exec [interpreter] $path(cat) $path(gorp.file)
d163 3
a165 3
test exec-3.3 {redirecting output to file} {exec stdio} {
    exec > $path(gorp.file) [interpreter] $path(echo) "Different simple words" | [interpreter] $path(cat) | [interpreter] $path(cat)
    exec [interpreter] $path(cat) $path(gorp.file)
d167 3
a169 3
test exec-3.4 {redirecting output to file} {exec} {
    exec [interpreter] $path(echo) "Some simple words" >$path(gorp.file)
    exec [interpreter] $path(cat) $path(gorp.file)
d171 4
a174 4
test exec-3.5 {redirecting output to file} {exec} {
    exec [interpreter] $path(echo) "First line" >$path(gorp.file)
    exec [interpreter] $path(echo) "Second line" >> $path(gorp.file)
    exec [interpreter] $path(cat) $path(gorp.file)
d176 4
a179 4
test exec-3.6 {redirecting output to file} {exec} {
    exec [interpreter] $path(echo) "First line" >$path(gorp.file)
    exec [interpreter] $path(echo) "Second line" >>$path(gorp.file)
    exec [interpreter] $path(cat) $path(gorp.file)
d181 2
a182 2
test exec-3.7 {redirecting output to file} {exec} {
    set f [open $path(gorp.file) w]
d185 2
a186 2
    exec [interpreter] $path(echo) "More text" >@@ $f
    exec [interpreter] $path(echo) >@@$f "Even more"
d189 1
a189 1
    exec [interpreter] $path(cat) $path(gorp.file)
d194 4
a197 5
removeFile gorp.file

test exec-4.1 {redirecting output and stderr to file} {exec} {
    exec [interpreter] $path(echo) "test output" >& $path(gorp.file)
    exec [interpreter] $path(cat) $path(gorp.file)
d199 3
a201 3
test exec-4.2 {redirecting output and stderr to file} {exec} {
    list [exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" >&$path(gorp.file)] \
	    [exec [interpreter] $path(cat) $path(gorp.file)]
d203 4
a206 4
test exec-4.3 {redirecting output and stderr to file} {exec} {
    exec [interpreter] $path(echo) "first line" > $path(gorp.file)
    list [exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" >>&$path(gorp.file)] \
	    [exec [interpreter] $path(cat) $path(gorp.file)]
d208 2
a209 2
test exec-4.4 {redirecting output and stderr to file} {exec} {
    set f [open $path(gorp.file) w]
d212 2
a213 2
    exec [interpreter] $path(echo) "More text" >&@@ $f
    exec [interpreter] $path(echo) >&@@$f "Even more"
d216 1
a216 1
    exec [interpreter] $path(cat) $path(gorp.file)
d218 2
a219 2
test exec-4.5 {redirecting output and stderr to file} {exec} {
    set f [open $path(gorp.file) w]
d222 2
a223 2
    exec >&@@ $f [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2"
    exec >&@@$f [interpreter] $path(sh) -c "$path(echo) xyzzy 1>&2"
d226 1
a226 1
    exec [interpreter] $path(cat) $path(gorp.file)
d231 3
a233 5
if { [set ::tcltest::testConstraints(exec)] } {
exec [interpreter] $path(echo) "Just a few thoughts" > $path(gorp.file)
}
test exec-5.1 {redirecting input from file} {exec} {
    exec [interpreter] $path(cat) < $path(gorp.file)
d235 2
a236 2
test exec-5.2 {redirecting input from file} {exec stdio} {
    exec [interpreter] $path(cat) | [interpreter] $path(cat) < $path(gorp.file)
d238 2
a239 2
test exec-5.3 {redirecting input from file} {exec stdio} {
    exec [interpreter] $path(cat) < $path(gorp.file) | [interpreter] $path(cat)
d241 2
a242 2
test exec-5.4 {redirecting input from file} {exec stdio} {
    exec < $path(gorp.file) [interpreter] $path(cat) | [interpreter] $path(cat)
d244 2
a245 2
test exec-5.5 {redirecting input from file} {exec} {
    exec [interpreter] $path(cat) <$path(gorp.file)
d247 3
a249 3
test exec-5.6 {redirecting input from file} {exec} {
    set f [open $path(gorp.file) r]
    set result [exec [interpreter] $path(cat) <@@ $f]
d253 3
a255 3
test exec-5.7 {redirecting input from file} {exec} {
    set f [open $path(gorp.file) r]
    set result [exec <@@$f [interpreter] $path(cat)]
d262 2
a263 2
test exec-6.1 {redirecting stderr through a pipeline} {exec stdio} {
    exec [interpreter] $path(sh) -c "$path(echo) foo bar" |& [interpreter] $path(cat)
d265 2
a266 2
test exec-6.2 {redirecting stderr through a pipeline} {exec stdio} {
    exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" |& [interpreter] $path(cat)
d268 3
a270 3
test exec-6.3 {redirecting stderr through a pipeline} {exec stdio} {
    exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" \
	|& [interpreter] $path(sh) -c "$path(echo) second msg 1>&2 ; $path(cat)" |& [interpreter] $path(cat)
d275 4
a278 6
set path(gorp.file2) [makeFile {} gorp.file2]
removeFile gorp.file2

test exec-7.1 {multiple I/O redirections} {exec} {
    exec << "command input" > $path(gorp.file2) [interpreter] $path(cat) < $path(gorp.file)
    exec [interpreter] $path(cat) $path(gorp.file2)
d280 2
a281 2
test exec-7.2 {multiple I/O redirections} {exec} {
    exec < $path(gorp.file) << "command input" [interpreter] $path(cat)
d291 2
a292 2
test exec-8.1 {long input and output} {exec} {
    exec [interpreter] $path(cat) << $a
d297 2
a298 2
test exec-8.2 {long input and output} {exec} {
    exec [interpreter] $path(echo) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23
d303 1
a303 1
test exec-9.1 {commands returning errors} {exec} {
d307 2
a308 2
test exec-9.2 {commands returning errors} {exec} {
    string tolower [list [catch {exec [interpreter] echo foo | foo123} msg] $msg $errorCode]
d310 2
a311 2
test exec-9.3 {commands returning errors} {exec stdio} {
    list [catch {exec [interpreter] $path(sleep) 1 | [interpreter] $path(exit) 43 | [interpreter] $path(sleep) 1} msg] $msg
d313 2
a314 2
test exec-9.4 {commands returning errors} {exec stdio} {
    list [catch {exec [interpreter] $path(exit) 43 | [interpreter] $path(echo) "foo bar"} msg] $msg
d317 2
a318 2
test exec-9.5 {commands returning errors} {exec stdio} {
    list [catch {exec gorp456 | [interpreter] echo a b c} msg] [string tolower $msg]
d320 2
a321 2
test exec-9.6 {commands returning errors} {exec} {
    list [catch {exec [interpreter] $path(sh) -c "$path(echo) error msg 1>&2"} msg] $msg
d323 3
a325 3
test exec-9.7 {commands returning errors} {exec stdio} {
    list [catch {exec [interpreter] $path(sh) -c "$path(echo) error msg 1>&2" \
		     | [interpreter] $path(sh) -c "$path(echo) error msg 1>&2"} msg] $msg
d328 2
a329 5

set path(err) [makeFile {} err]

test exec-9.8 {commands returning errors} {exec} {
    set f [open $path(err) w]
d335 1
a335 1
    list [catch {exec [interpreter] $path(err)} msg] $msg
d342 1
a342 1
test exec-10.1 {errors in exec invocation} {exec} {
d345 1
a345 1
test exec-10.2 {errors in exec invocation} {exec} {
d348 1
a348 1
test exec-10.3 {errors in exec invocation} {exec} {
d351 1
a351 1
test exec-10.4 {errors in exec invocation} {exec} {
d354 1
a354 1
test exec-10.5 {errors in exec invocation} {exec} {
d357 1
a357 1
test exec-10.6 {errors in exec invocation} {exec} {
d360 1
a360 1
test exec-10.7 {errors in exec invocation} {exec} {
d363 1
a363 1
test exec-10.8 {errors in exec invocation} {exec} {
d366 1
a366 1
test exec-10.9 {errors in exec invocation} {exec} {
d369 1
a369 1
test exec-10.10 {errors in exec invocation} {exec} {
d372 1
a372 1
test exec-10.11 {errors in exec invocation} {exec} {
d375 1
a375 1
test exec-10.12 {errors in exec invocation} {exec} {
d378 1
a378 1
test exec-10.13 {errors in exec invocation} {exec} {
d381 1
a381 1
test exec-10.14 {errors in exec invocation} {exec} {
d384 1
a384 1
test exec-10.15 {errors in exec invocation} {exec} {
d387 1
a387 1
test exec-10.16 {errors in exec invocation} {exec} {
d390 1
a390 1
test exec-10.17 {errors in exec invocation} {exec} {
d393 2
a394 2
set f [open $path(gorp.file) w]
test exec-10.18 {errors in exec invocation} {exec} {
d398 2
a399 2
set f [open $path(gorp.file) r]
test exec-10.19 {errors in exec invocation} {exec} {
d403 1
a403 1
test exec-10.20 {errors in exec invocation} {exec} {
d406 2
a407 2
test exec-10.21 {errors in exec invocation} {exec} {
    list [catch {exec [interpreter] true | ~xyzzy_bad_user/x | false} msg] $msg
d412 2
a413 2
test exec-11.1 {commands in background} {exec} {
    set x [lindex [time {exec [interpreter] $path(sleep) 2 &}] 0]
d416 2
a417 2
test exec-11.2 {commands in background} {exec} {
    list [catch {exec [interpreter] $path(echo) a &b} msg] $msg
d419 2
a420 2
test exec-11.3 {commands in background} {exec} {
    llength [exec [interpreter] $path(sleep) 1 &]
d422 2
a423 2
test exec-11.4 {commands in background} {exec stdio} {
    llength [exec [interpreter] $path(sleep) 1 | [interpreter] $path(sleep) 1 | [interpreter] $path(sleep) 1 &]
d425 3
a427 3
test exec-11.5 {commands in background} {exec} {
    set f [open $path(gorp.file) w]
    puts $f [format { catch { exec [info nameofexecutable] %s foo & } } $path(echo)]
d429 1
a429 1
    string compare "foo" [exec [interpreter] $path(gorp.file)]
d435 1
a435 3
if { [set ::tcltest::testConstraints(exec)] } {
exec [interpreter] $path(sleep) 3
}
d437 1
a437 1
	{exec unixOnly nonPortable} {
d446 1
a446 1
	{exec unixOnly nonPortable} {
d455 1
a455 1
	{exec unixOnly nonPortable} {
d478 2
a479 2
test exec-13.1 {setting errorCode variable} {exec} {
    list [catch {exec [interpreter] $path(cat) < a/b/c} msg] [string tolower $errorCode]
d481 2
a482 2
test exec-13.2 {setting errorCode variable} {exec} {
    list [catch {exec [interpreter] $path(cat) > a/b/c} msg] [string tolower $errorCode]
d484 1
a484 1
test exec-13.3 {setting errorCode variable} {exec} {
d492 2
a493 2
test exec-14.1 {-keepnewline switch} {exec} {
    exec -keepnewline [interpreter] $path(echo) foo
d495 1
a495 1
test exec-14.2 {-keepnewline switch} {exec} {
d498 1
a498 1
test exec-14.3 {unknown switch} {exec} {
d501 1
a501 1
test exec-14.4 {-- switch} {exec} {
d507 4
a510 4
test exec-15.1 {standard error redirection} {exec} {
    exec [interpreter] $path(echo) "First line" > $path(gorp.file)
    list [exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" 2> $path(gorp.file)] \
	    [exec [interpreter] $path(cat) $path(gorp.file)]
d512 5
a516 5
test exec-15.2 {standard error redirection} {exec stdio} {
    list [exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" \
		| [interpreter] $path(echo) biz baz >$path(gorp.file) 2> $path(gorp.file2)] \
	    [exec [interpreter] $path(cat) $path(gorp.file)] \
	    [exec [interpreter] $path(cat) $path(gorp.file2)]
d518 5
a522 5
test exec-15.3 {standard error redirection} {exec stdio} {
    list [exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" \
	        | [interpreter] $path(echo) biz baz 2>$path(gorp.file) > $path(gorp.file2)] \
	    [exec [interpreter] $path(cat) $path(gorp.file)] \
	    [exec [interpreter] $path(cat) $path(gorp.file2)]
d524 2
a525 2
test exec-15.4 {standard error redirection} {exec} {
    set f [open $path(gorp.file) w]
d528 1
a528 1
    exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" 2>@@ $f
d531 1
a531 1
    exec [interpreter] $path(cat) $path(gorp.file)
d535 4
a538 4
test exec-15.5 {standard error redirection} {exec} {
    exec [interpreter] $path(echo) "First line" > $path(gorp.file)
    exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" 2>> $path(gorp.file)
    exec [interpreter] $path(cat) $path(gorp.file)
d541 4
a544 4
test exec-15.6 {standard error redirection} {exec stdio} {
    exec [interpreter] $path(sh) -c "$path(echo) foo bar 1>&2" > $path(gorp.file2) 2> $path(gorp.file) \
	    >& $path(gorp.file) 2> $path(gorp.file2) | [interpreter] $path(echo) biz baz
    list [exec [interpreter] $path(cat) $path(gorp.file)] [exec [interpreter] $path(cat) $path(gorp.file2)]
d547 2
a548 2
test exec-16.1 {flush output before exec} {exec} {
    set f [open $path(gorp.file) w]
d550 1
a550 1
    exec [interpreter] $path(echo) "Second line" >@@ $f
d553 1
a553 1
    exec [interpreter] $path(cat) $path(gorp.file)
d557 2
a558 2
test exec-16.2 {flush output before exec} {exec} {
    set f [open $path(gorp.file) w]
d560 1
a560 1
    exec [interpreter] << {puts stderr {Second line}} >&@@ $f > $path(gorp.file2)
d563 1
a563 1
    exec [interpreter] $path(cat) $path(gorp.file)
d568 6
a573 8
set path(script) [makeFile {} script]

test exec-17.1 { inheriting standard I/O } {exec} {
    set f [open $path(script) w]
    puts $f [format {close stdout
	set f [open %s w]
	catch {exec [info nameofexecutable] %s foobar &}
	exec [info nameofexecutable] %s 2
d575 1
a575 1
    } $path(gorp.file) $path(echo) $path(sleep)]
d577 2
a578 2
    catch {exec [interpreter] $path(script)} result
    set f [open $path(gorp.file) r]
d585 16
a600 12
test exec-18.1 { exec cat deals with weird file names} {exec unixOnly} {
    # This is cross-platform, but the cat isn't predictably correct on
    # Windows.
    set f "foo\[\{blah"
    set path(fooblah) [makeFile {} $f]
    set fout [open $path(fooblah) w]
    puts $fout "contents"
    close $fout
    set res [list [catch {exec cat $path(fooblah)} msg] $msg]
    removeFile $f
    set res
} {0 contents}
a601 1
# cleanup
a602 3
foreach file {script gorp.file gorp.file2 echo cat wc sh sleep exit err} {
	removeFile $file
}
a603 2
::tcltest::cleanupTests
return
@


