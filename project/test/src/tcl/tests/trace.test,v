head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.58
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.56
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.54
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.52
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.50
	gdb_7_0-branch:1.5.0.48
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tcl8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.46
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.44
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.42
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.40
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.38
	gdb_6_5-2006-05-14-branchpoint:1.5
	readline_5_1-import-branch:1.5.0.36
	readline_5_1-import-branchpoint:1.5
	gdb_6_4-branch:1.5.0.34
	gdb_6_4-2005-11-01-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.32
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	ezannoni_pie-20040323-branch:1.5.0.30
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.28
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.26
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.24
	cagney_x86i386-20030821-branch:1.5.0.22
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.20
	gdb_6_0-2003-06-23-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.18
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.16
	cagney_writestrings-20030508-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.14
	cagney_fileio-20030521-branchpoint:1.5
	carlton_dictionary-20030430-merge:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.12
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.10
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.8
	cagney_lazyid-20030317-branchpoint:1.5
	offbyone-20030313-branch:1.5.0.6
	offbyone-20030313-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.4
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.2
	interps-20030202-branchpoint:1.5
	TCL8_4_1:1.1.1.4
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.2
	TCL_8_4_1:1.1.1.4
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.4
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TCL_8_4_0:1.1.1.3
	carlton_dictionary-branch:1.2.0.16
	carlton_dictionary-20020920-branchpoint:1.2
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.14
	gdb_5_3-branch:1.2.0.12
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.10
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.8
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.6
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TCL_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	dejagnu-2000-02-04:1.1.1.1
	dejagnu-2000-01-31:1.1.1.1
	dejagnu-2000-01-24:1.1.1.1
	dejagnu-2000-01-17:1.1.1.1
	dejagnu-2000-01-10:1.1.1.1
	dejagnu-2000-01-04:1.1.1.1
	dejagnu-1999-12-21:1.1.1.1
	dejagnu-1999-12-13:1.1.1.1
	dejagnu-1999-12-07:1.1.1.1
	dejagnu-1999-12-06:1.1.1.1
	dejagnu-1999-11-15:1.1.1.1
	dejagnu-1999-11-08:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2003.01.21.19.40.17;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.26.19.48.02;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.37.08;	author kseitz;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2001.09.09.23.56.08;	author irox;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2002.09.27.21.49.11;	author kseitz;	state Exp;
branches;
next	;

1.3.4.1
date	2003.12.14.20.28.50;	author drow;	state Exp;
branches;
next	;

1.2.16.1
date	2002.12.23.19.40.45;	author carlton;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2003.02.07.19.18.20;	author carlton;	state Exp;
branches;
next	;

1.1.1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.09.22.40.59;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.19.56.41;	author kseitz;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.11.26.20.01.14;	author hunt;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tcl 8.4.1
@
text
@# Commands covered:  trace
#
# This file contains a collection of tests for one or more of the Tcl
# built-in commands.  Sourcing this file into Tcl runs the tests and
# generates output for errors.  No output means no errors were found.
#
# Copyright (c) 1991-1993 The Regents of the University of California.
# Copyright (c) 1994 Sun Microsystems, Inc.
# Copyright (c) 1998-1999 by Scriptics Corporation.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# RCS: @@(#) $Id: trace.test,v 1.23 2002/10/15 16:13:47 vincentdarley Exp $

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import -force ::tcltest::*
}

proc traceScalar {name1 name2 op} {
    global info
    set info [list $name1 $name2 $op [catch {uplevel set $name1} msg] $msg]
}
proc traceScalarAppend {name1 name2 op} {
    global info
    lappend info $name1 $name2 $op [catch {uplevel set $name1} msg] $msg
}
proc traceArray {name1 name2 op} {
    global info
    set info [list $name1 $name2 $op [catch {uplevel set [set name1]($name2)} msg] $msg]
}
proc traceArray2 {name1 name2 op} {
    global info
    set info [list $name1 $name2 $op]
}
proc traceProc {name1 name2 op} {
    global info
    set info [concat $info [list $name1 $name2 $op]]
}
proc traceTag {tag args} {
    global info
    set info [concat $info $tag]
}
proc traceError {args} {
    error "trace returned error"
}
proc traceCheck {cmd args} {
    global info
    set info [list [catch $cmd msg] $msg]
}
proc traceCrtElement {value name1 name2 op} {
    uplevel set ${name1}($name2) $value
}
proc traceCommand {oldName newName op} {
    global info
    set info [list $oldName $newName $op]
}

test trace-0.0 {memory corruption in trace (Tcl Bug 484339)} {
    # You may need Purify or Electric Fence to reliably
    # see this one fail.
    catch {unset z}
    trace add variable z array {set z(foo) 1 ;#}
    set res "names: [array names z]"
    catch {unset ::z}
    trace variable ::z w {unset ::z; error "memory corruption";#}
    list [catch {set ::z 1} msg] $msg
} {1 {can't set "::z": memory corruption}}

# Read-tracing on variables

test trace-1.1 {trace variable reads} {
    catch {unset x}
    set info {}
    trace add variable x read traceScalar
    list [catch {set x} msg] $msg $info
} {1 {can't read "x": no such variable} {x {} read 1 {can't read "x": no such variable}}}
test trace-1.2 {trace variable reads} {
    catch {unset x}
    set x 123
    set info {}
    trace add variable x read traceScalar
    list [catch {set x} msg] $msg $info
} {0 123 {x {} read 0 123}}
test trace-1.3 {trace variable reads} {
    catch {unset x}
    set info {}
    trace add variable x read traceScalar
    set x 123
    set info
} {}
test trace-1.4 {trace array element reads} {
    catch {unset x}
    set info {}
    trace add variable x(2) read traceArray
    list [catch {set x(2)} msg] $msg $info
} {1 {can't read "x(2)": no such element in array} {x 2 read 1 {can't read "x(2)": no such element in array}}}
test trace-1.5 {trace array element reads} {
    catch {unset x}
    set x(2) zzz
    set info {}
    trace add variable x(2) read traceArray
    list [catch {set x(2)} msg] $msg $info
} {0 zzz {x 2 read 0 zzz}}
test trace-1.6 {trace array element reads} {
    catch {unset x}
    set info {}
    trace add variable x read traceArray2
    proc p {} {
        global x
        set x(2) willi
        return $x(2)
    }
    list [catch {p} msg] $msg $info
} {0 willi {x 2 read}}
test trace-1.7 {trace array element reads, create element undefined if nonexistant} {
    catch {unset x}
    set info {}
    trace add variable x read q
    proc q {name1 name2 op} {
        global info
        set info [list $name1 $name2 $op]
        global $name1
        set ${name1}($name2) wolf
    }
    proc p {} {
        global x
        set x(X) willi
        return $x(Y)
    }
    list [catch {p} msg] $msg $info
} {0 wolf {x Y read}}
test trace-1.8 {trace reads on whole arrays} {
    catch {unset x}
    set info {}
    trace add variable x read traceArray
    list [catch {set x(2)} msg] $msg $info
} {1 {can't read "x(2)": no such variable} {}}
test trace-1.9 {trace reads on whole arrays} {
    catch {unset x}
    set x(2) zzz
    set info {}
    trace add variable x read traceArray
    list [catch {set x(2)} msg] $msg $info
} {0 zzz {x 2 read 0 zzz}}
test trace-1.10 {trace variable reads} {
    catch {unset x}
    set x 444
    set info {}
    trace add variable x read traceScalar
    unset x
    set info
} {}
test trace-1.11 {read traces that modify the array structure} {
    catch {unset x}
    set x(bar) 0 
    trace variable x r {set x(foo) 1 ;#} 
    trace variable x r {unset -nocomplain x(bar) ;#} 
    array get x
} {}
test trace-1.12 {read traces that modify the array structure} {
    catch {unset x}
    set x(bar) 0 
    trace variable x r {unset -nocomplain x(bar) ;#} 
    trace variable x r {set x(foo) 1 ;#} 
    array get x
} {}
test trace-1.13 {read traces that modify the array structure} {
    catch {unset x}
    set x(bar) 0 
    trace variable x r {set x(foo) 1 ;#} 
    trace variable x r {unset -nocomplain x;#} 
    list [catch {array get x} res] $res
} {1 {can't read "x(bar)": no such variable}}
test trace-1.14 {read traces that modify the array structure} {
    catch {unset x}
    set x(bar) 0 
    trace variable x r {unset -nocomplain x;#} 
    trace variable x r {set x(foo) 1 ;#} 
    list [catch {array get x} res] $res
} {1 {can't read "x(bar)": no such variable}}

# Basic write-tracing on variables

test trace-2.1 {trace variable writes} {
    catch {unset x}
    set info {}
    trace add variable x write traceScalar
    set x 123
    set info
} {x {} write 0 123}
test trace-2.2 {trace writes to array elements} {
    catch {unset x}
    set info {}
    trace add variable x(33) write traceArray
    set x(33) 444
    set info
} {x 33 write 0 444}
test trace-2.3 {trace writes on whole arrays} {
    catch {unset x}
    set info {}
    trace add variable x write traceArray
    set x(abc) qq
    set info
} {x abc write 0 qq}
test trace-2.4 {trace variable writes} {
    catch {unset x}
    set x 1234
    set info {}
    trace add variable x write traceScalar
    set x
    set info
} {}
test trace-2.5 {trace variable writes} {
    catch {unset x}
    set x 1234
    set info {}
    trace add variable x write traceScalar
    unset x
    set info
} {}

# append no longer triggers read traces when fetching the old values of
# variables before doing the append operation. However, lappend _does_
# still trigger these read traces. Also lappend triggers only one write
# trace: after appending all arguments to the list.

test trace-3.1 {trace variable read-modify-writes} {
    catch {unset x}
    set info {}
    trace add variable x read traceScalarAppend
    append x 123
    append x 456
    lappend x 789
    set info
} {x {} read 0 123456}
test trace-3.2 {trace variable read-modify-writes} {
    catch {unset x}
    set info {}
    trace add variable x {read write} traceScalarAppend
    append x 123
    lappend x 456
    set info
} {x {} write 0 123 x {} read 0 123 x {} write 0 {123 456}}

# Basic unset-tracing on variables

test trace-4.1 {trace variable unsets} {
    catch {unset x}
    set info {}
    trace add variable x unset traceScalar
    catch {unset x}
    set info
} {x {} unset 1 {can't read "x": no such variable}}
test trace-4.2 {variable mustn't exist during unset trace} {
    catch {unset x}
    set x 1234
    set info {}
    trace add variable x unset traceScalar
    unset x
    set info
} {x {} unset 1 {can't read "x": no such variable}}
test trace-4.3 {unset traces mustn't be called during reads and writes} {
    catch {unset x}
    set info {}
    trace add variable x unset traceScalar
    set x 44
    set x
    set info
} {}
test trace-4.4 {trace unsets on array elements} {
    catch {unset x}
    set x(0) 18
    set info {}
    trace add variable x(1) unset traceArray
    catch {unset x(1)}
    set info
} {x 1 unset 1 {can't read "x(1)": no such element in array}}
test trace-4.5 {trace unsets on array elements} {
    catch {unset x}
    set x(1) 18
    set info {}
    trace add variable x(1) unset traceArray
    unset x(1)
    set info
} {x 1 unset 1 {can't read "x(1)": no such element in array}}
test trace-4.6 {trace unsets on array elements} {
    catch {unset x}
    set x(1) 18
    set info {}
    trace add variable x(1) unset traceArray
    unset x
    set info
} {x 1 unset 1 {can't read "x(1)": no such variable}}
test trace-4.7 {trace unsets on whole arrays} {
    catch {unset x}
    set x(1) 18
    set info {}
    trace add variable x unset traceProc
    catch {unset x(0)}
    set info
} {}
test trace-4.8 {trace unsets on whole arrays} {
    catch {unset x}
    set x(1) 18
    set x(2) 144
    set x(3) 14
    set info {}
    trace add variable x unset traceProc
    unset x(1)
    set info
} {x 1 unset}
test trace-4.9 {trace unsets on whole arrays} {
    catch {unset x}
    set x(1) 18
    set x(2) 144
    set x(3) 14
    set info {}
    trace add variable x unset traceProc
    unset x
    set info
} {x {} unset}

# Array tracing on variables
test trace-5.1 {array traces fire on accesses via [array]} {
    catch {unset x}
    set x(b) 2
    trace add variable x array traceArray2
    set ::info {}
    array set x {a 1}
    set ::info
} {x {} array}
test trace-5.2 {array traces do not fire on normal accesses} {
    catch {unset x}
    set x(b) 2
    trace add variable x array traceArray2
    set ::info {}
    set x(a) 1
    set x(b) $x(a)
    set ::info
} {}
test trace-5.3 {array traces do not outlive variable} {
    catch {unset x}
    trace add variable x array traceArray2
    set ::info {}
    set x(a) 1
    unset x
    array set x {a 1}
    set ::info
} {}
test trace-5.4 {array traces properly listed in trace information} {
    catch {unset x}
    trace add variable x array traceArray2
    set result [trace info variable x]
    set result
} [list [list array traceArray2]]
test trace-5.5 {array traces properly listed in trace information} {
    catch {unset x}
    trace variable x a traceArray2
    set result [trace vinfo x]
    set result
} [list [list a traceArray2]]
test trace-5.6 {array traces don't fire on scalar variables} {
    catch {unset x}
    set x foo
    trace add variable x array traceArray2
    set ::info {}
    catch {array set x {a 1}}
    set ::info
} {}
test trace-5.7 {array traces fire for undefined variables} {
    catch {unset x}
    trace add variable x array traceArray2
    set ::info {}
    array set x {a 1}
    set ::info
} {x {} array}
test trace-5.8 {array traces fire for undefined variables} {
    catch {unset x}
    trace add variable x array {set x(foo) 1 ;#}
    set res "names: [array names x]"
} {names: foo}
    
# Trace multiple trace types at once.

test trace-6.1 {multiple ops traced at once} {
    catch {unset x}
    set info {}
    trace add variable x {read write unset} traceProc
    catch {set x}
    set x 22
    set x
    set x 33
    unset x
    set info
} {x {} read x {} write x {} read x {} write x {} unset}
test trace-6.2 {multiple ops traced on array element} {
    catch {unset x}
    set info {}
    trace add variable x(0) {read write unset} traceProc
    catch {set x(0)}
    set x(0) 22
    set x(0)
    set x(0) 33
    unset x(0)
    unset x
    set info
} {x 0 read x 0 write x 0 read x 0 write x 0 unset}
test trace-6.3 {multiple ops traced on whole array} {
    catch {unset x}
    set info {}
    trace add variable x {read write unset} traceProc
    catch {set x(0)}
    set x(0) 22
    set x(0)
    set x(0) 33
    unset x(0)
    unset x
    set info
} {x 0 write x 0 read x 0 write x 0 unset x {} unset}

# Check order of invocation of traces

test trace-7.1 {order of invocation of traces} {
    catch {unset x}
    set info {}
    trace add variable x read "traceTag 1"
    trace add variable x read "traceTag 2"
    trace add variable x read "traceTag 3"
    catch {set x}
    set x 22
    set x
    set info
} {3 2 1 3 2 1}
test trace-7.2 {order of invocation of traces} {
    catch {unset x}
    set x(0) 44
    set info {}
    trace add variable x(0) read "traceTag 1"
    trace add variable x(0) read "traceTag 2"
    trace add variable x(0) read "traceTag 3"
    set x(0)
    set info
} {3 2 1}
test trace-7.3 {order of invocation of traces} {
    catch {unset x}
    set x(0) 44
    set info {}
    trace add variable x(0) read "traceTag 1"
    trace add variable x read "traceTag A1"
    trace add variable x(0) read "traceTag 2"
    trace add variable x read "traceTag A2"
    trace add variable x(0) read "traceTag 3"
    trace add variable x read "traceTag A3"
    set x(0)
    set info
} {A3 A2 A1 3 2 1}

# Check effects of errors in trace procedures

test trace-8.1 {error returns from traces} {
    catch {unset x}
    set x 123
    set info {}
    trace add variable x read "traceTag 1"
    trace add variable x read traceError
    list [catch {set x} msg] $msg $info
} {1 {can't read "x": trace returned error} {}}
test trace-8.2 {error returns from traces} {
    catch {unset x}
    set x 123
    set info {}
    trace add variable x write "traceTag 1"
    trace add variable x write traceError
    list [catch {set x 44} msg] $msg $info
} {1 {can't set "x": trace returned error} {}}
test trace-8.3 {error returns from traces} {
    catch {unset x}
    set x 123
    set info {}
    trace add variable x write traceError
    list [catch {append x 44} msg] $msg $info
} {1 {can't set "x": trace returned error} {}}
test trace-8.4 {error returns from traces} {
    catch {unset x}
    set x 123
    set info {}
    trace add variable x unset "traceTag 1"
    trace add variable x unset traceError
    list [catch {unset x} msg] $msg $info
} {0 {} 1}
test trace-8.5 {error returns from traces} {
    catch {unset x}
    set x(0) 123
    set info {}
    trace add variable x(0) read "traceTag 1"
    trace add variable x read "traceTag 2"
    trace add variable x read traceError
    trace add variable x read "traceTag 3"
    list [catch {set x(0)} msg] $msg $info
} {1 {can't read "x(0)": trace returned error} 3}
test trace-8.6 {error returns from traces} {
    catch {unset x}
    set x 123
    trace add variable x unset traceError
    list [catch {unset x} msg] $msg
} {0 {}}
test trace-8.7 {error returns from traces} {
    # This test just makes sure that the memory for the error message
    # gets deallocated correctly when the trace is invoked again or
    # when the trace is deleted.
    catch {unset x}
    set x 123
    trace add variable x read traceError
    catch {set x}
    catch {set x}
    trace remove variable x read traceError
} {}
test trace-8.8 {error returns from traces} {
    # Yet more elaborate memory corruption testing that checks nothing
    # bad happens when the trace deletes itself and installs something
    # new.  Alas, there is no neat way to guarantee that this test will
    # fail if there is a problem, but that's life and with the new code
    # it should *never* fail.
    #
    # Adapted from Bug #219393 reported by Don Porter.
    catch {rename ::foo {}}
    proc foo {old args} {
	trace remove variable ::x write [list foo $old]
	trace add    variable ::x write [list foo $::x]
	error "foo"
    }
    catch {unset ::x ::y}
    set x junk
    trace add variable ::x write [list foo $x]
    for {set y 0} {$y<100} {incr y} {
	catch {set x junk}
    }
    unset x
} {}

# Check to see that variables are expunged before trace
# procedures are invoked, so trace procedure can even manipulate
# a new copy of the variables.

test trace-9.1 {be sure variable is unset before trace is called} {
    catch {unset x}
    set x 33
    set info {}
    trace add variable x unset {traceCheck {uplevel set x}}
    unset x
    set info
} {1 {can't read "x": no such variable}}
test trace-9.2 {be sure variable is unset before trace is called} {
    catch {unset x}
    set x 33
    set info {}
    trace add variable x unset {traceCheck {uplevel set x 22}}
    unset x
    concat $info [list [catch {set x} msg] $msg]
} {0 22 0 22}
test trace-9.3 {be sure traces are cleared before unset trace called} {
    catch {unset x}
    set x 33
    set info {}
    trace add variable x unset {traceCheck {uplevel trace info variable x}}
    unset x
    set info
} {0 {}}
test trace-9.4 {set new trace during unset trace} {
    catch {unset x}
    set x 33
    set info {}
    trace add variable x unset {traceCheck {global x; trace add variable x unset traceProc}}
    unset x
    concat $info [trace info variable x]
} {0 {} {unset traceProc}}

test trace-10.1 {make sure array elements are unset before traces are called} {
    catch {unset x}
    set x(0) 33
    set info {}
    trace add variable x(0) unset {traceCheck {uplevel set x(0)}}
    unset x(0)
    set info
} {1 {can't read "x(0)": no such element in array}}
test trace-10.2 {make sure array elements are unset before traces are called} {
    catch {unset x}
    set x(0) 33
    set info {}
    trace add variable x(0) unset {traceCheck {uplevel set x(0) zzz}}
    unset x(0)
    concat $info [list [catch {set x(0)} msg] $msg]
} {0 zzz 0 zzz}
test trace-10.3 {array elements are unset before traces are called} {
    catch {unset x}
    set x(0) 33
    set info {}
    trace add variable x(0) unset {traceCheck {global x; trace info variable x(0)}}
    unset x(0)
    set info
} {0 {}}
test trace-10.4 {set new array element trace during unset trace} {
    catch {unset x}
    set x(0) 33
    set info {}
    trace add variable x(0) unset {traceCheck {uplevel {trace add variable x(0) read {}}}}
    catch {unset x(0)}
    concat $info [trace info variable x(0)]
} {0 {} {read {}}}

test trace-11.1 {make sure arrays are unset before traces are called} {
    catch {unset x}
    set x(0) 33
    set info {}
    trace add variable x unset {traceCheck {uplevel set x(0)}}
    unset x
    set info
} {1 {can't read "x(0)": no such variable}}
test trace-11.2 {make sure arrays are unset before traces are called} {
    catch {unset x}
    set x(y) 33
    set info {}
    trace add variable x unset {traceCheck {uplevel set x(y) 22}}
    unset x
    concat $info [list [catch {set x(y)} msg] $msg]
} {0 22 0 22}
test trace-11.3 {make sure arrays are unset before traces are called} {
    catch {unset x}
    set x(y) 33
    set info {}
    trace add variable x unset {traceCheck {uplevel array exists x}}
    unset x
    set info
} {0 0}
test trace-11.4 {make sure arrays are unset before traces are called} {
    catch {unset x}
    set x(y) 33
    set info {}
    set cmd {traceCheck {uplevel {trace info variable x}}}
    trace add variable x unset $cmd
    unset x
    set info
} {0 {}}
test trace-11.5 {set new array trace during unset trace} {
    catch {unset x}
    set x(y) 33
    set info {}
    trace add variable x unset {traceCheck {global x; trace add variable x read {}}}
    unset x
    concat $info [trace info variable x]
} {0 {} {read {}}}
test trace-11.6 {create scalar during array unset trace} {
    catch {unset x}
    set x(y) 33
    set info {}
    trace add variable x unset {traceCheck {global x; set x 44}}
    unset x
    concat $info [list [catch {set x} msg] $msg]
} {0 44 0 44}

# Check special conditions (e.g. errors) in Tcl_TraceVar2.

test trace-12.1 {creating array when setting variable traces} {
    catch {unset x}
    set info {}
    trace add variable x(0) write traceProc
    list [catch {set x 22} msg] $msg
} {1 {can't set "x": variable is array}}
test trace-12.2 {creating array when setting variable traces} {
    catch {unset x}
    set info {}
    trace add variable x(0) write traceProc
    list [catch {set x(0)} msg] $msg
} {1 {can't read "x(0)": no such element in array}}
test trace-12.3 {creating array when setting variable traces} {
    catch {unset x}
    set info {}
    trace add variable x(0) write traceProc
    set x(0) 22
    set info
} {x 0 write}
test trace-12.4 {creating variable when setting variable traces} {
    catch {unset x}
    set info {}
    trace add variable x write traceProc
    list [catch {set x} msg] $msg
} {1 {can't read "x": no such variable}}
test trace-12.5 {creating variable when setting variable traces} {
    catch {unset x}
    set info {}
    trace add variable x write traceProc
    set x 22
    set info
} {x {} write}
test trace-12.6 {creating variable when setting variable traces} {
    catch {unset x}
    set info {}
    trace add variable x write traceProc
    set x(0) 22
    set info
} {x 0 write}
test trace-12.7 {create array element during read trace} {
    catch {unset x}
    set x(2) zzz
    trace add variable x read {traceCrtElement xyzzy}
    list [catch {set x(3)} msg] $msg
} {0 xyzzy}
test trace-12.8 {errors when setting variable traces} {
    catch {unset x}
    set x 44
    list [catch {trace add variable x(0) write traceProc} msg] $msg
} {1 {can't trace "x(0)": variable isn't array}}

# Check deleting one trace from another.

test trace-13.1 {delete one trace from another} {
    proc delTraces {args} {
	global x
	trace remove variable x read {traceTag 2}
	trace remove variable x read {traceTag 3}
	trace remove variable x read {traceTag 4}
    }
    catch {unset x}
    set x 44
    set info {}
    trace add variable x read {traceTag 1}
    trace add variable x read {traceTag 2}
    trace add variable x read {traceTag 3}
    trace add variable x read {traceTag 4}
    trace add variable x read delTraces 
    trace add variable x read {traceTag 5}
    set x
    set info
} {5 1}

# Check operation and syntax of "trace" command.

# Syntax for adding/removing variable and command traces is basically the
# same:
#	trace add variable name opList command
#	trace remove variable name opList command
#
# The following loops just get all the common "wrong # args" tests done.

set i 0
set start "wrong # args:"
foreach type {variable command} {
    foreach op {add remove} {
	test trace-14.0.[incr i] "trace command, wrong # args errors" {
	    list [catch {trace $op $type} msg] $msg
	} [list 1 "$start should be \"trace $op $type name opList command\""]
	test trace-14.0.[incr i] "trace command wrong # args errors" {
	    list [catch {trace $op $type foo} msg] $msg
	} [list 1 "$start should be \"trace $op $type name opList command\""]
	test trace-14.0.[incr i] "trace command, wrong # args errors" {
	    list [catch {trace $op $type foo bar} msg] $msg
	} [list 1 "$start should be \"trace $op $type name opList command\""]
	test trace-14.0.[incr i] "trace command, wrong # args errors" {
	    list [catch {trace $op $type foo bar baz boo} msg] $msg
	} [list 1 "$start should be \"trace $op $type name opList command\""]
    }
    test trace-14.0.[incr i] "trace command, wrong # args errors" {
	list [catch {trace info $type foo bar} msg] $msg
    } [list 1 "$start should be \"trace info $type name\""]
    test trace-14.0.[incr i] "trace command, wrong # args errors" {
	list [catch {trace info $type} msg] $msg
    } [list 1 "$start should be \"trace info $type name\""]
}

test trace-14.1 "trace command, wrong # args errors" {
    list [catch {trace} msg] $msg
} [list 1 "wrong # args: should be \"trace option ?arg arg ...?\""]
test trace-14.2 "trace command, wrong # args errors" {
    list [catch {trace add} msg] $msg
} [list 1 "wrong # args: should be \"trace add type ?arg arg ...?\""]
test trace-14.3 "trace command, wrong # args errors" {
    list [catch {trace remove} msg] $msg
} [list 1 "wrong # args: should be \"trace remove type ?arg arg ...?\""]
test trace-14.4 "trace command, wrong # args errors" {
    list [catch {trace info} msg] $msg
} [list 1 "wrong # args: should be \"trace info type ?arg arg ...?\""]

test trace-14.5 {trace command, invalid option} {
    list [catch {trace gorp} msg] $msg
} [list 1 "bad option \"gorp\": must be add, info, remove, variable, vdelete, or vinfo"]

# Again, [trace ... command] and [trace ... variable] share syntax and
# error message styles for their opList options; these loops test those 
# error messages.

set i 0
set errs [list "array, read, unset, or write" "delete or rename" "enter, leave, enterstep, or leavestep"]
set abbvs [list {a r u w} {d r} {}]
proc x {} {}
foreach type {variable command execution} err $errs abbvlist $abbvs {
    foreach op {add remove} {
	test trace-14.6.[incr i] "trace $op $type errors" {
	    list [catch {trace $op $type x {y z w} a} msg] $msg
	} [list 1 "bad operation \"y\": must be $err"]
	foreach abbv $abbvlist {
	    test trace-14.6.[incr i] "trace $op $type rejects abbreviations" {
		list [catch {trace $op $type x $abbv a} msg] $msg
	    } [list 1 "bad operation \"$abbv\": must be $err"]
	}
	test trace-14.6.[incr i] "trace $op $type rejects null opList" {
	    list [catch {trace $op $type x {} a} msg] $msg
	} [list 1 "bad operation list \"\": must be one or more of $err"]
    }
}
rename x {}

test trace-14.7 {trace command, "trace variable" errors} {
    list [catch {trace variable} msg] $msg
} [list 1 "wrong # args: should be \"trace variable name ops command\""]
test trace-14.8 {trace command, "trace variable" errors} {
    list [catch {trace variable x} msg] $msg
} [list 1 "wrong # args: should be \"trace variable name ops command\""]
test trace-14.9 {trace command, "trace variable" errors} {
    list [catch {trace variable x y} msg] $msg
} [list 1 "wrong # args: should be \"trace variable name ops command\""]
test trace-14.10 {trace command, "trace variable" errors} {
    list [catch {trace variable x y z w} msg] $msg
} [list 1 "wrong # args: should be \"trace variable name ops command\""]
test trace-14.11 {trace command, "trace variable" errors} {
    list [catch {trace variable x y z} msg] $msg
} [list 1 "bad operations \"y\": should be one or more of rwua"]


test trace-14.9 {trace command ("remove variable" option)} {
    catch {unset x}
    set info {}
    trace add variable x write traceProc
    trace remove variable x write traceProc
} {}
test trace-14.10 {trace command ("remove variable" option)} {
    catch {unset x}
    set info {}
    trace add variable x write traceProc
    trace remove variable x write traceProc
    set x 12345
    set info
} {}
test trace-14.11 {trace command ("remove variable" option)} {
    catch {unset x}
    set info {}
    trace add variable x write {traceTag 1}
    trace add variable x write traceProc
    trace add variable x write {traceTag 2}
    set x yy
    trace remove variable x write traceProc
    set x 12345
    trace remove variable x write {traceTag 1}
    set x foo
    trace remove variable x write {traceTag 2}
    set x gorp
    set info
} {2 x {} write 1 2 1 2}
test trace-14.12 {trace command ("remove variable" option)} {
    catch {unset x}
    set info {}
    trace add variable x write {traceTag 1}
    trace remove variable x write non_existent
    set x 12345
    set info
} {1}
test trace-14.15 {trace command ("list variable" option)} {
    catch {unset x}
    trace add variable x write {traceTag 1}
    trace add variable x write traceProc
    trace add variable x write {traceTag 2}
    trace info variable x
} {{write {traceTag 2}} {write traceProc} {write {traceTag 1}}}
test trace-14.16 {trace command ("list variable" option)} {
    catch {unset x}
    trace info variable x
} {}
test trace-14.17 {trace command ("list variable" option)} {
    catch {unset x}
    trace info variable x(0)
} {}
test trace-14.18 {trace command ("list variable" option)} {
    catch {unset x}
    set x 44
    trace info variable x(0)
} {}
test trace-14.19 {trace command ("list variable" option)} {
    catch {unset x}
    set x 44
    trace add variable x write {traceTag 1}
    proc check {} {global x; trace info variable x}
    check
} {{write {traceTag 1}}}

# Check fancy trace commands (long ones, weird arguments, etc.)

test trace-15.1 {long trace command} {
    catch {unset x}
    set info {}
    trace add variable x write {traceTag {This is a very very long argument.  It's \
	designed to test out the facilities of TraceVarProc for dealing \
	with such long arguments by malloc-ing space.  One possibility \
	is that space doesn't get freed properly.  If this happens, then \
	invoking this test over and over again will eventually leak memory.}}
    set x 44
    set info
} {This is a very very long argument.  It's \
	designed to test out the facilities of TraceVarProc for dealing \
	with such long arguments by malloc-ing space.  One possibility \
	is that space doesn't get freed properly.  If this happens, then \
	invoking this test over and over again will eventually leak memory.}
test trace-15.2 {long trace command result to ignore} {
    proc longResult {args} {return "quite a bit of text, designed to
	generate a core leak if this command file is invoked over and over again
	and memory isn't being recycled correctly"}
    catch {unset x}
    trace add variable x write longResult
    set x 44
    set x 5
    set x abcde
} abcde
test trace-15.3 {special list-handling in trace commands} {
    catch {unset "x y z"}
    set "x y z(a\n\{)" 44
    set info {}
    trace add variable "x y z(a\n\{)" write traceProc
    set "x y z(a\n\{)" 33
    set info
} "{x y z} a\\n\\\{ write"

# Check for proper handling of unsets during traces.

proc traceUnset {unsetName args} {
    global info
    upvar $unsetName x
    lappend info [catch {unset x} msg] $msg [catch {set x} msg] $msg
}
proc traceReset {unsetName resetName args} {
    global info
    upvar $unsetName x $resetName y
    lappend info [catch {unset x} msg] $msg [catch {set y xyzzy} msg] $msg
}
proc traceReset2 {unsetName resetName args} {
    global info
    lappend info [catch {uplevel unset $unsetName} msg] $msg \
	    [catch {uplevel set $resetName xyzzy} msg] $msg
}
proc traceAppend {string name1 name2 op} {
    global info
    lappend info $string
}

test trace-16.1 {unsets during read traces} {
    catch {unset y}
    set y 1234
    set info {}
    trace add variable y read {traceUnset y}
    trace add variable y unset {traceAppend unset}
    lappend info [catch {set y} msg] $msg
} {unset 0 {} 1 {can't read "x": no such variable} 1 {can't read "y": no such variable}}
test trace-16.2 {unsets during read traces} {
    catch {unset y}
    set y(0) 1234
    set info {}
    trace add variable y(0) read {traceUnset y(0)}
    lappend info [catch {set y(0)} msg] $msg
} {0 {} 1 {can't read "x": no such variable} 1 {can't read "y(0)": no such element in array}}
test trace-16.3 {unsets during read traces} {
    catch {unset y}
    set y(0) 1234
    set info {}
    trace add variable y(0) read {traceUnset y}
    lappend info [catch {set y(0)} msg] $msg
} {0 {} 1 {can't read "x": no such variable} 1 {can't read "y(0)": no such variable}}
test trace-16.4 {unsets during read traces} {
    catch {unset y}
    set y 1234
    set info {}
    trace add variable y read {traceReset y y}
    lappend info [catch {set y} msg] $msg
} {0 {} 0 xyzzy 0 xyzzy}
test trace-16.5 {unsets during read traces} {
    catch {unset y}
    set y(0) 1234
    set info {}
    trace add variable y(0) read {traceReset y(0) y(0)}
    lappend info [catch {set y(0)} msg] $msg
} {0 {} 0 xyzzy 0 xyzzy}
test trace-16.6 {unsets during read traces} {
    catch {unset y}
    set y(0) 1234
    set info {}
    trace add variable y(0) read {traceReset y y(0)}
    lappend info [catch {set y(0)} msg] $msg [catch {set y(0)} msg] $msg
} {0 {} 1 {can't set "y": upvar refers to element in deleted array} 1 {can't read "y(0)": no such variable} 1 {can't read "y(0)": no such variable}}
test trace-16.7 {unsets during read traces} {
    catch {unset y}
    set y(0) 1234
    set info {}
    trace add variable y(0) read {traceReset2 y y(0)}
    lappend info [catch {set y(0)} msg] $msg [catch {set y(0)} msg] $msg
} {0 {} 0 xyzzy 1 {can't read "y(0)": no such element in array} 0 xyzzy}
test trace-16.8 {unsets during write traces} {
    catch {unset y}
    set y 1234
    set info {}
    trace add variable y write {traceUnset y}
    trace add variable y unset {traceAppend unset}
    lappend info [catch {set y xxx} msg] $msg
} {unset 0 {} 1 {can't read "x": no such variable} 0 {}}
test trace-16.9 {unsets during write traces} {
    catch {unset y}
    set y(0) 1234
    set info {}
    trace add variable y(0) write {traceUnset y(0)}
    lappend info [catch {set y(0) xxx} msg] $msg
} {0 {} 1 {can't read "x": no such variable} 0 {}}
test trace-16.10 {unsets during write traces} {
    catch {unset y}
    set y(0) 1234
    set info {}
    trace add variable y(0) write {traceUnset y}
    lappend info [catch {set y(0) xxx} msg] $msg
} {0 {} 1 {can't read "x": no such variable} 0 {}}
test trace-16.11 {unsets during write traces} {
    catch {unset y}
    set y 1234
    set info {}
    trace add variable y write {traceReset y y}
    lappend info [catch {set y xxx} msg] $msg
} {0 {} 0 xyzzy 0 xyzzy}
test trace-16.12 {unsets during write traces} {
    catch {unset y}
    set y(0) 1234
    set info {}
    trace add variable y(0) write {traceReset y(0) y(0)}
    lappend info [catch {set y(0) xxx} msg] $msg
} {0 {} 0 xyzzy 0 xyzzy}
test trace-16.13 {unsets during write traces} {
    catch {unset y}
    set y(0) 1234
    set info {}
    trace add variable y(0) write {traceReset y y(0)}
    lappend info [catch {set y(0) xxx} msg] $msg [catch {set y(0)} msg] $msg
} {0 {} 1 {can't set "y": upvar refers to element in deleted array} 0 {} 1 {can't read "y(0)": no such variable}}
test trace-16.14 {unsets during write traces} {
    catch {unset y}
    set y(0) 1234
    set info {}
    trace add variable y(0) write {traceReset2 y y(0)}
    lappend info [catch {set y(0) xxx} msg] $msg [catch {set y(0)} msg] $msg
} {0 {} 0 xyzzy 0 {} 0 xyzzy}
test trace-16.15 {unsets during unset traces} {
    catch {unset y}
    set y 1234
    set info {}
    trace add variable y unset {traceUnset y}
    lappend info [catch {unset y} msg] $msg [catch {set y} msg] $msg
} {1 {can't unset "x": no such variable} 1 {can't read "x": no such variable} 0 {} 1 {can't read "y": no such variable}}
test trace-16.16 {unsets during unset traces} {
    catch {unset y}
    set y(0) 1234
    set info {}
    trace add variable y(0) unset {traceUnset y(0)}
    lappend info [catch {unset y(0)} msg] $msg [catch {set y(0)} msg] $msg
} {1 {can't unset "x": no such variable} 1 {can't read "x": no such variable} 0 {} 1 {can't read "y(0)": no such element in array}}
test trace-16.17 {unsets during unset traces} {
    catch {unset y}
    set y(0) 1234
    set info {}
    trace add variable y(0) unset {traceUnset y}
    lappend info [catch {unset y(0)} msg] $msg [catch {set y(0)} msg] $msg
} {0 {} 1 {can't read "x": no such variable} 0 {} 1 {can't read "y(0)": no such variable}}
test trace-16.18 {unsets during unset traces} {
    catch {unset y}
    set y 1234
    set info {}
    trace add variable y unset {traceReset2 y y}
    lappend info [catch {unset y} msg] $msg [catch {set y} msg] $msg
} {1 {can't unset "y": no such variable} 0 xyzzy 0 {} 0 xyzzy}
test trace-16.19 {unsets during unset traces} {
    catch {unset y}
    set y(0) 1234
    set info {}
    trace add variable y(0) unset {traceReset2 y(0) y(0)}
    lappend info [catch {unset y(0)} msg] $msg [catch {set y(0)} msg] $msg
} {1 {can't unset "y(0)": no such element in array} 0 xyzzy 0 {} 0 xyzzy}
test trace-16.20 {unsets during unset traces} {
    catch {unset y}
    set y(0) 1234
    set info {}
    trace add variable y(0) unset {traceReset2 y y(0)}
    lappend info [catch {unset y(0)} msg] $msg [catch {set y(0)} msg] $msg
} {0 {} 0 xyzzy 0 {} 0 xyzzy}
test trace-16.21 {unsets cancelling traces} {
    catch {unset y}
    set y 1234
    set info {}
    trace add variable y read {traceAppend first}
    trace add variable y read {traceUnset y}
    trace add variable y read {traceAppend third}
    trace add variable y unset {traceAppend unset}
    lappend info [catch {set y} msg] $msg
} {third unset 0 {} 1 {can't read "x": no such variable} 1 {can't read "y": no such variable}}
test trace-16.22 {unsets cancelling traces} {
    catch {unset y}
    set y(0) 1234
    set info {}
    trace add variable y(0) read {traceAppend first}
    trace add variable y(0) read {traceUnset y}
    trace add variable y(0) read {traceAppend third}
    trace add variable y(0) unset {traceAppend unset}
    lappend info [catch {set y(0)} msg] $msg
} {third unset 0 {} 1 {can't read "x": no such variable} 1 {can't read "y(0)": no such variable}}

# Check various non-interference between traces and other things.

test trace-17.1 {trace doesn't prevent unset errors} {
    catch {unset x}
    set info {}
    trace add variable x unset {traceProc}
    list [catch {unset x} msg] $msg $info
} {1 {can't unset "x": no such variable} {x {} unset}}
test trace-17.2 {traced variables must survive procedure exits} {
    catch {unset x}
    proc p1 {} {global x; trace add variable x write traceProc}
    p1
    trace info variable x
} {{write traceProc}}
test trace-17.3 {traced variables must survive procedure exits} {
    catch {unset x}
    set info {}
    proc p1 {} {global x; trace add variable x write traceProc}
    p1
    set x 44
    set info
} {x {} write}

# Be sure that procedure frames are released before unset traces
# are invoked.

test trace-18.1 {unset traces on procedure returns} {
    proc p1 {x y} {set a 44; p2 14}
    proc p2 {z} {trace add variable z unset {traceCheck {lsort [uplevel {info vars}]}}}
    set info {}
    p1 foo bar
    set info
} {0 {a x y}}
test trace-18.2 {namespace delete / trace vdelete combo} {
    namespace eval ::foo {
	variable x 123
    }
    proc p1 args {
	trace vdelete ::foo::x u p1
    }
    trace variable ::foo::x u p1
    namespace delete ::foo
    info exists ::foo::x
} 0

# Delete arrays when done, so they can be re-used as scalars
# elsewhere.

catch {unset x}
catch {unset y}

test trace-18.2 {trace add command (command existence)} {
    # Just in case!
    catch {rename nosuchname ""}
    list [catch {trace add command nosuchname rename traceCommand} msg] $msg
} {1 {unknown command "nosuchname"}}
test trace-18.3 {trace add command (command existence in ns)} {
    list [catch {trace add command nosuchns::nosuchname rename traceCommand} msg] $msg
} {1 {unknown command "nosuchns::nosuchname"}}


test trace-19.1 {trace add command (rename option)} {
    proc foo {} {}
    catch {rename bar {}}
    trace add command foo rename traceCommand
    rename foo bar
    set info
} {foo bar rename}
test trace-19.2 {traces stick with renamed commands} {
    proc foo {} {}
    catch {rename bar {}}
    trace add command foo rename traceCommand
    rename foo bar
    rename bar foo
    set info
} {bar foo rename}
test trace-19.2.1 {trace add command rename trace exists} {
    proc foo {} {}
    trace add command foo rename traceCommand
    trace info command foo
} {{rename traceCommand}}
test trace-19.3 {command rename traces don't fire on command deletion} {
    proc foo {} {}
    set info {}
    trace add command foo rename traceCommand
    rename foo {}
    set info
} {}
test trace-19.4 {trace add command rename doesn't trace recreated commands} {
    proc foo {} {}
    catch {rename bar {}}
    trace add command foo rename traceCommand
    proc foo {} {}
    rename foo bar
    set info
} {}
test trace-19.5 {trace add command deleted removes traces} {
    proc foo {} {}
    trace add command foo rename traceCommand
    proc foo {} {}
    trace info command foo
} {}

namespace eval tc {}
proc tc::tcfoo {} {}
test trace-19.6 {trace add command rename in namespace} {
    trace add command tc::tcfoo rename traceCommand
    rename tc::tcfoo tc::tcbar
    set info
} {tc::tcfoo tc::tcbar rename}
test trace-19.7 {trace add command rename in namespace back again} {
    rename tc::tcbar tc::tcfoo
    set info
} {tc::tcbar tc::tcfoo rename}
test trace-19.8 {trace add command rename in namespace to out of namespace} {
    rename tc::tcfoo tcbar
    set info
} {tc::tcfoo tcbar rename}
test trace-19.9 {trace add command rename back into namespace} {
    rename tcbar tc::tcfoo
    set info
} {tcbar tc::tcfoo rename}
test trace-19.10 {trace add command failed rename doesn't trigger trace} {
    set info {}
    proc foo {} {}
    proc bar {} {}
    trace add command foo {rename delete} traceCommand
    catch {rename foo bar}
    set info
} {}
catch {rename foo {}}
catch {rename bar {}}

# Make sure it exists again
proc foo {} {}

test trace-20.1 {trace add command (delete option)} {
    trace add command foo delete traceCommand
    rename foo ""
    set info
} {::foo {} delete}
test trace-20.2 {trace add command delete doesn't trace recreated commands} {
    set info {}
    proc foo {} {}
    rename foo ""
    set info
} {}
test trace-20.2.1 {trace add command delete trace info} {
    proc foo {} {}
    trace add command foo delete traceCommand
    trace info command foo
} {{delete traceCommand}}
test trace-20.3 {trace add command implicit delete} {
    proc foo {} {}
    trace add command foo delete traceCommand
    proc foo {} {}
    set info
} {::foo {} delete}
test trace-20.3.1 {trace add command delete trace info} {
    proc foo {} {}
    trace info command foo
} {}
test trace-20.4 {trace add command rename followed by delete} {
    set infotemp {}
    proc foo {} {}
    trace add command foo {rename delete} traceCommand
    rename foo bar
    lappend infotemp $info
    rename bar {}
    lappend infotemp $info
    set info $infotemp
    unset infotemp
    set info
} {{foo bar rename} {::bar {} delete}}
catch {rename foo {}}
catch {rename bar {}}

test trace-20.5 {trace add command rename and delete} {
    set infotemp {}
    set info {}
    proc foo {} {}
    trace add command foo {rename delete} traceCommand
    rename foo bar
    lappend infotemp $info
    rename bar {}
    lappend infotemp $info
    set info $infotemp
    unset infotemp
    set info
} {{foo bar rename} {::bar {} delete}}

test trace-20.6 {trace add command rename and delete in subinterp} {
    set tc [interp create]
    foreach p {traceCommand} {
	$tc eval [list proc $p [info args $p] [info body $p]]
    }
    $tc eval [list set infotemp {}]
    $tc eval [list set info {}]
    $tc eval [list proc foo {} {}]
    $tc eval [list trace add command foo {rename delete} traceCommand]
    $tc eval [list rename foo bar]
    $tc eval {lappend infotemp $info}
    $tc eval [list rename bar {}]
    $tc eval {lappend infotemp $info}
    $tc eval {set info $infotemp}
    $tc eval [list unset infotemp]
    set info [$tc eval [list set info]]
    interp delete $tc
    set info
} {{foo bar rename} {::bar {} delete}}

# I'd like it if this test could give 'foo {} d' as a result,
# but interp deletion means there is no interp to evaluate
# the trace in.
test trace-20.7 {trace add command delete in subinterp while being deleted} {
    set info {}
    set tc [interp create]
    interp alias $tc traceCommand {} traceCommand
    $tc eval [list proc foo {} {}]
    $tc eval [list trace add command foo {rename delete} traceCommand]
    interp delete $tc
    set info
} {}

proc traceDelete {cmd old new op} {
    eval trace remove command $cmd [lindex [trace info command $cmd] 0]
    global info
    set info [list $old $new $op]
}
proc traceCmdrename {cmd old new op} {
    rename $old someothername
}
proc traceCmddelete {cmd old new op} {
    rename $old ""
}
test trace-20.8 {trace delete while trace is active} {
    set info {}
    proc foo {} {}
    catch {rename bar {}}
    trace add command foo {rename delete} [list traceDelete foo]
    rename foo bar
    list [set info] [trace info command bar]
} {{foo bar rename} {}}

test trace-20.9 {rename trace deletes command} {
    set info {}
    proc foo {} {}
    catch {rename bar {}}
    catch {rename someothername {}}
    trace add command foo rename [list traceCmddelete foo]
    rename foo bar
    list [info commands foo] [info commands bar] [info commands someothername]
} {{} {} {}}

test trace-20.10 {rename trace renames command} {
    set info {}
    proc foo {} {}
    catch {rename bar {}}
    catch {rename someothername {}}
    trace add command foo rename [list traceCmdrename foo]
    rename foo bar
    set info [list [info commands foo] [info commands bar] [info commands someothername]]
    rename someothername {}
    set info
} {{} {} someothername}

test trace-20.11 {delete trace deletes command} {
    set info {}
    proc foo {} {}
    catch {rename bar {}}
    catch {rename someothername {}}
    trace add command foo delete [list traceCmddelete foo]
    rename foo {}
    list [info commands foo] [info commands bar] [info commands someothername]
} {{} {} {}}

test trace-20.12 {delete trace renames command} {
    set info {}
    proc foo {} {}
    catch {rename bar {}}
    catch {rename someothername {}}
    trace add command foo delete [list traceCmdrename foo]
    rename foo bar
    rename bar {}
    # None of these should exist.
    list [info commands foo] [info commands bar] [info commands someothername]
} {{} {} {}}

proc foo {b} { set a $b }


# Delete arrays when done, so they can be re-used as scalars
# elsewhere.

catch {unset x}
catch {unset y}

# Delete procedures when done, so we don't clash with other tests
# (e.g. foobar will clash with 'unknown' tests).
catch {rename foobar {}}
catch {rename foo {}}
catch {rename bar {}}

proc foo {a} {
    set b $a
}

proc traceExecute {args} {
    global info
    lappend info $args
}

test trace-21.1 {trace execution: enter} {
    set info {}
    trace add execution foo enter [list traceExecute foo]
    foo 1
    trace remove execution foo enter [list traceExecute foo]
    set info
} {{foo {foo 1} enter}}

test trace-21.2 {trace exeuction: leave} {
    set info {}
    trace add execution foo leave [list traceExecute foo]
    foo 2
    trace remove execution foo leave [list traceExecute foo]
    set info
} {{foo {foo 2} 0 2 leave}}

test trace-21.3 {trace exeuction: enter, leave} {
    set info {}
    trace add execution foo {enter leave} [list traceExecute foo]
    foo 3
    trace remove execution foo {enter leave} [list traceExecute foo]
    set info
} {{foo {foo 3} enter} {foo {foo 3} 0 3 leave}}

test trace-21.4 {trace execution: enter, leave, enterstep} {
    set info {}
    trace add execution foo {enter leave enterstep} [list traceExecute foo]
    foo 3
    trace remove execution foo {enter leave enterstep} [list traceExecute foo]
    set info
} {{foo {foo 3} enter} {foo {set b 3} enterstep} {foo {foo 3} 0 3 leave}}

test trace-21.5 {trace execution: enter, leave, enterstep, leavestep} {
    set info {}
    trace add execution foo {enter leave enterstep leavestep} [list traceExecute foo]
    foo 3
    trace remove execution foo {enter leave enterstep leavestep} [list traceExecute foo]
    set info
} {{foo {foo 3} enter} {foo {set b 3} enterstep} {foo {set b 3} 0 3 leavestep} {foo {foo 3} 0 3 leave}}

test trace-21.6 {trace execution: enterstep, leavestep} {
    set info {}
    trace add execution foo {enterstep leavestep} [list traceExecute foo]
    foo 3
    trace remove execution foo {enterstep leavestep} [list traceExecute foo]
    set info
} {{foo {set b 3} enterstep} {foo {set b 3} 0 3 leavestep}}

test trace-21.7 {trace execution: enterstep} {
    set info {}
    trace add execution foo {enterstep} [list traceExecute foo]
    foo 3
    trace remove execution foo {enterstep} [list traceExecute foo]
    set info
} {{foo {set b 3} enterstep}}

test trace-21.8 {trace execution: leavestep} {
    set info {}
    trace add execution foo {leavestep} [list traceExecute foo]
    foo 3
    trace remove execution foo {leavestep} [list traceExecute foo]
    set info
} {{foo {set b 3} 0 3 leavestep}}

proc factorial {n} {
    if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }
    return 1
}

test trace-22.1 {recursive(1) trace execution: enter} {
    set info {}
    trace add execution factorial {enter} [list traceExecute factorial]
    factorial 1
    trace remove execution factorial {enter} [list traceExecute factorial]
    set info
} {{factorial {factorial 1} enter}}

test trace-22.2 {recursive(2) trace execution: enter} {
    set info {}
    trace add execution factorial {enter} [list traceExecute factorial]
    factorial 2
    trace remove execution factorial {enter} [list traceExecute factorial]
    set info
} {{factorial {factorial 2} enter} {factorial {factorial 1} enter}}

test trace-22.3 {recursive(3) trace execution: enter} {
    set info {}
    trace add execution factorial {enter} [list traceExecute factorial]
    factorial 3
    trace remove execution factorial {enter} [list traceExecute factorial]
    set info
} {{factorial {factorial 3} enter} {factorial {factorial 2} enter} {factorial {factorial 1} enter}}

test trace-23.1 {recursive(1) trace execution: enter, leave, enterstep, leavestep} {
    set info {}
    trace add execution factorial {enter leave enterstep leavestep} [list traceExecute]
    factorial 1
    trace remove execution factorial {enter leave enterstep leavestep} [list traceExecute]
    join $info "\n"
} {{factorial 1} enter
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} enterstep
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} 0 {} leavestep
{return 1} enterstep
{return 1} 2 1 leavestep
{factorial 1} 0 1 leave}

test trace-23.2 {recursive(2) trace execution: enter, leave, enterstep, leavestep} {
    set info {}
    trace add execution factorial {enter leave enterstep leavestep} [list traceExecute]
    factorial 2
    trace remove execution factorial {enter leave enterstep leavestep} [list traceExecute]
    join $info "\n"
} {{factorial 2} enter
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} enterstep
{expr {$n * [factorial [expr {$n -1 }]]}} enterstep
{expr {$n -1 }} enterstep
{expr {$n -1 }} 0 1 leavestep
{factorial 1} enterstep
{factorial 1} enter
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} enterstep
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} 0 {} leavestep
{return 1} enterstep
{return 1} 2 1 leavestep
{factorial 1} 0 1 leave
{factorial 1} 0 1 leavestep
{expr {$n * [factorial [expr {$n -1 }]]}} 0 2 leavestep
{return 2} enterstep
{return 2} 2 2 leavestep
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} 2 2 leavestep
{factorial 2} 0 2 leave}

test trace-23.3 {recursive(3) trace execution: enter, leave, enterstep, leavestep} {
    set info {}
    trace add execution factorial {enter leave enterstep leavestep} [list traceExecute]
    factorial 3
    trace remove execution factorial {enter leave enterstep leavestep} [list traceExecute]
    join $info "\n"
} {{factorial 3} enter
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} enterstep
{expr {$n * [factorial [expr {$n -1 }]]}} enterstep
{expr {$n -1 }} enterstep
{expr {$n -1 }} 0 2 leavestep
{factorial 2} enterstep
{factorial 2} enter
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} enterstep
{expr {$n * [factorial [expr {$n -1 }]]}} enterstep
{expr {$n -1 }} enterstep
{expr {$n -1 }} 0 1 leavestep
{factorial 1} enterstep
{factorial 1} enter
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} enterstep
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} 0 {} leavestep
{return 1} enterstep
{return 1} 2 1 leavestep
{factorial 1} 0 1 leave
{factorial 1} 0 1 leavestep
{expr {$n * [factorial [expr {$n -1 }]]}} 0 2 leavestep
{return 2} enterstep
{return 2} 2 2 leavestep
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} 2 2 leavestep
{factorial 2} 0 2 leave
{factorial 2} 0 2 leavestep
{expr {$n * [factorial [expr {$n -1 }]]}} 0 6 leavestep
{return 6} enterstep
{return 6} 2 6 leavestep
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} 2 6 leavestep
{factorial 3} 0 6 leave}

proc traceDelete {cmd args} {
    eval trace remove execution $cmd [lindex [trace info execution $cmd] 0]
    global info
    set info $args
}

test trace-24.1 {delete trace during enter trace} {
    set info {}
    trace add execution foo enter [list traceDelete foo]
    foo 1
    list $info [trace info execution foo]
} {{{foo 1} enter} {}}

test trace-24.2 {delete trace during leave trace} {
    set info {}
    trace add execution foo leave [list traceDelete foo]
    foo 1
    list $info [trace info execution foo]
} {{{foo 1} 0 1 leave} {}}

test trace-24.3 {delete trace during enter-leave trace} {
    set info {}
    trace add execution foo {enter leave} [list traceDelete foo]
    foo 1
    list $info [trace info execution foo]
} {{{foo 1} enter} {}}

test trace-24.4 {delete trace during all exec traces} {
    set info {}
    trace add execution foo {enter leave enterstep leavestep} [list traceDelete foo]
    foo 1
    list $info [trace info execution foo]
} {{{foo 1} enter} {}}

test trace-24.5 {delete trace during all exec traces except enter} {
    set info {}
    trace add execution foo {leave enterstep leavestep} [list traceDelete foo]
    foo 1
    list $info [trace info execution foo]
} {{{set b 1} enterstep} {}}

proc traceDelete {cmd args} {
    rename $cmd {}
    global info
    set info $args
}

proc foo {a} {
    set b $a
}

test trace-25.1 {delete command during enter trace} {
    set info {}
    trace add execution foo enter [list traceDelete foo]
    catch {foo 1} err
    list $err $info [trace info execution foo]
} {{invalid command name "foo"} {{foo 1} enter} {unknown command "foo"}}

proc foo {a} {
    set b $a
}

test trace-25.2 {delete command during leave trace} {
    set info {}
    trace add execution foo leave [list traceDelete foo]
    foo 1
    list $info [trace info execution foo]
} {{{foo 1} 0 1 leave} {unknown command "foo"}}

proc foo {a} {
    set b $a
}

test trace-25.3 {delete command during enter then leave trace} {
    set info {}
    trace add execution foo enter [list traceDelete foo]
    trace add execution foo leave [list traceDelete foo]
    catch {foo 1} err
    list $err $info [trace info execution foo]
} {{invalid command name "foo"} {{foo 1} enter} {unknown command "foo"}}

proc foo {a} {
    set b $a
}
proc traceExecute2 {args} {
    global info
    lappend info $args
}

# This shows the peculiar consequences of having two traces
# at the same time: as well as tracing the procedure you want
test trace-25.4 {order dependencies of two enter traces} {
    set info {}
    trace add execution foo enter [list traceExecute traceExecute]
    trace add execution foo enter [list traceExecute2 traceExecute2]
    catch {foo 1} err
    trace remove execution foo enter [list traceExecute traceExecute]
    trace remove execution foo enter [list traceExecute2 traceExecute2]
    join [list $err [join $info \n] [trace info execution foo]] "\n"
} {1
traceExecute2 {foo 1} enter
traceExecute {foo 1} enter
}

test trace-25.5 {order dependencies of two step traces} {
    set info {}
    trace add execution foo enterstep [list traceExecute traceExecute]
    trace add execution foo enterstep [list traceExecute2 traceExecute2]
    catch {foo 1} err
    trace remove execution foo enterstep [list traceExecute traceExecute]
    trace remove execution foo enterstep [list traceExecute2 traceExecute2]
    join [list $err [join $info \n] [trace info execution foo]] "\n"
} {1
traceExecute2 {set b 1} enterstep
traceExecute {set b 1} enterstep
}

# We don't want the result string (5th argument), or the results
# will get unmanageable.
proc tracePostExecute {args} {
    global info
    lappend info [concat [lrange $args 0 2] [lindex $args 4]]
}
proc tracePostExecute2 {args} {
    global info
    lappend info [concat [lrange $args 0 2] [lindex $args 4]]
}

test trace-25.6 {order dependencies of two leave traces} {
    set info {}
    trace add execution foo leave [list tracePostExecute tracePostExecute]
    trace add execution foo leave [list tracePostExecute2 tracePostExecute2]
    catch {foo 1} err
    trace remove execution foo leave [list tracePostExecute tracePostExecute]
    trace remove execution foo leave [list tracePostExecute2 tracePostExecute2]
    join [list $err [join $info \n] [trace info execution foo]] "\n"
} {1
tracePostExecute {foo 1} 0 leave
tracePostExecute2 {foo 1} 0 leave
}

test trace-25.7 {order dependencies of two leavestep traces} {
    set info {}
    trace add execution foo leavestep [list tracePostExecute tracePostExecute]
    trace add execution foo leavestep [list tracePostExecute2 tracePostExecute2]
    catch {foo 1} err
    trace remove execution foo leavestep [list tracePostExecute tracePostExecute]
    trace remove execution foo leavestep [list tracePostExecute2 tracePostExecute2]
    join [list $err [join $info \n] [trace info execution foo]] "\n"
} {1
tracePostExecute {set b 1} 0 leavestep
tracePostExecute2 {set b 1} 0 leavestep
}

proc foo {a} {
    set b $a
}

proc traceDelete {cmd args} {
    rename $cmd {}
    global info
    set info $args
}

test trace-25.8 {delete command during enter leave and enter/leave-step traces} {
    set info {}
    trace add execution foo enter [list traceDelete foo]
    trace add execution foo leave [list traceDelete foo]
    trace add execution foo enterstep [list traceDelete foo]
    trace add execution foo leavestep [list traceDelete foo]
    catch {foo 1} err
    list $err $info [trace info execution foo]
} {{invalid command name "foo"} {{foo 1} enter} {unknown command "foo"}}

proc foo {a} {
    set b $a
}

test trace-25.9 {delete command during enter leave and leavestep traces} {
    set info {}
    trace add execution foo enter [list traceDelete foo]
    trace add execution foo leave [list traceDelete foo]
    trace add execution foo leavestep [list traceDelete foo]
    catch {foo 1} err
    list $err $info [trace info execution foo]
} {{invalid command name "foo"} {{foo 1} enter} {unknown command "foo"}}

proc foo {a} {
    set b $a
}

test trace-25.10 {delete command during leave and leavestep traces} {
    set info {}
    trace add execution foo leave [list traceDelete foo]
    trace add execution foo leavestep [list traceDelete foo]
    catch {foo 1} err
    list $err $info [trace info execution foo]
} {1 {{set b 1} 0 1 leavestep} {unknown command "foo"}}

proc foo {a} {
    set b $a
}

test trace-25.11 {delete command during enter and enterstep traces} {
    set info {}
    trace add execution foo enter [list traceDelete foo]
    trace add execution foo enterstep [list traceDelete foo]
    catch {foo 1} err
    list $err $info [trace info execution foo]
} {{invalid command name "foo"} {{foo 1} enter} {unknown command "foo"}}

test trace-26.1 {trace targetCmd when invoked through an alias} {
    proc foo {args} {
	set b $args
    }
    set info {}
    trace add execution foo enter [list traceExecute foo]
    interp alias {} bar {} foo 1
    bar 2
    trace remove execution foo enter [list traceExecute foo]
    set info
} {{foo {foo 1 2} enter}}
test trace-26.2 {trace targetCmd when invoked through an alias} {
    proc foo {args} {
	set b $args
    }
    set info {}
    trace add execution foo enter [list traceExecute foo]
    interp create child
    interp alias child bar {} foo 1
    child eval bar 2
    interp delete child
    trace remove execution foo enter [list traceExecute foo]
    set info
} {{foo {foo 1 2} enter}}

test trace-27.1 {memory leak in rename trace (604609)} {
    catch {rename bar {}}
    proc foo {} {error foo}
    trace add command foo rename {rename foo "" ;#}
    rename foo bar
    info commands foo
} {}

test trace-28.1 {enterstep and leavestep traces with update idletasks (615043)} {
    catch {rename foo {}}
    proc foo {} {
        set a 1
        update idletasks
        set b 1
    }

    set info {}
    trace add execution foo {enter enterstep leavestep leave} \
        [list traceExecute foo]
    update
    after idle {puts idle}
    foo

    trace remove execution foo {enter enterstep leavestep leave} \
        [list traceExecute foo]
    rename foo {}
    join $info "\n"
} {foo foo enter
foo {set a 1} enterstep
foo {set a 1} 0 1 leavestep
foo {update idletasks} enterstep
foo {puts idle} enterstep
foo {puts idle} 0 {} leavestep
foo {update idletasks} 0 {} leavestep
foo {set b 1} enterstep
foo {set b 1} 0 1 leavestep
foo foo 0 1 leave}

# Delete procedures when done, so we don't clash with other tests
# (e.g. foobar will clash with 'unknown' tests).
catch {rename foobar {}}
catch {rename foo {}}
catch {rename bar {}}

# Unset the varaible when done
catch {unset info}

# cleanup
::tcltest::cleanupTests
return

@


1.4
log
@touched all sources to ease next import
@
text
@d14 1
a14 1
# RCS: @@(#) $Id: trace.test,v 1.6.8.2 2000/09/15 16:57:45 spolk Exp $
d55 15
d76 1
a76 1
    trace var x r traceScalar
d78 1
a78 1
} {1 {can't read "x": no such variable} {x {} r 1 {can't read "x": no such variable}}}
d83 1
a83 1
    trace var x r traceScalar
d85 1
a85 1
} {0 123 {x {} r 0 123}}
d89 1
a89 1
    trace var x r traceScalar
d96 1
a96 1
    trace var x(2) r traceArray
d98 1
a98 1
} {1 {can't read "x(2)": no such element in array} {x 2 r 1 {can't read "x(2)": no such element in array}}}
d103 1
a103 1
    trace var x(2) r traceArray
d105 1
a105 1
} {0 zzz {x 2 r 0 zzz}}
d109 1
a109 1
    trace variable x r traceArray2
d116 1
a116 1
} {0 willi {x 2 r}}
d120 1
a120 1
    trace variable x r q
d133 1
a133 1
} {0 wolf {x Y r}}
d137 1
a137 1
    trace var x r traceArray
d144 1
a144 1
    trace var x r traceArray
d146 1
a146 1
} {0 zzz {x 2 r 0 zzz}}
d151 1
a151 1
    trace var x r traceScalar
d155 28
d189 1
a189 1
    trace var x w traceScalar
d192 1
a192 1
} {x {} w 0 123}
d196 1
a196 1
    trace var x(33) w traceArray
d199 1
a199 1
} {x 33 w 0 444}
d203 1
a203 1
    trace var x w traceArray
d206 1
a206 1
} {x abc w 0 qq}
d211 1
a211 1
    trace var x w traceScalar
d219 1
a219 1
    trace var x w traceScalar
d232 1
a232 1
    trace var x r traceScalarAppend
d237 1
a237 1
} {x {} r 0 123456}
d241 1
a241 1
    trace var x rw traceScalarAppend
d245 1
a245 1
} {x {} w 0 123 x {} r 0 123 x {} w 0 {123 456}}
d252 1
a252 1
    trace var x u traceScalar
d255 1
a255 1
} {x {} u 1 {can't read "x": no such variable}}
d260 1
a260 1
    trace var x u traceScalar
d263 1
a263 1
} {x {} u 1 {can't read "x": no such variable}}
d267 1
a267 1
    trace var x u traceScalar
d276 1
a276 1
    trace var x(1) u traceArray
d279 1
a279 1
} {x 1 u 1 {can't read "x(1)": no such element in array}}
d284 1
a284 1
    trace var x(1) u traceArray
d287 1
a287 1
} {x 1 u 1 {can't read "x(1)": no such element in array}}
d292 1
a292 1
    trace var x(1) u traceArray
d295 1
a295 1
} {x 1 u 1 {can't read "x(1)": no such variable}}
d300 1
a300 1
    trace var x u traceProc
d310 1
a310 1
    trace var x u traceProc
d313 1
a313 1
} {x 1 u}
d320 1
a320 1
    trace var x u traceProc
d323 1
a323 1
} {x {} u}
d325 60
d387 1
a387 1
test trace-5.1 {multiple ops traced at once} {
d390 1
a390 1
    trace var x rwu traceProc
d397 2
a398 2
} {x {} r x {} w x {} r x {} w x {} u}
test trace-5.2 {multiple ops traced on array element} {
d401 1
a401 1
    trace var x(0) rwu traceProc
d409 2
a410 2
} {x 0 r x 0 w x 0 r x 0 w x 0 u}
test trace-5.3 {multiple ops traced on whole array} {
d413 1
a413 1
    trace var x rwu traceProc
d421 1
a421 1
} {x 0 w x 0 r x 0 w x 0 u x {} u}
d425 1
a425 1
test trace-6.1 {order of invocation of traces} {
d428 3
a430 3
    trace var x r "traceTag 1"
    trace var x r "traceTag 2"
    trace var x r "traceTag 3"
d436 1
a436 1
test trace-6.2 {order of invocation of traces} {
d440 3
a442 3
    trace var x(0) r "traceTag 1"
    trace var x(0) r "traceTag 2"
    trace var x(0) r "traceTag 3"
d446 1
a446 1
test trace-6.3 {order of invocation of traces} {
d450 6
a455 6
    trace var x(0) r "traceTag 1"
    trace var x r "traceTag A1"
    trace var x(0) r "traceTag 2"
    trace var x r "traceTag A2"
    trace var x(0) r "traceTag 3"
    trace var x r "traceTag A3"
d462 1
a462 1
test trace-7.1 {error returns from traces} {
d466 2
a467 2
    trace var x r "traceTag 1"
    trace var x r traceError
d470 1
a470 1
test trace-7.2 {error returns from traces} {
d474 2
a475 2
    trace var x w "traceTag 1"
    trace var x w traceError
d478 1
a478 1
test trace-7.3 {error returns from traces} {
d482 1
a482 1
    trace var x w traceError
d485 1
a485 1
test trace-7.4 {error returns from traces} {
d489 2
a490 2
    trace var x u "traceTag 1"
    trace var x u traceError
d493 1
a493 1
test trace-7.5 {error returns from traces} {
d497 4
a500 4
    trace var x(0) r "traceTag 1"
    trace var x r "traceTag 2"
    trace var x r traceError
    trace var x r "traceTag 3"
d503 1
a503 1
test trace-7.6 {error returns from traces} {
d506 1
a506 1
    trace var x u traceError
d509 1
a509 1
test trace-7.7 {error returns from traces} {
d515 1
a515 1
    trace var x r traceError
d518 23
a540 1
    trace vdelete x r traceError
d547 1
a547 1
test trace-8.1 {be sure variable is unset before trace is called} {
d551 1
a551 1
    trace var x u {traceCheck {uplevel set x}}
d555 1
a555 1
test trace-8.2 {be sure variable is unset before trace is called} {
d559 1
a559 1
    trace var x u {traceCheck {uplevel set x 22}}
d563 1
a563 1
test trace-8.3 {be sure traces are cleared before unset trace called} {
d567 1
a567 1
    trace var x u {traceCheck {uplevel trace vinfo x}}
d571 1
a571 1
test trace-8.4 {set new trace during unset trace} {
d575 1
a575 1
    trace var x u {traceCheck {global x; trace var x u traceProc}}
d577 2
a578 2
    concat $info [trace vinfo x]
} {0 {} {u traceProc}}
d580 1
a580 1
test trace-9.1 {make sure array elements are unset before traces are called} {
d584 1
a584 1
    trace var x(0) u {traceCheck {uplevel set x(0)}}
d588 1
a588 1
test trace-9.2 {make sure array elements are unset before traces are called} {
d592 1
a592 1
    trace var x(0) u {traceCheck {uplevel set x(0) zzz}}
d596 1
a596 1
test trace-9.3 {array elements are unset before traces are called} {
d600 1
a600 1
    trace var x(0) u {traceCheck {global x; trace vinfo x(0)}}
d604 1
a604 1
test trace-9.4 {set new array element trace during unset trace} {
d608 1
a608 1
    trace var x(0) u {traceCheck {uplevel {trace variable x(0) r {}}}}
d610 2
a611 2
    concat $info [trace vinfo x(0)]
} {0 {} {r {}}}
d613 1
a613 1
test trace-10.1 {make sure arrays are unset before traces are called} {
d617 1
a617 1
    trace var x u {traceCheck {uplevel set x(0)}}
d621 1
a621 1
test trace-10.2 {make sure arrays are unset before traces are called} {
d625 1
a625 1
    trace var x u {traceCheck {uplevel set x(y) 22}}
d629 1
a629 1
test trace-10.3 {make sure arrays are unset before traces are called} {
d633 1
a633 1
    trace var x u {traceCheck {uplevel array exists x}}
d637 1
a637 1
test trace-10.4 {make sure arrays are unset before traces are called} {
d641 2
a642 2
    set cmd {traceCheck {uplevel {trace vinfo x}}}
    trace var x u $cmd
d646 1
a646 1
test trace-10.5 {set new array trace during unset trace} {
d650 1
a650 1
    trace var x u {traceCheck {global x; trace var x r {}}}
d652 3
a654 3
    concat $info [trace vinfo x]
} {0 {} {r {}}}
test trace-10.6 {create scalar during array unset trace} {
d658 1
a658 1
    trace var x u {traceCheck {global x; set x 44}}
d665 1
a665 1
test trace-11.1 {creating array when setting variable traces} {
d668 1
a668 1
    trace var x(0) w traceProc
d671 1
a671 1
test trace-11.2 {creating array when setting variable traces} {
d674 1
a674 1
    trace var x(0) w traceProc
d677 1
a677 1
test trace-11.3 {creating array when setting variable traces} {
d680 1
a680 1
    trace var x(0) w traceProc
d683 2
a684 2
} {x 0 w}
test trace-11.4 {creating variable when setting variable traces} {
d687 1
a687 1
    trace var x w traceProc
d690 1
a690 1
test trace-11.5 {creating variable when setting variable traces} {
d693 1
a693 1
    trace var x w traceProc
d696 2
a697 2
} {x {} w}
test trace-11.6 {creating variable when setting variable traces} {
d700 1
a700 1
    trace var x w traceProc
d703 2
a704 2
} {x 0 w}
test trace-11.7 {create array element during read trace} {
d707 1
a707 1
    trace var x r {traceCrtElement xyzzy}
d710 1
a710 1
test trace-11.8 {errors when setting variable traces} {
d713 1
a713 1
    list [catch {trace var x(0) w traceProc} msg] $msg
d718 1
a718 1
test trace-12.1 {delete one trace from another} {
d721 3
a723 3
	trace vdel x r {traceTag 2}
	trace vdel x r {traceTag 3}
	trace vdel x r {traceTag 4}
d728 6
a733 6
    trace var x r {traceTag 1}
    trace var x r {traceTag 2}
    trace var x r {traceTag 3}
    trace var x r {traceTag 4}
    trace var x r delTraces 
    trace var x r {traceTag 5}
d740 33
a772 1
test trace-13.1 {trace command (overall)} {
d774 12
a785 2
} {1 {wrong # args: should be "trace option [arg arg ...]"}}
test trace-13.2 {trace command (overall)} {
d787 34
a820 2
} {1 {bad option "gorp": must be variable, vdelete, or vinfo}}
test trace-13.3 {trace command ("variable" option)} {
d822 10
a831 17
} {1 {wrong # args: should be "trace variable name ops command"}}
test trace-13.4 {trace command ("variable" option)} {
    list [catch {trace var x y z z2} msg] $msg
} {1 {wrong # args: should be "trace variable name ops command"}}
test trace-13.5 {trace command ("variable" option)} {
    list [catch {trace var x y z} msg] $msg
} {1 {bad operations "y": should be one or more of rwu}}
test trace-13.6 {trace command ("vdelete" option)} {
    list [catch {trace vdelete x y} msg] $msg
} {1 {wrong # args: should be "trace vdelete name ops command"}}
test trace-13.7 {trace command ("vdelete" option)} {
    list [catch {trace vdelete x y z foo} msg] $msg
} {1 {wrong # args: should be "trace vdelete name ops command"}}
test trace-13.8 {trace command ("vdelete" option)} {
    list [catch {trace vdelete x y z} msg] $msg
} {1 {bad operations "y": should be one or more of rwu}}
test trace-13.9 {trace command ("vdelete" option)} {
d834 2
a835 2
    trace var x w traceProc
    trace vdelete x w traceProc
d837 1
a837 1
test trace-13.10 {trace command ("vdelete" option)} {
d840 2
a841 2
    trace var x w traceProc
    trace vdelete x w traceProc
d845 1
a845 1
test trace-13.11 {trace command ("vdelete" option)} {
d848 3
a850 3
    trace var x w {traceTag 1}
    trace var x w traceProc
    trace var x w {traceTag 2}
d852 1
a852 1
    trace vdelete x w traceProc
d854 1
a854 1
    trace vdelete x w {traceTag 1}
d856 1
a856 1
    trace vdelete x w {traceTag 2}
d859 2
a860 2
} {2 x {} w 1 2 1 2}
test trace-13.12 {trace command ("vdelete" option)} {
d863 2
a864 2
    trace var x w {traceTag 1}
    trace vdelete x w non_existent
d868 8
a875 14
test trace-13.13 {trace command ("vinfo" option)} {
    list [catch {trace vinfo} msg] $msg]
} {1 {wrong # args: should be "trace vinfo name"]}}
test trace-13.14 {trace command ("vinfo" option)} {
    list [catch {trace vinfo x y} msg] $msg]
} {1 {wrong # args: should be "trace vinfo name"]}}
test trace-13.15 {trace command ("vinfo" option)} {
    catch {unset x}
    trace var x w {traceTag 1}
    trace var x w traceProc
    trace var x w {traceTag 2}
    trace vinfo x
} {{w {traceTag 2}} {w traceProc} {w {traceTag 1}}}
test trace-13.16 {trace command ("vinfo" option)} {
d877 1
a877 1
    trace vinfo x
d879 1
a879 1
test trace-13.17 {trace command ("vinfo" option)} {
d881 1
a881 1
    trace vinfo x(0)
d883 1
a883 1
test trace-13.18 {trace command ("vinfo" option)} {
d886 1
a886 1
    trace vinfo x(0)
d888 1
a888 1
test trace-13.19 {trace command ("vinfo" option)} {
d891 2
a892 2
    trace var x w {traceTag 1}
    proc check {} {global x; trace vinfo x}
d894 1
a894 1
} {{w {traceTag 1}}}
d898 1
a898 1
test trace-14.1 {long trace command} {
d901 1
a901 1
    trace var x w {traceTag {This is a very very long argument.  It's \
d913 1
a913 1
test trace-14.2 {long trace command result to ignore} {
d918 1
a918 1
    trace var x w longResult
d923 1
a923 1
test trace-14.3 {special list-handling in trace commands} {
d927 1
a927 1
    trace var "x y z(a\n\{)" w traceProc
d930 1
a930 1
} "{x y z} a\\n\\{ w"
d954 1
a954 1
test trace-15.1 {unsets during read traces} {
d958 2
a959 2
    trace var y r {traceUnset y}
    trace var y u {traceAppend unset}
d962 1
a962 1
test trace-15.2 {unsets during read traces} {
d966 1
a966 1
    trace var y(0) r {traceUnset y(0)}
d969 1
a969 1
test trace-15.3 {unsets during read traces} {
d973 1
a973 1
    trace var y(0) r {traceUnset y}
d976 1
a976 1
test trace-15.4 {unsets during read traces} {
d980 1
a980 1
    trace var y r {traceReset y y}
d983 1
a983 1
test trace-15.5 {unsets during read traces} {
d987 1
a987 1
    trace var y(0) r {traceReset y(0) y(0)}
d990 1
a990 1
test trace-15.6 {unsets during read traces} {
d994 1
a994 1
    trace var y(0) r {traceReset y y(0)}
d997 1
a997 1
test trace-15.7 {unsets during read traces} {
d1001 1
a1001 1
    trace var y(0) r {traceReset2 y y(0)}
d1004 1
a1004 1
test trace-15.8 {unsets during write traces} {
d1008 2
a1009 2
    trace var y w {traceUnset y}
    trace var y u {traceAppend unset}
d1012 1
a1012 1
test trace-15.9 {unsets during write traces} {
d1016 1
a1016 1
    trace var y(0) w {traceUnset y(0)}
d1019 1
a1019 1
test trace-15.10 {unsets during write traces} {
d1023 1
a1023 1
    trace var y(0) w {traceUnset y}
d1026 1
a1026 1
test trace-15.11 {unsets during write traces} {
d1030 1
a1030 1
    trace var y w {traceReset y y}
d1033 1
a1033 1
test trace-15.12 {unsets during write traces} {
d1037 1
a1037 1
    trace var y(0) w {traceReset y(0) y(0)}
d1040 1
a1040 1
test trace-15.13 {unsets during write traces} {
d1044 1
a1044 1
    trace var y(0) w {traceReset y y(0)}
d1047 1
a1047 1
test trace-15.14 {unsets during write traces} {
d1051 1
a1051 1
    trace var y(0) w {traceReset2 y y(0)}
d1054 1
a1054 1
test trace-15.15 {unsets during unset traces} {
d1058 1
a1058 1
    trace var y u {traceUnset y}
d1061 1
a1061 1
test trace-15.16 {unsets during unset traces} {
d1065 1
a1065 1
    trace var y(0) u {traceUnset y(0)}
d1068 1
a1068 1
test trace-15.17 {unsets during unset traces} {
d1072 1
a1072 1
    trace var y(0) u {traceUnset y}
d1075 1
a1075 1
test trace-15.18 {unsets during unset traces} {
d1079 1
a1079 1
    trace var y u {traceReset2 y y}
d1082 1
a1082 1
test trace-15.19 {unsets during unset traces} {
d1086 1
a1086 1
    trace var y(0) u {traceReset2 y(0) y(0)}
d1089 1
a1089 1
test trace-15.20 {unsets during unset traces} {
d1093 1
a1093 1
    trace var y(0) u {traceReset2 y y(0)}
d1096 1
a1096 1
test trace-15.21 {unsets cancelling traces} {
d1100 4
a1103 4
    trace var y r {traceAppend first}
    trace var y r {traceUnset y}
    trace var y r {traceAppend third}
    trace var y u {traceAppend unset}
d1106 1
a1106 1
test trace-15.22 {unsets cancelling traces} {
d1110 4
a1113 4
    trace var y(0) r {traceAppend first}
    trace var y(0) r {traceUnset y}
    trace var y(0) r {traceAppend third}
    trace var y(0) u {traceAppend unset}
d1119 1
a1119 1
test trace-16.1 {trace doesn't prevent unset errors} {
d1122 1
a1122 1
    trace var x u {traceProc}
d1124 2
a1125 2
} {1 {can't unset "x": no such variable} {x {} u}}
test trace-16.2 {traced variables must survive procedure exits} {
d1127 1
a1127 1
    proc p1 {} {global x; trace var x w traceProc}
d1129 3
a1131 3
    trace vinfo x
} {{w traceProc}}
test trace-16.3 {traced variables must survive procedure exits} {
d1134 1
a1134 1
    proc p1 {} {global x; trace var x w traceProc}
d1138 1
a1138 1
} {x {} w}
d1143 1
a1143 1
test trace-17.1 {unset traces on procedure returns} {
d1145 1
a1145 1
    proc p2 {z} {trace var z u {traceCheck {lsort [uplevel {info vars}]}}}
d1150 11
d1168 586
a1753 3
# cleanup
::tcltest::cleanupTests
return
d1755 5
d1761 9
d1771 3
d1775 8
d1784 3
d1788 7
d1796 3
d1800 40
d1841 7
d1849 27
d1877 2
d1880 3
@


1.3
log
@touched all sources to ease next import
@
text
@@


1.3.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d14 1
a14 1
# RCS: @@(#) $Id: trace.test,v 1.23 2002/10/15 16:13:47 vincentdarley Exp $
a54 15
proc traceCommand {oldName newName op} {
    global info
    set info [list $oldName $newName $op]
}

test trace-0.0 {memory corruption in trace (Tcl Bug 484339)} {
    # You may need Purify or Electric Fence to reliably
    # see this one fail.
    catch {unset z}
    trace add variable z array {set z(foo) 1 ;#}
    set res "names: [array names z]"
    catch {unset ::z}
    trace variable ::z w {unset ::z; error "memory corruption";#}
    list [catch {set ::z 1} msg] $msg
} {1 {can't set "::z": memory corruption}}
d61 1
a61 1
    trace add variable x read traceScalar
d63 1
a63 1
} {1 {can't read "x": no such variable} {x {} read 1 {can't read "x": no such variable}}}
d68 1
a68 1
    trace add variable x read traceScalar
d70 1
a70 1
} {0 123 {x {} read 0 123}}
d74 1
a74 1
    trace add variable x read traceScalar
d81 1
a81 1
    trace add variable x(2) read traceArray
d83 1
a83 1
} {1 {can't read "x(2)": no such element in array} {x 2 read 1 {can't read "x(2)": no such element in array}}}
d88 1
a88 1
    trace add variable x(2) read traceArray
d90 1
a90 1
} {0 zzz {x 2 read 0 zzz}}
d94 1
a94 1
    trace add variable x read traceArray2
d101 1
a101 1
} {0 willi {x 2 read}}
d105 1
a105 1
    trace add variable x read q
d118 1
a118 1
} {0 wolf {x Y read}}
d122 1
a122 1
    trace add variable x read traceArray
d129 1
a129 1
    trace add variable x read traceArray
d131 1
a131 1
} {0 zzz {x 2 read 0 zzz}}
d136 1
a136 1
    trace add variable x read traceScalar
a139 28
test trace-1.11 {read traces that modify the array structure} {
    catch {unset x}
    set x(bar) 0 
    trace variable x r {set x(foo) 1 ;#} 
    trace variable x r {unset -nocomplain x(bar) ;#} 
    array get x
} {}
test trace-1.12 {read traces that modify the array structure} {
    catch {unset x}
    set x(bar) 0 
    trace variable x r {unset -nocomplain x(bar) ;#} 
    trace variable x r {set x(foo) 1 ;#} 
    array get x
} {}
test trace-1.13 {read traces that modify the array structure} {
    catch {unset x}
    set x(bar) 0 
    trace variable x r {set x(foo) 1 ;#} 
    trace variable x r {unset -nocomplain x;#} 
    list [catch {array get x} res] $res
} {1 {can't read "x(bar)": no such variable}}
test trace-1.14 {read traces that modify the array structure} {
    catch {unset x}
    set x(bar) 0 
    trace variable x r {unset -nocomplain x;#} 
    trace variable x r {set x(foo) 1 ;#} 
    list [catch {array get x} res] $res
} {1 {can't read "x(bar)": no such variable}}
d146 1
a146 1
    trace add variable x write traceScalar
d149 1
a149 1
} {x {} write 0 123}
d153 1
a153 1
    trace add variable x(33) write traceArray
d156 1
a156 1
} {x 33 write 0 444}
d160 1
a160 1
    trace add variable x write traceArray
d163 1
a163 1
} {x abc write 0 qq}
d168 1
a168 1
    trace add variable x write traceScalar
d176 1
a176 1
    trace add variable x write traceScalar
d189 1
a189 1
    trace add variable x read traceScalarAppend
d194 1
a194 1
} {x {} read 0 123456}
d198 1
a198 1
    trace add variable x {read write} traceScalarAppend
d202 1
a202 1
} {x {} write 0 123 x {} read 0 123 x {} write 0 {123 456}}
d209 1
a209 1
    trace add variable x unset traceScalar
d212 1
a212 1
} {x {} unset 1 {can't read "x": no such variable}}
d217 1
a217 1
    trace add variable x unset traceScalar
d220 1
a220 1
} {x {} unset 1 {can't read "x": no such variable}}
d224 1
a224 1
    trace add variable x unset traceScalar
d233 1
a233 1
    trace add variable x(1) unset traceArray
d236 1
a236 1
} {x 1 unset 1 {can't read "x(1)": no such element in array}}
d241 1
a241 1
    trace add variable x(1) unset traceArray
d244 1
a244 1
} {x 1 unset 1 {can't read "x(1)": no such element in array}}
d249 1
a249 1
    trace add variable x(1) unset traceArray
d252 1
a252 1
} {x 1 unset 1 {can't read "x(1)": no such variable}}
d257 1
a257 1
    trace add variable x unset traceProc
d267 1
a267 1
    trace add variable x unset traceProc
d270 1
a270 1
} {x 1 unset}
d277 1
a277 1
    trace add variable x unset traceProc
d280 1
a280 1
} {x {} unset}
a281 60
# Array tracing on variables
test trace-5.1 {array traces fire on accesses via [array]} {
    catch {unset x}
    set x(b) 2
    trace add variable x array traceArray2
    set ::info {}
    array set x {a 1}
    set ::info
} {x {} array}
test trace-5.2 {array traces do not fire on normal accesses} {
    catch {unset x}
    set x(b) 2
    trace add variable x array traceArray2
    set ::info {}
    set x(a) 1
    set x(b) $x(a)
    set ::info
} {}
test trace-5.3 {array traces do not outlive variable} {
    catch {unset x}
    trace add variable x array traceArray2
    set ::info {}
    set x(a) 1
    unset x
    array set x {a 1}
    set ::info
} {}
test trace-5.4 {array traces properly listed in trace information} {
    catch {unset x}
    trace add variable x array traceArray2
    set result [trace info variable x]
    set result
} [list [list array traceArray2]]
test trace-5.5 {array traces properly listed in trace information} {
    catch {unset x}
    trace variable x a traceArray2
    set result [trace vinfo x]
    set result
} [list [list a traceArray2]]
test trace-5.6 {array traces don't fire on scalar variables} {
    catch {unset x}
    set x foo
    trace add variable x array traceArray2
    set ::info {}
    catch {array set x {a 1}}
    set ::info
} {}
test trace-5.7 {array traces fire for undefined variables} {
    catch {unset x}
    trace add variable x array traceArray2
    set ::info {}
    array set x {a 1}
    set ::info
} {x {} array}
test trace-5.8 {array traces fire for undefined variables} {
    catch {unset x}
    trace add variable x array {set x(foo) 1 ;#}
    set res "names: [array names x]"
} {names: foo}
    
d284 1
a284 1
test trace-6.1 {multiple ops traced at once} {
d287 1
a287 1
    trace add variable x {read write unset} traceProc
d294 2
a295 2
} {x {} read x {} write x {} read x {} write x {} unset}
test trace-6.2 {multiple ops traced on array element} {
d298 1
a298 1
    trace add variable x(0) {read write unset} traceProc
d306 2
a307 2
} {x 0 read x 0 write x 0 read x 0 write x 0 unset}
test trace-6.3 {multiple ops traced on whole array} {
d310 1
a310 1
    trace add variable x {read write unset} traceProc
d318 1
a318 1
} {x 0 write x 0 read x 0 write x 0 unset x {} unset}
d322 1
a322 1
test trace-7.1 {order of invocation of traces} {
d325 3
a327 3
    trace add variable x read "traceTag 1"
    trace add variable x read "traceTag 2"
    trace add variable x read "traceTag 3"
d333 1
a333 1
test trace-7.2 {order of invocation of traces} {
d337 3
a339 3
    trace add variable x(0) read "traceTag 1"
    trace add variable x(0) read "traceTag 2"
    trace add variable x(0) read "traceTag 3"
d343 1
a343 1
test trace-7.3 {order of invocation of traces} {
d347 6
a352 6
    trace add variable x(0) read "traceTag 1"
    trace add variable x read "traceTag A1"
    trace add variable x(0) read "traceTag 2"
    trace add variable x read "traceTag A2"
    trace add variable x(0) read "traceTag 3"
    trace add variable x read "traceTag A3"
d359 1
a359 1
test trace-8.1 {error returns from traces} {
d363 2
a364 2
    trace add variable x read "traceTag 1"
    trace add variable x read traceError
d367 1
a367 1
test trace-8.2 {error returns from traces} {
d371 2
a372 2
    trace add variable x write "traceTag 1"
    trace add variable x write traceError
d375 1
a375 1
test trace-8.3 {error returns from traces} {
d379 1
a379 1
    trace add variable x write traceError
d382 1
a382 1
test trace-8.4 {error returns from traces} {
d386 2
a387 2
    trace add variable x unset "traceTag 1"
    trace add variable x unset traceError
d390 1
a390 1
test trace-8.5 {error returns from traces} {
d394 4
a397 4
    trace add variable x(0) read "traceTag 1"
    trace add variable x read "traceTag 2"
    trace add variable x read traceError
    trace add variable x read "traceTag 3"
d400 1
a400 1
test trace-8.6 {error returns from traces} {
d403 1
a403 1
    trace add variable x unset traceError
d406 1
a406 1
test trace-8.7 {error returns from traces} {
d412 1
a412 1
    trace add variable x read traceError
d415 1
a415 23
    trace remove variable x read traceError
} {}
test trace-8.8 {error returns from traces} {
    # Yet more elaborate memory corruption testing that checks nothing
    # bad happens when the trace deletes itself and installs something
    # new.  Alas, there is no neat way to guarantee that this test will
    # fail if there is a problem, but that's life and with the new code
    # it should *never* fail.
    #
    # Adapted from Bug #219393 reported by Don Porter.
    catch {rename ::foo {}}
    proc foo {old args} {
	trace remove variable ::x write [list foo $old]
	trace add    variable ::x write [list foo $::x]
	error "foo"
    }
    catch {unset ::x ::y}
    set x junk
    trace add variable ::x write [list foo $x]
    for {set y 0} {$y<100} {incr y} {
	catch {set x junk}
    }
    unset x
d422 1
a422 1
test trace-9.1 {be sure variable is unset before trace is called} {
d426 1
a426 1
    trace add variable x unset {traceCheck {uplevel set x}}
d430 1
a430 1
test trace-9.2 {be sure variable is unset before trace is called} {
d434 1
a434 1
    trace add variable x unset {traceCheck {uplevel set x 22}}
d438 1
a438 1
test trace-9.3 {be sure traces are cleared before unset trace called} {
d442 1
a442 1
    trace add variable x unset {traceCheck {uplevel trace info variable x}}
d446 1
a446 1
test trace-9.4 {set new trace during unset trace} {
d450 1
a450 1
    trace add variable x unset {traceCheck {global x; trace add variable x unset traceProc}}
d452 2
a453 2
    concat $info [trace info variable x]
} {0 {} {unset traceProc}}
d455 1
a455 1
test trace-10.1 {make sure array elements are unset before traces are called} {
d459 1
a459 1
    trace add variable x(0) unset {traceCheck {uplevel set x(0)}}
d463 1
a463 1
test trace-10.2 {make sure array elements are unset before traces are called} {
d467 1
a467 1
    trace add variable x(0) unset {traceCheck {uplevel set x(0) zzz}}
d471 1
a471 1
test trace-10.3 {array elements are unset before traces are called} {
d475 1
a475 1
    trace add variable x(0) unset {traceCheck {global x; trace info variable x(0)}}
d479 1
a479 1
test trace-10.4 {set new array element trace during unset trace} {
d483 1
a483 1
    trace add variable x(0) unset {traceCheck {uplevel {trace add variable x(0) read {}}}}
d485 2
a486 2
    concat $info [trace info variable x(0)]
} {0 {} {read {}}}
d488 1
a488 1
test trace-11.1 {make sure arrays are unset before traces are called} {
d492 1
a492 1
    trace add variable x unset {traceCheck {uplevel set x(0)}}
d496 1
a496 1
test trace-11.2 {make sure arrays are unset before traces are called} {
d500 1
a500 1
    trace add variable x unset {traceCheck {uplevel set x(y) 22}}
d504 1
a504 1
test trace-11.3 {make sure arrays are unset before traces are called} {
d508 1
a508 1
    trace add variable x unset {traceCheck {uplevel array exists x}}
d512 1
a512 1
test trace-11.4 {make sure arrays are unset before traces are called} {
d516 2
a517 2
    set cmd {traceCheck {uplevel {trace info variable x}}}
    trace add variable x unset $cmd
d521 1
a521 1
test trace-11.5 {set new array trace during unset trace} {
d525 1
a525 1
    trace add variable x unset {traceCheck {global x; trace add variable x read {}}}
d527 3
a529 3
    concat $info [trace info variable x]
} {0 {} {read {}}}
test trace-11.6 {create scalar during array unset trace} {
d533 1
a533 1
    trace add variable x unset {traceCheck {global x; set x 44}}
d540 1
a540 1
test trace-12.1 {creating array when setting variable traces} {
d543 1
a543 1
    trace add variable x(0) write traceProc
d546 1
a546 1
test trace-12.2 {creating array when setting variable traces} {
d549 1
a549 1
    trace add variable x(0) write traceProc
d552 1
a552 1
test trace-12.3 {creating array when setting variable traces} {
d555 1
a555 1
    trace add variable x(0) write traceProc
d558 2
a559 2
} {x 0 write}
test trace-12.4 {creating variable when setting variable traces} {
d562 1
a562 1
    trace add variable x write traceProc
d565 1
a565 1
test trace-12.5 {creating variable when setting variable traces} {
d568 1
a568 1
    trace add variable x write traceProc
d571 2
a572 2
} {x {} write}
test trace-12.6 {creating variable when setting variable traces} {
d575 1
a575 1
    trace add variable x write traceProc
d578 2
a579 2
} {x 0 write}
test trace-12.7 {create array element during read trace} {
d582 1
a582 1
    trace add variable x read {traceCrtElement xyzzy}
d585 1
a585 1
test trace-12.8 {errors when setting variable traces} {
d588 1
a588 1
    list [catch {trace add variable x(0) write traceProc} msg] $msg
d593 1
a593 1
test trace-13.1 {delete one trace from another} {
d596 3
a598 3
	trace remove variable x read {traceTag 2}
	trace remove variable x read {traceTag 3}
	trace remove variable x read {traceTag 4}
d603 6
a608 6
    trace add variable x read {traceTag 1}
    trace add variable x read {traceTag 2}
    trace add variable x read {traceTag 3}
    trace add variable x read {traceTag 4}
    trace add variable x read delTraces 
    trace add variable x read {traceTag 5}
d615 1
a615 33
# Syntax for adding/removing variable and command traces is basically the
# same:
#	trace add variable name opList command
#	trace remove variable name opList command
#
# The following loops just get all the common "wrong # args" tests done.

set i 0
set start "wrong # args:"
foreach type {variable command} {
    foreach op {add remove} {
	test trace-14.0.[incr i] "trace command, wrong # args errors" {
	    list [catch {trace $op $type} msg] $msg
	} [list 1 "$start should be \"trace $op $type name opList command\""]
	test trace-14.0.[incr i] "trace command wrong # args errors" {
	    list [catch {trace $op $type foo} msg] $msg
	} [list 1 "$start should be \"trace $op $type name opList command\""]
	test trace-14.0.[incr i] "trace command, wrong # args errors" {
	    list [catch {trace $op $type foo bar} msg] $msg
	} [list 1 "$start should be \"trace $op $type name opList command\""]
	test trace-14.0.[incr i] "trace command, wrong # args errors" {
	    list [catch {trace $op $type foo bar baz boo} msg] $msg
	} [list 1 "$start should be \"trace $op $type name opList command\""]
    }
    test trace-14.0.[incr i] "trace command, wrong # args errors" {
	list [catch {trace info $type foo bar} msg] $msg
    } [list 1 "$start should be \"trace info $type name\""]
    test trace-14.0.[incr i] "trace command, wrong # args errors" {
	list [catch {trace info $type} msg] $msg
    } [list 1 "$start should be \"trace info $type name\""]
}

test trace-14.1 "trace command, wrong # args errors" {
d617 2
a618 12
} [list 1 "wrong # args: should be \"trace option ?arg arg ...?\""]
test trace-14.2 "trace command, wrong # args errors" {
    list [catch {trace add} msg] $msg
} [list 1 "wrong # args: should be \"trace add type ?arg arg ...?\""]
test trace-14.3 "trace command, wrong # args errors" {
    list [catch {trace remove} msg] $msg
} [list 1 "wrong # args: should be \"trace remove type ?arg arg ...?\""]
test trace-14.4 "trace command, wrong # args errors" {
    list [catch {trace info} msg] $msg
} [list 1 "wrong # args: should be \"trace info type ?arg arg ...?\""]

test trace-14.5 {trace command, invalid option} {
d620 2
a621 34
} [list 1 "bad option \"gorp\": must be add, info, remove, variable, vdelete, or vinfo"]

# Again, [trace ... command] and [trace ... variable] share syntax and
# error message styles for their opList options; these loops test those 
# error messages.

set i 0
set errs [list "array, read, unset, or write" "delete or rename" "enter, leave, enterstep, or leavestep"]
set abbvs [list {a r u w} {d r} {}]
proc x {} {}
foreach type {variable command execution} err $errs abbvlist $abbvs {
    foreach op {add remove} {
	test trace-14.6.[incr i] "trace $op $type errors" {
	    list [catch {trace $op $type x {y z w} a} msg] $msg
	} [list 1 "bad operation \"y\": must be $err"]
	foreach abbv $abbvlist {
	    test trace-14.6.[incr i] "trace $op $type rejects abbreviations" {
		list [catch {trace $op $type x $abbv a} msg] $msg
	    } [list 1 "bad operation \"$abbv\": must be $err"]
	}
	test trace-14.6.[incr i] "trace $op $type rejects null opList" {
	    list [catch {trace $op $type x {} a} msg] $msg
	} [list 1 "bad operation list \"\": must be one or more of $err"]
    }
}
rename x {}

test trace-14.7 {trace command, "trace variable" errors} {
    list [catch {trace variable} msg] $msg
} [list 1 "wrong # args: should be \"trace variable name ops command\""]
test trace-14.8 {trace command, "trace variable" errors} {
    list [catch {trace variable x} msg] $msg
} [list 1 "wrong # args: should be \"trace variable name ops command\""]
test trace-14.9 {trace command, "trace variable" errors} {
d623 17
a639 10
} [list 1 "wrong # args: should be \"trace variable name ops command\""]
test trace-14.10 {trace command, "trace variable" errors} {
    list [catch {trace variable x y z w} msg] $msg
} [list 1 "wrong # args: should be \"trace variable name ops command\""]
test trace-14.11 {trace command, "trace variable" errors} {
    list [catch {trace variable x y z} msg] $msg
} [list 1 "bad operations \"y\": should be one or more of rwua"]


test trace-14.9 {trace command ("remove variable" option)} {
d642 2
a643 2
    trace add variable x write traceProc
    trace remove variable x write traceProc
d645 1
a645 1
test trace-14.10 {trace command ("remove variable" option)} {
d648 2
a649 2
    trace add variable x write traceProc
    trace remove variable x write traceProc
d653 1
a653 1
test trace-14.11 {trace command ("remove variable" option)} {
d656 3
a658 3
    trace add variable x write {traceTag 1}
    trace add variable x write traceProc
    trace add variable x write {traceTag 2}
d660 1
a660 1
    trace remove variable x write traceProc
d662 1
a662 1
    trace remove variable x write {traceTag 1}
d664 1
a664 1
    trace remove variable x write {traceTag 2}
d667 2
a668 2
} {2 x {} write 1 2 1 2}
test trace-14.12 {trace command ("remove variable" option)} {
d671 2
a672 2
    trace add variable x write {traceTag 1}
    trace remove variable x write non_existent
d676 14
a689 8
test trace-14.15 {trace command ("list variable" option)} {
    catch {unset x}
    trace add variable x write {traceTag 1}
    trace add variable x write traceProc
    trace add variable x write {traceTag 2}
    trace info variable x
} {{write {traceTag 2}} {write traceProc} {write {traceTag 1}}}
test trace-14.16 {trace command ("list variable" option)} {
d691 1
a691 1
    trace info variable x
d693 1
a693 1
test trace-14.17 {trace command ("list variable" option)} {
d695 1
a695 1
    trace info variable x(0)
d697 1
a697 1
test trace-14.18 {trace command ("list variable" option)} {
d700 1
a700 1
    trace info variable x(0)
d702 1
a702 1
test trace-14.19 {trace command ("list variable" option)} {
d705 2
a706 2
    trace add variable x write {traceTag 1}
    proc check {} {global x; trace info variable x}
d708 1
a708 1
} {{write {traceTag 1}}}
d712 1
a712 1
test trace-15.1 {long trace command} {
d715 1
a715 1
    trace add variable x write {traceTag {This is a very very long argument.  It's \
d727 1
a727 1
test trace-15.2 {long trace command result to ignore} {
d732 1
a732 1
    trace add variable x write longResult
d737 1
a737 1
test trace-15.3 {special list-handling in trace commands} {
d741 1
a741 1
    trace add variable "x y z(a\n\{)" write traceProc
d744 1
a744 1
} "{x y z} a\\n\\\{ write"
d768 1
a768 1
test trace-16.1 {unsets during read traces} {
d772 2
a773 2
    trace add variable y read {traceUnset y}
    trace add variable y unset {traceAppend unset}
d776 1
a776 1
test trace-16.2 {unsets during read traces} {
d780 1
a780 1
    trace add variable y(0) read {traceUnset y(0)}
d783 1
a783 1
test trace-16.3 {unsets during read traces} {
d787 1
a787 1
    trace add variable y(0) read {traceUnset y}
d790 1
a790 1
test trace-16.4 {unsets during read traces} {
d794 1
a794 1
    trace add variable y read {traceReset y y}
d797 1
a797 1
test trace-16.5 {unsets during read traces} {
d801 1
a801 1
    trace add variable y(0) read {traceReset y(0) y(0)}
d804 1
a804 1
test trace-16.6 {unsets during read traces} {
d808 1
a808 1
    trace add variable y(0) read {traceReset y y(0)}
d811 1
a811 1
test trace-16.7 {unsets during read traces} {
d815 1
a815 1
    trace add variable y(0) read {traceReset2 y y(0)}
d818 1
a818 1
test trace-16.8 {unsets during write traces} {
d822 2
a823 2
    trace add variable y write {traceUnset y}
    trace add variable y unset {traceAppend unset}
d826 1
a826 1
test trace-16.9 {unsets during write traces} {
d830 1
a830 1
    trace add variable y(0) write {traceUnset y(0)}
d833 1
a833 1
test trace-16.10 {unsets during write traces} {
d837 1
a837 1
    trace add variable y(0) write {traceUnset y}
d840 1
a840 1
test trace-16.11 {unsets during write traces} {
d844 1
a844 1
    trace add variable y write {traceReset y y}
d847 1
a847 1
test trace-16.12 {unsets during write traces} {
d851 1
a851 1
    trace add variable y(0) write {traceReset y(0) y(0)}
d854 1
a854 1
test trace-16.13 {unsets during write traces} {
d858 1
a858 1
    trace add variable y(0) write {traceReset y y(0)}
d861 1
a861 1
test trace-16.14 {unsets during write traces} {
d865 1
a865 1
    trace add variable y(0) write {traceReset2 y y(0)}
d868 1
a868 1
test trace-16.15 {unsets during unset traces} {
d872 1
a872 1
    trace add variable y unset {traceUnset y}
d875 1
a875 1
test trace-16.16 {unsets during unset traces} {
d879 1
a879 1
    trace add variable y(0) unset {traceUnset y(0)}
d882 1
a882 1
test trace-16.17 {unsets during unset traces} {
d886 1
a886 1
    trace add variable y(0) unset {traceUnset y}
d889 1
a889 1
test trace-16.18 {unsets during unset traces} {
d893 1
a893 1
    trace add variable y unset {traceReset2 y y}
d896 1
a896 1
test trace-16.19 {unsets during unset traces} {
d900 1
a900 1
    trace add variable y(0) unset {traceReset2 y(0) y(0)}
d903 1
a903 1
test trace-16.20 {unsets during unset traces} {
d907 1
a907 1
    trace add variable y(0) unset {traceReset2 y y(0)}
d910 1
a910 1
test trace-16.21 {unsets cancelling traces} {
d914 4
a917 4
    trace add variable y read {traceAppend first}
    trace add variable y read {traceUnset y}
    trace add variable y read {traceAppend third}
    trace add variable y unset {traceAppend unset}
d920 1
a920 1
test trace-16.22 {unsets cancelling traces} {
d924 4
a927 4
    trace add variable y(0) read {traceAppend first}
    trace add variable y(0) read {traceUnset y}
    trace add variable y(0) read {traceAppend third}
    trace add variable y(0) unset {traceAppend unset}
d933 1
a933 1
test trace-17.1 {trace doesn't prevent unset errors} {
d936 1
a936 1
    trace add variable x unset {traceProc}
d938 2
a939 2
} {1 {can't unset "x": no such variable} {x {} unset}}
test trace-17.2 {traced variables must survive procedure exits} {
d941 1
a941 1
    proc p1 {} {global x; trace add variable x write traceProc}
d943 3
a945 3
    trace info variable x
} {{write traceProc}}
test trace-17.3 {traced variables must survive procedure exits} {
d948 1
a948 1
    proc p1 {} {global x; trace add variable x write traceProc}
d952 1
a952 1
} {x {} write}
d957 1
a957 1
test trace-18.1 {unset traces on procedure returns} {
d959 1
a959 1
    proc p2 {z} {trace add variable z unset {traceCheck {lsort [uplevel {info vars}]}}}
a963 11
test trace-18.2 {namespace delete / trace vdelete combo} {
    namespace eval ::foo {
	variable x 123
    }
    proc p1 args {
	trace vdelete ::foo::x u p1
    }
    trace variable ::foo::x u p1
    namespace delete ::foo
    info exists ::foo::x
} 0
d971 3
a973 448
test trace-18.2 {trace add command (command existence)} {
    # Just in case!
    catch {rename nosuchname ""}
    list [catch {trace add command nosuchname rename traceCommand} msg] $msg
} {1 {unknown command "nosuchname"}}
test trace-18.3 {trace add command (command existence in ns)} {
    list [catch {trace add command nosuchns::nosuchname rename traceCommand} msg] $msg
} {1 {unknown command "nosuchns::nosuchname"}}


test trace-19.1 {trace add command (rename option)} {
    proc foo {} {}
    catch {rename bar {}}
    trace add command foo rename traceCommand
    rename foo bar
    set info
} {foo bar rename}
test trace-19.2 {traces stick with renamed commands} {
    proc foo {} {}
    catch {rename bar {}}
    trace add command foo rename traceCommand
    rename foo bar
    rename bar foo
    set info
} {bar foo rename}
test trace-19.2.1 {trace add command rename trace exists} {
    proc foo {} {}
    trace add command foo rename traceCommand
    trace info command foo
} {{rename traceCommand}}
test trace-19.3 {command rename traces don't fire on command deletion} {
    proc foo {} {}
    set info {}
    trace add command foo rename traceCommand
    rename foo {}
    set info
} {}
test trace-19.4 {trace add command rename doesn't trace recreated commands} {
    proc foo {} {}
    catch {rename bar {}}
    trace add command foo rename traceCommand
    proc foo {} {}
    rename foo bar
    set info
} {}
test trace-19.5 {trace add command deleted removes traces} {
    proc foo {} {}
    trace add command foo rename traceCommand
    proc foo {} {}
    trace info command foo
} {}

namespace eval tc {}
proc tc::tcfoo {} {}
test trace-19.6 {trace add command rename in namespace} {
    trace add command tc::tcfoo rename traceCommand
    rename tc::tcfoo tc::tcbar
    set info
} {tc::tcfoo tc::tcbar rename}
test trace-19.7 {trace add command rename in namespace back again} {
    rename tc::tcbar tc::tcfoo
    set info
} {tc::tcbar tc::tcfoo rename}
test trace-19.8 {trace add command rename in namespace to out of namespace} {
    rename tc::tcfoo tcbar
    set info
} {tc::tcfoo tcbar rename}
test trace-19.9 {trace add command rename back into namespace} {
    rename tcbar tc::tcfoo
    set info
} {tcbar tc::tcfoo rename}
test trace-19.10 {trace add command failed rename doesn't trigger trace} {
    set info {}
    proc foo {} {}
    proc bar {} {}
    trace add command foo {rename delete} traceCommand
    catch {rename foo bar}
    set info
} {}
catch {rename foo {}}
catch {rename bar {}}

# Make sure it exists again
proc foo {} {}

test trace-20.1 {trace add command (delete option)} {
    trace add command foo delete traceCommand
    rename foo ""
    set info
} {::foo {} delete}
test trace-20.2 {trace add command delete doesn't trace recreated commands} {
    set info {}
    proc foo {} {}
    rename foo ""
    set info
} {}
test trace-20.2.1 {trace add command delete trace info} {
    proc foo {} {}
    trace add command foo delete traceCommand
    trace info command foo
} {{delete traceCommand}}
test trace-20.3 {trace add command implicit delete} {
    proc foo {} {}
    trace add command foo delete traceCommand
    proc foo {} {}
    set info
} {::foo {} delete}
test trace-20.3.1 {trace add command delete trace info} {
    proc foo {} {}
    trace info command foo
} {}
test trace-20.4 {trace add command rename followed by delete} {
    set infotemp {}
    proc foo {} {}
    trace add command foo {rename delete} traceCommand
    rename foo bar
    lappend infotemp $info
    rename bar {}
    lappend infotemp $info
    set info $infotemp
    unset infotemp
    set info
} {{foo bar rename} {::bar {} delete}}
catch {rename foo {}}
catch {rename bar {}}

test trace-20.5 {trace add command rename and delete} {
    set infotemp {}
    set info {}
    proc foo {} {}
    trace add command foo {rename delete} traceCommand
    rename foo bar
    lappend infotemp $info
    rename bar {}
    lappend infotemp $info
    set info $infotemp
    unset infotemp
    set info
} {{foo bar rename} {::bar {} delete}}

test trace-20.6 {trace add command rename and delete in subinterp} {
    set tc [interp create]
    foreach p {traceCommand} {
	$tc eval [list proc $p [info args $p] [info body $p]]
    }
    $tc eval [list set infotemp {}]
    $tc eval [list set info {}]
    $tc eval [list proc foo {} {}]
    $tc eval [list trace add command foo {rename delete} traceCommand]
    $tc eval [list rename foo bar]
    $tc eval {lappend infotemp $info}
    $tc eval [list rename bar {}]
    $tc eval {lappend infotemp $info}
    $tc eval {set info $infotemp}
    $tc eval [list unset infotemp]
    set info [$tc eval [list set info]]
    interp delete $tc
    set info
} {{foo bar rename} {::bar {} delete}}

# I'd like it if this test could give 'foo {} d' as a result,
# but interp deletion means there is no interp to evaluate
# the trace in.
test trace-20.7 {trace add command delete in subinterp while being deleted} {
    set info {}
    set tc [interp create]
    interp alias $tc traceCommand {} traceCommand
    $tc eval [list proc foo {} {}]
    $tc eval [list trace add command foo {rename delete} traceCommand]
    interp delete $tc
    set info
} {}

proc traceDelete {cmd old new op} {
    eval trace remove command $cmd [lindex [trace info command $cmd] 0]
    global info
    set info [list $old $new $op]
}
proc traceCmdrename {cmd old new op} {
    rename $old someothername
}
proc traceCmddelete {cmd old new op} {
    rename $old ""
}
test trace-20.8 {trace delete while trace is active} {
    set info {}
    proc foo {} {}
    catch {rename bar {}}
    trace add command foo {rename delete} [list traceDelete foo]
    rename foo bar
    list [set info] [trace info command bar]
} {{foo bar rename} {}}

test trace-20.9 {rename trace deletes command} {
    set info {}
    proc foo {} {}
    catch {rename bar {}}
    catch {rename someothername {}}
    trace add command foo rename [list traceCmddelete foo]
    rename foo bar
    list [info commands foo] [info commands bar] [info commands someothername]
} {{} {} {}}

test trace-20.10 {rename trace renames command} {
    set info {}
    proc foo {} {}
    catch {rename bar {}}
    catch {rename someothername {}}
    trace add command foo rename [list traceCmdrename foo]
    rename foo bar
    set info [list [info commands foo] [info commands bar] [info commands someothername]]
    rename someothername {}
    set info
} {{} {} someothername}

test trace-20.11 {delete trace deletes command} {
    set info {}
    proc foo {} {}
    catch {rename bar {}}
    catch {rename someothername {}}
    trace add command foo delete [list traceCmddelete foo]
    rename foo {}
    list [info commands foo] [info commands bar] [info commands someothername]
} {{} {} {}}

test trace-20.12 {delete trace renames command} {
    set info {}
    proc foo {} {}
    catch {rename bar {}}
    catch {rename someothername {}}
    trace add command foo delete [list traceCmdrename foo]
    rename foo bar
    rename bar {}
    # None of these should exist.
    list [info commands foo] [info commands bar] [info commands someothername]
} {{} {} {}}

proc foo {b} { set a $b }


# Delete arrays when done, so they can be re-used as scalars
# elsewhere.

catch {unset x}
catch {unset y}

# Delete procedures when done, so we don't clash with other tests
# (e.g. foobar will clash with 'unknown' tests).
catch {rename foobar {}}
catch {rename foo {}}
catch {rename bar {}}

proc foo {a} {
    set b $a
}

proc traceExecute {args} {
    global info
    lappend info $args
}

test trace-21.1 {trace execution: enter} {
    set info {}
    trace add execution foo enter [list traceExecute foo]
    foo 1
    trace remove execution foo enter [list traceExecute foo]
    set info
} {{foo {foo 1} enter}}

test trace-21.2 {trace exeuction: leave} {
    set info {}
    trace add execution foo leave [list traceExecute foo]
    foo 2
    trace remove execution foo leave [list traceExecute foo]
    set info
} {{foo {foo 2} 0 2 leave}}

test trace-21.3 {trace exeuction: enter, leave} {
    set info {}
    trace add execution foo {enter leave} [list traceExecute foo]
    foo 3
    trace remove execution foo {enter leave} [list traceExecute foo]
    set info
} {{foo {foo 3} enter} {foo {foo 3} 0 3 leave}}

test trace-21.4 {trace execution: enter, leave, enterstep} {
    set info {}
    trace add execution foo {enter leave enterstep} [list traceExecute foo]
    foo 3
    trace remove execution foo {enter leave enterstep} [list traceExecute foo]
    set info
} {{foo {foo 3} enter} {foo {set b 3} enterstep} {foo {foo 3} 0 3 leave}}

test trace-21.5 {trace execution: enter, leave, enterstep, leavestep} {
    set info {}
    trace add execution foo {enter leave enterstep leavestep} [list traceExecute foo]
    foo 3
    trace remove execution foo {enter leave enterstep leavestep} [list traceExecute foo]
    set info
} {{foo {foo 3} enter} {foo {set b 3} enterstep} {foo {set b 3} 0 3 leavestep} {foo {foo 3} 0 3 leave}}

test trace-21.6 {trace execution: enterstep, leavestep} {
    set info {}
    trace add execution foo {enterstep leavestep} [list traceExecute foo]
    foo 3
    trace remove execution foo {enterstep leavestep} [list traceExecute foo]
    set info
} {{foo {set b 3} enterstep} {foo {set b 3} 0 3 leavestep}}

test trace-21.7 {trace execution: enterstep} {
    set info {}
    trace add execution foo {enterstep} [list traceExecute foo]
    foo 3
    trace remove execution foo {enterstep} [list traceExecute foo]
    set info
} {{foo {set b 3} enterstep}}

test trace-21.8 {trace execution: leavestep} {
    set info {}
    trace add execution foo {leavestep} [list traceExecute foo]
    foo 3
    trace remove execution foo {leavestep} [list traceExecute foo]
    set info
} {{foo {set b 3} 0 3 leavestep}}

proc factorial {n} {
    if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }
    return 1
}

test trace-22.1 {recursive(1) trace execution: enter} {
    set info {}
    trace add execution factorial {enter} [list traceExecute factorial]
    factorial 1
    trace remove execution factorial {enter} [list traceExecute factorial]
    set info
} {{factorial {factorial 1} enter}}

test trace-22.2 {recursive(2) trace execution: enter} {
    set info {}
    trace add execution factorial {enter} [list traceExecute factorial]
    factorial 2
    trace remove execution factorial {enter} [list traceExecute factorial]
    set info
} {{factorial {factorial 2} enter} {factorial {factorial 1} enter}}

test trace-22.3 {recursive(3) trace execution: enter} {
    set info {}
    trace add execution factorial {enter} [list traceExecute factorial]
    factorial 3
    trace remove execution factorial {enter} [list traceExecute factorial]
    set info
} {{factorial {factorial 3} enter} {factorial {factorial 2} enter} {factorial {factorial 1} enter}}

test trace-23.1 {recursive(1) trace execution: enter, leave, enterstep, leavestep} {
    set info {}
    trace add execution factorial {enter leave enterstep leavestep} [list traceExecute]
    factorial 1
    trace remove execution factorial {enter leave enterstep leavestep} [list traceExecute]
    join $info "\n"
} {{factorial 1} enter
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} enterstep
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} 0 {} leavestep
{return 1} enterstep
{return 1} 2 1 leavestep
{factorial 1} 0 1 leave}

test trace-23.2 {recursive(2) trace execution: enter, leave, enterstep, leavestep} {
    set info {}
    trace add execution factorial {enter leave enterstep leavestep} [list traceExecute]
    factorial 2
    trace remove execution factorial {enter leave enterstep leavestep} [list traceExecute]
    join $info "\n"
} {{factorial 2} enter
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} enterstep
{expr {$n * [factorial [expr {$n -1 }]]}} enterstep
{expr {$n -1 }} enterstep
{expr {$n -1 }} 0 1 leavestep
{factorial 1} enterstep
{factorial 1} enter
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} enterstep
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} 0 {} leavestep
{return 1} enterstep
{return 1} 2 1 leavestep
{factorial 1} 0 1 leave
{factorial 1} 0 1 leavestep
{expr {$n * [factorial [expr {$n -1 }]]}} 0 2 leavestep
{return 2} enterstep
{return 2} 2 2 leavestep
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} 2 2 leavestep
{factorial 2} 0 2 leave}

test trace-23.3 {recursive(3) trace execution: enter, leave, enterstep, leavestep} {
    set info {}
    trace add execution factorial {enter leave enterstep leavestep} [list traceExecute]
    factorial 3
    trace remove execution factorial {enter leave enterstep leavestep} [list traceExecute]
    join $info "\n"
} {{factorial 3} enter
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} enterstep
{expr {$n * [factorial [expr {$n -1 }]]}} enterstep
{expr {$n -1 }} enterstep
{expr {$n -1 }} 0 2 leavestep
{factorial 2} enterstep
{factorial 2} enter
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} enterstep
{expr {$n * [factorial [expr {$n -1 }]]}} enterstep
{expr {$n -1 }} enterstep
{expr {$n -1 }} 0 1 leavestep
{factorial 1} enterstep
{factorial 1} enter
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} enterstep
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} 0 {} leavestep
{return 1} enterstep
{return 1} 2 1 leavestep
{factorial 1} 0 1 leave
{factorial 1} 0 1 leavestep
{expr {$n * [factorial [expr {$n -1 }]]}} 0 2 leavestep
{return 2} enterstep
{return 2} 2 2 leavestep
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} 2 2 leavestep
{factorial 2} 0 2 leave
{factorial 2} 0 2 leavestep
{expr {$n * [factorial [expr {$n -1 }]]}} 0 6 leavestep
{return 6} enterstep
{return 6} 2 6 leavestep
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} 2 6 leavestep
{factorial 3} 0 6 leave}

proc traceDelete {cmd args} {
    eval trace remove execution $cmd [lindex [trace info execution $cmd] 0]
    global info
    set info $args
}

test trace-24.1 {delete trace during enter trace} {
    set info {}
    trace add execution foo enter [list traceDelete foo]
    foo 1
    list $info [trace info execution foo]
} {{{foo 1} enter} {}}

test trace-24.2 {delete trace during leave trace} {
    set info {}
    trace add execution foo leave [list traceDelete foo]
    foo 1
    list $info [trace info execution foo]
} {{{foo 1} 0 1 leave} {}}
a974 6
test trace-24.3 {delete trace during enter-leave trace} {
    set info {}
    trace add execution foo {enter leave} [list traceDelete foo]
    foo 1
    list $info [trace info execution foo]
} {{{foo 1} enter} {}}
a975 6
test trace-24.4 {delete trace during all exec traces} {
    set info {}
    trace add execution foo {enter leave enterstep leavestep} [list traceDelete foo]
    foo 1
    list $info [trace info execution foo]
} {{{foo 1} enter} {}}
a976 16
test trace-24.5 {delete trace during all exec traces except enter} {
    set info {}
    trace add execution foo {leave enterstep leavestep} [list traceDelete foo]
    foo 1
    list $info [trace info execution foo]
} {{{set b 1} enterstep} {}}

proc traceDelete {cmd args} {
    rename $cmd {}
    global info
    set info $args
}

proc foo {a} {
    set b $a
}
a977 6
test trace-25.1 {delete command during enter trace} {
    set info {}
    trace add execution foo enter [list traceDelete foo]
    catch {foo 1} err
    list $err $info [trace info execution foo]
} {{invalid command name "foo"} {{foo 1} enter} {unknown command "foo"}}
a978 3
proc foo {a} {
    set b $a
}
a979 6
test trace-25.2 {delete command during leave trace} {
    set info {}
    trace add execution foo leave [list traceDelete foo]
    foo 1
    list $info [trace info execution foo]
} {{{foo 1} 0 1 leave} {unknown command "foo"}}
a980 3
proc foo {a} {
    set b $a
}
a981 7
test trace-25.3 {delete command during enter then leave trace} {
    set info {}
    trace add execution foo enter [list traceDelete foo]
    trace add execution foo leave [list traceDelete foo]
    catch {foo 1} err
    list $err $info [trace info execution foo]
} {{invalid command name "foo"} {{foo 1} enter} {unknown command "foo"}}
a982 7
proc foo {a} {
    set b $a
}
proc traceExecute2 {args} {
    global info
    lappend info $args
}
a983 14
# This shows the peculiar consequences of having two traces
# at the same time: as well as tracing the procedure you want
test trace-25.4 {order dependencies of two enter traces} {
    set info {}
    trace add execution foo enter [list traceExecute traceExecute]
    trace add execution foo enter [list traceExecute2 traceExecute2]
    catch {foo 1} err
    trace remove execution foo enter [list traceExecute traceExecute]
    trace remove execution foo enter [list traceExecute2 traceExecute2]
    join [list $err [join $info \n] [trace info execution foo]] "\n"
} {1
traceExecute2 {foo 1} enter
traceExecute {foo 1} enter
}
a984 12
test trace-25.5 {order dependencies of two step traces} {
    set info {}
    trace add execution foo enterstep [list traceExecute traceExecute]
    trace add execution foo enterstep [list traceExecute2 traceExecute2]
    catch {foo 1} err
    trace remove execution foo enterstep [list traceExecute traceExecute]
    trace remove execution foo enterstep [list traceExecute2 traceExecute2]
    join [list $err [join $info \n] [trace info execution foo]] "\n"
} {1
traceExecute2 {set b 1} enterstep
traceExecute {set b 1} enterstep
}
a985 169
# We don't want the result string (5th argument), or the results
# will get unmanageable.
proc tracePostExecute {args} {
    global info
    lappend info [concat [lrange $args 0 2] [lindex $args 4]]
}
proc tracePostExecute2 {args} {
    global info
    lappend info [concat [lrange $args 0 2] [lindex $args 4]]
}

test trace-25.6 {order dependencies of two leave traces} {
    set info {}
    trace add execution foo leave [list tracePostExecute tracePostExecute]
    trace add execution foo leave [list tracePostExecute2 tracePostExecute2]
    catch {foo 1} err
    trace remove execution foo leave [list tracePostExecute tracePostExecute]
    trace remove execution foo leave [list tracePostExecute2 tracePostExecute2]
    join [list $err [join $info \n] [trace info execution foo]] "\n"
} {1
tracePostExecute {foo 1} 0 leave
tracePostExecute2 {foo 1} 0 leave
}

test trace-25.7 {order dependencies of two leavestep traces} {
    set info {}
    trace add execution foo leavestep [list tracePostExecute tracePostExecute]
    trace add execution foo leavestep [list tracePostExecute2 tracePostExecute2]
    catch {foo 1} err
    trace remove execution foo leavestep [list tracePostExecute tracePostExecute]
    trace remove execution foo leavestep [list tracePostExecute2 tracePostExecute2]
    join [list $err [join $info \n] [trace info execution foo]] "\n"
} {1
tracePostExecute {set b 1} 0 leavestep
tracePostExecute2 {set b 1} 0 leavestep
}

proc foo {a} {
    set b $a
}

proc traceDelete {cmd args} {
    rename $cmd {}
    global info
    set info $args
}

test trace-25.8 {delete command during enter leave and enter/leave-step traces} {
    set info {}
    trace add execution foo enter [list traceDelete foo]
    trace add execution foo leave [list traceDelete foo]
    trace add execution foo enterstep [list traceDelete foo]
    trace add execution foo leavestep [list traceDelete foo]
    catch {foo 1} err
    list $err $info [trace info execution foo]
} {{invalid command name "foo"} {{foo 1} enter} {unknown command "foo"}}

proc foo {a} {
    set b $a
}

test trace-25.9 {delete command during enter leave and leavestep traces} {
    set info {}
    trace add execution foo enter [list traceDelete foo]
    trace add execution foo leave [list traceDelete foo]
    trace add execution foo leavestep [list traceDelete foo]
    catch {foo 1} err
    list $err $info [trace info execution foo]
} {{invalid command name "foo"} {{foo 1} enter} {unknown command "foo"}}

proc foo {a} {
    set b $a
}

test trace-25.10 {delete command during leave and leavestep traces} {
    set info {}
    trace add execution foo leave [list traceDelete foo]
    trace add execution foo leavestep [list traceDelete foo]
    catch {foo 1} err
    list $err $info [trace info execution foo]
} {1 {{set b 1} 0 1 leavestep} {unknown command "foo"}}

proc foo {a} {
    set b $a
}

test trace-25.11 {delete command during enter and enterstep traces} {
    set info {}
    trace add execution foo enter [list traceDelete foo]
    trace add execution foo enterstep [list traceDelete foo]
    catch {foo 1} err
    list $err $info [trace info execution foo]
} {{invalid command name "foo"} {{foo 1} enter} {unknown command "foo"}}

test trace-26.1 {trace targetCmd when invoked through an alias} {
    proc foo {args} {
	set b $args
    }
    set info {}
    trace add execution foo enter [list traceExecute foo]
    interp alias {} bar {} foo 1
    bar 2
    trace remove execution foo enter [list traceExecute foo]
    set info
} {{foo {foo 1 2} enter}}
test trace-26.2 {trace targetCmd when invoked through an alias} {
    proc foo {args} {
	set b $args
    }
    set info {}
    trace add execution foo enter [list traceExecute foo]
    interp create child
    interp alias child bar {} foo 1
    child eval bar 2
    interp delete child
    trace remove execution foo enter [list traceExecute foo]
    set info
} {{foo {foo 1 2} enter}}

test trace-27.1 {memory leak in rename trace (604609)} {
    catch {rename bar {}}
    proc foo {} {error foo}
    trace add command foo rename {rename foo "" ;#}
    rename foo bar
    info commands foo
} {}

test trace-28.1 {enterstep and leavestep traces with update idletasks (615043)} {
    catch {rename foo {}}
    proc foo {} {
        set a 1
        update idletasks
        set b 1
    }

    set info {}
    trace add execution foo {enter enterstep leavestep leave} \
        [list traceExecute foo]
    update
    after idle {puts idle}
    foo

    trace remove execution foo {enter enterstep leavestep leave} \
        [list traceExecute foo]
    rename foo {}
    join $info "\n"
} {foo foo enter
foo {set a 1} enterstep
foo {set a 1} 0 1 leavestep
foo {update idletasks} enterstep
foo {puts idle} enterstep
foo {puts idle} 0 {} leavestep
foo {update idletasks} 0 {} leavestep
foo {set b 1} enterstep
foo {set b 1} 0 1 leavestep
foo foo 0 1 leave}

# Delete procedures when done, so we don't clash with other tests
# (e.g. foobar will clash with 'unknown' tests).
catch {rename foobar {}}
catch {rename foo {}}
catch {rename bar {}}

# Unset the varaible when done
catch {unset info}

# cleanup
::tcltest::cleanupTests
return
@


1.3.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@d14 1
a14 1
# RCS: @@(#) $Id: trace.test,v 1.22 2002/09/06 00:20:29 dgp Exp $
a54 15
proc traceCommand {oldName newName op} {
    global info
    set info [list $oldName $newName $op]
}

test trace-0.0 {memory corruption in trace (Tcl Bug 484339)} {
    # You may need Purify or Electric Fence to reliably
    # see this one fail.
    catch {unset z}
    trace add variable z array {set z(foo) 1 ;#}
    set res "names: [array names z]"
    catch {unset ::z}
    trace variable ::z w {unset ::z; error "memory corruption";#}
    list [catch {set ::z 1} msg] $msg
} {1 {can't set "::z": memory corruption}}
d61 1
a61 1
    trace add variable x read traceScalar
d63 1
a63 1
} {1 {can't read "x": no such variable} {x {} read 1 {can't read "x": no such variable}}}
d68 1
a68 1
    trace add variable x read traceScalar
d70 1
a70 1
} {0 123 {x {} read 0 123}}
d74 1
a74 1
    trace add variable x read traceScalar
d81 1
a81 1
    trace add variable x(2) read traceArray
d83 1
a83 1
} {1 {can't read "x(2)": no such element in array} {x 2 read 1 {can't read "x(2)": no such element in array}}}
d88 1
a88 1
    trace add variable x(2) read traceArray
d90 1
a90 1
} {0 zzz {x 2 read 0 zzz}}
d94 1
a94 1
    trace add variable x read traceArray2
d101 1
a101 1
} {0 willi {x 2 read}}
d105 1
a105 1
    trace add variable x read q
d118 1
a118 1
} {0 wolf {x Y read}}
d122 1
a122 1
    trace add variable x read traceArray
d129 1
a129 1
    trace add variable x read traceArray
d131 1
a131 1
} {0 zzz {x 2 read 0 zzz}}
d136 1
a136 1
    trace add variable x read traceScalar
a139 28
test trace-1.11 {read traces that modify the array structure} {
    catch {unset x}
    set x(bar) 0 
    trace variable x r {set x(foo) 1 ;#} 
    trace variable x r {unset -nocomplain x(bar) ;#} 
    array get x
} {}
test trace-1.12 {read traces that modify the array structure} {
    catch {unset x}
    set x(bar) 0 
    trace variable x r {unset -nocomplain x(bar) ;#} 
    trace variable x r {set x(foo) 1 ;#} 
    array get x
} {}
test trace-1.13 {read traces that modify the array structure} {
    catch {unset x}
    set x(bar) 0 
    trace variable x r {set x(foo) 1 ;#} 
    trace variable x r {unset -nocomplain x;#} 
    list [catch {array get x} res] $res
} {1 {can't read "x(bar)": no such variable}}
test trace-1.14 {read traces that modify the array structure} {
    catch {unset x}
    set x(bar) 0 
    trace variable x r {unset -nocomplain x;#} 
    trace variable x r {set x(foo) 1 ;#} 
    list [catch {array get x} res] $res
} {1 {can't read "x(bar)": no such variable}}
d146 1
a146 1
    trace add variable x write traceScalar
d149 1
a149 1
} {x {} write 0 123}
d153 1
a153 1
    trace add variable x(33) write traceArray
d156 1
a156 1
} {x 33 write 0 444}
d160 1
a160 1
    trace add variable x write traceArray
d163 1
a163 1
} {x abc write 0 qq}
d168 1
a168 1
    trace add variable x write traceScalar
d176 1
a176 1
    trace add variable x write traceScalar
d189 1
a189 1
    trace add variable x read traceScalarAppend
d194 1
a194 1
} {x {} read 0 123456}
d198 1
a198 1
    trace add variable x {read write} traceScalarAppend
d202 1
a202 1
} {x {} write 0 123 x {} read 0 123 x {} write 0 {123 456}}
d209 1
a209 1
    trace add variable x unset traceScalar
d212 1
a212 1
} {x {} unset 1 {can't read "x": no such variable}}
d217 1
a217 1
    trace add variable x unset traceScalar
d220 1
a220 1
} {x {} unset 1 {can't read "x": no such variable}}
d224 1
a224 1
    trace add variable x unset traceScalar
d233 1
a233 1
    trace add variable x(1) unset traceArray
d236 1
a236 1
} {x 1 unset 1 {can't read "x(1)": no such element in array}}
d241 1
a241 1
    trace add variable x(1) unset traceArray
d244 1
a244 1
} {x 1 unset 1 {can't read "x(1)": no such element in array}}
d249 1
a249 1
    trace add variable x(1) unset traceArray
d252 1
a252 1
} {x 1 unset 1 {can't read "x(1)": no such variable}}
d257 1
a257 1
    trace add variable x unset traceProc
d267 1
a267 1
    trace add variable x unset traceProc
d270 1
a270 1
} {x 1 unset}
d277 1
a277 1
    trace add variable x unset traceProc
d280 1
a280 1
} {x {} unset}
a281 60
# Array tracing on variables
test trace-5.1 {array traces fire on accesses via [array]} {
    catch {unset x}
    set x(b) 2
    trace add variable x array traceArray2
    set ::info {}
    array set x {a 1}
    set ::info
} {x {} array}
test trace-5.2 {array traces do not fire on normal accesses} {
    catch {unset x}
    set x(b) 2
    trace add variable x array traceArray2
    set ::info {}
    set x(a) 1
    set x(b) $x(a)
    set ::info
} {}
test trace-5.3 {array traces do not outlive variable} {
    catch {unset x}
    trace add variable x array traceArray2
    set ::info {}
    set x(a) 1
    unset x
    array set x {a 1}
    set ::info
} {}
test trace-5.4 {array traces properly listed in trace information} {
    catch {unset x}
    trace add variable x array traceArray2
    set result [trace info variable x]
    set result
} [list [list array traceArray2]]
test trace-5.5 {array traces properly listed in trace information} {
    catch {unset x}
    trace variable x a traceArray2
    set result [trace vinfo x]
    set result
} [list [list a traceArray2]]
test trace-5.6 {array traces don't fire on scalar variables} {
    catch {unset x}
    set x foo
    trace add variable x array traceArray2
    set ::info {}
    catch {array set x {a 1}}
    set ::info
} {}
test trace-5.7 {array traces fire for undefined variables} {
    catch {unset x}
    trace add variable x array traceArray2
    set ::info {}
    array set x {a 1}
    set ::info
} {x {} array}
test trace-5.8 {array traces fire for undefined variables} {
    catch {unset x}
    trace add variable x array {set x(foo) 1 ;#}
    set res "names: [array names x]"
} {names: foo}
    
d284 1
a284 1
test trace-6.1 {multiple ops traced at once} {
d287 1
a287 1
    trace add variable x {read write unset} traceProc
d294 2
a295 2
} {x {} read x {} write x {} read x {} write x {} unset}
test trace-6.2 {multiple ops traced on array element} {
d298 1
a298 1
    trace add variable x(0) {read write unset} traceProc
d306 2
a307 2
} {x 0 read x 0 write x 0 read x 0 write x 0 unset}
test trace-6.3 {multiple ops traced on whole array} {
d310 1
a310 1
    trace add variable x {read write unset} traceProc
d318 1
a318 1
} {x 0 write x 0 read x 0 write x 0 unset x {} unset}
d322 1
a322 1
test trace-7.1 {order of invocation of traces} {
d325 3
a327 3
    trace add variable x read "traceTag 1"
    trace add variable x read "traceTag 2"
    trace add variable x read "traceTag 3"
d333 1
a333 1
test trace-7.2 {order of invocation of traces} {
d337 3
a339 3
    trace add variable x(0) read "traceTag 1"
    trace add variable x(0) read "traceTag 2"
    trace add variable x(0) read "traceTag 3"
d343 1
a343 1
test trace-7.3 {order of invocation of traces} {
d347 6
a352 6
    trace add variable x(0) read "traceTag 1"
    trace add variable x read "traceTag A1"
    trace add variable x(0) read "traceTag 2"
    trace add variable x read "traceTag A2"
    trace add variable x(0) read "traceTag 3"
    trace add variable x read "traceTag A3"
d359 1
a359 1
test trace-8.1 {error returns from traces} {
d363 2
a364 2
    trace add variable x read "traceTag 1"
    trace add variable x read traceError
d367 1
a367 1
test trace-8.2 {error returns from traces} {
d371 2
a372 2
    trace add variable x write "traceTag 1"
    trace add variable x write traceError
d375 1
a375 1
test trace-8.3 {error returns from traces} {
d379 1
a379 1
    trace add variable x write traceError
d382 1
a382 1
test trace-8.4 {error returns from traces} {
d386 2
a387 2
    trace add variable x unset "traceTag 1"
    trace add variable x unset traceError
d390 1
a390 1
test trace-8.5 {error returns from traces} {
d394 4
a397 4
    trace add variable x(0) read "traceTag 1"
    trace add variable x read "traceTag 2"
    trace add variable x read traceError
    trace add variable x read "traceTag 3"
d400 1
a400 1
test trace-8.6 {error returns from traces} {
d403 1
a403 1
    trace add variable x unset traceError
d406 1
a406 1
test trace-8.7 {error returns from traces} {
d412 1
a412 1
    trace add variable x read traceError
d415 1
a415 23
    trace remove variable x read traceError
} {}
test trace-8.8 {error returns from traces} {
    # Yet more elaborate memory corruption testing that checks nothing
    # bad happens when the trace deletes itself and installs something
    # new.  Alas, there is no neat way to guarantee that this test will
    # fail if there is a problem, but that's life and with the new code
    # it should *never* fail.
    #
    # Adapted from Bug #219393 reported by Don Porter.
    catch {rename ::foo {}}
    proc foo {old args} {
	trace remove variable ::x write [list foo $old]
	trace add    variable ::x write [list foo $::x]
	error "foo"
    }
    catch {unset ::x ::y}
    set x junk
    trace add variable ::x write [list foo $x]
    for {set y 0} {$y<100} {incr y} {
	catch {set x junk}
    }
    unset x
d422 1
a422 1
test trace-9.1 {be sure variable is unset before trace is called} {
d426 1
a426 1
    trace add variable x unset {traceCheck {uplevel set x}}
d430 1
a430 1
test trace-9.2 {be sure variable is unset before trace is called} {
d434 1
a434 1
    trace add variable x unset {traceCheck {uplevel set x 22}}
d438 1
a438 1
test trace-9.3 {be sure traces are cleared before unset trace called} {
d442 1
a442 1
    trace add variable x unset {traceCheck {uplevel trace info variable x}}
d446 1
a446 1
test trace-9.4 {set new trace during unset trace} {
d450 1
a450 1
    trace add variable x unset {traceCheck {global x; trace add variable x unset traceProc}}
d452 2
a453 2
    concat $info [trace info variable x]
} {0 {} {unset traceProc}}
d455 1
a455 1
test trace-10.1 {make sure array elements are unset before traces are called} {
d459 1
a459 1
    trace add variable x(0) unset {traceCheck {uplevel set x(0)}}
d463 1
a463 1
test trace-10.2 {make sure array elements are unset before traces are called} {
d467 1
a467 1
    trace add variable x(0) unset {traceCheck {uplevel set x(0) zzz}}
d471 1
a471 1
test trace-10.3 {array elements are unset before traces are called} {
d475 1
a475 1
    trace add variable x(0) unset {traceCheck {global x; trace info variable x(0)}}
d479 1
a479 1
test trace-10.4 {set new array element trace during unset trace} {
d483 1
a483 1
    trace add variable x(0) unset {traceCheck {uplevel {trace add variable x(0) read {}}}}
d485 2
a486 2
    concat $info [trace info variable x(0)]
} {0 {} {read {}}}
d488 1
a488 1
test trace-11.1 {make sure arrays are unset before traces are called} {
d492 1
a492 1
    trace add variable x unset {traceCheck {uplevel set x(0)}}
d496 1
a496 1
test trace-11.2 {make sure arrays are unset before traces are called} {
d500 1
a500 1
    trace add variable x unset {traceCheck {uplevel set x(y) 22}}
d504 1
a504 1
test trace-11.3 {make sure arrays are unset before traces are called} {
d508 1
a508 1
    trace add variable x unset {traceCheck {uplevel array exists x}}
d512 1
a512 1
test trace-11.4 {make sure arrays are unset before traces are called} {
d516 2
a517 2
    set cmd {traceCheck {uplevel {trace info variable x}}}
    trace add variable x unset $cmd
d521 1
a521 1
test trace-11.5 {set new array trace during unset trace} {
d525 1
a525 1
    trace add variable x unset {traceCheck {global x; trace add variable x read {}}}
d527 3
a529 3
    concat $info [trace info variable x]
} {0 {} {read {}}}
test trace-11.6 {create scalar during array unset trace} {
d533 1
a533 1
    trace add variable x unset {traceCheck {global x; set x 44}}
d540 1
a540 1
test trace-12.1 {creating array when setting variable traces} {
d543 1
a543 1
    trace add variable x(0) write traceProc
d546 1
a546 1
test trace-12.2 {creating array when setting variable traces} {
d549 1
a549 1
    trace add variable x(0) write traceProc
d552 1
a552 1
test trace-12.3 {creating array when setting variable traces} {
d555 1
a555 1
    trace add variable x(0) write traceProc
d558 2
a559 2
} {x 0 write}
test trace-12.4 {creating variable when setting variable traces} {
d562 1
a562 1
    trace add variable x write traceProc
d565 1
a565 1
test trace-12.5 {creating variable when setting variable traces} {
d568 1
a568 1
    trace add variable x write traceProc
d571 2
a572 2
} {x {} write}
test trace-12.6 {creating variable when setting variable traces} {
d575 1
a575 1
    trace add variable x write traceProc
d578 2
a579 2
} {x 0 write}
test trace-12.7 {create array element during read trace} {
d582 1
a582 1
    trace add variable x read {traceCrtElement xyzzy}
d585 1
a585 1
test trace-12.8 {errors when setting variable traces} {
d588 1
a588 1
    list [catch {trace add variable x(0) write traceProc} msg] $msg
d593 1
a593 1
test trace-13.1 {delete one trace from another} {
d596 3
a598 3
	trace remove variable x read {traceTag 2}
	trace remove variable x read {traceTag 3}
	trace remove variable x read {traceTag 4}
d603 6
a608 6
    trace add variable x read {traceTag 1}
    trace add variable x read {traceTag 2}
    trace add variable x read {traceTag 3}
    trace add variable x read {traceTag 4}
    trace add variable x read delTraces 
    trace add variable x read {traceTag 5}
d615 1
a615 33
# Syntax for adding/removing variable and command traces is basically the
# same:
#	trace add variable name opList command
#	trace remove variable name opList command
#
# The following loops just get all the common "wrong # args" tests done.

set i 0
set start "wrong # args:"
foreach type {variable command} {
    foreach op {add remove} {
	test trace-14.0.[incr i] "trace command, wrong # args errors" {
	    list [catch {trace $op $type} msg] $msg
	} [list 1 "$start should be \"trace $op $type name opList command\""]
	test trace-14.0.[incr i] "trace command wrong # args errors" {
	    list [catch {trace $op $type foo} msg] $msg
	} [list 1 "$start should be \"trace $op $type name opList command\""]
	test trace-14.0.[incr i] "trace command, wrong # args errors" {
	    list [catch {trace $op $type foo bar} msg] $msg
	} [list 1 "$start should be \"trace $op $type name opList command\""]
	test trace-14.0.[incr i] "trace command, wrong # args errors" {
	    list [catch {trace $op $type foo bar baz boo} msg] $msg
	} [list 1 "$start should be \"trace $op $type name opList command\""]
    }
    test trace-14.0.[incr i] "trace command, wrong # args errors" {
	list [catch {trace info $type foo bar} msg] $msg
    } [list 1 "$start should be \"trace info $type name\""]
    test trace-14.0.[incr i] "trace command, wrong # args errors" {
	list [catch {trace info $type} msg] $msg
    } [list 1 "$start should be \"trace info $type name\""]
}

test trace-14.1 "trace command, wrong # args errors" {
d617 2
a618 12
} [list 1 "wrong # args: should be \"trace option ?arg arg ...?\""]
test trace-14.2 "trace command, wrong # args errors" {
    list [catch {trace add} msg] $msg
} [list 1 "wrong # args: should be \"trace add type ?arg arg ...?\""]
test trace-14.3 "trace command, wrong # args errors" {
    list [catch {trace remove} msg] $msg
} [list 1 "wrong # args: should be \"trace remove type ?arg arg ...?\""]
test trace-14.4 "trace command, wrong # args errors" {
    list [catch {trace info} msg] $msg
} [list 1 "wrong # args: should be \"trace info type ?arg arg ...?\""]

test trace-14.5 {trace command, invalid option} {
d620 2
a621 34
} [list 1 "bad option \"gorp\": must be add, info, remove, variable, vdelete, or vinfo"]

# Again, [trace ... command] and [trace ... variable] share syntax and
# error message styles for their opList options; these loops test those 
# error messages.

set i 0
set errs [list "array, read, unset, or write" "delete or rename" "enter, leave, enterstep, or leavestep"]
set abbvs [list {a r u w} {d r} {}]
proc x {} {}
foreach type {variable command execution} err $errs abbvlist $abbvs {
    foreach op {add remove} {
	test trace-14.6.[incr i] "trace $op $type errors" {
	    list [catch {trace $op $type x {y z w} a} msg] $msg
	} [list 1 "bad operation \"y\": must be $err"]
	foreach abbv $abbvlist {
	    test trace-14.6.[incr i] "trace $op $type rejects abbreviations" {
		list [catch {trace $op $type x $abbv a} msg] $msg
	    } [list 1 "bad operation \"$abbv\": must be $err"]
	}
	test trace-14.6.[incr i] "trace $op $type rejects null opList" {
	    list [catch {trace $op $type x {} a} msg] $msg
	} [list 1 "bad operation list \"\": must be one or more of $err"]
    }
}
rename x {}

test trace-14.7 {trace command, "trace variable" errors} {
    list [catch {trace variable} msg] $msg
} [list 1 "wrong # args: should be \"trace variable name ops command\""]
test trace-14.8 {trace command, "trace variable" errors} {
    list [catch {trace variable x} msg] $msg
} [list 1 "wrong # args: should be \"trace variable name ops command\""]
test trace-14.9 {trace command, "trace variable" errors} {
d623 17
a639 10
} [list 1 "wrong # args: should be \"trace variable name ops command\""]
test trace-14.10 {trace command, "trace variable" errors} {
    list [catch {trace variable x y z w} msg] $msg
} [list 1 "wrong # args: should be \"trace variable name ops command\""]
test trace-14.11 {trace command, "trace variable" errors} {
    list [catch {trace variable x y z} msg] $msg
} [list 1 "bad operations \"y\": should be one or more of rwua"]


test trace-14.9 {trace command ("remove variable" option)} {
d642 2
a643 2
    trace add variable x write traceProc
    trace remove variable x write traceProc
d645 1
a645 1
test trace-14.10 {trace command ("remove variable" option)} {
d648 2
a649 2
    trace add variable x write traceProc
    trace remove variable x write traceProc
d653 1
a653 1
test trace-14.11 {trace command ("remove variable" option)} {
d656 3
a658 3
    trace add variable x write {traceTag 1}
    trace add variable x write traceProc
    trace add variable x write {traceTag 2}
d660 1
a660 1
    trace remove variable x write traceProc
d662 1
a662 1
    trace remove variable x write {traceTag 1}
d664 1
a664 1
    trace remove variable x write {traceTag 2}
d667 2
a668 2
} {2 x {} write 1 2 1 2}
test trace-14.12 {trace command ("remove variable" option)} {
d671 2
a672 2
    trace add variable x write {traceTag 1}
    trace remove variable x write non_existent
d676 14
a689 8
test trace-14.15 {trace command ("list variable" option)} {
    catch {unset x}
    trace add variable x write {traceTag 1}
    trace add variable x write traceProc
    trace add variable x write {traceTag 2}
    trace info variable x
} {{write {traceTag 2}} {write traceProc} {write {traceTag 1}}}
test trace-14.16 {trace command ("list variable" option)} {
d691 1
a691 1
    trace info variable x
d693 1
a693 1
test trace-14.17 {trace command ("list variable" option)} {
d695 1
a695 1
    trace info variable x(0)
d697 1
a697 1
test trace-14.18 {trace command ("list variable" option)} {
d700 1
a700 1
    trace info variable x(0)
d702 1
a702 1
test trace-14.19 {trace command ("list variable" option)} {
d705 2
a706 2
    trace add variable x write {traceTag 1}
    proc check {} {global x; trace info variable x}
d708 1
a708 1
} {{write {traceTag 1}}}
d712 1
a712 1
test trace-15.1 {long trace command} {
d715 1
a715 1
    trace add variable x write {traceTag {This is a very very long argument.  It's \
d727 1
a727 1
test trace-15.2 {long trace command result to ignore} {
d732 1
a732 1
    trace add variable x write longResult
d737 1
a737 1
test trace-15.3 {special list-handling in trace commands} {
d741 1
a741 1
    trace add variable "x y z(a\n\{)" write traceProc
d744 1
a744 1
} "{x y z} a\\n\\\{ write"
d768 1
a768 1
test trace-16.1 {unsets during read traces} {
d772 2
a773 2
    trace add variable y read {traceUnset y}
    trace add variable y unset {traceAppend unset}
d776 1
a776 1
test trace-16.2 {unsets during read traces} {
d780 1
a780 1
    trace add variable y(0) read {traceUnset y(0)}
d783 1
a783 1
test trace-16.3 {unsets during read traces} {
d787 1
a787 1
    trace add variable y(0) read {traceUnset y}
d790 1
a790 1
test trace-16.4 {unsets during read traces} {
d794 1
a794 1
    trace add variable y read {traceReset y y}
d797 1
a797 1
test trace-16.5 {unsets during read traces} {
d801 1
a801 1
    trace add variable y(0) read {traceReset y(0) y(0)}
d804 1
a804 1
test trace-16.6 {unsets during read traces} {
d808 1
a808 1
    trace add variable y(0) read {traceReset y y(0)}
d811 1
a811 1
test trace-16.7 {unsets during read traces} {
d815 1
a815 1
    trace add variable y(0) read {traceReset2 y y(0)}
d818 1
a818 1
test trace-16.8 {unsets during write traces} {
d822 2
a823 2
    trace add variable y write {traceUnset y}
    trace add variable y unset {traceAppend unset}
d826 1
a826 1
test trace-16.9 {unsets during write traces} {
d830 1
a830 1
    trace add variable y(0) write {traceUnset y(0)}
d833 1
a833 1
test trace-16.10 {unsets during write traces} {
d837 1
a837 1
    trace add variable y(0) write {traceUnset y}
d840 1
a840 1
test trace-16.11 {unsets during write traces} {
d844 1
a844 1
    trace add variable y write {traceReset y y}
d847 1
a847 1
test trace-16.12 {unsets during write traces} {
d851 1
a851 1
    trace add variable y(0) write {traceReset y(0) y(0)}
d854 1
a854 1
test trace-16.13 {unsets during write traces} {
d858 1
a858 1
    trace add variable y(0) write {traceReset y y(0)}
d861 1
a861 1
test trace-16.14 {unsets during write traces} {
d865 1
a865 1
    trace add variable y(0) write {traceReset2 y y(0)}
d868 1
a868 1
test trace-16.15 {unsets during unset traces} {
d872 1
a872 1
    trace add variable y unset {traceUnset y}
d875 1
a875 1
test trace-16.16 {unsets during unset traces} {
d879 1
a879 1
    trace add variable y(0) unset {traceUnset y(0)}
d882 1
a882 1
test trace-16.17 {unsets during unset traces} {
d886 1
a886 1
    trace add variable y(0) unset {traceUnset y}
d889 1
a889 1
test trace-16.18 {unsets during unset traces} {
d893 1
a893 1
    trace add variable y unset {traceReset2 y y}
d896 1
a896 1
test trace-16.19 {unsets during unset traces} {
d900 1
a900 1
    trace add variable y(0) unset {traceReset2 y(0) y(0)}
d903 1
a903 1
test trace-16.20 {unsets during unset traces} {
d907 1
a907 1
    trace add variable y(0) unset {traceReset2 y y(0)}
d910 1
a910 1
test trace-16.21 {unsets cancelling traces} {
d914 4
a917 4
    trace add variable y read {traceAppend first}
    trace add variable y read {traceUnset y}
    trace add variable y read {traceAppend third}
    trace add variable y unset {traceAppend unset}
d920 1
a920 1
test trace-16.22 {unsets cancelling traces} {
d924 4
a927 4
    trace add variable y(0) read {traceAppend first}
    trace add variable y(0) read {traceUnset y}
    trace add variable y(0) read {traceAppend third}
    trace add variable y(0) unset {traceAppend unset}
d933 1
a933 1
test trace-17.1 {trace doesn't prevent unset errors} {
d936 1
a936 1
    trace add variable x unset {traceProc}
d938 2
a939 2
} {1 {can't unset "x": no such variable} {x {} unset}}
test trace-17.2 {traced variables must survive procedure exits} {
d941 1
a941 1
    proc p1 {} {global x; trace add variable x write traceProc}
d943 3
a945 3
    trace info variable x
} {{write traceProc}}
test trace-17.3 {traced variables must survive procedure exits} {
d948 1
a948 1
    proc p1 {} {global x; trace add variable x write traceProc}
d952 1
a952 1
} {x {} write}
d957 1
a957 1
test trace-18.1 {unset traces on procedure returns} {
d959 1
a959 1
    proc p2 {z} {trace add variable z unset {traceCheck {lsort [uplevel {info vars}]}}}
a963 11
test trace-18.2 {namespace delete / trace vdelete combo} {
    namespace eval ::foo {
	variable x 123
    }
    proc p1 args {
	trace vdelete ::foo::x u p1
    }
    trace variable ::foo::x u p1
    namespace delete ::foo
    info exists ::foo::x
} 0
d971 3
a973 292
test trace-18.2 {trace add command (command existence)} {
    # Just in case!
    catch {rename nosuchname ""}
    list [catch {trace add command nosuchname rename traceCommand} msg] $msg
} {1 {unknown command "nosuchname"}}
test trace-18.3 {trace add command (command existence in ns)} {
    list [catch {trace add command nosuchns::nosuchname rename traceCommand} msg] $msg
} {1 {unknown command "nosuchns::nosuchname"}}


test trace-19.1 {trace add command (rename option)} {
    proc foo {} {}
    catch {rename bar {}}
    trace add command foo rename traceCommand
    rename foo bar
    set info
} {foo bar rename}
test trace-19.2 {traces stick with renamed commands} {
    proc foo {} {}
    catch {rename bar {}}
    trace add command foo rename traceCommand
    rename foo bar
    rename bar foo
    set info
} {bar foo rename}
test trace-19.2.1 {trace add command rename trace exists} {
    proc foo {} {}
    trace add command foo rename traceCommand
    trace info command foo
} {{rename traceCommand}}
test trace-19.3 {command rename traces don't fire on command deletion} {
    proc foo {} {}
    set info {}
    trace add command foo rename traceCommand
    rename foo {}
    set info
} {}
test trace-19.4 {trace add command rename doesn't trace recreated commands} {
    proc foo {} {}
    catch {rename bar {}}
    trace add command foo rename traceCommand
    proc foo {} {}
    rename foo bar
    set info
} {}
test trace-19.5 {trace add command deleted removes traces} {
    proc foo {} {}
    trace add command foo rename traceCommand
    proc foo {} {}
    trace info command foo
} {}

namespace eval tc {}
proc tc::tcfoo {} {}
test trace-19.6 {trace add command rename in namespace} {
    trace add command tc::tcfoo rename traceCommand
    rename tc::tcfoo tc::tcbar
    set info
} {tc::tcfoo tc::tcbar rename}
test trace-19.7 {trace add command rename in namespace back again} {
    rename tc::tcbar tc::tcfoo
    set info
} {tc::tcbar tc::tcfoo rename}
test trace-19.8 {trace add command rename in namespace to out of namespace} {
    rename tc::tcfoo tcbar
    set info
} {tc::tcfoo tcbar rename}
test trace-19.9 {trace add command rename back into namespace} {
    rename tcbar tc::tcfoo
    set info
} {tcbar tc::tcfoo rename}
test trace-19.10 {trace add command failed rename doesn't trigger trace} {
    set info {}
    proc foo {} {}
    proc bar {} {}
    trace add command foo {rename delete} traceCommand
    catch {rename foo bar}
    set info
} {}
catch {rename foo {}}
catch {rename bar {}}

# Make sure it exists again
proc foo {} {}

test trace-20.1 {trace add command (delete option)} {
    trace add command foo delete traceCommand
    rename foo ""
    set info
} {::foo {} delete}
test trace-20.2 {trace add command delete doesn't trace recreated commands} {
    set info {}
    proc foo {} {}
    rename foo ""
    set info
} {}
test trace-20.2.1 {trace add command delete trace info} {
    proc foo {} {}
    trace add command foo delete traceCommand
    trace info command foo
} {{delete traceCommand}}
test trace-20.3 {trace add command implicit delete} {
    proc foo {} {}
    trace add command foo delete traceCommand
    proc foo {} {}
    set info
} {::foo {} delete}
test trace-20.3.1 {trace add command delete trace info} {
    proc foo {} {}
    trace info command foo
} {}
test trace-20.4 {trace add command rename followed by delete} {
    set infotemp {}
    proc foo {} {}
    trace add command foo {rename delete} traceCommand
    rename foo bar
    lappend infotemp $info
    rename bar {}
    lappend infotemp $info
    set info $infotemp
    unset infotemp
    set info
} {{foo bar rename} {::bar {} delete}}
catch {rename foo {}}
catch {rename bar {}}

test trace-20.5 {trace add command rename and delete} {
    set infotemp {}
    set info {}
    proc foo {} {}
    trace add command foo {rename delete} traceCommand
    rename foo bar
    lappend infotemp $info
    rename bar {}
    lappend infotemp $info
    set info $infotemp
    unset infotemp
    set info
} {{foo bar rename} {::bar {} delete}}

test trace-20.6 {trace add command rename and delete in subinterp} {
    set tc [interp create]
    foreach p {traceCommand} {
	$tc eval [list proc $p [info args $p] [info body $p]]
    }
    $tc eval [list set infotemp {}]
    $tc eval [list set info {}]
    $tc eval [list proc foo {} {}]
    $tc eval [list trace add command foo {rename delete} traceCommand]
    $tc eval [list rename foo bar]
    $tc eval {lappend infotemp $info}
    $tc eval [list rename bar {}]
    $tc eval {lappend infotemp $info}
    $tc eval {set info $infotemp}
    $tc eval [list unset infotemp]
    set info [$tc eval [list set info]]
    interp delete $tc
    set info
} {{foo bar rename} {::bar {} delete}}

# I'd like it if this test could give 'foo {} d' as a result,
# but interp deletion means there is no interp to evaluate
# the trace in.
test trace-20.7 {trace add command delete in subinterp while being deleted} {
    set info {}
    set tc [interp create]
    interp alias $tc traceCommand {} traceCommand
    $tc eval [list proc foo {} {}]
    $tc eval [list trace add command foo {rename delete} traceCommand]
    interp delete $tc
    set info
} {}

proc traceDelete {cmd old new op} {
    eval trace remove command $cmd [lindex [trace info command $cmd] 0]
    global info
    set info [list $old $new $op]
}
proc traceCmdrename {cmd old new op} {
    rename $old someothername
}
proc traceCmddelete {cmd old new op} {
    rename $old ""
}
test trace-20.8 {trace delete while trace is active} {
    set info {}
    proc foo {} {}
    catch {rename bar {}}
    trace add command foo {rename delete} [list traceDelete foo]
    rename foo bar
    list [set info] [trace info command bar]
} {{foo bar rename} {}}

test trace-20.9 {rename trace deletes command} {
    set info {}
    proc foo {} {}
    catch {rename bar {}}
    catch {rename someothername {}}
    trace add command foo rename [list traceCmddelete foo]
    rename foo bar
    list [info commands foo] [info commands bar] [info commands someothername]
} {{} {} {}}

test trace-20.10 {rename trace renames command} {
    set info {}
    proc foo {} {}
    catch {rename bar {}}
    catch {rename someothername {}}
    trace add command foo rename [list traceCmdrename foo]
    rename foo bar
    set info [list [info commands foo] [info commands bar] [info commands someothername]]
    rename someothername {}
    set info
} {{} {} someothername}

test trace-20.11 {delete trace deletes command} {
    set info {}
    proc foo {} {}
    catch {rename bar {}}
    catch {rename someothername {}}
    trace add command foo delete [list traceCmddelete foo]
    rename foo {}
    list [info commands foo] [info commands bar] [info commands someothername]
} {{} {} {}}

test trace-20.12 {delete trace renames command} {
    set info {}
    proc foo {} {}
    catch {rename bar {}}
    catch {rename someothername {}}
    trace add command foo delete [list traceCmdrename foo]
    rename foo bar
    rename bar {}
    # None of these should exist.
    list [info commands foo] [info commands bar] [info commands someothername]
} {{} {} {}}

proc foo {b} { set a $b }


# Delete arrays when done, so they can be re-used as scalars
# elsewhere.

catch {unset x}
catch {unset y}

# Delete procedures when done, so we don't clash with other tests
# (e.g. foobar will clash with 'unknown' tests).
catch {rename foobar {}}
catch {rename foo {}}
catch {rename bar {}}

proc foo {a} {
    set b $a
}

proc traceExecute {args} {
    global info
    lappend info $args
}

test trace-21.1 {trace execution: enter} {
    set info {}
    trace add execution foo enter [list traceExecute foo]
    foo 1
    trace remove execution foo enter [list traceExecute foo]
    set info
} {{foo {foo 1} enter}}

test trace-21.2 {trace exeuction: leave} {
    set info {}
    trace add execution foo leave [list traceExecute foo]
    foo 2
    trace remove execution foo leave [list traceExecute foo]
    set info
} {{foo {foo 2} 0 2 leave}}

test trace-21.3 {trace exeuction: enter, leave} {
    set info {}
    trace add execution foo {enter leave} [list traceExecute foo]
    foo 3
    trace remove execution foo {enter leave} [list traceExecute foo]
    set info
} {{foo {foo 3} enter} {foo {foo 3} 0 3 leave}}

test trace-21.4 {trace execution: enter, leave, enterstep} {
    set info {}
    trace add execution foo {enter leave enterstep} [list traceExecute foo]
    foo 3
    trace remove execution foo {enter leave enterstep} [list traceExecute foo]
    set info
} {{foo {foo 3} enter} {foo {set b 3} enterstep} {foo {foo 3} 0 3 leave}}
a974 7
test trace-21.5 {trace execution: enter, leave, enterstep, leavestep} {
    set info {}
    trace add execution foo {enter leave enterstep leavestep} [list traceExecute foo]
    foo 3
    trace remove execution foo {enter leave enterstep leavestep} [list traceExecute foo]
    set info
} {{foo {foo 3} enter} {foo {set b 3} enterstep} {foo {set b 3} 0 3 leavestep} {foo {foo 3} 0 3 leave}}
a975 15
test trace-21.6 {trace execution: enterstep, leavestep} {
    set info {}
    trace add execution foo {enterstep leavestep} [list traceExecute foo]
    foo 3
    trace remove execution foo {enterstep leavestep} [list traceExecute foo]
    set info
} {{foo {set b 3} enterstep} {foo {set b 3} 0 3 leavestep}}

test trace-21.7 {trace execution: enterstep} {
    set info {}
    trace add execution foo {enterstep} [list traceExecute foo]
    foo 3
    trace remove execution foo {enterstep} [list traceExecute foo]
    set info
} {{foo {set b 3} enterstep}}
a976 7
test trace-21.8 {trace execution: leavestep} {
    set info {}
    trace add execution foo {leavestep} [list traceExecute foo]
    foo 3
    trace remove execution foo {leavestep} [list traceExecute foo]
    set info
} {{foo {set b 3} 0 3 leavestep}}
a977 4
proc factorial {n} {
    if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }
    return 1
}
a978 98
test trace-22.1 {recursive(1) trace execution: enter} {
    set info {}
    trace add execution factorial {enter} [list traceExecute factorial]
    factorial 1
    trace remove execution factorial {enter} [list traceExecute factorial]
    set info
} {{factorial {factorial 1} enter}}

test trace-22.2 {recursive(2) trace execution: enter} {
    set info {}
    trace add execution factorial {enter} [list traceExecute factorial]
    factorial 2
    trace remove execution factorial {enter} [list traceExecute factorial]
    set info
} {{factorial {factorial 2} enter} {factorial {factorial 1} enter}}

test trace-22.3 {recursive(3) trace execution: enter} {
    set info {}
    trace add execution factorial {enter} [list traceExecute factorial]
    factorial 3
    trace remove execution factorial {enter} [list traceExecute factorial]
    set info
} {{factorial {factorial 3} enter} {factorial {factorial 2} enter} {factorial {factorial 1} enter}}

test trace-23.1 {recursive(1) trace execution: enter, leave, enterstep, leavestep} {
    set info {}
    trace add execution factorial {enter leave enterstep leavestep} [list traceExecute]
    factorial 1
    trace remove execution factorial {enter leave enterstep leavestep} [list traceExecute]
    join $info "\n"
} {{factorial 1} enter
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} enterstep
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} 0 {} leavestep
{return 1} enterstep
{return 1} 2 1 leavestep
{factorial 1} 0 1 leave}

test trace-23.2 {recursive(2) trace execution: enter, leave, enterstep, leavestep} {
    set info {}
    trace add execution factorial {enter leave enterstep leavestep} [list traceExecute]
    factorial 2
    trace remove execution factorial {enter leave enterstep leavestep} [list traceExecute]
    join $info "\n"
} {{factorial 2} enter
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} enterstep
{expr {$n * [factorial [expr {$n -1 }]]}} enterstep
{expr {$n -1 }} enterstep
{expr {$n -1 }} 0 1 leavestep
{factorial 1} enterstep
{factorial 1} enter
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} enterstep
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} 0 {} leavestep
{return 1} enterstep
{return 1} 2 1 leavestep
{factorial 1} 0 1 leave
{factorial 1} 0 1 leavestep
{expr {$n * [factorial [expr {$n -1 }]]}} 0 2 leavestep
{return 2} enterstep
{return 2} 2 2 leavestep
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} 2 2 leavestep
{factorial 2} 0 2 leave}

test trace-23.3 {recursive(3) trace execution: enter, leave, enterstep, leavestep} {
    set info {}
    trace add execution factorial {enter leave enterstep leavestep} [list traceExecute]
    factorial 3
    trace remove execution factorial {enter leave enterstep leavestep} [list traceExecute]
    join $info "\n"
} {{factorial 3} enter
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} enterstep
{expr {$n * [factorial [expr {$n -1 }]]}} enterstep
{expr {$n -1 }} enterstep
{expr {$n -1 }} 0 2 leavestep
{factorial 2} enterstep
{factorial 2} enter
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} enterstep
{expr {$n * [factorial [expr {$n -1 }]]}} enterstep
{expr {$n -1 }} enterstep
{expr {$n -1 }} 0 1 leavestep
{factorial 1} enterstep
{factorial 1} enter
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} enterstep
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} 0 {} leavestep
{return 1} enterstep
{return 1} 2 1 leavestep
{factorial 1} 0 1 leave
{factorial 1} 0 1 leavestep
{expr {$n * [factorial [expr {$n -1 }]]}} 0 2 leavestep
{return 2} enterstep
{return 2} 2 2 leavestep
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} 2 2 leavestep
{factorial 2} 0 2 leave
{factorial 2} 0 2 leavestep
{expr {$n * [factorial [expr {$n -1 }]]}} 0 6 leavestep
{return 6} enterstep
{return 6} 2 6 leavestep
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} 2 6 leavestep
{factorial 3} 0 6 leave}
a979 5
proc traceDelete {cmd args} {
    eval trace remove execution $cmd [lindex [trace info execution $cmd] 0]
    global info
    set info $args
}
a980 6
test trace-24.1 {delete trace during enter trace} {
    set info {}
    trace add execution foo enter [list traceDelete foo]
    foo 1
    list $info [trace info execution foo]
} {{{foo 1} enter} {}}
a981 6
test trace-24.2 {delete trace during leave trace} {
    set info {}
    trace add execution foo leave [list traceDelete foo]
    foo 1
    list $info [trace info execution foo]
} {{{foo 1} 0 1 leave} {}}
a982 6
test trace-24.3 {delete trace during enter-leave trace} {
    set info {}
    trace add execution foo {enter leave} [list traceDelete foo]
    foo 1
    list $info [trace info execution foo]
} {{{foo 1} enter} {}}
a983 6
test trace-24.4 {delete trace during all exec traces} {
    set info {}
    trace add execution foo {enter leave enterstep leavestep} [list traceDelete foo]
    foo 1
    list $info [trace info execution foo]
} {{{foo 1} enter} {}}
a984 69
test trace-24.5 {delete trace during all exec traces except enter} {
    set info {}
    trace add execution foo {leave enterstep leavestep} [list traceDelete foo]
    foo 1
    list $info [trace info execution foo]
} {{{set b 1} enterstep} {}}

proc traceDelete {cmd args} {
    rename $cmd {}
    global info
    set info $args
}

proc foo {a} {
    set b $a
}

test trace-25.1 {delete command during enter trace} {
    set info {}
    trace add execution foo enter [list traceDelete foo]
    catch {foo 1} err
    list $err $info [trace info execution foo]
} {{invalid command name "foo"} {{foo 1} enter} {unknown command "foo"}}

proc foo {a} {
    set b $a
}

test trace-25.2 {delete command during leave trace} {
    set info {}
    trace add execution foo leave [list traceDelete foo]
    foo 1
    list $info [trace info execution foo]
} {{{foo 1} 0 1 leave} {unknown command "foo"}}

proc foo {a} {
    set b $a
}

test trace-25.3 {delete command during enter then leave trace} {
    set info {}
    trace add execution foo enter [list traceDelete foo]
    trace add execution foo leave [list traceDelete foo]
    catch {foo 1} err
    list $err $info [trace info execution foo]
} {{invalid command name "foo"} {{foo 1} enter} {unknown command "foo"}}

proc foo {a} {
    set b $a
}
proc traceExecute2 {args} {
    global info
    lappend info $args
}

# This shows the peculiar consequences of having two traces
# at the same time: as well as tracing the procedure you want
test trace-25.4 {order dependencies of two enter traces} {
    set info {}
    trace add execution foo enter [list traceExecute traceExecute]
    trace add execution foo enter [list traceExecute2 traceExecute2]
    catch {foo 1} err
    trace remove execution foo enter [list traceExecute traceExecute]
    trace remove execution foo enter [list traceExecute2 traceExecute2]
    join [list $err [join $info \n] [trace info execution foo]] "\n"
} {1
traceExecute2 {foo 1} enter
traceExecute {foo 1} enter
}
a985 149
test trace-25.5 {order dependencies of two step traces} {
    set info {}
    trace add execution foo enterstep [list traceExecute traceExecute]
    trace add execution foo enterstep [list traceExecute2 traceExecute2]
    catch {foo 1} err
    trace remove execution foo enterstep [list traceExecute traceExecute]
    trace remove execution foo enterstep [list traceExecute2 traceExecute2]
    join [list $err [join $info \n] [trace info execution foo]] "\n"
} {1
traceExecute2 {set b 1} enterstep
traceExecute {set b 1} enterstep
}

# We don't want the result string (5th argument), or the results
# will get unmanageable.
proc tracePostExecute {args} {
    global info
    lappend info [concat [lrange $args 0 2] [lindex $args 4]]
}
proc tracePostExecute2 {args} {
    global info
    lappend info [concat [lrange $args 0 2] [lindex $args 4]]
}

test trace-25.6 {order dependencies of two leave traces} {
    set info {}
    trace add execution foo leave [list tracePostExecute tracePostExecute]
    trace add execution foo leave [list tracePostExecute2 tracePostExecute2]
    catch {foo 1} err
    trace remove execution foo leave [list tracePostExecute tracePostExecute]
    trace remove execution foo leave [list tracePostExecute2 tracePostExecute2]
    join [list $err [join $info \n] [trace info execution foo]] "\n"
} {1
tracePostExecute {foo 1} 0 leave
tracePostExecute2 {foo 1} 0 leave
}

test trace-25.7 {order dependencies of two leavestep traces} {
    set info {}
    trace add execution foo leavestep [list tracePostExecute tracePostExecute]
    trace add execution foo leavestep [list tracePostExecute2 tracePostExecute2]
    catch {foo 1} err
    trace remove execution foo leavestep [list tracePostExecute tracePostExecute]
    trace remove execution foo leavestep [list tracePostExecute2 tracePostExecute2]
    join [list $err [join $info \n] [trace info execution foo]] "\n"
} {1
tracePostExecute {set b 1} 0 leavestep
tracePostExecute2 {set b 1} 0 leavestep
}

proc foo {a} {
    set b $a
}

proc traceDelete {cmd args} {
    rename $cmd {}
    global info
    set info $args
}

test trace-25.8 {delete command during enter leave and enter/leave-step traces} {
    set info {}
    trace add execution foo enter [list traceDelete foo]
    trace add execution foo leave [list traceDelete foo]
    trace add execution foo enterstep [list traceDelete foo]
    trace add execution foo leavestep [list traceDelete foo]
    catch {foo 1} err
    list $err $info [trace info execution foo]
} {{invalid command name "foo"} {{foo 1} enter} {unknown command "foo"}}

proc foo {a} {
    set b $a
}

test trace-25.9 {delete command during enter leave and leavestep traces} {
    set info {}
    trace add execution foo enter [list traceDelete foo]
    trace add execution foo leave [list traceDelete foo]
    trace add execution foo leavestep [list traceDelete foo]
    catch {foo 1} err
    list $err $info [trace info execution foo]
} {{invalid command name "foo"} {{foo 1} enter} {unknown command "foo"}}

proc foo {a} {
    set b $a
}

test trace-25.10 {delete command during leave and leavestep traces} {
    set info {}
    trace add execution foo leave [list traceDelete foo]
    trace add execution foo leavestep [list traceDelete foo]
    catch {foo 1} err
    list $err $info [trace info execution foo]
} {1 {{set b 1} 0 1 leavestep} {unknown command "foo"}}

proc foo {a} {
    set b $a
}

test trace-25.11 {delete command during enter and enterstep traces} {
    set info {}
    trace add execution foo enter [list traceDelete foo]
    trace add execution foo enterstep [list traceDelete foo]
    catch {foo 1} err
    list $err $info [trace info execution foo]
} {{invalid command name "foo"} {{foo 1} enter} {unknown command "foo"}}

test trace-26.1 {trace targetCmd when invoked through an alias} {
    proc foo {args} {
	set b $args
    }
    set info {}
    trace add execution foo enter [list traceExecute foo]
    interp alias {} bar {} foo 1
    bar 2
    trace remove execution foo enter [list traceExecute foo]
    set info
} {{foo {foo 1 2} enter}}
test trace-26.2 {trace targetCmd when invoked through an alias} {
    proc foo {args} {
	set b $args
    }
    set info {}
    trace add execution foo enter [list traceExecute foo]
    interp create child
    interp alias child bar {} foo 1
    child eval bar 2
    interp delete child
    trace remove execution foo enter [list traceExecute foo]
    set info
} {{foo {foo 1 2} enter}}

test trace-27.1 {memory leak in rename trace (604609)} {
    catch {rename bar {}}
    proc foo {} {error foo}
    trace add command foo rename {rename foo "" ;#}
    rename foo bar
    info commands foo
} {}

# Delete procedures when done, so we don't clash with other tests
# (e.g. foobar will clash with 'unknown' tests).
catch {rename foobar {}}
catch {rename foo {}}
catch {rename bar {}}

# cleanup
::tcltest::cleanupTests
return
@


1.2
log
@touched all Tcl files to ease next import.
@
text
@@


1.2.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.2.16.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@a54 15
proc traceCommand {oldName newName op} {
    global info
    set info [list $oldName $newName $op]
}

test trace-0.0 {memory corruption in trace (Tcl Bug 484339)} {
    # You may need Purify or Electric Fence to reliably
    # see this one fail.
    catch {unset z}
    trace add variable z array {set z(foo) 1 ;#}
    set res "names: [array names z]"
    catch {unset ::z}
    trace variable ::z w {unset ::z; error "memory corruption";#}
    list [catch {set ::z 1} msg] $msg
} {1 {can't set "::z": memory corruption}}
d61 1
a61 1
    trace add variable x read traceScalar
d63 1
a63 1
} {1 {can't read "x": no such variable} {x {} read 1 {can't read "x": no such variable}}}
d68 1
a68 1
    trace add variable x read traceScalar
d70 1
a70 1
} {0 123 {x {} read 0 123}}
d74 1
a74 1
    trace add variable x read traceScalar
d81 1
a81 1
    trace add variable x(2) read traceArray
d83 1
a83 1
} {1 {can't read "x(2)": no such element in array} {x 2 read 1 {can't read "x(2)": no such element in array}}}
d88 1
a88 1
    trace add variable x(2) read traceArray
d90 1
a90 1
} {0 zzz {x 2 read 0 zzz}}
d94 1
a94 1
    trace add variable x read traceArray2
d101 1
a101 1
} {0 willi {x 2 read}}
d105 1
a105 1
    trace add variable x read q
d118 1
a118 1
} {0 wolf {x Y read}}
d122 1
a122 1
    trace add variable x read traceArray
d129 1
a129 1
    trace add variable x read traceArray
d131 1
a131 1
} {0 zzz {x 2 read 0 zzz}}
d136 1
a136 1
    trace add variable x read traceScalar
a139 28
test trace-1.11 {read traces that modify the array structure} {
    catch {unset x}
    set x(bar) 0 
    trace variable x r {set x(foo) 1 ;#} 
    trace variable x r {unset -nocomplain x(bar) ;#} 
    array get x
} {}
test trace-1.12 {read traces that modify the array structure} {
    catch {unset x}
    set x(bar) 0 
    trace variable x r {unset -nocomplain x(bar) ;#} 
    trace variable x r {set x(foo) 1 ;#} 
    array get x
} {}
test trace-1.13 {read traces that modify the array structure} {
    catch {unset x}
    set x(bar) 0 
    trace variable x r {set x(foo) 1 ;#} 
    trace variable x r {unset -nocomplain x;#} 
    list [catch {array get x} res] $res
} {1 {can't read "x(bar)": no such variable}}
test trace-1.14 {read traces that modify the array structure} {
    catch {unset x}
    set x(bar) 0 
    trace variable x r {unset -nocomplain x;#} 
    trace variable x r {set x(foo) 1 ;#} 
    list [catch {array get x} res] $res
} {1 {can't read "x(bar)": no such variable}}
d146 1
a146 1
    trace add variable x write traceScalar
d149 1
a149 1
} {x {} write 0 123}
d153 1
a153 1
    trace add variable x(33) write traceArray
d156 1
a156 1
} {x 33 write 0 444}
d160 1
a160 1
    trace add variable x write traceArray
d163 1
a163 1
} {x abc write 0 qq}
d168 1
a168 1
    trace add variable x write traceScalar
d176 1
a176 1
    trace add variable x write traceScalar
d189 1
a189 1
    trace add variable x read traceScalarAppend
d194 1
a194 1
} {x {} read 0 123456}
d198 1
a198 1
    trace add variable x {read write} traceScalarAppend
d202 1
a202 1
} {x {} write 0 123 x {} read 0 123 x {} write 0 {123 456}}
d209 1
a209 1
    trace add variable x unset traceScalar
d212 1
a212 1
} {x {} unset 1 {can't read "x": no such variable}}
d217 1
a217 1
    trace add variable x unset traceScalar
d220 1
a220 1
} {x {} unset 1 {can't read "x": no such variable}}
d224 1
a224 1
    trace add variable x unset traceScalar
d233 1
a233 1
    trace add variable x(1) unset traceArray
d236 1
a236 1
} {x 1 unset 1 {can't read "x(1)": no such element in array}}
d241 1
a241 1
    trace add variable x(1) unset traceArray
d244 1
a244 1
} {x 1 unset 1 {can't read "x(1)": no such element in array}}
d249 1
a249 1
    trace add variable x(1) unset traceArray
d252 1
a252 1
} {x 1 unset 1 {can't read "x(1)": no such variable}}
d257 1
a257 1
    trace add variable x unset traceProc
d267 1
a267 1
    trace add variable x unset traceProc
d270 1
a270 1
} {x 1 unset}
d277 1
a277 1
    trace add variable x unset traceProc
d280 1
a280 1
} {x {} unset}
a281 60
# Array tracing on variables
test trace-5.1 {array traces fire on accesses via [array]} {
    catch {unset x}
    set x(b) 2
    trace add variable x array traceArray2
    set ::info {}
    array set x {a 1}
    set ::info
} {x {} array}
test trace-5.2 {array traces do not fire on normal accesses} {
    catch {unset x}
    set x(b) 2
    trace add variable x array traceArray2
    set ::info {}
    set x(a) 1
    set x(b) $x(a)
    set ::info
} {}
test trace-5.3 {array traces do not outlive variable} {
    catch {unset x}
    trace add variable x array traceArray2
    set ::info {}
    set x(a) 1
    unset x
    array set x {a 1}
    set ::info
} {}
test trace-5.4 {array traces properly listed in trace information} {
    catch {unset x}
    trace add variable x array traceArray2
    set result [trace info variable x]
    set result
} [list [list array traceArray2]]
test trace-5.5 {array traces properly listed in trace information} {
    catch {unset x}
    trace variable x a traceArray2
    set result [trace vinfo x]
    set result
} [list [list a traceArray2]]
test trace-5.6 {array traces don't fire on scalar variables} {
    catch {unset x}
    set x foo
    trace add variable x array traceArray2
    set ::info {}
    catch {array set x {a 1}}
    set ::info
} {}
test trace-5.7 {array traces fire for undefined variables} {
    catch {unset x}
    trace add variable x array traceArray2
    set ::info {}
    array set x {a 1}
    set ::info
} {x {} array}
test trace-5.8 {array traces fire for undefined variables} {
    catch {unset x}
    trace add variable x array {set x(foo) 1 ;#}
    set res "names: [array names x]"
} {names: foo}
    
d284 1
a284 1
test trace-6.1 {multiple ops traced at once} {
d287 1
a287 1
    trace add variable x {read write unset} traceProc
d294 2
a295 2
} {x {} read x {} write x {} read x {} write x {} unset}
test trace-6.2 {multiple ops traced on array element} {
d298 1
a298 1
    trace add variable x(0) {read write unset} traceProc
d306 2
a307 2
} {x 0 read x 0 write x 0 read x 0 write x 0 unset}
test trace-6.3 {multiple ops traced on whole array} {
d310 1
a310 1
    trace add variable x {read write unset} traceProc
d318 1
a318 1
} {x 0 write x 0 read x 0 write x 0 unset x {} unset}
d322 1
a322 1
test trace-7.1 {order of invocation of traces} {
d325 3
a327 3
    trace add variable x read "traceTag 1"
    trace add variable x read "traceTag 2"
    trace add variable x read "traceTag 3"
d333 1
a333 1
test trace-7.2 {order of invocation of traces} {
d337 3
a339 3
    trace add variable x(0) read "traceTag 1"
    trace add variable x(0) read "traceTag 2"
    trace add variable x(0) read "traceTag 3"
d343 1
a343 1
test trace-7.3 {order of invocation of traces} {
d347 6
a352 6
    trace add variable x(0) read "traceTag 1"
    trace add variable x read "traceTag A1"
    trace add variable x(0) read "traceTag 2"
    trace add variable x read "traceTag A2"
    trace add variable x(0) read "traceTag 3"
    trace add variable x read "traceTag A3"
d359 1
a359 1
test trace-8.1 {error returns from traces} {
d363 2
a364 2
    trace add variable x read "traceTag 1"
    trace add variable x read traceError
d367 1
a367 1
test trace-8.2 {error returns from traces} {
d371 2
a372 2
    trace add variable x write "traceTag 1"
    trace add variable x write traceError
d375 1
a375 1
test trace-8.3 {error returns from traces} {
d379 1
a379 1
    trace add variable x write traceError
d382 1
a382 1
test trace-8.4 {error returns from traces} {
d386 2
a387 2
    trace add variable x unset "traceTag 1"
    trace add variable x unset traceError
d390 1
a390 1
test trace-8.5 {error returns from traces} {
d394 4
a397 4
    trace add variable x(0) read "traceTag 1"
    trace add variable x read "traceTag 2"
    trace add variable x read traceError
    trace add variable x read "traceTag 3"
d400 1
a400 1
test trace-8.6 {error returns from traces} {
d403 1
a403 1
    trace add variable x unset traceError
d406 1
a406 1
test trace-8.7 {error returns from traces} {
d412 1
a412 1
    trace add variable x read traceError
d415 1
a415 23
    trace remove variable x read traceError
} {}
test trace-8.8 {error returns from traces} {
    # Yet more elaborate memory corruption testing that checks nothing
    # bad happens when the trace deletes itself and installs something
    # new.  Alas, there is no neat way to guarantee that this test will
    # fail if there is a problem, but that's life and with the new code
    # it should *never* fail.
    #
    # Adapted from Bug #219393 reported by Don Porter.
    catch {rename ::foo {}}
    proc foo {old args} {
	trace remove variable ::x write [list foo $old]
	trace add    variable ::x write [list foo $::x]
	error "foo"
    }
    catch {unset ::x ::y}
    set x junk
    trace add variable ::x write [list foo $x]
    for {set y 0} {$y<100} {incr y} {
	catch {set x junk}
    }
    unset x
d422 1
a422 1
test trace-9.1 {be sure variable is unset before trace is called} {
d426 1
a426 1
    trace add variable x unset {traceCheck {uplevel set x}}
d430 1
a430 1
test trace-9.2 {be sure variable is unset before trace is called} {
d434 1
a434 1
    trace add variable x unset {traceCheck {uplevel set x 22}}
d438 1
a438 1
test trace-9.3 {be sure traces are cleared before unset trace called} {
d442 1
a442 1
    trace add variable x unset {traceCheck {uplevel trace info variable x}}
d446 1
a446 1
test trace-9.4 {set new trace during unset trace} {
d450 1
a450 1
    trace add variable x unset {traceCheck {global x; trace add variable x unset traceProc}}
d452 2
a453 2
    concat $info [trace info variable x]
} {0 {} {unset traceProc}}
d455 1
a455 1
test trace-10.1 {make sure array elements are unset before traces are called} {
d459 1
a459 1
    trace add variable x(0) unset {traceCheck {uplevel set x(0)}}
d463 1
a463 1
test trace-10.2 {make sure array elements are unset before traces are called} {
d467 1
a467 1
    trace add variable x(0) unset {traceCheck {uplevel set x(0) zzz}}
d471 1
a471 1
test trace-10.3 {array elements are unset before traces are called} {
d475 1
a475 1
    trace add variable x(0) unset {traceCheck {global x; trace info variable x(0)}}
d479 1
a479 1
test trace-10.4 {set new array element trace during unset trace} {
d483 1
a483 1
    trace add variable x(0) unset {traceCheck {uplevel {trace add variable x(0) read {}}}}
d485 2
a486 2
    concat $info [trace info variable x(0)]
} {0 {} {read {}}}
d488 1
a488 1
test trace-11.1 {make sure arrays are unset before traces are called} {
d492 1
a492 1
    trace add variable x unset {traceCheck {uplevel set x(0)}}
d496 1
a496 1
test trace-11.2 {make sure arrays are unset before traces are called} {
d500 1
a500 1
    trace add variable x unset {traceCheck {uplevel set x(y) 22}}
d504 1
a504 1
test trace-11.3 {make sure arrays are unset before traces are called} {
d508 1
a508 1
    trace add variable x unset {traceCheck {uplevel array exists x}}
d512 1
a512 1
test trace-11.4 {make sure arrays are unset before traces are called} {
d516 2
a517 2
    set cmd {traceCheck {uplevel {trace info variable x}}}
    trace add variable x unset $cmd
d521 1
a521 1
test trace-11.5 {set new array trace during unset trace} {
d525 1
a525 1
    trace add variable x unset {traceCheck {global x; trace add variable x read {}}}
d527 3
a529 3
    concat $info [trace info variable x]
} {0 {} {read {}}}
test trace-11.6 {create scalar during array unset trace} {
d533 1
a533 1
    trace add variable x unset {traceCheck {global x; set x 44}}
d540 1
a540 1
test trace-12.1 {creating array when setting variable traces} {
d543 1
a543 1
    trace add variable x(0) write traceProc
d546 1
a546 1
test trace-12.2 {creating array when setting variable traces} {
d549 1
a549 1
    trace add variable x(0) write traceProc
d552 1
a552 1
test trace-12.3 {creating array when setting variable traces} {
d555 1
a555 1
    trace add variable x(0) write traceProc
d558 2
a559 2
} {x 0 write}
test trace-12.4 {creating variable when setting variable traces} {
d562 1
a562 1
    trace add variable x write traceProc
d565 1
a565 1
test trace-12.5 {creating variable when setting variable traces} {
d568 1
a568 1
    trace add variable x write traceProc
d571 2
a572 2
} {x {} write}
test trace-12.6 {creating variable when setting variable traces} {
d575 1
a575 1
    trace add variable x write traceProc
d578 2
a579 2
} {x 0 write}
test trace-12.7 {create array element during read trace} {
d582 1
a582 1
    trace add variable x read {traceCrtElement xyzzy}
d585 1
a585 1
test trace-12.8 {errors when setting variable traces} {
d588 1
a588 1
    list [catch {trace add variable x(0) write traceProc} msg] $msg
d593 1
a593 1
test trace-13.1 {delete one trace from another} {
d596 3
a598 3
	trace remove variable x read {traceTag 2}
	trace remove variable x read {traceTag 3}
	trace remove variable x read {traceTag 4}
d603 6
a608 6
    trace add variable x read {traceTag 1}
    trace add variable x read {traceTag 2}
    trace add variable x read {traceTag 3}
    trace add variable x read {traceTag 4}
    trace add variable x read delTraces 
    trace add variable x read {traceTag 5}
d615 1
a615 33
# Syntax for adding/removing variable and command traces is basically the
# same:
#	trace add variable name opList command
#	trace remove variable name opList command
#
# The following loops just get all the common "wrong # args" tests done.

set i 0
set start "wrong # args:"
foreach type {variable command} {
    foreach op {add remove} {
	test trace-14.0.[incr i] "trace command, wrong # args errors" {
	    list [catch {trace $op $type} msg] $msg
	} [list 1 "$start should be \"trace $op $type name opList command\""]
	test trace-14.0.[incr i] "trace command wrong # args errors" {
	    list [catch {trace $op $type foo} msg] $msg
	} [list 1 "$start should be \"trace $op $type name opList command\""]
	test trace-14.0.[incr i] "trace command, wrong # args errors" {
	    list [catch {trace $op $type foo bar} msg] $msg
	} [list 1 "$start should be \"trace $op $type name opList command\""]
	test trace-14.0.[incr i] "trace command, wrong # args errors" {
	    list [catch {trace $op $type foo bar baz boo} msg] $msg
	} [list 1 "$start should be \"trace $op $type name opList command\""]
    }
    test trace-14.0.[incr i] "trace command, wrong # args errors" {
	list [catch {trace info $type foo bar} msg] $msg
    } [list 1 "$start should be \"trace info $type name\""]
    test trace-14.0.[incr i] "trace command, wrong # args errors" {
	list [catch {trace info $type} msg] $msg
    } [list 1 "$start should be \"trace info $type name\""]
}

test trace-14.1 "trace command, wrong # args errors" {
d617 2
a618 12
} [list 1 "wrong # args: should be \"trace option ?arg arg ...?\""]
test trace-14.2 "trace command, wrong # args errors" {
    list [catch {trace add} msg] $msg
} [list 1 "wrong # args: should be \"trace add type ?arg arg ...?\""]
test trace-14.3 "trace command, wrong # args errors" {
    list [catch {trace remove} msg] $msg
} [list 1 "wrong # args: should be \"trace remove type ?arg arg ...?\""]
test trace-14.4 "trace command, wrong # args errors" {
    list [catch {trace info} msg] $msg
} [list 1 "wrong # args: should be \"trace info type ?arg arg ...?\""]

test trace-14.5 {trace command, invalid option} {
d620 2
a621 34
} [list 1 "bad option \"gorp\": must be add, info, remove, variable, vdelete, or vinfo"]

# Again, [trace ... command] and [trace ... variable] share syntax and
# error message styles for their opList options; these loops test those 
# error messages.

set i 0
set errs [list "array, read, unset, or write" "delete or rename" "enter, leave, enterstep, or leavestep"]
set abbvs [list {a r u w} {d r} {}]
proc x {} {}
foreach type {variable command execution} err $errs abbvlist $abbvs {
    foreach op {add remove} {
	test trace-14.6.[incr i] "trace $op $type errors" {
	    list [catch {trace $op $type x {y z w} a} msg] $msg
	} [list 1 "bad operation \"y\": must be $err"]
	foreach abbv $abbvlist {
	    test trace-14.6.[incr i] "trace $op $type rejects abbreviations" {
		list [catch {trace $op $type x $abbv a} msg] $msg
	    } [list 1 "bad operation \"$abbv\": must be $err"]
	}
	test trace-14.6.[incr i] "trace $op $type rejects null opList" {
	    list [catch {trace $op $type x {} a} msg] $msg
	} [list 1 "bad operation list \"\": must be one or more of $err"]
    }
}
rename x {}

test trace-14.7 {trace command, "trace variable" errors} {
    list [catch {trace variable} msg] $msg
} [list 1 "wrong # args: should be \"trace variable name ops command\""]
test trace-14.8 {trace command, "trace variable" errors} {
    list [catch {trace variable x} msg] $msg
} [list 1 "wrong # args: should be \"trace variable name ops command\""]
test trace-14.9 {trace command, "trace variable" errors} {
d623 17
a639 10
} [list 1 "wrong # args: should be \"trace variable name ops command\""]
test trace-14.10 {trace command, "trace variable" errors} {
    list [catch {trace variable x y z w} msg] $msg
} [list 1 "wrong # args: should be \"trace variable name ops command\""]
test trace-14.11 {trace command, "trace variable" errors} {
    list [catch {trace variable x y z} msg] $msg
} [list 1 "bad operations \"y\": should be one or more of rwua"]


test trace-14.9 {trace command ("remove variable" option)} {
d642 2
a643 2
    trace add variable x write traceProc
    trace remove variable x write traceProc
d645 1
a645 1
test trace-14.10 {trace command ("remove variable" option)} {
d648 2
a649 2
    trace add variable x write traceProc
    trace remove variable x write traceProc
d653 1
a653 1
test trace-14.11 {trace command ("remove variable" option)} {
d656 3
a658 3
    trace add variable x write {traceTag 1}
    trace add variable x write traceProc
    trace add variable x write {traceTag 2}
d660 1
a660 1
    trace remove variable x write traceProc
d662 1
a662 1
    trace remove variable x write {traceTag 1}
d664 1
a664 1
    trace remove variable x write {traceTag 2}
d667 2
a668 2
} {2 x {} write 1 2 1 2}
test trace-14.12 {trace command ("remove variable" option)} {
d671 2
a672 2
    trace add variable x write {traceTag 1}
    trace remove variable x write non_existent
d676 14
a689 8
test trace-14.15 {trace command ("list variable" option)} {
    catch {unset x}
    trace add variable x write {traceTag 1}
    trace add variable x write traceProc
    trace add variable x write {traceTag 2}
    trace info variable x
} {{write {traceTag 2}} {write traceProc} {write {traceTag 1}}}
test trace-14.16 {trace command ("list variable" option)} {
d691 1
a691 1
    trace info variable x
d693 1
a693 1
test trace-14.17 {trace command ("list variable" option)} {
d695 1
a695 1
    trace info variable x(0)
d697 1
a697 1
test trace-14.18 {trace command ("list variable" option)} {
d700 1
a700 1
    trace info variable x(0)
d702 1
a702 1
test trace-14.19 {trace command ("list variable" option)} {
d705 2
a706 2
    trace add variable x write {traceTag 1}
    proc check {} {global x; trace info variable x}
d708 1
a708 1
} {{write {traceTag 1}}}
d712 1
a712 1
test trace-15.1 {long trace command} {
d715 1
a715 1
    trace add variable x write {traceTag {This is a very very long argument.  It's \
d727 1
a727 1
test trace-15.2 {long trace command result to ignore} {
d732 1
a732 1
    trace add variable x write longResult
d737 1
a737 1
test trace-15.3 {special list-handling in trace commands} {
d741 1
a741 1
    trace add variable "x y z(a\n\{)" write traceProc
d744 1
a744 1
} "{x y z} a\\n\\\{ write"
d768 1
a768 1
test trace-16.1 {unsets during read traces} {
d772 2
a773 2
    trace add variable y read {traceUnset y}
    trace add variable y unset {traceAppend unset}
d776 1
a776 1
test trace-16.2 {unsets during read traces} {
d780 1
a780 1
    trace add variable y(0) read {traceUnset y(0)}
d783 1
a783 1
test trace-16.3 {unsets during read traces} {
d787 1
a787 1
    trace add variable y(0) read {traceUnset y}
d790 1
a790 1
test trace-16.4 {unsets during read traces} {
d794 1
a794 1
    trace add variable y read {traceReset y y}
d797 1
a797 1
test trace-16.5 {unsets during read traces} {
d801 1
a801 1
    trace add variable y(0) read {traceReset y(0) y(0)}
d804 1
a804 1
test trace-16.6 {unsets during read traces} {
d808 1
a808 1
    trace add variable y(0) read {traceReset y y(0)}
d811 1
a811 1
test trace-16.7 {unsets during read traces} {
d815 1
a815 1
    trace add variable y(0) read {traceReset2 y y(0)}
d818 1
a818 1
test trace-16.8 {unsets during write traces} {
d822 2
a823 2
    trace add variable y write {traceUnset y}
    trace add variable y unset {traceAppend unset}
d826 1
a826 1
test trace-16.9 {unsets during write traces} {
d830 1
a830 1
    trace add variable y(0) write {traceUnset y(0)}
d833 1
a833 1
test trace-16.10 {unsets during write traces} {
d837 1
a837 1
    trace add variable y(0) write {traceUnset y}
d840 1
a840 1
test trace-16.11 {unsets during write traces} {
d844 1
a844 1
    trace add variable y write {traceReset y y}
d847 1
a847 1
test trace-16.12 {unsets during write traces} {
d851 1
a851 1
    trace add variable y(0) write {traceReset y(0) y(0)}
d854 1
a854 1
test trace-16.13 {unsets during write traces} {
d858 1
a858 1
    trace add variable y(0) write {traceReset y y(0)}
d861 1
a861 1
test trace-16.14 {unsets during write traces} {
d865 1
a865 1
    trace add variable y(0) write {traceReset2 y y(0)}
d868 1
a868 1
test trace-16.15 {unsets during unset traces} {
d872 1
a872 1
    trace add variable y unset {traceUnset y}
d875 1
a875 1
test trace-16.16 {unsets during unset traces} {
d879 1
a879 1
    trace add variable y(0) unset {traceUnset y(0)}
d882 1
a882 1
test trace-16.17 {unsets during unset traces} {
d886 1
a886 1
    trace add variable y(0) unset {traceUnset y}
d889 1
a889 1
test trace-16.18 {unsets during unset traces} {
d893 1
a893 1
    trace add variable y unset {traceReset2 y y}
d896 1
a896 1
test trace-16.19 {unsets during unset traces} {
d900 1
a900 1
    trace add variable y(0) unset {traceReset2 y(0) y(0)}
d903 1
a903 1
test trace-16.20 {unsets during unset traces} {
d907 1
a907 1
    trace add variable y(0) unset {traceReset2 y y(0)}
d910 1
a910 1
test trace-16.21 {unsets cancelling traces} {
d914 4
a917 4
    trace add variable y read {traceAppend first}
    trace add variable y read {traceUnset y}
    trace add variable y read {traceAppend third}
    trace add variable y unset {traceAppend unset}
d920 1
a920 1
test trace-16.22 {unsets cancelling traces} {
d924 4
a927 4
    trace add variable y(0) read {traceAppend first}
    trace add variable y(0) read {traceUnset y}
    trace add variable y(0) read {traceAppend third}
    trace add variable y(0) unset {traceAppend unset}
d933 1
a933 1
test trace-17.1 {trace doesn't prevent unset errors} {
d936 1
a936 1
    trace add variable x unset {traceProc}
d938 2
a939 2
} {1 {can't unset "x": no such variable} {x {} unset}}
test trace-17.2 {traced variables must survive procedure exits} {
d941 1
a941 1
    proc p1 {} {global x; trace add variable x write traceProc}
d943 3
a945 3
    trace info variable x
} {{write traceProc}}
test trace-17.3 {traced variables must survive procedure exits} {
d948 1
a948 1
    proc p1 {} {global x; trace add variable x write traceProc}
d952 1
a952 1
} {x {} write}
d957 1
a957 1
test trace-18.1 {unset traces on procedure returns} {
d959 1
a959 1
    proc p2 {z} {trace add variable z unset {traceCheck {lsort [uplevel {info vars}]}}}
a963 11
test trace-18.2 {namespace delete / trace vdelete combo} {
    namespace eval ::foo {
	variable x 123
    }
    proc p1 args {
	trace vdelete ::foo::x u p1
    }
    trace variable ::foo::x u p1
    namespace delete ::foo
    info exists ::foo::x
} 0
d971 3
a973 448
test trace-18.2 {trace add command (command existence)} {
    # Just in case!
    catch {rename nosuchname ""}
    list [catch {trace add command nosuchname rename traceCommand} msg] $msg
} {1 {unknown command "nosuchname"}}
test trace-18.3 {trace add command (command existence in ns)} {
    list [catch {trace add command nosuchns::nosuchname rename traceCommand} msg] $msg
} {1 {unknown command "nosuchns::nosuchname"}}


test trace-19.1 {trace add command (rename option)} {
    proc foo {} {}
    catch {rename bar {}}
    trace add command foo rename traceCommand
    rename foo bar
    set info
} {foo bar rename}
test trace-19.2 {traces stick with renamed commands} {
    proc foo {} {}
    catch {rename bar {}}
    trace add command foo rename traceCommand
    rename foo bar
    rename bar foo
    set info
} {bar foo rename}
test trace-19.2.1 {trace add command rename trace exists} {
    proc foo {} {}
    trace add command foo rename traceCommand
    trace info command foo
} {{rename traceCommand}}
test trace-19.3 {command rename traces don't fire on command deletion} {
    proc foo {} {}
    set info {}
    trace add command foo rename traceCommand
    rename foo {}
    set info
} {}
test trace-19.4 {trace add command rename doesn't trace recreated commands} {
    proc foo {} {}
    catch {rename bar {}}
    trace add command foo rename traceCommand
    proc foo {} {}
    rename foo bar
    set info
} {}
test trace-19.5 {trace add command deleted removes traces} {
    proc foo {} {}
    trace add command foo rename traceCommand
    proc foo {} {}
    trace info command foo
} {}

namespace eval tc {}
proc tc::tcfoo {} {}
test trace-19.6 {trace add command rename in namespace} {
    trace add command tc::tcfoo rename traceCommand
    rename tc::tcfoo tc::tcbar
    set info
} {tc::tcfoo tc::tcbar rename}
test trace-19.7 {trace add command rename in namespace back again} {
    rename tc::tcbar tc::tcfoo
    set info
} {tc::tcbar tc::tcfoo rename}
test trace-19.8 {trace add command rename in namespace to out of namespace} {
    rename tc::tcfoo tcbar
    set info
} {tc::tcfoo tcbar rename}
test trace-19.9 {trace add command rename back into namespace} {
    rename tcbar tc::tcfoo
    set info
} {tcbar tc::tcfoo rename}
test trace-19.10 {trace add command failed rename doesn't trigger trace} {
    set info {}
    proc foo {} {}
    proc bar {} {}
    trace add command foo {rename delete} traceCommand
    catch {rename foo bar}
    set info
} {}
catch {rename foo {}}
catch {rename bar {}}

# Make sure it exists again
proc foo {} {}

test trace-20.1 {trace add command (delete option)} {
    trace add command foo delete traceCommand
    rename foo ""
    set info
} {::foo {} delete}
test trace-20.2 {trace add command delete doesn't trace recreated commands} {
    set info {}
    proc foo {} {}
    rename foo ""
    set info
} {}
test trace-20.2.1 {trace add command delete trace info} {
    proc foo {} {}
    trace add command foo delete traceCommand
    trace info command foo
} {{delete traceCommand}}
test trace-20.3 {trace add command implicit delete} {
    proc foo {} {}
    trace add command foo delete traceCommand
    proc foo {} {}
    set info
} {::foo {} delete}
test trace-20.3.1 {trace add command delete trace info} {
    proc foo {} {}
    trace info command foo
} {}
test trace-20.4 {trace add command rename followed by delete} {
    set infotemp {}
    proc foo {} {}
    trace add command foo {rename delete} traceCommand
    rename foo bar
    lappend infotemp $info
    rename bar {}
    lappend infotemp $info
    set info $infotemp
    unset infotemp
    set info
} {{foo bar rename} {::bar {} delete}}
catch {rename foo {}}
catch {rename bar {}}

test trace-20.5 {trace add command rename and delete} {
    set infotemp {}
    set info {}
    proc foo {} {}
    trace add command foo {rename delete} traceCommand
    rename foo bar
    lappend infotemp $info
    rename bar {}
    lappend infotemp $info
    set info $infotemp
    unset infotemp
    set info
} {{foo bar rename} {::bar {} delete}}

test trace-20.6 {trace add command rename and delete in subinterp} {
    set tc [interp create]
    foreach p {traceCommand} {
	$tc eval [list proc $p [info args $p] [info body $p]]
    }
    $tc eval [list set infotemp {}]
    $tc eval [list set info {}]
    $tc eval [list proc foo {} {}]
    $tc eval [list trace add command foo {rename delete} traceCommand]
    $tc eval [list rename foo bar]
    $tc eval {lappend infotemp $info}
    $tc eval [list rename bar {}]
    $tc eval {lappend infotemp $info}
    $tc eval {set info $infotemp}
    $tc eval [list unset infotemp]
    set info [$tc eval [list set info]]
    interp delete $tc
    set info
} {{foo bar rename} {::bar {} delete}}

# I'd like it if this test could give 'foo {} d' as a result,
# but interp deletion means there is no interp to evaluate
# the trace in.
test trace-20.7 {trace add command delete in subinterp while being deleted} {
    set info {}
    set tc [interp create]
    interp alias $tc traceCommand {} traceCommand
    $tc eval [list proc foo {} {}]
    $tc eval [list trace add command foo {rename delete} traceCommand]
    interp delete $tc
    set info
} {}

proc traceDelete {cmd old new op} {
    eval trace remove command $cmd [lindex [trace info command $cmd] 0]
    global info
    set info [list $old $new $op]
}
proc traceCmdrename {cmd old new op} {
    rename $old someothername
}
proc traceCmddelete {cmd old new op} {
    rename $old ""
}
test trace-20.8 {trace delete while trace is active} {
    set info {}
    proc foo {} {}
    catch {rename bar {}}
    trace add command foo {rename delete} [list traceDelete foo]
    rename foo bar
    list [set info] [trace info command bar]
} {{foo bar rename} {}}

test trace-20.9 {rename trace deletes command} {
    set info {}
    proc foo {} {}
    catch {rename bar {}}
    catch {rename someothername {}}
    trace add command foo rename [list traceCmddelete foo]
    rename foo bar
    list [info commands foo] [info commands bar] [info commands someothername]
} {{} {} {}}

test trace-20.10 {rename trace renames command} {
    set info {}
    proc foo {} {}
    catch {rename bar {}}
    catch {rename someothername {}}
    trace add command foo rename [list traceCmdrename foo]
    rename foo bar
    set info [list [info commands foo] [info commands bar] [info commands someothername]]
    rename someothername {}
    set info
} {{} {} someothername}

test trace-20.11 {delete trace deletes command} {
    set info {}
    proc foo {} {}
    catch {rename bar {}}
    catch {rename someothername {}}
    trace add command foo delete [list traceCmddelete foo]
    rename foo {}
    list [info commands foo] [info commands bar] [info commands someothername]
} {{} {} {}}

test trace-20.12 {delete trace renames command} {
    set info {}
    proc foo {} {}
    catch {rename bar {}}
    catch {rename someothername {}}
    trace add command foo delete [list traceCmdrename foo]
    rename foo bar
    rename bar {}
    # None of these should exist.
    list [info commands foo] [info commands bar] [info commands someothername]
} {{} {} {}}

proc foo {b} { set a $b }


# Delete arrays when done, so they can be re-used as scalars
# elsewhere.

catch {unset x}
catch {unset y}

# Delete procedures when done, so we don't clash with other tests
# (e.g. foobar will clash with 'unknown' tests).
catch {rename foobar {}}
catch {rename foo {}}
catch {rename bar {}}

proc foo {a} {
    set b $a
}

proc traceExecute {args} {
    global info
    lappend info $args
}

test trace-21.1 {trace execution: enter} {
    set info {}
    trace add execution foo enter [list traceExecute foo]
    foo 1
    trace remove execution foo enter [list traceExecute foo]
    set info
} {{foo {foo 1} enter}}

test trace-21.2 {trace exeuction: leave} {
    set info {}
    trace add execution foo leave [list traceExecute foo]
    foo 2
    trace remove execution foo leave [list traceExecute foo]
    set info
} {{foo {foo 2} 0 2 leave}}

test trace-21.3 {trace exeuction: enter, leave} {
    set info {}
    trace add execution foo {enter leave} [list traceExecute foo]
    foo 3
    trace remove execution foo {enter leave} [list traceExecute foo]
    set info
} {{foo {foo 3} enter} {foo {foo 3} 0 3 leave}}

test trace-21.4 {trace execution: enter, leave, enterstep} {
    set info {}
    trace add execution foo {enter leave enterstep} [list traceExecute foo]
    foo 3
    trace remove execution foo {enter leave enterstep} [list traceExecute foo]
    set info
} {{foo {foo 3} enter} {foo {set b 3} enterstep} {foo {foo 3} 0 3 leave}}

test trace-21.5 {trace execution: enter, leave, enterstep, leavestep} {
    set info {}
    trace add execution foo {enter leave enterstep leavestep} [list traceExecute foo]
    foo 3
    trace remove execution foo {enter leave enterstep leavestep} [list traceExecute foo]
    set info
} {{foo {foo 3} enter} {foo {set b 3} enterstep} {foo {set b 3} 0 3 leavestep} {foo {foo 3} 0 3 leave}}

test trace-21.6 {trace execution: enterstep, leavestep} {
    set info {}
    trace add execution foo {enterstep leavestep} [list traceExecute foo]
    foo 3
    trace remove execution foo {enterstep leavestep} [list traceExecute foo]
    set info
} {{foo {set b 3} enterstep} {foo {set b 3} 0 3 leavestep}}

test trace-21.7 {trace execution: enterstep} {
    set info {}
    trace add execution foo {enterstep} [list traceExecute foo]
    foo 3
    trace remove execution foo {enterstep} [list traceExecute foo]
    set info
} {{foo {set b 3} enterstep}}

test trace-21.8 {trace execution: leavestep} {
    set info {}
    trace add execution foo {leavestep} [list traceExecute foo]
    foo 3
    trace remove execution foo {leavestep} [list traceExecute foo]
    set info
} {{foo {set b 3} 0 3 leavestep}}

proc factorial {n} {
    if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }
    return 1
}

test trace-22.1 {recursive(1) trace execution: enter} {
    set info {}
    trace add execution factorial {enter} [list traceExecute factorial]
    factorial 1
    trace remove execution factorial {enter} [list traceExecute factorial]
    set info
} {{factorial {factorial 1} enter}}

test trace-22.2 {recursive(2) trace execution: enter} {
    set info {}
    trace add execution factorial {enter} [list traceExecute factorial]
    factorial 2
    trace remove execution factorial {enter} [list traceExecute factorial]
    set info
} {{factorial {factorial 2} enter} {factorial {factorial 1} enter}}

test trace-22.3 {recursive(3) trace execution: enter} {
    set info {}
    trace add execution factorial {enter} [list traceExecute factorial]
    factorial 3
    trace remove execution factorial {enter} [list traceExecute factorial]
    set info
} {{factorial {factorial 3} enter} {factorial {factorial 2} enter} {factorial {factorial 1} enter}}

test trace-23.1 {recursive(1) trace execution: enter, leave, enterstep, leavestep} {
    set info {}
    trace add execution factorial {enter leave enterstep leavestep} [list traceExecute]
    factorial 1
    trace remove execution factorial {enter leave enterstep leavestep} [list traceExecute]
    join $info "\n"
} {{factorial 1} enter
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} enterstep
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} 0 {} leavestep
{return 1} enterstep
{return 1} 2 1 leavestep
{factorial 1} 0 1 leave}

test trace-23.2 {recursive(2) trace execution: enter, leave, enterstep, leavestep} {
    set info {}
    trace add execution factorial {enter leave enterstep leavestep} [list traceExecute]
    factorial 2
    trace remove execution factorial {enter leave enterstep leavestep} [list traceExecute]
    join $info "\n"
} {{factorial 2} enter
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} enterstep
{expr {$n * [factorial [expr {$n -1 }]]}} enterstep
{expr {$n -1 }} enterstep
{expr {$n -1 }} 0 1 leavestep
{factorial 1} enterstep
{factorial 1} enter
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} enterstep
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} 0 {} leavestep
{return 1} enterstep
{return 1} 2 1 leavestep
{factorial 1} 0 1 leave
{factorial 1} 0 1 leavestep
{expr {$n * [factorial [expr {$n -1 }]]}} 0 2 leavestep
{return 2} enterstep
{return 2} 2 2 leavestep
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} 2 2 leavestep
{factorial 2} 0 2 leave}

test trace-23.3 {recursive(3) trace execution: enter, leave, enterstep, leavestep} {
    set info {}
    trace add execution factorial {enter leave enterstep leavestep} [list traceExecute]
    factorial 3
    trace remove execution factorial {enter leave enterstep leavestep} [list traceExecute]
    join $info "\n"
} {{factorial 3} enter
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} enterstep
{expr {$n * [factorial [expr {$n -1 }]]}} enterstep
{expr {$n -1 }} enterstep
{expr {$n -1 }} 0 2 leavestep
{factorial 2} enterstep
{factorial 2} enter
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} enterstep
{expr {$n * [factorial [expr {$n -1 }]]}} enterstep
{expr {$n -1 }} enterstep
{expr {$n -1 }} 0 1 leavestep
{factorial 1} enterstep
{factorial 1} enter
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} enterstep
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} 0 {} leavestep
{return 1} enterstep
{return 1} 2 1 leavestep
{factorial 1} 0 1 leave
{factorial 1} 0 1 leavestep
{expr {$n * [factorial [expr {$n -1 }]]}} 0 2 leavestep
{return 2} enterstep
{return 2} 2 2 leavestep
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} 2 2 leavestep
{factorial 2} 0 2 leave
{factorial 2} 0 2 leavestep
{expr {$n * [factorial [expr {$n -1 }]]}} 0 6 leavestep
{return 6} enterstep
{return 6} 2 6 leavestep
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} 2 6 leavestep
{factorial 3} 0 6 leave}

proc traceDelete {cmd args} {
    eval trace remove execution $cmd [lindex [trace info execution $cmd] 0]
    global info
    set info $args
}

test trace-24.1 {delete trace during enter trace} {
    set info {}
    trace add execution foo enter [list traceDelete foo]
    foo 1
    list $info [trace info execution foo]
} {{{foo 1} enter} {}}

test trace-24.2 {delete trace during leave trace} {
    set info {}
    trace add execution foo leave [list traceDelete foo]
    foo 1
    list $info [trace info execution foo]
} {{{foo 1} 0 1 leave} {}}
a974 6
test trace-24.3 {delete trace during enter-leave trace} {
    set info {}
    trace add execution foo {enter leave} [list traceDelete foo]
    foo 1
    list $info [trace info execution foo]
} {{{foo 1} enter} {}}
a975 6
test trace-24.4 {delete trace during all exec traces} {
    set info {}
    trace add execution foo {enter leave enterstep leavestep} [list traceDelete foo]
    foo 1
    list $info [trace info execution foo]
} {{{foo 1} enter} {}}
a976 16
test trace-24.5 {delete trace during all exec traces except enter} {
    set info {}
    trace add execution foo {leave enterstep leavestep} [list traceDelete foo]
    foo 1
    list $info [trace info execution foo]
} {{{set b 1} enterstep} {}}

proc traceDelete {cmd args} {
    rename $cmd {}
    global info
    set info $args
}

proc foo {a} {
    set b $a
}
a977 6
test trace-25.1 {delete command during enter trace} {
    set info {}
    trace add execution foo enter [list traceDelete foo]
    catch {foo 1} err
    list $err $info [trace info execution foo]
} {{invalid command name "foo"} {{foo 1} enter} {unknown command "foo"}}
a978 3
proc foo {a} {
    set b $a
}
a979 6
test trace-25.2 {delete command during leave trace} {
    set info {}
    trace add execution foo leave [list traceDelete foo]
    foo 1
    list $info [trace info execution foo]
} {{{foo 1} 0 1 leave} {unknown command "foo"}}
a980 3
proc foo {a} {
    set b $a
}
a981 7
test trace-25.3 {delete command during enter then leave trace} {
    set info {}
    trace add execution foo enter [list traceDelete foo]
    trace add execution foo leave [list traceDelete foo]
    catch {foo 1} err
    list $err $info [trace info execution foo]
} {{invalid command name "foo"} {{foo 1} enter} {unknown command "foo"}}
a982 7
proc foo {a} {
    set b $a
}
proc traceExecute2 {args} {
    global info
    lappend info $args
}
a983 14
# This shows the peculiar consequences of having two traces
# at the same time: as well as tracing the procedure you want
test trace-25.4 {order dependencies of two enter traces} {
    set info {}
    trace add execution foo enter [list traceExecute traceExecute]
    trace add execution foo enter [list traceExecute2 traceExecute2]
    catch {foo 1} err
    trace remove execution foo enter [list traceExecute traceExecute]
    trace remove execution foo enter [list traceExecute2 traceExecute2]
    join [list $err [join $info \n] [trace info execution foo]] "\n"
} {1
traceExecute2 {foo 1} enter
traceExecute {foo 1} enter
}
a984 12
test trace-25.5 {order dependencies of two step traces} {
    set info {}
    trace add execution foo enterstep [list traceExecute traceExecute]
    trace add execution foo enterstep [list traceExecute2 traceExecute2]
    catch {foo 1} err
    trace remove execution foo enterstep [list traceExecute traceExecute]
    trace remove execution foo enterstep [list traceExecute2 traceExecute2]
    join [list $err [join $info \n] [trace info execution foo]] "\n"
} {1
traceExecute2 {set b 1} enterstep
traceExecute {set b 1} enterstep
}
a985 169
# We don't want the result string (5th argument), or the results
# will get unmanageable.
proc tracePostExecute {args} {
    global info
    lappend info [concat [lrange $args 0 2] [lindex $args 4]]
}
proc tracePostExecute2 {args} {
    global info
    lappend info [concat [lrange $args 0 2] [lindex $args 4]]
}

test trace-25.6 {order dependencies of two leave traces} {
    set info {}
    trace add execution foo leave [list tracePostExecute tracePostExecute]
    trace add execution foo leave [list tracePostExecute2 tracePostExecute2]
    catch {foo 1} err
    trace remove execution foo leave [list tracePostExecute tracePostExecute]
    trace remove execution foo leave [list tracePostExecute2 tracePostExecute2]
    join [list $err [join $info \n] [trace info execution foo]] "\n"
} {1
tracePostExecute {foo 1} 0 leave
tracePostExecute2 {foo 1} 0 leave
}

test trace-25.7 {order dependencies of two leavestep traces} {
    set info {}
    trace add execution foo leavestep [list tracePostExecute tracePostExecute]
    trace add execution foo leavestep [list tracePostExecute2 tracePostExecute2]
    catch {foo 1} err
    trace remove execution foo leavestep [list tracePostExecute tracePostExecute]
    trace remove execution foo leavestep [list tracePostExecute2 tracePostExecute2]
    join [list $err [join $info \n] [trace info execution foo]] "\n"
} {1
tracePostExecute {set b 1} 0 leavestep
tracePostExecute2 {set b 1} 0 leavestep
}

proc foo {a} {
    set b $a
}

proc traceDelete {cmd args} {
    rename $cmd {}
    global info
    set info $args
}

test trace-25.8 {delete command during enter leave and enter/leave-step traces} {
    set info {}
    trace add execution foo enter [list traceDelete foo]
    trace add execution foo leave [list traceDelete foo]
    trace add execution foo enterstep [list traceDelete foo]
    trace add execution foo leavestep [list traceDelete foo]
    catch {foo 1} err
    list $err $info [trace info execution foo]
} {{invalid command name "foo"} {{foo 1} enter} {unknown command "foo"}}

proc foo {a} {
    set b $a
}

test trace-25.9 {delete command during enter leave and leavestep traces} {
    set info {}
    trace add execution foo enter [list traceDelete foo]
    trace add execution foo leave [list traceDelete foo]
    trace add execution foo leavestep [list traceDelete foo]
    catch {foo 1} err
    list $err $info [trace info execution foo]
} {{invalid command name "foo"} {{foo 1} enter} {unknown command "foo"}}

proc foo {a} {
    set b $a
}

test trace-25.10 {delete command during leave and leavestep traces} {
    set info {}
    trace add execution foo leave [list traceDelete foo]
    trace add execution foo leavestep [list traceDelete foo]
    catch {foo 1} err
    list $err $info [trace info execution foo]
} {1 {{set b 1} 0 1 leavestep} {unknown command "foo"}}

proc foo {a} {
    set b $a
}

test trace-25.11 {delete command during enter and enterstep traces} {
    set info {}
    trace add execution foo enter [list traceDelete foo]
    trace add execution foo enterstep [list traceDelete foo]
    catch {foo 1} err
    list $err $info [trace info execution foo]
} {{invalid command name "foo"} {{foo 1} enter} {unknown command "foo"}}

test trace-26.1 {trace targetCmd when invoked through an alias} {
    proc foo {args} {
	set b $args
    }
    set info {}
    trace add execution foo enter [list traceExecute foo]
    interp alias {} bar {} foo 1
    bar 2
    trace remove execution foo enter [list traceExecute foo]
    set info
} {{foo {foo 1 2} enter}}
test trace-26.2 {trace targetCmd when invoked through an alias} {
    proc foo {args} {
	set b $args
    }
    set info {}
    trace add execution foo enter [list traceExecute foo]
    interp create child
    interp alias child bar {} foo 1
    child eval bar 2
    interp delete child
    trace remove execution foo enter [list traceExecute foo]
    set info
} {{foo {foo 1 2} enter}}

test trace-27.1 {memory leak in rename trace (604609)} {
    catch {rename bar {}}
    proc foo {} {error foo}
    trace add command foo rename {rename foo "" ;#}
    rename foo bar
    info commands foo
} {}

test trace-28.1 {enterstep and leavestep traces with update idletasks (615043)} {
    catch {rename foo {}}
    proc foo {} {
        set a 1
        update idletasks
        set b 1
    }

    set info {}
    trace add execution foo {enter enterstep leavestep leave} \
        [list traceExecute foo]
    update
    after idle {puts idle}
    foo

    trace remove execution foo {enter enterstep leavestep leave} \
        [list traceExecute foo]
    rename foo {}
    join $info "\n"
} {foo foo enter
foo {set a 1} enterstep
foo {set a 1} 0 1 leavestep
foo {update idletasks} enterstep
foo {puts idle} enterstep
foo {puts idle} 0 {} leavestep
foo {update idletasks} 0 {} leavestep
foo {set b 1} enterstep
foo {set b 1} 0 1 leavestep
foo foo 0 1 leave}

# Delete procedures when done, so we don't clash with other tests
# (e.g. foobar will clash with 'unknown' tests).
catch {rename foobar {}}
catch {rename foo {}}
catch {rename bar {}}

# Unset the varaible when done
catch {unset info}

# cleanup
::tcltest::cleanupTests
return
@


1.1
log
@Initial revision
@
text
@d9 1
d14 1
a14 1
# RCS: @@(#) $Id: trace.test,v 1.2 1998/09/14 18:40:14 stanton Exp $
d16 4
a19 1
if {[string compare test [info procs test]] == 1} then {source defs}
d617 1
a617 1
} {1 {too few args: should be "trace option [arg arg ...]"}}
d620 1
a620 1
} {1 {bad option "gorp": should be variable, vdelete, or vinfo}}
d970 17
a986 1
concat {}
@


1.1.1.1
log
@import dejagnu-1999-11-08 snapshot
@
text
@@


1.1.1.2
log
@Tcl 8.3 upgrade
@
text
@a8 1
# Copyright (c) 1998-1999 by Scriptics Corporation.
d13 1
a13 1
# RCS: @@(#) $Id: trace.test,v 1.6.8.2 2000/09/15 16:57:45 spolk Exp $
d15 1
a15 4
if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import -force ::tcltest::*
}
d613 1
a613 1
} {1 {wrong # args: should be "trace option [arg arg ...]"}}
d616 1
a616 1
} {1 {bad option "gorp": must be variable, vdelete, or vinfo}}
d966 1
a966 17

# cleanup
::tcltest::cleanupTests
return













@


1.1.1.3
log
@import tcl 8.4.0
@
text
@d14 1
a14 1
# RCS: @@(#) $Id: trace.test,v 1.22 2002/09/06 00:20:29 dgp Exp $
a54 15
proc traceCommand {oldName newName op} {
    global info
    set info [list $oldName $newName $op]
}

test trace-0.0 {memory corruption in trace (Tcl Bug 484339)} {
    # You may need Purify or Electric Fence to reliably
    # see this one fail.
    catch {unset z}
    trace add variable z array {set z(foo) 1 ;#}
    set res "names: [array names z]"
    catch {unset ::z}
    trace variable ::z w {unset ::z; error "memory corruption";#}
    list [catch {set ::z 1} msg] $msg
} {1 {can't set "::z": memory corruption}}
d61 1
a61 1
    trace add variable x read traceScalar
d63 1
a63 1
} {1 {can't read "x": no such variable} {x {} read 1 {can't read "x": no such variable}}}
d68 1
a68 1
    trace add variable x read traceScalar
d70 1
a70 1
} {0 123 {x {} read 0 123}}
d74 1
a74 1
    trace add variable x read traceScalar
d81 1
a81 1
    trace add variable x(2) read traceArray
d83 1
a83 1
} {1 {can't read "x(2)": no such element in array} {x 2 read 1 {can't read "x(2)": no such element in array}}}
d88 1
a88 1
    trace add variable x(2) read traceArray
d90 1
a90 1
} {0 zzz {x 2 read 0 zzz}}
d94 1
a94 1
    trace add variable x read traceArray2
d101 1
a101 1
} {0 willi {x 2 read}}
d105 1
a105 1
    trace add variable x read q
d118 1
a118 1
} {0 wolf {x Y read}}
d122 1
a122 1
    trace add variable x read traceArray
d129 1
a129 1
    trace add variable x read traceArray
d131 1
a131 1
} {0 zzz {x 2 read 0 zzz}}
d136 1
a136 1
    trace add variable x read traceScalar
a139 28
test trace-1.11 {read traces that modify the array structure} {
    catch {unset x}
    set x(bar) 0 
    trace variable x r {set x(foo) 1 ;#} 
    trace variable x r {unset -nocomplain x(bar) ;#} 
    array get x
} {}
test trace-1.12 {read traces that modify the array structure} {
    catch {unset x}
    set x(bar) 0 
    trace variable x r {unset -nocomplain x(bar) ;#} 
    trace variable x r {set x(foo) 1 ;#} 
    array get x
} {}
test trace-1.13 {read traces that modify the array structure} {
    catch {unset x}
    set x(bar) 0 
    trace variable x r {set x(foo) 1 ;#} 
    trace variable x r {unset -nocomplain x;#} 
    list [catch {array get x} res] $res
} {1 {can't read "x(bar)": no such variable}}
test trace-1.14 {read traces that modify the array structure} {
    catch {unset x}
    set x(bar) 0 
    trace variable x r {unset -nocomplain x;#} 
    trace variable x r {set x(foo) 1 ;#} 
    list [catch {array get x} res] $res
} {1 {can't read "x(bar)": no such variable}}
d146 1
a146 1
    trace add variable x write traceScalar
d149 1
a149 1
} {x {} write 0 123}
d153 1
a153 1
    trace add variable x(33) write traceArray
d156 1
a156 1
} {x 33 write 0 444}
d160 1
a160 1
    trace add variable x write traceArray
d163 1
a163 1
} {x abc write 0 qq}
d168 1
a168 1
    trace add variable x write traceScalar
d176 1
a176 1
    trace add variable x write traceScalar
d189 1
a189 1
    trace add variable x read traceScalarAppend
d194 1
a194 1
} {x {} read 0 123456}
d198 1
a198 1
    trace add variable x {read write} traceScalarAppend
d202 1
a202 1
} {x {} write 0 123 x {} read 0 123 x {} write 0 {123 456}}
d209 1
a209 1
    trace add variable x unset traceScalar
d212 1
a212 1
} {x {} unset 1 {can't read "x": no such variable}}
d217 1
a217 1
    trace add variable x unset traceScalar
d220 1
a220 1
} {x {} unset 1 {can't read "x": no such variable}}
d224 1
a224 1
    trace add variable x unset traceScalar
d233 1
a233 1
    trace add variable x(1) unset traceArray
d236 1
a236 1
} {x 1 unset 1 {can't read "x(1)": no such element in array}}
d241 1
a241 1
    trace add variable x(1) unset traceArray
d244 1
a244 1
} {x 1 unset 1 {can't read "x(1)": no such element in array}}
d249 1
a249 1
    trace add variable x(1) unset traceArray
d252 1
a252 1
} {x 1 unset 1 {can't read "x(1)": no such variable}}
d257 1
a257 1
    trace add variable x unset traceProc
d267 1
a267 1
    trace add variable x unset traceProc
d270 1
a270 1
} {x 1 unset}
d277 1
a277 1
    trace add variable x unset traceProc
d280 1
a280 1
} {x {} unset}
a281 60
# Array tracing on variables
test trace-5.1 {array traces fire on accesses via [array]} {
    catch {unset x}
    set x(b) 2
    trace add variable x array traceArray2
    set ::info {}
    array set x {a 1}
    set ::info
} {x {} array}
test trace-5.2 {array traces do not fire on normal accesses} {
    catch {unset x}
    set x(b) 2
    trace add variable x array traceArray2
    set ::info {}
    set x(a) 1
    set x(b) $x(a)
    set ::info
} {}
test trace-5.3 {array traces do not outlive variable} {
    catch {unset x}
    trace add variable x array traceArray2
    set ::info {}
    set x(a) 1
    unset x
    array set x {a 1}
    set ::info
} {}
test trace-5.4 {array traces properly listed in trace information} {
    catch {unset x}
    trace add variable x array traceArray2
    set result [trace info variable x]
    set result
} [list [list array traceArray2]]
test trace-5.5 {array traces properly listed in trace information} {
    catch {unset x}
    trace variable x a traceArray2
    set result [trace vinfo x]
    set result
} [list [list a traceArray2]]
test trace-5.6 {array traces don't fire on scalar variables} {
    catch {unset x}
    set x foo
    trace add variable x array traceArray2
    set ::info {}
    catch {array set x {a 1}}
    set ::info
} {}
test trace-5.7 {array traces fire for undefined variables} {
    catch {unset x}
    trace add variable x array traceArray2
    set ::info {}
    array set x {a 1}
    set ::info
} {x {} array}
test trace-5.8 {array traces fire for undefined variables} {
    catch {unset x}
    trace add variable x array {set x(foo) 1 ;#}
    set res "names: [array names x]"
} {names: foo}
    
d284 1
a284 1
test trace-6.1 {multiple ops traced at once} {
d287 1
a287 1
    trace add variable x {read write unset} traceProc
d294 2
a295 2
} {x {} read x {} write x {} read x {} write x {} unset}
test trace-6.2 {multiple ops traced on array element} {
d298 1
a298 1
    trace add variable x(0) {read write unset} traceProc
d306 2
a307 2
} {x 0 read x 0 write x 0 read x 0 write x 0 unset}
test trace-6.3 {multiple ops traced on whole array} {
d310 1
a310 1
    trace add variable x {read write unset} traceProc
d318 1
a318 1
} {x 0 write x 0 read x 0 write x 0 unset x {} unset}
d322 1
a322 1
test trace-7.1 {order of invocation of traces} {
d325 3
a327 3
    trace add variable x read "traceTag 1"
    trace add variable x read "traceTag 2"
    trace add variable x read "traceTag 3"
d333 1
a333 1
test trace-7.2 {order of invocation of traces} {
d337 3
a339 3
    trace add variable x(0) read "traceTag 1"
    trace add variable x(0) read "traceTag 2"
    trace add variable x(0) read "traceTag 3"
d343 1
a343 1
test trace-7.3 {order of invocation of traces} {
d347 6
a352 6
    trace add variable x(0) read "traceTag 1"
    trace add variable x read "traceTag A1"
    trace add variable x(0) read "traceTag 2"
    trace add variable x read "traceTag A2"
    trace add variable x(0) read "traceTag 3"
    trace add variable x read "traceTag A3"
d359 1
a359 1
test trace-8.1 {error returns from traces} {
d363 2
a364 2
    trace add variable x read "traceTag 1"
    trace add variable x read traceError
d367 1
a367 1
test trace-8.2 {error returns from traces} {
d371 2
a372 2
    trace add variable x write "traceTag 1"
    trace add variable x write traceError
d375 1
a375 1
test trace-8.3 {error returns from traces} {
d379 1
a379 1
    trace add variable x write traceError
d382 1
a382 1
test trace-8.4 {error returns from traces} {
d386 2
a387 2
    trace add variable x unset "traceTag 1"
    trace add variable x unset traceError
d390 1
a390 1
test trace-8.5 {error returns from traces} {
d394 4
a397 4
    trace add variable x(0) read "traceTag 1"
    trace add variable x read "traceTag 2"
    trace add variable x read traceError
    trace add variable x read "traceTag 3"
d400 1
a400 1
test trace-8.6 {error returns from traces} {
d403 1
a403 1
    trace add variable x unset traceError
d406 1
a406 1
test trace-8.7 {error returns from traces} {
d412 1
a412 1
    trace add variable x read traceError
d415 1
a415 23
    trace remove variable x read traceError
} {}
test trace-8.8 {error returns from traces} {
    # Yet more elaborate memory corruption testing that checks nothing
    # bad happens when the trace deletes itself and installs something
    # new.  Alas, there is no neat way to guarantee that this test will
    # fail if there is a problem, but that's life and with the new code
    # it should *never* fail.
    #
    # Adapted from Bug #219393 reported by Don Porter.
    catch {rename ::foo {}}
    proc foo {old args} {
	trace remove variable ::x write [list foo $old]
	trace add    variable ::x write [list foo $::x]
	error "foo"
    }
    catch {unset ::x ::y}
    set x junk
    trace add variable ::x write [list foo $x]
    for {set y 0} {$y<100} {incr y} {
	catch {set x junk}
    }
    unset x
d422 1
a422 1
test trace-9.1 {be sure variable is unset before trace is called} {
d426 1
a426 1
    trace add variable x unset {traceCheck {uplevel set x}}
d430 1
a430 1
test trace-9.2 {be sure variable is unset before trace is called} {
d434 1
a434 1
    trace add variable x unset {traceCheck {uplevel set x 22}}
d438 1
a438 1
test trace-9.3 {be sure traces are cleared before unset trace called} {
d442 1
a442 1
    trace add variable x unset {traceCheck {uplevel trace info variable x}}
d446 1
a446 1
test trace-9.4 {set new trace during unset trace} {
d450 1
a450 1
    trace add variable x unset {traceCheck {global x; trace add variable x unset traceProc}}
d452 2
a453 2
    concat $info [trace info variable x]
} {0 {} {unset traceProc}}
d455 1
a455 1
test trace-10.1 {make sure array elements are unset before traces are called} {
d459 1
a459 1
    trace add variable x(0) unset {traceCheck {uplevel set x(0)}}
d463 1
a463 1
test trace-10.2 {make sure array elements are unset before traces are called} {
d467 1
a467 1
    trace add variable x(0) unset {traceCheck {uplevel set x(0) zzz}}
d471 1
a471 1
test trace-10.3 {array elements are unset before traces are called} {
d475 1
a475 1
    trace add variable x(0) unset {traceCheck {global x; trace info variable x(0)}}
d479 1
a479 1
test trace-10.4 {set new array element trace during unset trace} {
d483 1
a483 1
    trace add variable x(0) unset {traceCheck {uplevel {trace add variable x(0) read {}}}}
d485 2
a486 2
    concat $info [trace info variable x(0)]
} {0 {} {read {}}}
d488 1
a488 1
test trace-11.1 {make sure arrays are unset before traces are called} {
d492 1
a492 1
    trace add variable x unset {traceCheck {uplevel set x(0)}}
d496 1
a496 1
test trace-11.2 {make sure arrays are unset before traces are called} {
d500 1
a500 1
    trace add variable x unset {traceCheck {uplevel set x(y) 22}}
d504 1
a504 1
test trace-11.3 {make sure arrays are unset before traces are called} {
d508 1
a508 1
    trace add variable x unset {traceCheck {uplevel array exists x}}
d512 1
a512 1
test trace-11.4 {make sure arrays are unset before traces are called} {
d516 2
a517 2
    set cmd {traceCheck {uplevel {trace info variable x}}}
    trace add variable x unset $cmd
d521 1
a521 1
test trace-11.5 {set new array trace during unset trace} {
d525 1
a525 1
    trace add variable x unset {traceCheck {global x; trace add variable x read {}}}
d527 3
a529 3
    concat $info [trace info variable x]
} {0 {} {read {}}}
test trace-11.6 {create scalar during array unset trace} {
d533 1
a533 1
    trace add variable x unset {traceCheck {global x; set x 44}}
d540 1
a540 1
test trace-12.1 {creating array when setting variable traces} {
d543 1
a543 1
    trace add variable x(0) write traceProc
d546 1
a546 1
test trace-12.2 {creating array when setting variable traces} {
d549 1
a549 1
    trace add variable x(0) write traceProc
d552 1
a552 1
test trace-12.3 {creating array when setting variable traces} {
d555 1
a555 1
    trace add variable x(0) write traceProc
d558 2
a559 2
} {x 0 write}
test trace-12.4 {creating variable when setting variable traces} {
d562 1
a562 1
    trace add variable x write traceProc
d565 1
a565 1
test trace-12.5 {creating variable when setting variable traces} {
d568 1
a568 1
    trace add variable x write traceProc
d571 2
a572 2
} {x {} write}
test trace-12.6 {creating variable when setting variable traces} {
d575 1
a575 1
    trace add variable x write traceProc
d578 2
a579 2
} {x 0 write}
test trace-12.7 {create array element during read trace} {
d582 1
a582 1
    trace add variable x read {traceCrtElement xyzzy}
d585 1
a585 1
test trace-12.8 {errors when setting variable traces} {
d588 1
a588 1
    list [catch {trace add variable x(0) write traceProc} msg] $msg
d593 1
a593 1
test trace-13.1 {delete one trace from another} {
d596 3
a598 3
	trace remove variable x read {traceTag 2}
	trace remove variable x read {traceTag 3}
	trace remove variable x read {traceTag 4}
d603 6
a608 6
    trace add variable x read {traceTag 1}
    trace add variable x read {traceTag 2}
    trace add variable x read {traceTag 3}
    trace add variable x read {traceTag 4}
    trace add variable x read delTraces 
    trace add variable x read {traceTag 5}
d615 1
a615 33
# Syntax for adding/removing variable and command traces is basically the
# same:
#	trace add variable name opList command
#	trace remove variable name opList command
#
# The following loops just get all the common "wrong # args" tests done.

set i 0
set start "wrong # args:"
foreach type {variable command} {
    foreach op {add remove} {
	test trace-14.0.[incr i] "trace command, wrong # args errors" {
	    list [catch {trace $op $type} msg] $msg
	} [list 1 "$start should be \"trace $op $type name opList command\""]
	test trace-14.0.[incr i] "trace command wrong # args errors" {
	    list [catch {trace $op $type foo} msg] $msg
	} [list 1 "$start should be \"trace $op $type name opList command\""]
	test trace-14.0.[incr i] "trace command, wrong # args errors" {
	    list [catch {trace $op $type foo bar} msg] $msg
	} [list 1 "$start should be \"trace $op $type name opList command\""]
	test trace-14.0.[incr i] "trace command, wrong # args errors" {
	    list [catch {trace $op $type foo bar baz boo} msg] $msg
	} [list 1 "$start should be \"trace $op $type name opList command\""]
    }
    test trace-14.0.[incr i] "trace command, wrong # args errors" {
	list [catch {trace info $type foo bar} msg] $msg
    } [list 1 "$start should be \"trace info $type name\""]
    test trace-14.0.[incr i] "trace command, wrong # args errors" {
	list [catch {trace info $type} msg] $msg
    } [list 1 "$start should be \"trace info $type name\""]
}

test trace-14.1 "trace command, wrong # args errors" {
d617 2
a618 12
} [list 1 "wrong # args: should be \"trace option ?arg arg ...?\""]
test trace-14.2 "trace command, wrong # args errors" {
    list [catch {trace add} msg] $msg
} [list 1 "wrong # args: should be \"trace add type ?arg arg ...?\""]
test trace-14.3 "trace command, wrong # args errors" {
    list [catch {trace remove} msg] $msg
} [list 1 "wrong # args: should be \"trace remove type ?arg arg ...?\""]
test trace-14.4 "trace command, wrong # args errors" {
    list [catch {trace info} msg] $msg
} [list 1 "wrong # args: should be \"trace info type ?arg arg ...?\""]

test trace-14.5 {trace command, invalid option} {
d620 2
a621 34
} [list 1 "bad option \"gorp\": must be add, info, remove, variable, vdelete, or vinfo"]

# Again, [trace ... command] and [trace ... variable] share syntax and
# error message styles for their opList options; these loops test those 
# error messages.

set i 0
set errs [list "array, read, unset, or write" "delete or rename" "enter, leave, enterstep, or leavestep"]
set abbvs [list {a r u w} {d r} {}]
proc x {} {}
foreach type {variable command execution} err $errs abbvlist $abbvs {
    foreach op {add remove} {
	test trace-14.6.[incr i] "trace $op $type errors" {
	    list [catch {trace $op $type x {y z w} a} msg] $msg
	} [list 1 "bad operation \"y\": must be $err"]
	foreach abbv $abbvlist {
	    test trace-14.6.[incr i] "trace $op $type rejects abbreviations" {
		list [catch {trace $op $type x $abbv a} msg] $msg
	    } [list 1 "bad operation \"$abbv\": must be $err"]
	}
	test trace-14.6.[incr i] "trace $op $type rejects null opList" {
	    list [catch {trace $op $type x {} a} msg] $msg
	} [list 1 "bad operation list \"\": must be one or more of $err"]
    }
}
rename x {}

test trace-14.7 {trace command, "trace variable" errors} {
    list [catch {trace variable} msg] $msg
} [list 1 "wrong # args: should be \"trace variable name ops command\""]
test trace-14.8 {trace command, "trace variable" errors} {
    list [catch {trace variable x} msg] $msg
} [list 1 "wrong # args: should be \"trace variable name ops command\""]
test trace-14.9 {trace command, "trace variable" errors} {
d623 17
a639 10
} [list 1 "wrong # args: should be \"trace variable name ops command\""]
test trace-14.10 {trace command, "trace variable" errors} {
    list [catch {trace variable x y z w} msg] $msg
} [list 1 "wrong # args: should be \"trace variable name ops command\""]
test trace-14.11 {trace command, "trace variable" errors} {
    list [catch {trace variable x y z} msg] $msg
} [list 1 "bad operations \"y\": should be one or more of rwua"]


test trace-14.9 {trace command ("remove variable" option)} {
d642 2
a643 2
    trace add variable x write traceProc
    trace remove variable x write traceProc
d645 1
a645 1
test trace-14.10 {trace command ("remove variable" option)} {
d648 2
a649 2
    trace add variable x write traceProc
    trace remove variable x write traceProc
d653 1
a653 1
test trace-14.11 {trace command ("remove variable" option)} {
d656 3
a658 3
    trace add variable x write {traceTag 1}
    trace add variable x write traceProc
    trace add variable x write {traceTag 2}
d660 1
a660 1
    trace remove variable x write traceProc
d662 1
a662 1
    trace remove variable x write {traceTag 1}
d664 1
a664 1
    trace remove variable x write {traceTag 2}
d667 2
a668 2
} {2 x {} write 1 2 1 2}
test trace-14.12 {trace command ("remove variable" option)} {
d671 2
a672 2
    trace add variable x write {traceTag 1}
    trace remove variable x write non_existent
d676 14
a689 8
test trace-14.15 {trace command ("list variable" option)} {
    catch {unset x}
    trace add variable x write {traceTag 1}
    trace add variable x write traceProc
    trace add variable x write {traceTag 2}
    trace info variable x
} {{write {traceTag 2}} {write traceProc} {write {traceTag 1}}}
test trace-14.16 {trace command ("list variable" option)} {
d691 1
a691 1
    trace info variable x
d693 1
a693 1
test trace-14.17 {trace command ("list variable" option)} {
d695 1
a695 1
    trace info variable x(0)
d697 1
a697 1
test trace-14.18 {trace command ("list variable" option)} {
d700 1
a700 1
    trace info variable x(0)
d702 1
a702 1
test trace-14.19 {trace command ("list variable" option)} {
d705 2
a706 2
    trace add variable x write {traceTag 1}
    proc check {} {global x; trace info variable x}
d708 1
a708 1
} {{write {traceTag 1}}}
d712 1
a712 1
test trace-15.1 {long trace command} {
d715 1
a715 1
    trace add variable x write {traceTag {This is a very very long argument.  It's \
d727 1
a727 1
test trace-15.2 {long trace command result to ignore} {
d732 1
a732 1
    trace add variable x write longResult
d737 1
a737 1
test trace-15.3 {special list-handling in trace commands} {
d741 1
a741 1
    trace add variable "x y z(a\n\{)" write traceProc
d744 1
a744 1
} "{x y z} a\\n\\\{ write"
d768 1
a768 1
test trace-16.1 {unsets during read traces} {
d772 2
a773 2
    trace add variable y read {traceUnset y}
    trace add variable y unset {traceAppend unset}
d776 1
a776 1
test trace-16.2 {unsets during read traces} {
d780 1
a780 1
    trace add variable y(0) read {traceUnset y(0)}
d783 1
a783 1
test trace-16.3 {unsets during read traces} {
d787 1
a787 1
    trace add variable y(0) read {traceUnset y}
d790 1
a790 1
test trace-16.4 {unsets during read traces} {
d794 1
a794 1
    trace add variable y read {traceReset y y}
d797 1
a797 1
test trace-16.5 {unsets during read traces} {
d801 1
a801 1
    trace add variable y(0) read {traceReset y(0) y(0)}
d804 1
a804 1
test trace-16.6 {unsets during read traces} {
d808 1
a808 1
    trace add variable y(0) read {traceReset y y(0)}
d811 1
a811 1
test trace-16.7 {unsets during read traces} {
d815 1
a815 1
    trace add variable y(0) read {traceReset2 y y(0)}
d818 1
a818 1
test trace-16.8 {unsets during write traces} {
d822 2
a823 2
    trace add variable y write {traceUnset y}
    trace add variable y unset {traceAppend unset}
d826 1
a826 1
test trace-16.9 {unsets during write traces} {
d830 1
a830 1
    trace add variable y(0) write {traceUnset y(0)}
d833 1
a833 1
test trace-16.10 {unsets during write traces} {
d837 1
a837 1
    trace add variable y(0) write {traceUnset y}
d840 1
a840 1
test trace-16.11 {unsets during write traces} {
d844 1
a844 1
    trace add variable y write {traceReset y y}
d847 1
a847 1
test trace-16.12 {unsets during write traces} {
d851 1
a851 1
    trace add variable y(0) write {traceReset y(0) y(0)}
d854 1
a854 1
test trace-16.13 {unsets during write traces} {
d858 1
a858 1
    trace add variable y(0) write {traceReset y y(0)}
d861 1
a861 1
test trace-16.14 {unsets during write traces} {
d865 1
a865 1
    trace add variable y(0) write {traceReset2 y y(0)}
d868 1
a868 1
test trace-16.15 {unsets during unset traces} {
d872 1
a872 1
    trace add variable y unset {traceUnset y}
d875 1
a875 1
test trace-16.16 {unsets during unset traces} {
d879 1
a879 1
    trace add variable y(0) unset {traceUnset y(0)}
d882 1
a882 1
test trace-16.17 {unsets during unset traces} {
d886 1
a886 1
    trace add variable y(0) unset {traceUnset y}
d889 1
a889 1
test trace-16.18 {unsets during unset traces} {
d893 1
a893 1
    trace add variable y unset {traceReset2 y y}
d896 1
a896 1
test trace-16.19 {unsets during unset traces} {
d900 1
a900 1
    trace add variable y(0) unset {traceReset2 y(0) y(0)}
d903 1
a903 1
test trace-16.20 {unsets during unset traces} {
d907 1
a907 1
    trace add variable y(0) unset {traceReset2 y y(0)}
d910 1
a910 1
test trace-16.21 {unsets cancelling traces} {
d914 4
a917 4
    trace add variable y read {traceAppend first}
    trace add variable y read {traceUnset y}
    trace add variable y read {traceAppend third}
    trace add variable y unset {traceAppend unset}
d920 1
a920 1
test trace-16.22 {unsets cancelling traces} {
d924 4
a927 4
    trace add variable y(0) read {traceAppend first}
    trace add variable y(0) read {traceUnset y}
    trace add variable y(0) read {traceAppend third}
    trace add variable y(0) unset {traceAppend unset}
d933 1
a933 1
test trace-17.1 {trace doesn't prevent unset errors} {
d936 1
a936 1
    trace add variable x unset {traceProc}
d938 2
a939 2
} {1 {can't unset "x": no such variable} {x {} unset}}
test trace-17.2 {traced variables must survive procedure exits} {
d941 1
a941 1
    proc p1 {} {global x; trace add variable x write traceProc}
d943 3
a945 3
    trace info variable x
} {{write traceProc}}
test trace-17.3 {traced variables must survive procedure exits} {
d948 1
a948 1
    proc p1 {} {global x; trace add variable x write traceProc}
d952 1
a952 1
} {x {} write}
d957 1
a957 1
test trace-18.1 {unset traces on procedure returns} {
d959 1
a959 1
    proc p2 {z} {trace add variable z unset {traceCheck {lsort [uplevel {info vars}]}}}
a963 11
test trace-18.2 {namespace delete / trace vdelete combo} {
    namespace eval ::foo {
	variable x 123
    }
    proc p1 args {
	trace vdelete ::foo::x u p1
    }
    trace variable ::foo::x u p1
    namespace delete ::foo
    info exists ::foo::x
} 0
d971 3
a973 292
test trace-18.2 {trace add command (command existence)} {
    # Just in case!
    catch {rename nosuchname ""}
    list [catch {trace add command nosuchname rename traceCommand} msg] $msg
} {1 {unknown command "nosuchname"}}
test trace-18.3 {trace add command (command existence in ns)} {
    list [catch {trace add command nosuchns::nosuchname rename traceCommand} msg] $msg
} {1 {unknown command "nosuchns::nosuchname"}}


test trace-19.1 {trace add command (rename option)} {
    proc foo {} {}
    catch {rename bar {}}
    trace add command foo rename traceCommand
    rename foo bar
    set info
} {foo bar rename}
test trace-19.2 {traces stick with renamed commands} {
    proc foo {} {}
    catch {rename bar {}}
    trace add command foo rename traceCommand
    rename foo bar
    rename bar foo
    set info
} {bar foo rename}
test trace-19.2.1 {trace add command rename trace exists} {
    proc foo {} {}
    trace add command foo rename traceCommand
    trace info command foo
} {{rename traceCommand}}
test trace-19.3 {command rename traces don't fire on command deletion} {
    proc foo {} {}
    set info {}
    trace add command foo rename traceCommand
    rename foo {}
    set info
} {}
test trace-19.4 {trace add command rename doesn't trace recreated commands} {
    proc foo {} {}
    catch {rename bar {}}
    trace add command foo rename traceCommand
    proc foo {} {}
    rename foo bar
    set info
} {}
test trace-19.5 {trace add command deleted removes traces} {
    proc foo {} {}
    trace add command foo rename traceCommand
    proc foo {} {}
    trace info command foo
} {}

namespace eval tc {}
proc tc::tcfoo {} {}
test trace-19.6 {trace add command rename in namespace} {
    trace add command tc::tcfoo rename traceCommand
    rename tc::tcfoo tc::tcbar
    set info
} {tc::tcfoo tc::tcbar rename}
test trace-19.7 {trace add command rename in namespace back again} {
    rename tc::tcbar tc::tcfoo
    set info
} {tc::tcbar tc::tcfoo rename}
test trace-19.8 {trace add command rename in namespace to out of namespace} {
    rename tc::tcfoo tcbar
    set info
} {tc::tcfoo tcbar rename}
test trace-19.9 {trace add command rename back into namespace} {
    rename tcbar tc::tcfoo
    set info
} {tcbar tc::tcfoo rename}
test trace-19.10 {trace add command failed rename doesn't trigger trace} {
    set info {}
    proc foo {} {}
    proc bar {} {}
    trace add command foo {rename delete} traceCommand
    catch {rename foo bar}
    set info
} {}
catch {rename foo {}}
catch {rename bar {}}

# Make sure it exists again
proc foo {} {}

test trace-20.1 {trace add command (delete option)} {
    trace add command foo delete traceCommand
    rename foo ""
    set info
} {::foo {} delete}
test trace-20.2 {trace add command delete doesn't trace recreated commands} {
    set info {}
    proc foo {} {}
    rename foo ""
    set info
} {}
test trace-20.2.1 {trace add command delete trace info} {
    proc foo {} {}
    trace add command foo delete traceCommand
    trace info command foo
} {{delete traceCommand}}
test trace-20.3 {trace add command implicit delete} {
    proc foo {} {}
    trace add command foo delete traceCommand
    proc foo {} {}
    set info
} {::foo {} delete}
test trace-20.3.1 {trace add command delete trace info} {
    proc foo {} {}
    trace info command foo
} {}
test trace-20.4 {trace add command rename followed by delete} {
    set infotemp {}
    proc foo {} {}
    trace add command foo {rename delete} traceCommand
    rename foo bar
    lappend infotemp $info
    rename bar {}
    lappend infotemp $info
    set info $infotemp
    unset infotemp
    set info
} {{foo bar rename} {::bar {} delete}}
catch {rename foo {}}
catch {rename bar {}}

test trace-20.5 {trace add command rename and delete} {
    set infotemp {}
    set info {}
    proc foo {} {}
    trace add command foo {rename delete} traceCommand
    rename foo bar
    lappend infotemp $info
    rename bar {}
    lappend infotemp $info
    set info $infotemp
    unset infotemp
    set info
} {{foo bar rename} {::bar {} delete}}

test trace-20.6 {trace add command rename and delete in subinterp} {
    set tc [interp create]
    foreach p {traceCommand} {
	$tc eval [list proc $p [info args $p] [info body $p]]
    }
    $tc eval [list set infotemp {}]
    $tc eval [list set info {}]
    $tc eval [list proc foo {} {}]
    $tc eval [list trace add command foo {rename delete} traceCommand]
    $tc eval [list rename foo bar]
    $tc eval {lappend infotemp $info}
    $tc eval [list rename bar {}]
    $tc eval {lappend infotemp $info}
    $tc eval {set info $infotemp}
    $tc eval [list unset infotemp]
    set info [$tc eval [list set info]]
    interp delete $tc
    set info
} {{foo bar rename} {::bar {} delete}}

# I'd like it if this test could give 'foo {} d' as a result,
# but interp deletion means there is no interp to evaluate
# the trace in.
test trace-20.7 {trace add command delete in subinterp while being deleted} {
    set info {}
    set tc [interp create]
    interp alias $tc traceCommand {} traceCommand
    $tc eval [list proc foo {} {}]
    $tc eval [list trace add command foo {rename delete} traceCommand]
    interp delete $tc
    set info
} {}

proc traceDelete {cmd old new op} {
    eval trace remove command $cmd [lindex [trace info command $cmd] 0]
    global info
    set info [list $old $new $op]
}
proc traceCmdrename {cmd old new op} {
    rename $old someothername
}
proc traceCmddelete {cmd old new op} {
    rename $old ""
}
test trace-20.8 {trace delete while trace is active} {
    set info {}
    proc foo {} {}
    catch {rename bar {}}
    trace add command foo {rename delete} [list traceDelete foo]
    rename foo bar
    list [set info] [trace info command bar]
} {{foo bar rename} {}}

test trace-20.9 {rename trace deletes command} {
    set info {}
    proc foo {} {}
    catch {rename bar {}}
    catch {rename someothername {}}
    trace add command foo rename [list traceCmddelete foo]
    rename foo bar
    list [info commands foo] [info commands bar] [info commands someothername]
} {{} {} {}}

test trace-20.10 {rename trace renames command} {
    set info {}
    proc foo {} {}
    catch {rename bar {}}
    catch {rename someothername {}}
    trace add command foo rename [list traceCmdrename foo]
    rename foo bar
    set info [list [info commands foo] [info commands bar] [info commands someothername]]
    rename someothername {}
    set info
} {{} {} someothername}

test trace-20.11 {delete trace deletes command} {
    set info {}
    proc foo {} {}
    catch {rename bar {}}
    catch {rename someothername {}}
    trace add command foo delete [list traceCmddelete foo]
    rename foo {}
    list [info commands foo] [info commands bar] [info commands someothername]
} {{} {} {}}

test trace-20.12 {delete trace renames command} {
    set info {}
    proc foo {} {}
    catch {rename bar {}}
    catch {rename someothername {}}
    trace add command foo delete [list traceCmdrename foo]
    rename foo bar
    rename bar {}
    # None of these should exist.
    list [info commands foo] [info commands bar] [info commands someothername]
} {{} {} {}}

proc foo {b} { set a $b }


# Delete arrays when done, so they can be re-used as scalars
# elsewhere.

catch {unset x}
catch {unset y}

# Delete procedures when done, so we don't clash with other tests
# (e.g. foobar will clash with 'unknown' tests).
catch {rename foobar {}}
catch {rename foo {}}
catch {rename bar {}}

proc foo {a} {
    set b $a
}

proc traceExecute {args} {
    global info
    lappend info $args
}

test trace-21.1 {trace execution: enter} {
    set info {}
    trace add execution foo enter [list traceExecute foo]
    foo 1
    trace remove execution foo enter [list traceExecute foo]
    set info
} {{foo {foo 1} enter}}

test trace-21.2 {trace exeuction: leave} {
    set info {}
    trace add execution foo leave [list traceExecute foo]
    foo 2
    trace remove execution foo leave [list traceExecute foo]
    set info
} {{foo {foo 2} 0 2 leave}}

test trace-21.3 {trace exeuction: enter, leave} {
    set info {}
    trace add execution foo {enter leave} [list traceExecute foo]
    foo 3
    trace remove execution foo {enter leave} [list traceExecute foo]
    set info
} {{foo {foo 3} enter} {foo {foo 3} 0 3 leave}}

test trace-21.4 {trace execution: enter, leave, enterstep} {
    set info {}
    trace add execution foo {enter leave enterstep} [list traceExecute foo]
    foo 3
    trace remove execution foo {enter leave enterstep} [list traceExecute foo]
    set info
} {{foo {foo 3} enter} {foo {set b 3} enterstep} {foo {foo 3} 0 3 leave}}
a974 7
test trace-21.5 {trace execution: enter, leave, enterstep, leavestep} {
    set info {}
    trace add execution foo {enter leave enterstep leavestep} [list traceExecute foo]
    foo 3
    trace remove execution foo {enter leave enterstep leavestep} [list traceExecute foo]
    set info
} {{foo {foo 3} enter} {foo {set b 3} enterstep} {foo {set b 3} 0 3 leavestep} {foo {foo 3} 0 3 leave}}
a975 15
test trace-21.6 {trace execution: enterstep, leavestep} {
    set info {}
    trace add execution foo {enterstep leavestep} [list traceExecute foo]
    foo 3
    trace remove execution foo {enterstep leavestep} [list traceExecute foo]
    set info
} {{foo {set b 3} enterstep} {foo {set b 3} 0 3 leavestep}}

test trace-21.7 {trace execution: enterstep} {
    set info {}
    trace add execution foo {enterstep} [list traceExecute foo]
    foo 3
    trace remove execution foo {enterstep} [list traceExecute foo]
    set info
} {{foo {set b 3} enterstep}}
a976 7
test trace-21.8 {trace execution: leavestep} {
    set info {}
    trace add execution foo {leavestep} [list traceExecute foo]
    foo 3
    trace remove execution foo {leavestep} [list traceExecute foo]
    set info
} {{foo {set b 3} 0 3 leavestep}}
a977 4
proc factorial {n} {
    if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }
    return 1
}
a978 98
test trace-22.1 {recursive(1) trace execution: enter} {
    set info {}
    trace add execution factorial {enter} [list traceExecute factorial]
    factorial 1
    trace remove execution factorial {enter} [list traceExecute factorial]
    set info
} {{factorial {factorial 1} enter}}

test trace-22.2 {recursive(2) trace execution: enter} {
    set info {}
    trace add execution factorial {enter} [list traceExecute factorial]
    factorial 2
    trace remove execution factorial {enter} [list traceExecute factorial]
    set info
} {{factorial {factorial 2} enter} {factorial {factorial 1} enter}}

test trace-22.3 {recursive(3) trace execution: enter} {
    set info {}
    trace add execution factorial {enter} [list traceExecute factorial]
    factorial 3
    trace remove execution factorial {enter} [list traceExecute factorial]
    set info
} {{factorial {factorial 3} enter} {factorial {factorial 2} enter} {factorial {factorial 1} enter}}

test trace-23.1 {recursive(1) trace execution: enter, leave, enterstep, leavestep} {
    set info {}
    trace add execution factorial {enter leave enterstep leavestep} [list traceExecute]
    factorial 1
    trace remove execution factorial {enter leave enterstep leavestep} [list traceExecute]
    join $info "\n"
} {{factorial 1} enter
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} enterstep
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} 0 {} leavestep
{return 1} enterstep
{return 1} 2 1 leavestep
{factorial 1} 0 1 leave}

test trace-23.2 {recursive(2) trace execution: enter, leave, enterstep, leavestep} {
    set info {}
    trace add execution factorial {enter leave enterstep leavestep} [list traceExecute]
    factorial 2
    trace remove execution factorial {enter leave enterstep leavestep} [list traceExecute]
    join $info "\n"
} {{factorial 2} enter
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} enterstep
{expr {$n * [factorial [expr {$n -1 }]]}} enterstep
{expr {$n -1 }} enterstep
{expr {$n -1 }} 0 1 leavestep
{factorial 1} enterstep
{factorial 1} enter
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} enterstep
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} 0 {} leavestep
{return 1} enterstep
{return 1} 2 1 leavestep
{factorial 1} 0 1 leave
{factorial 1} 0 1 leavestep
{expr {$n * [factorial [expr {$n -1 }]]}} 0 2 leavestep
{return 2} enterstep
{return 2} 2 2 leavestep
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} 2 2 leavestep
{factorial 2} 0 2 leave}

test trace-23.3 {recursive(3) trace execution: enter, leave, enterstep, leavestep} {
    set info {}
    trace add execution factorial {enter leave enterstep leavestep} [list traceExecute]
    factorial 3
    trace remove execution factorial {enter leave enterstep leavestep} [list traceExecute]
    join $info "\n"
} {{factorial 3} enter
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} enterstep
{expr {$n * [factorial [expr {$n -1 }]]}} enterstep
{expr {$n -1 }} enterstep
{expr {$n -1 }} 0 2 leavestep
{factorial 2} enterstep
{factorial 2} enter
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} enterstep
{expr {$n * [factorial [expr {$n -1 }]]}} enterstep
{expr {$n -1 }} enterstep
{expr {$n -1 }} 0 1 leavestep
{factorial 1} enterstep
{factorial 1} enter
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} enterstep
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} 0 {} leavestep
{return 1} enterstep
{return 1} 2 1 leavestep
{factorial 1} 0 1 leave
{factorial 1} 0 1 leavestep
{expr {$n * [factorial [expr {$n -1 }]]}} 0 2 leavestep
{return 2} enterstep
{return 2} 2 2 leavestep
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} 2 2 leavestep
{factorial 2} 0 2 leave
{factorial 2} 0 2 leavestep
{expr {$n * [factorial [expr {$n -1 }]]}} 0 6 leavestep
{return 6} enterstep
{return 6} 2 6 leavestep
{if {$n != 1} { return [expr {$n * [factorial [expr {$n -1 }]]}] }} 2 6 leavestep
{factorial 3} 0 6 leave}
a979 5
proc traceDelete {cmd args} {
    eval trace remove execution $cmd [lindex [trace info execution $cmd] 0]
    global info
    set info $args
}
a980 6
test trace-24.1 {delete trace during enter trace} {
    set info {}
    trace add execution foo enter [list traceDelete foo]
    foo 1
    list $info [trace info execution foo]
} {{{foo 1} enter} {}}
a981 6
test trace-24.2 {delete trace during leave trace} {
    set info {}
    trace add execution foo leave [list traceDelete foo]
    foo 1
    list $info [trace info execution foo]
} {{{foo 1} 0 1 leave} {}}
a982 6
test trace-24.3 {delete trace during enter-leave trace} {
    set info {}
    trace add execution foo {enter leave} [list traceDelete foo]
    foo 1
    list $info [trace info execution foo]
} {{{foo 1} enter} {}}
a983 6
test trace-24.4 {delete trace during all exec traces} {
    set info {}
    trace add execution foo {enter leave enterstep leavestep} [list traceDelete foo]
    foo 1
    list $info [trace info execution foo]
} {{{foo 1} enter} {}}
a984 69
test trace-24.5 {delete trace during all exec traces except enter} {
    set info {}
    trace add execution foo {leave enterstep leavestep} [list traceDelete foo]
    foo 1
    list $info [trace info execution foo]
} {{{set b 1} enterstep} {}}

proc traceDelete {cmd args} {
    rename $cmd {}
    global info
    set info $args
}

proc foo {a} {
    set b $a
}

test trace-25.1 {delete command during enter trace} {
    set info {}
    trace add execution foo enter [list traceDelete foo]
    catch {foo 1} err
    list $err $info [trace info execution foo]
} {{invalid command name "foo"} {{foo 1} enter} {unknown command "foo"}}

proc foo {a} {
    set b $a
}

test trace-25.2 {delete command during leave trace} {
    set info {}
    trace add execution foo leave [list traceDelete foo]
    foo 1
    list $info [trace info execution foo]
} {{{foo 1} 0 1 leave} {unknown command "foo"}}

proc foo {a} {
    set b $a
}

test trace-25.3 {delete command during enter then leave trace} {
    set info {}
    trace add execution foo enter [list traceDelete foo]
    trace add execution foo leave [list traceDelete foo]
    catch {foo 1} err
    list $err $info [trace info execution foo]
} {{invalid command name "foo"} {{foo 1} enter} {unknown command "foo"}}

proc foo {a} {
    set b $a
}
proc traceExecute2 {args} {
    global info
    lappend info $args
}

# This shows the peculiar consequences of having two traces
# at the same time: as well as tracing the procedure you want
test trace-25.4 {order dependencies of two enter traces} {
    set info {}
    trace add execution foo enter [list traceExecute traceExecute]
    trace add execution foo enter [list traceExecute2 traceExecute2]
    catch {foo 1} err
    trace remove execution foo enter [list traceExecute traceExecute]
    trace remove execution foo enter [list traceExecute2 traceExecute2]
    join [list $err [join $info \n] [trace info execution foo]] "\n"
} {1
traceExecute2 {foo 1} enter
traceExecute {foo 1} enter
}
a985 149
test trace-25.5 {order dependencies of two step traces} {
    set info {}
    trace add execution foo enterstep [list traceExecute traceExecute]
    trace add execution foo enterstep [list traceExecute2 traceExecute2]
    catch {foo 1} err
    trace remove execution foo enterstep [list traceExecute traceExecute]
    trace remove execution foo enterstep [list traceExecute2 traceExecute2]
    join [list $err [join $info \n] [trace info execution foo]] "\n"
} {1
traceExecute2 {set b 1} enterstep
traceExecute {set b 1} enterstep
}

# We don't want the result string (5th argument), or the results
# will get unmanageable.
proc tracePostExecute {args} {
    global info
    lappend info [concat [lrange $args 0 2] [lindex $args 4]]
}
proc tracePostExecute2 {args} {
    global info
    lappend info [concat [lrange $args 0 2] [lindex $args 4]]
}

test trace-25.6 {order dependencies of two leave traces} {
    set info {}
    trace add execution foo leave [list tracePostExecute tracePostExecute]
    trace add execution foo leave [list tracePostExecute2 tracePostExecute2]
    catch {foo 1} err
    trace remove execution foo leave [list tracePostExecute tracePostExecute]
    trace remove execution foo leave [list tracePostExecute2 tracePostExecute2]
    join [list $err [join $info \n] [trace info execution foo]] "\n"
} {1
tracePostExecute {foo 1} 0 leave
tracePostExecute2 {foo 1} 0 leave
}

test trace-25.7 {order dependencies of two leavestep traces} {
    set info {}
    trace add execution foo leavestep [list tracePostExecute tracePostExecute]
    trace add execution foo leavestep [list tracePostExecute2 tracePostExecute2]
    catch {foo 1} err
    trace remove execution foo leavestep [list tracePostExecute tracePostExecute]
    trace remove execution foo leavestep [list tracePostExecute2 tracePostExecute2]
    join [list $err [join $info \n] [trace info execution foo]] "\n"
} {1
tracePostExecute {set b 1} 0 leavestep
tracePostExecute2 {set b 1} 0 leavestep
}

proc foo {a} {
    set b $a
}

proc traceDelete {cmd args} {
    rename $cmd {}
    global info
    set info $args
}

test trace-25.8 {delete command during enter leave and enter/leave-step traces} {
    set info {}
    trace add execution foo enter [list traceDelete foo]
    trace add execution foo leave [list traceDelete foo]
    trace add execution foo enterstep [list traceDelete foo]
    trace add execution foo leavestep [list traceDelete foo]
    catch {foo 1} err
    list $err $info [trace info execution foo]
} {{invalid command name "foo"} {{foo 1} enter} {unknown command "foo"}}

proc foo {a} {
    set b $a
}

test trace-25.9 {delete command during enter leave and leavestep traces} {
    set info {}
    trace add execution foo enter [list traceDelete foo]
    trace add execution foo leave [list traceDelete foo]
    trace add execution foo leavestep [list traceDelete foo]
    catch {foo 1} err
    list $err $info [trace info execution foo]
} {{invalid command name "foo"} {{foo 1} enter} {unknown command "foo"}}

proc foo {a} {
    set b $a
}

test trace-25.10 {delete command during leave and leavestep traces} {
    set info {}
    trace add execution foo leave [list traceDelete foo]
    trace add execution foo leavestep [list traceDelete foo]
    catch {foo 1} err
    list $err $info [trace info execution foo]
} {1 {{set b 1} 0 1 leavestep} {unknown command "foo"}}

proc foo {a} {
    set b $a
}

test trace-25.11 {delete command during enter and enterstep traces} {
    set info {}
    trace add execution foo enter [list traceDelete foo]
    trace add execution foo enterstep [list traceDelete foo]
    catch {foo 1} err
    list $err $info [trace info execution foo]
} {{invalid command name "foo"} {{foo 1} enter} {unknown command "foo"}}

test trace-26.1 {trace targetCmd when invoked through an alias} {
    proc foo {args} {
	set b $args
    }
    set info {}
    trace add execution foo enter [list traceExecute foo]
    interp alias {} bar {} foo 1
    bar 2
    trace remove execution foo enter [list traceExecute foo]
    set info
} {{foo {foo 1 2} enter}}
test trace-26.2 {trace targetCmd when invoked through an alias} {
    proc foo {args} {
	set b $args
    }
    set info {}
    trace add execution foo enter [list traceExecute foo]
    interp create child
    interp alias child bar {} foo 1
    child eval bar 2
    interp delete child
    trace remove execution foo enter [list traceExecute foo]
    set info
} {{foo {foo 1 2} enter}}

test trace-27.1 {memory leak in rename trace (604609)} {
    catch {rename bar {}}
    proc foo {} {error foo}
    trace add command foo rename {rename foo "" ;#}
    rename foo bar
    info commands foo
} {}

# Delete procedures when done, so we don't clash with other tests
# (e.g. foobar will clash with 'unknown' tests).
catch {rename foobar {}}
catch {rename foo {}}
catch {rename bar {}}

# cleanup
::tcltest::cleanupTests
return
@


1.1.1.4
log
@import tcl 8.4.1
@
text
@d14 1
a14 1
# RCS: @@(#) $Id: trace.test,v 1.23 2002/10/15 16:13:47 vincentdarley Exp $
a1840 30
test trace-28.1 {enterstep and leavestep traces with update idletasks (615043)} {
    catch {rename foo {}}
    proc foo {} {
        set a 1
        update idletasks
        set b 1
    }

    set info {}
    trace add execution foo {enter enterstep leavestep leave} \
        [list traceExecute foo]
    update
    after idle {puts idle}
    foo

    trace remove execution foo {enter enterstep leavestep leave} \
        [list traceExecute foo]
    rename foo {}
    join $info "\n"
} {foo foo enter
foo {set a 1} enterstep
foo {set a 1} 0 1 leavestep
foo {update idletasks} enterstep
foo {puts idle} enterstep
foo {puts idle} 0 {} leavestep
foo {update idletasks} 0 {} leavestep
foo {set b 1} enterstep
foo {set b 1} 0 1 leavestep
foo foo 0 1 leave}

a1845 3

# Unset the varaible when done
catch {unset info}
@


