head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.60
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.58
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.56
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.54
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.52
	gdb_7_0-branch:1.5.0.50
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tcl8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.48
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.46
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.44
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.42
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.40
	gdb_6_5-2006-05-14-branchpoint:1.5
	readline_5_1-import-branch:1.5.0.38
	readline_5_1-import-branchpoint:1.5
	gdb_6_4-branch:1.5.0.36
	gdb_6_4-2005-11-01-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.34
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	ezannoni_pie-20040323-branch:1.5.0.32
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.30
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.28
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.26
	gdb_5_1-2001-07-29-branch:1.5.0.24
	cagney_x86i386-20030821-branch:1.5.0.22
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.20
	gdb_6_0-2003-06-23-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.18
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.16
	cagney_writestrings-20030508-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.14
	cagney_fileio-20030521-branchpoint:1.5
	carlton_dictionary-20030430-merge:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.12
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.10
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.8
	cagney_lazyid-20030317-branchpoint:1.5
	offbyone-20030313-branch:1.5.0.6
	offbyone-20030313-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.4
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.2
	interps-20030202-branchpoint:1.5
	TCL8_4_1:1.1.1.2
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.2
	TCL_8_4_1:1.1.1.2
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.4
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TCL_8_4_0:1.1.1.2
	carlton_dictionary-branch:1.2.0.16
	carlton_dictionary-20020920-branchpoint:1.2
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.14
	gdb_5_3-branch:1.2.0.12
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.10
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.8
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.6
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	cygnus_cvs_20020108_pre:1.2
	TCL_8_3:1.1.1.1
	NET:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2003.01.21.19.40.16;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.26.19.48.01;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.37.07;	author kseitz;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2001.09.09.23.56.08;	author irox;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	2001.09.09.22.40.58;	author irox;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2002.09.27.21.49.10;	author kseitz;	state Exp;
branches;
next	;

1.3.4.1
date	2003.12.14.20.28.49;	author drow;	state Exp;
branches;
next	;

1.2.16.1
date	2002.12.23.19.40.42;	author carlton;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2003.02.07.19.18.19;	author carlton;	state Exp;
branches;
next	;

1.1.1.1
date	2001.09.09.22.40.58;	author irox;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.24.19.56.38;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tcl 8.4.1
@
text
@# This file contains a collection of tests for the msgcat package.
# Sourcing this file into Tcl runs the tests and
# generates output for errors.  No output means no errors were found.
#
# Copyright (c) 1998 Mark Harrison.
# Copyright (c) 1998-1999 by Scriptics Corporation.
# Contributions from Don Porter, NIST, 2002.  (not subject to US copyright)
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# Note that after running these tests, entries will be left behind in the
# message catalogs for locales foo, foo_BAR, and foo_BAR_baz.
#
# RCS: @@(#) $Id: msgcat.test,v 1.11 2002/06/17 05:37:39 dgp Exp $

package require Tcl 8.2
if {[catch {package require tcltest 2}]} {
    puts stderr "Skipping tests in [info script].  tcltest 2 required."
    return
}
if {[catch {package require msgcat 1.3}]} {
    puts stderr "Skipping tests in [info script].  No msgcat 1.3 found to test."
    return
}

namespace eval ::msgcat::test {
    namespace import ::msgcat::*
    namespace import ::tcltest::test
    namespace import ::tcltest::cleanupTests
    namespace import ::tcltest::temporaryDirectory
    namespace import ::tcltest::make*
    namespace import ::tcltest::remove*

    # Tests msgcat-0.*: locale initialization

    proc PowerSet {l} {
	if {[llength $l] == 0} {return [list [list]]}
	set element [lindex $l 0]
	set rest [lrange $l 1 end]
	set result [list]
	foreach x [PowerSet $rest] {
	    lappend result [linsert $x 0 $element]
	    lappend result $x
	}
	return $result
    }

    variable envVars {LC_ALL LC_MESSAGES LANG}
    variable count 0
    variable body
    variable result
    variable setVars
    foreach setVars [PowerSet $envVars] { 
	set result [string tolower [lindex $setVars 0]]
	if {[string length $result] == 0} {
	    set result c
	}
	test msgcat-0.$count {
	    locale initialization from environment variables
	} -setup {
	    variable var
	    foreach var $envVars {
		catch {variable $var $::env($var)}
		catch {unset ::env($var)}
	    }
	    foreach var $setVars {
		set ::env($var) $var
	    }
	    interp create [namespace current]::i
	    i eval [list package ifneeded msgcat [package provide msgcat] \
		    [package ifneeded msgcat [package provide msgcat]]]
	    i eval package require msgcat
	} -cleanup {
	    interp delete [namespace current]::i
	    foreach var $envVars {
		catch {unset ::env($var)}
		catch {set ::env($var) [set [namespace current]::$var]}
	    }
	} -body {i eval msgcat::mclocale} -result $result
	incr count
    }
    catch {unset result}
    
    # Could add tests of initialization from Windows registry here.
    # Use a fake registry package.

    # Tests msgcat-1.*: [mclocale], [mcpreferences]

    test msgcat-1.3 {mclocale set, single element} -setup {
	variable locale [mclocale]
    } -cleanup {
	mclocale $locale
    } -body {
	mclocale en
    } -result en

    test msgcat-1.4 {mclocale get, single element} -setup {
	variable locale [mclocale]
	mclocale en
    } -cleanup {
	mclocale $locale
    } -body {
	mclocale
    } -result en

    test msgcat-1.5 {mcpreferences, single element} -setup {
	variable locale [mclocale]
	mclocale en
    } -cleanup {
	mclocale $locale
    } -body {
	mcpreferences
    } -result en

    test msgcat-1.6 {mclocale set, two elements} -setup {
	variable locale [mclocale]
    } -cleanup {
	mclocale $locale
    } -body {
	mclocale en_US
    } -result en_us

    test msgcat-1.7 {mclocale get, two elements} -setup {
	variable locale [mclocale]
	mclocale en_US
    } -cleanup {
	mclocale $locale
    } -body {
	mclocale
    } -result en_us

    test msgcat-1.8 {mcpreferences, two elements} -setup {
	variable locale [mclocale]
	mclocale en_US
    } -cleanup {
	mclocale $locale
    } -body {
	mcpreferences
    } -result {en_us en}

    test msgcat-1.9 {mclocale set, three elements} -setup {
	variable locale [mclocale]
    } -cleanup {
	mclocale $locale
    } -body {
	mclocale en_US_funky
    } -result en_us_funky

    test msgcat-1.10 {mclocale get, three elements} -setup {
	variable locale [mclocale]
	mclocale en_US_funky
    } -cleanup {
	mclocale $locale
    } -body {
	mclocale
    } -result en_us_funky

    test msgcat-1.11 {mcpreferences, three elements} -setup {
	variable locale [mclocale]
	mclocale en_US_funky
    } -cleanup {
	mclocale $locale
    } -body {
	mcpreferences
    } -result {en_us_funky en_us en}

    # Tests msgcat-2.*: [mcset], [mcmset], namespace partitioning

    test msgcat-2.1 {mcset, global scope} {
	namespace eval :: ::msgcat::mcset  foo_BAR text1 text2
    } {text2}

    test msgcat-2.2 {mcset, global scope, default} {
	namespace eval :: ::msgcat::mcset foo_BAR text3
    } {text3}

    test msgcat-2.2 {mcset, namespace overlap} {
	namespace eval baz {::msgcat::mcset  foo_BAR con1 con1baz}
    } {con1baz}

    test msgcat-2.3 {mcset, namespace overlap} -setup {
	namespace eval bar {::msgcat::mcset  foo_BAR con1 con1bar}
	namespace eval baz {::msgcat::mcset  foo_BAR con1 con1baz}
	variable locale [mclocale]
	mclocale foo_BAR
    } -cleanup {
	mclocale $locale
    } -body {
	namespace eval bar {::msgcat::mc con1}
    } -result con1bar

    test msgcat-2.4 {mcset, namespace overlap} -setup {
	namespace eval bar {::msgcat::mcset  foo_BAR con1 con1bar}
	namespace eval baz {::msgcat::mcset  foo_BAR con1 con1baz}
	variable locale [mclocale]
	mclocale foo_BAR
    } -cleanup {
	mclocale $locale
    } -body {
	namespace eval baz {::msgcat::mc con1}
    } -result con1baz

    test msgcat-2.5 {mcmset, global scope} -setup {
	namespace eval :: {
	    ::msgcat::mcmset  foo_BAR {
	        src1 trans1
	        src2 trans2
	    }
	}
	variable locale [mclocale]
	mclocale foo_BAR
    } -cleanup {
	mclocale $locale
    } -body {
	namespace eval :: {
	    ::msgcat::mc src1
	}
    } -result trans1

    test msgcat-2.6 {mcmset, namespace overlap} -setup {
	namespace eval bar {::msgcat::mcmset  foo_BAR {con2 con2bar}}
	namespace eval baz {::msgcat::mcmset  foo_BAR {con2 con2baz}}
	variable locale [mclocale]
	mclocale foo_BAR
    } -cleanup {
	mclocale $locale
    } -body {
	namespace eval bar {::msgcat::mc con2}
    } -result con2bar

    test msgcat-2.7 {mcmset, namespace overlap} -setup {
	namespace eval bar {::msgcat::mcmset  foo_BAR {con2 con2bar}}
	namespace eval baz {::msgcat::mcmset  foo_BAR {con2 con2baz}}
	variable locale [mclocale]
	mclocale foo_BAR
    } -cleanup {
	mclocale $locale
    } -body {
	namespace eval baz {::msgcat::mc con2}
    } -result con2baz

    # Tests msgcat-3.*: [mcset], [mc], catalog "inheritance"
    #
    # Test mcset and mc, ensuring that more specific locales
    # (e.g. en_UK) will search less specific locales
    # (e.g. en) for translation strings.
    #
    # Do this for the 12 permutations of
    #     locales: {foo foo_BAR foo_BAR_baz}
    #     strings: {ov1 ov2 ov3 ov4}
    #     locale foo         defines ov1, ov2, ov3
    #     locale foo_BAR     defines      ov2, ov3
    #     locale foo_BAR_BAZ defines           ov3
    #     (ov4 is defined in none)
    # So,
    #     ov3 should be resolved in foo, foo_BAR, foo_BAR_baz
    #     ov2 should be resolved in foo, foo_BAR
    #     ov2 should resolve to foo_BAR in foo_BAR_baz
    #     ov1 should be resolved in foo
    #     ov1 should resolve to foo in foo_BAR, foo_BAR_baz
    #     ov4 should be resolved in none, and call mcunknown
    #
    variable count 2
    variable result
    array set result {
	foo,ov1 ov1_foo foo,ov2 ov2_foo foo,ov3 ov3_foo foo,ov4 ov4
	foo_BAR,ov1 ov1_foo foo_BAR,ov2 ov2_foo_BAR foo_BAR,ov3 ov3_foo_BAR
	foo_BAR,ov4 ov4 foo_BAR_baz,ov1 ov1_foo foo_BAR_baz,ov2 ov2_foo_BAR
	foo_BAR_baz,ov3 ov3_foo_BAR_baz foo_BAR_baz,ov4 ov4
    }
    variable loc
    variable string
    foreach loc {foo foo_BAR foo_BAR_baz} {
	foreach string {ov1 ov2 ov3 ov4} {
	    test msgcat-3.$count {mcset, overlap} -setup {
		mcset foo ov1 ov1_foo
		mcset foo ov2 ov2_foo
		mcset foo ov3 ov3_foo
		mcset foo_BAR ov2 ov2_foo_BAR
		mcset foo_BAR ov3 ov3_foo_BAR
		mcset foo_BAR_baz ov3 ov3_foo_BAR_baz
		variable locale [mclocale]
		mclocale $loc
	    } -cleanup {
		mclocale $locale
	    } -body {
		mc $string
	    } -result $result($loc,$string)
	    incr count
	}
    }
    catch {unset result}

    # Tests msgcat-4.*: [mcunknown]

    test msgcat-4.2 {mcunknown, default} -setup {
	mcset foo unk1 "unknown 1"
	variable locale [mclocale]
	mclocale foo
    } -cleanup {
	mclocale $locale
    } -body {
	mc unk1
    } -result {unknown 1}

    test msgcat-4.3 {mcunknown, default} -setup {
	mcset foo unk1 "unknown 1"
	variable locale [mclocale]
	mclocale foo
    } -cleanup {
	mclocale $locale
    } -body {
	mc unk2
    } -result unk2

    test msgcat-4.4 {mcunknown, overridden} -setup {
	rename ::msgcat::mcunknown SavedMcunknown
	proc ::msgcat::mcunknown {dom s} {
            return unknown:$dom:$s
	}
	mcset foo unk1 "unknown 1"
	variable locale [mclocale]
	mclocale foo
    } -cleanup {
	mclocale $locale
	rename ::msgcat::mcunknown {}
	rename SavedMcunknown ::msgcat::mcunknown
    } -body {
	mc unk1
    } -result {unknown 1}

    test msgcat-4.5 {mcunknown, overridden} -setup {
	rename ::msgcat::mcunknown SavedMcunknown
	proc ::msgcat::mcunknown {dom s} {
            return unknown:$dom:$s
	}
	mcset foo unk1 "unknown 1"
	variable locale [mclocale]
	mclocale foo
    } -cleanup {
	mclocale $locale
	rename ::msgcat::mcunknown {}
	rename SavedMcunknown ::msgcat::mcunknown
    } -body {
	mc unk2
    } -result {unknown:foo:unk2}

    test msgcat-4.6 {mcunknown, uplevel context} -setup {
	rename ::msgcat::mcunknown SavedMcunknown
	proc ::msgcat::mcunknown {dom s} {
            return "unknown:$dom:$s:[expr {[info level] - 1}]"
	}
	mcset foo unk1 "unknown 1"
	variable locale [mclocale]
	mclocale foo
    } -cleanup {
	mclocale $locale
	rename ::msgcat::mcunknown {}
	rename SavedMcunknown ::msgcat::mcunknown
    } -body {
	mc unk2
    } -result unknown:foo:unk2:[info level]

    # Tests msgcat-5.*: [mcload]

    variable locales {foo foo_BAR foo_BAR_baz}
    makeDirectory msgdir
    foreach loc $locales {
	makeFile "::msgcat::mcset $loc abc abc-$loc" \
		[string tolower [file join msgdir $loc.msg]]
    }
    variable count 1
    foreach loc {foo foo_BAR foo_BAR_baz} {
	test msgcat-5.$count {mcload} -setup {
	    variable locale [mclocale]
	    mclocale $loc
	} -cleanup {
	    mclocale $locale
	} -body {
	    mcload [file join [temporaryDirectory] msgdir]
	} -result $count
	incr count
    }

    # Even though foo_BAR_notexist does not exist,
    # foo_BAR and foo should be loaded.
	test msgcat-5.4 {mcload} -setup {
	    variable locale [mclocale]
	    mclocale foo_BAR_notexist
	} -cleanup {
	    mclocale $locale
	} -body {
	    mcload [file join [temporaryDirectory] msgdir]
	} -result 2

	test msgcat-5.5 {mcload} -setup {
	    variable locale [mclocale]
	    mclocale no_FI_notexist
	} -cleanup {
	    mclocale $locale
	} -body {
	    mcload [file join [temporaryDirectory] msgdir]
	} -result 0

	test msgcat-5.6 {mcload} -setup {
	    variable locale [mclocale]
	    mclocale foo
	} -cleanup {
	    mclocale $locale
	} -body {
	    mc abc
	} -result abc-foo

	test msgcat-5.7 {mcload} -setup {
	    variable locale [mclocale]
	    mclocale foo_BAR
	} -cleanup {
	    mclocale $locale
	} -body {
	    mc abc
	} -result abc-foo_BAR

	test msgcat-5.8 {mcload} -setup {
	    variable locale [mclocale]
	    mclocale foo_BAR_baz
	} -cleanup {
	    mclocale $locale
	} -body {
	    mc abc
	} -result abc-foo_BAR_baz

	test msgcat-5.9 {mcload} -setup {
	    rename ::msgcat::mcunknown SavedMcunknown
	    proc ::msgcat::mcunknown {dom s} {
		return unknown:$dom:$s
	    }
	    variable locale [mclocale]
	    mclocale no_FI_notexist
	} -cleanup {
	    mclocale $locale
	    rename ::msgcat::mcunknown {}
	    rename SavedMcunknown ::msgcat::mcunknown
	} -body {
	    mc abc
	} -result unknown:no_fi_notexist:abc


    foreach loc $locales {
	removeFile [string tolower [file join msgdir $loc.msg]]
    }
    removeDirectory msgdir

    # Tests msgcat-6.*: [mcset], [mc] namespace inheritance
#
# Test mcset and mc, ensuring that resolution for messages
# proceeds from the current ns to its parent and so on to the 
# global ns.
#
# Do this for the 12 permutations of
#     locales: foo
#     namespaces: foo foo::bar foo::bar::baz
#     strings: {ov1 ov2 ov3 ov4}
#     namespace ::foo            defines ov1, ov2, ov3
#     namespace ::foo::bar       defines      ov2, ov3
#     namespace ::foo::bar::baz  defines           ov3
#
#     ov4 is not defined in any namespace.
#
# So,
#     ov3 should be resolved in ::foo::bar::baz, ::foo::bar, ::foo;
#     ov2 should be resolved in ::foo, ::foo::bar
#     ov1 should be resolved in ::foo
#     ov4 should be resolved in none, and call mcunknown
#

    variable result
    array set result {
	foo,ov1 ov1_foo foo,ov2 ov2_foo foo,ov3 ov3_foo foo,ov4 ov4
	foo::bar,ov1 ov1_foo foo::bar,ov2 ov2_foo_bar
	foo::bar,ov3 ov3_foo_bar foo::bar,ov4 ov4 foo::bar::baz,ov1 ov1_foo
	foo::bar::baz,ov2 ov2_foo_bar foo::bar::baz,ov3 ov3_foo_bar_baz
	foo::bar::baz,ov4 ov4
    }
    variable count 1
    variable ns
    foreach ns {foo foo::bar foo::bar::baz} {
	foreach string {ov1 ov2 ov3 ov4} {
	    test msgcat-6.$count {mcset, overlap} -setup {
		namespace eval foo {
		    ::msgcat::mcset foo ov1 ov1_foo
		    ::msgcat::mcset foo ov2 ov2_foo
		    ::msgcat::mcset foo ov3 ov3_foo
		    namespace eval bar {
			::msgcat::mcset foo ov2 ov2_foo_bar
			::msgcat::mcset foo ov3 ov3_foo_bar
			namespace eval baz {
			    ::msgcat::mcset foo ov3 "ov3_foo_bar_baz"
			}
		    }
		    
		}
		variable locale [mclocale]
		mclocale foo
	    } -cleanup {
		mclocale $locale
		namespace delete foo
	    } -body {
		namespace eval $ns [list ::msgcat::mc $string]
	    } -result $result($ns,$string)
	    incr count
	}
    }

    # Tests msgcat-7.*: [mc] extra args processed by [format]

    test msgcat-7.1 {mc extra args go through to format} -setup {
	mcset foo format1 "this is a test"
	mcset foo format2 "this is a %s"
	mcset foo format3 "this is a %s %s"
	variable locale [mclocale]
	mclocale foo
    } -cleanup {
	mclocale $locale
    } -body {
	mc format1 "good test"
    } -result "this is a test"

    test msgcat-7.2 {mc extra args go through to format} -setup {
	mcset foo format1 "this is a test"
	mcset foo format2 "this is a %s"
	mcset foo format3 "this is a %s %s"
	variable locale [mclocale]
	mclocale foo
    } -cleanup {
	mclocale $locale
    } -body {
	mc format2 "good test"
    } -result "this is a good test"

    test msgcat-7.3 {mc errors from format are propagated} -setup {
	mcset foo format1 "this is a test"
	mcset foo format2 "this is a %s"
	mcset foo format3 "this is a %s %s"
	variable locale [mclocale]
	mclocale foo
    } -cleanup {
	mclocale $locale
    } -body {
	catch {mc format3 "good test"}
    } -result 1

    test msgcat-7.4 {mc, extra args are given to unknown} -setup {
	mcset foo format1 "this is a test"
	mcset foo format2 "this is a %s"
	mcset foo format3 "this is a %s %s"
	variable locale [mclocale]
	mclocale foo
    } -cleanup {
	mclocale $locale
    } -body {
	mc "this is a %s" "good test"
    } -result "this is a good test"

    cleanupTests
}
namespace delete ::msgcat::test
return

@


1.4
log
@touched all sources to ease next import
@
text
@d1 1
a1 5
# Commands covered: ::msgcat::mc ::msgcat::mclocale
#                   ::msgcat::mcpreferences ::msgcat::mcload
#                   ::msgcat::mcset ::msgcat::mcunknown
#
# This file contains a collection of tests for the msgcat script library.
d7 1
d12 4
a15 1
# RCS: @@(#) $Id: msgcat.test,v 1.3.8.2 2000/09/15 16:57:03 spolk Exp $
d17 8
a24 3
if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import -force ::tcltest::*
d27 20
a46 11
if {[catch {package require msgcat 1.0}]} {
    if {[info exist msgcat1]} {
	catch {puts "Cannot load msgcat 1.0 package"}
	return
    } else {
	catch {puts "Running msgcat 1.0 tests in slave interp"}
	set interp [interp create msgcat1]
	$interp eval [list set msgcat1 "running"]
	$interp eval [list source [info script]]
	interp delete $interp
	return
a47 1
}
d49 38
a86 1
set oldlocale [::msgcat::mclocale]
d88 1
a88 1
# some tests fail in tne environment variable LANG exists and is not C
d90 204
a293 90
if {[info exists env(LANG)] && ($env(LANG) != "C")} {
    set ::tcltest::testConstraints(LANGisC) 0
} else {
    set ::tcltest::testConstraints(LANGisC) 1
}

#
# Test the various permutations of mclocale
# and mcpreferences.
#

test msgcat-1.1 {::msgcat::mclocale default} {LANGisC} {
    ::msgcat::mclocale
} {c}
test msgcat-1.2 {::msgcat::mcpreferences, single element} {LANGisC} {
    ::msgcat::mcpreferences
} {c}
test msgcat-1.3 {::msgcat::mclocale, single element} {
    ::msgcat::mclocale en
} {en}
test msgcat-1.4 {::msgcat::mclocale, single element} {
    ::msgcat::mclocale
} {en}
test msgcat-1.5 {::msgcat::mcpreferences, single element} {
    ::msgcat::mcpreferences
} {en}
test msgcat-1.6 {::msgcat::mclocale, two elements} {
    ::msgcat::mclocale en_US
} {en_us}
test msgcat-1.7 {::msgcat::mclocale, two elements} {
    ::msgcat::mclocale en_US
    ::msgcat::mclocale
} {en_us}
test msgcat-1.8 {::msgcat::mcpreferences, two elements} {
    ::msgcat::mcpreferences
} {en_us en}
test msgcat-1.9 {::msgcat::mclocale, three elements} {
    ::msgcat::mclocale en_US_funky
} {en_us_funky}
test msgcat-1.10 {::msgcat::mclocale, three elements} {
    ::msgcat::mclocale
} {en_us_funky}
test msgcat-1.11 {::msgcat::mcpreferences, three elements} {
    ::msgcat::mcpreferences
} {en_us_funky en_us en}

#
# Test mcset and mcc, ensuring that namespace partitioning
# is working.
#

test msgcat-2.1 {::msgcat::mcset, global scope} {
    ::msgcat::mcset  foo_BAR text1 text2
} {text2}
test msgcat-2.2 {::msgcat::mcset, global scope, default} {
    ::msgcat::mcset  foo_BAR text3
} {text3}
test msgcat-2.2 {::msgcat::mcset, namespace overlap} {
    namespace eval bar {::msgcat::mcset  foo_BAR con1 con1bar}
    namespace eval baz {::msgcat::mcset  foo_BAR con1 con1baz}
} {con1baz}
test msgcat-2.3 {::msgcat::mcset, namespace overlap} {
    ::msgcat::mclocale foo_BAR
    namespace eval bar {::msgcat::mc con1}
} {con1bar}
test msgcat-2.4 {::msgcat::mcset, namespace overlap} {
    ::msgcat::mclocale foo_BAR
    namespace eval baz {::msgcat::mc con1}
} {con1baz}

#
# Test mcset and mc, ensuring that more specific locales
# (e.g. "en_UK") will search less specific locales
# (e.g. "en") for translation strings.
#
# Do this for the 12 permutations of
#     locales: {foo foo_BAR foo_BAR_baz}
#     strings: {ov1 ov2 ov3 ov4}
#     locale foo         defines ov1, ov2, ov3
#     locale foo_BAR     defines      ov2, ov3
#     locale foo_BAR_BAZ defines           ov3
#     (ov4 is defined in none)
# So,
#     ov3 should be resolved in foo, foo_BAR, foo_BAR_baz
#     ov2 should be resolved in foo, foo_BAR
#     ov2 should resolve to foo_BAR in foo_BAR_baz
#     ov1 should be resolved in foo
#     ov1 should resolve to foo in foo_BAR, foo_BAR_baz
#     ov4 should be resolved in none, and call mcunknown
#
d295 1
a295 59
test msgcat-3.1 {::msgcat::mcset, overlap} {
    ::msgcat::mcset foo ov1 ov1_foo
    ::msgcat::mcset foo ov2 ov2_foo
    ::msgcat::mcset foo ov3 ov3_foo
    ::msgcat::mcset foo_BAR ov2 ov2_foo_BAR
    ::msgcat::mcset foo_BAR ov3 ov3_foo_BAR
    ::msgcat::mcset foo_BAR_baz ov3 ov3_foo_BAR_baz
} {ov3_foo_BAR_baz}
# top level, locale foo
test msgcat-3.2 {::msgcat::mcset, overlap} {
    ::msgcat::mclocale foo
    ::msgcat::mc ov1
} {ov1_foo}
test msgcat-3.3 {::msgcat::mcset, overlap} {
    ::msgcat::mclocale foo
    ::msgcat::mc ov2
} {ov2_foo}
test msgcat-3.4 {::msgcat::mcset, overlap} {
    ::msgcat::mclocale foo
    ::msgcat::mc ov3
} {ov3_foo}
test msgcat-3.5 {::msgcat::mcset, overlap} {
    ::msgcat::mclocale foo
    ::msgcat::mc ov4
} {ov4}
# second level, locale foo_BAR
test msgcat-3.6 {::msgcat::mcset, overlap} {
    ::msgcat::mclocale foo_BAR
    ::msgcat::mc ov1
} {ov1_foo}
test msgcat-3.7 {::msgcat::mcset, overlap} {
    ::msgcat::mclocale foo_BAR
    ::msgcat::mc ov2
} {ov2_foo_BAR}
test msgcat-3.8 {::msgcat::mcset, overlap} {
    ::msgcat::mclocale foo_BAR
    ::msgcat::mc ov3
} {ov3_foo_BAR}
test msgcat-3.9 {::msgcat::mcset, overlap} {
    ::msgcat::mclocale foo_BAR
    ::msgcat::mc ov4
} {ov4}
# third level, locale foo_BAR_baz
test msgcat-3.10 {::msgcat::mcset, overlap} {
    ::msgcat::mclocale foo_BAR_baz
    ::msgcat::mc ov1
} {ov1_foo}
test msgcat-3.11 {::msgcat::mcset, overlap} {
    ::msgcat::mclocale foo_BAR_baz
    ::msgcat::mc ov2
} {ov2_foo_BAR}
test msgcat-3.12 {::msgcat::mcset, overlap} {
    ::msgcat::mclocale foo_BAR_baz
    ::msgcat::mc ov3
} {ov3_foo_BAR_baz}
test msgcat-3.13 {::msgcat::mcset, overlap} {
    ::msgcat::mclocale foo_BAR_baz
    ::msgcat::mc ov4
} {ov4}
d297 75
a371 20
#
# Test mcunknown, first the default operation
# and then with an overridden definition.
#

test msgcat-4.1 {::msgcat::mcunknown, default} {
    ::msgcat::mcset foo unk1 "unknown 1"
} {unknown 1}
test msgcat-4.2 {::msgcat::mcunknown, default} {
    ::msgcat::mclocale foo
    ::msgcat::mc unk1
} {unknown 1}
test msgcat-4.3 {::msgcat::mcunknown, default} {
    ::msgcat::mclocale foo
    ::msgcat::mc unk2
} {unk2}
test msgcat-4.4 {::msgcat::mcunknown, overridden} {
    rename ::msgcat::mcunknown oldproc
    proc ::msgcat::mcunknown {dom s} {
        return "unknown:$dom:$s"
d373 11
a383 10
    ::msgcat::mclocale foo
    set result [::msgcat::mc unk1]
    rename ::msgcat::mcunknown {}
    rename oldproc ::msgcat::mcunknown
    set result
} {unknown 1}
test msgcat-4.5 {::msgcat::mcunknown, overridden} {
    rename ::msgcat::mcunknown oldproc
    proc ::msgcat::mcunknown {dom s} {
        return "unknown:$dom:$s"
a384 18
    ::msgcat::mclocale foo
    set result [::msgcat::mc unk2]
    rename ::msgcat::mcunknown {}
    rename oldproc ::msgcat::mcunknown
    set result
} {unknown:foo:unk2}
test msgcat-4.6 {::msgcat::mcunknown, uplevel context} {
    rename ::msgcat::mcunknown oldproc
    proc ::msgcat::mcunknown {dom s} {
        return "unknown:$dom:$s:[info level]"
    }
    ::msgcat::mclocale foo
    set result [::msgcat::mc unk2]
    rename ::msgcat::mcunknown {}
    rename oldproc ::msgcat::mcunknown
    set result
} {unknown:foo:unk2:1}
    
d386 61
a446 5
#
# Test mcload.  Need to set up an environment for
# these tests by creating a temporary directory and
# message files.
#
a447 1
set locales {en en_US en_US_funky}
d449 2
a450 47
catch {file mkdir msgdir}
foreach l $locales {
    set fd [open [string tolower [file join msgdir $l.msg]] w]
    puts $fd "::msgcat::mcset $l abc abc-$l"
    close $fd
}

test msgcat-5.1 {::msgcat::mcload} {
    ::msgcat::mclocale en
    ::msgcat::mcload msgdir
} {1}
test msgcat-5.2 {::msgcat::mcload} {
    ::msgcat::mclocale en_US
    ::msgcat::mcload msgdir
} {2}
test msgcat-5.3 {::msgcat::mcload} {
    ::msgcat::mclocale en_US_funky
    ::msgcat::mcload msgdir
} {3}

# Even though en_US_notexist does not exist,
# en_US and en should be loaded.

test msgcat-5.4 {::msgcat::mcload} {
    ::msgcat::mclocale en_US_notexist
    ::msgcat::mcload msgdir
} {2}
test msgcat-5.5 {::msgcat::mcload} {
    ::msgcat::mclocale no_FI_notexist
    ::msgcat::mcload msgdir
} {0}
test msgcat-5.6 {::msgcat::mcload} {
    ::msgcat::mclocale en
    ::msgcat::mc abc
} {abc-en}
test msgcat-5.7 {::msgcat::mcload} {
    ::msgcat::mclocale en_US
    ::msgcat::mc abc
} {abc-en_US}
test msgcat-5.8 {::msgcat::mcload} {
    ::msgcat::mclocale en_US_funky
    ::msgcat::mc abc
} {abc-en_US_funky}
test msgcat-5.9 {::msgcat::mcload} {
    rename ::msgcat::mcunknown oldproc
    proc ::msgcat::mcunknown {dom s} {
        return "unknown:$dom:$s"
d452 1
a452 13
    ::msgcat::mclocale no_FI_notexist
    set result [::msgcat::mc abc]
    rename ::msgcat::mcunknown {}
    rename oldproc ::msgcat::mcunknown
    set result
} {unknown:no_fi_notexist:abc}

# cleanup temp files
foreach l $locales {
    file delete [string tolower [file join msgdir $l.msg]]
}
# Clean out the msg catalogs
file delete msgdir
d454 1
d462 1
a462 1
#     namespaces: ::foo ::foo::bar ::foo::bar::baz
d477 39
a515 73
namespace eval ::foo {
    ::msgcat::mcset foo ov1 "ov1_foo"
    ::msgcat::mcset foo ov2 "ov2_foo"
    ::msgcat::mcset foo ov3 "ov3_foo"
}
namespace eval ::foo::bar {
    ::msgcat::mcset foo ov2 "ov2_foo_bar"
    ::msgcat::mcset foo ov3 "ov3_foo_bar"
}    
namespace eval ::foo::bar::baz {
    ::msgcat::mcset foo ov3 "ov3_foo_bar_baz"
}    
::msgcat::mclocale foo

# namespace ::foo
test msgcat-6.1 {::msgcat::mc, namespace resolution} {
    namespace eval ::foo {::msgcat::mc ov1}
} {ov1_foo}
test msgcat-6.2 {::msgcat::mc, namespace resolution} {
    namespace eval ::foo {::msgcat::mc ov2}
} {ov2_foo}
test msgcat-6.3 {::msgcat::mc, namespace resolution} {
    namespace eval ::foo {::msgcat::mc ov3}
} {ov3_foo}
test msgcat-6.4 {::msgcat::mc, namespace resolution} {
    namespace eval ::foo {::msgcat::mc ov4}
} {ov4}
# namespace ::foo::bar
test msgcat-6.5 {::msgcat::mc, namespace resolution} {
    namespace eval ::foo::bar {::msgcat::mc ov1}
} {ov1_foo}
test msgcat-6.6 {::msgcat::mc, namespace resolution} {
    namespace eval ::foo::bar {::msgcat::mc ov2}
} {ov2_foo_bar}
test msgcat-6.7 {::msgcat::mc, namespace resolution} {
    namespace eval ::foo::bar {::msgcat::mc ov3}
} {ov3_foo_bar}
test msgcat-6.8 {::msgcat::mc, namespace resolution} {
    namespace eval ::foo::bar {::msgcat::mc ov4}
} {ov4}
# namespace ::foo
test msgcat-6.9 {::msgcat::mc, namespace resolution} {
    namespace eval ::foo::bar::baz {::msgcat::mc ov1}
} {ov1_foo}
test msgcat-6.10 {::msgcat::mc, namespace resolution} {
    namespace eval ::foo::bar::baz {::msgcat::mc ov2}
} {ov2_foo_bar}
test msgcat-6.11 {::msgcat::mc, namespace resolution} {
    namespace eval ::foo::bar::baz {::msgcat::mc ov3}
} {ov3_foo_bar_baz}
test msgcat-6.12 {::msgcat::mc, namespace resolution} {
    namespace eval ::foo::bar::baz {::msgcat::mc ov4}
} {ov4}

namespace delete ::foo::bar::baz ::foo::bar ::foo

::msgcat::mclocale foo
::msgcat::mcset foo format1 "this is a test"
::msgcat::mcset foo format2 "this is a %s"
::msgcat::mcset foo format3 "this is a %s %s"

test msgcat-7.1 {::msgcat::mc, extra args go through to format} {
    ::msgcat::mc format1 "good test"
} "this is a test"
test msgcat-7.2 {::msgcat::mc, extra args go through to format} {
    ::msgcat::mc format2 "good test"
} "this is a good test"
test msgcat-7.3 {::msgcat::mc, errors from format are propagated} {
    catch {::msgcat::mc format3 "good test"}
} 1
test msgcat-7.4 {::msgcat::mc, extra args are given to unknown} {
    ::msgcat::mc "this is a %s" "good test"
} "this is a good test"
d517 47
a563 2
# Reset the locale
::msgcat::mclocale $oldlocale
d565 3
a567 1
::tcltest::cleanupTests
@


1.3
log
@touched all sources to ease next import
@
text
@@


1.3.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d1 5
a5 1
# This file contains a collection of tests for the msgcat package.
a10 1
# Contributions from Don Porter, NIST, 2002.  (not subject to US copyright)
d15 6
a20 4
# Note that after running these tests, entries will be left behind in the
# message catalogs for locales foo, foo_BAR, and foo_BAR_baz.
#
# RCS: @@(#) $Id: msgcat.test,v 1.11 2002/06/17 05:37:39 dgp Exp $
d22 12
a33 4
package require Tcl 8.2
if {[catch {package require tcltest 2}]} {
    puts stderr "Skipping tests in [info script].  tcltest 2 required."
    return
d35 9
a43 3
if {[catch {package require msgcat 1.3}]} {
    puts stderr "Skipping tests in [info script].  No msgcat 1.3 found to test."
    return
d46 44
a89 21
namespace eval ::msgcat::test {
    namespace import ::msgcat::*
    namespace import ::tcltest::test
    namespace import ::tcltest::cleanupTests
    namespace import ::tcltest::temporaryDirectory
    namespace import ::tcltest::make*
    namespace import ::tcltest::remove*

    # Tests msgcat-0.*: locale initialization

    proc PowerSet {l} {
	if {[llength $l] == 0} {return [list [list]]}
	set element [lindex $l 0]
	set rest [lrange $l 1 end]
	set result [list]
	foreach x [PowerSet $rest] {
	    lappend result [linsert $x 0 $element]
	    lappend result $x
	}
	return $result
    }
d91 18
a108 38
    variable envVars {LC_ALL LC_MESSAGES LANG}
    variable count 0
    variable body
    variable result
    variable setVars
    foreach setVars [PowerSet $envVars] { 
	set result [string tolower [lindex $setVars 0]]
	if {[string length $result] == 0} {
	    set result c
	}
	test msgcat-0.$count {
	    locale initialization from environment variables
	} -setup {
	    variable var
	    foreach var $envVars {
		catch {variable $var $::env($var)}
		catch {unset ::env($var)}
	    }
	    foreach var $setVars {
		set ::env($var) $var
	    }
	    interp create [namespace current]::i
	    i eval [list package ifneeded msgcat [package provide msgcat] \
		    [package ifneeded msgcat [package provide msgcat]]]
	    i eval package require msgcat
	} -cleanup {
	    interp delete [namespace current]::i
	    foreach var $envVars {
		catch {unset ::env($var)}
		catch {set ::env($var) [set [namespace current]::$var]}
	    }
	} -body {i eval msgcat::mclocale} -result $result
	incr count
    }
    catch {unset result}
    
    # Could add tests of initialization from Windows registry here.
    # Use a fake registry package.
d110 20
a129 1
    # Tests msgcat-1.*: [mclocale], [mcpreferences]
d131 59
a189 204
    test msgcat-1.3 {mclocale set, single element} -setup {
	variable locale [mclocale]
    } -cleanup {
	mclocale $locale
    } -body {
	mclocale en
    } -result en

    test msgcat-1.4 {mclocale get, single element} -setup {
	variable locale [mclocale]
	mclocale en
    } -cleanup {
	mclocale $locale
    } -body {
	mclocale
    } -result en

    test msgcat-1.5 {mcpreferences, single element} -setup {
	variable locale [mclocale]
	mclocale en
    } -cleanup {
	mclocale $locale
    } -body {
	mcpreferences
    } -result en

    test msgcat-1.6 {mclocale set, two elements} -setup {
	variable locale [mclocale]
    } -cleanup {
	mclocale $locale
    } -body {
	mclocale en_US
    } -result en_us

    test msgcat-1.7 {mclocale get, two elements} -setup {
	variable locale [mclocale]
	mclocale en_US
    } -cleanup {
	mclocale $locale
    } -body {
	mclocale
    } -result en_us

    test msgcat-1.8 {mcpreferences, two elements} -setup {
	variable locale [mclocale]
	mclocale en_US
    } -cleanup {
	mclocale $locale
    } -body {
	mcpreferences
    } -result {en_us en}

    test msgcat-1.9 {mclocale set, three elements} -setup {
	variable locale [mclocale]
    } -cleanup {
	mclocale $locale
    } -body {
	mclocale en_US_funky
    } -result en_us_funky

    test msgcat-1.10 {mclocale get, three elements} -setup {
	variable locale [mclocale]
	mclocale en_US_funky
    } -cleanup {
	mclocale $locale
    } -body {
	mclocale
    } -result en_us_funky

    test msgcat-1.11 {mcpreferences, three elements} -setup {
	variable locale [mclocale]
	mclocale en_US_funky
    } -cleanup {
	mclocale $locale
    } -body {
	mcpreferences
    } -result {en_us_funky en_us en}

    # Tests msgcat-2.*: [mcset], [mcmset], namespace partitioning

    test msgcat-2.1 {mcset, global scope} {
	namespace eval :: ::msgcat::mcset  foo_BAR text1 text2
    } {text2}

    test msgcat-2.2 {mcset, global scope, default} {
	namespace eval :: ::msgcat::mcset foo_BAR text3
    } {text3}

    test msgcat-2.2 {mcset, namespace overlap} {
	namespace eval baz {::msgcat::mcset  foo_BAR con1 con1baz}
    } {con1baz}

    test msgcat-2.3 {mcset, namespace overlap} -setup {
	namespace eval bar {::msgcat::mcset  foo_BAR con1 con1bar}
	namespace eval baz {::msgcat::mcset  foo_BAR con1 con1baz}
	variable locale [mclocale]
	mclocale foo_BAR
    } -cleanup {
	mclocale $locale
    } -body {
	namespace eval bar {::msgcat::mc con1}
    } -result con1bar

    test msgcat-2.4 {mcset, namespace overlap} -setup {
	namespace eval bar {::msgcat::mcset  foo_BAR con1 con1bar}
	namespace eval baz {::msgcat::mcset  foo_BAR con1 con1baz}
	variable locale [mclocale]
	mclocale foo_BAR
    } -cleanup {
	mclocale $locale
    } -body {
	namespace eval baz {::msgcat::mc con1}
    } -result con1baz

    test msgcat-2.5 {mcmset, global scope} -setup {
	namespace eval :: {
	    ::msgcat::mcmset  foo_BAR {
	        src1 trans1
	        src2 trans2
	    }
	}
	variable locale [mclocale]
	mclocale foo_BAR
    } -cleanup {
	mclocale $locale
    } -body {
	namespace eval :: {
	    ::msgcat::mc src1
	}
    } -result trans1

    test msgcat-2.6 {mcmset, namespace overlap} -setup {
	namespace eval bar {::msgcat::mcmset  foo_BAR {con2 con2bar}}
	namespace eval baz {::msgcat::mcmset  foo_BAR {con2 con2baz}}
	variable locale [mclocale]
	mclocale foo_BAR
    } -cleanup {
	mclocale $locale
    } -body {
	namespace eval bar {::msgcat::mc con2}
    } -result con2bar

    test msgcat-2.7 {mcmset, namespace overlap} -setup {
	namespace eval bar {::msgcat::mcmset  foo_BAR {con2 con2bar}}
	namespace eval baz {::msgcat::mcmset  foo_BAR {con2 con2baz}}
	variable locale [mclocale]
	mclocale foo_BAR
    } -cleanup {
	mclocale $locale
    } -body {
	namespace eval baz {::msgcat::mc con2}
    } -result con2baz

    # Tests msgcat-3.*: [mcset], [mc], catalog "inheritance"
    #
    # Test mcset and mc, ensuring that more specific locales
    # (e.g. en_UK) will search less specific locales
    # (e.g. en) for translation strings.
    #
    # Do this for the 12 permutations of
    #     locales: {foo foo_BAR foo_BAR_baz}
    #     strings: {ov1 ov2 ov3 ov4}
    #     locale foo         defines ov1, ov2, ov3
    #     locale foo_BAR     defines      ov2, ov3
    #     locale foo_BAR_BAZ defines           ov3
    #     (ov4 is defined in none)
    # So,
    #     ov3 should be resolved in foo, foo_BAR, foo_BAR_baz
    #     ov2 should be resolved in foo, foo_BAR
    #     ov2 should resolve to foo_BAR in foo_BAR_baz
    #     ov1 should be resolved in foo
    #     ov1 should resolve to foo in foo_BAR, foo_BAR_baz
    #     ov4 should be resolved in none, and call mcunknown
    #
    variable count 2
    variable result
    array set result {
	foo,ov1 ov1_foo foo,ov2 ov2_foo foo,ov3 ov3_foo foo,ov4 ov4
	foo_BAR,ov1 ov1_foo foo_BAR,ov2 ov2_foo_BAR foo_BAR,ov3 ov3_foo_BAR
	foo_BAR,ov4 ov4 foo_BAR_baz,ov1 ov1_foo foo_BAR_baz,ov2 ov2_foo_BAR
	foo_BAR_baz,ov3 ov3_foo_BAR_baz foo_BAR_baz,ov4 ov4
    }
    variable loc
    variable string
    foreach loc {foo foo_BAR foo_BAR_baz} {
	foreach string {ov1 ov2 ov3 ov4} {
	    test msgcat-3.$count {mcset, overlap} -setup {
		mcset foo ov1 ov1_foo
		mcset foo ov2 ov2_foo
		mcset foo ov3 ov3_foo
		mcset foo_BAR ov2 ov2_foo_BAR
		mcset foo_BAR ov3 ov3_foo_BAR
		mcset foo_BAR_baz ov3 ov3_foo_BAR_baz
		variable locale [mclocale]
		mclocale $loc
	    } -cleanup {
		mclocale $locale
	    } -body {
		mc $string
	    } -result $result($loc,$string)
	    incr count
	}
    }
    catch {unset result}
d191 4
a194 1
    # Tests msgcat-4.*: [mcunknown]
d196 15
a210 75
    test msgcat-4.2 {mcunknown, default} -setup {
	mcset foo unk1 "unknown 1"
	variable locale [mclocale]
	mclocale foo
    } -cleanup {
	mclocale $locale
    } -body {
	mc unk1
    } -result {unknown 1}

    test msgcat-4.3 {mcunknown, default} -setup {
	mcset foo unk1 "unknown 1"
	variable locale [mclocale]
	mclocale foo
    } -cleanup {
	mclocale $locale
    } -body {
	mc unk2
    } -result unk2

    test msgcat-4.4 {mcunknown, overridden} -setup {
	rename ::msgcat::mcunknown SavedMcunknown
	proc ::msgcat::mcunknown {dom s} {
            return unknown:$dom:$s
	}
	mcset foo unk1 "unknown 1"
	variable locale [mclocale]
	mclocale foo
    } -cleanup {
	mclocale $locale
	rename ::msgcat::mcunknown {}
	rename SavedMcunknown ::msgcat::mcunknown
    } -body {
	mc unk1
    } -result {unknown 1}

    test msgcat-4.5 {mcunknown, overridden} -setup {
	rename ::msgcat::mcunknown SavedMcunknown
	proc ::msgcat::mcunknown {dom s} {
            return unknown:$dom:$s
	}
	mcset foo unk1 "unknown 1"
	variable locale [mclocale]
	mclocale foo
    } -cleanup {
	mclocale $locale
	rename ::msgcat::mcunknown {}
	rename SavedMcunknown ::msgcat::mcunknown
    } -body {
	mc unk2
    } -result {unknown:foo:unk2}

    test msgcat-4.6 {mcunknown, uplevel context} -setup {
	rename ::msgcat::mcunknown SavedMcunknown
	proc ::msgcat::mcunknown {dom s} {
            return "unknown:$dom:$s:[expr {[info level] - 1}]"
	}
	mcset foo unk1 "unknown 1"
	variable locale [mclocale]
	mclocale foo
    } -cleanup {
	mclocale $locale
	rename ::msgcat::mcunknown {}
	rename SavedMcunknown ::msgcat::mcunknown
    } -body {
	mc unk2
    } -result unknown:foo:unk2:[info level]

    # Tests msgcat-5.*: [mcload]

    variable locales {foo foo_BAR foo_BAR_baz}
    makeDirectory msgdir
    foreach loc $locales {
	makeFile "::msgcat::mcset $loc abc abc-$loc" \
		[string tolower [file join msgdir $loc.msg]]
d212 10
a221 11
    variable count 1
    foreach loc {foo foo_BAR foo_BAR_baz} {
	test msgcat-5.$count {mcload} -setup {
	    variable locale [mclocale]
	    mclocale $loc
	} -cleanup {
	    mclocale $locale
	} -body {
	    mcload [file join [temporaryDirectory] msgdir]
	} -result $count
	incr count
d223 18
d242 5
a246 61
    # Even though foo_BAR_notexist does not exist,
    # foo_BAR and foo should be loaded.
	test msgcat-5.4 {mcload} -setup {
	    variable locale [mclocale]
	    mclocale foo_BAR_notexist
	} -cleanup {
	    mclocale $locale
	} -body {
	    mcload [file join [temporaryDirectory] msgdir]
	} -result 2

	test msgcat-5.5 {mcload} -setup {
	    variable locale [mclocale]
	    mclocale no_FI_notexist
	} -cleanup {
	    mclocale $locale
	} -body {
	    mcload [file join [temporaryDirectory] msgdir]
	} -result 0

	test msgcat-5.6 {mcload} -setup {
	    variable locale [mclocale]
	    mclocale foo
	} -cleanup {
	    mclocale $locale
	} -body {
	    mc abc
	} -result abc-foo

	test msgcat-5.7 {mcload} -setup {
	    variable locale [mclocale]
	    mclocale foo_BAR
	} -cleanup {
	    mclocale $locale
	} -body {
	    mc abc
	} -result abc-foo_BAR

	test msgcat-5.8 {mcload} -setup {
	    variable locale [mclocale]
	    mclocale foo_BAR_baz
	} -cleanup {
	    mclocale $locale
	} -body {
	    mc abc
	} -result abc-foo_BAR_baz

	test msgcat-5.9 {mcload} -setup {
	    rename ::msgcat::mcunknown SavedMcunknown
	    proc ::msgcat::mcunknown {dom s} {
		return unknown:$dom:$s
	    }
	    variable locale [mclocale]
	    mclocale no_FI_notexist
	} -cleanup {
	    mclocale $locale
	    rename ::msgcat::mcunknown {}
	    rename SavedMcunknown ::msgcat::mcunknown
	} -body {
	    mc abc
	} -result unknown:no_fi_notexist:abc
d248 1
d250 47
a296 2
    foreach loc $locales {
	removeFile [string tolower [file join msgdir $loc.msg]]
d298 13
a310 1
    removeDirectory msgdir
a311 1
    # Tests msgcat-6.*: [mcset], [mc] namespace inheritance
d319 1
a319 1
#     namespaces: foo foo::bar foo::bar::baz
d334 73
a406 37
    variable result
    array set result {
	foo,ov1 ov1_foo foo,ov2 ov2_foo foo,ov3 ov3_foo foo,ov4 ov4
	foo::bar,ov1 ov1_foo foo::bar,ov2 ov2_foo_bar
	foo::bar,ov3 ov3_foo_bar foo::bar,ov4 ov4 foo::bar::baz,ov1 ov1_foo
	foo::bar::baz,ov2 ov2_foo_bar foo::bar::baz,ov3 ov3_foo_bar_baz
	foo::bar::baz,ov4 ov4
    }
    variable count 1
    variable ns
    foreach ns {foo foo::bar foo::bar::baz} {
	foreach string {ov1 ov2 ov3 ov4} {
	    test msgcat-6.$count {mcset, overlap} -setup {
		namespace eval foo {
		    ::msgcat::mcset foo ov1 ov1_foo
		    ::msgcat::mcset foo ov2 ov2_foo
		    ::msgcat::mcset foo ov3 ov3_foo
		    namespace eval bar {
			::msgcat::mcset foo ov2 ov2_foo_bar
			::msgcat::mcset foo ov3 ov3_foo_bar
			namespace eval baz {
			    ::msgcat::mcset foo ov3 "ov3_foo_bar_baz"
			}
		    }
		    
		}
		variable locale [mclocale]
		mclocale foo
	    } -cleanup {
		mclocale $locale
		namespace delete foo
	    } -body {
		namespace eval $ns [list ::msgcat::mc $string]
	    } -result $result($ns,$string)
	    incr count
	}
    }
d408 2
a409 1
    # Tests msgcat-7.*: [mc] extra args processed by [format]
d411 1
a411 51
    test msgcat-7.1 {mc extra args go through to format} -setup {
	mcset foo format1 "this is a test"
	mcset foo format2 "this is a %s"
	mcset foo format3 "this is a %s %s"
	variable locale [mclocale]
	mclocale foo
    } -cleanup {
	mclocale $locale
    } -body {
	mc format1 "good test"
    } -result "this is a test"

    test msgcat-7.2 {mc extra args go through to format} -setup {
	mcset foo format1 "this is a test"
	mcset foo format2 "this is a %s"
	mcset foo format3 "this is a %s %s"
	variable locale [mclocale]
	mclocale foo
    } -cleanup {
	mclocale $locale
    } -body {
	mc format2 "good test"
    } -result "this is a good test"

    test msgcat-7.3 {mc errors from format are propagated} -setup {
	mcset foo format1 "this is a test"
	mcset foo format2 "this is a %s"
	mcset foo format3 "this is a %s %s"
	variable locale [mclocale]
	mclocale foo
    } -cleanup {
	mclocale $locale
    } -body {
	catch {mc format3 "good test"}
    } -result 1

    test msgcat-7.4 {mc, extra args are given to unknown} -setup {
	mcset foo format1 "this is a test"
	mcset foo format2 "this is a %s"
	mcset foo format3 "this is a %s %s"
	variable locale [mclocale]
	mclocale foo
    } -cleanup {
	mclocale $locale
    } -body {
	mc "this is a %s" "good test"
    } -result "this is a good test"

    cleanupTests
}
namespace delete ::msgcat::test
@


1.3.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@d1 5
a5 1
# This file contains a collection of tests for the msgcat package.
a10 1
# Contributions from Don Porter, NIST, 2002.  (not subject to US copyright)
d15 6
a20 4
# Note that after running these tests, entries will be left behind in the
# message catalogs for locales foo, foo_BAR, and foo_BAR_baz.
#
# RCS: @@(#) $Id: msgcat.test,v 1.11 2002/06/17 05:37:39 dgp Exp $
d22 12
a33 4
package require Tcl 8.2
if {[catch {package require tcltest 2}]} {
    puts stderr "Skipping tests in [info script].  tcltest 2 required."
    return
d35 9
a43 3
if {[catch {package require msgcat 1.3}]} {
    puts stderr "Skipping tests in [info script].  No msgcat 1.3 found to test."
    return
d46 44
a89 21
namespace eval ::msgcat::test {
    namespace import ::msgcat::*
    namespace import ::tcltest::test
    namespace import ::tcltest::cleanupTests
    namespace import ::tcltest::temporaryDirectory
    namespace import ::tcltest::make*
    namespace import ::tcltest::remove*

    # Tests msgcat-0.*: locale initialization

    proc PowerSet {l} {
	if {[llength $l] == 0} {return [list [list]]}
	set element [lindex $l 0]
	set rest [lrange $l 1 end]
	set result [list]
	foreach x [PowerSet $rest] {
	    lappend result [linsert $x 0 $element]
	    lappend result $x
	}
	return $result
    }
d91 18
a108 38
    variable envVars {LC_ALL LC_MESSAGES LANG}
    variable count 0
    variable body
    variable result
    variable setVars
    foreach setVars [PowerSet $envVars] { 
	set result [string tolower [lindex $setVars 0]]
	if {[string length $result] == 0} {
	    set result c
	}
	test msgcat-0.$count {
	    locale initialization from environment variables
	} -setup {
	    variable var
	    foreach var $envVars {
		catch {variable $var $::env($var)}
		catch {unset ::env($var)}
	    }
	    foreach var $setVars {
		set ::env($var) $var
	    }
	    interp create [namespace current]::i
	    i eval [list package ifneeded msgcat [package provide msgcat] \
		    [package ifneeded msgcat [package provide msgcat]]]
	    i eval package require msgcat
	} -cleanup {
	    interp delete [namespace current]::i
	    foreach var $envVars {
		catch {unset ::env($var)}
		catch {set ::env($var) [set [namespace current]::$var]}
	    }
	} -body {i eval msgcat::mclocale} -result $result
	incr count
    }
    catch {unset result}
    
    # Could add tests of initialization from Windows registry here.
    # Use a fake registry package.
d110 20
a129 1
    # Tests msgcat-1.*: [mclocale], [mcpreferences]
d131 59
a189 204
    test msgcat-1.3 {mclocale set, single element} -setup {
	variable locale [mclocale]
    } -cleanup {
	mclocale $locale
    } -body {
	mclocale en
    } -result en

    test msgcat-1.4 {mclocale get, single element} -setup {
	variable locale [mclocale]
	mclocale en
    } -cleanup {
	mclocale $locale
    } -body {
	mclocale
    } -result en

    test msgcat-1.5 {mcpreferences, single element} -setup {
	variable locale [mclocale]
	mclocale en
    } -cleanup {
	mclocale $locale
    } -body {
	mcpreferences
    } -result en

    test msgcat-1.6 {mclocale set, two elements} -setup {
	variable locale [mclocale]
    } -cleanup {
	mclocale $locale
    } -body {
	mclocale en_US
    } -result en_us

    test msgcat-1.7 {mclocale get, two elements} -setup {
	variable locale [mclocale]
	mclocale en_US
    } -cleanup {
	mclocale $locale
    } -body {
	mclocale
    } -result en_us

    test msgcat-1.8 {mcpreferences, two elements} -setup {
	variable locale [mclocale]
	mclocale en_US
    } -cleanup {
	mclocale $locale
    } -body {
	mcpreferences
    } -result {en_us en}

    test msgcat-1.9 {mclocale set, three elements} -setup {
	variable locale [mclocale]
    } -cleanup {
	mclocale $locale
    } -body {
	mclocale en_US_funky
    } -result en_us_funky

    test msgcat-1.10 {mclocale get, three elements} -setup {
	variable locale [mclocale]
	mclocale en_US_funky
    } -cleanup {
	mclocale $locale
    } -body {
	mclocale
    } -result en_us_funky

    test msgcat-1.11 {mcpreferences, three elements} -setup {
	variable locale [mclocale]
	mclocale en_US_funky
    } -cleanup {
	mclocale $locale
    } -body {
	mcpreferences
    } -result {en_us_funky en_us en}

    # Tests msgcat-2.*: [mcset], [mcmset], namespace partitioning

    test msgcat-2.1 {mcset, global scope} {
	namespace eval :: ::msgcat::mcset  foo_BAR text1 text2
    } {text2}

    test msgcat-2.2 {mcset, global scope, default} {
	namespace eval :: ::msgcat::mcset foo_BAR text3
    } {text3}

    test msgcat-2.2 {mcset, namespace overlap} {
	namespace eval baz {::msgcat::mcset  foo_BAR con1 con1baz}
    } {con1baz}

    test msgcat-2.3 {mcset, namespace overlap} -setup {
	namespace eval bar {::msgcat::mcset  foo_BAR con1 con1bar}
	namespace eval baz {::msgcat::mcset  foo_BAR con1 con1baz}
	variable locale [mclocale]
	mclocale foo_BAR
    } -cleanup {
	mclocale $locale
    } -body {
	namespace eval bar {::msgcat::mc con1}
    } -result con1bar

    test msgcat-2.4 {mcset, namespace overlap} -setup {
	namespace eval bar {::msgcat::mcset  foo_BAR con1 con1bar}
	namespace eval baz {::msgcat::mcset  foo_BAR con1 con1baz}
	variable locale [mclocale]
	mclocale foo_BAR
    } -cleanup {
	mclocale $locale
    } -body {
	namespace eval baz {::msgcat::mc con1}
    } -result con1baz

    test msgcat-2.5 {mcmset, global scope} -setup {
	namespace eval :: {
	    ::msgcat::mcmset  foo_BAR {
	        src1 trans1
	        src2 trans2
	    }
	}
	variable locale [mclocale]
	mclocale foo_BAR
    } -cleanup {
	mclocale $locale
    } -body {
	namespace eval :: {
	    ::msgcat::mc src1
	}
    } -result trans1

    test msgcat-2.6 {mcmset, namespace overlap} -setup {
	namespace eval bar {::msgcat::mcmset  foo_BAR {con2 con2bar}}
	namespace eval baz {::msgcat::mcmset  foo_BAR {con2 con2baz}}
	variable locale [mclocale]
	mclocale foo_BAR
    } -cleanup {
	mclocale $locale
    } -body {
	namespace eval bar {::msgcat::mc con2}
    } -result con2bar

    test msgcat-2.7 {mcmset, namespace overlap} -setup {
	namespace eval bar {::msgcat::mcmset  foo_BAR {con2 con2bar}}
	namespace eval baz {::msgcat::mcmset  foo_BAR {con2 con2baz}}
	variable locale [mclocale]
	mclocale foo_BAR
    } -cleanup {
	mclocale $locale
    } -body {
	namespace eval baz {::msgcat::mc con2}
    } -result con2baz

    # Tests msgcat-3.*: [mcset], [mc], catalog "inheritance"
    #
    # Test mcset and mc, ensuring that more specific locales
    # (e.g. en_UK) will search less specific locales
    # (e.g. en) for translation strings.
    #
    # Do this for the 12 permutations of
    #     locales: {foo foo_BAR foo_BAR_baz}
    #     strings: {ov1 ov2 ov3 ov4}
    #     locale foo         defines ov1, ov2, ov3
    #     locale foo_BAR     defines      ov2, ov3
    #     locale foo_BAR_BAZ defines           ov3
    #     (ov4 is defined in none)
    # So,
    #     ov3 should be resolved in foo, foo_BAR, foo_BAR_baz
    #     ov2 should be resolved in foo, foo_BAR
    #     ov2 should resolve to foo_BAR in foo_BAR_baz
    #     ov1 should be resolved in foo
    #     ov1 should resolve to foo in foo_BAR, foo_BAR_baz
    #     ov4 should be resolved in none, and call mcunknown
    #
    variable count 2
    variable result
    array set result {
	foo,ov1 ov1_foo foo,ov2 ov2_foo foo,ov3 ov3_foo foo,ov4 ov4
	foo_BAR,ov1 ov1_foo foo_BAR,ov2 ov2_foo_BAR foo_BAR,ov3 ov3_foo_BAR
	foo_BAR,ov4 ov4 foo_BAR_baz,ov1 ov1_foo foo_BAR_baz,ov2 ov2_foo_BAR
	foo_BAR_baz,ov3 ov3_foo_BAR_baz foo_BAR_baz,ov4 ov4
    }
    variable loc
    variable string
    foreach loc {foo foo_BAR foo_BAR_baz} {
	foreach string {ov1 ov2 ov3 ov4} {
	    test msgcat-3.$count {mcset, overlap} -setup {
		mcset foo ov1 ov1_foo
		mcset foo ov2 ov2_foo
		mcset foo ov3 ov3_foo
		mcset foo_BAR ov2 ov2_foo_BAR
		mcset foo_BAR ov3 ov3_foo_BAR
		mcset foo_BAR_baz ov3 ov3_foo_BAR_baz
		variable locale [mclocale]
		mclocale $loc
	    } -cleanup {
		mclocale $locale
	    } -body {
		mc $string
	    } -result $result($loc,$string)
	    incr count
	}
    }
    catch {unset result}
d191 4
a194 1
    # Tests msgcat-4.*: [mcunknown]
d196 15
a210 75
    test msgcat-4.2 {mcunknown, default} -setup {
	mcset foo unk1 "unknown 1"
	variable locale [mclocale]
	mclocale foo
    } -cleanup {
	mclocale $locale
    } -body {
	mc unk1
    } -result {unknown 1}

    test msgcat-4.3 {mcunknown, default} -setup {
	mcset foo unk1 "unknown 1"
	variable locale [mclocale]
	mclocale foo
    } -cleanup {
	mclocale $locale
    } -body {
	mc unk2
    } -result unk2

    test msgcat-4.4 {mcunknown, overridden} -setup {
	rename ::msgcat::mcunknown SavedMcunknown
	proc ::msgcat::mcunknown {dom s} {
            return unknown:$dom:$s
	}
	mcset foo unk1 "unknown 1"
	variable locale [mclocale]
	mclocale foo
    } -cleanup {
	mclocale $locale
	rename ::msgcat::mcunknown {}
	rename SavedMcunknown ::msgcat::mcunknown
    } -body {
	mc unk1
    } -result {unknown 1}

    test msgcat-4.5 {mcunknown, overridden} -setup {
	rename ::msgcat::mcunknown SavedMcunknown
	proc ::msgcat::mcunknown {dom s} {
            return unknown:$dom:$s
	}
	mcset foo unk1 "unknown 1"
	variable locale [mclocale]
	mclocale foo
    } -cleanup {
	mclocale $locale
	rename ::msgcat::mcunknown {}
	rename SavedMcunknown ::msgcat::mcunknown
    } -body {
	mc unk2
    } -result {unknown:foo:unk2}

    test msgcat-4.6 {mcunknown, uplevel context} -setup {
	rename ::msgcat::mcunknown SavedMcunknown
	proc ::msgcat::mcunknown {dom s} {
            return "unknown:$dom:$s:[expr {[info level] - 1}]"
	}
	mcset foo unk1 "unknown 1"
	variable locale [mclocale]
	mclocale foo
    } -cleanup {
	mclocale $locale
	rename ::msgcat::mcunknown {}
	rename SavedMcunknown ::msgcat::mcunknown
    } -body {
	mc unk2
    } -result unknown:foo:unk2:[info level]

    # Tests msgcat-5.*: [mcload]

    variable locales {foo foo_BAR foo_BAR_baz}
    makeDirectory msgdir
    foreach loc $locales {
	makeFile "::msgcat::mcset $loc abc abc-$loc" \
		[string tolower [file join msgdir $loc.msg]]
d212 10
a221 11
    variable count 1
    foreach loc {foo foo_BAR foo_BAR_baz} {
	test msgcat-5.$count {mcload} -setup {
	    variable locale [mclocale]
	    mclocale $loc
	} -cleanup {
	    mclocale $locale
	} -body {
	    mcload [file join [temporaryDirectory] msgdir]
	} -result $count
	incr count
d223 18
d242 5
a246 61
    # Even though foo_BAR_notexist does not exist,
    # foo_BAR and foo should be loaded.
	test msgcat-5.4 {mcload} -setup {
	    variable locale [mclocale]
	    mclocale foo_BAR_notexist
	} -cleanup {
	    mclocale $locale
	} -body {
	    mcload [file join [temporaryDirectory] msgdir]
	} -result 2

	test msgcat-5.5 {mcload} -setup {
	    variable locale [mclocale]
	    mclocale no_FI_notexist
	} -cleanup {
	    mclocale $locale
	} -body {
	    mcload [file join [temporaryDirectory] msgdir]
	} -result 0

	test msgcat-5.6 {mcload} -setup {
	    variable locale [mclocale]
	    mclocale foo
	} -cleanup {
	    mclocale $locale
	} -body {
	    mc abc
	} -result abc-foo

	test msgcat-5.7 {mcload} -setup {
	    variable locale [mclocale]
	    mclocale foo_BAR
	} -cleanup {
	    mclocale $locale
	} -body {
	    mc abc
	} -result abc-foo_BAR

	test msgcat-5.8 {mcload} -setup {
	    variable locale [mclocale]
	    mclocale foo_BAR_baz
	} -cleanup {
	    mclocale $locale
	} -body {
	    mc abc
	} -result abc-foo_BAR_baz

	test msgcat-5.9 {mcload} -setup {
	    rename ::msgcat::mcunknown SavedMcunknown
	    proc ::msgcat::mcunknown {dom s} {
		return unknown:$dom:$s
	    }
	    variable locale [mclocale]
	    mclocale no_FI_notexist
	} -cleanup {
	    mclocale $locale
	    rename ::msgcat::mcunknown {}
	    rename SavedMcunknown ::msgcat::mcunknown
	} -body {
	    mc abc
	} -result unknown:no_fi_notexist:abc
d248 1
d250 47
a296 2
    foreach loc $locales {
	removeFile [string tolower [file join msgdir $loc.msg]]
d298 13
a310 1
    removeDirectory msgdir
a311 1
    # Tests msgcat-6.*: [mcset], [mc] namespace inheritance
d319 1
a319 1
#     namespaces: foo foo::bar foo::bar::baz
d334 73
a406 37
    variable result
    array set result {
	foo,ov1 ov1_foo foo,ov2 ov2_foo foo,ov3 ov3_foo foo,ov4 ov4
	foo::bar,ov1 ov1_foo foo::bar,ov2 ov2_foo_bar
	foo::bar,ov3 ov3_foo_bar foo::bar,ov4 ov4 foo::bar::baz,ov1 ov1_foo
	foo::bar::baz,ov2 ov2_foo_bar foo::bar::baz,ov3 ov3_foo_bar_baz
	foo::bar::baz,ov4 ov4
    }
    variable count 1
    variable ns
    foreach ns {foo foo::bar foo::bar::baz} {
	foreach string {ov1 ov2 ov3 ov4} {
	    test msgcat-6.$count {mcset, overlap} -setup {
		namespace eval foo {
		    ::msgcat::mcset foo ov1 ov1_foo
		    ::msgcat::mcset foo ov2 ov2_foo
		    ::msgcat::mcset foo ov3 ov3_foo
		    namespace eval bar {
			::msgcat::mcset foo ov2 ov2_foo_bar
			::msgcat::mcset foo ov3 ov3_foo_bar
			namespace eval baz {
			    ::msgcat::mcset foo ov3 "ov3_foo_bar_baz"
			}
		    }
		    
		}
		variable locale [mclocale]
		mclocale foo
	    } -cleanup {
		mclocale $locale
		namespace delete foo
	    } -body {
		namespace eval $ns [list ::msgcat::mc $string]
	    } -result $result($ns,$string)
	    incr count
	}
    }
d408 2
a409 1
    # Tests msgcat-7.*: [mc] extra args processed by [format]
d411 1
a411 51
    test msgcat-7.1 {mc extra args go through to format} -setup {
	mcset foo format1 "this is a test"
	mcset foo format2 "this is a %s"
	mcset foo format3 "this is a %s %s"
	variable locale [mclocale]
	mclocale foo
    } -cleanup {
	mclocale $locale
    } -body {
	mc format1 "good test"
    } -result "this is a test"

    test msgcat-7.2 {mc extra args go through to format} -setup {
	mcset foo format1 "this is a test"
	mcset foo format2 "this is a %s"
	mcset foo format3 "this is a %s %s"
	variable locale [mclocale]
	mclocale foo
    } -cleanup {
	mclocale $locale
    } -body {
	mc format2 "good test"
    } -result "this is a good test"

    test msgcat-7.3 {mc errors from format are propagated} -setup {
	mcset foo format1 "this is a test"
	mcset foo format2 "this is a %s"
	mcset foo format3 "this is a %s %s"
	variable locale [mclocale]
	mclocale foo
    } -cleanup {
	mclocale $locale
    } -body {
	catch {mc format3 "good test"}
    } -result 1

    test msgcat-7.4 {mc, extra args are given to unknown} -setup {
	mcset foo format1 "this is a test"
	mcset foo format2 "this is a %s"
	mcset foo format3 "this is a %s %s"
	variable locale [mclocale]
	mclocale foo
    } -cleanup {
	mclocale $locale
    } -body {
	mc "this is a %s" "good test"
    } -result "this is a good test"

    cleanupTests
}
namespace delete ::msgcat::test
@


1.2
log
@touched all Tcl files to ease next import.
@
text
@@


1.2.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.2.16.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d1 5
a5 1
# This file contains a collection of tests for the msgcat package.
a10 1
# Contributions from Don Porter, NIST, 2002.  (not subject to US copyright)
d15 6
a20 4
# Note that after running these tests, entries will be left behind in the
# message catalogs for locales foo, foo_BAR, and foo_BAR_baz.
#
# RCS: @@(#) $Id$
d22 12
a33 4
package require Tcl 8.2
if {[catch {package require tcltest 2}]} {
    puts stderr "Skipping tests in [info script].  tcltest 2 required."
    return
d35 9
a43 3
if {[catch {package require msgcat 1.3}]} {
    puts stderr "Skipping tests in [info script].  No msgcat 1.3 found to test."
    return
d46 44
a89 21
namespace eval ::msgcat::test {
    namespace import ::msgcat::*
    namespace import ::tcltest::test
    namespace import ::tcltest::cleanupTests
    namespace import ::tcltest::temporaryDirectory
    namespace import ::tcltest::make*
    namespace import ::tcltest::remove*

    # Tests msgcat-0.*: locale initialization

    proc PowerSet {l} {
	if {[llength $l] == 0} {return [list [list]]}
	set element [lindex $l 0]
	set rest [lrange $l 1 end]
	set result [list]
	foreach x [PowerSet $rest] {
	    lappend result [linsert $x 0 $element]
	    lappend result $x
	}
	return $result
    }
d91 18
a108 38
    variable envVars {LC_ALL LC_MESSAGES LANG}
    variable count 0
    variable body
    variable result
    variable setVars
    foreach setVars [PowerSet $envVars] { 
	set result [string tolower [lindex $setVars 0]]
	if {[string length $result] == 0} {
	    set result c
	}
	test msgcat-0.$count {
	    locale initialization from environment variables
	} -setup {
	    variable var
	    foreach var $envVars {
		catch {variable $var $::env($var)}
		catch {unset ::env($var)}
	    }
	    foreach var $setVars {
		set ::env($var) $var
	    }
	    interp create [namespace current]::i
	    i eval [list package ifneeded msgcat [package provide msgcat] \
		    [package ifneeded msgcat [package provide msgcat]]]
	    i eval package require msgcat
	} -cleanup {
	    interp delete [namespace current]::i
	    foreach var $envVars {
		catch {unset ::env($var)}
		catch {set ::env($var) [set [namespace current]::$var]}
	    }
	} -body {i eval msgcat::mclocale} -result $result
	incr count
    }
    catch {unset result}
    
    # Could add tests of initialization from Windows registry here.
    # Use a fake registry package.
d110 20
a129 1
    # Tests msgcat-1.*: [mclocale], [mcpreferences]
d131 59
a189 204
    test msgcat-1.3 {mclocale set, single element} -setup {
	variable locale [mclocale]
    } -cleanup {
	mclocale $locale
    } -body {
	mclocale en
    } -result en

    test msgcat-1.4 {mclocale get, single element} -setup {
	variable locale [mclocale]
	mclocale en
    } -cleanup {
	mclocale $locale
    } -body {
	mclocale
    } -result en

    test msgcat-1.5 {mcpreferences, single element} -setup {
	variable locale [mclocale]
	mclocale en
    } -cleanup {
	mclocale $locale
    } -body {
	mcpreferences
    } -result en

    test msgcat-1.6 {mclocale set, two elements} -setup {
	variable locale [mclocale]
    } -cleanup {
	mclocale $locale
    } -body {
	mclocale en_US
    } -result en_us

    test msgcat-1.7 {mclocale get, two elements} -setup {
	variable locale [mclocale]
	mclocale en_US
    } -cleanup {
	mclocale $locale
    } -body {
	mclocale
    } -result en_us

    test msgcat-1.8 {mcpreferences, two elements} -setup {
	variable locale [mclocale]
	mclocale en_US
    } -cleanup {
	mclocale $locale
    } -body {
	mcpreferences
    } -result {en_us en}

    test msgcat-1.9 {mclocale set, three elements} -setup {
	variable locale [mclocale]
    } -cleanup {
	mclocale $locale
    } -body {
	mclocale en_US_funky
    } -result en_us_funky

    test msgcat-1.10 {mclocale get, three elements} -setup {
	variable locale [mclocale]
	mclocale en_US_funky
    } -cleanup {
	mclocale $locale
    } -body {
	mclocale
    } -result en_us_funky

    test msgcat-1.11 {mcpreferences, three elements} -setup {
	variable locale [mclocale]
	mclocale en_US_funky
    } -cleanup {
	mclocale $locale
    } -body {
	mcpreferences
    } -result {en_us_funky en_us en}

    # Tests msgcat-2.*: [mcset], [mcmset], namespace partitioning

    test msgcat-2.1 {mcset, global scope} {
	namespace eval :: ::msgcat::mcset  foo_BAR text1 text2
    } {text2}

    test msgcat-2.2 {mcset, global scope, default} {
	namespace eval :: ::msgcat::mcset foo_BAR text3
    } {text3}

    test msgcat-2.2 {mcset, namespace overlap} {
	namespace eval baz {::msgcat::mcset  foo_BAR con1 con1baz}
    } {con1baz}

    test msgcat-2.3 {mcset, namespace overlap} -setup {
	namespace eval bar {::msgcat::mcset  foo_BAR con1 con1bar}
	namespace eval baz {::msgcat::mcset  foo_BAR con1 con1baz}
	variable locale [mclocale]
	mclocale foo_BAR
    } -cleanup {
	mclocale $locale
    } -body {
	namespace eval bar {::msgcat::mc con1}
    } -result con1bar

    test msgcat-2.4 {mcset, namespace overlap} -setup {
	namespace eval bar {::msgcat::mcset  foo_BAR con1 con1bar}
	namespace eval baz {::msgcat::mcset  foo_BAR con1 con1baz}
	variable locale [mclocale]
	mclocale foo_BAR
    } -cleanup {
	mclocale $locale
    } -body {
	namespace eval baz {::msgcat::mc con1}
    } -result con1baz

    test msgcat-2.5 {mcmset, global scope} -setup {
	namespace eval :: {
	    ::msgcat::mcmset  foo_BAR {
	        src1 trans1
	        src2 trans2
	    }
	}
	variable locale [mclocale]
	mclocale foo_BAR
    } -cleanup {
	mclocale $locale
    } -body {
	namespace eval :: {
	    ::msgcat::mc src1
	}
    } -result trans1

    test msgcat-2.6 {mcmset, namespace overlap} -setup {
	namespace eval bar {::msgcat::mcmset  foo_BAR {con2 con2bar}}
	namespace eval baz {::msgcat::mcmset  foo_BAR {con2 con2baz}}
	variable locale [mclocale]
	mclocale foo_BAR
    } -cleanup {
	mclocale $locale
    } -body {
	namespace eval bar {::msgcat::mc con2}
    } -result con2bar

    test msgcat-2.7 {mcmset, namespace overlap} -setup {
	namespace eval bar {::msgcat::mcmset  foo_BAR {con2 con2bar}}
	namespace eval baz {::msgcat::mcmset  foo_BAR {con2 con2baz}}
	variable locale [mclocale]
	mclocale foo_BAR
    } -cleanup {
	mclocale $locale
    } -body {
	namespace eval baz {::msgcat::mc con2}
    } -result con2baz

    # Tests msgcat-3.*: [mcset], [mc], catalog "inheritance"
    #
    # Test mcset and mc, ensuring that more specific locales
    # (e.g. en_UK) will search less specific locales
    # (e.g. en) for translation strings.
    #
    # Do this for the 12 permutations of
    #     locales: {foo foo_BAR foo_BAR_baz}
    #     strings: {ov1 ov2 ov3 ov4}
    #     locale foo         defines ov1, ov2, ov3
    #     locale foo_BAR     defines      ov2, ov3
    #     locale foo_BAR_BAZ defines           ov3
    #     (ov4 is defined in none)
    # So,
    #     ov3 should be resolved in foo, foo_BAR, foo_BAR_baz
    #     ov2 should be resolved in foo, foo_BAR
    #     ov2 should resolve to foo_BAR in foo_BAR_baz
    #     ov1 should be resolved in foo
    #     ov1 should resolve to foo in foo_BAR, foo_BAR_baz
    #     ov4 should be resolved in none, and call mcunknown
    #
    variable count 2
    variable result
    array set result {
	foo,ov1 ov1_foo foo,ov2 ov2_foo foo,ov3 ov3_foo foo,ov4 ov4
	foo_BAR,ov1 ov1_foo foo_BAR,ov2 ov2_foo_BAR foo_BAR,ov3 ov3_foo_BAR
	foo_BAR,ov4 ov4 foo_BAR_baz,ov1 ov1_foo foo_BAR_baz,ov2 ov2_foo_BAR
	foo_BAR_baz,ov3 ov3_foo_BAR_baz foo_BAR_baz,ov4 ov4
    }
    variable loc
    variable string
    foreach loc {foo foo_BAR foo_BAR_baz} {
	foreach string {ov1 ov2 ov3 ov4} {
	    test msgcat-3.$count {mcset, overlap} -setup {
		mcset foo ov1 ov1_foo
		mcset foo ov2 ov2_foo
		mcset foo ov3 ov3_foo
		mcset foo_BAR ov2 ov2_foo_BAR
		mcset foo_BAR ov3 ov3_foo_BAR
		mcset foo_BAR_baz ov3 ov3_foo_BAR_baz
		variable locale [mclocale]
		mclocale $loc
	    } -cleanup {
		mclocale $locale
	    } -body {
		mc $string
	    } -result $result($loc,$string)
	    incr count
	}
    }
    catch {unset result}
d191 4
a194 1
    # Tests msgcat-4.*: [mcunknown]
d196 15
a210 75
    test msgcat-4.2 {mcunknown, default} -setup {
	mcset foo unk1 "unknown 1"
	variable locale [mclocale]
	mclocale foo
    } -cleanup {
	mclocale $locale
    } -body {
	mc unk1
    } -result {unknown 1}

    test msgcat-4.3 {mcunknown, default} -setup {
	mcset foo unk1 "unknown 1"
	variable locale [mclocale]
	mclocale foo
    } -cleanup {
	mclocale $locale
    } -body {
	mc unk2
    } -result unk2

    test msgcat-4.4 {mcunknown, overridden} -setup {
	rename ::msgcat::mcunknown SavedMcunknown
	proc ::msgcat::mcunknown {dom s} {
            return unknown:$dom:$s
	}
	mcset foo unk1 "unknown 1"
	variable locale [mclocale]
	mclocale foo
    } -cleanup {
	mclocale $locale
	rename ::msgcat::mcunknown {}
	rename SavedMcunknown ::msgcat::mcunknown
    } -body {
	mc unk1
    } -result {unknown 1}

    test msgcat-4.5 {mcunknown, overridden} -setup {
	rename ::msgcat::mcunknown SavedMcunknown
	proc ::msgcat::mcunknown {dom s} {
            return unknown:$dom:$s
	}
	mcset foo unk1 "unknown 1"
	variable locale [mclocale]
	mclocale foo
    } -cleanup {
	mclocale $locale
	rename ::msgcat::mcunknown {}
	rename SavedMcunknown ::msgcat::mcunknown
    } -body {
	mc unk2
    } -result {unknown:foo:unk2}

    test msgcat-4.6 {mcunknown, uplevel context} -setup {
	rename ::msgcat::mcunknown SavedMcunknown
	proc ::msgcat::mcunknown {dom s} {
            return "unknown:$dom:$s:[expr {[info level] - 1}]"
	}
	mcset foo unk1 "unknown 1"
	variable locale [mclocale]
	mclocale foo
    } -cleanup {
	mclocale $locale
	rename ::msgcat::mcunknown {}
	rename SavedMcunknown ::msgcat::mcunknown
    } -body {
	mc unk2
    } -result unknown:foo:unk2:[info level]

    # Tests msgcat-5.*: [mcload]

    variable locales {foo foo_BAR foo_BAR_baz}
    makeDirectory msgdir
    foreach loc $locales {
	makeFile "::msgcat::mcset $loc abc abc-$loc" \
		[string tolower [file join msgdir $loc.msg]]
d212 10
a221 11
    variable count 1
    foreach loc {foo foo_BAR foo_BAR_baz} {
	test msgcat-5.$count {mcload} -setup {
	    variable locale [mclocale]
	    mclocale $loc
	} -cleanup {
	    mclocale $locale
	} -body {
	    mcload [file join [temporaryDirectory] msgdir]
	} -result $count
	incr count
d223 18
d242 5
a246 61
    # Even though foo_BAR_notexist does not exist,
    # foo_BAR and foo should be loaded.
	test msgcat-5.4 {mcload} -setup {
	    variable locale [mclocale]
	    mclocale foo_BAR_notexist
	} -cleanup {
	    mclocale $locale
	} -body {
	    mcload [file join [temporaryDirectory] msgdir]
	} -result 2

	test msgcat-5.5 {mcload} -setup {
	    variable locale [mclocale]
	    mclocale no_FI_notexist
	} -cleanup {
	    mclocale $locale
	} -body {
	    mcload [file join [temporaryDirectory] msgdir]
	} -result 0

	test msgcat-5.6 {mcload} -setup {
	    variable locale [mclocale]
	    mclocale foo
	} -cleanup {
	    mclocale $locale
	} -body {
	    mc abc
	} -result abc-foo

	test msgcat-5.7 {mcload} -setup {
	    variable locale [mclocale]
	    mclocale foo_BAR
	} -cleanup {
	    mclocale $locale
	} -body {
	    mc abc
	} -result abc-foo_BAR

	test msgcat-5.8 {mcload} -setup {
	    variable locale [mclocale]
	    mclocale foo_BAR_baz
	} -cleanup {
	    mclocale $locale
	} -body {
	    mc abc
	} -result abc-foo_BAR_baz

	test msgcat-5.9 {mcload} -setup {
	    rename ::msgcat::mcunknown SavedMcunknown
	    proc ::msgcat::mcunknown {dom s} {
		return unknown:$dom:$s
	    }
	    variable locale [mclocale]
	    mclocale no_FI_notexist
	} -cleanup {
	    mclocale $locale
	    rename ::msgcat::mcunknown {}
	    rename SavedMcunknown ::msgcat::mcunknown
	} -body {
	    mc abc
	} -result unknown:no_fi_notexist:abc
d248 1
d250 47
a296 2
    foreach loc $locales {
	removeFile [string tolower [file join msgdir $loc.msg]]
d298 13
a310 1
    removeDirectory msgdir
a311 1
    # Tests msgcat-6.*: [mcset], [mc] namespace inheritance
d319 1
a319 1
#     namespaces: foo foo::bar foo::bar::baz
d334 73
a406 37
    variable result
    array set result {
	foo,ov1 ov1_foo foo,ov2 ov2_foo foo,ov3 ov3_foo foo,ov4 ov4
	foo::bar,ov1 ov1_foo foo::bar,ov2 ov2_foo_bar
	foo::bar,ov3 ov3_foo_bar foo::bar,ov4 ov4 foo::bar::baz,ov1 ov1_foo
	foo::bar::baz,ov2 ov2_foo_bar foo::bar::baz,ov3 ov3_foo_bar_baz
	foo::bar::baz,ov4 ov4
    }
    variable count 1
    variable ns
    foreach ns {foo foo::bar foo::bar::baz} {
	foreach string {ov1 ov2 ov3 ov4} {
	    test msgcat-6.$count {mcset, overlap} -setup {
		namespace eval foo {
		    ::msgcat::mcset foo ov1 ov1_foo
		    ::msgcat::mcset foo ov2 ov2_foo
		    ::msgcat::mcset foo ov3 ov3_foo
		    namespace eval bar {
			::msgcat::mcset foo ov2 ov2_foo_bar
			::msgcat::mcset foo ov3 ov3_foo_bar
			namespace eval baz {
			    ::msgcat::mcset foo ov3 "ov3_foo_bar_baz"
			}
		    }
		    
		}
		variable locale [mclocale]
		mclocale foo
	    } -cleanup {
		mclocale $locale
		namespace delete foo
	    } -body {
		namespace eval $ns [list ::msgcat::mc $string]
	    } -result $result($ns,$string)
	    incr count
	}
    }
d408 2
a409 1
    # Tests msgcat-7.*: [mc] extra args processed by [format]
d411 1
a411 51
    test msgcat-7.1 {mc extra args go through to format} -setup {
	mcset foo format1 "this is a test"
	mcset foo format2 "this is a %s"
	mcset foo format3 "this is a %s %s"
	variable locale [mclocale]
	mclocale foo
    } -cleanup {
	mclocale $locale
    } -body {
	mc format1 "good test"
    } -result "this is a test"

    test msgcat-7.2 {mc extra args go through to format} -setup {
	mcset foo format1 "this is a test"
	mcset foo format2 "this is a %s"
	mcset foo format3 "this is a %s %s"
	variable locale [mclocale]
	mclocale foo
    } -cleanup {
	mclocale $locale
    } -body {
	mc format2 "good test"
    } -result "this is a good test"

    test msgcat-7.3 {mc errors from format are propagated} -setup {
	mcset foo format1 "this is a test"
	mcset foo format2 "this is a %s"
	mcset foo format3 "this is a %s %s"
	variable locale [mclocale]
	mclocale foo
    } -cleanup {
	mclocale $locale
    } -body {
	catch {mc format3 "good test"}
    } -result 1

    test msgcat-7.4 {mc, extra args are given to unknown} -setup {
	mcset foo format1 "this is a test"
	mcset foo format2 "this is a %s"
	mcset foo format3 "this is a %s %s"
	variable locale [mclocale]
	mclocale foo
    } -cleanup {
	mclocale $locale
    } -body {
	mc "this is a %s" "good test"
    } -result "this is a good test"

    cleanupTests
}
namespace delete ::msgcat::test
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Tcl 8.3 upgrade
@
text
@@


1.1.1.2
log
@import tcl 8.4.0
@
text
@d1 5
a5 1
# This file contains a collection of tests for the msgcat package.
a10 1
# Contributions from Don Porter, NIST, 2002.  (not subject to US copyright)
d15 6
a20 4
# Note that after running these tests, entries will be left behind in the
# message catalogs for locales foo, foo_BAR, and foo_BAR_baz.
#
# RCS: @@(#) $Id: msgcat.test,v 1.11 2002/06/17 05:37:39 dgp Exp $
d22 12
a33 4
package require Tcl 8.2
if {[catch {package require tcltest 2}]} {
    puts stderr "Skipping tests in [info script].  tcltest 2 required."
    return
d35 9
a43 3
if {[catch {package require msgcat 1.3}]} {
    puts stderr "Skipping tests in [info script].  No msgcat 1.3 found to test."
    return
d46 44
a89 21
namespace eval ::msgcat::test {
    namespace import ::msgcat::*
    namespace import ::tcltest::test
    namespace import ::tcltest::cleanupTests
    namespace import ::tcltest::temporaryDirectory
    namespace import ::tcltest::make*
    namespace import ::tcltest::remove*

    # Tests msgcat-0.*: locale initialization

    proc PowerSet {l} {
	if {[llength $l] == 0} {return [list [list]]}
	set element [lindex $l 0]
	set rest [lrange $l 1 end]
	set result [list]
	foreach x [PowerSet $rest] {
	    lappend result [linsert $x 0 $element]
	    lappend result $x
	}
	return $result
    }
d91 18
a108 38
    variable envVars {LC_ALL LC_MESSAGES LANG}
    variable count 0
    variable body
    variable result
    variable setVars
    foreach setVars [PowerSet $envVars] { 
	set result [string tolower [lindex $setVars 0]]
	if {[string length $result] == 0} {
	    set result c
	}
	test msgcat-0.$count {
	    locale initialization from environment variables
	} -setup {
	    variable var
	    foreach var $envVars {
		catch {variable $var $::env($var)}
		catch {unset ::env($var)}
	    }
	    foreach var $setVars {
		set ::env($var) $var
	    }
	    interp create [namespace current]::i
	    i eval [list package ifneeded msgcat [package provide msgcat] \
		    [package ifneeded msgcat [package provide msgcat]]]
	    i eval package require msgcat
	} -cleanup {
	    interp delete [namespace current]::i
	    foreach var $envVars {
		catch {unset ::env($var)}
		catch {set ::env($var) [set [namespace current]::$var]}
	    }
	} -body {i eval msgcat::mclocale} -result $result
	incr count
    }
    catch {unset result}
    
    # Could add tests of initialization from Windows registry here.
    # Use a fake registry package.
d110 20
a129 1
    # Tests msgcat-1.*: [mclocale], [mcpreferences]
d131 59
a189 204
    test msgcat-1.3 {mclocale set, single element} -setup {
	variable locale [mclocale]
    } -cleanup {
	mclocale $locale
    } -body {
	mclocale en
    } -result en

    test msgcat-1.4 {mclocale get, single element} -setup {
	variable locale [mclocale]
	mclocale en
    } -cleanup {
	mclocale $locale
    } -body {
	mclocale
    } -result en

    test msgcat-1.5 {mcpreferences, single element} -setup {
	variable locale [mclocale]
	mclocale en
    } -cleanup {
	mclocale $locale
    } -body {
	mcpreferences
    } -result en

    test msgcat-1.6 {mclocale set, two elements} -setup {
	variable locale [mclocale]
    } -cleanup {
	mclocale $locale
    } -body {
	mclocale en_US
    } -result en_us

    test msgcat-1.7 {mclocale get, two elements} -setup {
	variable locale [mclocale]
	mclocale en_US
    } -cleanup {
	mclocale $locale
    } -body {
	mclocale
    } -result en_us

    test msgcat-1.8 {mcpreferences, two elements} -setup {
	variable locale [mclocale]
	mclocale en_US
    } -cleanup {
	mclocale $locale
    } -body {
	mcpreferences
    } -result {en_us en}

    test msgcat-1.9 {mclocale set, three elements} -setup {
	variable locale [mclocale]
    } -cleanup {
	mclocale $locale
    } -body {
	mclocale en_US_funky
    } -result en_us_funky

    test msgcat-1.10 {mclocale get, three elements} -setup {
	variable locale [mclocale]
	mclocale en_US_funky
    } -cleanup {
	mclocale $locale
    } -body {
	mclocale
    } -result en_us_funky

    test msgcat-1.11 {mcpreferences, three elements} -setup {
	variable locale [mclocale]
	mclocale en_US_funky
    } -cleanup {
	mclocale $locale
    } -body {
	mcpreferences
    } -result {en_us_funky en_us en}

    # Tests msgcat-2.*: [mcset], [mcmset], namespace partitioning

    test msgcat-2.1 {mcset, global scope} {
	namespace eval :: ::msgcat::mcset  foo_BAR text1 text2
    } {text2}

    test msgcat-2.2 {mcset, global scope, default} {
	namespace eval :: ::msgcat::mcset foo_BAR text3
    } {text3}

    test msgcat-2.2 {mcset, namespace overlap} {
	namespace eval baz {::msgcat::mcset  foo_BAR con1 con1baz}
    } {con1baz}

    test msgcat-2.3 {mcset, namespace overlap} -setup {
	namespace eval bar {::msgcat::mcset  foo_BAR con1 con1bar}
	namespace eval baz {::msgcat::mcset  foo_BAR con1 con1baz}
	variable locale [mclocale]
	mclocale foo_BAR
    } -cleanup {
	mclocale $locale
    } -body {
	namespace eval bar {::msgcat::mc con1}
    } -result con1bar

    test msgcat-2.4 {mcset, namespace overlap} -setup {
	namespace eval bar {::msgcat::mcset  foo_BAR con1 con1bar}
	namespace eval baz {::msgcat::mcset  foo_BAR con1 con1baz}
	variable locale [mclocale]
	mclocale foo_BAR
    } -cleanup {
	mclocale $locale
    } -body {
	namespace eval baz {::msgcat::mc con1}
    } -result con1baz

    test msgcat-2.5 {mcmset, global scope} -setup {
	namespace eval :: {
	    ::msgcat::mcmset  foo_BAR {
	        src1 trans1
	        src2 trans2
	    }
	}
	variable locale [mclocale]
	mclocale foo_BAR
    } -cleanup {
	mclocale $locale
    } -body {
	namespace eval :: {
	    ::msgcat::mc src1
	}
    } -result trans1

    test msgcat-2.6 {mcmset, namespace overlap} -setup {
	namespace eval bar {::msgcat::mcmset  foo_BAR {con2 con2bar}}
	namespace eval baz {::msgcat::mcmset  foo_BAR {con2 con2baz}}
	variable locale [mclocale]
	mclocale foo_BAR
    } -cleanup {
	mclocale $locale
    } -body {
	namespace eval bar {::msgcat::mc con2}
    } -result con2bar

    test msgcat-2.7 {mcmset, namespace overlap} -setup {
	namespace eval bar {::msgcat::mcmset  foo_BAR {con2 con2bar}}
	namespace eval baz {::msgcat::mcmset  foo_BAR {con2 con2baz}}
	variable locale [mclocale]
	mclocale foo_BAR
    } -cleanup {
	mclocale $locale
    } -body {
	namespace eval baz {::msgcat::mc con2}
    } -result con2baz

    # Tests msgcat-3.*: [mcset], [mc], catalog "inheritance"
    #
    # Test mcset and mc, ensuring that more specific locales
    # (e.g. en_UK) will search less specific locales
    # (e.g. en) for translation strings.
    #
    # Do this for the 12 permutations of
    #     locales: {foo foo_BAR foo_BAR_baz}
    #     strings: {ov1 ov2 ov3 ov4}
    #     locale foo         defines ov1, ov2, ov3
    #     locale foo_BAR     defines      ov2, ov3
    #     locale foo_BAR_BAZ defines           ov3
    #     (ov4 is defined in none)
    # So,
    #     ov3 should be resolved in foo, foo_BAR, foo_BAR_baz
    #     ov2 should be resolved in foo, foo_BAR
    #     ov2 should resolve to foo_BAR in foo_BAR_baz
    #     ov1 should be resolved in foo
    #     ov1 should resolve to foo in foo_BAR, foo_BAR_baz
    #     ov4 should be resolved in none, and call mcunknown
    #
    variable count 2
    variable result
    array set result {
	foo,ov1 ov1_foo foo,ov2 ov2_foo foo,ov3 ov3_foo foo,ov4 ov4
	foo_BAR,ov1 ov1_foo foo_BAR,ov2 ov2_foo_BAR foo_BAR,ov3 ov3_foo_BAR
	foo_BAR,ov4 ov4 foo_BAR_baz,ov1 ov1_foo foo_BAR_baz,ov2 ov2_foo_BAR
	foo_BAR_baz,ov3 ov3_foo_BAR_baz foo_BAR_baz,ov4 ov4
    }
    variable loc
    variable string
    foreach loc {foo foo_BAR foo_BAR_baz} {
	foreach string {ov1 ov2 ov3 ov4} {
	    test msgcat-3.$count {mcset, overlap} -setup {
		mcset foo ov1 ov1_foo
		mcset foo ov2 ov2_foo
		mcset foo ov3 ov3_foo
		mcset foo_BAR ov2 ov2_foo_BAR
		mcset foo_BAR ov3 ov3_foo_BAR
		mcset foo_BAR_baz ov3 ov3_foo_BAR_baz
		variable locale [mclocale]
		mclocale $loc
	    } -cleanup {
		mclocale $locale
	    } -body {
		mc $string
	    } -result $result($loc,$string)
	    incr count
	}
    }
    catch {unset result}
d191 4
a194 1
    # Tests msgcat-4.*: [mcunknown]
d196 15
a210 75
    test msgcat-4.2 {mcunknown, default} -setup {
	mcset foo unk1 "unknown 1"
	variable locale [mclocale]
	mclocale foo
    } -cleanup {
	mclocale $locale
    } -body {
	mc unk1
    } -result {unknown 1}

    test msgcat-4.3 {mcunknown, default} -setup {
	mcset foo unk1 "unknown 1"
	variable locale [mclocale]
	mclocale foo
    } -cleanup {
	mclocale $locale
    } -body {
	mc unk2
    } -result unk2

    test msgcat-4.4 {mcunknown, overridden} -setup {
	rename ::msgcat::mcunknown SavedMcunknown
	proc ::msgcat::mcunknown {dom s} {
            return unknown:$dom:$s
	}
	mcset foo unk1 "unknown 1"
	variable locale [mclocale]
	mclocale foo
    } -cleanup {
	mclocale $locale
	rename ::msgcat::mcunknown {}
	rename SavedMcunknown ::msgcat::mcunknown
    } -body {
	mc unk1
    } -result {unknown 1}

    test msgcat-4.5 {mcunknown, overridden} -setup {
	rename ::msgcat::mcunknown SavedMcunknown
	proc ::msgcat::mcunknown {dom s} {
            return unknown:$dom:$s
	}
	mcset foo unk1 "unknown 1"
	variable locale [mclocale]
	mclocale foo
    } -cleanup {
	mclocale $locale
	rename ::msgcat::mcunknown {}
	rename SavedMcunknown ::msgcat::mcunknown
    } -body {
	mc unk2
    } -result {unknown:foo:unk2}

    test msgcat-4.6 {mcunknown, uplevel context} -setup {
	rename ::msgcat::mcunknown SavedMcunknown
	proc ::msgcat::mcunknown {dom s} {
            return "unknown:$dom:$s:[expr {[info level] - 1}]"
	}
	mcset foo unk1 "unknown 1"
	variable locale [mclocale]
	mclocale foo
    } -cleanup {
	mclocale $locale
	rename ::msgcat::mcunknown {}
	rename SavedMcunknown ::msgcat::mcunknown
    } -body {
	mc unk2
    } -result unknown:foo:unk2:[info level]

    # Tests msgcat-5.*: [mcload]

    variable locales {foo foo_BAR foo_BAR_baz}
    makeDirectory msgdir
    foreach loc $locales {
	makeFile "::msgcat::mcset $loc abc abc-$loc" \
		[string tolower [file join msgdir $loc.msg]]
d212 10
a221 11
    variable count 1
    foreach loc {foo foo_BAR foo_BAR_baz} {
	test msgcat-5.$count {mcload} -setup {
	    variable locale [mclocale]
	    mclocale $loc
	} -cleanup {
	    mclocale $locale
	} -body {
	    mcload [file join [temporaryDirectory] msgdir]
	} -result $count
	incr count
d223 18
d242 5
a246 61
    # Even though foo_BAR_notexist does not exist,
    # foo_BAR and foo should be loaded.
	test msgcat-5.4 {mcload} -setup {
	    variable locale [mclocale]
	    mclocale foo_BAR_notexist
	} -cleanup {
	    mclocale $locale
	} -body {
	    mcload [file join [temporaryDirectory] msgdir]
	} -result 2

	test msgcat-5.5 {mcload} -setup {
	    variable locale [mclocale]
	    mclocale no_FI_notexist
	} -cleanup {
	    mclocale $locale
	} -body {
	    mcload [file join [temporaryDirectory] msgdir]
	} -result 0

	test msgcat-5.6 {mcload} -setup {
	    variable locale [mclocale]
	    mclocale foo
	} -cleanup {
	    mclocale $locale
	} -body {
	    mc abc
	} -result abc-foo

	test msgcat-5.7 {mcload} -setup {
	    variable locale [mclocale]
	    mclocale foo_BAR
	} -cleanup {
	    mclocale $locale
	} -body {
	    mc abc
	} -result abc-foo_BAR

	test msgcat-5.8 {mcload} -setup {
	    variable locale [mclocale]
	    mclocale foo_BAR_baz
	} -cleanup {
	    mclocale $locale
	} -body {
	    mc abc
	} -result abc-foo_BAR_baz

	test msgcat-5.9 {mcload} -setup {
	    rename ::msgcat::mcunknown SavedMcunknown
	    proc ::msgcat::mcunknown {dom s} {
		return unknown:$dom:$s
	    }
	    variable locale [mclocale]
	    mclocale no_FI_notexist
	} -cleanup {
	    mclocale $locale
	    rename ::msgcat::mcunknown {}
	    rename SavedMcunknown ::msgcat::mcunknown
	} -body {
	    mc abc
	} -result unknown:no_fi_notexist:abc
d248 1
d250 47
a296 2
    foreach loc $locales {
	removeFile [string tolower [file join msgdir $loc.msg]]
d298 13
a310 1
    removeDirectory msgdir
a311 1
    # Tests msgcat-6.*: [mcset], [mc] namespace inheritance
d319 1
a319 1
#     namespaces: foo foo::bar foo::bar::baz
d334 73
a406 37
    variable result
    array set result {
	foo,ov1 ov1_foo foo,ov2 ov2_foo foo,ov3 ov3_foo foo,ov4 ov4
	foo::bar,ov1 ov1_foo foo::bar,ov2 ov2_foo_bar
	foo::bar,ov3 ov3_foo_bar foo::bar,ov4 ov4 foo::bar::baz,ov1 ov1_foo
	foo::bar::baz,ov2 ov2_foo_bar foo::bar::baz,ov3 ov3_foo_bar_baz
	foo::bar::baz,ov4 ov4
    }
    variable count 1
    variable ns
    foreach ns {foo foo::bar foo::bar::baz} {
	foreach string {ov1 ov2 ov3 ov4} {
	    test msgcat-6.$count {mcset, overlap} -setup {
		namespace eval foo {
		    ::msgcat::mcset foo ov1 ov1_foo
		    ::msgcat::mcset foo ov2 ov2_foo
		    ::msgcat::mcset foo ov3 ov3_foo
		    namespace eval bar {
			::msgcat::mcset foo ov2 ov2_foo_bar
			::msgcat::mcset foo ov3 ov3_foo_bar
			namespace eval baz {
			    ::msgcat::mcset foo ov3 "ov3_foo_bar_baz"
			}
		    }
		    
		}
		variable locale [mclocale]
		mclocale foo
	    } -cleanup {
		mclocale $locale
		namespace delete foo
	    } -body {
		namespace eval $ns [list ::msgcat::mc $string]
	    } -result $result($ns,$string)
	    incr count
	}
    }
d408 2
a409 1
    # Tests msgcat-7.*: [mc] extra args processed by [format]
d411 1
a411 51
    test msgcat-7.1 {mc extra args go through to format} -setup {
	mcset foo format1 "this is a test"
	mcset foo format2 "this is a %s"
	mcset foo format3 "this is a %s %s"
	variable locale [mclocale]
	mclocale foo
    } -cleanup {
	mclocale $locale
    } -body {
	mc format1 "good test"
    } -result "this is a test"

    test msgcat-7.2 {mc extra args go through to format} -setup {
	mcset foo format1 "this is a test"
	mcset foo format2 "this is a %s"
	mcset foo format3 "this is a %s %s"
	variable locale [mclocale]
	mclocale foo
    } -cleanup {
	mclocale $locale
    } -body {
	mc format2 "good test"
    } -result "this is a good test"

    test msgcat-7.3 {mc errors from format are propagated} -setup {
	mcset foo format1 "this is a test"
	mcset foo format2 "this is a %s"
	mcset foo format3 "this is a %s %s"
	variable locale [mclocale]
	mclocale foo
    } -cleanup {
	mclocale $locale
    } -body {
	catch {mc format3 "good test"}
    } -result 1

    test msgcat-7.4 {mc, extra args are given to unknown} -setup {
	mcset foo format1 "this is a test"
	mcset foo format2 "this is a %s"
	mcset foo format3 "this is a %s %s"
	variable locale [mclocale]
	mclocale foo
    } -cleanup {
	mclocale $locale
    } -body {
	mc "this is a %s" "good test"
    } -result "this is a good test"

    cleanupTests
}
namespace delete ::msgcat::test
@

