head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.58
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.56
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.54
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.52
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.50
	gdb_7_0-branch:1.5.0.48
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tcl8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.46
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.44
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.42
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.40
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.38
	gdb_6_5-2006-05-14-branchpoint:1.5
	readline_5_1-import-branch:1.5.0.36
	readline_5_1-import-branchpoint:1.5
	gdb_6_4-branch:1.5.0.34
	gdb_6_4-2005-11-01-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.32
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	ezannoni_pie-20040323-branch:1.5.0.30
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.28
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.26
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.24
	cagney_x86i386-20030821-branch:1.5.0.22
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.20
	gdb_6_0-2003-06-23-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.18
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.16
	cagney_writestrings-20030508-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.14
	cagney_fileio-20030521-branchpoint:1.5
	carlton_dictionary-20030430-merge:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.12
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.10
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.8
	cagney_lazyid-20030317-branchpoint:1.5
	offbyone-20030313-branch:1.5.0.6
	offbyone-20030313-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.4
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.2
	interps-20030202-branchpoint:1.5
	TCL8_4_1:1.1.1.3
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.2
	TCL_8_4_1:1.1.1.3
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.4
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TCL_8_4_0:1.1.1.3
	carlton_dictionary-branch:1.2.0.16
	carlton_dictionary-20020920-branchpoint:1.2
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.14
	gdb_5_3-branch:1.2.0.12
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.10
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.8
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.6
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TCL_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	dejagnu-2000-02-04:1.1.1.1
	dejagnu-2000-01-31:1.1.1.1
	dejagnu-2000-01-24:1.1.1.1
	dejagnu-2000-01-17:1.1.1.1
	dejagnu-2000-01-10:1.1.1.1
	dejagnu-2000-01-04:1.1.1.1
	dejagnu-1999-12-21:1.1.1.1
	dejagnu-1999-12-13:1.1.1.1
	dejagnu-1999-12-07:1.1.1.1
	dejagnu-1999-12-06:1.1.1.1
	dejagnu-1999-11-15:1.1.1.1
	dejagnu-1999-11-08:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2003.01.21.19.40.17;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.26.19.48.03;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.37.08;	author kseitz;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2001.09.09.23.56.08;	author irox;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2002.09.27.21.49.11;	author kseitz;	state Exp;
branches;
next	;

1.3.4.1
date	2003.12.14.20.28.50;	author drow;	state Exp;
branches;
next	;

1.2.16.1
date	2002.12.23.19.40.45;	author carlton;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2003.02.07.19.18.20;	author carlton;	state Exp;
branches;
next	;

1.1.1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.09.22.40.59;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.19.56.41;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tcl 8.4.1
@
text
@# This file tests the tclUnixFCmd.c file.
#
# This file contains a collection of tests for one or more of the Tcl
# built-in commands.  Sourcing this file into Tcl runs the tests and
# generates output for errors.  No output means no errors were found.
#
# Copyright (c) 1996 Sun Microsystems, Inc.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# RCS: @@(#) $Id: unixFCmd.test,v 1.16 2002/08/08 10:41:22 hobbs Exp $

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import -force ::tcltest::*
}

# These tests really need to be run from a writable directory, which
# it is assumed [temporaryDirectory] is.
set oldcwd [pwd]
cd [temporaryDirectory]

# Several tests require need to match results against the unix username
set user {}
if {$tcl_platform(platform) == "unix"} {
    catch {set user [exec whoami]}
    if {$user == ""} {
	catch {regexp {^[^(]*\(([^)]*)\)} [exec id] dummy user}
    }
    if {$user == ""} {
	set user "root"
    }
}

proc openup {path} {
    testchmod 777 $path
    if {[file isdirectory $path]} {
	catch {
	    foreach p [glob -directory $path *] {
		openup $p
	    }
	}
    }
}

proc cleanup {args} {
    foreach p ". $args" {
	set x ""
	catch {
	    set x [glob -directory $p tf* td*]
	}
	foreach file $x {
	    if {[catch {file delete -force -- $file}]} {
		openup $file
		file delete -force -- $file
	    }
	}
    }
}

test unixFCmd-1.1 {TclpRenameFile: EACCES} {unixOnly notRoot} {
    cleanup
    file mkdir td1/td2/td3
    file attributes td1/td2 -permissions 0000
    set msg [list [catch {file rename td1/td2/td3 td2} msg] $msg]
    file attributes td1/td2 -permissions 0755
    set msg
} {1 {error renaming "td1/td2/td3": permission denied}}
test unixFCmd-1.2 {TclpRenameFile: EEXIST} {unixOnly notRoot} {
    cleanup
    file mkdir td1/td2
    file mkdir td2
    list [catch {file rename td2 td1} msg] $msg
} {1 {error renaming "td2" to "td1/td2": file already exists}}
test unixFCmd-1.3 {TclpRenameFile: EINVAL} {unixOnly notRoot} {
    cleanup
    file mkdir td1
    list [catch {file rename td1 td1} msg] $msg
} {1 {error renaming "td1" to "td1/td1": trying to rename a volume or move a directory into itself}}
test unixFCmd-1.4 {TclpRenameFile: EISDIR} {emptyTest unixOnly notRoot} {
    # can't make it happen
} {}
test unixFCmd-1.5 {TclpRenameFile: ENOENT} {unixOnly notRoot} {
    cleanup
    file mkdir td1
    list [catch {file rename td2 td1} msg] $msg
} {1 {error renaming "td2": no such file or directory}}
test unixFCmd-1.6 {TclpRenameFile: ENOTDIR} {emptyTest unixOnly notRoot} {
    # can't make it happen
} {}
test unixFCmd-1.7 {TclpRenameFile: EXDEV} {unixOnly notRoot} {
    cleanup
    file mkdir foo/bar
    file attr foo -perm 040555
    set catchResult [catch {file rename foo/bar /tmp} msg]
    set msg [lindex [split $msg :] end]
    catch {file delete /tmp/bar}
    catch {file attr foo -perm 040777}
    catch {file delete -force foo}
    list $catchResult $msg
} {1 { permission denied}}
test unixFCmd-1.8 {Checking EINTR Bug} {unixOnly notRoot nonPortable} {
    testalarm 
    after 2000
    list [testgotsig] [testgotsig]
} {1 0}
test unixFCmd-1.9 {Checking EINTR Bug} {unixOnly notRoot nonPortable} {
    cleanup
    set f [open tfalarm w]
    puts $f {
	after 2000
	puts "hello world"
	exit 0
    }
    close $f
    testalarm 
    set pipe [open "|[info nameofexecutable] tfalarm" r+]
    set line [read $pipe 1]
    catch {close $pipe}
    list $line [testgotsig]
} {h 1}
test unixFCmd-2.1 {TclpCopyFile: target exists: lstat(dst) == 0} \
	{unixOnly notRoot} {
    cleanup
    close [open tf1 a]
    close [open tf2 a]
    file copy -force tf1 tf2
} {}
test unixFCmd-2.2.1 {TclpCopyFile: src is symlink} {unixOnly notRoot dontCopyLinks} {
    # copying links should end up with real files
    cleanup
    close [open tf1 a]
    file link -symbolic tf2 tf1
    file copy tf2 tf3
    file type tf3
} {file}
test unixFCmd-2.2.2 {TclpCopyFile: src is symlink} {unixOnly notRoot} {
    # copying links should end up with the links copied
    cleanup
    close [open tf1 a]
    file link -symbolic tf2 tf1
    file copy tf2 tf3
    file type tf3
} {link}
test unixFCmd-2.3 {TclpCopyFile: src is block} {unixOnly notRoot} {
    cleanup
    set null "/dev/null"
    while {[file type $null] != "characterSpecial"} {
	set null [file join [file dirname $null] [file readlink $null]]
    }
    # file copy $null tf1
} {}
test unixFCmd-2.4 {TclpCopyFile: src is fifo} {unixOnly notRoot} {
    cleanup
    if [catch {exec mknod tf1 p}] {
	list 1
    } else {
	file copy tf1 tf2
	expr {"[file type tf1]" == "[file type tf2]"}
    }
} {1}
test unixFCmd-2.5 {TclpCopyFile: copy attributes} {unixOnly notRoot} {
    cleanup
    close [open tf1 a]
    file attributes tf1 -permissions 0472
    file copy tf1 tf2
    file attributes tf2 -permissions
} 00472 ;# i.e. perms field of [exec ls -l tf2] is -r--rwx-w-

test unixFCmd-3.1 {CopyFile not done} {emptyTest unixOnly notRoot} {
} {}

test unixFCmd-4.1 {TclpDeleteFile not done} {emptyTest unixOnly notRoot} {
} {}

test unixFCmd-5.1 {TclpCreateDirectory not done} {emptyTest unixOnly notRoot} {
} {}

test unixFCmd-6.1 {TclpCopyDirectory not done} {emptyTest unixOnly notRoot} {
} {}

test unixFCmd-7.1 {TclpRemoveDirectory not done} {emptyTest unixOnly notRoot} {
} {}

test unixFCmd-8.1 {TraverseUnixTree not done} {emptyTest unixOnly notRoot} {
} {}

test unixFCmd-9.1 {TraversalCopy not done} {emptyTest unixOnly notRoot} {
} {}

test unixFCmd-10.1 {TraversalDelete not done} {emptyTest unixOnly notRoot} {
} {}

test unixFCmd-11.1 {CopyFileAttrs not done} {emptyTest unixOnly notRoot} {
} {}

test unixFCmd-12.1 {GetGroupAttribute - file not found} {unixOnly notRoot} {
    catch {file delete -force -- foo.test}
    list [catch {file attributes foo.test -group} msg] $msg
} {1 {could not read "foo.test": no such file or directory}}
test unixFCmd-12.2 {GetGroupAttribute - file found} {unixOnly notRoot} {
    catch {file delete -force -- foo.test}
    close [open foo.test w]
    list [catch {file attributes foo.test -group}] [file delete -force -- foo.test]
} {0 {}}

test unixFCmd-13.1 {GetOwnerAttribute - file not found} {unixOnly notRoot} {
    catch {file delete -force -- foo.test}
    list [catch {file attributes foo.test -group} msg] $msg
} {1 {could not read "foo.test": no such file or directory}}
test unixFCmd-13.2 {GetOwnerAttribute} {unixOnly notRoot} {
    catch {file delete -force -- foo.test}
    close [open foo.test w]
    list [catch {file attributes foo.test -owner} msg] \
	    [string compare $msg $user] [file delete -force -- foo.test]
} {0 0 {}}

test unixFCmd-14.1 {GetPermissionsAttribute - file not found} {unixOnly notRoot} {
    catch {file delete -force -- foo.test}
    list [catch {file attributes foo.test -permissions} msg] $msg
} {1 {could not read "foo.test": no such file or directory}}
test unixFCmd-14.2 {GetPermissionsAttribute} {unixOnly notRoot} {
    catch {file delete -force -- foo.test}
    close [open foo.test w]
    list [catch {file attribute foo.test -permissions}] \
	    [file delete -force -- foo.test]
} {0 {}}

# Find a group that exists on this system, or else skip tests that require
# groups
set ::tcltest::testConstraints(foundGroup) 0
catch {
    set groupList [exec groups]
    set group [lindex $groupList 0]
    set ::tcltest::testConstraints(foundGroup) 1
}

#groups hard to test
test unixFCmd-15.1 {SetGroupAttribute - invalid group} {unixOnly notRoot} {
    catch {file delete -force -- foo.test}
    list [catch {file attributes foo.test -group foozzz} msg] \
	    $msg [file delete -force -- foo.test]
} {1 {could not set group for file "foo.test": group "foozzz" does not exist} {}}
test unixFCmd-15.2 {SetGroupAttribute - invalid file} \
	{unixOnly notRoot foundGroup} {
    catch {file delete -force -- foo.test}
    list [catch {file attributes foo.test -group $group} msg] $msg
} {1 {could not set group for file "foo.test": no such file or directory}}

#changing owners hard to do
test unixFCmd-16.1 {SetOwnerAttribute - current owner} {unixOnly notRoot} {
    catch {file delete -force -- foo.test}
    close [open foo.test w]
    list [catch {file attributes foo.test -owner $user} msg] \
	    $msg [string compare [file attributes foo.test -owner] $user] \
	    [file delete -force -- foo.test]
} {0 {} 0 {}}
test unixFCmd-16.2 {SetOwnerAttribute - invalid file} {unixOnly notRoot} {
    catch {file delete -force -- foo.test}
    list [catch {file attributes foo.test -owner $user} msg] $msg
} {1 {could not set owner for file "foo.test": no such file or directory}}
test unixFCmd-16.3 {SetOwnerAttribute - invalid owner} {unixOnly notRoot} {
    catch {file delete -force -- foo.test}
    list [catch {file attributes foo.test -owner foozzz} msg] $msg
} {1 {could not set owner for file "foo.test": user "foozzz" does not exist}}


test unixFCmd-17.1 {SetPermissionsAttribute} {unixOnly notRoot} {
    catch {file delete -force -- foo.test}
    close [open foo.test w]
    list [catch {file attributes foo.test -permissions 0000} msg] \
	    $msg [file attributes foo.test -permissions] \
	    [file delete -force -- foo.test]
} {0 {} 00000 {}}
test unixFCmd-17.2 {SetPermissionsAttribute} {unixOnly notRoot} {
    catch {file delete -force -- foo.test}
    list [catch {file attributes foo.test -permissions 0000} msg] $msg
} {1 {could not set permissions for file "foo.test": no such file or directory}}
test unixFCmd-17.3 {SetPermissionsAttribute} {unixOnly notRoot} {
    catch {file delete -force -- foo.test}
    close [open foo.test w]
    list [catch {file attributes foo.test -permissions foo} msg] $msg \
	    [file delete -force -- foo.test]
} {1 {unknown permission string format "foo"} {}}
test unixFCmd-17.3 {SetPermissionsAttribute} {unixOnly notRoot} {
    catch {file delete -force -- foo.test}
    close [open foo.test w]
    list [catch {file attributes foo.test -permissions ---rwx} msg] $msg \
	    [file delete -force -- foo.test]
} {1 {unknown permission string format "---rwx"} {}}

close [open foo.test w]
set ::i 4
proc permcheck {testnum permstr expected} {
    test $testnum {SetPermissionsAttribute} {unixOnly notRoot} {
	file attributes foo.test -permissions $permstr
	file attributes foo.test -permissions
    } $expected
}
permcheck unixFCmd-17.4   rwxrwxrwx	00777
permcheck unixFCmd-17.5   r--r---w-	00442
permcheck unixFCmd-17.6   0		00000
permcheck unixFCmd-17.7   u+rwx,g+r	00740
permcheck unixFCmd-17.8   u-w		00540
permcheck unixFCmd-17.9   o+rwx		00547
permcheck unixFCmd-17.10  --x--x--x	00111
permcheck unixFCmd-17.11  a+rwx		00777
file delete -force -- foo.test

test unixFCmd-18.1 {Unix pwd} {nonPortable unixOnly notRoot} {
    # This test is nonportable because SunOS generates a weird error
    # message when the current directory isn't readable.
    set cd [pwd]
    set nd $cd/tstdir
    file mkdir $nd
    cd $nd
    file attributes $nd -permissions 0000
    set r [list [catch {pwd} res] [string range $res 0 36]];
    cd $cd;
    file attributes $nd -permissions 0755
    file delete $nd
    set r
} {1 {error getting working directory name:}}

# cleanup
cleanup
cd $oldcwd
::tcltest::cleanupTests
return
@


1.4
log
@touched all sources to ease next import
@
text
@d12 1
a12 1
# RCS: @@(#) $Id: unixFCmd.test,v 1.6.8.2 2000/09/15 16:57:46 spolk Exp $
d19 5
d40 1
a40 1
	    foreach p [glob [file join $path *]] {
d51 1
a51 1
	    set x [glob [file join $p tf*] [file join $p td*]]
d65 1
a65 1
    exec chmod 000 td1/td2
d67 1
a67 1
    exec chmod 755 td1/td2
d126 2
a127 2
    exec touch tf1
    exec touch tf2
d130 2
a131 1
test unixFCmd-2.2 {TclpCopyFile: src is symlink} {unixOnly notRoot} {
d133 10
a142 1
    exec ln -s tf1 tf2
d165 2
a166 2
    exec touch tf1
    exec chmod 472 tf1
d168 2
a169 2
    string range [exec ls -l tf2] 0 9
} {-r--rwx-w-}
d295 2
a296 3
proc permcheck {permstr expected} {
    test unixFCmd-17.[incr ::i] {SetPermissionsAttribute} {unixOnly notRoot} \
	    [subst {
d299 1
a299 2
    }
    ] $expected
d301 8
a308 8
permcheck rwxrwxrwx	00777
permcheck r--r---w-	00442
permcheck 0		00000
permcheck u+rwx,g+r	00740
permcheck u-w		00540
permcheck o+rwx		00547
permcheck --x--x--x	00111
permcheck a+rwx		00777
d318 1
a318 1
    exec chmod 000 $nd
d321 1
a321 1
    exec chmod 755 $nd
d328 1
a330 13













@


1.3
log
@touched all sources to ease next import
@
text
@@


1.3.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d12 1
a12 1
# RCS: @@(#) $Id: unixFCmd.test,v 1.16 2002/08/08 10:41:22 hobbs Exp $
a18 5
# These tests really need to be run from a writable directory, which
# it is assumed [temporaryDirectory] is.
set oldcwd [pwd]
cd [temporaryDirectory]

d35 1
a35 1
	    foreach p [glob -directory $path *] {
d46 1
a46 1
	    set x [glob -directory $p tf* td*]
d60 1
a60 1
    file attributes td1/td2 -permissions 0000
d62 1
a62 1
    file attributes td1/td2 -permissions 0755
d121 2
a122 2
    close [open tf1 a]
    close [open tf2 a]
d125 1
a125 2
test unixFCmd-2.2.1 {TclpCopyFile: src is symlink} {unixOnly notRoot dontCopyLinks} {
    # copying links should end up with real files
d127 1
a127 10
    close [open tf1 a]
    file link -symbolic tf2 tf1
    file copy tf2 tf3
    file type tf3
} {file}
test unixFCmd-2.2.2 {TclpCopyFile: src is symlink} {unixOnly notRoot} {
    # copying links should end up with the links copied
    cleanup
    close [open tf1 a]
    file link -symbolic tf2 tf1
d150 2
a151 2
    close [open tf1 a]
    file attributes tf1 -permissions 0472
d153 2
a154 2
    file attributes tf2 -permissions
} 00472 ;# i.e. perms field of [exec ls -l tf2] is -r--rwx-w-
d280 3
a282 2
proc permcheck {testnum permstr expected} {
    test $testnum {SetPermissionsAttribute} {unixOnly notRoot} {
d285 2
a286 1
    } $expected
d288 8
a295 8
permcheck unixFCmd-17.4   rwxrwxrwx	00777
permcheck unixFCmd-17.5   r--r---w-	00442
permcheck unixFCmd-17.6   0		00000
permcheck unixFCmd-17.7   u+rwx,g+r	00740
permcheck unixFCmd-17.8   u-w		00540
permcheck unixFCmd-17.9   o+rwx		00547
permcheck unixFCmd-17.10  --x--x--x	00111
permcheck unixFCmd-17.11  a+rwx		00777
d305 1
a305 1
    file attributes $nd -permissions 0000
d308 1
a308 1
    file attributes $nd -permissions 0755
a314 1
cd $oldcwd
d317 13
@


1.3.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@d12 1
a12 1
# RCS: @@(#) $Id: unixFCmd.test,v 1.16 2002/08/08 10:41:22 hobbs Exp $
a18 5
# These tests really need to be run from a writable directory, which
# it is assumed [temporaryDirectory] is.
set oldcwd [pwd]
cd [temporaryDirectory]

d35 1
a35 1
	    foreach p [glob -directory $path *] {
d46 1
a46 1
	    set x [glob -directory $p tf* td*]
d60 1
a60 1
    file attributes td1/td2 -permissions 0000
d62 1
a62 1
    file attributes td1/td2 -permissions 0755
d121 2
a122 2
    close [open tf1 a]
    close [open tf2 a]
d125 1
a125 2
test unixFCmd-2.2.1 {TclpCopyFile: src is symlink} {unixOnly notRoot dontCopyLinks} {
    # copying links should end up with real files
d127 1
a127 10
    close [open tf1 a]
    file link -symbolic tf2 tf1
    file copy tf2 tf3
    file type tf3
} {file}
test unixFCmd-2.2.2 {TclpCopyFile: src is symlink} {unixOnly notRoot} {
    # copying links should end up with the links copied
    cleanup
    close [open tf1 a]
    file link -symbolic tf2 tf1
d150 2
a151 2
    close [open tf1 a]
    file attributes tf1 -permissions 0472
d153 2
a154 2
    file attributes tf2 -permissions
} 00472 ;# i.e. perms field of [exec ls -l tf2] is -r--rwx-w-
d280 3
a282 2
proc permcheck {testnum permstr expected} {
    test $testnum {SetPermissionsAttribute} {unixOnly notRoot} {
d285 2
a286 1
    } $expected
d288 8
a295 8
permcheck unixFCmd-17.4   rwxrwxrwx	00777
permcheck unixFCmd-17.5   r--r---w-	00442
permcheck unixFCmd-17.6   0		00000
permcheck unixFCmd-17.7   u+rwx,g+r	00740
permcheck unixFCmd-17.8   u-w		00540
permcheck unixFCmd-17.9   o+rwx		00547
permcheck unixFCmd-17.10  --x--x--x	00111
permcheck unixFCmd-17.11  a+rwx		00777
d305 1
a305 1
    file attributes $nd -permissions 0000
d308 1
a308 1
    file attributes $nd -permissions 0755
a314 1
cd $oldcwd
d317 13
@


1.2
log
@touched all Tcl files to ease next import.
@
text
@@


1.2.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.2.16.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@a18 5
# These tests really need to be run from a writable directory, which
# it is assumed [temporaryDirectory] is.
set oldcwd [pwd]
cd [temporaryDirectory]

d35 1
a35 1
	    foreach p [glob -directory $path *] {
d46 1
a46 1
	    set x [glob -directory $p tf* td*]
d60 1
a60 1
    file attributes td1/td2 -permissions 0000
d62 1
a62 1
    file attributes td1/td2 -permissions 0755
d121 2
a122 2
    close [open tf1 a]
    close [open tf2 a]
d125 1
a125 2
test unixFCmd-2.2.1 {TclpCopyFile: src is symlink} {unixOnly notRoot dontCopyLinks} {
    # copying links should end up with real files
d127 1
a127 10
    close [open tf1 a]
    file link -symbolic tf2 tf1
    file copy tf2 tf3
    file type tf3
} {file}
test unixFCmd-2.2.2 {TclpCopyFile: src is symlink} {unixOnly notRoot} {
    # copying links should end up with the links copied
    cleanup
    close [open tf1 a]
    file link -symbolic tf2 tf1
d150 2
a151 2
    close [open tf1 a]
    file attributes tf1 -permissions 0472
d153 2
a154 2
    file attributes tf2 -permissions
} 00472 ;# i.e. perms field of [exec ls -l tf2] is -r--rwx-w-
d280 3
a282 2
proc permcheck {testnum permstr expected} {
    test $testnum {SetPermissionsAttribute} {unixOnly notRoot} {
d285 2
a286 1
    } $expected
d288 8
a295 8
permcheck unixFCmd-17.4   rwxrwxrwx	00777
permcheck unixFCmd-17.5   r--r---w-	00442
permcheck unixFCmd-17.6   0		00000
permcheck unixFCmd-17.7   u+rwx,g+r	00740
permcheck unixFCmd-17.8   u-w		00540
permcheck unixFCmd-17.9   o+rwx		00547
permcheck unixFCmd-17.10  --x--x--x	00111
permcheck unixFCmd-17.11  a+rwx		00777
d305 1
a305 1
    file attributes $nd -permissions 0000
d308 1
a308 1
    file attributes $nd -permissions 0755
a314 1
cd $oldcwd
d317 13
@


1.1
log
@Initial revision
@
text
@d12 1
a12 1
# RCS: @@(#) $Id: unixFCmd.test,v 1.9 1999/01/26 03:53:34 jingham Exp $
d14 3
a16 4
if {[string compare test [info procs test]] == 1} then {source defs}

if {$tcl_platform(platform) != "unix"} {
    return
d19 10
a28 4
if {$user == "root"} {
    puts "Skipping unixFCmd tests.  They depend on not being able to write to"
    puts "certain directories.  It would be too dangerous to run them as root."
    return
d57 1
a57 1
test unixFCmd-1.1 {TclpRenameFile: EACCES} {
d65 1
a65 1
test unixFCmd-1.2 {TclpRenameFile: EEXIST} {
d71 1
a71 1
test unixFCmd-1.3 {TclpRenameFile: EINVAL} {
d76 1
a76 1
test unixFCmd-1.4 {TclpRenameFile: EISDIR} {
d79 1
a79 1
test unixFCmd-1.5 {TclpRenameFile: ENOENT} {
d84 1
a84 1
test unixFCmd-1.6 {TclpRenameFile: ENOTDIR} {
d87 1
a87 1
test unixFCmd-1.7 {TclpRenameFile: EXDEV} {
d91 2
a92 3
    set msg [list [catch {file rename foo/bar /tmp} msg] $msg]
    set a1 {1 {can't unlink "foo/bar": permission denied}}
    set result [expr {$msg == $a1}]
d96 3
a98 3
    set result
} {1}
test unixFCmd-1.8 {Checking EINTR Bug} nonPortable {
d103 1
a103 1
test unixFCmd-1.9 {Checking EINTR Bug} nonPortable {
d118 2
a119 1
test unixFCmd-2.1 {TclpCopyFile: target exists: lstat(dst) == 0} {
d125 1
a125 1
test unixFCmd-2.2 {TclpCopyFile: src is symlink} {
d131 1
a131 1
test unixFCmd-2.3 {TclpCopyFile: src is block} {
d139 1
a139 1
test unixFCmd-2.4 {TclpCopyFile: src is fifo} {
d148 1
a148 1
test unixFCmd-2.5 {TclpCopyFile: copy attributes} {
d156 1
a156 1
test unixFCmd-3.1 {CopyFile not done} {
d159 1
a159 1
test unixFCmd-4.1 {TclpDeleteFile not done} {
d162 1
a162 1
test unixFCmd-5.1 {TclpCreateDirectory not done} {
d165 1
a165 1
test unixFCmd-6.1 {TclpCopyDirectory not done} {
d168 1
a168 1
test unixFCmd-7.1 {TclpRemoveDirectory not done} {
d171 1
a171 1
test unixFCmd-8.1 {TraverseUnixTree not done} {
d174 1
a174 1
test unixFCmd-9.1 {TraversalCopy not done} {
d177 1
a177 1
test unixFCmd-10.1 {TraversalDelete not done} {
d180 1
a180 1
test unixFCmd-11.1 {CopyFileAttrs not done} {
d183 1
a183 8
set testConfig(tclGroup) 0
if {[catch {exec {groups}} groupList] == 0} {
    if {[lsearch $groupList tcl] != -1} {
	set testConfig(tclGroup) 1
    }
}

test unixFCmd-12.1 {GetGroupAttribute - file not found} {
d186 2
a187 2
} {1 {could not stat file "foo.test": no such file or directory}}
test unixFCmd-12.2 {GetGroupAttribute - file found} {
d193 1
a193 1
test unixFCmd-13.1 {GetOwnerAttribute - file not found} {
d196 2
a197 2
} {1 {could not stat file "foo.test": no such file or directory}}
test unixFCmd-13.2 {GetOwnerAttribute} {
d200 2
a201 1
    list [catch {file attributes foo.test -owner} msg] [string compare $msg $user] [file delete -force -- foo.test]
d204 1
a204 1
test unixFCmd-14.1 {GetPermissionsAttribute - file not found} {
d207 2
a208 2
} {1 {could not stat file "foo.test": no such file or directory}}
test unixFCmd-14.2 {GetPermissionsAttribute} {
d211 2
a212 1
    list [catch {file attribute foo.test -permissions}] [file delete -force -- foo.test]
d215 9
d225 1
a225 1
test unixFCmd-15.1 {SetGroupAttribute - invalid group} {
d227 2
a228 1
    list [catch {file attributes foo.test -group foozzz} msg] $msg [file delete -force -- foo.test]
d230 2
a231 1
test unixFCmd-15.2 {SetGroupAttribute - invalid file} {tclGroup} {
d233 1
a233 1
    list [catch {file attributes foo.test -group tcl} msg] $msg
d237 1
a237 1
test unixFCmd-16.1 {SetOwnerAttribute - current owner} {
d240 3
a242 1
    list [catch {file attributes foo.test -owner $user} msg] $msg [string compare [file attributes foo.test -owner] $user] [file delete -force -- foo.test]
d244 1
a244 1
test unixFCmd-16.2 {SetOwnerAttribute - invalid file} {
d248 1
a248 1
test unixFCmd-16.3 {SetOwnerAttribute - invalid owner} {
d254 1
a254 1
test unixFCmd-17.1 {SetPermissionsAttribute} {
d257 3
a259 1
    list [catch {file attributes foo.test -permissions 0000} msg] $msg [file attributes foo.test -permissions] [file delete -force -- foo.test]
d261 1
a261 1
test unixFCmd-17.2 {SetPermissionsAttribute} {
d265 7
a271 1
test unixFCmd-17.3 {SetPermissionsAttribute} {
d274 25
a298 3
    list [catch {file attributes foo.test -permissions foo} msg] $msg [file delete -force -- foo.test]
} {1 {expected integer but got "foo"} {}}
test unixFCmd-18.1 {Unix pwd} {nonPortable} {
d313 1
d315 15
@


1.1.1.1
log
@import dejagnu-1999-11-08 snapshot
@
text
@@


1.1.1.2
log
@Tcl 8.3 upgrade
@
text
@d12 1
a12 1
# RCS: @@(#) $Id: unixFCmd.test,v 1.6.8.2 2000/09/15 16:57:46 spolk Exp $
d14 4
a17 3
if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import -force ::tcltest::*
d20 4
a23 10
# Several tests require need to match results against the unix username
set user {}
if {$tcl_platform(platform) == "unix"} {
    catch {set user [exec whoami]}
    if {$user == ""} {
	catch {regexp {^[^(]*\(([^)]*)\)} [exec id] dummy user}
    }
    if {$user == ""} {
	set user "root"
    }
d52 1
a52 1
test unixFCmd-1.1 {TclpRenameFile: EACCES} {unixOnly notRoot} {
d60 1
a60 1
test unixFCmd-1.2 {TclpRenameFile: EEXIST} {unixOnly notRoot} {
d66 1
a66 1
test unixFCmd-1.3 {TclpRenameFile: EINVAL} {unixOnly notRoot} {
d71 1
a71 1
test unixFCmd-1.4 {TclpRenameFile: EISDIR} {emptyTest unixOnly notRoot} {
d74 1
a74 1
test unixFCmd-1.5 {TclpRenameFile: ENOENT} {unixOnly notRoot} {
d79 1
a79 1
test unixFCmd-1.6 {TclpRenameFile: ENOTDIR} {emptyTest unixOnly notRoot} {
d82 1
a82 1
test unixFCmd-1.7 {TclpRenameFile: EXDEV} {unixOnly notRoot} {
d86 3
a88 2
    set catchResult [catch {file rename foo/bar /tmp} msg]
    set msg [lindex [split $msg :] end]
d92 3
a94 3
    list $catchResult $msg
} {1 { permission denied}}
test unixFCmd-1.8 {Checking EINTR Bug} {unixOnly notRoot nonPortable} {
d99 1
a99 1
test unixFCmd-1.9 {Checking EINTR Bug} {unixOnly notRoot nonPortable} {
d114 1
a114 2
test unixFCmd-2.1 {TclpCopyFile: target exists: lstat(dst) == 0} \
	{unixOnly notRoot} {
d120 1
a120 1
test unixFCmd-2.2 {TclpCopyFile: src is symlink} {unixOnly notRoot} {
d126 1
a126 1
test unixFCmd-2.3 {TclpCopyFile: src is block} {unixOnly notRoot} {
d134 1
a134 1
test unixFCmd-2.4 {TclpCopyFile: src is fifo} {unixOnly notRoot} {
d143 1
a143 1
test unixFCmd-2.5 {TclpCopyFile: copy attributes} {unixOnly notRoot} {
d151 1
a151 1
test unixFCmd-3.1 {CopyFile not done} {emptyTest unixOnly notRoot} {
d154 1
a154 1
test unixFCmd-4.1 {TclpDeleteFile not done} {emptyTest unixOnly notRoot} {
d157 1
a157 1
test unixFCmd-5.1 {TclpCreateDirectory not done} {emptyTest unixOnly notRoot} {
d160 1
a160 1
test unixFCmd-6.1 {TclpCopyDirectory not done} {emptyTest unixOnly notRoot} {
d163 1
a163 1
test unixFCmd-7.1 {TclpRemoveDirectory not done} {emptyTest unixOnly notRoot} {
d166 1
a166 1
test unixFCmd-8.1 {TraverseUnixTree not done} {emptyTest unixOnly notRoot} {
d169 1
a169 1
test unixFCmd-9.1 {TraversalCopy not done} {emptyTest unixOnly notRoot} {
d172 1
a172 1
test unixFCmd-10.1 {TraversalDelete not done} {emptyTest unixOnly notRoot} {
d175 1
a175 1
test unixFCmd-11.1 {CopyFileAttrs not done} {emptyTest unixOnly notRoot} {
d178 8
a185 1
test unixFCmd-12.1 {GetGroupAttribute - file not found} {unixOnly notRoot} {
d188 2
a189 2
} {1 {could not read "foo.test": no such file or directory}}
test unixFCmd-12.2 {GetGroupAttribute - file found} {unixOnly notRoot} {
d195 1
a195 1
test unixFCmd-13.1 {GetOwnerAttribute - file not found} {unixOnly notRoot} {
d198 2
a199 2
} {1 {could not read "foo.test": no such file or directory}}
test unixFCmd-13.2 {GetOwnerAttribute} {unixOnly notRoot} {
d202 1
a202 2
    list [catch {file attributes foo.test -owner} msg] \
	    [string compare $msg $user] [file delete -force -- foo.test]
d205 1
a205 1
test unixFCmd-14.1 {GetPermissionsAttribute - file not found} {unixOnly notRoot} {
d208 2
a209 2
} {1 {could not read "foo.test": no such file or directory}}
test unixFCmd-14.2 {GetPermissionsAttribute} {unixOnly notRoot} {
d212 1
a212 2
    list [catch {file attribute foo.test -permissions}] \
	    [file delete -force -- foo.test]
a214 9
# Find a group that exists on this system, or else skip tests that require
# groups
set ::tcltest::testConstraints(foundGroup) 0
catch {
    set groupList [exec groups]
    set group [lindex $groupList 0]
    set ::tcltest::testConstraints(foundGroup) 1
}

d216 1
a216 1
test unixFCmd-15.1 {SetGroupAttribute - invalid group} {unixOnly notRoot} {
d218 1
a218 2
    list [catch {file attributes foo.test -group foozzz} msg] \
	    $msg [file delete -force -- foo.test]
d220 1
a220 2
test unixFCmd-15.2 {SetGroupAttribute - invalid file} \
	{unixOnly notRoot foundGroup} {
d222 1
a222 1
    list [catch {file attributes foo.test -group $group} msg] $msg
d226 1
a226 1
test unixFCmd-16.1 {SetOwnerAttribute - current owner} {unixOnly notRoot} {
d229 1
a229 3
    list [catch {file attributes foo.test -owner $user} msg] \
	    $msg [string compare [file attributes foo.test -owner] $user] \
	    [file delete -force -- foo.test]
d231 1
a231 1
test unixFCmd-16.2 {SetOwnerAttribute - invalid file} {unixOnly notRoot} {
d235 1
a235 1
test unixFCmd-16.3 {SetOwnerAttribute - invalid owner} {unixOnly notRoot} {
d241 1
a241 1
test unixFCmd-17.1 {SetPermissionsAttribute} {unixOnly notRoot} {
d244 1
a244 3
    list [catch {file attributes foo.test -permissions 0000} msg] \
	    $msg [file attributes foo.test -permissions] \
	    [file delete -force -- foo.test]
d246 1
a246 1
test unixFCmd-17.2 {SetPermissionsAttribute} {unixOnly notRoot} {
d250 1
a250 7
test unixFCmd-17.3 {SetPermissionsAttribute} {unixOnly notRoot} {
    catch {file delete -force -- foo.test}
    close [open foo.test w]
    list [catch {file attributes foo.test -permissions foo} msg] $msg \
	    [file delete -force -- foo.test]
} {1 {unknown permission string format "foo"} {}}
test unixFCmd-17.3 {SetPermissionsAttribute} {unixOnly notRoot} {
d253 3
a255 25
    list [catch {file attributes foo.test -permissions ---rwx} msg] $msg \
	    [file delete -force -- foo.test]
} {1 {unknown permission string format "---rwx"} {}}

close [open foo.test w]
set ::i 4
proc permcheck {permstr expected} {
    test unixFCmd-17.[incr ::i] {SetPermissionsAttribute} {unixOnly notRoot} \
	    [subst {
	file attributes foo.test -permissions $permstr
	file attributes foo.test -permissions
    }
    ] $expected
}
permcheck rwxrwxrwx	00777
permcheck r--r---w-	00442
permcheck 0		00000
permcheck u+rwx,g+r	00740
permcheck u-w		00540
permcheck o+rwx		00547
permcheck --x--x--x	00111
permcheck a+rwx		00777
file delete -force -- foo.test

test unixFCmd-18.1 {Unix pwd} {nonPortable unixOnly notRoot} {
a269 1
# cleanup
a270 15
::tcltest::cleanupTests
return













@


1.1.1.3
log
@import tcl 8.4.0
@
text
@d12 1
a12 1
# RCS: @@(#) $Id: unixFCmd.test,v 1.16 2002/08/08 10:41:22 hobbs Exp $
a18 5
# These tests really need to be run from a writable directory, which
# it is assumed [temporaryDirectory] is.
set oldcwd [pwd]
cd [temporaryDirectory]

d35 1
a35 1
	    foreach p [glob -directory $path *] {
d46 1
a46 1
	    set x [glob -directory $p tf* td*]
d60 1
a60 1
    file attributes td1/td2 -permissions 0000
d62 1
a62 1
    file attributes td1/td2 -permissions 0755
d121 2
a122 2
    close [open tf1 a]
    close [open tf2 a]
d125 1
a125 2
test unixFCmd-2.2.1 {TclpCopyFile: src is symlink} {unixOnly notRoot dontCopyLinks} {
    # copying links should end up with real files
d127 1
a127 10
    close [open tf1 a]
    file link -symbolic tf2 tf1
    file copy tf2 tf3
    file type tf3
} {file}
test unixFCmd-2.2.2 {TclpCopyFile: src is symlink} {unixOnly notRoot} {
    # copying links should end up with the links copied
    cleanup
    close [open tf1 a]
    file link -symbolic tf2 tf1
d150 2
a151 2
    close [open tf1 a]
    file attributes tf1 -permissions 0472
d153 2
a154 2
    file attributes tf2 -permissions
} 00472 ;# i.e. perms field of [exec ls -l tf2] is -r--rwx-w-
d280 3
a282 2
proc permcheck {testnum permstr expected} {
    test $testnum {SetPermissionsAttribute} {unixOnly notRoot} {
d285 2
a286 1
    } $expected
d288 8
a295 8
permcheck unixFCmd-17.4   rwxrwxrwx	00777
permcheck unixFCmd-17.5   r--r---w-	00442
permcheck unixFCmd-17.6   0		00000
permcheck unixFCmd-17.7   u+rwx,g+r	00740
permcheck unixFCmd-17.8   u-w		00540
permcheck unixFCmd-17.9   o+rwx		00547
permcheck unixFCmd-17.10  --x--x--x	00111
permcheck unixFCmd-17.11  a+rwx		00777
d305 1
a305 1
    file attributes $nd -permissions 0000
d308 1
a308 1
    file attributes $nd -permissions 0755
a314 1
cd $oldcwd
d317 13
@


