head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.60
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.58
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.56
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.54
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.52
	gdb_7_0-branch:1.5.0.50
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tcl8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.48
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.46
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.44
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.42
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.40
	gdb_6_5-2006-05-14-branchpoint:1.5
	readline_5_1-import-branch:1.5.0.38
	readline_5_1-import-branchpoint:1.5
	gdb_6_4-branch:1.5.0.36
	gdb_6_4-2005-11-01-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.34
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	ezannoni_pie-20040323-branch:1.5.0.32
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.30
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.28
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.26
	gdb_5_1-2001-07-29-branch:1.5.0.24
	cagney_x86i386-20030821-branch:1.5.0.22
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.20
	gdb_6_0-2003-06-23-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.18
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.16
	cagney_writestrings-20030508-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.14
	cagney_fileio-20030521-branchpoint:1.5
	carlton_dictionary-20030430-merge:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.12
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.10
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.8
	cagney_lazyid-20030317-branchpoint:1.5
	offbyone-20030313-branch:1.5.0.6
	offbyone-20030313-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.4
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.2
	interps-20030202-branchpoint:1.5
	TCL8_4_1:1.1.1.2
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.2
	TCL_8_4_1:1.1.1.2
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.4
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TCL_8_4_0:1.1.1.2
	carlton_dictionary-branch:1.2.0.16
	carlton_dictionary-20020920-branchpoint:1.2
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.14
	gdb_5_3-branch:1.2.0.12
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.10
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.8
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.6
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	cygnus_cvs_20020108_pre:1.2
	TCL_8_3:1.1.1.1
	NET:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2003.01.21.19.40.16;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.26.19.48.01;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.37.07;	author kseitz;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2001.09.09.23.56.08;	author irox;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	2001.09.09.22.40.58;	author irox;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2002.09.27.21.49.11;	author kseitz;	state Exp;
branches;
next	;

1.3.4.1
date	2003.12.14.20.28.49;	author drow;	state Exp;
branches;
next	;

1.2.16.1
date	2002.12.23.19.40.42;	author carlton;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2003.02.07.19.18.20;	author carlton;	state Exp;
branches;
next	;

1.1.1.1
date	2001.09.09.22.40.58;	author irox;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.24.19.56.39;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tcl 8.4.1
@
text
@# This file contains a collection of tests for the procedures in the
# file tclParseExpr.c.  Sourcing this file into Tcl runs the tests and
# generates output for errors.  No output means no errors were found.
#
# Copyright (c) 1997 Sun Microsystems, Inc.
# Copyright (c) 1998-1999 by Scriptics Corporation.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# RCS: @@(#) $Id: parseExpr.test,v 1.8 2002/08/05 03:24:41 dgp Exp $

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import -force ::tcltest::*
}

# Note that the Tcl expression parser (tclParseExpr.c) does not check
# the semantic validity of the expressions it parses. It does not check,
# for example, that a math function actually exists, or that the operands
# of "<<" are integers.

if {[info commands testexprparser] == {}} {
    puts "This application hasn't been compiled with the \"testexprparser\""
    puts "command, so I can't test the Tcl expression parser."
    ::tcltest::cleanupTests
    return 
}

# Some tests only work if wide integers (>32bit) are not found to be
# integers at all.
set ::tcltest::testConstraints(wideIntegerUnparsed) \
	[expr {-1 == 0xffffffff}]

test parseExpr-1.1 {Tcl_ParseExpr procedure, computing string length} {
    testexprparser [bytestring "1+2\0 +3"] -1
} {- {} 0 subexpr 1+2 5 operator + 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 {}}
test parseExpr-1.2 {Tcl_ParseExpr procedure, computing string length} {
    testexprparser "1  + 2" -1
} {- {} 0 subexpr {1  + 2} 5 operator + 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 {}}
test parseExpr-1.3 {Tcl_ParseExpr procedure, error getting initial lexeme} {wideIntegerUnparsed} {
    list [catch {testexprparser {12345678901234567890} -1} msg] $msg
} {1 {integer value too large to represent}}
test parseExpr-1.4 {Tcl_ParseExpr procedure, error in conditional expression} {
    list [catch {testexprparser {foo+} -1} msg] $msg
} {1 {syntax error in expression "foo+": variable references require preceding $}}
test parseExpr-1.5 {Tcl_ParseExpr procedure, lexemes after the expression} {
    list [catch {testexprparser {1+2 345} -1} msg] $msg
} {1 {syntax error in expression "1+2 345": extra tokens at end of expression}}

test parseExpr-2.1 {ParseCondExpr procedure, valid test subexpr} {
    testexprparser {2>3? 1 : 0} -1
} {- {} 0 subexpr {2>3? 1 : 0} 11 operator ? 0 subexpr 2>3 5 operator > 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 subexpr 1 1 text 1 0 subexpr 0 1 text 0 0 {}}
test parseExpr-2.2 {ParseCondExpr procedure, error in test subexpr} {
    list [catch {testexprparser {0 || foo} -1} msg] $msg
} {1 {syntax error in expression "0 || foo": variable references require preceding $}}
test parseExpr-2.3 {ParseCondExpr procedure, next lexeme isn't "?"} {
    testexprparser {1+2} -1
} {- {} 0 subexpr 1+2 5 operator + 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 {}}
test parseExpr-2.4 {ParseCondExpr procedure, next lexeme is "?"} {
    testexprparser {1+2 ? 3 : 4} -1
} {- {} 0 subexpr {1+2 ? 3 : 4} 11 operator ? 0 subexpr 1+2 5 operator + 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 subexpr 4 1 text 4 0 {}}
test parseExpr-2.5 {ParseCondExpr procedure, bad lexeme after "?"} {wideIntegerUnparsed} {
    list [catch {testexprparser {1+2 ? 12345678901234567890} -1} msg] $msg
} {1 {integer value too large to represent}}
test parseExpr-2.6 {ParseCondExpr procedure, valid "then" subexpression} {
    testexprparser {1? 3 : 4} -1
} {- {} 0 subexpr {1? 3 : 4} 7 operator ? 0 subexpr 1 1 text 1 0 subexpr 3 1 text 3 0 subexpr 4 1 text 4 0 {}}
test parseExpr-2.7 {ParseCondExpr procedure, error in "then" subexpression} {
    list [catch {testexprparser {1? fred : martha} -1} msg] $msg
} {1 {syntax error in expression "1? fred : martha": variable references require preceding $}}
test parseExpr-2.8 {ParseCondExpr procedure, lexeme after "then" subexpr isn't ":"} {
    list [catch {testexprparser {1? 2 martha 3} -1} msg] $msg
} {1 {syntax error in expression "1? 2 martha 3": missing colon from ternary conditional}}
test parseExpr-2.9 {ParseCondExpr procedure, valid "else" subexpression} {
    testexprparser {27||3? 3 : 4&&9} -1
} {- {} 0 subexpr {27||3? 3 : 4&&9} 15 operator ? 0 subexpr 27||3 5 operator || 0 subexpr 27 1 text 27 0 subexpr 3 1 text 3 0 subexpr 3 1 text 3 0 subexpr 4&&9 5 operator && 0 subexpr 4 1 text 4 0 subexpr 9 1 text 9 0 {}}
test parseExpr-2.10 {ParseCondExpr procedure, error in "else" subexpression} {
    list [catch {testexprparser {1? 2 : martha} -1} msg] $msg
} {1 {syntax error in expression "1? 2 : martha": variable references require preceding $}}

test parseExpr-3.1 {ParseLorExpr procedure, valid logical and subexpr} {
    testexprparser {1&&2 || 3} -1
} {- {} 0 subexpr {1&&2 || 3} 9 operator || 0 subexpr 1&&2 5 operator && 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 {}}
test parseExpr-3.2 {ParseLorExpr procedure, error in logical and subexpr} {
    list [catch {testexprparser {1&&foo || 3} -1} msg] $msg
} {1 {syntax error in expression "1&&foo || 3": variable references require preceding $}}
test parseExpr-3.3 {ParseLorExpr procedure, next lexeme isn't "||"} {
    testexprparser {1&&2? 1 : 0} -1
} {- {} 0 subexpr {1&&2? 1 : 0} 11 operator ? 0 subexpr 1&&2 5 operator && 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 subexpr 1 1 text 1 0 subexpr 0 1 text 0 0 {}}
test parseExpr-3.4 {ParseLorExpr procedure, next lexeme is "||"} {
    testexprparser {1&&2 || 3} -1
} {- {} 0 subexpr {1&&2 || 3} 9 operator || 0 subexpr 1&&2 5 operator && 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 {}}
test parseExpr-3.5 {ParseLorExpr procedure, bad lexeme after "||"} {wideIntegerUnparsed} {
    list [catch {testexprparser {1&&2 || 12345678901234567890} -1} msg] $msg
} {1 {integer value too large to represent}}
test parseExpr-3.6 {ParseLorExpr procedure, valid RHS subexpression} {
    testexprparser {1&&2 || 3 || 4} -1
} {- {} 0 subexpr {1&&2 || 3 || 4} 13 operator || 0 subexpr {1&&2 || 3} 9 operator || 0 subexpr 1&&2 5 operator && 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 subexpr 4 1 text 4 0 {}}
test parseExpr-3.7 {ParseLorExpr procedure, error in RHS subexpression} {
    list [catch {testexprparser {1&&2 || 3 || martha} -1} msg] $msg
} {1 {syntax error in expression "1&&2 || 3 || martha": variable references require preceding $}}

test parseExpr-4.1 {ParseLandExpr procedure, valid LHS "|" subexpr} {
    testexprparser {1|2 && 3} -1
} {- {} 0 subexpr {1|2 && 3} 9 operator && 0 subexpr 1|2 5 operator | 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 {}}
test parseExpr-4.2 {ParseLandExpr procedure, error in LHS "|" subexpr} {
    list [catch {testexprparser {1&&foo && 3} -1} msg] $msg
} {1 {syntax error in expression "1&&foo && 3": variable references require preceding $}}
test parseExpr-4.3 {ParseLandExpr procedure, next lexeme isn't "&&"} {
    testexprparser {1|2? 1 : 0} -1
} {- {} 0 subexpr {1|2? 1 : 0} 11 operator ? 0 subexpr 1|2 5 operator | 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 subexpr 1 1 text 1 0 subexpr 0 1 text 0 0 {}}
test parseExpr-4.4 {ParseLandExpr procedure, next lexeme is "&&"} {
    testexprparser {1|2 && 3} -1
} {- {} 0 subexpr {1|2 && 3} 9 operator && 0 subexpr 1|2 5 operator | 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 {}}
test parseExpr-4.5 {ParseLandExpr procedure, bad lexeme after "&&"} {wideIntegerUnparsed} {
    list [catch {testexprparser {1|2 && 12345678901234567890} -1} msg] $msg
} {1 {integer value too large to represent}}
test parseExpr-4.6 {ParseLandExpr procedure, valid RHS subexpression} {
    testexprparser {1|2 && 3 && 4} -1
} {- {} 0 subexpr {1|2 && 3 && 4} 13 operator && 0 subexpr {1|2 && 3} 9 operator && 0 subexpr 1|2 5 operator | 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 subexpr 4 1 text 4 0 {}}
test parseExpr-4.7 {ParseLandExpr procedure, error in RHS subexpression} {
    list [catch {testexprparser {1|2 && 3 && martha} -1} msg] $msg
} {1 {syntax error in expression "1|2 && 3 && martha": variable references require preceding $}}

test parseExpr-5.1 {ParseBitOrExpr procedure, valid LHS "^" subexpr} {
    testexprparser {1^2 | 3} -1
} {- {} 0 subexpr {1^2 | 3} 9 operator | 0 subexpr 1^2 5 operator ^ 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 {}}
test parseExpr-5.2 {ParseBitOrExpr procedure, error in LHS "^" subexpr} {
    list [catch {testexprparser {1|foo | 3} -1} msg] $msg
} {1 {syntax error in expression "1|foo | 3": variable references require preceding $}}
test parseExpr-5.3 {ParseBitOrExpr procedure, next lexeme isn't "|"} {
    testexprparser {1^2? 1 : 0} -1
} {- {} 0 subexpr {1^2? 1 : 0} 11 operator ? 0 subexpr 1^2 5 operator ^ 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 subexpr 1 1 text 1 0 subexpr 0 1 text 0 0 {}}
test parseExpr-5.4 {ParseBitOrExpr procedure, next lexeme is "|"} {
    testexprparser {1^2 | 3} -1
} {- {} 0 subexpr {1^2 | 3} 9 operator | 0 subexpr 1^2 5 operator ^ 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 {}}
test parseExpr-5.5 {ParseBitOrExpr procedure, bad lexeme after "|"} {wideIntegerUnparsed} {
    list [catch {testexprparser {1^2 | 12345678901234567890} -1} msg] $msg
} {1 {integer value too large to represent}}
test parseExpr-5.6 {ParseBitOrExpr procedure, valid RHS subexpression} {
    testexprparser {1^2 | 3 | 4} -1
} {- {} 0 subexpr {1^2 | 3 | 4} 13 operator | 0 subexpr {1^2 | 3} 9 operator | 0 subexpr 1^2 5 operator ^ 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 subexpr 4 1 text 4 0 {}}
test parseExpr-5.7 {ParseBitOrExpr procedure, error in RHS subexpression} {
    list [catch {testexprparser {1^2 | 3 | martha} -1} msg] $msg
} {1 {syntax error in expression "1^2 | 3 | martha": variable references require preceding $}}

test parseExpr-6.1 {ParseBitXorExpr procedure, valid LHS "&" subexpr} {
    testexprparser {1&2 ^ 3} -1
} {- {} 0 subexpr {1&2 ^ 3} 9 operator ^ 0 subexpr 1&2 5 operator & 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 {}}
test parseExpr-6.2 {ParseBitXorExpr procedure, error in LHS "&" subexpr} {
    list [catch {testexprparser {1^foo ^ 3} -1} msg] $msg
} {1 {syntax error in expression "1^foo ^ 3": variable references require preceding $}}
test parseExpr-6.3 {ParseBitXorExpr procedure, next lexeme isn't "^"} {
    testexprparser {1&2? 1 : 0} -1
} {- {} 0 subexpr {1&2? 1 : 0} 11 operator ? 0 subexpr 1&2 5 operator & 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 subexpr 1 1 text 1 0 subexpr 0 1 text 0 0 {}}
test parseExpr-6.4 {ParseBitXorExpr procedure, next lexeme is "^"} {
    testexprparser {1&2 ^ 3} -1
} {- {} 0 subexpr {1&2 ^ 3} 9 operator ^ 0 subexpr 1&2 5 operator & 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 {}}
test parseExpr-6.5 {ParseBitXorExpr procedure, bad lexeme after "^"} {wideIntegerUnparsed} {
    list [catch {testexprparser {1&2 ^ 12345678901234567890} -1} msg] $msg
} {1 {integer value too large to represent}}
test parseExpr-6.6 {ParseBitXorExpr procedure, valid RHS subexpression} {
    testexprparser {1&2 ^ 3 ^ 4} -1
} {- {} 0 subexpr {1&2 ^ 3 ^ 4} 13 operator ^ 0 subexpr {1&2 ^ 3} 9 operator ^ 0 subexpr 1&2 5 operator & 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 subexpr 4 1 text 4 0 {}}
test parseExpr-6.7 {ParseBitXorExpr procedure, error in RHS subexpression} {
    list [catch {testexprparser {1&2 ^ 3 ^ martha} -1} msg] $msg
} {1 {syntax error in expression "1&2 ^ 3 ^ martha": variable references require preceding $}}

test parseExpr-7.1 {ParseBitAndExpr procedure, valid LHS equality subexpr} {
    testexprparser {1==2 & 3} -1
} {- {} 0 subexpr {1==2 & 3} 9 operator & 0 subexpr 1==2 5 operator == 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 {}}
test parseExpr-7.2 {ParseBitAndExpr procedure, error in LHS equality subexpr} {
    list [catch {testexprparser {1!=foo & 3} -1} msg] $msg
} {1 {syntax error in expression "1!=foo & 3": variable references require preceding $}}
test parseExpr-7.3 {ParseBitAndExpr procedure, next lexeme isn't "&"} {
    testexprparser {1==2? 1 : 0} -1
} {- {} 0 subexpr {1==2? 1 : 0} 11 operator ? 0 subexpr 1==2 5 operator == 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 subexpr 1 1 text 1 0 subexpr 0 1 text 0 0 {}}
test parseExpr-7.4 {ParseBitAndExpr procedure, next lexeme is "&"} {
    testexprparser {1>2 & 3} -1
} {- {} 0 subexpr {1>2 & 3} 9 operator & 0 subexpr 1>2 5 operator > 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 {}}
test parseExpr-7.5 {ParseBitAndExpr procedure, bad lexeme after "&"} {wideIntegerUnparsed} {
    list [catch {testexprparser {1==2 & 12345678901234567890} -1} msg] $msg
} {1 {integer value too large to represent}}
test parseExpr-7.6 {ParseBitAndExpr procedure, valid RHS subexpression} {
    testexprparser {1<2 & 3 & 4} -1
} {- {} 0 subexpr {1<2 & 3 & 4} 13 operator & 0 subexpr {1<2 & 3} 9 operator & 0 subexpr 1<2 5 operator < 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 subexpr 4 1 text 4 0 {}}
test parseExpr-7.7 {ParseBitAndExpr procedure, error in RHS subexpression} {
    list [catch {testexprparser {1==2 & 3>2 & martha} -1} msg] $msg
} {1 {syntax error in expression "1==2 & 3>2 & martha": variable references require preceding $}}

test parseExpr-8.1 {ParseEqualityExpr procedure, valid LHS relational subexpr} {
    testexprparser {1<2 == 3} -1
} {- {} 0 subexpr {1<2 == 3} 9 operator == 0 subexpr 1<2 5 operator < 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 {}}
test parseExpr-8.2 {ParseEqualityExpr procedure, error in LHS relational subexpr} {
    list [catch {testexprparser {1>=foo == 3} -1} msg] $msg
} {1 {syntax error in expression "1>=foo == 3": variable references require preceding $}}
test parseExpr-8.3 {ParseEqualityExpr procedure, next lexeme isn't "==" or "!="} {
    testexprparser {1<2? 1 : 0} -1
} {- {} 0 subexpr {1<2? 1 : 0} 11 operator ? 0 subexpr 1<2 5 operator < 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 subexpr 1 1 text 1 0 subexpr 0 1 text 0 0 {}}
test parseExpr-8.4 {ParseEqualityExpr procedure, next lexeme is "==" or "!="} {
    testexprparser {1<2 == 3} -1
} {- {} 0 subexpr {1<2 == 3} 9 operator == 0 subexpr 1<2 5 operator < 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 {}}
test parseExpr-8.5 {ParseEqualityExpr procedure, next lexeme is "==" or "!="} {
    testexprparser {1<2 != 3} -1
} {- {} 0 subexpr {1<2 != 3} 9 operator != 0 subexpr 1<2 5 operator < 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 {}}
test parseExpr-8.6 {ParseEqualityExpr procedure, bad lexeme after "==" or "!="} {wideIntegerUnparsed} {
    list [catch {testexprparser {1<2 == 12345678901234567890} -1} msg] $msg
} {1 {integer value too large to represent}}
test parseExpr-8.7 {ParseEqualityExpr procedure, valid RHS subexpression} {
    testexprparser {1<2 == 3 == 4} -1
} {- {} 0 subexpr {1<2 == 3 == 4} 13 operator == 0 subexpr {1<2 == 3} 9 operator == 0 subexpr 1<2 5 operator < 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 subexpr 4 1 text 4 0 {}}
test parseExpr-8.8 {ParseEqualityExpr procedure, error in RHS subexpression} {
    list [catch {testexprparser {1<2 == 3 != martha} -1} msg] $msg
} {1 {syntax error in expression "1<2 == 3 != martha": variable references require preceding $}}

test parseExpr-9.1 {ParseRelationalExpr procedure, valid LHS shift subexpr} {
    testexprparser {1<<2 < 3} -1
} {- {} 0 subexpr {1<<2 < 3} 9 operator < 0 subexpr 1<<2 5 operator << 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 {}}
test parseExpr-9.2 {ParseRelationalExpr procedure, error in LHS shift subexpr} {
    list [catch {testexprparser {1>=foo < 3} -1} msg] $msg
} {1 {syntax error in expression "1>=foo < 3": variable references require preceding $}}
test parseExpr-9.3 {ParseRelationalExpr procedure, next lexeme isn't relational op} {
    testexprparser {1<<2? 1 : 0} -1
} {- {} 0 subexpr {1<<2? 1 : 0} 11 operator ? 0 subexpr 1<<2 5 operator << 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 subexpr 1 1 text 1 0 subexpr 0 1 text 0 0 {}}
test parseExpr-9.4 {ParseRelationalExpr procedure, next lexeme is relational op} {
    testexprparser {1<<2 < 3} -1
} {- {} 0 subexpr {1<<2 < 3} 9 operator < 0 subexpr 1<<2 5 operator << 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 {}}
test parseExpr-9.5 {ParseRelationalExpr procedure, next lexeme is relational op} {
    testexprparser {1>>2 > 3} -1
} {- {} 0 subexpr {1>>2 > 3} 9 operator > 0 subexpr 1>>2 5 operator >> 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 {}}
test parseExpr-9.6 {ParseRelationalExpr procedure, next lexeme is relational op} {
    testexprparser {1<<2 <= 3} -1
} {- {} 0 subexpr {1<<2 <= 3} 9 operator <= 0 subexpr 1<<2 5 operator << 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 {}}
test parseExpr-9.7 {ParseRelationalExpr procedure, next lexeme is relational op} {
    testexprparser {1<<2 >= 3} -1
} {- {} 0 subexpr {1<<2 >= 3} 9 operator >= 0 subexpr 1<<2 5 operator << 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 {}}
test parseExpr-9.8 {ParseRelationalExpr procedure, bad lexeme after relational op} {wideIntegerUnparsed} {
    list [catch {testexprparser {1<<2 < 12345678901234567890} -1} msg] $msg
} {1 {integer value too large to represent}}
test parseExpr-9.9 {ParseRelationalExpr procedure, valid RHS subexpression} {
    testexprparser {1<<2 < 3 < 4} -1
} {- {} 0 subexpr {1<<2 < 3 < 4} 13 operator < 0 subexpr {1<<2 < 3} 9 operator < 0 subexpr 1<<2 5 operator << 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 subexpr 4 1 text 4 0 {}}
test parseExpr-9.10 {ParseRelationalExpr procedure, error in RHS subexpression} {
    list [catch {testexprparser {1<<2 < 3 > martha} -1} msg] $msg
} {1 {syntax error in expression "1<<2 < 3 > martha": variable references require preceding $}}

test parseExpr-10.1 {ParseShiftExpr procedure, valid LHS add subexpr} {
    testexprparser {1+2 << 3} -1
} {- {} 0 subexpr {1+2 << 3} 9 operator << 0 subexpr 1+2 5 operator + 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 {}}
test parseExpr-10.2 {ParseShiftExpr procedure, error in LHS add subexpr} {
    list [catch {testexprparser {1-foo << 3} -1} msg] $msg
} {1 {syntax error in expression "1-foo << 3": variable references require preceding $}}
test parseExpr-10.3 {ParseShiftExpr procedure, next lexeme isn't "<<" or ">>"} {
    testexprparser {1+2? 1 : 0} -1
} {- {} 0 subexpr {1+2? 1 : 0} 11 operator ? 0 subexpr 1+2 5 operator + 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 subexpr 1 1 text 1 0 subexpr 0 1 text 0 0 {}}
test parseExpr-10.4 {ParseShiftExpr procedure, next lexeme is "<<" or ">>"} {
    testexprparser {1+2 << 3} -1
} {- {} 0 subexpr {1+2 << 3} 9 operator << 0 subexpr 1+2 5 operator + 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 {}}
test parseExpr-10.5 {ParseShiftExpr procedure, next lexeme is "<<" or ">>"} {
    testexprparser {1+2 >> 3} -1
} {- {} 0 subexpr {1+2 >> 3} 9 operator >> 0 subexpr 1+2 5 operator + 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 {}}
test parseExpr-10.6 {ParseShiftExpr procedure, bad lexeme after "<<" or ">>"} {wideIntegerUnparsed} {
    list [catch {testexprparser {1+2 << 12345678901234567890} -1} msg] $msg
} {1 {integer value too large to represent}}
test parseExpr-10.7 {ParseShiftExpr procedure, valid RHS subexpression} {
    testexprparser {1+2 << 3 << 4} -1
} {- {} 0 subexpr {1+2 << 3 << 4} 13 operator << 0 subexpr {1+2 << 3} 9 operator << 0 subexpr 1+2 5 operator + 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 subexpr 4 1 text 4 0 {}}
test parseExpr-10.8 {ParseShiftExpr procedure, error in RHS subexpression} {
    list [catch {testexprparser {1+2 << 3 >> martha} -1} msg] $msg
} {1 {syntax error in expression "1+2 << 3 >> martha": variable references require preceding $}}

test parseExpr-11.1 {ParseAddExpr procedure, valid LHS multiply subexpr} {
    testexprparser {1*2 + 3} -1
} {- {} 0 subexpr {1*2 + 3} 9 operator + 0 subexpr 1*2 5 operator * 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 {}}
test parseExpr-11.2 {ParseAddExpr procedure, error in LHS multiply subexpr} {
    list [catch {testexprparser {1/foo + 3} -1} msg] $msg
} {1 {syntax error in expression "1/foo + 3": variable references require preceding $}}
test parseExpr-11.3 {ParseAddExpr procedure, next lexeme isn't "+" or "-"} {
    testexprparser {1*2? 1 : 0} -1
} {- {} 0 subexpr {1*2? 1 : 0} 11 operator ? 0 subexpr 1*2 5 operator * 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 subexpr 1 1 text 1 0 subexpr 0 1 text 0 0 {}}
test parseExpr-11.4 {ParseAddExpr procedure, next lexeme is "+" or "-"} {
    testexprparser {1*2 + 3} -1
} {- {} 0 subexpr {1*2 + 3} 9 operator + 0 subexpr 1*2 5 operator * 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 {}}
test parseExpr-11.5 {ParseAddExpr procedure, next lexeme is "+" or "-"} {
    testexprparser {1*2 - 3} -1
} {- {} 0 subexpr {1*2 - 3} 9 operator - 0 subexpr 1*2 5 operator * 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 {}}
test parseExpr-11.6 {ParseAddExpr procedure, bad lexeme after "+" or "-"} {wideIntegerUnparsed} {
    list [catch {testexprparser {1*2 + 12345678901234567890} -1} msg] $msg
} {1 {integer value too large to represent}}
test parseExpr-11.7 {ParseAddExpr procedure, valid RHS subexpression} {
    testexprparser {1*2 + 3 + 4} -1
} {- {} 0 subexpr {1*2 + 3 + 4} 13 operator + 0 subexpr {1*2 + 3} 9 operator + 0 subexpr 1*2 5 operator * 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 subexpr 4 1 text 4 0 {}}
test parseExpr-11.8 {ParseAddExpr procedure, error in RHS subexpression} {
    list [catch {testexprparser {1*2 + 3 - martha} -1} msg] $msg
} {1 {syntax error in expression "1*2 + 3 - martha": variable references require preceding $}}

test parseExpr-12.1 {ParseAddExpr procedure, valid LHS multiply subexpr} {
    testexprparser {1*2 + 3} -1
} {- {} 0 subexpr {1*2 + 3} 9 operator + 0 subexpr 1*2 5 operator * 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 {}}
test parseExpr-12.2 {ParseAddExpr procedure, error in LHS multiply subexpr} {
    list [catch {testexprparser {1/foo + 3} -1} msg] $msg
} {1 {syntax error in expression "1/foo + 3": variable references require preceding $}}
test parseExpr-12.3 {ParseAddExpr procedure, next lexeme isn't "+" or "-"} {
    testexprparser {1*2? 1 : 0} -1
} {- {} 0 subexpr {1*2? 1 : 0} 11 operator ? 0 subexpr 1*2 5 operator * 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 subexpr 1 1 text 1 0 subexpr 0 1 text 0 0 {}}
test parseExpr-12.4 {ParseAddExpr procedure, next lexeme is "+" or "-"} {
    testexprparser {1*2 + 3} -1
} {- {} 0 subexpr {1*2 + 3} 9 operator + 0 subexpr 1*2 5 operator * 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 {}}
test parseExpr-12.5 {ParseAddExpr procedure, next lexeme is "+" or "-"} {
    testexprparser {1*2 - 3} -1
} {- {} 0 subexpr {1*2 - 3} 9 operator - 0 subexpr 1*2 5 operator * 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 {}}
test parseExpr-12.6 {ParseAddExpr procedure, bad lexeme after "+" or "-"} {wideIntegerUnparsed} {
    list [catch {testexprparser {1*2 + 12345678901234567890} -1} msg] $msg
} {1 {integer value too large to represent}}
test parseExpr-12.7 {ParseAddExpr procedure, valid RHS subexpression} {
    testexprparser {1*2 + 3 + 4} -1
} {- {} 0 subexpr {1*2 + 3 + 4} 13 operator + 0 subexpr {1*2 + 3} 9 operator + 0 subexpr 1*2 5 operator * 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 subexpr 4 1 text 4 0 {}}
test parseExpr-12.8 {ParseAddExpr procedure, error in RHS subexpression} {
    list [catch {testexprparser {1*2 + 3 - martha} -1} msg] $msg
} {1 {syntax error in expression "1*2 + 3 - martha": variable references require preceding $}}

test parseExpr-13.1 {ParseMultiplyExpr procedure, valid LHS unary subexpr} {
    testexprparser {+2 * 3} -1
} {- {} 0 subexpr {+2 * 3} 7 operator * 0 subexpr +2 3 operator + 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 {}}
test parseExpr-13.2 {ParseMultiplyExpr procedure, error in LHS unary subexpr} {wideIntegerUnparsed} {
    list [catch {testexprparser {-12345678901234567890 * 3} -1} msg] $msg
} {1 {integer value too large to represent}}
test parseExpr-13.3 {ParseMultiplyExpr procedure, next lexeme isn't "*", "/", or "%"} {
    testexprparser {+2? 1 : 0} -1
} {- {} 0 subexpr {+2? 1 : 0} 9 operator ? 0 subexpr +2 3 operator + 0 subexpr 2 1 text 2 0 subexpr 1 1 text 1 0 subexpr 0 1 text 0 0 {}}
test parseExpr-13.4 {ParseMultiplyExpr procedure, next lexeme is "*", "/", or "%"} {
    testexprparser {-123 * 3} -1
} {- {} 0 subexpr {-123 * 3} 7 operator * 0 subexpr -123 3 operator - 0 subexpr 123 1 text 123 0 subexpr 3 1 text 3 0 {}}
test parseExpr-13.5 {ParseMultiplyExpr procedure, next lexeme is "*", "/", or "%"} {
    testexprparser {+-456 / 3} -1
} {- {} 0 subexpr {+-456 / 3} 9 operator / 0 subexpr +-456 5 operator + 0 subexpr -456 3 operator - 0 subexpr 456 1 text 456 0 subexpr 3 1 text 3 0 {}}
test parseExpr-13.6 {ParseMultiplyExpr procedure, next lexeme is "*", "/", or "%"} {
    testexprparser {+-456 % 3} -1
} {- {} 0 subexpr {+-456 % 3} 9 operator % 0 subexpr +-456 5 operator + 0 subexpr -456 3 operator - 0 subexpr 456 1 text 456 0 subexpr 3 1 text 3 0 {}}
test parseExpr-13.7 {ParseMultiplyExpr procedure, bad lexeme after "*", "/", or "%"} {wideIntegerUnparsed} {
    list [catch {testexprparser {--++5 / 12345678901234567890} -1} msg] $msg
} {1 {integer value too large to represent}}
test parseExpr-13.8 {ParseMultiplyExpr procedure, valid RHS subexpression} {
    testexprparser {-2 / 3 % 4} -1
} {- {} 0 subexpr {-2 / 3 % 4} 11 operator % 0 subexpr {-2 / 3} 7 operator / 0 subexpr -2 3 operator - 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 subexpr 4 1 text 4 0 {}}
test parseExpr-13.9 {ParseMultiplyExpr procedure, error in RHS subexpression} {
    list [catch {testexprparser {++2 / 3 * martha} -1} msg] $msg
} {1 {syntax error in expression "++2 / 3 * martha": variable references require preceding $}}

test parseExpr-14.1 {ParseUnaryExpr procedure, first token is unary operator} {
    testexprparser {+2} -1
} {- {} 0 subexpr +2 3 operator + 0 subexpr 2 1 text 2 0 {}}
test parseExpr-14.2 {ParseUnaryExpr procedure, first token is unary operator} {
    testexprparser {-2} -1
} {- {} 0 subexpr -2 3 operator - 0 subexpr 2 1 text 2 0 {}}
test parseExpr-14.3 {ParseUnaryExpr procedure, first token is unary operator} {
    testexprparser {~2} -1
} {- {} 0 subexpr ~2 3 operator ~ 0 subexpr 2 1 text 2 0 {}}
test parseExpr-14.4 {ParseUnaryExpr procedure, first token is unary operator} {
    testexprparser {!2} -1
} {- {} 0 subexpr !2 3 operator ! 0 subexpr 2 1 text 2 0 {}}
test parseExpr-14.5 {ParseUnaryExpr procedure, error in lexeme after unary op} {wideIntegerUnparsed} {
    list [catch {testexprparser {-12345678901234567890} -1} msg] $msg
} {1 {integer value too large to represent}}
test parseExpr-14.6 {ParseUnaryExpr procedure, simple unary expr after unary op} {
    testexprparser {+"1234"} -1
} {- {} 0 subexpr +\"1234\" 3 operator + 0 subexpr {"1234"} 1 text 1234 0 {}}
test parseExpr-14.7 {ParseUnaryExpr procedure, another unary expr after unary op} {
    testexprparser {~!{fred}} -1
} {- {} 0 subexpr ~!{fred} 5 operator ~ 0 subexpr !{fred} 3 operator ! 0 subexpr {{fred}} 1 text fred 0 {}}
test parseExpr-14.8 {ParseUnaryExpr procedure, error in unary expr after unary op} {
    list [catch {testexprparser {+-||27} -1} msg] $msg
} {1 {syntax error in expression "+-||27": unexpected operator ||}}
test parseExpr-14.9 {ParseUnaryExpr procedure, error in unary expr after unary op} {
    list [catch {testexprparser {+-||27} -1} msg] $msg
} {1 {syntax error in expression "+-||27": unexpected operator ||}}
test parseExpr-14.10 {ParseUnaryExpr procedure, first token is not unary op} {
    testexprparser {123} -1
} {- {} 0 subexpr 123 1 text 123 0 {}}
test parseExpr-14.11 {ParseUnaryExpr procedure, not unary expr, complex primary expr} {
    testexprparser {(1+2)} -1
} {- {} 0 subexpr 1+2 5 operator + 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 {}}
test parseExpr-14.12 {ParseUnaryExpr procedure, not unary expr, error in primary expr} {wideIntegerUnparsed} {
    list [catch {testexprparser {(12345678901234567890)} -1} msg] $msg
} {1 {integer value too large to represent}}

test parseExpr-15.1 {ParsePrimaryExpr procedure, just parenthesized subexpr} {
    testexprparser {({abc}/{def})} -1
} {- {} 0 subexpr {{abc}/{def}} 5 operator / 0 subexpr {{abc}} 1 text abc 0 subexpr {{def}} 1 text def 0 {}}
test parseExpr-15.2 {ParsePrimaryExpr procedure, bad lexeme after "("} {wideIntegerUnparsed} {
    list [catch {testexprparser {(12345678901234567890)} -1} msg] $msg
} {1 {integer value too large to represent}}
test parseExpr-15.3 {ParsePrimaryExpr procedure, valid parenthesized subexpr} {
    testexprparser {({abc}? 2*4 : -6)} -1
} {- {} 0 subexpr {{abc}? 2*4 : -6} 13 operator ? 0 subexpr {{abc}} 1 text abc 0 subexpr 2*4 5 operator * 0 subexpr 2 1 text 2 0 subexpr 4 1 text 4 0 subexpr -6 3 operator - 0 subexpr 6 1 text 6 0 {}}
test parseExpr-15.4 {ParsePrimaryExpr procedure, error in parenthesized subexpr} {
    list [catch {testexprparser {(? 123 : 456)} -1} msg] $msg
} {1 {syntax error in expression "(? 123 : 456)": unexpected ternary 'then' separator}}
test parseExpr-15.5 {ParsePrimaryExpr procedure, missing ")" after in parenthesized subexpr} {
    list [catch {testexprparser {({abc}/{def}} -1} msg] $msg
} {1 {syntax error in expression "({abc}/{def}": looking for close parenthesis}}
test parseExpr-15.6 {ParsePrimaryExpr procedure, primary is literal} {
    testexprparser {12345} -1
} {- {} 0 subexpr 12345 1 text 12345 0 {}}
test parseExpr-15.7 {ParsePrimaryExpr procedure, primary is literal} {
    testexprparser {12345.6789} -1
} {- {} 0 subexpr 12345.6789 1 text 12345.6789 0 {}}
test parseExpr-15.8 {ParsePrimaryExpr procedure, primary is var reference} {
    testexprparser {$a} -1
} {- {} 0 subexpr {$a} 2 variable {$a} 1 text a 0 {}}
test parseExpr-15.9 {ParsePrimaryExpr procedure, primary is var reference} {
    testexprparser {$a(hello$there)} -1
} {- {} 0 subexpr {$a(hello$there)} 5 variable {$a(hello$there)} 4 text a 0 text hello 0 variable {$there} 1 text there 0 {}}
test parseExpr-15.10 {ParsePrimaryExpr procedure, primary is var reference} {
    testexprparser {$a()} -1
} {- {} 0 subexpr {$a()} 3 variable {$a()} 2 text a 0 text {} 0 {}}
test parseExpr-15.11 {ParsePrimaryExpr procedure, error in var reference} {
    list [catch {testexprparser {$a(} -1} msg] $msg
} {1 {missing )}}
test parseExpr-15.12 {ParsePrimaryExpr procedure, primary is quoted string} {
    testexprparser {"abc $xyz def"} -1
} {- {} 0 subexpr {"abc $xyz def"} 5 word {"abc $xyz def"} 4 text {abc } 0 variable {$xyz} 1 text xyz 0 text { def} 0 {}}
test parseExpr-15.13 {ParsePrimaryExpr procedure, error in quoted string} {
    list [catch {testexprparser {"$a(12"} -1} msg] $msg
} {1 {missing )}}
test parseExpr-15.14 {ParsePrimaryExpr procedure, quoted string has multiple tokens} {
    testexprparser {"abc [xyz] $def"} -1
} {- {} 0 subexpr {"abc [xyz] $def"} 6 word {"abc [xyz] $def"} 5 text {abc } 0 command {[xyz]} 0 text { } 0 variable {$def} 1 text def 0 {}}
test parseExpr-15.15 {ParsePrimaryExpr procedure, primary is command} {
    testexprparser {[def]} -1
} {- {} 0 subexpr {[def]} 1 command {[def]} 0 {}}
test parseExpr-15.16 {ParsePrimaryExpr procedure, primary is multiple commands} {
    testexprparser {[one; two; three; four;]} -1
} {- {} 0 subexpr {[one; two; three; four;]} 1 command {[one; two; three; four;]} 0 {}}
test parseExpr-15.17 {ParsePrimaryExpr procedure, primary is multiple commands} {
    testexprparser {[one; two; three; four;]} -1
} {- {} 0 subexpr {[one; two; three; four;]} 1 command {[one; two; three; four;]} 0 {}}
test parseExpr-15.18 {ParsePrimaryExpr procedure, missing close bracket} {
    list [catch {testexprparser {[one} -1} msg] $msg
} {1 {missing close-bracket}}
test parseExpr-15.19 {ParsePrimaryExpr procedure, primary is braced string} {
    testexprparser {{hello world}} -1
} {- {} 0 subexpr {{hello world}} 1 text {hello world} 0 {}}
test parseExpr-15.20 {ParsePrimaryExpr procedure, error in primary, which is braced string} {
    list [catch {testexprparser "\{abc\\\n" -1} msg] $msg
} {1 {missing close-brace}}
test parseExpr-15.21 {ParsePrimaryExpr procedure, primary is braced string with multiple tokens} {
    testexprparser "\{  \\
 +123 \}" -1
} {- {} 0 subexpr \{\ \ \\\n\ +123\ \} 4 word \{\ \ \\\n\ +123\ \} 3 text {  } 0 backslash \\\n\  0 text {+123 } 0 {}}
test parseExpr-15.22 {ParsePrimaryExpr procedure, primary is function call} {
    testexprparser {foo(123)} -1
} {- {} 0 subexpr foo(123) 3 operator foo 0 subexpr 123 1 text 123 0 {}}
test parseExpr-15.23 {ParsePrimaryExpr procedure, bad lexeme after function name} {wideIntegerUnparsed} {
    list [catch {testexprparser {foo 12345678901234567890 123)} -1} msg] $msg
} {1 {integer value too large to represent}}
test parseExpr-15.24 {ParsePrimaryExpr procedure, lexeme after function name isn't "("} {
    list [catch {testexprparser {foo 27.4 123)} -1} msg] $msg
} {1 {syntax error in expression "foo 27.4 123)": variable references require preceding $}}
test parseExpr-15.25 {ParsePrimaryExpr procedure, bad lexeme after "("} {wideIntegerUnparsed} {
    list [catch {testexprparser {foo(12345678901234567890)} -1} msg] $msg
} {1 {integer value too large to represent}}
test parseExpr-15.26 {ParsePrimaryExpr procedure, function call, one arg} {
    testexprparser {foo(27*4)} -1
} {- {} 0 subexpr foo(27*4) 7 operator foo 0 subexpr 27*4 5 operator * 0 subexpr 27 1 text 27 0 subexpr 4 1 text 4 0 {}}
test parseExpr-15.27 {ParsePrimaryExpr procedure, error in function arg} {
    list [catch {testexprparser {foo(*1-2)} -1} msg] $msg
} {1 {syntax error in expression "foo(*1-2)": unexpected operator *}}
test parseExpr-15.28 {ParsePrimaryExpr procedure, error in function arg} {
    list [catch {testexprparser {foo(*1-2)} -1} msg] $msg
} {1 {syntax error in expression "foo(*1-2)": unexpected operator *}}
test parseExpr-15.29 {ParsePrimaryExpr procedure, function call, comma after arg} {
    testexprparser {foo(27-2, (-2*[foo]))} -1
} {- {} 0 subexpr {foo(27-2, (-2*[foo]))} 15 operator foo 0 subexpr 27-2 5 operator - 0 subexpr 27 1 text 27 0 subexpr 2 1 text 2 0 subexpr {-2*[foo]} 7 operator * 0 subexpr -2 3 operator - 0 subexpr 2 1 text 2 0 subexpr {[foo]} 1 command {[foo]} 0 {}}
test parseExpr-15.30 {ParsePrimaryExpr procedure, bad lexeme after comma} {wideIntegerUnparsed} {
    list [catch {testexprparser {foo(123, 12345678901234567890)} -1} msg] $msg
} {1 {integer value too large to represent}}
test parseExpr-15.31 {ParsePrimaryExpr procedure, lexeme not "," or ")" after arg} {
    list [catch {testexprparser {foo(123 [foo])} -1} msg] $msg
} {1 {syntax error in expression "foo(123 [foo])": missing close parenthesis at end of function call}}
test parseExpr-15.32 {ParsePrimaryExpr procedure, bad lexeme after primary} {wideIntegerUnparsed} {
    list [catch {testexprparser {123 12345678901234567890} -1} msg] $msg
} {1 {integer value too large to represent}}
test parseExpr-15.33 {ParsePrimaryExpr procedure, comma-specific message} {
    list [catch {testexprparser {123+,456} -1} msg] $msg
} {1 {syntax error in expression "123+,456": commas can only separate function arguments}}
test parseExpr-15.34 {ParsePrimaryExpr procedure, single equal-specific message} {
    list [catch {testexprparser {123+=456} -1} msg] $msg
} {1 {syntax error in expression "123+=456": single equality character not legal in expressions}}
test parseExpr-15.35 {ParsePrimaryExpr procedure, error in parenthesized subexpr} {
    list [catch {testexprparser {(: 123 : 456)} -1} msg] $msg
} {1 {syntax error in expression "(: 123 : 456)": unexpected ternary 'else' separator}}

test parseExpr-16.1 {GetLexeme procedure, whitespace before lexeme} {
    testexprparser {   123} -1
} {- {} 0 subexpr 123 1 text 123 0 {}}
test parseExpr-16.2 {GetLexeme procedure, whitespace before lexeme} {
    testexprparser {  \
456} -1
} {- {} 0 subexpr 456 1 text 456 0 {}}
test parseExpr-16.3 {GetLexeme procedure, no lexeme after whitespace} {
    testexprparser { 123 \
   } -1
} {- {} 0 subexpr 123 1 text 123 0 {}}
test parseExpr-16.4 {GetLexeme procedure, integer lexeme} {
    testexprparser {000} -1
} {- {} 0 subexpr 000 1 text 000 0 {}}
test parseExpr-16.5 {GetLexeme procedure, integer lexeme too big} {wideIntegerUnparsed} {
    list [catch {testexprparser {12345678901234567890} -1} msg] $msg
} {1 {integer value too large to represent}}

test parseExpr-16.6 {GetLexeme procedure, bad integer lexeme} -body {
    testexprparser {0999} -1
} -returnCodes error -match glob -result {*invalid octal number*}

test parseExpr-16.7 {GetLexeme procedure, double lexeme} {
    testexprparser {0.999} -1
} {- {} 0 subexpr 0.999 1 text 0.999 0 {}}
test parseExpr-16.8 {GetLexeme procedure, double lexeme} {
    testexprparser {.123} -1
} {- {} 0 subexpr .123 1 text .123 0 {}}
test parseExpr-16.9 {GetLexeme procedure, double lexeme} {nonPortable unixOnly} {
    testexprparser {nan} -1
} {- {} 0 subexpr nan 1 text nan 0 {}}
test parseExpr-16.10 {GetLexeme procedure, double lexeme} {nonPortable unixOnly} {
    testexprparser {NaN} -1
} {- {} 0 subexpr NaN 1 text NaN 0 {}}
test parseExpr-16.11 {GetLexeme procedure, bad double lexeme too big} {
    list [catch {testexprparser {123.e+99999999999999} -1} msg] $msg
} {1 {floating-point value too large to represent}}
test parseExpr-16.12 {GetLexeme procedure, bad double lexeme} {
    list [catch {testexprparser {123.4x56} -1} msg] $msg
} {1 {syntax error in expression "123.4x56": extra tokens at end of expression}}
test parseExpr-16.13 {GetLexeme procedure, lexeme is "["} {
    testexprparser {[foo]} -1
} {- {} 0 subexpr {[foo]} 1 command {[foo]} 0 {}}
test parseExpr-16.14 {GetLexeme procedure, lexeme is open brace} {
    testexprparser {{bar}} -1
} {- {} 0 subexpr {{bar}} 1 text bar 0 {}}
test parseExpr-16.15 {GetLexeme procedure, lexeme is "("} {
    testexprparser {(123)} -1
} {- {} 0 subexpr 123 1 text 123 0 {}}
test parseExpr-16.16 {GetLexeme procedure, lexeme is ")"} {
    testexprparser {(2*3)} -1
} {- {} 0 subexpr 2*3 5 operator * 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 {}}
test parseExpr-16.17 {GetLexeme procedure, lexeme is "$"} {
    testexprparser {$wombat} -1
} {- {} 0 subexpr {$wombat} 2 variable {$wombat} 1 text wombat 0 {}}
test parseExpr-16.18 "GetLexeme procedure, lexeme is '\"'" {
    testexprparser {"fred"} -1
} {- {} 0 subexpr {"fred"} 1 text fred 0 {}}
test parseExpr-16.19 {GetLexeme procedure, lexeme is ","} {
    testexprparser {foo(1,2)} -1
} {- {} 0 subexpr foo(1,2) 5 operator foo 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 {}}
test parseExpr-16.20 {GetLexeme procedure, lexeme is "*"} {
    testexprparser {$a*$b} -1
} {- {} 0 subexpr {$a*$b} 7 operator * 0 subexpr {$a} 2 variable {$a} 1 text a 0 subexpr {$b} 2 variable {$b} 1 text b 0 {}}
test parseExpr-16.21 {GetLexeme procedure, lexeme is "/"} {
    testexprparser {5/6} -1
} {- {} 0 subexpr 5/6 5 operator / 0 subexpr 5 1 text 5 0 subexpr 6 1 text 6 0 {}}
test parseExpr-16.22 {GetLexeme procedure, lexeme is "%"} {
    testexprparser {5%[xxx]} -1
} {- {} 0 subexpr {5%[xxx]} 5 operator % 0 subexpr 5 1 text 5 0 subexpr {[xxx]} 1 command {[xxx]} 0 {}}
test parseExpr-16.23 {GetLexeme procedure, lexeme is "+"} {
    testexprparser {1+2} -1
} {- {} 0 subexpr 1+2 5 operator + 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 {}}
test parseExpr-16.24 {GetLexeme procedure, lexeme is "-"} {
    testexprparser {.12-0e27} -1
} {- {} 0 subexpr .12-0e27 5 operator - 0 subexpr .12 1 text .12 0 subexpr 0e27 1 text 0e27 0 {}}
test parseExpr-16.25 {GetLexeme procedure, lexeme is "?" or ":"} {
    testexprparser {$b? 1 : 0} -1
} {- {} 0 subexpr {$b? 1 : 0} 8 operator ? 0 subexpr {$b} 2 variable {$b} 1 text b 0 subexpr 1 1 text 1 0 subexpr 0 1 text 0 0 {}}
test parseExpr-16.26 {GetLexeme procedure, lexeme is "<"} {
    testexprparser {2<3} -1
} {- {} 0 subexpr 2<3 5 operator < 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 {}}
test parseExpr-16.27 {GetLexeme procedure, lexeme is "<<"} {
    testexprparser {2<<3} -1
} {- {} 0 subexpr 2<<3 5 operator << 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 {}}
test parseExpr-16.28 {GetLexeme procedure, lexeme is "<="} {
    testexprparser {2<=3} -1
} {- {} 0 subexpr 2<=3 5 operator <= 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 {}}
test parseExpr-16.29 {GetLexeme procedure, lexeme is ">"} {
    testexprparser {2>3} -1
} {- {} 0 subexpr 2>3 5 operator > 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 {}}
test parseExpr-16.30 {GetLexeme procedure, lexeme is ">>"} {
    testexprparser {2>>3} -1
} {- {} 0 subexpr 2>>3 5 operator >> 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 {}}
test parseExpr-16.31 {GetLexeme procedure, lexeme is ">="} {
    testexprparser {2>=3} -1
} {- {} 0 subexpr 2>=3 5 operator >= 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 {}}
test parseExpr-16.32 {GetLexeme procedure, lexeme is "=="} {
    testexprparser {2==3} -1
} {- {} 0 subexpr 2==3 5 operator == 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 {}}
test parseExpr-16.33 {GetLexeme procedure, bad lexeme starting with "="} {
    list [catch {testexprparser {2=+3} -1} msg] $msg
} {1 {syntax error in expression "2=+3": extra tokens at end of expression}}
test parseExpr-16.34 {GetLexeme procedure, lexeme is "!="} {
    testexprparser {2!=3} -1
} {- {} 0 subexpr 2!=3 5 operator != 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 {}}
test parseExpr-16.35 {GetLexeme procedure, lexeme is "!"} {
    testexprparser {!2} -1
} {- {} 0 subexpr !2 3 operator ! 0 subexpr 2 1 text 2 0 {}}
test parseExpr-16.36 {GetLexeme procedure, lexeme is "&&"} {
    testexprparser {2&&3} -1
} {- {} 0 subexpr 2&&3 5 operator && 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 {}}
test parseExpr-16.37 {GetLexeme procedure, lexeme is "&"} {
    testexprparser {1&2} -1
} {- {} 0 subexpr 1&2 5 operator & 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 {}}
test parseExpr-16.38 {GetLexeme procedure, lexeme is "^"} {
    testexprparser {1^2} -1
} {- {} 0 subexpr 1^2 5 operator ^ 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 {}}
test parseExpr-16.39 {GetLexeme procedure, lexeme is "||"} {
    testexprparser {2||3} -1
} {- {} 0 subexpr 2||3 5 operator || 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 {}}
test parseExpr-16.40 {GetLexeme procedure, lexeme is "|"} {
    testexprparser {1|2} -1
} {- {} 0 subexpr 1|2 5 operator | 0 subexpr 1 1 text 1 0 subexpr 2 1 text 2 0 {}}
test parseExpr-16.41 {GetLexeme procedure, lexeme is "~"} {
    testexprparser {~2} -1
} {- {} 0 subexpr ~2 3 operator ~ 0 subexpr 2 1 text 2 0 {}}
test parseExpr-16.42 {GetLexeme procedure, lexeme is func name} {
    testexprparser {george()} -1
} {- {} 0 subexpr george() 1 operator george 0 {}}
test parseExpr-16.43 {GetLexeme procedure, lexeme is func name} {
    testexprparser {harmonic_ratio(2,3)} -1
} {- {} 0 subexpr harmonic_ratio(2,3) 5 operator harmonic_ratio 0 subexpr 2 1 text 2 0 subexpr 3 1 text 3 0 {}}
test parseExpr-16.44 {GetLexeme procedure, unknown lexeme} {
    list [catch {testexprparser {@@27} -1} msg] $msg
} {1 {syntax error in expression "@@27": character not legal in expressions}}

test parseExpr-17.1 {PrependSubExprTokens procedure, expand token array} {
    testexprparser {[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]} -1
} {- {} 0 subexpr {[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]} 13 operator && 0 subexpr {[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]} 9 operator && 0 subexpr {[string compare [format %c $i] [string index $a $i]]&&[string compare [format %c $i] [string index $a $i]]} 5 operator && 0 subexpr {[string compare [format %c $i] [string index $a $i]]} 1 command {[string compare [format %c $i] [string index $a $i]]} 0 subexpr {[string compare [format %c $i] [string index $a $i]]} 1 command {[string compare [format %c $i] [string index $a $i]]} 0 subexpr {[string compare [format %c $i] [string index $a $i]]} 1 command {[string compare [format %c $i] [string index $a $i]]} 0 subexpr {[string compare [format %c $i] [string index $a $i]]} 1 command {[string compare [format %c $i] [string index $a $i]]} 0 {}}

test parseExpr-18.1 {LogSyntaxError procedure, error in expr longer than 60 chars} {
    list [catch {testexprparser {(+0123456)*(+0123456)*(+0123456)*(+0123456)*(+0123456)*(+0123456)*(+0123456)/} -1} msg] $msg
} {1 {syntax error in expression "(+0123456)*(+0123456)*(+0123456)*(+0123456)*(+0123456)*(+012...": premature end of expression}}

# cleanup
::tcltest::cleanupTests
return
@


1.4
log
@touched all sources to ease next import
@
text
@d11 1
a11 1
# RCS: @@(#) $Id: parseExpr.test,v 1.5.8.2 2000/09/15 16:57:12 spolk Exp $
d30 5
d41 1
a41 1
test parseExpr-1.3 {Tcl_ParseExpr procedure, error getting initial lexeme} {nonPortable} {
d46 1
a46 1
} {1 {syntax error in expression "foo+"}}
d49 1
a49 1
} {1 {syntax error in expression "1+2 345"}}
d56 1
a56 1
} {1 {syntax error in expression "0 || foo"}}
d63 1
a63 1
test parseExpr-2.5 {ParseCondExpr procedure, bad lexeme after "?"} {nonPortable} {
d71 1
a71 1
} {1 {syntax error in expression "1? fred : martha"}}
d74 1
a74 1
} {1 {syntax error in expression "1? 2 martha 3"}}
d80 1
a80 1
} {1 {syntax error in expression "1? 2 : martha"}}
d87 1
a87 1
} {1 {syntax error in expression "1&&foo || 3"}}
d94 1
a94 1
test parseExpr-3.5 {ParseLorExpr procedure, bad lexeme after "||"} {nonPortable} {
d102 1
a102 1
} {1 {syntax error in expression "1&&2 || 3 || martha"}}
d109 1
a109 1
} {1 {syntax error in expression "1&&foo && 3"}}
d116 1
a116 1
test parseExpr-4.5 {ParseLandExpr procedure, bad lexeme after "&&"} {nonPortable} {
d124 1
a124 1
} {1 {syntax error in expression "1|2 && 3 && martha"}}
d131 1
a131 1
} {1 {syntax error in expression "1|foo | 3"}}
d138 1
a138 1
test parseExpr-5.5 {ParseBitOrExpr procedure, bad lexeme after "|"} {nonPortable} {
d146 1
a146 1
} {1 {syntax error in expression "1^2 | 3 | martha"}}
d153 1
a153 1
} {1 {syntax error in expression "1^foo ^ 3"}}
d160 1
a160 1
test parseExpr-6.5 {ParseBitXorExpr procedure, bad lexeme after "^"} {nonPortable} {
d168 1
a168 1
} {1 {syntax error in expression "1&2 ^ 3 ^ martha"}}
d175 1
a175 1
} {1 {syntax error in expression "1!=foo & 3"}}
d182 1
a182 1
test parseExpr-7.5 {ParseBitAndExpr procedure, bad lexeme after "&"} {nonPortable} {
d190 1
a190 1
} {1 {syntax error in expression "1==2 & 3>2 & martha"}}
d192 1
a192 1
test parseExpr-7.1 {ParseEqualityExpr procedure, valid LHS relational subexpr} {
d195 1
a195 1
test parseExpr-7.2 {ParseEqualityExpr procedure, error in LHS relational subexpr} {
d197 2
a198 2
} {1 {syntax error in expression "1>=foo == 3"}}
test parseExpr-7.3 {ParseEqualityExpr procedure, next lexeme isn't "==" or "!="} {
d201 1
a201 1
test parseExpr-7.4 {ParseEqualityExpr procedure, next lexeme is "==" or "!=} {
d204 1
a204 1
test parseExpr-7.5 {ParseEqualityExpr procedure, next lexeme is "==" or "!="} {
d207 1
a207 1
test parseExpr-7.6 {ParseEqualityExpr procedure, bad lexeme after "==" or "!="} {nonPortable} {
d210 1
a210 1
test parseExpr-7.7 {ParseEqualityExpr procedure, valid RHS subexpression} {
d213 1
a213 1
test parseExpr-7.8 {ParseEqualityExpr procedure, error in RHS subexpression} {
d215 1
a215 1
} {1 {syntax error in expression "1<2 == 3 != martha"}}
d217 1
a217 1
test parseExpr-8.1 {ParseRelationalExpr procedure, valid LHS shift subexpr} {
d220 1
a220 1
test parseExpr-8.2 {ParseRelationalExpr procedure, error in LHS shift subexpr} {
d222 2
a223 2
} {1 {syntax error in expression "1>=foo < 3"}}
test parseExpr-8.3 {ParseRelationalExpr procedure, next lexeme isn't relational op} {
d226 1
a226 1
test parseExpr-8.4 {ParseRelationalExpr procedure, next lexeme is relational op} {
d229 1
a229 1
test parseExpr-8.5 {ParseRelationalExpr procedure, next lexeme is relational op} {
d232 1
a232 1
test parseExpr-8.6 {ParseRelationalExpr procedure, next lexeme is relational op} {
d235 1
a235 1
test parseExpr-8.7 {ParseRelationalExpr procedure, next lexeme is relational op} {
d238 1
a238 1
test parseExpr-8.8 {ParseRelationalExpr procedure, bad lexeme after relational op} {nonPortable} {
d241 1
a241 1
test parseExpr-8.9 {ParseRelationalExpr procedure, valid RHS subexpression} {
d244 1
a244 1
test parseExpr-8.8 {ParseRelationalExpr procedure, error in RHS subexpression} {
d246 1
a246 1
} {1 {syntax error in expression "1<<2 < 3 > martha"}}
d248 1
a248 1
test parseExpr-9.1 {ParseShiftExpr procedure, valid LHS add subexpr} {
d251 1
a251 1
test parseExpr-9.2 {ParseShiftExpr procedure, error in LHS add subexpr} {
d253 2
a254 2
} {1 {syntax error in expression "1-foo << 3"}}
test parseExpr-9.3 {ParseShiftExpr procedure, next lexeme isn't "<<" or ">>"} {
d257 1
a257 1
test parseExpr-9.4 {ParseShiftExpr procedure, next lexeme is "<<" or ">>} {
d260 1
a260 1
test parseExpr-9.5 {ParseShiftExpr procedure, next lexeme is "<<" or ">>"} {
d263 1
a263 1
test parseExpr-9.6 {ParseShiftExpr procedure, bad lexeme after "<<" or ">>"} {nonPortable} {
d266 1
a266 1
test parseExpr-9.7 {ParseShiftExpr procedure, valid RHS subexpression} {
d269 1
a269 1
test parseExpr-9.8 {ParseShiftExpr procedure, error in RHS subexpression} {
d271 1
a271 1
} {1 {syntax error in expression "1+2 << 3 >> martha"}}
d273 1
a273 1
test parseExpr-10.1 {ParseAddExpr procedure, valid LHS multiply subexpr} {
d276 1
a276 1
test parseExpr-10.2 {ParseAddExpr procedure, error in LHS multiply subexpr} {
d278 2
a279 2
} {1 {syntax error in expression "1/foo + 3"}}
test parseExpr-10.3 {ParseAddExpr procedure, next lexeme isn't "+" or "-"} {
d282 1
a282 1
test parseExpr-10.4 {ParseAddExpr procedure, next lexeme is "+" or "-} {
d285 1
a285 1
test parseExpr-10.5 {ParseAddExpr procedure, next lexeme is "+" or "-"} {
d288 1
a288 1
test parseExpr-10.6 {ParseAddExpr procedure, bad lexeme after "+" or "-"} {nonPortable} {
d291 1
a291 1
test parseExpr-10.7 {ParseAddExpr procedure, valid RHS subexpression} {
d294 1
a294 1
test parseExpr-10.8 {ParseAddExpr procedure, error in RHS subexpression} {
d296 1
a296 1
} {1 {syntax error in expression "1*2 + 3 - martha"}}
d298 1
a298 1
test parseExpr-10.1 {ParseAddExpr procedure, valid LHS multiply subexpr} {
d301 1
a301 1
test parseExpr-10.2 {ParseAddExpr procedure, error in LHS multiply subexpr} {
d303 2
a304 2
} {1 {syntax error in expression "1/foo + 3"}}
test parseExpr-10.3 {ParseAddExpr procedure, next lexeme isn't "+" or "-"} {
d307 1
a307 1
test parseExpr-10.4 {ParseAddExpr procedure, next lexeme is "+" or "-} {
d310 1
a310 1
test parseExpr-10.5 {ParseAddExpr procedure, next lexeme is "+" or "-"} {
d313 1
a313 1
test parseExpr-10.6 {ParseAddExpr procedure, bad lexeme after "+" or "-"} {nonPortable} {
d316 1
a316 1
test parseExpr-10.7 {ParseAddExpr procedure, valid RHS subexpression} {
d319 1
a319 1
test parseExpr-10.8 {ParseAddExpr procedure, error in RHS subexpression} {
d321 1
a321 1
} {1 {syntax error in expression "1*2 + 3 - martha"}}
d323 1
a323 1
test parseExpr-11.1 {ParseMultiplyExpr procedure, valid LHS unary subexpr} {
d326 1
a326 1
test parseExpr-11.2 {ParseMultiplyExpr procedure, error in LHS unary subexpr} {nonPortable} {
d329 1
a329 1
test parseExpr-11.3 {ParseMultiplyExpr procedure, next lexeme isn't "*", "/", or "%"} {
d332 1
a332 1
test parseExpr-11.4 {ParseMultiplyExpr procedure, next lexeme is "*", "/", or "%"} {
d335 1
a335 1
test parseExpr-11.5 {ParseMultiplyExpr procedure, next lexeme is "*", "/", or "%"} {
d338 1
a338 1
test parseExpr-11.6 {ParseMultiplyExpr procedure, next lexeme is "*", "/", or "%"} {
d341 1
a341 1
test parseExpr-11.7 {ParseMultiplyExpr procedure, bad lexeme after "*", "/", or "%"} {nonPortable} {
d344 1
a344 1
test parseExpr-11.8 {ParseMultiplyExpr procedure, valid RHS subexpression} {
d347 1
a347 1
test parseExpr-11.9 {ParseMultiplyExpr procedure, error in RHS subexpression} {
d349 1
a349 1
} {1 {syntax error in expression "++2 / 3 * martha"}}
d351 1
a351 1
test parseExpr-12.1 {ParseUnaryExpr procedure, first token is unary operator} {
d354 1
a354 1
test parseExpr-12.2 {ParseUnaryExpr procedure, first token is unary operator} {
d357 1
a357 1
test parseExpr-12.3 {ParseUnaryExpr procedure, first token is unary operator} {
d360 1
a360 1
test parseExpr-12.4 {ParseUnaryExpr procedure, first token is unary operator} {
d363 1
a363 1
test parseExpr-12.5 {ParseUnaryExpr procedure, error in lexeme after unary op} {nonPortable} {
d366 1
a366 1
test parseExpr-12.6 {ParseUnaryExpr procedure, simple unary expr after unary op} {
d369 1
a369 1
test parseExpr-12.7 {ParseUnaryExpr procedure, another unary expr after unary op} {
d372 1
a372 1
test parseExpr-12.8 {ParseUnaryExpr procedure, error in unary expr after unary op} {
d374 2
a375 2
} {1 {syntax error in expression "+-||27"}}
test parseExpr-12.9 {ParseUnaryExpr procedure, error in unary expr after unary op} {
d377 2
a378 2
} {1 {syntax error in expression "+-||27"}}
test parseExpr-12.10 {ParseUnaryExpr procedure, first token is not unary op} {
d381 1
a381 1
test parseExpr-12.11 {ParseUnaryExpr procedure, not unary expr, complex primary expr} {
d384 1
a384 1
test parseExpr-12.12 {ParseUnaryExpr procedure, not unary expr, error in primary expr} {nonPortable} {
d388 1
a388 1
test parseExpr-13.1 {ParsePrimaryExpr procedure, just parenthesized subexpr} {
d391 1
a391 1
test parseExpr-13.2 {ParsePrimaryExpr procedure, bad lexeme after "("} {nonPortable} {
d394 1
a394 1
test parseExpr-13.3 {ParsePrimaryExpr procedure, valid parenthesized subexpr} {
d397 1
a397 1
test parseExpr-13.4 {ParsePrimaryExpr procedure, error in parenthesized subexpr} {
d399 2
a400 2
} {1 {syntax error in expression "(? 123 : 456)"}}
test parseExpr-13.5 {ParsePrimaryExpr procedure, missing ")" after in parenthesized subexpr} {
d402 2
a403 2
} {1 {syntax error in expression "({abc}/{def}"}}
test parseExpr-13.6 {ParsePrimaryExpr procedure, primary is literal} {
d406 1
a406 1
test parseExpr-13.7 {ParsePrimaryExpr procedure, primary is literal} {
d409 1
a409 1
test parseExpr-13.8 {ParsePrimaryExpr procedure, primary is var reference} {
d412 1
a412 1
test parseExpr-13.9 {ParsePrimaryExpr procedure, primary is var reference} {
d415 1
a415 1
test parseExpr-13.10 {ParsePrimaryExpr procedure, primary is var reference} {
d418 1
a418 1
test parseExpr-13.11 {ParsePrimaryExpr procedure, error in var reference} {
d421 1
a421 1
test parseExpr-13.12 {ParsePrimaryExpr procedure, primary is quoted string} {
d424 1
a424 1
test parseExpr-13.13 {ParsePrimaryExpr procedure, error in quoted string} {
d427 1
a427 1
test parseExpr-13.14 {ParsePrimaryExpr procedure, quoted string has multiple tokens} {
d430 1
a430 1
test parseExpr-13.15 {ParsePrimaryExpr procedure, primary is command} {
d433 1
a433 1
test parseExpr-13.16 {ParsePrimaryExpr procedure, primary is multiple commands} {
d436 1
a436 1
test parseExpr-13.17 {ParsePrimaryExpr procedure, primary is multiple commands} {
d439 1
a439 1
test parseExpr-13.18 {ParsePrimaryExpr procedure, missing close bracket} {
d442 1
a442 1
test parseExpr-13.19 {ParsePrimaryExpr procedure, primary is braced string} {
d445 1
a445 1
test parseExpr-13.20 {ParsePrimaryExpr procedure, error in primary, which is braced string} {
d448 1
a448 1
test parseExpr-13.21 {ParsePrimaryExpr procedure, primary is braced string with multiple tokens} {
d452 1
a452 1
test parseExpr-13.22 {ParsePrimaryExpr procedure, primary is function call} {
d455 1
a455 1
test parseExpr-13.23 {ParsePrimaryExpr procedure, bad lexeme after function name} {nonPortable} {
d458 1
a458 1
test parseExpr-13.24 {ParsePrimaryExpr procedure, lexeme after function name isn't "("} {
d460 2
a461 2
} {1 {syntax error in expression "foo 27.4 123)"}}
test parseExpr-13.25 {ParsePrimaryExpr procedure, bad lexeme after "("} {nonPortable} {
d464 1
a464 1
test parseExpr-13.26 {ParsePrimaryExpr procedure, function call, one arg} {
d467 1
a467 1
test parseExpr-13.27 {ParsePrimaryExpr procedure, error in function arg} {
d469 2
a470 2
} {1 {syntax error in expression "foo(*1-2)"}}
test parseExpr-13.28 {ParsePrimaryExpr procedure, error in function arg} {
d472 2
a473 2
} {1 {syntax error in expression "foo(*1-2)"}}
test parseExpr-13.29 {ParsePrimaryExpr procedure, function call, comma after arg} {
d476 1
a476 1
test parseExpr-13.30 {ParsePrimaryExpr procedure, bad lexeme after comma} {nonPortable} {
d479 1
a479 1
test parseExpr-13.31 {ParsePrimaryExpr procedure, lexeme not "," or ")" after arg} {
d481 2
a482 2
} {1 {syntax error in expression "foo(123 [foo])"}}
test parseExpr-13.32 {ParsePrimaryExpr procedure, bad lexeme after primary} {nonPortable} {
d485 9
d495 1
a495 1
test parseExpr-14.1 {GetLexeme procedure, whitespace before lexeme} {
d498 1
a498 1
test parseExpr-14.2 {GetLexeme procedure, whitespace before lexeme} {
d502 1
a502 1
test parseExpr-14.3 {GetLexeme procedure, no lexeme after whitespace} {
d506 1
a506 1
test parseExpr-14.4 {GetLexeme procedure, integer lexeme} {
d509 1
a509 1
test parseExpr-14.5 {GetLexeme procedure, integer lexeme too big} {nonPortable} {
d512 6
a517 4
test parseExpr-14.6 {GetLexeme procedure, bad integer lexeme} {
    list [catch {testexprparser {0999} -1} msg] $msg
} {1 {"0999" is an invalid octal number}}
test parseExpr-14.7 {GetLexeme procedure, double lexeme} {
d520 1
a520 1
test parseExpr-14.8 {GetLexeme procedure, double lexeme} {
d523 1
a523 1
test parseExpr-14.9 {GetLexeme procedure, double lexeme} {nonPortable unixOnly} {
d526 1
a526 1
test parseExpr-14.10 {GetLexeme procedure, double lexeme} {nonPortable unixOnly} {
d529 1
a529 1
test parseExpr-14.11 {GetLexeme procedure, bad double lexeme too big} {
d532 1
a532 1
test parseExpr-14.12 {GetLexeme procedure, bad double lexeme} {
d534 2
a535 2
} {1 {syntax error in expression "123.4x56"}}
test parseExpr-14.13 {GetLexeme procedure, lexeme is "["} {
d538 1
a538 1
test parseExpr-14.14 {GetLexeme procedure, lexeme is open brace} {
d541 1
a541 1
test parseExpr-14.15 {GetLexeme procedure, lexeme is "("} {
d544 1
a544 1
test parseExpr-14.16 {GetLexeme procedure, lexeme is ")"} {
d547 1
a547 1
test parseExpr-14.17 {GetLexeme procedure, lexeme is "$"} {
d550 1
a550 1
test parseExpr-14.18 {GetLexeme procedure, lexeme is '"'} {
d553 1
a553 1
test parseExpr-14.19 {GetLexeme procedure, lexeme is ","} {
d556 1
a556 1
test parseExpr-14.20 {GetLexeme procedure, lexeme is "*"} {
d559 1
a559 1
test parseExpr-14.21 {GetLexeme procedure, lexeme is "/"} {
d562 1
a562 1
test parseExpr-14.22 {GetLexeme procedure, lexeme is "%"} {
d565 1
a565 1
test parseExpr-14.23 {GetLexeme procedure, lexeme is "+"} {
d568 1
a568 1
test parseExpr-14.24 {GetLexeme procedure, lexeme is "-"} {
d571 1
a571 1
test parseExpr-14.25 {GetLexeme procedure, lexeme is "?" or ":"} {
d574 1
a574 1
test parseExpr-14.26 {GetLexeme procedure, lexeme is "<"} {
d577 1
a577 1
test parseExpr-14.27 {GetLexeme procedure, lexeme is "<<"} {
d580 1
a580 1
test parseExpr-14.28 {GetLexeme procedure, lexeme is "<="} {
d583 1
a583 1
test parseExpr-14.29 {GetLexeme procedure, lexeme is ">"} {
d586 1
a586 1
test parseExpr-14.30 {GetLexeme procedure, lexeme is ">>"} {
d589 1
a589 1
test parseExpr-14.31 {GetLexeme procedure, lexeme is ">="} {
d592 1
a592 1
test parseExpr-14.32 {GetLexeme procedure, lexeme is "=="} {
d595 1
a595 1
test parseExpr-14.33 {GetLexeme procedure, bad lexeme starting with "="} {
d597 2
a598 2
} {1 {syntax error in expression "2=+3"}}
test parseExpr-14.34 {GetLexeme procedure, lexeme is "!="} {
d601 1
a601 1
test parseExpr-14.35 {GetLexeme procedure, lexeme is "!"} {
d604 1
a604 1
test parseExpr-14.36 {GetLexeme procedure, lexeme is "&&"} {
d607 1
a607 1
test parseExpr-14.37 {GetLexeme procedure, lexeme is "&"} {
d610 1
a610 1
test parseExpr-14.38 {GetLexeme procedure, lexeme is "^"} {
d613 1
a613 1
test parseExpr-14.39 {GetLexeme procedure, lexeme is "||"} {
d616 1
a616 1
test parseExpr-14.40 {GetLexeme procedure, lexeme is "|"} {
d619 1
a619 1
test parseExpr-14.41 {GetLexeme procedure, lexeme is "~"} {
d622 1
a622 1
test parseExpr-14.42 {GetLexeme procedure, lexeme is func name} {
d625 1
a625 1
test parseExpr-14.43 {GetLexeme procedure, lexeme is func name} {
d628 1
a628 1
test parseExpr-14.44 {GetLexeme procedure, unknown lexeme} {
d630 1
a630 1
} {1 {syntax error in expression "@@27"}}
d632 1
a632 1
test parseExpr-15.1 {PrependSubExprTokens procedure, expand token array} {
d636 1
a636 1
test parse-16.1 {LogSyntaxError procedure, error in expr longer than 60 chars} {
d638 1
a638 1
} {1 {syntax error in expression "(+0123456)*(+0123456)*(+0123456)*(+0123456)*(+0123456)*(+012"}}
a642 13













@


1.3
log
@touched all sources to ease next import
@
text
@@


1.3.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d11 1
a11 1
# RCS: @@(#) $Id: parseExpr.test,v 1.8 2002/08/05 03:24:41 dgp Exp $
a29 5
# Some tests only work if wide integers (>32bit) are not found to be
# integers at all.
set ::tcltest::testConstraints(wideIntegerUnparsed) \
	[expr {-1 == 0xffffffff}]

d36 1
a36 1
test parseExpr-1.3 {Tcl_ParseExpr procedure, error getting initial lexeme} {wideIntegerUnparsed} {
d41 1
a41 1
} {1 {syntax error in expression "foo+": variable references require preceding $}}
d44 1
a44 1
} {1 {syntax error in expression "1+2 345": extra tokens at end of expression}}
d51 1
a51 1
} {1 {syntax error in expression "0 || foo": variable references require preceding $}}
d58 1
a58 1
test parseExpr-2.5 {ParseCondExpr procedure, bad lexeme after "?"} {wideIntegerUnparsed} {
d66 1
a66 1
} {1 {syntax error in expression "1? fred : martha": variable references require preceding $}}
d69 1
a69 1
} {1 {syntax error in expression "1? 2 martha 3": missing colon from ternary conditional}}
d75 1
a75 1
} {1 {syntax error in expression "1? 2 : martha": variable references require preceding $}}
d82 1
a82 1
} {1 {syntax error in expression "1&&foo || 3": variable references require preceding $}}
d89 1
a89 1
test parseExpr-3.5 {ParseLorExpr procedure, bad lexeme after "||"} {wideIntegerUnparsed} {
d97 1
a97 1
} {1 {syntax error in expression "1&&2 || 3 || martha": variable references require preceding $}}
d104 1
a104 1
} {1 {syntax error in expression "1&&foo && 3": variable references require preceding $}}
d111 1
a111 1
test parseExpr-4.5 {ParseLandExpr procedure, bad lexeme after "&&"} {wideIntegerUnparsed} {
d119 1
a119 1
} {1 {syntax error in expression "1|2 && 3 && martha": variable references require preceding $}}
d126 1
a126 1
} {1 {syntax error in expression "1|foo | 3": variable references require preceding $}}
d133 1
a133 1
test parseExpr-5.5 {ParseBitOrExpr procedure, bad lexeme after "|"} {wideIntegerUnparsed} {
d141 1
a141 1
} {1 {syntax error in expression "1^2 | 3 | martha": variable references require preceding $}}
d148 1
a148 1
} {1 {syntax error in expression "1^foo ^ 3": variable references require preceding $}}
d155 1
a155 1
test parseExpr-6.5 {ParseBitXorExpr procedure, bad lexeme after "^"} {wideIntegerUnparsed} {
d163 1
a163 1
} {1 {syntax error in expression "1&2 ^ 3 ^ martha": variable references require preceding $}}
d170 1
a170 1
} {1 {syntax error in expression "1!=foo & 3": variable references require preceding $}}
d177 1
a177 1
test parseExpr-7.5 {ParseBitAndExpr procedure, bad lexeme after "&"} {wideIntegerUnparsed} {
d185 1
a185 1
} {1 {syntax error in expression "1==2 & 3>2 & martha": variable references require preceding $}}
d187 1
a187 1
test parseExpr-8.1 {ParseEqualityExpr procedure, valid LHS relational subexpr} {
d190 1
a190 1
test parseExpr-8.2 {ParseEqualityExpr procedure, error in LHS relational subexpr} {
d192 2
a193 2
} {1 {syntax error in expression "1>=foo == 3": variable references require preceding $}}
test parseExpr-8.3 {ParseEqualityExpr procedure, next lexeme isn't "==" or "!="} {
d196 1
a196 1
test parseExpr-8.4 {ParseEqualityExpr procedure, next lexeme is "==" or "!="} {
d199 1
a199 1
test parseExpr-8.5 {ParseEqualityExpr procedure, next lexeme is "==" or "!="} {
d202 1
a202 1
test parseExpr-8.6 {ParseEqualityExpr procedure, bad lexeme after "==" or "!="} {wideIntegerUnparsed} {
d205 1
a205 1
test parseExpr-8.7 {ParseEqualityExpr procedure, valid RHS subexpression} {
d208 1
a208 1
test parseExpr-8.8 {ParseEqualityExpr procedure, error in RHS subexpression} {
d210 1
a210 1
} {1 {syntax error in expression "1<2 == 3 != martha": variable references require preceding $}}
d212 1
a212 1
test parseExpr-9.1 {ParseRelationalExpr procedure, valid LHS shift subexpr} {
d215 1
a215 1
test parseExpr-9.2 {ParseRelationalExpr procedure, error in LHS shift subexpr} {
d217 2
a218 2
} {1 {syntax error in expression "1>=foo < 3": variable references require preceding $}}
test parseExpr-9.3 {ParseRelationalExpr procedure, next lexeme isn't relational op} {
d221 1
a221 1
test parseExpr-9.4 {ParseRelationalExpr procedure, next lexeme is relational op} {
d224 1
a224 1
test parseExpr-9.5 {ParseRelationalExpr procedure, next lexeme is relational op} {
d227 1
a227 1
test parseExpr-9.6 {ParseRelationalExpr procedure, next lexeme is relational op} {
d230 1
a230 1
test parseExpr-9.7 {ParseRelationalExpr procedure, next lexeme is relational op} {
d233 1
a233 1
test parseExpr-9.8 {ParseRelationalExpr procedure, bad lexeme after relational op} {wideIntegerUnparsed} {
d236 1
a236 1
test parseExpr-9.9 {ParseRelationalExpr procedure, valid RHS subexpression} {
d239 1
a239 1
test parseExpr-9.10 {ParseRelationalExpr procedure, error in RHS subexpression} {
d241 1
a241 1
} {1 {syntax error in expression "1<<2 < 3 > martha": variable references require preceding $}}
d243 1
a243 1
test parseExpr-10.1 {ParseShiftExpr procedure, valid LHS add subexpr} {
d246 1
a246 1
test parseExpr-10.2 {ParseShiftExpr procedure, error in LHS add subexpr} {
d248 2
a249 2
} {1 {syntax error in expression "1-foo << 3": variable references require preceding $}}
test parseExpr-10.3 {ParseShiftExpr procedure, next lexeme isn't "<<" or ">>"} {
d252 1
a252 1
test parseExpr-10.4 {ParseShiftExpr procedure, next lexeme is "<<" or ">>"} {
d255 1
a255 1
test parseExpr-10.5 {ParseShiftExpr procedure, next lexeme is "<<" or ">>"} {
d258 1
a258 1
test parseExpr-10.6 {ParseShiftExpr procedure, bad lexeme after "<<" or ">>"} {wideIntegerUnparsed} {
d261 1
a261 1
test parseExpr-10.7 {ParseShiftExpr procedure, valid RHS subexpression} {
d264 1
a264 1
test parseExpr-10.8 {ParseShiftExpr procedure, error in RHS subexpression} {
d266 1
a266 1
} {1 {syntax error in expression "1+2 << 3 >> martha": variable references require preceding $}}
d268 1
a268 1
test parseExpr-11.1 {ParseAddExpr procedure, valid LHS multiply subexpr} {
d271 1
a271 1
test parseExpr-11.2 {ParseAddExpr procedure, error in LHS multiply subexpr} {
d273 2
a274 2
} {1 {syntax error in expression "1/foo + 3": variable references require preceding $}}
test parseExpr-11.3 {ParseAddExpr procedure, next lexeme isn't "+" or "-"} {
d277 1
a277 1
test parseExpr-11.4 {ParseAddExpr procedure, next lexeme is "+" or "-"} {
d280 1
a280 1
test parseExpr-11.5 {ParseAddExpr procedure, next lexeme is "+" or "-"} {
d283 1
a283 1
test parseExpr-11.6 {ParseAddExpr procedure, bad lexeme after "+" or "-"} {wideIntegerUnparsed} {
d286 1
a286 1
test parseExpr-11.7 {ParseAddExpr procedure, valid RHS subexpression} {
d289 1
a289 1
test parseExpr-11.8 {ParseAddExpr procedure, error in RHS subexpression} {
d291 1
a291 1
} {1 {syntax error in expression "1*2 + 3 - martha": variable references require preceding $}}
d293 1
a293 1
test parseExpr-12.1 {ParseAddExpr procedure, valid LHS multiply subexpr} {
d296 1
a296 1
test parseExpr-12.2 {ParseAddExpr procedure, error in LHS multiply subexpr} {
d298 2
a299 2
} {1 {syntax error in expression "1/foo + 3": variable references require preceding $}}
test parseExpr-12.3 {ParseAddExpr procedure, next lexeme isn't "+" or "-"} {
d302 1
a302 1
test parseExpr-12.4 {ParseAddExpr procedure, next lexeme is "+" or "-"} {
d305 1
a305 1
test parseExpr-12.5 {ParseAddExpr procedure, next lexeme is "+" or "-"} {
d308 1
a308 1
test parseExpr-12.6 {ParseAddExpr procedure, bad lexeme after "+" or "-"} {wideIntegerUnparsed} {
d311 1
a311 1
test parseExpr-12.7 {ParseAddExpr procedure, valid RHS subexpression} {
d314 1
a314 1
test parseExpr-12.8 {ParseAddExpr procedure, error in RHS subexpression} {
d316 1
a316 1
} {1 {syntax error in expression "1*2 + 3 - martha": variable references require preceding $}}
d318 1
a318 1
test parseExpr-13.1 {ParseMultiplyExpr procedure, valid LHS unary subexpr} {
d321 1
a321 1
test parseExpr-13.2 {ParseMultiplyExpr procedure, error in LHS unary subexpr} {wideIntegerUnparsed} {
d324 1
a324 1
test parseExpr-13.3 {ParseMultiplyExpr procedure, next lexeme isn't "*", "/", or "%"} {
d327 1
a327 1
test parseExpr-13.4 {ParseMultiplyExpr procedure, next lexeme is "*", "/", or "%"} {
d330 1
a330 1
test parseExpr-13.5 {ParseMultiplyExpr procedure, next lexeme is "*", "/", or "%"} {
d333 1
a333 1
test parseExpr-13.6 {ParseMultiplyExpr procedure, next lexeme is "*", "/", or "%"} {
d336 1
a336 1
test parseExpr-13.7 {ParseMultiplyExpr procedure, bad lexeme after "*", "/", or "%"} {wideIntegerUnparsed} {
d339 1
a339 1
test parseExpr-13.8 {ParseMultiplyExpr procedure, valid RHS subexpression} {
d342 1
a342 1
test parseExpr-13.9 {ParseMultiplyExpr procedure, error in RHS subexpression} {
d344 1
a344 1
} {1 {syntax error in expression "++2 / 3 * martha": variable references require preceding $}}
d346 1
a346 1
test parseExpr-14.1 {ParseUnaryExpr procedure, first token is unary operator} {
d349 1
a349 1
test parseExpr-14.2 {ParseUnaryExpr procedure, first token is unary operator} {
d352 1
a352 1
test parseExpr-14.3 {ParseUnaryExpr procedure, first token is unary operator} {
d355 1
a355 1
test parseExpr-14.4 {ParseUnaryExpr procedure, first token is unary operator} {
d358 1
a358 1
test parseExpr-14.5 {ParseUnaryExpr procedure, error in lexeme after unary op} {wideIntegerUnparsed} {
d361 1
a361 1
test parseExpr-14.6 {ParseUnaryExpr procedure, simple unary expr after unary op} {
d364 1
a364 1
test parseExpr-14.7 {ParseUnaryExpr procedure, another unary expr after unary op} {
d367 1
a367 1
test parseExpr-14.8 {ParseUnaryExpr procedure, error in unary expr after unary op} {
d369 2
a370 2
} {1 {syntax error in expression "+-||27": unexpected operator ||}}
test parseExpr-14.9 {ParseUnaryExpr procedure, error in unary expr after unary op} {
d372 2
a373 2
} {1 {syntax error in expression "+-||27": unexpected operator ||}}
test parseExpr-14.10 {ParseUnaryExpr procedure, first token is not unary op} {
d376 1
a376 1
test parseExpr-14.11 {ParseUnaryExpr procedure, not unary expr, complex primary expr} {
d379 1
a379 1
test parseExpr-14.12 {ParseUnaryExpr procedure, not unary expr, error in primary expr} {wideIntegerUnparsed} {
d383 1
a383 1
test parseExpr-15.1 {ParsePrimaryExpr procedure, just parenthesized subexpr} {
d386 1
a386 1
test parseExpr-15.2 {ParsePrimaryExpr procedure, bad lexeme after "("} {wideIntegerUnparsed} {
d389 1
a389 1
test parseExpr-15.3 {ParsePrimaryExpr procedure, valid parenthesized subexpr} {
d392 1
a392 1
test parseExpr-15.4 {ParsePrimaryExpr procedure, error in parenthesized subexpr} {
d394 2
a395 2
} {1 {syntax error in expression "(? 123 : 456)": unexpected ternary 'then' separator}}
test parseExpr-15.5 {ParsePrimaryExpr procedure, missing ")" after in parenthesized subexpr} {
d397 2
a398 2
} {1 {syntax error in expression "({abc}/{def}": looking for close parenthesis}}
test parseExpr-15.6 {ParsePrimaryExpr procedure, primary is literal} {
d401 1
a401 1
test parseExpr-15.7 {ParsePrimaryExpr procedure, primary is literal} {
d404 1
a404 1
test parseExpr-15.8 {ParsePrimaryExpr procedure, primary is var reference} {
d407 1
a407 1
test parseExpr-15.9 {ParsePrimaryExpr procedure, primary is var reference} {
d410 1
a410 1
test parseExpr-15.10 {ParsePrimaryExpr procedure, primary is var reference} {
d413 1
a413 1
test parseExpr-15.11 {ParsePrimaryExpr procedure, error in var reference} {
d416 1
a416 1
test parseExpr-15.12 {ParsePrimaryExpr procedure, primary is quoted string} {
d419 1
a419 1
test parseExpr-15.13 {ParsePrimaryExpr procedure, error in quoted string} {
d422 1
a422 1
test parseExpr-15.14 {ParsePrimaryExpr procedure, quoted string has multiple tokens} {
d425 1
a425 1
test parseExpr-15.15 {ParsePrimaryExpr procedure, primary is command} {
d428 1
a428 1
test parseExpr-15.16 {ParsePrimaryExpr procedure, primary is multiple commands} {
d431 1
a431 1
test parseExpr-15.17 {ParsePrimaryExpr procedure, primary is multiple commands} {
d434 1
a434 1
test parseExpr-15.18 {ParsePrimaryExpr procedure, missing close bracket} {
d437 1
a437 1
test parseExpr-15.19 {ParsePrimaryExpr procedure, primary is braced string} {
d440 1
a440 1
test parseExpr-15.20 {ParsePrimaryExpr procedure, error in primary, which is braced string} {
d443 1
a443 1
test parseExpr-15.21 {ParsePrimaryExpr procedure, primary is braced string with multiple tokens} {
d447 1
a447 1
test parseExpr-15.22 {ParsePrimaryExpr procedure, primary is function call} {
d450 1
a450 1
test parseExpr-15.23 {ParsePrimaryExpr procedure, bad lexeme after function name} {wideIntegerUnparsed} {
d453 1
a453 1
test parseExpr-15.24 {ParsePrimaryExpr procedure, lexeme after function name isn't "("} {
d455 2
a456 2
} {1 {syntax error in expression "foo 27.4 123)": variable references require preceding $}}
test parseExpr-15.25 {ParsePrimaryExpr procedure, bad lexeme after "("} {wideIntegerUnparsed} {
d459 1
a459 1
test parseExpr-15.26 {ParsePrimaryExpr procedure, function call, one arg} {
d462 1
a462 1
test parseExpr-15.27 {ParsePrimaryExpr procedure, error in function arg} {
d464 2
a465 2
} {1 {syntax error in expression "foo(*1-2)": unexpected operator *}}
test parseExpr-15.28 {ParsePrimaryExpr procedure, error in function arg} {
d467 2
a468 2
} {1 {syntax error in expression "foo(*1-2)": unexpected operator *}}
test parseExpr-15.29 {ParsePrimaryExpr procedure, function call, comma after arg} {
d471 1
a471 1
test parseExpr-15.30 {ParsePrimaryExpr procedure, bad lexeme after comma} {wideIntegerUnparsed} {
d474 1
a474 1
test parseExpr-15.31 {ParsePrimaryExpr procedure, lexeme not "," or ")" after arg} {
d476 2
a477 2
} {1 {syntax error in expression "foo(123 [foo])": missing close parenthesis at end of function call}}
test parseExpr-15.32 {ParsePrimaryExpr procedure, bad lexeme after primary} {wideIntegerUnparsed} {
a479 9
test parseExpr-15.33 {ParsePrimaryExpr procedure, comma-specific message} {
    list [catch {testexprparser {123+,456} -1} msg] $msg
} {1 {syntax error in expression "123+,456": commas can only separate function arguments}}
test parseExpr-15.34 {ParsePrimaryExpr procedure, single equal-specific message} {
    list [catch {testexprparser {123+=456} -1} msg] $msg
} {1 {syntax error in expression "123+=456": single equality character not legal in expressions}}
test parseExpr-15.35 {ParsePrimaryExpr procedure, error in parenthesized subexpr} {
    list [catch {testexprparser {(: 123 : 456)} -1} msg] $msg
} {1 {syntax error in expression "(: 123 : 456)": unexpected ternary 'else' separator}}
d481 1
a481 1
test parseExpr-16.1 {GetLexeme procedure, whitespace before lexeme} {
d484 1
a484 1
test parseExpr-16.2 {GetLexeme procedure, whitespace before lexeme} {
d488 1
a488 1
test parseExpr-16.3 {GetLexeme procedure, no lexeme after whitespace} {
d492 1
a492 1
test parseExpr-16.4 {GetLexeme procedure, integer lexeme} {
d495 1
a495 1
test parseExpr-16.5 {GetLexeme procedure, integer lexeme too big} {wideIntegerUnparsed} {
d498 4
a501 6

test parseExpr-16.6 {GetLexeme procedure, bad integer lexeme} -body {
    testexprparser {0999} -1
} -returnCodes error -match glob -result {*invalid octal number*}

test parseExpr-16.7 {GetLexeme procedure, double lexeme} {
d504 1
a504 1
test parseExpr-16.8 {GetLexeme procedure, double lexeme} {
d507 1
a507 1
test parseExpr-16.9 {GetLexeme procedure, double lexeme} {nonPortable unixOnly} {
d510 1
a510 1
test parseExpr-16.10 {GetLexeme procedure, double lexeme} {nonPortable unixOnly} {
d513 1
a513 1
test parseExpr-16.11 {GetLexeme procedure, bad double lexeme too big} {
d516 1
a516 1
test parseExpr-16.12 {GetLexeme procedure, bad double lexeme} {
d518 2
a519 2
} {1 {syntax error in expression "123.4x56": extra tokens at end of expression}}
test parseExpr-16.13 {GetLexeme procedure, lexeme is "["} {
d522 1
a522 1
test parseExpr-16.14 {GetLexeme procedure, lexeme is open brace} {
d525 1
a525 1
test parseExpr-16.15 {GetLexeme procedure, lexeme is "("} {
d528 1
a528 1
test parseExpr-16.16 {GetLexeme procedure, lexeme is ")"} {
d531 1
a531 1
test parseExpr-16.17 {GetLexeme procedure, lexeme is "$"} {
d534 1
a534 1
test parseExpr-16.18 "GetLexeme procedure, lexeme is '\"'" {
d537 1
a537 1
test parseExpr-16.19 {GetLexeme procedure, lexeme is ","} {
d540 1
a540 1
test parseExpr-16.20 {GetLexeme procedure, lexeme is "*"} {
d543 1
a543 1
test parseExpr-16.21 {GetLexeme procedure, lexeme is "/"} {
d546 1
a546 1
test parseExpr-16.22 {GetLexeme procedure, lexeme is "%"} {
d549 1
a549 1
test parseExpr-16.23 {GetLexeme procedure, lexeme is "+"} {
d552 1
a552 1
test parseExpr-16.24 {GetLexeme procedure, lexeme is "-"} {
d555 1
a555 1
test parseExpr-16.25 {GetLexeme procedure, lexeme is "?" or ":"} {
d558 1
a558 1
test parseExpr-16.26 {GetLexeme procedure, lexeme is "<"} {
d561 1
a561 1
test parseExpr-16.27 {GetLexeme procedure, lexeme is "<<"} {
d564 1
a564 1
test parseExpr-16.28 {GetLexeme procedure, lexeme is "<="} {
d567 1
a567 1
test parseExpr-16.29 {GetLexeme procedure, lexeme is ">"} {
d570 1
a570 1
test parseExpr-16.30 {GetLexeme procedure, lexeme is ">>"} {
d573 1
a573 1
test parseExpr-16.31 {GetLexeme procedure, lexeme is ">="} {
d576 1
a576 1
test parseExpr-16.32 {GetLexeme procedure, lexeme is "=="} {
d579 1
a579 1
test parseExpr-16.33 {GetLexeme procedure, bad lexeme starting with "="} {
d581 2
a582 2
} {1 {syntax error in expression "2=+3": extra tokens at end of expression}}
test parseExpr-16.34 {GetLexeme procedure, lexeme is "!="} {
d585 1
a585 1
test parseExpr-16.35 {GetLexeme procedure, lexeme is "!"} {
d588 1
a588 1
test parseExpr-16.36 {GetLexeme procedure, lexeme is "&&"} {
d591 1
a591 1
test parseExpr-16.37 {GetLexeme procedure, lexeme is "&"} {
d594 1
a594 1
test parseExpr-16.38 {GetLexeme procedure, lexeme is "^"} {
d597 1
a597 1
test parseExpr-16.39 {GetLexeme procedure, lexeme is "||"} {
d600 1
a600 1
test parseExpr-16.40 {GetLexeme procedure, lexeme is "|"} {
d603 1
a603 1
test parseExpr-16.41 {GetLexeme procedure, lexeme is "~"} {
d606 1
a606 1
test parseExpr-16.42 {GetLexeme procedure, lexeme is func name} {
d609 1
a609 1
test parseExpr-16.43 {GetLexeme procedure, lexeme is func name} {
d612 1
a612 1
test parseExpr-16.44 {GetLexeme procedure, unknown lexeme} {
d614 1
a614 1
} {1 {syntax error in expression "@@27": character not legal in expressions}}
d616 1
a616 1
test parseExpr-17.1 {PrependSubExprTokens procedure, expand token array} {
d620 1
a620 1
test parseExpr-18.1 {LogSyntaxError procedure, error in expr longer than 60 chars} {
d622 1
a622 1
} {1 {syntax error in expression "(+0123456)*(+0123456)*(+0123456)*(+0123456)*(+0123456)*(+012...": premature end of expression}}
d627 13
@


1.3.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@d11 1
a11 1
# RCS: @@(#) $Id: parseExpr.test,v 1.8 2002/08/05 03:24:41 dgp Exp $
a29 5
# Some tests only work if wide integers (>32bit) are not found to be
# integers at all.
set ::tcltest::testConstraints(wideIntegerUnparsed) \
	[expr {-1 == 0xffffffff}]

d36 1
a36 1
test parseExpr-1.3 {Tcl_ParseExpr procedure, error getting initial lexeme} {wideIntegerUnparsed} {
d41 1
a41 1
} {1 {syntax error in expression "foo+": variable references require preceding $}}
d44 1
a44 1
} {1 {syntax error in expression "1+2 345": extra tokens at end of expression}}
d51 1
a51 1
} {1 {syntax error in expression "0 || foo": variable references require preceding $}}
d58 1
a58 1
test parseExpr-2.5 {ParseCondExpr procedure, bad lexeme after "?"} {wideIntegerUnparsed} {
d66 1
a66 1
} {1 {syntax error in expression "1? fred : martha": variable references require preceding $}}
d69 1
a69 1
} {1 {syntax error in expression "1? 2 martha 3": missing colon from ternary conditional}}
d75 1
a75 1
} {1 {syntax error in expression "1? 2 : martha": variable references require preceding $}}
d82 1
a82 1
} {1 {syntax error in expression "1&&foo || 3": variable references require preceding $}}
d89 1
a89 1
test parseExpr-3.5 {ParseLorExpr procedure, bad lexeme after "||"} {wideIntegerUnparsed} {
d97 1
a97 1
} {1 {syntax error in expression "1&&2 || 3 || martha": variable references require preceding $}}
d104 1
a104 1
} {1 {syntax error in expression "1&&foo && 3": variable references require preceding $}}
d111 1
a111 1
test parseExpr-4.5 {ParseLandExpr procedure, bad lexeme after "&&"} {wideIntegerUnparsed} {
d119 1
a119 1
} {1 {syntax error in expression "1|2 && 3 && martha": variable references require preceding $}}
d126 1
a126 1
} {1 {syntax error in expression "1|foo | 3": variable references require preceding $}}
d133 1
a133 1
test parseExpr-5.5 {ParseBitOrExpr procedure, bad lexeme after "|"} {wideIntegerUnparsed} {
d141 1
a141 1
} {1 {syntax error in expression "1^2 | 3 | martha": variable references require preceding $}}
d148 1
a148 1
} {1 {syntax error in expression "1^foo ^ 3": variable references require preceding $}}
d155 1
a155 1
test parseExpr-6.5 {ParseBitXorExpr procedure, bad lexeme after "^"} {wideIntegerUnparsed} {
d163 1
a163 1
} {1 {syntax error in expression "1&2 ^ 3 ^ martha": variable references require preceding $}}
d170 1
a170 1
} {1 {syntax error in expression "1!=foo & 3": variable references require preceding $}}
d177 1
a177 1
test parseExpr-7.5 {ParseBitAndExpr procedure, bad lexeme after "&"} {wideIntegerUnparsed} {
d185 1
a185 1
} {1 {syntax error in expression "1==2 & 3>2 & martha": variable references require preceding $}}
d187 1
a187 1
test parseExpr-8.1 {ParseEqualityExpr procedure, valid LHS relational subexpr} {
d190 1
a190 1
test parseExpr-8.2 {ParseEqualityExpr procedure, error in LHS relational subexpr} {
d192 2
a193 2
} {1 {syntax error in expression "1>=foo == 3": variable references require preceding $}}
test parseExpr-8.3 {ParseEqualityExpr procedure, next lexeme isn't "==" or "!="} {
d196 1
a196 1
test parseExpr-8.4 {ParseEqualityExpr procedure, next lexeme is "==" or "!="} {
d199 1
a199 1
test parseExpr-8.5 {ParseEqualityExpr procedure, next lexeme is "==" or "!="} {
d202 1
a202 1
test parseExpr-8.6 {ParseEqualityExpr procedure, bad lexeme after "==" or "!="} {wideIntegerUnparsed} {
d205 1
a205 1
test parseExpr-8.7 {ParseEqualityExpr procedure, valid RHS subexpression} {
d208 1
a208 1
test parseExpr-8.8 {ParseEqualityExpr procedure, error in RHS subexpression} {
d210 1
a210 1
} {1 {syntax error in expression "1<2 == 3 != martha": variable references require preceding $}}
d212 1
a212 1
test parseExpr-9.1 {ParseRelationalExpr procedure, valid LHS shift subexpr} {
d215 1
a215 1
test parseExpr-9.2 {ParseRelationalExpr procedure, error in LHS shift subexpr} {
d217 2
a218 2
} {1 {syntax error in expression "1>=foo < 3": variable references require preceding $}}
test parseExpr-9.3 {ParseRelationalExpr procedure, next lexeme isn't relational op} {
d221 1
a221 1
test parseExpr-9.4 {ParseRelationalExpr procedure, next lexeme is relational op} {
d224 1
a224 1
test parseExpr-9.5 {ParseRelationalExpr procedure, next lexeme is relational op} {
d227 1
a227 1
test parseExpr-9.6 {ParseRelationalExpr procedure, next lexeme is relational op} {
d230 1
a230 1
test parseExpr-9.7 {ParseRelationalExpr procedure, next lexeme is relational op} {
d233 1
a233 1
test parseExpr-9.8 {ParseRelationalExpr procedure, bad lexeme after relational op} {wideIntegerUnparsed} {
d236 1
a236 1
test parseExpr-9.9 {ParseRelationalExpr procedure, valid RHS subexpression} {
d239 1
a239 1
test parseExpr-9.10 {ParseRelationalExpr procedure, error in RHS subexpression} {
d241 1
a241 1
} {1 {syntax error in expression "1<<2 < 3 > martha": variable references require preceding $}}
d243 1
a243 1
test parseExpr-10.1 {ParseShiftExpr procedure, valid LHS add subexpr} {
d246 1
a246 1
test parseExpr-10.2 {ParseShiftExpr procedure, error in LHS add subexpr} {
d248 2
a249 2
} {1 {syntax error in expression "1-foo << 3": variable references require preceding $}}
test parseExpr-10.3 {ParseShiftExpr procedure, next lexeme isn't "<<" or ">>"} {
d252 1
a252 1
test parseExpr-10.4 {ParseShiftExpr procedure, next lexeme is "<<" or ">>"} {
d255 1
a255 1
test parseExpr-10.5 {ParseShiftExpr procedure, next lexeme is "<<" or ">>"} {
d258 1
a258 1
test parseExpr-10.6 {ParseShiftExpr procedure, bad lexeme after "<<" or ">>"} {wideIntegerUnparsed} {
d261 1
a261 1
test parseExpr-10.7 {ParseShiftExpr procedure, valid RHS subexpression} {
d264 1
a264 1
test parseExpr-10.8 {ParseShiftExpr procedure, error in RHS subexpression} {
d266 1
a266 1
} {1 {syntax error in expression "1+2 << 3 >> martha": variable references require preceding $}}
d268 1
a268 1
test parseExpr-11.1 {ParseAddExpr procedure, valid LHS multiply subexpr} {
d271 1
a271 1
test parseExpr-11.2 {ParseAddExpr procedure, error in LHS multiply subexpr} {
d273 2
a274 2
} {1 {syntax error in expression "1/foo + 3": variable references require preceding $}}
test parseExpr-11.3 {ParseAddExpr procedure, next lexeme isn't "+" or "-"} {
d277 1
a277 1
test parseExpr-11.4 {ParseAddExpr procedure, next lexeme is "+" or "-"} {
d280 1
a280 1
test parseExpr-11.5 {ParseAddExpr procedure, next lexeme is "+" or "-"} {
d283 1
a283 1
test parseExpr-11.6 {ParseAddExpr procedure, bad lexeme after "+" or "-"} {wideIntegerUnparsed} {
d286 1
a286 1
test parseExpr-11.7 {ParseAddExpr procedure, valid RHS subexpression} {
d289 1
a289 1
test parseExpr-11.8 {ParseAddExpr procedure, error in RHS subexpression} {
d291 1
a291 1
} {1 {syntax error in expression "1*2 + 3 - martha": variable references require preceding $}}
d293 1
a293 1
test parseExpr-12.1 {ParseAddExpr procedure, valid LHS multiply subexpr} {
d296 1
a296 1
test parseExpr-12.2 {ParseAddExpr procedure, error in LHS multiply subexpr} {
d298 2
a299 2
} {1 {syntax error in expression "1/foo + 3": variable references require preceding $}}
test parseExpr-12.3 {ParseAddExpr procedure, next lexeme isn't "+" or "-"} {
d302 1
a302 1
test parseExpr-12.4 {ParseAddExpr procedure, next lexeme is "+" or "-"} {
d305 1
a305 1
test parseExpr-12.5 {ParseAddExpr procedure, next lexeme is "+" or "-"} {
d308 1
a308 1
test parseExpr-12.6 {ParseAddExpr procedure, bad lexeme after "+" or "-"} {wideIntegerUnparsed} {
d311 1
a311 1
test parseExpr-12.7 {ParseAddExpr procedure, valid RHS subexpression} {
d314 1
a314 1
test parseExpr-12.8 {ParseAddExpr procedure, error in RHS subexpression} {
d316 1
a316 1
} {1 {syntax error in expression "1*2 + 3 - martha": variable references require preceding $}}
d318 1
a318 1
test parseExpr-13.1 {ParseMultiplyExpr procedure, valid LHS unary subexpr} {
d321 1
a321 1
test parseExpr-13.2 {ParseMultiplyExpr procedure, error in LHS unary subexpr} {wideIntegerUnparsed} {
d324 1
a324 1
test parseExpr-13.3 {ParseMultiplyExpr procedure, next lexeme isn't "*", "/", or "%"} {
d327 1
a327 1
test parseExpr-13.4 {ParseMultiplyExpr procedure, next lexeme is "*", "/", or "%"} {
d330 1
a330 1
test parseExpr-13.5 {ParseMultiplyExpr procedure, next lexeme is "*", "/", or "%"} {
d333 1
a333 1
test parseExpr-13.6 {ParseMultiplyExpr procedure, next lexeme is "*", "/", or "%"} {
d336 1
a336 1
test parseExpr-13.7 {ParseMultiplyExpr procedure, bad lexeme after "*", "/", or "%"} {wideIntegerUnparsed} {
d339 1
a339 1
test parseExpr-13.8 {ParseMultiplyExpr procedure, valid RHS subexpression} {
d342 1
a342 1
test parseExpr-13.9 {ParseMultiplyExpr procedure, error in RHS subexpression} {
d344 1
a344 1
} {1 {syntax error in expression "++2 / 3 * martha": variable references require preceding $}}
d346 1
a346 1
test parseExpr-14.1 {ParseUnaryExpr procedure, first token is unary operator} {
d349 1
a349 1
test parseExpr-14.2 {ParseUnaryExpr procedure, first token is unary operator} {
d352 1
a352 1
test parseExpr-14.3 {ParseUnaryExpr procedure, first token is unary operator} {
d355 1
a355 1
test parseExpr-14.4 {ParseUnaryExpr procedure, first token is unary operator} {
d358 1
a358 1
test parseExpr-14.5 {ParseUnaryExpr procedure, error in lexeme after unary op} {wideIntegerUnparsed} {
d361 1
a361 1
test parseExpr-14.6 {ParseUnaryExpr procedure, simple unary expr after unary op} {
d364 1
a364 1
test parseExpr-14.7 {ParseUnaryExpr procedure, another unary expr after unary op} {
d367 1
a367 1
test parseExpr-14.8 {ParseUnaryExpr procedure, error in unary expr after unary op} {
d369 2
a370 2
} {1 {syntax error in expression "+-||27": unexpected operator ||}}
test parseExpr-14.9 {ParseUnaryExpr procedure, error in unary expr after unary op} {
d372 2
a373 2
} {1 {syntax error in expression "+-||27": unexpected operator ||}}
test parseExpr-14.10 {ParseUnaryExpr procedure, first token is not unary op} {
d376 1
a376 1
test parseExpr-14.11 {ParseUnaryExpr procedure, not unary expr, complex primary expr} {
d379 1
a379 1
test parseExpr-14.12 {ParseUnaryExpr procedure, not unary expr, error in primary expr} {wideIntegerUnparsed} {
d383 1
a383 1
test parseExpr-15.1 {ParsePrimaryExpr procedure, just parenthesized subexpr} {
d386 1
a386 1
test parseExpr-15.2 {ParsePrimaryExpr procedure, bad lexeme after "("} {wideIntegerUnparsed} {
d389 1
a389 1
test parseExpr-15.3 {ParsePrimaryExpr procedure, valid parenthesized subexpr} {
d392 1
a392 1
test parseExpr-15.4 {ParsePrimaryExpr procedure, error in parenthesized subexpr} {
d394 2
a395 2
} {1 {syntax error in expression "(? 123 : 456)": unexpected ternary 'then' separator}}
test parseExpr-15.5 {ParsePrimaryExpr procedure, missing ")" after in parenthesized subexpr} {
d397 2
a398 2
} {1 {syntax error in expression "({abc}/{def}": looking for close parenthesis}}
test parseExpr-15.6 {ParsePrimaryExpr procedure, primary is literal} {
d401 1
a401 1
test parseExpr-15.7 {ParsePrimaryExpr procedure, primary is literal} {
d404 1
a404 1
test parseExpr-15.8 {ParsePrimaryExpr procedure, primary is var reference} {
d407 1
a407 1
test parseExpr-15.9 {ParsePrimaryExpr procedure, primary is var reference} {
d410 1
a410 1
test parseExpr-15.10 {ParsePrimaryExpr procedure, primary is var reference} {
d413 1
a413 1
test parseExpr-15.11 {ParsePrimaryExpr procedure, error in var reference} {
d416 1
a416 1
test parseExpr-15.12 {ParsePrimaryExpr procedure, primary is quoted string} {
d419 1
a419 1
test parseExpr-15.13 {ParsePrimaryExpr procedure, error in quoted string} {
d422 1
a422 1
test parseExpr-15.14 {ParsePrimaryExpr procedure, quoted string has multiple tokens} {
d425 1
a425 1
test parseExpr-15.15 {ParsePrimaryExpr procedure, primary is command} {
d428 1
a428 1
test parseExpr-15.16 {ParsePrimaryExpr procedure, primary is multiple commands} {
d431 1
a431 1
test parseExpr-15.17 {ParsePrimaryExpr procedure, primary is multiple commands} {
d434 1
a434 1
test parseExpr-15.18 {ParsePrimaryExpr procedure, missing close bracket} {
d437 1
a437 1
test parseExpr-15.19 {ParsePrimaryExpr procedure, primary is braced string} {
d440 1
a440 1
test parseExpr-15.20 {ParsePrimaryExpr procedure, error in primary, which is braced string} {
d443 1
a443 1
test parseExpr-15.21 {ParsePrimaryExpr procedure, primary is braced string with multiple tokens} {
d447 1
a447 1
test parseExpr-15.22 {ParsePrimaryExpr procedure, primary is function call} {
d450 1
a450 1
test parseExpr-15.23 {ParsePrimaryExpr procedure, bad lexeme after function name} {wideIntegerUnparsed} {
d453 1
a453 1
test parseExpr-15.24 {ParsePrimaryExpr procedure, lexeme after function name isn't "("} {
d455 2
a456 2
} {1 {syntax error in expression "foo 27.4 123)": variable references require preceding $}}
test parseExpr-15.25 {ParsePrimaryExpr procedure, bad lexeme after "("} {wideIntegerUnparsed} {
d459 1
a459 1
test parseExpr-15.26 {ParsePrimaryExpr procedure, function call, one arg} {
d462 1
a462 1
test parseExpr-15.27 {ParsePrimaryExpr procedure, error in function arg} {
d464 2
a465 2
} {1 {syntax error in expression "foo(*1-2)": unexpected operator *}}
test parseExpr-15.28 {ParsePrimaryExpr procedure, error in function arg} {
d467 2
a468 2
} {1 {syntax error in expression "foo(*1-2)": unexpected operator *}}
test parseExpr-15.29 {ParsePrimaryExpr procedure, function call, comma after arg} {
d471 1
a471 1
test parseExpr-15.30 {ParsePrimaryExpr procedure, bad lexeme after comma} {wideIntegerUnparsed} {
d474 1
a474 1
test parseExpr-15.31 {ParsePrimaryExpr procedure, lexeme not "," or ")" after arg} {
d476 2
a477 2
} {1 {syntax error in expression "foo(123 [foo])": missing close parenthesis at end of function call}}
test parseExpr-15.32 {ParsePrimaryExpr procedure, bad lexeme after primary} {wideIntegerUnparsed} {
a479 9
test parseExpr-15.33 {ParsePrimaryExpr procedure, comma-specific message} {
    list [catch {testexprparser {123+,456} -1} msg] $msg
} {1 {syntax error in expression "123+,456": commas can only separate function arguments}}
test parseExpr-15.34 {ParsePrimaryExpr procedure, single equal-specific message} {
    list [catch {testexprparser {123+=456} -1} msg] $msg
} {1 {syntax error in expression "123+=456": single equality character not legal in expressions}}
test parseExpr-15.35 {ParsePrimaryExpr procedure, error in parenthesized subexpr} {
    list [catch {testexprparser {(: 123 : 456)} -1} msg] $msg
} {1 {syntax error in expression "(: 123 : 456)": unexpected ternary 'else' separator}}
d481 1
a481 1
test parseExpr-16.1 {GetLexeme procedure, whitespace before lexeme} {
d484 1
a484 1
test parseExpr-16.2 {GetLexeme procedure, whitespace before lexeme} {
d488 1
a488 1
test parseExpr-16.3 {GetLexeme procedure, no lexeme after whitespace} {
d492 1
a492 1
test parseExpr-16.4 {GetLexeme procedure, integer lexeme} {
d495 1
a495 1
test parseExpr-16.5 {GetLexeme procedure, integer lexeme too big} {wideIntegerUnparsed} {
d498 4
a501 6

test parseExpr-16.6 {GetLexeme procedure, bad integer lexeme} -body {
    testexprparser {0999} -1
} -returnCodes error -match glob -result {*invalid octal number*}

test parseExpr-16.7 {GetLexeme procedure, double lexeme} {
d504 1
a504 1
test parseExpr-16.8 {GetLexeme procedure, double lexeme} {
d507 1
a507 1
test parseExpr-16.9 {GetLexeme procedure, double lexeme} {nonPortable unixOnly} {
d510 1
a510 1
test parseExpr-16.10 {GetLexeme procedure, double lexeme} {nonPortable unixOnly} {
d513 1
a513 1
test parseExpr-16.11 {GetLexeme procedure, bad double lexeme too big} {
d516 1
a516 1
test parseExpr-16.12 {GetLexeme procedure, bad double lexeme} {
d518 2
a519 2
} {1 {syntax error in expression "123.4x56": extra tokens at end of expression}}
test parseExpr-16.13 {GetLexeme procedure, lexeme is "["} {
d522 1
a522 1
test parseExpr-16.14 {GetLexeme procedure, lexeme is open brace} {
d525 1
a525 1
test parseExpr-16.15 {GetLexeme procedure, lexeme is "("} {
d528 1
a528 1
test parseExpr-16.16 {GetLexeme procedure, lexeme is ")"} {
d531 1
a531 1
test parseExpr-16.17 {GetLexeme procedure, lexeme is "$"} {
d534 1
a534 1
test parseExpr-16.18 "GetLexeme procedure, lexeme is '\"'" {
d537 1
a537 1
test parseExpr-16.19 {GetLexeme procedure, lexeme is ","} {
d540 1
a540 1
test parseExpr-16.20 {GetLexeme procedure, lexeme is "*"} {
d543 1
a543 1
test parseExpr-16.21 {GetLexeme procedure, lexeme is "/"} {
d546 1
a546 1
test parseExpr-16.22 {GetLexeme procedure, lexeme is "%"} {
d549 1
a549 1
test parseExpr-16.23 {GetLexeme procedure, lexeme is "+"} {
d552 1
a552 1
test parseExpr-16.24 {GetLexeme procedure, lexeme is "-"} {
d555 1
a555 1
test parseExpr-16.25 {GetLexeme procedure, lexeme is "?" or ":"} {
d558 1
a558 1
test parseExpr-16.26 {GetLexeme procedure, lexeme is "<"} {
d561 1
a561 1
test parseExpr-16.27 {GetLexeme procedure, lexeme is "<<"} {
d564 1
a564 1
test parseExpr-16.28 {GetLexeme procedure, lexeme is "<="} {
d567 1
a567 1
test parseExpr-16.29 {GetLexeme procedure, lexeme is ">"} {
d570 1
a570 1
test parseExpr-16.30 {GetLexeme procedure, lexeme is ">>"} {
d573 1
a573 1
test parseExpr-16.31 {GetLexeme procedure, lexeme is ">="} {
d576 1
a576 1
test parseExpr-16.32 {GetLexeme procedure, lexeme is "=="} {
d579 1
a579 1
test parseExpr-16.33 {GetLexeme procedure, bad lexeme starting with "="} {
d581 2
a582 2
} {1 {syntax error in expression "2=+3": extra tokens at end of expression}}
test parseExpr-16.34 {GetLexeme procedure, lexeme is "!="} {
d585 1
a585 1
test parseExpr-16.35 {GetLexeme procedure, lexeme is "!"} {
d588 1
a588 1
test parseExpr-16.36 {GetLexeme procedure, lexeme is "&&"} {
d591 1
a591 1
test parseExpr-16.37 {GetLexeme procedure, lexeme is "&"} {
d594 1
a594 1
test parseExpr-16.38 {GetLexeme procedure, lexeme is "^"} {
d597 1
a597 1
test parseExpr-16.39 {GetLexeme procedure, lexeme is "||"} {
d600 1
a600 1
test parseExpr-16.40 {GetLexeme procedure, lexeme is "|"} {
d603 1
a603 1
test parseExpr-16.41 {GetLexeme procedure, lexeme is "~"} {
d606 1
a606 1
test parseExpr-16.42 {GetLexeme procedure, lexeme is func name} {
d609 1
a609 1
test parseExpr-16.43 {GetLexeme procedure, lexeme is func name} {
d612 1
a612 1
test parseExpr-16.44 {GetLexeme procedure, unknown lexeme} {
d614 1
a614 1
} {1 {syntax error in expression "@@27": character not legal in expressions}}
d616 1
a616 1
test parseExpr-17.1 {PrependSubExprTokens procedure, expand token array} {
d620 1
a620 1
test parseExpr-18.1 {LogSyntaxError procedure, error in expr longer than 60 chars} {
d622 1
a622 1
} {1 {syntax error in expression "(+0123456)*(+0123456)*(+0123456)*(+0123456)*(+0123456)*(+012...": premature end of expression}}
d627 13
@


1.2
log
@touched all Tcl files to ease next import.
@
text
@@


1.2.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.2.16.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@a29 5
# Some tests only work if wide integers (>32bit) are not found to be
# integers at all.
set ::tcltest::testConstraints(wideIntegerUnparsed) \
	[expr {-1 == 0xffffffff}]

d36 1
a36 1
test parseExpr-1.3 {Tcl_ParseExpr procedure, error getting initial lexeme} {wideIntegerUnparsed} {
d41 1
a41 1
} {1 {syntax error in expression "foo+": variable references require preceding $}}
d44 1
a44 1
} {1 {syntax error in expression "1+2 345": extra tokens at end of expression}}
d51 1
a51 1
} {1 {syntax error in expression "0 || foo": variable references require preceding $}}
d58 1
a58 1
test parseExpr-2.5 {ParseCondExpr procedure, bad lexeme after "?"} {wideIntegerUnparsed} {
d66 1
a66 1
} {1 {syntax error in expression "1? fred : martha": variable references require preceding $}}
d69 1
a69 1
} {1 {syntax error in expression "1? 2 martha 3": missing colon from ternary conditional}}
d75 1
a75 1
} {1 {syntax error in expression "1? 2 : martha": variable references require preceding $}}
d82 1
a82 1
} {1 {syntax error in expression "1&&foo || 3": variable references require preceding $}}
d89 1
a89 1
test parseExpr-3.5 {ParseLorExpr procedure, bad lexeme after "||"} {wideIntegerUnparsed} {
d97 1
a97 1
} {1 {syntax error in expression "1&&2 || 3 || martha": variable references require preceding $}}
d104 1
a104 1
} {1 {syntax error in expression "1&&foo && 3": variable references require preceding $}}
d111 1
a111 1
test parseExpr-4.5 {ParseLandExpr procedure, bad lexeme after "&&"} {wideIntegerUnparsed} {
d119 1
a119 1
} {1 {syntax error in expression "1|2 && 3 && martha": variable references require preceding $}}
d126 1
a126 1
} {1 {syntax error in expression "1|foo | 3": variable references require preceding $}}
d133 1
a133 1
test parseExpr-5.5 {ParseBitOrExpr procedure, bad lexeme after "|"} {wideIntegerUnparsed} {
d141 1
a141 1
} {1 {syntax error in expression "1^2 | 3 | martha": variable references require preceding $}}
d148 1
a148 1
} {1 {syntax error in expression "1^foo ^ 3": variable references require preceding $}}
d155 1
a155 1
test parseExpr-6.5 {ParseBitXorExpr procedure, bad lexeme after "^"} {wideIntegerUnparsed} {
d163 1
a163 1
} {1 {syntax error in expression "1&2 ^ 3 ^ martha": variable references require preceding $}}
d170 1
a170 1
} {1 {syntax error in expression "1!=foo & 3": variable references require preceding $}}
d177 1
a177 1
test parseExpr-7.5 {ParseBitAndExpr procedure, bad lexeme after "&"} {wideIntegerUnparsed} {
d185 1
a185 1
} {1 {syntax error in expression "1==2 & 3>2 & martha": variable references require preceding $}}
d187 1
a187 1
test parseExpr-8.1 {ParseEqualityExpr procedure, valid LHS relational subexpr} {
d190 1
a190 1
test parseExpr-8.2 {ParseEqualityExpr procedure, error in LHS relational subexpr} {
d192 2
a193 2
} {1 {syntax error in expression "1>=foo == 3": variable references require preceding $}}
test parseExpr-8.3 {ParseEqualityExpr procedure, next lexeme isn't "==" or "!="} {
d196 1
a196 1
test parseExpr-8.4 {ParseEqualityExpr procedure, next lexeme is "==" or "!="} {
d199 1
a199 1
test parseExpr-8.5 {ParseEqualityExpr procedure, next lexeme is "==" or "!="} {
d202 1
a202 1
test parseExpr-8.6 {ParseEqualityExpr procedure, bad lexeme after "==" or "!="} {wideIntegerUnparsed} {
d205 1
a205 1
test parseExpr-8.7 {ParseEqualityExpr procedure, valid RHS subexpression} {
d208 1
a208 1
test parseExpr-8.8 {ParseEqualityExpr procedure, error in RHS subexpression} {
d210 1
a210 1
} {1 {syntax error in expression "1<2 == 3 != martha": variable references require preceding $}}
d212 1
a212 1
test parseExpr-9.1 {ParseRelationalExpr procedure, valid LHS shift subexpr} {
d215 1
a215 1
test parseExpr-9.2 {ParseRelationalExpr procedure, error in LHS shift subexpr} {
d217 2
a218 2
} {1 {syntax error in expression "1>=foo < 3": variable references require preceding $}}
test parseExpr-9.3 {ParseRelationalExpr procedure, next lexeme isn't relational op} {
d221 1
a221 1
test parseExpr-9.4 {ParseRelationalExpr procedure, next lexeme is relational op} {
d224 1
a224 1
test parseExpr-9.5 {ParseRelationalExpr procedure, next lexeme is relational op} {
d227 1
a227 1
test parseExpr-9.6 {ParseRelationalExpr procedure, next lexeme is relational op} {
d230 1
a230 1
test parseExpr-9.7 {ParseRelationalExpr procedure, next lexeme is relational op} {
d233 1
a233 1
test parseExpr-9.8 {ParseRelationalExpr procedure, bad lexeme after relational op} {wideIntegerUnparsed} {
d236 1
a236 1
test parseExpr-9.9 {ParseRelationalExpr procedure, valid RHS subexpression} {
d239 1
a239 1
test parseExpr-9.10 {ParseRelationalExpr procedure, error in RHS subexpression} {
d241 1
a241 1
} {1 {syntax error in expression "1<<2 < 3 > martha": variable references require preceding $}}
d243 1
a243 1
test parseExpr-10.1 {ParseShiftExpr procedure, valid LHS add subexpr} {
d246 1
a246 1
test parseExpr-10.2 {ParseShiftExpr procedure, error in LHS add subexpr} {
d248 2
a249 2
} {1 {syntax error in expression "1-foo << 3": variable references require preceding $}}
test parseExpr-10.3 {ParseShiftExpr procedure, next lexeme isn't "<<" or ">>"} {
d252 1
a252 1
test parseExpr-10.4 {ParseShiftExpr procedure, next lexeme is "<<" or ">>"} {
d255 1
a255 1
test parseExpr-10.5 {ParseShiftExpr procedure, next lexeme is "<<" or ">>"} {
d258 1
a258 1
test parseExpr-10.6 {ParseShiftExpr procedure, bad lexeme after "<<" or ">>"} {wideIntegerUnparsed} {
d261 1
a261 1
test parseExpr-10.7 {ParseShiftExpr procedure, valid RHS subexpression} {
d264 1
a264 1
test parseExpr-10.8 {ParseShiftExpr procedure, error in RHS subexpression} {
d266 1
a266 1
} {1 {syntax error in expression "1+2 << 3 >> martha": variable references require preceding $}}
d268 1
a268 1
test parseExpr-11.1 {ParseAddExpr procedure, valid LHS multiply subexpr} {
d271 1
a271 1
test parseExpr-11.2 {ParseAddExpr procedure, error in LHS multiply subexpr} {
d273 2
a274 2
} {1 {syntax error in expression "1/foo + 3": variable references require preceding $}}
test parseExpr-11.3 {ParseAddExpr procedure, next lexeme isn't "+" or "-"} {
d277 1
a277 1
test parseExpr-11.4 {ParseAddExpr procedure, next lexeme is "+" or "-"} {
d280 1
a280 1
test parseExpr-11.5 {ParseAddExpr procedure, next lexeme is "+" or "-"} {
d283 1
a283 1
test parseExpr-11.6 {ParseAddExpr procedure, bad lexeme after "+" or "-"} {wideIntegerUnparsed} {
d286 1
a286 1
test parseExpr-11.7 {ParseAddExpr procedure, valid RHS subexpression} {
d289 1
a289 1
test parseExpr-11.8 {ParseAddExpr procedure, error in RHS subexpression} {
d291 1
a291 1
} {1 {syntax error in expression "1*2 + 3 - martha": variable references require preceding $}}
d293 1
a293 1
test parseExpr-12.1 {ParseAddExpr procedure, valid LHS multiply subexpr} {
d296 1
a296 1
test parseExpr-12.2 {ParseAddExpr procedure, error in LHS multiply subexpr} {
d298 2
a299 2
} {1 {syntax error in expression "1/foo + 3": variable references require preceding $}}
test parseExpr-12.3 {ParseAddExpr procedure, next lexeme isn't "+" or "-"} {
d302 1
a302 1
test parseExpr-12.4 {ParseAddExpr procedure, next lexeme is "+" or "-"} {
d305 1
a305 1
test parseExpr-12.5 {ParseAddExpr procedure, next lexeme is "+" or "-"} {
d308 1
a308 1
test parseExpr-12.6 {ParseAddExpr procedure, bad lexeme after "+" or "-"} {wideIntegerUnparsed} {
d311 1
a311 1
test parseExpr-12.7 {ParseAddExpr procedure, valid RHS subexpression} {
d314 1
a314 1
test parseExpr-12.8 {ParseAddExpr procedure, error in RHS subexpression} {
d316 1
a316 1
} {1 {syntax error in expression "1*2 + 3 - martha": variable references require preceding $}}
d318 1
a318 1
test parseExpr-13.1 {ParseMultiplyExpr procedure, valid LHS unary subexpr} {
d321 1
a321 1
test parseExpr-13.2 {ParseMultiplyExpr procedure, error in LHS unary subexpr} {wideIntegerUnparsed} {
d324 1
a324 1
test parseExpr-13.3 {ParseMultiplyExpr procedure, next lexeme isn't "*", "/", or "%"} {
d327 1
a327 1
test parseExpr-13.4 {ParseMultiplyExpr procedure, next lexeme is "*", "/", or "%"} {
d330 1
a330 1
test parseExpr-13.5 {ParseMultiplyExpr procedure, next lexeme is "*", "/", or "%"} {
d333 1
a333 1
test parseExpr-13.6 {ParseMultiplyExpr procedure, next lexeme is "*", "/", or "%"} {
d336 1
a336 1
test parseExpr-13.7 {ParseMultiplyExpr procedure, bad lexeme after "*", "/", or "%"} {wideIntegerUnparsed} {
d339 1
a339 1
test parseExpr-13.8 {ParseMultiplyExpr procedure, valid RHS subexpression} {
d342 1
a342 1
test parseExpr-13.9 {ParseMultiplyExpr procedure, error in RHS subexpression} {
d344 1
a344 1
} {1 {syntax error in expression "++2 / 3 * martha": variable references require preceding $}}
d346 1
a346 1
test parseExpr-14.1 {ParseUnaryExpr procedure, first token is unary operator} {
d349 1
a349 1
test parseExpr-14.2 {ParseUnaryExpr procedure, first token is unary operator} {
d352 1
a352 1
test parseExpr-14.3 {ParseUnaryExpr procedure, first token is unary operator} {
d355 1
a355 1
test parseExpr-14.4 {ParseUnaryExpr procedure, first token is unary operator} {
d358 1
a358 1
test parseExpr-14.5 {ParseUnaryExpr procedure, error in lexeme after unary op} {wideIntegerUnparsed} {
d361 1
a361 1
test parseExpr-14.6 {ParseUnaryExpr procedure, simple unary expr after unary op} {
d364 1
a364 1
test parseExpr-14.7 {ParseUnaryExpr procedure, another unary expr after unary op} {
d367 1
a367 1
test parseExpr-14.8 {ParseUnaryExpr procedure, error in unary expr after unary op} {
d369 2
a370 2
} {1 {syntax error in expression "+-||27": unexpected operator ||}}
test parseExpr-14.9 {ParseUnaryExpr procedure, error in unary expr after unary op} {
d372 2
a373 2
} {1 {syntax error in expression "+-||27": unexpected operator ||}}
test parseExpr-14.10 {ParseUnaryExpr procedure, first token is not unary op} {
d376 1
a376 1
test parseExpr-14.11 {ParseUnaryExpr procedure, not unary expr, complex primary expr} {
d379 1
a379 1
test parseExpr-14.12 {ParseUnaryExpr procedure, not unary expr, error in primary expr} {wideIntegerUnparsed} {
d383 1
a383 1
test parseExpr-15.1 {ParsePrimaryExpr procedure, just parenthesized subexpr} {
d386 1
a386 1
test parseExpr-15.2 {ParsePrimaryExpr procedure, bad lexeme after "("} {wideIntegerUnparsed} {
d389 1
a389 1
test parseExpr-15.3 {ParsePrimaryExpr procedure, valid parenthesized subexpr} {
d392 1
a392 1
test parseExpr-15.4 {ParsePrimaryExpr procedure, error in parenthesized subexpr} {
d394 2
a395 2
} {1 {syntax error in expression "(? 123 : 456)": unexpected ternary 'then' separator}}
test parseExpr-15.5 {ParsePrimaryExpr procedure, missing ")" after in parenthesized subexpr} {
d397 2
a398 2
} {1 {syntax error in expression "({abc}/{def}": looking for close parenthesis}}
test parseExpr-15.6 {ParsePrimaryExpr procedure, primary is literal} {
d401 1
a401 1
test parseExpr-15.7 {ParsePrimaryExpr procedure, primary is literal} {
d404 1
a404 1
test parseExpr-15.8 {ParsePrimaryExpr procedure, primary is var reference} {
d407 1
a407 1
test parseExpr-15.9 {ParsePrimaryExpr procedure, primary is var reference} {
d410 1
a410 1
test parseExpr-15.10 {ParsePrimaryExpr procedure, primary is var reference} {
d413 1
a413 1
test parseExpr-15.11 {ParsePrimaryExpr procedure, error in var reference} {
d416 1
a416 1
test parseExpr-15.12 {ParsePrimaryExpr procedure, primary is quoted string} {
d419 1
a419 1
test parseExpr-15.13 {ParsePrimaryExpr procedure, error in quoted string} {
d422 1
a422 1
test parseExpr-15.14 {ParsePrimaryExpr procedure, quoted string has multiple tokens} {
d425 1
a425 1
test parseExpr-15.15 {ParsePrimaryExpr procedure, primary is command} {
d428 1
a428 1
test parseExpr-15.16 {ParsePrimaryExpr procedure, primary is multiple commands} {
d431 1
a431 1
test parseExpr-15.17 {ParsePrimaryExpr procedure, primary is multiple commands} {
d434 1
a434 1
test parseExpr-15.18 {ParsePrimaryExpr procedure, missing close bracket} {
d437 1
a437 1
test parseExpr-15.19 {ParsePrimaryExpr procedure, primary is braced string} {
d440 1
a440 1
test parseExpr-15.20 {ParsePrimaryExpr procedure, error in primary, which is braced string} {
d443 1
a443 1
test parseExpr-15.21 {ParsePrimaryExpr procedure, primary is braced string with multiple tokens} {
d447 1
a447 1
test parseExpr-15.22 {ParsePrimaryExpr procedure, primary is function call} {
d450 1
a450 1
test parseExpr-15.23 {ParsePrimaryExpr procedure, bad lexeme after function name} {wideIntegerUnparsed} {
d453 1
a453 1
test parseExpr-15.24 {ParsePrimaryExpr procedure, lexeme after function name isn't "("} {
d455 2
a456 2
} {1 {syntax error in expression "foo 27.4 123)": variable references require preceding $}}
test parseExpr-15.25 {ParsePrimaryExpr procedure, bad lexeme after "("} {wideIntegerUnparsed} {
d459 1
a459 1
test parseExpr-15.26 {ParsePrimaryExpr procedure, function call, one arg} {
d462 1
a462 1
test parseExpr-15.27 {ParsePrimaryExpr procedure, error in function arg} {
d464 2
a465 2
} {1 {syntax error in expression "foo(*1-2)": unexpected operator *}}
test parseExpr-15.28 {ParsePrimaryExpr procedure, error in function arg} {
d467 2
a468 2
} {1 {syntax error in expression "foo(*1-2)": unexpected operator *}}
test parseExpr-15.29 {ParsePrimaryExpr procedure, function call, comma after arg} {
d471 1
a471 1
test parseExpr-15.30 {ParsePrimaryExpr procedure, bad lexeme after comma} {wideIntegerUnparsed} {
d474 1
a474 1
test parseExpr-15.31 {ParsePrimaryExpr procedure, lexeme not "," or ")" after arg} {
d476 2
a477 2
} {1 {syntax error in expression "foo(123 [foo])": missing close parenthesis at end of function call}}
test parseExpr-15.32 {ParsePrimaryExpr procedure, bad lexeme after primary} {wideIntegerUnparsed} {
a479 9
test parseExpr-15.33 {ParsePrimaryExpr procedure, comma-specific message} {
    list [catch {testexprparser {123+,456} -1} msg] $msg
} {1 {syntax error in expression "123+,456": commas can only separate function arguments}}
test parseExpr-15.34 {ParsePrimaryExpr procedure, single equal-specific message} {
    list [catch {testexprparser {123+=456} -1} msg] $msg
} {1 {syntax error in expression "123+=456": single equality character not legal in expressions}}
test parseExpr-15.35 {ParsePrimaryExpr procedure, error in parenthesized subexpr} {
    list [catch {testexprparser {(: 123 : 456)} -1} msg] $msg
} {1 {syntax error in expression "(: 123 : 456)": unexpected ternary 'else' separator}}
d481 1
a481 1
test parseExpr-16.1 {GetLexeme procedure, whitespace before lexeme} {
d484 1
a484 1
test parseExpr-16.2 {GetLexeme procedure, whitespace before lexeme} {
d488 1
a488 1
test parseExpr-16.3 {GetLexeme procedure, no lexeme after whitespace} {
d492 1
a492 1
test parseExpr-16.4 {GetLexeme procedure, integer lexeme} {
d495 1
a495 1
test parseExpr-16.5 {GetLexeme procedure, integer lexeme too big} {wideIntegerUnparsed} {
d498 4
a501 6

test parseExpr-16.6 {GetLexeme procedure, bad integer lexeme} -body {
    testexprparser {0999} -1
} -returnCodes error -match glob -result {*invalid octal number*}

test parseExpr-16.7 {GetLexeme procedure, double lexeme} {
d504 1
a504 1
test parseExpr-16.8 {GetLexeme procedure, double lexeme} {
d507 1
a507 1
test parseExpr-16.9 {GetLexeme procedure, double lexeme} {nonPortable unixOnly} {
d510 1
a510 1
test parseExpr-16.10 {GetLexeme procedure, double lexeme} {nonPortable unixOnly} {
d513 1
a513 1
test parseExpr-16.11 {GetLexeme procedure, bad double lexeme too big} {
d516 1
a516 1
test parseExpr-16.12 {GetLexeme procedure, bad double lexeme} {
d518 2
a519 2
} {1 {syntax error in expression "123.4x56": extra tokens at end of expression}}
test parseExpr-16.13 {GetLexeme procedure, lexeme is "["} {
d522 1
a522 1
test parseExpr-16.14 {GetLexeme procedure, lexeme is open brace} {
d525 1
a525 1
test parseExpr-16.15 {GetLexeme procedure, lexeme is "("} {
d528 1
a528 1
test parseExpr-16.16 {GetLexeme procedure, lexeme is ")"} {
d531 1
a531 1
test parseExpr-16.17 {GetLexeme procedure, lexeme is "$"} {
d534 1
a534 1
test parseExpr-16.18 "GetLexeme procedure, lexeme is '\"'" {
d537 1
a537 1
test parseExpr-16.19 {GetLexeme procedure, lexeme is ","} {
d540 1
a540 1
test parseExpr-16.20 {GetLexeme procedure, lexeme is "*"} {
d543 1
a543 1
test parseExpr-16.21 {GetLexeme procedure, lexeme is "/"} {
d546 1
a546 1
test parseExpr-16.22 {GetLexeme procedure, lexeme is "%"} {
d549 1
a549 1
test parseExpr-16.23 {GetLexeme procedure, lexeme is "+"} {
d552 1
a552 1
test parseExpr-16.24 {GetLexeme procedure, lexeme is "-"} {
d555 1
a555 1
test parseExpr-16.25 {GetLexeme procedure, lexeme is "?" or ":"} {
d558 1
a558 1
test parseExpr-16.26 {GetLexeme procedure, lexeme is "<"} {
d561 1
a561 1
test parseExpr-16.27 {GetLexeme procedure, lexeme is "<<"} {
d564 1
a564 1
test parseExpr-16.28 {GetLexeme procedure, lexeme is "<="} {
d567 1
a567 1
test parseExpr-16.29 {GetLexeme procedure, lexeme is ">"} {
d570 1
a570 1
test parseExpr-16.30 {GetLexeme procedure, lexeme is ">>"} {
d573 1
a573 1
test parseExpr-16.31 {GetLexeme procedure, lexeme is ">="} {
d576 1
a576 1
test parseExpr-16.32 {GetLexeme procedure, lexeme is "=="} {
d579 1
a579 1
test parseExpr-16.33 {GetLexeme procedure, bad lexeme starting with "="} {
d581 2
a582 2
} {1 {syntax error in expression "2=+3": extra tokens at end of expression}}
test parseExpr-16.34 {GetLexeme procedure, lexeme is "!="} {
d585 1
a585 1
test parseExpr-16.35 {GetLexeme procedure, lexeme is "!"} {
d588 1
a588 1
test parseExpr-16.36 {GetLexeme procedure, lexeme is "&&"} {
d591 1
a591 1
test parseExpr-16.37 {GetLexeme procedure, lexeme is "&"} {
d594 1
a594 1
test parseExpr-16.38 {GetLexeme procedure, lexeme is "^"} {
d597 1
a597 1
test parseExpr-16.39 {GetLexeme procedure, lexeme is "||"} {
d600 1
a600 1
test parseExpr-16.40 {GetLexeme procedure, lexeme is "|"} {
d603 1
a603 1
test parseExpr-16.41 {GetLexeme procedure, lexeme is "~"} {
d606 1
a606 1
test parseExpr-16.42 {GetLexeme procedure, lexeme is func name} {
d609 1
a609 1
test parseExpr-16.43 {GetLexeme procedure, lexeme is func name} {
d612 1
a612 1
test parseExpr-16.44 {GetLexeme procedure, unknown lexeme} {
d614 1
a614 1
} {1 {syntax error in expression "@@27": character not legal in expressions}}
d616 1
a616 1
test parseExpr-17.1 {PrependSubExprTokens procedure, expand token array} {
d620 1
a620 1
test parseExpr-18.1 {LogSyntaxError procedure, error in expr longer than 60 chars} {
d622 1
a622 1
} {1 {syntax error in expression "(+0123456)*(+0123456)*(+0123456)*(+0123456)*(+0123456)*(+012...": premature end of expression}}
d627 13
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Tcl 8.3 upgrade
@
text
@@


1.1.1.2
log
@import tcl 8.4.0
@
text
@d11 1
a11 1
# RCS: @@(#) $Id: parseExpr.test,v 1.8 2002/08/05 03:24:41 dgp Exp $
a29 5
# Some tests only work if wide integers (>32bit) are not found to be
# integers at all.
set ::tcltest::testConstraints(wideIntegerUnparsed) \
	[expr {-1 == 0xffffffff}]

d36 1
a36 1
test parseExpr-1.3 {Tcl_ParseExpr procedure, error getting initial lexeme} {wideIntegerUnparsed} {
d41 1
a41 1
} {1 {syntax error in expression "foo+": variable references require preceding $}}
d44 1
a44 1
} {1 {syntax error in expression "1+2 345": extra tokens at end of expression}}
d51 1
a51 1
} {1 {syntax error in expression "0 || foo": variable references require preceding $}}
d58 1
a58 1
test parseExpr-2.5 {ParseCondExpr procedure, bad lexeme after "?"} {wideIntegerUnparsed} {
d66 1
a66 1
} {1 {syntax error in expression "1? fred : martha": variable references require preceding $}}
d69 1
a69 1
} {1 {syntax error in expression "1? 2 martha 3": missing colon from ternary conditional}}
d75 1
a75 1
} {1 {syntax error in expression "1? 2 : martha": variable references require preceding $}}
d82 1
a82 1
} {1 {syntax error in expression "1&&foo || 3": variable references require preceding $}}
d89 1
a89 1
test parseExpr-3.5 {ParseLorExpr procedure, bad lexeme after "||"} {wideIntegerUnparsed} {
d97 1
a97 1
} {1 {syntax error in expression "1&&2 || 3 || martha": variable references require preceding $}}
d104 1
a104 1
} {1 {syntax error in expression "1&&foo && 3": variable references require preceding $}}
d111 1
a111 1
test parseExpr-4.5 {ParseLandExpr procedure, bad lexeme after "&&"} {wideIntegerUnparsed} {
d119 1
a119 1
} {1 {syntax error in expression "1|2 && 3 && martha": variable references require preceding $}}
d126 1
a126 1
} {1 {syntax error in expression "1|foo | 3": variable references require preceding $}}
d133 1
a133 1
test parseExpr-5.5 {ParseBitOrExpr procedure, bad lexeme after "|"} {wideIntegerUnparsed} {
d141 1
a141 1
} {1 {syntax error in expression "1^2 | 3 | martha": variable references require preceding $}}
d148 1
a148 1
} {1 {syntax error in expression "1^foo ^ 3": variable references require preceding $}}
d155 1
a155 1
test parseExpr-6.5 {ParseBitXorExpr procedure, bad lexeme after "^"} {wideIntegerUnparsed} {
d163 1
a163 1
} {1 {syntax error in expression "1&2 ^ 3 ^ martha": variable references require preceding $}}
d170 1
a170 1
} {1 {syntax error in expression "1!=foo & 3": variable references require preceding $}}
d177 1
a177 1
test parseExpr-7.5 {ParseBitAndExpr procedure, bad lexeme after "&"} {wideIntegerUnparsed} {
d185 1
a185 1
} {1 {syntax error in expression "1==2 & 3>2 & martha": variable references require preceding $}}
d187 1
a187 1
test parseExpr-8.1 {ParseEqualityExpr procedure, valid LHS relational subexpr} {
d190 1
a190 1
test parseExpr-8.2 {ParseEqualityExpr procedure, error in LHS relational subexpr} {
d192 2
a193 2
} {1 {syntax error in expression "1>=foo == 3": variable references require preceding $}}
test parseExpr-8.3 {ParseEqualityExpr procedure, next lexeme isn't "==" or "!="} {
d196 1
a196 1
test parseExpr-8.4 {ParseEqualityExpr procedure, next lexeme is "==" or "!="} {
d199 1
a199 1
test parseExpr-8.5 {ParseEqualityExpr procedure, next lexeme is "==" or "!="} {
d202 1
a202 1
test parseExpr-8.6 {ParseEqualityExpr procedure, bad lexeme after "==" or "!="} {wideIntegerUnparsed} {
d205 1
a205 1
test parseExpr-8.7 {ParseEqualityExpr procedure, valid RHS subexpression} {
d208 1
a208 1
test parseExpr-8.8 {ParseEqualityExpr procedure, error in RHS subexpression} {
d210 1
a210 1
} {1 {syntax error in expression "1<2 == 3 != martha": variable references require preceding $}}
d212 1
a212 1
test parseExpr-9.1 {ParseRelationalExpr procedure, valid LHS shift subexpr} {
d215 1
a215 1
test parseExpr-9.2 {ParseRelationalExpr procedure, error in LHS shift subexpr} {
d217 2
a218 2
} {1 {syntax error in expression "1>=foo < 3": variable references require preceding $}}
test parseExpr-9.3 {ParseRelationalExpr procedure, next lexeme isn't relational op} {
d221 1
a221 1
test parseExpr-9.4 {ParseRelationalExpr procedure, next lexeme is relational op} {
d224 1
a224 1
test parseExpr-9.5 {ParseRelationalExpr procedure, next lexeme is relational op} {
d227 1
a227 1
test parseExpr-9.6 {ParseRelationalExpr procedure, next lexeme is relational op} {
d230 1
a230 1
test parseExpr-9.7 {ParseRelationalExpr procedure, next lexeme is relational op} {
d233 1
a233 1
test parseExpr-9.8 {ParseRelationalExpr procedure, bad lexeme after relational op} {wideIntegerUnparsed} {
d236 1
a236 1
test parseExpr-9.9 {ParseRelationalExpr procedure, valid RHS subexpression} {
d239 1
a239 1
test parseExpr-9.10 {ParseRelationalExpr procedure, error in RHS subexpression} {
d241 1
a241 1
} {1 {syntax error in expression "1<<2 < 3 > martha": variable references require preceding $}}
d243 1
a243 1
test parseExpr-10.1 {ParseShiftExpr procedure, valid LHS add subexpr} {
d246 1
a246 1
test parseExpr-10.2 {ParseShiftExpr procedure, error in LHS add subexpr} {
d248 2
a249 2
} {1 {syntax error in expression "1-foo << 3": variable references require preceding $}}
test parseExpr-10.3 {ParseShiftExpr procedure, next lexeme isn't "<<" or ">>"} {
d252 1
a252 1
test parseExpr-10.4 {ParseShiftExpr procedure, next lexeme is "<<" or ">>"} {
d255 1
a255 1
test parseExpr-10.5 {ParseShiftExpr procedure, next lexeme is "<<" or ">>"} {
d258 1
a258 1
test parseExpr-10.6 {ParseShiftExpr procedure, bad lexeme after "<<" or ">>"} {wideIntegerUnparsed} {
d261 1
a261 1
test parseExpr-10.7 {ParseShiftExpr procedure, valid RHS subexpression} {
d264 1
a264 1
test parseExpr-10.8 {ParseShiftExpr procedure, error in RHS subexpression} {
d266 1
a266 1
} {1 {syntax error in expression "1+2 << 3 >> martha": variable references require preceding $}}
d268 1
a268 1
test parseExpr-11.1 {ParseAddExpr procedure, valid LHS multiply subexpr} {
d271 1
a271 1
test parseExpr-11.2 {ParseAddExpr procedure, error in LHS multiply subexpr} {
d273 2
a274 2
} {1 {syntax error in expression "1/foo + 3": variable references require preceding $}}
test parseExpr-11.3 {ParseAddExpr procedure, next lexeme isn't "+" or "-"} {
d277 1
a277 1
test parseExpr-11.4 {ParseAddExpr procedure, next lexeme is "+" or "-"} {
d280 1
a280 1
test parseExpr-11.5 {ParseAddExpr procedure, next lexeme is "+" or "-"} {
d283 1
a283 1
test parseExpr-11.6 {ParseAddExpr procedure, bad lexeme after "+" or "-"} {wideIntegerUnparsed} {
d286 1
a286 1
test parseExpr-11.7 {ParseAddExpr procedure, valid RHS subexpression} {
d289 1
a289 1
test parseExpr-11.8 {ParseAddExpr procedure, error in RHS subexpression} {
d291 1
a291 1
} {1 {syntax error in expression "1*2 + 3 - martha": variable references require preceding $}}
d293 1
a293 1
test parseExpr-12.1 {ParseAddExpr procedure, valid LHS multiply subexpr} {
d296 1
a296 1
test parseExpr-12.2 {ParseAddExpr procedure, error in LHS multiply subexpr} {
d298 2
a299 2
} {1 {syntax error in expression "1/foo + 3": variable references require preceding $}}
test parseExpr-12.3 {ParseAddExpr procedure, next lexeme isn't "+" or "-"} {
d302 1
a302 1
test parseExpr-12.4 {ParseAddExpr procedure, next lexeme is "+" or "-"} {
d305 1
a305 1
test parseExpr-12.5 {ParseAddExpr procedure, next lexeme is "+" or "-"} {
d308 1
a308 1
test parseExpr-12.6 {ParseAddExpr procedure, bad lexeme after "+" or "-"} {wideIntegerUnparsed} {
d311 1
a311 1
test parseExpr-12.7 {ParseAddExpr procedure, valid RHS subexpression} {
d314 1
a314 1
test parseExpr-12.8 {ParseAddExpr procedure, error in RHS subexpression} {
d316 1
a316 1
} {1 {syntax error in expression "1*2 + 3 - martha": variable references require preceding $}}
d318 1
a318 1
test parseExpr-13.1 {ParseMultiplyExpr procedure, valid LHS unary subexpr} {
d321 1
a321 1
test parseExpr-13.2 {ParseMultiplyExpr procedure, error in LHS unary subexpr} {wideIntegerUnparsed} {
d324 1
a324 1
test parseExpr-13.3 {ParseMultiplyExpr procedure, next lexeme isn't "*", "/", or "%"} {
d327 1
a327 1
test parseExpr-13.4 {ParseMultiplyExpr procedure, next lexeme is "*", "/", or "%"} {
d330 1
a330 1
test parseExpr-13.5 {ParseMultiplyExpr procedure, next lexeme is "*", "/", or "%"} {
d333 1
a333 1
test parseExpr-13.6 {ParseMultiplyExpr procedure, next lexeme is "*", "/", or "%"} {
d336 1
a336 1
test parseExpr-13.7 {ParseMultiplyExpr procedure, bad lexeme after "*", "/", or "%"} {wideIntegerUnparsed} {
d339 1
a339 1
test parseExpr-13.8 {ParseMultiplyExpr procedure, valid RHS subexpression} {
d342 1
a342 1
test parseExpr-13.9 {ParseMultiplyExpr procedure, error in RHS subexpression} {
d344 1
a344 1
} {1 {syntax error in expression "++2 / 3 * martha": variable references require preceding $}}
d346 1
a346 1
test parseExpr-14.1 {ParseUnaryExpr procedure, first token is unary operator} {
d349 1
a349 1
test parseExpr-14.2 {ParseUnaryExpr procedure, first token is unary operator} {
d352 1
a352 1
test parseExpr-14.3 {ParseUnaryExpr procedure, first token is unary operator} {
d355 1
a355 1
test parseExpr-14.4 {ParseUnaryExpr procedure, first token is unary operator} {
d358 1
a358 1
test parseExpr-14.5 {ParseUnaryExpr procedure, error in lexeme after unary op} {wideIntegerUnparsed} {
d361 1
a361 1
test parseExpr-14.6 {ParseUnaryExpr procedure, simple unary expr after unary op} {
d364 1
a364 1
test parseExpr-14.7 {ParseUnaryExpr procedure, another unary expr after unary op} {
d367 1
a367 1
test parseExpr-14.8 {ParseUnaryExpr procedure, error in unary expr after unary op} {
d369 2
a370 2
} {1 {syntax error in expression "+-||27": unexpected operator ||}}
test parseExpr-14.9 {ParseUnaryExpr procedure, error in unary expr after unary op} {
d372 2
a373 2
} {1 {syntax error in expression "+-||27": unexpected operator ||}}
test parseExpr-14.10 {ParseUnaryExpr procedure, first token is not unary op} {
d376 1
a376 1
test parseExpr-14.11 {ParseUnaryExpr procedure, not unary expr, complex primary expr} {
d379 1
a379 1
test parseExpr-14.12 {ParseUnaryExpr procedure, not unary expr, error in primary expr} {wideIntegerUnparsed} {
d383 1
a383 1
test parseExpr-15.1 {ParsePrimaryExpr procedure, just parenthesized subexpr} {
d386 1
a386 1
test parseExpr-15.2 {ParsePrimaryExpr procedure, bad lexeme after "("} {wideIntegerUnparsed} {
d389 1
a389 1
test parseExpr-15.3 {ParsePrimaryExpr procedure, valid parenthesized subexpr} {
d392 1
a392 1
test parseExpr-15.4 {ParsePrimaryExpr procedure, error in parenthesized subexpr} {
d394 2
a395 2
} {1 {syntax error in expression "(? 123 : 456)": unexpected ternary 'then' separator}}
test parseExpr-15.5 {ParsePrimaryExpr procedure, missing ")" after in parenthesized subexpr} {
d397 2
a398 2
} {1 {syntax error in expression "({abc}/{def}": looking for close parenthesis}}
test parseExpr-15.6 {ParsePrimaryExpr procedure, primary is literal} {
d401 1
a401 1
test parseExpr-15.7 {ParsePrimaryExpr procedure, primary is literal} {
d404 1
a404 1
test parseExpr-15.8 {ParsePrimaryExpr procedure, primary is var reference} {
d407 1
a407 1
test parseExpr-15.9 {ParsePrimaryExpr procedure, primary is var reference} {
d410 1
a410 1
test parseExpr-15.10 {ParsePrimaryExpr procedure, primary is var reference} {
d413 1
a413 1
test parseExpr-15.11 {ParsePrimaryExpr procedure, error in var reference} {
d416 1
a416 1
test parseExpr-15.12 {ParsePrimaryExpr procedure, primary is quoted string} {
d419 1
a419 1
test parseExpr-15.13 {ParsePrimaryExpr procedure, error in quoted string} {
d422 1
a422 1
test parseExpr-15.14 {ParsePrimaryExpr procedure, quoted string has multiple tokens} {
d425 1
a425 1
test parseExpr-15.15 {ParsePrimaryExpr procedure, primary is command} {
d428 1
a428 1
test parseExpr-15.16 {ParsePrimaryExpr procedure, primary is multiple commands} {
d431 1
a431 1
test parseExpr-15.17 {ParsePrimaryExpr procedure, primary is multiple commands} {
d434 1
a434 1
test parseExpr-15.18 {ParsePrimaryExpr procedure, missing close bracket} {
d437 1
a437 1
test parseExpr-15.19 {ParsePrimaryExpr procedure, primary is braced string} {
d440 1
a440 1
test parseExpr-15.20 {ParsePrimaryExpr procedure, error in primary, which is braced string} {
d443 1
a443 1
test parseExpr-15.21 {ParsePrimaryExpr procedure, primary is braced string with multiple tokens} {
d447 1
a447 1
test parseExpr-15.22 {ParsePrimaryExpr procedure, primary is function call} {
d450 1
a450 1
test parseExpr-15.23 {ParsePrimaryExpr procedure, bad lexeme after function name} {wideIntegerUnparsed} {
d453 1
a453 1
test parseExpr-15.24 {ParsePrimaryExpr procedure, lexeme after function name isn't "("} {
d455 2
a456 2
} {1 {syntax error in expression "foo 27.4 123)": variable references require preceding $}}
test parseExpr-15.25 {ParsePrimaryExpr procedure, bad lexeme after "("} {wideIntegerUnparsed} {
d459 1
a459 1
test parseExpr-15.26 {ParsePrimaryExpr procedure, function call, one arg} {
d462 1
a462 1
test parseExpr-15.27 {ParsePrimaryExpr procedure, error in function arg} {
d464 2
a465 2
} {1 {syntax error in expression "foo(*1-2)": unexpected operator *}}
test parseExpr-15.28 {ParsePrimaryExpr procedure, error in function arg} {
d467 2
a468 2
} {1 {syntax error in expression "foo(*1-2)": unexpected operator *}}
test parseExpr-15.29 {ParsePrimaryExpr procedure, function call, comma after arg} {
d471 1
a471 1
test parseExpr-15.30 {ParsePrimaryExpr procedure, bad lexeme after comma} {wideIntegerUnparsed} {
d474 1
a474 1
test parseExpr-15.31 {ParsePrimaryExpr procedure, lexeme not "," or ")" after arg} {
d476 2
a477 2
} {1 {syntax error in expression "foo(123 [foo])": missing close parenthesis at end of function call}}
test parseExpr-15.32 {ParsePrimaryExpr procedure, bad lexeme after primary} {wideIntegerUnparsed} {
a479 9
test parseExpr-15.33 {ParsePrimaryExpr procedure, comma-specific message} {
    list [catch {testexprparser {123+,456} -1} msg] $msg
} {1 {syntax error in expression "123+,456": commas can only separate function arguments}}
test parseExpr-15.34 {ParsePrimaryExpr procedure, single equal-specific message} {
    list [catch {testexprparser {123+=456} -1} msg] $msg
} {1 {syntax error in expression "123+=456": single equality character not legal in expressions}}
test parseExpr-15.35 {ParsePrimaryExpr procedure, error in parenthesized subexpr} {
    list [catch {testexprparser {(: 123 : 456)} -1} msg] $msg
} {1 {syntax error in expression "(: 123 : 456)": unexpected ternary 'else' separator}}
d481 1
a481 1
test parseExpr-16.1 {GetLexeme procedure, whitespace before lexeme} {
d484 1
a484 1
test parseExpr-16.2 {GetLexeme procedure, whitespace before lexeme} {
d488 1
a488 1
test parseExpr-16.3 {GetLexeme procedure, no lexeme after whitespace} {
d492 1
a492 1
test parseExpr-16.4 {GetLexeme procedure, integer lexeme} {
d495 1
a495 1
test parseExpr-16.5 {GetLexeme procedure, integer lexeme too big} {wideIntegerUnparsed} {
d498 4
a501 6

test parseExpr-16.6 {GetLexeme procedure, bad integer lexeme} -body {
    testexprparser {0999} -1
} -returnCodes error -match glob -result {*invalid octal number*}

test parseExpr-16.7 {GetLexeme procedure, double lexeme} {
d504 1
a504 1
test parseExpr-16.8 {GetLexeme procedure, double lexeme} {
d507 1
a507 1
test parseExpr-16.9 {GetLexeme procedure, double lexeme} {nonPortable unixOnly} {
d510 1
a510 1
test parseExpr-16.10 {GetLexeme procedure, double lexeme} {nonPortable unixOnly} {
d513 1
a513 1
test parseExpr-16.11 {GetLexeme procedure, bad double lexeme too big} {
d516 1
a516 1
test parseExpr-16.12 {GetLexeme procedure, bad double lexeme} {
d518 2
a519 2
} {1 {syntax error in expression "123.4x56": extra tokens at end of expression}}
test parseExpr-16.13 {GetLexeme procedure, lexeme is "["} {
d522 1
a522 1
test parseExpr-16.14 {GetLexeme procedure, lexeme is open brace} {
d525 1
a525 1
test parseExpr-16.15 {GetLexeme procedure, lexeme is "("} {
d528 1
a528 1
test parseExpr-16.16 {GetLexeme procedure, lexeme is ")"} {
d531 1
a531 1
test parseExpr-16.17 {GetLexeme procedure, lexeme is "$"} {
d534 1
a534 1
test parseExpr-16.18 "GetLexeme procedure, lexeme is '\"'" {
d537 1
a537 1
test parseExpr-16.19 {GetLexeme procedure, lexeme is ","} {
d540 1
a540 1
test parseExpr-16.20 {GetLexeme procedure, lexeme is "*"} {
d543 1
a543 1
test parseExpr-16.21 {GetLexeme procedure, lexeme is "/"} {
d546 1
a546 1
test parseExpr-16.22 {GetLexeme procedure, lexeme is "%"} {
d549 1
a549 1
test parseExpr-16.23 {GetLexeme procedure, lexeme is "+"} {
d552 1
a552 1
test parseExpr-16.24 {GetLexeme procedure, lexeme is "-"} {
d555 1
a555 1
test parseExpr-16.25 {GetLexeme procedure, lexeme is "?" or ":"} {
d558 1
a558 1
test parseExpr-16.26 {GetLexeme procedure, lexeme is "<"} {
d561 1
a561 1
test parseExpr-16.27 {GetLexeme procedure, lexeme is "<<"} {
d564 1
a564 1
test parseExpr-16.28 {GetLexeme procedure, lexeme is "<="} {
d567 1
a567 1
test parseExpr-16.29 {GetLexeme procedure, lexeme is ">"} {
d570 1
a570 1
test parseExpr-16.30 {GetLexeme procedure, lexeme is ">>"} {
d573 1
a573 1
test parseExpr-16.31 {GetLexeme procedure, lexeme is ">="} {
d576 1
a576 1
test parseExpr-16.32 {GetLexeme procedure, lexeme is "=="} {
d579 1
a579 1
test parseExpr-16.33 {GetLexeme procedure, bad lexeme starting with "="} {
d581 2
a582 2
} {1 {syntax error in expression "2=+3": extra tokens at end of expression}}
test parseExpr-16.34 {GetLexeme procedure, lexeme is "!="} {
d585 1
a585 1
test parseExpr-16.35 {GetLexeme procedure, lexeme is "!"} {
d588 1
a588 1
test parseExpr-16.36 {GetLexeme procedure, lexeme is "&&"} {
d591 1
a591 1
test parseExpr-16.37 {GetLexeme procedure, lexeme is "&"} {
d594 1
a594 1
test parseExpr-16.38 {GetLexeme procedure, lexeme is "^"} {
d597 1
a597 1
test parseExpr-16.39 {GetLexeme procedure, lexeme is "||"} {
d600 1
a600 1
test parseExpr-16.40 {GetLexeme procedure, lexeme is "|"} {
d603 1
a603 1
test parseExpr-16.41 {GetLexeme procedure, lexeme is "~"} {
d606 1
a606 1
test parseExpr-16.42 {GetLexeme procedure, lexeme is func name} {
d609 1
a609 1
test parseExpr-16.43 {GetLexeme procedure, lexeme is func name} {
d612 1
a612 1
test parseExpr-16.44 {GetLexeme procedure, unknown lexeme} {
d614 1
a614 1
} {1 {syntax error in expression "@@27": character not legal in expressions}}
d616 1
a616 1
test parseExpr-17.1 {PrependSubExprTokens procedure, expand token array} {
d620 1
a620 1
test parseExpr-18.1 {LogSyntaxError procedure, error in expr longer than 60 chars} {
d622 1
a622 1
} {1 {syntax error in expression "(+0123456)*(+0123456)*(+0123456)*(+0123456)*(+0123456)*(+012...": premature end of expression}}
d627 13
@

