head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.58
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.56
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.54
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.52
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.50
	gdb_7_0-branch:1.5.0.48
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tcl8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.46
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.44
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.42
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.40
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.38
	gdb_6_5-2006-05-14-branchpoint:1.5
	readline_5_1-import-branch:1.5.0.36
	readline_5_1-import-branchpoint:1.5
	gdb_6_4-branch:1.5.0.34
	gdb_6_4-2005-11-01-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.32
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	ezannoni_pie-20040323-branch:1.5.0.30
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.28
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.26
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.24
	cagney_x86i386-20030821-branch:1.5.0.22
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.20
	gdb_6_0-2003-06-23-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.18
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.16
	cagney_writestrings-20030508-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.14
	cagney_fileio-20030521-branchpoint:1.5
	carlton_dictionary-20030430-merge:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.12
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.10
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.8
	cagney_lazyid-20030317-branchpoint:1.5
	offbyone-20030313-branch:1.5.0.6
	offbyone-20030313-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.4
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.2
	interps-20030202-branchpoint:1.5
	TCL8_4_1:1.1.1.3
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.2
	TCL_8_4_1:1.1.1.3
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.4
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TCL_8_4_0:1.1.1.3
	carlton_dictionary-branch:1.2.0.16
	carlton_dictionary-20020920-branchpoint:1.2
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.14
	gdb_5_3-branch:1.2.0.12
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.10
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.8
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.6
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TCL_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	dejagnu-2000-02-04:1.1.1.1
	dejagnu-2000-01-31:1.1.1.1
	dejagnu-2000-01-24:1.1.1.1
	dejagnu-2000-01-17:1.1.1.1
	dejagnu-2000-01-10:1.1.1.1
	dejagnu-2000-01-04:1.1.1.1
	dejagnu-1999-12-21:1.1.1.1
	dejagnu-1999-12-13:1.1.1.1
	dejagnu-1999-12-07:1.1.1.1
	dejagnu-1999-12-06:1.1.1.1
	dejagnu-1999-11-15:1.1.1.1
	dejagnu-1999-11-08:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2003.01.21.19.40.16;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.26.19.48.02;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.37.08;	author kseitz;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2001.09.09.23.56.08;	author irox;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2002.09.27.21.49.11;	author kseitz;	state Exp;
branches;
next	;

1.3.4.1
date	2003.12.14.20.28.50;	author drow;	state Exp;
branches;
next	;

1.2.16.1
date	2002.12.23.19.40.44;	author carlton;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2003.02.07.19.18.20;	author carlton;	state Exp;
branches;
next	;

1.1.1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.09.22.40.58;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.19.56.40;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tcl 8.4.1
@
text
@# Commands covered:  scan
#
# This file contains a collection of tests for one or more of the Tcl
# built-in commands.  Sourcing this file into Tcl runs the tests and
# generates output for errors.  No output means no errors were found.
#
# Copyright (c) 1991-1994 The Regents of the University of California.
# Copyright (c) 1994-1997 Sun Microsystems, Inc.
# Copyright (c) 1998-1999 by Scriptics Corporation.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# RCS: @@(#) $Id: scan.test,v 1.14 2002/06/22 04:19:47 dgp Exp $

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest 2
    namespace import -force ::tcltest::*
}

::tcltest::testConstraint 64bitInts [expr {0x80000000 > 0}]

test scan-1.1 {BuildCharSet, CharInSet} {
    list [scan foo {%[^o]} x] $x
} {1 f}
test scan-1.2 {BuildCharSet, CharInSet} {
    list [scan \]foo {%[]f]} x] $x
} {1 \]f}
test scan-1.3 {BuildCharSet, CharInSet} {
    list [scan abc-def {%[a-c]} x] $x
} {1 abc}
test scan-1.4 {BuildCharSet, CharInSet} {
    list [scan abc-def {%[a-c]} x] $x
} {1 abc}
test scan-1.5 {BuildCharSet, CharInSet} {
    list [scan -abc-def {%[-ac]} x] $x
} {1 -a}
test scan-1.6 {BuildCharSet, CharInSet} {
    list [scan -abc-def {%[ac-]} x] $x
} {1 -a}
test scan-1.7 {BuildCharSet, CharInSet} {
    list [scan abc-def {%[c-a]} x] $x
} {1 abc}
test scan-1.8 {BuildCharSet, CharInSet} {
    list [scan def-abc {%[^c-a]} x] $x
} {1 def-}
test scan-1.9 {BuildCharSet, CharInSet no match} {
    catch {unset x}
    list [scan {= f} {= %[TF]} x] [info exists x]
} {0 0}

test scan-2.1 {ReleaseCharSet} {
    list [scan abcde {%[abc]} x] $x
} {1 abc}
test scan-2.2 {ReleaseCharSet} {
    list [scan abcde {%[a-c]} x] $x
} {1 abc}

test scan-3.1 {ValidateFormat} {
    list [catch {scan {} {%d%1$d} x} msg] $msg
} {1 {cannot mix "%" and "%n$" conversion specifiers}}
test scan-3.2 {ValidateFormat} {
    list [catch {scan {} {%d%1$d} x} msg] $msg
} {1 {cannot mix "%" and "%n$" conversion specifiers}}
test scan-3.3 {ValidateFormat} {
    list [catch {scan {} {%2$d%d} x} msg] $msg
} {1 {"%n$" argument index out of range}}
test scan-3.4 {ValidateFormat} {
    # degenerate case, before changed from 8.2 to 8.3
    list [catch {scan {} %d} msg] $msg
} {0 {}}
test scan-3.5 {ValidateFormat} {
    list [catch {scan {} {%10c} a} msg] $msg
} {1 {field width may not be specified in %c conversion}}
test scan-3.6 {ValidateFormat} {
    list [catch {scan {} {%*1$d} a} msg] $msg
} {1 {bad scan conversion character "$"}}
test scan-3.7 {ValidateFormat} {
    list [catch {scan {} {%1$d%1$d} a} msg] $msg
} {1 {variable is assigned by multiple "%n$" conversion specifiers}}
test scan-3.8 {ValidateFormat} {
    list [catch {scan {} a x} msg] $msg
} {1 {variable is not assigned by any conversion specifiers}}
test scan-3.9 {ValidateFormat} {
    list [catch {scan {} {%2$s} x y} msg] $msg
} {1 {variable is not assigned by any conversion specifiers}}
test scan-3.10 {ValidateFormat} {
    list [catch {scan {} {%[a} x} msg] $msg
} {1 {unmatched [ in format string}}
test scan-3.11 {ValidateFormat} {
    list [catch {scan {} {%[^a} x} msg] $msg
} {1 {unmatched [ in format string}}
test scan-3.12 {ValidateFormat} {
    list [catch {scan {} {%[]a} x} msg] $msg
} {1 {unmatched [ in format string}}
test scan-3.13 {ValidateFormat} {
    list [catch {scan {} {%[^]a} x} msg] $msg
} {1 {unmatched [ in format string}}

test scan-4.1 {Tcl_ScanObjCmd, argument checks} {
    list [catch {scan} msg] $msg
} {1 {wrong # args: should be "scan string format ?varName varName ...?"}}
test scan-4.2 {Tcl_ScanObjCmd, argument checks} {
    list [catch {scan string} msg] $msg
} {1 {wrong # args: should be "scan string format ?varName varName ...?"}}
test scan-4.3 {Tcl_ScanObjCmd, argument checks} {
    # degenerate case, before changed from 8.2 to 8.3
    list [catch {scan string format} msg] $msg
} {0 {}}
test scan-4.4 {Tcl_ScanObjCmd, whitespace} {
    list [scan {   abc   def   } {%s%s} x y] $x $y
} {2 abc def}
test scan-4.5 {Tcl_ScanObjCmd, whitespace} {
    list [scan {   abc   def   } { %s %s } x y] $x $y
} {2 abc def}
test scan-4.6 {Tcl_ScanObjCmd, whitespace} {
    list [scan {   abc   def   } { %s %s } x y] $x $y
} {2 abc def}
test scan-4.7 {Tcl_ScanObjCmd, literals} {
    # degenerate case, before changed from 8.2 to 8.3
    scan {   abc   def   } { abc def }
} {}
test scan-4.8 {Tcl_ScanObjCmd, literals} {
    set x {}
    list [scan {   abcg} { abc def %1s} x] $x
} {0 {}}
test scan-4.9 {Tcl_ScanObjCmd, literals} {
    list [scan {   abc%defghi} { abc %% def%n } x] $x
} {1 10}
test scan-4.10 {Tcl_ScanObjCmd, assignment suppression} {
    list [scan {   abc   def   } { %*c%s def } x] $x
} {1 bc}
test scan-4.11 {Tcl_ScanObjCmd, XPG3-style} {
    list [scan {   abc   def   } {%2$s %1$s} x y] $x $y
} {2 def abc}
test scan-4.12 {Tcl_ScanObjCmd, width specifiers} {
    list [scan {abc123456789012} {%3s%3d%3f%3[0-9]%s} a b c d e] $a $b $c $d $e
} {5 abc 123 456.0 789 012}
test scan-4.13 {Tcl_ScanObjCmd, width specifiers} {
    list [scan {abc123456789012} {%3s%3d%3f%3[0-9]%s} a b c d e] $a $b $c $d $e
} {5 abc 123 456.0 789 012}
test scan-4.14 {Tcl_ScanObjCmd, underflow} {
    set x {}
    list [scan {a} {a%d} x] $x
} {-1 {}}
test scan-4.15 {Tcl_ScanObjCmd, underflow} {
    set x {}
    list [scan {} {a%d} x] $x
} {-1 {}}
test scan-4.16 {Tcl_ScanObjCmd, underflow} {
    set x {}
    list [scan {ab} {a%d} x] $x
} {0 {}}
test scan-4.17 {Tcl_ScanObjCmd, underflow} {
    set x {}
    list [scan {a   } {a%d} x] $x
} {-1 {}}
test scan-4.18 {Tcl_ScanObjCmd, skipping whitespace} {
    list [scan {  b} {%c%s} x y] $x $y
} {2 32 b}
test scan-4.19 {Tcl_ScanObjCmd, skipping whitespace} {
    list [scan {  b} {%[^b]%s} x y] $x $y
} {2 {  } b}
test scan-4.20 {Tcl_ScanObjCmd, string scanning} {
    list [scan {abc def} {%s} x] $x
} {1 abc}
test scan-4.21 {Tcl_ScanObjCmd, string scanning} {
    list [scan {abc def} {%0s} x] $x
} {1 abc}
test scan-4.22 {Tcl_ScanObjCmd, string scanning} {
    list [scan {abc def} {%2s} x] $x
} {1 ab}
test scan-4.23 {Tcl_ScanObjCmd, string scanning} {
    list [scan {abc def} {%*s%n} x] $x
} {1 3}
test scan-4.24 {Tcl_ScanObjCmd, charset scanning} {
    list [scan {abcdef} {%[a-c]} x] $x
} {1 abc}
test scan-4.25 {Tcl_ScanObjCmd, charset scanning} {
    list [scan {abcdef} {%0[a-c]} x] $x
} {1 abc}
test scan-4.26 {Tcl_ScanObjCmd, charset scanning} {
    list [scan {abcdef} {%2[a-c]} x] $x
} {1 ab}
test scan-4.27 {Tcl_ScanObjCmd, charset scanning} {
    list [scan {abcdef} {%*[a-c]%n} x] $x
} {1 3}
test scan-4.28 {Tcl_ScanObjCmd, character scanning} {
    list [scan {abcdef} {%c} x] $x
} {1 97}
test scan-4.29 {Tcl_ScanObjCmd, character scanning} {
    list [scan {abcdef} {%*c%n} x] $x
} {1 1}

test scan-4.30 {Tcl_ScanObjCmd, base-10 integer scanning} {
    set x {}
    list [scan {1234567890a} {%3d} x] $x
} {1 123}
test scan-4.31 {Tcl_ScanObjCmd, base-10 integer scanning} {
    set x {}
    list [scan {1234567890a} {%d} x] $x
} {1 1234567890}
test scan-4.32 {Tcl_ScanObjCmd, base-10 integer scanning} {
    set x {}
    list [scan {01234567890a} {%d} x] $x
} {1 1234567890}
test scan-4.33 {Tcl_ScanObjCmd, base-10 integer scanning} {
    set x {}
    list [scan {+01234} {%d} x] $x
} {1 1234}
test scan-4.34 {Tcl_ScanObjCmd, base-10 integer scanning} {
    set x {}
    list [scan {-01234} {%d} x] $x
} {1 -1234}
test scan-4.35 {Tcl_ScanObjCmd, base-10 integer scanning} {
    set x {}
    list [scan {a01234} {%d} x] $x
} {0 {}}
test scan-4.36 {Tcl_ScanObjCmd, base-10 integer scanning} {
    set x {}
    list [scan {0x10} {%d} x] $x
} {1 0}
test scan-4.37 {Tcl_ScanObjCmd, base-8 integer scanning} {
    set x {}
    list [scan {012345678} {%o} x] $x
} {1 342391}
test scan-4.38 {Tcl_ScanObjCmd, base-8 integer scanning} {
    set x {}
    list [scan {+1238 -1239 123a} {%o%*s%o%*s%o} x y z] $x $y $z
} {3 83 -83 83}
test scan-4.39 {Tcl_ScanObjCmd, base-16 integer scanning} {
    set x {}
    list [scan {+1238 -123a 0123} {%x%x%x} x y z] $x $y $z
} {3 4664 -4666 291}
test scan-4.40 {Tcl_ScanObjCmd, base-16 integer scanning} {
    # The behavior changed in 8.4a4/8.3.4cvs (6 Feb) to correctly
    # return '1' for 0x1 scanned via %x, to comply with 8.0 and C scanf.
    # Bug #495213
    set x {}
    list [scan {aBcDeF AbCdEf 0x1} {%x%x%x} x y z] $x $y $z
} {3 11259375 11259375 1}
test scan-4.40.1 {Tcl_ScanObjCmd, base-16 integer scanning} {
    set x {}
    list [scan {0xF 0x00A0B 0X0XF} {%x %x %x} x y z] $x $y $z
} {3 15 2571 0}
test scan-4.40.2 {Tcl_ScanObjCmd, base-16 integer scanning} {
    catch {unset x}
    list [scan {xF} {%x} x] [info exists x]
} {0 0}
test scan-4.41 {Tcl_ScanObjCmd, base-unknown integer scanning} {
    set x {}
    list [scan {10 010 0x10} {%i%i%i} x y z] $x $y $z
} {3 10 8 16}
test scan-4.42 {Tcl_ScanObjCmd, base-unknown integer scanning} {
    set x {}
    list [scan {10 010 0X10} {%i%i%i} x y z] $x $y $z
} {3 10 8 16}
test scan-4.43 {Tcl_ScanObjCmd, integer scanning, odd cases} {
    set x {}
    list [scan {+ } {%i} x] $x
} {0 {}}
test scan-4.44 {Tcl_ScanObjCmd, integer scanning, odd cases} {
    set x {}
    list [scan {+} {%i} x] $x
} {-1 {}}
test scan-4.45 {Tcl_ScanObjCmd, integer scanning, odd cases} {
    set x {}
    list [scan {0x} {%i%s} x y] $x $y
} {2 0 x}
test scan-4.46 {Tcl_ScanObjCmd, integer scanning, odd cases} {
    set x {}
    list [scan {0X} {%i%s} x y] $x $y
} {2 0 X}
test scan-4.47 {Tcl_ScanObjCmd, integer scanning, suppressed} {
    set x {}
    list [scan {123def} {%*i%s} x] $x
} {1 def}
test scan-4.48 {Tcl_ScanObjCmd, float scanning} {
    list [scan {1 2 3} {%e %f %g} x y z] $x $y $z
} {3 1.0 2.0 3.0}
test scan-4.49 {Tcl_ScanObjCmd, float scanning} {
    list [scan {.1 0.2 3.} {%e %f %g} x y z] $x $y $z
} {3 0.1 0.2 3.0}
test scan-4.50 {Tcl_ScanObjCmd, float scanning} {
    list [scan {1234567890a} %f x] $x
} {1 1234567890.0}
test scan-4.51 {Tcl_ScanObjCmd, float scanning} {
    list [scan {+123+45} %f x] $x
} {1 123.0}
test scan-4.52 {Tcl_ScanObjCmd, float scanning} {
    list [scan {-123+45} %f x] $x
} {1 -123.0}
test scan-4.53 {Tcl_ScanObjCmd, float scanning} {
    list [scan {1.0e1} %f x] $x
} {1 10.0}
test scan-4.54 {Tcl_ScanObjCmd, float scanning} {
    list [scan {1.0e-1} %f x] $x
} {1 0.1}
test scan-4.55 {Tcl_ScanObjCmd, odd cases} {
    set x {}
    list [scan {+} %f x] $x
} {-1 {}}
test scan-4.56 {Tcl_ScanObjCmd, odd cases} {
    set x {}
    list [scan {1.0e} %f%s x y] $x $y
} {2 1.0 e}
test scan-4.57 {Tcl_ScanObjCmd, odd cases} {
    set x {}
    list [scan {1.0e+} %f%s x y] $x $y
} {2 1.0 e+}
test scan-4.58 {Tcl_ScanObjCmd, odd cases} {
    set x {}
    set y {}
    list [scan {e1} %f%s x y] $x $y
} {0 {} {}}
test scan-4.59 {Tcl_ScanObjCmd, float scanning} {
    list [scan {1.0e-1x} %*f%n x] $x
} {1 6}

test scan-4.60 {Tcl_ScanObjCmd, set errors} {
    set x {}
    set y {}
    catch {unset z}; array set z {}
    set result [list [catch {scan {abc def ghi} {%s%s%s} x z y} msg] \
	    $msg $x $y]
    unset z
    set result
} {1 {couldn't set variable "z"} abc ghi}
test scan-4.61 {Tcl_ScanObjCmd, set errors} {
    set x {}
    catch {unset y}; array set y {}
    catch {unset z}; array set z {}
    set result [list [catch {scan {abc def ghi} {%s%s%s} x z y} msg] \
	    $msg $x]
    unset y
    unset z
    set result
} {1 {couldn't set variable "z"couldn't set variable "y"} abc}

# procedure that returns the range of integers

proc int_range {} {
    for { set MIN_INT 1 } { $MIN_INT > 0 } {} {
	set MIN_INT [expr { $MIN_INT << 1 }]
    }
    set MAX_INT [expr { ~ $MIN_INT }]
    return [list $MIN_INT $MAX_INT]
}

test scan-4.62 {scanning of large and negative octal integers} {
    foreach { MIN_INT MAX_INT } [int_range] {}
    set scanstring [format {%o %o %o} -1 $MIN_INT $MAX_INT]
    list [scan $scanstring {%o %o %o} a b c] \
	[expr { $a == -1 }] [expr { $b == $MIN_INT }] [expr { $c == $MAX_INT }]
} {3 1 1 1}
test scan-4.63 {scanning of large and negative hex integers} {
    foreach { MIN_INT MAX_INT } [int_range] {}
    set scanstring [format {%x %x %x} -1 $MIN_INT $MAX_INT]
    list [scan $scanstring {%x %x %x} a b c] \
	[expr { $a == -1 }] [expr { $b == $MIN_INT }] [expr { $c == $MAX_INT }]
} {3 1 1 1}

# clean up from last two tests

catch {
    rename int_range {}
}

test scan-5.1 {integer scanning} {
    set a {}; set b {}; set c {}; set d {}
    list [scan "-20 1476 \n33 0" "%d %d %d %d" a b c d] $a $b $c $d
} {4 -20 1476 33 0}
test scan-5.2 {integer scanning} {
    set a {}; set b {}; set c {}
    list [scan "-45 16 7890 +10" "%2d %*d %10d %d" a b c] $a $b $c
} {3 -4 16 7890}
test scan-5.3 {integer scanning} {
    set a {}; set b {}; set c {}; set d {}
    list [scan "-45 16 +10 987" "%ld %d %ld %d" a b c d] $a $b $c $d
} {4 -45 16 10 987}
test scan-5.4 {integer scanning} {
    set a {}; set b {}; set c {}; set d {}
    list [scan "14 1ab 62 10" "%d %x %lo %x" a b c d] $a $b $c $d
} {4 14 427 50 16}
test scan-5.5 {integer scanning} {
    set a {}; set b {}; set c {}; set d {}
    list [scan "12345670 1234567890ab cdefg" "%o	 %o %x %lx" a b c d] \
	    $a $b $c $d
} {4 2739128 342391 561323 52719}
test scan-5.6 {integer scanning} {
    set a {}; set b {}; set c {}; set d {}
    list [scan "ab123-24642" "%2x %3x %3o %2o" a b c d] $a $b $c $d
} {4 171 291 -20 52}
test scan-5.7 {integer scanning} {
    set a {}; set b {}
    list [scan "1234567 234 567  " "%*3x %x %*o %4o" a b] $a $b
} {2 17767 375}
test scan-5.8 {integer scanning} {
    set a {}; set b {}
    list [scan "a	1234" "%d %d" a b] $a $b
} {0 {} {}}
test scan-5.9 {integer scanning} {
    set a {}; set b {}; set c {}; set d {};
    list [scan "12345678" "%2d %2d %2ld %2d" a b c d] $a $b $c $d
} {4 12 34 56 78}
test scan-5.10 {integer scanning} {
    set a {}; set b {}; set c {}; set d {}
    list [scan "1 2 " "%hd %d %d %d" a b c d] $a $b $c $d
} {2 1 2 {} {}}
#
# The behavior for scaning intergers larger than MAX_INT is
# not defined by the ANSI spec.  Some implementations wrap the
# input (-16) some return MAX_INT.
#
test scan-5.11 {integer scanning} {nonPortable} {
    set a {}; set b {};
    list [scan "4294967280 4294967280" "%u %d" a b] $a \
	    [expr {$b == -16 || $b == 0x7fffffff}]
} {2 4294967280 1}

test scan-5.12 {integer scanning} {64bitInts} {
    set a {}; set b {}; set c {}
    list [scan "7810179016327718216,6c63546f6c6c6548,661432506755433062510" \
	    %ld,%lx,%lo a b c] $a $b $c
} {3 7810179016327718216 7810179016327718216 7810179016327718216}

test scan-6.1 {floating-point scanning} {
    set a {}; set b {}; set c {}; set d {}
    list [scan "2.1 -3.0e8 .99962 a" "%f%g%e%f" a b c d] $a $b $c $d
} {3 2.1 -300000000.0 0.99962 {}}
test scan-6.2 {floating-point scanning} {
    set a {}; set b {}; set c {}; set d {}
    list [scan "-1.2345 +8.2 9" "%3e %3lf %f %f" a b c d] $a $b $c $d
} {4 -1.0 234.0 5.0 8.2}
test scan-6.3 {floating-point scanning} {
    set a {}; set b {}; set c {}
    list [scan "1e00004 332E-4 3e+4" "%Lf %*2e %f %f" a b c] $a $c
} {3 10000.0 30000.0}
#
# Some libc implementations consider 3.e- bad input.  The ANSI
# spec states that digits must follow the - sign.
#
test scan-6.4 {floating-point scanning} {
    set a {}; set b {}; set c {}
    list [scan "1. 47.6 2.e2 3.e-" "%f %*f %f %f" a b c] $a $b $c
} {3 1.0 200.0 3.0}
test scan-6.5 {floating-point scanning} {
    set a {}; set b {}; set c {}; set d {}
    list [scan "4.6 99999.7 876.43e-1 118" "%f %f %f %e" a b c d] $a $b $c $d
} {4 4.6 99999.7 87.643 118.0}
test scan-6.6 {floating-point scanning} {eformat} {
    set a {}; set b {}; set c {}; set d {}
    list [scan "1.2345 697.0e-3 124 .00005" "%f %e %f %e" a b c d] $a $b $c $d
} {4 1.2345 0.697 124.0 5e-05}
test scan-6.7 {floating-point scanning} {
    set a {}; set b {}; set c {}; set d {}
    list [scan "4.6abc" "%f %f %f %f" a b c d] $a $b $c $d
} {1 4.6 {} {} {}}
test scan-6.8 {floating-point scanning} {
    set a {}; set b {}; set c {}; set d {}
    list [scan "4.6 5.2" "%f %f %f %f" a b c d] $a $b $c $d
} {2 4.6 5.2 {} {}}

test scan-7.1 {string and character scanning} {
    set a {}; set b {}; set c {}; set d {}
    list [scan "abc defghijk dum " "%s %3s %20s %s" a b c d] $a $b $c $d
} {4 abc def ghijk dum}
test scan-7.2 {string and character scanning} {
    set a {}; set b {}; set c {}; set d {}
    list [scan "a       bcdef" "%c%c%1s %s" a b c d] $a $b $c $d
} {4 97 32 b cdef}
test scan-7.3 {string and character scanning} {
    set a {}; set b {}; set c {}
    list [scan "123456 test " "%*c%*s %s %s %s" a b c] $a $b $c
} {1 test {} {}}
test scan-7.4 {string and character scanning} {
    set a {}; set b {}; set c {}; set d
    list [scan "ababcd01234  f 123450" {%4[abcd] %4[abcd] %[^abcdef] %[^0]} a b c d] $a $b $c $d
} {4 abab cd {01234  } {f 12345}}
test scan-7.5 {string and character scanning} {
    set a {}; set b {}; set c {}
    list [scan "aaaaaabc aaabcdefg  + +  XYZQR" {%*4[a] %s %*4[a]%s%*4[ +]%c} a b c] $a $b $c
} {3 aabc bcdefg 43}
test scan-7.6 {string and character scanning, unicode} {
    set a {}; set b {}; set c {}; set d {}
    list [scan "abc d\u00c7fghijk dum " "%s %3s %20s %s" a b c d] $a $b $c $d
} "4 abc d\u00c7f ghijk dum"
test scan-7.7 {string and character scanning, unicode} {
    set a {}; set b {}
    list [scan "ab\u00c7cdef" "ab%c%c" a b] $a $b
} "2 199 99"
test scan-7.8 {string and character scanning, unicode} {
    set a {}; set b {}
    list [scan "ab\ufeffdef" "%\[ab\ufeff\]" a] $a
} "1 ab\ufeff"

test scan-8.1 {error conditions} {
    catch {scan a}
} 1
test scan-8.2 {error conditions} {
    catch {scan a} msg
    set msg
} {wrong # args: should be "scan string format ?varName varName ...?"}
test scan-8.3 {error conditions} {
    list [catch {scan a %D x} msg] $msg
} {1 {bad scan conversion character "D"}}
test scan-8.4 {error conditions} {
    list [catch {scan a %O x} msg] $msg
} {1 {bad scan conversion character "O"}}
test scan-8.5 {error conditions} {
    list [catch {scan a %X x} msg] $msg
} {1 {bad scan conversion character "X"}}
test scan-8.6 {error conditions} {
    list [catch {scan a %F x} msg] $msg
} {1 {bad scan conversion character "F"}}
test scan-8.7 {error conditions} {
    list [catch {scan a %E x} msg] $msg
} {1 {bad scan conversion character "E"}}
test scan-8.8 {error conditions} {
    list [catch {scan a "%d %d" a} msg] $msg
} {1 {different numbers of variable names and field specifiers}}
test scan-8.9 {error conditions} {
    list [catch {scan a "%d %d" a b c} msg] $msg
} {1 {variable is not assigned by any conversion specifiers}}
test scan-8.10 {error conditions} {
    set a {}; set b {}; set c {}; set d {}
    list [expr {[scan "  a" " a %d %d %d %d" a b c d] <= 0}] $a $b $c $d
} {1 {} {} {} {}}
test scan-8.11 {error conditions} {
    set a {}; set b {}; set c {}; set d {}
    list [scan "1 2" "%d %d %d %d" a b c d] $a $b $c $d
} {2 1 2 {} {}}
test scan-8.12 {error conditions} {
    catch {unset a}
    set a(0) 44
    list [catch {scan 44 %d a} msg] $msg
} {1 {couldn't set variable "a"}}
test scan-8.13 {error conditions} {
    catch {unset a}
    set a(0) 44
    list [catch {scan 44 %c a} msg] $msg
} {1 {couldn't set variable "a"}}
test scan-8.14 {error conditions} {
    catch {unset a}
    set a(0) 44
    list [catch {scan 44 %s a} msg] $msg
} {1 {couldn't set variable "a"}}
test scan-8.15 {error conditions} {
    catch {unset a}
    set a(0) 44
    list [catch {scan 44 %f a} msg] $msg
} {1 {couldn't set variable "a"}}
test scan-8.16 {error conditions} {
    catch {unset a}
    set a(0) 44
    list [catch {scan 44 %f a} msg] $msg
} {1 {couldn't set variable "a"}}
catch {unset a}
test scan-8.17 {error conditions} {
    list [catch {scan 44 %2c a} msg] $msg
} {1 {field width may not be specified in %c conversion}}
test scan-8.18 {error conditions} {
    list [catch {scan abc {%[} x} msg] $msg
} {1 {unmatched [ in format string}}
test scan-8.19 {error conditions} {
    list [catch {scan abc {%[^a} x} msg] $msg
} {1 {unmatched [ in format string}}
test scan-8.20 {error conditions} {
    list [catch {scan abc {%[^]a} x} msg] $msg
} {1 {unmatched [ in format string}}
test scan-8.21 {error conditions} {
    list [catch {scan abc {%[]a} x} msg] $msg
} {1 {unmatched [ in format string}}

test scan-9.1 {lots of arguments} {
    scan "10 20 30 40 50 60 70 80 90 100 110 120 130 140 150 160 170 180 190 200" "%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d" a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a15 a16 a17 a18 a19 a20
} 20
test scan-9.2 {lots of arguments} {
    scan "10 20 30 40 50 60 70 80 90 100 110 120 130 140 150 160 170 180 190 200" "%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d" a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a15 a16 a17 a18 a19 a20
    set a20
} 200

test scan-10.1 {miscellaneous tests} {
    set a {}
    list [scan ab16c ab%dc a] $a
} {1 16}
test scan-10.2 {miscellaneous tests} {
    set a {}
    list [scan ax16c ab%dc a] $a
} {0 {}}
test scan-10.3 {miscellaneous tests} {
    set a {}
    list [catch {scan ab%c114 ab%%c%d a} msg] $msg $a
} {0 1 114}
test scan-10.4 {miscellaneous tests} {
    set a {}
    list [catch {scan ab%c14 ab%%c%d a} msg] $msg $a
} {0 1 14}
test scan-10.5 {miscellaneous tests} {
    catch {unset arr}
    set arr(2) {}
    list [catch {scan ab%c14 ab%%c%d arr(2)} msg] $msg $arr(2)
} {0 1 14}

test scan-11.1 {alignment in results array (TCL_ALIGN)} {
    scan "123 13.6" "%s %f" a b
    set b
} 13.6
test scan-11.2 {alignment in results array (TCL_ALIGN)} {
    scan "1234567 13.6" "%s %f" a b
    set b
} 13.6
test scan-11.3 {alignment in results array (TCL_ALIGN)} {
    scan "12345678901 13.6" "%s %f" a b
    set b
} 13.6
test scan-11.4 {alignment in results array (TCL_ALIGN)} {
    scan "123456789012345 13.6" "%s %f" a b
    set b
} 13.6
test scan-11.5 {alignment in results array (TCL_ALIGN)} {
    scan "1234567890123456789 13.6" "%s %f" a b
    set b
} 13.6

test scan-12.1 {Tcl_ScanObjCmd, inline case} {
    scan a %c
} 97
test scan-12.2 {Tcl_ScanObjCmd, inline case} {
    scan abc %c%c%c%c
} {97 98 99 {}}
test scan-12.3 {Tcl_ScanObjCmd, inline case} {
    scan abc %s%c
} {abc {}}
test scan-12.4 {Tcl_ScanObjCmd, inline case, underflow} {
    scan abc abc%c
} {}
test scan-12.5 {Tcl_ScanObjCmd, inline case} {
    scan abc bogus%c%c%c
} {{} {} {}}
test scan-12.6 {Tcl_ScanObjCmd, inline case} {
    # degenerate case, behavior changed from 8.2 to 8.3
    list [catch {scan foo foobar} msg] $msg
} {0 {}}
test scan-12.7 {Tcl_ScanObjCmd, inline case lots of arguments} {
    scan "10 20 30 40 50 60 70 80 90 100 110 120 130 140\
	    150 160 170 180 190 200" \
	    "%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d"
} {10 20 30 40 50 60 70 80 90 100 110 120 130 140 150 160 170 180 190 200 {}}

test scan-13.1 {Tcl_ScanObjCmd, inline XPG case} {
    scan a {%1$c}
} 97
test scan-13.2 {Tcl_ScanObjCmd, inline XPG case} {
    scan abc {%1$c%2$c%3$c%4$c}
} {97 98 99 {}}
test scan-13.3 {Tcl_ScanObjCmd, inline XPG case} {
    list [catch {scan abc {%1$c%1$c}} msg] $msg
} {1 {variable is assigned by multiple "%n$" conversion specifiers}}
test scan-13.4 {Tcl_ScanObjCmd, inline XPG case} {
    scan abc {%2$s%1$c}
} {{} abc}
test scan-13.5 {Tcl_ScanObjCmd, inline XPG case, underflow} {
    scan abc {abc%5$c}
} {}
test scan-13.6 {Tcl_ScanObjCmd, inline XPG case} {
    catch {scan abc {bogus%1$c%5$c%10$c}} msg
    list [llength $msg] $msg
} {10 {{} {} {} {} {} {} {} {} {} {}}}
test scan-13.7 {Tcl_ScanObjCmd, inline XPG case lots of arguments} {
    scan "10 20 30 40 50 60 70 80 90 100 110 120 130 140 150 160 170 180 190 200" {%20$d %18$d %17$d %16$d %15$d %14$d %13$d %12$d %11$d %10$d %9$d %8$d %7$d %6$d %5$d %4$d %3$d %2$d %1$d}
} {190 180 170 160 150 140 130 120 110 100 90 80 70 60 50 40 30 20 {} 10}
test scan-13.8 {Tcl_ScanObjCmd, inline XPG case lots of arguments} {
    set msg [scan "10 20 30" {%100$d %5$d %200$d}]
    list [llength $msg] [lindex $msg 99] [lindex $msg 4] [lindex $msg 199]
} {200 10 20 30}

# cleanup
::tcltest::cleanupTests
return
@


1.4
log
@touched all sources to ease next import
@
text
@d14 1
a14 1
# RCS: @@(#) $Id: scan.test,v 1.6.8.2 2000/09/15 16:57:29 spolk Exp $
d17 1
a17 1
    package require tcltest
d21 2
d236 3
d241 9
a249 1
} {3 11259375 11259375 0}
d340 29
d421 6
a680 15















@


1.3
log
@touched all sources to ease next import
@
text
@@


1.3.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d14 1
a14 1
# RCS: @@(#) $Id: scan.test,v 1.14 2002/06/22 04:19:47 dgp Exp $
d17 1
a17 1
    package require tcltest 2
a20 2
::tcltest::testConstraint 64bitInts [expr {0x80000000 > 0}]

a233 3
    # The behavior changed in 8.4a4/8.3.4cvs (6 Feb) to correctly
    # return '1' for 0x1 scanned via %x, to comply with 8.0 and C scanf.
    # Bug #495213
d236 1
a236 9
} {3 11259375 11259375 1}
test scan-4.40.1 {Tcl_ScanObjCmd, base-16 integer scanning} {
    set x {}
    list [scan {0xF 0x00A0B 0X0XF} {%x %x %x} x y z] $x $y $z
} {3 15 2571 0}
test scan-4.40.2 {Tcl_ScanObjCmd, base-16 integer scanning} {
    catch {unset x}
    list [scan {xF} {%x} x] [info exists x]
} {0 0}
a326 29
# procedure that returns the range of integers

proc int_range {} {
    for { set MIN_INT 1 } { $MIN_INT > 0 } {} {
	set MIN_INT [expr { $MIN_INT << 1 }]
    }
    set MAX_INT [expr { ~ $MIN_INT }]
    return [list $MIN_INT $MAX_INT]
}

test scan-4.62 {scanning of large and negative octal integers} {
    foreach { MIN_INT MAX_INT } [int_range] {}
    set scanstring [format {%o %o %o} -1 $MIN_INT $MAX_INT]
    list [scan $scanstring {%o %o %o} a b c] \
	[expr { $a == -1 }] [expr { $b == $MIN_INT }] [expr { $c == $MAX_INT }]
} {3 1 1 1}
test scan-4.63 {scanning of large and negative hex integers} {
    foreach { MIN_INT MAX_INT } [int_range] {}
    set scanstring [format {%x %x %x} -1 $MIN_INT $MAX_INT]
    list [scan $scanstring {%x %x %x} a b c] \
	[expr { $a == -1 }] [expr { $b == $MIN_INT }] [expr { $c == $MAX_INT }]
} {3 1 1 1}

# clean up from last two tests

catch {
    rename int_range {}
}

a378 6
test scan-5.12 {integer scanning} {64bitInts} {
    set a {}; set b {}; set c {}
    list [scan "7810179016327718216,6c63546f6c6c6548,661432506755433062510" \
	    %ld,%lx,%lo a b c] $a $b $c
} {3 7810179016327718216 7810179016327718216 7810179016327718216}

d633 15
@


1.3.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@d14 1
a14 1
# RCS: @@(#) $Id: scan.test,v 1.14 2002/06/22 04:19:47 dgp Exp $
d17 1
a17 1
    package require tcltest 2
a20 2
::tcltest::testConstraint 64bitInts [expr {0x80000000 > 0}]

a233 3
    # The behavior changed in 8.4a4/8.3.4cvs (6 Feb) to correctly
    # return '1' for 0x1 scanned via %x, to comply with 8.0 and C scanf.
    # Bug #495213
d236 1
a236 9
} {3 11259375 11259375 1}
test scan-4.40.1 {Tcl_ScanObjCmd, base-16 integer scanning} {
    set x {}
    list [scan {0xF 0x00A0B 0X0XF} {%x %x %x} x y z] $x $y $z
} {3 15 2571 0}
test scan-4.40.2 {Tcl_ScanObjCmd, base-16 integer scanning} {
    catch {unset x}
    list [scan {xF} {%x} x] [info exists x]
} {0 0}
a326 29
# procedure that returns the range of integers

proc int_range {} {
    for { set MIN_INT 1 } { $MIN_INT > 0 } {} {
	set MIN_INT [expr { $MIN_INT << 1 }]
    }
    set MAX_INT [expr { ~ $MIN_INT }]
    return [list $MIN_INT $MAX_INT]
}

test scan-4.62 {scanning of large and negative octal integers} {
    foreach { MIN_INT MAX_INT } [int_range] {}
    set scanstring [format {%o %o %o} -1 $MIN_INT $MAX_INT]
    list [scan $scanstring {%o %o %o} a b c] \
	[expr { $a == -1 }] [expr { $b == $MIN_INT }] [expr { $c == $MAX_INT }]
} {3 1 1 1}
test scan-4.63 {scanning of large and negative hex integers} {
    foreach { MIN_INT MAX_INT } [int_range] {}
    set scanstring [format {%x %x %x} -1 $MIN_INT $MAX_INT]
    list [scan $scanstring {%x %x %x} a b c] \
	[expr { $a == -1 }] [expr { $b == $MIN_INT }] [expr { $c == $MAX_INT }]
} {3 1 1 1}

# clean up from last two tests

catch {
    rename int_range {}
}

a378 6
test scan-5.12 {integer scanning} {64bitInts} {
    set a {}; set b {}; set c {}
    list [scan "7810179016327718216,6c63546f6c6c6548,661432506755433062510" \
	    %ld,%lx,%lo a b c] $a $b $c
} {3 7810179016327718216 7810179016327718216 7810179016327718216}

d633 15
@


1.2
log
@touched all Tcl files to ease next import.
@
text
@@


1.2.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.2.16.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d17 1
a17 1
    package require tcltest 2
a20 2
::tcltest::testConstraint 64bitInts [expr {0x80000000 > 0}]

a233 3
    # The behavior changed in 8.4a4/8.3.4cvs (6 Feb) to correctly
    # return '1' for 0x1 scanned via %x, to comply with 8.0 and C scanf.
    # Bug #495213
d236 1
a236 9
} {3 11259375 11259375 1}
test scan-4.40.1 {Tcl_ScanObjCmd, base-16 integer scanning} {
    set x {}
    list [scan {0xF 0x00A0B 0X0XF} {%x %x %x} x y z] $x $y $z
} {3 15 2571 0}
test scan-4.40.2 {Tcl_ScanObjCmd, base-16 integer scanning} {
    catch {unset x}
    list [scan {xF} {%x} x] [info exists x]
} {0 0}
a326 29
# procedure that returns the range of integers

proc int_range {} {
    for { set MIN_INT 1 } { $MIN_INT > 0 } {} {
	set MIN_INT [expr { $MIN_INT << 1 }]
    }
    set MAX_INT [expr { ~ $MIN_INT }]
    return [list $MIN_INT $MAX_INT]
}

test scan-4.62 {scanning of large and negative octal integers} {
    foreach { MIN_INT MAX_INT } [int_range] {}
    set scanstring [format {%o %o %o} -1 $MIN_INT $MAX_INT]
    list [scan $scanstring {%o %o %o} a b c] \
	[expr { $a == -1 }] [expr { $b == $MIN_INT }] [expr { $c == $MAX_INT }]
} {3 1 1 1}
test scan-4.63 {scanning of large and negative hex integers} {
    foreach { MIN_INT MAX_INT } [int_range] {}
    set scanstring [format {%x %x %x} -1 $MIN_INT $MAX_INT]
    list [scan $scanstring {%x %x %x} a b c] \
	[expr { $a == -1 }] [expr { $b == $MIN_INT }] [expr { $c == $MAX_INT }]
} {3 1 1 1}

# clean up from last two tests

catch {
    rename int_range {}
}

a378 6
test scan-5.12 {integer scanning} {64bitInts} {
    set a {}; set b {}; set c {}
    list [scan "7810179016327718216,6c63546f6c6c6548,661432506755433062510" \
	    %ld,%lx,%lo a b c] $a $b $c
} {3 7810179016327718216 7810179016327718216 7810179016327718216}

d633 15
@


1.1
log
@Initial revision
@
text
@d9 1
d14 1
a14 1
# RCS: @@(#) $Id: scan.test,v 1.3 1998/11/02 23:04:14 stanton Exp $
d16 4
a19 1
if {[string compare test [info procs test]] == 1} then {source defs}
d21 307
a327 1
test scan-1.1 {integer scanning} {
d331 1
a331 1
test scan-1.2 {integer scanning} {
d335 1
a335 1
test scan-1.3 {integer scanning} {
d339 1
a339 1
test scan-1.4 {integer scanning} {
d343 1
a343 1
test scan-1.5 {integer scanning} {
d348 1
a348 1
test scan-1.6 {integer scanning} {
d352 1
a352 1
test scan-1.7 {integer scanning} {
d356 1
a356 1
test scan-1.8 {integer scanning} {
d360 1
a360 1
test scan-1.9 {integer scanning} {
d364 1
a364 1
test scan-1.10 {integer scanning} {
d373 1
a373 1
test scan-1.11 {integer scanning} {nonPortable} {
d375 3
a377 2
    list [scan "4294967280 4294967280" "%u %d" a b] $a $b
} {2 4294967280 -16}
d379 1
a379 1
test scan-2.1 {floating-point scanning} {
d383 1
a383 1
test scan-2.2 {floating-point scanning} {
d387 1
a387 1
test scan-2.3 {floating-point scanning} {
d395 1
a395 1
test scan-2.4 {floating-point scanning} {nonPortable} {
d399 1
a399 1
test scan-2.5 {floating-point scanning} {
d403 1
a403 1
test scan-2.6 {floating-point scanning} {eformat} {
d407 1
a407 1
test scan-2.7 {floating-point scanning} {
d411 1
a411 1
test scan-2.8 {floating-point scanning} {
d416 1
a416 1
test scan-3.1 {string and character scanning} {
d420 1
a420 1
test scan-3.2 {string and character scanning} {
d424 1
a424 1
test scan-3.3 {string and character scanning} {
d428 1
a428 1
test scan-3.4 {string and character scanning} {
d432 1
a432 1
test scan-3.5 {string and character scanning} {
d436 12
d449 1
a449 1
test scan-4.1 {error conditions} {
d452 1
a452 1
test scan-4.2 {error conditions} {
d456 2
a457 9
test scan-4.3 {error conditions} {
    catch {scan "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21" "%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d" a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a15 a16 a17 a18 a19 a20 a21}
} 1
test scan-4.4 {error conditions} {
    catch {scan "1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21" "%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d" a1 a2 a3 a4 a5 a6 a7 a8 a9 a10 a11 a12 a13 a14 a15 a16 a17 a18 a19 a20 a21} msg
    set msg
} {too many fields to scan}
test scan-4.5 {error conditions} {
    list [catch {scan a %D} msg] $msg
d459 2
a460 2
test scan-4.6 {error conditions} {
    list [catch {scan a %O} msg] $msg
d462 2
a463 2
test scan-4.7 {error conditions} {
    list [catch {scan a %X} msg] $msg
d465 2
a466 2
test scan-4.8 {error conditions} {
    list [catch {scan a %F} msg] $msg
d468 2
a469 2
test scan-4.9 {error conditions} {
    list [catch {scan a %E} msg] $msg
d471 1
a471 1
test scan-4.10 {error conditions} {
d474 1
a474 1
test scan-4.11 {error conditions} {
d476 2
a477 2
} {1 {different numbers of variable names and field specifiers}}
test scan-4.12 {error conditions} {
d481 1
a481 1
test scan-4.13 {error conditions} {
d485 1
a485 1
test scan-4.14 {error conditions} {
d490 1
a490 1
test scan-4.15 {error conditions} {
d495 1
a495 1
test scan-4.16 {error conditions} {
d500 1
a500 1
test scan-4.17 {error conditions} {
d505 1
a505 1
test scan-4.18 {error conditions} {
d511 1
a511 1
test scan-4.19 {error conditions} {
d514 11
a524 2
test scan-4.20 {error conditions} {
    list [catch {scan abc {%[}} msg] $msg
d527 1
a527 1
test scan-5.1 {lots of arguments} {
d530 1
a530 1
test scan-5.2 {lots of arguments} {
d535 1
a535 1
test scan-6.1 {miscellaneous tests} {
d539 1
a539 1
test scan-6.2 {miscellaneous tests} {
d543 1
a543 1
test scan-6.3 {miscellaneous tests} {
d547 1
a547 1
test scan-6.4 {miscellaneous tests} {
d551 5
d557 1
a557 1
test scan-7.1 {alignment in results array (TCL_ALIGN)} {
d561 1
a561 1
test scan-7.2 {alignment in results array (TCL_ALIGN)} {
d565 1
a565 1
test scan-7.3 {alignment in results array (TCL_ALIGN)} {
d569 1
a569 1
test scan-7.4 {alignment in results array (TCL_ALIGN)} {
d573 1
a573 1
test scan-7.5 {alignment in results array (TCL_ALIGN)} {
d577 71
@


1.1.1.1
log
@import dejagnu-1999-11-08 snapshot
@
text
@@


1.1.1.2
log
@Tcl 8.3 upgrade
@
text
@a8 1
# Copyright (c) 1998-1999 by Scriptics Corporation.
d13 1
a13 1
# RCS: @@(#) $Id: scan.test,v 1.6.8.2 2000/09/15 16:57:29 spolk Exp $
d15 1
a15 4
if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import -force ::tcltest::*
}
d17 1
a17 307
test scan-1.1 {BuildCharSet, CharInSet} {
    list [scan foo {%[^o]} x] $x
} {1 f}
test scan-1.2 {BuildCharSet, CharInSet} {
    list [scan \]foo {%[]f]} x] $x
} {1 \]f}
test scan-1.3 {BuildCharSet, CharInSet} {
    list [scan abc-def {%[a-c]} x] $x
} {1 abc}
test scan-1.4 {BuildCharSet, CharInSet} {
    list [scan abc-def {%[a-c]} x] $x
} {1 abc}
test scan-1.5 {BuildCharSet, CharInSet} {
    list [scan -abc-def {%[-ac]} x] $x
} {1 -a}
test scan-1.6 {BuildCharSet, CharInSet} {
    list [scan -abc-def {%[ac-]} x] $x
} {1 -a}
test scan-1.7 {BuildCharSet, CharInSet} {
    list [scan abc-def {%[c-a]} x] $x
} {1 abc}
test scan-1.8 {BuildCharSet, CharInSet} {
    list [scan def-abc {%[^c-a]} x] $x
} {1 def-}
test scan-1.9 {BuildCharSet, CharInSet no match} {
    catch {unset x}
    list [scan {= f} {= %[TF]} x] [info exists x]
} {0 0}

test scan-2.1 {ReleaseCharSet} {
    list [scan abcde {%[abc]} x] $x
} {1 abc}
test scan-2.2 {ReleaseCharSet} {
    list [scan abcde {%[a-c]} x] $x
} {1 abc}

test scan-3.1 {ValidateFormat} {
    list [catch {scan {} {%d%1$d} x} msg] $msg
} {1 {cannot mix "%" and "%n$" conversion specifiers}}
test scan-3.2 {ValidateFormat} {
    list [catch {scan {} {%d%1$d} x} msg] $msg
} {1 {cannot mix "%" and "%n$" conversion specifiers}}
test scan-3.3 {ValidateFormat} {
    list [catch {scan {} {%2$d%d} x} msg] $msg
} {1 {"%n$" argument index out of range}}
test scan-3.4 {ValidateFormat} {
    # degenerate case, before changed from 8.2 to 8.3
    list [catch {scan {} %d} msg] $msg
} {0 {}}
test scan-3.5 {ValidateFormat} {
    list [catch {scan {} {%10c} a} msg] $msg
} {1 {field width may not be specified in %c conversion}}
test scan-3.6 {ValidateFormat} {
    list [catch {scan {} {%*1$d} a} msg] $msg
} {1 {bad scan conversion character "$"}}
test scan-3.7 {ValidateFormat} {
    list [catch {scan {} {%1$d%1$d} a} msg] $msg
} {1 {variable is assigned by multiple "%n$" conversion specifiers}}
test scan-3.8 {ValidateFormat} {
    list [catch {scan {} a x} msg] $msg
} {1 {variable is not assigned by any conversion specifiers}}
test scan-3.9 {ValidateFormat} {
    list [catch {scan {} {%2$s} x y} msg] $msg
} {1 {variable is not assigned by any conversion specifiers}}
test scan-3.10 {ValidateFormat} {
    list [catch {scan {} {%[a} x} msg] $msg
} {1 {unmatched [ in format string}}
test scan-3.11 {ValidateFormat} {
    list [catch {scan {} {%[^a} x} msg] $msg
} {1 {unmatched [ in format string}}
test scan-3.12 {ValidateFormat} {
    list [catch {scan {} {%[]a} x} msg] $msg
} {1 {unmatched [ in format string}}
test scan-3.13 {ValidateFormat} {
    list [catch {scan {} {%[^]a} x} msg] $msg
} {1 {unmatched [ in format string}}

test scan-4.1 {Tcl_ScanObjCmd, argument checks} {
    list [catch {scan} msg] $msg
} {1 {wrong # args: should be "scan string format ?varName varName ...?"}}
test scan-4.2 {Tcl_ScanObjCmd, argument checks} {
    list [catch {scan string} msg] $msg
} {1 {wrong # args: should be "scan string format ?varName varName ...?"}}
test scan-4.3 {Tcl_ScanObjCmd, argument checks} {
    # degenerate case, before changed from 8.2 to 8.3
    list [catch {scan string format} msg] $msg
} {0 {}}
test scan-4.4 {Tcl_ScanObjCmd, whitespace} {
    list [scan {   abc   def   } {%s%s} x y] $x $y
} {2 abc def}
test scan-4.5 {Tcl_ScanObjCmd, whitespace} {
    list [scan {   abc   def   } { %s %s } x y] $x $y
} {2 abc def}
test scan-4.6 {Tcl_ScanObjCmd, whitespace} {
    list [scan {   abc   def   } { %s %s } x y] $x $y
} {2 abc def}
test scan-4.7 {Tcl_ScanObjCmd, literals} {
    # degenerate case, before changed from 8.2 to 8.3
    scan {   abc   def   } { abc def }
} {}
test scan-4.8 {Tcl_ScanObjCmd, literals} {
    set x {}
    list [scan {   abcg} { abc def %1s} x] $x
} {0 {}}
test scan-4.9 {Tcl_ScanObjCmd, literals} {
    list [scan {   abc%defghi} { abc %% def%n } x] $x
} {1 10}
test scan-4.10 {Tcl_ScanObjCmd, assignment suppression} {
    list [scan {   abc   def   } { %*c%s def } x] $x
} {1 bc}
test scan-4.11 {Tcl_ScanObjCmd, XPG3-style} {
    list [scan {   abc   def   } {%2$s %1$s} x y] $x $y
} {2 def abc}
test scan-4.12 {Tcl_ScanObjCmd, width specifiers} {
    list [scan {abc123456789012} {%3s%3d%3f%3[0-9]%s} a b c d e] $a $b $c $d $e
} {5 abc 123 456.0 789 012}
test scan-4.13 {Tcl_ScanObjCmd, width specifiers} {
    list [scan {abc123456789012} {%3s%3d%3f%3[0-9]%s} a b c d e] $a $b $c $d $e
} {5 abc 123 456.0 789 012}
test scan-4.14 {Tcl_ScanObjCmd, underflow} {
    set x {}
    list [scan {a} {a%d} x] $x
} {-1 {}}
test scan-4.15 {Tcl_ScanObjCmd, underflow} {
    set x {}
    list [scan {} {a%d} x] $x
} {-1 {}}
test scan-4.16 {Tcl_ScanObjCmd, underflow} {
    set x {}
    list [scan {ab} {a%d} x] $x
} {0 {}}
test scan-4.17 {Tcl_ScanObjCmd, underflow} {
    set x {}
    list [scan {a   } {a%d} x] $x
} {-1 {}}
test scan-4.18 {Tcl_ScanObjCmd, skipping whitespace} {
    list [scan {  b} {%c%s} x y] $x $y
} {2 32 b}
test scan-4.19 {Tcl_ScanObjCmd, skipping whitespace} {
    list [scan {  b} {%[^b]%s} x y] $x $y
} {2 {  } b}
test scan-4.20 {Tcl_ScanObjCmd, string scanning} {
    list [scan {abc def} {%s} x] $x
} {1 abc}
test scan-4.21 {Tcl_ScanObjCmd, string scanning} {
    list [scan {abc def} {%0s} x] $x
} {1 abc}
test scan-4.22 {Tcl_ScanObjCmd, string scanning} {
    list [scan {abc def} {%2s} x] $x
} {1 ab}
test scan-4.23 {Tcl_ScanObjCmd, string scanning} {
    list [scan {abc def} {%*s%n} x] $x
} {1 3}
test scan-4.24 {Tcl_ScanObjCmd, charset scanning} {
    list [scan {abcdef} {%[a-c]} x] $x
} {1 abc}
test scan-4.25 {Tcl_ScanObjCmd, charset scanning} {
    list [scan {abcdef} {%0[a-c]} x] $x
} {1 abc}
test scan-4.26 {Tcl_ScanObjCmd, charset scanning} {
    list [scan {abcdef} {%2[a-c]} x] $x
} {1 ab}
test scan-4.27 {Tcl_ScanObjCmd, charset scanning} {
    list [scan {abcdef} {%*[a-c]%n} x] $x
} {1 3}
test scan-4.28 {Tcl_ScanObjCmd, character scanning} {
    list [scan {abcdef} {%c} x] $x
} {1 97}
test scan-4.29 {Tcl_ScanObjCmd, character scanning} {
    list [scan {abcdef} {%*c%n} x] $x
} {1 1}

test scan-4.30 {Tcl_ScanObjCmd, base-10 integer scanning} {
    set x {}
    list [scan {1234567890a} {%3d} x] $x
} {1 123}
test scan-4.31 {Tcl_ScanObjCmd, base-10 integer scanning} {
    set x {}
    list [scan {1234567890a} {%d} x] $x
} {1 1234567890}
test scan-4.32 {Tcl_ScanObjCmd, base-10 integer scanning} {
    set x {}
    list [scan {01234567890a} {%d} x] $x
} {1 1234567890}
test scan-4.33 {Tcl_ScanObjCmd, base-10 integer scanning} {
    set x {}
    list [scan {+01234} {%d} x] $x
} {1 1234}
test scan-4.34 {Tcl_ScanObjCmd, base-10 integer scanning} {
    set x {}
    list [scan {-01234} {%d} x] $x
} {1 -1234}
test scan-4.35 {Tcl_ScanObjCmd, base-10 integer scanning} {
    set x {}
    list [scan {a01234} {%d} x] $x
} {0 {}}
test scan-4.36 {Tcl_ScanObjCmd, base-10 integer scanning} {
    set x {}
    list [scan {0x10} {%d} x] $x
} {1 0}
test scan-4.37 {Tcl_ScanObjCmd, base-8 integer scanning} {
    set x {}
    list [scan {012345678} {%o} x] $x
} {1 342391}
test scan-4.38 {Tcl_ScanObjCmd, base-8 integer scanning} {
    set x {}
    list [scan {+1238 -1239 123a} {%o%*s%o%*s%o} x y z] $x $y $z
} {3 83 -83 83}
test scan-4.39 {Tcl_ScanObjCmd, base-16 integer scanning} {
    set x {}
    list [scan {+1238 -123a 0123} {%x%x%x} x y z] $x $y $z
} {3 4664 -4666 291}
test scan-4.40 {Tcl_ScanObjCmd, base-16 integer scanning} {
    set x {}
    list [scan {aBcDeF AbCdEf 0x1} {%x%x%x} x y z] $x $y $z
} {3 11259375 11259375 0}
test scan-4.41 {Tcl_ScanObjCmd, base-unknown integer scanning} {
    set x {}
    list [scan {10 010 0x10} {%i%i%i} x y z] $x $y $z
} {3 10 8 16}
test scan-4.42 {Tcl_ScanObjCmd, base-unknown integer scanning} {
    set x {}
    list [scan {10 010 0X10} {%i%i%i} x y z] $x $y $z
} {3 10 8 16}
test scan-4.43 {Tcl_ScanObjCmd, integer scanning, odd cases} {
    set x {}
    list [scan {+ } {%i} x] $x
} {0 {}}
test scan-4.44 {Tcl_ScanObjCmd, integer scanning, odd cases} {
    set x {}
    list [scan {+} {%i} x] $x
} {-1 {}}
test scan-4.45 {Tcl_ScanObjCmd, integer scanning, odd cases} {
    set x {}
    list [scan {0x} {%i%s} x y] $x $y
} {2 0 x}
test scan-4.46 {Tcl_ScanObjCmd, integer scanning, odd cases} {
    set x {}
    list [scan {0X} {%i%s} x y] $x $y
} {2 0 X}
test scan-4.47 {Tcl_ScanObjCmd, integer scanning, suppressed} {
    set x {}
    list [scan {123def} {%*i%s} x] $x
} {1 def}
test scan-4.48 {Tcl_ScanObjCmd, float scanning} {
    list [scan {1 2 3} {%e %f %g} x y z] $x $y $z
} {3 1.0 2.0 3.0}
test scan-4.49 {Tcl_ScanObjCmd, float scanning} {
    list [scan {.1 0.2 3.} {%e %f %g} x y z] $x $y $z
} {3 0.1 0.2 3.0}
test scan-4.50 {Tcl_ScanObjCmd, float scanning} {
    list [scan {1234567890a} %f x] $x
} {1 1234567890.0}
test scan-4.51 {Tcl_ScanObjCmd, float scanning} {
    list [scan {+123+45} %f x] $x
} {1 123.0}
test scan-4.52 {Tcl_ScanObjCmd, float scanning} {
    list [scan {-123+45} %f x] $x
} {1 -123.0}
test scan-4.53 {Tcl_ScanObjCmd, float scanning} {
    list [scan {1.0e1} %f x] $x
} {1 10.0}
test scan-4.54 {Tcl_ScanObjCmd, float scanning} {
    list [scan {1.0e-1} %f x] $x
} {1 0.1}
test scan-4.55 {Tcl_ScanObjCmd, odd cases} {
    set x {}
    list [scan {+} %f x] $x
} {-1 {}}
test scan-4.56 {Tcl_ScanObjCmd, odd cases} {
    set x {}
    list [scan {1.0e} %f%s x y] $x $y
} {2 1.0 e}
test scan-4.57 {Tcl_ScanObjCmd, odd cases} {
    set x {}
    list [scan {1.0e+} %f%s x y] $x $y
} {2 1.0 e+}
test scan-4.58 {Tcl_ScanObjCmd, odd cases} {
    set x {}
    set y {}
    list [scan {e1} %f%s x y] $x $y
} {0 {} {}}
test scan-4.59 {Tcl_ScanObjCmd, float scanning} {
    list [scan {1.0e-1x} %*f%n x] $x
} {1 6}

test scan-4.60 {Tcl_ScanObjCmd, set errors} {
    set x {}
    set y {}
    catch {unset z}; array set z {}
    set result [list [catch {scan {abc def ghi} {%s%s%s} x z y} msg] \
	    $msg $x $y]
    unset z
    set result
} {1 {couldn't set variable "z"} abc ghi}
test scan-4.61 {Tcl_ScanObjCmd, set errors} {
    set x {}
    catch {unset y}; array set y {}
    catch {unset z}; array set z {}
    set result [list [catch {scan {abc def ghi} {%s%s%s} x z y} msg] \
	    $msg $x]
    unset y
    unset z
    set result
} {1 {couldn't set variable "z"couldn't set variable "y"} abc}

test scan-5.1 {integer scanning} {
d21 1
a21 1
test scan-5.2 {integer scanning} {
d25 1
a25 1
test scan-5.3 {integer scanning} {
d29 1
a29 1
test scan-5.4 {integer scanning} {
d33 1
a33 1
test scan-5.5 {integer scanning} {
d38 1
a38 1
test scan-5.6 {integer scanning} {
d42 1
a42 1
test scan-5.7 {integer scanning} {
d46 1
a46 1
test scan-5.8 {integer scanning} {
d50 1
a50 1
test scan-5.9 {integer scanning} {
d54 1
a54 1
test scan-5.10 {integer scanning} {
d63 1
a63 1
test scan-5.11 {integer scanning} {nonPortable} {
d65 2
a66 3
    list [scan "4294967280 4294967280" "%u %d" a b] $a \
	    [expr {$b == -16 || $b == 0x7fffffff}]
} {2 4294967280 1}
d68 1
a68 1
test scan-6.1 {floating-point scanning} {
d72 1
a72 1
test scan-6.2 {floating-point scanning} {
d76 1
a76 1
test scan-6.3 {floating-point scanning} {
d84 1
a84 1
test scan-6.4 {floating-point scanning} {
d88 1
a88 1
test scan-6.5 {floating-point scanning} {
d92 1
a92 1
test scan-6.6 {floating-point scanning} {eformat} {
d96 1
a96 1
test scan-6.7 {floating-point scanning} {
d100 1
a100 1
test scan-6.8 {floating-point scanning} {
d105 1
a105 1
test scan-7.1 {string and character scanning} {
d109 1
a109 1
test scan-7.2 {string and character scanning} {
d113 1
a113 1
test scan-7.3 {string and character scanning} {
d117 1
a117 1
test scan-7.4 {string and character scanning} {
d121 1
a121 1
test scan-7.5 {string and character scanning} {
a124 12
test scan-7.6 {string and character scanning, unicode} {
    set a {}; set b {}; set c {}; set d {}
    list [scan "abc d\u00c7fghijk dum " "%s %3s %20s %s" a b c d] $a $b $c $d
} "4 abc d\u00c7f ghijk dum"
test scan-7.7 {string and character scanning, unicode} {
    set a {}; set b {}
    list [scan "ab\u00c7cdef" "ab%c%c" a b] $a $b
} "2 199 99"
test scan-7.8 {string and character scanning, unicode} {
    set a {}; set b {}
    list [scan "ab\ufeffdef" "%\[ab\ufeff\]" a] $a
} "1 ab\ufeff"
d126 1
a126 1
test scan-8.1 {error conditions} {
d129 1
a129 1
test scan-8.2 {error conditions} {
d133 9
a141 2
test scan-8.3 {error conditions} {
    list [catch {scan a %D x} msg] $msg
d143 2
a144 2
test scan-8.4 {error conditions} {
    list [catch {scan a %O x} msg] $msg
d146 2
a147 2
test scan-8.5 {error conditions} {
    list [catch {scan a %X x} msg] $msg
d149 2
a150 2
test scan-8.6 {error conditions} {
    list [catch {scan a %F x} msg] $msg
d152 2
a153 2
test scan-8.7 {error conditions} {
    list [catch {scan a %E x} msg] $msg
d155 1
a155 1
test scan-8.8 {error conditions} {
d158 1
a158 1
test scan-8.9 {error conditions} {
d160 2
a161 2
} {1 {variable is not assigned by any conversion specifiers}}
test scan-8.10 {error conditions} {
d165 1
a165 1
test scan-8.11 {error conditions} {
d169 1
a169 1
test scan-8.12 {error conditions} {
d174 1
a174 1
test scan-8.13 {error conditions} {
d179 1
a179 1
test scan-8.14 {error conditions} {
d184 1
a184 1
test scan-8.15 {error conditions} {
d189 1
a189 1
test scan-8.16 {error conditions} {
d195 1
a195 1
test scan-8.17 {error conditions} {
d198 2
a199 11
test scan-8.18 {error conditions} {
    list [catch {scan abc {%[} x} msg] $msg
} {1 {unmatched [ in format string}}
test scan-8.19 {error conditions} {
    list [catch {scan abc {%[^a} x} msg] $msg
} {1 {unmatched [ in format string}}
test scan-8.20 {error conditions} {
    list [catch {scan abc {%[^]a} x} msg] $msg
} {1 {unmatched [ in format string}}
test scan-8.21 {error conditions} {
    list [catch {scan abc {%[]a} x} msg] $msg
d202 1
a202 1
test scan-9.1 {lots of arguments} {
d205 1
a205 1
test scan-9.2 {lots of arguments} {
d210 1
a210 1
test scan-10.1 {miscellaneous tests} {
d214 1
a214 1
test scan-10.2 {miscellaneous tests} {
d218 1
a218 1
test scan-10.3 {miscellaneous tests} {
d222 1
a222 1
test scan-10.4 {miscellaneous tests} {
a225 5
test scan-10.5 {miscellaneous tests} {
    catch {unset arr}
    set arr(2) {}
    list [catch {scan ab%c14 ab%%c%d arr(2)} msg] $msg $arr(2)
} {0 1 14}
d227 1
a227 1
test scan-11.1 {alignment in results array (TCL_ALIGN)} {
d231 1
a231 1
test scan-11.2 {alignment in results array (TCL_ALIGN)} {
d235 1
a235 1
test scan-11.3 {alignment in results array (TCL_ALIGN)} {
d239 1
a239 1
test scan-11.4 {alignment in results array (TCL_ALIGN)} {
d243 1
a243 1
test scan-11.5 {alignment in results array (TCL_ALIGN)} {
a246 71

test scan-12.1 {Tcl_ScanObjCmd, inline case} {
    scan a %c
} 97
test scan-12.2 {Tcl_ScanObjCmd, inline case} {
    scan abc %c%c%c%c
} {97 98 99 {}}
test scan-12.3 {Tcl_ScanObjCmd, inline case} {
    scan abc %s%c
} {abc {}}
test scan-12.4 {Tcl_ScanObjCmd, inline case, underflow} {
    scan abc abc%c
} {}
test scan-12.5 {Tcl_ScanObjCmd, inline case} {
    scan abc bogus%c%c%c
} {{} {} {}}
test scan-12.6 {Tcl_ScanObjCmd, inline case} {
    # degenerate case, behavior changed from 8.2 to 8.3
    list [catch {scan foo foobar} msg] $msg
} {0 {}}
test scan-12.7 {Tcl_ScanObjCmd, inline case lots of arguments} {
    scan "10 20 30 40 50 60 70 80 90 100 110 120 130 140\
	    150 160 170 180 190 200" \
	    "%d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d %d"
} {10 20 30 40 50 60 70 80 90 100 110 120 130 140 150 160 170 180 190 200 {}}

test scan-13.1 {Tcl_ScanObjCmd, inline XPG case} {
    scan a {%1$c}
} 97
test scan-13.2 {Tcl_ScanObjCmd, inline XPG case} {
    scan abc {%1$c%2$c%3$c%4$c}
} {97 98 99 {}}
test scan-13.3 {Tcl_ScanObjCmd, inline XPG case} {
    list [catch {scan abc {%1$c%1$c}} msg] $msg
} {1 {variable is assigned by multiple "%n$" conversion specifiers}}
test scan-13.4 {Tcl_ScanObjCmd, inline XPG case} {
    scan abc {%2$s%1$c}
} {{} abc}
test scan-13.5 {Tcl_ScanObjCmd, inline XPG case, underflow} {
    scan abc {abc%5$c}
} {}
test scan-13.6 {Tcl_ScanObjCmd, inline XPG case} {
    catch {scan abc {bogus%1$c%5$c%10$c}} msg
    list [llength $msg] $msg
} {10 {{} {} {} {} {} {} {} {} {} {}}}
test scan-13.7 {Tcl_ScanObjCmd, inline XPG case lots of arguments} {
    scan "10 20 30 40 50 60 70 80 90 100 110 120 130 140 150 160 170 180 190 200" {%20$d %18$d %17$d %16$d %15$d %14$d %13$d %12$d %11$d %10$d %9$d %8$d %7$d %6$d %5$d %4$d %3$d %2$d %1$d}
} {190 180 170 160 150 140 130 120 110 100 90 80 70 60 50 40 30 20 {} 10}
test scan-13.8 {Tcl_ScanObjCmd, inline XPG case lots of arguments} {
    set msg [scan "10 20 30" {%100$d %5$d %200$d}]
    list [llength $msg] [lindex $msg 99] [lindex $msg 4] [lindex $msg 199]
} {200 10 20 30}

# cleanup
::tcltest::cleanupTests
return















@


1.1.1.3
log
@import tcl 8.4.0
@
text
@d14 1
a14 1
# RCS: @@(#) $Id: scan.test,v 1.14 2002/06/22 04:19:47 dgp Exp $
d17 1
a17 1
    package require tcltest 2
a20 2
::tcltest::testConstraint 64bitInts [expr {0x80000000 > 0}]

a233 3
    # The behavior changed in 8.4a4/8.3.4cvs (6 Feb) to correctly
    # return '1' for 0x1 scanned via %x, to comply with 8.0 and C scanf.
    # Bug #495213
d236 1
a236 9
} {3 11259375 11259375 1}
test scan-4.40.1 {Tcl_ScanObjCmd, base-16 integer scanning} {
    set x {}
    list [scan {0xF 0x00A0B 0X0XF} {%x %x %x} x y z] $x $y $z
} {3 15 2571 0}
test scan-4.40.2 {Tcl_ScanObjCmd, base-16 integer scanning} {
    catch {unset x}
    list [scan {xF} {%x} x] [info exists x]
} {0 0}
a326 29
# procedure that returns the range of integers

proc int_range {} {
    for { set MIN_INT 1 } { $MIN_INT > 0 } {} {
	set MIN_INT [expr { $MIN_INT << 1 }]
    }
    set MAX_INT [expr { ~ $MIN_INT }]
    return [list $MIN_INT $MAX_INT]
}

test scan-4.62 {scanning of large and negative octal integers} {
    foreach { MIN_INT MAX_INT } [int_range] {}
    set scanstring [format {%o %o %o} -1 $MIN_INT $MAX_INT]
    list [scan $scanstring {%o %o %o} a b c] \
	[expr { $a == -1 }] [expr { $b == $MIN_INT }] [expr { $c == $MAX_INT }]
} {3 1 1 1}
test scan-4.63 {scanning of large and negative hex integers} {
    foreach { MIN_INT MAX_INT } [int_range] {}
    set scanstring [format {%x %x %x} -1 $MIN_INT $MAX_INT]
    list [scan $scanstring {%x %x %x} a b c] \
	[expr { $a == -1 }] [expr { $b == $MIN_INT }] [expr { $c == $MAX_INT }]
} {3 1 1 1}

# clean up from last two tests

catch {
    rename int_range {}
}

a378 6
test scan-5.12 {integer scanning} {64bitInts} {
    set a {}; set b {}; set c {}
    list [scan "7810179016327718216,6c63546f6c6c6548,661432506755433062510" \
	    %ld,%lx,%lo a b c] $a $b $c
} {3 7810179016327718216 7810179016327718216 7810179016327718216}

d633 15
@


