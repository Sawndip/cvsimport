head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.58
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.56
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.54
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.52
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.50
	gdb_7_0-branch:1.5.0.48
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tcl8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.46
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.44
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.42
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.40
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.38
	gdb_6_5-2006-05-14-branchpoint:1.5
	readline_5_1-import-branch:1.5.0.36
	readline_5_1-import-branchpoint:1.5
	gdb_6_4-branch:1.5.0.34
	gdb_6_4-2005-11-01-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.32
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	ezannoni_pie-20040323-branch:1.5.0.30
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.28
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.26
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.24
	cagney_x86i386-20030821-branch:1.5.0.22
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.20
	gdb_6_0-2003-06-23-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.18
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.16
	cagney_writestrings-20030508-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.14
	cagney_fileio-20030521-branchpoint:1.5
	carlton_dictionary-20030430-merge:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.12
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.10
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.8
	cagney_lazyid-20030317-branchpoint:1.5
	offbyone-20030313-branch:1.5.0.6
	offbyone-20030313-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.4
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.2
	interps-20030202-branchpoint:1.5
	TCL8_4_1:1.1.1.3
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.2
	TCL_8_4_1:1.1.1.3
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.4
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TCL_8_4_0:1.1.1.3
	carlton_dictionary-branch:1.2.0.16
	carlton_dictionary-20020920-branchpoint:1.2
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.14
	gdb_5_3-branch:1.2.0.12
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.10
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.8
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.6
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TCL_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	dejagnu-2000-02-04:1.1.1.1
	dejagnu-2000-01-31:1.1.1.1
	dejagnu-2000-01-24:1.1.1.1
	dejagnu-2000-01-17:1.1.1.1
	dejagnu-2000-01-10:1.1.1.1
	dejagnu-2000-01-04:1.1.1.1
	dejagnu-1999-12-21:1.1.1.1
	dejagnu-1999-12-13:1.1.1.1
	dejagnu-1999-12-07:1.1.1.1
	dejagnu-1999-12-06:1.1.1.1
	dejagnu-1999-11-15:1.1.1.1
	dejagnu-1999-11-08:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2003.01.21.19.40.14;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.26.19.48.00;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.37.07;	author kseitz;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2001.09.09.23.56.08;	author irox;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2002.09.27.21.49.10;	author kseitz;	state Exp;
branches;
next	;

1.3.4.1
date	2003.12.14.20.28.49;	author drow;	state Exp;
branches;
next	;

1.2.16.1
date	2002.12.23.19.40.37;	author carlton;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2003.02.07.19.18.17;	author carlton;	state Exp;
branches;
next	;

1.1.1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.09.22.40.58;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.19.56.34;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tcl 8.4.1
@
text
@# This file contains a collection of tests for the procedures in the
# file tclCmdIL.c.  Sourcing this file into Tcl runs the tests and
# generates output for errors.  No output means no errors were found.
#
# Copyright (c) 1997 Sun Microsystems, Inc.
# Copyright (c) 1998-1999 by Scriptics Corporation.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# RCS: @@(#) $Id: cmdIL.test,v 1.14 2001/09/28 15:32:17 dkf Exp $

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import -force ::tcltest::*
}

test cmdIL-1.1 {Tcl_LsortObjCmd procedure} {
    list [catch {lsort} msg] $msg
} {1 {wrong # args: should be "lsort ?options? list"}}
test cmdIL-1.2 {Tcl_LsortObjCmd procedure} {
    list [catch {lsort -foo {1 3 2 5}} msg] $msg
} {1 {bad option "-foo": must be -ascii, -command, -decreasing, -dictionary, -increasing, -index, -integer, -real, or -unique}}
test cmdIL-1.3 {Tcl_LsortObjCmd procedure, default options} {
    lsort {d e c b a \{ d35 d300}
} {a b c d d300 d35 e \{}
test cmdIL-1.4 {Tcl_LsortObjCmd procedure, -ascii option} {
    lsort -integer -ascii {d e c b a d35 d300}
} {a b c d d300 d35 e}
test cmdIL-1.5 {Tcl_LsortObjCmd procedure, -command option} {
    list [catch {lsort -command {1 3 2 5}} msg] $msg
} {1 {"-command" option must be followed by comparison command}}
test cmdIL-1.6 {Tcl_LsortObjCmd procedure, -command option} {
    proc cmp {a b} {
	expr {[string match x* $b] - [string match x* $a]}
    }
    lsort -command cmp {x1 abc x2 def x3 x4}
} {x1 x2 x3 x4 abc def}
test cmdIL-1.7 {Tcl_LsortObjCmd procedure, -decreasing option} {
    lsort -decreasing {d e c b a d35 d300}
} {e d35 d300 d c b a}
test cmdIL-1.8 {Tcl_LsortObjCmd procedure, -dictionary option} {
    lsort -dictionary {d e c b a d35 d300}
} {a b c d d35 d300 e}
test cmdIL-1.9 {Tcl_LsortObjCmd procedure, -dictionary option} {
    lsort -dictionary {1k 0k 10k}
} {0k 1k 10k}
test cmdIL-1.10 {Tcl_LsortObjCmd procedure, -increasing option} {
    lsort -decreasing -increasing {d e c b a d35 d300}
} {a b c d d300 d35 e}
test cmdIL-1.11 {Tcl_LsortObjCmd procedure, -index option} {
    list [catch {lsort -index {1 3 2 5}} msg] $msg
} {1 {"-index" option must be followed by list index}}
test cmdIL-1.12 {Tcl_LsortObjCmd procedure, -index option} {
    list [catch {lsort -index foo {1 3 2 5}} msg] $msg
} {1 {bad index "foo": must be integer or end?-integer?}}
test cmdIL-1.13 {Tcl_LsortObjCmd procedure, -index option} {
    lsort -index end -integer {{2 25} {10 20 50 100} {3 16 42} 1}
} {1 {2 25} {3 16 42} {10 20 50 100}}
test cmdIL-1.14 {Tcl_LsortObjCmd procedure, -index option} {
    lsort -index 1 -integer {{1 25 100} {3 16 42} {10 20 50}}
} {{3 16 42} {10 20 50} {1 25 100}}
test cmdIL-1.15 {Tcl_LsortObjCmd procedure, -integer option} {
    lsort -integer {24 6 300 18}
} {6 18 24 300}
test cmdIL-1.16 {Tcl_LsortObjCmd procedure, -integer option} {
    list [catch {lsort -integer {1 3 2.4}} msg] $msg
} {1 {expected integer but got "2.4"}}
test cmdIL-1.17 {Tcl_LsortObjCmd procedure, -real option} {
    lsort -real {24.2 6e3 150e-1}
} {150e-1 24.2 6e3}
test cmdIL-1.18 {Tcl_LsortObjCmd procedure, bogus list} {
    list [catch {lsort "1 2 3 \{ 4"} msg] $msg
} {1 {unmatched open brace in list}}
test cmdIL-1.19 {Tcl_LsortObjCmd procedure, empty list} {
    lsort {}
} {}
test cmdIL-1.22 {Tcl_LsortObjCmd procedure, unique sort} {
    lsort -integer -unique {3 1 2 3 1 4 3}
} {1 2 3 4}
test cmdIL-1.23 {Tcl_LsortObjCmd procedure, unique sort with index} {
    # lsort -unique should return the last unique item
    lsort -unique -index 0 {{a b} {c b} {a c} {d a}}
} {{a c} {c b} {d a}}
test cmdIL-1.24 {Tcl_LsortObjCmd procedure, order of -index and -command} {
    catch {rename 1 ""}
    proc testcmp {a b} {return [string compare $a $b]}
    set l [list [list a b] [list c d]]
    set result [list [catch {lsort -command testcmp -index 1 $l} msg] $msg]
    rename testcmp ""
    set result
} [list 0 [list [list a b] [list c d]]]
test cmdIL-1.25 {Tcl_LsortObjCmd procedure, order of -index and -command} {
    catch {rename 1 ""}
    proc testcmp {a b} {return [string compare $a $b]}
    set l [list [list a b] [list c d]]
    set result [list [catch {lsort -index 1 -command testcmp $l} msg] $msg]
    rename testcmp ""
    set result
} [list 0 [list [list a b] [list c d]]]
# Note that the required order only exists in the end-1'th element;
# indexing using the end element or any fixed offset from the start
# will not work...
test cmdIL-1.26 {Tcl_LsortObjCmd procedure, offset indexing from end} {
    lsort -index end-1 {{a 1 e i} {b 2 3 f g} {c 4 5 6 d h}}
} {{c 4 5 6 d h} {a 1 e i} {b 2 3 f g}}

# Can't think of any good tests for the MergeSort and MergeLists
# procedures, except a bunch of random lists to sort.

test cmdIL-2.1 {MergeSort and MergeLists procedures} {
    set result {}
    set r 1435753299
    proc rand {} {
	global r
	set r [expr {(16807 * $r) % (0x7fffffff)}]
    }
    for {set i 0} {$i < 150} {incr i} {
	set x {}
	for {set j 0} {$j < $i} {incr j} {
	    lappend x [expr {[rand] & 0xfff}]
	}
	set y [lsort -integer $x]
	set old -1
	foreach el $y {
	    if {$el < $old} {
		append result "list {$x} sorted to {$y}, element $el out of order\n"
		break
	    }
	    set old $el
	}
    }
    set result
} {}

test cmdIL-3.1 {SortCompare procedure, skip comparisons after error} {
    set x 0
    proc cmp {a b} {
	global x
	incr x
	error "error #$x"
    }
    list [catch {lsort -integer -command cmp {48 6 28 190 16 2 3 6 1}} msg] \
	    $msg $x
} {1 {error #1} 1}
test cmdIL-3.2 {SortCompare procedure, -index option} {
    list [catch {lsort -integer -index 2 "\\\{ {30 40 50}"} msg] $msg
} {1 {unmatched open brace in list}}
test cmdIL-3.3 {SortCompare procedure, -index option} {
    list [catch {lsort -integer -index 2 {{20 10} {15 30 40}}} msg] $msg
} {1 {element 2 missing from sublist "20 10"}}
test cmdIL-3.4 {SortCompare procedure, -index option} {
    list [catch {lsort -integer -index 2 "{a b c} \\\{"} msg] $msg
} {1 {unmatched open brace in list}}
test cmdIL-3.5 {SortCompare procedure, -index option} {
    list [catch {lsort -integer -index 2 {{20 10 13} {15}}} msg] $msg
} {1 {element 2 missing from sublist "15"}}
test cmdIL-3.6 {SortCompare procedure, -index option} {
    lsort -integer -index 2 {{1 15 30} {2 5 25} {3 25 20}}
} {{3 25 20} {2 5 25} {1 15 30}}
test cmdIL-3.7 {SortCompare procedure, -ascii option} {
    lsort -ascii {d e c b a d35 d300 100 20}
} {100 20 a b c d d300 d35 e}
test cmdIL-3.8 {SortCompare procedure, -dictionary option} {
    lsort -dictionary {d e c b a d35 d300 100 20}
} {20 100 a b c d d35 d300 e}
test cmdIL-3.9 {SortCompare procedure, -integer option} {
    list [catch {lsort -integer {x 3}} msg] $msg
} {1 {expected integer but got "x"}}
test cmdIL-3.10 {SortCompare procedure, -integer option} {
    list [catch {lsort -integer {3 q}} msg] $msg
} {1 {expected integer but got "q"}}
test cmdIL-3.11 {SortCompare procedure, -integer option} {
    lsort -integer {35 21 0x20 30 023 100 8}
} {8 023 21 30 0x20 35 100}
test cmdIL-3.12 {SortCompare procedure, -real option} {
    list [catch {lsort -real {6...4 3}} msg] $msg
} {1 {expected floating-point number but got "6...4"}}
test cmdIL-3.13 {SortCompare procedure, -real option} {
    list [catch {lsort -real {3 1x7}} msg] $msg
} {1 {expected floating-point number but got "1x7"}}
test cmdIL-3.14 {SortCompare procedure, -real option} {
    lsort -real {24 2.5e01 16.7 85e-1 10.004}
} {85e-1 10.004 16.7 24 2.5e01}
test cmdIL-3.15 {SortCompare procedure, -command option} {
    proc cmp {a b} {
	error "comparison error"
    }
    list [catch {lsort -command cmp {48 6}} msg] $msg $errorInfo
} {1 {comparison error} {comparison error
    while executing
"error "comparison error""
    (procedure "cmp" line 2)
    invoked from within
"cmp 48 6"
    (-compare command)
    invoked from within
"lsort -command cmp {48 6}"}}
test cmdIL-3.16 {SortCompare procedure, -command option, long command} {
    proc cmp {dummy a b} {
	string compare $a $b
    }
    lsort -command {cmp {this argument is very very long in order to make the dstring overflow its statically allocated space}} {{this first element is also long in order to help expand the dstring} {the second element, last but not least, is quite long also, in order to make absolutely sure that space is allocated dynamically for the dstring}}
} {{the second element, last but not least, is quite long also, in order to make absolutely sure that space is allocated dynamically for the dstring} {this first element is also long in order to help expand the dstring}}
test cmdIL-3.17 {SortCompare procedure, -command option, non-integer result} {
    proc cmp {a b} {
	return foow
    }
    list [catch {lsort -command cmp {48 6}} msg] $msg
} {1 {-compare command returned non-numeric result}}
test cmdIL-3.18 {SortCompare procedure, -command option} {
    proc cmp {a b} {
	expr {$b - $a}
    }
    lsort -command cmp {48 6 18 22 21 35 36}
} {48 36 35 22 21 18 6}
test cmdIL-3.19 {SortCompare procedure, -decreasing option} {
    lsort -decreasing -integer {35 21 0x20 30 023 100 8}
} {100 35 0x20 30 21 023 8}

test cmdIL-4.1 {DictionaryCompare procedure, numerics, leading zeros} {
    lsort -dictionary {a003b a03b}
} {a03b a003b}
test cmdIL-4.2 {DictionaryCompare procedure, numerics, leading zeros} {
    lsort -dictionary {a3b a03b}
} {a3b a03b}
test cmdIL-4.3 {DictionaryCompare procedure, numerics, leading zeros} {
    lsort -dictionary {a3b A03b}
} {A03b a3b}
test cmdIL-4.4 {DictionaryCompare procedure, numerics, leading zeros} {
    lsort -dictionary {a3b a03B}
} {a3b a03B}
test cmdIL-4.5 {DictionaryCompare procedure, numerics, leading zeros} {
    lsort -dictionary {00000 000}
} {000 00000}
test cmdIL-4.6 {DictionaryCompare procedure, numerics, different lengths} {
    lsort -dictionary {a321b a03210b}
} {a321b a03210b}
test cmdIL-4.7 {DictionaryCompare procedure, numerics, different lengths} {
    lsort -dictionary {a03210b a321b}
} {a321b a03210b}
test cmdIL-4.8 {DictionaryCompare procedure, numerics} {
    lsort -dictionary {48 6a 18b 22a 21aa 35 36}
} {6a 18b 21aa 22a 35 36 48}
test cmdIL-4.9 {DictionaryCompare procedure, numerics} {
    lsort -dictionary {a123x a123b}
} {a123b a123x}
test cmdIL-4.10 {DictionaryCompare procedure, numerics} {
    lsort -dictionary {a123b a123x}
} {a123b a123x}
test cmdIL-4.11 {DictionaryCompare procedure, numerics} {
    lsort -dictionary {a1b aab}
} {a1b aab}
test cmdIL-4.12 {DictionaryCompare procedure, numerics} {
    lsort -dictionary {a1b a!b}
} {a!b a1b}
test cmdIL-4.13 {DictionaryCompare procedure, numerics} {
    lsort -dictionary {a1b2c a1b1c}
} {a1b1c a1b2c}
test cmdIL-4.14 {DictionaryCompare procedure, numerics} {
    lsort -dictionary {a1b2c a1b3c}
} {a1b2c a1b3c}
test cmdIL-4.15 {DictionaryCompare procedure, long numbers} {
    lsort -dictionary {a7654884321988762b a7654884321988761b}
} {a7654884321988761b a7654884321988762b}
test cmdIL-4.16 {DictionaryCompare procedure, long numbers} {
    lsort -dictionary {a8765488432198876b a7654884321988761b}
} {a7654884321988761b a8765488432198876b}
test cmdIL-4.17 {DictionaryCompare procedure, case} {
    lsort -dictionary {aBCd abcc}
} {abcc aBCd}
test cmdIL-4.18 {DictionaryCompare procedure, case} {
    lsort -dictionary {aBCd abce}
} {aBCd abce}
test cmdIL-4.19 {DictionaryCompare procedure, case} {
    lsort -dictionary {abcd ABcc}
} {ABcc abcd}
test cmdIL-4.20 {DictionaryCompare procedure, case} {
    lsort -dictionary {abcd ABce}
} {abcd ABce}
test cmdIL-4.21 {DictionaryCompare procedure, case} {
    lsort -dictionary {abCD ABcd}
} {ABcd abCD}
test cmdIL-4.22 {DictionaryCompare procedure, case} {
    lsort -dictionary {ABcd aBCd}
} {ABcd aBCd}
test cmdIL-4.23 {DictionaryCompare procedure, case} {
    lsort -dictionary {ABcd AbCd}
} {ABcd AbCd}
test cmdIL-4.24 {DictionaryCompare procedure, international characters} {hasIsoLocale} {
    ::tcltest::set_iso8859_1_locale
    set result [lsort -dictionary "a b c A B C \xe3 \xc4"]
    ::tcltest::restore_locale
    set result
} "A a B b C c \xe3 \xc4"
test cmdIL-4.25 {DictionaryCompare procedure, international characters} {hasIsoLocale} {
    ::tcltest::set_iso8859_1_locale
    set result [lsort -dictionary "a23\xe3 a23\xc5 a23\xe4"]
    ::tcltest::restore_locale
    set result
} "a23\xe3 a23\xe4 a23\xc5"
test cmdIL-4.26 {DefaultCompare procedure, signed characters} {
    set l [lsort [list "abc\200" "abc"]]
    set viewlist {}
    foreach s $l {
	set viewelem ""
	set len [string length $s]
	for {set i 0} {$i < $len} {incr i} {
	    set c [string index $s $i]
	    scan $c %c d
	    if {$d > 0 && $d < 128} {
		append viewelem $c
	    } else {
		append viewelem "\\[format %03o $d]"
	    }
	}
	lappend viewlist $viewelem
    }
    set viewlist
} [list "abc" "abc\\200"]
test cmdIL-4.27 {DictionaryCompare procedure, signed characters} {
    set l [lsort -dictionary [list "abc\200" "abc"]]
    set viewlist {}
    foreach s $l {
	set viewelem ""
	set len [string length $s]
	for {set i 0} {$i < $len} {incr i} {
	    set c [string index $s $i]
	    scan $c %c d
	    if {$d > 0 && $d < 128} {
		append viewelem $c
	    } else {
		append viewelem "\\[format %03o $d]"
	    }
	}
	lappend viewlist $viewelem
    }
    set viewlist
} [list "abc" "abc\\200"]
test cmdIL-4.28 {DictionaryCompare procedure, chars between Z and a in ASCII} {
    lsort -dictionary [list AA ` c CC]
} [list ` AA c CC]
test cmdIL-4.29 {DictionaryCompare procedure, chars between Z and a in ASCII} {
    lsort -dictionary [list AA ` c ^ \\ CC \[ \]]
} [list \[ \\ \] ^ ` AA c CC]
test cmdIL-4.30 {DictionaryCompare procedure, chars between Z and a in ASCII} {
    lsort -dictionary [list AA ` c ^ _ \\ CC \[ dude \] funky]
} [list \[ \\ \] ^ _ ` AA c CC dude funky]
test cmdIL-4.31 {DictionaryCompare procedure, chars between Z and a in ASCII} {
    lsort -dictionary [list AA c ` CC]
} [list ` AA c CC]
test cmdIL-4.32 {DictionaryCompare procedure, chars between Z and a in ASCII} {
    lsort -dictionary [list AA c CC `]
} [list ` AA c CC]
test cmdIL-4.33 {DictionaryCompare procedure, chars between Z and a in ASCII} {
    lsort -dictionary [list AA ! c CC `]
} [list ! ` AA c CC]

# cleanup
::tcltest::cleanupTests
return
@


1.4
log
@touched all sources to ease next import
@
text
@d11 1
a11 1
# RCS: @@(#) $Id: cmdIL.test,v 1.6.8.2 2000/09/15 16:56:05 spolk Exp $
d85 22
a361 1

@


1.3
log
@touched all sources to ease next import
@
text
@@


1.3.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d11 1
a11 1
# RCS: @@(#) $Id: cmdIL.test,v 1.14 2001/09/28 15:32:17 dkf Exp $
a84 22
test cmdIL-1.24 {Tcl_LsortObjCmd procedure, order of -index and -command} {
    catch {rename 1 ""}
    proc testcmp {a b} {return [string compare $a $b]}
    set l [list [list a b] [list c d]]
    set result [list [catch {lsort -command testcmp -index 1 $l} msg] $msg]
    rename testcmp ""
    set result
} [list 0 [list [list a b] [list c d]]]
test cmdIL-1.25 {Tcl_LsortObjCmd procedure, order of -index and -command} {
    catch {rename 1 ""}
    proc testcmp {a b} {return [string compare $a $b]}
    set l [list [list a b] [list c d]]
    set result [list [catch {lsort -index 1 -command testcmp $l} msg] $msg]
    rename testcmp ""
    set result
} [list 0 [list [list a b] [list c d]]]
# Note that the required order only exists in the end-1'th element;
# indexing using the end element or any fixed offset from the start
# will not work...
test cmdIL-1.26 {Tcl_LsortObjCmd procedure, offset indexing from end} {
    lsort -index end-1 {{a 1 e i} {b 2 3 f g} {c 4 5 6 d h}}
} {{c 4 5 6 d h} {a 1 e i} {b 2 3 f g}}
d340 1
@


1.3.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@d11 1
a11 1
# RCS: @@(#) $Id: cmdIL.test,v 1.14 2001/09/28 15:32:17 dkf Exp $
a84 22
test cmdIL-1.24 {Tcl_LsortObjCmd procedure, order of -index and -command} {
    catch {rename 1 ""}
    proc testcmp {a b} {return [string compare $a $b]}
    set l [list [list a b] [list c d]]
    set result [list [catch {lsort -command testcmp -index 1 $l} msg] $msg]
    rename testcmp ""
    set result
} [list 0 [list [list a b] [list c d]]]
test cmdIL-1.25 {Tcl_LsortObjCmd procedure, order of -index and -command} {
    catch {rename 1 ""}
    proc testcmp {a b} {return [string compare $a $b]}
    set l [list [list a b] [list c d]]
    set result [list [catch {lsort -index 1 -command testcmp $l} msg] $msg]
    rename testcmp ""
    set result
} [list 0 [list [list a b] [list c d]]]
# Note that the required order only exists in the end-1'th element;
# indexing using the end element or any fixed offset from the start
# will not work...
test cmdIL-1.26 {Tcl_LsortObjCmd procedure, offset indexing from end} {
    lsort -index end-1 {{a 1 e i} {b 2 3 f g} {c 4 5 6 d h}}
} {{c 4 5 6 d h} {a 1 e i} {b 2 3 f g}}
d340 1
@


1.2
log
@touched all Tcl files to ease next import.
@
text
@@


1.2.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.2.16.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@a84 22
test cmdIL-1.24 {Tcl_LsortObjCmd procedure, order of -index and -command} {
    catch {rename 1 ""}
    proc testcmp {a b} {return [string compare $a $b]}
    set l [list [list a b] [list c d]]
    set result [list [catch {lsort -command testcmp -index 1 $l} msg] $msg]
    rename testcmp ""
    set result
} [list 0 [list [list a b] [list c d]]]
test cmdIL-1.25 {Tcl_LsortObjCmd procedure, order of -index and -command} {
    catch {rename 1 ""}
    proc testcmp {a b} {return [string compare $a $b]}
    set l [list [list a b] [list c d]]
    set result [list [catch {lsort -index 1 -command testcmp $l} msg] $msg]
    rename testcmp ""
    set result
} [list 0 [list [list a b] [list c d]]]
# Note that the required order only exists in the end-1'th element;
# indexing using the end element or any fixed offset from the start
# will not work...
test cmdIL-1.26 {Tcl_LsortObjCmd procedure, offset indexing from end} {
    lsort -index end-1 {{a 1 e i} {b 2 3 f g} {c 4 5 6 d h}}
} {{c 4 5 6 d h} {a 1 e i} {b 2 3 f g}}
d340 1
@


1.1
log
@Initial revision
@
text
@d6 1
a6 1
# Copyright (c) 1998 by Scriptics Corporation.
d11 1
a11 1
# RCS: @@(#) $Id: cmdIL.test,v 1.5 1998/10/13 20:30:23 rjohnson Exp $
d13 4
a16 1
if {[string compare test [info procs test]] == 1} then {source defs}
d23 1
a23 1
} {1 {bad option "-foo": must be -ascii, -command, -decreasing, -dictionary, -increasing, -index, -integer, or -real}}
d56 1
a56 1
} {1 {bad index "foo": must be integer or "end"}}
d78 7
d94 1
a94 1
	set r [expr (16807 * $r) % (0x7fffffff)]
d99 1
a99 1
	    lappend x [expr [rand] & 0xfff]
d191 1
a191 1
	expr $b - $a
d268 13
a280 1
test cmdIL-4.24 {DefaultCompare procedure, signed characters} {
d299 1
a299 1
test cmdIL-4.25 {DictionaryCompare procedure, signed characters} {
d318 23
@


1.1.1.1
log
@import dejagnu-1999-11-08 snapshot
@
text
@@


1.1.1.2
log
@Tcl 8.3 upgrade
@
text
@d6 1
a6 1
# Copyright (c) 1998-1999 by Scriptics Corporation.
d11 1
a11 1
# RCS: @@(#) $Id: cmdIL.test,v 1.6.8.2 2000/09/15 16:56:05 spolk Exp $
d13 1
a13 4
if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import -force ::tcltest::*
}
d20 1
a20 1
} {1 {bad option "-foo": must be -ascii, -command, -decreasing, -dictionary, -increasing, -index, -integer, -real, or -unique}}
d53 1
a53 1
} {1 {bad index "foo": must be integer or end?-integer?}}
a74 7
test cmdIL-1.22 {Tcl_LsortObjCmd procedure, unique sort} {
    lsort -integer -unique {3 1 2 3 1 4 3}
} {1 2 3 4}
test cmdIL-1.23 {Tcl_LsortObjCmd procedure, unique sort with index} {
    # lsort -unique should return the last unique item
    lsort -unique -index 0 {{a b} {c b} {a c} {d a}}
} {{a c} {c b} {d a}}
d84 1
a84 1
	set r [expr {(16807 * $r) % (0x7fffffff)}]
d89 1
a89 1
	    lappend x [expr {[rand] & 0xfff}]
d181 1
a181 1
	expr {$b - $a}
d258 1
a258 13
test cmdIL-4.24 {DictionaryCompare procedure, international characters} {hasIsoLocale} {
    ::tcltest::set_iso8859_1_locale
    set result [lsort -dictionary "a b c A B C \xe3 \xc4"]
    ::tcltest::restore_locale
    set result
} "A a B b C c \xe3 \xc4"
test cmdIL-4.25 {DictionaryCompare procedure, international characters} {hasIsoLocale} {
    ::tcltest::set_iso8859_1_locale
    set result [lsort -dictionary "a23\xe3 a23\xc5 a23\xe4"]
    ::tcltest::restore_locale
    set result
} "a23\xe3 a23\xe4 a23\xc5"
test cmdIL-4.26 {DefaultCompare procedure, signed characters} {
d277 1
a277 1
test cmdIL-4.27 {DictionaryCompare procedure, signed characters} {
a295 23
test cmdIL-4.28 {DictionaryCompare procedure, chars between Z and a in ASCII} {
    lsort -dictionary [list AA ` c CC]
} [list ` AA c CC]
test cmdIL-4.29 {DictionaryCompare procedure, chars between Z and a in ASCII} {
    lsort -dictionary [list AA ` c ^ \\ CC \[ \]]
} [list \[ \\ \] ^ ` AA c CC]
test cmdIL-4.30 {DictionaryCompare procedure, chars between Z and a in ASCII} {
    lsort -dictionary [list AA ` c ^ _ \\ CC \[ dude \] funky]
} [list \[ \\ \] ^ _ ` AA c CC dude funky]
test cmdIL-4.31 {DictionaryCompare procedure, chars between Z and a in ASCII} {
    lsort -dictionary [list AA c ` CC]
} [list ` AA c CC]
test cmdIL-4.32 {DictionaryCompare procedure, chars between Z and a in ASCII} {
    lsort -dictionary [list AA c CC `]
} [list ` AA c CC]
test cmdIL-4.33 {DictionaryCompare procedure, chars between Z and a in ASCII} {
    lsort -dictionary [list AA ! c CC `]
} [list ! ` AA c CC]

# cleanup
::tcltest::cleanupTests
return

@


1.1.1.3
log
@import tcl 8.4.0
@
text
@d11 1
a11 1
# RCS: @@(#) $Id: cmdIL.test,v 1.14 2001/09/28 15:32:17 dkf Exp $
a84 22
test cmdIL-1.24 {Tcl_LsortObjCmd procedure, order of -index and -command} {
    catch {rename 1 ""}
    proc testcmp {a b} {return [string compare $a $b]}
    set l [list [list a b] [list c d]]
    set result [list [catch {lsort -command testcmp -index 1 $l} msg] $msg]
    rename testcmp ""
    set result
} [list 0 [list [list a b] [list c d]]]
test cmdIL-1.25 {Tcl_LsortObjCmd procedure, order of -index and -command} {
    catch {rename 1 ""}
    proc testcmp {a b} {return [string compare $a $b]}
    set l [list [list a b] [list c d]]
    set result [list [catch {lsort -index 1 -command testcmp $l} msg] $msg]
    rename testcmp ""
    set result
} [list 0 [list [list a b] [list c d]]]
# Note that the required order only exists in the end-1'th element;
# indexing using the end element or any fixed offset from the start
# will not work...
test cmdIL-1.26 {Tcl_LsortObjCmd procedure, offset indexing from end} {
    lsort -index end-1 {{a 1 e i} {b 2 3 f g} {c 4 5 6 d h}}
} {{c 4 5 6 d h} {a 1 e i} {b 2 3 f g}}
d340 1
@


