head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.58
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.56
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.54
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.52
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.50
	gdb_7_0-branch:1.5.0.48
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tcl8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.46
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.44
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.42
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.40
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.38
	gdb_6_5-2006-05-14-branchpoint:1.5
	readline_5_1-import-branch:1.5.0.36
	readline_5_1-import-branchpoint:1.5
	gdb_6_4-branch:1.5.0.34
	gdb_6_4-2005-11-01-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.32
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	ezannoni_pie-20040323-branch:1.5.0.30
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.28
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.26
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.24
	cagney_x86i386-20030821-branch:1.5.0.22
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.20
	gdb_6_0-2003-06-23-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.18
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.16
	cagney_writestrings-20030508-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.14
	cagney_fileio-20030521-branchpoint:1.5
	carlton_dictionary-20030430-merge:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.12
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.10
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.8
	cagney_lazyid-20030317-branchpoint:1.5
	offbyone-20030313-branch:1.5.0.6
	offbyone-20030313-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.4
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.2
	interps-20030202-branchpoint:1.5
	TCL8_4_1:1.1.1.3
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.2
	TCL_8_4_1:1.1.1.3
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.4
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TCL_8_4_0:1.1.1.3
	carlton_dictionary-branch:1.2.0.16
	carlton_dictionary-20020920-branchpoint:1.2
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.14
	gdb_5_3-branch:1.2.0.12
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.10
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.8
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.6
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TCL_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	dejagnu-2000-02-04:1.1.1.1
	dejagnu-2000-01-31:1.1.1.1
	dejagnu-2000-01-24:1.1.1.1
	dejagnu-2000-01-17:1.1.1.1
	dejagnu-2000-01-10:1.1.1.1
	dejagnu-2000-01-04:1.1.1.1
	dejagnu-1999-12-21:1.1.1.1
	dejagnu-1999-12-13:1.1.1.1
	dejagnu-1999-12-07:1.1.1.1
	dejagnu-1999-12-06:1.1.1.1
	dejagnu-1999-11-15:1.1.1.1
	dejagnu-1999-11-08:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2003.01.21.19.40.14;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.26.19.48.00;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.37.07;	author kseitz;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2001.09.09.23.56.08;	author irox;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2002.09.27.21.49.10;	author kseitz;	state Exp;
branches;
next	;

1.3.4.1
date	2003.12.14.20.28.49;	author drow;	state Exp;
branches;
next	;

1.2.16.1
date	2002.12.23.19.40.36;	author carlton;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2003.02.07.19.18.17;	author carlton;	state Exp;
branches;
next	;

1.1.1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.09.22.40.58;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.19.56.34;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tcl 8.4.1
@
text
@# The file tests the tclCmdAH.c file.
#
# This file contains a collection of tests for one or more of the Tcl
# built-in commands.  Sourcing this file into Tcl runs the tests and
# generates output for errors.  No output means no errors were found.
#
# Copyright (c) 1996-1998 by Sun Microsystems, Inc.
# Copyright (c) 1998-1999 by Scriptics Corporation.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# RCS: @@(#) $Id: cmdAH.test,v 1.29 2002/07/11 08:25:24 dkf Exp $

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest 2.1
    namespace import -force ::tcltest::*
}

tcltest::testConstraint testchmod [string equal testchmod [info commands testchmod]]

global env
set cmdAHwd [pwd]
catch {set platform [testgetplatform]}

test cmdAH-0.1 {Tcl_BreakObjCmd, errors} {
    list [catch {break foo} msg] $msg
} {1 {wrong # args: should be "break"}}
test cmdAH-0.2 {Tcl_BreakObjCmd, success} {
    list [catch {break} msg] $msg
} {3 {}}

# Tcl_CaseObjCmd is tested in case.test

test cmdAH-1.1 {Tcl_CatchObjCmd, errors} {
    list [catch {catch} msg] $msg
} {1 {wrong # args: should be "catch command ?varName?"}}
test cmdAH-1.2 {Tcl_CatchObjCmd, errors} {
    list [catch {catch foo bar baz} msg] $msg
} {1 {wrong # args: should be "catch command ?varName?"}}

test cmdAH-2.1 {Tcl_CdObjCmd} {
    list [catch {cd foo bar} msg] $msg
} {1 {wrong # args: should be "cd ?dirName?"}}
set foodir [file join [temporaryDirectory] foo]
test cmdAH-2.2 {Tcl_CdObjCmd} {
    file delete -force $foodir
    file mkdir $foodir
    cd $foodir
    set result [file tail [pwd]]
    cd ..
    file delete $foodir
    set result
} foo
test cmdAH-2.3 {Tcl_CdObjCmd} {
    global env
    set oldpwd [pwd]
    set temp $env(HOME)
    set env(HOME) $oldpwd
    file delete -force $foodir
    file mkdir $foodir
    cd $foodir
    cd ~
    set result [string equal [pwd] $oldpwd]
    file delete $foodir
    set env(HOME) $temp
    set result
} 1
test cmdAH-2.4 {Tcl_CdObjCmd} {
    global env
    set oldpwd [pwd]
    set temp $env(HOME)
    set env(HOME) $oldpwd
    file delete -force $foodir
    file mkdir $foodir
    cd $foodir
    cd
    set result [string equal [pwd] $oldpwd]
    file delete $foodir
    set env(HOME) $temp
    set result
} 1
test cmdAH-2.5 {Tcl_CdObjCmd} {
    list [catch {cd ~~} msg] $msg
} {1 {user "~" doesn't exist}}
test cmdAH-2.6 {Tcl_CdObjCmd} {
    list [catch {cd _foobar} msg] $msg
} {1 {couldn't change working directory to "_foobar": no such file or directory}}

test cmdAH-2.7 {Tcl_ConcatObjCmd} {
    concat
} {}
test cmdAH-2.8 {Tcl_ConcatObjCmd} {
    concat a
} a
test cmdAH-2.9 {Tcl_ConcatObjCmd} {
    concat a {b c}
} {a b c}

test cmdAH-3.1 {Tcl_ContinueObjCmd, errors} {
    list [catch {continue foo} msg] $msg
} {1 {wrong # args: should be "continue"}}
test cmdAH-3.2 {Tcl_ContinueObjCmd, success} {
    list [catch {continue} msg] $msg
} {4 {}}

test cmdAH-4.1 {Tcl_EncodingObjCmd} {
    list [catch {encoding} msg] $msg
} {1 {wrong # args: should be "encoding option ?arg ...?"}}
test cmdAH-4.2 {Tcl_EncodingObjCmd} {
    list [catch {encoding foo} msg] $msg
} {1 {bad option "foo": must be convertfrom, convertto, names, or system}}
test cmdAH-4.3 {Tcl_EncodingObjCmd} {
    list [catch {encoding convertto} msg] $msg
} {1 {wrong # args: should be "encoding convertto ?encoding? data"}}
test cmdAH-4.4 {Tcl_EncodingObjCmd} {
    list [catch {encoding convertto foo bar} msg] $msg
} {1 {unknown encoding "foo"}}
test cmdAH-4.5 {Tcl_EncodingObjCmd} {
    set system [encoding system]
    encoding system jis0208
    set x [encoding convertto \u4e4e]
    encoding system $system
    set x
} 8C
test cmdAH-4.6 {Tcl_EncodingObjCmd} {
    set system [encoding system]
    encoding system identity
    set x [encoding convertto jis0208 \u4e4e]
    encoding system $system
    set x
} 8C
test cmdAH-4.7 {Tcl_EncodingObjCmd} {
    list [catch {encoding convertfrom} msg] $msg
} {1 {wrong # args: should be "encoding convertfrom ?encoding? data"}}
test cmdAH-4.8 {Tcl_EncodingObjCmd} {
    list [catch {encoding convertfrom foo bar} msg] $msg
} {1 {unknown encoding "foo"}}
test cmdAH-4.9 {Tcl_EncodingObjCmd} {
    set system [encoding system]
    encoding system jis0208
    set x [encoding convertfrom 8C]
    encoding system $system
    set x
} \u4e4e
test cmdAH-4.10 {Tcl_EncodingObjCmd} {
    set system [encoding system]
    encoding system identity
    set x [encoding convertfrom jis0208 8C]
    encoding system $system
    set x
} \u4e4e
test cmdAH-4.11 {Tcl_EncodingObjCmd} {
    list [catch {encoding names foo} msg] $msg
} {1 {wrong # args: should be "encoding names"}}
test cmdAH-4.12 {Tcl_EncodingObjCmd} {
    list [catch {encoding system foo bar} msg] $msg
} {1 {wrong # args: should be "encoding system ?encoding?"}}
test cmdAH-4.13 {Tcl_EncodingObjCmd} {
    set system [encoding system]
    encoding system identity
    set x [encoding system]
    encoding system $system
    set x
} identity

test cmdAH-5.1 {Tcl_FileObjCmd} {
    list [catch file msg] $msg
} {1 {wrong # args: should be "file option ?arg ...?"}}
test cmdAH-5.2 {Tcl_FileObjCmd} {
    list [catch {file x} msg] $msg
} {1 {bad option "x": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, link, lstat, mtime, mkdir, nativename, normalize, owned, pathtype, readable, readlink, rename, rootname, separator, size, split, stat, system, tail, type, volumes, or writable}}
test cmdAH-5.3 {Tcl_FileObjCmd} {
    list [catch {file exists} msg] $msg
} {1 {wrong # args: should be "file exists name"}}
test cmdAH-5.4 {Tcl_FileObjCmd} {
    list [catch {file exists ""} msg] $msg
} {0 0}

#volume

test cmdAH-6.1 {Tcl_FileObjCmd: volumes} {
    list [catch {file volumes x} msg] $msg	
} {1 {wrong # args: should be "file volumes"}}
test cmdAH-6.2 {Tcl_FileObjCmd: volumes} {
	set volumeList [file volumes]
	if { [llength $volumeList] == 0 } {
		set result 0
	} else {
		set result 1
	}	
} {1}
test cmdAH-6.3 {Tcl_FileObjCmd: volumes} {macOrUnix} {
    set volumeList [file volumes]
    catch [list glob -nocomplain [lindex $volumeList 0]*]
} {0}
test cmdAH-6.4 {Tcl_FileObjCmd: volumes} {pcOnly} {
    set volumeList [string tolower [file volumes]]
    list [catch {lsearch $volumeList "c:/"} element] [expr $element != -1] [catch {list glob -nocomplain [lindex $volumeList $element]*}]
} {0 1 0}

test cmdAH-6.5 {cd} {unixOnly nonPortable} {
    set dir [pwd]
    cd /
    set res [pwd]
    cd $dir
    set res
} {/}

# attributes

test cmdAH-7.1 {Tcl_FileObjCmd - file attrs} {
    set foofile [makeFile abcde foo.file]
    catch {file delete -force $foofile}
    close [open $foofile w]
    set res [catch {file attributes $foofile}]
    # We used [makeFile] so we undo with [removeFile]
    removeFile $foofile
    set res
} {0}

# dirname

if {[info commands testsetplatform] == {}} {
    puts "This application hasn't been compiled with the \"testsetplatform\""
    puts "command, so I can't test Tcl_FileObjCmd etc."
} else {
test cmdAH-8.1 {Tcl_FileObjCmd: dirname} {
    testsetplatform unix
    list [catch {file dirname a b} msg] $msg
} {1 {wrong # args: should be "file dirname name"}}
test cmdAH-8.2 {Tcl_FileObjCmd: dirname} {
    testsetplatform unix
    file dirname /a/b
} /a
test cmdAH-8.3 {Tcl_FileObjCmd: dirname} {
    testsetplatform unix
    file dirname {}
} .
test cmdAH-8.4 {Tcl_FileObjCmd: dirname} {
    testsetplatform mac
    file dirname {}
} :
test cmdAH-8.5 {Tcl_FileObjCmd: dirname} {
    testsetplatform win
    file dirname {}
} .
test cmdAH-8.6 {Tcl_FileObjCmd: dirname} {
    testsetplatform unix
    file dirname .def
} .
test cmdAH-8.7 {Tcl_FileObjCmd: dirname} {
    testsetplatform mac
    file dirname a
} :
test cmdAH-8.8 {Tcl_FileObjCmd: dirname} {
    testsetplatform win
    file dirname a
} .
test cmdAH-8.9 {Tcl_FileObjCmd: dirname} {
    testsetplatform unix
    file dirname a/b/c.d
} a/b
test cmdAH-8.10 {Tcl_FileObjCmd: dirname} {
    testsetplatform unix
    file dirname a/b.c/d
} a/b.c
test cmdAH-8.11 {Tcl_FileObjCmd: dirname} {
    testsetplatform unix
    file dirname /.
} /
test cmdAH-8.12 {Tcl_FileObjCmd: dirname} {
    testsetplatform unix
    list [catch {file dirname /} msg] $msg
} {0 /}
test cmdAH-8.13 {Tcl_FileObjCmd: dirname} {
    testsetplatform unix
    list [catch {file dirname /foo} msg] $msg
} {0 /}
test cmdAH-8.14 {Tcl_FileObjCmd: dirname} {
    testsetplatform unix
    list [catch {file dirname //foo} msg] $msg
} {0 /}
test cmdAH-8.15 {Tcl_FileObjCmd: dirname} {
    testsetplatform unix
    list [catch {file dirname //foo/bar} msg] $msg
} {0 /foo}
test cmdAH-8.16 {Tcl_FileObjCmd: dirname} {
    testsetplatform unix
    list [catch {file dirname {//foo\/bar/baz}} msg] $msg
} {0 {/foo\/bar}}
test cmdAH-8.17 {Tcl_FileObjCmd: dirname} {
    testsetplatform unix
    list [catch {file dirname {//foo\/bar/baz/blat}} msg] $msg
} {0 {/foo\/bar/baz}}
test cmdAH-8.18 {Tcl_FileObjCmd: dirname} {
    testsetplatform unix
    list [catch {file dirname /foo//} msg] $msg
} {0 /}
test cmdAH-8.19 {Tcl_FileObjCmd: dirname} {
    testsetplatform unix
    list [catch {file dirname ./a} msg] $msg
} {0 .}
test cmdAH-8.20 {Tcl_FileObjCmd: dirname} {
    testsetplatform unix
    list [catch {file dirname a/.a} msg] $msg
} {0 a}
test cmdAH-8.21 {Tcl_FileObjCmd: dirname} {
    testsetplatform windows
    list [catch {file dirname c:foo} msg] $msg
} {0 c:}
test cmdAH-8.22 {Tcl_FileObjCmd: dirname} {
    testsetplatform windows
    list [catch {file dirname c:} msg] $msg
} {0 c:}
test cmdAH-8.23 {Tcl_FileObjCmd: dirname} {
    testsetplatform windows
    list [catch {file dirname c:/} msg] $msg
} {0 c:/}
test cmdAH-8.24 {Tcl_FileObjCmd: dirname} {
    testsetplatform windows
    list [catch {file dirname {c:\foo}} msg] $msg
} {0 c:/}
test cmdAH-8.25 {Tcl_FileObjCmd: dirname} {
    testsetplatform windows
    list [catch {file dirname {//foo/bar/baz}} msg] $msg
} {0 //foo/bar}
test cmdAH-8.26 {Tcl_FileObjCmd: dirname} {
    testsetplatform windows
    list [catch {file dirname {//foo/bar}} msg] $msg
} {0 //foo/bar}
test cmdAH-8.27 {Tcl_FileObjCmd: dirname} {
    testsetplatform mac
    list [catch {file dirname :} msg] $msg
} {0 :}
test cmdAH-8.28 {Tcl_FileObjCmd: dirname} {
    testsetplatform mac
    list [catch {file dirname :Foo} msg] $msg
} {0 :}
test cmdAH-8.29 {Tcl_FileObjCmd: dirname} {
    testsetplatform mac
    list [catch {file dirname Foo:} msg] $msg
} {0 Foo:}
test cmdAH-8.30 {Tcl_FileObjCmd: dirname} {
    testsetplatform mac
    list [catch {file dirname Foo:bar} msg] $msg
} {0 Foo:}
test cmdAH-8.31 {Tcl_FileObjCmd: dirname} {
    testsetplatform mac
    list [catch {file dirname :Foo:bar} msg] $msg
} {0 :Foo}
test cmdAH-8.32 {Tcl_FileObjCmd: dirname} {
    testsetplatform mac
    list [catch {file dirname ::} msg] $msg
} {0 :}
test cmdAH-8.33 {Tcl_FileObjCmd: dirname} {
    testsetplatform mac
    list [catch {file dirname :::} msg] $msg
} {0 ::}
test cmdAH-8.34 {Tcl_FileObjCmd: dirname} {
    testsetplatform mac
    list [catch {file dirname /foo/bar/} msg] $msg
} {0 foo:}
test cmdAH-8.35 {Tcl_FileObjCmd: dirname} {
    testsetplatform mac
    list [catch {file dirname /foo/bar} msg] $msg
} {0 foo:}
test cmdAH-8.36 {Tcl_FileObjCmd: dirname} {
    testsetplatform mac
    list [catch {file dirname /foo} msg] $msg
} {0 foo:}
test cmdAH-8.37 {Tcl_FileObjCmd: dirname} {
    testsetplatform mac
    list [catch {file dirname foo} msg] $msg
} {0 :}
test cmdAH-8.38 {Tcl_FileObjCmd: dirname} {
    testsetplatform unix
    list [catch {file dirname ~/foo} msg] $msg
} {0 ~}
test cmdAH-8.39 {Tcl_FileObjCmd: dirname} {
    testsetplatform unix
    list [catch {file dirname ~bar/foo} msg] $msg
} {0 ~bar}
test cmdAH-8.40 {Tcl_FileObjCmd: dirname} {
    testsetplatform mac
    list [catch {file dirname ~bar/foo} msg] $msg
} {0 ~bar:}
test cmdAH-8.41 {Tcl_FileObjCmd: dirname} {
    testsetplatform mac
    list [catch {file dirname ~/foo} msg] $msg
} {0 ~:}
test cmdAH-8.42 {Tcl_FileObjCmd: dirname} {
    testsetplatform mac
    list [catch {file dirname ~:baz} msg] $msg
} {0 ~:}
test cmdAH-8.43 {Tcl_FileObjCmd: dirname} {
    global env
    set temp $env(HOME)
    set env(HOME) "/home/test"
    testsetplatform unix
    set result [list [catch {file dirname ~} msg] $msg]
    set env(HOME) $temp
    set result
} {0 /home}
test cmdAH-8.44 {Tcl_FileObjCmd: dirname} {
    global env
    set temp $env(HOME)
    set env(HOME) "~"
    testsetplatform unix
    set result [list [catch {file dirname ~} msg] $msg]
    set env(HOME) $temp
    set result
} {0 ~}
test cmdAH-8.45 {Tcl_FileObjCmd: dirname} {
    global env
    set temp $env(HOME)
    set env(HOME) "/home/test"
    testsetplatform windows
    set result [list [catch {file dirname ~} msg] $msg]
    set env(HOME) $temp
    set result
} {0 /home}
test cmdAH-8.46 {Tcl_FileObjCmd: dirname} {
    global env
    set temp $env(HOME)
    set env(HOME) "/home/test"
    testsetplatform mac
    set result [list [catch {file dirname ~} msg] $msg]
    set env(HOME) $temp
    set result
} {0 home:}

# tail

test cmdAH-9.1 {Tcl_FileObjCmd: tail} {
    testsetplatform unix
    list [catch {file tail a b} msg] $msg
} {1 {wrong # args: should be "file tail name"}}
test cmdAH-9.2 {Tcl_FileObjCmd: tail} {
    testsetplatform unix
    file tail /a/b
} b
test cmdAH-9.3 {Tcl_FileObjCmd: tail} {
    testsetplatform unix
    file tail {}
} {}
test cmdAH-9.4 {Tcl_FileObjCmd: tail} {
    testsetplatform mac
    file tail {}
} {}
test cmdAH-9.5 {Tcl_FileObjCmd: tail} {
    testsetplatform win
    file tail {}
} {}
test cmdAH-9.6 {Tcl_FileObjCmd: tail} {
    testsetplatform unix
    file tail .def
} .def
test cmdAH-9.7 {Tcl_FileObjCmd: tail} {
    testsetplatform mac
    file tail a
} a
test cmdAH-9.8 {Tcl_FileObjCmd: tail} {
    testsetplatform win
    file tail a
} a
test cmdAH-9.9 {Tcl_FileObjCmd: tail} {
    testsetplatform unix
    file ta a/b/c.d
} c.d
test cmdAH-9.10 {Tcl_FileObjCmd: tail} {
    testsetplatform unix
    file tail a/b.c/d
} d
test cmdAH-9.11 {Tcl_FileObjCmd: tail} {
    testsetplatform unix
    file tail /.
} .
test cmdAH-9.12 {Tcl_FileObjCmd: tail} {
    testsetplatform unix
    file tail /
} {}
test cmdAH-9.13 {Tcl_FileObjCmd: tail} {
    testsetplatform unix
    file tail /foo
} foo
test cmdAH-9.14 {Tcl_FileObjCmd: tail} {
    testsetplatform unix
    file tail //foo
} foo
test cmdAH-9.15 {Tcl_FileObjCmd: tail} {
    testsetplatform unix
    file tail //foo/bar
} bar
test cmdAH-9.16 {Tcl_FileObjCmd: tail} {
    testsetplatform unix
    file tail {//foo\/bar/baz}
} baz
test cmdAH-9.17 {Tcl_FileObjCmd: tail} {
    testsetplatform unix
    file tail {//foo\/bar/baz/blat}
} blat
test cmdAH-9.18 {Tcl_FileObjCmd: tail} {
    testsetplatform unix
    file tail /foo//
} foo
test cmdAH-9.19 {Tcl_FileObjCmd: tail} {
    testsetplatform unix
    file tail ./a
} a
test cmdAH-9.20 {Tcl_FileObjCmd: tail} {
    testsetplatform unix
    file tail a/.a
} .a
test cmdAH-9.21 {Tcl_FileObjCmd: tail} {
    testsetplatform windows
    file tail c:foo
} foo
test cmdAH-9.22 {Tcl_FileObjCmd: tail} {
    testsetplatform windows
    file tail c:
} {}
test cmdAH-9.23 {Tcl_FileObjCmd: tail} {
    testsetplatform windows
    file tail c:/
} {}
test cmdAH-9.24 {Tcl_FileObjCmd: tail} {
    testsetplatform windows
    file tail {c:\foo}
} foo
test cmdAH-9.25 {Tcl_FileObjCmd: tail} {
    testsetplatform windows
    file tail {//foo/bar/baz}
} baz
test cmdAH-9.26 {Tcl_FileObjCmd: tail} {
    testsetplatform windows
    file tail {//foo/bar}
} {}
test cmdAH-9.27 {Tcl_FileObjCmd: tail} {
    testsetplatform mac
    file tail :
} :
test cmdAH-9.28 {Tcl_FileObjCmd: tail} {
    testsetplatform mac
    file tail :Foo
} Foo
test cmdAH-9.29 {Tcl_FileObjCmd: tail} {
    testsetplatform mac
    file tail Foo:
} {}
test cmdAH-9.30 {Tcl_FileObjCmd: tail} {
    testsetplatform mac
    file tail Foo:bar
} bar
test cmdAH-9.31 {Tcl_FileObjCmd: tail} {
    testsetplatform mac
    file tail :Foo:bar
} bar
test cmdAH-9.32 {Tcl_FileObjCmd: tail} {
    testsetplatform mac
    file tail ::
} ::
test cmdAH-9.33 {Tcl_FileObjCmd: tail} {
    testsetplatform mac
    file tail :::
} ::
test cmdAH-9.34 {Tcl_FileObjCmd: tail} {
    testsetplatform mac
    file tail /foo/bar/
} bar
test cmdAH-9.35 {Tcl_FileObjCmd: tail} {
    testsetplatform mac
    file tail /foo/bar
} bar
test cmdAH-9.36 {Tcl_FileObjCmd: tail} {
    testsetplatform mac
    file tail /foo
} {}
test cmdAH-9.37 {Tcl_FileObjCmd: tail} {
    testsetplatform mac
    file tail foo
} foo
test cmdAH-9.38 {Tcl_FileObjCmd: tail} {
    testsetplatform mac
    file tail ~:foo
} foo
test cmdAH-9.39 {Tcl_FileObjCmd: tail} {
    testsetplatform mac
    file tail ~bar:foo
} foo
test cmdAH-9.40 {Tcl_FileObjCmd: tail} {
    testsetplatform mac
    file tail ~bar/foo
} foo
test cmdAH-9.41 {Tcl_FileObjCmd: tail} {
    testsetplatform mac
    file tail ~/foo
} foo
test cmdAH-9.42 {Tcl_FileObjCmd: tail} {
    global env
    set temp $env(HOME)
    set env(HOME) "/home/test"
    testsetplatform unix
    set result [file tail ~]
    set env(HOME) $temp
    set result
} test
test cmdAH-9.43 {Tcl_FileObjCmd: tail} {
    global env
    set temp $env(HOME)
    set env(HOME) "~"
    testsetplatform unix
    set result [file tail ~]
    set env(HOME) $temp
    set result
} {}
test cmdAH-9.44 {Tcl_FileObjCmd: tail} {
    global env
    set temp $env(HOME)
    set env(HOME) "/home/test"
    testsetplatform windows
    set result [file tail ~]
    set env(HOME) $temp
    set result
} test
test cmdAH-9.45 {Tcl_FileObjCmd: tail} {
    global env
    set temp $env(HOME)
    set env(HOME) "/home/test"
    testsetplatform mac
    set result [file tail ~]
    set env(HOME) $temp
    set result
} test
test cmdAH-9.46 {Tcl_FileObjCmd: tail} {
    testsetplatform unix
    file tail {f.oo\bar/baz.bat}
} baz.bat
test cmdAH-9.47 {Tcl_FileObjCmd: tail} {
    testsetplatform windows
    file tail c:foo
} foo
test cmdAH-9.48 {Tcl_FileObjCmd: tail} {
    testsetplatform windows
    file tail c:
} {}
test cmdAH-9.49 {Tcl_FileObjCmd: tail} {
    testsetplatform windows
    file tail c:/foo
} foo
test cmdAH-9.50 {Tcl_FileObjCmd: tail} {
    testsetplatform windows
    file tail {c:/foo\bar}
} bar
test cmdAH-9.51 {Tcl_FileObjCmd: tail} {
    testsetplatform windows
    file tail {foo\bar}
} bar

# rootname

test cmdAH-10.1 {Tcl_FileObjCmd: rootname} {
    testsetplatform unix
    list [catch {file rootname a b} msg] $msg
} {1 {wrong # args: should be "file rootname name"}}
test cmdAH-10.2 {Tcl_FileObjCmd: rootname} {
    testsetplatform unix
    file rootname {}
} {}
test cmdAH-10.3 {Tcl_FileObjCmd: rootname} {
    testsetplatform unix
    file ro foo
} foo
test cmdAH-10.4 {Tcl_FileObjCmd: rootname} {
    testsetplatform unix
    file rootname foo.
} foo
test cmdAH-10.5 {Tcl_FileObjCmd: rootname} {
    testsetplatform unix
    file rootname .foo
} {}
test cmdAH-10.6 {Tcl_FileObjCmd: rootname} {
    testsetplatform unix
    file rootname abc.def
} abc
test cmdAH-10.7 {Tcl_FileObjCmd: rootname} {
    testsetplatform unix
    file rootname abc.def.ghi
} abc.def
test cmdAH-10.8 {Tcl_FileObjCmd: rootname} {
    testsetplatform unix
    file rootname a/b/c.d
} a/b/c
test cmdAH-10.9 {Tcl_FileObjCmd: rootname} {
    testsetplatform unix
    file rootname a/b.c/d
} a/b.c/d
test cmdAH-10.10 {Tcl_FileObjCmd: rootname} {
    testsetplatform unix
    file rootname a/b.c/
} a/b.c/
test cmdAH-10.11 {Tcl_FileObjCmd: rootname} {
    testsetplatform mac
    file ro foo
} foo
test cmdAH-10.12 {Tcl_FileObjCmd: rootname} {
    testsetplatform mac
    file rootname {}
} {}
test cmdAH-10.13 {Tcl_FileObjCmd: rootname} {
    testsetplatform mac
    file rootname foo.
} foo
test cmdAH-10.14 {Tcl_FileObjCmd: rootname} {
    testsetplatform mac
    file rootname .foo
} {}
test cmdAH-10.15 {Tcl_FileObjCmd: rootname} {
    testsetplatform mac
    file rootname abc.def
} abc
test cmdAH-10.16 {Tcl_FileObjCmd: rootname} {
    testsetplatform mac
    file rootname abc.def.ghi
} abc.def
test cmdAH-10.17 {Tcl_FileObjCmd: rootname} {
    testsetplatform mac
    file rootname a:b:c.d
} a:b:c
test cmdAH-10.18 {Tcl_FileObjCmd: rootname} {
    testsetplatform mac
    file rootname a:b.c:d
} a:b.c:d
test cmdAH-10.19 {Tcl_FileObjCmd: rootname} {
    testsetplatform mac
    file rootname a/b/c.d
} a/b/c
test cmdAH-10.20 {Tcl_FileObjCmd: rootname} {
    testsetplatform mac
    file rootname a/b.c/d
} a/b.c/d
test cmdAH-10.21 {Tcl_FileObjCmd: rootname} {
    testsetplatform mac
    file rootname /a.b
} /a
test cmdAH-10.22 {Tcl_FileObjCmd: rootname} {
    testsetplatform mac
    file rootname foo.c:
} foo.c:
test cmdAH-10.23 {Tcl_FileObjCmd: rootname} {
    testsetplatform windows
    file rootname {}
} {}
test cmdAH-10.24 {Tcl_FileObjCmd: rootname} {
    testsetplatform windows
    file ro foo
} foo
test cmdAH-10.25 {Tcl_FileObjCmd: rootname} {
    testsetplatform windows
    file rootname foo.
} foo
test cmdAH-10.26 {Tcl_FileObjCmd: rootname} {
    testsetplatform windows
    file rootname .foo
} {}
test cmdAH-10.27 {Tcl_FileObjCmd: rootname} {
    testsetplatform windows
    file rootname abc.def
} abc
test cmdAH-10.28 {Tcl_FileObjCmd: rootname} {
    testsetplatform windows
    file rootname abc.def.ghi
} abc.def
test cmdAH-10.29 {Tcl_FileObjCmd: rootname} {
    testsetplatform windows
    file rootname a/b/c.d
} a/b/c
test cmdAH-10.30 {Tcl_FileObjCmd: rootname} {
    testsetplatform windows
    file rootname a/b.c/d
} a/b.c/d
test cmdAH-10.31 {Tcl_FileObjCmd: rootname} {
    testsetplatform windows
    file rootname a\\b.c\\
} a\\b.c\\
test cmdAH-10.32 {Tcl_FileObjCmd: rootname} {
    testsetplatform windows
    file rootname a\\b\\c.d
} a\\b\\c
test cmdAH-10.33 {Tcl_FileObjCmd: rootname} {
    testsetplatform windows
    file rootname a\\b.c\\d
} a\\b.c\\d
test cmdAH-10.34 {Tcl_FileObjCmd: rootname} {
    testsetplatform windows
    file rootname a\\b.c\\
} a\\b.c\\
set num 35
foreach outer { {} a .a a. a.a } {
  foreach inner { {} a .a a. a.a } {
    set thing [format %s/%s $outer $inner]
;   test cmdAH-6.$num {Tcl_FileObjCmd: rootname and extension options} {
	testsetplatform unix
	format %s%s [file rootname $thing] [file ext $thing]
    } $thing
    set num [expr $num+1]
  }
}

# extension

test cmdAH-11.1 {Tcl_FileObjCmd: extension} {
    testsetplatform unix
    list [catch {file extension a b} msg] $msg
} {1 {wrong # args: should be "file extension name"}}
test cmdAH-11.2 {Tcl_FileObjCmd: extension} {
    testsetplatform unix
    file extension {}
} {}
test cmdAH-11.3 {Tcl_FileObjCmd: extension} {
    testsetplatform unix
    file ext foo
} {}
test cmdAH-11.4 {Tcl_FileObjCmd: extension} {
    testsetplatform unix
    file extension foo.
} .
test cmdAH-11.5 {Tcl_FileObjCmd: extension} {
    testsetplatform unix
    file extension .foo
} .foo
test cmdAH-11.6 {Tcl_FileObjCmd: extension} {
    testsetplatform unix
    file extension abc.def
} .def
test cmdAH-11.7 {Tcl_FileObjCmd: extension} {
    testsetplatform unix
    file extension abc.def.ghi
} .ghi
test cmdAH-11.8 {Tcl_FileObjCmd: extension} {
    testsetplatform unix
    file extension a/b/c.d
} .d
test cmdAH-11.9 {Tcl_FileObjCmd: extension} {
    testsetplatform unix
    file extension a/b.c/d
} {}
test cmdAH-11.10 {Tcl_FileObjCmd: extension} {
    testsetplatform unix
    file extension a/b.c/
} {}
test cmdAH-11.11 {Tcl_FileObjCmd: extension} {
    testsetplatform mac
    file ext foo
} {}
test cmdAH-11.12 {Tcl_FileObjCmd: extension} {
    testsetplatform mac
    file extension {}
} {}
test cmdAH-11.13 {Tcl_FileObjCmd: extension} {
    testsetplatform mac
    file extension foo.
} .
test cmdAH-11.14 {Tcl_FileObjCmd: extension} {
    testsetplatform mac
    file extension .foo
} .foo
test cmdAH-11.15 {Tcl_FileObjCmd: extension} {
    testsetplatform mac
    file extension abc.def
} .def
test cmdAH-11.16 {Tcl_FileObjCmd: extension} {
    testsetplatform mac
    file extension abc.def.ghi
} .ghi
test cmdAH-11.17 {Tcl_FileObjCmd: extension} {
    testsetplatform mac
    file extension a:b:c.d
} .d
test cmdAH-11.18 {Tcl_FileObjCmd: extension} {
    testsetplatform mac
    file extension a:b.c:d
} {}
test cmdAH-11.19 {Tcl_FileObjCmd: extension} {
    testsetplatform mac
    file extension a/b/c.d
} .d
test cmdAH-11.20 {Tcl_FileObjCmd: extension} {
    testsetplatform mac
    file extension a/b.c/d
} {}
test cmdAH-11.21 {Tcl_FileObjCmd: extension} {
    testsetplatform mac
    file extension /a.b
} .b
test cmdAH-11.22 {Tcl_FileObjCmd: extension} {
    testsetplatform mac
    file extension foo.c:
} {}
test cmdAH-11.23 {Tcl_FileObjCmd: extension} {
    testsetplatform windows
    file extension {}
} {}
test cmdAH-11.24 {Tcl_FileObjCmd: extension} {
    testsetplatform windows
    file ext foo
} {}
test cmdAH-11.25 {Tcl_FileObjCmd: extension} {
    testsetplatform windows
    file extension foo.
} .
test cmdAH-11.26 {Tcl_FileObjCmd: extension} {
    testsetplatform windows
    file extension .foo
} .foo
test cmdAH-11.27 {Tcl_FileObjCmd: extension} {
    testsetplatform windows
    file extension abc.def
} .def
test cmdAH-11.28 {Tcl_FileObjCmd: extension} {
    testsetplatform windows
    file extension abc.def.ghi
} .ghi
test cmdAH-11.29 {Tcl_FileObjCmd: extension} {
    testsetplatform windows
    file extension a/b/c.d
} .d
test cmdAH-11.30 {Tcl_FileObjCmd: extension} {
    testsetplatform windows
    file extension a/b.c/d
} {}
test cmdAH-11.31 {Tcl_FileObjCmd: extension} {
    testsetplatform windows
    file extension a\\b.c\\
} {}
test cmdAH-11.32 {Tcl_FileObjCmd: extension} {
    testsetplatform windows
    file extension a\\b\\c.d
} .d
test cmdAH-11.33 {Tcl_FileObjCmd: extension} {
    testsetplatform windows
    file extension a\\b.c\\d
} {}
test cmdAH-11.34 {Tcl_FileObjCmd: extension} {
    testsetplatform windows
    file extension a\\b.c\\
} {}
set num 35
foreach value {a..b a...b a.c..b ..b} result {.b .b .b .b} {
    foreach p {unix mac windows} {
;	test cmdAH-7.$num {Tcl_FileObjCmd: extension} "
	    testsetplatform $p
	    file extension $value
	" $result
	incr num
    }
}

# pathtype

test cmdAH-12.1 {Tcl_FileObjCmd: pathtype} {
    testsetplatform unix
    list [catch {file pathtype a b} msg] $msg
} {1 {wrong # args: should be "file pathtype name"}}
test cmdAH-12.2 {Tcl_FileObjCmd: pathtype} {
    testsetplatform unix
    file pathtype /a
} absolute
test cmdAH-12.3 {Tcl_FileObjCmd: pathtype} {
    testsetplatform unix
    file p a
} relative
test cmdAH-12.4 {Tcl_FileObjCmd: pathtype} {
    testsetplatform windows
    file pathtype c:a
} volumerelative

# split

test cmdAH-13.1 {Tcl_FileObjCmd: split} {
    testsetplatform unix
    list [catch {file split a b} msg] $msg
} {1 {wrong # args: should be "file split name"}}
test cmdAH-13.2 {Tcl_FileObjCmd: split} {
    testsetplatform unix
    file split a
} a
test cmdAH-13.3 {Tcl_FileObjCmd: split} {
    testsetplatform unix
    file split a/b
} {a b}

# join

test cmdAH-14.1 {Tcl_FileObjCmd: join} {
    testsetplatform unix
    file join a
} a
test cmdAH-14.2 {Tcl_FileObjCmd: join} {
    testsetplatform unix
    file join a b
} a/b
test cmdAH-14.3 {Tcl_FileObjCmd: join} {
    testsetplatform unix
    file join a b c d
} a/b/c/d

# error handling of Tcl_TranslateFileName

test cmdAH-15.1 {Tcl_FileObjCmd} {
    testsetplatform unix
    list [catch {file atime ~_bad_user} msg] $msg
} {1 {user "_bad_user" doesn't exist}}

testsetplatform $platform
}

# readable

set gorpfile [makeFile abcde gorp.file]
set dirfile [makeDirectory dir.file]

if {[info commands testchmod] == {}} {
    puts "This application hasn't been compiled with the \"testchmod\""
    puts "command, so I can't test Tcl_FileObjCmd etc."
} else {
test cmdAH-16.1 {Tcl_FileObjCmd: readable} {testchmod} {
    list [catch {file readable a b} msg] $msg
} {1 {wrong # args: should be "file readable name"}}
testchmod 0444 $gorpfile
test cmdAH-16.2 {Tcl_FileObjCmd: readable} {testchmod} {
    file readable $gorpfile
} 1
testchmod 0333 $gorpfile
test cmdAH-16.3 {Tcl_FileObjCmd: readable} {unixOnly notRoot testchmod} {
    file reada $gorpfile
} 0

# writable

test cmdAH-17.1 {Tcl_FileObjCmd: writable} {testchmod} {
    list [catch {file writable a b} msg] $msg
} {1 {wrong # args: should be "file writable name"}}
testchmod 0555 $gorpfile
test cmdAH-17.2 {Tcl_FileObjCmd: writable} {notRoot testchmod} {
    file writable $gorpfile
} 0
testchmod 0222 $gorpfile
test cmdAH-17.3 {Tcl_FileObjCmd: writable} {testchmod} {
    file writable $gorpfile
} 1
}

# executable

removeFile $gorpfile
removeDirectory $dirfile
set dirfile [makeDirectory dir.file]
set gorpfile [makeFile abcde gorp.file]

test cmdAH-18.1 {Tcl_FileObjCmd: executable} {testchmod} {
    list [catch {file executable a b} msg] $msg
} {1 {wrong # args: should be "file executable name"}}
test cmdAH-18.2 {Tcl_FileObjCmd: executable} {testchmod} {
    file executable $gorpfile
} 0
test cmdAH-18.3 {Tcl_FileObjCmd: executable} {unixOnly testchmod} {
    # Only on unix will setting the execute bit on a regular file
    # cause that file to be executable.   
    
    testchmod 0775 $gorpfile
    file exe $gorpfile
} 1

test cmdAH-18.4 {Tcl_FileObjCmd: executable} {macOnly testchmod} {
    # On mac, the only executable files are of type APPL.

    set x [file exe $gorpfile]    
    file attrib $gorpfile -type APPL
    lappend x [file exe $gorpfile]
} {0 1}
test cmdAH-18.5 {Tcl_FileObjCmd: executable} {pcOnly testchmod} {
    # On pc, must be a .exe, .com, etc.
    
    set x [file exe $gorpfile]
    set gorpexe [makeFile foo gorp.exe]
    lappend x [file exe $gorpexe]
    removeFile $gorpexe
    set x
} {0 1}
test cmdAH-18.6 {Tcl_FileObjCmd: executable} {testchmod} {
    # Directories are always executable.
    
    file exe $dirfile
} 1

removeDirectory $dirfile
removeFile $gorpfile
set linkfile [file join [temporaryDirectory] link.file]
file delete $linkfile

# exists

test cmdAH-19.1 {Tcl_FileObjCmd: exists} {
    list [catch {file exists a b} msg] $msg
} {1 {wrong # args: should be "file exists name"}}
test cmdAH-19.2 {Tcl_FileObjCmd: exists} {file exists $gorpfile} 0
test cmdAH-19.3 {Tcl_FileObjCmd: exists} {
    file exists [file join [temporaryDirectory] dir.file gorp.file]
} 0
catch {
    set gorpfile [makeFile abcde gorp.file]
    set dirfile [makeDirectory dir.file]
    set subgorp [makeFile 12345 [file join $dirfile gorp.file]]
}
test cmdAH-19.4 {Tcl_FileObjCmd: exists} {
    file exists $gorpfile
} 1
test cmdAH-19.5 {Tcl_FileObjCmd: exists} {
    file exists $subgorp
} 1

# nativename
if {[info commands testsetplatform] == {}} {
    puts "This application hasn't been compiled with the \"testsetplatform\""
    puts "command, so I can't test Tcl_FileObjCmd etc."
} else {
test cmdAH-19.6 {Tcl_FileObjCmd: nativename} {
    testsetplatform unix
    list [catch {file nativename a/b} msg] $msg [testsetplatform $platform]
} {0 a/b {}}
test cmdAH-19.7 {Tcl_FileObjCmd: nativename} {
    testsetplatform windows
    list [catch {file nativename a/b} msg] $msg [testsetplatform $platform]
} {0 {a\b} {}}
test cmdAH-19.8 {Tcl_FileObjCmd: nativename} {
    testsetplatform mac
    list [catch {file nativename a/b} msg] $msg [testsetplatform $platform]
} {0 :a:b {}}
}

test cmdAH-19.9 {Tcl_FileObjCmd: ~ : exists} {
    file exists ~nOsUcHuSeR
} 0
test cmdAH-19.10 {Tcl_FileObjCmd: ~ : nativename} {
    # should probably be 0 in fact...
    catch {file nativename ~nOsUcHuSeR}
} 1

# The test below has to be done in /tmp rather than the current
# directory in order to guarantee (?) a local file system:  some
# NFS file systems won't do the stuff below correctly.

test cmdAH-19.11 {Tcl_FileObjCmd: exists} {unixOnly notRoot} {
    file delete -force /tmp/tcl.foo.dir/file
    file delete -force /tmp/tcl.foo.dir
    makeDirectory /tmp/tcl.foo.dir
    makeFile 12345 /tmp/tcl.foo.dir/file
    file attributes /tmp/tcl.foo.dir -permissions 0000

    set result [file exists /tmp/tcl.foo.dir/file]

    file attributes /tmp/tcl.foo.dir -permissions 0775
    removeFile /tmp/tcl.foo.dir/file
    removeDirectory /tmp/tcl.foo.dir
    set result
} 0

# Stat related commands

catch {testsetplatform $platform}
removeFile $gorpfile
set gorpfile [makeFile "Test string" gorp.file]
catch {file attributes $gorpfile -permissions 0765}

# atime

set file [makeFile "data" touch.me]

test cmdAH-20.1 {Tcl_FileObjCmd: atime} {
    list [catch {file atime a b c} msg] $msg
} {1 {wrong # args: should be "file atime name ?time?"}}
test cmdAH-20.2 {Tcl_FileObjCmd: atime} {
    catch {unset stat}
    file stat $gorpfile stat
    list [expr {[file mtime $gorpfile] == $stat(mtime)}] \
	    [expr {[file atime $gorpfile] == $stat(atime)}]
} {1 1}
test cmdAH-20.3 {Tcl_FileObjCmd: atime} {
    string tolower [list [catch {file atime _bogus_} msg] \
	    $msg $errorCode]
} {1 {could not read "_bogus_": no such file or directory} {posix enoent {no such file or directory}}}
test cmdAH-20.4 {Tcl_FileObjCmd: atime} {
    list [catch {file atime $file notint} msg] $msg
} {1 {expected integer but got "notint"}}
test cmdAH-20.5 {Tcl_FileObjCmd: atime touch} {unixOrPc} {
    if {[string equal $tcl_platform(platform) "windows"]} {
	set old [pwd]
	cd $::tcltest::temporaryDirectory
	if {![string equal "NTFS" [testvolumetype]]} {
	    # Windows FAT doesn't understand atime, but NTFS does
	    # May also fail for Windows on NFS mounted disks
	    cd $old
	    return 1
	}
	cd $old
    }
    set atime [file atime $file]
    after 1100; # pause a sec to notice change in atime
    set newatime [clock seconds]
    set modatime [file atime $file $newatime]
    expr {$newatime == $modatime ? 1 : "$newatime != $modatime"}
} 1

removeFile touch.me
# isdirectory

test cmdAH-21.1 {Tcl_FileObjCmd: isdirectory} {
    list [catch {file isdirectory a b} msg] $msg
} {1 {wrong # args: should be "file isdirectory name"}}
test cmdAH-21.2 {Tcl_FileObjCmd: isdirectory} {
    file isdirectory $gorpfile
} 0
test cmdAH-21.3 {Tcl_FileObjCmd: isdirectory} {
    file isd $dirfile
} 1

# isfile

test cmdAH-22.1 {Tcl_FileObjCmd: isfile} {
    list [catch {file isfile a b} msg] $msg
} {1 {wrong # args: should be "file isfile name"}}
test cmdAH-22.2 {Tcl_FileObjCmd: isfile} {file isfile $gorpfile} 1
test cmdAH-22.3 {Tcl_FileObjCmd: isfile} {file isfile $dirfile} 0

# lstat and readlink:  don't run these tests everywhere, since not all
# sites will have symbolic links

catch {file link -symbolic $linkfile $gorpfile}
test cmdAH-23.1 {Tcl_FileObjCmd: lstat} {
    list [catch {file lstat a} msg] $msg
} {1 {wrong # args: should be "file lstat name varName"}}
test cmdAH-23.2 {Tcl_FileObjCmd: lstat} {
    list [catch {file lstat a b c} msg] $msg
} {1 {wrong # args: should be "file lstat name varName"}}
test cmdAH-23.3 {Tcl_FileObjCmd: lstat} {unixOnly nonPortable} {
    catch {unset stat}
    file lstat $linkfile stat
    lsort [array names stat]
} {atime ctime dev gid ino mode mtime nlink size type uid}
test cmdAH-23.4 {Tcl_FileObjCmd: lstat} {unixOnly nonPortable} {
    catch {unset stat}
    file lstat $linkfile stat
    list $stat(nlink) [expr $stat(mode)&0777] $stat(type)
} {1 511 link}
test cmdAH-23.5 {Tcl_FileObjCmd: lstat errors} {nonPortable} {
    string tolower [list [catch {file lstat _bogus_ stat} msg] \
	    $msg $errorCode]
} {1 {could not read "_bogus_": no such file or directory} {posix enoent {no such file or directory}}}
test cmdAH-23.6 {Tcl_FileObjCmd: lstat errors} {
    catch {unset x}
    set x 44
    list [catch {file lstat $gorpfile x} msg] $msg $errorCode
} {1 {can't set "x(dev)": variable isn't array} NONE}
catch {unset stat}

# mkdir

set dirA [file join [temporaryDirectory] a]
set dirB [file join [temporaryDirectory] a]
test cmdAH-23.7 {Tcl_FileObjCmd: mkdir} {
    catch {file delete -force $dirA}
    file mkdir $dirA
    set res [file isdirectory $dirA]
    file delete $dirA
    set res
} {1}
test cmdAH-23.8 {Tcl_FileObjCmd: mkdir} {
    catch {file delete -force $dirA}
    file mkdir $dirA/b
    set res [file isdirectory $dirA/b]
    file delete -force $dirA
    set res
} {1}
test cmdAH-23.9 {Tcl_FileObjCmd: mkdir} {
    catch {file delete -force $dirA}
    file mkdir $dirA/b/c
    set res [file isdirectory $dirA/b/c]
    file delete -force $dirA
    set res
} {1}
test cmdAH-23.10 {Tcl_FileObjCmd: mkdir} {
    catch {file delete -force $dirA}
    catch {file delete -force $dirB}
    file mkdir $dirA/b $dirB/a/c
    set res [list [file isdirectory $dirA/b] [file isdirectory $dirB/a/c]]
    file delete -force $dirA
    file delete -force $dirB
    set res
} {1 1}

# mtime 

set file [makeFile "data" touch.me]

test cmdAH-24.1 {Tcl_FileObjCmd: mtime} {
    list [catch {file mtime a b c} msg] $msg
} {1 {wrong # args: should be "file mtime name ?time?"}}
# Check (allowing for clock-skew and OS interrupts as best we can)
# that the change in mtime on a file being written is the time elapsed
# between writes.  Note that this can still fail on very busy systems
# if there are long preemptions between the writes and the reading of
# the clock, but there's not much you can do about that other than the
# completely horrible "keep on trying to write until you managed to do
# it all in less than a second."  - DKF
test cmdAH-24.2 {Tcl_FileObjCmd: mtime} {
    set f [open $gorpfile w]
    puts $f "More text"
    set localOld [clock seconds]
    close $f
    set old [file mtime $gorpfile]
    after 2000
    set f [open $gorpfile w]
    puts $f "More text"
    set localNew [clock seconds]
    close $f
    set new [file mtime $gorpfile]
    expr {
	($new > $old) && ($localNew > $localOld) &&
	(abs(($new-$old) - ($localNew-$localOld)) <= 1)
    }
} {1}
test cmdAH-24.3 {Tcl_FileObjCmd: mtime} {
    catch {unset stat}
    file stat $gorpfile stat
    list [expr {[file mtime $gorpfile] == $stat(mtime)}] \
	    [expr {[file atime $gorpfile] == $stat(atime)}]
} {1 1}
test cmdAH-24.4 {Tcl_FileObjCmd: mtime} {
    string tolower [list [catch {file mtime _bogus_} msg] $msg \
	    $errorCode]
} {1 {could not read "_bogus_": no such file or directory} {posix enoent {no such file or directory}}}
test cmdAH-24.5 {Tcl_FileObjCmd: mtime} {
    # Under Unix, use a file in /tmp to avoid clock skew due to NFS.
    # On other platforms, just use a file in the local directory.

    if {[string equal $tcl_platform(platform) "unix"]} {
	set name /tmp/tcl.test.[pid]
    } else {
	set name [file join [temporaryDirectory] tf]
    }

    # Make sure that a new file's time is correct.  10 seconds variance 
    # is allowed used due to slow networks or clock skew on a network drive.

    file delete -force $name
    close [open $name w]
    set a [expr abs([clock seconds]-[file mtime $name])<10]
    file delete $name
    set a
} {1}
test cmdAH-24.7 {Tcl_FileObjCmd: mtime} {
    list [catch {file mtime $file notint} msg] $msg
} {1 {expected integer but got "notint"}}
test cmdAH-24.8 {Tcl_FileObjCmd: mtime touch} {
    set mtime [file mtime $file]
    after 1100; # pause a sec to notice change in mtime
    set newmtime [clock seconds]
    set modmtime [file mtime $file $newmtime]
    expr {$newmtime == $modmtime ? 1 : "$newmtime != $modmtime"}
} 1
removeFile touch.me

# owned

test cmdAH-25.1 {Tcl_FileObjCmd: owned} {
    list [catch {file owned a b} msg] $msg
} {1 {wrong # args: should be "file owned name"}}
test cmdAH-25.2 {Tcl_FileObjCmd: owned} {
    file owned $gorpfile
} 1
test cmdAH-25.3 {Tcl_FileObjCmd: owned} {unixOnly notRoot} {
    file owned /
} 0

# readlink

test cmdAH-26.1 {Tcl_FileObjCmd: readlink} {
    list [catch {file readlink a b} msg] $msg
} {1 {wrong # args: should be "file readlink name"}}
test cmdAH-26.2 {Tcl_FileObjCmd: readlink} {unixOnly nonPortable} {
    file readlink $linkfile
} $gorpfile
test cmdAH-26.3 {Tcl_FileObjCmd: readlink errors} {unixOnly nonPortable} {
    list [catch {file readlink _bogus_} msg] [string tolower $msg] \
	    [string tolower $errorCode]
} {1 {could not readlink "_bogus_": no such file or directory} {posix enoent {no such file or directory}}}
test cmdAH-26.4 {Tcl_FileObjCmd: readlink errors} {macOnly nonPortable} {
    list [catch {file readlink _bogus_} msg] [string tolower $msg] \
	    [string tolower $errorCode]
} {1 {could not readlink "_bogus_": no such file or directory} {posix enoent {no such file or directory}}}
test cmdAH-26.5 {Tcl_FileObjCmd: readlink errors} {pcOnly nonPortable} {
    list [catch {file readlink _bogus_} msg] [string tolower $msg] \
	    [string tolower $errorCode]
} {1 {could not readlink "_bogus_": invalid argument} {posix einval {invalid argument}}}

# size

test cmdAH-27.1 {Tcl_FileObjCmd: size} {
    list [catch {file size a b} msg] $msg
} {1 {wrong # args: should be "file size name"}}
test cmdAH-27.2 {Tcl_FileObjCmd: size} {
    set oldsize [file size $gorpfile]
    set f [open $gorpfile a]
    fconfigure $f -translation lf -eofchar {}
    puts $f "More text"
    close $f
    expr {[file size $gorpfile] - $oldsize}
} {10}
test cmdAH-27.3 {Tcl_FileObjCmd: size} {
    string tolower [list [catch {file size _bogus_} msg] $msg \
	    $errorCode]
} {1 {could not read "_bogus_": no such file or directory} {posix enoent {no such file or directory}}}

# stat

catch {testsetplatform $platform}
removeFile $gorpfile
set gorpfile [makeFile "Test string" gorp.file]
catch {file attributes $gorpfile -permissions 0765}

test cmdAH-28.1 {Tcl_FileObjCmd: stat} {
    list [catch {file stat _bogus_} msg] $msg $errorCode
} {1 {wrong # args: should be "file stat name varName"} NONE}
test cmdAH-28.2 {Tcl_FileObjCmd: stat} {
    list [catch {file stat _bogus_ a b} msg] $msg $errorCode
} {1 {wrong # args: should be "file stat name varName"} NONE}
test cmdAH-28.3 {Tcl_FileObjCmd: stat} {
    catch {unset stat}
    file stat $gorpfile stat
    lsort [array names stat]
} {atime ctime dev gid ino mode mtime nlink size type uid}
test cmdAH-28.4 {Tcl_FileObjCmd: stat} {
    catch {unset stat}
    file stat $gorpfile stat
    list $stat(nlink) $stat(size) $stat(type)
} {1 12 file}
test cmdAH-28.5 {Tcl_FileObjCmd: stat} {unixOnly} {
    catch {unset stat}
    file stat $gorpfile stat
    expr $stat(mode)&0777
} {501}
test cmdAH-28.6 {Tcl_FileObjCmd: stat} {
    string tolower [list [catch {file stat _bogus_ stat} msg] \
	    $msg $errorCode]
} {1 {could not read "_bogus_": no such file or directory} {posix enoent {no such file or directory}}}
test cmdAH-28.7 {Tcl_FileObjCmd: stat} {
    catch {unset x}
    set x 44
    list [catch {file stat $gorpfile x} msg] $msg $errorCode
} {1 {can't set "x(dev)": variable isn't array} NONE}
test cmdAH-28.8 {Tcl_FileObjCmd: stat} {
    # Sign extension of purported unsigned short to int.

    set filename [makeFile "" foo.text]
    file stat $filename stat
    set x [expr {$stat(mode) > 0}]
    removeFile $filename
    set x
} 1
test cmdAH-28.9 {Tcl_FileObjCmd: stat} {pcOnly} {
    # stat of root directory was failing.
    # don't care about answer, just that test runs.

    # relative paths that resolve to root
    set old [pwd]
    cd c:/
    file stat c: stat	    
    file stat c:. stat
    file stat . stat
    cd $old

    file stat / stat
    file stat c:/ stat
    file stat c:/. stat
} {}
test cmdAH-28.10 {Tcl_FileObjCmd: stat} {pcOnly nonPortable} {
    # stat of root directory was failing.
    # don't care about answer, just that test runs.

    file stat //pop/$env(USERNAME) stat
    file stat //pop/$env(USERNAME)/ stat
    file stat //pop/$env(USERNAME)/. stat
} {}    
test cmdAH-28.11 {Tcl_FileObjCmd: stat} {pcOnly nonPortable} {
    # stat of network directory was returning id of current local drive.

    set old [pwd]
    cd c:/

    file stat //pop/$env(USERNAME) stat
    cd $old
    expr {$stat(dev) == 2}
} 0
test cmdAH-28.12 {Tcl_FileObjCmd: stat} {
    # stat(mode) with S_IFREG flag was returned as a negative number
    # if mode_t was a short instead of an unsigned short.

    set filename [makeFile "" foo.test]
    file stat $filename stat
    removeFile $filename
    expr {$stat(mode) > 0}
} 1
catch {unset stat}

# type

test cmdAH-29.1 {Tcl_FileObjCmd: type} {
    list [catch {file size a b} msg] $msg
} {1 {wrong # args: should be "file size name"}}
test cmdAH-29.2 {Tcl_FileObjCmd: type} {
    file type $dirfile
} directory
test cmdAH-29.3.0 {Tcl_FileObjCmd: delete removes link not file} {unixOnly nonPortable} {
    set exists [list [file exists $linkfile] [file exists $gorpfile]]
    file delete $linkfile
    set exists2	[list [file exists $linkfile] [file exists $gorpfile]]
    list $exists $exists2
} {{1 1} {0 1}}
test cmdAH-29.3 {Tcl_FileObjCmd: type} {
    file type $gorpfile
} file
test cmdAH-29.4 {Tcl_FileObjCmd: type} {unixOnly} {
    catch {file delete $linkfile}
    # Unlike [exec ln -s], [file link] requires an existing target
    file link -symbolic $linkfile $gorpfile
    set result [file type $linkfile]
    file delete $linkfile
    set result
} link
if {[string equal $tcl_platform(platform) "windows"]} {
    if {[string index $tcl_platform(osVersion) 0] >= 5 \
      && ([lindex [file system [temporaryDirectory]] 1] == "NTFS")} {
	tcltest::testConstraint linkDirectory 1
    } else {
	tcltest::testConstraint linkDirectory 0
    }
} else {
    tcltest::testConstraint linkDirectory 1
}
test cmdAH-29.4.1 {Tcl_FileObjCmd: type} {linkDirectory} {
    set tempdir [makeDirectory temp]
    set linkdir [file join [temporaryDirectory] link.dir]
    file link -symbolic $linkdir $tempdir
    set result [file type $linkdir]
    file delete $linkdir
    removeDirectory $tempdir
    set result
} link
test cmdAH-29.5 {Tcl_FileObjCmd: type} {
    string tolower [list [catch {file type _bogus_} msg] $msg $errorCode]
} {1 {could not read "_bogus_": no such file or directory} {posix enoent {no such file or directory}}}

# Error conditions

test cmdAH-30.1 {Tcl_FileObjCmd: error conditions} {
    list [catch {file gorp x} msg] $msg
} {1 {bad option "gorp": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, link, lstat, mtime, mkdir, nativename, normalize, owned, pathtype, readable, readlink, rename, rootname, separator, size, split, stat, system, tail, type, volumes, or writable}}
test cmdAH-30.2 {Tcl_FileObjCmd: error conditions} {
    list [catch {file ex x} msg] $msg
} {1 {ambiguous option "ex": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, link, lstat, mtime, mkdir, nativename, normalize, owned, pathtype, readable, readlink, rename, rootname, separator, size, split, stat, system, tail, type, volumes, or writable}}
test cmdAH-30.3 {Tcl_FileObjCmd: error conditions} {
    list [catch {file is x} msg] $msg
} {1 {ambiguous option "is": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, link, lstat, mtime, mkdir, nativename, normalize, owned, pathtype, readable, readlink, rename, rootname, separator, size, split, stat, system, tail, type, volumes, or writable}}
test cmdAH-30.4 {Tcl_FileObjCmd: error conditions} {
    list [catch {file z x} msg] $msg
} {1 {bad option "z": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, link, lstat, mtime, mkdir, nativename, normalize, owned, pathtype, readable, readlink, rename, rootname, separator, size, split, stat, system, tail, type, volumes, or writable}}
test cmdAH-30.5 {Tcl_FileObjCmd: error conditions} {
    list [catch {file read x} msg] $msg
} {1 {ambiguous option "read": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, link, lstat, mtime, mkdir, nativename, normalize, owned, pathtype, readable, readlink, rename, rootname, separator, size, split, stat, system, tail, type, volumes, or writable}}
test cmdAH-30.6 {Tcl_FileObjCmd: error conditions} {
    list [catch {file s x} msg] $msg
} {1 {ambiguous option "s": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, link, lstat, mtime, mkdir, nativename, normalize, owned, pathtype, readable, readlink, rename, rootname, separator, size, split, stat, system, tail, type, volumes, or writable}}
test cmdAH-30.7 {Tcl_FileObjCmd: error conditions} {
    list [catch {file t x} msg] $msg
} {1 {ambiguous option "t": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, link, lstat, mtime, mkdir, nativename, normalize, owned, pathtype, readable, readlink, rename, rootname, separator, size, split, stat, system, tail, type, volumes, or writable}}
test cmdAH-30.8 {Tcl_FileObjCmd: error conditions} {
    list [catch {file dirname ~woohgy} msg] $msg
} {1 {user "woohgy" doesn't exist}}

# channels
# In testing 'file channels', we need to make sure that a channel
# created in one interp isn't visible in another.

interp create simpleInterp
interp create -safe safeInterp
interp c
safeInterp expose file file

test cmdAH-31.1 {Tcl_FileObjCmd: channels, too many args} {
    list [catch {file channels a b} msg] $msg
} {1 {wrong # args: should be "file channels ?pattern?"}}
test cmdAH-31.2 {Tcl_FileObjCmd: channels, too many args} {
    # Normal interps start out with only the standard channels
    lsort [simpleInterp eval [list file chan]]
} [lsort {stderr stdout stdin}]
test cmdAH-31.3 {Tcl_FileObjCmd: channels, globbing} {
    string equal [file channels] [file channels *]
} {1}
test cmdAH-31.4 {Tcl_FileObjCmd: channels, globbing} {
    lsort [file channels std*]
} [lsort {stdout stderr stdin}]

set newFileId [open $gorpfile w]

test cmdAH-31.5 {Tcl_FileObjCmd: channels} {
    set res [file channels $newFileId]
    string equal $newFileId $res
} {1}
test cmdAH-31.6 {Tcl_FileObjCmd: channels in other interp} {
    # Safe interps start out with no channels
    safeInterp eval [list file channels]
} {}
test cmdAH-31.7 {Tcl_FileObjCmd: channels in other interp} {
    list [catch {safeInterp eval [list puts $newFileId "hello"]} msg] $msg
} [list 1 "can not find channel named \"$newFileId\""]

interp share {} $newFileId safeInterp
interp share {} stdout safeInterp

test cmdAH-31.8 {Tcl_FileObjCmd: channels in other interp} {
    # $newFileId should now be visible in both interps
    list [file channels $newFileId] \
	    [safeInterp eval [list file channels $newFileId]]
} [list $newFileId $newFileId]
test cmdAH-31.9 {Tcl_FileObjCmd: channels in other interp} {
    lsort [safeInterp eval [list file channels]]
} [lsort [list stdout $newFileId]]
test cmdAH-31.10 {Tcl_FileObjCmd: channels in other interp} {
    # we can now write to $newFileId from slave
    safeInterp eval [list puts $newFileId "hello"]
} {}

interp transfer {} $newFileId safeInterp

test cmdAH-31.11 {Tcl_FileObjCmd: channels in other interp} {
    # $newFileId should now be visible only in safeInterp
    list [file channels $newFileId] \
	    [safeInterp eval [list file channels $newFileId]]
} [list {} $newFileId]
test cmdAH-31.12 {Tcl_FileObjCmd: channels in other interp} {
    lsort [safeInterp eval [list file channels]]
} [lsort [list stdout $newFileId]]
test cmdAH-31.13 {Tcl_FileObjCmd: channels in other interp} {
    safeInterp eval [list close $newFileId]
    safeInterp eval [list file channels]
} {stdout}

# This shouldn't work, but just in case a test above failed...
catch {close $newFileId}

interp delete safeInterp
interp delete simpleInterp

# cleanup
catch {testsetplatform $platform}
catch {unset platform}

# Tcl_ForObjCmd is tested in for.test

catch {file attributes $dirfile -permissions 0777}
removeDirectory $dirfile
removeFile $gorpfile
# No idea how well [removeFile] copes with links...
file delete $linkfile

cd $cmdAHwd

::tcltest::cleanupTests
return
@


1.4
log
@touched all sources to ease next import
@
text
@d13 1
a13 1
# RCS: @@(#) $Id: cmdAH.test,v 1.6.8.2 2000/09/15 16:56:04 spolk Exp $
d16 1
a16 1
    package require tcltest
d20 2
d45 1
d47 3
a49 3
    file delete -force foo
    file mkdir foo
    cd foo
d52 1
a52 1
    file delete foo
d60 3
a62 3
    file delete -force foo
    file mkdir foo
    cd foo
d64 2
a65 2
    set result [string match [pwd] $oldpwd]
    file delete foo
d74 3
a76 3
    file delete -force foo
    file mkdir foo
    cd foo
d78 2
a79 2
    set result [string match [pwd] $oldpwd]
    file delete foo
d172 1
a172 1
} {1 {bad option "x": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, lstat, mtime, mkdir, nativename, owned, pathtype, readable, readlink, rename, rootname, size, split, stat, tail, type, volumes, or writable}}
d176 3
a178 1

d202 8
d213 8
a220 4
    catch {file delete -force foo.file}
    close [open foo.file w]
    list [catch {file attributes foo.file}] [file delete -force foo.file]
} {0 {}}
d1020 3
d1027 1
a1027 4
makeFile abcde gorp.file
makeDirectory dir.file

test cmdAH-16.1 {Tcl_FileObjCmd: readable} {
d1030 3
a1032 3
testchmod 444 gorp.file
test cmdAH-16.2 {Tcl_FileObjCmd: readable} {
    file readable gorp.file
d1034 3
a1036 3
testchmod 333 gorp.file
test cmdAH-16.3 {Tcl_FileObjCmd: readable} {unixOnly notRoot} {
    file reada gorp.file
d1041 1
a1041 1
test cmdAH-17.1 {Tcl_FileObjCmd: writable} {
d1044 3
a1046 3
testchmod 555 gorp.file
test cmdAH-17.2 {Tcl_FileObjCmd: writable} {notRoot} {
    file writable gorp.file
d1048 3
a1050 3
testchmod 222 gorp.file
test cmdAH-17.3 {Tcl_FileObjCmd: writable} {
    file writable gorp.file
d1052 1
d1056 4
a1059 3
file delete -force dir.file gorp.file
file mkdir dir.file
makeFile abcde gorp.file
d1061 1
a1061 1
test cmdAH-18.1 {Tcl_FileObjCmd: executable} {
d1064 2
a1065 2
test cmdAH-18.2 {Tcl_FileObjCmd: executable} {
    file executable gorp.file
d1067 1
a1067 1
test cmdAH-18.3 {Tcl_FileObjCmd: executable} {unixOnly} {
d1071 2
a1072 2
    testchmod 775 gorp.file
    file exe gorp.file
d1075 1
a1075 1
test cmdAH-18.4 {Tcl_FileObjCmd: executable} {macOnly} {
d1078 3
a1080 3
    set x [file exe gorp.file]    
    file attrib gorp.file -type APPL
    lappend x [file exe gorp.file]
d1082 1
a1082 1
test cmdAH-18.5 {Tcl_FileObjCmd: executable} {pcOnly} {
d1085 4
a1088 4
    set x [file exe gorp.file]
    makeFile foo gorp.exe
    lappend x [file exe gorp.exe]
    file delete gorp.exe
d1091 1
a1091 1
test cmdAH-18.6 {Tcl_FileObjCmd: executable} {
d1094 1
a1094 1
    file exe dir.file
d1097 4
a1100 4
file delete -force dir.file  
file delete gorp.file
file delete link.file
}
d1107 1
a1107 1
test cmdAH-19.2 {Tcl_FileObjCmd: exists} {file exists gorp.file} 0
d1109 1
a1109 1
    file exists [file join dir.file gorp.file]
d1112 3
a1114 3
    makeFile abcde gorp.file
    makeDirectory dir.file
    makeFile 12345 [file join dir.file gorp.file]
d1117 1
a1117 1
    file exists gorp.file
d1120 1
a1120 1
    file exists [file join dir.file gorp.file]
d1155 2
a1156 2
    removeFile /tmp/tcl.foo.dir/file
    removeDirectory /tmp/tcl.foo.dir
d1159 1
a1159 1
    exec chmod 000 /tmp/tcl.foo.dir
d1163 1
a1163 1
    exec chmod 775 /tmp/tcl.foo.dir
d1172 3
a1174 3
file delete gorp.file
makeFile "Test string" gorp.file
catch {exec chmod 765 gorp.file}
d1185 3
a1187 3
    file stat gorp.file stat
    list [expr {[file mtime gorp.file] == $stat(mtime)}] \
	    [expr {[file atime gorp.file] == $stat(atime)}]
d1196 1
a1196 1
test cmdAH-20.5 {Tcl_FileObjCmd: atime touch} {
d1211 2
a1212 1
    expr {$newatime==[file atime $file $newatime]}
d1215 1
d1222 1
a1222 1
    file isdirectory gorp.file
d1225 1
a1225 1
    file isd dir.file
d1233 2
a1234 2
test cmdAH-22.2 {Tcl_FileObjCmd: isfile} {file isfile gorp.file} 1
test cmdAH-22.3 {Tcl_FileObjCmd: isfile} {file isfile dir.file} 0
d1239 1
a1239 1
catch {exec ln -s gorp.file link.file}
d1248 1
a1248 1
    file lstat link.file stat
d1253 1
a1253 1
    file lstat link.file stat
d1263 1
a1263 1
    list [catch {file lstat gorp.file x} msg] $msg $errorCode
d1267 35
d1309 7
d1317 5
a1321 1
    set old [file mtime gorp.file]
d1323 1
a1323 1
    set f [open gorp.file w]
d1325 1
d1327 5
a1331 2
    set new [file mtime gorp.file]
    expr {($new > $old) && ($new <= ($old+5))}
d1335 3
a1337 3
    file stat gorp.file stat
    list [expr {[file mtime gorp.file] == $stat(mtime)}] \
	    [expr {[file atime gorp.file] == $stat(atime)}]
d1348 1
a1348 1
	 set name /tmp/tcl.test
d1350 1
a1350 1
	set name tf
d1369 2
a1370 1
    expr {$newmtime==[file mtime $file $newmtime]}
d1372 1
a1372 1

d1380 1
a1380 1
    file owned gorp.file
d1392 2
a1393 2
    file readlink link.file
} gorp.file
d1413 2
a1414 2
    set oldsize [file size gorp.file]
    set f [open gorp.file a]
d1418 1
a1418 1
    expr {[file size gorp.file] - $oldsize}
d1428 3
a1430 2
makeFile "Test string" gorp.file
catch {exec chmod 765 gorp.file}
d1440 1
a1440 1
    file stat gorp.file stat
d1445 1
a1445 1
    file stat gorp.file stat
d1450 1
a1450 1
    file stat gorp.file stat
d1460 1
a1460 1
    list [catch {file stat gorp.file x} msg] $msg $errorCode
d1465 2
a1466 2
    close [open foo.test w]
    file stat foo.test stat
d1468 1
a1468 1
    file delete foo.test
d1509 3
a1511 3
    close [open foo.test w]
    file stat foo.test stat
    file delete foo.test
a1517 2
file delete link.file

d1522 1
a1522 1
    file type dir.file
d1524 6
d1531 1
a1531 1
    file type gorp.file
d1533 25
a1557 4
test cmdAH-29.4 {Tcl_FileObjCmd: type} {unixOnly nonPortable} {
    exec ln -s a/b/c link.file
    set result [file type link.file]
    file delete link.file
d1568 1
a1568 1
} {1 {bad option "gorp": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, lstat, mtime, mkdir, nativename, owned, pathtype, readable, readlink, rename, rootname, size, split, stat, tail, type, volumes, or writable}}
d1571 1
a1571 1
} {1 {ambiguous option "ex": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, lstat, mtime, mkdir, nativename, owned, pathtype, readable, readlink, rename, rootname, size, split, stat, tail, type, volumes, or writable}}
d1574 1
a1574 1
} {1 {ambiguous option "is": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, lstat, mtime, mkdir, nativename, owned, pathtype, readable, readlink, rename, rootname, size, split, stat, tail, type, volumes, or writable}}
d1577 1
a1577 1
} {1 {bad option "z": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, lstat, mtime, mkdir, nativename, owned, pathtype, readable, readlink, rename, rootname, size, split, stat, tail, type, volumes, or writable}}
d1580 1
a1580 1
} {1 {ambiguous option "read": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, lstat, mtime, mkdir, nativename, owned, pathtype, readable, readlink, rename, rootname, size, split, stat, tail, type, volumes, or writable}}
d1583 1
a1583 1
} {1 {ambiguous option "s": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, lstat, mtime, mkdir, nativename, owned, pathtype, readable, readlink, rename, rootname, size, split, stat, tail, type, volumes, or writable}}
d1586 1
a1586 1
} {1 {ambiguous option "t": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, lstat, mtime, mkdir, nativename, owned, pathtype, readable, readlink, rename, rootname, size, split, stat, tail, type, volumes, or writable}}
d1592 7
d1604 4
a1607 3
    file chan
} {stderr stdout stdin}
test cmdAH-31.3 {Tcl_FileObjCmd: channels, too many args} {
d1610 9
a1618 6
test cmdAH-31.4 {Tcl_FileObjCmd: channels} {
    set old [file channels gorp.file]
    set f [open gorp.file w]
    set new [file channels file*]
    close $f
    string equal $f $new
d1620 44
d1671 5
a1675 4
catch {exec chmod 777 dir.file}
file delete -force dir.file
file delete gorp.file
file delete link.file
a1680 14














@


1.3
log
@touched all sources to ease next import
@
text
@@


1.3.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d13 1
a13 1
# RCS: @@(#) $Id: cmdAH.test,v 1.29 2002/07/11 08:25:24 dkf Exp $
d16 1
a16 1
    package require tcltest 2.1
a19 2
tcltest::testConstraint testchmod [string equal testchmod [info commands testchmod]]

a42 1
set foodir [file join [temporaryDirectory] foo]
d44 3
a46 3
    file delete -force $foodir
    file mkdir $foodir
    cd $foodir
d49 1
a49 1
    file delete $foodir
d57 3
a59 3
    file delete -force $foodir
    file mkdir $foodir
    cd $foodir
d61 2
a62 2
    set result [string equal [pwd] $oldpwd]
    file delete $foodir
d71 3
a73 3
    file delete -force $foodir
    file mkdir $foodir
    cd $foodir
d75 2
a76 2
    set result [string equal [pwd] $oldpwd]
    file delete $foodir
d169 1
a169 1
} {1 {bad option "x": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, link, lstat, mtime, mkdir, nativename, normalize, owned, pathtype, readable, readlink, rename, rootname, separator, size, split, stat, system, tail, type, volumes, or writable}}
d173 1
a173 3
test cmdAH-5.4 {Tcl_FileObjCmd} {
    list [catch {file exists ""} msg] $msg
} {0 0}
a196 8
test cmdAH-6.5 {cd} {unixOnly nonPortable} {
    set dir [pwd]
    cd /
    set res [pwd]
    cd $dir
    set res
} {/}

d200 4
a203 8
    set foofile [makeFile abcde foo.file]
    catch {file delete -force $foofile}
    close [open $foofile w]
    set res [catch {file attributes $foofile}]
    # We used [makeFile] so we undo with [removeFile]
    removeFile $foofile
    set res
} {0}
a1002 3
set gorpfile [makeFile abcde gorp.file]
set dirfile [makeDirectory dir.file]

d1007 4
a1010 1
test cmdAH-16.1 {Tcl_FileObjCmd: readable} {testchmod} {
d1013 3
a1015 3
testchmod 0444 $gorpfile
test cmdAH-16.2 {Tcl_FileObjCmd: readable} {testchmod} {
    file readable $gorpfile
d1017 3
a1019 3
testchmod 0333 $gorpfile
test cmdAH-16.3 {Tcl_FileObjCmd: readable} {unixOnly notRoot testchmod} {
    file reada $gorpfile
d1024 1
a1024 1
test cmdAH-17.1 {Tcl_FileObjCmd: writable} {testchmod} {
d1027 3
a1029 3
testchmod 0555 $gorpfile
test cmdAH-17.2 {Tcl_FileObjCmd: writable} {notRoot testchmod} {
    file writable $gorpfile
d1031 3
a1033 3
testchmod 0222 $gorpfile
test cmdAH-17.3 {Tcl_FileObjCmd: writable} {testchmod} {
    file writable $gorpfile
a1034 1
}
d1038 3
a1040 4
removeFile $gorpfile
removeDirectory $dirfile
set dirfile [makeDirectory dir.file]
set gorpfile [makeFile abcde gorp.file]
d1042 1
a1042 1
test cmdAH-18.1 {Tcl_FileObjCmd: executable} {testchmod} {
d1045 2
a1046 2
test cmdAH-18.2 {Tcl_FileObjCmd: executable} {testchmod} {
    file executable $gorpfile
d1048 1
a1048 1
test cmdAH-18.3 {Tcl_FileObjCmd: executable} {unixOnly testchmod} {
d1052 2
a1053 2
    testchmod 0775 $gorpfile
    file exe $gorpfile
d1056 1
a1056 1
test cmdAH-18.4 {Tcl_FileObjCmd: executable} {macOnly testchmod} {
d1059 3
a1061 3
    set x [file exe $gorpfile]    
    file attrib $gorpfile -type APPL
    lappend x [file exe $gorpfile]
d1063 1
a1063 1
test cmdAH-18.5 {Tcl_FileObjCmd: executable} {pcOnly testchmod} {
d1066 4
a1069 4
    set x [file exe $gorpfile]
    set gorpexe [makeFile foo gorp.exe]
    lappend x [file exe $gorpexe]
    removeFile $gorpexe
d1072 1
a1072 1
test cmdAH-18.6 {Tcl_FileObjCmd: executable} {testchmod} {
d1075 1
a1075 1
    file exe $dirfile
d1078 4
a1081 4
removeDirectory $dirfile
removeFile $gorpfile
set linkfile [file join [temporaryDirectory] link.file]
file delete $linkfile
d1088 1
a1088 1
test cmdAH-19.2 {Tcl_FileObjCmd: exists} {file exists $gorpfile} 0
d1090 1
a1090 1
    file exists [file join [temporaryDirectory] dir.file gorp.file]
d1093 3
a1095 3
    set gorpfile [makeFile abcde gorp.file]
    set dirfile [makeDirectory dir.file]
    set subgorp [makeFile 12345 [file join $dirfile gorp.file]]
d1098 1
a1098 1
    file exists $gorpfile
d1101 1
a1101 1
    file exists $subgorp
d1136 2
a1137 2
    file delete -force /tmp/tcl.foo.dir/file
    file delete -force /tmp/tcl.foo.dir
d1140 1
a1140 1
    file attributes /tmp/tcl.foo.dir -permissions 0000
d1144 1
a1144 1
    file attributes /tmp/tcl.foo.dir -permissions 0775
d1153 3
a1155 3
removeFile $gorpfile
set gorpfile [makeFile "Test string" gorp.file]
catch {file attributes $gorpfile -permissions 0765}
d1166 3
a1168 3
    file stat $gorpfile stat
    list [expr {[file mtime $gorpfile] == $stat(mtime)}] \
	    [expr {[file atime $gorpfile] == $stat(atime)}]
d1177 1
a1177 1
test cmdAH-20.5 {Tcl_FileObjCmd: atime touch} {unixOrPc} {
d1192 1
a1192 2
    set modatime [file atime $file $newatime]
    expr {$newatime == $modatime ? 1 : "$newatime != $modatime"}
a1194 1
removeFile touch.me
d1201 1
a1201 1
    file isdirectory $gorpfile
d1204 1
a1204 1
    file isd $dirfile
d1212 2
a1213 2
test cmdAH-22.2 {Tcl_FileObjCmd: isfile} {file isfile $gorpfile} 1
test cmdAH-22.3 {Tcl_FileObjCmd: isfile} {file isfile $dirfile} 0
d1218 1
a1218 1
catch {file link -symbolic $linkfile $gorpfile}
d1227 1
a1227 1
    file lstat $linkfile stat
d1232 1
a1232 1
    file lstat $linkfile stat
d1242 1
a1242 1
    list [catch {file lstat $gorpfile x} msg] $msg $errorCode
a1245 35
# mkdir

set dirA [file join [temporaryDirectory] a]
set dirB [file join [temporaryDirectory] a]
test cmdAH-23.7 {Tcl_FileObjCmd: mkdir} {
    catch {file delete -force $dirA}
    file mkdir $dirA
    set res [file isdirectory $dirA]
    file delete $dirA
    set res
} {1}
test cmdAH-23.8 {Tcl_FileObjCmd: mkdir} {
    catch {file delete -force $dirA}
    file mkdir $dirA/b
    set res [file isdirectory $dirA/b]
    file delete -force $dirA
    set res
} {1}
test cmdAH-23.9 {Tcl_FileObjCmd: mkdir} {
    catch {file delete -force $dirA}
    file mkdir $dirA/b/c
    set res [file isdirectory $dirA/b/c]
    file delete -force $dirA
    set res
} {1}
test cmdAH-23.10 {Tcl_FileObjCmd: mkdir} {
    catch {file delete -force $dirA}
    catch {file delete -force $dirB}
    file mkdir $dirA/b $dirB/a/c
    set res [list [file isdirectory $dirA/b] [file isdirectory $dirB/a/c]]
    file delete -force $dirA
    file delete -force $dirB
    set res
} {1 1}

a1252 7
# Check (allowing for clock-skew and OS interrupts as best we can)
# that the change in mtime on a file being written is the time elapsed
# between writes.  Note that this can still fail on very busy systems
# if there are long preemptions between the writes and the reading of
# the clock, but there's not much you can do about that other than the
# completely horrible "keep on trying to write until you managed to do
# it all in less than a second."  - DKF
d1254 1
a1254 5
    set f [open $gorpfile w]
    puts $f "More text"
    set localOld [clock seconds]
    close $f
    set old [file mtime $gorpfile]
d1256 1
a1256 1
    set f [open $gorpfile w]
a1257 1
    set localNew [clock seconds]
d1259 2
a1260 5
    set new [file mtime $gorpfile]
    expr {
	($new > $old) && ($localNew > $localOld) &&
	(abs(($new-$old) - ($localNew-$localOld)) <= 1)
    }
d1264 3
a1266 3
    file stat $gorpfile stat
    list [expr {[file mtime $gorpfile] == $stat(mtime)}] \
	    [expr {[file atime $gorpfile] == $stat(atime)}]
d1277 1
a1277 1
	set name /tmp/tcl.test.[pid]
d1279 1
a1279 1
	set name [file join [temporaryDirectory] tf]
d1298 1
a1298 2
    set modmtime [file mtime $file $newmtime]
    expr {$newmtime == $modmtime ? 1 : "$newmtime != $modmtime"}
d1300 1
a1300 1
removeFile touch.me
d1308 1
a1308 1
    file owned $gorpfile
d1320 2
a1321 2
    file readlink $linkfile
} $gorpfile
d1341 2
a1342 2
    set oldsize [file size $gorpfile]
    set f [open $gorpfile a]
d1346 1
a1346 1
    expr {[file size $gorpfile] - $oldsize}
d1356 2
a1357 3
removeFile $gorpfile
set gorpfile [makeFile "Test string" gorp.file]
catch {file attributes $gorpfile -permissions 0765}
d1367 1
a1367 1
    file stat $gorpfile stat
d1372 1
a1372 1
    file stat $gorpfile stat
d1377 1
a1377 1
    file stat $gorpfile stat
d1387 1
a1387 1
    list [catch {file stat $gorpfile x} msg] $msg $errorCode
d1392 2
a1393 2
    set filename [makeFile "" foo.text]
    file stat $filename stat
d1395 1
a1395 1
    removeFile $filename
d1436 3
a1438 3
    set filename [makeFile "" foo.test]
    file stat $filename stat
    removeFile $filename
d1445 2
d1451 1
a1451 1
    file type $dirfile
a1452 6
test cmdAH-29.3.0 {Tcl_FileObjCmd: delete removes link not file} {unixOnly nonPortable} {
    set exists [list [file exists $linkfile] [file exists $gorpfile]]
    file delete $linkfile
    set exists2	[list [file exists $linkfile] [file exists $gorpfile]]
    list $exists $exists2
} {{1 1} {0 1}}
d1454 1
a1454 1
    file type $gorpfile
d1456 4
a1459 25
test cmdAH-29.4 {Tcl_FileObjCmd: type} {unixOnly} {
    catch {file delete $linkfile}
    # Unlike [exec ln -s], [file link] requires an existing target
    file link -symbolic $linkfile $gorpfile
    set result [file type $linkfile]
    file delete $linkfile
    set result
} link
if {[string equal $tcl_platform(platform) "windows"]} {
    if {[string index $tcl_platform(osVersion) 0] >= 5 \
      && ([lindex [file system [temporaryDirectory]] 1] == "NTFS")} {
	tcltest::testConstraint linkDirectory 1
    } else {
	tcltest::testConstraint linkDirectory 0
    }
} else {
    tcltest::testConstraint linkDirectory 1
}
test cmdAH-29.4.1 {Tcl_FileObjCmd: type} {linkDirectory} {
    set tempdir [makeDirectory temp]
    set linkdir [file join [temporaryDirectory] link.dir]
    file link -symbolic $linkdir $tempdir
    set result [file type $linkdir]
    file delete $linkdir
    removeDirectory $tempdir
d1470 1
a1470 1
} {1 {bad option "gorp": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, link, lstat, mtime, mkdir, nativename, normalize, owned, pathtype, readable, readlink, rename, rootname, separator, size, split, stat, system, tail, type, volumes, or writable}}
d1473 1
a1473 1
} {1 {ambiguous option "ex": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, link, lstat, mtime, mkdir, nativename, normalize, owned, pathtype, readable, readlink, rename, rootname, separator, size, split, stat, system, tail, type, volumes, or writable}}
d1476 1
a1476 1
} {1 {ambiguous option "is": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, link, lstat, mtime, mkdir, nativename, normalize, owned, pathtype, readable, readlink, rename, rootname, separator, size, split, stat, system, tail, type, volumes, or writable}}
d1479 1
a1479 1
} {1 {bad option "z": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, link, lstat, mtime, mkdir, nativename, normalize, owned, pathtype, readable, readlink, rename, rootname, separator, size, split, stat, system, tail, type, volumes, or writable}}
d1482 1
a1482 1
} {1 {ambiguous option "read": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, link, lstat, mtime, mkdir, nativename, normalize, owned, pathtype, readable, readlink, rename, rootname, separator, size, split, stat, system, tail, type, volumes, or writable}}
d1485 1
a1485 1
} {1 {ambiguous option "s": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, link, lstat, mtime, mkdir, nativename, normalize, owned, pathtype, readable, readlink, rename, rootname, separator, size, split, stat, system, tail, type, volumes, or writable}}
d1488 1
a1488 1
} {1 {ambiguous option "t": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, link, lstat, mtime, mkdir, nativename, normalize, owned, pathtype, readable, readlink, rename, rootname, separator, size, split, stat, system, tail, type, volumes, or writable}}
a1493 7
# In testing 'file channels', we need to make sure that a channel
# created in one interp isn't visible in another.

interp create simpleInterp
interp create -safe safeInterp
interp c
safeInterp expose file file
d1499 3
a1501 4
    # Normal interps start out with only the standard channels
    lsort [simpleInterp eval [list file chan]]
} [lsort {stderr stdout stdin}]
test cmdAH-31.3 {Tcl_FileObjCmd: channels, globbing} {
d1504 6
a1509 9
test cmdAH-31.4 {Tcl_FileObjCmd: channels, globbing} {
    lsort [file channels std*]
} [lsort {stdout stderr stdin}]

set newFileId [open $gorpfile w]

test cmdAH-31.5 {Tcl_FileObjCmd: channels} {
    set res [file channels $newFileId]
    string equal $newFileId $res
a1510 44
test cmdAH-31.6 {Tcl_FileObjCmd: channels in other interp} {
    # Safe interps start out with no channels
    safeInterp eval [list file channels]
} {}
test cmdAH-31.7 {Tcl_FileObjCmd: channels in other interp} {
    list [catch {safeInterp eval [list puts $newFileId "hello"]} msg] $msg
} [list 1 "can not find channel named \"$newFileId\""]

interp share {} $newFileId safeInterp
interp share {} stdout safeInterp

test cmdAH-31.8 {Tcl_FileObjCmd: channels in other interp} {
    # $newFileId should now be visible in both interps
    list [file channels $newFileId] \
	    [safeInterp eval [list file channels $newFileId]]
} [list $newFileId $newFileId]
test cmdAH-31.9 {Tcl_FileObjCmd: channels in other interp} {
    lsort [safeInterp eval [list file channels]]
} [lsort [list stdout $newFileId]]
test cmdAH-31.10 {Tcl_FileObjCmd: channels in other interp} {
    # we can now write to $newFileId from slave
    safeInterp eval [list puts $newFileId "hello"]
} {}

interp transfer {} $newFileId safeInterp

test cmdAH-31.11 {Tcl_FileObjCmd: channels in other interp} {
    # $newFileId should now be visible only in safeInterp
    list [file channels $newFileId] \
	    [safeInterp eval [list file channels $newFileId]]
} [list {} $newFileId]
test cmdAH-31.12 {Tcl_FileObjCmd: channels in other interp} {
    lsort [safeInterp eval [list file channels]]
} [lsort [list stdout $newFileId]]
test cmdAH-31.13 {Tcl_FileObjCmd: channels in other interp} {
    safeInterp eval [list close $newFileId]
    safeInterp eval [list file channels]
} {stdout}

# This shouldn't work, but just in case a test above failed...
catch {close $newFileId}

interp delete safeInterp
interp delete simpleInterp
d1518 4
a1521 5
catch {file attributes $dirfile -permissions 0777}
removeDirectory $dirfile
removeFile $gorpfile
# No idea how well [removeFile] copes with links...
file delete $linkfile
d1527 14
@


1.3.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@d13 1
a13 1
# RCS: @@(#) $Id: cmdAH.test,v 1.29 2002/07/11 08:25:24 dkf Exp $
d16 1
a16 1
    package require tcltest 2.1
a19 2
tcltest::testConstraint testchmod [string equal testchmod [info commands testchmod]]

a42 1
set foodir [file join [temporaryDirectory] foo]
d44 3
a46 3
    file delete -force $foodir
    file mkdir $foodir
    cd $foodir
d49 1
a49 1
    file delete $foodir
d57 3
a59 3
    file delete -force $foodir
    file mkdir $foodir
    cd $foodir
d61 2
a62 2
    set result [string equal [pwd] $oldpwd]
    file delete $foodir
d71 3
a73 3
    file delete -force $foodir
    file mkdir $foodir
    cd $foodir
d75 2
a76 2
    set result [string equal [pwd] $oldpwd]
    file delete $foodir
d169 1
a169 1
} {1 {bad option "x": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, link, lstat, mtime, mkdir, nativename, normalize, owned, pathtype, readable, readlink, rename, rootname, separator, size, split, stat, system, tail, type, volumes, or writable}}
d173 1
a173 3
test cmdAH-5.4 {Tcl_FileObjCmd} {
    list [catch {file exists ""} msg] $msg
} {0 0}
a196 8
test cmdAH-6.5 {cd} {unixOnly nonPortable} {
    set dir [pwd]
    cd /
    set res [pwd]
    cd $dir
    set res
} {/}

d200 4
a203 8
    set foofile [makeFile abcde foo.file]
    catch {file delete -force $foofile}
    close [open $foofile w]
    set res [catch {file attributes $foofile}]
    # We used [makeFile] so we undo with [removeFile]
    removeFile $foofile
    set res
} {0}
a1002 3
set gorpfile [makeFile abcde gorp.file]
set dirfile [makeDirectory dir.file]

d1007 4
a1010 1
test cmdAH-16.1 {Tcl_FileObjCmd: readable} {testchmod} {
d1013 3
a1015 3
testchmod 0444 $gorpfile
test cmdAH-16.2 {Tcl_FileObjCmd: readable} {testchmod} {
    file readable $gorpfile
d1017 3
a1019 3
testchmod 0333 $gorpfile
test cmdAH-16.3 {Tcl_FileObjCmd: readable} {unixOnly notRoot testchmod} {
    file reada $gorpfile
d1024 1
a1024 1
test cmdAH-17.1 {Tcl_FileObjCmd: writable} {testchmod} {
d1027 3
a1029 3
testchmod 0555 $gorpfile
test cmdAH-17.2 {Tcl_FileObjCmd: writable} {notRoot testchmod} {
    file writable $gorpfile
d1031 3
a1033 3
testchmod 0222 $gorpfile
test cmdAH-17.3 {Tcl_FileObjCmd: writable} {testchmod} {
    file writable $gorpfile
a1034 1
}
d1038 3
a1040 4
removeFile $gorpfile
removeDirectory $dirfile
set dirfile [makeDirectory dir.file]
set gorpfile [makeFile abcde gorp.file]
d1042 1
a1042 1
test cmdAH-18.1 {Tcl_FileObjCmd: executable} {testchmod} {
d1045 2
a1046 2
test cmdAH-18.2 {Tcl_FileObjCmd: executable} {testchmod} {
    file executable $gorpfile
d1048 1
a1048 1
test cmdAH-18.3 {Tcl_FileObjCmd: executable} {unixOnly testchmod} {
d1052 2
a1053 2
    testchmod 0775 $gorpfile
    file exe $gorpfile
d1056 1
a1056 1
test cmdAH-18.4 {Tcl_FileObjCmd: executable} {macOnly testchmod} {
d1059 3
a1061 3
    set x [file exe $gorpfile]    
    file attrib $gorpfile -type APPL
    lappend x [file exe $gorpfile]
d1063 1
a1063 1
test cmdAH-18.5 {Tcl_FileObjCmd: executable} {pcOnly testchmod} {
d1066 4
a1069 4
    set x [file exe $gorpfile]
    set gorpexe [makeFile foo gorp.exe]
    lappend x [file exe $gorpexe]
    removeFile $gorpexe
d1072 1
a1072 1
test cmdAH-18.6 {Tcl_FileObjCmd: executable} {testchmod} {
d1075 1
a1075 1
    file exe $dirfile
d1078 4
a1081 4
removeDirectory $dirfile
removeFile $gorpfile
set linkfile [file join [temporaryDirectory] link.file]
file delete $linkfile
d1088 1
a1088 1
test cmdAH-19.2 {Tcl_FileObjCmd: exists} {file exists $gorpfile} 0
d1090 1
a1090 1
    file exists [file join [temporaryDirectory] dir.file gorp.file]
d1093 3
a1095 3
    set gorpfile [makeFile abcde gorp.file]
    set dirfile [makeDirectory dir.file]
    set subgorp [makeFile 12345 [file join $dirfile gorp.file]]
d1098 1
a1098 1
    file exists $gorpfile
d1101 1
a1101 1
    file exists $subgorp
d1136 2
a1137 2
    file delete -force /tmp/tcl.foo.dir/file
    file delete -force /tmp/tcl.foo.dir
d1140 1
a1140 1
    file attributes /tmp/tcl.foo.dir -permissions 0000
d1144 1
a1144 1
    file attributes /tmp/tcl.foo.dir -permissions 0775
d1153 3
a1155 3
removeFile $gorpfile
set gorpfile [makeFile "Test string" gorp.file]
catch {file attributes $gorpfile -permissions 0765}
d1166 3
a1168 3
    file stat $gorpfile stat
    list [expr {[file mtime $gorpfile] == $stat(mtime)}] \
	    [expr {[file atime $gorpfile] == $stat(atime)}]
d1177 1
a1177 1
test cmdAH-20.5 {Tcl_FileObjCmd: atime touch} {unixOrPc} {
d1192 1
a1192 2
    set modatime [file atime $file $newatime]
    expr {$newatime == $modatime ? 1 : "$newatime != $modatime"}
a1194 1
removeFile touch.me
d1201 1
a1201 1
    file isdirectory $gorpfile
d1204 1
a1204 1
    file isd $dirfile
d1212 2
a1213 2
test cmdAH-22.2 {Tcl_FileObjCmd: isfile} {file isfile $gorpfile} 1
test cmdAH-22.3 {Tcl_FileObjCmd: isfile} {file isfile $dirfile} 0
d1218 1
a1218 1
catch {file link -symbolic $linkfile $gorpfile}
d1227 1
a1227 1
    file lstat $linkfile stat
d1232 1
a1232 1
    file lstat $linkfile stat
d1242 1
a1242 1
    list [catch {file lstat $gorpfile x} msg] $msg $errorCode
a1245 35
# mkdir

set dirA [file join [temporaryDirectory] a]
set dirB [file join [temporaryDirectory] a]
test cmdAH-23.7 {Tcl_FileObjCmd: mkdir} {
    catch {file delete -force $dirA}
    file mkdir $dirA
    set res [file isdirectory $dirA]
    file delete $dirA
    set res
} {1}
test cmdAH-23.8 {Tcl_FileObjCmd: mkdir} {
    catch {file delete -force $dirA}
    file mkdir $dirA/b
    set res [file isdirectory $dirA/b]
    file delete -force $dirA
    set res
} {1}
test cmdAH-23.9 {Tcl_FileObjCmd: mkdir} {
    catch {file delete -force $dirA}
    file mkdir $dirA/b/c
    set res [file isdirectory $dirA/b/c]
    file delete -force $dirA
    set res
} {1}
test cmdAH-23.10 {Tcl_FileObjCmd: mkdir} {
    catch {file delete -force $dirA}
    catch {file delete -force $dirB}
    file mkdir $dirA/b $dirB/a/c
    set res [list [file isdirectory $dirA/b] [file isdirectory $dirB/a/c]]
    file delete -force $dirA
    file delete -force $dirB
    set res
} {1 1}

a1252 7
# Check (allowing for clock-skew and OS interrupts as best we can)
# that the change in mtime on a file being written is the time elapsed
# between writes.  Note that this can still fail on very busy systems
# if there are long preemptions between the writes and the reading of
# the clock, but there's not much you can do about that other than the
# completely horrible "keep on trying to write until you managed to do
# it all in less than a second."  - DKF
d1254 1
a1254 5
    set f [open $gorpfile w]
    puts $f "More text"
    set localOld [clock seconds]
    close $f
    set old [file mtime $gorpfile]
d1256 1
a1256 1
    set f [open $gorpfile w]
a1257 1
    set localNew [clock seconds]
d1259 2
a1260 5
    set new [file mtime $gorpfile]
    expr {
	($new > $old) && ($localNew > $localOld) &&
	(abs(($new-$old) - ($localNew-$localOld)) <= 1)
    }
d1264 3
a1266 3
    file stat $gorpfile stat
    list [expr {[file mtime $gorpfile] == $stat(mtime)}] \
	    [expr {[file atime $gorpfile] == $stat(atime)}]
d1277 1
a1277 1
	set name /tmp/tcl.test.[pid]
d1279 1
a1279 1
	set name [file join [temporaryDirectory] tf]
d1298 1
a1298 2
    set modmtime [file mtime $file $newmtime]
    expr {$newmtime == $modmtime ? 1 : "$newmtime != $modmtime"}
d1300 1
a1300 1
removeFile touch.me
d1308 1
a1308 1
    file owned $gorpfile
d1320 2
a1321 2
    file readlink $linkfile
} $gorpfile
d1341 2
a1342 2
    set oldsize [file size $gorpfile]
    set f [open $gorpfile a]
d1346 1
a1346 1
    expr {[file size $gorpfile] - $oldsize}
d1356 2
a1357 3
removeFile $gorpfile
set gorpfile [makeFile "Test string" gorp.file]
catch {file attributes $gorpfile -permissions 0765}
d1367 1
a1367 1
    file stat $gorpfile stat
d1372 1
a1372 1
    file stat $gorpfile stat
d1377 1
a1377 1
    file stat $gorpfile stat
d1387 1
a1387 1
    list [catch {file stat $gorpfile x} msg] $msg $errorCode
d1392 2
a1393 2
    set filename [makeFile "" foo.text]
    file stat $filename stat
d1395 1
a1395 1
    removeFile $filename
d1436 3
a1438 3
    set filename [makeFile "" foo.test]
    file stat $filename stat
    removeFile $filename
d1445 2
d1451 1
a1451 1
    file type $dirfile
a1452 6
test cmdAH-29.3.0 {Tcl_FileObjCmd: delete removes link not file} {unixOnly nonPortable} {
    set exists [list [file exists $linkfile] [file exists $gorpfile]]
    file delete $linkfile
    set exists2	[list [file exists $linkfile] [file exists $gorpfile]]
    list $exists $exists2
} {{1 1} {0 1}}
d1454 1
a1454 1
    file type $gorpfile
d1456 4
a1459 25
test cmdAH-29.4 {Tcl_FileObjCmd: type} {unixOnly} {
    catch {file delete $linkfile}
    # Unlike [exec ln -s], [file link] requires an existing target
    file link -symbolic $linkfile $gorpfile
    set result [file type $linkfile]
    file delete $linkfile
    set result
} link
if {[string equal $tcl_platform(platform) "windows"]} {
    if {[string index $tcl_platform(osVersion) 0] >= 5 \
      && ([lindex [file system [temporaryDirectory]] 1] == "NTFS")} {
	tcltest::testConstraint linkDirectory 1
    } else {
	tcltest::testConstraint linkDirectory 0
    }
} else {
    tcltest::testConstraint linkDirectory 1
}
test cmdAH-29.4.1 {Tcl_FileObjCmd: type} {linkDirectory} {
    set tempdir [makeDirectory temp]
    set linkdir [file join [temporaryDirectory] link.dir]
    file link -symbolic $linkdir $tempdir
    set result [file type $linkdir]
    file delete $linkdir
    removeDirectory $tempdir
d1470 1
a1470 1
} {1 {bad option "gorp": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, link, lstat, mtime, mkdir, nativename, normalize, owned, pathtype, readable, readlink, rename, rootname, separator, size, split, stat, system, tail, type, volumes, or writable}}
d1473 1
a1473 1
} {1 {ambiguous option "ex": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, link, lstat, mtime, mkdir, nativename, normalize, owned, pathtype, readable, readlink, rename, rootname, separator, size, split, stat, system, tail, type, volumes, or writable}}
d1476 1
a1476 1
} {1 {ambiguous option "is": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, link, lstat, mtime, mkdir, nativename, normalize, owned, pathtype, readable, readlink, rename, rootname, separator, size, split, stat, system, tail, type, volumes, or writable}}
d1479 1
a1479 1
} {1 {bad option "z": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, link, lstat, mtime, mkdir, nativename, normalize, owned, pathtype, readable, readlink, rename, rootname, separator, size, split, stat, system, tail, type, volumes, or writable}}
d1482 1
a1482 1
} {1 {ambiguous option "read": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, link, lstat, mtime, mkdir, nativename, normalize, owned, pathtype, readable, readlink, rename, rootname, separator, size, split, stat, system, tail, type, volumes, or writable}}
d1485 1
a1485 1
} {1 {ambiguous option "s": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, link, lstat, mtime, mkdir, nativename, normalize, owned, pathtype, readable, readlink, rename, rootname, separator, size, split, stat, system, tail, type, volumes, or writable}}
d1488 1
a1488 1
} {1 {ambiguous option "t": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, link, lstat, mtime, mkdir, nativename, normalize, owned, pathtype, readable, readlink, rename, rootname, separator, size, split, stat, system, tail, type, volumes, or writable}}
a1493 7
# In testing 'file channels', we need to make sure that a channel
# created in one interp isn't visible in another.

interp create simpleInterp
interp create -safe safeInterp
interp c
safeInterp expose file file
d1499 3
a1501 4
    # Normal interps start out with only the standard channels
    lsort [simpleInterp eval [list file chan]]
} [lsort {stderr stdout stdin}]
test cmdAH-31.3 {Tcl_FileObjCmd: channels, globbing} {
d1504 6
a1509 9
test cmdAH-31.4 {Tcl_FileObjCmd: channels, globbing} {
    lsort [file channels std*]
} [lsort {stdout stderr stdin}]

set newFileId [open $gorpfile w]

test cmdAH-31.5 {Tcl_FileObjCmd: channels} {
    set res [file channels $newFileId]
    string equal $newFileId $res
a1510 44
test cmdAH-31.6 {Tcl_FileObjCmd: channels in other interp} {
    # Safe interps start out with no channels
    safeInterp eval [list file channels]
} {}
test cmdAH-31.7 {Tcl_FileObjCmd: channels in other interp} {
    list [catch {safeInterp eval [list puts $newFileId "hello"]} msg] $msg
} [list 1 "can not find channel named \"$newFileId\""]

interp share {} $newFileId safeInterp
interp share {} stdout safeInterp

test cmdAH-31.8 {Tcl_FileObjCmd: channels in other interp} {
    # $newFileId should now be visible in both interps
    list [file channels $newFileId] \
	    [safeInterp eval [list file channels $newFileId]]
} [list $newFileId $newFileId]
test cmdAH-31.9 {Tcl_FileObjCmd: channels in other interp} {
    lsort [safeInterp eval [list file channels]]
} [lsort [list stdout $newFileId]]
test cmdAH-31.10 {Tcl_FileObjCmd: channels in other interp} {
    # we can now write to $newFileId from slave
    safeInterp eval [list puts $newFileId "hello"]
} {}

interp transfer {} $newFileId safeInterp

test cmdAH-31.11 {Tcl_FileObjCmd: channels in other interp} {
    # $newFileId should now be visible only in safeInterp
    list [file channels $newFileId] \
	    [safeInterp eval [list file channels $newFileId]]
} [list {} $newFileId]
test cmdAH-31.12 {Tcl_FileObjCmd: channels in other interp} {
    lsort [safeInterp eval [list file channels]]
} [lsort [list stdout $newFileId]]
test cmdAH-31.13 {Tcl_FileObjCmd: channels in other interp} {
    safeInterp eval [list close $newFileId]
    safeInterp eval [list file channels]
} {stdout}

# This shouldn't work, but just in case a test above failed...
catch {close $newFileId}

interp delete safeInterp
interp delete simpleInterp
d1518 4
a1521 5
catch {file attributes $dirfile -permissions 0777}
removeDirectory $dirfile
removeFile $gorpfile
# No idea how well [removeFile] copes with links...
file delete $linkfile
d1527 14
@


1.2
log
@touched all Tcl files to ease next import.
@
text
@@


1.2.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.2.16.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d16 1
a16 1
    package require tcltest 2.1
a19 2
tcltest::testConstraint testchmod [string equal testchmod [info commands testchmod]]

a42 1
set foodir [file join [temporaryDirectory] foo]
d44 3
a46 3
    file delete -force $foodir
    file mkdir $foodir
    cd $foodir
d49 1
a49 1
    file delete $foodir
d57 3
a59 3
    file delete -force $foodir
    file mkdir $foodir
    cd $foodir
d61 2
a62 2
    set result [string equal [pwd] $oldpwd]
    file delete $foodir
d71 3
a73 3
    file delete -force $foodir
    file mkdir $foodir
    cd $foodir
d75 2
a76 2
    set result [string equal [pwd] $oldpwd]
    file delete $foodir
d169 1
a169 1
} {1 {bad option "x": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, link, lstat, mtime, mkdir, nativename, normalize, owned, pathtype, readable, readlink, rename, rootname, separator, size, split, stat, system, tail, type, volumes, or writable}}
d173 1
a173 3
test cmdAH-5.4 {Tcl_FileObjCmd} {
    list [catch {file exists ""} msg] $msg
} {0 0}
a196 8
test cmdAH-6.5 {cd} {unixOnly nonPortable} {
    set dir [pwd]
    cd /
    set res [pwd]
    cd $dir
    set res
} {/}

d200 4
a203 8
    set foofile [makeFile abcde foo.file]
    catch {file delete -force $foofile}
    close [open $foofile w]
    set res [catch {file attributes $foofile}]
    # We used [makeFile] so we undo with [removeFile]
    removeFile $foofile
    set res
} {0}
a1002 3
set gorpfile [makeFile abcde gorp.file]
set dirfile [makeDirectory dir.file]

d1007 4
a1010 1
test cmdAH-16.1 {Tcl_FileObjCmd: readable} {testchmod} {
d1013 3
a1015 3
testchmod 0444 $gorpfile
test cmdAH-16.2 {Tcl_FileObjCmd: readable} {testchmod} {
    file readable $gorpfile
d1017 3
a1019 3
testchmod 0333 $gorpfile
test cmdAH-16.3 {Tcl_FileObjCmd: readable} {unixOnly notRoot testchmod} {
    file reada $gorpfile
d1024 1
a1024 1
test cmdAH-17.1 {Tcl_FileObjCmd: writable} {testchmod} {
d1027 3
a1029 3
testchmod 0555 $gorpfile
test cmdAH-17.2 {Tcl_FileObjCmd: writable} {notRoot testchmod} {
    file writable $gorpfile
d1031 3
a1033 3
testchmod 0222 $gorpfile
test cmdAH-17.3 {Tcl_FileObjCmd: writable} {testchmod} {
    file writable $gorpfile
a1034 1
}
d1038 3
a1040 4
removeFile $gorpfile
removeDirectory $dirfile
set dirfile [makeDirectory dir.file]
set gorpfile [makeFile abcde gorp.file]
d1042 1
a1042 1
test cmdAH-18.1 {Tcl_FileObjCmd: executable} {testchmod} {
d1045 2
a1046 2
test cmdAH-18.2 {Tcl_FileObjCmd: executable} {testchmod} {
    file executable $gorpfile
d1048 1
a1048 1
test cmdAH-18.3 {Tcl_FileObjCmd: executable} {unixOnly testchmod} {
d1052 2
a1053 2
    testchmod 0775 $gorpfile
    file exe $gorpfile
d1056 1
a1056 1
test cmdAH-18.4 {Tcl_FileObjCmd: executable} {macOnly testchmod} {
d1059 3
a1061 3
    set x [file exe $gorpfile]    
    file attrib $gorpfile -type APPL
    lappend x [file exe $gorpfile]
d1063 1
a1063 1
test cmdAH-18.5 {Tcl_FileObjCmd: executable} {pcOnly testchmod} {
d1066 4
a1069 4
    set x [file exe $gorpfile]
    set gorpexe [makeFile foo gorp.exe]
    lappend x [file exe $gorpexe]
    removeFile $gorpexe
d1072 1
a1072 1
test cmdAH-18.6 {Tcl_FileObjCmd: executable} {testchmod} {
d1075 1
a1075 1
    file exe $dirfile
d1078 4
a1081 4
removeDirectory $dirfile
removeFile $gorpfile
set linkfile [file join [temporaryDirectory] link.file]
file delete $linkfile
d1088 1
a1088 1
test cmdAH-19.2 {Tcl_FileObjCmd: exists} {file exists $gorpfile} 0
d1090 1
a1090 1
    file exists [file join [temporaryDirectory] dir.file gorp.file]
d1093 3
a1095 3
    set gorpfile [makeFile abcde gorp.file]
    set dirfile [makeDirectory dir.file]
    set subgorp [makeFile 12345 [file join $dirfile gorp.file]]
d1098 1
a1098 1
    file exists $gorpfile
d1101 1
a1101 1
    file exists $subgorp
d1136 2
a1137 2
    file delete -force /tmp/tcl.foo.dir/file
    file delete -force /tmp/tcl.foo.dir
d1140 1
a1140 1
    file attributes /tmp/tcl.foo.dir -permissions 0000
d1144 1
a1144 1
    file attributes /tmp/tcl.foo.dir -permissions 0775
d1153 3
a1155 3
removeFile $gorpfile
set gorpfile [makeFile "Test string" gorp.file]
catch {file attributes $gorpfile -permissions 0765}
d1166 3
a1168 3
    file stat $gorpfile stat
    list [expr {[file mtime $gorpfile] == $stat(mtime)}] \
	    [expr {[file atime $gorpfile] == $stat(atime)}]
d1177 1
a1177 1
test cmdAH-20.5 {Tcl_FileObjCmd: atime touch} {unixOrPc} {
d1192 1
a1192 2
    set modatime [file atime $file $newatime]
    expr {$newatime == $modatime ? 1 : "$newatime != $modatime"}
a1194 1
removeFile touch.me
d1201 1
a1201 1
    file isdirectory $gorpfile
d1204 1
a1204 1
    file isd $dirfile
d1212 2
a1213 2
test cmdAH-22.2 {Tcl_FileObjCmd: isfile} {file isfile $gorpfile} 1
test cmdAH-22.3 {Tcl_FileObjCmd: isfile} {file isfile $dirfile} 0
d1218 1
a1218 1
catch {file link -symbolic $linkfile $gorpfile}
d1227 1
a1227 1
    file lstat $linkfile stat
d1232 1
a1232 1
    file lstat $linkfile stat
d1242 1
a1242 1
    list [catch {file lstat $gorpfile x} msg] $msg $errorCode
a1245 35
# mkdir

set dirA [file join [temporaryDirectory] a]
set dirB [file join [temporaryDirectory] a]
test cmdAH-23.7 {Tcl_FileObjCmd: mkdir} {
    catch {file delete -force $dirA}
    file mkdir $dirA
    set res [file isdirectory $dirA]
    file delete $dirA
    set res
} {1}
test cmdAH-23.8 {Tcl_FileObjCmd: mkdir} {
    catch {file delete -force $dirA}
    file mkdir $dirA/b
    set res [file isdirectory $dirA/b]
    file delete -force $dirA
    set res
} {1}
test cmdAH-23.9 {Tcl_FileObjCmd: mkdir} {
    catch {file delete -force $dirA}
    file mkdir $dirA/b/c
    set res [file isdirectory $dirA/b/c]
    file delete -force $dirA
    set res
} {1}
test cmdAH-23.10 {Tcl_FileObjCmd: mkdir} {
    catch {file delete -force $dirA}
    catch {file delete -force $dirB}
    file mkdir $dirA/b $dirB/a/c
    set res [list [file isdirectory $dirA/b] [file isdirectory $dirB/a/c]]
    file delete -force $dirA
    file delete -force $dirB
    set res
} {1 1}

a1252 7
# Check (allowing for clock-skew and OS interrupts as best we can)
# that the change in mtime on a file being written is the time elapsed
# between writes.  Note that this can still fail on very busy systems
# if there are long preemptions between the writes and the reading of
# the clock, but there's not much you can do about that other than the
# completely horrible "keep on trying to write until you managed to do
# it all in less than a second."  - DKF
d1254 1
a1254 5
    set f [open $gorpfile w]
    puts $f "More text"
    set localOld [clock seconds]
    close $f
    set old [file mtime $gorpfile]
d1256 1
a1256 1
    set f [open $gorpfile w]
a1257 1
    set localNew [clock seconds]
d1259 2
a1260 5
    set new [file mtime $gorpfile]
    expr {
	($new > $old) && ($localNew > $localOld) &&
	(abs(($new-$old) - ($localNew-$localOld)) <= 1)
    }
d1264 3
a1266 3
    file stat $gorpfile stat
    list [expr {[file mtime $gorpfile] == $stat(mtime)}] \
	    [expr {[file atime $gorpfile] == $stat(atime)}]
d1277 1
a1277 1
	set name /tmp/tcl.test.[pid]
d1279 1
a1279 1
	set name [file join [temporaryDirectory] tf]
d1298 1
a1298 2
    set modmtime [file mtime $file $newmtime]
    expr {$newmtime == $modmtime ? 1 : "$newmtime != $modmtime"}
d1300 1
a1300 1
removeFile touch.me
d1308 1
a1308 1
    file owned $gorpfile
d1320 2
a1321 2
    file readlink $linkfile
} $gorpfile
d1341 2
a1342 2
    set oldsize [file size $gorpfile]
    set f [open $gorpfile a]
d1346 1
a1346 1
    expr {[file size $gorpfile] - $oldsize}
d1356 2
a1357 3
removeFile $gorpfile
set gorpfile [makeFile "Test string" gorp.file]
catch {file attributes $gorpfile -permissions 0765}
d1367 1
a1367 1
    file stat $gorpfile stat
d1372 1
a1372 1
    file stat $gorpfile stat
d1377 1
a1377 1
    file stat $gorpfile stat
d1387 1
a1387 1
    list [catch {file stat $gorpfile x} msg] $msg $errorCode
d1392 2
a1393 2
    set filename [makeFile "" foo.text]
    file stat $filename stat
d1395 1
a1395 1
    removeFile $filename
d1436 3
a1438 3
    set filename [makeFile "" foo.test]
    file stat $filename stat
    removeFile $filename
d1445 2
d1451 1
a1451 1
    file type $dirfile
a1452 6
test cmdAH-29.3.0 {Tcl_FileObjCmd: delete removes link not file} {unixOnly nonPortable} {
    set exists [list [file exists $linkfile] [file exists $gorpfile]]
    file delete $linkfile
    set exists2	[list [file exists $linkfile] [file exists $gorpfile]]
    list $exists $exists2
} {{1 1} {0 1}}
d1454 1
a1454 1
    file type $gorpfile
d1456 4
a1459 25
test cmdAH-29.4 {Tcl_FileObjCmd: type} {unixOnly} {
    catch {file delete $linkfile}
    # Unlike [exec ln -s], [file link] requires an existing target
    file link -symbolic $linkfile $gorpfile
    set result [file type $linkfile]
    file delete $linkfile
    set result
} link
if {[string equal $tcl_platform(platform) "windows"]} {
    if {[string index $tcl_platform(osVersion) 0] >= 5 \
      && ([lindex [file system [temporaryDirectory]] 1] == "NTFS")} {
	tcltest::testConstraint linkDirectory 1
    } else {
	tcltest::testConstraint linkDirectory 0
    }
} else {
    tcltest::testConstraint linkDirectory 1
}
test cmdAH-29.4.1 {Tcl_FileObjCmd: type} {linkDirectory} {
    set tempdir [makeDirectory temp]
    set linkdir [file join [temporaryDirectory] link.dir]
    file link -symbolic $linkdir $tempdir
    set result [file type $linkdir]
    file delete $linkdir
    removeDirectory $tempdir
d1470 1
a1470 1
} {1 {bad option "gorp": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, link, lstat, mtime, mkdir, nativename, normalize, owned, pathtype, readable, readlink, rename, rootname, separator, size, split, stat, system, tail, type, volumes, or writable}}
d1473 1
a1473 1
} {1 {ambiguous option "ex": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, link, lstat, mtime, mkdir, nativename, normalize, owned, pathtype, readable, readlink, rename, rootname, separator, size, split, stat, system, tail, type, volumes, or writable}}
d1476 1
a1476 1
} {1 {ambiguous option "is": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, link, lstat, mtime, mkdir, nativename, normalize, owned, pathtype, readable, readlink, rename, rootname, separator, size, split, stat, system, tail, type, volumes, or writable}}
d1479 1
a1479 1
} {1 {bad option "z": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, link, lstat, mtime, mkdir, nativename, normalize, owned, pathtype, readable, readlink, rename, rootname, separator, size, split, stat, system, tail, type, volumes, or writable}}
d1482 1
a1482 1
} {1 {ambiguous option "read": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, link, lstat, mtime, mkdir, nativename, normalize, owned, pathtype, readable, readlink, rename, rootname, separator, size, split, stat, system, tail, type, volumes, or writable}}
d1485 1
a1485 1
} {1 {ambiguous option "s": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, link, lstat, mtime, mkdir, nativename, normalize, owned, pathtype, readable, readlink, rename, rootname, separator, size, split, stat, system, tail, type, volumes, or writable}}
d1488 1
a1488 1
} {1 {ambiguous option "t": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, link, lstat, mtime, mkdir, nativename, normalize, owned, pathtype, readable, readlink, rename, rootname, separator, size, split, stat, system, tail, type, volumes, or writable}}
a1493 7
# In testing 'file channels', we need to make sure that a channel
# created in one interp isn't visible in another.

interp create simpleInterp
interp create -safe safeInterp
interp c
safeInterp expose file file
d1499 3
a1501 4
    # Normal interps start out with only the standard channels
    lsort [simpleInterp eval [list file chan]]
} [lsort {stderr stdout stdin}]
test cmdAH-31.3 {Tcl_FileObjCmd: channels, globbing} {
d1504 6
a1509 9
test cmdAH-31.4 {Tcl_FileObjCmd: channels, globbing} {
    lsort [file channels std*]
} [lsort {stdout stderr stdin}]

set newFileId [open $gorpfile w]

test cmdAH-31.5 {Tcl_FileObjCmd: channels} {
    set res [file channels $newFileId]
    string equal $newFileId $res
a1510 44
test cmdAH-31.6 {Tcl_FileObjCmd: channels in other interp} {
    # Safe interps start out with no channels
    safeInterp eval [list file channels]
} {}
test cmdAH-31.7 {Tcl_FileObjCmd: channels in other interp} {
    list [catch {safeInterp eval [list puts $newFileId "hello"]} msg] $msg
} [list 1 "can not find channel named \"$newFileId\""]

interp share {} $newFileId safeInterp
interp share {} stdout safeInterp

test cmdAH-31.8 {Tcl_FileObjCmd: channels in other interp} {
    # $newFileId should now be visible in both interps
    list [file channels $newFileId] \
	    [safeInterp eval [list file channels $newFileId]]
} [list $newFileId $newFileId]
test cmdAH-31.9 {Tcl_FileObjCmd: channels in other interp} {
    lsort [safeInterp eval [list file channels]]
} [lsort [list stdout $newFileId]]
test cmdAH-31.10 {Tcl_FileObjCmd: channels in other interp} {
    # we can now write to $newFileId from slave
    safeInterp eval [list puts $newFileId "hello"]
} {}

interp transfer {} $newFileId safeInterp

test cmdAH-31.11 {Tcl_FileObjCmd: channels in other interp} {
    # $newFileId should now be visible only in safeInterp
    list [file channels $newFileId] \
	    [safeInterp eval [list file channels $newFileId]]
} [list {} $newFileId]
test cmdAH-31.12 {Tcl_FileObjCmd: channels in other interp} {
    lsort [safeInterp eval [list file channels]]
} [lsort [list stdout $newFileId]]
test cmdAH-31.13 {Tcl_FileObjCmd: channels in other interp} {
    safeInterp eval [list close $newFileId]
    safeInterp eval [list file channels]
} {stdout}

# This shouldn't work, but just in case a test above failed...
catch {close $newFileId}

interp delete safeInterp
interp delete simpleInterp
d1518 4
a1521 5
catch {file attributes $dirfile -permissions 0777}
removeDirectory $dirfile
removeFile $gorpfile
# No idea how well [removeFile] copes with links...
file delete $linkfile
d1527 14
@


1.1
log
@Initial revision
@
text
@d7 2
a8 1
# Copyright (c) 1996-1997 by Sun Microsystems, Inc.
d13 1
a13 1
# RCS: @@(#) $Id: cmdAH.test,v 1.8 1999/01/26 03:53:28 jingham Exp $
d15 4
a18 1
if {[string compare test [info procs test]] == 1} then {source defs}
d21 1
d24 141
a164 1
test cmdAH-1.1 {Tcl_FileObjCmd} {
d167 1
a167 1
test cmdAH-1.2 {Tcl_FileObjCmd} {
d169 4
a172 4
} {1 {bad option "x": must be atime, attributes, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, lstat, mtime, mkdir, nativename, owned, pathtype, readable, readlink, rename, rootname, size, split, stat, tail, type, volumes, or writable}}
test cmdAH-1.3 {Tcl_FileObjCmd} {
    list [catch {file atime} msg] $msg
} {1 {wrong # args: should be "file atime name ?arg ...?"}}
d177 1
a177 1
test cmdAH-2.1 {Tcl_FileObjCmd: volumes} {
d180 1
a180 1
test cmdAH-2.2 {Tcl_FileObjCmd: volumes} {
d188 1
a188 1
test cmdAH-2.3 {Tcl_FileObjCmd: volumes} {macOrUnix} {
d192 2
a193 2
test cmdAH-2.4 {Tcl_FileObjCmd: volumes} {pcOnly} {
    set volumeList [file volumes]
d199 1
a199 1
test cmdAH-3.1 {Tcl_FileObjCmd - file attrs} {
d211 1
a211 1
test cmdAH-4.1 {Tcl_FileObjCmd: dirname} {
d215 1
a215 1
test cmdAH-4.2 {Tcl_FileObjCmd: dirname} {
d219 1
a219 1
test cmdAH-4.3 {Tcl_FileObjCmd: dirname} {
d223 1
a223 1
test cmdAH-4.4 {Tcl_FileObjCmd: dirname} {
d227 1
a227 1
test cmdAH-4.5 {Tcl_FileObjCmd: dirname} {
d231 1
a231 1
test cmdAH-4.6 {Tcl_FileObjCmd: dirname} {
d235 1
a235 1
test cmdAH-4.7 {Tcl_FileObjCmd: dirname} {
d239 1
a239 1
test cmdAH-4.8 {Tcl_FileObjCmd: dirname} {
d243 1
a243 1
test cmdAH-4.9 {Tcl_FileObjCmd: dirname} {
d247 1
a247 1
test cmdAH-4.10 {Tcl_FileObjCmd: dirname} {
d251 1
a251 1
test cmdAH-4.11 {Tcl_FileObjCmd: dirname} {
d255 1
a255 1
test cmdAH-4.12 {Tcl_FileObjCmd: dirname} {
d259 1
a259 1
test cmdAH-4.13 {Tcl_FileObjCmd: dirname} {
d263 1
a263 1
test cmdAH-4.14 {Tcl_FileObjCmd: dirname} {
d267 1
a267 1
test cmdAH-4.15 {Tcl_FileObjCmd: dirname} {
d271 1
a271 1
test cmdAH-4.16 {Tcl_FileObjCmd: dirname} {
d275 1
a275 1
test cmdAH-4.17 {Tcl_FileObjCmd: dirname} {
d279 1
a279 1
test cmdAH-4.18 {Tcl_FileObjCmd: dirname} {
d283 1
a283 1
test cmdAH-4.19 {Tcl_FileObjCmd: dirname} {
d287 1
a287 1
test cmdAH-4.20 {Tcl_FileObjCmd: dirname} {
d291 1
a291 1
test cmdAH-4.21 {Tcl_FileObjCmd: dirname} {
d295 1
a295 1
test cmdAH-4.22 {Tcl_FileObjCmd: dirname} {
d299 1
a299 1
test cmdAH-4.23 {Tcl_FileObjCmd: dirname} {
d303 1
a303 1
test cmdAH-4.24 {Tcl_FileObjCmd: dirname} {
d307 1
a307 1
test cmdAH-4.25 {Tcl_FileObjCmd: dirname} {
d311 1
a311 1
test cmdAH-4.26 {Tcl_FileObjCmd: dirname} {
d315 1
a315 1
test cmdAH-4.27 {Tcl_FileObjCmd: dirname} {
d319 1
a319 1
test cmdAH-4.28 {Tcl_FileObjCmd: dirname} {
d323 1
a323 1
test cmdAH-4.29 {Tcl_FileObjCmd: dirname} {
d327 1
a327 1
test cmdAH-4.30 {Tcl_FileObjCmd: dirname} {
d331 1
a331 1
test cmdAH-4.31 {Tcl_FileObjCmd: dirname} {
d335 1
a335 1
test cmdAH-4.32 {Tcl_FileObjCmd: dirname} {
d339 1
a339 1
test cmdAH-4.33 {Tcl_FileObjCmd: dirname} {
d343 1
a343 1
test cmdAH-4.34 {Tcl_FileObjCmd: dirname} {
d347 1
a347 1
test cmdAH-4.35 {Tcl_FileObjCmd: dirname} {
d351 1
a351 1
test cmdAH-4.36 {Tcl_FileObjCmd: dirname} {
d355 1
a355 1
test cmdAH-4.37 {Tcl_FileObjCmd: dirname} {
d359 1
a359 1
test cmdAH-4.38 {Tcl_FileObjCmd: dirname} {
d363 1
a363 1
test cmdAH-4.39 {Tcl_FileObjCmd: dirname} {
d367 1
a367 1
test cmdAH-4.40 {Tcl_FileObjCmd: dirname} {
d371 1
a371 1
test cmdAH-4.41 {Tcl_FileObjCmd: dirname} {
d375 1
a375 1
test cmdAH-4.42 {Tcl_FileObjCmd: dirname} {
d379 1
a379 1
test cmdAH-4.43 {Tcl_FileObjCmd: dirname} {
d388 1
a388 1
test cmdAH-4.44 {Tcl_FileObjCmd: dirname} {
d397 1
a397 1
test cmdAH-4.45 {Tcl_FileObjCmd: dirname} {
d406 1
a406 1
test cmdAH-4.46 {Tcl_FileObjCmd: dirname} {
d418 1
a418 1
test cmdAH-5.1 {Tcl_FileObjCmd: tail} {
d422 1
a422 1
test cmdAH-5.2 {Tcl_FileObjCmd: tail} {
d426 1
a426 1
test cmdAH-5.3 {Tcl_FileObjCmd: tail} {
d430 1
a430 1
test cmdAH-5.4 {Tcl_FileObjCmd: tail} {
d434 1
a434 1
test cmdAH-5.5 {Tcl_FileObjCmd: tail} {
d438 1
a438 1
test cmdAH-5.6 {Tcl_FileObjCmd: tail} {
d442 1
a442 1
test cmdAH-5.7 {Tcl_FileObjCmd: tail} {
d446 1
a446 1
test cmdAH-5.8 {Tcl_FileObjCmd: tail} {
d450 1
a450 1
test cmdAH-5.9 {Tcl_FileObjCmd: tail} {
d454 1
a454 1
test cmdAH-5.10 {Tcl_FileObjCmd: tail} {
d458 1
a458 1
test cmdAH-5.11 {Tcl_FileObjCmd: tail} {
d462 1
a462 1
test cmdAH-5.12 {Tcl_FileObjCmd: tail} {
d466 1
a466 1
test cmdAH-5.13 {Tcl_FileObjCmd: tail} {
d470 1
a470 1
test cmdAH-5.14 {Tcl_FileObjCmd: tail} {
d474 1
a474 1
test cmdAH-5.15 {Tcl_FileObjCmd: tail} {
d478 1
a478 1
test cmdAH-5.16 {Tcl_FileObjCmd: tail} {
d482 1
a482 1
test cmdAH-5.17 {Tcl_FileObjCmd: tail} {
d486 1
a486 1
test cmdAH-5.18 {Tcl_FileObjCmd: tail} {
d490 1
a490 1
test cmdAH-5.19 {Tcl_FileObjCmd: tail} {
d494 1
a494 1
test cmdAH-5.20 {Tcl_FileObjCmd: tail} {
d498 1
a498 1
test cmdAH-5.21 {Tcl_FileObjCmd: tail} {
d502 1
a502 1
test cmdAH-5.22 {Tcl_FileObjCmd: tail} {
d506 1
a506 1
test cmdAH-5.23 {Tcl_FileObjCmd: tail} {
d510 1
a510 1
test cmdAH-5.24 {Tcl_FileObjCmd: tail} {
d514 1
a514 1
test cmdAH-5.25 {Tcl_FileObjCmd: tail} {
d518 1
a518 1
test cmdAH-5.26 {Tcl_FileObjCmd: tail} {
d522 1
a522 1
test cmdAH-5.27 {Tcl_FileObjCmd: tail} {
d526 1
a526 1
test cmdAH-5.28 {Tcl_FileObjCmd: tail} {
d530 1
a530 1
test cmdAH-5.29 {Tcl_FileObjCmd: tail} {
d534 1
a534 1
test cmdAH-5.30 {Tcl_FileObjCmd: tail} {
d538 1
a538 1
test cmdAH-5.31 {Tcl_FileObjCmd: tail} {
d542 1
a542 1
test cmdAH-5.32 {Tcl_FileObjCmd: tail} {
d546 1
a546 1
test cmdAH-5.33 {Tcl_FileObjCmd: tail} {
d550 1
a550 1
test cmdAH-5.34 {Tcl_FileObjCmd: tail} {
d554 1
a554 1
test cmdAH-5.35 {Tcl_FileObjCmd: tail} {
d558 1
a558 1
test cmdAH-5.36 {Tcl_FileObjCmd: tail} {
d562 1
a562 1
test cmdAH-5.37 {Tcl_FileObjCmd: tail} {
d566 1
a566 1
test cmdAH-5.38 {Tcl_FileObjCmd: tail} {
d570 1
a570 1
test cmdAH-5.39 {Tcl_FileObjCmd: tail} {
d574 1
a574 1
test cmdAH-5.40 {Tcl_FileObjCmd: tail} {
d578 1
a578 1
test cmdAH-5.41 {Tcl_FileObjCmd: tail} {
d582 1
a582 1
test cmdAH-5.42 {Tcl_FileObjCmd: tail} {
d591 1
a591 1
test cmdAH-5.43 {Tcl_FileObjCmd: tail} {
d600 1
a600 1
test cmdAH-5.44 {Tcl_FileObjCmd: tail} {
d609 1
a609 1
test cmdAH-5.45 {Tcl_FileObjCmd: tail} {
d618 1
a618 1
test cmdAH-5.46 {Tcl_FileObjCmd: tail} {
d622 1
a622 1
test cmdAH-5.47 {Tcl_FileObjCmd: tail} {
d626 1
a626 1
test cmdAH-5.48 {Tcl_FileObjCmd: tail} {
d630 1
a630 1
test cmdAH-5.49 {Tcl_FileObjCmd: tail} {
d634 1
a634 1
test cmdAH-5.50 {Tcl_FileObjCmd: tail} {
d638 1
a638 1
test cmdAH-5.51 {Tcl_FileObjCmd: tail} {
d645 1
a645 1
test cmdAH-6.1 {Tcl_FileObjCmd: rootname} {
d649 1
a649 1
test cmdAH-6.2 {Tcl_FileObjCmd: rootname} {
d653 1
a653 1
test cmdAH-6.3 {Tcl_FileObjCmd: rootname} {
d657 1
a657 1
test cmdAH-6.4 {Tcl_FileObjCmd: rootname} {
d661 1
a661 1
test cmdAH-6.5 {Tcl_FileObjCmd: rootname} {
d665 1
a665 1
test cmdAH-6.6 {Tcl_FileObjCmd: rootname} {
d669 1
a669 1
test cmdAH-6.7 {Tcl_FileObjCmd: rootname} {
d673 1
a673 1
test cmdAH-6.8 {Tcl_FileObjCmd: rootname} {
d677 1
a677 1
test cmdAH-6.9 {Tcl_FileObjCmd: rootname} {
d681 1
a681 1
test cmdAH-6.10 {Tcl_FileObjCmd: rootname} {
d685 1
a685 1
test cmdAH-6.11 {Tcl_FileObjCmd: rootname} {
d689 1
a689 1
test cmdAH-6.12 {Tcl_FileObjCmd: rootname} {
d693 1
a693 1
test cmdAH-6.13 {Tcl_FileObjCmd: rootname} {
d697 1
a697 1
test cmdAH-6.14 {Tcl_FileObjCmd: rootname} {
d701 1
a701 1
test cmdAH-6.15 {Tcl_FileObjCmd: rootname} {
d705 1
a705 1
test cmdAH-6.16 {Tcl_FileObjCmd: rootname} {
d709 1
a709 1
test cmdAH-6.17 {Tcl_FileObjCmd: rootname} {
d713 1
a713 1
test cmdAH-6.18 {Tcl_FileObjCmd: rootname} {
d717 1
a717 1
test cmdAH-6.19 {Tcl_FileObjCmd: rootname} {
d721 1
a721 1
test cmdAH-6.20 {Tcl_FileObjCmd: rootname} {
d725 1
a725 1
test cmdAH-6.21 {Tcl_FileObjCmd: rootname} {
d729 1
a729 1
test cmdAH-6.22 {Tcl_FileObjCmd: rootname} {
d733 1
a733 1
test cmdAH-6.23 {Tcl_FileObjCmd: rootname} {
d737 1
a737 1
test cmdAH-6.24 {Tcl_FileObjCmd: rootname} {
d741 1
a741 1
test cmdAH-6.25 {Tcl_FileObjCmd: rootname} {
d745 1
a745 1
test cmdAH-6.26 {Tcl_FileObjCmd: rootname} {
d749 1
a749 1
test cmdAH-6.27 {Tcl_FileObjCmd: rootname} {
d753 1
a753 1
test cmdAH-6.28 {Tcl_FileObjCmd: rootname} {
d757 1
a757 1
test cmdAH-6.29 {Tcl_FileObjCmd: rootname} {
d761 1
a761 1
test cmdAH-6.30 {Tcl_FileObjCmd: rootname} {
d765 1
a765 1
test cmdAH-6.31 {Tcl_FileObjCmd: rootname} {
d769 1
a769 1
test cmdAH-6.32 {Tcl_FileObjCmd: rootname} {
d773 1
a773 1
test cmdAH-6.33 {Tcl_FileObjCmd: rootname} {
d777 1
a777 1
test cmdAH-6.34 {Tcl_FileObjCmd: rootname} {
d795 1
a795 1
test cmdAH-7.1 {Tcl_FileObjCmd: extension} {
d799 1
a799 1
test cmdAH-7.2 {Tcl_FileObjCmd: extension} {
d803 1
a803 1
test cmdAH-7.3 {Tcl_FileObjCmd: extension} {
d807 1
a807 1
test cmdAH-7.4 {Tcl_FileObjCmd: extension} {
d811 1
a811 1
test cmdAH-7.5 {Tcl_FileObjCmd: extension} {
d815 1
a815 1
test cmdAH-7.6 {Tcl_FileObjCmd: extension} {
d819 1
a819 1
test cmdAH-7.7 {Tcl_FileObjCmd: extension} {
d823 1
a823 1
test cmdAH-7.8 {Tcl_FileObjCmd: extension} {
d827 1
a827 1
test cmdAH-7.9 {Tcl_FileObjCmd: extension} {
d831 1
a831 1
test cmdAH-7.10 {Tcl_FileObjCmd: extension} {
d835 1
a835 1
test cmdAH-7.11 {Tcl_FileObjCmd: extension} {
d839 1
a839 1
test cmdAH-7.12 {Tcl_FileObjCmd: extension} {
d843 1
a843 1
test cmdAH-7.13 {Tcl_FileObjCmd: extension} {
d847 1
a847 1
test cmdAH-7.14 {Tcl_FileObjCmd: extension} {
d851 1
a851 1
test cmdAH-7.15 {Tcl_FileObjCmd: extension} {
d855 1
a855 1
test cmdAH-7.16 {Tcl_FileObjCmd: extension} {
d859 1
a859 1
test cmdAH-7.17 {Tcl_FileObjCmd: extension} {
d863 1
a863 1
test cmdAH-7.18 {Tcl_FileObjCmd: extension} {
d867 1
a867 1
test cmdAH-7.19 {Tcl_FileObjCmd: extension} {
d871 1
a871 1
test cmdAH-7.20 {Tcl_FileObjCmd: extension} {
d875 1
a875 1
test cmdAH-7.21 {Tcl_FileObjCmd: extension} {
d879 1
a879 1
test cmdAH-7.22 {Tcl_FileObjCmd: extension} {
d883 1
a883 1
test cmdAH-7.23 {Tcl_FileObjCmd: extension} {
d887 1
a887 1
test cmdAH-7.24 {Tcl_FileObjCmd: extension} {
d891 1
a891 1
test cmdAH-7.25 {Tcl_FileObjCmd: extension} {
d895 1
a895 1
test cmdAH-7.26 {Tcl_FileObjCmd: extension} {
d899 1
a899 1
test cmdAH-7.27 {Tcl_FileObjCmd: extension} {
d903 1
a903 1
test cmdAH-7.28 {Tcl_FileObjCmd: extension} {
d907 1
a907 1
test cmdAH-7.29 {Tcl_FileObjCmd: extension} {
d911 1
a911 1
test cmdAH-7.30 {Tcl_FileObjCmd: extension} {
d915 1
a915 1
test cmdAH-7.31 {Tcl_FileObjCmd: extension} {
d919 1
a919 1
test cmdAH-7.32 {Tcl_FileObjCmd: extension} {
d923 1
a923 1
test cmdAH-7.33 {Tcl_FileObjCmd: extension} {
d927 1
a927 1
test cmdAH-7.34 {Tcl_FileObjCmd: extension} {
d932 1
a932 1
foreach value {a..b a...b a.c..b ..b} result {..b ...b ..b ..b} {
d944 1
a944 1
test cmdAH-8.1 {Tcl_FileObjCmd: pathtype} {
d948 1
a948 1
test cmdAH-8.2 {Tcl_FileObjCmd: pathtype} {
d952 1
a952 1
test cmdAH-8.3 {Tcl_FileObjCmd: pathtype} {
d956 1
a956 1
test cmdAH-8.4 {Tcl_FileObjCmd: pathtype} {
d963 1
a963 1
test cmdAH-9.1 {Tcl_FileObjCmd: split} {
d967 1
a967 1
test cmdAH-9.2 {Tcl_FileObjCmd: split} {
d971 1
a971 1
test cmdAH-9.3 {Tcl_FileObjCmd: split} {
d978 1
a978 1
test cmdAH-10.1 {Tcl_FileObjCmd: join} {
d982 1
a982 1
test cmdAH-10.2 {Tcl_FileObjCmd: join} {
d986 1
a986 1
test cmdAH-10.3 {Tcl_FileObjCmd: join} {
d993 1
a993 1
test cmdAH-11.1 {Tcl_FileObjCmd} {
d1010 1
a1010 1
test cmdAH-12.1 {Tcl_FileObjCmd: readable} {
d1014 1
a1014 1
test cmdAH-12.2 {Tcl_FileObjCmd: readable} {
d1018 1
a1018 1
test cmdAH-12.3 {Tcl_FileObjCmd: readable} {unixOnly && !root} {
d1024 1
a1024 1
test cmdAH-13.1 {Tcl_FileObjCmd: writable} {
d1028 1
a1028 1
test cmdAH-13.2 {Tcl_FileObjCmd: writable} {!root} {
d1032 1
a1032 1
test cmdAH-13.3 {Tcl_FileObjCmd: writable} {
d1042 1
a1042 1
test cmdAH-14.1 {Tcl_FileObjCmd: executable} {
d1045 1
a1045 1
test cmdAH-14.2 {Tcl_FileObjCmd: executable} {
d1048 1
a1048 1
test cmdAH-14.3 {Tcl_FileObjCmd: executable} {unix} {
d1056 1
a1056 1
test cmdAH-14.4 {Tcl_FileObjCmd: executable} {mac} {
d1063 1
a1063 1
test cmdAH-14.5 {Tcl_FileObjCmd: executable} {pc} {
d1072 1
a1072 1
test cmdAH-14.6 {Tcl_FileObjCmd: executable} {
d1085 1
a1085 1
test cmdAH-15.1 {Tcl_FileObjCmd: exists} {
d1088 2
a1089 2
test cmdAH-15.2 {Tcl_FileObjCmd: exists} {file exists gorp.file} 0
test cmdAH-15.3 {Tcl_FileObjCmd: exists} {
d1097 1
a1097 1
test cmdAH-15.4 {Tcl_FileObjCmd: exists} {
d1100 1
a1100 1
test cmdAH-15.5 {Tcl_FileObjCmd: exists} {
d1109 1
a1109 1
test cmdAH-15.6 {Tcl_FileObjCmd: nativename} {
d1113 1
a1113 1
test cmdAH-15.7 {Tcl_FileObjCmd: nativename} {
d1117 1
a1117 1
test cmdAH-15.8 {Tcl_FileObjCmd: nativename} {
d1123 1
a1123 1
test cmdAH-15.9 {Tcl_FileObjCmd: ~ : exists} {
d1126 1
a1126 1
test cmdAH-15.10 {Tcl_FileObjCmd: ~ : nativename} {
d1135 2
a1136 2
if {$tcl_platform(platform) == "unix"} {
    file delete /tmp/tcl.foo.dir/file
d1141 3
a1143 5
    if {$user != "root"} {
	test cmdAH-15.9 {Tcl_FileObjCmd: exists} {
	    file exists /tmp/tcl.foo.dir/file
	} 0
    }
d1145 1
a1145 1
    file delete /tmp/tcl.foo.dir/file
d1147 2
a1148 1
}
d1159 6
a1164 4
test cmdAH-16.1 {Tcl_FileObjCmd: atime} {
    list [catch {file atime a b} msg] $msg
} {1 {wrong # args: should be "file atime name"}}
test cmdAH-16.2 {Tcl_FileObjCmd: atime} {
d1170 1
a1170 1
test cmdAH-16.3 {Tcl_FileObjCmd: atime} {
d1173 21
a1193 1
} {1 {couldn't stat "_bogus_": no such file or directory} {posix enoent {no such file or directory}}}
d1197 1
a1197 1
test cmdAH-17.1 {Tcl_FileObjCmd: isdirectory} {
d1200 1
a1200 1
test cmdAH-17.2 {Tcl_FileObjCmd: isdirectory} {
d1203 1
a1203 1
test cmdAH-17.3 {Tcl_FileObjCmd: isdirectory} {
d1209 1
a1209 1
test cmdAH-18.1 {Tcl_FileObjCmd: isfile} {
d1212 2
a1213 2
test cmdAH-18.2 {Tcl_FileObjCmd: isfile} {file isfile gorp.file} 1
test cmdAH-18.3 {Tcl_FileObjCmd: isfile} {file isfile dir.file} 0
d1219 1
a1219 1
test cmdAH-19.1 {Tcl_FileObjCmd: lstat} {
d1222 1
a1222 1
test cmdAH-19.2 {Tcl_FileObjCmd: lstat} {
d1225 1
a1225 1
test cmdAH-19.3 {Tcl_FileObjCmd: lstat} {unixOnly nonPortable} {
d1230 1
a1230 1
test cmdAH-19.4 {Tcl_FileObjCmd: lstat} {unixOnly nonPortable} {
d1235 1
a1235 1
test cmdAH-19.5 {Tcl_FileObjCmd: lstat errors} {nonPortable} {
d1238 2
a1239 2
} {1 {couldn't lstat "_bogus_": no such file or directory} {posix enoent {no such file or directory}}}
test cmdAH-19.6 {Tcl_FileObjCmd: lstat errors} {
d1248 6
a1253 4
test cmdAH-20.1 {Tcl_FileObjCmd: mtime} {
    list [catch {file mtime a b} msg] $msg
} {1 {wrong # args: should be "file mtime name"}}
test cmdAH-20.2 {Tcl_FileObjCmd: mtime} {
d1262 1
a1262 1
test cmdAH-20.3 {Tcl_FileObjCmd: mtime} {
d1268 1
a1268 1
test cmdAH-20.4 {Tcl_FileObjCmd: mtime} {
d1271 2
a1272 2
} {1 {couldn't stat "_bogus_": no such file or directory} {posix enoent {no such file or directory}}}
test cmdAH-20.5 {Tcl_FileObjCmd: mtime} {
d1276 1
a1276 1
    if {$tcl_platform(platform) == "unix"} {
d1282 2
a1283 3
    # Borland file times were off by timezone.  Make sure that a new file's
    # time is correct.  10 seconds variance is allowed used due to slow
    # networks or clock skew on a network drive.
d1291 9
d1304 1
a1304 1
test cmdAH-21.1 {Tcl_FileObjCmd: owned} {
d1307 1
a1307 1
test cmdAH-21.2 {Tcl_FileObjCmd: owned} {
d1310 1
a1310 1
test cmdAH-21.3 {Tcl_FileObjCmd: owned} {unixOnly && !root} {
d1316 1
a1316 1
test cmdAH-22.1 {Tcl_FileObjCmd: readlink} {
d1319 1
a1319 1
test cmdAH-22.2 {Tcl_FileObjCmd: readlink} {unixOnly nonPortable} {
d1322 1
a1322 1
test cmdAH-22.3 {Tcl_FileObjCmd: readlink errors} {unixOnly nonPortable} {
d1325 2
a1326 2
} {1 {couldn't readlink "_bogus_": no such file or directory} {posix enoent {no such file or directory}}}
test cmdAH-22.4 {Tcl_FileObjCmd: readlink errors} {macOnly nonPortable} {
d1329 2
a1330 2
} {1 {couldn't readlink "_bogus_": no such file or directory} {posix enoent {no such file or directory}}}
test cmdAH-22.5 {Tcl_FileObjCmd: readlink errors} {pcOnly nonPortable} {
d1333 1
a1333 1
} {1 {couldn't readlink "_bogus_": invalid argument} {posix einval {invalid argument}}}
d1337 1
a1337 1
test cmdAH-23.1 {Tcl_FileObjCmd: size} {
d1340 1
a1340 1
test cmdAH-23.2 {Tcl_FileObjCmd: size} {
d1348 1
a1348 1
test cmdAH-23.3 {Tcl_FileObjCmd: size} {
d1351 1
a1351 1
} {1 {couldn't stat "_bogus_": no such file or directory} {posix enoent {no such file or directory}}}
d1359 1
a1359 1
test cmdAH-24.1 {Tcl_FileObjCmd: stat} {
d1362 1
a1362 1
test cmdAH-24.2 {Tcl_FileObjCmd: stat} {
d1365 1
a1365 1
test cmdAH-24.3 {Tcl_FileObjCmd: stat} {
d1370 1
a1370 1
test cmdAH-24.4 {Tcl_FileObjCmd: stat} {
d1375 1
a1375 1
test cmdAH-24.5 {Tcl_FileObjCmd: stat} {unix} {
d1380 1
a1380 1
test cmdAH-24.6 {Tcl_FileObjCmd: stat} {
d1383 2
a1384 2
} {1 {couldn't stat "_bogus_": no such file or directory} {posix enoent {no such file or directory}}}
test cmdAH-24.7 {Tcl_FileObjCmd: stat} {
d1389 52
d1447 1
a1447 1
test cmdAH-25.1 {Tcl_FileObjCmd: type} {
d1450 1
a1450 1
test cmdAH-25.2 {Tcl_FileObjCmd: type} {
d1453 1
a1453 1
test cmdAH-25.3 {Tcl_FileObjCmd: type} {
d1456 1
a1456 1
test cmdAH-25.4 {Tcl_FileObjCmd: type} {unixOnly nonPortable} {
d1462 1
a1462 1
test cmdAH-25.5 {Tcl_FileObjCmd: type} {
d1464 1
a1464 1
} {1 {couldn't stat "_bogus_": no such file or directory} {posix enoent {no such file or directory}}}
d1468 1
a1468 1
test cmdAH-26.1 {error conditions} {
d1470 2
a1471 2
} {1 {bad option "gorp": must be atime, attributes, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, lstat, mtime, mkdir, nativename, owned, pathtype, readable, readlink, rename, rootname, size, split, stat, tail, type, volumes, or writable}}
test cmdAH-26.2 {error conditions} {
d1473 2
a1474 2
} {1 {ambiguous option "ex": must be atime, attributes, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, lstat, mtime, mkdir, nativename, owned, pathtype, readable, readlink, rename, rootname, size, split, stat, tail, type, volumes, or writable}}
test cmdAH-26.3 {error conditions} {
d1476 2
a1477 2
} {1 {ambiguous option "is": must be atime, attributes, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, lstat, mtime, mkdir, nativename, owned, pathtype, readable, readlink, rename, rootname, size, split, stat, tail, type, volumes, or writable}}
test cmdAH-26.4 {error conditions} {
d1479 2
a1480 2
} {1 {bad option "z": must be atime, attributes, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, lstat, mtime, mkdir, nativename, owned, pathtype, readable, readlink, rename, rootname, size, split, stat, tail, type, volumes, or writable}}
test cmdAH-26.5 {error conditions} {
d1482 2
a1483 2
} {1 {ambiguous option "read": must be atime, attributes, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, lstat, mtime, mkdir, nativename, owned, pathtype, readable, readlink, rename, rootname, size, split, stat, tail, type, volumes, or writable}}
test cmdAH-26.6 {error conditions} {
d1485 2
a1486 2
} {1 {ambiguous option "s": must be atime, attributes, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, lstat, mtime, mkdir, nativename, owned, pathtype, readable, readlink, rename, rootname, size, split, stat, tail, type, volumes, or writable}}
test cmdAH-26.7 {error conditions} {
d1488 2
a1489 2
} {1 {ambiguous option "t": must be atime, attributes, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, lstat, mtime, mkdir, nativename, owned, pathtype, readable, readlink, rename, rootname, size, split, stat, tail, type, volumes, or writable}}
test cmdAH-26.8 {error conditions} {
d1493 20
d1516 2
d1523 18
a1540 1
concat ""
@


1.1.1.1
log
@import dejagnu-1999-11-08 snapshot
@
text
@@


1.1.1.2
log
@Tcl 8.3 upgrade
@
text
@d7 1
a7 2
# Copyright (c) 1996-1998 by Sun Microsystems, Inc.
# Copyright (c) 1998-1999 by Scriptics Corporation.
d12 1
a12 1
# RCS: @@(#) $Id: cmdAH.test,v 1.6.8.2 2000/09/15 16:56:04 spolk Exp $
d14 1
a14 4
if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import -force ::tcltest::*
}
a16 1
set cmdAHwd [pwd]
d19 1
a19 141
test cmdAH-0.1 {Tcl_BreakObjCmd, errors} {
    list [catch {break foo} msg] $msg
} {1 {wrong # args: should be "break"}}
test cmdAH-0.2 {Tcl_BreakObjCmd, success} {
    list [catch {break} msg] $msg
} {3 {}}

# Tcl_CaseObjCmd is tested in case.test

test cmdAH-1.1 {Tcl_CatchObjCmd, errors} {
    list [catch {catch} msg] $msg
} {1 {wrong # args: should be "catch command ?varName?"}}
test cmdAH-1.2 {Tcl_CatchObjCmd, errors} {
    list [catch {catch foo bar baz} msg] $msg
} {1 {wrong # args: should be "catch command ?varName?"}}

test cmdAH-2.1 {Tcl_CdObjCmd} {
    list [catch {cd foo bar} msg] $msg
} {1 {wrong # args: should be "cd ?dirName?"}}
test cmdAH-2.2 {Tcl_CdObjCmd} {
    file delete -force foo
    file mkdir foo
    cd foo
    set result [file tail [pwd]]
    cd ..
    file delete foo
    set result
} foo
test cmdAH-2.3 {Tcl_CdObjCmd} {
    global env
    set oldpwd [pwd]
    set temp $env(HOME)
    set env(HOME) $oldpwd
    file delete -force foo
    file mkdir foo
    cd foo
    cd ~
    set result [string match [pwd] $oldpwd]
    file delete foo
    set env(HOME) $temp
    set result
} 1
test cmdAH-2.4 {Tcl_CdObjCmd} {
    global env
    set oldpwd [pwd]
    set temp $env(HOME)
    set env(HOME) $oldpwd
    file delete -force foo
    file mkdir foo
    cd foo
    cd
    set result [string match [pwd] $oldpwd]
    file delete foo
    set env(HOME) $temp
    set result
} 1
test cmdAH-2.5 {Tcl_CdObjCmd} {
    list [catch {cd ~~} msg] $msg
} {1 {user "~" doesn't exist}}
test cmdAH-2.6 {Tcl_CdObjCmd} {
    list [catch {cd _foobar} msg] $msg
} {1 {couldn't change working directory to "_foobar": no such file or directory}}

test cmdAH-2.7 {Tcl_ConcatObjCmd} {
    concat
} {}
test cmdAH-2.8 {Tcl_ConcatObjCmd} {
    concat a
} a
test cmdAH-2.9 {Tcl_ConcatObjCmd} {
    concat a {b c}
} {a b c}

test cmdAH-3.1 {Tcl_ContinueObjCmd, errors} {
    list [catch {continue foo} msg] $msg
} {1 {wrong # args: should be "continue"}}
test cmdAH-3.2 {Tcl_ContinueObjCmd, success} {
    list [catch {continue} msg] $msg
} {4 {}}

test cmdAH-4.1 {Tcl_EncodingObjCmd} {
    list [catch {encoding} msg] $msg
} {1 {wrong # args: should be "encoding option ?arg ...?"}}
test cmdAH-4.2 {Tcl_EncodingObjCmd} {
    list [catch {encoding foo} msg] $msg
} {1 {bad option "foo": must be convertfrom, convertto, names, or system}}
test cmdAH-4.3 {Tcl_EncodingObjCmd} {
    list [catch {encoding convertto} msg] $msg
} {1 {wrong # args: should be "encoding convertto ?encoding? data"}}
test cmdAH-4.4 {Tcl_EncodingObjCmd} {
    list [catch {encoding convertto foo bar} msg] $msg
} {1 {unknown encoding "foo"}}
test cmdAH-4.5 {Tcl_EncodingObjCmd} {
    set system [encoding system]
    encoding system jis0208
    set x [encoding convertto \u4e4e]
    encoding system $system
    set x
} 8C
test cmdAH-4.6 {Tcl_EncodingObjCmd} {
    set system [encoding system]
    encoding system identity
    set x [encoding convertto jis0208 \u4e4e]
    encoding system $system
    set x
} 8C
test cmdAH-4.7 {Tcl_EncodingObjCmd} {
    list [catch {encoding convertfrom} msg] $msg
} {1 {wrong # args: should be "encoding convertfrom ?encoding? data"}}
test cmdAH-4.8 {Tcl_EncodingObjCmd} {
    list [catch {encoding convertfrom foo bar} msg] $msg
} {1 {unknown encoding "foo"}}
test cmdAH-4.9 {Tcl_EncodingObjCmd} {
    set system [encoding system]
    encoding system jis0208
    set x [encoding convertfrom 8C]
    encoding system $system
    set x
} \u4e4e
test cmdAH-4.10 {Tcl_EncodingObjCmd} {
    set system [encoding system]
    encoding system identity
    set x [encoding convertfrom jis0208 8C]
    encoding system $system
    set x
} \u4e4e
test cmdAH-4.11 {Tcl_EncodingObjCmd} {
    list [catch {encoding names foo} msg] $msg
} {1 {wrong # args: should be "encoding names"}}
test cmdAH-4.12 {Tcl_EncodingObjCmd} {
    list [catch {encoding system foo bar} msg] $msg
} {1 {wrong # args: should be "encoding system ?encoding?"}}
test cmdAH-4.13 {Tcl_EncodingObjCmd} {
    set system [encoding system]
    encoding system identity
    set x [encoding system]
    encoding system $system
    set x
} identity

test cmdAH-5.1 {Tcl_FileObjCmd} {
d22 1
a22 1
test cmdAH-5.2 {Tcl_FileObjCmd} {
d24 4
a27 4
} {1 {bad option "x": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, lstat, mtime, mkdir, nativename, owned, pathtype, readable, readlink, rename, rootname, size, split, stat, tail, type, volumes, or writable}}
test cmdAH-5.3 {Tcl_FileObjCmd} {
    list [catch {file exists} msg] $msg
} {1 {wrong # args: should be "file exists name"}}
d32 1
a32 1
test cmdAH-6.1 {Tcl_FileObjCmd: volumes} {
d35 1
a35 1
test cmdAH-6.2 {Tcl_FileObjCmd: volumes} {
d43 1
a43 1
test cmdAH-6.3 {Tcl_FileObjCmd: volumes} {macOrUnix} {
d47 2
a48 2
test cmdAH-6.4 {Tcl_FileObjCmd: volumes} {pcOnly} {
    set volumeList [string tolower [file volumes]]
d54 1
a54 1
test cmdAH-7.1 {Tcl_FileObjCmd - file attrs} {
d66 1
a66 1
test cmdAH-8.1 {Tcl_FileObjCmd: dirname} {
d70 1
a70 1
test cmdAH-8.2 {Tcl_FileObjCmd: dirname} {
d74 1
a74 1
test cmdAH-8.3 {Tcl_FileObjCmd: dirname} {
d78 1
a78 1
test cmdAH-8.4 {Tcl_FileObjCmd: dirname} {
d82 1
a82 1
test cmdAH-8.5 {Tcl_FileObjCmd: dirname} {
d86 1
a86 1
test cmdAH-8.6 {Tcl_FileObjCmd: dirname} {
d90 1
a90 1
test cmdAH-8.7 {Tcl_FileObjCmd: dirname} {
d94 1
a94 1
test cmdAH-8.8 {Tcl_FileObjCmd: dirname} {
d98 1
a98 1
test cmdAH-8.9 {Tcl_FileObjCmd: dirname} {
d102 1
a102 1
test cmdAH-8.10 {Tcl_FileObjCmd: dirname} {
d106 1
a106 1
test cmdAH-8.11 {Tcl_FileObjCmd: dirname} {
d110 1
a110 1
test cmdAH-8.12 {Tcl_FileObjCmd: dirname} {
d114 1
a114 1
test cmdAH-8.13 {Tcl_FileObjCmd: dirname} {
d118 1
a118 1
test cmdAH-8.14 {Tcl_FileObjCmd: dirname} {
d122 1
a122 1
test cmdAH-8.15 {Tcl_FileObjCmd: dirname} {
d126 1
a126 1
test cmdAH-8.16 {Tcl_FileObjCmd: dirname} {
d130 1
a130 1
test cmdAH-8.17 {Tcl_FileObjCmd: dirname} {
d134 1
a134 1
test cmdAH-8.18 {Tcl_FileObjCmd: dirname} {
d138 1
a138 1
test cmdAH-8.19 {Tcl_FileObjCmd: dirname} {
d142 1
a142 1
test cmdAH-8.20 {Tcl_FileObjCmd: dirname} {
d146 1
a146 1
test cmdAH-8.21 {Tcl_FileObjCmd: dirname} {
d150 1
a150 1
test cmdAH-8.22 {Tcl_FileObjCmd: dirname} {
d154 1
a154 1
test cmdAH-8.23 {Tcl_FileObjCmd: dirname} {
d158 1
a158 1
test cmdAH-8.24 {Tcl_FileObjCmd: dirname} {
d162 1
a162 1
test cmdAH-8.25 {Tcl_FileObjCmd: dirname} {
d166 1
a166 1
test cmdAH-8.26 {Tcl_FileObjCmd: dirname} {
d170 1
a170 1
test cmdAH-8.27 {Tcl_FileObjCmd: dirname} {
d174 1
a174 1
test cmdAH-8.28 {Tcl_FileObjCmd: dirname} {
d178 1
a178 1
test cmdAH-8.29 {Tcl_FileObjCmd: dirname} {
d182 1
a182 1
test cmdAH-8.30 {Tcl_FileObjCmd: dirname} {
d186 1
a186 1
test cmdAH-8.31 {Tcl_FileObjCmd: dirname} {
d190 1
a190 1
test cmdAH-8.32 {Tcl_FileObjCmd: dirname} {
d194 1
a194 1
test cmdAH-8.33 {Tcl_FileObjCmd: dirname} {
d198 1
a198 1
test cmdAH-8.34 {Tcl_FileObjCmd: dirname} {
d202 1
a202 1
test cmdAH-8.35 {Tcl_FileObjCmd: dirname} {
d206 1
a206 1
test cmdAH-8.36 {Tcl_FileObjCmd: dirname} {
d210 1
a210 1
test cmdAH-8.37 {Tcl_FileObjCmd: dirname} {
d214 1
a214 1
test cmdAH-8.38 {Tcl_FileObjCmd: dirname} {
d218 1
a218 1
test cmdAH-8.39 {Tcl_FileObjCmd: dirname} {
d222 1
a222 1
test cmdAH-8.40 {Tcl_FileObjCmd: dirname} {
d226 1
a226 1
test cmdAH-8.41 {Tcl_FileObjCmd: dirname} {
d230 1
a230 1
test cmdAH-8.42 {Tcl_FileObjCmd: dirname} {
d234 1
a234 1
test cmdAH-8.43 {Tcl_FileObjCmd: dirname} {
d243 1
a243 1
test cmdAH-8.44 {Tcl_FileObjCmd: dirname} {
d252 1
a252 1
test cmdAH-8.45 {Tcl_FileObjCmd: dirname} {
d261 1
a261 1
test cmdAH-8.46 {Tcl_FileObjCmd: dirname} {
d273 1
a273 1
test cmdAH-9.1 {Tcl_FileObjCmd: tail} {
d277 1
a277 1
test cmdAH-9.2 {Tcl_FileObjCmd: tail} {
d281 1
a281 1
test cmdAH-9.3 {Tcl_FileObjCmd: tail} {
d285 1
a285 1
test cmdAH-9.4 {Tcl_FileObjCmd: tail} {
d289 1
a289 1
test cmdAH-9.5 {Tcl_FileObjCmd: tail} {
d293 1
a293 1
test cmdAH-9.6 {Tcl_FileObjCmd: tail} {
d297 1
a297 1
test cmdAH-9.7 {Tcl_FileObjCmd: tail} {
d301 1
a301 1
test cmdAH-9.8 {Tcl_FileObjCmd: tail} {
d305 1
a305 1
test cmdAH-9.9 {Tcl_FileObjCmd: tail} {
d309 1
a309 1
test cmdAH-9.10 {Tcl_FileObjCmd: tail} {
d313 1
a313 1
test cmdAH-9.11 {Tcl_FileObjCmd: tail} {
d317 1
a317 1
test cmdAH-9.12 {Tcl_FileObjCmd: tail} {
d321 1
a321 1
test cmdAH-9.13 {Tcl_FileObjCmd: tail} {
d325 1
a325 1
test cmdAH-9.14 {Tcl_FileObjCmd: tail} {
d329 1
a329 1
test cmdAH-9.15 {Tcl_FileObjCmd: tail} {
d333 1
a333 1
test cmdAH-9.16 {Tcl_FileObjCmd: tail} {
d337 1
a337 1
test cmdAH-9.17 {Tcl_FileObjCmd: tail} {
d341 1
a341 1
test cmdAH-9.18 {Tcl_FileObjCmd: tail} {
d345 1
a345 1
test cmdAH-9.19 {Tcl_FileObjCmd: tail} {
d349 1
a349 1
test cmdAH-9.20 {Tcl_FileObjCmd: tail} {
d353 1
a353 1
test cmdAH-9.21 {Tcl_FileObjCmd: tail} {
d357 1
a357 1
test cmdAH-9.22 {Tcl_FileObjCmd: tail} {
d361 1
a361 1
test cmdAH-9.23 {Tcl_FileObjCmd: tail} {
d365 1
a365 1
test cmdAH-9.24 {Tcl_FileObjCmd: tail} {
d369 1
a369 1
test cmdAH-9.25 {Tcl_FileObjCmd: tail} {
d373 1
a373 1
test cmdAH-9.26 {Tcl_FileObjCmd: tail} {
d377 1
a377 1
test cmdAH-9.27 {Tcl_FileObjCmd: tail} {
d381 1
a381 1
test cmdAH-9.28 {Tcl_FileObjCmd: tail} {
d385 1
a385 1
test cmdAH-9.29 {Tcl_FileObjCmd: tail} {
d389 1
a389 1
test cmdAH-9.30 {Tcl_FileObjCmd: tail} {
d393 1
a393 1
test cmdAH-9.31 {Tcl_FileObjCmd: tail} {
d397 1
a397 1
test cmdAH-9.32 {Tcl_FileObjCmd: tail} {
d401 1
a401 1
test cmdAH-9.33 {Tcl_FileObjCmd: tail} {
d405 1
a405 1
test cmdAH-9.34 {Tcl_FileObjCmd: tail} {
d409 1
a409 1
test cmdAH-9.35 {Tcl_FileObjCmd: tail} {
d413 1
a413 1
test cmdAH-9.36 {Tcl_FileObjCmd: tail} {
d417 1
a417 1
test cmdAH-9.37 {Tcl_FileObjCmd: tail} {
d421 1
a421 1
test cmdAH-9.38 {Tcl_FileObjCmd: tail} {
d425 1
a425 1
test cmdAH-9.39 {Tcl_FileObjCmd: tail} {
d429 1
a429 1
test cmdAH-9.40 {Tcl_FileObjCmd: tail} {
d433 1
a433 1
test cmdAH-9.41 {Tcl_FileObjCmd: tail} {
d437 1
a437 1
test cmdAH-9.42 {Tcl_FileObjCmd: tail} {
d446 1
a446 1
test cmdAH-9.43 {Tcl_FileObjCmd: tail} {
d455 1
a455 1
test cmdAH-9.44 {Tcl_FileObjCmd: tail} {
d464 1
a464 1
test cmdAH-9.45 {Tcl_FileObjCmd: tail} {
d473 1
a473 1
test cmdAH-9.46 {Tcl_FileObjCmd: tail} {
d477 1
a477 1
test cmdAH-9.47 {Tcl_FileObjCmd: tail} {
d481 1
a481 1
test cmdAH-9.48 {Tcl_FileObjCmd: tail} {
d485 1
a485 1
test cmdAH-9.49 {Tcl_FileObjCmd: tail} {
d489 1
a489 1
test cmdAH-9.50 {Tcl_FileObjCmd: tail} {
d493 1
a493 1
test cmdAH-9.51 {Tcl_FileObjCmd: tail} {
d500 1
a500 1
test cmdAH-10.1 {Tcl_FileObjCmd: rootname} {
d504 1
a504 1
test cmdAH-10.2 {Tcl_FileObjCmd: rootname} {
d508 1
a508 1
test cmdAH-10.3 {Tcl_FileObjCmd: rootname} {
d512 1
a512 1
test cmdAH-10.4 {Tcl_FileObjCmd: rootname} {
d516 1
a516 1
test cmdAH-10.5 {Tcl_FileObjCmd: rootname} {
d520 1
a520 1
test cmdAH-10.6 {Tcl_FileObjCmd: rootname} {
d524 1
a524 1
test cmdAH-10.7 {Tcl_FileObjCmd: rootname} {
d528 1
a528 1
test cmdAH-10.8 {Tcl_FileObjCmd: rootname} {
d532 1
a532 1
test cmdAH-10.9 {Tcl_FileObjCmd: rootname} {
d536 1
a536 1
test cmdAH-10.10 {Tcl_FileObjCmd: rootname} {
d540 1
a540 1
test cmdAH-10.11 {Tcl_FileObjCmd: rootname} {
d544 1
a544 1
test cmdAH-10.12 {Tcl_FileObjCmd: rootname} {
d548 1
a548 1
test cmdAH-10.13 {Tcl_FileObjCmd: rootname} {
d552 1
a552 1
test cmdAH-10.14 {Tcl_FileObjCmd: rootname} {
d556 1
a556 1
test cmdAH-10.15 {Tcl_FileObjCmd: rootname} {
d560 1
a560 1
test cmdAH-10.16 {Tcl_FileObjCmd: rootname} {
d564 1
a564 1
test cmdAH-10.17 {Tcl_FileObjCmd: rootname} {
d568 1
a568 1
test cmdAH-10.18 {Tcl_FileObjCmd: rootname} {
d572 1
a572 1
test cmdAH-10.19 {Tcl_FileObjCmd: rootname} {
d576 1
a576 1
test cmdAH-10.20 {Tcl_FileObjCmd: rootname} {
d580 1
a580 1
test cmdAH-10.21 {Tcl_FileObjCmd: rootname} {
d584 1
a584 1
test cmdAH-10.22 {Tcl_FileObjCmd: rootname} {
d588 1
a588 1
test cmdAH-10.23 {Tcl_FileObjCmd: rootname} {
d592 1
a592 1
test cmdAH-10.24 {Tcl_FileObjCmd: rootname} {
d596 1
a596 1
test cmdAH-10.25 {Tcl_FileObjCmd: rootname} {
d600 1
a600 1
test cmdAH-10.26 {Tcl_FileObjCmd: rootname} {
d604 1
a604 1
test cmdAH-10.27 {Tcl_FileObjCmd: rootname} {
d608 1
a608 1
test cmdAH-10.28 {Tcl_FileObjCmd: rootname} {
d612 1
a612 1
test cmdAH-10.29 {Tcl_FileObjCmd: rootname} {
d616 1
a616 1
test cmdAH-10.30 {Tcl_FileObjCmd: rootname} {
d620 1
a620 1
test cmdAH-10.31 {Tcl_FileObjCmd: rootname} {
d624 1
a624 1
test cmdAH-10.32 {Tcl_FileObjCmd: rootname} {
d628 1
a628 1
test cmdAH-10.33 {Tcl_FileObjCmd: rootname} {
d632 1
a632 1
test cmdAH-10.34 {Tcl_FileObjCmd: rootname} {
d650 1
a650 1
test cmdAH-11.1 {Tcl_FileObjCmd: extension} {
d654 1
a654 1
test cmdAH-11.2 {Tcl_FileObjCmd: extension} {
d658 1
a658 1
test cmdAH-11.3 {Tcl_FileObjCmd: extension} {
d662 1
a662 1
test cmdAH-11.4 {Tcl_FileObjCmd: extension} {
d666 1
a666 1
test cmdAH-11.5 {Tcl_FileObjCmd: extension} {
d670 1
a670 1
test cmdAH-11.6 {Tcl_FileObjCmd: extension} {
d674 1
a674 1
test cmdAH-11.7 {Tcl_FileObjCmd: extension} {
d678 1
a678 1
test cmdAH-11.8 {Tcl_FileObjCmd: extension} {
d682 1
a682 1
test cmdAH-11.9 {Tcl_FileObjCmd: extension} {
d686 1
a686 1
test cmdAH-11.10 {Tcl_FileObjCmd: extension} {
d690 1
a690 1
test cmdAH-11.11 {Tcl_FileObjCmd: extension} {
d694 1
a694 1
test cmdAH-11.12 {Tcl_FileObjCmd: extension} {
d698 1
a698 1
test cmdAH-11.13 {Tcl_FileObjCmd: extension} {
d702 1
a702 1
test cmdAH-11.14 {Tcl_FileObjCmd: extension} {
d706 1
a706 1
test cmdAH-11.15 {Tcl_FileObjCmd: extension} {
d710 1
a710 1
test cmdAH-11.16 {Tcl_FileObjCmd: extension} {
d714 1
a714 1
test cmdAH-11.17 {Tcl_FileObjCmd: extension} {
d718 1
a718 1
test cmdAH-11.18 {Tcl_FileObjCmd: extension} {
d722 1
a722 1
test cmdAH-11.19 {Tcl_FileObjCmd: extension} {
d726 1
a726 1
test cmdAH-11.20 {Tcl_FileObjCmd: extension} {
d730 1
a730 1
test cmdAH-11.21 {Tcl_FileObjCmd: extension} {
d734 1
a734 1
test cmdAH-11.22 {Tcl_FileObjCmd: extension} {
d738 1
a738 1
test cmdAH-11.23 {Tcl_FileObjCmd: extension} {
d742 1
a742 1
test cmdAH-11.24 {Tcl_FileObjCmd: extension} {
d746 1
a746 1
test cmdAH-11.25 {Tcl_FileObjCmd: extension} {
d750 1
a750 1
test cmdAH-11.26 {Tcl_FileObjCmd: extension} {
d754 1
a754 1
test cmdAH-11.27 {Tcl_FileObjCmd: extension} {
d758 1
a758 1
test cmdAH-11.28 {Tcl_FileObjCmd: extension} {
d762 1
a762 1
test cmdAH-11.29 {Tcl_FileObjCmd: extension} {
d766 1
a766 1
test cmdAH-11.30 {Tcl_FileObjCmd: extension} {
d770 1
a770 1
test cmdAH-11.31 {Tcl_FileObjCmd: extension} {
d774 1
a774 1
test cmdAH-11.32 {Tcl_FileObjCmd: extension} {
d778 1
a778 1
test cmdAH-11.33 {Tcl_FileObjCmd: extension} {
d782 1
a782 1
test cmdAH-11.34 {Tcl_FileObjCmd: extension} {
d787 1
a787 1
foreach value {a..b a...b a.c..b ..b} result {.b .b .b .b} {
d799 1
a799 1
test cmdAH-12.1 {Tcl_FileObjCmd: pathtype} {
d803 1
a803 1
test cmdAH-12.2 {Tcl_FileObjCmd: pathtype} {
d807 1
a807 1
test cmdAH-12.3 {Tcl_FileObjCmd: pathtype} {
d811 1
a811 1
test cmdAH-12.4 {Tcl_FileObjCmd: pathtype} {
d818 1
a818 1
test cmdAH-13.1 {Tcl_FileObjCmd: split} {
d822 1
a822 1
test cmdAH-13.2 {Tcl_FileObjCmd: split} {
d826 1
a826 1
test cmdAH-13.3 {Tcl_FileObjCmd: split} {
d833 1
a833 1
test cmdAH-14.1 {Tcl_FileObjCmd: join} {
d837 1
a837 1
test cmdAH-14.2 {Tcl_FileObjCmd: join} {
d841 1
a841 1
test cmdAH-14.3 {Tcl_FileObjCmd: join} {
d848 1
a848 1
test cmdAH-15.1 {Tcl_FileObjCmd} {
d865 1
a865 1
test cmdAH-16.1 {Tcl_FileObjCmd: readable} {
d869 1
a869 1
test cmdAH-16.2 {Tcl_FileObjCmd: readable} {
d873 1
a873 1
test cmdAH-16.3 {Tcl_FileObjCmd: readable} {unixOnly notRoot} {
d879 1
a879 1
test cmdAH-17.1 {Tcl_FileObjCmd: writable} {
d883 1
a883 1
test cmdAH-17.2 {Tcl_FileObjCmd: writable} {notRoot} {
d887 1
a887 1
test cmdAH-17.3 {Tcl_FileObjCmd: writable} {
d897 1
a897 1
test cmdAH-18.1 {Tcl_FileObjCmd: executable} {
d900 1
a900 1
test cmdAH-18.2 {Tcl_FileObjCmd: executable} {
d903 1
a903 1
test cmdAH-18.3 {Tcl_FileObjCmd: executable} {unixOnly} {
d911 1
a911 1
test cmdAH-18.4 {Tcl_FileObjCmd: executable} {macOnly} {
d918 1
a918 1
test cmdAH-18.5 {Tcl_FileObjCmd: executable} {pcOnly} {
d927 1
a927 1
test cmdAH-18.6 {Tcl_FileObjCmd: executable} {
d940 1
a940 1
test cmdAH-19.1 {Tcl_FileObjCmd: exists} {
d943 2
a944 2
test cmdAH-19.2 {Tcl_FileObjCmd: exists} {file exists gorp.file} 0
test cmdAH-19.3 {Tcl_FileObjCmd: exists} {
d952 1
a952 1
test cmdAH-19.4 {Tcl_FileObjCmd: exists} {
d955 1
a955 1
test cmdAH-19.5 {Tcl_FileObjCmd: exists} {
d964 1
a964 1
test cmdAH-19.6 {Tcl_FileObjCmd: nativename} {
d968 1
a968 1
test cmdAH-19.7 {Tcl_FileObjCmd: nativename} {
d972 1
a972 1
test cmdAH-19.8 {Tcl_FileObjCmd: nativename} {
d978 1
a978 1
test cmdAH-19.9 {Tcl_FileObjCmd: ~ : exists} {
d981 1
a981 1
test cmdAH-19.10 {Tcl_FileObjCmd: ~ : nativename} {
d990 2
a991 2
test cmdAH-19.11 {Tcl_FileObjCmd: exists} {unixOnly notRoot} {
    removeFile /tmp/tcl.foo.dir/file
d996 5
a1000 3

    set result [file exists /tmp/tcl.foo.dir/file]

d1002 1
a1002 1
    removeFile /tmp/tcl.foo.dir/file
d1004 1
a1004 2
    set result
} 0
d1015 4
a1018 6
set file [makeFile "data" touch.me]

test cmdAH-20.1 {Tcl_FileObjCmd: atime} {
    list [catch {file atime a b c} msg] $msg
} {1 {wrong # args: should be "file atime name ?time?"}}
test cmdAH-20.2 {Tcl_FileObjCmd: atime} {
d1024 1
a1024 1
test cmdAH-20.3 {Tcl_FileObjCmd: atime} {
d1027 1
a1027 21
} {1 {could not read "_bogus_": no such file or directory} {posix enoent {no such file or directory}}}
test cmdAH-20.4 {Tcl_FileObjCmd: atime} {
    list [catch {file atime $file notint} msg] $msg
} {1 {expected integer but got "notint"}}
test cmdAH-20.5 {Tcl_FileObjCmd: atime touch} {
    if {[string equal $tcl_platform(platform) "windows"]} {
	set old [pwd]
	cd $::tcltest::temporaryDirectory
	if {![string equal "NTFS" [testvolumetype]]} {
	    # Windows FAT doesn't understand atime, but NTFS does
	    # May also fail for Windows on NFS mounted disks
	    cd $old
	    return 1
	}
	cd $old
    }
    set atime [file atime $file]
    after 1100; # pause a sec to notice change in atime
    set newatime [clock seconds]
    expr {$newatime==[file atime $file $newatime]}
} 1
d1031 1
a1031 1
test cmdAH-21.1 {Tcl_FileObjCmd: isdirectory} {
d1034 1
a1034 1
test cmdAH-21.2 {Tcl_FileObjCmd: isdirectory} {
d1037 1
a1037 1
test cmdAH-21.3 {Tcl_FileObjCmd: isdirectory} {
d1043 1
a1043 1
test cmdAH-22.1 {Tcl_FileObjCmd: isfile} {
d1046 2
a1047 2
test cmdAH-22.2 {Tcl_FileObjCmd: isfile} {file isfile gorp.file} 1
test cmdAH-22.3 {Tcl_FileObjCmd: isfile} {file isfile dir.file} 0
d1053 1
a1053 1
test cmdAH-23.1 {Tcl_FileObjCmd: lstat} {
d1056 1
a1056 1
test cmdAH-23.2 {Tcl_FileObjCmd: lstat} {
d1059 1
a1059 1
test cmdAH-23.3 {Tcl_FileObjCmd: lstat} {unixOnly nonPortable} {
d1064 1
a1064 1
test cmdAH-23.4 {Tcl_FileObjCmd: lstat} {unixOnly nonPortable} {
d1069 1
a1069 1
test cmdAH-23.5 {Tcl_FileObjCmd: lstat errors} {nonPortable} {
d1072 2
a1073 2
} {1 {could not read "_bogus_": no such file or directory} {posix enoent {no such file or directory}}}
test cmdAH-23.6 {Tcl_FileObjCmd: lstat errors} {
d1082 4
a1085 6
set file [makeFile "data" touch.me]

test cmdAH-24.1 {Tcl_FileObjCmd: mtime} {
    list [catch {file mtime a b c} msg] $msg
} {1 {wrong # args: should be "file mtime name ?time?"}}
test cmdAH-24.2 {Tcl_FileObjCmd: mtime} {
d1094 1
a1094 1
test cmdAH-24.3 {Tcl_FileObjCmd: mtime} {
d1100 1
a1100 1
test cmdAH-24.4 {Tcl_FileObjCmd: mtime} {
d1103 2
a1104 2
} {1 {could not read "_bogus_": no such file or directory} {posix enoent {no such file or directory}}}
test cmdAH-24.5 {Tcl_FileObjCmd: mtime} {
d1108 1
a1108 1
    if {[string equal $tcl_platform(platform) "unix"]} {
d1114 3
a1116 2
    # Make sure that a new file's time is correct.  10 seconds variance 
    # is allowed used due to slow networks or clock skew on a network drive.
a1123 9
test cmdAH-24.7 {Tcl_FileObjCmd: mtime} {
    list [catch {file mtime $file notint} msg] $msg
} {1 {expected integer but got "notint"}}
test cmdAH-24.8 {Tcl_FileObjCmd: mtime touch} {
    set mtime [file mtime $file]
    after 1100; # pause a sec to notice change in mtime
    set newmtime [clock seconds]
    expr {$newmtime==[file mtime $file $newmtime]}
} 1
d1128 1
a1128 1
test cmdAH-25.1 {Tcl_FileObjCmd: owned} {
d1131 1
a1131 1
test cmdAH-25.2 {Tcl_FileObjCmd: owned} {
d1134 1
a1134 1
test cmdAH-25.3 {Tcl_FileObjCmd: owned} {unixOnly notRoot} {
d1140 1
a1140 1
test cmdAH-26.1 {Tcl_FileObjCmd: readlink} {
d1143 1
a1143 1
test cmdAH-26.2 {Tcl_FileObjCmd: readlink} {unixOnly nonPortable} {
d1146 1
a1146 1
test cmdAH-26.3 {Tcl_FileObjCmd: readlink errors} {unixOnly nonPortable} {
d1149 2
a1150 2
} {1 {could not readlink "_bogus_": no such file or directory} {posix enoent {no such file or directory}}}
test cmdAH-26.4 {Tcl_FileObjCmd: readlink errors} {macOnly nonPortable} {
d1153 2
a1154 2
} {1 {could not readlink "_bogus_": no such file or directory} {posix enoent {no such file or directory}}}
test cmdAH-26.5 {Tcl_FileObjCmd: readlink errors} {pcOnly nonPortable} {
d1157 1
a1157 1
} {1 {could not readlink "_bogus_": invalid argument} {posix einval {invalid argument}}}
d1161 1
a1161 1
test cmdAH-27.1 {Tcl_FileObjCmd: size} {
d1164 1
a1164 1
test cmdAH-27.2 {Tcl_FileObjCmd: size} {
d1172 1
a1172 1
test cmdAH-27.3 {Tcl_FileObjCmd: size} {
d1175 1
a1175 1
} {1 {could not read "_bogus_": no such file or directory} {posix enoent {no such file or directory}}}
d1183 1
a1183 1
test cmdAH-28.1 {Tcl_FileObjCmd: stat} {
d1186 1
a1186 1
test cmdAH-28.2 {Tcl_FileObjCmd: stat} {
d1189 1
a1189 1
test cmdAH-28.3 {Tcl_FileObjCmd: stat} {
d1194 1
a1194 1
test cmdAH-28.4 {Tcl_FileObjCmd: stat} {
d1199 1
a1199 1
test cmdAH-28.5 {Tcl_FileObjCmd: stat} {unixOnly} {
d1204 1
a1204 1
test cmdAH-28.6 {Tcl_FileObjCmd: stat} {
d1207 2
a1208 2
} {1 {could not read "_bogus_": no such file or directory} {posix enoent {no such file or directory}}}
test cmdAH-28.7 {Tcl_FileObjCmd: stat} {
a1212 52
test cmdAH-28.8 {Tcl_FileObjCmd: stat} {
    # Sign extension of purported unsigned short to int.

    close [open foo.test w]
    file stat foo.test stat
    set x [expr {$stat(mode) > 0}]
    file delete foo.test
    set x
} 1
test cmdAH-28.9 {Tcl_FileObjCmd: stat} {pcOnly} {
    # stat of root directory was failing.
    # don't care about answer, just that test runs.

    # relative paths that resolve to root
    set old [pwd]
    cd c:/
    file stat c: stat	    
    file stat c:. stat
    file stat . stat
    cd $old

    file stat / stat
    file stat c:/ stat
    file stat c:/. stat
} {}
test cmdAH-28.10 {Tcl_FileObjCmd: stat} {pcOnly nonPortable} {
    # stat of root directory was failing.
    # don't care about answer, just that test runs.

    file stat //pop/$env(USERNAME) stat
    file stat //pop/$env(USERNAME)/ stat
    file stat //pop/$env(USERNAME)/. stat
} {}    
test cmdAH-28.11 {Tcl_FileObjCmd: stat} {pcOnly nonPortable} {
    # stat of network directory was returning id of current local drive.

    set old [pwd]
    cd c:/

    file stat //pop/$env(USERNAME) stat
    cd $old
    expr {$stat(dev) == 2}
} 0
test cmdAH-28.12 {Tcl_FileObjCmd: stat} {
    # stat(mode) with S_IFREG flag was returned as a negative number
    # if mode_t was a short instead of an unsigned short.

    close [open foo.test w]
    file stat foo.test stat
    file delete foo.test
    expr {$stat(mode) > 0}
} 1
d1219 1
a1219 1
test cmdAH-29.1 {Tcl_FileObjCmd: type} {
d1222 1
a1222 1
test cmdAH-29.2 {Tcl_FileObjCmd: type} {
d1225 1
a1225 1
test cmdAH-29.3 {Tcl_FileObjCmd: type} {
d1228 1
a1228 1
test cmdAH-29.4 {Tcl_FileObjCmd: type} {unixOnly nonPortable} {
d1234 1
a1234 1
test cmdAH-29.5 {Tcl_FileObjCmd: type} {
d1236 1
a1236 1
} {1 {could not read "_bogus_": no such file or directory} {posix enoent {no such file or directory}}}
d1240 1
a1240 1
test cmdAH-30.1 {Tcl_FileObjCmd: error conditions} {
d1242 2
a1243 2
} {1 {bad option "gorp": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, lstat, mtime, mkdir, nativename, owned, pathtype, readable, readlink, rename, rootname, size, split, stat, tail, type, volumes, or writable}}
test cmdAH-30.2 {Tcl_FileObjCmd: error conditions} {
d1245 2
a1246 2
} {1 {ambiguous option "ex": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, lstat, mtime, mkdir, nativename, owned, pathtype, readable, readlink, rename, rootname, size, split, stat, tail, type, volumes, or writable}}
test cmdAH-30.3 {Tcl_FileObjCmd: error conditions} {
d1248 2
a1249 2
} {1 {ambiguous option "is": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, lstat, mtime, mkdir, nativename, owned, pathtype, readable, readlink, rename, rootname, size, split, stat, tail, type, volumes, or writable}}
test cmdAH-30.4 {Tcl_FileObjCmd: error conditions} {
d1251 2
a1252 2
} {1 {bad option "z": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, lstat, mtime, mkdir, nativename, owned, pathtype, readable, readlink, rename, rootname, size, split, stat, tail, type, volumes, or writable}}
test cmdAH-30.5 {Tcl_FileObjCmd: error conditions} {
d1254 2
a1255 2
} {1 {ambiguous option "read": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, lstat, mtime, mkdir, nativename, owned, pathtype, readable, readlink, rename, rootname, size, split, stat, tail, type, volumes, or writable}}
test cmdAH-30.6 {Tcl_FileObjCmd: error conditions} {
d1257 2
a1258 2
} {1 {ambiguous option "s": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, lstat, mtime, mkdir, nativename, owned, pathtype, readable, readlink, rename, rootname, size, split, stat, tail, type, volumes, or writable}}
test cmdAH-30.7 {Tcl_FileObjCmd: error conditions} {
d1260 2
a1261 2
} {1 {ambiguous option "t": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, lstat, mtime, mkdir, nativename, owned, pathtype, readable, readlink, rename, rootname, size, split, stat, tail, type, volumes, or writable}}
test cmdAH-30.8 {Tcl_FileObjCmd: error conditions} {
a1264 20
# channels

test cmdAH-31.1 {Tcl_FileObjCmd: channels, too many args} {
    list [catch {file channels a b} msg] $msg
} {1 {wrong # args: should be "file channels ?pattern?"}}
test cmdAH-31.2 {Tcl_FileObjCmd: channels, too many args} {
    file chan
} {stderr stdout stdin}
test cmdAH-31.3 {Tcl_FileObjCmd: channels, too many args} {
    string equal [file channels] [file channels *]
} {1}
test cmdAH-31.4 {Tcl_FileObjCmd: channels} {
    set old [file channels gorp.file]
    set f [open gorp.file w]
    set new [file channels file*]
    close $f
    string equal $f $new
} {1}

# cleanup
a1267 2
# Tcl_ForObjCmd is tested in for.test

d1273 1
a1273 18
cd $cmdAHwd

::tcltest::cleanupTests
return














@


1.1.1.3
log
@import tcl 8.4.0
@
text
@d13 1
a13 1
# RCS: @@(#) $Id: cmdAH.test,v 1.29 2002/07/11 08:25:24 dkf Exp $
d16 1
a16 1
    package require tcltest 2.1
a19 2
tcltest::testConstraint testchmod [string equal testchmod [info commands testchmod]]

a42 1
set foodir [file join [temporaryDirectory] foo]
d44 3
a46 3
    file delete -force $foodir
    file mkdir $foodir
    cd $foodir
d49 1
a49 1
    file delete $foodir
d57 3
a59 3
    file delete -force $foodir
    file mkdir $foodir
    cd $foodir
d61 2
a62 2
    set result [string equal [pwd] $oldpwd]
    file delete $foodir
d71 3
a73 3
    file delete -force $foodir
    file mkdir $foodir
    cd $foodir
d75 2
a76 2
    set result [string equal [pwd] $oldpwd]
    file delete $foodir
d169 1
a169 1
} {1 {bad option "x": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, link, lstat, mtime, mkdir, nativename, normalize, owned, pathtype, readable, readlink, rename, rootname, separator, size, split, stat, system, tail, type, volumes, or writable}}
d173 1
a173 3
test cmdAH-5.4 {Tcl_FileObjCmd} {
    list [catch {file exists ""} msg] $msg
} {0 0}
a196 8
test cmdAH-6.5 {cd} {unixOnly nonPortable} {
    set dir [pwd]
    cd /
    set res [pwd]
    cd $dir
    set res
} {/}

d200 4
a203 8
    set foofile [makeFile abcde foo.file]
    catch {file delete -force $foofile}
    close [open $foofile w]
    set res [catch {file attributes $foofile}]
    # We used [makeFile] so we undo with [removeFile]
    removeFile $foofile
    set res
} {0}
a1002 3
set gorpfile [makeFile abcde gorp.file]
set dirfile [makeDirectory dir.file]

d1007 4
a1010 1
test cmdAH-16.1 {Tcl_FileObjCmd: readable} {testchmod} {
d1013 3
a1015 3
testchmod 0444 $gorpfile
test cmdAH-16.2 {Tcl_FileObjCmd: readable} {testchmod} {
    file readable $gorpfile
d1017 3
a1019 3
testchmod 0333 $gorpfile
test cmdAH-16.3 {Tcl_FileObjCmd: readable} {unixOnly notRoot testchmod} {
    file reada $gorpfile
d1024 1
a1024 1
test cmdAH-17.1 {Tcl_FileObjCmd: writable} {testchmod} {
d1027 3
a1029 3
testchmod 0555 $gorpfile
test cmdAH-17.2 {Tcl_FileObjCmd: writable} {notRoot testchmod} {
    file writable $gorpfile
d1031 3
a1033 3
testchmod 0222 $gorpfile
test cmdAH-17.3 {Tcl_FileObjCmd: writable} {testchmod} {
    file writable $gorpfile
a1034 1
}
d1038 3
a1040 4
removeFile $gorpfile
removeDirectory $dirfile
set dirfile [makeDirectory dir.file]
set gorpfile [makeFile abcde gorp.file]
d1042 1
a1042 1
test cmdAH-18.1 {Tcl_FileObjCmd: executable} {testchmod} {
d1045 2
a1046 2
test cmdAH-18.2 {Tcl_FileObjCmd: executable} {testchmod} {
    file executable $gorpfile
d1048 1
a1048 1
test cmdAH-18.3 {Tcl_FileObjCmd: executable} {unixOnly testchmod} {
d1052 2
a1053 2
    testchmod 0775 $gorpfile
    file exe $gorpfile
d1056 1
a1056 1
test cmdAH-18.4 {Tcl_FileObjCmd: executable} {macOnly testchmod} {
d1059 3
a1061 3
    set x [file exe $gorpfile]    
    file attrib $gorpfile -type APPL
    lappend x [file exe $gorpfile]
d1063 1
a1063 1
test cmdAH-18.5 {Tcl_FileObjCmd: executable} {pcOnly testchmod} {
d1066 4
a1069 4
    set x [file exe $gorpfile]
    set gorpexe [makeFile foo gorp.exe]
    lappend x [file exe $gorpexe]
    removeFile $gorpexe
d1072 1
a1072 1
test cmdAH-18.6 {Tcl_FileObjCmd: executable} {testchmod} {
d1075 1
a1075 1
    file exe $dirfile
d1078 4
a1081 4
removeDirectory $dirfile
removeFile $gorpfile
set linkfile [file join [temporaryDirectory] link.file]
file delete $linkfile
d1088 1
a1088 1
test cmdAH-19.2 {Tcl_FileObjCmd: exists} {file exists $gorpfile} 0
d1090 1
a1090 1
    file exists [file join [temporaryDirectory] dir.file gorp.file]
d1093 3
a1095 3
    set gorpfile [makeFile abcde gorp.file]
    set dirfile [makeDirectory dir.file]
    set subgorp [makeFile 12345 [file join $dirfile gorp.file]]
d1098 1
a1098 1
    file exists $gorpfile
d1101 1
a1101 1
    file exists $subgorp
d1136 2
a1137 2
    file delete -force /tmp/tcl.foo.dir/file
    file delete -force /tmp/tcl.foo.dir
d1140 1
a1140 1
    file attributes /tmp/tcl.foo.dir -permissions 0000
d1144 1
a1144 1
    file attributes /tmp/tcl.foo.dir -permissions 0775
d1153 3
a1155 3
removeFile $gorpfile
set gorpfile [makeFile "Test string" gorp.file]
catch {file attributes $gorpfile -permissions 0765}
d1166 3
a1168 3
    file stat $gorpfile stat
    list [expr {[file mtime $gorpfile] == $stat(mtime)}] \
	    [expr {[file atime $gorpfile] == $stat(atime)}]
d1177 1
a1177 1
test cmdAH-20.5 {Tcl_FileObjCmd: atime touch} {unixOrPc} {
d1192 1
a1192 2
    set modatime [file atime $file $newatime]
    expr {$newatime == $modatime ? 1 : "$newatime != $modatime"}
a1194 1
removeFile touch.me
d1201 1
a1201 1
    file isdirectory $gorpfile
d1204 1
a1204 1
    file isd $dirfile
d1212 2
a1213 2
test cmdAH-22.2 {Tcl_FileObjCmd: isfile} {file isfile $gorpfile} 1
test cmdAH-22.3 {Tcl_FileObjCmd: isfile} {file isfile $dirfile} 0
d1218 1
a1218 1
catch {file link -symbolic $linkfile $gorpfile}
d1227 1
a1227 1
    file lstat $linkfile stat
d1232 1
a1232 1
    file lstat $linkfile stat
d1242 1
a1242 1
    list [catch {file lstat $gorpfile x} msg] $msg $errorCode
a1245 35
# mkdir

set dirA [file join [temporaryDirectory] a]
set dirB [file join [temporaryDirectory] a]
test cmdAH-23.7 {Tcl_FileObjCmd: mkdir} {
    catch {file delete -force $dirA}
    file mkdir $dirA
    set res [file isdirectory $dirA]
    file delete $dirA
    set res
} {1}
test cmdAH-23.8 {Tcl_FileObjCmd: mkdir} {
    catch {file delete -force $dirA}
    file mkdir $dirA/b
    set res [file isdirectory $dirA/b]
    file delete -force $dirA
    set res
} {1}
test cmdAH-23.9 {Tcl_FileObjCmd: mkdir} {
    catch {file delete -force $dirA}
    file mkdir $dirA/b/c
    set res [file isdirectory $dirA/b/c]
    file delete -force $dirA
    set res
} {1}
test cmdAH-23.10 {Tcl_FileObjCmd: mkdir} {
    catch {file delete -force $dirA}
    catch {file delete -force $dirB}
    file mkdir $dirA/b $dirB/a/c
    set res [list [file isdirectory $dirA/b] [file isdirectory $dirB/a/c]]
    file delete -force $dirA
    file delete -force $dirB
    set res
} {1 1}

a1252 7
# Check (allowing for clock-skew and OS interrupts as best we can)
# that the change in mtime on a file being written is the time elapsed
# between writes.  Note that this can still fail on very busy systems
# if there are long preemptions between the writes and the reading of
# the clock, but there's not much you can do about that other than the
# completely horrible "keep on trying to write until you managed to do
# it all in less than a second."  - DKF
d1254 1
a1254 5
    set f [open $gorpfile w]
    puts $f "More text"
    set localOld [clock seconds]
    close $f
    set old [file mtime $gorpfile]
d1256 1
a1256 1
    set f [open $gorpfile w]
a1257 1
    set localNew [clock seconds]
d1259 2
a1260 5
    set new [file mtime $gorpfile]
    expr {
	($new > $old) && ($localNew > $localOld) &&
	(abs(($new-$old) - ($localNew-$localOld)) <= 1)
    }
d1264 3
a1266 3
    file stat $gorpfile stat
    list [expr {[file mtime $gorpfile] == $stat(mtime)}] \
	    [expr {[file atime $gorpfile] == $stat(atime)}]
d1277 1
a1277 1
	set name /tmp/tcl.test.[pid]
d1279 1
a1279 1
	set name [file join [temporaryDirectory] tf]
d1298 1
a1298 2
    set modmtime [file mtime $file $newmtime]
    expr {$newmtime == $modmtime ? 1 : "$newmtime != $modmtime"}
d1300 1
a1300 1
removeFile touch.me
d1308 1
a1308 1
    file owned $gorpfile
d1320 2
a1321 2
    file readlink $linkfile
} $gorpfile
d1341 2
a1342 2
    set oldsize [file size $gorpfile]
    set f [open $gorpfile a]
d1346 1
a1346 1
    expr {[file size $gorpfile] - $oldsize}
d1356 2
a1357 3
removeFile $gorpfile
set gorpfile [makeFile "Test string" gorp.file]
catch {file attributes $gorpfile -permissions 0765}
d1367 1
a1367 1
    file stat $gorpfile stat
d1372 1
a1372 1
    file stat $gorpfile stat
d1377 1
a1377 1
    file stat $gorpfile stat
d1387 1
a1387 1
    list [catch {file stat $gorpfile x} msg] $msg $errorCode
d1392 2
a1393 2
    set filename [makeFile "" foo.text]
    file stat $filename stat
d1395 1
a1395 1
    removeFile $filename
d1436 3
a1438 3
    set filename [makeFile "" foo.test]
    file stat $filename stat
    removeFile $filename
d1445 2
d1451 1
a1451 1
    file type $dirfile
a1452 6
test cmdAH-29.3.0 {Tcl_FileObjCmd: delete removes link not file} {unixOnly nonPortable} {
    set exists [list [file exists $linkfile] [file exists $gorpfile]]
    file delete $linkfile
    set exists2	[list [file exists $linkfile] [file exists $gorpfile]]
    list $exists $exists2
} {{1 1} {0 1}}
d1454 1
a1454 1
    file type $gorpfile
d1456 4
a1459 25
test cmdAH-29.4 {Tcl_FileObjCmd: type} {unixOnly} {
    catch {file delete $linkfile}
    # Unlike [exec ln -s], [file link] requires an existing target
    file link -symbolic $linkfile $gorpfile
    set result [file type $linkfile]
    file delete $linkfile
    set result
} link
if {[string equal $tcl_platform(platform) "windows"]} {
    if {[string index $tcl_platform(osVersion) 0] >= 5 \
      && ([lindex [file system [temporaryDirectory]] 1] == "NTFS")} {
	tcltest::testConstraint linkDirectory 1
    } else {
	tcltest::testConstraint linkDirectory 0
    }
} else {
    tcltest::testConstraint linkDirectory 1
}
test cmdAH-29.4.1 {Tcl_FileObjCmd: type} {linkDirectory} {
    set tempdir [makeDirectory temp]
    set linkdir [file join [temporaryDirectory] link.dir]
    file link -symbolic $linkdir $tempdir
    set result [file type $linkdir]
    file delete $linkdir
    removeDirectory $tempdir
d1470 1
a1470 1
} {1 {bad option "gorp": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, link, lstat, mtime, mkdir, nativename, normalize, owned, pathtype, readable, readlink, rename, rootname, separator, size, split, stat, system, tail, type, volumes, or writable}}
d1473 1
a1473 1
} {1 {ambiguous option "ex": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, link, lstat, mtime, mkdir, nativename, normalize, owned, pathtype, readable, readlink, rename, rootname, separator, size, split, stat, system, tail, type, volumes, or writable}}
d1476 1
a1476 1
} {1 {ambiguous option "is": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, link, lstat, mtime, mkdir, nativename, normalize, owned, pathtype, readable, readlink, rename, rootname, separator, size, split, stat, system, tail, type, volumes, or writable}}
d1479 1
a1479 1
} {1 {bad option "z": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, link, lstat, mtime, mkdir, nativename, normalize, owned, pathtype, readable, readlink, rename, rootname, separator, size, split, stat, system, tail, type, volumes, or writable}}
d1482 1
a1482 1
} {1 {ambiguous option "read": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, link, lstat, mtime, mkdir, nativename, normalize, owned, pathtype, readable, readlink, rename, rootname, separator, size, split, stat, system, tail, type, volumes, or writable}}
d1485 1
a1485 1
} {1 {ambiguous option "s": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, link, lstat, mtime, mkdir, nativename, normalize, owned, pathtype, readable, readlink, rename, rootname, separator, size, split, stat, system, tail, type, volumes, or writable}}
d1488 1
a1488 1
} {1 {ambiguous option "t": must be atime, attributes, channels, copy, delete, dirname, executable, exists, extension, isdirectory, isfile, join, link, lstat, mtime, mkdir, nativename, normalize, owned, pathtype, readable, readlink, rename, rootname, separator, size, split, stat, system, tail, type, volumes, or writable}}
a1493 7
# In testing 'file channels', we need to make sure that a channel
# created in one interp isn't visible in another.

interp create simpleInterp
interp create -safe safeInterp
interp c
safeInterp expose file file
d1499 3
a1501 4
    # Normal interps start out with only the standard channels
    lsort [simpleInterp eval [list file chan]]
} [lsort {stderr stdout stdin}]
test cmdAH-31.3 {Tcl_FileObjCmd: channels, globbing} {
d1504 6
a1509 9
test cmdAH-31.4 {Tcl_FileObjCmd: channels, globbing} {
    lsort [file channels std*]
} [lsort {stdout stderr stdin}]

set newFileId [open $gorpfile w]

test cmdAH-31.5 {Tcl_FileObjCmd: channels} {
    set res [file channels $newFileId]
    string equal $newFileId $res
a1510 44
test cmdAH-31.6 {Tcl_FileObjCmd: channels in other interp} {
    # Safe interps start out with no channels
    safeInterp eval [list file channels]
} {}
test cmdAH-31.7 {Tcl_FileObjCmd: channels in other interp} {
    list [catch {safeInterp eval [list puts $newFileId "hello"]} msg] $msg
} [list 1 "can not find channel named \"$newFileId\""]

interp share {} $newFileId safeInterp
interp share {} stdout safeInterp

test cmdAH-31.8 {Tcl_FileObjCmd: channels in other interp} {
    # $newFileId should now be visible in both interps
    list [file channels $newFileId] \
	    [safeInterp eval [list file channels $newFileId]]
} [list $newFileId $newFileId]
test cmdAH-31.9 {Tcl_FileObjCmd: channels in other interp} {
    lsort [safeInterp eval [list file channels]]
} [lsort [list stdout $newFileId]]
test cmdAH-31.10 {Tcl_FileObjCmd: channels in other interp} {
    # we can now write to $newFileId from slave
    safeInterp eval [list puts $newFileId "hello"]
} {}

interp transfer {} $newFileId safeInterp

test cmdAH-31.11 {Tcl_FileObjCmd: channels in other interp} {
    # $newFileId should now be visible only in safeInterp
    list [file channels $newFileId] \
	    [safeInterp eval [list file channels $newFileId]]
} [list {} $newFileId]
test cmdAH-31.12 {Tcl_FileObjCmd: channels in other interp} {
    lsort [safeInterp eval [list file channels]]
} [lsort [list stdout $newFileId]]
test cmdAH-31.13 {Tcl_FileObjCmd: channels in other interp} {
    safeInterp eval [list close $newFileId]
    safeInterp eval [list file channels]
} {stdout}

# This shouldn't work, but just in case a test above failed...
catch {close $newFileId}

interp delete safeInterp
interp delete simpleInterp
d1518 4
a1521 5
catch {file attributes $dirfile -permissions 0777}
removeDirectory $dirfile
removeFile $gorpfile
# No idea how well [removeFile] copes with links...
file delete $linkfile
d1527 14
@


