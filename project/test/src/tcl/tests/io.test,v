head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.58
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.56
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.54
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.52
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.50
	gdb_7_0-branch:1.5.0.48
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tcl8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.46
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.44
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.42
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.40
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.38
	gdb_6_5-2006-05-14-branchpoint:1.5
	readline_5_1-import-branch:1.5.0.36
	readline_5_1-import-branchpoint:1.5
	gdb_6_4-branch:1.5.0.34
	gdb_6_4-2005-11-01-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.32
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	ezannoni_pie-20040323-branch:1.5.0.30
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.28
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.26
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.24
	cagney_x86i386-20030821-branch:1.5.0.22
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.20
	gdb_6_0-2003-06-23-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.18
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.16
	cagney_writestrings-20030508-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.14
	cagney_fileio-20030521-branchpoint:1.5
	carlton_dictionary-20030430-merge:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.12
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.10
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.8
	cagney_lazyid-20030317-branchpoint:1.5
	offbyone-20030313-branch:1.5.0.6
	offbyone-20030313-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.4
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.2
	interps-20030202-branchpoint:1.5
	TCL8_4_1:1.1.1.3
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.2
	TCL_8_4_1:1.1.1.3
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.4
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TCL_8_4_0:1.1.1.3
	carlton_dictionary-branch:1.2.0.16
	carlton_dictionary-20020920-branchpoint:1.2
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.14
	gdb_5_3-branch:1.2.0.12
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.10
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.8
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.6
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TCL_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	dejagnu-2000-02-04:1.1.1.1
	dejagnu-2000-01-31:1.1.1.1
	dejagnu-2000-01-24:1.1.1.1
	dejagnu-2000-01-17:1.1.1.1
	dejagnu-2000-01-10:1.1.1.1
	dejagnu-2000-01-04:1.1.1.1
	dejagnu-1999-12-21:1.1.1.1
	dejagnu-1999-12-13:1.1.1.1
	dejagnu-1999-12-07:1.1.1.1
	dejagnu-1999-12-06:1.1.1.1
	dejagnu-1999-11-15:1.1.1.1
	dejagnu-1999-11-08:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2003.01.21.19.40.15;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.26.19.48.01;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.37.07;	author kseitz;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2001.09.09.23.56.08;	author irox;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2002.09.27.21.49.10;	author kseitz;	state Exp;
branches;
next	;

1.3.4.1
date	2003.12.14.20.28.49;	author drow;	state Exp;
branches;
next	;

1.2.16.1
date	2002.12.23.19.40.40;	author carlton;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2003.02.07.19.18.19;	author carlton;	state Exp;
branches;
next	;

1.1.1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.09.22.40.58;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.19.56.37;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tcl 8.4.1
@
text
@# Functionality covered: operation of all IO commands, and all procedures
# defined in generic/tclIO.c.
#
# This file contains a collection of tests for one or more of the Tcl
# built-in commands.  Sourcing this file into Tcl runs the tests and
# generates output for errors.  No output means no errors were found.
#
# Copyright (c) 1991-1994 The Regents of the University of California.
# Copyright (c) 1994-1997 Sun Microsystems, Inc.
# Copyright (c) 1998-1999 by Scriptics Corporation.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# RCS: @@(#) $Id: io.test,v 1.37 2002/07/30 18:36:26 andreas_kupries Exp $

if {[catch {package require tcltest 2}]} {
    puts stderr "Skipping tests in [info script].  tcltest 2 required."
    return
}
namespace eval ::tcl::test::io {

    namespace import ::tcltest::cleanupTests
    namespace import ::tcltest::interpreter
    namespace import ::tcltest::makeFile
    namespace import ::tcltest::removeFile
    namespace import ::tcltest::test
    namespace import ::tcltest::testConstraint
    namespace import ::tcltest::viewFile

testConstraint testchannel [llength [info commands testchannel]]
testConstraint exec [llength [info commands exec]]

# You need a *very* special environment to do some tests.  In
# particular, many file systems do not support large-files...
testConstraint largefileSupport 0

removeFile test1
removeFile pipe

# set up a long data file for some of the following tests

set path(longfile) [makeFile {} longfile]
set f [open $path(longfile) w]
fconfigure $f -eofchar {} -translation lf
for { set i 0 } { $i < 100 } { incr i} {
    puts $f "#123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef
\#123456789abcdef01
\#"
    }
close $f

set path(cat) [makeFile {
    set f stdin
    if {$argv != ""} {
	set f [open $argv]
    }
    fconfigure $f -encoding binary -translation lf -blocking 0 -eofchar \x1a
    fconfigure stdout -encoding binary -translation lf -buffering none
    fileevent $f readable "foo $f"
    proc foo {f} {
	set x [read $f]
	catch {puts -nonewline $x}
	if {[eof $f]} {
	    close $f
	    exit 0
	}
    }
    vwait forever
} cat]

set thisScript [file join [pwd] [info script]]

proc contents {file} {
    set f [open $file]
    fconfigure $f -translation binary
    set a [read $f]
    close $f
    return $a
}

test io-1.5 {Tcl_WriteChars: CheckChannelErrors} {emptyTest} {
    # no test, need to cause an async error.
} {}

set path(test1) [makeFile {} test1]

test io-1.6 {Tcl_WriteChars: WriteBytes} {
    set f [open $path(test1) w]
    fconfigure $f -encoding binary
    puts -nonewline $f "a\u4e4d\0"
    close $f
    contents $path(test1)
} "a\x4d\x00"
test io-1.7 {Tcl_WriteChars: WriteChars} {
    set f [open $path(test1) w]
    fconfigure $f -encoding shiftjis
    puts -nonewline $f "a\u4e4d\0"
    close $f
    contents $path(test1)
} "a\x93\xe1\x00"

set path(test2) [makeFile {} test2]

test io-1.8 {Tcl_WriteChars: WriteChars} {
    # This test written for SF bug #506297.
    #
    # Executing this test without the fix for the referenced bug
    # applied to tcl will cause tcl, more specifically WriteChars, to
    # go into an infinite loop.

    set f [open $path(test2) w] 
    fconfigure      $f -encoding iso2022-jp 
    puts -nonewline $f [format %s%c [string repeat " " 4] 12399] 
    close           $f 
    contents $path(test2)
} "    \x1b\$B\$O\x1b(B"

test io-2.1 {WriteBytes} {
    # loop until all bytes are written
    
    set f [open $path(test1) w]
    fconfigure $f  -encoding binary -buffersize 16 -translation crlf
    puts $f "abcdefghijklmnopqrstuvwxyz"
    close $f
    contents $path(test1)
} "abcdefghijklmnopqrstuvwxyz\r\n"
test io-2.2 {WriteBytes: savedLF > 0} {
    # After flushing buffer, there was a \n left over from the last
    # \n -> \r\n expansion.  It gets stuck at beginning of this buffer.

    set f [open $path(test1) w]
    fconfigure $f -encoding binary -buffersize 16 -translation crlf
    puts -nonewline $f "123456789012345\n12"
    set x [list [contents $path(test1)]]
    close $f
    lappend x [contents $path(test1)]
} [list "123456789012345\r" "123456789012345\r\n12"]
test io-2.3 {WriteBytes: flush on line} {
    # Tcl "line" buffering has weird behavior: if current buffer contains
    # a \n, entire buffer gets flushed.  Logical behavior would be to flush
    # only up to the \n.
    
    set f [open $path(test1) w]
    fconfigure $f -encoding binary -buffering line -translation crlf
    puts -nonewline $f "\n12"
    set x [contents $path(test1)]
    close $f
    set x
} "\r\n12"
test io-2.4 {WriteBytes: reset sawLF after each buffer} {
    set f [open $path(test1) w]
     fconfigure $f -encoding binary -buffering line -translation lf \
	     -buffersize 16
    puts -nonewline $f "abcdefg\nhijklmnopqrstuvwxyz"
    set x [list [contents $path(test1)]]
    close $f
    lappend x [contents $path(test1)]
} [list "abcdefg\nhijklmno" "abcdefg\nhijklmnopqrstuvwxyz"]

test io-3.1 {WriteChars: compatibility with WriteBytes} {
    # loop until all bytes are written
    
    set f [open $path(test1) w]
    fconfigure $f -encoding ascii -buffersize 16 -translation crlf
    puts $f "abcdefghijklmnopqrstuvwxyz"
    close $f
    contents $path(test1)
} "abcdefghijklmnopqrstuvwxyz\r\n"
test io-3.2 {WriteChars: compatibility with WriteBytes: savedLF > 0} {
    # After flushing buffer, there was a \n left over from the last
    # \n -> \r\n expansion.  It gets stuck at beginning of this buffer.

    set f [open $path(test1) w]
    fconfigure $f -encoding ascii -buffersize 16 -translation crlf
    puts -nonewline $f "123456789012345\n12"
    set x [list [contents $path(test1)]]
    close $f
    lappend x [contents $path(test1)]
} [list "123456789012345\r" "123456789012345\r\n12"]
test io-3.3 {WriteChars: compatibility with WriteBytes: flush on line} {
    # Tcl "line" buffering has weird behavior: if current buffer contains
    # a \n, entire buffer gets flushed.  Logical behavior would be to flush
    # only up to the \n.
    
    set f [open $path(test1) w]
    fconfigure $f -encoding ascii -buffering line -translation crlf
    puts -nonewline $f "\n12"
    set x [contents $path(test1)]
    close $f
    set x
} "\r\n12"
test io-3.4 {WriteChars: loop over stage buffer} {
    # stage buffer maps to more than can be queued at once.

    set f [open $path(test1) w]
    fconfigure $f -encoding jis0208 -buffersize 16 
    puts -nonewline $f "\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"
    set x [list [contents $path(test1)]]
    close $f
    lappend x [contents $path(test1)]
} [list "!)!)!)!)!)!)!)!)" "!)!)!)!)!)!)!)!)!)!)!)!)!)!)!)"]
test io-3.5 {WriteChars: saved != 0} {
    # Bytes produced by UtfToExternal from end of last channel buffer
    # had to be moved to beginning of next channel buffer to preserve
    # requested buffersize.

    set f [open $path(test1) w]
    fconfigure $f -encoding jis0208 -buffersize 17 
    puts -nonewline $f "\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"
    set x [list [contents $path(test1)]]
    close $f
    lappend x [contents $path(test1)]
} [list "!)!)!)!)!)!)!)!)!" "!)!)!)!)!)!)!)!)!)!)!)!)!)!)!)"]
test io-3.6 {WriteChars: (stageRead + dstWrote == 0)} {
    # One incomplete UTF-8 character at end of staging buffer.  Backup
    # in src to the beginning of that UTF-8 character and try again.
    #
    # Translate the first 16 bytes, produce 14 bytes of output, 2 left over
    # (first two bytes of \uff21 in UTF-8).  Given those two bytes try
    # translating them again, find that no bytes are read produced, and break
    # to outer loop where those two bytes will have the remaining 4 bytes
    # (the last byte of \uff21 plus the all of \uff22) appended.

    set f [open $path(test1) w]
    fconfigure $f -encoding shiftjis -buffersize 16
    puts -nonewline $f "12345678901234\uff21\uff22"
    set x [list [contents $path(test1)]]
    close $f
    lappend x [contents $path(test1)]
} [list "12345678901234\x82\x60" "12345678901234\x82\x60\x82\x61"]
test io-3.7 {WriteChars: (bufPtr->nextAdded > bufPtr->length)} {
    # When translating UTF-8 to external, the produced bytes went past end
    # of the channel buffer.  This is done purpose -- we then truncate the
    # bytes at the end of the partial character to preserve the requested
    # blocksize on flush.  The truncated bytes are moved to the beginning
    # of the next channel buffer.

    set f [open $path(test1) w]
    fconfigure $f -encoding jis0208 -buffersize 17 
    puts -nonewline $f "\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"
    set x [list [contents $path(test1)]]
    close $f
    lappend x [contents $path(test1)]
} [list "!)!)!)!)!)!)!)!)!" "!)!)!)!)!)!)!)!)!)!)!)!)!)!)!)"]
test io-3.8 {WriteChars: reset sawLF after each buffer} {
    set f [open $path(test1) w]
    fconfigure $f -encoding ascii -buffering line -translation lf \
	     -buffersize 16
    puts -nonewline $f "abcdefg\nhijklmnopqrstuvwxyz"
    set x [list [contents $path(test1)]]
    close $f
    lappend x [contents $path(test1)]
} [list "abcdefg\nhijklmno" "abcdefg\nhijklmnopqrstuvwxyz"]

test io-4.1 {TranslateOutputEOL: lf} {
    # search for \n

    set f [open $path(test1) w]
    fconfigure $f -buffering line -translation lf
    puts $f "abcde"
    set x [list [contents $path(test1)]]
    close $f
    lappend x [contents $path(test1)]
} [list "abcde\n" "abcde\n"]
test io-4.2 {TranslateOutputEOL: cr} {
    # search for \n, replace with \r

    set f [open $path(test1) w]
    fconfigure $f -buffering line -translation cr
    puts $f "abcde"
    set x [list [contents $path(test1)]]
    close $f
    lappend x [contents $path(test1)]
} [list "abcde\r" "abcde\r"]
test io-4.3 {TranslateOutputEOL: crlf} {
    # simple case: search for \n, replace with \r

    set f [open $path(test1) w]
    fconfigure $f -buffering line -translation crlf
    puts $f "abcde"
    set x [list [contents $path(test1)]]
    close $f
    lappend x [contents $path(test1)]
} [list "abcde\r\n" "abcde\r\n"]
test io-4.4 {TranslateOutputEOL: crlf} {
    # keep storing more bytes in output buffer until output buffer is full.
    # We have 13 bytes initially that would turn into 18 bytes.  Fill
    # dest buffer while (dstEnd < dstMax).

    set f [open $path(test1) w]
    fconfigure $f -translation crlf -buffersize 16
    puts -nonewline $f "1234567\n\n\n\n\nA"
    set x [list [contents $path(test1)]]
    close $f
    lappend x [contents $path(test1)]
} [list "1234567\r\n\r\n\r\n\r\n\r" "1234567\r\n\r\n\r\n\r\n\r\nA"]
test io-4.5 {TranslateOutputEOL: crlf} {
    # Check for overflow of the destination buffer

    set f [open $path(test1) w]
    fconfigure $f -translation crlf -buffersize 12
    puts -nonewline $f "12345678901\n456789012345678901234"
    close $f
    set x [contents $path(test1)]
} "12345678901\r\n456789012345678901234"

test io-5.1 {CheckFlush: not full} {
    set f [open $path(test1) w]
    fconfigure $f 
    puts -nonewline $f "12345678901234567890"
    set x [list [contents $path(test1)]]
    close $f
    lappend x [contents $path(test1)]
} [list "" "12345678901234567890"]
test io-5.2 {CheckFlush: full} {
    set f [open $path(test1) w]
    fconfigure $f -buffersize 16
    puts -nonewline $f "12345678901234567890"
    set x [list [contents $path(test1)]]
    close $f
    lappend x [contents $path(test1)]
} [list "1234567890123456" "12345678901234567890"]
test io-5.3 {CheckFlush: not line} {
    set f [open $path(test1) w]
    fconfigure $f -buffering line
    puts -nonewline $f "12345678901234567890"
    set x [list [contents $path(test1)]]
    close $f
    lappend x [contents $path(test1)]
} [list "" "12345678901234567890"]
test io-5.4 {CheckFlush: line} {
    set f [open $path(test1) w]
    fconfigure $f -buffering line -translation lf -encoding ascii
    puts -nonewline $f "1234567890\n1234567890"
    set x [list [contents $path(test1)]]
    close $f
    lappend x [contents $path(test1)]
} [list "1234567890\n1234567890" "1234567890\n1234567890"]
test io-5.5 {CheckFlush: none} {
    set f [open $path(test1) w]
    fconfigure $f -buffering none
    puts -nonewline $f "1234567890"
    set x [list [contents $path(test1)]]
    close $f
    lappend x [contents $path(test1)]
} [list "1234567890" "1234567890"]

test io-6.1 {Tcl_GetsObj: working} {
    set f [open $path(test1) w]
    puts $f "foo\nboo"
    close $f
    set f [open $path(test1)]
    set x [gets $f]
    close $f
    set x
} {foo}
test io-6.2 {Tcl_GetsObj: CheckChannelErrors() != 0} {
    # no test, need to cause an async error.
} {}
test io-6.3 {Tcl_GetsObj: how many have we used?} {
    # if (bufPtr != NULL) {oldRemoved = bufPtr->nextRemoved}

    set f [open $path(test1) w]
    fconfigure $f -translation crlf
    puts $f "abc\ndefg"
    close $f
    set f [open $path(test1)]
    set x [list [tell $f] [gets $f line] [tell $f] [gets $f line] $line]
    close $f
    set x
} {0 3 5 4 defg}
test io-6.4 {Tcl_GetsObj: encoding == NULL} {
    set f [open $path(test1) w]
    fconfigure $f -translation binary
    puts $f "\x81\u1234\0"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation binary
    set x [list [gets $f line] $line]
    close $f
    set x
} [list 3 "\x81\x34\x00"]
test io-6.5 {Tcl_GetsObj: encoding != NULL} {
    set f [open $path(test1) w]
    fconfigure $f -translation binary
    puts $f "\x88\xea\x92\x9a"
    close $f
    set f [open $path(test1)]
    fconfigure $f -encoding shiftjis
    set x [list [gets $f line] $line]
    close $f
    set x
} [list 2 "\u4e00\u4e01"]
set a "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"
append a $a
append a $a
test io-6.6 {Tcl_GetsObj: loop test} {
    # if (dst >= dstEnd) 

    set f [open $path(test1) w]
    puts $f $a
    puts $f hi
    close $f
    set f [open $path(test1)]
    set x [list [gets $f line] $line]
    close $f
    set x
} [list 256 $a]
test io-6.7 {Tcl_GetsObj: error in input} {stdio} {
    # if (FilterInputBytes(chanPtr, &gs) != 0)

    set f [open "|[list [interpreter] cat]" w+]
    puts -nonewline $f "hi\nwould"
    flush $f
    gets $f
    fconfigure $f -blocking 0
    set x [gets $f line]
    close $f
    set x
} {-1}
test io-6.8 {Tcl_GetsObj: remember if EOF is seen} {
    set f [open $path(test1) w]
    puts $f "abcdef\x1aghijk\nwombat"
    close $f
    set f [open $path(test1)]
    fconfigure $f -eofchar \x1a
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} {6 abcdef -1 {}}
test io-6.9 {Tcl_GetsObj: remember if EOF is seen} {
    set f [open $path(test1) w]
    puts $f "abcdefghijk\nwom\u001abat"
    close $f
    set f [open $path(test1)]
    fconfigure $f -eofchar \x1a
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} {11 abcdefghijk 3 wom}

# Comprehensive tests

test io-6.10 {Tcl_GetsObj: lf mode: no chars} {
    set f [open $path(test1) w]
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation lf
    set x [list [gets $f line] $line]
    close $f
    set x
} {-1 {}}
test io-6.11 {Tcl_GetsObj: lf mode: lone \n} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "\n"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation lf
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} {0 {} -1 {}}
test io-6.12 {Tcl_GetsObj: lf mode: lone \r} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "\r"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation lf
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} [list 1 "\r" -1 ""]
test io-6.13 {Tcl_GetsObj: lf mode: 1 char} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f a
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation lf
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} {1 a -1 {}}
test io-6.14 {Tcl_GetsObj: lf mode: 1 char followed by EOL} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "a\n"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation lf
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} {1 a -1 {}}
test io-6.15 {Tcl_GetsObj: lf mode: several chars} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "abcd\nefgh\rijkl\r\nmnop"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation lf
    set x [list [gets $f line] $line [gets $f line] $line [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} [list 4 "abcd" 10 "efgh\rijkl\r" 4 "mnop" -1 ""]
test io-6.16 {Tcl_GetsObj: cr mode: no chars} {
    set f [open $path(test1) w]
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation cr
    set x [list [gets $f line] $line]
    close $f
    set x
} {-1 {}}
test io-6.17 {Tcl_GetsObj: cr mode: lone \n} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "\n"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation cr
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} [list 1 "\n" -1 ""]
test io-6.18 {Tcl_GetsObj: cr mode: lone \r} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "\r"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation cr
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} {0 {} -1 {}}
test io-6.19 {Tcl_GetsObj: cr mode: 1 char} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f a
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation cr
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} {1 a -1 {}}
test io-6.20 {Tcl_GetsObj: cr mode: 1 char followed by EOL} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "a\r"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation cr
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} {1 a -1 {}}
test io-6.21 {Tcl_GetsObj: cr mode: several chars} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "abcd\nefgh\rijkl\r\nmnop"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation cr
    set x [list [gets $f line] $line [gets $f line] $line [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} [list 9 "abcd\nefgh" 4 "ijkl" 5 "\nmnop" -1 ""]
test io-6.22 {Tcl_GetsObj: crlf mode: no chars} {
    set f [open $path(test1) w]
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation crlf
    set x [list [gets $f line] $line]
    close $f
    set x
} {-1 {}}
test io-6.23 {Tcl_GetsObj: crlf mode: lone \n} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "\n"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation crlf
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} [list 1 "\n" -1 ""]
test io-6.24 {Tcl_GetsObj: crlf mode: lone \r} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "\r"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation crlf
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} [list 1 "\r" -1 ""]
test io-6.25 {Tcl_GetsObj: crlf mode: \r\r} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "\r\r"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation crlf
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} [list 2 "\r\r" -1 ""]
test io-6.26 {Tcl_GetsObj: crlf mode: \r\n} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "\r\n"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation crlf
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} [list 0 "" -1 ""]
test io-6.27 {Tcl_GetsObj: crlf mode: 1 char} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f a
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation crlf
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} {1 a -1 {}}
test io-6.28 {Tcl_GetsObj: crlf mode: 1 char followed by EOL} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "a\r\n"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation crlf
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} {1 a -1 {}}
test io-6.29 {Tcl_GetsObj: crlf mode: several chars} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "abcd\nefgh\rijkl\r\nmnop"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation crlf
    set x [list [gets $f line] $line [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} [list 14 "abcd\nefgh\rijkl" 4 "mnop" -1 ""]
test io-6.30 {Tcl_GetsObj: crlf mode: buffer exhausted} {testchannel} {
    # if (eol >= dstEnd)

    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "123456789012345\r\nabcdefghijklmnoprstuvwxyz"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation crlf -buffersize 16
    set x [list [gets $f line] $line [testchannel inputbuffered $f]]
    close $f
    set x
} [list 15 "123456789012345" 15]
test io-6.31 {Tcl_GetsObj: crlf mode: buffer exhausted, blocked} {stdio testchannel} {
    # (FilterInputBytes() != 0)

    set f [open "|[list [interpreter] $path(cat)]" w+]
    fconfigure $f -translation {crlf lf} -buffering none
    puts -nonewline $f "bbbbbbbbbbbbbb\r\n123456789012345\r"
    fconfigure $f -buffersize 16
    set x [gets $f]
    fconfigure $f -blocking 0
    lappend x [gets $f line] $line [fblocked $f] [testchannel inputbuffered $f]
    close $f
    set x
} [list "bbbbbbbbbbbbbb" -1 "" 1 16]
test io-6.32 {Tcl_GetsObj: crlf mode: buffer exhausted, more data} {testchannel} {
    # not (FilterInputBytes() != 0)

    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "123456789012345\r\n123"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation crlf -buffersize 16
    set x [list [gets $f line] $line [tell $f] [testchannel inputbuffered $f]]
    close $f
    set x
} [list 15 "123456789012345" 17 3]
test io-6.33 {Tcl_GetsObj: crlf mode: buffer exhausted, at eof} {
    # eol still equals dstEnd
    
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "123456789012345\r"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation crlf -buffersize 16
    set x [list [gets $f line] $line [eof $f]]
    close $f
    set x
} [list 16 "123456789012345\r" 1]
test io-6.34 {Tcl_GetsObj: crlf mode: buffer exhausted, not followed by \n} {
    # not (*eol == '\n') 
    
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "123456789012345\rabcd\r\nefg"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation crlf -buffersize 16
    set x [list [gets $f line] $line [tell $f]]
    close $f
    set x
} [list 20 "123456789012345\rabcd" 22]
test io-6.35 {Tcl_GetsObj: auto mode: no chars} {
    set f [open $path(test1) w]
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation auto
    set x [list [gets $f line] $line]
    close $f
    set x
} {-1 {}}
test io-6.36 {Tcl_GetsObj: auto mode: lone \n} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "\n"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation auto
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} [list 0 "" -1 ""]
test io-6.37 {Tcl_GetsObj: auto mode: lone \r} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "\r"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation auto
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} [list 0 "" -1 ""]
test io-6.38 {Tcl_GetsObj: auto mode: \r\r} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "\r\r"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation auto
    set x [list [gets $f line] $line [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} [list 0 "" 0 "" -1 ""]
test io-6.39 {Tcl_GetsObj: auto mode: \r\n} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "\r\n"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation auto
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} [list 0 "" -1 ""]
test io-6.40 {Tcl_GetsObj: auto mode: 1 char} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f a
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation auto
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} {1 a -1 {}}
test io-6.41 {Tcl_GetsObj: auto mode: 1 char followed by EOL} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "a\r\n"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation auto
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} {1 a -1 {}}
test io-6.42 {Tcl_GetsObj: auto mode: several chars} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "abcd\nefgh\rijkl\r\nmnop"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation auto
    set x [list [gets $f line] $line [gets $f line] $line]
    lappend x [gets $f line] $line [gets $f line] $line [gets $f line] $line
    close $f
    set x
} [list 4 "abcd" 4 "efgh" 4 "ijkl" 4 "mnop" -1 ""]
test io-6.43 {Tcl_GetsObj: input saw cr} {stdio testchannel} {
    # if (chanPtr->flags & INPUT_SAW_CR)

    set f [open "|[list [interpreter] $path(cat)]" w+]
    fconfigure $f -translation {auto lf} -buffering none
    puts -nonewline $f "bbbbbbbbbbbbbbb\n123456789abcdef\r"
    fconfigure $f -buffersize 16
    set x [list [gets $f]]
    fconfigure $f -blocking 0
    lappend x [gets $f line] $line [testchannel queuedcr $f] 
    fconfigure $f -blocking 1
    puts -nonewline $f "\nabcd\refg\x1a"
    lappend x [gets $f line] $line [testchannel queuedcr $f]
    lappend x [gets $f line] $line
    close $f
    set x
} [list "bbbbbbbbbbbbbbb" 15 "123456789abcdef" 1 4 "abcd" 0 3 "efg"]
test io-6.44 {Tcl_GetsObj: input saw cr, not followed by cr} {stdio testchannel} {
    # not (*eol == '\n') 

    set f [open "|[list [interpreter] $path(cat)]" w+]
    fconfigure $f -translation {auto lf} -buffering none
    puts -nonewline $f "bbbbbbbbbbbbbbb\n123456789abcdef\r"
    fconfigure $f -buffersize 16
    set x [list [gets $f]]
    fconfigure $f -blocking 0
    lappend x [gets $f line] $line [testchannel queuedcr $f] 
    fconfigure $f -blocking 1
    puts -nonewline $f "abcd\refg\x1a"
    lappend x [gets $f line] $line [testchannel queuedcr $f]
    lappend x [gets $f line] $line
    close $f
    set x
} [list "bbbbbbbbbbbbbbb" 15 "123456789abcdef" 1 4 "abcd" 0 3 "efg"]
test io-6.45 {Tcl_GetsObj: input saw cr, skip right number of bytes} {stdio testchannel} {
    # Tcl_ExternalToUtf()

    set f [open "|[list [interpreter] $path(cat)]" w+]
    fconfigure $f -translation {auto lf} -buffering none
    fconfigure $f -encoding unicode
    puts -nonewline $f "bbbbbbbbbbbbbbb\n123456789abcdef\r"
    fconfigure $f -buffersize 16
    gets $f
    fconfigure $f -blocking 0
    set x [list [gets $f line] $line [testchannel queuedcr $f]]
    fconfigure $f -blocking 1
    puts -nonewline $f "\nabcd\refg"
    lappend x [gets $f line] $line [testchannel queuedcr $f]
    close $f
    set x
} [list 15 "123456789abcdef" 1 4 "abcd" 0]
test io-6.46 {Tcl_GetsObj: input saw cr, followed by just \n should give eof} {stdio testchannel} {
    # memmove()

    set f [open "|[list [interpreter] $path(cat)]" w+]
    fconfigure $f -translation {auto lf} -buffering none
    puts -nonewline $f "bbbbbbbbbbbbbbb\n123456789abcdef\r"
    fconfigure $f -buffersize 16
    gets $f
    fconfigure $f -blocking 0
    set x [list [gets $f line] $line [testchannel queuedcr $f]]
    fconfigure $f -blocking 1
    puts -nonewline $f "\n\x1a"
    lappend x [gets $f line] $line [testchannel queuedcr $f]
    close $f
    set x
} [list 15 "123456789abcdef" 1 -1 "" 0]
test io-6.47 {Tcl_GetsObj: auto mode: \r at end of buffer, peek for \n} {testchannel} {
    # (eol == dstEnd)

    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "123456789012345\r\nabcdefghijklmnopq"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation auto -buffersize 16
    set x [list [gets $f] [testchannel inputbuffered $f]]
    close $f
    set x
} [list "123456789012345" 15]    
test io-6.48 {Tcl_GetsObj: auto mode: \r at end of buffer, no more avail} {testchannel} {
    # PeekAhead() did not get any, so (eol >= dstEnd)
    
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "123456789012345\r"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation auto -buffersize 16
    set x [list [gets $f] [testchannel queuedcr $f]]
    close $f
    set x
} [list "123456789012345" 1]
test io-6.49 {Tcl_GetsObj: auto mode: \r followed by \n} {testchannel} {
    # if (*eol == '\n') {skip++}
    
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "123456\r\n78901"
    close $f
    set f [open $path(test1)]
    set x [list [gets $f] [testchannel queuedcr $f] [tell $f] [gets $f]]
    close $f
    set x
} [list "123456" 0 8 "78901"]
test io-6.50 {Tcl_GetsObj: auto mode: \r not followed by \n} {testchannel} {
    # not (*eol == '\n') 
    
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "123456\r78901"
    close $f
    set f [open $path(test1)]
    set x [list [gets $f] [testchannel queuedcr $f] [tell $f] [gets $f]]
    close $f
    set x
} [list "123456" 0 7 "78901"]
test io-6.51 {Tcl_GetsObj: auto mode: \n} {
    # else if (*eol == '\n') {goto gotoeol;}
    
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "123456\n78901"
    close $f
    set f [open $path(test1)]
    set x [list [gets $f] [tell $f] [gets $f]]
    close $f
    set x
} [list "123456" 7 "78901"]
test io-6.52 {Tcl_GetsObj: saw EOF character} {testchannel} {
    # if (eof != NULL)

    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "123456\x1ak9012345\r"
    close $f
    set f [open $path(test1)]
    fconfigure $f -eofchar \x1a
    set x [list [gets $f] [testchannel queuedcr $f] [tell $f] [gets $f]]
    close $f
    set x
} [list "123456" 0 6 ""]
test io-6.53 {Tcl_GetsObj: device EOF} {
    # didn't produce any bytes

    set f [open $path(test1) w]
    close $f
    set f [open $path(test1)]
    set x [list [gets $f line] $line [eof $f]]
    close $f
    set x
} {-1 {} 1}
test io-6.54 {Tcl_GetsObj: device EOF} {
    # got some bytes before EOF.

    set f [open $path(test1) w]
    puts -nonewline $f abc
    close $f
    set f [open $path(test1)]
    set x [list [gets $f line] $line [eof $f]]
    close $f
    set x
} {3 abc 1}
test io-6.55 {Tcl_GetsObj: overconverted} {
    # Tcl_ExternalToUtf(), make sure state updated

    set f [open $path(test1) w]
    fconfigure $f -encoding iso2022-jp
    puts $f "there\u4e00ok\n\u4e01more bytes\nhere"
    close $f
    set f [open $path(test1)]
    fconfigure $f -encoding iso2022-jp
    set x [list [gets $f line] $line [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} [list 8 "there\u4e00ok" 11 "\u4e01more bytes" 4 "here"]
test io-6.56 {Tcl_GetsObj: incomplete lines should disable file events} {stdio} {
    update
    set f [open "|[list [interpreter] $path(cat)]" w+]
    fconfigure $f -buffering none
    puts -nonewline $f "foobar"
    fconfigure $f -blocking 0
    variable x {}
    after 500 [namespace code { lappend x timeout }]
    fileevent $f readable [namespace code { lappend x [gets $f] }]
    vwait [namespace which -variable x]
    vwait [namespace which -variable x]
    fconfigure $f -blocking 1
    puts -nonewline $f "baz\n"
    after 500 [namespace code { lappend x timeout }]
    fconfigure $f -blocking 0
    vwait [namespace which -variable x]
    vwait [namespace which -variable x]
    close $f
    set x
} {{} timeout foobarbaz timeout}

test io-7.1 {FilterInputBytes: split up character at end of buffer} {
    # (result == TCL_CONVERT_MULTIBYTE)

    set f [open $path(test1) w]
    fconfigure $f -encoding shiftjis
    puts $f "1234567890123\uff10\uff11\uff12\uff13\uff14\nend"
    close $f
    set f [open $path(test1)]
    fconfigure $f -encoding shiftjis -buffersize 16
    set x [gets $f]
    close $f
    set x
} "1234567890123\uff10\uff11\uff12\uff13\uff14"
test io-7.2 {FilterInputBytes: split up character in middle of buffer} {
    # (bufPtr->nextAdded < bufPtr->bufLength)
    
    set f [open $path(test1) w]
    fconfigure $f -encoding binary
    puts -nonewline $f "1234567890\n123\x82\x4f\x82\x50\x82"
    close $f
    set f [open $path(test1)]
    fconfigure $f -encoding shiftjis
    set x [list [gets $f line] $line [eof $f]]
    close $f
    set x
} [list 10 "1234567890" 0]
test io-7.3 {FilterInputBytes: split up character at EOF} {testchannel} {
    set f [open $path(test1) w]
    fconfigure $f -encoding binary
    puts -nonewline $f "1234567890123\x82\x4f\x82\x50\x82"
    close $f
    set f [open $path(test1)]
    fconfigure $f -encoding shiftjis
    set x [list [gets $f line] $line]
    lappend x [tell $f] [testchannel inputbuffered $f] [eof $f]
    lappend x [gets $f line] $line
    close $f
    set x
} [list 15 "1234567890123\uff10\uff11" 18 0 1 -1 ""]
test io-7.4 {FilterInputBytes: recover from split up character} {stdio} {
    set f [open "|[list [interpreter] $path(cat)]" w+]
    fconfigure $f -encoding binary -buffering none
    puts -nonewline $f "1234567890123\x82\x4f\x82\x50\x82"
    fconfigure $f -encoding shiftjis -blocking 0
    fileevent $f read [namespace code "ready $f"]
    variable x {}
    proc ready {f} {
	variable x
	lappend x [gets $f line] $line [fblocked $f]
    }
    vwait [namespace which -variable x]
    fconfigure $f -encoding binary -blocking 1
    puts $f "\x51\x82\x52"
    fconfigure $f -encoding shiftjis
    vwait [namespace which -variable x]
    close $f
    set x
} [list -1 "" 1 17 "1234567890123\uff10\uff11\uff12\uff13" 0]

test io-8.1 {PeekAhead: only go to device if no more cached data} {testchannel} {
    # (bufPtr->nextPtr == NULL)

    set f [open $path(test1) w]
    fconfigure $f -encoding ascii -translation lf
    puts -nonewline $f "123456789012345\r\n2345678"
    close $f
    set f [open $path(test1)]
    fconfigure $f -encoding ascii -translation auto -buffersize 16
    # here
    gets $f
    set x [testchannel inputbuffered $f]
    close $f
    set x
} "7"
test io-8.2 {PeekAhead: only go to device if no more cached data} {stdio testchannel} {
    # not (bufPtr->nextPtr == NULL)

    set f [open "|[list [interpreter] $path(cat)]" w+]
    fconfigure $f -translation lf -encoding ascii -buffering none
    puts -nonewline $f "123456789012345\r\nbcdefghijklmnopqrstuvwxyz"
    variable x {}
    fileevent $f read [namespace code "ready $f"]
    proc ready {f} {
	variable x
	lappend x [gets $f line] $line [testchannel inputbuffered $f]
    }
    fconfigure $f -encoding unicode -buffersize 16 -blocking 0
    vwait [namespace which -variable x]
    fconfigure $f -translation auto -encoding ascii -blocking 1
    # here
    vwait [namespace which -variable x]
    close $f
    set x
} [list -1 "" 42 15 "123456789012345" 25]
test io-8.3 {PeekAhead: no cached data available} {stdio testchannel} {
    # (bytesLeft == 0)

    set f [open "|[list [interpreter] $path(cat)]" w+]
    fconfigure $f -translation {auto binary}
    puts -nonewline $f "abcdefghijklmno\r"
    flush $f
    set x [list [gets $f line] $line [testchannel queuedcr $f]]
    close $f
    set x
} [list 15 "abcdefghijklmno" 1]
set a "123456789012345678901234567890"
append a "123456789012345678901234567890"
append a "1234567890123456789012345678901"
test io-8.4 {PeekAhead: cached data available in this buffer} {
    # not (bytesLeft == 0)

    set f [open $path(test1) w+]
    fconfigure $f -translation binary
    puts $f "${a}\r\nabcdef"
    close $f
    set f [open $path(test1)]
    fconfigure $f -encoding binary -translation auto

    # "${a}\r" was converted in one operation (because ENCODING_LINESIZE
    # is 30).  To check if "\n" follows, calls PeekAhead and determines
    # that cached data is available in buffer w/o having to call driver.

    set x [gets $f]
    close $f
    set x    
} $a
unset a
test io-8.5 {PeekAhead: don't peek if last read was short} {stdio testchannel} {
    # (bufPtr->nextAdded < bufPtr->length)

    set f [open "|[list [interpreter] $path(cat)]" w+]
    fconfigure $f -translation {auto binary}
    puts -nonewline $f "abcdefghijklmno\r"
    flush $f
    # here
    set x [list [gets $f line] $line [testchannel queuedcr $f]]
    close $f
    set x
} {15 abcdefghijklmno 1}
test io-8.6 {PeekAhead: change to non-blocking mode} {stdio testchannel} {
    # ((chanPtr->flags & CHANNEL_NONBLOCKING) == 0) 

    set f [open "|[list [interpreter] $path(cat)]" w+]
    fconfigure $f -translation {auto binary} -buffersize 16
    puts -nonewline $f "abcdefghijklmno\r"
    flush $f
    # here
    set x [list [gets $f line] $line [testchannel queuedcr $f]]
    close $f
    set x
} {15 abcdefghijklmno 1}
test io-8.7 {PeekAhead: cleanup} {stdio testchannel} {
    # Make sure bytes are removed from buffer.

    set f [open "|[list [interpreter] $path(cat)]" w+]
    fconfigure $f -translation {auto binary} -buffering none
    puts -nonewline $f "abcdefghijklmno\r"
    # here
    set x [list [gets $f line] $line [testchannel queuedcr $f]]
    puts -nonewline $f "\x1a"
    lappend x [gets $f line] $line
    close $f
    set x
} {15 abcdefghijklmno 1 -1 {}}
    

test io-9.1 {CommonGetsCleanup} {
} {}

test io-10.1 {Tcl_ReadChars: CheckChannelErrors} {
    # no test, need to cause an async error.
} {}
test io-10.2 {Tcl_ReadChars: loop until enough copied} {
    # one time
    # for (copied = 0; (unsigned) toRead > 0; )

    set f [open $path(test1) w]
    puts $f abcdefghijklmnop
    close $f

    set f [open $path(test1)]
    set x [read $f 5]
    close $f
    set x
} {abcde}
test io-10.3 {Tcl_ReadChars: loop until enough copied} {
    # multiple times
    # for (copied = 0; (unsigned) toRead > 0; )

    set f [open $path(test1) w]
    puts $f abcdefghijklmnopqrstuvwxyz
    close $f

    set f [open $path(test1)]
    fconfigure $f -buffersize 16
    # here
    set x [read $f 19]
    close $f
    set x
} {abcdefghijklmnopqrs}
test io-10.4 {Tcl_ReadChars: no more in channel buffer} {
    # (copiedNow < 0)

    set f [open $path(test1) w]
    puts -nonewline $f abcdefghijkl
    close $f

    set f [open $path(test1)]
    # here
    set x [read $f 1000]
    close $f
    set x
} {abcdefghijkl}
test io-10.5 {Tcl_ReadChars: stop on EOF} {
    # (chanPtr->flags & CHANNEL_EOF)

    set f [open $path(test1) w]
    puts -nonewline $f abcdefghijkl
    close $f

    set f [open $path(test1)]
    # here
    set x [read $f 1000]
    close $f
    set x
} {abcdefghijkl}

test io-11.1 {ReadBytes: want to read a lot} {
    # ((unsigned) toRead > (unsigned) srcLen)

    set f [open $path(test1) w]
    puts -nonewline $f abcdefghijkl
    close $f
    set f [open $path(test1)]
    fconfigure $f -encoding binary
    # here
    set x [read $f 1000]
    close $f
    set x
} {abcdefghijkl}
test io-11.2 {ReadBytes: want to read all} {
    # ((unsigned) toRead > (unsigned) srcLen)

    set f [open $path(test1) w]
    puts -nonewline $f abcdefghijkl
    close $f
    set f [open $path(test1)]
    fconfigure $f -encoding binary
    # here
    set x [read $f]
    close $f
    set x
} {abcdefghijkl}
test io-11.3 {ReadBytes: allocate more space} {
    # (toRead > length - offset - 1)

    set f [open $path(test1) w]
    puts -nonewline $f abcdefghijklmnopqrstuvwxyz
    close $f
    set f [open $path(test1)]
    fconfigure $f -buffersize 16 -encoding binary
    # here
    set x [read $f]
    close $f
    set x
} {abcdefghijklmnopqrstuvwxyz}
test io-11.4 {ReadBytes: EOF char found} {
    # (TranslateInputEOL() != 0)

    set f [open $path(test1) w]
    puts $f abcdefghijklmnopqrstuvwxyz
    close $f
    set f [open $path(test1)]
    fconfigure $f -eofchar m -encoding binary
    # here
    set x [list [read $f] [eof $f] [read $f] [eof $f]]
    close $f
    set x
} [list "abcdefghijkl" 1 "" 1]
    
test io-12.1 {ReadChars: want to read a lot} {
    # ((unsigned) toRead > (unsigned) srcLen)

    set f [open $path(test1) w]
    puts -nonewline $f abcdefghijkl
    close $f
    set f [open $path(test1)]
    # here
    set x [read $f 1000]
    close $f
    set x
} {abcdefghijkl}
test io-12.2 {ReadChars: want to read all} {
    # ((unsigned) toRead > (unsigned) srcLen)

    set f [open $path(test1) w]
    puts -nonewline $f abcdefghijkl
    close $f
    set f [open $path(test1)]
    # here
    set x [read $f]
    close $f
    set x
} {abcdefghijkl}
test io-12.3 {ReadChars: allocate more space} {
    # (toRead > length - offset - 1)

    set f [open $path(test1) w]
    puts -nonewline $f abcdefghijklmnopqrstuvwxyz
    close $f
    set f [open $path(test1)]
    fconfigure $f -buffersize 16
    # here
    set x [read $f]
    close $f
    set x
} {abcdefghijklmnopqrstuvwxyz}
test io-12.4 {ReadChars: split-up char} {stdio testchannel} {
    # (srcRead == 0)

    set f [open "|[list [interpreter] $path(cat)]" w+]
    fconfigure $f -encoding binary -buffering none -buffersize 16
    puts -nonewline $f "123456789012345\x96"
    fconfigure $f -encoding shiftjis -blocking 0

    fileevent $f read [namespace code "ready $f"]
    proc ready {f} {
	variable x
	lappend x [read $f] [testchannel inputbuffered $f]
    }
    variable x {}

    fconfigure $f -encoding shiftjis
    vwait [namespace which -variable x]
    fconfigure $f -encoding binary -blocking 1
    puts -nonewline $f "\x7b"
    after 500			;# Give the cat process time to catch up
    fconfigure $f -encoding shiftjis -blocking 0
    vwait [namespace which -variable x]
    close $f
    set x
} [list "123456789012345" 1 "\u672c" 0]
test io-12.5 {ReadChars: fileevents on partial characters} {stdio} {
    set path(test1) [makeFile {
	fconfigure stdout -encoding binary -buffering none
	gets stdin; puts -nonewline "\xe7"
	gets stdin; puts -nonewline "\x89"
	gets stdin; puts -nonewline "\xa6"
    } test1]
    set f [open "|[list [interpreter] $path(test1)]" r+]
    fileevent $f readable [namespace code {
	lappend x [read $f]
	if {[eof $f]} {
	    lappend x eof
	}
    }]
    puts $f "go1"
    flush $f
    fconfigure $f -blocking 0 -encoding utf-8
    variable x {}
    vwait [namespace which -variable x]
    after 500 [namespace code { lappend x timeout }]
    vwait [namespace which -variable x]
    puts $f "go2"
    flush $f
    vwait [namespace which -variable x]
    after 500 [namespace code { lappend x timeout }]
    vwait [namespace which -variable x]
    puts $f "go3"
    flush $f
    vwait [namespace which -variable x]
    vwait [namespace which -variable x]
    lappend x [catch {close $f} msg] $msg
    set x
} "{} timeout {} timeout \u7266 {} eof 0 {}"

test io-13.1 {TranslateInputEOL: cr mode} {} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "abcd\rdef\r"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation cr
    set x [read $f]
    close $f
    set x
} "abcd\ndef\n"
test io-13.2 {TranslateInputEOL: crlf mode} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "abcd\r\ndef\r\n"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation crlf
    set x [read $f]
    close $f
    set x
} "abcd\ndef\n"
test io-13.3 {TranslateInputEOL: crlf mode: naked cr} {
    # (src >= srcMax) 

    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "abcd\r\ndef\r"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation crlf
    set x [read $f]
    close $f
    set x
} "abcd\ndef\r"
test io-13.4 {TranslateInputEOL: crlf mode: cr followed by not \n} {
    # (src >= srcMax) 

    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "abcd\r\ndef\rfgh"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation crlf
    set x [read $f]
    close $f
    set x
} "abcd\ndef\rfgh"
test io-13.5 {TranslateInputEOL: crlf mode: naked lf} {
    # (src >= srcMax) 

    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "abcd\r\ndef\nfgh"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation crlf
    set x [read $f]
    close $f
    set x
} "abcd\ndef\nfgh"
test io-13.6 {TranslateInputEOL: auto mode: saw cr in last segment} {stdio testchannel} {
    # (chanPtr->flags & INPUT_SAW_CR)
    # This test may fail on slower machines.

    set f [open "|[list [interpreter] $path(cat)]" w+]
    fconfigure $f -blocking 0 -buffering none -translation {auto lf}

    fileevent $f read [namespace code "ready $f"]
    proc ready {f} {
	variable x
	lappend x [read $f] [testchannel queuedcr $f]
    }
    variable x {}
    variable y {}

    puts -nonewline $f "abcdefghj\r"
    after 500 [namespace code {set y ok}]
    vwait [namespace which -variable y]

    puts -nonewline $f "\n01234"
    after 500 [namespace code {set y ok}]
    vwait [namespace which -variable y]

    close $f
    set x
} [list "abcdefghj\n" 1 "01234" 0]
test io-13.7 {TranslateInputEOL: auto mode: naked \r} {testchannel} {
    # (src >= srcMax)

    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "abcd\r"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation auto
    set x [list [read $f] [testchannel queuedcr $f]]
    close $f
    set x
} [list "abcd\n" 1]
test io-13.8 {TranslateInputEOL: auto mode: \r\n} {
    # (*src == '\n')

    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "abcd\r\ndef"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation auto
    set x [read $f]
    close $f
    set x
} "abcd\ndef"
test io-13.9 {TranslateInputEOL: auto mode: \r followed by not \n} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "abcd\rdef"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation auto
    set x [read $f]
    close $f
    set x
} "abcd\ndef"
test io-13.10 {TranslateInputEOL: auto mode: \n} {
    # not (*src == '\r') 

    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "abcd\ndef"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation auto
    set x [read $f]
    close $f
    set x
} "abcd\ndef"
test io-13.11 {TranslateInputEOL: EOF char} {
    # (*chanPtr->inEofChar != '\0')

    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "abcd\ndefgh"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation auto -eofchar e
    set x [read $f]
    close $f
    set x
} "abcd\nd"
test io-13.12 {TranslateInputEOL: find EOF char in src} {
    # (*chanPtr->inEofChar != '\0')

    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "\r\n\r\n\r\nab\r\n\r\ndef\r\n\r\n\r\n"
    close $f
    set f [open $path(test1)]
    fconfigure $f -translation auto -eofchar e
    set x [read $f]
    close $f
    set x
} "\n\n\nab\n\nd"
    
# Test standard handle management. The functions tested are
# Tcl_SetStdChannel and Tcl_GetStdChannel. Incidentally we are
# also testing channel table management.

if {[info commands testchannel] != ""} {
    if {$tcl_platform(platform) == "macintosh"} {
	set consoleFileNames [list console0 console1 console2]
    } else {
	set consoleFileNames [lsort [testchannel open]]
    }
} else {
    # just to avoid an error
    set consoleFileNames [list]
}

test io-14.1 {Tcl_SetStdChannel and Tcl_GetStdChannel} {testchannel} {
    set l ""
    lappend l [fconfigure stdin -buffering]
    lappend l [fconfigure stdout -buffering]
    lappend l [fconfigure stderr -buffering]
    lappend l [lsort [testchannel open]]
    set l
} [list line line none $consoleFileNames]
test io-14.2 {Tcl_SetStdChannel and Tcl_GetStdChannel} {
    interp create x
    set l ""
    lappend l [x eval {fconfigure stdin -buffering}]
    lappend l [x eval {fconfigure stdout -buffering}]
    lappend l [x eval {fconfigure stderr -buffering}]
    interp delete x
    set l
} {line line none}

set path(test3) [makeFile {} test3]

test io-14.3 {Tcl_SetStdChannel & Tcl_GetStdChannel} {exec} {
    set f [open $path(test1) w]
    puts $f [format {
	close stdin
	close stdout
	close stderr
	set f  [open "%s" r]
	set f2 [open "%s" w]
	set f3 [open "%s" w]
	puts stdout [gets stdin]
	puts stdout out
	puts stderr err
	close $f
	close $f2
	close $f3
    } $path(test1) $path(test2) $path(test3)]
    close $f
    set result [exec [interpreter] $path(test1)]
    set f  [open $path(test2) r]
    set f2 [open $path(test3) r]
    lappend result [read $f] [read $f2]
    close $f
    close $f2
    set result
} {{
out
} {err
}}
# This test relies on the fact that the smallest available fd is used first.
test io-14.4 {Tcl_SetStdChannel & Tcl_GetStdChannel} {exec unixOnly} {
    set f [open $path(test1) w]
    puts $f [format { close stdin
	close stdout
	close stderr
	set f  [open "%s" r]
	set f2 [open "%s" w]
	set f3 [open "%s" w]
	puts stdout [gets stdin]
	puts stdout $f2
	puts stderr $f3
	close $f
	close $f2
	close $f3
    } $path(test1) $path(test2) $path(test3)]
    close $f
    set result [exec [interpreter] $path(test1)]
    set f  [open $path(test2) r]
    set f2 [open $path(test3) r]
    lappend result [read $f] [read $f2]
    close $f
    close $f2
    set result
} {{ close stdin
file1
} {file2
}}
catch {interp delete z}
test io-14.5 {Tcl_GetChannel: stdio name translation} {
    interp create z
    eof stdin
    catch {z eval flush stdin} msg1
    catch {z eval close stdin} msg2
    catch {z eval flush stdin} msg3
    set result [list $msg1 $msg2 $msg3]
    interp delete z
    set result
} {{channel "stdin" wasn't opened for writing} {} {can not find channel named "stdin"}}
test io-14.6 {Tcl_GetChannel: stdio name translation} {
    interp create z
    eof stdout
    catch {z eval flush stdout} msg1
    catch {z eval close stdout} msg2
    catch {z eval flush stdout} msg3
    set result [list $msg1 $msg2 $msg3]
    interp delete z
    set result
} {{} {} {can not find channel named "stdout"}}
test io-14.7 {Tcl_GetChannel: stdio name translation} {
    interp create z
    eof stderr
    catch {z eval flush stderr} msg1
    catch {z eval close stderr} msg2
    catch {z eval flush stderr} msg3
    set result [list $msg1 $msg2 $msg3]
    interp delete z
    set result
} {{} {} {can not find channel named "stderr"}}

set path(script) [makeFile {} script]

test io-14.8 {reuse of stdio special channels} {stdio} {
    removeFile script
    removeFile test1
    set f [open $path(script) w]
    puts $f [format {
	close stderr
	set f [open "%s" w]
	puts stderr hello
	close $f
	set f [open "%s" r]
	puts [gets $f]
    } $path(test1) $path(test1)]
    close $f
    set f [open "|[list [interpreter] $path(script)]" r]
    set c [gets $f]
    close $f
    set c
} hello

test io-14.9 {reuse of stdio special channels} {stdio} {
    removeFile script
    removeFile test1
    set f [open $path(script) w]
    puts $f {
        array set path [lindex $argv 0]
	set f [open $path(test1) w]
	puts $f hello
	close $f
	close stderr
	set f [open "|[list [info nameofexecutable] $path(cat) $path(test1)]" r]
	puts [gets $f]
    }
    close $f
    set f [open "|[list [interpreter] $path(script) [array get path]]" r]
    set c [gets $f]
    close $f
    set c
} hello

test io-15.1 {Tcl_CreateCloseHandler} {
} {}

test io-16.1 {Tcl_DeleteCloseHandler} {
} {}

# Test channel table management. The functions tested are
# GetChannelTable, DeleteChannelTable, Tcl_RegisterChannel,
# Tcl_UnregisterChannel, Tcl_GetChannel and Tcl_CreateChannel.
#
# These functions use "eof stdin" to ensure that the standard
# channels are added to the channel table of the interpreter.

test io-17.1 {GetChannelTable, DeleteChannelTable on std handles} {testchannel} {
    set l1 [testchannel refcount stdin]
    eof stdin
    interp create x
    set l ""
    lappend l [expr [testchannel refcount stdin] - $l1]
    x eval {eof stdin}
    lappend l [expr [testchannel refcount stdin] - $l1]
    interp delete x
    lappend l [expr [testchannel refcount stdin] - $l1]
    set l
} {0 1 0}
test io-17.2 {GetChannelTable, DeleteChannelTable on std handles} {testchannel} {
    set l1 [testchannel refcount stdout]
    eof stdin
    interp create x
    set l ""
    lappend l [expr [testchannel refcount stdout] - $l1]
    x eval {eof stdout}
    lappend l [expr [testchannel refcount stdout] - $l1]
    interp delete x
    lappend l [expr [testchannel refcount stdout] - $l1]
    set l
} {0 1 0}
test io-17.3 {GetChannelTable, DeleteChannelTable on std handles} {testchannel} {
    set l1 [testchannel refcount stderr]
    eof stdin
    interp create x
    set l ""
    lappend l [expr [testchannel refcount stderr] - $l1]
    x eval {eof stderr}
    lappend l [expr [testchannel refcount stderr] - $l1]
    interp delete x
    lappend l [expr [testchannel refcount stderr] - $l1]
    set l
} {0 1 0}

test io-18.1 {Tcl_RegisterChannel, Tcl_UnregisterChannel} {testchannel} {
    removeFile test1
    set l ""
    set f [open $path(test1) w]
    lappend l [lindex [testchannel info $f] 15]
    close $f
    if {[catch {lindex [testchannel info $f] 15} msg]} {
	lappend l $msg
    } else {
	lappend l "very broken: $f found after being closed"
    }
    string compare [string tolower $l] \
	[list 1 [format "can not find channel named \"%s\"" $f]]
} 0
test io-18.2 {Tcl_RegisterChannel, Tcl_UnregisterChannel} {testchannel} {
    removeFile test1
    set l ""
    set f [open $path(test1) w]
    lappend l [lindex [testchannel info $f] 15]
    interp create x
    interp share "" $f x
    lappend l [lindex [testchannel info $f] 15]
    x eval close $f
    lappend l [lindex [testchannel info $f] 15]
    interp delete x
    lappend l [lindex [testchannel info $f] 15]
    close $f
    if {[catch {lindex [testchannel info $f] 15} msg]} {
	lappend l $msg
    } else {
	lappend l "very broken: $f found after being closed"
    }
    string compare [string tolower $l] \
	[list 1 2 1 1 [format "can not find channel named \"%s\"" $f]]
} 0
test io-18.3 {Tcl_RegisterChannel, Tcl_UnregisterChannel} {testchannel} {
    removeFile test1
    set l ""
    set f [open $path(test1) w]
    lappend l [lindex [testchannel info $f] 15]
    interp create x
    interp share "" $f x
    lappend l [lindex [testchannel info $f] 15]
    interp delete x
    lappend l [lindex [testchannel info $f] 15]
    close $f
    if {[catch {lindex [testchannel info $f] 15} msg]} {
	lappend l $msg
    } else {
	lappend l "very broken: $f found after being closed"
    }
    string compare [string tolower $l] \
	[list 1 2 1 [format "can not find channel named \"%s\"" $f]]
} 0

test io-19.1 {Tcl_GetChannel->Tcl_GetStdChannel, standard handles} {
    eof stdin
} 0
test io-19.2 {testing Tcl_GetChannel, user opened handle} {
    removeFile test1
    set f [open $path(test1) w]
    set x [eof $f]
    close $f
    set x
} 0
test io-19.3 {Tcl_GetChannel, channel not found} {
    list [catch {eof file34} msg] $msg
} {1 {can not find channel named "file34"}}
test io-19.4 {Tcl_CreateChannel, insertion into channel table} {testchannel} {
    removeFile test1
    set f [open $path(test1) w]
    set l ""
    lappend l [eof $f]
    close $f
    if {[catch {lindex [testchannel info $f] 15} msg]} {
	lappend l $msg
    } else {
	lappend l "very broken: $f found after being closed"
    }
    string compare [string tolower $l] \
	[list 0 [format "can not find channel named \"%s\"" $f]]
} 0

test io-20.1 {Tcl_CreateChannel: initial settings} {
	set a [open $path(test2) w]
    set old [encoding system]
    encoding system ascii
    set f [open $path(test1) w]
    set x [fconfigure $f -encoding]
    close $f
    encoding system $old
	close $a
    set x
} {ascii}    
test io-20.2 {Tcl_CreateChannel: initial settings} {pcOnly} {
    set f [open $path(test1) w+]
    set x [list [fconfigure $f -eofchar] [fconfigure $f -translation]]
    close $f
    set x
} [list [list \x1a ""] {auto crlf}]
test io-20.3 {Tcl_CreateChannel: initial settings} {unixOnly} {
    set f [open $path(test1) w+]
    set x [list [fconfigure $f -eofchar] [fconfigure $f -translation]]
    close $f
    set x
} {{{} {}} {auto lf}}
test io-20.4 {Tcl_CreateChannel: initial settings} {macOnly} {
    set f [open $path(test1) w+]
    set x [list [fconfigure $f -eofchar] [fconfigure $f -translation]]
    close $f
    set x
} {{{} {}} {auto cr}}

set path(stdout) [makeFile {} stdout]

test io-20.5 {Tcl_CreateChannel: install channel in empty slot} {stdio} {
    set f [open $path(script) w]
    puts $f [format {
	close stdout
	set f1 [open "%s" w]
	fconfigure $f1 -buffersize 777
	puts stderr [fconfigure stdout -buffersize]
    } $path(stdout)]
    close $f
    set f [open "|[list [interpreter] $path(script)]"]
    catch {close $f} msg
    set msg
} {777}
	
test io-21.1 {CloseChannelsOnExit} {
} {}
    
# Test management of attributes associated with a channel, such as
# its default translation, its name and type, etc. The functions
# tested in this group are Tcl_GetChannelName,
# Tcl_GetChannelType and Tcl_GetChannelFile. Tcl_GetChannelInstanceData
# not tested because files do not use the instance data.

test io-22.1 {Tcl_GetChannelMode} {
    # Not used anywhere in Tcl.
} {}

test io-23.1 {Tcl_GetChannelName} {testchannel} {
    removeFile test1
    set f [open $path(test1) w]
    set n [testchannel name $f]
    close $f
    string compare $n $f
} 0

test io-24.1 {Tcl_GetChannelType} {testchannel} {
    removeFile test1
    set f [open $path(test1) w]
    set t [testchannel type $f]
    close $f
    string compare $t file
} 0

test io-25.1 {Tcl_GetChannelHandle, input} {testchannel} {
    set f [open $path(test1) w]
    fconfigure $f -translation lf -eofchar {}
    puts $f "1234567890\n098765432"
    close $f
    set f [open $path(test1) r]
    gets $f
    set l ""
    lappend l [testchannel inputbuffered $f]
    lappend l [tell $f]
    close $f
    set l
} {10 11}
test io-25.2 {Tcl_GetChannelHandle, output} {testchannel} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts $f hello
    set l ""
    lappend l [testchannel outputbuffered $f]
    lappend l [tell $f]
    flush $f
    lappend l [testchannel outputbuffered $f]
    lappend l [tell $f]
    close $f
    removeFile test1
    set l
} {6 6 0 6}

test io-26.1 {Tcl_GetChannelInstanceData} {stdio} {
    # "pid" command uses Tcl_GetChannelInstanceData
    # Don't care what pid is (but must be a number), just want to exercise it.

    set f [open "|[list [interpreter] << exit]"]
    expr [pid $f]
    close $f
} {}    

# Test flushing. The functions tested here are FlushChannel.

test io-27.1 {FlushChannel, no output buffered} {
    removeFile test1
    set f [open $path(test1) w]
    flush $f
    set s [file size $path(test1)]
    close $f
    set s
} 0
test io-27.2 {FlushChannel, some output buffered} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf -eofchar {}
    set l ""
    puts $f hello
    lappend l [file size $path(test1)]
    flush $f
    lappend l [file size $path(test1)]
    close $f
    lappend l [file size $path(test1)]
    set l
} {0 6 6}
test io-27.3 {FlushChannel, implicit flush on close} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf -eofchar {}
    set l ""
    puts $f hello
    lappend l [file size $path(test1)]
    close $f
    lappend l [file size $path(test1)]
    set l
} {0 6}
test io-27.4 {FlushChannel, implicit flush when buffer fills} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf -eofchar {}
    fconfigure $f -buffersize 60
    set l ""
    lappend l [file size $path(test1)]
    for {set i 0} {$i < 12} {incr i} {
	puts $f hello
    }
    lappend l [file size $path(test1)]
    flush $f
    lappend l [file size $path(test1)]
    close $f
    set l
} {0 60 72}
test io-27.5 {FlushChannel, implicit flush when buffer fills and on close} \
	{unixOrPc} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf -buffersize 60 -eofchar {}
    set l ""
    lappend l [file size $path(test1)]
    for {set i 0} {$i < 12} {incr i} {
	puts $f hello
    }
    lappend l [file size $path(test1)]
    close $f
    lappend l [file size $path(test1)]
    set l
} {0 60 72}

set path(pipe)   [makeFile {} pipe]
set path(output) [makeFile {} output]

test io-27.6 {FlushChannel, async flushing, async close} \
	{stdio asyncPipeClose } {
    removeFile pipe
    removeFile output
    set f [open $path(pipe) w]
    puts $f [format {
	set f [open "%s" w]
	fconfigure $f -translation lf -buffering none -eofchar {}
	while {![eof stdin]} {
	    after 20
	    puts -nonewline $f [read stdin 1024]
	}
	close $f
    } $path(output)]
    close $f
    set x 01234567890123456789012345678901
    for {set i 0} {$i < 11} {incr i} {
        set x "$x$x"
    }
    set f [open $path(output) w]
    close $f
    set f [open "|[list [interpreter] $path(pipe)]" w]
    fconfigure $f -blocking off
    puts -nonewline $f $x
    close $f
    set counter 0
    while {([file size $path(output)] < 65536) && ($counter < 1000)} {
        incr counter
        after 20
        update
    }
    if {$counter == 1000} {
        set result "file size only [file size $path(output)]"
    } else {
        set result ok
    }
} ok

# Tests closing a channel. The functions tested are CloseChannel and Tcl_Close.

test io-28.1 {CloseChannel called when all references are dropped} {testchannel} {
    removeFile test1
    set f [open $path(test1) w]
    interp create x
    interp share "" $f x
    set l ""
    lappend l [testchannel refcount $f]
    x eval close $f
    interp delete x
    lappend l [testchannel refcount $f]
    close $f
    set l
} {2 1}
test io-28.2 {CloseChannel called when all references are dropped} {
    removeFile test1
    set f [open $path(test1) w]
    interp create x
    interp share "" $f x
    puts -nonewline $f abc
    close $f
    x eval puts $f def
    x eval close $f
    interp delete x
    set f [open $path(test1) r]
    set l [gets $f]
    close $f
    set l
} abcdef
test io-28.3 {CloseChannel, not called before output queue is empty} \
	{stdio asyncPipeClose nonPortable} {
    removeFile pipe
    removeFile output
    set f [open $path(pipe) w]
    puts $f {

	# Need to not have eof char appended on close, because the other
	# side of the pipe already closed, so that writing would cause an
	# error "invalid file".

	fconfigure stdout -eofchar {}
	fconfigure stderr -eofchar {}

	set f [open $path(output) w]
	fconfigure $f -translation lf -buffering none
	for {set x 0} {$x < 20} {incr x} {
	    after 20
	    puts -nonewline $f [read stdin 1024]
	}
	close $f
    }
    close $f
    set x 01234567890123456789012345678901
    for {set i 0} {$i < 11} {incr i} {
        set x "$x$x"
    }
    set f [open $path(output) w]
    close $f
    set f [open "|[list [interpreter] pipe]" r+]
    fconfigure $f -blocking off -eofchar {}

    puts -nonewline $f $x
    close $f
    set counter 0
    while {([file size $path(output)] < 20480) && ($counter < 1000)} {
        incr counter
        after 20
        update
    }
    if {$counter == 1000} {
        set result probably_broken
    } else {
        set result ok
    }
} ok
test io-28.4 {Tcl_Close} {testchannel} {
    removeFile test1
    set l ""
    lappend l [lsort [testchannel open]]
    set f [open $path(test1) w]
    lappend l [lsort [testchannel open]]
    close $f
    lappend l [lsort [testchannel open]]
    set x [list $consoleFileNames \
		[lsort [eval list $consoleFileNames $f]] \
		$consoleFileNames]
    string compare $l $x
} 0
test io-28.5 {Tcl_Close vs standard handles} {stdio unixOnly testchannel} {
    removeFile script
    set f [open $path(script) w]
    puts $f {
	close stdin
	puts [testchannel open]
    }
    close $f
    set f [open "|[list [interpreter] $path(script)]" r]
    set l [gets $f]
    close $f
    set l
} {file1 file2}

test io-29.1 {Tcl_WriteChars, channel not writable} {
    list [catch {puts stdin hello} msg] $msg
} {1 {channel "stdin" wasn't opened for writing}}
test io-29.2 {Tcl_WriteChars, empty string} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -eofchar {}
    puts -nonewline $f ""
    close $f
    file size $path(test1)
} 0
test io-29.3 {Tcl_WriteChars, nonempty string} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -eofchar {}
    puts -nonewline $f hello
    close $f
    file size $path(test1)
} 5
test io-29.4 {Tcl_WriteChars, buffering in full buffering mode} {testchannel} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf -buffering full -eofchar {}
    puts $f hello
    set l ""
    lappend l [testchannel outputbuffered $f]
    lappend l [file size $path(test1)]
    flush $f
    lappend l [testchannel outputbuffered $f]
    lappend l [file size $path(test1)]
    close $f
    set l
} {6 0 0 6}
test io-29.5 {Tcl_WriteChars, buffering in line buffering mode} {testchannel} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf -buffering line -eofchar {}
    puts -nonewline $f hello
    set l ""
    lappend l [testchannel outputbuffered $f]
    lappend l [file size $path(test1)]
    puts $f hello
    lappend l [testchannel outputbuffered $f]
    lappend l [file size $path(test1)]
    close $f
    set l
} {5 0 0 11}
test io-29.6 {Tcl_WriteChars, buffering in no buffering mode} {testchannel} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf -buffering none -eofchar {}
    puts -nonewline $f hello
    set l ""
    lappend l [testchannel outputbuffered $f]
    lappend l [file size $path(test1)]
    puts $f hello
    lappend l [testchannel outputbuffered $f]
    lappend l [file size $path(test1)]
    close $f
    set l
} {0 5 0 11}

test io-29.7 {Tcl_Flush, full buffering} {testchannel} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf -buffering full -eofchar {}
    puts -nonewline $f hello
    set l ""
    lappend l [testchannel outputbuffered $f]
    lappend l [file size $path(test1)]
    puts $f hello
    lappend l [testchannel outputbuffered $f]
    lappend l [file size $path(test1)]
    flush $f
    lappend l [testchannel outputbuffered $f]
    lappend l [file size $path(test1)]
    close $f
    set l
} {5 0 11 0 0 11}
test io-29.8 {Tcl_Flush, full buffering} {testchannel} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf -buffering line
    puts -nonewline $f hello
    set l ""
    lappend l [testchannel outputbuffered $f]
    lappend l [file size $path(test1)]
    flush $f
    lappend l [testchannel outputbuffered $f]
    lappend l [file size $path(test1)]
    puts $f hello
    lappend l [testchannel outputbuffered $f]
    lappend l [file size $path(test1)]
    flush $f
    lappend l [testchannel outputbuffered $f]
    lappend l [file size $path(test1)]
    close $f
    set l
} {5 0 0 5 0 11 0 11}
test io-29.9 {Tcl_Flush, channel not writable} {
    list [catch {flush stdin} msg] $msg
} {1 {channel "stdin" wasn't opened for writing}}
test io-29.10 {Tcl_WriteChars, looping and buffering} {
    removeFile test1
    set f1 [open $path(test1) w]
    fconfigure $f1 -translation lf -eofchar {}
    set f2 [open $path(longfile) r]
    for {set x 0} {$x < 10} {incr x} {
	puts $f1 [gets $f2]
    }
    close $f2
    close $f1
    file size $path(test1)
} 387
test io-29.11 {Tcl_WriteChars, no newline, implicit flush} {
    removeFile test1
    set f1 [open $path(test1) w]
    fconfigure $f1 -eofchar {}
    set f2 [open $path(longfile) r]
    for {set x 0} {$x < 10} {incr x} {
	puts -nonewline $f1 [gets $f2]
    }
    close $f1
    close $f2
    file size $path(test1)
} 377
test io-29.12 {Tcl_WriteChars on a pipe} {stdio} {
    removeFile test1
    removeFile pipe
    set f1 [open $path(pipe) w]
    puts $f1 [format {
	set f1 [open "%s" r]
	for {set x 0} {$x < 10} {incr x} {
	    puts [gets $f1]
	}
    } $path(longfile)]
    close $f1
    set f1 [open "|[list [interpreter] $path(pipe)]" r]
    set f2 [open $path(longfile) r]
    set y ok
    for {set x 0} {$x < 10} {incr x} {
	set l1 [gets $f1]
	set l2 [gets $f2]
	if {"$l1" != "$l2"} {
	    set y broken
	}
    }
    close $f1
    close $f2
    set y
} ok
test io-29.13 {Tcl_WriteChars to a pipe, line buffered} {stdio} {
    removeFile test1
    removeFile pipe
    set f1 [open $path(pipe) w]
    puts $f1 {
	puts [gets stdin]
	puts [gets stdin]
    }
    close $f1
    set y ok
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
    fconfigure $f1 -buffering line
    set f2 [open $path(longfile) r]
    set line [gets $f2]
    puts $f1 $line
    set backline [gets $f1]
    if {"$line" != "$backline"} {
	set y broken
    }
    set line [gets $f2]
    puts $f1 $line
    set backline [gets $f1]
    if {"$line" != "$backline"} {
	set y broken
    }
    close $f1
    close $f2
    set y
} ok
test io-29.14 {Tcl_WriteChars, buffering and implicit flush at close} {
    removeFile test3
    set f [open $path(test3) w]
    puts -nonewline $f "Text1"
    puts -nonewline $f " Text 2"
    puts $f " Text 3"
    close $f
    set f [open $path(test3) r]
    set x [gets $f]
    close $f
    set x
} {Text1 Text 2 Text 3}
test io-29.15 {Tcl_Flush, channel not open for writing} {
    removeFile test1
    set fd [open $path(test1) w]
    close $fd
    set fd [open $path(test1) r]
    set x [list [catch {flush $fd} msg] $msg]
    close $fd
    string compare $x \
	[list 1 "channel \"$fd\" wasn't opened for writing"]
} 0
test io-29.16 {Tcl_Flush on pipe opened only for reading} {stdio} {
    set fd [open "|[list [interpreter] cat longfile]" r]
    set x [list [catch {flush $fd} msg] $msg]
    catch {close $fd}
    string compare $x \
	[list 1 "channel \"$fd\" wasn't opened for writing"]
} 0
test io-29.17 {Tcl_WriteChars buffers, then Tcl_Flush flushes} {
    removeFile test1
    set f1 [open $path(test1) w]
    fconfigure $f1 -translation lf
    puts $f1 hello
    puts $f1 hello
    puts $f1 hello
    flush $f1
    set x [file size $path(test1)]
    close $f1
    set x
} 18
test io-29.18 {Tcl_WriteChars and Tcl_Flush intermixed} {
    removeFile test1
    set x ""
    set f1 [open $path(test1) w]
    fconfigure $f1 -translation lf
    puts $f1 hello
    puts $f1 hello
    puts $f1 hello
    flush $f1
    lappend x [file size $path(test1)]
    puts $f1 hello
    flush $f1
    lappend x [file size $path(test1)]
    puts $f1 hello
    flush $f1
    lappend x [file size $path(test1)]
    close $f1
    set x
} {18 24 30}
test io-29.19 {Explicit and implicit flushes} {
    removeFile test1
    set f1 [open $path(test1) w]
    fconfigure $f1 -translation lf -eofchar {}
    set x ""
    puts $f1 hello
    puts $f1 hello
    puts $f1 hello
    flush $f1
    lappend x [file size $path(test1)]
    puts $f1 hello
    flush $f1
    lappend x [file size $path(test1)]
    puts $f1 hello
    close $f1
    lappend x [file size $path(test1)]
    set x
} {18 24 30}
test io-29.20 {Implicit flush when buffer is full} {
    removeFile test1
    set f1 [open $path(test1) w]
    fconfigure $f1 -translation lf -eofchar {}
    set line "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    for {set x 0} {$x < 100} {incr x} {
      puts $f1 $line
    }
    set z ""
    lappend z [file size $path(test1)]
    for {set x 0} {$x < 100} {incr x} {
	puts $f1 $line
    }
    lappend z [file size $path(test1)]
    close $f1
    lappend z [file size $path(test1)]
    set z
} {4096 12288 12600}
test io-29.21 {Tcl_Flush to pipe} {stdio} {
    removeFile pipe
    set f1 [open $path(pipe) w]
    puts $f1 {set x [read stdin 6]}
    puts $f1 {set cnt [string length $x]}
    puts $f1 {puts "read $cnt characters"}
    close $f1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
    puts $f1 hello
    flush $f1
    set x [gets $f1]
    catch {close $f1}
    set x
} "read 6 characters"
test io-29.22 {Tcl_Flush called at other end of pipe} {stdio} {
    removeFile pipe
    set f1 [open $path(pipe) w]
    puts $f1 {
	fconfigure stdout -buffering full
	puts hello
	puts hello
	flush stdout
	gets stdin
	puts bye
	flush stdout
    }
    close $f1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
    set x ""
    lappend x [gets $f1]
    lappend x [gets $f1]
    puts $f1 hello
    flush $f1
    lappend x [gets $f1]
    close $f1
    set x
} {hello hello bye}
test io-29.23 {Tcl_Flush and line buffering at end of pipe} {stdio} {
    removeFile pipe
    set f1 [open $path(pipe) w]
    puts $f1 {
	puts hello
	puts hello
	gets stdin
	puts bye
    }
    close $f1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
    set x ""
    lappend x [gets $f1]
    lappend x [gets $f1]
    puts $f1 hello
    flush $f1
    lappend x [gets $f1]
    close $f1
    set x
} {hello hello bye}
test io-29.24 {Tcl_WriteChars and Tcl_Flush move end of file} {
    set f [open $path(test3) w]
    puts $f "Line 1"
    puts $f "Line 2"
    set f2 [open $path(test3)]
    set x {}
    lappend x [read -nonewline $f2]
    close $f2
    flush $f
    set f2 [open $path(test3)]
    lappend x [read -nonewline $f2]
    close $f2
    close $f
    set x
} "{} {Line 1\nLine 2}"
test io-29.25 {Implicit flush with Tcl_Flush to command pipelines} {stdio} {
    removeFile test3
    set f [open "|[list [interpreter] $path(cat) | [interpreter] $path(cat) > $path(test3)]" w]
    puts $f "Line 1"
    puts $f "Line 2"
    close $f
    after 100
    set f [open $path(test3) r]
    set x [read $f]
    close $f
    set x
} "Line 1\nLine 2\n"
test io-29.26 {Tcl_Flush, Tcl_Write on bidirectional pipelines} {stdio unixExecs} {
    set f [open "|[list cat -u]" r+]
    puts $f "Line1"
    flush $f
    set x [gets $f]
    close $f
    set x
} {Line1}
test io-29.27 {Tcl_Flush on closed pipeline} {stdio} {
    removeFile pipe
    set f [open $path(pipe) w]
    puts $f {exit}
    close $f
    set f [open "|[list [interpreter] $path(pipe)]" r+]
    gets $f
    puts $f output
    after 50
    #
    # The flush below will get a SIGPIPE. This is an expected part of
    # test and indicates that the test operates correctly. If you run
    # this test under a debugger, the signal will by intercepted unless
    # you disable the debugger's signal interception.
    #
    if {[catch {flush $f} msg]} {
	set x [list 1 $msg $errorCode]
	catch {close $f}
    } else {
	if {[catch {close $f} msg]} {
	    set x [list 1 $msg $errorCode]
	} else {
	    set x {this was supposed to fail and did not}
	}
    }
    regsub {".*":} $x {"":} x
    string tolower $x
} {1 {error flushing "": broken pipe} {posix epipe {broken pipe}}}
test io-29.28 {Tcl_WriteChars, lf mode} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf -eofchar {}
    puts $f hello\nthere\nand\nhere
    flush $f
    set s [file size $path(test1)]
    close $f
    set s
} 21
test io-29.29 {Tcl_WriteChars, cr mode} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation cr -eofchar {}
    puts $f hello\nthere\nand\nhere
    close $f
    file size $path(test1)
} 21
test io-29.30 {Tcl_WriteChars, crlf mode} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation crlf -eofchar {}
    puts $f hello\nthere\nand\nhere
    close $f
    file size $path(test1)
} 25
test io-29.31 {Tcl_WriteChars, background flush} {stdio} {
    removeFile pipe
    removeFile output
    set f [open $path(pipe) w]
    puts $f [format {set f [open "%s" w]} $path(output)]
    puts $f {fconfigure $f -translation lf}
    set x [list while {![eof stdin]}]
    set x "$x {"
    puts $f $x
    puts $f {  puts -nonewline $f [read stdin 4096]}
    puts $f {  flush $f}
    puts $f "}"
    puts $f {close $f}
    close $f
    set x 01234567890123456789012345678901
    for {set i 0} {$i < 11} {incr i} {
	set x "$x$x"
    }
    set f [open $path(output) w]
    close $f
    set f [open "|[list [interpreter] $path(pipe)]" r+]
    fconfigure $f -blocking off
    puts -nonewline $f $x
    close $f
    set counter 0
    while {([file size $path(output)] < 65536) && ($counter < 1000)} {
	incr counter
	after 5
	update
    }
    if {$counter == 1000} {
	set result "file size only [file size $path(output)]"
    } else {
	set result ok
    }
} ok
test io-29.32 {Tcl_WriteChars, background flush to slow reader} \
	{stdio asyncPipeClose} {
    removeFile pipe
    removeFile output
    set f [open $path(pipe) w]
    puts $f [format {set f [open "%s" w]} $path(output)]
    puts $f {fconfigure $f -translation lf}
    set x [list while {![eof stdin]}]
    set x "$x {"
    puts $f $x
    puts $f {  after 20}
    puts $f {  puts -nonewline $f [read stdin 1024]}
    puts $f {  flush $f}
    puts $f "}"
    puts $f {close $f}
    close $f
    set x 01234567890123456789012345678901
    for {set i 0} {$i < 11} {incr i} {
	set x "$x$x"
    }
    set f [open $path(output) w]
    close $f
    set f [open "|[list [interpreter] $path(pipe)]" r+]
    fconfigure $f -blocking off
    puts -nonewline $f $x
    close $f
    set counter 0
    while {([file size $path(output)] < 65536) && ($counter < 1000)} {
	incr counter
	after 20
	update
    }
    if {$counter == 1000} {
	set result "file size only [file size $path(output)]"
    } else {
	set result ok
    }
} ok
test io-29.33 {Tcl_Flush, implicit flush on exit} {exec} {
    set f [open $path(script) w]
    puts $f [format {
	set f [open "%s" w]
	fconfigure $f -translation lf
	puts $f hello
	puts $f bye
	puts $f strange
    } $path(test1)]
    close $f
    exec [interpreter] $path(script)
    set f [open $path(test1) r]
    set r [read $f]
    close $f
    set r
} "hello\nbye\nstrange\n"
test io-29.34 {Tcl_Close, async flush on close, using sockets} {socket tempNotMac} {
    set c 0
    variable x running
    set l abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz
    proc writelots {s l} {
	for {set i 0} {$i < 2000} {incr i} {
	    puts $s $l
	}
    }
    proc accept {s a p} {
	variable x
	fileevent $s readable [namespace code [list readit $s]]
	fconfigure $s -blocking off
	set x accepted
    }
    proc readit {s} {
	variable c
	variable x
	set l [gets $s]
	
	if {[eof $s]} {
	    close $s
	    set x done
	} elseif {([string length $l] > 0) || ![fblocked $s]} {
	    incr c
	}
    }
    set ss [socket -server [namespace code accept] 0]
    set cs [socket [info hostname] [lindex [fconfigure $ss -sockname] 2]]
    vwait [namespace which -variable x]
    fconfigure $cs -blocking off
    writelots $cs $l
    close $cs
    close $ss
    vwait [namespace which -variable x]
    set c
} 2000
test io-29.35 {Tcl_Close vs fileevent vs multiple interpreters} {socket tempNotMac} {
    # On Mac, this test screws up sockets such that subsequent tests using port 2828 
    # either cause errors or panic().
     
    catch {interp delete x}
    catch {interp delete y}
    interp create x
    interp create y
    set s [socket -server [namespace code accept] 0]
    proc accept {s a p} {
	puts $s hello
	close $s
    }
    set c [socket [info hostname] [lindex [fconfigure $s -sockname] 2]]
    interp share {} $c x
    interp share {} $c y
    close $c
    x eval {
	proc readit {s} {
	    gets $s
	    if {[eof $s]} {
		close $s
	    }
	}
    }
    y eval {
	proc readit {s} {
	    gets $s
	    if {[eof $s]} {
		close $s
	    }
	}
    }
    x eval "fileevent $c readable \{readit $c\}"
    y eval "fileevent $c readable \{readit $c\}"
    y eval [list close $c]
    update
    close $s
    interp delete x
    interp delete y
} ""

# Test end of line translations. Procedures tested are Tcl_Write, Tcl_Read.

test io-30.1 {Tcl_Write lf, Tcl_Read lf} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation lf
    set x [read $f]
    close $f
    set x
} "hello\nthere\nand\nhere\n"
test io-30.2 {Tcl_Write lf, Tcl_Read cr} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation cr
    set x [read $f]
    close $f
    set x
} "hello\nthere\nand\nhere\n"
test io-30.3 {Tcl_Write lf, Tcl_Read crlf} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation crlf
    set x [read $f]
    close $f
    set x
} "hello\nthere\nand\nhere\n"
test io-30.4 {Tcl_Write cr, Tcl_Read cr} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation cr
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation cr
    set x [read $f]
    close $f
    set x
} "hello\nthere\nand\nhere\n"
test io-30.5 {Tcl_Write cr, Tcl_Read lf} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation cr
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation lf
    set x [read $f]
    close $f
    set x
} "hello\rthere\rand\rhere\r"
test io-30.6 {Tcl_Write cr, Tcl_Read crlf} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation cr
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation crlf
    set x [read $f]
    close $f
    set x 
} "hello\rthere\rand\rhere\r"
test io-30.7 {Tcl_Write crlf, Tcl_Read crlf} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation crlf
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation crlf
    set x [read $f]
    close $f
    set x
} "hello\nthere\nand\nhere\n"
test io-30.8 {Tcl_Write crlf, Tcl_Read lf} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation crlf
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation lf
    set x [read $f]
    close $f
    set x
} "hello\r\nthere\r\nand\r\nhere\r\n"
test io-30.9 {Tcl_Write crlf, Tcl_Read cr} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation crlf
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation cr
    set x [read $f]
    close $f
    set x
} "hello\n\nthere\n\nand\n\nhere\n\n"
test io-30.10 {Tcl_Write lf, Tcl_Read auto} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open $path(test1) r]
    set c [read $f]
    set x [fconfigure $f -translation]
    close $f
    list $c $x
} {{hello
there
and
here
} auto}
test io-30.11 {Tcl_Write cr, Tcl_Read auto} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation cr
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open $path(test1) r]
    set c [read $f]
    set x [fconfigure $f -translation]
    close $f
    list $c $x
} {{hello
there
and
here
} auto}
test io-30.12 {Tcl_Write crlf, Tcl_Read auto} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation crlf
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open $path(test1) r]
    set c [read $f]
    set x [fconfigure $f -translation]
    close $f
    list $c $x
} {{hello
there
and
here
} auto}

test io-30.13 {Tcl_Write crlf on block boundary, Tcl_Read auto} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation crlf
    set line "123456789ABCDE"	;# 14 char plus crlf
    puts -nonewline $f x	;# shift crlf across block boundary
    for {set i 0} {$i < 700} {incr i} {
	puts $f $line
    }
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation auto
    set c [read $f]
    close $f
    string length $c
} [expr 700*15+1]

test io-30.14 {Tcl_Write crlf on block boundary, Tcl_Read crlf} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation crlf
    set line "123456789ABCDE"	;# 14 char plus crlf
    puts -nonewline $f x	;# shift crlf across block boundary
    for {set i 0} {$i < 700} {incr i} {
	puts $f $line
    }
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation crlf
    set c [read $f]
    close $f
    string length $c
} [expr 700*15+1]

test io-30.15 {Tcl_Write mixed, Tcl_Read auto} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts $f hello\nthere\nand\rhere
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation auto
    set c [read $f]
    close $f
    set c
} {hello
there
and
here
}
test io-30.16 {Tcl_Write ^Z at end, Tcl_Read auto} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f hello\nthere\nand\rhere\n\x1a
    close $f
    set f [open $path(test1) r]
    fconfigure $f -eofchar \x1a -translation auto
    set c [read $f]
    close $f
    set c
} {hello
there
and
here
}
test io-30.17 {Tcl_Write, implicit ^Z at end, Tcl_Read auto} {pcOnly} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -eofchar \x1a -translation lf
    puts $f hello\nthere\nand\rhere
    close $f
    set f [open $path(test1) r]
    fconfigure $f -eofchar \x1a -translation auto
    set c [read $f]
    close $f
    set c
} {hello
there
and
here
}
test io-30.18 {Tcl_Write, ^Z in middle, Tcl_Read auto} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    set s [format "abc\ndef\n%cghi\nqrs" 26]
    puts $f $s
    close $f
    set f [open $path(test1) r]
    fconfigure $f -eofchar \x1a -translation auto
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {abc def 0 {} 1 {} 1}
test io-30.19 {Tcl_Write, ^Z no newline in middle, Tcl_Read auto} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    set s [format "abc\ndef\n%cghi\nqrs" 26]
    puts $f $s
    close $f
    set f [open $path(test1) r]
    fconfigure $f -eofchar \x1a -translation auto
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {abc def 0 {} 1 {} 1}
test io-30.20 {Tcl_Write, ^Z in middle ignored, Tcl_Read lf} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf -eofchar {}
    set s [format "abc\ndef\n%cghi\nqrs" 26]
    puts $f $s
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation lf -eofchar {}
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} "abc def 0 \x1aghi 0 qrs 0 {} 1"
test io-30.21 {Tcl_Write, ^Z in middle ignored, Tcl_Read cr} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf -eofchar {}
    set s [format "abc\ndef\n%cghi\nqrs" 26]
    puts $f $s
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation cr -eofchar {}
    set l ""
    set x [gets $f]
    lappend l [string compare $x "abc\ndef\n\x1aghi\nqrs\n"]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {0 1 {} 1}
test io-30.22 {Tcl_Write, ^Z in middle ignored, Tcl_Read crlf} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf -eofchar {}
    set s [format "abc\ndef\n%cghi\nqrs" 26]
    puts $f $s
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation crlf -eofchar {}
    set l ""
    set x [gets $f]
    lappend l [string compare $x "abc\ndef\n\x1aghi\nqrs\n"]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {0 1 {} 1}
test io-30.23 {Tcl_Write lf, ^Z in middle, Tcl_Read auto} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    set c [format abc\ndef\n%cqrs\ntuv 26]
    puts $f $c
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation auto -eofchar \x1a
    set c [string length [read $f]]
    set e [eof $f]
    close $f
    list $c $e
} {8 1}
test io-30.24 {Tcl_Write lf, ^Z in middle, Tcl_Read lf} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    set c [format abc\ndef\n%cqrs\ntuv 26]
    puts $f $c
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation lf -eofchar \x1a
    set c [string length [read $f]]
    set e [eof $f]
    close $f
    list $c $e
} {8 1}
test io-30.25 {Tcl_Write cr, ^Z in middle, Tcl_Read auto} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation cr
    set c [format abc\ndef\n%cqrs\ntuv 26]
    puts $f $c
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation auto -eofchar \x1a
    set c [string length [read $f]]
    set e [eof $f]
    close $f
    list $c $e
} {8 1}
test io-30.26 {Tcl_Write cr, ^Z in middle, Tcl_Read cr} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation cr
    set c [format abc\ndef\n%cqrs\ntuv 26]
    puts $f $c
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation cr -eofchar \x1a
    set c [string length [read $f]]
    set e [eof $f]
    close $f
    list $c $e
} {8 1}
test io-30.27 {Tcl_Write crlf, ^Z in middle, Tcl_Read auto} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation crlf
    set c [format abc\ndef\n%cqrs\ntuv 26]
    puts $f $c
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation auto -eofchar \x1a
    set c [string length [read $f]]
    set e [eof $f]
    close $f
    list $c $e
} {8 1}
test io-30.28 {Tcl_Write crlf, ^Z in middle, Tcl_Read crlf} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation crlf
    set c [format abc\ndef\n%cqrs\ntuv 26]
    puts $f $c
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation crlf -eofchar \x1a
    set c [string length [read $f]]
    set e [eof $f]
    close $f
    list $c $e
} {8 1}

# Test end of line translations. Functions tested are Tcl_Write and Tcl_Gets.

test io-31.1 {Tcl_Write lf, Tcl_Gets auto} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open $path(test1) r]
    set l ""
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    close $f
    set l
} {hello 6 auto there 12 auto}
test io-31.2 {Tcl_Write cr, Tcl_Gets auto} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation cr
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open $path(test1) r]
    set l ""
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    close $f
    set l
} {hello 6 auto there 12 auto}
test io-31.3 {Tcl_Write crlf, Tcl_Gets auto} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation crlf
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open $path(test1) r]
    set l ""
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    close $f
    set l
} {hello 7 auto there 14 auto}
test io-31.4 {Tcl_Write lf, Tcl_Gets lf} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation lf
    set l ""
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    close $f
    set l
} {hello 6 lf there 12 lf}
test io-31.5 {Tcl_Write lf, Tcl_Gets cr} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation cr
    set l ""
    lappend l [string length [gets $f]]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [eof $f]
    close $f
    set l
} {21 21 cr 1 {} 21 cr 1}
test io-31.6 {Tcl_Write lf, Tcl_Gets crlf} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation crlf
    set l ""
    lappend l [string length [gets $f]]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [eof $f]
    close $f
    set l
} {21 21 crlf 1 {} 21 crlf 1}
test io-31.7 {Tcl_Write cr, Tcl_Gets cr} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation cr
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation cr
    set l ""
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [eof $f]
    close $f
    set l
} {hello 6 cr 0 there 12 cr 0}
test io-31.8 {Tcl_Write cr, Tcl_Gets lf} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation cr
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation lf
    set l ""
    lappend l [string length [gets $f]]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [eof $f]
    close $f
    set l
} {21 21 lf 1 {} 21 lf 1}
test io-31.9 {Tcl_Write cr, Tcl_Gets crlf} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation cr
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation crlf
    set l ""
    lappend l [string length [gets $f]]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [eof $f]
    close $f
    set l
} {21 21 crlf 1 {} 21 crlf 1}
test io-31.10 {Tcl_Write crlf, Tcl_Gets crlf} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation crlf
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation crlf
    set l ""
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [eof $f]
    close $f
    set l
} {hello 7 crlf 0 there 14 crlf 0}
test io-31.11 {Tcl_Write crlf, Tcl_Gets cr} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation crlf
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation cr
    set l ""
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [eof $f]
    lappend l [string length [gets $f]]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [eof $f]
    close $f
    set l
} {hello 6 cr 0 6 13 cr 0}
test io-31.12 {Tcl_Write crlf, Tcl_Gets lf} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation crlf
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation lf
    set l ""
    lappend l [string length [gets $f]]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [eof $f]
    lappend l [string length [gets $f]]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [eof $f]
    close $f
    set l
} {6 7 lf 0 6 14 lf 0}
test io-31.13 {binary mode is synonym of lf mode} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation binary
    set x [fconfigure $f -translation]
    close $f
    set x
} lf
#
# Test io-9.14 has been removed because "auto" output translation mode is
# not supoprted.
#
test io-31.14 {Tcl_Write mixed, Tcl_Gets auto} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts $f hello\nthere\rand\r\nhere
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation auto
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {hello there and here 0 {} 1}
test io-31.15 {Tcl_Write mixed, Tcl_Gets auto} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f hello\nthere\rand\r\nhere\r
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation auto
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {hello there and here 0 {} 1}
test io-31.16 {Tcl_Write mixed, Tcl_Gets auto} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f hello\nthere\rand\r\nhere\n
    close $f
    set f [open $path(test1) r]
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {hello there and here 0 {} 1}
test io-31.17 {Tcl_Write mixed, Tcl_Gets auto} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f hello\nthere\rand\r\nhere\r\n
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation auto
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {hello there and here 0 {} 1}
test io-31.18 {Tcl_Write ^Z at end, Tcl_Gets auto} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    set s [format "hello\nthere\nand\rhere\n\%c" 26]
    puts $f $s
    close $f
    set f [open $path(test1) r]
    fconfigure $f -eofchar \x1a -translation auto
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {hello there and here 0 {} 1}
test io-31.19 {Tcl_Write, implicit ^Z at end, Tcl_Gets auto} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -eofchar \x1a -translation lf
    puts $f hello\nthere\nand\rhere
    close $f
    set f [open $path(test1) r]
    fconfigure $f -eofchar \x1a -translation auto
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {hello there and here 0 {} 1}
test io-31.20 {Tcl_Write, ^Z in middle, Tcl_Gets auto, eofChar} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    set s [format "abc\ndef\n%cqrs\ntuv" 26]
    puts $f $s
    close $f
    set f [open $path(test1) r]
    fconfigure $f -eofchar \x1a
    fconfigure $f -translation auto
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {abc def 0 {} 1}
test io-31.21 {Tcl_Write, no newline ^Z in middle, Tcl_Gets auto, eofChar} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    set s [format "abc\ndef\n%cqrs\ntuv" 26]
    puts $f $s
    close $f
    set f [open $path(test1) r]
    fconfigure $f -eofchar \x1a -translation auto
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {abc def 0 {} 1}
test io-31.22 {Tcl_Write, ^Z in middle ignored, Tcl_Gets lf} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf -eofchar {}
    set s [format "abc\ndef\n%cqrs\ntuv" 26]
    puts $f $s
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation lf -eofchar {}
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} "abc def 0 \x1aqrs 0 tuv 0 {} 1"
test io-31.23 {Tcl_Write, ^Z in middle ignored, Tcl_Gets cr} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation cr -eofchar {}
    set s [format "abc\ndef\n%cqrs\ntuv" 26]
    puts $f $s
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation cr -eofchar {}
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} "abc def 0 \x1aqrs 0 tuv 0 {} 1"
test io-31.24 {Tcl_Write, ^Z in middle ignored, Tcl_Gets crlf} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation crlf -eofchar {}
    set s [format "abc\ndef\n%cqrs\ntuv" 26]
    puts $f $s
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation crlf -eofchar {}
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} "abc def 0 \x1aqrs 0 tuv 0 {} 1"
test io-31.25 {Tcl_Write lf, ^Z in middle, Tcl_Gets auto} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    set s [format "abc\ndef\n%cqrs\ntuv" 26]
    puts $f $s
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation auto -eofchar \x1a
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {abc def 0 {} 1}
test io-31.26 {Tcl_Write lf, ^Z in middle, Tcl_Gets lf} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    set s [format "abc\ndef\n%cqrs\ntuv" 26]
    puts $f $s
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation lf -eofchar \x1a
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {abc def 0 {} 1}
test io-31.27 {Tcl_Write cr, ^Z in middle, Tcl_Gets auto} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation cr -eofchar {}
    set s [format "abc\ndef\n%cqrs\ntuv" 26]
    puts $f $s
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation auto -eofchar \x1a
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {abc def 0 {} 1}
test io-31.28 {Tcl_Write cr, ^Z in middle, Tcl_Gets cr} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation cr -eofchar {}
    set s [format "abc\ndef\n%cqrs\ntuv" 26]
    puts $f $s
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation cr -eofchar \x1a
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {abc def 0 {} 1}
test io-31.29 {Tcl_Write crlf, ^Z in middle, Tcl_Gets auto} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation crlf -eofchar {}
    set s [format "abc\ndef\n%cqrs\ntuv" 26]
    puts $f $s
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation auto -eofchar \x1a
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {abc def 0 {} 1}
test io-31.30 {Tcl_Write crlf, ^Z in middle, Tcl_Gets crlf} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation crlf -eofchar {}
    set s [format "abc\ndef\n%cqrs\ntuv" 26]
    puts $f $s
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation crlf -eofchar \x1a
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {abc def 0 {} 1}
test io-31.31 {Tcl_Write crlf on block boundary, Tcl_Gets crlf} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation crlf
    set line "123456789ABCDE"	;# 14 char plus crlf
    puts -nonewline $f x	;# shift crlf across block boundary
    for {set i 0} {$i < 700} {incr i} {
	puts $f $line
    }
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation crlf 
    set c ""
    while {[gets $f line] >= 0} {
	append c $line\n
    }
    close $f
    string length $c
} [expr 700*15+1]
test io-31.32 {Tcl_Write crlf on block boundary, Tcl_Gets auto} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation crlf
    set line "123456789ABCDE"	;# 14 char plus crlf
    puts -nonewline $f x	;# shift crlf across block boundary
    for {set i 0} {$i < 700} {incr i} {
	puts $f $line
    }
    close $f
    set f [open $path(test1) r]
    fconfigure $f -translation auto
    set c ""
    while {[gets $f line] >= 0} {
	append c $line\n
    }
    close $f
    string length $c
} [expr 700*15+1]


# Test Tcl_Read and buffering.

test io-32.1 {Tcl_Read, channel not readable} {
    list [catch {read stdout} msg] $msg
} {1 {channel "stdout" wasn't opened for reading}}
test io-32.2 {Tcl_Read, zero byte count} {
    read stdin 0
} ""
test io-32.3 {Tcl_Read, negative byte count} {
    set f [open $path(longfile) r]
    set l [list [catch {read $f -1} msg] $msg]
    close $f
    set l
} {1 {bad argument "-1": should be "nonewline"}}
test io-32.4 {Tcl_Read, positive byte count} {
    set f [open $path(longfile) r]
    set x [read $f 1024]
    set s [string length $x]
    unset x
    close $f
    set s
} 1024
test io-32.5 {Tcl_Read, multiple buffers} {
    set f [open $path(longfile) r]
    fconfigure $f -buffersize 100
    set x [read $f 1024]
    set s [string length $x]
    unset x
    close $f
    set s
} 1024
test io-32.6 {Tcl_Read, very large read} {
    set f1 [open $path(longfile) r]
    set z [read $f1 1000000]
    close $f1
    set l [string length $z]
    set x ok
    set z [file size $path(longfile)]
    if {$z != $l} {
	set x broken
    }
    set x
} ok
test io-32.7 {Tcl_Read, nonblocking, file} {nonBlockFiles} {
    set f1 [open $path(longfile) r]
    fconfigure $f1 -blocking off
    set z [read $f1 20]
    close $f1
    set l [string length $z]
    set x ok
    if {$l != 20} {
	set x broken
    }
    set x
} ok
test io-32.8 {Tcl_Read, nonblocking, file} {nonBlockFiles} {
    set f1 [open $path(longfile) r]
    fconfigure $f1 -blocking off
    set z [read $f1 1000000]
    close $f1
    set x ok
    set l [string length $z]
    set z [file size $path(longfile)]
    if {$z != $l} {
	set x broken
    }
    set x
} ok
test io-32.9 {Tcl_Read, read to end of file} {
    set f1 [open $path(longfile) r]
    set z [read $f1]
    close $f1
    set l [string length $z]
    set x ok
    set z [file size $path(longfile)]
    if {$z != $l} {
	set x broken
    }
    set x
} ok
test io-32.10 {Tcl_Read from a pipe} {stdio} {
    removeFile pipe
    set f1 [open $path(pipe) w]
    puts $f1 {puts [gets stdin]}
    close $f1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
    puts $f1 hello
    flush $f1
    set x [read $f1]
    close $f1
    set x
} "hello\n"
test io-32.11 {Tcl_Read from a pipe} {stdio} {
    removeFile pipe
    set f1 [open $path(pipe) w]
    puts $f1 {puts [gets stdin]}
    puts $f1 {puts [gets stdin]}
    close $f1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
    puts $f1 hello
    flush $f1
    set x ""
    lappend x [read $f1 6]
    puts $f1 hello
    flush $f1
    lappend x [read $f1]
    close $f1
    set x
} {{hello
} {hello
}}
test io-32.12 {Tcl_Read, -nonewline} {
    removeFile test1
    set f1 [open $path(test1) w]
    puts $f1 hello
    puts $f1 bye
    close $f1
    set f1 [open $path(test1) r]
    set c [read -nonewline $f1]
    close $f1
    set c
} {hello
bye}
test io-32.13 {Tcl_Read, -nonewline} {
    removeFile test1
    set f1 [open $path(test1) w]
    puts $f1 hello
    puts $f1 bye
    close $f1
    set f1 [open $path(test1) r]
    set c [read -nonewline $f1]
    close $f1
    list [string length $c] $c
} {9 {hello
bye}}
test io-32.14 {Tcl_Read, reading in small chunks} {
    removeFile test1
    set f [open $path(test1) w]
    puts $f "Two lines: this one"
    puts $f "and this one"
    close $f
    set f [open $path(test1)]
    set x [list [read $f 1] [read $f 2] [read $f]]
    close $f
    set x
} {T wo { lines: this one
and this one
}}
test io-32.15 {Tcl_Read, asking for more input than available} {
    removeFile test1
    set f [open $path(test1) w]
    puts $f "Two lines: this one"
    puts $f "and this one"
    close $f
    set f [open $path(test1)]
    set x [read $f 100]
    close $f
    set x
} {Two lines: this one
and this one
}
test io-32.16 {Tcl_Read, read to end of file with -nonewline} {
    removeFile test1
    set f [open $path(test1) w]
    puts $f "Two lines: this one"
    puts $f "and this one"
    close $f
    set f [open $path(test1)]
    set x [read -nonewline $f]
    close $f
    set x
} {Two lines: this one
and this one}

# Test Tcl_Gets.

test io-33.1 {Tcl_Gets, reading what was written} {
    removeFile test1
    set f1 [open $path(test1) w]
    set y "first line"
    puts $f1 $y
    close $f1
    set f1 [open $path(test1) r]
    set x [gets $f1]
    set z ok
    if {"$x" != "$y"} {
	set z broken
    }
    close $f1
    set z
} ok
test io-33.2 {Tcl_Gets into variable} {
    set f1 [open $path(longfile) r]
    set c [gets $f1 x]
    set l [string length x]
    set z ok
    if {$l != $l} {
	set z broken
    }
    close $f1
    set z
} ok
test io-33.3 {Tcl_Gets from pipe} {stdio} {
    removeFile pipe
    set f1 [open $path(pipe) w]
    puts $f1 {puts [gets stdin]}
    close $f1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
    puts $f1 hello
    flush $f1
    set x [gets $f1]
    close $f1
    set z ok
    if {"$x" != "hello"} {
	set z broken
    }
    set z
} ok
test io-33.4 {Tcl_Gets with long line} {
    removeFile test3
    set f [open $path(test3) w]
    puts -nonewline $f "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
    puts -nonewline $f "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
    puts -nonewline $f "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
    puts -nonewline $f "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
    puts $f "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
    close $f
    set f [open $path(test3)]
    set x [gets $f]
    close $f
    set x
} {abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ}
test io-33.5 {Tcl_Gets with long line} {
    set f [open $path(test3)]
    set x [gets $f y]
    close $f
    list $x $y
} {260 abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ}
test io-33.6 {Tcl_Gets and end of file} {
    removeFile test3
    set f [open $path(test3) w]
    puts -nonewline $f "Test1\nTest2"
    close $f
    set f [open $path(test3)]
    set x {}
    set y {}
    lappend x [gets $f y] $y
    set y {}
    lappend x [gets $f y] $y
    set y {}
    lappend x [gets $f y] $y
    close $f
    set x
} {5 Test1 5 Test2 -1 {}}
test io-33.7 {Tcl_Gets and bad variable} {
    set f [open $path(test3) w]
    puts $f "Line 1"
    puts $f "Line 2"
    close $f
    catch {unset x}
    set x 24
    set f [open $path(test3) r]
    set result [list [catch {gets $f x(0)} msg] $msg]
    close $f
    set result
} {1 {can't set "x(0)": variable isn't array}}
test io-33.8 {Tcl_Gets, exercising double buffering} {
    set f [open $path(test3) w]
    fconfigure $f -translation lf -eofchar {}
    set x ""
    for {set y 0} {$y < 99} {incr y} {set x "a$x"}
    for {set y 0} {$y < 100} {incr y} {puts $f $x}
    close $f
    set f [open $path(test3) r]
    fconfigure $f -translation lf
    for {set y 0} {$y < 100} {incr y} {gets $f}
    close $f
    set y
} 100
test io-33.9 {Tcl_Gets, exercising double buffering} {
    set f [open $path(test3) w]
    fconfigure $f -translation lf -eofchar {}
    set x ""
    for {set y 0} {$y < 99} {incr y} {set x "a$x"}
    for {set y 0} {$y < 200} {incr y} {puts $f $x}
    close $f
    set f [open $path(test3) r]
    fconfigure $f -translation lf
    for {set y 0} {$y < 200} {incr y} {gets $f}
    close $f
    set y
} 200
test io-33.10 {Tcl_Gets, exercising double buffering} {
    set f [open $path(test3) w]
    fconfigure $f -translation lf -eofchar {}
    set x ""
    for {set y 0} {$y < 99} {incr y} {set x "a$x"}
    for {set y 0} {$y < 300} {incr y} {puts $f $x}
    close $f
    set f [open $path(test3) r]
    fconfigure $f -translation lf
    for {set y 0} {$y < 300} {incr y} {gets $f}
    close $f
    set y
} 300

# Test Tcl_Seek and Tcl_Tell.

test io-34.1 {Tcl_Seek to current position at start of file} {
    set f1 [open $path(longfile) r]
    seek $f1 0 current
    set c [tell $f1]
    close $f1
    set c
} 0
test io-34.2 {Tcl_Seek to offset from start} {
    removeFile test1
    set f1 [open $path(test1) w]
    fconfigure $f1 -translation lf -eofchar {}
    puts $f1 "abcdefghijklmnopqrstuvwxyz"
    puts $f1 "abcdefghijklmnopqrstuvwxyz"
    close $f1
    set f1 [open $path(test1) r]
    seek $f1 10 start
    set c [tell $f1]
    close $f1
    set c
} 10
test io-34.3 {Tcl_Seek to end of file} {
    removeFile test1
    set f1 [open $path(test1) w]
    fconfigure $f1 -translation lf -eofchar {}
    puts $f1 "abcdefghijklmnopqrstuvwxyz"
    puts $f1 "abcdefghijklmnopqrstuvwxyz"
    close $f1
    set f1 [open $path(test1) r]
    seek $f1 0 end
    set c [tell $f1]
    close $f1
    set c
} 54
test io-34.4 {Tcl_Seek to offset from end of file} {
    removeFile test1
    set f1 [open $path(test1) w]
    fconfigure $f1 -translation lf -eofchar {}
    puts $f1 "abcdefghijklmnopqrstuvwxyz"
    puts $f1 "abcdefghijklmnopqrstuvwxyz"
    close $f1
    set f1 [open $path(test1) r]
    seek $f1 -10 end
    set c [tell $f1]
    close $f1
    set c
} 44
test io-34.5 {Tcl_Seek to offset from current position} {
    removeFile test1
    set f1 [open $path(test1) w]
    fconfigure $f1 -translation lf -eofchar {}
    puts $f1 "abcdefghijklmnopqrstuvwxyz"
    puts $f1 "abcdefghijklmnopqrstuvwxyz"
    close $f1
    set f1 [open $path(test1) r]
    seek $f1 10 current
    seek $f1 10 current
    set c [tell $f1]
    close $f1
    set c
} 20
test io-34.6 {Tcl_Seek to offset from end of file} {
    removeFile test1
    set f1 [open $path(test1) w]
    fconfigure $f1 -translation lf -eofchar {}
    puts $f1 "abcdefghijklmnopqrstuvwxyz"
    puts $f1 "abcdefghijklmnopqrstuvwxyz"
    close $f1
    set f1 [open $path(test1) r]
    seek $f1 -10 end
    set c [tell $f1]
    set r [read $f1]
    close $f1
    list $c $r
} {44 {rstuvwxyz
}}
test io-34.7 {Tcl_Seek to offset from end of file, then to current position} {
    removeFile test1
    set f1 [open $path(test1) w]
    fconfigure $f1 -translation lf -eofchar {}
    puts $f1 "abcdefghijklmnopqrstuvwxyz"
    puts $f1 "abcdefghijklmnopqrstuvwxyz"
    close $f1
    set f1 [open $path(test1) r]
    seek $f1 -10 end
    set c1 [tell $f1]
    set r1 [read $f1 5]
    seek $f1 0 current
    set c2 [tell $f1]
    close $f1
    list $c1 $r1 $c2
} {44 rstuv 49}
test io-34.8 {Tcl_Seek on pipes: not supported} {stdio} {
    set f1 [open "|[list [interpreter]]" r+]
    set x [list [catch {seek $f1 0 current} msg] $msg]
    close $f1
    regsub {".*":} $x {"":} x
    string tolower $x
} {1 {error during seek on "": invalid argument}}
test io-34.9 {Tcl_Seek, testing buffered input flushing} {
    removeFile test3
    set f [open $path(test3) w]
    fconfigure $f -eofchar {}
    puts -nonewline $f "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
    close $f
    set f [open $path(test3) RDWR]
    set x [read $f 1]
    seek $f 3
    lappend x [read $f 1]
    seek $f 0 start
    lappend x [read $f 1]
    seek $f 10 current
    lappend x [read $f 1]
    seek $f -2 end
    lappend x [read $f 1]
    seek $f 50 end
    lappend x [read $f 1]
    seek $f 1
    lappend x [read $f 1]
    close $f
    set x
} {a d a l Y {} b}

set path(test3) [makeFile {} test3]

test io-34.10 {Tcl_Seek testing flushing of buffered input} {
    set f [open $path(test3) w]
    fconfigure $f -translation lf
    puts $f xyz\n123
    close $f
    set f [open $path(test3) r+]
    fconfigure $f -translation lf
    set x [gets $f]
    seek $f 0 current
    puts $f 456
    close $f
    list $x [viewFile test3]
} "xyz {xyz
456}"
test io-34.11 {Tcl_Seek testing flushing of buffered output} {
    set f [open $path(test3) w]
    puts $f xyz\n123
    close $f
    set f [open $path(test3) w+]
    puts $f xyzzy
    seek $f 2
    set x [gets $f]
    close $f
    list $x [viewFile test3]
} "zzy xyzzy"
test io-34.12 {Tcl_Seek testing combination of write, seek back and read} {
    set f [open $path(test3) w]
    fconfigure $f -translation lf -eofchar {}
    puts $f xyz\n123
    close $f
    set f [open $path(test3) a+]
    fconfigure $f -translation lf -eofchar {}
    puts $f xyzzy
    flush $f
    set x [tell $f]
    seek $f -4 cur
    set y [gets $f]
    close $f
    list $x [viewFile test3] $y
} {14 {xyz
123
xyzzy} zzy}
test io-34.13 {Tcl_Tell at start of file} {
    removeFile test1
    set f1 [open $path(test1) w]
    set p [tell $f1]
    close $f1
    set p
} 0
test io-34.14 {Tcl_Tell after seek to end of file} {
    removeFile test1
    set f1 [open $path(test1) w]
    fconfigure $f1 -translation lf -eofchar {}
    puts $f1 "abcdefghijklmnopqrstuvwxyz"
    puts $f1 "abcdefghijklmnopqrstuvwxyz"
    close $f1
    set f1 [open $path(test1) r]
    seek $f1 0 end
    set c1 [tell $f1]
    close $f1
    set c1
} 54
test io-34.15 {Tcl_Tell combined with seeking} {
    removeFile test1
    set f1 [open $path(test1) w]
    fconfigure $f1 -translation lf -eofchar {}
    puts $f1 "abcdefghijklmnopqrstuvwxyz"
    puts $f1 "abcdefghijklmnopqrstuvwxyz"
    close $f1
    set f1 [open $path(test1) r]
    seek $f1 10 start
    set c1 [tell $f1]
    seek $f1 10 current
    set c2 [tell $f1]
    close $f1
    list $c1 $c2
} {10 20}
test io-34.16 {Tcl_tell on pipe: always -1} {stdio} {
    set f1 [open "|[list [interpreter]]" r+]
    set c [tell $f1]
    close $f1
    set c
} -1
test io-34.17 {Tcl_Tell on pipe: always -1} {stdio} {
    set f1 [open "|[list [interpreter]]" r+]
    puts $f1 {puts hello}
    flush $f1
    set c [tell $f1]
    gets $f1
    close $f1
    set c
} -1
test io-34.18 {Tcl_Tell combined with seeking and reading} {
    removeFile test2
    set f [open $path(test2) w]
    fconfigure $f -translation lf -eofchar {}
    puts -nonewline $f "line1\nline2\nline3\nline4\nline5\n"
    close $f
    set f [open $path(test2)]
    fconfigure $f -translation lf
    set x [tell $f]
    read $f 3
    lappend x [tell $f]
    seek $f 2
    lappend x [tell $f]
    seek $f 10 current
    lappend x [tell $f]
    seek $f 0 end
    lappend x [tell $f]
    close $f
    set x
} {0 3 2 12 30}
test io-34.19 {Tcl_Tell combined with opening in append mode} {
    set f [open $path(test3) w]
    fconfigure $f -translation lf -eofchar {}
    puts $f "abcdefghijklmnopqrstuvwxyz"
    puts $f "abcdefghijklmnopqrstuvwxyz"
    close $f
    set f [open $path(test3) a]
    set c [tell $f]
    close $f
    set c
} 54
test io-34.20 {Tcl_Tell combined with writing} {
    set f [open $path(test3) w]
    set l ""
    seek $f 29 start
    lappend l [tell $f]
    puts -nonewline $f a
    seek $f 39 start
    lappend l [tell $f]
    puts -nonewline $f a
    lappend l [tell $f]
    seek $f 407 end
    lappend l [tell $f]
    close $f
    set l
} {29 39 40 447}
test io-34.21 {Tcl_Seek and Tcl_Tell on large files} {largefileSupport} {
    removeFile test3
    set f [open $path(test3) w]
    fconfigure $f -encoding binary
    set l ""
    lappend l [tell $f]
    puts -nonewline $f abcdef
    lappend l [tell $f]
    flush $f
    lappend l [tell $f]
    # 4GB offset!
    seek $f 0x100000000
    lappend l [tell $f]
    puts -nonewline $f abcdef
    lappend l [tell $f]
    close $f
    lappend l [file size $f]
    # truncate...
    close [open $path(test3) w]
    lappend l [file size $f]
    set l
} {0 6 6 4294967296 4294967302 4294967302 0}

# Test Tcl_Eof

test io-35.1 {Tcl_Eof} {
    removeFile test1
    set f [open $path(test1) w]
    puts $f hello
    puts $f hello
    close $f
    set f [open $path(test1)]
    set x [eof $f]
    lappend x [eof $f]
    gets $f
    lappend x [eof $f]
    gets $f
    lappend x [eof $f]
    gets $f
    lappend x [eof $f]
    lappend x [eof $f]
    close $f
    set x
} {0 0 0 0 1 1}
test io-35.2 {Tcl_Eof with pipe} {stdio} {
    removeFile pipe
    set f1 [open $path(pipe) w]
    puts $f1 {gets stdin}
    puts $f1 {puts hello}
    close $f1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
    puts $f1 hello
    set x [eof $f1]
    flush $f1
    lappend x [eof $f1]
    gets $f1
    lappend x [eof $f1]
    gets $f1
    lappend x [eof $f1]
    close $f1
    set x
} {0 0 0 1}
test io-35.3 {Tcl_Eof with pipe} {stdio} {
    removeFile pipe
    set f1 [open $path(pipe) w]
    puts $f1 {gets stdin}
    puts $f1 {puts hello}
    close $f1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
    puts $f1 hello
    set x [eof $f1]
    flush $f1
    lappend x [eof $f1]
    gets $f1
    lappend x [eof $f1]
    gets $f1
    lappend x [eof $f1]
    gets $f1
    lappend x [eof $f1]
    gets $f1
    lappend x [eof $f1]
    close $f1
    set x
} {0 0 0 1 1 1}
test io-35.4 {Tcl_Eof, eof detection on nonblocking file} {nonBlockFiles} {
    removeFile test1
    set f [open $path(test1) w]
    close $f
    set f [open $path(test1) r]
    fconfigure $f -blocking off
    set l ""
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {{} 1}
test io-35.5 {Tcl_Eof, eof detection on nonblocking pipe} {stdio} {
    removeFile pipe
    set f [open $path(pipe) w]
    puts $f {
	exit
    }
    close $f
    set f [open "|[list [interpreter] $path(pipe)]" r]
    set l ""
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {{} 1}
test io-35.6 {Tcl_Eof, eof char, lf write, auto read} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf -eofchar \x1a
    puts $f abc\ndef
    close $f
    set s [file size $path(test1)]
    set f [open $path(test1) r]
    fconfigure $f -translation auto -eofchar \x1a
    set l [string length [read $f]]
    set e [eof $f]
    close $f
    list $s $l $e
} {9 8 1}
test io-35.7 {Tcl_Eof, eof char, lf write, lf read} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf -eofchar \x1a
    puts $f abc\ndef
    close $f
    set s [file size $path(test1)]
    set f [open $path(test1) r]
    fconfigure $f -translation lf -eofchar \x1a
    set l [string length [read $f]]
    set e [eof $f]
    close $f
    list $s $l $e
} {9 8 1}
test io-35.8 {Tcl_Eof, eof char, cr write, auto read} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation cr -eofchar \x1a
    puts $f abc\ndef
    close $f
    set s [file size $path(test1)]
    set f [open $path(test1) r]
    fconfigure $f -translation auto -eofchar \x1a
    set l [string length [read $f]]
    set e [eof $f]
    close $f
    list $s $l $e
} {9 8 1}
test io-35.9 {Tcl_Eof, eof char, cr write, cr read} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation cr -eofchar \x1a
    puts $f abc\ndef
    close $f
    set s [file size $path(test1)]
    set f [open $path(test1) r]
    fconfigure $f -translation cr -eofchar \x1a
    set l [string length [read $f]]
    set e [eof $f]
    close $f
    list $s $l $e
} {9 8 1}
test io-35.10 {Tcl_Eof, eof char, crlf write, auto read} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation crlf -eofchar \x1a
    puts $f abc\ndef
    close $f
    set s [file size $path(test1)]
    set f [open $path(test1) r]
    fconfigure $f -translation auto -eofchar \x1a
    set l [string length [read $f]]
    set e [eof $f]
    close $f
    list $s $l $e
} {11 8 1}
test io-35.11 {Tcl_Eof, eof char, crlf write, crlf read} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation crlf -eofchar \x1a
    puts $f abc\ndef
    close $f
    set s [file size $path(test1)]
    set f [open $path(test1) r]
    fconfigure $f -translation crlf -eofchar \x1a
    set l [string length [read $f]]
    set e [eof $f]
    close $f
    list $s $l $e
} {11 8 1}
test io-35.12 {Tcl_Eof, eof char in middle, lf write, auto read} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf -eofchar {}
    set i [format abc\ndef\n%cqrs\nuvw 26]
    puts $f $i
    close $f
    set c [file size $path(test1)]
    set f [open $path(test1) r]
    fconfigure $f -translation auto -eofchar \x1a
    set l [string length [read $f]]
    set e [eof $f]
    close $f
    list $c $l $e
} {17 8 1}
test io-35.13 {Tcl_Eof, eof char in middle, lf write, lf read} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf -eofchar {}
    set i [format abc\ndef\n%cqrs\nuvw 26]
    puts $f $i
    close $f
    set c [file size $path(test1)]
    set f [open $path(test1) r]
    fconfigure $f -translation lf -eofchar \x1a
    set l [string length [read $f]]
    set e [eof $f]
    close $f
    list $c $l $e
} {17 8 1}
test io-35.14 {Tcl_Eof, eof char in middle, cr write, auto read} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation cr -eofchar {}
    set i [format abc\ndef\n%cqrs\nuvw 26]
    puts $f $i
    close $f
    set c [file size $path(test1)]
    set f [open $path(test1) r]
    fconfigure $f -translation auto -eofchar \x1a
    set l [string length [read $f]]
    set e [eof $f]
    close $f
    list $c $l $e
} {17 8 1}
test io-35.15 {Tcl_Eof, eof char in middle, cr write, cr read} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation cr -eofchar {}
    set i [format abc\ndef\n%cqrs\nuvw 26]
    puts $f $i
    close $f
    set c [file size $path(test1)]
    set f [open $path(test1) r]
    fconfigure $f -translation cr -eofchar \x1a
    set l [string length [read $f]]
    set e [eof $f]
    close $f
    list $c $l $e
} {17 8 1}
test io-35.16 {Tcl_Eof, eof char in middle, crlf write, auto read} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation crlf -eofchar {}
    set i [format abc\ndef\n%cqrs\nuvw 26]
    puts $f $i
    close $f
    set c [file size $path(test1)]
    set f [open $path(test1) r]
    fconfigure $f -translation auto -eofchar \x1a
    set l [string length [read $f]]
    set e [eof $f]
    close $f
    list $c $l $e
} {21 8 1}
test io-35.17 {Tcl_Eof, eof char in middle, crlf write, crlf read} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation crlf -eofchar {}
    set i [format abc\ndef\n%cqrs\nuvw 26]
    puts $f $i
    close $f
    set c [file size $path(test1)]
    set f [open $path(test1) r]
    fconfigure $f -translation crlf -eofchar \x1a
    set l [string length [read $f]]
    set e [eof $f]
    close $f
    list $c $l $e
} {21 8 1}

# Test Tcl_InputBlocked

test io-36.1 {Tcl_InputBlocked on nonblocking pipe} {stdio} {
    set f1 [open "|[list [interpreter]]" r+]
    puts $f1 {puts hello_from_pipe}
    flush $f1
    gets $f1
    fconfigure $f1 -blocking off -buffering full
    puts $f1 {puts hello}
    set x ""
    lappend x [gets $f1]
    lappend x [fblocked $f1]
    flush $f1
    after 200
    lappend x [gets $f1]
    lappend x [fblocked $f1]
    lappend x [gets $f1]
    lappend x [fblocked $f1]
    close $f1
    set x
} {{} 1 hello 0 {} 1}
test io-36.2 {Tcl_InputBlocked on blocking pipe} {stdio} {
    set f1 [open "|[list [interpreter]]" r+]
    fconfigure $f1 -buffering line
    puts $f1 {puts hello_from_pipe}
    set x ""
    lappend x [gets $f1]
    lappend x [fblocked $f1]
    puts $f1 {exit}
    lappend x [gets $f1]
    lappend x [fblocked $f1]
    lappend x [eof $f1]
    close $f1
    set x
} {hello_from_pipe 0 {} 0 1}
test io-36.3 {Tcl_InputBlocked vs files, short read} {
    removeFile test1
    set f [open $path(test1) w]
    puts $f abcdefghijklmnop
    close $f
    set f [open $path(test1) r]
    set l ""
    lappend l [fblocked $f]
    lappend l [read $f 3]
    lappend l [fblocked $f]
    lappend l [read -nonewline $f]
    lappend l [fblocked $f]
    lappend l [eof $f]
    close $f
    set l
} {0 abc 0 defghijklmnop 0 1}
test io-36.4 {Tcl_InputBlocked vs files, event driven read} {
    proc in {f} {
        variable l
        variable x
	lappend l [read $f 3]
	if {[eof $f]} {lappend l eof; close $f; set x done}
    }
    removeFile test1
    set f [open $path(test1) w]
    puts $f abcdefghijklmnop
    close $f
    set f [open $path(test1) r]
    set l ""
    fileevent $f readable [namespace code [list in $f]]
    variable x
    vwait [namespace which -variable x]
    set l
} {abc def ghi jkl mno {p
} eof}
test io-36.5 {Tcl_InputBlocked vs files, short read, nonblocking} {nonBlockFiles} {
    removeFile test1
    set f [open $path(test1) w]
    puts $f abcdefghijklmnop
    close $f
    set f [open $path(test1) r]
    fconfigure $f -blocking off
    set l ""
    lappend l [fblocked $f]
    lappend l [read $f 3]
    lappend l [fblocked $f]
    lappend l [read -nonewline $f]
    lappend l [fblocked $f]
    lappend l [eof $f]
    close $f
    set l
} {0 abc 0 defghijklmnop 0 1}
test io-36.6 {Tcl_InputBlocked vs files, event driven read} {nonBlockFiles} {
    proc in {f} {
        variable l
        variable x
	lappend l [read $f 3]
	if {[eof $f]} {lappend l eof; close $f; set x done}
    }
    removeFile test1
    set f [open $path(test1) w]
    puts $f abcdefghijklmnop
    close $f
    set f [open $path(test1) r]
    fconfigure $f -blocking off
    set l ""
    fileevent $f readable [namespace code [list in $f]]
    variable x
    vwait [namespace which -variable x]
    set l
} {abc def ghi jkl mno {p
} eof}

# Test Tcl_InputBuffered

test io-37.1 {Tcl_InputBuffered} {testchannel} {
    set f [open $path(longfile) r]
    fconfigure $f -buffersize 4096
    read $f 3
    set l ""
    lappend l [testchannel inputbuffered $f]
    lappend l [tell $f]
    close $f
    set l
} {4093 3}
test io-37.2 {Tcl_InputBuffered, test input flushing on seek} {testchannel} {
    set f [open $path(longfile) r]
    fconfigure $f -buffersize 4096
    read $f 3
    set l ""
    lappend l [testchannel inputbuffered $f]
    lappend l [tell $f]
    seek $f 0 current
    lappend l [testchannel inputbuffered $f]
    lappend l [tell $f]
    close $f
    set l
} {4093 3 0 3}

# Test Tcl_SetChannelBufferSize, Tcl_GetChannelBufferSize

test io-38.1 {Tcl_GetChannelBufferSize, default buffer size} {
    set f [open $path(longfile) r]
    set s [fconfigure $f -buffersize]
    close $f
    set s
} 4096
test io-38.2 {Tcl_SetChannelBufferSize, Tcl_GetChannelBufferSize} {
    set f [open $path(longfile) r]
    set l ""
    lappend l [fconfigure $f -buffersize]
    fconfigure $f -buffersize 10000
    lappend l [fconfigure $f -buffersize]
    fconfigure $f -buffersize 1
    lappend l [fconfigure $f -buffersize]
    fconfigure $f -buffersize -1
    lappend l [fconfigure $f -buffersize]
    fconfigure $f -buffersize 0
    lappend l [fconfigure $f -buffersize]
    fconfigure $f -buffersize 100000
    lappend l [fconfigure $f -buffersize]
    fconfigure $f -buffersize 10000000
    lappend l [fconfigure $f -buffersize]
    close $f
    set l
} {4096 10000 4096 4096 4096 100000 4096}

test io-38.3 {Tcl_SetChannelBufferSize, changing buffersize between reads} {
    # This test crashes the interp if Bug #427196 is not fixed

    set chan [open [info script] r]
    fconfigure $chan -buffersize 10
    set var [read $chan 2]
    fconfigure $chan -buffersize 32
    append var [read $chan]
    close $chan
} {}

# Test Tcl_SetChannelOption, Tcl_GetChannelOption

test io-39.1 {Tcl_GetChannelOption} {
    removeFile test1
    set f1 [open $path(test1) w]
    set x [fconfigure $f1 -blocking]
    close $f1
    set x
} 1
#
# Test 17.2 was removed.
#
test io-39.2 {Tcl_GetChannelOption} {
    removeFile test1
    set f1 [open $path(test1) w]
    set x [fconfigure $f1 -buffering]
    close $f1
    set x
} full
test io-39.3 {Tcl_GetChannelOption} {
    removeFile test1
    set f1 [open $path(test1) w]
    fconfigure $f1 -buffering line
    set x [fconfigure $f1 -buffering]
    close $f1
    set x
} line
test io-39.4 {Tcl_GetChannelOption, Tcl_SetChannelOption} {
    removeFile test1
    set f1 [open $path(test1) w]
    set l ""
    lappend l [fconfigure $f1 -buffering]
    fconfigure $f1 -buffering line
    lappend l [fconfigure $f1 -buffering]
    fconfigure $f1 -buffering none
    lappend l [fconfigure $f1 -buffering]
    fconfigure $f1 -buffering line
    lappend l [fconfigure $f1 -buffering]
    fconfigure $f1 -buffering full
    lappend l [fconfigure $f1 -buffering]
    close $f1
    set l
} {full line none line full}
test io-39.5 {Tcl_GetChannelOption, invariance} {
    removeFile test1
    set f1 [open $path(test1) w]
    set l ""
    lappend l [fconfigure $f1 -buffering]
    lappend l [list [catch {fconfigure $f1 -buffering green} msg] $msg]
    lappend l [fconfigure $f1 -buffering]
    close $f1
    set l
} {full {1 {bad value for -buffering: must be one of full, line, or none}} full}
test io-39.6 {Tcl_SetChannelOption, multiple options} {
    removeFile test1
    set f1 [open $path(test1) w]
    fconfigure $f1 -translation lf -buffering line
    puts $f1 hello
    puts $f1 bye
    set x [file size $path(test1)]
    close $f1
    set x
} 10
test io-39.7 {Tcl_SetChannelOption, buffering, translation} {
    removeFile test1
    set f1 [open $path(test1) w]
    fconfigure $f1 -translation lf
    puts $f1 hello
    puts $f1 bye
    set x ""
    fconfigure $f1 -buffering line
    lappend x [file size $path(test1)]
    puts $f1 really_bye
    lappend x [file size $path(test1)]
    close $f1
    set x
} {0 21}
test io-39.8 {Tcl_SetChannelOption, different buffering options} {
    removeFile test1
    set f1 [open $path(test1) w]
    set l ""
    fconfigure $f1 -translation lf -buffering none -eofchar {}
    puts -nonewline $f1 hello
    lappend l [file size $path(test1)]
    puts -nonewline $f1 hello
    lappend l [file size $path(test1)]
    fconfigure $f1 -buffering full
    puts -nonewline $f1 hello
    lappend l [file size $path(test1)]
    fconfigure $f1 -buffering none
    lappend l [file size $path(test1)]
    puts -nonewline $f1 hello
    lappend l [file size $path(test1)]
    close $f1
    lappend l [file size $path(test1)]
    set l
} {5 10 10 10 20 20}
test io-39.9 {Tcl_SetChannelOption, blocking mode} {nonBlockFiles} {
    removeFile test1
    set f1 [open $path(test1) w]
    close $f1
    set f1 [open $path(test1) r]
    set x ""
    lappend x [fconfigure $f1 -blocking]
    fconfigure $f1 -blocking off
    lappend x [fconfigure $f1 -blocking]
    lappend x [gets $f1]
    lappend x [read $f1 1000]
    lappend x [fblocked $f1]
    lappend x [eof $f1]
    close $f1
    set x
} {1 0 {} {} 0 1}
test io-39.10 {Tcl_SetChannelOption, blocking mode} {stdio} {
    removeFile pipe
    set f1 [open $path(pipe) w]
    puts $f1 {
	gets stdin
	after 100
	puts hi
	gets stdin
    }
    close $f1
    set x ""
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
    fconfigure $f1 -blocking off -buffering line
    lappend x [fconfigure $f1 -blocking]
    lappend x [gets $f1]
    lappend x [fblocked $f1]
    fconfigure $f1 -blocking on
    puts $f1 hello
    fconfigure $f1 -blocking off
    lappend x [gets $f1]
    lappend x [fblocked $f1]
    fconfigure $f1 -blocking on
    puts $f1 bye
    fconfigure $f1 -blocking off
    lappend x [gets $f1]
    lappend x [fblocked $f1]
    fconfigure $f1 -blocking on
    lappend x [fconfigure $f1 -blocking]
    lappend x [gets $f1]
    lappend x [fblocked $f1]
    lappend x [eof $f1]
    lappend x [gets $f1]
    lappend x [eof $f1]
    close $f1
    set x
} {0 {} 1 {} 1 {} 1 1 hi 0 0 {} 1}
test io-39.11 {Tcl_SetChannelOption, Tcl_GetChannelOption, buffer size} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -buffersize -10
    set x [fconfigure $f -buffersize]
    close $f
    set x
} 4096
test io-39.12 {Tcl_SetChannelOption, Tcl_GetChannelOption buffer size} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -buffersize 10000000
    set x [fconfigure $f -buffersize]
    close $f
    set x
} 4096
test io-39.13 {Tcl_SetChannelOption, Tcl_GetChannelOption, buffer size} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -buffersize 40000
    set x [fconfigure $f -buffersize]
    close $f
    set x
} 40000
test io-39.14 {Tcl_SetChannelOption: -encoding, binary & utf-8} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -encoding {} 
    puts -nonewline $f \xe7\x89\xa6
    close $f
    set f [open $path(test1) r]
    fconfigure $f -encoding utf-8
    set x [read $f]
    close $f
    set x
} \u7266
test io-39.15 {Tcl_SetChannelOption: -encoding, binary & utf-8} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -encoding binary
    puts -nonewline $f \xe7\x89\xa6
    close $f
    set f [open $path(test1) r]
    fconfigure $f -encoding utf-8
    set x [read $f]
    close $f
    set x
} \u7266
test io-39.16 {Tcl_SetChannelOption: -encoding, errors} {
    removeFile test1
    set f [open $path(test1) w]
    set result [list [catch {fconfigure $f -encoding foobar} msg] $msg]
    close $f
    set result
} {1 {unknown encoding "foobar"}}
test io-39.17 {Tcl_SetChannelOption: -encoding, clearing CHANNEL_NEED_MORE_DATA} {stdio} {
    set f [open "|[list [interpreter] $path(cat)]" r+]
    fconfigure $f -encoding binary
    puts -nonewline $f "\xe7"
    flush $f
    fconfigure $f -encoding utf-8 -blocking 0
    variable x {}
    fileevent $f readable [namespace code { lappend x [read $f] }]
    vwait [namespace which -variable x]
    after 300 [namespace code { lappend x timeout }]
    vwait [namespace which -variable x]
    fconfigure $f -encoding utf-8
    vwait [namespace which -variable x]
    after 300 [namespace code { lappend x timeout }]
    vwait [namespace which -variable x]
    fconfigure $f -encoding binary
    vwait [namespace which -variable x]
    after 300 [namespace code { lappend x timeout }]
    vwait [namespace which -variable x]
    close $f
    set x
} "{} timeout {} timeout \xe7 timeout"

test io-39.18 {Tcl_SetChannelOption, setting read mode independently} \
	{socket} {
    proc accept {s a p} {close $s}
    set s1 [socket -server [namespace code accept] 0]
    set port [lindex [fconfigure $s1 -sockname] 2]
    set s2 [socket 127.0.0.1 $port]
    update
    fconfigure $s2 -translation {auto lf}
    set modes [fconfigure $s2 -translation]
    close $s1
    close $s2
    set modes
} {auto lf}
test io-39.19 {Tcl_SetChannelOption, setting read mode independently} \
	{socket} {
    proc accept {s a p} {close $s}
    set s1 [socket -server [namespace code accept] 0]
    set port [lindex [fconfigure $s1 -sockname] 2]
    set s2 [socket 127.0.0.1 $port]
    update
    fconfigure $s2 -translation {auto crlf}
    set modes [fconfigure $s2 -translation]
    close $s1
    close $s2
    set modes
} {auto crlf}
test io-39.20 {Tcl_SetChannelOption, setting read mode independently} \
	{socket} {
    proc accept {s a p} {close $s}
    set s1 [socket -server [namespace code accept] 0]
    set port [lindex [fconfigure $s1 -sockname] 2]
    set s2 [socket 127.0.0.1 $port]
    update
    fconfigure $s2 -translation {auto cr}
    set modes [fconfigure $s2 -translation]
    close $s1
    close $s2
    set modes
} {auto cr}
test io-39.21 {Tcl_SetChannelOption, setting read mode independently} \
	{socket} {
    proc accept {s a p} {close $s}
    set s1 [socket -server [namespace code accept] 0]
    set port [lindex [fconfigure $s1 -sockname] 2]
    set s2 [socket 127.0.0.1 $port]
    update
    fconfigure $s2 -translation {auto auto}
    set modes [fconfigure $s2 -translation]
    close $s1
    close $s2
    set modes
} {auto crlf}

test io-39.22 {Tcl_SetChannelOption, invariance} {unixOnly} {
    removeFile test1
    set f1 [open $path(test1) w+]
    set l ""
    lappend l [fconfigure $f1 -eofchar]
    fconfigure $f1 -eofchar {ON GO}
    lappend l [fconfigure $f1 -eofchar]
    fconfigure $f1 -eofchar D
    lappend l [fconfigure $f1 -eofchar]
    close $f1
    set l
} {{{} {}} {O G} {D D}}

test io-39.22a {Tcl_SetChannelOption, invariance} {
    removeFile test1
    set f1 [open $path(test1) w+]
    set l [list]
    fconfigure $f1 -eofchar {ON GO}
    lappend l [fconfigure $f1 -eofchar]
    fconfigure $f1 -eofchar D
    lappend l [fconfigure $f1 -eofchar]
    lappend l [list [catch {fconfigure $f1 -eofchar {1 2 3}} msg] $msg]
    close $f1
    set l
} {{O G} {D D} {1 {bad value for -eofchar: should be a list of zero, one, or two elements}}}


test io-39.23 {Tcl_GetChannelOption, server socket is not readable or
        writeable, it should still have valid -eofchar and -translation options } {
    set l [list]
    set sock [socket -server [namespace code accept] 0]
    lappend l [fconfigure $sock -eofchar] [fconfigure $sock -translation]
    close $sock
    set l
} {{{}} auto}
test io-39.24 {Tcl_SetChannelOption, server socket is not readable or
        writable so we can't change -eofchar or -translation } {
    set l [list]
    set sock [socket -server [namespace code accept] 0]
    fconfigure $sock -eofchar D -translation lf
    lappend l [fconfigure $sock -eofchar] [fconfigure $sock -translation]
    close $sock
    set l
} {{{}} auto}

test io-40.1 {POSIX open access modes: RDWR} {
    removeFile test3
    set f [open $path(test3) w]
    puts $f xyzzy
    close $f
    set f [open $path(test3) RDWR]
    puts -nonewline $f "ab"
    seek $f 0 current
    set x [gets $f]
    close $f
    set f [open $path(test3) r]
    lappend x [gets $f]
    close $f
    set x
} {zzy abzzy}
test io-40.2 {POSIX open access modes: CREAT} {unixOnly} {
    removeFile test3
    set f [open $path(test3) {WRONLY CREAT} 0600]
    file stat $path(test3) stats
    set x [format "0%o" [expr $stats(mode)&0777]]
    puts $f "line 1"
    close $f
    set f [open $path(test3) r]
    lappend x [gets $f]
    close $f
    set x
} {0600 {line 1}}

# some tests can only be run is umask is 2
# if "umask" cannot be run, the tests will be skipped.
catch {testConstraint umask2 [expr {[exec umask] == 2}]}

test io-40.3 {POSIX open access modes: CREAT} {unixOnly umask2} {
    # This test only works if your umask is 2, like ouster's.
    removeFile test3
    set f [open $path(test3) {WRONLY CREAT}]
    close $f
    file stat test3 stats
    format "0%o" [expr $stats(mode)&0777]
} 0664
test io-40.4 {POSIX open access modes: CREAT} {
    removeFile test3
    set f [open $path(test3) w]
    fconfigure $f -eofchar {}
    puts $f xyzzy
    close $f
    set f [open $path(test3) {WRONLY CREAT}]
    fconfigure $f -eofchar {}
    puts -nonewline $f "ab"
    close $f
    set f [open $path(test3) r]
    set x [gets $f]
    close $f
    set x
} abzzy
test io-40.5 {POSIX open access modes: APPEND} {
    removeFile test3
    set f [open $path(test3) w]
    fconfigure $f -translation lf -eofchar {}
    puts $f xyzzy
    close $f
    set f [open $path(test3) {WRONLY APPEND}]
    fconfigure $f -translation lf
    puts $f "new line"
    seek $f 0
    puts $f "abc"
    close $f
    set f [open $path(test3) r]
    fconfigure $f -translation lf
    set x ""
    seek $f 6 current
    lappend x [gets $f]
    lappend x [gets $f]
    close $f
    set x
} {{new line} abc}
test io-40.6 {POSIX open access modes: EXCL} {
    removeFile test3
    set f [open $path(test3) w]
    puts $f xyzzy
    close $f
    set msg [list [catch {open $path(test3) {WRONLY CREAT EXCL}} msg] $msg]
    regsub " already " $msg " " msg
    regsub [file join {} $path(test3)] $msg "test3" msg
    string tolower $msg
} {1 {couldn't open "test3": file exists}}
test io-40.7 {POSIX open access modes: EXCL} {
    removeFile test3
    set f [open $path(test3) {WRONLY CREAT EXCL}]
    fconfigure $f -eofchar {}
    puts $f "A test line"
    close $f
    viewFile test3
} {A test line}
test io-40.8 {POSIX open access modes: TRUNC} {
    removeFile test3
    set f [open $path(test3) w]
    puts $f xyzzy
    close $f
    set f [open $path(test3) {WRONLY TRUNC}]
    puts $f abc
    close $f
    set f [open $path(test3) r]
    set x [gets $f]
    close $f
    set x
} abc
test io-40.9 {POSIX open access modes: NONBLOCK} {nonPortable macOrUnix} {
    removeFile test3
    set f [open $path(test3) {WRONLY NONBLOCK CREAT}]
    puts $f "NONBLOCK test"
    close $f
    set f [open $path(test3) r]
    set x [gets $f]
    close $f
    set x
} {NONBLOCK test}
test io-40.10 {POSIX open access modes: RDONLY} {
    set f [open $path(test1) w]
    puts $f "two lines: this one"
    puts $f "and this"
    close $f
    set f [open $path(test1) RDONLY]
    set x [list [gets $f] [catch {puts $f Test} msg] $msg]
    close $f
    string compare [string tolower $x] \
	[list {two lines: this one} 1 \
		[format "channel \"%s\" wasn't opened for writing" $f]]
} 0
test io-40.11 {POSIX open access modes: RDONLY} {
    removeFile test3
    set msg [list [catch {open $path(test3) RDONLY} msg] $msg]
    regsub [file join {} $path(test3)] $msg "test3" msg
	string tolower $msg
} {1 {couldn't open "test3": no such file or directory}}
test io-40.12 {POSIX open access modes: WRONLY} {
    removeFile test3
    set msg [list [catch {open $path(test3) WRONLY} msg] $msg]
    regsub [file join {} $path(test3)] $msg "test3" msg
	string tolower $msg
} {1 {couldn't open "test3": no such file or directory}}
test io-40.13 {POSIX open access modes: WRONLY} {
    makeFile xyzzy test3
    set f [open $path(test3) WRONLY]
    fconfigure $f -eofchar {}
    puts -nonewline $f "ab"
    seek $f 0 current
    set x [list [catch {gets $f} msg] $msg]
    close $f
    lappend x [viewFile test3]
    string compare [string tolower $x] \
	[list 1 "channel \"$f\" wasn't opened for reading" abzzy]
} 0
test io-40.14 {POSIX open access modes: RDWR} {
    removeFile test3
    set msg [list [catch {open $path(test3) RDWR} msg] $msg]
    regsub [file join {} $path(test3)] $msg "test3" msg
	string tolower $msg
} {1 {couldn't open "test3": no such file or directory}}
test io-40.15 {POSIX open access modes: RDWR} {
    makeFile xyzzy test3
    set f [open $path(test3) RDWR]
    puts -nonewline $f "ab"
    seek $f 0 current
    set x [gets $f]
    close $f
    lappend x [viewFile test3]
} {zzy abzzy}
if {![file exists ~/_test_] && [file writable ~]} {
    test io-40.16 {tilde substitution in open} {
	set f [open ~/_test_ w]
	puts $f "Some text"
	close $f
	set x [file exists [file join $env(HOME) _test_]]
	removeFile [file join $env(HOME) _test_]
	set x
    } 1
}
test io-40.17 {tilde substitution in open} {
    set home $env(HOME)
    unset env(HOME)
    set x [list [catch {open ~/foo} msg] $msg]
    set env(HOME) $home
    set x
} {1 {couldn't find HOME environment variable to expand path}}

test io-41.1 {Tcl_FileeventCmd: errors} {
    list [catch {fileevent foo} msg] $msg
} {1 {wrong # args: should be "fileevent channelId event ?script?"}}
test io-41.2 {Tcl_FileeventCmd: errors} {
    list [catch {fileevent foo bar baz q} msg] $msg
} {1 {wrong # args: should be "fileevent channelId event ?script?"}}
test io-41.3 {Tcl_FileeventCmd: errors} {
    list [catch {fileevent gorp readable} msg] $msg
} {1 {can not find channel named "gorp"}}
test io-41.4 {Tcl_FileeventCmd: errors} {
    list [catch {fileevent gorp writable} msg] $msg
} {1 {can not find channel named "gorp"}}
test io-41.5 {Tcl_FileeventCmd: errors} {
    list [catch {fileevent gorp who-knows} msg] $msg
} {1 {bad event name "who-knows": must be readable or writable}}

#
# Test fileevent on a file
#

set path(foo) [makeFile {} foo]
set f [open $path(foo) w+]

test io-42.1 {Tcl_FileeventCmd: creating, deleting, querying} {
    list [fileevent $f readable] [fileevent $f writable]
} {{} {}}
test io-42.2 {Tcl_FileeventCmd: replacing} {
    set result {}
    fileevent $f r "first script"
    lappend result [fileevent $f readable]
    fileevent $f r "new script"
    lappend result [fileevent $f readable]
    fileevent $f r "yet another"
    lappend result [fileevent $f readable]
    fileevent $f r ""
    lappend result [fileevent $f readable]
} {{first script} {new script} {yet another} {}}
test io-42.3 {Tcl_FileeventCmd: replacing, with NULL chars in script} {
    set result {}
    fileevent $f r "first scr\0ipt"
    lappend result [string length [fileevent $f readable]]
    fileevent $f r "new scr\0ipt"
    lappend result [string length [fileevent $f readable]]
    fileevent $f r "yet ano\0ther"
    lappend result [string length [fileevent $f readable]]
    fileevent $f r ""
    lappend result [fileevent $f readable]
} {13 11 12 {}}

#
# Test fileevent on a pipe
#

catch {set f2 [open "|[list cat -u]" r+]}
catch {set f3 [open "|[list cat -u]" r+]}

test io-43.1 {Tcl_FileeventCmd: creating, deleting, querying} {stdio unixExecs} {
    set result {}
    fileevent $f readable "script 1"
    lappend result [fileevent $f readable] [fileevent $f writable]
    fileevent $f writable "write script"
    lappend result [fileevent $f readable] [fileevent $f writable]
    fileevent $f readable {}
    lappend result [fileevent $f readable] [fileevent $f writable]
    fileevent $f writable {}
    lappend result [fileevent $f readable] [fileevent $f writable]
} {{script 1} {} {script 1} {write script} {} {write script} {} {}}
test io-43.2 {Tcl_FileeventCmd: deleting when many present} {stdio unixExecs} {
    set result {}
    lappend result [fileevent $f r] [fileevent $f2 r] [fileevent $f3 r]
    fileevent $f r "read f"
    fileevent $f2 r "read f2"
    fileevent $f3 r "read f3"
    lappend result [fileevent $f r] [fileevent $f2 r] [fileevent $f3 r]
    fileevent $f2 r {}
    lappend result [fileevent $f r] [fileevent $f2 r] [fileevent $f3 r]
    fileevent $f3 r {}
    lappend result [fileevent $f r] [fileevent $f2 r] [fileevent $f3 r]
    fileevent $f r {}
    lappend result [fileevent $f r] [fileevent $f2 r] [fileevent $f3 r]
} {{} {} {} {read f} {read f2} {read f3} {read f} {} {read f3} {read f} {} {} {} {} {}}

test io-44.1 {FileEventProc procedure: normal read event} {stdio unixExecs} {
    fileevent $f2 readable [namespace code {
	set x [gets $f2]; fileevent $f2 readable {}
    }]
    puts $f2 text; flush $f2
    variable x initial
    vwait [namespace which -variable x]
    set x
} {text}
test io-44.2 {FileEventProc procedure: error in read event} {stdio unixExecs} {
    proc ::bgerror args "set [namespace which -variable x] \$args"
    fileevent $f2 readable {error bogus}
    puts $f2 text; flush $f2
    variable x initial
    vwait [namespace which -variable x]
    rename ::bgerror {}
    list $x [fileevent $f2 readable]
} {bogus {}}
test io-44.3 {FileEventProc procedure: normal write event} {stdio unixExecs} {
    fileevent $f2 writable [namespace code {
	lappend x "triggered"
	incr count -1
	if {$count <= 0} {
	    fileevent $f2 writable {}
	}
    }]
    variable x initial
    set count 3
    vwait [namespace which -variable x]
    vwait [namespace which -variable x]
    vwait [namespace which -variable x]
    set x
} {initial triggered triggered triggered}
test io-44.4 {FileEventProc procedure: eror in write event} {stdio unixExecs} {
    proc ::bgerror args "set [namespace which -variable x] \$args"
    fileevent $f2 writable {error bad-write}
    variable x initial
    vwait [namespace which -variable x]
    rename ::bgerror {}
    list $x [fileevent $f2 writable]
} {bad-write {}}
test io-44.5 {FileEventProc procedure: end of file} {stdio unixExecs} {
    set f4 [open "|[list [interpreter] $path(cat) << foo]" r]
    fileevent $f4 readable [namespace code {
	if {[gets $f4 line] < 0} {
	    lappend x eof
	    fileevent $f4 readable {}
	} else {
	    lappend x $line
	}
    }]
    variable x initial
    vwait [namespace which -variable x]
    vwait [namespace which -variable x]
    close $f4
    set x
} {initial foo eof}

catch {close $f2}
catch {close $f3}


close $f
makeFile "foo bar" foo
test io-45.1 {DeleteFileEvent, cleanup on close} {
    set f [open $path(foo) r]
    fileevent $f readable [namespace code {
	lappend x "binding triggered: \"[gets $f]\""
	fileevent $f readable {}
    }]
    close $f
    set x initial
    after 100 [namespace code { set y done }]
    variable y
    vwait [namespace which -variable y]
    set x
} {initial}
test io-45.2 {DeleteFileEvent, cleanup on close} {
    set f  [open $path(foo) r]
    set f2 [open $path(foo) r]
    fileevent $f readable [namespace code {
	    lappend x "f triggered: \"[gets $f]\""
	    fileevent $f readable {}
	}]
    fileevent $f2 readable [namespace code {
	lappend x "f2 triggered: \"[gets $f2]\""
	fileevent $f2 readable {}
    }]
    close $f
    variable x initial
    vwait [namespace which -variable x]
    close $f2
    set x
} {initial {f2 triggered: "foo bar"}}
test io-45.3 {DeleteFileEvent, cleanup on close} {
    set f  [open $path(foo) r]
    set f2 [open $path(foo) r]
    set f3 [open $path(foo) r]
    fileevent $f readable {f script}
    fileevent $f2 readable {f2 script}
    fileevent $f3 readable {f3 script}
    set x {}
    close $f2
    lappend x [catch {fileevent $f readable} msg] $msg \
	    [catch {fileevent $f2 readable}] \
	    [catch {fileevent $f3 readable} msg] $msg
    close $f3
    lappend x [catch {fileevent $f readable} msg] $msg \
	    [catch {fileevent $f2 readable}] \
	    [catch {fileevent $f3 readable}]
    close $f
    lappend x [catch {fileevent $f readable}] \
	    [catch {fileevent $f2 readable}] \
	    [catch {fileevent $f3 readable}]
} {0 {f script} 1 0 {f3 script} 0 {f script} 1 1 1 1 1}

# Execute these tests only if the "testfevent" command is present.
testConstraint testfevent [llength [info commands testfevent]]

test io-46.1 {Tcl event loop vs multiple interpreters} {testfevent} {
    testfevent create
    testfevent cmd [format {
        set f [open %s r]
        set x "no event"
        fileevent $f readable [namespace code {
            set x "f triggered: [gets $f]"
            fileevent $f readable {}
        }]
    } $path(foo)]
    after 1	;# We must delay because Windows takes a little time to notice
    update
    testfevent cmd {close $f}
    list [testfevent cmd {set x}] [testfevent cmd {info commands after}]
} {{f triggered: foo bar} after}
test io-46.2 {Tcl event loop vs multiple interpreters} testfevent {
    testfevent create
    testfevent cmd {
        variable x 0
        after 100 {set x triggered}
        vwait [namespace which -variable x]
        set x
    }
} {triggered}
test io-46.3 {Tcl event loop vs multiple interpreters} testfevent {
    testfevent create
    testfevent cmd {
        set x 0
        after 10 {lappend x timer}
        after 30
        set result $x
        update idletasks
        lappend result $x
        update
        lappend result $x
    }
} {0 0 {0 timer}}

test io-47.1 {fileevent vs multiple interpreters} testfevent {
    set f  [open $path(foo) r]
    set f2 [open $path(foo) r]
    set f3 [open $path(foo) r]
    fileevent $f readable {script 1}
    testfevent create
    testfevent share $f2
    testfevent cmd "fileevent $f2 readable {script 2}"
    fileevent $f3 readable {sript 3}
    set x {}
    lappend x [fileevent $f2 readable]
    testfevent delete
    lappend x [fileevent $f readable] [fileevent $f2 readable] \
        [fileevent $f3 readable]
    close $f
    close $f2
    close $f3
    set x
} {{} {script 1} {} {sript 3}}
test io-47.2 {deleting fileevent on interpreter delete} testfevent {
    set f  [open $path(foo) r]
    set f2 [open $path(foo) r]
    set f3 [open $path(foo) r]
    set f4 [open $path(foo) r]
    fileevent $f readable {script 1}
    testfevent create
    testfevent share $f2
    testfevent share $f3
    testfevent cmd "fileevent $f2 readable {script 2}
        fileevent $f3 readable {script 3}"
    fileevent $f4 readable {script 4}
    testfevent delete
    set x [list [fileevent $f readable] [fileevent $f2 readable] \
                [fileevent $f3 readable] [fileevent $f4 readable]]
    close $f
    close $f2
    close $f3
    close $f4
    set x
} {{script 1} {} {} {script 4}}
test io-47.3 {deleting fileevent on interpreter delete} testfevent {
    set f  [open $path(foo) r]
    set f2 [open $path(foo) r]
    set f3 [open $path(foo) r]
    set f4 [open $path(foo) r]
    testfevent create
    testfevent share $f3
    testfevent share $f4
    fileevent $f readable {script 1}
    fileevent $f2 readable {script 2}
    testfevent cmd "fileevent $f3 readable {script 3}
      fileevent $f4 readable {script 4}"
    testfevent delete
    set x [list [fileevent $f readable] [fileevent $f2 readable] \
                [fileevent $f3 readable] [fileevent $f4 readable]]
    close $f
    close $f2
    close $f3
    close $f4
    set x
} {{script 1} {script 2} {} {}}
test io-47.4 {file events on shared files and multiple interpreters} testfevent {
    set f  [open $path(foo) r]
    set f2 [open $path(foo) r]
    testfevent create
    testfevent share $f
    testfevent cmd "fileevent $f readable {script 1}"
    fileevent $f readable {script 2}
    fileevent $f2 readable {script 3}
    set x [list [fileevent $f2 readable] \
                [testfevent cmd "fileevent $f readable"] \
                [fileevent $f readable]]
    testfevent delete
    close $f
    close $f2
    set x
} {{script 3} {script 1} {script 2}}
test io-47.5 {file events on shared files, deleting file events} testfevent {
    set f [open $path(foo) r]
    testfevent create
    testfevent share $f
    testfevent cmd "fileevent $f readable {script 1}"
    fileevent $f readable {script 2}
    testfevent cmd "fileevent $f readable {}"
    set x [list [testfevent cmd "fileevent $f readable"] \
                [fileevent $f readable]]
    testfevent delete
    close $f
    set x
} {{} {script 2}}
test io-47.6 {file events on shared files, deleting file events} testfevent {
    set f [open $path(foo) r]
    testfevent create
    testfevent share $f
    testfevent cmd "fileevent $f readable {script 1}"
    fileevent $f readable {script 2}
    fileevent $f readable {}
    set x [list [testfevent cmd "fileevent $f readable"] \
                [fileevent $f readable]]
    testfevent delete
    close $f
    set x
} {{script 1} {}}

set path(bar) [makeFile {} bar]

test io-48.1 {testing readability conditions} {
    set f [open $path(bar) w]
    puts $f abcdefg
    puts $f abcdefg
    puts $f abcdefg
    puts $f abcdefg
    puts $f abcdefg
    close $f
    set f [open $path(bar) r]
    fileevent $f readable [namespace code [list consume $f]]
    proc consume {f} {
	variable l
	variable x
	lappend l called
	if {[eof $f]} {
	    close $f
	    set x done
	} else {
	    gets $f
	}
    }
    set l ""
    variable x not_done
    vwait [namespace which -variable x]
    list $x $l
} {done {called called called called called called called}}
test io-48.2 {testing readability conditions} {nonBlockFiles} {
    set f [open $path(bar) w]
    puts $f abcdefg
    puts $f abcdefg
    puts $f abcdefg
    puts $f abcdefg
    puts $f abcdefg
    close $f
    set f [open $path(bar) r]
    fileevent $f readable [namespace code [list consume $f]]
    fconfigure $f -blocking off
    proc consume {f} {
	variable x
	variable l
	lappend l called
	if {[eof $f]} {
	    close $f
	    set x done
	} else {
	    gets $f
	}
    }
    set l ""
    variable x not_done
    vwait [namespace which -variable x]
    list $x $l
} {done {called called called called called called called}}

set path(my_script) [makeFile {} my_script]

test io-48.3 {testing readability conditions} {stdio unixOnly nonBlockFiles} {
    set f [open $path(bar) w]
    puts $f abcdefg
    puts $f abcdefg
    puts $f abcdefg
    puts $f abcdefg
    puts $f abcdefg
    close $f
    set f [open $path(my_script) w]
    puts $f {
	proc copy_slowly {f} {
	    while {![eof $f]} {
		puts [gets $f]
		after 200
	    }
	    close $f
	}
    }
    close $f
    set f [open "|[list [interpreter]]" r+]
    fileevent $f readable [namespace code [list consume $f]]
    fconfigure $f -buffering line
    fconfigure $f -blocking off
    proc consume {f} {
	variable l
	variable x
	if {[eof $f]} {
	    set x done
	} else {
	    gets $f
	    lappend l [fblocked $f]
	    gets $f
	    lappend l [fblocked $f]
	}
    }
    set l ""
    variable x not_done
    puts $f [format {source %s}         $path(my_script)]
    puts $f [format {set f [open %s r]} $path(bar)]
    puts $f {copy_slowly $f}
    puts $f {exit}
    vwait [namespace which -variable x]
    close $f
    list $x $l
} {done {0 1 0 1 0 1 0 1 0 1 0 1 0 0}}
test io-48.4 {lf write, testing readability, ^Z termination, auto read mode} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    set c [format "abc\ndef\n%c" 26]
    puts -nonewline $f $c
    close $f
    proc consume {f} {
	variable l
	variable c
	variable x
	if {[eof $f]} {
	   set x done
	   close $f
	} else {
	   lappend l [gets $f]
	   incr c
	}
    }
    set c 0
    set l ""
    set f [open $path(test1) r]
    fconfigure $f -translation auto -eofchar \x1a
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
    list $c $l
} {3 {abc def {}}}
test io-48.5 {lf write, testing readability, ^Z in middle, auto read mode} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    set c [format "abc\ndef\n%cfoo\nbar\n" 26]
    puts -nonewline $f $c
    close $f
    proc consume {f} {
	variable l
	variable x
	variable c
	if {[eof $f]} {
	   set x done
	   close $f
	} else {
	   lappend l [gets $f]
	   incr c
	}
    }
    set c 0
    set l ""
    set f [open $path(test1) r]
    fconfigure $f -eofchar \x1a -translation auto
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
    list $c $l
} {3 {abc def {}}}
test io-48.6 {cr write, testing readability, ^Z termination, auto read mode} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation cr
    set c [format "abc\ndef\n%c" 26]
    puts -nonewline $f $c
    close $f
    proc consume {f} {
	variable l
	variable x
	variable c
	if {[eof $f]} {
	   set x done
	   close $f
	} else {
	   lappend l [gets $f]
	   incr c
	}
    }
    set c 0
    set l ""
    set f [open $path(test1) r]
    fconfigure $f -translation auto -eofchar \x1a
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
    list $c $l
} {3 {abc def {}}}
test io-48.7 {cr write, testing readability, ^Z in middle, auto read mode} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation cr
    set c [format "abc\ndef\n%cfoo\nbar\n" 26]
    puts -nonewline $f $c
    close $f
    proc consume {f} {
	variable l
	variable c
	variable x
	if {[eof $f]} {
	   set x done
	   close $f
	} else {
	   lappend l [gets $f]
	   incr c
	}
    }
    set c 0
    set l ""
    set f [open $path(test1) r]
    fconfigure $f -eofchar \x1a -translation auto
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
    list $c $l
} {3 {abc def {}}}
test io-48.8 {crlf write, testing readability, ^Z termination, auto read mode} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation crlf
    set c [format "abc\ndef\n%c" 26]
    puts -nonewline $f $c
    close $f
    proc consume {f} {
	variable l
	variable x
	variable c
	if {[eof $f]} {
	   set x done
	   close $f
	} else {
	   lappend l [gets $f]
	   incr c
	}
    }
    set c 0
    set l ""
    set f [open $path(test1) r]
    fconfigure $f -translation auto -eofchar \x1a
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
    list $c $l
} {3 {abc def {}}}
test io-48.9 {crlf write, testing readability, ^Z in middle, auto read mode} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation crlf
    set c [format "abc\ndef\n%cfoo\nbar\n" 26]
    puts -nonewline $f $c
    close $f
    proc consume {f} {
	variable l
	variable c
	variable x
	if {[eof $f]} {
	   set x done
	   close $f
	} else {
	   lappend l [gets $f]
	   incr c
	}
    }
    set c 0
    set l ""
    set f [open $path(test1) r]
    fconfigure $f -eofchar \x1a -translation auto
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
    list $c $l
} {3 {abc def {}}}
test io-48.10 {lf write, testing readability, ^Z in middle, lf read mode} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    set c [format "abc\ndef\n%cfoo\nbar\n" 26]
    puts -nonewline $f $c
    close $f
    proc consume {f} {
	variable l
	variable c
	variable x
	if {[eof $f]} {
	   set x done
	   close $f
	} else {
	   lappend l [gets $f]
	   incr c
	}
    }
    set c 0
    set l ""
    set f [open $path(test1) r]
    fconfigure $f -eofchar \x1a -translation lf
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
    list $c $l
} {3 {abc def {}}}
test io-48.11 {lf write, testing readability, ^Z termination, lf read mode} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    set c [format "abc\ndef\n%c" 26]
    puts -nonewline $f $c
    close $f
    proc consume {f} {
	variable l
	variable x
	variable c
	if {[eof $f]} {
	   set x done
	   close $f
	} else {
	   lappend l [gets $f]
	   incr c
	}
    }
    set c 0
    set l ""
    set f [open $path(test1) r]
    fconfigure $f -translation lf -eofchar \x1a
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
    list $c $l
} {3 {abc def {}}}
test io-48.12 {cr write, testing readability, ^Z in middle, cr read mode} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation cr
    set c [format "abc\ndef\n%cfoo\nbar\n" 26]
    puts -nonewline $f $c
    close $f
    proc consume {f} {
	variable l
	variable x
	variable c
	if {[eof $f]} {
	   set x done
	   close $f
	} else {
	   lappend l [gets $f]
	   incr c
	}
    }
    set c 0
    set l ""
    set f [open $path(test1) r]
    fconfigure $f -eofchar \x1a -translation cr
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
    list $c $l
} {3 {abc def {}}}
test io-48.13 {cr write, testing readability, ^Z termination, cr read mode} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation cr
    set c [format "abc\ndef\n%c" 26]
    puts -nonewline $f $c
    close $f
    proc consume {f} {
	variable c
	variable x
	variable l
	if {[eof $f]} {
	   set x done
	   close $f
	} else {
	   lappend l [gets $f]
	   incr c
	}
    }
    set c 0
    set l ""
    set f [open $path(test1) r]
    fconfigure $f -translation cr -eofchar \x1a
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
    list $c $l
} {3 {abc def {}}}
test io-48.14 {crlf write, testing readability, ^Z in middle, crlf read mode} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation crlf
    set c [format "abc\ndef\n%cfoo\nbar\n" 26]
    puts -nonewline $f $c
    close $f
    proc consume {f} {
	variable c
	variable x
	variable l
	if {[eof $f]} {
	   set x done
	   close $f
	} else {
	   lappend l [gets $f]
	   incr c
	}
    }
    set c 0
    set l ""
    set f [open $path(test1) r]
    fconfigure $f -eofchar \x1a -translation crlf
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
    list $c $l
} {3 {abc def {}}}
test io-48.15 {crlf write, testing readability, ^Z termi, crlf read mode} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation crlf
    set c [format "abc\ndef\n%c" 26]
    puts -nonewline $f $c
    close $f
    proc consume {f} {
	variable c
	variable x
	variable l
	if {[eof $f]} {
	   set x done
	   close $f
	} else {
	   lappend l [gets $f]
	   incr c
	}
    }
    set c 0
    set l ""
    set f [open $path(test1) r]
    fconfigure $f -translation crlf -eofchar \x1a
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
    list $c $l
} {3 {abc def {}}}

test io-49.1 {testing crlf reading, leftover cr disgorgment} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "a\rb\rc\r\n"
    close $f
    set f [open $path(test1) r]
    set l ""
    lappend l [file size $path(test1)]
    fconfigure $f -translation crlf
    lappend l [read $f 1]
    lappend l [tell $f]
    lappend l [read $f 1]
    lappend l [tell $f]
    lappend l [read $f 1]
    lappend l [tell $f]
    lappend l [read $f 1]
    lappend l [tell $f]
    lappend l [read $f 1]
    lappend l [tell $f]
    lappend l [read $f 1]
    lappend l [tell $f]
    lappend l [eof $f]
    lappend l [read $f 1]
    lappend l [eof $f]
    close $f
    set l
} "7 a 1 [list \r] 2 b 3 [list \r] 4 c 5 {
} 7 0 {} 1"
test io-49.2 {testing crlf reading, leftover cr disgorgment} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "a\rb\rc\r\n"
    close $f
    set f [open $path(test1) r]
    set l ""
    lappend l [file size $path(test1)]
    fconfigure $f -translation crlf
    lappend l [read $f 2]
    lappend l [tell $f]
    lappend l [read $f 2]
    lappend l [tell $f]
    lappend l [read $f 2]
    lappend l [tell $f]
    lappend l [eof $f]
    lappend l [read $f 2]
    lappend l [tell $f]
    lappend l [eof $f]
    close $f
    set l
} "7 [list a\r] 2 [list b\r] 4 [list c\n] 7 0 {} 7 1"
test io-49.3 {testing crlf reading, leftover cr disgorgment} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "a\rb\rc\r\n"
    close $f
    set f [open $path(test1) r]
    set l ""
    lappend l [file size $path(test1)]
    fconfigure $f -translation crlf
    lappend l [read $f 3]
    lappend l [tell $f]
    lappend l [read $f 3]
    lappend l [tell $f]
    lappend l [eof $f]
    lappend l [read $f 3]
    lappend l [tell $f]
    lappend l [eof $f]
    close $f
    set l
} "7 [list a\rb] 3 [list \rc\n] 7 0 {} 7 1"
test io-49.4 {testing crlf reading, leftover cr disgorgment} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "a\rb\rc\r\n"
    close $f
    set f [open $path(test1) r]
    set l ""
    lappend l [file size $path(test1)]
    fconfigure $f -translation crlf
    lappend l [read $f 3]
    lappend l [tell $f]
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [eof $f]
    close $f
    set l
} "7 [list a\rb] 3 [list \rc] 7 0 {} 7 1"
test io-49.5 {testing crlf reading, leftover cr disgorgment} {
    removeFile test1
    set f [open $path(test1) w]
    fconfigure $f -translation lf
    puts -nonewline $f "a\rb\rc\r\n"
    close $f
    set f [open $path(test1) r]
    set l ""
    lappend l [file size $path(test1)]
    fconfigure $f -translation crlf
    lappend l [set x [gets $f]]
    lappend l [tell $f]
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [eof $f]
    close $f
    set l
} [list 7 a\rb\rc 7 {} 7 1]
    
testConstraint testchannelevent [llength [info commands testchannelevent]]
test io-50.1 {testing handler deletion} {testchannelevent} {
    removeFile test1
    set f [open $path(test1) w]
    close $f
    set f [open $path(test1) r]
    testchannelevent $f add readable [namespace code [list delhandler $f]]
    proc delhandler {f} {
	variable z
	set z called
	testchannelevent $f delete 0
    }
    set z not_called
    update
    close $f
    set z
} called
test io-50.2 {testing handler deletion with multiple handlers} {testchannelevent} {
    removeFile test1
    set f [open $path(test1) w]
    close $f
    set f [open $path(test1) r]
    testchannelevent $f add readable [namespace code [list delhandler $f 1]]
    testchannelevent $f add readable [namespace code [list delhandler $f 0]]
    proc delhandler {f i} {
	variable z
	lappend z "called delhandler $f $i"
	testchannelevent $f delete 0
    }
    set z ""
    update
    close $f
    string compare [string tolower $z] \
	[list [list called delhandler $f 0] [list called delhandler $f 1]]
} 0
test io-50.3 {testing handler deletion with multiple handlers} {testchannelevent} {
    removeFile test1
    set f [open $path(test1) w]
    close $f
    set f [open $path(test1) r]
    testchannelevent $f add readable [namespace code [list notcalled $f 1]]
    testchannelevent $f add readable [namespace code [list delhandler $f 0]]
    set z ""
    proc notcalled {f i} {
	variable z
	lappend z "notcalled was called!! $f $i"
    }
    proc delhandler {f i} {
	variable z
	testchannelevent $f delete 1
	lappend z "delhandler $f $i called"
	testchannelevent $f delete 0
	lappend z "delhandler $f $i deleted myself"
    }
    set z ""
    update
    close $f
    string compare [string tolower $z] \
	[list [list delhandler $f 0 called] \
	      [list delhandler $f 0 deleted myself]]
} 0
test io-50.4 {testing handler deletion vs reentrant calls} {testchannelevent} {
    removeFile test1
    set f [open $path(test1) w]
    close $f
    set f [open $path(test1) r]
    testchannelevent $f add readable [namespace code [list delrecursive $f]]
    proc delrecursive {f} {
	variable z
	variable u
	if {"$u" == "recursive"} {
	    testchannelevent $f delete 0
	    lappend z "delrecursive deleting recursive"
	} else {
	    lappend z "delrecursive calling recursive"
	    set u recursive
	    update
	}
    }
    set u toplevel
    set z ""
    update
    close $f
    string compare [string tolower $z] \
	{{delrecursive calling recursive} {delrecursive deleting recursive}}
} 0
test io-50.5 {testing handler deletion vs reentrant calls} {testchannelevent} {
    removeFile test1
    set f [open $path(test1) w]
    close $f
    set f [open $path(test1) r]
    testchannelevent $f add readable [namespace code [list notcalled $f]]
    testchannelevent $f add readable [namespace code [list del $f]]
    proc notcalled {f} {
	variable z
	lappend z "notcalled was called!! $f"
    }
    proc del {f} {
	variable u
	variable z
	if {"$u" == "recursive"} {
	    testchannelevent $f delete 1
	    testchannelevent $f delete 0
	    lappend z "del deleted notcalled"
	    lappend z "del deleted myself"
	} else {
	    set u recursive
	    lappend z "del calling recursive"
	    update
	    lappend z "del after update"
	}
    }
    set z ""
    set u toplevel
    update
    close $f
    string compare [string tolower $z] \
	[list {del calling recursive} {del deleted notcalled} \
	      {del deleted myself} {del after update}]
} 0
test io-50.6 {testing handler deletion vs reentrant calls} {testchannelevent} {
    removeFile test1
    set f [open $path(test1) w]
    close $f
    set f [open $path(test1) r]
    testchannelevent $f add readable [namespace code [list second $f]]
    testchannelevent $f add readable [namespace code [list first $f]]
    proc first {f} {
	variable u
	variable z
	if {"$u" == "toplevel"} {
	    lappend z "first called"
	    set u first
	    update
	    lappend z "first after update"
	} else {
	    lappend z "first called not toplevel"
	}
    }
    proc second {f} {
	variable u
	variable z
	if {"$u" == "first"} {
	    lappend z "second called, first time"
	    set u second
	    testchannelevent $f delete 0
	} elseif {"$u" == "second"} {
	    lappend z "second called, second time"
	    testchannelevent $f delete 0
	} else {
	    lappend z "second called, cannot happen!"
	    testchannelevent $f removeall
	}
    }
    set z ""
    set u toplevel
    update
    close $f
    string compare [string tolower $z] \
	[list {first called} {first called not toplevel} \
	      {second called, first time} {second called, second time} \
	      {first after update}]
} 0

test io-51.1 {Test old socket deletion on Macintosh} {socket} {
    set x 0
    set result ""
    proc accept {s a p} {
	variable x
	variable wait
	fconfigure $s -blocking off
	puts $s "sock[incr x]"
	close $s
	set wait done
    }
    set ss [socket -server [namespace code accept] 0]
    variable wait ""
    set cs [socket [info hostname] [lindex [fconfigure $ss -sockname] 2]]
    vwait [namespace which -variable wait]
    lappend result [gets $cs]
    close $cs

    set wait ""
    set cs [socket [info hostname] [lindex [fconfigure $ss -sockname] 2]]
    vwait [namespace which -variable wait]
    lappend result [gets $cs]
    close $cs

    set wait ""
    set cs [socket [info hostname] [lindex [fconfigure $ss -sockname] 2]]
    vwait [namespace which -variable wait]
    lappend result [gets $cs]
    close $cs

    set wait ""
    set cs [socket [info hostname] [lindex [fconfigure $ss -sockname] 2]]
    vwait [namespace which -variable wait]
    lappend result [gets $cs]
    close $cs
    close $ss
    set result
} {sock1 sock2 sock3 sock4}

test io-52.1 {TclCopyChannel} {
    removeFile test1
    set f1 [open $thisScript]
    set f2 [open $path(test1) w]
    fcopy $f1 $f2 -command { # }
    catch { fcopy $f1 $f2 } msg
    close $f1
    close $f2
    string compare $msg "channel \"$f1\" is busy"
} {0}
test io-52.2 {TclCopyChannel} {
    removeFile test1
    set f1 [open $thisScript]
    set f2 [open $path(test1) w]
    set f3 [open $thisScript]
    fcopy $f1 $f2 -command { # }
    catch { fcopy $f3 $f2 } msg
    close $f1
    close $f2
    close $f3
    string compare $msg "channel \"$f2\" is busy"
} {0}
test io-52.3 {TclCopyChannel} {
    removeFile test1
    set f1 [open $thisScript]
    set f2 [open $path(test1) w]
    fconfigure $f1 -translation lf -blocking 0
    fconfigure $f2 -translation cr -blocking 0
    set s0 [fcopy $f1 $f2]
    set result [list [fconfigure $f1 -blocking] [fconfigure $f2 -blocking]]
    close $f1
    close $f2
    set s1 [file size $thisScript]
    set s2 [file size $path(test1)]
    if {("$s1" == "$s2") && ($s0 == $s1)} {
        lappend result ok
    }
    set result
} {0 0 ok}
test io-52.4 {TclCopyChannel} {
    removeFile test1
    set f1 [open $thisScript]
    set f2 [open $path(test1) w]
    fconfigure $f1 -translation lf -blocking 0
    fconfigure $f2 -translation cr -blocking 0
    fcopy $f1 $f2 -size 40
    set result [list [fconfigure $f1 -blocking] [fconfigure $f2 -blocking]]
    close $f1
    close $f2
    lappend result [file size $path(test1)]
} {0 0 40}
test io-52.5 {TclCopyChannel} {
    removeFile test1
    set f1 [open $thisScript]
    set f2 [open $path(test1) w]
    fconfigure $f1 -translation lf -blocking 0
    fconfigure $f2 -translation lf -blocking 0
    fcopy $f1 $f2 -size -1
    set result [list [fconfigure $f1 -blocking] [fconfigure $f2 -blocking]]
    close $f1
    close $f2
    set s1 [file size $thisScript]
    set s2 [file size $path(test1)]
    if {"$s1" == "$s2"} {
        lappend result ok
    }
    set result
} {0 0 ok}
test io-52.6 {TclCopyChannel} {
    removeFile test1
    set f1 [open $thisScript]
    set f2 [open $path(test1) w]
    fconfigure $f1 -translation lf -blocking 0
    fconfigure $f2 -translation lf -blocking 0
    set s0 [fcopy $f1 $f2 -size [expr [file size $thisScript] + 5]]
    set result [list [fconfigure $f1 -blocking] [fconfigure $f2 -blocking]]
    close $f1
    close $f2
    set s1 [file size $thisScript]
    set s2 [file size $path(test1)]
    if {("$s1" == "$s2") && ($s0 == $s1)} {
        lappend result ok
    }
    set result
} {0 0 ok}
test io-52.7 {TclCopyChannel} {
    removeFile test1
    set f1 [open $thisScript]
    set f2 [open $path(test1) w]
    fconfigure $f1 -translation lf -blocking 0
    fconfigure $f2 -translation lf -blocking 0
    fcopy $f1 $f2
    set result [list [fconfigure $f1 -blocking] [fconfigure $f2 -blocking]]
    set s1 [file size $thisScript]
    set s2 [file size $path(test1)]
    close $f1
    close $f2
    if {"$s1" == "$s2"} {
        lappend result ok
    }
    set result
} {0 0 ok}
test io-52.8 {TclCopyChannel} {stdio} {
    removeFile test1
    removeFile pipe
    set f1 [open $path(pipe) w]
    fconfigure $f1 -translation lf
    puts $f1 "
	puts ready
	gets stdin
	set f1 \[open [list $thisScript] r\]
	fconfigure \$f1 -translation lf
	puts \[read \$f1 100\]
	close \$f1
    "
    close $f1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
    fconfigure $f1 -translation lf
    gets $f1
    puts $f1 ready
    flush $f1
    set f2 [open $path(test1) w]
    fconfigure $f2 -translation lf
    set s0 [fcopy $f1 $f2 -size 40]
    catch {close $f1}
    close $f2
    list $s0 [file size $path(test1)]
} {40 40}

# Empty files, to register them with the test facility
set path(kyrillic.txt)   [makeFile {} kyrillic.txt]
set path(utf8-fcopy.txt) [makeFile {} utf8-fcopy.txt]
set path(utf8-rp.txt)    [makeFile {} utf8-rp.txt]

# Create kyrillic file, use lf translation to avoid os eol issues
set out [open $path(kyrillic.txt) w]
fconfigure $out -encoding koi8-r -translation lf
puts       $out "\u0410\u0410"
close      $out

test io-52.9 {TclCopyChannel & encodings} {
    # Copy kyrillic to UTF-8, using fcopy.

    set in  [open $path(kyrillic.txt) r]
    set out [open $path(utf8-fcopy.txt) w]

    fconfigure $in  -encoding koi8-r -translation lf
    fconfigure $out -encoding utf-8 -translation lf

    fcopy $in $out
    close $in
    close $out

    # Do the same again, but differently (read/puts).

    set in  [open $path(kyrillic.txt) r]
    set out [open $path(utf8-rp.txt) w]

    fconfigure $in  -encoding koi8-r -translation lf
    fconfigure $out -encoding utf-8 -translation lf

    puts -nonewline $out [read $in]

    close $in
    close $out

    list [file size $path(kyrillic.txt)] \
	    [file size $path(utf8-fcopy.txt)] \
	    [file size $path(utf8-rp.txt)]
} {3 5 5}

test io-52.10 {TclCopyChannel & encodings} {
    # encoding to binary (=> implies that the
    # internal utf-8 is written)

    set in  [open $path(kyrillic.txt) r]
    set out [open $path(utf8-fcopy.txt) w]

    fconfigure $in  -encoding koi8-r -translation lf
    # -translation binary is also -encoding binary
    fconfigure $out -translation binary

    fcopy $in $out
    close $in
    close $out

    file size $path(utf8-fcopy.txt)
} 5

test io-52.11 {TclCopyChannel & encodings} {
    # binary to encoding => the input has to be
    # in utf-8 to make sense to the encoder

    set in  [open $path(utf8-fcopy.txt) r]
    set out [open $path(kyrillic.txt) w]

    # -translation binary is also -encoding binary
    fconfigure $in  -translation binary
    fconfigure $out -encoding koi8-r -translation lf

    fcopy $in $out
    close $in
    close $out

    file size $path(kyrillic.txt)
} 3


test io-53.1 {CopyData} {
    removeFile test1
    set f1 [open $thisScript]
    set f2 [open $path(test1) w]
    fconfigure $f1 -translation lf -blocking 0
    fconfigure $f2 -translation cr -blocking 0
    fcopy $f1 $f2 -size 0
    set result [list [fconfigure $f1 -blocking] [fconfigure $f2 -blocking]]
    close $f1
    close $f2
    lappend result [file size $path(test1)]
} {0 0 0}
test io-53.2 {CopyData} {
    removeFile test1
    set f1 [open $thisScript]
    set f2 [open $path(test1) w]
    fconfigure $f1 -translation lf -blocking 0
    fconfigure $f2 -translation cr -blocking 0
    fcopy $f1 $f2 -command [namespace code {set s0}]
    set result [list [fconfigure $f1 -blocking] [fconfigure $f2 -blocking]]
    variable s0
    vwait [namespace which -variable s0]
    close $f1
    close $f2
    set s1 [file size $thisScript]
    set s2 [file size $path(test1)]
    if {("$s1" == "$s2") && ($s0 == $s1)} {
        lappend result ok
    }
    set result
} {0 0 ok}
test io-53.3 {CopyData: background read underflow} {stdio unixOnly} {
    removeFile test1
    removeFile pipe
    set f1 [open $path(pipe) w]
    puts $f1 [format {
	puts ready
	flush stdout				;# Don't assume line buffered!
	fcopy stdin stdout -command { set x }
	vwait x
	set f [open "%s" w]
	fconfigure $f -translation lf
	puts $f "done"
	close $f
    } $path(test1)]
    close $f1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
    set result [gets $f1]
    puts $f1 line1
    flush $f1
    lappend result [gets $f1]
    puts $f1 line2
    flush $f1
    lappend result [gets $f1]
    close $f1
    after 500
    set f [open $path(test1)]
    lappend result [read $f]
    close $f
    set result
} "ready line1 line2 {done\n}"
test io-53.4 {CopyData: background write overflow} {stdio unixOnly} {
    set big bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\n
    variable x
    for {set x 0} {$x < 12} {incr x} {
	append big $big
    }
    removeFile test1
    removeFile pipe
    set f1 [open $path(pipe) w]
    puts $f1 {
	puts ready
	fcopy stdin stdout -command { set x }
	vwait x
	set f [open $path(test1) w]
	fconfigure $f -translation lf
	puts $f "done"
	close $f
    }
    close $f1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
    set result [gets $f1]
    fconfigure $f1 -blocking 0
    puts $f1 $big
    flush $f1
    after 500
    set result ""
    fileevent $f1 read [namespace code {
	append result [read $f1 1024]
	if {[string length $result] >= [string length $big]} {
	    set x done
	}
    }]
    vwait [namespace which -variable x]
    close $f1
    set big {}
    set x
} done
set result {}

proc FcopyTestAccept {sock args} {
    after 1000 "close $sock"
}
proc FcopyTestDone {bytes {error {}}} {
    variable fcopyTestDone
    if {[string length $error]} {
	set fcopyTestDone 1
    } else {
	set fcopyTestDone 0
    }
}

test io-53.5 {CopyData: error during fcopy} {socket} {
    variable fcopyTestDone
    set listen [socket -server [namespace code FcopyTestAccept] 0]
    set in [open $thisScript]	;# 126 K
    set out [socket 127.0.0.1 [lindex [fconfigure $listen -sockname] 2]]
    catch {unset fcopyTestDone}
    close $listen	;# This means the socket open never really succeeds
    fcopy $in $out -command [namespace code FcopyTestDone]
    variable fcopyTestDone
    if ![info exists fcopyTestDone] {
	vwait [namespace which -variable fcopyTestDone]		;# The error occurs here in the b.g.
    }
    close $in
    close $out
    set fcopyTestDone	;# 1 for error condition
} 1
test io-53.6 {CopyData: error during fcopy} {stdio} {
    variable fcopyTestDone
    removeFile pipe
    removeFile test1
    catch {unset fcopyTestDone}
    set f1 [open $path(pipe) w]
    puts $f1 "exit 1"
    close $f1
    set in [open "|[list [interpreter] $path(pipe)]" r+]
    set out [open $path(test1) w]
    fcopy $in $out -command [namespace code FcopyTestDone]
    variable fcopyTestDone
    if ![info exists fcopyTestDone] {
	vwait [namespace which -variable fcopyTestDone]
    }
    catch {close $in}
    close $out
    set fcopyTestDone	;# 0 for plain end of file
} {0}

proc doFcopy {in out {bytes 0} {error {}}} {
    variable fcopyTestDone
    variable fcopyTestCount
    incr fcopyTestCount $bytes
    if {[string length $error]} {
	    set fcopyTestDone 1
    } elseif {[eof $in]} {
	    set fcopyTestDone 0
    } else {
        # Delay next fcopy to wait for size>0 input bytes
        after 100 [list 
            fcopy $in $out -size 1000 \
		    -command [namespace code [list doFcopy $in $out]]
        ]
    }
}

test io-53.7 {CopyData: Flooding fcopy from pipe} {stdio} {
    variable fcopyTestDone
    removeFile pipe
    removeFile test1
    catch {unset fcopyTestDone}
    set fcopyTestCount 0
    set f1 [open $path(pipe) w]
    puts $f1 {
	# Write  10 bytes / 10 msec
	proc Write {count} {
	    puts -nonewline "1234567890"
	    if {[incr count -1]} {
	        after 10 [list Write $count]
	    } else {
	        set ::ready 1
	    }
	}
	fconfigure stdout -buffering none
	Write 345 ;# 3450 bytes ~3.45 sec
	vwait ready
	exit 0
    }
    close $f1
    set in [open "|[list [interpreter] $path(pipe) &]" r+]
    set out [open $path(test1) w]
    doFcopy $in $out
    variable fcopyTestDone
    if ![info exists fcopyTestDone] {
	vwait [namespace which -variable fcopyTestDone]
    }
    catch {close $in}
    close $out
    # -1=error 0=script error N=number of bytes
    expr ($fcopyTestDone == 0) ? $fcopyTestCount : -1
} {3450}

test io-54.1 {Recursive channel events} {socket} {
    # This test checks to see if file events are delivered during recursive
    # event loops when there is buffered data on the channel.

    proc accept {s a p} {
	variable as
	fconfigure $s -translation lf
	puts $s "line 1\nline2\nline3"
	flush $s
	set as $s
    }
    proc readit {s next} {
	variable x
	variable result
	lappend result $next
	if {$next == 1} {
	    fileevent $s readable [namespace code [list readit $s 2]]
	    vwait [namespace which -variable x]
	}
	incr x
    }
    set ss [socket -server [namespace code accept] 0]

    # We need to delay on some systems until the creation of the
    # server socket completes.

    set done 0
    for {set i 0} {$i < 10} {incr i} {
	if {![catch {set cs [socket [info hostname] [lindex [fconfigure $ss -sockname] 2]]}]} {
	    set done 1
	    break
	}
	after 100
    }
    if {$done == 0} {
	close $ss
	error "failed to connect to server"
    }
    variable result {}
    variable x 0
    variable as
    vwait [namespace which -variable as]
    fconfigure $cs -translation lf
    lappend result [gets $cs]
    fconfigure $cs -blocking off
    fileevent $cs readable [namespace code [list readit $cs 1]]
    set a [after 2000 [namespace code { set x failure }]]
    vwait [namespace which -variable x]
    after cancel $a
    close $as
    close $ss
    close $cs
    list $result $x
} {{{line 1} 1 2} 2}
test io-54.2 {Testing for busy-wait in recursive channel events} {socket} {
    set accept {}
    set after {}
    variable s [socket -server [namespace code accept] 0]
    proc accept {s a p} {
	variable counter
	variable accept

	set accept $s
	set counter 0
	fconfigure $s -blocking off -buffering line -translation lf
	fileevent $s readable [namespace code "doit $s"]
    }
    proc doit {s} {
	variable counter
	variable after

	incr counter
	set l [gets $s]
	if {"$l" == ""} {
	    fileevent $s readable [namespace code "doit1 $s"]
	    set after [after 1000 [namespace code newline]]
	}
    }
    proc doit1 {s} {
	variable counter
	variable accept

	incr counter
	set l [gets $s]
	close $s
	set accept {}
    }
    proc producer {} {
	variable s
	variable writer

	set writer [socket 127.0.0.1 [lindex [fconfigure $s -sockname] 2]]
	fconfigure $writer -buffering line
	puts -nonewline $writer hello
	flush $writer
    }
    proc newline {} {
	variable done
	variable writer

	puts $writer hello
	flush $writer
	set done 1
    }
    producer
    variable done
    vwait [namespace which -variable done]
    close $writer
    close $s
    after cancel $after
    if {$accept != {}} {close $accept}
    set counter
} 1

set path(fooBar) [makeFile {} fooBar]

test io-55.1 {ChannelEventScriptInvoker: deletion} {
    variable x
    proc eventScript {fd} {
	variable x
	close $fd
	error "planned error"
	set x whoops
    }
    proc ::bgerror {args} "set [namespace which -variable x] got_error"
    set f [open $path(fooBar) w]
    fileevent $f writable [namespace code [list eventScript $f]]
    variable x not_done
    vwait [namespace which -variable x]
    set x
} {got_error}

test io-56.1 {ChannelTimerProc} {testchannelevent} {
    set f [open $path(fooBar) w]
    puts $f "this is a test"
    close $f
    set f [open $path(fooBar) r]
    testchannelevent $f add readable [namespace code {
	read $f 1
	incr x
    }]
    variable x 0
    vwait [namespace which -variable x]
    vwait [namespace which -variable x]
    set result $x
    testchannelevent $f set 0 none
    after idle [namespace code {set y done}]
    variable y
    vwait [namespace which -variable y]
    close $f
    lappend result $y
} {2 done}

test io-57.1 {buffered data and file events, gets} {
    proc accept {sock args} {
	variable s2
	set s2 $sock
    }
    set server [socket -server [namespace code accept] 0]
    set s [socket 127.0.0.1 [lindex [fconfigure $server -sockname] 2]]
    variable s2
    vwait [namespace which -variable s2]
    update
    fileevent $s2 readable [namespace code {lappend result readable}]
    puts $s "12\n34567890"
    flush $s
    variable result [gets $s2]
    after 1000 [namespace code {lappend result timer}]
    vwait [namespace which -variable result]
    lappend result [gets $s2]
    vwait [namespace which -variable result]
    close $s
    close $s2
    close $server
    set result
} {12 readable 34567890 timer}
test io-57.2 {buffered data and file events, read} {
    proc accept {sock args} {
	variable s2
	set s2 $sock
    }
    set server [socket -server [namespace code accept] 0]
    set s [socket 127.0.0.1 [lindex [fconfigure $server -sockname] 2]]
    variable s2
    vwait [namespace which -variable s2]
    update
    fileevent $s2 readable [namespace code {lappend result readable}]
    puts -nonewline $s "1234567890"
    flush $s
    variable result [read $s2 1]
    after 1000 [namespace code {lappend result timer}]
    vwait [namespace which -variable result]
    lappend result [read $s2 9]
    vwait [namespace which -variable result]
    close $s
    close $s2
    close $server
    set result
} {1 readable 234567890 timer}
        
test io-58.1 {Tcl_NotifyChannel and error when closing} {stdio unixOrPc} {
    set out [open $path(script) w]
    puts $out {
	puts "normal message from pipe"
	puts stderr "error message from pipe"
	exit 1
    }
    proc readit {pipe} {
	variable x
	variable result
	if {[eof $pipe]} {
	    set x [catch {close $pipe} line]
	    lappend result catch $line
	} else {
	    gets $pipe line
	    lappend result gets $line
	}
    }
    close $out
    set pipe [open "|[list [interpreter] $path(script)]" r]
    fileevent $pipe readable [namespace code [list readit $pipe]]
    variable x ""
    set result ""
    vwait [namespace which -variable x]
    list $x $result
} {1 {gets {normal message from pipe} gets {} catch {error message from pipe}}}


testConstraint testmainthread [llength [info commands testmainthread]]
test io-59.1 {Thread reference of channels} {testmainthread testchannel} {
    # TIP #10
    # More complicated tests (like that the reference changes as a
    # channel is moved from thread to thread) can be done only in the
    # extension which fully implements the moving of channels between
    # threads, i.e. 'Threads'. Or we have to extend [testthread] as well.

    set f [open $path(longfile) r]
    set result [testchannel mthread $f]
    close $f
    string equal $result [testmainthread]
} {1}


test io-60.1 {writing illegal utf sequences} {
    # This test will hang in older revisions of the core.

    set out [open $path(script) w]
    puts $out {
	puts [encoding convertfrom identity \xe2]
	exit 1
    }
    proc readit {pipe} {
	variable x
	variable result
	if {[eof $pipe]} {
	    set x [catch {close $pipe} line]
	    lappend result catch $line
	} else {
	    gets $pipe line
	    lappend result gets $line
	}
    }
    close $out
    set pipe [open "|[list [interpreter] $path(script)]" r]
    fileevent $pipe readable [namespace code [list readit $pipe]]
    variable x ""
    set result ""
    vwait [namespace which -variable x]

    # cut of the remainder of the error stack, especially the filename
    set result [lreplace $result 3 3 [lindex [split [lindex $result 3] \n] 0]]
    list $x $result
} {1 {gets {} catch {error writing "stdout": invalid argument}}}




# cleanup
foreach file [list fooBar longfile script output test1 pipe my_script foo \
	bar test2 test3 cat stdout] {
    removeFile $file
}
cleanupTests
}
namespace delete ::tcl::test::io
return
@


1.4
log
@touched all sources to ease next import
@
text
@d15 1
a15 1
# RCS: @@(#) $Id: io.test,v 1.6.8.2 2000/09/15 16:56:45 spolk Exp $
d17 2
a18 8
if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import -force ::tcltest::*
}

if {"[info commands testchannel]" != "testchannel"} {
    puts "Skipping io tests. This application does not seem to have the"
    puts "testchannel command that is needed to run these tests."
d21 1
d23 14
a36 1
::tcltest::saveState
a40 2
catch {unset u}

d43 2
a44 1
set f [open longfile w]
d53 1
a53 1
makeFile {
d70 1
a70 1
} cat
d85 3
d89 1
a89 1
    set f [open test1 w]
d93 1
a93 1
    contents test1
d96 1
a96 1
    set f [open test1 w]
d100 1
a100 1
    contents test1
d103 16
d122 1
a122 1
    set f [open test1 w]
d126 1
a126 1
    contents test1
d132 1
a132 1
    set f [open test1 w]
d135 1
a135 1
    set x [list [contents test1]]
d137 1
a137 1
    lappend x [contents test1]
d144 1
a144 1
    set f [open test1 w]
d147 1
a147 1
    set x [contents test1]
d152 1
a152 1
    set f [open test1 w]
d156 1
a156 1
    set x [list [contents test1]]
d158 1
a158 1
    lappend x [contents test1]
d164 1
a164 1
    set f [open test1 w]
d168 1
a168 1
    contents test1
d174 1
a174 1
    set f [open test1 w]
d177 1
a177 1
    set x [list [contents test1]]
d179 1
a179 1
    lappend x [contents test1]
d186 1
a186 1
    set f [open test1 w]
d189 1
a189 1
    set x [contents test1]
d196 1
a196 1
    set f [open test1 w]
d199 1
a199 1
    set x [list [contents test1]]
d201 1
a201 1
    lappend x [contents test1]
d208 1
a208 1
    set f [open test1 w]
d211 1
a211 1
    set x [list [contents test1]]
d213 1
a213 1
    lappend x [contents test1]
d225 1
a225 1
    set f [open test1 w]
d228 1
a228 1
    set x [list [contents test1]]
d230 1
a230 1
    lappend x [contents test1]
d239 1
a239 1
    set f [open test1 w]
d242 1
a242 1
    set x [list [contents test1]]
d244 1
a244 1
    lappend x [contents test1]
d247 1
a247 1
    set f [open test1 w]
d251 1
a251 1
    set x [list [contents test1]]
d253 1
a253 1
    lappend x [contents test1]
d259 1
a259 1
    set f [open test1 w]
d262 1
a262 1
    set x [list [contents test1]]
d264 1
a264 1
    lappend x [contents test1]
d269 1
a269 1
    set f [open test1 w]
d272 1
a272 1
    set x [list [contents test1]]
d274 1
a274 1
    lappend x [contents test1]
d279 1
a279 1
    set f [open test1 w]
d282 1
a282 1
    set x [list [contents test1]]
d284 1
a284 1
    lappend x [contents test1]
d291 1
a291 1
    set f [open test1 w]
d294 1
a294 1
    set x [list [contents test1]]
d296 1
a296 1
    lappend x [contents test1]
d301 1
a301 1
    set f [open test1 w]
d305 1
a305 1
    set x [contents test1]
d309 1
a309 1
    set f [open test1 w]
d312 1
a312 1
    set x [list [contents test1]]
d314 1
a314 1
    lappend x [contents test1]
d317 1
a317 1
    set f [open test1 w]
d320 1
a320 1
    set x [list [contents test1]]
d322 1
a322 1
    lappend x [contents test1]
d325 1
a325 1
    set f [open test1 w]
d328 1
a328 1
    set x [list [contents test1]]
d330 1
a330 1
    lappend x [contents test1]
d333 1
a333 1
    set f [open test1 w]
d336 1
a336 1
    set x [list [contents test1]]
d338 1
a338 1
    lappend x [contents test1]
d341 1
a341 1
    set f [open test1 w]
d344 1
a344 1
    set x [list [contents test1]]
d346 1
a346 1
    lappend x [contents test1]
d350 1
a350 1
    set f [open test1 w]
d353 1
a353 1
    set f [open test1]
d364 1
a364 1
    set f [open test1 w]
d368 1
a368 1
    set f [open test1]
d374 1
a374 1
    set f [open test1 w]
d378 1
a378 1
    set f [open test1]
d385 1
a385 1
    set f [open test1 w]
d389 1
a389 1
    set f [open test1]
d401 1
a401 1
    set f [open test1 w]
d405 1
a405 1
    set f [open test1]
d413 1
a413 1
    set f [open "|[list $::tcltest::tcltest cat]" w+]
d423 1
a423 1
    set f [open test1 w]
d426 1
a426 1
    set f [open test1]
d433 1
a433 1
    set f [open test1 w]
d436 1
a436 1
    set f [open test1]
d446 1
a446 1
    set f [open test1 w]
d448 1
a448 1
    set f [open test1]
d455 1
a455 1
    set f [open test1 w]
d459 1
a459 1
    set f [open test1]
d466 1
a466 1
    set f [open test1 w]
d470 1
a470 1
    set f [open test1]
d477 1
a477 1
    set f [open test1 w]
d481 1
a481 1
    set f [open test1]
d488 1
a488 1
    set f [open test1 w]
d492 1
a492 1
    set f [open test1]
d499 1
a499 1
    set f [open test1 w]
d503 1
a503 1
    set f [open test1]
d510 1
a510 1
    set f [open test1 w]
d512 1
a512 1
    set f [open test1]
d519 1
a519 1
    set f [open test1 w]
d523 1
a523 1
    set f [open test1]
d530 1
a530 1
    set f [open test1 w]
d534 1
a534 1
    set f [open test1]
d541 1
a541 1
    set f [open test1 w]
d545 1
a545 1
    set f [open test1]
d552 1
a552 1
    set f [open test1 w]
d556 1
a556 1
    set f [open test1]
d563 1
a563 1
    set f [open test1 w]
d567 1
a567 1
    set f [open test1]
d574 1
a574 1
    set f [open test1 w]
d576 1
a576 1
    set f [open test1]
d583 1
a583 1
    set f [open test1 w]
d587 1
a587 1
    set f [open test1]
d594 1
a594 1
    set f [open test1 w]
d598 1
a598 1
    set f [open test1]
d605 1
a605 1
    set f [open test1 w]
d609 1
a609 1
    set f [open test1]
d616 1
a616 1
    set f [open test1 w]
d620 1
a620 1
    set f [open test1]
d627 1
a627 1
    set f [open test1 w]
d631 1
a631 1
    set f [open test1]
d638 1
a638 1
    set f [open test1 w]
d642 1
a642 1
    set f [open test1]
d649 1
a649 1
    set f [open test1 w]
d653 1
a653 1
    set f [open test1]
d659 1
a659 1
test io-6.30 {Tcl_GetsObj: crlf mode: buffer exhausted} {
d662 1
a662 1
    set f [open test1 w]
d666 1
a666 1
    set f [open test1]
d672 1
a672 1
test io-6.31 {Tcl_GetsObj: crlf mode: buffer exhausted, blocked} {stdio} {
d675 1
a675 1
    set f [open "|[list $::tcltest::tcltest cat]" w+]
d685 1
a685 1
test io-6.32 {Tcl_GetsObj: crlf mode: buffer exhausted, more data} {
d688 1
a688 1
    set f [open test1 w]
d692 1
a692 1
    set f [open test1]
d701 1
a701 1
    set f [open test1 w]
d705 1
a705 1
    set f [open test1]
d714 1
a714 1
    set f [open test1 w]
d718 1
a718 1
    set f [open test1]
d725 1
a725 1
    set f [open test1 w]
d727 1
a727 1
    set f [open test1]
d734 1
a734 1
    set f [open test1 w]
d738 1
a738 1
    set f [open test1]
d745 1
a745 1
    set f [open test1 w]
d749 1
a749 1
    set f [open test1]
d756 1
a756 1
    set f [open test1 w]
d760 1
a760 1
    set f [open test1]
d767 1
a767 1
    set f [open test1 w]
d771 1
a771 1
    set f [open test1]
d778 1
a778 1
    set f [open test1 w]
d782 1
a782 1
    set f [open test1]
d789 1
a789 1
    set f [open test1 w]
d793 1
a793 1
    set f [open test1]
d800 1
a800 1
    set f [open test1 w]
d804 1
a804 1
    set f [open test1]
d811 1
a811 1
test io-6.43 {Tcl_GetsObj: input saw cr} {stdio} {
d814 1
a814 1
    set f [open "|[list $::tcltest::tcltest cat]" w+]
d828 1
a828 1
test io-6.44 {Tcl_GetsObj: input saw cr, not followed by cr} {stdio} {
d831 1
a831 1
    set f [open "|[list $::tcltest::tcltest cat]" w+]
d845 1
a845 1
test io-6.45 {Tcl_GetsObj: input saw cr, skip right number of bytes} {stdio} {
d848 1
a848 1
    set f [open "|[list $::tcltest::tcltest cat]" w+]
d862 1
a862 1
test io-6.46 {Tcl_GetsObj: input saw cr, followed by just \n should give eof} {stdio} {
d865 1
a865 1
    set f [open "|[list $::tcltest::tcltest cat]" w+]
d878 1
a878 1
test io-6.47 {Tcl_GetsObj: auto mode: \r at end of buffer, peek for \n} {
d881 1
a881 1
    set f [open test1 w]
d885 1
a885 1
    set f [open test1]
d891 1
a891 1
test io-6.48 {Tcl_GetsObj: auto mode: \r at end of buffer, no more avail} {
d894 1
a894 1
    set f [open test1 w]
d898 1
a898 1
    set f [open test1]
d904 1
a904 1
test io-6.49 {Tcl_GetsObj: auto mode: \r followed by \n} {
d907 1
a907 1
    set f [open test1 w]
d911 1
a911 1
    set f [open test1]
d916 1
a916 1
test io-6.50 {Tcl_GetsObj: auto mode: \r not followed by \n} {
d919 1
a919 1
    set f [open test1 w]
d923 1
a923 1
    set f [open test1]
d931 1
a931 1
    set f [open test1 w]
d935 1
a935 1
    set f [open test1]
d940 1
a940 1
test io-6.52 {Tcl_GetsObj: saw EOF character} {
d943 1
a943 1
    set f [open test1 w]
d947 1
a947 1
    set f [open test1]
d956 1
a956 1
    set f [open test1 w]
d958 1
a958 1
    set f [open test1]
d966 1
a966 1
    set f [open test1 w]
d969 1
a969 1
    set f [open test1]
d977 1
a977 1
    set f [open test1 w]
d981 1
a981 1
    set f [open test1]
d989 1
a989 1
    set f [open "|[list $::tcltest::tcltest cat]" w+]
d993 5
a997 5
    set x {}
    after 500 { lappend x timeout }
    fileevent $f readable { lappend x [gets $f] }
    vwait x
    vwait x
d1000 1
a1000 1
    after 500 { lappend x timeout }
d1002 2
a1003 2
    vwait x
    vwait x
d1011 1
a1011 1
    set f [open test1 w]
d1015 1
a1015 1
    set f [open test1]
d1024 1
a1024 1
    set f [open test1 w]
d1028 1
a1028 1
    set f [open test1]
d1034 2
a1035 2
test io-7.3 {FilterInputBytes: split up character at EOF} {
    set f [open test1 w]
d1039 1
a1039 1
    set f [open test1]
d1048 1
a1048 1
    set f [open "|[list $::tcltest::tcltest cat]" w+]
d1052 2
a1053 2
    fileevent $f read "ready $f"
    set x {}
d1055 2
a1056 1
	lappend ::x [gets $f line] $line [fblocked $f]
d1058 1
a1058 1
    vwait x
d1062 1
a1062 1
    vwait x
d1067 1
a1067 1
test io-8.1 {PeekAhead: only go to device if no more cached data} {
d1070 1
a1070 1
    set f [open "test1" w]
d1074 1
a1074 1
    set f [open "test1"]
d1082 1
a1082 1
test io-8.2 {PeekAhead: only go to device if no more cached data} {stdio} {
d1085 1
a1085 1
    set f [open "|[list $::tcltest::tcltest cat]" w+]
d1088 2
a1089 2
    set x {}
    fileevent $f read "ready $f"
d1091 2
a1092 1
	lappend ::x [gets $f line] $line [testchannel inputbuffered $f]
d1095 1
a1095 1
    vwait x
d1098 1
a1098 1
    vwait x
d1102 1
a1102 1
test io-8.3 {PeekAhead: no cached data available} {stdio} {
d1105 1
a1105 1
    set f [open "|[list $::tcltest::tcltest cat]" w+]
d1119 1
a1119 1
    set f [open test1 w+]
d1123 1
a1123 1
    set f [open test1]
d1135 1
a1135 1
test io-8.5 {PeekAhead: don't peek if last read was short} {stdio} {
d1138 1
a1138 1
    set f [open "|[list $::tcltest::tcltest cat]" w+]
d1147 1
a1147 1
test io-8.6 {PeekAhead: change to non-blocking mode} {stdio} {
d1150 1
a1150 1
    set f [open "|[list $::tcltest::tcltest cat]" w+]
d1159 1
a1159 1
test io-8.7 {PeekAhead: cleanup} {stdio} {
d1162 1
a1162 1
    set f [open "|[list $::tcltest::tcltest cat]" w+]
d1184 1
a1184 1
    set f [open "test1" w]
d1188 1
a1188 1
    set f [open "test1"]
d1197 1
a1197 1
    set f [open "test1" w]
d1201 1
a1201 1
    set f [open "test1"]
d1211 1
a1211 1
    set f [open "test1" w]
d1215 1
a1215 1
    set f [open "test1"]
d1224 1
a1224 1
    set f [open "test1" w]
d1228 1
a1228 1
    set f [open "test1"]
d1238 1
a1238 1
    set f [open "test1" w]
d1241 1
a1241 1
    set f [open "test1"]
d1251 1
a1251 1
    set f [open "test1" w]
d1254 1
a1254 1
    set f [open "test1"]
d1264 1
a1264 1
    set f [open "test1" w]
d1267 1
a1267 1
    set f [open "test1"]
d1277 1
a1277 1
    set f [open "test1" w]
d1280 1
a1280 1
    set f [open "test1"]
d1291 1
a1291 1
    set f [open "test1" w]
d1294 1
a1294 1
    set f [open "test1"]
d1303 1
a1303 1
    set f [open "test1" w]
d1306 1
a1306 1
    set f [open "test1"]
d1315 1
a1315 1
    set f [open "test1" w]
d1318 1
a1318 1
    set f [open "test1"]
d1325 1
a1325 1
test io-12.4 {ReadChars: split-up char} {stdio} {
d1328 1
a1328 1
    set f [open "|[list $::tcltest::tcltest cat]" w+]
d1333 1
a1333 1
    fileevent $f read "ready $f"
d1335 2
a1336 1
	lappend ::x [read $f] [testchannel inputbuffered $f]
d1338 1
a1338 1
    set x {}
d1341 1
a1341 1
    vwait x
d1346 1
a1346 1
    vwait x
d1351 1
a1351 1
    makeFile {
d1356 3
a1358 3
    } test1
    set f [open "|[list $::tcltest::tcltest test1]" r+]
    fileevent $f readable {
d1363 1
a1363 1
    }
d1367 4
a1370 4
    set x {}
    vwait x
    after 500 { lappend x timeout }
    vwait x
d1373 3
a1375 3
    vwait x
    after 500 { lappend x timeout }
    vwait x
d1378 2
a1379 2
    vwait x
    vwait x
d1385 1
a1385 1
    set f [open test1 w]
d1389 1
a1389 1
    set f [open test1]
d1396 1
a1396 1
    set f [open test1 w]
d1400 1
a1400 1
    set f [open test1]
d1409 1
a1409 1
    set f [open test1 w]
d1413 1
a1413 1
    set f [open test1]
d1422 1
a1422 1
    set f [open test1 w]
d1426 1
a1426 1
    set f [open test1]
d1435 1
a1435 1
    set f [open test1 w]
d1439 1
a1439 1
    set f [open test1]
d1445 1
a1445 1
test io-13.6 {TranslateInputEOL: auto mode: saw cr in last segment} {stdio} {
d1449 1
a1449 1
    set f [open "|[list $::tcltest::tcltest cat]" w+]
d1452 1
a1452 1
    fileevent $f read "ready $f"
d1454 2
a1455 1
	lappend ::x [read $f] [testchannel queuedcr $f]
d1457 2
a1458 1
    set x {}
d1461 2
a1462 2
    after 500 {set y ok}
    vwait y
d1465 2
a1466 2
    after 500 {set y ok}
    vwait y
d1471 1
a1471 1
test io-13.7 {TranslateInputEOL: auto mode: naked \r} {
d1474 1
a1474 1
    set f [open test1 w]
d1478 1
a1478 1
    set f [open test1]
d1487 1
a1487 1
    set f [open test1 w]
d1491 1
a1491 1
    set f [open test1]
d1498 1
a1498 1
    set f [open test1 w]
d1502 1
a1502 1
    set f [open test1]
d1511 1
a1511 1
    set f [open test1 w]
d1515 1
a1515 1
    set f [open test1]
d1524 1
a1524 1
    set f [open test1 w]
d1528 1
a1528 1
    set f [open test1]
d1537 1
a1537 1
    set f [open test1 w]
d1541 1
a1541 1
    set f [open test1]
d1552 6
a1557 2
if {$tcl_platform(platform) == "macintosh"} {
    set consoleFileNames [list console0 console1 console2]
d1559 2
a1560 1
    set consoleFileNames [lsort [testchannel open]]
d1562 2
a1563 1
test io-14.1 {Tcl_SetStdChannel and Tcl_GetStdChannel} {
d1580 6
a1585 3
test io-14.3 {Tcl_SetStdChannel & Tcl_GetStdChannel} {stdio} {
    set f [open test1 w]
    puts $f {
d1589 3
a1591 3
	set f [open test1 r]
	set f2 [open test2 w]
	set f3 [open test3 w]
d1598 1
a1598 1
    }
d1600 3
a1602 3
    set result [exec $::tcltest::tcltest test1]
    set f [open test2 r]
    set f2 [open test3 r]
d1612 3
a1614 3
test io-14.4 {Tcl_SetStdChannel & Tcl_GetStdChannel} {unixOnly} {
    set f [open test1 w]
    puts $f { close stdin
d1617 3
a1619 3
	set f [open test1 r]
	set f2 [open test2 w]
	set f3 [open test3 w]
d1626 1
a1626 1
    }
d1628 3
a1630 3
    set result [exec $::tcltest::tcltest test1]
    set f [open test2 r]
    set f2 [open test3 r]
d1670 3
d1676 2
a1677 2
    set f [open script w]
    puts $f {
d1679 1
a1679 1
	set f [open test1 w]
d1682 1
a1682 1
	set f [open test1 r]
d1684 1
a1684 1
    }
d1686 1
a1686 1
    set f [open "|[list $::tcltest::tcltest script]" r]
d1691 1
d1695 1
a1695 1
    set f [open script w]
d1697 2
a1698 1
	set f [open test1 w]
d1702 1
a1702 1
	set f [open "|[list [info nameofexecutable] cat test1]" r]
d1706 1
a1706 1
    set f [open "|[list $::tcltest::tcltest script]" r]
d1725 1
a1725 1
test io-17.1 {GetChannelTable, DeleteChannelTable on std handles} {
d1737 1
a1737 1
test io-17.2 {GetChannelTable, DeleteChannelTable on std handles} {
d1749 1
a1749 1
test io-17.3 {GetChannelTable, DeleteChannelTable on std handles} {
d1762 1
a1762 1
test io-18.1 {Tcl_RegisterChannel, Tcl_UnregisterChannel} {
d1765 1
a1765 1
    set f [open test1 w]
d1776 1
a1776 1
test io-18.2 {Tcl_RegisterChannel, Tcl_UnregisterChannel} {
d1779 1
a1779 1
    set f [open test1 w]
d1797 1
a1797 1
test io-18.3 {Tcl_RegisterChannel, Tcl_UnregisterChannel} {
d1800 1
a1800 1
    set f [open test1 w]
d1822 1
a1822 1
    set f [open test1 w]
d1830 1
a1830 1
test io-19.4 {Tcl_CreateChannel, insertion into channel table} {
d1832 1
a1832 1
    set f [open test1 w]
d1846 1
a1846 1
	set a [open test2 w]
d1849 1
a1849 1
    set f [open test1 w]
d1857 1
a1857 1
    set f [open test1 w+]
d1863 1
a1863 1
    set f [open test1 w+]
d1869 1
a1869 1
    set f [open test1 w+]
d1874 3
d1878 2
a1879 2
    set f [open script w]
    puts $f {
d1881 1
a1881 1
	set f1 [open stdout w]
d1884 1
a1884 1
    }
d1886 1
a1886 1
    set f [open "|[list $::tcltest::tcltest script]"]
d1904 1
a1904 1
test io-23.1 {Tcl_GetChannelName} {
d1906 1
a1906 1
    set f [open test1 w]
d1912 1
a1912 1
test io-24.1 {Tcl_GetChannelType} {
d1914 1
a1914 1
    set f [open test1 w]
d1920 2
a1921 2
test io-25.1 {Tcl_GetChannelHandle, input} {
    set f [open test1 w]
d1925 1
a1925 1
    set f [open test1 r]
d1933 1
a1933 1
test io-25.2 {Tcl_GetChannelHandle, output} {
d1935 1
a1935 1
    set f [open test1 w]
d1953 1
a1953 1
    set f [open "|[list $::tcltest::tcltest << exit]"]
d1962 1
a1962 1
    set f [open test1 w]
d1964 1
a1964 1
    set s [file size test1]
d1970 1
a1970 1
    set f [open test1 w]
d1974 1
a1974 1
    lappend l [file size test1]
d1976 1
a1976 1
    lappend l [file size test1]
d1978 1
a1978 1
    lappend l [file size test1]
d1983 1
a1983 1
    set f [open test1 w]
d1987 1
a1987 1
    lappend l [file size test1]
d1989 1
a1989 1
    lappend l [file size test1]
d1994 1
a1994 1
    set f [open test1 w]
d1998 1
a1998 1
    lappend l [file size test1]
d2002 1
a2002 1
    lappend l [file size test1]
d2004 1
a2004 1
    lappend l [file size test1]
d2011 1
a2011 1
    set f [open test1 w]
d2014 1
a2014 1
    lappend l [file size test1]
d2018 1
a2018 1
    lappend l [file size test1]
d2020 1
a2020 1
    lappend l [file size test1]
d2023 4
d2031 3
a2033 3
    set f [open pipe w]
    puts $f {
	set f [open output w]
d2040 1
a2040 1
    }
d2046 1
a2046 1
    set f [open output w]
d2048 1
a2048 1
    set f [open "|[list $::tcltest::tcltest pipe]" w]
d2053 1
a2053 1
    while {([file size output] < 65536) && ($counter < 1000)} {
d2059 1
a2059 1
        set result "file size only [file size output]"
d2067 1
a2067 1
test io-28.1 {CloseChannel called when all references are dropped} {
d2069 1
a2069 1
    set f [open test1 w]
d2082 1
a2082 1
    set f [open test1 w]
d2090 1
a2090 1
    set f [open test1 r]
d2099 1
a2099 1
    set f [open pipe w]
d2109 1
a2109 1
	set f [open output w]
d2122 1
a2122 1
    set f [open output w]
d2124 1
a2124 1
    set f [open "|[list $::tcltest::tcltest pipe]" r+]
d2130 1
a2130 1
    while {([file size output] < 20480) && ($counter < 1000)} {
d2141 1
a2141 1
test io-28.4 {Tcl_Close} {
d2145 1
a2145 1
    set f [open test1 w]
d2154 1
a2154 1
test io-28.5 {Tcl_Close vs standard handles} {stdio unixOnly} {
d2156 1
a2156 1
    set f [open script w]
d2162 1
a2162 1
    set f [open "|[list $::tcltest::tcltest script]" r]
d2173 1
a2173 1
    set f [open test1 w]
d2177 1
a2177 1
    file size test1
d2181 1
a2181 1
    set f [open test1 w]
d2185 1
a2185 1
    file size test1
d2187 1
a2187 1
test io-29.4 {Tcl_WriteChars, buffering in full buffering mode} {
d2189 1
a2189 1
    set f [open test1 w]
d2194 1
a2194 1
    lappend l [file size test1]
d2197 1
a2197 1
    lappend l [file size test1]
d2201 1
a2201 1
test io-29.5 {Tcl_WriteChars, buffering in line buffering mode} {
d2203 1
a2203 1
    set f [open test1 w]
d2208 1
a2208 1
    lappend l [file size test1]
d2211 1
a2211 1
    lappend l [file size test1]
d2215 1
a2215 1
test io-29.6 {Tcl_WriteChars, buffering in no buffering mode} {
d2217 1
a2217 1
    set f [open test1 w]
d2222 1
a2222 1
    lappend l [file size test1]
d2225 1
a2225 1
    lappend l [file size test1]
d2230 1
a2230 1
test io-29.7 {Tcl_Flush, full buffering} {
d2232 1
a2232 1
    set f [open test1 w]
d2237 1
a2237 1
    lappend l [file size test1]
d2240 1
a2240 1
    lappend l [file size test1]
d2243 1
a2243 1
    lappend l [file size test1]
d2247 1
a2247 1
test io-29.8 {Tcl_Flush, full buffering} {
d2249 1
a2249 1
    set f [open test1 w]
d2254 1
a2254 1
    lappend l [file size test1]
d2257 1
a2257 1
    lappend l [file size test1]
d2260 1
a2260 1
    lappend l [file size test1]
d2263 1
a2263 1
    lappend l [file size test1]
d2272 1
a2272 1
    set f1 [open test1 w]
d2274 1
a2274 1
    set f2 [open longfile r]
d2280 1
a2280 1
    file size test1
d2284 1
a2284 1
    set f1 [open test1 w]
d2286 1
a2286 1
    set f2 [open longfile r]
d2292 1
a2292 1
    file size test1
d2297 3
a2299 3
    set f1 [open pipe w]
    puts $f1 {
	set f1 [open longfile r]
d2303 1
a2303 1
    }
d2305 2
a2306 2
    set f1 [open "|[list $::tcltest::tcltest pipe]" r]
    set f2 [open longfile r]
d2322 1
a2322 1
    set f1 [open pipe w]
d2329 1
a2329 1
    set f1 [open "|[list $::tcltest::tcltest pipe]" r+]
d2331 1
a2331 1
    set f2 [open longfile r]
d2350 1
a2350 1
    set f [open test3 w]
d2355 1
a2355 1
    set f [open test3 r]
d2362 1
a2362 1
    set fd [open test1 w]
d2364 1
a2364 1
    set fd [open test1 r]
d2371 1
a2371 1
    set fd [open "|[list $::tcltest::tcltest cat longfile]" r]
d2379 1
a2379 1
    set f1 [open test1 w]
d2385 1
a2385 1
    set x [file size test1]
d2392 1
a2392 1
    set f1 [open test1 w]
d2398 1
a2398 1
    lappend x [file size test1]
d2401 1
a2401 1
    lappend x [file size test1]
d2404 1
a2404 1
    lappend x [file size test1]
d2410 1
a2410 1
    set f1 [open test1 w]
d2417 1
a2417 1
    lappend x [file size test1]
d2420 1
a2420 1
    lappend x [file size test1]
d2423 1
a2423 1
    lappend x [file size test1]
d2428 1
a2428 1
    set f1 [open test1 w]
d2435 1
a2435 1
    lappend z [file size test1]
d2439 1
a2439 1
    lappend z [file size test1]
d2441 1
a2441 1
    lappend z [file size test1]
d2446 1
a2446 1
    set f1 [open pipe w]
d2451 1
a2451 1
    set f1 [open "|[list $::tcltest::tcltest pipe]" r+]
d2460 1
a2460 1
    set f1 [open pipe w]
d2471 1
a2471 1
    set f1 [open "|[list $::tcltest::tcltest pipe]" r+]
d2483 1
a2483 1
    set f1 [open pipe w]
d2491 1
a2491 1
    set f1 [open "|[list $::tcltest::tcltest pipe]" r+]
d2502 1
a2502 1
    set f [open test3 w]
d2505 1
a2505 1
    set f2 [open test3]
d2510 1
a2510 1
    set f2 [open test3]
d2518 1
a2518 1
    set f [open "|[list $::tcltest::tcltest cat | $::tcltest::tcltest cat > test3]" w]
d2523 1
a2523 1
    set f [open test3 r]
d2538 1
a2538 1
    set f [open pipe w]
d2541 1
a2541 1
    set f [open "|[list $::tcltest::tcltest pipe]" r+]
d2566 1
a2566 1
    set f [open test1 w]
d2570 1
a2570 1
    set s [file size test1]
d2576 1
a2576 1
    set f [open test1 w]
d2580 1
a2580 1
    file size test1
d2584 1
a2584 1
    set f [open test1 w]
d2588 1
a2588 1
    file size test1
d2593 2
a2594 2
    set f [open pipe w]
    puts $f {set f [open output w]}
d2608 1
a2608 1
    set f [open output w]
d2610 1
a2610 1
    set f [open "|[list $::tcltest::tcltest pipe]" r+]
d2615 1
a2615 1
    while {([file size output] < 65536) && ($counter < 1000)} {
d2621 1
a2621 1
	set result "file size only [file size output]"
d2630 2
a2631 2
    set f [open pipe w]
    puts $f {set f [open output w]}
d2646 1
a2646 1
    set f [open output w]
d2648 1
a2648 1
    set f [open "|[list $::tcltest::tcltest pipe]" r+]
d2653 1
a2653 1
    while {([file size output] < 65536) && ($counter < 1000)} {
d2659 1
a2659 1
	set result "file size only [file size output]"
d2664 4
a2667 4
test io-29.33 {Tcl_Flush, implicit flush on exit} {stdio} {
    set f [open script w]
    puts $f {
	set f [open test1 w]
d2672 1
a2672 1
    }
d2674 2
a2675 2
    exec $::tcltest::tcltest script
    set f [open test1 r]
d2682 1
a2682 1
    set x running
d2690 2
a2691 2
	global x
	fileevent $s readable [list readit $s]
d2696 2
a2697 1
	global c x
d2707 3
a2709 3
    set ss [socket -server accept 2828]
    set cs [socket [info hostname] 2828]
    vwait x
d2714 1
a2714 1
    vwait x
d2725 1
a2725 1
    set s [socket -server accept 2828]
d2730 1
a2730 1
    set c [socket [info hostname] 2828]
d2763 1
a2763 1
    set f [open test1 w]
d2767 1
a2767 1
    set f [open test1 r]
d2775 1
a2775 1
    set f [open test1 w]
d2779 1
a2779 1
    set f [open test1 r]
d2787 1
a2787 1
    set f [open test1 w]
d2791 1
a2791 1
    set f [open test1 r]
d2799 1
a2799 1
    set f [open test1 w]
d2803 1
a2803 1
    set f [open test1 r]
d2811 1
a2811 1
    set f [open test1 w]
d2815 1
a2815 1
    set f [open test1 r]
d2823 1
a2823 1
    set f [open test1 w]
d2827 1
a2827 1
    set f [open test1 r]
d2835 1
a2835 1
    set f [open test1 w]
d2839 1
a2839 1
    set f [open test1 r]
d2847 1
a2847 1
    set f [open test1 w]
d2851 1
a2851 1
    set f [open test1 r]
d2859 1
a2859 1
    set f [open test1 w]
d2863 1
a2863 1
    set f [open test1 r]
d2871 1
a2871 1
    set f [open test1 w]
d2875 1
a2875 1
    set f [open test1 r]
d2887 1
a2887 1
    set f [open test1 w]
d2891 1
a2891 1
    set f [open test1 r]
d2903 1
a2903 1
    set f [open test1 w]
d2907 1
a2907 1
    set f [open test1 r]
d2920 1
a2920 1
    set f [open test1 w]
d2928 1
a2928 1
    set f [open test1 r]
d2937 1
a2937 1
    set f [open test1 w]
d2945 1
a2945 1
    set f [open test1 r]
d2954 1
a2954 1
    set f [open test1 w]
d2958 1
a2958 1
    set f [open test1 r]
d2970 1
a2970 1
    set f [open test1 w]
d2974 1
a2974 1
    set f [open test1 r]
d2986 1
a2986 1
    set f [open test1 w]
d2990 1
a2990 1
    set f [open test1 r]
d3002 1
a3002 1
    set f [open test1 w]
d3007 1
a3007 1
    set f [open test1 r]
d3022 1
a3022 1
    set f [open test1 w]
d3027 1
a3027 1
    set f [open test1 r]
d3042 1
a3042 1
    set f [open test1 w]
d3047 1
a3047 1
    set f [open test1 r]
d3064 1
a3064 1
    set f [open test1 w]
d3069 1
a3069 1
    set f [open test1 r]
d3082 1
a3082 1
    set f [open test1 w]
d3087 1
a3087 1
    set f [open test1 r]
d3100 1
a3100 1
    set f [open test1 w]
d3105 1
a3105 1
    set f [open test1 r]
d3114 1
a3114 1
    set f [open test1 w]
d3119 1
a3119 1
    set f [open test1 r]
d3128 1
a3128 1
    set f [open test1 w]
d3133 1
a3133 1
    set f [open test1 r]
d3142 1
a3142 1
    set f [open test1 w]
d3147 1
a3147 1
    set f [open test1 r]
d3156 1
a3156 1
    set f [open test1 w]
d3161 1
a3161 1
    set f [open test1 r]
d3170 1
a3170 1
    set f [open test1 w]
d3175 1
a3175 1
    set f [open test1 r]
d3187 1
a3187 1
    set f [open test1 w]
d3191 1
a3191 1
    set f [open test1 r]
d3204 1
a3204 1
    set f [open test1 w]
d3208 1
a3208 1
    set f [open test1 r]
d3221 1
a3221 1
    set f [open test1 w]
d3225 1
a3225 1
    set f [open test1 r]
d3238 1
a3238 1
    set f [open test1 w]
d3242 1
a3242 1
    set f [open test1 r]
d3256 1
a3256 1
    set f [open test1 w]
d3260 1
a3260 1
    set f [open test1 r]
d3276 1
a3276 1
    set f [open test1 w]
d3280 1
a3280 1
    set f [open test1 r]
d3296 1
a3296 1
    set f [open test1 w]
d3300 1
a3300 1
    set f [open test1 r]
d3316 1
a3316 1
    set f [open test1 w]
d3320 1
a3320 1
    set f [open test1 r]
d3336 1
a3336 1
    set f [open test1 w]
d3340 1
a3340 1
    set f [open test1 r]
d3356 1
a3356 1
    set f [open test1 w]
d3360 1
a3360 1
    set f [open test1 r]
d3376 1
a3376 1
    set f [open test1 w]
d3380 1
a3380 1
    set f [open test1 r]
d3396 1
a3396 1
    set f [open test1 w]
d3400 1
a3400 1
    set f [open test1 r]
d3416 1
a3416 1
    set f [open test1 w]
d3428 1
a3428 1
    set f [open test1 w]
d3432 1
a3432 1
    set f [open test1 r]
d3447 1
a3447 1
    set f [open test1 w]
d3451 1
a3451 1
    set f [open test1 r]
d3466 1
a3466 1
    set f [open test1 w]
d3470 1
a3470 1
    set f [open test1 r]
d3484 1
a3484 1
    set f [open test1 w]
d3488 1
a3488 1
    set f [open test1 r]
d3503 1
a3503 1
    set f [open test1 w]
d3508 1
a3508 1
    set f [open test1 r]
d3523 1
a3523 1
    set f [open test1 w]
d3527 1
a3527 1
    set f [open test1 r]
d3542 1
a3542 1
    set f [open test1 w]
d3547 1
a3547 1
    set f [open test1 r]
d3561 1
a3561 1
    set f [open test1 w]
d3566 1
a3566 1
    set f [open test1 r]
d3579 1
a3579 1
    set f [open test1 w]
d3584 1
a3584 1
    set f [open test1 r]
d3601 1
a3601 1
    set f [open test1 w]
d3606 1
a3606 1
    set f [open test1 r]
d3623 1
a3623 1
    set f [open test1 w]
d3628 1
a3628 1
    set f [open test1 r]
d3645 1
a3645 1
    set f [open test1 w]
d3650 1
a3650 1
    set f [open test1 r]
d3663 1
a3663 1
    set f [open test1 w]
d3668 1
a3668 1
    set f [open test1 r]
d3681 1
a3681 1
    set f [open test1 w]
d3686 1
a3686 1
    set f [open test1 r]
d3699 1
a3699 1
    set f [open test1 w]
d3704 1
a3704 1
    set f [open test1 r]
d3717 1
a3717 1
    set f [open test1 w]
d3722 1
a3722 1
    set f [open test1 r]
d3735 1
a3735 1
    set f [open test1 w]
d3740 1
a3740 1
    set f [open test1 r]
d3753 1
a3753 1
    set f [open test1 w]
d3761 1
a3761 1
    set f [open test1 r]
d3772 1
a3772 1
    set f [open test1 w]
d3780 1
a3780 1
    set f [open test1 r]
d3800 1
a3800 1
    set f [open longfile r]
d3806 1
a3806 1
    set f [open longfile r]
d3814 1
a3814 1
    set f [open longfile r]
d3823 1
a3823 1
    set f1 [open longfile r]
d3828 1
a3828 1
    set z [file size longfile]
d3835 1
a3835 1
    set f1 [open longfile r]
d3847 1
a3847 1
    set f1 [open longfile r]
d3852 2
a3853 2
    set l [string length $z]]
    set z [file size longfile]]
d3857 1
a3857 1
  set x
d3860 1
a3860 1
    set f1 [open longfile r]
d3865 1
a3865 1
    set z [file size longfile]
d3873 1
a3873 1
    set f1 [open pipe w]
d3876 1
a3876 1
    set f1 [open "|[list $::tcltest::tcltest pipe]" r+]
d3885 1
a3885 1
    set f1 [open pipe w]
d3889 1
a3889 1
    set f1 [open "|[list $::tcltest::tcltest pipe]" r+]
d3904 1
a3904 1
    set f1 [open test1 w]
d3908 1
a3908 1
    set f1 [open test1 r]
d3916 1
a3916 1
    set f1 [open test1 w]
d3920 1
a3920 1
    set f1 [open test1 r]
d3928 1
a3928 1
    set f [open test1 w]
d3932 1
a3932 1
    set f [open test1]
d3941 1
a3941 1
    set f [open test1 w]
d3945 1
a3945 1
    set f [open test1]
d3954 1
a3954 1
    set f [open test1 w]
d3958 1
a3958 1
    set f [open test1]
d3969 1
a3969 1
    set f1 [open test1 w]
d3973 1
a3973 1
    set f1 [open test1 r]
d3983 1
a3983 1
    set f1 [open longfile r]
d3995 1
a3995 1
    set f1 [open pipe w]
d3998 1
a3998 1
    set f1 [open "|[list $::tcltest::tcltest pipe]" r+]
d4011 1
a4011 1
    set f [open test3 w]
d4018 1
a4018 1
    set f [open test3]
d4024 1
a4024 1
    set f [open test3]
d4031 1
a4031 1
    set f [open test3 w]
d4034 1
a4034 1
    set f [open test3]
d4046 1
a4046 1
    set f [open test3 w]
d4052 1
a4052 1
    set f [open test3 r]
d4058 1
a4058 1
    set f [open test3 w]
d4064 1
a4064 1
    set f [open test3 r]
d4071 1
a4071 1
    set f [open test3 w]
d4077 1
a4077 1
    set f [open test3 r]
d4084 1
a4084 1
    set f [open test3 w]
d4090 1
a4090 1
    set f [open test3 r]
d4100 1
a4100 1
    set f1 [open longfile r]
d4108 1
a4108 1
    set f1 [open test1 w]
d4113 1
a4113 1
    set f1 [open test1 r]
d4121 1
a4121 1
    set f1 [open test1 w]
d4126 1
a4126 1
    set f1 [open test1 r]
d4134 1
a4134 1
    set f1 [open test1 w]
d4139 1
a4139 1
    set f1 [open test1 r]
d4147 1
a4147 1
    set f1 [open test1 w]
d4152 1
a4152 1
    set f1 [open test1 r]
d4161 1
a4161 1
    set f1 [open test1 w]
d4166 1
a4166 1
    set f1 [open test1 r]
d4176 1
a4176 1
    set f1 [open test1 w]
d4181 1
a4181 1
    set f1 [open test1 r]
d4191 1
a4191 1
    set f1 [open "|[list $::tcltest::tcltest]" r+]
d4199 1
a4199 1
    set f [open test3 w]
d4203 1
a4203 1
    set f [open test3 RDWR]
d4220 3
d4224 1
a4224 1
    set f [open test3 w]
d4228 1
a4228 1
    set f [open test3 r+]
d4238 1
a4238 1
    set f [open test3 w]
d4241 1
a4241 1
    set f [open test3 w+]
d4249 1
a4249 1
    set f [open test3 w]
d4253 1
a4253 1
    set f [open test3 a+]
d4267 1
a4267 1
    set f1 [open test1 w]
d4274 1
a4274 1
    set f1 [open test1 w]
d4279 1
a4279 1
    set f1 [open test1 r]
d4287 1
a4287 1
    set f1 [open test1 w]
d4292 1
a4292 1
    set f1 [open test1 r]
d4301 1
a4301 1
    set f1 [open "|[list $::tcltest::tcltest]" r+]
d4307 1
a4307 1
    set f1 [open "|[list $::tcltest::tcltest]" r+]
d4317 1
a4317 1
    set f [open test2 w]
d4321 1
a4321 1
    set f [open test2]
d4336 1
a4336 1
    set f [open test3 w]
d4341 1
a4341 1
    set f [open test3 a]
d4347 1
a4347 1
    set f [open test3 w]
d4361 22
d4388 1
a4388 1
    set f [open test1 w]
d4392 1
a4392 1
    set f [open test1]
d4407 1
a4407 1
    set f1 [open pipe w]
d4411 1
a4411 1
    set f1 [open "|[list $::tcltest::tcltest pipe]" r+]
d4425 1
a4425 1
    set f1 [open pipe w]
d4429 1
a4429 1
    set f1 [open "|[list $::tcltest::tcltest pipe]" r+]
d4447 1
a4447 1
    set f [open test1 w]
d4449 1
a4449 1
    set f [open test1 r]
d4459 1
a4459 1
    set f [open pipe w]
d4464 1
a4464 1
    set f [open "|[list $::tcltest::tcltest pipe]" r]
d4473 1
a4473 1
    set f [open test1 w]
d4477 2
a4478 2
    set s [file size test1]
    set f [open test1 r]
d4487 1
a4487 1
    set f [open test1 w]
d4491 2
a4492 2
    set s [file size test1]
    set f [open test1 r]
d4501 1
a4501 1
    set f [open test1 w]
d4505 2
a4506 2
    set s [file size test1]
    set f [open test1 r]
d4515 1
a4515 1
    set f [open test1 w]
d4519 2
a4520 2
    set s [file size test1]
    set f [open test1 r]
d4529 1
a4529 1
    set f [open test1 w]
d4533 2
a4534 2
    set s [file size test1]
    set f [open test1 r]
d4543 1
a4543 1
    set f [open test1 w]
d4547 2
a4548 2
    set s [file size test1]
    set f [open test1 r]
d4557 1
a4557 1
    set f [open test1 w]
d4562 2
a4563 2
    set c [file size test1]
    set f [open test1 r]
d4572 1
a4572 1
    set f [open test1 w]
d4577 2
a4578 2
    set c [file size test1]
    set f [open test1 r]
d4587 1
a4587 1
    set f [open test1 w]
d4592 2
a4593 2
    set c [file size test1]
    set f [open test1 r]
d4602 1
a4602 1
    set f [open test1 w]
d4607 2
a4608 2
    set c [file size test1]
    set f [open test1 r]
d4617 1
a4617 1
    set f [open test1 w]
d4622 2
a4623 2
    set c [file size test1]
    set f [open test1 r]
d4632 1
a4632 1
    set f [open test1 w]
d4637 2
a4638 2
    set c [file size test1]
    set f [open test1 r]
d4649 1
a4649 1
    set f1 [open "|[list $::tcltest::tcltest]" r+]
d4668 1
a4668 1
    set f1 [open "|[list $::tcltest::tcltest]" r+]
d4683 1
a4683 1
    set f [open test1 w]
d4686 1
a4686 1
    set f [open test1 r]
d4699 2
a4700 1
        global l x
d4705 1
a4705 1
    set f [open test1 w]
d4708 1
a4708 1
    set f [open test1 r]
d4710 3
a4712 2
    fileevent $f readable [list in $f]
    vwait x
d4718 1
a4718 1
    set f [open test1 w]
d4721 1
a4721 1
    set f [open test1 r]
d4735 2
a4736 1
        global l x
d4741 1
a4741 1
    set f [open test1 w]
d4744 1
a4744 1
    set f [open test1 r]
d4747 3
a4749 2
    fileevent $f readable [list in $f]
    vwait x
d4756 2
a4757 2
test io-37.1 {Tcl_InputBuffered} {
    set f [open longfile r]
d4766 2
a4767 2
test io-37.2 {Tcl_InputBuffered, test input flushing on seek} {
    set f [open longfile r]
d4783 1
a4783 1
    set f [open longfile r]
d4789 1
a4789 1
    set f [open longfile r]
d4808 11
d4823 1
a4823 1
    set f1 [open test1 w]
d4833 1
a4833 1
    set f1 [open test1 w]
d4840 1
a4840 1
    set f1 [open test1 w]
d4848 1
a4848 1
    set f1 [open test1 w]
d4864 1
a4864 1
    set f1 [open test1 w]
d4874 1
a4874 1
    set f1 [open test1 w]
d4878 1
a4878 1
    set x [file size test1]
d4884 1
a4884 1
    set f1 [open test1 w]
d4890 1
a4890 1
    lappend x [file size test1]
d4892 1
a4892 1
    lappend x [file size test1]
d4898 1
a4898 1
    set f1 [open test1 w]
d4902 1
a4902 1
    lappend l [file size test1]
d4904 1
a4904 1
    lappend l [file size test1]
d4907 1
a4907 1
    lappend l [file size test1]
d4909 1
a4909 1
    lappend l [file size test1]
d4911 1
a4911 1
    lappend l [file size test1]
d4913 1
a4913 1
    lappend l [file size test1]
d4918 1
a4918 1
    set f1 [open test1 w]
d4920 1
a4920 1
    set f1 [open test1 r]
d4934 1
a4934 1
    set f1 [open pipe w]
d4943 1
a4943 1
    set f1 [open "|[list $::tcltest::tcltest pipe]" r+]
d4970 1
a4970 1
    set f [open test1 w]
d4978 1
a4978 1
    set f [open test1 w]
d4986 1
a4986 1
    set f [open test1 w]
d4994 1
a4994 1
    set f [open test1 w]
d4998 1
a4998 1
    set f [open test1 r]
d5006 1
a5006 1
    set f [open test1 w]
d5010 1
a5010 1
    set f [open test1 r]
d5018 1
a5018 1
    set f [open test1 w]
d5024 1
a5024 1
    set f [open "|[list $::tcltest::tcltest cat]" r+]
d5029 5
a5033 5
    set x {}
    fileevent $f readable { lappend x [read $f] }
    vwait x
    after 300 { lappend x timeout }
    vwait x
d5035 3
a5037 3
    vwait x
    after 300 { lappend x timeout }
    vwait x
d5039 3
a5041 3
    vwait x
    after 300 { lappend x timeout }
    vwait x
d5049 1
a5049 1
    set s1 [socket -server accept 0]
d5062 1
a5062 1
    set s1 [socket -server accept 0]
d5075 1
a5075 1
    set s1 [socket -server accept 0]
d5088 1
a5088 1
    set s1 [socket -server accept 0]
d5099 45
d5146 1
a5146 1
    set f [open test3 w]
d5149 1
a5149 1
    set f [open test3 RDWR]
d5154 1
a5154 1
    set f [open test3 r]
d5161 2
a5162 2
    set f [open test3 {WRONLY CREAT} 0600]
    file stat test3 stats
d5166 1
a5166 1
    set f [open test3 r]
d5174 1
a5174 1
catch {set ::tcltest::testConstraints(umask2) [expr {[exec umask] == 2}]}
d5179 1
a5179 1
    set f [open test3 {WRONLY CREAT}]
d5186 1
a5186 1
    set f [open test3 w]
d5190 1
a5190 1
    set f [open test3 {WRONLY CREAT}]
d5194 1
a5194 1
    set f [open test3 r]
d5201 1
a5201 1
    set f [open test3 w]
d5205 1
a5205 1
    set f [open test3 {WRONLY APPEND}]
d5211 1
a5211 1
    set f [open test3 r]
d5222 1
a5222 1
    set f [open test3 w]
d5225 1
a5225 1
    set msg [list [catch {open test3 {WRONLY CREAT EXCL}} msg] $msg]
d5227 1
d5232 1
a5232 1
    set f [open test3 {WRONLY CREAT EXCL}]
d5240 1
a5240 1
    set f [open test3 w]
d5243 1
a5243 1
    set f [open test3 {WRONLY TRUNC}]
d5246 1
a5246 1
    set f [open test3 r]
d5253 1
a5253 1
    set f [open test3 {WRONLY NONBLOCK CREAT}]
d5256 1
a5256 1
    set f [open test3 r]
d5262 1
a5262 1
    set f [open test1 w]
d5266 1
a5266 1
    set f [open test1 RDONLY]
d5275 3
a5277 1
    string tolower [list [catch {open test3 RDONLY} msg] $msg]
d5281 3
a5283 1
    string tolower [list [catch {open test3 WRONLY} msg] $msg]
d5287 1
a5287 1
    set f [open test3 WRONLY]
d5299 3
a5301 1
    string tolower [list [catch {open test3 RDWR} msg] $msg]
d5305 1
a5305 1
    set f [open test3 RDWR]
d5350 2
a5351 1
set f [open foo w+]
d5413 1
a5413 1
    fileevent $f2 readable {
d5415 1
a5415 1
    }
d5417 2
a5418 2
    set x initial
    vwait x
d5422 1
a5422 4
    proc bgerror args {
	global x
	set x $args
    }
d5425 3
a5427 3
    set x initial
    vwait x
    rename bgerror {}
d5431 1
a5431 1
    fileevent $f2 writable {
d5437 2
a5438 2
    }
    set x initial
d5440 3
a5442 3
    vwait x
    vwait x
    vwait x
d5446 1
a5446 4
    proc bgerror args {
	global x
	set x $args
    }
d5448 3
a5450 3
    set x initial
    vwait x
    rename bgerror {}
d5454 2
a5455 2
    set f4 [open "|[list $::tcltest::tcltest cat << foo]" r]
    fileevent $f4 readable {
d5462 4
a5465 4
    }
    set x initial
    vwait x
    vwait x
d5477 2
a5478 2
    set f [open foo r]
    fileevent $f readable {
d5481 1
a5481 1
    }
d5484 3
a5486 2
    after 100 { set y done }
    vwait y
d5490 3
a5492 3
    set f [open foo r]
    set f2 [open foo r]
    fileevent $f readable {
d5495 2
a5496 2
	}
    fileevent $f2 readable {
d5499 1
a5499 1
    }
d5501 2
a5502 2
    set x initial
    vwait x
d5507 3
a5509 3
    set f [open foo r]
    set f2 [open foo r]
    set f3 [open foo r]
d5529 1
d5531 1
a5531 3
if {[info commands testfevent] == "testfevent"} {

    test io-46.1 {Tcl event loop vs multiple interpreters} {} {
d5533 2
a5534 2
    testfevent cmd {
        set f [open foo r]
d5536 1
a5536 1
        fileevent $f readable {
d5539 2
a5540 2
        }
    } 
d5546 1
a5546 1
test io-46.2 {Tcl event loop vs multiple interpreters} {
d5549 1
a5549 1
        set x 0
d5551 1
a5551 1
        vwait x
d5555 1
a5555 1
test io-46.3 {Tcl event loop vs multiple interpreters} {
d5569 4
a5572 4
test io-47.1 {fileevent vs multiple interpreters} {
    set f [open foo r]
    set f2 [open foo r]
    set f3 [open foo r]
d5588 5
a5592 5
test io-47.2 {deleting fileevent on interpreter delete} {
    set f [open foo r]
    set f2 [open foo r]
    set f3 [open foo r]
    set f4 [open foo r]
d5609 5
a5613 5
test io-47.3 {deleting fileevent on interpreter delete} {
    set f [open foo r]
    set f2 [open foo r]
    set f3 [open foo r]
    set f4 [open foo r]
d5630 3
a5632 3
test io-47.4 {file events on shared files and multiple interpreters} {
    set f [open foo r]
    set f2 [open foo r]
d5646 2
a5647 2
test io-47.5 {file events on shared files, deleting file events} {
    set f [open foo r]
d5659 2
a5660 2
test io-47.6 {file events on shared files, deleting file events} {
    set f [open foo r]
d5673 1
a5673 3
}

# The above curly closes the test for presence of the "testfevent" command.
d5676 1
a5676 1
    set f [open bar w]
d5683 2
a5684 2
    set f [open bar r]
    fileevent $f readable [list consume $f]
d5686 2
a5687 1
	global x l
d5697 2
a5698 2
    set x not_done
    vwait x
d5702 1
a5702 1
    set f [open bar w]
d5709 2
a5710 2
    set f [open bar r]
    fileevent $f readable [list consume $f]
d5713 2
a5714 1
	global x l
d5724 2
a5725 2
    set x not_done
    vwait x
d5728 5
a5732 2
test io-48.3 {testing readability conditions} {unixOnly nonBlockFiles} {
    set f [open bar w]
d5739 1
a5739 1
    set f [open my_script w]
d5750 2
a5751 2
    set f [open "|[list $::tcltest::tcltest]" r+]
    fileevent $f readable [list consume $f]
d5755 2
a5756 1
	global x l
d5767 3
a5769 3
    set x not_done
    puts $f {source my_script}
    puts $f {set f [open bar r]}
d5772 1
a5772 1
    vwait x
d5778 1
a5778 1
    set f [open test1 w]
d5784 3
a5786 1
	global c x l
d5797 1
a5797 1
    set f [open test1 r]
d5799 3
a5801 2
    fileevent $f readable [list consume $f]
    vwait x
d5806 1
a5806 1
    set f [open test1 w]
d5812 3
a5814 1
	global c x l
d5825 1
a5825 1
    set f [open test1 r]
d5827 3
a5829 2
    fileevent $f readable [list consume $f]
    vwait x
d5834 1
a5834 1
    set f [open test1 w]
d5840 3
a5842 1
	global c x l
d5853 1
a5853 1
    set f [open test1 r]
d5855 3
a5857 2
    fileevent $f readable [list consume $f]
    vwait x
d5862 1
a5862 1
    set f [open test1 w]
d5868 3
a5870 1
	global c x l
d5881 1
a5881 1
    set f [open test1 r]
d5883 3
a5885 2
    fileevent $f readable [list consume $f]
    vwait x
d5890 1
a5890 1
    set f [open test1 w]
d5896 3
a5898 1
	global c x l
d5909 1
a5909 1
    set f [open test1 r]
d5911 3
a5913 2
    fileevent $f readable [list consume $f]
    vwait x
d5918 1
a5918 1
    set f [open test1 w]
d5924 3
a5926 1
	global c x l
d5937 1
a5937 1
    set f [open test1 r]
d5939 3
a5941 2
    fileevent $f readable [list consume $f]
    vwait x
d5946 1
a5946 1
    set f [open test1 w]
d5952 3
a5954 1
	global c x l
d5965 1
a5965 1
    set f [open test1 r]
d5967 3
a5969 2
    fileevent $f readable [list consume $f]
    vwait x
d5974 1
a5974 1
    set f [open test1 w]
d5980 3
a5982 1
	global c x l
d5993 1
a5993 1
    set f [open test1 r]
d5995 3
a5997 2
    fileevent $f readable [list consume $f]
    vwait x
d6002 1
a6002 1
    set f [open test1 w]
d6008 3
a6010 1
	global c x l
d6021 1
a6021 1
    set f [open test1 r]
d6023 3
a6025 2
    fileevent $f readable [list consume $f]
    vwait x
d6030 1
a6030 1
    set f [open test1 w]
d6036 3
a6038 1
	global c x l
d6049 1
a6049 1
    set f [open test1 r]
d6051 3
a6053 2
    fileevent $f readable [list consume $f]
    vwait x
d6058 1
a6058 1
    set f [open test1 w]
d6064 3
a6066 1
	global c x l
d6077 1
a6077 1
    set f [open test1 r]
d6079 3
a6081 2
    fileevent $f readable [list consume $f]
    vwait x
d6086 1
a6086 1
    set f [open test1 w]
d6092 3
a6094 1
	global c x l
d6105 1
a6105 1
    set f [open test1 r]
d6107 3
a6109 2
    fileevent $f readable [list consume $f]
    vwait x
d6115 1
a6115 1
    set f [open test1 w]
d6119 1
a6119 1
    set f [open test1 r]
d6121 1
a6121 1
    lappend l [file size test1]
d6144 1
a6144 1
    set f [open test1 w]
d6148 1
a6148 1
    set f [open test1 r]
d6150 1
a6150 1
    lappend l [file size test1]
d6167 1
a6167 1
    set f [open test1 w]
d6171 1
a6171 1
    set f [open test1 r]
d6173 1
a6173 1
    lappend l [file size test1]
d6188 1
a6188 1
    set f [open test1 w]
d6192 1
a6192 1
    set f [open test1 r]
d6194 1
a6194 1
    lappend l [file size test1]
d6209 1
a6209 1
    set f [open test1 w]
d6213 1
a6213 1
    set f [open test1 r]
d6215 1
a6215 1
    lappend l [file size test1]
d6226 2
a6227 1
test io-50.1 {testing handler deletion} {} {
d6229 1
a6229 1
    set f [open test1 w]
d6231 2
a6232 2
    set f [open test1 r]
    testchannelevent $f add readable [list delhandler $f]
d6234 1
a6234 1
	global z
d6243 1
a6243 1
test io-50.2 {testing handler deletion with multiple handlers} {} {
d6245 1
a6245 1
    set f [open test1 w]
d6247 3
a6249 3
    set f [open test1 r]
    testchannelevent $f add readable [list delhandler $f 1]
    testchannelevent $f add readable [list delhandler $f 0]
d6251 1
a6251 1
	global z
d6261 1
a6261 1
test io-50.3 {testing handler deletion with multiple handlers} {} {
d6263 1
a6263 1
    set f [open test1 w]
d6265 3
a6267 3
    set f [open test1 r]
    testchannelevent $f add readable [list notcalled $f 1]
    testchannelevent $f add readable [list delhandler $f 0]
d6270 1
a6270 1
	global z
d6274 1
a6274 1
	global z
d6287 1
a6287 1
test io-50.4 {testing handler deletion vs reentrant calls} {} {
d6289 1
a6289 1
    set f [open test1 w]
d6291 2
a6292 2
    set f [open test1 r]
    testchannelevent $f add readable [list delrecursive $f]
d6294 2
a6295 1
	global z u
d6312 1
a6312 1
test io-50.5 {testing handler deletion vs reentrant calls} {} {
d6314 1
a6314 1
    set f [open test1 w]
d6316 3
a6318 3
    set f [open test1 r]
    testchannelevent $f add readable [list notcalled $f]
    testchannelevent $f add readable [list del $f]
d6320 1
a6320 1
	global z
d6324 2
a6325 1
	global z u
d6346 1
a6346 1
test io-50.6 {testing handler deletion vs reentrant calls} {} {
d6348 1
a6348 1
    set f [open test1 w]
d6350 3
a6352 3
    set f [open test1 r]
    testchannelevent $f add readable [list second $f]
    testchannelevent $f add readable [list first $f]
d6354 2
a6355 1
	global u z
d6366 2
a6367 1
	global u z
d6394 2
a6395 1
	global x wait
d6401 4
a6404 4
    set ss [socket -server accept 2831]
    set wait ""
    set cs [socket [info hostname] 2831]
    vwait wait
d6409 2
a6410 2
    set cs [socket [info hostname] 2831]
    vwait wait
d6415 2
a6416 2
    set cs [socket [info hostname] 2831]
    vwait wait
d6421 2
a6422 2
    set cs [socket [info hostname] 2831]
    vwait wait
d6432 1
a6432 1
    set f2 [open test1 w]
d6442 1
a6442 1
    set f2 [open test1 w]
d6454 1
a6454 1
    set f2 [open test1 w]
d6462 1
a6462 1
    set s2 [file size test1]
d6471 1
a6471 1
    set f2 [open test1 w]
d6478 1
a6478 1
    lappend result [file size test1]
d6483 1
a6483 1
    set f2 [open test1 w]
d6491 1
a6491 1
    set s2 [file size test1]
d6500 1
a6500 1
    set f2 [open test1 w]
d6508 1
a6508 1
    set s2 [file size test1]
d6517 1
a6517 1
    set f2 [open test1 w]
d6523 1
a6523 1
    set s2 [file size test1]
d6534 1
a6534 1
    set f1 [open pipe w]
d6545 1
a6545 1
    set f1 [open "|[list $::tcltest::tcltest pipe]" r+]
d6550 1
a6550 1
    set f2 [open test1 w]
d6555 1
a6555 1
    list $s0 [file size test1]
d6558 79
d6640 1
a6640 1
    set f2 [open test1 w]
d6647 1
a6647 1
    lappend result [file size test1]
d6652 1
a6652 1
    set f2 [open test1 w]
d6655 1
a6655 1
    fcopy $f1 $f2 -command {set s0}
d6657 2
a6658 1
    vwait s0
d6662 1
a6662 1
    set s2 [file size test1]
d6668 1
a6668 1
test io-53.3 {CopyData: background read underflow} {unixOnly} {
d6671 2
a6672 2
    set f1 [open pipe w]
    puts $f1 {
d6677 1
a6677 1
	set f [open test1 w]
d6681 1
a6681 1
    }
d6683 1
a6683 1
    set f1 [open "|[list $::tcltest::tcltest pipe]" r+]
d6693 1
a6693 1
    set f [open test1]
d6698 1
a6698 1
test io-53.4 {CopyData: background write overflow} {unixOnly} {
d6700 1
d6706 1
a6706 1
    set f1 [open pipe w]
d6711 1
a6711 1
	set f [open test1 w]
d6717 1
a6717 1
    set f1 [open "|[list $::tcltest::tcltest pipe]" r+]
d6724 1
a6724 1
    fileevent $f1 read {
d6729 2
a6730 2
    }
    vwait x
d6741 1
a6741 1
    global fcopyTestDone
d6750 2
a6751 1
    set listen [socket -server FcopyTestAccept 2828]
d6753 1
a6753 1
    set out [socket 127.0.0.1 2828]
d6756 2
a6757 1
    fcopy $in $out -command FcopyTestDone
d6759 1
a6759 1
	vwait fcopyTestDone		;# The error occurs here in the b.g.
d6766 1
d6770 1
a6770 1
    set f1 [open pipe w]
d6773 4
a6776 3
    set in [open "|[list $::tcltest::tcltest pipe]" r+]
    set out [open test1 w]
    fcopy $in $out -command [list FcopyTestDone]
d6778 1
a6778 1
	vwait fcopyTestDone
d6785 53
d6843 1
a6843 1
	global as
d6850 2
a6851 1
	global result x
d6854 2
a6855 2
	    fileevent $s readable [list readit $s 2]
	    vwait x
d6859 1
a6859 1
    set ss [socket -server accept 2828]
d6866 1
a6866 1
	if {![catch {set cs [socket [info hostname] 2828]}]} {
d6876 4
a6879 3
    set result {}
    set x 0
    vwait as
d6883 3
a6885 3
    fileevent $cs readable [list readit $cs 1]
    set a [after 2000 { set x failure }]
    vwait x
d6895 1
a6895 1
    set s [socket -server accept 3939]
d6897 2
a6898 1
	global counter accept
d6903 1
a6903 1
	fileevent $s readable "doit $s"
d6906 2
a6907 1
	global counter after
d6912 2
a6913 2
	    fileevent $s readable "doit1 $s"
	    set after [after 1000 newline]
d6917 2
a6918 1
	global counter accept
d6926 2
a6927 1
	global writer
d6929 1
a6929 1
	set writer [socket 127.0.0.1 3939]
d6935 2
a6936 1
	global writer done
d6943 2
a6944 1
    vwait done
d6952 2
d6955 1
d6957 1
d6960 1
a6960 1
	set ::x whoops
d6962 5
a6966 7
    proc bgerror {args} {
	set ::x got_error
    }
    set f [open fooBar w]
    fileevent $f writable [list eventScript $f]
    set x not_done
    vwait x
d6970 2
a6971 2
test io-56.1 {ChannelTimerProc} {
    set f [open fooBar w]
d6974 2
a6975 2
    set f [open fooBar r]
    testchannelevent $f add readable {
d6978 4
a6981 4
    }
    set x 0
    vwait x
    vwait x
d6984 3
a6986 2
    after idle {set y done}
    vwait y
d6993 2
a6994 1
	set ::s2 $sock
d6996 4
a6999 3
    set server [socket -server accept 4040]
    set s [socket 127.0.0.1 4040]
    vwait s2
d7001 1
a7001 1
    fileevent $s2 readable {lappend result readable}
d7004 3
a7006 3
    set result [gets $s2]
    after 1000 {lappend result timer}
    vwait result
d7008 1
a7008 1
    vwait result
d7016 2
a7017 1
	set ::s2 $sock
d7019 4
a7022 3
    set server [socket -server accept 4041]
    set s [socket 127.0.0.1 4041]
    vwait s2
d7024 1
a7024 1
    fileevent $s2 readable {lappend result readable}
d7027 3
a7029 3
    set result [read $s2 1]
    after 1000 {lappend result timer}
    vwait result
d7031 1
a7031 1
    vwait result
d7038 2
a7039 2
test io-58.1 {Tcl_NotifyChannel and error when closing} {unixOrPc} {
    set out [open script w]
d7046 2
a7047 1
	global x result
d7057 3
a7059 3
    set pipe [open "|[list $::tcltest::tcltest] script" r]
    fileevent $pipe readable [list readit $pipe]
    set x ""
d7061 1
a7061 1
    vwait x
a7064 12
# cleanup
foreach file [list fooBar longfile script output test1 pipe my_script foo \
	bar test2 test3 cat stdout] {
    ::tcltest::removeFile $file
}
::tcltest::restoreState
::tcltest::cleanupTests
return




d7066 7
d7074 5
d7081 2
d7084 22
d7107 4
d7115 9
@


1.3
log
@touched all sources to ease next import
@
text
@@


1.3.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d15 1
a15 1
# RCS: @@(#) $Id: io.test,v 1.37 2002/07/30 18:36:26 andreas_kupries Exp $
d17 8
a24 2
if {[catch {package require tcltest 2}]} {
    puts stderr "Skipping tests in [info script].  tcltest 2 required."
a26 1
namespace eval ::tcl::test::io {
d28 1
a28 14
    namespace import ::tcltest::cleanupTests
    namespace import ::tcltest::interpreter
    namespace import ::tcltest::makeFile
    namespace import ::tcltest::removeFile
    namespace import ::tcltest::test
    namespace import ::tcltest::testConstraint
    namespace import ::tcltest::viewFile

testConstraint testchannel [llength [info commands testchannel]]
testConstraint exec [llength [info commands exec]]

# You need a *very* special environment to do some tests.  In
# particular, many file systems do not support large-files...
testConstraint largefileSupport 0
d33 2
d37 1
a37 2
set path(longfile) [makeFile {} longfile]
set f [open $path(longfile) w]
d46 1
a46 1
set path(cat) [makeFile {
d63 1
a63 1
} cat]
a77 3

set path(test1) [makeFile {} test1]

d79 1
a79 1
    set f [open $path(test1) w]
d83 1
a83 1
    contents $path(test1)
d86 1
a86 1
    set f [open $path(test1) w]
d90 1
a90 1
    contents $path(test1)
a92 16
set path(test2) [makeFile {} test2]

test io-1.8 {Tcl_WriteChars: WriteChars} {
    # This test written for SF bug #506297.
    #
    # Executing this test without the fix for the referenced bug
    # applied to tcl will cause tcl, more specifically WriteChars, to
    # go into an infinite loop.

    set f [open $path(test2) w] 
    fconfigure      $f -encoding iso2022-jp 
    puts -nonewline $f [format %s%c [string repeat " " 4] 12399] 
    close           $f 
    contents $path(test2)
} "    \x1b\$B\$O\x1b(B"

d96 1
a96 1
    set f [open $path(test1) w]
d100 1
a100 1
    contents $path(test1)
d106 1
a106 1
    set f [open $path(test1) w]
d109 1
a109 1
    set x [list [contents $path(test1)]]
d111 1
a111 1
    lappend x [contents $path(test1)]
d118 1
a118 1
    set f [open $path(test1) w]
d121 1
a121 1
    set x [contents $path(test1)]
d126 1
a126 1
    set f [open $path(test1) w]
d130 1
a130 1
    set x [list [contents $path(test1)]]
d132 1
a132 1
    lappend x [contents $path(test1)]
d138 1
a138 1
    set f [open $path(test1) w]
d142 1
a142 1
    contents $path(test1)
d148 1
a148 1
    set f [open $path(test1) w]
d151 1
a151 1
    set x [list [contents $path(test1)]]
d153 1
a153 1
    lappend x [contents $path(test1)]
d160 1
a160 1
    set f [open $path(test1) w]
d163 1
a163 1
    set x [contents $path(test1)]
d170 1
a170 1
    set f [open $path(test1) w]
d173 1
a173 1
    set x [list [contents $path(test1)]]
d175 1
a175 1
    lappend x [contents $path(test1)]
d182 1
a182 1
    set f [open $path(test1) w]
d185 1
a185 1
    set x [list [contents $path(test1)]]
d187 1
a187 1
    lappend x [contents $path(test1)]
d199 1
a199 1
    set f [open $path(test1) w]
d202 1
a202 1
    set x [list [contents $path(test1)]]
d204 1
a204 1
    lappend x [contents $path(test1)]
d213 1
a213 1
    set f [open $path(test1) w]
d216 1
a216 1
    set x [list [contents $path(test1)]]
d218 1
a218 1
    lappend x [contents $path(test1)]
d221 1
a221 1
    set f [open $path(test1) w]
d225 1
a225 1
    set x [list [contents $path(test1)]]
d227 1
a227 1
    lappend x [contents $path(test1)]
d233 1
a233 1
    set f [open $path(test1) w]
d236 1
a236 1
    set x [list [contents $path(test1)]]
d238 1
a238 1
    lappend x [contents $path(test1)]
d243 1
a243 1
    set f [open $path(test1) w]
d246 1
a246 1
    set x [list [contents $path(test1)]]
d248 1
a248 1
    lappend x [contents $path(test1)]
d253 1
a253 1
    set f [open $path(test1) w]
d256 1
a256 1
    set x [list [contents $path(test1)]]
d258 1
a258 1
    lappend x [contents $path(test1)]
d265 1
a265 1
    set f [open $path(test1) w]
d268 1
a268 1
    set x [list [contents $path(test1)]]
d270 1
a270 1
    lappend x [contents $path(test1)]
d275 1
a275 1
    set f [open $path(test1) w]
d279 1
a279 1
    set x [contents $path(test1)]
d283 1
a283 1
    set f [open $path(test1) w]
d286 1
a286 1
    set x [list [contents $path(test1)]]
d288 1
a288 1
    lappend x [contents $path(test1)]
d291 1
a291 1
    set f [open $path(test1) w]
d294 1
a294 1
    set x [list [contents $path(test1)]]
d296 1
a296 1
    lappend x [contents $path(test1)]
d299 1
a299 1
    set f [open $path(test1) w]
d302 1
a302 1
    set x [list [contents $path(test1)]]
d304 1
a304 1
    lappend x [contents $path(test1)]
d307 1
a307 1
    set f [open $path(test1) w]
d310 1
a310 1
    set x [list [contents $path(test1)]]
d312 1
a312 1
    lappend x [contents $path(test1)]
d315 1
a315 1
    set f [open $path(test1) w]
d318 1
a318 1
    set x [list [contents $path(test1)]]
d320 1
a320 1
    lappend x [contents $path(test1)]
d324 1
a324 1
    set f [open $path(test1) w]
d327 1
a327 1
    set f [open $path(test1)]
d338 1
a338 1
    set f [open $path(test1) w]
d342 1
a342 1
    set f [open $path(test1)]
d348 1
a348 1
    set f [open $path(test1) w]
d352 1
a352 1
    set f [open $path(test1)]
d359 1
a359 1
    set f [open $path(test1) w]
d363 1
a363 1
    set f [open $path(test1)]
d375 1
a375 1
    set f [open $path(test1) w]
d379 1
a379 1
    set f [open $path(test1)]
d387 1
a387 1
    set f [open "|[list [interpreter] cat]" w+]
d397 1
a397 1
    set f [open $path(test1) w]
d400 1
a400 1
    set f [open $path(test1)]
d407 1
a407 1
    set f [open $path(test1) w]
d410 1
a410 1
    set f [open $path(test1)]
d420 1
a420 1
    set f [open $path(test1) w]
d422 1
a422 1
    set f [open $path(test1)]
d429 1
a429 1
    set f [open $path(test1) w]
d433 1
a433 1
    set f [open $path(test1)]
d440 1
a440 1
    set f [open $path(test1) w]
d444 1
a444 1
    set f [open $path(test1)]
d451 1
a451 1
    set f [open $path(test1) w]
d455 1
a455 1
    set f [open $path(test1)]
d462 1
a462 1
    set f [open $path(test1) w]
d466 1
a466 1
    set f [open $path(test1)]
d473 1
a473 1
    set f [open $path(test1) w]
d477 1
a477 1
    set f [open $path(test1)]
d484 1
a484 1
    set f [open $path(test1) w]
d486 1
a486 1
    set f [open $path(test1)]
d493 1
a493 1
    set f [open $path(test1) w]
d497 1
a497 1
    set f [open $path(test1)]
d504 1
a504 1
    set f [open $path(test1) w]
d508 1
a508 1
    set f [open $path(test1)]
d515 1
a515 1
    set f [open $path(test1) w]
d519 1
a519 1
    set f [open $path(test1)]
d526 1
a526 1
    set f [open $path(test1) w]
d530 1
a530 1
    set f [open $path(test1)]
d537 1
a537 1
    set f [open $path(test1) w]
d541 1
a541 1
    set f [open $path(test1)]
d548 1
a548 1
    set f [open $path(test1) w]
d550 1
a550 1
    set f [open $path(test1)]
d557 1
a557 1
    set f [open $path(test1) w]
d561 1
a561 1
    set f [open $path(test1)]
d568 1
a568 1
    set f [open $path(test1) w]
d572 1
a572 1
    set f [open $path(test1)]
d579 1
a579 1
    set f [open $path(test1) w]
d583 1
a583 1
    set f [open $path(test1)]
d590 1
a590 1
    set f [open $path(test1) w]
d594 1
a594 1
    set f [open $path(test1)]
d601 1
a601 1
    set f [open $path(test1) w]
d605 1
a605 1
    set f [open $path(test1)]
d612 1
a612 1
    set f [open $path(test1) w]
d616 1
a616 1
    set f [open $path(test1)]
d623 1
a623 1
    set f [open $path(test1) w]
d627 1
a627 1
    set f [open $path(test1)]
d633 1
a633 1
test io-6.30 {Tcl_GetsObj: crlf mode: buffer exhausted} {testchannel} {
d636 1
a636 1
    set f [open $path(test1) w]
d640 1
a640 1
    set f [open $path(test1)]
d646 1
a646 1
test io-6.31 {Tcl_GetsObj: crlf mode: buffer exhausted, blocked} {stdio testchannel} {
d649 1
a649 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d659 1
a659 1
test io-6.32 {Tcl_GetsObj: crlf mode: buffer exhausted, more data} {testchannel} {
d662 1
a662 1
    set f [open $path(test1) w]
d666 1
a666 1
    set f [open $path(test1)]
d675 1
a675 1
    set f [open $path(test1) w]
d679 1
a679 1
    set f [open $path(test1)]
d688 1
a688 1
    set f [open $path(test1) w]
d692 1
a692 1
    set f [open $path(test1)]
d699 1
a699 1
    set f [open $path(test1) w]
d701 1
a701 1
    set f [open $path(test1)]
d708 1
a708 1
    set f [open $path(test1) w]
d712 1
a712 1
    set f [open $path(test1)]
d719 1
a719 1
    set f [open $path(test1) w]
d723 1
a723 1
    set f [open $path(test1)]
d730 1
a730 1
    set f [open $path(test1) w]
d734 1
a734 1
    set f [open $path(test1)]
d741 1
a741 1
    set f [open $path(test1) w]
d745 1
a745 1
    set f [open $path(test1)]
d752 1
a752 1
    set f [open $path(test1) w]
d756 1
a756 1
    set f [open $path(test1)]
d763 1
a763 1
    set f [open $path(test1) w]
d767 1
a767 1
    set f [open $path(test1)]
d774 1
a774 1
    set f [open $path(test1) w]
d778 1
a778 1
    set f [open $path(test1)]
d785 1
a785 1
test io-6.43 {Tcl_GetsObj: input saw cr} {stdio testchannel} {
d788 1
a788 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d802 1
a802 1
test io-6.44 {Tcl_GetsObj: input saw cr, not followed by cr} {stdio testchannel} {
d805 1
a805 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d819 1
a819 1
test io-6.45 {Tcl_GetsObj: input saw cr, skip right number of bytes} {stdio testchannel} {
d822 1
a822 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d836 1
a836 1
test io-6.46 {Tcl_GetsObj: input saw cr, followed by just \n should give eof} {stdio testchannel} {
d839 1
a839 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d852 1
a852 1
test io-6.47 {Tcl_GetsObj: auto mode: \r at end of buffer, peek for \n} {testchannel} {
d855 1
a855 1
    set f [open $path(test1) w]
d859 1
a859 1
    set f [open $path(test1)]
d865 1
a865 1
test io-6.48 {Tcl_GetsObj: auto mode: \r at end of buffer, no more avail} {testchannel} {
d868 1
a868 1
    set f [open $path(test1) w]
d872 1
a872 1
    set f [open $path(test1)]
d878 1
a878 1
test io-6.49 {Tcl_GetsObj: auto mode: \r followed by \n} {testchannel} {
d881 1
a881 1
    set f [open $path(test1) w]
d885 1
a885 1
    set f [open $path(test1)]
d890 1
a890 1
test io-6.50 {Tcl_GetsObj: auto mode: \r not followed by \n} {testchannel} {
d893 1
a893 1
    set f [open $path(test1) w]
d897 1
a897 1
    set f [open $path(test1)]
d905 1
a905 1
    set f [open $path(test1) w]
d909 1
a909 1
    set f [open $path(test1)]
d914 1
a914 1
test io-6.52 {Tcl_GetsObj: saw EOF character} {testchannel} {
d917 1
a917 1
    set f [open $path(test1) w]
d921 1
a921 1
    set f [open $path(test1)]
d930 1
a930 1
    set f [open $path(test1) w]
d932 1
a932 1
    set f [open $path(test1)]
d940 1
a940 1
    set f [open $path(test1) w]
d943 1
a943 1
    set f [open $path(test1)]
d951 1
a951 1
    set f [open $path(test1) w]
d955 1
a955 1
    set f [open $path(test1)]
d963 1
a963 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d967 5
a971 5
    variable x {}
    after 500 [namespace code { lappend x timeout }]
    fileevent $f readable [namespace code { lappend x [gets $f] }]
    vwait [namespace which -variable x]
    vwait [namespace which -variable x]
d974 1
a974 1
    after 500 [namespace code { lappend x timeout }]
d976 2
a977 2
    vwait [namespace which -variable x]
    vwait [namespace which -variable x]
d985 1
a985 1
    set f [open $path(test1) w]
d989 1
a989 1
    set f [open $path(test1)]
d998 1
a998 1
    set f [open $path(test1) w]
d1002 1
a1002 1
    set f [open $path(test1)]
d1008 2
a1009 2
test io-7.3 {FilterInputBytes: split up character at EOF} {testchannel} {
    set f [open $path(test1) w]
d1013 1
a1013 1
    set f [open $path(test1)]
d1022 1
a1022 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d1026 2
a1027 2
    fileevent $f read [namespace code "ready $f"]
    variable x {}
d1029 1
a1029 2
	variable x
	lappend x [gets $f line] $line [fblocked $f]
d1031 1
a1031 1
    vwait [namespace which -variable x]
d1035 1
a1035 1
    vwait [namespace which -variable x]
d1040 1
a1040 1
test io-8.1 {PeekAhead: only go to device if no more cached data} {testchannel} {
d1043 1
a1043 1
    set f [open $path(test1) w]
d1047 1
a1047 1
    set f [open $path(test1)]
d1055 1
a1055 1
test io-8.2 {PeekAhead: only go to device if no more cached data} {stdio testchannel} {
d1058 1
a1058 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d1061 2
a1062 2
    variable x {}
    fileevent $f read [namespace code "ready $f"]
d1064 1
a1064 2
	variable x
	lappend x [gets $f line] $line [testchannel inputbuffered $f]
d1067 1
a1067 1
    vwait [namespace which -variable x]
d1070 1
a1070 1
    vwait [namespace which -variable x]
d1074 1
a1074 1
test io-8.3 {PeekAhead: no cached data available} {stdio testchannel} {
d1077 1
a1077 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d1091 1
a1091 1
    set f [open $path(test1) w+]
d1095 1
a1095 1
    set f [open $path(test1)]
d1107 1
a1107 1
test io-8.5 {PeekAhead: don't peek if last read was short} {stdio testchannel} {
d1110 1
a1110 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d1119 1
a1119 1
test io-8.6 {PeekAhead: change to non-blocking mode} {stdio testchannel} {
d1122 1
a1122 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d1131 1
a1131 1
test io-8.7 {PeekAhead: cleanup} {stdio testchannel} {
d1134 1
a1134 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d1156 1
a1156 1
    set f [open $path(test1) w]
d1160 1
a1160 1
    set f [open $path(test1)]
d1169 1
a1169 1
    set f [open $path(test1) w]
d1173 1
a1173 1
    set f [open $path(test1)]
d1183 1
a1183 1
    set f [open $path(test1) w]
d1187 1
a1187 1
    set f [open $path(test1)]
d1196 1
a1196 1
    set f [open $path(test1) w]
d1200 1
a1200 1
    set f [open $path(test1)]
d1210 1
a1210 1
    set f [open $path(test1) w]
d1213 1
a1213 1
    set f [open $path(test1)]
d1223 1
a1223 1
    set f [open $path(test1) w]
d1226 1
a1226 1
    set f [open $path(test1)]
d1236 1
a1236 1
    set f [open $path(test1) w]
d1239 1
a1239 1
    set f [open $path(test1)]
d1249 1
a1249 1
    set f [open $path(test1) w]
d1252 1
a1252 1
    set f [open $path(test1)]
d1263 1
a1263 1
    set f [open $path(test1) w]
d1266 1
a1266 1
    set f [open $path(test1)]
d1275 1
a1275 1
    set f [open $path(test1) w]
d1278 1
a1278 1
    set f [open $path(test1)]
d1287 1
a1287 1
    set f [open $path(test1) w]
d1290 1
a1290 1
    set f [open $path(test1)]
d1297 1
a1297 1
test io-12.4 {ReadChars: split-up char} {stdio testchannel} {
d1300 1
a1300 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d1305 1
a1305 1
    fileevent $f read [namespace code "ready $f"]
d1307 1
a1307 2
	variable x
	lappend x [read $f] [testchannel inputbuffered $f]
d1309 1
a1309 1
    variable x {}
d1312 1
a1312 1
    vwait [namespace which -variable x]
d1317 1
a1317 1
    vwait [namespace which -variable x]
d1322 1
a1322 1
    set path(test1) [makeFile {
d1327 3
a1329 3
    } test1]
    set f [open "|[list [interpreter] $path(test1)]" r+]
    fileevent $f readable [namespace code {
d1334 1
a1334 1
    }]
d1338 4
a1341 4
    variable x {}
    vwait [namespace which -variable x]
    after 500 [namespace code { lappend x timeout }]
    vwait [namespace which -variable x]
d1344 3
a1346 3
    vwait [namespace which -variable x]
    after 500 [namespace code { lappend x timeout }]
    vwait [namespace which -variable x]
d1349 2
a1350 2
    vwait [namespace which -variable x]
    vwait [namespace which -variable x]
d1356 1
a1356 1
    set f [open $path(test1) w]
d1360 1
a1360 1
    set f [open $path(test1)]
d1367 1
a1367 1
    set f [open $path(test1) w]
d1371 1
a1371 1
    set f [open $path(test1)]
d1380 1
a1380 1
    set f [open $path(test1) w]
d1384 1
a1384 1
    set f [open $path(test1)]
d1393 1
a1393 1
    set f [open $path(test1) w]
d1397 1
a1397 1
    set f [open $path(test1)]
d1406 1
a1406 1
    set f [open $path(test1) w]
d1410 1
a1410 1
    set f [open $path(test1)]
d1416 1
a1416 1
test io-13.6 {TranslateInputEOL: auto mode: saw cr in last segment} {stdio testchannel} {
d1420 1
a1420 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d1423 1
a1423 1
    fileevent $f read [namespace code "ready $f"]
d1425 1
a1425 2
	variable x
	lappend x [read $f] [testchannel queuedcr $f]
d1427 1
a1427 2
    variable x {}
    variable y {}
d1430 2
a1431 2
    after 500 [namespace code {set y ok}]
    vwait [namespace which -variable y]
d1434 2
a1435 2
    after 500 [namespace code {set y ok}]
    vwait [namespace which -variable y]
d1440 1
a1440 1
test io-13.7 {TranslateInputEOL: auto mode: naked \r} {testchannel} {
d1443 1
a1443 1
    set f [open $path(test1) w]
d1447 1
a1447 1
    set f [open $path(test1)]
d1456 1
a1456 1
    set f [open $path(test1) w]
d1460 1
a1460 1
    set f [open $path(test1)]
d1467 1
a1467 1
    set f [open $path(test1) w]
d1471 1
a1471 1
    set f [open $path(test1)]
d1480 1
a1480 1
    set f [open $path(test1) w]
d1484 1
a1484 1
    set f [open $path(test1)]
d1493 1
a1493 1
    set f [open $path(test1) w]
d1497 1
a1497 1
    set f [open $path(test1)]
d1506 1
a1506 1
    set f [open $path(test1) w]
d1510 1
a1510 1
    set f [open $path(test1)]
d1521 2
a1522 6
if {[info commands testchannel] != ""} {
    if {$tcl_platform(platform) == "macintosh"} {
	set consoleFileNames [list console0 console1 console2]
    } else {
	set consoleFileNames [lsort [testchannel open]]
    }
d1524 1
a1524 2
    # just to avoid an error
    set consoleFileNames [list]
d1526 1
a1526 2

test io-14.1 {Tcl_SetStdChannel and Tcl_GetStdChannel} {testchannel} {
d1543 3
a1545 6

set path(test3) [makeFile {} test3]

test io-14.3 {Tcl_SetStdChannel & Tcl_GetStdChannel} {exec} {
    set f [open $path(test1) w]
    puts $f [format {
d1549 3
a1551 3
	set f  [open "%s" r]
	set f2 [open "%s" w]
	set f3 [open "%s" w]
d1558 1
a1558 1
    } $path(test1) $path(test2) $path(test3)]
d1560 3
a1562 3
    set result [exec [interpreter] $path(test1)]
    set f  [open $path(test2) r]
    set f2 [open $path(test3) r]
d1572 3
a1574 3
test io-14.4 {Tcl_SetStdChannel & Tcl_GetStdChannel} {exec unixOnly} {
    set f [open $path(test1) w]
    puts $f [format { close stdin
d1577 3
a1579 3
	set f  [open "%s" r]
	set f2 [open "%s" w]
	set f3 [open "%s" w]
d1586 1
a1586 1
    } $path(test1) $path(test2) $path(test3)]
d1588 3
a1590 3
    set result [exec [interpreter] $path(test1)]
    set f  [open $path(test2) r]
    set f2 [open $path(test3) r]
a1629 3

set path(script) [makeFile {} script]

d1633 2
a1634 2
    set f [open $path(script) w]
    puts $f [format {
d1636 1
a1636 1
	set f [open "%s" w]
d1639 1
a1639 1
	set f [open "%s" r]
d1641 1
a1641 1
    } $path(test1) $path(test1)]
d1643 1
a1643 1
    set f [open "|[list [interpreter] $path(script)]" r]
a1647 1

d1651 1
a1651 1
    set f [open $path(script) w]
d1653 1
a1653 2
        array set path [lindex $argv 0]
	set f [open $path(test1) w]
d1657 1
a1657 1
	set f [open "|[list [info nameofexecutable] $path(cat) $path(test1)]" r]
d1661 1
a1661 1
    set f [open "|[list [interpreter] $path(script) [array get path]]" r]
d1680 1
a1680 1
test io-17.1 {GetChannelTable, DeleteChannelTable on std handles} {testchannel} {
d1692 1
a1692 1
test io-17.2 {GetChannelTable, DeleteChannelTable on std handles} {testchannel} {
d1704 1
a1704 1
test io-17.3 {GetChannelTable, DeleteChannelTable on std handles} {testchannel} {
d1717 1
a1717 1
test io-18.1 {Tcl_RegisterChannel, Tcl_UnregisterChannel} {testchannel} {
d1720 1
a1720 1
    set f [open $path(test1) w]
d1731 1
a1731 1
test io-18.2 {Tcl_RegisterChannel, Tcl_UnregisterChannel} {testchannel} {
d1734 1
a1734 1
    set f [open $path(test1) w]
d1752 1
a1752 1
test io-18.3 {Tcl_RegisterChannel, Tcl_UnregisterChannel} {testchannel} {
d1755 1
a1755 1
    set f [open $path(test1) w]
d1777 1
a1777 1
    set f [open $path(test1) w]
d1785 1
a1785 1
test io-19.4 {Tcl_CreateChannel, insertion into channel table} {testchannel} {
d1787 1
a1787 1
    set f [open $path(test1) w]
d1801 1
a1801 1
	set a [open $path(test2) w]
d1804 1
a1804 1
    set f [open $path(test1) w]
d1812 1
a1812 1
    set f [open $path(test1) w+]
d1818 1
a1818 1
    set f [open $path(test1) w+]
d1824 1
a1824 1
    set f [open $path(test1) w+]
a1828 3

set path(stdout) [makeFile {} stdout]

d1830 2
a1831 2
    set f [open $path(script) w]
    puts $f [format {
d1833 1
a1833 1
	set f1 [open "%s" w]
d1836 1
a1836 1
    } $path(stdout)]
d1838 1
a1838 1
    set f [open "|[list [interpreter] $path(script)]"]
d1856 1
a1856 1
test io-23.1 {Tcl_GetChannelName} {testchannel} {
d1858 1
a1858 1
    set f [open $path(test1) w]
d1864 1
a1864 1
test io-24.1 {Tcl_GetChannelType} {testchannel} {
d1866 1
a1866 1
    set f [open $path(test1) w]
d1872 2
a1873 2
test io-25.1 {Tcl_GetChannelHandle, input} {testchannel} {
    set f [open $path(test1) w]
d1877 1
a1877 1
    set f [open $path(test1) r]
d1885 1
a1885 1
test io-25.2 {Tcl_GetChannelHandle, output} {testchannel} {
d1887 1
a1887 1
    set f [open $path(test1) w]
d1905 1
a1905 1
    set f [open "|[list [interpreter] << exit]"]
d1914 1
a1914 1
    set f [open $path(test1) w]
d1916 1
a1916 1
    set s [file size $path(test1)]
d1922 1
a1922 1
    set f [open $path(test1) w]
d1926 1
a1926 1
    lappend l [file size $path(test1)]
d1928 1
a1928 1
    lappend l [file size $path(test1)]
d1930 1
a1930 1
    lappend l [file size $path(test1)]
d1935 1
a1935 1
    set f [open $path(test1) w]
d1939 1
a1939 1
    lappend l [file size $path(test1)]
d1941 1
a1941 1
    lappend l [file size $path(test1)]
d1946 1
a1946 1
    set f [open $path(test1) w]
d1950 1
a1950 1
    lappend l [file size $path(test1)]
d1954 1
a1954 1
    lappend l [file size $path(test1)]
d1956 1
a1956 1
    lappend l [file size $path(test1)]
d1963 1
a1963 1
    set f [open $path(test1) w]
d1966 1
a1966 1
    lappend l [file size $path(test1)]
d1970 1
a1970 1
    lappend l [file size $path(test1)]
d1972 1
a1972 1
    lappend l [file size $path(test1)]
a1974 4

set path(pipe)   [makeFile {} pipe]
set path(output) [makeFile {} output]

d1979 3
a1981 3
    set f [open $path(pipe) w]
    puts $f [format {
	set f [open "%s" w]
d1988 1
a1988 1
    } $path(output)]
d1994 1
a1994 1
    set f [open $path(output) w]
d1996 1
a1996 1
    set f [open "|[list [interpreter] $path(pipe)]" w]
d2001 1
a2001 1
    while {([file size $path(output)] < 65536) && ($counter < 1000)} {
d2007 1
a2007 1
        set result "file size only [file size $path(output)]"
d2015 1
a2015 1
test io-28.1 {CloseChannel called when all references are dropped} {testchannel} {
d2017 1
a2017 1
    set f [open $path(test1) w]
d2030 1
a2030 1
    set f [open $path(test1) w]
d2038 1
a2038 1
    set f [open $path(test1) r]
d2047 1
a2047 1
    set f [open $path(pipe) w]
d2057 1
a2057 1
	set f [open $path(output) w]
d2070 1
a2070 1
    set f [open $path(output) w]
d2072 1
a2072 1
    set f [open "|[list [interpreter] pipe]" r+]
d2078 1
a2078 1
    while {([file size $path(output)] < 20480) && ($counter < 1000)} {
d2089 1
a2089 1
test io-28.4 {Tcl_Close} {testchannel} {
d2093 1
a2093 1
    set f [open $path(test1) w]
d2102 1
a2102 1
test io-28.5 {Tcl_Close vs standard handles} {stdio unixOnly testchannel} {
d2104 1
a2104 1
    set f [open $path(script) w]
d2110 1
a2110 1
    set f [open "|[list [interpreter] $path(script)]" r]
d2121 1
a2121 1
    set f [open $path(test1) w]
d2125 1
a2125 1
    file size $path(test1)
d2129 1
a2129 1
    set f [open $path(test1) w]
d2133 1
a2133 1
    file size $path(test1)
d2135 1
a2135 1
test io-29.4 {Tcl_WriteChars, buffering in full buffering mode} {testchannel} {
d2137 1
a2137 1
    set f [open $path(test1) w]
d2142 1
a2142 1
    lappend l [file size $path(test1)]
d2145 1
a2145 1
    lappend l [file size $path(test1)]
d2149 1
a2149 1
test io-29.5 {Tcl_WriteChars, buffering in line buffering mode} {testchannel} {
d2151 1
a2151 1
    set f [open $path(test1) w]
d2156 1
a2156 1
    lappend l [file size $path(test1)]
d2159 1
a2159 1
    lappend l [file size $path(test1)]
d2163 1
a2163 1
test io-29.6 {Tcl_WriteChars, buffering in no buffering mode} {testchannel} {
d2165 1
a2165 1
    set f [open $path(test1) w]
d2170 1
a2170 1
    lappend l [file size $path(test1)]
d2173 1
a2173 1
    lappend l [file size $path(test1)]
d2178 1
a2178 1
test io-29.7 {Tcl_Flush, full buffering} {testchannel} {
d2180 1
a2180 1
    set f [open $path(test1) w]
d2185 1
a2185 1
    lappend l [file size $path(test1)]
d2188 1
a2188 1
    lappend l [file size $path(test1)]
d2191 1
a2191 1
    lappend l [file size $path(test1)]
d2195 1
a2195 1
test io-29.8 {Tcl_Flush, full buffering} {testchannel} {
d2197 1
a2197 1
    set f [open $path(test1) w]
d2202 1
a2202 1
    lappend l [file size $path(test1)]
d2205 1
a2205 1
    lappend l [file size $path(test1)]
d2208 1
a2208 1
    lappend l [file size $path(test1)]
d2211 1
a2211 1
    lappend l [file size $path(test1)]
d2220 1
a2220 1
    set f1 [open $path(test1) w]
d2222 1
a2222 1
    set f2 [open $path(longfile) r]
d2228 1
a2228 1
    file size $path(test1)
d2232 1
a2232 1
    set f1 [open $path(test1) w]
d2234 1
a2234 1
    set f2 [open $path(longfile) r]
d2240 1
a2240 1
    file size $path(test1)
d2245 3
a2247 3
    set f1 [open $path(pipe) w]
    puts $f1 [format {
	set f1 [open "%s" r]
d2251 1
a2251 1
    } $path(longfile)]
d2253 2
a2254 2
    set f1 [open "|[list [interpreter] $path(pipe)]" r]
    set f2 [open $path(longfile) r]
d2270 1
a2270 1
    set f1 [open $path(pipe) w]
d2277 1
a2277 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d2279 1
a2279 1
    set f2 [open $path(longfile) r]
d2298 1
a2298 1
    set f [open $path(test3) w]
d2303 1
a2303 1
    set f [open $path(test3) r]
d2310 1
a2310 1
    set fd [open $path(test1) w]
d2312 1
a2312 1
    set fd [open $path(test1) r]
d2319 1
a2319 1
    set fd [open "|[list [interpreter] cat longfile]" r]
d2327 1
a2327 1
    set f1 [open $path(test1) w]
d2333 1
a2333 1
    set x [file size $path(test1)]
d2340 1
a2340 1
    set f1 [open $path(test1) w]
d2346 1
a2346 1
    lappend x [file size $path(test1)]
d2349 1
a2349 1
    lappend x [file size $path(test1)]
d2352 1
a2352 1
    lappend x [file size $path(test1)]
d2358 1
a2358 1
    set f1 [open $path(test1) w]
d2365 1
a2365 1
    lappend x [file size $path(test1)]
d2368 1
a2368 1
    lappend x [file size $path(test1)]
d2371 1
a2371 1
    lappend x [file size $path(test1)]
d2376 1
a2376 1
    set f1 [open $path(test1) w]
d2383 1
a2383 1
    lappend z [file size $path(test1)]
d2387 1
a2387 1
    lappend z [file size $path(test1)]
d2389 1
a2389 1
    lappend z [file size $path(test1)]
d2394 1
a2394 1
    set f1 [open $path(pipe) w]
d2399 1
a2399 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d2408 1
a2408 1
    set f1 [open $path(pipe) w]
d2419 1
a2419 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d2431 1
a2431 1
    set f1 [open $path(pipe) w]
d2439 1
a2439 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d2450 1
a2450 1
    set f [open $path(test3) w]
d2453 1
a2453 1
    set f2 [open $path(test3)]
d2458 1
a2458 1
    set f2 [open $path(test3)]
d2466 1
a2466 1
    set f [open "|[list [interpreter] $path(cat) | [interpreter] $path(cat) > $path(test3)]" w]
d2471 1
a2471 1
    set f [open $path(test3) r]
d2486 1
a2486 1
    set f [open $path(pipe) w]
d2489 1
a2489 1
    set f [open "|[list [interpreter] $path(pipe)]" r+]
d2514 1
a2514 1
    set f [open $path(test1) w]
d2518 1
a2518 1
    set s [file size $path(test1)]
d2524 1
a2524 1
    set f [open $path(test1) w]
d2528 1
a2528 1
    file size $path(test1)
d2532 1
a2532 1
    set f [open $path(test1) w]
d2536 1
a2536 1
    file size $path(test1)
d2541 2
a2542 2
    set f [open $path(pipe) w]
    puts $f [format {set f [open "%s" w]} $path(output)]
d2556 1
a2556 1
    set f [open $path(output) w]
d2558 1
a2558 1
    set f [open "|[list [interpreter] $path(pipe)]" r+]
d2563 1
a2563 1
    while {([file size $path(output)] < 65536) && ($counter < 1000)} {
d2569 1
a2569 1
	set result "file size only [file size $path(output)]"
d2578 2
a2579 2
    set f [open $path(pipe) w]
    puts $f [format {set f [open "%s" w]} $path(output)]
d2594 1
a2594 1
    set f [open $path(output) w]
d2596 1
a2596 1
    set f [open "|[list [interpreter] $path(pipe)]" r+]
d2601 1
a2601 1
    while {([file size $path(output)] < 65536) && ($counter < 1000)} {
d2607 1
a2607 1
	set result "file size only [file size $path(output)]"
d2612 4
a2615 4
test io-29.33 {Tcl_Flush, implicit flush on exit} {exec} {
    set f [open $path(script) w]
    puts $f [format {
	set f [open "%s" w]
d2620 1
a2620 1
    } $path(test1)]
d2622 2
a2623 2
    exec [interpreter] $path(script)
    set f [open $path(test1) r]
d2630 1
a2630 1
    variable x running
d2638 2
a2639 2
	variable x
	fileevent $s readable [namespace code [list readit $s]]
d2644 1
a2644 2
	variable c
	variable x
d2654 3
a2656 3
    set ss [socket -server [namespace code accept] 0]
    set cs [socket [info hostname] [lindex [fconfigure $ss -sockname] 2]]
    vwait [namespace which -variable x]
d2661 1
a2661 1
    vwait [namespace which -variable x]
d2672 1
a2672 1
    set s [socket -server [namespace code accept] 0]
d2677 1
a2677 1
    set c [socket [info hostname] [lindex [fconfigure $s -sockname] 2]]
d2710 1
a2710 1
    set f [open $path(test1) w]
d2714 1
a2714 1
    set f [open $path(test1) r]
d2722 1
a2722 1
    set f [open $path(test1) w]
d2726 1
a2726 1
    set f [open $path(test1) r]
d2734 1
a2734 1
    set f [open $path(test1) w]
d2738 1
a2738 1
    set f [open $path(test1) r]
d2746 1
a2746 1
    set f [open $path(test1) w]
d2750 1
a2750 1
    set f [open $path(test1) r]
d2758 1
a2758 1
    set f [open $path(test1) w]
d2762 1
a2762 1
    set f [open $path(test1) r]
d2770 1
a2770 1
    set f [open $path(test1) w]
d2774 1
a2774 1
    set f [open $path(test1) r]
d2782 1
a2782 1
    set f [open $path(test1) w]
d2786 1
a2786 1
    set f [open $path(test1) r]
d2794 1
a2794 1
    set f [open $path(test1) w]
d2798 1
a2798 1
    set f [open $path(test1) r]
d2806 1
a2806 1
    set f [open $path(test1) w]
d2810 1
a2810 1
    set f [open $path(test1) r]
d2818 1
a2818 1
    set f [open $path(test1) w]
d2822 1
a2822 1
    set f [open $path(test1) r]
d2834 1
a2834 1
    set f [open $path(test1) w]
d2838 1
a2838 1
    set f [open $path(test1) r]
d2850 1
a2850 1
    set f [open $path(test1) w]
d2854 1
a2854 1
    set f [open $path(test1) r]
d2867 1
a2867 1
    set f [open $path(test1) w]
d2875 1
a2875 1
    set f [open $path(test1) r]
d2884 1
a2884 1
    set f [open $path(test1) w]
d2892 1
a2892 1
    set f [open $path(test1) r]
d2901 1
a2901 1
    set f [open $path(test1) w]
d2905 1
a2905 1
    set f [open $path(test1) r]
d2917 1
a2917 1
    set f [open $path(test1) w]
d2921 1
a2921 1
    set f [open $path(test1) r]
d2933 1
a2933 1
    set f [open $path(test1) w]
d2937 1
a2937 1
    set f [open $path(test1) r]
d2949 1
a2949 1
    set f [open $path(test1) w]
d2954 1
a2954 1
    set f [open $path(test1) r]
d2969 1
a2969 1
    set f [open $path(test1) w]
d2974 1
a2974 1
    set f [open $path(test1) r]
d2989 1
a2989 1
    set f [open $path(test1) w]
d2994 1
a2994 1
    set f [open $path(test1) r]
d3011 1
a3011 1
    set f [open $path(test1) w]
d3016 1
a3016 1
    set f [open $path(test1) r]
d3029 1
a3029 1
    set f [open $path(test1) w]
d3034 1
a3034 1
    set f [open $path(test1) r]
d3047 1
a3047 1
    set f [open $path(test1) w]
d3052 1
a3052 1
    set f [open $path(test1) r]
d3061 1
a3061 1
    set f [open $path(test1) w]
d3066 1
a3066 1
    set f [open $path(test1) r]
d3075 1
a3075 1
    set f [open $path(test1) w]
d3080 1
a3080 1
    set f [open $path(test1) r]
d3089 1
a3089 1
    set f [open $path(test1) w]
d3094 1
a3094 1
    set f [open $path(test1) r]
d3103 1
a3103 1
    set f [open $path(test1) w]
d3108 1
a3108 1
    set f [open $path(test1) r]
d3117 1
a3117 1
    set f [open $path(test1) w]
d3122 1
a3122 1
    set f [open $path(test1) r]
d3134 1
a3134 1
    set f [open $path(test1) w]
d3138 1
a3138 1
    set f [open $path(test1) r]
d3151 1
a3151 1
    set f [open $path(test1) w]
d3155 1
a3155 1
    set f [open $path(test1) r]
d3168 1
a3168 1
    set f [open $path(test1) w]
d3172 1
a3172 1
    set f [open $path(test1) r]
d3185 1
a3185 1
    set f [open $path(test1) w]
d3189 1
a3189 1
    set f [open $path(test1) r]
d3203 1
a3203 1
    set f [open $path(test1) w]
d3207 1
a3207 1
    set f [open $path(test1) r]
d3223 1
a3223 1
    set f [open $path(test1) w]
d3227 1
a3227 1
    set f [open $path(test1) r]
d3243 1
a3243 1
    set f [open $path(test1) w]
d3247 1
a3247 1
    set f [open $path(test1) r]
d3263 1
a3263 1
    set f [open $path(test1) w]
d3267 1
a3267 1
    set f [open $path(test1) r]
d3283 1
a3283 1
    set f [open $path(test1) w]
d3287 1
a3287 1
    set f [open $path(test1) r]
d3303 1
a3303 1
    set f [open $path(test1) w]
d3307 1
a3307 1
    set f [open $path(test1) r]
d3323 1
a3323 1
    set f [open $path(test1) w]
d3327 1
a3327 1
    set f [open $path(test1) r]
d3343 1
a3343 1
    set f [open $path(test1) w]
d3347 1
a3347 1
    set f [open $path(test1) r]
d3363 1
a3363 1
    set f [open $path(test1) w]
d3375 1
a3375 1
    set f [open $path(test1) w]
d3379 1
a3379 1
    set f [open $path(test1) r]
d3394 1
a3394 1
    set f [open $path(test1) w]
d3398 1
a3398 1
    set f [open $path(test1) r]
d3413 1
a3413 1
    set f [open $path(test1) w]
d3417 1
a3417 1
    set f [open $path(test1) r]
d3431 1
a3431 1
    set f [open $path(test1) w]
d3435 1
a3435 1
    set f [open $path(test1) r]
d3450 1
a3450 1
    set f [open $path(test1) w]
d3455 1
a3455 1
    set f [open $path(test1) r]
d3470 1
a3470 1
    set f [open $path(test1) w]
d3474 1
a3474 1
    set f [open $path(test1) r]
d3489 1
a3489 1
    set f [open $path(test1) w]
d3494 1
a3494 1
    set f [open $path(test1) r]
d3508 1
a3508 1
    set f [open $path(test1) w]
d3513 1
a3513 1
    set f [open $path(test1) r]
d3526 1
a3526 1
    set f [open $path(test1) w]
d3531 1
a3531 1
    set f [open $path(test1) r]
d3548 1
a3548 1
    set f [open $path(test1) w]
d3553 1
a3553 1
    set f [open $path(test1) r]
d3570 1
a3570 1
    set f [open $path(test1) w]
d3575 1
a3575 1
    set f [open $path(test1) r]
d3592 1
a3592 1
    set f [open $path(test1) w]
d3597 1
a3597 1
    set f [open $path(test1) r]
d3610 1
a3610 1
    set f [open $path(test1) w]
d3615 1
a3615 1
    set f [open $path(test1) r]
d3628 1
a3628 1
    set f [open $path(test1) w]
d3633 1
a3633 1
    set f [open $path(test1) r]
d3646 1
a3646 1
    set f [open $path(test1) w]
d3651 1
a3651 1
    set f [open $path(test1) r]
d3664 1
a3664 1
    set f [open $path(test1) w]
d3669 1
a3669 1
    set f [open $path(test1) r]
d3682 1
a3682 1
    set f [open $path(test1) w]
d3687 1
a3687 1
    set f [open $path(test1) r]
d3700 1
a3700 1
    set f [open $path(test1) w]
d3708 1
a3708 1
    set f [open $path(test1) r]
d3719 1
a3719 1
    set f [open $path(test1) w]
d3727 1
a3727 1
    set f [open $path(test1) r]
d3747 1
a3747 1
    set f [open $path(longfile) r]
d3753 1
a3753 1
    set f [open $path(longfile) r]
d3761 1
a3761 1
    set f [open $path(longfile) r]
d3770 1
a3770 1
    set f1 [open $path(longfile) r]
d3775 1
a3775 1
    set z [file size $path(longfile)]
d3782 1
a3782 1
    set f1 [open $path(longfile) r]
d3794 1
a3794 1
    set f1 [open $path(longfile) r]
d3799 2
a3800 2
    set l [string length $z]
    set z [file size $path(longfile)]
d3804 1
a3804 1
    set x
d3807 1
a3807 1
    set f1 [open $path(longfile) r]
d3812 1
a3812 1
    set z [file size $path(longfile)]
d3820 1
a3820 1
    set f1 [open $path(pipe) w]
d3823 1
a3823 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d3832 1
a3832 1
    set f1 [open $path(pipe) w]
d3836 1
a3836 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d3851 1
a3851 1
    set f1 [open $path(test1) w]
d3855 1
a3855 1
    set f1 [open $path(test1) r]
d3863 1
a3863 1
    set f1 [open $path(test1) w]
d3867 1
a3867 1
    set f1 [open $path(test1) r]
d3875 1
a3875 1
    set f [open $path(test1) w]
d3879 1
a3879 1
    set f [open $path(test1)]
d3888 1
a3888 1
    set f [open $path(test1) w]
d3892 1
a3892 1
    set f [open $path(test1)]
d3901 1
a3901 1
    set f [open $path(test1) w]
d3905 1
a3905 1
    set f [open $path(test1)]
d3916 1
a3916 1
    set f1 [open $path(test1) w]
d3920 1
a3920 1
    set f1 [open $path(test1) r]
d3930 1
a3930 1
    set f1 [open $path(longfile) r]
d3942 1
a3942 1
    set f1 [open $path(pipe) w]
d3945 1
a3945 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d3958 1
a3958 1
    set f [open $path(test3) w]
d3965 1
a3965 1
    set f [open $path(test3)]
d3971 1
a3971 1
    set f [open $path(test3)]
d3978 1
a3978 1
    set f [open $path(test3) w]
d3981 1
a3981 1
    set f [open $path(test3)]
d3993 1
a3993 1
    set f [open $path(test3) w]
d3999 1
a3999 1
    set f [open $path(test3) r]
d4005 1
a4005 1
    set f [open $path(test3) w]
d4011 1
a4011 1
    set f [open $path(test3) r]
d4018 1
a4018 1
    set f [open $path(test3) w]
d4024 1
a4024 1
    set f [open $path(test3) r]
d4031 1
a4031 1
    set f [open $path(test3) w]
d4037 1
a4037 1
    set f [open $path(test3) r]
d4047 1
a4047 1
    set f1 [open $path(longfile) r]
d4055 1
a4055 1
    set f1 [open $path(test1) w]
d4060 1
a4060 1
    set f1 [open $path(test1) r]
d4068 1
a4068 1
    set f1 [open $path(test1) w]
d4073 1
a4073 1
    set f1 [open $path(test1) r]
d4081 1
a4081 1
    set f1 [open $path(test1) w]
d4086 1
a4086 1
    set f1 [open $path(test1) r]
d4094 1
a4094 1
    set f1 [open $path(test1) w]
d4099 1
a4099 1
    set f1 [open $path(test1) r]
d4108 1
a4108 1
    set f1 [open $path(test1) w]
d4113 1
a4113 1
    set f1 [open $path(test1) r]
d4123 1
a4123 1
    set f1 [open $path(test1) w]
d4128 1
a4128 1
    set f1 [open $path(test1) r]
d4138 1
a4138 1
    set f1 [open "|[list [interpreter]]" r+]
d4146 1
a4146 1
    set f [open $path(test3) w]
d4150 1
a4150 1
    set f [open $path(test3) RDWR]
a4166 3

set path(test3) [makeFile {} test3]

d4168 1
a4168 1
    set f [open $path(test3) w]
d4172 1
a4172 1
    set f [open $path(test3) r+]
d4182 1
a4182 1
    set f [open $path(test3) w]
d4185 1
a4185 1
    set f [open $path(test3) w+]
d4193 1
a4193 1
    set f [open $path(test3) w]
d4197 1
a4197 1
    set f [open $path(test3) a+]
d4211 1
a4211 1
    set f1 [open $path(test1) w]
d4218 1
a4218 1
    set f1 [open $path(test1) w]
d4223 1
a4223 1
    set f1 [open $path(test1) r]
d4231 1
a4231 1
    set f1 [open $path(test1) w]
d4236 1
a4236 1
    set f1 [open $path(test1) r]
d4245 1
a4245 1
    set f1 [open "|[list [interpreter]]" r+]
d4251 1
a4251 1
    set f1 [open "|[list [interpreter]]" r+]
d4261 1
a4261 1
    set f [open $path(test2) w]
d4265 1
a4265 1
    set f [open $path(test2)]
d4280 1
a4280 1
    set f [open $path(test3) w]
d4285 1
a4285 1
    set f [open $path(test3) a]
d4291 1
a4291 1
    set f [open $path(test3) w]
a4304 22
test io-34.21 {Tcl_Seek and Tcl_Tell on large files} {largefileSupport} {
    removeFile test3
    set f [open $path(test3) w]
    fconfigure $f -encoding binary
    set l ""
    lappend l [tell $f]
    puts -nonewline $f abcdef
    lappend l [tell $f]
    flush $f
    lappend l [tell $f]
    # 4GB offset!
    seek $f 0x100000000
    lappend l [tell $f]
    puts -nonewline $f abcdef
    lappend l [tell $f]
    close $f
    lappend l [file size $f]
    # truncate...
    close [open $path(test3) w]
    lappend l [file size $f]
    set l
} {0 6 6 4294967296 4294967302 4294967302 0}
d4310 1
a4310 1
    set f [open $path(test1) w]
d4314 1
a4314 1
    set f [open $path(test1)]
d4329 1
a4329 1
    set f1 [open $path(pipe) w]
d4333 1
a4333 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d4347 1
a4347 1
    set f1 [open $path(pipe) w]
d4351 1
a4351 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d4369 1
a4369 1
    set f [open $path(test1) w]
d4371 1
a4371 1
    set f [open $path(test1) r]
d4381 1
a4381 1
    set f [open $path(pipe) w]
d4386 1
a4386 1
    set f [open "|[list [interpreter] $path(pipe)]" r]
d4395 1
a4395 1
    set f [open $path(test1) w]
d4399 2
a4400 2
    set s [file size $path(test1)]
    set f [open $path(test1) r]
d4409 1
a4409 1
    set f [open $path(test1) w]
d4413 2
a4414 2
    set s [file size $path(test1)]
    set f [open $path(test1) r]
d4423 1
a4423 1
    set f [open $path(test1) w]
d4427 2
a4428 2
    set s [file size $path(test1)]
    set f [open $path(test1) r]
d4437 1
a4437 1
    set f [open $path(test1) w]
d4441 2
a4442 2
    set s [file size $path(test1)]
    set f [open $path(test1) r]
d4451 1
a4451 1
    set f [open $path(test1) w]
d4455 2
a4456 2
    set s [file size $path(test1)]
    set f [open $path(test1) r]
d4465 1
a4465 1
    set f [open $path(test1) w]
d4469 2
a4470 2
    set s [file size $path(test1)]
    set f [open $path(test1) r]
d4479 1
a4479 1
    set f [open $path(test1) w]
d4484 2
a4485 2
    set c [file size $path(test1)]
    set f [open $path(test1) r]
d4494 1
a4494 1
    set f [open $path(test1) w]
d4499 2
a4500 2
    set c [file size $path(test1)]
    set f [open $path(test1) r]
d4509 1
a4509 1
    set f [open $path(test1) w]
d4514 2
a4515 2
    set c [file size $path(test1)]
    set f [open $path(test1) r]
d4524 1
a4524 1
    set f [open $path(test1) w]
d4529 2
a4530 2
    set c [file size $path(test1)]
    set f [open $path(test1) r]
d4539 1
a4539 1
    set f [open $path(test1) w]
d4544 2
a4545 2
    set c [file size $path(test1)]
    set f [open $path(test1) r]
d4554 1
a4554 1
    set f [open $path(test1) w]
d4559 2
a4560 2
    set c [file size $path(test1)]
    set f [open $path(test1) r]
d4571 1
a4571 1
    set f1 [open "|[list [interpreter]]" r+]
d4590 1
a4590 1
    set f1 [open "|[list [interpreter]]" r+]
d4605 1
a4605 1
    set f [open $path(test1) w]
d4608 1
a4608 1
    set f [open $path(test1) r]
d4621 1
a4621 2
        variable l
        variable x
d4626 1
a4626 1
    set f [open $path(test1) w]
d4629 1
a4629 1
    set f [open $path(test1) r]
d4631 2
a4632 3
    fileevent $f readable [namespace code [list in $f]]
    variable x
    vwait [namespace which -variable x]
d4638 1
a4638 1
    set f [open $path(test1) w]
d4641 1
a4641 1
    set f [open $path(test1) r]
d4655 1
a4655 2
        variable l
        variable x
d4660 1
a4660 1
    set f [open $path(test1) w]
d4663 1
a4663 1
    set f [open $path(test1) r]
d4666 2
a4667 3
    fileevent $f readable [namespace code [list in $f]]
    variable x
    vwait [namespace which -variable x]
d4674 2
a4675 2
test io-37.1 {Tcl_InputBuffered} {testchannel} {
    set f [open $path(longfile) r]
d4684 2
a4685 2
test io-37.2 {Tcl_InputBuffered, test input flushing on seek} {testchannel} {
    set f [open $path(longfile) r]
d4701 1
a4701 1
    set f [open $path(longfile) r]
d4707 1
a4707 1
    set f [open $path(longfile) r]
a4725 11
test io-38.3 {Tcl_SetChannelBufferSize, changing buffersize between reads} {
    # This test crashes the interp if Bug #427196 is not fixed

    set chan [open [info script] r]
    fconfigure $chan -buffersize 10
    set var [read $chan 2]
    fconfigure $chan -buffersize 32
    append var [read $chan]
    close $chan
} {}

d4730 1
a4730 1
    set f1 [open $path(test1) w]
d4740 1
a4740 1
    set f1 [open $path(test1) w]
d4747 1
a4747 1
    set f1 [open $path(test1) w]
d4755 1
a4755 1
    set f1 [open $path(test1) w]
d4771 1
a4771 1
    set f1 [open $path(test1) w]
d4781 1
a4781 1
    set f1 [open $path(test1) w]
d4785 1
a4785 1
    set x [file size $path(test1)]
d4791 1
a4791 1
    set f1 [open $path(test1) w]
d4797 1
a4797 1
    lappend x [file size $path(test1)]
d4799 1
a4799 1
    lappend x [file size $path(test1)]
d4805 1
a4805 1
    set f1 [open $path(test1) w]
d4809 1
a4809 1
    lappend l [file size $path(test1)]
d4811 1
a4811 1
    lappend l [file size $path(test1)]
d4814 1
a4814 1
    lappend l [file size $path(test1)]
d4816 1
a4816 1
    lappend l [file size $path(test1)]
d4818 1
a4818 1
    lappend l [file size $path(test1)]
d4820 1
a4820 1
    lappend l [file size $path(test1)]
d4825 1
a4825 1
    set f1 [open $path(test1) w]
d4827 1
a4827 1
    set f1 [open $path(test1) r]
d4841 1
a4841 1
    set f1 [open $path(pipe) w]
d4850 1
a4850 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d4877 1
a4877 1
    set f [open $path(test1) w]
d4885 1
a4885 1
    set f [open $path(test1) w]
d4893 1
a4893 1
    set f [open $path(test1) w]
d4901 1
a4901 1
    set f [open $path(test1) w]
d4905 1
a4905 1
    set f [open $path(test1) r]
d4913 1
a4913 1
    set f [open $path(test1) w]
d4917 1
a4917 1
    set f [open $path(test1) r]
d4925 1
a4925 1
    set f [open $path(test1) w]
d4931 1
a4931 1
    set f [open "|[list [interpreter] $path(cat)]" r+]
d4936 5
a4940 5
    variable x {}
    fileevent $f readable [namespace code { lappend x [read $f] }]
    vwait [namespace which -variable x]
    after 300 [namespace code { lappend x timeout }]
    vwait [namespace which -variable x]
d4942 3
a4944 3
    vwait [namespace which -variable x]
    after 300 [namespace code { lappend x timeout }]
    vwait [namespace which -variable x]
d4946 3
a4948 3
    vwait [namespace which -variable x]
    after 300 [namespace code { lappend x timeout }]
    vwait [namespace which -variable x]
d4956 1
a4956 1
    set s1 [socket -server [namespace code accept] 0]
d4969 1
a4969 1
    set s1 [socket -server [namespace code accept] 0]
d4982 1
a4982 1
    set s1 [socket -server [namespace code accept] 0]
d4995 1
a4995 1
    set s1 [socket -server [namespace code accept] 0]
a5005 45
test io-39.22 {Tcl_SetChannelOption, invariance} {unixOnly} {
    removeFile test1
    set f1 [open $path(test1) w+]
    set l ""
    lappend l [fconfigure $f1 -eofchar]
    fconfigure $f1 -eofchar {ON GO}
    lappend l [fconfigure $f1 -eofchar]
    fconfigure $f1 -eofchar D
    lappend l [fconfigure $f1 -eofchar]
    close $f1
    set l
} {{{} {}} {O G} {D D}}

test io-39.22a {Tcl_SetChannelOption, invariance} {
    removeFile test1
    set f1 [open $path(test1) w+]
    set l [list]
    fconfigure $f1 -eofchar {ON GO}
    lappend l [fconfigure $f1 -eofchar]
    fconfigure $f1 -eofchar D
    lappend l [fconfigure $f1 -eofchar]
    lappend l [list [catch {fconfigure $f1 -eofchar {1 2 3}} msg] $msg]
    close $f1
    set l
} {{O G} {D D} {1 {bad value for -eofchar: should be a list of zero, one, or two elements}}}


test io-39.23 {Tcl_GetChannelOption, server socket is not readable or
        writeable, it should still have valid -eofchar and -translation options } {
    set l [list]
    set sock [socket -server [namespace code accept] 0]
    lappend l [fconfigure $sock -eofchar] [fconfigure $sock -translation]
    close $sock
    set l
} {{{}} auto}
test io-39.24 {Tcl_SetChannelOption, server socket is not readable or
        writable so we can't change -eofchar or -translation } {
    set l [list]
    set sock [socket -server [namespace code accept] 0]
    fconfigure $sock -eofchar D -translation lf
    lappend l [fconfigure $sock -eofchar] [fconfigure $sock -translation]
    close $sock
    set l
} {{{}} auto}

d5008 1
a5008 1
    set f [open $path(test3) w]
d5011 1
a5011 1
    set f [open $path(test3) RDWR]
d5016 1
a5016 1
    set f [open $path(test3) r]
d5023 2
a5024 2
    set f [open $path(test3) {WRONLY CREAT} 0600]
    file stat $path(test3) stats
d5028 1
a5028 1
    set f [open $path(test3) r]
d5036 1
a5036 1
catch {testConstraint umask2 [expr {[exec umask] == 2}]}
d5041 1
a5041 1
    set f [open $path(test3) {WRONLY CREAT}]
d5048 1
a5048 1
    set f [open $path(test3) w]
d5052 1
a5052 1
    set f [open $path(test3) {WRONLY CREAT}]
d5056 1
a5056 1
    set f [open $path(test3) r]
d5063 1
a5063 1
    set f [open $path(test3) w]
d5067 1
a5067 1
    set f [open $path(test3) {WRONLY APPEND}]
d5073 1
a5073 1
    set f [open $path(test3) r]
d5084 1
a5084 1
    set f [open $path(test3) w]
d5087 1
a5087 1
    set msg [list [catch {open $path(test3) {WRONLY CREAT EXCL}} msg] $msg]
a5088 1
    regsub [file join {} $path(test3)] $msg "test3" msg
d5093 1
a5093 1
    set f [open $path(test3) {WRONLY CREAT EXCL}]
d5101 1
a5101 1
    set f [open $path(test3) w]
d5104 1
a5104 1
    set f [open $path(test3) {WRONLY TRUNC}]
d5107 1
a5107 1
    set f [open $path(test3) r]
d5114 1
a5114 1
    set f [open $path(test3) {WRONLY NONBLOCK CREAT}]
d5117 1
a5117 1
    set f [open $path(test3) r]
d5123 1
a5123 1
    set f [open $path(test1) w]
d5127 1
a5127 1
    set f [open $path(test1) RDONLY]
d5136 1
a5136 3
    set msg [list [catch {open $path(test3) RDONLY} msg] $msg]
    regsub [file join {} $path(test3)] $msg "test3" msg
	string tolower $msg
d5140 1
a5140 3
    set msg [list [catch {open $path(test3) WRONLY} msg] $msg]
    regsub [file join {} $path(test3)] $msg "test3" msg
	string tolower $msg
d5144 1
a5144 1
    set f [open $path(test3) WRONLY]
d5156 1
a5156 3
    set msg [list [catch {open $path(test3) RDWR} msg] $msg]
    regsub [file join {} $path(test3)] $msg "test3" msg
	string tolower $msg
d5160 1
a5160 1
    set f [open $path(test3) RDWR]
d5205 1
a5205 2
set path(foo) [makeFile {} foo]
set f [open $path(foo) w+]
d5267 1
a5267 1
    fileevent $f2 readable [namespace code {
d5269 1
a5269 1
    }]
d5271 2
a5272 2
    variable x initial
    vwait [namespace which -variable x]
d5276 4
a5279 1
    proc ::bgerror args "set [namespace which -variable x] \$args"
d5282 3
a5284 3
    variable x initial
    vwait [namespace which -variable x]
    rename ::bgerror {}
d5288 1
a5288 1
    fileevent $f2 writable [namespace code {
d5294 2
a5295 2
    }]
    variable x initial
d5297 3
a5299 3
    vwait [namespace which -variable x]
    vwait [namespace which -variable x]
    vwait [namespace which -variable x]
d5303 4
a5306 1
    proc ::bgerror args "set [namespace which -variable x] \$args"
d5308 3
a5310 3
    variable x initial
    vwait [namespace which -variable x]
    rename ::bgerror {}
d5314 2
a5315 2
    set f4 [open "|[list [interpreter] $path(cat) << foo]" r]
    fileevent $f4 readable [namespace code {
d5322 4
a5325 4
    }]
    variable x initial
    vwait [namespace which -variable x]
    vwait [namespace which -variable x]
d5337 2
a5338 2
    set f [open $path(foo) r]
    fileevent $f readable [namespace code {
d5341 1
a5341 1
    }]
d5344 2
a5345 3
    after 100 [namespace code { set y done }]
    variable y
    vwait [namespace which -variable y]
d5349 3
a5351 3
    set f  [open $path(foo) r]
    set f2 [open $path(foo) r]
    fileevent $f readable [namespace code {
d5354 2
a5355 2
	}]
    fileevent $f2 readable [namespace code {
d5358 1
a5358 1
    }]
d5360 2
a5361 2
    variable x initial
    vwait [namespace which -variable x]
d5366 3
a5368 3
    set f  [open $path(foo) r]
    set f2 [open $path(foo) r]
    set f3 [open $path(foo) r]
a5387 1
testConstraint testfevent [llength [info commands testfevent]]
d5389 3
a5391 1
test io-46.1 {Tcl event loop vs multiple interpreters} {testfevent} {
d5393 2
a5394 2
    testfevent cmd [format {
        set f [open %s r]
d5396 1
a5396 1
        fileevent $f readable [namespace code {
d5399 2
a5400 2
        }]
    } $path(foo)]
d5406 1
a5406 1
test io-46.2 {Tcl event loop vs multiple interpreters} testfevent {
d5409 1
a5409 1
        variable x 0
d5411 1
a5411 1
        vwait [namespace which -variable x]
d5415 1
a5415 1
test io-46.3 {Tcl event loop vs multiple interpreters} testfevent {
d5429 4
a5432 4
test io-47.1 {fileevent vs multiple interpreters} testfevent {
    set f  [open $path(foo) r]
    set f2 [open $path(foo) r]
    set f3 [open $path(foo) r]
d5448 5
a5452 5
test io-47.2 {deleting fileevent on interpreter delete} testfevent {
    set f  [open $path(foo) r]
    set f2 [open $path(foo) r]
    set f3 [open $path(foo) r]
    set f4 [open $path(foo) r]
d5469 5
a5473 5
test io-47.3 {deleting fileevent on interpreter delete} testfevent {
    set f  [open $path(foo) r]
    set f2 [open $path(foo) r]
    set f3 [open $path(foo) r]
    set f4 [open $path(foo) r]
d5490 3
a5492 3
test io-47.4 {file events on shared files and multiple interpreters} testfevent {
    set f  [open $path(foo) r]
    set f2 [open $path(foo) r]
d5506 2
a5507 2
test io-47.5 {file events on shared files, deleting file events} testfevent {
    set f [open $path(foo) r]
d5519 2
a5520 2
test io-47.6 {file events on shared files, deleting file events} testfevent {
    set f [open $path(foo) r]
d5533 3
a5535 1
set path(bar) [makeFile {} bar]
d5538 1
a5538 1
    set f [open $path(bar) w]
d5545 2
a5546 2
    set f [open $path(bar) r]
    fileevent $f readable [namespace code [list consume $f]]
d5548 1
a5548 2
	variable l
	variable x
d5558 2
a5559 2
    variable x not_done
    vwait [namespace which -variable x]
d5563 1
a5563 1
    set f [open $path(bar) w]
d5570 2
a5571 2
    set f [open $path(bar) r]
    fileevent $f readable [namespace code [list consume $f]]
d5574 1
a5574 2
	variable x
	variable l
d5584 2
a5585 2
    variable x not_done
    vwait [namespace which -variable x]
d5588 2
a5589 5

set path(my_script) [makeFile {} my_script]

test io-48.3 {testing readability conditions} {stdio unixOnly nonBlockFiles} {
    set f [open $path(bar) w]
d5596 1
a5596 1
    set f [open $path(my_script) w]
d5607 2
a5608 2
    set f [open "|[list [interpreter]]" r+]
    fileevent $f readable [namespace code [list consume $f]]
d5612 1
a5612 2
	variable l
	variable x
d5623 3
a5625 3
    variable x not_done
    puts $f [format {source %s}         $path(my_script)]
    puts $f [format {set f [open %s r]} $path(bar)]
d5628 1
a5628 1
    vwait [namespace which -variable x]
d5634 1
a5634 1
    set f [open $path(test1) w]
d5640 1
a5640 3
	variable l
	variable c
	variable x
d5651 1
a5651 1
    set f [open $path(test1) r]
d5653 2
a5654 3
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
d5659 1
a5659 1
    set f [open $path(test1) w]
d5665 1
a5665 3
	variable l
	variable x
	variable c
d5676 1
a5676 1
    set f [open $path(test1) r]
d5678 2
a5679 3
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
d5684 1
a5684 1
    set f [open $path(test1) w]
d5690 1
a5690 3
	variable l
	variable x
	variable c
d5701 1
a5701 1
    set f [open $path(test1) r]
d5703 2
a5704 3
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
d5709 1
a5709 1
    set f [open $path(test1) w]
d5715 1
a5715 3
	variable l
	variable c
	variable x
d5726 1
a5726 1
    set f [open $path(test1) r]
d5728 2
a5729 3
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
d5734 1
a5734 1
    set f [open $path(test1) w]
d5740 1
a5740 3
	variable l
	variable x
	variable c
d5751 1
a5751 1
    set f [open $path(test1) r]
d5753 2
a5754 3
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
d5759 1
a5759 1
    set f [open $path(test1) w]
d5765 1
a5765 3
	variable l
	variable c
	variable x
d5776 1
a5776 1
    set f [open $path(test1) r]
d5778 2
a5779 3
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
d5784 1
a5784 1
    set f [open $path(test1) w]
d5790 1
a5790 3
	variable l
	variable c
	variable x
d5801 1
a5801 1
    set f [open $path(test1) r]
d5803 2
a5804 3
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
d5809 1
a5809 1
    set f [open $path(test1) w]
d5815 1
a5815 3
	variable l
	variable x
	variable c
d5826 1
a5826 1
    set f [open $path(test1) r]
d5828 2
a5829 3
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
d5834 1
a5834 1
    set f [open $path(test1) w]
d5840 1
a5840 3
	variable l
	variable x
	variable c
d5851 1
a5851 1
    set f [open $path(test1) r]
d5853 2
a5854 3
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
d5859 1
a5859 1
    set f [open $path(test1) w]
d5865 1
a5865 3
	variable c
	variable x
	variable l
d5876 1
a5876 1
    set f [open $path(test1) r]
d5878 2
a5879 3
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
d5884 1
a5884 1
    set f [open $path(test1) w]
d5890 1
a5890 3
	variable c
	variable x
	variable l
d5901 1
a5901 1
    set f [open $path(test1) r]
d5903 2
a5904 3
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
d5909 1
a5909 1
    set f [open $path(test1) w]
d5915 1
a5915 3
	variable c
	variable x
	variable l
d5926 1
a5926 1
    set f [open $path(test1) r]
d5928 2
a5929 3
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
d5935 1
a5935 1
    set f [open $path(test1) w]
d5939 1
a5939 1
    set f [open $path(test1) r]
d5941 1
a5941 1
    lappend l [file size $path(test1)]
d5964 1
a5964 1
    set f [open $path(test1) w]
d5968 1
a5968 1
    set f [open $path(test1) r]
d5970 1
a5970 1
    lappend l [file size $path(test1)]
d5987 1
a5987 1
    set f [open $path(test1) w]
d5991 1
a5991 1
    set f [open $path(test1) r]
d5993 1
a5993 1
    lappend l [file size $path(test1)]
d6008 1
a6008 1
    set f [open $path(test1) w]
d6012 1
a6012 1
    set f [open $path(test1) r]
d6014 1
a6014 1
    lappend l [file size $path(test1)]
d6029 1
a6029 1
    set f [open $path(test1) w]
d6033 1
a6033 1
    set f [open $path(test1) r]
d6035 1
a6035 1
    lappend l [file size $path(test1)]
d6046 1
a6046 2
testConstraint testchannelevent [llength [info commands testchannelevent]]
test io-50.1 {testing handler deletion} {testchannelevent} {
d6048 1
a6048 1
    set f [open $path(test1) w]
d6050 2
a6051 2
    set f [open $path(test1) r]
    testchannelevent $f add readable [namespace code [list delhandler $f]]
d6053 1
a6053 1
	variable z
d6062 1
a6062 1
test io-50.2 {testing handler deletion with multiple handlers} {testchannelevent} {
d6064 1
a6064 1
    set f [open $path(test1) w]
d6066 3
a6068 3
    set f [open $path(test1) r]
    testchannelevent $f add readable [namespace code [list delhandler $f 1]]
    testchannelevent $f add readable [namespace code [list delhandler $f 0]]
d6070 1
a6070 1
	variable z
d6080 1
a6080 1
test io-50.3 {testing handler deletion with multiple handlers} {testchannelevent} {
d6082 1
a6082 1
    set f [open $path(test1) w]
d6084 3
a6086 3
    set f [open $path(test1) r]
    testchannelevent $f add readable [namespace code [list notcalled $f 1]]
    testchannelevent $f add readable [namespace code [list delhandler $f 0]]
d6089 1
a6089 1
	variable z
d6093 1
a6093 1
	variable z
d6106 1
a6106 1
test io-50.4 {testing handler deletion vs reentrant calls} {testchannelevent} {
d6108 1
a6108 1
    set f [open $path(test1) w]
d6110 2
a6111 2
    set f [open $path(test1) r]
    testchannelevent $f add readable [namespace code [list delrecursive $f]]
d6113 1
a6113 2
	variable z
	variable u
d6130 1
a6130 1
test io-50.5 {testing handler deletion vs reentrant calls} {testchannelevent} {
d6132 1
a6132 1
    set f [open $path(test1) w]
d6134 3
a6136 3
    set f [open $path(test1) r]
    testchannelevent $f add readable [namespace code [list notcalled $f]]
    testchannelevent $f add readable [namespace code [list del $f]]
d6138 1
a6138 1
	variable z
d6142 1
a6142 2
	variable u
	variable z
d6163 1
a6163 1
test io-50.6 {testing handler deletion vs reentrant calls} {testchannelevent} {
d6165 1
a6165 1
    set f [open $path(test1) w]
d6167 3
a6169 3
    set f [open $path(test1) r]
    testchannelevent $f add readable [namespace code [list second $f]]
    testchannelevent $f add readable [namespace code [list first $f]]
d6171 1
a6171 2
	variable u
	variable z
d6182 1
a6182 2
	variable u
	variable z
d6209 1
a6209 2
	variable x
	variable wait
d6215 4
a6218 4
    set ss [socket -server [namespace code accept] 0]
    variable wait ""
    set cs [socket [info hostname] [lindex [fconfigure $ss -sockname] 2]]
    vwait [namespace which -variable wait]
d6223 2
a6224 2
    set cs [socket [info hostname] [lindex [fconfigure $ss -sockname] 2]]
    vwait [namespace which -variable wait]
d6229 2
a6230 2
    set cs [socket [info hostname] [lindex [fconfigure $ss -sockname] 2]]
    vwait [namespace which -variable wait]
d6235 2
a6236 2
    set cs [socket [info hostname] [lindex [fconfigure $ss -sockname] 2]]
    vwait [namespace which -variable wait]
d6246 1
a6246 1
    set f2 [open $path(test1) w]
d6256 1
a6256 1
    set f2 [open $path(test1) w]
d6268 1
a6268 1
    set f2 [open $path(test1) w]
d6276 1
a6276 1
    set s2 [file size $path(test1)]
d6285 1
a6285 1
    set f2 [open $path(test1) w]
d6292 1
a6292 1
    lappend result [file size $path(test1)]
d6297 1
a6297 1
    set f2 [open $path(test1) w]
d6305 1
a6305 1
    set s2 [file size $path(test1)]
d6314 1
a6314 1
    set f2 [open $path(test1) w]
d6322 1
a6322 1
    set s2 [file size $path(test1)]
d6331 1
a6331 1
    set f2 [open $path(test1) w]
d6337 1
a6337 1
    set s2 [file size $path(test1)]
d6348 1
a6348 1
    set f1 [open $path(pipe) w]
d6359 1
a6359 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d6364 1
a6364 1
    set f2 [open $path(test1) w]
d6369 1
a6369 1
    list $s0 [file size $path(test1)]
a6371 79
# Empty files, to register them with the test facility
set path(kyrillic.txt)   [makeFile {} kyrillic.txt]
set path(utf8-fcopy.txt) [makeFile {} utf8-fcopy.txt]
set path(utf8-rp.txt)    [makeFile {} utf8-rp.txt]

# Create kyrillic file, use lf translation to avoid os eol issues
set out [open $path(kyrillic.txt) w]
fconfigure $out -encoding koi8-r -translation lf
puts       $out "\u0410\u0410"
close      $out

test io-52.9 {TclCopyChannel & encodings} {
    # Copy kyrillic to UTF-8, using fcopy.

    set in  [open $path(kyrillic.txt) r]
    set out [open $path(utf8-fcopy.txt) w]

    fconfigure $in  -encoding koi8-r -translation lf
    fconfigure $out -encoding utf-8 -translation lf

    fcopy $in $out
    close $in
    close $out

    # Do the same again, but differently (read/puts).

    set in  [open $path(kyrillic.txt) r]
    set out [open $path(utf8-rp.txt) w]

    fconfigure $in  -encoding koi8-r -translation lf
    fconfigure $out -encoding utf-8 -translation lf

    puts -nonewline $out [read $in]

    close $in
    close $out

    list [file size $path(kyrillic.txt)] \
	    [file size $path(utf8-fcopy.txt)] \
	    [file size $path(utf8-rp.txt)]
} {3 5 5}

test io-52.10 {TclCopyChannel & encodings} {
    # encoding to binary (=> implies that the
    # internal utf-8 is written)

    set in  [open $path(kyrillic.txt) r]
    set out [open $path(utf8-fcopy.txt) w]

    fconfigure $in  -encoding koi8-r -translation lf
    # -translation binary is also -encoding binary
    fconfigure $out -translation binary

    fcopy $in $out
    close $in
    close $out

    file size $path(utf8-fcopy.txt)
} 5

test io-52.11 {TclCopyChannel & encodings} {
    # binary to encoding => the input has to be
    # in utf-8 to make sense to the encoder

    set in  [open $path(utf8-fcopy.txt) r]
    set out [open $path(kyrillic.txt) w]

    # -translation binary is also -encoding binary
    fconfigure $in  -translation binary
    fconfigure $out -encoding koi8-r -translation lf

    fcopy $in $out
    close $in
    close $out

    file size $path(kyrillic.txt)
} 3


d6375 1
a6375 1
    set f2 [open $path(test1) w]
d6382 1
a6382 1
    lappend result [file size $path(test1)]
d6387 1
a6387 1
    set f2 [open $path(test1) w]
d6390 1
a6390 1
    fcopy $f1 $f2 -command [namespace code {set s0}]
d6392 1
a6392 2
    variable s0
    vwait [namespace which -variable s0]
d6396 1
a6396 1
    set s2 [file size $path(test1)]
d6402 1
a6402 1
test io-53.3 {CopyData: background read underflow} {stdio unixOnly} {
d6405 2
a6406 2
    set f1 [open $path(pipe) w]
    puts $f1 [format {
d6411 1
a6411 1
	set f [open "%s" w]
d6415 1
a6415 1
    } $path(test1)]
d6417 1
a6417 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d6427 1
a6427 1
    set f [open $path(test1)]
d6432 1
a6432 1
test io-53.4 {CopyData: background write overflow} {stdio unixOnly} {
a6433 1
    variable x
d6439 1
a6439 1
    set f1 [open $path(pipe) w]
d6444 1
a6444 1
	set f [open $path(test1) w]
d6450 1
a6450 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d6457 1
a6457 1
    fileevent $f1 read [namespace code {
d6462 2
a6463 2
    }]
    vwait [namespace which -variable x]
d6474 1
a6474 1
    variable fcopyTestDone
d6483 1
a6483 2
    variable fcopyTestDone
    set listen [socket -server [namespace code FcopyTestAccept] 0]
d6485 1
a6485 1
    set out [socket 127.0.0.1 [lindex [fconfigure $listen -sockname] 2]]
d6488 1
a6488 2
    fcopy $in $out -command [namespace code FcopyTestDone]
    variable fcopyTestDone
d6490 1
a6490 1
	vwait [namespace which -variable fcopyTestDone]		;# The error occurs here in the b.g.
a6496 1
    variable fcopyTestDone
d6500 1
a6500 1
    set f1 [open $path(pipe) w]
d6503 3
a6505 4
    set in [open "|[list [interpreter] $path(pipe)]" r+]
    set out [open $path(test1) w]
    fcopy $in $out -command [namespace code FcopyTestDone]
    variable fcopyTestDone
d6507 1
a6507 1
	vwait [namespace which -variable fcopyTestDone]
a6513 53
proc doFcopy {in out {bytes 0} {error {}}} {
    variable fcopyTestDone
    variable fcopyTestCount
    incr fcopyTestCount $bytes
    if {[string length $error]} {
	    set fcopyTestDone 1
    } elseif {[eof $in]} {
	    set fcopyTestDone 0
    } else {
        # Delay next fcopy to wait for size>0 input bytes
        after 100 [list 
            fcopy $in $out -size 1000 \
		    -command [namespace code [list doFcopy $in $out]]
        ]
    }
}

test io-53.7 {CopyData: Flooding fcopy from pipe} {stdio} {
    variable fcopyTestDone
    removeFile pipe
    removeFile test1
    catch {unset fcopyTestDone}
    set fcopyTestCount 0
    set f1 [open $path(pipe) w]
    puts $f1 {
	# Write  10 bytes / 10 msec
	proc Write {count} {
	    puts -nonewline "1234567890"
	    if {[incr count -1]} {
	        after 10 [list Write $count]
	    } else {
	        set ::ready 1
	    }
	}
	fconfigure stdout -buffering none
	Write 345 ;# 3450 bytes ~3.45 sec
	vwait ready
	exit 0
    }
    close $f1
    set in [open "|[list [interpreter] $path(pipe) &]" r+]
    set out [open $path(test1) w]
    doFcopy $in $out
    variable fcopyTestDone
    if ![info exists fcopyTestDone] {
	vwait [namespace which -variable fcopyTestDone]
    }
    catch {close $in}
    close $out
    # -1=error 0=script error N=number of bytes
    expr ($fcopyTestDone == 0) ? $fcopyTestCount : -1
} {3450}

d6519 1
a6519 1
	variable as
d6526 1
a6526 2
	variable x
	variable result
d6529 2
a6530 2
	    fileevent $s readable [namespace code [list readit $s 2]]
	    vwait [namespace which -variable x]
d6534 1
a6534 1
    set ss [socket -server [namespace code accept] 0]
d6541 1
a6541 1
	if {![catch {set cs [socket [info hostname] [lindex [fconfigure $ss -sockname] 2]]}]} {
d6551 3
a6553 4
    variable result {}
    variable x 0
    variable as
    vwait [namespace which -variable as]
d6557 3
a6559 3
    fileevent $cs readable [namespace code [list readit $cs 1]]
    set a [after 2000 [namespace code { set x failure }]]
    vwait [namespace which -variable x]
d6569 1
a6569 1
    variable s [socket -server [namespace code accept] 0]
d6571 1
a6571 2
	variable counter
	variable accept
d6576 1
a6576 1
	fileevent $s readable [namespace code "doit $s"]
d6579 1
a6579 2
	variable counter
	variable after
d6584 2
a6585 2
	    fileevent $s readable [namespace code "doit1 $s"]
	    set after [after 1000 [namespace code newline]]
d6589 1
a6589 2
	variable counter
	variable accept
d6597 1
a6597 2
	variable s
	variable writer
d6599 1
a6599 1
	set writer [socket 127.0.0.1 [lindex [fconfigure $s -sockname] 2]]
d6605 1
a6605 2
	variable done
	variable writer
d6612 1
a6612 2
    variable done
    vwait [namespace which -variable done]
a6619 2
set path(fooBar) [makeFile {} fooBar]

a6620 1
    variable x
a6621 1
	variable x
d6624 1
a6624 1
	set x whoops
d6626 7
a6632 5
    proc ::bgerror {args} "set [namespace which -variable x] got_error"
    set f [open $path(fooBar) w]
    fileevent $f writable [namespace code [list eventScript $f]]
    variable x not_done
    vwait [namespace which -variable x]
d6636 2
a6637 2
test io-56.1 {ChannelTimerProc} {testchannelevent} {
    set f [open $path(fooBar) w]
d6640 2
a6641 2
    set f [open $path(fooBar) r]
    testchannelevent $f add readable [namespace code {
d6644 4
a6647 4
    }]
    variable x 0
    vwait [namespace which -variable x]
    vwait [namespace which -variable x]
d6650 2
a6651 3
    after idle [namespace code {set y done}]
    variable y
    vwait [namespace which -variable y]
d6658 1
a6658 2
	variable s2
	set s2 $sock
d6660 3
a6662 4
    set server [socket -server [namespace code accept] 0]
    set s [socket 127.0.0.1 [lindex [fconfigure $server -sockname] 2]]
    variable s2
    vwait [namespace which -variable s2]
d6664 1
a6664 1
    fileevent $s2 readable [namespace code {lappend result readable}]
d6667 3
a6669 3
    variable result [gets $s2]
    after 1000 [namespace code {lappend result timer}]
    vwait [namespace which -variable result]
d6671 1
a6671 1
    vwait [namespace which -variable result]
d6679 1
a6679 2
	variable s2
	set s2 $sock
d6681 3
a6683 4
    set server [socket -server [namespace code accept] 0]
    set s [socket 127.0.0.1 [lindex [fconfigure $server -sockname] 2]]
    variable s2
    vwait [namespace which -variable s2]
d6685 1
a6685 1
    fileevent $s2 readable [namespace code {lappend result readable}]
d6688 3
a6690 3
    variable result [read $s2 1]
    after 1000 [namespace code {lappend result timer}]
    vwait [namespace which -variable result]
d6692 1
a6692 1
    vwait [namespace which -variable result]
d6699 2
a6700 2
test io-58.1 {Tcl_NotifyChannel and error when closing} {stdio unixOrPc} {
    set out [open $path(script) w]
d6707 1
a6707 2
	variable x
	variable result
d6717 3
a6719 3
    set pipe [open "|[list [interpreter] $path(script)]" r]
    fileevent $pipe readable [namespace code [list readit $pipe]]
    variable x ""
d6721 1
a6721 1
    vwait [namespace which -variable x]
d6725 12
a6737 7
testConstraint testmainthread [llength [info commands testmainthread]]
test io-59.1 {Thread reference of channels} {testmainthread testchannel} {
    # TIP #10
    # More complicated tests (like that the reference changes as a
    # channel is moved from thread to thread) can be done only in the
    # extension which fully implements the moving of channels between
    # threads, i.e. 'Threads'. Or we have to extend [testthread] as well.
a6738 5
    set f [open $path(longfile) r]
    set result [testchannel mthread $f]
    close $f
    string equal $result [testmainthread]
} {1}
a6740 2
test io-60.1 {writing illegal utf sequences} {
    # This test will hang in older revisions of the core.
a6741 22
    set out [open $path(script) w]
    puts $out {
	puts [encoding convertfrom identity \xe2]
	exit 1
    }
    proc readit {pipe} {
	variable x
	variable result
	if {[eof $pipe]} {
	    set x [catch {close $pipe} line]
	    lappend result catch $line
	} else {
	    gets $pipe line
	    lappend result gets $line
	}
    }
    close $out
    set pipe [open "|[list [interpreter] $path(script)]" r]
    fileevent $pipe readable [namespace code [list readit $pipe]]
    variable x ""
    set result ""
    vwait [namespace which -variable x]
a6742 4
    # cut of the remainder of the error stack, especially the filename
    set result [lreplace $result 3 3 [lindex [split [lindex $result 3] \n] 0]]
    list $x $result
} {1 {gets {} catch {error writing "stdout": invalid argument}}}
a6746 9
# cleanup
foreach file [list fooBar longfile script output test1 pipe my_script foo \
	bar test2 test3 cat stdout] {
    removeFile $file
}
cleanupTests
}
namespace delete ::tcl::test::io
return
@


1.3.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@d15 1
a15 1
# RCS: @@(#) $Id: io.test,v 1.37 2002/07/30 18:36:26 andreas_kupries Exp $
d17 8
a24 2
if {[catch {package require tcltest 2}]} {
    puts stderr "Skipping tests in [info script].  tcltest 2 required."
a26 1
namespace eval ::tcl::test::io {
d28 1
a28 14
    namespace import ::tcltest::cleanupTests
    namespace import ::tcltest::interpreter
    namespace import ::tcltest::makeFile
    namespace import ::tcltest::removeFile
    namespace import ::tcltest::test
    namespace import ::tcltest::testConstraint
    namespace import ::tcltest::viewFile

testConstraint testchannel [llength [info commands testchannel]]
testConstraint exec [llength [info commands exec]]

# You need a *very* special environment to do some tests.  In
# particular, many file systems do not support large-files...
testConstraint largefileSupport 0
d33 2
d37 1
a37 2
set path(longfile) [makeFile {} longfile]
set f [open $path(longfile) w]
d46 1
a46 1
set path(cat) [makeFile {
d63 1
a63 1
} cat]
a77 3

set path(test1) [makeFile {} test1]

d79 1
a79 1
    set f [open $path(test1) w]
d83 1
a83 1
    contents $path(test1)
d86 1
a86 1
    set f [open $path(test1) w]
d90 1
a90 1
    contents $path(test1)
a92 16
set path(test2) [makeFile {} test2]

test io-1.8 {Tcl_WriteChars: WriteChars} {
    # This test written for SF bug #506297.
    #
    # Executing this test without the fix for the referenced bug
    # applied to tcl will cause tcl, more specifically WriteChars, to
    # go into an infinite loop.

    set f [open $path(test2) w] 
    fconfigure      $f -encoding iso2022-jp 
    puts -nonewline $f [format %s%c [string repeat " " 4] 12399] 
    close           $f 
    contents $path(test2)
} "    \x1b\$B\$O\x1b(B"

d96 1
a96 1
    set f [open $path(test1) w]
d100 1
a100 1
    contents $path(test1)
d106 1
a106 1
    set f [open $path(test1) w]
d109 1
a109 1
    set x [list [contents $path(test1)]]
d111 1
a111 1
    lappend x [contents $path(test1)]
d118 1
a118 1
    set f [open $path(test1) w]
d121 1
a121 1
    set x [contents $path(test1)]
d126 1
a126 1
    set f [open $path(test1) w]
d130 1
a130 1
    set x [list [contents $path(test1)]]
d132 1
a132 1
    lappend x [contents $path(test1)]
d138 1
a138 1
    set f [open $path(test1) w]
d142 1
a142 1
    contents $path(test1)
d148 1
a148 1
    set f [open $path(test1) w]
d151 1
a151 1
    set x [list [contents $path(test1)]]
d153 1
a153 1
    lappend x [contents $path(test1)]
d160 1
a160 1
    set f [open $path(test1) w]
d163 1
a163 1
    set x [contents $path(test1)]
d170 1
a170 1
    set f [open $path(test1) w]
d173 1
a173 1
    set x [list [contents $path(test1)]]
d175 1
a175 1
    lappend x [contents $path(test1)]
d182 1
a182 1
    set f [open $path(test1) w]
d185 1
a185 1
    set x [list [contents $path(test1)]]
d187 1
a187 1
    lappend x [contents $path(test1)]
d199 1
a199 1
    set f [open $path(test1) w]
d202 1
a202 1
    set x [list [contents $path(test1)]]
d204 1
a204 1
    lappend x [contents $path(test1)]
d213 1
a213 1
    set f [open $path(test1) w]
d216 1
a216 1
    set x [list [contents $path(test1)]]
d218 1
a218 1
    lappend x [contents $path(test1)]
d221 1
a221 1
    set f [open $path(test1) w]
d225 1
a225 1
    set x [list [contents $path(test1)]]
d227 1
a227 1
    lappend x [contents $path(test1)]
d233 1
a233 1
    set f [open $path(test1) w]
d236 1
a236 1
    set x [list [contents $path(test1)]]
d238 1
a238 1
    lappend x [contents $path(test1)]
d243 1
a243 1
    set f [open $path(test1) w]
d246 1
a246 1
    set x [list [contents $path(test1)]]
d248 1
a248 1
    lappend x [contents $path(test1)]
d253 1
a253 1
    set f [open $path(test1) w]
d256 1
a256 1
    set x [list [contents $path(test1)]]
d258 1
a258 1
    lappend x [contents $path(test1)]
d265 1
a265 1
    set f [open $path(test1) w]
d268 1
a268 1
    set x [list [contents $path(test1)]]
d270 1
a270 1
    lappend x [contents $path(test1)]
d275 1
a275 1
    set f [open $path(test1) w]
d279 1
a279 1
    set x [contents $path(test1)]
d283 1
a283 1
    set f [open $path(test1) w]
d286 1
a286 1
    set x [list [contents $path(test1)]]
d288 1
a288 1
    lappend x [contents $path(test1)]
d291 1
a291 1
    set f [open $path(test1) w]
d294 1
a294 1
    set x [list [contents $path(test1)]]
d296 1
a296 1
    lappend x [contents $path(test1)]
d299 1
a299 1
    set f [open $path(test1) w]
d302 1
a302 1
    set x [list [contents $path(test1)]]
d304 1
a304 1
    lappend x [contents $path(test1)]
d307 1
a307 1
    set f [open $path(test1) w]
d310 1
a310 1
    set x [list [contents $path(test1)]]
d312 1
a312 1
    lappend x [contents $path(test1)]
d315 1
a315 1
    set f [open $path(test1) w]
d318 1
a318 1
    set x [list [contents $path(test1)]]
d320 1
a320 1
    lappend x [contents $path(test1)]
d324 1
a324 1
    set f [open $path(test1) w]
d327 1
a327 1
    set f [open $path(test1)]
d338 1
a338 1
    set f [open $path(test1) w]
d342 1
a342 1
    set f [open $path(test1)]
d348 1
a348 1
    set f [open $path(test1) w]
d352 1
a352 1
    set f [open $path(test1)]
d359 1
a359 1
    set f [open $path(test1) w]
d363 1
a363 1
    set f [open $path(test1)]
d375 1
a375 1
    set f [open $path(test1) w]
d379 1
a379 1
    set f [open $path(test1)]
d387 1
a387 1
    set f [open "|[list [interpreter] cat]" w+]
d397 1
a397 1
    set f [open $path(test1) w]
d400 1
a400 1
    set f [open $path(test1)]
d407 1
a407 1
    set f [open $path(test1) w]
d410 1
a410 1
    set f [open $path(test1)]
d420 1
a420 1
    set f [open $path(test1) w]
d422 1
a422 1
    set f [open $path(test1)]
d429 1
a429 1
    set f [open $path(test1) w]
d433 1
a433 1
    set f [open $path(test1)]
d440 1
a440 1
    set f [open $path(test1) w]
d444 1
a444 1
    set f [open $path(test1)]
d451 1
a451 1
    set f [open $path(test1) w]
d455 1
a455 1
    set f [open $path(test1)]
d462 1
a462 1
    set f [open $path(test1) w]
d466 1
a466 1
    set f [open $path(test1)]
d473 1
a473 1
    set f [open $path(test1) w]
d477 1
a477 1
    set f [open $path(test1)]
d484 1
a484 1
    set f [open $path(test1) w]
d486 1
a486 1
    set f [open $path(test1)]
d493 1
a493 1
    set f [open $path(test1) w]
d497 1
a497 1
    set f [open $path(test1)]
d504 1
a504 1
    set f [open $path(test1) w]
d508 1
a508 1
    set f [open $path(test1)]
d515 1
a515 1
    set f [open $path(test1) w]
d519 1
a519 1
    set f [open $path(test1)]
d526 1
a526 1
    set f [open $path(test1) w]
d530 1
a530 1
    set f [open $path(test1)]
d537 1
a537 1
    set f [open $path(test1) w]
d541 1
a541 1
    set f [open $path(test1)]
d548 1
a548 1
    set f [open $path(test1) w]
d550 1
a550 1
    set f [open $path(test1)]
d557 1
a557 1
    set f [open $path(test1) w]
d561 1
a561 1
    set f [open $path(test1)]
d568 1
a568 1
    set f [open $path(test1) w]
d572 1
a572 1
    set f [open $path(test1)]
d579 1
a579 1
    set f [open $path(test1) w]
d583 1
a583 1
    set f [open $path(test1)]
d590 1
a590 1
    set f [open $path(test1) w]
d594 1
a594 1
    set f [open $path(test1)]
d601 1
a601 1
    set f [open $path(test1) w]
d605 1
a605 1
    set f [open $path(test1)]
d612 1
a612 1
    set f [open $path(test1) w]
d616 1
a616 1
    set f [open $path(test1)]
d623 1
a623 1
    set f [open $path(test1) w]
d627 1
a627 1
    set f [open $path(test1)]
d633 1
a633 1
test io-6.30 {Tcl_GetsObj: crlf mode: buffer exhausted} {testchannel} {
d636 1
a636 1
    set f [open $path(test1) w]
d640 1
a640 1
    set f [open $path(test1)]
d646 1
a646 1
test io-6.31 {Tcl_GetsObj: crlf mode: buffer exhausted, blocked} {stdio testchannel} {
d649 1
a649 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d659 1
a659 1
test io-6.32 {Tcl_GetsObj: crlf mode: buffer exhausted, more data} {testchannel} {
d662 1
a662 1
    set f [open $path(test1) w]
d666 1
a666 1
    set f [open $path(test1)]
d675 1
a675 1
    set f [open $path(test1) w]
d679 1
a679 1
    set f [open $path(test1)]
d688 1
a688 1
    set f [open $path(test1) w]
d692 1
a692 1
    set f [open $path(test1)]
d699 1
a699 1
    set f [open $path(test1) w]
d701 1
a701 1
    set f [open $path(test1)]
d708 1
a708 1
    set f [open $path(test1) w]
d712 1
a712 1
    set f [open $path(test1)]
d719 1
a719 1
    set f [open $path(test1) w]
d723 1
a723 1
    set f [open $path(test1)]
d730 1
a730 1
    set f [open $path(test1) w]
d734 1
a734 1
    set f [open $path(test1)]
d741 1
a741 1
    set f [open $path(test1) w]
d745 1
a745 1
    set f [open $path(test1)]
d752 1
a752 1
    set f [open $path(test1) w]
d756 1
a756 1
    set f [open $path(test1)]
d763 1
a763 1
    set f [open $path(test1) w]
d767 1
a767 1
    set f [open $path(test1)]
d774 1
a774 1
    set f [open $path(test1) w]
d778 1
a778 1
    set f [open $path(test1)]
d785 1
a785 1
test io-6.43 {Tcl_GetsObj: input saw cr} {stdio testchannel} {
d788 1
a788 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d802 1
a802 1
test io-6.44 {Tcl_GetsObj: input saw cr, not followed by cr} {stdio testchannel} {
d805 1
a805 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d819 1
a819 1
test io-6.45 {Tcl_GetsObj: input saw cr, skip right number of bytes} {stdio testchannel} {
d822 1
a822 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d836 1
a836 1
test io-6.46 {Tcl_GetsObj: input saw cr, followed by just \n should give eof} {stdio testchannel} {
d839 1
a839 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d852 1
a852 1
test io-6.47 {Tcl_GetsObj: auto mode: \r at end of buffer, peek for \n} {testchannel} {
d855 1
a855 1
    set f [open $path(test1) w]
d859 1
a859 1
    set f [open $path(test1)]
d865 1
a865 1
test io-6.48 {Tcl_GetsObj: auto mode: \r at end of buffer, no more avail} {testchannel} {
d868 1
a868 1
    set f [open $path(test1) w]
d872 1
a872 1
    set f [open $path(test1)]
d878 1
a878 1
test io-6.49 {Tcl_GetsObj: auto mode: \r followed by \n} {testchannel} {
d881 1
a881 1
    set f [open $path(test1) w]
d885 1
a885 1
    set f [open $path(test1)]
d890 1
a890 1
test io-6.50 {Tcl_GetsObj: auto mode: \r not followed by \n} {testchannel} {
d893 1
a893 1
    set f [open $path(test1) w]
d897 1
a897 1
    set f [open $path(test1)]
d905 1
a905 1
    set f [open $path(test1) w]
d909 1
a909 1
    set f [open $path(test1)]
d914 1
a914 1
test io-6.52 {Tcl_GetsObj: saw EOF character} {testchannel} {
d917 1
a917 1
    set f [open $path(test1) w]
d921 1
a921 1
    set f [open $path(test1)]
d930 1
a930 1
    set f [open $path(test1) w]
d932 1
a932 1
    set f [open $path(test1)]
d940 1
a940 1
    set f [open $path(test1) w]
d943 1
a943 1
    set f [open $path(test1)]
d951 1
a951 1
    set f [open $path(test1) w]
d955 1
a955 1
    set f [open $path(test1)]
d963 1
a963 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d967 5
a971 5
    variable x {}
    after 500 [namespace code { lappend x timeout }]
    fileevent $f readable [namespace code { lappend x [gets $f] }]
    vwait [namespace which -variable x]
    vwait [namespace which -variable x]
d974 1
a974 1
    after 500 [namespace code { lappend x timeout }]
d976 2
a977 2
    vwait [namespace which -variable x]
    vwait [namespace which -variable x]
d985 1
a985 1
    set f [open $path(test1) w]
d989 1
a989 1
    set f [open $path(test1)]
d998 1
a998 1
    set f [open $path(test1) w]
d1002 1
a1002 1
    set f [open $path(test1)]
d1008 2
a1009 2
test io-7.3 {FilterInputBytes: split up character at EOF} {testchannel} {
    set f [open $path(test1) w]
d1013 1
a1013 1
    set f [open $path(test1)]
d1022 1
a1022 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d1026 2
a1027 2
    fileevent $f read [namespace code "ready $f"]
    variable x {}
d1029 1
a1029 2
	variable x
	lappend x [gets $f line] $line [fblocked $f]
d1031 1
a1031 1
    vwait [namespace which -variable x]
d1035 1
a1035 1
    vwait [namespace which -variable x]
d1040 1
a1040 1
test io-8.1 {PeekAhead: only go to device if no more cached data} {testchannel} {
d1043 1
a1043 1
    set f [open $path(test1) w]
d1047 1
a1047 1
    set f [open $path(test1)]
d1055 1
a1055 1
test io-8.2 {PeekAhead: only go to device if no more cached data} {stdio testchannel} {
d1058 1
a1058 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d1061 2
a1062 2
    variable x {}
    fileevent $f read [namespace code "ready $f"]
d1064 1
a1064 2
	variable x
	lappend x [gets $f line] $line [testchannel inputbuffered $f]
d1067 1
a1067 1
    vwait [namespace which -variable x]
d1070 1
a1070 1
    vwait [namespace which -variable x]
d1074 1
a1074 1
test io-8.3 {PeekAhead: no cached data available} {stdio testchannel} {
d1077 1
a1077 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d1091 1
a1091 1
    set f [open $path(test1) w+]
d1095 1
a1095 1
    set f [open $path(test1)]
d1107 1
a1107 1
test io-8.5 {PeekAhead: don't peek if last read was short} {stdio testchannel} {
d1110 1
a1110 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d1119 1
a1119 1
test io-8.6 {PeekAhead: change to non-blocking mode} {stdio testchannel} {
d1122 1
a1122 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d1131 1
a1131 1
test io-8.7 {PeekAhead: cleanup} {stdio testchannel} {
d1134 1
a1134 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d1156 1
a1156 1
    set f [open $path(test1) w]
d1160 1
a1160 1
    set f [open $path(test1)]
d1169 1
a1169 1
    set f [open $path(test1) w]
d1173 1
a1173 1
    set f [open $path(test1)]
d1183 1
a1183 1
    set f [open $path(test1) w]
d1187 1
a1187 1
    set f [open $path(test1)]
d1196 1
a1196 1
    set f [open $path(test1) w]
d1200 1
a1200 1
    set f [open $path(test1)]
d1210 1
a1210 1
    set f [open $path(test1) w]
d1213 1
a1213 1
    set f [open $path(test1)]
d1223 1
a1223 1
    set f [open $path(test1) w]
d1226 1
a1226 1
    set f [open $path(test1)]
d1236 1
a1236 1
    set f [open $path(test1) w]
d1239 1
a1239 1
    set f [open $path(test1)]
d1249 1
a1249 1
    set f [open $path(test1) w]
d1252 1
a1252 1
    set f [open $path(test1)]
d1263 1
a1263 1
    set f [open $path(test1) w]
d1266 1
a1266 1
    set f [open $path(test1)]
d1275 1
a1275 1
    set f [open $path(test1) w]
d1278 1
a1278 1
    set f [open $path(test1)]
d1287 1
a1287 1
    set f [open $path(test1) w]
d1290 1
a1290 1
    set f [open $path(test1)]
d1297 1
a1297 1
test io-12.4 {ReadChars: split-up char} {stdio testchannel} {
d1300 1
a1300 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d1305 1
a1305 1
    fileevent $f read [namespace code "ready $f"]
d1307 1
a1307 2
	variable x
	lappend x [read $f] [testchannel inputbuffered $f]
d1309 1
a1309 1
    variable x {}
d1312 1
a1312 1
    vwait [namespace which -variable x]
d1317 1
a1317 1
    vwait [namespace which -variable x]
d1322 1
a1322 1
    set path(test1) [makeFile {
d1327 3
a1329 3
    } test1]
    set f [open "|[list [interpreter] $path(test1)]" r+]
    fileevent $f readable [namespace code {
d1334 1
a1334 1
    }]
d1338 4
a1341 4
    variable x {}
    vwait [namespace which -variable x]
    after 500 [namespace code { lappend x timeout }]
    vwait [namespace which -variable x]
d1344 3
a1346 3
    vwait [namespace which -variable x]
    after 500 [namespace code { lappend x timeout }]
    vwait [namespace which -variable x]
d1349 2
a1350 2
    vwait [namespace which -variable x]
    vwait [namespace which -variable x]
d1356 1
a1356 1
    set f [open $path(test1) w]
d1360 1
a1360 1
    set f [open $path(test1)]
d1367 1
a1367 1
    set f [open $path(test1) w]
d1371 1
a1371 1
    set f [open $path(test1)]
d1380 1
a1380 1
    set f [open $path(test1) w]
d1384 1
a1384 1
    set f [open $path(test1)]
d1393 1
a1393 1
    set f [open $path(test1) w]
d1397 1
a1397 1
    set f [open $path(test1)]
d1406 1
a1406 1
    set f [open $path(test1) w]
d1410 1
a1410 1
    set f [open $path(test1)]
d1416 1
a1416 1
test io-13.6 {TranslateInputEOL: auto mode: saw cr in last segment} {stdio testchannel} {
d1420 1
a1420 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d1423 1
a1423 1
    fileevent $f read [namespace code "ready $f"]
d1425 1
a1425 2
	variable x
	lappend x [read $f] [testchannel queuedcr $f]
d1427 1
a1427 2
    variable x {}
    variable y {}
d1430 2
a1431 2
    after 500 [namespace code {set y ok}]
    vwait [namespace which -variable y]
d1434 2
a1435 2
    after 500 [namespace code {set y ok}]
    vwait [namespace which -variable y]
d1440 1
a1440 1
test io-13.7 {TranslateInputEOL: auto mode: naked \r} {testchannel} {
d1443 1
a1443 1
    set f [open $path(test1) w]
d1447 1
a1447 1
    set f [open $path(test1)]
d1456 1
a1456 1
    set f [open $path(test1) w]
d1460 1
a1460 1
    set f [open $path(test1)]
d1467 1
a1467 1
    set f [open $path(test1) w]
d1471 1
a1471 1
    set f [open $path(test1)]
d1480 1
a1480 1
    set f [open $path(test1) w]
d1484 1
a1484 1
    set f [open $path(test1)]
d1493 1
a1493 1
    set f [open $path(test1) w]
d1497 1
a1497 1
    set f [open $path(test1)]
d1506 1
a1506 1
    set f [open $path(test1) w]
d1510 1
a1510 1
    set f [open $path(test1)]
d1521 2
a1522 6
if {[info commands testchannel] != ""} {
    if {$tcl_platform(platform) == "macintosh"} {
	set consoleFileNames [list console0 console1 console2]
    } else {
	set consoleFileNames [lsort [testchannel open]]
    }
d1524 1
a1524 2
    # just to avoid an error
    set consoleFileNames [list]
d1526 1
a1526 2

test io-14.1 {Tcl_SetStdChannel and Tcl_GetStdChannel} {testchannel} {
d1543 3
a1545 6

set path(test3) [makeFile {} test3]

test io-14.3 {Tcl_SetStdChannel & Tcl_GetStdChannel} {exec} {
    set f [open $path(test1) w]
    puts $f [format {
d1549 3
a1551 3
	set f  [open "%s" r]
	set f2 [open "%s" w]
	set f3 [open "%s" w]
d1558 1
a1558 1
    } $path(test1) $path(test2) $path(test3)]
d1560 3
a1562 3
    set result [exec [interpreter] $path(test1)]
    set f  [open $path(test2) r]
    set f2 [open $path(test3) r]
d1572 3
a1574 3
test io-14.4 {Tcl_SetStdChannel & Tcl_GetStdChannel} {exec unixOnly} {
    set f [open $path(test1) w]
    puts $f [format { close stdin
d1577 3
a1579 3
	set f  [open "%s" r]
	set f2 [open "%s" w]
	set f3 [open "%s" w]
d1586 1
a1586 1
    } $path(test1) $path(test2) $path(test3)]
d1588 3
a1590 3
    set result [exec [interpreter] $path(test1)]
    set f  [open $path(test2) r]
    set f2 [open $path(test3) r]
a1629 3

set path(script) [makeFile {} script]

d1633 2
a1634 2
    set f [open $path(script) w]
    puts $f [format {
d1636 1
a1636 1
	set f [open "%s" w]
d1639 1
a1639 1
	set f [open "%s" r]
d1641 1
a1641 1
    } $path(test1) $path(test1)]
d1643 1
a1643 1
    set f [open "|[list [interpreter] $path(script)]" r]
a1647 1

d1651 1
a1651 1
    set f [open $path(script) w]
d1653 1
a1653 2
        array set path [lindex $argv 0]
	set f [open $path(test1) w]
d1657 1
a1657 1
	set f [open "|[list [info nameofexecutable] $path(cat) $path(test1)]" r]
d1661 1
a1661 1
    set f [open "|[list [interpreter] $path(script) [array get path]]" r]
d1680 1
a1680 1
test io-17.1 {GetChannelTable, DeleteChannelTable on std handles} {testchannel} {
d1692 1
a1692 1
test io-17.2 {GetChannelTable, DeleteChannelTable on std handles} {testchannel} {
d1704 1
a1704 1
test io-17.3 {GetChannelTable, DeleteChannelTable on std handles} {testchannel} {
d1717 1
a1717 1
test io-18.1 {Tcl_RegisterChannel, Tcl_UnregisterChannel} {testchannel} {
d1720 1
a1720 1
    set f [open $path(test1) w]
d1731 1
a1731 1
test io-18.2 {Tcl_RegisterChannel, Tcl_UnregisterChannel} {testchannel} {
d1734 1
a1734 1
    set f [open $path(test1) w]
d1752 1
a1752 1
test io-18.3 {Tcl_RegisterChannel, Tcl_UnregisterChannel} {testchannel} {
d1755 1
a1755 1
    set f [open $path(test1) w]
d1777 1
a1777 1
    set f [open $path(test1) w]
d1785 1
a1785 1
test io-19.4 {Tcl_CreateChannel, insertion into channel table} {testchannel} {
d1787 1
a1787 1
    set f [open $path(test1) w]
d1801 1
a1801 1
	set a [open $path(test2) w]
d1804 1
a1804 1
    set f [open $path(test1) w]
d1812 1
a1812 1
    set f [open $path(test1) w+]
d1818 1
a1818 1
    set f [open $path(test1) w+]
d1824 1
a1824 1
    set f [open $path(test1) w+]
a1828 3

set path(stdout) [makeFile {} stdout]

d1830 2
a1831 2
    set f [open $path(script) w]
    puts $f [format {
d1833 1
a1833 1
	set f1 [open "%s" w]
d1836 1
a1836 1
    } $path(stdout)]
d1838 1
a1838 1
    set f [open "|[list [interpreter] $path(script)]"]
d1856 1
a1856 1
test io-23.1 {Tcl_GetChannelName} {testchannel} {
d1858 1
a1858 1
    set f [open $path(test1) w]
d1864 1
a1864 1
test io-24.1 {Tcl_GetChannelType} {testchannel} {
d1866 1
a1866 1
    set f [open $path(test1) w]
d1872 2
a1873 2
test io-25.1 {Tcl_GetChannelHandle, input} {testchannel} {
    set f [open $path(test1) w]
d1877 1
a1877 1
    set f [open $path(test1) r]
d1885 1
a1885 1
test io-25.2 {Tcl_GetChannelHandle, output} {testchannel} {
d1887 1
a1887 1
    set f [open $path(test1) w]
d1905 1
a1905 1
    set f [open "|[list [interpreter] << exit]"]
d1914 1
a1914 1
    set f [open $path(test1) w]
d1916 1
a1916 1
    set s [file size $path(test1)]
d1922 1
a1922 1
    set f [open $path(test1) w]
d1926 1
a1926 1
    lappend l [file size $path(test1)]
d1928 1
a1928 1
    lappend l [file size $path(test1)]
d1930 1
a1930 1
    lappend l [file size $path(test1)]
d1935 1
a1935 1
    set f [open $path(test1) w]
d1939 1
a1939 1
    lappend l [file size $path(test1)]
d1941 1
a1941 1
    lappend l [file size $path(test1)]
d1946 1
a1946 1
    set f [open $path(test1) w]
d1950 1
a1950 1
    lappend l [file size $path(test1)]
d1954 1
a1954 1
    lappend l [file size $path(test1)]
d1956 1
a1956 1
    lappend l [file size $path(test1)]
d1963 1
a1963 1
    set f [open $path(test1) w]
d1966 1
a1966 1
    lappend l [file size $path(test1)]
d1970 1
a1970 1
    lappend l [file size $path(test1)]
d1972 1
a1972 1
    lappend l [file size $path(test1)]
a1974 4

set path(pipe)   [makeFile {} pipe]
set path(output) [makeFile {} output]

d1979 3
a1981 3
    set f [open $path(pipe) w]
    puts $f [format {
	set f [open "%s" w]
d1988 1
a1988 1
    } $path(output)]
d1994 1
a1994 1
    set f [open $path(output) w]
d1996 1
a1996 1
    set f [open "|[list [interpreter] $path(pipe)]" w]
d2001 1
a2001 1
    while {([file size $path(output)] < 65536) && ($counter < 1000)} {
d2007 1
a2007 1
        set result "file size only [file size $path(output)]"
d2015 1
a2015 1
test io-28.1 {CloseChannel called when all references are dropped} {testchannel} {
d2017 1
a2017 1
    set f [open $path(test1) w]
d2030 1
a2030 1
    set f [open $path(test1) w]
d2038 1
a2038 1
    set f [open $path(test1) r]
d2047 1
a2047 1
    set f [open $path(pipe) w]
d2057 1
a2057 1
	set f [open $path(output) w]
d2070 1
a2070 1
    set f [open $path(output) w]
d2072 1
a2072 1
    set f [open "|[list [interpreter] pipe]" r+]
d2078 1
a2078 1
    while {([file size $path(output)] < 20480) && ($counter < 1000)} {
d2089 1
a2089 1
test io-28.4 {Tcl_Close} {testchannel} {
d2093 1
a2093 1
    set f [open $path(test1) w]
d2102 1
a2102 1
test io-28.5 {Tcl_Close vs standard handles} {stdio unixOnly testchannel} {
d2104 1
a2104 1
    set f [open $path(script) w]
d2110 1
a2110 1
    set f [open "|[list [interpreter] $path(script)]" r]
d2121 1
a2121 1
    set f [open $path(test1) w]
d2125 1
a2125 1
    file size $path(test1)
d2129 1
a2129 1
    set f [open $path(test1) w]
d2133 1
a2133 1
    file size $path(test1)
d2135 1
a2135 1
test io-29.4 {Tcl_WriteChars, buffering in full buffering mode} {testchannel} {
d2137 1
a2137 1
    set f [open $path(test1) w]
d2142 1
a2142 1
    lappend l [file size $path(test1)]
d2145 1
a2145 1
    lappend l [file size $path(test1)]
d2149 1
a2149 1
test io-29.5 {Tcl_WriteChars, buffering in line buffering mode} {testchannel} {
d2151 1
a2151 1
    set f [open $path(test1) w]
d2156 1
a2156 1
    lappend l [file size $path(test1)]
d2159 1
a2159 1
    lappend l [file size $path(test1)]
d2163 1
a2163 1
test io-29.6 {Tcl_WriteChars, buffering in no buffering mode} {testchannel} {
d2165 1
a2165 1
    set f [open $path(test1) w]
d2170 1
a2170 1
    lappend l [file size $path(test1)]
d2173 1
a2173 1
    lappend l [file size $path(test1)]
d2178 1
a2178 1
test io-29.7 {Tcl_Flush, full buffering} {testchannel} {
d2180 1
a2180 1
    set f [open $path(test1) w]
d2185 1
a2185 1
    lappend l [file size $path(test1)]
d2188 1
a2188 1
    lappend l [file size $path(test1)]
d2191 1
a2191 1
    lappend l [file size $path(test1)]
d2195 1
a2195 1
test io-29.8 {Tcl_Flush, full buffering} {testchannel} {
d2197 1
a2197 1
    set f [open $path(test1) w]
d2202 1
a2202 1
    lappend l [file size $path(test1)]
d2205 1
a2205 1
    lappend l [file size $path(test1)]
d2208 1
a2208 1
    lappend l [file size $path(test1)]
d2211 1
a2211 1
    lappend l [file size $path(test1)]
d2220 1
a2220 1
    set f1 [open $path(test1) w]
d2222 1
a2222 1
    set f2 [open $path(longfile) r]
d2228 1
a2228 1
    file size $path(test1)
d2232 1
a2232 1
    set f1 [open $path(test1) w]
d2234 1
a2234 1
    set f2 [open $path(longfile) r]
d2240 1
a2240 1
    file size $path(test1)
d2245 3
a2247 3
    set f1 [open $path(pipe) w]
    puts $f1 [format {
	set f1 [open "%s" r]
d2251 1
a2251 1
    } $path(longfile)]
d2253 2
a2254 2
    set f1 [open "|[list [interpreter] $path(pipe)]" r]
    set f2 [open $path(longfile) r]
d2270 1
a2270 1
    set f1 [open $path(pipe) w]
d2277 1
a2277 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d2279 1
a2279 1
    set f2 [open $path(longfile) r]
d2298 1
a2298 1
    set f [open $path(test3) w]
d2303 1
a2303 1
    set f [open $path(test3) r]
d2310 1
a2310 1
    set fd [open $path(test1) w]
d2312 1
a2312 1
    set fd [open $path(test1) r]
d2319 1
a2319 1
    set fd [open "|[list [interpreter] cat longfile]" r]
d2327 1
a2327 1
    set f1 [open $path(test1) w]
d2333 1
a2333 1
    set x [file size $path(test1)]
d2340 1
a2340 1
    set f1 [open $path(test1) w]
d2346 1
a2346 1
    lappend x [file size $path(test1)]
d2349 1
a2349 1
    lappend x [file size $path(test1)]
d2352 1
a2352 1
    lappend x [file size $path(test1)]
d2358 1
a2358 1
    set f1 [open $path(test1) w]
d2365 1
a2365 1
    lappend x [file size $path(test1)]
d2368 1
a2368 1
    lappend x [file size $path(test1)]
d2371 1
a2371 1
    lappend x [file size $path(test1)]
d2376 1
a2376 1
    set f1 [open $path(test1) w]
d2383 1
a2383 1
    lappend z [file size $path(test1)]
d2387 1
a2387 1
    lappend z [file size $path(test1)]
d2389 1
a2389 1
    lappend z [file size $path(test1)]
d2394 1
a2394 1
    set f1 [open $path(pipe) w]
d2399 1
a2399 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d2408 1
a2408 1
    set f1 [open $path(pipe) w]
d2419 1
a2419 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d2431 1
a2431 1
    set f1 [open $path(pipe) w]
d2439 1
a2439 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d2450 1
a2450 1
    set f [open $path(test3) w]
d2453 1
a2453 1
    set f2 [open $path(test3)]
d2458 1
a2458 1
    set f2 [open $path(test3)]
d2466 1
a2466 1
    set f [open "|[list [interpreter] $path(cat) | [interpreter] $path(cat) > $path(test3)]" w]
d2471 1
a2471 1
    set f [open $path(test3) r]
d2486 1
a2486 1
    set f [open $path(pipe) w]
d2489 1
a2489 1
    set f [open "|[list [interpreter] $path(pipe)]" r+]
d2514 1
a2514 1
    set f [open $path(test1) w]
d2518 1
a2518 1
    set s [file size $path(test1)]
d2524 1
a2524 1
    set f [open $path(test1) w]
d2528 1
a2528 1
    file size $path(test1)
d2532 1
a2532 1
    set f [open $path(test1) w]
d2536 1
a2536 1
    file size $path(test1)
d2541 2
a2542 2
    set f [open $path(pipe) w]
    puts $f [format {set f [open "%s" w]} $path(output)]
d2556 1
a2556 1
    set f [open $path(output) w]
d2558 1
a2558 1
    set f [open "|[list [interpreter] $path(pipe)]" r+]
d2563 1
a2563 1
    while {([file size $path(output)] < 65536) && ($counter < 1000)} {
d2569 1
a2569 1
	set result "file size only [file size $path(output)]"
d2578 2
a2579 2
    set f [open $path(pipe) w]
    puts $f [format {set f [open "%s" w]} $path(output)]
d2594 1
a2594 1
    set f [open $path(output) w]
d2596 1
a2596 1
    set f [open "|[list [interpreter] $path(pipe)]" r+]
d2601 1
a2601 1
    while {([file size $path(output)] < 65536) && ($counter < 1000)} {
d2607 1
a2607 1
	set result "file size only [file size $path(output)]"
d2612 4
a2615 4
test io-29.33 {Tcl_Flush, implicit flush on exit} {exec} {
    set f [open $path(script) w]
    puts $f [format {
	set f [open "%s" w]
d2620 1
a2620 1
    } $path(test1)]
d2622 2
a2623 2
    exec [interpreter] $path(script)
    set f [open $path(test1) r]
d2630 1
a2630 1
    variable x running
d2638 2
a2639 2
	variable x
	fileevent $s readable [namespace code [list readit $s]]
d2644 1
a2644 2
	variable c
	variable x
d2654 3
a2656 3
    set ss [socket -server [namespace code accept] 0]
    set cs [socket [info hostname] [lindex [fconfigure $ss -sockname] 2]]
    vwait [namespace which -variable x]
d2661 1
a2661 1
    vwait [namespace which -variable x]
d2672 1
a2672 1
    set s [socket -server [namespace code accept] 0]
d2677 1
a2677 1
    set c [socket [info hostname] [lindex [fconfigure $s -sockname] 2]]
d2710 1
a2710 1
    set f [open $path(test1) w]
d2714 1
a2714 1
    set f [open $path(test1) r]
d2722 1
a2722 1
    set f [open $path(test1) w]
d2726 1
a2726 1
    set f [open $path(test1) r]
d2734 1
a2734 1
    set f [open $path(test1) w]
d2738 1
a2738 1
    set f [open $path(test1) r]
d2746 1
a2746 1
    set f [open $path(test1) w]
d2750 1
a2750 1
    set f [open $path(test1) r]
d2758 1
a2758 1
    set f [open $path(test1) w]
d2762 1
a2762 1
    set f [open $path(test1) r]
d2770 1
a2770 1
    set f [open $path(test1) w]
d2774 1
a2774 1
    set f [open $path(test1) r]
d2782 1
a2782 1
    set f [open $path(test1) w]
d2786 1
a2786 1
    set f [open $path(test1) r]
d2794 1
a2794 1
    set f [open $path(test1) w]
d2798 1
a2798 1
    set f [open $path(test1) r]
d2806 1
a2806 1
    set f [open $path(test1) w]
d2810 1
a2810 1
    set f [open $path(test1) r]
d2818 1
a2818 1
    set f [open $path(test1) w]
d2822 1
a2822 1
    set f [open $path(test1) r]
d2834 1
a2834 1
    set f [open $path(test1) w]
d2838 1
a2838 1
    set f [open $path(test1) r]
d2850 1
a2850 1
    set f [open $path(test1) w]
d2854 1
a2854 1
    set f [open $path(test1) r]
d2867 1
a2867 1
    set f [open $path(test1) w]
d2875 1
a2875 1
    set f [open $path(test1) r]
d2884 1
a2884 1
    set f [open $path(test1) w]
d2892 1
a2892 1
    set f [open $path(test1) r]
d2901 1
a2901 1
    set f [open $path(test1) w]
d2905 1
a2905 1
    set f [open $path(test1) r]
d2917 1
a2917 1
    set f [open $path(test1) w]
d2921 1
a2921 1
    set f [open $path(test1) r]
d2933 1
a2933 1
    set f [open $path(test1) w]
d2937 1
a2937 1
    set f [open $path(test1) r]
d2949 1
a2949 1
    set f [open $path(test1) w]
d2954 1
a2954 1
    set f [open $path(test1) r]
d2969 1
a2969 1
    set f [open $path(test1) w]
d2974 1
a2974 1
    set f [open $path(test1) r]
d2989 1
a2989 1
    set f [open $path(test1) w]
d2994 1
a2994 1
    set f [open $path(test1) r]
d3011 1
a3011 1
    set f [open $path(test1) w]
d3016 1
a3016 1
    set f [open $path(test1) r]
d3029 1
a3029 1
    set f [open $path(test1) w]
d3034 1
a3034 1
    set f [open $path(test1) r]
d3047 1
a3047 1
    set f [open $path(test1) w]
d3052 1
a3052 1
    set f [open $path(test1) r]
d3061 1
a3061 1
    set f [open $path(test1) w]
d3066 1
a3066 1
    set f [open $path(test1) r]
d3075 1
a3075 1
    set f [open $path(test1) w]
d3080 1
a3080 1
    set f [open $path(test1) r]
d3089 1
a3089 1
    set f [open $path(test1) w]
d3094 1
a3094 1
    set f [open $path(test1) r]
d3103 1
a3103 1
    set f [open $path(test1) w]
d3108 1
a3108 1
    set f [open $path(test1) r]
d3117 1
a3117 1
    set f [open $path(test1) w]
d3122 1
a3122 1
    set f [open $path(test1) r]
d3134 1
a3134 1
    set f [open $path(test1) w]
d3138 1
a3138 1
    set f [open $path(test1) r]
d3151 1
a3151 1
    set f [open $path(test1) w]
d3155 1
a3155 1
    set f [open $path(test1) r]
d3168 1
a3168 1
    set f [open $path(test1) w]
d3172 1
a3172 1
    set f [open $path(test1) r]
d3185 1
a3185 1
    set f [open $path(test1) w]
d3189 1
a3189 1
    set f [open $path(test1) r]
d3203 1
a3203 1
    set f [open $path(test1) w]
d3207 1
a3207 1
    set f [open $path(test1) r]
d3223 1
a3223 1
    set f [open $path(test1) w]
d3227 1
a3227 1
    set f [open $path(test1) r]
d3243 1
a3243 1
    set f [open $path(test1) w]
d3247 1
a3247 1
    set f [open $path(test1) r]
d3263 1
a3263 1
    set f [open $path(test1) w]
d3267 1
a3267 1
    set f [open $path(test1) r]
d3283 1
a3283 1
    set f [open $path(test1) w]
d3287 1
a3287 1
    set f [open $path(test1) r]
d3303 1
a3303 1
    set f [open $path(test1) w]
d3307 1
a3307 1
    set f [open $path(test1) r]
d3323 1
a3323 1
    set f [open $path(test1) w]
d3327 1
a3327 1
    set f [open $path(test1) r]
d3343 1
a3343 1
    set f [open $path(test1) w]
d3347 1
a3347 1
    set f [open $path(test1) r]
d3363 1
a3363 1
    set f [open $path(test1) w]
d3375 1
a3375 1
    set f [open $path(test1) w]
d3379 1
a3379 1
    set f [open $path(test1) r]
d3394 1
a3394 1
    set f [open $path(test1) w]
d3398 1
a3398 1
    set f [open $path(test1) r]
d3413 1
a3413 1
    set f [open $path(test1) w]
d3417 1
a3417 1
    set f [open $path(test1) r]
d3431 1
a3431 1
    set f [open $path(test1) w]
d3435 1
a3435 1
    set f [open $path(test1) r]
d3450 1
a3450 1
    set f [open $path(test1) w]
d3455 1
a3455 1
    set f [open $path(test1) r]
d3470 1
a3470 1
    set f [open $path(test1) w]
d3474 1
a3474 1
    set f [open $path(test1) r]
d3489 1
a3489 1
    set f [open $path(test1) w]
d3494 1
a3494 1
    set f [open $path(test1) r]
d3508 1
a3508 1
    set f [open $path(test1) w]
d3513 1
a3513 1
    set f [open $path(test1) r]
d3526 1
a3526 1
    set f [open $path(test1) w]
d3531 1
a3531 1
    set f [open $path(test1) r]
d3548 1
a3548 1
    set f [open $path(test1) w]
d3553 1
a3553 1
    set f [open $path(test1) r]
d3570 1
a3570 1
    set f [open $path(test1) w]
d3575 1
a3575 1
    set f [open $path(test1) r]
d3592 1
a3592 1
    set f [open $path(test1) w]
d3597 1
a3597 1
    set f [open $path(test1) r]
d3610 1
a3610 1
    set f [open $path(test1) w]
d3615 1
a3615 1
    set f [open $path(test1) r]
d3628 1
a3628 1
    set f [open $path(test1) w]
d3633 1
a3633 1
    set f [open $path(test1) r]
d3646 1
a3646 1
    set f [open $path(test1) w]
d3651 1
a3651 1
    set f [open $path(test1) r]
d3664 1
a3664 1
    set f [open $path(test1) w]
d3669 1
a3669 1
    set f [open $path(test1) r]
d3682 1
a3682 1
    set f [open $path(test1) w]
d3687 1
a3687 1
    set f [open $path(test1) r]
d3700 1
a3700 1
    set f [open $path(test1) w]
d3708 1
a3708 1
    set f [open $path(test1) r]
d3719 1
a3719 1
    set f [open $path(test1) w]
d3727 1
a3727 1
    set f [open $path(test1) r]
d3747 1
a3747 1
    set f [open $path(longfile) r]
d3753 1
a3753 1
    set f [open $path(longfile) r]
d3761 1
a3761 1
    set f [open $path(longfile) r]
d3770 1
a3770 1
    set f1 [open $path(longfile) r]
d3775 1
a3775 1
    set z [file size $path(longfile)]
d3782 1
a3782 1
    set f1 [open $path(longfile) r]
d3794 1
a3794 1
    set f1 [open $path(longfile) r]
d3799 2
a3800 2
    set l [string length $z]
    set z [file size $path(longfile)]
d3804 1
a3804 1
    set x
d3807 1
a3807 1
    set f1 [open $path(longfile) r]
d3812 1
a3812 1
    set z [file size $path(longfile)]
d3820 1
a3820 1
    set f1 [open $path(pipe) w]
d3823 1
a3823 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d3832 1
a3832 1
    set f1 [open $path(pipe) w]
d3836 1
a3836 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d3851 1
a3851 1
    set f1 [open $path(test1) w]
d3855 1
a3855 1
    set f1 [open $path(test1) r]
d3863 1
a3863 1
    set f1 [open $path(test1) w]
d3867 1
a3867 1
    set f1 [open $path(test1) r]
d3875 1
a3875 1
    set f [open $path(test1) w]
d3879 1
a3879 1
    set f [open $path(test1)]
d3888 1
a3888 1
    set f [open $path(test1) w]
d3892 1
a3892 1
    set f [open $path(test1)]
d3901 1
a3901 1
    set f [open $path(test1) w]
d3905 1
a3905 1
    set f [open $path(test1)]
d3916 1
a3916 1
    set f1 [open $path(test1) w]
d3920 1
a3920 1
    set f1 [open $path(test1) r]
d3930 1
a3930 1
    set f1 [open $path(longfile) r]
d3942 1
a3942 1
    set f1 [open $path(pipe) w]
d3945 1
a3945 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d3958 1
a3958 1
    set f [open $path(test3) w]
d3965 1
a3965 1
    set f [open $path(test3)]
d3971 1
a3971 1
    set f [open $path(test3)]
d3978 1
a3978 1
    set f [open $path(test3) w]
d3981 1
a3981 1
    set f [open $path(test3)]
d3993 1
a3993 1
    set f [open $path(test3) w]
d3999 1
a3999 1
    set f [open $path(test3) r]
d4005 1
a4005 1
    set f [open $path(test3) w]
d4011 1
a4011 1
    set f [open $path(test3) r]
d4018 1
a4018 1
    set f [open $path(test3) w]
d4024 1
a4024 1
    set f [open $path(test3) r]
d4031 1
a4031 1
    set f [open $path(test3) w]
d4037 1
a4037 1
    set f [open $path(test3) r]
d4047 1
a4047 1
    set f1 [open $path(longfile) r]
d4055 1
a4055 1
    set f1 [open $path(test1) w]
d4060 1
a4060 1
    set f1 [open $path(test1) r]
d4068 1
a4068 1
    set f1 [open $path(test1) w]
d4073 1
a4073 1
    set f1 [open $path(test1) r]
d4081 1
a4081 1
    set f1 [open $path(test1) w]
d4086 1
a4086 1
    set f1 [open $path(test1) r]
d4094 1
a4094 1
    set f1 [open $path(test1) w]
d4099 1
a4099 1
    set f1 [open $path(test1) r]
d4108 1
a4108 1
    set f1 [open $path(test1) w]
d4113 1
a4113 1
    set f1 [open $path(test1) r]
d4123 1
a4123 1
    set f1 [open $path(test1) w]
d4128 1
a4128 1
    set f1 [open $path(test1) r]
d4138 1
a4138 1
    set f1 [open "|[list [interpreter]]" r+]
d4146 1
a4146 1
    set f [open $path(test3) w]
d4150 1
a4150 1
    set f [open $path(test3) RDWR]
a4166 3

set path(test3) [makeFile {} test3]

d4168 1
a4168 1
    set f [open $path(test3) w]
d4172 1
a4172 1
    set f [open $path(test3) r+]
d4182 1
a4182 1
    set f [open $path(test3) w]
d4185 1
a4185 1
    set f [open $path(test3) w+]
d4193 1
a4193 1
    set f [open $path(test3) w]
d4197 1
a4197 1
    set f [open $path(test3) a+]
d4211 1
a4211 1
    set f1 [open $path(test1) w]
d4218 1
a4218 1
    set f1 [open $path(test1) w]
d4223 1
a4223 1
    set f1 [open $path(test1) r]
d4231 1
a4231 1
    set f1 [open $path(test1) w]
d4236 1
a4236 1
    set f1 [open $path(test1) r]
d4245 1
a4245 1
    set f1 [open "|[list [interpreter]]" r+]
d4251 1
a4251 1
    set f1 [open "|[list [interpreter]]" r+]
d4261 1
a4261 1
    set f [open $path(test2) w]
d4265 1
a4265 1
    set f [open $path(test2)]
d4280 1
a4280 1
    set f [open $path(test3) w]
d4285 1
a4285 1
    set f [open $path(test3) a]
d4291 1
a4291 1
    set f [open $path(test3) w]
a4304 22
test io-34.21 {Tcl_Seek and Tcl_Tell on large files} {largefileSupport} {
    removeFile test3
    set f [open $path(test3) w]
    fconfigure $f -encoding binary
    set l ""
    lappend l [tell $f]
    puts -nonewline $f abcdef
    lappend l [tell $f]
    flush $f
    lappend l [tell $f]
    # 4GB offset!
    seek $f 0x100000000
    lappend l [tell $f]
    puts -nonewline $f abcdef
    lappend l [tell $f]
    close $f
    lappend l [file size $f]
    # truncate...
    close [open $path(test3) w]
    lappend l [file size $f]
    set l
} {0 6 6 4294967296 4294967302 4294967302 0}
d4310 1
a4310 1
    set f [open $path(test1) w]
d4314 1
a4314 1
    set f [open $path(test1)]
d4329 1
a4329 1
    set f1 [open $path(pipe) w]
d4333 1
a4333 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d4347 1
a4347 1
    set f1 [open $path(pipe) w]
d4351 1
a4351 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d4369 1
a4369 1
    set f [open $path(test1) w]
d4371 1
a4371 1
    set f [open $path(test1) r]
d4381 1
a4381 1
    set f [open $path(pipe) w]
d4386 1
a4386 1
    set f [open "|[list [interpreter] $path(pipe)]" r]
d4395 1
a4395 1
    set f [open $path(test1) w]
d4399 2
a4400 2
    set s [file size $path(test1)]
    set f [open $path(test1) r]
d4409 1
a4409 1
    set f [open $path(test1) w]
d4413 2
a4414 2
    set s [file size $path(test1)]
    set f [open $path(test1) r]
d4423 1
a4423 1
    set f [open $path(test1) w]
d4427 2
a4428 2
    set s [file size $path(test1)]
    set f [open $path(test1) r]
d4437 1
a4437 1
    set f [open $path(test1) w]
d4441 2
a4442 2
    set s [file size $path(test1)]
    set f [open $path(test1) r]
d4451 1
a4451 1
    set f [open $path(test1) w]
d4455 2
a4456 2
    set s [file size $path(test1)]
    set f [open $path(test1) r]
d4465 1
a4465 1
    set f [open $path(test1) w]
d4469 2
a4470 2
    set s [file size $path(test1)]
    set f [open $path(test1) r]
d4479 1
a4479 1
    set f [open $path(test1) w]
d4484 2
a4485 2
    set c [file size $path(test1)]
    set f [open $path(test1) r]
d4494 1
a4494 1
    set f [open $path(test1) w]
d4499 2
a4500 2
    set c [file size $path(test1)]
    set f [open $path(test1) r]
d4509 1
a4509 1
    set f [open $path(test1) w]
d4514 2
a4515 2
    set c [file size $path(test1)]
    set f [open $path(test1) r]
d4524 1
a4524 1
    set f [open $path(test1) w]
d4529 2
a4530 2
    set c [file size $path(test1)]
    set f [open $path(test1) r]
d4539 1
a4539 1
    set f [open $path(test1) w]
d4544 2
a4545 2
    set c [file size $path(test1)]
    set f [open $path(test1) r]
d4554 1
a4554 1
    set f [open $path(test1) w]
d4559 2
a4560 2
    set c [file size $path(test1)]
    set f [open $path(test1) r]
d4571 1
a4571 1
    set f1 [open "|[list [interpreter]]" r+]
d4590 1
a4590 1
    set f1 [open "|[list [interpreter]]" r+]
d4605 1
a4605 1
    set f [open $path(test1) w]
d4608 1
a4608 1
    set f [open $path(test1) r]
d4621 1
a4621 2
        variable l
        variable x
d4626 1
a4626 1
    set f [open $path(test1) w]
d4629 1
a4629 1
    set f [open $path(test1) r]
d4631 2
a4632 3
    fileevent $f readable [namespace code [list in $f]]
    variable x
    vwait [namespace which -variable x]
d4638 1
a4638 1
    set f [open $path(test1) w]
d4641 1
a4641 1
    set f [open $path(test1) r]
d4655 1
a4655 2
        variable l
        variable x
d4660 1
a4660 1
    set f [open $path(test1) w]
d4663 1
a4663 1
    set f [open $path(test1) r]
d4666 2
a4667 3
    fileevent $f readable [namespace code [list in $f]]
    variable x
    vwait [namespace which -variable x]
d4674 2
a4675 2
test io-37.1 {Tcl_InputBuffered} {testchannel} {
    set f [open $path(longfile) r]
d4684 2
a4685 2
test io-37.2 {Tcl_InputBuffered, test input flushing on seek} {testchannel} {
    set f [open $path(longfile) r]
d4701 1
a4701 1
    set f [open $path(longfile) r]
d4707 1
a4707 1
    set f [open $path(longfile) r]
a4725 11
test io-38.3 {Tcl_SetChannelBufferSize, changing buffersize between reads} {
    # This test crashes the interp if Bug #427196 is not fixed

    set chan [open [info script] r]
    fconfigure $chan -buffersize 10
    set var [read $chan 2]
    fconfigure $chan -buffersize 32
    append var [read $chan]
    close $chan
} {}

d4730 1
a4730 1
    set f1 [open $path(test1) w]
d4740 1
a4740 1
    set f1 [open $path(test1) w]
d4747 1
a4747 1
    set f1 [open $path(test1) w]
d4755 1
a4755 1
    set f1 [open $path(test1) w]
d4771 1
a4771 1
    set f1 [open $path(test1) w]
d4781 1
a4781 1
    set f1 [open $path(test1) w]
d4785 1
a4785 1
    set x [file size $path(test1)]
d4791 1
a4791 1
    set f1 [open $path(test1) w]
d4797 1
a4797 1
    lappend x [file size $path(test1)]
d4799 1
a4799 1
    lappend x [file size $path(test1)]
d4805 1
a4805 1
    set f1 [open $path(test1) w]
d4809 1
a4809 1
    lappend l [file size $path(test1)]
d4811 1
a4811 1
    lappend l [file size $path(test1)]
d4814 1
a4814 1
    lappend l [file size $path(test1)]
d4816 1
a4816 1
    lappend l [file size $path(test1)]
d4818 1
a4818 1
    lappend l [file size $path(test1)]
d4820 1
a4820 1
    lappend l [file size $path(test1)]
d4825 1
a4825 1
    set f1 [open $path(test1) w]
d4827 1
a4827 1
    set f1 [open $path(test1) r]
d4841 1
a4841 1
    set f1 [open $path(pipe) w]
d4850 1
a4850 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d4877 1
a4877 1
    set f [open $path(test1) w]
d4885 1
a4885 1
    set f [open $path(test1) w]
d4893 1
a4893 1
    set f [open $path(test1) w]
d4901 1
a4901 1
    set f [open $path(test1) w]
d4905 1
a4905 1
    set f [open $path(test1) r]
d4913 1
a4913 1
    set f [open $path(test1) w]
d4917 1
a4917 1
    set f [open $path(test1) r]
d4925 1
a4925 1
    set f [open $path(test1) w]
d4931 1
a4931 1
    set f [open "|[list [interpreter] $path(cat)]" r+]
d4936 5
a4940 5
    variable x {}
    fileevent $f readable [namespace code { lappend x [read $f] }]
    vwait [namespace which -variable x]
    after 300 [namespace code { lappend x timeout }]
    vwait [namespace which -variable x]
d4942 3
a4944 3
    vwait [namespace which -variable x]
    after 300 [namespace code { lappend x timeout }]
    vwait [namespace which -variable x]
d4946 3
a4948 3
    vwait [namespace which -variable x]
    after 300 [namespace code { lappend x timeout }]
    vwait [namespace which -variable x]
d4956 1
a4956 1
    set s1 [socket -server [namespace code accept] 0]
d4969 1
a4969 1
    set s1 [socket -server [namespace code accept] 0]
d4982 1
a4982 1
    set s1 [socket -server [namespace code accept] 0]
d4995 1
a4995 1
    set s1 [socket -server [namespace code accept] 0]
a5005 45
test io-39.22 {Tcl_SetChannelOption, invariance} {unixOnly} {
    removeFile test1
    set f1 [open $path(test1) w+]
    set l ""
    lappend l [fconfigure $f1 -eofchar]
    fconfigure $f1 -eofchar {ON GO}
    lappend l [fconfigure $f1 -eofchar]
    fconfigure $f1 -eofchar D
    lappend l [fconfigure $f1 -eofchar]
    close $f1
    set l
} {{{} {}} {O G} {D D}}

test io-39.22a {Tcl_SetChannelOption, invariance} {
    removeFile test1
    set f1 [open $path(test1) w+]
    set l [list]
    fconfigure $f1 -eofchar {ON GO}
    lappend l [fconfigure $f1 -eofchar]
    fconfigure $f1 -eofchar D
    lappend l [fconfigure $f1 -eofchar]
    lappend l [list [catch {fconfigure $f1 -eofchar {1 2 3}} msg] $msg]
    close $f1
    set l
} {{O G} {D D} {1 {bad value for -eofchar: should be a list of zero, one, or two elements}}}


test io-39.23 {Tcl_GetChannelOption, server socket is not readable or
        writeable, it should still have valid -eofchar and -translation options } {
    set l [list]
    set sock [socket -server [namespace code accept] 0]
    lappend l [fconfigure $sock -eofchar] [fconfigure $sock -translation]
    close $sock
    set l
} {{{}} auto}
test io-39.24 {Tcl_SetChannelOption, server socket is not readable or
        writable so we can't change -eofchar or -translation } {
    set l [list]
    set sock [socket -server [namespace code accept] 0]
    fconfigure $sock -eofchar D -translation lf
    lappend l [fconfigure $sock -eofchar] [fconfigure $sock -translation]
    close $sock
    set l
} {{{}} auto}

d5008 1
a5008 1
    set f [open $path(test3) w]
d5011 1
a5011 1
    set f [open $path(test3) RDWR]
d5016 1
a5016 1
    set f [open $path(test3) r]
d5023 2
a5024 2
    set f [open $path(test3) {WRONLY CREAT} 0600]
    file stat $path(test3) stats
d5028 1
a5028 1
    set f [open $path(test3) r]
d5036 1
a5036 1
catch {testConstraint umask2 [expr {[exec umask] == 2}]}
d5041 1
a5041 1
    set f [open $path(test3) {WRONLY CREAT}]
d5048 1
a5048 1
    set f [open $path(test3) w]
d5052 1
a5052 1
    set f [open $path(test3) {WRONLY CREAT}]
d5056 1
a5056 1
    set f [open $path(test3) r]
d5063 1
a5063 1
    set f [open $path(test3) w]
d5067 1
a5067 1
    set f [open $path(test3) {WRONLY APPEND}]
d5073 1
a5073 1
    set f [open $path(test3) r]
d5084 1
a5084 1
    set f [open $path(test3) w]
d5087 1
a5087 1
    set msg [list [catch {open $path(test3) {WRONLY CREAT EXCL}} msg] $msg]
a5088 1
    regsub [file join {} $path(test3)] $msg "test3" msg
d5093 1
a5093 1
    set f [open $path(test3) {WRONLY CREAT EXCL}]
d5101 1
a5101 1
    set f [open $path(test3) w]
d5104 1
a5104 1
    set f [open $path(test3) {WRONLY TRUNC}]
d5107 1
a5107 1
    set f [open $path(test3) r]
d5114 1
a5114 1
    set f [open $path(test3) {WRONLY NONBLOCK CREAT}]
d5117 1
a5117 1
    set f [open $path(test3) r]
d5123 1
a5123 1
    set f [open $path(test1) w]
d5127 1
a5127 1
    set f [open $path(test1) RDONLY]
d5136 1
a5136 3
    set msg [list [catch {open $path(test3) RDONLY} msg] $msg]
    regsub [file join {} $path(test3)] $msg "test3" msg
	string tolower $msg
d5140 1
a5140 3
    set msg [list [catch {open $path(test3) WRONLY} msg] $msg]
    regsub [file join {} $path(test3)] $msg "test3" msg
	string tolower $msg
d5144 1
a5144 1
    set f [open $path(test3) WRONLY]
d5156 1
a5156 3
    set msg [list [catch {open $path(test3) RDWR} msg] $msg]
    regsub [file join {} $path(test3)] $msg "test3" msg
	string tolower $msg
d5160 1
a5160 1
    set f [open $path(test3) RDWR]
d5205 1
a5205 2
set path(foo) [makeFile {} foo]
set f [open $path(foo) w+]
d5267 1
a5267 1
    fileevent $f2 readable [namespace code {
d5269 1
a5269 1
    }]
d5271 2
a5272 2
    variable x initial
    vwait [namespace which -variable x]
d5276 4
a5279 1
    proc ::bgerror args "set [namespace which -variable x] \$args"
d5282 3
a5284 3
    variable x initial
    vwait [namespace which -variable x]
    rename ::bgerror {}
d5288 1
a5288 1
    fileevent $f2 writable [namespace code {
d5294 2
a5295 2
    }]
    variable x initial
d5297 3
a5299 3
    vwait [namespace which -variable x]
    vwait [namespace which -variable x]
    vwait [namespace which -variable x]
d5303 4
a5306 1
    proc ::bgerror args "set [namespace which -variable x] \$args"
d5308 3
a5310 3
    variable x initial
    vwait [namespace which -variable x]
    rename ::bgerror {}
d5314 2
a5315 2
    set f4 [open "|[list [interpreter] $path(cat) << foo]" r]
    fileevent $f4 readable [namespace code {
d5322 4
a5325 4
    }]
    variable x initial
    vwait [namespace which -variable x]
    vwait [namespace which -variable x]
d5337 2
a5338 2
    set f [open $path(foo) r]
    fileevent $f readable [namespace code {
d5341 1
a5341 1
    }]
d5344 2
a5345 3
    after 100 [namespace code { set y done }]
    variable y
    vwait [namespace which -variable y]
d5349 3
a5351 3
    set f  [open $path(foo) r]
    set f2 [open $path(foo) r]
    fileevent $f readable [namespace code {
d5354 2
a5355 2
	}]
    fileevent $f2 readable [namespace code {
d5358 1
a5358 1
    }]
d5360 2
a5361 2
    variable x initial
    vwait [namespace which -variable x]
d5366 3
a5368 3
    set f  [open $path(foo) r]
    set f2 [open $path(foo) r]
    set f3 [open $path(foo) r]
a5387 1
testConstraint testfevent [llength [info commands testfevent]]
d5389 3
a5391 1
test io-46.1 {Tcl event loop vs multiple interpreters} {testfevent} {
d5393 2
a5394 2
    testfevent cmd [format {
        set f [open %s r]
d5396 1
a5396 1
        fileevent $f readable [namespace code {
d5399 2
a5400 2
        }]
    } $path(foo)]
d5406 1
a5406 1
test io-46.2 {Tcl event loop vs multiple interpreters} testfevent {
d5409 1
a5409 1
        variable x 0
d5411 1
a5411 1
        vwait [namespace which -variable x]
d5415 1
a5415 1
test io-46.3 {Tcl event loop vs multiple interpreters} testfevent {
d5429 4
a5432 4
test io-47.1 {fileevent vs multiple interpreters} testfevent {
    set f  [open $path(foo) r]
    set f2 [open $path(foo) r]
    set f3 [open $path(foo) r]
d5448 5
a5452 5
test io-47.2 {deleting fileevent on interpreter delete} testfevent {
    set f  [open $path(foo) r]
    set f2 [open $path(foo) r]
    set f3 [open $path(foo) r]
    set f4 [open $path(foo) r]
d5469 5
a5473 5
test io-47.3 {deleting fileevent on interpreter delete} testfevent {
    set f  [open $path(foo) r]
    set f2 [open $path(foo) r]
    set f3 [open $path(foo) r]
    set f4 [open $path(foo) r]
d5490 3
a5492 3
test io-47.4 {file events on shared files and multiple interpreters} testfevent {
    set f  [open $path(foo) r]
    set f2 [open $path(foo) r]
d5506 2
a5507 2
test io-47.5 {file events on shared files, deleting file events} testfevent {
    set f [open $path(foo) r]
d5519 2
a5520 2
test io-47.6 {file events on shared files, deleting file events} testfevent {
    set f [open $path(foo) r]
d5533 3
a5535 1
set path(bar) [makeFile {} bar]
d5538 1
a5538 1
    set f [open $path(bar) w]
d5545 2
a5546 2
    set f [open $path(bar) r]
    fileevent $f readable [namespace code [list consume $f]]
d5548 1
a5548 2
	variable l
	variable x
d5558 2
a5559 2
    variable x not_done
    vwait [namespace which -variable x]
d5563 1
a5563 1
    set f [open $path(bar) w]
d5570 2
a5571 2
    set f [open $path(bar) r]
    fileevent $f readable [namespace code [list consume $f]]
d5574 1
a5574 2
	variable x
	variable l
d5584 2
a5585 2
    variable x not_done
    vwait [namespace which -variable x]
d5588 2
a5589 5

set path(my_script) [makeFile {} my_script]

test io-48.3 {testing readability conditions} {stdio unixOnly nonBlockFiles} {
    set f [open $path(bar) w]
d5596 1
a5596 1
    set f [open $path(my_script) w]
d5607 2
a5608 2
    set f [open "|[list [interpreter]]" r+]
    fileevent $f readable [namespace code [list consume $f]]
d5612 1
a5612 2
	variable l
	variable x
d5623 3
a5625 3
    variable x not_done
    puts $f [format {source %s}         $path(my_script)]
    puts $f [format {set f [open %s r]} $path(bar)]
d5628 1
a5628 1
    vwait [namespace which -variable x]
d5634 1
a5634 1
    set f [open $path(test1) w]
d5640 1
a5640 3
	variable l
	variable c
	variable x
d5651 1
a5651 1
    set f [open $path(test1) r]
d5653 2
a5654 3
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
d5659 1
a5659 1
    set f [open $path(test1) w]
d5665 1
a5665 3
	variable l
	variable x
	variable c
d5676 1
a5676 1
    set f [open $path(test1) r]
d5678 2
a5679 3
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
d5684 1
a5684 1
    set f [open $path(test1) w]
d5690 1
a5690 3
	variable l
	variable x
	variable c
d5701 1
a5701 1
    set f [open $path(test1) r]
d5703 2
a5704 3
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
d5709 1
a5709 1
    set f [open $path(test1) w]
d5715 1
a5715 3
	variable l
	variable c
	variable x
d5726 1
a5726 1
    set f [open $path(test1) r]
d5728 2
a5729 3
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
d5734 1
a5734 1
    set f [open $path(test1) w]
d5740 1
a5740 3
	variable l
	variable x
	variable c
d5751 1
a5751 1
    set f [open $path(test1) r]
d5753 2
a5754 3
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
d5759 1
a5759 1
    set f [open $path(test1) w]
d5765 1
a5765 3
	variable l
	variable c
	variable x
d5776 1
a5776 1
    set f [open $path(test1) r]
d5778 2
a5779 3
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
d5784 1
a5784 1
    set f [open $path(test1) w]
d5790 1
a5790 3
	variable l
	variable c
	variable x
d5801 1
a5801 1
    set f [open $path(test1) r]
d5803 2
a5804 3
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
d5809 1
a5809 1
    set f [open $path(test1) w]
d5815 1
a5815 3
	variable l
	variable x
	variable c
d5826 1
a5826 1
    set f [open $path(test1) r]
d5828 2
a5829 3
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
d5834 1
a5834 1
    set f [open $path(test1) w]
d5840 1
a5840 3
	variable l
	variable x
	variable c
d5851 1
a5851 1
    set f [open $path(test1) r]
d5853 2
a5854 3
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
d5859 1
a5859 1
    set f [open $path(test1) w]
d5865 1
a5865 3
	variable c
	variable x
	variable l
d5876 1
a5876 1
    set f [open $path(test1) r]
d5878 2
a5879 3
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
d5884 1
a5884 1
    set f [open $path(test1) w]
d5890 1
a5890 3
	variable c
	variable x
	variable l
d5901 1
a5901 1
    set f [open $path(test1) r]
d5903 2
a5904 3
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
d5909 1
a5909 1
    set f [open $path(test1) w]
d5915 1
a5915 3
	variable c
	variable x
	variable l
d5926 1
a5926 1
    set f [open $path(test1) r]
d5928 2
a5929 3
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
d5935 1
a5935 1
    set f [open $path(test1) w]
d5939 1
a5939 1
    set f [open $path(test1) r]
d5941 1
a5941 1
    lappend l [file size $path(test1)]
d5964 1
a5964 1
    set f [open $path(test1) w]
d5968 1
a5968 1
    set f [open $path(test1) r]
d5970 1
a5970 1
    lappend l [file size $path(test1)]
d5987 1
a5987 1
    set f [open $path(test1) w]
d5991 1
a5991 1
    set f [open $path(test1) r]
d5993 1
a5993 1
    lappend l [file size $path(test1)]
d6008 1
a6008 1
    set f [open $path(test1) w]
d6012 1
a6012 1
    set f [open $path(test1) r]
d6014 1
a6014 1
    lappend l [file size $path(test1)]
d6029 1
a6029 1
    set f [open $path(test1) w]
d6033 1
a6033 1
    set f [open $path(test1) r]
d6035 1
a6035 1
    lappend l [file size $path(test1)]
d6046 1
a6046 2
testConstraint testchannelevent [llength [info commands testchannelevent]]
test io-50.1 {testing handler deletion} {testchannelevent} {
d6048 1
a6048 1
    set f [open $path(test1) w]
d6050 2
a6051 2
    set f [open $path(test1) r]
    testchannelevent $f add readable [namespace code [list delhandler $f]]
d6053 1
a6053 1
	variable z
d6062 1
a6062 1
test io-50.2 {testing handler deletion with multiple handlers} {testchannelevent} {
d6064 1
a6064 1
    set f [open $path(test1) w]
d6066 3
a6068 3
    set f [open $path(test1) r]
    testchannelevent $f add readable [namespace code [list delhandler $f 1]]
    testchannelevent $f add readable [namespace code [list delhandler $f 0]]
d6070 1
a6070 1
	variable z
d6080 1
a6080 1
test io-50.3 {testing handler deletion with multiple handlers} {testchannelevent} {
d6082 1
a6082 1
    set f [open $path(test1) w]
d6084 3
a6086 3
    set f [open $path(test1) r]
    testchannelevent $f add readable [namespace code [list notcalled $f 1]]
    testchannelevent $f add readable [namespace code [list delhandler $f 0]]
d6089 1
a6089 1
	variable z
d6093 1
a6093 1
	variable z
d6106 1
a6106 1
test io-50.4 {testing handler deletion vs reentrant calls} {testchannelevent} {
d6108 1
a6108 1
    set f [open $path(test1) w]
d6110 2
a6111 2
    set f [open $path(test1) r]
    testchannelevent $f add readable [namespace code [list delrecursive $f]]
d6113 1
a6113 2
	variable z
	variable u
d6130 1
a6130 1
test io-50.5 {testing handler deletion vs reentrant calls} {testchannelevent} {
d6132 1
a6132 1
    set f [open $path(test1) w]
d6134 3
a6136 3
    set f [open $path(test1) r]
    testchannelevent $f add readable [namespace code [list notcalled $f]]
    testchannelevent $f add readable [namespace code [list del $f]]
d6138 1
a6138 1
	variable z
d6142 1
a6142 2
	variable u
	variable z
d6163 1
a6163 1
test io-50.6 {testing handler deletion vs reentrant calls} {testchannelevent} {
d6165 1
a6165 1
    set f [open $path(test1) w]
d6167 3
a6169 3
    set f [open $path(test1) r]
    testchannelevent $f add readable [namespace code [list second $f]]
    testchannelevent $f add readable [namespace code [list first $f]]
d6171 1
a6171 2
	variable u
	variable z
d6182 1
a6182 2
	variable u
	variable z
d6209 1
a6209 2
	variable x
	variable wait
d6215 4
a6218 4
    set ss [socket -server [namespace code accept] 0]
    variable wait ""
    set cs [socket [info hostname] [lindex [fconfigure $ss -sockname] 2]]
    vwait [namespace which -variable wait]
d6223 2
a6224 2
    set cs [socket [info hostname] [lindex [fconfigure $ss -sockname] 2]]
    vwait [namespace which -variable wait]
d6229 2
a6230 2
    set cs [socket [info hostname] [lindex [fconfigure $ss -sockname] 2]]
    vwait [namespace which -variable wait]
d6235 2
a6236 2
    set cs [socket [info hostname] [lindex [fconfigure $ss -sockname] 2]]
    vwait [namespace which -variable wait]
d6246 1
a6246 1
    set f2 [open $path(test1) w]
d6256 1
a6256 1
    set f2 [open $path(test1) w]
d6268 1
a6268 1
    set f2 [open $path(test1) w]
d6276 1
a6276 1
    set s2 [file size $path(test1)]
d6285 1
a6285 1
    set f2 [open $path(test1) w]
d6292 1
a6292 1
    lappend result [file size $path(test1)]
d6297 1
a6297 1
    set f2 [open $path(test1) w]
d6305 1
a6305 1
    set s2 [file size $path(test1)]
d6314 1
a6314 1
    set f2 [open $path(test1) w]
d6322 1
a6322 1
    set s2 [file size $path(test1)]
d6331 1
a6331 1
    set f2 [open $path(test1) w]
d6337 1
a6337 1
    set s2 [file size $path(test1)]
d6348 1
a6348 1
    set f1 [open $path(pipe) w]
d6359 1
a6359 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d6364 1
a6364 1
    set f2 [open $path(test1) w]
d6369 1
a6369 1
    list $s0 [file size $path(test1)]
a6371 79
# Empty files, to register them with the test facility
set path(kyrillic.txt)   [makeFile {} kyrillic.txt]
set path(utf8-fcopy.txt) [makeFile {} utf8-fcopy.txt]
set path(utf8-rp.txt)    [makeFile {} utf8-rp.txt]

# Create kyrillic file, use lf translation to avoid os eol issues
set out [open $path(kyrillic.txt) w]
fconfigure $out -encoding koi8-r -translation lf
puts       $out "\u0410\u0410"
close      $out

test io-52.9 {TclCopyChannel & encodings} {
    # Copy kyrillic to UTF-8, using fcopy.

    set in  [open $path(kyrillic.txt) r]
    set out [open $path(utf8-fcopy.txt) w]

    fconfigure $in  -encoding koi8-r -translation lf
    fconfigure $out -encoding utf-8 -translation lf

    fcopy $in $out
    close $in
    close $out

    # Do the same again, but differently (read/puts).

    set in  [open $path(kyrillic.txt) r]
    set out [open $path(utf8-rp.txt) w]

    fconfigure $in  -encoding koi8-r -translation lf
    fconfigure $out -encoding utf-8 -translation lf

    puts -nonewline $out [read $in]

    close $in
    close $out

    list [file size $path(kyrillic.txt)] \
	    [file size $path(utf8-fcopy.txt)] \
	    [file size $path(utf8-rp.txt)]
} {3 5 5}

test io-52.10 {TclCopyChannel & encodings} {
    # encoding to binary (=> implies that the
    # internal utf-8 is written)

    set in  [open $path(kyrillic.txt) r]
    set out [open $path(utf8-fcopy.txt) w]

    fconfigure $in  -encoding koi8-r -translation lf
    # -translation binary is also -encoding binary
    fconfigure $out -translation binary

    fcopy $in $out
    close $in
    close $out

    file size $path(utf8-fcopy.txt)
} 5

test io-52.11 {TclCopyChannel & encodings} {
    # binary to encoding => the input has to be
    # in utf-8 to make sense to the encoder

    set in  [open $path(utf8-fcopy.txt) r]
    set out [open $path(kyrillic.txt) w]

    # -translation binary is also -encoding binary
    fconfigure $in  -translation binary
    fconfigure $out -encoding koi8-r -translation lf

    fcopy $in $out
    close $in
    close $out

    file size $path(kyrillic.txt)
} 3


d6375 1
a6375 1
    set f2 [open $path(test1) w]
d6382 1
a6382 1
    lappend result [file size $path(test1)]
d6387 1
a6387 1
    set f2 [open $path(test1) w]
d6390 1
a6390 1
    fcopy $f1 $f2 -command [namespace code {set s0}]
d6392 1
a6392 2
    variable s0
    vwait [namespace which -variable s0]
d6396 1
a6396 1
    set s2 [file size $path(test1)]
d6402 1
a6402 1
test io-53.3 {CopyData: background read underflow} {stdio unixOnly} {
d6405 2
a6406 2
    set f1 [open $path(pipe) w]
    puts $f1 [format {
d6411 1
a6411 1
	set f [open "%s" w]
d6415 1
a6415 1
    } $path(test1)]
d6417 1
a6417 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d6427 1
a6427 1
    set f [open $path(test1)]
d6432 1
a6432 1
test io-53.4 {CopyData: background write overflow} {stdio unixOnly} {
a6433 1
    variable x
d6439 1
a6439 1
    set f1 [open $path(pipe) w]
d6444 1
a6444 1
	set f [open $path(test1) w]
d6450 1
a6450 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d6457 1
a6457 1
    fileevent $f1 read [namespace code {
d6462 2
a6463 2
    }]
    vwait [namespace which -variable x]
d6474 1
a6474 1
    variable fcopyTestDone
d6483 1
a6483 2
    variable fcopyTestDone
    set listen [socket -server [namespace code FcopyTestAccept] 0]
d6485 1
a6485 1
    set out [socket 127.0.0.1 [lindex [fconfigure $listen -sockname] 2]]
d6488 1
a6488 2
    fcopy $in $out -command [namespace code FcopyTestDone]
    variable fcopyTestDone
d6490 1
a6490 1
	vwait [namespace which -variable fcopyTestDone]		;# The error occurs here in the b.g.
a6496 1
    variable fcopyTestDone
d6500 1
a6500 1
    set f1 [open $path(pipe) w]
d6503 3
a6505 4
    set in [open "|[list [interpreter] $path(pipe)]" r+]
    set out [open $path(test1) w]
    fcopy $in $out -command [namespace code FcopyTestDone]
    variable fcopyTestDone
d6507 1
a6507 1
	vwait [namespace which -variable fcopyTestDone]
a6513 53
proc doFcopy {in out {bytes 0} {error {}}} {
    variable fcopyTestDone
    variable fcopyTestCount
    incr fcopyTestCount $bytes
    if {[string length $error]} {
	    set fcopyTestDone 1
    } elseif {[eof $in]} {
	    set fcopyTestDone 0
    } else {
        # Delay next fcopy to wait for size>0 input bytes
        after 100 [list 
            fcopy $in $out -size 1000 \
		    -command [namespace code [list doFcopy $in $out]]
        ]
    }
}

test io-53.7 {CopyData: Flooding fcopy from pipe} {stdio} {
    variable fcopyTestDone
    removeFile pipe
    removeFile test1
    catch {unset fcopyTestDone}
    set fcopyTestCount 0
    set f1 [open $path(pipe) w]
    puts $f1 {
	# Write  10 bytes / 10 msec
	proc Write {count} {
	    puts -nonewline "1234567890"
	    if {[incr count -1]} {
	        after 10 [list Write $count]
	    } else {
	        set ::ready 1
	    }
	}
	fconfigure stdout -buffering none
	Write 345 ;# 3450 bytes ~3.45 sec
	vwait ready
	exit 0
    }
    close $f1
    set in [open "|[list [interpreter] $path(pipe) &]" r+]
    set out [open $path(test1) w]
    doFcopy $in $out
    variable fcopyTestDone
    if ![info exists fcopyTestDone] {
	vwait [namespace which -variable fcopyTestDone]
    }
    catch {close $in}
    close $out
    # -1=error 0=script error N=number of bytes
    expr ($fcopyTestDone == 0) ? $fcopyTestCount : -1
} {3450}

d6519 1
a6519 1
	variable as
d6526 1
a6526 2
	variable x
	variable result
d6529 2
a6530 2
	    fileevent $s readable [namespace code [list readit $s 2]]
	    vwait [namespace which -variable x]
d6534 1
a6534 1
    set ss [socket -server [namespace code accept] 0]
d6541 1
a6541 1
	if {![catch {set cs [socket [info hostname] [lindex [fconfigure $ss -sockname] 2]]}]} {
d6551 3
a6553 4
    variable result {}
    variable x 0
    variable as
    vwait [namespace which -variable as]
d6557 3
a6559 3
    fileevent $cs readable [namespace code [list readit $cs 1]]
    set a [after 2000 [namespace code { set x failure }]]
    vwait [namespace which -variable x]
d6569 1
a6569 1
    variable s [socket -server [namespace code accept] 0]
d6571 1
a6571 2
	variable counter
	variable accept
d6576 1
a6576 1
	fileevent $s readable [namespace code "doit $s"]
d6579 1
a6579 2
	variable counter
	variable after
d6584 2
a6585 2
	    fileevent $s readable [namespace code "doit1 $s"]
	    set after [after 1000 [namespace code newline]]
d6589 1
a6589 2
	variable counter
	variable accept
d6597 1
a6597 2
	variable s
	variable writer
d6599 1
a6599 1
	set writer [socket 127.0.0.1 [lindex [fconfigure $s -sockname] 2]]
d6605 1
a6605 2
	variable done
	variable writer
d6612 1
a6612 2
    variable done
    vwait [namespace which -variable done]
a6619 2
set path(fooBar) [makeFile {} fooBar]

a6620 1
    variable x
a6621 1
	variable x
d6624 1
a6624 1
	set x whoops
d6626 7
a6632 5
    proc ::bgerror {args} "set [namespace which -variable x] got_error"
    set f [open $path(fooBar) w]
    fileevent $f writable [namespace code [list eventScript $f]]
    variable x not_done
    vwait [namespace which -variable x]
d6636 2
a6637 2
test io-56.1 {ChannelTimerProc} {testchannelevent} {
    set f [open $path(fooBar) w]
d6640 2
a6641 2
    set f [open $path(fooBar) r]
    testchannelevent $f add readable [namespace code {
d6644 4
a6647 4
    }]
    variable x 0
    vwait [namespace which -variable x]
    vwait [namespace which -variable x]
d6650 2
a6651 3
    after idle [namespace code {set y done}]
    variable y
    vwait [namespace which -variable y]
d6658 1
a6658 2
	variable s2
	set s2 $sock
d6660 3
a6662 4
    set server [socket -server [namespace code accept] 0]
    set s [socket 127.0.0.1 [lindex [fconfigure $server -sockname] 2]]
    variable s2
    vwait [namespace which -variable s2]
d6664 1
a6664 1
    fileevent $s2 readable [namespace code {lappend result readable}]
d6667 3
a6669 3
    variable result [gets $s2]
    after 1000 [namespace code {lappend result timer}]
    vwait [namespace which -variable result]
d6671 1
a6671 1
    vwait [namespace which -variable result]
d6679 1
a6679 2
	variable s2
	set s2 $sock
d6681 3
a6683 4
    set server [socket -server [namespace code accept] 0]
    set s [socket 127.0.0.1 [lindex [fconfigure $server -sockname] 2]]
    variable s2
    vwait [namespace which -variable s2]
d6685 1
a6685 1
    fileevent $s2 readable [namespace code {lappend result readable}]
d6688 3
a6690 3
    variable result [read $s2 1]
    after 1000 [namespace code {lappend result timer}]
    vwait [namespace which -variable result]
d6692 1
a6692 1
    vwait [namespace which -variable result]
d6699 2
a6700 2
test io-58.1 {Tcl_NotifyChannel and error when closing} {stdio unixOrPc} {
    set out [open $path(script) w]
d6707 1
a6707 2
	variable x
	variable result
d6717 3
a6719 3
    set pipe [open "|[list [interpreter] $path(script)]" r]
    fileevent $pipe readable [namespace code [list readit $pipe]]
    variable x ""
d6721 1
a6721 1
    vwait [namespace which -variable x]
d6725 12
a6737 7
testConstraint testmainthread [llength [info commands testmainthread]]
test io-59.1 {Thread reference of channels} {testmainthread testchannel} {
    # TIP #10
    # More complicated tests (like that the reference changes as a
    # channel is moved from thread to thread) can be done only in the
    # extension which fully implements the moving of channels between
    # threads, i.e. 'Threads'. Or we have to extend [testthread] as well.
a6738 5
    set f [open $path(longfile) r]
    set result [testchannel mthread $f]
    close $f
    string equal $result [testmainthread]
} {1}
a6740 2
test io-60.1 {writing illegal utf sequences} {
    # This test will hang in older revisions of the core.
a6741 22
    set out [open $path(script) w]
    puts $out {
	puts [encoding convertfrom identity \xe2]
	exit 1
    }
    proc readit {pipe} {
	variable x
	variable result
	if {[eof $pipe]} {
	    set x [catch {close $pipe} line]
	    lappend result catch $line
	} else {
	    gets $pipe line
	    lappend result gets $line
	}
    }
    close $out
    set pipe [open "|[list [interpreter] $path(script)]" r]
    fileevent $pipe readable [namespace code [list readit $pipe]]
    variable x ""
    set result ""
    vwait [namespace which -variable x]
a6742 4
    # cut of the remainder of the error stack, especially the filename
    set result [lreplace $result 3 3 [lindex [split [lindex $result 3] \n] 0]]
    list $x $result
} {1 {gets {} catch {error writing "stdout": invalid argument}}}
a6746 9
# cleanup
foreach file [list fooBar longfile script output test1 pipe my_script foo \
	bar test2 test3 cat stdout] {
    removeFile $file
}
cleanupTests
}
namespace delete ::tcl::test::io
return
@


1.2
log
@touched all Tcl files to ease next import.
@
text
@@


1.2.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.2.16.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d17 8
a24 2
if {[catch {package require tcltest 2}]} {
    puts stderr "Skipping tests in [info script].  tcltest 2 required."
a26 1
namespace eval ::tcl::test::io {
d28 1
a28 14
    namespace import ::tcltest::cleanupTests
    namespace import ::tcltest::interpreter
    namespace import ::tcltest::makeFile
    namespace import ::tcltest::removeFile
    namespace import ::tcltest::test
    namespace import ::tcltest::testConstraint
    namespace import ::tcltest::viewFile

testConstraint testchannel [llength [info commands testchannel]]
testConstraint exec [llength [info commands exec]]

# You need a *very* special environment to do some tests.  In
# particular, many file systems do not support large-files...
testConstraint largefileSupport 0
d33 2
d37 1
a37 2
set path(longfile) [makeFile {} longfile]
set f [open $path(longfile) w]
d46 1
a46 1
set path(cat) [makeFile {
d63 1
a63 1
} cat]
a77 3

set path(test1) [makeFile {} test1]

d79 1
a79 1
    set f [open $path(test1) w]
d83 1
a83 1
    contents $path(test1)
d86 1
a86 1
    set f [open $path(test1) w]
d90 1
a90 1
    contents $path(test1)
a92 16
set path(test2) [makeFile {} test2]

test io-1.8 {Tcl_WriteChars: WriteChars} {
    # This test written for SF bug #506297.
    #
    # Executing this test without the fix for the referenced bug
    # applied to tcl will cause tcl, more specifically WriteChars, to
    # go into an infinite loop.

    set f [open $path(test2) w] 
    fconfigure      $f -encoding iso2022-jp 
    puts -nonewline $f [format %s%c [string repeat " " 4] 12399] 
    close           $f 
    contents $path(test2)
} "    \x1b\$B\$O\x1b(B"

d96 1
a96 1
    set f [open $path(test1) w]
d100 1
a100 1
    contents $path(test1)
d106 1
a106 1
    set f [open $path(test1) w]
d109 1
a109 1
    set x [list [contents $path(test1)]]
d111 1
a111 1
    lappend x [contents $path(test1)]
d118 1
a118 1
    set f [open $path(test1) w]
d121 1
a121 1
    set x [contents $path(test1)]
d126 1
a126 1
    set f [open $path(test1) w]
d130 1
a130 1
    set x [list [contents $path(test1)]]
d132 1
a132 1
    lappend x [contents $path(test1)]
d138 1
a138 1
    set f [open $path(test1) w]
d142 1
a142 1
    contents $path(test1)
d148 1
a148 1
    set f [open $path(test1) w]
d151 1
a151 1
    set x [list [contents $path(test1)]]
d153 1
a153 1
    lappend x [contents $path(test1)]
d160 1
a160 1
    set f [open $path(test1) w]
d163 1
a163 1
    set x [contents $path(test1)]
d170 1
a170 1
    set f [open $path(test1) w]
d173 1
a173 1
    set x [list [contents $path(test1)]]
d175 1
a175 1
    lappend x [contents $path(test1)]
d182 1
a182 1
    set f [open $path(test1) w]
d185 1
a185 1
    set x [list [contents $path(test1)]]
d187 1
a187 1
    lappend x [contents $path(test1)]
d199 1
a199 1
    set f [open $path(test1) w]
d202 1
a202 1
    set x [list [contents $path(test1)]]
d204 1
a204 1
    lappend x [contents $path(test1)]
d213 1
a213 1
    set f [open $path(test1) w]
d216 1
a216 1
    set x [list [contents $path(test1)]]
d218 1
a218 1
    lappend x [contents $path(test1)]
d221 1
a221 1
    set f [open $path(test1) w]
d225 1
a225 1
    set x [list [contents $path(test1)]]
d227 1
a227 1
    lappend x [contents $path(test1)]
d233 1
a233 1
    set f [open $path(test1) w]
d236 1
a236 1
    set x [list [contents $path(test1)]]
d238 1
a238 1
    lappend x [contents $path(test1)]
d243 1
a243 1
    set f [open $path(test1) w]
d246 1
a246 1
    set x [list [contents $path(test1)]]
d248 1
a248 1
    lappend x [contents $path(test1)]
d253 1
a253 1
    set f [open $path(test1) w]
d256 1
a256 1
    set x [list [contents $path(test1)]]
d258 1
a258 1
    lappend x [contents $path(test1)]
d265 1
a265 1
    set f [open $path(test1) w]
d268 1
a268 1
    set x [list [contents $path(test1)]]
d270 1
a270 1
    lappend x [contents $path(test1)]
d275 1
a275 1
    set f [open $path(test1) w]
d279 1
a279 1
    set x [contents $path(test1)]
d283 1
a283 1
    set f [open $path(test1) w]
d286 1
a286 1
    set x [list [contents $path(test1)]]
d288 1
a288 1
    lappend x [contents $path(test1)]
d291 1
a291 1
    set f [open $path(test1) w]
d294 1
a294 1
    set x [list [contents $path(test1)]]
d296 1
a296 1
    lappend x [contents $path(test1)]
d299 1
a299 1
    set f [open $path(test1) w]
d302 1
a302 1
    set x [list [contents $path(test1)]]
d304 1
a304 1
    lappend x [contents $path(test1)]
d307 1
a307 1
    set f [open $path(test1) w]
d310 1
a310 1
    set x [list [contents $path(test1)]]
d312 1
a312 1
    lappend x [contents $path(test1)]
d315 1
a315 1
    set f [open $path(test1) w]
d318 1
a318 1
    set x [list [contents $path(test1)]]
d320 1
a320 1
    lappend x [contents $path(test1)]
d324 1
a324 1
    set f [open $path(test1) w]
d327 1
a327 1
    set f [open $path(test1)]
d338 1
a338 1
    set f [open $path(test1) w]
d342 1
a342 1
    set f [open $path(test1)]
d348 1
a348 1
    set f [open $path(test1) w]
d352 1
a352 1
    set f [open $path(test1)]
d359 1
a359 1
    set f [open $path(test1) w]
d363 1
a363 1
    set f [open $path(test1)]
d375 1
a375 1
    set f [open $path(test1) w]
d379 1
a379 1
    set f [open $path(test1)]
d387 1
a387 1
    set f [open "|[list [interpreter] cat]" w+]
d397 1
a397 1
    set f [open $path(test1) w]
d400 1
a400 1
    set f [open $path(test1)]
d407 1
a407 1
    set f [open $path(test1) w]
d410 1
a410 1
    set f [open $path(test1)]
d420 1
a420 1
    set f [open $path(test1) w]
d422 1
a422 1
    set f [open $path(test1)]
d429 1
a429 1
    set f [open $path(test1) w]
d433 1
a433 1
    set f [open $path(test1)]
d440 1
a440 1
    set f [open $path(test1) w]
d444 1
a444 1
    set f [open $path(test1)]
d451 1
a451 1
    set f [open $path(test1) w]
d455 1
a455 1
    set f [open $path(test1)]
d462 1
a462 1
    set f [open $path(test1) w]
d466 1
a466 1
    set f [open $path(test1)]
d473 1
a473 1
    set f [open $path(test1) w]
d477 1
a477 1
    set f [open $path(test1)]
d484 1
a484 1
    set f [open $path(test1) w]
d486 1
a486 1
    set f [open $path(test1)]
d493 1
a493 1
    set f [open $path(test1) w]
d497 1
a497 1
    set f [open $path(test1)]
d504 1
a504 1
    set f [open $path(test1) w]
d508 1
a508 1
    set f [open $path(test1)]
d515 1
a515 1
    set f [open $path(test1) w]
d519 1
a519 1
    set f [open $path(test1)]
d526 1
a526 1
    set f [open $path(test1) w]
d530 1
a530 1
    set f [open $path(test1)]
d537 1
a537 1
    set f [open $path(test1) w]
d541 1
a541 1
    set f [open $path(test1)]
d548 1
a548 1
    set f [open $path(test1) w]
d550 1
a550 1
    set f [open $path(test1)]
d557 1
a557 1
    set f [open $path(test1) w]
d561 1
a561 1
    set f [open $path(test1)]
d568 1
a568 1
    set f [open $path(test1) w]
d572 1
a572 1
    set f [open $path(test1)]
d579 1
a579 1
    set f [open $path(test1) w]
d583 1
a583 1
    set f [open $path(test1)]
d590 1
a590 1
    set f [open $path(test1) w]
d594 1
a594 1
    set f [open $path(test1)]
d601 1
a601 1
    set f [open $path(test1) w]
d605 1
a605 1
    set f [open $path(test1)]
d612 1
a612 1
    set f [open $path(test1) w]
d616 1
a616 1
    set f [open $path(test1)]
d623 1
a623 1
    set f [open $path(test1) w]
d627 1
a627 1
    set f [open $path(test1)]
d633 1
a633 1
test io-6.30 {Tcl_GetsObj: crlf mode: buffer exhausted} {testchannel} {
d636 1
a636 1
    set f [open $path(test1) w]
d640 1
a640 1
    set f [open $path(test1)]
d646 1
a646 1
test io-6.31 {Tcl_GetsObj: crlf mode: buffer exhausted, blocked} {stdio testchannel} {
d649 1
a649 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d659 1
a659 1
test io-6.32 {Tcl_GetsObj: crlf mode: buffer exhausted, more data} {testchannel} {
d662 1
a662 1
    set f [open $path(test1) w]
d666 1
a666 1
    set f [open $path(test1)]
d675 1
a675 1
    set f [open $path(test1) w]
d679 1
a679 1
    set f [open $path(test1)]
d688 1
a688 1
    set f [open $path(test1) w]
d692 1
a692 1
    set f [open $path(test1)]
d699 1
a699 1
    set f [open $path(test1) w]
d701 1
a701 1
    set f [open $path(test1)]
d708 1
a708 1
    set f [open $path(test1) w]
d712 1
a712 1
    set f [open $path(test1)]
d719 1
a719 1
    set f [open $path(test1) w]
d723 1
a723 1
    set f [open $path(test1)]
d730 1
a730 1
    set f [open $path(test1) w]
d734 1
a734 1
    set f [open $path(test1)]
d741 1
a741 1
    set f [open $path(test1) w]
d745 1
a745 1
    set f [open $path(test1)]
d752 1
a752 1
    set f [open $path(test1) w]
d756 1
a756 1
    set f [open $path(test1)]
d763 1
a763 1
    set f [open $path(test1) w]
d767 1
a767 1
    set f [open $path(test1)]
d774 1
a774 1
    set f [open $path(test1) w]
d778 1
a778 1
    set f [open $path(test1)]
d785 1
a785 1
test io-6.43 {Tcl_GetsObj: input saw cr} {stdio testchannel} {
d788 1
a788 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d802 1
a802 1
test io-6.44 {Tcl_GetsObj: input saw cr, not followed by cr} {stdio testchannel} {
d805 1
a805 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d819 1
a819 1
test io-6.45 {Tcl_GetsObj: input saw cr, skip right number of bytes} {stdio testchannel} {
d822 1
a822 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d836 1
a836 1
test io-6.46 {Tcl_GetsObj: input saw cr, followed by just \n should give eof} {stdio testchannel} {
d839 1
a839 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d852 1
a852 1
test io-6.47 {Tcl_GetsObj: auto mode: \r at end of buffer, peek for \n} {testchannel} {
d855 1
a855 1
    set f [open $path(test1) w]
d859 1
a859 1
    set f [open $path(test1)]
d865 1
a865 1
test io-6.48 {Tcl_GetsObj: auto mode: \r at end of buffer, no more avail} {testchannel} {
d868 1
a868 1
    set f [open $path(test1) w]
d872 1
a872 1
    set f [open $path(test1)]
d878 1
a878 1
test io-6.49 {Tcl_GetsObj: auto mode: \r followed by \n} {testchannel} {
d881 1
a881 1
    set f [open $path(test1) w]
d885 1
a885 1
    set f [open $path(test1)]
d890 1
a890 1
test io-6.50 {Tcl_GetsObj: auto mode: \r not followed by \n} {testchannel} {
d893 1
a893 1
    set f [open $path(test1) w]
d897 1
a897 1
    set f [open $path(test1)]
d905 1
a905 1
    set f [open $path(test1) w]
d909 1
a909 1
    set f [open $path(test1)]
d914 1
a914 1
test io-6.52 {Tcl_GetsObj: saw EOF character} {testchannel} {
d917 1
a917 1
    set f [open $path(test1) w]
d921 1
a921 1
    set f [open $path(test1)]
d930 1
a930 1
    set f [open $path(test1) w]
d932 1
a932 1
    set f [open $path(test1)]
d940 1
a940 1
    set f [open $path(test1) w]
d943 1
a943 1
    set f [open $path(test1)]
d951 1
a951 1
    set f [open $path(test1) w]
d955 1
a955 1
    set f [open $path(test1)]
d963 1
a963 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d967 5
a971 5
    variable x {}
    after 500 [namespace code { lappend x timeout }]
    fileevent $f readable [namespace code { lappend x [gets $f] }]
    vwait [namespace which -variable x]
    vwait [namespace which -variable x]
d974 1
a974 1
    after 500 [namespace code { lappend x timeout }]
d976 2
a977 2
    vwait [namespace which -variable x]
    vwait [namespace which -variable x]
d985 1
a985 1
    set f [open $path(test1) w]
d989 1
a989 1
    set f [open $path(test1)]
d998 1
a998 1
    set f [open $path(test1) w]
d1002 1
a1002 1
    set f [open $path(test1)]
d1008 2
a1009 2
test io-7.3 {FilterInputBytes: split up character at EOF} {testchannel} {
    set f [open $path(test1) w]
d1013 1
a1013 1
    set f [open $path(test1)]
d1022 1
a1022 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d1026 2
a1027 2
    fileevent $f read [namespace code "ready $f"]
    variable x {}
d1029 1
a1029 2
	variable x
	lappend x [gets $f line] $line [fblocked $f]
d1031 1
a1031 1
    vwait [namespace which -variable x]
d1035 1
a1035 1
    vwait [namespace which -variable x]
d1040 1
a1040 1
test io-8.1 {PeekAhead: only go to device if no more cached data} {testchannel} {
d1043 1
a1043 1
    set f [open $path(test1) w]
d1047 1
a1047 1
    set f [open $path(test1)]
d1055 1
a1055 1
test io-8.2 {PeekAhead: only go to device if no more cached data} {stdio testchannel} {
d1058 1
a1058 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d1061 2
a1062 2
    variable x {}
    fileevent $f read [namespace code "ready $f"]
d1064 1
a1064 2
	variable x
	lappend x [gets $f line] $line [testchannel inputbuffered $f]
d1067 1
a1067 1
    vwait [namespace which -variable x]
d1070 1
a1070 1
    vwait [namespace which -variable x]
d1074 1
a1074 1
test io-8.3 {PeekAhead: no cached data available} {stdio testchannel} {
d1077 1
a1077 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d1091 1
a1091 1
    set f [open $path(test1) w+]
d1095 1
a1095 1
    set f [open $path(test1)]
d1107 1
a1107 1
test io-8.5 {PeekAhead: don't peek if last read was short} {stdio testchannel} {
d1110 1
a1110 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d1119 1
a1119 1
test io-8.6 {PeekAhead: change to non-blocking mode} {stdio testchannel} {
d1122 1
a1122 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d1131 1
a1131 1
test io-8.7 {PeekAhead: cleanup} {stdio testchannel} {
d1134 1
a1134 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d1156 1
a1156 1
    set f [open $path(test1) w]
d1160 1
a1160 1
    set f [open $path(test1)]
d1169 1
a1169 1
    set f [open $path(test1) w]
d1173 1
a1173 1
    set f [open $path(test1)]
d1183 1
a1183 1
    set f [open $path(test1) w]
d1187 1
a1187 1
    set f [open $path(test1)]
d1196 1
a1196 1
    set f [open $path(test1) w]
d1200 1
a1200 1
    set f [open $path(test1)]
d1210 1
a1210 1
    set f [open $path(test1) w]
d1213 1
a1213 1
    set f [open $path(test1)]
d1223 1
a1223 1
    set f [open $path(test1) w]
d1226 1
a1226 1
    set f [open $path(test1)]
d1236 1
a1236 1
    set f [open $path(test1) w]
d1239 1
a1239 1
    set f [open $path(test1)]
d1249 1
a1249 1
    set f [open $path(test1) w]
d1252 1
a1252 1
    set f [open $path(test1)]
d1263 1
a1263 1
    set f [open $path(test1) w]
d1266 1
a1266 1
    set f [open $path(test1)]
d1275 1
a1275 1
    set f [open $path(test1) w]
d1278 1
a1278 1
    set f [open $path(test1)]
d1287 1
a1287 1
    set f [open $path(test1) w]
d1290 1
a1290 1
    set f [open $path(test1)]
d1297 1
a1297 1
test io-12.4 {ReadChars: split-up char} {stdio testchannel} {
d1300 1
a1300 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d1305 1
a1305 1
    fileevent $f read [namespace code "ready $f"]
d1307 1
a1307 2
	variable x
	lappend x [read $f] [testchannel inputbuffered $f]
d1309 1
a1309 1
    variable x {}
d1312 1
a1312 1
    vwait [namespace which -variable x]
d1317 1
a1317 1
    vwait [namespace which -variable x]
d1322 1
a1322 1
    set path(test1) [makeFile {
d1327 3
a1329 3
    } test1]
    set f [open "|[list [interpreter] $path(test1)]" r+]
    fileevent $f readable [namespace code {
d1334 1
a1334 1
    }]
d1338 4
a1341 4
    variable x {}
    vwait [namespace which -variable x]
    after 500 [namespace code { lappend x timeout }]
    vwait [namespace which -variable x]
d1344 3
a1346 3
    vwait [namespace which -variable x]
    after 500 [namespace code { lappend x timeout }]
    vwait [namespace which -variable x]
d1349 2
a1350 2
    vwait [namespace which -variable x]
    vwait [namespace which -variable x]
d1356 1
a1356 1
    set f [open $path(test1) w]
d1360 1
a1360 1
    set f [open $path(test1)]
d1367 1
a1367 1
    set f [open $path(test1) w]
d1371 1
a1371 1
    set f [open $path(test1)]
d1380 1
a1380 1
    set f [open $path(test1) w]
d1384 1
a1384 1
    set f [open $path(test1)]
d1393 1
a1393 1
    set f [open $path(test1) w]
d1397 1
a1397 1
    set f [open $path(test1)]
d1406 1
a1406 1
    set f [open $path(test1) w]
d1410 1
a1410 1
    set f [open $path(test1)]
d1416 1
a1416 1
test io-13.6 {TranslateInputEOL: auto mode: saw cr in last segment} {stdio testchannel} {
d1420 1
a1420 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d1423 1
a1423 1
    fileevent $f read [namespace code "ready $f"]
d1425 1
a1425 2
	variable x
	lappend x [read $f] [testchannel queuedcr $f]
d1427 1
a1427 2
    variable x {}
    variable y {}
d1430 2
a1431 2
    after 500 [namespace code {set y ok}]
    vwait [namespace which -variable y]
d1434 2
a1435 2
    after 500 [namespace code {set y ok}]
    vwait [namespace which -variable y]
d1440 1
a1440 1
test io-13.7 {TranslateInputEOL: auto mode: naked \r} {testchannel} {
d1443 1
a1443 1
    set f [open $path(test1) w]
d1447 1
a1447 1
    set f [open $path(test1)]
d1456 1
a1456 1
    set f [open $path(test1) w]
d1460 1
a1460 1
    set f [open $path(test1)]
d1467 1
a1467 1
    set f [open $path(test1) w]
d1471 1
a1471 1
    set f [open $path(test1)]
d1480 1
a1480 1
    set f [open $path(test1) w]
d1484 1
a1484 1
    set f [open $path(test1)]
d1493 1
a1493 1
    set f [open $path(test1) w]
d1497 1
a1497 1
    set f [open $path(test1)]
d1506 1
a1506 1
    set f [open $path(test1) w]
d1510 1
a1510 1
    set f [open $path(test1)]
d1521 2
a1522 6
if {[info commands testchannel] != ""} {
    if {$tcl_platform(platform) == "macintosh"} {
	set consoleFileNames [list console0 console1 console2]
    } else {
	set consoleFileNames [lsort [testchannel open]]
    }
d1524 1
a1524 2
    # just to avoid an error
    set consoleFileNames [list]
d1526 1
a1526 2

test io-14.1 {Tcl_SetStdChannel and Tcl_GetStdChannel} {testchannel} {
d1543 3
a1545 6

set path(test3) [makeFile {} test3]

test io-14.3 {Tcl_SetStdChannel & Tcl_GetStdChannel} {exec} {
    set f [open $path(test1) w]
    puts $f [format {
d1549 3
a1551 3
	set f  [open "%s" r]
	set f2 [open "%s" w]
	set f3 [open "%s" w]
d1558 1
a1558 1
    } $path(test1) $path(test2) $path(test3)]
d1560 3
a1562 3
    set result [exec [interpreter] $path(test1)]
    set f  [open $path(test2) r]
    set f2 [open $path(test3) r]
d1572 3
a1574 3
test io-14.4 {Tcl_SetStdChannel & Tcl_GetStdChannel} {exec unixOnly} {
    set f [open $path(test1) w]
    puts $f [format { close stdin
d1577 3
a1579 3
	set f  [open "%s" r]
	set f2 [open "%s" w]
	set f3 [open "%s" w]
d1586 1
a1586 1
    } $path(test1) $path(test2) $path(test3)]
d1588 3
a1590 3
    set result [exec [interpreter] $path(test1)]
    set f  [open $path(test2) r]
    set f2 [open $path(test3) r]
a1629 3

set path(script) [makeFile {} script]

d1633 2
a1634 2
    set f [open $path(script) w]
    puts $f [format {
d1636 1
a1636 1
	set f [open "%s" w]
d1639 1
a1639 1
	set f [open "%s" r]
d1641 1
a1641 1
    } $path(test1) $path(test1)]
d1643 1
a1643 1
    set f [open "|[list [interpreter] $path(script)]" r]
a1647 1

d1651 1
a1651 1
    set f [open $path(script) w]
d1653 1
a1653 2
        array set path [lindex $argv 0]
	set f [open $path(test1) w]
d1657 1
a1657 1
	set f [open "|[list [info nameofexecutable] $path(cat) $path(test1)]" r]
d1661 1
a1661 1
    set f [open "|[list [interpreter] $path(script) [array get path]]" r]
d1680 1
a1680 1
test io-17.1 {GetChannelTable, DeleteChannelTable on std handles} {testchannel} {
d1692 1
a1692 1
test io-17.2 {GetChannelTable, DeleteChannelTable on std handles} {testchannel} {
d1704 1
a1704 1
test io-17.3 {GetChannelTable, DeleteChannelTable on std handles} {testchannel} {
d1717 1
a1717 1
test io-18.1 {Tcl_RegisterChannel, Tcl_UnregisterChannel} {testchannel} {
d1720 1
a1720 1
    set f [open $path(test1) w]
d1731 1
a1731 1
test io-18.2 {Tcl_RegisterChannel, Tcl_UnregisterChannel} {testchannel} {
d1734 1
a1734 1
    set f [open $path(test1) w]
d1752 1
a1752 1
test io-18.3 {Tcl_RegisterChannel, Tcl_UnregisterChannel} {testchannel} {
d1755 1
a1755 1
    set f [open $path(test1) w]
d1777 1
a1777 1
    set f [open $path(test1) w]
d1785 1
a1785 1
test io-19.4 {Tcl_CreateChannel, insertion into channel table} {testchannel} {
d1787 1
a1787 1
    set f [open $path(test1) w]
d1801 1
a1801 1
	set a [open $path(test2) w]
d1804 1
a1804 1
    set f [open $path(test1) w]
d1812 1
a1812 1
    set f [open $path(test1) w+]
d1818 1
a1818 1
    set f [open $path(test1) w+]
d1824 1
a1824 1
    set f [open $path(test1) w+]
a1828 3

set path(stdout) [makeFile {} stdout]

d1830 2
a1831 2
    set f [open $path(script) w]
    puts $f [format {
d1833 1
a1833 1
	set f1 [open "%s" w]
d1836 1
a1836 1
    } $path(stdout)]
d1838 1
a1838 1
    set f [open "|[list [interpreter] $path(script)]"]
d1856 1
a1856 1
test io-23.1 {Tcl_GetChannelName} {testchannel} {
d1858 1
a1858 1
    set f [open $path(test1) w]
d1864 1
a1864 1
test io-24.1 {Tcl_GetChannelType} {testchannel} {
d1866 1
a1866 1
    set f [open $path(test1) w]
d1872 2
a1873 2
test io-25.1 {Tcl_GetChannelHandle, input} {testchannel} {
    set f [open $path(test1) w]
d1877 1
a1877 1
    set f [open $path(test1) r]
d1885 1
a1885 1
test io-25.2 {Tcl_GetChannelHandle, output} {testchannel} {
d1887 1
a1887 1
    set f [open $path(test1) w]
d1905 1
a1905 1
    set f [open "|[list [interpreter] << exit]"]
d1914 1
a1914 1
    set f [open $path(test1) w]
d1916 1
a1916 1
    set s [file size $path(test1)]
d1922 1
a1922 1
    set f [open $path(test1) w]
d1926 1
a1926 1
    lappend l [file size $path(test1)]
d1928 1
a1928 1
    lappend l [file size $path(test1)]
d1930 1
a1930 1
    lappend l [file size $path(test1)]
d1935 1
a1935 1
    set f [open $path(test1) w]
d1939 1
a1939 1
    lappend l [file size $path(test1)]
d1941 1
a1941 1
    lappend l [file size $path(test1)]
d1946 1
a1946 1
    set f [open $path(test1) w]
d1950 1
a1950 1
    lappend l [file size $path(test1)]
d1954 1
a1954 1
    lappend l [file size $path(test1)]
d1956 1
a1956 1
    lappend l [file size $path(test1)]
d1963 1
a1963 1
    set f [open $path(test1) w]
d1966 1
a1966 1
    lappend l [file size $path(test1)]
d1970 1
a1970 1
    lappend l [file size $path(test1)]
d1972 1
a1972 1
    lappend l [file size $path(test1)]
a1974 4

set path(pipe)   [makeFile {} pipe]
set path(output) [makeFile {} output]

d1979 3
a1981 3
    set f [open $path(pipe) w]
    puts $f [format {
	set f [open "%s" w]
d1988 1
a1988 1
    } $path(output)]
d1994 1
a1994 1
    set f [open $path(output) w]
d1996 1
a1996 1
    set f [open "|[list [interpreter] $path(pipe)]" w]
d2001 1
a2001 1
    while {([file size $path(output)] < 65536) && ($counter < 1000)} {
d2007 1
a2007 1
        set result "file size only [file size $path(output)]"
d2015 1
a2015 1
test io-28.1 {CloseChannel called when all references are dropped} {testchannel} {
d2017 1
a2017 1
    set f [open $path(test1) w]
d2030 1
a2030 1
    set f [open $path(test1) w]
d2038 1
a2038 1
    set f [open $path(test1) r]
d2047 1
a2047 1
    set f [open $path(pipe) w]
d2057 1
a2057 1
	set f [open $path(output) w]
d2070 1
a2070 1
    set f [open $path(output) w]
d2072 1
a2072 1
    set f [open "|[list [interpreter] pipe]" r+]
d2078 1
a2078 1
    while {([file size $path(output)] < 20480) && ($counter < 1000)} {
d2089 1
a2089 1
test io-28.4 {Tcl_Close} {testchannel} {
d2093 1
a2093 1
    set f [open $path(test1) w]
d2102 1
a2102 1
test io-28.5 {Tcl_Close vs standard handles} {stdio unixOnly testchannel} {
d2104 1
a2104 1
    set f [open $path(script) w]
d2110 1
a2110 1
    set f [open "|[list [interpreter] $path(script)]" r]
d2121 1
a2121 1
    set f [open $path(test1) w]
d2125 1
a2125 1
    file size $path(test1)
d2129 1
a2129 1
    set f [open $path(test1) w]
d2133 1
a2133 1
    file size $path(test1)
d2135 1
a2135 1
test io-29.4 {Tcl_WriteChars, buffering in full buffering mode} {testchannel} {
d2137 1
a2137 1
    set f [open $path(test1) w]
d2142 1
a2142 1
    lappend l [file size $path(test1)]
d2145 1
a2145 1
    lappend l [file size $path(test1)]
d2149 1
a2149 1
test io-29.5 {Tcl_WriteChars, buffering in line buffering mode} {testchannel} {
d2151 1
a2151 1
    set f [open $path(test1) w]
d2156 1
a2156 1
    lappend l [file size $path(test1)]
d2159 1
a2159 1
    lappend l [file size $path(test1)]
d2163 1
a2163 1
test io-29.6 {Tcl_WriteChars, buffering in no buffering mode} {testchannel} {
d2165 1
a2165 1
    set f [open $path(test1) w]
d2170 1
a2170 1
    lappend l [file size $path(test1)]
d2173 1
a2173 1
    lappend l [file size $path(test1)]
d2178 1
a2178 1
test io-29.7 {Tcl_Flush, full buffering} {testchannel} {
d2180 1
a2180 1
    set f [open $path(test1) w]
d2185 1
a2185 1
    lappend l [file size $path(test1)]
d2188 1
a2188 1
    lappend l [file size $path(test1)]
d2191 1
a2191 1
    lappend l [file size $path(test1)]
d2195 1
a2195 1
test io-29.8 {Tcl_Flush, full buffering} {testchannel} {
d2197 1
a2197 1
    set f [open $path(test1) w]
d2202 1
a2202 1
    lappend l [file size $path(test1)]
d2205 1
a2205 1
    lappend l [file size $path(test1)]
d2208 1
a2208 1
    lappend l [file size $path(test1)]
d2211 1
a2211 1
    lappend l [file size $path(test1)]
d2220 1
a2220 1
    set f1 [open $path(test1) w]
d2222 1
a2222 1
    set f2 [open $path(longfile) r]
d2228 1
a2228 1
    file size $path(test1)
d2232 1
a2232 1
    set f1 [open $path(test1) w]
d2234 1
a2234 1
    set f2 [open $path(longfile) r]
d2240 1
a2240 1
    file size $path(test1)
d2245 3
a2247 3
    set f1 [open $path(pipe) w]
    puts $f1 [format {
	set f1 [open "%s" r]
d2251 1
a2251 1
    } $path(longfile)]
d2253 2
a2254 2
    set f1 [open "|[list [interpreter] $path(pipe)]" r]
    set f2 [open $path(longfile) r]
d2270 1
a2270 1
    set f1 [open $path(pipe) w]
d2277 1
a2277 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d2279 1
a2279 1
    set f2 [open $path(longfile) r]
d2298 1
a2298 1
    set f [open $path(test3) w]
d2303 1
a2303 1
    set f [open $path(test3) r]
d2310 1
a2310 1
    set fd [open $path(test1) w]
d2312 1
a2312 1
    set fd [open $path(test1) r]
d2319 1
a2319 1
    set fd [open "|[list [interpreter] cat longfile]" r]
d2327 1
a2327 1
    set f1 [open $path(test1) w]
d2333 1
a2333 1
    set x [file size $path(test1)]
d2340 1
a2340 1
    set f1 [open $path(test1) w]
d2346 1
a2346 1
    lappend x [file size $path(test1)]
d2349 1
a2349 1
    lappend x [file size $path(test1)]
d2352 1
a2352 1
    lappend x [file size $path(test1)]
d2358 1
a2358 1
    set f1 [open $path(test1) w]
d2365 1
a2365 1
    lappend x [file size $path(test1)]
d2368 1
a2368 1
    lappend x [file size $path(test1)]
d2371 1
a2371 1
    lappend x [file size $path(test1)]
d2376 1
a2376 1
    set f1 [open $path(test1) w]
d2383 1
a2383 1
    lappend z [file size $path(test1)]
d2387 1
a2387 1
    lappend z [file size $path(test1)]
d2389 1
a2389 1
    lappend z [file size $path(test1)]
d2394 1
a2394 1
    set f1 [open $path(pipe) w]
d2399 1
a2399 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d2408 1
a2408 1
    set f1 [open $path(pipe) w]
d2419 1
a2419 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d2431 1
a2431 1
    set f1 [open $path(pipe) w]
d2439 1
a2439 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d2450 1
a2450 1
    set f [open $path(test3) w]
d2453 1
a2453 1
    set f2 [open $path(test3)]
d2458 1
a2458 1
    set f2 [open $path(test3)]
d2466 1
a2466 1
    set f [open "|[list [interpreter] $path(cat) | [interpreter] $path(cat) > $path(test3)]" w]
d2471 1
a2471 1
    set f [open $path(test3) r]
d2486 1
a2486 1
    set f [open $path(pipe) w]
d2489 1
a2489 1
    set f [open "|[list [interpreter] $path(pipe)]" r+]
d2514 1
a2514 1
    set f [open $path(test1) w]
d2518 1
a2518 1
    set s [file size $path(test1)]
d2524 1
a2524 1
    set f [open $path(test1) w]
d2528 1
a2528 1
    file size $path(test1)
d2532 1
a2532 1
    set f [open $path(test1) w]
d2536 1
a2536 1
    file size $path(test1)
d2541 2
a2542 2
    set f [open $path(pipe) w]
    puts $f [format {set f [open "%s" w]} $path(output)]
d2556 1
a2556 1
    set f [open $path(output) w]
d2558 1
a2558 1
    set f [open "|[list [interpreter] $path(pipe)]" r+]
d2563 1
a2563 1
    while {([file size $path(output)] < 65536) && ($counter < 1000)} {
d2569 1
a2569 1
	set result "file size only [file size $path(output)]"
d2578 2
a2579 2
    set f [open $path(pipe) w]
    puts $f [format {set f [open "%s" w]} $path(output)]
d2594 1
a2594 1
    set f [open $path(output) w]
d2596 1
a2596 1
    set f [open "|[list [interpreter] $path(pipe)]" r+]
d2601 1
a2601 1
    while {([file size $path(output)] < 65536) && ($counter < 1000)} {
d2607 1
a2607 1
	set result "file size only [file size $path(output)]"
d2612 4
a2615 4
test io-29.33 {Tcl_Flush, implicit flush on exit} {exec} {
    set f [open $path(script) w]
    puts $f [format {
	set f [open "%s" w]
d2620 1
a2620 1
    } $path(test1)]
d2622 2
a2623 2
    exec [interpreter] $path(script)
    set f [open $path(test1) r]
d2630 1
a2630 1
    variable x running
d2638 2
a2639 2
	variable x
	fileevent $s readable [namespace code [list readit $s]]
d2644 1
a2644 2
	variable c
	variable x
d2654 3
a2656 3
    set ss [socket -server [namespace code accept] 0]
    set cs [socket [info hostname] [lindex [fconfigure $ss -sockname] 2]]
    vwait [namespace which -variable x]
d2661 1
a2661 1
    vwait [namespace which -variable x]
d2672 1
a2672 1
    set s [socket -server [namespace code accept] 0]
d2677 1
a2677 1
    set c [socket [info hostname] [lindex [fconfigure $s -sockname] 2]]
d2710 1
a2710 1
    set f [open $path(test1) w]
d2714 1
a2714 1
    set f [open $path(test1) r]
d2722 1
a2722 1
    set f [open $path(test1) w]
d2726 1
a2726 1
    set f [open $path(test1) r]
d2734 1
a2734 1
    set f [open $path(test1) w]
d2738 1
a2738 1
    set f [open $path(test1) r]
d2746 1
a2746 1
    set f [open $path(test1) w]
d2750 1
a2750 1
    set f [open $path(test1) r]
d2758 1
a2758 1
    set f [open $path(test1) w]
d2762 1
a2762 1
    set f [open $path(test1) r]
d2770 1
a2770 1
    set f [open $path(test1) w]
d2774 1
a2774 1
    set f [open $path(test1) r]
d2782 1
a2782 1
    set f [open $path(test1) w]
d2786 1
a2786 1
    set f [open $path(test1) r]
d2794 1
a2794 1
    set f [open $path(test1) w]
d2798 1
a2798 1
    set f [open $path(test1) r]
d2806 1
a2806 1
    set f [open $path(test1) w]
d2810 1
a2810 1
    set f [open $path(test1) r]
d2818 1
a2818 1
    set f [open $path(test1) w]
d2822 1
a2822 1
    set f [open $path(test1) r]
d2834 1
a2834 1
    set f [open $path(test1) w]
d2838 1
a2838 1
    set f [open $path(test1) r]
d2850 1
a2850 1
    set f [open $path(test1) w]
d2854 1
a2854 1
    set f [open $path(test1) r]
d2867 1
a2867 1
    set f [open $path(test1) w]
d2875 1
a2875 1
    set f [open $path(test1) r]
d2884 1
a2884 1
    set f [open $path(test1) w]
d2892 1
a2892 1
    set f [open $path(test1) r]
d2901 1
a2901 1
    set f [open $path(test1) w]
d2905 1
a2905 1
    set f [open $path(test1) r]
d2917 1
a2917 1
    set f [open $path(test1) w]
d2921 1
a2921 1
    set f [open $path(test1) r]
d2933 1
a2933 1
    set f [open $path(test1) w]
d2937 1
a2937 1
    set f [open $path(test1) r]
d2949 1
a2949 1
    set f [open $path(test1) w]
d2954 1
a2954 1
    set f [open $path(test1) r]
d2969 1
a2969 1
    set f [open $path(test1) w]
d2974 1
a2974 1
    set f [open $path(test1) r]
d2989 1
a2989 1
    set f [open $path(test1) w]
d2994 1
a2994 1
    set f [open $path(test1) r]
d3011 1
a3011 1
    set f [open $path(test1) w]
d3016 1
a3016 1
    set f [open $path(test1) r]
d3029 1
a3029 1
    set f [open $path(test1) w]
d3034 1
a3034 1
    set f [open $path(test1) r]
d3047 1
a3047 1
    set f [open $path(test1) w]
d3052 1
a3052 1
    set f [open $path(test1) r]
d3061 1
a3061 1
    set f [open $path(test1) w]
d3066 1
a3066 1
    set f [open $path(test1) r]
d3075 1
a3075 1
    set f [open $path(test1) w]
d3080 1
a3080 1
    set f [open $path(test1) r]
d3089 1
a3089 1
    set f [open $path(test1) w]
d3094 1
a3094 1
    set f [open $path(test1) r]
d3103 1
a3103 1
    set f [open $path(test1) w]
d3108 1
a3108 1
    set f [open $path(test1) r]
d3117 1
a3117 1
    set f [open $path(test1) w]
d3122 1
a3122 1
    set f [open $path(test1) r]
d3134 1
a3134 1
    set f [open $path(test1) w]
d3138 1
a3138 1
    set f [open $path(test1) r]
d3151 1
a3151 1
    set f [open $path(test1) w]
d3155 1
a3155 1
    set f [open $path(test1) r]
d3168 1
a3168 1
    set f [open $path(test1) w]
d3172 1
a3172 1
    set f [open $path(test1) r]
d3185 1
a3185 1
    set f [open $path(test1) w]
d3189 1
a3189 1
    set f [open $path(test1) r]
d3203 1
a3203 1
    set f [open $path(test1) w]
d3207 1
a3207 1
    set f [open $path(test1) r]
d3223 1
a3223 1
    set f [open $path(test1) w]
d3227 1
a3227 1
    set f [open $path(test1) r]
d3243 1
a3243 1
    set f [open $path(test1) w]
d3247 1
a3247 1
    set f [open $path(test1) r]
d3263 1
a3263 1
    set f [open $path(test1) w]
d3267 1
a3267 1
    set f [open $path(test1) r]
d3283 1
a3283 1
    set f [open $path(test1) w]
d3287 1
a3287 1
    set f [open $path(test1) r]
d3303 1
a3303 1
    set f [open $path(test1) w]
d3307 1
a3307 1
    set f [open $path(test1) r]
d3323 1
a3323 1
    set f [open $path(test1) w]
d3327 1
a3327 1
    set f [open $path(test1) r]
d3343 1
a3343 1
    set f [open $path(test1) w]
d3347 1
a3347 1
    set f [open $path(test1) r]
d3363 1
a3363 1
    set f [open $path(test1) w]
d3375 1
a3375 1
    set f [open $path(test1) w]
d3379 1
a3379 1
    set f [open $path(test1) r]
d3394 1
a3394 1
    set f [open $path(test1) w]
d3398 1
a3398 1
    set f [open $path(test1) r]
d3413 1
a3413 1
    set f [open $path(test1) w]
d3417 1
a3417 1
    set f [open $path(test1) r]
d3431 1
a3431 1
    set f [open $path(test1) w]
d3435 1
a3435 1
    set f [open $path(test1) r]
d3450 1
a3450 1
    set f [open $path(test1) w]
d3455 1
a3455 1
    set f [open $path(test1) r]
d3470 1
a3470 1
    set f [open $path(test1) w]
d3474 1
a3474 1
    set f [open $path(test1) r]
d3489 1
a3489 1
    set f [open $path(test1) w]
d3494 1
a3494 1
    set f [open $path(test1) r]
d3508 1
a3508 1
    set f [open $path(test1) w]
d3513 1
a3513 1
    set f [open $path(test1) r]
d3526 1
a3526 1
    set f [open $path(test1) w]
d3531 1
a3531 1
    set f [open $path(test1) r]
d3548 1
a3548 1
    set f [open $path(test1) w]
d3553 1
a3553 1
    set f [open $path(test1) r]
d3570 1
a3570 1
    set f [open $path(test1) w]
d3575 1
a3575 1
    set f [open $path(test1) r]
d3592 1
a3592 1
    set f [open $path(test1) w]
d3597 1
a3597 1
    set f [open $path(test1) r]
d3610 1
a3610 1
    set f [open $path(test1) w]
d3615 1
a3615 1
    set f [open $path(test1) r]
d3628 1
a3628 1
    set f [open $path(test1) w]
d3633 1
a3633 1
    set f [open $path(test1) r]
d3646 1
a3646 1
    set f [open $path(test1) w]
d3651 1
a3651 1
    set f [open $path(test1) r]
d3664 1
a3664 1
    set f [open $path(test1) w]
d3669 1
a3669 1
    set f [open $path(test1) r]
d3682 1
a3682 1
    set f [open $path(test1) w]
d3687 1
a3687 1
    set f [open $path(test1) r]
d3700 1
a3700 1
    set f [open $path(test1) w]
d3708 1
a3708 1
    set f [open $path(test1) r]
d3719 1
a3719 1
    set f [open $path(test1) w]
d3727 1
a3727 1
    set f [open $path(test1) r]
d3747 1
a3747 1
    set f [open $path(longfile) r]
d3753 1
a3753 1
    set f [open $path(longfile) r]
d3761 1
a3761 1
    set f [open $path(longfile) r]
d3770 1
a3770 1
    set f1 [open $path(longfile) r]
d3775 1
a3775 1
    set z [file size $path(longfile)]
d3782 1
a3782 1
    set f1 [open $path(longfile) r]
d3794 1
a3794 1
    set f1 [open $path(longfile) r]
d3799 2
a3800 2
    set l [string length $z]
    set z [file size $path(longfile)]
d3804 1
a3804 1
    set x
d3807 1
a3807 1
    set f1 [open $path(longfile) r]
d3812 1
a3812 1
    set z [file size $path(longfile)]
d3820 1
a3820 1
    set f1 [open $path(pipe) w]
d3823 1
a3823 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d3832 1
a3832 1
    set f1 [open $path(pipe) w]
d3836 1
a3836 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d3851 1
a3851 1
    set f1 [open $path(test1) w]
d3855 1
a3855 1
    set f1 [open $path(test1) r]
d3863 1
a3863 1
    set f1 [open $path(test1) w]
d3867 1
a3867 1
    set f1 [open $path(test1) r]
d3875 1
a3875 1
    set f [open $path(test1) w]
d3879 1
a3879 1
    set f [open $path(test1)]
d3888 1
a3888 1
    set f [open $path(test1) w]
d3892 1
a3892 1
    set f [open $path(test1)]
d3901 1
a3901 1
    set f [open $path(test1) w]
d3905 1
a3905 1
    set f [open $path(test1)]
d3916 1
a3916 1
    set f1 [open $path(test1) w]
d3920 1
a3920 1
    set f1 [open $path(test1) r]
d3930 1
a3930 1
    set f1 [open $path(longfile) r]
d3942 1
a3942 1
    set f1 [open $path(pipe) w]
d3945 1
a3945 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d3958 1
a3958 1
    set f [open $path(test3) w]
d3965 1
a3965 1
    set f [open $path(test3)]
d3971 1
a3971 1
    set f [open $path(test3)]
d3978 1
a3978 1
    set f [open $path(test3) w]
d3981 1
a3981 1
    set f [open $path(test3)]
d3993 1
a3993 1
    set f [open $path(test3) w]
d3999 1
a3999 1
    set f [open $path(test3) r]
d4005 1
a4005 1
    set f [open $path(test3) w]
d4011 1
a4011 1
    set f [open $path(test3) r]
d4018 1
a4018 1
    set f [open $path(test3) w]
d4024 1
a4024 1
    set f [open $path(test3) r]
d4031 1
a4031 1
    set f [open $path(test3) w]
d4037 1
a4037 1
    set f [open $path(test3) r]
d4047 1
a4047 1
    set f1 [open $path(longfile) r]
d4055 1
a4055 1
    set f1 [open $path(test1) w]
d4060 1
a4060 1
    set f1 [open $path(test1) r]
d4068 1
a4068 1
    set f1 [open $path(test1) w]
d4073 1
a4073 1
    set f1 [open $path(test1) r]
d4081 1
a4081 1
    set f1 [open $path(test1) w]
d4086 1
a4086 1
    set f1 [open $path(test1) r]
d4094 1
a4094 1
    set f1 [open $path(test1) w]
d4099 1
a4099 1
    set f1 [open $path(test1) r]
d4108 1
a4108 1
    set f1 [open $path(test1) w]
d4113 1
a4113 1
    set f1 [open $path(test1) r]
d4123 1
a4123 1
    set f1 [open $path(test1) w]
d4128 1
a4128 1
    set f1 [open $path(test1) r]
d4138 1
a4138 1
    set f1 [open "|[list [interpreter]]" r+]
d4146 1
a4146 1
    set f [open $path(test3) w]
d4150 1
a4150 1
    set f [open $path(test3) RDWR]
a4166 3

set path(test3) [makeFile {} test3]

d4168 1
a4168 1
    set f [open $path(test3) w]
d4172 1
a4172 1
    set f [open $path(test3) r+]
d4182 1
a4182 1
    set f [open $path(test3) w]
d4185 1
a4185 1
    set f [open $path(test3) w+]
d4193 1
a4193 1
    set f [open $path(test3) w]
d4197 1
a4197 1
    set f [open $path(test3) a+]
d4211 1
a4211 1
    set f1 [open $path(test1) w]
d4218 1
a4218 1
    set f1 [open $path(test1) w]
d4223 1
a4223 1
    set f1 [open $path(test1) r]
d4231 1
a4231 1
    set f1 [open $path(test1) w]
d4236 1
a4236 1
    set f1 [open $path(test1) r]
d4245 1
a4245 1
    set f1 [open "|[list [interpreter]]" r+]
d4251 1
a4251 1
    set f1 [open "|[list [interpreter]]" r+]
d4261 1
a4261 1
    set f [open $path(test2) w]
d4265 1
a4265 1
    set f [open $path(test2)]
d4280 1
a4280 1
    set f [open $path(test3) w]
d4285 1
a4285 1
    set f [open $path(test3) a]
d4291 1
a4291 1
    set f [open $path(test3) w]
a4304 22
test io-34.21 {Tcl_Seek and Tcl_Tell on large files} {largefileSupport} {
    removeFile test3
    set f [open $path(test3) w]
    fconfigure $f -encoding binary
    set l ""
    lappend l [tell $f]
    puts -nonewline $f abcdef
    lappend l [tell $f]
    flush $f
    lappend l [tell $f]
    # 4GB offset!
    seek $f 0x100000000
    lappend l [tell $f]
    puts -nonewline $f abcdef
    lappend l [tell $f]
    close $f
    lappend l [file size $f]
    # truncate...
    close [open $path(test3) w]
    lappend l [file size $f]
    set l
} {0 6 6 4294967296 4294967302 4294967302 0}
d4310 1
a4310 1
    set f [open $path(test1) w]
d4314 1
a4314 1
    set f [open $path(test1)]
d4329 1
a4329 1
    set f1 [open $path(pipe) w]
d4333 1
a4333 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d4347 1
a4347 1
    set f1 [open $path(pipe) w]
d4351 1
a4351 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d4369 1
a4369 1
    set f [open $path(test1) w]
d4371 1
a4371 1
    set f [open $path(test1) r]
d4381 1
a4381 1
    set f [open $path(pipe) w]
d4386 1
a4386 1
    set f [open "|[list [interpreter] $path(pipe)]" r]
d4395 1
a4395 1
    set f [open $path(test1) w]
d4399 2
a4400 2
    set s [file size $path(test1)]
    set f [open $path(test1) r]
d4409 1
a4409 1
    set f [open $path(test1) w]
d4413 2
a4414 2
    set s [file size $path(test1)]
    set f [open $path(test1) r]
d4423 1
a4423 1
    set f [open $path(test1) w]
d4427 2
a4428 2
    set s [file size $path(test1)]
    set f [open $path(test1) r]
d4437 1
a4437 1
    set f [open $path(test1) w]
d4441 2
a4442 2
    set s [file size $path(test1)]
    set f [open $path(test1) r]
d4451 1
a4451 1
    set f [open $path(test1) w]
d4455 2
a4456 2
    set s [file size $path(test1)]
    set f [open $path(test1) r]
d4465 1
a4465 1
    set f [open $path(test1) w]
d4469 2
a4470 2
    set s [file size $path(test1)]
    set f [open $path(test1) r]
d4479 1
a4479 1
    set f [open $path(test1) w]
d4484 2
a4485 2
    set c [file size $path(test1)]
    set f [open $path(test1) r]
d4494 1
a4494 1
    set f [open $path(test1) w]
d4499 2
a4500 2
    set c [file size $path(test1)]
    set f [open $path(test1) r]
d4509 1
a4509 1
    set f [open $path(test1) w]
d4514 2
a4515 2
    set c [file size $path(test1)]
    set f [open $path(test1) r]
d4524 1
a4524 1
    set f [open $path(test1) w]
d4529 2
a4530 2
    set c [file size $path(test1)]
    set f [open $path(test1) r]
d4539 1
a4539 1
    set f [open $path(test1) w]
d4544 2
a4545 2
    set c [file size $path(test1)]
    set f [open $path(test1) r]
d4554 1
a4554 1
    set f [open $path(test1) w]
d4559 2
a4560 2
    set c [file size $path(test1)]
    set f [open $path(test1) r]
d4571 1
a4571 1
    set f1 [open "|[list [interpreter]]" r+]
d4590 1
a4590 1
    set f1 [open "|[list [interpreter]]" r+]
d4605 1
a4605 1
    set f [open $path(test1) w]
d4608 1
a4608 1
    set f [open $path(test1) r]
d4621 1
a4621 2
        variable l
        variable x
d4626 1
a4626 1
    set f [open $path(test1) w]
d4629 1
a4629 1
    set f [open $path(test1) r]
d4631 2
a4632 3
    fileevent $f readable [namespace code [list in $f]]
    variable x
    vwait [namespace which -variable x]
d4638 1
a4638 1
    set f [open $path(test1) w]
d4641 1
a4641 1
    set f [open $path(test1) r]
d4655 1
a4655 2
        variable l
        variable x
d4660 1
a4660 1
    set f [open $path(test1) w]
d4663 1
a4663 1
    set f [open $path(test1) r]
d4666 2
a4667 3
    fileevent $f readable [namespace code [list in $f]]
    variable x
    vwait [namespace which -variable x]
d4674 2
a4675 2
test io-37.1 {Tcl_InputBuffered} {testchannel} {
    set f [open $path(longfile) r]
d4684 2
a4685 2
test io-37.2 {Tcl_InputBuffered, test input flushing on seek} {testchannel} {
    set f [open $path(longfile) r]
d4701 1
a4701 1
    set f [open $path(longfile) r]
d4707 1
a4707 1
    set f [open $path(longfile) r]
a4725 11
test io-38.3 {Tcl_SetChannelBufferSize, changing buffersize between reads} {
    # This test crashes the interp if Bug #427196 is not fixed

    set chan [open [info script] r]
    fconfigure $chan -buffersize 10
    set var [read $chan 2]
    fconfigure $chan -buffersize 32
    append var [read $chan]
    close $chan
} {}

d4730 1
a4730 1
    set f1 [open $path(test1) w]
d4740 1
a4740 1
    set f1 [open $path(test1) w]
d4747 1
a4747 1
    set f1 [open $path(test1) w]
d4755 1
a4755 1
    set f1 [open $path(test1) w]
d4771 1
a4771 1
    set f1 [open $path(test1) w]
d4781 1
a4781 1
    set f1 [open $path(test1) w]
d4785 1
a4785 1
    set x [file size $path(test1)]
d4791 1
a4791 1
    set f1 [open $path(test1) w]
d4797 1
a4797 1
    lappend x [file size $path(test1)]
d4799 1
a4799 1
    lappend x [file size $path(test1)]
d4805 1
a4805 1
    set f1 [open $path(test1) w]
d4809 1
a4809 1
    lappend l [file size $path(test1)]
d4811 1
a4811 1
    lappend l [file size $path(test1)]
d4814 1
a4814 1
    lappend l [file size $path(test1)]
d4816 1
a4816 1
    lappend l [file size $path(test1)]
d4818 1
a4818 1
    lappend l [file size $path(test1)]
d4820 1
a4820 1
    lappend l [file size $path(test1)]
d4825 1
a4825 1
    set f1 [open $path(test1) w]
d4827 1
a4827 1
    set f1 [open $path(test1) r]
d4841 1
a4841 1
    set f1 [open $path(pipe) w]
d4850 1
a4850 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d4877 1
a4877 1
    set f [open $path(test1) w]
d4885 1
a4885 1
    set f [open $path(test1) w]
d4893 1
a4893 1
    set f [open $path(test1) w]
d4901 1
a4901 1
    set f [open $path(test1) w]
d4905 1
a4905 1
    set f [open $path(test1) r]
d4913 1
a4913 1
    set f [open $path(test1) w]
d4917 1
a4917 1
    set f [open $path(test1) r]
d4925 1
a4925 1
    set f [open $path(test1) w]
d4931 1
a4931 1
    set f [open "|[list [interpreter] $path(cat)]" r+]
d4936 5
a4940 5
    variable x {}
    fileevent $f readable [namespace code { lappend x [read $f] }]
    vwait [namespace which -variable x]
    after 300 [namespace code { lappend x timeout }]
    vwait [namespace which -variable x]
d4942 3
a4944 3
    vwait [namespace which -variable x]
    after 300 [namespace code { lappend x timeout }]
    vwait [namespace which -variable x]
d4946 3
a4948 3
    vwait [namespace which -variable x]
    after 300 [namespace code { lappend x timeout }]
    vwait [namespace which -variable x]
d4956 1
a4956 1
    set s1 [socket -server [namespace code accept] 0]
d4969 1
a4969 1
    set s1 [socket -server [namespace code accept] 0]
d4982 1
a4982 1
    set s1 [socket -server [namespace code accept] 0]
d4995 1
a4995 1
    set s1 [socket -server [namespace code accept] 0]
a5005 45
test io-39.22 {Tcl_SetChannelOption, invariance} {unixOnly} {
    removeFile test1
    set f1 [open $path(test1) w+]
    set l ""
    lappend l [fconfigure $f1 -eofchar]
    fconfigure $f1 -eofchar {ON GO}
    lappend l [fconfigure $f1 -eofchar]
    fconfigure $f1 -eofchar D
    lappend l [fconfigure $f1 -eofchar]
    close $f1
    set l
} {{{} {}} {O G} {D D}}

test io-39.22a {Tcl_SetChannelOption, invariance} {
    removeFile test1
    set f1 [open $path(test1) w+]
    set l [list]
    fconfigure $f1 -eofchar {ON GO}
    lappend l [fconfigure $f1 -eofchar]
    fconfigure $f1 -eofchar D
    lappend l [fconfigure $f1 -eofchar]
    lappend l [list [catch {fconfigure $f1 -eofchar {1 2 3}} msg] $msg]
    close $f1
    set l
} {{O G} {D D} {1 {bad value for -eofchar: should be a list of zero, one, or two elements}}}


test io-39.23 {Tcl_GetChannelOption, server socket is not readable or
        writeable, it should still have valid -eofchar and -translation options } {
    set l [list]
    set sock [socket -server [namespace code accept] 0]
    lappend l [fconfigure $sock -eofchar] [fconfigure $sock -translation]
    close $sock
    set l
} {{{}} auto}
test io-39.24 {Tcl_SetChannelOption, server socket is not readable or
        writable so we can't change -eofchar or -translation } {
    set l [list]
    set sock [socket -server [namespace code accept] 0]
    fconfigure $sock -eofchar D -translation lf
    lappend l [fconfigure $sock -eofchar] [fconfigure $sock -translation]
    close $sock
    set l
} {{{}} auto}

d5008 1
a5008 1
    set f [open $path(test3) w]
d5011 1
a5011 1
    set f [open $path(test3) RDWR]
d5016 1
a5016 1
    set f [open $path(test3) r]
d5023 2
a5024 2
    set f [open $path(test3) {WRONLY CREAT} 0600]
    file stat $path(test3) stats
d5028 1
a5028 1
    set f [open $path(test3) r]
d5036 1
a5036 1
catch {testConstraint umask2 [expr {[exec umask] == 2}]}
d5041 1
a5041 1
    set f [open $path(test3) {WRONLY CREAT}]
d5048 1
a5048 1
    set f [open $path(test3) w]
d5052 1
a5052 1
    set f [open $path(test3) {WRONLY CREAT}]
d5056 1
a5056 1
    set f [open $path(test3) r]
d5063 1
a5063 1
    set f [open $path(test3) w]
d5067 1
a5067 1
    set f [open $path(test3) {WRONLY APPEND}]
d5073 1
a5073 1
    set f [open $path(test3) r]
d5084 1
a5084 1
    set f [open $path(test3) w]
d5087 1
a5087 1
    set msg [list [catch {open $path(test3) {WRONLY CREAT EXCL}} msg] $msg]
a5088 1
    regsub [file join {} $path(test3)] $msg "test3" msg
d5093 1
a5093 1
    set f [open $path(test3) {WRONLY CREAT EXCL}]
d5101 1
a5101 1
    set f [open $path(test3) w]
d5104 1
a5104 1
    set f [open $path(test3) {WRONLY TRUNC}]
d5107 1
a5107 1
    set f [open $path(test3) r]
d5114 1
a5114 1
    set f [open $path(test3) {WRONLY NONBLOCK CREAT}]
d5117 1
a5117 1
    set f [open $path(test3) r]
d5123 1
a5123 1
    set f [open $path(test1) w]
d5127 1
a5127 1
    set f [open $path(test1) RDONLY]
d5136 1
a5136 3
    set msg [list [catch {open $path(test3) RDONLY} msg] $msg]
    regsub [file join {} $path(test3)] $msg "test3" msg
	string tolower $msg
d5140 1
a5140 3
    set msg [list [catch {open $path(test3) WRONLY} msg] $msg]
    regsub [file join {} $path(test3)] $msg "test3" msg
	string tolower $msg
d5144 1
a5144 1
    set f [open $path(test3) WRONLY]
d5156 1
a5156 3
    set msg [list [catch {open $path(test3) RDWR} msg] $msg]
    regsub [file join {} $path(test3)] $msg "test3" msg
	string tolower $msg
d5160 1
a5160 1
    set f [open $path(test3) RDWR]
d5205 1
a5205 2
set path(foo) [makeFile {} foo]
set f [open $path(foo) w+]
d5267 1
a5267 1
    fileevent $f2 readable [namespace code {
d5269 1
a5269 1
    }]
d5271 2
a5272 2
    variable x initial
    vwait [namespace which -variable x]
d5276 4
a5279 1
    proc ::bgerror args "set [namespace which -variable x] \$args"
d5282 3
a5284 3
    variable x initial
    vwait [namespace which -variable x]
    rename ::bgerror {}
d5288 1
a5288 1
    fileevent $f2 writable [namespace code {
d5294 2
a5295 2
    }]
    variable x initial
d5297 3
a5299 3
    vwait [namespace which -variable x]
    vwait [namespace which -variable x]
    vwait [namespace which -variable x]
d5303 4
a5306 1
    proc ::bgerror args "set [namespace which -variable x] \$args"
d5308 3
a5310 3
    variable x initial
    vwait [namespace which -variable x]
    rename ::bgerror {}
d5314 2
a5315 2
    set f4 [open "|[list [interpreter] $path(cat) << foo]" r]
    fileevent $f4 readable [namespace code {
d5322 4
a5325 4
    }]
    variable x initial
    vwait [namespace which -variable x]
    vwait [namespace which -variable x]
d5337 2
a5338 2
    set f [open $path(foo) r]
    fileevent $f readable [namespace code {
d5341 1
a5341 1
    }]
d5344 2
a5345 3
    after 100 [namespace code { set y done }]
    variable y
    vwait [namespace which -variable y]
d5349 3
a5351 3
    set f  [open $path(foo) r]
    set f2 [open $path(foo) r]
    fileevent $f readable [namespace code {
d5354 2
a5355 2
	}]
    fileevent $f2 readable [namespace code {
d5358 1
a5358 1
    }]
d5360 2
a5361 2
    variable x initial
    vwait [namespace which -variable x]
d5366 3
a5368 3
    set f  [open $path(foo) r]
    set f2 [open $path(foo) r]
    set f3 [open $path(foo) r]
a5387 1
testConstraint testfevent [llength [info commands testfevent]]
d5389 3
a5391 1
test io-46.1 {Tcl event loop vs multiple interpreters} {testfevent} {
d5393 2
a5394 2
    testfevent cmd [format {
        set f [open %s r]
d5396 1
a5396 1
        fileevent $f readable [namespace code {
d5399 2
a5400 2
        }]
    } $path(foo)]
d5406 1
a5406 1
test io-46.2 {Tcl event loop vs multiple interpreters} testfevent {
d5409 1
a5409 1
        variable x 0
d5411 1
a5411 1
        vwait [namespace which -variable x]
d5415 1
a5415 1
test io-46.3 {Tcl event loop vs multiple interpreters} testfevent {
d5429 4
a5432 4
test io-47.1 {fileevent vs multiple interpreters} testfevent {
    set f  [open $path(foo) r]
    set f2 [open $path(foo) r]
    set f3 [open $path(foo) r]
d5448 5
a5452 5
test io-47.2 {deleting fileevent on interpreter delete} testfevent {
    set f  [open $path(foo) r]
    set f2 [open $path(foo) r]
    set f3 [open $path(foo) r]
    set f4 [open $path(foo) r]
d5469 5
a5473 5
test io-47.3 {deleting fileevent on interpreter delete} testfevent {
    set f  [open $path(foo) r]
    set f2 [open $path(foo) r]
    set f3 [open $path(foo) r]
    set f4 [open $path(foo) r]
d5490 3
a5492 3
test io-47.4 {file events on shared files and multiple interpreters} testfevent {
    set f  [open $path(foo) r]
    set f2 [open $path(foo) r]
d5506 2
a5507 2
test io-47.5 {file events on shared files, deleting file events} testfevent {
    set f [open $path(foo) r]
d5519 2
a5520 2
test io-47.6 {file events on shared files, deleting file events} testfevent {
    set f [open $path(foo) r]
d5533 3
a5535 1
set path(bar) [makeFile {} bar]
d5538 1
a5538 1
    set f [open $path(bar) w]
d5545 2
a5546 2
    set f [open $path(bar) r]
    fileevent $f readable [namespace code [list consume $f]]
d5548 1
a5548 2
	variable l
	variable x
d5558 2
a5559 2
    variable x not_done
    vwait [namespace which -variable x]
d5563 1
a5563 1
    set f [open $path(bar) w]
d5570 2
a5571 2
    set f [open $path(bar) r]
    fileevent $f readable [namespace code [list consume $f]]
d5574 1
a5574 2
	variable x
	variable l
d5584 2
a5585 2
    variable x not_done
    vwait [namespace which -variable x]
d5588 2
a5589 5

set path(my_script) [makeFile {} my_script]

test io-48.3 {testing readability conditions} {stdio unixOnly nonBlockFiles} {
    set f [open $path(bar) w]
d5596 1
a5596 1
    set f [open $path(my_script) w]
d5607 2
a5608 2
    set f [open "|[list [interpreter]]" r+]
    fileevent $f readable [namespace code [list consume $f]]
d5612 1
a5612 2
	variable l
	variable x
d5623 3
a5625 3
    variable x not_done
    puts $f [format {source %s}         $path(my_script)]
    puts $f [format {set f [open %s r]} $path(bar)]
d5628 1
a5628 1
    vwait [namespace which -variable x]
d5634 1
a5634 1
    set f [open $path(test1) w]
d5640 1
a5640 3
	variable l
	variable c
	variable x
d5651 1
a5651 1
    set f [open $path(test1) r]
d5653 2
a5654 3
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
d5659 1
a5659 1
    set f [open $path(test1) w]
d5665 1
a5665 3
	variable l
	variable x
	variable c
d5676 1
a5676 1
    set f [open $path(test1) r]
d5678 2
a5679 3
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
d5684 1
a5684 1
    set f [open $path(test1) w]
d5690 1
a5690 3
	variable l
	variable x
	variable c
d5701 1
a5701 1
    set f [open $path(test1) r]
d5703 2
a5704 3
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
d5709 1
a5709 1
    set f [open $path(test1) w]
d5715 1
a5715 3
	variable l
	variable c
	variable x
d5726 1
a5726 1
    set f [open $path(test1) r]
d5728 2
a5729 3
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
d5734 1
a5734 1
    set f [open $path(test1) w]
d5740 1
a5740 3
	variable l
	variable x
	variable c
d5751 1
a5751 1
    set f [open $path(test1) r]
d5753 2
a5754 3
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
d5759 1
a5759 1
    set f [open $path(test1) w]
d5765 1
a5765 3
	variable l
	variable c
	variable x
d5776 1
a5776 1
    set f [open $path(test1) r]
d5778 2
a5779 3
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
d5784 1
a5784 1
    set f [open $path(test1) w]
d5790 1
a5790 3
	variable l
	variable c
	variable x
d5801 1
a5801 1
    set f [open $path(test1) r]
d5803 2
a5804 3
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
d5809 1
a5809 1
    set f [open $path(test1) w]
d5815 1
a5815 3
	variable l
	variable x
	variable c
d5826 1
a5826 1
    set f [open $path(test1) r]
d5828 2
a5829 3
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
d5834 1
a5834 1
    set f [open $path(test1) w]
d5840 1
a5840 3
	variable l
	variable x
	variable c
d5851 1
a5851 1
    set f [open $path(test1) r]
d5853 2
a5854 3
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
d5859 1
a5859 1
    set f [open $path(test1) w]
d5865 1
a5865 3
	variable c
	variable x
	variable l
d5876 1
a5876 1
    set f [open $path(test1) r]
d5878 2
a5879 3
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
d5884 1
a5884 1
    set f [open $path(test1) w]
d5890 1
a5890 3
	variable c
	variable x
	variable l
d5901 1
a5901 1
    set f [open $path(test1) r]
d5903 2
a5904 3
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
d5909 1
a5909 1
    set f [open $path(test1) w]
d5915 1
a5915 3
	variable c
	variable x
	variable l
d5926 1
a5926 1
    set f [open $path(test1) r]
d5928 2
a5929 3
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
d5935 1
a5935 1
    set f [open $path(test1) w]
d5939 1
a5939 1
    set f [open $path(test1) r]
d5941 1
a5941 1
    lappend l [file size $path(test1)]
d5964 1
a5964 1
    set f [open $path(test1) w]
d5968 1
a5968 1
    set f [open $path(test1) r]
d5970 1
a5970 1
    lappend l [file size $path(test1)]
d5987 1
a5987 1
    set f [open $path(test1) w]
d5991 1
a5991 1
    set f [open $path(test1) r]
d5993 1
a5993 1
    lappend l [file size $path(test1)]
d6008 1
a6008 1
    set f [open $path(test1) w]
d6012 1
a6012 1
    set f [open $path(test1) r]
d6014 1
a6014 1
    lappend l [file size $path(test1)]
d6029 1
a6029 1
    set f [open $path(test1) w]
d6033 1
a6033 1
    set f [open $path(test1) r]
d6035 1
a6035 1
    lappend l [file size $path(test1)]
d6046 1
a6046 2
testConstraint testchannelevent [llength [info commands testchannelevent]]
test io-50.1 {testing handler deletion} {testchannelevent} {
d6048 1
a6048 1
    set f [open $path(test1) w]
d6050 2
a6051 2
    set f [open $path(test1) r]
    testchannelevent $f add readable [namespace code [list delhandler $f]]
d6053 1
a6053 1
	variable z
d6062 1
a6062 1
test io-50.2 {testing handler deletion with multiple handlers} {testchannelevent} {
d6064 1
a6064 1
    set f [open $path(test1) w]
d6066 3
a6068 3
    set f [open $path(test1) r]
    testchannelevent $f add readable [namespace code [list delhandler $f 1]]
    testchannelevent $f add readable [namespace code [list delhandler $f 0]]
d6070 1
a6070 1
	variable z
d6080 1
a6080 1
test io-50.3 {testing handler deletion with multiple handlers} {testchannelevent} {
d6082 1
a6082 1
    set f [open $path(test1) w]
d6084 3
a6086 3
    set f [open $path(test1) r]
    testchannelevent $f add readable [namespace code [list notcalled $f 1]]
    testchannelevent $f add readable [namespace code [list delhandler $f 0]]
d6089 1
a6089 1
	variable z
d6093 1
a6093 1
	variable z
d6106 1
a6106 1
test io-50.4 {testing handler deletion vs reentrant calls} {testchannelevent} {
d6108 1
a6108 1
    set f [open $path(test1) w]
d6110 2
a6111 2
    set f [open $path(test1) r]
    testchannelevent $f add readable [namespace code [list delrecursive $f]]
d6113 1
a6113 2
	variable z
	variable u
d6130 1
a6130 1
test io-50.5 {testing handler deletion vs reentrant calls} {testchannelevent} {
d6132 1
a6132 1
    set f [open $path(test1) w]
d6134 3
a6136 3
    set f [open $path(test1) r]
    testchannelevent $f add readable [namespace code [list notcalled $f]]
    testchannelevent $f add readable [namespace code [list del $f]]
d6138 1
a6138 1
	variable z
d6142 1
a6142 2
	variable u
	variable z
d6163 1
a6163 1
test io-50.6 {testing handler deletion vs reentrant calls} {testchannelevent} {
d6165 1
a6165 1
    set f [open $path(test1) w]
d6167 3
a6169 3
    set f [open $path(test1) r]
    testchannelevent $f add readable [namespace code [list second $f]]
    testchannelevent $f add readable [namespace code [list first $f]]
d6171 1
a6171 2
	variable u
	variable z
d6182 1
a6182 2
	variable u
	variable z
d6209 1
a6209 2
	variable x
	variable wait
d6215 4
a6218 4
    set ss [socket -server [namespace code accept] 0]
    variable wait ""
    set cs [socket [info hostname] [lindex [fconfigure $ss -sockname] 2]]
    vwait [namespace which -variable wait]
d6223 2
a6224 2
    set cs [socket [info hostname] [lindex [fconfigure $ss -sockname] 2]]
    vwait [namespace which -variable wait]
d6229 2
a6230 2
    set cs [socket [info hostname] [lindex [fconfigure $ss -sockname] 2]]
    vwait [namespace which -variable wait]
d6235 2
a6236 2
    set cs [socket [info hostname] [lindex [fconfigure $ss -sockname] 2]]
    vwait [namespace which -variable wait]
d6246 1
a6246 1
    set f2 [open $path(test1) w]
d6256 1
a6256 1
    set f2 [open $path(test1) w]
d6268 1
a6268 1
    set f2 [open $path(test1) w]
d6276 1
a6276 1
    set s2 [file size $path(test1)]
d6285 1
a6285 1
    set f2 [open $path(test1) w]
d6292 1
a6292 1
    lappend result [file size $path(test1)]
d6297 1
a6297 1
    set f2 [open $path(test1) w]
d6305 1
a6305 1
    set s2 [file size $path(test1)]
d6314 1
a6314 1
    set f2 [open $path(test1) w]
d6322 1
a6322 1
    set s2 [file size $path(test1)]
d6331 1
a6331 1
    set f2 [open $path(test1) w]
d6337 1
a6337 1
    set s2 [file size $path(test1)]
d6348 1
a6348 1
    set f1 [open $path(pipe) w]
d6359 1
a6359 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d6364 1
a6364 1
    set f2 [open $path(test1) w]
d6369 1
a6369 1
    list $s0 [file size $path(test1)]
a6371 79
# Empty files, to register them with the test facility
set path(kyrillic.txt)   [makeFile {} kyrillic.txt]
set path(utf8-fcopy.txt) [makeFile {} utf8-fcopy.txt]
set path(utf8-rp.txt)    [makeFile {} utf8-rp.txt]

# Create kyrillic file, use lf translation to avoid os eol issues
set out [open $path(kyrillic.txt) w]
fconfigure $out -encoding koi8-r -translation lf
puts       $out "\u0410\u0410"
close      $out

test io-52.9 {TclCopyChannel & encodings} {
    # Copy kyrillic to UTF-8, using fcopy.

    set in  [open $path(kyrillic.txt) r]
    set out [open $path(utf8-fcopy.txt) w]

    fconfigure $in  -encoding koi8-r -translation lf
    fconfigure $out -encoding utf-8 -translation lf

    fcopy $in $out
    close $in
    close $out

    # Do the same again, but differently (read/puts).

    set in  [open $path(kyrillic.txt) r]
    set out [open $path(utf8-rp.txt) w]

    fconfigure $in  -encoding koi8-r -translation lf
    fconfigure $out -encoding utf-8 -translation lf

    puts -nonewline $out [read $in]

    close $in
    close $out

    list [file size $path(kyrillic.txt)] \
	    [file size $path(utf8-fcopy.txt)] \
	    [file size $path(utf8-rp.txt)]
} {3 5 5}

test io-52.10 {TclCopyChannel & encodings} {
    # encoding to binary (=> implies that the
    # internal utf-8 is written)

    set in  [open $path(kyrillic.txt) r]
    set out [open $path(utf8-fcopy.txt) w]

    fconfigure $in  -encoding koi8-r -translation lf
    # -translation binary is also -encoding binary
    fconfigure $out -translation binary

    fcopy $in $out
    close $in
    close $out

    file size $path(utf8-fcopy.txt)
} 5

test io-52.11 {TclCopyChannel & encodings} {
    # binary to encoding => the input has to be
    # in utf-8 to make sense to the encoder

    set in  [open $path(utf8-fcopy.txt) r]
    set out [open $path(kyrillic.txt) w]

    # -translation binary is also -encoding binary
    fconfigure $in  -translation binary
    fconfigure $out -encoding koi8-r -translation lf

    fcopy $in $out
    close $in
    close $out

    file size $path(kyrillic.txt)
} 3


d6375 1
a6375 1
    set f2 [open $path(test1) w]
d6382 1
a6382 1
    lappend result [file size $path(test1)]
d6387 1
a6387 1
    set f2 [open $path(test1) w]
d6390 1
a6390 1
    fcopy $f1 $f2 -command [namespace code {set s0}]
d6392 1
a6392 2
    variable s0
    vwait [namespace which -variable s0]
d6396 1
a6396 1
    set s2 [file size $path(test1)]
d6402 1
a6402 1
test io-53.3 {CopyData: background read underflow} {stdio unixOnly} {
d6405 2
a6406 2
    set f1 [open $path(pipe) w]
    puts $f1 [format {
d6411 1
a6411 1
	set f [open "%s" w]
d6415 1
a6415 1
    } $path(test1)]
d6417 1
a6417 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d6427 1
a6427 1
    set f [open $path(test1)]
d6432 1
a6432 1
test io-53.4 {CopyData: background write overflow} {stdio unixOnly} {
a6433 1
    variable x
d6439 1
a6439 1
    set f1 [open $path(pipe) w]
d6444 1
a6444 1
	set f [open $path(test1) w]
d6450 1
a6450 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d6457 1
a6457 1
    fileevent $f1 read [namespace code {
d6462 2
a6463 2
    }]
    vwait [namespace which -variable x]
d6474 1
a6474 1
    variable fcopyTestDone
d6483 1
a6483 2
    variable fcopyTestDone
    set listen [socket -server [namespace code FcopyTestAccept] 0]
d6485 1
a6485 1
    set out [socket 127.0.0.1 [lindex [fconfigure $listen -sockname] 2]]
d6488 1
a6488 2
    fcopy $in $out -command [namespace code FcopyTestDone]
    variable fcopyTestDone
d6490 1
a6490 1
	vwait [namespace which -variable fcopyTestDone]		;# The error occurs here in the b.g.
a6496 1
    variable fcopyTestDone
d6500 1
a6500 1
    set f1 [open $path(pipe) w]
d6503 3
a6505 4
    set in [open "|[list [interpreter] $path(pipe)]" r+]
    set out [open $path(test1) w]
    fcopy $in $out -command [namespace code FcopyTestDone]
    variable fcopyTestDone
d6507 1
a6507 1
	vwait [namespace which -variable fcopyTestDone]
a6513 53
proc doFcopy {in out {bytes 0} {error {}}} {
    variable fcopyTestDone
    variable fcopyTestCount
    incr fcopyTestCount $bytes
    if {[string length $error]} {
	    set fcopyTestDone 1
    } elseif {[eof $in]} {
	    set fcopyTestDone 0
    } else {
        # Delay next fcopy to wait for size>0 input bytes
        after 100 [list 
            fcopy $in $out -size 1000 \
		    -command [namespace code [list doFcopy $in $out]]
        ]
    }
}

test io-53.7 {CopyData: Flooding fcopy from pipe} {stdio} {
    variable fcopyTestDone
    removeFile pipe
    removeFile test1
    catch {unset fcopyTestDone}
    set fcopyTestCount 0
    set f1 [open $path(pipe) w]
    puts $f1 {
	# Write  10 bytes / 10 msec
	proc Write {count} {
	    puts -nonewline "1234567890"
	    if {[incr count -1]} {
	        after 10 [list Write $count]
	    } else {
	        set ::ready 1
	    }
	}
	fconfigure stdout -buffering none
	Write 345 ;# 3450 bytes ~3.45 sec
	vwait ready
	exit 0
    }
    close $f1
    set in [open "|[list [interpreter] $path(pipe) &]" r+]
    set out [open $path(test1) w]
    doFcopy $in $out
    variable fcopyTestDone
    if ![info exists fcopyTestDone] {
	vwait [namespace which -variable fcopyTestDone]
    }
    catch {close $in}
    close $out
    # -1=error 0=script error N=number of bytes
    expr ($fcopyTestDone == 0) ? $fcopyTestCount : -1
} {3450}

d6519 1
a6519 1
	variable as
d6526 1
a6526 2
	variable x
	variable result
d6529 2
a6530 2
	    fileevent $s readable [namespace code [list readit $s 2]]
	    vwait [namespace which -variable x]
d6534 1
a6534 1
    set ss [socket -server [namespace code accept] 0]
d6541 1
a6541 1
	if {![catch {set cs [socket [info hostname] [lindex [fconfigure $ss -sockname] 2]]}]} {
d6551 3
a6553 4
    variable result {}
    variable x 0
    variable as
    vwait [namespace which -variable as]
d6557 3
a6559 3
    fileevent $cs readable [namespace code [list readit $cs 1]]
    set a [after 2000 [namespace code { set x failure }]]
    vwait [namespace which -variable x]
d6569 1
a6569 1
    variable s [socket -server [namespace code accept] 0]
d6571 1
a6571 2
	variable counter
	variable accept
d6576 1
a6576 1
	fileevent $s readable [namespace code "doit $s"]
d6579 1
a6579 2
	variable counter
	variable after
d6584 2
a6585 2
	    fileevent $s readable [namespace code "doit1 $s"]
	    set after [after 1000 [namespace code newline]]
d6589 1
a6589 2
	variable counter
	variable accept
d6597 1
a6597 2
	variable s
	variable writer
d6599 1
a6599 1
	set writer [socket 127.0.0.1 [lindex [fconfigure $s -sockname] 2]]
d6605 1
a6605 2
	variable done
	variable writer
d6612 1
a6612 2
    variable done
    vwait [namespace which -variable done]
a6619 2
set path(fooBar) [makeFile {} fooBar]

a6620 1
    variable x
a6621 1
	variable x
d6624 1
a6624 1
	set x whoops
d6626 7
a6632 5
    proc ::bgerror {args} "set [namespace which -variable x] got_error"
    set f [open $path(fooBar) w]
    fileevent $f writable [namespace code [list eventScript $f]]
    variable x not_done
    vwait [namespace which -variable x]
d6636 2
a6637 2
test io-56.1 {ChannelTimerProc} {testchannelevent} {
    set f [open $path(fooBar) w]
d6640 2
a6641 2
    set f [open $path(fooBar) r]
    testchannelevent $f add readable [namespace code {
d6644 4
a6647 4
    }]
    variable x 0
    vwait [namespace which -variable x]
    vwait [namespace which -variable x]
d6650 2
a6651 3
    after idle [namespace code {set y done}]
    variable y
    vwait [namespace which -variable y]
d6658 1
a6658 2
	variable s2
	set s2 $sock
d6660 3
a6662 4
    set server [socket -server [namespace code accept] 0]
    set s [socket 127.0.0.1 [lindex [fconfigure $server -sockname] 2]]
    variable s2
    vwait [namespace which -variable s2]
d6664 1
a6664 1
    fileevent $s2 readable [namespace code {lappend result readable}]
d6667 3
a6669 3
    variable result [gets $s2]
    after 1000 [namespace code {lappend result timer}]
    vwait [namespace which -variable result]
d6671 1
a6671 1
    vwait [namespace which -variable result]
d6679 1
a6679 2
	variable s2
	set s2 $sock
d6681 3
a6683 4
    set server [socket -server [namespace code accept] 0]
    set s [socket 127.0.0.1 [lindex [fconfigure $server -sockname] 2]]
    variable s2
    vwait [namespace which -variable s2]
d6685 1
a6685 1
    fileevent $s2 readable [namespace code {lappend result readable}]
d6688 3
a6690 3
    variable result [read $s2 1]
    after 1000 [namespace code {lappend result timer}]
    vwait [namespace which -variable result]
d6692 1
a6692 1
    vwait [namespace which -variable result]
d6699 2
a6700 2
test io-58.1 {Tcl_NotifyChannel and error when closing} {stdio unixOrPc} {
    set out [open $path(script) w]
d6707 1
a6707 2
	variable x
	variable result
d6717 3
a6719 3
    set pipe [open "|[list [interpreter] $path(script)]" r]
    fileevent $pipe readable [namespace code [list readit $pipe]]
    variable x ""
d6721 1
a6721 1
    vwait [namespace which -variable x]
d6725 12
a6737 7
testConstraint testmainthread [llength [info commands testmainthread]]
test io-59.1 {Thread reference of channels} {testmainthread testchannel} {
    # TIP #10
    # More complicated tests (like that the reference changes as a
    # channel is moved from thread to thread) can be done only in the
    # extension which fully implements the moving of channels between
    # threads, i.e. 'Threads'. Or we have to extend [testthread] as well.
a6738 5
    set f [open $path(longfile) r]
    set result [testchannel mthread $f]
    close $f
    string equal $result [testmainthread]
} {1}
a6740 2
test io-60.1 {writing illegal utf sequences} {
    # This test will hang in older revisions of the core.
a6741 22
    set out [open $path(script) w]
    puts $out {
	puts [encoding convertfrom identity \xe2]
	exit 1
    }
    proc readit {pipe} {
	variable x
	variable result
	if {[eof $pipe]} {
	    set x [catch {close $pipe} line]
	    lappend result catch $line
	} else {
	    gets $pipe line
	    lappend result gets $line
	}
    }
    close $out
    set pipe [open "|[list [interpreter] $path(script)]" r]
    fileevent $pipe readable [namespace code [list readit $pipe]]
    variable x ""
    set result ""
    vwait [namespace which -variable x]
a6742 4
    # cut of the remainder of the error stack, especially the filename
    set result [lreplace $result 3 3 [lindex [split [lindex $result 3] \n] 0]]
    list $x $result
} {1 {gets {} catch {error writing "stdout": invalid argument}}}
a6746 9
# cleanup
foreach file [list fooBar longfile script output test1 pipe my_script foo \
	bar test2 test3 cat stdout] {
    removeFile $file
}
cleanupTests
}
namespace delete ::tcl::test::io
return
@


1.1
log
@Initial revision
@
text
@d10 1
d15 1
a15 1
# RCS: @@(#) $Id: io.test,v 1.12 1999/01/26 03:53:32 jingham Exp $
d17 1337
a1353 1
if {[string compare test [info procs test]] == 1} then {source defs}
d1355 24
a1378 5
if {"[info commands testchannel]" != "testchannel"} {
    puts "Skipping io tests. This application does not seem to have the"
    puts "testchannel command that is needed to run these tests."
    return
}
d1380 12
a1391 2
removeFile test1
removeFile pipe
d1393 12
a1404 1
# set up a long data file for some of the following tests
d1406 20
a1425 6
set f [open longfile w]
fconfigure $f -eofchar {} -translation lf
for { set i 0 } { $i < 100 } { incr i} {
    puts $f "#123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef
\#123456789abcdef01
\#"
d1427 52
a1478 1
close $f
d1480 12
a1491 21
set f [open cat w]
puts $f {
    if {$argv == {}} {
	set argv -
    }
    foreach name $argv {
	if {$name == "-"} {
	    set f stdin
	} elseif {[catch {open $name r} f] != 0} {
	    puts stderr $f
	    continue
	}
	while {[eof $f] == 0} {
	    puts -nonewline stdout [read $f]
	}
	if {$f != "stdin"} {
	    close $f
	}
    }
}
close $f
d1493 12
a1504 66
# These tests are disabled until we decide what to do with "unsupported0".
#
#test io-1.7 {unsupported0 command} {
#    removeFile test1
#    set f1 [open iocmd.test]
#    set f2 [open test1 w]
#    unsupported0 $f1 $f2
#    close $f1
#    catch {close $f2}
#    set s1 [file size [info script]]
#    set s2 [file size test1]
#    set x ok
#    if {"$s1" != "$s2"} {
#        set x broken
#    }
#    set x
#} ok
#test io-1.8 {unsupported0 command} {
#    removeFile test1
#    set f1 [open [info script]]
#    set f2 [open test1 w]
#    unsupported0 $f1 $f2 40
#    close $f1
#    close $f2
#    file size test1
#} 40
#test io-1.9 {unsupported0 command} {
#    removeFile test1
#    set f1 [open [info script]]
#    set f2 [open test1 w]
#    unsupported0 $f1 $f2 -1
#    close $f1
#    close $f2
#    set x ok
#    set s1 [file size [info script]]
#    set s2 [file size test1]
#    if {$s1 != $s2} {
#        set x broken
#    }
#    set x
#} ok
#test io-1.10 {unsupported0 command} {unixOrPc} {
#    removeFile pipe
#    removeFile test1
#    set f1 [open pipe w]
#    puts $f1 {puts ready}
#    puts $f1 {gets stdin}
#    puts $f1 {set f1 [open [info script] r]}
#    puts $f1 {puts [read $f1 100]}
#    puts $f1 {close $f1}
#    close $f1
#    set f1 [open "|[list $tcltest pipe]" r+]
#    gets $f1
#    puts $f1 ready
#    flush $f1
#    set f2 [open test1 w]
#    set c [unsupported0 $f1 $f2 40]
#    catch {close $f1}
#    close $f2
#    set s1 [file size test1]
#    set x ok
#    if {$s1 != "40"} {
#        set x broken
#    }
#    list $c $x
#} {40 ok}
d1506 11
d1526 1
a1526 1
test io-1.1 {Tcl_SetStdChannel and Tcl_GetStdChannel} {
d1534 1
a1534 1
test io-1.2 {Tcl_SetStdChannel and Tcl_GetStdChannel} {
d1543 1
a1543 1
test io-1.3 {Tcl_SetStdChannel & Tcl_GetStdChannel} {stdio} {
d1560 1
a1560 1
    set result [exec $tcltest test1]
d1572 1
a1572 1
test io-1.4 {Tcl_SetStdChannel & Tcl_GetStdChannel} {unixOnly} {
d1588 1
a1588 1
    set result [exec $tcltest test1]
d1600 1
a1600 1
test io-1.5 {Tcl_GetChannel: stdio name translation} {
d1610 1
a1610 1
test io-1.6 {Tcl_GetChannel: stdio name translation} {
d1620 1
a1620 1
test io-1.7 {Tcl_GetChannel: stdio name translation} {
d1630 1
a1630 1
test io-1.8 {reuse of stdio special channels} {unixOnly} {
d1643 1
a1643 1
    set f [open "|[list $tcltest script]" r]
d1648 1
a1648 1
test io-1.9 {reuse of stdio special channels} {stdio} {
d1661 1
a1661 1
    set f [open "|[list $tcltest script]" r]
d1667 5
a1671 2
# Must add test function for testing Tcl_CreateCloseHandler and
# Tcl_DeleteCloseHandler.
d1680 1
a1680 10
#
# CYGNUS LOCAL:
# I open tclConfig.sh to get the correct paths if I am not in the install
# directory.  This increments the refcount on the stdin WHEN the interpreter
# is created, not when you call eof stdin in the child.  Because of this, I
# had to change the first value in the results for tests 2.1, 2.2 & 2.3 from
# 0 to 1.  This is really a side issue, and does not affect what the tests
# were supposed to be looking for, however.
  
test io-2.1 {GetChannelTable, DeleteChannelTable on std handles} {
d1691 2
a1692 2
} {1 1 0}
test io-2.2 {GetChannelTable, DeleteChannelTable on std handles} {
d1703 2
a1704 2
} {1 1 0}
test io-2.3 {GetChannelTable, DeleteChannelTable on std handles} {
d1715 3
a1717 2
} {1 1 0}
test io-2.4 {Tcl_RegisterChannel, Tcl_UnregisterChannel} {
d1731 1
a1731 1
test io-2.5 {Tcl_RegisterChannel, Tcl_UnregisterChannel} {
d1752 1
a1752 1
test io-2.6 {Tcl_RegisterChannel, Tcl_UnregisterChannel} {
d1771 2
a1772 1
test io-2.7 {Tcl_GetChannel->Tcl_GetStdChannel, standard handles} {
d1775 1
a1775 1
test io-2.8 {testing Tcl_GetChannel, user opened handle} {
d1782 1
a1782 1
test io-2.9 {Tcl_GetChannel, channel not found} {
d1785 1
a1785 1
test io-2.10 {Tcl_CreateChannel, insertion into channel table} {
d1800 46
d1852 5
a1856 1
test io-3.1 {Tcl_GetChannelName} {
d1863 2
a1864 1
test io-3.2 {Tcl_GetChannelType} {
d1871 2
a1872 1
test io-3.3 {Tcl_GetChannelFile, input} {
d1885 1
a1885 1
test io-3.4 {Tcl_GetChannelFile, output} {
d1901 9
d1912 1
a1912 1
test io-4.1 {FlushChannel, no output buffered} {
d1920 1
a1920 1
test io-4.2 {FlushChannel, some output buffered} {
d1933 1
a1933 1
test io-4.3 {FlushChannel, implicit flush on close} {
d1944 1
a1944 1
test io-4.4 {FlushChannel, implicit flush when buffer fills} {
d1960 2
a1961 1
test io-4.5 {FlushChannel, implicit flush when buffer fills and on close} {unixOrPc} {
d1975 2
a1976 1
test io-4.6 {FlushChannel, async flushing, async close} {stdio && asyncPipeClose} {
d1996 1
a1996 1
    set f [open "|[list $tcltest pipe]" w]
d2007 1
a2007 1
        set result probably_broken
d2015 1
a2015 1
test io-5.1 {CloseChannel called when all references are dropped} {
d2028 1
a2028 1
test io-5.2 {CloseChannel called when all references are dropped} {
d2043 2
a2044 1
test io-5.3 {CloseChannel, not called before output queue is empty} {unixOrPc asyncPipeClose nonPortable tempNotPc} {
d2072 1
a2072 1
    set f [open "|[list $tcltest pipe]" r+]
a2074 3
    # Under windows, the first 24576 bytes of $x are copied to $f, and
    # then the writing fails.  

d2089 1
a2089 1
test io-5.4 {Tcl_Close} {
d2102 1
a2102 1
test io-5.5 {Tcl_Close vs standard handles} {unixOnly} {
d2110 1
a2110 1
    set f [open "|[list $tcltest script]" r]
d2116 1
a2116 4
# Test output on channels. The functions tested are Tcl_Write
# and Tcl_Flush.

test io-6.1 {Tcl_Write, channel not writable} {
d2119 1
a2119 1
test io-6.2 {Tcl_Write, empty string} {
d2127 1
a2127 1
test io-6.3 {Tcl_Write, nonempty string} {
d2135 1
a2135 1
test io-6.4 {Tcl_Write, buffering in full buffering mode} {
d2149 1
a2149 1
test io-6.5 {Tcl_Write, buffering in line buffering mode} {
d2163 1
a2163 1
test io-6.6 {Tcl_Write, buffering in no buffering mode} {
d2177 2
a2178 1
test io-6.7 {Tcl_Flush, full buffering} {
d2195 1
a2195 1
test io-6.8 {Tcl_Flush, full buffering} {
d2215 1
a2215 1
test io-6.9 {Tcl_Flush, channel not writable} {
d2218 1
a2218 1
test io-6.10 {Tcl_Write, looping and buffering} {
d2224 1
a2224 1
        puts $f1 [gets $f2]
d2230 1
a2230 1
test io-6.11 {Tcl_Write, no newline, implicit flush} {
d2236 1
a2236 1
        puts -nonewline $f1 [gets $f2]
d2242 1
a2242 1
test io-6.12 {Tcl_Write on a pipe} {stdio} {
d2253 1
a2253 1
    set f1 [open "|[list $tcltest pipe]" r]
d2257 5
a2261 5
        set l1 [gets $f1]
        set l2 [gets $f2]
        if {"$l1" != "$l2"} {
            set y broken
        }
d2267 1
a2267 1
test io-6.13 {Tcl_Write to a pipe, line buffered} {stdio} {
d2277 1
a2277 1
    set f1 [open "|[list $tcltest pipe]" r+]
d2284 1
a2284 1
        set y broken
d2290 1
a2290 1
        set y broken
d2296 1
a2296 1
test io-6.14 {Tcl_Write, buffering and implicit flush at close} {
d2308 1
a2308 1
test io-6.15 {Tcl_Flush, channel not open for writing} {
d2318 2
a2319 2
test io-6.16 {Tcl_Flush on pipe opened only for reading} {stdio} {
    set fd [open "|[list $tcltest cat longfile]" r]
d2325 1
a2325 1
test io-6.17 {Tcl_Write buffers, then Tcl_Flush flushes} {
d2337 1
a2337 1
test io-6.18 {Tcl_Write and Tcl_Flush intermixed} {
d2356 1
a2356 1
test io-6.19 {Explicit and implicit flushes} {
d2374 1
a2374 1
test io-6.20 {Implicit flush when buffer is full} {
d2385 1
a2385 1
        puts $f1 $line
d2392 1
a2392 1
test io-6.21 {Tcl_Flush to pipe} {stdio} {
d2399 1
a2399 1
    set f1 [open "|[list $tcltest pipe]" r+]
d2406 1
a2406 1
test io-6.22 {Tcl_Flush called at other end of pipe} {stdio} {
d2419 1
a2419 1
    set f1 [open "|[list $tcltest pipe]" r+]
d2429 1
a2429 1
test io-6.23 {Tcl_Flush and line buffering at end of pipe} {stdio} {
d2439 1
a2439 1
    set f1 [open "|[list $tcltest pipe]" r+]
d2449 1
a2449 1
test io-6.24 {Tcl_Write and Tcl_Flush move end of file} {
d2463 2
a2464 3
} {{} {Line 1
Line 2}}
test io-6.25 {Implicit flush with Tcl_Flush to command pipelines} {stdio} {
d2466 1
a2466 1
    set f [open "|[list $tcltest cat | $tcltest cat > test3]" w]
d2475 2
a2476 4
} {Line 1
Line 2
}    
test io-6.26 {Tcl_Flush, Tcl_Write on bidirectional pipelines} {unixOrPc && unixExecs && tempNotPc} {
d2484 1
a2484 1
test io-6.27 {Tcl_Flush on closed pipeline} {stdio && tempNotPc} {
d2489 1
a2489 1
    set f [open "|[list $tcltest pipe]" r+]
d2512 1
a2512 1
test io-6.28 {Tcl_Write, lf mode} {
d2522 1
a2522 1
test io-6.29 {Tcl_Write, cr mode} {
d2530 1
a2530 1
test io-6.30 {Tcl_Write, crlf mode} {
d2538 1
a2538 1
test io-6.31 {Tcl_Write, background flush} {stdio} {
d2554 1
a2554 1
        set x "$x$x"
d2558 1
a2558 1
    set f [open "|[list $tcltest pipe]" r+]
d2564 3
a2566 3
        incr counter
        after 5
        update
d2569 1
a2569 1
        set result probably_broken
d2571 1
a2571 1
        set result ok
d2574 2
a2575 1
test io-6.32 {Tcl_Write, background flush to slow reader} {stdio && asyncPipeClose} {
d2592 1
a2592 1
        set x "$x$x"
d2596 1
a2596 1
    set f [open "|[list $tcltest pipe]" r+]
d2602 3
a2604 3
        incr counter
        after 20
        update
d2607 1
a2607 1
        set result probably_broken
d2609 1
a2609 1
        set result ok
d2612 1
a2612 1
test io-6.33 {Tcl_Flush, implicit flush on exit} {stdio} {
d2622 1
a2622 1
    exec $tcltest script
d2627 2
a2628 6
} {hello
bye
strange
}

test io-6.34 {Tcl_Close, async flush on close, using sockets} {socket tempNotMac} {
d2664 4
a2667 1
test io-6.35 {Tcl_Close vs fileevent vs multiple interpreters} {socket} {
d2708 1
a2708 1
test io-7.1 {Tcl_Write lf, Tcl_Read lf} {
d2720 1
a2720 1
test io-7.2 {Tcl_Write lf, Tcl_Read cr} {
d2732 1
a2732 1
test io-7.3 {Tcl_Write lf, Tcl_Read crlf} {
d2744 1
a2744 1
test io-7.4 {Tcl_Write cr, Tcl_Read cr} {
d2756 1
a2756 1
test io-7.5 {Tcl_Write cr, Tcl_Read lf} {
d2768 1
a2768 1
test io-7.6 {Tcl_Write cr, Tcl_Read crlf} {
d2780 1
a2780 1
test io-7.7 {Tcl_Write crlf, Tcl_Read crlf} {
d2792 1
a2792 1
test io-7.8 {Tcl_Write crlf, Tcl_Read lf} {
d2804 1
a2804 1
test io-7.9 {Tcl_Write crlf, Tcl_Read cr} {
d2816 1
a2816 1
test io-7.10 {Tcl_Write lf, Tcl_Read auto} {
d2832 1
a2832 1
test io-7.11 {Tcl_Write cr, Tcl_Read auto} {
d2848 1
a2848 1
test io-7.12 {Tcl_Write crlf, Tcl_Read auto} {
d2865 1
a2865 1
test io-7.13 {Tcl_Write crlf on block boundary, Tcl_Read auto} {
d2882 1
a2882 1
test io-7.14 {Tcl_Write crlf on block boundary, Tcl_Read crlf} {
d2899 1
a2899 1
test io-7.15 {Tcl_Write mixed, Tcl_Read auto} {
d2915 1
a2915 1
test io-7.16 {Tcl_Write ^Z at end, Tcl_Read auto} {
d2931 1
a2931 1
test io-7.17 {Tcl_Write, implicit ^Z at end, Tcl_Read auto} {pcOnly} {
d2947 1
a2947 1
test io-7.18 {Tcl_Write, ^Z in middle, Tcl_Read auto} {
d2967 1
a2967 1
test io-7.19 {Tcl_Write, ^Z no newline in middle, Tcl_Read auto} {
d2987 1
a2987 1
test io-7.20 {Tcl_Write, ^Z in middle ignored, Tcl_Read lf} {
d3009 1
a3009 1
test io-7.21 {Tcl_Write, ^Z in middle ignored, Tcl_Read cr} {
d3020 1
a3020 1
    lappend l [string compare $x "abc\ndef\n\x1aghi\nqrs"]
d3027 1
a3027 1
test io-7.22 {Tcl_Write, ^Z in middle ignored, Tcl_Read crlf} {
d3038 1
a3038 1
    lappend l [string compare $x "abc\ndef\n\x1aghi\nqrs"]
d3045 1
a3045 1
test io-7.23 {Tcl_Write lf, ^Z in middle, Tcl_Read auto} {
d3059 1
a3059 1
test io-7.24 {Tcl_Write lf, ^Z in middle, Tcl_Read lf} {
d3073 1
a3073 1
test io-7.25 {Tcl_Write cr, ^Z in middle, Tcl_Read auto} {
d3087 1
a3087 1
test io-7.26 {Tcl_Write cr, ^Z in middle, Tcl_Read cr} {
d3101 1
a3101 1
test io-7.27 {Tcl_Write crlf, ^Z in middle, Tcl_Read auto} {
d3115 1
a3115 1
test io-7.28 {Tcl_Write crlf, ^Z in middle, Tcl_Read crlf} {
d3132 1
a3132 1
test io-8.1 {Tcl_Write lf, Tcl_Gets auto} {
d3149 1
a3149 1
test io-8.2 {Tcl_Write cr, Tcl_Gets auto} {
d3166 1
a3166 1
test io-8.3 {Tcl_Write crlf, Tcl_Gets auto} {
d3183 1
a3183 1
test io-8.4 {Tcl_Write lf, Tcl_Gets lf} {
d3201 1
a3201 1
test io-8.5 {Tcl_Write lf, Tcl_Gets cr} {
d3220 2
a3221 2
} {20 21 cr 1 {} 21 cr 1}
test io-8.6 {Tcl_Write lf, Tcl_Gets crlf} {
d3240 2
a3241 2
} {20 21 crlf 1 {} 21 crlf 1}
test io-8.7 {Tcl_Write cr, Tcl_Gets cr} {
d3261 1
a3261 1
test io-8.8 {Tcl_Write cr, Tcl_Gets lf} {
d3281 1
a3281 1
test io-8.9 {Tcl_Write cr, Tcl_Gets crlf} {
d3301 1
a3301 1
test io-8.10 {Tcl_Write crlf, Tcl_Gets crlf} {
d3321 1
a3321 1
test io-8.11 {Tcl_Write crlf, Tcl_Gets cr} {
d3341 1
a3341 1
test io-8.12 {Tcl_Write crlf, Tcl_Gets lf} {
d3361 1
a3361 1
test io-8.13 {binary mode is synonym of lf mode} {
d3373 1
a3373 1
test io-8.14 {Tcl_Write mixed, Tcl_Gets auto} {
d3392 1
a3392 1
test io-8.15 {Tcl_Write mixed, Tcl_Gets auto} {
d3411 1
a3411 1
test io-8.16 {Tcl_Write mixed, Tcl_Gets auto} {
d3429 1
a3429 1
test io-8.17 {Tcl_Write mixed, Tcl_Gets auto} {
d3448 1
a3448 1
test io-8.18 {Tcl_Write ^Z at end, Tcl_Gets auto} {
d3468 1
a3468 1
test io-8.19 {Tcl_Write, implicit ^Z at end, Tcl_Gets auto} {
d3487 1
a3487 1
test io-8.20 {Tcl_Write, ^Z in middle, Tcl_Gets auto, eofChar} {
d3506 1
a3506 1
test io-8.21 {Tcl_Write, no newline ^Z in middle, Tcl_Gets auto, eofChar} {
d3524 1
a3524 1
test io-8.22 {Tcl_Write, ^Z in middle ignored, Tcl_Gets lf} {
d3546 1
a3546 1
test io-8.23 {Tcl_Write, ^Z in middle ignored, Tcl_Gets cr} {
d3568 1
a3568 1
test io-8.24 {Tcl_Write, ^Z in middle ignored, Tcl_Gets crlf} {
d3590 1
a3590 1
test io-8.25 {Tcl_Write lf, ^Z in middle, Tcl_Gets auto} {
d3608 1
a3608 1
test io-8.26 {Tcl_Write lf, ^Z in middle, Tcl_Gets lf} {
d3626 1
a3626 1
test io-8.27 {Tcl_Write cr, ^Z in middle, Tcl_Gets auto} {
d3644 1
a3644 1
test io-8.28 {Tcl_Write cr, ^Z in middle, Tcl_Gets cr} {
d3662 1
a3662 1
test io-8.29 {Tcl_Write crlf, ^Z in middle, Tcl_Gets auto} {
d3680 1
a3680 1
test io-8.30 {Tcl_Write crlf, ^Z in middle, Tcl_Gets crlf} {
d3698 1
a3698 1
test io-8.31 {Tcl_Write crlf on block boundary, Tcl_Gets auto} {
d3709 1
a3709 1
    fconfigure $f -translation auto
d3717 1
a3717 1
test io-8.32 {Tcl_Write crlf on block boundary, Tcl_Gets auto} {
d3723 1
a3723 1
    for {set i 0} {$i < 256} {incr i} {
d3735 1
a3735 1
} [expr 256*15+1]
d3740 1
a3740 1
test io-9.1 {Tcl_Read, channel not readable} {
d3743 1
a3743 1
test io-9.2 {Tcl_Read, zero byte count} {
d3746 1
a3746 1
test io-9.3 {Tcl_Read, negative byte count} {
d3752 1
a3752 1
test io-9.4 {Tcl_Read, positive byte count} {
d3760 1
a3760 1
test io-9.5 {Tcl_Read, multiple buffers} {
d3769 1
a3769 1
test io-9.6 {Tcl_Read, very large read} {
d3777 1
a3777 1
        set x broken
d3781 1
a3781 1
test io-9.7 {Tcl_Read, nonblocking, file} {nonBlockFiles} {
d3789 1
a3789 1
        set x broken
d3793 1
a3793 1
test io-9.8 {Tcl_Read, nonblocking, file} {nonBlockFiles} {
d3802 1
a3802 1
        set x broken
d3806 1
a3806 1
test io-9.9 {Tcl_Read, read to end of file} {
d3814 1
a3814 1
        set x broken
d3818 1
a3818 1
test io-9.10 {Tcl_Read from a pipe} {stdio} {
d3823 1
a3823 1
    set f1 [open "|[list $tcltest pipe]" r+]
d3830 1
a3830 1
test io-9.11 {Tcl_Read from a pipe} {stdio} {
d3836 1
a3836 1
    set f1 [open "|[list $tcltest pipe]" r+]
d3849 1
a3849 1
test io-9.12 {Tcl_Read, -nonewline} {
d3861 1
a3861 1
test io-9.13 {Tcl_Read, -nonewline} {
d3873 1
a3873 1
test io-9.14 {Tcl_Read, reading in small chunks} {
d3886 1
a3886 1
test io-9.15 {Tcl_Read, asking for more input than available} {
d3899 1
a3899 1
test io-9.16 {Tcl_Read, read to end of file with -nonewline} {
d3914 1
a3914 1
test io-10.1 {Tcl_Gets, reading what was written} {
d3924 1
a3924 1
        set z broken
d3929 1
a3929 1
test io-10.2 {Tcl_Gets into variable} {
d3935 1
a3935 1
        set z broken
d3940 1
a3940 1
test io-10.3 {Tcl_Gets from pipe} {stdio} {
d3945 1
a3945 1
    set f1 [open "|[list $tcltest pipe]" r+]
d3952 1
a3952 1
        set z broken
d3956 1
a3956 1
test io-10.4 {Tcl_Gets with long line} {
d3970 1
a3970 1
test io-10.5 {Tcl_Gets with long line} {
d3976 1
a3976 1
test io-10.6 {Tcl_Gets and end of file} {
d3992 1
a3992 1
test io-10.7 {Tcl_Gets and bad variable} {
d4004 1
a4004 1
test io-10.8 {Tcl_Gets, exercising double buffering} {
d4017 1
a4017 1
test io-10.9 {Tcl_Gets, exercising double buffering} {
d4030 1
a4030 1
test io-10.10 {Tcl_Gets, exercising double buffering} {
d4046 1
a4046 1
test io-11.1 {Tcl_Seek to current position at start of file} {
d4053 1
a4053 1
test io-11.2 {Tcl_Seek to offset from start} {
d4066 1
a4066 1
test io-11.3 {Tcl_Seek to end of file} {
d4079 1
a4079 1
test io-11.4 {Tcl_Seek to offset from end of file} {
d4092 1
a4092 1
test io-11.5 {Tcl_Seek to offset from current position} {
d4106 1
a4106 1
test io-11.6 {Tcl_Seek to offset from end of file} {
d4121 1
a4121 1
test io-11.7 {Tcl_Seek to offset from end of file, then to current position} {
d4137 2
a4138 2
test io-11.8 {Tcl_Seek on pipes: not supported} {stdio} {
    set f1 [open "|[list $tcltest]" r+]
d4144 1
a4144 1
test io-11.9 {Tcl_Seek, testing buffered input flushing} {
d4167 1
a4167 1
test io-11.10 {Tcl_Seek testing flushing of buffered input} {
d4181 1
a4181 1
test io-11.11 {Tcl_Seek testing flushing of buffered output} {
d4192 1
a4192 1
test io-11.12 {Tcl_Seek testing combination of write, seek back and read} {
d4209 1
a4209 1
test io-11.13 {Tcl_Tell at start of file} {
d4216 1
a4216 1
test io-11.14 {Tcl_Tell after seek to end of file} {
d4229 1
a4229 1
test io-11.15 {Tcl_Tell combined with seeking} {
d4244 2
a4245 2
test io-11.16 {Tcl_tell on pipe: always -1} {stdio} {
    set f1 [open "|[list $tcltest]" r+]
d4250 2
a4251 2
test io-11.17 {Tcl_Tell on pipe: always -1} {stdio} {
    set f1 [open "|[list $tcltest]" r+]
d4259 1
a4259 1
test io-11.18 {Tcl_Tell combined with seeking and reading} {
d4279 1
a4279 1
test io-11.19 {Tcl_Tell combined with opening in append mode} {
d4290 1
a4290 1
test io-11.20 {Tcl_Tell combined with writing} {
d4308 1
a4308 1
test io-12.1 {Tcl_Eof} {
d4327 1
a4327 1
test io-12.2 {Tcl_Eof with pipe} {stdio} {
d4333 1
a4333 1
    set f1 [open "|[list $tcltest pipe]" r+]
d4345 1
a4345 1
test io-12.3 {Tcl_Eof with pipe} {stdio} {
d4351 1
a4351 1
    set f1 [open "|[list $tcltest pipe]" r+]
d4367 1
a4367 1
test io-12.4 {Tcl_Eof, eof detection on nonblocking file} {nonBlockFiles} {
d4379 1
a4379 1
test io-12.5 {Tcl_Eof, eof detection on nonblocking pipe} {stdio} {
d4386 1
a4386 1
    set f [open "|[list $tcltest pipe]" r]
d4393 1
a4393 1
test io-12.6 {Tcl_Eof, eof char, lf write, auto read} {
d4407 1
a4407 1
test io-12.7 {Tcl_Eof, eof char, lf write, lf read} {
d4421 1
a4421 1
test io-12.8 {Tcl_Eof, eof char, cr write, auto read} {
d4435 1
a4435 1
test io-12.9 {Tcl_Eof, eof char, cr write, cr read} {
d4449 1
a4449 1
test io-12.10 {Tcl_Eof, eof char, crlf write, auto read} {
d4463 1
a4463 1
test io-12.11 {Tcl_Eof, eof char, crlf write, crlf read} {
d4477 1
a4477 1
test io-12.12 {Tcl_Eof, eof char in middle, lf write, auto read} {
d4492 1
a4492 1
test io-12.13 {Tcl_Eof, eof char in middle, lf write, lf read} {
d4507 1
a4507 1
test io-12.14 {Tcl_Eof, eof char in middle, cr write, auto read} {
d4522 1
a4522 1
test io-12.15 {Tcl_Eof, eof char in middle, cr write, cr read} {
d4537 1
a4537 1
test io-12.16 {Tcl_Eof, eof char in middle, crlf write, auto read} {
d4552 1
a4552 1
test io-12.17 {Tcl_Eof, eof char in middle, crlf write, crlf read} {
d4570 2
a4571 2
test io-13.1 {Tcl_InputBlocked on nonblocking pipe} {unixOrPc tempNotPc} {
    set f1 [open "|[list $tcltest]" r+]
d4589 2
a4590 2
test io-13.2 {Tcl_InputBlocked on blocking pipe} {unixOrPc tempNotPc} {
    set f1 [open "|[list $tcltest]" r+]
d4603 1
a4603 1
test io-13.3 {Tcl_InputBlocked vs files, short read} {
d4619 1
a4619 1
test io-13.4 {Tcl_InputBlocked vs files, event driven read} {
d4636 1
a4636 1
test io-13.5 {Tcl_InputBlocked vs files, short read, nonblocking} {nonBlockFiles} {
d4653 1
a4653 1
test io-13.6 {Tcl_InputBlocked vs files, event driven read} {nonBlockFiles} {
d4674 1
a4674 1
test io-14.1 {Tcl_InputBuffered} {
d4684 1
a4684 1
test io-14.2 {Tcl_InputBuffered, test input flushing on seek} {
d4700 1
a4700 1
test io-15.1 {Tcl_GetChannelBufferSize, default buffer size} {
d4706 1
a4706 1
test io-15.2 {Tcl_SetChannelBufferSize, Tcl_GetChannelBufferSize} {
d4728 1
a4728 1
test io-16.1 {Tcl_GetChannelOption} {
d4738 1
a4738 1
test io-16.2 {Tcl_GetChannelOption} {
d4745 1
a4745 1
test io-16.3 {Tcl_GetChannelOption} {
d4753 1
a4753 1
test io-16.4 {Tcl_GetChannelOption, Tcl_SetChannelOption} {
d4769 1
a4769 1
test io-16.5 {Tcl_GetChannelOption, invariance} {
d4779 1
a4779 1
test io-16.6 {Tcl_SetChannelOption, multiple options} {
d4789 1
a4789 1
test io-16.7 {Tcl_SetChannelOption, buffering, translation} {
d4803 1
a4803 1
test io-16.8 {Tcl_SetChannelOption, different buffering options} {
d4823 1
a4823 1
test io-16.9 {Tcl_SetChannelOption, blocking mode} {nonBlockFiles} {
d4839 1
a4839 1
test io-16.10 {Tcl_SetChannelOption, blocking mode} {unixOrPc tempNotPc} {
d4842 6
a4847 4
    puts $f1 {gets stdin}
    puts $f1 {after 100}
    puts $f1 {puts hi}
    puts $f1 {gets stdin}
d4850 1
a4850 1
    set f1 [open "|[list $tcltest pipe]" r+]
d4855 1
d4857 1
d4860 1
d4862 1
d4875 1
a4875 1
test io-16.11 {Tcl_SetChannelOption, Tcl_GetChannelOption, buffer size} {
d4883 1
a4883 1
test io-16.12 {Tcl_SetChannelOption, Tcl_GetChannelOption buffer size} {
d4891 1
a4891 1
test io-16.13 {Tcl_SetChannelOption, Tcl_GetChannelOption, buffer size} {
d4899 55
a4953 1
test io-16.14 {Tcl_SetChannelOption, setting read mode independently} \
d4958 1
a4958 1
    set s2 [socket localhost $port]
d4966 1
a4966 1
test io-16.15 {Tcl_SetChannelOption, setting read mode independently} \
d4971 1
a4971 1
    set s2 [socket localhost $port]
d4979 1
a4979 1
test io-16.16 {Tcl_SetChannelOption, setting read mode independently} \
d4984 1
a4984 1
    set s2 [socket localhost $port]
d4992 1
a4992 1
test io-16.17 {Tcl_SetChannelOption, setting read mode independently} \
d4997 1
a4997 1
    set s2 [socket localhost $port]
d5006 1
a5006 1
test io-17.1 {POSIX open access modes: RDWR} {
d5021 1
a5021 1
test io-17.2 {POSIX open access modes: CREAT} {unixOnly} {
d5033 6
a5038 1
test io-17.3 {POSIX open access modes: CREAT} {$testConfig(unix) && ([exec umask] == 2)} {
d5046 1
a5046 1
test io-17.4 {POSIX open access modes: CREAT} {
d5061 1
a5061 1
test io-17.5 {POSIX open access modes: APPEND} {
d5082 1
a5082 1
test io-17.6 {POSIX open access modes: EXCL} {
d5091 1
a5091 1
test io-17.7 {POSIX open access modes: EXCL} {
d5099 1
a5099 1
test io-17.8 {POSIX open access modes: TRUNC} {
d5112 1
a5112 1
test io-17.9 {POSIX open access modes: NONBLOCK} {nonPortable macOrUnix} {
d5122 1
a5122 1
test io-17.10 {POSIX open access modes: RDONLY} {
d5134 1
a5134 1
test io-17.11 {POSIX open access modes: RDONLY} {
d5138 1
a5138 1
test io-17.12 {POSIX open access modes: WRONLY} {
d5142 1
a5142 1
test io-17.13 {POSIX open access modes: WRONLY} {
d5154 1
a5154 1
test io-17.14 {POSIX open access modes: RDWR} {
d5158 1
a5158 1
test io-17.15 {POSIX open access modes: RDWR} {
d5168 1
a5168 1
    test io-17.16 {tilde substitution in open} {
d5177 1
a5177 1
test io-17.17 {tilde substitution in open} {
d5185 1
a5185 1
test io-18.1 {Tcl_FileeventCmd: errors} {
d5187 2
a5188 2
} {1 {wrong # args: must be "fileevent channelId event ?script?}}
test io-18.2 {Tcl_FileeventCmd: errors} {
d5190 2
a5191 2
} {1 {wrong # args: must be "fileevent channelId event ?script?}}
test io-18.3 {Tcl_FileeventCmd: errors} {
d5194 1
a5194 1
test io-18.4 {Tcl_FileeventCmd: errors} {
d5197 1
a5197 1
test io-18.5 {Tcl_FileeventCmd: errors} {
d5207 1
a5207 1
test io-19.1 {Tcl_FileeventCmd: creating, deleting, querying} {
d5210 1
a5210 1
test io-19.2 {Tcl_FileeventCmd: replacing} {
d5221 11
a5236 3
if {($tcl_platform(platform) != "macintosh") && \
	($testConfig(unixExecs) == 1)} {

d5240 1
a5240 1
test io-20.1 {Tcl_FileeventCmd: creating, deleting, querying} {
d5251 1
a5251 1
test io-20.2 {Tcl_FileeventCmd: deleting when many present} {
d5266 1
a5266 1
test io-21.1 {FileEventProc procedure: normal read event} {
d5275 1
a5275 1
test io-21.2 {FileEventProc procedure: error in read event} {
d5287 1
a5287 1
test io-21.3 {FileEventProc procedure: normal write event} {
d5302 1
a5302 1
test io-21.4 {FileEventProc procedure: eror in write event} {
d5313 2
a5314 2
test io-21.5 {FileEventProc procedure: end of file} {unixOrPc} {
    set f4 [open "|[list $tcltest cat << foo]" r]
a5332 3
}
	# Closes if {($platform(platform) != "macintosh") && \
	#		($testConfig(unixExecs) == 1)} clause
d5336 1
a5336 1
test io-22.1 {DeleteFileEvent, cleanup on close} {
d5348 1
a5348 1
test io-22.2 {DeleteFileEvent, cleanup on close} {
d5365 1
a5365 1
test io-22.3 {DeleteFileEvent, cleanup on close} {
d5391 1
a5391 1
test io-23.1 {Tcl event loop vs multiple interpreters} {
d5406 1
a5406 1
test io-23.2 {Tcl event loop vs multiple interpreters} {
d5415 1
a5415 1
test io-23.3 {Tcl event loop vs multiple interpreters} {
d5429 1
a5429 1
test io-24.1 {fileevent vs multiple interpreters} {
d5448 1
a5448 1
test io-24.2 {deleting fileevent on interpreter delete} {
d5469 1
a5469 1
test io-24.3 {deleting fileevent on interpreter delete} {
d5490 1
a5490 1
test io-24.4 {file events on shared files and multiple interpreters} {
d5506 1
a5506 1
test io-24.5 {file events on shared files, deleting file events} {
d5519 1
a5519 1
test io-24.6 {file events on shared files, deleting file events} {
d5537 1
a5537 1
test io-25.1 {testing readability conditions} {
d5562 1
a5562 1
test io-25.2 {testing readability conditions} {nonBlockFiles} {
d5588 1
a5588 1
test io-25.3 {testing readability conditions} {unixOnly nonBlockFiles} {
d5607 1
a5607 1
    set f [open "|[list $tcltest]" r+]
d5632 1
a5632 1
test io-25.4 {lf write, testing readability, ^Z termination, auto read mode} {
d5657 1
a5657 1
test io-25.5 {lf write, testing readability, ^Z in middle, auto read mode} {
d5682 1
a5682 1
test io-25.6 {cr write, testing readability, ^Z termination, auto read mode} {
d5707 1
a5707 1
test io-25.7 {cr write, testing readability, ^Z in middle, auto read mode} {
d5732 1
a5732 1
test io-25.8 {crlf write, testing readability, ^Z termination, auto read mode} {
d5757 1
a5757 1
test io-25.9 {crlf write, testing readability, ^Z in middle, auto read mode} {
d5782 1
a5782 1
test io-25.10 {lf write, testing readability, ^Z in middle, lf read mode} {
d5807 1
a5807 1
test io-25.11 {lf write, testing readability, ^Z termination, lf read mode} {
d5832 1
a5832 1
test io-25.12 {cr write, testing readability, ^Z in middle, cr read mode} {
d5857 1
a5857 1
test io-25.13 {cr write, testing readability, ^Z termination, cr read mode} {
d5882 1
a5882 1
test io-25.14 {crlf write, testing readability, ^Z in middle, crlf read mode} {
d5907 1
a5907 1
test io-25.15 {crlf write, testing readability, ^Z termi, crlf read mode} {
d5933 1
a5933 1
test io-26.1 {testing crlf reading, leftover cr disgorgment} {
d5962 1
a5962 1
test io-26.2 {testing crlf reading, leftover cr disgorgment} {
d5985 1
a5985 1
test io-26.3 {testing crlf reading, leftover cr disgorgment} {
d6006 1
a6006 1
test io-26.4 {testing crlf reading, leftover cr disgorgment} {
d6027 1
a6027 1
test io-26.5 {testing crlf reading, leftover cr disgorgment} {
d6046 1
a6046 1
test io-27.1 {testing handler deletion} {
d6062 1
a6062 1
test io-27.2 {testing handler deletion with multiple handlers} {
d6080 1
a6080 1
test io-27.3 {testing handler deletion with multiple handlers} {
d6106 1
a6106 1
test io-27.4 {testing handler deletion vs reentrant calls} {
d6130 1
a6130 1
test io-27.5 {testing handler deletion vs reentrant calls} {
d6163 1
a6163 1
test io-27.6 {testing handler deletion vs reentrant calls} {
d6205 1
a6205 1
test io-28.1 {Test old socket deletion on Macintosh} {socket} {
d6243 1
a6243 1
test io-29.1 {TclCopyChannel} {
d6245 1
a6245 1
    set f1 [open [info script]]
d6253 1
a6253 1
test io-29.2 {TclCopyChannel} {
d6255 1
a6255 1
    set f1 [open [info script]]
d6257 1
a6257 1
    set f3 [open [info script]]
d6265 1
a6265 1
test io-29.3 {TclCopyChannel} {
d6267 1
a6267 1
    set f1 [open [info script]]
d6275 1
a6275 1
    set s1 [file size [info script]]
d6282 1
a6282 1
test io-29.4 {TclCopyChannel} {
d6284 1
a6284 1
    set f1 [open [info script]]
d6294 1
a6294 1
test io-29.5 {TclCopyChannel} {
d6296 1
a6296 1
    set f1 [open [info script]]
d6304 1
a6304 1
    set s1 [file size [info script]]
d6311 1
a6311 1
test io-29.6 {TclCopyChannel} {
d6313 1
a6313 1
    set f1 [open [info script]]
d6317 1
a6317 1
    set s0 [fcopy $f1 $f2 -size [expr [file size [info script]] + 5]]
d6321 1
a6321 1
    set s1 [file size [info script]]
d6328 1
a6328 1
test io-29.7 {TclCopyChannel} {
d6330 1
a6330 1
    set f1 [open [info script]]
d6336 1
a6336 1
    set s1 [file size [info script]]
d6345 1
a6345 1
test io-29.8 {TclCopyChannel} {stdio} {
d6350 1
a6350 1
    puts $f1 {
d6353 5
a6357 5
	set f1 [open [info script] r]
	fconfigure $f1 -translation lf
	puts [read $f1 100]
	close $f1
    }
d6359 1
a6359 1
    set f1 [open "|[list $tcltest pipe]" r+]
d6372 1
a6372 1
test io-30.1 {CopyData} {
d6374 1
a6374 1
    set f1 [open [info script]]
d6384 1
a6384 1
test io-30.2 {CopyData} {
d6386 1
a6386 1
    set f1 [open [info script]]
d6395 1
a6395 1
    set s1 [file size [info script]]
d6402 1
a6402 1
test io-30.3 {CopyData: background read underflow} {unixOnly} {
d6417 1
a6417 1
    set f1 [open "|[list $tcltest pipe]" r+]
d6432 2
a6433 2
test io-30.4 {CopyData: background write overflow} {unixOnly} {
    set big aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n
d6450 1
a6450 1
    set f1 [open "|[list $tcltest pipe]" r+]
d6468 1
d6481 16
a6496 18
if [catch {socket -server FcopyTestAccept 2828} listen] {
    puts stderr "Skipping fcopy error test"
} else {
    test io-30.5 {CopyData: error during fcopy} {
	set in [open [info script]]	;# 126 K
	set out [socket localhost 2828]
	catch {unset fcopyTestDone}
	close $listen	;# This means the socket open never really succeeds
	fcopy $in $out -command FcopyTestDone
	if ![info exists fcopyTestDone] {
	    vwait fcopyTestDone		;# The error occurs here in the b.g.
	}
	close $in
	close $out
	set fcopyTestDone	;# 1 for error condition
    } 1
}
test io-30.6 {CopyData: error during fcopy} {stdio} {
d6503 1
a6503 1
    set in [open "|[list $tcltest pipe]" r+]
d6514 1
a6514 1
test io-31.1 {Recursive channel events} {socket} {
d6566 3
a6568 1
test io-31.2 {Testing for busy-wait in recursive channel events} {socket} {
d6571 1
a6571 1
	global counter
d6573 1
d6579 1
a6579 1
	global counter
d6585 1
a6585 1
	    after 1000 newline
d6589 1
a6589 1
	global counter
d6594 1
d6599 1
a6599 1
	set writer [socket localhost 3939]
d6615 2
d6619 2
a6620 1
test io-32.1 {ChannelEventScriptInvoker: deletion} {
d6636 1
a6636 1
test io-33.1 {ChannelTimerProc} {
d6656 1
a6656 1
test io-34.1 {buffered data and file events, gets} {
d6661 1
a6661 1
    set s [socket localhost 4040]
d6677 1
a6677 1
test io-34.2 {buffered data and file events, read} {
d6682 1
a6682 1
    set s [socket localhost 4041]
d6699 1
a6699 1
test io-35.1 {Tcl_NotifyChannel and error when closing} {unixOrPc} {
d6717 1
a6717 1
    set pipe [open "|[list $tcltest] script" r]
d6725 19
a6744 11
removeFile fooBar
removeFile longfile
removeFile script
removeFile output
removeFile test1
removeFile pipe
removeFile my_script
removeFile foo
removeFile bar
removeFile test2
removeFile test3
a6745 1
file delete cat
a6746 2
set x ""
unset x
@


1.1.1.1
log
@import dejagnu-1999-11-08 snapshot
@
text
@@


1.1.1.2
log
@Tcl 8.3 upgrade
@
text
@a9 1
# Copyright (c) 1998-1999 by Scriptics Corporation.
d14 1
a14 1
# RCS: @@(#) $Id: io.test,v 1.6.8.2 2000/09/15 16:56:45 spolk Exp $
d16 1
a16 1337
if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import -force ::tcltest::*
}

if {"[info commands testchannel]" != "testchannel"} {
    puts "Skipping io tests. This application does not seem to have the"
    puts "testchannel command that is needed to run these tests."
    return
}

::tcltest::saveState

removeFile test1
removeFile pipe

catch {unset u}

# set up a long data file for some of the following tests

set f [open longfile w]
fconfigure $f -eofchar {} -translation lf
for { set i 0 } { $i < 100 } { incr i} {
    puts $f "#123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef
\#123456789abcdef01
\#"
    }
close $f

makeFile {
    set f stdin
    if {$argv != ""} {
	set f [open $argv]
    }
    fconfigure $f -encoding binary -translation lf -blocking 0 -eofchar \x1a
    fconfigure stdout -encoding binary -translation lf -buffering none
    fileevent $f readable "foo $f"
    proc foo {f} {
	set x [read $f]
	catch {puts -nonewline $x}
	if {[eof $f]} {
	    close $f
	    exit 0
	}
    }
    vwait forever
} cat

set thisScript [file join [pwd] [info script]]

proc contents {file} {
    set f [open $file]
    fconfigure $f -translation binary
    set a [read $f]
    close $f
    return $a
}

test io-1.5 {Tcl_WriteChars: CheckChannelErrors} {emptyTest} {
    # no test, need to cause an async error.
} {}
test io-1.6 {Tcl_WriteChars: WriteBytes} {
    set f [open test1 w]
    fconfigure $f -encoding binary
    puts -nonewline $f "a\u4e4d\0"
    close $f
    contents test1
} "a\x4d\x00"
test io-1.7 {Tcl_WriteChars: WriteChars} {
    set f [open test1 w]
    fconfigure $f -encoding shiftjis
    puts -nonewline $f "a\u4e4d\0"
    close $f
    contents test1
} "a\x93\xe1\x00"

test io-2.1 {WriteBytes} {
    # loop until all bytes are written
    
    set f [open test1 w]
    fconfigure $f  -encoding binary -buffersize 16 -translation crlf
    puts $f "abcdefghijklmnopqrstuvwxyz"
    close $f
    contents test1
} "abcdefghijklmnopqrstuvwxyz\r\n"
test io-2.2 {WriteBytes: savedLF > 0} {
    # After flushing buffer, there was a \n left over from the last
    # \n -> \r\n expansion.  It gets stuck at beginning of this buffer.

    set f [open test1 w]
    fconfigure $f -encoding binary -buffersize 16 -translation crlf
    puts -nonewline $f "123456789012345\n12"
    set x [list [contents test1]]
    close $f
    lappend x [contents test1]
} [list "123456789012345\r" "123456789012345\r\n12"]
test io-2.3 {WriteBytes: flush on line} {
    # Tcl "line" buffering has weird behavior: if current buffer contains
    # a \n, entire buffer gets flushed.  Logical behavior would be to flush
    # only up to the \n.
    
    set f [open test1 w]
    fconfigure $f -encoding binary -buffering line -translation crlf
    puts -nonewline $f "\n12"
    set x [contents test1]
    close $f
    set x
} "\r\n12"
test io-2.4 {WriteBytes: reset sawLF after each buffer} {
    set f [open test1 w]
     fconfigure $f -encoding binary -buffering line -translation lf \
	     -buffersize 16
    puts -nonewline $f "abcdefg\nhijklmnopqrstuvwxyz"
    set x [list [contents test1]]
    close $f
    lappend x [contents test1]
} [list "abcdefg\nhijklmno" "abcdefg\nhijklmnopqrstuvwxyz"]

test io-3.1 {WriteChars: compatibility with WriteBytes} {
    # loop until all bytes are written
    
    set f [open test1 w]
    fconfigure $f -encoding ascii -buffersize 16 -translation crlf
    puts $f "abcdefghijklmnopqrstuvwxyz"
    close $f
    contents test1
} "abcdefghijklmnopqrstuvwxyz\r\n"
test io-3.2 {WriteChars: compatibility with WriteBytes: savedLF > 0} {
    # After flushing buffer, there was a \n left over from the last
    # \n -> \r\n expansion.  It gets stuck at beginning of this buffer.

    set f [open test1 w]
    fconfigure $f -encoding ascii -buffersize 16 -translation crlf
    puts -nonewline $f "123456789012345\n12"
    set x [list [contents test1]]
    close $f
    lappend x [contents test1]
} [list "123456789012345\r" "123456789012345\r\n12"]
test io-3.3 {WriteChars: compatibility with WriteBytes: flush on line} {
    # Tcl "line" buffering has weird behavior: if current buffer contains
    # a \n, entire buffer gets flushed.  Logical behavior would be to flush
    # only up to the \n.
    
    set f [open test1 w]
    fconfigure $f -encoding ascii -buffering line -translation crlf
    puts -nonewline $f "\n12"
    set x [contents test1]
    close $f
    set x
} "\r\n12"
test io-3.4 {WriteChars: loop over stage buffer} {
    # stage buffer maps to more than can be queued at once.

    set f [open test1 w]
    fconfigure $f -encoding jis0208 -buffersize 16 
    puts -nonewline $f "\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"
    set x [list [contents test1]]
    close $f
    lappend x [contents test1]
} [list "!)!)!)!)!)!)!)!)" "!)!)!)!)!)!)!)!)!)!)!)!)!)!)!)"]
test io-3.5 {WriteChars: saved != 0} {
    # Bytes produced by UtfToExternal from end of last channel buffer
    # had to be moved to beginning of next channel buffer to preserve
    # requested buffersize.

    set f [open test1 w]
    fconfigure $f -encoding jis0208 -buffersize 17 
    puts -nonewline $f "\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"
    set x [list [contents test1]]
    close $f
    lappend x [contents test1]
} [list "!)!)!)!)!)!)!)!)!" "!)!)!)!)!)!)!)!)!)!)!)!)!)!)!)"]
test io-3.6 {WriteChars: (stageRead + dstWrote == 0)} {
    # One incomplete UTF-8 character at end of staging buffer.  Backup
    # in src to the beginning of that UTF-8 character and try again.
    #
    # Translate the first 16 bytes, produce 14 bytes of output, 2 left over
    # (first two bytes of \uff21 in UTF-8).  Given those two bytes try
    # translating them again, find that no bytes are read produced, and break
    # to outer loop where those two bytes will have the remaining 4 bytes
    # (the last byte of \uff21 plus the all of \uff22) appended.

    set f [open test1 w]
    fconfigure $f -encoding shiftjis -buffersize 16
    puts -nonewline $f "12345678901234\uff21\uff22"
    set x [list [contents test1]]
    close $f
    lappend x [contents test1]
} [list "12345678901234\x82\x60" "12345678901234\x82\x60\x82\x61"]
test io-3.7 {WriteChars: (bufPtr->nextAdded > bufPtr->length)} {
    # When translating UTF-8 to external, the produced bytes went past end
    # of the channel buffer.  This is done purpose -- we then truncate the
    # bytes at the end of the partial character to preserve the requested
    # blocksize on flush.  The truncated bytes are moved to the beginning
    # of the next channel buffer.

    set f [open test1 w]
    fconfigure $f -encoding jis0208 -buffersize 17 
    puts -nonewline $f "\\\\\\\\\\\\\\\\\\\\\\\\\\\\\\"
    set x [list [contents test1]]
    close $f
    lappend x [contents test1]
} [list "!)!)!)!)!)!)!)!)!" "!)!)!)!)!)!)!)!)!)!)!)!)!)!)!)"]
test io-3.8 {WriteChars: reset sawLF after each buffer} {
    set f [open test1 w]
    fconfigure $f -encoding ascii -buffering line -translation lf \
	     -buffersize 16
    puts -nonewline $f "abcdefg\nhijklmnopqrstuvwxyz"
    set x [list [contents test1]]
    close $f
    lappend x [contents test1]
} [list "abcdefg\nhijklmno" "abcdefg\nhijklmnopqrstuvwxyz"]

test io-4.1 {TranslateOutputEOL: lf} {
    # search for \n

    set f [open test1 w]
    fconfigure $f -buffering line -translation lf
    puts $f "abcde"
    set x [list [contents test1]]
    close $f
    lappend x [contents test1]
} [list "abcde\n" "abcde\n"]
test io-4.2 {TranslateOutputEOL: cr} {
    # search for \n, replace with \r

    set f [open test1 w]
    fconfigure $f -buffering line -translation cr
    puts $f "abcde"
    set x [list [contents test1]]
    close $f
    lappend x [contents test1]
} [list "abcde\r" "abcde\r"]
test io-4.3 {TranslateOutputEOL: crlf} {
    # simple case: search for \n, replace with \r

    set f [open test1 w]
    fconfigure $f -buffering line -translation crlf
    puts $f "abcde"
    set x [list [contents test1]]
    close $f
    lappend x [contents test1]
} [list "abcde\r\n" "abcde\r\n"]
test io-4.4 {TranslateOutputEOL: crlf} {
    # keep storing more bytes in output buffer until output buffer is full.
    # We have 13 bytes initially that would turn into 18 bytes.  Fill
    # dest buffer while (dstEnd < dstMax).

    set f [open test1 w]
    fconfigure $f -translation crlf -buffersize 16
    puts -nonewline $f "1234567\n\n\n\n\nA"
    set x [list [contents test1]]
    close $f
    lappend x [contents test1]
} [list "1234567\r\n\r\n\r\n\r\n\r" "1234567\r\n\r\n\r\n\r\n\r\nA"]
test io-4.5 {TranslateOutputEOL: crlf} {
    # Check for overflow of the destination buffer

    set f [open test1 w]
    fconfigure $f -translation crlf -buffersize 12
    puts -nonewline $f "12345678901\n456789012345678901234"
    close $f
    set x [contents test1]
} "12345678901\r\n456789012345678901234"

test io-5.1 {CheckFlush: not full} {
    set f [open test1 w]
    fconfigure $f 
    puts -nonewline $f "12345678901234567890"
    set x [list [contents test1]]
    close $f
    lappend x [contents test1]
} [list "" "12345678901234567890"]
test io-5.2 {CheckFlush: full} {
    set f [open test1 w]
    fconfigure $f -buffersize 16
    puts -nonewline $f "12345678901234567890"
    set x [list [contents test1]]
    close $f
    lappend x [contents test1]
} [list "1234567890123456" "12345678901234567890"]
test io-5.3 {CheckFlush: not line} {
    set f [open test1 w]
    fconfigure $f -buffering line
    puts -nonewline $f "12345678901234567890"
    set x [list [contents test1]]
    close $f
    lappend x [contents test1]
} [list "" "12345678901234567890"]
test io-5.4 {CheckFlush: line} {
    set f [open test1 w]
    fconfigure $f -buffering line -translation lf -encoding ascii
    puts -nonewline $f "1234567890\n1234567890"
    set x [list [contents test1]]
    close $f
    lappend x [contents test1]
} [list "1234567890\n1234567890" "1234567890\n1234567890"]
test io-5.5 {CheckFlush: none} {
    set f [open test1 w]
    fconfigure $f -buffering none
    puts -nonewline $f "1234567890"
    set x [list [contents test1]]
    close $f
    lappend x [contents test1]
} [list "1234567890" "1234567890"]

test io-6.1 {Tcl_GetsObj: working} {
    set f [open test1 w]
    puts $f "foo\nboo"
    close $f
    set f [open test1]
    set x [gets $f]
    close $f
    set x
} {foo}
test io-6.2 {Tcl_GetsObj: CheckChannelErrors() != 0} {
    # no test, need to cause an async error.
} {}
test io-6.3 {Tcl_GetsObj: how many have we used?} {
    # if (bufPtr != NULL) {oldRemoved = bufPtr->nextRemoved}

    set f [open test1 w]
    fconfigure $f -translation crlf
    puts $f "abc\ndefg"
    close $f
    set f [open test1]
    set x [list [tell $f] [gets $f line] [tell $f] [gets $f line] $line]
    close $f
    set x
} {0 3 5 4 defg}
test io-6.4 {Tcl_GetsObj: encoding == NULL} {
    set f [open test1 w]
    fconfigure $f -translation binary
    puts $f "\x81\u1234\0"
    close $f
    set f [open test1]
    fconfigure $f -translation binary
    set x [list [gets $f line] $line]
    close $f
    set x
} [list 3 "\x81\x34\x00"]
test io-6.5 {Tcl_GetsObj: encoding != NULL} {
    set f [open test1 w]
    fconfigure $f -translation binary
    puts $f "\x88\xea\x92\x9a"
    close $f
    set f [open test1]
    fconfigure $f -encoding shiftjis
    set x [list [gets $f line] $line]
    close $f
    set x
} [list 2 "\u4e00\u4e01"]
set a "bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb"
append a $a
append a $a
test io-6.6 {Tcl_GetsObj: loop test} {
    # if (dst >= dstEnd) 

    set f [open test1 w]
    puts $f $a
    puts $f hi
    close $f
    set f [open test1]
    set x [list [gets $f line] $line]
    close $f
    set x
} [list 256 $a]
test io-6.7 {Tcl_GetsObj: error in input} {stdio} {
    # if (FilterInputBytes(chanPtr, &gs) != 0)

    set f [open "|[list $::tcltest::tcltest cat]" w+]
    puts -nonewline $f "hi\nwould"
    flush $f
    gets $f
    fconfigure $f -blocking 0
    set x [gets $f line]
    close $f
    set x
} {-1}
test io-6.8 {Tcl_GetsObj: remember if EOF is seen} {
    set f [open test1 w]
    puts $f "abcdef\x1aghijk\nwombat"
    close $f
    set f [open test1]
    fconfigure $f -eofchar \x1a
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} {6 abcdef -1 {}}
test io-6.9 {Tcl_GetsObj: remember if EOF is seen} {
    set f [open test1 w]
    puts $f "abcdefghijk\nwom\u001abat"
    close $f
    set f [open test1]
    fconfigure $f -eofchar \x1a
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} {11 abcdefghijk 3 wom}

# Comprehensive tests

test io-6.10 {Tcl_GetsObj: lf mode: no chars} {
    set f [open test1 w]
    close $f
    set f [open test1]
    fconfigure $f -translation lf
    set x [list [gets $f line] $line]
    close $f
    set x
} {-1 {}}
test io-6.11 {Tcl_GetsObj: lf mode: lone \n} {
    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f "\n"
    close $f
    set f [open test1]
    fconfigure $f -translation lf
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} {0 {} -1 {}}
test io-6.12 {Tcl_GetsObj: lf mode: lone \r} {
    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f "\r"
    close $f
    set f [open test1]
    fconfigure $f -translation lf
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} [list 1 "\r" -1 ""]
test io-6.13 {Tcl_GetsObj: lf mode: 1 char} {
    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f a
    close $f
    set f [open test1]
    fconfigure $f -translation lf
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} {1 a -1 {}}
test io-6.14 {Tcl_GetsObj: lf mode: 1 char followed by EOL} {
    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f "a\n"
    close $f
    set f [open test1]
    fconfigure $f -translation lf
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} {1 a -1 {}}
test io-6.15 {Tcl_GetsObj: lf mode: several chars} {
    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f "abcd\nefgh\rijkl\r\nmnop"
    close $f
    set f [open test1]
    fconfigure $f -translation lf
    set x [list [gets $f line] $line [gets $f line] $line [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} [list 4 "abcd" 10 "efgh\rijkl\r" 4 "mnop" -1 ""]
test io-6.16 {Tcl_GetsObj: cr mode: no chars} {
    set f [open test1 w]
    close $f
    set f [open test1]
    fconfigure $f -translation cr
    set x [list [gets $f line] $line]
    close $f
    set x
} {-1 {}}
test io-6.17 {Tcl_GetsObj: cr mode: lone \n} {
    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f "\n"
    close $f
    set f [open test1]
    fconfigure $f -translation cr
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} [list 1 "\n" -1 ""]
test io-6.18 {Tcl_GetsObj: cr mode: lone \r} {
    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f "\r"
    close $f
    set f [open test1]
    fconfigure $f -translation cr
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} {0 {} -1 {}}
test io-6.19 {Tcl_GetsObj: cr mode: 1 char} {
    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f a
    close $f
    set f [open test1]
    fconfigure $f -translation cr
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} {1 a -1 {}}
test io-6.20 {Tcl_GetsObj: cr mode: 1 char followed by EOL} {
    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f "a\r"
    close $f
    set f [open test1]
    fconfigure $f -translation cr
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} {1 a -1 {}}
test io-6.21 {Tcl_GetsObj: cr mode: several chars} {
    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f "abcd\nefgh\rijkl\r\nmnop"
    close $f
    set f [open test1]
    fconfigure $f -translation cr
    set x [list [gets $f line] $line [gets $f line] $line [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} [list 9 "abcd\nefgh" 4 "ijkl" 5 "\nmnop" -1 ""]
test io-6.22 {Tcl_GetsObj: crlf mode: no chars} {
    set f [open test1 w]
    close $f
    set f [open test1]
    fconfigure $f -translation crlf
    set x [list [gets $f line] $line]
    close $f
    set x
} {-1 {}}
test io-6.23 {Tcl_GetsObj: crlf mode: lone \n} {
    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f "\n"
    close $f
    set f [open test1]
    fconfigure $f -translation crlf
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} [list 1 "\n" -1 ""]
test io-6.24 {Tcl_GetsObj: crlf mode: lone \r} {
    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f "\r"
    close $f
    set f [open test1]
    fconfigure $f -translation crlf
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} [list 1 "\r" -1 ""]
test io-6.25 {Tcl_GetsObj: crlf mode: \r\r} {
    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f "\r\r"
    close $f
    set f [open test1]
    fconfigure $f -translation crlf
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} [list 2 "\r\r" -1 ""]
test io-6.26 {Tcl_GetsObj: crlf mode: \r\n} {
    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f "\r\n"
    close $f
    set f [open test1]
    fconfigure $f -translation crlf
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} [list 0 "" -1 ""]
test io-6.27 {Tcl_GetsObj: crlf mode: 1 char} {
    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f a
    close $f
    set f [open test1]
    fconfigure $f -translation crlf
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} {1 a -1 {}}
test io-6.28 {Tcl_GetsObj: crlf mode: 1 char followed by EOL} {
    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f "a\r\n"
    close $f
    set f [open test1]
    fconfigure $f -translation crlf
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} {1 a -1 {}}
test io-6.29 {Tcl_GetsObj: crlf mode: several chars} {
    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f "abcd\nefgh\rijkl\r\nmnop"
    close $f
    set f [open test1]
    fconfigure $f -translation crlf
    set x [list [gets $f line] $line [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} [list 14 "abcd\nefgh\rijkl" 4 "mnop" -1 ""]
test io-6.30 {Tcl_GetsObj: crlf mode: buffer exhausted} {
    # if (eol >= dstEnd)

    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f "123456789012345\r\nabcdefghijklmnoprstuvwxyz"
    close $f
    set f [open test1]
    fconfigure $f -translation crlf -buffersize 16
    set x [list [gets $f line] $line [testchannel inputbuffered $f]]
    close $f
    set x
} [list 15 "123456789012345" 15]
test io-6.31 {Tcl_GetsObj: crlf mode: buffer exhausted, blocked} {stdio} {
    # (FilterInputBytes() != 0)

    set f [open "|[list $::tcltest::tcltest cat]" w+]
    fconfigure $f -translation {crlf lf} -buffering none
    puts -nonewline $f "bbbbbbbbbbbbbb\r\n123456789012345\r"
    fconfigure $f -buffersize 16
    set x [gets $f]
    fconfigure $f -blocking 0
    lappend x [gets $f line] $line [fblocked $f] [testchannel inputbuffered $f]
    close $f
    set x
} [list "bbbbbbbbbbbbbb" -1 "" 1 16]
test io-6.32 {Tcl_GetsObj: crlf mode: buffer exhausted, more data} {
    # not (FilterInputBytes() != 0)

    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f "123456789012345\r\n123"
    close $f
    set f [open test1]
    fconfigure $f -translation crlf -buffersize 16
    set x [list [gets $f line] $line [tell $f] [testchannel inputbuffered $f]]
    close $f
    set x
} [list 15 "123456789012345" 17 3]
test io-6.33 {Tcl_GetsObj: crlf mode: buffer exhausted, at eof} {
    # eol still equals dstEnd
    
    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f "123456789012345\r"
    close $f
    set f [open test1]
    fconfigure $f -translation crlf -buffersize 16
    set x [list [gets $f line] $line [eof $f]]
    close $f
    set x
} [list 16 "123456789012345\r" 1]
test io-6.34 {Tcl_GetsObj: crlf mode: buffer exhausted, not followed by \n} {
    # not (*eol == '\n') 
    
    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f "123456789012345\rabcd\r\nefg"
    close $f
    set f [open test1]
    fconfigure $f -translation crlf -buffersize 16
    set x [list [gets $f line] $line [tell $f]]
    close $f
    set x
} [list 20 "123456789012345\rabcd" 22]
test io-6.35 {Tcl_GetsObj: auto mode: no chars} {
    set f [open test1 w]
    close $f
    set f [open test1]
    fconfigure $f -translation auto
    set x [list [gets $f line] $line]
    close $f
    set x
} {-1 {}}
test io-6.36 {Tcl_GetsObj: auto mode: lone \n} {
    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f "\n"
    close $f
    set f [open test1]
    fconfigure $f -translation auto
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} [list 0 "" -1 ""]
test io-6.37 {Tcl_GetsObj: auto mode: lone \r} {
    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f "\r"
    close $f
    set f [open test1]
    fconfigure $f -translation auto
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} [list 0 "" -1 ""]
test io-6.38 {Tcl_GetsObj: auto mode: \r\r} {
    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f "\r\r"
    close $f
    set f [open test1]
    fconfigure $f -translation auto
    set x [list [gets $f line] $line [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} [list 0 "" 0 "" -1 ""]
test io-6.39 {Tcl_GetsObj: auto mode: \r\n} {
    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f "\r\n"
    close $f
    set f [open test1]
    fconfigure $f -translation auto
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} [list 0 "" -1 ""]
test io-6.40 {Tcl_GetsObj: auto mode: 1 char} {
    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f a
    close $f
    set f [open test1]
    fconfigure $f -translation auto
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} {1 a -1 {}}
test io-6.41 {Tcl_GetsObj: auto mode: 1 char followed by EOL} {
    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f "a\r\n"
    close $f
    set f [open test1]
    fconfigure $f -translation auto
    set x [list [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} {1 a -1 {}}
test io-6.42 {Tcl_GetsObj: auto mode: several chars} {
    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f "abcd\nefgh\rijkl\r\nmnop"
    close $f
    set f [open test1]
    fconfigure $f -translation auto
    set x [list [gets $f line] $line [gets $f line] $line]
    lappend x [gets $f line] $line [gets $f line] $line [gets $f line] $line
    close $f
    set x
} [list 4 "abcd" 4 "efgh" 4 "ijkl" 4 "mnop" -1 ""]
test io-6.43 {Tcl_GetsObj: input saw cr} {stdio} {
    # if (chanPtr->flags & INPUT_SAW_CR)

    set f [open "|[list $::tcltest::tcltest cat]" w+]
    fconfigure $f -translation {auto lf} -buffering none
    puts -nonewline $f "bbbbbbbbbbbbbbb\n123456789abcdef\r"
    fconfigure $f -buffersize 16
    set x [list [gets $f]]
    fconfigure $f -blocking 0
    lappend x [gets $f line] $line [testchannel queuedcr $f] 
    fconfigure $f -blocking 1
    puts -nonewline $f "\nabcd\refg\x1a"
    lappend x [gets $f line] $line [testchannel queuedcr $f]
    lappend x [gets $f line] $line
    close $f
    set x
} [list "bbbbbbbbbbbbbbb" 15 "123456789abcdef" 1 4 "abcd" 0 3 "efg"]
test io-6.44 {Tcl_GetsObj: input saw cr, not followed by cr} {stdio} {
    # not (*eol == '\n') 

    set f [open "|[list $::tcltest::tcltest cat]" w+]
    fconfigure $f -translation {auto lf} -buffering none
    puts -nonewline $f "bbbbbbbbbbbbbbb\n123456789abcdef\r"
    fconfigure $f -buffersize 16
    set x [list [gets $f]]
    fconfigure $f -blocking 0
    lappend x [gets $f line] $line [testchannel queuedcr $f] 
    fconfigure $f -blocking 1
    puts -nonewline $f "abcd\refg\x1a"
    lappend x [gets $f line] $line [testchannel queuedcr $f]
    lappend x [gets $f line] $line
    close $f
    set x
} [list "bbbbbbbbbbbbbbb" 15 "123456789abcdef" 1 4 "abcd" 0 3 "efg"]
test io-6.45 {Tcl_GetsObj: input saw cr, skip right number of bytes} {stdio} {
    # Tcl_ExternalToUtf()

    set f [open "|[list $::tcltest::tcltest cat]" w+]
    fconfigure $f -translation {auto lf} -buffering none
    fconfigure $f -encoding unicode
    puts -nonewline $f "bbbbbbbbbbbbbbb\n123456789abcdef\r"
    fconfigure $f -buffersize 16
    gets $f
    fconfigure $f -blocking 0
    set x [list [gets $f line] $line [testchannel queuedcr $f]]
    fconfigure $f -blocking 1
    puts -nonewline $f "\nabcd\refg"
    lappend x [gets $f line] $line [testchannel queuedcr $f]
    close $f
    set x
} [list 15 "123456789abcdef" 1 4 "abcd" 0]
test io-6.46 {Tcl_GetsObj: input saw cr, followed by just \n should give eof} {stdio} {
    # memmove()

    set f [open "|[list $::tcltest::tcltest cat]" w+]
    fconfigure $f -translation {auto lf} -buffering none
    puts -nonewline $f "bbbbbbbbbbbbbbb\n123456789abcdef\r"
    fconfigure $f -buffersize 16
    gets $f
    fconfigure $f -blocking 0
    set x [list [gets $f line] $line [testchannel queuedcr $f]]
    fconfigure $f -blocking 1
    puts -nonewline $f "\n\x1a"
    lappend x [gets $f line] $line [testchannel queuedcr $f]
    close $f
    set x
} [list 15 "123456789abcdef" 1 -1 "" 0]
test io-6.47 {Tcl_GetsObj: auto mode: \r at end of buffer, peek for \n} {
    # (eol == dstEnd)

    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f "123456789012345\r\nabcdefghijklmnopq"
    close $f
    set f [open test1]
    fconfigure $f -translation auto -buffersize 16
    set x [list [gets $f] [testchannel inputbuffered $f]]
    close $f
    set x
} [list "123456789012345" 15]    
test io-6.48 {Tcl_GetsObj: auto mode: \r at end of buffer, no more avail} {
    # PeekAhead() did not get any, so (eol >= dstEnd)
    
    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f "123456789012345\r"
    close $f
    set f [open test1]
    fconfigure $f -translation auto -buffersize 16
    set x [list [gets $f] [testchannel queuedcr $f]]
    close $f
    set x
} [list "123456789012345" 1]
test io-6.49 {Tcl_GetsObj: auto mode: \r followed by \n} {
    # if (*eol == '\n') {skip++}
    
    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f "123456\r\n78901"
    close $f
    set f [open test1]
    set x [list [gets $f] [testchannel queuedcr $f] [tell $f] [gets $f]]
    close $f
    set x
} [list "123456" 0 8 "78901"]
test io-6.50 {Tcl_GetsObj: auto mode: \r not followed by \n} {
    # not (*eol == '\n') 
    
    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f "123456\r78901"
    close $f
    set f [open test1]
    set x [list [gets $f] [testchannel queuedcr $f] [tell $f] [gets $f]]
    close $f
    set x
} [list "123456" 0 7 "78901"]
test io-6.51 {Tcl_GetsObj: auto mode: \n} {
    # else if (*eol == '\n') {goto gotoeol;}
    
    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f "123456\n78901"
    close $f
    set f [open test1]
    set x [list [gets $f] [tell $f] [gets $f]]
    close $f
    set x
} [list "123456" 7 "78901"]
test io-6.52 {Tcl_GetsObj: saw EOF character} {
    # if (eof != NULL)

    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f "123456\x1ak9012345\r"
    close $f
    set f [open test1]
    fconfigure $f -eofchar \x1a
    set x [list [gets $f] [testchannel queuedcr $f] [tell $f] [gets $f]]
    close $f
    set x
} [list "123456" 0 6 ""]
test io-6.53 {Tcl_GetsObj: device EOF} {
    # didn't produce any bytes

    set f [open test1 w]
    close $f
    set f [open test1]
    set x [list [gets $f line] $line [eof $f]]
    close $f
    set x
} {-1 {} 1}
test io-6.54 {Tcl_GetsObj: device EOF} {
    # got some bytes before EOF.

    set f [open test1 w]
    puts -nonewline $f abc
    close $f
    set f [open test1]
    set x [list [gets $f line] $line [eof $f]]
    close $f
    set x
} {3 abc 1}
test io-6.55 {Tcl_GetsObj: overconverted} {
    # Tcl_ExternalToUtf(), make sure state updated

    set f [open test1 w]
    fconfigure $f -encoding iso2022-jp
    puts $f "there\u4e00ok\n\u4e01more bytes\nhere"
    close $f
    set f [open test1]
    fconfigure $f -encoding iso2022-jp
    set x [list [gets $f line] $line [gets $f line] $line [gets $f line] $line]
    close $f
    set x
} [list 8 "there\u4e00ok" 11 "\u4e01more bytes" 4 "here"]
test io-6.56 {Tcl_GetsObj: incomplete lines should disable file events} {stdio} {
    update
    set f [open "|[list $::tcltest::tcltest cat]" w+]
    fconfigure $f -buffering none
    puts -nonewline $f "foobar"
    fconfigure $f -blocking 0
    set x {}
    after 500 { lappend x timeout }
    fileevent $f readable { lappend x [gets $f] }
    vwait x
    vwait x
    fconfigure $f -blocking 1
    puts -nonewline $f "baz\n"
    after 500 { lappend x timeout }
    fconfigure $f -blocking 0
    vwait x
    vwait x
    close $f
    set x
} {{} timeout foobarbaz timeout}

test io-7.1 {FilterInputBytes: split up character at end of buffer} {
    # (result == TCL_CONVERT_MULTIBYTE)

    set f [open test1 w]
    fconfigure $f -encoding shiftjis
    puts $f "1234567890123\uff10\uff11\uff12\uff13\uff14\nend"
    close $f
    set f [open test1]
    fconfigure $f -encoding shiftjis -buffersize 16
    set x [gets $f]
    close $f
    set x
} "1234567890123\uff10\uff11\uff12\uff13\uff14"
test io-7.2 {FilterInputBytes: split up character in middle of buffer} {
    # (bufPtr->nextAdded < bufPtr->bufLength)
    
    set f [open test1 w]
    fconfigure $f -encoding binary
    puts -nonewline $f "1234567890\n123\x82\x4f\x82\x50\x82"
    close $f
    set f [open test1]
    fconfigure $f -encoding shiftjis
    set x [list [gets $f line] $line [eof $f]]
    close $f
    set x
} [list 10 "1234567890" 0]
test io-7.3 {FilterInputBytes: split up character at EOF} {
    set f [open test1 w]
    fconfigure $f -encoding binary
    puts -nonewline $f "1234567890123\x82\x4f\x82\x50\x82"
    close $f
    set f [open test1]
    fconfigure $f -encoding shiftjis
    set x [list [gets $f line] $line]
    lappend x [tell $f] [testchannel inputbuffered $f] [eof $f]
    lappend x [gets $f line] $line
    close $f
    set x
} [list 15 "1234567890123\uff10\uff11" 18 0 1 -1 ""]
test io-7.4 {FilterInputBytes: recover from split up character} {stdio} {
    set f [open "|[list $::tcltest::tcltest cat]" w+]
    fconfigure $f -encoding binary -buffering none
    puts -nonewline $f "1234567890123\x82\x4f\x82\x50\x82"
    fconfigure $f -encoding shiftjis -blocking 0
    fileevent $f read "ready $f"
    set x {}
    proc ready {f} {
	lappend ::x [gets $f line] $line [fblocked $f]
    }
    vwait x
    fconfigure $f -encoding binary -blocking 1
    puts $f "\x51\x82\x52"
    fconfigure $f -encoding shiftjis
    vwait x
    close $f
    set x
} [list -1 "" 1 17 "1234567890123\uff10\uff11\uff12\uff13" 0]

test io-8.1 {PeekAhead: only go to device if no more cached data} {
    # (bufPtr->nextPtr == NULL)

    set f [open "test1" w]
    fconfigure $f -encoding ascii -translation lf
    puts -nonewline $f "123456789012345\r\n2345678"
    close $f
    set f [open "test1"]
    fconfigure $f -encoding ascii -translation auto -buffersize 16
    # here
    gets $f
    set x [testchannel inputbuffered $f]
    close $f
    set x
} "7"
test io-8.2 {PeekAhead: only go to device if no more cached data} {stdio} {
    # not (bufPtr->nextPtr == NULL)

    set f [open "|[list $::tcltest::tcltest cat]" w+]
    fconfigure $f -translation lf -encoding ascii -buffering none
    puts -nonewline $f "123456789012345\r\nbcdefghijklmnopqrstuvwxyz"
    set x {}
    fileevent $f read "ready $f"
    proc ready {f} {
	lappend ::x [gets $f line] $line [testchannel inputbuffered $f]
    }
    fconfigure $f -encoding unicode -buffersize 16 -blocking 0
    vwait x
    fconfigure $f -translation auto -encoding ascii -blocking 1
    # here
    vwait x
    close $f
    set x
} [list -1 "" 42 15 "123456789012345" 25]
test io-8.3 {PeekAhead: no cached data available} {stdio} {
    # (bytesLeft == 0)

    set f [open "|[list $::tcltest::tcltest cat]" w+]
    fconfigure $f -translation {auto binary}
    puts -nonewline $f "abcdefghijklmno\r"
    flush $f
    set x [list [gets $f line] $line [testchannel queuedcr $f]]
    close $f
    set x
} [list 15 "abcdefghijklmno" 1]
set a "123456789012345678901234567890"
append a "123456789012345678901234567890"
append a "1234567890123456789012345678901"
test io-8.4 {PeekAhead: cached data available in this buffer} {
    # not (bytesLeft == 0)

    set f [open test1 w+]
    fconfigure $f -translation binary
    puts $f "${a}\r\nabcdef"
    close $f
    set f [open test1]
    fconfigure $f -encoding binary -translation auto

    # "${a}\r" was converted in one operation (because ENCODING_LINESIZE
    # is 30).  To check if "\n" follows, calls PeekAhead and determines
    # that cached data is available in buffer w/o having to call driver.

    set x [gets $f]
    close $f
    set x    
} $a
unset a
test io-8.5 {PeekAhead: don't peek if last read was short} {stdio} {
    # (bufPtr->nextAdded < bufPtr->length)

    set f [open "|[list $::tcltest::tcltest cat]" w+]
    fconfigure $f -translation {auto binary}
    puts -nonewline $f "abcdefghijklmno\r"
    flush $f
    # here
    set x [list [gets $f line] $line [testchannel queuedcr $f]]
    close $f
    set x
} {15 abcdefghijklmno 1}
test io-8.6 {PeekAhead: change to non-blocking mode} {stdio} {
    # ((chanPtr->flags & CHANNEL_NONBLOCKING) == 0) 

    set f [open "|[list $::tcltest::tcltest cat]" w+]
    fconfigure $f -translation {auto binary} -buffersize 16
    puts -nonewline $f "abcdefghijklmno\r"
    flush $f
    # here
    set x [list [gets $f line] $line [testchannel queuedcr $f]]
    close $f
    set x
} {15 abcdefghijklmno 1}
test io-8.7 {PeekAhead: cleanup} {stdio} {
    # Make sure bytes are removed from buffer.

    set f [open "|[list $::tcltest::tcltest cat]" w+]
    fconfigure $f -translation {auto binary} -buffering none
    puts -nonewline $f "abcdefghijklmno\r"
    # here
    set x [list [gets $f line] $line [testchannel queuedcr $f]]
    puts -nonewline $f "\x1a"
    lappend x [gets $f line] $line
    close $f
    set x
} {15 abcdefghijklmno 1 -1 {}}
    

test io-9.1 {CommonGetsCleanup} {
} {}

test io-10.1 {Tcl_ReadChars: CheckChannelErrors} {
    # no test, need to cause an async error.
} {}
test io-10.2 {Tcl_ReadChars: loop until enough copied} {
    # one time
    # for (copied = 0; (unsigned) toRead > 0; )

    set f [open "test1" w]
    puts $f abcdefghijklmnop
    close $f

    set f [open "test1"]
    set x [read $f 5]
    close $f
    set x
} {abcde}
test io-10.3 {Tcl_ReadChars: loop until enough copied} {
    # multiple times
    # for (copied = 0; (unsigned) toRead > 0; )

    set f [open "test1" w]
    puts $f abcdefghijklmnopqrstuvwxyz
    close $f

    set f [open "test1"]
    fconfigure $f -buffersize 16
    # here
    set x [read $f 19]
    close $f
    set x
} {abcdefghijklmnopqrs}
test io-10.4 {Tcl_ReadChars: no more in channel buffer} {
    # (copiedNow < 0)

    set f [open "test1" w]
    puts -nonewline $f abcdefghijkl
    close $f

    set f [open "test1"]
    # here
    set x [read $f 1000]
    close $f
    set x
} {abcdefghijkl}
test io-10.5 {Tcl_ReadChars: stop on EOF} {
    # (chanPtr->flags & CHANNEL_EOF)

    set f [open "test1" w]
    puts -nonewline $f abcdefghijkl
    close $f

    set f [open "test1"]
    # here
    set x [read $f 1000]
    close $f
    set x
} {abcdefghijkl}

test io-11.1 {ReadBytes: want to read a lot} {
    # ((unsigned) toRead > (unsigned) srcLen)

    set f [open "test1" w]
    puts -nonewline $f abcdefghijkl
    close $f
    set f [open "test1"]
    fconfigure $f -encoding binary
    # here
    set x [read $f 1000]
    close $f
    set x
} {abcdefghijkl}
test io-11.2 {ReadBytes: want to read all} {
    # ((unsigned) toRead > (unsigned) srcLen)

    set f [open "test1" w]
    puts -nonewline $f abcdefghijkl
    close $f
    set f [open "test1"]
    fconfigure $f -encoding binary
    # here
    set x [read $f]
    close $f
    set x
} {abcdefghijkl}
test io-11.3 {ReadBytes: allocate more space} {
    # (toRead > length - offset - 1)

    set f [open "test1" w]
    puts -nonewline $f abcdefghijklmnopqrstuvwxyz
    close $f
    set f [open "test1"]
    fconfigure $f -buffersize 16 -encoding binary
    # here
    set x [read $f]
    close $f
    set x
} {abcdefghijklmnopqrstuvwxyz}
test io-11.4 {ReadBytes: EOF char found} {
    # (TranslateInputEOL() != 0)

    set f [open "test1" w]
    puts $f abcdefghijklmnopqrstuvwxyz
    close $f
    set f [open "test1"]
    fconfigure $f -eofchar m -encoding binary
    # here
    set x [list [read $f] [eof $f] [read $f] [eof $f]]
    close $f
    set x
} [list "abcdefghijkl" 1 "" 1]
    
test io-12.1 {ReadChars: want to read a lot} {
    # ((unsigned) toRead > (unsigned) srcLen)

    set f [open "test1" w]
    puts -nonewline $f abcdefghijkl
    close $f
    set f [open "test1"]
    # here
    set x [read $f 1000]
    close $f
    set x
} {abcdefghijkl}
test io-12.2 {ReadChars: want to read all} {
    # ((unsigned) toRead > (unsigned) srcLen)

    set f [open "test1" w]
    puts -nonewline $f abcdefghijkl
    close $f
    set f [open "test1"]
    # here
    set x [read $f]
    close $f
    set x
} {abcdefghijkl}
test io-12.3 {ReadChars: allocate more space} {
    # (toRead > length - offset - 1)

    set f [open "test1" w]
    puts -nonewline $f abcdefghijklmnopqrstuvwxyz
    close $f
    set f [open "test1"]
    fconfigure $f -buffersize 16
    # here
    set x [read $f]
    close $f
    set x
} {abcdefghijklmnopqrstuvwxyz}
test io-12.4 {ReadChars: split-up char} {stdio} {
    # (srcRead == 0)

    set f [open "|[list $::tcltest::tcltest cat]" w+]
    fconfigure $f -encoding binary -buffering none -buffersize 16
    puts -nonewline $f "123456789012345\x96"
    fconfigure $f -encoding shiftjis -blocking 0

    fileevent $f read "ready $f"
    proc ready {f} {
	lappend ::x [read $f] [testchannel inputbuffered $f]
    }
    set x {}

    fconfigure $f -encoding shiftjis
    vwait x
    fconfigure $f -encoding binary -blocking 1
    puts -nonewline $f "\x7b"
    after 500			;# Give the cat process time to catch up
    fconfigure $f -encoding shiftjis -blocking 0
    vwait x
    close $f
    set x
} [list "123456789012345" 1 "\u672c" 0]
test io-12.5 {ReadChars: fileevents on partial characters} {stdio} {
    makeFile {
	fconfigure stdout -encoding binary -buffering none
	gets stdin; puts -nonewline "\xe7"
	gets stdin; puts -nonewline "\x89"
	gets stdin; puts -nonewline "\xa6"
    } test1
    set f [open "|[list $::tcltest::tcltest test1]" r+]
    fileevent $f readable {
	lappend x [read $f]
	if {[eof $f]} {
	    lappend x eof
	}
    }
    puts $f "go1"
    flush $f
    fconfigure $f -blocking 0 -encoding utf-8
    set x {}
    vwait x
    after 500 { lappend x timeout }
    vwait x
    puts $f "go2"
    flush $f
    vwait x
    after 500 { lappend x timeout }
    vwait x
    puts $f "go3"
    flush $f
    vwait x
    vwait x
    lappend x [catch {close $f} msg] $msg
    set x
} "{} timeout {} timeout \u7266 {} eof 0 {}"
d18 5
a22 24
test io-13.1 {TranslateInputEOL: cr mode} {} {
    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f "abcd\rdef\r"
    close $f
    set f [open test1]
    fconfigure $f -translation cr
    set x [read $f]
    close $f
    set x
} "abcd\ndef\n"
test io-13.2 {TranslateInputEOL: crlf mode} {
    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f "abcd\r\ndef\r\n"
    close $f
    set f [open test1]
    fconfigure $f -translation crlf
    set x [read $f]
    close $f
    set x
} "abcd\ndef\n"
test io-13.3 {TranslateInputEOL: crlf mode: naked cr} {
    # (src >= srcMax) 
d24 2
a25 12
    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f "abcd\r\ndef\r"
    close $f
    set f [open test1]
    fconfigure $f -translation crlf
    set x [read $f]
    close $f
    set x
} "abcd\ndef\r"
test io-13.4 {TranslateInputEOL: crlf mode: cr followed by not \n} {
    # (src >= srcMax) 
d27 1
a27 12
    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f "abcd\r\ndef\rfgh"
    close $f
    set f [open test1]
    fconfigure $f -translation crlf
    set x [read $f]
    close $f
    set x
} "abcd\ndef\rfgh"
test io-13.5 {TranslateInputEOL: crlf mode: naked lf} {
    # (src >= srcMax) 
d29 6
a34 20
    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f "abcd\r\ndef\nfgh"
    close $f
    set f [open test1]
    fconfigure $f -translation crlf
    set x [read $f]
    close $f
    set x
} "abcd\ndef\nfgh"
test io-13.6 {TranslateInputEOL: auto mode: saw cr in last segment} {stdio} {
    # (chanPtr->flags & INPUT_SAW_CR)
    # This test may fail on slower machines.

    set f [open "|[list $::tcltest::tcltest cat]" w+]
    fconfigure $f -blocking 0 -buffering none -translation {auto lf}

    fileevent $f read "ready $f"
    proc ready {f} {
	lappend ::x [read $f] [testchannel queuedcr $f]
d36 1
a36 1
    set x {}
d38 21
a58 3
    puts -nonewline $f "abcdefghj\r"
    after 500 {set y ok}
    vwait y
d60 66
a125 72
    puts -nonewline $f "\n01234"
    after 500 {set y ok}
    vwait y

    close $f
    set x
} [list "abcdefghj\n" 1 "01234" 0]
test io-13.7 {TranslateInputEOL: auto mode: naked \r} {
    # (src >= srcMax)

    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f "abcd\r"
    close $f
    set f [open test1]
    fconfigure $f -translation auto
    set x [list [read $f] [testchannel queuedcr $f]]
    close $f
    set x
} [list "abcd\n" 1]
test io-13.8 {TranslateInputEOL: auto mode: \r\n} {
    # (*src == '\n')

    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f "abcd\r\ndef"
    close $f
    set f [open test1]
    fconfigure $f -translation auto
    set x [read $f]
    close $f
    set x
} "abcd\ndef"
test io-13.9 {TranslateInputEOL: auto mode: \r followed by not \n} {
    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f "abcd\rdef"
    close $f
    set f [open test1]
    fconfigure $f -translation auto
    set x [read $f]
    close $f
    set x
} "abcd\ndef"
test io-13.10 {TranslateInputEOL: auto mode: \n} {
    # not (*src == '\r') 

    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f "abcd\ndef"
    close $f
    set f [open test1]
    fconfigure $f -translation auto
    set x [read $f]
    close $f
    set x
} "abcd\ndef"
test io-13.11 {TranslateInputEOL: EOF char} {
    # (*chanPtr->inEofChar != '\0')

    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f "abcd\ndefgh"
    close $f
    set f [open test1]
    fconfigure $f -translation auto -eofchar e
    set x [read $f]
    close $f
    set x
} "abcd\nd"
test io-13.12 {TranslateInputEOL: find EOF char in src} {
    # (*chanPtr->inEofChar != '\0')
a126 11
    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f "\r\n\r\n\r\nab\r\n\r\ndef\r\n\r\n\r\n"
    close $f
    set f [open test1]
    fconfigure $f -translation auto -eofchar e
    set x [read $f]
    close $f
    set x
} "\n\n\nab\n\nd"
    
d136 1
a136 1
test io-14.1 {Tcl_SetStdChannel and Tcl_GetStdChannel} {
d144 1
a144 1
test io-14.2 {Tcl_SetStdChannel and Tcl_GetStdChannel} {
d153 1
a153 1
test io-14.3 {Tcl_SetStdChannel & Tcl_GetStdChannel} {stdio} {
d170 1
a170 1
    set result [exec $::tcltest::tcltest test1]
d182 1
a182 1
test io-14.4 {Tcl_SetStdChannel & Tcl_GetStdChannel} {unixOnly} {
d198 1
a198 1
    set result [exec $::tcltest::tcltest test1]
d210 1
a210 1
test io-14.5 {Tcl_GetChannel: stdio name translation} {
d220 1
a220 1
test io-14.6 {Tcl_GetChannel: stdio name translation} {
d230 1
a230 1
test io-14.7 {Tcl_GetChannel: stdio name translation} {
d240 1
a240 1
test io-14.8 {reuse of stdio special channels} {stdio} {
d253 1
a253 1
    set f [open "|[list $::tcltest::tcltest script]" r]
d258 1
a258 1
test io-14.9 {reuse of stdio special channels} {stdio} {
d271 1
a271 1
    set f [open "|[list $::tcltest::tcltest script]" r]
d277 2
a278 5
test io-15.1 {Tcl_CreateCloseHandler} {
} {}

test io-16.1 {Tcl_DeleteCloseHandler} {
} {}
d287 10
a296 1
test io-17.1 {GetChannelTable, DeleteChannelTable on std handles} {
d307 2
a308 2
} {0 1 0}
test io-17.2 {GetChannelTable, DeleteChannelTable on std handles} {
d319 2
a320 2
} {0 1 0}
test io-17.3 {GetChannelTable, DeleteChannelTable on std handles} {
d331 2
a332 3
} {0 1 0}

test io-18.1 {Tcl_RegisterChannel, Tcl_UnregisterChannel} {
d346 1
a346 1
test io-18.2 {Tcl_RegisterChannel, Tcl_UnregisterChannel} {
d367 1
a367 1
test io-18.3 {Tcl_RegisterChannel, Tcl_UnregisterChannel} {
d386 1
a386 2

test io-19.1 {Tcl_GetChannel->Tcl_GetStdChannel, standard handles} {
d389 1
a389 1
test io-19.2 {testing Tcl_GetChannel, user opened handle} {
d396 1
a396 1
test io-19.3 {Tcl_GetChannel, channel not found} {
d399 1
a399 1
test io-19.4 {Tcl_CreateChannel, insertion into channel table} {
a413 46
test io-20.1 {Tcl_CreateChannel: initial settings} {
	set a [open test2 w]
    set old [encoding system]
    encoding system ascii
    set f [open test1 w]
    set x [fconfigure $f -encoding]
    close $f
    encoding system $old
	close $a
    set x
} {ascii}    
test io-20.2 {Tcl_CreateChannel: initial settings} {pcOnly} {
    set f [open test1 w+]
    set x [list [fconfigure $f -eofchar] [fconfigure $f -translation]]
    close $f
    set x
} [list [list \x1a ""] {auto crlf}]
test io-20.3 {Tcl_CreateChannel: initial settings} {unixOnly} {
    set f [open test1 w+]
    set x [list [fconfigure $f -eofchar] [fconfigure $f -translation]]
    close $f
    set x
} {{{} {}} {auto lf}}
test io-20.4 {Tcl_CreateChannel: initial settings} {macOnly} {
    set f [open test1 w+]
    set x [list [fconfigure $f -eofchar] [fconfigure $f -translation]]
    close $f
    set x
} {{{} {}} {auto cr}}
test io-20.5 {Tcl_CreateChannel: install channel in empty slot} {stdio} {
    set f [open script w]
    puts $f {
	close stdout
	set f1 [open stdout w]
	fconfigure $f1 -buffersize 777
	puts stderr [fconfigure stdout -buffersize]
    }
    close $f
    set f [open "|[list $::tcltest::tcltest script]"]
    catch {close $f} msg
    set msg
} {777}
	
test io-21.1 {CloseChannelsOnExit} {
} {}
    
d420 1
a420 5
test io-22.1 {Tcl_GetChannelMode} {
    # Not used anywhere in Tcl.
} {}

test io-23.1 {Tcl_GetChannelName} {
d427 1
a427 2

test io-24.1 {Tcl_GetChannelType} {
d434 1
a434 2

test io-25.1 {Tcl_GetChannelHandle, input} {
d447 1
a447 1
test io-25.2 {Tcl_GetChannelHandle, output} {
a462 9
test io-26.1 {Tcl_GetChannelInstanceData} {stdio} {
    # "pid" command uses Tcl_GetChannelInstanceData
    # Don't care what pid is (but must be a number), just want to exercise it.

    set f [open "|[list $::tcltest::tcltest << exit]"]
    expr [pid $f]
    close $f
} {}    

d465 1
a465 1
test io-27.1 {FlushChannel, no output buffered} {
d473 1
a473 1
test io-27.2 {FlushChannel, some output buffered} {
d486 1
a486 1
test io-27.3 {FlushChannel, implicit flush on close} {
d497 1
a497 1
test io-27.4 {FlushChannel, implicit flush when buffer fills} {
d513 1
a513 2
test io-27.5 {FlushChannel, implicit flush when buffer fills and on close} \
	{unixOrPc} {
d527 1
a527 2
test io-27.6 {FlushChannel, async flushing, async close} \
	{stdio asyncPipeClose } {
d547 1
a547 1
    set f [open "|[list $::tcltest::tcltest pipe]" w]
d558 1
a558 1
        set result "file size only [file size output]"
d566 1
a566 1
test io-28.1 {CloseChannel called when all references are dropped} {
d579 1
a579 1
test io-28.2 {CloseChannel called when all references are dropped} {
d594 1
a594 2
test io-28.3 {CloseChannel, not called before output queue is empty} \
	{stdio asyncPipeClose nonPortable} {
d622 1
a622 1
    set f [open "|[list $::tcltest::tcltest pipe]" r+]
d625 3
d642 1
a642 1
test io-28.4 {Tcl_Close} {
d655 1
a655 1
test io-28.5 {Tcl_Close vs standard handles} {stdio unixOnly} {
d663 1
a663 1
    set f [open "|[list $::tcltest::tcltest script]" r]
d669 4
a672 1
test io-29.1 {Tcl_WriteChars, channel not writable} {
d675 1
a675 1
test io-29.2 {Tcl_WriteChars, empty string} {
d683 1
a683 1
test io-29.3 {Tcl_WriteChars, nonempty string} {
d691 1
a691 1
test io-29.4 {Tcl_WriteChars, buffering in full buffering mode} {
d705 1
a705 1
test io-29.5 {Tcl_WriteChars, buffering in line buffering mode} {
d719 1
a719 1
test io-29.6 {Tcl_WriteChars, buffering in no buffering mode} {
d733 1
a733 2

test io-29.7 {Tcl_Flush, full buffering} {
d750 1
a750 1
test io-29.8 {Tcl_Flush, full buffering} {
d770 1
a770 1
test io-29.9 {Tcl_Flush, channel not writable} {
d773 1
a773 1
test io-29.10 {Tcl_WriteChars, looping and buffering} {
d779 1
a779 1
	puts $f1 [gets $f2]
d785 1
a785 1
test io-29.11 {Tcl_WriteChars, no newline, implicit flush} {
d791 1
a791 1
	puts -nonewline $f1 [gets $f2]
d797 1
a797 1
test io-29.12 {Tcl_WriteChars on a pipe} {stdio} {
d808 1
a808 1
    set f1 [open "|[list $::tcltest::tcltest pipe]" r]
d812 5
a816 5
	set l1 [gets $f1]
	set l2 [gets $f2]
	if {"$l1" != "$l2"} {
	    set y broken
	}
d822 1
a822 1
test io-29.13 {Tcl_WriteChars to a pipe, line buffered} {stdio} {
d832 1
a832 1
    set f1 [open "|[list $::tcltest::tcltest pipe]" r+]
d839 1
a839 1
	set y broken
d845 1
a845 1
	set y broken
d851 1
a851 1
test io-29.14 {Tcl_WriteChars, buffering and implicit flush at close} {
d863 1
a863 1
test io-29.15 {Tcl_Flush, channel not open for writing} {
d873 2
a874 2
test io-29.16 {Tcl_Flush on pipe opened only for reading} {stdio} {
    set fd [open "|[list $::tcltest::tcltest cat longfile]" r]
d880 1
a880 1
test io-29.17 {Tcl_WriteChars buffers, then Tcl_Flush flushes} {
d892 1
a892 1
test io-29.18 {Tcl_WriteChars and Tcl_Flush intermixed} {
d911 1
a911 1
test io-29.19 {Explicit and implicit flushes} {
d929 1
a929 1
test io-29.20 {Implicit flush when buffer is full} {
d940 1
a940 1
	puts $f1 $line
d947 1
a947 1
test io-29.21 {Tcl_Flush to pipe} {stdio} {
d954 1
a954 1
    set f1 [open "|[list $::tcltest::tcltest pipe]" r+]
d961 1
a961 1
test io-29.22 {Tcl_Flush called at other end of pipe} {stdio} {
d974 1
a974 1
    set f1 [open "|[list $::tcltest::tcltest pipe]" r+]
d984 1
a984 1
test io-29.23 {Tcl_Flush and line buffering at end of pipe} {stdio} {
d994 1
a994 1
    set f1 [open "|[list $::tcltest::tcltest pipe]" r+]
d1004 1
a1004 1
test io-29.24 {Tcl_WriteChars and Tcl_Flush move end of file} {
d1018 3
a1020 2
} "{} {Line 1\nLine 2}"
test io-29.25 {Implicit flush with Tcl_Flush to command pipelines} {stdio} {
d1022 1
a1022 1
    set f [open "|[list $::tcltest::tcltest cat | $::tcltest::tcltest cat > test3]" w]
d1031 4
a1034 2
} "Line 1\nLine 2\n"
test io-29.26 {Tcl_Flush, Tcl_Write on bidirectional pipelines} {stdio unixExecs} {
d1042 1
a1042 1
test io-29.27 {Tcl_Flush on closed pipeline} {stdio} {
d1047 1
a1047 1
    set f [open "|[list $::tcltest::tcltest pipe]" r+]
d1070 1
a1070 1
test io-29.28 {Tcl_WriteChars, lf mode} {
d1080 1
a1080 1
test io-29.29 {Tcl_WriteChars, cr mode} {
d1088 1
a1088 1
test io-29.30 {Tcl_WriteChars, crlf mode} {
d1096 1
a1096 1
test io-29.31 {Tcl_WriteChars, background flush} {stdio} {
d1112 1
a1112 1
	set x "$x$x"
d1116 1
a1116 1
    set f [open "|[list $::tcltest::tcltest pipe]" r+]
d1122 3
a1124 3
	incr counter
	after 5
	update
d1127 1
a1127 1
	set result "file size only [file size output]"
d1129 1
a1129 1
	set result ok
d1132 1
a1132 2
test io-29.32 {Tcl_WriteChars, background flush to slow reader} \
	{stdio asyncPipeClose} {
d1149 1
a1149 1
	set x "$x$x"
d1153 1
a1153 1
    set f [open "|[list $::tcltest::tcltest pipe]" r+]
d1159 3
a1161 3
	incr counter
	after 20
	update
d1164 1
a1164 1
	set result "file size only [file size output]"
d1166 1
a1166 1
	set result ok
d1169 1
a1169 1
test io-29.33 {Tcl_Flush, implicit flush on exit} {stdio} {
d1179 1
a1179 1
    exec $::tcltest::tcltest script
d1184 6
a1189 2
} "hello\nbye\nstrange\n"
test io-29.34 {Tcl_Close, async flush on close, using sockets} {socket tempNotMac} {
d1225 1
a1225 4
test io-29.35 {Tcl_Close vs fileevent vs multiple interpreters} {socket tempNotMac} {
    # On Mac, this test screws up sockets such that subsequent tests using port 2828 
    # either cause errors or panic().
     
d1266 1
a1266 1
test io-30.1 {Tcl_Write lf, Tcl_Read lf} {
d1278 1
a1278 1
test io-30.2 {Tcl_Write lf, Tcl_Read cr} {
d1290 1
a1290 1
test io-30.3 {Tcl_Write lf, Tcl_Read crlf} {
d1302 1
a1302 1
test io-30.4 {Tcl_Write cr, Tcl_Read cr} {
d1314 1
a1314 1
test io-30.5 {Tcl_Write cr, Tcl_Read lf} {
d1326 1
a1326 1
test io-30.6 {Tcl_Write cr, Tcl_Read crlf} {
d1338 1
a1338 1
test io-30.7 {Tcl_Write crlf, Tcl_Read crlf} {
d1350 1
a1350 1
test io-30.8 {Tcl_Write crlf, Tcl_Read lf} {
d1362 1
a1362 1
test io-30.9 {Tcl_Write crlf, Tcl_Read cr} {
d1374 1
a1374 1
test io-30.10 {Tcl_Write lf, Tcl_Read auto} {
d1390 1
a1390 1
test io-30.11 {Tcl_Write cr, Tcl_Read auto} {
d1406 1
a1406 1
test io-30.12 {Tcl_Write crlf, Tcl_Read auto} {
d1423 1
a1423 1
test io-30.13 {Tcl_Write crlf on block boundary, Tcl_Read auto} {
d1440 1
a1440 1
test io-30.14 {Tcl_Write crlf on block boundary, Tcl_Read crlf} {
d1457 1
a1457 1
test io-30.15 {Tcl_Write mixed, Tcl_Read auto} {
d1473 1
a1473 1
test io-30.16 {Tcl_Write ^Z at end, Tcl_Read auto} {
d1489 1
a1489 1
test io-30.17 {Tcl_Write, implicit ^Z at end, Tcl_Read auto} {pcOnly} {
d1505 1
a1505 1
test io-30.18 {Tcl_Write, ^Z in middle, Tcl_Read auto} {
d1525 1
a1525 1
test io-30.19 {Tcl_Write, ^Z no newline in middle, Tcl_Read auto} {
d1545 1
a1545 1
test io-30.20 {Tcl_Write, ^Z in middle ignored, Tcl_Read lf} {
d1567 1
a1567 1
test io-30.21 {Tcl_Write, ^Z in middle ignored, Tcl_Read cr} {
d1578 1
a1578 1
    lappend l [string compare $x "abc\ndef\n\x1aghi\nqrs\n"]
d1585 1
a1585 1
test io-30.22 {Tcl_Write, ^Z in middle ignored, Tcl_Read crlf} {
d1596 1
a1596 1
    lappend l [string compare $x "abc\ndef\n\x1aghi\nqrs\n"]
d1603 1
a1603 1
test io-30.23 {Tcl_Write lf, ^Z in middle, Tcl_Read auto} {
d1617 1
a1617 1
test io-30.24 {Tcl_Write lf, ^Z in middle, Tcl_Read lf} {
d1631 1
a1631 1
test io-30.25 {Tcl_Write cr, ^Z in middle, Tcl_Read auto} {
d1645 1
a1645 1
test io-30.26 {Tcl_Write cr, ^Z in middle, Tcl_Read cr} {
d1659 1
a1659 1
test io-30.27 {Tcl_Write crlf, ^Z in middle, Tcl_Read auto} {
d1673 1
a1673 1
test io-30.28 {Tcl_Write crlf, ^Z in middle, Tcl_Read crlf} {
d1690 1
a1690 1
test io-31.1 {Tcl_Write lf, Tcl_Gets auto} {
d1707 1
a1707 1
test io-31.2 {Tcl_Write cr, Tcl_Gets auto} {
d1724 1
a1724 1
test io-31.3 {Tcl_Write crlf, Tcl_Gets auto} {
d1741 1
a1741 1
test io-31.4 {Tcl_Write lf, Tcl_Gets lf} {
d1759 1
a1759 1
test io-31.5 {Tcl_Write lf, Tcl_Gets cr} {
d1778 2
a1779 2
} {21 21 cr 1 {} 21 cr 1}
test io-31.6 {Tcl_Write lf, Tcl_Gets crlf} {
d1798 2
a1799 2
} {21 21 crlf 1 {} 21 crlf 1}
test io-31.7 {Tcl_Write cr, Tcl_Gets cr} {
d1819 1
a1819 1
test io-31.8 {Tcl_Write cr, Tcl_Gets lf} {
d1839 1
a1839 1
test io-31.9 {Tcl_Write cr, Tcl_Gets crlf} {
d1859 1
a1859 1
test io-31.10 {Tcl_Write crlf, Tcl_Gets crlf} {
d1879 1
a1879 1
test io-31.11 {Tcl_Write crlf, Tcl_Gets cr} {
d1899 1
a1899 1
test io-31.12 {Tcl_Write crlf, Tcl_Gets lf} {
d1919 1
a1919 1
test io-31.13 {binary mode is synonym of lf mode} {
d1931 1
a1931 1
test io-31.14 {Tcl_Write mixed, Tcl_Gets auto} {
d1950 1
a1950 1
test io-31.15 {Tcl_Write mixed, Tcl_Gets auto} {
d1969 1
a1969 1
test io-31.16 {Tcl_Write mixed, Tcl_Gets auto} {
d1987 1
a1987 1
test io-31.17 {Tcl_Write mixed, Tcl_Gets auto} {
d2006 1
a2006 1
test io-31.18 {Tcl_Write ^Z at end, Tcl_Gets auto} {
d2026 1
a2026 1
test io-31.19 {Tcl_Write, implicit ^Z at end, Tcl_Gets auto} {
d2045 1
a2045 1
test io-31.20 {Tcl_Write, ^Z in middle, Tcl_Gets auto, eofChar} {
d2064 1
a2064 1
test io-31.21 {Tcl_Write, no newline ^Z in middle, Tcl_Gets auto, eofChar} {
d2082 1
a2082 1
test io-31.22 {Tcl_Write, ^Z in middle ignored, Tcl_Gets lf} {
d2104 1
a2104 1
test io-31.23 {Tcl_Write, ^Z in middle ignored, Tcl_Gets cr} {
d2126 1
a2126 1
test io-31.24 {Tcl_Write, ^Z in middle ignored, Tcl_Gets crlf} {
d2148 1
a2148 1
test io-31.25 {Tcl_Write lf, ^Z in middle, Tcl_Gets auto} {
d2166 1
a2166 1
test io-31.26 {Tcl_Write lf, ^Z in middle, Tcl_Gets lf} {
d2184 1
a2184 1
test io-31.27 {Tcl_Write cr, ^Z in middle, Tcl_Gets auto} {
d2202 1
a2202 1
test io-31.28 {Tcl_Write cr, ^Z in middle, Tcl_Gets cr} {
d2220 1
a2220 1
test io-31.29 {Tcl_Write crlf, ^Z in middle, Tcl_Gets auto} {
d2238 1
a2238 1
test io-31.30 {Tcl_Write crlf, ^Z in middle, Tcl_Gets crlf} {
d2256 1
a2256 1
test io-31.31 {Tcl_Write crlf on block boundary, Tcl_Gets crlf} {
d2267 1
a2267 1
    fconfigure $f -translation crlf 
d2275 1
a2275 1
test io-31.32 {Tcl_Write crlf on block boundary, Tcl_Gets auto} {
d2281 1
a2281 1
    for {set i 0} {$i < 700} {incr i} {
d2293 1
a2293 1
} [expr 700*15+1]
d2298 1
a2298 1
test io-32.1 {Tcl_Read, channel not readable} {
d2301 1
a2301 1
test io-32.2 {Tcl_Read, zero byte count} {
d2304 1
a2304 1
test io-32.3 {Tcl_Read, negative byte count} {
d2310 1
a2310 1
test io-32.4 {Tcl_Read, positive byte count} {
d2318 1
a2318 1
test io-32.5 {Tcl_Read, multiple buffers} {
d2327 1
a2327 1
test io-32.6 {Tcl_Read, very large read} {
d2335 1
a2335 1
	set x broken
d2339 1
a2339 1
test io-32.7 {Tcl_Read, nonblocking, file} {nonBlockFiles} {
d2347 1
a2347 1
	set x broken
d2351 1
a2351 1
test io-32.8 {Tcl_Read, nonblocking, file} {nonBlockFiles} {
d2360 1
a2360 1
	set x broken
d2364 1
a2364 1
test io-32.9 {Tcl_Read, read to end of file} {
d2372 1
a2372 1
	set x broken
d2376 1
a2376 1
test io-32.10 {Tcl_Read from a pipe} {stdio} {
d2381 1
a2381 1
    set f1 [open "|[list $::tcltest::tcltest pipe]" r+]
d2388 1
a2388 1
test io-32.11 {Tcl_Read from a pipe} {stdio} {
d2394 1
a2394 1
    set f1 [open "|[list $::tcltest::tcltest pipe]" r+]
d2407 1
a2407 1
test io-32.12 {Tcl_Read, -nonewline} {
d2419 1
a2419 1
test io-32.13 {Tcl_Read, -nonewline} {
d2431 1
a2431 1
test io-32.14 {Tcl_Read, reading in small chunks} {
d2444 1
a2444 1
test io-32.15 {Tcl_Read, asking for more input than available} {
d2457 1
a2457 1
test io-32.16 {Tcl_Read, read to end of file with -nonewline} {
d2472 1
a2472 1
test io-33.1 {Tcl_Gets, reading what was written} {
d2482 1
a2482 1
	set z broken
d2487 1
a2487 1
test io-33.2 {Tcl_Gets into variable} {
d2493 1
a2493 1
	set z broken
d2498 1
a2498 1
test io-33.3 {Tcl_Gets from pipe} {stdio} {
d2503 1
a2503 1
    set f1 [open "|[list $::tcltest::tcltest pipe]" r+]
d2510 1
a2510 1
	set z broken
d2514 1
a2514 1
test io-33.4 {Tcl_Gets with long line} {
d2528 1
a2528 1
test io-33.5 {Tcl_Gets with long line} {
d2534 1
a2534 1
test io-33.6 {Tcl_Gets and end of file} {
d2550 1
a2550 1
test io-33.7 {Tcl_Gets and bad variable} {
d2562 1
a2562 1
test io-33.8 {Tcl_Gets, exercising double buffering} {
d2575 1
a2575 1
test io-33.9 {Tcl_Gets, exercising double buffering} {
d2588 1
a2588 1
test io-33.10 {Tcl_Gets, exercising double buffering} {
d2604 1
a2604 1
test io-34.1 {Tcl_Seek to current position at start of file} {
d2611 1
a2611 1
test io-34.2 {Tcl_Seek to offset from start} {
d2624 1
a2624 1
test io-34.3 {Tcl_Seek to end of file} {
d2637 1
a2637 1
test io-34.4 {Tcl_Seek to offset from end of file} {
d2650 1
a2650 1
test io-34.5 {Tcl_Seek to offset from current position} {
d2664 1
a2664 1
test io-34.6 {Tcl_Seek to offset from end of file} {
d2679 1
a2679 1
test io-34.7 {Tcl_Seek to offset from end of file, then to current position} {
d2695 2
a2696 2
test io-34.8 {Tcl_Seek on pipes: not supported} {stdio} {
    set f1 [open "|[list $::tcltest::tcltest]" r+]
d2702 1
a2702 1
test io-34.9 {Tcl_Seek, testing buffered input flushing} {
d2725 1
a2725 1
test io-34.10 {Tcl_Seek testing flushing of buffered input} {
d2739 1
a2739 1
test io-34.11 {Tcl_Seek testing flushing of buffered output} {
d2750 1
a2750 1
test io-34.12 {Tcl_Seek testing combination of write, seek back and read} {
d2767 1
a2767 1
test io-34.13 {Tcl_Tell at start of file} {
d2774 1
a2774 1
test io-34.14 {Tcl_Tell after seek to end of file} {
d2787 1
a2787 1
test io-34.15 {Tcl_Tell combined with seeking} {
d2802 2
a2803 2
test io-34.16 {Tcl_tell on pipe: always -1} {stdio} {
    set f1 [open "|[list $::tcltest::tcltest]" r+]
d2808 2
a2809 2
test io-34.17 {Tcl_Tell on pipe: always -1} {stdio} {
    set f1 [open "|[list $::tcltest::tcltest]" r+]
d2817 1
a2817 1
test io-34.18 {Tcl_Tell combined with seeking and reading} {
d2837 1
a2837 1
test io-34.19 {Tcl_Tell combined with opening in append mode} {
d2848 1
a2848 1
test io-34.20 {Tcl_Tell combined with writing} {
d2866 1
a2866 1
test io-35.1 {Tcl_Eof} {
d2885 1
a2885 1
test io-35.2 {Tcl_Eof with pipe} {stdio} {
d2891 1
a2891 1
    set f1 [open "|[list $::tcltest::tcltest pipe]" r+]
d2903 1
a2903 1
test io-35.3 {Tcl_Eof with pipe} {stdio} {
d2909 1
a2909 1
    set f1 [open "|[list $::tcltest::tcltest pipe]" r+]
d2925 1
a2925 1
test io-35.4 {Tcl_Eof, eof detection on nonblocking file} {nonBlockFiles} {
d2937 1
a2937 1
test io-35.5 {Tcl_Eof, eof detection on nonblocking pipe} {stdio} {
d2944 1
a2944 1
    set f [open "|[list $::tcltest::tcltest pipe]" r]
d2951 1
a2951 1
test io-35.6 {Tcl_Eof, eof char, lf write, auto read} {
d2965 1
a2965 1
test io-35.7 {Tcl_Eof, eof char, lf write, lf read} {
d2979 1
a2979 1
test io-35.8 {Tcl_Eof, eof char, cr write, auto read} {
d2993 1
a2993 1
test io-35.9 {Tcl_Eof, eof char, cr write, cr read} {
d3007 1
a3007 1
test io-35.10 {Tcl_Eof, eof char, crlf write, auto read} {
d3021 1
a3021 1
test io-35.11 {Tcl_Eof, eof char, crlf write, crlf read} {
d3035 1
a3035 1
test io-35.12 {Tcl_Eof, eof char in middle, lf write, auto read} {
d3050 1
a3050 1
test io-35.13 {Tcl_Eof, eof char in middle, lf write, lf read} {
d3065 1
a3065 1
test io-35.14 {Tcl_Eof, eof char in middle, cr write, auto read} {
d3080 1
a3080 1
test io-35.15 {Tcl_Eof, eof char in middle, cr write, cr read} {
d3095 1
a3095 1
test io-35.16 {Tcl_Eof, eof char in middle, crlf write, auto read} {
d3110 1
a3110 1
test io-35.17 {Tcl_Eof, eof char in middle, crlf write, crlf read} {
d3128 2
a3129 2
test io-36.1 {Tcl_InputBlocked on nonblocking pipe} {stdio} {
    set f1 [open "|[list $::tcltest::tcltest]" r+]
d3147 2
a3148 2
test io-36.2 {Tcl_InputBlocked on blocking pipe} {stdio} {
    set f1 [open "|[list $::tcltest::tcltest]" r+]
d3161 1
a3161 1
test io-36.3 {Tcl_InputBlocked vs files, short read} {
d3177 1
a3177 1
test io-36.4 {Tcl_InputBlocked vs files, event driven read} {
d3194 1
a3194 1
test io-36.5 {Tcl_InputBlocked vs files, short read, nonblocking} {nonBlockFiles} {
d3211 1
a3211 1
test io-36.6 {Tcl_InputBlocked vs files, event driven read} {nonBlockFiles} {
d3232 1
a3232 1
test io-37.1 {Tcl_InputBuffered} {
d3242 1
a3242 1
test io-37.2 {Tcl_InputBuffered, test input flushing on seek} {
d3258 1
a3258 1
test io-38.1 {Tcl_GetChannelBufferSize, default buffer size} {
d3264 1
a3264 1
test io-38.2 {Tcl_SetChannelBufferSize, Tcl_GetChannelBufferSize} {
d3286 1
a3286 1
test io-39.1 {Tcl_GetChannelOption} {
d3296 1
a3296 1
test io-39.2 {Tcl_GetChannelOption} {
d3303 1
a3303 1
test io-39.3 {Tcl_GetChannelOption} {
d3311 1
a3311 1
test io-39.4 {Tcl_GetChannelOption, Tcl_SetChannelOption} {
d3327 1
a3327 1
test io-39.5 {Tcl_GetChannelOption, invariance} {
d3337 1
a3337 1
test io-39.6 {Tcl_SetChannelOption, multiple options} {
d3347 1
a3347 1
test io-39.7 {Tcl_SetChannelOption, buffering, translation} {
d3361 1
a3361 1
test io-39.8 {Tcl_SetChannelOption, different buffering options} {
d3381 1
a3381 1
test io-39.9 {Tcl_SetChannelOption, blocking mode} {nonBlockFiles} {
d3397 1
a3397 1
test io-39.10 {Tcl_SetChannelOption, blocking mode} {stdio} {
d3400 4
a3403 6
    puts $f1 {
	gets stdin
	after 100
	puts hi
	gets stdin
    }
d3406 1
a3406 1
    set f1 [open "|[list $::tcltest::tcltest pipe]" r+]
a3410 1
    fconfigure $f1 -blocking on
a3411 1
    fconfigure $f1 -blocking off
a3413 1
    fconfigure $f1 -blocking on
a3414 1
    fconfigure $f1 -blocking off
d3427 1
a3427 1
test io-39.11 {Tcl_SetChannelOption, Tcl_GetChannelOption, buffer size} {
d3435 1
a3435 1
test io-39.12 {Tcl_SetChannelOption, Tcl_GetChannelOption buffer size} {
d3443 1
a3443 1
test io-39.13 {Tcl_SetChannelOption, Tcl_GetChannelOption, buffer size} {
d3451 1
a3451 55
test io-39.14 {Tcl_SetChannelOption: -encoding, binary & utf-8} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -encoding {} 
    puts -nonewline $f \xe7\x89\xa6
    close $f
    set f [open test1 r]
    fconfigure $f -encoding utf-8
    set x [read $f]
    close $f
    set x
} \u7266
test io-39.15 {Tcl_SetChannelOption: -encoding, binary & utf-8} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -encoding binary
    puts -nonewline $f \xe7\x89\xa6
    close $f
    set f [open test1 r]
    fconfigure $f -encoding utf-8
    set x [read $f]
    close $f
    set x
} \u7266
test io-39.16 {Tcl_SetChannelOption: -encoding, errors} {
    removeFile test1
    set f [open test1 w]
    set result [list [catch {fconfigure $f -encoding foobar} msg] $msg]
    close $f
    set result
} {1 {unknown encoding "foobar"}}
test io-39.17 {Tcl_SetChannelOption: -encoding, clearing CHANNEL_NEED_MORE_DATA} {stdio} {
    set f [open "|[list $::tcltest::tcltest cat]" r+]
    fconfigure $f -encoding binary
    puts -nonewline $f "\xe7"
    flush $f
    fconfigure $f -encoding utf-8 -blocking 0
    set x {}
    fileevent $f readable { lappend x [read $f] }
    vwait x
    after 300 { lappend x timeout }
    vwait x
    fconfigure $f -encoding utf-8
    vwait x
    after 300 { lappend x timeout }
    vwait x
    fconfigure $f -encoding binary
    vwait x
    after 300 { lappend x timeout }
    vwait x
    close $f
    set x
} "{} timeout {} timeout \xe7 timeout"

test io-39.18 {Tcl_SetChannelOption, setting read mode independently} \
d3456 1
a3456 1
    set s2 [socket 127.0.0.1 $port]
d3464 1
a3464 1
test io-39.19 {Tcl_SetChannelOption, setting read mode independently} \
d3469 1
a3469 1
    set s2 [socket 127.0.0.1 $port]
d3477 1
a3477 1
test io-39.20 {Tcl_SetChannelOption, setting read mode independently} \
d3482 1
a3482 1
    set s2 [socket 127.0.0.1 $port]
d3490 1
a3490 1
test io-39.21 {Tcl_SetChannelOption, setting read mode independently} \
d3495 1
a3495 1
    set s2 [socket 127.0.0.1 $port]
d3504 1
a3504 1
test io-40.1 {POSIX open access modes: RDWR} {
d3519 1
a3519 1
test io-40.2 {POSIX open access modes: CREAT} {unixOnly} {
d3531 1
a3531 6

# some tests can only be run is umask is 2
# if "umask" cannot be run, the tests will be skipped.
catch {set ::tcltest::testConstraints(umask2) [expr {[exec umask] == 2}]}

test io-40.3 {POSIX open access modes: CREAT} {unixOnly umask2} {
d3539 1
a3539 1
test io-40.4 {POSIX open access modes: CREAT} {
d3554 1
a3554 1
test io-40.5 {POSIX open access modes: APPEND} {
d3575 1
a3575 1
test io-40.6 {POSIX open access modes: EXCL} {
d3584 1
a3584 1
test io-40.7 {POSIX open access modes: EXCL} {
d3592 1
a3592 1
test io-40.8 {POSIX open access modes: TRUNC} {
d3605 1
a3605 1
test io-40.9 {POSIX open access modes: NONBLOCK} {nonPortable macOrUnix} {
d3615 1
a3615 1
test io-40.10 {POSIX open access modes: RDONLY} {
d3627 1
a3627 1
test io-40.11 {POSIX open access modes: RDONLY} {
d3631 1
a3631 1
test io-40.12 {POSIX open access modes: WRONLY} {
d3635 1
a3635 1
test io-40.13 {POSIX open access modes: WRONLY} {
d3647 1
a3647 1
test io-40.14 {POSIX open access modes: RDWR} {
d3651 1
a3651 1
test io-40.15 {POSIX open access modes: RDWR} {
d3661 1
a3661 1
    test io-40.16 {tilde substitution in open} {
d3670 1
a3670 1
test io-40.17 {tilde substitution in open} {
d3678 1
a3678 1
test io-41.1 {Tcl_FileeventCmd: errors} {
d3680 2
a3681 2
} {1 {wrong # args: should be "fileevent channelId event ?script?"}}
test io-41.2 {Tcl_FileeventCmd: errors} {
d3683 2
a3684 2
} {1 {wrong # args: should be "fileevent channelId event ?script?"}}
test io-41.3 {Tcl_FileeventCmd: errors} {
d3687 1
a3687 1
test io-41.4 {Tcl_FileeventCmd: errors} {
d3690 1
a3690 1
test io-41.5 {Tcl_FileeventCmd: errors} {
d3700 1
a3700 1
test io-42.1 {Tcl_FileeventCmd: creating, deleting, querying} {
d3703 1
a3703 1
test io-42.2 {Tcl_FileeventCmd: replacing} {
a3713 11
test io-42.3 {Tcl_FileeventCmd: replacing, with NULL chars in script} {
    set result {}
    fileevent $f r "first scr\0ipt"
    lappend result [string length [fileevent $f readable]]
    fileevent $f r "new scr\0ipt"
    lappend result [string length [fileevent $f readable]]
    fileevent $f r "yet ano\0ther"
    lappend result [string length [fileevent $f readable]]
    fileevent $f r ""
    lappend result [fileevent $f readable]
} {13 11 12 {}}
d3719 3
d3725 1
a3725 1
test io-43.1 {Tcl_FileeventCmd: creating, deleting, querying} {stdio unixExecs} {
d3736 1
a3736 1
test io-43.2 {Tcl_FileeventCmd: deleting when many present} {stdio unixExecs} {
d3751 1
a3751 1
test io-44.1 {FileEventProc procedure: normal read event} {stdio unixExecs} {
d3760 1
a3760 1
test io-44.2 {FileEventProc procedure: error in read event} {stdio unixExecs} {
d3772 1
a3772 1
test io-44.3 {FileEventProc procedure: normal write event} {stdio unixExecs} {
d3787 1
a3787 1
test io-44.4 {FileEventProc procedure: eror in write event} {stdio unixExecs} {
d3798 2
a3799 2
test io-44.5 {FileEventProc procedure: end of file} {stdio unixExecs} {
    set f4 [open "|[list $::tcltest::tcltest cat << foo]" r]
d3818 3
d3824 1
a3824 1
test io-45.1 {DeleteFileEvent, cleanup on close} {
d3836 1
a3836 1
test io-45.2 {DeleteFileEvent, cleanup on close} {
d3853 1
a3853 1
test io-45.3 {DeleteFileEvent, cleanup on close} {
d3879 1
a3879 1
    test io-46.1 {Tcl event loop vs multiple interpreters} {} {
d3894 1
a3894 1
test io-46.2 {Tcl event loop vs multiple interpreters} {
d3903 1
a3903 1
test io-46.3 {Tcl event loop vs multiple interpreters} {
d3917 1
a3917 1
test io-47.1 {fileevent vs multiple interpreters} {
d3936 1
a3936 1
test io-47.2 {deleting fileevent on interpreter delete} {
d3957 1
a3957 1
test io-47.3 {deleting fileevent on interpreter delete} {
d3978 1
a3978 1
test io-47.4 {file events on shared files and multiple interpreters} {
d3994 1
a3994 1
test io-47.5 {file events on shared files, deleting file events} {
d4007 1
a4007 1
test io-47.6 {file events on shared files, deleting file events} {
d4025 1
a4025 1
test io-48.1 {testing readability conditions} {
d4050 1
a4050 1
test io-48.2 {testing readability conditions} {nonBlockFiles} {
d4076 1
a4076 1
test io-48.3 {testing readability conditions} {unixOnly nonBlockFiles} {
d4095 1
a4095 1
    set f [open "|[list $::tcltest::tcltest]" r+]
d4120 1
a4120 1
test io-48.4 {lf write, testing readability, ^Z termination, auto read mode} {
d4145 1
a4145 1
test io-48.5 {lf write, testing readability, ^Z in middle, auto read mode} {
d4170 1
a4170 1
test io-48.6 {cr write, testing readability, ^Z termination, auto read mode} {
d4195 1
a4195 1
test io-48.7 {cr write, testing readability, ^Z in middle, auto read mode} {
d4220 1
a4220 1
test io-48.8 {crlf write, testing readability, ^Z termination, auto read mode} {
d4245 1
a4245 1
test io-48.9 {crlf write, testing readability, ^Z in middle, auto read mode} {
d4270 1
a4270 1
test io-48.10 {lf write, testing readability, ^Z in middle, lf read mode} {
d4295 1
a4295 1
test io-48.11 {lf write, testing readability, ^Z termination, lf read mode} {
d4320 1
a4320 1
test io-48.12 {cr write, testing readability, ^Z in middle, cr read mode} {
d4345 1
a4345 1
test io-48.13 {cr write, testing readability, ^Z termination, cr read mode} {
d4370 1
a4370 1
test io-48.14 {crlf write, testing readability, ^Z in middle, crlf read mode} {
d4395 1
a4395 1
test io-48.15 {crlf write, testing readability, ^Z termi, crlf read mode} {
d4421 1
a4421 1
test io-49.1 {testing crlf reading, leftover cr disgorgment} {
d4450 1
a4450 1
test io-49.2 {testing crlf reading, leftover cr disgorgment} {
d4473 1
a4473 1
test io-49.3 {testing crlf reading, leftover cr disgorgment} {
d4494 1
a4494 1
test io-49.4 {testing crlf reading, leftover cr disgorgment} {
d4515 1
a4515 1
test io-49.5 {testing crlf reading, leftover cr disgorgment} {
d4534 1
a4534 1
test io-50.1 {testing handler deletion} {} {
d4550 1
a4550 1
test io-50.2 {testing handler deletion with multiple handlers} {} {
d4568 1
a4568 1
test io-50.3 {testing handler deletion with multiple handlers} {} {
d4594 1
a4594 1
test io-50.4 {testing handler deletion vs reentrant calls} {} {
d4618 1
a4618 1
test io-50.5 {testing handler deletion vs reentrant calls} {} {
d4651 1
a4651 1
test io-50.6 {testing handler deletion vs reentrant calls} {} {
d4693 1
a4693 1
test io-51.1 {Test old socket deletion on Macintosh} {socket} {
d4731 1
a4731 1
test io-52.1 {TclCopyChannel} {
d4733 1
a4733 1
    set f1 [open $thisScript]
d4741 1
a4741 1
test io-52.2 {TclCopyChannel} {
d4743 1
a4743 1
    set f1 [open $thisScript]
d4745 1
a4745 1
    set f3 [open $thisScript]
d4753 1
a4753 1
test io-52.3 {TclCopyChannel} {
d4755 1
a4755 1
    set f1 [open $thisScript]
d4763 1
a4763 1
    set s1 [file size $thisScript]
d4770 1
a4770 1
test io-52.4 {TclCopyChannel} {
d4772 1
a4772 1
    set f1 [open $thisScript]
d4782 1
a4782 1
test io-52.5 {TclCopyChannel} {
d4784 1
a4784 1
    set f1 [open $thisScript]
d4792 1
a4792 1
    set s1 [file size $thisScript]
d4799 1
a4799 1
test io-52.6 {TclCopyChannel} {
d4801 1
a4801 1
    set f1 [open $thisScript]
d4805 1
a4805 1
    set s0 [fcopy $f1 $f2 -size [expr [file size $thisScript] + 5]]
d4809 1
a4809 1
    set s1 [file size $thisScript]
d4816 1
a4816 1
test io-52.7 {TclCopyChannel} {
d4818 1
a4818 1
    set f1 [open $thisScript]
d4824 1
a4824 1
    set s1 [file size $thisScript]
d4833 1
a4833 1
test io-52.8 {TclCopyChannel} {stdio} {
d4838 1
a4838 1
    puts $f1 "
d4841 5
a4845 5
	set f1 \[open [list $thisScript] r\]
	fconfigure \$f1 -translation lf
	puts \[read \$f1 100\]
	close \$f1
    "
d4847 1
a4847 1
    set f1 [open "|[list $::tcltest::tcltest pipe]" r+]
d4860 1
a4860 1
test io-53.1 {CopyData} {
d4862 1
a4862 1
    set f1 [open $thisScript]
d4872 1
a4872 1
test io-53.2 {CopyData} {
d4874 1
a4874 1
    set f1 [open $thisScript]
d4883 1
a4883 1
    set s1 [file size $thisScript]
d4890 1
a4890 1
test io-53.3 {CopyData: background read underflow} {unixOnly} {
d4905 1
a4905 1
    set f1 [open "|[list $::tcltest::tcltest pipe]" r+]
d4920 2
a4921 2
test io-53.4 {CopyData: background write overflow} {unixOnly} {
    set big bbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbb\n
d4938 1
a4938 1
    set f1 [open "|[list $::tcltest::tcltest pipe]" r+]
a4955 1
set result {}
d4968 18
a4985 16

test io-53.5 {CopyData: error during fcopy} {socket} {
    set listen [socket -server FcopyTestAccept 2828]
    set in [open $thisScript]	;# 126 K
    set out [socket 127.0.0.1 2828]
    catch {unset fcopyTestDone}
    close $listen	;# This means the socket open never really succeeds
    fcopy $in $out -command FcopyTestDone
    if ![info exists fcopyTestDone] {
	vwait fcopyTestDone		;# The error occurs here in the b.g.
    }
    close $in
    close $out
    set fcopyTestDone	;# 1 for error condition
} 1
test io-53.6 {CopyData: error during fcopy} {stdio} {
d4992 1
a4992 1
    set in [open "|[list $::tcltest::tcltest pipe]" r+]
d5003 1
a5003 1
test io-54.1 {Recursive channel events} {socket} {
d5055 1
a5055 3
test io-54.2 {Testing for busy-wait in recursive channel events} {socket} {
    set accept {}
    set after {}
d5058 1
a5058 1
	global counter accept
a5059 1
	set accept $s
d5065 1
a5065 1
	global counter after
d5071 1
a5071 1
	    set after [after 1000 newline]
d5075 1
a5075 1
	global counter accept
a5079 1
	set accept {}
d5084 1
a5084 1
	set writer [socket 127.0.0.1 3939]
a5099 2
    after cancel $after
    if {$accept != {}} {close $accept}
d5102 1
a5102 2

test io-55.1 {ChannelEventScriptInvoker: deletion} {
d5118 1
a5118 1
test io-56.1 {ChannelTimerProc} {
d5138 1
a5138 1
test io-57.1 {buffered data and file events, gets} {
d5143 1
a5143 1
    set s [socket 127.0.0.1 4040]
d5159 1
a5159 1
test io-57.2 {buffered data and file events, read} {
d5164 1
a5164 1
    set s [socket 127.0.0.1 4041]
d5181 1
a5181 1
test io-58.1 {Tcl_NotifyChannel and error when closing} {unixOrPc} {
d5199 1
a5199 1
    set pipe [open "|[list $::tcltest::tcltest] script" r]
a5206 19
# cleanup
foreach file [list fooBar longfile script output test1 pipe my_script foo \
	bar test2 test3 cat stdout] {
    ::tcltest::removeFile $file
}
::tcltest::restoreState
::tcltest::cleanupTests
return











d5208 11
d5220 1
d5222 2
@


1.1.1.3
log
@import tcl 8.4.0
@
text
@d15 1
a15 1
# RCS: @@(#) $Id: io.test,v 1.37 2002/07/30 18:36:26 andreas_kupries Exp $
d17 8
a24 2
if {[catch {package require tcltest 2}]} {
    puts stderr "Skipping tests in [info script].  tcltest 2 required."
a26 1
namespace eval ::tcl::test::io {
d28 1
a28 14
    namespace import ::tcltest::cleanupTests
    namespace import ::tcltest::interpreter
    namespace import ::tcltest::makeFile
    namespace import ::tcltest::removeFile
    namespace import ::tcltest::test
    namespace import ::tcltest::testConstraint
    namespace import ::tcltest::viewFile

testConstraint testchannel [llength [info commands testchannel]]
testConstraint exec [llength [info commands exec]]

# You need a *very* special environment to do some tests.  In
# particular, many file systems do not support large-files...
testConstraint largefileSupport 0
d33 2
d37 1
a37 2
set path(longfile) [makeFile {} longfile]
set f [open $path(longfile) w]
d46 1
a46 1
set path(cat) [makeFile {
d63 1
a63 1
} cat]
a77 3

set path(test1) [makeFile {} test1]

d79 1
a79 1
    set f [open $path(test1) w]
d83 1
a83 1
    contents $path(test1)
d86 1
a86 1
    set f [open $path(test1) w]
d90 1
a90 1
    contents $path(test1)
a92 16
set path(test2) [makeFile {} test2]

test io-1.8 {Tcl_WriteChars: WriteChars} {
    # This test written for SF bug #506297.
    #
    # Executing this test without the fix for the referenced bug
    # applied to tcl will cause tcl, more specifically WriteChars, to
    # go into an infinite loop.

    set f [open $path(test2) w] 
    fconfigure      $f -encoding iso2022-jp 
    puts -nonewline $f [format %s%c [string repeat " " 4] 12399] 
    close           $f 
    contents $path(test2)
} "    \x1b\$B\$O\x1b(B"

d96 1
a96 1
    set f [open $path(test1) w]
d100 1
a100 1
    contents $path(test1)
d106 1
a106 1
    set f [open $path(test1) w]
d109 1
a109 1
    set x [list [contents $path(test1)]]
d111 1
a111 1
    lappend x [contents $path(test1)]
d118 1
a118 1
    set f [open $path(test1) w]
d121 1
a121 1
    set x [contents $path(test1)]
d126 1
a126 1
    set f [open $path(test1) w]
d130 1
a130 1
    set x [list [contents $path(test1)]]
d132 1
a132 1
    lappend x [contents $path(test1)]
d138 1
a138 1
    set f [open $path(test1) w]
d142 1
a142 1
    contents $path(test1)
d148 1
a148 1
    set f [open $path(test1) w]
d151 1
a151 1
    set x [list [contents $path(test1)]]
d153 1
a153 1
    lappend x [contents $path(test1)]
d160 1
a160 1
    set f [open $path(test1) w]
d163 1
a163 1
    set x [contents $path(test1)]
d170 1
a170 1
    set f [open $path(test1) w]
d173 1
a173 1
    set x [list [contents $path(test1)]]
d175 1
a175 1
    lappend x [contents $path(test1)]
d182 1
a182 1
    set f [open $path(test1) w]
d185 1
a185 1
    set x [list [contents $path(test1)]]
d187 1
a187 1
    lappend x [contents $path(test1)]
d199 1
a199 1
    set f [open $path(test1) w]
d202 1
a202 1
    set x [list [contents $path(test1)]]
d204 1
a204 1
    lappend x [contents $path(test1)]
d213 1
a213 1
    set f [open $path(test1) w]
d216 1
a216 1
    set x [list [contents $path(test1)]]
d218 1
a218 1
    lappend x [contents $path(test1)]
d221 1
a221 1
    set f [open $path(test1) w]
d225 1
a225 1
    set x [list [contents $path(test1)]]
d227 1
a227 1
    lappend x [contents $path(test1)]
d233 1
a233 1
    set f [open $path(test1) w]
d236 1
a236 1
    set x [list [contents $path(test1)]]
d238 1
a238 1
    lappend x [contents $path(test1)]
d243 1
a243 1
    set f [open $path(test1) w]
d246 1
a246 1
    set x [list [contents $path(test1)]]
d248 1
a248 1
    lappend x [contents $path(test1)]
d253 1
a253 1
    set f [open $path(test1) w]
d256 1
a256 1
    set x [list [contents $path(test1)]]
d258 1
a258 1
    lappend x [contents $path(test1)]
d265 1
a265 1
    set f [open $path(test1) w]
d268 1
a268 1
    set x [list [contents $path(test1)]]
d270 1
a270 1
    lappend x [contents $path(test1)]
d275 1
a275 1
    set f [open $path(test1) w]
d279 1
a279 1
    set x [contents $path(test1)]
d283 1
a283 1
    set f [open $path(test1) w]
d286 1
a286 1
    set x [list [contents $path(test1)]]
d288 1
a288 1
    lappend x [contents $path(test1)]
d291 1
a291 1
    set f [open $path(test1) w]
d294 1
a294 1
    set x [list [contents $path(test1)]]
d296 1
a296 1
    lappend x [contents $path(test1)]
d299 1
a299 1
    set f [open $path(test1) w]
d302 1
a302 1
    set x [list [contents $path(test1)]]
d304 1
a304 1
    lappend x [contents $path(test1)]
d307 1
a307 1
    set f [open $path(test1) w]
d310 1
a310 1
    set x [list [contents $path(test1)]]
d312 1
a312 1
    lappend x [contents $path(test1)]
d315 1
a315 1
    set f [open $path(test1) w]
d318 1
a318 1
    set x [list [contents $path(test1)]]
d320 1
a320 1
    lappend x [contents $path(test1)]
d324 1
a324 1
    set f [open $path(test1) w]
d327 1
a327 1
    set f [open $path(test1)]
d338 1
a338 1
    set f [open $path(test1) w]
d342 1
a342 1
    set f [open $path(test1)]
d348 1
a348 1
    set f [open $path(test1) w]
d352 1
a352 1
    set f [open $path(test1)]
d359 1
a359 1
    set f [open $path(test1) w]
d363 1
a363 1
    set f [open $path(test1)]
d375 1
a375 1
    set f [open $path(test1) w]
d379 1
a379 1
    set f [open $path(test1)]
d387 1
a387 1
    set f [open "|[list [interpreter] cat]" w+]
d397 1
a397 1
    set f [open $path(test1) w]
d400 1
a400 1
    set f [open $path(test1)]
d407 1
a407 1
    set f [open $path(test1) w]
d410 1
a410 1
    set f [open $path(test1)]
d420 1
a420 1
    set f [open $path(test1) w]
d422 1
a422 1
    set f [open $path(test1)]
d429 1
a429 1
    set f [open $path(test1) w]
d433 1
a433 1
    set f [open $path(test1)]
d440 1
a440 1
    set f [open $path(test1) w]
d444 1
a444 1
    set f [open $path(test1)]
d451 1
a451 1
    set f [open $path(test1) w]
d455 1
a455 1
    set f [open $path(test1)]
d462 1
a462 1
    set f [open $path(test1) w]
d466 1
a466 1
    set f [open $path(test1)]
d473 1
a473 1
    set f [open $path(test1) w]
d477 1
a477 1
    set f [open $path(test1)]
d484 1
a484 1
    set f [open $path(test1) w]
d486 1
a486 1
    set f [open $path(test1)]
d493 1
a493 1
    set f [open $path(test1) w]
d497 1
a497 1
    set f [open $path(test1)]
d504 1
a504 1
    set f [open $path(test1) w]
d508 1
a508 1
    set f [open $path(test1)]
d515 1
a515 1
    set f [open $path(test1) w]
d519 1
a519 1
    set f [open $path(test1)]
d526 1
a526 1
    set f [open $path(test1) w]
d530 1
a530 1
    set f [open $path(test1)]
d537 1
a537 1
    set f [open $path(test1) w]
d541 1
a541 1
    set f [open $path(test1)]
d548 1
a548 1
    set f [open $path(test1) w]
d550 1
a550 1
    set f [open $path(test1)]
d557 1
a557 1
    set f [open $path(test1) w]
d561 1
a561 1
    set f [open $path(test1)]
d568 1
a568 1
    set f [open $path(test1) w]
d572 1
a572 1
    set f [open $path(test1)]
d579 1
a579 1
    set f [open $path(test1) w]
d583 1
a583 1
    set f [open $path(test1)]
d590 1
a590 1
    set f [open $path(test1) w]
d594 1
a594 1
    set f [open $path(test1)]
d601 1
a601 1
    set f [open $path(test1) w]
d605 1
a605 1
    set f [open $path(test1)]
d612 1
a612 1
    set f [open $path(test1) w]
d616 1
a616 1
    set f [open $path(test1)]
d623 1
a623 1
    set f [open $path(test1) w]
d627 1
a627 1
    set f [open $path(test1)]
d633 1
a633 1
test io-6.30 {Tcl_GetsObj: crlf mode: buffer exhausted} {testchannel} {
d636 1
a636 1
    set f [open $path(test1) w]
d640 1
a640 1
    set f [open $path(test1)]
d646 1
a646 1
test io-6.31 {Tcl_GetsObj: crlf mode: buffer exhausted, blocked} {stdio testchannel} {
d649 1
a649 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d659 1
a659 1
test io-6.32 {Tcl_GetsObj: crlf mode: buffer exhausted, more data} {testchannel} {
d662 1
a662 1
    set f [open $path(test1) w]
d666 1
a666 1
    set f [open $path(test1)]
d675 1
a675 1
    set f [open $path(test1) w]
d679 1
a679 1
    set f [open $path(test1)]
d688 1
a688 1
    set f [open $path(test1) w]
d692 1
a692 1
    set f [open $path(test1)]
d699 1
a699 1
    set f [open $path(test1) w]
d701 1
a701 1
    set f [open $path(test1)]
d708 1
a708 1
    set f [open $path(test1) w]
d712 1
a712 1
    set f [open $path(test1)]
d719 1
a719 1
    set f [open $path(test1) w]
d723 1
a723 1
    set f [open $path(test1)]
d730 1
a730 1
    set f [open $path(test1) w]
d734 1
a734 1
    set f [open $path(test1)]
d741 1
a741 1
    set f [open $path(test1) w]
d745 1
a745 1
    set f [open $path(test1)]
d752 1
a752 1
    set f [open $path(test1) w]
d756 1
a756 1
    set f [open $path(test1)]
d763 1
a763 1
    set f [open $path(test1) w]
d767 1
a767 1
    set f [open $path(test1)]
d774 1
a774 1
    set f [open $path(test1) w]
d778 1
a778 1
    set f [open $path(test1)]
d785 1
a785 1
test io-6.43 {Tcl_GetsObj: input saw cr} {stdio testchannel} {
d788 1
a788 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d802 1
a802 1
test io-6.44 {Tcl_GetsObj: input saw cr, not followed by cr} {stdio testchannel} {
d805 1
a805 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d819 1
a819 1
test io-6.45 {Tcl_GetsObj: input saw cr, skip right number of bytes} {stdio testchannel} {
d822 1
a822 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d836 1
a836 1
test io-6.46 {Tcl_GetsObj: input saw cr, followed by just \n should give eof} {stdio testchannel} {
d839 1
a839 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d852 1
a852 1
test io-6.47 {Tcl_GetsObj: auto mode: \r at end of buffer, peek for \n} {testchannel} {
d855 1
a855 1
    set f [open $path(test1) w]
d859 1
a859 1
    set f [open $path(test1)]
d865 1
a865 1
test io-6.48 {Tcl_GetsObj: auto mode: \r at end of buffer, no more avail} {testchannel} {
d868 1
a868 1
    set f [open $path(test1) w]
d872 1
a872 1
    set f [open $path(test1)]
d878 1
a878 1
test io-6.49 {Tcl_GetsObj: auto mode: \r followed by \n} {testchannel} {
d881 1
a881 1
    set f [open $path(test1) w]
d885 1
a885 1
    set f [open $path(test1)]
d890 1
a890 1
test io-6.50 {Tcl_GetsObj: auto mode: \r not followed by \n} {testchannel} {
d893 1
a893 1
    set f [open $path(test1) w]
d897 1
a897 1
    set f [open $path(test1)]
d905 1
a905 1
    set f [open $path(test1) w]
d909 1
a909 1
    set f [open $path(test1)]
d914 1
a914 1
test io-6.52 {Tcl_GetsObj: saw EOF character} {testchannel} {
d917 1
a917 1
    set f [open $path(test1) w]
d921 1
a921 1
    set f [open $path(test1)]
d930 1
a930 1
    set f [open $path(test1) w]
d932 1
a932 1
    set f [open $path(test1)]
d940 1
a940 1
    set f [open $path(test1) w]
d943 1
a943 1
    set f [open $path(test1)]
d951 1
a951 1
    set f [open $path(test1) w]
d955 1
a955 1
    set f [open $path(test1)]
d963 1
a963 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d967 5
a971 5
    variable x {}
    after 500 [namespace code { lappend x timeout }]
    fileevent $f readable [namespace code { lappend x [gets $f] }]
    vwait [namespace which -variable x]
    vwait [namespace which -variable x]
d974 1
a974 1
    after 500 [namespace code { lappend x timeout }]
d976 2
a977 2
    vwait [namespace which -variable x]
    vwait [namespace which -variable x]
d985 1
a985 1
    set f [open $path(test1) w]
d989 1
a989 1
    set f [open $path(test1)]
d998 1
a998 1
    set f [open $path(test1) w]
d1002 1
a1002 1
    set f [open $path(test1)]
d1008 2
a1009 2
test io-7.3 {FilterInputBytes: split up character at EOF} {testchannel} {
    set f [open $path(test1) w]
d1013 1
a1013 1
    set f [open $path(test1)]
d1022 1
a1022 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d1026 2
a1027 2
    fileevent $f read [namespace code "ready $f"]
    variable x {}
d1029 1
a1029 2
	variable x
	lappend x [gets $f line] $line [fblocked $f]
d1031 1
a1031 1
    vwait [namespace which -variable x]
d1035 1
a1035 1
    vwait [namespace which -variable x]
d1040 1
a1040 1
test io-8.1 {PeekAhead: only go to device if no more cached data} {testchannel} {
d1043 1
a1043 1
    set f [open $path(test1) w]
d1047 1
a1047 1
    set f [open $path(test1)]
d1055 1
a1055 1
test io-8.2 {PeekAhead: only go to device if no more cached data} {stdio testchannel} {
d1058 1
a1058 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d1061 2
a1062 2
    variable x {}
    fileevent $f read [namespace code "ready $f"]
d1064 1
a1064 2
	variable x
	lappend x [gets $f line] $line [testchannel inputbuffered $f]
d1067 1
a1067 1
    vwait [namespace which -variable x]
d1070 1
a1070 1
    vwait [namespace which -variable x]
d1074 1
a1074 1
test io-8.3 {PeekAhead: no cached data available} {stdio testchannel} {
d1077 1
a1077 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d1091 1
a1091 1
    set f [open $path(test1) w+]
d1095 1
a1095 1
    set f [open $path(test1)]
d1107 1
a1107 1
test io-8.5 {PeekAhead: don't peek if last read was short} {stdio testchannel} {
d1110 1
a1110 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d1119 1
a1119 1
test io-8.6 {PeekAhead: change to non-blocking mode} {stdio testchannel} {
d1122 1
a1122 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d1131 1
a1131 1
test io-8.7 {PeekAhead: cleanup} {stdio testchannel} {
d1134 1
a1134 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d1156 1
a1156 1
    set f [open $path(test1) w]
d1160 1
a1160 1
    set f [open $path(test1)]
d1169 1
a1169 1
    set f [open $path(test1) w]
d1173 1
a1173 1
    set f [open $path(test1)]
d1183 1
a1183 1
    set f [open $path(test1) w]
d1187 1
a1187 1
    set f [open $path(test1)]
d1196 1
a1196 1
    set f [open $path(test1) w]
d1200 1
a1200 1
    set f [open $path(test1)]
d1210 1
a1210 1
    set f [open $path(test1) w]
d1213 1
a1213 1
    set f [open $path(test1)]
d1223 1
a1223 1
    set f [open $path(test1) w]
d1226 1
a1226 1
    set f [open $path(test1)]
d1236 1
a1236 1
    set f [open $path(test1) w]
d1239 1
a1239 1
    set f [open $path(test1)]
d1249 1
a1249 1
    set f [open $path(test1) w]
d1252 1
a1252 1
    set f [open $path(test1)]
d1263 1
a1263 1
    set f [open $path(test1) w]
d1266 1
a1266 1
    set f [open $path(test1)]
d1275 1
a1275 1
    set f [open $path(test1) w]
d1278 1
a1278 1
    set f [open $path(test1)]
d1287 1
a1287 1
    set f [open $path(test1) w]
d1290 1
a1290 1
    set f [open $path(test1)]
d1297 1
a1297 1
test io-12.4 {ReadChars: split-up char} {stdio testchannel} {
d1300 1
a1300 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d1305 1
a1305 1
    fileevent $f read [namespace code "ready $f"]
d1307 1
a1307 2
	variable x
	lappend x [read $f] [testchannel inputbuffered $f]
d1309 1
a1309 1
    variable x {}
d1312 1
a1312 1
    vwait [namespace which -variable x]
d1317 1
a1317 1
    vwait [namespace which -variable x]
d1322 1
a1322 1
    set path(test1) [makeFile {
d1327 3
a1329 3
    } test1]
    set f [open "|[list [interpreter] $path(test1)]" r+]
    fileevent $f readable [namespace code {
d1334 1
a1334 1
    }]
d1338 4
a1341 4
    variable x {}
    vwait [namespace which -variable x]
    after 500 [namespace code { lappend x timeout }]
    vwait [namespace which -variable x]
d1344 3
a1346 3
    vwait [namespace which -variable x]
    after 500 [namespace code { lappend x timeout }]
    vwait [namespace which -variable x]
d1349 2
a1350 2
    vwait [namespace which -variable x]
    vwait [namespace which -variable x]
d1356 1
a1356 1
    set f [open $path(test1) w]
d1360 1
a1360 1
    set f [open $path(test1)]
d1367 1
a1367 1
    set f [open $path(test1) w]
d1371 1
a1371 1
    set f [open $path(test1)]
d1380 1
a1380 1
    set f [open $path(test1) w]
d1384 1
a1384 1
    set f [open $path(test1)]
d1393 1
a1393 1
    set f [open $path(test1) w]
d1397 1
a1397 1
    set f [open $path(test1)]
d1406 1
a1406 1
    set f [open $path(test1) w]
d1410 1
a1410 1
    set f [open $path(test1)]
d1416 1
a1416 1
test io-13.6 {TranslateInputEOL: auto mode: saw cr in last segment} {stdio testchannel} {
d1420 1
a1420 1
    set f [open "|[list [interpreter] $path(cat)]" w+]
d1423 1
a1423 1
    fileevent $f read [namespace code "ready $f"]
d1425 1
a1425 2
	variable x
	lappend x [read $f] [testchannel queuedcr $f]
d1427 1
a1427 2
    variable x {}
    variable y {}
d1430 2
a1431 2
    after 500 [namespace code {set y ok}]
    vwait [namespace which -variable y]
d1434 2
a1435 2
    after 500 [namespace code {set y ok}]
    vwait [namespace which -variable y]
d1440 1
a1440 1
test io-13.7 {TranslateInputEOL: auto mode: naked \r} {testchannel} {
d1443 1
a1443 1
    set f [open $path(test1) w]
d1447 1
a1447 1
    set f [open $path(test1)]
d1456 1
a1456 1
    set f [open $path(test1) w]
d1460 1
a1460 1
    set f [open $path(test1)]
d1467 1
a1467 1
    set f [open $path(test1) w]
d1471 1
a1471 1
    set f [open $path(test1)]
d1480 1
a1480 1
    set f [open $path(test1) w]
d1484 1
a1484 1
    set f [open $path(test1)]
d1493 1
a1493 1
    set f [open $path(test1) w]
d1497 1
a1497 1
    set f [open $path(test1)]
d1506 1
a1506 1
    set f [open $path(test1) w]
d1510 1
a1510 1
    set f [open $path(test1)]
d1521 2
a1522 6
if {[info commands testchannel] != ""} {
    if {$tcl_platform(platform) == "macintosh"} {
	set consoleFileNames [list console0 console1 console2]
    } else {
	set consoleFileNames [lsort [testchannel open]]
    }
d1524 1
a1524 2
    # just to avoid an error
    set consoleFileNames [list]
d1526 1
a1526 2

test io-14.1 {Tcl_SetStdChannel and Tcl_GetStdChannel} {testchannel} {
d1543 3
a1545 6

set path(test3) [makeFile {} test3]

test io-14.3 {Tcl_SetStdChannel & Tcl_GetStdChannel} {exec} {
    set f [open $path(test1) w]
    puts $f [format {
d1549 3
a1551 3
	set f  [open "%s" r]
	set f2 [open "%s" w]
	set f3 [open "%s" w]
d1558 1
a1558 1
    } $path(test1) $path(test2) $path(test3)]
d1560 3
a1562 3
    set result [exec [interpreter] $path(test1)]
    set f  [open $path(test2) r]
    set f2 [open $path(test3) r]
d1572 3
a1574 3
test io-14.4 {Tcl_SetStdChannel & Tcl_GetStdChannel} {exec unixOnly} {
    set f [open $path(test1) w]
    puts $f [format { close stdin
d1577 3
a1579 3
	set f  [open "%s" r]
	set f2 [open "%s" w]
	set f3 [open "%s" w]
d1586 1
a1586 1
    } $path(test1) $path(test2) $path(test3)]
d1588 3
a1590 3
    set result [exec [interpreter] $path(test1)]
    set f  [open $path(test2) r]
    set f2 [open $path(test3) r]
a1629 3

set path(script) [makeFile {} script]

d1633 2
a1634 2
    set f [open $path(script) w]
    puts $f [format {
d1636 1
a1636 1
	set f [open "%s" w]
d1639 1
a1639 1
	set f [open "%s" r]
d1641 1
a1641 1
    } $path(test1) $path(test1)]
d1643 1
a1643 1
    set f [open "|[list [interpreter] $path(script)]" r]
a1647 1

d1651 1
a1651 1
    set f [open $path(script) w]
d1653 1
a1653 2
        array set path [lindex $argv 0]
	set f [open $path(test1) w]
d1657 1
a1657 1
	set f [open "|[list [info nameofexecutable] $path(cat) $path(test1)]" r]
d1661 1
a1661 1
    set f [open "|[list [interpreter] $path(script) [array get path]]" r]
d1680 1
a1680 1
test io-17.1 {GetChannelTable, DeleteChannelTable on std handles} {testchannel} {
d1692 1
a1692 1
test io-17.2 {GetChannelTable, DeleteChannelTable on std handles} {testchannel} {
d1704 1
a1704 1
test io-17.3 {GetChannelTable, DeleteChannelTable on std handles} {testchannel} {
d1717 1
a1717 1
test io-18.1 {Tcl_RegisterChannel, Tcl_UnregisterChannel} {testchannel} {
d1720 1
a1720 1
    set f [open $path(test1) w]
d1731 1
a1731 1
test io-18.2 {Tcl_RegisterChannel, Tcl_UnregisterChannel} {testchannel} {
d1734 1
a1734 1
    set f [open $path(test1) w]
d1752 1
a1752 1
test io-18.3 {Tcl_RegisterChannel, Tcl_UnregisterChannel} {testchannel} {
d1755 1
a1755 1
    set f [open $path(test1) w]
d1777 1
a1777 1
    set f [open $path(test1) w]
d1785 1
a1785 1
test io-19.4 {Tcl_CreateChannel, insertion into channel table} {testchannel} {
d1787 1
a1787 1
    set f [open $path(test1) w]
d1801 1
a1801 1
	set a [open $path(test2) w]
d1804 1
a1804 1
    set f [open $path(test1) w]
d1812 1
a1812 1
    set f [open $path(test1) w+]
d1818 1
a1818 1
    set f [open $path(test1) w+]
d1824 1
a1824 1
    set f [open $path(test1) w+]
a1828 3

set path(stdout) [makeFile {} stdout]

d1830 2
a1831 2
    set f [open $path(script) w]
    puts $f [format {
d1833 1
a1833 1
	set f1 [open "%s" w]
d1836 1
a1836 1
    } $path(stdout)]
d1838 1
a1838 1
    set f [open "|[list [interpreter] $path(script)]"]
d1856 1
a1856 1
test io-23.1 {Tcl_GetChannelName} {testchannel} {
d1858 1
a1858 1
    set f [open $path(test1) w]
d1864 1
a1864 1
test io-24.1 {Tcl_GetChannelType} {testchannel} {
d1866 1
a1866 1
    set f [open $path(test1) w]
d1872 2
a1873 2
test io-25.1 {Tcl_GetChannelHandle, input} {testchannel} {
    set f [open $path(test1) w]
d1877 1
a1877 1
    set f [open $path(test1) r]
d1885 1
a1885 1
test io-25.2 {Tcl_GetChannelHandle, output} {testchannel} {
d1887 1
a1887 1
    set f [open $path(test1) w]
d1905 1
a1905 1
    set f [open "|[list [interpreter] << exit]"]
d1914 1
a1914 1
    set f [open $path(test1) w]
d1916 1
a1916 1
    set s [file size $path(test1)]
d1922 1
a1922 1
    set f [open $path(test1) w]
d1926 1
a1926 1
    lappend l [file size $path(test1)]
d1928 1
a1928 1
    lappend l [file size $path(test1)]
d1930 1
a1930 1
    lappend l [file size $path(test1)]
d1935 1
a1935 1
    set f [open $path(test1) w]
d1939 1
a1939 1
    lappend l [file size $path(test1)]
d1941 1
a1941 1
    lappend l [file size $path(test1)]
d1946 1
a1946 1
    set f [open $path(test1) w]
d1950 1
a1950 1
    lappend l [file size $path(test1)]
d1954 1
a1954 1
    lappend l [file size $path(test1)]
d1956 1
a1956 1
    lappend l [file size $path(test1)]
d1963 1
a1963 1
    set f [open $path(test1) w]
d1966 1
a1966 1
    lappend l [file size $path(test1)]
d1970 1
a1970 1
    lappend l [file size $path(test1)]
d1972 1
a1972 1
    lappend l [file size $path(test1)]
a1974 4

set path(pipe)   [makeFile {} pipe]
set path(output) [makeFile {} output]

d1979 3
a1981 3
    set f [open $path(pipe) w]
    puts $f [format {
	set f [open "%s" w]
d1988 1
a1988 1
    } $path(output)]
d1994 1
a1994 1
    set f [open $path(output) w]
d1996 1
a1996 1
    set f [open "|[list [interpreter] $path(pipe)]" w]
d2001 1
a2001 1
    while {([file size $path(output)] < 65536) && ($counter < 1000)} {
d2007 1
a2007 1
        set result "file size only [file size $path(output)]"
d2015 1
a2015 1
test io-28.1 {CloseChannel called when all references are dropped} {testchannel} {
d2017 1
a2017 1
    set f [open $path(test1) w]
d2030 1
a2030 1
    set f [open $path(test1) w]
d2038 1
a2038 1
    set f [open $path(test1) r]
d2047 1
a2047 1
    set f [open $path(pipe) w]
d2057 1
a2057 1
	set f [open $path(output) w]
d2070 1
a2070 1
    set f [open $path(output) w]
d2072 1
a2072 1
    set f [open "|[list [interpreter] pipe]" r+]
d2078 1
a2078 1
    while {([file size $path(output)] < 20480) && ($counter < 1000)} {
d2089 1
a2089 1
test io-28.4 {Tcl_Close} {testchannel} {
d2093 1
a2093 1
    set f [open $path(test1) w]
d2102 1
a2102 1
test io-28.5 {Tcl_Close vs standard handles} {stdio unixOnly testchannel} {
d2104 1
a2104 1
    set f [open $path(script) w]
d2110 1
a2110 1
    set f [open "|[list [interpreter] $path(script)]" r]
d2121 1
a2121 1
    set f [open $path(test1) w]
d2125 1
a2125 1
    file size $path(test1)
d2129 1
a2129 1
    set f [open $path(test1) w]
d2133 1
a2133 1
    file size $path(test1)
d2135 1
a2135 1
test io-29.4 {Tcl_WriteChars, buffering in full buffering mode} {testchannel} {
d2137 1
a2137 1
    set f [open $path(test1) w]
d2142 1
a2142 1
    lappend l [file size $path(test1)]
d2145 1
a2145 1
    lappend l [file size $path(test1)]
d2149 1
a2149 1
test io-29.5 {Tcl_WriteChars, buffering in line buffering mode} {testchannel} {
d2151 1
a2151 1
    set f [open $path(test1) w]
d2156 1
a2156 1
    lappend l [file size $path(test1)]
d2159 1
a2159 1
    lappend l [file size $path(test1)]
d2163 1
a2163 1
test io-29.6 {Tcl_WriteChars, buffering in no buffering mode} {testchannel} {
d2165 1
a2165 1
    set f [open $path(test1) w]
d2170 1
a2170 1
    lappend l [file size $path(test1)]
d2173 1
a2173 1
    lappend l [file size $path(test1)]
d2178 1
a2178 1
test io-29.7 {Tcl_Flush, full buffering} {testchannel} {
d2180 1
a2180 1
    set f [open $path(test1) w]
d2185 1
a2185 1
    lappend l [file size $path(test1)]
d2188 1
a2188 1
    lappend l [file size $path(test1)]
d2191 1
a2191 1
    lappend l [file size $path(test1)]
d2195 1
a2195 1
test io-29.8 {Tcl_Flush, full buffering} {testchannel} {
d2197 1
a2197 1
    set f [open $path(test1) w]
d2202 1
a2202 1
    lappend l [file size $path(test1)]
d2205 1
a2205 1
    lappend l [file size $path(test1)]
d2208 1
a2208 1
    lappend l [file size $path(test1)]
d2211 1
a2211 1
    lappend l [file size $path(test1)]
d2220 1
a2220 1
    set f1 [open $path(test1) w]
d2222 1
a2222 1
    set f2 [open $path(longfile) r]
d2228 1
a2228 1
    file size $path(test1)
d2232 1
a2232 1
    set f1 [open $path(test1) w]
d2234 1
a2234 1
    set f2 [open $path(longfile) r]
d2240 1
a2240 1
    file size $path(test1)
d2245 3
a2247 3
    set f1 [open $path(pipe) w]
    puts $f1 [format {
	set f1 [open "%s" r]
d2251 1
a2251 1
    } $path(longfile)]
d2253 2
a2254 2
    set f1 [open "|[list [interpreter] $path(pipe)]" r]
    set f2 [open $path(longfile) r]
d2270 1
a2270 1
    set f1 [open $path(pipe) w]
d2277 1
a2277 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d2279 1
a2279 1
    set f2 [open $path(longfile) r]
d2298 1
a2298 1
    set f [open $path(test3) w]
d2303 1
a2303 1
    set f [open $path(test3) r]
d2310 1
a2310 1
    set fd [open $path(test1) w]
d2312 1
a2312 1
    set fd [open $path(test1) r]
d2319 1
a2319 1
    set fd [open "|[list [interpreter] cat longfile]" r]
d2327 1
a2327 1
    set f1 [open $path(test1) w]
d2333 1
a2333 1
    set x [file size $path(test1)]
d2340 1
a2340 1
    set f1 [open $path(test1) w]
d2346 1
a2346 1
    lappend x [file size $path(test1)]
d2349 1
a2349 1
    lappend x [file size $path(test1)]
d2352 1
a2352 1
    lappend x [file size $path(test1)]
d2358 1
a2358 1
    set f1 [open $path(test1) w]
d2365 1
a2365 1
    lappend x [file size $path(test1)]
d2368 1
a2368 1
    lappend x [file size $path(test1)]
d2371 1
a2371 1
    lappend x [file size $path(test1)]
d2376 1
a2376 1
    set f1 [open $path(test1) w]
d2383 1
a2383 1
    lappend z [file size $path(test1)]
d2387 1
a2387 1
    lappend z [file size $path(test1)]
d2389 1
a2389 1
    lappend z [file size $path(test1)]
d2394 1
a2394 1
    set f1 [open $path(pipe) w]
d2399 1
a2399 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d2408 1
a2408 1
    set f1 [open $path(pipe) w]
d2419 1
a2419 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d2431 1
a2431 1
    set f1 [open $path(pipe) w]
d2439 1
a2439 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d2450 1
a2450 1
    set f [open $path(test3) w]
d2453 1
a2453 1
    set f2 [open $path(test3)]
d2458 1
a2458 1
    set f2 [open $path(test3)]
d2466 1
a2466 1
    set f [open "|[list [interpreter] $path(cat) | [interpreter] $path(cat) > $path(test3)]" w]
d2471 1
a2471 1
    set f [open $path(test3) r]
d2486 1
a2486 1
    set f [open $path(pipe) w]
d2489 1
a2489 1
    set f [open "|[list [interpreter] $path(pipe)]" r+]
d2514 1
a2514 1
    set f [open $path(test1) w]
d2518 1
a2518 1
    set s [file size $path(test1)]
d2524 1
a2524 1
    set f [open $path(test1) w]
d2528 1
a2528 1
    file size $path(test1)
d2532 1
a2532 1
    set f [open $path(test1) w]
d2536 1
a2536 1
    file size $path(test1)
d2541 2
a2542 2
    set f [open $path(pipe) w]
    puts $f [format {set f [open "%s" w]} $path(output)]
d2556 1
a2556 1
    set f [open $path(output) w]
d2558 1
a2558 1
    set f [open "|[list [interpreter] $path(pipe)]" r+]
d2563 1
a2563 1
    while {([file size $path(output)] < 65536) && ($counter < 1000)} {
d2569 1
a2569 1
	set result "file size only [file size $path(output)]"
d2578 2
a2579 2
    set f [open $path(pipe) w]
    puts $f [format {set f [open "%s" w]} $path(output)]
d2594 1
a2594 1
    set f [open $path(output) w]
d2596 1
a2596 1
    set f [open "|[list [interpreter] $path(pipe)]" r+]
d2601 1
a2601 1
    while {([file size $path(output)] < 65536) && ($counter < 1000)} {
d2607 1
a2607 1
	set result "file size only [file size $path(output)]"
d2612 4
a2615 4
test io-29.33 {Tcl_Flush, implicit flush on exit} {exec} {
    set f [open $path(script) w]
    puts $f [format {
	set f [open "%s" w]
d2620 1
a2620 1
    } $path(test1)]
d2622 2
a2623 2
    exec [interpreter] $path(script)
    set f [open $path(test1) r]
d2630 1
a2630 1
    variable x running
d2638 2
a2639 2
	variable x
	fileevent $s readable [namespace code [list readit $s]]
d2644 1
a2644 2
	variable c
	variable x
d2654 3
a2656 3
    set ss [socket -server [namespace code accept] 0]
    set cs [socket [info hostname] [lindex [fconfigure $ss -sockname] 2]]
    vwait [namespace which -variable x]
d2661 1
a2661 1
    vwait [namespace which -variable x]
d2672 1
a2672 1
    set s [socket -server [namespace code accept] 0]
d2677 1
a2677 1
    set c [socket [info hostname] [lindex [fconfigure $s -sockname] 2]]
d2710 1
a2710 1
    set f [open $path(test1) w]
d2714 1
a2714 1
    set f [open $path(test1) r]
d2722 1
a2722 1
    set f [open $path(test1) w]
d2726 1
a2726 1
    set f [open $path(test1) r]
d2734 1
a2734 1
    set f [open $path(test1) w]
d2738 1
a2738 1
    set f [open $path(test1) r]
d2746 1
a2746 1
    set f [open $path(test1) w]
d2750 1
a2750 1
    set f [open $path(test1) r]
d2758 1
a2758 1
    set f [open $path(test1) w]
d2762 1
a2762 1
    set f [open $path(test1) r]
d2770 1
a2770 1
    set f [open $path(test1) w]
d2774 1
a2774 1
    set f [open $path(test1) r]
d2782 1
a2782 1
    set f [open $path(test1) w]
d2786 1
a2786 1
    set f [open $path(test1) r]
d2794 1
a2794 1
    set f [open $path(test1) w]
d2798 1
a2798 1
    set f [open $path(test1) r]
d2806 1
a2806 1
    set f [open $path(test1) w]
d2810 1
a2810 1
    set f [open $path(test1) r]
d2818 1
a2818 1
    set f [open $path(test1) w]
d2822 1
a2822 1
    set f [open $path(test1) r]
d2834 1
a2834 1
    set f [open $path(test1) w]
d2838 1
a2838 1
    set f [open $path(test1) r]
d2850 1
a2850 1
    set f [open $path(test1) w]
d2854 1
a2854 1
    set f [open $path(test1) r]
d2867 1
a2867 1
    set f [open $path(test1) w]
d2875 1
a2875 1
    set f [open $path(test1) r]
d2884 1
a2884 1
    set f [open $path(test1) w]
d2892 1
a2892 1
    set f [open $path(test1) r]
d2901 1
a2901 1
    set f [open $path(test1) w]
d2905 1
a2905 1
    set f [open $path(test1) r]
d2917 1
a2917 1
    set f [open $path(test1) w]
d2921 1
a2921 1
    set f [open $path(test1) r]
d2933 1
a2933 1
    set f [open $path(test1) w]
d2937 1
a2937 1
    set f [open $path(test1) r]
d2949 1
a2949 1
    set f [open $path(test1) w]
d2954 1
a2954 1
    set f [open $path(test1) r]
d2969 1
a2969 1
    set f [open $path(test1) w]
d2974 1
a2974 1
    set f [open $path(test1) r]
d2989 1
a2989 1
    set f [open $path(test1) w]
d2994 1
a2994 1
    set f [open $path(test1) r]
d3011 1
a3011 1
    set f [open $path(test1) w]
d3016 1
a3016 1
    set f [open $path(test1) r]
d3029 1
a3029 1
    set f [open $path(test1) w]
d3034 1
a3034 1
    set f [open $path(test1) r]
d3047 1
a3047 1
    set f [open $path(test1) w]
d3052 1
a3052 1
    set f [open $path(test1) r]
d3061 1
a3061 1
    set f [open $path(test1) w]
d3066 1
a3066 1
    set f [open $path(test1) r]
d3075 1
a3075 1
    set f [open $path(test1) w]
d3080 1
a3080 1
    set f [open $path(test1) r]
d3089 1
a3089 1
    set f [open $path(test1) w]
d3094 1
a3094 1
    set f [open $path(test1) r]
d3103 1
a3103 1
    set f [open $path(test1) w]
d3108 1
a3108 1
    set f [open $path(test1) r]
d3117 1
a3117 1
    set f [open $path(test1) w]
d3122 1
a3122 1
    set f [open $path(test1) r]
d3134 1
a3134 1
    set f [open $path(test1) w]
d3138 1
a3138 1
    set f [open $path(test1) r]
d3151 1
a3151 1
    set f [open $path(test1) w]
d3155 1
a3155 1
    set f [open $path(test1) r]
d3168 1
a3168 1
    set f [open $path(test1) w]
d3172 1
a3172 1
    set f [open $path(test1) r]
d3185 1
a3185 1
    set f [open $path(test1) w]
d3189 1
a3189 1
    set f [open $path(test1) r]
d3203 1
a3203 1
    set f [open $path(test1) w]
d3207 1
a3207 1
    set f [open $path(test1) r]
d3223 1
a3223 1
    set f [open $path(test1) w]
d3227 1
a3227 1
    set f [open $path(test1) r]
d3243 1
a3243 1
    set f [open $path(test1) w]
d3247 1
a3247 1
    set f [open $path(test1) r]
d3263 1
a3263 1
    set f [open $path(test1) w]
d3267 1
a3267 1
    set f [open $path(test1) r]
d3283 1
a3283 1
    set f [open $path(test1) w]
d3287 1
a3287 1
    set f [open $path(test1) r]
d3303 1
a3303 1
    set f [open $path(test1) w]
d3307 1
a3307 1
    set f [open $path(test1) r]
d3323 1
a3323 1
    set f [open $path(test1) w]
d3327 1
a3327 1
    set f [open $path(test1) r]
d3343 1
a3343 1
    set f [open $path(test1) w]
d3347 1
a3347 1
    set f [open $path(test1) r]
d3363 1
a3363 1
    set f [open $path(test1) w]
d3375 1
a3375 1
    set f [open $path(test1) w]
d3379 1
a3379 1
    set f [open $path(test1) r]
d3394 1
a3394 1
    set f [open $path(test1) w]
d3398 1
a3398 1
    set f [open $path(test1) r]
d3413 1
a3413 1
    set f [open $path(test1) w]
d3417 1
a3417 1
    set f [open $path(test1) r]
d3431 1
a3431 1
    set f [open $path(test1) w]
d3435 1
a3435 1
    set f [open $path(test1) r]
d3450 1
a3450 1
    set f [open $path(test1) w]
d3455 1
a3455 1
    set f [open $path(test1) r]
d3470 1
a3470 1
    set f [open $path(test1) w]
d3474 1
a3474 1
    set f [open $path(test1) r]
d3489 1
a3489 1
    set f [open $path(test1) w]
d3494 1
a3494 1
    set f [open $path(test1) r]
d3508 1
a3508 1
    set f [open $path(test1) w]
d3513 1
a3513 1
    set f [open $path(test1) r]
d3526 1
a3526 1
    set f [open $path(test1) w]
d3531 1
a3531 1
    set f [open $path(test1) r]
d3548 1
a3548 1
    set f [open $path(test1) w]
d3553 1
a3553 1
    set f [open $path(test1) r]
d3570 1
a3570 1
    set f [open $path(test1) w]
d3575 1
a3575 1
    set f [open $path(test1) r]
d3592 1
a3592 1
    set f [open $path(test1) w]
d3597 1
a3597 1
    set f [open $path(test1) r]
d3610 1
a3610 1
    set f [open $path(test1) w]
d3615 1
a3615 1
    set f [open $path(test1) r]
d3628 1
a3628 1
    set f [open $path(test1) w]
d3633 1
a3633 1
    set f [open $path(test1) r]
d3646 1
a3646 1
    set f [open $path(test1) w]
d3651 1
a3651 1
    set f [open $path(test1) r]
d3664 1
a3664 1
    set f [open $path(test1) w]
d3669 1
a3669 1
    set f [open $path(test1) r]
d3682 1
a3682 1
    set f [open $path(test1) w]
d3687 1
a3687 1
    set f [open $path(test1) r]
d3700 1
a3700 1
    set f [open $path(test1) w]
d3708 1
a3708 1
    set f [open $path(test1) r]
d3719 1
a3719 1
    set f [open $path(test1) w]
d3727 1
a3727 1
    set f [open $path(test1) r]
d3747 1
a3747 1
    set f [open $path(longfile) r]
d3753 1
a3753 1
    set f [open $path(longfile) r]
d3761 1
a3761 1
    set f [open $path(longfile) r]
d3770 1
a3770 1
    set f1 [open $path(longfile) r]
d3775 1
a3775 1
    set z [file size $path(longfile)]
d3782 1
a3782 1
    set f1 [open $path(longfile) r]
d3794 1
a3794 1
    set f1 [open $path(longfile) r]
d3799 2
a3800 2
    set l [string length $z]
    set z [file size $path(longfile)]
d3804 1
a3804 1
    set x
d3807 1
a3807 1
    set f1 [open $path(longfile) r]
d3812 1
a3812 1
    set z [file size $path(longfile)]
d3820 1
a3820 1
    set f1 [open $path(pipe) w]
d3823 1
a3823 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d3832 1
a3832 1
    set f1 [open $path(pipe) w]
d3836 1
a3836 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d3851 1
a3851 1
    set f1 [open $path(test1) w]
d3855 1
a3855 1
    set f1 [open $path(test1) r]
d3863 1
a3863 1
    set f1 [open $path(test1) w]
d3867 1
a3867 1
    set f1 [open $path(test1) r]
d3875 1
a3875 1
    set f [open $path(test1) w]
d3879 1
a3879 1
    set f [open $path(test1)]
d3888 1
a3888 1
    set f [open $path(test1) w]
d3892 1
a3892 1
    set f [open $path(test1)]
d3901 1
a3901 1
    set f [open $path(test1) w]
d3905 1
a3905 1
    set f [open $path(test1)]
d3916 1
a3916 1
    set f1 [open $path(test1) w]
d3920 1
a3920 1
    set f1 [open $path(test1) r]
d3930 1
a3930 1
    set f1 [open $path(longfile) r]
d3942 1
a3942 1
    set f1 [open $path(pipe) w]
d3945 1
a3945 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d3958 1
a3958 1
    set f [open $path(test3) w]
d3965 1
a3965 1
    set f [open $path(test3)]
d3971 1
a3971 1
    set f [open $path(test3)]
d3978 1
a3978 1
    set f [open $path(test3) w]
d3981 1
a3981 1
    set f [open $path(test3)]
d3993 1
a3993 1
    set f [open $path(test3) w]
d3999 1
a3999 1
    set f [open $path(test3) r]
d4005 1
a4005 1
    set f [open $path(test3) w]
d4011 1
a4011 1
    set f [open $path(test3) r]
d4018 1
a4018 1
    set f [open $path(test3) w]
d4024 1
a4024 1
    set f [open $path(test3) r]
d4031 1
a4031 1
    set f [open $path(test3) w]
d4037 1
a4037 1
    set f [open $path(test3) r]
d4047 1
a4047 1
    set f1 [open $path(longfile) r]
d4055 1
a4055 1
    set f1 [open $path(test1) w]
d4060 1
a4060 1
    set f1 [open $path(test1) r]
d4068 1
a4068 1
    set f1 [open $path(test1) w]
d4073 1
a4073 1
    set f1 [open $path(test1) r]
d4081 1
a4081 1
    set f1 [open $path(test1) w]
d4086 1
a4086 1
    set f1 [open $path(test1) r]
d4094 1
a4094 1
    set f1 [open $path(test1) w]
d4099 1
a4099 1
    set f1 [open $path(test1) r]
d4108 1
a4108 1
    set f1 [open $path(test1) w]
d4113 1
a4113 1
    set f1 [open $path(test1) r]
d4123 1
a4123 1
    set f1 [open $path(test1) w]
d4128 1
a4128 1
    set f1 [open $path(test1) r]
d4138 1
a4138 1
    set f1 [open "|[list [interpreter]]" r+]
d4146 1
a4146 1
    set f [open $path(test3) w]
d4150 1
a4150 1
    set f [open $path(test3) RDWR]
a4166 3

set path(test3) [makeFile {} test3]

d4168 1
a4168 1
    set f [open $path(test3) w]
d4172 1
a4172 1
    set f [open $path(test3) r+]
d4182 1
a4182 1
    set f [open $path(test3) w]
d4185 1
a4185 1
    set f [open $path(test3) w+]
d4193 1
a4193 1
    set f [open $path(test3) w]
d4197 1
a4197 1
    set f [open $path(test3) a+]
d4211 1
a4211 1
    set f1 [open $path(test1) w]
d4218 1
a4218 1
    set f1 [open $path(test1) w]
d4223 1
a4223 1
    set f1 [open $path(test1) r]
d4231 1
a4231 1
    set f1 [open $path(test1) w]
d4236 1
a4236 1
    set f1 [open $path(test1) r]
d4245 1
a4245 1
    set f1 [open "|[list [interpreter]]" r+]
d4251 1
a4251 1
    set f1 [open "|[list [interpreter]]" r+]
d4261 1
a4261 1
    set f [open $path(test2) w]
d4265 1
a4265 1
    set f [open $path(test2)]
d4280 1
a4280 1
    set f [open $path(test3) w]
d4285 1
a4285 1
    set f [open $path(test3) a]
d4291 1
a4291 1
    set f [open $path(test3) w]
a4304 22
test io-34.21 {Tcl_Seek and Tcl_Tell on large files} {largefileSupport} {
    removeFile test3
    set f [open $path(test3) w]
    fconfigure $f -encoding binary
    set l ""
    lappend l [tell $f]
    puts -nonewline $f abcdef
    lappend l [tell $f]
    flush $f
    lappend l [tell $f]
    # 4GB offset!
    seek $f 0x100000000
    lappend l [tell $f]
    puts -nonewline $f abcdef
    lappend l [tell $f]
    close $f
    lappend l [file size $f]
    # truncate...
    close [open $path(test3) w]
    lappend l [file size $f]
    set l
} {0 6 6 4294967296 4294967302 4294967302 0}
d4310 1
a4310 1
    set f [open $path(test1) w]
d4314 1
a4314 1
    set f [open $path(test1)]
d4329 1
a4329 1
    set f1 [open $path(pipe) w]
d4333 1
a4333 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d4347 1
a4347 1
    set f1 [open $path(pipe) w]
d4351 1
a4351 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d4369 1
a4369 1
    set f [open $path(test1) w]
d4371 1
a4371 1
    set f [open $path(test1) r]
d4381 1
a4381 1
    set f [open $path(pipe) w]
d4386 1
a4386 1
    set f [open "|[list [interpreter] $path(pipe)]" r]
d4395 1
a4395 1
    set f [open $path(test1) w]
d4399 2
a4400 2
    set s [file size $path(test1)]
    set f [open $path(test1) r]
d4409 1
a4409 1
    set f [open $path(test1) w]
d4413 2
a4414 2
    set s [file size $path(test1)]
    set f [open $path(test1) r]
d4423 1
a4423 1
    set f [open $path(test1) w]
d4427 2
a4428 2
    set s [file size $path(test1)]
    set f [open $path(test1) r]
d4437 1
a4437 1
    set f [open $path(test1) w]
d4441 2
a4442 2
    set s [file size $path(test1)]
    set f [open $path(test1) r]
d4451 1
a4451 1
    set f [open $path(test1) w]
d4455 2
a4456 2
    set s [file size $path(test1)]
    set f [open $path(test1) r]
d4465 1
a4465 1
    set f [open $path(test1) w]
d4469 2
a4470 2
    set s [file size $path(test1)]
    set f [open $path(test1) r]
d4479 1
a4479 1
    set f [open $path(test1) w]
d4484 2
a4485 2
    set c [file size $path(test1)]
    set f [open $path(test1) r]
d4494 1
a4494 1
    set f [open $path(test1) w]
d4499 2
a4500 2
    set c [file size $path(test1)]
    set f [open $path(test1) r]
d4509 1
a4509 1
    set f [open $path(test1) w]
d4514 2
a4515 2
    set c [file size $path(test1)]
    set f [open $path(test1) r]
d4524 1
a4524 1
    set f [open $path(test1) w]
d4529 2
a4530 2
    set c [file size $path(test1)]
    set f [open $path(test1) r]
d4539 1
a4539 1
    set f [open $path(test1) w]
d4544 2
a4545 2
    set c [file size $path(test1)]
    set f [open $path(test1) r]
d4554 1
a4554 1
    set f [open $path(test1) w]
d4559 2
a4560 2
    set c [file size $path(test1)]
    set f [open $path(test1) r]
d4571 1
a4571 1
    set f1 [open "|[list [interpreter]]" r+]
d4590 1
a4590 1
    set f1 [open "|[list [interpreter]]" r+]
d4605 1
a4605 1
    set f [open $path(test1) w]
d4608 1
a4608 1
    set f [open $path(test1) r]
d4621 1
a4621 2
        variable l
        variable x
d4626 1
a4626 1
    set f [open $path(test1) w]
d4629 1
a4629 1
    set f [open $path(test1) r]
d4631 2
a4632 3
    fileevent $f readable [namespace code [list in $f]]
    variable x
    vwait [namespace which -variable x]
d4638 1
a4638 1
    set f [open $path(test1) w]
d4641 1
a4641 1
    set f [open $path(test1) r]
d4655 1
a4655 2
        variable l
        variable x
d4660 1
a4660 1
    set f [open $path(test1) w]
d4663 1
a4663 1
    set f [open $path(test1) r]
d4666 2
a4667 3
    fileevent $f readable [namespace code [list in $f]]
    variable x
    vwait [namespace which -variable x]
d4674 2
a4675 2
test io-37.1 {Tcl_InputBuffered} {testchannel} {
    set f [open $path(longfile) r]
d4684 2
a4685 2
test io-37.2 {Tcl_InputBuffered, test input flushing on seek} {testchannel} {
    set f [open $path(longfile) r]
d4701 1
a4701 1
    set f [open $path(longfile) r]
d4707 1
a4707 1
    set f [open $path(longfile) r]
a4725 11
test io-38.3 {Tcl_SetChannelBufferSize, changing buffersize between reads} {
    # This test crashes the interp if Bug #427196 is not fixed

    set chan [open [info script] r]
    fconfigure $chan -buffersize 10
    set var [read $chan 2]
    fconfigure $chan -buffersize 32
    append var [read $chan]
    close $chan
} {}

d4730 1
a4730 1
    set f1 [open $path(test1) w]
d4740 1
a4740 1
    set f1 [open $path(test1) w]
d4747 1
a4747 1
    set f1 [open $path(test1) w]
d4755 1
a4755 1
    set f1 [open $path(test1) w]
d4771 1
a4771 1
    set f1 [open $path(test1) w]
d4781 1
a4781 1
    set f1 [open $path(test1) w]
d4785 1
a4785 1
    set x [file size $path(test1)]
d4791 1
a4791 1
    set f1 [open $path(test1) w]
d4797 1
a4797 1
    lappend x [file size $path(test1)]
d4799 1
a4799 1
    lappend x [file size $path(test1)]
d4805 1
a4805 1
    set f1 [open $path(test1) w]
d4809 1
a4809 1
    lappend l [file size $path(test1)]
d4811 1
a4811 1
    lappend l [file size $path(test1)]
d4814 1
a4814 1
    lappend l [file size $path(test1)]
d4816 1
a4816 1
    lappend l [file size $path(test1)]
d4818 1
a4818 1
    lappend l [file size $path(test1)]
d4820 1
a4820 1
    lappend l [file size $path(test1)]
d4825 1
a4825 1
    set f1 [open $path(test1) w]
d4827 1
a4827 1
    set f1 [open $path(test1) r]
d4841 1
a4841 1
    set f1 [open $path(pipe) w]
d4850 1
a4850 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d4877 1
a4877 1
    set f [open $path(test1) w]
d4885 1
a4885 1
    set f [open $path(test1) w]
d4893 1
a4893 1
    set f [open $path(test1) w]
d4901 1
a4901 1
    set f [open $path(test1) w]
d4905 1
a4905 1
    set f [open $path(test1) r]
d4913 1
a4913 1
    set f [open $path(test1) w]
d4917 1
a4917 1
    set f [open $path(test1) r]
d4925 1
a4925 1
    set f [open $path(test1) w]
d4931 1
a4931 1
    set f [open "|[list [interpreter] $path(cat)]" r+]
d4936 5
a4940 5
    variable x {}
    fileevent $f readable [namespace code { lappend x [read $f] }]
    vwait [namespace which -variable x]
    after 300 [namespace code { lappend x timeout }]
    vwait [namespace which -variable x]
d4942 3
a4944 3
    vwait [namespace which -variable x]
    after 300 [namespace code { lappend x timeout }]
    vwait [namespace which -variable x]
d4946 3
a4948 3
    vwait [namespace which -variable x]
    after 300 [namespace code { lappend x timeout }]
    vwait [namespace which -variable x]
d4956 1
a4956 1
    set s1 [socket -server [namespace code accept] 0]
d4969 1
a4969 1
    set s1 [socket -server [namespace code accept] 0]
d4982 1
a4982 1
    set s1 [socket -server [namespace code accept] 0]
d4995 1
a4995 1
    set s1 [socket -server [namespace code accept] 0]
a5005 45
test io-39.22 {Tcl_SetChannelOption, invariance} {unixOnly} {
    removeFile test1
    set f1 [open $path(test1) w+]
    set l ""
    lappend l [fconfigure $f1 -eofchar]
    fconfigure $f1 -eofchar {ON GO}
    lappend l [fconfigure $f1 -eofchar]
    fconfigure $f1 -eofchar D
    lappend l [fconfigure $f1 -eofchar]
    close $f1
    set l
} {{{} {}} {O G} {D D}}

test io-39.22a {Tcl_SetChannelOption, invariance} {
    removeFile test1
    set f1 [open $path(test1) w+]
    set l [list]
    fconfigure $f1 -eofchar {ON GO}
    lappend l [fconfigure $f1 -eofchar]
    fconfigure $f1 -eofchar D
    lappend l [fconfigure $f1 -eofchar]
    lappend l [list [catch {fconfigure $f1 -eofchar {1 2 3}} msg] $msg]
    close $f1
    set l
} {{O G} {D D} {1 {bad value for -eofchar: should be a list of zero, one, or two elements}}}


test io-39.23 {Tcl_GetChannelOption, server socket is not readable or
        writeable, it should still have valid -eofchar and -translation options } {
    set l [list]
    set sock [socket -server [namespace code accept] 0]
    lappend l [fconfigure $sock -eofchar] [fconfigure $sock -translation]
    close $sock
    set l
} {{{}} auto}
test io-39.24 {Tcl_SetChannelOption, server socket is not readable or
        writable so we can't change -eofchar or -translation } {
    set l [list]
    set sock [socket -server [namespace code accept] 0]
    fconfigure $sock -eofchar D -translation lf
    lappend l [fconfigure $sock -eofchar] [fconfigure $sock -translation]
    close $sock
    set l
} {{{}} auto}

d5008 1
a5008 1
    set f [open $path(test3) w]
d5011 1
a5011 1
    set f [open $path(test3) RDWR]
d5016 1
a5016 1
    set f [open $path(test3) r]
d5023 2
a5024 2
    set f [open $path(test3) {WRONLY CREAT} 0600]
    file stat $path(test3) stats
d5028 1
a5028 1
    set f [open $path(test3) r]
d5036 1
a5036 1
catch {testConstraint umask2 [expr {[exec umask] == 2}]}
d5041 1
a5041 1
    set f [open $path(test3) {WRONLY CREAT}]
d5048 1
a5048 1
    set f [open $path(test3) w]
d5052 1
a5052 1
    set f [open $path(test3) {WRONLY CREAT}]
d5056 1
a5056 1
    set f [open $path(test3) r]
d5063 1
a5063 1
    set f [open $path(test3) w]
d5067 1
a5067 1
    set f [open $path(test3) {WRONLY APPEND}]
d5073 1
a5073 1
    set f [open $path(test3) r]
d5084 1
a5084 1
    set f [open $path(test3) w]
d5087 1
a5087 1
    set msg [list [catch {open $path(test3) {WRONLY CREAT EXCL}} msg] $msg]
a5088 1
    regsub [file join {} $path(test3)] $msg "test3" msg
d5093 1
a5093 1
    set f [open $path(test3) {WRONLY CREAT EXCL}]
d5101 1
a5101 1
    set f [open $path(test3) w]
d5104 1
a5104 1
    set f [open $path(test3) {WRONLY TRUNC}]
d5107 1
a5107 1
    set f [open $path(test3) r]
d5114 1
a5114 1
    set f [open $path(test3) {WRONLY NONBLOCK CREAT}]
d5117 1
a5117 1
    set f [open $path(test3) r]
d5123 1
a5123 1
    set f [open $path(test1) w]
d5127 1
a5127 1
    set f [open $path(test1) RDONLY]
d5136 1
a5136 3
    set msg [list [catch {open $path(test3) RDONLY} msg] $msg]
    regsub [file join {} $path(test3)] $msg "test3" msg
	string tolower $msg
d5140 1
a5140 3
    set msg [list [catch {open $path(test3) WRONLY} msg] $msg]
    regsub [file join {} $path(test3)] $msg "test3" msg
	string tolower $msg
d5144 1
a5144 1
    set f [open $path(test3) WRONLY]
d5156 1
a5156 3
    set msg [list [catch {open $path(test3) RDWR} msg] $msg]
    regsub [file join {} $path(test3)] $msg "test3" msg
	string tolower $msg
d5160 1
a5160 1
    set f [open $path(test3) RDWR]
d5205 1
a5205 2
set path(foo) [makeFile {} foo]
set f [open $path(foo) w+]
d5267 1
a5267 1
    fileevent $f2 readable [namespace code {
d5269 1
a5269 1
    }]
d5271 2
a5272 2
    variable x initial
    vwait [namespace which -variable x]
d5276 4
a5279 1
    proc ::bgerror args "set [namespace which -variable x] \$args"
d5282 3
a5284 3
    variable x initial
    vwait [namespace which -variable x]
    rename ::bgerror {}
d5288 1
a5288 1
    fileevent $f2 writable [namespace code {
d5294 2
a5295 2
    }]
    variable x initial
d5297 3
a5299 3
    vwait [namespace which -variable x]
    vwait [namespace which -variable x]
    vwait [namespace which -variable x]
d5303 4
a5306 1
    proc ::bgerror args "set [namespace which -variable x] \$args"
d5308 3
a5310 3
    variable x initial
    vwait [namespace which -variable x]
    rename ::bgerror {}
d5314 2
a5315 2
    set f4 [open "|[list [interpreter] $path(cat) << foo]" r]
    fileevent $f4 readable [namespace code {
d5322 4
a5325 4
    }]
    variable x initial
    vwait [namespace which -variable x]
    vwait [namespace which -variable x]
d5337 2
a5338 2
    set f [open $path(foo) r]
    fileevent $f readable [namespace code {
d5341 1
a5341 1
    }]
d5344 2
a5345 3
    after 100 [namespace code { set y done }]
    variable y
    vwait [namespace which -variable y]
d5349 3
a5351 3
    set f  [open $path(foo) r]
    set f2 [open $path(foo) r]
    fileevent $f readable [namespace code {
d5354 2
a5355 2
	}]
    fileevent $f2 readable [namespace code {
d5358 1
a5358 1
    }]
d5360 2
a5361 2
    variable x initial
    vwait [namespace which -variable x]
d5366 3
a5368 3
    set f  [open $path(foo) r]
    set f2 [open $path(foo) r]
    set f3 [open $path(foo) r]
a5387 1
testConstraint testfevent [llength [info commands testfevent]]
d5389 3
a5391 1
test io-46.1 {Tcl event loop vs multiple interpreters} {testfevent} {
d5393 2
a5394 2
    testfevent cmd [format {
        set f [open %s r]
d5396 1
a5396 1
        fileevent $f readable [namespace code {
d5399 2
a5400 2
        }]
    } $path(foo)]
d5406 1
a5406 1
test io-46.2 {Tcl event loop vs multiple interpreters} testfevent {
d5409 1
a5409 1
        variable x 0
d5411 1
a5411 1
        vwait [namespace which -variable x]
d5415 1
a5415 1
test io-46.3 {Tcl event loop vs multiple interpreters} testfevent {
d5429 4
a5432 4
test io-47.1 {fileevent vs multiple interpreters} testfevent {
    set f  [open $path(foo) r]
    set f2 [open $path(foo) r]
    set f3 [open $path(foo) r]
d5448 5
a5452 5
test io-47.2 {deleting fileevent on interpreter delete} testfevent {
    set f  [open $path(foo) r]
    set f2 [open $path(foo) r]
    set f3 [open $path(foo) r]
    set f4 [open $path(foo) r]
d5469 5
a5473 5
test io-47.3 {deleting fileevent on interpreter delete} testfevent {
    set f  [open $path(foo) r]
    set f2 [open $path(foo) r]
    set f3 [open $path(foo) r]
    set f4 [open $path(foo) r]
d5490 3
a5492 3
test io-47.4 {file events on shared files and multiple interpreters} testfevent {
    set f  [open $path(foo) r]
    set f2 [open $path(foo) r]
d5506 2
a5507 2
test io-47.5 {file events on shared files, deleting file events} testfevent {
    set f [open $path(foo) r]
d5519 2
a5520 2
test io-47.6 {file events on shared files, deleting file events} testfevent {
    set f [open $path(foo) r]
d5533 3
a5535 1
set path(bar) [makeFile {} bar]
d5538 1
a5538 1
    set f [open $path(bar) w]
d5545 2
a5546 2
    set f [open $path(bar) r]
    fileevent $f readable [namespace code [list consume $f]]
d5548 1
a5548 2
	variable l
	variable x
d5558 2
a5559 2
    variable x not_done
    vwait [namespace which -variable x]
d5563 1
a5563 1
    set f [open $path(bar) w]
d5570 2
a5571 2
    set f [open $path(bar) r]
    fileevent $f readable [namespace code [list consume $f]]
d5574 1
a5574 2
	variable x
	variable l
d5584 2
a5585 2
    variable x not_done
    vwait [namespace which -variable x]
d5588 2
a5589 5

set path(my_script) [makeFile {} my_script]

test io-48.3 {testing readability conditions} {stdio unixOnly nonBlockFiles} {
    set f [open $path(bar) w]
d5596 1
a5596 1
    set f [open $path(my_script) w]
d5607 2
a5608 2
    set f [open "|[list [interpreter]]" r+]
    fileevent $f readable [namespace code [list consume $f]]
d5612 1
a5612 2
	variable l
	variable x
d5623 3
a5625 3
    variable x not_done
    puts $f [format {source %s}         $path(my_script)]
    puts $f [format {set f [open %s r]} $path(bar)]
d5628 1
a5628 1
    vwait [namespace which -variable x]
d5634 1
a5634 1
    set f [open $path(test1) w]
d5640 1
a5640 3
	variable l
	variable c
	variable x
d5651 1
a5651 1
    set f [open $path(test1) r]
d5653 2
a5654 3
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
d5659 1
a5659 1
    set f [open $path(test1) w]
d5665 1
a5665 3
	variable l
	variable x
	variable c
d5676 1
a5676 1
    set f [open $path(test1) r]
d5678 2
a5679 3
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
d5684 1
a5684 1
    set f [open $path(test1) w]
d5690 1
a5690 3
	variable l
	variable x
	variable c
d5701 1
a5701 1
    set f [open $path(test1) r]
d5703 2
a5704 3
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
d5709 1
a5709 1
    set f [open $path(test1) w]
d5715 1
a5715 3
	variable l
	variable c
	variable x
d5726 1
a5726 1
    set f [open $path(test1) r]
d5728 2
a5729 3
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
d5734 1
a5734 1
    set f [open $path(test1) w]
d5740 1
a5740 3
	variable l
	variable x
	variable c
d5751 1
a5751 1
    set f [open $path(test1) r]
d5753 2
a5754 3
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
d5759 1
a5759 1
    set f [open $path(test1) w]
d5765 1
a5765 3
	variable l
	variable c
	variable x
d5776 1
a5776 1
    set f [open $path(test1) r]
d5778 2
a5779 3
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
d5784 1
a5784 1
    set f [open $path(test1) w]
d5790 1
a5790 3
	variable l
	variable c
	variable x
d5801 1
a5801 1
    set f [open $path(test1) r]
d5803 2
a5804 3
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
d5809 1
a5809 1
    set f [open $path(test1) w]
d5815 1
a5815 3
	variable l
	variable x
	variable c
d5826 1
a5826 1
    set f [open $path(test1) r]
d5828 2
a5829 3
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
d5834 1
a5834 1
    set f [open $path(test1) w]
d5840 1
a5840 3
	variable l
	variable x
	variable c
d5851 1
a5851 1
    set f [open $path(test1) r]
d5853 2
a5854 3
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
d5859 1
a5859 1
    set f [open $path(test1) w]
d5865 1
a5865 3
	variable c
	variable x
	variable l
d5876 1
a5876 1
    set f [open $path(test1) r]
d5878 2
a5879 3
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
d5884 1
a5884 1
    set f [open $path(test1) w]
d5890 1
a5890 3
	variable c
	variable x
	variable l
d5901 1
a5901 1
    set f [open $path(test1) r]
d5903 2
a5904 3
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
d5909 1
a5909 1
    set f [open $path(test1) w]
d5915 1
a5915 3
	variable c
	variable x
	variable l
d5926 1
a5926 1
    set f [open $path(test1) r]
d5928 2
a5929 3
    fileevent $f readable [namespace code [list consume $f]]
    variable x
    vwait [namespace which -variable x]
d5935 1
a5935 1
    set f [open $path(test1) w]
d5939 1
a5939 1
    set f [open $path(test1) r]
d5941 1
a5941 1
    lappend l [file size $path(test1)]
d5964 1
a5964 1
    set f [open $path(test1) w]
d5968 1
a5968 1
    set f [open $path(test1) r]
d5970 1
a5970 1
    lappend l [file size $path(test1)]
d5987 1
a5987 1
    set f [open $path(test1) w]
d5991 1
a5991 1
    set f [open $path(test1) r]
d5993 1
a5993 1
    lappend l [file size $path(test1)]
d6008 1
a6008 1
    set f [open $path(test1) w]
d6012 1
a6012 1
    set f [open $path(test1) r]
d6014 1
a6014 1
    lappend l [file size $path(test1)]
d6029 1
a6029 1
    set f [open $path(test1) w]
d6033 1
a6033 1
    set f [open $path(test1) r]
d6035 1
a6035 1
    lappend l [file size $path(test1)]
d6046 1
a6046 2
testConstraint testchannelevent [llength [info commands testchannelevent]]
test io-50.1 {testing handler deletion} {testchannelevent} {
d6048 1
a6048 1
    set f [open $path(test1) w]
d6050 2
a6051 2
    set f [open $path(test1) r]
    testchannelevent $f add readable [namespace code [list delhandler $f]]
d6053 1
a6053 1
	variable z
d6062 1
a6062 1
test io-50.2 {testing handler deletion with multiple handlers} {testchannelevent} {
d6064 1
a6064 1
    set f [open $path(test1) w]
d6066 3
a6068 3
    set f [open $path(test1) r]
    testchannelevent $f add readable [namespace code [list delhandler $f 1]]
    testchannelevent $f add readable [namespace code [list delhandler $f 0]]
d6070 1
a6070 1
	variable z
d6080 1
a6080 1
test io-50.3 {testing handler deletion with multiple handlers} {testchannelevent} {
d6082 1
a6082 1
    set f [open $path(test1) w]
d6084 3
a6086 3
    set f [open $path(test1) r]
    testchannelevent $f add readable [namespace code [list notcalled $f 1]]
    testchannelevent $f add readable [namespace code [list delhandler $f 0]]
d6089 1
a6089 1
	variable z
d6093 1
a6093 1
	variable z
d6106 1
a6106 1
test io-50.4 {testing handler deletion vs reentrant calls} {testchannelevent} {
d6108 1
a6108 1
    set f [open $path(test1) w]
d6110 2
a6111 2
    set f [open $path(test1) r]
    testchannelevent $f add readable [namespace code [list delrecursive $f]]
d6113 1
a6113 2
	variable z
	variable u
d6130 1
a6130 1
test io-50.5 {testing handler deletion vs reentrant calls} {testchannelevent} {
d6132 1
a6132 1
    set f [open $path(test1) w]
d6134 3
a6136 3
    set f [open $path(test1) r]
    testchannelevent $f add readable [namespace code [list notcalled $f]]
    testchannelevent $f add readable [namespace code [list del $f]]
d6138 1
a6138 1
	variable z
d6142 1
a6142 2
	variable u
	variable z
d6163 1
a6163 1
test io-50.6 {testing handler deletion vs reentrant calls} {testchannelevent} {
d6165 1
a6165 1
    set f [open $path(test1) w]
d6167 3
a6169 3
    set f [open $path(test1) r]
    testchannelevent $f add readable [namespace code [list second $f]]
    testchannelevent $f add readable [namespace code [list first $f]]
d6171 1
a6171 2
	variable u
	variable z
d6182 1
a6182 2
	variable u
	variable z
d6209 1
a6209 2
	variable x
	variable wait
d6215 4
a6218 4
    set ss [socket -server [namespace code accept] 0]
    variable wait ""
    set cs [socket [info hostname] [lindex [fconfigure $ss -sockname] 2]]
    vwait [namespace which -variable wait]
d6223 2
a6224 2
    set cs [socket [info hostname] [lindex [fconfigure $ss -sockname] 2]]
    vwait [namespace which -variable wait]
d6229 2
a6230 2
    set cs [socket [info hostname] [lindex [fconfigure $ss -sockname] 2]]
    vwait [namespace which -variable wait]
d6235 2
a6236 2
    set cs [socket [info hostname] [lindex [fconfigure $ss -sockname] 2]]
    vwait [namespace which -variable wait]
d6246 1
a6246 1
    set f2 [open $path(test1) w]
d6256 1
a6256 1
    set f2 [open $path(test1) w]
d6268 1
a6268 1
    set f2 [open $path(test1) w]
d6276 1
a6276 1
    set s2 [file size $path(test1)]
d6285 1
a6285 1
    set f2 [open $path(test1) w]
d6292 1
a6292 1
    lappend result [file size $path(test1)]
d6297 1
a6297 1
    set f2 [open $path(test1) w]
d6305 1
a6305 1
    set s2 [file size $path(test1)]
d6314 1
a6314 1
    set f2 [open $path(test1) w]
d6322 1
a6322 1
    set s2 [file size $path(test1)]
d6331 1
a6331 1
    set f2 [open $path(test1) w]
d6337 1
a6337 1
    set s2 [file size $path(test1)]
d6348 1
a6348 1
    set f1 [open $path(pipe) w]
d6359 1
a6359 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d6364 1
a6364 1
    set f2 [open $path(test1) w]
d6369 1
a6369 1
    list $s0 [file size $path(test1)]
a6371 79
# Empty files, to register them with the test facility
set path(kyrillic.txt)   [makeFile {} kyrillic.txt]
set path(utf8-fcopy.txt) [makeFile {} utf8-fcopy.txt]
set path(utf8-rp.txt)    [makeFile {} utf8-rp.txt]

# Create kyrillic file, use lf translation to avoid os eol issues
set out [open $path(kyrillic.txt) w]
fconfigure $out -encoding koi8-r -translation lf
puts       $out "\u0410\u0410"
close      $out

test io-52.9 {TclCopyChannel & encodings} {
    # Copy kyrillic to UTF-8, using fcopy.

    set in  [open $path(kyrillic.txt) r]
    set out [open $path(utf8-fcopy.txt) w]

    fconfigure $in  -encoding koi8-r -translation lf
    fconfigure $out -encoding utf-8 -translation lf

    fcopy $in $out
    close $in
    close $out

    # Do the same again, but differently (read/puts).

    set in  [open $path(kyrillic.txt) r]
    set out [open $path(utf8-rp.txt) w]

    fconfigure $in  -encoding koi8-r -translation lf
    fconfigure $out -encoding utf-8 -translation lf

    puts -nonewline $out [read $in]

    close $in
    close $out

    list [file size $path(kyrillic.txt)] \
	    [file size $path(utf8-fcopy.txt)] \
	    [file size $path(utf8-rp.txt)]
} {3 5 5}

test io-52.10 {TclCopyChannel & encodings} {
    # encoding to binary (=> implies that the
    # internal utf-8 is written)

    set in  [open $path(kyrillic.txt) r]
    set out [open $path(utf8-fcopy.txt) w]

    fconfigure $in  -encoding koi8-r -translation lf
    # -translation binary is also -encoding binary
    fconfigure $out -translation binary

    fcopy $in $out
    close $in
    close $out

    file size $path(utf8-fcopy.txt)
} 5

test io-52.11 {TclCopyChannel & encodings} {
    # binary to encoding => the input has to be
    # in utf-8 to make sense to the encoder

    set in  [open $path(utf8-fcopy.txt) r]
    set out [open $path(kyrillic.txt) w]

    # -translation binary is also -encoding binary
    fconfigure $in  -translation binary
    fconfigure $out -encoding koi8-r -translation lf

    fcopy $in $out
    close $in
    close $out

    file size $path(kyrillic.txt)
} 3


d6375 1
a6375 1
    set f2 [open $path(test1) w]
d6382 1
a6382 1
    lappend result [file size $path(test1)]
d6387 1
a6387 1
    set f2 [open $path(test1) w]
d6390 1
a6390 1
    fcopy $f1 $f2 -command [namespace code {set s0}]
d6392 1
a6392 2
    variable s0
    vwait [namespace which -variable s0]
d6396 1
a6396 1
    set s2 [file size $path(test1)]
d6402 1
a6402 1
test io-53.3 {CopyData: background read underflow} {stdio unixOnly} {
d6405 2
a6406 2
    set f1 [open $path(pipe) w]
    puts $f1 [format {
d6411 1
a6411 1
	set f [open "%s" w]
d6415 1
a6415 1
    } $path(test1)]
d6417 1
a6417 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d6427 1
a6427 1
    set f [open $path(test1)]
d6432 1
a6432 1
test io-53.4 {CopyData: background write overflow} {stdio unixOnly} {
a6433 1
    variable x
d6439 1
a6439 1
    set f1 [open $path(pipe) w]
d6444 1
a6444 1
	set f [open $path(test1) w]
d6450 1
a6450 1
    set f1 [open "|[list [interpreter] $path(pipe)]" r+]
d6457 1
a6457 1
    fileevent $f1 read [namespace code {
d6462 2
a6463 2
    }]
    vwait [namespace which -variable x]
d6474 1
a6474 1
    variable fcopyTestDone
d6483 1
a6483 2
    variable fcopyTestDone
    set listen [socket -server [namespace code FcopyTestAccept] 0]
d6485 1
a6485 1
    set out [socket 127.0.0.1 [lindex [fconfigure $listen -sockname] 2]]
d6488 1
a6488 2
    fcopy $in $out -command [namespace code FcopyTestDone]
    variable fcopyTestDone
d6490 1
a6490 1
	vwait [namespace which -variable fcopyTestDone]		;# The error occurs here in the b.g.
a6496 1
    variable fcopyTestDone
d6500 1
a6500 1
    set f1 [open $path(pipe) w]
d6503 3
a6505 4
    set in [open "|[list [interpreter] $path(pipe)]" r+]
    set out [open $path(test1) w]
    fcopy $in $out -command [namespace code FcopyTestDone]
    variable fcopyTestDone
d6507 1
a6507 1
	vwait [namespace which -variable fcopyTestDone]
a6513 53
proc doFcopy {in out {bytes 0} {error {}}} {
    variable fcopyTestDone
    variable fcopyTestCount
    incr fcopyTestCount $bytes
    if {[string length $error]} {
	    set fcopyTestDone 1
    } elseif {[eof $in]} {
	    set fcopyTestDone 0
    } else {
        # Delay next fcopy to wait for size>0 input bytes
        after 100 [list 
            fcopy $in $out -size 1000 \
		    -command [namespace code [list doFcopy $in $out]]
        ]
    }
}

test io-53.7 {CopyData: Flooding fcopy from pipe} {stdio} {
    variable fcopyTestDone
    removeFile pipe
    removeFile test1
    catch {unset fcopyTestDone}
    set fcopyTestCount 0
    set f1 [open $path(pipe) w]
    puts $f1 {
	# Write  10 bytes / 10 msec
	proc Write {count} {
	    puts -nonewline "1234567890"
	    if {[incr count -1]} {
	        after 10 [list Write $count]
	    } else {
	        set ::ready 1
	    }
	}
	fconfigure stdout -buffering none
	Write 345 ;# 3450 bytes ~3.45 sec
	vwait ready
	exit 0
    }
    close $f1
    set in [open "|[list [interpreter] $path(pipe) &]" r+]
    set out [open $path(test1) w]
    doFcopy $in $out
    variable fcopyTestDone
    if ![info exists fcopyTestDone] {
	vwait [namespace which -variable fcopyTestDone]
    }
    catch {close $in}
    close $out
    # -1=error 0=script error N=number of bytes
    expr ($fcopyTestDone == 0) ? $fcopyTestCount : -1
} {3450}

d6519 1
a6519 1
	variable as
d6526 1
a6526 2
	variable x
	variable result
d6529 2
a6530 2
	    fileevent $s readable [namespace code [list readit $s 2]]
	    vwait [namespace which -variable x]
d6534 1
a6534 1
    set ss [socket -server [namespace code accept] 0]
d6541 1
a6541 1
	if {![catch {set cs [socket [info hostname] [lindex [fconfigure $ss -sockname] 2]]}]} {
d6551 3
a6553 4
    variable result {}
    variable x 0
    variable as
    vwait [namespace which -variable as]
d6557 3
a6559 3
    fileevent $cs readable [namespace code [list readit $cs 1]]
    set a [after 2000 [namespace code { set x failure }]]
    vwait [namespace which -variable x]
d6569 1
a6569 1
    variable s [socket -server [namespace code accept] 0]
d6571 1
a6571 2
	variable counter
	variable accept
d6576 1
a6576 1
	fileevent $s readable [namespace code "doit $s"]
d6579 1
a6579 2
	variable counter
	variable after
d6584 2
a6585 2
	    fileevent $s readable [namespace code "doit1 $s"]
	    set after [after 1000 [namespace code newline]]
d6589 1
a6589 2
	variable counter
	variable accept
d6597 1
a6597 2
	variable s
	variable writer
d6599 1
a6599 1
	set writer [socket 127.0.0.1 [lindex [fconfigure $s -sockname] 2]]
d6605 1
a6605 2
	variable done
	variable writer
d6612 1
a6612 2
    variable done
    vwait [namespace which -variable done]
a6619 2
set path(fooBar) [makeFile {} fooBar]

a6620 1
    variable x
a6621 1
	variable x
d6624 1
a6624 1
	set x whoops
d6626 7
a6632 5
    proc ::bgerror {args} "set [namespace which -variable x] got_error"
    set f [open $path(fooBar) w]
    fileevent $f writable [namespace code [list eventScript $f]]
    variable x not_done
    vwait [namespace which -variable x]
d6636 2
a6637 2
test io-56.1 {ChannelTimerProc} {testchannelevent} {
    set f [open $path(fooBar) w]
d6640 2
a6641 2
    set f [open $path(fooBar) r]
    testchannelevent $f add readable [namespace code {
d6644 4
a6647 4
    }]
    variable x 0
    vwait [namespace which -variable x]
    vwait [namespace which -variable x]
d6650 2
a6651 3
    after idle [namespace code {set y done}]
    variable y
    vwait [namespace which -variable y]
d6658 1
a6658 2
	variable s2
	set s2 $sock
d6660 3
a6662 4
    set server [socket -server [namespace code accept] 0]
    set s [socket 127.0.0.1 [lindex [fconfigure $server -sockname] 2]]
    variable s2
    vwait [namespace which -variable s2]
d6664 1
a6664 1
    fileevent $s2 readable [namespace code {lappend result readable}]
d6667 3
a6669 3
    variable result [gets $s2]
    after 1000 [namespace code {lappend result timer}]
    vwait [namespace which -variable result]
d6671 1
a6671 1
    vwait [namespace which -variable result]
d6679 1
a6679 2
	variable s2
	set s2 $sock
d6681 3
a6683 4
    set server [socket -server [namespace code accept] 0]
    set s [socket 127.0.0.1 [lindex [fconfigure $server -sockname] 2]]
    variable s2
    vwait [namespace which -variable s2]
d6685 1
a6685 1
    fileevent $s2 readable [namespace code {lappend result readable}]
d6688 3
a6690 3
    variable result [read $s2 1]
    after 1000 [namespace code {lappend result timer}]
    vwait [namespace which -variable result]
d6692 1
a6692 1
    vwait [namespace which -variable result]
d6699 2
a6700 2
test io-58.1 {Tcl_NotifyChannel and error when closing} {stdio unixOrPc} {
    set out [open $path(script) w]
d6707 1
a6707 2
	variable x
	variable result
d6717 3
a6719 3
    set pipe [open "|[list [interpreter] $path(script)]" r]
    fileevent $pipe readable [namespace code [list readit $pipe]]
    variable x ""
d6721 1
a6721 1
    vwait [namespace which -variable x]
d6725 12
a6737 7
testConstraint testmainthread [llength [info commands testmainthread]]
test io-59.1 {Thread reference of channels} {testmainthread testchannel} {
    # TIP #10
    # More complicated tests (like that the reference changes as a
    # channel is moved from thread to thread) can be done only in the
    # extension which fully implements the moving of channels between
    # threads, i.e. 'Threads'. Or we have to extend [testthread] as well.
a6738 5
    set f [open $path(longfile) r]
    set result [testchannel mthread $f]
    close $f
    string equal $result [testmainthread]
} {1}
a6740 2
test io-60.1 {writing illegal utf sequences} {
    # This test will hang in older revisions of the core.
a6741 22
    set out [open $path(script) w]
    puts $out {
	puts [encoding convertfrom identity \xe2]
	exit 1
    }
    proc readit {pipe} {
	variable x
	variable result
	if {[eof $pipe]} {
	    set x [catch {close $pipe} line]
	    lappend result catch $line
	} else {
	    gets $pipe line
	    lappend result gets $line
	}
    }
    close $out
    set pipe [open "|[list [interpreter] $path(script)]" r]
    fileevent $pipe readable [namespace code [list readit $pipe]]
    variable x ""
    set result ""
    vwait [namespace which -variable x]
a6742 4
    # cut of the remainder of the error stack, especially the filename
    set result [lreplace $result 3 3 [lindex [split [lindex $result 3] \n] 0]]
    list $x $result
} {1 {gets {} catch {error writing "stdout": invalid argument}}}
a6746 9
# cleanup
foreach file [list fooBar longfile script output test1 pipe my_script foo \
	bar test2 test3 cat stdout] {
    removeFile $file
}
cleanupTests
}
namespace delete ::tcl::test::io
return
@


