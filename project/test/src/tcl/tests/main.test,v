head	1.3;
access;
symbols
	sid-snapshot-20180601:1.3
	sid-snapshot-20180501:1.3
	sid-snapshot-20180401:1.3
	sid-snapshot-20180301:1.3
	sid-snapshot-20180201:1.3
	sid-snapshot-20180101:1.3
	sid-snapshot-20171201:1.3
	sid-snapshot-20171101:1.3
	sid-snapshot-20171001:1.3
	sid-snapshot-20170901:1.3
	sid-snapshot-20170801:1.3
	sid-snapshot-20170701:1.3
	sid-snapshot-20170601:1.3
	sid-snapshot-20170501:1.3
	sid-snapshot-20170401:1.3
	sid-snapshot-20170301:1.3
	sid-snapshot-20170201:1.3
	sid-snapshot-20170101:1.3
	sid-snapshot-20161201:1.3
	sid-snapshot-20161101:1.3
	sid-snapshot-20160901:1.3
	sid-snapshot-20160801:1.3
	sid-snapshot-20160701:1.3
	sid-snapshot-20160601:1.3
	sid-snapshot-20160501:1.3
	sid-snapshot-20160401:1.3
	sid-snapshot-20160301:1.3
	sid-snapshot-20160201:1.3
	sid-snapshot-20160101:1.3
	sid-snapshot-20151201:1.3
	sid-snapshot-20151101:1.3
	sid-snapshot-20151001:1.3
	sid-snapshot-20150901:1.3
	sid-snapshot-20150801:1.3
	sid-snapshot-20150701:1.3
	sid-snapshot-20150601:1.3
	sid-snapshot-20150501:1.3
	sid-snapshot-20150401:1.3
	sid-snapshot-20150301:1.3
	sid-snapshot-20150201:1.3
	sid-snapshot-20150101:1.3
	sid-snapshot-20141201:1.3
	sid-snapshot-20141101:1.3
	sid-snapshot-20141001:1.3
	sid-snapshot-20140901:1.3
	sid-snapshot-20140801:1.3
	sid-snapshot-20140701:1.3
	sid-snapshot-20140601:1.3
	sid-snapshot-20140501:1.3
	sid-snapshot-20140401:1.3
	sid-snapshot-20140301:1.3
	sid-snapshot-20140201:1.3
	sid-snapshot-20140101:1.3
	sid-snapshot-20131201:1.3
	sid-snapshot-20131101:1.3
	sid-snapshot-20131001:1.3
	sid-snapshot-20130901:1.3
	sid-snapshot-20130801:1.3
	sid-snapshot-20130701:1.3
	sid-snapshot-20130601:1.3
	insight_7_6-2013-04-10-branchpoint:1.3
	gdb_7_6-branch:1.3.0.60
	sid-snapshot-20130501:1.3
	sid-snapshot-20130401:1.3
	sid-snapshot-20130301:1.3
	sid-snapshot-20130201:1.3
	sid-snapshot-20130101:1.3
	sid-snapshot-20121201:1.3
	sid-snapshot-20121101:1.3
	sid-snapshot-20121001:1.3
	sid-snapshot-20120901:1.3
	gdb_7_5-branch:1.3.0.58
	sid-snapshot-20120801:1.3
	sid-snapshot-20120701:1.3
	sid-snapshot-20120601:1.3
	sid-snapshot-20120501:1.3
	sid-snapshot-20120401:1.3
	gdb_7_4-branch:1.3.0.56
	sid-snapshot-20120301:1.3
	sid-snapshot-20120201:1.3
	sid-snapshot-20120101:1.3
	sid-snapshot-20111201:1.3
	sid-snapshot-20111101:1.3
	sid-snapshot-20111001:1.3
	sid-snapshot-20110901:1.3
	gdb_7_3-branch:1.3.0.54
	sid-snapshot-20110801:1.3
	sid-snapshot-20110701:1.3
	sid-snapshot-20110601:1.3
	sid-snapshot-20110501:1.3
	sid-snapshot-20110401:1.3
	sid-snapshot-20110301:1.3
	sid-snapshot-20110201:1.3
	sid-snapshot-20110101:1.3
	sid-snapshot-20101201:1.3
	sid-snapshot-20101101:1.3
	sid-snapshot-20101001:1.3
	sid-snapshot-20100901:1.3
	sid-snapshot-20100801:1.3
	sid-snapshot-20100701:1.3
	sid-snapshot-20100601:1.3
	sid-snapshot-20100501:1.3
	sid-snapshot-20100401:1.3
	sid-snapshot-20100301:1.3
	gdb_7_1-branch:1.3.0.52
	gdb_7_0-branch:1.3.0.50
	sid-snapshot-20100201:1.3
	sid-snapshot-20100101:1.3
	sid-snapshot-20091201:1.3
	sid-snapshot-20091101:1.3
	sid-snapshot-20091001:1.3
	arc-sim-20090309:1.3
	sid-snapshot-20090901:1.3
	sid-snapshot-20090801:1.3
	sid-snapshot-20090701:1.3
	sid-snapshot-20090601:1.3
	sid-snapshot-20090501:1.3
	kevinb-pre-tcl8_5_7_merge:1.3
	sid-snapshot-20090401:1.3
	arc-insight_6_8-branch:1.3.0.48
	arc-insight_6_8-branchpoint:1.3
	insight_6_8-branch:1.3.0.46
	insight_6_8-branchpoint:1.3
	sid-snapshot-20090301:1.3
	sid-snapshot-20090201:1.3
	sid-snapshot-20090101:1.3
	sid-snapshot-20081201:1.3
	sid-snapshot-20081101:1.3
	sid-snapshot-20081001:1.3
	sid-snapshot-20080901:1.3
	sid-snapshot-20080801:1.3
	sid-snapshot-20080701:1.3
	sid-snapshot-20080601:1.3
	sid-snapshot-20080501:1.3
	sid-snapshot-20080403:1.3
	sid-snapshot-20080401:1.3
	gdb_6_8-branch:1.3.0.44
	sid-snapshot-20080301:1.3
	sid-snapshot-20080201:1.3
	sid-snapshot-20080101:1.3
	sid-snapshot-20071201:1.3
	sid-snapshot-20071101:1.3
	sid-snapshot-20071001:1.3
	insight_6_6-20070208-release:1.3
	gdb_6_6-branch:1.3.0.42
	gdb_6_6-2006-11-15-branchpoint:1.3
	insight_6_5-20061003-release:1.3
	gdb_6_5-branch:1.3.0.40
	gdb_6_5-2006-05-14-branchpoint:1.3
	readline_5_1-import-branch:1.3.0.38
	readline_5_1-import-branchpoint:1.3
	gdb_6_4-branch:1.3.0.36
	gdb_6_4-2005-11-01-branchpoint:1.3
	msnyder-tracepoint-checkpoint-branch:1.3.0.34
	msnyder-tracepoint-checkpoint-branchpoint:1.3
	gdb_6_1-2004-04-05-release:1.3
	ezannoni_pie-20040323-branch:1.3.0.32
	ezannoni_pie-20040323-branchpoint:1.3
	cagney_tramp-20040321-mergepoint:1.3
	cagney_tramp-20040309-branch:1.3.0.30
	cagney_tramp-20040309-branchpoint:1.3
	gdb_6_1-branch:1.3.0.28
	gdb_6_1-2004-03-01-gmt-branchpoint:1.3
	drow-cplus-merge-20040208:1.3
	carlton_dictionary-20040126-merge:1.3
	drow-cplus-merge-20040113:1.3
	drow-cplus-merge-20031224:1.3
	drow-cplus-merge-20031220:1.3
	carlton_dictionary-20031215-merge:1.3
	drow-cplus-merge-20031214:1.3
	carlton-dictionary-20031111-merge:1.3
	gdb_6_0-2003-10-04-release:1.3
	carlton_dictionary-20030917-merge:1.3
	ezannoni_pie-20030916-branchpoint:1.3
	ezannoni_pie-20030916-branch:1.3.0.26
	gdb_5_1-2001-07-29-branch:1.3.0.24
	cagney_x86i386-20030821-branch:1.3.0.22
	cagney_x86i386-20030821-branchpoint:1.3
	carlton_dictionary-20030805-merge:1.3
	carlton_dictionary-20030627-merge:1.3
	gdb_6_0-branch:1.3.0.20
	gdb_6_0-2003-06-23-branchpoint:1.3
	cagney_convert-20030606-branch:1.3.0.18
	cagney_convert-20030606-branchpoint:1.3
	cagney_writestrings-20030508-branch:1.3.0.16
	cagney_writestrings-20030508-branchpoint:1.3
	carlton_dictionary-20030523-merge:1.3
	cagney_fileio-20030521-branch:1.3.0.14
	cagney_fileio-20030521-branchpoint:1.3
	carlton_dictionary-20030430-merge:1.3
	carlton_dictionary-20030416-merge:1.3
	cagney_frameaddr-20030409-mergepoint:1.3
	cagney_frameaddr-20030403-branchpoint:1.3
	cagney_frameaddr-20030403-branch:1.3.0.12
	cagney_framebase-20030330-mergepoint:1.3
	cagney_framebase-20030326-branch:1.3.0.10
	cagney_framebase-20030326-branchpoint:1.3
	cagney_lazyid-20030317-branch:1.3.0.8
	cagney_lazyid-20030317-branchpoint:1.3
	offbyone-20030313-branch:1.3.0.6
	offbyone-20030313-branchpoint:1.3
	carlton_dictionary-20030305-merge:1.3
	cagney_offbyone-20030303-branch:1.3.0.4
	cagney_offbyone-20030303-branchpoint:1.3
	carlton_dictionary-20030207-merge:1.3
	interps-20030202-branch:1.3.0.2
	interps-20030202-branchpoint:1.3
	TCL8_4_1:1.1.1.3
	cagney-unwind-20030108-branch:1.2.0.2
	cagney-unwind-20030108-branchpoint:1.2
	carlton_dictionary-20021223-merge:1.2
	TCL_8_4_1:1.1.1.3
	carlton_dictionary-20021115-merge:1.1
	kseitz_interps-20021105-merge:1.1
	kseitz_interps-20021103-merge:1.1
	drow-cplus-merge-20021020:1.1
	drow-cplus-merge-20021025:1.1
	carlton_dictionary-20021025-merge:1.1
	carlton_dictionary-20021011-merge:1.1
	drow-cplus-branch:1.1.0.6
	drow-cplus-branchpoint:1.1
	kseitz_interps-20020528-branch:1.1.0.4
	kseitz_interps-20020930-merge:1.1
	carlton_dictionary-branch:1.1.0.2
	carlton_dictionary-20020927-merge:1.1.1.3
	tcltk840-20020924-branch:1.1.1.3.0.2
	tcltk840-20020924-branchpoint:1.1.1.3
	TK_8_4_0:1.1.1.2
	TCL_8_4_0:1.1.1.3
	NET:1.1.1;
locks; strict;
comment	@# @;


1.3
date	2003.01.21.19.40.16;	author hunt;	state Exp;
branches
	1.3.48.1;
next	1.2;

1.2
date	2002.11.26.19.48.01;	author hunt;	state Exp;
branches;
next	1.1;

1.1
date	2002.09.24.19.56.38;	author kseitz;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.4.1
	1.1.6.1;
next	;

1.3.48.1
date	2009.09.11.04.46.02;	author amylaar;	state Exp;
branches;
next	;

1.1.1.1
date	2002.09.24.19.56.38;	author kseitz;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.24.20.25.29;	author kseitz;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.22.01.38;	author kseitz;	state Exp;
branches;
next	;

1.1.2.1
date	2002.09.27.20.03.39;	author carlton;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2002.10.11.22.23.11;	author carlton;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2002.12.23.19.40.42;	author carlton;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2003.02.07.19.18.19;	author carlton;	state Exp;
branches;
next	;

1.1.4.1
date	2002.10.01.00.46.57;	author kseitz;	state Exp;
branches;
next	;

1.1.6.1
date	2003.12.14.20.28.49;	author drow;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Updated to tcl 8.4.1
@
text
@# This file contains a collection of tests for generic/tclMain.c.
#
# RCS: @@(#) $Id$

if {[catch {package require tcltest 2.0.2}]} {
    puts stderr "Skipping tests in [info script]. tcltest 2.0.2 required."
    return
}

namespace eval ::tcl::test::main {

    namespace import ::tcltest::test
    namespace import ::tcltest::testConstraint
    namespace import ::tcltest::interpreter
    namespace import ::tcltest::cleanupTests
    namespace import ::tcltest::makeFile
    namespace import ::tcltest::removeFile
    namespace import ::tcltest::temporaryDirectory
    namespace import ::tcltest::workingDirectory

    # Is [exec] defined?
    testConstraint exec [llength [info commands exec]]

    # Is the Tcltest package loaded?
    #	- that is, the special C-coded testing commands in tclTest.c
    #   - tests use testing commands introduced in Tcltest 8.4
    testConstraint Tcltest [expr {
	[llength [package provide Tcltest]]
	&& [package vsatisfies [package provide Tcltest] 8.4]}]

    # Procedure to simulate interactive typing of commands, line by line
    proc type {chan script} {
	foreach line [split $script \n] {
	    if {[catch {
	        puts $chan $line
	        flush $chan
	    }]} {
		return
	    }
	    # Grrr... Behavior depends on this value.
	    after 1000
	}
    }

    cd [temporaryDirectory]
    # Tests Tcl_Main-1.*: variable initializations

    test Tcl_Main-1.1 {
	Tcl_Main: startup script - normal
    } -constraints {
	stdio
    } -setup {
	makeFile {puts [list $argv0 $argv $tcl_interactive]} script
	catch {set f [open "|[list [interpreter] script]" r]}
    } -body {
	read $f
    } -cleanup {
	close $f
	removeFile script
    } -result [list script {} 0]\n

    test Tcl_Main-1.2 {
	Tcl_Main: startup script - can't begin with '-'
    } -constraints {
	stdio
    } -setup {
	makeFile {puts [list $argv0 $argv $tcl_interactive]} -script
	catch {set f [open "|[list [interpreter] -script]" w+]}
    } -body {
	puts $f {puts [list $argv0 $argv $tcl_interactive]; exit}
	flush $f
	read $f
    } -cleanup {
	close $f
	removeFile -script
    } -result [list [interpreter] -script 0]\n

    test Tcl_Main-1.3 {
	Tcl_Main: encoding of arguments: done by system encoding
	Note the shortcoming explained in Tcl Patch 491789
    } -constraints {
	stdio
    } -setup {
	makeFile {puts [list $argv0 $argv $tcl_interactive]} script
	catch {set f [open "|[list [interpreter] script \u00c0]" r]}
    } -body {
	read $f
    } -cleanup {
	close $f
	removeFile script
    } -result [list script [list [encoding convertfrom [encoding system] \
	[encoding convertto [encoding system] \u00c0]]] 0]\n

    test Tcl_Main-1.4 {
	Tcl_Main: encoding of arguments: done by system encoding
	Note the shortcoming explained in Tcl Patch 491789
    } -constraints {
	stdio
    } -setup {
	makeFile {puts [list $argv0 $argv $tcl_interactive]} script
	catch {set f [open "|[list [interpreter] script \u20ac]" r]}
    } -body {
	read $f
    } -cleanup {
	close $f
	removeFile script
    } -result [list script [list [encoding convertfrom [encoding system] \
	[encoding convertto [encoding system] \u20ac]]] 0]\n

    test Tcl_Main-1.5 {
	Tcl_Main: encoding of script name: system encoding loss
	Note the shortcoming explained in Tcl Patch 491789
    } -constraints {
	stdio
    } -setup {
	makeFile {puts [list $argv0 $argv $tcl_interactive]} \u00c0
	catch {set f [open "|[list [interpreter] \u00c0]" r]}
    } -body {
	read $f
    } -cleanup {
	close $f
	removeFile \u00c0
    } -result [list [list [encoding convertfrom [encoding system] \
	[encoding convertto [encoding system] \u00c0]]] {} 0]\n

    test Tcl_Main-1.6 {
	Tcl_Main: encoding of script name: system encoding loss
	Note the shortcoming explained in Tcl Patch 491789
    } -constraints {
	stdio	
    } -setup {
	makeFile {puts [list $argv0 $argv $tcl_interactive]} \u20ac
	catch {set f [open "|[list [interpreter] \u20ac]" r]}
    } -body {
	read $f
    } -cleanup {
	close $f
	removeFile \u20ac
    } -result [list [list [encoding convertfrom [encoding system] \
	[encoding convertto [encoding system] \u20ac]]] {} 0]\n

    # Tests Tcl_Main-2.*: application-initialization procedure

    test Tcl_Main-2.1 {
	Tcl_Main: appInitProc returns error
    } -constraints {
	exec Tcltest
    } -setup {
	makeFile {puts "In script"} script
    } -body {
	exec [interpreter] script -appinitprocerror >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
	removeFile script
    } -result "application-specific initialization failed: \nIn script\n"

    test Tcl_Main-2.2 {
	Tcl_Main: appInitProc returns error
    } -constraints {
	exec Tcltest
    } -body {
	exec [interpreter] << {puts "In script"} -appinitprocerror >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "application-specific initialization failed: \nIn script\n"

    test Tcl_Main-2.3 {
	Tcl_Main: appInitProc deletes interp
    } -constraints {
	exec Tcltest
    } -setup {
	makeFile {puts "In script"} script
    } -body {
	exec [interpreter] script -appinitprocdeleteinterp >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
	removeFile script
    } -result "application-specific initialization failed: \n"

    test Tcl_Main-2.4 {
	Tcl_Main: appInitProc deletes interp
    } -constraints {
	exec Tcltest
    } -body {
	exec [interpreter] << {puts "In script"} \
		-appinitprocdeleteinterp >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "application-specific initialization failed: \n"

    test Tcl_Main-2.5 {
	Tcl_Main: appInitProc closes stderr
    } -constraints {
	exec Tcltest
    } -body {
	exec [interpreter] << {puts "In script"} \
		-appinitprocclosestderr >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "In script\n"

    # Tests Tcl_Main-3.*: startup script evaluation

    test Tcl_Main-3.1 {
	Tcl_Main: startup script does not exist
    } -constraints {
	exec
    } -setup {
	catch {removeFile no-such-file}
    } -body {
	set code [catch {exec [interpreter] no-such-file >& result} result]
	set f [open result]
	list $code $result [read $f]
    } -cleanup {
	close $f
	file delete result
    } -match glob -result [list 1 {child process exited abnormally} \
	{couldn't read file "no-such-file":*}]

    test Tcl_Main-3.2 {
	Tcl_Main: startup script raises error
    } -constraints {
	exec
    } -setup {
	makeFile {error ERROR} script
    } -body {
	set code [catch {exec [interpreter] script >& result} result]
	set f [open result]
	list $code $result [read $f]
    } -cleanup {
	close $f
	file delete result
	removeFile script
    } -match glob -result [list 1 {child process exited abnormally} \
	"ERROR\n    while executing*"]

    test Tcl_Main-3.3 {
	Tcl_Main: startup script closes stderr
    } -constraints {
	exec
    } -setup {
	makeFile {close stderr; error ERROR} script
    } -body {
	set code [catch {exec [interpreter] script >& result} result]
	set f [open result]
	list $code $result [read $f]
    } -cleanup {
	close $f
	file delete result
	removeFile script
    } -result [list 1 {child process exited abnormally} {}]

    test Tcl_Main-3.4 {
	Tcl_Main: startup script holds incomplete script
    } -constraints {
	exec
    } -setup {
	makeFile "if 1 \{" script
    } -body {
	set code [catch {exec [interpreter] script >& result} result]
	set f [open result]
	list $code $result [read $f]
    } -cleanup {
	close $f
	file delete result
	removeFile script
    } -match glob -result [list 1 {child process exited abnormally}\
	"missing close-brace\n    while executing*"]

    test Tcl_Main-3.5 {
	Tcl_Main: startup script sets main loop
    } -constraints {
	exec Tcltest
    } -setup {
	makeFile {
		rename exit _exit
		proc exit {code} {
		    puts "In exit"
		    _exit $code
		}
		after 0 {
			puts event
			testexitmainloop
		}
		testexithandler create 0
		testsetmainloop
	} script
    } -body {
	exec [interpreter] script >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
	removeFile script
    } -result "event\nExit MainLoop\nIn exit\neven 0\n"

    test Tcl_Main-3.6 {
	Tcl_Main: startup script sets main loop and closes stdin
    } -constraints {
	exec Tcltest
    } -setup {
	makeFile {
		close stdin
		testsetmainloop
		rename exit _exit
		proc exit {code} {
		    puts "In exit"
		    _exit $code
		}
		after 0 {
			puts event
			testexitmainloop
		}
		testexithandler create 0
	} script
    } -body {
	exec [interpreter] script >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
	removeFile script
    } -result "event\nExit MainLoop\nIn exit\neven 0\n"

    test Tcl_Main-3.7 {
	Tcl_Main: startup script deletes interp
    } -constraints {
	exec Tcltest
    } -setup {
	makeFile {
		rename exit _exit
		proc exit {code} {
		    puts "In exit"
		    _exit $code
		}
		testexithandler create 0
		testinterpdelete {}
	} script
    } -body {
	exec [interpreter] script >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
	removeFile script
    } -result "even 0\n"

    test Tcl_Main-3.8 {
	Tcl_Main: startup script deletes interp and sets mainloop
    } -constraints {
	exec Tcltest
    } -setup {
	makeFile {
		testsetmainloop
		rename exit _exit
		proc exit {code} {
		    puts "In exit"
		    _exit $code
		}
		testexitmainloop
		testexithandler create 0
		testinterpdelete {}
	} script
    } -body {
	exec [interpreter] script >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
	removeFile script
    } -result "Exit MainLoop\neven 0\n"

    test Tcl_Main-3.9 {
	Tcl_Main: startup script can set tcl_interactive without limit
    } -constraints {
	exec
    } -setup {
	makeFile {set tcl_interactive foo} script
    } -body {
	exec [interpreter] script >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
	removeFile script
    } -result {}

    # Tests Tcl_Main-4.*: rc file evaluation

    test Tcl_Main-4.1 {
	Tcl_Main: rcFile evaluation deletes interp
    } -constraints {
	exec Tcltest
    } -setup {
	set rc [makeFile {testinterpdelete {}} rc]
    } -body {
	exec [interpreter] << {puts "In script"} \
		-appinitprocsetrcfile $rc >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
	removeFile rc
    } -result "application-specific initialization failed: \n"

    test Tcl_Main-4.2 {
	Tcl_Main: rcFile evaluation closes stdin
    } -constraints {
	exec Tcltest
    } -setup {
	set rc [makeFile {close stdin} rc]
    } -body {
	exec [interpreter] << {puts "In script"} \
		-appinitprocsetrcfile $rc >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
	removeFile rc
    } -result "application-specific initialization failed: \n"

    test Tcl_Main-4.3 {
	Tcl_Main: rcFile evaluation closes stdin and sets main loop
    } -constraints {
	exec Tcltest
    } -setup {
	set rc [makeFile {
		close stdin
		testsetmainloop
		after 0 testexitmainloop
		testexithandler create 0
		rename exit _exit
		proc exit code {
		    puts "In exit"
		    _exit $code
		}
	} rc]
    } -body {
	exec [interpreter] << {puts "In script"} \
		-appinitprocsetrcfile $rc >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
	removeFile rc
    } -result "application-specific initialization failed:\
	\nExit MainLoop\nIn exit\neven 0\n"

    test Tcl_Main-4.4 {
	Tcl_Main: rcFile evaluation sets main loop
    } -constraints {
	exec Tcltest
    } -setup {
	set rc [makeFile {
		testsetmainloop
		after 0 testexitmainloop
		testexithandler create 0
		rename exit _exit
		proc exit code {
		    puts "In exit"
		    _exit $code
		}
	} rc]
    } -body {
	exec [interpreter] << {puts "In script"} \
		-appinitprocsetrcfile $rc >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
	removeFile rc
    } -result "application-specific initialization failed:\
	\nIn script\nExit MainLoop\nIn exit\neven 0\n"

    # Tests Tcl_Main-5.*: interactive operations

    test Tcl_Main-5.1 {
	Tcl_Main: tcl_interactive must be boolean
    } -constraints {
	exec
    } -body {
	exec [interpreter] << {set tcl_interactive foo} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "can't set \"tcl_interactive\":\
	     variable must have boolean value\n"

    test Tcl_Main-5.2 {
	Tcl_Main able to handle non-blocking stdin
    } -constraints {
	exec
    } -setup {
	catch {set f [open "|[list [interpreter]]" w+]}
    } -body {
	type $f {
	    fconfigure stdin -blocking 0
	    puts SUCCESS
	}
	list [catch {gets $f} line] $line
    } -cleanup {
	close $f
    } -result [list 0 SUCCESS]

    test Tcl_Main-5.3 {
	Tcl_Main handles stdin EOF in mid-command
    } -constraints {
	exec
    } -setup {
	catch {set f [open "|[list [interpreter]]" w+]}
	catch {fconfigure $f -blocking 0}
    } -body {
	type $f "fconfigure stdin -eofchar \\032
	    if 1 \{\n\032"
	variable wait
	fileevent $f readable \
		[list set [namespace which -variable wait] "child exit"]
	set id [after 2000 [list set [namespace which -variable wait] timeout]]
	vwait [namespace which -variable wait]
	after cancel $id
	set wait
    } -cleanup {
	if {[string equal timeout $wait]
		&& [string equal unix $::tcl_platform(platform)]} {
	    exec kill [pid $f]
	}
	close $f
    } -result {child exit}

    test Tcl_Main-5.4 {
	Tcl_Main handles stdin EOF in mid-command
    } -constraints {
	exec
    } -setup {
	set cmd {makeFile "if 1 \{" script}
	catch {set f [open "|[list [interpreter]] < [list [eval $cmd]]" r]}
	catch {fconfigure $f -blocking 0}
    } -body {
	variable wait
	fileevent $f readable \
		[list set [namespace which -variable wait] "child exit"]
	set id [after 2000 [list set [namespace which -variable wait] timeout]]
	vwait [namespace which -variable wait]
	after cancel $id
	set wait
    } -cleanup {
	if {[string equal timeout $wait]
		&& [string equal unix $::tcl_platform(platform)]} {
	    exec kill [pid $f]
	}
	close $f
	removeFile script
    } -result {child exit}

    test Tcl_Main-5.5 {
	Tcl_Main: error raised in interactive mode
    } -constraints {
	exec
    } -body {
	exec [interpreter] << {error foo} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "foo\n"

    test Tcl_Main-5.6 {
	Tcl_Main: interactive mode: errors don't stop command loop
    } -constraints {
	exec
    } -body {
	exec [interpreter] << {
		error foo
		puts bar
	} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "foo\nbar\n"

    test Tcl_Main-5.7 {
	Tcl_Main: interactive mode: closed stderr
    } -constraints {
	exec
    } -body {
	exec [interpreter] << {
		close stderr
		error foo
		puts bar
	} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "bar\n"

    test Tcl_Main-5.8 {
	Tcl_Main: interactive mode: close stdin
		-> main loop & [exit] & exit handlers
    } -constraints {
	exec Tcltest
    } -body {
	exec [interpreter] << {
		rename exit _exit
		proc exit code {
		    puts "In exit"
		    _exit $code
		}
		testsetmainloop
		testexitmainloop
		testexithandler create 0
		close stdin
	} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "Exit MainLoop\nIn exit\neven 0\n"

    test Tcl_Main-5.9 {
	Tcl_Main: interactive mode: delete interp 
		-> main loop & exit handlers, but no [exit]
    } -constraints {
	exec Tcltest
    } -body {
	exec [interpreter] << {
		rename exit _exit
		proc exit code {
		    puts "In exit"
		    _exit $code
		}
		testsetmainloop
		testexitmainloop
		testexithandler create 0
		testinterpdelete {}
	} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "Exit MainLoop\neven 0\n"

    test Tcl_Main-5.10 {
	Tcl_Main: exit main loop in mid-interactive command
    } -constraints {
	exec Tcltest
    } -setup {
	catch {set f [open "|[list [interpreter]]" w+]}
	catch {fconfigure $f -blocking 0}
    } -body {
	type $f "testsetmainloop
	         after 2000 testexitmainloop
	         puts \{1 2"
	after 4000
	type $f "3 4\}"
	set code1 [catch {gets $f} line1]
	set code2 [catch {gets $f} line2]
	set code3 [catch {gets $f} line3]
	list $code1 $line1 $code2 $line2 $code3 $line3
    } -cleanup {
	close $f
    } -result [list 0 {Exit MainLoop} 0 {1 2} 0 {3 4}]

    test Tcl_Main-5.11 {
	Tcl_Main: EOF in interactive main loop
    } -constraints {
	exec Tcltest
    } -body {
	exec [interpreter] << {
		rename exit _exit
		proc exit code {
		    puts "In exit"
		    _exit $code
		}
		testexithandler create 0
		after 0 testexitmainloop
		testsetmainloop
	} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "Exit MainLoop\nIn exit\neven 0\n"

    test Tcl_Main-5.12 {
	Tcl_Main: close stdin in interactive main loop
    } -constraints {
	exec Tcltest
    } -body {
	exec [interpreter] << {
		rename exit _exit
		proc exit code {
		    puts "In exit"
		    _exit $code
		}
		testexithandler create 0
		after 100 testexitmainloop
		testsetmainloop
		close stdin
		puts "don't reach this"
	} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "Exit MainLoop\nIn exit\neven 0\n"

    # Tests Tcl_Main-6.*: interactive operations with prompts

    test Tcl_Main-6.1 {
	Tcl_Main: enable prompts with tcl_interactive
    } -constraints {
	exec
    } -body {
	exec [interpreter] << {set tcl_interactive 1} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "1\n% "

    test Tcl_Main-6.2 {
	Tcl_Main: prompt deletes interp
    } -constraints {
	exec Tcltest
    } -body {
	exec [interpreter] << {
		set tcl_prompt1 {testinterpdelete {}}
		set tcl_interactive 1
		puts "not reached"
	} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "1\n"

    test Tcl_Main-6.3 {
	Tcl_Main: prompt closes stdin
    } -constraints {
	exec
    } -body {
	exec [interpreter] << {
		set tcl_prompt1 {close stdin}
		set tcl_interactive 1
		puts "not reached"
	} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "1\n"

    test Tcl_Main-6.4 {
	Tcl_Main: interactive output, closed stdout
    } -constraints {
	exec
    } -body {
	exec [interpreter] << {
		set tcl_interactive 1
		close stdout
		set a NO
		puts stderr YES
	} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "1\n% YES\n"

    test Tcl_Main-6.5 {
	Tcl_Main: interactive entry to main loop
    } -constraints {
	exec Tcltest
    } -body {
	exec [interpreter] << {
		set tcl_interactive 1
		testsetmainloop
		testexitmainloop} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "1\n% % % Exit MainLoop\n"

    test Tcl_Main-6.6 {
	Tcl_Main: number of prompts during stdin close exit
    } -constraints {
	exec
    } -body {
	exec [interpreter] << {
		set tcl_interactive 1
		close stdin} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "1\n% "

    # Tests Tcl_Main-7.*: exiting

    test Tcl_Main-7.1 {
	Tcl_Main: [exit] defined as no-op -> still have exithandlers
    } -constraints {
	exec Tcltest
    } -body {
	exec [interpreter] << {
		proc exit args {}
		testexithandler create 0
	} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "even 0\n"

    test Tcl_Main-7.2 {
	Tcl_Main: [exit] defined as no-op -> still have exithandlers
    } -constraints {
	exec Tcltest
    } -body {
	exec [interpreter] << {
		proc exit args {}
		testexithandler create 0
		after 0 testexitmainloop
		testsetmainloop
	} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "Exit MainLoop\neven 0\n"

    # Tests Tcl_Main-8.*: StdinProc operations

    test Tcl_Main-8.1 {
	StdinProc: handles non-blocking stdin
    } -constraints {
	exec Tcltest
    } -body {
	exec [interpreter] << {
		testsetmainloop
		fconfigure stdin -blocking 0
		testexitmainloop
	} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "Exit MainLoop\n"

    test Tcl_Main-8.2 {
	StdinProc: handles stdin EOF
    } -constraints {
	exec Tcltest
    } -body {
	exec [interpreter] << {
		testsetmainloop
		testexithandler create 0
		rename exit _exit
		proc exit code {
		    puts "In exit"
		    _exit $code
		}
		after 100 testexitmainloop
	} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "Exit MainLoop\nIn exit\neven 0\n"

    test Tcl_Main-8.3 {
	StdinProc: handles interactive stdin EOF
    } -constraints {
	exec Tcltest
    } -body {
	exec [interpreter] << {
		testsetmainloop
		testexithandler create 0
		rename exit _exit
		proc exit code {
		    puts "In exit"
		    _exit $code
		}
		set tcl_interactive 1} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "1\n% even 0\n"

    test Tcl_Main-8.4 {
	StdinProc: handles stdin close
    } -constraints {
	exec Tcltest
    } -body {
	exec [interpreter] << {
		testsetmainloop
		rename exit _exit
		proc exit code {
		    puts "In exit"
		    _exit $code
		}
		after 100 testexitmainloop
		after 0 puts 1
		close stdin
	} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "1\nExit MainLoop\nIn exit\n"

    test Tcl_Main-8.5 {
	StdinProc: handles interactive stdin close
    } -constraints {
	exec Tcltest
    } -body {
	exec [interpreter] << {
		testsetmainloop
		set tcl_interactive 1
		rename exit _exit
		proc exit code {
		    puts "In exit"
		    _exit $code
		}
		after 100 testexitmainloop
		after 0 puts 1
		close stdin
	} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "1\n% % % after#0\n% after#1\n% 1\nExit MainLoop\nIn exit\n"

    test Tcl_Main-8.6 {
	StdinProc: handles event loop re-entry
    } -constraints {
	exec Tcltest
    } -body {
	exec [interpreter] << {
		testsetmainloop
		after 100 {puts 1; set delay 1}
		vwait delay
		puts 2
		testexitmainloop
	} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "1\n2\nExit MainLoop\n"

    test Tcl_Main-8.7 {
	StdinProc: handling of errors
    } -constraints {
	exec Tcltest
    } -body {
	exec [interpreter] << {
		testsetmainloop
		error foo
		testexitmainloop
	} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "foo\nExit MainLoop\n"

    test Tcl_Main-8.8 {
	StdinProc: handling of errors, closed stderr
    } -constraints {
	exec Tcltest
    } -body {
	exec [interpreter] << {
		testsetmainloop
		close stderr
		error foo
		testexitmainloop
	} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "Exit MainLoop\n"

    test Tcl_Main-8.9 {
	StdinProc: interactive output
    } -constraints {
	exec Tcltest
    } -body {
	exec [interpreter] << {
		testsetmainloop
		set tcl_interactive 1
		testexitmainloop} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "1\n% % Exit MainLoop\n"

    test Tcl_Main-8.10 {
	StdinProc: interactive output, closed stdout
    } -constraints {
	exec Tcltest
    } -body {
	exec [interpreter] << {
		testsetmainloop
		close stdout
		set tcl_interactive 1
		testexitmainloop
	} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result {}

    test Tcl_Main-8.11 {
	StdinProc: prompt deletes interp
    } -constraints {
	exec Tcltest
    } -body {
	exec [interpreter] << {
		testsetmainloop
		set tcl_prompt1 {testinterpdelete {}}
		set tcl_interactive 1} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "1\n"

    test Tcl_Main-8.12 {
	StdinProc: prompt closes stdin
    } -constraints {
	exec Tcltest
    } -body {
	exec [interpreter] << {
		testsetmainloop
		set tcl_prompt1 {close stdin}
		after 100 testexitmainloop
		set tcl_interactive 1
		puts "not reached"
	} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "1\nExit MainLoop\n"

    # Tests Tcl_Main-9.*: Prompt operations

    test Tcl_Main-9.1 {
	Prompt: custom prompt variables
    } -constraints {
	exec
    } -body {
	exec [interpreter] << {
		set tcl_prompt1 {puts -nonewline stdout "one "}
		set tcl_prompt2 {puts -nonewline stdout "two "}
		set tcl_interactive 1
		puts {This is
		a test}} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "1\none two This is\n\t\ta test\none "

    test Tcl_Main-9.2 {
	Prompt: error in custom prompt variables
    } -constraints {
	exec
    } -body {
	exec [interpreter] << {
		set tcl_prompt1 {error foo}
		set tcl_interactive 1
		set errorInfo} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "1\nfoo\n% foo\n    while executing\n\"error foo\"\n    (script\
	that generates prompt)\nfoo\n% "

    test Tcl_Main-9.3 {
	Prompt: error in custom prompt variables, closed stderr
    } -constraints {
	exec
    } -body {
	exec [interpreter] << {
		set tcl_prompt1 {close stderr; error foo}
		set tcl_interactive 1} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "1\n% "

    test Tcl_Main-9.4 {
	Prompt: error in custom prompt variables, closed stdout
    } -constraints {
	exec
    } -body {
	exec [interpreter] << {
		set tcl_prompt1 {close stdout; error foo}
		set tcl_interactive 1} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "1\nfoo\n"

    cd [workingDirectory]

    cleanupTests
}

namespace delete ::tcl::test::main
return
@


1.3.48.1
log
@gdb/insight for ARCompact (from Richard Stuckey)
@
text
@d3 1
a3 1
# RCS: @@(#) $Id: main.test,v 1.3 2003/01/21 19:40:16 hunt Exp $
@


1.2
log
@touched all sources to ease next import
@
text
@d3 1
a3 1
# RCS: @@(#) $Id: main.test,v 1.1 2002/09/24 19:56:38 kseitz Exp $
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
# RCS: @@(#) $Id$
@


1.1.6.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d3 1
a3 1
# RCS: @@(#) $Id: main.test,v 1.3 2003/01/21 19:40:16 hunt Exp $
@


1.1.4.1
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d3 1
a3 1
# RCS: @@(#) $Id: main.test,v 1.1 2002/09/24 19:56:38 kseitz Exp $
@


1.1.2.1
log
@Merge with mainline; tag is carlton_dictionary-20020927-merge
@
text
@d3 1
a3 1
# RCS: @@(#) $Id: main.test,v 1.1.1.3 2002/09/24 22:01:38 kseitz Exp $
@


1.1.2.2
log
@Merge with mainline; merge tag carlton_dictionary-20021011-merge.
@
text
@d3 1
a3 1
# RCS: @@(#) $Id: main.test,v 1.1 2002/09/24 19:56:38 kseitz Exp $
@


1.1.2.3
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d3 1
a3 1
# RCS: @@(#) $Id: main.test,v 1.1.2.2 2002/10/11 22:23:11 carlton Exp $
@


1.1.2.4
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d3 1
a3 1
# RCS: @@(#) $Id: main.test,v 1.1.2.3 2002/12/23 19:40:42 carlton Exp $
@


1.1.1.1
log
@import tcl 8.4.0
@
text
@@


1.1.1.2
log
@import tk 8.4.0
@
text
@d1 1
a1 1
# This file contains tests for the tkMain.c file.
d3 27
a29 9
# This file contains a collection of tests for one or more of the Tcl
# built-in commands.  Sourcing this file into Tcl runs the tests and
# generates output for errors.  No output means no errors were found.
#
# Copyright (c) 1997 by Sun Microsystems, Inc.
# Copyright (c) 1998-1999 by Scriptics Corporation.
# All rights reserved.
#
# RCS: @@(#) $Id: main.test,v 1.6 2002/07/13 20:28:35 dgp Exp $
d31 12
a42 19
package require tcltest 2.1
namespace import -force tcltest::configure
namespace import -force tcltest::testsDirectory
configure -testdir [file join [pwd] [file dirname [info script]]]
configure -loadfile [file join [testsDirectory] constraints.tcl]
tcltest::loadTestedCommands

namespace import -force tcltest::interpreter
namespace import -force tcltest::makeFile
namespace import -force tcltest::removeFile

test main-1.1 {StdinProc} {unix} {
    set script [makeFile {
	close stdin; exit
    } script]
    if {[catch {exec [interpreter] <$script} msg]} {
	set error 1
    } else {
	set error 0
a43 3
    removeFile script
    list $error $msg
} {0 {}}
d45 975
a1019 3
# cleanup
::tcltest::cleanupTests
return
d1021 17
d1039 15
d1055 17
d1073 15
d1089 18
d1108 1
d1110 17
d1128 16
d1145 14
d1160 14
d1175 1
d1177 2
d1180 2
@


1.1.1.3
log
@one more time: import tcl 8.4.0
@
text
@d1 1
a1 1
# This file contains a collection of tests for generic/tclMain.c.
d3 9
a11 17
# RCS: @@(#) $Id$

if {[catch {package require tcltest 2.0.2}]} {
    puts stderr "Skipping tests in [info script]. tcltest 2.0.2 required."
    return
}

namespace eval ::tcl::test::main {

    namespace import ::tcltest::test
    namespace import ::tcltest::testConstraint
    namespace import ::tcltest::interpreter
    namespace import ::tcltest::cleanupTests
    namespace import ::tcltest::makeFile
    namespace import ::tcltest::removeFile
    namespace import ::tcltest::temporaryDirectory
    namespace import ::tcltest::workingDirectory
d13 19
a31 22
    # Is [exec] defined?
    testConstraint exec [llength [info commands exec]]

    # Is the Tcltest package loaded?
    #	- that is, the special C-coded testing commands in tclTest.c
    #   - tests use testing commands introduced in Tcltest 8.4
    testConstraint Tcltest [expr {
	[llength [package provide Tcltest]]
	&& [package vsatisfies [package provide Tcltest] 8.4]}]

    # Procedure to simulate interactive typing of commands, line by line
    proc type {chan script} {
	foreach line [split $script \n] {
	    if {[catch {
	        puts $chan $line
	        flush $chan
	    }]} {
		return
	    }
	    # Grrr... Behavior depends on this value.
	    after 1000
	}
d33 3
d37 3
a39 426
    cd [temporaryDirectory]
    # Tests Tcl_Main-1.*: variable initializations

    test Tcl_Main-1.1 {
	Tcl_Main: startup script - normal
    } -constraints {
	stdio
    } -setup {
	makeFile {puts [list $argv0 $argv $tcl_interactive]} script
	catch {set f [open "|[list [interpreter] script]" r]}
    } -body {
	read $f
    } -cleanup {
	close $f
	removeFile script
    } -result [list script {} 0]\n

    test Tcl_Main-1.2 {
	Tcl_Main: startup script - can't begin with '-'
    } -constraints {
	stdio
    } -setup {
	makeFile {puts [list $argv0 $argv $tcl_interactive]} -script
	catch {set f [open "|[list [interpreter] -script]" w+]}
    } -body {
	puts $f {puts [list $argv0 $argv $tcl_interactive]; exit}
	flush $f
	read $f
    } -cleanup {
	close $f
	removeFile -script
    } -result [list [interpreter] -script 0]\n

    test Tcl_Main-1.3 {
	Tcl_Main: encoding of arguments: done by system encoding
	Note the shortcoming explained in Tcl Patch 491789
    } -constraints {
	stdio
    } -setup {
	makeFile {puts [list $argv0 $argv $tcl_interactive]} script
	catch {set f [open "|[list [interpreter] script \u00c0]" r]}
    } -body {
	read $f
    } -cleanup {
	close $f
	removeFile script
    } -result [list script [list [encoding convertfrom [encoding system] \
	[encoding convertto [encoding system] \u00c0]]] 0]\n

    test Tcl_Main-1.4 {
	Tcl_Main: encoding of arguments: done by system encoding
	Note the shortcoming explained in Tcl Patch 491789
    } -constraints {
	stdio
    } -setup {
	makeFile {puts [list $argv0 $argv $tcl_interactive]} script
	catch {set f [open "|[list [interpreter] script \u20ac]" r]}
    } -body {
	read $f
    } -cleanup {
	close $f
	removeFile script
    } -result [list script [list [encoding convertfrom [encoding system] \
	[encoding convertto [encoding system] \u20ac]]] 0]\n

    test Tcl_Main-1.5 {
	Tcl_Main: encoding of script name: system encoding loss
	Note the shortcoming explained in Tcl Patch 491789
    } -constraints {
	stdio
    } -setup {
	makeFile {puts [list $argv0 $argv $tcl_interactive]} \u00c0
	catch {set f [open "|[list [interpreter] \u00c0]" r]}
    } -body {
	read $f
    } -cleanup {
	close $f
	removeFile \u00c0
    } -result [list [list [encoding convertfrom [encoding system] \
	[encoding convertto [encoding system] \u00c0]]] {} 0]\n

    test Tcl_Main-1.6 {
	Tcl_Main: encoding of script name: system encoding loss
	Note the shortcoming explained in Tcl Patch 491789
    } -constraints {
	stdio	
    } -setup {
	makeFile {puts [list $argv0 $argv $tcl_interactive]} \u20ac
	catch {set f [open "|[list [interpreter] \u20ac]" r]}
    } -body {
	read $f
    } -cleanup {
	close $f
	removeFile \u20ac
    } -result [list [list [encoding convertfrom [encoding system] \
	[encoding convertto [encoding system] \u20ac]]] {} 0]\n

    # Tests Tcl_Main-2.*: application-initialization procedure

    test Tcl_Main-2.1 {
	Tcl_Main: appInitProc returns error
    } -constraints {
	exec Tcltest
    } -setup {
	makeFile {puts "In script"} script
    } -body {
	exec [interpreter] script -appinitprocerror >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
	removeFile script
    } -result "application-specific initialization failed: \nIn script\n"

    test Tcl_Main-2.2 {
	Tcl_Main: appInitProc returns error
    } -constraints {
	exec Tcltest
    } -body {
	exec [interpreter] << {puts "In script"} -appinitprocerror >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "application-specific initialization failed: \nIn script\n"

    test Tcl_Main-2.3 {
	Tcl_Main: appInitProc deletes interp
    } -constraints {
	exec Tcltest
    } -setup {
	makeFile {puts "In script"} script
    } -body {
	exec [interpreter] script -appinitprocdeleteinterp >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
	removeFile script
    } -result "application-specific initialization failed: \n"

    test Tcl_Main-2.4 {
	Tcl_Main: appInitProc deletes interp
    } -constraints {
	exec Tcltest
    } -body {
	exec [interpreter] << {puts "In script"} \
		-appinitprocdeleteinterp >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "application-specific initialization failed: \n"

    test Tcl_Main-2.5 {
	Tcl_Main: appInitProc closes stderr
    } -constraints {
	exec Tcltest
    } -body {
	exec [interpreter] << {puts "In script"} \
		-appinitprocclosestderr >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "In script\n"

    # Tests Tcl_Main-3.*: startup script evaluation

    test Tcl_Main-3.1 {
	Tcl_Main: startup script does not exist
    } -constraints {
	exec
    } -setup {
	catch {removeFile no-such-file}
    } -body {
	set code [catch {exec [interpreter] no-such-file >& result} result]
	set f [open result]
	list $code $result [read $f]
    } -cleanup {
	close $f
	file delete result
    } -match glob -result [list 1 {child process exited abnormally} \
	{couldn't read file "no-such-file":*}]

    test Tcl_Main-3.2 {
	Tcl_Main: startup script raises error
    } -constraints {
	exec
    } -setup {
	makeFile {error ERROR} script
    } -body {
	set code [catch {exec [interpreter] script >& result} result]
	set f [open result]
	list $code $result [read $f]
    } -cleanup {
	close $f
	file delete result
	removeFile script
    } -match glob -result [list 1 {child process exited abnormally} \
	"ERROR\n    while executing*"]

    test Tcl_Main-3.3 {
	Tcl_Main: startup script closes stderr
    } -constraints {
	exec
    } -setup {
	makeFile {close stderr; error ERROR} script
    } -body {
	set code [catch {exec [interpreter] script >& result} result]
	set f [open result]
	list $code $result [read $f]
    } -cleanup {
	close $f
	file delete result
	removeFile script
    } -result [list 1 {child process exited abnormally} {}]

    test Tcl_Main-3.4 {
	Tcl_Main: startup script holds incomplete script
    } -constraints {
	exec
    } -setup {
	makeFile "if 1 \{" script
    } -body {
	set code [catch {exec [interpreter] script >& result} result]
	set f [open result]
	list $code $result [read $f]
    } -cleanup {
	close $f
	file delete result
	removeFile script
    } -match glob -result [list 1 {child process exited abnormally}\
	"missing close-brace\n    while executing*"]

    test Tcl_Main-3.5 {
	Tcl_Main: startup script sets main loop
    } -constraints {
	exec Tcltest
    } -setup {
	makeFile {
		rename exit _exit
		proc exit {code} {
		    puts "In exit"
		    _exit $code
		}
		after 0 {
			puts event
			testexitmainloop
		}
		testexithandler create 0
		testsetmainloop
	} script
    } -body {
	exec [interpreter] script >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
	removeFile script
    } -result "event\nExit MainLoop\nIn exit\neven 0\n"

    test Tcl_Main-3.6 {
	Tcl_Main: startup script sets main loop and closes stdin
    } -constraints {
	exec Tcltest
    } -setup {
	makeFile {
		close stdin
		testsetmainloop
		rename exit _exit
		proc exit {code} {
		    puts "In exit"
		    _exit $code
		}
		after 0 {
			puts event
			testexitmainloop
		}
		testexithandler create 0
	} script
    } -body {
	exec [interpreter] script >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
	removeFile script
    } -result "event\nExit MainLoop\nIn exit\neven 0\n"

    test Tcl_Main-3.7 {
	Tcl_Main: startup script deletes interp
    } -constraints {
	exec Tcltest
    } -setup {
	makeFile {
		rename exit _exit
		proc exit {code} {
		    puts "In exit"
		    _exit $code
		}
		testexithandler create 0
		testinterpdelete {}
	} script
    } -body {
	exec [interpreter] script >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
	removeFile script
    } -result "even 0\n"

    test Tcl_Main-3.8 {
	Tcl_Main: startup script deletes interp and sets mainloop
    } -constraints {
	exec Tcltest
    } -setup {
	makeFile {
		testsetmainloop
		rename exit _exit
		proc exit {code} {
		    puts "In exit"
		    _exit $code
		}
		testexitmainloop
		testexithandler create 0
		testinterpdelete {}
	} script
    } -body {
	exec [interpreter] script >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
	removeFile script
    } -result "Exit MainLoop\neven 0\n"

    test Tcl_Main-3.9 {
	Tcl_Main: startup script can set tcl_interactive without limit
    } -constraints {
	exec
    } -setup {
	makeFile {set tcl_interactive foo} script
    } -body {
	exec [interpreter] script >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
	removeFile script
    } -result {}

    # Tests Tcl_Main-4.*: rc file evaluation

    test Tcl_Main-4.1 {
	Tcl_Main: rcFile evaluation deletes interp
    } -constraints {
	exec Tcltest
    } -setup {
	set rc [makeFile {testinterpdelete {}} rc]
    } -body {
	exec [interpreter] << {puts "In script"} \
		-appinitprocsetrcfile $rc >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
	removeFile rc
    } -result "application-specific initialization failed: \n"

    test Tcl_Main-4.2 {
	Tcl_Main: rcFile evaluation closes stdin
    } -constraints {
	exec Tcltest
    } -setup {
	set rc [makeFile {close stdin} rc]
    } -body {
	exec [interpreter] << {puts "In script"} \
		-appinitprocsetrcfile $rc >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
	removeFile rc
    } -result "application-specific initialization failed: \n"

    test Tcl_Main-4.3 {
	Tcl_Main: rcFile evaluation closes stdin and sets main loop
    } -constraints {
	exec Tcltest
    } -setup {
	set rc [makeFile {
		close stdin
		testsetmainloop
		after 0 testexitmainloop
		testexithandler create 0
		rename exit _exit
		proc exit code {
		    puts "In exit"
		    _exit $code
		}
	} rc]
    } -body {
	exec [interpreter] << {puts "In script"} \
		-appinitprocsetrcfile $rc >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
	removeFile rc
    } -result "application-specific initialization failed:\
	\nExit MainLoop\nIn exit\neven 0\n"
a40 26
    test Tcl_Main-4.4 {
	Tcl_Main: rcFile evaluation sets main loop
    } -constraints {
	exec Tcltest
    } -setup {
	set rc [makeFile {
		testsetmainloop
		after 0 testexitmainloop
		testexithandler create 0
		rename exit _exit
		proc exit code {
		    puts "In exit"
		    _exit $code
		}
	} rc]
    } -body {
	exec [interpreter] << {puts "In script"} \
		-appinitprocsetrcfile $rc >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
	removeFile rc
    } -result "application-specific initialization failed:\
	\nIn script\nExit MainLoop\nIn exit\neven 0\n"
a41 1
    # Tests Tcl_Main-5.*: interactive operations
a42 13
    test Tcl_Main-5.1 {
	Tcl_Main: tcl_interactive must be boolean
    } -constraints {
	exec
    } -body {
	exec [interpreter] << {set tcl_interactive foo} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "can't set \"tcl_interactive\":\
	     variable must have boolean value\n"
a43 15
    test Tcl_Main-5.2 {
	Tcl_Main able to handle non-blocking stdin
    } -constraints {
	exec
    } -setup {
	catch {set f [open "|[list [interpreter]]" w+]}
    } -body {
	type $f {
	    fconfigure stdin -blocking 0
	    puts SUCCESS
	}
	list [catch {gets $f} line] $line
    } -cleanup {
	close $f
    } -result [list 0 SUCCESS]
a44 24
    test Tcl_Main-5.3 {
	Tcl_Main handles stdin EOF in mid-command
    } -constraints {
	exec
    } -setup {
	catch {set f [open "|[list [interpreter]]" w+]}
	catch {fconfigure $f -blocking 0}
    } -body {
	type $f "fconfigure stdin -eofchar \\032
	    if 1 \{\n\032"
	variable wait
	fileevent $f readable \
		[list set [namespace which -variable wait] "child exit"]
	set id [after 2000 [list set [namespace which -variable wait] timeout]]
	vwait [namespace which -variable wait]
	after cancel $id
	set wait
    } -cleanup {
	if {[string equal timeout $wait]
		&& [string equal unix $::tcl_platform(platform)]} {
	    exec kill [pid $f]
	}
	close $f
    } -result {child exit}
a45 24
    test Tcl_Main-5.4 {
	Tcl_Main handles stdin EOF in mid-command
    } -constraints {
	exec
    } -setup {
	set cmd {makeFile "if 1 \{" script}
	catch {set f [open "|[list [interpreter]] < [list [eval $cmd]]" r]}
	catch {fconfigure $f -blocking 0}
    } -body {
	variable wait
	fileevent $f readable \
		[list set [namespace which -variable wait] "child exit"]
	set id [after 2000 [list set [namespace which -variable wait] timeout]]
	vwait [namespace which -variable wait]
	after cancel $id
	set wait
    } -cleanup {
	if {[string equal timeout $wait]
		&& [string equal unix $::tcl_platform(platform)]} {
	    exec kill [pid $f]
	}
	close $f
	removeFile script
    } -result {child exit}
a46 12
    test Tcl_Main-5.5 {
	Tcl_Main: error raised in interactive mode
    } -constraints {
	exec
    } -body {
	exec [interpreter] << {error foo} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "foo\n"
a47 15
    test Tcl_Main-5.6 {
	Tcl_Main: interactive mode: errors don't stop command loop
    } -constraints {
	exec
    } -body {
	exec [interpreter] << {
		error foo
		puts bar
	} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "foo\nbar\n"
a48 16
    test Tcl_Main-5.7 {
	Tcl_Main: interactive mode: closed stderr
    } -constraints {
	exec
    } -body {
	exec [interpreter] << {
		close stderr
		error foo
		puts bar
	} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "bar\n"
a49 23
    test Tcl_Main-5.8 {
	Tcl_Main: interactive mode: close stdin
		-> main loop & [exit] & exit handlers
    } -constraints {
	exec Tcltest
    } -body {
	exec [interpreter] << {
		rename exit _exit
		proc exit code {
		    puts "In exit"
		    _exit $code
		}
		testsetmainloop
		testexitmainloop
		testexithandler create 0
		close stdin
	} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "Exit MainLoop\nIn exit\neven 0\n"
a50 23
    test Tcl_Main-5.9 {
	Tcl_Main: interactive mode: delete interp 
		-> main loop & exit handlers, but no [exit]
    } -constraints {
	exec Tcltest
    } -body {
	exec [interpreter] << {
		rename exit _exit
		proc exit code {
		    puts "In exit"
		    _exit $code
		}
		testsetmainloop
		testexitmainloop
		testexithandler create 0
		testinterpdelete {}
	} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "Exit MainLoop\neven 0\n"
a51 20
    test Tcl_Main-5.10 {
	Tcl_Main: exit main loop in mid-interactive command
    } -constraints {
	exec Tcltest
    } -setup {
	catch {set f [open "|[list [interpreter]]" w+]}
	catch {fconfigure $f -blocking 0}
    } -body {
	type $f "testsetmainloop
	         after 2000 testexitmainloop
	         puts \{1 2"
	after 4000
	type $f "3 4\}"
	set code1 [catch {gets $f} line1]
	set code2 [catch {gets $f} line2]
	set code3 [catch {gets $f} line3]
	list $code1 $line1 $code2 $line2 $code3 $line3
    } -cleanup {
	close $f
    } -result [list 0 {Exit MainLoop} 0 {1 2} 0 {3 4}]
a52 486
    test Tcl_Main-5.11 {
	Tcl_Main: EOF in interactive main loop
    } -constraints {
	exec Tcltest
    } -body {
	exec [interpreter] << {
		rename exit _exit
		proc exit code {
		    puts "In exit"
		    _exit $code
		}
		testexithandler create 0
		after 0 testexitmainloop
		testsetmainloop
	} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "Exit MainLoop\nIn exit\neven 0\n"

    test Tcl_Main-5.12 {
	Tcl_Main: close stdin in interactive main loop
    } -constraints {
	exec Tcltest
    } -body {
	exec [interpreter] << {
		rename exit _exit
		proc exit code {
		    puts "In exit"
		    _exit $code
		}
		testexithandler create 0
		after 100 testexitmainloop
		testsetmainloop
		close stdin
		puts "don't reach this"
	} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "Exit MainLoop\nIn exit\neven 0\n"

    # Tests Tcl_Main-6.*: interactive operations with prompts

    test Tcl_Main-6.1 {
	Tcl_Main: enable prompts with tcl_interactive
    } -constraints {
	exec
    } -body {
	exec [interpreter] << {set tcl_interactive 1} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "1\n% "

    test Tcl_Main-6.2 {
	Tcl_Main: prompt deletes interp
    } -constraints {
	exec Tcltest
    } -body {
	exec [interpreter] << {
		set tcl_prompt1 {testinterpdelete {}}
		set tcl_interactive 1
		puts "not reached"
	} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "1\n"

    test Tcl_Main-6.3 {
	Tcl_Main: prompt closes stdin
    } -constraints {
	exec
    } -body {
	exec [interpreter] << {
		set tcl_prompt1 {close stdin}
		set tcl_interactive 1
		puts "not reached"
	} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "1\n"

    test Tcl_Main-6.4 {
	Tcl_Main: interactive output, closed stdout
    } -constraints {
	exec
    } -body {
	exec [interpreter] << {
		set tcl_interactive 1
		close stdout
		set a NO
		puts stderr YES
	} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "1\n% YES\n"

    test Tcl_Main-6.5 {
	Tcl_Main: interactive entry to main loop
    } -constraints {
	exec Tcltest
    } -body {
	exec [interpreter] << {
		set tcl_interactive 1
		testsetmainloop
		testexitmainloop} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "1\n% % % Exit MainLoop\n"

    test Tcl_Main-6.6 {
	Tcl_Main: number of prompts during stdin close exit
    } -constraints {
	exec
    } -body {
	exec [interpreter] << {
		set tcl_interactive 1
		close stdin} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "1\n% "

    # Tests Tcl_Main-7.*: exiting

    test Tcl_Main-7.1 {
	Tcl_Main: [exit] defined as no-op -> still have exithandlers
    } -constraints {
	exec Tcltest
    } -body {
	exec [interpreter] << {
		proc exit args {}
		testexithandler create 0
	} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "even 0\n"

    test Tcl_Main-7.2 {
	Tcl_Main: [exit] defined as no-op -> still have exithandlers
    } -constraints {
	exec Tcltest
    } -body {
	exec [interpreter] << {
		proc exit args {}
		testexithandler create 0
		after 0 testexitmainloop
		testsetmainloop
	} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "Exit MainLoop\neven 0\n"

    # Tests Tcl_Main-8.*: StdinProc operations

    test Tcl_Main-8.1 {
	StdinProc: handles non-blocking stdin
    } -constraints {
	exec Tcltest
    } -body {
	exec [interpreter] << {
		testsetmainloop
		fconfigure stdin -blocking 0
		testexitmainloop
	} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "Exit MainLoop\n"

    test Tcl_Main-8.2 {
	StdinProc: handles stdin EOF
    } -constraints {
	exec Tcltest
    } -body {
	exec [interpreter] << {
		testsetmainloop
		testexithandler create 0
		rename exit _exit
		proc exit code {
		    puts "In exit"
		    _exit $code
		}
		after 100 testexitmainloop
	} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "Exit MainLoop\nIn exit\neven 0\n"

    test Tcl_Main-8.3 {
	StdinProc: handles interactive stdin EOF
    } -constraints {
	exec Tcltest
    } -body {
	exec [interpreter] << {
		testsetmainloop
		testexithandler create 0
		rename exit _exit
		proc exit code {
		    puts "In exit"
		    _exit $code
		}
		set tcl_interactive 1} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "1\n% even 0\n"

    test Tcl_Main-8.4 {
	StdinProc: handles stdin close
    } -constraints {
	exec Tcltest
    } -body {
	exec [interpreter] << {
		testsetmainloop
		rename exit _exit
		proc exit code {
		    puts "In exit"
		    _exit $code
		}
		after 100 testexitmainloop
		after 0 puts 1
		close stdin
	} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "1\nExit MainLoop\nIn exit\n"

    test Tcl_Main-8.5 {
	StdinProc: handles interactive stdin close
    } -constraints {
	exec Tcltest
    } -body {
	exec [interpreter] << {
		testsetmainloop
		set tcl_interactive 1
		rename exit _exit
		proc exit code {
		    puts "In exit"
		    _exit $code
		}
		after 100 testexitmainloop
		after 0 puts 1
		close stdin
	} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "1\n% % % after#0\n% after#1\n% 1\nExit MainLoop\nIn exit\n"

    test Tcl_Main-8.6 {
	StdinProc: handles event loop re-entry
    } -constraints {
	exec Tcltest
    } -body {
	exec [interpreter] << {
		testsetmainloop
		after 100 {puts 1; set delay 1}
		vwait delay
		puts 2
		testexitmainloop
	} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "1\n2\nExit MainLoop\n"

    test Tcl_Main-8.7 {
	StdinProc: handling of errors
    } -constraints {
	exec Tcltest
    } -body {
	exec [interpreter] << {
		testsetmainloop
		error foo
		testexitmainloop
	} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "foo\nExit MainLoop\n"

    test Tcl_Main-8.8 {
	StdinProc: handling of errors, closed stderr
    } -constraints {
	exec Tcltest
    } -body {
	exec [interpreter] << {
		testsetmainloop
		close stderr
		error foo
		testexitmainloop
	} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "Exit MainLoop\n"

    test Tcl_Main-8.9 {
	StdinProc: interactive output
    } -constraints {
	exec Tcltest
    } -body {
	exec [interpreter] << {
		testsetmainloop
		set tcl_interactive 1
		testexitmainloop} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "1\n% % Exit MainLoop\n"

    test Tcl_Main-8.10 {
	StdinProc: interactive output, closed stdout
    } -constraints {
	exec Tcltest
    } -body {
	exec [interpreter] << {
		testsetmainloop
		close stdout
		set tcl_interactive 1
		testexitmainloop
	} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result {}

    test Tcl_Main-8.11 {
	StdinProc: prompt deletes interp
    } -constraints {
	exec Tcltest
    } -body {
	exec [interpreter] << {
		testsetmainloop
		set tcl_prompt1 {testinterpdelete {}}
		set tcl_interactive 1} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "1\n"

    test Tcl_Main-8.12 {
	StdinProc: prompt closes stdin
    } -constraints {
	exec Tcltest
    } -body {
	exec [interpreter] << {
		testsetmainloop
		set tcl_prompt1 {close stdin}
		after 100 testexitmainloop
		set tcl_interactive 1
		puts "not reached"
	} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "1\nExit MainLoop\n"

    # Tests Tcl_Main-9.*: Prompt operations

    test Tcl_Main-9.1 {
	Prompt: custom prompt variables
    } -constraints {
	exec
    } -body {
	exec [interpreter] << {
		set tcl_prompt1 {puts -nonewline stdout "one "}
		set tcl_prompt2 {puts -nonewline stdout "two "}
		set tcl_interactive 1
		puts {This is
		a test}} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "1\none two This is\n\t\ta test\none "

    test Tcl_Main-9.2 {
	Prompt: error in custom prompt variables
    } -constraints {
	exec
    } -body {
	exec [interpreter] << {
		set tcl_prompt1 {error foo}
		set tcl_interactive 1
		set errorInfo} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "1\nfoo\n% foo\n    while executing\n\"error foo\"\n    (script\
	that generates prompt)\nfoo\n% "

    test Tcl_Main-9.3 {
	Prompt: error in custom prompt variables, closed stderr
    } -constraints {
	exec
    } -body {
	exec [interpreter] << {
		set tcl_prompt1 {close stderr; error foo}
		set tcl_interactive 1} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "1\n% "

    test Tcl_Main-9.4 {
	Prompt: error in custom prompt variables, closed stdout
    } -constraints {
	exec
    } -body {
	exec [interpreter] << {
		set tcl_prompt1 {close stdout; error foo}
		set tcl_interactive 1} >& result
	set f [open result]
	read $f
    } -cleanup {
	close $f
	file delete result
    } -result "1\nfoo\n"

    cd [workingDirectory]

    cleanupTests
}

namespace delete ::tcl::test::main
return
@


