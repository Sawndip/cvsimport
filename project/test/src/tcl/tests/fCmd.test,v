head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.58
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.56
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.54
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.52
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.50
	gdb_7_0-branch:1.5.0.48
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tcl8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.46
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.44
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.42
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.40
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.38
	gdb_6_5-2006-05-14-branchpoint:1.5
	readline_5_1-import-branch:1.5.0.36
	readline_5_1-import-branchpoint:1.5
	gdb_6_4-branch:1.5.0.34
	gdb_6_4-2005-11-01-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.32
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	ezannoni_pie-20040323-branch:1.5.0.30
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.28
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.26
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.24
	cagney_x86i386-20030821-branch:1.5.0.22
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.20
	gdb_6_0-2003-06-23-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.18
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.16
	cagney_writestrings-20030508-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.14
	cagney_fileio-20030521-branchpoint:1.5
	carlton_dictionary-20030430-merge:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.12
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.10
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.8
	cagney_lazyid-20030317-branchpoint:1.5
	offbyone-20030313-branch:1.5.0.6
	offbyone-20030313-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.4
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.2
	interps-20030202-branchpoint:1.5
	TCL8_4_1:1.1.1.4
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.2
	TCL_8_4_1:1.1.1.4
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.4
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TCL_8_4_0:1.1.1.3
	carlton_dictionary-branch:1.2.0.16
	carlton_dictionary-20020920-branchpoint:1.2
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.14
	gdb_5_3-branch:1.2.0.12
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.10
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.8
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.6
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TCL_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	dejagnu-2000-02-04:1.1.1.1
	dejagnu-2000-01-31:1.1.1.1
	dejagnu-2000-01-24:1.1.1.1
	dejagnu-2000-01-17:1.1.1.1
	dejagnu-2000-01-10:1.1.1.1
	dejagnu-2000-01-04:1.1.1.1
	dejagnu-1999-12-21:1.1.1.1
	dejagnu-1999-12-13:1.1.1.1
	dejagnu-1999-12-07:1.1.1.1
	dejagnu-1999-12-06:1.1.1.1
	dejagnu-1999-11-15:1.1.1.1
	dejagnu-1999-11-08:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2003.01.21.19.40.14;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.26.19.48.01;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.37.07;	author kseitz;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2001.09.09.23.56.08;	author irox;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2002.09.27.21.49.10;	author kseitz;	state Exp;
branches;
next	;

1.3.4.1
date	2003.12.14.20.28.49;	author drow;	state Exp;
branches;
next	;

1.2.16.1
date	2002.12.23.19.40.39;	author carlton;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2003.02.07.19.18.18;	author carlton;	state Exp;
branches;
next	;

1.1.1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.09.22.40.58;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.19.56.35;	author kseitz;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.11.26.20.01.06;	author hunt;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tcl 8.4.1
@
text
@# This file tests the tclFCmd.c file.
#
# This file contains a collection of tests for one or more of the Tcl
# built-in commands.  Sourcing this file into Tcl runs the tests and
# generates output for errors.  No output means no errors were found.
#
# Copyright (c) 1996-1997 Sun Microsystems, Inc.
# Copyright (c) 1999 by Scriptics Corporation.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# RCS: @@(#) $Id: fCmd.test,v 1.25 2002/10/04 08:25:14 dkf Exp $
#

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest 2
    namespace import -force ::tcltest::*
}

tcltest::testConstraint testsetplatform [string equal testsetplatform [info commands testsetplatform]]
tcltest::testConstraint testchmod [string equal testchmod [info commands testchmod]]

# Several tests require need to match results against the unix username
set user {}
if {$tcl_platform(platform) == "unix"} {
    catch {set user [exec whoami]}
    if {$user == ""} {
	catch {regexp {^[^(]*\(([^)]*)\)} [exec id] dummy user}
    }
    if {$user == ""} {
	set user "root"
    }
}

proc createfile {file {string a}} {
    set f [open $file w]
    puts -nonewline $f $string
    close $f
    return $string
}

# 
# checkcontent --
#
#  Ensures that file "file" contains only the string "matchString"
#  returns 0 if the file does not exist, or has a different content
#
proc checkcontent {file matchString} {
    if {[catch {
	set f [open $file]
	set fileString [read $f]
	close $f 
    }]} {
	return 0
    }
    return [string match $matchString $fileString]
}

proc openup {path} {
    testchmod 777 $path
    if {[file isdirectory $path]} {
	catch {
	    foreach p [glob -directory $path *] {
		openup $p
	    }
	}
    }
}

proc cleanup {args} {
	if {$::tcl_platform(platform) == "macintosh"} {
		set wd [list :]
	} else {
		set wd [list .]
	}
    foreach p [concat $wd $args] {
	set x ""
	catch {
	    set x [glob -directory $p tf* td*]
	}
	foreach file $x {
	    if {[catch {file delete -force -- $file}]} {
		catch {openup $file}
		catch {file delete -force -- $file}
	    }
	}
    }
}

proc contents {file} {
    set f [open $file r]
    set r [read $f]
    close $f
    set r
}

set ::tcltest::testConstraints(fileSharing) 0
set ::tcltest::testConstraints(notFileSharing) 1

if {$tcl_platform(platform) == "macintosh"} {
    catch {file delete -force foo.dir}
    file mkdir foo.dir
    if {[catch {file attributes foo.dir -readonly 1}] == 0} {
    	set ::tcltest::testConstraints(fileSharing) 1
    	set ::tcltest::testConstraints(notFileSharing) 0
    }
    file delete -force foo.dir
}

set ::tcltest::testConstraints(xdev) 0

if {$tcl_platform(platform) == "unix"} {
    if {[catch {set m1 [exec df .]; set m2 [exec df /tmp]}] == 0} {
	set m1 [string range $m1 0 [expr [string first " " $m1]-1]]
	set m2 [string range $m2 0 [expr [string first " " $m2]-1]]
	if {$m1 != "" && $m2 != "" && $m1 != $m2 && [file exists $m1] && [file exists $m2]} {
	    set ::tcltest::testConstraints(xdev) 1
	}
    }
}

set root [lindex [file split [pwd]] 0]

# A really long file name
# length of long is 1216 chars, which should be greater than any static
# buffer or allowable filename.

set long "abcdefghihjllmnopqrstuvwxyz01234567890"
append long $long
append long $long
append long $long
append long $long
append long $long

test fCmd-1.1 {TclFileRenameCmd} {notRoot} {
    cleanup
    createfile tf1
    file rename tf1 tf2
    glob tf*
} {tf2}

test fCmd-2.1 {TclFileCopyCmd} {notRoot} {
    cleanup
    createfile tf1
    file copy tf1 tf2
    lsort [glob tf*]
} {tf1 tf2}

test fCmd-3.1 {FileCopyRename: FileForceOption fails} {notRoot} {
    list [catch {file rename -xyz} msg] $msg
} {1 {bad option "-xyz": should be -force or --}}
test fCmd-3.2 {FileCopyRename: not enough args} {notRoot} {
    list [catch {file rename xyz} msg] $msg
} {1 {wrong # args: should be "file rename ?options? source ?source ...? target"}}
test fCmd-3.3 {FileCopyRename: Tcl_TranslateFileName fails} {notRoot} {
    list [catch {file rename xyz ~_totally_bogus_user} msg] $msg
} {1 {user "_totally_bogus_user" doesn't exist}}
test fCmd-3.4 {FileCopyRename: Tcl_TranslateFileName passes} {notRoot} {
    cleanup
    list [catch {file copy tf1 ~} msg] $msg
} {1 {error copying "tf1": no such file or directory}}
test fCmd-3.5 {FileCopyRename: target doesn't exist: stat(target) != 0} {notRoot} {
    cleanup
    list [catch {file rename tf1 tf2 tf3} msg] $msg
} {1 {error renaming: target "tf3" is not a directory}}
test fCmd-3.6 {FileCopyRename: target tf3 is not a dir: !S_ISDIR(target)} \
	{notRoot} {
    cleanup
    createfile tf3
    list [catch {file rename tf1 tf2 tf3} msg] $msg
} {1 {error renaming: target "tf3" is not a directory}}
test fCmd-3.7 {FileCopyRename: target exists & is directory} {notRoot} {
    cleanup
    file mkdir td1
    createfile tf1 tf1
    file rename tf1 td1
    contents [file join td1 tf1]
} {tf1}
test fCmd-3.8 {FileCopyRename: too many arguments: argc - i > 2} {notRoot} {
    cleanup
    list [catch {file rename tf1 tf2 tf3} msg] $msg
} {1 {error renaming: target "tf3" is not a directory}}
test fCmd-3.9 {FileCopyRename: too many arguments: argc - i > 2} {notRoot} {
    cleanup
    list [catch {file copy -force -- tf1 tf2 tf3} msg] $msg
} {1 {error copying: target "tf3" is not a directory}}
test fCmd-3.10 {FileCopyRename: just 2 arguments} {notRoot} {
    cleanup
    createfile tf1 tf1
    file rename tf1 tf2
    contents tf2
} {tf1}
test fCmd-3.11 {FileCopyRename: just 2 arguments} {notRoot} {
    cleanup
    createfile tf1 tf1
    file rename -force -force -- tf1 tf2
    contents tf2
} {tf1}
test fCmd-3.12 {FileCopyRename: move each source: 1 source} {notRoot} {
    cleanup
    createfile tf1 tf1
    file mkdir td1
    file rename tf1 td1
    contents [file join td1 tf1]
} {tf1}
test fCmd-3.13 {FileCopyRename: move each source: multiple sources} {notRoot} {
    cleanup
    createfile tf1 tf1
    createfile tf2 tf2
    createfile tf3 tf3
    createfile tf4 tf4
    file mkdir td1
    file rename tf1 tf2 tf3 tf4 td1
    list [contents [file join td1 tf1]] [contents [file join td1 tf2]] \
	[contents [file join td1 tf3]] [contents [file join td1 tf4]]
} {tf1 tf2 tf3 tf4}
test fCmd-3.14 {FileCopyRename: FileBasename fails} {notRoot} {
    cleanup
    file mkdir td1
    list [catch {file rename ~_totally_bogus_user td1} msg] $msg
} {1 {user "_totally_bogus_user" doesn't exist}}
test fCmd-3.15 {FileCopyRename: source[0] == '\0'} {notRoot unixOrPc} {
    cleanup
    file mkdir td1
    list [catch {file rename / td1} msg] $msg
} {1 {error renaming "/" to "td1": file already exists}}
test fCmd-3.16 {FileCopyRename: break on first error} {notRoot} {
    cleanup
    createfile tf1 
    createfile tf2 
    createfile tf3 
    createfile tf4 
    file mkdir td1
    createfile [file join td1 tf3]
    list [catch {file rename tf1 tf2 tf3 tf4 td1} msg] $msg
} [subst {1 {error renaming "tf3" to "[file join td1 tf3]": file already exists}}]

test fCmd-4.1 {TclFileMakeDirsCmd: make each dir: 1 dir} {notRoot} {
    cleanup
    file mkdir td1
    glob td*
} {td1}
test fCmd-4.2 {TclFileMakeDirsCmd: make each dir: multiple dirs} {notRoot} {
    cleanup
    file mkdir td1 td2 td3
    lsort [glob td*]
} {td1 td2 td3}
test fCmd-4.3 {TclFileMakeDirsCmd: stops on first error} {notRoot} {
    cleanup
    createfile tf1
    catch {file mkdir td1 td2 tf1 td3 td4}
    glob td1 td2 tf1 td3 td4
} {td1 td2 tf1}
test fCmd-4.4 {TclFileMakeDirsCmd: Tcl_TranslateFileName fails} {notRoot} {
    cleanup
    list [catch {file mkdir ~_totally_bogus_user} msg] $msg
} {1 {user "_totally_bogus_user" doesn't exist}}
test fCmd-4.5 {TclFileMakeDirsCmd: Tcl_SplitPath returns 0: *name == '\0'} \
	{notRoot} {
    cleanup
    list [catch {file mkdir ""} msg] $msg
} {1 {can't create directory "": no such file or directory}}
test fCmd-4.6 {TclFileMakeDirsCmd: one level deep} {notRoot} {
    cleanup
    file mkdir td1
    glob td1
} {td1}
test fCmd-4.7 {TclFileMakeDirsCmd: multi levels deep} {notRoot} {
    cleanup
    file mkdir [file join td1 td2 td3 td4]
    glob td1 [file join td1 td2]
} "td1 [file join td1 td2]"
test fCmd-4.8 {TclFileMakeDirsCmd: already exist: lstat(target) == 0} {notRoot} {
    cleanup
    file mkdir td1
    set x [file exists td1]
    file mkdir td1
    list $x [file exists td1]
} {1 1}
test fCmd-4.9 {TclFileMakeDirsCmd: exists, not dir} {notRoot} {
    cleanup
    createfile tf1
    list [catch {file mkdir tf1} msg] $msg
} [subst {1 {can't create directory "[file join tf1]": file already exists}}]
test fCmd-4.10 {TclFileMakeDirsCmd: exists, is dir} {notRoot} {
    cleanup
    file mkdir td1
    set x [file exists td1]
    file mkdir td1
    list $x [file exists td1]
} {1 1}
test fCmd-4.11 {TclFileMakeDirsCmd: doesn't exist: errno != ENOENT} \
	{unixOnly notRoot testchmod} {
    cleanup
    file mkdir td1/td2/td3
    testchmod 000 td1/td2
    set msg [list [catch {file mkdir td1/td2/td3/td4} msg] $msg]
    testchmod 755 td1/td2
    set msg
} {1 {can't create directory "td1/td2/td3": permission denied}}
test fCmd-4.12 {TclFileMakeDirsCmd: doesn't exist: errno != ENOENT} {macOnly} {
    cleanup
    list [catch {file mkdir nonexistentvolume:} msg] $msg
} {1 {can't create directory "nonexistentvolume:": invalid argument}}
test fCmd-4.13 {TclFileMakeDirsCmd: doesn't exist: errno == ENOENT} {notRoot} {
    cleanup
    set x [file exists td1]
    file mkdir td1
    list $x [file exists td1]
} {0 1}
test fCmd-4.14 {TclFileMakeDirsCmd: TclpCreateDirectory fails} \
	{unixOnly notRoot} {
    cleanup
    file delete -force foo
    file mkdir foo
    file attr foo -perm 040000
    set result [list [catch {file mkdir foo/tf1} msg] $msg]
    file delete -force foo
    set result
} {1 {can't create directory "foo/tf1": permission denied}}
test fCmd-4.15 {TclFileMakeDirsCmd: TclpCreateDirectory fails} {macOnly} {
    list [catch {file mkdir ${root}:} msg] $msg
} [subst {1 {can't create directory "${root}:": no such file or directory}}]
test fCmd-4.16 {TclFileMakeDirsCmd: TclpCreateDirectory succeeds} {notRoot} {
    cleanup
    file mkdir tf1
    file exists tf1
} {1}

test fCmd-5.1 {TclFileDeleteCmd: FileForceOption fails} {notRoot} {
    list [catch {file delete -xyz} msg] $msg
} {1 {bad option "-xyz": should be -force or --}}
test fCmd-5.2 {TclFileDeleteCmd: not enough args} {notRoot} {
    list [catch {file delete -force -force} msg] $msg
} {1 {wrong # args: should be "file delete ?options? file ?file ...?"}}
test fCmd-5.3 {TclFileDeleteCmd: 1 file} {notRoot} {
    cleanup
    createfile tf1
    createfile tf2
    file mkdir td1
    file delete tf2
    glob tf* td*
} {tf1 td1}
test fCmd-5.4 {TclFileDeleteCmd: multiple files} {notRoot} {
    cleanup
    createfile tf1
    createfile tf2
    file mkdir td1
    set x [list [file exists tf1] [file exists tf2] [file exists td1]]
    file delete tf1 td1 tf2
    lappend x [file exists tf1] [file exists tf2] [file exists tf3]
} {1 1 1 0 0 0}
test fCmd-5.5 {TclFileDeleteCmd: stop at first error} {notRoot unixOrPc} {
    cleanup
    createfile tf1
    createfile tf2
    file mkdir td1
    catch {file delete tf1 td1 $root tf2}
    list [file exists tf1] [file exists tf2] [file exists td1]
} {0 1 0}
test fCmd-5.6 {TclFileDeleteCmd: Tcl_TranslateFileName fails} {notRoot} {
    list [catch {file delete ~_totally_bogus_user} msg] $msg
} {1 {user "_totally_bogus_user" doesn't exist}}
test fCmd-5.7 {TclFileDeleteCmd: Tcl_TranslateFileName succeeds} {notRoot} {
    catch {file delete ~/tf1}
    createfile ~/tf1
    file delete ~/tf1
} {}
test fCmd-5.8 {TclFileDeleteCmd: file doesn't exist: lstat(name) != 0} {notRoot} {
    cleanup
    set x [file exists tf1]
    file delete tf1
    list $x [file exists tf1]
} {0 0}    
test fCmd-5.9 {TclFileDeleteCmd: is directory} {notRoot} {
    cleanup
    file mkdir td1
    file delete td1
    file exists td1
} {0}
test fCmd-5.10 {TclFileDeleteCmd: TclpRemoveDirectory fails} {notRoot} {
    cleanup
    file mkdir [file join td1 td2]
    list [catch {file delete td1} msg] $msg
} {1 {error deleting "td1": directory not empty}}
test fCmd-5.11 {TclFileDeleteCmd: TclpRemoveDirectory with cwd inside} {notRoot} {
    cleanup
    set dir [pwd]
    file mkdir [file join td1 td2]
    cd [file join td1 td2]
    set res [list [catch {file delete -force [file dirname [pwd]]} msg]]
    cd $dir
    lappend res [file exists td1] $msg
} {0 0 {}}
test fCmd-5.12 {TclFileDeleteCmd: TclpRemoveDirectory with bad perms} {unixOnly} {
    cleanup
    file mkdir [file join td1 td2]
    #exec chmod u-rwx [file join td1 td2]
    file attributes [file join td1 td2] -permissions u+rwx
    set res [list [catch {file delete -force td1} msg]]
    lappend res [file exists td1] $msg
} {0 0 {}}

test fCmd-6.1 {CopyRenameOneFile: bad source} {notRoot} {
    # can't test this, because it's caught by FileCopyRename
} {}
test fCmd-6.2 {CopyRenameOneFile: bad target} {notRoot} {
    # can't test this, because it's caught by FileCopyRename
} {}
test fCmd-6.3 {CopyRenameOneFile: lstat(source) != 0} {notRoot} {
    cleanup
    list [catch {file rename tf1 tf2} msg] $msg
} {1 {error renaming "tf1": no such file or directory}}
test fCmd-6.4 {CopyRenameOneFile: lstat(source) == 0} {notRoot} {
    cleanup
    createfile tf1
    file rename tf1 tf2
    glob tf*
} {tf2}
test fCmd-6.5 {CopyRenameOneFile: lstat(target) != 0} {notRoot} {
    cleanup
    createfile tf1
    file rename tf1 tf2
    glob tf*
} {tf2}
test fCmd-6.6 {CopyRenameOneFile: errno != ENOENT} {unixOnly notRoot testchmod} {
    cleanup
    file mkdir td1
    testchmod 000 td1
    createfile tf1
    set msg [list [catch {file rename tf1 td1} msg] $msg]
    testchmod 755 td1
    set msg
} {1 {error renaming "tf1" to "td1/tf1": permission denied}}
test fCmd-6.7 {CopyRenameOneFile: errno != ENOENT} {pcOnly 95} {
    cleanup
    createfile tf1
    list [catch {file rename tf1 $long} msg] $msg
} [subst {1 {error renaming "tf1" to "$long": file name too long}}]
test fCmd-6.8 {CopyRenameOneFile: errno != ENOENT} {macOnly} {
    cleanup
    createfile tf1
    list [catch {file rename tf1 $long} msg] $msg
} [subst {1 {error renaming "tf1" to "$long": file name too long}}]
test fCmd-6.9 {CopyRenameOneFile: errno == ENOENT} {unixOnly notRoot} {
    cleanup
    createfile tf1
    file rename tf1 tf2
    glob tf*
} {tf2}
test fCmd-6.10 {CopyRenameOneFile: lstat(target) == 0} {notRoot} {
    cleanup
    createfile tf1
    createfile tf2
    list [catch {file rename tf1 tf2} msg] $msg
} {1 {error renaming "tf1" to "tf2": file already exists}}
test fCmd-6.11 {CopyRenameOneFile: force == 0} {notRoot} {
    cleanup
    createfile tf1
    createfile tf2
    list [catch {file rename tf1 tf2} msg] $msg
} {1 {error renaming "tf1" to "tf2": file already exists}}
test fCmd-6.12 {CopyRenameOneFile: force != 0} {notRoot} {
    cleanup
    createfile tf1
    createfile tf2
    file rename -force tf1 tf2
    glob tf*
} {tf2}
test fCmd-6.13 {CopyRenameOneFile: source is dir, target is file} {notRoot} {
    cleanup
    file mkdir td1
    file mkdir td2
    createfile [file join td2 td1]
    list [catch {file rename -force td1 td2} msg] $msg
} [subst {1 {can't overwrite file "[file join td2 td1]" with directory "td1"}}]
test fCmd-6.14 {CopyRenameOneFile: source is file, target is dir} {notRoot} {
    cleanup
    createfile tf1
    file mkdir [file join td1 tf1]
    list [catch {file rename -force tf1 td1} msg] $msg
} [subst {1 {can't overwrite directory "[file join td1 tf1]" with file "tf1"}}]
test fCmd-6.15 {CopyRenameOneFile: TclpRenameFile succeeds} {notRoot} {
    cleanup
    file mkdir [file join td1 td2]
    file mkdir td2
    createfile [file join td2 tf1]
    file rename -force td2 td1
    file exists [file join td1 td2 tf1]
} {1}
test fCmd-6.16 {CopyRenameOneFile: TclpCopyRenameOneFile fails} {notRoot} {
    cleanup
    file mkdir [file join td1 td2]
    createfile [file join td1 td2 tf1]
    file mkdir td2
    list [catch {file rename -force td2 td1} msg] $msg
} [subst {1 {error renaming "td2" to "[file join td1 td2]": file already exists}}]

test fCmd-6.17 {CopyRenameOneFile: errno == EINVAL} {notRoot} {
    cleanup
    list [catch {file rename -force $root tf1} msg] $msg
} [subst {1 {error renaming "$root" to "tf1": trying to rename a volume or move a directory into itself}}]
test fCmd-6.18 {CopyRenameOneFile: errno != EXDEV} {notRoot} {
    cleanup
    file mkdir [file join td1 td2]
    createfile [file join td1 td2 tf1]
    file mkdir td2
    list [catch {file rename -force td2 td1} msg] $msg
} [subst {1 {error renaming "td2" to "[file join td1 td2]": file already exists}}]
test fCmd-6.19 {CopyRenameOneFile: errno == EXDEV} {unixOnly notRoot} {
    cleanup /tmp
    createfile tf1
    file rename tf1 /tmp
    glob tf* /tmp/tf1
} {/tmp/tf1}
test fCmd-6.20 {CopyRenameOneFile: errno == EXDEV} {pcOnly} {
    catch {file delete -force c:/tcl8975@@ d:/tcl8975@@}
    file mkdir c:/tcl8975@@
    if [catch {file rename c:/tcl8975@@ d:/}] {
	set msg d:/tcl8975@@
    } else {
	set msg [glob c:/tcl8975@@ d:/tcl8975@@]
	file delete -force d:/tcl8975@@
    }
    file delete -force c:/tcl8975@@
    set msg
} {d:/tcl8975@@}
test fCmd-6.21 {CopyRenameOneFile: copy/rename: S_ISDIR(source)} \
	{unixOnly notRoot} {
    cleanup /tmp
    file mkdir td1
    file rename td1 /tmp
    glob td* /tmp/td*
} {/tmp/td1}
test fCmd-6.22 {CopyRenameOneFile: copy/rename: !S_ISDIR(source)} \
	{unixOnly notRoot} {
    cleanup /tmp
    createfile tf1
    file rename tf1 /tmp
    glob tf* /tmp/tf*
} {/tmp/tf1}
test fCmd-6.23 {CopyRenameOneFile: TclpCopyDirectory failed} \
	{unixOnly notRoot xdev} {
    cleanup /tmp
    file mkdir td1/td2/td3
    file attributes td1 -permissions 0000
    set msg [list [catch {file rename td1 /tmp} msg] $msg]
    file attributes td1 -permissions 0755
    set msg 
} {1 {error renaming "td1": permission denied}}
test fCmd-6.24 {CopyRenameOneFile: error uses original name} \
	{unixOnly notRoot} {
    cleanup
    file mkdir ~/td1/td2
    set td1name [file join [file dirname ~] [file tail ~] td1]
    file attributes $td1name -permissions 0000
    set msg [list [catch {file copy ~/td1 td1} msg] $msg]
    file attributes $td1name -permissions 0755
    file delete -force ~/td1
    set msg
} {1 {error copying "~/td1": permission denied}}
test fCmd-6.25 {CopyRenameOneFile: error uses original name} \
	{unixOnly notRoot} {
    cleanup
    file mkdir td2
    file mkdir ~/td1
    set td1name [file join [file dirname ~] [file tail ~] td1]
    file attributes $td1name -permissions 0000
    set msg [list [catch {file copy td2 ~/td1} msg] $msg]
    file attributes $td1name -permissions 0755
    file delete -force ~/td1
    set msg
} {1 {error copying "td2" to "~/td1/td2": permission denied}}
test fCmd-6.26 {CopyRenameOneFile: doesn't use original name} \
	{unixOnly notRoot} {
    cleanup
    file mkdir ~/td1/td2
    set td2name [file join [file dirname ~] [file tail ~] td1 td2]
    file attributes $td2name -permissions 0000
    set msg [list [catch {file copy ~/td1 td1} msg] $msg]
    file attributes $td2name -permissions 0755
    file delete -force ~/td1
    set msg
} "1 {error copying \"~/td1\" to \"td1\": \"[file join [file dirname ~] [file tail ~] td1 td2]\": permission denied}"
test fCmd-6.27 {CopyRenameOneFile: TclpCopyDirectory failed} \
	{unixOnly notRoot xdev} {
    cleanup /tmp
    file mkdir td1/td2/td3
    file mkdir /tmp/td1
    createfile /tmp/td1/tf1
    list [catch {file rename -force td1 /tmp} msg] $msg
} {1 {error renaming "td1" to "/tmp/td1": file already exists}}
test fCmd-6.28 {CopyRenameOneFile: TclpCopyDirectory failed} \
	{unixOnly notRoot xdev} {
    cleanup /tmp
    file mkdir td1/td2/td3
    file attributes td1/td2/td3 -permissions 0000
    set msg [list [catch {file rename td1 /tmp} msg] $msg]
    file attributes td1/td2/td3 -permissions 0755
    set msg
} {1 {error renaming "td1" to "/tmp/td1": "td1/td2/td3": permission denied}}
test fCmd-6.29 {CopyRenameOneFile: TclpCopyDirectory passed} \
	{unixOnly notRoot xdev} {
    cleanup /tmp
    file mkdir td1/td2/td3
    file rename td1 /tmp
    glob td* /tmp/td1/t*
} {/tmp/td1/td2}
test fCmd-6.30 {CopyRenameOneFile: TclpRemoveDirectory failed} \
	{unixOnly notRoot} {
    cleanup
    file mkdir foo/bar
    file attr foo -perm 040555
    set catchResult [catch {file rename foo/bar /tmp} msg]
    set msg [lindex [split $msg :] end]
    catch {file delete /tmp/bar}
    catch {file attr foo -perm 040777}
    catch {file delete -force foo}
    list $catchResult $msg
} {1 { permission denied}}
test fCmd-6.31 {CopyRenameOneFile: TclpDeleteFile passed} \
	{unixOnly notRoot xdev} {
    catch {cleanup /tmp}
    file mkdir /tmp/td1
    createfile /tmp/td1/tf1
    file rename /tmp/td1/tf1 tf1
    list [file exists /tmp/td1/tf1] [file exists tf1]
} {0 1}
test fCmd-6.32 {CopyRenameOneFile: copy} {notRoot} {
    cleanup
    list [catch {file copy tf1 tf2} msg] $msg
} {1 {error copying "tf1": no such file or directory}}
catch {cleanup /tmp}

test fCmd-7.1 {FileForceOption: none} {notRoot} {
    cleanup
    file mkdir [file join tf1 tf2]
    list [catch {file delete tf1} msg] $msg
} {1 {error deleting "tf1": directory not empty}}
test fCmd-7.2 {FileForceOption: -force} {notRoot} {
    cleanup
    file mkdir [file join tf1 tf2]
    file delete -force tf1
} {}
test fCmd-7.3 {FileForceOption: --} {notRoot} {
    createfile -tf1
    file delete -- -tf1
} {}
test fCmd-7.4 {FileForceOption: bad option} {notRoot} {
    createfile -tf1
    set msg [list [catch {file delete -tf1} msg] $msg]
    file delete -- -tf1
    set msg
} {1 {bad option "-tf1": should be -force or --}}
test fCmd-7.5 {FileForceOption: multiple times through loop} {notRoot} {
    createfile --
    createfile -force
    file delete -force -force -- -- -force
    list [catch {glob -- -- -force} msg] $msg
} {1 {no files matched glob patterns "-- -force"}}

test fCmd-8.1 {FileBasename: basename of ~user: argc == 1 && *path == ~} \
	{unixOnly notRoot knownBug} {
    # Labelled knownBug because it is dangerous [Bug: 3881]
    file mkdir td1
    file attr td1 -perm 040000
    set result [list [catch {file rename ~$user td1} msg] $msg]
    file delete -force td1
    set result
} "1 {error renaming \"~$user\" to \"td1/[file tail ~$user]\": permission denied}"
test fCmd-8.2 {FileBasename: basename of ~user: argc == 1 && *path == ~} \
	{unixOnly notRoot} {
    file tail ~$user
} "$user"

test fCmd-9.1 {file rename: comprehensive: EACCES} {unixOnly notRoot} {
    cleanup
    file mkdir td1
    file mkdir td2
    file attr td2 -perm 040000
    set result [list [catch {file rename td1 td2/} msg] $msg]
    file delete -force td2
    file delete -force td1
    set result
} {1 {error renaming "td1" to "td2/td1": permission denied}}
test fCmd-9.2 {file rename: comprehensive: source doesn't exist} {notRoot} {
    cleanup
    list [catch {file rename tf1 tf2} msg] $msg
} {1 {error renaming "tf1": no such file or directory}}
test fCmd-9.3 {file rename: comprehensive: file to new name} {notRoot testchmod} {
    cleanup
    createfile tf1
    createfile tf2
    testchmod 444 tf2
    file rename tf1 tf3
    file rename tf2 tf4
    list [lsort [glob tf*]] [file writable tf3] [file writable tf4]
} {{tf3 tf4} 1 0}    
test fCmd-9.4 {file rename: comprehensive: dir to new name} {unixOrPc notRoot testchmod} {
    cleanup
    file mkdir td1 td2
    testchmod 555 td2
    file rename td1 td3
    file rename td2 td4
    list [lsort [glob td*]] [file writable td3] [file writable td4]
} {{td3 td4} 1 0}    
test fCmd-9.5 {file rename: comprehensive: file to self} {notRoot testchmod} {
    cleanup
    createfile tf1 tf1
    createfile tf2 tf2
    testchmod 444 tf2
    file rename -force tf1 tf1
    file rename -force tf2 tf2
    list [contents tf1] [contents tf2] [file writable tf1] [file writable tf2]
} {tf1 tf2 1 0}    
test fCmd-9.6 {file rename: comprehensive: dir to self} {notRoot unixOrPc testchmod} {
    cleanup
    file mkdir td1
    file mkdir td2
    testchmod 555 td2
    file rename -force td1 .
    file rename -force td2 .
    list [lsort [glob td*]] [file writable td1] [file writable td2]
} {{td1 td2} 1 0}    
test fCmd-9.7 {file rename: comprehensive: file to existing file} {notRoot testchmod} {
    cleanup
    createfile tf1
    createfile tf2
    createfile tfs1
    createfile tfs2
    createfile tfs3
    createfile tfs4
    createfile tfd1
    createfile tfd2
    createfile tfd3
    createfile tfd4
    testchmod 444 tfs3
    testchmod 444 tfs4
    testchmod 444 tfd2
    testchmod 444 tfd4
    set msg [list [catch {file rename tf1 tf2} msg] $msg]
    file rename -force tfs1 tfd1
    file rename -force tfs2 tfd2
    file rename -force tfs3 tfd3
    file rename -force tfs4 tfd4
    list [lsort [glob tf*]] $msg [file writable tfd1] [file writable tfd2] [file writable tfd3] [file writable tfd4] 
} {{tf1 tf2 tfd1 tfd2 tfd3 tfd4} {1 {error renaming "tf1" to "tf2": file already exists}} 1 1 0 0}
test fCmd-9.8 {file rename: comprehensive: dir to empty dir} {notRoot testchmod} {
    # Under unix, you can rename a read-only directory, but you can't
    # move it into another directory.

    cleanup
    file mkdir td1
    file mkdir [file join td2 td1]
    file mkdir tds1
    file mkdir tds2
    file mkdir tds3
    file mkdir tds4
    file mkdir [file join tdd1 tds1]
    file mkdir [file join tdd2 tds2]
    file mkdir [file join tdd3 tds3]
    file mkdir [file join tdd4 tds4]
    if {$tcl_platform(platform) != "unix" && $tcl_platform(platform) != "macintosh"} {
	testchmod 555 tds3
	testchmod 555 tds4
    }
    if {$tcl_platform(platform) != "macintosh"} {
    	testchmod 555 [file join tdd2 tds2]
    	testchmod 555 [file join tdd4 tds4]
    }
    set msg [list [catch {file rename td1 td2} msg] $msg]
    file rename -force tds1 tdd1
    file rename -force tds2 tdd2
    file rename -force tds3 tdd3
    file rename -force tds4 tdd4
    if {$tcl_platform(platform) != "unix" && $tcl_platform(platform) != "macintosh"} {
	set w3 [file writable [file join tdd3 tds3]]
	set w4 [file writable [file join tdd4 tds4]]
    } else {
	set w3 0
	set w4 0
    }
    list [lsort [glob td*]] $msg [file writable [file join tdd1 tds1]] \
    [file writable [file join tdd2 tds2]] $w3 $w4
} [subst {{td1 td2 tdd1 tdd2 tdd3 tdd4} {1 {error renaming "td1" to "[file join td2 td1]": file already exists}} 1 1 0 0}]
test fCmd-9.9 {file rename: comprehensive: dir to non-empty dir} {notRoot testchmod} {
    cleanup
    file mkdir tds1
    file mkdir tds2
    file mkdir [file join tdd1 tds1 xxx]
    file mkdir [file join tdd2 tds2 xxx]
    if {$tcl_platform(platform) != "unix" && $tcl_platform(platform) != "macintosh"} {
	testchmod 555 tds2
    }
    set a1 [list [catch {file rename -force tds1 tdd1} msg] $msg]
    set a2 [list [catch {file rename -force tds2 tdd2} msg] $msg]
    if {$tcl_platform(platform) != "unix" && $tcl_platform(platform) != "macintosh"} {
	set w2 [file writable tds2]
    } else {
	set w2 0
    }
    list [lsort [glob td*]] $a1 $a2 [file writable tds1] $w2
} [subst {{tdd1 tdd2 tds1 tds2} {1 {error renaming "tds1" to "[file join tdd1 tds1]": file already exists}} {1 {error renaming "tds2" to "[file join tdd2 tds2]": file already exists}} 1 0}]
test fCmd-9.10 {file rename: comprehensive: file to new name and dir} {notRoot testchmod} {
    cleanup
    createfile tf1
    createfile tf2
    file mkdir td1
    testchmod 444 tf2
    file rename tf1 [file join td1 tf3]
    file rename tf2 [file join td1 tf4]
    list [catch {glob tf*}] [lsort [glob -directory td1 t*]] \
    [file writable [file join td1 tf3]] [file writable [file join td1 tf4]]
} [subst {1 {[file join td1 tf3] [file join td1 tf4]} 1 0}]
test fCmd-9.11 {file rename: comprehensive: dir to new name and dir} {notRoot testchmod} {
    cleanup
    file mkdir td1
    file mkdir td2
    file mkdir td3
    if {$tcl_platform(platform) != "unix" && $tcl_platform(platform) != "macintosh"} {
	testchmod 555 td2
    }
    file rename td1 [file join td3 td3]
    file rename td2 [file join td3 td4]
    if {$tcl_platform(platform) != "unix" && $tcl_platform(platform) != "macintosh"} {
	set w4 [file writable [file join td3 td4]]
    } else {
        set w4 0
    }
    list [lsort [glob td*]] [lsort [glob -directory td3 t*]] \
    [file writable [file join td3 td3]] $w4
} [subst {td3 {[file join td3 td3] [file join td3 td4]} 1 0}]
test fCmd-9.12 {file rename: comprehensive: target exists} {notRoot testchmod} {
    cleanup
    file mkdir [file join td1 td2] [file join td2 td1]
    if {$tcl_platform(platform) != "macintosh"} {
    	testchmod 555 [file join td2 td1]
    }
    file mkdir [file join td3 td4] [file join td4 td3]
    file rename -force td3 td4
    set msg [list [file exists td3] [file exists [file join td4 td3 td4]] \
    [catch {file rename td1 td2} msg] $msg]
    if {$tcl_platform(platform) != "macintosh"} {
    	testchmod 755 [file join td2 td1]
    }
    set msg
} [subst {0 1 1 {error renaming "td1" to "[file join td2 td1]": file already exists}}]
test fCmd-9.13 {file rename: comprehensive: can't overwrite target} {notRoot} {
    cleanup
    file mkdir [file join td1 td2] [file join td2 td1 td4]
    list [catch {file rename -force td1 td2} msg] $msg
} [subst {1 {error renaming "td1" to "[file join td2 td1]": file already exists}}]
test fCmd-9.14 {file rename: comprehensive: dir into self} {notRoot} {
    cleanup
    file mkdir td1
    list [glob td*] [list [catch {file rename td1 td1} msg] $msg]
} [subst {td1 {1 {error renaming "td1" to "[file join td1 td1]": trying to rename a volume or move a directory into itself}}}]
test fCmd-9.15 {file rename: comprehensive: source and target incompatible} \
	{notRoot} {
    cleanup
    file mkdir td1
    createfile tf1
    list [catch {file rename -force td1 tf1} msg] $msg
} {1 {can't overwrite file "tf1" with directory "td1"}}
test fCmd-9.16 {file rename: comprehensive: source and target incompatible} \
	{notRoot} {
    cleanup
    file mkdir td1/tf1
    createfile tf1
    list [catch {file rename -force tf1 td1} msg] $msg
} [subst {1 {can't overwrite directory "[file join td1 tf1]" with file "tf1"}}]

test fCmd-10.1 {file copy: comprehensive: source doesn't exist} {notRoot} {
    cleanup
    list [catch {file copy tf1 tf2} msg] $msg
} {1 {error copying "tf1": no such file or directory}}
test fCmd-10.2 {file copy: comprehensive: file to new name} {notRoot testchmod} {
    cleanup
    createfile tf1 tf1
    createfile tf2 tf2
    testchmod 444 tf2
    file copy tf1 tf3
    file copy tf2 tf4
    list [lsort [glob tf*]] [contents tf3] [contents tf4] [file writable tf3] [file writable tf4]
} {{tf1 tf2 tf3 tf4} tf1 tf2 1 0}
test fCmd-10.3 {file copy: comprehensive: dir to new name} {notRoot unixOrPc testchmod} {
    cleanup
    file mkdir [file join td1 tdx]
    file mkdir [file join td2 tdy]
    testchmod 555 td2
    file copy td1 td3
    file copy td2 td4
    set msg [list [lsort [glob td*]] [glob -directory td3 t*] \
	    [glob -directory td4 t*] [file writable td3] [file writable td4]]
    if {$tcl_platform(platform) != "macintosh"} {
    	testchmod 755 td2
    	testchmod 755 td4
    }
    set msg
} [subst {{td1 td2 td3 td4} [file join td3 tdx] [file join td4 tdy] 1 0}]
test fCmd-10.4 {file copy: comprehensive: file to existing file} {notRoot testchmod} {
    cleanup
    createfile tf1
    createfile tf2
    createfile tfs1
    createfile tfs2
    createfile tfs3
    createfile tfs4
    createfile tfd1
    createfile tfd2
    createfile tfd3
    createfile tfd4
    testchmod 444 tfs3
    testchmod 444 tfs4
    testchmod 444 tfd2
    testchmod 444 tfd4
    set msg [list [catch {file copy tf1 tf2} msg] $msg]
    file copy -force tfs1 tfd1
    file copy -force tfs2 tfd2
    file copy -force tfs3 tfd3
    file copy -force tfs4 tfd4
    list [lsort [glob tf*]] $msg [file writable tfd1] [file writable tfd2] [file writable tfd3] [file writable tfd4] 
} {{tf1 tf2 tfd1 tfd2 tfd3 tfd4 tfs1 tfs2 tfs3 tfs4} {1 {error copying "tf1" to "tf2": file already exists}} 1 1 0 0}
test fCmd-10.5 {file copy: comprehensive: dir to empty dir} {notRoot testchmod} {
    cleanup
    file mkdir td1
    file mkdir [file join td2 td1]
    file mkdir tds1
    file mkdir tds2
    file mkdir tds3
    file mkdir tds4
    file mkdir [file join tdd1 tds1]
    file mkdir [file join tdd2 tds2]
    file mkdir [file join tdd3 tds3]
    file mkdir [file join tdd4 tds4]
    if {$tcl_platform(platform) != "macintosh"} {
	testchmod 555 tds3
	testchmod 555 tds4
	testchmod 555 [file join tdd2 tds2]
	testchmod 555 [file join tdd4 tds4]
    }
    set a1 [list [catch {file copy td1 td2} msg] $msg]
    set a2 [list [catch {file copy -force tds1 tdd1} msg] $msg]
    set a3 [catch {file copy -force tds2 tdd2}]
    set a4 [catch {file copy -force tds3 tdd3}]
    set a5 [catch {file copy -force tds4 tdd4}]
    list [lsort [glob td*]] $a1 $a2 $a3 $a4 $a5 
} [subst {{td1 td2 tdd1 tdd2 tdd3 tdd4 tds1 tds2 tds3 tds4} {1 {error copying "td1" to "[file join td2 td1]": file already exists}} {1 {error copying "tds1" to "[file join tdd1 tds1]": file already exists}} 1 1 1}]
test fCmd-10.6 {file copy: comprehensive: dir to non-empty dir} \
	{notRoot unixOrPc testchmod} {
    cleanup
    file mkdir tds1
    file mkdir tds2
    file mkdir [file join tdd1 tds1 xxx]
    file mkdir [file join tdd2 tds2 xxx]
    testchmod 555 tds2
    set a1 [list [catch {file copy -force tds1 tdd1} msg] $msg]
    set a2 [list [catch {file copy -force tds2 tdd2} msg] $msg]
    list [lsort [glob td*]] $a1 $a2 [file writable tds1] [file writable tds2]
} [subst {{tdd1 tdd2 tds1 tds2} {1 {error copying "tds1" to "[file join tdd1 tds1]": file already exists}} {1 {error copying "tds2" to "[file join tdd2 tds2]": file already exists}} 1 0}]
test fCmd-10.7 {file rename: comprehensive: file to new name and dir} {notRoot testchmod} {
    cleanup
    createfile tf1
    createfile tf2
    file mkdir td1
    testchmod 444 tf2
    file copy tf1 [file join td1 tf3]
    file copy tf2 [file join td1 tf4]
    list [lsort [glob tf*]] [lsort [glob -directory td1 t*]] \
    [file writable [file join td1 tf3]] [file writable [file join td1 tf4]]
} [subst {{tf1 tf2} {[file join td1 tf3] [file join td1 tf4]} 1 0}]
test fCmd-10.8 {file rename: comprehensive: dir to new name and dir} \
	{notRoot unixOrPc testchmod} {
    cleanup
    file mkdir td1
    file mkdir td2
    file mkdir td3
    testchmod 555 td2
    file copy td1 [file join td3 td3]
    file copy td2 [file join td3 td4]
    list [lsort [glob td*]] [lsort [glob -directory td3 t*]] \
    [file writable [file join td3 td3]] [file writable [file join td3 td4]]
} [subst {{td1 td2 td3} {[file join td3 td3] [file join td3 td4]} 1 0}]
test fCmd-10.9 {file copy: comprehensive: source and target incompatible} \
	{notRoot} {
    cleanup
    file mkdir td1
    createfile tf1
    list [catch {file copy -force td1 tf1} msg] $msg
} {1 {can't overwrite file "tf1" with directory "td1"}}
test fCmd-10.10 {file copy: comprehensive: source and target incompatible} \
	{notRoot} {
    cleanup
    file mkdir [file join td1 tf1]
    createfile tf1
    list [catch {file copy -force tf1 td1} msg] $msg
} [subst {1 {can't overwrite directory "[file join td1 tf1]" with file "tf1"}}]
cleanup    

# old tests    

test fCmd-11.1 {TclFileRenameCmd: -- option } {notRoot} {
    catch {file delete -force -- -tfa1}
    set s [createfile -tfa1]
    file rename -- -tfa1 tfa2
    set result [expr [checkcontent tfa2 $s] && ![file exists -tfa1]]
    file delete tfa2
    set result
} {1}

test fCmd-11.2 {TclFileRenameCmd: bad option } {notRoot} {
    catch {file delete -force -- tfa1}
    set s [createfile tfa1]
    set r1 [catch {file rename -x tfa1 tfa2}]
    set result [expr $r1 && [checkcontent tfa1 $s] && ![file exists tfa2]]
    file delete tfa1
    set result
} {1}

test fCmd-11.3 {TclFileRenameCmd: bad \# args} {
    catch {file rename -- }
} {1}

test fCmd-11.4 {TclFileRenameCmd: target filename translation failing} {notRoot} {
     global env
     set temp $env(HOME)
     unset env(HOME)
     set result [catch {file rename tfa ~/foobar }]
     set env(HOME) $temp
     set result
 } {1}

test fCmd-11.5 {TclFileRenameCmd: > 1 source & target is not a dir} {notRoot} {
    catch {file delete -force -- tfa1 tfa2 tfa3}
    createfile tfa1 
    createfile tfa2 
    createfile tfa3 
    set result [catch {file rename tfa1 tfa2 tfa3}]
    file delete tfa1 tfa2 tfa3
    set result
} {1}

test fCmd-11.6 {TclFileRenameCmd: : single file into directory} {notRoot} {
    catch {file delete -force -- tfa1 tfad}
    set s [createfile tfa1]
    file mkdir tfad
    file rename tfa1 tfad
    set result [expr [checkcontent tfad/tfa1 $s] && ![file exists tfa1]]
    file delete -force tfad
    set result
} {1}

test fCmd-11.7 {TclFileRenameCmd: : multiple files into directory} {notRoot} {
    catch {file delete -force -- tfa1 tfa2 tfad}
    set s1 [createfile tfa1 ]
    set s2 [createfile tfa2 ]
    file mkdir tfad
    file rename tfa1 tfa2 tfad
    set r1 [checkcontent tfad/tfa1 $s1]
    set r2 [checkcontent tfad/tfa2 $s2]
    
    set result [expr $r1 && $r2 && ![file exists tfa1] && ![file exists tfa2]]
	    
    file delete -force tfad
    set result
} {1}

test fCmd-11.8 {TclFileRenameCmd: error renaming file to directory} {notRoot} {
    catch {file delete -force -- tfa tfad}
    set s [createfile tfa ]
    file mkdir tfad
    file mkdir tfad/tfa
    set r1 [catch {file rename tfa tfad}]
    set r2 [checkcontent tfa $s]
    set r3 [file isdir tfad]
    set result [expr $r1 && $r2 && $r3 ]
    file delete -force tfa tfad
    set result
} {1}

#
# Coverage tests for renamefile() ;
#
test fCmd-12.1 {renamefile: source filename translation failing} {notRoot} {
    global env
    set temp $env(HOME)
    unset env(HOME)
    set result [catch {file rename ~/tfa1 tfa2}]
    set env(HOME) $temp
    set result
} {1}

test fCmd-12.2 {renamefile: src filename translation failing} {notRoot} {
    global env
    set temp $env(HOME)
    unset env(HOME)
    set s [createfile tfa1]
    file mkdir tfad
    set result [catch {file rename tfa1 ~/tfa2 tfad}]
    set env(HOME) $temp
    file delete -force tfad
    set result
} {1}

test fCmd-12.3 {renamefile: stat failing on source} {notRoot} {
    catch {file delete -force -- tfa1 tfa2}
    set r1 [catch {file rename tfa1 tfa2}]
    expr {$r1 && ![file exists tfa1] && ![file exists tfa2]}
} {1}

test fCmd-12.4 {renamefile: error renaming file to directory} {notRoot} {
    catch {file delete -force -- tfa tfad}
    set s1 [createfile tfa ]
    file mkdir tfad
    file mkdir tfad/tfa
    set r1 [catch {file rename tfa tfad}]
    set r2 [checkcontent tfa $s1]
    set r3 [file isdir tfad/tfa]
    set result [expr $r1 && $r2 && $r3]
    file delete -force tfa tfad
    set result
} {1}

test fCmd-12.5 {renamefile: error renaming directory to file} {notRoot} {
    catch {file delete -force -- tfa tfad}
    file mkdir tfa
    file mkdir tfad
    set s [createfile tfad/tfa]
    set r1 [catch {file rename tfa tfad}]
    set r2 [checkcontent tfad/tfa $s]
    set r3 [file isdir tfad]
    set r4 [file isdir tfa]
    set result [expr $r1 && $r2 && $r3 && $r4 ]
    file delete -force tfa tfad
    set result
} {1}

test fCmd-12.6 {renamefile: TclRenameFile succeeding} {notRoot} {
    catch {file delete -force -- tfa1 tfa2}
    set s [createfile tfa1]
    file rename tfa1 tfa2
    set result [expr [checkcontent tfa2 $s] && ![file exists tfa1]]
    file delete tfa2
    set result
} {1}

test fCmd-12.7 {renamefile: renaming directory into offspring} {notRoot} {
    catch {file delete -force -- tfad}
    file mkdir tfad
    file mkdir tfad/dir
    set result [catch {file rename tfad tfad/dir}]
    file delete -force tfad 
    set result
} {1}

test fCmd-12.8 {renamefile: generic error} {unixOnly notRoot} {
    catch {file delete -force -- tfa}
    file mkdir tfa
    file mkdir tfa/dir
    file attributes tfa -permissions 0555
    set result [catch {file rename tfa/dir tfa2}]
    file attributes tfa -permissions 0777
    file delete -force tfa
    set result
} {1}


test fCmd-12.9 {renamefile: moving a file across volumes} {unixOnly notRoot} {
    catch {file delete -force -- tfa /tmp/tfa}
    set s [createfile tfa ]
    file rename tfa /tmp
    set result [expr [checkcontent /tmp/tfa $s] && ![file exists tfa]]
    file delete /tmp/tfa
    set result
} {1}

test fCmd-12.10 {renamefile: moving a directory across volumes } \
	{unixOnly notRoot} {
    catch {file delete -force -- tfad /tmp/tfad}
    file mkdir tfad
    set s [createfile tfad/a ]
    file rename tfad /tmp
    set restul [expr [checkcontent /tmp/tfad/a $s] && ![file exists tfad]]
    file delete -force /tmp/tfad
    set result
} {1}

#
# Coverage tests for TclCopyFilesCmd()
#
test fCmd-13.1 {TclCopyFilesCmd: -force option} {notRoot} {
    catch {file delete -force -- tfa1}
    set s [createfile tfa1]
    file copy -force  tfa1 tfa2
    set result [expr [checkcontent tfa2 $s] && [checkcontent tfa1 $s]]
    file delete tfa1 tfa2
    set result
} {1}

test fCmd-13.2 {TclCopyFilesCmd: -- option} {notRoot} {
    catch {file delete -force -- tfa1}
    set s [createfile -tfa1]
    file copy --  -tfa1 tfa2
    set result [expr [checkcontent tfa2 $s] &&  [checkcontent -tfa1 $s]]
    file delete -- -tfa1 tfa2
    set result
} {1}

test fCmd-13.3 {TclCopyFilesCmd: bad option} {notRoot} {
    catch {file delete -force -- tfa1}
    set s [createfile tfa1]
    set r1 [catch {file copy -x tfa1 tfa2}]
    set result [expr $r1 && [checkcontent tfa1 $s] && ![file exists tfa2]]
    file delete tfa1
    set result
} {1}

test fCmd-13.4 {TclCopyFilesCmd: bad \# args} {notRoot} {
    catch {file copy -- }
} {1}

test fCmd-13.5 {TclCopyFilesCmd: target filename translation failing} {
     global env
     set temp $env(HOME)
    unset env(HOME)
     set result [catch {file copy tfa ~/foobar }]
     set env(HOME) $temp
     set result
 } {1}

test fCmd-13.6 {TclCopyFilesCmd: > 1 source & target is not a dir} {notRoot} {
    catch {file delete -force -- tfa1 tfa2 tfa3}
    createfile tfa1 
    createfile tfa2 
    createfile tfa3 
    set result [catch {file copy tfa1 tfa2 tfa3}]
    file delete tfa1 tfa2 tfa3
    set result
} {1}

test fCmd-13.7 {TclCopyFilesCmd: single file into directory} {notRoot} {
    catch {file delete -force -- tfa1 tfad}
    set s [createfile tfa1]
    file mkdir tfad
    file copy tfa1 tfad
    set result [expr [checkcontent tfad/tfa1 $s] &&  [checkcontent tfa1 $s]]
    file delete -force tfad tfa1
    set result
} {1}

test fCmd-13.8 {TclCopyFilesCmd: multiple files into directory} {notRoot} {
    catch {file delete -force -- tfa1 tfa2 tfad}
    set s1 [createfile tfa1 ]
    set s2 [createfile tfa2 ]
    file mkdir tfad
    file copy tfa1 tfa2 tfad
    set r1 [checkcontent tfad/tfa1 $s1]
    set r2 [checkcontent tfad/tfa2 $s2]
    set r3 [checkcontent tfa1 $s1]
    set r4 [checkcontent tfa2 $s2]
    set result [expr $r1 && $r2 && $r3 && $r4 ]
	    
    file delete -force tfad tfa1 tfa2
    set result
} {1}

test fCmd-13.9 {TclCopyFilesCmd: error copying file to directory} {notRoot} {
    catch {file delete -force -- tfa tfad}
    set s [createfile tfa ]
    file mkdir tfad
    file mkdir tfad/tfa
    set r1 [catch {file copy tfa tfad}]
    set r2 [expr [checkcontent tfa $s] && [file isdir tfad/tfa]]
    set r3 [file isdir tfad]
    set result [expr $r1 && $r2 && $r3 ]
    file delete -force tfa tfad
    set result
} {1}

#
# Coverage tests for copyfile()
# 
test fCmd-14.1 {copyfile: source filename translation failing} {notRoot} {
    global env
    set temp $env(HOME)
    unset env(HOME)
    set result [catch {file copy ~/tfa1 tfa2}]
    set env(HOME) $temp
    set result
} {1}

test fCmd-14.2 {copyfile: dst filename translation failing} {notRoot} {
    global env
    set temp $env(HOME)
    unset env(HOME)
    set s [createfile tfa1]
    file mkdir tfad
    set r1 [catch {file copy tfa1 ~/tfa2 tfad}]
    set result [expr $r1 && [checkcontent tfad/tfa1 $s]]
    set env(HOME) $temp
    file delete -force tfa1 tfad
    set result
} {1}

test fCmd-14.3 {copyfile: stat failing on source} {notRoot} {
    catch {file delete -force -- tfa1 tfa2}
    set r1 [catch {file copy tfa1 tfa2}]
    expr $r1 && ![file exists tfa1] && ![file exists tfa2]
} {1}

test fCmd-14.4 {copyfile: error copying file to directory} {notRoot} {
    catch {file delete -force -- tfa tfad}
    set s1 [createfile tfa ]
    file mkdir tfad
    file mkdir tfad/tfa
    set r1 [catch {file copy tfa tfad}]
    set r2 [checkcontent tfa $s1]
    set r3 [file isdir tfad]
    set r4 [file isdir tfad/tfa]
    set result [expr $r1 && $r2 && $r3 && $r4 ]
    file delete -force tfa tfad
    set result
} {1}

 test fCmd-14.5 {copyfile: error copying directory to file} {notRoot} {
     catch {file delete -force -- tfa tfad}
     file mkdir tfa
     file mkdir tfad
     set s [createfile tfad/tfa]
     set r1 [catch {file copy tfa tfad}]
     set r2 [checkcontent tfad/tfa $s]
     set r3 [file isdir tfad]
     set r4 [file isdir tfa]
     set result [expr $r1 && $r2 && $r3 && $r4 ]
     file delete -force tfa tfad
     set result
} {1}

test fCmd-14.6 {copyfile: copy file succeeding} {notRoot} {
    catch {file delete -force -- tfa tfa2}
    set s [createfile tfa]
    file copy tfa tfa2
    set result [expr  [checkcontent tfa $s] && [checkcontent tfa2 $s]]
    file delete tfa tfa2
    set result
} {1}

test fCmd-14.7 {copyfile: copy directory succeeding} {notRoot} {
    catch {file delete -force -- tfa tfa2}
    file mkdir tfa
    set s [createfile tfa/file]
    file copy tfa tfa2
    set result [expr [checkcontent tfa/file $s] && [checkcontent tfa2/file $s]]
    file delete -force tfa tfa2
    set result
} {1}

test fCmd-14.8 {copyfile: copy directory failing} {unixOnly notRoot} {
    catch {file delete -force -- tfa}
    file mkdir tfa/dir/a/b/c
    file attributes tfa/dir -permissions 0000
    set r1 [catch {file copy tfa tfa2}]
    file attributes tfa/dir -permissions 0777
    set result $r1
    file delete -force tfa tfa2
    set result
} {1}

#
# Coverage tests for TclMkdirCmd()
#
test fCmd-15.1 {TclMakeDirsCmd: target filename translation failing} {notRoot} {
    global env
    set temp $env(HOME)
    unset env(HOME) 
    set result [catch {file mkdir ~/tfa}]
    set env(HOME) $temp
    set result
} {1}
#
# Can Tcl_SplitPath return argc == 0? If so them we need a
# test for that code.
#
test fCmd-15.2 {TclMakeDirsCmd - one directory } {notRoot} {
    catch {file delete -force -- tfa}
    file mkdir tfa
    set result [file isdirectory tfa]
    file delete tfa
    set result
} {1}

test fCmd-15.3 {TclMakeDirsCmd: - two directories} {notRoot} {
    catch {file delete -force -- tfa1 tfa2}
    file mkdir tfa1 tfa2
    set result [expr [file isdirectory tfa1] && [file isdirectory tfa2]]
    file delete tfa1 tfa2
    set result
} {1}

test fCmd-15.4 {TclMakeDirsCmd - stat failing} {unixOnly notRoot} {
    catch {file delete -force -- tfa}
    file mkdir tfa
    createfile tfa/file
    file attributes tfa -permissions 0000
    set result [catch {file mkdir tfa/file}]
    file attributes tfa -permissions 0777
    file delete -force tfa
    set result
} {1}

test fCmd-15.5 {TclMakeDirsCmd: - making a directory several levels deep} \
	{notRoot} {
    catch {file delete -force -- tfa}
    file mkdir tfa/a/b/c
    set result [file isdir tfa/a/b/c]
    file delete -force tfa
    set result
} {1}

    
test fCmd-15.6 {TclMakeDirsCmd: - trying to overwrite a file} {notRoot} {
    catch {file delete -force -- tfa}
    set s [createfile tfa]
    set r1 [catch {file mkdir tfa}]
    set r2 [file isdir tfa]
    set r3 [file exists tfa]
    set result [expr $r1 && !$r2 && $r3 && [checkcontent tfa $s]]
    file delete tfa
    set result
} {1}

test fCmd-15.7 {TclMakeDirsCmd - making several directories} {notRoot} {
    catch {file delete -force -- tfa1 tfa2}
    file mkdir tfa1 tfa2/a/b/c
    set result [expr [file isdir tfa1] && [file isdir tfa2/a/b/c]]
    file delete -force tfa1 tfa2
    set result
} {1}

test fCmd-15.8 {TclFileMakeDirsCmd: trying to create an existing dir} {notRoot} {
    file mkdir tfa
    file mkdir tfa
    set result [file isdir tfa]
    file delete tfa
    set result
} {1}


# Coverage tests for TclDeleteFilesCommand()
test fCmd-16.1 {test the -- argument} {notRoot} {
    catch {file delete -force -- tfa}
    createfile tfa
    file delete -- tfa
    file exists tfa
} {0}

test fCmd-16.2 {test the -force and -- arguments} {notRoot} {
    catch {file delete -force -- tfa}
    createfile tfa
    file delete -force -- tfa
    file exists tfa
} {0}

test fCmd-16.3 {test bad option} {notRoot} {
    catch {file delete -force -- tfa}
    createfile tfa
    set result [catch {file delete -dog tfa}]
    file delete tfa
    set result
} {1}

test fCmd-16.4 {test not enough args} {notRoot} {
    catch {file delete}
} {1}

test fCmd-16.5 {test not enough args with options} {notRoot} {
    catch {file delete --}
} {1}

test fCmd-16.6 {delete: source filename translation failing} {notRoot} {
    global env
    set temp $env(HOME)
    unset env(HOME)
    set result [catch {file delete ~/tfa}]
    set env(HOME) $temp
    set result
} {1}

test fCmd-16.7 {remove a non-empty directory without -force } {notRoot} {
    catch {file delete -force -- tfa}
    file mkdir tfa
    createfile tfa/a
    set result [catch  {file delete tfa }]
    file delete -force tfa
    set result
} {1}

test fCmd-16.8 {remove a normal file } {notRoot} {
    catch {file delete -force -- tfa}
    file mkdir tfa
    createfile tfa/a
    set result [catch  {file delete tfa }]
    file delete -force tfa
    set result
} {1}

test fCmd-16.9 {error while deleting file } {unixOnly notRoot} {
    catch {file delete -force -- tfa}
    file mkdir tfa
    createfile tfa/a
    file attributes tfa -permissions 0555
    set result [catch  {file delete tfa/a }]
    #######
    #######  If any directory in a tree that is being removed does not 
    #######  have write permission, the process will fail!
    #######  This is also the case with "rm -rf"
    #######
    file attributes tfa -permissions 0777
    file delete -force tfa
    set result
} {1}

test fCmd-16.10 {deleting multiple files} {notRoot} {
    catch {file delete -force -- tfa1 tfa2}
    createfile tfa1
    createfile tfa2
    file delete tfa1 tfa2
    expr ![file exists tfa1] && ![file exists tfa2]
} {1}

test fCmd-16.11 {TclFileDeleteCmd: removing a nonexistant file} {notRoot} {
    catch {file delete -force -- tfa}
    file delete tfa
    set result 1
} {1}

# More coverage tests for mkpath()
 test fCmd-17.1 {mkdir stat failing on target but not ENOENT} {unixOnly notRoot} {
     catch {file delete -force -- tfa1}
     file mkdir tfa1
     file attributes tfa1 -permissions 0555
     set result [catch {file mkdir tfa1/tfa2}]
     file attributes tfa1 -permissions 0777
     file delete -force tfa1
     set result
} {1}

test fCmd-17.2 {mkdir several levels deep - relative } {notRoot} {
    catch {file delete -force -- tfa}
    file mkdir tfa/a/b
    set result [file isdir tfa/a/b ]
    file delete tfa/a/b tfa/a tfa
    set result
} {1}

test fCmd-17.3 {mkdir several levels deep - absolute } {notRoot} {
    catch {file delete -force -- tfa}
    set f [file join [pwd] tfa a ]
    file mkdir $f
    set result [file isdir $f ]
    file delete $f [file join [pwd] tfa]
    set result
} {1}

#
# Functionality tests for TclFileRenameCmd()
#

test fCmd-18.1 {TclFileRenameCmd: rename (first form) in the same directory} \
	{notRoot} {
    catch {file delete -force -- tfad}
    file mkdir tfad/dir
    cd tfad/dir
    set s [createfile foo ]
    file rename  foo bar
    file rename bar ./foo
    file rename ./foo bar
    file rename ./bar ./foo
    file rename foo ../dir/bar
    file rename ../dir/bar ./foo
    file rename ../../tfad/dir/foo ../../tfad/dir/bar
    file rename [file join [pwd] bar] foo
    file rename foo [file join [pwd] bar]
    set result [expr [checkcontent bar $s] && ![file exists foo]]
    cd ../..
    file delete -force tfad
    set result
} {1}

test fCmd-18.2 {TclFileRenameCmd: single dir to nonexistant} {notRoot} {
    catch {file delete -force -- tfa1 tfa2}
    file mkdir tfa1
    file rename tfa1 tfa2
    set result [expr [file exists tfa2] && ![file exists tfa1]]
    file delete tfa2
    set result
} {1}

test fCmd-18.3 {TclFileRenameCmd: mixed dirs and files into directory} {notRoot} {
    catch {file delete -force -- tfa1 tfad1 tfad2}
    set s [createfile tfa1 ]
    file mkdir tfad1 tfad2
    file rename tfa1 tfad1 tfad2
    set r1 [checkcontent  tfad2/tfa1 $s]
    set r2 [file isdir tfad2/tfad1]
    set result [expr $r1 && $r2 && ![file exists tfa1] && ![file exists tfad1]]
    file delete tfad2/tfa1
    file delete -force tfad2
    set result
} {1}

test fCmd-18.4 {TclFileRenameCmd: attempt to replace non-dir with dir} {notRoot} {
    catch {file delete -force -- tfa tfad}
    set s [createfile tfa ]
    file mkdir tfad
    set r1 [catch {file rename tfad tfa}]
    set r2 [checkcontent tfa $s]
    set r3 [file isdir tfad]
    set result [expr $r1 && $r2 && $r3 ]
    file delete tfa tfad
    set result
} {1}

test fCmd-18.5 {TclFileRenameCmd: attempt to replace dir with non-dir} {notRoot} {
    catch {file delete -force -- tfa tfad}
    set s [createfile tfa ]
    file mkdir tfad/tfa
    set r1 [catch {file rename tfa tfad}]
    set r2 [checkcontent tfa $s]
    set r3 [file isdir tfad/tfa]
    set result [expr $r1 && $r2 && $r3 ]
    file delete -force  tfa tfad
    set result
} {1}

#
# On Windows there is no easy way to determine if two files are the same
#
test fCmd-18.6 {TclFileRenameCmd: rename a file to itself} {macOrUnix notRoot} {
    catch {file delete -force -- tfa}
    set s [createfile tfa]
    set r1 [catch {file rename tfa tfa}]
    set result [expr $r1 && [checkcontent tfa $s]]
    file delete tfa
    set result
} {1}

test fCmd-18.7 {TclFileRenameCmd: rename dir on top of another empty dir w/o -force} \
	{notRoot} {
    catch {file delete -force -- tfa tfad}
    file mkdir tfa tfad/tfa
    set r1 [catch {file rename tfa tfad}]
    set result [expr $r1 && [file isdir tfa]]
    file delete -force tfa tfad
    set result
} {1}

test fCmd-18.8 {TclFileRenameCmd: rename dir on top of another empty dir w/ -force} \
	{notRoot} {
    catch {file delete -force -- tfa tfad}
    file mkdir tfa tfad/tfa
    file rename -force tfa tfad
    set result [expr ![file isdir tfa]]
    file delete -force tfad
    set result
} {1}

test fCmd-18.9 {TclFileRenameCmd: rename dir on top of a non-empty dir w/o -force} \
	{notRoot} {
    catch {file delete -force -- tfa tfad}
    file mkdir tfa tfad/tfa/file
    set r1 [catch {file rename tfa tfad}]
    set result [expr $r1 && [file isdir tfa] && [file isdir tfad/tfa/file]]
    file delete -force tfa tfad
    set result
} {1}

test fCmd-18.10 {TclFileRenameCmd: rename dir on top of a non-empty dir w/ -force} \
	{notRoot} {
    catch {file delete -force -- tfa tfad}
    file mkdir tfa tfad/tfa/file
    set r1 [catch {file rename -force tfa tfad}]
    set result [expr $r1 && [file isdir tfa] && [file isdir tfad/tfa/file]]
    file delete -force tfa tfad
    set result
} {1}

test fCmd-18.11 {TclFileRenameCmd: rename a non-existant file} {notRoot} {
    catch {file delete -force -- tfa1}
    set r1 [catch {file rename tfa1 tfa2}]
    set result [expr $r1 && ![file exists tfa1] && ![file exists tfa2]]
} {1}

test fCmd-18.12 {TclFileRenameCmd : rename a symbolic link to file} \
	{unixOnly notRoot} {
    catch {file delete -force -- tfa1 tfa2 tfa3}
	
    set s [createfile tfa1]
    file link -symbolic tfa2 tfa1
    file rename tfa2 tfa3
    set t [file type tfa3]
    set result [expr {$t eq "link"}]
    file delete tfa1 tfa3
    set result
} {1}

test fCmd-18.13 {TclFileRenameCmd : rename a symbolic link to dir} \
	{unixOnly notRoot} {
    catch {file delete -force -- tfa1 tfa2 tfa3}
	
    file mkdir tfa1
    file link -symbolic tfa2 tfa1
    file rename tfa2 tfa3
    set t [file type tfa3]
    set result [expr {$t eq "link"}]
    file delete tfa1 tfa3
    set result
} {1}

test fCmd-18.14 {TclFileRenameCmd : rename a path with sym link} \
	{unixOnly notRoot} {
    catch {file delete -force -- tfa1 tfa2 tfa3}
	
    file mkdir tfa1/a/b/c/d
    file mkdir tfa2
    set f [file join [pwd] tfa1/a/b] 
    set f2 [file join [pwd] {tfa2/b alias}]
    file link -symbolic $f2 $f
    file rename {tfa2/b alias/c} tfa3
    set r1 [file isdir tfa3]
    set r2 [file exists tfa1/a/b/c]
    set result [expr $r1 && !$r2]
    file delete -force tfa1 tfa2 tfa3
    set result
} {1}

test fCmd-18.15 {TclFileRenameCmd : rename a file to a symlink dir} \
	{unixOnly notRoot} {
    catch {file delete -force -- tfa1 tfa2 tfalink}
	
    file mkdir tfa1
    set s [createfile tfa2]
    file link -symbolic tfalink tfa1

    file rename tfa2 tfalink
    set result [checkcontent tfa1/tfa2 $s ]
    file delete -force tfa1 tfalink
    set result
} {1}

test fCmd-18.16 {TclFileRenameCmd: rename a dangling symlink} {unixOnly notRoot} {
    catch {file delete -force -- tfa1 tfalink}
	
    file mkdir tfa1
    file link -symbolic tfalink tfa1
    file delete tfa1 
    file rename tfalink tfa2
    set result [expr [string compare [file type tfa2] "link"] == 0]
    file delete tfa2
    set result
} {1}


#
# Coverage tests for TclUnixRmdir
#
test fCmd-19.1 {remove empty directory} {notRoot} {
    catch {file delete -force -- tfa}
    file mkdir tfa
    file delete tfa
    file exists tfa
} {0}

test fCmd-19.2 {rmdir error besides EEXIST} {unixOnly notRoot} {
    catch {file delete -force -- tfa}
    file mkdir tfa
    file mkdir tfa/a
    file attributes tfa -permissions 0555
    set result [catch {file delete tfa/a}]
    file attributes tfa -permissions 0777
    file delete -force tfa
    set result
} {1}

test fCmd-19.3 {recursive remove} {notRoot} {
    catch {file delete -force -- tfa}
    file mkdir tfa
    file mkdir tfa/a
    file delete -force tfa
    file exists tfa
} {0}

#
# TclUnixDeleteFile and TraversalDelete are covered by tests from the 
# TclDeleteFilesCmd suite
#
#

#
# Coverage tests for TraverseUnixTree(), called from TclDeleteFilesCmd
#

test fCmd-20.1 {TraverseUnixTree : failure opening a subdirectory directory } \
	{unixOnly notRoot} {
    catch {file delete -force -- tfa}
    file mkdir tfa
    file mkdir tfa/a
    file attributes tfa/a -permissions 0000
    set result [catch {file delete -force tfa}]
    file attributes tfa/a -permissions 0777
    file delete -force tfa
    set result
} {1}


#
# Feature testing for TclCopyFilesCmd
# 
test fCmd-21.1 {copy : single file to nonexistant } {notRoot} {
    catch {file delete -force -- tfa1 tfa2}
    set s [createfile tfa1]
    file copy tfa1 tfa2
    set result [expr [checkcontent tfa2 $s] && [checkcontent tfa1 $s]]
    file delete tfa1 tfa2
    set result
} {1}

test fCmd-21.2 {copy : single dir to nonexistant } {notRoot} {
    catch {file delete -force -- tfa1 tfa2}
    file mkdir tfa1
    file copy tfa1 tfa2
    set result [expr [file isdir tfa2] && [file isdir tfa1]]
    file delete tfa1 tfa2
    set result
} {1}

test fCmd-21.3 {copy : single file into directory  } {notRoot} {
    catch {file delete -force -- tfa1 tfad}
    set s [createfile tfa1]
    file mkdir tfad
    file copy tfa1 tfad
    set result [expr [checkcontent tfad/tfa1 $s] && [checkcontent tfa1 $s]]
    file delete -force tfa1 tfad
    set result
} {1}

test fCmd-21.4 {copy : more than one source and target is not a directory} \
	{notRoot} {
    catch {file delete -force -- tfa1 tfa2 tfa3}
    createfile tfa1 
    createfile tfa2 
    createfile tfa3 
    set result [catch {file copy tfa1 tfa2 tfa3}]
    file delete tfa1 tfa2 tfa3
    set result
} {1}

test fCmd-21.5 {copy : multiple files into directory  } {notRoot} {
    catch {file delete -force -- tfa1 tfa2 tfad}
    set s1 [createfile tfa1 ]
    set s2 [createfile tfa2 ]
    file mkdir tfad
    file copy tfa1 tfa2 tfad
    set r1 [checkcontent tfad/tfa1 $s1]
    set r2 [checkcontent tfad/tfa2 $s2]
    set r3 [checkcontent tfa1 $s1]
    set r4 [checkcontent tfa2 $s2]
    set result [expr $r1 && $r2 && $r3 && $r4]
    file delete -force tfa1 tfa2 tfad
    set result
} {1}

test fCmd-21.6 {copy: mixed dirs and files into directory} \
	{notRoot notFileSharing} {
    catch {file delete -force -- tfa1 tfad1 tfad2}
    set s [createfile tfa1 ]
    file mkdir tfad1 tfad2
    file copy tfa1 tfad1 tfad2
    set r1 [checkcontent [file join tfad2 tfa1] $s]
    set r2 [file isdir [file join tfad2 tfad1]]
    set r3 [checkcontent tfa1 $s]
    set result [expr $r1 && $r2 && $r3 && [file isdir tfad1]]
    file delete -force tfa1 tfad1 tfad2
    set result
} {1}

test fCmd-21.7.1 {TclCopyFilesCmd: copy a dangling link} {unixOnly notRoot dontCopyLinks} {
    file mkdir tfad1
    file link -symbolic tfalink tfad1
    file delete tfad1
    set result [list [catch {file copy tfalink tfalink2} msg] $msg]
    file delete -force tfalink tfalink2 
    set result
} {1 {error copying "tfalink": the target of this link doesn't exist}}
test fCmd-21.7.2 {TclCopyFilesCmd: copy a dangling link} {unixOnly notRoot} {
    file mkdir tfad1
    file link -symbolic tfalink tfad1
    file delete tfad1
    file copy tfalink tfalink2
    set result [string match [file type tfalink2] link]
    file delete tfalink tfalink2 
    set result
} {1}

test fCmd-21.8.1 {TclCopyFilesCmd: copy a link } {unixOnly notRoot dontCopyLinks} {
    file mkdir tfad1
    file link -symbolic tfalink tfad1
    file copy tfalink tfalink2
    set r1 [file type tfalink]; # link
    set r2 [file type tfalink2]; # directory
    set r3 [file isdir tfad1]; # 1
    set result [expr {("$r1" == "link") && ("$r2" == "directory") && $r3}]
    file delete -force tfad1 tfalink tfalink2
    set result
} {1}
test fCmd-21.8.2 {TclCopyFilesCmd: copy a link } {unixOnly notRoot} {
    file mkdir tfad1
    file link -symbolic tfalink tfad1
    file copy tfalink tfalink2
    set r1 [file type tfalink]; # link
    set r2 [file type tfalink2]; # link
    set r3 [file isdir tfad1]; # 1
    set result [expr {("$r1" == "link") && ("$r2" == "link") && $r3}]
    file delete -force tfad1 tfalink tfalink2
    set result
} {1}

test fCmd-21.9 {TclCopyFilesCmd: copy dir with a link in it} {unixOnly notRoot} {
    file mkdir tfad1
    file link -symbolic tfad1/tfalink "[pwd]/tfad1"
    file copy tfad1 tfad2
    set result [string match [file type tfad2/tfalink] link]
    file delete -force tfad1 tfad2
    set result
} {1}

test fCmd-21.10 {TclFileCopyCmd: copy dir on top of another empty dir w/o -force} \
	{notRoot} {
    catch {file delete -force -- tfa tfad}
    file mkdir tfa [file join tfad tfa]
    set r1 [catch {file copy tfa tfad}]
    set result [expr $r1 && [file isdir tfa]]
    file delete -force tfa tfad
    set result
} {1}

test fCmd-21.11 {TclFileCopyCmd: copy dir on top of a dir w/o -force} {notRoot} {
    catch {file delete -force -- tfa tfad}
    file mkdir tfa [file join tfad tfa file]
    set r1 [catch {file copy tfa tfad}]
    set result [expr $r1 && [file isdir tfa] && [file isdir [file join tfad tfa file]]]
    file delete -force tfa tfad
    set result
} {1}

test fCmd-21.12 {TclFileCopyCmd: copy dir on top of a non-empty dir w/ -force} \
	{notRoot} {
    catch {file delete -force -- tfa tfad}
    file mkdir tfa [file join tfad tfa file]
    set r1 [catch {file copy -force tfa tfad}]
    set result [expr $r1 && [file isdir tfa] && [file isdir [file join tfad tfa file]]]
    file delete -force tfa tfad
    set result
} {1}

#
# Coverage testing for TclpRenameFile
#
test fCmd-22.1 {TclpRenameFile: rename and overwrite in a single dir} {notRoot} {
    catch {file delete -force -- tfa1 tfa2}
    set s [createfile tfa1]
    set s2 [createfile tfa2 q]
	
    set r1 [catch {rename tfa1 tfa2}]
    file rename -force tfa1 tfa2
    set result [expr $r1 && [checkcontent tfa2 $s]]
    file delete [glob tfa1 tfa2]
    set result
} {1}

test fCmd-22.2 {TclpRenameFile: attempt to overwrite itself} {macOrUnix notRoot} {
    catch {file delete -force -- tfa1}
    set s [createfile tfa1]	
    file rename -force tfa1 tfa1
    set result [checkcontent tfa1 $s]
    file delete tfa1 
    set result
} {1}

test fCmd-22.3 {TclpRenameFile: rename dir to existing dir} {notRoot} {
    catch {file delete -force -- d1 tfad}
    file mkdir d1 [file join tfad d1]
    set r1 [catch {file rename d1 tfad}]
    set result [expr $r1 && [file isdir d1] && [file isdir [file join tfad d1]]]
    file delete -force d1 tfad
    set result
} {1}

test fCmd-22.4 {TclpRenameFile: rename dir to dir several levels deep} {notRoot} {
    catch {file delete -force -- d1 tfad}
    file mkdir d1 [file join tfad a b c]
    file rename d1 [file join tfad a b c d1]
    set result [expr ![file isdir d1] && [file isdir [file join tfad a b c d1]]]
    file delete -force [glob d1 tfad]
    set result
} {1}


#
# TclMacCopyFile needs to be redone.
#
test fCmd-22.5 {TclMacCopyFile: copy and overwrite in a single dir} {notRoot} {
    catch {file delete -force -- tfa1 tfa2}
    set s [createfile tfa1]
    set s2 [createfile tfa2 q]

    set r1 [catch {file copy tfa1 tfa2}]
    file copy -force tfa1 tfa2
    set result [expr $r1 && [checkcontent tfa2 $s] && [checkcontent tfa1 $s]]
    file delete tfa1 tfa2
    set result
} {1}

#
# TclMacMkdir - basic cases are covered elsewhere.
# Error cases are not covered.
#

#
# TclMacRmdir
# Error cases are not covered.
#

test fCmd-23.1 {TclMacRmdir: trying to remove a nonempty directory} {notRoot} {
    catch {file delete -force -- tfad}
	
    file mkdir [file join tfad dir]
	
    set result [catch {file delete tfad}]
    file delete -force tfad 
    set result
} {1}

#
# TclMacDeleteFile	
# Error cases are not covered.
#
test fCmd-24.1 {TclMacDeleteFile: deleting a normal file} {notRoot} {
    catch {file delete -force -- tfa1}
	
    createfile tfa1
    file delete tfa1
    file exists tfa1
} {0}

#
# TclMacCopyDirectory
# Error cases are not covered.
#
test fCmd-25.1 {TclMacCopyDirectory: copying a normal directory} {notRoot notFileSharing} {
    catch {file delete -force -- tfad1 tfad2}
		
    file mkdir [file join tfad1 a b c]
    file copy tfad1 tfad2
    set result [expr [file isdir [file join tfad1 a b c]] && [file isdir [file join tfad2 a b c]]]
    file delete -force tfad1 tfad2
    set result
} {1}

test fCmd-25.2 {TclMacCopyDirectory: copying a short path normal directory} {notRoot notFileSharing} {
    catch {file delete -force -- tfad1 tfad2}
		
    file mkdir tfad1
    file copy tfad1 tfad2
    set result [expr [file isdir tfad1] && [file isdir tfad2]]
    file delete tfad1 tfad2
    set result
} {1}

test fCmd-25.3 {TclMacCopyDirectory: copying dirs between different dirs} {notRoot notFileSharing} {
    catch {file delete -force -- tfad1 tfad2}
		
    file mkdir [file join tfad1 x y z]
    file mkdir [file join tfad2 dir]
    file copy tfad1 [file join tfad2 dir]
    set result [expr [file isdir [file join tfad1 x y z]] && [file isdir [file join tfad2 dir tfad1 x y z]]]
    file delete -force tfad1 tfad2
    set result
} {1}

#
# Functionality tests for TclDeleteFilesCmd
#

test fCmd-26.1 {TclDeleteFilesCmd: delete symlink} {unixOnly notRoot} {
    catch {file delete -force -- tfad1 tfad2}
		
    file mkdir tfad1
    file link -symbolic tfalink tfad1
    file delete tfalink

    set r1 [file isdir tfad1]
    set r2 [file exists tfalink]
    
    set result [expr $r1 && !$r2]
    file delete tfad1
    set result
} {1}

test fCmd-26.2 {TclDeleteFilesCmd: delete dir with symlink} {unixOnly notRoot} {
    catch {file delete -force -- tfad1 tfad2}
		
    file mkdir tfad1
    file mkdir tfad2
    file link -symbolic [file join tfad2 link] tfad1
    file delete -force tfad2

    set r1 [file isdir tfad1]
    set r2 [file exists tfad2]
    
    set result [expr $r1 && !$r2]
    file delete tfad1
    set result
} {1}

test fCmd-26.3 {TclDeleteFilesCmd: delete dangling symlink} {unixOnly notRoot} {
    catch {file delete -force -- tfad1 tfad2}
		
    file mkdir tfad1
    file link -symbolic tfad2 tfad1
    file delete tfad1
    file delete tfad2

    set r1 [file exists tfad1]
    set r2 [file exists tfad2]
    
    set result [expr !$r1 && !$r2]
    set result
} {1}

test fCmd-27.2 {TclFileAttrsCmd - Tcl_TranslateFileName fails} {testsetplatform} {
    set platform [testgetplatform]
    testsetplatform unix
    list [catch {file attributes ~_totally_bogus_user} msg] $msg [testsetplatform $platform]
} {1 {user "_totally_bogus_user" doesn't exist} {}}
test fCmd-27.3 {TclFileAttrsCmd - all attributes} {
    catch {file delete -force -- foo.tmp}
    createfile foo.tmp
    list [catch {file attributes foo.tmp} msg] [expr {[llength $msg] > 0}] [file delete -force -- foo.tmp]
} {0 1 {}}
test fCmd-27.4 {TclFileAttrsCmd - getting one option} {
    catch {file delete -force -- foo.tmp}
    createfile foo.tmp
    set attrs [file attributes foo.tmp]
    list [catch {eval file attributes foo.tmp [lindex $attrs 0]}] [file delete -force -- foo.tmp]
} {0 {}}

# Find a group that exists on this Unix system, or else skip tests that
# require Unix groups.
if {$tcl_platform(platform) == "unix"} {
    ::tcltest::testConstraint foundGroup 0
    catch {
	set groupList [exec groups]
	set group [lindex $groupList 0]
	::tcltest::testConstraint foundGroup 1
    }
} else {
    ::tcltest::testConstraint foundGroup 1
}

test fCmd-27.5 {TclFileAttrsCmd - setting one option} {foundGroup} {
    catch {file delete -force -- foo.tmp}
    createfile foo.tmp
    set attrs [file attributes foo.tmp]
    list [catch {eval file attributes foo.tmp [lrange $attrs 0 1]} msg] $msg [file delete -force -- foo.tmp]
} {0 {} {}}
test fCmd-27.6 {TclFileAttrsCmd - setting more than one option} {foundGroup} {
    catch {file delete -force -- foo.tmp}
    createfile foo.tmp
    set attrs [file attributes foo.tmp]
    list [catch {eval file attributes foo.tmp [lrange $attrs 0 3]} msg] $msg [file delete -force -- foo.tmp]
} {0 {} {}}

if {[string equal $tcl_platform(platform) "windows"]} {
    if {[string index $tcl_platform(osVersion) 0] >= 5 \
      && ([lindex [file system [temporaryDirectory]] 1] == "NTFS")} {
	tcltest::testConstraint linkDirectory 1
	tcltest::testConstraint linkFile 1
    } else {
	tcltest::testConstraint linkDirectory 0
	tcltest::testConstraint linkFile 0
    }
} else {
    tcltest::testConstraint linkFile 1
    tcltest::testConstraint linkDirectory 1
}

test fCmd-28.1 {file link} {
    list [catch {file link} msg] $msg
} {1 {wrong # args: should be "file link ?-linktype? linkname ?target?"}}

test fCmd-28.2 {file link} {
    list [catch {file link a b c d} msg] $msg
} {1 {wrong # args: should be "file link ?-linktype? linkname ?target?"}}

test fCmd-28.3 {file link} {
    list [catch {file link abc b c} msg] $msg
} {1 {bad switch "abc": must be -symbolic or -hard}}

test fCmd-28.4 {file link} {
    list [catch {file link -abc b c} msg] $msg
} {1 {bad switch "-abc": must be -symbolic or -hard}}

makeDirectory abc.dir
makeDirectory abc2.dir
makeFile contents abc.file
makeFile contents abc2.file

cd [temporaryDirectory]
test fCmd-28.5 {file link: source already exists} {linkDirectory} {
    cd [temporaryDirectory]
    set res [list [catch {file link abc.dir abc2.dir} msg] $msg]
    cd [workingDirectory]
    set res
} {1 {could not create new link "abc.dir": that path already exists}}

test fCmd-28.6 {file link: unsupported operation} {linkDirectory macOrWin} {
    cd [temporaryDirectory]
    set res [list [catch {file link -hard abc.link abc.dir} msg] $msg]
    cd [workingDirectory]
    set res
} {1 {could not create new link "abc.link" pointing to "abc.dir": illegal operation on a directory}}

test fCmd-28.7 {file link: source already exists} {linkFile} {
    cd [temporaryDirectory]
    set res [list [catch {file link abc.file abc2.file} msg] $msg]
    cd [workingDirectory]
    set res
} {1 {could not create new link "abc.file": that path already exists}}

test fCmd-28.8 {file link} {linkFile winOnly} {
    cd [temporaryDirectory]
    set res [list [catch {file link -symbolic abc.link abc.file} msg] $msg]
    cd [workingDirectory]
    set res
} {1 {could not create new link "abc.link" pointing to "abc.file": not a directory}}

test fCmd-28.9 {file link: success with file} {linkFile} {
    cd [temporaryDirectory]
    file delete -force abc.link
    set res [list [catch {file link abc.link abc.file} msg] $msg]
    cd [workingDirectory]
    set res
} {0 abc.file}

cd [temporaryDirectory]
catch {file delete -force abc.link}
cd [workingDirectory]

test fCmd-28.10 {file link: linking to nonexistent path} {linkDirectory} {
    cd [temporaryDirectory]
    file delete -force abc.link
    set res [list [catch {file link abc.link abc2.doesnt} msg] $msg]
    cd [workingDirectory]
    set res
} {1 {could not create new link "abc.link" since target "abc2.doesnt" doesn't exist}}

test fCmd-28.11 {file link: success with directory} {linkDirectory} {
    cd [temporaryDirectory]
    file delete -force abc.link
    set res [list [catch {file link abc.link abc.dir} msg] $msg]
    cd [workingDirectory]
    set res
} {0 abc.dir}

test fCmd-28.12 {file link: cd into a link} {linkDirectory} {
    cd [temporaryDirectory]
    file delete -force abc.link
    file link abc.link abc.dir
    set orig [pwd]
    cd abc.link
    set dir [pwd]
    cd ..
    set up [pwd]
    cd $orig
    # now '$up' should be either $orig or [file dirname abc.dir],
    # depending on whether 'cd' actually moves to the destination
    # of a link, or simply treats the link as a directory.
    # (on windows the former, on unix the latter, I believe)
    if {([file normalize $up] != [file normalize $orig]) \
      && ([file normalize $up] != [file normalize [file dirname abc.dir]])} {
	set res "wrong directory with 'cd $link ; cd ..'"
    } else {
	set res "ok"
    }
    cd [workingDirectory]
    set res
} {ok}

test fCmd-28.13 {file link} {linkDirectory} {
    # duplicate link throws error
    cd [temporaryDirectory]
    set res [list [catch {file link abc.link abc.dir} msg] $msg]
    cd [workingDirectory]
    set res
} {1 {could not create new link "abc.link": that path already exists}}

test fCmd-28.14 {file link: deletes link not dir} {linkDirectory} {
    cd [temporaryDirectory]
    file delete -force abc.link
    set res [list [file exists abc.link] [file exists abc.dir]]
    cd [workingDirectory]
    set res
} {0 1}

test fCmd-28.15.1 {file link: copies link not dir} {linkDirectory dontCopyLinks} {
    cd [temporaryDirectory]
    file delete -force abc.link
    file link abc.link abc.dir
    file copy abc.link abc2.link
    # abc2.linkdir was a copy of a link to a dir, so it should end up as
    # a directory, not a link (links trace to endpoint).
    set res [list [file type abc2.link] [file tail [file link abc.link]]]
    cd [workingDirectory]
    set res
} {directory abc.dir}
test fCmd-28.15.2 {file link: copies link not dir} {linkDirectory} {
    cd [temporaryDirectory]
    file delete -force abc.link
    file link abc.link abc.dir
    file copy abc.link abc2.link
    set res [list [file type abc2.link] [file tail [file link abc2.link]]]
    cd [workingDirectory]
    set res
} {link abc.dir}

cd [temporaryDirectory]
file delete -force abc.link
file delete -force abc2.link

file copy abc.file abc.dir
file copy abc2.file abc.dir
cd [workingDirectory]

test fCmd-28.16 {file link: glob inside link} {linkDirectory} {
    cd [temporaryDirectory]
    file delete -force abc.link
    file link abc.link abc.dir
    set res [glob -dir abc.link -tails *]
    cd [workingDirectory]
    set res
} {abc.file abc2.file}

test fCmd-28.17 {file link: glob -type l} {linkDirectory} {
    cd [temporaryDirectory]
    set res [glob -dir [pwd] -type l -tails abc*]
    cd [workingDirectory]
    set res
} {abc.link}

test fCmd-28.18 {file link: glob -type d} {linkDirectory} {
    cd [temporaryDirectory]
    set res [lsort [glob -dir [pwd] -type d -tails abc*]]
    cd [workingDirectory]
    set res
} [lsort [list abc.link abc.dir abc2.dir]]

test fCmd-29.1 {weird memory corruption fault} {
    catch {set res [open [file join ~a_totally_bogus_user_id/foo bar]]}
} 1

cd [temporaryDirectory]
file delete -force abc.link
cd [workingDirectory]

removeFile abc2.file
removeFile abc.file
removeDirectory abc2.dir
removeDirectory abc.dir

# cleanup
cleanup
::tcltest::cleanupTests
return
@


1.4
log
@touched all sources to ease next import
@
text
@d13 1
a13 1
# RCS: @@(#) $Id: fCmd.test,v 1.6.8.2 2000/09/15 16:56:25 spolk Exp $
d17 1
a17 1
    package require tcltest
d21 2
a22 15
if {[string compare testgetplatform [info commands testgetplatform]] != 0} {
    puts "This application hasn't been compiled with the \"testgetplatform\""
    puts "command, therefore I am skipping all of these tests."
    ::tcltest::cleanupTests
    return
}

set platform [testgetplatform]

if {"[info commands testchmod]" != "testchmod"} {
    puts "Skipping fCmd tests. This application does not seem to have the"
    puts "testchmod command that is needed to run these tests."
    ::tcltest::cleanupTests
    return
}
d64 1
a64 1
	    foreach p [glob [file join $path *]] {
d72 6
a77 1
    foreach p ". $args" {
d80 1
a80 1
	    set x [glob [file join $p tf*] [file join $p td*]]
d277 1
a277 1
    set x [file exist td1]
d279 1
a279 1
    list $x [file exist td1]
d289 1
a289 1
    set x [file exist td1]
d291 1
a291 1
    list $x [file exist td1]
d294 1
a294 1
	{unixOnly notRoot} {
d304 2
a305 2
    list [catch {file mkdir nonexistantvolume:} msg] $msg
} {1 {can't create directory "nonexistantvolume:": invalid argument}}
d308 1
a308 1
    set x [file exist td1]
d310 1
a310 1
    list $x [file exist td1]
d350 1
a350 1
    set x [list [file exist tf1] [file exist tf2] [file exist td1]]
d352 1
a352 1
    lappend x [file exist tf1] [file exist tf2] [file exist tf3]
d360 1
a360 1
    list [file exist tf1] [file exist tf2] [file exist td1]
d372 1
a372 1
    set x [file exist tf1]
d374 1
a374 1
    list $x [file exist tf1]
d380 1
a380 1
    file exist td1
d384 1
a384 1
    file mkdir td1/td2
d387 17
d427 1
a427 1
test fCmd-6.6 {CopyRenameOneFile: errno != ENOENT} {unixOnly notRoot} {
d436 1
a436 1
test fCmd-6.7 {CopyRenameOneFile: errno != ENOENT} {95} {
d521 1
a521 1
	list d:/tcl8975@@
a524 1
	set msg
d526 2
d547 1
a547 1
    exec chmod 000 td1
d549 1
a549 1
    exec chmod 755 td1
d556 2
a557 1
    exec chmod 000 [file join [file dirname ~] [file tail ~] td1]
d559 1
a559 1
    exec chmod 755 [file join [file dirname ~] [file tail ~] td1]
d568 2
a569 1
    exec chmod 000 [file join [file dirname ~] [file tail ~] td1]
d571 1
a571 1
    exec chmod 755 [file join [file dirname ~] [file tail ~] td1]
d579 2
a580 1
    exec chmod 000 [file join [file dirname ~] [file tail ~] td1 td2]
d582 1
a582 1
    exec chmod 755 [file join [file dirname ~] [file tail ~] td1 td2]
d598 1
a598 1
    exec chmod 000 td1/td2/td3 
d600 1
a600 1
    exec chmod 755 td1/td2/td3 
d691 1
a691 1
test fCmd-9.3 {file rename: comprehensive: file to new name} {notRoot} {
d700 1
a700 1
test fCmd-9.4 {file rename: comprehensive: dir to new name} {unixOrPc notRoot} {
d708 1
a708 1
test fCmd-9.5 {file rename: comprehensive: file to self} {notRoot} {
d717 1
a717 1
test fCmd-9.6 {file rename: comprehensive: dir to self} {notRoot unixOrPc} {
d726 1
a726 1
test fCmd-9.7 {file rename: comprehensive: file to existing file} {notRoot} {
d749 1
a749 1
test fCmd-9.8 {file rename: comprehensive: dir to empty dir} {notRoot} {
d787 1
a787 1
test fCmd-9.9 {file rename: comprehensive: dir to non-empty dir} {notRoot} {
d805 1
a805 1
test fCmd-9.10 {file rename: comprehensive: file to new name and dir} {notRoot} {
d813 1
a813 1
    list [catch {glob tf*}] [lsort [glob [file join td1 t*]]] \
d816 1
a816 1
test fCmd-9.11 {file rename: comprehensive: dir to new name and dir} {notRoot} {
d831 1
a831 1
    list [lsort [glob td*]] [lsort [glob [file join td3 t*]]] \
d834 1
a834 1
test fCmd-9.12 {file rename: comprehensive: target exists} {notRoot} {
d878 1
a878 1
test fCmd-10.2 {file copy: comprehensive: file to new name} {notRoot} {
d887 1
a887 1
test fCmd-10.3 {file copy: comprehensive: dir to new name} {notRoot unixOrPc} {
d894 2
a895 2
    set msg [list [lsort [glob td*]] [glob [file join td3 t*]] \
	    [glob [file join td4 t*]] [file writable td3] [file writable td4]]
d902 1
a902 1
test fCmd-10.4 {file copy: comprehensive: file to existing file} {notRoot} {
d925 1
a925 1
test fCmd-10.5 {file copy: comprehensive: dir to empty dir} {notRoot} {
d951 1
a951 1
	{notRoot unixOrPc} {
d962 1
a962 1
test fCmd-10.7 {file rename: comprehensive: file to new name and dir} {notRoot} {
d970 1
a970 1
    list [lsort [glob tf*]] [lsort [glob [file join td1 t*]]] \
d974 1
a974 1
	{notRoot unixOrPc} {
d982 1
a982 1
    list [lsort [glob td*]] [lsort [glob [file join td3 t*]]] \
d1161 1
a1161 1
    exec chmod 555 tfa
d1163 1
a1163 1
    exec chmod 777 tfa
d1362 1
a1362 1
    exec chmod 000 tfa/dir
d1364 1
a1364 1
    exec chmod 777 tfa/dir
d1405 1
a1405 1
    exec chmod 000 tfa
d1407 1
a1407 1
    exec chmod 777 tfa
d1451 1
a1451 1
test fCmd-16.1 { test the -- argument } {notRoot} {
d1458 1
a1458 1
test fCmd-16.2 { test the -force and -- arguments } {notRoot} {
d1465 1
a1465 1
test fCmd-16.3 { test bad option } {notRoot} {
d1473 1
a1473 1
test fCmd-16.4 { test not enough args } {notRoot} {
d1477 1
a1477 1
test fCmd-16.5 { test not enough args with options } {notRoot} {
d1512 1
a1512 1
    exec chmod 555 tfa
d1519 1
a1519 1
    exec chmod 777 tfa
d1532 1
a1532 1
test fCmd-16.11 { TclFileDeleteCmd: removing a nonexistant file} {notRoot} {
d1542 1
a1542 1
     exec chmod 555 tfa1
d1544 1
a1544 1
     exec chmod 777 tfa1
d1700 1
a1700 1
    exec ln -s tfa1 tfa2
d1703 1
a1703 1
    set result [expr { $t == "link" }]
d1713 1
a1713 1
    exec ln -s tfa1 tfa2
d1716 1
a1716 1
    set result [expr { $t == "link" }]
d1729 1
a1729 1
    exec ln -s $f $f2
d1744 1
a1744 1
    exec ln -s tfa1 tfalink
d1756 1
a1756 1
    exec ln -s tfa1 tfalink
d1768 1
a1768 1
test fCmd-19.1 { remove empty directory } {notRoot} {
d1775 1
a1775 1
test fCmd-19.2 { rmdir error besides EEXIST} {unixOnly notRoot} {
d1779 1
a1779 1
    exec chmod 555 tfa
d1781 1
a1781 1
    exec chmod 777 tfa
d1786 1
a1786 1
test fCmd-19.3 { recursive remove } {notRoot} {
d1809 1
a1809 1
    exec chmod 000 tfa/a
d1811 1
a1811 1
    exec chmod 777 tfa/a
d1888 1
a1888 1
test fCmd-21.7 {TclCopyFilesCmd: copy a dangling link} {unixOnly notRoot} {
d1890 9
a1898 1
    exec ln -s tfad1 tfalink
d1906 1
a1906 1
test fCmd-21.8 {TclCopyFilesCmd : copy a link } {unixOnly notRoot} {
d1908 1
a1908 1
    exec ln -s tfad1 tfalink
d1910 16
a1925 5
    set r1 [file type tfalink]
    set r2 [file type tfalink2]
    set r3 [file isdir tfad1]
    set result [expr {("$r1" == "link" ) && ("$r2" == "link" ) && $r3}]
    file delete tfad1 tfalink tfalink2
d1931 1
a1931 1
    exec ln -s "[pwd]/tfad1" tfad1/tfalink
d1966 1
a1966 1
   
d1991 1
a1991 1
test fCmd-22.3 { TclpRenameFile : rename dir to existing dir } {notRoot} {
d2061 1
a2061 2
test fCmd-25.1 { TclMacCopyDirectory : copying a normal directory} \
	{notRoot notFileSharing} {
d2071 1
a2071 2
test fCmd-25.2 { TclMacCopyDirectory : copying a short path normal directory} \
	{notRoot notFileSharing} {
d2081 1
a2081 2
test fCmd-25.3 { TclMacCopyDirectory : copying dirs between different dirs} \
	{notRoot notFileSharing} {
d2096 1
a2096 1
test fCmd-26.1 { TclDeleteFilesCmd : delete symlink} {unixOnly notRoot} {
d2100 1
a2100 1
    exec ln -s tfad1 tfalink
d2111 1
a2111 1
test fCmd-26.2 { TclDeleteFilesCmd : delete dir with symlink} {unixOnly notRoot} {
d2116 1
a2116 1
    exec ln -s tfad1 [file join tfad2 link]
d2127 1
a2127 1
test fCmd-26.3 { TclDeleteFilesCmd : delete dangling symlink} {unixOnly notRoot} {
d2131 1
a2131 1
    exec ln -s tfad1 tfad2
d2142 2
a2143 1
test fCmd-27.2 {TclFileAttrsCmd - Tcl_TranslateFileName fails} {
d2162 1
a2162 1
    set ::tcltest::testConstraints(foundGroup) 0
d2166 1
a2166 1
	set ::tcltest::testConstraints(foundGroup) 1
d2169 1
a2169 1
    set ::tcltest::testConstraints(foundGroup) 1
d2185 197
a2385 13













@


1.3
log
@touched all sources to ease next import
@
text
@@


1.3.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d13 1
a13 1
# RCS: @@(#) $Id: fCmd.test,v 1.25 2002/10/04 08:25:14 dkf Exp $
d17 1
a17 1
    package require tcltest 2
d21 15
a35 2
tcltest::testConstraint testsetplatform [string equal testsetplatform [info commands testsetplatform]]
tcltest::testConstraint testchmod [string equal testchmod [info commands testchmod]]
d77 1
a77 1
	    foreach p [glob -directory $path *] {
d85 1
a85 6
	if {$::tcl_platform(platform) == "macintosh"} {
		set wd [list :]
	} else {
		set wd [list .]
	}
    foreach p [concat $wd $args] {
d88 1
a88 1
	    set x [glob -directory $p tf* td*]
d285 1
a285 1
    set x [file exists td1]
d287 1
a287 1
    list $x [file exists td1]
d297 1
a297 1
    set x [file exists td1]
d299 1
a299 1
    list $x [file exists td1]
d302 1
a302 1
	{unixOnly notRoot testchmod} {
d312 2
a313 2
    list [catch {file mkdir nonexistentvolume:} msg] $msg
} {1 {can't create directory "nonexistentvolume:": invalid argument}}
d316 1
a316 1
    set x [file exists td1]
d318 1
a318 1
    list $x [file exists td1]
d358 1
a358 1
    set x [list [file exists tf1] [file exists tf2] [file exists td1]]
d360 1
a360 1
    lappend x [file exists tf1] [file exists tf2] [file exists tf3]
d368 1
a368 1
    list [file exists tf1] [file exists tf2] [file exists td1]
d380 1
a380 1
    set x [file exists tf1]
d382 1
a382 1
    list $x [file exists tf1]
d388 1
a388 1
    file exists td1
d392 1
a392 1
    file mkdir [file join td1 td2]
a394 17
test fCmd-5.11 {TclFileDeleteCmd: TclpRemoveDirectory with cwd inside} {notRoot} {
    cleanup
    set dir [pwd]
    file mkdir [file join td1 td2]
    cd [file join td1 td2]
    set res [list [catch {file delete -force [file dirname [pwd]]} msg]]
    cd $dir
    lappend res [file exists td1] $msg
} {0 0 {}}
test fCmd-5.12 {TclFileDeleteCmd: TclpRemoveDirectory with bad perms} {unixOnly} {
    cleanup
    file mkdir [file join td1 td2]
    #exec chmod u-rwx [file join td1 td2]
    file attributes [file join td1 td2] -permissions u+rwx
    set res [list [catch {file delete -force td1} msg]]
    lappend res [file exists td1] $msg
} {0 0 {}}
d418 1
a418 1
test fCmd-6.6 {CopyRenameOneFile: errno != ENOENT} {unixOnly notRoot testchmod} {
d427 1
a427 1
test fCmd-6.7 {CopyRenameOneFile: errno != ENOENT} {pcOnly 95} {
d512 1
a512 1
	set msg d:/tcl8975@@
d516 1
a517 2
    file delete -force c:/tcl8975@@
    set msg
d537 1
a537 1
    file attributes td1 -permissions 0000
d539 1
a539 1
    file attributes td1 -permissions 0755
d546 1
a546 2
    set td1name [file join [file dirname ~] [file tail ~] td1]
    file attributes $td1name -permissions 0000
d548 1
a548 1
    file attributes $td1name -permissions 0755
d557 1
a557 2
    set td1name [file join [file dirname ~] [file tail ~] td1]
    file attributes $td1name -permissions 0000
d559 1
a559 1
    file attributes $td1name -permissions 0755
d567 1
a567 2
    set td2name [file join [file dirname ~] [file tail ~] td1 td2]
    file attributes $td2name -permissions 0000
d569 1
a569 1
    file attributes $td2name -permissions 0755
d585 1
a585 1
    file attributes td1/td2/td3 -permissions 0000
d587 1
a587 1
    file attributes td1/td2/td3 -permissions 0755
d678 1
a678 1
test fCmd-9.3 {file rename: comprehensive: file to new name} {notRoot testchmod} {
d687 1
a687 1
test fCmd-9.4 {file rename: comprehensive: dir to new name} {unixOrPc notRoot testchmod} {
d695 1
a695 1
test fCmd-9.5 {file rename: comprehensive: file to self} {notRoot testchmod} {
d704 1
a704 1
test fCmd-9.6 {file rename: comprehensive: dir to self} {notRoot unixOrPc testchmod} {
d713 1
a713 1
test fCmd-9.7 {file rename: comprehensive: file to existing file} {notRoot testchmod} {
d736 1
a736 1
test fCmd-9.8 {file rename: comprehensive: dir to empty dir} {notRoot testchmod} {
d774 1
a774 1
test fCmd-9.9 {file rename: comprehensive: dir to non-empty dir} {notRoot testchmod} {
d792 1
a792 1
test fCmd-9.10 {file rename: comprehensive: file to new name and dir} {notRoot testchmod} {
d800 1
a800 1
    list [catch {glob tf*}] [lsort [glob -directory td1 t*]] \
d803 1
a803 1
test fCmd-9.11 {file rename: comprehensive: dir to new name and dir} {notRoot testchmod} {
d818 1
a818 1
    list [lsort [glob td*]] [lsort [glob -directory td3 t*]] \
d821 1
a821 1
test fCmd-9.12 {file rename: comprehensive: target exists} {notRoot testchmod} {
d865 1
a865 1
test fCmd-10.2 {file copy: comprehensive: file to new name} {notRoot testchmod} {
d874 1
a874 1
test fCmd-10.3 {file copy: comprehensive: dir to new name} {notRoot unixOrPc testchmod} {
d881 2
a882 2
    set msg [list [lsort [glob td*]] [glob -directory td3 t*] \
	    [glob -directory td4 t*] [file writable td3] [file writable td4]]
d889 1
a889 1
test fCmd-10.4 {file copy: comprehensive: file to existing file} {notRoot testchmod} {
d912 1
a912 1
test fCmd-10.5 {file copy: comprehensive: dir to empty dir} {notRoot testchmod} {
d938 1
a938 1
	{notRoot unixOrPc testchmod} {
d949 1
a949 1
test fCmd-10.7 {file rename: comprehensive: file to new name and dir} {notRoot testchmod} {
d957 1
a957 1
    list [lsort [glob tf*]] [lsort [glob -directory td1 t*]] \
d961 1
a961 1
	{notRoot unixOrPc testchmod} {
d969 1
a969 1
    list [lsort [glob td*]] [lsort [glob -directory td3 t*]] \
d1148 1
a1148 1
    file attributes tfa -permissions 0555
d1150 1
a1150 1
    file attributes tfa -permissions 0777
d1349 1
a1349 1
    file attributes tfa/dir -permissions 0000
d1351 1
a1351 1
    file attributes tfa/dir -permissions 0777
d1392 1
a1392 1
    file attributes tfa -permissions 0000
d1394 1
a1394 1
    file attributes tfa -permissions 0777
d1438 1
a1438 1
test fCmd-16.1 {test the -- argument} {notRoot} {
d1445 1
a1445 1
test fCmd-16.2 {test the -force and -- arguments} {notRoot} {
d1452 1
a1452 1
test fCmd-16.3 {test bad option} {notRoot} {
d1460 1
a1460 1
test fCmd-16.4 {test not enough args} {notRoot} {
d1464 1
a1464 1
test fCmd-16.5 {test not enough args with options} {notRoot} {
d1499 1
a1499 1
    file attributes tfa -permissions 0555
d1506 1
a1506 1
    file attributes tfa -permissions 0777
d1519 1
a1519 1
test fCmd-16.11 {TclFileDeleteCmd: removing a nonexistant file} {notRoot} {
d1529 1
a1529 1
     file attributes tfa1 -permissions 0555
d1531 1
a1531 1
     file attributes tfa1 -permissions 0777
d1687 1
a1687 1
    file link -symbolic tfa2 tfa1
d1690 1
a1690 1
    set result [expr {$t eq "link"}]
d1700 1
a1700 1
    file link -symbolic tfa2 tfa1
d1703 1
a1703 1
    set result [expr {$t eq "link"}]
d1716 1
a1716 1
    file link -symbolic $f2 $f
d1731 1
a1731 1
    file link -symbolic tfalink tfa1
d1743 1
a1743 1
    file link -symbolic tfalink tfa1
d1755 1
a1755 1
test fCmd-19.1 {remove empty directory} {notRoot} {
d1762 1
a1762 1
test fCmd-19.2 {rmdir error besides EEXIST} {unixOnly notRoot} {
d1766 1
a1766 1
    file attributes tfa -permissions 0555
d1768 1
a1768 1
    file attributes tfa -permissions 0777
d1773 1
a1773 1
test fCmd-19.3 {recursive remove} {notRoot} {
d1796 1
a1796 1
    file attributes tfa/a -permissions 0000
d1798 1
a1798 1
    file attributes tfa/a -permissions 0777
d1875 1
a1875 1
test fCmd-21.7.1 {TclCopyFilesCmd: copy a dangling link} {unixOnly notRoot dontCopyLinks} {
d1877 1
a1877 9
    file link -symbolic tfalink tfad1
    file delete tfad1
    set result [list [catch {file copy tfalink tfalink2} msg] $msg]
    file delete -force tfalink tfalink2 
    set result
} {1 {error copying "tfalink": the target of this link doesn't exist}}
test fCmd-21.7.2 {TclCopyFilesCmd: copy a dangling link} {unixOnly notRoot} {
    file mkdir tfad1
    file link -symbolic tfalink tfad1
d1885 1
a1885 1
test fCmd-21.8.1 {TclCopyFilesCmd: copy a link } {unixOnly notRoot dontCopyLinks} {
d1887 1
a1887 1
    file link -symbolic tfalink tfad1
d1889 5
a1893 16
    set r1 [file type tfalink]; # link
    set r2 [file type tfalink2]; # directory
    set r3 [file isdir tfad1]; # 1
    set result [expr {("$r1" == "link") && ("$r2" == "directory") && $r3}]
    file delete -force tfad1 tfalink tfalink2
    set result
} {1}
test fCmd-21.8.2 {TclCopyFilesCmd: copy a link } {unixOnly notRoot} {
    file mkdir tfad1
    file link -symbolic tfalink tfad1
    file copy tfalink tfalink2
    set r1 [file type tfalink]; # link
    set r2 [file type tfalink2]; # link
    set r3 [file isdir tfad1]; # 1
    set result [expr {("$r1" == "link") && ("$r2" == "link") && $r3}]
    file delete -force tfad1 tfalink tfalink2
d1899 1
a1899 1
    file link -symbolic tfad1/tfalink "[pwd]/tfad1"
d1934 1
a1934 1

d1959 1
a1959 1
test fCmd-22.3 {TclpRenameFile: rename dir to existing dir} {notRoot} {
d2029 2
a2030 1
test fCmd-25.1 {TclMacCopyDirectory: copying a normal directory} {notRoot notFileSharing} {
d2040 2
a2041 1
test fCmd-25.2 {TclMacCopyDirectory: copying a short path normal directory} {notRoot notFileSharing} {
d2051 2
a2052 1
test fCmd-25.3 {TclMacCopyDirectory: copying dirs between different dirs} {notRoot notFileSharing} {
d2067 1
a2067 1
test fCmd-26.1 {TclDeleteFilesCmd: delete symlink} {unixOnly notRoot} {
d2071 1
a2071 1
    file link -symbolic tfalink tfad1
d2082 1
a2082 1
test fCmd-26.2 {TclDeleteFilesCmd: delete dir with symlink} {unixOnly notRoot} {
d2087 1
a2087 1
    file link -symbolic [file join tfad2 link] tfad1
d2098 1
a2098 1
test fCmd-26.3 {TclDeleteFilesCmd: delete dangling symlink} {unixOnly notRoot} {
d2102 1
a2102 1
    file link -symbolic tfad2 tfad1
d2113 1
a2113 2
test fCmd-27.2 {TclFileAttrsCmd - Tcl_TranslateFileName fails} {testsetplatform} {
    set platform [testgetplatform]
d2132 1
a2132 1
    ::tcltest::testConstraint foundGroup 0
d2136 1
a2136 1
	::tcltest::testConstraint foundGroup 1
d2139 1
a2139 1
    ::tcltest::testConstraint foundGroup 1
a2154 197
if {[string equal $tcl_platform(platform) "windows"]} {
    if {[string index $tcl_platform(osVersion) 0] >= 5 \
      && ([lindex [file system [temporaryDirectory]] 1] == "NTFS")} {
	tcltest::testConstraint linkDirectory 1
	tcltest::testConstraint linkFile 1
    } else {
	tcltest::testConstraint linkDirectory 0
	tcltest::testConstraint linkFile 0
    }
} else {
    tcltest::testConstraint linkFile 1
    tcltest::testConstraint linkDirectory 1
}

test fCmd-28.1 {file link} {
    list [catch {file link} msg] $msg
} {1 {wrong # args: should be "file link ?-linktype? linkname ?target?"}}

test fCmd-28.2 {file link} {
    list [catch {file link a b c d} msg] $msg
} {1 {wrong # args: should be "file link ?-linktype? linkname ?target?"}}

test fCmd-28.3 {file link} {
    list [catch {file link abc b c} msg] $msg
} {1 {bad switch "abc": must be -symbolic or -hard}}

test fCmd-28.4 {file link} {
    list [catch {file link -abc b c} msg] $msg
} {1 {bad switch "-abc": must be -symbolic or -hard}}

makeDirectory abc.dir
makeDirectory abc2.dir
makeFile contents abc.file
makeFile contents abc2.file

cd [temporaryDirectory]
test fCmd-28.5 {file link: source already exists} {linkDirectory} {
    cd [temporaryDirectory]
    set res [list [catch {file link abc.dir abc2.dir} msg] $msg]
    cd [workingDirectory]
    set res
} {1 {could not create new link "abc.dir": that path already exists}}

test fCmd-28.6 {file link: unsupported operation} {linkDirectory macOrWin} {
    cd [temporaryDirectory]
    set res [list [catch {file link -hard abc.link abc.dir} msg] $msg]
    cd [workingDirectory]
    set res
} {1 {could not create new link "abc.link" pointing to "abc.dir": illegal operation on a directory}}

test fCmd-28.7 {file link: source already exists} {linkFile} {
    cd [temporaryDirectory]
    set res [list [catch {file link abc.file abc2.file} msg] $msg]
    cd [workingDirectory]
    set res
} {1 {could not create new link "abc.file": that path already exists}}

test fCmd-28.8 {file link} {linkFile winOnly} {
    cd [temporaryDirectory]
    set res [list [catch {file link -symbolic abc.link abc.file} msg] $msg]
    cd [workingDirectory]
    set res
} {1 {could not create new link "abc.link" pointing to "abc.file": not a directory}}

test fCmd-28.9 {file link: success with file} {linkFile} {
    cd [temporaryDirectory]
    file delete -force abc.link
    set res [list [catch {file link abc.link abc.file} msg] $msg]
    cd [workingDirectory]
    set res
} {0 abc.file}

cd [temporaryDirectory]
catch {file delete -force abc.link}
cd [workingDirectory]

test fCmd-28.10 {file link: linking to nonexistent path} {linkDirectory} {
    cd [temporaryDirectory]
    file delete -force abc.link
    set res [list [catch {file link abc.link abc2.doesnt} msg] $msg]
    cd [workingDirectory]
    set res
} {1 {could not create new link "abc.link" since target "abc2.doesnt" doesn't exist}}

test fCmd-28.11 {file link: success with directory} {linkDirectory} {
    cd [temporaryDirectory]
    file delete -force abc.link
    set res [list [catch {file link abc.link abc.dir} msg] $msg]
    cd [workingDirectory]
    set res
} {0 abc.dir}

test fCmd-28.12 {file link: cd into a link} {linkDirectory} {
    cd [temporaryDirectory]
    file delete -force abc.link
    file link abc.link abc.dir
    set orig [pwd]
    cd abc.link
    set dir [pwd]
    cd ..
    set up [pwd]
    cd $orig
    # now '$up' should be either $orig or [file dirname abc.dir],
    # depending on whether 'cd' actually moves to the destination
    # of a link, or simply treats the link as a directory.
    # (on windows the former, on unix the latter, I believe)
    if {([file normalize $up] != [file normalize $orig]) \
      && ([file normalize $up] != [file normalize [file dirname abc.dir]])} {
	set res "wrong directory with 'cd $link ; cd ..'"
    } else {
	set res "ok"
    }
    cd [workingDirectory]
    set res
} {ok}

test fCmd-28.13 {file link} {linkDirectory} {
    # duplicate link throws error
    cd [temporaryDirectory]
    set res [list [catch {file link abc.link abc.dir} msg] $msg]
    cd [workingDirectory]
    set res
} {1 {could not create new link "abc.link": that path already exists}}

test fCmd-28.14 {file link: deletes link not dir} {linkDirectory} {
    cd [temporaryDirectory]
    file delete -force abc.link
    set res [list [file exists abc.link] [file exists abc.dir]]
    cd [workingDirectory]
    set res
} {0 1}

test fCmd-28.15.1 {file link: copies link not dir} {linkDirectory dontCopyLinks} {
    cd [temporaryDirectory]
    file delete -force abc.link
    file link abc.link abc.dir
    file copy abc.link abc2.link
    # abc2.linkdir was a copy of a link to a dir, so it should end up as
    # a directory, not a link (links trace to endpoint).
    set res [list [file type abc2.link] [file tail [file link abc.link]]]
    cd [workingDirectory]
    set res
} {directory abc.dir}
test fCmd-28.15.2 {file link: copies link not dir} {linkDirectory} {
    cd [temporaryDirectory]
    file delete -force abc.link
    file link abc.link abc.dir
    file copy abc.link abc2.link
    set res [list [file type abc2.link] [file tail [file link abc2.link]]]
    cd [workingDirectory]
    set res
} {link abc.dir}

cd [temporaryDirectory]
file delete -force abc.link
file delete -force abc2.link

file copy abc.file abc.dir
file copy abc2.file abc.dir
cd [workingDirectory]

test fCmd-28.16 {file link: glob inside link} {linkDirectory} {
    cd [temporaryDirectory]
    file delete -force abc.link
    file link abc.link abc.dir
    set res [glob -dir abc.link -tails *]
    cd [workingDirectory]
    set res
} {abc.file abc2.file}

test fCmd-28.17 {file link: glob -type l} {linkDirectory} {
    cd [temporaryDirectory]
    set res [glob -dir [pwd] -type l -tails abc*]
    cd [workingDirectory]
    set res
} {abc.link}

test fCmd-28.18 {file link: glob -type d} {linkDirectory} {
    cd [temporaryDirectory]
    set res [lsort [glob -dir [pwd] -type d -tails abc*]]
    cd [workingDirectory]
    set res
} [lsort [list abc.link abc.dir abc2.dir]]

test fCmd-29.1 {weird memory corruption fault} {
    catch {set res [open [file join ~a_totally_bogus_user_id/foo bar]]}
} 1

cd [temporaryDirectory]
file delete -force abc.link
cd [workingDirectory]

removeFile abc2.file
removeFile abc.file
removeDirectory abc2.dir
removeDirectory abc.dir

d2159 13
@


1.3.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@d13 1
a13 1
# RCS: @@(#) $Id: fCmd.test,v 1.24 2002/08/16 13:58:39 dkf Exp $
d17 1
a17 1
    package require tcltest 2
d21 15
a35 2
tcltest::testConstraint testsetplatform [string equal testsetplatform [info commands testsetplatform]]
tcltest::testConstraint testchmod [string equal testchmod [info commands testchmod]]
d77 1
a77 1
	    foreach p [glob -directory $path *] {
d85 1
a85 6
	if {$::tcl_platform(platform) == "macintosh"} {
		set wd [list :]
	} else {
		set wd [list .]
	}
    foreach p [concat $wd $args] {
d88 1
a88 1
	    set x [glob -directory $p tf* td*]
d302 1
a302 1
	{unixOnly notRoot testchmod} {
d312 2
a313 2
    list [catch {file mkdir nonexistentvolume:} msg] $msg
} {1 {can't create directory "nonexistentvolume:": invalid argument}}
d392 1
a392 1
    file mkdir [file join td1 td2]
a394 17
test fCmd-5.11 {TclFileDeleteCmd: TclpRemoveDirectory with cwd inside} {notRoot} {
    cleanup
    set dir [pwd]
    file mkdir [file join td1 td2]
    cd [file join td1 td2]
    set res [list [catch {file delete -force [file dirname [pwd]]} msg]]
    cd $dir
    lappend res [file exists td1] $msg
} {0 0 {}}
test fCmd-5.12 {TclFileDeleteCmd: TclpRemoveDirectory with bad perms} {unixOnly} {
    cleanup
    file mkdir [file join td1 td2]
    #exec chmod u-rwx [file join td1 td2]
    file attributes [file join td1 td2] -permissions u+rwx
    set res [list [catch {file delete -force td1} msg]]
    lappend res [file exists td1] $msg
} {0 0 {}}
d418 1
a418 1
test fCmd-6.6 {CopyRenameOneFile: errno != ENOENT} {unixOnly notRoot testchmod} {
d427 1
a427 1
test fCmd-6.7 {CopyRenameOneFile: errno != ENOENT} {pcOnly 95} {
d512 1
a512 1
	set msg d:/tcl8975@@
d516 1
a517 2
    file delete -force c:/tcl8975@@
    set msg
d537 1
a537 1
    file attributes td1 -permissions 0000
d539 1
a539 1
    file attributes td1 -permissions 0755
d546 1
a546 2
    set td1name [file join [file dirname ~] [file tail ~] td1]
    file attributes $td1name -permissions 0000
d548 1
a548 1
    file attributes $td1name -permissions 0755
d557 1
a557 2
    set td1name [file join [file dirname ~] [file tail ~] td1]
    file attributes $td1name -permissions 0000
d559 1
a559 1
    file attributes $td1name -permissions 0755
d567 1
a567 2
    set td2name [file join [file dirname ~] [file tail ~] td1 td2]
    file attributes $td2name -permissions 0000
d569 1
a569 1
    file attributes $td2name -permissions 0755
d585 1
a585 1
    file attributes td1/td2/td3 -permissions 0000
d587 1
a587 1
    file attributes td1/td2/td3 -permissions 0755
d678 1
a678 1
test fCmd-9.3 {file rename: comprehensive: file to new name} {notRoot testchmod} {
d687 1
a687 1
test fCmd-9.4 {file rename: comprehensive: dir to new name} {unixOrPc notRoot testchmod} {
d695 1
a695 1
test fCmd-9.5 {file rename: comprehensive: file to self} {notRoot testchmod} {
d704 1
a704 1
test fCmd-9.6 {file rename: comprehensive: dir to self} {notRoot unixOrPc testchmod} {
d713 1
a713 1
test fCmd-9.7 {file rename: comprehensive: file to existing file} {notRoot testchmod} {
d736 1
a736 1
test fCmd-9.8 {file rename: comprehensive: dir to empty dir} {notRoot testchmod} {
d774 1
a774 1
test fCmd-9.9 {file rename: comprehensive: dir to non-empty dir} {notRoot testchmod} {
d792 1
a792 1
test fCmd-9.10 {file rename: comprehensive: file to new name and dir} {notRoot testchmod} {
d800 1
a800 1
    list [catch {glob tf*}] [lsort [glob -directory td1 t*]] \
d803 1
a803 1
test fCmd-9.11 {file rename: comprehensive: dir to new name and dir} {notRoot testchmod} {
d818 1
a818 1
    list [lsort [glob td*]] [lsort [glob -directory td3 t*]] \
d821 1
a821 1
test fCmd-9.12 {file rename: comprehensive: target exists} {notRoot testchmod} {
d865 1
a865 1
test fCmd-10.2 {file copy: comprehensive: file to new name} {notRoot testchmod} {
d874 1
a874 1
test fCmd-10.3 {file copy: comprehensive: dir to new name} {notRoot unixOrPc testchmod} {
d881 2
a882 2
    set msg [list [lsort [glob td*]] [glob -directory td3 t*] \
	    [glob -directory td4 t*] [file writable td3] [file writable td4]]
d889 1
a889 1
test fCmd-10.4 {file copy: comprehensive: file to existing file} {notRoot testchmod} {
d912 1
a912 1
test fCmd-10.5 {file copy: comprehensive: dir to empty dir} {notRoot testchmod} {
d938 1
a938 1
	{notRoot unixOrPc testchmod} {
d949 1
a949 1
test fCmd-10.7 {file rename: comprehensive: file to new name and dir} {notRoot testchmod} {
d957 1
a957 1
    list [lsort [glob tf*]] [lsort [glob -directory td1 t*]] \
d961 1
a961 1
	{notRoot unixOrPc testchmod} {
d969 1
a969 1
    list [lsort [glob td*]] [lsort [glob -directory td3 t*]] \
d1148 1
a1148 1
    file attributes tfa -permissions 0555
d1150 1
a1150 1
    file attributes tfa -permissions 0777
d1349 1
a1349 1
    file attributes tfa/dir -permissions 0000
d1351 1
a1351 1
    file attributes tfa/dir -permissions 0777
d1392 1
a1392 1
    file attributes tfa -permissions 0000
d1394 1
a1394 1
    file attributes tfa -permissions 0777
d1438 1
a1438 1
test fCmd-16.1 {test the -- argument} {notRoot} {
d1445 1
a1445 1
test fCmd-16.2 {test the -force and -- arguments} {notRoot} {
d1452 1
a1452 1
test fCmd-16.3 {test bad option} {notRoot} {
d1460 1
a1460 1
test fCmd-16.4 {test not enough args} {notRoot} {
d1464 1
a1464 1
test fCmd-16.5 {test not enough args with options} {notRoot} {
d1499 1
a1499 1
    file attributes tfa -permissions 0555
d1506 1
a1506 1
    file attributes tfa -permissions 0777
d1519 1
a1519 1
test fCmd-16.11 {TclFileDeleteCmd: removing a nonexistant file} {notRoot} {
d1529 1
a1529 1
     file attributes tfa1 -permissions 0555
d1531 1
a1531 1
     file attributes tfa1 -permissions 0777
d1687 1
a1687 1
    file link -symbolic tfa2 tfa1
d1690 1
a1690 1
    set result [expr {$t eq "link"}]
d1700 1
a1700 1
    file link -symbolic tfa2 tfa1
d1703 1
a1703 1
    set result [expr {$t eq "link"}]
d1716 1
a1716 1
    file link -symbolic $f2 $f
d1731 1
a1731 1
    file link -symbolic tfalink tfa1
d1743 1
a1743 1
    file link -symbolic tfalink tfa1
d1755 1
a1755 1
test fCmd-19.1 {remove empty directory} {notRoot} {
d1762 1
a1762 1
test fCmd-19.2 {rmdir error besides EEXIST} {unixOnly notRoot} {
d1766 1
a1766 1
    file attributes tfa -permissions 0555
d1768 1
a1768 1
    file attributes tfa -permissions 0777
d1773 1
a1773 1
test fCmd-19.3 {recursive remove} {notRoot} {
d1796 1
a1796 1
    file attributes tfa/a -permissions 0000
d1798 1
a1798 1
    file attributes tfa/a -permissions 0777
d1875 1
a1875 1
test fCmd-21.7.1 {TclCopyFilesCmd: copy a dangling link} {unixOnly notRoot dontCopyLinks} {
d1877 1
a1877 9
    file link -symbolic tfalink tfad1
    file delete tfad1
    set result [list [catch {file copy tfalink tfalink2} msg] $msg]
    file delete -force tfalink tfalink2 
    set result
} {1 {error copying "tfalink": the target of this link doesn't exist}}
test fCmd-21.7.2 {TclCopyFilesCmd: copy a dangling link} {unixOnly notRoot} {
    file mkdir tfad1
    file link -symbolic tfalink tfad1
d1885 1
a1885 1
test fCmd-21.8.1 {TclCopyFilesCmd: copy a link } {unixOnly notRoot dontCopyLinks} {
d1887 1
a1887 1
    file link -symbolic tfalink tfad1
d1889 5
a1893 16
    set r1 [file type tfalink]; # link
    set r2 [file type tfalink2]; # directory
    set r3 [file isdir tfad1]; # 1
    set result [expr {("$r1" == "link") && ("$r2" == "directory") && $r3}]
    file delete -force tfad1 tfalink tfalink2
    set result
} {1}
test fCmd-21.8.2 {TclCopyFilesCmd: copy a link } {unixOnly notRoot} {
    file mkdir tfad1
    file link -symbolic tfalink tfad1
    file copy tfalink tfalink2
    set r1 [file type tfalink]; # link
    set r2 [file type tfalink2]; # link
    set r3 [file isdir tfad1]; # 1
    set result [expr {("$r1" == "link") && ("$r2" == "link") && $r3}]
    file delete -force tfad1 tfalink tfalink2
d1899 1
a1899 1
    file link -symbolic tfad1/tfalink "[pwd]/tfad1"
d1934 1
a1934 1

d1959 1
a1959 1
test fCmd-22.3 {TclpRenameFile: rename dir to existing dir} {notRoot} {
d2029 2
a2030 1
test fCmd-25.1 {TclMacCopyDirectory: copying a normal directory} {notRoot notFileSharing} {
d2040 2
a2041 1
test fCmd-25.2 {TclMacCopyDirectory: copying a short path normal directory} {notRoot notFileSharing} {
d2051 2
a2052 1
test fCmd-25.3 {TclMacCopyDirectory: copying dirs between different dirs} {notRoot notFileSharing} {
d2067 1
a2067 1
test fCmd-26.1 {TclDeleteFilesCmd: delete symlink} {unixOnly notRoot} {
d2071 1
a2071 1
    file link -symbolic tfalink tfad1
d2082 1
a2082 1
test fCmd-26.2 {TclDeleteFilesCmd: delete dir with symlink} {unixOnly notRoot} {
d2087 1
a2087 1
    file link -symbolic [file join tfad2 link] tfad1
d2098 1
a2098 1
test fCmd-26.3 {TclDeleteFilesCmd: delete dangling symlink} {unixOnly notRoot} {
d2102 1
a2102 1
    file link -symbolic tfad2 tfad1
d2113 1
a2113 2
test fCmd-27.2 {TclFileAttrsCmd - Tcl_TranslateFileName fails} {testsetplatform} {
    set platform [testgetplatform]
d2132 1
a2132 1
    ::tcltest::testConstraint foundGroup 0
d2136 1
a2136 1
	::tcltest::testConstraint foundGroup 1
d2139 1
a2139 1
    ::tcltest::testConstraint foundGroup 1
a2154 197
if {[string equal $tcl_platform(platform) "windows"]} {
    if {[string index $tcl_platform(osVersion) 0] >= 5 \
      && ([lindex [file system [temporaryDirectory]] 1] == "NTFS")} {
	tcltest::testConstraint linkDirectory 1
	tcltest::testConstraint linkFile 1
    } else {
	tcltest::testConstraint linkDirectory 0
	tcltest::testConstraint linkFile 0
    }
} else {
    tcltest::testConstraint linkFile 1
    tcltest::testConstraint linkDirectory 1
}

test fCmd-28.1 {file link} {
    list [catch {file link} msg] $msg
} {1 {wrong # args: should be "file link ?-linktype? linkname ?target?"}}

test fCmd-28.2 {file link} {
    list [catch {file link a b c d} msg] $msg
} {1 {wrong # args: should be "file link ?-linktype? linkname ?target?"}}

test fCmd-28.3 {file link} {
    list [catch {file link abc b c} msg] $msg
} {1 {bad switch "abc": must be -symbolic or -hard}}

test fCmd-28.4 {file link} {
    list [catch {file link -abc b c} msg] $msg
} {1 {bad switch "-abc": must be -symbolic or -hard}}

makeDirectory abc.dir
makeDirectory abc2.dir
makeFile contents abc.file
makeFile contents abc2.file

cd [temporaryDirectory]
test fCmd-28.5 {file link: source already exists} {linkDirectory} {
    cd [temporaryDirectory]
    set res [list [catch {file link abc.dir abc2.dir} msg] $msg]
    cd [workingDirectory]
    set res
} {1 {could not create new link "abc.dir": that path already exists}}

test fCmd-28.6 {file link: unsupported operation} {linkDirectory macOrWin} {
    cd [temporaryDirectory]
    set res [list [catch {file link -hard abc.link abc.dir} msg] $msg]
    cd [workingDirectory]
    set res
} {1 {could not create new link "abc.link" pointing to "abc.dir": illegal operation on a directory}}

test fCmd-28.7 {file link: source already exists} {linkFile} {
    cd [temporaryDirectory]
    set res [list [catch {file link abc.file abc2.file} msg] $msg]
    cd [workingDirectory]
    set res
} {1 {could not create new link "abc.file": that path already exists}}

test fCmd-28.8 {file link} {linkFile winOnly} {
    cd [temporaryDirectory]
    set res [list [catch {file link -symbolic abc.link abc.file} msg] $msg]
    cd [workingDirectory]
    set res
} {1 {could not create new link "abc.link" pointing to "abc.file": not a directory}}

test fCmd-28.9 {file link: success with file} {linkFile} {
    cd [temporaryDirectory]
    file delete -force abc.link
    set res [list [catch {file link abc.link abc.file} msg] $msg]
    cd [workingDirectory]
    set res
} {0 abc.file}

cd [temporaryDirectory]
catch {file delete -force abc.link}
cd [workingDirectory]

test fCmd-28.10 {file link: linking to nonexistent path} {linkDirectory} {
    cd [temporaryDirectory]
    file delete -force abc.link
    set res [list [catch {file link abc.link abc2.doesnt} msg] $msg]
    cd [workingDirectory]
    set res
} {1 {could not create new link "abc.link" since target "abc2.doesnt" doesn't exist}}

test fCmd-28.11 {file link: success with directory} {linkDirectory} {
    cd [temporaryDirectory]
    file delete -force abc.link
    set res [list [catch {file link abc.link abc.dir} msg] $msg]
    cd [workingDirectory]
    set res
} {0 abc.dir}

test fCmd-28.12 {file link: cd into a link} {linkDirectory} {
    cd [temporaryDirectory]
    file delete -force abc.link
    file link abc.link abc.dir
    set orig [pwd]
    cd abc.link
    set dir [pwd]
    cd ..
    set up [pwd]
    cd $orig
    # now '$up' should be either $orig or [file dirname abc.dir],
    # depending on whether 'cd' actually moves to the destination
    # of a link, or simply treats the link as a directory.
    # (on windows the former, on unix the latter, I believe)
    if {([file normalize $up] != [file normalize $orig]) \
      && ([file normalize $up] != [file normalize [file dirname abc.dir]])} {
	set res "wrong directory with 'cd $link ; cd ..'"
    } else {
	set res "ok"
    }
    cd [workingDirectory]
    set res
} {ok}

test fCmd-28.13 {file link} {linkDirectory} {
    # duplicate link throws error
    cd [temporaryDirectory]
    set res [list [catch {file link abc.link abc.dir} msg] $msg]
    cd [workingDirectory]
    set res
} {1 {could not create new link "abc.link": that path already exists}}

test fCmd-28.14 {file link: deletes link not dir} {linkDirectory} {
    cd [temporaryDirectory]
    file delete -force abc.link
    set res [list [file exists abc.link] [file exists abc.dir]]
    cd [workingDirectory]
    set res
} {0 1}

test fCmd-28.15.1 {file link: copies link not dir} {linkDirectory dontCopyLinks} {
    cd [temporaryDirectory]
    file delete -force abc.link
    file link abc.link abc.dir
    file copy abc.link abc2.link
    # abc2.linkdir was a copy of a link to a dir, so it should end up as
    # a directory, not a link (links trace to endpoint).
    set res [list [file type abc2.link] [file tail [file link abc.link]]]
    cd [workingDirectory]
    set res
} {directory abc.dir}
test fCmd-28.15.2 {file link: copies link not dir} {linkDirectory} {
    cd [temporaryDirectory]
    file delete -force abc.link
    file link abc.link abc.dir
    file copy abc.link abc2.link
    set res [list [file type abc2.link] [file tail [file link abc2.link]]]
    cd [workingDirectory]
    set res
} {link abc.dir}

cd [temporaryDirectory]
file delete -force abc.link
file delete -force abc2.link

file copy abc.file abc.dir
file copy abc2.file abc.dir
cd [workingDirectory]

test fCmd-28.16 {file link: glob inside link} {linkDirectory} {
    cd [temporaryDirectory]
    file delete -force abc.link
    file link abc.link abc.dir
    set res [glob -dir abc.link -tails *]
    cd [workingDirectory]
    set res
} {abc.file abc2.file}

test fCmd-28.17 {file link: glob -type l} {linkDirectory} {
    cd [temporaryDirectory]
    set res [glob -dir [pwd] -type l -tails abc*]
    cd [workingDirectory]
    set res
} {abc.link}

test fCmd-28.18 {file link: glob -type d} {linkDirectory} {
    cd [temporaryDirectory]
    set res [lsort [glob -dir [pwd] -type d -tails abc*]]
    cd [workingDirectory]
    set res
} [lsort [list abc.link abc.dir abc2.dir]]

test fCmd-29.1 {weird memory corruption fault} {
    catch {set res [open [file join ~a_totally_bogus_user_id/foo bar]]}
} 1

cd [temporaryDirectory]
file delete -force abc.link
cd [workingDirectory]

removeFile abc2.file
removeFile abc.file
removeDirectory abc2.dir
removeDirectory abc.dir

d2159 13
@


1.2
log
@touched all Tcl files to ease next import.
@
text
@@


1.2.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.2.16.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d17 1
a17 1
    package require tcltest 2
d21 15
a35 2
tcltest::testConstraint testsetplatform [string equal testsetplatform [info commands testsetplatform]]
tcltest::testConstraint testchmod [string equal testchmod [info commands testchmod]]
d77 1
a77 1
	    foreach p [glob -directory $path *] {
d85 1
a85 6
	if {$::tcl_platform(platform) == "macintosh"} {
		set wd [list :]
	} else {
		set wd [list .]
	}
    foreach p [concat $wd $args] {
d88 1
a88 1
	    set x [glob -directory $p tf* td*]
d285 1
a285 1
    set x [file exists td1]
d287 1
a287 1
    list $x [file exists td1]
d297 1
a297 1
    set x [file exists td1]
d299 1
a299 1
    list $x [file exists td1]
d302 1
a302 1
	{unixOnly notRoot testchmod} {
d312 2
a313 2
    list [catch {file mkdir nonexistentvolume:} msg] $msg
} {1 {can't create directory "nonexistentvolume:": invalid argument}}
d316 1
a316 1
    set x [file exists td1]
d318 1
a318 1
    list $x [file exists td1]
d358 1
a358 1
    set x [list [file exists tf1] [file exists tf2] [file exists td1]]
d360 1
a360 1
    lappend x [file exists tf1] [file exists tf2] [file exists tf3]
d368 1
a368 1
    list [file exists tf1] [file exists tf2] [file exists td1]
d380 1
a380 1
    set x [file exists tf1]
d382 1
a382 1
    list $x [file exists tf1]
d388 1
a388 1
    file exists td1
d392 1
a392 1
    file mkdir [file join td1 td2]
a394 17
test fCmd-5.11 {TclFileDeleteCmd: TclpRemoveDirectory with cwd inside} {notRoot} {
    cleanup
    set dir [pwd]
    file mkdir [file join td1 td2]
    cd [file join td1 td2]
    set res [list [catch {file delete -force [file dirname [pwd]]} msg]]
    cd $dir
    lappend res [file exists td1] $msg
} {0 0 {}}
test fCmd-5.12 {TclFileDeleteCmd: TclpRemoveDirectory with bad perms} {unixOnly} {
    cleanup
    file mkdir [file join td1 td2]
    #exec chmod u-rwx [file join td1 td2]
    file attributes [file join td1 td2] -permissions u+rwx
    set res [list [catch {file delete -force td1} msg]]
    lappend res [file exists td1] $msg
} {0 0 {}}
d418 1
a418 1
test fCmd-6.6 {CopyRenameOneFile: errno != ENOENT} {unixOnly notRoot testchmod} {
d427 1
a427 1
test fCmd-6.7 {CopyRenameOneFile: errno != ENOENT} {pcOnly 95} {
d512 1
a512 1
	set msg d:/tcl8975@@
d516 1
a517 2
    file delete -force c:/tcl8975@@
    set msg
d537 1
a537 1
    file attributes td1 -permissions 0000
d539 1
a539 1
    file attributes td1 -permissions 0755
d546 1
a546 2
    set td1name [file join [file dirname ~] [file tail ~] td1]
    file attributes $td1name -permissions 0000
d548 1
a548 1
    file attributes $td1name -permissions 0755
d557 1
a557 2
    set td1name [file join [file dirname ~] [file tail ~] td1]
    file attributes $td1name -permissions 0000
d559 1
a559 1
    file attributes $td1name -permissions 0755
d567 1
a567 2
    set td2name [file join [file dirname ~] [file tail ~] td1 td2]
    file attributes $td2name -permissions 0000
d569 1
a569 1
    file attributes $td2name -permissions 0755
d585 1
a585 1
    file attributes td1/td2/td3 -permissions 0000
d587 1
a587 1
    file attributes td1/td2/td3 -permissions 0755
d678 1
a678 1
test fCmd-9.3 {file rename: comprehensive: file to new name} {notRoot testchmod} {
d687 1
a687 1
test fCmd-9.4 {file rename: comprehensive: dir to new name} {unixOrPc notRoot testchmod} {
d695 1
a695 1
test fCmd-9.5 {file rename: comprehensive: file to self} {notRoot testchmod} {
d704 1
a704 1
test fCmd-9.6 {file rename: comprehensive: dir to self} {notRoot unixOrPc testchmod} {
d713 1
a713 1
test fCmd-9.7 {file rename: comprehensive: file to existing file} {notRoot testchmod} {
d736 1
a736 1
test fCmd-9.8 {file rename: comprehensive: dir to empty dir} {notRoot testchmod} {
d774 1
a774 1
test fCmd-9.9 {file rename: comprehensive: dir to non-empty dir} {notRoot testchmod} {
d792 1
a792 1
test fCmd-9.10 {file rename: comprehensive: file to new name and dir} {notRoot testchmod} {
d800 1
a800 1
    list [catch {glob tf*}] [lsort [glob -directory td1 t*]] \
d803 1
a803 1
test fCmd-9.11 {file rename: comprehensive: dir to new name and dir} {notRoot testchmod} {
d818 1
a818 1
    list [lsort [glob td*]] [lsort [glob -directory td3 t*]] \
d821 1
a821 1
test fCmd-9.12 {file rename: comprehensive: target exists} {notRoot testchmod} {
d865 1
a865 1
test fCmd-10.2 {file copy: comprehensive: file to new name} {notRoot testchmod} {
d874 1
a874 1
test fCmd-10.3 {file copy: comprehensive: dir to new name} {notRoot unixOrPc testchmod} {
d881 2
a882 2
    set msg [list [lsort [glob td*]] [glob -directory td3 t*] \
	    [glob -directory td4 t*] [file writable td3] [file writable td4]]
d889 1
a889 1
test fCmd-10.4 {file copy: comprehensive: file to existing file} {notRoot testchmod} {
d912 1
a912 1
test fCmd-10.5 {file copy: comprehensive: dir to empty dir} {notRoot testchmod} {
d938 1
a938 1
	{notRoot unixOrPc testchmod} {
d949 1
a949 1
test fCmd-10.7 {file rename: comprehensive: file to new name and dir} {notRoot testchmod} {
d957 1
a957 1
    list [lsort [glob tf*]] [lsort [glob -directory td1 t*]] \
d961 1
a961 1
	{notRoot unixOrPc testchmod} {
d969 1
a969 1
    list [lsort [glob td*]] [lsort [glob -directory td3 t*]] \
d1148 1
a1148 1
    file attributes tfa -permissions 0555
d1150 1
a1150 1
    file attributes tfa -permissions 0777
d1349 1
a1349 1
    file attributes tfa/dir -permissions 0000
d1351 1
a1351 1
    file attributes tfa/dir -permissions 0777
d1392 1
a1392 1
    file attributes tfa -permissions 0000
d1394 1
a1394 1
    file attributes tfa -permissions 0777
d1438 1
a1438 1
test fCmd-16.1 {test the -- argument} {notRoot} {
d1445 1
a1445 1
test fCmd-16.2 {test the -force and -- arguments} {notRoot} {
d1452 1
a1452 1
test fCmd-16.3 {test bad option} {notRoot} {
d1460 1
a1460 1
test fCmd-16.4 {test not enough args} {notRoot} {
d1464 1
a1464 1
test fCmd-16.5 {test not enough args with options} {notRoot} {
d1499 1
a1499 1
    file attributes tfa -permissions 0555
d1506 1
a1506 1
    file attributes tfa -permissions 0777
d1519 1
a1519 1
test fCmd-16.11 {TclFileDeleteCmd: removing a nonexistant file} {notRoot} {
d1529 1
a1529 1
     file attributes tfa1 -permissions 0555
d1531 1
a1531 1
     file attributes tfa1 -permissions 0777
d1687 1
a1687 1
    file link -symbolic tfa2 tfa1
d1690 1
a1690 1
    set result [expr {$t eq "link"}]
d1700 1
a1700 1
    file link -symbolic tfa2 tfa1
d1703 1
a1703 1
    set result [expr {$t eq "link"}]
d1716 1
a1716 1
    file link -symbolic $f2 $f
d1731 1
a1731 1
    file link -symbolic tfalink tfa1
d1743 1
a1743 1
    file link -symbolic tfalink tfa1
d1755 1
a1755 1
test fCmd-19.1 {remove empty directory} {notRoot} {
d1762 1
a1762 1
test fCmd-19.2 {rmdir error besides EEXIST} {unixOnly notRoot} {
d1766 1
a1766 1
    file attributes tfa -permissions 0555
d1768 1
a1768 1
    file attributes tfa -permissions 0777
d1773 1
a1773 1
test fCmd-19.3 {recursive remove} {notRoot} {
d1796 1
a1796 1
    file attributes tfa/a -permissions 0000
d1798 1
a1798 1
    file attributes tfa/a -permissions 0777
d1875 1
a1875 1
test fCmd-21.7.1 {TclCopyFilesCmd: copy a dangling link} {unixOnly notRoot dontCopyLinks} {
d1877 1
a1877 9
    file link -symbolic tfalink tfad1
    file delete tfad1
    set result [list [catch {file copy tfalink tfalink2} msg] $msg]
    file delete -force tfalink tfalink2 
    set result
} {1 {error copying "tfalink": the target of this link doesn't exist}}
test fCmd-21.7.2 {TclCopyFilesCmd: copy a dangling link} {unixOnly notRoot} {
    file mkdir tfad1
    file link -symbolic tfalink tfad1
d1885 1
a1885 1
test fCmd-21.8.1 {TclCopyFilesCmd: copy a link } {unixOnly notRoot dontCopyLinks} {
d1887 1
a1887 1
    file link -symbolic tfalink tfad1
d1889 5
a1893 16
    set r1 [file type tfalink]; # link
    set r2 [file type tfalink2]; # directory
    set r3 [file isdir tfad1]; # 1
    set result [expr {("$r1" == "link") && ("$r2" == "directory") && $r3}]
    file delete -force tfad1 tfalink tfalink2
    set result
} {1}
test fCmd-21.8.2 {TclCopyFilesCmd: copy a link } {unixOnly notRoot} {
    file mkdir tfad1
    file link -symbolic tfalink tfad1
    file copy tfalink tfalink2
    set r1 [file type tfalink]; # link
    set r2 [file type tfalink2]; # link
    set r3 [file isdir tfad1]; # 1
    set result [expr {("$r1" == "link") && ("$r2" == "link") && $r3}]
    file delete -force tfad1 tfalink tfalink2
d1899 1
a1899 1
    file link -symbolic tfad1/tfalink "[pwd]/tfad1"
d1934 1
a1934 1

d1959 1
a1959 1
test fCmd-22.3 {TclpRenameFile: rename dir to existing dir} {notRoot} {
d2029 2
a2030 1
test fCmd-25.1 {TclMacCopyDirectory: copying a normal directory} {notRoot notFileSharing} {
d2040 2
a2041 1
test fCmd-25.2 {TclMacCopyDirectory: copying a short path normal directory} {notRoot notFileSharing} {
d2051 2
a2052 1
test fCmd-25.3 {TclMacCopyDirectory: copying dirs between different dirs} {notRoot notFileSharing} {
d2067 1
a2067 1
test fCmd-26.1 {TclDeleteFilesCmd: delete symlink} {unixOnly notRoot} {
d2071 1
a2071 1
    file link -symbolic tfalink tfad1
d2082 1
a2082 1
test fCmd-26.2 {TclDeleteFilesCmd: delete dir with symlink} {unixOnly notRoot} {
d2087 1
a2087 1
    file link -symbolic [file join tfad2 link] tfad1
d2098 1
a2098 1
test fCmd-26.3 {TclDeleteFilesCmd: delete dangling symlink} {unixOnly notRoot} {
d2102 1
a2102 1
    file link -symbolic tfad2 tfad1
d2113 1
a2113 2
test fCmd-27.2 {TclFileAttrsCmd - Tcl_TranslateFileName fails} {testsetplatform} {
    set platform [testgetplatform]
d2132 1
a2132 1
    ::tcltest::testConstraint foundGroup 0
d2136 1
a2136 1
	::tcltest::testConstraint foundGroup 1
d2139 1
a2139 1
    ::tcltest::testConstraint foundGroup 1
a2154 197
if {[string equal $tcl_platform(platform) "windows"]} {
    if {[string index $tcl_platform(osVersion) 0] >= 5 \
      && ([lindex [file system [temporaryDirectory]] 1] == "NTFS")} {
	tcltest::testConstraint linkDirectory 1
	tcltest::testConstraint linkFile 1
    } else {
	tcltest::testConstraint linkDirectory 0
	tcltest::testConstraint linkFile 0
    }
} else {
    tcltest::testConstraint linkFile 1
    tcltest::testConstraint linkDirectory 1
}

test fCmd-28.1 {file link} {
    list [catch {file link} msg] $msg
} {1 {wrong # args: should be "file link ?-linktype? linkname ?target?"}}

test fCmd-28.2 {file link} {
    list [catch {file link a b c d} msg] $msg
} {1 {wrong # args: should be "file link ?-linktype? linkname ?target?"}}

test fCmd-28.3 {file link} {
    list [catch {file link abc b c} msg] $msg
} {1 {bad switch "abc": must be -symbolic or -hard}}

test fCmd-28.4 {file link} {
    list [catch {file link -abc b c} msg] $msg
} {1 {bad switch "-abc": must be -symbolic or -hard}}

makeDirectory abc.dir
makeDirectory abc2.dir
makeFile contents abc.file
makeFile contents abc2.file

cd [temporaryDirectory]
test fCmd-28.5 {file link: source already exists} {linkDirectory} {
    cd [temporaryDirectory]
    set res [list [catch {file link abc.dir abc2.dir} msg] $msg]
    cd [workingDirectory]
    set res
} {1 {could not create new link "abc.dir": that path already exists}}

test fCmd-28.6 {file link: unsupported operation} {linkDirectory macOrWin} {
    cd [temporaryDirectory]
    set res [list [catch {file link -hard abc.link abc.dir} msg] $msg]
    cd [workingDirectory]
    set res
} {1 {could not create new link "abc.link" pointing to "abc.dir": illegal operation on a directory}}

test fCmd-28.7 {file link: source already exists} {linkFile} {
    cd [temporaryDirectory]
    set res [list [catch {file link abc.file abc2.file} msg] $msg]
    cd [workingDirectory]
    set res
} {1 {could not create new link "abc.file": that path already exists}}

test fCmd-28.8 {file link} {linkFile winOnly} {
    cd [temporaryDirectory]
    set res [list [catch {file link -symbolic abc.link abc.file} msg] $msg]
    cd [workingDirectory]
    set res
} {1 {could not create new link "abc.link" pointing to "abc.file": not a directory}}

test fCmd-28.9 {file link: success with file} {linkFile} {
    cd [temporaryDirectory]
    file delete -force abc.link
    set res [list [catch {file link abc.link abc.file} msg] $msg]
    cd [workingDirectory]
    set res
} {0 abc.file}

cd [temporaryDirectory]
catch {file delete -force abc.link}
cd [workingDirectory]

test fCmd-28.10 {file link: linking to nonexistent path} {linkDirectory} {
    cd [temporaryDirectory]
    file delete -force abc.link
    set res [list [catch {file link abc.link abc2.doesnt} msg] $msg]
    cd [workingDirectory]
    set res
} {1 {could not create new link "abc.link" since target "abc2.doesnt" doesn't exist}}

test fCmd-28.11 {file link: success with directory} {linkDirectory} {
    cd [temporaryDirectory]
    file delete -force abc.link
    set res [list [catch {file link abc.link abc.dir} msg] $msg]
    cd [workingDirectory]
    set res
} {0 abc.dir}

test fCmd-28.12 {file link: cd into a link} {linkDirectory} {
    cd [temporaryDirectory]
    file delete -force abc.link
    file link abc.link abc.dir
    set orig [pwd]
    cd abc.link
    set dir [pwd]
    cd ..
    set up [pwd]
    cd $orig
    # now '$up' should be either $orig or [file dirname abc.dir],
    # depending on whether 'cd' actually moves to the destination
    # of a link, or simply treats the link as a directory.
    # (on windows the former, on unix the latter, I believe)
    if {([file normalize $up] != [file normalize $orig]) \
      && ([file normalize $up] != [file normalize [file dirname abc.dir]])} {
	set res "wrong directory with 'cd $link ; cd ..'"
    } else {
	set res "ok"
    }
    cd [workingDirectory]
    set res
} {ok}

test fCmd-28.13 {file link} {linkDirectory} {
    # duplicate link throws error
    cd [temporaryDirectory]
    set res [list [catch {file link abc.link abc.dir} msg] $msg]
    cd [workingDirectory]
    set res
} {1 {could not create new link "abc.link": that path already exists}}

test fCmd-28.14 {file link: deletes link not dir} {linkDirectory} {
    cd [temporaryDirectory]
    file delete -force abc.link
    set res [list [file exists abc.link] [file exists abc.dir]]
    cd [workingDirectory]
    set res
} {0 1}

test fCmd-28.15.1 {file link: copies link not dir} {linkDirectory dontCopyLinks} {
    cd [temporaryDirectory]
    file delete -force abc.link
    file link abc.link abc.dir
    file copy abc.link abc2.link
    # abc2.linkdir was a copy of a link to a dir, so it should end up as
    # a directory, not a link (links trace to endpoint).
    set res [list [file type abc2.link] [file tail [file link abc.link]]]
    cd [workingDirectory]
    set res
} {directory abc.dir}
test fCmd-28.15.2 {file link: copies link not dir} {linkDirectory} {
    cd [temporaryDirectory]
    file delete -force abc.link
    file link abc.link abc.dir
    file copy abc.link abc2.link
    set res [list [file type abc2.link] [file tail [file link abc2.link]]]
    cd [workingDirectory]
    set res
} {link abc.dir}

cd [temporaryDirectory]
file delete -force abc.link
file delete -force abc2.link

file copy abc.file abc.dir
file copy abc2.file abc.dir
cd [workingDirectory]

test fCmd-28.16 {file link: glob inside link} {linkDirectory} {
    cd [temporaryDirectory]
    file delete -force abc.link
    file link abc.link abc.dir
    set res [glob -dir abc.link -tails *]
    cd [workingDirectory]
    set res
} {abc.file abc2.file}

test fCmd-28.17 {file link: glob -type l} {linkDirectory} {
    cd [temporaryDirectory]
    set res [glob -dir [pwd] -type l -tails abc*]
    cd [workingDirectory]
    set res
} {abc.link}

test fCmd-28.18 {file link: glob -type d} {linkDirectory} {
    cd [temporaryDirectory]
    set res [lsort [glob -dir [pwd] -type d -tails abc*]]
    cd [workingDirectory]
    set res
} [lsort [list abc.link abc.dir abc2.dir]]

test fCmd-29.1 {weird memory corruption fault} {
    catch {set res [open [file join ~a_totally_bogus_user_id/foo bar]]}
} 1

cd [temporaryDirectory]
file delete -force abc.link
cd [workingDirectory]

removeFile abc2.file
removeFile abc.file
removeDirectory abc2.dir
removeDirectory abc.dir

d2159 13
@


1.1
log
@Initial revision
@
text
@d8 1
d13 1
a13 1
# RCS: @@(#) $Id: fCmd.test,v 1.11 1999/01/26 03:53:29 jingham Exp $
d16 4
a19 3
if {[string compare test [info procs test]] == 1} then {source defs}

set platform [testgetplatform]
d21 4
a24 3
if {$user == "root"} {
    puts "Skipping fCmd tests.  They depend on not being able to write to"
    puts "certain directories.  It would be too dangerous to run them as root."
d28 2
d33 1
d37 12
d92 2
a93 2
		openup $file
		file delete -force -- $file
d106 2
a107 10
set testConfig(NT) 0
set testConfig(95) 0

switch $tcl_platform(os) {
    "Windows NT" {set testConfig(NT) 1}
    "Windows 95" {set testConfig(95) 1}
}

set testConfig(fileSharing) 0
set testConfig(notFileSharing) 1
d113 2
a114 2
    	set testConfig(fileSharing) 1
    	set testConfig(notFileSharing) 0
d119 1
a119 1
set testConfig(xdev) 0
d126 1
a126 1
	    set testConfig(xdev) 1
d144 1
a144 1
test fCmd-1.1 {TclFileRenameCmd} {
d151 1
a151 1
test fCmd-2.1 {TclFileCopyCmd} {
d158 1
a158 1
test fCmd-3.1 {FileCopyRename: FileForceOption fails} {
d161 1
a161 1
test fCmd-3.2 {FileCopyRename: not enough args} {
d164 4
a167 4
test fCmd-3.3 {FileCopyRename: Tcl_TranslateFileName fails} {
    list [catch {file rename xyz ~nonexistantuser} msg] $msg
} {1 {user "nonexistantuser" doesn't exist}}
test fCmd-3.4 {FileCopyRename: Tcl_TranslateFileName passes} {
d171 1
a171 1
test fCmd-3.5 {FileCopyRename: target doesn't exist: stat(target) != 0} {
d175 2
a176 1
test fCmd-3.6 {FileCopyRename: target tf3 is not a directory: !S_ISDIR(target)} {
d181 1
a181 1
test fCmd-3.7 {FileCopyRename: target exists & is directory} {
d188 1
a188 1
test fCmd-3.8 {FileCopyRename: too many arguments: argc - i > 2} {
d192 1
a192 1
test fCmd-3.9 {FileCopyRename: too many arguments: argc - i > 2} {
d196 1
a196 1
test fCmd-3.10 {FileCopyRename: just 2 arguments} {
d202 1
a202 1
test fCmd-3.11 {FileCopyRename: just 2 arguments} {
d208 1
a208 1
test fCmd-3.12 {FileCopyRename: move each source: 1 source} {
d215 1
a215 1
test fCmd-3.13 {FileCopyRename: move each source: multiple sources} {
d226 1
a226 1
test fCmd-3.14 {FileCopyRename: FileBasename fails} {
d229 3
a231 3
    list [catch {file rename ~nonexistantuser td1} msg] $msg
} {1 {user "nonexistantuser" doesn't exist}}
test fCmd-3.15 {FileCopyRename: source[0] == '\0'} {unixOrPc} {
d236 1
a236 1
test fCmd-3.16 {FileCopyRename: break on first error} {
d247 1
a247 1
test fCmd-4.1 {TclFileMakeDirsCmd: make each dir: 1 dir} {
d252 1
a252 1
test fCmd-4.2 {TclFileMakeDirsCmd: make each dir: multiple dirs} {
d257 1
a257 1
test fCmd-4.3 {TclFileMakeDirsCmd: stops on first error} {
d263 1
a263 1
test fCmd-4.4 {TclFileMakeDirsCmd: Tcl_TranslateFileName fails} {
d265 4
a268 3
    list [catch {file mkdir ~nonexistantuser} msg] $msg
} {1 {user "nonexistantuser" doesn't exist}}
test fCmd-4.5 {TclFileMakeDirsCmd: Tcl_SplitPath returns 0: *name == '\0'} {
d272 1
a272 1
test fCmd-4.6 {TclFileMakeDirsCmd: one level deep} {
d277 1
a277 1
test fCmd-4.7 {TclFileMakeDirsCmd: multi levels deep} {
d282 1
a282 1
test fCmd-4.8 {TclFileMakeDirsCmd: already exist: lstat(target) == 0} {
d289 1
a289 1
test fCmd-4.9 {TclFileMakeDirsCmd: exists, not dir} {
d294 1
a294 1
test fCmd-4.10 {TclFileMakeDirsCmd: exists, is dir} {
d301 2
a302 1
test fCmd-4.11 {TclFileMakeDirsCmd: doesn't exist: errno != ENOENT} {unixOnly} {
d314 1
a314 1
test fCmd-4.13 {TclFileMakeDirsCmd: doesn't exist: errno == ENOENT} {
d320 2
a321 1
test fCmd-4.14 {TclFileMakeDirsCmd: TclpCreateDirectory fails} {unixOnly} {
d333 1
a333 1
test fCmd-4.16 {TclFileMakeDirsCmd: TclpCreateDirectory succeeds} {
d339 1
a339 1
test fCmd-5.1 {TclFileDeleteCmd: FileForceOption fails} {
d342 1
a342 1
test fCmd-5.2 {TclFileDeleteCmd: not enough args} {
d345 1
a345 1
test fCmd-5.3 {TclFileDeleteCmd: 1 file} {
d353 1
a353 1
test fCmd-5.4 {TclFileDeleteCmd: multiple files} {
d362 1
a362 1
test fCmd-5.5 {TclFileDeleteCmd: stop at first error} {unixOrPc} {
d370 4
a373 4
test fCmd-5.6 {TclFileDeleteCmd: Tcl_TranslateFileName fails} {
    list [catch {file delete ~nonexistantuser} msg] $msg
} {1 {user "nonexistantuser" doesn't exist}}
test fCmd-5.7 {TclFileDeleteCmd: Tcl_TranslateFileName succeeds} {
d378 1
a378 1
test fCmd-5.8 {TclFileDeleteCmd: file doesn't exist: lstat(name) != 0} {
d384 1
a384 1
test fCmd-5.9 {TclFileDeleteCmd: is directory} {
d390 1
a390 1
test fCmd-5.10 {TclFileDeleteCmd: TclpRemoveDirectory fails} {
d396 1
a396 1
test fCmd-6.1 {CopyRenameOneFile: bad source} {
d399 1
a399 1
test fCmd-6.2 {CopyRenameOneFile: bad target} {
d402 1
a402 1
test fCmd-6.3 {CopyRenameOneFile: lstat(source) != 0} {
d406 1
a406 1
test fCmd-6.4 {CopyRenameOneFile: lstat(source) == 0} {
d412 1
a412 1
test fCmd-6.5 {CopyRenameOneFile: lstat(target) != 0} {
d418 1
a418 1
test fCmd-6.6 {CopyRenameOneFile: errno != ENOENT} {unixOnly} {
d437 1
a437 1
test fCmd-6.9 {CopyRenameOneFile: errno == ENOENT} {unixOnly} {
d443 1
a443 1
test fCmd-6.10 {CopyRenameOneFile: lstat(target) == 0} {
d449 1
a449 1
test fCmd-6.11 {CopyRenameOneFile: force == 0} {
d455 1
a455 1
test fCmd-6.12 {CopyRenameOneFile: force != 0} {
d462 1
a462 1
test fCmd-6.13 {CopyRenameOneFile: source is dir, target is file} {
d469 1
a469 1
test fCmd-6.14 {CopyRenameOneFile: source is file, target is dir} {
d475 1
a475 1
test fCmd-6.15 {CopyRenameOneFile: TclpRenameFile succeeds} {
d483 1
a483 1
test fCmd-6.16 {CopyRenameOneFile: TclpCopyRenameOneFile fails} {
a489 3
test fCmd-6.17 {CopyRenameOneFile: errno == EINVAL} {!$testConfig(win32s) || ($root == "C:/")} {
    # Don't run this test under Win32s on a drive mounted from an NT 
    # machine; it causes the NT machine to die.
d491 1
d495 1
a495 1
test fCmd-6.18 {CopyRenameOneFile: errno != EXDEV} {
d502 1
a502 1
test fCmd-6.19 {CopyRenameOneFile: errno == EXDEV} {unixOnly} {
d519 2
a520 1
test fCmd-6.21 {CopyRenameOneFile: copy/rename: S_ISDIR(source)} {unixOnly} {
d526 2
a527 1
test fCmd-6.22 {CopyRenameOneFile: copy/rename: !S_ISDIR(source)} {unixOnly} {
d533 2
a534 1
test fCmd-6.23 {CopyRenameOneFile: TclpCopyDirectory failed} {unixOnly xdev} {
d542 2
a543 1
test fCmd-6.24 {CopyRenameOneFile: error uses original name} {unixOnly} {
d552 2
a553 1
test fCmd-6.25 {CopyRenameOneFile: error uses original name} {unixOnly} {
d563 2
a564 1
test fCmd-6.26 {CopyRenameOneFile: doesn't use original name} {unixOnly} {
d573 2
a574 1
test fCmd-6.27 {CopyRenameOneFile: TclpCopyDirectory failed} {unixOnly xdev} {
d581 2
a582 1
test fCmd-6.28 {CopyRenameOneFile: TclpCopyDirectory failed} {unixOnly xdev} {
d590 2
a591 1
test fCmd-6.29 {CopyRenameOneFile: TclpCopyDirectory passed} {unixOnly xdev} {
d597 2
a598 1
test fCmd-6.30 {CopyRenameOneFile: TclpRemoveDirectory failed} {unixOnly} {
d602 2
a603 3
    set msg [list [catch {file rename foo/bar /tmp} msg] $msg]
    set a1 {1 {can't unlink "foo/bar": permission denied}}
    set result [expr {$msg == $a1}]
d607 4
a610 3
    set result
} {1}
test fCmd-6.31 {CopyRenameOneFile: TclpDeleteFile passed} {unixOnly xdev} {
d617 1
a617 1
test fCmd-6.32 {CopyRenameOneFile: copy} {
d623 1
a623 1
test fCmd-7.1 {FileForceOption: none} {
d628 1
a628 1
test fCmd-7.2 {FileForceOption: -force} {
d633 1
a633 1
test fCmd-7.3 {FileForceOption: --} {
d637 1
a637 1
test fCmd-7.4 {FileForceOption: bad option} {
d643 1
a643 1
test fCmd-7.5 {FileForceOption: multiple times through loop} {
d650 3
a652 1
test fCmd-8.1 {FileBasename: basename of ~user: argc == 1 && *path == ~} {unixOnly} {
d659 4
d664 1
a664 1
test fCmd-9.1 {file rename: comprehensive: EACCES} {unixOnly} {
d674 1
a674 1
test fCmd-9.2 {file rename: comprehensive: source doesn't exist} {
d678 1
a678 1
test fCmd-9.3 {file rename: comprehensive: file to new name} {
d687 1
a687 1
test fCmd-9.4 {file rename: comprehensive: dir to new name} {unixOrPc} {
d695 1
a695 1
test fCmd-9.5 {file rename: comprehensive: file to self} {
d704 1
a704 1
test fCmd-9.6 {file rename: comprehensive: dir to self} {unixOrPc} {
d713 1
a713 1
test fCmd-9.7 {file rename: comprehensive: file to existing file} {
d736 1
a736 1
test fCmd-9.8 {file rename: comprehensive: dir to empty dir} {
d774 1
a774 1
test fCmd-9.9 {file rename: comprehensive: dir to non-empty dir} {
d792 1
a792 1
test fCmd-9.10 {file rename: comprehensive: file to new name and dir} {
d803 1
a803 1
test fCmd-9.11 {file rename: comprehensive: dir to new name and dir} {
d821 1
a821 1
test fCmd-9.12 {file rename: comprehensive: target exists} {
d836 1
a836 1
test fCmd-9.13 {file rename: comprehensive: can't overwrite target} {
d841 1
a841 1
test fCmd-9.14 {file rename: comprehensive: dir into self} {
d846 2
a847 1
test fCmd-9.15 {file rename: comprehensive: source and target incompatible} {
d853 2
a854 1
test fCmd-9.16 {file rename: comprehensive: source and target incompatible} {
d861 1
a861 1
test fCmd-10.1 {file copy: comprehensive: source doesn't exist} {
d865 1
a865 1
test fCmd-10.2 {file copy: comprehensive: file to new name} {
d874 1
a874 1
test fCmd-10.3 {file copy: comprehensive: dir to new name} {unixOrPc} {
d889 1
a889 1
test fCmd-10.4 {file copy: comprehensive: file to existing file} {
d912 1
a912 1
test fCmd-10.5 {file copy: comprehensive: dir to empty dir} {
d937 2
a938 1
test fCmd-10.6 {file copy: comprehensive: dir to non-empty dir} {unixOrPc} {
d949 1
a949 1
test fCmd-10.7 {file rename: comprehensive: file to new name and dir} {
d960 2
a961 1
test fCmd-10.8 {file rename: comprehensive: dir to new name and dir} {unixOrPc} {
d972 2
a973 1
test fCmd-10.9 {file copy: comprehensive: source and target incompatible} {
d979 2
a980 1
test fCmd-10.10 {file copy: comprehensive: source and target incompatible} {
d990 1
a990 1
test fCmd-11.1 {TclFileRenameCmd: -- option } {
d999 1
a999 1
test fCmd-11.2 {TclFileRenameCmd: bad option } {
d1012 1
a1012 1
test fCmd-11.4 {TclFileRenameCmd: target filename translation failing} {
d1021 1
a1021 1
test fCmd-11.5 {TclFileRenameCmd: more than one source and target is not a directory} {
d1031 1
a1031 1
test fCmd-11.6 {TclFileRenameCmd: : single file into directory  } {
d1041 1
a1041 1
test fCmd-11.7 {TclFileRenameCmd: : multiple files into directory  } {
d1056 1
a1056 1
test fCmd-11.8 {TclFileRenameCmd: error renaming file to directory } {
d1072 1
a1072 1
test fCmd-12.1 {renamefile: source filename translation failing} {
d1081 1
a1081 1
test fCmd-12.2 {renamefile: src filename translation failing} {
d1093 1
a1093 1
test fCmd-12.3 {renamefile: stat failing on source} {
d1099 1
a1099 1
test fCmd-12.4 {renamefile: error renaming file to directory } {
d1112 1
a1112 1
test fCmd-12.5 {renamefile: error renaming directory to file } {
d1126 1
a1126 1
test fCmd-12.6 {renamefile: TclRenameFile succeeding } {
d1135 1
a1135 1
test fCmd-12.7 {renamefile: renaming directory into offspring} {
d1144 1
a1144 1
test fCmd-12.8 {renamefile: generic error } {unixOnly} {
d1156 1
a1156 1
test fCmd-12.9 {renamefile: moving a file across volumes } {unixOnly} {
d1165 2
a1166 1
test fCmd-12.10 {renamefile: moving a directory across volumes } {unixOnly} {
d1179 1
a1179 1
test fCmd-13.1 {TclCopyFilesCmd: -force option } {
d1188 1
a1188 1
test fCmd-13.2 {TclCopyFilesCmd: -- option } {
d1197 1
a1197 1
test fCmd-13.3 {TclCopyFilesCmd: bad option } {
d1206 1
a1206 1
test fCmd-13.4 {TclCopyFilesCmd: bad \# args} {
d1219 1
a1219 1
test fCmd-13.6 {TclCopyFilesCmd: more than one source and target is not a directory} {
d1229 1
a1229 1
test fCmd-13.7 {TclCopyFilesCmd: : single file into directory  } {
d1239 1
a1239 1
test fCmd-13.8 {TclCopyFilesCmd: : multiple files into directory  } {
d1255 1
a1255 1
test fCmd-13.9 {TclCopyFilesCmd: error copying file to directory } {
d1271 1
a1271 1
test fCmd-14.1 {copyfile: source filename translation failing} {
d1280 1
a1280 1
test fCmd-14.2 {copyfile: dst filename translation failing} {
d1293 1
a1293 1
test fCmd-14.3 {copyfile: stat failing on source} {
d1299 1
a1299 1
test fCmd-14.4 {copyfile: error copying file to directory } {
d1313 1
a1313 1
 test fCmd-14.5 {copyfile: error copying directory to file } {
d1327 1
a1327 1
test fCmd-14.6 {copyfile: copy file succeeding } {
d1336 1
a1336 1
test fCmd-14.7 {copyfile: copy directory succeeding } {
d1346 1
a1346 1
test fCmd-14.8 {copyfile: copy directory failing } {unixOnly} {
d1360 1
a1360 1
test fCmd-15.1 {TclMakeDirsCmd: target filename translation failing} {
d1372 1
a1372 1
test fCmd-15.2 {TclMakeDirsCmd - one directory } {
d1380 1
a1380 1
test fCmd-15.3 {TclMakeDirsCmd: - two directories } {
d1388 1
a1388 1
test fCmd-15.4 {TclMakeDirsCmd - stat failing } {unixOnly} {
d1399 2
a1400 1
test fCmd-15.5 {TclMakeDirsCmd: - making a directory several levels deep } {
d1409 1
a1409 1
test fCmd-15.6 {TclMakeDirsCmd: - trying to overwrite a file } {
d1420 1
a1420 1
test fCmd-15.7 {TclMakeDirsCmd - making several directories } {
d1428 1
a1428 1
test fCmd-15.8 {TclFileMakeDirsCmd: trying to create an existing dir} {
d1438 1
a1438 1
test fCmd-16.1 { test the -- argument } {
d1445 1
a1445 1
test fCmd-16.2 { test the -force and -- arguments } {
d1452 1
a1452 1
test fCmd-16.3 { test bad option } {
d1460 1
a1460 1
test fCmd-16.4 { test not enough args } {
d1464 1
a1464 1
test fCmd-16.5 { test not enough args with options } {
d1468 1
a1468 1
test fCmd-16.6 {delete: source filename translation failing} {
d1477 1
a1477 1
test fCmd-16.7 {remove a non-empty directory without -force } {
d1486 1
a1486 1
test fCmd-16.8 {remove a normal file } {
d1495 1
a1495 1
test fCmd-16.9 {error while deleting file } {unixOnly} {
d1511 1
a1511 1
test fCmd-16.10 {deleting multiple files } {
d1519 1
a1519 1
test fCmd-16.11 { TclFileDeleteCmd: removing a nonexistant file} {
d1526 1
a1526 1
 test fCmd-17.1 {mkdir stat failing on target but not ENOENT } {unixOnly} {
d1536 1
a1536 1
test fCmd-17.2 {mkdir several levels deep - relative } {
d1544 1
a1544 1
test fCmd-17.3 {mkdir several levels deep - absolute } {
d1557 2
a1558 1
test fCmd-18.1 {TclFileRenameCmd: rename (first form) in the same directory} {
d1578 1
a1578 1
test fCmd-18.2 {TclFileRenameCmd: single dir to nonexistant } {
d1587 1
a1587 1
test fCmd-18.3 {TclFileRenameCmd: mixed dirs and files into directory  } {
d1600 1
a1600 1
test fCmd-18.4 {TclFileRenameCmd: attempt to replace non-dir with dir } {
d1612 1
a1612 1
test fCmd-18.5 {TclFileRenameCmd: attempt to replace dir with non-dir } {
d1627 1
a1627 1
test fCmd-18.6 {TclFileRenameCmd: rename a file to itself} {macOrUnix}  {
d1636 2
a1637 1
test fCmd-18.7 {TclFileRenameCmd: rename dir on top of another empty dir w/o -force} {
d1646 2
a1647 1
test fCmd-18.8 {TclFileRenameCmd: rename dir on top of another empty dir w/ -force} {
d1656 2
a1657 1
test fCmd-18.9 {TclFileRenameCmd: rename dir on top of a non-empty dir w/o -force} {
d1666 2
a1667 1
test fCmd-18.10 {TclFileRenameCmd: rename dir on top of a non-empty dir w/ -force} {
d1676 1
a1676 1
test fCmd-18.11 {TclFileRenameCmd: rename a non-existant file} {
d1682 2
a1683 1
test fCmd-18.12 {TclFileRenameCmd : rename a symbolic link to file} {unixOnly} {
d1695 2
a1696 1
test fCmd-18.13 {TclFileRenameCmd : rename a symbolic link to dir} {unixOnly} {
d1708 2
a1709 1
test fCmd-18.14 {TclFileRenameCmd : rename a path with sym link} {unixOnly} {
d1725 2
a1726 1
test fCmd-18.15 {TclFileRenameCmd : rename a file to a symlink dir} {unixOnly} {
d1739 1
a1739 1
test fCmd-18.16 {TclFileRenameCmd : rename a dangling symlink} {unixOnly} {
d1755 1
a1755 1
test fCmd-19.1 { remove empty directory } {
d1762 1
a1762 1
test fCmd-19.2 { rmdir error besides EEXIST} {unixOnly} {
d1773 1
a1773 1
test fCmd-19.3 { recursive remove } {
d1791 2
a1792 1
test fCmd-20.1 {TraverseUnixTree : failure opening a subdirectory directory } {unixOnly} {
d1807 1
a1807 1
test fCmd-21.1 {copy : single file to nonexistant } {
d1816 1
a1816 1
test fCmd-21.2 {copy : single dir to nonexistant } {
d1825 1
a1825 1
test fCmd-21.3 {copy : single file into directory  } {
d1835 2
a1836 1
test fCmd-21.4 {copy : more than one source and target is not a directory} {
d1846 1
a1846 1
test fCmd-21.5 {copy : multiple files into directory  } {
d1861 2
a1862 1
test fCmd-21.6 {copy : mixed dirs and files into directory  } {notFileSharing} {
d1875 1
a1875 1
test fCmd-21.7 {TclCopyFilesCmd : copy a dangling link } {unixOnly} {
d1885 1
a1885 1
test fCmd-21.8 {TclCopyFilesCmd : copy a link } {unixOnly} {
d1897 1
a1897 1
test fCmd-21.9 {TclCopyFilesCmd : copy dir with a link in it } {unixOnly} {
d1906 2
a1907 1
test fCmd-21.10 {TclFileCopyCmd: copy dir on top of another empty dir w/o -force} {
d1916 1
a1916 1
test fCmd-21.11 {TclFileCopyCmd: copy dir on top of a dir w/o -force} {
d1925 2
a1926 1
test fCmd-21.12 {TclFileCopyCmd: copy dir on top of a non-empty dir w/ -force} {
d1938 1
a1938 1
test fCmd-22.1 { TclpRenameFile : rename and overwrite in a single dir } {
d1950 1
a1950 1
test fCmd-22.2 { TclpRenameFile : attempt to overwrite itself } {macOrUnix} {
d1959 1
a1959 1
test fCmd-22.3 { TclpRenameFile : rename dir to existing dir } {
d1968 1
a1968 1
test fCmd-22.4 { TclpRenameFile : rename dir to dir several levels deep } {
d1981 1
a1981 1
test fCmd-22.5 { TclMacCopyFile : copy and overwrite in a single dir } {
d2003 1
a2003 1
test fCmd-23.1 { TclMacRmdir : trying to remove a nonempty directory } {
d2017 1
a2017 1
test fCmd-24.1 { TclMacDeleteFile : deleting a normal file } {
d2029 2
a2030 1
test fCmd-25.1 { TclMacCopyDirectory : copying a normal directory} {notFileSharing} {
d2040 2
a2041 1
test fCmd-25.2 { TclMacCopyDirectory : copying a short path normal directory} {notFileSharing} {
d2051 2
a2052 1
test fCmd-25.3 { TclMacCopyDirectory : copying dirs between different dirs} {notFileSharing} {
d2067 1
a2067 1
test fCmd-26.1 { TclDeleteFilesCmd : delete symlink} {unixOnly} {
d2082 1
a2082 1
test fCmd-26.2 { TclDeleteFilesCmd : delete dir with symlink} {unixOnly} {
d2098 1
a2098 1
test fCmd-26.3 { TclDeleteFilesCmd : delete dangling symlink} {unixOnly} {
a2112 3
test fCmd-27.1 {TclFileAttrsCmd - wrong # args} {
    list [catch {file attributes a b c d} msg] $msg
} {1 {wrong # args: must be "file attributes name ?option? ?value? ?option value? ..."}}
d2115 2
a2116 2
    list [catch {file attributes ~_bad_user} msg] $msg [testsetplatform $platform]
} {1 {user "_bad_user" doesn't exist} {}}
d2129 8
a2136 7
set testConfig(tclGroup) 0
if {($tcl_platform(platform) == "macintosh") \
	|| ($tcl_platform(platform) == "windows")} {
    set testConfig(tclGroup) 1
} elseif {[catch {exec {groups}} groupList] == 0} {
    if {[lsearch $groupList tcl] != -1} {
	set testConfig(tclGroup) 1
d2138 2
d2142 1
a2142 1
test fCmd-27.5 {TclFileAttrsCmd - setting one option} {tclGroup} {
d2148 1
a2148 1
test fCmd-27.6 {TclFileAttrsCmd - setting more than one option} {tclGroup} {
d2155 1
d2157 15
@


1.1.1.1
log
@import dejagnu-1999-11-08 snapshot
@
text
@@


1.1.1.2
log
@Tcl 8.3 upgrade
@
text
@a7 1
# Copyright (c) 1999 by Scriptics Corporation.
d12 1
a12 1
# RCS: @@(#) $Id: fCmd.test,v 1.6.8.2 2000/09/15 16:56:25 spolk Exp $
d15 3
a17 4
if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import -force ::tcltest::*
}
d19 3
a21 4
if {[string compare testgetplatform [info commands testgetplatform]] != 0} {
    puts "This application hasn't been compiled with the \"testgetplatform\""
    puts "command, therefore I am skipping all of these tests."
    ::tcltest::cleanupTests
a24 2
set platform [testgetplatform]

a27 1
    ::tcltest::cleanupTests
a30 12
# Several tests require need to match results against the unix username
set user {}
if {$tcl_platform(platform) == "unix"} {
    catch {set user [exec whoami]}
    if {$user == ""} {
	catch {regexp {^[^(]*\(([^)]*)\)} [exec id] dummy user}
    }
    if {$user == ""} {
	set user "root"
    }
}

d74 2
a75 2
		catch {openup $file}
		catch {file delete -force -- $file}
d88 10
a97 2
set ::tcltest::testConstraints(fileSharing) 0
set ::tcltest::testConstraints(notFileSharing) 1
d103 2
a104 2
    	set ::tcltest::testConstraints(fileSharing) 1
    	set ::tcltest::testConstraints(notFileSharing) 0
d109 1
a109 1
set ::tcltest::testConstraints(xdev) 0
d116 1
a116 1
	    set ::tcltest::testConstraints(xdev) 1
d134 1
a134 1
test fCmd-1.1 {TclFileRenameCmd} {notRoot} {
d141 1
a141 1
test fCmd-2.1 {TclFileCopyCmd} {notRoot} {
d148 1
a148 1
test fCmd-3.1 {FileCopyRename: FileForceOption fails} {notRoot} {
d151 1
a151 1
test fCmd-3.2 {FileCopyRename: not enough args} {notRoot} {
d154 4
a157 4
test fCmd-3.3 {FileCopyRename: Tcl_TranslateFileName fails} {notRoot} {
    list [catch {file rename xyz ~_totally_bogus_user} msg] $msg
} {1 {user "_totally_bogus_user" doesn't exist}}
test fCmd-3.4 {FileCopyRename: Tcl_TranslateFileName passes} {notRoot} {
d161 1
a161 1
test fCmd-3.5 {FileCopyRename: target doesn't exist: stat(target) != 0} {notRoot} {
d165 1
a165 2
test fCmd-3.6 {FileCopyRename: target tf3 is not a dir: !S_ISDIR(target)} \
	{notRoot} {
d170 1
a170 1
test fCmd-3.7 {FileCopyRename: target exists & is directory} {notRoot} {
d177 1
a177 1
test fCmd-3.8 {FileCopyRename: too many arguments: argc - i > 2} {notRoot} {
d181 1
a181 1
test fCmd-3.9 {FileCopyRename: too many arguments: argc - i > 2} {notRoot} {
d185 1
a185 1
test fCmd-3.10 {FileCopyRename: just 2 arguments} {notRoot} {
d191 1
a191 1
test fCmd-3.11 {FileCopyRename: just 2 arguments} {notRoot} {
d197 1
a197 1
test fCmd-3.12 {FileCopyRename: move each source: 1 source} {notRoot} {
d204 1
a204 1
test fCmd-3.13 {FileCopyRename: move each source: multiple sources} {notRoot} {
d215 1
a215 1
test fCmd-3.14 {FileCopyRename: FileBasename fails} {notRoot} {
d218 3
a220 3
    list [catch {file rename ~_totally_bogus_user td1} msg] $msg
} {1 {user "_totally_bogus_user" doesn't exist}}
test fCmd-3.15 {FileCopyRename: source[0] == '\0'} {notRoot unixOrPc} {
d225 1
a225 1
test fCmd-3.16 {FileCopyRename: break on first error} {notRoot} {
d236 1
a236 1
test fCmd-4.1 {TclFileMakeDirsCmd: make each dir: 1 dir} {notRoot} {
d241 1
a241 1
test fCmd-4.2 {TclFileMakeDirsCmd: make each dir: multiple dirs} {notRoot} {
d246 1
a246 1
test fCmd-4.3 {TclFileMakeDirsCmd: stops on first error} {notRoot} {
d252 1
a252 1
test fCmd-4.4 {TclFileMakeDirsCmd: Tcl_TranslateFileName fails} {notRoot} {
d254 3
a256 4
    list [catch {file mkdir ~_totally_bogus_user} msg] $msg
} {1 {user "_totally_bogus_user" doesn't exist}}
test fCmd-4.5 {TclFileMakeDirsCmd: Tcl_SplitPath returns 0: *name == '\0'} \
	{notRoot} {
d260 1
a260 1
test fCmd-4.6 {TclFileMakeDirsCmd: one level deep} {notRoot} {
d265 1
a265 1
test fCmd-4.7 {TclFileMakeDirsCmd: multi levels deep} {notRoot} {
d270 1
a270 1
test fCmd-4.8 {TclFileMakeDirsCmd: already exist: lstat(target) == 0} {notRoot} {
d277 1
a277 1
test fCmd-4.9 {TclFileMakeDirsCmd: exists, not dir} {notRoot} {
d282 1
a282 1
test fCmd-4.10 {TclFileMakeDirsCmd: exists, is dir} {notRoot} {
d289 1
a289 2
test fCmd-4.11 {TclFileMakeDirsCmd: doesn't exist: errno != ENOENT} \
	{unixOnly notRoot} {
d301 1
a301 1
test fCmd-4.13 {TclFileMakeDirsCmd: doesn't exist: errno == ENOENT} {notRoot} {
d307 1
a307 2
test fCmd-4.14 {TclFileMakeDirsCmd: TclpCreateDirectory fails} \
	{unixOnly notRoot} {
d319 1
a319 1
test fCmd-4.16 {TclFileMakeDirsCmd: TclpCreateDirectory succeeds} {notRoot} {
d325 1
a325 1
test fCmd-5.1 {TclFileDeleteCmd: FileForceOption fails} {notRoot} {
d328 1
a328 1
test fCmd-5.2 {TclFileDeleteCmd: not enough args} {notRoot} {
d331 1
a331 1
test fCmd-5.3 {TclFileDeleteCmd: 1 file} {notRoot} {
d339 1
a339 1
test fCmd-5.4 {TclFileDeleteCmd: multiple files} {notRoot} {
d348 1
a348 1
test fCmd-5.5 {TclFileDeleteCmd: stop at first error} {notRoot unixOrPc} {
d356 4
a359 4
test fCmd-5.6 {TclFileDeleteCmd: Tcl_TranslateFileName fails} {notRoot} {
    list [catch {file delete ~_totally_bogus_user} msg] $msg
} {1 {user "_totally_bogus_user" doesn't exist}}
test fCmd-5.7 {TclFileDeleteCmd: Tcl_TranslateFileName succeeds} {notRoot} {
d364 1
a364 1
test fCmd-5.8 {TclFileDeleteCmd: file doesn't exist: lstat(name) != 0} {notRoot} {
d370 1
a370 1
test fCmd-5.9 {TclFileDeleteCmd: is directory} {notRoot} {
d376 1
a376 1
test fCmd-5.10 {TclFileDeleteCmd: TclpRemoveDirectory fails} {notRoot} {
d382 1
a382 1
test fCmd-6.1 {CopyRenameOneFile: bad source} {notRoot} {
d385 1
a385 1
test fCmd-6.2 {CopyRenameOneFile: bad target} {notRoot} {
d388 1
a388 1
test fCmd-6.3 {CopyRenameOneFile: lstat(source) != 0} {notRoot} {
d392 1
a392 1
test fCmd-6.4 {CopyRenameOneFile: lstat(source) == 0} {notRoot} {
d398 1
a398 1
test fCmd-6.5 {CopyRenameOneFile: lstat(target) != 0} {notRoot} {
d404 1
a404 1
test fCmd-6.6 {CopyRenameOneFile: errno != ENOENT} {unixOnly notRoot} {
d423 1
a423 1
test fCmd-6.9 {CopyRenameOneFile: errno == ENOENT} {unixOnly notRoot} {
d429 1
a429 1
test fCmd-6.10 {CopyRenameOneFile: lstat(target) == 0} {notRoot} {
d435 1
a435 1
test fCmd-6.11 {CopyRenameOneFile: force == 0} {notRoot} {
d441 1
a441 1
test fCmd-6.12 {CopyRenameOneFile: force != 0} {notRoot} {
d448 1
a448 1
test fCmd-6.13 {CopyRenameOneFile: source is dir, target is file} {notRoot} {
d455 1
a455 1
test fCmd-6.14 {CopyRenameOneFile: source is file, target is dir} {notRoot} {
d461 1
a461 1
test fCmd-6.15 {CopyRenameOneFile: TclpRenameFile succeeds} {notRoot} {
d469 1
a469 1
test fCmd-6.16 {CopyRenameOneFile: TclpCopyRenameOneFile fails} {notRoot} {
d476 3
a479 1
test fCmd-6.17 {CopyRenameOneFile: errno == EINVAL} {notRoot} {
d483 1
a483 1
test fCmd-6.18 {CopyRenameOneFile: errno != EXDEV} {notRoot} {
d490 1
a490 1
test fCmd-6.19 {CopyRenameOneFile: errno == EXDEV} {unixOnly notRoot} {
d507 1
a507 2
test fCmd-6.21 {CopyRenameOneFile: copy/rename: S_ISDIR(source)} \
	{unixOnly notRoot} {
d513 1
a513 2
test fCmd-6.22 {CopyRenameOneFile: copy/rename: !S_ISDIR(source)} \
	{unixOnly notRoot} {
d519 1
a519 2
test fCmd-6.23 {CopyRenameOneFile: TclpCopyDirectory failed} \
	{unixOnly notRoot xdev} {
d527 1
a527 2
test fCmd-6.24 {CopyRenameOneFile: error uses original name} \
	{unixOnly notRoot} {
d536 1
a536 2
test fCmd-6.25 {CopyRenameOneFile: error uses original name} \
	{unixOnly notRoot} {
d546 1
a546 2
test fCmd-6.26 {CopyRenameOneFile: doesn't use original name} \
	{unixOnly notRoot} {
d555 1
a555 2
test fCmd-6.27 {CopyRenameOneFile: TclpCopyDirectory failed} \
	{unixOnly notRoot xdev} {
d562 1
a562 2
test fCmd-6.28 {CopyRenameOneFile: TclpCopyDirectory failed} \
	{unixOnly notRoot xdev} {
d570 1
a570 2
test fCmd-6.29 {CopyRenameOneFile: TclpCopyDirectory passed} \
	{unixOnly notRoot xdev} {
d576 1
a576 2
test fCmd-6.30 {CopyRenameOneFile: TclpRemoveDirectory failed} \
	{unixOnly notRoot} {
d580 3
a582 2
    set catchResult [catch {file rename foo/bar /tmp} msg]
    set msg [lindex [split $msg :] end]
d586 3
a588 4
    list $catchResult $msg
} {1 { permission denied}}
test fCmd-6.31 {CopyRenameOneFile: TclpDeleteFile passed} \
	{unixOnly notRoot xdev} {
d595 1
a595 1
test fCmd-6.32 {CopyRenameOneFile: copy} {notRoot} {
d601 1
a601 1
test fCmd-7.1 {FileForceOption: none} {notRoot} {
d606 1
a606 1
test fCmd-7.2 {FileForceOption: -force} {notRoot} {
d611 1
a611 1
test fCmd-7.3 {FileForceOption: --} {notRoot} {
d615 1
a615 1
test fCmd-7.4 {FileForceOption: bad option} {notRoot} {
d621 1
a621 1
test fCmd-7.5 {FileForceOption: multiple times through loop} {notRoot} {
d628 1
a628 3
test fCmd-8.1 {FileBasename: basename of ~user: argc == 1 && *path == ~} \
	{unixOnly notRoot knownBug} {
    # Labelled knownBug because it is dangerous [Bug: 3881]
a634 4
test fCmd-8.2 {FileBasename: basename of ~user: argc == 1 && *path == ~} \
	{unixOnly notRoot} {
    file tail ~$user
} "$user"
d636 1
a636 1
test fCmd-9.1 {file rename: comprehensive: EACCES} {unixOnly notRoot} {
d646 1
a646 1
test fCmd-9.2 {file rename: comprehensive: source doesn't exist} {notRoot} {
d650 1
a650 1
test fCmd-9.3 {file rename: comprehensive: file to new name} {notRoot} {
d659 1
a659 1
test fCmd-9.4 {file rename: comprehensive: dir to new name} {unixOrPc notRoot} {
d667 1
a667 1
test fCmd-9.5 {file rename: comprehensive: file to self} {notRoot} {
d676 1
a676 1
test fCmd-9.6 {file rename: comprehensive: dir to self} {notRoot unixOrPc} {
d685 1
a685 1
test fCmd-9.7 {file rename: comprehensive: file to existing file} {notRoot} {
d708 1
a708 1
test fCmd-9.8 {file rename: comprehensive: dir to empty dir} {notRoot} {
d746 1
a746 1
test fCmd-9.9 {file rename: comprehensive: dir to non-empty dir} {notRoot} {
d764 1
a764 1
test fCmd-9.10 {file rename: comprehensive: file to new name and dir} {notRoot} {
d775 1
a775 1
test fCmd-9.11 {file rename: comprehensive: dir to new name and dir} {notRoot} {
d793 1
a793 1
test fCmd-9.12 {file rename: comprehensive: target exists} {notRoot} {
d808 1
a808 1
test fCmd-9.13 {file rename: comprehensive: can't overwrite target} {notRoot} {
d813 1
a813 1
test fCmd-9.14 {file rename: comprehensive: dir into self} {notRoot} {
d818 1
a818 2
test fCmd-9.15 {file rename: comprehensive: source and target incompatible} \
	{notRoot} {
d824 1
a824 2
test fCmd-9.16 {file rename: comprehensive: source and target incompatible} \
	{notRoot} {
d831 1
a831 1
test fCmd-10.1 {file copy: comprehensive: source doesn't exist} {notRoot} {
d835 1
a835 1
test fCmd-10.2 {file copy: comprehensive: file to new name} {notRoot} {
d844 1
a844 1
test fCmd-10.3 {file copy: comprehensive: dir to new name} {notRoot unixOrPc} {
d859 1
a859 1
test fCmd-10.4 {file copy: comprehensive: file to existing file} {notRoot} {
d882 1
a882 1
test fCmd-10.5 {file copy: comprehensive: dir to empty dir} {notRoot} {
d907 1
a907 2
test fCmd-10.6 {file copy: comprehensive: dir to non-empty dir} \
	{notRoot unixOrPc} {
d918 1
a918 1
test fCmd-10.7 {file rename: comprehensive: file to new name and dir} {notRoot} {
d929 1
a929 2
test fCmd-10.8 {file rename: comprehensive: dir to new name and dir} \
	{notRoot unixOrPc} {
d940 1
a940 2
test fCmd-10.9 {file copy: comprehensive: source and target incompatible} \
	{notRoot} {
d946 1
a946 2
test fCmd-10.10 {file copy: comprehensive: source and target incompatible} \
	{notRoot} {
d956 1
a956 1
test fCmd-11.1 {TclFileRenameCmd: -- option } {notRoot} {
d965 1
a965 1
test fCmd-11.2 {TclFileRenameCmd: bad option } {notRoot} {
d978 1
a978 1
test fCmd-11.4 {TclFileRenameCmd: target filename translation failing} {notRoot} {
d987 1
a987 1
test fCmd-11.5 {TclFileRenameCmd: > 1 source & target is not a dir} {notRoot} {
d997 1
a997 1
test fCmd-11.6 {TclFileRenameCmd: : single file into directory} {notRoot} {
d1007 1
a1007 1
test fCmd-11.7 {TclFileRenameCmd: : multiple files into directory} {notRoot} {
d1022 1
a1022 1
test fCmd-11.8 {TclFileRenameCmd: error renaming file to directory} {notRoot} {
d1038 1
a1038 1
test fCmd-12.1 {renamefile: source filename translation failing} {notRoot} {
d1047 1
a1047 1
test fCmd-12.2 {renamefile: src filename translation failing} {notRoot} {
d1059 1
a1059 1
test fCmd-12.3 {renamefile: stat failing on source} {notRoot} {
d1065 1
a1065 1
test fCmd-12.4 {renamefile: error renaming file to directory} {notRoot} {
d1078 1
a1078 1
test fCmd-12.5 {renamefile: error renaming directory to file} {notRoot} {
d1092 1
a1092 1
test fCmd-12.6 {renamefile: TclRenameFile succeeding} {notRoot} {
d1101 1
a1101 1
test fCmd-12.7 {renamefile: renaming directory into offspring} {notRoot} {
d1110 1
a1110 1
test fCmd-12.8 {renamefile: generic error} {unixOnly notRoot} {
d1122 1
a1122 1
test fCmd-12.9 {renamefile: moving a file across volumes} {unixOnly notRoot} {
d1131 1
a1131 2
test fCmd-12.10 {renamefile: moving a directory across volumes } \
	{unixOnly notRoot} {
d1144 1
a1144 1
test fCmd-13.1 {TclCopyFilesCmd: -force option} {notRoot} {
d1153 1
a1153 1
test fCmd-13.2 {TclCopyFilesCmd: -- option} {notRoot} {
d1162 1
a1162 1
test fCmd-13.3 {TclCopyFilesCmd: bad option} {notRoot} {
d1171 1
a1171 1
test fCmd-13.4 {TclCopyFilesCmd: bad \# args} {notRoot} {
d1184 1
a1184 1
test fCmd-13.6 {TclCopyFilesCmd: > 1 source & target is not a dir} {notRoot} {
d1194 1
a1194 1
test fCmd-13.7 {TclCopyFilesCmd: single file into directory} {notRoot} {
d1204 1
a1204 1
test fCmd-13.8 {TclCopyFilesCmd: multiple files into directory} {notRoot} {
d1220 1
a1220 1
test fCmd-13.9 {TclCopyFilesCmd: error copying file to directory} {notRoot} {
d1236 1
a1236 1
test fCmd-14.1 {copyfile: source filename translation failing} {notRoot} {
d1245 1
a1245 1
test fCmd-14.2 {copyfile: dst filename translation failing} {notRoot} {
d1258 1
a1258 1
test fCmd-14.3 {copyfile: stat failing on source} {notRoot} {
d1264 1
a1264 1
test fCmd-14.4 {copyfile: error copying file to directory} {notRoot} {
d1278 1
a1278 1
 test fCmd-14.5 {copyfile: error copying directory to file} {notRoot} {
d1292 1
a1292 1
test fCmd-14.6 {copyfile: copy file succeeding} {notRoot} {
d1301 1
a1301 1
test fCmd-14.7 {copyfile: copy directory succeeding} {notRoot} {
d1311 1
a1311 1
test fCmd-14.8 {copyfile: copy directory failing} {unixOnly notRoot} {
d1325 1
a1325 1
test fCmd-15.1 {TclMakeDirsCmd: target filename translation failing} {notRoot} {
d1337 1
a1337 1
test fCmd-15.2 {TclMakeDirsCmd - one directory } {notRoot} {
d1345 1
a1345 1
test fCmd-15.3 {TclMakeDirsCmd: - two directories} {notRoot} {
d1353 1
a1353 1
test fCmd-15.4 {TclMakeDirsCmd - stat failing} {unixOnly notRoot} {
d1364 1
a1364 2
test fCmd-15.5 {TclMakeDirsCmd: - making a directory several levels deep} \
	{notRoot} {
d1373 1
a1373 1
test fCmd-15.6 {TclMakeDirsCmd: - trying to overwrite a file} {notRoot} {
d1384 1
a1384 1
test fCmd-15.7 {TclMakeDirsCmd - making several directories} {notRoot} {
d1392 1
a1392 1
test fCmd-15.8 {TclFileMakeDirsCmd: trying to create an existing dir} {notRoot} {
d1402 1
a1402 1
test fCmd-16.1 { test the -- argument } {notRoot} {
d1409 1
a1409 1
test fCmd-16.2 { test the -force and -- arguments } {notRoot} {
d1416 1
a1416 1
test fCmd-16.3 { test bad option } {notRoot} {
d1424 1
a1424 1
test fCmd-16.4 { test not enough args } {notRoot} {
d1428 1
a1428 1
test fCmd-16.5 { test not enough args with options } {notRoot} {
d1432 1
a1432 1
test fCmd-16.6 {delete: source filename translation failing} {notRoot} {
d1441 1
a1441 1
test fCmd-16.7 {remove a non-empty directory without -force } {notRoot} {
d1450 1
a1450 1
test fCmd-16.8 {remove a normal file } {notRoot} {
d1459 1
a1459 1
test fCmd-16.9 {error while deleting file } {unixOnly notRoot} {
d1475 1
a1475 1
test fCmd-16.10 {deleting multiple files} {notRoot} {
d1483 1
a1483 1
test fCmd-16.11 { TclFileDeleteCmd: removing a nonexistant file} {notRoot} {
d1490 1
a1490 1
 test fCmd-17.1 {mkdir stat failing on target but not ENOENT} {unixOnly notRoot} {
d1500 1
a1500 1
test fCmd-17.2 {mkdir several levels deep - relative } {notRoot} {
d1508 1
a1508 1
test fCmd-17.3 {mkdir several levels deep - absolute } {notRoot} {
d1521 1
a1521 2
test fCmd-18.1 {TclFileRenameCmd: rename (first form) in the same directory} \
	{notRoot} {
d1541 1
a1541 1
test fCmd-18.2 {TclFileRenameCmd: single dir to nonexistant} {notRoot} {
d1550 1
a1550 1
test fCmd-18.3 {TclFileRenameCmd: mixed dirs and files into directory} {notRoot} {
d1563 1
a1563 1
test fCmd-18.4 {TclFileRenameCmd: attempt to replace non-dir with dir} {notRoot} {
d1575 1
a1575 1
test fCmd-18.5 {TclFileRenameCmd: attempt to replace dir with non-dir} {notRoot} {
d1590 1
a1590 1
test fCmd-18.6 {TclFileRenameCmd: rename a file to itself} {macOrUnix notRoot} {
d1599 1
a1599 2
test fCmd-18.7 {TclFileRenameCmd: rename dir on top of another empty dir w/o -force} \
	{notRoot} {
d1608 1
a1608 2
test fCmd-18.8 {TclFileRenameCmd: rename dir on top of another empty dir w/ -force} \
	{notRoot} {
d1617 1
a1617 2
test fCmd-18.9 {TclFileRenameCmd: rename dir on top of a non-empty dir w/o -force} \
	{notRoot} {
d1626 1
a1626 2
test fCmd-18.10 {TclFileRenameCmd: rename dir on top of a non-empty dir w/ -force} \
	{notRoot} {
d1635 1
a1635 1
test fCmd-18.11 {TclFileRenameCmd: rename a non-existant file} {notRoot} {
d1641 1
a1641 2
test fCmd-18.12 {TclFileRenameCmd : rename a symbolic link to file} \
	{unixOnly notRoot} {
d1653 1
a1653 2
test fCmd-18.13 {TclFileRenameCmd : rename a symbolic link to dir} \
	{unixOnly notRoot} {
d1665 1
a1665 2
test fCmd-18.14 {TclFileRenameCmd : rename a path with sym link} \
	{unixOnly notRoot} {
d1681 1
a1681 2
test fCmd-18.15 {TclFileRenameCmd : rename a file to a symlink dir} \
	{unixOnly notRoot} {
d1694 1
a1694 1
test fCmd-18.16 {TclFileRenameCmd: rename a dangling symlink} {unixOnly notRoot} {
d1710 1
a1710 1
test fCmd-19.1 { remove empty directory } {notRoot} {
d1717 1
a1717 1
test fCmd-19.2 { rmdir error besides EEXIST} {unixOnly notRoot} {
d1728 1
a1728 1
test fCmd-19.3 { recursive remove } {notRoot} {
d1746 1
a1746 2
test fCmd-20.1 {TraverseUnixTree : failure opening a subdirectory directory } \
	{unixOnly notRoot} {
d1761 1
a1761 1
test fCmd-21.1 {copy : single file to nonexistant } {notRoot} {
d1770 1
a1770 1
test fCmd-21.2 {copy : single dir to nonexistant } {notRoot} {
d1779 1
a1779 1
test fCmd-21.3 {copy : single file into directory  } {notRoot} {
d1789 1
a1789 2
test fCmd-21.4 {copy : more than one source and target is not a directory} \
	{notRoot} {
d1799 1
a1799 1
test fCmd-21.5 {copy : multiple files into directory  } {notRoot} {
d1814 1
a1814 2
test fCmd-21.6 {copy: mixed dirs and files into directory} \
	{notRoot notFileSharing} {
d1827 1
a1827 1
test fCmd-21.7 {TclCopyFilesCmd: copy a dangling link} {unixOnly notRoot} {
d1837 1
a1837 1
test fCmd-21.8 {TclCopyFilesCmd : copy a link } {unixOnly notRoot} {
d1849 1
a1849 1
test fCmd-21.9 {TclCopyFilesCmd: copy dir with a link in it} {unixOnly notRoot} {
d1858 1
a1858 2
test fCmd-21.10 {TclFileCopyCmd: copy dir on top of another empty dir w/o -force} \
	{notRoot} {
d1867 1
a1867 1
test fCmd-21.11 {TclFileCopyCmd: copy dir on top of a dir w/o -force} {notRoot} {
d1876 1
a1876 2
test fCmd-21.12 {TclFileCopyCmd: copy dir on top of a non-empty dir w/ -force} \
	{notRoot} {
d1888 1
a1888 1
test fCmd-22.1 {TclpRenameFile: rename and overwrite in a single dir} {notRoot} {
d1900 1
a1900 1
test fCmd-22.2 {TclpRenameFile: attempt to overwrite itself} {macOrUnix notRoot} {
d1909 1
a1909 1
test fCmd-22.3 { TclpRenameFile : rename dir to existing dir } {notRoot} {
d1918 1
a1918 1
test fCmd-22.4 {TclpRenameFile: rename dir to dir several levels deep} {notRoot} {
d1931 1
a1931 1
test fCmd-22.5 {TclMacCopyFile: copy and overwrite in a single dir} {notRoot} {
d1953 1
a1953 1
test fCmd-23.1 {TclMacRmdir: trying to remove a nonempty directory} {notRoot} {
d1967 1
a1967 1
test fCmd-24.1 {TclMacDeleteFile: deleting a normal file} {notRoot} {
d1979 1
a1979 2
test fCmd-25.1 { TclMacCopyDirectory : copying a normal directory} \
	{notRoot notFileSharing} {
d1989 1
a1989 2
test fCmd-25.2 { TclMacCopyDirectory : copying a short path normal directory} \
	{notRoot notFileSharing} {
d1999 1
a1999 2
test fCmd-25.3 { TclMacCopyDirectory : copying dirs between different dirs} \
	{notRoot notFileSharing} {
d2014 1
a2014 1
test fCmd-26.1 { TclDeleteFilesCmd : delete symlink} {unixOnly notRoot} {
d2029 1
a2029 1
test fCmd-26.2 { TclDeleteFilesCmd : delete dir with symlink} {unixOnly notRoot} {
d2045 1
a2045 1
test fCmd-26.3 { TclDeleteFilesCmd : delete dangling symlink} {unixOnly notRoot} {
d2060 3
d2065 2
a2066 2
    list [catch {file attributes ~_totally_bogus_user} msg] $msg [testsetplatform $platform]
} {1 {user "_totally_bogus_user" doesn't exist} {}}
d2079 7
a2085 8
# Find a group that exists on this Unix system, or else skip tests that
# require Unix groups.
if {$tcl_platform(platform) == "unix"} {
    set ::tcltest::testConstraints(foundGroup) 0
    catch {
	set groupList [exec groups]
	set group [lindex $groupList 0]
	set ::tcltest::testConstraints(foundGroup) 1
a2086 2
} else {
    set ::tcltest::testConstraints(foundGroup) 1
d2089 1
a2089 1
test fCmd-27.5 {TclFileAttrsCmd - setting one option} {foundGroup} {
d2095 1
a2095 1
test fCmd-27.6 {TclFileAttrsCmd - setting more than one option} {foundGroup} {
a2101 1
# cleanup
a2102 15
::tcltest::cleanupTests
return













@


1.1.1.3
log
@import tcl 8.4.0
@
text
@d13 1
a13 1
# RCS: @@(#) $Id: fCmd.test,v 1.24 2002/08/16 13:58:39 dkf Exp $
d17 1
a17 1
    package require tcltest 2
d21 15
a35 2
tcltest::testConstraint testsetplatform [string equal testsetplatform [info commands testsetplatform]]
tcltest::testConstraint testchmod [string equal testchmod [info commands testchmod]]
d77 1
a77 1
	    foreach p [glob -directory $path *] {
d85 1
a85 6
	if {$::tcl_platform(platform) == "macintosh"} {
		set wd [list :]
	} else {
		set wd [list .]
	}
    foreach p [concat $wd $args] {
d88 1
a88 1
	    set x [glob -directory $p tf* td*]
d302 1
a302 1
	{unixOnly notRoot testchmod} {
d312 2
a313 2
    list [catch {file mkdir nonexistentvolume:} msg] $msg
} {1 {can't create directory "nonexistentvolume:": invalid argument}}
d392 1
a392 1
    file mkdir [file join td1 td2]
a394 17
test fCmd-5.11 {TclFileDeleteCmd: TclpRemoveDirectory with cwd inside} {notRoot} {
    cleanup
    set dir [pwd]
    file mkdir [file join td1 td2]
    cd [file join td1 td2]
    set res [list [catch {file delete -force [file dirname [pwd]]} msg]]
    cd $dir
    lappend res [file exists td1] $msg
} {0 0 {}}
test fCmd-5.12 {TclFileDeleteCmd: TclpRemoveDirectory with bad perms} {unixOnly} {
    cleanup
    file mkdir [file join td1 td2]
    #exec chmod u-rwx [file join td1 td2]
    file attributes [file join td1 td2] -permissions u+rwx
    set res [list [catch {file delete -force td1} msg]]
    lappend res [file exists td1] $msg
} {0 0 {}}
d418 1
a418 1
test fCmd-6.6 {CopyRenameOneFile: errno != ENOENT} {unixOnly notRoot testchmod} {
d427 1
a427 1
test fCmd-6.7 {CopyRenameOneFile: errno != ENOENT} {pcOnly 95} {
d512 1
a512 1
	set msg d:/tcl8975@@
d516 1
a517 2
    file delete -force c:/tcl8975@@
    set msg
d537 1
a537 1
    file attributes td1 -permissions 0000
d539 1
a539 1
    file attributes td1 -permissions 0755
d546 1
a546 2
    set td1name [file join [file dirname ~] [file tail ~] td1]
    file attributes $td1name -permissions 0000
d548 1
a548 1
    file attributes $td1name -permissions 0755
d557 1
a557 2
    set td1name [file join [file dirname ~] [file tail ~] td1]
    file attributes $td1name -permissions 0000
d559 1
a559 1
    file attributes $td1name -permissions 0755
d567 1
a567 2
    set td2name [file join [file dirname ~] [file tail ~] td1 td2]
    file attributes $td2name -permissions 0000
d569 1
a569 1
    file attributes $td2name -permissions 0755
d585 1
a585 1
    file attributes td1/td2/td3 -permissions 0000
d587 1
a587 1
    file attributes td1/td2/td3 -permissions 0755
d678 1
a678 1
test fCmd-9.3 {file rename: comprehensive: file to new name} {notRoot testchmod} {
d687 1
a687 1
test fCmd-9.4 {file rename: comprehensive: dir to new name} {unixOrPc notRoot testchmod} {
d695 1
a695 1
test fCmd-9.5 {file rename: comprehensive: file to self} {notRoot testchmod} {
d704 1
a704 1
test fCmd-9.6 {file rename: comprehensive: dir to self} {notRoot unixOrPc testchmod} {
d713 1
a713 1
test fCmd-9.7 {file rename: comprehensive: file to existing file} {notRoot testchmod} {
d736 1
a736 1
test fCmd-9.8 {file rename: comprehensive: dir to empty dir} {notRoot testchmod} {
d774 1
a774 1
test fCmd-9.9 {file rename: comprehensive: dir to non-empty dir} {notRoot testchmod} {
d792 1
a792 1
test fCmd-9.10 {file rename: comprehensive: file to new name and dir} {notRoot testchmod} {
d800 1
a800 1
    list [catch {glob tf*}] [lsort [glob -directory td1 t*]] \
d803 1
a803 1
test fCmd-9.11 {file rename: comprehensive: dir to new name and dir} {notRoot testchmod} {
d818 1
a818 1
    list [lsort [glob td*]] [lsort [glob -directory td3 t*]] \
d821 1
a821 1
test fCmd-9.12 {file rename: comprehensive: target exists} {notRoot testchmod} {
d865 1
a865 1
test fCmd-10.2 {file copy: comprehensive: file to new name} {notRoot testchmod} {
d874 1
a874 1
test fCmd-10.3 {file copy: comprehensive: dir to new name} {notRoot unixOrPc testchmod} {
d881 2
a882 2
    set msg [list [lsort [glob td*]] [glob -directory td3 t*] \
	    [glob -directory td4 t*] [file writable td3] [file writable td4]]
d889 1
a889 1
test fCmd-10.4 {file copy: comprehensive: file to existing file} {notRoot testchmod} {
d912 1
a912 1
test fCmd-10.5 {file copy: comprehensive: dir to empty dir} {notRoot testchmod} {
d938 1
a938 1
	{notRoot unixOrPc testchmod} {
d949 1
a949 1
test fCmd-10.7 {file rename: comprehensive: file to new name and dir} {notRoot testchmod} {
d957 1
a957 1
    list [lsort [glob tf*]] [lsort [glob -directory td1 t*]] \
d961 1
a961 1
	{notRoot unixOrPc testchmod} {
d969 1
a969 1
    list [lsort [glob td*]] [lsort [glob -directory td3 t*]] \
d1148 1
a1148 1
    file attributes tfa -permissions 0555
d1150 1
a1150 1
    file attributes tfa -permissions 0777
d1349 1
a1349 1
    file attributes tfa/dir -permissions 0000
d1351 1
a1351 1
    file attributes tfa/dir -permissions 0777
d1392 1
a1392 1
    file attributes tfa -permissions 0000
d1394 1
a1394 1
    file attributes tfa -permissions 0777
d1438 1
a1438 1
test fCmd-16.1 {test the -- argument} {notRoot} {
d1445 1
a1445 1
test fCmd-16.2 {test the -force and -- arguments} {notRoot} {
d1452 1
a1452 1
test fCmd-16.3 {test bad option} {notRoot} {
d1460 1
a1460 1
test fCmd-16.4 {test not enough args} {notRoot} {
d1464 1
a1464 1
test fCmd-16.5 {test not enough args with options} {notRoot} {
d1499 1
a1499 1
    file attributes tfa -permissions 0555
d1506 1
a1506 1
    file attributes tfa -permissions 0777
d1519 1
a1519 1
test fCmd-16.11 {TclFileDeleteCmd: removing a nonexistant file} {notRoot} {
d1529 1
a1529 1
     file attributes tfa1 -permissions 0555
d1531 1
a1531 1
     file attributes tfa1 -permissions 0777
d1687 1
a1687 1
    file link -symbolic tfa2 tfa1
d1690 1
a1690 1
    set result [expr {$t eq "link"}]
d1700 1
a1700 1
    file link -symbolic tfa2 tfa1
d1703 1
a1703 1
    set result [expr {$t eq "link"}]
d1716 1
a1716 1
    file link -symbolic $f2 $f
d1731 1
a1731 1
    file link -symbolic tfalink tfa1
d1743 1
a1743 1
    file link -symbolic tfalink tfa1
d1755 1
a1755 1
test fCmd-19.1 {remove empty directory} {notRoot} {
d1762 1
a1762 1
test fCmd-19.2 {rmdir error besides EEXIST} {unixOnly notRoot} {
d1766 1
a1766 1
    file attributes tfa -permissions 0555
d1768 1
a1768 1
    file attributes tfa -permissions 0777
d1773 1
a1773 1
test fCmd-19.3 {recursive remove} {notRoot} {
d1796 1
a1796 1
    file attributes tfa/a -permissions 0000
d1798 1
a1798 1
    file attributes tfa/a -permissions 0777
d1875 1
a1875 1
test fCmd-21.7.1 {TclCopyFilesCmd: copy a dangling link} {unixOnly notRoot dontCopyLinks} {
d1877 1
a1877 9
    file link -symbolic tfalink tfad1
    file delete tfad1
    set result [list [catch {file copy tfalink tfalink2} msg] $msg]
    file delete -force tfalink tfalink2 
    set result
} {1 {error copying "tfalink": the target of this link doesn't exist}}
test fCmd-21.7.2 {TclCopyFilesCmd: copy a dangling link} {unixOnly notRoot} {
    file mkdir tfad1
    file link -symbolic tfalink tfad1
d1885 1
a1885 1
test fCmd-21.8.1 {TclCopyFilesCmd: copy a link } {unixOnly notRoot dontCopyLinks} {
d1887 1
a1887 1
    file link -symbolic tfalink tfad1
d1889 5
a1893 16
    set r1 [file type tfalink]; # link
    set r2 [file type tfalink2]; # directory
    set r3 [file isdir tfad1]; # 1
    set result [expr {("$r1" == "link") && ("$r2" == "directory") && $r3}]
    file delete -force tfad1 tfalink tfalink2
    set result
} {1}
test fCmd-21.8.2 {TclCopyFilesCmd: copy a link } {unixOnly notRoot} {
    file mkdir tfad1
    file link -symbolic tfalink tfad1
    file copy tfalink tfalink2
    set r1 [file type tfalink]; # link
    set r2 [file type tfalink2]; # link
    set r3 [file isdir tfad1]; # 1
    set result [expr {("$r1" == "link") && ("$r2" == "link") && $r3}]
    file delete -force tfad1 tfalink tfalink2
d1899 1
a1899 1
    file link -symbolic tfad1/tfalink "[pwd]/tfad1"
d1934 1
a1934 1

d1959 1
a1959 1
test fCmd-22.3 {TclpRenameFile: rename dir to existing dir} {notRoot} {
d2029 2
a2030 1
test fCmd-25.1 {TclMacCopyDirectory: copying a normal directory} {notRoot notFileSharing} {
d2040 2
a2041 1
test fCmd-25.2 {TclMacCopyDirectory: copying a short path normal directory} {notRoot notFileSharing} {
d2051 2
a2052 1
test fCmd-25.3 {TclMacCopyDirectory: copying dirs between different dirs} {notRoot notFileSharing} {
d2067 1
a2067 1
test fCmd-26.1 {TclDeleteFilesCmd: delete symlink} {unixOnly notRoot} {
d2071 1
a2071 1
    file link -symbolic tfalink tfad1
d2082 1
a2082 1
test fCmd-26.2 {TclDeleteFilesCmd: delete dir with symlink} {unixOnly notRoot} {
d2087 1
a2087 1
    file link -symbolic [file join tfad2 link] tfad1
d2098 1
a2098 1
test fCmd-26.3 {TclDeleteFilesCmd: delete dangling symlink} {unixOnly notRoot} {
d2102 1
a2102 1
    file link -symbolic tfad2 tfad1
d2113 1
a2113 2
test fCmd-27.2 {TclFileAttrsCmd - Tcl_TranslateFileName fails} {testsetplatform} {
    set platform [testgetplatform]
d2132 1
a2132 1
    ::tcltest::testConstraint foundGroup 0
d2136 1
a2136 1
	::tcltest::testConstraint foundGroup 1
d2139 1
a2139 1
    ::tcltest::testConstraint foundGroup 1
a2154 197
if {[string equal $tcl_platform(platform) "windows"]} {
    if {[string index $tcl_platform(osVersion) 0] >= 5 \
      && ([lindex [file system [temporaryDirectory]] 1] == "NTFS")} {
	tcltest::testConstraint linkDirectory 1
	tcltest::testConstraint linkFile 1
    } else {
	tcltest::testConstraint linkDirectory 0
	tcltest::testConstraint linkFile 0
    }
} else {
    tcltest::testConstraint linkFile 1
    tcltest::testConstraint linkDirectory 1
}

test fCmd-28.1 {file link} {
    list [catch {file link} msg] $msg
} {1 {wrong # args: should be "file link ?-linktype? linkname ?target?"}}

test fCmd-28.2 {file link} {
    list [catch {file link a b c d} msg] $msg
} {1 {wrong # args: should be "file link ?-linktype? linkname ?target?"}}

test fCmd-28.3 {file link} {
    list [catch {file link abc b c} msg] $msg
} {1 {bad switch "abc": must be -symbolic or -hard}}

test fCmd-28.4 {file link} {
    list [catch {file link -abc b c} msg] $msg
} {1 {bad switch "-abc": must be -symbolic or -hard}}

makeDirectory abc.dir
makeDirectory abc2.dir
makeFile contents abc.file
makeFile contents abc2.file

cd [temporaryDirectory]
test fCmd-28.5 {file link: source already exists} {linkDirectory} {
    cd [temporaryDirectory]
    set res [list [catch {file link abc.dir abc2.dir} msg] $msg]
    cd [workingDirectory]
    set res
} {1 {could not create new link "abc.dir": that path already exists}}

test fCmd-28.6 {file link: unsupported operation} {linkDirectory macOrWin} {
    cd [temporaryDirectory]
    set res [list [catch {file link -hard abc.link abc.dir} msg] $msg]
    cd [workingDirectory]
    set res
} {1 {could not create new link "abc.link" pointing to "abc.dir": illegal operation on a directory}}

test fCmd-28.7 {file link: source already exists} {linkFile} {
    cd [temporaryDirectory]
    set res [list [catch {file link abc.file abc2.file} msg] $msg]
    cd [workingDirectory]
    set res
} {1 {could not create new link "abc.file": that path already exists}}

test fCmd-28.8 {file link} {linkFile winOnly} {
    cd [temporaryDirectory]
    set res [list [catch {file link -symbolic abc.link abc.file} msg] $msg]
    cd [workingDirectory]
    set res
} {1 {could not create new link "abc.link" pointing to "abc.file": not a directory}}

test fCmd-28.9 {file link: success with file} {linkFile} {
    cd [temporaryDirectory]
    file delete -force abc.link
    set res [list [catch {file link abc.link abc.file} msg] $msg]
    cd [workingDirectory]
    set res
} {0 abc.file}

cd [temporaryDirectory]
catch {file delete -force abc.link}
cd [workingDirectory]

test fCmd-28.10 {file link: linking to nonexistent path} {linkDirectory} {
    cd [temporaryDirectory]
    file delete -force abc.link
    set res [list [catch {file link abc.link abc2.doesnt} msg] $msg]
    cd [workingDirectory]
    set res
} {1 {could not create new link "abc.link" since target "abc2.doesnt" doesn't exist}}

test fCmd-28.11 {file link: success with directory} {linkDirectory} {
    cd [temporaryDirectory]
    file delete -force abc.link
    set res [list [catch {file link abc.link abc.dir} msg] $msg]
    cd [workingDirectory]
    set res
} {0 abc.dir}

test fCmd-28.12 {file link: cd into a link} {linkDirectory} {
    cd [temporaryDirectory]
    file delete -force abc.link
    file link abc.link abc.dir
    set orig [pwd]
    cd abc.link
    set dir [pwd]
    cd ..
    set up [pwd]
    cd $orig
    # now '$up' should be either $orig or [file dirname abc.dir],
    # depending on whether 'cd' actually moves to the destination
    # of a link, or simply treats the link as a directory.
    # (on windows the former, on unix the latter, I believe)
    if {([file normalize $up] != [file normalize $orig]) \
      && ([file normalize $up] != [file normalize [file dirname abc.dir]])} {
	set res "wrong directory with 'cd $link ; cd ..'"
    } else {
	set res "ok"
    }
    cd [workingDirectory]
    set res
} {ok}

test fCmd-28.13 {file link} {linkDirectory} {
    # duplicate link throws error
    cd [temporaryDirectory]
    set res [list [catch {file link abc.link abc.dir} msg] $msg]
    cd [workingDirectory]
    set res
} {1 {could not create new link "abc.link": that path already exists}}

test fCmd-28.14 {file link: deletes link not dir} {linkDirectory} {
    cd [temporaryDirectory]
    file delete -force abc.link
    set res [list [file exists abc.link] [file exists abc.dir]]
    cd [workingDirectory]
    set res
} {0 1}

test fCmd-28.15.1 {file link: copies link not dir} {linkDirectory dontCopyLinks} {
    cd [temporaryDirectory]
    file delete -force abc.link
    file link abc.link abc.dir
    file copy abc.link abc2.link
    # abc2.linkdir was a copy of a link to a dir, so it should end up as
    # a directory, not a link (links trace to endpoint).
    set res [list [file type abc2.link] [file tail [file link abc.link]]]
    cd [workingDirectory]
    set res
} {directory abc.dir}
test fCmd-28.15.2 {file link: copies link not dir} {linkDirectory} {
    cd [temporaryDirectory]
    file delete -force abc.link
    file link abc.link abc.dir
    file copy abc.link abc2.link
    set res [list [file type abc2.link] [file tail [file link abc2.link]]]
    cd [workingDirectory]
    set res
} {link abc.dir}

cd [temporaryDirectory]
file delete -force abc.link
file delete -force abc2.link

file copy abc.file abc.dir
file copy abc2.file abc.dir
cd [workingDirectory]

test fCmd-28.16 {file link: glob inside link} {linkDirectory} {
    cd [temporaryDirectory]
    file delete -force abc.link
    file link abc.link abc.dir
    set res [glob -dir abc.link -tails *]
    cd [workingDirectory]
    set res
} {abc.file abc2.file}

test fCmd-28.17 {file link: glob -type l} {linkDirectory} {
    cd [temporaryDirectory]
    set res [glob -dir [pwd] -type l -tails abc*]
    cd [workingDirectory]
    set res
} {abc.link}

test fCmd-28.18 {file link: glob -type d} {linkDirectory} {
    cd [temporaryDirectory]
    set res [lsort [glob -dir [pwd] -type d -tails abc*]]
    cd [workingDirectory]
    set res
} [lsort [list abc.link abc.dir abc2.dir]]

test fCmd-29.1 {weird memory corruption fault} {
    catch {set res [open [file join ~a_totally_bogus_user_id/foo bar]]}
} 1

cd [temporaryDirectory]
file delete -force abc.link
cd [workingDirectory]

removeFile abc2.file
removeFile abc.file
removeDirectory abc2.dir
removeDirectory abc.dir

d2159 13
@


1.1.1.4
log
@import tcl 8.4.1
@
text
@d13 1
a13 1
# RCS: @@(#) $Id: fCmd.test,v 1.25 2002/10/04 08:25:14 dkf Exp $
d277 1
a277 1
    set x [file exists td1]
d279 1
a279 1
    list $x [file exists td1]
d289 1
a289 1
    set x [file exists td1]
d291 1
a291 1
    list $x [file exists td1]
d308 1
a308 1
    set x [file exists td1]
d310 1
a310 1
    list $x [file exists td1]
d350 1
a350 1
    set x [list [file exists tf1] [file exists tf2] [file exists td1]]
d352 1
a352 1
    lappend x [file exists tf1] [file exists tf2] [file exists tf3]
d360 1
a360 1
    list [file exists tf1] [file exists tf2] [file exists td1]
d372 1
a372 1
    set x [file exists tf1]
d374 1
a374 1
    list $x [file exists tf1]
d380 1
a380 1
    file exists td1
@


