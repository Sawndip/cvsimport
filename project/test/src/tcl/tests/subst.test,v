head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.58
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.56
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.54
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.52
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.50
	gdb_7_0-branch:1.5.0.48
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tcl8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.46
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.44
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.42
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.40
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.38
	gdb_6_5-2006-05-14-branchpoint:1.5
	readline_5_1-import-branch:1.5.0.36
	readline_5_1-import-branchpoint:1.5
	gdb_6_4-branch:1.5.0.34
	gdb_6_4-2005-11-01-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.32
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	ezannoni_pie-20040323-branch:1.5.0.30
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.28
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.26
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.24
	cagney_x86i386-20030821-branch:1.5.0.22
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.20
	gdb_6_0-2003-06-23-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.18
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.16
	cagney_writestrings-20030508-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.14
	cagney_fileio-20030521-branchpoint:1.5
	carlton_dictionary-20030430-merge:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.12
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.10
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.8
	cagney_lazyid-20030317-branchpoint:1.5
	offbyone-20030313-branch:1.5.0.6
	offbyone-20030313-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.4
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.2
	interps-20030202-branchpoint:1.5
	TCL8_4_1:1.1.1.3
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.2
	TCL_8_4_1:1.1.1.3
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.4
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TCL_8_4_0:1.1.1.3
	carlton_dictionary-branch:1.2.0.16
	carlton_dictionary-20020920-branchpoint:1.2
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.14
	gdb_5_3-branch:1.2.0.12
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.10
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.8
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.6
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TCL_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	dejagnu-2000-02-04:1.1.1.1
	dejagnu-2000-01-31:1.1.1.1
	dejagnu-2000-01-24:1.1.1.1
	dejagnu-2000-01-17:1.1.1.1
	dejagnu-2000-01-10:1.1.1.1
	dejagnu-2000-01-04:1.1.1.1
	dejagnu-1999-12-21:1.1.1.1
	dejagnu-1999-12-13:1.1.1.1
	dejagnu-1999-12-07:1.1.1.1
	dejagnu-1999-12-06:1.1.1.1
	dejagnu-1999-11-15:1.1.1.1
	dejagnu-1999-11-08:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2003.01.21.19.40.17;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.26.19.48.02;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.37.08;	author kseitz;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2001.09.09.23.56.08;	author irox;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2002.09.27.21.49.11;	author kseitz;	state Exp;
branches;
next	;

1.3.4.1
date	2003.12.14.20.28.50;	author drow;	state Exp;
branches;
next	;

1.2.16.1
date	2002.12.23.19.40.45;	author carlton;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2003.02.07.19.18.20;	author carlton;	state Exp;
branches;
next	;

1.1.1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.09.22.40.59;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.19.56.41;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tcl 8.4.1
@
text
@# Commands covered:  subst
#
# This file contains a collection of tests for one or more of the Tcl
# built-in commands.  Sourcing this file into Tcl runs the tests and
# generates output for errors.  No output means no errors were found.
#
# Copyright (c) 1994 The Regents of the University of California.
# Copyright (c) 1994 Sun Microsystems, Inc.
# Copyright (c) 1998-2000 Ajuba Solutions.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# RCS: @@(#) $Id: subst.test,v 1.12 2002/08/08 15:28:55 msofer Exp $

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import -force ::tcltest::*
}

test subst-1.1 {basics} {
    list [catch {subst} msg] $msg
} {1 {wrong # args: should be "subst ?-nobackslashes? ?-nocommands? ?-novariables? string"}}
test subst-1.2 {basics} {
    list [catch {subst a b c} msg] $msg
} {1 {bad switch "a": must be -nobackslashes, -nocommands, or -novariables}}

test subst-2.1 {simple strings} {
    subst {}
} {}
test subst-2.2 {simple strings} {
    subst a
} a
test subst-2.3 {simple strings} {
    subst abcdefg
} abcdefg

test subst-3.1 {backslash substitutions} {
    subst {\x\$x\[foo bar]\\}
} "x\$x\[foo bar]\\"
test subst-3.2 {backslash substitutions with utf chars} {
    # 'j' is just a char that doesn't mean anything, and \344 is 'ä'
    # that also doesn't mean anything, but is multi-byte in UTF-8.
    list [subst \j] [subst \\j] [subst \\344] [subst \\\344]
} "j j \344 \344"

test subst-4.1 {variable substitutions} {
    set a 44
    subst {$a}
} {44}
test subst-4.2 {variable substitutions} {
    set a 44
    subst {x$a.y{$a}.z}
} {x44.y{44}.z}
test subst-4.3 {variable substitutions} {
    catch {unset a}
    set a(13) 82
    set i 13
    subst {x.$a($i)}
} {x.82}
catch {unset a}
set long {This is a very long string, intentionally made so long that it
	will overflow the static character size for dstrings, so that
	additional memory will have to be allocated by subst.  That way,
	if the subst procedure forgets to free up memory while returning
	an error, there will be memory that isn't freed (this will be
	detected when the tests are run under a checking memory allocator
	such as Purify).}
test subst-4.4 {variable substitutions} {
    list [catch {subst {$long $a}} msg] $msg
} {1 {can't read "a": no such variable}}

test subst-5.1 {command substitutions} {
    subst {[concat {}]}
} {}
test subst-5.2 {command substitutions} {
    subst {[concat A test string]}
} {A test string}
test subst-5.3 {command substitutions} {
    subst {x.[concat foo].y.[concat bar].z}
} {x.foo.y.bar.z}
test subst-5.4 {command substitutions} {
    list [catch {subst {$long [set long] [bogus_command]}} msg] $msg
} {1 {invalid command name "bogus_command"}}
test subst-5.5 {command substitutions} {
    set a 0
    list [catch {subst {[set a 1}} msg] $a $msg 
} {1 0 {missing close-bracket}}
test subst-5.6 {command substitutions} {
    set a 0
    list [catch {subst {0[set a 1}} msg] $a $msg 
} {1 0 {missing close-bracket}}
test subst-5.7 {command substitutions} {
    set a 0
    list [catch {subst {0[set a 1; set a 2}} msg] $a $msg 
} {1 1 {missing close-bracket}}

# repeat the tests above simulating cmd line input
test subst-5.8 {command substitutions} {
    set script {[subst {[set a 1}]}
    list [catch {exec [info nameofexecutable] << $script} msg] $msg 
} {1 {missing close-bracket}}
test subst-5.9 {command substitutions} {
    set script {[subst {0[set a 1}]}
    list [catch {exec [info nameofexecutable] << $script} msg] $msg 
} {1 {missing close-bracket}}
test subst-5.10 {command substitutions} {
    set script {[subst {0[set a 1; set a 2}]}
    list [catch {exec [info nameofexecutable] << $script} msg] $msg 
} {1 {missing close-bracket}}

test subst-6.1 {clear the result after command substitution} {
    catch {unset a}
    list [catch {subst {[concat foo] $a}} msg] $msg
} {1 {can't read "a": no such variable}}

test subst-7.1 {switches} {
    list [catch {subst foo bar} msg] $msg
} {1 {bad switch "foo": must be -nobackslashes, -nocommands, or -novariables}}
test subst-7.2 {switches} {
    list [catch {subst -no bar} msg] $msg
} {1 {ambiguous switch "-no": must be -nobackslashes, -nocommands, or -novariables}}
test subst-7.3 {switches} {
    list [catch {subst -bogus bar} msg] $msg
} {1 {bad switch "-bogus": must be -nobackslashes, -nocommands, or -novariables}}
test subst-7.4 {switches} {
    set x 123
    subst -nobackslashes {abc $x [expr 1+2] \\\x41}
} {abc 123 3 \\\x41}
test subst-7.5 {switches} {
    set x 123
    subst -nocommands {abc $x [expr 1+2] \\\x41}
} {abc 123 [expr 1+2] \A}
test subst-7.6 {switches} {
    set x 123
    subst -novariables {abc $x [expr 1+2] \\\x41}
} {abc $x 3 \A}
test subst-7.7 {switches} {
    set x 123
    subst -nov -nob -noc {abc $x [expr 1+2] \\\x41}
} {abc $x [expr 1+2] \\\x41}

test subst-8.1 {return in a subst} {
    subst {foo [return {x}; bogus code] bar}
} {foo x bar}
test subst-8.2 {return in a subst} {
    subst {foo [return x ; bogus code] bar}
} {foo x bar}
test subst-8.3 {return in a subst} {
    subst {foo [if 1 { return {x}; bogus code }] bar}
} {foo x bar}
test subst-8.4 {return in a subst} {
    subst {[eval {return hi}] there}
} {hi there}
test subst-8.5 {return in a subst} {
    subst {foo [return {]}; bogus code] bar}
} {foo ] bar}
test subst-8.6 {return in a subst} {
    subst {foo [return {x}; bogus code bar}
} {foo x}
test subst-8.7 {return in a subst, parse error} {
    subst {foo [return {x} ; set a {}" ; stuff] bar}
} {foo xset a {}" ; stuff] bar}
test subst-8.8 {return in a subst, parse error} {
    subst {foo [return {x} ; set bar baz ; set a {}" ; stuff] bar}
} {foo xset bar baz ; set a {}" ; stuff] bar}
test subst-8.9 {return in a variable subst} {
    subst {foo $var([return {x}]) bar}
} {foo x bar}

test subst-9.1 {error in a subst} {
    list [catch {subst {[error foo; bogus code]bar}} msg] $msg
} {1 foo}
test subst-9.2 {error in a subst} {
    list [catch {subst {[if 1 { error foo; bogus code}]bar}} msg] $msg
} {1 foo}
test subst-9.3 {error in a variable subst} {
    list [catch {subst {foo $var([error foo]) bar}} msg] $msg
} {1 foo}

test subst-10.1 {break in a subst} {
    subst {foo [break; bogus code] bar}
} {foo }
test subst-10.2 {break in a subst} {
    subst {foo [break; return x; bogus code] bar}
} {foo }
test subst-10.3 {break in a subst} {
    subst {foo [if 1 { break; bogus code}] bar}
} {foo }
test subst-10.4 {break in a subst, parse error} {
    subst {foo [break ; set a {}{} ; stuff] bar}
} {foo }
test subst-10.5 {break in a subst, parse error} {
    subst {foo [break ;set bar baz ;set a {}{} ; stuff] bar}
} {foo }
test subst-10.6 {break in a variable subst} {
    subst {foo $var([break]) bar}
} {foo }

test subst-11.1 {continue in a subst} {
    subst {foo [continue; bogus code] bar}
} {foo  bar}
test subst-11.2 {continue in a subst} {
    subst {foo [continue; return x; bogus code] bar}
} {foo  bar}
test subst-11.3 {continue in a subst} {
    subst {foo [if 1 { continue; bogus code}] bar}
} {foo  bar}
test subst-11.4 {continue in a subst, parse error} {
    subst {foo [continue ; set a {}{} ; stuff] bar}
} {foo set a {}{} ; stuff] bar}
test subst-11.5 {continue in a subst, parse error} {
    subst {foo [continue ;set bar baz ;set a {}{} ; stuff] bar}
} {foo set bar baz ;set a {}{} ; stuff] bar}
test subst-11.6 {continue in a variable subst} {
    subst {foo $var([continue]) bar}
} {foo  bar}

# cleanup
::tcltest::cleanupTests
return
@


1.4
log
@touched all sources to ease next import
@
text
@d9 1
a9 1
# Copyright (c) 1998-1999 by Scriptics Corporation.
d14 1
a14 1
# RCS: @@(#) $Id: subst.test,v 1.6.8.2 2000/09/15 16:57:39 spolk Exp $
d26 1
a26 1
} {1 {wrong # args: should be "subst ?-nobackslashes? ?-nocommands? ?-novariables? string"}}
d41 5
d85 26
d119 1
a119 1
} {1 {wrong # args: should be "subst ?-nobackslashes? ?-nocommands? ?-novariables? string"}}
d143 76
a221 13













@


1.3
log
@touched all sources to ease next import
@
text
@@


1.3.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d9 1
a9 1
# Copyright (c) 1998-2000 Ajuba Solutions.
d14 1
a14 1
# RCS: @@(#) $Id: subst.test,v 1.12 2002/08/08 15:28:55 msofer Exp $
d26 1
a26 1
} {1 {bad switch "a": must be -nobackslashes, -nocommands, or -novariables}}
a40 5
test subst-3.2 {backslash substitutions with utf chars} {
    # 'j' is just a char that doesn't mean anything, and \344 is 'ä'
    # that also doesn't mean anything, but is multi-byte in UTF-8.
    list [subst \j] [subst \\j] [subst \\344] [subst \\\344]
} "j j \344 \344"
a79 26
test subst-5.5 {command substitutions} {
    set a 0
    list [catch {subst {[set a 1}} msg] $a $msg 
} {1 0 {missing close-bracket}}
test subst-5.6 {command substitutions} {
    set a 0
    list [catch {subst {0[set a 1}} msg] $a $msg 
} {1 0 {missing close-bracket}}
test subst-5.7 {command substitutions} {
    set a 0
    list [catch {subst {0[set a 1; set a 2}} msg] $a $msg 
} {1 1 {missing close-bracket}}

# repeat the tests above simulating cmd line input
test subst-5.8 {command substitutions} {
    set script {[subst {[set a 1}]}
    list [catch {exec [info nameofexecutable] << $script} msg] $msg 
} {1 {missing close-bracket}}
test subst-5.9 {command substitutions} {
    set script {[subst {0[set a 1}]}
    list [catch {exec [info nameofexecutable] << $script} msg] $msg 
} {1 {missing close-bracket}}
test subst-5.10 {command substitutions} {
    set script {[subst {0[set a 1; set a 2}]}
    list [catch {exec [info nameofexecutable] << $script} msg] $msg 
} {1 {missing close-bracket}}
d88 1
a88 1
} {1 {bad switch "foo": must be -nobackslashes, -nocommands, or -novariables}}
a111 76
test subst-8.1 {return in a subst} {
    subst {foo [return {x}; bogus code] bar}
} {foo x bar}
test subst-8.2 {return in a subst} {
    subst {foo [return x ; bogus code] bar}
} {foo x bar}
test subst-8.3 {return in a subst} {
    subst {foo [if 1 { return {x}; bogus code }] bar}
} {foo x bar}
test subst-8.4 {return in a subst} {
    subst {[eval {return hi}] there}
} {hi there}
test subst-8.5 {return in a subst} {
    subst {foo [return {]}; bogus code] bar}
} {foo ] bar}
test subst-8.6 {return in a subst} {
    subst {foo [return {x}; bogus code bar}
} {foo x}
test subst-8.7 {return in a subst, parse error} {
    subst {foo [return {x} ; set a {}" ; stuff] bar}
} {foo xset a {}" ; stuff] bar}
test subst-8.8 {return in a subst, parse error} {
    subst {foo [return {x} ; set bar baz ; set a {}" ; stuff] bar}
} {foo xset bar baz ; set a {}" ; stuff] bar}
test subst-8.9 {return in a variable subst} {
    subst {foo $var([return {x}]) bar}
} {foo x bar}

test subst-9.1 {error in a subst} {
    list [catch {subst {[error foo; bogus code]bar}} msg] $msg
} {1 foo}
test subst-9.2 {error in a subst} {
    list [catch {subst {[if 1 { error foo; bogus code}]bar}} msg] $msg
} {1 foo}
test subst-9.3 {error in a variable subst} {
    list [catch {subst {foo $var([error foo]) bar}} msg] $msg
} {1 foo}

test subst-10.1 {break in a subst} {
    subst {foo [break; bogus code] bar}
} {foo }
test subst-10.2 {break in a subst} {
    subst {foo [break; return x; bogus code] bar}
} {foo }
test subst-10.3 {break in a subst} {
    subst {foo [if 1 { break; bogus code}] bar}
} {foo }
test subst-10.4 {break in a subst, parse error} {
    subst {foo [break ; set a {}{} ; stuff] bar}
} {foo }
test subst-10.5 {break in a subst, parse error} {
    subst {foo [break ;set bar baz ;set a {}{} ; stuff] bar}
} {foo }
test subst-10.6 {break in a variable subst} {
    subst {foo $var([break]) bar}
} {foo }

test subst-11.1 {continue in a subst} {
    subst {foo [continue; bogus code] bar}
} {foo  bar}
test subst-11.2 {continue in a subst} {
    subst {foo [continue; return x; bogus code] bar}
} {foo  bar}
test subst-11.3 {continue in a subst} {
    subst {foo [if 1 { continue; bogus code}] bar}
} {foo  bar}
test subst-11.4 {continue in a subst, parse error} {
    subst {foo [continue ; set a {}{} ; stuff] bar}
} {foo set a {}{} ; stuff] bar}
test subst-11.5 {continue in a subst, parse error} {
    subst {foo [continue ;set bar baz ;set a {}{} ; stuff] bar}
} {foo set bar baz ;set a {}{} ; stuff] bar}
test subst-11.6 {continue in a variable subst} {
    subst {foo $var([continue]) bar}
} {foo  bar}

d115 13
@


1.3.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@d9 1
a9 1
# Copyright (c) 1998-2000 Ajuba Solutions.
d14 1
a14 1
# RCS: @@(#) $Id: subst.test,v 1.12 2002/08/08 15:28:55 msofer Exp $
d26 1
a26 1
} {1 {bad switch "a": must be -nobackslashes, -nocommands, or -novariables}}
a40 5
test subst-3.2 {backslash substitutions with utf chars} {
    # 'j' is just a char that doesn't mean anything, and \344 is 'ä'
    # that also doesn't mean anything, but is multi-byte in UTF-8.
    list [subst \j] [subst \\j] [subst \\344] [subst \\\344]
} "j j \344 \344"
a79 26
test subst-5.5 {command substitutions} {
    set a 0
    list [catch {subst {[set a 1}} msg] $a $msg 
} {1 0 {missing close-bracket}}
test subst-5.6 {command substitutions} {
    set a 0
    list [catch {subst {0[set a 1}} msg] $a $msg 
} {1 0 {missing close-bracket}}
test subst-5.7 {command substitutions} {
    set a 0
    list [catch {subst {0[set a 1; set a 2}} msg] $a $msg 
} {1 1 {missing close-bracket}}

# repeat the tests above simulating cmd line input
test subst-5.8 {command substitutions} {
    set script {[subst {[set a 1}]}
    list [catch {exec [info nameofexecutable] << $script} msg] $msg 
} {1 {missing close-bracket}}
test subst-5.9 {command substitutions} {
    set script {[subst {0[set a 1}]}
    list [catch {exec [info nameofexecutable] << $script} msg] $msg 
} {1 {missing close-bracket}}
test subst-5.10 {command substitutions} {
    set script {[subst {0[set a 1; set a 2}]}
    list [catch {exec [info nameofexecutable] << $script} msg] $msg 
} {1 {missing close-bracket}}
d88 1
a88 1
} {1 {bad switch "foo": must be -nobackslashes, -nocommands, or -novariables}}
a111 76
test subst-8.1 {return in a subst} {
    subst {foo [return {x}; bogus code] bar}
} {foo x bar}
test subst-8.2 {return in a subst} {
    subst {foo [return x ; bogus code] bar}
} {foo x bar}
test subst-8.3 {return in a subst} {
    subst {foo [if 1 { return {x}; bogus code }] bar}
} {foo x bar}
test subst-8.4 {return in a subst} {
    subst {[eval {return hi}] there}
} {hi there}
test subst-8.5 {return in a subst} {
    subst {foo [return {]}; bogus code] bar}
} {foo ] bar}
test subst-8.6 {return in a subst} {
    subst {foo [return {x}; bogus code bar}
} {foo x}
test subst-8.7 {return in a subst, parse error} {
    subst {foo [return {x} ; set a {}" ; stuff] bar}
} {foo xset a {}" ; stuff] bar}
test subst-8.8 {return in a subst, parse error} {
    subst {foo [return {x} ; set bar baz ; set a {}" ; stuff] bar}
} {foo xset bar baz ; set a {}" ; stuff] bar}
test subst-8.9 {return in a variable subst} {
    subst {foo $var([return {x}]) bar}
} {foo x bar}

test subst-9.1 {error in a subst} {
    list [catch {subst {[error foo; bogus code]bar}} msg] $msg
} {1 foo}
test subst-9.2 {error in a subst} {
    list [catch {subst {[if 1 { error foo; bogus code}]bar}} msg] $msg
} {1 foo}
test subst-9.3 {error in a variable subst} {
    list [catch {subst {foo $var([error foo]) bar}} msg] $msg
} {1 foo}

test subst-10.1 {break in a subst} {
    subst {foo [break; bogus code] bar}
} {foo }
test subst-10.2 {break in a subst} {
    subst {foo [break; return x; bogus code] bar}
} {foo }
test subst-10.3 {break in a subst} {
    subst {foo [if 1 { break; bogus code}] bar}
} {foo }
test subst-10.4 {break in a subst, parse error} {
    subst {foo [break ; set a {}{} ; stuff] bar}
} {foo }
test subst-10.5 {break in a subst, parse error} {
    subst {foo [break ;set bar baz ;set a {}{} ; stuff] bar}
} {foo }
test subst-10.6 {break in a variable subst} {
    subst {foo $var([break]) bar}
} {foo }

test subst-11.1 {continue in a subst} {
    subst {foo [continue; bogus code] bar}
} {foo  bar}
test subst-11.2 {continue in a subst} {
    subst {foo [continue; return x; bogus code] bar}
} {foo  bar}
test subst-11.3 {continue in a subst} {
    subst {foo [if 1 { continue; bogus code}] bar}
} {foo  bar}
test subst-11.4 {continue in a subst, parse error} {
    subst {foo [continue ; set a {}{} ; stuff] bar}
} {foo set a {}{} ; stuff] bar}
test subst-11.5 {continue in a subst, parse error} {
    subst {foo [continue ;set bar baz ;set a {}{} ; stuff] bar}
} {foo set bar baz ;set a {}{} ; stuff] bar}
test subst-11.6 {continue in a variable subst} {
    subst {foo $var([continue]) bar}
} {foo  bar}

d115 13
@


1.2
log
@touched all Tcl files to ease next import.
@
text
@@


1.2.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.2.16.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d9 1
a9 1
# Copyright (c) 1998-2000 Ajuba Solutions.
d26 1
a26 1
} {1 {bad switch "a": must be -nobackslashes, -nocommands, or -novariables}}
a40 5
test subst-3.2 {backslash substitutions with utf chars} {
    # 'j' is just a char that doesn't mean anything, and \344 is 'ä'
    # that also doesn't mean anything, but is multi-byte in UTF-8.
    list [subst \j] [subst \\j] [subst \\344] [subst \\\344]
} "j j \344 \344"
a79 26
test subst-5.5 {command substitutions} {
    set a 0
    list [catch {subst {[set a 1}} msg] $a $msg 
} {1 0 {missing close-bracket}}
test subst-5.6 {command substitutions} {
    set a 0
    list [catch {subst {0[set a 1}} msg] $a $msg 
} {1 0 {missing close-bracket}}
test subst-5.7 {command substitutions} {
    set a 0
    list [catch {subst {0[set a 1; set a 2}} msg] $a $msg 
} {1 1 {missing close-bracket}}

# repeat the tests above simulating cmd line input
test subst-5.8 {command substitutions} {
    set script {[subst {[set a 1}]}
    list [catch {exec [info nameofexecutable] << $script} msg] $msg 
} {1 {missing close-bracket}}
test subst-5.9 {command substitutions} {
    set script {[subst {0[set a 1}]}
    list [catch {exec [info nameofexecutable] << $script} msg] $msg 
} {1 {missing close-bracket}}
test subst-5.10 {command substitutions} {
    set script {[subst {0[set a 1; set a 2}]}
    list [catch {exec [info nameofexecutable] << $script} msg] $msg 
} {1 {missing close-bracket}}
d88 1
a88 1
} {1 {bad switch "foo": must be -nobackslashes, -nocommands, or -novariables}}
a111 76
test subst-8.1 {return in a subst} {
    subst {foo [return {x}; bogus code] bar}
} {foo x bar}
test subst-8.2 {return in a subst} {
    subst {foo [return x ; bogus code] bar}
} {foo x bar}
test subst-8.3 {return in a subst} {
    subst {foo [if 1 { return {x}; bogus code }] bar}
} {foo x bar}
test subst-8.4 {return in a subst} {
    subst {[eval {return hi}] there}
} {hi there}
test subst-8.5 {return in a subst} {
    subst {foo [return {]}; bogus code] bar}
} {foo ] bar}
test subst-8.6 {return in a subst} {
    subst {foo [return {x}; bogus code bar}
} {foo x}
test subst-8.7 {return in a subst, parse error} {
    subst {foo [return {x} ; set a {}" ; stuff] bar}
} {foo xset a {}" ; stuff] bar}
test subst-8.8 {return in a subst, parse error} {
    subst {foo [return {x} ; set bar baz ; set a {}" ; stuff] bar}
} {foo xset bar baz ; set a {}" ; stuff] bar}
test subst-8.9 {return in a variable subst} {
    subst {foo $var([return {x}]) bar}
} {foo x bar}

test subst-9.1 {error in a subst} {
    list [catch {subst {[error foo; bogus code]bar}} msg] $msg
} {1 foo}
test subst-9.2 {error in a subst} {
    list [catch {subst {[if 1 { error foo; bogus code}]bar}} msg] $msg
} {1 foo}
test subst-9.3 {error in a variable subst} {
    list [catch {subst {foo $var([error foo]) bar}} msg] $msg
} {1 foo}

test subst-10.1 {break in a subst} {
    subst {foo [break; bogus code] bar}
} {foo }
test subst-10.2 {break in a subst} {
    subst {foo [break; return x; bogus code] bar}
} {foo }
test subst-10.3 {break in a subst} {
    subst {foo [if 1 { break; bogus code}] bar}
} {foo }
test subst-10.4 {break in a subst, parse error} {
    subst {foo [break ; set a {}{} ; stuff] bar}
} {foo }
test subst-10.5 {break in a subst, parse error} {
    subst {foo [break ;set bar baz ;set a {}{} ; stuff] bar}
} {foo }
test subst-10.6 {break in a variable subst} {
    subst {foo $var([break]) bar}
} {foo }

test subst-11.1 {continue in a subst} {
    subst {foo [continue; bogus code] bar}
} {foo  bar}
test subst-11.2 {continue in a subst} {
    subst {foo [continue; return x; bogus code] bar}
} {foo  bar}
test subst-11.3 {continue in a subst} {
    subst {foo [if 1 { continue; bogus code}] bar}
} {foo  bar}
test subst-11.4 {continue in a subst, parse error} {
    subst {foo [continue ; set a {}{} ; stuff] bar}
} {foo set a {}{} ; stuff] bar}
test subst-11.5 {continue in a subst, parse error} {
    subst {foo [continue ;set bar baz ;set a {}{} ; stuff] bar}
} {foo set bar baz ;set a {}{} ; stuff] bar}
test subst-11.6 {continue in a variable subst} {
    subst {foo $var([continue]) bar}
} {foo  bar}

d115 13
@


1.1
log
@Initial revision
@
text
@d9 1
d14 1
a14 1
# RCS: @@(#) $Id: subst.test,v 1.10 1999/01/26 03:53:34 jingham Exp $
d16 4
a19 1
if {[string compare test [info procs test]] == 1} then {source defs}
d91 1
a91 1
} {1 {bad switch "-no": must be -nobackslashes, -nocommands, or -novariables}}
d111 17
@


1.1.1.1
log
@import dejagnu-1999-11-08 snapshot
@
text
@@


1.1.1.2
log
@Tcl 8.3 upgrade
@
text
@a8 1
# Copyright (c) 1998-1999 by Scriptics Corporation.
d13 1
a13 1
# RCS: @@(#) $Id: subst.test,v 1.6.8.2 2000/09/15 16:57:39 spolk Exp $
d15 1
a15 4
if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import -force ::tcltest::*
}
d87 1
a87 1
} {1 {ambiguous switch "-no": must be -nobackslashes, -nocommands, or -novariables}}
a106 17

# cleanup
::tcltest::cleanupTests
return













@


1.1.1.3
log
@import tcl 8.4.0
@
text
@d9 1
a9 1
# Copyright (c) 1998-2000 Ajuba Solutions.
d14 1
a14 1
# RCS: @@(#) $Id: subst.test,v 1.12 2002/08/08 15:28:55 msofer Exp $
d26 1
a26 1
} {1 {bad switch "a": must be -nobackslashes, -nocommands, or -novariables}}
a40 5
test subst-3.2 {backslash substitutions with utf chars} {
    # 'j' is just a char that doesn't mean anything, and \344 is 'ä'
    # that also doesn't mean anything, but is multi-byte in UTF-8.
    list [subst \j] [subst \\j] [subst \\344] [subst \\\344]
} "j j \344 \344"
a79 26
test subst-5.5 {command substitutions} {
    set a 0
    list [catch {subst {[set a 1}} msg] $a $msg 
} {1 0 {missing close-bracket}}
test subst-5.6 {command substitutions} {
    set a 0
    list [catch {subst {0[set a 1}} msg] $a $msg 
} {1 0 {missing close-bracket}}
test subst-5.7 {command substitutions} {
    set a 0
    list [catch {subst {0[set a 1; set a 2}} msg] $a $msg 
} {1 1 {missing close-bracket}}

# repeat the tests above simulating cmd line input
test subst-5.8 {command substitutions} {
    set script {[subst {[set a 1}]}
    list [catch {exec [info nameofexecutable] << $script} msg] $msg 
} {1 {missing close-bracket}}
test subst-5.9 {command substitutions} {
    set script {[subst {0[set a 1}]}
    list [catch {exec [info nameofexecutable] << $script} msg] $msg 
} {1 {missing close-bracket}}
test subst-5.10 {command substitutions} {
    set script {[subst {0[set a 1; set a 2}]}
    list [catch {exec [info nameofexecutable] << $script} msg] $msg 
} {1 {missing close-bracket}}
d88 1
a88 1
} {1 {bad switch "foo": must be -nobackslashes, -nocommands, or -novariables}}
a111 76
test subst-8.1 {return in a subst} {
    subst {foo [return {x}; bogus code] bar}
} {foo x bar}
test subst-8.2 {return in a subst} {
    subst {foo [return x ; bogus code] bar}
} {foo x bar}
test subst-8.3 {return in a subst} {
    subst {foo [if 1 { return {x}; bogus code }] bar}
} {foo x bar}
test subst-8.4 {return in a subst} {
    subst {[eval {return hi}] there}
} {hi there}
test subst-8.5 {return in a subst} {
    subst {foo [return {]}; bogus code] bar}
} {foo ] bar}
test subst-8.6 {return in a subst} {
    subst {foo [return {x}; bogus code bar}
} {foo x}
test subst-8.7 {return in a subst, parse error} {
    subst {foo [return {x} ; set a {}" ; stuff] bar}
} {foo xset a {}" ; stuff] bar}
test subst-8.8 {return in a subst, parse error} {
    subst {foo [return {x} ; set bar baz ; set a {}" ; stuff] bar}
} {foo xset bar baz ; set a {}" ; stuff] bar}
test subst-8.9 {return in a variable subst} {
    subst {foo $var([return {x}]) bar}
} {foo x bar}

test subst-9.1 {error in a subst} {
    list [catch {subst {[error foo; bogus code]bar}} msg] $msg
} {1 foo}
test subst-9.2 {error in a subst} {
    list [catch {subst {[if 1 { error foo; bogus code}]bar}} msg] $msg
} {1 foo}
test subst-9.3 {error in a variable subst} {
    list [catch {subst {foo $var([error foo]) bar}} msg] $msg
} {1 foo}

test subst-10.1 {break in a subst} {
    subst {foo [break; bogus code] bar}
} {foo }
test subst-10.2 {break in a subst} {
    subst {foo [break; return x; bogus code] bar}
} {foo }
test subst-10.3 {break in a subst} {
    subst {foo [if 1 { break; bogus code}] bar}
} {foo }
test subst-10.4 {break in a subst, parse error} {
    subst {foo [break ; set a {}{} ; stuff] bar}
} {foo }
test subst-10.5 {break in a subst, parse error} {
    subst {foo [break ;set bar baz ;set a {}{} ; stuff] bar}
} {foo }
test subst-10.6 {break in a variable subst} {
    subst {foo $var([break]) bar}
} {foo }

test subst-11.1 {continue in a subst} {
    subst {foo [continue; bogus code] bar}
} {foo  bar}
test subst-11.2 {continue in a subst} {
    subst {foo [continue; return x; bogus code] bar}
} {foo  bar}
test subst-11.3 {continue in a subst} {
    subst {foo [if 1 { continue; bogus code}] bar}
} {foo  bar}
test subst-11.4 {continue in a subst, parse error} {
    subst {foo [continue ; set a {}{} ; stuff] bar}
} {foo set a {}{} ; stuff] bar}
test subst-11.5 {continue in a subst, parse error} {
    subst {foo [continue ;set bar baz ;set a {}{} ; stuff] bar}
} {foo set bar baz ;set a {}{} ; stuff] bar}
test subst-11.6 {continue in a variable subst} {
    subst {foo $var([continue]) bar}
} {foo  bar}

d115 13
@


