head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.58
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.56
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.54
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.52
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.50
	gdb_7_0-branch:1.5.0.48
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tcl8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.46
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.44
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.42
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.40
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.38
	gdb_6_5-2006-05-14-branchpoint:1.5
	readline_5_1-import-branch:1.5.0.36
	readline_5_1-import-branchpoint:1.5
	gdb_6_4-branch:1.5.0.34
	gdb_6_4-2005-11-01-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.32
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	ezannoni_pie-20040323-branch:1.5.0.30
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.28
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.26
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.24
	cagney_x86i386-20030821-branch:1.5.0.22
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.20
	gdb_6_0-2003-06-23-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.18
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.16
	cagney_writestrings-20030508-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.14
	cagney_fileio-20030521-branchpoint:1.5
	carlton_dictionary-20030430-merge:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.12
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.10
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.8
	cagney_lazyid-20030317-branchpoint:1.5
	offbyone-20030313-branch:1.5.0.6
	offbyone-20030313-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.4
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.2
	interps-20030202-branchpoint:1.5
	TCL8_4_1:1.1.1.3
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.2
	TCL_8_4_1:1.1.1.3
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.4
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TCL_8_4_0:1.1.1.3
	carlton_dictionary-branch:1.2.0.16
	carlton_dictionary-20020920-branchpoint:1.2
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.14
	gdb_5_3-branch:1.2.0.12
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.10
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.8
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.6
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TCL_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	dejagnu-2000-02-04:1.1.1.1
	dejagnu-2000-01-31:1.1.1.1
	dejagnu-2000-01-24:1.1.1.1
	dejagnu-2000-01-17:1.1.1.1
	dejagnu-2000-01-10:1.1.1.1
	dejagnu-2000-01-04:1.1.1.1
	dejagnu-1999-12-21:1.1.1.1
	dejagnu-1999-12-13:1.1.1.1
	dejagnu-1999-12-07:1.1.1.1
	dejagnu-1999-12-06:1.1.1.1
	dejagnu-1999-11-15:1.1.1.1
	dejagnu-1999-11-08:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2003.01.21.19.40.16;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.26.19.48.01;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.37.07;	author kseitz;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2001.09.09.23.56.08;	author irox;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2002.09.27.21.49.11;	author kseitz;	state Exp;
branches;
next	;

1.3.4.1
date	2003.12.14.20.28.49;	author drow;	state Exp;
branches;
next	;

1.2.16.1
date	2002.12.23.19.40.43;	author carlton;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2003.02.07.19.18.20;	author carlton;	state Exp;
branches;
next	;

1.1.1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.09.22.40.58;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.19.56.39;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tcl 8.4.1
@
text
@# This file contains tests for the pkg_mkIndex command.
# Note that the tests are limited to Tcl scripts only, there are no shared
# libraries against which to test.
#
# Sourcing this file into Tcl runs the tests and generates output for
# errors.  No output means no errors were found.
#
# Copyright (c) 1998-1999 by Scriptics Corporation.
# All rights reserved.
#
# RCS: @@(#) $Id: pkgMkIndex.test,v 1.23 2002/07/06 18:19:46 dgp Exp $

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest 2
    namespace import -force ::tcltest::*
}

set fullPkgPath [makeDirectory pkg]


namespace eval pkgtest {
    # Namespace for procs we can discard
}

# pkgtest::parseArgs --
#
#  Parse an argument list.
#
# Arguments:
#  <flags>	(optional) arguments starting with a dash are collected
#		as options to pkg_mkIndex and passed to pkg_mkIndex.
#  dirPath	the directory to index
#  pattern0	pattern to index
#  ...		pattern to index
#  patternN	pattern to index
#
# Results:
#  Returns a three element list:
#    0: the options
#    1: the directory to index
#    2: the patterns list

proc pkgtest::parseArgs { args } {
    set options ""

    set argc [llength $args]
    for {set iarg 0} {$iarg < $argc} {incr iarg} {
	set a [lindex $args $iarg]
	if {[regexp {^-} $a]} {
	    lappend options $a
	    if {[string compare -load $a] == 0} {
		incr iarg
		lappend options [lindex $args $iarg]
	    }
	} else {
	    break
	}
    }

    set dirPath [lindex $args $iarg]
    incr iarg
    set patternList [lrange $args $iarg end]

    return [list $options $dirPath $patternList]
}

# pkgtest::parseIndex --
#
#  Loads a pkgIndex.tcl file, records all the calls to "package ifneeded".
#
# Arguments:
#  filePath	path to the pkgIndex.tcl file.
#
# Results:
#  Returns a list, in "array set/get" format, where the keys are the package
#  name and version (in the form "$name:$version"), and the values the rest
#  of the command line.

proc pkgtest::parseIndex { filePath } {
    # create a slave interpreter, where we override "package ifneeded"

    set slave [interp create]
    if {[catch {
	$slave eval {
	    rename package package_original
	    proc package { args } {
		if {[string compare [lindex $args 0] ifneeded] == 0} {
		    set pkg [lindex $args 1]
		    set ver [lindex $args 2]
		    set ::PKGS($pkg:$ver) [lindex $args 3]
		} else {
		    return [eval package_original $args]
		}
	    }
	    array set ::PKGS {}
	}

	set dir [file dirname $filePath]
	$slave eval {set curdir [pwd]}
	$slave eval [list cd $dir]
	$slave eval [list set dir $dir]
	$slave eval [list source [file tail $filePath]]
	$slave eval {cd $curdir}

	# Create the list in sorted order, so that we don't get spurious
	# errors because the order has changed.

	array set P {}
	foreach {k v} [$slave eval {array get ::PKGS}] {
	    set P($k) $v
	}

	set PKGS ""
	foreach k [lsort [array names P]] {
	    lappend PKGS $k $P($k)
	}
    } err]} {
	set ei $::errorInfo
	set ec $::errorCode

	catch {interp delete $slave}

	error $ei $ec
    }

    interp delete $slave

    return $PKGS
}

# pkgtest::createIndex --
#
#  Runs pkg_mkIndex for the given directory and set of patterns.
#  This procedure deletes any pkgIndex.tcl file in the target directory,
#  then runs pkg_mkIndex.
#
# Arguments:
#  <flags>	(optional) arguments starting with a dash are collected
#		as options to pkg_mkIndex and passed to pkg_mkIndex.
#  dirPath	the directory to index
#  pattern0	pattern to index
#  ...		pattern to index
#  patternN	pattern to index
#
# Results:
#  Returns a two element list:
#    0: 1 if the procedure encountered an error, 0 otherwise.
#    1: the error result if element 0 was 1

proc pkgtest::createIndex { args } {
    set parsed [eval parseArgs $args]
    set options [lindex $parsed 0]
    set dirPath [lindex $parsed 1]
    set patternList [lindex $parsed 2]

    file mkdir $dirPath

    if {[catch {
	file delete [file join $dirPath pkgIndex.tcl]
	eval pkg_mkIndex $options [list $dirPath] $patternList
    } err]} {
	return [list 1 $err]
    }

    return [list 0 {}]
}

# makePkgList --
#
#  Takes the output of a pkgtest::parseIndex call, filters it and returns a
#  cleaned up list of packages and their actions.
#
# Arguments:
#  inList	output from a pkgtest::parseIndex.
#
# Results:
#  Returns a list of two element lists:
#    0: the name:version
#    1: a list describing the package.
#	For tclPkgSetup packages it consists of:
#	 0: the keyword tclPkgSetup
#	 1: the first file to source, with its exported procedures
#	 2: the second file ...
#	 N: the N-1st file ...

proc makePkgList { inList } {
    set pkgList ""

    foreach {k v} $inList {
	switch [lindex $v 0] {
	    tclPkgSetup {
		set l tclPkgSetup
		foreach s [lindex $v 4] {
		    lappend l $s
		}
	    }

	    source {
		set l $v
	    }

	    default {
		error "can't handle $k $v"
	    }
	}

	lappend pkgList [list $k $l]
    }

    return $pkgList
}

# pkgtest::runIndex --
#
#  Runs pkg_mkIndex, parses the generated index file.
#
# Arguments:
#  <flags>	(optional) arguments starting with a dash are collected
#		as options to pkg_mkIndex and passed to pkg_mkIndex.
#  dirPath	the directory to index
#  pattern0	pattern to index
#  ...		pattern to index
#  patternN	pattern to index
#
# Results:
#  Returns a two element list:
#    0: 1 if the procedure encountered an error, 0 otherwise.
#    1: if no error, this is the parsed generated index file, in the format
#	returned by pkgtest::parseIndex.
#	If error, this is the error result.

proc pkgtest::runCreatedIndex {rv args} {
    if {[lindex $rv 0] == 0} {
	set parsed [eval parseArgs $args]
	set dirPath [lindex $parsed 1]
	set idxFile [file join $dirPath pkgIndex.tcl]

	if {[catch {
	    set result [list 0 [makePkgList [parseIndex $idxFile]]]
	} err]} {
	    set result [list 1 $err]
	} 
	file delete $idxFile
    } else {
	set result $rv
    }

    return $result
}
proc pkgtest::runIndex { args } {
    set rv [eval createIndex $args]
    return [eval [list runCreatedIndex $rv] $args]
}

# If there is no match to the patterns, make sure the directory hasn't
# changed on us

test pkgMkIndex-1.1 {nothing matches pattern - current dir is the same} {
    list [pkgtest::runIndex -lazy $fullPkgPath nomatch.tcl] [pwd]
} [list {1 {no files matched glob pattern "nomatch.tcl"}} [pwd]]

makeFile {
#  This is a simple package, just to check basic functionality.
package provide simple 1.0
namespace eval simple {
    namespace export lower upper
}
proc simple::lower { stg } {
    return [string tolower $stg]
}
proc simple::upper { stg } {
    return [string toupper $stg]
}
} [file join pkg simple.tcl]

test pkgMkIndex-2.1 {simple package} {
    pkgtest::runIndex -lazy $fullPkgPath simple.tcl
} {0 {{simple:1.0 {tclPkgSetup {simple.tcl source {::simple::lower ::simple::upper}}}}}}

test pkgMkIndex-2.2 {simple package - use -direct} {
    pkgtest::runIndex -direct $fullPkgPath simple.tcl
} "0 {{simple:1.0 {[list source [file join $fullPkgPath simple.tcl]]}}}"

test pkgMkIndex-2.3 {simple package - direct loading is default} {
    pkgtest::runIndex $fullPkgPath simple.tcl
} "0 {{simple:1.0 {[list source [file join $fullPkgPath simple.tcl]]}}}"

removeFile [file join pkg simple.tcl]

makeFile {
#  Contains global symbols, used to check that they don't have a leading ::
package provide global 1.0
proc global_lower { stg } {
    return [string tolower $stg]
}
proc global_upper { stg } {
    return [string toupper $stg]
}
} [file join pkg global.tcl]

test pkgMkIndex-3.1 {simple package with global symbols} {
    pkgtest::runIndex -lazy $fullPkgPath global.tcl
} {0 {{global:1.0 {tclPkgSetup {global.tcl source {global_lower global_upper}}}}}}

removeFile [file join pkg global.tcl]

makeFile {
#  This package is required by pkg1.
#  This package is split into two files, to test packages that are split
#  over multiple files.
package provide pkg2 1.0
namespace eval pkg2 {
    namespace export p2-1
}
proc pkg2::p2-1 { num } {
    return [expr $num * 2]
}
} [file join pkg pkg2_a.tcl]

makeFile {
#  This package is required by pkg1.
#  This package is split into two files, to test packages that are split
#  over multiple files.
package provide pkg2 1.0
namespace eval pkg2 {
    namespace export p2-2
}
proc pkg2::p2-2 { num } {
    return [expr $num * 3]
}
} [file join pkg pkg2_b.tcl]

test pkgMkIndex-4.1 {split package} {
    pkgtest::runIndex -lazy $fullPkgPath pkg2_a.tcl pkg2_b.tcl
} {0 {{pkg2:1.0 {tclPkgSetup {pkg2_a.tcl source ::pkg2::p2-1} {pkg2_b.tcl source ::pkg2::p2-2}}}}}

test pkgMkIndex-4.2 {split package - direct loading} {
    pkgtest::runIndex -direct $fullPkgPath pkg2_a.tcl pkg2_b.tcl
} "0 {{pkg2:1.0 {[list source [file join $fullPkgPath pkg2_a.tcl]]
[list source [file join $fullPkgPath pkg2_b.tcl]]}}}"

# Add the direct1 directory to auto_path, so that the direct1 package 
# can be found.
set direct1 [makeDirectory direct1]
lappend auto_path $direct1
makeFile {
#  This is referenced by pkgIndex.tcl as a -direct script.
package provide direct1 1.0
namespace eval direct1 {
    namespace export pd1 pd2
}
proc direct1::pd1 { stg } {
    return [string tolower $stg]
}
proc direct1::pd2 { stg } {
    return [string toupper $stg]
}
} [file join direct1 direct1.tcl]
pkg_mkIndex -direct $direct1 direct1.tcl

makeFile {
#  Does a package require of direct1, whose pkgIndex.tcl entry
#  is created above with option -direct.  This tests that pkg_mkIndex
#  can handle code that is sourced in pkgIndex.tcl files.
package require direct1
package provide std 1.0
namespace eval std {
    namespace export p1 p2
}
proc std::p1 { stg } {
    return [string tolower $stg]
}
proc std::p2 { stg } {
    return [string toupper $stg]
}
} [file join pkg std.tcl]

test pkgMkIndex-5.1 {requires -direct package} {
    pkgtest::runIndex -lazy $fullPkgPath std.tcl
} {0 {{std:1.0 {tclPkgSetup {std.tcl source {::std::p1 ::std::p2}}}}}}

removeFile [file join direct1 direct1.tcl]
file delete [file join $direct1 pkgIndex.tcl]
removeDirectory direct1
removeFile [file join pkg std.tcl]

makeFile {
#  This package requires pkg3, but it does
#  not use any of pkg3's procs in the code that is executed by the file
#  (i.e. references to pkg3's procs are in the proc bodies only).
package require pkg3 1.0
package provide pkg1 1.0
namespace eval pkg1 {
    namespace export p1-1 p1-2
}
proc pkg1::p1-1 { num } {
    return [pkg3::p3-1 $num]
}
proc pkg1::p1-2 { num } {
    return [pkg3::p3-2 $num]
}
} [file join pkg pkg1.tcl]

makeFile {
package provide pkg3 1.0
namespace eval pkg3 {
    namespace export p3-1 p3-2
}
proc pkg3::p3-1 { num } {
    return {[expr $num * 2]}
}
proc pkg3::p3-2 { num } {
    return {[expr $num * 3]}
}
} [file join pkg pkg3.tcl]

test pkgMkIndex-6.1 {pkg1 requires pkg3} {
    pkgtest::runIndex -lazy $fullPkgPath pkg1.tcl pkg3.tcl
} {0 {{pkg1:1.0 {tclPkgSetup {pkg1.tcl source {::pkg1::p1-1 ::pkg1::p1-2}}}} {pkg3:1.0 {tclPkgSetup {pkg3.tcl source {::pkg3::p3-1 ::pkg3::p3-2}}}}}}

test pkgMkIndex-6.2 {pkg1 requires pkg3 - use -direct} {
    pkgtest::runIndex -direct $fullPkgPath pkg1.tcl pkg3.tcl
} "0 {{pkg1:1.0 {[list source [file join $fullPkgPath pkg1.tcl]]}} {pkg3:1.0 {[list source [file join $fullPkgPath pkg3.tcl]]}}}"

removeFile [file join pkg pkg1.tcl]

makeFile {
#  This package requires pkg3, and it calls
#  a pkg3 proc in the code that is executed by the file
package require pkg3 1.0
package provide pkg4 1.0
namespace eval pkg4 {
    namespace export p4-1 p4-2
    variable m2 [pkg3::p3-1 10]
}
proc pkg4::p4-1 { num } {
    variable m2
    return [expr {$m2 * $num}]
}
proc pkg4::p4-2 { num } {
    return [pkg3::p3-2 $num]
}
} [file join pkg pkg4.tcl]

test pkgMkIndex-7.1 {pkg4 uses pkg3} {
    pkgtest::runIndex -lazy $fullPkgPath pkg4.tcl pkg3.tcl
} {0 {{pkg3:1.0 {tclPkgSetup {pkg3.tcl source {::pkg3::p3-1 ::pkg3::p3-2}}}} {pkg4:1.0 {tclPkgSetup {pkg4.tcl source {::pkg4::p4-1 ::pkg4::p4-2}}}}}}

test pkgMkIndex-7.2 {pkg4 uses pkg3 - use -direct} {
    pkgtest::runIndex -direct $fullPkgPath pkg4.tcl pkg3.tcl
} "0 {{pkg3:1.0 {[list source [file join $fullPkgPath pkg3.tcl]]}} {pkg4:1.0 {[list source [file join $fullPkgPath pkg4.tcl]]}}}"

removeFile [file join pkg pkg4.tcl]
removeFile [file join pkg pkg3.tcl]

makeFile {
#  This package requires pkg2, and it calls
#  a pkg2 proc in the code that is executed by the file.
#  Pkg2 is a split package.
package require pkg2 1.0
package provide pkg5 1.0
namespace eval pkg5 {
    namespace export p5-1 p5-2
    variable m2 [pkg2::p2-1 10]
    variable m3 [pkg2::p2-2 10]
}
proc pkg5::p5-1 { num } {
    variable m2
    return [expr {$m2 * $num}]
}
proc pkg5::p5-2 { num } {
    variable m2
    return [expr {$m2 * $num}]
}
} [file join pkg pkg5.tcl]

test pkgMkIndex-8.1 {pkg5 uses pkg2} {
    pkgtest::runIndex -lazy $fullPkgPath pkg5.tcl pkg2_a.tcl pkg2_b.tcl
} {0 {{pkg2:1.0 {tclPkgSetup {pkg2_a.tcl source ::pkg2::p2-1} {pkg2_b.tcl source ::pkg2::p2-2}}} {pkg5:1.0 {tclPkgSetup {pkg5.tcl source {::pkg5::p5-1 ::pkg5::p5-2}}}}}}

test pkgMkIndex-8.2 {pkg5 uses pkg2 - use -direct} {
    pkgtest::runIndex -direct $fullPkgPath pkg5.tcl pkg2_a.tcl pkg2_b.tcl
} "0 {{pkg2:1.0 {[list source [file join $fullPkgPath pkg2_a.tcl]]
[list source [file join $fullPkgPath pkg2_b.tcl]]}} {pkg5:1.0 {[list source [file join $fullPkgPath pkg5.tcl]]}}}"

removeFile [file join pkg pkg5.tcl]
removeFile [file join pkg pkg2_a.tcl]
removeFile [file join pkg pkg2_b.tcl]

makeFile {
#  This package requires circ2, and circ2
#  requires circ3, which in turn requires circ1.
#  In case of cirularities, pkg_mkIndex should give up when it gets stuck.
package require circ2 1.0
package provide circ1 1.0
namespace eval circ1 {
    namespace export c1-1 c1-2 c1-3 c1-4
}
proc circ1::c1-1 { num } {
    return [circ2::c2-1 $num]
}
proc circ1::c1-2 { num } {
    return [circ2::c2-2 $num]
}
proc circ1::c1-3 {} {
    return 10
}
proc circ1::c1-4 {} {
    return 20
}
} [file join pkg circ1.tcl]

makeFile {
#  This package is required by circ1, and
#  requires circ3. Circ3, in turn, requires circ1 to give us a circularity.
package require circ3 1.0
package provide circ2 1.0
namespace eval circ2 {
    namespace export c2-1 c2-2
}
proc circ2::c2-1 { num } {
    return [expr $num * [circ3::c3-1]]
}
proc circ2::c2-2 { num } {
    return [expr $num * [circ3::c3-2]]
}
} [file join pkg circ2.tcl]

makeFile {
#  This package is required by circ2, and in
#  turn requires circ1. This closes the circularity.
package require circ1 1.0
package provide circ3 1.0
namespace eval circ3 {
    namespace export c3-1 c3-4
}
proc circ3::c3-1 {} {
    return [circ1::c1-3]
}
proc circ3::c3-2 {} {
    return [circ1::c1-4]
}
} [file join pkg circ3.tcl]

test pkgMkIndex-9.1 {circular packages} {
    pkgtest::runIndex -lazy $fullPkgPath circ1.tcl circ2.tcl circ3.tcl
} {0 {{circ1:1.0 {tclPkgSetup {circ1.tcl source {::circ1::c1-1 ::circ1::c1-2 ::circ1::c1-3 ::circ1::c1-4}}}} {circ2:1.0 {tclPkgSetup {circ2.tcl source {::circ2::c2-1 ::circ2::c2-2}}}} {circ3:1.0 {tclPkgSetup {circ3.tcl source ::circ3::c3-1}}}}}

removeFile [file join pkg circ1.tcl]
removeFile [file join pkg circ2.tcl]
removeFile [file join pkg circ3.tcl]

# Some tests require the existence of one of the DLLs in the dltest directory
set x [file join [file dirname [info nameofexecutable]] dltest \
	pkga[info sharedlibextension]]
set dll "[file tail $x]Required"
::tcltest::testConstraint $dll [file exists $x]

if {[testConstraint $dll]} {
makeFile {
#  This package provides Pkga, which is also provided by a DLL.
package provide Pkga 1.0
proc pkga_neq { x } {
    return [expr {! [pkgq_eq $x]}]
}
} [file join pkg pkga.tcl]
file copy -force $x $fullPkgPath
}
testConstraint exec [llength [info commands ::exec]]

test pkgMkIndex-10.1 {package in DLL and script} [list exec $dll] {
    # Do all [load]ing of shared libraries in another process, so 
    # we can delete the file and not get stuck because we're holding
    # a reference to it.
    set cmd [list pkg_mkIndex -lazy $fullPkgPath [file tail $x] pkga.tcl]
    exec [interpreter] << $cmd
    pkgtest::runCreatedIndex {0 {}} -lazy $fullPkgPath pkga[info sharedlibextension] pkga.tcl
} "0 {{Pkga:1.0 {tclPkgSetup {pkga[info sharedlibextension] load {pkga_eq pkga_quote}} {pkga.tcl source pkga_neq}}}}"
test pkgMkIndex-10.2 {package in DLL hidden by -load} [list exec $dll] {
    # Do all [load]ing of shared libraries in another process, so 
    # we can delete the file and not get stuck because we're holding
    # a reference to it.
    #
    # This test depends on context from prior test, so repeat it.
    set script "[list pkg_mkIndex -lazy $fullPkgPath [file tail $x] pkga.tcl]\n"
    append script \
	    "[list pkg_mkIndex -lazy -load Pkg* $fullPkgPath [file tail $x]]"
    exec [interpreter] << $script
    pkgtest::runCreatedIndex {0 {}} -lazy -load Pkg* -- $fullPkgPath pkga[info sharedlibextension]
} {0 {}}

if {[testConstraint $dll]} {
file delete -force [file join $fullPkgPath [file tail $x]]
removeFile [file join pkg pkga.tcl]
}

# Tolerate "namespace import" at the global scope

makeFile {
package provide fubar 1.0
namespace eval ::fubar:: {
    #
    # export only public functions.
    #
    namespace export {[a-z]*}
}
proc ::fubar::foo {bar} {
    puts "$bar"
    return true
}
namespace import ::fubar::foo
} [file join pkg import.tcl]

test pkgMkIndex-11.1 {conflicting namespace imports} {
    pkgtest::runIndex -lazy $fullPkgPath import.tcl
} {0 {{fubar:1.0 {tclPkgSetup {import.tcl source ::fubar::foo}}}}}

removeFile [file join pkg import.tcl]

# Verify that the auto load list generated is correct even when there
# is a proc name conflict between two namespaces (ie, ::foo::baz and
# ::bar::baz)

makeFile {
package provide football 1.0
namespace eval ::pro:: {
    #
    # export only public functions.
    #
    namespace export {[a-z]*}
}
namespace eval ::college:: {
    #
    # export only public functions.
    #
    namespace export {[a-z]*}
}
proc ::pro::team {} {
    puts "go packers!"
    return true
}
proc ::college::team {} {
    puts "go badgers!"
    return true
}
} [file join pkg samename.tcl]

test pkgMkIndex-12.1 {same name procs in different namespace} {
    pkgtest::runIndex -lazy $fullPkgPath samename.tcl
} {0 {{football:1.0 {tclPkgSetup {samename.tcl source {::college::team ::pro::team}}}}}}

removeFile [file join pkg samename.tcl]

# Proc names with embedded spaces are properly listed (ie, correct number of
# braces) in result
makeFile {
package provide spacename 1.0
proc {a b} {} {}
proc {c d} {} {}
} [file join pkg spacename.tcl]

test pkgMkIndex-13.1 {proc names with embedded spaces} {
    pkgtest::runIndex -lazy $fullPkgPath spacename.tcl
} {0 {{spacename:1.0 {tclPkgSetup {spacename.tcl source {{a b} {c d}}}}}}}

removeFile [file join pkg spacename.tcl]

# Test the pkg_compareExtension helper function
test pkgMkIndex-14.1 {pkg_compareExtension} {unixOnly} {
    pkg_compareExtension foo.so .so
} 1
test pkgMkIndex-14.2 {pkg_compareExtension} {unixOnly} {
    pkg_compareExtension foo.so.bar .so
} 0
test pkgMkIndex-14.3 {pkg_compareExtension} {unixOnly} {
    pkg_compareExtension foo.so.1 .so
} 1
test pkgMkIndex-14.4 {pkg_compareExtension} {unixOnly} {
    pkg_compareExtension foo.so.1.2 .so
} 1
test pkgMkIndex-14.5 {pkg_compareExtension} {unixOnly} {
    pkg_compareExtension foo .so
} 0
test pkgMkIndex-14.6 {pkg_compareExtension} {unixOnly} {
    pkg_compareExtension foo.so.1.2.bar .so
} 0

# cleanup

removeDirectory pkg

namespace delete pkgtest
::tcltest::cleanupTests
return

@


1.4
log
@touched all sources to ease next import
@
text
@d11 1
a11 1
# RCS: @@(#) $Id: pkgMkIndex.test,v 1.3.8.2 2000/09/15 16:57:16 spolk Exp $
d14 1
a14 1
    package require tcltest
d18 1
a18 2
set origDir [pwd]
cd $::tcltest::testsDirectory
a19 7
set fullPkgPath [file join $::tcltest::testsDirectory pkg]

# Add the pkg1 directory to auto_path, so that its packages can be found.
# packages in pkg1 are used to test indexing of packages in pkg.
# Make sure that the path to pkg1 is absolute.

lappend auto_path [file join $::tcltest::testsDirectory pkg1]
d157 1
a157 1
 
d160 1
a160 1
	eval pkg_mkIndex $options $dirPath $patternList
d232 1
a232 2
proc pkgtest::runIndex { args } {
    set rv [eval createIndex $args]
d250 4
d262 14
d282 1
a282 1
} "0 {{simple:1.0 {source [file join $fullPkgPath simple.tcl]}}}"
d286 14
a299 1
} "0 {{simple:1.0 {source [file join $fullPkgPath simple.tcl]}}}"
d305 28
d339 2
a340 2
} "0 {{pkg2:1.0 {source [file join $fullPkgPath pkg2_a.tcl]
source [file join $fullPkgPath pkg2_b.tcl]}}}"
d342 35
a376 5
# This will fail, with "direct1" procedures in the list of procedures
# provided by std.
# It may also fail, if tclblend is in the auto_path, with an additional
# command "loadJava" which comes from the tclblend pkgIndex.tcl file.
# Both failures are caused by Tcl code executed in pkgIndex.tcl.
d382 35
d423 21
a443 1
} "0 {{pkg1:1.0 {source [file join $fullPkgPath pkg1.tcl]}} {pkg3:1.0 {source [file join $fullPkgPath pkg3.tcl]}}}"
d451 25
a475 1
} "0 {{pkg3:1.0 {source [file join $fullPkgPath pkg3.tcl]}} {pkg4:1.0 {source [file join $fullPkgPath pkg4.tcl]}}}"
d483 61
a543 2
} "0 {{pkg2:1.0 {source [file join $fullPkgPath pkg2_a.tcl]
source [file join $fullPkgPath pkg2_b.tcl]}} {pkg5:1.0 {source [file join $fullPkgPath pkg5.tcl]}}}"
d549 4
d557 1
a557 1
set ::tcltest::testConstraints($dll) [file exists $x]
d559 19
a577 3
test pkgMkIndex-10.1 {package in DLL and script} $dll {
    file copy -force $x $fullPkgPath
    pkgtest::runIndex -lazy $fullPkgPath pkga[info sharedlibextension] pkga.tcl
d579 11
a589 2
test pkgMkIndex-10.2 {package in DLL hidden by -load} $dll {
    pkgtest::runIndex -lazy -load Pkg* -- $fullPkgPath pkga[info sharedlibextension]
d592 5
d599 15
d618 2
d624 24
d652 2
d656 6
d666 22
d690 2
a692 1
cd $origDir
a694 1

@


1.3
log
@touched all sources to ease next import
@
text
@@


1.3.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d11 1
a11 1
# RCS: @@(#) $Id: pkgMkIndex.test,v 1.23 2002/07/06 18:19:46 dgp Exp $
d14 1
a14 1
    package require tcltest 2
d18 2
a19 1
set fullPkgPath [makeDirectory pkg]
d21 7
d165 1
a165 1

d168 1
a168 1
	eval pkg_mkIndex $options [list $dirPath] $patternList
d240 2
a241 1
proc pkgtest::runCreatedIndex {rv args} {
a258 4
proc pkgtest::runIndex { args } {
    set rv [eval createIndex $args]
    return [eval [list runCreatedIndex $rv] $args]
}
a266 14
makeFile {
#  This is a simple package, just to check basic functionality.
package provide simple 1.0
namespace eval simple {
    namespace export lower upper
}
proc simple::lower { stg } {
    return [string tolower $stg]
}
proc simple::upper { stg } {
    return [string toupper $stg]
}
} [file join pkg simple.tcl]

d273 1
a273 1
} "0 {{simple:1.0 {[list source [file join $fullPkgPath simple.tcl]]}}}"
d277 1
a277 14
} "0 {{simple:1.0 {[list source [file join $fullPkgPath simple.tcl]]}}}"

removeFile [file join pkg simple.tcl]

makeFile {
#  Contains global symbols, used to check that they don't have a leading ::
package provide global 1.0
proc global_lower { stg } {
    return [string tolower $stg]
}
proc global_upper { stg } {
    return [string toupper $stg]
}
} [file join pkg global.tcl]
a282 28
removeFile [file join pkg global.tcl]

makeFile {
#  This package is required by pkg1.
#  This package is split into two files, to test packages that are split
#  over multiple files.
package provide pkg2 1.0
namespace eval pkg2 {
    namespace export p2-1
}
proc pkg2::p2-1 { num } {
    return [expr $num * 2]
}
} [file join pkg pkg2_a.tcl]

makeFile {
#  This package is required by pkg1.
#  This package is split into two files, to test packages that are split
#  over multiple files.
package provide pkg2 1.0
namespace eval pkg2 {
    namespace export p2-2
}
proc pkg2::p2-2 { num } {
    return [expr $num * 3]
}
} [file join pkg pkg2_b.tcl]

d289 2
a290 2
} "0 {{pkg2:1.0 {[list source [file join $fullPkgPath pkg2_a.tcl]]
[list source [file join $fullPkgPath pkg2_b.tcl]]}}}"
d292 5
a296 35
# Add the direct1 directory to auto_path, so that the direct1 package 
# can be found.
set direct1 [makeDirectory direct1]
lappend auto_path $direct1
makeFile {
#  This is referenced by pkgIndex.tcl as a -direct script.
package provide direct1 1.0
namespace eval direct1 {
    namespace export pd1 pd2
}
proc direct1::pd1 { stg } {
    return [string tolower $stg]
}
proc direct1::pd2 { stg } {
    return [string toupper $stg]
}
} [file join direct1 direct1.tcl]
pkg_mkIndex -direct $direct1 direct1.tcl

makeFile {
#  Does a package require of direct1, whose pkgIndex.tcl entry
#  is created above with option -direct.  This tests that pkg_mkIndex
#  can handle code that is sourced in pkgIndex.tcl files.
package require direct1
package provide std 1.0
namespace eval std {
    namespace export p1 p2
}
proc std::p1 { stg } {
    return [string tolower $stg]
}
proc std::p2 { stg } {
    return [string toupper $stg]
}
} [file join pkg std.tcl]
a301 35
removeFile [file join direct1 direct1.tcl]
file delete [file join $direct1 pkgIndex.tcl]
removeDirectory direct1
removeFile [file join pkg std.tcl]

makeFile {
#  This package requires pkg3, but it does
#  not use any of pkg3's procs in the code that is executed by the file
#  (i.e. references to pkg3's procs are in the proc bodies only).
package require pkg3 1.0
package provide pkg1 1.0
namespace eval pkg1 {
    namespace export p1-1 p1-2
}
proc pkg1::p1-1 { num } {
    return [pkg3::p3-1 $num]
}
proc pkg1::p1-2 { num } {
    return [pkg3::p3-2 $num]
}
} [file join pkg pkg1.tcl]

makeFile {
package provide pkg3 1.0
namespace eval pkg3 {
    namespace export p3-1 p3-2
}
proc pkg3::p3-1 { num } {
    return {[expr $num * 2]}
}
proc pkg3::p3-2 { num } {
    return {[expr $num * 3]}
}
} [file join pkg pkg3.tcl]

d308 1
a308 21
} "0 {{pkg1:1.0 {[list source [file join $fullPkgPath pkg1.tcl]]}} {pkg3:1.0 {[list source [file join $fullPkgPath pkg3.tcl]]}}}"

removeFile [file join pkg pkg1.tcl]

makeFile {
#  This package requires pkg3, and it calls
#  a pkg3 proc in the code that is executed by the file
package require pkg3 1.0
package provide pkg4 1.0
namespace eval pkg4 {
    namespace export p4-1 p4-2
    variable m2 [pkg3::p3-1 10]
}
proc pkg4::p4-1 { num } {
    variable m2
    return [expr {$m2 * $num}]
}
proc pkg4::p4-2 { num } {
    return [pkg3::p3-2 $num]
}
} [file join pkg pkg4.tcl]
d316 1
a316 25
} "0 {{pkg3:1.0 {[list source [file join $fullPkgPath pkg3.tcl]]}} {pkg4:1.0 {[list source [file join $fullPkgPath pkg4.tcl]]}}}"

removeFile [file join pkg pkg4.tcl]
removeFile [file join pkg pkg3.tcl]

makeFile {
#  This package requires pkg2, and it calls
#  a pkg2 proc in the code that is executed by the file.
#  Pkg2 is a split package.
package require pkg2 1.0
package provide pkg5 1.0
namespace eval pkg5 {
    namespace export p5-1 p5-2
    variable m2 [pkg2::p2-1 10]
    variable m3 [pkg2::p2-2 10]
}
proc pkg5::p5-1 { num } {
    variable m2
    return [expr {$m2 * $num}]
}
proc pkg5::p5-2 { num } {
    variable m2
    return [expr {$m2 * $num}]
}
} [file join pkg pkg5.tcl]
d324 2
a325 61
} "0 {{pkg2:1.0 {[list source [file join $fullPkgPath pkg2_a.tcl]]
[list source [file join $fullPkgPath pkg2_b.tcl]]}} {pkg5:1.0 {[list source [file join $fullPkgPath pkg5.tcl]]}}}"

removeFile [file join pkg pkg5.tcl]
removeFile [file join pkg pkg2_a.tcl]
removeFile [file join pkg pkg2_b.tcl]

makeFile {
#  This package requires circ2, and circ2
#  requires circ3, which in turn requires circ1.
#  In case of cirularities, pkg_mkIndex should give up when it gets stuck.
package require circ2 1.0
package provide circ1 1.0
namespace eval circ1 {
    namespace export c1-1 c1-2 c1-3 c1-4
}
proc circ1::c1-1 { num } {
    return [circ2::c2-1 $num]
}
proc circ1::c1-2 { num } {
    return [circ2::c2-2 $num]
}
proc circ1::c1-3 {} {
    return 10
}
proc circ1::c1-4 {} {
    return 20
}
} [file join pkg circ1.tcl]

makeFile {
#  This package is required by circ1, and
#  requires circ3. Circ3, in turn, requires circ1 to give us a circularity.
package require circ3 1.0
package provide circ2 1.0
namespace eval circ2 {
    namespace export c2-1 c2-2
}
proc circ2::c2-1 { num } {
    return [expr $num * [circ3::c3-1]]
}
proc circ2::c2-2 { num } {
    return [expr $num * [circ3::c3-2]]
}
} [file join pkg circ2.tcl]

makeFile {
#  This package is required by circ2, and in
#  turn requires circ1. This closes the circularity.
package require circ1 1.0
package provide circ3 1.0
namespace eval circ3 {
    namespace export c3-1 c3-4
}
proc circ3::c3-1 {} {
    return [circ1::c1-3]
}
proc circ3::c3-2 {} {
    return [circ1::c1-4]
}
} [file join pkg circ3.tcl]
a330 4
removeFile [file join pkg circ1.tcl]
removeFile [file join pkg circ2.tcl]
removeFile [file join pkg circ3.tcl]

d335 1
a335 1
::tcltest::testConstraint $dll [file exists $x]
d337 3
a339 19
if {[testConstraint $dll]} {
makeFile {
#  This package provides Pkga, which is also provided by a DLL.
package provide Pkga 1.0
proc pkga_neq { x } {
    return [expr {! [pkgq_eq $x]}]
}
} [file join pkg pkga.tcl]
file copy -force $x $fullPkgPath
}
testConstraint exec [llength [info commands ::exec]]

test pkgMkIndex-10.1 {package in DLL and script} [list exec $dll] {
    # Do all [load]ing of shared libraries in another process, so 
    # we can delete the file and not get stuck because we're holding
    # a reference to it.
    set cmd [list pkg_mkIndex -lazy $fullPkgPath [file tail $x] pkga.tcl]
    exec [interpreter] << $cmd
    pkgtest::runCreatedIndex {0 {}} -lazy $fullPkgPath pkga[info sharedlibextension] pkga.tcl
d341 2
a342 11
test pkgMkIndex-10.2 {package in DLL hidden by -load} [list exec $dll] {
    # Do all [load]ing of shared libraries in another process, so 
    # we can delete the file and not get stuck because we're holding
    # a reference to it.
    #
    # This test depends on context from prior test, so repeat it.
    set script "[list pkg_mkIndex -lazy $fullPkgPath [file tail $x] pkga.tcl]\n"
    append script \
	    "[list pkg_mkIndex -lazy -load Pkg* $fullPkgPath [file tail $x]]"
    exec [interpreter] << $script
    pkgtest::runCreatedIndex {0 {}} -lazy -load Pkg* -- $fullPkgPath pkga[info sharedlibextension]
a344 5
if {[testConstraint $dll]} {
file delete -force [file join $fullPkgPath [file tail $x]]
removeFile [file join pkg pkga.tcl]
}

a346 15
makeFile {
package provide fubar 1.0
namespace eval ::fubar:: {
    #
    # export only public functions.
    #
    namespace export {[a-z]*}
}
proc ::fubar::foo {bar} {
    puts "$bar"
    return true
}
namespace import ::fubar::foo
} [file join pkg import.tcl]

a350 2
removeFile [file join pkg import.tcl]

a354 24
makeFile {
package provide football 1.0
namespace eval ::pro:: {
    #
    # export only public functions.
    #
    namespace export {[a-z]*}
}
namespace eval ::college:: {
    #
    # export only public functions.
    #
    namespace export {[a-z]*}
}
proc ::pro::team {} {
    puts "go packers!"
    return true
}
proc ::college::team {} {
    puts "go badgers!"
    return true
}
} [file join pkg samename.tcl]

a358 2
removeFile [file join pkg samename.tcl]

a360 6
makeFile {
package provide spacename 1.0
proc {a b} {} {}
proc {c d} {} {}
} [file join pkg spacename.tcl]

a364 22
removeFile [file join pkg spacename.tcl]

# Test the pkg_compareExtension helper function
test pkgMkIndex-14.1 {pkg_compareExtension} {unixOnly} {
    pkg_compareExtension foo.so .so
} 1
test pkgMkIndex-14.2 {pkg_compareExtension} {unixOnly} {
    pkg_compareExtension foo.so.bar .so
} 0
test pkgMkIndex-14.3 {pkg_compareExtension} {unixOnly} {
    pkg_compareExtension foo.so.1 .so
} 1
test pkgMkIndex-14.4 {pkg_compareExtension} {unixOnly} {
    pkg_compareExtension foo.so.1.2 .so
} 1
test pkgMkIndex-14.5 {pkg_compareExtension} {unixOnly} {
    pkg_compareExtension foo .so
} 0
test pkgMkIndex-14.6 {pkg_compareExtension} {unixOnly} {
    pkg_compareExtension foo.so.1.2.bar .so
} 0

a366 2
removeDirectory pkg

d368 1
d371 1
@


1.3.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@d11 1
a11 1
# RCS: @@(#) $Id: pkgMkIndex.test,v 1.23 2002/07/06 18:19:46 dgp Exp $
d14 1
a14 1
    package require tcltest 2
d18 2
a19 1
set fullPkgPath [makeDirectory pkg]
d21 7
d165 1
a165 1

d168 1
a168 1
	eval pkg_mkIndex $options [list $dirPath] $patternList
d240 2
a241 1
proc pkgtest::runCreatedIndex {rv args} {
a258 4
proc pkgtest::runIndex { args } {
    set rv [eval createIndex $args]
    return [eval [list runCreatedIndex $rv] $args]
}
a266 14
makeFile {
#  This is a simple package, just to check basic functionality.
package provide simple 1.0
namespace eval simple {
    namespace export lower upper
}
proc simple::lower { stg } {
    return [string tolower $stg]
}
proc simple::upper { stg } {
    return [string toupper $stg]
}
} [file join pkg simple.tcl]

d273 1
a273 1
} "0 {{simple:1.0 {[list source [file join $fullPkgPath simple.tcl]]}}}"
d277 1
a277 14
} "0 {{simple:1.0 {[list source [file join $fullPkgPath simple.tcl]]}}}"

removeFile [file join pkg simple.tcl]

makeFile {
#  Contains global symbols, used to check that they don't have a leading ::
package provide global 1.0
proc global_lower { stg } {
    return [string tolower $stg]
}
proc global_upper { stg } {
    return [string toupper $stg]
}
} [file join pkg global.tcl]
a282 28
removeFile [file join pkg global.tcl]

makeFile {
#  This package is required by pkg1.
#  This package is split into two files, to test packages that are split
#  over multiple files.
package provide pkg2 1.0
namespace eval pkg2 {
    namespace export p2-1
}
proc pkg2::p2-1 { num } {
    return [expr $num * 2]
}
} [file join pkg pkg2_a.tcl]

makeFile {
#  This package is required by pkg1.
#  This package is split into two files, to test packages that are split
#  over multiple files.
package provide pkg2 1.0
namespace eval pkg2 {
    namespace export p2-2
}
proc pkg2::p2-2 { num } {
    return [expr $num * 3]
}
} [file join pkg pkg2_b.tcl]

d289 2
a290 2
} "0 {{pkg2:1.0 {[list source [file join $fullPkgPath pkg2_a.tcl]]
[list source [file join $fullPkgPath pkg2_b.tcl]]}}}"
d292 5
a296 35
# Add the direct1 directory to auto_path, so that the direct1 package 
# can be found.
set direct1 [makeDirectory direct1]
lappend auto_path $direct1
makeFile {
#  This is referenced by pkgIndex.tcl as a -direct script.
package provide direct1 1.0
namespace eval direct1 {
    namespace export pd1 pd2
}
proc direct1::pd1 { stg } {
    return [string tolower $stg]
}
proc direct1::pd2 { stg } {
    return [string toupper $stg]
}
} [file join direct1 direct1.tcl]
pkg_mkIndex -direct $direct1 direct1.tcl

makeFile {
#  Does a package require of direct1, whose pkgIndex.tcl entry
#  is created above with option -direct.  This tests that pkg_mkIndex
#  can handle code that is sourced in pkgIndex.tcl files.
package require direct1
package provide std 1.0
namespace eval std {
    namespace export p1 p2
}
proc std::p1 { stg } {
    return [string tolower $stg]
}
proc std::p2 { stg } {
    return [string toupper $stg]
}
} [file join pkg std.tcl]
a301 35
removeFile [file join direct1 direct1.tcl]
file delete [file join $direct1 pkgIndex.tcl]
removeDirectory direct1
removeFile [file join pkg std.tcl]

makeFile {
#  This package requires pkg3, but it does
#  not use any of pkg3's procs in the code that is executed by the file
#  (i.e. references to pkg3's procs are in the proc bodies only).
package require pkg3 1.0
package provide pkg1 1.0
namespace eval pkg1 {
    namespace export p1-1 p1-2
}
proc pkg1::p1-1 { num } {
    return [pkg3::p3-1 $num]
}
proc pkg1::p1-2 { num } {
    return [pkg3::p3-2 $num]
}
} [file join pkg pkg1.tcl]

makeFile {
package provide pkg3 1.0
namespace eval pkg3 {
    namespace export p3-1 p3-2
}
proc pkg3::p3-1 { num } {
    return {[expr $num * 2]}
}
proc pkg3::p3-2 { num } {
    return {[expr $num * 3]}
}
} [file join pkg pkg3.tcl]

d308 1
a308 21
} "0 {{pkg1:1.0 {[list source [file join $fullPkgPath pkg1.tcl]]}} {pkg3:1.0 {[list source [file join $fullPkgPath pkg3.tcl]]}}}"

removeFile [file join pkg pkg1.tcl]

makeFile {
#  This package requires pkg3, and it calls
#  a pkg3 proc in the code that is executed by the file
package require pkg3 1.0
package provide pkg4 1.0
namespace eval pkg4 {
    namespace export p4-1 p4-2
    variable m2 [pkg3::p3-1 10]
}
proc pkg4::p4-1 { num } {
    variable m2
    return [expr {$m2 * $num}]
}
proc pkg4::p4-2 { num } {
    return [pkg3::p3-2 $num]
}
} [file join pkg pkg4.tcl]
d316 1
a316 25
} "0 {{pkg3:1.0 {[list source [file join $fullPkgPath pkg3.tcl]]}} {pkg4:1.0 {[list source [file join $fullPkgPath pkg4.tcl]]}}}"

removeFile [file join pkg pkg4.tcl]
removeFile [file join pkg pkg3.tcl]

makeFile {
#  This package requires pkg2, and it calls
#  a pkg2 proc in the code that is executed by the file.
#  Pkg2 is a split package.
package require pkg2 1.0
package provide pkg5 1.0
namespace eval pkg5 {
    namespace export p5-1 p5-2
    variable m2 [pkg2::p2-1 10]
    variable m3 [pkg2::p2-2 10]
}
proc pkg5::p5-1 { num } {
    variable m2
    return [expr {$m2 * $num}]
}
proc pkg5::p5-2 { num } {
    variable m2
    return [expr {$m2 * $num}]
}
} [file join pkg pkg5.tcl]
d324 2
a325 61
} "0 {{pkg2:1.0 {[list source [file join $fullPkgPath pkg2_a.tcl]]
[list source [file join $fullPkgPath pkg2_b.tcl]]}} {pkg5:1.0 {[list source [file join $fullPkgPath pkg5.tcl]]}}}"

removeFile [file join pkg pkg5.tcl]
removeFile [file join pkg pkg2_a.tcl]
removeFile [file join pkg pkg2_b.tcl]

makeFile {
#  This package requires circ2, and circ2
#  requires circ3, which in turn requires circ1.
#  In case of cirularities, pkg_mkIndex should give up when it gets stuck.
package require circ2 1.0
package provide circ1 1.0
namespace eval circ1 {
    namespace export c1-1 c1-2 c1-3 c1-4
}
proc circ1::c1-1 { num } {
    return [circ2::c2-1 $num]
}
proc circ1::c1-2 { num } {
    return [circ2::c2-2 $num]
}
proc circ1::c1-3 {} {
    return 10
}
proc circ1::c1-4 {} {
    return 20
}
} [file join pkg circ1.tcl]

makeFile {
#  This package is required by circ1, and
#  requires circ3. Circ3, in turn, requires circ1 to give us a circularity.
package require circ3 1.0
package provide circ2 1.0
namespace eval circ2 {
    namespace export c2-1 c2-2
}
proc circ2::c2-1 { num } {
    return [expr $num * [circ3::c3-1]]
}
proc circ2::c2-2 { num } {
    return [expr $num * [circ3::c3-2]]
}
} [file join pkg circ2.tcl]

makeFile {
#  This package is required by circ2, and in
#  turn requires circ1. This closes the circularity.
package require circ1 1.0
package provide circ3 1.0
namespace eval circ3 {
    namespace export c3-1 c3-4
}
proc circ3::c3-1 {} {
    return [circ1::c1-3]
}
proc circ3::c3-2 {} {
    return [circ1::c1-4]
}
} [file join pkg circ3.tcl]
a330 4
removeFile [file join pkg circ1.tcl]
removeFile [file join pkg circ2.tcl]
removeFile [file join pkg circ3.tcl]

d335 1
a335 1
::tcltest::testConstraint $dll [file exists $x]
d337 3
a339 19
if {[testConstraint $dll]} {
makeFile {
#  This package provides Pkga, which is also provided by a DLL.
package provide Pkga 1.0
proc pkga_neq { x } {
    return [expr {! [pkgq_eq $x]}]
}
} [file join pkg pkga.tcl]
file copy -force $x $fullPkgPath
}
testConstraint exec [llength [info commands ::exec]]

test pkgMkIndex-10.1 {package in DLL and script} [list exec $dll] {
    # Do all [load]ing of shared libraries in another process, so 
    # we can delete the file and not get stuck because we're holding
    # a reference to it.
    set cmd [list pkg_mkIndex -lazy $fullPkgPath [file tail $x] pkga.tcl]
    exec [interpreter] << $cmd
    pkgtest::runCreatedIndex {0 {}} -lazy $fullPkgPath pkga[info sharedlibextension] pkga.tcl
d341 2
a342 11
test pkgMkIndex-10.2 {package in DLL hidden by -load} [list exec $dll] {
    # Do all [load]ing of shared libraries in another process, so 
    # we can delete the file and not get stuck because we're holding
    # a reference to it.
    #
    # This test depends on context from prior test, so repeat it.
    set script "[list pkg_mkIndex -lazy $fullPkgPath [file tail $x] pkga.tcl]\n"
    append script \
	    "[list pkg_mkIndex -lazy -load Pkg* $fullPkgPath [file tail $x]]"
    exec [interpreter] << $script
    pkgtest::runCreatedIndex {0 {}} -lazy -load Pkg* -- $fullPkgPath pkga[info sharedlibextension]
a344 5
if {[testConstraint $dll]} {
file delete -force [file join $fullPkgPath [file tail $x]]
removeFile [file join pkg pkga.tcl]
}

a346 15
makeFile {
package provide fubar 1.0
namespace eval ::fubar:: {
    #
    # export only public functions.
    #
    namespace export {[a-z]*}
}
proc ::fubar::foo {bar} {
    puts "$bar"
    return true
}
namespace import ::fubar::foo
} [file join pkg import.tcl]

a350 2
removeFile [file join pkg import.tcl]

a354 24
makeFile {
package provide football 1.0
namespace eval ::pro:: {
    #
    # export only public functions.
    #
    namespace export {[a-z]*}
}
namespace eval ::college:: {
    #
    # export only public functions.
    #
    namespace export {[a-z]*}
}
proc ::pro::team {} {
    puts "go packers!"
    return true
}
proc ::college::team {} {
    puts "go badgers!"
    return true
}
} [file join pkg samename.tcl]

a358 2
removeFile [file join pkg samename.tcl]

a360 6
makeFile {
package provide spacename 1.0
proc {a b} {} {}
proc {c d} {} {}
} [file join pkg spacename.tcl]

a364 22
removeFile [file join pkg spacename.tcl]

# Test the pkg_compareExtension helper function
test pkgMkIndex-14.1 {pkg_compareExtension} {unixOnly} {
    pkg_compareExtension foo.so .so
} 1
test pkgMkIndex-14.2 {pkg_compareExtension} {unixOnly} {
    pkg_compareExtension foo.so.bar .so
} 0
test pkgMkIndex-14.3 {pkg_compareExtension} {unixOnly} {
    pkg_compareExtension foo.so.1 .so
} 1
test pkgMkIndex-14.4 {pkg_compareExtension} {unixOnly} {
    pkg_compareExtension foo.so.1.2 .so
} 1
test pkgMkIndex-14.5 {pkg_compareExtension} {unixOnly} {
    pkg_compareExtension foo .so
} 0
test pkgMkIndex-14.6 {pkg_compareExtension} {unixOnly} {
    pkg_compareExtension foo.so.1.2.bar .so
} 0

a366 2
removeDirectory pkg

d368 1
d371 1
@


1.2
log
@touched all Tcl files to ease next import.
@
text
@@


1.2.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.2.16.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d14 1
a14 1
    package require tcltest 2
d18 2
a19 1
set fullPkgPath [makeDirectory pkg]
d21 7
d165 1
a165 1

d168 1
a168 1
	eval pkg_mkIndex $options [list $dirPath] $patternList
d240 2
a241 1
proc pkgtest::runCreatedIndex {rv args} {
a258 4
proc pkgtest::runIndex { args } {
    set rv [eval createIndex $args]
    return [eval [list runCreatedIndex $rv] $args]
}
a266 14
makeFile {
#  This is a simple package, just to check basic functionality.
package provide simple 1.0
namespace eval simple {
    namespace export lower upper
}
proc simple::lower { stg } {
    return [string tolower $stg]
}
proc simple::upper { stg } {
    return [string toupper $stg]
}
} [file join pkg simple.tcl]

d273 1
a273 1
} "0 {{simple:1.0 {[list source [file join $fullPkgPath simple.tcl]]}}}"
d277 1
a277 14
} "0 {{simple:1.0 {[list source [file join $fullPkgPath simple.tcl]]}}}"

removeFile [file join pkg simple.tcl]

makeFile {
#  Contains global symbols, used to check that they don't have a leading ::
package provide global 1.0
proc global_lower { stg } {
    return [string tolower $stg]
}
proc global_upper { stg } {
    return [string toupper $stg]
}
} [file join pkg global.tcl]
a282 28
removeFile [file join pkg global.tcl]

makeFile {
#  This package is required by pkg1.
#  This package is split into two files, to test packages that are split
#  over multiple files.
package provide pkg2 1.0
namespace eval pkg2 {
    namespace export p2-1
}
proc pkg2::p2-1 { num } {
    return [expr $num * 2]
}
} [file join pkg pkg2_a.tcl]

makeFile {
#  This package is required by pkg1.
#  This package is split into two files, to test packages that are split
#  over multiple files.
package provide pkg2 1.0
namespace eval pkg2 {
    namespace export p2-2
}
proc pkg2::p2-2 { num } {
    return [expr $num * 3]
}
} [file join pkg pkg2_b.tcl]

d289 2
a290 2
} "0 {{pkg2:1.0 {[list source [file join $fullPkgPath pkg2_a.tcl]]
[list source [file join $fullPkgPath pkg2_b.tcl]]}}}"
d292 5
a296 35
# Add the direct1 directory to auto_path, so that the direct1 package 
# can be found.
set direct1 [makeDirectory direct1]
lappend auto_path $direct1
makeFile {
#  This is referenced by pkgIndex.tcl as a -direct script.
package provide direct1 1.0
namespace eval direct1 {
    namespace export pd1 pd2
}
proc direct1::pd1 { stg } {
    return [string tolower $stg]
}
proc direct1::pd2 { stg } {
    return [string toupper $stg]
}
} [file join direct1 direct1.tcl]
pkg_mkIndex -direct $direct1 direct1.tcl

makeFile {
#  Does a package require of direct1, whose pkgIndex.tcl entry
#  is created above with option -direct.  This tests that pkg_mkIndex
#  can handle code that is sourced in pkgIndex.tcl files.
package require direct1
package provide std 1.0
namespace eval std {
    namespace export p1 p2
}
proc std::p1 { stg } {
    return [string tolower $stg]
}
proc std::p2 { stg } {
    return [string toupper $stg]
}
} [file join pkg std.tcl]
a301 35
removeFile [file join direct1 direct1.tcl]
file delete [file join $direct1 pkgIndex.tcl]
removeDirectory direct1
removeFile [file join pkg std.tcl]

makeFile {
#  This package requires pkg3, but it does
#  not use any of pkg3's procs in the code that is executed by the file
#  (i.e. references to pkg3's procs are in the proc bodies only).
package require pkg3 1.0
package provide pkg1 1.0
namespace eval pkg1 {
    namespace export p1-1 p1-2
}
proc pkg1::p1-1 { num } {
    return [pkg3::p3-1 $num]
}
proc pkg1::p1-2 { num } {
    return [pkg3::p3-2 $num]
}
} [file join pkg pkg1.tcl]

makeFile {
package provide pkg3 1.0
namespace eval pkg3 {
    namespace export p3-1 p3-2
}
proc pkg3::p3-1 { num } {
    return {[expr $num * 2]}
}
proc pkg3::p3-2 { num } {
    return {[expr $num * 3]}
}
} [file join pkg pkg3.tcl]

d308 1
a308 21
} "0 {{pkg1:1.0 {[list source [file join $fullPkgPath pkg1.tcl]]}} {pkg3:1.0 {[list source [file join $fullPkgPath pkg3.tcl]]}}}"

removeFile [file join pkg pkg1.tcl]

makeFile {
#  This package requires pkg3, and it calls
#  a pkg3 proc in the code that is executed by the file
package require pkg3 1.0
package provide pkg4 1.0
namespace eval pkg4 {
    namespace export p4-1 p4-2
    variable m2 [pkg3::p3-1 10]
}
proc pkg4::p4-1 { num } {
    variable m2
    return [expr {$m2 * $num}]
}
proc pkg4::p4-2 { num } {
    return [pkg3::p3-2 $num]
}
} [file join pkg pkg4.tcl]
d316 1
a316 25
} "0 {{pkg3:1.0 {[list source [file join $fullPkgPath pkg3.tcl]]}} {pkg4:1.0 {[list source [file join $fullPkgPath pkg4.tcl]]}}}"

removeFile [file join pkg pkg4.tcl]
removeFile [file join pkg pkg3.tcl]

makeFile {
#  This package requires pkg2, and it calls
#  a pkg2 proc in the code that is executed by the file.
#  Pkg2 is a split package.
package require pkg2 1.0
package provide pkg5 1.0
namespace eval pkg5 {
    namespace export p5-1 p5-2
    variable m2 [pkg2::p2-1 10]
    variable m3 [pkg2::p2-2 10]
}
proc pkg5::p5-1 { num } {
    variable m2
    return [expr {$m2 * $num}]
}
proc pkg5::p5-2 { num } {
    variable m2
    return [expr {$m2 * $num}]
}
} [file join pkg pkg5.tcl]
d324 2
a325 61
} "0 {{pkg2:1.0 {[list source [file join $fullPkgPath pkg2_a.tcl]]
[list source [file join $fullPkgPath pkg2_b.tcl]]}} {pkg5:1.0 {[list source [file join $fullPkgPath pkg5.tcl]]}}}"

removeFile [file join pkg pkg5.tcl]
removeFile [file join pkg pkg2_a.tcl]
removeFile [file join pkg pkg2_b.tcl]

makeFile {
#  This package requires circ2, and circ2
#  requires circ3, which in turn requires circ1.
#  In case of cirularities, pkg_mkIndex should give up when it gets stuck.
package require circ2 1.0
package provide circ1 1.0
namespace eval circ1 {
    namespace export c1-1 c1-2 c1-3 c1-4
}
proc circ1::c1-1 { num } {
    return [circ2::c2-1 $num]
}
proc circ1::c1-2 { num } {
    return [circ2::c2-2 $num]
}
proc circ1::c1-3 {} {
    return 10
}
proc circ1::c1-4 {} {
    return 20
}
} [file join pkg circ1.tcl]

makeFile {
#  This package is required by circ1, and
#  requires circ3. Circ3, in turn, requires circ1 to give us a circularity.
package require circ3 1.0
package provide circ2 1.0
namespace eval circ2 {
    namespace export c2-1 c2-2
}
proc circ2::c2-1 { num } {
    return [expr $num * [circ3::c3-1]]
}
proc circ2::c2-2 { num } {
    return [expr $num * [circ3::c3-2]]
}
} [file join pkg circ2.tcl]

makeFile {
#  This package is required by circ2, and in
#  turn requires circ1. This closes the circularity.
package require circ1 1.0
package provide circ3 1.0
namespace eval circ3 {
    namespace export c3-1 c3-4
}
proc circ3::c3-1 {} {
    return [circ1::c1-3]
}
proc circ3::c3-2 {} {
    return [circ1::c1-4]
}
} [file join pkg circ3.tcl]
a330 4
removeFile [file join pkg circ1.tcl]
removeFile [file join pkg circ2.tcl]
removeFile [file join pkg circ3.tcl]

d335 1
a335 1
::tcltest::testConstraint $dll [file exists $x]
d337 3
a339 19
if {[testConstraint $dll]} {
makeFile {
#  This package provides Pkga, which is also provided by a DLL.
package provide Pkga 1.0
proc pkga_neq { x } {
    return [expr {! [pkgq_eq $x]}]
}
} [file join pkg pkga.tcl]
file copy -force $x $fullPkgPath
}
testConstraint exec [llength [info commands ::exec]]

test pkgMkIndex-10.1 {package in DLL and script} [list exec $dll] {
    # Do all [load]ing of shared libraries in another process, so 
    # we can delete the file and not get stuck because we're holding
    # a reference to it.
    set cmd [list pkg_mkIndex -lazy $fullPkgPath [file tail $x] pkga.tcl]
    exec [interpreter] << $cmd
    pkgtest::runCreatedIndex {0 {}} -lazy $fullPkgPath pkga[info sharedlibextension] pkga.tcl
d341 2
a342 11
test pkgMkIndex-10.2 {package in DLL hidden by -load} [list exec $dll] {
    # Do all [load]ing of shared libraries in another process, so 
    # we can delete the file and not get stuck because we're holding
    # a reference to it.
    #
    # This test depends on context from prior test, so repeat it.
    set script "[list pkg_mkIndex -lazy $fullPkgPath [file tail $x] pkga.tcl]\n"
    append script \
	    "[list pkg_mkIndex -lazy -load Pkg* $fullPkgPath [file tail $x]]"
    exec [interpreter] << $script
    pkgtest::runCreatedIndex {0 {}} -lazy -load Pkg* -- $fullPkgPath pkga[info sharedlibextension]
a344 5
if {[testConstraint $dll]} {
file delete -force [file join $fullPkgPath [file tail $x]]
removeFile [file join pkg pkga.tcl]
}

a346 15
makeFile {
package provide fubar 1.0
namespace eval ::fubar:: {
    #
    # export only public functions.
    #
    namespace export {[a-z]*}
}
proc ::fubar::foo {bar} {
    puts "$bar"
    return true
}
namespace import ::fubar::foo
} [file join pkg import.tcl]

a350 2
removeFile [file join pkg import.tcl]

a354 24
makeFile {
package provide football 1.0
namespace eval ::pro:: {
    #
    # export only public functions.
    #
    namespace export {[a-z]*}
}
namespace eval ::college:: {
    #
    # export only public functions.
    #
    namespace export {[a-z]*}
}
proc ::pro::team {} {
    puts "go packers!"
    return true
}
proc ::college::team {} {
    puts "go badgers!"
    return true
}
} [file join pkg samename.tcl]

a358 2
removeFile [file join pkg samename.tcl]

a360 6
makeFile {
package provide spacename 1.0
proc {a b} {} {}
proc {c d} {} {}
} [file join pkg spacename.tcl]

a364 22
removeFile [file join pkg spacename.tcl]

# Test the pkg_compareExtension helper function
test pkgMkIndex-14.1 {pkg_compareExtension} {unixOnly} {
    pkg_compareExtension foo.so .so
} 1
test pkgMkIndex-14.2 {pkg_compareExtension} {unixOnly} {
    pkg_compareExtension foo.so.bar .so
} 0
test pkgMkIndex-14.3 {pkg_compareExtension} {unixOnly} {
    pkg_compareExtension foo.so.1 .so
} 1
test pkgMkIndex-14.4 {pkg_compareExtension} {unixOnly} {
    pkg_compareExtension foo.so.1.2 .so
} 1
test pkgMkIndex-14.5 {pkg_compareExtension} {unixOnly} {
    pkg_compareExtension foo .so
} 0
test pkgMkIndex-14.6 {pkg_compareExtension} {unixOnly} {
    pkg_compareExtension foo.so.1.2.bar .so
} 0

a366 2
removeDirectory pkg

d368 1
d371 1
@


1.1
log
@Initial revision
@
text
@d8 1
a8 1
# Copyright (c) 1998 by Scriptics Corporation.
d11 1
a11 1
# RCS: @@(#) $Id: pkgMkIndex.test,v 1.2 1999/01/26 03:53:33 jingham Exp $
d13 9
a21 1
if {[string compare test [info procs test]] == 1} then {source defs}
d27 1
a27 3
set scriptDir [file dirname [info script]]
set oldDir [pwd]
lappend auto_path [file join [pwd] $scriptDir pkg1]
d164 2
d251 1
a251 1
	}
d264 1
a264 1
    list [pkgtest::runIndex pkg nomatch.tcl] [pwd]
d266 1
a266 1
cd $oldDir	;# 'cause 8.0.3 is left in the wrong place
d268 1
a268 1
    pkgtest::runIndex pkg simple.tcl
d272 6
a277 2
    pkgtest::runIndex -direct pkg simple.tcl
} "0 {{simple:1.0 {source [file join pkg simple.tcl]}}}"
d280 1
a280 1
    pkgtest::runIndex pkg global.tcl
d284 1
a284 1
    pkgtest::runIndex pkg pkg2_a.tcl pkg2_b.tcl
d288 3
a290 3
    pkgtest::runIndex -direct pkg pkg2_a.tcl pkg2_b.tcl
} "0 {{pkg2:1.0 {source [file join pkg pkg2_a.tcl]
source [file join pkg pkg2_b.tcl]}}}"
d299 1
a299 1
    pkgtest::runIndex pkg std.tcl
d303 1
a303 1
    pkgtest::runIndex pkg pkg1.tcl pkg3.tcl
d307 2
a308 2
    pkgtest::runIndex -direct pkg pkg1.tcl pkg3.tcl
} "0 {{pkg1:1.0 {source [file join pkg pkg1.tcl]}} {pkg3:1.0 {source [file join pkg pkg3.tcl]}}}"
d311 1
a311 1
    pkgtest::runIndex pkg pkg4.tcl pkg3.tcl
d315 2
a316 2
    pkgtest::runIndex -direct pkg pkg4.tcl pkg3.tcl
} "0 {{pkg3:1.0 {source [file join pkg pkg3.tcl]}} {pkg4:1.0 {source [file join pkg pkg4.tcl]}}}"
d319 1
a319 1
    pkgtest::runIndex pkg pkg5.tcl pkg2_a.tcl pkg2_b.tcl
d323 3
a325 3
    pkgtest::runIndex -direct pkg pkg5.tcl pkg2_a.tcl pkg2_b.tcl
} "0 {{pkg2:1.0 {source [file join pkg pkg2_a.tcl]
source [file join pkg pkg2_b.tcl]}} {pkg5:1.0 {source [file join pkg pkg5.tcl]}}}"
d328 1
a328 1
    pkgtest::runIndex pkg circ1.tcl circ2.tcl circ3.tcl
d331 33
a363 14
# Try to find one of the DLLs in the dltest directory
set x [file join [pwd] [file dirname [info script]]]
set x [file join $x ../unix/dltest/pkga[info sharedlibextension]]
if {[file exists $x]} {
    file copy -force $x pkg
    test pkgMkIndex-10.1 {package in DLL and script} {
	pkgtest::runIndex pkg pkga[info sharedlibextension] pkga.tcl
    } {0 {{Pkga:1.0 {tclPkgSetup {pkga.so load {pkga_eq pkga_quote}} {pkga.tcl source pkga_neq}}}}}
    test pkgMkIndex-10.2 {package in DLL hidden by -load} {
	pkgtest::runIndex -load Pkg* -- pkg pkga[info sharedlibextension]
    } {0 {}}
} else {
    puts "Skipping pkgMkIndex-10.1 (index of DLL and script)"
}
a364 1
#
d366 7
a372 5
#
if {![info exist TESTS]} {
    file delete [file join pkg pkgIndex.tcl]
    namespace delete pkgtest
}
@


1.1.1.1
log
@import dejagnu-1999-11-08 snapshot
@
text
@@


1.1.1.2
log
@Tcl 8.3 upgrade
@
text
@d8 1
a8 1
# Copyright (c) 1998-1999 by Scriptics Corporation.
d11 1
a11 1
# RCS: @@(#) $Id: pkgMkIndex.test,v 1.3.8.2 2000/09/15 16:57:16 spolk Exp $
d13 1
a13 9
if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import -force ::tcltest::*
}

set origDir [pwd]
cd $::tcltest::testsDirectory

set fullPkgPath [file join $::tcltest::testsDirectory pkg]
d19 3
a21 1
lappend auto_path [file join $::tcltest::testsDirectory pkg1]
a157 2
    file mkdir $dirPath
 
d243 1
a243 1
	} 
d256 1
a256 1
    list [pkgtest::runIndex -lazy $fullPkgPath nomatch.tcl] [pwd]
d258 1
a258 1

d260 1
a260 1
    pkgtest::runIndex -lazy $fullPkgPath simple.tcl
d264 2
a265 6
    pkgtest::runIndex -direct $fullPkgPath simple.tcl
} "0 {{simple:1.0 {source [file join $fullPkgPath simple.tcl]}}}"

test pkgMkIndex-2.3 {simple package - direct loading is default} {
    pkgtest::runIndex $fullPkgPath simple.tcl
} "0 {{simple:1.0 {source [file join $fullPkgPath simple.tcl]}}}"
d268 1
a268 1
    pkgtest::runIndex -lazy $fullPkgPath global.tcl
d272 1
a272 1
    pkgtest::runIndex -lazy $fullPkgPath pkg2_a.tcl pkg2_b.tcl
d276 3
a278 3
    pkgtest::runIndex -direct $fullPkgPath pkg2_a.tcl pkg2_b.tcl
} "0 {{pkg2:1.0 {source [file join $fullPkgPath pkg2_a.tcl]
source [file join $fullPkgPath pkg2_b.tcl]}}}"
d287 1
a287 1
    pkgtest::runIndex -lazy $fullPkgPath std.tcl
d291 1
a291 1
    pkgtest::runIndex -lazy $fullPkgPath pkg1.tcl pkg3.tcl
d295 2
a296 2
    pkgtest::runIndex -direct $fullPkgPath pkg1.tcl pkg3.tcl
} "0 {{pkg1:1.0 {source [file join $fullPkgPath pkg1.tcl]}} {pkg3:1.0 {source [file join $fullPkgPath pkg3.tcl]}}}"
d299 1
a299 1
    pkgtest::runIndex -lazy $fullPkgPath pkg4.tcl pkg3.tcl
d303 2
a304 2
    pkgtest::runIndex -direct $fullPkgPath pkg4.tcl pkg3.tcl
} "0 {{pkg3:1.0 {source [file join $fullPkgPath pkg3.tcl]}} {pkg4:1.0 {source [file join $fullPkgPath pkg4.tcl]}}}"
d307 1
a307 1
    pkgtest::runIndex -lazy $fullPkgPath pkg5.tcl pkg2_a.tcl pkg2_b.tcl
d311 3
a313 3
    pkgtest::runIndex -direct $fullPkgPath pkg5.tcl pkg2_a.tcl pkg2_b.tcl
} "0 {{pkg2:1.0 {source [file join $fullPkgPath pkg2_a.tcl]
source [file join $fullPkgPath pkg2_b.tcl]}} {pkg5:1.0 {source [file join $fullPkgPath pkg5.tcl]}}}"
d316 1
a316 1
    pkgtest::runIndex -lazy $fullPkgPath circ1.tcl circ2.tcl circ3.tcl
d319 14
a332 33
# Some tests require the existence of one of the DLLs in the dltest directory
set x [file join [file dirname [info nameofexecutable]] dltest \
	pkga[info sharedlibextension]]
set dll "[file tail $x]Required"
set ::tcltest::testConstraints($dll) [file exists $x]

test pkgMkIndex-10.1 {package in DLL and script} $dll {
    file copy -force $x $fullPkgPath
    pkgtest::runIndex -lazy $fullPkgPath pkga[info sharedlibextension] pkga.tcl
} "0 {{Pkga:1.0 {tclPkgSetup {pkga[info sharedlibextension] load {pkga_eq pkga_quote}} {pkga.tcl source pkga_neq}}}}"
test pkgMkIndex-10.2 {package in DLL hidden by -load} $dll {
    pkgtest::runIndex -lazy -load Pkg* -- $fullPkgPath pkga[info sharedlibextension]
} {0 {}}

# Tolerate "namespace import" at the global scope

test pkgMkIndex-11.1 {conflicting namespace imports} {
    pkgtest::runIndex -lazy $fullPkgPath import.tcl
} {0 {{fubar:1.0 {tclPkgSetup {import.tcl source ::fubar::foo}}}}}

# Verify that the auto load list generated is correct even when there
# is a proc name conflict between two namespaces (ie, ::foo::baz and
# ::bar::baz)

test pkgMkIndex-12.1 {same name procs in different namespace} {
    pkgtest::runIndex -lazy $fullPkgPath samename.tcl
} {0 {{football:1.0 {tclPkgSetup {samename.tcl source {::college::team ::pro::team}}}}}}

# Proc names with embedded spaces are properly listed (ie, correct number of
# braces) in result
test pkgMkIndex-13.1 {proc names with embedded spaces} {
    pkgtest::runIndex -lazy $fullPkgPath spacename.tcl
} {0 {{spacename:1.0 {tclPkgSetup {spacename.tcl source {{a b} {c d}}}}}}}
d334 1
d336 5
a340 7

namespace delete pkgtest
cd $origDir
::tcltest::cleanupTests
return


@


1.1.1.3
log
@import tcl 8.4.0
@
text
@d11 1
a11 1
# RCS: @@(#) $Id: pkgMkIndex.test,v 1.23 2002/07/06 18:19:46 dgp Exp $
d14 1
a14 1
    package require tcltest 2
d18 2
a19 1
set fullPkgPath [makeDirectory pkg]
d21 7
d165 1
a165 1

d168 1
a168 1
	eval pkg_mkIndex $options [list $dirPath] $patternList
d240 2
a241 1
proc pkgtest::runCreatedIndex {rv args} {
a258 4
proc pkgtest::runIndex { args } {
    set rv [eval createIndex $args]
    return [eval [list runCreatedIndex $rv] $args]
}
a266 14
makeFile {
#  This is a simple package, just to check basic functionality.
package provide simple 1.0
namespace eval simple {
    namespace export lower upper
}
proc simple::lower { stg } {
    return [string tolower $stg]
}
proc simple::upper { stg } {
    return [string toupper $stg]
}
} [file join pkg simple.tcl]

d273 1
a273 1
} "0 {{simple:1.0 {[list source [file join $fullPkgPath simple.tcl]]}}}"
d277 1
a277 14
} "0 {{simple:1.0 {[list source [file join $fullPkgPath simple.tcl]]}}}"

removeFile [file join pkg simple.tcl]

makeFile {
#  Contains global symbols, used to check that they don't have a leading ::
package provide global 1.0
proc global_lower { stg } {
    return [string tolower $stg]
}
proc global_upper { stg } {
    return [string toupper $stg]
}
} [file join pkg global.tcl]
a282 28
removeFile [file join pkg global.tcl]

makeFile {
#  This package is required by pkg1.
#  This package is split into two files, to test packages that are split
#  over multiple files.
package provide pkg2 1.0
namespace eval pkg2 {
    namespace export p2-1
}
proc pkg2::p2-1 { num } {
    return [expr $num * 2]
}
} [file join pkg pkg2_a.tcl]

makeFile {
#  This package is required by pkg1.
#  This package is split into two files, to test packages that are split
#  over multiple files.
package provide pkg2 1.0
namespace eval pkg2 {
    namespace export p2-2
}
proc pkg2::p2-2 { num } {
    return [expr $num * 3]
}
} [file join pkg pkg2_b.tcl]

d289 2
a290 2
} "0 {{pkg2:1.0 {[list source [file join $fullPkgPath pkg2_a.tcl]]
[list source [file join $fullPkgPath pkg2_b.tcl]]}}}"
d292 5
a296 35
# Add the direct1 directory to auto_path, so that the direct1 package 
# can be found.
set direct1 [makeDirectory direct1]
lappend auto_path $direct1
makeFile {
#  This is referenced by pkgIndex.tcl as a -direct script.
package provide direct1 1.0
namespace eval direct1 {
    namespace export pd1 pd2
}
proc direct1::pd1 { stg } {
    return [string tolower $stg]
}
proc direct1::pd2 { stg } {
    return [string toupper $stg]
}
} [file join direct1 direct1.tcl]
pkg_mkIndex -direct $direct1 direct1.tcl

makeFile {
#  Does a package require of direct1, whose pkgIndex.tcl entry
#  is created above with option -direct.  This tests that pkg_mkIndex
#  can handle code that is sourced in pkgIndex.tcl files.
package require direct1
package provide std 1.0
namespace eval std {
    namespace export p1 p2
}
proc std::p1 { stg } {
    return [string tolower $stg]
}
proc std::p2 { stg } {
    return [string toupper $stg]
}
} [file join pkg std.tcl]
a301 35
removeFile [file join direct1 direct1.tcl]
file delete [file join $direct1 pkgIndex.tcl]
removeDirectory direct1
removeFile [file join pkg std.tcl]

makeFile {
#  This package requires pkg3, but it does
#  not use any of pkg3's procs in the code that is executed by the file
#  (i.e. references to pkg3's procs are in the proc bodies only).
package require pkg3 1.0
package provide pkg1 1.0
namespace eval pkg1 {
    namespace export p1-1 p1-2
}
proc pkg1::p1-1 { num } {
    return [pkg3::p3-1 $num]
}
proc pkg1::p1-2 { num } {
    return [pkg3::p3-2 $num]
}
} [file join pkg pkg1.tcl]

makeFile {
package provide pkg3 1.0
namespace eval pkg3 {
    namespace export p3-1 p3-2
}
proc pkg3::p3-1 { num } {
    return {[expr $num * 2]}
}
proc pkg3::p3-2 { num } {
    return {[expr $num * 3]}
}
} [file join pkg pkg3.tcl]

d308 1
a308 21
} "0 {{pkg1:1.0 {[list source [file join $fullPkgPath pkg1.tcl]]}} {pkg3:1.0 {[list source [file join $fullPkgPath pkg3.tcl]]}}}"

removeFile [file join pkg pkg1.tcl]

makeFile {
#  This package requires pkg3, and it calls
#  a pkg3 proc in the code that is executed by the file
package require pkg3 1.0
package provide pkg4 1.0
namespace eval pkg4 {
    namespace export p4-1 p4-2
    variable m2 [pkg3::p3-1 10]
}
proc pkg4::p4-1 { num } {
    variable m2
    return [expr {$m2 * $num}]
}
proc pkg4::p4-2 { num } {
    return [pkg3::p3-2 $num]
}
} [file join pkg pkg4.tcl]
d316 1
a316 25
} "0 {{pkg3:1.0 {[list source [file join $fullPkgPath pkg3.tcl]]}} {pkg4:1.0 {[list source [file join $fullPkgPath pkg4.tcl]]}}}"

removeFile [file join pkg pkg4.tcl]
removeFile [file join pkg pkg3.tcl]

makeFile {
#  This package requires pkg2, and it calls
#  a pkg2 proc in the code that is executed by the file.
#  Pkg2 is a split package.
package require pkg2 1.0
package provide pkg5 1.0
namespace eval pkg5 {
    namespace export p5-1 p5-2
    variable m2 [pkg2::p2-1 10]
    variable m3 [pkg2::p2-2 10]
}
proc pkg5::p5-1 { num } {
    variable m2
    return [expr {$m2 * $num}]
}
proc pkg5::p5-2 { num } {
    variable m2
    return [expr {$m2 * $num}]
}
} [file join pkg pkg5.tcl]
d324 2
a325 61
} "0 {{pkg2:1.0 {[list source [file join $fullPkgPath pkg2_a.tcl]]
[list source [file join $fullPkgPath pkg2_b.tcl]]}} {pkg5:1.0 {[list source [file join $fullPkgPath pkg5.tcl]]}}}"

removeFile [file join pkg pkg5.tcl]
removeFile [file join pkg pkg2_a.tcl]
removeFile [file join pkg pkg2_b.tcl]

makeFile {
#  This package requires circ2, and circ2
#  requires circ3, which in turn requires circ1.
#  In case of cirularities, pkg_mkIndex should give up when it gets stuck.
package require circ2 1.0
package provide circ1 1.0
namespace eval circ1 {
    namespace export c1-1 c1-2 c1-3 c1-4
}
proc circ1::c1-1 { num } {
    return [circ2::c2-1 $num]
}
proc circ1::c1-2 { num } {
    return [circ2::c2-2 $num]
}
proc circ1::c1-3 {} {
    return 10
}
proc circ1::c1-4 {} {
    return 20
}
} [file join pkg circ1.tcl]

makeFile {
#  This package is required by circ1, and
#  requires circ3. Circ3, in turn, requires circ1 to give us a circularity.
package require circ3 1.0
package provide circ2 1.0
namespace eval circ2 {
    namespace export c2-1 c2-2
}
proc circ2::c2-1 { num } {
    return [expr $num * [circ3::c3-1]]
}
proc circ2::c2-2 { num } {
    return [expr $num * [circ3::c3-2]]
}
} [file join pkg circ2.tcl]

makeFile {
#  This package is required by circ2, and in
#  turn requires circ1. This closes the circularity.
package require circ1 1.0
package provide circ3 1.0
namespace eval circ3 {
    namespace export c3-1 c3-4
}
proc circ3::c3-1 {} {
    return [circ1::c1-3]
}
proc circ3::c3-2 {} {
    return [circ1::c1-4]
}
} [file join pkg circ3.tcl]
a330 4
removeFile [file join pkg circ1.tcl]
removeFile [file join pkg circ2.tcl]
removeFile [file join pkg circ3.tcl]

d335 1
a335 1
::tcltest::testConstraint $dll [file exists $x]
d337 3
a339 19
if {[testConstraint $dll]} {
makeFile {
#  This package provides Pkga, which is also provided by a DLL.
package provide Pkga 1.0
proc pkga_neq { x } {
    return [expr {! [pkgq_eq $x]}]
}
} [file join pkg pkga.tcl]
file copy -force $x $fullPkgPath
}
testConstraint exec [llength [info commands ::exec]]

test pkgMkIndex-10.1 {package in DLL and script} [list exec $dll] {
    # Do all [load]ing of shared libraries in another process, so 
    # we can delete the file and not get stuck because we're holding
    # a reference to it.
    set cmd [list pkg_mkIndex -lazy $fullPkgPath [file tail $x] pkga.tcl]
    exec [interpreter] << $cmd
    pkgtest::runCreatedIndex {0 {}} -lazy $fullPkgPath pkga[info sharedlibextension] pkga.tcl
d341 2
a342 11
test pkgMkIndex-10.2 {package in DLL hidden by -load} [list exec $dll] {
    # Do all [load]ing of shared libraries in another process, so 
    # we can delete the file and not get stuck because we're holding
    # a reference to it.
    #
    # This test depends on context from prior test, so repeat it.
    set script "[list pkg_mkIndex -lazy $fullPkgPath [file tail $x] pkga.tcl]\n"
    append script \
	    "[list pkg_mkIndex -lazy -load Pkg* $fullPkgPath [file tail $x]]"
    exec [interpreter] << $script
    pkgtest::runCreatedIndex {0 {}} -lazy -load Pkg* -- $fullPkgPath pkga[info sharedlibextension]
a344 5
if {[testConstraint $dll]} {
file delete -force [file join $fullPkgPath [file tail $x]]
removeFile [file join pkg pkga.tcl]
}

a346 15
makeFile {
package provide fubar 1.0
namespace eval ::fubar:: {
    #
    # export only public functions.
    #
    namespace export {[a-z]*}
}
proc ::fubar::foo {bar} {
    puts "$bar"
    return true
}
namespace import ::fubar::foo
} [file join pkg import.tcl]

a350 2
removeFile [file join pkg import.tcl]

a354 24
makeFile {
package provide football 1.0
namespace eval ::pro:: {
    #
    # export only public functions.
    #
    namespace export {[a-z]*}
}
namespace eval ::college:: {
    #
    # export only public functions.
    #
    namespace export {[a-z]*}
}
proc ::pro::team {} {
    puts "go packers!"
    return true
}
proc ::college::team {} {
    puts "go badgers!"
    return true
}
} [file join pkg samename.tcl]

a358 2
removeFile [file join pkg samename.tcl]

a360 6
makeFile {
package provide spacename 1.0
proc {a b} {} {}
proc {c d} {} {}
} [file join pkg spacename.tcl]

a364 22
removeFile [file join pkg spacename.tcl]

# Test the pkg_compareExtension helper function
test pkgMkIndex-14.1 {pkg_compareExtension} {unixOnly} {
    pkg_compareExtension foo.so .so
} 1
test pkgMkIndex-14.2 {pkg_compareExtension} {unixOnly} {
    pkg_compareExtension foo.so.bar .so
} 0
test pkgMkIndex-14.3 {pkg_compareExtension} {unixOnly} {
    pkg_compareExtension foo.so.1 .so
} 1
test pkgMkIndex-14.4 {pkg_compareExtension} {unixOnly} {
    pkg_compareExtension foo.so.1.2 .so
} 1
test pkgMkIndex-14.5 {pkg_compareExtension} {unixOnly} {
    pkg_compareExtension foo .so
} 0
test pkgMkIndex-14.6 {pkg_compareExtension} {unixOnly} {
    pkg_compareExtension foo.so.1.2.bar .so
} 0

a366 2
removeDirectory pkg

d368 1
d371 1
@


