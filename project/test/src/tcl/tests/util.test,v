head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.58
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.56
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.54
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.52
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.50
	gdb_7_0-branch:1.5.0.48
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tcl8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.46
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.44
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.42
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.40
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.38
	gdb_6_5-2006-05-14-branchpoint:1.5
	readline_5_1-import-branch:1.5.0.36
	readline_5_1-import-branchpoint:1.5
	gdb_6_4-branch:1.5.0.34
	gdb_6_4-2005-11-01-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.32
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	ezannoni_pie-20040323-branch:1.5.0.30
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.28
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.26
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.24
	cagney_x86i386-20030821-branch:1.5.0.22
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.20
	gdb_6_0-2003-06-23-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.18
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.16
	cagney_writestrings-20030508-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.14
	cagney_fileio-20030521-branchpoint:1.5
	carlton_dictionary-20030430-merge:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.12
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.10
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.8
	cagney_lazyid-20030317-branchpoint:1.5
	offbyone-20030313-branch:1.5.0.6
	offbyone-20030313-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.4
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.2
	interps-20030202-branchpoint:1.5
	TCL8_4_1:1.1.1.5
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.2
	TCL_8_4_1:1.1.1.5
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.4
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TK_8_4_0:1.1.1.4
	TCL_8_4_0:1.1.1.5
	carlton_dictionary-branch:1.2.0.16
	carlton_dictionary-20020920-branchpoint:1.2
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.14
	gdb_5_3-branch:1.2.0.12
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.10
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.8
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.6
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TCL_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	dejagnu-2000-02-04:1.1.1.1
	dejagnu-2000-01-31:1.1.1.1
	dejagnu-2000-01-24:1.1.1.1
	dejagnu-2000-01-17:1.1.1.1
	dejagnu-2000-01-10:1.1.1.1
	dejagnu-2000-01-04:1.1.1.1
	dejagnu-1999-12-21:1.1.1.1
	dejagnu-1999-12-13:1.1.1.1
	dejagnu-1999-12-07:1.1.1.1
	dejagnu-1999-12-06:1.1.1.1
	dejagnu-1999-11-15:1.1.1.1
	dejagnu-1999-11-08:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2003.01.21.19.40.17;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.26.19.48.03;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.37.08;	author kseitz;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2001.09.09.23.56.08;	author irox;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2002.09.27.21.49.11;	author kseitz;	state Exp;
branches;
next	;

1.3.4.1
date	2003.12.14.20.28.50;	author drow;	state Exp;
branches;
next	;

1.2.16.1
date	2002.12.23.19.40.46;	author carlton;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2003.02.07.19.18.20;	author carlton;	state Exp;
branches;
next	;

1.1.1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.09.22.40.59;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.19.56.41;	author kseitz;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.09.24.20.25.32;	author kseitz;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.09.24.22.01.41;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tcl 8.4.1
@
text
@# This file is a Tcl script to test the code in the file tclUtil.c.
# This file is organized in the standard fashion for Tcl tests.
#
# Copyright (c) 1995-1998 Sun Microsystems, Inc.
# Copyright (c) 1998-1999 by Scriptics Corporation.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# RCS: @@(#) $Id: util.test,v 1.10 2002/01/02 13:52:04 dkf Exp $

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import -force ::tcltest::*
}

if {[info commands testobj] == {}} {
    puts "This application hasn't been compiled with the \"testobj\""
    puts "command, so I can't test the Tcl type and object support."
    ::tcltest::cleanupTests
    return
}

test util-1.1 {TclFindElement procedure - binary element in middle of list} {
    lindex {0 foo\x00help 1} 1
} "foo\x00help"
test util-1.2 {TclFindElement procedure - binary element at end of list} {
    lindex {0 foo\x00help} 1
} "foo\x00help"

test util-2.1 {TclCopyAndCollapse procedure - normal string} {
    lindex {0 foo} 1
} {foo}
test util-2.2 {TclCopyAndCollapse procedure - string with backslashes} {
    lindex {0 foo\n\x00help 1} 1
} "foo\n\x00help"

test util-3.1 {Tcl_ScanCountedElement procedure - don't leave unmatched braces} {
    # This test checks for a very tricky feature.  Any list element
    # generated with Tcl_ScanCountedElement and Tcl_ConvertElement must
    # have the property that it can be enclosing in curly braces to make
    # an embedded sub-list.  If this property doesn't hold, then
    # Tcl_DStringStartSublist doesn't work.

    set x {}
    lappend x " \\\{ \\"
    concat $x [llength "{$x}"]
} {\ \\\{\ \\ 1}

test util-4.1 {Tcl_ConcatObj - backslash-space at end of argument} {
    concat a {b\ } c
} {a b\  c}
test util-4.2 {Tcl_ConcatObj - backslash-space at end of argument} {
    concat a {b\   } c
} {a b\  c}
test util-4.3 {Tcl_ConcatObj - backslash-space at end of argument} {
    concat a {b\\   } c
} {a b\\  c}
test util-4.4 {Tcl_ConcatObj - backslash-space at end of argument} {
    concat a {b } c
} {a b c}
test util-4.5 {Tcl_ConcatObj - backslash-space at end of argument} {
    concat a { } c
} {a c}
test util-4.6 {Tcl_ConcatObj - utf-8 sequence with "whitespace" char} {
    # Check for Bug #227512.  If this violates C isspace, then it returns \xc3.
    concat \xe0
} \xe0

proc Wrapper_Tcl_StringMatch {pattern string} {
    # Forces use of Tcl_StringMatch, not Tcl_UniCharCaseMatch
    switch -glob -- $string $pattern {return 1} default {return 0}
}
test util-5.1 {Tcl_StringMatch} {
    Wrapper_Tcl_StringMatch ab*c abc
} 1
test util-5.2 {Tcl_StringMatch} {
    Wrapper_Tcl_StringMatch ab**c abc
} 1
test util-5.3 {Tcl_StringMatch} {
    Wrapper_Tcl_StringMatch ab* abcdef
} 1
test util-5.4 {Tcl_StringMatch} {
    Wrapper_Tcl_StringMatch *c abc
} 1
test util-5.5 {Tcl_StringMatch} {
    Wrapper_Tcl_StringMatch *3*6*9 0123456789
} 1
test util-5.6 {Tcl_StringMatch} {
    Wrapper_Tcl_StringMatch *3*6*9 01234567890
} 0
test util-5.7 {Tcl_StringMatch: UTF-8} {
    Wrapper_Tcl_StringMatch *u \u4e4fu
} 1
test util-5.8 {Tcl_StringMatch} {
    Wrapper_Tcl_StringMatch a?c abc
} 1
test util-5.9 {Tcl_StringMatch: UTF-8} {
    # skip one character in string

    Wrapper_Tcl_StringMatch a?c a\u4e4fc
} 1
test util-5.10 {Tcl_StringMatch} {
    Wrapper_Tcl_StringMatch a??c abc
} 0
test util-5.11 {Tcl_StringMatch} {
    Wrapper_Tcl_StringMatch ?1??4???8? 0123456789
} 1
test util-5.12 {Tcl_StringMatch} {
    Wrapper_Tcl_StringMatch {[abc]bc} abc
} 1
test util-5.13 {Tcl_StringMatch: UTF-8} {
    # string += Tcl_UtfToUniChar(string, &ch);

    Wrapper_Tcl_StringMatch "\[\u4e4fxy\]bc" "\u4e4fbc"
} 1
test util-5.14 {Tcl_StringMatch} {
    # if ((*pattern == ']') || (*pattern == '\0'))
    # badly formed pattern

    Wrapper_Tcl_StringMatch {[]} {[]}
} 0
test util-5.15 {Tcl_StringMatch} {
    # if ((*pattern == ']') || (*pattern == '\0'))
    # badly formed pattern

    Wrapper_Tcl_StringMatch {[} {[}
} 0
test util-5.16 {Tcl_StringMatch} {
    Wrapper_Tcl_StringMatch {a[abc]c} abc
} 1
test util-5.17 {Tcl_StringMatch: UTF-8} {
    # pattern += Tcl_UtfToUniChar(pattern, &endChar);
    # get 1 UTF-8 character

    Wrapper_Tcl_StringMatch "a\[a\u4e4fc]c" "a\u4e4fc"
} 1
test util-5.18 {Tcl_StringMatch: UTF-8} {
    # pattern += Tcl_UtfToUniChar(pattern, &endChar);
    # proper advance: wrong answer would match on UTF trail byte of \u4e4f

    Wrapper_Tcl_StringMatch {a[a\u4e4fc]c} [bytestring a\u008fc]
} 0
test util-5.19 {Tcl_StringMatch: UTF-8} {
    # pattern += Tcl_UtfToUniChar(pattern, &endChar);
    # proper advance.

    Wrapper_Tcl_StringMatch {a[a\u4e4fc]c} "acc"
} 1
test util-5.20 {Tcl_StringMatch} {
    Wrapper_Tcl_StringMatch {a[xyz]c} abc
} 0
test util-5.21 {Tcl_StringMatch} {
    Wrapper_Tcl_StringMatch {12[2-7]45} 12345
} 1
test util-5.22 {Tcl_StringMatch: UTF-8 range} {
    Wrapper_Tcl_StringMatch "\[\u4e00-\u4e4f]" "0"
} 0
test util-5.23 {Tcl_StringMatch: UTF-8 range} {
    Wrapper_Tcl_StringMatch "\[\u4e00-\u4e4f]" "\u4e33"
} 1
test util-5.24 {Tcl_StringMatch: UTF-8 range} {
    Wrapper_Tcl_StringMatch "\[\u4e00-\u4e4f]" "\uff08"
} 0
test util-5.25 {Tcl_StringMatch} {
    Wrapper_Tcl_StringMatch {12[ab2-4cd]45} 12345
} 1
test util-5.26 {Tcl_StringMatch} {
    Wrapper_Tcl_StringMatch {12[ab2-4cd]45} 12b45
} 1
test util-5.27 {Tcl_StringMatch} {
    Wrapper_Tcl_StringMatch {12[ab2-4cd]45} 12d45
} 1
test util-5.28 {Tcl_StringMatch} {
    Wrapper_Tcl_StringMatch {12[ab2-4cd]45} 12145
} 0
test util-5.29 {Tcl_StringMatch} {
    Wrapper_Tcl_StringMatch {12[ab2-4cd]45} 12545
} 0
test util-5.30 {Tcl_StringMatch: forwards range} {
    Wrapper_Tcl_StringMatch {[k-w]} "z"
} 0
test util-5.31 {Tcl_StringMatch: forwards range} {
    Wrapper_Tcl_StringMatch {[k-w]} "w"
} 1
test util-5.32 {Tcl_StringMatch: forwards range} {
    Wrapper_Tcl_StringMatch {[k-w]} "r"
} 1
test util-5.33 {Tcl_StringMatch: forwards range} {
    Wrapper_Tcl_StringMatch {[k-w]} "k"
} 1
test util-5.34 {Tcl_StringMatch: forwards range} {
    Wrapper_Tcl_StringMatch {[k-w]} "a"
} 0
test util-5.35 {Tcl_StringMatch: reverse range} {
    Wrapper_Tcl_StringMatch {[w-k]} "z"
} 0
test util-5.36 {Tcl_StringMatch: reverse range} {
    Wrapper_Tcl_StringMatch {[w-k]} "w"
} 1
test util-5.37 {Tcl_StringMatch: reverse range} {
    Wrapper_Tcl_StringMatch {[w-k]} "r"
} 1
test util-5.38 {Tcl_StringMatch: reverse range} {
    Wrapper_Tcl_StringMatch {[w-k]} "k"
} 1
test util-5.39 {Tcl_StringMatch: reverse range} {
    Wrapper_Tcl_StringMatch {[w-k]} "a"
} 0
test util-5.40 {Tcl_StringMatch: skip correct number of ']'} {
    Wrapper_Tcl_StringMatch {[A-]x} Ax
} 0
test util-5.41 {Tcl_StringMatch: skip correct number of ']'} {
    Wrapper_Tcl_StringMatch {[A-]]x} Ax
} 1
test util-5.42 {Tcl_StringMatch: skip correct number of ']'} {
    Wrapper_Tcl_StringMatch {[A-]]x} \ue1x
} 0
test util-5.43 {Tcl_StringMatch: skip correct number of ']'} {
    Wrapper_Tcl_StringMatch \[A-]\ue1]x \ue1x
} 1
test util-5.44 {Tcl_StringMatch: skip correct number of ']'} {
    Wrapper_Tcl_StringMatch {[A-]h]x} hx
} 1
test util-5.45 {Tcl_StringMatch} {
    # if (*pattern == '\0')
    # badly formed pattern, still treats as a set

    Wrapper_Tcl_StringMatch {[a} a
} 1
test util-5.46 {Tcl_StringMatch} {
    Wrapper_Tcl_StringMatch {a\*b} a*b
} 1
test util-5.47 {Tcl_StringMatch} {
    Wrapper_Tcl_StringMatch {a\*b} ab
} 0
test util-5.48 {Tcl_StringMatch} {
    Wrapper_Tcl_StringMatch {a\*\?\[\]\\\x} "a*?\[\]\\x"
} 1
test util-5.49 {Tcl_StringMatch} {
    Wrapper_Tcl_StringMatch ** ""
} 1
test util-5.50 {Tcl_StringMatch} {
    Wrapper_Tcl_StringMatch *. ""
} 0
test util-5.51 {Tcl_StringMatch} {
    Wrapper_Tcl_StringMatch "" ""
} 1

test util-6.1 {Tcl_PrintDouble - using tcl_precision} {
    concat x[expr 1.4]
} {x1.4}
test util-6.2 {Tcl_PrintDouble - using tcl_precision} {
    concat x[expr 1.39999999999]
} {x1.39999999999}
test util-6.3 {Tcl_PrintDouble - using tcl_precision} {
    concat x[expr 1.399999999999]
} {x1.4}
test util-6.4 {Tcl_PrintDouble - using tcl_precision} {
    set tcl_precision 5
    concat x[expr 1.123412341234]
} {x1.1234}
set tcl_precision 12
test util-6.5 {Tcl_PrintDouble - make sure there's a decimal point} {
    concat x[expr 2.0]
} {x2.0}
test util-6.6 {Tcl_PrintDouble - make sure there's a decimal point} {eformat} {
    concat x[expr 3.0e98]
} {x3e+98}

test util-7.1 {TclPrecTraceProc - unset callbacks} {
    set tcl_precision 7
    set x $tcl_precision
    unset tcl_precision
    list $x $tcl_precision
} {7 7}
test util-7.2 {TclPrecTraceProc - read traces, sharing among interpreters} {
    set tcl_precision 12
    interp create child
    set x [child eval set tcl_precision]
    child eval {set tcl_precision 6}
    interp delete child
    list $x $tcl_precision
} {12 6}
test util-7.3 {TclPrecTraceProc - write traces, safe interpreters} {
    set tcl_precision 12
    interp create -safe child
    set x [child eval {
	list [catch {set tcl_precision 8} msg] $msg
    }]
    interp delete child
    list $x $tcl_precision
} {{1 {can't set "tcl_precision": can't modify precision from a safe interpreter}} 12}
test util-7.4 {TclPrecTraceProc - write traces, bogus values} {
    set tcl_precision 12
    list [catch {set tcl_precision abc} msg] $msg $tcl_precision
} {1 {can't set "tcl_precision": improper value for precision} 12}

set tcl_precision 12

# This test always succeeded in the C locale anyway...
test util-8.1 {TclNeedSpace - correct UTF8 handling} {
    interp create \u5420
    interp create [list \u5420 foo]
    interp alias {} fooset [list \u5420 foo] set
    set result [interp target {} fooset]
    interp delete \u5420
    set result
} "\u5420 foo"

# cleanup
::tcltest::cleanupTests
return
@


1.4
log
@touched all sources to ease next import
@
text
@d10 1
a10 1
# RCS: @@(#) $Id: util.test,v 1.6.8.2 2000/09/15 16:57:54 spolk Exp $
d65 9
a73 1

d75 1
a75 1
    string match ab*c abc
d78 1
a78 1
    string match ab**c abc
d81 1
a81 1
    string match ab* abcdef
d84 1
a84 1
    string match *c abc
d87 1
a87 1
    string match *3*6*9 0123456789
d90 1
a90 1
    string match *3*6*9 01234567890
d93 1
a93 1
    string match *u \u4e4fu
d96 1
a96 1
    string match a?c abc
d101 1
a101 1
    string match a?c a\u4e4fc
d104 1
a104 1
    string match a??c abc
d107 1
a107 1
    string match ?1??4???8? 0123456789
d110 1
a110 1
    string match {[abc]bc} abc
d115 1
a115 1
    string match "\[\u4e4fxy\]bc" "\u4e4fbc"
d121 1
a121 1
    string match {[]} {[]}
d127 1
a127 1
    string match {[} {[}
d130 1
a130 1
    string match {a[abc]c} abc
d136 1
a136 1
    string match "a\[a\u4e4fc]c" "a\u4e4fc"
d142 1
a142 1
    string match {a[a\u4e4fc]c} [bytestring a\u008fc]
d148 1
a148 1
    string match {a[a\u4e4fc]c} "acc"
d151 1
a151 1
    string match {a[xyz]c} abc
d154 1
a154 1
    string match {12[2-7]45} 12345
d157 1
a157 1
    string match "\[\u4e00-\u4e4f]" "0"
d160 1
a160 1
    string match "\[\u4e00-\u4e4f]" "\u4e33"
d163 1
a163 1
    string match "\[\u4e00-\u4e4f]" "\uff08"
d166 1
a166 1
    string match {12[ab2-4cd]45} 12345
d169 1
a169 1
    string match {12[ab2-4cd]45} 12b45
d172 1
a172 1
    string match {12[ab2-4cd]45} 12d45
d175 1
a175 1
    string match {12[ab2-4cd]45} 12145
d178 1
a178 1
    string match {12[ab2-4cd]45} 12545
d181 1
a181 1
    string match {[k-w]} "z"
d184 1
a184 1
    string match {[k-w]} "w"
d187 1
a187 1
    string match {[k-w]} "r"
d190 1
a190 1
    string match {[k-w]} "k"
d193 1
a193 1
    string match {[k-w]} "a"
d196 1
a196 1
    string match {[w-k]} "z"
d199 1
a199 1
    string match {[w-k]} "w"
d202 1
a202 1
    string match {[w-k]} "r"
d205 1
a205 1
    string match {[w-k]} "k"
d208 1
a208 1
    string match {[w-k]} "a"
d211 1
a211 1
    string match {[A-]x} Ax
d214 1
a214 1
    string match {[A-]]x} Ax
d217 1
a217 1
    string match {[A-]]x} \ue1x
d220 1
a220 1
    string match \[A-]\ue1]x \ue1x
d223 1
a223 1
    string match {[A-]h]x} hx
d229 1
a229 1
    string match {[a} a
d232 1
a232 1
    string match {a\*b} a*b
d235 1
a235 1
    string match {a\*b} ab
d238 1
a238 1
    string match {a\*\?\[\]\\\x} "a*?\[\]\\x"
d241 1
a241 1
    string match ** ""
d244 1
a244 1
    string match *. ""
d247 1
a247 1
    string match "" ""
d301 10
a313 13













@


1.3
log
@touched all sources to ease next import
@
text
@@


1.3.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d10 1
a10 1
# RCS: @@(#) $Id: util.test,v 1.10 2002/01/02 13:52:04 dkf Exp $
d65 1
a65 9
test util-4.6 {Tcl_ConcatObj - utf-8 sequence with "whitespace" char} {
    # Check for Bug #227512.  If this violates C isspace, then it returns \xc3.
    concat \xe0
} \xe0

proc Wrapper_Tcl_StringMatch {pattern string} {
    # Forces use of Tcl_StringMatch, not Tcl_UniCharCaseMatch
    switch -glob -- $string $pattern {return 1} default {return 0}
}
d67 1
a67 1
    Wrapper_Tcl_StringMatch ab*c abc
d70 1
a70 1
    Wrapper_Tcl_StringMatch ab**c abc
d73 1
a73 1
    Wrapper_Tcl_StringMatch ab* abcdef
d76 1
a76 1
    Wrapper_Tcl_StringMatch *c abc
d79 1
a79 1
    Wrapper_Tcl_StringMatch *3*6*9 0123456789
d82 1
a82 1
    Wrapper_Tcl_StringMatch *3*6*9 01234567890
d85 1
a85 1
    Wrapper_Tcl_StringMatch *u \u4e4fu
d88 1
a88 1
    Wrapper_Tcl_StringMatch a?c abc
d93 1
a93 1
    Wrapper_Tcl_StringMatch a?c a\u4e4fc
d96 1
a96 1
    Wrapper_Tcl_StringMatch a??c abc
d99 1
a99 1
    Wrapper_Tcl_StringMatch ?1??4???8? 0123456789
d102 1
a102 1
    Wrapper_Tcl_StringMatch {[abc]bc} abc
d107 1
a107 1
    Wrapper_Tcl_StringMatch "\[\u4e4fxy\]bc" "\u4e4fbc"
d113 1
a113 1
    Wrapper_Tcl_StringMatch {[]} {[]}
d119 1
a119 1
    Wrapper_Tcl_StringMatch {[} {[}
d122 1
a122 1
    Wrapper_Tcl_StringMatch {a[abc]c} abc
d128 1
a128 1
    Wrapper_Tcl_StringMatch "a\[a\u4e4fc]c" "a\u4e4fc"
d134 1
a134 1
    Wrapper_Tcl_StringMatch {a[a\u4e4fc]c} [bytestring a\u008fc]
d140 1
a140 1
    Wrapper_Tcl_StringMatch {a[a\u4e4fc]c} "acc"
d143 1
a143 1
    Wrapper_Tcl_StringMatch {a[xyz]c} abc
d146 1
a146 1
    Wrapper_Tcl_StringMatch {12[2-7]45} 12345
d149 1
a149 1
    Wrapper_Tcl_StringMatch "\[\u4e00-\u4e4f]" "0"
d152 1
a152 1
    Wrapper_Tcl_StringMatch "\[\u4e00-\u4e4f]" "\u4e33"
d155 1
a155 1
    Wrapper_Tcl_StringMatch "\[\u4e00-\u4e4f]" "\uff08"
d158 1
a158 1
    Wrapper_Tcl_StringMatch {12[ab2-4cd]45} 12345
d161 1
a161 1
    Wrapper_Tcl_StringMatch {12[ab2-4cd]45} 12b45
d164 1
a164 1
    Wrapper_Tcl_StringMatch {12[ab2-4cd]45} 12d45
d167 1
a167 1
    Wrapper_Tcl_StringMatch {12[ab2-4cd]45} 12145
d170 1
a170 1
    Wrapper_Tcl_StringMatch {12[ab2-4cd]45} 12545
d173 1
a173 1
    Wrapper_Tcl_StringMatch {[k-w]} "z"
d176 1
a176 1
    Wrapper_Tcl_StringMatch {[k-w]} "w"
d179 1
a179 1
    Wrapper_Tcl_StringMatch {[k-w]} "r"
d182 1
a182 1
    Wrapper_Tcl_StringMatch {[k-w]} "k"
d185 1
a185 1
    Wrapper_Tcl_StringMatch {[k-w]} "a"
d188 1
a188 1
    Wrapper_Tcl_StringMatch {[w-k]} "z"
d191 1
a191 1
    Wrapper_Tcl_StringMatch {[w-k]} "w"
d194 1
a194 1
    Wrapper_Tcl_StringMatch {[w-k]} "r"
d197 1
a197 1
    Wrapper_Tcl_StringMatch {[w-k]} "k"
d200 1
a200 1
    Wrapper_Tcl_StringMatch {[w-k]} "a"
d203 1
a203 1
    Wrapper_Tcl_StringMatch {[A-]x} Ax
d206 1
a206 1
    Wrapper_Tcl_StringMatch {[A-]]x} Ax
d209 1
a209 1
    Wrapper_Tcl_StringMatch {[A-]]x} \ue1x
d212 1
a212 1
    Wrapper_Tcl_StringMatch \[A-]\ue1]x \ue1x
d215 1
a215 1
    Wrapper_Tcl_StringMatch {[A-]h]x} hx
d221 1
a221 1
    Wrapper_Tcl_StringMatch {[a} a
d224 1
a224 1
    Wrapper_Tcl_StringMatch {a\*b} a*b
d227 1
a227 1
    Wrapper_Tcl_StringMatch {a\*b} ab
d230 1
a230 1
    Wrapper_Tcl_StringMatch {a\*\?\[\]\\\x} "a*?\[\]\\x"
d233 1
a233 1
    Wrapper_Tcl_StringMatch ** ""
d236 1
a236 1
    Wrapper_Tcl_StringMatch *. ""
d239 1
a239 1
    Wrapper_Tcl_StringMatch "" ""
a292 10
# This test always succeeded in the C locale anyway...
test util-8.1 {TclNeedSpace - correct UTF8 handling} {
    interp create \u5420
    interp create [list \u5420 foo]
    interp alias {} fooset [list \u5420 foo] set
    set result [interp target {} fooset]
    interp delete \u5420
    set result
} "\u5420 foo"

d296 13
@


1.3.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@d10 1
a10 1
# RCS: @@(#) $Id: util.test,v 1.10 2002/01/02 13:52:04 dkf Exp $
d65 1
a65 9
test util-4.6 {Tcl_ConcatObj - utf-8 sequence with "whitespace" char} {
    # Check for Bug #227512.  If this violates C isspace, then it returns \xc3.
    concat \xe0
} \xe0

proc Wrapper_Tcl_StringMatch {pattern string} {
    # Forces use of Tcl_StringMatch, not Tcl_UniCharCaseMatch
    switch -glob -- $string $pattern {return 1} default {return 0}
}
d67 1
a67 1
    Wrapper_Tcl_StringMatch ab*c abc
d70 1
a70 1
    Wrapper_Tcl_StringMatch ab**c abc
d73 1
a73 1
    Wrapper_Tcl_StringMatch ab* abcdef
d76 1
a76 1
    Wrapper_Tcl_StringMatch *c abc
d79 1
a79 1
    Wrapper_Tcl_StringMatch *3*6*9 0123456789
d82 1
a82 1
    Wrapper_Tcl_StringMatch *3*6*9 01234567890
d85 1
a85 1
    Wrapper_Tcl_StringMatch *u \u4e4fu
d88 1
a88 1
    Wrapper_Tcl_StringMatch a?c abc
d93 1
a93 1
    Wrapper_Tcl_StringMatch a?c a\u4e4fc
d96 1
a96 1
    Wrapper_Tcl_StringMatch a??c abc
d99 1
a99 1
    Wrapper_Tcl_StringMatch ?1??4???8? 0123456789
d102 1
a102 1
    Wrapper_Tcl_StringMatch {[abc]bc} abc
d107 1
a107 1
    Wrapper_Tcl_StringMatch "\[\u4e4fxy\]bc" "\u4e4fbc"
d113 1
a113 1
    Wrapper_Tcl_StringMatch {[]} {[]}
d119 1
a119 1
    Wrapper_Tcl_StringMatch {[} {[}
d122 1
a122 1
    Wrapper_Tcl_StringMatch {a[abc]c} abc
d128 1
a128 1
    Wrapper_Tcl_StringMatch "a\[a\u4e4fc]c" "a\u4e4fc"
d134 1
a134 1
    Wrapper_Tcl_StringMatch {a[a\u4e4fc]c} [bytestring a\u008fc]
d140 1
a140 1
    Wrapper_Tcl_StringMatch {a[a\u4e4fc]c} "acc"
d143 1
a143 1
    Wrapper_Tcl_StringMatch {a[xyz]c} abc
d146 1
a146 1
    Wrapper_Tcl_StringMatch {12[2-7]45} 12345
d149 1
a149 1
    Wrapper_Tcl_StringMatch "\[\u4e00-\u4e4f]" "0"
d152 1
a152 1
    Wrapper_Tcl_StringMatch "\[\u4e00-\u4e4f]" "\u4e33"
d155 1
a155 1
    Wrapper_Tcl_StringMatch "\[\u4e00-\u4e4f]" "\uff08"
d158 1
a158 1
    Wrapper_Tcl_StringMatch {12[ab2-4cd]45} 12345
d161 1
a161 1
    Wrapper_Tcl_StringMatch {12[ab2-4cd]45} 12b45
d164 1
a164 1
    Wrapper_Tcl_StringMatch {12[ab2-4cd]45} 12d45
d167 1
a167 1
    Wrapper_Tcl_StringMatch {12[ab2-4cd]45} 12145
d170 1
a170 1
    Wrapper_Tcl_StringMatch {12[ab2-4cd]45} 12545
d173 1
a173 1
    Wrapper_Tcl_StringMatch {[k-w]} "z"
d176 1
a176 1
    Wrapper_Tcl_StringMatch {[k-w]} "w"
d179 1
a179 1
    Wrapper_Tcl_StringMatch {[k-w]} "r"
d182 1
a182 1
    Wrapper_Tcl_StringMatch {[k-w]} "k"
d185 1
a185 1
    Wrapper_Tcl_StringMatch {[k-w]} "a"
d188 1
a188 1
    Wrapper_Tcl_StringMatch {[w-k]} "z"
d191 1
a191 1
    Wrapper_Tcl_StringMatch {[w-k]} "w"
d194 1
a194 1
    Wrapper_Tcl_StringMatch {[w-k]} "r"
d197 1
a197 1
    Wrapper_Tcl_StringMatch {[w-k]} "k"
d200 1
a200 1
    Wrapper_Tcl_StringMatch {[w-k]} "a"
d203 1
a203 1
    Wrapper_Tcl_StringMatch {[A-]x} Ax
d206 1
a206 1
    Wrapper_Tcl_StringMatch {[A-]]x} Ax
d209 1
a209 1
    Wrapper_Tcl_StringMatch {[A-]]x} \ue1x
d212 1
a212 1
    Wrapper_Tcl_StringMatch \[A-]\ue1]x \ue1x
d215 1
a215 1
    Wrapper_Tcl_StringMatch {[A-]h]x} hx
d221 1
a221 1
    Wrapper_Tcl_StringMatch {[a} a
d224 1
a224 1
    Wrapper_Tcl_StringMatch {a\*b} a*b
d227 1
a227 1
    Wrapper_Tcl_StringMatch {a\*b} ab
d230 1
a230 1
    Wrapper_Tcl_StringMatch {a\*\?\[\]\\\x} "a*?\[\]\\x"
d233 1
a233 1
    Wrapper_Tcl_StringMatch ** ""
d236 1
a236 1
    Wrapper_Tcl_StringMatch *. ""
d239 1
a239 1
    Wrapper_Tcl_StringMatch "" ""
a292 10
# This test always succeeded in the C locale anyway...
test util-8.1 {TclNeedSpace - correct UTF8 handling} {
    interp create \u5420
    interp create [list \u5420 foo]
    interp alias {} fooset [list \u5420 foo] set
    set result [interp target {} fooset]
    interp delete \u5420
    set result
} "\u5420 foo"

d296 13
@


1.2
log
@touched all Tcl files to ease next import.
@
text
@@


1.2.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.2.16.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d65 1
a65 9
test util-4.6 {Tcl_ConcatObj - utf-8 sequence with "whitespace" char} {
    # Check for Bug #227512.  If this violates C isspace, then it returns \xc3.
    concat \xe0
} \xe0

proc Wrapper_Tcl_StringMatch {pattern string} {
    # Forces use of Tcl_StringMatch, not Tcl_UniCharCaseMatch
    switch -glob -- $string $pattern {return 1} default {return 0}
}
d67 1
a67 1
    Wrapper_Tcl_StringMatch ab*c abc
d70 1
a70 1
    Wrapper_Tcl_StringMatch ab**c abc
d73 1
a73 1
    Wrapper_Tcl_StringMatch ab* abcdef
d76 1
a76 1
    Wrapper_Tcl_StringMatch *c abc
d79 1
a79 1
    Wrapper_Tcl_StringMatch *3*6*9 0123456789
d82 1
a82 1
    Wrapper_Tcl_StringMatch *3*6*9 01234567890
d85 1
a85 1
    Wrapper_Tcl_StringMatch *u \u4e4fu
d88 1
a88 1
    Wrapper_Tcl_StringMatch a?c abc
d93 1
a93 1
    Wrapper_Tcl_StringMatch a?c a\u4e4fc
d96 1
a96 1
    Wrapper_Tcl_StringMatch a??c abc
d99 1
a99 1
    Wrapper_Tcl_StringMatch ?1??4???8? 0123456789
d102 1
a102 1
    Wrapper_Tcl_StringMatch {[abc]bc} abc
d107 1
a107 1
    Wrapper_Tcl_StringMatch "\[\u4e4fxy\]bc" "\u4e4fbc"
d113 1
a113 1
    Wrapper_Tcl_StringMatch {[]} {[]}
d119 1
a119 1
    Wrapper_Tcl_StringMatch {[} {[}
d122 1
a122 1
    Wrapper_Tcl_StringMatch {a[abc]c} abc
d128 1
a128 1
    Wrapper_Tcl_StringMatch "a\[a\u4e4fc]c" "a\u4e4fc"
d134 1
a134 1
    Wrapper_Tcl_StringMatch {a[a\u4e4fc]c} [bytestring a\u008fc]
d140 1
a140 1
    Wrapper_Tcl_StringMatch {a[a\u4e4fc]c} "acc"
d143 1
a143 1
    Wrapper_Tcl_StringMatch {a[xyz]c} abc
d146 1
a146 1
    Wrapper_Tcl_StringMatch {12[2-7]45} 12345
d149 1
a149 1
    Wrapper_Tcl_StringMatch "\[\u4e00-\u4e4f]" "0"
d152 1
a152 1
    Wrapper_Tcl_StringMatch "\[\u4e00-\u4e4f]" "\u4e33"
d155 1
a155 1
    Wrapper_Tcl_StringMatch "\[\u4e00-\u4e4f]" "\uff08"
d158 1
a158 1
    Wrapper_Tcl_StringMatch {12[ab2-4cd]45} 12345
d161 1
a161 1
    Wrapper_Tcl_StringMatch {12[ab2-4cd]45} 12b45
d164 1
a164 1
    Wrapper_Tcl_StringMatch {12[ab2-4cd]45} 12d45
d167 1
a167 1
    Wrapper_Tcl_StringMatch {12[ab2-4cd]45} 12145
d170 1
a170 1
    Wrapper_Tcl_StringMatch {12[ab2-4cd]45} 12545
d173 1
a173 1
    Wrapper_Tcl_StringMatch {[k-w]} "z"
d176 1
a176 1
    Wrapper_Tcl_StringMatch {[k-w]} "w"
d179 1
a179 1
    Wrapper_Tcl_StringMatch {[k-w]} "r"
d182 1
a182 1
    Wrapper_Tcl_StringMatch {[k-w]} "k"
d185 1
a185 1
    Wrapper_Tcl_StringMatch {[k-w]} "a"
d188 1
a188 1
    Wrapper_Tcl_StringMatch {[w-k]} "z"
d191 1
a191 1
    Wrapper_Tcl_StringMatch {[w-k]} "w"
d194 1
a194 1
    Wrapper_Tcl_StringMatch {[w-k]} "r"
d197 1
a197 1
    Wrapper_Tcl_StringMatch {[w-k]} "k"
d200 1
a200 1
    Wrapper_Tcl_StringMatch {[w-k]} "a"
d203 1
a203 1
    Wrapper_Tcl_StringMatch {[A-]x} Ax
d206 1
a206 1
    Wrapper_Tcl_StringMatch {[A-]]x} Ax
d209 1
a209 1
    Wrapper_Tcl_StringMatch {[A-]]x} \ue1x
d212 1
a212 1
    Wrapper_Tcl_StringMatch \[A-]\ue1]x \ue1x
d215 1
a215 1
    Wrapper_Tcl_StringMatch {[A-]h]x} hx
d221 1
a221 1
    Wrapper_Tcl_StringMatch {[a} a
d224 1
a224 1
    Wrapper_Tcl_StringMatch {a\*b} a*b
d227 1
a227 1
    Wrapper_Tcl_StringMatch {a\*b} ab
d230 1
a230 1
    Wrapper_Tcl_StringMatch {a\*\?\[\]\\\x} "a*?\[\]\\x"
d233 1
a233 1
    Wrapper_Tcl_StringMatch ** ""
d236 1
a236 1
    Wrapper_Tcl_StringMatch *. ""
d239 1
a239 1
    Wrapper_Tcl_StringMatch "" ""
a292 10
# This test always succeeded in the C locale anyway...
test util-8.1 {TclNeedSpace - correct UTF8 handling} {
    interp create \u5420
    interp create [list \u5420 foo]
    interp alias {} fooset [list \u5420 foo] set
    set result [interp target {} fooset]
    interp delete \u5420
    set result
} "\u5420 foo"

d296 13
@


1.1
log
@Initial revision
@
text
@d4 2
a5 1
# Copyright (c) 1995-1997 Sun Microsystems, Inc.
d10 6
a15 1
# RCS: @@(#) $Id: util.test,v 1.3 1998/11/02 23:04:15 stanton Exp $
d20 1
a23 2
if {[string compare test [info procs test]] == 1} then {source defs}

d66 175
a240 20
test util-5.1 {Tcl_SetObjErrorCode - one arg} {
    catch {testsetobjerrorcode 1}
    list [set errorCode]
} {1}
test util-5.2 {Tcl_SetObjErrorCode - two args} {
    catch {testsetobjerrorcode 1 2}
    list [set errorCode]
} {{1 2}}
test util-5.3 {Tcl_SetObjErrorCode - three args} {
    catch {testsetobjerrorcode 1 2 3}
    list [set errorCode]
} {{1 2 3}}
test util-5.4 {Tcl_SetObjErrorCode - four args} {
    catch {testsetobjerrorcode 1 2 3 4}
    list [set errorCode]
} {{1 2 3 4}}
test util-5.5 {Tcl_SetObjErrorCode - five args} {
    catch {testsetobjerrorcode 1 2 3 4 5}
    list [set errorCode]
} {{1 2 3 4 5}}
d256 1
a256 1
test util-6.4 {Tcl_PrintDouble - make sure there's a decimal point} {
d259 1
a259 1
test util-6.5 {Tcl_PrintDouble - make sure there's a decimal point} {eformat} {
d286 1
a286 1
test util-7.3 {TclPrecTraceProc - write traces, bogus values} {
d292 17
a308 1
concat ""
@


1.1.1.1
log
@import dejagnu-1999-11-08 snapshot
@
text
@@


1.1.1.2
log
@Tcl 8.3 upgrade
@
text
@d4 1
a4 2
# Copyright (c) 1995-1998 Sun Microsystems, Inc.
# Copyright (c) 1998-1999 by Scriptics Corporation.
d9 1
a9 6
# RCS: @@(#) $Id: util.test,v 1.6.8.2 2000/09/15 16:57:54 spolk Exp $

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import -force ::tcltest::*
}
a13 1
    ::tcltest::cleanupTests
d17 2
d61 20
a80 175
test util-5.1 {Tcl_StringMatch} {
    string match ab*c abc
} 1
test util-5.2 {Tcl_StringMatch} {
    string match ab**c abc
} 1
test util-5.3 {Tcl_StringMatch} {
    string match ab* abcdef
} 1
test util-5.4 {Tcl_StringMatch} {
    string match *c abc
} 1
test util-5.5 {Tcl_StringMatch} {
    string match *3*6*9 0123456789
} 1
test util-5.6 {Tcl_StringMatch} {
    string match *3*6*9 01234567890
} 0
test util-5.7 {Tcl_StringMatch: UTF-8} {
    string match *u \u4e4fu
} 1
test util-5.8 {Tcl_StringMatch} {
    string match a?c abc
} 1
test util-5.9 {Tcl_StringMatch: UTF-8} {
    # skip one character in string

    string match a?c a\u4e4fc
} 1
test util-5.10 {Tcl_StringMatch} {
    string match a??c abc
} 0
test util-5.11 {Tcl_StringMatch} {
    string match ?1??4???8? 0123456789
} 1
test util-5.12 {Tcl_StringMatch} {
    string match {[abc]bc} abc
} 1
test util-5.13 {Tcl_StringMatch: UTF-8} {
    # string += Tcl_UtfToUniChar(string, &ch);

    string match "\[\u4e4fxy\]bc" "\u4e4fbc"
} 1
test util-5.14 {Tcl_StringMatch} {
    # if ((*pattern == ']') || (*pattern == '\0'))
    # badly formed pattern

    string match {[]} {[]}
} 0
test util-5.15 {Tcl_StringMatch} {
    # if ((*pattern == ']') || (*pattern == '\0'))
    # badly formed pattern

    string match {[} {[}
} 0
test util-5.16 {Tcl_StringMatch} {
    string match {a[abc]c} abc
} 1
test util-5.17 {Tcl_StringMatch: UTF-8} {
    # pattern += Tcl_UtfToUniChar(pattern, &endChar);
    # get 1 UTF-8 character

    string match "a\[a\u4e4fc]c" "a\u4e4fc"
} 1
test util-5.18 {Tcl_StringMatch: UTF-8} {
    # pattern += Tcl_UtfToUniChar(pattern, &endChar);
    # proper advance: wrong answer would match on UTF trail byte of \u4e4f

    string match {a[a\u4e4fc]c} [bytestring a\u008fc]
} 0
test util-5.19 {Tcl_StringMatch: UTF-8} {
    # pattern += Tcl_UtfToUniChar(pattern, &endChar);
    # proper advance.

    string match {a[a\u4e4fc]c} "acc"
} 1
test util-5.20 {Tcl_StringMatch} {
    string match {a[xyz]c} abc
} 0
test util-5.21 {Tcl_StringMatch} {
    string match {12[2-7]45} 12345
} 1
test util-5.22 {Tcl_StringMatch: UTF-8 range} {
    string match "\[\u4e00-\u4e4f]" "0"
} 0
test util-5.23 {Tcl_StringMatch: UTF-8 range} {
    string match "\[\u4e00-\u4e4f]" "\u4e33"
} 1
test util-5.24 {Tcl_StringMatch: UTF-8 range} {
    string match "\[\u4e00-\u4e4f]" "\uff08"
} 0
test util-5.25 {Tcl_StringMatch} {
    string match {12[ab2-4cd]45} 12345
} 1
test util-5.26 {Tcl_StringMatch} {
    string match {12[ab2-4cd]45} 12b45
} 1
test util-5.27 {Tcl_StringMatch} {
    string match {12[ab2-4cd]45} 12d45
} 1
test util-5.28 {Tcl_StringMatch} {
    string match {12[ab2-4cd]45} 12145
} 0
test util-5.29 {Tcl_StringMatch} {
    string match {12[ab2-4cd]45} 12545
} 0
test util-5.30 {Tcl_StringMatch: forwards range} {
    string match {[k-w]} "z"
} 0
test util-5.31 {Tcl_StringMatch: forwards range} {
    string match {[k-w]} "w"
} 1
test util-5.32 {Tcl_StringMatch: forwards range} {
    string match {[k-w]} "r"
} 1
test util-5.33 {Tcl_StringMatch: forwards range} {
    string match {[k-w]} "k"
} 1
test util-5.34 {Tcl_StringMatch: forwards range} {
    string match {[k-w]} "a"
} 0
test util-5.35 {Tcl_StringMatch: reverse range} {
    string match {[w-k]} "z"
} 0
test util-5.36 {Tcl_StringMatch: reverse range} {
    string match {[w-k]} "w"
} 1
test util-5.37 {Tcl_StringMatch: reverse range} {
    string match {[w-k]} "r"
} 1
test util-5.38 {Tcl_StringMatch: reverse range} {
    string match {[w-k]} "k"
} 1
test util-5.39 {Tcl_StringMatch: reverse range} {
    string match {[w-k]} "a"
} 0
test util-5.40 {Tcl_StringMatch: skip correct number of ']'} {
    string match {[A-]x} Ax
} 0
test util-5.41 {Tcl_StringMatch: skip correct number of ']'} {
    string match {[A-]]x} Ax
} 1
test util-5.42 {Tcl_StringMatch: skip correct number of ']'} {
    string match {[A-]]x} \ue1x
} 0
test util-5.43 {Tcl_StringMatch: skip correct number of ']'} {
    string match \[A-]\ue1]x \ue1x
} 1
test util-5.44 {Tcl_StringMatch: skip correct number of ']'} {
    string match {[A-]h]x} hx
} 1
test util-5.45 {Tcl_StringMatch} {
    # if (*pattern == '\0')
    # badly formed pattern, still treats as a set

    string match {[a} a
} 1
test util-5.46 {Tcl_StringMatch} {
    string match {a\*b} a*b
} 1
test util-5.47 {Tcl_StringMatch} {
    string match {a\*b} ab
} 0
test util-5.48 {Tcl_StringMatch} {
    string match {a\*\?\[\]\\\x} "a*?\[\]\\x"
} 1
test util-5.49 {Tcl_StringMatch} {
    string match ** ""
} 1
test util-5.50 {Tcl_StringMatch} {
    string match *. ""
} 0
test util-5.51 {Tcl_StringMatch} {
    string match "" ""
} 1
d96 1
a96 1
test util-6.5 {Tcl_PrintDouble - make sure there's a decimal point} {
d99 1
a99 1
test util-6.6 {Tcl_PrintDouble - make sure there's a decimal point} {eformat} {
d126 1
a126 1
test util-7.4 {TclPrecTraceProc - write traces, bogus values} {
d132 1
a132 17

# cleanup
::tcltest::cleanupTests
return













@


1.1.1.3
log
@import tcl 8.4.0
@
text
@d10 1
a10 1
# RCS: @@(#) $Id: util.test,v 1.10 2002/01/02 13:52:04 dkf Exp $
d65 1
a65 9
test util-4.6 {Tcl_ConcatObj - utf-8 sequence with "whitespace" char} {
    # Check for Bug #227512.  If this violates C isspace, then it returns \xc3.
    concat \xe0
} \xe0

proc Wrapper_Tcl_StringMatch {pattern string} {
    # Forces use of Tcl_StringMatch, not Tcl_UniCharCaseMatch
    switch -glob -- $string $pattern {return 1} default {return 0}
}
d67 1
a67 1
    Wrapper_Tcl_StringMatch ab*c abc
d70 1
a70 1
    Wrapper_Tcl_StringMatch ab**c abc
d73 1
a73 1
    Wrapper_Tcl_StringMatch ab* abcdef
d76 1
a76 1
    Wrapper_Tcl_StringMatch *c abc
d79 1
a79 1
    Wrapper_Tcl_StringMatch *3*6*9 0123456789
d82 1
a82 1
    Wrapper_Tcl_StringMatch *3*6*9 01234567890
d85 1
a85 1
    Wrapper_Tcl_StringMatch *u \u4e4fu
d88 1
a88 1
    Wrapper_Tcl_StringMatch a?c abc
d93 1
a93 1
    Wrapper_Tcl_StringMatch a?c a\u4e4fc
d96 1
a96 1
    Wrapper_Tcl_StringMatch a??c abc
d99 1
a99 1
    Wrapper_Tcl_StringMatch ?1??4???8? 0123456789
d102 1
a102 1
    Wrapper_Tcl_StringMatch {[abc]bc} abc
d107 1
a107 1
    Wrapper_Tcl_StringMatch "\[\u4e4fxy\]bc" "\u4e4fbc"
d113 1
a113 1
    Wrapper_Tcl_StringMatch {[]} {[]}
d119 1
a119 1
    Wrapper_Tcl_StringMatch {[} {[}
d122 1
a122 1
    Wrapper_Tcl_StringMatch {a[abc]c} abc
d128 1
a128 1
    Wrapper_Tcl_StringMatch "a\[a\u4e4fc]c" "a\u4e4fc"
d134 1
a134 1
    Wrapper_Tcl_StringMatch {a[a\u4e4fc]c} [bytestring a\u008fc]
d140 1
a140 1
    Wrapper_Tcl_StringMatch {a[a\u4e4fc]c} "acc"
d143 1
a143 1
    Wrapper_Tcl_StringMatch {a[xyz]c} abc
d146 1
a146 1
    Wrapper_Tcl_StringMatch {12[2-7]45} 12345
d149 1
a149 1
    Wrapper_Tcl_StringMatch "\[\u4e00-\u4e4f]" "0"
d152 1
a152 1
    Wrapper_Tcl_StringMatch "\[\u4e00-\u4e4f]" "\u4e33"
d155 1
a155 1
    Wrapper_Tcl_StringMatch "\[\u4e00-\u4e4f]" "\uff08"
d158 1
a158 1
    Wrapper_Tcl_StringMatch {12[ab2-4cd]45} 12345
d161 1
a161 1
    Wrapper_Tcl_StringMatch {12[ab2-4cd]45} 12b45
d164 1
a164 1
    Wrapper_Tcl_StringMatch {12[ab2-4cd]45} 12d45
d167 1
a167 1
    Wrapper_Tcl_StringMatch {12[ab2-4cd]45} 12145
d170 1
a170 1
    Wrapper_Tcl_StringMatch {12[ab2-4cd]45} 12545
d173 1
a173 1
    Wrapper_Tcl_StringMatch {[k-w]} "z"
d176 1
a176 1
    Wrapper_Tcl_StringMatch {[k-w]} "w"
d179 1
a179 1
    Wrapper_Tcl_StringMatch {[k-w]} "r"
d182 1
a182 1
    Wrapper_Tcl_StringMatch {[k-w]} "k"
d185 1
a185 1
    Wrapper_Tcl_StringMatch {[k-w]} "a"
d188 1
a188 1
    Wrapper_Tcl_StringMatch {[w-k]} "z"
d191 1
a191 1
    Wrapper_Tcl_StringMatch {[w-k]} "w"
d194 1
a194 1
    Wrapper_Tcl_StringMatch {[w-k]} "r"
d197 1
a197 1
    Wrapper_Tcl_StringMatch {[w-k]} "k"
d200 1
a200 1
    Wrapper_Tcl_StringMatch {[w-k]} "a"
d203 1
a203 1
    Wrapper_Tcl_StringMatch {[A-]x} Ax
d206 1
a206 1
    Wrapper_Tcl_StringMatch {[A-]]x} Ax
d209 1
a209 1
    Wrapper_Tcl_StringMatch {[A-]]x} \ue1x
d212 1
a212 1
    Wrapper_Tcl_StringMatch \[A-]\ue1]x \ue1x
d215 1
a215 1
    Wrapper_Tcl_StringMatch {[A-]h]x} hx
d221 1
a221 1
    Wrapper_Tcl_StringMatch {[a} a
d224 1
a224 1
    Wrapper_Tcl_StringMatch {a\*b} a*b
d227 1
a227 1
    Wrapper_Tcl_StringMatch {a\*b} ab
d230 1
a230 1
    Wrapper_Tcl_StringMatch {a\*\?\[\]\\\x} "a*?\[\]\\x"
d233 1
a233 1
    Wrapper_Tcl_StringMatch ** ""
d236 1
a236 1
    Wrapper_Tcl_StringMatch *. ""
d239 1
a239 1
    Wrapper_Tcl_StringMatch "" ""
a292 10
# This test always succeeded in the C locale anyway...
test util-8.1 {TclNeedSpace - correct UTF8 handling} {
    interp create \u5420
    interp create [list \u5420 foo]
    interp alias {} fooset [list \u5420 foo] set
    set result [interp target {} fooset]
    interp delete \u5420
    set result
} "\u5420 foo"

d296 13
@


1.1.1.4
log
@import tk 8.4.0
@
text
@d1 2
a2 2
# This file is a Tcl script to test out the procedures in the file
# tkUtil.c.  It is organized in the standard fashion for Tcl tests.
d4 1
a4 2
# Copyright (c) 1994 The Regents of the University of California.
# Copyright (c) 1994 Sun Microsystems, Inc.
a5 1
# All rights reserved.
d7 4
a10 1
# RCS: @@(#) $Id: util.test,v 1.5 2002/07/13 20:28:36 dgp Exp $
d12 298
a309 57
package require tcltest 2.1
namespace import -force tcltest::configure
namespace import -force tcltest::testsDirectory
configure -testdir [file join [pwd] [file dirname [info script]]]
configure -loadfile [file join [testsDirectory] constraints.tcl]
tcltest::loadTestedCommands

listbox .l -width 20 -height 5 -relief sunken -bd 2
pack .l
.l insert 0 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19
update
test util-1.1 {Tk_GetScrollInfo procedure} {
    list [catch {.l yview moveto a b} msg] $msg
} {1 {wrong # args: should be ".l yview moveto fraction"}}
test util-1.2 {Tk_GetScrollInfo procedure} {
    list [catch {.l yview moveto xyz} msg] $msg
} {1 {expected floating-point number but got "xyz"}}
test util-1.3 {Tk_GetScrollInfo procedure} {
    .l yview 0
    .l yview moveto .5
    .l yview
} {0.5 0.75}
test util-1.4 {Tk_GetScrollInfo procedure} {
    list [catch {.l yview scroll a} msg] $msg
} {1 {wrong # args: should be ".l yview scroll number units|pages"}}
test util-1.5 {Tk_GetScrollInfo procedure} {
    list [catch {.l yview scroll a b c} msg] $msg
} {1 {wrong # args: should be ".l yview scroll number units|pages"}}
test util-1.6 {Tk_GetScrollInfo procedure} {
    list [catch {.l yview scroll xyz units} msg] $msg
} {1 {expected integer but got "xyz"}}
test util-1.7 {Tk_GetScrollInfo procedure} {
    .l yview 0
    .l yview scroll 2 pages
    .l nearest 0
} {6}
test util-1.8 {Tk_GetScrollInfo procedure} {
    .l yview 15
    .l yview scroll -2 pages
    .l nearest 0
} {9}
test util-1.9 {Tk_GetScrollInfo procedure} {
    .l yview 0
    .l yview scroll 2 units
    .l nearest 0
} {2}
test util-1.10 {Tk_GetScrollInfo procedure} {
    .l yview 15
    .l yview scroll -2 units
    .l nearest 0
} {13}
test util-1.11 {Tk_GetScrollInfo procedure} {
    list [catch {.l yview scroll 3 zips} msg] $msg
} {1 {bad argument "zips": must be units or pages}}
test util-1.12 {Tk_GetScrollInfo procedure} {
    list [catch {.l yview dropdead 3 times} msg] $msg
} {1 {unknown option "dropdead": must be moveto or scroll}}
a313 13













@


1.1.1.5
log
@one more time: import tcl 8.4.0
@
text
@d1 2
a2 2
# This file is a Tcl script to test the code in the file tclUtil.c.
# This file is organized in the standard fashion for Tcl tests.
d4 2
a5 1
# Copyright (c) 1995-1998 Sun Microsystems, Inc.
d7 1
d9 1
a9 4
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# RCS: @@(#) $Id: util.test,v 1.10 2002/01/02 13:52:04 dkf Exp $
d11 57
a67 298
if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import -force ::tcltest::*
}

if {[info commands testobj] == {}} {
    puts "This application hasn't been compiled with the \"testobj\""
    puts "command, so I can't test the Tcl type and object support."
    ::tcltest::cleanupTests
    return
}

test util-1.1 {TclFindElement procedure - binary element in middle of list} {
    lindex {0 foo\x00help 1} 1
} "foo\x00help"
test util-1.2 {TclFindElement procedure - binary element at end of list} {
    lindex {0 foo\x00help} 1
} "foo\x00help"

test util-2.1 {TclCopyAndCollapse procedure - normal string} {
    lindex {0 foo} 1
} {foo}
test util-2.2 {TclCopyAndCollapse procedure - string with backslashes} {
    lindex {0 foo\n\x00help 1} 1
} "foo\n\x00help"

test util-3.1 {Tcl_ScanCountedElement procedure - don't leave unmatched braces} {
    # This test checks for a very tricky feature.  Any list element
    # generated with Tcl_ScanCountedElement and Tcl_ConvertElement must
    # have the property that it can be enclosing in curly braces to make
    # an embedded sub-list.  If this property doesn't hold, then
    # Tcl_DStringStartSublist doesn't work.

    set x {}
    lappend x " \\\{ \\"
    concat $x [llength "{$x}"]
} {\ \\\{\ \\ 1}

test util-4.1 {Tcl_ConcatObj - backslash-space at end of argument} {
    concat a {b\ } c
} {a b\  c}
test util-4.2 {Tcl_ConcatObj - backslash-space at end of argument} {
    concat a {b\   } c
} {a b\  c}
test util-4.3 {Tcl_ConcatObj - backslash-space at end of argument} {
    concat a {b\\   } c
} {a b\\  c}
test util-4.4 {Tcl_ConcatObj - backslash-space at end of argument} {
    concat a {b } c
} {a b c}
test util-4.5 {Tcl_ConcatObj - backslash-space at end of argument} {
    concat a { } c
} {a c}
test util-4.6 {Tcl_ConcatObj - utf-8 sequence with "whitespace" char} {
    # Check for Bug #227512.  If this violates C isspace, then it returns \xc3.
    concat \xe0
} \xe0

proc Wrapper_Tcl_StringMatch {pattern string} {
    # Forces use of Tcl_StringMatch, not Tcl_UniCharCaseMatch
    switch -glob -- $string $pattern {return 1} default {return 0}
}
test util-5.1 {Tcl_StringMatch} {
    Wrapper_Tcl_StringMatch ab*c abc
} 1
test util-5.2 {Tcl_StringMatch} {
    Wrapper_Tcl_StringMatch ab**c abc
} 1
test util-5.3 {Tcl_StringMatch} {
    Wrapper_Tcl_StringMatch ab* abcdef
} 1
test util-5.4 {Tcl_StringMatch} {
    Wrapper_Tcl_StringMatch *c abc
} 1
test util-5.5 {Tcl_StringMatch} {
    Wrapper_Tcl_StringMatch *3*6*9 0123456789
} 1
test util-5.6 {Tcl_StringMatch} {
    Wrapper_Tcl_StringMatch *3*6*9 01234567890
} 0
test util-5.7 {Tcl_StringMatch: UTF-8} {
    Wrapper_Tcl_StringMatch *u \u4e4fu
} 1
test util-5.8 {Tcl_StringMatch} {
    Wrapper_Tcl_StringMatch a?c abc
} 1
test util-5.9 {Tcl_StringMatch: UTF-8} {
    # skip one character in string

    Wrapper_Tcl_StringMatch a?c a\u4e4fc
} 1
test util-5.10 {Tcl_StringMatch} {
    Wrapper_Tcl_StringMatch a??c abc
} 0
test util-5.11 {Tcl_StringMatch} {
    Wrapper_Tcl_StringMatch ?1??4???8? 0123456789
} 1
test util-5.12 {Tcl_StringMatch} {
    Wrapper_Tcl_StringMatch {[abc]bc} abc
} 1
test util-5.13 {Tcl_StringMatch: UTF-8} {
    # string += Tcl_UtfToUniChar(string, &ch);

    Wrapper_Tcl_StringMatch "\[\u4e4fxy\]bc" "\u4e4fbc"
} 1
test util-5.14 {Tcl_StringMatch} {
    # if ((*pattern == ']') || (*pattern == '\0'))
    # badly formed pattern

    Wrapper_Tcl_StringMatch {[]} {[]}
} 0
test util-5.15 {Tcl_StringMatch} {
    # if ((*pattern == ']') || (*pattern == '\0'))
    # badly formed pattern

    Wrapper_Tcl_StringMatch {[} {[}
} 0
test util-5.16 {Tcl_StringMatch} {
    Wrapper_Tcl_StringMatch {a[abc]c} abc
} 1
test util-5.17 {Tcl_StringMatch: UTF-8} {
    # pattern += Tcl_UtfToUniChar(pattern, &endChar);
    # get 1 UTF-8 character

    Wrapper_Tcl_StringMatch "a\[a\u4e4fc]c" "a\u4e4fc"
} 1
test util-5.18 {Tcl_StringMatch: UTF-8} {
    # pattern += Tcl_UtfToUniChar(pattern, &endChar);
    # proper advance: wrong answer would match on UTF trail byte of \u4e4f

    Wrapper_Tcl_StringMatch {a[a\u4e4fc]c} [bytestring a\u008fc]
} 0
test util-5.19 {Tcl_StringMatch: UTF-8} {
    # pattern += Tcl_UtfToUniChar(pattern, &endChar);
    # proper advance.

    Wrapper_Tcl_StringMatch {a[a\u4e4fc]c} "acc"
} 1
test util-5.20 {Tcl_StringMatch} {
    Wrapper_Tcl_StringMatch {a[xyz]c} abc
} 0
test util-5.21 {Tcl_StringMatch} {
    Wrapper_Tcl_StringMatch {12[2-7]45} 12345
} 1
test util-5.22 {Tcl_StringMatch: UTF-8 range} {
    Wrapper_Tcl_StringMatch "\[\u4e00-\u4e4f]" "0"
} 0
test util-5.23 {Tcl_StringMatch: UTF-8 range} {
    Wrapper_Tcl_StringMatch "\[\u4e00-\u4e4f]" "\u4e33"
} 1
test util-5.24 {Tcl_StringMatch: UTF-8 range} {
    Wrapper_Tcl_StringMatch "\[\u4e00-\u4e4f]" "\uff08"
} 0
test util-5.25 {Tcl_StringMatch} {
    Wrapper_Tcl_StringMatch {12[ab2-4cd]45} 12345
} 1
test util-5.26 {Tcl_StringMatch} {
    Wrapper_Tcl_StringMatch {12[ab2-4cd]45} 12b45
} 1
test util-5.27 {Tcl_StringMatch} {
    Wrapper_Tcl_StringMatch {12[ab2-4cd]45} 12d45
} 1
test util-5.28 {Tcl_StringMatch} {
    Wrapper_Tcl_StringMatch {12[ab2-4cd]45} 12145
} 0
test util-5.29 {Tcl_StringMatch} {
    Wrapper_Tcl_StringMatch {12[ab2-4cd]45} 12545
} 0
test util-5.30 {Tcl_StringMatch: forwards range} {
    Wrapper_Tcl_StringMatch {[k-w]} "z"
} 0
test util-5.31 {Tcl_StringMatch: forwards range} {
    Wrapper_Tcl_StringMatch {[k-w]} "w"
} 1
test util-5.32 {Tcl_StringMatch: forwards range} {
    Wrapper_Tcl_StringMatch {[k-w]} "r"
} 1
test util-5.33 {Tcl_StringMatch: forwards range} {
    Wrapper_Tcl_StringMatch {[k-w]} "k"
} 1
test util-5.34 {Tcl_StringMatch: forwards range} {
    Wrapper_Tcl_StringMatch {[k-w]} "a"
} 0
test util-5.35 {Tcl_StringMatch: reverse range} {
    Wrapper_Tcl_StringMatch {[w-k]} "z"
} 0
test util-5.36 {Tcl_StringMatch: reverse range} {
    Wrapper_Tcl_StringMatch {[w-k]} "w"
} 1
test util-5.37 {Tcl_StringMatch: reverse range} {
    Wrapper_Tcl_StringMatch {[w-k]} "r"
} 1
test util-5.38 {Tcl_StringMatch: reverse range} {
    Wrapper_Tcl_StringMatch {[w-k]} "k"
} 1
test util-5.39 {Tcl_StringMatch: reverse range} {
    Wrapper_Tcl_StringMatch {[w-k]} "a"
} 0
test util-5.40 {Tcl_StringMatch: skip correct number of ']'} {
    Wrapper_Tcl_StringMatch {[A-]x} Ax
} 0
test util-5.41 {Tcl_StringMatch: skip correct number of ']'} {
    Wrapper_Tcl_StringMatch {[A-]]x} Ax
} 1
test util-5.42 {Tcl_StringMatch: skip correct number of ']'} {
    Wrapper_Tcl_StringMatch {[A-]]x} \ue1x
} 0
test util-5.43 {Tcl_StringMatch: skip correct number of ']'} {
    Wrapper_Tcl_StringMatch \[A-]\ue1]x \ue1x
} 1
test util-5.44 {Tcl_StringMatch: skip correct number of ']'} {
    Wrapper_Tcl_StringMatch {[A-]h]x} hx
} 1
test util-5.45 {Tcl_StringMatch} {
    # if (*pattern == '\0')
    # badly formed pattern, still treats as a set

    Wrapper_Tcl_StringMatch {[a} a
} 1
test util-5.46 {Tcl_StringMatch} {
    Wrapper_Tcl_StringMatch {a\*b} a*b
} 1
test util-5.47 {Tcl_StringMatch} {
    Wrapper_Tcl_StringMatch {a\*b} ab
} 0
test util-5.48 {Tcl_StringMatch} {
    Wrapper_Tcl_StringMatch {a\*\?\[\]\\\x} "a*?\[\]\\x"
} 1
test util-5.49 {Tcl_StringMatch} {
    Wrapper_Tcl_StringMatch ** ""
} 1
test util-5.50 {Tcl_StringMatch} {
    Wrapper_Tcl_StringMatch *. ""
} 0
test util-5.51 {Tcl_StringMatch} {
    Wrapper_Tcl_StringMatch "" ""
} 1

test util-6.1 {Tcl_PrintDouble - using tcl_precision} {
    concat x[expr 1.4]
} {x1.4}
test util-6.2 {Tcl_PrintDouble - using tcl_precision} {
    concat x[expr 1.39999999999]
} {x1.39999999999}
test util-6.3 {Tcl_PrintDouble - using tcl_precision} {
    concat x[expr 1.399999999999]
} {x1.4}
test util-6.4 {Tcl_PrintDouble - using tcl_precision} {
    set tcl_precision 5
    concat x[expr 1.123412341234]
} {x1.1234}
set tcl_precision 12
test util-6.5 {Tcl_PrintDouble - make sure there's a decimal point} {
    concat x[expr 2.0]
} {x2.0}
test util-6.6 {Tcl_PrintDouble - make sure there's a decimal point} {eformat} {
    concat x[expr 3.0e98]
} {x3e+98}

test util-7.1 {TclPrecTraceProc - unset callbacks} {
    set tcl_precision 7
    set x $tcl_precision
    unset tcl_precision
    list $x $tcl_precision
} {7 7}
test util-7.2 {TclPrecTraceProc - read traces, sharing among interpreters} {
    set tcl_precision 12
    interp create child
    set x [child eval set tcl_precision]
    child eval {set tcl_precision 6}
    interp delete child
    list $x $tcl_precision
} {12 6}
test util-7.3 {TclPrecTraceProc - write traces, safe interpreters} {
    set tcl_precision 12
    interp create -safe child
    set x [child eval {
	list [catch {set tcl_precision 8} msg] $msg
    }]
    interp delete child
    list $x $tcl_precision
} {{1 {can't set "tcl_precision": can't modify precision from a safe interpreter}} 12}
test util-7.4 {TclPrecTraceProc - write traces, bogus values} {
    set tcl_precision 12
    list [catch {set tcl_precision abc} msg] $msg $tcl_precision
} {1 {can't set "tcl_precision": improper value for precision} 12}

set tcl_precision 12

# This test always succeeded in the C locale anyway...
test util-8.1 {TclNeedSpace - correct UTF8 handling} {
    interp create \u5420
    interp create [list \u5420 foo]
    interp alias {} fooset [list \u5420 foo] set
    set result [interp target {} fooset]
    interp delete \u5420
    set result
} "\u5420 foo"
d72 13
@


