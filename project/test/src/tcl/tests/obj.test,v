head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.58
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.56
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.54
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.52
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.50
	gdb_7_0-branch:1.5.0.48
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tcl8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.46
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.44
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.42
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.40
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.38
	gdb_6_5-2006-05-14-branchpoint:1.5
	readline_5_1-import-branch:1.5.0.36
	readline_5_1-import-branchpoint:1.5
	gdb_6_4-branch:1.5.0.34
	gdb_6_4-2005-11-01-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.32
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	ezannoni_pie-20040323-branch:1.5.0.30
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.28
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.26
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.24
	cagney_x86i386-20030821-branch:1.5.0.22
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.20
	gdb_6_0-2003-06-23-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.18
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.16
	cagney_writestrings-20030508-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.14
	cagney_fileio-20030521-branchpoint:1.5
	carlton_dictionary-20030430-merge:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.12
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.10
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.8
	cagney_lazyid-20030317-branchpoint:1.5
	offbyone-20030313-branch:1.5.0.6
	offbyone-20030313-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.4
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.2
	interps-20030202-branchpoint:1.5
	TCL8_4_1:1.1.1.5
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.2
	TCL_8_4_1:1.1.1.5
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.4
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TK_8_4_0:1.1.1.4
	TCL_8_4_0:1.1.1.5
	carlton_dictionary-branch:1.2.0.16
	carlton_dictionary-20020920-branchpoint:1.2
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.14
	gdb_5_3-branch:1.2.0.12
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.10
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.8
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.6
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TCL_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	dejagnu-2000-02-04:1.1.1.1
	dejagnu-2000-01-31:1.1.1.1
	dejagnu-2000-01-24:1.1.1.1
	dejagnu-2000-01-17:1.1.1.1
	dejagnu-2000-01-10:1.1.1.1
	dejagnu-2000-01-04:1.1.1.1
	dejagnu-1999-12-21:1.1.1.1
	dejagnu-1999-12-13:1.1.1.1
	dejagnu-1999-12-07:1.1.1.1
	dejagnu-1999-12-06:1.1.1.1
	dejagnu-1999-11-15:1.1.1.1
	dejagnu-1999-11-08:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2003.01.21.19.40.16;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.26.19.48.01;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.37.07;	author kseitz;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2001.09.09.23.56.08;	author irox;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2002.09.27.21.49.10;	author kseitz;	state Exp;
branches;
next	;

1.3.4.1
date	2003.12.14.20.28.49;	author drow;	state Exp;
branches;
next	;

1.2.16.1
date	2002.12.23.19.40.42;	author carlton;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2003.02.07.19.18.19;	author carlton;	state Exp;
branches;
next	;

1.1.1.1
date	99.11.09.01.28.44;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.09.22.40.58;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.19.56.38;	author kseitz;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.09.24.20.25.29;	author kseitz;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.09.24.22.01.38;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tcl 8.4.1
@
text
@# Functionality covered: this file contains a collection of tests for the
# procedures in tclObj.c that implement Tcl's basic type support and the
# type managers for the types boolean, double, and integer.
#
# Sourcing this file into Tcl runs the tests and generates output for
# errors. No output means no errors were found.
#
# Copyright (c) 1995-1996 Sun Microsystems, Inc.
# Copyright (c) 1998-1999 by Scriptics Corporation.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# RCS: @@(#) $Id: obj.test,v 1.7 2002/04/26 08:43:38 dkf Exp $

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import -force ::tcltest::*
}

if {[info commands testobj] == {}} {
    puts "This application hasn't been compiled with the \"testobj\""
    puts "command, so I can't test the Tcl type and object support."
    ::tcltest::cleanupTests
    return
}

test obj-1.1 {Tcl_AppendAllObjTypes, and InitTypeTable, Tcl_RegisterObjType} {
    set r 1
    foreach {t} {
	{array search} 
	boolean
	bytearray
	bytecode
	double
	end-offset
	index
	int
	list
	nsName
	procbody
	string
    } {
        set first [string first $t [testobj types]]
        set r [expr {$r && ($first != -1)}]
    }
    set result $r
} {1}

test obj-2.1 {Tcl_GetObjType error} {
    list [testintobj set 1 0] [catch {testobj convert 1 foo} msg] $msg
} {0 1 {no type foo found}}
test obj-2.2 {Tcl_GetObjType and Tcl_ConvertToType} {
    set result ""
    lappend result [testobj freeallvars]
    lappend result [testintobj set 1 12]
    lappend result [testobj convert 1 double]
    lappend result [testobj type 1]
    lappend result [testobj refcount 1]
} {{} 12 12 double 3}

test obj-3.1 {Tcl_ConvertToType error} {
    list [testdoubleobj set 1 12.34] [catch {testobj convert 1 int} msg] $msg
} {12.34 1 {expected integer but got "12.34"}}
test obj-3.2 {Tcl_ConvertToType error, "empty string" object} {
    list [testobj newobj 1] [catch {testobj convert 1 int} msg] $msg
} {{} 1 {expected integer but got ""}}

test obj-4.1 {Tcl_NewObj and AllocateFreeObjects} {
    set result ""
    lappend result [testobj freeallvars]
    lappend result [testobj newobj 1]
    lappend result [testobj type 1]
    lappend result [testobj refcount 1]
} {{} {} string 2}

test obj-5.1 {Tcl_FreeObj} {
    set result ""
    lappend result [testintobj set 1 12345]
    lappend result [testobj freeallvars]
    lappend result [catch {testintobj get 1} msg]
    lappend result $msg
} {12345 {} 1 {variable 1 is unset (NULL)}}

test obj-6.1 {Tcl_DuplicateObj, object has internal rep} {
    set result ""
    lappend result [testobj freeallvars]
    lappend result [testintobj set 1 47]
    lappend result [testobj duplicate 1 2]    
    lappend result [testintobj get 2]
    lappend result [testobj refcount 1]
    lappend result [testobj refcount 2]
} {{} 47 47 47 2 3}
test obj-6.2 {Tcl_DuplicateObj, "empty string" object} {
    set result ""
    lappend result [testobj freeallvars]
    lappend result [testobj newobj 1]
    lappend result [testobj duplicate 1 2]    
    lappend result [testintobj get 2]
    lappend result [testobj refcount 1]
    lappend result [testobj refcount 2]
} {{} {} {} {} 2 3}

test obj-7.1 {Tcl_GetString, return existing string rep} {
    set result ""
    lappend result [testintobj set 1 47]
    lappend result [testintobj get2 1]
} {47 47}
test obj-7.2 {Tcl_GetString, "empty string" object} {
    set result ""
    lappend result [testobj newobj 1]
    lappend result [teststringobj append 1 abc -1]
    lappend result [teststringobj get2 1]
} {{} abc abc}
test obj-7.3 {Tcl_GetString, returns string internal rep (DString)} {
    set result ""
    lappend result [teststringobj set 1 xyz]
    lappend result [teststringobj append 1 abc -1]
    lappend result [teststringobj get2 1]
} {xyz xyzabc xyzabc}
test obj-7.4 {Tcl_GetString, recompute string rep from internal rep} {
    set result ""
    lappend result [testintobj set 1 77]
    lappend result [testintobj mult10 1]
    lappend result [teststringobj get2 1]
} {77 770 770}

test obj-8.1 {Tcl_GetStringFromObj, return existing string rep} {
    set result ""
    lappend result [testintobj set 1 47]
    lappend result [testintobj get 1]
} {47 47}
test obj-8.2 {Tcl_GetStringFromObj, "empty string" object} {
    set result ""
    lappend result [testobj newobj 1]
    lappend result [teststringobj append 1 abc -1]
    lappend result [teststringobj get 1]
} {{} abc abc}
test obj-8.3 {Tcl_GetStringFromObj, returns string internal rep (DString)} {
    set result ""
    lappend result [teststringobj set 1 xyz]
    lappend result [teststringobj append 1 abc -1]
    lappend result [teststringobj get 1]
} {xyz xyzabc xyzabc}
test obj-8.4 {Tcl_GetStringFromObj, recompute string rep from internal rep} {
    set result ""
    lappend result [testintobj set 1 77]
    lappend result [testintobj mult10 1]
    lappend result [teststringobj get 1]
} {77 770 770}

test obj-9.1 {Tcl_NewBooleanObj} {
    set result ""
    lappend result [testobj freeallvars]
    lappend result [testbooleanobj set 1 0]
    lappend result [testobj type 1]
    lappend result [testobj refcount 1]
} {{} 0 boolean 2}

test obj-10.1 {Tcl_SetBooleanObj, existing "empty string" object} {
    set result ""
    lappend result [testobj freeallvars]
    lappend result [testobj newobj 1]
    lappend result [testbooleanobj set 1 0]  ;# makes existing obj boolean
    lappend result [testobj type 1]
    lappend result [testobj refcount 1]
} {{} {} 0 boolean 2}
test obj-10.2 {Tcl_SetBooleanObj, existing non-"empty string" object} {
    set result ""
    lappend result [testobj freeallvars]
    lappend result [testintobj set 1 98765]
    lappend result [testbooleanobj set 1 1]  ;# makes existing obj boolean
    lappend result [testobj type 1]
    lappend result [testobj refcount 1]
} {{} 98765 1 boolean 2}

test obj-11.1 {Tcl_GetBooleanFromObj, existing boolean object} {
    set result ""
    lappend result [testbooleanobj set 1 1]
    lappend result [testbooleanobj not 1]    ;# gets existing boolean rep
} {1 0}
test obj-11.2 {Tcl_GetBooleanFromObj, convert to boolean} {
    set result ""
    lappend result [testintobj set 1 47]
    lappend result [testbooleanobj not 1]    ;# must convert to bool
    lappend result [testobj type 1]
} {47 0 boolean}
test obj-11.3 {Tcl_GetBooleanFromObj, error converting to boolean} {
    set result ""
    lappend result [teststringobj set 1 abc]
    lappend result [catch {testbooleanobj not 1} msg]
    lappend result $msg
} {abc 1 {expected boolean value but got "abc"}}
test obj-11.4 {Tcl_GetBooleanFromObj, error converting from "empty string"} {
    set result ""
    lappend result [testobj newobj 1]
    lappend result [catch {testbooleanobj not 1} msg]
    lappend result $msg
} {{} 1 {expected boolean value but got ""}}
test obj-11.5 {Tcl_GetBooleanFromObj, convert hex to boolean} {
    set result ""
    lappend result [teststringobj set 1 0xac]
    lappend result [testbooleanobj not 1]
    lappend result [testobj type 1]
} {0xac 0 boolean}
test obj-11.6 {Tcl_GetBooleanFromObj, convert float to boolean} {
    set result ""
    lappend result [teststringobj set 1 5.42]
    lappend result [testbooleanobj not 1]
    lappend result [testobj type 1]
} {5.42 0 boolean}

test obj-12.1 {DupBooleanInternalRep} {
    set result ""
    lappend result [testbooleanobj set 1 1]
    lappend result [testobj duplicate 1 2]   ;# uses DupBooleanInternalRep
    lappend result [testbooleanobj get 2]
} {1 1 1}

test obj-13.1 {SetBooleanFromAny, int to boolean special case} {
    set result ""
    lappend result [testintobj set 1 1234]
    lappend result [testbooleanobj not 1]    ;# converts with SetBooleanFromAny
    lappend result [testobj type 1]
} {1234 0 boolean}
test obj-13.2 {SetBooleanFromAny, double to boolean special case} {
    set result ""
    lappend result [testdoubleobj set 1 3.14159]
    lappend result [testbooleanobj not 1]    ;# converts with SetBooleanFromAny
    lappend result [testobj type 1]
} {3.14159 0 boolean}
test obj-13.3 {SetBooleanFromAny, special case strings representing booleans} {
    set result ""
    foreach s {yes no true false on off} {
        teststringobj set 1 $s
        lappend result [testbooleanobj not 1]
    }
    lappend result [testobj type 1]
} {0 1 0 1 0 1 boolean}
test obj-13.4 {SetBooleanFromAny, recompute string rep then parse it} {
    set result ""
    lappend result [testintobj set 1 456]
    lappend result [testintobj div10 1]
    lappend result [testbooleanobj not 1]    ;# converts with SetBooleanFromAny
    lappend result [testobj type 1]
} {456 45 0 boolean}
test obj-13.5 {SetBooleanFromAny, error parsing string} {
    set result ""
    lappend result [teststringobj set 1 abc]
    lappend result [catch {testbooleanobj not 1} msg]
    lappend result $msg
} {abc 1 {expected boolean value but got "abc"}}
test obj-13.6 {SetBooleanFromAny, error parsing string} {
    set result ""
    lappend result [teststringobj set 1 x1.0]
    lappend result [catch {testbooleanobj not 1} msg]
    lappend result $msg
} {x1.0 1 {expected boolean value but got "x1.0"}}
test obj-13.7 {SetBooleanFromAny, error converting from "empty string"} {
    set result ""
    lappend result [testobj newobj 1]
    lappend result [catch {testbooleanobj not 1} msg]
    lappend result $msg
} {{} 1 {expected boolean value but got ""}}
test obj-13.8 {SetBooleanFromAny, unicode strings} {
    set result ""
    lappend result [teststringobj set 1 1\u7777]
    lappend result [catch {testbooleanobj not 1} msg]
    lappend result $msg
} "1\u7777 1 {expected boolean value but got \"1\u7777\"}"

test obj-14.1 {UpdateStringOfBoolean} {
    set result ""
    lappend result [testbooleanobj set 1 0]
    lappend result [testbooleanobj not 1]
    lappend result [testbooleanobj get 1]    ;# must update string rep
} {0 1 1}

test obj-15.1 {Tcl_NewDoubleObj} {
    set result ""
    lappend result [testobj freeallvars]
    lappend result [testdoubleobj set 1 3.1459]
    lappend result [testobj type 1]
    lappend result [testobj refcount 1]
} {{} 3.1459 double 2}

test obj-16.1 {Tcl_SetDoubleObj, existing "empty string" object} {
    set result ""
    lappend result [testobj freeallvars]
    lappend result [testobj newobj 1]
    lappend result [testdoubleobj set 1 0.123]  ;# makes existing obj boolean
    lappend result [testobj type 1]
    lappend result [testobj refcount 1]
} {{} {} 0.123 double 2}
test obj-16.2 {Tcl_SetDoubleObj, existing non-"empty string" object} {
    set result ""
    lappend result [testobj freeallvars]
    lappend result [testintobj set 1 98765]
    lappend result [testdoubleobj set 1 27.56]  ;# makes existing obj double
    lappend result [testobj type 1]
    lappend result [testobj refcount 1]
} {{} 98765 27.56 double 2}

test obj-17.1 {Tcl_GetDoubleFromObj, existing double object} {
    set result ""
    lappend result [testdoubleobj set 1 16.1]
    lappend result [testdoubleobj mult10 1]   ;# gets existing double rep
} {16.1 161.0}
test obj-17.2 {Tcl_GetDoubleFromObj, convert to double} {
    set result ""
    lappend result [testintobj set 1 477]
    lappend result [testdoubleobj div10 1]    ;# must convert to bool
    lappend result [testobj type 1]
} {477 47.7 double}
test obj-17.3 {Tcl_GetDoubleFromObj, error converting to double} {
    set result ""
    lappend result [teststringobj set 1 abc]
    lappend result [catch {testdoubleobj mult10 1} msg]
    lappend result $msg
} {abc 1 {expected floating-point number but got "abc"}}
test obj-17.4 {Tcl_GetDoubleFromObj, error converting from "empty string"} {
    set result ""
    lappend result [testobj newobj 1]
    lappend result [catch {testdoubleobj div10 1} msg]
    lappend result $msg
} {{} 1 {expected floating-point number but got ""}}

test obj-18.1 {DupDoubleInternalRep} {
    set result ""
    lappend result [testdoubleobj set 1 17.1]
    lappend result [testobj duplicate 1 2]      ;# uses DupDoubleInternalRep
    lappend result [testdoubleobj get 2]
} {17.1 17.1 17.1}

test obj-19.1 {SetDoubleFromAny, int to double special case} {
    set result ""
    lappend result [testintobj set 1 1234]
    lappend result [testdoubleobj mult10 1] ;# converts with SetDoubleFromAny
    lappend result [testobj type 1]
} {1234 12340.0 double}
test obj-19.2 {SetDoubleFromAny, boolean to double special case} {
    set result ""
    lappend result [testbooleanobj set 1 1]
    lappend result [testdoubleobj mult10 1] ;# converts with SetDoubleFromAny
    lappend result [testobj type 1]
} {1 10.0 double}
test obj-19.3 {SetDoubleFromAny, recompute string rep then parse it} {
    set result ""
    lappend result [testintobj set 1 456]
    lappend result [testintobj div10 1]
    lappend result [testdoubleobj mult10 1] ;# converts with SetDoubleFromAny
    lappend result [testobj type 1]
} {456 45 450.0 double}
test obj-19.4 {SetDoubleFromAny, error parsing string} {
    set result ""
    lappend result [teststringobj set 1 abc]
    lappend result [catch {testdoubleobj mult10 1} msg]
    lappend result $msg
} {abc 1 {expected floating-point number but got "abc"}}
test obj-19.5 {SetDoubleFromAny, error parsing string} {
    set result ""
    lappend result [teststringobj set 1 x1.0]
    lappend result [catch {testdoubleobj mult10 1} msg]
    lappend result $msg
} {x1.0 1 {expected floating-point number but got "x1.0"}}
test obj-19.6 {SetDoubleFromAny, error converting from "empty string"} {
    set result ""
    lappend result [testobj newobj 1]
    lappend result [catch {testdoubleobj div10 1} msg]
    lappend result $msg
} {{} 1 {expected floating-point number but got ""}}

test obj-20.1 {UpdateStringOfDouble} {
    set result ""
    lappend result [testdoubleobj set 1 3.14159]
    lappend result [testdoubleobj mult10 1]
    lappend result [testdoubleobj get 1]   ;# must update string rep
} {3.14159 31.4159 31.4159}

test obj-21.1 {Tcl_NewIntObj} {
    set result ""
    lappend result [testobj freeallvars]
    lappend result [testintobj set 1 55]
    lappend result [testobj type 1]
    lappend result [testobj refcount 1]
} {{} 55 int 2}

test obj-22.1 {Tcl_SetIntObj, existing "empty string" object} {
    set result ""
    lappend result [testobj freeallvars]
    lappend result [testobj newobj 1]
    lappend result [testintobj set 1 77]  ;# makes existing obj int
    lappend result [testobj type 1]
    lappend result [testobj refcount 1]
} {{} {} 77 int 2}
test obj-22.2 {Tcl_SetIntObj, existing non-"empty string" object} {
    set result ""
    lappend result [testobj freeallvars]
    lappend result [testdoubleobj set 1 12.34]
    lappend result [testintobj set 1 77]  ;# makes existing obj int
    lappend result [testobj type 1]
    lappend result [testobj refcount 1]
} {{} 12.34 77 int 2}

test obj-23.1 {Tcl_GetIntFromObj, existing int object} {
    set result ""
    lappend result [testintobj set 1 22]
    lappend result [testintobj mult10 1]   ;# gets existing int rep
} {22 220}
test obj-23.2 {Tcl_GetIntFromObj, convert to int} {
    set result ""
    lappend result [testintobj set 1 477]
    lappend result [testintobj div10 1]    ;# must convert to bool
    lappend result [testobj type 1]
} {477 47 int}
test obj-23.3 {Tcl_GetIntFromObj, error converting to int} {
    set result ""
    lappend result [teststringobj set 1 abc]
    lappend result [catch {testintobj mult10 1} msg]
    lappend result $msg
} {abc 1 {expected integer but got "abc"}}
test obj-23.4 {Tcl_GetIntFromObj, error converting from "empty string"} {
    set result ""
    lappend result [testobj newobj 1]
    lappend result [catch {testintobj div10 1} msg]
    lappend result $msg
} {{} 1 {expected integer but got ""}}
test obj-23.5 {Tcl_GetIntFromObj, integer too large to represent as non-long error} {nonPortable} {
    set result ""
    lappend result [testobj newobj 1]
    lappend result [testintobj inttoobigtest 1]
} {{} 1}

test obj-24.1 {DupIntInternalRep} {
    set result ""
    lappend result [testintobj set 1 23]
    lappend result [testobj duplicate 1 2]    ;# uses DupIntInternalRep
    lappend result [testintobj get 2]
} {23 23 23}

test obj-25.1 {SetIntFromAny, int to int special case} {
    set result ""
    lappend result [testintobj set 1 1234]
    lappend result [testintobj mult10 1]  ;# converts with SetIntFromAny
    lappend result [testobj type 1]
} {1234 12340 int}
test obj-25.2 {SetIntFromAny, boolean to int special case} {
    set result ""
    lappend result [testbooleanobj set 1 1]
    lappend result [testintobj mult10 1]  ;# converts with SetIntFromAny
    lappend result [testobj type 1]
} {1 10 int}
test obj-25.3 {SetIntFromAny, recompute string rep then parse it} {
    set result ""
    lappend result [testintobj set 1 456]
    lappend result [testintobj div10 1]
    lappend result [testintobj mult10 1]  ;# converts with SetIntFromAny
    lappend result [testobj type 1]
} {456 45 450 int}
test obj-25.4 {SetIntFromAny, error parsing string} {
    set result ""
    lappend result [teststringobj set 1 abc]
    lappend result [catch {testintobj mult10 1} msg]
    lappend result $msg
} {abc 1 {expected integer but got "abc"}}
test obj-25.5 {SetIntFromAny, error parsing string} {
    set result ""
    lappend result [teststringobj set 1 x17]
    lappend result [catch {testintobj mult10 1} msg]
    lappend result $msg
} {x17 1 {expected integer but got "x17"}}
test obj-25.6 {SetIntFromAny, integer too large} {nonPortable} {
    set result ""
    lappend result [teststringobj set 1 123456789012345678901]
    lappend result [catch {testintobj mult10 1} msg]
    lappend result $msg
} {123456789012345678901 1 {integer value too large to represent}}
test obj-25.7 {SetIntFromAny, error converting from "empty string"} {
    set result ""
    lappend result [testobj newobj 1]
    lappend result [catch {testintobj div10 1} msg]
    lappend result $msg
} {{} 1 {expected integer but got ""}}

test obj-26.1 {UpdateStringOfInt} {
    set result ""
    lappend result [testintobj set 1 512]
    lappend result [testintobj mult10 1]
    lappend result [testintobj get 1]       ;# must update string rep
} {512 5120 5120}

test obj-27.1 {Tcl_NewLongObj} {
    set result ""
    lappend result [testobj freeallvars]
    testintobj setmaxlong 1
    lappend result [testintobj ismaxlong 1]
    lappend result [testobj type 1]
    lappend result [testobj refcount 1]
} {{} 1 int 1}

test obj-28.1 {Tcl_SetLongObj, existing "empty string" object} {
    set result ""
    lappend result [testobj freeallvars]
    lappend result [testobj newobj 1]
    lappend result [testintobj setlong 1 77]  ;# makes existing obj long int
    lappend result [testobj type 1]
    lappend result [testobj refcount 1]
} {{} {} 77 int 2}
test obj-28.2 {Tcl_SetLongObj, existing non-"empty string" object} {
    set result ""
    lappend result [testobj freeallvars]
    lappend result [testdoubleobj set 1 12.34]
    lappend result [testintobj setlong 1 77]  ;# makes existing obj long int
    lappend result [testobj type 1]
    lappend result [testobj refcount 1]
} {{} 12.34 77 int 2}

test obj-29.1 {Tcl_GetLongFromObj, existing long integer object} {
    set result ""
    lappend result [testintobj setlong 1 22]
    lappend result [testintobj mult10 1]   ;# gets existing long int rep
} {22 220}
test obj-29.2 {Tcl_GetLongFromObj, convert to long} {
    set result ""
    lappend result [testintobj setlong 1 477]
    lappend result [testintobj div10 1]    ;# must convert to bool
    lappend result [testobj type 1]
} {477 47 int}
test obj-29.3 {Tcl_GetLongFromObj, error converting to long integer} {
    set result ""
    lappend result [teststringobj set 1 abc]
    lappend result [catch {testintobj ismaxlong 1} msg] ;# cvts to long int
    lappend result $msg
} {abc 1 {expected integer but got "abc"}}
test obj-29.4 {Tcl_GetLongFromObj, error converting from "empty string"} {
    set result ""
    lappend result [testobj newobj 1]
    lappend result [catch {testintobj ismaxlong 1} msg] ;# cvts to long int
    lappend result $msg
} {{} 1 {expected integer but got ""}}

test obj-30.1 {Ref counting and object deletion, simple types} {
    set result ""
    lappend result [testobj freeallvars]
    lappend result [testintobj set 1 1024]
    lappend result [testobj assign 1 2]     ;# vars 1 and 2 share the int obj
    lappend result [testobj type 2]
    lappend result [testobj refcount 1]
    lappend result [testobj refcount 2]
    lappend result [testbooleanobj set 2 0] ;# must copy on write, now 2 objs
    lappend result [testobj type 2]
    lappend result [testobj refcount 1]
    lappend result [testobj refcount 2]
} {{} 1024 1024 int 4 4 0 boolean 3 2}


test obj-31.1 {regenerate string rep of "end"} {
    testobj freeallvars
    teststringobj set 1 end
    testobj convert 1 end-offset
    testobj invalidateStringRep 1
} end

test obj-31.2 {regenerate string rep of "end-1"} {
    testobj freeallvars
    teststringobj set 1 end-0x1
    testobj convert 1 end-offset
    testobj invalidateStringRep 1
} end-1

test obj-31.3 {regenerate string rep of "end--1"} {
    testobj freeallvars
    teststringobj set 1 end--0x1
    testobj convert 1 end-offset
    testobj invalidateStringRep 1
} end--1

test obj-31.4 {regenerate string rep of "end-bigInteger"} {
    testobj freeallvars
    teststringobj set 1 end-0x7fffffff
    testobj convert 1 end-offset
    testobj invalidateStringRep 1
} end-2147483647

test obj-31.5 {regenerate string rep of "end--bigInteger"} {
    testobj freeallvars
    teststringobj set 1 end--0x7fffffff
    testobj convert 1 end-offset
    testobj invalidateStringRep 1
} end--2147483647
    

test obj-31.6 {regenerate string rep of "end--bigInteger"} {nonPortable} {
    testobj freeallvars
    teststringobj set 1 end--0x80000000
    testobj convert 1 end-offset
    testobj invalidateStringRep 1
} end--2147483648

testobj freeallvars

# cleanup
::tcltest::cleanupTests
return
@


1.4
log
@touched all sources to ease next import
@
text
@d14 1
a14 1
# RCS: @@(#) $Id: obj.test,v 1.6.8.2 2000/09/15 16:57:06 spolk Exp $
d30 14
a43 1
    foreach {t} {list boolean cmdName bytecode string int double} {
d200 12
d556 44
a604 13













@


1.3
log
@touched all sources to ease next import
@
text
@@


1.3.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d14 1
a14 1
# RCS: @@(#) $Id: obj.test,v 1.7 2002/04/26 08:43:38 dkf Exp $
d30 1
a30 14
    foreach {t} {
	{array search} 
	boolean
	bytearray
	bytecode
	double
	end-offset
	index
	int
	list
	nsName
	procbody
	string
    } {
a186 12
test obj-11.5 {Tcl_GetBooleanFromObj, convert hex to boolean} {
    set result ""
    lappend result [teststringobj set 1 0xac]
    lappend result [testbooleanobj not 1]
    lappend result [testobj type 1]
} {0xac 0 boolean}
test obj-11.6 {Tcl_GetBooleanFromObj, convert float to boolean} {
    set result ""
    lappend result [teststringobj set 1 5.42]
    lappend result [testbooleanobj not 1]
    lappend result [testobj type 1]
} {5.42 0 boolean}
a530 44

test obj-31.1 {regenerate string rep of "end"} {
    testobj freeallvars
    teststringobj set 1 end
    testobj convert 1 end-offset
    testobj invalidateStringRep 1
} end

test obj-31.2 {regenerate string rep of "end-1"} {
    testobj freeallvars
    teststringobj set 1 end-0x1
    testobj convert 1 end-offset
    testobj invalidateStringRep 1
} end-1

test obj-31.3 {regenerate string rep of "end--1"} {
    testobj freeallvars
    teststringobj set 1 end--0x1
    testobj convert 1 end-offset
    testobj invalidateStringRep 1
} end--1

test obj-31.4 {regenerate string rep of "end-bigInteger"} {
    testobj freeallvars
    teststringobj set 1 end-0x7fffffff
    testobj convert 1 end-offset
    testobj invalidateStringRep 1
} end-2147483647

test obj-31.5 {regenerate string rep of "end--bigInteger"} {
    testobj freeallvars
    teststringobj set 1 end--0x7fffffff
    testobj convert 1 end-offset
    testobj invalidateStringRep 1
} end--2147483647
    

test obj-31.6 {regenerate string rep of "end--bigInteger"} {nonPortable} {
    testobj freeallvars
    teststringobj set 1 end--0x80000000
    testobj convert 1 end-offset
    testobj invalidateStringRep 1
} end--2147483648

d536 13
@


1.3.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@d14 1
a14 1
# RCS: @@(#) $Id: obj.test,v 1.7 2002/04/26 08:43:38 dkf Exp $
d30 1
a30 14
    foreach {t} {
	{array search} 
	boolean
	bytearray
	bytecode
	double
	end-offset
	index
	int
	list
	nsName
	procbody
	string
    } {
a186 12
test obj-11.5 {Tcl_GetBooleanFromObj, convert hex to boolean} {
    set result ""
    lappend result [teststringobj set 1 0xac]
    lappend result [testbooleanobj not 1]
    lappend result [testobj type 1]
} {0xac 0 boolean}
test obj-11.6 {Tcl_GetBooleanFromObj, convert float to boolean} {
    set result ""
    lappend result [teststringobj set 1 5.42]
    lappend result [testbooleanobj not 1]
    lappend result [testobj type 1]
} {5.42 0 boolean}
a530 44

test obj-31.1 {regenerate string rep of "end"} {
    testobj freeallvars
    teststringobj set 1 end
    testobj convert 1 end-offset
    testobj invalidateStringRep 1
} end

test obj-31.2 {regenerate string rep of "end-1"} {
    testobj freeallvars
    teststringobj set 1 end-0x1
    testobj convert 1 end-offset
    testobj invalidateStringRep 1
} end-1

test obj-31.3 {regenerate string rep of "end--1"} {
    testobj freeallvars
    teststringobj set 1 end--0x1
    testobj convert 1 end-offset
    testobj invalidateStringRep 1
} end--1

test obj-31.4 {regenerate string rep of "end-bigInteger"} {
    testobj freeallvars
    teststringobj set 1 end-0x7fffffff
    testobj convert 1 end-offset
    testobj invalidateStringRep 1
} end-2147483647

test obj-31.5 {regenerate string rep of "end--bigInteger"} {
    testobj freeallvars
    teststringobj set 1 end--0x7fffffff
    testobj convert 1 end-offset
    testobj invalidateStringRep 1
} end--2147483647
    

test obj-31.6 {regenerate string rep of "end--bigInteger"} {nonPortable} {
    testobj freeallvars
    teststringobj set 1 end--0x80000000
    testobj convert 1 end-offset
    testobj invalidateStringRep 1
} end--2147483648

d536 13
@


1.2
log
@touched all Tcl files to ease next import.
@
text
@@


1.2.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.2.16.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d30 1
a30 14
    foreach {t} {
	{array search} 
	boolean
	bytearray
	bytecode
	double
	end-offset
	index
	int
	list
	nsName
	procbody
	string
    } {
a186 12
test obj-11.5 {Tcl_GetBooleanFromObj, convert hex to boolean} {
    set result ""
    lappend result [teststringobj set 1 0xac]
    lappend result [testbooleanobj not 1]
    lappend result [testobj type 1]
} {0xac 0 boolean}
test obj-11.6 {Tcl_GetBooleanFromObj, convert float to boolean} {
    set result ""
    lappend result [teststringobj set 1 5.42]
    lappend result [testbooleanobj not 1]
    lappend result [testobj type 1]
} {5.42 0 boolean}
a530 44

test obj-31.1 {regenerate string rep of "end"} {
    testobj freeallvars
    teststringobj set 1 end
    testobj convert 1 end-offset
    testobj invalidateStringRep 1
} end

test obj-31.2 {regenerate string rep of "end-1"} {
    testobj freeallvars
    teststringobj set 1 end-0x1
    testobj convert 1 end-offset
    testobj invalidateStringRep 1
} end-1

test obj-31.3 {regenerate string rep of "end--1"} {
    testobj freeallvars
    teststringobj set 1 end--0x1
    testobj convert 1 end-offset
    testobj invalidateStringRep 1
} end--1

test obj-31.4 {regenerate string rep of "end-bigInteger"} {
    testobj freeallvars
    teststringobj set 1 end-0x7fffffff
    testobj convert 1 end-offset
    testobj invalidateStringRep 1
} end-2147483647

test obj-31.5 {regenerate string rep of "end--bigInteger"} {
    testobj freeallvars
    teststringobj set 1 end--0x7fffffff
    testobj convert 1 end-offset
    testobj invalidateStringRep 1
} end--2147483647
    

test obj-31.6 {regenerate string rep of "end--bigInteger"} {nonPortable} {
    testobj freeallvars
    teststringobj set 1 end--0x80000000
    testobj convert 1 end-offset
    testobj invalidateStringRep 1
} end--2147483648

d536 13
@


1.1
log
@Initial revision
@
text
@d9 1
d14 6
a19 1
# RCS: @@(#) $Id: obj.test,v 1.2 1998/09/14 18:40:12 stanton Exp $
d24 1
a27 2
if {[string compare test [info procs test]] == 1} then {source defs}

d91 25
a115 1
test obj-7.1 {Tcl_GetStringFromObj, return existing string rep} {
d120 1
a120 1
test obj-7.2 {Tcl_GetStringFromObj, "empty string" object} {
d126 1
a126 1
test obj-7.3 {Tcl_GetStringFromObj, returns string internal rep (DString)} {
d132 1
a132 1
test obj-7.4 {Tcl_GetStringFromObj, recompute string rep from internal rep} {
d139 1
a139 1
test obj-8.1 {Tcl_NewBooleanObj} {
d147 1
a147 1
test obj-9.1 {Tcl_SetBooleanObj, existing "empty string" object} {
d155 1
a155 1
test obj-9.2 {Tcl_SetBooleanObj, existing non-"empty string" object} {
d164 1
a164 1
test obj-10.1 {Tcl_GetBooleanFromObj, existing boolean object} {
d169 1
a169 1
test obj-10.2 {Tcl_GetBooleanFromObj, convert to boolean} {
d175 1
a175 1
test obj-10.3 {Tcl_GetBooleanFromObj, error converting to boolean} {
d181 1
a181 1
test obj-10.4 {Tcl_GetBooleanFromObj, error converting from "empty string"} {
d188 1
a188 1
test obj-11.1 {DupBooleanInternalRep} {
d195 1
a195 1
test obj-12.1 {SetBooleanFromAny, int to boolean special case} {
d201 1
a201 1
test obj-12.2 {SetBooleanFromAny, double to boolean special case} {
d207 1
a207 1
test obj-12.3 {SetBooleanFromAny, special case strings representing booleans} {
d215 1
a215 1
test obj-12.4 {SetBooleanFromAny, recompute string rep then parse it} {
d222 1
a222 1
test obj-12.5 {SetBooleanFromAny, error parsing string} {
d228 1
a228 1
test obj-12.6 {SetBooleanFromAny, error parsing string} {
d234 1
a234 1
test obj-12.7 {SetBooleanFromAny, error converting from "empty string"} {
d240 6
d247 1
a247 1
test obj-13.1 {UpdateStringOfBoolean} {
d254 1
a254 1
test obj-14.1 {Tcl_NewDoubleObj} {
d262 1
a262 1
test obj-15.1 {Tcl_SetDoubleObj, existing "empty string" object} {
d270 1
a270 1
test obj-15.2 {Tcl_SetDoubleObj, existing non-"empty string" object} {
d279 1
a279 1
test obj-16.1 {Tcl_GetDoubleFromObj, existing double object} {
d284 1
a284 1
test obj-16.2 {Tcl_GetDoubleFromObj, convert to double} {
d290 1
a290 1
test obj-16.3 {Tcl_GetDoubleFromObj, error converting to double} {
d296 1
a296 1
test obj-16.4 {Tcl_GetDoubleFromObj, error converting from "empty string"} {
d303 1
a303 1
test obj-17.1 {DupDoubleInternalRep} {
d310 1
a310 1
test obj-18.1 {SetDoubleFromAny, int to double special case} {
d316 1
a316 1
test obj-18.2 {SetDoubleFromAny, boolean to double special case} {
d322 1
a322 1
test obj-18.3 {SetDoubleFromAny, recompute string rep then parse it} {
d329 1
a329 1
test obj-18.4 {SetDoubleFromAny, error parsing string} {
d335 1
a335 1
test obj-18.5 {SetDoubleFromAny, error parsing string} {
d341 1
a341 1
test obj-18.6 {SetDoubleFromAny, error converting from "empty string"} {
d348 1
a348 1
test obj-19.1 {UpdateStringOfDouble} {
d355 1
a355 1
test obj-20.1 {Tcl_NewIntObj} {
d363 1
a363 1
test obj-21.1 {Tcl_SetIntObj, existing "empty string" object} {
d371 1
a371 1
test obj-21.2 {Tcl_SetIntObj, existing non-"empty string" object} {
d380 1
a380 1
test obj-22.1 {Tcl_GetIntFromObj, existing int object} {
d385 1
a385 1
test obj-22.2 {Tcl_GetIntFromObj, convert to int} {
d391 1
a391 1
test obj-22.3 {Tcl_GetIntFromObj, error converting to int} {
d397 1
a397 1
test obj-22.4 {Tcl_GetIntFromObj, error converting from "empty string"} {
d403 1
a403 1
test obj-22.5 {Tcl_GetIntFromObj, integer too large to represent as non-long error} {nonPortable} {
d409 1
a409 1
test obj-23.1 {DupIntInternalRep} {
d416 1
a416 1
test obj-24.1 {SetIntFromAny, int to int special case} {
d422 1
a422 1
test obj-24.2 {SetIntFromAny, boolean to int special case} {
d428 1
a428 1
test obj-24.3 {SetIntFromAny, recompute string rep then parse it} {
d435 1
a435 1
test obj-24.4 {SetIntFromAny, error parsing string} {
d441 1
a441 1
test obj-24.5 {SetIntFromAny, error parsing string} {
d447 1
a447 1
test obj-24.6 {SetIntFromAny, integer too large} {nonPortable} {
d453 1
a453 1
test obj-24.7 {SetIntFromAny, error converting from "empty string"} {
d460 1
a460 1
test obj-25.1 {UpdateStringOfInt} {
d467 1
a467 1
test obj-26.1 {Tcl_NewLongObj} {
d476 1
a476 1
test obj-27.1 {Tcl_SetLongObj, existing "empty string" object} {
d484 1
a484 1
test obj-27.2 {Tcl_SetLongObj, existing non-"empty string" object} {
d493 1
a493 1
test obj-28.1 {Tcl_GetLongFromObj, existing long integer object} {
d498 1
a498 1
test obj-28.2 {Tcl_GetLongFromObj, convert to long} {
d504 1
a504 1
test obj-28.3 {Tcl_GetLongFromObj, error converting to long integer} {
d510 1
a510 1
test obj-28.4 {Tcl_GetLongFromObj, error converting from "empty string"} {
d517 1
a517 1
test obj-29.1 {Ref counting and object deletion, simple types} {
d532 17
@


1.1.1.1
log
@import dejagnu-1999-11-08 snapshot
@
text
@@


1.1.1.2
log
@Tcl 8.3 upgrade
@
text
@a8 1
# Copyright (c) 1998-1999 by Scriptics Corporation.
d13 1
a13 6
# RCS: @@(#) $Id: obj.test,v 1.6.8.2 2000/09/15 16:57:06 spolk Exp $

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import -force ::tcltest::*
}
a17 1
    ::tcltest::cleanupTests
d21 2
d86 1
a86 25
test obj-7.1 {Tcl_GetString, return existing string rep} {
    set result ""
    lappend result [testintobj set 1 47]
    lappend result [testintobj get2 1]
} {47 47}
test obj-7.2 {Tcl_GetString, "empty string" object} {
    set result ""
    lappend result [testobj newobj 1]
    lappend result [teststringobj append 1 abc -1]
    lappend result [teststringobj get2 1]
} {{} abc abc}
test obj-7.3 {Tcl_GetString, returns string internal rep (DString)} {
    set result ""
    lappend result [teststringobj set 1 xyz]
    lappend result [teststringobj append 1 abc -1]
    lappend result [teststringobj get2 1]
} {xyz xyzabc xyzabc}
test obj-7.4 {Tcl_GetString, recompute string rep from internal rep} {
    set result ""
    lappend result [testintobj set 1 77]
    lappend result [testintobj mult10 1]
    lappend result [teststringobj get2 1]
} {77 770 770}

test obj-8.1 {Tcl_GetStringFromObj, return existing string rep} {
d91 1
a91 1
test obj-8.2 {Tcl_GetStringFromObj, "empty string" object} {
d97 1
a97 1
test obj-8.3 {Tcl_GetStringFromObj, returns string internal rep (DString)} {
d103 1
a103 1
test obj-8.4 {Tcl_GetStringFromObj, recompute string rep from internal rep} {
d110 1
a110 1
test obj-9.1 {Tcl_NewBooleanObj} {
d118 1
a118 1
test obj-10.1 {Tcl_SetBooleanObj, existing "empty string" object} {
d126 1
a126 1
test obj-10.2 {Tcl_SetBooleanObj, existing non-"empty string" object} {
d135 1
a135 1
test obj-11.1 {Tcl_GetBooleanFromObj, existing boolean object} {
d140 1
a140 1
test obj-11.2 {Tcl_GetBooleanFromObj, convert to boolean} {
d146 1
a146 1
test obj-11.3 {Tcl_GetBooleanFromObj, error converting to boolean} {
d152 1
a152 1
test obj-11.4 {Tcl_GetBooleanFromObj, error converting from "empty string"} {
d159 1
a159 1
test obj-12.1 {DupBooleanInternalRep} {
d166 1
a166 1
test obj-13.1 {SetBooleanFromAny, int to boolean special case} {
d172 1
a172 1
test obj-13.2 {SetBooleanFromAny, double to boolean special case} {
d178 1
a178 1
test obj-13.3 {SetBooleanFromAny, special case strings representing booleans} {
d186 1
a186 1
test obj-13.4 {SetBooleanFromAny, recompute string rep then parse it} {
d193 1
a193 1
test obj-13.5 {SetBooleanFromAny, error parsing string} {
d199 1
a199 1
test obj-13.6 {SetBooleanFromAny, error parsing string} {
d205 1
a205 1
test obj-13.7 {SetBooleanFromAny, error converting from "empty string"} {
a210 6
test obj-13.8 {SetBooleanFromAny, unicode strings} {
    set result ""
    lappend result [teststringobj set 1 1\u7777]
    lappend result [catch {testbooleanobj not 1} msg]
    lappend result $msg
} "1\u7777 1 {expected boolean value but got \"1\u7777\"}"
d212 1
a212 1
test obj-14.1 {UpdateStringOfBoolean} {
d219 1
a219 1
test obj-15.1 {Tcl_NewDoubleObj} {
d227 1
a227 1
test obj-16.1 {Tcl_SetDoubleObj, existing "empty string" object} {
d235 1
a235 1
test obj-16.2 {Tcl_SetDoubleObj, existing non-"empty string" object} {
d244 1
a244 1
test obj-17.1 {Tcl_GetDoubleFromObj, existing double object} {
d249 1
a249 1
test obj-17.2 {Tcl_GetDoubleFromObj, convert to double} {
d255 1
a255 1
test obj-17.3 {Tcl_GetDoubleFromObj, error converting to double} {
d261 1
a261 1
test obj-17.4 {Tcl_GetDoubleFromObj, error converting from "empty string"} {
d268 1
a268 1
test obj-18.1 {DupDoubleInternalRep} {
d275 1
a275 1
test obj-19.1 {SetDoubleFromAny, int to double special case} {
d281 1
a281 1
test obj-19.2 {SetDoubleFromAny, boolean to double special case} {
d287 1
a287 1
test obj-19.3 {SetDoubleFromAny, recompute string rep then parse it} {
d294 1
a294 1
test obj-19.4 {SetDoubleFromAny, error parsing string} {
d300 1
a300 1
test obj-19.5 {SetDoubleFromAny, error parsing string} {
d306 1
a306 1
test obj-19.6 {SetDoubleFromAny, error converting from "empty string"} {
d313 1
a313 1
test obj-20.1 {UpdateStringOfDouble} {
d320 1
a320 1
test obj-21.1 {Tcl_NewIntObj} {
d328 1
a328 1
test obj-22.1 {Tcl_SetIntObj, existing "empty string" object} {
d336 1
a336 1
test obj-22.2 {Tcl_SetIntObj, existing non-"empty string" object} {
d345 1
a345 1
test obj-23.1 {Tcl_GetIntFromObj, existing int object} {
d350 1
a350 1
test obj-23.2 {Tcl_GetIntFromObj, convert to int} {
d356 1
a356 1
test obj-23.3 {Tcl_GetIntFromObj, error converting to int} {
d362 1
a362 1
test obj-23.4 {Tcl_GetIntFromObj, error converting from "empty string"} {
d368 1
a368 1
test obj-23.5 {Tcl_GetIntFromObj, integer too large to represent as non-long error} {nonPortable} {
d374 1
a374 1
test obj-24.1 {DupIntInternalRep} {
d381 1
a381 1
test obj-25.1 {SetIntFromAny, int to int special case} {
d387 1
a387 1
test obj-25.2 {SetIntFromAny, boolean to int special case} {
d393 1
a393 1
test obj-25.3 {SetIntFromAny, recompute string rep then parse it} {
d400 1
a400 1
test obj-25.4 {SetIntFromAny, error parsing string} {
d406 1
a406 1
test obj-25.5 {SetIntFromAny, error parsing string} {
d412 1
a412 1
test obj-25.6 {SetIntFromAny, integer too large} {nonPortable} {
d418 1
a418 1
test obj-25.7 {SetIntFromAny, error converting from "empty string"} {
d425 1
a425 1
test obj-26.1 {UpdateStringOfInt} {
d432 1
a432 1
test obj-27.1 {Tcl_NewLongObj} {
d441 1
a441 1
test obj-28.1 {Tcl_SetLongObj, existing "empty string" object} {
d449 1
a449 1
test obj-28.2 {Tcl_SetLongObj, existing non-"empty string" object} {
d458 1
a458 1
test obj-29.1 {Tcl_GetLongFromObj, existing long integer object} {
d463 1
a463 1
test obj-29.2 {Tcl_GetLongFromObj, convert to long} {
d469 1
a469 1
test obj-29.3 {Tcl_GetLongFromObj, error converting to long integer} {
d475 1
a475 1
test obj-29.4 {Tcl_GetLongFromObj, error converting from "empty string"} {
d482 1
a482 1
test obj-30.1 {Ref counting and object deletion, simple types} {
a496 17

# cleanup
::tcltest::cleanupTests
return













@


1.1.1.3
log
@import tcl 8.4.0
@
text
@d14 1
a14 1
# RCS: @@(#) $Id: obj.test,v 1.7 2002/04/26 08:43:38 dkf Exp $
d30 1
a30 14
    foreach {t} {
	{array search} 
	boolean
	bytearray
	bytecode
	double
	end-offset
	index
	int
	list
	nsName
	procbody
	string
    } {
a186 12
test obj-11.5 {Tcl_GetBooleanFromObj, convert hex to boolean} {
    set result ""
    lappend result [teststringobj set 1 0xac]
    lappend result [testbooleanobj not 1]
    lappend result [testobj type 1]
} {0xac 0 boolean}
test obj-11.6 {Tcl_GetBooleanFromObj, convert float to boolean} {
    set result ""
    lappend result [teststringobj set 1 5.42]
    lappend result [testbooleanobj not 1]
    lappend result [testobj type 1]
} {5.42 0 boolean}
a530 44

test obj-31.1 {regenerate string rep of "end"} {
    testobj freeallvars
    teststringobj set 1 end
    testobj convert 1 end-offset
    testobj invalidateStringRep 1
} end

test obj-31.2 {regenerate string rep of "end-1"} {
    testobj freeallvars
    teststringobj set 1 end-0x1
    testobj convert 1 end-offset
    testobj invalidateStringRep 1
} end-1

test obj-31.3 {regenerate string rep of "end--1"} {
    testobj freeallvars
    teststringobj set 1 end--0x1
    testobj convert 1 end-offset
    testobj invalidateStringRep 1
} end--1

test obj-31.4 {regenerate string rep of "end-bigInteger"} {
    testobj freeallvars
    teststringobj set 1 end-0x7fffffff
    testobj convert 1 end-offset
    testobj invalidateStringRep 1
} end-2147483647

test obj-31.5 {regenerate string rep of "end--bigInteger"} {
    testobj freeallvars
    teststringobj set 1 end--0x7fffffff
    testobj convert 1 end-offset
    testobj invalidateStringRep 1
} end--2147483647
    

test obj-31.6 {regenerate string rep of "end--bigInteger"} {nonPortable} {
    testobj freeallvars
    teststringobj set 1 end--0x80000000
    testobj convert 1 end-offset
    testobj invalidateStringRep 1
} end--2147483648

d536 13
@


1.1.1.4
log
@import tk 8.4.0
@
text
@d1 3
a3 2
# This file is a Tcl script to test new object types in Tk.
# It is organized in the standard fashion for Tcl tests.
d5 4
a8 1
# Copyright (c) 1997 Sun Microsystems, Inc.
a9 1
# All rights reserved.
d11 4
a14 17
# RCS: @@(#) $Id: obj.test,v 1.3 2002/07/13 20:28:35 dgp Exp $

package require tcltest 2.1
namespace import -force tcltest::configure
namespace import -force tcltest::testsDirectory
configure -testdir [file join [pwd] [file dirname [info script]]]
configure -loadfile [file join [testsDirectory] constraints.tcl]
tcltest::loadTestedCommands

test obj-1.1 {TkGetPixelsFromObj} {
} {}

test obj-2.1 {FreePixelInternalRep} {
} {}

test obj-3.1 {DupPixelInternalRep} {
} {}
d16 583
a598 2
test obj-4.1 {SetPixelFromAny} {
} {}
d600 1
a600 3


deleteWindows
a604 14














@


1.1.1.5
log
@one more time: import tcl 8.4.0
@
text
@d1 2
a2 3
# Functionality covered: this file contains a collection of tests for the
# procedures in tclObj.c that implement Tcl's basic type support and the
# type managers for the types boolean, double, and integer.
d4 1
a4 4
# Sourcing this file into Tcl runs the tests and generates output for
# errors. No output means no errors were found.
#
# Copyright (c) 1995-1996 Sun Microsystems, Inc.
d6 1
d8 21
a28 4
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# RCS: @@(#) $Id: obj.test,v 1.7 2002/04/26 08:43:38 dkf Exp $
a29 583
if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import -force ::tcltest::*
}

if {[info commands testobj] == {}} {
    puts "This application hasn't been compiled with the \"testobj\""
    puts "command, so I can't test the Tcl type and object support."
    ::tcltest::cleanupTests
    return
}

test obj-1.1 {Tcl_AppendAllObjTypes, and InitTypeTable, Tcl_RegisterObjType} {
    set r 1
    foreach {t} {
	{array search} 
	boolean
	bytearray
	bytecode
	double
	end-offset
	index
	int
	list
	nsName
	procbody
	string
    } {
        set first [string first $t [testobj types]]
        set r [expr {$r && ($first != -1)}]
    }
    set result $r
} {1}

test obj-2.1 {Tcl_GetObjType error} {
    list [testintobj set 1 0] [catch {testobj convert 1 foo} msg] $msg
} {0 1 {no type foo found}}
test obj-2.2 {Tcl_GetObjType and Tcl_ConvertToType} {
    set result ""
    lappend result [testobj freeallvars]
    lappend result [testintobj set 1 12]
    lappend result [testobj convert 1 double]
    lappend result [testobj type 1]
    lappend result [testobj refcount 1]
} {{} 12 12 double 3}

test obj-3.1 {Tcl_ConvertToType error} {
    list [testdoubleobj set 1 12.34] [catch {testobj convert 1 int} msg] $msg
} {12.34 1 {expected integer but got "12.34"}}
test obj-3.2 {Tcl_ConvertToType error, "empty string" object} {
    list [testobj newobj 1] [catch {testobj convert 1 int} msg] $msg
} {{} 1 {expected integer but got ""}}

test obj-4.1 {Tcl_NewObj and AllocateFreeObjects} {
    set result ""
    lappend result [testobj freeallvars]
    lappend result [testobj newobj 1]
    lappend result [testobj type 1]
    lappend result [testobj refcount 1]
} {{} {} string 2}

test obj-5.1 {Tcl_FreeObj} {
    set result ""
    lappend result [testintobj set 1 12345]
    lappend result [testobj freeallvars]
    lappend result [catch {testintobj get 1} msg]
    lappend result $msg
} {12345 {} 1 {variable 1 is unset (NULL)}}

test obj-6.1 {Tcl_DuplicateObj, object has internal rep} {
    set result ""
    lappend result [testobj freeallvars]
    lappend result [testintobj set 1 47]
    lappend result [testobj duplicate 1 2]    
    lappend result [testintobj get 2]
    lappend result [testobj refcount 1]
    lappend result [testobj refcount 2]
} {{} 47 47 47 2 3}
test obj-6.2 {Tcl_DuplicateObj, "empty string" object} {
    set result ""
    lappend result [testobj freeallvars]
    lappend result [testobj newobj 1]
    lappend result [testobj duplicate 1 2]    
    lappend result [testintobj get 2]
    lappend result [testobj refcount 1]
    lappend result [testobj refcount 2]
} {{} {} {} {} 2 3}

test obj-7.1 {Tcl_GetString, return existing string rep} {
    set result ""
    lappend result [testintobj set 1 47]
    lappend result [testintobj get2 1]
} {47 47}
test obj-7.2 {Tcl_GetString, "empty string" object} {
    set result ""
    lappend result [testobj newobj 1]
    lappend result [teststringobj append 1 abc -1]
    lappend result [teststringobj get2 1]
} {{} abc abc}
test obj-7.3 {Tcl_GetString, returns string internal rep (DString)} {
    set result ""
    lappend result [teststringobj set 1 xyz]
    lappend result [teststringobj append 1 abc -1]
    lappend result [teststringobj get2 1]
} {xyz xyzabc xyzabc}
test obj-7.4 {Tcl_GetString, recompute string rep from internal rep} {
    set result ""
    lappend result [testintobj set 1 77]
    lappend result [testintobj mult10 1]
    lappend result [teststringobj get2 1]
} {77 770 770}

test obj-8.1 {Tcl_GetStringFromObj, return existing string rep} {
    set result ""
    lappend result [testintobj set 1 47]
    lappend result [testintobj get 1]
} {47 47}
test obj-8.2 {Tcl_GetStringFromObj, "empty string" object} {
    set result ""
    lappend result [testobj newobj 1]
    lappend result [teststringobj append 1 abc -1]
    lappend result [teststringobj get 1]
} {{} abc abc}
test obj-8.3 {Tcl_GetStringFromObj, returns string internal rep (DString)} {
    set result ""
    lappend result [teststringobj set 1 xyz]
    lappend result [teststringobj append 1 abc -1]
    lappend result [teststringobj get 1]
} {xyz xyzabc xyzabc}
test obj-8.4 {Tcl_GetStringFromObj, recompute string rep from internal rep} {
    set result ""
    lappend result [testintobj set 1 77]
    lappend result [testintobj mult10 1]
    lappend result [teststringobj get 1]
} {77 770 770}

test obj-9.1 {Tcl_NewBooleanObj} {
    set result ""
    lappend result [testobj freeallvars]
    lappend result [testbooleanobj set 1 0]
    lappend result [testobj type 1]
    lappend result [testobj refcount 1]
} {{} 0 boolean 2}

test obj-10.1 {Tcl_SetBooleanObj, existing "empty string" object} {
    set result ""
    lappend result [testobj freeallvars]
    lappend result [testobj newobj 1]
    lappend result [testbooleanobj set 1 0]  ;# makes existing obj boolean
    lappend result [testobj type 1]
    lappend result [testobj refcount 1]
} {{} {} 0 boolean 2}
test obj-10.2 {Tcl_SetBooleanObj, existing non-"empty string" object} {
    set result ""
    lappend result [testobj freeallvars]
    lappend result [testintobj set 1 98765]
    lappend result [testbooleanobj set 1 1]  ;# makes existing obj boolean
    lappend result [testobj type 1]
    lappend result [testobj refcount 1]
} {{} 98765 1 boolean 2}

test obj-11.1 {Tcl_GetBooleanFromObj, existing boolean object} {
    set result ""
    lappend result [testbooleanobj set 1 1]
    lappend result [testbooleanobj not 1]    ;# gets existing boolean rep
} {1 0}
test obj-11.2 {Tcl_GetBooleanFromObj, convert to boolean} {
    set result ""
    lappend result [testintobj set 1 47]
    lappend result [testbooleanobj not 1]    ;# must convert to bool
    lappend result [testobj type 1]
} {47 0 boolean}
test obj-11.3 {Tcl_GetBooleanFromObj, error converting to boolean} {
    set result ""
    lappend result [teststringobj set 1 abc]
    lappend result [catch {testbooleanobj not 1} msg]
    lappend result $msg
} {abc 1 {expected boolean value but got "abc"}}
test obj-11.4 {Tcl_GetBooleanFromObj, error converting from "empty string"} {
    set result ""
    lappend result [testobj newobj 1]
    lappend result [catch {testbooleanobj not 1} msg]
    lappend result $msg
} {{} 1 {expected boolean value but got ""}}
test obj-11.5 {Tcl_GetBooleanFromObj, convert hex to boolean} {
    set result ""
    lappend result [teststringobj set 1 0xac]
    lappend result [testbooleanobj not 1]
    lappend result [testobj type 1]
} {0xac 0 boolean}
test obj-11.6 {Tcl_GetBooleanFromObj, convert float to boolean} {
    set result ""
    lappend result [teststringobj set 1 5.42]
    lappend result [testbooleanobj not 1]
    lappend result [testobj type 1]
} {5.42 0 boolean}

test obj-12.1 {DupBooleanInternalRep} {
    set result ""
    lappend result [testbooleanobj set 1 1]
    lappend result [testobj duplicate 1 2]   ;# uses DupBooleanInternalRep
    lappend result [testbooleanobj get 2]
} {1 1 1}

test obj-13.1 {SetBooleanFromAny, int to boolean special case} {
    set result ""
    lappend result [testintobj set 1 1234]
    lappend result [testbooleanobj not 1]    ;# converts with SetBooleanFromAny
    lappend result [testobj type 1]
} {1234 0 boolean}
test obj-13.2 {SetBooleanFromAny, double to boolean special case} {
    set result ""
    lappend result [testdoubleobj set 1 3.14159]
    lappend result [testbooleanobj not 1]    ;# converts with SetBooleanFromAny
    lappend result [testobj type 1]
} {3.14159 0 boolean}
test obj-13.3 {SetBooleanFromAny, special case strings representing booleans} {
    set result ""
    foreach s {yes no true false on off} {
        teststringobj set 1 $s
        lappend result [testbooleanobj not 1]
    }
    lappend result [testobj type 1]
} {0 1 0 1 0 1 boolean}
test obj-13.4 {SetBooleanFromAny, recompute string rep then parse it} {
    set result ""
    lappend result [testintobj set 1 456]
    lappend result [testintobj div10 1]
    lappend result [testbooleanobj not 1]    ;# converts with SetBooleanFromAny
    lappend result [testobj type 1]
} {456 45 0 boolean}
test obj-13.5 {SetBooleanFromAny, error parsing string} {
    set result ""
    lappend result [teststringobj set 1 abc]
    lappend result [catch {testbooleanobj not 1} msg]
    lappend result $msg
} {abc 1 {expected boolean value but got "abc"}}
test obj-13.6 {SetBooleanFromAny, error parsing string} {
    set result ""
    lappend result [teststringobj set 1 x1.0]
    lappend result [catch {testbooleanobj not 1} msg]
    lappend result $msg
} {x1.0 1 {expected boolean value but got "x1.0"}}
test obj-13.7 {SetBooleanFromAny, error converting from "empty string"} {
    set result ""
    lappend result [testobj newobj 1]
    lappend result [catch {testbooleanobj not 1} msg]
    lappend result $msg
} {{} 1 {expected boolean value but got ""}}
test obj-13.8 {SetBooleanFromAny, unicode strings} {
    set result ""
    lappend result [teststringobj set 1 1\u7777]
    lappend result [catch {testbooleanobj not 1} msg]
    lappend result $msg
} "1\u7777 1 {expected boolean value but got \"1\u7777\"}"

test obj-14.1 {UpdateStringOfBoolean} {
    set result ""
    lappend result [testbooleanobj set 1 0]
    lappend result [testbooleanobj not 1]
    lappend result [testbooleanobj get 1]    ;# must update string rep
} {0 1 1}

test obj-15.1 {Tcl_NewDoubleObj} {
    set result ""
    lappend result [testobj freeallvars]
    lappend result [testdoubleobj set 1 3.1459]
    lappend result [testobj type 1]
    lappend result [testobj refcount 1]
} {{} 3.1459 double 2}

test obj-16.1 {Tcl_SetDoubleObj, existing "empty string" object} {
    set result ""
    lappend result [testobj freeallvars]
    lappend result [testobj newobj 1]
    lappend result [testdoubleobj set 1 0.123]  ;# makes existing obj boolean
    lappend result [testobj type 1]
    lappend result [testobj refcount 1]
} {{} {} 0.123 double 2}
test obj-16.2 {Tcl_SetDoubleObj, existing non-"empty string" object} {
    set result ""
    lappend result [testobj freeallvars]
    lappend result [testintobj set 1 98765]
    lappend result [testdoubleobj set 1 27.56]  ;# makes existing obj double
    lappend result [testobj type 1]
    lappend result [testobj refcount 1]
} {{} 98765 27.56 double 2}

test obj-17.1 {Tcl_GetDoubleFromObj, existing double object} {
    set result ""
    lappend result [testdoubleobj set 1 16.1]
    lappend result [testdoubleobj mult10 1]   ;# gets existing double rep
} {16.1 161.0}
test obj-17.2 {Tcl_GetDoubleFromObj, convert to double} {
    set result ""
    lappend result [testintobj set 1 477]
    lappend result [testdoubleobj div10 1]    ;# must convert to bool
    lappend result [testobj type 1]
} {477 47.7 double}
test obj-17.3 {Tcl_GetDoubleFromObj, error converting to double} {
    set result ""
    lappend result [teststringobj set 1 abc]
    lappend result [catch {testdoubleobj mult10 1} msg]
    lappend result $msg
} {abc 1 {expected floating-point number but got "abc"}}
test obj-17.4 {Tcl_GetDoubleFromObj, error converting from "empty string"} {
    set result ""
    lappend result [testobj newobj 1]
    lappend result [catch {testdoubleobj div10 1} msg]
    lappend result $msg
} {{} 1 {expected floating-point number but got ""}}

test obj-18.1 {DupDoubleInternalRep} {
    set result ""
    lappend result [testdoubleobj set 1 17.1]
    lappend result [testobj duplicate 1 2]      ;# uses DupDoubleInternalRep
    lappend result [testdoubleobj get 2]
} {17.1 17.1 17.1}

test obj-19.1 {SetDoubleFromAny, int to double special case} {
    set result ""
    lappend result [testintobj set 1 1234]
    lappend result [testdoubleobj mult10 1] ;# converts with SetDoubleFromAny
    lappend result [testobj type 1]
} {1234 12340.0 double}
test obj-19.2 {SetDoubleFromAny, boolean to double special case} {
    set result ""
    lappend result [testbooleanobj set 1 1]
    lappend result [testdoubleobj mult10 1] ;# converts with SetDoubleFromAny
    lappend result [testobj type 1]
} {1 10.0 double}
test obj-19.3 {SetDoubleFromAny, recompute string rep then parse it} {
    set result ""
    lappend result [testintobj set 1 456]
    lappend result [testintobj div10 1]
    lappend result [testdoubleobj mult10 1] ;# converts with SetDoubleFromAny
    lappend result [testobj type 1]
} {456 45 450.0 double}
test obj-19.4 {SetDoubleFromAny, error parsing string} {
    set result ""
    lappend result [teststringobj set 1 abc]
    lappend result [catch {testdoubleobj mult10 1} msg]
    lappend result $msg
} {abc 1 {expected floating-point number but got "abc"}}
test obj-19.5 {SetDoubleFromAny, error parsing string} {
    set result ""
    lappend result [teststringobj set 1 x1.0]
    lappend result [catch {testdoubleobj mult10 1} msg]
    lappend result $msg
} {x1.0 1 {expected floating-point number but got "x1.0"}}
test obj-19.6 {SetDoubleFromAny, error converting from "empty string"} {
    set result ""
    lappend result [testobj newobj 1]
    lappend result [catch {testdoubleobj div10 1} msg]
    lappend result $msg
} {{} 1 {expected floating-point number but got ""}}

test obj-20.1 {UpdateStringOfDouble} {
    set result ""
    lappend result [testdoubleobj set 1 3.14159]
    lappend result [testdoubleobj mult10 1]
    lappend result [testdoubleobj get 1]   ;# must update string rep
} {3.14159 31.4159 31.4159}

test obj-21.1 {Tcl_NewIntObj} {
    set result ""
    lappend result [testobj freeallvars]
    lappend result [testintobj set 1 55]
    lappend result [testobj type 1]
    lappend result [testobj refcount 1]
} {{} 55 int 2}

test obj-22.1 {Tcl_SetIntObj, existing "empty string" object} {
    set result ""
    lappend result [testobj freeallvars]
    lappend result [testobj newobj 1]
    lappend result [testintobj set 1 77]  ;# makes existing obj int
    lappend result [testobj type 1]
    lappend result [testobj refcount 1]
} {{} {} 77 int 2}
test obj-22.2 {Tcl_SetIntObj, existing non-"empty string" object} {
    set result ""
    lappend result [testobj freeallvars]
    lappend result [testdoubleobj set 1 12.34]
    lappend result [testintobj set 1 77]  ;# makes existing obj int
    lappend result [testobj type 1]
    lappend result [testobj refcount 1]
} {{} 12.34 77 int 2}

test obj-23.1 {Tcl_GetIntFromObj, existing int object} {
    set result ""
    lappend result [testintobj set 1 22]
    lappend result [testintobj mult10 1]   ;# gets existing int rep
} {22 220}
test obj-23.2 {Tcl_GetIntFromObj, convert to int} {
    set result ""
    lappend result [testintobj set 1 477]
    lappend result [testintobj div10 1]    ;# must convert to bool
    lappend result [testobj type 1]
} {477 47 int}
test obj-23.3 {Tcl_GetIntFromObj, error converting to int} {
    set result ""
    lappend result [teststringobj set 1 abc]
    lappend result [catch {testintobj mult10 1} msg]
    lappend result $msg
} {abc 1 {expected integer but got "abc"}}
test obj-23.4 {Tcl_GetIntFromObj, error converting from "empty string"} {
    set result ""
    lappend result [testobj newobj 1]
    lappend result [catch {testintobj div10 1} msg]
    lappend result $msg
} {{} 1 {expected integer but got ""}}
test obj-23.5 {Tcl_GetIntFromObj, integer too large to represent as non-long error} {nonPortable} {
    set result ""
    lappend result [testobj newobj 1]
    lappend result [testintobj inttoobigtest 1]
} {{} 1}

test obj-24.1 {DupIntInternalRep} {
    set result ""
    lappend result [testintobj set 1 23]
    lappend result [testobj duplicate 1 2]    ;# uses DupIntInternalRep
    lappend result [testintobj get 2]
} {23 23 23}

test obj-25.1 {SetIntFromAny, int to int special case} {
    set result ""
    lappend result [testintobj set 1 1234]
    lappend result [testintobj mult10 1]  ;# converts with SetIntFromAny
    lappend result [testobj type 1]
} {1234 12340 int}
test obj-25.2 {SetIntFromAny, boolean to int special case} {
    set result ""
    lappend result [testbooleanobj set 1 1]
    lappend result [testintobj mult10 1]  ;# converts with SetIntFromAny
    lappend result [testobj type 1]
} {1 10 int}
test obj-25.3 {SetIntFromAny, recompute string rep then parse it} {
    set result ""
    lappend result [testintobj set 1 456]
    lappend result [testintobj div10 1]
    lappend result [testintobj mult10 1]  ;# converts with SetIntFromAny
    lappend result [testobj type 1]
} {456 45 450 int}
test obj-25.4 {SetIntFromAny, error parsing string} {
    set result ""
    lappend result [teststringobj set 1 abc]
    lappend result [catch {testintobj mult10 1} msg]
    lappend result $msg
} {abc 1 {expected integer but got "abc"}}
test obj-25.5 {SetIntFromAny, error parsing string} {
    set result ""
    lappend result [teststringobj set 1 x17]
    lappend result [catch {testintobj mult10 1} msg]
    lappend result $msg
} {x17 1 {expected integer but got "x17"}}
test obj-25.6 {SetIntFromAny, integer too large} {nonPortable} {
    set result ""
    lappend result [teststringobj set 1 123456789012345678901]
    lappend result [catch {testintobj mult10 1} msg]
    lappend result $msg
} {123456789012345678901 1 {integer value too large to represent}}
test obj-25.7 {SetIntFromAny, error converting from "empty string"} {
    set result ""
    lappend result [testobj newobj 1]
    lappend result [catch {testintobj div10 1} msg]
    lappend result $msg
} {{} 1 {expected integer but got ""}}

test obj-26.1 {UpdateStringOfInt} {
    set result ""
    lappend result [testintobj set 1 512]
    lappend result [testintobj mult10 1]
    lappend result [testintobj get 1]       ;# must update string rep
} {512 5120 5120}

test obj-27.1 {Tcl_NewLongObj} {
    set result ""
    lappend result [testobj freeallvars]
    testintobj setmaxlong 1
    lappend result [testintobj ismaxlong 1]
    lappend result [testobj type 1]
    lappend result [testobj refcount 1]
} {{} 1 int 1}

test obj-28.1 {Tcl_SetLongObj, existing "empty string" object} {
    set result ""
    lappend result [testobj freeallvars]
    lappend result [testobj newobj 1]
    lappend result [testintobj setlong 1 77]  ;# makes existing obj long int
    lappend result [testobj type 1]
    lappend result [testobj refcount 1]
} {{} {} 77 int 2}
test obj-28.2 {Tcl_SetLongObj, existing non-"empty string" object} {
    set result ""
    lappend result [testobj freeallvars]
    lappend result [testdoubleobj set 1 12.34]
    lappend result [testintobj setlong 1 77]  ;# makes existing obj long int
    lappend result [testobj type 1]
    lappend result [testobj refcount 1]
} {{} 12.34 77 int 2}

test obj-29.1 {Tcl_GetLongFromObj, existing long integer object} {
    set result ""
    lappend result [testintobj setlong 1 22]
    lappend result [testintobj mult10 1]   ;# gets existing long int rep
} {22 220}
test obj-29.2 {Tcl_GetLongFromObj, convert to long} {
    set result ""
    lappend result [testintobj setlong 1 477]
    lappend result [testintobj div10 1]    ;# must convert to bool
    lappend result [testobj type 1]
} {477 47 int}
test obj-29.3 {Tcl_GetLongFromObj, error converting to long integer} {
    set result ""
    lappend result [teststringobj set 1 abc]
    lappend result [catch {testintobj ismaxlong 1} msg] ;# cvts to long int
    lappend result $msg
} {abc 1 {expected integer but got "abc"}}
test obj-29.4 {Tcl_GetLongFromObj, error converting from "empty string"} {
    set result ""
    lappend result [testobj newobj 1]
    lappend result [catch {testintobj ismaxlong 1} msg] ;# cvts to long int
    lappend result $msg
} {{} 1 {expected integer but got ""}}

test obj-30.1 {Ref counting and object deletion, simple types} {
    set result ""
    lappend result [testobj freeallvars]
    lappend result [testintobj set 1 1024]
    lappend result [testobj assign 1 2]     ;# vars 1 and 2 share the int obj
    lappend result [testobj type 2]
    lappend result [testobj refcount 1]
    lappend result [testobj refcount 2]
    lappend result [testbooleanobj set 2 0] ;# must copy on write, now 2 objs
    lappend result [testobj type 2]
    lappend result [testobj refcount 1]
    lappend result [testobj refcount 2]
} {{} 1024 1024 int 4 4 0 boolean 3 2}


test obj-31.1 {regenerate string rep of "end"} {
    testobj freeallvars
    teststringobj set 1 end
    testobj convert 1 end-offset
    testobj invalidateStringRep 1
} end

test obj-31.2 {regenerate string rep of "end-1"} {
    testobj freeallvars
    teststringobj set 1 end-0x1
    testobj convert 1 end-offset
    testobj invalidateStringRep 1
} end-1

test obj-31.3 {regenerate string rep of "end--1"} {
    testobj freeallvars
    teststringobj set 1 end--0x1
    testobj convert 1 end-offset
    testobj invalidateStringRep 1
} end--1

test obj-31.4 {regenerate string rep of "end-bigInteger"} {
    testobj freeallvars
    teststringobj set 1 end-0x7fffffff
    testobj convert 1 end-offset
    testobj invalidateStringRep 1
} end-2147483647

test obj-31.5 {regenerate string rep of "end--bigInteger"} {
    testobj freeallvars
    teststringobj set 1 end--0x7fffffff
    testobj convert 1 end-offset
    testobj invalidateStringRep 1
} end--2147483647
    

test obj-31.6 {regenerate string rep of "end--bigInteger"} {nonPortable} {
    testobj freeallvars
    teststringobj set 1 end--0x80000000
    testobj convert 1 end-offset
    testobj invalidateStringRep 1
} end--2147483648
d31 1
a31 1
testobj freeallvars
d36 14
@


