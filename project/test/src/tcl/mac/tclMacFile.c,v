head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.58
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.56
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.54
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.52
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.50
	gdb_7_0-branch:1.5.0.48
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tcl8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.46
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.44
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.42
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.40
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.38
	gdb_6_5-2006-05-14-branchpoint:1.5
	readline_5_1-import-branch:1.5.0.36
	readline_5_1-import-branchpoint:1.5
	gdb_6_4-branch:1.5.0.34
	gdb_6_4-2005-11-01-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.32
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	ezannoni_pie-20040323-branch:1.5.0.30
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.28
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.26
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.24
	cagney_x86i386-20030821-branch:1.5.0.22
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.20
	gdb_6_0-2003-06-23-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.18
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.16
	cagney_writestrings-20030508-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.14
	cagney_fileio-20030521-branchpoint:1.5
	carlton_dictionary-20030430-merge:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.12
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.10
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.8
	cagney_lazyid-20030317-branchpoint:1.5
	offbyone-20030313-branch:1.5.0.6
	offbyone-20030313-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.4
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.2
	interps-20030202-branchpoint:1.5
	TCL8_4_1:1.1.1.4
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.2
	TCL_8_4_1:1.1.1.4
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.4
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TCL_8_4_0:1.1.1.3
	carlton_dictionary-branch:1.2.0.16
	carlton_dictionary-20020920-branchpoint:1.2
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.14
	gdb_5_3-branch:1.2.0.12
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.10
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.8
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.6
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TCL_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	dejagnu-2000-02-04:1.1.1.1
	dejagnu-2000-01-31:1.1.1.1
	dejagnu-2000-01-24:1.1.1.1
	dejagnu-2000-01-17:1.1.1.1
	dejagnu-2000-01-10:1.1.1.1
	dejagnu-2000-01-04:1.1.1.1
	dejagnu-1999-12-21:1.1.1.1
	dejagnu-1999-12-13:1.1.1.1
	dejagnu-1999-12-07:1.1.1.1
	dejagnu-1999-12-06:1.1.1.1
	dejagnu-1999-11-15:1.1.1.1
	dejagnu-1999-11-08:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.5
date	2003.01.21.19.40.11;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.26.19.47.59;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.37.06;	author kseitz;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2001.09.09.23.56.07;	author irox;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	99.11.09.01.28.43;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2002.09.27.21.49.09;	author kseitz;	state Exp;
branches;
next	;

1.3.4.1
date	2003.12.14.20.28.47;	author drow;	state Exp;
branches;
next	;

1.2.16.1
date	2002.12.23.19.40.33;	author carlton;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2003.02.07.19.18.16;	author carlton;	state Exp;
branches;
next	;

1.1.1.1
date	99.11.09.01.28.43;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.09.22.40.57;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.19.56.52;	author kseitz;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.11.26.20.01.36;	author hunt;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tcl 8.4.1
@
text
@/* 
 * tclMacFile.c --
 *
 *      This file implements the channel drivers for Macintosh
 *	files.  It also comtains Macintosh version of other Tcl
 *	functions that deal with the file system.
 *
 * Copyright (c) 1995-1998 Sun Microsystems, Inc.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tclMacFile.c,v 1.25 2002/10/09 11:54:24 das Exp $
 */

/*
 * Note: This code eventually needs to support async I/O.  In doing this
 * we will need to keep track of all current async I/O.  If exit to shell
 * is called - we shouldn't exit until all asyc I/O completes.
 */

#include "tclInt.h"
#include "tclPort.h"
#include "tclMacInt.h"
#include <Aliases.h>
#include <Errors.h>
#include <Processes.h>
#include <Strings.h>
#include <Types.h>
#include <MoreFiles.h>
#include <MoreFilesExtras.h>
#include <FSpCompat.h>

static int NativeMatchType(Tcl_Obj *tempName, Tcl_GlobTypeData *types, 
			   HFileInfo fileInfo, OSType okType, OSType okCreator);
static OSErr FspLocationFromFsPath _ANSI_ARGS_((Tcl_Obj *pathPtr, 
						FSSpec* specPtr));
static OSErr FspLLocationFromFsPath _ANSI_ARGS_((Tcl_Obj *pathPtr, 
						FSSpec* specPtr));

static OSErr 
FspLocationFromFsPath(pathPtr, specPtr)
    Tcl_Obj *pathPtr;
    FSSpec* specPtr;
{
    CONST char *native = Tcl_FSGetNativePath(pathPtr);
    return FSpLocationFromPath(strlen(native), native, specPtr);
}

static OSErr 
FspLLocationFromFsPath(pathPtr, specPtr)
    Tcl_Obj *pathPtr;
    FSSpec* specPtr;
{
    CONST char *native = Tcl_FSGetNativePath(pathPtr);
    return FSpLLocationFromPath(strlen(native), native, specPtr);
}


/*
 *----------------------------------------------------------------------
 *
 * TclpFindExecutable --
 *
 *	This procedure computes the absolute path name of the current
 *	application, given its argv[0] value.  However, this
 *	implementation doesn't need the argv[0] value.  NULL
 *	may be passed in its place.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The variable tclExecutableName gets filled in with the file
 *	name for the application, if we figured it out.  If we couldn't
 *	figure it out, Tcl_FindExecutable is set to NULL.
 *
 *----------------------------------------------------------------------
 */

char *
TclpFindExecutable(
    CONST char *argv0)		/* The value of the application's argv[0]. */
{
    ProcessSerialNumber psn;
    ProcessInfoRec info;
    Str63 appName;
    FSSpec fileSpec;
    int pathLength;
    Handle pathName = NULL;
    OSErr err;
    Tcl_DString ds;
    
    TclInitSubsystems(argv0);
    
    GetCurrentProcess(&psn);
    info.processInfoLength = sizeof(ProcessInfoRec);
    info.processName = appName;
    info.processAppSpec = &fileSpec;
    GetProcessInformation(&psn, &info);

    if (tclExecutableName != NULL) {
	ckfree(tclExecutableName);
	tclExecutableName = NULL;
    }
    
    err = FSpPathFromLocation(&fileSpec, &pathLength, &pathName);
    HLock(pathName);
    Tcl_ExternalToUtfDString(NULL, *pathName, pathLength, &ds);
    HUnlock(pathName);
    DisposeHandle(pathName);	

    tclExecutableName = (char *) ckalloc((unsigned) 
    	    (Tcl_DStringLength(&ds) + 1));
    strcpy(tclExecutableName, Tcl_DStringValue(&ds));
    Tcl_DStringFree(&ds);
    return tclExecutableName;
}

/*
 *----------------------------------------------------------------------
 *
 * TclpMatchInDirectory --
 *
 *	This routine is used by the globbing code to search a
 *	directory for all files which match a given pattern.
 *
 * Results: 
 *	
 *	The return value is a standard Tcl result indicating whether an
 *	error occurred in globbing.  Errors are left in interp, good
 *	results are lappended to resultPtr (which must be a valid object)
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------- */

int
TclpMatchInDirectory(interp, resultPtr, pathPtr, pattern, types)
    Tcl_Interp *interp;		/* Interpreter to receive errors. */
    Tcl_Obj *resultPtr;		/* List object to lappend results. */
    Tcl_Obj *pathPtr;	        /* Contains path to directory to search. */
    CONST char *pattern;	/* Pattern to match against.  NULL or empty
                        	 * means pathPtr is actually a single file
                        	 * to check. */
    Tcl_GlobTypeData *types;	/* Object containing list of acceptable types.
				 * May be NULL. In particular the directory
				 * flag is very important. */
{
    OSType okType = 0;
    OSType okCreator = 0;
    Tcl_Obj *fileNamePtr;

    fileNamePtr = Tcl_FSGetTranslatedPath(interp, pathPtr);
    if (fileNamePtr == NULL) {
	return TCL_ERROR;
    }
    
    if (types != NULL) {
	if (types->macType != NULL) {
	    Tcl_GetOSTypeFromObj(NULL, types->macType, &okType);
	}
	if (types->macCreator != NULL) {
	    Tcl_GetOSTypeFromObj(NULL, types->macCreator, &okCreator);
	}
    }

    if (pattern == NULL || (*pattern == '\0')) {
	/* Match a single file directly */
	Tcl_StatBuf buf;
	CInfoPBRec paramBlock;
	FSSpec fileSpec;
	
	if (TclpObjLstat(fileNamePtr, &buf) != 0) {
	    /* File doesn't exist */
	    return TCL_OK;
	}

	if (FspLLocationFromFsPath(fileNamePtr, &fileSpec) == noErr) {
	    paramBlock.hFileInfo.ioCompletion = NULL;
	    paramBlock.hFileInfo.ioNamePtr = fileSpec.name;
	    paramBlock.hFileInfo.ioVRefNum = fileSpec.vRefNum;
	    paramBlock.hFileInfo.ioFDirIndex = 0;
	    paramBlock.hFileInfo.ioDirID = fileSpec.parID;
	    
	    PBGetCatInfo(&paramBlock, 0);
	}

	if (NativeMatchType(fileNamePtr, types, paramBlock.hFileInfo,
			    okType, okCreator)) {
	    int fnameLen;
	    char *fname = Tcl_GetStringFromObj(pathPtr,&fnameLen);
	    if ((fnameLen > 1) && (strchr(fname+1, ':') == NULL)) {
		Tcl_ListObjAppendElement(interp, resultPtr, 
			Tcl_NewStringObj(fname+1, fnameLen-1));
	    } else {
		Tcl_ListObjAppendElement(interp, resultPtr, pathPtr);
	    }
	}
	return TCL_OK;
    } else {
	char *fname;
	int fnameLen, result = TCL_OK;
	int baseLength;
	CInfoPBRec pb;
	OSErr err;
	FSSpec dirSpec;
	Boolean isDirectory;
	long dirID;
	short itemIndex;
	Str255 fileName;
	Tcl_DString fileString;    
	Tcl_DString dsOrig;

	Tcl_DStringInit(&dsOrig);
	Tcl_DStringAppend(&dsOrig, Tcl_GetString(fileNamePtr), -1);
	baseLength = Tcl_DStringLength(&dsOrig);

	/*
	 * Make sure that the directory part of the name really is a
	 * directory.
	 */

	Tcl_UtfToExternalDString(NULL, Tcl_DStringValue(&dsOrig),
		Tcl_DStringLength(&dsOrig), &fileString);

	err = FSpLocationFromPath(Tcl_DStringLength(&fileString), 
				  Tcl_DStringValue(&fileString), &dirSpec);
	Tcl_DStringFree(&fileString);
	if (err == noErr) {
	    err = FSpGetDirectoryID(&dirSpec, &dirID, &isDirectory);
	}
	
	if ((err != noErr) || !isDirectory) {
	    /*
	     * Check if we had a relative path (unix style relative path 
	     * compatibility for glob)
	     */
	    Tcl_DStringFree(&dsOrig);
	    Tcl_DStringAppend(&dsOrig, ":", 1);
	    Tcl_DStringAppend(&dsOrig, Tcl_GetString(fileNamePtr), -1);
	    baseLength = Tcl_DStringLength(&dsOrig);

	    Tcl_UtfToExternalDString(NULL, Tcl_DStringValue(&dsOrig),
		    Tcl_DStringLength(&dsOrig), &fileString);
	    
	    err = FSpLocationFromPath(Tcl_DStringLength(&fileString), 
				      Tcl_DStringValue(&fileString), &dirSpec);
	    Tcl_DStringFree(&fileString);
	    if (err == noErr) {
		err = FSpGetDirectoryID(&dirSpec, &dirID, &isDirectory);
	    }
	    
	    if ((err != noErr) || !isDirectory) {
		Tcl_DStringFree(&dsOrig);
		return TCL_OK;
	    }
	}

	/* Make sure we have a trailing directory delimiter */
	if (Tcl_DStringValue(&dsOrig)[baseLength-1] != ':') {
	    Tcl_DStringAppend(&dsOrig, ":", 1);
	    baseLength++;
	}
	
	/*
	 * Now open the directory for reading and iterate over the contents.
	 */

	pb.hFileInfo.ioVRefNum = dirSpec.vRefNum;
	pb.hFileInfo.ioDirID = dirID;
	pb.hFileInfo.ioNamePtr = (StringPtr) fileName;
	pb.hFileInfo.ioFDirIndex = itemIndex = 1;

	while (1) {
	    pb.hFileInfo.ioFDirIndex = itemIndex;
	    pb.hFileInfo.ioDirID = dirID;
	    err = PBGetCatInfoSync(&pb);
	    if (err != noErr) {
		break;
	    }

	    /*
	     * Now check to see if the file matches.  
	     */
	     
	    Tcl_ExternalToUtfDString(NULL, (char *) fileName + 1, fileName[0],
		    &fileString);
	    if (Tcl_StringMatch(Tcl_DStringValue(&fileString), pattern)) {
		Tcl_Obj *tempName;
		Tcl_DStringSetLength(&dsOrig, baseLength);
		Tcl_DStringAppend(&dsOrig, Tcl_DStringValue(&fileString), -1);
		fname = Tcl_DStringValue(&dsOrig);
		fnameLen = Tcl_DStringLength(&dsOrig);
		
		/* 
		 * We use this tempName in calls to check the file's
		 * type below.  We may also use it for the result.
		 */
		tempName = Tcl_NewStringObj(fname, fnameLen);
		Tcl_IncrRefCount(tempName);

		/* Is the type acceptable? */
		if (NativeMatchType(tempName, types, pb.hFileInfo,
				    okType, okCreator)) {
		    if ((fnameLen > 1) && (strchr(fname+1, ':') == NULL)) {
			Tcl_ListObjAppendElement(interp, resultPtr, 
				Tcl_NewStringObj(fname+1, fnameLen-1));
		    } else {
			Tcl_ListObjAppendElement(interp, resultPtr, tempName);
		    }
		}
		/* 
		 * This will free the object, unless it was inserted in
		 * the result list above.
		 */
		Tcl_DecrRefCount(tempName);
	    }
	    Tcl_DStringFree(&fileString);
	    itemIndex++;
	}

	Tcl_DStringFree(&dsOrig);
	return result;
    }
}

static int 
NativeMatchType(
    Tcl_Obj *tempName,        /* Path to check */
    Tcl_GlobTypeData *types,  /* Type description to match against */
    HFileInfo fileInfo,       /* MacOS file info */
    OSType okType,            /* Acceptable MacOS type, or zero */
    OSType okCreator)         /* Acceptable MacOS creator, or zero */
{
    if (types == NULL) {
	/* If invisible, don't return the file */
	if (fileInfo.ioFlFndrInfo.fdFlags & kIsInvisible) {
	    return 0;
	}
    } else {
	Tcl_StatBuf buf;
	
	if (fileInfo.ioFlFndrInfo.fdFlags & kIsInvisible) {
	    /* If invisible */
	    if ((types->perm == 0) || 
	      !(types->perm & TCL_GLOB_PERM_HIDDEN)) {
		return 0;
	    }
	} else {
	    /* Visible */
	    if (types->perm & TCL_GLOB_PERM_HIDDEN) {
		return 0;
	    }
	}
	if (types->perm != 0) {
	    if (
		((types->perm & TCL_GLOB_PERM_RONLY) &&
			!(fileInfo.ioFlAttrib & 1)) ||
		((types->perm & TCL_GLOB_PERM_R) &&
			(TclpObjAccess(tempName, R_OK) != 0)) ||
		((types->perm & TCL_GLOB_PERM_W) &&
			(TclpObjAccess(tempName, W_OK) != 0)) ||
		((types->perm & TCL_GLOB_PERM_X) &&
			(TclpObjAccess(tempName, X_OK) != 0))
		) {
		return 0;
	    }
	}
	if (types->type != 0) {
	    if (TclpObjStat(tempName, &buf) != 0) {
		/* Posix error occurred */
		return 0;
	    }
	    /*
	     * In order bcdpfls as in 'find -t'
	     */
	    if (
		((types->type & TCL_GLOB_TYPE_BLOCK) &&
			S_ISBLK(buf.st_mode)) ||
		((types->type & TCL_GLOB_TYPE_CHAR) &&
			S_ISCHR(buf.st_mode)) ||
		((types->type & TCL_GLOB_TYPE_DIR) &&
			S_ISDIR(buf.st_mode)) ||
		((types->type & TCL_GLOB_TYPE_PIPE) &&
			S_ISFIFO(buf.st_mode)) ||
		((types->type & TCL_GLOB_TYPE_FILE) &&
			S_ISREG(buf.st_mode))
#ifdef S_ISSOCK
		|| ((types->type & TCL_GLOB_TYPE_SOCK) &&
			S_ISSOCK(buf.st_mode))
#endif
		) {
		/* Do nothing -- this file is ok */
	    } else {
		int typeOk = 0;
#ifdef S_ISLNK
		if (types->type & TCL_GLOB_TYPE_LINK) {
		    if (TclpObjLstat(tempName, &buf) == 0) {
			if (S_ISLNK(buf.st_mode)) {
			    typeOk = 1;
			}
		    }
		}
#endif
		if (typeOk == 0) {
		    return 0;
		}
	    }
	}
	if (((okType != 0) && (okType !=
			       fileInfo.ioFlFndrInfo.fdType)) ||
	    ((okCreator != 0) && (okCreator !=
				  fileInfo.ioFlFndrInfo.fdCreator))) {
	    return 0;
	}
    }
    return 1;
}


/*
 *----------------------------------------------------------------------
 *
 * TclpObjAccess --
 *
 *	This function replaces the library version of access().
 *
 * Results:
 *	See access documentation.
 *
 * Side effects:
 *	See access documentation.
 *
 *----------------------------------------------------------------------
 */

int 
TclpObjAccess(pathPtr, mode)
    Tcl_Obj *pathPtr;
    int mode;
{
    HFileInfo fpb;
    HVolumeParam vpb;
    OSErr err;
    FSSpec fileSpec;
    Boolean isDirectory;
    long dirID;
    int full_mode = 0;

    err = FspLLocationFromFsPath(pathPtr, &fileSpec);

    if (err != noErr) {
	errno = TclMacOSErrorToPosixError(err);
	return -1;
    }
    
    /*
     * Fill the fpb & vpb struct up with info about file or directory.
     */
    FSpGetDirectoryID(&fileSpec, &dirID, &isDirectory);
    vpb.ioVRefNum = fpb.ioVRefNum = fileSpec.vRefNum;
    vpb.ioNamePtr = fpb.ioNamePtr = fileSpec.name;
    if (isDirectory) {
	fpb.ioDirID = fileSpec.parID;
    } else {
	fpb.ioDirID = dirID;
    }

    fpb.ioFDirIndex = 0;
    err = PBGetCatInfoSync((CInfoPBPtr)&fpb);
    if (err == noErr) {
	vpb.ioVolIndex = 0;
	err = PBHGetVInfoSync((HParmBlkPtr)&vpb);
	if (err == noErr) {
	    /* 
	     * Use the Volume Info & File Info to determine
	     * access information.  If we have got this far
	     * we know the directory is searchable or the file
	     * exists.  (We have F_OK)
	     */

	    /*
	     * Check to see if the volume is hardware or
	     * software locked.  If so we arn't W_OK.
	     */
	    if (mode & W_OK) {
		if ((vpb.ioVAtrb & 0x0080) || (vpb.ioVAtrb & 0x8000)) {
		    errno = EROFS;
		    return -1;
		}
		if (fpb.ioFlAttrib & 0x01) {
		    errno = EACCES;
		    return -1;
		}
	    }
	    
	    /*
	     * Directories are always searchable and executable.  But only 
	     * files of type 'APPL' are executable.
	     */
	    if (!(fpb.ioFlAttrib & 0x10) && (mode & X_OK)
		&& (fpb.ioFlFndrInfo.fdType != 'APPL')) {
		return -1;
	    }
	}
    }

    if (err != noErr) {
	errno = TclMacOSErrorToPosixError(err);
	return -1;
    }
    
    return 0;
}

/*
 *----------------------------------------------------------------------
 *
 * TclpObjChdir --
 *
 *	This function replaces the library version of chdir().
 *
 * Results:
 *	See chdir() documentation.
 *
 * Side effects:
 *	See chdir() documentation.  Also the cache maintained used by 
 *	Tcl_FSGetCwd() is deallocated and set to NULL.
 *
 *----------------------------------------------------------------------
 */

int 
TclpObjChdir(pathPtr)
    Tcl_Obj *pathPtr;
{
    FSSpec spec;
    OSErr err;
    Boolean isFolder;
    long dirID;

    err = FspLocationFromFsPath(pathPtr, &spec);

    if (err != noErr) {
	errno = ENOENT;
	return -1;
    }
    
    err = FSpGetDirectoryID(&spec, &dirID, &isFolder);
    if (err != noErr) {
	errno = ENOENT;
	return -1;
    }

    if (isFolder != true) {
	errno = ENOTDIR;
	return -1;
    }

    err = FSpSetDefaultDir(&spec);
    if (err != noErr) {
	switch (err) {
	    case afpAccessDenied:
		errno = EACCES;
		break;
	    default:
		errno = ENOENT;
	}
	return -1;
    }

    return 0;
}

/*
 *----------------------------------------------------------------------
 *
 * TclpObjGetCwd --
 *
 *	This function replaces the library version of getcwd().
 *
 * Results:
 *	The result is a pointer to a string specifying the current
 *	directory, or NULL if the current directory could not be
 *	determined.  If NULL is returned, an error message is left in the
 *	interp's result.  Storage for the result string is allocated in
 *	bufferPtr; the caller must call Tcl_DStringFree() when the result
 *	is no longer needed.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_Obj* 
TclpObjGetCwd(interp)
    Tcl_Interp *interp;
{
    Tcl_DString ds;
    if (TclpGetCwd(interp, &ds) != NULL) {
	Tcl_Obj *cwdPtr = Tcl_NewStringObj(Tcl_DStringValue(&ds), -1);
	Tcl_IncrRefCount(cwdPtr);
	Tcl_DStringFree(&ds);
	return cwdPtr;
    } else {
	return NULL;
    }
}

CONST char *
TclpGetCwd(
    Tcl_Interp *interp,		/* If non-NULL, used for error reporting. */
    Tcl_DString *bufferPtr)	/* Uninitialized or free DString filled
				 * with name of current directory. */
{
    FSSpec theSpec;
    int length;
    Handle pathHandle = NULL;
    
    if (FSpGetDefaultDir(&theSpec) != noErr) {
 	if (interp != NULL) {
	    Tcl_SetResult(interp, "error getting working directory name",
		    TCL_STATIC);
	}
	return NULL;
    }
    if (FSpPathFromLocation(&theSpec, &length, &pathHandle) != noErr) {
 	if (interp != NULL) {
	     Tcl_SetResult(interp, "error getting working directory name",
		    TCL_STATIC);
	}
	return NULL;
    }
    HLock(pathHandle);
    Tcl_ExternalToUtfDString(NULL, *pathHandle, length, bufferPtr);
    HUnlock(pathHandle);
    DisposeHandle(pathHandle);	

    return Tcl_DStringValue(bufferPtr);
}

/*
 *----------------------------------------------------------------------
 *
 * TclpReadlink --
 *
 *	This function replaces the library version of readlink().
 *
 * Results:
 *	The result is a pointer to a string specifying the contents
 *	of the symbolic link given by 'path', or NULL if the symbolic
 *	link could not be read.  Storage for the result string is
 *	allocated in bufferPtr; the caller must call Tcl_DStringFree()
 *	when the result is no longer needed.
 *
 * Side effects:
 *	See readlink() documentation.
 *
 *---------------------------------------------------------------------------
 */

char *
TclpReadlink(
    CONST char *path,		/* Path of file to readlink (UTF-8). */
    Tcl_DString *linkPtr)	/* Uninitialized or free DString filled
				 * with contents of link (UTF-8). */
{
    HFileInfo fpb;
    OSErr err;
    FSSpec fileSpec;
    Boolean isDirectory;
    Boolean wasAlias;
    long dirID;
    char fileName[257];
    char *end;
    Handle theString = NULL;
    int pathSize;
    Tcl_DString ds;
    
    Tcl_UtfToExternalDString(NULL, path, -1, &ds);

    /*
     * Remove ending colons if they exist.
     */
     
    while ((Tcl_DStringLength(&ds) != 0) 
	   && (Tcl_DStringValue(&ds)[Tcl_DStringLength(&ds) - 1] == ':')) {
	Tcl_DStringSetLength(&ds, Tcl_DStringLength(&ds) - 1);
    }

    end = strrchr(Tcl_DStringValue(&ds), ':');
    if (end == NULL ) {
	strcpy(fileName + 1, Tcl_DStringValue(&ds));
    } else {
	strcpy(fileName + 1, end + 1);
	Tcl_DStringSetLength(&ds, end + 1 - Tcl_DStringValue(&ds));
    }
    fileName[0] = (char) strlen(fileName + 1);
    
    /*
     * Create the file spec for the directory of the file
     * we want to look at.
     */

    if (end != NULL) {
	err = FSpLocationFromPath(Tcl_DStringLength(&ds), 
				  Tcl_DStringValue(&ds), &fileSpec);
	if (err != noErr) {
	    Tcl_DStringFree(&ds);
	    errno = EINVAL;
	    return NULL;
	}
    } else {
	FSMakeFSSpecCompat(0, 0, NULL, &fileSpec);
    }
    Tcl_DStringFree(&ds);
    
    /*
     * Fill the fpb struct up with info about file or directory.
     */

    FSpGetDirectoryID(&fileSpec, &dirID, &isDirectory);
    fpb.ioVRefNum = fileSpec.vRefNum;
    fpb.ioDirID = dirID;
    fpb.ioNamePtr = (StringPtr) fileName;

    fpb.ioFDirIndex = 0;
    err = PBGetCatInfoSync((CInfoPBPtr)&fpb);
    if (err != noErr) {
	errno = TclMacOSErrorToPosixError(err);
	return NULL;
    } else {
	if (fpb.ioFlAttrib & 0x10) {
	    errno = EINVAL;
	    return NULL;
	} else {
	    if (fpb.ioFlFndrInfo.fdFlags & 0x8000) {
		/*
		 * The file is a link!
		 */
	    } else {
		errno = EINVAL;
		return NULL;
	    }
	}
    }
    
    /*
     * If we are here it's really a link - now find out
     * where it points to.
     */
    err = FSMakeFSSpecCompat(fileSpec.vRefNum, dirID, (StringPtr) fileName, 
    	    &fileSpec);
    if (err == noErr) {
	err = ResolveAliasFile(&fileSpec, true, &isDirectory, &wasAlias);
    }
    if ((err == fnfErr) || wasAlias) {
	err = FSpPathFromLocation(&fileSpec, &pathSize, &theString);
	if (err != noErr) {
	    DisposeHandle(theString);
	    errno = ENAMETOOLONG;
	    return NULL;
	}
    } else {
    	errno = EINVAL;
	return NULL;
    }
    
    Tcl_ExternalToUtfDString(NULL, *theString, pathSize, linkPtr);
    DisposeHandle(theString);
    
    return Tcl_DStringValue(linkPtr);
}

static int 
TclpObjStatAlias _ANSI_ARGS_((Tcl_Obj *pathPtr, Tcl_StatBuf *bufPtr, 
			      Boolean resolveLink));


/*
 *----------------------------------------------------------------------
 *
 * TclpObjLstat --
 *
 *	This function replaces the library version of lstat().
 *
 * Results:
 *	See lstat() documentation.
 *
 * Side effects:
 *	See lstat() documentation.
 *
 *----------------------------------------------------------------------
 */

int 
TclpObjLstat(pathPtr, buf)
    Tcl_Obj *pathPtr;
    Tcl_StatBuf *buf;
{
    return TclpObjStatAlias(pathPtr, buf, FALSE);
}

/*
 *----------------------------------------------------------------------
 *
 * TclpObjStat --
 *
 *	This function replaces the library version of stat().
 *
 * Results:
 *	See stat() documentation.
 *
 * Side effects:
 *	See stat() documentation.
 *
 *----------------------------------------------------------------------
 */

int 
TclpObjStat(pathPtr, bufPtr)
    Tcl_Obj *pathPtr;
    Tcl_StatBuf *bufPtr;
{
    return TclpObjStatAlias(pathPtr, bufPtr, TRUE);
}


static int
TclpObjStatAlias (Tcl_Obj *pathPtr, Tcl_StatBuf *bufPtr, Boolean resolveLink)
{
    HFileInfo fpb;
    HVolumeParam vpb;
    OSErr err;
    FSSpec fileSpec;
    Boolean isDirectory;
    long dirID;
    
    if (resolveLink)
    	err = FspLocationFromFsPath(pathPtr, &fileSpec);
    else
    	err = FspLLocationFromFsPath(pathPtr, &fileSpec);
    
    if (err != noErr) {
	errno = TclMacOSErrorToPosixError(err);
	return -1;
    }
    
    /*
     * Fill the fpb & vpb struct up with info about file or directory.
     */
     
    FSpGetDirectoryID(&fileSpec, &dirID, &isDirectory);
    vpb.ioVRefNum = fpb.ioVRefNum = fileSpec.vRefNum;
    vpb.ioNamePtr = fpb.ioNamePtr = fileSpec.name;
    if (isDirectory) {
	fpb.ioDirID = fileSpec.parID;
    } else {
	fpb.ioDirID = dirID;
    }

    fpb.ioFDirIndex = 0;
    err = PBGetCatInfoSync((CInfoPBPtr)&fpb);
    if (err == noErr) {
	vpb.ioVolIndex = 0;
	err = PBHGetVInfoSync((HParmBlkPtr)&vpb);
	if (err == noErr && bufPtr != NULL) {
	    /* 
	     * Files are always readable by everyone.
	     */
	     
	    bufPtr->st_mode = S_IRUSR | S_IRGRP | S_IROTH;

	    /* 
	     * Use the Volume Info & File Info to fill out stat buf.
	     */
	    if (fpb.ioFlAttrib & 0x10) {
		bufPtr->st_mode |= S_IFDIR;
		bufPtr->st_nlink = 2;
	    } else {
		bufPtr->st_nlink = 1;
		if (fpb.ioFlFndrInfo.fdFlags & 0x8000) {
		    bufPtr->st_mode |= S_IFLNK;
		} else {
		    bufPtr->st_mode |= S_IFREG;
		}
	    }
	    if ((fpb.ioFlAttrib & 0x10) || (fpb.ioFlFndrInfo.fdType == 'APPL')) {
		/*
		 * Directories and applications are executable by everyone.
		 */
		 
		bufPtr->st_mode |= S_IXUSR | S_IXGRP | S_IXOTH;
	    }
	    if ((fpb.ioFlAttrib & 0x01) == 0){
		/* 
		 * If not locked, then everyone has write acces.
		 */
		 
		bufPtr->st_mode |= S_IWUSR | S_IWGRP | S_IWOTH;
	    }
	    bufPtr->st_ino = fpb.ioDirID;
	    bufPtr->st_dev = fpb.ioVRefNum;
	    bufPtr->st_uid = -1;
	    bufPtr->st_gid = -1;
	    bufPtr->st_rdev = 0;
	    bufPtr->st_size = fpb.ioFlLgLen;
	    bufPtr->st_blksize = vpb.ioVAlBlkSiz;
	    bufPtr->st_blocks = (bufPtr->st_size + bufPtr->st_blksize - 1)
		/ bufPtr->st_blksize;

	    /*
	     * The times returned by the Mac file system are in the
	     * local time zone.  We convert them to GMT so that the
	     * epoch starts from GMT.  This is also consistent with
	     * what is returned from "clock seconds".
	     */

	    bufPtr->st_atime = bufPtr->st_mtime = fpb.ioFlMdDat 
	      - TclpGetGMTOffset() + tcl_mac_epoch_offset;
	    bufPtr->st_ctime = fpb.ioFlCrDat - TclpGetGMTOffset() 
	      + tcl_mac_epoch_offset;
	}
    }

    if (err != noErr) {
	errno = TclMacOSErrorToPosixError(err);
    }
    
    return (err == noErr ? 0 : -1);
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_WaitPid --
 *
 *	Fakes a call to wait pid.
 *
 * Results:
 *	Always returns -1.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_Pid
Tcl_WaitPid(
    Tcl_Pid pid,
    int *statPtr,
    int options)
{
    return (Tcl_Pid) -1;
}

/*
 *----------------------------------------------------------------------
 *
 * TclMacFOpenHack --
 *
 *	This function replaces fopen.  It supports paths with alises.
 *	Note, remember to undefine the fopen macro!
 *
 * Results:
 *	See fopen documentation.
 *
 * Side effects:
 *	See fopen documentation.
 *
 *----------------------------------------------------------------------
 */

#undef fopen
FILE *
TclMacFOpenHack(
    CONST char *path,
    CONST char *mode)
{
    OSErr err;
    FSSpec fileSpec;
    Handle pathString = NULL;
    int size;
    FILE * f;
    
    err = FSpLocationFromPath(strlen(path), path, &fileSpec);
    if ((err != noErr) && (err != fnfErr)) {
	return NULL;
    }
    err = FSpPathFromLocation(&fileSpec, &size, &pathString);
    if ((err != noErr) && (err != fnfErr)) {
	return NULL;
    }
    
    HLock(pathString);
    f = fopen(*pathString, mode);
    HUnlock(pathString);
    DisposeHandle(pathString);
    return f;
}

/*
 *---------------------------------------------------------------------------
 *
 * TclpGetUserHome --
 *
 *	This function takes the specified user name and finds their
 *	home directory.
 *
 * Results:
 *	The result is a pointer to a string specifying the user's home
 *	directory, or NULL if the user's home directory could not be
 *	determined.  Storage for the result string is allocated in
 *	bufferPtr; the caller must call Tcl_DStringFree() when the result
 *	is no longer needed.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

char *
TclpGetUserHome(name, bufferPtr)
    CONST char *name;		/* User name for desired home directory. */
    Tcl_DString *bufferPtr;	/* Uninitialized or free DString filled
				 * with name of user's home directory. */
{
    return NULL;
}

/*
 *----------------------------------------------------------------------
 *
 * TclMacOSErrorToPosixError --
 *
 *	Given a Macintosh OSErr return the appropiate POSIX error.
 *
 * Results:
 *	A Posix error.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
TclMacOSErrorToPosixError(
    int error)	/* A Macintosh error. */
{
    switch (error) {
	case noErr:
	    return 0;
	case bdNamErr:
	    return ENAMETOOLONG;
	case afpObjectTypeErr:
	    return ENOTDIR;
	case fnfErr:
	case dirNFErr:
	    return ENOENT;
	case dupFNErr:
	    return EEXIST;
	case dirFulErr:
	case dskFulErr:
	    return ENOSPC;
	case fBsyErr:
	    return EBUSY;
	case tmfoErr:
	    return ENFILE;
	case fLckdErr:
	case permErr:
	case afpAccessDenied:
	    return EACCES;
	case wPrErr:
	case vLckdErr:
	    return EROFS;
	case badMovErr:
	    return EINVAL;
	case diffVolErr:
	    return EXDEV;
	default:
	    return EINVAL;
    }
}

int
TclMacChmod(
    CONST char *path, 
    int mode)
{
    HParamBlockRec hpb;
    OSErr err;
    Str255 pathName;
    strcpy((char *) pathName + 1, path);
    pathName[0] = strlen(path);
    hpb.fileParam.ioNamePtr = pathName;
    hpb.fileParam.ioVRefNum = 0;
    hpb.fileParam.ioDirID = 0;
    
    if (mode & 0200) {
        err = PBHRstFLockSync(&hpb);
    } else {
        err = PBHSetFLockSync(&hpb);
    }
    
    if (err != noErr) {
        errno = TclMacOSErrorToPosixError(err);
        return -1;
    }
    
    return 0;
}


/*
 *----------------------------------------------------------------------
 *
 * TclpTempFileName --
 *
 *	This function returns a unique filename.
 *
 * Results:
 *	Returns a valid Tcl_Obj* with refCount 0, or NULL on failure.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_Obj* 
TclpTempFileName()
{
    char fileName[L_tmpnam];
    
    if (tmpnam(fileName) == NULL) {	       /* INTL: Native. */
	return NULL;
    }

    return TclpNativeToNormalized((ClientData) fileName);
}

#ifdef S_IFLNK

Tcl_Obj* 
TclpObjLink(pathPtr, toPtr, linkAction)
    Tcl_Obj *pathPtr;
    Tcl_Obj *toPtr;
    int linkAction;
{
    Tcl_Obj* link = NULL;

    if (toPtr != NULL) {
	if (TclpObjAccess(pathPtr, F_OK) != -1) {
	    /* src exists */
	    errno = EEXIST;
	    return NULL;
	}
	if (TclpObjAccess(toPtr, F_OK) == -1) {
	    /* target doesn't exist */
	    errno = ENOENT;
	    return NULL;
	}

	if (linkAction & TCL_CREATE_SYMBOLIC_LINK) {
	    /* Needs to create a new link */
	    FSSpec spec;
	    FSSpec linkSpec;
	    OSErr err;
	    CONST char *path;
	    AliasHandle alias;
	    
	    err = FspLocationFromFsPath(toPtr, &spec);
	    if (err != noErr) {
		errno = ENOENT;
		return NULL;
	    }

	    path = Tcl_FSGetNativePath(pathPtr);
	    err = FSpLocationFromPath(strlen(path), path, &linkSpec);
	    if (err == noErr) {
		err = dupFNErr;		/* EEXIST. */
	    } else {
		err = NewAlias(&spec, &linkSpec, &alias);
	    }
	    if (err != noErr) {
		errno = TclMacOSErrorToPosixError(err);
		return NULL;
	    }
	    return toPtr;
	} else {
	    errno = ENODEV;
	    return NULL;
	}
    } else {
	Tcl_DString ds;
	Tcl_Obj *transPtr = Tcl_FSGetTranslatedPath(NULL, pathPtr);
	if (transPtr == NULL) {
	    return NULL;
	}
	if (TclpReadlink(Tcl_GetString(transPtr), &ds) != NULL) {
	    link = Tcl_NewStringObj(Tcl_DStringValue(&ds), -1);
	    Tcl_IncrRefCount(link);
	    Tcl_DStringFree(&ds);
	}
    }
    return link;
}

#endif


/*
 *---------------------------------------------------------------------------
 *
 * TclpFilesystemPathType --
 *
 *      This function is part of the native filesystem support, and
 *      returns the path type of the given path.  Right now it simply
 *      returns NULL.  In the future it could return specific path
 *      types, like 'HFS', 'HFS+', 'nfs', 'samba', 'FAT32', etc.
 *
 * Results:
 *      NULL at present.
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
 */
Tcl_Obj*
TclpFilesystemPathType(pathObjPtr)
    Tcl_Obj* pathObjPtr;
{
    /* All native paths are of the same type */
    return NULL;
}
@


1.4
log
@touched all sources to ease next import
@
text
@d13 1
a13 1
 * RCS: @@(#) $Id: tclMacFile.c,v 1.6.8.1 2000/04/06 22:38:30 spolk Exp $
d34 24
a57 6
/*
 * Static variables used by the TclpStat function.
 */
static int initialized = false;
static long gmt_offset;
TCL_DECLARE_MUTEX(gmtMutex)
d123 1
a123 1
 * TclpMatchFilesTypes --
d129 4
a132 5
 *	If the tail argument is NULL, then the matching files are
 *	added to the the interp's result.  Otherwise, TclDoGlob is called
 *	recursively for each matching subdirectory.  The return value
 *	is a standard Tcl result indicating whether an error occurred
 *	in globbing.
d140 11
a150 24
TclpMatchFilesTypes(
    Tcl_Interp *interp,		/* Interpreter to receive results. */
    char *separators,		/* Directory separators to pass to TclDoGlob. */
    Tcl_DString *dirPtr,	/* Contains path to directory to search. */
    char *pattern,		/* Pattern to match against. */
    char *tail,			/* Pointer to end of pattern.  Tail must
				 * point to a location in pattern and must
				 * not be static.*/
    GlobTypeData *types)	/* Object containing list of acceptable types.
				 * May be NULL. */
{
    char *fname, *patternEnd = tail;
    char savedChar;
    int fnameLen, result = TCL_OK;
    int baseLength = Tcl_DStringLength(dirPtr);
    CInfoPBRec pb;
    OSErr err;
    FSSpec dirSpec;
    Boolean isDirectory;
    long dirID;
    short itemIndex;
    Str255 fileName;
    Tcl_DString fileString;    
    Tcl_Obj *resultPtr;
d153 1
d155 3
a157 14
    /*
     * Make sure that the directory part of the name really is a
     * directory.
     */

    Tcl_UtfToExternalDString(NULL, Tcl_DStringValue(dirPtr),
	    Tcl_DStringLength(dirPtr), &fileString);

    FSpLocationFromPath(fileString.length, fileString.string, &dirSpec);
    Tcl_DStringFree(&fileString);

    err = FSpGetDirectoryID(&dirSpec, &dirID, &isDirectory);
    if ((err != noErr) || !isDirectory) {
	return TCL_OK;
d159 1
a159 29

    /*
     * Now open the directory for reading and iterate over the contents.
     */

    pb.hFileInfo.ioVRefNum = dirSpec.vRefNum;
    pb.hFileInfo.ioDirID = dirID;
    pb.hFileInfo.ioNamePtr = (StringPtr) fileName;
    pb.hFileInfo.ioFDirIndex = itemIndex = 1;

    /*
     * Clean up the end of the pattern and the tail pointer.  Leave
     * the tail pointing to the first character after the path separator
     * following the pattern, or NULL.  Also, ensure that the pattern
     * is null-terminated.
     */

    if (*tail == '\\') {
	tail++;
    }
    if (*tail == '\0') {
	tail = NULL;
    } else {
	tail++;
    }
    savedChar = *patternEnd;
    *patternEnd = '\0';

    resultPtr = Tcl_GetObjResult(interp);
d169 90
a258 6
    while (1) {
	pb.hFileInfo.ioFDirIndex = itemIndex;
	pb.hFileInfo.ioDirID = dirID;
	err = PBGetCatInfoSync(&pb);
	if (err != noErr) {
	    break;
d261 6
d268 1
a268 4
	 * Now check to see if the file matches.  If there are more
	 * characters to be processed, then ensure matching files are
	 * directories before calling TclDoGlob. Otherwise, just add
	 * the file to the result.
d270 37
a306 73
	 
	Tcl_ExternalToUtfDString(NULL, (char *) fileName + 1, fileName[0],
		&fileString);
	if (Tcl_StringMatch(Tcl_DStringValue(&fileString), pattern)) {
	    Tcl_DStringSetLength(dirPtr, baseLength);
	    Tcl_DStringAppend(dirPtr, Tcl_DStringValue(&fileString), -1);
	    fname = Tcl_DStringValue(dirPtr);
	    fnameLen = Tcl_DStringLength(dirPtr);
	    if (tail == NULL) {
		int typeOk = 1;
		if (types != NULL) {
		    if (types->perm != 0) {
			if (
			    ((types->perm & TCL_GLOB_PERM_RONLY) &&
				    !(pb.hFileInfo.ioFlAttrib & 1)) ||
			    ((types->perm & TCL_GLOB_PERM_HIDDEN) &&
				    !(pb.hFileInfo.ioFlFndrInfo.fdFlags &
					    kIsInvisible)) ||
			    ((types->perm & TCL_GLOB_PERM_R) &&
				    (TclpAccess(fname, R_OK) != 0)) ||
			    ((types->perm & TCL_GLOB_PERM_W) &&
				    (TclpAccess(fname, W_OK) != 0)) ||
			    ((types->perm & TCL_GLOB_PERM_X) &&
				    (TclpAccess(fname, X_OK) != 0))
			    ) {
			    typeOk = 0;
			}
		    }
		    if (typeOk == 1 && types->type != 0) {
			struct stat buf;
			/*
			 * We must match at least one flag to be listed
			 */
			typeOk = 0;
			if (TclpLstat(fname, &buf) >= 0) {
			    /*
			     * In order bcdpfls as in 'find -t'
			     */
			    if (
				((types->type & TCL_GLOB_TYPE_BLOCK) &&
					S_ISBLK(buf.st_mode)) ||
				((types->type & TCL_GLOB_TYPE_CHAR) &&
					S_ISCHR(buf.st_mode)) ||
				((types->type & TCL_GLOB_TYPE_DIR) &&
					S_ISDIR(buf.st_mode)) ||
				((types->type & TCL_GLOB_TYPE_PIPE) &&
					S_ISFIFO(buf.st_mode)) ||
				((types->type & TCL_GLOB_TYPE_FILE) &&
					S_ISREG(buf.st_mode))
#ifdef S_ISLNK
				|| ((types->type & TCL_GLOB_TYPE_LINK) &&
					S_ISLNK(buf.st_mode))
#endif
#ifdef S_ISSOCK
				|| ((types->type & TCL_GLOB_TYPE_SOCK) &&
					S_ISSOCK(buf.st_mode))
#endif
				) {
				typeOk = 1;
			    }
			} else {
			    /* Posix error occurred */
			}
		    }
		    if (typeOk && (
			((okType != 0) && (okType !=
				pb.hFileInfo.ioFlFndrInfo.fdType)) ||
			((okCreator != 0) && (okCreator !=
				pb.hFileInfo.ioFlFndrInfo.fdCreator)))) {
			typeOk = 0;
		    }
		} 
		if (typeOk) {
d311 1
a311 2
			Tcl_ListObjAppendElement(interp, resultPtr, 
				Tcl_NewStringObj(fname, fnameLen));
d314 5
a318 7
	    } else if ((pb.hFileInfo.ioFlAttrib & ioDirMask) != 0) {
		Tcl_DStringAppend(dirPtr, ":", 1);
		result = TclDoGlob(interp, separators, dirPtr, tail, types);
		if (result != TCL_OK) {
		    Tcl_DStringFree(&fileString);
		    break;
		}
d320 2
d323 3
a325 2
	Tcl_DStringFree(&fileString);
	itemIndex++;
d327 1
a327 1
    *patternEnd = savedChar;
d329 7
a335 18
    return result;
}

/* 
 * TclpMatchFiles --
 * 
 * This function is now obsolete.  Call the above function 
 * 'TclpMatchFilesTypes' instead.
 */
int
TclpMatchFiles(
    Tcl_Interp *interp,		/* Interpreter to receive results. */
    char *separators,		/* Directory separators to pass to TclDoGlob. */
    Tcl_DString *dirPtr,	/* Contains path to directory to search. */
    char *pattern,		/* Pattern to match against. */
    char *tail)			/* Pointer to end of pattern.  Tail must
				 * point to a location in pattern and must
				 * not be static.*/
d337 83
a419 1
    return TclpMatchFilesTypes(interp,separators,dirPtr,pattern,tail,NULL);
d421 1
d426 1
a426 1
 * TclpAccess --
d439 4
a442 4
int
TclpAccess(
    CONST char *path,		/* Path of file to access (UTF-8). */
    int mode)			/* Permission setting. */
a449 2
    Tcl_DString ds;
    char *native;
d452 1
a452 3
    native = Tcl_UtfToExternalDString(NULL, path, -1, &ds);
    err = FSpLocationFromPath(Tcl_DStringLength(&ds), native, &fileSpec);
    Tcl_DStringFree(&ds);
d504 1
a504 1
	    	&& (fpb.ioFlFndrInfo.fdType != 'APPL')) {
d521 1
a521 1
 * TclpChdir --
d530 1
a530 1
 *	TclGetCwd() is deallocated and set to NULL.
d535 3
a537 3
int
TclpChdir(
    CONST char *dirName)     	/* Path to new working directory (UTF-8). */
a542 2
    Tcl_DString ds;
    char *native;
d544 1
a544 3
    native = Tcl_UtfToExternalDString(NULL, dirName, -1, &ds);
    err = FSpLocationFromPath(Tcl_DStringLength(&ds), native, &spec);
    Tcl_DStringFree(&ds);
d580 1
a580 1
 * TclpGetCwd --
d598 16
a613 1
char *
a681 1
    char *native;
d683 1
a683 1
    native = Tcl_UtfToExternalDString(NULL, path, -1, &ds);
d689 3
a691 2
    while ((strlen(native) != 0) && (path[strlen(native) - 1] == ':')) {
	native[strlen(native) - 1] = NULL;
d694 3
a696 3
    if (strchr(native, ':') == NULL) {
	strcpy(fileName + 1, native);
	native = NULL;
d698 2
a699 3
	end = strrchr(native, ':') + 1;
	strcpy(fileName + 1, end);
	*end = NULL;
d708 3
a710 2
    if (native != NULL) {
	err = FSpLocationFromPath(strlen(native), native, &fileSpec);
d777 5
d786 1
a786 1
 * TclpLstat --
d791 1
a791 1
 *	See stat() documentation.
d794 1
a794 1
 *	See stat() documentation.
d799 4
a802 4
int
TclpLstat(
    CONST char *path,		/* Path of file to stat (in UTF-8). */
    struct stat *bufPtr)	/* Filled with results of stat call. */
d804 1
a804 5
    /*
     * FIXME: Emulate TclpLstat
     */
     
    return TclpStat(path, bufPtr);
d810 1
a810 1
 * TclpStat --
d823 11
a833 4
int
TclpStat(
    CONST char *path,		/* Path of file to stat (in UTF-8). */
    struct stat *bufPtr)	/* Filled with results of stat call. */
a840 1
    Tcl_DString ds;
d842 4
a845 3
    path = Tcl_UtfToExternalDString(NULL, path, -1, &ds);
    err = FSpLocationFromPath(Tcl_DStringLength(&ds), path, &fileSpec);
    Tcl_DStringFree(&ds);
d892 5
a896 5
	    	/*
	    	 * Directories and applications are executable by everyone.
	    	 */
	    	 
	    	bufPtr->st_mode |= S_IXUSR | S_IXGRP | S_IXOTH;
d899 5
a903 5
	    	/* 
	    	 * If not locked, then everyone has write acces.
	    	 */
	    	 
	        bufPtr->st_mode |= S_IWUSR | S_IWGRP | S_IWOTH;
d918 1
a918 1
	     * epoch starts from GMT.  This is also consistant with
d922 4
a925 15
	    Tcl_MutexLock(&gmtMutex);
	    if (initialized == false) {
		MachineLocation loc;
    
		ReadLocation(&loc);
		gmt_offset = loc.u.gmtDelta & 0x00ffffff;
		if (gmt_offset & 0x00800000) {
		    gmt_offset = gmt_offset | 0xff000000;
		}
		initialized = true;
	    }
	    Tcl_MutexUnlock(&gmtMutex);

	    bufPtr->st_atime = bufPtr->st_mtime = fpb.ioFlMdDat - gmt_offset;
	    bufPtr->st_ctime = fpb.ioFlCrDat - gmt_offset;
d990 1
a990 1
    err = FSpLocationFromPath(strlen(path), (char *) path, &fileSpec);
d1090 1
d1093 1
a1093 1
    char *path, 
d1098 4
a1101 3
    
    c2pstr(path);
    hpb.fileParam.ioNamePtr = (unsigned char *) path;
a1109 1
    p2cstr((unsigned char *) path);
d1117 125
@


1.3
log
@touched all sources to ease next import
@
text
@@


1.3.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d13 1
a13 1
 * RCS: @@(#) $Id: tclMacFile.c,v 1.25 2002/10/09 11:54:24 das Exp $
d34 6
a39 24
static int NativeMatchType(Tcl_Obj *tempName, Tcl_GlobTypeData *types, 
			   HFileInfo fileInfo, OSType okType, OSType okCreator);
static OSErr FspLocationFromFsPath _ANSI_ARGS_((Tcl_Obj *pathPtr, 
						FSSpec* specPtr));
static OSErr FspLLocationFromFsPath _ANSI_ARGS_((Tcl_Obj *pathPtr, 
						FSSpec* specPtr));

static OSErr 
FspLocationFromFsPath(pathPtr, specPtr)
    Tcl_Obj *pathPtr;
    FSSpec* specPtr;
{
    CONST char *native = Tcl_FSGetNativePath(pathPtr);
    return FSpLocationFromPath(strlen(native), native, specPtr);
}

static OSErr 
FspLLocationFromFsPath(pathPtr, specPtr)
    Tcl_Obj *pathPtr;
    FSSpec* specPtr;
{
    CONST char *native = Tcl_FSGetNativePath(pathPtr);
    return FSpLLocationFromPath(strlen(native), native, specPtr);
}
d105 1
a105 1
 * TclpMatchInDirectory --
d111 5
a115 4
 *	
 *	The return value is a standard Tcl result indicating whether an
 *	error occurred in globbing.  Errors are left in interp, good
 *	results are lappended to resultPtr (which must be a valid object)
d123 24
a146 11
TclpMatchInDirectory(interp, resultPtr, pathPtr, pattern, types)
    Tcl_Interp *interp;		/* Interpreter to receive errors. */
    Tcl_Obj *resultPtr;		/* List object to lappend results. */
    Tcl_Obj *pathPtr;	        /* Contains path to directory to search. */
    CONST char *pattern;	/* Pattern to match against.  NULL or empty
                        	 * means pathPtr is actually a single file
                        	 * to check. */
    Tcl_GlobTypeData *types;	/* Object containing list of acceptable types.
				 * May be NULL. In particular the directory
				 * flag is very important. */
{
a148 1
    Tcl_Obj *fileNamePtr;
d150 39
a188 3
    fileNamePtr = Tcl_FSGetTranslatedPath(interp, pathPtr);
    if (fileNamePtr == NULL) {
	return TCL_ERROR;
d190 4
a193 1
    
d203 6
a208 19
    if (pattern == NULL || (*pattern == '\0')) {
	/* Match a single file directly */
	Tcl_StatBuf buf;
	CInfoPBRec paramBlock;
	FSSpec fileSpec;
	
	if (TclpObjLstat(fileNamePtr, &buf) != 0) {
	    /* File doesn't exist */
	    return TCL_OK;
	}

	if (FspLLocationFromFsPath(fileNamePtr, &fileSpec) == noErr) {
	    paramBlock.hFileInfo.ioCompletion = NULL;
	    paramBlock.hFileInfo.ioNamePtr = fileSpec.name;
	    paramBlock.hFileInfo.ioVRefNum = fileSpec.vRefNum;
	    paramBlock.hFileInfo.ioFDirIndex = 0;
	    paramBlock.hFileInfo.ioDirID = fileSpec.parID;
	    
	    PBGetCatInfo(&paramBlock, 0);
a210 30
	if (NativeMatchType(fileNamePtr, types, paramBlock.hFileInfo,
			    okType, okCreator)) {
	    int fnameLen;
	    char *fname = Tcl_GetStringFromObj(pathPtr,&fnameLen);
	    if ((fnameLen > 1) && (strchr(fname+1, ':') == NULL)) {
		Tcl_ListObjAppendElement(interp, resultPtr, 
			Tcl_NewStringObj(fname+1, fnameLen-1));
	    } else {
		Tcl_ListObjAppendElement(interp, resultPtr, pathPtr);
	    }
	}
	return TCL_OK;
    } else {
	char *fname;
	int fnameLen, result = TCL_OK;
	int baseLength;
	CInfoPBRec pb;
	OSErr err;
	FSSpec dirSpec;
	Boolean isDirectory;
	long dirID;
	short itemIndex;
	Str255 fileName;
	Tcl_DString fileString;    
	Tcl_DString dsOrig;

	Tcl_DStringInit(&dsOrig);
	Tcl_DStringAppend(&dsOrig, Tcl_GetString(fileNamePtr), -1);
	baseLength = Tcl_DStringLength(&dsOrig);

d212 4
a215 2
	 * Make sure that the directory part of the name really is a
	 * directory.
d217 73
a289 83

	Tcl_UtfToExternalDString(NULL, Tcl_DStringValue(&dsOrig),
		Tcl_DStringLength(&dsOrig), &fileString);

	err = FSpLocationFromPath(Tcl_DStringLength(&fileString), 
				  Tcl_DStringValue(&fileString), &dirSpec);
	Tcl_DStringFree(&fileString);
	if (err == noErr) {
	    err = FSpGetDirectoryID(&dirSpec, &dirID, &isDirectory);
	}
	
	if ((err != noErr) || !isDirectory) {
	    /*
	     * Check if we had a relative path (unix style relative path 
	     * compatibility for glob)
	     */
	    Tcl_DStringFree(&dsOrig);
	    Tcl_DStringAppend(&dsOrig, ":", 1);
	    Tcl_DStringAppend(&dsOrig, Tcl_GetString(fileNamePtr), -1);
	    baseLength = Tcl_DStringLength(&dsOrig);

	    Tcl_UtfToExternalDString(NULL, Tcl_DStringValue(&dsOrig),
		    Tcl_DStringLength(&dsOrig), &fileString);
	    
	    err = FSpLocationFromPath(Tcl_DStringLength(&fileString), 
				      Tcl_DStringValue(&fileString), &dirSpec);
	    Tcl_DStringFree(&fileString);
	    if (err == noErr) {
		err = FSpGetDirectoryID(&dirSpec, &dirID, &isDirectory);
	    }
	    
	    if ((err != noErr) || !isDirectory) {
		Tcl_DStringFree(&dsOrig);
		return TCL_OK;
	    }
	}

	/* Make sure we have a trailing directory delimiter */
	if (Tcl_DStringValue(&dsOrig)[baseLength-1] != ':') {
	    Tcl_DStringAppend(&dsOrig, ":", 1);
	    baseLength++;
	}
	
	/*
	 * Now open the directory for reading and iterate over the contents.
	 */

	pb.hFileInfo.ioVRefNum = dirSpec.vRefNum;
	pb.hFileInfo.ioDirID = dirID;
	pb.hFileInfo.ioNamePtr = (StringPtr) fileName;
	pb.hFileInfo.ioFDirIndex = itemIndex = 1;

	while (1) {
	    pb.hFileInfo.ioFDirIndex = itemIndex;
	    pb.hFileInfo.ioDirID = dirID;
	    err = PBGetCatInfoSync(&pb);
	    if (err != noErr) {
		break;
	    }

	    /*
	     * Now check to see if the file matches.  
	     */
	     
	    Tcl_ExternalToUtfDString(NULL, (char *) fileName + 1, fileName[0],
		    &fileString);
	    if (Tcl_StringMatch(Tcl_DStringValue(&fileString), pattern)) {
		Tcl_Obj *tempName;
		Tcl_DStringSetLength(&dsOrig, baseLength);
		Tcl_DStringAppend(&dsOrig, Tcl_DStringValue(&fileString), -1);
		fname = Tcl_DStringValue(&dsOrig);
		fnameLen = Tcl_DStringLength(&dsOrig);
		
		/* 
		 * We use this tempName in calls to check the file's
		 * type below.  We may also use it for the result.
		 */
		tempName = Tcl_NewStringObj(fname, fnameLen);
		Tcl_IncrRefCount(tempName);

		/* Is the type acceptable? */
		if (NativeMatchType(tempName, types, pb.hFileInfo,
				    okType, okCreator)) {
d294 2
a295 1
			Tcl_ListObjAppendElement(interp, resultPtr, tempName);
d298 7
a304 5
		/* 
		 * This will free the object, unless it was inserted in
		 * the result list above.
		 */
		Tcl_DecrRefCount(tempName);
a305 2
	    Tcl_DStringFree(&fileString);
	    itemIndex++;
d307 4
d312 1
a312 3
	Tcl_DStringFree(&dsOrig);
	return result;
    }
d314 16
a329 8

static int 
NativeMatchType(
    Tcl_Obj *tempName,        /* Path to check */
    Tcl_GlobTypeData *types,  /* Type description to match against */
    HFileInfo fileInfo,       /* MacOS file info */
    OSType okType,            /* Acceptable MacOS type, or zero */
    OSType okCreator)         /* Acceptable MacOS creator, or zero */
d331 1
a331 83
    if (types == NULL) {
	/* If invisible, don't return the file */
	if (fileInfo.ioFlFndrInfo.fdFlags & kIsInvisible) {
	    return 0;
	}
    } else {
	Tcl_StatBuf buf;
	
	if (fileInfo.ioFlFndrInfo.fdFlags & kIsInvisible) {
	    /* If invisible */
	    if ((types->perm == 0) || 
	      !(types->perm & TCL_GLOB_PERM_HIDDEN)) {
		return 0;
	    }
	} else {
	    /* Visible */
	    if (types->perm & TCL_GLOB_PERM_HIDDEN) {
		return 0;
	    }
	}
	if (types->perm != 0) {
	    if (
		((types->perm & TCL_GLOB_PERM_RONLY) &&
			!(fileInfo.ioFlAttrib & 1)) ||
		((types->perm & TCL_GLOB_PERM_R) &&
			(TclpObjAccess(tempName, R_OK) != 0)) ||
		((types->perm & TCL_GLOB_PERM_W) &&
			(TclpObjAccess(tempName, W_OK) != 0)) ||
		((types->perm & TCL_GLOB_PERM_X) &&
			(TclpObjAccess(tempName, X_OK) != 0))
		) {
		return 0;
	    }
	}
	if (types->type != 0) {
	    if (TclpObjStat(tempName, &buf) != 0) {
		/* Posix error occurred */
		return 0;
	    }
	    /*
	     * In order bcdpfls as in 'find -t'
	     */
	    if (
		((types->type & TCL_GLOB_TYPE_BLOCK) &&
			S_ISBLK(buf.st_mode)) ||
		((types->type & TCL_GLOB_TYPE_CHAR) &&
			S_ISCHR(buf.st_mode)) ||
		((types->type & TCL_GLOB_TYPE_DIR) &&
			S_ISDIR(buf.st_mode)) ||
		((types->type & TCL_GLOB_TYPE_PIPE) &&
			S_ISFIFO(buf.st_mode)) ||
		((types->type & TCL_GLOB_TYPE_FILE) &&
			S_ISREG(buf.st_mode))
#ifdef S_ISSOCK
		|| ((types->type & TCL_GLOB_TYPE_SOCK) &&
			S_ISSOCK(buf.st_mode))
#endif
		) {
		/* Do nothing -- this file is ok */
	    } else {
		int typeOk = 0;
#ifdef S_ISLNK
		if (types->type & TCL_GLOB_TYPE_LINK) {
		    if (TclpObjLstat(tempName, &buf) == 0) {
			if (S_ISLNK(buf.st_mode)) {
			    typeOk = 1;
			}
		    }
		}
#endif
		if (typeOk == 0) {
		    return 0;
		}
	    }
	}
	if (((okType != 0) && (okType !=
			       fileInfo.ioFlFndrInfo.fdType)) ||
	    ((okCreator != 0) && (okCreator !=
				  fileInfo.ioFlFndrInfo.fdCreator))) {
	    return 0;
	}
    }
    return 1;
a332 1

d337 1
a337 1
 * TclpObjAccess --
d350 4
a353 4
int 
TclpObjAccess(pathPtr, mode)
    Tcl_Obj *pathPtr;
    int mode;
d361 2
d365 3
a367 1
    err = FspLLocationFromFsPath(pathPtr, &fileSpec);
d419 1
a419 1
		&& (fpb.ioFlFndrInfo.fdType != 'APPL')) {
d436 1
a436 1
 * TclpObjChdir --
d445 1
a445 1
 *	Tcl_FSGetCwd() is deallocated and set to NULL.
d450 3
a452 3
int 
TclpObjChdir(pathPtr)
    Tcl_Obj *pathPtr;
d458 2
d461 3
a463 1
    err = FspLocationFromFsPath(pathPtr, &spec);
d499 1
a499 1
 * TclpObjGetCwd --
d517 1
a517 16
Tcl_Obj* 
TclpObjGetCwd(interp)
    Tcl_Interp *interp;
{
    Tcl_DString ds;
    if (TclpGetCwd(interp, &ds) != NULL) {
	Tcl_Obj *cwdPtr = Tcl_NewStringObj(Tcl_DStringValue(&ds), -1);
	Tcl_IncrRefCount(cwdPtr);
	Tcl_DStringFree(&ds);
	return cwdPtr;
    } else {
	return NULL;
    }
}

CONST char *
d586 1
d588 1
a588 1
    Tcl_UtfToExternalDString(NULL, path, -1, &ds);
d594 2
a595 3
    while ((Tcl_DStringLength(&ds) != 0) 
	   && (Tcl_DStringValue(&ds)[Tcl_DStringLength(&ds) - 1] == ':')) {
	Tcl_DStringSetLength(&ds, Tcl_DStringLength(&ds) - 1);
d598 3
a600 3
    end = strrchr(Tcl_DStringValue(&ds), ':');
    if (end == NULL ) {
	strcpy(fileName + 1, Tcl_DStringValue(&ds));
d602 3
a604 2
	strcpy(fileName + 1, end + 1);
	Tcl_DStringSetLength(&ds, end + 1 - Tcl_DStringValue(&ds));
d613 2
a614 3
    if (end != NULL) {
	err = FSpLocationFromPath(Tcl_DStringLength(&ds), 
				  Tcl_DStringValue(&ds), &fileSpec);
a680 5

static int 
TclpObjStatAlias _ANSI_ARGS_((Tcl_Obj *pathPtr, Tcl_StatBuf *bufPtr, 
			      Boolean resolveLink));

d685 1
a685 1
 * TclpObjLstat --
d690 1
a690 1
 *	See lstat() documentation.
d693 1
a693 1
 *	See lstat() documentation.
d698 4
a701 4
int 
TclpObjLstat(pathPtr, buf)
    Tcl_Obj *pathPtr;
    Tcl_StatBuf *buf;
d703 5
a707 1
    return TclpObjStatAlias(pathPtr, buf, FALSE);
d713 1
a713 1
 * TclpObjStat --
d726 4
a729 11
int 
TclpObjStat(pathPtr, bufPtr)
    Tcl_Obj *pathPtr;
    Tcl_StatBuf *bufPtr;
{
    return TclpObjStatAlias(pathPtr, bufPtr, TRUE);
}


static int
TclpObjStatAlias (Tcl_Obj *pathPtr, Tcl_StatBuf *bufPtr, Boolean resolveLink)
d737 1
d739 3
a741 4
    if (resolveLink)
    	err = FspLocationFromFsPath(pathPtr, &fileSpec);
    else
    	err = FspLLocationFromFsPath(pathPtr, &fileSpec);
d788 5
a792 5
		/*
		 * Directories and applications are executable by everyone.
		 */
		 
		bufPtr->st_mode |= S_IXUSR | S_IXGRP | S_IXOTH;
d795 5
a799 5
		/* 
		 * If not locked, then everyone has write acces.
		 */
		 
		bufPtr->st_mode |= S_IWUSR | S_IWGRP | S_IWOTH;
d814 1
a814 1
	     * epoch starts from GMT.  This is also consistent with
d818 15
a832 4
	    bufPtr->st_atime = bufPtr->st_mtime = fpb.ioFlMdDat 
	      - TclpGetGMTOffset() + tcl_mac_epoch_offset;
	    bufPtr->st_ctime = fpb.ioFlCrDat - TclpGetGMTOffset() 
	      + tcl_mac_epoch_offset;
d897 1
a897 1
    err = FSpLocationFromPath(strlen(path), path, &fileSpec);
a996 1

d999 1
a999 1
    CONST char *path, 
d1004 3
a1006 4
    Str255 pathName;
    strcpy((char *) pathName + 1, path);
    pathName[0] = strlen(path);
    hpb.fileParam.ioNamePtr = pathName;
d1015 1
a1022 125
}


/*
 *----------------------------------------------------------------------
 *
 * TclpTempFileName --
 *
 *	This function returns a unique filename.
 *
 * Results:
 *	Returns a valid Tcl_Obj* with refCount 0, or NULL on failure.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_Obj* 
TclpTempFileName()
{
    char fileName[L_tmpnam];
    
    if (tmpnam(fileName) == NULL) {	       /* INTL: Native. */
	return NULL;
    }

    return TclpNativeToNormalized((ClientData) fileName);
}

#ifdef S_IFLNK

Tcl_Obj* 
TclpObjLink(pathPtr, toPtr, linkAction)
    Tcl_Obj *pathPtr;
    Tcl_Obj *toPtr;
    int linkAction;
{
    Tcl_Obj* link = NULL;

    if (toPtr != NULL) {
	if (TclpObjAccess(pathPtr, F_OK) != -1) {
	    /* src exists */
	    errno = EEXIST;
	    return NULL;
	}
	if (TclpObjAccess(toPtr, F_OK) == -1) {
	    /* target doesn't exist */
	    errno = ENOENT;
	    return NULL;
	}

	if (linkAction & TCL_CREATE_SYMBOLIC_LINK) {
	    /* Needs to create a new link */
	    FSSpec spec;
	    FSSpec linkSpec;
	    OSErr err;
	    CONST char *path;
	    AliasHandle alias;
	    
	    err = FspLocationFromFsPath(toPtr, &spec);
	    if (err != noErr) {
		errno = ENOENT;
		return NULL;
	    }

	    path = Tcl_FSGetNativePath(pathPtr);
	    err = FSpLocationFromPath(strlen(path), path, &linkSpec);
	    if (err == noErr) {
		err = dupFNErr;		/* EEXIST. */
	    } else {
		err = NewAlias(&spec, &linkSpec, &alias);
	    }
	    if (err != noErr) {
		errno = TclMacOSErrorToPosixError(err);
		return NULL;
	    }
	    return toPtr;
	} else {
	    errno = ENODEV;
	    return NULL;
	}
    } else {
	Tcl_DString ds;
	Tcl_Obj *transPtr = Tcl_FSGetTranslatedPath(NULL, pathPtr);
	if (transPtr == NULL) {
	    return NULL;
	}
	if (TclpReadlink(Tcl_GetString(transPtr), &ds) != NULL) {
	    link = Tcl_NewStringObj(Tcl_DStringValue(&ds), -1);
	    Tcl_IncrRefCount(link);
	    Tcl_DStringFree(&ds);
	}
    }
    return link;
}

#endif


/*
 *---------------------------------------------------------------------------
 *
 * TclpFilesystemPathType --
 *
 *      This function is part of the native filesystem support, and
 *      returns the path type of the given path.  Right now it simply
 *      returns NULL.  In the future it could return specific path
 *      types, like 'HFS', 'HFS+', 'nfs', 'samba', 'FAT32', etc.
 *
 * Results:
 *      NULL at present.
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
 */
Tcl_Obj*
TclpFilesystemPathType(pathObjPtr)
    Tcl_Obj* pathObjPtr;
{
    /* All native paths are of the same type */
    return NULL;
@


1.3.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@d13 1
a13 1
 * RCS: @@(#) $Id: tclMacFile.c,v 1.24 2002/07/15 10:28:18 vincentdarley Exp $
d34 6
a39 24
static int NativeMatchType(Tcl_Obj *tempName, Tcl_GlobTypeData *types, 
			   HFileInfo fileInfo, OSType okType, OSType okCreator);
static OSErr FspLocationFromFsPath _ANSI_ARGS_((Tcl_Obj *pathPtr, 
						FSSpec* specPtr));
static OSErr FspLLocationFromFsPath _ANSI_ARGS_((Tcl_Obj *pathPtr, 
						FSSpec* specPtr));

static OSErr 
FspLocationFromFsPath(pathPtr, specPtr)
    Tcl_Obj *pathPtr;
    FSSpec* specPtr;
{
    CONST char *native = Tcl_FSGetNativePath(pathPtr);
    return FSpLocationFromPath(strlen(native), native, specPtr);
}

static OSErr 
FspLLocationFromFsPath(pathPtr, specPtr)
    Tcl_Obj *pathPtr;
    FSSpec* specPtr;
{
    CONST char *native = Tcl_FSGetNativePath(pathPtr);
    return FSpLLocationFromPath(strlen(native), native, specPtr);
}
d105 1
a105 1
 * TclpMatchInDirectory --
d111 5
a115 4
 *	
 *	The return value is a standard Tcl result indicating whether an
 *	error occurred in globbing.  Errors are left in interp, good
 *	results are lappended to resultPtr (which must be a valid object)
d123 24
a146 11
TclpMatchInDirectory(interp, resultPtr, pathPtr, pattern, types)
    Tcl_Interp *interp;		/* Interpreter to receive errors. */
    Tcl_Obj *resultPtr;		/* List object to lappend results. */
    Tcl_Obj *pathPtr;	        /* Contains path to directory to search. */
    CONST char *pattern;	/* Pattern to match against.  NULL or empty
                        	 * means pathPtr is actually a single file
                        	 * to check. */
    Tcl_GlobTypeData *types;	/* Object containing list of acceptable types.
				 * May be NULL. In particular the directory
				 * flag is very important. */
{
a148 1
    Tcl_Obj *fileNamePtr;
d150 39
a188 3
    fileNamePtr = Tcl_FSGetTranslatedPath(interp, pathPtr);
    if (fileNamePtr == NULL) {
	return TCL_ERROR;
d190 4
a193 1
    
d203 6
a208 19
    if (pattern == NULL || (*pattern == '\0')) {
	/* Match a single file directly */
	Tcl_StatBuf buf;
	CInfoPBRec paramBlock;
	FSSpec fileSpec;
	
	if (TclpObjLstat(fileNamePtr, &buf) != 0) {
	    /* File doesn't exist */
	    return TCL_OK;
	}

	if (FspLLocationFromFsPath(fileNamePtr, &fileSpec) == noErr) {
	    paramBlock.hFileInfo.ioCompletion = NULL;
	    paramBlock.hFileInfo.ioNamePtr = fileSpec.name;
	    paramBlock.hFileInfo.ioVRefNum = fileSpec.vRefNum;
	    paramBlock.hFileInfo.ioFDirIndex = 0;
	    paramBlock.hFileInfo.ioDirID = fileSpec.parID;
	    
	    PBGetCatInfo(&paramBlock, 0);
a210 30
	if (NativeMatchType(fileNamePtr, types, paramBlock.hFileInfo,
			    okType, okCreator)) {
	    int fnameLen;
	    char *fname = Tcl_GetStringFromObj(pathPtr,&fnameLen);
	    if ((fnameLen > 1) && (strchr(fname+1, ':') == NULL)) {
		Tcl_ListObjAppendElement(interp, resultPtr, 
			Tcl_NewStringObj(fname+1, fnameLen-1));
	    } else {
		Tcl_ListObjAppendElement(interp, resultPtr, pathPtr);
	    }
	}
	return TCL_OK;
    } else {
	char *fname;
	int fnameLen, result = TCL_OK;
	int baseLength;
	CInfoPBRec pb;
	OSErr err;
	FSSpec dirSpec;
	Boolean isDirectory;
	long dirID;
	short itemIndex;
	Str255 fileName;
	Tcl_DString fileString;    
	Tcl_DString dsOrig;

	Tcl_DStringInit(&dsOrig);
	Tcl_DStringAppend(&dsOrig, Tcl_GetString(fileNamePtr), -1);
	baseLength = Tcl_DStringLength(&dsOrig);

d212 4
a215 2
	 * Make sure that the directory part of the name really is a
	 * directory.
d217 73
a289 83

	Tcl_UtfToExternalDString(NULL, Tcl_DStringValue(&dsOrig),
		Tcl_DStringLength(&dsOrig), &fileString);

	err = FSpLocationFromPath(Tcl_DStringLength(&fileString), 
				  Tcl_DStringValue(&fileString), &dirSpec);
	Tcl_DStringFree(&fileString);
	if (err == noErr) {
	    err = FSpGetDirectoryID(&dirSpec, &dirID, &isDirectory);
	}
	
	if ((err != noErr) || !isDirectory) {
	    /*
	     * Check if we had a relative path (unix style relative path 
	     * compatibility for glob)
	     */
	    Tcl_DStringFree(&dsOrig);
	    Tcl_DStringAppend(&dsOrig, ":", 1);
	    Tcl_DStringAppend(&dsOrig, Tcl_GetString(fileNamePtr), -1);
	    baseLength = Tcl_DStringLength(&dsOrig);

	    Tcl_UtfToExternalDString(NULL, Tcl_DStringValue(&dsOrig),
		    Tcl_DStringLength(&dsOrig), &fileString);
	    
	    err = FSpLocationFromPath(Tcl_DStringLength(&fileString), 
				      Tcl_DStringValue(&fileString), &dirSpec);
	    Tcl_DStringFree(&fileString);
	    if (err == noErr) {
		err = FSpGetDirectoryID(&dirSpec, &dirID, &isDirectory);
	    }
	    
	    if ((err != noErr) || !isDirectory) {
		Tcl_DStringFree(&dsOrig);
		return TCL_OK;
	    }
	}

	/* Make sure we have a trailing directory delimiter */
	if (Tcl_DStringValue(&dsOrig)[baseLength-1] != ':') {
	    Tcl_DStringAppend(&dsOrig, ":", 1);
	    baseLength++;
	}
	
	/*
	 * Now open the directory for reading and iterate over the contents.
	 */

	pb.hFileInfo.ioVRefNum = dirSpec.vRefNum;
	pb.hFileInfo.ioDirID = dirID;
	pb.hFileInfo.ioNamePtr = (StringPtr) fileName;
	pb.hFileInfo.ioFDirIndex = itemIndex = 1;

	while (1) {
	    pb.hFileInfo.ioFDirIndex = itemIndex;
	    pb.hFileInfo.ioDirID = dirID;
	    err = PBGetCatInfoSync(&pb);
	    if (err != noErr) {
		break;
	    }

	    /*
	     * Now check to see if the file matches.  
	     */
	     
	    Tcl_ExternalToUtfDString(NULL, (char *) fileName + 1, fileName[0],
		    &fileString);
	    if (Tcl_StringMatch(Tcl_DStringValue(&fileString), pattern)) {
		Tcl_Obj *tempName;
		Tcl_DStringSetLength(&dsOrig, baseLength);
		Tcl_DStringAppend(&dsOrig, Tcl_DStringValue(&fileString), -1);
		fname = Tcl_DStringValue(&dsOrig);
		fnameLen = Tcl_DStringLength(&dsOrig);
		
		/* 
		 * We use this tempName in calls to check the file's
		 * type below.  We may also use it for the result.
		 */
		tempName = Tcl_NewStringObj(fname, fnameLen);
		Tcl_IncrRefCount(tempName);

		/* Is the type acceptable? */
		if (NativeMatchType(tempName, types, pb.hFileInfo,
				    okType, okCreator)) {
d294 2
a295 1
			Tcl_ListObjAppendElement(interp, resultPtr, tempName);
d298 7
a304 5
		/* 
		 * This will free the object, unless it was inserted in
		 * the result list above.
		 */
		Tcl_DecrRefCount(tempName);
a305 2
	    Tcl_DStringFree(&fileString);
	    itemIndex++;
d307 4
d312 1
a312 3
	Tcl_DStringFree(&dsOrig);
	return result;
    }
d314 16
a329 8

static int 
NativeMatchType(
    Tcl_Obj *tempName,        /* Path to check */
    Tcl_GlobTypeData *types,  /* Type description to match against */
    HFileInfo fileInfo,       /* MacOS file info */
    OSType okType,            /* Acceptable MacOS type, or zero */
    OSType okCreator)         /* Acceptable MacOS creator, or zero */
d331 1
a331 83
    if (types == NULL) {
	/* If invisible, don't return the file */
	if (fileInfo.ioFlFndrInfo.fdFlags & kIsInvisible) {
	    return 0;
	}
    } else {
	Tcl_StatBuf buf;
	
	if (fileInfo.ioFlFndrInfo.fdFlags & kIsInvisible) {
	    /* If invisible */
	    if ((types->perm == 0) || 
	      !(types->perm & TCL_GLOB_PERM_HIDDEN)) {
		return 0;
	    }
	} else {
	    /* Visible */
	    if (types->perm & TCL_GLOB_PERM_HIDDEN) {
		return 0;
	    }
	}
	if (types->perm != 0) {
	    if (
		((types->perm & TCL_GLOB_PERM_RONLY) &&
			!(fileInfo.ioFlAttrib & 1)) ||
		((types->perm & TCL_GLOB_PERM_R) &&
			(TclpObjAccess(tempName, R_OK) != 0)) ||
		((types->perm & TCL_GLOB_PERM_W) &&
			(TclpObjAccess(tempName, W_OK) != 0)) ||
		((types->perm & TCL_GLOB_PERM_X) &&
			(TclpObjAccess(tempName, X_OK) != 0))
		) {
		return 0;
	    }
	}
	if (types->type != 0) {
	    if (TclpObjStat(tempName, &buf) != 0) {
		/* Posix error occurred */
		return 0;
	    }
	    /*
	     * In order bcdpfls as in 'find -t'
	     */
	    if (
		((types->type & TCL_GLOB_TYPE_BLOCK) &&
			S_ISBLK(buf.st_mode)) ||
		((types->type & TCL_GLOB_TYPE_CHAR) &&
			S_ISCHR(buf.st_mode)) ||
		((types->type & TCL_GLOB_TYPE_DIR) &&
			S_ISDIR(buf.st_mode)) ||
		((types->type & TCL_GLOB_TYPE_PIPE) &&
			S_ISFIFO(buf.st_mode)) ||
		((types->type & TCL_GLOB_TYPE_FILE) &&
			S_ISREG(buf.st_mode))
#ifdef S_ISSOCK
		|| ((types->type & TCL_GLOB_TYPE_SOCK) &&
			S_ISSOCK(buf.st_mode))
#endif
		) {
		/* Do nothing -- this file is ok */
	    } else {
		int typeOk = 0;
#ifdef S_ISLNK
		if (types->type & TCL_GLOB_TYPE_LINK) {
		    if (TclpObjLstat(tempName, &buf) == 0) {
			if (S_ISLNK(buf.st_mode)) {
			    typeOk = 1;
			}
		    }
		}
#endif
		if (typeOk == 0) {
		    return 0;
		}
	    }
	}
	if (((okType != 0) && (okType !=
			       fileInfo.ioFlFndrInfo.fdType)) ||
	    ((okCreator != 0) && (okCreator !=
				  fileInfo.ioFlFndrInfo.fdCreator))) {
	    return 0;
	}
    }
    return 1;
a332 1

d337 1
a337 1
 * TclpObjAccess --
d350 4
a353 4
int 
TclpObjAccess(pathPtr, mode)
    Tcl_Obj *pathPtr;
    int mode;
d361 2
d365 3
a367 1
    err = FspLLocationFromFsPath(pathPtr, &fileSpec);
d419 1
a419 1
		&& (fpb.ioFlFndrInfo.fdType != 'APPL')) {
d436 1
a436 1
 * TclpObjChdir --
d445 1
a445 1
 *	Tcl_FSGetCwd() is deallocated and set to NULL.
d450 3
a452 3
int 
TclpObjChdir(pathPtr)
    Tcl_Obj *pathPtr;
d458 2
d461 3
a463 1
    err = FspLocationFromFsPath(pathPtr, &spec);
d499 1
a499 1
 * TclpObjGetCwd --
d517 1
a517 16
Tcl_Obj* 
TclpObjGetCwd(interp)
    Tcl_Interp *interp;
{
    Tcl_DString ds;
    if (TclpGetCwd(interp, &ds) != NULL) {
	Tcl_Obj *cwdPtr = Tcl_NewStringObj(Tcl_DStringValue(&ds), -1);
	Tcl_IncrRefCount(cwdPtr);
	Tcl_DStringFree(&ds);
	return cwdPtr;
    } else {
	return NULL;
    }
}

CONST char *
d586 1
d588 1
a588 1
    Tcl_UtfToExternalDString(NULL, path, -1, &ds);
d594 2
a595 3
    while ((Tcl_DStringLength(&ds) != 0) 
	   && (Tcl_DStringValue(&ds)[Tcl_DStringLength(&ds) - 1] == ':')) {
	Tcl_DStringSetLength(&ds, Tcl_DStringLength(&ds) - 1);
d598 3
a600 3
    end = strrchr(Tcl_DStringValue(&ds), ':');
    if (end == NULL ) {
	strcpy(fileName + 1, Tcl_DStringValue(&ds));
d602 3
a604 2
	strcpy(fileName + 1, end + 1);
	Tcl_DStringSetLength(&ds, end + 1 - Tcl_DStringValue(&ds));
d613 2
a614 3
    if (end != NULL) {
	err = FSpLocationFromPath(Tcl_DStringLength(&ds), 
				  Tcl_DStringValue(&ds), &fileSpec);
a680 5

static int 
TclpObjStatAlias _ANSI_ARGS_((Tcl_Obj *pathPtr, Tcl_StatBuf *bufPtr, 
			      Boolean resolveLink));

d685 1
a685 1
 * TclpObjLstat --
d690 1
a690 1
 *	See lstat() documentation.
d693 1
a693 1
 *	See lstat() documentation.
d698 4
a701 4
int 
TclpObjLstat(pathPtr, buf)
    Tcl_Obj *pathPtr;
    Tcl_StatBuf *buf;
d703 5
a707 1
    return TclpObjStatAlias(pathPtr, buf, FALSE);
d713 1
a713 1
 * TclpObjStat --
d726 4
a729 11
int 
TclpObjStat(pathPtr, bufPtr)
    Tcl_Obj *pathPtr;
    Tcl_StatBuf *bufPtr;
{
    return TclpObjStatAlias(pathPtr, bufPtr, TRUE);
}


static int
TclpObjStatAlias (Tcl_Obj *pathPtr, Tcl_StatBuf *bufPtr, Boolean resolveLink)
d737 1
d739 3
a741 4
    if (resolveLink)
    	err = FspLocationFromFsPath(pathPtr, &fileSpec);
    else
    	err = FspLLocationFromFsPath(pathPtr, &fileSpec);
d788 5
a792 5
		/*
		 * Directories and applications are executable by everyone.
		 */
		 
		bufPtr->st_mode |= S_IXUSR | S_IXGRP | S_IXOTH;
d795 5
a799 5
		/* 
		 * If not locked, then everyone has write acces.
		 */
		 
		bufPtr->st_mode |= S_IWUSR | S_IWGRP | S_IWOTH;
d814 1
a814 1
	     * epoch starts from GMT.  This is also consistent with
d818 15
a832 4
	    bufPtr->st_atime = bufPtr->st_mtime = fpb.ioFlMdDat 
	      - TclpGetGMTOffset() + tcl_mac_epoch_offset;
	    bufPtr->st_ctime = fpb.ioFlCrDat - TclpGetGMTOffset() 
	      + tcl_mac_epoch_offset;
d897 1
a897 1
    err = FSpLocationFromPath(strlen(path), path, &fileSpec);
a996 1

d999 1
a999 1
    CONST char *path, 
d1004 3
a1006 4
    Str255 pathName;
    strcpy((char *) pathName + 1, path);
    pathName[0] = strlen(path);
    hpb.fileParam.ioNamePtr = pathName;
d1015 1
a1022 125
}


/*
 *----------------------------------------------------------------------
 *
 * TclpTempFileName --
 *
 *	This function returns a unique filename.
 *
 * Results:
 *	Returns a valid Tcl_Obj* with refCount 0, or NULL on failure.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_Obj* 
TclpTempFileName()
{
    char fileName[L_tmpnam];
    
    if (tmpnam(fileName) == NULL) {	       /* INTL: Native. */
	return NULL;
    }

    return TclpNativeToNormalized((ClientData) fileName);
}

#ifdef S_IFLNK

Tcl_Obj* 
TclpObjLink(pathPtr, toPtr, linkAction)
    Tcl_Obj *pathPtr;
    Tcl_Obj *toPtr;
    int linkAction;
{
    Tcl_Obj* link = NULL;

    if (toPtr != NULL) {
	if (TclpObjAccess(pathPtr, F_OK) != -1) {
	    /* src exists */
	    errno = EEXIST;
	    return NULL;
	}
	if (TclpObjAccess(toPtr, F_OK) == -1) {
	    /* target doesn't exist */
	    errno = ENOENT;
	    return NULL;
	}

	if (linkAction & TCL_CREATE_SYMBOLIC_LINK) {
	    /* Needs to create a new link */
	    FSSpec spec;
	    FSSpec linkSpec;
	    OSErr err;
	    char *path;
	    AliasHandle alias;
	    
	    err = FspLocationFromFsPath(toPtr, &spec);
	    if (err != noErr) {
		errno = ENOENT;
		return NULL;
	    }

	    path = Tcl_FSGetNativePath(pathPtr);
	    err = FSpLocationFromPath(strlen(path), path, &linkSpec);
	    if (err == noErr) {
		err = dupFNErr;		/* EEXIST. */
	    } else {
		err = NewAlias(&spec, &linkSpec, &alias);
	    }
	    if (err != noErr) {
		errno = TclMacOSErrorToPosixError(err);
		return NULL;
	    }
	    return toPtr;
	} else {
	    errno = ENODEV;
	    return NULL;
	}
    } else {
	Tcl_DString ds;
	Tcl_Obj *transPtr = Tcl_FSGetTranslatedPath(NULL, pathPtr);
	if (transPtr == NULL) {
	    return NULL;
	}
	if (TclpReadlink(Tcl_GetString(transPtr), &ds) != NULL) {
	    link = Tcl_NewStringObj(Tcl_DStringValue(&ds), -1);
	    Tcl_IncrRefCount(link);
	    Tcl_DStringFree(&ds);
	}
    }
    return link;
}

#endif


/*
 *---------------------------------------------------------------------------
 *
 * TclpFilesystemPathType --
 *
 *      This function is part of the native filesystem support, and
 *      returns the path type of the given path.  Right now it simply
 *      returns NULL.  In the future it could return specific path
 *      types, like 'HFS', 'HFS+', 'nfs', 'samba', 'FAT32', etc.
 *
 * Results:
 *      NULL at present.
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
 */
Tcl_Obj*
TclpFilesystemPathType(pathObjPtr)
    Tcl_Obj* pathObjPtr;
{
    /* All native paths are of the same type */
    return NULL;
@


1.2
log
@touched all Tcl files to ease next import.
@
text
@@


1.2.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.2.16.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d34 6
a39 24
static int NativeMatchType(Tcl_Obj *tempName, Tcl_GlobTypeData *types, 
			   HFileInfo fileInfo, OSType okType, OSType okCreator);
static OSErr FspLocationFromFsPath _ANSI_ARGS_((Tcl_Obj *pathPtr, 
						FSSpec* specPtr));
static OSErr FspLLocationFromFsPath _ANSI_ARGS_((Tcl_Obj *pathPtr, 
						FSSpec* specPtr));

static OSErr 
FspLocationFromFsPath(pathPtr, specPtr)
    Tcl_Obj *pathPtr;
    FSSpec* specPtr;
{
    CONST char *native = Tcl_FSGetNativePath(pathPtr);
    return FSpLocationFromPath(strlen(native), native, specPtr);
}

static OSErr 
FspLLocationFromFsPath(pathPtr, specPtr)
    Tcl_Obj *pathPtr;
    FSSpec* specPtr;
{
    CONST char *native = Tcl_FSGetNativePath(pathPtr);
    return FSpLLocationFromPath(strlen(native), native, specPtr);
}
d105 1
a105 1
 * TclpMatchInDirectory --
d111 5
a115 4
 *	
 *	The return value is a standard Tcl result indicating whether an
 *	error occurred in globbing.  Errors are left in interp, good
 *	results are lappended to resultPtr (which must be a valid object)
d123 24
a146 11
TclpMatchInDirectory(interp, resultPtr, pathPtr, pattern, types)
    Tcl_Interp *interp;		/* Interpreter to receive errors. */
    Tcl_Obj *resultPtr;		/* List object to lappend results. */
    Tcl_Obj *pathPtr;	        /* Contains path to directory to search. */
    CONST char *pattern;	/* Pattern to match against.  NULL or empty
                        	 * means pathPtr is actually a single file
                        	 * to check. */
    Tcl_GlobTypeData *types;	/* Object containing list of acceptable types.
				 * May be NULL. In particular the directory
				 * flag is very important. */
{
a148 1
    Tcl_Obj *fileNamePtr;
d150 39
a188 3
    fileNamePtr = Tcl_FSGetTranslatedPath(interp, pathPtr);
    if (fileNamePtr == NULL) {
	return TCL_ERROR;
d190 4
a193 1
    
d203 6
a208 19
    if (pattern == NULL || (*pattern == '\0')) {
	/* Match a single file directly */
	Tcl_StatBuf buf;
	CInfoPBRec paramBlock;
	FSSpec fileSpec;
	
	if (TclpObjLstat(fileNamePtr, &buf) != 0) {
	    /* File doesn't exist */
	    return TCL_OK;
	}

	if (FspLLocationFromFsPath(fileNamePtr, &fileSpec) == noErr) {
	    paramBlock.hFileInfo.ioCompletion = NULL;
	    paramBlock.hFileInfo.ioNamePtr = fileSpec.name;
	    paramBlock.hFileInfo.ioVRefNum = fileSpec.vRefNum;
	    paramBlock.hFileInfo.ioFDirIndex = 0;
	    paramBlock.hFileInfo.ioDirID = fileSpec.parID;
	    
	    PBGetCatInfo(&paramBlock, 0);
a210 30
	if (NativeMatchType(fileNamePtr, types, paramBlock.hFileInfo,
			    okType, okCreator)) {
	    int fnameLen;
	    char *fname = Tcl_GetStringFromObj(pathPtr,&fnameLen);
	    if ((fnameLen > 1) && (strchr(fname+1, ':') == NULL)) {
		Tcl_ListObjAppendElement(interp, resultPtr, 
			Tcl_NewStringObj(fname+1, fnameLen-1));
	    } else {
		Tcl_ListObjAppendElement(interp, resultPtr, pathPtr);
	    }
	}
	return TCL_OK;
    } else {
	char *fname;
	int fnameLen, result = TCL_OK;
	int baseLength;
	CInfoPBRec pb;
	OSErr err;
	FSSpec dirSpec;
	Boolean isDirectory;
	long dirID;
	short itemIndex;
	Str255 fileName;
	Tcl_DString fileString;    
	Tcl_DString dsOrig;

	Tcl_DStringInit(&dsOrig);
	Tcl_DStringAppend(&dsOrig, Tcl_GetString(fileNamePtr), -1);
	baseLength = Tcl_DStringLength(&dsOrig);

d212 4
a215 2
	 * Make sure that the directory part of the name really is a
	 * directory.
d217 73
a289 83

	Tcl_UtfToExternalDString(NULL, Tcl_DStringValue(&dsOrig),
		Tcl_DStringLength(&dsOrig), &fileString);

	err = FSpLocationFromPath(Tcl_DStringLength(&fileString), 
				  Tcl_DStringValue(&fileString), &dirSpec);
	Tcl_DStringFree(&fileString);
	if (err == noErr) {
	    err = FSpGetDirectoryID(&dirSpec, &dirID, &isDirectory);
	}
	
	if ((err != noErr) || !isDirectory) {
	    /*
	     * Check if we had a relative path (unix style relative path 
	     * compatibility for glob)
	     */
	    Tcl_DStringFree(&dsOrig);
	    Tcl_DStringAppend(&dsOrig, ":", 1);
	    Tcl_DStringAppend(&dsOrig, Tcl_GetString(fileNamePtr), -1);
	    baseLength = Tcl_DStringLength(&dsOrig);

	    Tcl_UtfToExternalDString(NULL, Tcl_DStringValue(&dsOrig),
		    Tcl_DStringLength(&dsOrig), &fileString);
	    
	    err = FSpLocationFromPath(Tcl_DStringLength(&fileString), 
				      Tcl_DStringValue(&fileString), &dirSpec);
	    Tcl_DStringFree(&fileString);
	    if (err == noErr) {
		err = FSpGetDirectoryID(&dirSpec, &dirID, &isDirectory);
	    }
	    
	    if ((err != noErr) || !isDirectory) {
		Tcl_DStringFree(&dsOrig);
		return TCL_OK;
	    }
	}

	/* Make sure we have a trailing directory delimiter */
	if (Tcl_DStringValue(&dsOrig)[baseLength-1] != ':') {
	    Tcl_DStringAppend(&dsOrig, ":", 1);
	    baseLength++;
	}
	
	/*
	 * Now open the directory for reading and iterate over the contents.
	 */

	pb.hFileInfo.ioVRefNum = dirSpec.vRefNum;
	pb.hFileInfo.ioDirID = dirID;
	pb.hFileInfo.ioNamePtr = (StringPtr) fileName;
	pb.hFileInfo.ioFDirIndex = itemIndex = 1;

	while (1) {
	    pb.hFileInfo.ioFDirIndex = itemIndex;
	    pb.hFileInfo.ioDirID = dirID;
	    err = PBGetCatInfoSync(&pb);
	    if (err != noErr) {
		break;
	    }

	    /*
	     * Now check to see if the file matches.  
	     */
	     
	    Tcl_ExternalToUtfDString(NULL, (char *) fileName + 1, fileName[0],
		    &fileString);
	    if (Tcl_StringMatch(Tcl_DStringValue(&fileString), pattern)) {
		Tcl_Obj *tempName;
		Tcl_DStringSetLength(&dsOrig, baseLength);
		Tcl_DStringAppend(&dsOrig, Tcl_DStringValue(&fileString), -1);
		fname = Tcl_DStringValue(&dsOrig);
		fnameLen = Tcl_DStringLength(&dsOrig);
		
		/* 
		 * We use this tempName in calls to check the file's
		 * type below.  We may also use it for the result.
		 */
		tempName = Tcl_NewStringObj(fname, fnameLen);
		Tcl_IncrRefCount(tempName);

		/* Is the type acceptable? */
		if (NativeMatchType(tempName, types, pb.hFileInfo,
				    okType, okCreator)) {
d294 2
a295 1
			Tcl_ListObjAppendElement(interp, resultPtr, tempName);
d298 7
a304 5
		/* 
		 * This will free the object, unless it was inserted in
		 * the result list above.
		 */
		Tcl_DecrRefCount(tempName);
a305 2
	    Tcl_DStringFree(&fileString);
	    itemIndex++;
d307 4
d312 1
a312 3
	Tcl_DStringFree(&dsOrig);
	return result;
    }
d314 16
a329 8

static int 
NativeMatchType(
    Tcl_Obj *tempName,        /* Path to check */
    Tcl_GlobTypeData *types,  /* Type description to match against */
    HFileInfo fileInfo,       /* MacOS file info */
    OSType okType,            /* Acceptable MacOS type, or zero */
    OSType okCreator)         /* Acceptable MacOS creator, or zero */
d331 1
a331 83
    if (types == NULL) {
	/* If invisible, don't return the file */
	if (fileInfo.ioFlFndrInfo.fdFlags & kIsInvisible) {
	    return 0;
	}
    } else {
	Tcl_StatBuf buf;
	
	if (fileInfo.ioFlFndrInfo.fdFlags & kIsInvisible) {
	    /* If invisible */
	    if ((types->perm == 0) || 
	      !(types->perm & TCL_GLOB_PERM_HIDDEN)) {
		return 0;
	    }
	} else {
	    /* Visible */
	    if (types->perm & TCL_GLOB_PERM_HIDDEN) {
		return 0;
	    }
	}
	if (types->perm != 0) {
	    if (
		((types->perm & TCL_GLOB_PERM_RONLY) &&
			!(fileInfo.ioFlAttrib & 1)) ||
		((types->perm & TCL_GLOB_PERM_R) &&
			(TclpObjAccess(tempName, R_OK) != 0)) ||
		((types->perm & TCL_GLOB_PERM_W) &&
			(TclpObjAccess(tempName, W_OK) != 0)) ||
		((types->perm & TCL_GLOB_PERM_X) &&
			(TclpObjAccess(tempName, X_OK) != 0))
		) {
		return 0;
	    }
	}
	if (types->type != 0) {
	    if (TclpObjStat(tempName, &buf) != 0) {
		/* Posix error occurred */
		return 0;
	    }
	    /*
	     * In order bcdpfls as in 'find -t'
	     */
	    if (
		((types->type & TCL_GLOB_TYPE_BLOCK) &&
			S_ISBLK(buf.st_mode)) ||
		((types->type & TCL_GLOB_TYPE_CHAR) &&
			S_ISCHR(buf.st_mode)) ||
		((types->type & TCL_GLOB_TYPE_DIR) &&
			S_ISDIR(buf.st_mode)) ||
		((types->type & TCL_GLOB_TYPE_PIPE) &&
			S_ISFIFO(buf.st_mode)) ||
		((types->type & TCL_GLOB_TYPE_FILE) &&
			S_ISREG(buf.st_mode))
#ifdef S_ISSOCK
		|| ((types->type & TCL_GLOB_TYPE_SOCK) &&
			S_ISSOCK(buf.st_mode))
#endif
		) {
		/* Do nothing -- this file is ok */
	    } else {
		int typeOk = 0;
#ifdef S_ISLNK
		if (types->type & TCL_GLOB_TYPE_LINK) {
		    if (TclpObjLstat(tempName, &buf) == 0) {
			if (S_ISLNK(buf.st_mode)) {
			    typeOk = 1;
			}
		    }
		}
#endif
		if (typeOk == 0) {
		    return 0;
		}
	    }
	}
	if (((okType != 0) && (okType !=
			       fileInfo.ioFlFndrInfo.fdType)) ||
	    ((okCreator != 0) && (okCreator !=
				  fileInfo.ioFlFndrInfo.fdCreator))) {
	    return 0;
	}
    }
    return 1;
a332 1

d337 1
a337 1
 * TclpObjAccess --
d350 4
a353 4
int 
TclpObjAccess(pathPtr, mode)
    Tcl_Obj *pathPtr;
    int mode;
d361 2
d365 3
a367 1
    err = FspLLocationFromFsPath(pathPtr, &fileSpec);
d419 1
a419 1
		&& (fpb.ioFlFndrInfo.fdType != 'APPL')) {
d436 1
a436 1
 * TclpObjChdir --
d445 1
a445 1
 *	Tcl_FSGetCwd() is deallocated and set to NULL.
d450 3
a452 3
int 
TclpObjChdir(pathPtr)
    Tcl_Obj *pathPtr;
d458 2
d461 3
a463 1
    err = FspLocationFromFsPath(pathPtr, &spec);
d499 1
a499 1
 * TclpObjGetCwd --
d517 1
a517 16
Tcl_Obj* 
TclpObjGetCwd(interp)
    Tcl_Interp *interp;
{
    Tcl_DString ds;
    if (TclpGetCwd(interp, &ds) != NULL) {
	Tcl_Obj *cwdPtr = Tcl_NewStringObj(Tcl_DStringValue(&ds), -1);
	Tcl_IncrRefCount(cwdPtr);
	Tcl_DStringFree(&ds);
	return cwdPtr;
    } else {
	return NULL;
    }
}

CONST char *
d586 1
d588 1
a588 1
    Tcl_UtfToExternalDString(NULL, path, -1, &ds);
d594 2
a595 3
    while ((Tcl_DStringLength(&ds) != 0) 
	   && (Tcl_DStringValue(&ds)[Tcl_DStringLength(&ds) - 1] == ':')) {
	Tcl_DStringSetLength(&ds, Tcl_DStringLength(&ds) - 1);
d598 3
a600 3
    end = strrchr(Tcl_DStringValue(&ds), ':');
    if (end == NULL ) {
	strcpy(fileName + 1, Tcl_DStringValue(&ds));
d602 3
a604 2
	strcpy(fileName + 1, end + 1);
	Tcl_DStringSetLength(&ds, end + 1 - Tcl_DStringValue(&ds));
d613 2
a614 3
    if (end != NULL) {
	err = FSpLocationFromPath(Tcl_DStringLength(&ds), 
				  Tcl_DStringValue(&ds), &fileSpec);
a680 5

static int 
TclpObjStatAlias _ANSI_ARGS_((Tcl_Obj *pathPtr, Tcl_StatBuf *bufPtr, 
			      Boolean resolveLink));

d685 1
a685 1
 * TclpObjLstat --
d690 1
a690 1
 *	See lstat() documentation.
d693 1
a693 1
 *	See lstat() documentation.
d698 4
a701 4
int 
TclpObjLstat(pathPtr, buf)
    Tcl_Obj *pathPtr;
    Tcl_StatBuf *buf;
d703 5
a707 1
    return TclpObjStatAlias(pathPtr, buf, FALSE);
d713 1
a713 1
 * TclpObjStat --
d726 4
a729 11
int 
TclpObjStat(pathPtr, bufPtr)
    Tcl_Obj *pathPtr;
    Tcl_StatBuf *bufPtr;
{
    return TclpObjStatAlias(pathPtr, bufPtr, TRUE);
}


static int
TclpObjStatAlias (Tcl_Obj *pathPtr, Tcl_StatBuf *bufPtr, Boolean resolveLink)
d737 1
d739 3
a741 4
    if (resolveLink)
    	err = FspLocationFromFsPath(pathPtr, &fileSpec);
    else
    	err = FspLLocationFromFsPath(pathPtr, &fileSpec);
d788 5
a792 5
		/*
		 * Directories and applications are executable by everyone.
		 */
		 
		bufPtr->st_mode |= S_IXUSR | S_IXGRP | S_IXOTH;
d795 5
a799 5
		/* 
		 * If not locked, then everyone has write acces.
		 */
		 
		bufPtr->st_mode |= S_IWUSR | S_IWGRP | S_IWOTH;
d814 1
a814 1
	     * epoch starts from GMT.  This is also consistent with
d818 15
a832 4
	    bufPtr->st_atime = bufPtr->st_mtime = fpb.ioFlMdDat 
	      - TclpGetGMTOffset() + tcl_mac_epoch_offset;
	    bufPtr->st_ctime = fpb.ioFlCrDat - TclpGetGMTOffset() 
	      + tcl_mac_epoch_offset;
d897 1
a897 1
    err = FSpLocationFromPath(strlen(path), path, &fileSpec);
a996 1

d999 1
a999 1
    CONST char *path, 
d1004 3
a1006 4
    Str255 pathName;
    strcpy((char *) pathName + 1, path);
    pathName[0] = strlen(path);
    hpb.fileParam.ioNamePtr = pathName;
d1015 1
a1022 125
}


/*
 *----------------------------------------------------------------------
 *
 * TclpTempFileName --
 *
 *	This function returns a unique filename.
 *
 * Results:
 *	Returns a valid Tcl_Obj* with refCount 0, or NULL on failure.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_Obj* 
TclpTempFileName()
{
    char fileName[L_tmpnam];
    
    if (tmpnam(fileName) == NULL) {	       /* INTL: Native. */
	return NULL;
    }

    return TclpNativeToNormalized((ClientData) fileName);
}

#ifdef S_IFLNK

Tcl_Obj* 
TclpObjLink(pathPtr, toPtr, linkAction)
    Tcl_Obj *pathPtr;
    Tcl_Obj *toPtr;
    int linkAction;
{
    Tcl_Obj* link = NULL;

    if (toPtr != NULL) {
	if (TclpObjAccess(pathPtr, F_OK) != -1) {
	    /* src exists */
	    errno = EEXIST;
	    return NULL;
	}
	if (TclpObjAccess(toPtr, F_OK) == -1) {
	    /* target doesn't exist */
	    errno = ENOENT;
	    return NULL;
	}

	if (linkAction & TCL_CREATE_SYMBOLIC_LINK) {
	    /* Needs to create a new link */
	    FSSpec spec;
	    FSSpec linkSpec;
	    OSErr err;
	    CONST char *path;
	    AliasHandle alias;
	    
	    err = FspLocationFromFsPath(toPtr, &spec);
	    if (err != noErr) {
		errno = ENOENT;
		return NULL;
	    }

	    path = Tcl_FSGetNativePath(pathPtr);
	    err = FSpLocationFromPath(strlen(path), path, &linkSpec);
	    if (err == noErr) {
		err = dupFNErr;		/* EEXIST. */
	    } else {
		err = NewAlias(&spec, &linkSpec, &alias);
	    }
	    if (err != noErr) {
		errno = TclMacOSErrorToPosixError(err);
		return NULL;
	    }
	    return toPtr;
	} else {
	    errno = ENODEV;
	    return NULL;
	}
    } else {
	Tcl_DString ds;
	Tcl_Obj *transPtr = Tcl_FSGetTranslatedPath(NULL, pathPtr);
	if (transPtr == NULL) {
	    return NULL;
	}
	if (TclpReadlink(Tcl_GetString(transPtr), &ds) != NULL) {
	    link = Tcl_NewStringObj(Tcl_DStringValue(&ds), -1);
	    Tcl_IncrRefCount(link);
	    Tcl_DStringFree(&ds);
	}
    }
    return link;
}

#endif


/*
 *---------------------------------------------------------------------------
 *
 * TclpFilesystemPathType --
 *
 *      This function is part of the native filesystem support, and
 *      returns the path type of the given path.  Right now it simply
 *      returns NULL.  In the future it could return specific path
 *      types, like 'HFS', 'HFS+', 'nfs', 'samba', 'FAT32', etc.
 *
 * Results:
 *      NULL at present.
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
 */
Tcl_Obj*
TclpFilesystemPathType(pathObjPtr)
    Tcl_Obj* pathObjPtr;
{
    /* All native paths are of the same type */
    return NULL;
@


1.1
log
@Initial revision
@
text
@d8 1
a8 1
 * Copyright (c) 1995-1997 Sun Microsystems, Inc.
d13 1
a13 1
 * RCS: @@(#) $Id: tclMacFile.c,v 1.7 1999/01/26 03:53:23 jingham Exp $
d37 1
a37 1
static int initalized = false;
d39 1
a40 79
/*
 * The variable below caches the name of the current working directory
 * in order to avoid repeated calls to getcwd.  The string is malloc-ed.
 * NULL means the cache needs to be refreshed.
 */

static char *currentDir =  NULL;

/*
 *----------------------------------------------------------------------
 *
 * TclChdir --
 *
 *	Change the current working directory.
 *
 * Results:
 *	The result is a standard Tcl result.  If an error occurs and 
 *	interp isn't NULL, an error message is left in interp->result.
 *
 * Side effects:
 *	The working directory for this application is changed.  Also
 *	the cache maintained used by TclGetCwd is deallocated and
 *	set to NULL.
 *
 *----------------------------------------------------------------------
 */

int
TclChdir(
    Tcl_Interp *interp,		/* If non NULL, used for error reporting. */
    char *dirName)		/* Path to new working directory. */
{
    FSSpec spec;
    OSErr err;
    Boolean isFolder;
    long dirID;

    if (currentDir != NULL) {
	ckfree(currentDir);
	currentDir = NULL;
    }

    err = FSpLocationFromPath(strlen(dirName), dirName, &spec);
    if (err != noErr) {
	errno = ENOENT;
	goto chdirError;
    }
    
    err = FSpGetDirectoryID(&spec, &dirID, &isFolder);
    if (err != noErr) {
	errno = ENOENT;
	goto chdirError;
    }

    if (isFolder != true) {
	errno = ENOTDIR;
	goto chdirError;
    }

    err = FSpSetDefaultDir(&spec);
    if (err != noErr) {
	switch (err) {
	    case afpAccessDenied:
		errno = EACCES;
		break;
	    default:
		errno = ENOENT;
	}
	goto chdirError;
    }

    return TCL_OK;
    chdirError:
    if (interp != NULL) {
	Tcl_AppendResult(interp, "couldn't change working directory to \"",
		dirName, "\": ", Tcl_PosixError(interp), (char *) NULL);
    }
    return TCL_ERROR;
}
d45 1
a45 77
 * TclGetCwd --
 *
 *	Return the path name of the current working directory.
 *
 * Results:
 *	The result is the full path name of the current working
 *	directory, or NULL if an error occurred while figuring it
 *	out.  If an error occurs and interp isn't NULL, an error
 *	message is left in interp->result.
 *
 * Side effects:
 *	The path name is cached to avoid having to recompute it
 *	on future calls;  if it is already cached, the cached
 *	value is returned.
 *
 *----------------------------------------------------------------------
 */

char *
TclGetCwd(
    Tcl_Interp *interp)		/* If non NULL, used for error reporting. */
{
    FSSpec theSpec;
    int length;
    Handle pathHandle = NULL;
    
    if (currentDir == NULL) {
	if (FSpGetDefaultDir(&theSpec) != noErr) {
	    if (interp != NULL) {
		interp->result = "error getting working directory name";
	    }
	    return NULL;
	}
	if (FSpPathFromLocation(&theSpec, &length, &pathHandle) != noErr) {
	    if (interp != NULL) {
		interp->result = "error getting working directory name";
	    }
	    return NULL;
	}
	HLock(pathHandle);
	currentDir = (char *) ckalloc((unsigned) (length + 1));
	strcpy(currentDir, *pathHandle);
	HUnlock(pathHandle);
	DisposeHandle(pathHandle);	
    }
    return currentDir;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_WaitPid --
 *
 *	Fakes a call to wait pid.
 *
 * Results:
 *	Always returns -1.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_Pid
Tcl_WaitPid(
    Tcl_Pid pid,
    int *statPtr,
    int options)
{
    return (Tcl_Pid) -1;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_FindExecutable --
d49 1
a49 1
 *	implementation doesn't use of need the argv[0] value.  NULL
d63 3
a65 3
void
Tcl_FindExecutable(
    char *argv0)		/* The value of the application's argv[0]. */
d74 3
a89 2

    tclExecutableName = (char *) ckalloc((unsigned) pathLength + 1);
d91 1
a91 1
    strcpy(tclExecutableName, *pathName);
a93 18
}

/*
 *----------------------------------------------------------------------
 *
 * TclGetUserHome --
 *
 *	This function takes the passed in user name and finds the
 *	corresponding home directory specified in the password file.
 *
 * Results:
 *	On a Macintosh we always return a NULL.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
d95 5
a99 8
char *
TclGetUserHome(
    char *name,			/* User name to use to find home directory. */
    Tcl_DString *bufferPtr)	/* May be used to hold result.  Must not hold
				 * anything at the time of the call, and need
				 * not even be initialized. */
{
    return NULL;
d105 1
a105 1
 * TclMatchFiles --
d112 1
a112 1
 *	added to the interp->result.  Otherwise, TclDoGlob is called
d123 1
a123 1
TclMatchFiles(
d128 5
a132 2
    char *tail)			/* Pointer to end of pattern.  Tail must
				 * point to a location in pattern. */
d134 1
a134 1
    char *dirName, *patternEnd = tail;
d136 1
a136 1
    int result = TCL_OK;
d145 4
a148 1
    
d155 6
a160 2
    dirName = dirPtr->string;
    FSpLocationFromPath(strlen(dirName), dirName, &dirSpec);
d174 1
a174 1
    
d193 10
d217 4
a220 3

	p2cstr(fileName);
	if (Tcl_StringMatch((char *) fileName, pattern)) {
d222 3
a224 1
	    Tcl_DStringAppend(dirPtr, (char *) fileName, -1);
d226 71
a296 5
		if ((dirPtr->length > 1) &&
			(strchr(dirPtr->string+1, ':') == NULL)) {
		    Tcl_AppendElement(interp, dirPtr->string+1);
		} else {
		    Tcl_AppendElement(interp, dirPtr->string);
d300 1
a300 1
		result = TclDoGlob(interp, separators, dirPtr, tail);
d302 1
d307 1
a307 1
	
d315 19
d337 1
a337 1
 * TclpStat --
d339 1
a339 3
 *	This function replaces the library version of stat.  The stat
 *	function provided by most Mac compiliers is rather broken and
 *	incomplete.
d342 1
a342 1
 *	See stat documentation.
d345 1
a345 1
 *	See stat documentation.
d351 3
a353 3
TclpStat(
    CONST char *path,
    struct stat *buf)
d361 8
a368 2
    
    err = FSpLocationFromPath(strlen(path), path, &fileSpec);
a376 1
     
d391 1
a391 1
	if (err == noErr && buf != NULL) {
d393 4
a396 1
	     * Files are always readable by everyone.
a397 2
	     
	    buf->st_mode = S_IRUSR | S_IRGRP | S_IROTH;
d399 3
a401 2
	    /* 
	     * Use the Volume Info & File Info to fill out stat buf.
d403 8
a410 9
	    if (fpb.ioFlAttrib & 0x10) {
		buf->st_mode |= S_IFDIR;
		buf->st_nlink = 2;
	    } else {
		buf->st_nlink = 1;
		if (fpb.ioFlFndrInfo.fdFlags & 0x8000) {
		    buf->st_mode |= S_IFLNK;
		} else {
		    buf->st_mode |= S_IFREG;
d413 1
a413 24
	    if ((fpb.ioFlAttrib & 0x10) || (fpb.ioFlFndrInfo.fdType == 'APPL')) {
	    	/*
	    	 * Directories and applications are executable by everyone.
	    	 */
	    	 
	    	buf->st_mode |= S_IXUSR | S_IXGRP | S_IXOTH;
	    }
	    if ((fpb.ioFlAttrib & 0x01) == 0){
	    	/* 
	    	 * If not locked, then everyone has write acces.
	    	 */
	    	 
	        buf->st_mode |= S_IWUSR | S_IWGRP | S_IWOTH;
	    }
	    buf->st_ino = fpb.ioDirID;
	    buf->st_dev = fpb.ioVRefNum;
	    buf->st_uid = -1;
	    buf->st_gid = -1;
	    buf->st_rdev = 0;
	    buf->st_size = fpb.ioFlLgLen;
	    buf->st_blksize = vpb.ioVAlBlkSiz;
	    buf->st_blocks = (buf->st_size + buf->st_blksize - 1)
		/ buf->st_blksize;

d415 2
a416 4
	     * The times returned by the Mac file system are in the
	     * local time zone.  We convert them to GMT so that the
	     * epoch starts from GMT.  This is also consistant with
	     * what is returned from "clock seconds".
d418 3
a420 9
	    if (initalized == false) {
		MachineLocation loc;
    
		ReadLocation(&loc);
		gmt_offset = loc.u.gmtDelta & 0x00ffffff;
		if (gmt_offset & 0x00800000) {
		    gmt_offset = gmt_offset | 0xff000000;
		}
		initalized = true;
a421 3
	    buf->st_atime = buf->st_mtime = fpb.ioFlMdDat - gmt_offset;
	    buf->st_ctime = fpb.ioFlCrDat - gmt_offset;

d427 1
d430 64
a493 1
    return (err == noErr ? 0 : -1);
d499 1
a499 1
 * TclMacReadlink --
d501 1
a501 1
 *	This function replaces the library version of readlink.
d504 6
a509 1
 *	See readlink documentation.
d517 57
a573 5
int
TclMacReadlink(
    char *path,
    char *buf,
    int size)
d581 1
a581 1
    char fileName[256];
d585 4
d593 3
a595 2
    while ((strlen(path) != 0) && (path[strlen(path) - 1] == ':')) {
	path[strlen(path) - 1] = NULL;
d598 3
a600 3
    if (strchr(path, ':') == NULL) {
	strcpy(fileName, path);
	path = NULL;
d602 2
a603 2
	end = strrchr(path, ':') + 1;
	strcpy(fileName, end);
d606 1
a606 1
    c2pstr(fileName);
d612 3
a614 2
    if (path != NULL) {
	err = FSpLocationFromPath(strlen(path), path, &fileSpec);
d616 1
d618 1
a618 1
	    return -1;
d623 1
d628 1
d638 1
a638 1
	return -1;
d642 1
a642 1
	    return -1;
d650 1
a650 1
		return -1;
d659 2
a660 1
    err = FSMakeFSSpecCompat(fileSpec.vRefNum, dirID, (StringPtr) fileName, &fileSpec);
d666 1
a666 1
	if ((err != noErr) || (pathSize > size)) {
d669 1
a669 1
	    return -1;
d673 1
a673 1
	return -1;
d675 2
a676 2

    strncpy(buf, *theString, pathSize);
d679 1
a679 1
    return pathSize;
d685 29
a713 1
 * TclpAccess --
d715 1
a715 3
 *	This function replaces the library version of access.  The
 *	access function provided by most Mac compiliers is rather 
 *	broken or incomplete.
d718 1
a718 1
 *	See access documentation.
d721 1
a721 1
 *	See access documentation.
d727 3
a729 3
TclpAccess(
    const char *path,
    int mode)
d737 6
a742 3
    int full_mode = 0;

    err = FSpLocationFromPath(strlen(path), (char *) path, &fileSpec);
d751 1
d766 1
a766 1
	if (err == noErr) {
d768 1
a768 4
	     * Use the Volume Info & File Info to determine
	     * access information.  If we have got this far
	     * we know the directory is searchable or the file
	     * exists.  (We have F_OK)
d770 2
d773 2
a774 3
	    /*
	     * Check to see if the volume is hardware or
	     * software locked.  If so we arn't W_OK.
d776 9
a784 8
	    if (mode & W_OK) {
		if ((vpb.ioVAtrb & 0x0080) || (vpb.ioVAtrb & 0x8000)) {
		    errno = EROFS;
		    return -1;
		}
		if (fpb.ioFlAttrib & 0x01) {
		    errno = EACCES;
		    return -1;
d787 24
a810 1
	    
d812 4
a815 2
	     * Directories are always searchable and executable.  But only 
	     * files of type 'APPL' are executable.
d817 11
a827 3
	    if (!(fpb.ioFlAttrib & 0x10) && (mode & X_OK)
	    	&& (fpb.ioFlFndrInfo.fdType != 'APPL')) {
		return -1;
d829 4
a837 1
	return -1;
d840 26
a865 1
    return 0;
d888 2
a889 2
    const char *path,
    const char *mode)
d914 30
d996 27
@


1.1.1.1
log
@import dejagnu-1999-11-08 snapshot
@
text
@@


1.1.1.2
log
@Tcl 8.3 upgrade
@
text
@d8 1
a8 1
 * Copyright (c) 1995-1998 Sun Microsystems, Inc.
d13 1
a13 1
 * RCS: @@(#) $Id: tclMacFile.c,v 1.6.8.1 2000/04/06 22:38:30 spolk Exp $
d37 1
a37 1
static int initialized = false;
a38 1
TCL_DECLARE_MUTEX(gmtMutex)
d40 79
d123 77
a199 1
 * TclpFindExecutable --
d203 1
a203 1
 *	implementation doesn't need the argv[0] value.  NULL
d217 3
a219 3
char *
TclpFindExecutable(
    CONST char *argv0)		/* The value of the application's argv[0]. */
a227 3
    Tcl_DString ds;
    
    TclInitSubsystems(argv0);
d241 2
d244 1
a244 1
    Tcl_ExternalToUtfDString(NULL, *pathName, pathLength, &ds);
d247 18
d266 8
a273 5
    tclExecutableName = (char *) ckalloc((unsigned) 
    	    (Tcl_DStringLength(&ds) + 1));
    strcpy(tclExecutableName, Tcl_DStringValue(&ds));
    Tcl_DStringFree(&ds);
    return tclExecutableName;
d279 1
a279 1
 * TclpMatchFilesTypes --
d286 1
a286 1
 *	added to the the interp's result.  Otherwise, TclDoGlob is called
d297 1
a297 1
TclpMatchFilesTypes(
d302 2
a303 5
    char *tail,			/* Pointer to end of pattern.  Tail must
				 * point to a location in pattern and must
				 * not be static.*/
    GlobTypeData *types)	/* Object containing list of acceptable types.
				 * May be NULL. */
d305 1
a305 1
    char *fname, *patternEnd = tail;
d307 1
a307 1
    int fnameLen, result = TCL_OK;
d316 1
a316 4
    Tcl_DString fileString;    
    Tcl_Obj *resultPtr;
    OSType okType = 0;
    OSType okCreator = 0;
d323 2
a324 6
    Tcl_UtfToExternalDString(NULL, Tcl_DStringValue(dirPtr),
	    Tcl_DStringLength(dirPtr), &fileString);

    FSpLocationFromPath(fileString.length, fileString.string, &dirSpec);
    Tcl_DStringFree(&fileString);

d338 1
a338 1

a356 10
    resultPtr = Tcl_GetObjResult(interp);
    if (types != NULL) {
	if (types->macType != NULL) {
	    Tcl_GetOSTypeFromObj(NULL, types->macType, &okType);
	}
	if (types->macCreator != NULL) {
	    Tcl_GetOSTypeFromObj(NULL, types->macCreator, &okCreator);
	}
    }

d371 3
a373 4
	 
	Tcl_ExternalToUtfDString(NULL, (char *) fileName + 1, fileName[0],
		&fileString);
	if (Tcl_StringMatch(Tcl_DStringValue(&fileString), pattern)) {
d375 1
a375 3
	    Tcl_DStringAppend(dirPtr, Tcl_DStringValue(&fileString), -1);
	    fname = Tcl_DStringValue(dirPtr);
	    fnameLen = Tcl_DStringLength(dirPtr);
d377 5
a381 71
		int typeOk = 1;
		if (types != NULL) {
		    if (types->perm != 0) {
			if (
			    ((types->perm & TCL_GLOB_PERM_RONLY) &&
				    !(pb.hFileInfo.ioFlAttrib & 1)) ||
			    ((types->perm & TCL_GLOB_PERM_HIDDEN) &&
				    !(pb.hFileInfo.ioFlFndrInfo.fdFlags &
					    kIsInvisible)) ||
			    ((types->perm & TCL_GLOB_PERM_R) &&
				    (TclpAccess(fname, R_OK) != 0)) ||
			    ((types->perm & TCL_GLOB_PERM_W) &&
				    (TclpAccess(fname, W_OK) != 0)) ||
			    ((types->perm & TCL_GLOB_PERM_X) &&
				    (TclpAccess(fname, X_OK) != 0))
			    ) {
			    typeOk = 0;
			}
		    }
		    if (typeOk == 1 && types->type != 0) {
			struct stat buf;
			/*
			 * We must match at least one flag to be listed
			 */
			typeOk = 0;
			if (TclpLstat(fname, &buf) >= 0) {
			    /*
			     * In order bcdpfls as in 'find -t'
			     */
			    if (
				((types->type & TCL_GLOB_TYPE_BLOCK) &&
					S_ISBLK(buf.st_mode)) ||
				((types->type & TCL_GLOB_TYPE_CHAR) &&
					S_ISCHR(buf.st_mode)) ||
				((types->type & TCL_GLOB_TYPE_DIR) &&
					S_ISDIR(buf.st_mode)) ||
				((types->type & TCL_GLOB_TYPE_PIPE) &&
					S_ISFIFO(buf.st_mode)) ||
				((types->type & TCL_GLOB_TYPE_FILE) &&
					S_ISREG(buf.st_mode))
#ifdef S_ISLNK
				|| ((types->type & TCL_GLOB_TYPE_LINK) &&
					S_ISLNK(buf.st_mode))
#endif
#ifdef S_ISSOCK
				|| ((types->type & TCL_GLOB_TYPE_SOCK) &&
					S_ISSOCK(buf.st_mode))
#endif
				) {
				typeOk = 1;
			    }
			} else {
			    /* Posix error occurred */
			}
		    }
		    if (typeOk && (
			((okType != 0) && (okType !=
				pb.hFileInfo.ioFlFndrInfo.fdType)) ||
			((okCreator != 0) && (okCreator !=
				pb.hFileInfo.ioFlFndrInfo.fdCreator)))) {
			typeOk = 0;
		    }
		} 
		if (typeOk) {
		    if ((fnameLen > 1) && (strchr(fname+1, ':') == NULL)) {
			Tcl_ListObjAppendElement(interp, resultPtr, 
				Tcl_NewStringObj(fname+1, fnameLen-1));
		    } else {
			Tcl_ListObjAppendElement(interp, resultPtr, 
				Tcl_NewStringObj(fname, fnameLen));
		    }
d385 1
a385 1
		result = TclDoGlob(interp, separators, dirPtr, tail, types);
a386 1
		    Tcl_DStringFree(&fileString);
d391 1
a391 1
	Tcl_DStringFree(&fileString);
a398 19
/* 
 * TclpMatchFiles --
 * 
 * This function is now obsolete.  Call the above function 
 * 'TclpMatchFilesTypes' instead.
 */
int
TclpMatchFiles(
    Tcl_Interp *interp,		/* Interpreter to receive results. */
    char *separators,		/* Directory separators to pass to TclDoGlob. */
    Tcl_DString *dirPtr,	/* Contains path to directory to search. */
    char *pattern,		/* Pattern to match against. */
    char *tail)			/* Pointer to end of pattern.  Tail must
				 * point to a location in pattern and must
				 * not be static.*/
{
    return TclpMatchFilesTypes(interp,separators,dirPtr,pattern,tail,NULL);
}

d402 1
a402 1
 * TclpAccess --
d404 3
a406 1
 *	This function replaces the library version of access().
d409 1
a409 1
 *	See access documentation.
d412 1
a412 1
 *	See access documentation.
d418 3
a420 3
TclpAccess(
    CONST char *path,		/* Path of file to access (UTF-8). */
    int mode)			/* Permission setting. */
d428 2
a429 8
    Tcl_DString ds;
    char *native;
    int full_mode = 0;

    native = Tcl_UtfToExternalDString(NULL, path, -1, &ds);
    err = FSpLocationFromPath(Tcl_DStringLength(&ds), native, &fileSpec);
    Tcl_DStringFree(&ds);

d438 1
d453 1
a453 1
	if (err == noErr) {
d455 1
a455 4
	     * Use the Volume Info & File Info to determine
	     * access information.  If we have got this far
	     * we know the directory is searchable or the file
	     * exists.  (We have F_OK)
d457 2
d460 2
a461 3
	    /*
	     * Check to see if the volume is hardware or
	     * software locked.  If so we arn't W_OK.
d463 9
a471 8
	    if (mode & W_OK) {
		if ((vpb.ioVAtrb & 0x0080) || (vpb.ioVAtrb & 0x8000)) {
		    errno = EROFS;
		    return -1;
		}
		if (fpb.ioFlAttrib & 0x01) {
		    errno = EACCES;
		    return -1;
d474 24
a497 1
	    
d499 4
a502 2
	     * Directories are always searchable and executable.  But only 
	     * files of type 'APPL' are executable.
d504 9
a512 3
	    if (!(fpb.ioFlAttrib & 0x10) && (mode & X_OK)
	    	&& (fpb.ioFlFndrInfo.fdType != 'APPL')) {
		return -1;
d514 3
a521 1
	return -1;
d524 1
a524 1
    return 0;
d530 1
a530 1
 * TclpChdir --
d532 1
a532 1
 *	This function replaces the library version of chdir().
d535 1
a535 1
 *	See chdir() documentation.
d538 1
a538 2
 *	See chdir() documentation.  Also the cache maintained used by 
 *	TclGetCwd() is deallocated and set to NULL.
d544 4
a547 123
TclpChdir(
    CONST char *dirName)     	/* Path to new working directory (UTF-8). */
{
    FSSpec spec;
    OSErr err;
    Boolean isFolder;
    long dirID;
    Tcl_DString ds;
    char *native;

    native = Tcl_UtfToExternalDString(NULL, dirName, -1, &ds);
    err = FSpLocationFromPath(Tcl_DStringLength(&ds), native, &spec);
    Tcl_DStringFree(&ds);

    if (err != noErr) {
	errno = ENOENT;
	return -1;
    }
    
    err = FSpGetDirectoryID(&spec, &dirID, &isFolder);
    if (err != noErr) {
	errno = ENOENT;
	return -1;
    }

    if (isFolder != true) {
	errno = ENOTDIR;
	return -1;
    }

    err = FSpSetDefaultDir(&spec);
    if (err != noErr) {
	switch (err) {
	    case afpAccessDenied:
		errno = EACCES;
		break;
	    default:
		errno = ENOENT;
	}
	return -1;
    }

    return 0;
}

/*
 *----------------------------------------------------------------------
 *
 * TclpGetCwd --
 *
 *	This function replaces the library version of getcwd().
 *
 * Results:
 *	The result is a pointer to a string specifying the current
 *	directory, or NULL if the current directory could not be
 *	determined.  If NULL is returned, an error message is left in the
 *	interp's result.  Storage for the result string is allocated in
 *	bufferPtr; the caller must call Tcl_DStringFree() when the result
 *	is no longer needed.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

char *
TclpGetCwd(
    Tcl_Interp *interp,		/* If non-NULL, used for error reporting. */
    Tcl_DString *bufferPtr)	/* Uninitialized or free DString filled
				 * with name of current directory. */
{
    FSSpec theSpec;
    int length;
    Handle pathHandle = NULL;
    
    if (FSpGetDefaultDir(&theSpec) != noErr) {
 	if (interp != NULL) {
	    Tcl_SetResult(interp, "error getting working directory name",
		    TCL_STATIC);
	}
	return NULL;
    }
    if (FSpPathFromLocation(&theSpec, &length, &pathHandle) != noErr) {
 	if (interp != NULL) {
	     Tcl_SetResult(interp, "error getting working directory name",
		    TCL_STATIC);
	}
	return NULL;
    }
    HLock(pathHandle);
    Tcl_ExternalToUtfDString(NULL, *pathHandle, length, bufferPtr);
    HUnlock(pathHandle);
    DisposeHandle(pathHandle);	

    return Tcl_DStringValue(bufferPtr);
}

/*
 *----------------------------------------------------------------------
 *
 * TclpReadlink --
 *
 *	This function replaces the library version of readlink().
 *
 * Results:
 *	The result is a pointer to a string specifying the contents
 *	of the symbolic link given by 'path', or NULL if the symbolic
 *	link could not be read.  Storage for the result string is
 *	allocated in bufferPtr; the caller must call Tcl_DStringFree()
 *	when the result is no longer needed.
 *
 * Side effects:
 *	See readlink() documentation.
 *
 *---------------------------------------------------------------------------
 */

char *
TclpReadlink(
    CONST char *path,		/* Path of file to readlink (UTF-8). */
    Tcl_DString *linkPtr)	/* Uninitialized or free DString filled
				 * with contents of link (UTF-8). */
d555 1
a555 1
    char fileName[257];
a558 4
    Tcl_DString ds;
    char *native;
    
    native = Tcl_UtfToExternalDString(NULL, path, -1, &ds);
d563 2
a564 3
     
    while ((strlen(native) != 0) && (path[strlen(native) - 1] == ':')) {
	native[strlen(native) - 1] = NULL;
d567 3
a569 3
    if (strchr(native, ':') == NULL) {
	strcpy(fileName + 1, native);
	native = NULL;
d571 2
a572 2
	end = strrchr(native, ':') + 1;
	strcpy(fileName + 1, end);
d575 1
a575 1
    fileName[0] = (char) strlen(fileName + 1);
d581 2
a582 3

    if (native != NULL) {
	err = FSpLocationFromPath(strlen(native), native, &fileSpec);
a583 1
	    Tcl_DStringFree(&ds);
d585 1
a585 1
	    return NULL;
a589 1
    Tcl_DStringFree(&ds);
a593 1

d603 1
a603 1
	return NULL;
d607 1
a607 1
	    return NULL;
d615 1
a615 1
		return NULL;
d624 1
a624 2
    err = FSMakeFSSpecCompat(fileSpec.vRefNum, dirID, (StringPtr) fileName, 
    	    &fileSpec);
d630 1
a630 1
	if (err != noErr) {
d633 1
a633 1
	    return NULL;
d637 1
a637 1
	return NULL;
d639 2
a640 2
    
    Tcl_ExternalToUtfDString(NULL, *theString, pathSize, linkPtr);
d643 1
a643 1
    return Tcl_DStringValue(linkPtr);
d649 1
a649 1
 * TclpLstat --
d651 3
a653 1
 *	This function replaces the library version of lstat().
d656 1
a656 1
 *	See stat() documentation.
d659 1
a659 1
 *	See stat() documentation.
d665 3
a667 31
TclpLstat(
    CONST char *path,		/* Path of file to stat (in UTF-8). */
    struct stat *bufPtr)	/* Filled with results of stat call. */
{
    /*
     * FIXME: Emulate TclpLstat
     */
     
    return TclpStat(path, bufPtr);
}

/*
 *----------------------------------------------------------------------
 *
 * TclpStat --
 *
 *	This function replaces the library version of stat().
 *
 * Results:
 *	See stat() documentation.
 *
 * Side effects:
 *	See stat() documentation.
 *
 *----------------------------------------------------------------------
 */

int
TclpStat(
    CONST char *path,		/* Path of file to stat (in UTF-8). */
    struct stat *bufPtr)	/* Filled with results of stat call. */
d675 3
a677 6
    Tcl_DString ds;
    
    path = Tcl_UtfToExternalDString(NULL, path, -1, &ds);
    err = FSpLocationFromPath(Tcl_DStringLength(&ds), path, &fileSpec);
    Tcl_DStringFree(&ds);
    
a685 1
     
d700 1
a700 1
	if (err == noErr && bufPtr != NULL) {
d702 4
a705 1
	     * Files are always readable by everyone.
a706 2
	     
	    bufPtr->st_mode = S_IRUSR | S_IRGRP | S_IROTH;
d708 3
a710 2
	    /* 
	     * Use the Volume Info & File Info to fill out stat buf.
d712 8
a719 9
	    if (fpb.ioFlAttrib & 0x10) {
		bufPtr->st_mode |= S_IFDIR;
		bufPtr->st_nlink = 2;
	    } else {
		bufPtr->st_nlink = 1;
		if (fpb.ioFlFndrInfo.fdFlags & 0x8000) {
		    bufPtr->st_mode |= S_IFLNK;
		} else {
		    bufPtr->st_mode |= S_IFREG;
d722 1
a722 24
	    if ((fpb.ioFlAttrib & 0x10) || (fpb.ioFlFndrInfo.fdType == 'APPL')) {
	    	/*
	    	 * Directories and applications are executable by everyone.
	    	 */
	    	 
	    	bufPtr->st_mode |= S_IXUSR | S_IXGRP | S_IXOTH;
	    }
	    if ((fpb.ioFlAttrib & 0x01) == 0){
	    	/* 
	    	 * If not locked, then everyone has write acces.
	    	 */
	    	 
	        bufPtr->st_mode |= S_IWUSR | S_IWGRP | S_IWOTH;
	    }
	    bufPtr->st_ino = fpb.ioDirID;
	    bufPtr->st_dev = fpb.ioVRefNum;
	    bufPtr->st_uid = -1;
	    bufPtr->st_gid = -1;
	    bufPtr->st_rdev = 0;
	    bufPtr->st_size = fpb.ioFlLgLen;
	    bufPtr->st_blksize = vpb.ioVAlBlkSiz;
	    bufPtr->st_blocks = (bufPtr->st_size + bufPtr->st_blksize - 1)
		/ bufPtr->st_blksize;

d724 2
a725 4
	     * The times returned by the Mac file system are in the
	     * local time zone.  We convert them to GMT so that the
	     * epoch starts from GMT.  This is also consistant with
	     * what is returned from "clock seconds".
d727 3
a729 11

	    Tcl_MutexLock(&gmtMutex);
	    if (initialized == false) {
		MachineLocation loc;
    
		ReadLocation(&loc);
		gmt_offset = loc.u.gmtDelta & 0x00ffffff;
		if (gmt_offset & 0x00800000) {
		    gmt_offset = gmt_offset | 0xff000000;
		}
		initialized = true;
a730 4
	    Tcl_MutexUnlock(&gmtMutex);

	    bufPtr->st_atime = bufPtr->st_mtime = fpb.ioFlMdDat - gmt_offset;
	    bufPtr->st_ctime = fpb.ioFlCrDat - gmt_offset;
d736 1
d739 1
a739 26
    return (err == noErr ? 0 : -1);
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_WaitPid --
 *
 *	Fakes a call to wait pid.
 *
 * Results:
 *	Always returns -1.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_Pid
Tcl_WaitPid(
    Tcl_Pid pid,
    int *statPtr,
    int options)
{
    return (Tcl_Pid) -1;
d762 2
a763 2
    CONST char *path,
    CONST char *mode)
a787 30
 *---------------------------------------------------------------------------
 *
 * TclpGetUserHome --
 *
 *	This function takes the specified user name and finds their
 *	home directory.
 *
 * Results:
 *	The result is a pointer to a string specifying the user's home
 *	directory, or NULL if the user's home directory could not be
 *	determined.  Storage for the result string is allocated in
 *	bufferPtr; the caller must call Tcl_DStringFree() when the result
 *	is no longer needed.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

char *
TclpGetUserHome(name, bufferPtr)
    CONST char *name;		/* User name for desired home directory. */
    Tcl_DString *bufferPtr;	/* Uninitialized or free DString filled
				 * with name of user's home directory. */
{
    return NULL;
}

/*
a839 27
}
int
TclMacChmod(
    char *path, 
    int mode)
{
    HParamBlockRec hpb;
    OSErr err;
    
    c2pstr(path);
    hpb.fileParam.ioNamePtr = (unsigned char *) path;
    hpb.fileParam.ioVRefNum = 0;
    hpb.fileParam.ioDirID = 0;
    
    if (mode & 0200) {
        err = PBHRstFLockSync(&hpb);
    } else {
        err = PBHSetFLockSync(&hpb);
    }
    p2cstr((unsigned char *) path);
    
    if (err != noErr) {
        errno = TclMacOSErrorToPosixError(err);
        return -1;
    }
    
    return 0;
@


1.1.1.3
log
@import tcl 8.4.0
@
text
@d13 1
a13 1
 * RCS: @@(#) $Id: tclMacFile.c,v 1.24 2002/07/15 10:28:18 vincentdarley Exp $
d34 6
a39 24
static int NativeMatchType(Tcl_Obj *tempName, Tcl_GlobTypeData *types, 
			   HFileInfo fileInfo, OSType okType, OSType okCreator);
static OSErr FspLocationFromFsPath _ANSI_ARGS_((Tcl_Obj *pathPtr, 
						FSSpec* specPtr));
static OSErr FspLLocationFromFsPath _ANSI_ARGS_((Tcl_Obj *pathPtr, 
						FSSpec* specPtr));

static OSErr 
FspLocationFromFsPath(pathPtr, specPtr)
    Tcl_Obj *pathPtr;
    FSSpec* specPtr;
{
    CONST char *native = Tcl_FSGetNativePath(pathPtr);
    return FSpLocationFromPath(strlen(native), native, specPtr);
}

static OSErr 
FspLLocationFromFsPath(pathPtr, specPtr)
    Tcl_Obj *pathPtr;
    FSSpec* specPtr;
{
    CONST char *native = Tcl_FSGetNativePath(pathPtr);
    return FSpLLocationFromPath(strlen(native), native, specPtr);
}
d105 1
a105 1
 * TclpMatchInDirectory --
d111 5
a115 4
 *	
 *	The return value is a standard Tcl result indicating whether an
 *	error occurred in globbing.  Errors are left in interp, good
 *	results are lappended to resultPtr (which must be a valid object)
d123 24
a146 11
TclpMatchInDirectory(interp, resultPtr, pathPtr, pattern, types)
    Tcl_Interp *interp;		/* Interpreter to receive errors. */
    Tcl_Obj *resultPtr;		/* List object to lappend results. */
    Tcl_Obj *pathPtr;	        /* Contains path to directory to search. */
    CONST char *pattern;	/* Pattern to match against.  NULL or empty
                        	 * means pathPtr is actually a single file
                        	 * to check. */
    Tcl_GlobTypeData *types;	/* Object containing list of acceptable types.
				 * May be NULL. In particular the directory
				 * flag is very important. */
{
a148 1
    Tcl_Obj *fileNamePtr;
d150 39
a188 3
    fileNamePtr = Tcl_FSGetTranslatedPath(interp, pathPtr);
    if (fileNamePtr == NULL) {
	return TCL_ERROR;
d190 4
a193 1
    
d203 6
a208 19
    if (pattern == NULL || (*pattern == '\0')) {
	/* Match a single file directly */
	Tcl_StatBuf buf;
	CInfoPBRec paramBlock;
	FSSpec fileSpec;
	
	if (TclpObjLstat(fileNamePtr, &buf) != 0) {
	    /* File doesn't exist */
	    return TCL_OK;
	}

	if (FspLLocationFromFsPath(fileNamePtr, &fileSpec) == noErr) {
	    paramBlock.hFileInfo.ioCompletion = NULL;
	    paramBlock.hFileInfo.ioNamePtr = fileSpec.name;
	    paramBlock.hFileInfo.ioVRefNum = fileSpec.vRefNum;
	    paramBlock.hFileInfo.ioFDirIndex = 0;
	    paramBlock.hFileInfo.ioDirID = fileSpec.parID;
	    
	    PBGetCatInfo(&paramBlock, 0);
a210 30
	if (NativeMatchType(fileNamePtr, types, paramBlock.hFileInfo,
			    okType, okCreator)) {
	    int fnameLen;
	    char *fname = Tcl_GetStringFromObj(pathPtr,&fnameLen);
	    if ((fnameLen > 1) && (strchr(fname+1, ':') == NULL)) {
		Tcl_ListObjAppendElement(interp, resultPtr, 
			Tcl_NewStringObj(fname+1, fnameLen-1));
	    } else {
		Tcl_ListObjAppendElement(interp, resultPtr, pathPtr);
	    }
	}
	return TCL_OK;
    } else {
	char *fname;
	int fnameLen, result = TCL_OK;
	int baseLength;
	CInfoPBRec pb;
	OSErr err;
	FSSpec dirSpec;
	Boolean isDirectory;
	long dirID;
	short itemIndex;
	Str255 fileName;
	Tcl_DString fileString;    
	Tcl_DString dsOrig;

	Tcl_DStringInit(&dsOrig);
	Tcl_DStringAppend(&dsOrig, Tcl_GetString(fileNamePtr), -1);
	baseLength = Tcl_DStringLength(&dsOrig);

d212 4
a215 2
	 * Make sure that the directory part of the name really is a
	 * directory.
d217 73
a289 83

	Tcl_UtfToExternalDString(NULL, Tcl_DStringValue(&dsOrig),
		Tcl_DStringLength(&dsOrig), &fileString);

	err = FSpLocationFromPath(Tcl_DStringLength(&fileString), 
				  Tcl_DStringValue(&fileString), &dirSpec);
	Tcl_DStringFree(&fileString);
	if (err == noErr) {
	    err = FSpGetDirectoryID(&dirSpec, &dirID, &isDirectory);
	}
	
	if ((err != noErr) || !isDirectory) {
	    /*
	     * Check if we had a relative path (unix style relative path 
	     * compatibility for glob)
	     */
	    Tcl_DStringFree(&dsOrig);
	    Tcl_DStringAppend(&dsOrig, ":", 1);
	    Tcl_DStringAppend(&dsOrig, Tcl_GetString(fileNamePtr), -1);
	    baseLength = Tcl_DStringLength(&dsOrig);

	    Tcl_UtfToExternalDString(NULL, Tcl_DStringValue(&dsOrig),
		    Tcl_DStringLength(&dsOrig), &fileString);
	    
	    err = FSpLocationFromPath(Tcl_DStringLength(&fileString), 
				      Tcl_DStringValue(&fileString), &dirSpec);
	    Tcl_DStringFree(&fileString);
	    if (err == noErr) {
		err = FSpGetDirectoryID(&dirSpec, &dirID, &isDirectory);
	    }
	    
	    if ((err != noErr) || !isDirectory) {
		Tcl_DStringFree(&dsOrig);
		return TCL_OK;
	    }
	}

	/* Make sure we have a trailing directory delimiter */
	if (Tcl_DStringValue(&dsOrig)[baseLength-1] != ':') {
	    Tcl_DStringAppend(&dsOrig, ":", 1);
	    baseLength++;
	}
	
	/*
	 * Now open the directory for reading and iterate over the contents.
	 */

	pb.hFileInfo.ioVRefNum = dirSpec.vRefNum;
	pb.hFileInfo.ioDirID = dirID;
	pb.hFileInfo.ioNamePtr = (StringPtr) fileName;
	pb.hFileInfo.ioFDirIndex = itemIndex = 1;

	while (1) {
	    pb.hFileInfo.ioFDirIndex = itemIndex;
	    pb.hFileInfo.ioDirID = dirID;
	    err = PBGetCatInfoSync(&pb);
	    if (err != noErr) {
		break;
	    }

	    /*
	     * Now check to see if the file matches.  
	     */
	     
	    Tcl_ExternalToUtfDString(NULL, (char *) fileName + 1, fileName[0],
		    &fileString);
	    if (Tcl_StringMatch(Tcl_DStringValue(&fileString), pattern)) {
		Tcl_Obj *tempName;
		Tcl_DStringSetLength(&dsOrig, baseLength);
		Tcl_DStringAppend(&dsOrig, Tcl_DStringValue(&fileString), -1);
		fname = Tcl_DStringValue(&dsOrig);
		fnameLen = Tcl_DStringLength(&dsOrig);
		
		/* 
		 * We use this tempName in calls to check the file's
		 * type below.  We may also use it for the result.
		 */
		tempName = Tcl_NewStringObj(fname, fnameLen);
		Tcl_IncrRefCount(tempName);

		/* Is the type acceptable? */
		if (NativeMatchType(tempName, types, pb.hFileInfo,
				    okType, okCreator)) {
d294 2
a295 1
			Tcl_ListObjAppendElement(interp, resultPtr, tempName);
d298 7
a304 5
		/* 
		 * This will free the object, unless it was inserted in
		 * the result list above.
		 */
		Tcl_DecrRefCount(tempName);
a305 2
	    Tcl_DStringFree(&fileString);
	    itemIndex++;
d307 4
d312 1
a312 3
	Tcl_DStringFree(&dsOrig);
	return result;
    }
d314 16
a329 8

static int 
NativeMatchType(
    Tcl_Obj *tempName,        /* Path to check */
    Tcl_GlobTypeData *types,  /* Type description to match against */
    HFileInfo fileInfo,       /* MacOS file info */
    OSType okType,            /* Acceptable MacOS type, or zero */
    OSType okCreator)         /* Acceptable MacOS creator, or zero */
d331 1
a331 83
    if (types == NULL) {
	/* If invisible, don't return the file */
	if (fileInfo.ioFlFndrInfo.fdFlags & kIsInvisible) {
	    return 0;
	}
    } else {
	Tcl_StatBuf buf;
	
	if (fileInfo.ioFlFndrInfo.fdFlags & kIsInvisible) {
	    /* If invisible */
	    if ((types->perm == 0) || 
	      !(types->perm & TCL_GLOB_PERM_HIDDEN)) {
		return 0;
	    }
	} else {
	    /* Visible */
	    if (types->perm & TCL_GLOB_PERM_HIDDEN) {
		return 0;
	    }
	}
	if (types->perm != 0) {
	    if (
		((types->perm & TCL_GLOB_PERM_RONLY) &&
			!(fileInfo.ioFlAttrib & 1)) ||
		((types->perm & TCL_GLOB_PERM_R) &&
			(TclpObjAccess(tempName, R_OK) != 0)) ||
		((types->perm & TCL_GLOB_PERM_W) &&
			(TclpObjAccess(tempName, W_OK) != 0)) ||
		((types->perm & TCL_GLOB_PERM_X) &&
			(TclpObjAccess(tempName, X_OK) != 0))
		) {
		return 0;
	    }
	}
	if (types->type != 0) {
	    if (TclpObjStat(tempName, &buf) != 0) {
		/* Posix error occurred */
		return 0;
	    }
	    /*
	     * In order bcdpfls as in 'find -t'
	     */
	    if (
		((types->type & TCL_GLOB_TYPE_BLOCK) &&
			S_ISBLK(buf.st_mode)) ||
		((types->type & TCL_GLOB_TYPE_CHAR) &&
			S_ISCHR(buf.st_mode)) ||
		((types->type & TCL_GLOB_TYPE_DIR) &&
			S_ISDIR(buf.st_mode)) ||
		((types->type & TCL_GLOB_TYPE_PIPE) &&
			S_ISFIFO(buf.st_mode)) ||
		((types->type & TCL_GLOB_TYPE_FILE) &&
			S_ISREG(buf.st_mode))
#ifdef S_ISSOCK
		|| ((types->type & TCL_GLOB_TYPE_SOCK) &&
			S_ISSOCK(buf.st_mode))
#endif
		) {
		/* Do nothing -- this file is ok */
	    } else {
		int typeOk = 0;
#ifdef S_ISLNK
		if (types->type & TCL_GLOB_TYPE_LINK) {
		    if (TclpObjLstat(tempName, &buf) == 0) {
			if (S_ISLNK(buf.st_mode)) {
			    typeOk = 1;
			}
		    }
		}
#endif
		if (typeOk == 0) {
		    return 0;
		}
	    }
	}
	if (((okType != 0) && (okType !=
			       fileInfo.ioFlFndrInfo.fdType)) ||
	    ((okCreator != 0) && (okCreator !=
				  fileInfo.ioFlFndrInfo.fdCreator))) {
	    return 0;
	}
    }
    return 1;
a332 1

d337 1
a337 1
 * TclpObjAccess --
d350 4
a353 4
int 
TclpObjAccess(pathPtr, mode)
    Tcl_Obj *pathPtr;
    int mode;
d361 2
d365 3
a367 1
    err = FspLLocationFromFsPath(pathPtr, &fileSpec);
d419 1
a419 1
		&& (fpb.ioFlFndrInfo.fdType != 'APPL')) {
d436 1
a436 1
 * TclpObjChdir --
d445 1
a445 1
 *	Tcl_FSGetCwd() is deallocated and set to NULL.
d450 3
a452 3
int 
TclpObjChdir(pathPtr)
    Tcl_Obj *pathPtr;
d458 2
d461 3
a463 1
    err = FspLocationFromFsPath(pathPtr, &spec);
d499 1
a499 1
 * TclpObjGetCwd --
d517 1
a517 16
Tcl_Obj* 
TclpObjGetCwd(interp)
    Tcl_Interp *interp;
{
    Tcl_DString ds;
    if (TclpGetCwd(interp, &ds) != NULL) {
	Tcl_Obj *cwdPtr = Tcl_NewStringObj(Tcl_DStringValue(&ds), -1);
	Tcl_IncrRefCount(cwdPtr);
	Tcl_DStringFree(&ds);
	return cwdPtr;
    } else {
	return NULL;
    }
}

CONST char *
d586 1
d588 1
a588 1
    Tcl_UtfToExternalDString(NULL, path, -1, &ds);
d594 2
a595 3
    while ((Tcl_DStringLength(&ds) != 0) 
	   && (Tcl_DStringValue(&ds)[Tcl_DStringLength(&ds) - 1] == ':')) {
	Tcl_DStringSetLength(&ds, Tcl_DStringLength(&ds) - 1);
d598 3
a600 3
    end = strrchr(Tcl_DStringValue(&ds), ':');
    if (end == NULL ) {
	strcpy(fileName + 1, Tcl_DStringValue(&ds));
d602 3
a604 2
	strcpy(fileName + 1, end + 1);
	Tcl_DStringSetLength(&ds, end + 1 - Tcl_DStringValue(&ds));
d613 2
a614 3
    if (end != NULL) {
	err = FSpLocationFromPath(Tcl_DStringLength(&ds), 
				  Tcl_DStringValue(&ds), &fileSpec);
a680 5

static int 
TclpObjStatAlias _ANSI_ARGS_((Tcl_Obj *pathPtr, Tcl_StatBuf *bufPtr, 
			      Boolean resolveLink));

d685 1
a685 1
 * TclpObjLstat --
d690 1
a690 1
 *	See lstat() documentation.
d693 1
a693 1
 *	See lstat() documentation.
d698 4
a701 4
int 
TclpObjLstat(pathPtr, buf)
    Tcl_Obj *pathPtr;
    Tcl_StatBuf *buf;
d703 5
a707 1
    return TclpObjStatAlias(pathPtr, buf, FALSE);
d713 1
a713 1
 * TclpObjStat --
d726 4
a729 11
int 
TclpObjStat(pathPtr, bufPtr)
    Tcl_Obj *pathPtr;
    Tcl_StatBuf *bufPtr;
{
    return TclpObjStatAlias(pathPtr, bufPtr, TRUE);
}


static int
TclpObjStatAlias (Tcl_Obj *pathPtr, Tcl_StatBuf *bufPtr, Boolean resolveLink)
d737 1
d739 3
a741 4
    if (resolveLink)
    	err = FspLocationFromFsPath(pathPtr, &fileSpec);
    else
    	err = FspLLocationFromFsPath(pathPtr, &fileSpec);
d788 5
a792 5
		/*
		 * Directories and applications are executable by everyone.
		 */
		 
		bufPtr->st_mode |= S_IXUSR | S_IXGRP | S_IXOTH;
d795 5
a799 5
		/* 
		 * If not locked, then everyone has write acces.
		 */
		 
		bufPtr->st_mode |= S_IWUSR | S_IWGRP | S_IWOTH;
d814 1
a814 1
	     * epoch starts from GMT.  This is also consistent with
d818 15
a832 4
	    bufPtr->st_atime = bufPtr->st_mtime = fpb.ioFlMdDat 
	      - TclpGetGMTOffset() + tcl_mac_epoch_offset;
	    bufPtr->st_ctime = fpb.ioFlCrDat - TclpGetGMTOffset() 
	      + tcl_mac_epoch_offset;
d897 1
a897 1
    err = FSpLocationFromPath(strlen(path), path, &fileSpec);
a996 1

d999 1
a999 1
    CONST char *path, 
d1004 3
a1006 4
    Str255 pathName;
    strcpy((char *) pathName + 1, path);
    pathName[0] = strlen(path);
    hpb.fileParam.ioNamePtr = pathName;
d1015 1
a1022 125
}


/*
 *----------------------------------------------------------------------
 *
 * TclpTempFileName --
 *
 *	This function returns a unique filename.
 *
 * Results:
 *	Returns a valid Tcl_Obj* with refCount 0, or NULL on failure.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_Obj* 
TclpTempFileName()
{
    char fileName[L_tmpnam];
    
    if (tmpnam(fileName) == NULL) {	       /* INTL: Native. */
	return NULL;
    }

    return TclpNativeToNormalized((ClientData) fileName);
}

#ifdef S_IFLNK

Tcl_Obj* 
TclpObjLink(pathPtr, toPtr, linkAction)
    Tcl_Obj *pathPtr;
    Tcl_Obj *toPtr;
    int linkAction;
{
    Tcl_Obj* link = NULL;

    if (toPtr != NULL) {
	if (TclpObjAccess(pathPtr, F_OK) != -1) {
	    /* src exists */
	    errno = EEXIST;
	    return NULL;
	}
	if (TclpObjAccess(toPtr, F_OK) == -1) {
	    /* target doesn't exist */
	    errno = ENOENT;
	    return NULL;
	}

	if (linkAction & TCL_CREATE_SYMBOLIC_LINK) {
	    /* Needs to create a new link */
	    FSSpec spec;
	    FSSpec linkSpec;
	    OSErr err;
	    char *path;
	    AliasHandle alias;
	    
	    err = FspLocationFromFsPath(toPtr, &spec);
	    if (err != noErr) {
		errno = ENOENT;
		return NULL;
	    }

	    path = Tcl_FSGetNativePath(pathPtr);
	    err = FSpLocationFromPath(strlen(path), path, &linkSpec);
	    if (err == noErr) {
		err = dupFNErr;		/* EEXIST. */
	    } else {
		err = NewAlias(&spec, &linkSpec, &alias);
	    }
	    if (err != noErr) {
		errno = TclMacOSErrorToPosixError(err);
		return NULL;
	    }
	    return toPtr;
	} else {
	    errno = ENODEV;
	    return NULL;
	}
    } else {
	Tcl_DString ds;
	Tcl_Obj *transPtr = Tcl_FSGetTranslatedPath(NULL, pathPtr);
	if (transPtr == NULL) {
	    return NULL;
	}
	if (TclpReadlink(Tcl_GetString(transPtr), &ds) != NULL) {
	    link = Tcl_NewStringObj(Tcl_DStringValue(&ds), -1);
	    Tcl_IncrRefCount(link);
	    Tcl_DStringFree(&ds);
	}
    }
    return link;
}

#endif


/*
 *---------------------------------------------------------------------------
 *
 * TclpFilesystemPathType --
 *
 *      This function is part of the native filesystem support, and
 *      returns the path type of the given path.  Right now it simply
 *      returns NULL.  In the future it could return specific path
 *      types, like 'HFS', 'HFS+', 'nfs', 'samba', 'FAT32', etc.
 *
 * Results:
 *      NULL at present.
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
 */
Tcl_Obj*
TclpFilesystemPathType(pathObjPtr)
    Tcl_Obj* pathObjPtr;
{
    /* All native paths are of the same type */
    return NULL;
@


1.1.1.4
log
@import tcl 8.4.1
@
text
@d13 1
a13 1
 * RCS: @@(#) $Id: tclMacFile.c,v 1.25 2002/10/09 11:54:24 das Exp $
d1175 1
a1175 1
	    CONST char *path;
@


