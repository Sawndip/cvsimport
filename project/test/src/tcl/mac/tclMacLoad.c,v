head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.58
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.56
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.54
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.52
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.50
	gdb_7_0-branch:1.5.0.48
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tcl8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.46
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.44
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.42
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.40
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.38
	gdb_6_5-2006-05-14-branchpoint:1.5
	readline_5_1-import-branch:1.5.0.36
	readline_5_1-import-branchpoint:1.5
	gdb_6_4-branch:1.5.0.34
	gdb_6_4-2005-11-01-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.32
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	ezannoni_pie-20040323-branch:1.5.0.30
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.28
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.26
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.24
	cagney_x86i386-20030821-branch:1.5.0.22
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.20
	gdb_6_0-2003-06-23-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.18
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.16
	cagney_writestrings-20030508-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.14
	cagney_fileio-20030521-branchpoint:1.5
	carlton_dictionary-20030430-merge:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.12
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.10
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.8
	cagney_lazyid-20030317-branchpoint:1.5
	offbyone-20030313-branch:1.5.0.6
	offbyone-20030313-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.4
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.2
	interps-20030202-branchpoint:1.5
	TCL8_4_1:1.1.1.4
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.2
	TCL_8_4_1:1.1.1.4
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.4
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TCL_8_4_0:1.1.1.3
	carlton_dictionary-branch:1.2.0.16
	carlton_dictionary-20020920-branchpoint:1.2
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.14
	gdb_5_3-branch:1.2.0.12
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.10
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.8
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.6
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TCL_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	dejagnu-2000-02-04:1.1.1.1
	dejagnu-2000-01-31:1.1.1.1
	dejagnu-2000-01-24:1.1.1.1
	dejagnu-2000-01-17:1.1.1.1
	dejagnu-2000-01-10:1.1.1.1
	dejagnu-2000-01-04:1.1.1.1
	dejagnu-1999-12-21:1.1.1.1
	dejagnu-1999-12-13:1.1.1.1
	dejagnu-1999-12-07:1.1.1.1
	dejagnu-1999-12-06:1.1.1.1
	dejagnu-1999-11-15:1.1.1.1
	dejagnu-1999-11-08:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.5
date	2003.01.21.19.40.11;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.26.19.47.59;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.37.06;	author kseitz;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2001.09.09.23.56.07;	author irox;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	99.11.09.01.28.43;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2002.09.27.21.49.09;	author kseitz;	state Exp;
branches;
next	;

1.3.4.1
date	2003.12.14.20.28.47;	author drow;	state Exp;
branches;
next	;

1.2.16.1
date	2002.12.23.19.40.34;	author carlton;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2003.02.07.19.18.16;	author carlton;	state Exp;
branches;
next	;

1.1.1.1
date	99.11.09.01.28.43;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.09.22.40.57;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.19.56.53;	author kseitz;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.11.26.20.01.36;	author hunt;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tcl 8.4.1
@
text
@/*
 * tclMacLoad.c --
 *
 *	This procedure provides a version of the TclLoadFile for use
 *	on the Macintosh.  This procedure will only work with systems 
 *	that use the Code Fragment Manager.
 *
 * Copyright (c) 1995-1997 Sun Microsystems, Inc.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tclMacLoad.c,v 1.16 2002/10/09 11:54:26 das Exp $
 */

#include <CodeFragments.h>
#include <Errors.h>
#include <Resources.h>
#include <Strings.h>
#include <FSpCompat.h>

/*
 * Seems that the 3.0.1 Universal headers leave this define out.  So we
 * define it here...
 */
 
#ifndef fragNoErr
    #define fragNoErr noErr
#endif

#include "tclPort.h"
#include "tclInt.h"
#include "tclMacInt.h"

#if GENERATINGPOWERPC
    #define OUR_ARCH_TYPE kPowerPCCFragArch
#else
    #define OUR_ARCH_TYPE kMotorola68KCFragArch
#endif

/*
 * The following data structure defines the structure of a code fragment
 * resource.  We can cast the resource to be of this type to access
 * any fields we need to see.
 */
struct CfrgHeader {
    long 	res1;
    long 	res2;
    long 	version;
    long 	res3;
    long 	res4;
    long 	filler1;
    long 	filler2;
    long 	itemCount;
    char	arrayStart;	/* Array of externalItems begins here. */
};
typedef struct CfrgHeader CfrgHeader, *CfrgHeaderPtr, **CfrgHeaderPtrHand;

/*
 * The below structure defines a cfrag item within the cfrag resource.
 */
struct CfrgItem {
    OSType 	archType;
    long 	updateLevel;
    long	currVersion;
    long	oldDefVersion;
    long	appStackSize;
    short	appSubFolder;
    char	usage;
    char	location;
    long	codeOffset;
    long	codeLength;
    long	res1;
    long	res2;
    short	itemSize;
    Str255	name;		/* This is actually variable sized. */
};
typedef struct CfrgItem CfrgItem;

/*
 * On MacOS, old shared libraries which contain many code fragments
 * cannot, it seems, be loaded in one go.  We need to look provide
 * the name of a code fragment while we load.  Since with the
 * separation of the 'load' and 'findsymbol' be do not necessarily
 * know a symbol name at load time, we have to store some further
 * information in a structure like this so we can ensure we load
 * properly in 'findsymbol' if the first attempts didn't work.
 */
typedef struct TclMacLoadInfo {
    int loaded;
    CFragConnectionID connID;
    FSSpec fileSpec;
} TclMacLoadInfo;

static int TryToLoad(Tcl_Interp *interp, TclMacLoadInfo *loadInfo, Tcl_Obj *pathPtr, 
		     CONST char *sym /* native */);


/*
 *----------------------------------------------------------------------
 *
 * TclpDlopen --
 *
 *	This procedure is called to carry out dynamic loading of binary
 *	code for the Macintosh.  This implementation is based on the
 *	Code Fragment Manager & will not work on other systems.
 *
 * Results:
 *	The result is TCL_ERROR, and an error message is left in
 *	the interp's result.
 *
 * Side effects:
 *	New binary code is loaded.
 *
 *----------------------------------------------------------------------
 */

int
TclpDlopen(interp, pathPtr, loadHandle, unloadProcPtr)
    Tcl_Interp *interp;		/* Used for error reporting. */
    Tcl_Obj *pathPtr;		/* Name of the file containing the desired
				 * code (UTF-8). */
    Tcl_LoadHandle *loadHandle;	/* Filled with token for dynamically loaded
				 * file which will be passed back to 
				 * (*unloadProcPtr)() to unload the file. */
    Tcl_FSUnloadFileProc **unloadProcPtr;
				/* Filled with address of Tcl_FSUnloadFileProc
				 * function which should be used for
				 * this file. */
{
    OSErr err;
    FSSpec fileSpec;
    CONST char *native;
    TclMacLoadInfo *loadInfo;
    
    native = Tcl_FSGetNativePath(pathPtr);
    err = FSpLocationFromPath(strlen(native), native, &fileSpec);
    
    if (err != noErr) {
	Tcl_SetResult(interp, "could not locate shared library", TCL_STATIC);
	return TCL_ERROR;
    }
    
    loadInfo = (TclMacLoadInfo *) ckalloc(sizeof(TclMacLoadInfo));
    loadInfo->loaded = 0;
    loadInfo->fileSpec = fileSpec;
    loadInfo->connID = NULL;
    
    if (TryToLoad(interp, loadInfo, pathPtr, NULL) != TCL_OK) {
	ckfree((char*) loadInfo);
	return TCL_ERROR;
    }

    *loadHandle = (Tcl_LoadHandle)loadInfo;
    *unloadProcPtr = &TclpUnloadFile;
    return TCL_OK;
}

/* 
 * See the comments about 'struct TclMacLoadInfo' above. This
 * function ensures the appropriate library or symbol is
 * loaded.
 */
static int
TryToLoad(Tcl_Interp *interp, TclMacLoadInfo *loadInfo, Tcl_Obj *pathPtr,
	  CONST char *sym /* native */) 
{
    OSErr err;
    CFragConnectionID connID;
    Ptr dummy;
    short fragFileRef, saveFileRef;
    Handle fragResource;
    UInt32 offset = 0;
    UInt32 length = kCFragGoesToEOF;
    Str255 errName;
    StringPtr fragName=NULL;

    if (loadInfo->loaded == 1) {
        return TCL_OK;
    }

    /*
     * See if this fragment has a 'cfrg' resource.  It will tell us where
     * to look for the fragment in the file.  If it doesn't exist we will
     * assume we have a ppc frag using the whole data fork.  If it does
     * exist we find the frag that matches the one we are looking for and
     * get the offset and size from the resource.
     */
     
    saveFileRef = CurResFile();
    SetResLoad(false);
    fragFileRef = FSpOpenResFile(&loadInfo->fileSpec, fsRdPerm);
    SetResLoad(true);
    if (fragFileRef != -1) {
	if (sym != NULL) {
	    UseResFile(fragFileRef);
	    fragResource = Get1Resource(kCFragResourceType, kCFragResourceID);
	    HLock(fragResource);
	    if (ResError() == noErr) {
		CfrgItem* srcItem;
		long itemCount, index;
		Ptr itemStart;

		itemCount = (*(CfrgHeaderPtrHand)fragResource)->itemCount;
		itemStart = &(*(CfrgHeaderPtrHand)fragResource)->arrayStart;
		for (index = 0; index < itemCount;
		     index++, itemStart += srcItem->itemSize) {
		    srcItem = (CfrgItem*)itemStart;
		    if (srcItem->archType != OUR_ARCH_TYPE) continue;
		    if (!strncasecmp(sym, (char *) srcItem->name + 1,
			    strlen(sym))) {
			offset = srcItem->codeOffset;
			length = srcItem->codeLength;
			fragName=srcItem->name;
		    }
		}
	    }
	}
	/*
	 * Close the resource file.  If the extension wants to reopen the
	 * resource fork it should use the tclMacLibrary.c file during it's
	 * construction.
	 */
	HUnlock(fragResource);
	ReleaseResource(fragResource);
	CloseResFile(fragFileRef);
	UseResFile(saveFileRef);
	if (sym == NULL) {
	    /* We just return */
	    return TCL_OK;
	}
    }

    /*
     * Now we can attempt to load the fragment using the offset & length
     * obtained from the resource.  We don't worry about the main entry point
     * as we are going to search for specific entry points passed to us.
     */
    
    err = GetDiskFragment(&loadInfo->fileSpec, offset, length, fragName,
	    kLoadCFrag, &connID, &dummy, errName);
    
    if (err != fragNoErr) {
	p2cstr(errName);
	if(pathPtr) {
	Tcl_AppendResult(interp, "couldn't load file \"", 
			 Tcl_GetString(pathPtr),
			 "\": ", errName, (char *) NULL);
	} else if(sym) {
	Tcl_AppendResult(interp, "couldn't load library \"", 
			 sym,
			 "\": ", errName, (char *) NULL);
	}
	return TCL_ERROR;
    }

    loadInfo->connID = connID;
    loadInfo->loaded = 1;

    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * TclpFindSymbol --
 *
 *	Looks up a symbol, by name, through a handle associated with
 *	a previously loaded piece of code (shared library).
 *
 * Results:
 *	Returns a pointer to the function associated with 'symbol' if
 *	it is found.  Otherwise returns NULL and may leave an error
 *	message in the interp's result.
 *
 *----------------------------------------------------------------------
 */
Tcl_PackageInitProc*
TclpFindSymbol(interp, loadHandle, symbol) 
    Tcl_Interp *interp;
    Tcl_LoadHandle loadHandle;
    CONST char *symbol;
{
    Tcl_DString ds;
    Tcl_PackageInitProc *proc=NULL;
    TclMacLoadInfo *loadInfo = (TclMacLoadInfo *)loadHandle;
    Str255 symbolName;
    CFragSymbolClass symClass;
    OSErr err;
   
    if (loadInfo->loaded == 0) {
	int res;
	/*
	 * First thing we must do is infer the package name from the
	 * sym variable.  We do this by removing the '_Init'.
	 */
	Tcl_UtfToExternalDString(NULL, symbol, -1, &ds);
	Tcl_DStringSetLength(&ds, Tcl_DStringLength(&ds) - 5);
	res = TryToLoad(interp, loadInfo, NULL, Tcl_DStringValue(&ds));
	Tcl_DStringFree(&ds);
	if (res != TCL_OK) {
	    return NULL;
	}
    }
    
    Tcl_UtfToExternalDString(NULL, symbol, -1, &ds);
    strcpy((char *) symbolName + 1, Tcl_DStringValue(&ds));
    symbolName[0] = (unsigned) Tcl_DStringLength(&ds);
    err = FindSymbol(loadInfo->connID, symbolName, (Ptr *) &proc, &symClass);
    Tcl_DStringFree(&ds);
    if (err != fragNoErr || symClass == kDataCFragSymbol) {
	Tcl_SetResult(interp,
		"could not find Initialization routine in library",
		TCL_STATIC);
	return NULL;
    }
    return proc;
}

/*
 *----------------------------------------------------------------------
 *
 * TclpUnloadFile --
 *
 *	Unloads a dynamically loaded binary code file from memory.
 *	Code pointers in the formerly loaded file are no longer valid
 *	after calling this function.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Does nothing.  Can anything be done?
 *
 *----------------------------------------------------------------------
 */

void
TclpUnloadFile(loadHandle)
    Tcl_LoadHandle loadHandle;	/* loadHandle returned by a previous call
				 * to TclpDlopen().  The loadHandle is 
				 * a token that represents the loaded 
				 * file. */
{
    TclMacLoadInfo *loadInfo = (TclMacLoadInfo *)loadHandle;
    if (loadInfo->loaded) {
	CloseConnection((CFragConnectionID*) &(loadInfo->connID));
    }
    ckfree((char*)loadInfo);
}

/*
 *----------------------------------------------------------------------
 *
 * TclGuessPackageName --
 *
 *	If the "load" command is invoked without providing a package
 *	name, this procedure is invoked to try to figure it out.
 *
 * Results:
 *	Always returns 0 to indicate that we couldn't figure out a
 *	package name;  generic code will then try to guess the package
 *	from the file name.  A return value of 1 would have meant that
 *	we figured out the package name and put it in bufPtr.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
TclGuessPackageName(
    CONST char *fileName,	/* Name of file containing package (already
				 * translated to local form if needed). */
    Tcl_DString *bufPtr)	/* Initialized empty dstring.  Append
				 * package name to this if possible. */
{
    return 0;
}
@


1.4
log
@touched all sources to ease next import
@
text
@d13 1
a13 1
 * RCS: @@(#) $Id: tclMacLoad.c,v 1.6.8.1 2000/04/06 22:38:30 spolk Exp $
d79 19
d102 1
a102 1
 * TclLoadFile --
d119 5
a123 11
TclpLoadFile(
    Tcl_Interp *interp,		/* Used for error reporting. */
    char *fileName,		/* Name of the file containing the desired
				 * code. */
    char *sym1, char *sym2,	/* Names of two procedures to look up in
				 * the file's symbol table. */
    Tcl_PackageInitProc **proc1Ptr,
    Tcl_PackageInitProc **proc2Ptr,
				/* Where to return the addresses corresponding
				 * to sym1 and sym2. */
    ClientData *clientDataPtr)	/* Filled with token for dynamically loaded
d125 5
a129 1
				 * TclpUnloadFile() to unload the file. */
a130 2
    CFragConnectionID connID;
    Ptr dummy;
a131 1
    CFragSymbolClass symClass;
d133 2
a134 17
    short fragFileRef, saveFileRef;
    Handle fragResource;
    UInt32 offset = 0;
    UInt32 length = kCFragGoesToEOF;
    char packageName[255];
    Str255 errName;
    Tcl_DString ds;
    char *native;
    
    /*
     * First thing we must do is infer the package name from the sym1
     * variable.  This is kind of dumb since the caller actually knows
     * this value, it just doesn't give it to us.
     */
    strcpy(packageName, sym1);
    Tcl_UtfToLower(packageName);
    *(Tcl_UtfAtIndex(packageName, Tcl_NumUtfChars(packageName, -1) - 5)) = 0;
d136 1
a136 1
    native = Tcl_UtfToExternalDString(NULL, fileName, -1, &ds);
a137 1
    Tcl_DStringFree(&ds);
d144 38
d192 1
a192 1
    fragFileRef = FSpOpenResFile(&fileSpec, fsRdPerm);
d195 21
a215 18
	UseResFile(fragFileRef);
	fragResource = Get1Resource(kCFragResourceType, kCFragResourceID);
	HLock(fragResource);
	if (ResError() == noErr) {
	    CfrgItem* srcItem;
	    long itemCount, index;
	    Ptr itemStart;

	    itemCount = (*(CfrgHeaderPtrHand)fragResource)->itemCount;
	    itemStart = &(*(CfrgHeaderPtrHand)fragResource)->arrayStart;
	    for (index = 0; index < itemCount;
		 index++, itemStart += srcItem->itemSize) {
		srcItem = (CfrgItem*)itemStart;
		if (srcItem->archType != OUR_ARCH_TYPE) continue;
		if (!strncasecmp(packageName, (char *) srcItem->name + 1,
			srcItem->name[0])) {
		    offset = srcItem->codeOffset;
		    length = srcItem->codeLength;
d228 4
d235 1
a235 1
     * Now we can attempt to load the fragement using the offset & length
d240 1
a240 2
    c2pstr(packageName);
    err = GetDiskFragment(&fileSpec, offset, length, (StringPtr) packageName,
d242 1
d245 9
a253 2
	Tcl_AppendResult(interp, "couldn't load file \"", fileName,
	    "\": ", errName, (char *) NULL);
d256 49
d306 5
a310 3
    c2pstr(sym1);
    err = FindSymbol(connID, (StringPtr) sym1, (Ptr *) proc1Ptr, &symClass);
    p2cstr((StringPtr) sym1);
d315 1
a315 8
	return TCL_ERROR;
    }

    c2pstr(sym2);
    err = FindSymbol(connID, (StringPtr) sym2, (Ptr *) proc2Ptr, &symClass);
    p2cstr((StringPtr) sym2);
    if (err != fragNoErr || symClass == kDataCFragSymbol) {
	*proc2Ptr = NULL;
d317 1
a317 4
    
    *clientDataPtr = (ClientData) connID;
    
    return TCL_OK;
d339 3
a341 3
TclpUnloadFile(clientData)
    ClientData clientData;	/* ClientData returned by a previous call
				 * to TclpLoadFile().  The clientData is 
d345 5
d374 1
a374 1
    char *fileName,		/* Name of file containing package (already
@


1.3
log
@touched all sources to ease next import
@
text
@@


1.3.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d13 1
a13 1
 * RCS: @@(#) $Id: tclMacLoad.c,v 1.16 2002/10/09 11:54:26 das Exp $
a78 19

/*
 * On MacOS, old shared libraries which contain many code fragments
 * cannot, it seems, be loaded in one go.  We need to look provide
 * the name of a code fragment while we load.  Since with the
 * separation of the 'load' and 'findsymbol' be do not necessarily
 * know a symbol name at load time, we have to store some further
 * information in a structure like this so we can ensure we load
 * properly in 'findsymbol' if the first attempts didn't work.
 */
typedef struct TclMacLoadInfo {
    int loaded;
    CFragConnectionID connID;
    FSSpec fileSpec;
} TclMacLoadInfo;

static int TryToLoad(Tcl_Interp *interp, TclMacLoadInfo *loadInfo, Tcl_Obj *pathPtr, 
		     CONST char *sym /* native */);

d83 1
a83 1
 * TclpDlopen --
d100 11
a110 5
TclpDlopen(interp, pathPtr, loadHandle, unloadProcPtr)
    Tcl_Interp *interp;		/* Used for error reporting. */
    Tcl_Obj *pathPtr;		/* Name of the file containing the desired
				 * code (UTF-8). */
    Tcl_LoadHandle *loadHandle;	/* Filled with token for dynamically loaded
d112 1
a112 5
				 * (*unloadProcPtr)() to unload the file. */
    Tcl_FSUnloadFileProc **unloadProcPtr;
				/* Filled with address of Tcl_FSUnloadFileProc
				 * function which should be used for
				 * this file. */
d114 2
d117 1
d119 17
a135 2
    CONST char *native;
    TclMacLoadInfo *loadInfo;
d137 1
a137 1
    native = Tcl_FSGetNativePath(pathPtr);
d139 1
a145 38
    loadInfo = (TclMacLoadInfo *) ckalloc(sizeof(TclMacLoadInfo));
    loadInfo->loaded = 0;
    loadInfo->fileSpec = fileSpec;
    loadInfo->connID = NULL;
    
    if (TryToLoad(interp, loadInfo, pathPtr, NULL) != TCL_OK) {
	ckfree((char*) loadInfo);
	return TCL_ERROR;
    }

    *loadHandle = (Tcl_LoadHandle)loadInfo;
    *unloadProcPtr = &TclpUnloadFile;
    return TCL_OK;
}

/* 
 * See the comments about 'struct TclMacLoadInfo' above. This
 * function ensures the appropriate library or symbol is
 * loaded.
 */
static int
TryToLoad(Tcl_Interp *interp, TclMacLoadInfo *loadInfo, Tcl_Obj *pathPtr,
	  CONST char *sym /* native */) 
{
    OSErr err;
    CFragConnectionID connID;
    Ptr dummy;
    short fragFileRef, saveFileRef;
    Handle fragResource;
    UInt32 offset = 0;
    UInt32 length = kCFragGoesToEOF;
    Str255 errName;
    StringPtr fragName=NULL;

    if (loadInfo->loaded == 1) {
        return TCL_OK;
    }

d156 1
a156 1
    fragFileRef = FSpOpenResFile(&loadInfo->fileSpec, fsRdPerm);
d159 18
a176 21
	if (sym != NULL) {
	    UseResFile(fragFileRef);
	    fragResource = Get1Resource(kCFragResourceType, kCFragResourceID);
	    HLock(fragResource);
	    if (ResError() == noErr) {
		CfrgItem* srcItem;
		long itemCount, index;
		Ptr itemStart;

		itemCount = (*(CfrgHeaderPtrHand)fragResource)->itemCount;
		itemStart = &(*(CfrgHeaderPtrHand)fragResource)->arrayStart;
		for (index = 0; index < itemCount;
		     index++, itemStart += srcItem->itemSize) {
		    srcItem = (CfrgItem*)itemStart;
		    if (srcItem->archType != OUR_ARCH_TYPE) continue;
		    if (!strncasecmp(sym, (char *) srcItem->name + 1,
			    strlen(sym))) {
			offset = srcItem->codeOffset;
			length = srcItem->codeLength;
			fragName=srcItem->name;
		    }
a188 4
	if (sym == NULL) {
	    /* We just return */
	    return TCL_OK;
	}
d192 1
a192 1
     * Now we can attempt to load the fragment using the offset & length
d197 2
a198 1
    err = GetDiskFragment(&loadInfo->fileSpec, offset, length, fragName,
a199 1
    
d202 2
a203 9
	if(pathPtr) {
	Tcl_AppendResult(interp, "couldn't load file \"", 
			 Tcl_GetString(pathPtr),
			 "\": ", errName, (char *) NULL);
	} else if(sym) {
	Tcl_AppendResult(interp, "couldn't load library \"", 
			 sym,
			 "\": ", errName, (char *) NULL);
	}
a205 49

    loadInfo->connID = connID;
    loadInfo->loaded = 1;

    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * TclpFindSymbol --
 *
 *	Looks up a symbol, by name, through a handle associated with
 *	a previously loaded piece of code (shared library).
 *
 * Results:
 *	Returns a pointer to the function associated with 'symbol' if
 *	it is found.  Otherwise returns NULL and may leave an error
 *	message in the interp's result.
 *
 *----------------------------------------------------------------------
 */
Tcl_PackageInitProc*
TclpFindSymbol(interp, loadHandle, symbol) 
    Tcl_Interp *interp;
    Tcl_LoadHandle loadHandle;
    CONST char *symbol;
{
    Tcl_DString ds;
    Tcl_PackageInitProc *proc=NULL;
    TclMacLoadInfo *loadInfo = (TclMacLoadInfo *)loadHandle;
    Str255 symbolName;
    CFragSymbolClass symClass;
    OSErr err;
   
    if (loadInfo->loaded == 0) {
	int res;
	/*
	 * First thing we must do is infer the package name from the
	 * sym variable.  We do this by removing the '_Init'.
	 */
	Tcl_UtfToExternalDString(NULL, symbol, -1, &ds);
	Tcl_DStringSetLength(&ds, Tcl_DStringLength(&ds) - 5);
	res = TryToLoad(interp, loadInfo, NULL, Tcl_DStringValue(&ds));
	Tcl_DStringFree(&ds);
	if (res != TCL_OK) {
	    return NULL;
	}
    }
d207 3
a209 5
    Tcl_UtfToExternalDString(NULL, symbol, -1, &ds);
    strcpy((char *) symbolName + 1, Tcl_DStringValue(&ds));
    symbolName[0] = (unsigned) Tcl_DStringLength(&ds);
    err = FindSymbol(loadInfo->connID, symbolName, (Ptr *) &proc, &symClass);
    Tcl_DStringFree(&ds);
d214 8
a221 1
	return NULL;
d223 4
a226 1
    return proc;
d248 3
a250 3
TclpUnloadFile(loadHandle)
    Tcl_LoadHandle loadHandle;	/* loadHandle returned by a previous call
				 * to TclpDlopen().  The loadHandle is 
a253 5
    TclMacLoadInfo *loadInfo = (TclMacLoadInfo *)loadHandle;
    if (loadInfo->loaded) {
	CloseConnection((CFragConnectionID*) &(loadInfo->connID));
    }
    ckfree((char*)loadInfo);
d278 1
a278 1
    CONST char *fileName,	/* Name of file containing package (already
@


1.3.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@d13 1
a13 1
 * RCS: @@(#) $Id: tclMacLoad.c,v 1.15 2002/07/18 16:26:04 vincentdarley Exp $
a78 19

/*
 * On MacOS, old shared libraries which contain many code fragments
 * cannot, it seems, be loaded in one go.  We need to look provide
 * the name of a code fragment while we load.  Since with the
 * separation of the 'load' and 'findsymbol' be do not necessarily
 * know a symbol name at load time, we have to store some further
 * information in a structure like this so we can ensure we load
 * properly in 'findsymbol' if the first attempts didn't work.
 */
typedef struct TclMacLoadInfo {
    int loaded;
    CFragConnectionID connID;
    FSSpec fileSpec;
} TclMacLoadInfo;

static int TryToLoad(Tcl_Interp *interp, TclMacLoadInfo *loadInfo, 
		     CONST char *sym /* native */) 

d83 1
a83 1
 * TclpDlopen --
d100 11
a110 5
TclpDlopen(interp, pathPtr, loadHandle, unloadProcPtr)
    Tcl_Interp *interp;		/* Used for error reporting. */
    Tcl_Obj *pathPtr;		/* Name of the file containing the desired
				 * code (UTF-8). */
    Tcl_LoadHandle *loadHandle;	/* Filled with token for dynamically loaded
d112 1
a112 5
				 * (*unloadProcPtr)() to unload the file. */
    Tcl_FSUnloadFileProc **unloadProcPtr)
				/* Filled with address of Tcl_FSUnloadFileProc
				 * function which should be used for
				 * this file. */
d114 2
d117 1
d119 6
d126 10
a135 2
    CONST char *native;
    TclMacLoadInfo *loadInfo;
d137 1
a137 1
    native = Tcl_FSGetNativePath(pathPtr);
d139 1
a145 37
    loadInfo = (TclMacLoadInfo *) ckalloc(sizeof(TclMacLoadInfo));
    loadInfo->loaded = 0;
    loadInfo->fileSpec = fileSpec;
    loadInfo->connID = NULL;
    
    if (TryToLoad(interp, loadInfo, NULL) != TCL_OK) {
	ckfree(loadInfo);
	return TCL_ERROR;
    }

    *loadHandle = (Tcl_LoadHandle)loadInfo;
    *unloadProcPtr = &TclpUnloadFile;
    return TCL_OK;
}

/* 
 * See the comments about 'struct TclMacLoadInfo' above. This
 * function ensures the appropriate library or symbol is
 * loaded.
 */
static int
TryToLoad(Tcl_Interp *interp, TclMacLoadInfo *loadInfo, 
	  CONST char *sym /* native */) 
{
    CFragConnectionID connID;
    Ptr dummy;
    short fragFileRef, saveFileRef;
    Handle fragResource;
    UInt32 offset = 0;
    UInt32 length = kCFragGoesToEOF;
    Str255 errName;
    StringPtr fragName=NULL;

    if (loadInfo->loaded == 1) {
        return TCL_OK;
    }

d159 18
a176 21
	if (sym != NULL) {
	    UseResFile(fragFileRef);
	    fragResource = Get1Resource(kCFragResourceType, kCFragResourceID);
	    HLock(fragResource);
	    if (ResError() == noErr) {
		CfrgItem* srcItem;
		long itemCount, index;
		Ptr itemStart;

		itemCount = (*(CfrgHeaderPtrHand)fragResource)->itemCount;
		itemStart = &(*(CfrgHeaderPtrHand)fragResource)->arrayStart;
		for (index = 0; index < itemCount;
		     index++, itemStart += srcItem->itemSize) {
		    srcItem = (CfrgItem*)itemStart;
		    if (srcItem->archType != OUR_ARCH_TYPE) continue;
		    if (!strncasecmp(sym, (char *) srcItem->name + 1,
			    strlen(sym))) {
			offset = srcItem->codeOffset;
			length = srcItem->codeLength;
			fragName=srcItem->name;
		    }
a188 4
	if (sym == NULL) {
	    /* We just return */
	    return TCL_OK;
	}
d192 1
a192 1
     * Now we can attempt to load the fragment using the offset & length
d197 2
a198 1
    err = GetDiskFragment(&fileSpec, offset, length, fragName,
a199 1
    
d202 2
a203 3
	Tcl_AppendResult(interp, "couldn't load file \"", 
			 Tcl_GetString(pathPtr),
			 "\": ", errName, (char *) NULL);
a205 49

    loadInfo->connID = connID;
    loadInfo->loaded = 1;

    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * TclpFindSymbol --
 *
 *	Looks up a symbol, by name, through a handle associated with
 *	a previously loaded piece of code (shared library).
 *
 * Results:
 *	Returns a pointer to the function associated with 'symbol' if
 *	it is found.  Otherwise returns NULL and may leave an error
 *	message in the interp's result.
 *
 *----------------------------------------------------------------------
 */
Tcl_PackageInitProc*
TclpFindSymbol(interp, loadHandle, symbol) 
    Tcl_Interp *interp;
    Tcl_LoadHandle loadHandle;
    CONST char *symbol;
{
    Tcl_DString ds;
    Tcl_PackageInitProc *proc=NULL;
    TclMacLoadInfo *loadInfo = (TclMacLoadInfo *)loadHandle;
    Str255 symbolName;
    CFragSymbolClass symClass;
    OSErr err;
   
    if (loadInfo->loaded == 0) {
	int res;
	/*
	 * First thing we must do is infer the package name from the
	 * sym variable.  We do this by removing the '_Init'.
	 */
	Tcl_UtfToExternalDString(NULL, symbol, -1, &ds);
	Tcl_DStringSetLength(&ds, Tcl_DStringLength(&ds) - 5);
	res = TryToLoad(interp, loadInfo, Tcl_DStringValue(&ds));
	Tcl_DStringFree(&ds);
	if (res != TCL_OK) {
	    return NULL;
	}
    }
d207 3
a209 5
    Tcl_UtfToExternalDString(NULL, symbol, -1, &ds);
    strcpy((char *) symbolName + 1, Tcl_DStringValue(&ds));
    symbolName[0] = (unsigned) Tcl_DStringLength(&ds);
    err = FindSymbol(loadInfo->connID, symbolName, (Ptr *) &proc, &symClass);
    Tcl_DStringFree(&ds);
d214 8
a221 1
	return NULL;
d223 4
a226 1
    return proc;
d248 3
a250 3
TclpUnloadFile(loadHandle)
    Tcl_LoadHandle loadHandle;	/* loadHandle returned by a previous call
				 * to TclpDlopen().  The loadHandle is 
a253 5
    TclMacLoadInfo *loadInfo = (TclMacLoadInfo *)loadHandle;
    if (loadInfo->loaded) {
	CloseConnection((CFragConnectionID*) &(loadInfo->connID));
    }
    ckfree(loadInfo);
d278 1
a278 1
    CONST char *fileName,	/* Name of file containing package (already
@


1.2
log
@touched all Tcl files to ease next import.
@
text
@@


1.2.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.2.16.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@a78 19

/*
 * On MacOS, old shared libraries which contain many code fragments
 * cannot, it seems, be loaded in one go.  We need to look provide
 * the name of a code fragment while we load.  Since with the
 * separation of the 'load' and 'findsymbol' be do not necessarily
 * know a symbol name at load time, we have to store some further
 * information in a structure like this so we can ensure we load
 * properly in 'findsymbol' if the first attempts didn't work.
 */
typedef struct TclMacLoadInfo {
    int loaded;
    CFragConnectionID connID;
    FSSpec fileSpec;
} TclMacLoadInfo;

static int TryToLoad(Tcl_Interp *interp, TclMacLoadInfo *loadInfo, Tcl_Obj *pathPtr, 
		     CONST char *sym /* native */);

d83 1
a83 1
 * TclpDlopen --
d100 11
a110 5
TclpDlopen(interp, pathPtr, loadHandle, unloadProcPtr)
    Tcl_Interp *interp;		/* Used for error reporting. */
    Tcl_Obj *pathPtr;		/* Name of the file containing the desired
				 * code (UTF-8). */
    Tcl_LoadHandle *loadHandle;	/* Filled with token for dynamically loaded
d112 1
a112 5
				 * (*unloadProcPtr)() to unload the file. */
    Tcl_FSUnloadFileProc **unloadProcPtr;
				/* Filled with address of Tcl_FSUnloadFileProc
				 * function which should be used for
				 * this file. */
d114 2
d117 1
d119 17
a135 2
    CONST char *native;
    TclMacLoadInfo *loadInfo;
d137 1
a137 1
    native = Tcl_FSGetNativePath(pathPtr);
d139 1
a145 38
    loadInfo = (TclMacLoadInfo *) ckalloc(sizeof(TclMacLoadInfo));
    loadInfo->loaded = 0;
    loadInfo->fileSpec = fileSpec;
    loadInfo->connID = NULL;
    
    if (TryToLoad(interp, loadInfo, pathPtr, NULL) != TCL_OK) {
	ckfree((char*) loadInfo);
	return TCL_ERROR;
    }

    *loadHandle = (Tcl_LoadHandle)loadInfo;
    *unloadProcPtr = &TclpUnloadFile;
    return TCL_OK;
}

/* 
 * See the comments about 'struct TclMacLoadInfo' above. This
 * function ensures the appropriate library or symbol is
 * loaded.
 */
static int
TryToLoad(Tcl_Interp *interp, TclMacLoadInfo *loadInfo, Tcl_Obj *pathPtr,
	  CONST char *sym /* native */) 
{
    OSErr err;
    CFragConnectionID connID;
    Ptr dummy;
    short fragFileRef, saveFileRef;
    Handle fragResource;
    UInt32 offset = 0;
    UInt32 length = kCFragGoesToEOF;
    Str255 errName;
    StringPtr fragName=NULL;

    if (loadInfo->loaded == 1) {
        return TCL_OK;
    }

d156 1
a156 1
    fragFileRef = FSpOpenResFile(&loadInfo->fileSpec, fsRdPerm);
d159 18
a176 21
	if (sym != NULL) {
	    UseResFile(fragFileRef);
	    fragResource = Get1Resource(kCFragResourceType, kCFragResourceID);
	    HLock(fragResource);
	    if (ResError() == noErr) {
		CfrgItem* srcItem;
		long itemCount, index;
		Ptr itemStart;

		itemCount = (*(CfrgHeaderPtrHand)fragResource)->itemCount;
		itemStart = &(*(CfrgHeaderPtrHand)fragResource)->arrayStart;
		for (index = 0; index < itemCount;
		     index++, itemStart += srcItem->itemSize) {
		    srcItem = (CfrgItem*)itemStart;
		    if (srcItem->archType != OUR_ARCH_TYPE) continue;
		    if (!strncasecmp(sym, (char *) srcItem->name + 1,
			    strlen(sym))) {
			offset = srcItem->codeOffset;
			length = srcItem->codeLength;
			fragName=srcItem->name;
		    }
a188 4
	if (sym == NULL) {
	    /* We just return */
	    return TCL_OK;
	}
d192 1
a192 1
     * Now we can attempt to load the fragment using the offset & length
d197 2
a198 1
    err = GetDiskFragment(&loadInfo->fileSpec, offset, length, fragName,
a199 1
    
d202 2
a203 9
	if(pathPtr) {
	Tcl_AppendResult(interp, "couldn't load file \"", 
			 Tcl_GetString(pathPtr),
			 "\": ", errName, (char *) NULL);
	} else if(sym) {
	Tcl_AppendResult(interp, "couldn't load library \"", 
			 sym,
			 "\": ", errName, (char *) NULL);
	}
a205 49

    loadInfo->connID = connID;
    loadInfo->loaded = 1;

    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * TclpFindSymbol --
 *
 *	Looks up a symbol, by name, through a handle associated with
 *	a previously loaded piece of code (shared library).
 *
 * Results:
 *	Returns a pointer to the function associated with 'symbol' if
 *	it is found.  Otherwise returns NULL and may leave an error
 *	message in the interp's result.
 *
 *----------------------------------------------------------------------
 */
Tcl_PackageInitProc*
TclpFindSymbol(interp, loadHandle, symbol) 
    Tcl_Interp *interp;
    Tcl_LoadHandle loadHandle;
    CONST char *symbol;
{
    Tcl_DString ds;
    Tcl_PackageInitProc *proc=NULL;
    TclMacLoadInfo *loadInfo = (TclMacLoadInfo *)loadHandle;
    Str255 symbolName;
    CFragSymbolClass symClass;
    OSErr err;
   
    if (loadInfo->loaded == 0) {
	int res;
	/*
	 * First thing we must do is infer the package name from the
	 * sym variable.  We do this by removing the '_Init'.
	 */
	Tcl_UtfToExternalDString(NULL, symbol, -1, &ds);
	Tcl_DStringSetLength(&ds, Tcl_DStringLength(&ds) - 5);
	res = TryToLoad(interp, loadInfo, NULL, Tcl_DStringValue(&ds));
	Tcl_DStringFree(&ds);
	if (res != TCL_OK) {
	    return NULL;
	}
    }
d207 3
a209 5
    Tcl_UtfToExternalDString(NULL, symbol, -1, &ds);
    strcpy((char *) symbolName + 1, Tcl_DStringValue(&ds));
    symbolName[0] = (unsigned) Tcl_DStringLength(&ds);
    err = FindSymbol(loadInfo->connID, symbolName, (Ptr *) &proc, &symClass);
    Tcl_DStringFree(&ds);
d214 8
a221 1
	return NULL;
d223 4
a226 1
    return proc;
d248 3
a250 3
TclpUnloadFile(loadHandle)
    Tcl_LoadHandle loadHandle;	/* loadHandle returned by a previous call
				 * to TclpDlopen().  The loadHandle is 
a253 5
    TclMacLoadInfo *loadInfo = (TclMacLoadInfo *)loadHandle;
    if (loadInfo->loaded) {
	CloseConnection((CFragConnectionID*) &(loadInfo->connID));
    }
    ckfree((char*)loadInfo);
d278 1
a278 1
    CONST char *fileName,	/* Name of file containing package (already
@


1.1
log
@Initial revision
@
text
@d8 1
a8 1
 * Copyright (c) 1995-1996 Sun Microsystems, Inc.
d13 1
a13 1
 * RCS: @@(#) $Id: tclMacLoad.c,v 1.8 1999/01/26 03:53:23 jingham Exp $
d91 1
a91 1
 *	interp->result.
d100 1
a100 1
TclLoadFile(
d107 1
a107 1
    Tcl_PackageInitProc **proc2Ptr)
d110 3
d125 2
d134 6
a139 2
    *packageName = (char) tolower(*packageName);
    packageName[strlen(packageName) - 5] = NULL;
a140 1
    err = FSpLocationFromPath(strlen(fileName), fileName, &fileSpec);
d142 1
a142 1
	interp->result = "could not locate shared library";
d147 1
a147 1
     * See if this fragment has a 'cfrg' resource.  It will tell us were
d153 1
d211 3
a213 2
	interp->result =
	    "could not find Initialization routine in library";
d224 2
d227 27
@


1.1.1.1
log
@import dejagnu-1999-11-08 snapshot
@
text
@@


1.1.1.2
log
@Tcl 8.3 upgrade
@
text
@d8 1
a8 1
 * Copyright (c) 1995-1997 Sun Microsystems, Inc.
d13 1
a13 1
 * RCS: @@(#) $Id: tclMacLoad.c,v 1.6.8.1 2000/04/06 22:38:30 spolk Exp $
d91 1
a91 1
 *	the interp's result.
d100 1
a100 1
TclpLoadFile(
d107 1
a107 1
    Tcl_PackageInitProc **proc2Ptr,
a109 3
    ClientData *clientDataPtr)	/* Filled with token for dynamically loaded
				 * file which will be passed back to 
				 * TclpUnloadFile() to unload the file. */
a121 2
    Tcl_DString ds;
    char *native;
d129 2
a130 6
    Tcl_UtfToLower(packageName);
    *(Tcl_UtfAtIndex(packageName, Tcl_NumUtfChars(packageName, -1) - 5)) = 0;
    
    native = Tcl_UtfToExternalDString(NULL, fileName, -1, &ds);
    err = FSpLocationFromPath(strlen(native), native, &fileSpec);
    Tcl_DStringFree(&ds);
d132 1
d134 1
a134 1
	Tcl_SetResult(interp, "could not locate shared library", TCL_STATIC);
d139 1
a139 1
     * See if this fragment has a 'cfrg' resource.  It will tell us where
a144 1
     
d202 2
a203 3
	Tcl_SetResult(interp,
		"could not find Initialization routine in library",
		TCL_STATIC);
a213 2
    *clientDataPtr = (ClientData) connID;
    
a214 27
}

/*
 *----------------------------------------------------------------------
 *
 * TclpUnloadFile --
 *
 *	Unloads a dynamically loaded binary code file from memory.
 *	Code pointers in the formerly loaded file are no longer valid
 *	after calling this function.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Does nothing.  Can anything be done?
 *
 *----------------------------------------------------------------------
 */

void
TclpUnloadFile(clientData)
    ClientData clientData;	/* ClientData returned by a previous call
				 * to TclpLoadFile().  The clientData is 
				 * a token that represents the loaded 
				 * file. */
{
@


1.1.1.3
log
@import tcl 8.4.0
@
text
@d13 1
a13 1
 * RCS: @@(#) $Id: tclMacLoad.c,v 1.15 2002/07/18 16:26:04 vincentdarley Exp $
a78 19

/*
 * On MacOS, old shared libraries which contain many code fragments
 * cannot, it seems, be loaded in one go.  We need to look provide
 * the name of a code fragment while we load.  Since with the
 * separation of the 'load' and 'findsymbol' be do not necessarily
 * know a symbol name at load time, we have to store some further
 * information in a structure like this so we can ensure we load
 * properly in 'findsymbol' if the first attempts didn't work.
 */
typedef struct TclMacLoadInfo {
    int loaded;
    CFragConnectionID connID;
    FSSpec fileSpec;
} TclMacLoadInfo;

static int TryToLoad(Tcl_Interp *interp, TclMacLoadInfo *loadInfo, 
		     CONST char *sym /* native */) 

d83 1
a83 1
 * TclpDlopen --
d100 11
a110 5
TclpDlopen(interp, pathPtr, loadHandle, unloadProcPtr)
    Tcl_Interp *interp;		/* Used for error reporting. */
    Tcl_Obj *pathPtr;		/* Name of the file containing the desired
				 * code (UTF-8). */
    Tcl_LoadHandle *loadHandle;	/* Filled with token for dynamically loaded
d112 1
a112 5
				 * (*unloadProcPtr)() to unload the file. */
    Tcl_FSUnloadFileProc **unloadProcPtr)
				/* Filled with address of Tcl_FSUnloadFileProc
				 * function which should be used for
				 * this file. */
d114 2
d117 1
d119 6
d126 10
a135 2
    CONST char *native;
    TclMacLoadInfo *loadInfo;
d137 1
a137 1
    native = Tcl_FSGetNativePath(pathPtr);
d139 1
a145 37
    loadInfo = (TclMacLoadInfo *) ckalloc(sizeof(TclMacLoadInfo));
    loadInfo->loaded = 0;
    loadInfo->fileSpec = fileSpec;
    loadInfo->connID = NULL;
    
    if (TryToLoad(interp, loadInfo, NULL) != TCL_OK) {
	ckfree(loadInfo);
	return TCL_ERROR;
    }

    *loadHandle = (Tcl_LoadHandle)loadInfo;
    *unloadProcPtr = &TclpUnloadFile;
    return TCL_OK;
}

/* 
 * See the comments about 'struct TclMacLoadInfo' above. This
 * function ensures the appropriate library or symbol is
 * loaded.
 */
static int
TryToLoad(Tcl_Interp *interp, TclMacLoadInfo *loadInfo, 
	  CONST char *sym /* native */) 
{
    CFragConnectionID connID;
    Ptr dummy;
    short fragFileRef, saveFileRef;
    Handle fragResource;
    UInt32 offset = 0;
    UInt32 length = kCFragGoesToEOF;
    Str255 errName;
    StringPtr fragName=NULL;

    if (loadInfo->loaded == 1) {
        return TCL_OK;
    }

d159 18
a176 21
	if (sym != NULL) {
	    UseResFile(fragFileRef);
	    fragResource = Get1Resource(kCFragResourceType, kCFragResourceID);
	    HLock(fragResource);
	    if (ResError() == noErr) {
		CfrgItem* srcItem;
		long itemCount, index;
		Ptr itemStart;

		itemCount = (*(CfrgHeaderPtrHand)fragResource)->itemCount;
		itemStart = &(*(CfrgHeaderPtrHand)fragResource)->arrayStart;
		for (index = 0; index < itemCount;
		     index++, itemStart += srcItem->itemSize) {
		    srcItem = (CfrgItem*)itemStart;
		    if (srcItem->archType != OUR_ARCH_TYPE) continue;
		    if (!strncasecmp(sym, (char *) srcItem->name + 1,
			    strlen(sym))) {
			offset = srcItem->codeOffset;
			length = srcItem->codeLength;
			fragName=srcItem->name;
		    }
a188 4
	if (sym == NULL) {
	    /* We just return */
	    return TCL_OK;
	}
d192 1
a192 1
     * Now we can attempt to load the fragment using the offset & length
d197 2
a198 1
    err = GetDiskFragment(&fileSpec, offset, length, fragName,
a199 1
    
d202 2
a203 3
	Tcl_AppendResult(interp, "couldn't load file \"", 
			 Tcl_GetString(pathPtr),
			 "\": ", errName, (char *) NULL);
a205 49

    loadInfo->connID = connID;
    loadInfo->loaded = 1;

    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * TclpFindSymbol --
 *
 *	Looks up a symbol, by name, through a handle associated with
 *	a previously loaded piece of code (shared library).
 *
 * Results:
 *	Returns a pointer to the function associated with 'symbol' if
 *	it is found.  Otherwise returns NULL and may leave an error
 *	message in the interp's result.
 *
 *----------------------------------------------------------------------
 */
Tcl_PackageInitProc*
TclpFindSymbol(interp, loadHandle, symbol) 
    Tcl_Interp *interp;
    Tcl_LoadHandle loadHandle;
    CONST char *symbol;
{
    Tcl_DString ds;
    Tcl_PackageInitProc *proc=NULL;
    TclMacLoadInfo *loadInfo = (TclMacLoadInfo *)loadHandle;
    Str255 symbolName;
    CFragSymbolClass symClass;
    OSErr err;
   
    if (loadInfo->loaded == 0) {
	int res;
	/*
	 * First thing we must do is infer the package name from the
	 * sym variable.  We do this by removing the '_Init'.
	 */
	Tcl_UtfToExternalDString(NULL, symbol, -1, &ds);
	Tcl_DStringSetLength(&ds, Tcl_DStringLength(&ds) - 5);
	res = TryToLoad(interp, loadInfo, Tcl_DStringValue(&ds));
	Tcl_DStringFree(&ds);
	if (res != TCL_OK) {
	    return NULL;
	}
    }
d207 3
a209 5
    Tcl_UtfToExternalDString(NULL, symbol, -1, &ds);
    strcpy((char *) symbolName + 1, Tcl_DStringValue(&ds));
    symbolName[0] = (unsigned) Tcl_DStringLength(&ds);
    err = FindSymbol(loadInfo->connID, symbolName, (Ptr *) &proc, &symClass);
    Tcl_DStringFree(&ds);
d214 8
a221 1
	return NULL;
d223 4
a226 1
    return proc;
d248 3
a250 3
TclpUnloadFile(loadHandle)
    Tcl_LoadHandle loadHandle;	/* loadHandle returned by a previous call
				 * to TclpDlopen().  The loadHandle is 
a253 5
    TclMacLoadInfo *loadInfo = (TclMacLoadInfo *)loadHandle;
    if (loadInfo->loaded) {
	CloseConnection((CFragConnectionID*) &(loadInfo->connID));
    }
    ckfree(loadInfo);
d278 1
a278 1
    CONST char *fileName,	/* Name of file containing package (already
@


1.1.1.4
log
@import tcl 8.4.1
@
text
@d13 1
a13 1
 * RCS: @@(#) $Id: tclMacLoad.c,v 1.16 2002/10/09 11:54:26 das Exp $
d95 2
a96 2
static int TryToLoad(Tcl_Interp *interp, TclMacLoadInfo *loadInfo, Tcl_Obj *pathPtr, 
		     CONST char *sym /* native */);
d126 1
a126 1
    Tcl_FSUnloadFileProc **unloadProcPtr;
d133 1
d150 2
a151 2
    if (TryToLoad(interp, loadInfo, pathPtr, NULL) != TCL_OK) {
	ckfree((char*) loadInfo);
d166 1
a166 1
TryToLoad(Tcl_Interp *interp, TclMacLoadInfo *loadInfo, Tcl_Obj *pathPtr,
a168 1
    OSErr err;
d192 1
a192 1
    fragFileRef = FSpOpenResFile(&loadInfo->fileSpec, fsRdPerm);
d240 1
a240 1
    err = GetDiskFragment(&loadInfo->fileSpec, offset, length, fragName,
a244 1
	if(pathPtr) {
a247 5
	} else if(sym) {
	Tcl_AppendResult(interp, "couldn't load library \"", 
			 sym,
			 "\": ", errName, (char *) NULL);
	}
d293 1
a293 1
	res = TryToLoad(interp, loadInfo, NULL, Tcl_DStringValue(&ds));
d343 1
a343 1
    ckfree((char*)loadInfo);
@


