head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.58
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.56
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.54
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.52
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.50
	gdb_7_0-branch:1.5.0.48
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tcl8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.46
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.44
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.42
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.40
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.38
	gdb_6_5-2006-05-14-branchpoint:1.5
	readline_5_1-import-branch:1.5.0.36
	readline_5_1-import-branchpoint:1.5
	gdb_6_4-branch:1.5.0.34
	gdb_6_4-2005-11-01-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.32
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	ezannoni_pie-20040323-branch:1.5.0.30
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.28
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.26
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.24
	cagney_x86i386-20030821-branch:1.5.0.22
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.20
	gdb_6_0-2003-06-23-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.18
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.16
	cagney_writestrings-20030508-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.14
	cagney_fileio-20030521-branchpoint:1.5
	carlton_dictionary-20030430-merge:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.12
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.10
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.8
	cagney_lazyid-20030317-branchpoint:1.5
	offbyone-20030313-branch:1.5.0.6
	offbyone-20030313-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.4
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.2
	interps-20030202-branchpoint:1.5
	TCL8_4_1:1.1.1.4
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.2
	TCL_8_4_1:1.1.1.4
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.4
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TCL_8_4_0:1.1.1.3
	carlton_dictionary-branch:1.2.0.16
	carlton_dictionary-20020920-branchpoint:1.2
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.14
	gdb_5_3-branch:1.2.0.12
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.10
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.8
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.6
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TCL_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	dejagnu-2000-02-04:1.1.1.1
	dejagnu-2000-01-31:1.1.1.1
	dejagnu-2000-01-24:1.1.1.1
	dejagnu-2000-01-17:1.1.1.1
	dejagnu-2000-01-10:1.1.1.1
	dejagnu-2000-01-04:1.1.1.1
	dejagnu-1999-12-21:1.1.1.1
	dejagnu-1999-12-13:1.1.1.1
	dejagnu-1999-12-07:1.1.1.1
	dejagnu-1999-12-06:1.1.1.1
	dejagnu-1999-11-15:1.1.1.1
	dejagnu-1999-11-08:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.5
date	2003.01.21.19.40.11;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.26.19.47.59;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.37.06;	author kseitz;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2001.09.09.23.56.07;	author irox;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	99.11.09.01.28.43;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2002.09.27.21.49.09;	author kseitz;	state Exp;
branches;
next	;

1.3.4.1
date	2003.12.14.20.28.47;	author drow;	state Exp;
branches;
next	;

1.2.16.1
date	2002.12.23.19.40.33;	author carlton;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2003.02.07.19.18.16;	author carlton;	state Exp;
branches;
next	;

1.1.1.1
date	99.11.09.01.28.43;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.09.22.40.57;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.19.56.52;	author kseitz;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.11.26.20.01.36;	author hunt;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tcl 8.4.1
@
text
@/* 
 * tclMacFCmd.c --
 *
 * Implements the Macintosh specific portions of the file manipulation
 * subcommands of the "file" command.
 *
 * Copyright (c) 1996-1998 Sun Microsystems, Inc.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tclMacFCmd.c,v 1.18 2002/10/09 11:54:20 das Exp $
 */

#include "tclInt.h"
#include "tclMac.h"
#include "tclMacInt.h"
#include "tclPort.h"
#include <FSpCompat.h>
#include <MoreFilesExtras.h>
#include <Strings.h>
#include <Errors.h>
#include <FileCopy.h>
#include <DirectoryCopy.h>
#include <Script.h>
#include <string.h>
#include <Finder.h>
#include <Aliases.h>

/*
 * Callback for the file attributes code.
 */

static int		GetFileFinderAttributes _ANSI_ARGS_((Tcl_Interp *interp,
			    int objIndex, Tcl_Obj *fileName,
			    Tcl_Obj **attributePtrPtr));
static int		GetFileReadOnly _ANSI_ARGS_((Tcl_Interp *interp,
			    int objIndex, Tcl_Obj *fileName,
			    Tcl_Obj **readOnlyPtrPtr));
static int		SetFileFinderAttributes _ANSI_ARGS_((Tcl_Interp *interp,
			    int objIndex, Tcl_Obj *fileName,
			    Tcl_Obj *attributePtr));
static int		SetFileReadOnly _ANSI_ARGS_((Tcl_Interp *interp,
			    int objIndex, Tcl_Obj *fileName,
			    Tcl_Obj *readOnlyPtr));

/*
 * These are indeces into the tclpFileAttrsStrings table below.
 */

#define MAC_CREATOR_ATTRIBUTE	0
#define MAC_HIDDEN_ATTRIBUTE	1
#define MAC_READONLY_ATTRIBUTE	2
#define MAC_TYPE_ATTRIBUTE	3

/*
 * Global variables for the file attributes code.
 */

CONST char *tclpFileAttrStrings[] = {"-creator", "-hidden", "-readonly",
	"-type", (char *) NULL};
CONST TclFileAttrProcs tclpFileAttrProcs[] = {
	{GetFileFinderAttributes, SetFileFinderAttributes},
	{GetFileFinderAttributes, SetFileFinderAttributes},
	{GetFileReadOnly, SetFileReadOnly},
	{GetFileFinderAttributes, SetFileFinderAttributes}};

/*
 * File specific static data
 */

static long startSeed = 248923489;

/*
 * Prototypes for procedure only used in this file
 */

static pascal Boolean 	CopyErrHandler _ANSI_ARGS_((OSErr error, 
			    short failedOperation,
			    short srcVRefNum, long srcDirID,
			    ConstStr255Param srcName, short dstVRefNum,
			    long dstDirID,ConstStr255Param dstName));
static int		DoCopyDirectory _ANSI_ARGS_((CONST char *src,
			    CONST char *dst, Tcl_DString *errorPtr));
static int		DoCopyFile _ANSI_ARGS_((CONST char *src, 
			    CONST char *dst));
static int		DoCreateDirectory _ANSI_ARGS_((CONST char *path));
static int		DoDeleteFile _ANSI_ARGS_((CONST char *path));
static int		DoRemoveDirectory _ANSI_ARGS_((CONST char *path, 
			    int recursive, Tcl_DString *errorPtr));
static int		DoRenameFile _ANSI_ARGS_((CONST char *src,
			    CONST char *dst));
OSErr			FSpGetFLockCompat _ANSI_ARGS_((const FSSpec *specPtr, 
			    Boolean *lockedPtr));
static OSErr		GetFileSpecs _ANSI_ARGS_((CONST char *path, 
			    FSSpec *pathSpecPtr, FSSpec *dirSpecPtr,	
			    Boolean *pathExistsPtr, 
			    Boolean *pathIsDirectoryPtr));
static OSErr		MoveRename _ANSI_ARGS_((const FSSpec *srcSpecPtr, 
			    const FSSpec *dstSpecPtr, StringPtr copyName));
static int		Pstrequal _ANSI_ARGS_((ConstStr255Param stringA, 
			    ConstStr255Param stringB));
                 
/*
 *---------------------------------------------------------------------------
 *
 * TclpObjRenameFile, DoRenameFile --
 *
 *      Changes the name of an existing file or directory, from src to dst.
 *	If src and dst refer to the same file or directory, does nothing
 *	and returns success.  Otherwise if dst already exists, it will be
 *	deleted and replaced by src subject to the following conditions:
 *	    If src is a directory, dst may be an empty directory.
 *	    If src is a file, dst may be a file.
 *	In any other situation where dst already exists, the rename will
 *	fail.  
 *
 * Results:
 *	If the directory was successfully created, returns TCL_OK.
 *	Otherwise the return value is TCL_ERROR and errno is set to
 *	indicate the error.  Some possible values for errno are:
 *
 *	EACCES:     src or dst parent directory can't be read and/or written.
 *	EEXIST:	    dst is a non-empty directory.
 *	EINVAL:	    src is a root directory or dst is a subdirectory of src.
 *	EISDIR:	    dst is a directory, but src is not.
 *	ENOENT:	    src doesn't exist.  src or dst is "".
 *	ENOTDIR:    src is a directory, but dst is not.  
 *	EXDEV:	    src and dst are on different filesystems.
 *	
 * Side effects:
 *	The implementation of rename may allow cross-filesystem renames,
 *	but the caller should be prepared to emulate it with copy and
 *	delete if errno is EXDEV.
 *
 *---------------------------------------------------------------------------
 */

int 
TclpObjRenameFile(srcPathPtr, destPathPtr)
    Tcl_Obj *srcPathPtr;
    Tcl_Obj *destPathPtr;
{
    return DoRenameFile(Tcl_FSGetNativePath(srcPathPtr),
			Tcl_FSGetNativePath(destPathPtr));
}

static int
DoRenameFile(
    CONST char *src,		/* Pathname of file or dir to be renamed
				 * (native). */
    CONST char *dst)		/* New pathname of file or directory
				 * (native). */
{
    FSSpec srcFileSpec, dstFileSpec, dstDirSpec;
    OSErr err; 
    long srcID, dummy;
    Boolean srcIsDirectory, dstIsDirectory, dstExists, dstLocked;

    err = FSpLLocationFromPath(strlen(src), src, &srcFileSpec);
    if (err == noErr) {
	FSpGetDirectoryID(&srcFileSpec, &srcID, &srcIsDirectory);
    }
    if (err == noErr) {
        err = GetFileSpecs(dst, &dstFileSpec, &dstDirSpec, &dstExists, 
        	&dstIsDirectory);
    }
    if (err == noErr) {
	if (dstExists == 0) {
            err = MoveRename(&srcFileSpec, &dstDirSpec, dstFileSpec.name);
            goto end;
        }
        err = FSpGetFLockCompat(&dstFileSpec, &dstLocked);
        if (dstLocked) {
            FSpRstFLockCompat(&dstFileSpec);
        }
    }
    if (err == noErr) {
        if (srcIsDirectory) {
	    if (dstIsDirectory) {
		/*
		 * The following call will remove an empty directory.  If it
		 * fails, it's because it wasn't empty.
		 */
		 
                if (DoRemoveDirectory(dst, 0, NULL) != TCL_OK) {
                    return TCL_ERROR;
                }
                
                /*
		 * Now that that empty directory is gone, we can try
		 * renaming src.  If that fails, we'll put this empty
		 * directory back, for completeness.
		 */

		err = MoveRename(&srcFileSpec, &dstDirSpec, dstFileSpec.name);
                if (err != noErr) {
		    FSpDirCreateCompat(&dstFileSpec, smSystemScript, &dummy);
		    if (dstLocked) {
		        FSpSetFLockCompat(&dstFileSpec);
		    }
		}
	    } else {
	        errno = ENOTDIR;
	        return TCL_ERROR;
	    }
	} else {   
	    if (dstIsDirectory) {
		errno = EISDIR;
		return TCL_ERROR;
	    } else {                                
		/*
		 * Overwrite existing file by:
		 * 
		 * 1. Rename existing file to temp name.
		 * 2. Rename old file to new name.
		 * 3. If success, delete temp file.  If failure,
		 *    put temp file back to old name.
		 */

	        Str31 tmpName;
	        FSSpec tmpFileSpec;

	        err = GenerateUniqueName(dstFileSpec.vRefNum, &startSeed,
	        	dstFileSpec.parID, dstFileSpec.parID, tmpName);
	        if (err == noErr) {
	            err = FSpRenameCompat(&dstFileSpec, tmpName);
	        }
	        if (err == noErr) {
	            err = FSMakeFSSpecCompat(dstFileSpec.vRefNum,
	            	    dstFileSpec.parID, tmpName, &tmpFileSpec);
	        }
	        if (err == noErr) {
	            err = MoveRename(&srcFileSpec, &dstDirSpec, 
	            	    dstFileSpec.name);
	        }
	        if (err == noErr) {
		    FSpDeleteCompat(&tmpFileSpec);
		} else {
		    FSpDeleteCompat(&dstFileSpec);
		    FSpRenameCompat(&tmpFileSpec, dstFileSpec.name);
	            if (dstLocked) {
	            	FSpSetFLockCompat(&dstFileSpec);
	            }
	        }
	    }
   	}
    }    

    end:    
    if (err != noErr) {
	errno = TclMacOSErrorToPosixError(err);
	return TCL_ERROR;
    }
    return TCL_OK;
}

/*
 *--------------------------------------------------------------------------
 *
 * MoveRename --
 *
 *	Helper function for TclpRenameFile.  Renames a file or directory
 *	into the same directory or another directory.  The target name
 * 	must not already exist in the destination directory.
 *
 *	Don't use FSpMoveRenameCompat because it doesn't work with
 *	directories or with locked files. 
 *
 * Results:
 *	Returns a mac error indicating the cause of the failure.
 *
 * Side effects:
 *	Creates a temp file in the target directory to handle a rename
 *	between directories.
 *
 *--------------------------------------------------------------------------
 */
  
static OSErr		
MoveRename(
    const FSSpec *srcFileSpecPtr,   /* Source object. */
    const FSSpec *dstDirSpecPtr,    /* Destination directory. */
    StringPtr copyName)		    /* New name for object in destination 
    				     * directory. */
{
    OSErr err;
    long srcID, dstID;
    Boolean srcIsDir, dstIsDir;
    Str31 tmpName;
    FSSpec dstFileSpec, srcDirSpec, tmpSrcFileSpec, tmpDstFileSpec;
    Boolean locked;
    
    if (srcFileSpecPtr->parID == 1) {
        /*
         * Trying to rename a volume.
         */
          
        return badMovErr;
    }
    if (srcFileSpecPtr->vRefNum != dstDirSpecPtr->vRefNum) {
	/*
	 * Renaming across volumes.
	 */
	 
        return diffVolErr;
    }
    err = FSpGetFLockCompat(srcFileSpecPtr, &locked);
    if (locked) {
        FSpRstFLockCompat(srcFileSpecPtr);
    }
    if (err == noErr) {
	err = FSpGetDirectoryID(dstDirSpecPtr, &dstID, &dstIsDir);
    }
    if (err == noErr) {
        if (srcFileSpecPtr->parID == dstID) {
            /*
             * Renaming object within directory. 
             */
            
            err = FSpRenameCompat(srcFileSpecPtr, copyName);
            goto done; 
        }
        if (Pstrequal(srcFileSpecPtr->name, copyName)) {
	    /*
	     * Moving object to another directory (under same name). 
	     */
	 
	    err = FSpCatMoveCompat(srcFileSpecPtr, dstDirSpecPtr);
	    goto done; 
        } 
        err = FSpGetDirectoryID(srcFileSpecPtr, &srcID, &srcIsDir);
    } 
    if (err == noErr) {
        /*
         * Fullblown: rename source object to temp name, move temp to
         * dest directory, and rename temp to target.
         */
          
        err = GenerateUniqueName(srcFileSpecPtr->vRefNum, &startSeed,
       		srcFileSpecPtr->parID, dstID, tmpName);
        FSMakeFSSpecCompat(srcFileSpecPtr->vRefNum, srcFileSpecPtr->parID,
         	tmpName, &tmpSrcFileSpec);
        FSMakeFSSpecCompat(dstDirSpecPtr->vRefNum, dstID, tmpName,
         	&tmpDstFileSpec);
    }
    if (err == noErr) {
        err = FSpRenameCompat(srcFileSpecPtr, tmpName);
    }
    if (err == noErr) {
        err = FSpCatMoveCompat(&tmpSrcFileSpec, dstDirSpecPtr);
        if (err == noErr) {
            err = FSpRenameCompat(&tmpDstFileSpec, copyName);
            if (err == noErr) {
                goto done;
            }
            FSMakeFSSpecCompat(srcFileSpecPtr->vRefNum, srcFileSpecPtr->parID,
             	    NULL, &srcDirSpec);
            FSpCatMoveCompat(&tmpDstFileSpec, &srcDirSpec);
        }                 
        FSpRenameCompat(&tmpSrcFileSpec, srcFileSpecPtr->name);
    }
    
    done:
    if (locked != false) {
    	if (err == noErr) {
	    FSMakeFSSpecCompat(dstDirSpecPtr->vRefNum, 
	    	    dstID, copyName, &dstFileSpec);
            FSpSetFLockCompat(&dstFileSpec);
        } else {
            FSpSetFLockCompat(srcFileSpecPtr);
        }
    }
    return err;
}     

/*
 *---------------------------------------------------------------------------
 *
 * TclpObjCopyFile, DoCopyFile --
 *
 *      Copy a single file (not a directory).  If dst already exists and
 *	is not a directory, it is removed.
 *
 * Results:
 *	If the file was successfully copied, returns TCL_OK.  Otherwise
 *	the return value is TCL_ERROR and errno is set to indicate the
 *	error.  Some possible values for errno are:
 *
 *	EACCES:     src or dst parent directory can't be read and/or written.
 *	EISDIR:	    src or dst is a directory.
 *	ENOENT:	    src doesn't exist.  src or dst is "".
 *
 * Side effects:
 *      This procedure will also copy symbolic links, block, and
 *      character devices, and fifos.  For symbolic links, the links 
 *      themselves will be copied and not what they point to.  For the
 *	other special file types, the directory entry will be copied and
 *	not the contents of the device that it refers to.
 *
 *---------------------------------------------------------------------------
 */
 
int 
TclpObjCopyFile(srcPathPtr, destPathPtr)
    Tcl_Obj *srcPathPtr;
    Tcl_Obj *destPathPtr;
{
    return DoCopyFile(Tcl_FSGetNativePath(srcPathPtr),
		      Tcl_FSGetNativePath(destPathPtr));
}

static int
DoCopyFile(
    CONST char *src,		/* Pathname of file to be copied (native). */
    CONST char *dst)		/* Pathname of file to copy to (native). */
{
    OSErr err, dstErr;
    Boolean dstExists, dstIsDirectory, dstLocked;
    FSSpec srcFileSpec, dstFileSpec, dstDirSpec, tmpFileSpec;
    Str31 tmpName;
	
    err = FSpLLocationFromPath(strlen(src), src, &srcFileSpec);
    if (err == noErr) {
        err = GetFileSpecs(dst, &dstFileSpec, &dstDirSpec, &dstExists,
        	&dstIsDirectory);
    }
    if (dstExists) {
        if (dstIsDirectory) {
            errno = EISDIR;
            return TCL_ERROR;
        }
        err = FSpGetFLockCompat(&dstFileSpec, &dstLocked);
        if (dstLocked) {
            FSpRstFLockCompat(&dstFileSpec);
        }
        
        /*
         * Backup dest file.
         */
         
        dstErr = GenerateUniqueName(dstFileSpec.vRefNum, &startSeed, dstFileSpec.parID, 
    	        dstFileSpec.parID, tmpName);
        if (dstErr == noErr) {
            dstErr = FSpRenameCompat(&dstFileSpec, tmpName);
        }   
    }
    if (err == noErr) {
    	err = FSpFileCopy(&srcFileSpec, &dstDirSpec, 
    		(StringPtr) dstFileSpec.name, NULL, 0, true);
    }
    if ((dstExists != false) && (dstErr == noErr)) {
        FSMakeFSSpecCompat(dstFileSpec.vRefNum, dstFileSpec.parID,
        	tmpName, &tmpFileSpec);
	if (err == noErr) {
	    /* 
	     * Delete backup file. 
	     */
	     
	    FSpDeleteCompat(&tmpFileSpec);
	} else {
	
	    /* 
	     * Restore backup file.
	     */
	     
	    FSpDeleteCompat(&dstFileSpec);
	    FSpRenameCompat(&tmpFileSpec, dstFileSpec.name);
	    if (dstLocked) {
	        FSpSetFLockCompat(&dstFileSpec);
	    }
	}
    }
    
    if (err != noErr) {
	errno = TclMacOSErrorToPosixError(err);
	return TCL_ERROR;
    }
    return TCL_OK;
}

/*
 *---------------------------------------------------------------------------
 *
 * TclpObjDeleteFile, DoDeleteFile --
 *
 *      Removes a single file (not a directory).
 *
 * Results:
 *	If the file was successfully deleted, returns TCL_OK.  Otherwise
 *	the return value is TCL_ERROR and errno is set to indicate the
 *	error.  Some possible values for errno are:
 *
 *	EACCES:     a parent directory can't be read and/or written.
 *	EISDIR:	    path is a directory.
 *	ENOENT:	    path doesn't exist or is "".
 *
 * Side effects:
 *      The file is deleted, even if it is read-only.
 *
 *---------------------------------------------------------------------------
 */

int 
TclpObjDeleteFile(pathPtr)
    Tcl_Obj *pathPtr;
{
    return DoDeleteFile(Tcl_FSGetNativePath(pathPtr));
}

static int
DoDeleteFile(
    CONST char *path)		/* Pathname of file to be removed (native). */
{
    OSErr err;
    FSSpec fileSpec;
    Boolean isDirectory;
    long dirID;
    
    err = FSpLLocationFromPath(strlen(path), path, &fileSpec);
    if (err == noErr) {
	/*
     	 * Since FSpDeleteCompat will delete an empty directory, make sure
     	 * that this isn't a directory first.
         */
        
        FSpGetDirectoryID(&fileSpec, &dirID, &isDirectory);
	if (isDirectory == true) {
            errno = EISDIR;
            return TCL_ERROR;
        }
    }
    err = FSpDeleteCompat(&fileSpec);
    if (err == fLckdErr) {
    	FSpRstFLockCompat(&fileSpec);
    	err = FSpDeleteCompat(&fileSpec);
    	if (err != noErr) {
    	    FSpSetFLockCompat(&fileSpec);
    	}
    }
    if (err != noErr) {
	errno = TclMacOSErrorToPosixError(err);
	return TCL_ERROR;
    }
    return TCL_OK;
}

/*
 *---------------------------------------------------------------------------
 *
 * TclpObjCreateDirectory, DoCreateDirectory --
 *
 *      Creates the specified directory.  All parent directories of the
 *	specified directory must already exist.  The directory is
 *	automatically created with permissions so that user can access
 *	the new directory and create new files or subdirectories in it.
 *
 * Results:
 *	If the directory was successfully created, returns TCL_OK.
 *	Otherwise the return value is TCL_ERROR and errno is set to
 *	indicate the error.  Some possible values for errno are:
 *
 *	EACCES:     a parent directory can't be read and/or written.
 *	EEXIST:	    path already exists.
 *	ENOENT:	    a parent directory doesn't exist.
 *
 * Side effects:
 *      A directory is created with the current umask, except that
 *	permission for u+rwx will always be added.
 *
 *---------------------------------------------------------------------------
 */

int 
TclpObjCreateDirectory(pathPtr)
    Tcl_Obj *pathPtr;
{
    return DoCreateDirectory(Tcl_FSGetNativePath(pathPtr));
}

static int
DoCreateDirectory(
    CONST char *path)		/* Pathname of directory to create (native). */
{
    OSErr err;
    FSSpec dirSpec;
    long outDirID;
	
    err = FSpLocationFromPath(strlen(path), path, &dirSpec);
    if (err == noErr) {
        err = dupFNErr;		/* EEXIST. */
    } else if (err == fnfErr) {
        err = FSpDirCreateCompat(&dirSpec, smSystemScript, &outDirID);
    } 
    
    if (err != noErr) {
	errno = TclMacOSErrorToPosixError(err);
	return TCL_ERROR;
    }
    return TCL_OK;
}

/*
 *---------------------------------------------------------------------------
 *
 * TclpObjCopyDirectory, DoCopyDirectory --
 *
 *      Recursively copies a directory.  The target directory dst must
 *	not already exist.  Note that this function does not merge two
 *	directory hierarchies, even if the target directory is an an
 *	empty directory.
 *
 * Results:
 *	If the directory was successfully copied, returns TCL_OK.
 *	Otherwise the return value is TCL_ERROR, errno is set to indicate
 *	the error, and the pathname of the file that caused the error
 *	is stored in errorPtr.  See TclpCreateDirectory and TclpCopyFile
 *	for a description of possible values for errno.
 *
 * Side effects:
 *      An exact copy of the directory hierarchy src will be created
 *	with the name dst.  If an error occurs, the error will
 *      be returned immediately, and remaining files will not be
 *	processed.
 *
 *---------------------------------------------------------------------------
 */

int 
TclpObjCopyDirectory(srcPathPtr, destPathPtr, errorPtr)
    Tcl_Obj *srcPathPtr;
    Tcl_Obj *destPathPtr;
    Tcl_Obj **errorPtr;
{
    Tcl_DString ds;
    int ret;
    ret = DoCopyDirectory(Tcl_FSGetNativePath(srcPathPtr),
			  Tcl_FSGetNativePath(destPathPtr), &ds);
    if (ret != TCL_OK) {
	*errorPtr = Tcl_NewStringObj(Tcl_DStringValue(&ds), -1);
	Tcl_DStringFree(&ds);
	Tcl_IncrRefCount(*errorPtr);
    }
    return ret;
}

static int
DoCopyDirectory(
    CONST char *src,		/* Pathname of directory to be copied
				 * (Native). */
    CONST char *dst,		/* Pathname of target directory (Native). */
    Tcl_DString *errorPtr)	/* If non-NULL, uninitialized or free
				 * DString filled with UTF-8 name of file
				 * causing error. */
{
    OSErr err, saveErr;
    long srcID, tmpDirID;
    FSSpec srcFileSpec, dstFileSpec, dstDirSpec, tmpDirSpec, tmpFileSpec;
    Boolean srcIsDirectory, srcLocked;
    Boolean dstIsDirectory, dstExists;
    Str31 tmpName;

    err = FSpLocationFromPath(strlen(src), src, &srcFileSpec);
    if (err == noErr) {
    	err = FSpGetDirectoryID(&srcFileSpec, &srcID, &srcIsDirectory);
    }
    if (err == noErr) {
        if (srcIsDirectory == false) {
            err = afpObjectTypeErr;	/* ENOTDIR. */
        }
    }
    if (err == noErr) {
        err = GetFileSpecs(dst, &dstFileSpec, &dstDirSpec, &dstExists,
        	&dstIsDirectory);
    }
    if (dstExists) {
        if (dstIsDirectory == false) {
            err = afpObjectTypeErr;	/* ENOTDIR. */
        } else {
            err = dupFNErr;		/* EEXIST. */
        }
    }
    if (err != noErr) {
        goto done;
    }        
    if ((srcFileSpec.vRefNum == dstFileSpec.vRefNum) &&
    	    (srcFileSpec.parID == dstFileSpec.parID) &&
            (Pstrequal(srcFileSpec.name, dstFileSpec.name) != 0)) {
        /*
         * Copying on top of self.  No-op.
         */
                    
        goto done;
    }

    /*
     * This algorthm will work making a copy of the source directory in
     * the current directory with a new name, in a new directory with the
     * same name, and in a new directory with a new name:
     *
     * 1. Make dstDir/tmpDir.
     * 2. Copy srcDir/src to dstDir/tmpDir/src
     * 3. Rename dstDir/tmpDir/src to dstDir/tmpDir/dst (if necessary).
     * 4. CatMove dstDir/tmpDir/dst to dstDir/dst.
     * 5. Remove dstDir/tmpDir.
     */
                
    err = FSpGetFLockCompat(&srcFileSpec, &srcLocked);
    if (srcLocked) {
        FSpRstFLockCompat(&srcFileSpec);
    }
    if (err == noErr) {
        err = GenerateUniqueName(dstFileSpec.vRefNum, &startSeed, dstFileSpec.parID, 
    	        dstFileSpec.parID, tmpName);
    }
    if (err == noErr) {
        FSMakeFSSpecCompat(dstFileSpec.vRefNum, dstFileSpec.parID,
        	tmpName, &tmpDirSpec);
        err = FSpDirCreateCompat(&tmpDirSpec, smSystemScript, &tmpDirID);
    }
    if (err == noErr) {
	err = FSpDirectoryCopy(&srcFileSpec, &tmpDirSpec, NULL, NULL, 0, true,
	    	CopyErrHandler);
    }
    
    /* 
     * Even if the Copy failed, Rename/Move whatever did get copied to the
     * appropriate final destination, if possible.  
     */
     
    saveErr = err;
    err = noErr;
    if (Pstrequal(srcFileSpec.name, dstFileSpec.name) == 0) {
        err = FSMakeFSSpecCompat(tmpDirSpec.vRefNum, tmpDirID, 
        	srcFileSpec.name, &tmpFileSpec);
        if (err == noErr) {
            err = FSpRenameCompat(&tmpFileSpec, dstFileSpec.name);
        }
    }
    if (err == noErr) {
        err = FSMakeFSSpecCompat(tmpDirSpec.vRefNum, tmpDirID,
        	dstFileSpec.name, &tmpFileSpec);
    }
    if (err == noErr) {
        err = FSpCatMoveCompat(&tmpFileSpec, &dstDirSpec);
    }
    if (err == noErr) {
        if (srcLocked) {
            FSpSetFLockCompat(&dstFileSpec);
        }
    }
    
    FSpDeleteCompat(&tmpDirSpec);
    
    if (saveErr != noErr) {
        err = saveErr;
    }
    
    done:
    if (err != noErr) {
        errno = TclMacOSErrorToPosixError(err);
        if (errorPtr != NULL) {
            Tcl_ExternalToUtfDString(NULL, dst, -1, errorPtr);
        }
        return TCL_ERROR;
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * CopyErrHandler --
 *
 *      This procedure is called from the MoreFiles procedure 
 *      FSpDirectoryCopy whenever an error occurs.
 *
 * Results:
 *      False if the condition should not be considered an error, true
 *      otherwise.
 *
 * Side effects:
 *      Since FSpDirectoryCopy() is called only after removing any 
 *      existing target directories, there shouldn't be any errors.
 *      
 *----------------------------------------------------------------------
 */

static pascal Boolean 
CopyErrHandler(
    OSErr error,		/* Error that occured */
    short failedOperation,	/* operation that caused the error */
    short srcVRefNum,		/* volume ref number of source */
    long srcDirID,		/* directory id of source */
    ConstStr255Param srcName,	/* name of source */
    short dstVRefNum,		/* volume ref number of dst */
    long dstDirID,		/* directory id of dst */
    ConstStr255Param dstName)	/* name of dst directory */
{
    return true;
}

/*
 *---------------------------------------------------------------------------
 *
 * TclpObjRemoveDirectory, DoRemoveDirectory --
 *
 *	Removes directory (and its contents, if the recursive flag is set).
 *
 * Results:
 *	If the directory was successfully removed, returns TCL_OK.
 *	Otherwise the return value is TCL_ERROR, errno is set to indicate
 *	the error, and the pathname of the file that caused the error
 *	is stored in errorPtr.  Some possible values for errno are:
 *
 *	EACCES:     path directory can't be read and/or written.
 *	EEXIST:	    path is a non-empty directory.
 *	EINVAL:	    path is a root directory.
 *	ENOENT:	    path doesn't exist or is "".
 * 	ENOTDIR:    path is not a directory.
 *
 * Side effects:
 *	Directory removed.  If an error occurs, the error will be returned
 *	immediately, and remaining files will not be deleted.
 *
 *---------------------------------------------------------------------------
 */
 
int 
TclpObjRemoveDirectory(pathPtr, recursive, errorPtr)
    Tcl_Obj *pathPtr;
    int recursive;
    Tcl_Obj **errorPtr;
{
    Tcl_DString ds;
    int ret;
    ret = DoRemoveDirectory(Tcl_FSGetNativePath(pathPtr),recursive, &ds);
    if (ret != TCL_OK) {
	*errorPtr = Tcl_NewStringObj(Tcl_DStringValue(&ds), -1);
	Tcl_DStringFree(&ds);
	Tcl_IncrRefCount(*errorPtr);
    }
    return ret;
}

static int
DoRemoveDirectory(
    CONST char *path,		/* Pathname of directory to be removed
				 * (native). */
    int recursive,		/* If non-zero, removes directories that
				 * are nonempty.  Otherwise, will only remove
				 * empty directories. */
    Tcl_DString *errorPtr)	/* If non-NULL, uninitialized or free
				 * DString filled with UTF-8 name of file
				 * causing error. */
{
    OSErr err;
    FSSpec fileSpec;
    long dirID;
    int locked;
    Boolean isDirectory;
    CInfoPBRec pb;
    Str255 fileName;


    locked = 0;
    err = FSpLocationFromPath(strlen(path), path, &fileSpec);
    if (err != noErr) {
        goto done;
    }   

    /*
     * Since FSpDeleteCompat will delete a file, make sure this isn't
     * a file first.
     */
         
    isDirectory = 1;
    FSpGetDirectoryID(&fileSpec, &dirID, &isDirectory);
    if (isDirectory == 0) {
        errno = ENOTDIR;
        return TCL_ERROR;
    }
    
    err = FSpDeleteCompat(&fileSpec);
    if (err == fLckdErr) {
        locked = 1;
    	FSpRstFLockCompat(&fileSpec);
    	err = FSpDeleteCompat(&fileSpec);
    }
    if (err == noErr) {
	return TCL_OK;
    }
    if (err != fBsyErr) {
        goto done;
    }
     
    if (recursive == 0) {
	/*
	 * fBsyErr means one of three things: file busy, directory not empty, 
	 * or working directory control block open.  Determine if directory
	 * is empty. If directory is not empty, return EEXIST.
	 */

	pb.hFileInfo.ioVRefNum = fileSpec.vRefNum;
	pb.hFileInfo.ioDirID = dirID;
	pb.hFileInfo.ioNamePtr = (StringPtr) fileName;
	pb.hFileInfo.ioFDirIndex = 1;
	if (PBGetCatInfoSync(&pb) == noErr) {
	    err = dupFNErr;	/* EEXIST */
	    goto done;
	}
    }
	
    /*
     * DeleteDirectory removes a directory and all its contents, including
     * any locked files.  There is no interface to get the name of the 
     * file that caused the error, if an error occurs deleting this tree,
     * unless we rewrite DeleteDirectory ourselves.
     */
	 
    err = DeleteDirectory(fileSpec.vRefNum, dirID, NULL);

    done:
    if (err != noErr) {
	if (errorPtr != NULL) {
	    Tcl_UtfToExternalDString(NULL, path, -1, errorPtr);
	}
        if (locked) {
            FSpSetFLockCompat(&fileSpec);
        }
    	errno = TclMacOSErrorToPosixError(err);
    	return TCL_ERROR;
    }
    return TCL_OK;
}
			    
/*
 *---------------------------------------------------------------------------
 *
 * GetFileSpecs --
 *
 *	Gets FSSpecs for the specified path and its parent directory.
 *
 * Results:
 *	The return value is noErr if there was no error getting FSSpecs,
 *	otherwise it is an error describing the problem.  Fills buffers 
 *	with information, as above.  
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
 */

static OSErr
GetFileSpecs(
    CONST char *path,		/* The path to query. */
    FSSpec *pathSpecPtr,	/* Filled with information about path. */
    FSSpec *dirSpecPtr,		/* Filled with information about path's
    				 * parent directory. */
    Boolean *pathExistsPtr,	/* Set to true if path actually exists, 
    				 * false if it doesn't or there was an 
    				 * error reading the specified path. */
    Boolean *pathIsDirectoryPtr)/* Set to true if path is itself a directory,
    				 * otherwise false. */
{
    CONST char *dirName;
    OSErr err;
    int argc;
    CONST char **argv;
    long d;
    Tcl_DString buffer;
        
    *pathExistsPtr = false;
    *pathIsDirectoryPtr = false;
    
    Tcl_DStringInit(&buffer);
    Tcl_SplitPath(path, &argc, &argv);
    if (argc == 1) {
        dirName = ":";
    } else {
        dirName = Tcl_JoinPath(argc - 1, argv, &buffer);
    }
    err = FSpLocationFromPath(strlen(dirName), dirName, dirSpecPtr);
    Tcl_DStringFree(&buffer);
    ckfree((char *) argv);

    if (err == noErr) {
        err = FSpLocationFromPath(strlen(path), path, pathSpecPtr);
        if (err == noErr) {
            *pathExistsPtr = true;
            err = FSpGetDirectoryID(pathSpecPtr, &d, pathIsDirectoryPtr);
        } else if (err == fnfErr) {
            err = noErr;
        }
    }
    return err;
}

/*
 *-------------------------------------------------------------------------
 *
 * FSpGetFLockCompat --
 *
 *	Determines if there exists a software lock on the specified
 *	file.  The software lock could prevent the file from being 
 *	renamed or moved.
 *
 * Results:
 *	Standard macintosh error code.  
 *
 * Side effects:
 *	None.
 *
 *
 *-------------------------------------------------------------------------
 */
 
OSErr
FSpGetFLockCompat(
    const FSSpec *specPtr,	/* File to query. */
    Boolean *lockedPtr)		/* Set to true if file is locked, false
    				 * if it isn't or there was an error reading
    				 * specified file. */
{
    CInfoPBRec pb;
    OSErr err;
    
    pb.hFileInfo.ioVRefNum = specPtr->vRefNum;
    pb.hFileInfo.ioDirID = specPtr->parID;
    pb.hFileInfo.ioNamePtr = (StringPtr) specPtr->name;
    pb.hFileInfo.ioFDirIndex = 0;
    
    err = PBGetCatInfoSync(&pb);
    if ((err == noErr) && (pb.hFileInfo.ioFlAttrib & 0x01)) {
        *lockedPtr = true;
    } else {
        *lockedPtr = false;
    }
    return err;
}
    
/*
 *----------------------------------------------------------------------
 *
 * Pstrequal --
 *
 *      Pascal string compare. 
 *
 * Results:
 *      Returns 1 if strings equal, 0 otherwise.
 *
 * Side effects:
 *      None.
 *      
 *----------------------------------------------------------------------
 */

static int 
Pstrequal (
    ConstStr255Param stringA,	/* Pascal string A */
    ConstStr255Param stringB)   /* Pascal string B */
{
    int i, len;
    
    len = *stringA;
    for (i = 0; i <= len; i++) {
        if (*stringA++ != *stringB++) {
            return 0;
        }
    }
    return 1;
}
    
/*
 *----------------------------------------------------------------------
 *
 * GetFileFinderAttributes --
 *
 *	Returns a Tcl_Obj containing the value of a file attribute
 *	which is part of the FInfo record. Which attribute is controlled
 *	by objIndex.
 *
 * Results:
 *      Returns a standard TCL error. If the return value is TCL_OK,
 *	the new creator or file type object is put into attributePtrPtr.
 *	The object will have ref count 0. If there is an error,
 *	attributePtrPtr is not touched.
 *
 * Side effects:
 *      A new object is allocated if the file is valid.
 *      
 *----------------------------------------------------------------------
 */

static int
GetFileFinderAttributes(
    Tcl_Interp *interp,		/* The interp to report errors with. */
    int objIndex,		/* The index of the attribute option. */
    Tcl_Obj *fileName,	/* The name of the file (UTF-8). */
    Tcl_Obj **attributePtrPtr)	/* A pointer to return the object with. */
{
    OSErr err;
    FSSpec fileSpec;
    FInfo finfo;
    CONST char *native;

    native=Tcl_FSGetNativePath(fileName);
    err = FSpLLocationFromPath(strlen(native),
	    native, &fileSpec);

    if (err == noErr) {
    	err = FSpGetFInfo(&fileSpec, &finfo);
    }
    
    if (err == noErr) {
    	switch (objIndex) {
    	    case MAC_CREATOR_ATTRIBUTE:
    	    	*attributePtrPtr = Tcl_NewOSTypeObj(finfo.fdCreator);
    	    	break;
    	    case MAC_HIDDEN_ATTRIBUTE:
    	    	*attributePtrPtr = Tcl_NewBooleanObj(finfo.fdFlags
    	    		& kIsInvisible);
    	    	break;
    	    case MAC_TYPE_ATTRIBUTE:
    	    	*attributePtrPtr = Tcl_NewOSTypeObj(finfo.fdType);
    	    	break;
    	}
    } else if (err == fnfErr) {
    	long dirID;
    	Boolean isDirectory = 0;
    	
    	err = FSpGetDirectoryID(&fileSpec, &dirID, &isDirectory);
    	if ((err == noErr) && isDirectory) {
    	    if (objIndex == MAC_HIDDEN_ATTRIBUTE) {
    	    	*attributePtrPtr = Tcl_NewBooleanObj(0);
    	    } else {
    	    	*attributePtrPtr = Tcl_NewOSTypeObj('Fldr');
    	    }
    	}
    }
    
    if (err != noErr) {
    	errno = TclMacOSErrorToPosixError(err);
    	Tcl_AppendStringsToObj(Tcl_GetObjResult(interp), 
    		"could not read \"", Tcl_GetString(fileName), "\": ",
    		Tcl_PosixError(interp), (char *) NULL);
    	return TCL_ERROR;
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * GetFileReadOnly --
 *
 *	Returns a Tcl_Obj containing a Boolean value indicating whether
 *	or not the file is read-only. The object will have ref count 0.
 *	This procedure just checks the Finder attributes; it does not
 *	check AppleShare sharing attributes.
 *
 * Results:
 *      Returns a standard TCL error. If the return value is TCL_OK,
 *	the new creator type object is put into readOnlyPtrPtr.
 *	If there is an error, readOnlyPtrPtr is not touched.
 *
 * Side effects:
 *      A new object is allocated if the file is valid.
 *      
 *----------------------------------------------------------------------
 */

static int
GetFileReadOnly(
    Tcl_Interp *interp,		/* The interp to report errors with. */
    int objIndex,		/* The index of the attribute. */
    Tcl_Obj *fileName,	/* The name of the file (UTF-8). */
    Tcl_Obj **readOnlyPtrPtr)	/* A pointer to return the object with. */
{
    OSErr err;
    FSSpec fileSpec;
    CInfoPBRec paramBlock;
    CONST char *native;

    native=Tcl_FSGetNativePath(fileName);
    err = FSpLLocationFromPath(strlen(native),
	    native, &fileSpec);
    
    if (err == noErr) {
    	if (err == noErr) {
    	    paramBlock.hFileInfo.ioCompletion = NULL;
    	    paramBlock.hFileInfo.ioNamePtr = fileSpec.name;
    	    paramBlock.hFileInfo.ioVRefNum = fileSpec.vRefNum;
    	    paramBlock.hFileInfo.ioFDirIndex = 0;
    	    paramBlock.hFileInfo.ioDirID = fileSpec.parID;
    	    err = PBGetCatInfo(&paramBlock, 0);
    	    if (err == noErr) {
    	    
    	    	/*
    	    	 * For some unknown reason, the Mac does not give
    	    	 * symbols for the bits in the ioFlAttrib field.
    	    	 * 1 -> locked.
    	    	 */
    	    
    	    	*readOnlyPtrPtr = Tcl_NewBooleanObj(
    	    		paramBlock.hFileInfo.ioFlAttrib & 1);
    	    }
    	}
    }
    if (err != noErr) {
    	errno = TclMacOSErrorToPosixError(err);
    	Tcl_AppendStringsToObj(Tcl_GetObjResult(interp), 
    		"could not read \"", Tcl_GetString(fileName), "\": ",
    		Tcl_PosixError(interp), (char *) NULL);
    	return TCL_ERROR;
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * SetFileFinderAttributes --
 *
 *	Sets the file to the creator or file type given by attributePtr.
 *	objIndex determines whether the creator or file type is set.
 *
 * Results:
 *	Returns a standard TCL error.
 *
 * Side effects:
 *      The file's attribute is set.
 *      
 *----------------------------------------------------------------------
 */

static int
SetFileFinderAttributes(
    Tcl_Interp *interp,		/* The interp to report errors with. */
    int objIndex,		/* The index of the attribute. */
    Tcl_Obj *fileName,	/* The name of the file (UTF-8). */
    Tcl_Obj *attributePtr)	/* The command line object. */
{
    OSErr err;
    FSSpec fileSpec;
    FInfo finfo;
    CONST char *native;

    native=Tcl_FSGetNativePath(fileName);
    err = FSpLLocationFromPath(strlen(native),
	    native, &fileSpec);
    
    if (err == noErr) {
    	err = FSpGetFInfo(&fileSpec, &finfo);
    }
    
    if (err == noErr) {
    	switch (objIndex) {
    	    case MAC_CREATOR_ATTRIBUTE:
    	    	if (Tcl_GetOSTypeFromObj(interp, attributePtr,
    	    		&finfo.fdCreator) != TCL_OK) {
    	    	    return TCL_ERROR;
    	    	}
    	    	break;
    	    case MAC_HIDDEN_ATTRIBUTE: {
    	    	int hidden;
    	    	
    	    	if (Tcl_GetBooleanFromObj(interp, attributePtr, &hidden)
    	    		!= TCL_OK) {
    	    	    return TCL_ERROR;
    	    	}
    	    	if (hidden) {
    	    	    finfo.fdFlags |= kIsInvisible;
    	    	} else {
    	    	    finfo.fdFlags &= ~kIsInvisible;
    	    	}
    	    	break;
    	    }
    	    case MAC_TYPE_ATTRIBUTE:
    	    	if (Tcl_GetOSTypeFromObj(interp, attributePtr,
    	    		&finfo.fdType) != TCL_OK) {
    	    	    return TCL_ERROR;
    	    	}
    	    	break;
    	}
    	err = FSpSetFInfo(&fileSpec, &finfo);
    } else if (err == fnfErr) {
    	long dirID;
    	Boolean isDirectory = 0;
    	
    	err = FSpGetDirectoryID(&fileSpec, &dirID, &isDirectory);
    	if ((err == noErr) && isDirectory) {
    	    Tcl_Obj *resultPtr = Tcl_GetObjResult(interp);
    	    Tcl_AppendStringsToObj(resultPtr, "cannot set ",
    	    	    tclpFileAttrStrings[objIndex], ": \"",
    	    	    Tcl_GetString(fileName), "\" is a directory", (char *) NULL);
    	    return TCL_ERROR;
    	}
    }
    
    if (err != noErr) {
    	errno = TclMacOSErrorToPosixError(err);
    	Tcl_AppendStringsToObj(Tcl_GetObjResult(interp), 
    		"could not read \"", Tcl_GetString(fileName), "\": ",
    		Tcl_PosixError(interp), (char *) NULL);
    	return TCL_ERROR;
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * SetFileReadOnly --
 *
 *	Sets the file to be read-only according to the Boolean value
 *	given by hiddenPtr.
 *
 * Results:
 *	Returns a standard TCL error.
 *
 * Side effects:
 *      The file's attribute is set.
 *      
 *----------------------------------------------------------------------
 */

static int
SetFileReadOnly(
    Tcl_Interp *interp,		/* The interp to report errors with. */
    int objIndex,		/* The index of the attribute. */
    Tcl_Obj *fileName,	/* The name of the file (UTF-8). */
    Tcl_Obj *readOnlyPtr)	/* The command line object. */
{
    OSErr err;
    FSSpec fileSpec;
    HParamBlockRec paramBlock;
    int hidden;
    CONST char *native;

    native=Tcl_FSGetNativePath(fileName);
    err = FSpLLocationFromPath(strlen(native),
	    native, &fileSpec);
    
    if (err == noErr) {
    	if (Tcl_GetBooleanFromObj(interp, readOnlyPtr, &hidden) != TCL_OK) {
    	    return TCL_ERROR;
    	}
    
    	paramBlock.fileParam.ioCompletion = NULL;
    	paramBlock.fileParam.ioNamePtr = fileSpec.name;
    	paramBlock.fileParam.ioVRefNum = fileSpec.vRefNum;
    	paramBlock.fileParam.ioDirID = fileSpec.parID;
    	if (hidden) {
    	    err = PBHSetFLock(&paramBlock, 0);
    	} else {
    	    err = PBHRstFLock(&paramBlock, 0);
    	}
    }
    
    if (err == fnfErr) {
    	long dirID;
    	Boolean isDirectory = 0;
    	err = FSpGetDirectoryID(&fileSpec, &dirID, &isDirectory);
    	if ((err == noErr) && isDirectory) {
    	    Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
    	    	    "cannot set a directory to read-only when File Sharing is turned off",
    	    	    (char *) NULL);
    	    return TCL_ERROR;
    	} else {
    	    err = fnfErr;
    	}
    }
    
    if (err != noErr) {
    	errno = TclMacOSErrorToPosixError(err);
    	Tcl_AppendStringsToObj(Tcl_GetObjResult(interp), 
    		"could not read \"", Tcl_GetString(fileName), "\": ",
    		Tcl_PosixError(interp), (char *) NULL);
    	return TCL_ERROR;
    }
    return TCL_OK;
}

/*
 *---------------------------------------------------------------------------
 *
 * TclpObjListVolumes --
 *
 *	Lists the currently mounted volumes
 *
 * Results:
 *	The list of volumes.
 *
 * Side effects:
 *	None
 *
 *---------------------------------------------------------------------------
 */
Tcl_Obj*
TclpObjListVolumes(void)
{
    HParamBlockRec pb;
    Str255 name;
    OSErr theError = noErr;
    Tcl_Obj *resultPtr, *elemPtr;
    short volIndex = 1;
    Tcl_DString dstr;

    resultPtr = Tcl_NewObj();
        
    /*
     * We use two facts:
     * 1) The Mac volumes are enumerated by the ioVolIndex parameter of
     * the HParamBlockRec.  They run through the integers contiguously, 
     * starting at 1.  
     * 2) PBHGetVInfoSync returns an error when you ask for a volume index
     * that does not exist.
     * 
     */
        
    while ( 1 ) {
        pb.volumeParam.ioNamePtr = (StringPtr) &name;
        pb.volumeParam.ioVolIndex = volIndex;
                
        theError = PBHGetVInfoSync(&pb);

        if ( theError != noErr ) {
            break;
        }
        
        Tcl_ExternalToUtfDString(NULL, (CONST char *)&name[1], name[0], &dstr);
        elemPtr = Tcl_NewStringObj(Tcl_DStringValue(&dstr),
		Tcl_DStringLength(&dstr));
        Tcl_AppendToObj(elemPtr, ":", 1);
        Tcl_ListObjAppendElement(NULL, resultPtr, elemPtr);
        
        Tcl_DStringFree(&dstr);
                
        volIndex++;             
    }

    Tcl_IncrRefCount(resultPtr);
    return resultPtr;
}

/*
 *---------------------------------------------------------------------------
 *
 * TclpObjNormalizePath --
 *
 *	This function scans through a path specification and replaces
 *	it, in place, with a normalized version.  On MacOS, this means
 *	resolving all aliases present in the path and replacing the head of
 *	pathPtr with the absolute case-sensitive path to the last file or
 *	directory that could be validated in the path.
 *
 * Results:
 *	The new 'nextCheckpoint' value, giving as far as we could
 *	understand in the path.
 *
 * Side effects:
 *	The pathPtr string, which must contain a valid path, is
 *	possibly modified in place.
 *
 *---------------------------------------------------------------------------
 */

int
TclpObjNormalizePath(interp, pathPtr, nextCheckpoint)
    Tcl_Interp *interp;
    Tcl_Obj *pathPtr;
    int nextCheckpoint;
{
    #define MAXMACFILENAMELEN 31  /* assumed to be < sizeof(StrFileName) */
 
    StrFileName fileName;
    StringPtr fileNamePtr;
    int fileNameLen,newPathLen;
    Handle newPathHandle;
    OSErr err;
    short vRefNum;
    long dirID;
    Boolean isDirectory;
    Boolean wasAlias=FALSE;
    FSSpec fileSpec, lastFileSpec;
    
    Tcl_DString nativeds;

    char cur;
    int firstCheckpoint=nextCheckpoint, lastCheckpoint;
    int origPathLen;
    char *path = Tcl_GetStringFromObj(pathPtr,&origPathLen);
    
    {
	int currDirValid=0;    
	/*
	 * check if substring to first ':' after initial
	 * nextCheckpoint is a valid relative or absolute
	 * path to a directory, if not we return without
	 * normalizing anything
	 */
	
	while (1) {
	    cur = path[nextCheckpoint];
	    if (cur == ':' || cur == 0) {
		if (cur == ':') { 
		    /* jump over separator */
		    nextCheckpoint++; cur = path[nextCheckpoint]; 
		} 
		Tcl_UtfToExternalDString(NULL,path,nextCheckpoint,&nativeds);
		err = FSpLLocationFromPath(Tcl_DStringLength(&nativeds), 
					  Tcl_DStringValue(&nativeds), 
					  &fileSpec);
		Tcl_DStringFree(&nativeds);
		if (err == noErr) {
			lastFileSpec=fileSpec;
			err = ResolveAliasFile(&fileSpec, true, &isDirectory, 
				       &wasAlias);
			if (err == noErr) {
		    err = FSpGetDirectoryID(&fileSpec, &dirID, &isDirectory);
		    currDirValid = ((err == noErr) && isDirectory);
		    vRefNum = fileSpec.vRefNum;
		    }
		}
		break;
	    }
	    nextCheckpoint++;
	}
	
	if(!currDirValid) {
	    /* can't determine root dir, bail out */
	    return firstCheckpoint; 
	}
    }
	
    /*
     * Now vRefNum and dirID point to a valid
     * directory, so walk the rest of the path
     * ( code adapted from FSpLocationFromPath() )
     */

    lastCheckpoint=nextCheckpoint;
    while (1) {
	cur = path[nextCheckpoint];
	if (cur == ':' || cur == 0) {
	    fileNameLen=nextCheckpoint-lastCheckpoint;
	    fileNamePtr=fileName;
	    if(fileNameLen==0) {
		if (cur == ':') {
		    /*
		     * special case for empty dirname i.e. encountered
		     * a '::' path component: get parent dir of currDir
		     */
		    fileName[0]=2;
		    strcpy((char *) fileName + 1, "::");
		    lastCheckpoint--;
		} else {
		    /*
		     * empty filename, i.e. want FSSpec for currDir
		     */
		    fileNamePtr=NULL;
		}
	    } else {
		Tcl_UtfToExternalDString(NULL,&path[lastCheckpoint],
					 fileNameLen,&nativeds);
		fileNameLen=Tcl_DStringLength(&nativeds);
		if(fileNameLen > MAXMACFILENAMELEN) { 
		    err = bdNamErr;
		} else {
		fileName[0]=fileNameLen;
		strncpy((char *) fileName + 1, Tcl_DStringValue(&nativeds), 
			fileNameLen);
		}
		Tcl_DStringFree(&nativeds);
	    }
	    if(err == noErr)
	    err=FSMakeFSSpecCompat(vRefNum, dirID, fileNamePtr, &fileSpec);
	    if(err != noErr) {
		if(err != fnfErr) {
		    /*
		     * this can occur if trying to get parent of a root
		     * volume via '::' or when using an illegal
		     * filename; revert to last checkpoint and stop
		     * processing path further
		     */
		    err=FSMakeFSSpecCompat(vRefNum, dirID, NULL, &fileSpec);
		    if(err != noErr) {
			/* should never happen, bail out */
			return firstCheckpoint; 
		    }
		    nextCheckpoint=lastCheckpoint;
		    cur = path[lastCheckpoint];
		}
    		break; /* arrived at nonexistent file or dir */
	    } else {
		/* fileSpec could point to an alias, resolve it */
		lastFileSpec=fileSpec;
		err = ResolveAliasFile(&fileSpec, true, &isDirectory, 
				       &wasAlias);
		if (err != noErr || !isDirectory) {
		    break; /* fileSpec doesn't point to a dir */
		}
	    }
	    if (cur == 0) break; /* arrived at end of path */
	    
	    /* fileSpec points to possibly nonexisting subdirectory; validate */
	    err = FSpGetDirectoryID(&fileSpec, &dirID, &isDirectory);
	    if (err != noErr || !isDirectory) {
	        break; /* fileSpec doesn't point to existing dir */
	    }
	    vRefNum = fileSpec.vRefNum;
    	
	    /* found a new valid subdir in path, continue processing path */
	    lastCheckpoint=nextCheckpoint+1;
	}
	wasAlias=FALSE;
	nextCheckpoint++;
    }
    
    if (wasAlias)
    	fileSpec=lastFileSpec;
    
    /*
     * fileSpec now points to a possibly nonexisting file or dir
     *  inside a valid dir; get full path name to it
     */
    
    err=FSpPathFromLocation(&fileSpec, &newPathLen, &newPathHandle);
    if(err != noErr) {
	return firstCheckpoint; /* should not see any errors here, bail out */
    }
    
    HLock(newPathHandle);
    Tcl_ExternalToUtfDString(NULL,*newPathHandle,newPathLen,&nativeds);
    if (cur != 0) {
	/* not at end, append remaining path */
    	if ( newPathLen==0 || (*(*newPathHandle+(newPathLen-1))!=':' && path[nextCheckpoint] !=':')) {
	    Tcl_DStringAppend(&nativeds, ":" , 1);
	}
	Tcl_DStringAppend(&nativeds, &path[nextCheckpoint], 
			  strlen(&path[nextCheckpoint]));
    }
    DisposeHandle(newPathHandle);
    
    fileNameLen=Tcl_DStringLength(&nativeds);
    Tcl_SetStringObj(pathPtr,Tcl_DStringValue(&nativeds),fileNameLen);
    Tcl_DStringFree(&nativeds);
    
    return nextCheckpoint+(fileNameLen-origPathLen);
}

@


1.4
log
@touched all sources to ease next import
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tclMacFCmd.c,v 1.6.8.1 2000/04/06 22:38:30 spolk Exp $
d28 1
d35 1
a35 1
			    int objIndex, CONST char *fileName,
d38 1
a38 1
			    int objIndex, CONST char *fileName,
d41 1
a41 1
			    int objIndex, CONST char *fileName,
d44 1
a44 1
			    int objIndex, CONST char *fileName,
d60 1
a60 1
char *tclpFileAttrStrings[] = {"-creator", "-hidden", "-readonly",
d68 5
a94 2
static OSErr		GenerateUniqueName _ANSI_ARGS_((short vRefNum, 
			    long dirID1, long dirID2, Str31 uniqueName));
d107 1
a107 1
 * TclpRenameFile, DoRenameFile --
d139 4
a142 6
int
TclpRenameFile( 
    CONST char *src,		/* Pathname of file or dir to be renamed
				 * (UTF-8). */
    CONST char *dst)		/* New pathname of file or directory
				 * (UTF-8). */
d144 2
a145 10
    int result;
    Tcl_DString srcString, dstString;

    Tcl_UtfToExternalDString(NULL, src, -1, &srcString);
    Tcl_UtfToExternalDString(NULL, dst, -1, &dstString);
    result = DoRenameFile(Tcl_DStringValue(&srcString),
	    Tcl_DStringValue(&dstString));
    Tcl_DStringFree(&srcString);
    Tcl_DStringFree(&dstString);
    return result;
d160 1
a160 1
    err = FSpLocationFromPath(strlen(src), src, &srcFileSpec);
d224 1
a224 1
	        err = GenerateUniqueName(dstFileSpec.vRefNum, 
d340 1
a340 1
        err = GenerateUniqueName(srcFileSpecPtr->vRefNum, 
d380 1
a380 1
 * TclpCopyFile, DoCopyFile --
d405 6
a410 14
TclpCopyFile(
    CONST char *src,		/* Pathname of file to be copied (UTF-8). */
    CONST char *dst)		/* Pathname of file to copy to (UTF-8). */
{
    int result;
    Tcl_DString srcString, dstString;

    Tcl_UtfToExternalDString(NULL, src, -1, &srcString);
    Tcl_UtfToExternalDString(NULL, dst, -1, &dstString);
    result = DoCopyFile(Tcl_DStringValue(&srcString), 
    	    Tcl_DStringValue(&dstString));
    Tcl_DStringFree(&srcString);
    Tcl_DStringFree(&dstString);
    return result;
d423 1
a423 1
    err = FSpLocationFromPath(strlen(src), src, &srcFileSpec);
d442 1
a442 1
        dstErr = GenerateUniqueName(dstFileSpec.vRefNum, dstFileSpec.parID, 
d485 1
a485 1
 * TclpDeleteFile, DoDeleteFile --
d504 3
a506 3
int
TclpDeleteFile( 
    CONST char *path)		/* Pathname of file to be removed (UTF-8). */
d508 1
a508 7
    int result;
    Tcl_DString pathString;

    Tcl_UtfToExternalDString(NULL, path, -1, &pathString);
    result = DoDeleteFile(Tcl_DStringValue(&pathString));
    Tcl_DStringFree(&pathString);
    return result;
d520 1
a520 1
    err = FSpLocationFromPath(strlen(path), path, &fileSpec);
d551 1
a551 1
 * TclpCreateDirectory, DoCreateDirectory --
d574 3
a576 3
int
TclpCreateDirectory(
    CONST char *path)		/* Pathname of directory to create (UTF-8). */
d578 1
a578 7
    int result;
    Tcl_DString pathString;

    Tcl_UtfToExternalDString(NULL, path, -1, &pathString);
    result = DoCreateDirectory(Tcl_DStringValue(&pathString));
    Tcl_DStringFree(&pathString);
    return result;
d606 1
a606 1
 * TclpCopyDirectory, DoCopyDirectory --
d629 16
a644 19
int
TclpCopyDirectory(
    CONST char *src,		/* Pathname of directory to be copied
				 * (UTF-8). */
    CONST char *dst,		/* Pathname of target directory (UTF-8). */
    Tcl_DString *errorPtr)	/* If non-NULL, uninitialized or free
				 * DString filled with UTF-8 name of file
				 * causing error. */
{
    int result;
    Tcl_DString srcString, dstString;

    Tcl_UtfToExternalDString(NULL, src, -1, &srcString);
    Tcl_UtfToExternalDString(NULL, dst, -1, &dstString);
    result = DoCopyDirectory(Tcl_DStringValue(&srcString),
	    Tcl_DStringValue(&dstString), errorPtr);
    Tcl_DStringFree(&srcString);
    Tcl_DStringFree(&dstString);
    return result;
d650 2
a651 2
				 * (UTF-8). */
    CONST char *dst,		/* Pathname of target directory (UTF-8). */
d713 1
a713 1
        err = GenerateUniqueName(dstFileSpec.vRefNum, dstFileSpec.parID, 
d722 1
a722 1
	err = FSpDirectoryCopy(&srcFileSpec, &tmpDirSpec, NULL, 0, true,
d806 1
a806 1
 * TclpRemoveDirectory, DoRemoveDirectory --
d829 15
a843 20
int
TclpRemoveDirectory(
    CONST char *path,		/* Pathname of directory to be removed
				 * (UTF-8). */
    int recursive,		/* If non-zero, removes directories that
				 * are nonempty.  Otherwise, will only remove
				 * empty directories. */
    Tcl_DString *errorPtr)	/* If non-NULL, uninitialized or free
				 * DString filled with UTF-8 name of file
				 * causing error. */
{
    int result;
    Tcl_DString pathString;

    Tcl_UtfToExternalDString(NULL, path, -1, &pathString);
    result = DoRemoveDirectory(Tcl_DStringValue(&pathString), recursive, 
    	    errorPtr);
    Tcl_DStringFree(&pathString);

    return result;
a939 63
 * GenerateUniqueName --
 *
 * 	Generate a filename that is not in either of the two specified
 *	directories (on the same volume). 
 *
 * Results:
 *	Standard macintosh error.  On success, uniqueName is filled with 
 *	the name of the temporary file.
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
 */ 
 
static OSErr
GenerateUniqueName(
    short vRefNum,		/* Volume on which the following directories
    				 * are located. */		
    long dirID1,		/* ID of first directory. */
    long dirID2,		/* ID of second directory.  May be the same
    				 * as the first. */
    Str31 uniqueName)		/* Filled with filename for a file that is
    				 * not located in either of the above two
    				 * directories. */
{
    OSErr err;
    long i;
    CInfoPBRec pb;
    static unsigned char hexStr[16] = "0123456789ABCDEF";
    static long startSeed = 248923489;
    
    pb.hFileInfo.ioVRefNum = vRefNum;
    pb.hFileInfo.ioFDirIndex = 0;
    pb.hFileInfo.ioNamePtr = uniqueName;

    while (1) {
        startSeed++;		
	pb.hFileInfo.ioNamePtr[0] = 8;
	for (i = 1; i <= 8; i++) {
	    pb.hFileInfo.ioNamePtr[i] = hexStr[((startSeed >> ((8-i)*4)) & 0xf)];
	}
	pb.hFileInfo.ioDirID = dirID1;
	err = PBGetCatInfoSync(&pb);
	if (err == fnfErr) {
	    if (dirID1 != dirID2) {
		pb.hFileInfo.ioDirID = dirID2;
		err = PBGetCatInfoSync(&pb);
	    }
	    if (err == fnfErr) {
	        return noErr;
	    }
	}
	if (err == noErr) {
	    continue;
	} 
	return err;
    }
} 

/*
 *---------------------------------------------------------------------------
 *
d967 1
a967 1
    char *dirName;
d970 1
a970 1
    char **argv;
d1100 1
a1100 1
    CONST char *fileName,	/* The name of the file (UTF-8). */
d1106 1
a1106 1
    Tcl_DString pathString;
d1108 3
a1110 4
    Tcl_UtfToExternalDString(NULL, fileName, -1, &pathString);
    err = FSpLocationFromPath(Tcl_DStringLength(&pathString),
	    Tcl_DStringValue(&pathString), &fileSpec);
    Tcl_DStringFree(&pathString);
d1146 1
a1146 1
    		"could not read \"", fileName, "\": ",
d1178 1
a1178 1
    CONST char *fileName,	/* The name of the file (UTF-8). */
d1184 1
a1184 1
    Tcl_DString pathString;
d1186 3
a1188 4
    Tcl_UtfToExternalDString(NULL, fileName, -1, &pathString);
    err = FSpLocationFromPath(Tcl_DStringLength(&pathString),
	    Tcl_DStringValue(&pathString), &fileSpec);
    Tcl_DStringFree(&pathString);
d1214 1
a1214 1
    		"could not read \"", fileName, "\": ",
d1242 1
a1242 1
    CONST char *fileName,	/* The name of the file (UTF-8). */
d1248 1
a1248 1
    Tcl_DString pathString;
d1250 3
a1252 4
    Tcl_UtfToExternalDString(NULL, fileName, -1, &pathString);
    err = FSpLocationFromPath(Tcl_DStringLength(&pathString),
	    Tcl_DStringValue(&pathString), &fileSpec);
    Tcl_DStringFree(&pathString);
d1297 1
a1297 1
    	    	    fileName, "\" is a directory", (char *) NULL);
d1305 1
a1305 1
    		"could not read \"", fileName, "\": ",
d1333 1
a1333 1
    CONST char *fileName,	/* The name of the file (UTF-8). */
d1340 1
a1340 1
    Tcl_DString pathString;
d1342 3
a1344 4
    Tcl_UtfToExternalDString(NULL, fileName, -1, &pathString);
    err = FSpLocationFromPath(Tcl_DStringLength(&pathString),
	    Tcl_DStringValue(&pathString), &fileSpec);
    Tcl_DStringFree(&pathString);
d1379 1
a1379 1
    		"could not read \"", fileName, "\": ",
d1389 1
a1389 1
 * TclpListVolumes --
d1394 1
a1394 3
 *	A standard Tcl result.  Will always be TCL_OK, since there is no way
 *	that this command can fail.  Also, the interpreter's result is set to 
 *	the list of volumes.
d1401 2
a1402 3
int
TclpListVolumes( 
		Tcl_Interp *interp)    /* Interpreter to which to pass the volume list */
d1433 1
a1433 1
        Tcl_ExternalToUtfDString(NULL, (char *) &name[1], name[0], &dstr);  
d1437 1
a1437 1
        Tcl_ListObjAppendElement(interp, resultPtr, elemPtr);
d1443 209
a1651 3
        
    Tcl_SetObjResult(interp, resultPtr);
    return TCL_OK;      
@


1.3
log
@touched all sources to ease next import
@
text
@@


1.3.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tclMacFCmd.c,v 1.18 2002/10/09 11:54:20 das Exp $
a27 1
#include <Aliases.h>
d34 1
a34 1
			    int objIndex, Tcl_Obj *fileName,
d37 1
a37 1
			    int objIndex, Tcl_Obj *fileName,
d40 1
a40 1
			    int objIndex, Tcl_Obj *fileName,
d43 1
a43 1
			    int objIndex, Tcl_Obj *fileName,
d59 1
a59 1
CONST char *tclpFileAttrStrings[] = {"-creator", "-hidden", "-readonly",
a66 5
/*
 * File specific static data
 */

static long startSeed = 248923489;
d89 2
d103 1
a103 1
 * TclpObjRenameFile, DoRenameFile --
d135 6
a140 4
int 
TclpObjRenameFile(srcPathPtr, destPathPtr)
    Tcl_Obj *srcPathPtr;
    Tcl_Obj *destPathPtr;
d142 10
a151 2
    return DoRenameFile(Tcl_FSGetNativePath(srcPathPtr),
			Tcl_FSGetNativePath(destPathPtr));
d166 1
a166 1
    err = FSpLLocationFromPath(strlen(src), src, &srcFileSpec);
d230 1
a230 1
	        err = GenerateUniqueName(dstFileSpec.vRefNum, &startSeed,
d346 1
a346 1
        err = GenerateUniqueName(srcFileSpecPtr->vRefNum, &startSeed,
d386 1
a386 1
 * TclpObjCopyFile, DoCopyFile --
d411 14
a424 6
TclpObjCopyFile(srcPathPtr, destPathPtr)
    Tcl_Obj *srcPathPtr;
    Tcl_Obj *destPathPtr;
{
    return DoCopyFile(Tcl_FSGetNativePath(srcPathPtr),
		      Tcl_FSGetNativePath(destPathPtr));
d437 1
a437 1
    err = FSpLLocationFromPath(strlen(src), src, &srcFileSpec);
d456 1
a456 1
        dstErr = GenerateUniqueName(dstFileSpec.vRefNum, &startSeed, dstFileSpec.parID, 
d499 1
a499 1
 * TclpObjDeleteFile, DoDeleteFile --
d518 3
a520 3
int 
TclpObjDeleteFile(pathPtr)
    Tcl_Obj *pathPtr;
d522 7
a528 1
    return DoDeleteFile(Tcl_FSGetNativePath(pathPtr));
d540 1
a540 1
    err = FSpLLocationFromPath(strlen(path), path, &fileSpec);
d571 1
a571 1
 * TclpObjCreateDirectory, DoCreateDirectory --
d594 3
a596 3
int 
TclpObjCreateDirectory(pathPtr)
    Tcl_Obj *pathPtr;
d598 7
a604 1
    return DoCreateDirectory(Tcl_FSGetNativePath(pathPtr));
d632 1
a632 1
 * TclpObjCopyDirectory, DoCopyDirectory --
d655 19
a673 16
int 
TclpObjCopyDirectory(srcPathPtr, destPathPtr, errorPtr)
    Tcl_Obj *srcPathPtr;
    Tcl_Obj *destPathPtr;
    Tcl_Obj **errorPtr;
{
    Tcl_DString ds;
    int ret;
    ret = DoCopyDirectory(Tcl_FSGetNativePath(srcPathPtr),
			  Tcl_FSGetNativePath(destPathPtr), &ds);
    if (ret != TCL_OK) {
	*errorPtr = Tcl_NewStringObj(Tcl_DStringValue(&ds), -1);
	Tcl_DStringFree(&ds);
	Tcl_IncrRefCount(*errorPtr);
    }
    return ret;
d679 2
a680 2
				 * (Native). */
    CONST char *dst,		/* Pathname of target directory (Native). */
d742 1
a742 1
        err = GenerateUniqueName(dstFileSpec.vRefNum, &startSeed, dstFileSpec.parID, 
d751 1
a751 1
	err = FSpDirectoryCopy(&srcFileSpec, &tmpDirSpec, NULL, NULL, 0, true,
d835 1
a835 1
 * TclpObjRemoveDirectory, DoRemoveDirectory --
d858 20
a877 15
int 
TclpObjRemoveDirectory(pathPtr, recursive, errorPtr)
    Tcl_Obj *pathPtr;
    int recursive;
    Tcl_Obj **errorPtr;
{
    Tcl_DString ds;
    int ret;
    ret = DoRemoveDirectory(Tcl_FSGetNativePath(pathPtr),recursive, &ds);
    if (ret != TCL_OK) {
	*errorPtr = Tcl_NewStringObj(Tcl_DStringValue(&ds), -1);
	Tcl_DStringFree(&ds);
	Tcl_IncrRefCount(*errorPtr);
    }
    return ret;
d974 63
d1064 1
a1064 1
    CONST char *dirName;
d1067 1
a1067 1
    CONST char **argv;
d1197 1
a1197 1
    Tcl_Obj *fileName,	/* The name of the file (UTF-8). */
d1203 1
a1203 1
    CONST char *native;
d1205 4
a1208 3
    native=Tcl_FSGetNativePath(fileName);
    err = FSpLLocationFromPath(strlen(native),
	    native, &fileSpec);
d1244 1
a1244 1
    		"could not read \"", Tcl_GetString(fileName), "\": ",
d1276 1
a1276 1
    Tcl_Obj *fileName,	/* The name of the file (UTF-8). */
d1282 1
a1282 1
    CONST char *native;
d1284 4
a1287 3
    native=Tcl_FSGetNativePath(fileName);
    err = FSpLLocationFromPath(strlen(native),
	    native, &fileSpec);
d1313 1
a1313 1
    		"could not read \"", Tcl_GetString(fileName), "\": ",
d1341 1
a1341 1
    Tcl_Obj *fileName,	/* The name of the file (UTF-8). */
d1347 1
a1347 1
    CONST char *native;
d1349 4
a1352 3
    native=Tcl_FSGetNativePath(fileName);
    err = FSpLLocationFromPath(strlen(native),
	    native, &fileSpec);
d1397 1
a1397 1
    	    	    Tcl_GetString(fileName), "\" is a directory", (char *) NULL);
d1405 1
a1405 1
    		"could not read \"", Tcl_GetString(fileName), "\": ",
d1433 1
a1433 1
    Tcl_Obj *fileName,	/* The name of the file (UTF-8). */
d1440 1
a1440 1
    CONST char *native;
d1442 4
a1445 3
    native=Tcl_FSGetNativePath(fileName);
    err = FSpLLocationFromPath(strlen(native),
	    native, &fileSpec);
d1480 1
a1480 1
    		"could not read \"", Tcl_GetString(fileName), "\": ",
d1490 1
a1490 1
 * TclpObjListVolumes --
d1495 3
a1497 1
 *	The list of volumes.
d1504 3
a1506 2
Tcl_Obj*
TclpObjListVolumes(void)
d1537 1
a1537 1
        Tcl_ExternalToUtfDString(NULL, (CONST char *)&name[1], name[0], &dstr);
d1541 1
a1541 1
        Tcl_ListObjAppendElement(NULL, resultPtr, elemPtr);
d1547 3
a1549 209

    Tcl_IncrRefCount(resultPtr);
    return resultPtr;
}

/*
 *---------------------------------------------------------------------------
 *
 * TclpObjNormalizePath --
 *
 *	This function scans through a path specification and replaces
 *	it, in place, with a normalized version.  On MacOS, this means
 *	resolving all aliases present in the path and replacing the head of
 *	pathPtr with the absolute case-sensitive path to the last file or
 *	directory that could be validated in the path.
 *
 * Results:
 *	The new 'nextCheckpoint' value, giving as far as we could
 *	understand in the path.
 *
 * Side effects:
 *	The pathPtr string, which must contain a valid path, is
 *	possibly modified in place.
 *
 *---------------------------------------------------------------------------
 */

int
TclpObjNormalizePath(interp, pathPtr, nextCheckpoint)
    Tcl_Interp *interp;
    Tcl_Obj *pathPtr;
    int nextCheckpoint;
{
    #define MAXMACFILENAMELEN 31  /* assumed to be < sizeof(StrFileName) */
 
    StrFileName fileName;
    StringPtr fileNamePtr;
    int fileNameLen,newPathLen;
    Handle newPathHandle;
    OSErr err;
    short vRefNum;
    long dirID;
    Boolean isDirectory;
    Boolean wasAlias=FALSE;
    FSSpec fileSpec, lastFileSpec;
    
    Tcl_DString nativeds;

    char cur;
    int firstCheckpoint=nextCheckpoint, lastCheckpoint;
    int origPathLen;
    char *path = Tcl_GetStringFromObj(pathPtr,&origPathLen);
    
    {
	int currDirValid=0;    
	/*
	 * check if substring to first ':' after initial
	 * nextCheckpoint is a valid relative or absolute
	 * path to a directory, if not we return without
	 * normalizing anything
	 */
	
	while (1) {
	    cur = path[nextCheckpoint];
	    if (cur == ':' || cur == 0) {
		if (cur == ':') { 
		    /* jump over separator */
		    nextCheckpoint++; cur = path[nextCheckpoint]; 
		} 
		Tcl_UtfToExternalDString(NULL,path,nextCheckpoint,&nativeds);
		err = FSpLLocationFromPath(Tcl_DStringLength(&nativeds), 
					  Tcl_DStringValue(&nativeds), 
					  &fileSpec);
		Tcl_DStringFree(&nativeds);
		if (err == noErr) {
			lastFileSpec=fileSpec;
			err = ResolveAliasFile(&fileSpec, true, &isDirectory, 
				       &wasAlias);
			if (err == noErr) {
		    err = FSpGetDirectoryID(&fileSpec, &dirID, &isDirectory);
		    currDirValid = ((err == noErr) && isDirectory);
		    vRefNum = fileSpec.vRefNum;
		    }
		}
		break;
	    }
	    nextCheckpoint++;
	}
	
	if(!currDirValid) {
	    /* can't determine root dir, bail out */
	    return firstCheckpoint; 
	}
    }
	
    /*
     * Now vRefNum and dirID point to a valid
     * directory, so walk the rest of the path
     * ( code adapted from FSpLocationFromPath() )
     */

    lastCheckpoint=nextCheckpoint;
    while (1) {
	cur = path[nextCheckpoint];
	if (cur == ':' || cur == 0) {
	    fileNameLen=nextCheckpoint-lastCheckpoint;
	    fileNamePtr=fileName;
	    if(fileNameLen==0) {
		if (cur == ':') {
		    /*
		     * special case for empty dirname i.e. encountered
		     * a '::' path component: get parent dir of currDir
		     */
		    fileName[0]=2;
		    strcpy((char *) fileName + 1, "::");
		    lastCheckpoint--;
		} else {
		    /*
		     * empty filename, i.e. want FSSpec for currDir
		     */
		    fileNamePtr=NULL;
		}
	    } else {
		Tcl_UtfToExternalDString(NULL,&path[lastCheckpoint],
					 fileNameLen,&nativeds);
		fileNameLen=Tcl_DStringLength(&nativeds);
		if(fileNameLen > MAXMACFILENAMELEN) { 
		    err = bdNamErr;
		} else {
		fileName[0]=fileNameLen;
		strncpy((char *) fileName + 1, Tcl_DStringValue(&nativeds), 
			fileNameLen);
		}
		Tcl_DStringFree(&nativeds);
	    }
	    if(err == noErr)
	    err=FSMakeFSSpecCompat(vRefNum, dirID, fileNamePtr, &fileSpec);
	    if(err != noErr) {
		if(err != fnfErr) {
		    /*
		     * this can occur if trying to get parent of a root
		     * volume via '::' or when using an illegal
		     * filename; revert to last checkpoint and stop
		     * processing path further
		     */
		    err=FSMakeFSSpecCompat(vRefNum, dirID, NULL, &fileSpec);
		    if(err != noErr) {
			/* should never happen, bail out */
			return firstCheckpoint; 
		    }
		    nextCheckpoint=lastCheckpoint;
		    cur = path[lastCheckpoint];
		}
    		break; /* arrived at nonexistent file or dir */
	    } else {
		/* fileSpec could point to an alias, resolve it */
		lastFileSpec=fileSpec;
		err = ResolveAliasFile(&fileSpec, true, &isDirectory, 
				       &wasAlias);
		if (err != noErr || !isDirectory) {
		    break; /* fileSpec doesn't point to a dir */
		}
	    }
	    if (cur == 0) break; /* arrived at end of path */
	    
	    /* fileSpec points to possibly nonexisting subdirectory; validate */
	    err = FSpGetDirectoryID(&fileSpec, &dirID, &isDirectory);
	    if (err != noErr || !isDirectory) {
	        break; /* fileSpec doesn't point to existing dir */
	    }
	    vRefNum = fileSpec.vRefNum;
    	
	    /* found a new valid subdir in path, continue processing path */
	    lastCheckpoint=nextCheckpoint+1;
	}
	wasAlias=FALSE;
	nextCheckpoint++;
    }
    
    if (wasAlias)
    	fileSpec=lastFileSpec;
    
    /*
     * fileSpec now points to a possibly nonexisting file or dir
     *  inside a valid dir; get full path name to it
     */
    
    err=FSpPathFromLocation(&fileSpec, &newPathLen, &newPathHandle);
    if(err != noErr) {
	return firstCheckpoint; /* should not see any errors here, bail out */
    }
    
    HLock(newPathHandle);
    Tcl_ExternalToUtfDString(NULL,*newPathHandle,newPathLen,&nativeds);
    if (cur != 0) {
	/* not at end, append remaining path */
    	if ( newPathLen==0 || (*(*newPathHandle+(newPathLen-1))!=':' && path[nextCheckpoint] !=':')) {
	    Tcl_DStringAppend(&nativeds, ":" , 1);
	}
	Tcl_DStringAppend(&nativeds, &path[nextCheckpoint], 
			  strlen(&path[nextCheckpoint]));
    }
    DisposeHandle(newPathHandle);
    
    fileNameLen=Tcl_DStringLength(&nativeds);
    Tcl_SetStringObj(pathPtr,Tcl_DStringValue(&nativeds),fileNameLen);
    Tcl_DStringFree(&nativeds);
    
    return nextCheckpoint+(fileNameLen-origPathLen);
@


1.3.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tclMacFCmd.c,v 1.17 2002/04/19 14:18:45 das Exp $
a27 1
#include <Aliases.h>
d34 1
a34 1
			    int objIndex, Tcl_Obj *fileName,
d37 1
a37 1
			    int objIndex, Tcl_Obj *fileName,
d40 1
a40 1
			    int objIndex, Tcl_Obj *fileName,
d43 1
a43 1
			    int objIndex, Tcl_Obj *fileName,
d59 1
a59 1
CONST char *tclpFileAttrStrings[] = {"-creator", "-hidden", "-readonly",
d103 1
a103 1
 * TclpObjRenameFile, DoRenameFile --
d135 6
a140 4
int 
TclpObjRenameFile(srcPathPtr, destPathPtr)
    Tcl_Obj *srcPathPtr;
    Tcl_Obj *destPathPtr;
d142 10
a151 2
    return DoRenameFile(Tcl_FSGetNativePath(srcPathPtr),
			Tcl_FSGetNativePath(destPathPtr));
d166 1
a166 1
    err = FSpLLocationFromPath(strlen(src), src, &srcFileSpec);
d386 1
a386 1
 * TclpObjCopyFile, DoCopyFile --
d411 14
a424 6
TclpObjCopyFile(srcPathPtr, destPathPtr)
    Tcl_Obj *srcPathPtr;
    Tcl_Obj *destPathPtr;
{
    return DoCopyFile(Tcl_FSGetNativePath(srcPathPtr),
		      Tcl_FSGetNativePath(destPathPtr));
d437 1
a437 1
    err = FSpLLocationFromPath(strlen(src), src, &srcFileSpec);
d499 1
a499 1
 * TclpObjDeleteFile, DoDeleteFile --
d518 3
a520 3
int 
TclpObjDeleteFile(pathPtr)
    Tcl_Obj *pathPtr;
d522 7
a528 1
    return DoDeleteFile(Tcl_FSGetNativePath(pathPtr));
d540 1
a540 1
    err = FSpLLocationFromPath(strlen(path), path, &fileSpec);
d571 1
a571 1
 * TclpObjCreateDirectory, DoCreateDirectory --
d594 3
a596 3
int 
TclpObjCreateDirectory(pathPtr)
    Tcl_Obj *pathPtr;
d598 7
a604 1
    return DoCreateDirectory(Tcl_FSGetNativePath(pathPtr));
d632 1
a632 1
 * TclpObjCopyDirectory, DoCopyDirectory --
d655 19
a673 16
int 
TclpObjCopyDirectory(srcPathPtr, destPathPtr, errorPtr)
    Tcl_Obj *srcPathPtr;
    Tcl_Obj *destPathPtr;
    Tcl_Obj **errorPtr;
{
    Tcl_DString ds;
    int ret;
    ret = DoCopyDirectory(Tcl_FSGetNativePath(srcPathPtr),
			  Tcl_FSGetNativePath(destPathPtr), &ds);
    if (ret != TCL_OK) {
	*errorPtr = Tcl_NewStringObj(Tcl_DStringValue(&ds), -1);
	Tcl_DStringFree(&ds);
	Tcl_IncrRefCount(*errorPtr);
    }
    return ret;
d679 2
a680 2
				 * (Native). */
    CONST char *dst,		/* Pathname of target directory (Native). */
d751 1
a751 1
	err = FSpDirectoryCopy(&srcFileSpec, &tmpDirSpec, NULL, NULL, 0, true,
d835 1
a835 1
 * TclpObjRemoveDirectory, DoRemoveDirectory --
d858 20
a877 15
int 
TclpObjRemoveDirectory(pathPtr, recursive, errorPtr)
    Tcl_Obj *pathPtr;
    int recursive;
    Tcl_Obj **errorPtr;
{
    Tcl_DString ds;
    int ret;
    ret = DoRemoveDirectory(Tcl_FSGetNativePath(pathPtr),recursive, &ds);
    if (ret != TCL_OK) {
	*errorPtr = Tcl_NewStringObj(Tcl_DStringValue(&ds), -1);
	Tcl_DStringFree(&ds);
	Tcl_IncrRefCount(*errorPtr);
    }
    return ret;
d1064 1
a1064 1
    CONST char *dirName;
d1067 1
a1067 1
    CONST char **argv;
d1197 1
a1197 1
    Tcl_Obj *fileName,	/* The name of the file (UTF-8). */
d1203 1
a1203 1
    CONST char *native;
d1205 4
a1208 3
    native=Tcl_FSGetNativePath(fileName);
    err = FSpLLocationFromPath(strlen(native),
	    native, &fileSpec);
d1244 1
a1244 1
    		"could not read \"", Tcl_GetString(fileName), "\": ",
d1276 1
a1276 1
    Tcl_Obj *fileName,	/* The name of the file (UTF-8). */
d1282 1
a1282 1
    CONST char *native;
d1284 4
a1287 3
    native=Tcl_FSGetNativePath(fileName);
    err = FSpLLocationFromPath(strlen(native),
	    native, &fileSpec);
d1313 1
a1313 1
    		"could not read \"", Tcl_GetString(fileName), "\": ",
d1341 1
a1341 1
    Tcl_Obj *fileName,	/* The name of the file (UTF-8). */
d1347 1
a1347 1
    CONST char *native;
d1349 4
a1352 3
    native=Tcl_FSGetNativePath(fileName);
    err = FSpLLocationFromPath(strlen(native),
	    native, &fileSpec);
d1397 1
a1397 1
    	    	    Tcl_GetString(fileName), "\" is a directory", (char *) NULL);
d1405 1
a1405 1
    		"could not read \"", Tcl_GetString(fileName), "\": ",
d1433 1
a1433 1
    Tcl_Obj *fileName,	/* The name of the file (UTF-8). */
d1440 1
a1440 1
    CONST char *native;
d1442 4
a1445 3
    native=Tcl_FSGetNativePath(fileName);
    err = FSpLLocationFromPath(strlen(native),
	    native, &fileSpec);
d1480 1
a1480 1
    		"could not read \"", Tcl_GetString(fileName), "\": ",
d1490 1
a1490 1
 * TclpObjListVolumes --
d1495 3
a1497 1
 *	The list of volumes.
d1504 3
a1506 2
Tcl_Obj*
TclpObjListVolumes(void)
d1537 1
a1537 1
        Tcl_ExternalToUtfDString(NULL, (CONST char *)&name[1], name[0], &dstr);
d1541 1
a1541 1
        Tcl_ListObjAppendElement(NULL, resultPtr, elemPtr);
d1547 3
a1549 209

    Tcl_IncrRefCount(resultPtr);
    return resultPtr;
}

/*
 *---------------------------------------------------------------------------
 *
 * TclpObjNormalizePath --
 *
 *	This function scans through a path specification and replaces
 *	it, in place, with a normalized version.  On MacOS, this means
 *	resolving all aliases present in the path and replacing the head of
 *	pathPtr with the absolute case-sensitive path to the last file or
 *	directory that could be validated in the path.
 *
 * Results:
 *	The new 'nextCheckpoint' value, giving as far as we could
 *	understand in the path.
 *
 * Side effects:
 *	The pathPtr string, which must contain a valid path, is
 *	possibly modified in place.
 *
 *---------------------------------------------------------------------------
 */

int
TclpObjNormalizePath(interp, pathPtr, nextCheckpoint)
    Tcl_Interp *interp;
    Tcl_Obj *pathPtr;
    int nextCheckpoint;
{
    #define MAXMACFILENAMELEN 31  /* assumed to be < sizeof(StrFileName) */
 
    StrFileName fileName;
    StringPtr fileNamePtr;
    int fileNameLen,newPathLen;
    Handle newPathHandle;
    OSErr err;
    short vRefNum;
    long dirID;
    Boolean isDirectory;
    Boolean wasAlias=FALSE;
    FSSpec fileSpec, lastFileSpec;
    
    Tcl_DString nativeds;

    char cur;
    int firstCheckpoint=nextCheckpoint, lastCheckpoint;
    int origPathLen;
    char *path = Tcl_GetStringFromObj(pathPtr,&origPathLen);
    
    {
	int currDirValid=0;    
	/*
	 * check if substring to first ':' after initial
	 * nextCheckpoint is a valid relative or absolute
	 * path to a directory, if not we return without
	 * normalizing anything
	 */
	
	while (1) {
	    cur = path[nextCheckpoint];
	    if (cur == ':' || cur == 0) {
		if (cur == ':') { 
		    /* jump over separator */
		    nextCheckpoint++; cur = path[nextCheckpoint]; 
		} 
		Tcl_UtfToExternalDString(NULL,path,nextCheckpoint,&nativeds);
		err = FSpLLocationFromPath(Tcl_DStringLength(&nativeds), 
					  Tcl_DStringValue(&nativeds), 
					  &fileSpec);
		Tcl_DStringFree(&nativeds);
		if (err == noErr) {
			lastFileSpec=fileSpec;
			err = ResolveAliasFile(&fileSpec, true, &isDirectory, 
				       &wasAlias);
			if (err == noErr) {
		    err = FSpGetDirectoryID(&fileSpec, &dirID, &isDirectory);
		    currDirValid = ((err == noErr) && isDirectory);
		    vRefNum = fileSpec.vRefNum;
		    }
		}
		break;
	    }
	    nextCheckpoint++;
	}
	
	if(!currDirValid) {
	    /* can't determine root dir, bail out */
	    return firstCheckpoint; 
	}
    }
	
    /*
     * Now vRefNum and dirID point to a valid
     * directory, so walk the rest of the path
     * ( code adapted from FSpLocationFromPath() )
     */

    lastCheckpoint=nextCheckpoint;
    while (1) {
	cur = path[nextCheckpoint];
	if (cur == ':' || cur == 0) {
	    fileNameLen=nextCheckpoint-lastCheckpoint;
	    fileNamePtr=fileName;
	    if(fileNameLen==0) {
		if (cur == ':') {
		    /*
		     * special case for empty dirname i.e. encountered
		     * a '::' path component: get parent dir of currDir
		     */
		    fileName[0]=2;
		    strcpy((char *) fileName + 1, "::");
		    lastCheckpoint--;
		} else {
		    /*
		     * empty filename, i.e. want FSSpec for currDir
		     */
		    fileNamePtr=NULL;
		}
	    } else {
		Tcl_UtfToExternalDString(NULL,&path[lastCheckpoint],
					 fileNameLen,&nativeds);
		fileNameLen=Tcl_DStringLength(&nativeds);
		if(fileNameLen > MAXMACFILENAMELEN) { 
		    err = bdNamErr;
		} else {
		fileName[0]=fileNameLen;
		strncpy((char *) fileName + 1, Tcl_DStringValue(&nativeds), 
			fileNameLen);
		}
		Tcl_DStringFree(&nativeds);
	    }
	    if(err == noErr)
	    err=FSMakeFSSpecCompat(vRefNum, dirID, fileNamePtr, &fileSpec);
	    if(err != noErr) {
		if(err != fnfErr) {
		    /*
		     * this can occur if trying to get parent of a root
		     * volume via '::' or when using an illegal
		     * filename; revert to last checkpoint and stop
		     * processing path further
		     */
		    err=FSMakeFSSpecCompat(vRefNum, dirID, NULL, &fileSpec);
		    if(err != noErr) {
			/* should never happen, bail out */
			return firstCheckpoint; 
		    }
		    nextCheckpoint=lastCheckpoint;
		    cur = path[lastCheckpoint];
		}
    		break; /* arrived at nonexistent file or dir */
	    } else {
		/* fileSpec could point to an alias, resolve it */
		lastFileSpec=fileSpec;
		err = ResolveAliasFile(&fileSpec, true, &isDirectory, 
				       &wasAlias);
		if (err != noErr || !isDirectory) {
		    break; /* fileSpec doesn't point to a dir */
		}
	    }
	    if (cur == 0) break; /* arrived at end of path */
	    
	    /* fileSpec points to possibly nonexisting subdirectory; validate */
	    err = FSpGetDirectoryID(&fileSpec, &dirID, &isDirectory);
	    if (err != noErr || !isDirectory) {
	        break; /* fileSpec doesn't point to existing dir */
	    }
	    vRefNum = fileSpec.vRefNum;
    	
	    /* found a new valid subdir in path, continue processing path */
	    lastCheckpoint=nextCheckpoint+1;
	}
	wasAlias=FALSE;
	nextCheckpoint++;
    }
    
    if (wasAlias)
    	fileSpec=lastFileSpec;
    
    /*
     * fileSpec now points to a possibly nonexisting file or dir
     *  inside a valid dir; get full path name to it
     */
    
    err=FSpPathFromLocation(&fileSpec, &newPathLen, &newPathHandle);
    if(err != noErr) {
	return firstCheckpoint; /* should not see any errors here, bail out */
    }
    
    HLock(newPathHandle);
    Tcl_ExternalToUtfDString(NULL,*newPathHandle,newPathLen,&nativeds);
    if (cur != 0) {
	/* not at end, append remaining path */
    	if ( newPathLen==0 || (*(*newPathHandle+(newPathLen-1))!=':' && path[nextCheckpoint] !=':')) {
	    Tcl_DStringAppend(&nativeds, ":" , 1);
	}
	Tcl_DStringAppend(&nativeds, &path[nextCheckpoint], 
			  strlen(&path[nextCheckpoint]));
    }
    DisposeHandle(newPathHandle);
    
    fileNameLen=Tcl_DStringLength(&nativeds);
    Tcl_SetStringObj(pathPtr,Tcl_DStringValue(&nativeds),fileNameLen);
    Tcl_DStringFree(&nativeds);
    
    return nextCheckpoint+(fileNameLen-origPathLen);
@


1.2
log
@touched all Tcl files to ease next import.
@
text
@@


1.2.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.2.16.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@a27 1
#include <Aliases.h>
d34 1
a34 1
			    int objIndex, Tcl_Obj *fileName,
d37 1
a37 1
			    int objIndex, Tcl_Obj *fileName,
d40 1
a40 1
			    int objIndex, Tcl_Obj *fileName,
d43 1
a43 1
			    int objIndex, Tcl_Obj *fileName,
d59 1
a59 1
CONST char *tclpFileAttrStrings[] = {"-creator", "-hidden", "-readonly",
a66 5
/*
 * File specific static data
 */

static long startSeed = 248923489;
d89 2
d103 1
a103 1
 * TclpObjRenameFile, DoRenameFile --
d135 6
a140 4
int 
TclpObjRenameFile(srcPathPtr, destPathPtr)
    Tcl_Obj *srcPathPtr;
    Tcl_Obj *destPathPtr;
d142 10
a151 2
    return DoRenameFile(Tcl_FSGetNativePath(srcPathPtr),
			Tcl_FSGetNativePath(destPathPtr));
d166 1
a166 1
    err = FSpLLocationFromPath(strlen(src), src, &srcFileSpec);
d230 1
a230 1
	        err = GenerateUniqueName(dstFileSpec.vRefNum, &startSeed,
d346 1
a346 1
        err = GenerateUniqueName(srcFileSpecPtr->vRefNum, &startSeed,
d386 1
a386 1
 * TclpObjCopyFile, DoCopyFile --
d411 14
a424 6
TclpObjCopyFile(srcPathPtr, destPathPtr)
    Tcl_Obj *srcPathPtr;
    Tcl_Obj *destPathPtr;
{
    return DoCopyFile(Tcl_FSGetNativePath(srcPathPtr),
		      Tcl_FSGetNativePath(destPathPtr));
d437 1
a437 1
    err = FSpLLocationFromPath(strlen(src), src, &srcFileSpec);
d456 1
a456 1
        dstErr = GenerateUniqueName(dstFileSpec.vRefNum, &startSeed, dstFileSpec.parID, 
d499 1
a499 1
 * TclpObjDeleteFile, DoDeleteFile --
d518 3
a520 3
int 
TclpObjDeleteFile(pathPtr)
    Tcl_Obj *pathPtr;
d522 7
a528 1
    return DoDeleteFile(Tcl_FSGetNativePath(pathPtr));
d540 1
a540 1
    err = FSpLLocationFromPath(strlen(path), path, &fileSpec);
d571 1
a571 1
 * TclpObjCreateDirectory, DoCreateDirectory --
d594 3
a596 3
int 
TclpObjCreateDirectory(pathPtr)
    Tcl_Obj *pathPtr;
d598 7
a604 1
    return DoCreateDirectory(Tcl_FSGetNativePath(pathPtr));
d632 1
a632 1
 * TclpObjCopyDirectory, DoCopyDirectory --
d655 19
a673 16
int 
TclpObjCopyDirectory(srcPathPtr, destPathPtr, errorPtr)
    Tcl_Obj *srcPathPtr;
    Tcl_Obj *destPathPtr;
    Tcl_Obj **errorPtr;
{
    Tcl_DString ds;
    int ret;
    ret = DoCopyDirectory(Tcl_FSGetNativePath(srcPathPtr),
			  Tcl_FSGetNativePath(destPathPtr), &ds);
    if (ret != TCL_OK) {
	*errorPtr = Tcl_NewStringObj(Tcl_DStringValue(&ds), -1);
	Tcl_DStringFree(&ds);
	Tcl_IncrRefCount(*errorPtr);
    }
    return ret;
d679 2
a680 2
				 * (Native). */
    CONST char *dst,		/* Pathname of target directory (Native). */
d742 1
a742 1
        err = GenerateUniqueName(dstFileSpec.vRefNum, &startSeed, dstFileSpec.parID, 
d751 1
a751 1
	err = FSpDirectoryCopy(&srcFileSpec, &tmpDirSpec, NULL, NULL, 0, true,
d835 1
a835 1
 * TclpObjRemoveDirectory, DoRemoveDirectory --
d858 20
a877 15
int 
TclpObjRemoveDirectory(pathPtr, recursive, errorPtr)
    Tcl_Obj *pathPtr;
    int recursive;
    Tcl_Obj **errorPtr;
{
    Tcl_DString ds;
    int ret;
    ret = DoRemoveDirectory(Tcl_FSGetNativePath(pathPtr),recursive, &ds);
    if (ret != TCL_OK) {
	*errorPtr = Tcl_NewStringObj(Tcl_DStringValue(&ds), -1);
	Tcl_DStringFree(&ds);
	Tcl_IncrRefCount(*errorPtr);
    }
    return ret;
d974 63
d1064 1
a1064 1
    CONST char *dirName;
d1067 1
a1067 1
    CONST char **argv;
d1197 1
a1197 1
    Tcl_Obj *fileName,	/* The name of the file (UTF-8). */
d1203 1
a1203 1
    CONST char *native;
d1205 4
a1208 3
    native=Tcl_FSGetNativePath(fileName);
    err = FSpLLocationFromPath(strlen(native),
	    native, &fileSpec);
d1244 1
a1244 1
    		"could not read \"", Tcl_GetString(fileName), "\": ",
d1276 1
a1276 1
    Tcl_Obj *fileName,	/* The name of the file (UTF-8). */
d1282 1
a1282 1
    CONST char *native;
d1284 4
a1287 3
    native=Tcl_FSGetNativePath(fileName);
    err = FSpLLocationFromPath(strlen(native),
	    native, &fileSpec);
d1313 1
a1313 1
    		"could not read \"", Tcl_GetString(fileName), "\": ",
d1341 1
a1341 1
    Tcl_Obj *fileName,	/* The name of the file (UTF-8). */
d1347 1
a1347 1
    CONST char *native;
d1349 4
a1352 3
    native=Tcl_FSGetNativePath(fileName);
    err = FSpLLocationFromPath(strlen(native),
	    native, &fileSpec);
d1397 1
a1397 1
    	    	    Tcl_GetString(fileName), "\" is a directory", (char *) NULL);
d1405 1
a1405 1
    		"could not read \"", Tcl_GetString(fileName), "\": ",
d1433 1
a1433 1
    Tcl_Obj *fileName,	/* The name of the file (UTF-8). */
d1440 1
a1440 1
    CONST char *native;
d1442 4
a1445 3
    native=Tcl_FSGetNativePath(fileName);
    err = FSpLLocationFromPath(strlen(native),
	    native, &fileSpec);
d1480 1
a1480 1
    		"could not read \"", Tcl_GetString(fileName), "\": ",
d1490 1
a1490 1
 * TclpObjListVolumes --
d1495 3
a1497 1
 *	The list of volumes.
d1504 3
a1506 2
Tcl_Obj*
TclpObjListVolumes(void)
d1537 1
a1537 1
        Tcl_ExternalToUtfDString(NULL, (CONST char *)&name[1], name[0], &dstr);
d1541 1
a1541 1
        Tcl_ListObjAppendElement(NULL, resultPtr, elemPtr);
d1547 3
a1549 209

    Tcl_IncrRefCount(resultPtr);
    return resultPtr;
}

/*
 *---------------------------------------------------------------------------
 *
 * TclpObjNormalizePath --
 *
 *	This function scans through a path specification and replaces
 *	it, in place, with a normalized version.  On MacOS, this means
 *	resolving all aliases present in the path and replacing the head of
 *	pathPtr with the absolute case-sensitive path to the last file or
 *	directory that could be validated in the path.
 *
 * Results:
 *	The new 'nextCheckpoint' value, giving as far as we could
 *	understand in the path.
 *
 * Side effects:
 *	The pathPtr string, which must contain a valid path, is
 *	possibly modified in place.
 *
 *---------------------------------------------------------------------------
 */

int
TclpObjNormalizePath(interp, pathPtr, nextCheckpoint)
    Tcl_Interp *interp;
    Tcl_Obj *pathPtr;
    int nextCheckpoint;
{
    #define MAXMACFILENAMELEN 31  /* assumed to be < sizeof(StrFileName) */
 
    StrFileName fileName;
    StringPtr fileNamePtr;
    int fileNameLen,newPathLen;
    Handle newPathHandle;
    OSErr err;
    short vRefNum;
    long dirID;
    Boolean isDirectory;
    Boolean wasAlias=FALSE;
    FSSpec fileSpec, lastFileSpec;
    
    Tcl_DString nativeds;

    char cur;
    int firstCheckpoint=nextCheckpoint, lastCheckpoint;
    int origPathLen;
    char *path = Tcl_GetStringFromObj(pathPtr,&origPathLen);
    
    {
	int currDirValid=0;    
	/*
	 * check if substring to first ':' after initial
	 * nextCheckpoint is a valid relative or absolute
	 * path to a directory, if not we return without
	 * normalizing anything
	 */
	
	while (1) {
	    cur = path[nextCheckpoint];
	    if (cur == ':' || cur == 0) {
		if (cur == ':') { 
		    /* jump over separator */
		    nextCheckpoint++; cur = path[nextCheckpoint]; 
		} 
		Tcl_UtfToExternalDString(NULL,path,nextCheckpoint,&nativeds);
		err = FSpLLocationFromPath(Tcl_DStringLength(&nativeds), 
					  Tcl_DStringValue(&nativeds), 
					  &fileSpec);
		Tcl_DStringFree(&nativeds);
		if (err == noErr) {
			lastFileSpec=fileSpec;
			err = ResolveAliasFile(&fileSpec, true, &isDirectory, 
				       &wasAlias);
			if (err == noErr) {
		    err = FSpGetDirectoryID(&fileSpec, &dirID, &isDirectory);
		    currDirValid = ((err == noErr) && isDirectory);
		    vRefNum = fileSpec.vRefNum;
		    }
		}
		break;
	    }
	    nextCheckpoint++;
	}
	
	if(!currDirValid) {
	    /* can't determine root dir, bail out */
	    return firstCheckpoint; 
	}
    }
	
    /*
     * Now vRefNum and dirID point to a valid
     * directory, so walk the rest of the path
     * ( code adapted from FSpLocationFromPath() )
     */

    lastCheckpoint=nextCheckpoint;
    while (1) {
	cur = path[nextCheckpoint];
	if (cur == ':' || cur == 0) {
	    fileNameLen=nextCheckpoint-lastCheckpoint;
	    fileNamePtr=fileName;
	    if(fileNameLen==0) {
		if (cur == ':') {
		    /*
		     * special case for empty dirname i.e. encountered
		     * a '::' path component: get parent dir of currDir
		     */
		    fileName[0]=2;
		    strcpy((char *) fileName + 1, "::");
		    lastCheckpoint--;
		} else {
		    /*
		     * empty filename, i.e. want FSSpec for currDir
		     */
		    fileNamePtr=NULL;
		}
	    } else {
		Tcl_UtfToExternalDString(NULL,&path[lastCheckpoint],
					 fileNameLen,&nativeds);
		fileNameLen=Tcl_DStringLength(&nativeds);
		if(fileNameLen > MAXMACFILENAMELEN) { 
		    err = bdNamErr;
		} else {
		fileName[0]=fileNameLen;
		strncpy((char *) fileName + 1, Tcl_DStringValue(&nativeds), 
			fileNameLen);
		}
		Tcl_DStringFree(&nativeds);
	    }
	    if(err == noErr)
	    err=FSMakeFSSpecCompat(vRefNum, dirID, fileNamePtr, &fileSpec);
	    if(err != noErr) {
		if(err != fnfErr) {
		    /*
		     * this can occur if trying to get parent of a root
		     * volume via '::' or when using an illegal
		     * filename; revert to last checkpoint and stop
		     * processing path further
		     */
		    err=FSMakeFSSpecCompat(vRefNum, dirID, NULL, &fileSpec);
		    if(err != noErr) {
			/* should never happen, bail out */
			return firstCheckpoint; 
		    }
		    nextCheckpoint=lastCheckpoint;
		    cur = path[lastCheckpoint];
		}
    		break; /* arrived at nonexistent file or dir */
	    } else {
		/* fileSpec could point to an alias, resolve it */
		lastFileSpec=fileSpec;
		err = ResolveAliasFile(&fileSpec, true, &isDirectory, 
				       &wasAlias);
		if (err != noErr || !isDirectory) {
		    break; /* fileSpec doesn't point to a dir */
		}
	    }
	    if (cur == 0) break; /* arrived at end of path */
	    
	    /* fileSpec points to possibly nonexisting subdirectory; validate */
	    err = FSpGetDirectoryID(&fileSpec, &dirID, &isDirectory);
	    if (err != noErr || !isDirectory) {
	        break; /* fileSpec doesn't point to existing dir */
	    }
	    vRefNum = fileSpec.vRefNum;
    	
	    /* found a new valid subdir in path, continue processing path */
	    lastCheckpoint=nextCheckpoint+1;
	}
	wasAlias=FALSE;
	nextCheckpoint++;
    }
    
    if (wasAlias)
    	fileSpec=lastFileSpec;
    
    /*
     * fileSpec now points to a possibly nonexisting file or dir
     *  inside a valid dir; get full path name to it
     */
    
    err=FSpPathFromLocation(&fileSpec, &newPathLen, &newPathHandle);
    if(err != noErr) {
	return firstCheckpoint; /* should not see any errors here, bail out */
    }
    
    HLock(newPathHandle);
    Tcl_ExternalToUtfDString(NULL,*newPathHandle,newPathLen,&nativeds);
    if (cur != 0) {
	/* not at end, append remaining path */
    	if ( newPathLen==0 || (*(*newPathHandle+(newPathLen-1))!=':' && path[nextCheckpoint] !=':')) {
	    Tcl_DStringAppend(&nativeds, ":" , 1);
	}
	Tcl_DStringAppend(&nativeds, &path[nextCheckpoint], 
			  strlen(&path[nextCheckpoint]));
    }
    DisposeHandle(newPathHandle);
    
    fileNameLen=Tcl_DStringLength(&nativeds);
    Tcl_SetStringObj(pathPtr,Tcl_DStringValue(&nativeds),fileNameLen);
    Tcl_DStringFree(&nativeds);
    
    return nextCheckpoint+(fileNameLen-origPathLen);
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
 * Copyright (c) 1996-1997 Sun Microsystems, Inc.
d12 1
a12 1
 * RCS: @@(#) $Id: tclMacFCmd.c,v 1.7 1999/01/26 03:53:22 jingham Exp $
d34 1
a34 1
			    int objIndex, char *fileName,
d37 1
a37 1
			    int objIndex, char *fileName,
d40 1
a40 1
			    int objIndex, char *fileName,
d43 1
a43 1
			    int objIndex, char *fileName,
d75 12
a86 2
			    StringPtr srcName, short dstVRefNum,
			    long dstDirID,StringPtr dstName));
d91 3
a93 2
static OSErr		GetFileSpecs _ANSI_ARGS_((char *path, FSSpec *pathSpecPtr,
			    FSSpec *dirSpecPtr,	Boolean *pathExistsPtr,	
d103 1
a103 1
 * TclpRenameFile --
d137 23
a159 2
    char *src,    		/* Pathname of file or dir to be renamed. */
    char *dst)     		/* New pathname for file or directory. */
d192 1
a192 1
                if (TclpRemoveDirectory(dst, 0, NULL) != TCL_OK) {
d265 119
d386 1
a386 1
 * TclpCopyFile --
d412 19
a430 2
    char *src,			/* Pathname of file to be copied. */
    char *dst)			/* Pathname of file to copy to. */
d499 1
a499 1
 * TclpDeleteFile --
d520 14
a533 1
    char *path)			/* Pathname of file to be removed. */
d539 1
a539 1
	
d571 1
a571 1
 * TclpCreateDirectory --
d596 14
a609 1
    char *path)			/* Pathname of directory to create. */
d632 1
a632 1
 * TclpCopyDirectory --
d657 27
a683 4
    char *src,			/* Pathname of directory to be copied.  */
    char *dst,			/* Pathname of target directory. */
    Tcl_DString *errorPtr)	/* If non-NULL, initialized DString for
				 * error reporting. */
d792 1
a792 1
            Tcl_DStringAppend(errorPtr, dst, -1);
d824 1
a824 1
    StringPtr srcName,		/* name of source */
d827 1
a827 1
    StringPtr dstName)		/* name of dst directory */
d835 1
a835 1
 * TclpRemoveDirectory --
d860 2
a861 1
    char *path,			/* Pathname of directory to be removed. */
d865 26
a890 3
    Tcl_DString *errorPtr)	/* If non-NULL, initialized DString for
				 * error reporting. */
{				 
d899 1
d960 1
a960 1
	    Tcl_DStringAppend(errorPtr, path, -1);
a969 119

/*
 *--------------------------------------------------------------------------
 *
 * MoveRename --
 *
 *	Helper function for TclpRenameFile.  Renames a file or directory
 *	into the same directory or another directory.  The target name
 * 	must not already exist in the destination directory.
 *
 *	Don't use FSpMoveRenameCompat because it doesn't work with
 *	directories or with locked files. 
 *
 * Results:
 *	Returns a mac error indicating the cause of the failure.
 *
 * Side effects:
 *	Creates a temp file in the target directory to handle a rename
 *	between directories.
 *
 *--------------------------------------------------------------------------
 */
  
static OSErr		
MoveRename(
    const FSSpec *srcFileSpecPtr,   /* Source object. */
    const FSSpec *dstDirSpecPtr,    /* Destination directory. */
    StringPtr copyName)		    /* New name for object in destination 
    				     * directory. */
{
    OSErr err;
    long srcID, dstID;
    Boolean srcIsDir, dstIsDir;
    Str31 tmpName;
    FSSpec dstFileSpec, srcDirSpec, tmpSrcFileSpec, tmpDstFileSpec;
    Boolean locked;
    
    if (srcFileSpecPtr->parID == 1) {
        /*
         * Trying to rename a volume.
         */
          
        return badMovErr;
    }
    if (srcFileSpecPtr->vRefNum != dstDirSpecPtr->vRefNum) {
	/*
	 * Renaming across volumes.
	 */
	 
        return diffVolErr;
    }
    err = FSpGetFLockCompat(srcFileSpecPtr, &locked);
    if (locked) {
        FSpRstFLockCompat(srcFileSpecPtr);
    }
    if (err == noErr) {
	err = FSpGetDirectoryID(dstDirSpecPtr, &dstID, &dstIsDir);
    }
    if (err == noErr) {
        if (srcFileSpecPtr->parID == dstID) {
            /*
             * Renaming object within directory. 
             */
            
            err = FSpRenameCompat(srcFileSpecPtr, copyName);
            goto done; 
        }
        if (Pstrequal(srcFileSpecPtr->name, copyName)) {
	    /*
	     * Moving object to another directory (under same name). 
	     */
	 
	    err = FSpCatMoveCompat(srcFileSpecPtr, dstDirSpecPtr);
	    goto done; 
        } 
        err = FSpGetDirectoryID(srcFileSpecPtr, &srcID, &srcIsDir);
    } 
    if (err == noErr) {
        /*
         * Fullblown: rename source object to temp name, move temp to
         * dest directory, and rename temp to target.
         */
          
        err = GenerateUniqueName(srcFileSpecPtr->vRefNum, 
       		srcFileSpecPtr->parID, dstID, tmpName);
        FSMakeFSSpecCompat(srcFileSpecPtr->vRefNum, srcFileSpecPtr->parID,
         	tmpName, &tmpSrcFileSpec);
        FSMakeFSSpecCompat(dstDirSpecPtr->vRefNum, dstID, tmpName,
         	&tmpDstFileSpec);
    }
    if (err == noErr) {
        err = FSpRenameCompat(srcFileSpecPtr, tmpName);
    }
    if (err == noErr) {
        err = FSpCatMoveCompat(&tmpSrcFileSpec, dstDirSpecPtr);
        if (err == noErr) {
            err = FSpRenameCompat(&tmpDstFileSpec, copyName);
            if (err == noErr) {
                goto done;
            }
            FSMakeFSSpecCompat(srcFileSpecPtr->vRefNum, srcFileSpecPtr->parID,
             	    NULL, &srcDirSpec);
            FSpCatMoveCompat(&tmpDstFileSpec, &srcDirSpec);
        }                 
        FSpRenameCompat(&tmpSrcFileSpec, srcFileSpecPtr->name);
    }
    
    done:
    if (locked != false) {
    	if (err == noErr) {
	    FSMakeFSSpecCompat(dstDirSpecPtr->vRefNum, 
	    	    dstID, copyName, &dstFileSpec);
            FSpSetFLockCompat(&dstFileSpec);
        } else {
            FSpSetFLockCompat(srcFileSpecPtr);
        }
    }
    return err;
}     
d974 1
a974 1
 * GetFileSpecs --
d1054 1
a1054 1
    char *path,			/* The path to query. */
d1197 1
a1197 1
    char *fileName,		/* The name of the file. */
d1203 7
a1209 3
    
    err = FSpLocationFromPath(strlen(fileName), fileName, &fileSpec);
    
d1244 1
a1244 1
    		"couldn't get attributes for file \"", fileName, "\": ",
d1276 1
a1276 1
    char *fileName,		/* The name of the file. */
d1282 6
a1287 2
    
    err = FSpLocationFromPath(strlen(fileName), fileName, &fileSpec);
d1313 1
a1313 1
    		"couldn't get attributes for file \"", fileName, "\": ",
d1341 1
a1341 1
    char *fileName,		/* The name of the file. */
d1347 6
a1352 2
    
    err = FSpLocationFromPath(strlen(fileName), fileName, &fileSpec);
d1405 1
a1405 1
    		"couldn't set attributes for file \"", fileName, "\": ",
d1433 1
a1433 1
    char *fileName,		/* The name of the file. */
d1440 6
a1445 2
    
    err = FSpLocationFromPath(strlen(fileName), fileName, &fileSpec);
d1480 1
a1480 1
    		"couldn't set attributes for file \"", fileName, "\": ",
a1503 1

d1513 1
d1528 1
a1528 1
        pb.volumeParam.ioNamePtr = (StringPtr) & name;
d1536 4
a1539 2
                
        elemPtr = Tcl_NewStringObj((char *) name + 1, (int) name[0]);
d1542 2
@


1.1.1.1
log
@import dejagnu-1999-11-08 snapshot
@
text
@@


1.1.1.2
log
@Tcl 8.3 upgrade
@
text
@d7 1
a7 1
 * Copyright (c) 1996-1998 Sun Microsystems, Inc.
d12 1
a12 1
 * RCS: @@(#) $Id: tclMacFCmd.c,v 1.6.8.1 2000/04/06 22:38:30 spolk Exp $
d34 1
a34 1
			    int objIndex, CONST char *fileName,
d37 1
a37 1
			    int objIndex, CONST char *fileName,
d40 1
a40 1
			    int objIndex, CONST char *fileName,
d43 1
a43 1
			    int objIndex, CONST char *fileName,
d75 2
a76 12
			    ConstStr255Param srcName, short dstVRefNum,
			    long dstDirID,ConstStr255Param dstName));
static int		DoCopyDirectory _ANSI_ARGS_((CONST char *src,
			    CONST char *dst, Tcl_DString *errorPtr));
static int		DoCopyFile _ANSI_ARGS_((CONST char *src, 
			    CONST char *dst));
static int		DoCreateDirectory _ANSI_ARGS_((CONST char *path));
static int		DoDeleteFile _ANSI_ARGS_((CONST char *path));
static int		DoRemoveDirectory _ANSI_ARGS_((CONST char *path, 
			    int recursive, Tcl_DString *errorPtr));
static int		DoRenameFile _ANSI_ARGS_((CONST char *src,
			    CONST char *dst));
d81 2
a82 3
static OSErr		GetFileSpecs _ANSI_ARGS_((CONST char *path, 
			    FSSpec *pathSpecPtr, FSSpec *dirSpecPtr,	
			    Boolean *pathExistsPtr, 
d92 1
a92 1
 * TclpRenameFile, DoRenameFile --
d126 2
a127 23
    CONST char *src,		/* Pathname of file or dir to be renamed
				 * (UTF-8). */
    CONST char *dst)		/* New pathname of file or directory
				 * (UTF-8). */
{
    int result;
    Tcl_DString srcString, dstString;

    Tcl_UtfToExternalDString(NULL, src, -1, &srcString);
    Tcl_UtfToExternalDString(NULL, dst, -1, &dstString);
    result = DoRenameFile(Tcl_DStringValue(&srcString),
	    Tcl_DStringValue(&dstString));
    Tcl_DStringFree(&srcString);
    Tcl_DStringFree(&dstString);
    return result;
}

static int
DoRenameFile(
    CONST char *src,		/* Pathname of file or dir to be renamed
				 * (native). */
    CONST char *dst)		/* New pathname of file or directory
				 * (native). */
d160 1
a160 1
                if (DoRemoveDirectory(dst, 0, NULL) != TCL_OK) {
a232 119
 *--------------------------------------------------------------------------
 *
 * MoveRename --
 *
 *	Helper function for TclpRenameFile.  Renames a file or directory
 *	into the same directory or another directory.  The target name
 * 	must not already exist in the destination directory.
 *
 *	Don't use FSpMoveRenameCompat because it doesn't work with
 *	directories or with locked files. 
 *
 * Results:
 *	Returns a mac error indicating the cause of the failure.
 *
 * Side effects:
 *	Creates a temp file in the target directory to handle a rename
 *	between directories.
 *
 *--------------------------------------------------------------------------
 */
  
static OSErr		
MoveRename(
    const FSSpec *srcFileSpecPtr,   /* Source object. */
    const FSSpec *dstDirSpecPtr,    /* Destination directory. */
    StringPtr copyName)		    /* New name for object in destination 
    				     * directory. */
{
    OSErr err;
    long srcID, dstID;
    Boolean srcIsDir, dstIsDir;
    Str31 tmpName;
    FSSpec dstFileSpec, srcDirSpec, tmpSrcFileSpec, tmpDstFileSpec;
    Boolean locked;
    
    if (srcFileSpecPtr->parID == 1) {
        /*
         * Trying to rename a volume.
         */
          
        return badMovErr;
    }
    if (srcFileSpecPtr->vRefNum != dstDirSpecPtr->vRefNum) {
	/*
	 * Renaming across volumes.
	 */
	 
        return diffVolErr;
    }
    err = FSpGetFLockCompat(srcFileSpecPtr, &locked);
    if (locked) {
        FSpRstFLockCompat(srcFileSpecPtr);
    }
    if (err == noErr) {
	err = FSpGetDirectoryID(dstDirSpecPtr, &dstID, &dstIsDir);
    }
    if (err == noErr) {
        if (srcFileSpecPtr->parID == dstID) {
            /*
             * Renaming object within directory. 
             */
            
            err = FSpRenameCompat(srcFileSpecPtr, copyName);
            goto done; 
        }
        if (Pstrequal(srcFileSpecPtr->name, copyName)) {
	    /*
	     * Moving object to another directory (under same name). 
	     */
	 
	    err = FSpCatMoveCompat(srcFileSpecPtr, dstDirSpecPtr);
	    goto done; 
        } 
        err = FSpGetDirectoryID(srcFileSpecPtr, &srcID, &srcIsDir);
    } 
    if (err == noErr) {
        /*
         * Fullblown: rename source object to temp name, move temp to
         * dest directory, and rename temp to target.
         */
          
        err = GenerateUniqueName(srcFileSpecPtr->vRefNum, 
       		srcFileSpecPtr->parID, dstID, tmpName);
        FSMakeFSSpecCompat(srcFileSpecPtr->vRefNum, srcFileSpecPtr->parID,
         	tmpName, &tmpSrcFileSpec);
        FSMakeFSSpecCompat(dstDirSpecPtr->vRefNum, dstID, tmpName,
         	&tmpDstFileSpec);
    }
    if (err == noErr) {
        err = FSpRenameCompat(srcFileSpecPtr, tmpName);
    }
    if (err == noErr) {
        err = FSpCatMoveCompat(&tmpSrcFileSpec, dstDirSpecPtr);
        if (err == noErr) {
            err = FSpRenameCompat(&tmpDstFileSpec, copyName);
            if (err == noErr) {
                goto done;
            }
            FSMakeFSSpecCompat(srcFileSpecPtr->vRefNum, srcFileSpecPtr->parID,
             	    NULL, &srcDirSpec);
            FSpCatMoveCompat(&tmpDstFileSpec, &srcDirSpec);
        }                 
        FSpRenameCompat(&tmpSrcFileSpec, srcFileSpecPtr->name);
    }
    
    done:
    if (locked != false) {
    	if (err == noErr) {
	    FSMakeFSSpecCompat(dstDirSpecPtr->vRefNum, 
	    	    dstID, copyName, &dstFileSpec);
            FSpSetFLockCompat(&dstFileSpec);
        } else {
            FSpSetFLockCompat(srcFileSpecPtr);
        }
    }
    return err;
}     

/*
d235 1
a235 1
 * TclpCopyFile, DoCopyFile --
d261 2
a262 19
    CONST char *src,		/* Pathname of file to be copied (UTF-8). */
    CONST char *dst)		/* Pathname of file to copy to (UTF-8). */
{
    int result;
    Tcl_DString srcString, dstString;

    Tcl_UtfToExternalDString(NULL, src, -1, &srcString);
    Tcl_UtfToExternalDString(NULL, dst, -1, &dstString);
    result = DoCopyFile(Tcl_DStringValue(&srcString), 
    	    Tcl_DStringValue(&dstString));
    Tcl_DStringFree(&srcString);
    Tcl_DStringFree(&dstString);
    return result;
}

static int
DoCopyFile(
    CONST char *src,		/* Pathname of file to be copied (native). */
    CONST char *dst)		/* Pathname of file to copy to (native). */
d331 1
a331 1
 * TclpDeleteFile, DoDeleteFile --
d352 1
a352 14
    CONST char *path)		/* Pathname of file to be removed (UTF-8). */
{
    int result;
    Tcl_DString pathString;

    Tcl_UtfToExternalDString(NULL, path, -1, &pathString);
    result = DoDeleteFile(Tcl_DStringValue(&pathString));
    Tcl_DStringFree(&pathString);
    return result;
}

static int
DoDeleteFile(
    CONST char *path)		/* Pathname of file to be removed (native). */
d358 1
a358 1
    
d390 1
a390 1
 * TclpCreateDirectory, DoCreateDirectory --
d415 1
a415 14
    CONST char *path)		/* Pathname of directory to create (UTF-8). */
{
    int result;
    Tcl_DString pathString;

    Tcl_UtfToExternalDString(NULL, path, -1, &pathString);
    result = DoCreateDirectory(Tcl_DStringValue(&pathString));
    Tcl_DStringFree(&pathString);
    return result;
}

static int
DoCreateDirectory(
    CONST char *path)		/* Pathname of directory to create (native). */
d438 1
a438 1
 * TclpCopyDirectory, DoCopyDirectory --
d463 4
a466 27
    CONST char *src,		/* Pathname of directory to be copied
				 * (UTF-8). */
    CONST char *dst,		/* Pathname of target directory (UTF-8). */
    Tcl_DString *errorPtr)	/* If non-NULL, uninitialized or free
				 * DString filled with UTF-8 name of file
				 * causing error. */
{
    int result;
    Tcl_DString srcString, dstString;

    Tcl_UtfToExternalDString(NULL, src, -1, &srcString);
    Tcl_UtfToExternalDString(NULL, dst, -1, &dstString);
    result = DoCopyDirectory(Tcl_DStringValue(&srcString),
	    Tcl_DStringValue(&dstString), errorPtr);
    Tcl_DStringFree(&srcString);
    Tcl_DStringFree(&dstString);
    return result;
}

static int
DoCopyDirectory(
    CONST char *src,		/* Pathname of directory to be copied
				 * (UTF-8). */
    CONST char *dst,		/* Pathname of target directory (UTF-8). */
    Tcl_DString *errorPtr)	/* If non-NULL, uninitialized or free
				 * DString filled with UTF-8 name of file
				 * causing error. */
d575 1
a575 1
            Tcl_ExternalToUtfDString(NULL, dst, -1, errorPtr);
d607 1
a607 1
    ConstStr255Param srcName,	/* name of source */
d610 1
a610 1
    ConstStr255Param dstName)	/* name of dst directory */
d618 1
a618 1
 * TclpRemoveDirectory, DoRemoveDirectory --
d643 1
a643 2
    CONST char *path,		/* Pathname of directory to be removed
				 * (UTF-8). */
d647 3
a649 26
    Tcl_DString *errorPtr)	/* If non-NULL, uninitialized or free
				 * DString filled with UTF-8 name of file
				 * causing error. */
{
    int result;
    Tcl_DString pathString;

    Tcl_UtfToExternalDString(NULL, path, -1, &pathString);
    result = DoRemoveDirectory(Tcl_DStringValue(&pathString), recursive, 
    	    errorPtr);
    Tcl_DStringFree(&pathString);

    return result;
}

static int
DoRemoveDirectory(
    CONST char *path,		/* Pathname of directory to be removed
				 * (native). */
    int recursive,		/* If non-zero, removes directories that
				 * are nonempty.  Otherwise, will only remove
				 * empty directories. */
    Tcl_DString *errorPtr)	/* If non-NULL, uninitialized or free
				 * DString filled with UTF-8 name of file
				 * causing error. */
{
a657 1

d718 1
a718 1
	    Tcl_UtfToExternalDString(NULL, path, -1, errorPtr);
d728 119
d851 1
a851 1
 * GenerateUniqueName --
d931 1
a931 1
    CONST char *path,		/* The path to query. */
d1074 1
a1074 1
    CONST char *fileName,	/* The name of the file (UTF-8). */
d1080 3
a1082 7
    Tcl_DString pathString;

    Tcl_UtfToExternalDString(NULL, fileName, -1, &pathString);
    err = FSpLocationFromPath(Tcl_DStringLength(&pathString),
	    Tcl_DStringValue(&pathString), &fileSpec);
    Tcl_DStringFree(&pathString);

d1117 1
a1117 1
    		"could not read \"", fileName, "\": ",
d1149 1
a1149 1
    CONST char *fileName,	/* The name of the file (UTF-8). */
d1155 2
a1156 6
    Tcl_DString pathString;

    Tcl_UtfToExternalDString(NULL, fileName, -1, &pathString);
    err = FSpLocationFromPath(Tcl_DStringLength(&pathString),
	    Tcl_DStringValue(&pathString), &fileSpec);
    Tcl_DStringFree(&pathString);
d1182 1
a1182 1
    		"could not read \"", fileName, "\": ",
d1210 1
a1210 1
    CONST char *fileName,	/* The name of the file (UTF-8). */
d1216 2
a1217 6
    Tcl_DString pathString;

    Tcl_UtfToExternalDString(NULL, fileName, -1, &pathString);
    err = FSpLocationFromPath(Tcl_DStringLength(&pathString),
	    Tcl_DStringValue(&pathString), &fileSpec);
    Tcl_DStringFree(&pathString);
d1270 1
a1270 1
    		"could not read \"", fileName, "\": ",
d1298 1
a1298 1
    CONST char *fileName,	/* The name of the file (UTF-8). */
d1305 2
a1306 6
    Tcl_DString pathString;

    Tcl_UtfToExternalDString(NULL, fileName, -1, &pathString);
    err = FSpLocationFromPath(Tcl_DStringLength(&pathString),
	    Tcl_DStringValue(&pathString), &fileSpec);
    Tcl_DStringFree(&pathString);
d1341 1
a1341 1
    		"could not read \"", fileName, "\": ",
d1365 1
a1374 1
    Tcl_DString dstr;
d1389 1
a1389 1
        pb.volumeParam.ioNamePtr = (StringPtr) &name;
d1397 2
a1398 4
        
        Tcl_ExternalToUtfDString(NULL, (char *) &name[1], name[0], &dstr);  
        elemPtr = Tcl_NewStringObj(Tcl_DStringValue(&dstr),
		Tcl_DStringLength(&dstr));
a1400 2
        
        Tcl_DStringFree(&dstr);
@


1.1.1.3
log
@import tcl 8.4.0
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tclMacFCmd.c,v 1.17 2002/04/19 14:18:45 das Exp $
a27 1
#include <Aliases.h>
d34 1
a34 1
			    int objIndex, Tcl_Obj *fileName,
d37 1
a37 1
			    int objIndex, Tcl_Obj *fileName,
d40 1
a40 1
			    int objIndex, Tcl_Obj *fileName,
d43 1
a43 1
			    int objIndex, Tcl_Obj *fileName,
d59 1
a59 1
CONST char *tclpFileAttrStrings[] = {"-creator", "-hidden", "-readonly",
d103 1
a103 1
 * TclpObjRenameFile, DoRenameFile --
d135 6
a140 4
int 
TclpObjRenameFile(srcPathPtr, destPathPtr)
    Tcl_Obj *srcPathPtr;
    Tcl_Obj *destPathPtr;
d142 10
a151 2
    return DoRenameFile(Tcl_FSGetNativePath(srcPathPtr),
			Tcl_FSGetNativePath(destPathPtr));
d166 1
a166 1
    err = FSpLLocationFromPath(strlen(src), src, &srcFileSpec);
d386 1
a386 1
 * TclpObjCopyFile, DoCopyFile --
d411 14
a424 6
TclpObjCopyFile(srcPathPtr, destPathPtr)
    Tcl_Obj *srcPathPtr;
    Tcl_Obj *destPathPtr;
{
    return DoCopyFile(Tcl_FSGetNativePath(srcPathPtr),
		      Tcl_FSGetNativePath(destPathPtr));
d437 1
a437 1
    err = FSpLLocationFromPath(strlen(src), src, &srcFileSpec);
d499 1
a499 1
 * TclpObjDeleteFile, DoDeleteFile --
d518 3
a520 3
int 
TclpObjDeleteFile(pathPtr)
    Tcl_Obj *pathPtr;
d522 7
a528 1
    return DoDeleteFile(Tcl_FSGetNativePath(pathPtr));
d540 1
a540 1
    err = FSpLLocationFromPath(strlen(path), path, &fileSpec);
d571 1
a571 1
 * TclpObjCreateDirectory, DoCreateDirectory --
d594 3
a596 3
int 
TclpObjCreateDirectory(pathPtr)
    Tcl_Obj *pathPtr;
d598 7
a604 1
    return DoCreateDirectory(Tcl_FSGetNativePath(pathPtr));
d632 1
a632 1
 * TclpObjCopyDirectory, DoCopyDirectory --
d655 19
a673 16
int 
TclpObjCopyDirectory(srcPathPtr, destPathPtr, errorPtr)
    Tcl_Obj *srcPathPtr;
    Tcl_Obj *destPathPtr;
    Tcl_Obj **errorPtr;
{
    Tcl_DString ds;
    int ret;
    ret = DoCopyDirectory(Tcl_FSGetNativePath(srcPathPtr),
			  Tcl_FSGetNativePath(destPathPtr), &ds);
    if (ret != TCL_OK) {
	*errorPtr = Tcl_NewStringObj(Tcl_DStringValue(&ds), -1);
	Tcl_DStringFree(&ds);
	Tcl_IncrRefCount(*errorPtr);
    }
    return ret;
d679 2
a680 2
				 * (Native). */
    CONST char *dst,		/* Pathname of target directory (Native). */
d751 1
a751 1
	err = FSpDirectoryCopy(&srcFileSpec, &tmpDirSpec, NULL, NULL, 0, true,
d835 1
a835 1
 * TclpObjRemoveDirectory, DoRemoveDirectory --
d858 20
a877 15
int 
TclpObjRemoveDirectory(pathPtr, recursive, errorPtr)
    Tcl_Obj *pathPtr;
    int recursive;
    Tcl_Obj **errorPtr;
{
    Tcl_DString ds;
    int ret;
    ret = DoRemoveDirectory(Tcl_FSGetNativePath(pathPtr),recursive, &ds);
    if (ret != TCL_OK) {
	*errorPtr = Tcl_NewStringObj(Tcl_DStringValue(&ds), -1);
	Tcl_DStringFree(&ds);
	Tcl_IncrRefCount(*errorPtr);
    }
    return ret;
d1064 1
a1064 1
    CONST char *dirName;
d1067 1
a1067 1
    CONST char **argv;
d1197 1
a1197 1
    Tcl_Obj *fileName,	/* The name of the file (UTF-8). */
d1203 1
a1203 1
    CONST char *native;
d1205 4
a1208 3
    native=Tcl_FSGetNativePath(fileName);
    err = FSpLLocationFromPath(strlen(native),
	    native, &fileSpec);
d1244 1
a1244 1
    		"could not read \"", Tcl_GetString(fileName), "\": ",
d1276 1
a1276 1
    Tcl_Obj *fileName,	/* The name of the file (UTF-8). */
d1282 1
a1282 1
    CONST char *native;
d1284 4
a1287 3
    native=Tcl_FSGetNativePath(fileName);
    err = FSpLLocationFromPath(strlen(native),
	    native, &fileSpec);
d1313 1
a1313 1
    		"could not read \"", Tcl_GetString(fileName), "\": ",
d1341 1
a1341 1
    Tcl_Obj *fileName,	/* The name of the file (UTF-8). */
d1347 1
a1347 1
    CONST char *native;
d1349 4
a1352 3
    native=Tcl_FSGetNativePath(fileName);
    err = FSpLLocationFromPath(strlen(native),
	    native, &fileSpec);
d1397 1
a1397 1
    	    	    Tcl_GetString(fileName), "\" is a directory", (char *) NULL);
d1405 1
a1405 1
    		"could not read \"", Tcl_GetString(fileName), "\": ",
d1433 1
a1433 1
    Tcl_Obj *fileName,	/* The name of the file (UTF-8). */
d1440 1
a1440 1
    CONST char *native;
d1442 4
a1445 3
    native=Tcl_FSGetNativePath(fileName);
    err = FSpLLocationFromPath(strlen(native),
	    native, &fileSpec);
d1480 1
a1480 1
    		"could not read \"", Tcl_GetString(fileName), "\": ",
d1490 1
a1490 1
 * TclpObjListVolumes --
d1495 3
a1497 1
 *	The list of volumes.
d1504 3
a1506 2
Tcl_Obj*
TclpObjListVolumes(void)
d1537 1
a1537 1
        Tcl_ExternalToUtfDString(NULL, (CONST char *)&name[1], name[0], &dstr);
d1541 1
a1541 1
        Tcl_ListObjAppendElement(NULL, resultPtr, elemPtr);
d1547 3
a1549 209

    Tcl_IncrRefCount(resultPtr);
    return resultPtr;
}

/*
 *---------------------------------------------------------------------------
 *
 * TclpObjNormalizePath --
 *
 *	This function scans through a path specification and replaces
 *	it, in place, with a normalized version.  On MacOS, this means
 *	resolving all aliases present in the path and replacing the head of
 *	pathPtr with the absolute case-sensitive path to the last file or
 *	directory that could be validated in the path.
 *
 * Results:
 *	The new 'nextCheckpoint' value, giving as far as we could
 *	understand in the path.
 *
 * Side effects:
 *	The pathPtr string, which must contain a valid path, is
 *	possibly modified in place.
 *
 *---------------------------------------------------------------------------
 */

int
TclpObjNormalizePath(interp, pathPtr, nextCheckpoint)
    Tcl_Interp *interp;
    Tcl_Obj *pathPtr;
    int nextCheckpoint;
{
    #define MAXMACFILENAMELEN 31  /* assumed to be < sizeof(StrFileName) */
 
    StrFileName fileName;
    StringPtr fileNamePtr;
    int fileNameLen,newPathLen;
    Handle newPathHandle;
    OSErr err;
    short vRefNum;
    long dirID;
    Boolean isDirectory;
    Boolean wasAlias=FALSE;
    FSSpec fileSpec, lastFileSpec;
    
    Tcl_DString nativeds;

    char cur;
    int firstCheckpoint=nextCheckpoint, lastCheckpoint;
    int origPathLen;
    char *path = Tcl_GetStringFromObj(pathPtr,&origPathLen);
    
    {
	int currDirValid=0;    
	/*
	 * check if substring to first ':' after initial
	 * nextCheckpoint is a valid relative or absolute
	 * path to a directory, if not we return without
	 * normalizing anything
	 */
	
	while (1) {
	    cur = path[nextCheckpoint];
	    if (cur == ':' || cur == 0) {
		if (cur == ':') { 
		    /* jump over separator */
		    nextCheckpoint++; cur = path[nextCheckpoint]; 
		} 
		Tcl_UtfToExternalDString(NULL,path,nextCheckpoint,&nativeds);
		err = FSpLLocationFromPath(Tcl_DStringLength(&nativeds), 
					  Tcl_DStringValue(&nativeds), 
					  &fileSpec);
		Tcl_DStringFree(&nativeds);
		if (err == noErr) {
			lastFileSpec=fileSpec;
			err = ResolveAliasFile(&fileSpec, true, &isDirectory, 
				       &wasAlias);
			if (err == noErr) {
		    err = FSpGetDirectoryID(&fileSpec, &dirID, &isDirectory);
		    currDirValid = ((err == noErr) && isDirectory);
		    vRefNum = fileSpec.vRefNum;
		    }
		}
		break;
	    }
	    nextCheckpoint++;
	}
	
	if(!currDirValid) {
	    /* can't determine root dir, bail out */
	    return firstCheckpoint; 
	}
    }
	
    /*
     * Now vRefNum and dirID point to a valid
     * directory, so walk the rest of the path
     * ( code adapted from FSpLocationFromPath() )
     */

    lastCheckpoint=nextCheckpoint;
    while (1) {
	cur = path[nextCheckpoint];
	if (cur == ':' || cur == 0) {
	    fileNameLen=nextCheckpoint-lastCheckpoint;
	    fileNamePtr=fileName;
	    if(fileNameLen==0) {
		if (cur == ':') {
		    /*
		     * special case for empty dirname i.e. encountered
		     * a '::' path component: get parent dir of currDir
		     */
		    fileName[0]=2;
		    strcpy((char *) fileName + 1, "::");
		    lastCheckpoint--;
		} else {
		    /*
		     * empty filename, i.e. want FSSpec for currDir
		     */
		    fileNamePtr=NULL;
		}
	    } else {
		Tcl_UtfToExternalDString(NULL,&path[lastCheckpoint],
					 fileNameLen,&nativeds);
		fileNameLen=Tcl_DStringLength(&nativeds);
		if(fileNameLen > MAXMACFILENAMELEN) { 
		    err = bdNamErr;
		} else {
		fileName[0]=fileNameLen;
		strncpy((char *) fileName + 1, Tcl_DStringValue(&nativeds), 
			fileNameLen);
		}
		Tcl_DStringFree(&nativeds);
	    }
	    if(err == noErr)
	    err=FSMakeFSSpecCompat(vRefNum, dirID, fileNamePtr, &fileSpec);
	    if(err != noErr) {
		if(err != fnfErr) {
		    /*
		     * this can occur if trying to get parent of a root
		     * volume via '::' or when using an illegal
		     * filename; revert to last checkpoint and stop
		     * processing path further
		     */
		    err=FSMakeFSSpecCompat(vRefNum, dirID, NULL, &fileSpec);
		    if(err != noErr) {
			/* should never happen, bail out */
			return firstCheckpoint; 
		    }
		    nextCheckpoint=lastCheckpoint;
		    cur = path[lastCheckpoint];
		}
    		break; /* arrived at nonexistent file or dir */
	    } else {
		/* fileSpec could point to an alias, resolve it */
		lastFileSpec=fileSpec;
		err = ResolveAliasFile(&fileSpec, true, &isDirectory, 
				       &wasAlias);
		if (err != noErr || !isDirectory) {
		    break; /* fileSpec doesn't point to a dir */
		}
	    }
	    if (cur == 0) break; /* arrived at end of path */
	    
	    /* fileSpec points to possibly nonexisting subdirectory; validate */
	    err = FSpGetDirectoryID(&fileSpec, &dirID, &isDirectory);
	    if (err != noErr || !isDirectory) {
	        break; /* fileSpec doesn't point to existing dir */
	    }
	    vRefNum = fileSpec.vRefNum;
    	
	    /* found a new valid subdir in path, continue processing path */
	    lastCheckpoint=nextCheckpoint+1;
	}
	wasAlias=FALSE;
	nextCheckpoint++;
    }
    
    if (wasAlias)
    	fileSpec=lastFileSpec;
    
    /*
     * fileSpec now points to a possibly nonexisting file or dir
     *  inside a valid dir; get full path name to it
     */
    
    err=FSpPathFromLocation(&fileSpec, &newPathLen, &newPathHandle);
    if(err != noErr) {
	return firstCheckpoint; /* should not see any errors here, bail out */
    }
    
    HLock(newPathHandle);
    Tcl_ExternalToUtfDString(NULL,*newPathHandle,newPathLen,&nativeds);
    if (cur != 0) {
	/* not at end, append remaining path */
    	if ( newPathLen==0 || (*(*newPathHandle+(newPathLen-1))!=':' && path[nextCheckpoint] !=':')) {
	    Tcl_DStringAppend(&nativeds, ":" , 1);
	}
	Tcl_DStringAppend(&nativeds, &path[nextCheckpoint], 
			  strlen(&path[nextCheckpoint]));
    }
    DisposeHandle(newPathHandle);
    
    fileNameLen=Tcl_DStringLength(&nativeds);
    Tcl_SetStringObj(pathPtr,Tcl_DStringValue(&nativeds),fileNameLen);
    Tcl_DStringFree(&nativeds);
    
    return nextCheckpoint+(fileNameLen-origPathLen);
@


1.1.1.4
log
@import tcl 8.4.1
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tclMacFCmd.c,v 1.18 2002/10/09 11:54:20 das Exp $
a67 5
/*
 * File specific static data
 */

static long startSeed = 248923489;
d90 2
d221 1
a221 1
	        err = GenerateUniqueName(dstFileSpec.vRefNum, &startSeed,
d337 1
a337 1
        err = GenerateUniqueName(srcFileSpecPtr->vRefNum, &startSeed,
d439 1
a439 1
        dstErr = GenerateUniqueName(dstFileSpec.vRefNum, &startSeed, dstFileSpec.parID, 
d710 1
a710 1
        err = GenerateUniqueName(dstFileSpec.vRefNum, &startSeed, dstFileSpec.parID, 
d934 63
@


