head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.58
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.56
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.54
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.52
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.50
	gdb_7_0-branch:1.5.0.48
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tcl8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.46
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.44
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.42
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.40
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.38
	gdb_6_5-2006-05-14-branchpoint:1.5
	readline_5_1-import-branch:1.5.0.36
	readline_5_1-import-branchpoint:1.5
	gdb_6_4-branch:1.5.0.34
	gdb_6_4-2005-11-01-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.32
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	ezannoni_pie-20040323-branch:1.5.0.30
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.28
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.26
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.24
	cagney_x86i386-20030821-branch:1.5.0.22
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.20
	gdb_6_0-2003-06-23-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.18
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.16
	cagney_writestrings-20030508-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.14
	cagney_fileio-20030521-branchpoint:1.5
	carlton_dictionary-20030430-merge:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.12
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.10
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.8
	cagney_lazyid-20030317-branchpoint:1.5
	offbyone-20030313-branch:1.5.0.6
	offbyone-20030313-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.4
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.2
	interps-20030202-branchpoint:1.5
	TCL8_4_1:1.1.1.3
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.2
	TCL_8_4_1:1.1.1.3
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.4
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TCL_8_4_0:1.1.1.3
	carlton_dictionary-branch:1.2.0.16
	carlton_dictionary-20020920-branchpoint:1.2
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.14
	gdb_5_3-branch:1.2.0.12
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.10
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.8
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.6
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TCL_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	dejagnu-2000-02-04:1.1.1.1
	dejagnu-2000-01-31:1.1.1.1
	dejagnu-2000-01-24:1.1.1.1
	dejagnu-2000-01-17:1.1.1.1
	dejagnu-2000-01-10:1.1.1.1
	dejagnu-2000-01-04:1.1.1.1
	dejagnu-1999-12-21:1.1.1.1
	dejagnu-1999-12-13:1.1.1.1
	dejagnu-1999-12-07:1.1.1.1
	dejagnu-1999-12-06:1.1.1.1
	dejagnu-1999-11-15:1.1.1.1
	dejagnu-1999-11-08:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.5
date	2003.01.21.19.40.13;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.26.19.47.59;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.37.07;	author kseitz;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2001.09.09.23.56.07;	author irox;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	99.11.09.01.28.43;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2002.09.27.21.49.09;	author kseitz;	state Exp;
branches;
next	;

1.3.4.1
date	2003.12.14.20.28.48;	author drow;	state Exp;
branches;
next	;

1.2.16.1
date	2002.12.23.19.40.35;	author carlton;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2003.02.07.19.18.16;	author carlton;	state Exp;
branches;
next	;

1.1.1.1
date	99.11.09.01.28.43;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.09.22.40.57;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.19.56.54;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tcl 8.4.1
@
text
@/* 
 * tclMacTime.c --
 *
 *	Contains Macintosh specific versions of Tcl functions that
 *	obtain time values from the operating system.
 *
 * Copyright (c) 1995-1997 Sun Microsystems, Inc.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tclMacTime.c,v 1.7 2002/01/04 11:21:05 das Exp $
 */

#include "tclInt.h"
#include "tclPort.h"
#include "tclMacInt.h"
#include <OSUtils.h>
#include <Timer.h>
#include <time.h>

/*
 * Static variables used by the Tcl_GetTime function.
 */
 
static int initalized = false;
static unsigned long baseSeconds;
static UnsignedWide microOffset;

static int gmt_initialized = false;
static long gmt_offset;
static int gmt_isdst;
TCL_DECLARE_MUTEX(gmtMutex)

static int gmt_lastGetDateUseGMT = 0;

typedef struct _TABLE {
    char        *name;
    int         type;
    time_t      value;
} TABLE;


#define HOUR(x)         ((time_t) (3600 * x))

#define tZONE 0
#define tDAYZONE 1


/*
 * inverse timezone table, adapted from tclDate.c by removing duplicates and
 * adding some made up names for unusual daylight savings
 */
static TABLE    invTimezoneTable[] = {
    { "Z",    -1,     HOUR( 36) },      /* Unknown */
    { "GMT",    tZONE,     HOUR( 0) },      /* Greenwich Mean */
    { "BST",    tDAYZONE,  HOUR( 0) },      /* British Summer */
    { "WAT",    tZONE,     HOUR( 1) },      /* West Africa */
    { "WADST",  tDAYZONE,  HOUR( 1) },      /* West Africa Daylight*/
    { "AT",     tZONE,     HOUR( 2) },      /* Azores Daylight*/
    { "ADST",   tDAYZONE,  HOUR( 2) },      /* Azores */
    { "NFT",    tZONE,     HOUR( 7/2) },    /* Newfoundland */
    { "NDT",    tDAYZONE,  HOUR( 7/2) },    /* Newfoundland Daylight */
    { "AST",    tZONE,     HOUR( 4) },      /* Atlantic Standard */
    { "ADT",    tDAYZONE,  HOUR( 4) },      /* Atlantic Daylight */
    { "EST",    tZONE,     HOUR( 5) },      /* Eastern Standard */
    { "EDT",    tDAYZONE,  HOUR( 5) },      /* Eastern Daylight */
    { "CST",    tZONE,     HOUR( 6) },      /* Central Standard */
    { "CDT",    tDAYZONE,  HOUR( 6) },      /* Central Daylight */
    { "MST",    tZONE,     HOUR( 7) },      /* Mountain Standard */
    { "MDT",    tDAYZONE,  HOUR( 7) },      /* Mountain Daylight */
    { "PST",    tZONE,     HOUR( 8) },      /* Pacific Standard */
    { "PDT",    tDAYZONE,  HOUR( 8) },      /* Pacific Daylight */
    { "YST",    tZONE,     HOUR( 9) },      /* Yukon Standard */
    { "YDT",    tDAYZONE,  HOUR( 9) },      /* Yukon Daylight */
    { "HST",    tZONE,     HOUR(10) },      /* Hawaii Standard */
    { "HDT",    tDAYZONE,  HOUR(10) },      /* Hawaii Daylight */
    { "NT",     tZONE,     HOUR(11) },      /* Nome */
    { "NST",    tDAYZONE,  HOUR(11) },      /* Nome Daylight*/
    { "IDLW",   tZONE,     HOUR(12) },      /* International Date Line West */
    { "CET",    tZONE,    -HOUR( 1) },      /* Central European */
    { "CEST",   tDAYZONE, -HOUR( 1) },      /* Central European Summer */
    { "EET",    tZONE,    -HOUR( 2) },      /* Eastern Europe, USSR Zone 1 */
    { "EEST",   tDAYZONE, -HOUR( 2) },      /* Eastern Europe, USSR Zone 1 Daylight*/
    { "BT",     tZONE,    -HOUR( 3) },      /* Baghdad, USSR Zone 2 */
    { "BDST",   tDAYZONE, -HOUR( 3) },      /* Baghdad, USSR Zone 2 Daylight*/
    { "IT",     tZONE,    -HOUR( 7/2) },    /* Iran */
    { "IDST",   tDAYZONE, -HOUR( 7/2) },    /* Iran Daylight*/
    { "ZP4",    tZONE,    -HOUR( 4) },      /* USSR Zone 3 */
    { "ZP4S",   tDAYZONE, -HOUR( 4) },      /* USSR Zone 3 */
    { "ZP5",    tZONE,    -HOUR( 5) },      /* USSR Zone 4 */
    { "ZP5S",   tDAYZONE, -HOUR( 5) },      /* USSR Zone 4 */
    { "IST",    tZONE,    -HOUR(11/2) },    /* Indian Standard */
    { "ISDST",  tDAYZONE, -HOUR(11/2) },    /* Indian Standard */
    { "ZP6",    tZONE,    -HOUR( 6) },      /* USSR Zone 5 */
    { "ZP6S",   tDAYZONE, -HOUR( 6) },      /* USSR Zone 5 */
    { "WAST",   tZONE,    -HOUR( 7) },      /* West Australian Standard */
    { "WADT",   tDAYZONE, -HOUR( 7) },      /* West Australian Daylight */
    { "JT",     tZONE,    -HOUR(15/2) },    /* Java (3pm in Cronusland!) */
    { "JDST",   tDAYZONE, -HOUR(15/2) },    /* Java (3pm in Cronusland!) */
    { "CCT",    tZONE,    -HOUR( 8) },      /* China Coast, USSR Zone 7 */
    { "CCST",   tDAYZONE, -HOUR( 8) },      /* China Coast, USSR Zone 7 */
    { "JST",    tZONE,    -HOUR( 9) },      /* Japan Standard, USSR Zone 8 */
    { "JSDST",  tDAYZONE, -HOUR( 9) },      /* Japan Standard, USSR Zone 8 */
    { "CAST",   tZONE,    -HOUR(19/2) },    /* Central Australian Standard */
    { "CADT",   tDAYZONE, -HOUR(19/2) },    /* Central Australian Daylight */
    { "EAST",   tZONE,    -HOUR(10) },      /* Eastern Australian Standard */
    { "EADT",   tDAYZONE, -HOUR(10) },      /* Eastern Australian Daylight */
    { "NZT",    tZONE,    -HOUR(12) },      /* New Zealand */
    { "NZDT",   tDAYZONE, -HOUR(12) },      /* New Zealand Daylight */
    {  NULL  }
};

/*
 * Prototypes for procedures that are private to this file:
 */

static void SubtractUnsignedWide _ANSI_ARGS_((UnsignedWide *x,
	UnsignedWide *y, UnsignedWide *result));

/*
 *-----------------------------------------------------------------------------
 *
 * TclpGetGMTOffset --
 *
 *	This procedure gets the offset seconds that needs to be _added_ to tcl time
 *  in seconds (i.e. GMT time) to get local time needed as input to various
 *  Mac OS APIs, to convert Mac OS API output to tcl time, _subtract_ this value.
 *
 * Results:
 *	Number of seconds separating GMT time and mac.
 *
 * Side effects:
 *	None.
 *
 *-----------------------------------------------------------------------------
 */

long
TclpGetGMTOffset()
{
    if (gmt_initialized == false) {
	MachineLocation loc;
	
    Tcl_MutexLock(&gmtMutex);
	ReadLocation(&loc);
	gmt_offset = loc.u.gmtDelta & 0x00ffffff;
	if (gmt_offset & 0x00800000) {
	    gmt_offset = gmt_offset | 0xff000000;
	}
	gmt_isdst=(loc.u.dlsDelta < 0);
	gmt_initialized = true;
    Tcl_MutexUnlock(&gmtMutex);
    }
	return (gmt_offset);
}

/*
 *-----------------------------------------------------------------------------
 *
 * TclpGetSeconds --
 *
 *	This procedure returns the number of seconds from the epoch.  On
 *	the Macintosh the epoch is Midnight Jan 1, 1904.  Unfortunatly,
 *	the Macintosh doesn't tie the epoch to a particular time zone.  For
 *	Tcl we tie the epoch to GMT.  This makes the time zone date parsing
 *	code work.  The epoch for Mac-Tcl is: Midnight Jan 1, 1904 GMT.
 *
 * Results:
 *	Number of seconds from the epoch in GMT.
 *
 * Side effects:
 *	None.
 *
 *-----------------------------------------------------------------------------
 */

unsigned long
TclpGetSeconds()
{
    unsigned long seconds;

    GetDateTime(&seconds);
	return (seconds - TclpGetGMTOffset() + tcl_mac_epoch_offset);
}

/*
 *-----------------------------------------------------------------------------
 *
 * TclpGetClicks --
 *
 *	This procedure returns a value that represents the highest resolution
 *	clock available on the system.  There are no garantees on what the
 *	resolution will be.  In Tcl we will call this value a "click".  The
 *	start time is also system dependant.
 *
 * Results:
 *	Number of clicks from some start time.
 *
 * Side effects:
 *	None.
 *
 *-----------------------------------------------------------------------------
 */

unsigned long
TclpGetClicks()
{
    UnsignedWide micros;

    Microseconds(&micros);
    return micros.lo;
}

/*
 *----------------------------------------------------------------------
 *
 * TclpGetTimeZone --
 *
 *	Get the current time zone.
 *
 * Results:
 *	The return value is the local time zone, measured in
 *	minutes away from GMT (-ve for east, +ve for west).
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
TclpGetTimeZone (
    unsigned long  currentTime)		/* Ignored on Mac. */
{
    long offset;

    /*
     * Convert the Mac offset from seconds to minutes and
     * add an hour if we have daylight savings time.
     */
    offset = -TclpGetGMTOffset();
    offset /= 60;
    if (gmt_isdst) {
	offset += 60;
    }
    
    return offset;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetTime --
 *
 *	Gets the current system time in seconds and microseconds
 *	since the beginning of the epoch: 00:00 UCT, January 1, 1970.
 *
 * Results:
 *	Returns the current time (in the local timezone) in timePtr.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

void
Tcl_GetTime(
    Tcl_Time *timePtr)		/* Location to store time information. */
{
    UnsignedWide micro;
#ifndef NO_LONG_LONG
    long long *microPtr;
#endif
	
    if (initalized == false) {
	GetDateTime(&baseSeconds);
	/*
	 * Remove the local offset that ReadDateTime() adds.
	 */
	baseSeconds -= TclpGetGMTOffset() - tcl_mac_epoch_offset;
	Microseconds(&microOffset);
	initalized = true;
    }

    Microseconds(&micro);

#ifndef NO_LONG_LONG
    microPtr = (long long *) &micro;
    *microPtr -= *((long long *) &microOffset);
    timePtr->sec = baseSeconds + (*microPtr / 1000000);
    timePtr->usec = *microPtr % 1000000;
#else
    SubtractUnsignedWide(&micro, &microOffset, &micro);

    /*
     * This lovely computation is equal to: base + (micro / 1000000)
     * For the .hi part the ratio of 0x100000000 / 1000000 has been
     * reduced to avoid overflow.  This computation certainly has 
     * problems as the .hi part gets large.  However, your application
     * would have to run for a long time to make that happen.
     */

    timePtr->sec = baseSeconds + (micro.lo / 1000000) + 
    	(long) (micro.hi * ((double) 33554432.0 / 15625.0));
    timePtr->usec = micro.lo % 1000000;
#endif
}

/*
 *----------------------------------------------------------------------
 *
 * TclpGetDate --
 *
 *	Converts raw seconds to a struct tm data structure.  The
 *	returned time will be for Greenwich Mean Time if the useGMT flag 
 *	is set.  Otherwise, the returned time will be for the local
 *	time zone.  This function is meant to be used as a replacement
 *	for localtime and gmtime which is broken on most ANSI libs
 *	on the Macintosh.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *  	The passed in struct tm data structure is modified.
 *
 *----------------------------------------------------------------------
 */

struct tm *
TclpGetDate(
    TclpTime_t time,	/* Time struct to fill. */
    int useGMT)		/* True if date should reflect GNT time. */
{
    const time_t *tp = (const time_t *)time;
    DateTimeRec dtr;
    unsigned long offset=0L;
    static struct tm statictime;
    static const short monthday[12] =
        {0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334};
	    
	if(useGMT)
		SecondsToDate(*tp - tcl_mac_epoch_offset, &dtr);
	else
		SecondsToDate(*tp + TclpGetGMTOffset() - tcl_mac_epoch_offset, &dtr);
	
    statictime.tm_sec = dtr.second;
    statictime.tm_min = dtr.minute;
    statictime.tm_hour = dtr.hour;
    statictime.tm_mday = dtr.day;
    statictime.tm_mon = dtr.month - 1;
    statictime.tm_year = dtr.year - 1900;
    statictime.tm_wday = dtr.dayOfWeek - 1;
    statictime.tm_yday = monthday[statictime.tm_mon]
	+ statictime.tm_mday - 1;
    if (1 < statictime.tm_mon && !(statictime.tm_year & 3)) {
	++statictime.tm_yday;
    }
    if(useGMT)
    	statictime.tm_isdst = 0;
    else
    	statictime.tm_isdst = gmt_isdst;
    gmt_lastGetDateUseGMT=useGMT; /* hack to make TclpGetTZName below work */
    return(&statictime);
}

/*
 *----------------------------------------------------------------------
 *
 * TclpGetTZName --
 *
 *	Gets the current timezone string.
 *
 * Results:
 *	Returns a pointer to a static string, or NULL on failure.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

char *
TclpGetTZName(int dst)
{
    register TABLE *tp;
	long zonevalue=-TclpGetGMTOffset();
		
    if (gmt_isdst)
        zonevalue += HOUR(1);

	if(gmt_lastGetDateUseGMT) /* hack: if last TclpGetDate was called */
		zonevalue=0;          /* with useGMT==1 then we're using GMT  */

    for (tp = invTimezoneTable; tp->name; tp++) {
        if ((tp->value == zonevalue) && (tp->type == dst)) break;
    }
	if(!tp->name)
		tp = invTimezoneTable; /* default to unknown */

    return tp->name;
}

#ifdef NO_LONG_LONG
/*
 *----------------------------------------------------------------------
 *
 * SubtractUnsignedWide --
 *
 *	Subtracts one UnsignedWide value from another.
 *
 * Results:
 *  	The subtracted value.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static void
SubtractUnsignedWide(
    UnsignedWide *x,		/* Ptr to wide int. */
    UnsignedWide *y,		/* Ptr to wide int. */
    UnsignedWide *result)	/* Ptr to result. */
{
    result->hi = x->hi - y->hi;
    if (x->lo < y->lo) {
	result->hi--;
    }
    result->lo = x->lo - y->lo;
}
#endif
@


1.4
log
@touched all sources to ease next import
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tclMacTime.c,v 1.6.8.1 2000/04/06 22:38:31 spolk Exp $
d17 1
d23 1
a23 1
 * Static variables used by the TclpGetTime function.
d30 84
d124 37
a181 8
    MachineLocation loc;
    long int offset;
    
    ReadLocation(&loc);
    offset = loc.u.gmtDelta & 0x00ffffff;
    if (offset & 0x00800000) {
	offset = offset | 0xff000000;
    }
d183 2
a184 6
    if (ReadDateTime(&seconds) == noErr) {
	return (seconds - offset);
    } else {
	panic("Can't get time.");
	return 0;
    }
d236 1
a236 8
    MachineLocation loc;
    long int offset;

    ReadLocation(&loc);
    offset = loc.u.gmtDelta & 0x00ffffff;
    if (offset & 0x00700000) {
	offset |= 0xff000000;
    }
d242 1
a242 1
    offset = -offset;
d244 1
a244 1
    if (loc.u.dlsDelta < 0) {
d254 1
a254 1
 * TclpGetTime --
d269 1
a269 1
TclpGetTime(
d278 1
a278 14
        MachineLocation loc;
        long int offset;
    
        ReadLocation(&loc);
        offset = loc.u.gmtDelta & 0x00ffffff;
        if (offset & 0x00800000) {
            offset = offset | 0xff000000;
	}
	if (ReadDateTime(&baseSeconds) != noErr) {
	    /*
	     * This should never happen!
	     */
	    return;
	}
d282 1
a282 1
	baseSeconds -= offset;
d339 1
a339 2
    MachineLocation loc;
    long int offset;
d343 5
a347 10

    ReadLocation(&loc);
	
    if (useGMT) {
	SecondsToDate(*tp, &dtr);
    } else {
	offset = loc.u.gmtDelta & 0x00ffffff;
	if (offset & 0x00700000) {
	    offset |= 0xff000000;
	}
a348 3
	SecondsToDate(*tp + offset, &dtr);
    }

d361 5
a365 1
    statictime.tm_isdst = loc.u.dlsDelta;
d367 37
@


1.3
log
@touched all sources to ease next import
@
text
@@


1.3.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tclMacTime.c,v 1.7 2002/01/04 11:21:05 das Exp $
a16 1
#include "tclMacInt.h"
d22 1
a22 1
 * Static variables used by the Tcl_GetTime function.
a28 84
static int gmt_initialized = false;
static long gmt_offset;
static int gmt_isdst;
TCL_DECLARE_MUTEX(gmtMutex)

static int gmt_lastGetDateUseGMT = 0;

typedef struct _TABLE {
    char        *name;
    int         type;
    time_t      value;
} TABLE;


#define HOUR(x)         ((time_t) (3600 * x))

#define tZONE 0
#define tDAYZONE 1


/*
 * inverse timezone table, adapted from tclDate.c by removing duplicates and
 * adding some made up names for unusual daylight savings
 */
static TABLE    invTimezoneTable[] = {
    { "Z",    -1,     HOUR( 36) },      /* Unknown */
    { "GMT",    tZONE,     HOUR( 0) },      /* Greenwich Mean */
    { "BST",    tDAYZONE,  HOUR( 0) },      /* British Summer */
    { "WAT",    tZONE,     HOUR( 1) },      /* West Africa */
    { "WADST",  tDAYZONE,  HOUR( 1) },      /* West Africa Daylight*/
    { "AT",     tZONE,     HOUR( 2) },      /* Azores Daylight*/
    { "ADST",   tDAYZONE,  HOUR( 2) },      /* Azores */
    { "NFT",    tZONE,     HOUR( 7/2) },    /* Newfoundland */
    { "NDT",    tDAYZONE,  HOUR( 7/2) },    /* Newfoundland Daylight */
    { "AST",    tZONE,     HOUR( 4) },      /* Atlantic Standard */
    { "ADT",    tDAYZONE,  HOUR( 4) },      /* Atlantic Daylight */
    { "EST",    tZONE,     HOUR( 5) },      /* Eastern Standard */
    { "EDT",    tDAYZONE,  HOUR( 5) },      /* Eastern Daylight */
    { "CST",    tZONE,     HOUR( 6) },      /* Central Standard */
    { "CDT",    tDAYZONE,  HOUR( 6) },      /* Central Daylight */
    { "MST",    tZONE,     HOUR( 7) },      /* Mountain Standard */
    { "MDT",    tDAYZONE,  HOUR( 7) },      /* Mountain Daylight */
    { "PST",    tZONE,     HOUR( 8) },      /* Pacific Standard */
    { "PDT",    tDAYZONE,  HOUR( 8) },      /* Pacific Daylight */
    { "YST",    tZONE,     HOUR( 9) },      /* Yukon Standard */
    { "YDT",    tDAYZONE,  HOUR( 9) },      /* Yukon Daylight */
    { "HST",    tZONE,     HOUR(10) },      /* Hawaii Standard */
    { "HDT",    tDAYZONE,  HOUR(10) },      /* Hawaii Daylight */
    { "NT",     tZONE,     HOUR(11) },      /* Nome */
    { "NST",    tDAYZONE,  HOUR(11) },      /* Nome Daylight*/
    { "IDLW",   tZONE,     HOUR(12) },      /* International Date Line West */
    { "CET",    tZONE,    -HOUR( 1) },      /* Central European */
    { "CEST",   tDAYZONE, -HOUR( 1) },      /* Central European Summer */
    { "EET",    tZONE,    -HOUR( 2) },      /* Eastern Europe, USSR Zone 1 */
    { "EEST",   tDAYZONE, -HOUR( 2) },      /* Eastern Europe, USSR Zone 1 Daylight*/
    { "BT",     tZONE,    -HOUR( 3) },      /* Baghdad, USSR Zone 2 */
    { "BDST",   tDAYZONE, -HOUR( 3) },      /* Baghdad, USSR Zone 2 Daylight*/
    { "IT",     tZONE,    -HOUR( 7/2) },    /* Iran */
    { "IDST",   tDAYZONE, -HOUR( 7/2) },    /* Iran Daylight*/
    { "ZP4",    tZONE,    -HOUR( 4) },      /* USSR Zone 3 */
    { "ZP4S",   tDAYZONE, -HOUR( 4) },      /* USSR Zone 3 */
    { "ZP5",    tZONE,    -HOUR( 5) },      /* USSR Zone 4 */
    { "ZP5S",   tDAYZONE, -HOUR( 5) },      /* USSR Zone 4 */
    { "IST",    tZONE,    -HOUR(11/2) },    /* Indian Standard */
    { "ISDST",  tDAYZONE, -HOUR(11/2) },    /* Indian Standard */
    { "ZP6",    tZONE,    -HOUR( 6) },      /* USSR Zone 5 */
    { "ZP6S",   tDAYZONE, -HOUR( 6) },      /* USSR Zone 5 */
    { "WAST",   tZONE,    -HOUR( 7) },      /* West Australian Standard */
    { "WADT",   tDAYZONE, -HOUR( 7) },      /* West Australian Daylight */
    { "JT",     tZONE,    -HOUR(15/2) },    /* Java (3pm in Cronusland!) */
    { "JDST",   tDAYZONE, -HOUR(15/2) },    /* Java (3pm in Cronusland!) */
    { "CCT",    tZONE,    -HOUR( 8) },      /* China Coast, USSR Zone 7 */
    { "CCST",   tDAYZONE, -HOUR( 8) },      /* China Coast, USSR Zone 7 */
    { "JST",    tZONE,    -HOUR( 9) },      /* Japan Standard, USSR Zone 8 */
    { "JSDST",  tDAYZONE, -HOUR( 9) },      /* Japan Standard, USSR Zone 8 */
    { "CAST",   tZONE,    -HOUR(19/2) },    /* Central Australian Standard */
    { "CADT",   tDAYZONE, -HOUR(19/2) },    /* Central Australian Daylight */
    { "EAST",   tZONE,    -HOUR(10) },      /* Eastern Australian Standard */
    { "EADT",   tDAYZONE, -HOUR(10) },      /* Eastern Australian Daylight */
    { "NZT",    tZONE,    -HOUR(12) },      /* New Zealand */
    { "NZDT",   tDAYZONE, -HOUR(12) },      /* New Zealand Daylight */
    {  NULL  }
};

a38 37
 * TclpGetGMTOffset --
 *
 *	This procedure gets the offset seconds that needs to be _added_ to tcl time
 *  in seconds (i.e. GMT time) to get local time needed as input to various
 *  Mac OS APIs, to convert Mac OS API output to tcl time, _subtract_ this value.
 *
 * Results:
 *	Number of seconds separating GMT time and mac.
 *
 * Side effects:
 *	None.
 *
 *-----------------------------------------------------------------------------
 */

long
TclpGetGMTOffset()
{
    if (gmt_initialized == false) {
	MachineLocation loc;
	
    Tcl_MutexLock(&gmtMutex);
	ReadLocation(&loc);
	gmt_offset = loc.u.gmtDelta & 0x00ffffff;
	if (gmt_offset & 0x00800000) {
	    gmt_offset = gmt_offset | 0xff000000;
	}
	gmt_isdst=(loc.u.dlsDelta < 0);
	gmt_initialized = true;
    Tcl_MutexUnlock(&gmtMutex);
    }
	return (gmt_offset);
}

/*
 *-----------------------------------------------------------------------------
 *
d60 8
d69 6
a74 2
    GetDateTime(&seconds);
	return (seconds - TclpGetGMTOffset() + tcl_mac_epoch_offset);
d126 8
a133 1
    long offset;
d139 1
a139 1
    offset = -TclpGetGMTOffset();
d141 1
a141 1
    if (gmt_isdst) {
d151 1
a151 1
 * Tcl_GetTime --
d166 1
a166 1
Tcl_GetTime(
d175 14
a188 1
	GetDateTime(&baseSeconds);
d192 1
a192 1
	baseSeconds -= TclpGetGMTOffset() - tcl_mac_epoch_offset;
d249 2
a250 1
    unsigned long offset=0L;
d254 10
a263 5
	    
	if(useGMT)
		SecondsToDate(*tp - tcl_mac_epoch_offset, &dtr);
	else
		SecondsToDate(*tp + TclpGetGMTOffset() - tcl_mac_epoch_offset, &dtr);
d265 3
d280 1
a280 5
    if(useGMT)
    	statictime.tm_isdst = 0;
    else
    	statictime.tm_isdst = gmt_isdst;
    gmt_lastGetDateUseGMT=useGMT; /* hack to make TclpGetTZName below work */
a281 37
}

/*
 *----------------------------------------------------------------------
 *
 * TclpGetTZName --
 *
 *	Gets the current timezone string.
 *
 * Results:
 *	Returns a pointer to a static string, or NULL on failure.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

char *
TclpGetTZName(int dst)
{
    register TABLE *tp;
	long zonevalue=-TclpGetGMTOffset();
		
    if (gmt_isdst)
        zonevalue += HOUR(1);

	if(gmt_lastGetDateUseGMT) /* hack: if last TclpGetDate was called */
		zonevalue=0;          /* with useGMT==1 then we're using GMT  */

    for (tp = invTimezoneTable; tp->name; tp++) {
        if ((tp->value == zonevalue) && (tp->type == dst)) break;
    }
	if(!tp->name)
		tp = invTimezoneTable; /* default to unknown */

    return tp->name;
@


1.3.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tclMacTime.c,v 1.7 2002/01/04 11:21:05 das Exp $
a16 1
#include "tclMacInt.h"
d22 1
a22 1
 * Static variables used by the Tcl_GetTime function.
a28 84
static int gmt_initialized = false;
static long gmt_offset;
static int gmt_isdst;
TCL_DECLARE_MUTEX(gmtMutex)

static int gmt_lastGetDateUseGMT = 0;

typedef struct _TABLE {
    char        *name;
    int         type;
    time_t      value;
} TABLE;


#define HOUR(x)         ((time_t) (3600 * x))

#define tZONE 0
#define tDAYZONE 1


/*
 * inverse timezone table, adapted from tclDate.c by removing duplicates and
 * adding some made up names for unusual daylight savings
 */
static TABLE    invTimezoneTable[] = {
    { "Z",    -1,     HOUR( 36) },      /* Unknown */
    { "GMT",    tZONE,     HOUR( 0) },      /* Greenwich Mean */
    { "BST",    tDAYZONE,  HOUR( 0) },      /* British Summer */
    { "WAT",    tZONE,     HOUR( 1) },      /* West Africa */
    { "WADST",  tDAYZONE,  HOUR( 1) },      /* West Africa Daylight*/
    { "AT",     tZONE,     HOUR( 2) },      /* Azores Daylight*/
    { "ADST",   tDAYZONE,  HOUR( 2) },      /* Azores */
    { "NFT",    tZONE,     HOUR( 7/2) },    /* Newfoundland */
    { "NDT",    tDAYZONE,  HOUR( 7/2) },    /* Newfoundland Daylight */
    { "AST",    tZONE,     HOUR( 4) },      /* Atlantic Standard */
    { "ADT",    tDAYZONE,  HOUR( 4) },      /* Atlantic Daylight */
    { "EST",    tZONE,     HOUR( 5) },      /* Eastern Standard */
    { "EDT",    tDAYZONE,  HOUR( 5) },      /* Eastern Daylight */
    { "CST",    tZONE,     HOUR( 6) },      /* Central Standard */
    { "CDT",    tDAYZONE,  HOUR( 6) },      /* Central Daylight */
    { "MST",    tZONE,     HOUR( 7) },      /* Mountain Standard */
    { "MDT",    tDAYZONE,  HOUR( 7) },      /* Mountain Daylight */
    { "PST",    tZONE,     HOUR( 8) },      /* Pacific Standard */
    { "PDT",    tDAYZONE,  HOUR( 8) },      /* Pacific Daylight */
    { "YST",    tZONE,     HOUR( 9) },      /* Yukon Standard */
    { "YDT",    tDAYZONE,  HOUR( 9) },      /* Yukon Daylight */
    { "HST",    tZONE,     HOUR(10) },      /* Hawaii Standard */
    { "HDT",    tDAYZONE,  HOUR(10) },      /* Hawaii Daylight */
    { "NT",     tZONE,     HOUR(11) },      /* Nome */
    { "NST",    tDAYZONE,  HOUR(11) },      /* Nome Daylight*/
    { "IDLW",   tZONE,     HOUR(12) },      /* International Date Line West */
    { "CET",    tZONE,    -HOUR( 1) },      /* Central European */
    { "CEST",   tDAYZONE, -HOUR( 1) },      /* Central European Summer */
    { "EET",    tZONE,    -HOUR( 2) },      /* Eastern Europe, USSR Zone 1 */
    { "EEST",   tDAYZONE, -HOUR( 2) },      /* Eastern Europe, USSR Zone 1 Daylight*/
    { "BT",     tZONE,    -HOUR( 3) },      /* Baghdad, USSR Zone 2 */
    { "BDST",   tDAYZONE, -HOUR( 3) },      /* Baghdad, USSR Zone 2 Daylight*/
    { "IT",     tZONE,    -HOUR( 7/2) },    /* Iran */
    { "IDST",   tDAYZONE, -HOUR( 7/2) },    /* Iran Daylight*/
    { "ZP4",    tZONE,    -HOUR( 4) },      /* USSR Zone 3 */
    { "ZP4S",   tDAYZONE, -HOUR( 4) },      /* USSR Zone 3 */
    { "ZP5",    tZONE,    -HOUR( 5) },      /* USSR Zone 4 */
    { "ZP5S",   tDAYZONE, -HOUR( 5) },      /* USSR Zone 4 */
    { "IST",    tZONE,    -HOUR(11/2) },    /* Indian Standard */
    { "ISDST",  tDAYZONE, -HOUR(11/2) },    /* Indian Standard */
    { "ZP6",    tZONE,    -HOUR( 6) },      /* USSR Zone 5 */
    { "ZP6S",   tDAYZONE, -HOUR( 6) },      /* USSR Zone 5 */
    { "WAST",   tZONE,    -HOUR( 7) },      /* West Australian Standard */
    { "WADT",   tDAYZONE, -HOUR( 7) },      /* West Australian Daylight */
    { "JT",     tZONE,    -HOUR(15/2) },    /* Java (3pm in Cronusland!) */
    { "JDST",   tDAYZONE, -HOUR(15/2) },    /* Java (3pm in Cronusland!) */
    { "CCT",    tZONE,    -HOUR( 8) },      /* China Coast, USSR Zone 7 */
    { "CCST",   tDAYZONE, -HOUR( 8) },      /* China Coast, USSR Zone 7 */
    { "JST",    tZONE,    -HOUR( 9) },      /* Japan Standard, USSR Zone 8 */
    { "JSDST",  tDAYZONE, -HOUR( 9) },      /* Japan Standard, USSR Zone 8 */
    { "CAST",   tZONE,    -HOUR(19/2) },    /* Central Australian Standard */
    { "CADT",   tDAYZONE, -HOUR(19/2) },    /* Central Australian Daylight */
    { "EAST",   tZONE,    -HOUR(10) },      /* Eastern Australian Standard */
    { "EADT",   tDAYZONE, -HOUR(10) },      /* Eastern Australian Daylight */
    { "NZT",    tZONE,    -HOUR(12) },      /* New Zealand */
    { "NZDT",   tDAYZONE, -HOUR(12) },      /* New Zealand Daylight */
    {  NULL  }
};

a38 37
 * TclpGetGMTOffset --
 *
 *	This procedure gets the offset seconds that needs to be _added_ to tcl time
 *  in seconds (i.e. GMT time) to get local time needed as input to various
 *  Mac OS APIs, to convert Mac OS API output to tcl time, _subtract_ this value.
 *
 * Results:
 *	Number of seconds separating GMT time and mac.
 *
 * Side effects:
 *	None.
 *
 *-----------------------------------------------------------------------------
 */

long
TclpGetGMTOffset()
{
    if (gmt_initialized == false) {
	MachineLocation loc;
	
    Tcl_MutexLock(&gmtMutex);
	ReadLocation(&loc);
	gmt_offset = loc.u.gmtDelta & 0x00ffffff;
	if (gmt_offset & 0x00800000) {
	    gmt_offset = gmt_offset | 0xff000000;
	}
	gmt_isdst=(loc.u.dlsDelta < 0);
	gmt_initialized = true;
    Tcl_MutexUnlock(&gmtMutex);
    }
	return (gmt_offset);
}

/*
 *-----------------------------------------------------------------------------
 *
d60 8
d69 6
a74 2
    GetDateTime(&seconds);
	return (seconds - TclpGetGMTOffset() + tcl_mac_epoch_offset);
d126 8
a133 1
    long offset;
d139 1
a139 1
    offset = -TclpGetGMTOffset();
d141 1
a141 1
    if (gmt_isdst) {
d151 1
a151 1
 * Tcl_GetTime --
d166 1
a166 1
Tcl_GetTime(
d175 14
a188 1
	GetDateTime(&baseSeconds);
d192 1
a192 1
	baseSeconds -= TclpGetGMTOffset() - tcl_mac_epoch_offset;
d249 2
a250 1
    unsigned long offset=0L;
d254 10
a263 5
	    
	if(useGMT)
		SecondsToDate(*tp - tcl_mac_epoch_offset, &dtr);
	else
		SecondsToDate(*tp + TclpGetGMTOffset() - tcl_mac_epoch_offset, &dtr);
d265 3
d280 1
a280 5
    if(useGMT)
    	statictime.tm_isdst = 0;
    else
    	statictime.tm_isdst = gmt_isdst;
    gmt_lastGetDateUseGMT=useGMT; /* hack to make TclpGetTZName below work */
a281 37
}

/*
 *----------------------------------------------------------------------
 *
 * TclpGetTZName --
 *
 *	Gets the current timezone string.
 *
 * Results:
 *	Returns a pointer to a static string, or NULL on failure.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

char *
TclpGetTZName(int dst)
{
    register TABLE *tp;
	long zonevalue=-TclpGetGMTOffset();
		
    if (gmt_isdst)
        zonevalue += HOUR(1);

	if(gmt_lastGetDateUseGMT) /* hack: if last TclpGetDate was called */
		zonevalue=0;          /* with useGMT==1 then we're using GMT  */

    for (tp = invTimezoneTable; tp->name; tp++) {
        if ((tp->value == zonevalue) && (tp->type == dst)) break;
    }
	if(!tp->name)
		tp = invTimezoneTable; /* default to unknown */

    return tp->name;
@


1.2
log
@touched all Tcl files to ease next import.
@
text
@@


1.2.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.2.16.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@a16 1
#include "tclMacInt.h"
d22 1
a22 1
 * Static variables used by the Tcl_GetTime function.
a28 84
static int gmt_initialized = false;
static long gmt_offset;
static int gmt_isdst;
TCL_DECLARE_MUTEX(gmtMutex)

static int gmt_lastGetDateUseGMT = 0;

typedef struct _TABLE {
    char        *name;
    int         type;
    time_t      value;
} TABLE;


#define HOUR(x)         ((time_t) (3600 * x))

#define tZONE 0
#define tDAYZONE 1


/*
 * inverse timezone table, adapted from tclDate.c by removing duplicates and
 * adding some made up names for unusual daylight savings
 */
static TABLE    invTimezoneTable[] = {
    { "Z",    -1,     HOUR( 36) },      /* Unknown */
    { "GMT",    tZONE,     HOUR( 0) },      /* Greenwich Mean */
    { "BST",    tDAYZONE,  HOUR( 0) },      /* British Summer */
    { "WAT",    tZONE,     HOUR( 1) },      /* West Africa */
    { "WADST",  tDAYZONE,  HOUR( 1) },      /* West Africa Daylight*/
    { "AT",     tZONE,     HOUR( 2) },      /* Azores Daylight*/
    { "ADST",   tDAYZONE,  HOUR( 2) },      /* Azores */
    { "NFT",    tZONE,     HOUR( 7/2) },    /* Newfoundland */
    { "NDT",    tDAYZONE,  HOUR( 7/2) },    /* Newfoundland Daylight */
    { "AST",    tZONE,     HOUR( 4) },      /* Atlantic Standard */
    { "ADT",    tDAYZONE,  HOUR( 4) },      /* Atlantic Daylight */
    { "EST",    tZONE,     HOUR( 5) },      /* Eastern Standard */
    { "EDT",    tDAYZONE,  HOUR( 5) },      /* Eastern Daylight */
    { "CST",    tZONE,     HOUR( 6) },      /* Central Standard */
    { "CDT",    tDAYZONE,  HOUR( 6) },      /* Central Daylight */
    { "MST",    tZONE,     HOUR( 7) },      /* Mountain Standard */
    { "MDT",    tDAYZONE,  HOUR( 7) },      /* Mountain Daylight */
    { "PST",    tZONE,     HOUR( 8) },      /* Pacific Standard */
    { "PDT",    tDAYZONE,  HOUR( 8) },      /* Pacific Daylight */
    { "YST",    tZONE,     HOUR( 9) },      /* Yukon Standard */
    { "YDT",    tDAYZONE,  HOUR( 9) },      /* Yukon Daylight */
    { "HST",    tZONE,     HOUR(10) },      /* Hawaii Standard */
    { "HDT",    tDAYZONE,  HOUR(10) },      /* Hawaii Daylight */
    { "NT",     tZONE,     HOUR(11) },      /* Nome */
    { "NST",    tDAYZONE,  HOUR(11) },      /* Nome Daylight*/
    { "IDLW",   tZONE,     HOUR(12) },      /* International Date Line West */
    { "CET",    tZONE,    -HOUR( 1) },      /* Central European */
    { "CEST",   tDAYZONE, -HOUR( 1) },      /* Central European Summer */
    { "EET",    tZONE,    -HOUR( 2) },      /* Eastern Europe, USSR Zone 1 */
    { "EEST",   tDAYZONE, -HOUR( 2) },      /* Eastern Europe, USSR Zone 1 Daylight*/
    { "BT",     tZONE,    -HOUR( 3) },      /* Baghdad, USSR Zone 2 */
    { "BDST",   tDAYZONE, -HOUR( 3) },      /* Baghdad, USSR Zone 2 Daylight*/
    { "IT",     tZONE,    -HOUR( 7/2) },    /* Iran */
    { "IDST",   tDAYZONE, -HOUR( 7/2) },    /* Iran Daylight*/
    { "ZP4",    tZONE,    -HOUR( 4) },      /* USSR Zone 3 */
    { "ZP4S",   tDAYZONE, -HOUR( 4) },      /* USSR Zone 3 */
    { "ZP5",    tZONE,    -HOUR( 5) },      /* USSR Zone 4 */
    { "ZP5S",   tDAYZONE, -HOUR( 5) },      /* USSR Zone 4 */
    { "IST",    tZONE,    -HOUR(11/2) },    /* Indian Standard */
    { "ISDST",  tDAYZONE, -HOUR(11/2) },    /* Indian Standard */
    { "ZP6",    tZONE,    -HOUR( 6) },      /* USSR Zone 5 */
    { "ZP6S",   tDAYZONE, -HOUR( 6) },      /* USSR Zone 5 */
    { "WAST",   tZONE,    -HOUR( 7) },      /* West Australian Standard */
    { "WADT",   tDAYZONE, -HOUR( 7) },      /* West Australian Daylight */
    { "JT",     tZONE,    -HOUR(15/2) },    /* Java (3pm in Cronusland!) */
    { "JDST",   tDAYZONE, -HOUR(15/2) },    /* Java (3pm in Cronusland!) */
    { "CCT",    tZONE,    -HOUR( 8) },      /* China Coast, USSR Zone 7 */
    { "CCST",   tDAYZONE, -HOUR( 8) },      /* China Coast, USSR Zone 7 */
    { "JST",    tZONE,    -HOUR( 9) },      /* Japan Standard, USSR Zone 8 */
    { "JSDST",  tDAYZONE, -HOUR( 9) },      /* Japan Standard, USSR Zone 8 */
    { "CAST",   tZONE,    -HOUR(19/2) },    /* Central Australian Standard */
    { "CADT",   tDAYZONE, -HOUR(19/2) },    /* Central Australian Daylight */
    { "EAST",   tZONE,    -HOUR(10) },      /* Eastern Australian Standard */
    { "EADT",   tDAYZONE, -HOUR(10) },      /* Eastern Australian Daylight */
    { "NZT",    tZONE,    -HOUR(12) },      /* New Zealand */
    { "NZDT",   tDAYZONE, -HOUR(12) },      /* New Zealand Daylight */
    {  NULL  }
};

a38 37
 * TclpGetGMTOffset --
 *
 *	This procedure gets the offset seconds that needs to be _added_ to tcl time
 *  in seconds (i.e. GMT time) to get local time needed as input to various
 *  Mac OS APIs, to convert Mac OS API output to tcl time, _subtract_ this value.
 *
 * Results:
 *	Number of seconds separating GMT time and mac.
 *
 * Side effects:
 *	None.
 *
 *-----------------------------------------------------------------------------
 */

long
TclpGetGMTOffset()
{
    if (gmt_initialized == false) {
	MachineLocation loc;
	
    Tcl_MutexLock(&gmtMutex);
	ReadLocation(&loc);
	gmt_offset = loc.u.gmtDelta & 0x00ffffff;
	if (gmt_offset & 0x00800000) {
	    gmt_offset = gmt_offset | 0xff000000;
	}
	gmt_isdst=(loc.u.dlsDelta < 0);
	gmt_initialized = true;
    Tcl_MutexUnlock(&gmtMutex);
    }
	return (gmt_offset);
}

/*
 *-----------------------------------------------------------------------------
 *
d60 8
d69 6
a74 2
    GetDateTime(&seconds);
	return (seconds - TclpGetGMTOffset() + tcl_mac_epoch_offset);
d126 8
a133 1
    long offset;
d139 1
a139 1
    offset = -TclpGetGMTOffset();
d141 1
a141 1
    if (gmt_isdst) {
d151 1
a151 1
 * Tcl_GetTime --
d166 1
a166 1
Tcl_GetTime(
d175 14
a188 1
	GetDateTime(&baseSeconds);
d192 1
a192 1
	baseSeconds -= TclpGetGMTOffset() - tcl_mac_epoch_offset;
d249 2
a250 1
    unsigned long offset=0L;
d254 10
a263 5
	    
	if(useGMT)
		SecondsToDate(*tp - tcl_mac_epoch_offset, &dtr);
	else
		SecondsToDate(*tp + TclpGetGMTOffset() - tcl_mac_epoch_offset, &dtr);
d265 3
d280 1
a280 5
    if(useGMT)
    	statictime.tm_isdst = 0;
    else
    	statictime.tm_isdst = gmt_isdst;
    gmt_lastGetDateUseGMT=useGMT; /* hack to make TclpGetTZName below work */
a281 37
}

/*
 *----------------------------------------------------------------------
 *
 * TclpGetTZName --
 *
 *	Gets the current timezone string.
 *
 * Results:
 *	Returns a pointer to a static string, or NULL on failure.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

char *
TclpGetTZName(int dst)
{
    register TABLE *tp;
	long zonevalue=-TclpGetGMTOffset();
		
    if (gmt_isdst)
        zonevalue += HOUR(1);

	if(gmt_lastGetDateUseGMT) /* hack: if last TclpGetDate was called */
		zonevalue=0;          /* with useGMT==1 then we're using GMT  */

    for (tp = invTimezoneTable; tp->name; tp++) {
        if ((tp->value == zonevalue) && (tp->type == dst)) break;
    }
	if(!tp->name)
		tp = invTimezoneTable; /* default to unknown */

    return tp->name;
@


1.1
log
@Initial revision
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tclMacTime.c,v 1.7 1999/01/26 03:53:27 jingham Exp $
d244 1
a244 1
    const time_t *tp,	/* Time struct to fill. */
d247 1
@


1.1.1.1
log
@import dejagnu-1999-11-08 snapshot
@
text
@@


1.1.1.2
log
@Tcl 8.3 upgrade
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tclMacTime.c,v 1.6.8.1 2000/04/06 22:38:31 spolk Exp $
d244 1
a244 1
    TclpTime_t time,	/* Time struct to fill. */
a246 1
    const time_t *tp = (const time_t *)time;
@


1.1.1.3
log
@import tcl 8.4.0
@
text
@d12 1
a12 1
 * RCS: @@(#) $Id: tclMacTime.c,v 1.7 2002/01/04 11:21:05 das Exp $
a16 1
#include "tclMacInt.h"
d22 1
a22 1
 * Static variables used by the Tcl_GetTime function.
a28 84
static int gmt_initialized = false;
static long gmt_offset;
static int gmt_isdst;
TCL_DECLARE_MUTEX(gmtMutex)

static int gmt_lastGetDateUseGMT = 0;

typedef struct _TABLE {
    char        *name;
    int         type;
    time_t      value;
} TABLE;


#define HOUR(x)         ((time_t) (3600 * x))

#define tZONE 0
#define tDAYZONE 1


/*
 * inverse timezone table, adapted from tclDate.c by removing duplicates and
 * adding some made up names for unusual daylight savings
 */
static TABLE    invTimezoneTable[] = {
    { "Z",    -1,     HOUR( 36) },      /* Unknown */
    { "GMT",    tZONE,     HOUR( 0) },      /* Greenwich Mean */
    { "BST",    tDAYZONE,  HOUR( 0) },      /* British Summer */
    { "WAT",    tZONE,     HOUR( 1) },      /* West Africa */
    { "WADST",  tDAYZONE,  HOUR( 1) },      /* West Africa Daylight*/
    { "AT",     tZONE,     HOUR( 2) },      /* Azores Daylight*/
    { "ADST",   tDAYZONE,  HOUR( 2) },      /* Azores */
    { "NFT",    tZONE,     HOUR( 7/2) },    /* Newfoundland */
    { "NDT",    tDAYZONE,  HOUR( 7/2) },    /* Newfoundland Daylight */
    { "AST",    tZONE,     HOUR( 4) },      /* Atlantic Standard */
    { "ADT",    tDAYZONE,  HOUR( 4) },      /* Atlantic Daylight */
    { "EST",    tZONE,     HOUR( 5) },      /* Eastern Standard */
    { "EDT",    tDAYZONE,  HOUR( 5) },      /* Eastern Daylight */
    { "CST",    tZONE,     HOUR( 6) },      /* Central Standard */
    { "CDT",    tDAYZONE,  HOUR( 6) },      /* Central Daylight */
    { "MST",    tZONE,     HOUR( 7) },      /* Mountain Standard */
    { "MDT",    tDAYZONE,  HOUR( 7) },      /* Mountain Daylight */
    { "PST",    tZONE,     HOUR( 8) },      /* Pacific Standard */
    { "PDT",    tDAYZONE,  HOUR( 8) },      /* Pacific Daylight */
    { "YST",    tZONE,     HOUR( 9) },      /* Yukon Standard */
    { "YDT",    tDAYZONE,  HOUR( 9) },      /* Yukon Daylight */
    { "HST",    tZONE,     HOUR(10) },      /* Hawaii Standard */
    { "HDT",    tDAYZONE,  HOUR(10) },      /* Hawaii Daylight */
    { "NT",     tZONE,     HOUR(11) },      /* Nome */
    { "NST",    tDAYZONE,  HOUR(11) },      /* Nome Daylight*/
    { "IDLW",   tZONE,     HOUR(12) },      /* International Date Line West */
    { "CET",    tZONE,    -HOUR( 1) },      /* Central European */
    { "CEST",   tDAYZONE, -HOUR( 1) },      /* Central European Summer */
    { "EET",    tZONE,    -HOUR( 2) },      /* Eastern Europe, USSR Zone 1 */
    { "EEST",   tDAYZONE, -HOUR( 2) },      /* Eastern Europe, USSR Zone 1 Daylight*/
    { "BT",     tZONE,    -HOUR( 3) },      /* Baghdad, USSR Zone 2 */
    { "BDST",   tDAYZONE, -HOUR( 3) },      /* Baghdad, USSR Zone 2 Daylight*/
    { "IT",     tZONE,    -HOUR( 7/2) },    /* Iran */
    { "IDST",   tDAYZONE, -HOUR( 7/2) },    /* Iran Daylight*/
    { "ZP4",    tZONE,    -HOUR( 4) },      /* USSR Zone 3 */
    { "ZP4S",   tDAYZONE, -HOUR( 4) },      /* USSR Zone 3 */
    { "ZP5",    tZONE,    -HOUR( 5) },      /* USSR Zone 4 */
    { "ZP5S",   tDAYZONE, -HOUR( 5) },      /* USSR Zone 4 */
    { "IST",    tZONE,    -HOUR(11/2) },    /* Indian Standard */
    { "ISDST",  tDAYZONE, -HOUR(11/2) },    /* Indian Standard */
    { "ZP6",    tZONE,    -HOUR( 6) },      /* USSR Zone 5 */
    { "ZP6S",   tDAYZONE, -HOUR( 6) },      /* USSR Zone 5 */
    { "WAST",   tZONE,    -HOUR( 7) },      /* West Australian Standard */
    { "WADT",   tDAYZONE, -HOUR( 7) },      /* West Australian Daylight */
    { "JT",     tZONE,    -HOUR(15/2) },    /* Java (3pm in Cronusland!) */
    { "JDST",   tDAYZONE, -HOUR(15/2) },    /* Java (3pm in Cronusland!) */
    { "CCT",    tZONE,    -HOUR( 8) },      /* China Coast, USSR Zone 7 */
    { "CCST",   tDAYZONE, -HOUR( 8) },      /* China Coast, USSR Zone 7 */
    { "JST",    tZONE,    -HOUR( 9) },      /* Japan Standard, USSR Zone 8 */
    { "JSDST",  tDAYZONE, -HOUR( 9) },      /* Japan Standard, USSR Zone 8 */
    { "CAST",   tZONE,    -HOUR(19/2) },    /* Central Australian Standard */
    { "CADT",   tDAYZONE, -HOUR(19/2) },    /* Central Australian Daylight */
    { "EAST",   tZONE,    -HOUR(10) },      /* Eastern Australian Standard */
    { "EADT",   tDAYZONE, -HOUR(10) },      /* Eastern Australian Daylight */
    { "NZT",    tZONE,    -HOUR(12) },      /* New Zealand */
    { "NZDT",   tDAYZONE, -HOUR(12) },      /* New Zealand Daylight */
    {  NULL  }
};

a38 37
 * TclpGetGMTOffset --
 *
 *	This procedure gets the offset seconds that needs to be _added_ to tcl time
 *  in seconds (i.e. GMT time) to get local time needed as input to various
 *  Mac OS APIs, to convert Mac OS API output to tcl time, _subtract_ this value.
 *
 * Results:
 *	Number of seconds separating GMT time and mac.
 *
 * Side effects:
 *	None.
 *
 *-----------------------------------------------------------------------------
 */

long
TclpGetGMTOffset()
{
    if (gmt_initialized == false) {
	MachineLocation loc;
	
    Tcl_MutexLock(&gmtMutex);
	ReadLocation(&loc);
	gmt_offset = loc.u.gmtDelta & 0x00ffffff;
	if (gmt_offset & 0x00800000) {
	    gmt_offset = gmt_offset | 0xff000000;
	}
	gmt_isdst=(loc.u.dlsDelta < 0);
	gmt_initialized = true;
    Tcl_MutexUnlock(&gmtMutex);
    }
	return (gmt_offset);
}

/*
 *-----------------------------------------------------------------------------
 *
d60 8
d69 6
a74 2
    GetDateTime(&seconds);
	return (seconds - TclpGetGMTOffset() + tcl_mac_epoch_offset);
d126 8
a133 1
    long offset;
d139 1
a139 1
    offset = -TclpGetGMTOffset();
d141 1
a141 1
    if (gmt_isdst) {
d151 1
a151 1
 * Tcl_GetTime --
d166 1
a166 1
Tcl_GetTime(
d175 14
a188 1
	GetDateTime(&baseSeconds);
d192 1
a192 1
	baseSeconds -= TclpGetGMTOffset() - tcl_mac_epoch_offset;
d249 2
a250 1
    unsigned long offset=0L;
d254 10
a263 5
	    
	if(useGMT)
		SecondsToDate(*tp - tcl_mac_epoch_offset, &dtr);
	else
		SecondsToDate(*tp + TclpGetGMTOffset() - tcl_mac_epoch_offset, &dtr);
d265 3
d280 1
a280 5
    if(useGMT)
    	statictime.tm_isdst = 0;
    else
    	statictime.tm_isdst = gmt_isdst;
    gmt_lastGetDateUseGMT=useGMT; /* hack to make TclpGetTZName below work */
a281 37
}

/*
 *----------------------------------------------------------------------
 *
 * TclpGetTZName --
 *
 *	Gets the current timezone string.
 *
 * Results:
 *	Returns a pointer to a static string, or NULL on failure.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

char *
TclpGetTZName(int dst)
{
    register TABLE *tp;
	long zonevalue=-TclpGetGMTOffset();
		
    if (gmt_isdst)
        zonevalue += HOUR(1);

	if(gmt_lastGetDateUseGMT) /* hack: if last TclpGetDate was called */
		zonevalue=0;          /* with useGMT==1 then we're using GMT  */

    for (tp = invTimezoneTable; tp->name; tp++) {
        if ((tp->value == zonevalue) && (tp->type == dst)) break;
    }
	if(!tp->name)
		tp = invTimezoneTable; /* default to unknown */

    return tp->name;
@


