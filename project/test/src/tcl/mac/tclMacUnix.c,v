head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.58
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.56
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.54
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.52
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.50
	gdb_7_0-branch:1.5.0.48
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tcl8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.46
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.44
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.42
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.40
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.38
	gdb_6_5-2006-05-14-branchpoint:1.5
	readline_5_1-import-branch:1.5.0.36
	readline_5_1-import-branchpoint:1.5
	gdb_6_4-branch:1.5.0.34
	gdb_6_4-2005-11-01-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.32
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	ezannoni_pie-20040323-branch:1.5.0.30
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.28
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.26
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.24
	cagney_x86i386-20030821-branch:1.5.0.22
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.20
	gdb_6_0-2003-06-23-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.18
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.16
	cagney_writestrings-20030508-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.14
	cagney_fileio-20030521-branchpoint:1.5
	carlton_dictionary-20030430-merge:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.12
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.10
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.8
	cagney_lazyid-20030317-branchpoint:1.5
	offbyone-20030313-branch:1.5.0.6
	offbyone-20030313-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.4
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.2
	interps-20030202-branchpoint:1.5
	TCL8_4_1:1.1.1.4
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.2
	TCL_8_4_1:1.1.1.4
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.4
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TCL_8_4_0:1.1.1.3
	carlton_dictionary-branch:1.2.0.16
	carlton_dictionary-20020920-branchpoint:1.2
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.14
	gdb_5_3-branch:1.2.0.12
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.10
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.8
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.6
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TCL_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	dejagnu-2000-02-04:1.1.1.1
	dejagnu-2000-01-31:1.1.1.1
	dejagnu-2000-01-24:1.1.1.1
	dejagnu-2000-01-17:1.1.1.1
	dejagnu-2000-01-10:1.1.1.1
	dejagnu-2000-01-04:1.1.1.1
	dejagnu-1999-12-21:1.1.1.1
	dejagnu-1999-12-13:1.1.1.1
	dejagnu-1999-12-07:1.1.1.1
	dejagnu-1999-12-06:1.1.1.1
	dejagnu-1999-11-15:1.1.1.1
	dejagnu-1999-11-08:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.5
date	2003.01.21.19.40.13;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.26.19.47.59;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.37.07;	author kseitz;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2001.09.09.23.56.07;	author irox;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	99.11.09.01.28.43;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2002.09.27.21.49.09;	author kseitz;	state Exp;
branches;
next	;

1.3.4.1
date	2003.12.14.20.28.48;	author drow;	state Exp;
branches;
next	;

1.2.16.1
date	2002.12.23.19.40.35;	author carlton;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2003.02.07.19.18.16;	author carlton;	state Exp;
branches;
next	;

1.1.1.1
date	99.11.09.01.28.43;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.09.22.40.57;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.19.56.54;	author kseitz;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.11.26.20.01.39;	author hunt;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tcl 8.4.1
@
text
@/* 
 * tclMacUnix.c --
 *
 *	This file contains routines to implement several features
 *	available to the Unix implementation, but that require
 *      extra work to do on a Macintosh.  These include routines
 *      Unix Tcl normally hands off to the Unix OS.
 *
 * Copyright (c) 1993-1994 Lockheed Missle & Space Company, AI Center
 * Copyright (c) 1994-1997 Sun Microsystems, Inc.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tclMacUnix.c,v 1.5 2002/10/09 11:54:45 das Exp $
 */

#include <Files.h>
#include <Strings.h>
#include <TextUtils.h>
#include <Finder.h>
#include <FSpCompat.h>
#include <Aliases.h>
#include <Errors.h>

#include "tclInt.h"
#include "tclMacInt.h"

/*
 * The following two Includes are from the More Files package
 */
#include "FileCopy.h"
#include "MoreFiles.h"
#include "MoreFilesExtras.h"

/*
 * The following may not be defined in some versions of
 * MPW header files.
 */
#ifndef kIsInvisible
#define kIsInvisible 0x4000
#endif
#ifndef kIsAlias
#define kIsAlias 0x8000
#endif

/*
 * Missing error codes
 */
#define usageErr		500
#define noSourceErr		501
#define isDirErr		502


/*
 *----------------------------------------------------------------------
 *
 * Tcl_EchoCmd --
 *
 *    Implements the TCL echo command:
 *        echo ?str ...?
 *
 * Results:
 *      Always returns TCL_OK.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_EchoCmd(
    ClientData dummy,			/* Not used. */
    Tcl_Interp *interp,			/* Current interpreter. */
    int argc,				/* Number of arguments. */
    CONST char **argv)			/* Argument strings. */
{
    Tcl_Channel chan;
    int mode, result, i;

    chan = Tcl_GetChannel(interp, "stdout", &mode);
    if (chan == (Tcl_Channel) NULL) {
        return TCL_ERROR;
    }
    for (i = 1; i < argc; i++) {
	result = Tcl_WriteChars(chan, argv[i], -1);
	if (result < 0) {
	    Tcl_AppendResult(interp, "echo: ", Tcl_GetChannelName(chan),
		    ": ", Tcl_PosixError(interp), (char *) NULL);
	    return TCL_ERROR;
	}
        if (i < (argc - 1)) {
	    Tcl_WriteChars(chan, " ", -1);
	}
    }
    Tcl_WriteChars(chan, "\n", -1);
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_LsObjCmd --
 *
 *	This procedure is invoked to process the "ls" Tcl command.
 *	See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */
int
Tcl_LsObjCmd(
    ClientData dummy,			/* Not used. */
    Tcl_Interp *interp,			/* Current interpreter. */
    int objc,				/* Number of arguments. */
    Tcl_Obj *CONST objv[])		/* Argument strings. */
{
#define STRING_LENGTH 80
#define CR '\n'
    int i, j;
    int fieldLength, len = 0, maxLen = 0, perLine;
    OSErr err;
    CInfoPBRec paramBlock;
    HFileInfo *hpb = (HFileInfo *)&paramBlock;
    DirInfo *dpb = (DirInfo *)&paramBlock;
    char theFile[256];
    char theLine[STRING_LENGTH + 2];
    int fFlag = false, pFlag = false, aFlag = false, lFlag = false,
	cFlag = false, hFlag = false;
    char *argv;
    Tcl_Obj *newObjv[2], *resultObjPtr;

    /*
     * Process command flags.  End if argument doesn't start
     * with a dash or is a dash by itself.  The remaining arguments
     * should be files.
     */
    for (i = 1; i < objc; i++) {
    	argv = Tcl_GetString(objv[i]);
	if (argv[0] != '-') {
	    break;
	}
		
	if (!strcmp(argv, "-")) {
	    i++;
	    break;
	}
		
	for (j = 1 ; argv[j] ; ++j) {
	    switch(argv[j]) {
	    case 'a':
	    case 'A':
		aFlag = true;
		break;
	    case '1':
		cFlag = false;
		break;
	    case 'C':
		cFlag = true;
		break;
	    case 'F':
		fFlag = true;
		break;
	    case 'H':
		hFlag = true;
		break;
	    case 'p':
		pFlag = true;
		break;
	    case 'l':
		pFlag = false;
		lFlag = true;
		break;
	    default:
		Tcl_AppendResult(interp, "error - unknown flag ",
			"usage: ls -apCFHl1 ?files? ", NULL);
		return TCL_ERROR;
	    }
	}
    }

    objv += i;
    objc -= i;

    /*
     * No file specifications means we search for all files.
     * Glob will be doing most of the work.
     */
     if (!objc) {
	objc = 1;
	newObjv[0] = Tcl_NewStringObj("*", -1);
	newObjv[1] = NULL;
	objv = newObjv;
    }

    if (Tcl_GlobObjCmd(NULL, interp, objc + 1, objv - 1) != TCL_OK) {
    	Tcl_ResetResult(interp);
    	return TCL_ERROR;
    }

    resultObjPtr = Tcl_GetObjResult(interp);
    Tcl_IncrRefCount(resultObjPtr);
    if (Tcl_ListObjGetElements(interp, resultObjPtr, &objc, (Tcl_Obj ***)&objv) != TCL_OK) {
    	Tcl_DecrRefCount(resultObjPtr);
    	return TCL_ERROR;
    }

    Tcl_ResetResult(interp);

    /*
     * There are two major methods for listing files: the long
     * method and the normal method.
     */
    if (lFlag) {
	char	creator[5], type[5], time[16], date[16];
	char	lineTag;
	long	size;
	unsigned short flags;
	Tcl_Obj *objPtr;
	char *string;
	int length;

	/*
	 * Print the header for long listing.
	 */
	if (hFlag) {
	    sprintf(theLine, "T %7s %8s %8s %4s %4s %6s %s",
		    "Size", "ModTime", "ModDate",
		    "CRTR", "TYPE", "Flags", "Name");
	    Tcl_AppendResult(interp, theLine, "\n", NULL);
	    Tcl_AppendResult(interp,
		    "-------------------------------------------------------------\n",
		    NULL);
	}
		
	for (i = 0; i < objc; i++) {
	    strcpy(theFile, Tcl_GetString(objv[i]));
			
	    c2pstr(theFile);
	    hpb->ioCompletion = NULL;
	    hpb->ioVRefNum = 0;
	    hpb->ioFDirIndex = 0;
	    hpb->ioNamePtr = (StringPtr) theFile;
	    hpb->ioDirID = 0L;
	    err = PBGetCatInfoSync(&paramBlock);
	    p2cstr((StringPtr) theFile);

	    if (hpb->ioFlAttrib & 16) {
		/*
		 * For directories use zero as the size, use no Creator
		 * type, and use 'DIR ' as the file type.
		 */
		if ((aFlag == false) && (dpb->ioDrUsrWds.frFlags & 0x1000)) {
		    continue;
		}
		lineTag = 'D';
		size = 0;
		IUTimeString(dpb->ioDrMdDat, false, (unsigned char *)time);
		p2cstr((StringPtr)time);
		IUDateString(dpb->ioDrMdDat, shortDate, (unsigned char *)date);
		p2cstr((StringPtr)date);
		strcpy(creator, "    ");
		strcpy(type, "DIR ");
		flags = dpb->ioDrUsrWds.frFlags;
		if (fFlag || pFlag) {
		    strcat(theFile, ":");
		}
	    } else {
		/*
		 * All information for files should be printed.  This
		 * includes size, modtime, moddate, creator type, file
		 * type, flags, anf file name.
		 */
		if ((aFlag == false) &&
			(hpb->ioFlFndrInfo.fdFlags & kIsInvisible)) {
		    continue;
		}
		lineTag = 'F';
		size = hpb->ioFlLgLen + hpb->ioFlRLgLen;
		IUTimeString(hpb->ioFlMdDat, false, (unsigned char *)time);
		p2cstr((StringPtr)time);
		IUDateString(hpb->ioFlMdDat, shortDate, (unsigned char *)date);
		p2cstr((StringPtr)date);
		strncpy(creator, (char *) &hpb->ioFlFndrInfo.fdCreator, 4);
		creator[4] = 0;
		strncpy(type, (char *) &hpb->ioFlFndrInfo.fdType, 4);
		type[4] = 0;
		flags = hpb->ioFlFndrInfo.fdFlags;
		if (fFlag) {
		    if (hpb->ioFlFndrInfo.fdFlags & kIsAlias) {
			strcat(theFile, "@@");
		    } else if (hpb->ioFlFndrInfo.fdType == 'APPL') {
			strcat(theFile, "*");
		    }
		}
	    }
			
	    sprintf(theLine, "%c %7ld %8s %8s %-4.4s %-4.4s 0x%4.4X %s",
		    lineTag, size, time, date, creator, type, flags, theFile);
						 
	    Tcl_AppendResult(interp, theLine, "\n", NULL);
	    
	}
		
	objPtr = Tcl_GetObjResult(interp);
	string = Tcl_GetStringFromObj(objPtr, &length);
	if ((length > 0) && (string[length - 1] == '\n')) {
	    Tcl_SetObjLength(objPtr, length - 1);
	}
    } else {
	/*
	 * Not in long format. We only print files names.  If the
	 * -C flag is set we need to print in multiple coloumns.
	 */
	int argCount, linePos;
	Boolean needNewLine = false;

	/*
	 * Fiend the field length: the length each string printed
	 * to the terminal will be.
	 */
	if (!cFlag) {
	    perLine = 1;
	    fieldLength = STRING_LENGTH;
	} else {
	    for (i = 0; i < objc; i++) {
	    	argv = Tcl_GetString(objv[i]);
		len = strlen(argv);
		if (len > maxLen) {
		    maxLen = len;
		}
	    }
	    fieldLength = maxLen + 3;
	    perLine = STRING_LENGTH / fieldLength;
	}

	argCount = 0;
	linePos = 0;
	memset(theLine, ' ', STRING_LENGTH);
	while (argCount < objc) {
	    strcpy(theFile, Tcl_GetString(objv[argCount]));
			
	    c2pstr(theFile);
	    hpb->ioCompletion = NULL;
	    hpb->ioVRefNum = 0;
	    hpb->ioFDirIndex = 0;
	    hpb->ioNamePtr = (StringPtr) theFile;
	    hpb->ioDirID = 0L;
	    err = PBGetCatInfoSync(&paramBlock);
	    p2cstr((StringPtr) theFile);

	    if (hpb->ioFlAttrib & 16) {
		/*
		 * Directory. If -a show hidden files.  If -f or -p
		 * denote that this is a directory.
		 */
		if ((aFlag == false) && (dpb->ioDrUsrWds.frFlags & 0x1000)) {
		    argCount++;
		    continue;
		}
		if (fFlag || pFlag) {
		    strcat(theFile, ":");
		}
	    } else {
		/*
		 * File: If -a show hidden files, if -f show links
		 * (aliases) and executables (APPLs).
		 */
		if ((aFlag == false) &&
			(hpb->ioFlFndrInfo.fdFlags & kIsInvisible)) {
		    argCount++;
		    continue;
		}
		if (fFlag) {
		    if (hpb->ioFlFndrInfo.fdFlags & kIsAlias) {
			strcat(theFile, "@@");
		    } else if (hpb->ioFlFndrInfo.fdType == 'APPL') {
			strcat(theFile, "*");
		    }
		}
	    }

	    /*
	     * Print the item, taking into account multi-
	     * coloum output.
	     */
	    strncpy(theLine + (linePos * fieldLength), theFile,
		    strlen(theFile));
	    linePos++;
			
	    if (linePos == perLine) {
		theLine[STRING_LENGTH] = '\0';
		if (needNewLine) {
		    Tcl_AppendResult(interp, "\n", theLine, NULL);
		} else {
		    Tcl_AppendResult(interp, theLine, NULL);
		    needNewLine = true;
		}
		linePos = 0;
		memset(theLine, ' ', STRING_LENGTH);
	    }
			
	    argCount++;
	}
		
	if (linePos != 0) {
	    theLine[STRING_LENGTH] = '\0';
	    if (needNewLine) {
		Tcl_AppendResult(interp, "\n", theLine, NULL);
	    } else {
		Tcl_AppendResult(interp, theLine, NULL);
	    }
	}
    }

    Tcl_DecrRefCount(resultObjPtr);
    	
    return TCL_OK;
}
@


1.4
log
@touched all sources to ease next import
@
text
@d15 1
a15 1
 * RCS: @@(#) $Id: tclMacUnix.c,v 1.6.8.1 2000/04/06 22:38:31 spolk Exp $
d77 1
a77 1
    char **argv)			/* Argument strings. */
d209 1
a209 1
    if (Tcl_ListObjGetElements(interp, resultObjPtr, &objc, &objv) != TCL_OK) {
@


1.3
log
@touched all sources to ease next import
@
text
@@


1.3.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d15 1
a15 1
 * RCS: @@(#) $Id: tclMacUnix.c,v 1.5 2002/10/09 11:54:45 das Exp $
d77 1
a77 1
    CONST char **argv)			/* Argument strings. */
d209 1
a209 1
    if (Tcl_ListObjGetElements(interp, resultObjPtr, &objc, (Tcl_Obj ***)&objv) != TCL_OK) {
@


1.3.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@d15 1
a15 1
 * RCS: @@(#) $Id: tclMacUnix.c,v 1.4 2001/11/23 01:28:46 das Exp $
d209 1
a209 1
    if (Tcl_ListObjGetElements(interp, resultObjPtr, &objc, (Tcl_Obj ***)&objv) != TCL_OK) {
@


1.2
log
@touched all Tcl files to ease next import.
@
text
@@


1.2.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.2.16.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d77 1
a77 1
    CONST char **argv)			/* Argument strings. */
d209 1
a209 1
    if (Tcl_ListObjGetElements(interp, resultObjPtr, &objc, (Tcl_Obj ***)&objv) != TCL_OK) {
@


1.1
log
@Initial revision
@
text
@d10 1
a10 1
 * Copyright (c) 1994-1996 Sun Microsystems, Inc.
d15 1
a15 1
 * RCS: @@(#) $Id: tclMacUnix.c,v 1.9 1999/01/26 03:53:27 jingham Exp $
a53 54
/*
 * Static functions in this file.
 */

static int	GlobArgs _ANSI_ARGS_((Tcl_Interp *interp,
		    int *argc, char ***argv));

/*
 *----------------------------------------------------------------------
 *
 * GlobArgs --
 *
 *	The following function was taken from Peter Keleher's Alpha
 *	Editor.  *argc should only count the end arguments that should
 *	be globed.  argv should be incremented to point to the first
 *	arg to be globed.
 *
 * Results:
 *	Returns 'true' if it worked & memory was allocated, else 'false'.
 *
 * Side effects:
 *	argv will be alloced, the call will need to release the memory
 *
 *----------------------------------------------------------------------
 */
 
static int
GlobArgs(
    Tcl_Interp *interp,		/* Tcl interpreter. */
    int *argc,			/* Number of arguments. */
    char ***argv)		/* Argument strings. */
{
    int res, len;
    char *list;
	
    /*
     * Places the globbed args all into 'interp->result' as a list.
     */
    res = Tcl_GlobCmd(NULL, interp, *argc + 1, *argv - 1);
    if (res != TCL_OK) {
	return false;
    }
    len = strlen(interp->result);
    list = (char *) ckalloc(len + 1);
    strcpy(list, interp->result);
    Tcl_ResetResult(interp);
	
    res = Tcl_SplitList(interp, list, argc, argv);
    ckfree((char *) list);
    if (res != TCL_OK) {
	return false;
    }
    return true;
}
d87 1
a87 1
	result = Tcl_Write(chan, argv[i], -1);
d94 1
a94 1
	    Tcl_Write(chan, " ", -1);
d97 1
a97 1
    Tcl_Write(chan, "\n", -1);
d104 1
a104 1
 * Tcl_LsCmd --
d118 1
a118 1
Tcl_LsCmd(
d121 2
a122 2
    int argc,				/* Number of arguments. */
    char **argv)			/* Argument strings. */
a127 1
    char **origArgv = argv;
d136 2
d144 3
a146 2
    for (i = 1; i < argc; i++) {
	if (argv[i][0] != '-') {
d150 1
a150 1
	if (!strcmp(argv[i], "-")) {
d155 2
a156 2
	for (j = 1 ; argv[i][j] ; ++j) {
	    switch(argv[i][j]) {
d188 2
a189 2
    argv += i;
    argc -= i;
d195 10
a204 4
     if (!argc) {
	argc = 1;
	argv = origArgv;
	strcpy(argv[0], "*");
d207 5
a211 3
    if (!GlobArgs(interp, &argc, &argv)) {
	Tcl_ResetResult(interp);
	return TCL_ERROR;
d214 2
d225 3
d242 2
a243 2
	for (i = 0; i < argc; i++) {
	    strcpy(theFile, argv[i]);
d311 4
a314 5
	if ((interp->result != NULL) && (*(interp->result) != '\0')) {
	    int slen = strlen(interp->result);
	    if (interp->result[slen - 1] == '\n') {
		interp->result[slen - 1] = '\0';
	    }
d332 3
a334 2
	    for (i = 0; i < argc; i++) {
		len = strlen(argv[i]);
d346 2
a347 2
	while (argCount < argc) {
	    strcpy(theFile, argv[argCount]);
d421 3
a423 3
	
    ckfree((char *) argv);
	
@


1.1.1.1
log
@import dejagnu-1999-11-08 snapshot
@
text
@@


1.1.1.2
log
@Tcl 8.3 upgrade
@
text
@d10 1
a10 1
 * Copyright (c) 1994-1997 Sun Microsystems, Inc.
d15 1
a15 1
 * RCS: @@(#) $Id: tclMacUnix.c,v 1.6.8.1 2000/04/06 22:38:31 spolk Exp $
d54 54
d141 1
a141 1
	result = Tcl_WriteChars(chan, argv[i], -1);
d148 1
a148 1
	    Tcl_WriteChars(chan, " ", -1);
d151 1
a151 1
    Tcl_WriteChars(chan, "\n", -1);
d158 1
a158 1
 * Tcl_LsObjCmd --
d172 1
a172 1
Tcl_LsObjCmd(
d175 2
a176 2
    int objc,				/* Number of arguments. */
    Tcl_Obj *CONST objv[])		/* Argument strings. */
d182 1
a190 2
    char *argv;
    Tcl_Obj *newObjv[2], *resultObjPtr;
d197 2
a198 3
    for (i = 1; i < objc; i++) {
    	argv = Tcl_GetString(objv[i]);
	if (argv[0] != '-') {
d202 1
a202 1
	if (!strcmp(argv, "-")) {
d207 2
a208 2
	for (j = 1 ; argv[j] ; ++j) {
	    switch(argv[j]) {
d240 2
a241 2
    objv += i;
    objc -= i;
d247 4
a250 10
     if (!objc) {
	objc = 1;
	newObjv[0] = Tcl_NewStringObj("*", -1);
	newObjv[1] = NULL;
	objv = newObjv;
    }

    if (Tcl_GlobObjCmd(NULL, interp, objc + 1, objv - 1) != TCL_OK) {
    	Tcl_ResetResult(interp);
    	return TCL_ERROR;
d253 3
a255 5
    resultObjPtr = Tcl_GetObjResult(interp);
    Tcl_IncrRefCount(resultObjPtr);
    if (Tcl_ListObjGetElements(interp, resultObjPtr, &objc, &objv) != TCL_OK) {
    	Tcl_DecrRefCount(resultObjPtr);
    	return TCL_ERROR;
a257 2
    Tcl_ResetResult(interp);

a266 3
	Tcl_Obj *objPtr;
	char *string;
	int length;
d281 2
a282 2
	for (i = 0; i < objc; i++) {
	    strcpy(theFile, Tcl_GetString(objv[i]));
d350 5
a354 4
	objPtr = Tcl_GetObjResult(interp);
	string = Tcl_GetStringFromObj(objPtr, &length);
	if ((length > 0) && (string[length - 1] == '\n')) {
	    Tcl_SetObjLength(objPtr, length - 1);
d372 2
a373 3
	    for (i = 0; i < objc; i++) {
	    	argv = Tcl_GetString(objv[i]);
		len = strlen(argv);
d385 2
a386 2
	while (argCount < objc) {
	    strcpy(theFile, Tcl_GetString(objv[argCount]));
d460 3
a462 3

    Tcl_DecrRefCount(resultObjPtr);
    	
@


1.1.1.3
log
@import tcl 8.4.0
@
text
@d15 1
a15 1
 * RCS: @@(#) $Id: tclMacUnix.c,v 1.4 2001/11/23 01:28:46 das Exp $
d209 1
a209 1
    if (Tcl_ListObjGetElements(interp, resultObjPtr, &objc, (Tcl_Obj ***)&objv) != TCL_OK) {
@


1.1.1.4
log
@import tcl 8.4.1
@
text
@d15 1
a15 1
 * RCS: @@(#) $Id: tclMacUnix.c,v 1.5 2002/10/09 11:54:45 das Exp $
d77 1
a77 1
    CONST char **argv)			/* Argument strings. */
@


