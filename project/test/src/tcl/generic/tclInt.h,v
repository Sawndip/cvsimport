head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.58
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.56
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.54
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.52
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.50
	gdb_7_0-branch:1.5.0.48
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tcl8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.46
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.44
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.42
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.40
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.38
	gdb_6_5-2006-05-14-branchpoint:1.5
	readline_5_1-import-branch:1.5.0.36
	readline_5_1-import-branchpoint:1.5
	gdb_6_4-branch:1.5.0.34
	gdb_6_4-2005-11-01-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.32
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	ezannoni_pie-20040323-branch:1.5.0.30
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.28
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.26
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.24
	cagney_x86i386-20030821-branch:1.5.0.22
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.20
	gdb_6_0-2003-06-23-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.18
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.16
	cagney_writestrings-20030508-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.14
	cagney_fileio-20030521-branchpoint:1.5
	carlton_dictionary-20030430-merge:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.12
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.10
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.8
	cagney_lazyid-20030317-branchpoint:1.5
	offbyone-20030313-branch:1.5.0.6
	offbyone-20030313-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.4
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.2
	interps-20030202-branchpoint:1.5
	TCL8_4_1:1.1.1.3
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.2
	TCL_8_4_1:1.1.1.3
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.4
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TCL_8_4_0:1.1.1.3
	carlton_dictionary-branch:1.2.0.16
	carlton_dictionary-20020920-branchpoint:1.2
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.14
	gdb_5_3-branch:1.2.0.12
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.10
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.8
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.6
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TCL_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	dejagnu-2000-02-04:1.1.1.1
	dejagnu-2000-01-31:1.1.1.1
	dejagnu-2000-01-24:1.1.1.1
	dejagnu-2000-01-17:1.1.1.1
	dejagnu-2000-01-10:1.1.1.1
	dejagnu-2000-01-04:1.1.1.1
	dejagnu-1999-12-21:1.1.1.1
	dejagnu-1999-12-13:1.1.1.1
	dejagnu-1999-12-07:1.1.1.1
	dejagnu-1999-12-06:1.1.1.1
	dejagnu-1999-11-15:1.1.1.1
	dejagnu-1999-11-08:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.5
date	2003.01.21.19.40.04;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.26.19.47.53;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.37.02;	author kseitz;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2001.09.09.23.56.05;	author irox;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	99.11.09.01.28.43;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2002.09.27.21.49.04;	author kseitz;	state Exp;
branches;
next	;

1.3.4.1
date	2003.12.14.20.28.44;	author drow;	state Exp;
branches;
next	;

1.2.16.1
date	2002.12.23.19.40.21;	author carlton;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2003.02.07.19.18.12;	author carlton;	state Exp;
branches;
next	;

1.1.1.1
date	99.11.09.01.28.43;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.09.22.40.55;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.19.56.13;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tcl 8.4.1
@
text
@/*
 * tclInt.h --
 *
 *	Declarations of things used internally by the Tcl interpreter.
 *
 * Copyright (c) 1987-1993 The Regents of the University of California.
 * Copyright (c) 1993-1997 Lucent Technologies.
 * Copyright (c) 1994-1998 Sun Microsystems, Inc.
 * Copyright (c) 1998-1999 by Scriptics Corporation.
 * Copyright (c) 2001, 2002 by Kevin B. Kenny.  All rights reserved.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tclInt.h,v 1.111 2002/08/14 17:31:43 msofer Exp $
 */

#ifndef _TCLINT
#define _TCLINT

/*
 * Common include files needed by most of the Tcl source files are
 * included here, so that system-dependent personalizations for the
 * include files only have to be made in once place.  This results
 * in a few extra includes, but greater modularity.  The order of
 * the three groups of #includes is important.	For example, stdio.h
 * is needed by tcl.h, and the _ANSI_ARGS_ declaration in tcl.h is
 * needed by stdlib.h in some configurations.
 */

#ifndef _TCL
#include "tcl.h"
#endif

#include <stdio.h>

#include <ctype.h>
#ifdef NO_LIMITS_H
#   include "../compat/limits.h"
#else
#   include <limits.h>
#endif
#ifdef NO_STDLIB_H
#   include "../compat/stdlib.h"
#else
#   include <stdlib.h>
#endif
#ifdef NO_STRING_H
#include "../compat/string.h"
#else
#include <string.h>
#endif

#undef TCL_STORAGE_CLASS
#ifdef BUILD_tcl
# define TCL_STORAGE_CLASS DLLEXPORT
#else
# ifdef USE_TCL_STUBS
#  define TCL_STORAGE_CLASS
# else
#  define TCL_STORAGE_CLASS DLLIMPORT
# endif
#endif

/*
 * The following procedures allow namespaces to be customized to
 * support special name resolution rules for commands/variables.
 * 
 */

struct Tcl_ResolvedVarInfo;

typedef Tcl_Var (Tcl_ResolveRuntimeVarProc) _ANSI_ARGS_((
    Tcl_Interp* interp, struct Tcl_ResolvedVarInfo *vinfoPtr));

typedef void (Tcl_ResolveVarDeleteProc) _ANSI_ARGS_((
    struct Tcl_ResolvedVarInfo *vinfoPtr));

/*
 * The following structure encapsulates the routines needed to resolve a
 * variable reference at runtime.  Any variable specific state will typically
 * be appended to this structure.
 */


typedef struct Tcl_ResolvedVarInfo {
    Tcl_ResolveRuntimeVarProc *fetchProc;
    Tcl_ResolveVarDeleteProc *deleteProc;
} Tcl_ResolvedVarInfo;



typedef int (Tcl_ResolveCompiledVarProc) _ANSI_ARGS_((
    Tcl_Interp* interp, CONST84 char* name, int length,
    Tcl_Namespace *context, Tcl_ResolvedVarInfo **rPtr));

typedef int (Tcl_ResolveVarProc) _ANSI_ARGS_((
    Tcl_Interp* interp, CONST84 char* name, Tcl_Namespace *context,
    int flags, Tcl_Var *rPtr));

typedef int (Tcl_ResolveCmdProc) _ANSI_ARGS_((Tcl_Interp* interp,
    CONST84 char* name, Tcl_Namespace *context, int flags,
    Tcl_Command *rPtr));
 
typedef struct Tcl_ResolverInfo {
    Tcl_ResolveCmdProc *cmdResProc;	/* Procedure handling command name
					 * resolution. */
    Tcl_ResolveVarProc *varResProc;	/* Procedure handling variable name
					 * resolution for variables that
					 * can only be handled at runtime. */
    Tcl_ResolveCompiledVarProc *compiledVarResProc;
					/* Procedure handling variable name
					 * resolution at compile time. */
} Tcl_ResolverInfo;

/*
 *----------------------------------------------------------------
 * Data structures related to namespaces.
 *----------------------------------------------------------------
 */

/*
 * The structure below defines a namespace.
 * Note: the first five fields must match exactly the fields in a
 * Tcl_Namespace structure (see tcl.h). If you change one, be sure to
 * change the other.
 */

typedef struct Namespace {
    char *name;			 /* The namespace's simple (unqualified)
				  * name. This contains no ::'s. The name of
				  * the global namespace is "" although "::"
				  * is an synonym. */
    char *fullName;		 /* The namespace's fully qualified name.
				  * This starts with ::. */
    ClientData clientData;	 /* An arbitrary value associated with this
				  * namespace. */
    Tcl_NamespaceDeleteProc *deleteProc;
				 /* Procedure invoked when deleting the
				  * namespace to, e.g., free clientData. */
    struct Namespace *parentPtr; /* Points to the namespace that contains
				  * this one. NULL if this is the global
				  * namespace. */
    Tcl_HashTable childTable;	 /* Contains any child namespaces. Indexed
				  * by strings; values have type
				  * (Namespace *). */
    long nsId;			 /* Unique id for the namespace. */
    Tcl_Interp *interp;		 /* The interpreter containing this
				  * namespace. */
    int flags;			 /* OR-ed combination of the namespace
				  * status flags NS_DYING and NS_DEAD
				  * listed below. */
    int activationCount;	 /* Number of "activations" or active call
				  * frames for this namespace that are on
				  * the Tcl call stack. The namespace won't
				  * be freed until activationCount becomes
				  * zero. */
    int refCount;		 /* Count of references by namespaceName *
				  * objects. The namespace can't be freed
				  * until refCount becomes zero. */
    Tcl_HashTable cmdTable;	 /* Contains all the commands currently
				  * registered in the namespace. Indexed by
				  * strings; values have type (Command *).
				  * Commands imported by Tcl_Import have
				  * Command structures that point (via an
				  * ImportedCmdRef structure) to the
				  * Command structure in the source
				  * namespace's command table. */
    Tcl_HashTable varTable;	 /* Contains all the (global) variables
				  * currently in this namespace. Indexed
				  * by strings; values have type (Var *). */
    char **exportArrayPtr;	 /* Points to an array of string patterns
				  * specifying which commands are exported.
				  * A pattern may include "string match"
				  * style wildcard characters to specify
				  * multiple commands; however, no namespace
				  * qualifiers are allowed. NULL if no
				  * export patterns are registered. */
    int numExportPatterns;	 /* Number of export patterns currently
				  * registered using "namespace export". */
    int maxExportPatterns;	 /* Mumber of export patterns for which
				  * space is currently allocated. */
    int cmdRefEpoch;		 /* Incremented if a newly added command
				  * shadows a command for which this
				  * namespace has already cached a Command *
				  * pointer; this causes all its cached
				  * Command* pointers to be invalidated. */
    int resolverEpoch;		 /* Incremented whenever (a) the name resolution
				  * rules change for this namespace or (b) a 
				  * newly added command shadows a command that
				  * is compiled to bytecodes.
				  * This invalidates all byte codes compiled
				  * in the namespace, causing the code to be
				  * recompiled under the new rules.*/
    Tcl_ResolveCmdProc *cmdResProc;
				 /* If non-null, this procedure overrides
				  * the usual command resolution mechanism
				  * in Tcl.  This procedure is invoked
				  * within Tcl_FindCommand to resolve all
				  * command references within the namespace. */
    Tcl_ResolveVarProc *varResProc;
				 /* If non-null, this procedure overrides
				  * the usual variable resolution mechanism
				  * in Tcl.  This procedure is invoked
				  * within Tcl_FindNamespaceVar to resolve all
				  * variable references within the namespace
				  * at runtime. */
    Tcl_ResolveCompiledVarProc *compiledVarResProc;
				 /* If non-null, this procedure overrides
				  * the usual variable resolution mechanism
				  * in Tcl.  This procedure is invoked
				  * within LookupCompiledLocal to resolve
				  * variable references within the namespace
				  * at compile time. */
} Namespace;

/*
 * Flags used to represent the status of a namespace:
 *
 * NS_DYING -	1 means Tcl_DeleteNamespace has been called to delete the
 *		namespace but there are still active call frames on the Tcl
 *		stack that refer to the namespace. When the last call frame
 *		referring to it has been popped, it's variables and command
 *		will be destroyed and it will be marked "dead" (NS_DEAD).
 *		The namespace can no longer be looked up by name.
 * NS_DEAD -	1 means Tcl_DeleteNamespace has been called to delete the
 *		namespace and no call frames still refer to it. Its
 *		variables and command have already been destroyed. This bit
 *		allows the namespace resolution code to recognize that the
 *		namespace is "deleted". When the last namespaceName object
 *		in any byte code code unit that refers to the namespace has
 *		been freed (i.e., when the namespace's refCount is 0), the
 *		namespace's storage will be freed.
 */

#define NS_DYING	0x01
#define NS_DEAD		0x02

/*
 * Flag passed to TclGetNamespaceForQualName to have it create all namespace
 * components of a namespace-qualified name that cannot be found. The new
 * namespaces are created within their specified parent. Note that this
 * flag's value must not conflict with the values of the flags
 * TCL_GLOBAL_ONLY, TCL_NAMESPACE_ONLY, and FIND_ONLY_NS (defined in
 * tclNamesp.c).
 */

#define CREATE_NS_IF_UNKNOWN 0x800

/*
 *----------------------------------------------------------------
 * Data structures related to variables.   These are used primarily
 * in tclVar.c
 *----------------------------------------------------------------
 */

/*
 * The following structure defines a variable trace, which is used to
 * invoke a specific C procedure whenever certain operations are performed
 * on a variable.
 */

typedef struct VarTrace {
    Tcl_VarTraceProc *traceProc;/* Procedure to call when operations given
				 * by flags are performed on variable. */
    ClientData clientData;	/* Argument to pass to proc. */
    int flags;			/* What events the trace procedure is
				 * interested in:  OR-ed combination of
				 * TCL_TRACE_READS, TCL_TRACE_WRITES,
				 * TCL_TRACE_UNSETS and TCL_TRACE_ARRAY. */
    struct VarTrace *nextPtr;	/* Next in list of traces associated with
				 * a particular variable. */
} VarTrace;

/*
 * The following structure defines a command trace, which is used to
 * invoke a specific C procedure whenever certain operations are performed
 * on a command.
 */

typedef struct CommandTrace {
    Tcl_CommandTraceProc *traceProc;/* Procedure to call when operations given
				     * by flags are performed on command. */
    ClientData clientData;	    /* Argument to pass to proc. */
    int flags;			    /* What events the trace procedure is
				     * interested in:  OR-ed combination of
				     * TCL_TRACE_RENAME, TCL_TRACE_DELETE. */
    struct CommandTrace *nextPtr;   /* Next in list of traces associated with
				     * a particular command. */
} CommandTrace;

/*
 * When a command trace is active (i.e. its associated procedure is
 * executing), one of the following structures is linked into a list
 * associated with the command's interpreter.  The information in
 * the structure is needed in order for Tcl to behave reasonably
 * if traces are deleted while traces are active.
 */

typedef struct ActiveCommandTrace {
    struct Command *cmdPtr;	/* Command that's being traced. */
    struct ActiveCommandTrace *nextPtr;
				/* Next in list of all active command
				 * traces for the interpreter, or NULL
				 * if no more. */
    CommandTrace *nextTracePtr;	/* Next trace to check after current
				 * trace procedure returns;  if this
				 * trace gets deleted, must update pointer
				 * to avoid using free'd memory. */
} ActiveCommandTrace;

/*
 * When a variable trace is active (i.e. its associated procedure is
 * executing), one of the following structures is linked into a list
 * associated with the variable's interpreter.	The information in
 * the structure is needed in order for Tcl to behave reasonably
 * if traces are deleted while traces are active.
 */

typedef struct ActiveVarTrace {
    struct Var *varPtr;		/* Variable that's being traced. */
    struct ActiveVarTrace *nextPtr;
				/* Next in list of all active variable
				 * traces for the interpreter, or NULL
				 * if no more. */
    VarTrace *nextTracePtr;	/* Next trace to check after current
				 * trace procedure returns;  if this
				 * trace gets deleted, must update pointer
				 * to avoid using free'd memory. */
} ActiveVarTrace;

/*
 * The following structure describes an enumerative search in progress on
 * an array variable;  this are invoked with options to the "array"
 * command.
 */

typedef struct ArraySearch {
    int id;			/* Integer id used to distinguish among
				 * multiple concurrent searches for the
				 * same array. */
    struct Var *varPtr;		/* Pointer to array variable that's being
				 * searched. */
    Tcl_HashSearch search;	/* Info kept by the hash module about
				 * progress through the array. */
    Tcl_HashEntry *nextEntry;	/* Non-null means this is the next element
				 * to be enumerated (it's leftover from
				 * the Tcl_FirstHashEntry call or from
				 * an "array anymore" command).	 NULL
				 * means must call Tcl_NextHashEntry
				 * to get value to return. */
    struct ArraySearch *nextPtr;/* Next in list of all active searches
				 * for this variable, or NULL if this is
				 * the last one. */
} ArraySearch;

/*
 * The structure below defines a variable, which associates a string name
 * with a Tcl_Obj value. These structures are kept in procedure call frames
 * (for local variables recognized by the compiler) or in the heap (for
 * global variables and any variable not known to the compiler). For each
 * Var structure in the heap, a hash table entry holds the variable name and
 * a pointer to the Var structure.
 */

typedef struct Var {
    union {
	Tcl_Obj *objPtr;	/* The variable's object value. Used for 
				 * scalar variables and array elements. */
	Tcl_HashTable *tablePtr;/* For array variables, this points to
				 * information about the hash table used
				 * to implement the associative array. 
				 * Points to malloc-ed data. */
	struct Var *linkPtr;	/* If this is a global variable being
				 * referred to in a procedure, or a variable
				 * created by "upvar", this field points to
				 * the referenced variable's Var struct. */
    } value;
    char *name;			/* NULL if the variable is in a hashtable,
				 * otherwise points to the variable's
				 * name. It is used, e.g., by TclLookupVar
				 * and "info locals". The storage for the
				 * characters of the name is not owned by
				 * the Var and must not be freed when
				 * freeing the Var. */
    Namespace *nsPtr;		/* Points to the namespace that contains
				 * this variable or NULL if the variable is
				 * a local variable in a Tcl procedure. */
    Tcl_HashEntry *hPtr;	/* If variable is in a hashtable, either the
				 * hash table entry that refers to this
				 * variable or NULL if the variable has been
				 * detached from its hash table (e.g. an
				 * array is deleted, but some of its
				 * elements are still referred to in
				 * upvars). NULL if the variable is not in a
				 * hashtable. This is used to delete an
				 * variable from its hashtable if it is no
				 * longer needed. */
    int refCount;		/* Counts number of active uses of this
				 * variable, not including its entry in the
				 * call frame or the hash table: 1 for each
				 * additional variable whose linkPtr points
				 * here, 1 for each nested trace active on
				 * variable, and 1 if the variable is a 
				 * namespace variable. This record can't be
				 * deleted until refCount becomes 0. */
    VarTrace *tracePtr;		/* First in list of all traces set for this
				 * variable. */
    ArraySearch *searchPtr;	/* First in list of all searches active
				 * for this variable, or NULL if none. */
    int flags;			/* Miscellaneous bits of information about
				 * variable. See below for definitions. */
} Var;

/*
 * Flag bits for variables. The first three (VAR_SCALAR, VAR_ARRAY, and
 * VAR_LINK) are mutually exclusive and give the "type" of the variable.
 * VAR_UNDEFINED is independent of the variable's type. 
 *
 * VAR_SCALAR -			1 means this is a scalar variable and not
 *				an array or link. The "objPtr" field points
 *				to the variable's value, a Tcl object.
 * VAR_ARRAY -			1 means this is an array variable rather
 *				than a scalar variable or link. The
 *				"tablePtr" field points to the array's
 *				hashtable for its elements.
 * VAR_LINK -			1 means this Var structure contains a
 *				pointer to another Var structure that
 *				either has the real value or is itself
 *				another VAR_LINK pointer. Variables like
 *				this come about through "upvar" and "global"
 *				commands, or through references to variables
 *				in enclosing namespaces.
 * VAR_UNDEFINED -		1 means that the variable is in the process
 *				of being deleted. An undefined variable
 *				logically does not exist and survives only
 *				while it has a trace, or if it is a global
 *				variable currently being used by some
 *				procedure.
 * VAR_IN_HASHTABLE -		1 means this variable is in a hashtable and
 *				the Var structure is malloced. 0 if it is
 *				a local variable that was assigned a slot
 *				in a procedure frame by	the compiler so the
 *				Var storage is part of the call frame.
 * VAR_TRACE_ACTIVE -		1 means that trace processing is currently
 *				underway for a read or write access, so
 *				new read or write accesses should not cause
 *				trace procedures to be called and the
 *				variable can't be deleted.
 * VAR_ARRAY_ELEMENT -		1 means that this variable is an array
 *				element, so it is not legal for it to be
 *				an array itself (the VAR_ARRAY flag had
 *				better not be set).
 * VAR_NAMESPACE_VAR -		1 means that this variable was declared
 *				as a namespace variable. This flag ensures
 *				it persists until its namespace is
 *				destroyed or until the variable is unset;
 *				it will persist even if it has not been
 *				initialized and is marked undefined.
 *				The variable's refCount is incremented to
 *				reflect the "reference" from its namespace.
 *
 * The following additional flags are used with the CompiledLocal type
 * defined below:
 *
 * VAR_ARGUMENT -		1 means that this variable holds a procedure
 *				argument. 
 * VAR_TEMPORARY -		1 if the local variable is an anonymous
 *				temporary variable. Temporaries have a NULL
 *				name.
 * VAR_RESOLVED -		1 if name resolution has been done for this
 *				variable.
 */

#define VAR_SCALAR		0x1
#define VAR_ARRAY		0x2
#define VAR_LINK		0x4
#define VAR_UNDEFINED		0x8
#define VAR_IN_HASHTABLE	0x10
#define VAR_TRACE_ACTIVE	0x20
#define VAR_ARRAY_ELEMENT	0x40
#define VAR_NAMESPACE_VAR	0x80

#define VAR_ARGUMENT		0x100
#define VAR_TEMPORARY		0x200
#define VAR_RESOLVED		0x400	

/*
 * Macros to ensure that various flag bits are set properly for variables.
 * The ANSI C "prototypes" for these macros are:
 *
 * EXTERN void	TclSetVarScalar _ANSI_ARGS_((Var *varPtr));
 * EXTERN void	TclSetVarArray _ANSI_ARGS_((Var *varPtr));
 * EXTERN void	TclSetVarLink _ANSI_ARGS_((Var *varPtr));
 * EXTERN void	TclSetVarArrayElement _ANSI_ARGS_((Var *varPtr));
 * EXTERN void	TclSetVarUndefined _ANSI_ARGS_((Var *varPtr));
 * EXTERN void	TclClearVarUndefined _ANSI_ARGS_((Var *varPtr));
 */

#define TclSetVarScalar(varPtr) \
    (varPtr)->flags = ((varPtr)->flags & ~(VAR_ARRAY|VAR_LINK)) | VAR_SCALAR

#define TclSetVarArray(varPtr) \
    (varPtr)->flags = ((varPtr)->flags & ~(VAR_SCALAR|VAR_LINK)) | VAR_ARRAY

#define TclSetVarLink(varPtr) \
    (varPtr)->flags = ((varPtr)->flags & ~(VAR_SCALAR|VAR_ARRAY)) | VAR_LINK

#define TclSetVarArrayElement(varPtr) \
    (varPtr)->flags = ((varPtr)->flags & ~VAR_ARRAY) | VAR_ARRAY_ELEMENT

#define TclSetVarUndefined(varPtr) \
    (varPtr)->flags |= VAR_UNDEFINED

#define TclClearVarUndefined(varPtr) \
    (varPtr)->flags &= ~VAR_UNDEFINED

/*
 * Macros to read various flag bits of variables.
 * The ANSI C "prototypes" for these macros are:
 *
 * EXTERN int	TclIsVarScalar _ANSI_ARGS_((Var *varPtr));
 * EXTERN int	TclIsVarLink _ANSI_ARGS_((Var *varPtr));
 * EXTERN int	TclIsVarArray _ANSI_ARGS_((Var *varPtr));
 * EXTERN int	TclIsVarUndefined _ANSI_ARGS_((Var *varPtr));
 * EXTERN int	TclIsVarArrayElement _ANSI_ARGS_((Var *varPtr));
 * EXTERN int	TclIsVarTemporary _ANSI_ARGS_((Var *varPtr));
 * EXTERN int	TclIsVarArgument _ANSI_ARGS_((Var *varPtr));
 * EXTERN int	TclIsVarResolved _ANSI_ARGS_((Var *varPtr));
 */
    
#define TclIsVarScalar(varPtr) \
    ((varPtr)->flags & VAR_SCALAR)

#define TclIsVarLink(varPtr) \
    ((varPtr)->flags & VAR_LINK)

#define TclIsVarArray(varPtr) \
    ((varPtr)->flags & VAR_ARRAY)

#define TclIsVarUndefined(varPtr) \
    ((varPtr)->flags & VAR_UNDEFINED)

#define TclIsVarArrayElement(varPtr) \
    ((varPtr)->flags & VAR_ARRAY_ELEMENT)

#define TclIsVarTemporary(varPtr) \
    ((varPtr)->flags & VAR_TEMPORARY)
    
#define TclIsVarArgument(varPtr) \
    ((varPtr)->flags & VAR_ARGUMENT)
    
#define TclIsVarResolved(varPtr) \
    ((varPtr)->flags & VAR_RESOLVED)

/*
 *----------------------------------------------------------------
 * Data structures related to procedures.  These are used primarily
 * in tclProc.c, tclCompile.c, and tclExecute.c.
 *----------------------------------------------------------------
 */

/*
 * Forward declaration to prevent an error when the forward reference to
 * Command is encountered in the Proc and ImportRef types declared below.
 */

struct Command;

/*
 * The variable-length structure below describes a local variable of a
 * procedure that was recognized by the compiler. These variables have a
 * name, an element in the array of compiler-assigned local variables in the
 * procedure's call frame, and various other items of information. If the
 * local variable is a formal argument, it may also have a default value.
 * The compiler can't recognize local variables whose names are
 * expressions (these names are only known at runtime when the expressions
 * are evaluated) or local variables that are created as a result of an
 * "upvar" or "uplevel" command. These other local variables are kept
 * separately in a hash table in the call frame.
 */

typedef struct CompiledLocal {
    struct CompiledLocal *nextPtr;
				/* Next compiler-recognized local variable
				 * for this procedure, or NULL if this is
				 * the last local. */
    int nameLength;		/* The number of characters in local
				 * variable's name. Used to speed up
				 * variable lookups. */
    int frameIndex;		/* Index in the array of compiler-assigned
				 * variables in the procedure call frame. */
    int flags;			/* Flag bits for the local variable. Same as
				 * the flags for the Var structure above,
				 * although only VAR_SCALAR, VAR_ARRAY, 
				 * VAR_LINK, VAR_ARGUMENT, VAR_TEMPORARY, and
				 * VAR_RESOLVED make sense. */
    Tcl_Obj *defValuePtr;	/* Pointer to the default value of an
				 * argument, if any. NULL if not an argument
				 * or, if an argument, no default value. */
    Tcl_ResolvedVarInfo *resolveInfo;
				/* Customized variable resolution info
				 * supplied by the Tcl_ResolveCompiledVarProc
				 * associated with a namespace. Each variable
				 * is marked by a unique ClientData tag
				 * during compilation, and that same tag
				 * is used to find the variable at runtime. */
    char name[4];		/* Name of the local variable starts here.
				 * If the name is NULL, this will just be
				 * '\0'. The actual size of this field will
				 * be large enough to hold the name. MUST
				 * BE THE LAST FIELD IN THE STRUCTURE! */
} CompiledLocal;

/*
 * The structure below defines a command procedure, which consists of a
 * collection of Tcl commands plus information about arguments and other
 * local variables recognized at compile time.
 */

typedef struct Proc {
    struct Interp *iPtr;	  /* Interpreter for which this command
				   * is defined. */
    int refCount;		  /* Reference count: 1 if still present
				   * in command table plus 1 for each call
				   * to the procedure that is currently
				   * active. This structure can be freed
				   * when refCount becomes zero. */
    struct Command *cmdPtr;	  /* Points to the Command structure for
				   * this procedure. This is used to get
				   * the namespace in which to execute
				   * the procedure. */
    Tcl_Obj *bodyPtr;		  /* Points to the ByteCode object for
				   * procedure's body command. */
    int numArgs;		  /* Number of formal parameters. */
    int numCompiledLocals;	  /* Count of local variables recognized by
				   * the compiler including arguments and
				   * temporaries. */
    CompiledLocal *firstLocalPtr; /* Pointer to first of the procedure's
				   * compiler-allocated local variables, or
				   * NULL if none. The first numArgs entries
				   * in this list describe the procedure's
				   * formal arguments. */
    CompiledLocal *lastLocalPtr;  /* Pointer to the last allocated local
				   * variable or NULL if none. This has
				   * frame index (numCompiledLocals-1). */
} Proc;

/*
 * The structure below defines a command trace.	 This is used to allow Tcl
 * clients to find out whenever a command is about to be executed.
 */

typedef struct Trace {
    int level;			/* Only trace commands at nesting level
				 * less than or equal to this. */
    Tcl_CmdObjTraceProc *proc;	/* Procedure to call to trace command. */
    ClientData clientData;	/* Arbitrary value to pass to proc. */
    struct Trace *nextPtr;	/* Next in list of traces for this interp. */
    int flags;			/* Flags governing the trace - see
				 * Tcl_CreateObjTrace for details */
    Tcl_CmdObjTraceDeleteProc* delProc;
				/* Procedure to call when trace is deleted */
} Trace;

/*
 * When an interpreter trace is active (i.e. its associated procedure
 * is executing), one of the following structures is linked into a list
 * associated with the interpreter.  The information in the structure
 * is needed in order for Tcl to behave reasonably if traces are
 * deleted while traces are active.
 */

typedef struct ActiveInterpTrace {
    struct ActiveInterpTrace *nextPtr;
				/* Next in list of all active command
				 * traces for the interpreter, or NULL
				 * if no more. */
    Trace *nextTracePtr;	/* Next trace to check after current
				 * trace procedure returns;  if this
				 * trace gets deleted, must update pointer
				 * to avoid using free'd memory. */
} ActiveInterpTrace;

/*
 * The structure below defines an entry in the assocData hash table which
 * is associated with an interpreter. The entry contains a pointer to a
 * function to call when the interpreter is deleted, and a pointer to
 * a user-defined piece of data.
 */

typedef struct AssocData {
    Tcl_InterpDeleteProc *proc;	/* Proc to call when deleting. */
    ClientData clientData;	/* Value to pass to proc. */
} AssocData;	

/*
 * The structure below defines a call frame. A call frame defines a naming
 * context for a procedure call: its local naming scope (for local
 * variables) and its global naming scope (a namespace, perhaps the global
 * :: namespace). A call frame can also define the naming context for a
 * namespace eval or namespace inscope command: the namespace in which the
 * command's code should execute. The Tcl_CallFrame structures exist only
 * while procedures or namespace eval/inscope's are being executed, and
 * provide a kind of Tcl call stack.
 * 
 * WARNING!! The structure definition must be kept consistent with the
 * Tcl_CallFrame structure in tcl.h. If you change one, change the other.
 */

typedef struct CallFrame {
    Namespace *nsPtr;		/* Points to the namespace used to resolve
				 * commands and global variables. */
    int isProcCallFrame;	/* If nonzero, the frame was pushed to
				 * execute a Tcl procedure and may have
				 * local vars. If 0, the frame was pushed
				 * to execute a namespace command and var
				 * references are treated as references to
				 * namespace vars; varTablePtr and
				 * compiledLocals are ignored. */
    int objc;			/* This and objv below describe the
				 * arguments for this procedure call. */
    Tcl_Obj *CONST *objv;	/* Array of argument objects. */
    struct CallFrame *callerPtr;
				/* Value of interp->framePtr when this
				 * procedure was invoked (i.e. next higher
				 * in stack of all active procedures). */
    struct CallFrame *callerVarPtr;
				/* Value of interp->varFramePtr when this
				 * procedure was invoked (i.e. determines
				 * variable scoping within caller). Same
				 * as callerPtr unless an "uplevel" command
				 * or something equivalent was active in
				 * the caller). */
    int level;			/* Level of this procedure, for "uplevel"
				 * purposes (i.e. corresponds to nesting of
				 * callerVarPtr's, not callerPtr's). 1 for
				 * outermost procedure, 0 for top-level. */
    Proc *procPtr;		/* Points to the structure defining the
				 * called procedure. Used to get information
				 * such as the number of compiled local
				 * variables (local variables assigned
				 * entries ["slots"] in the compiledLocals
				 * array below). */
    Tcl_HashTable *varTablePtr;	/* Hash table containing local variables not
				 * recognized by the compiler, or created at
				 * execution time through, e.g., upvar.
				 * Initially NULL and created if needed. */
    int numCompiledLocals;	/* Count of local variables recognized by
				 * the compiler including arguments. */
    Var* compiledLocals;	/* Points to the array of local variables
				 * recognized by the compiler. The compiler
				 * emits code that refers to these variables
				 * using an index into this array. */
} CallFrame;

/*
 *----------------------------------------------------------------
 * Data structures and procedures related to TclHandles, which
 * are a very lightweight method of preserving enough information
 * to determine if an arbitrary malloc'd block has been deleted.
 *----------------------------------------------------------------
 */

typedef VOID **TclHandle;

/*
 *----------------------------------------------------------------
 * Data structures related to history.	 These are used primarily
 * in tclHistory.c
 *----------------------------------------------------------------
 */

/*
 * The structure below defines one history event (a previously-executed
 * command that can be re-executed in whole or in part).
 */

typedef struct {
    char *command;		/* String containing previously-executed
				 * command. */
    int bytesAvl;		/* Total # of bytes available at *event (not
				 * all are necessarily in use now). */
} HistoryEvent;

/*
 * The structure below defines a pending revision to the most recent
 * history event.  Changes are linked together into a list and applied
 * during the next call to Tcl_RecordHistory.  See the comments at the
 * beginning of tclHistory.c for information on revisions.
 */

typedef struct HistoryRev {
    int firstIndex;		/* Index of the first byte to replace in
				 * current history event. */
    int lastIndex;		/* Index of last byte to replace in
				 * current history event. */
    int newSize;		/* Number of bytes in newBytes. */
    char *newBytes;		/* Replacement for the range given by
				 * firstIndex and lastIndex (malloced). */
    struct HistoryRev *nextPtr;	/* Next in chain of revisions to apply, or
				 * NULL for end of list. */
} HistoryRev;

/*
 *----------------------------------------------------------------
 * Data structures related to expressions.  These are used only in
 * tclExpr.c.
 *----------------------------------------------------------------
 */

/*
 * The data structure below defines a math function (e.g. sin or hypot)
 * for use in Tcl expressions.
 */

#define MAX_MATH_ARGS 5
typedef struct MathFunc {
    int builtinFuncIndex;	/* If this is a builtin math function, its
				 * index in the array of builtin functions.
				 * (tclCompilation.h lists these indices.)
				 * The value is -1 if this is a new function
				 * defined by Tcl_CreateMathFunc. The value
				 * is also -1 if a builtin function is
				 * replaced by a Tcl_CreateMathFunc call. */
    int numArgs;		/* Number of arguments for function. */
    Tcl_ValueType argTypes[MAX_MATH_ARGS];
				/* Acceptable types for each argument. */
    Tcl_MathProc *proc;		/* Procedure that implements this function.
				 * NULL if isBuiltinFunc is 1. */
    ClientData clientData;	/* Additional argument to pass to the
				 * function when invoking it. NULL if
				 * isBuiltinFunc is 1. */
} MathFunc;

/*
 * These are a thin layer over TclpThreadKeyDataGet and TclpThreadKeyDataSet
 * when threads are used, or an emulation if there are no threads.  These
 * are really internal and Tcl clients should use Tcl_GetThreadData.
 */

EXTERN VOID *TclThreadDataKeyGet _ANSI_ARGS_((Tcl_ThreadDataKey *keyPtr));
EXTERN void TclThreadDataKeySet _ANSI_ARGS_((Tcl_ThreadDataKey *keyPtr, VOID *data));

/*
 * This is a convenience macro used to initialize a thread local storage ptr.
 */
#define TCL_TSD_INIT(keyPtr)	(ThreadSpecificData *)Tcl_GetThreadData((keyPtr), sizeof(ThreadSpecificData))


/*
 *----------------------------------------------------------------
 * Data structures related to bytecode compilation and execution.
 * These are used primarily in tclCompile.c, tclExecute.c, and
 * tclBasic.c.
 *----------------------------------------------------------------
 */

/*
 * Forward declaration to prevent errors when the forward references to
 * Tcl_Parse and CompileEnv are encountered in the procedure type
 * CompileProc declared below.
 */

struct CompileEnv;

/*
 * The type of procedures called by the Tcl bytecode compiler to compile
 * commands. Pointers to these procedures are kept in the Command structure
 * describing each command. When a CompileProc returns, the interpreter's
 * result is set to error information, if any. In addition, the CompileProc
 * returns an integer value, which is one of the following:
 *
 * TCL_OK		Compilation completed normally.
 * TCL_ERROR		Compilation failed because of an error;
 *			the interpreter's result describes what went wrong.
 * TCL_OUT_LINE_COMPILE	Compilation failed because, e.g., the command is
 *			too complex for effective inline compilation. The
 *			CompileProc believes the command is legal but 
 *			should be compiled "out of line" by emitting code
 *			to invoke its command procedure at runtime.
 */

#define TCL_OUT_LINE_COMPILE	(TCL_CONTINUE + 1)

typedef int (CompileProc) _ANSI_ARGS_((Tcl_Interp *interp,
	Tcl_Parse *parsePtr, struct CompileEnv *compEnvPtr));

/*
 * The type of procedure called from the compilation hook point in
 * SetByteCodeFromAny.
 */

typedef int (CompileHookProc) _ANSI_ARGS_((Tcl_Interp *interp,
	struct CompileEnv *compEnvPtr, ClientData clientData));

/*
 * The data structure defining the execution environment for ByteCode's.
 * There is one ExecEnv structure per Tcl interpreter. It holds the
 * evaluation stack that holds command operands and results. The stack grows
 * towards increasing addresses. The "stackTop" member is cached by
 * TclExecuteByteCode in a local variable: it must be set before calling
 * TclExecuteByteCode and will be restored by TclExecuteByteCode before it
 * returns.
 */

typedef struct ExecEnv {
    Tcl_Obj **stackPtr;		/* Points to the first item in the
				 * evaluation stack on the heap. */
    int stackTop;		/* Index of current top of stack; -1 when
				 * the stack is empty. */
    int stackEnd;		/* Index of last usable item in stack. */
    Tcl_Obj *errorInfo;
    Tcl_Obj *errorCode;
} ExecEnv;

/*
 * The definitions for the LiteralTable and LiteralEntry structures. Each
 * interpreter contains a LiteralTable. It is used to reduce the storage
 * needed for all the Tcl objects that hold the literals of scripts compiled
 * by the interpreter. A literal's object is shared by all the ByteCodes
 * that refer to the literal. Each distinct literal has one LiteralEntry
 * entry in the LiteralTable. A literal table is a specialized hash table
 * that is indexed by the literal's string representation, which may contain
 * null characters.
 *
 * Note that we reduce the space needed for literals by sharing literal
 * objects both within a ByteCode (each ByteCode contains a local
 * LiteralTable) and across all an interpreter's ByteCodes (with the
 * interpreter's global LiteralTable).
 */

typedef struct LiteralEntry {
    struct LiteralEntry *nextPtr;	/* Points to next entry in this
					 * hash bucket or NULL if end of
					 * chain. */
    Tcl_Obj *objPtr;			/* Points to Tcl object that
					 * holds the literal's bytes and
					 * length. */
    int refCount;			/* If in an interpreter's global
					 * literal table, the number of
					 * ByteCode structures that share
					 * the literal object; the literal
					 * entry can be freed when refCount
					 * drops to 0. If in a local literal
					 * table, -1. */
} LiteralEntry;

typedef struct LiteralTable {
    LiteralEntry **buckets;		/* Pointer to bucket array. Each
					 * element points to first entry in
					 * bucket's hash chain, or NULL. */
    LiteralEntry *staticBuckets[TCL_SMALL_HASH_TABLE];
					/* Bucket array used for small
					 * tables to avoid mallocs and
					 * frees. */
    int numBuckets;			/* Total number of buckets allocated
					 * at **buckets. */
    int numEntries;			/* Total number of entries present
					 * in table. */
    int rebuildSize;			/* Enlarge table when numEntries
					 * gets to be this large. */
    int mask;				/* Mask value used in hashing
					 * function. */
} LiteralTable;

/*
 * The following structure defines for each Tcl interpreter various
 * statistics-related information about the bytecode compiler and
 * interpreter's operation in that interpreter.
 */

#ifdef TCL_COMPILE_STATS
typedef struct ByteCodeStats {
    long numExecutions;		  /* Number of ByteCodes executed. */
    long numCompilations;	  /* Number of ByteCodes created. */
    long numByteCodesFreed;	  /* Number of ByteCodes destroyed. */
    long instructionCount[256];	  /* Number of times each instruction was
				   * executed. */

    double totalSrcBytes;	  /* Total source bytes ever compiled. */
    double totalByteCodeBytes;	  /* Total bytes for all ByteCodes. */
    double currentSrcBytes;	  /* Src bytes for all current ByteCodes. */
    double currentByteCodeBytes;  /* Code bytes in all current ByteCodes. */

    long srcCount[32];		  /* Source size distribution: # of srcs of
				   * size [2**(n-1)..2**n), n in [0..32). */
    long byteCodeCount[32];	  /* ByteCode size distribution. */
    long lifetimeCount[32];	  /* ByteCode lifetime distribution (ms). */
    
    double currentInstBytes;	  /* Instruction bytes-current ByteCodes. */
    double currentLitBytes;	  /* Current literal bytes. */
    double currentExceptBytes;	  /* Current exception table bytes. */
    double currentAuxBytes;	  /* Current auxiliary information bytes. */
    double currentCmdMapBytes;	  /* Current src<->code map bytes. */
    
    long numLiteralsCreated;	  /* Total literal objects ever compiled. */
    double totalLitStringBytes;	  /* Total string bytes in all literals. */
    double currentLitStringBytes; /* String bytes in current literals. */
    long literalCount[32];	  /* Distribution of literal string sizes. */
} ByteCodeStats;
#endif /* TCL_COMPILE_STATS */

/*
 *----------------------------------------------------------------
 * Data structures related to commands.
 *----------------------------------------------------------------
 */

/*
 * An imported command is created in an namespace when it imports a "real"
 * command from another namespace. An imported command has a Command
 * structure that points (via its ClientData value) to the "real" Command
 * structure in the source namespace's command table. The real command
 * records all the imported commands that refer to it in a list of ImportRef
 * structures so that they can be deleted when the real command is deleted.  */

typedef struct ImportRef {
    struct Command *importedCmdPtr;
				/* Points to the imported command created in
				 * an importing namespace; this command
				 * redirects its invocations to the "real"
				 * command. */
    struct ImportRef *nextPtr;	/* Next element on the linked list of
				 * imported commands that refer to the
				 * "real" command. The real command deletes
				 * these imported commands on this list when
				 * it is deleted. */
} ImportRef;

/*
 * Data structure used as the ClientData of imported commands: commands
 * created in an namespace when it imports a "real" command from another
 * namespace.
 */

typedef struct ImportedCmdData {
    struct Command *realCmdPtr;	/* "Real" command that this imported command
				 * refers to. */
    struct Command *selfPtr;	/* Pointer to this imported command. Needed
				 * only when deleting it in order to remove
				 * it from the real command's linked list of
				 * imported commands that refer to it. */
} ImportedCmdData;

/*
 * A Command structure exists for each command in a namespace. The
 * Tcl_Command opaque type actually refers to these structures.
 */

typedef struct Command {
    Tcl_HashEntry *hPtr;	/* Pointer to the hash table entry that
				 * refers to this command. The hash table is
				 * either a namespace's command table or an
				 * interpreter's hidden command table. This
				 * pointer is used to get a command's name
				 * from its Tcl_Command handle. NULL means
				 * that the hash table entry has been
				 * removed already (this can happen if
				 * deleteProc causes the command to be
				 * deleted or recreated). */
    Namespace *nsPtr;		/* Points to the namespace containing this
				 * command. */
    int refCount;		/* 1 if in command hashtable plus 1 for each
				 * reference from a CmdName Tcl object
				 * representing a command's name in a
				 * ByteCode instruction sequence. This
				 * structure can be freed when refCount
				 * becomes zero. */
    int cmdEpoch;		/* Incremented to invalidate any references
				 * that point to this command when it is
				 * renamed, deleted, hidden, or exposed. */
    CompileProc *compileProc;	/* Procedure called to compile command. NULL
				 * if no compile proc exists for command. */
    Tcl_ObjCmdProc *objProc;	/* Object-based command procedure. */
    ClientData objClientData;	/* Arbitrary value passed to object proc. */
    Tcl_CmdProc *proc;		/* String-based command procedure. */
    ClientData clientData;	/* Arbitrary value passed to string proc. */
    Tcl_CmdDeleteProc *deleteProc;
				/* Procedure invoked when deleting command
				 * to, e.g., free all client data. */
    ClientData deleteData;	/* Arbitrary value passed to deleteProc. */
    int flags;			/* Miscellaneous bits of information about
				 * command. See below for definitions. */
    ImportRef *importRefPtr;	/* List of each imported Command created in
				 * another namespace when this command is
				 * imported. These imported commands
				 * redirect invocations back to this
				 * command. The list is used to remove all
				 * those imported commands when deleting
				 * this "real" command. */
    CommandTrace *tracePtr;	/* First in list of all traces set for this
				 * command. */
} Command;

/*
 * Flag bits for commands. 
 *
 * CMD_IS_DELETED -		Means that the command is in the process
 *                              of being deleted (its deleteProc is
 *                              currently executing). Other attempts to
 *                              delete the command should be ignored.
 * CMD_TRACE_ACTIVE -		1 means that trace processing is currently
 *				underway for a rename/delete change.
 *				See the two flags below for which is
 *				currently being processed.
 * CMD_HAS_EXEC_TRACES -	1 means that this command has at least
 *                              one execution trace (as opposed to simple
 *                              delete/rename traces) in its tracePtr list.
 * TCL_TRACE_RENAME -           A rename trace is in progress. Further
 *                              recursive renames will not be traced.
 * TCL_TRACE_DELETE -           A delete trace is in progress. Further 
 *                              recursive deletes will not be traced.
 * (these last two flags are defined in tcl.h)
 */
#define CMD_IS_DELETED		0x1
#define CMD_TRACE_ACTIVE	0x2
#define CMD_HAS_EXEC_TRACES	0x4

/*
 *----------------------------------------------------------------
 * Data structures related to name resolution procedures.
 *----------------------------------------------------------------
 */

/*
 * The interpreter keeps a linked list of name resolution schemes.
 * The scheme for a namespace is consulted first, followed by the
 * list of schemes in an interpreter, followed by the default
 * name resolution in Tcl.  Schemes are added/removed from the
 * interpreter's list by calling Tcl_AddInterpResolver and
 * Tcl_RemoveInterpResolver.
 */

typedef struct ResolverScheme {
    char *name;			/* Name identifying this scheme. */
    Tcl_ResolveCmdProc *cmdResProc;
				/* Procedure handling command name
				 * resolution. */
    Tcl_ResolveVarProc *varResProc;
				/* Procedure handling variable name
				 * resolution for variables that
				 * can only be handled at runtime. */
    Tcl_ResolveCompiledVarProc *compiledVarResProc;
				/* Procedure handling variable name
				 * resolution at compile time. */

    struct ResolverScheme *nextPtr;
				/* Pointer to next record in linked list. */
} ResolverScheme;

/*
 *----------------------------------------------------------------
 * This structure defines an interpreter, which is a collection of
 * commands plus other state information related to interpreting
 * commands, such as variable storage. Primary responsibility for
 * this data structure is in tclBasic.c, but almost every Tcl
 * source file uses something in here.
 *----------------------------------------------------------------
 */

typedef struct Interp {

    /*
     * Note:  the first three fields must match exactly the fields in
     * a Tcl_Interp struct (see tcl.h).	 If you change one, be sure to
     * change the other.
     *
     * The interpreter's result is held in both the string and the
     * objResultPtr fields. These fields hold, respectively, the result's
     * string or object value. The interpreter's result is always in the
     * result field if that is non-empty, otherwise it is in objResultPtr.
     * The two fields are kept consistent unless some C code sets
     * interp->result directly. Programs should not access result and
     * objResultPtr directly; instead, they should always get and set the
     * result using procedures such as Tcl_SetObjResult, Tcl_GetObjResult,
     * and Tcl_GetStringResult. See the SetResult man page for details.
     */

    char *result;		/* If the last command returned a string
				 * result, this points to it. Should not be
				 * accessed directly; see comment above. */
    Tcl_FreeProc *freeProc;	/* Zero means a string result is statically
				 * allocated. TCL_DYNAMIC means string
				 * result was allocated with ckalloc and
				 * should be freed with ckfree. Other values
				 * give address of procedure to invoke to
				 * free the string result. Tcl_Eval must
				 * free it before executing next command. */
    int errorLine;		/* When TCL_ERROR is returned, this gives
				 * the line number in the command where the
				 * error occurred (1 means first line). */
    struct TclStubs *stubTable;
				/* Pointer to the exported Tcl stub table.
				 * On previous versions of Tcl this is a
				 * pointer to the objResultPtr or a pointer
				 * to a buckets array in a hash table. We
				 * therefore have to do some careful checking
				 * before we can use this. */

    TclHandle handle;		/* Handle used to keep track of when this
				 * interp is deleted. */

    Namespace *globalNsPtr;	/* The interpreter's global namespace. */
    Tcl_HashTable *hiddenCmdTablePtr;
				/* Hash table used by tclBasic.c to keep
				 * track of hidden commands on a per-interp
				 * basis. */
    ClientData interpInfo;	/* Information used by tclInterp.c to keep
				 * track of master/slave interps on
				 * a per-interp basis. */
    Tcl_HashTable mathFuncTable;/* Contains all the math functions currently
				 * defined for the interpreter.	 Indexed by
				 * strings (function names); values have
				 * type (MathFunc *). */



    /*
     * Information related to procedures and variables. See tclProc.c
     * and tclVar.c for usage.
     */

    int numLevels;		/* Keeps track of how many nested calls to
				 * Tcl_Eval are in progress for this
				 * interpreter.	 It's used to delay deletion
				 * of the table until all Tcl_Eval
				 * invocations are completed. */
    int maxNestingDepth;	/* If numLevels exceeds this value then Tcl
				 * assumes that infinite recursion has
				 * occurred and it generates an error. */
    CallFrame *framePtr;	/* Points to top-most in stack of all nested
				 * procedure invocations.  NULL means there
				 * are no active procedures. */
    CallFrame *varFramePtr;	/* Points to the call frame whose variables
				 * are currently in use (same as framePtr
				 * unless an "uplevel" command is
				 * executing). NULL means no procedure is
				 * active or "uplevel 0" is executing. */
    ActiveVarTrace *activeVarTracePtr;
				/* First in list of active traces for
				 * interp, or NULL if no active traces. */
    int returnCode;		/* Completion code to return if current
				 * procedure exits with TCL_RETURN code. */
    char *errorInfo;		/* Value to store in errorInfo if returnCode
				 * is TCL_ERROR.  Malloc'ed, may be NULL */
    char *errorCode;		/* Value to store in errorCode if returnCode
				 * is TCL_ERROR.  Malloc'ed, may be NULL */

    /*
     * Information used by Tcl_AppendResult to keep track of partial
     * results.	 See Tcl_AppendResult code for details.
     */

    char *appendResult;		/* Storage space for results generated
				 * by Tcl_AppendResult.	 Malloc-ed.  NULL
				 * means not yet allocated. */
    int appendAvl;		/* Total amount of space available at
				 * partialResult. */
    int appendUsed;		/* Number of non-null bytes currently
				 * stored at partialResult. */

    /*
     * Information about packages.  Used only in tclPkg.c.
     */

    Tcl_HashTable packageTable;	/* Describes all of the packages loaded
				 * in or available to this interpreter.
				 * Keys are package names, values are
				 * (Package *) pointers. */
    char *packageUnknown;	/* Command to invoke during "package
				 * require" commands for packages that
				 * aren't described in packageTable. 
				 * Malloc'ed, may be NULL. */

    /*
     * Miscellaneous information:
     */

    int cmdCount;		/* Total number of times a command procedure
				 * has been called for this interpreter. */
    int evalFlags;		/* Flags to control next call to Tcl_Eval.
				 * Normally zero, but may be set before
				 * calling Tcl_Eval.  See below for valid
				 * values. */
    int termOffset;		/* Offset of character just after last one
				 * compiled or executed by Tcl_EvalObj. */
    LiteralTable literalTable;	/* Contains LiteralEntry's describing all
				 * Tcl objects holding literals of scripts
				 * compiled by the interpreter. Indexed by
				 * the string representations of literals.
				 * Used to avoid creating duplicate
				 * objects. */
    int compileEpoch;		/* Holds the current "compilation epoch"
				 * for this interpreter. This is
				 * incremented to invalidate existing
				 * ByteCodes when, e.g., a command with a
				 * compile procedure is redefined. */
    Proc *compiledProcPtr;	/* If a procedure is being compiled, a
				 * pointer to its Proc structure; otherwise,
				 * this is NULL. Set by ObjInterpProc in
				 * tclProc.c and used by tclCompile.c to
				 * process local variables appropriately. */
    ResolverScheme *resolverPtr;
				/* Linked list of name resolution schemes
				 * added to this interpreter.  Schemes
				 * are added/removed by calling
				 * Tcl_AddInterpResolvers and
				 * Tcl_RemoveInterpResolver. */
    Tcl_Obj *scriptFile;	/* NULL means there is no nested source
				 * command active;  otherwise this points to
				 * pathPtr of the file being sourced. */
    int flags;			/* Various flag bits.  See below. */
    long randSeed;		/* Seed used for rand() function. */
    Trace *tracePtr;		/* List of traces for this interpreter. */
    Tcl_HashTable *assocData;	/* Hash table for associating data with
				 * this interpreter. Cleaned up when
				 * this interpreter is deleted. */
    struct ExecEnv *execEnvPtr;	/* Execution environment for Tcl bytecode
				 * execution. Contains a pointer to the
				 * Tcl evaluation stack. */
    Tcl_Obj *emptyObjPtr;	/* Points to an object holding an empty
				 * string. Returned by Tcl_ObjSetVar2 when
				 * variable traces change a variable in a
				 * gross way. */
    char resultSpace[TCL_RESULT_SIZE+1];
				/* Static space holding small results. */
    Tcl_Obj *objResultPtr;	/* If the last command returned an object
				 * result, this points to it. Should not be
				 * accessed directly; see comment above. */
    Tcl_ThreadId threadId;	/* ID of thread that owns the interpreter */

    ActiveCommandTrace *activeCmdTracePtr;
				/* First in list of active command traces for
				 * interp, or NULL if no active traces. */
    ActiveInterpTrace *activeInterpTracePtr;
				/* First in list of active traces for
				 * interp, or NULL if no active traces. */

    int tracesForbiddingInline; /* Count of traces (in the list headed by
				 * tracePtr) that forbid inline bytecode
				 * compilation */
    /*
     * Statistical information about the bytecode compiler and interpreter's
     * operation.
     */

#ifdef TCL_COMPILE_STATS
    ByteCodeStats stats;	/* Holds compilation and execution
				 * statistics for this interpreter. */
#endif /* TCL_COMPILE_STATS */	  
} Interp;

/*
 * EvalFlag bits for Interp structures:
 *
 * TCL_BRACKET_TERM	1 means that the current script is terminated by
 *			a close bracket rather than the end of the string.
 * TCL_ALLOW_EXCEPTIONS	1 means it's OK for the script to terminate with
 *			a code other than TCL_OK or TCL_ERROR;	0 means
 *			codes other than these should be turned into errors.
 */

#define TCL_BRACKET_TERM	  1
#define TCL_ALLOW_EXCEPTIONS	  4

/*
 * Flag bits for Interp structures:
 *
 * DELETED:		Non-zero means the interpreter has been deleted:
 *			don't process any more commands for it, and destroy
 *			the structure as soon as all nested invocations of
 *			Tcl_Eval are done.
 * ERR_IN_PROGRESS:	Non-zero means an error unwind is already in
 *			progress. Zero means a command proc has been
 *			invoked since last error occured.
 * ERR_ALREADY_LOGGED:	Non-zero means information has already been logged
 *			in $errorInfo for the current Tcl_Eval instance,
 *			so Tcl_Eval needn't log it (used to implement the
 *			"error message log" command).
 * ERROR_CODE_SET:	Non-zero means that Tcl_SetErrorCode has been
 *			called to record information for the current
 *			error.	Zero means Tcl_Eval must clear the
 *			errorCode variable if an error is returned.
 * EXPR_INITIALIZED:	Non-zero means initialization specific to
 *			expressions has	been carried out.
 * DONT_COMPILE_CMDS_INLINE: Non-zero means that the bytecode compiler
 *			should not compile any commands into an inline
 *			sequence of instructions. This is set 1, for
 *			example, when command traces are requested.
 * RAND_SEED_INITIALIZED: Non-zero means that the randSeed value of the
 *			interp has not be initialized.	This is set 1
 *			when we first use the rand() or srand() functions.
 * SAFE_INTERP:		Non zero means that the current interp is a
 *			safe interp (ie it has only the safe commands
 *			installed, less priviledge than a regular interp).
 * USE_EVAL_DIRECT:	Non-zero means don't use the compiler or byte-code
 *			interpreter; instead, have Tcl_EvalObj call
 *			Tcl_EvalEx. Used primarily for testing the
 *			new parser.
 * INTERP_TRACE_IN_PROGRESS: Non-zero means that an interp trace is currently
 *			active; so no further trace callbacks should be
 *			invoked.
 */

#define DELETED				    1
#define ERR_IN_PROGRESS			    2
#define ERR_ALREADY_LOGGED		    4
#define ERROR_CODE_SET			    8
#define EXPR_INITIALIZED		 0x10
#define DONT_COMPILE_CMDS_INLINE	 0x20
#define RAND_SEED_INITIALIZED		 0x40
#define SAFE_INTERP			 0x80
#define USE_EVAL_DIRECT			0x100
#define INTERP_TRACE_IN_PROGRESS	0x200

/*
 *----------------------------------------------------------------
 * Data structures related to command parsing. These are used in
 * tclParse.c and its clients.
 *----------------------------------------------------------------
 */

/*
 * The following data structure is used by various parsing procedures
 * to hold information about where to store the results of parsing
 * (e.g. the substituted contents of a quoted argument, or the result
 * of a nested command).  At any given time, the space available
 * for output is fixed, but a procedure may be called to expand the
 * space available if the current space runs out.
 */

typedef struct ParseValue {
    char *buffer;		/* Address of first character in
				 * output buffer. */
    char *next;			/* Place to store next character in
				 * output buffer. */
    char *end;			/* Address of the last usable character
				 * in the buffer. */
    void (*expandProc) _ANSI_ARGS_((struct ParseValue *pvPtr, int needed));
				/* Procedure to call when space runs out;
				 * it will make more space. */
    ClientData clientData;	/* Arbitrary information for use of
				 * expandProc. */
} ParseValue;


/*
 * Maximum number of levels of nesting permitted in Tcl commands (used
 * to catch infinite recursion).
 */

#define MAX_NESTING_DEPTH	1000

/*
 * The macro below is used to modify a "char" value (e.g. by casting
 * it to an unsigned character) so that it can be used safely with
 * macros such as isspace.
 */

#define UCHAR(c) ((unsigned char) (c))

/*
 * This macro is used to determine the offset needed to safely allocate any
 * data structure in memory. Given a starting offset or size, it "rounds up"
 * or "aligns" the offset to the next 8-byte boundary so that any data
 * structure can be placed at the resulting offset without fear of an
 * alignment error.
 *
 * WARNING!! DO NOT USE THIS MACRO TO ALIGN POINTERS: it will produce
 * the wrong result on platforms that allocate addresses that are divisible
 * by 4 or 2. Only use it for offsets or sizes.
 */

#define TCL_ALIGN(x) (((int)(x) + 7) & ~7)

/*
 * The following enum values are used to specify the runtime platform
 * setting of the tclPlatform variable.
 */

typedef enum {
    TCL_PLATFORM_UNIX,		/* Any Unix-like OS. */
    TCL_PLATFORM_MAC,		/* MacOS. */
    TCL_PLATFORM_WINDOWS	/* Any Microsoft Windows OS. */
} TclPlatformType;

/*
 *  The following enum values are used to indicate the translation
 *  of a Tcl channel.  Declared here so that each platform can define
 *  TCL_PLATFORM_TRANSLATION to the native translation on that platform
 */

typedef enum TclEolTranslation {
    TCL_TRANSLATE_AUTO,                 /* Eol == \r, \n and \r\n. */
    TCL_TRANSLATE_CR,                   /* Eol == \r. */
    TCL_TRANSLATE_LF,                   /* Eol == \n. */
    TCL_TRANSLATE_CRLF                  /* Eol == \r\n. */
} TclEolTranslation;

/*
 * Flags for TclInvoke:
 *
 * TCL_INVOKE_HIDDEN		Invoke a hidden command; if not set,
 *				invokes an exposed command.
 * TCL_INVOKE_NO_UNKNOWN	If set, "unknown" is not invoked if
 *				the command to be invoked is not found.
 *				Only has an effect if invoking an exposed
 *				command, i.e. if TCL_INVOKE_HIDDEN is not
 *				also set.
 * TCL_INVOKE_NO_TRACEBACK	Does not record traceback information if
 *				the invoked command returns an error.  Used
 *				if the caller plans on recording its own
 *				traceback information.
 */

#define	TCL_INVOKE_HIDDEN	(1<<0)
#define TCL_INVOKE_NO_UNKNOWN	(1<<1)
#define TCL_INVOKE_NO_TRACEBACK	(1<<2)

/*
 * The structure used as the internal representation of Tcl list
 * objects. This is an array of pointers to the element objects. This array
 * is grown (reallocated and copied) as necessary to hold all the list's
 * element pointers. The array might contain more slots than currently used
 * to hold all element pointers. This is done to make append operations
 * faster.
 */

typedef struct List {
    int maxElemCount;		/* Total number of element array slots. */
    int elemCount;		/* Current number of list elements. */
    Tcl_Obj **elements;		/* Array of pointers to element objects. */
} List;


/*
 * The following types are used for getting and storing platform-specific
 * file attributes in tclFCmd.c and the various platform-versions of
 * that file. This is done to have as much common code as possible
 * in the file attributes code. For more information about the callbacks,
 * see TclFileAttrsCmd in tclFCmd.c.
 */

typedef int (TclGetFileAttrProc) _ANSI_ARGS_((Tcl_Interp *interp,
	int objIndex, Tcl_Obj *fileName, Tcl_Obj **attrObjPtrPtr));
typedef int (TclSetFileAttrProc) _ANSI_ARGS_((Tcl_Interp *interp,
	int objIndex, Tcl_Obj *fileName, Tcl_Obj *attrObjPtr));

typedef struct TclFileAttrProcs {
    TclGetFileAttrProc *getProc;	/* The procedure for getting attrs. */
    TclSetFileAttrProc *setProc;	/* The procedure for setting attrs. */
} TclFileAttrProcs;

/*
 * Opaque handle used in pipeline routines to encapsulate platform-dependent
 * state. 
 */

typedef struct TclFile_ *TclFile;
    
/*
 * Opaque names for platform specific types.
 */

typedef struct TclpTime_t_    *TclpTime_t;

/*
 * The "globParameters" argument of the function TclGlob is an
 * or'ed combination of the following values:
 */

#define TCL_GLOBMODE_NO_COMPLAIN      1
#define TCL_GLOBMODE_JOIN             2
#define TCL_GLOBMODE_DIR              4
#define TCL_GLOBMODE_TAILS            8

/*
 *----------------------------------------------------------------
 * Data structures related to obsolete filesystem hooks
 *----------------------------------------------------------------
 */

typedef int (TclStatProc_) _ANSI_ARGS_((CONST char *path, struct stat *buf));
typedef int (TclAccessProc_) _ANSI_ARGS_((CONST char *path, int mode));
typedef Tcl_Channel (TclOpenFileChannelProc_) _ANSI_ARGS_((Tcl_Interp *interp,
	CONST char *fileName, CONST char *modeString,
	int permissions));


/*
 *----------------------------------------------------------------
 * Data structures related to procedures
 *----------------------------------------------------------------
 */

typedef Tcl_CmdProc *TclCmdProcType;
typedef Tcl_ObjCmdProc *TclObjCmdProcType;

/*
 *----------------------------------------------------------------
 * Variables shared among Tcl modules but not used by the outside world.
 *----------------------------------------------------------------
 */

extern Tcl_Time			tclBlockTime;
extern int			tclBlockTimeSet;
extern char *			tclExecutableName;
extern char *			tclNativeExecutableName;
extern char *			tclDefaultEncodingDir;
extern Tcl_ChannelType		tclFileChannelType;
extern char *			tclMemDumpFileName;
extern TclPlatformType		tclPlatform;

/*
 * Variables denoting the Tcl object types defined in the core.
 */

extern Tcl_ObjType	tclBooleanType;
extern Tcl_ObjType	tclByteArrayType;
extern Tcl_ObjType	tclByteCodeType;
extern Tcl_ObjType	tclDoubleType;
extern Tcl_ObjType	tclEndOffsetType;
extern Tcl_ObjType	tclIntType;
extern Tcl_ObjType	tclListType;
extern Tcl_ObjType	tclProcBodyType;
extern Tcl_ObjType	tclStringType;
extern Tcl_ObjType	tclArraySearchType;
extern Tcl_ObjType	tclIndexType;
extern Tcl_ObjType	tclNsNameType;
#ifndef TCL_WIDE_INT_IS_LONG
extern Tcl_ObjType	tclWideIntType;
#endif

/*
 * Variables denoting the hash key types defined in the core.
 */

extern Tcl_HashKeyType tclArrayHashKeyType;
extern Tcl_HashKeyType tclOneWordHashKeyType;
extern Tcl_HashKeyType tclStringHashKeyType;
extern Tcl_HashKeyType tclObjHashKeyType;

/*
 * The head of the list of free Tcl objects, and the total number of Tcl
 * objects ever allocated and freed.
 */

extern Tcl_Obj *	tclFreeObjList;

#ifdef TCL_COMPILE_STATS
extern long		tclObjsAlloced;
extern long		tclObjsFreed;
#define TCL_MAX_SHARED_OBJ_STATS 5
extern long		tclObjsShared[TCL_MAX_SHARED_OBJ_STATS];
#endif /* TCL_COMPILE_STATS */

/*
 * Pointer to a heap-allocated string of length zero that the Tcl core uses
 * as the value of an empty string representation for an object. This value
 * is shared by all new objects allocated by Tcl_NewObj.
 */

extern char *		tclEmptyStringRep;
extern char		tclEmptyString;

/*
 *----------------------------------------------------------------
 * Procedures shared among Tcl modules but not used by the outside
 * world:
 *----------------------------------------------------------------
 */

EXTERN int		TclArraySet _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_Obj *arrayNameObj, Tcl_Obj *arrayElemObj));
EXTERN int		TclCheckBadOctal _ANSI_ARGS_((Tcl_Interp *interp,
			    CONST char *value));
EXTERN void		TclExpandTokenArray _ANSI_ARGS_((
			    Tcl_Parse *parsePtr));
EXTERN int		TclFileAttrsCmd _ANSI_ARGS_((Tcl_Interp *interp,
			    int objc, Tcl_Obj *CONST objv[]));
EXTERN int		TclFileCopyCmd _ANSI_ARGS_((Tcl_Interp *interp, 
			    int objc, Tcl_Obj *CONST objv[])) ;
EXTERN int		TclFileDeleteCmd _ANSI_ARGS_((Tcl_Interp *interp,
			    int objc, Tcl_Obj *CONST objv[]));
EXTERN int		TclFileMakeDirsCmd _ANSI_ARGS_((Tcl_Interp *interp,
			    int objc, Tcl_Obj *CONST objv[])) ;
EXTERN int		TclFileRenameCmd _ANSI_ARGS_((Tcl_Interp *interp,
			    int objc, Tcl_Obj *CONST objv[])) ;
EXTERN void		TclFinalizeAllocSubsystem _ANSI_ARGS_((void));
EXTERN void		TclFinalizeCompExecEnv _ANSI_ARGS_((void));
EXTERN void		TclFinalizeCompilation _ANSI_ARGS_((void));
EXTERN void		TclFinalizeEncodingSubsystem _ANSI_ARGS_((void));
EXTERN void		TclFinalizeEnvironment _ANSI_ARGS_((void));
EXTERN void		TclFinalizeExecution _ANSI_ARGS_((void));
EXTERN void		TclFinalizeIOSubsystem _ANSI_ARGS_((void));
EXTERN void		TclFinalizeFilesystem _ANSI_ARGS_((void));
EXTERN void		TclFinalizeLoad _ANSI_ARGS_((void));
EXTERN void		TclFinalizeMemorySubsystem _ANSI_ARGS_((void));
EXTERN void		TclFinalizeNotifier _ANSI_ARGS_((void));
EXTERN void		TclFinalizeAsync _ANSI_ARGS_((void));
EXTERN void		TclFinalizeSynchronization _ANSI_ARGS_((void));
EXTERN void		TclFinalizeThreadData _ANSI_ARGS_((void));
EXTERN void		TclFindEncodings _ANSI_ARGS_((CONST char *argv0));
EXTERN int		TclGlob _ANSI_ARGS_((Tcl_Interp *interp,
			    char *pattern, Tcl_Obj *unquotedPrefix, 
			    int globFlags, Tcl_GlobTypeData* types));
EXTERN void		TclInitAlloc _ANSI_ARGS_((void));
EXTERN void		TclInitDbCkalloc _ANSI_ARGS_((void));
EXTERN void		TclInitEncodingSubsystem _ANSI_ARGS_((void));
EXTERN void		TclInitIOSubsystem _ANSI_ARGS_((void));
EXTERN void		TclInitNamespaceSubsystem _ANSI_ARGS_((void));
EXTERN void		TclInitNotifier _ANSI_ARGS_((void));
EXTERN void		TclInitObjSubsystem _ANSI_ARGS_((void));
EXTERN void		TclInitSubsystems _ANSI_ARGS_((CONST char *argv0));
EXTERN int		TclIsLocalScalar _ANSI_ARGS_((CONST char *src,
			    int len));
EXTERN int              TclJoinThread _ANSI_ARGS_((Tcl_ThreadId id,
			    int* result));
EXTERN Tcl_Obj *	TclLindexList _ANSI_ARGS_((Tcl_Interp* interp,
						   Tcl_Obj* listPtr,
						   Tcl_Obj* argPtr ));
EXTERN Tcl_Obj *	TclLindexFlat _ANSI_ARGS_((Tcl_Interp* interp,
						   Tcl_Obj* listPtr,
						   int indexCount,
						   Tcl_Obj *CONST indexArray[]
						   ));
EXTERN Tcl_Obj *	TclLsetList _ANSI_ARGS_((Tcl_Interp* interp,
						 Tcl_Obj* listPtr,
						 Tcl_Obj* indexPtr,
						 Tcl_Obj* valuePtr  
						 ));
EXTERN Tcl_Obj *	TclLsetFlat _ANSI_ARGS_((Tcl_Interp* interp,
						 Tcl_Obj* listPtr,
						 int indexCount,
						 Tcl_Obj *CONST indexArray[],
						 Tcl_Obj* valuePtr
						 ));
EXTERN int              TclParseBackslash _ANSI_ARGS_((CONST char *src,
                            int numBytes, int *readPtr, char *dst));
EXTERN int		TclParseHex _ANSI_ARGS_((CONST char *src, int numBytes,
                            Tcl_UniChar *resultPtr));
EXTERN int		TclParseInteger _ANSI_ARGS_((CONST char *string,
			    int numBytes));
EXTERN int		TclParseWhiteSpace _ANSI_ARGS_((CONST char *src,
			    int numBytes, Tcl_Parse *parsePtr, char *typePtr));
EXTERN int		TclpObjAccess _ANSI_ARGS_((Tcl_Obj *filename,
			    int mode));
EXTERN int              TclpObjLstat _ANSI_ARGS_((Tcl_Obj *pathPtr, 
			    Tcl_StatBuf *buf));
EXTERN int		TclpCheckStackSpace _ANSI_ARGS_((void));
EXTERN Tcl_Obj*         TclpTempFileName _ANSI_ARGS_((void));
EXTERN void		TclpFinalizeCondition _ANSI_ARGS_((
			    Tcl_Condition *condPtr));
EXTERN void		TclpFinalizeMutex _ANSI_ARGS_((Tcl_Mutex *mutexPtr));
EXTERN void		TclpFinalizeThreadData _ANSI_ARGS_((
			    Tcl_ThreadDataKey *keyPtr));
EXTERN void		TclpFinalizeThreadDataKey _ANSI_ARGS_((
			    Tcl_ThreadDataKey *keyPtr));
EXTERN char *		TclpFindExecutable _ANSI_ARGS_((
			    CONST char *argv0));
EXTERN int		TclpFindVariable _ANSI_ARGS_((CONST char *name,
			    int *lengthPtr));
EXTERN void		TclpInitLibraryPath _ANSI_ARGS_((CONST char *argv0));
EXTERN void		TclpInitLock _ANSI_ARGS_((void));
EXTERN void		TclpInitPlatform _ANSI_ARGS_((void));
EXTERN void		TclpInitUnlock _ANSI_ARGS_((void));
EXTERN int              TclpLoadFile _ANSI_ARGS_((Tcl_Interp *interp, 
				Tcl_Obj *pathPtr,
				CONST char *sym1, CONST char *sym2, 
				Tcl_PackageInitProc **proc1Ptr,
				Tcl_PackageInitProc **proc2Ptr, 
				ClientData *clientDataPtr,
				Tcl_FSUnloadFileProc **unloadProcPtr));
EXTERN Tcl_Obj*		TclpObjListVolumes _ANSI_ARGS_((void));
EXTERN void		TclpMasterLock _ANSI_ARGS_((void));
EXTERN void		TclpMasterUnlock _ANSI_ARGS_((void));
EXTERN int		TclpMatchFiles _ANSI_ARGS_((Tcl_Interp *interp,
			    char *separators, Tcl_DString *dirPtr,
			    char *pattern, char *tail));
EXTERN int              TclpObjNormalizePath _ANSI_ARGS_((Tcl_Interp *interp, 
			    Tcl_Obj *pathPtr, int nextCheckpoint));
EXTERN int		TclpObjCreateDirectory _ANSI_ARGS_((Tcl_Obj *pathPtr));
EXTERN void             TclpNativeJoinPath _ANSI_ARGS_((Tcl_Obj *prefix, 
							char *joining));
EXTERN Tcl_Obj*         TclpNativeSplitPath _ANSI_ARGS_((Tcl_Obj *pathPtr, 
							 int *lenPtr));
EXTERN Tcl_PathType     TclpGetNativePathType _ANSI_ARGS_((Tcl_Obj *pathObjPtr,
			    int *driveNameLengthPtr, Tcl_Obj **driveNameRef));
EXTERN int 		TclCrossFilesystemCopy _ANSI_ARGS_((Tcl_Interp *interp, 
			    Tcl_Obj *source, Tcl_Obj *target));
EXTERN int		TclpObjDeleteFile _ANSI_ARGS_((Tcl_Obj *pathPtr));
EXTERN int		TclpObjCopyDirectory _ANSI_ARGS_((Tcl_Obj *srcPathPtr, 
				Tcl_Obj *destPathPtr, Tcl_Obj **errorPtr));
EXTERN int		TclpObjCopyFile _ANSI_ARGS_((Tcl_Obj *srcPathPtr, 
				Tcl_Obj *destPathPtr));
EXTERN int		TclpObjRemoveDirectory _ANSI_ARGS_((Tcl_Obj *pathPtr, 
				int recursive, Tcl_Obj **errorPtr));
EXTERN int		TclpObjRenameFile _ANSI_ARGS_((Tcl_Obj *srcPathPtr, 
				Tcl_Obj *destPathPtr));
EXTERN int		TclpMatchInDirectory _ANSI_ARGS_((Tcl_Interp *interp, 
			        Tcl_Obj *resultPtr, Tcl_Obj *pathPtr, 
				CONST char *pattern, Tcl_GlobTypeData *types));
EXTERN Tcl_Obj*		TclpObjGetCwd _ANSI_ARGS_((Tcl_Interp *interp));
EXTERN Tcl_Obj*		TclpObjLink _ANSI_ARGS_((Tcl_Obj *pathPtr, 
				Tcl_Obj *toPtr, int linkType));
EXTERN int		TclpObjChdir _ANSI_ARGS_((Tcl_Obj *pathPtr));
EXTERN Tcl_Obj*         TclFileDirname _ANSI_ARGS_((Tcl_Interp *interp, 
						    Tcl_Obj*pathPtr));
EXTERN int		TclpObjStat _ANSI_ARGS_((Tcl_Obj *pathPtr, Tcl_StatBuf *buf));
EXTERN Tcl_Channel	TclpOpenFileChannel _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_Obj *pathPtr, int mode,
			    int permissions));
EXTERN void		TclpPanic _ANSI_ARGS_(TCL_VARARGS(CONST char *,
			    format));
EXTERN char *		TclpReadlink _ANSI_ARGS_((CONST char *fileName,
			    Tcl_DString *linkPtr));
EXTERN void		TclpReleaseFile _ANSI_ARGS_((TclFile file));
EXTERN void		TclpSetVariables _ANSI_ARGS_((Tcl_Interp *interp));
EXTERN void		TclpUnloadFile _ANSI_ARGS_((Tcl_LoadHandle loadHandle));
EXTERN VOID *		TclpThreadDataKeyGet _ANSI_ARGS_((
			    Tcl_ThreadDataKey *keyPtr));
EXTERN void		TclpThreadDataKeyInit _ANSI_ARGS_((
			    Tcl_ThreadDataKey *keyPtr));
EXTERN void		TclpThreadDataKeySet _ANSI_ARGS_((
			    Tcl_ThreadDataKey *keyPtr, VOID *data));
EXTERN void		TclpThreadExit _ANSI_ARGS_((int status));
EXTERN void		TclRememberCondition _ANSI_ARGS_((Tcl_Condition *mutex));
EXTERN void		TclRememberDataKey _ANSI_ARGS_((Tcl_ThreadDataKey *mutex));
EXTERN VOID             TclRememberJoinableThread _ANSI_ARGS_((Tcl_ThreadId id));
EXTERN void		TclRememberMutex _ANSI_ARGS_((Tcl_Mutex *mutex));
EXTERN VOID             TclSignalExitThread _ANSI_ARGS_((Tcl_ThreadId id,
			     int result));
EXTERN void		TclTransferResult _ANSI_ARGS_((Tcl_Interp *sourceInterp,
			    int result, Tcl_Interp *targetInterp));
EXTERN Tcl_Obj*         TclpNativeToNormalized 
                            _ANSI_ARGS_((ClientData clientData));
EXTERN Tcl_Obj*	        TclpFilesystemPathType
					_ANSI_ARGS_((Tcl_Obj* pathObjPtr));
EXTERN Tcl_PackageInitProc* TclpFindSymbol _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_LoadHandle loadHandle, CONST char *symbol));
EXTERN int              TclpDlopen _ANSI_ARGS_((Tcl_Interp *interp, 
			    Tcl_Obj *pathPtr, 
	                    Tcl_LoadHandle *loadHandle, 
		            Tcl_FSUnloadFileProc **unloadProcPtr));

/*
 *----------------------------------------------------------------
 * Command procedures in the generic core:
 *----------------------------------------------------------------
 */

EXTERN int	Tcl_AfterObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_AppendObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_ArrayObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_BinaryObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_BreakObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_CaseObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_CatchObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_CdObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_ClockObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_CloseObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_ConcatObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_ContinueObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_EncodingObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_EofObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_ErrorObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_EvalObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_ExecObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_ExitObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_ExprObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_FblockedObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_FconfigureObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_FcopyObjCmd _ANSI_ARGS_((ClientData dummy,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_FileObjCmd _ANSI_ARGS_((ClientData dummy,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_FileEventObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_FlushObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_ForObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_ForeachObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_FormatObjCmd _ANSI_ARGS_((ClientData dummy,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_GetsObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_GlobalObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_GlobObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_IfObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_IncrObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_InfoObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_InterpObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int argc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_JoinObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_LappendObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_LindexObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_LinsertObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_LlengthObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_ListObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_LoadObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_LrangeObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_LreplaceObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_LsearchObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_LsetObjCmd _ANSI_ARGS_((ClientData clientData,
                    Tcl_Interp* interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_LsortObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_NamespaceObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_OpenObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_PackageObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_PidObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_PutsObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_PwdObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_ReadObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_RegexpObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_RegsubObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_RenameObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_ReturnObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_ScanObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_SeekObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_SetObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_SplitObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_SocketObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_SourceObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_StringObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_SubstObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_SwitchObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_TellObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_TimeObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_TraceObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_UnsetObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_UpdateObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_UplevelObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_UpvarObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_VariableObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_VwaitObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_WhileObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));

/*
 *----------------------------------------------------------------
 * Command procedures found only in the Mac version of the core:
 *----------------------------------------------------------------
 */

#ifdef MAC_TCL
EXTERN int	Tcl_EchoCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int argc, CONST84 char **argv));
EXTERN int	Tcl_LsObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_BeepObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_MacSourceObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_ResourceObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
#endif

/*
 *----------------------------------------------------------------
 * Compilation procedures for commands in the generic core:
 *----------------------------------------------------------------
 */

EXTERN int	TclCompileAppendCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
EXTERN int	TclCompileBreakCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
EXTERN int	TclCompileCatchCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
EXTERN int	TclCompileContinueCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
EXTERN int	TclCompileExprCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
EXTERN int	TclCompileForCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
EXTERN int	TclCompileForeachCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
EXTERN int	TclCompileIfCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
EXTERN int	TclCompileIncrCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
EXTERN int	TclCompileLappendCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
EXTERN int	TclCompileLindexCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
EXTERN int	TclCompileListCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
EXTERN int	TclCompileLlengthCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
EXTERN int	TclCompileLsetCmd _ANSI_ARGS_((Tcl_Interp* interp,
		    Tcl_Parse* parsePtr, struct CompileEnv* envPtr));
EXTERN int	TclCompileRegexpCmd _ANSI_ARGS_((Tcl_Interp* interp,
		    Tcl_Parse* parsePtr, struct CompileEnv* envPtr));
EXTERN int	TclCompileReturnCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
EXTERN int	TclCompileSetCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
EXTERN int	TclCompileStringCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
EXTERN int	TclCompileWhileCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));

/*
 * Functions defined in generic/tclVar.c and currenttly exported only 
 * for use by the bytecode compiler and engine. Some of these could later 
 * be placed in the public interface.
 */

EXTERN Var *	TclLookupArrayElement _ANSI_ARGS_((Tcl_Interp *interp,
		    CONST char *arrayName, CONST char *elName, CONST int flags,
		    CONST char *msg, CONST int createPart1,
		    CONST int createPart2, Var *arrayPtr));	
EXTERN Var *    TclObjLookupVar _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Obj *part1Ptr, CONST char *part2, int flags,
		    CONST char *msg, CONST int createPart1,
		    CONST int createPart2, Var **arrayPtrPtr));
EXTERN Tcl_Obj *TclPtrGetVar _ANSI_ARGS_((Tcl_Interp *interp, Var *varPtr,
		    Var *arrayPtr, CONST char *part1, CONST char *part2,
		    CONST int flags));
EXTERN Tcl_Obj *TclPtrSetVar _ANSI_ARGS_((Tcl_Interp *interp, Var *varPtr,
		    Var *arrayPtr, CONST char *part1, CONST char *part2,
		    Tcl_Obj *newValuePtr, CONST int flags));
EXTERN Tcl_Obj *TclPtrIncrVar _ANSI_ARGS_((Tcl_Interp *interp, Var *varPtr,
		    Var *arrayPtr, CONST char *part1, CONST char *part2,
		    CONST long i, CONST int flags));

/*
 *----------------------------------------------------------------
 * Macros used by the Tcl core to create and release Tcl objects.
 * TclNewObj(objPtr) creates a new object denoting an empty string.
 * TclDecrRefCount(objPtr) decrements the object's reference count,
 * and frees the object if its reference count is zero.
 * These macros are inline versions of Tcl_NewObj() and
 * Tcl_DecrRefCount(). Notice that the names differ in not having
 * a "_" after the "Tcl". Notice also that these macros reference
 * their argument more than once, so you should avoid calling them
 * with an expression that is expensive to compute or has
 * side effects. The ANSI C "prototypes" for these macros are:
 *
 * EXTERN void	TclNewObj _ANSI_ARGS_((Tcl_Obj *objPtr));
 * EXTERN void	TclDecrRefCount _ANSI_ARGS_((Tcl_Obj *objPtr));
 *
 * These macros are defined in terms of two macros that depend on 
 * memory allocator in use: TclAllocObjStorage, TclFreeObjStorage.
 * They are defined below.
 *----------------------------------------------------------------
 */

#ifdef TCL_COMPILE_STATS
#  define TclIncrObjsAllocated() \
    tclObjsAlloced++
#  define TclIncrObjsFreed() \
    tclObjsFreed++
#else
#  define TclIncrObjsAllocated()
#  define TclIncrObjsFreed()
#endif /* TCL_COMPILE_STATS */

#define TclNewObj(objPtr) \
    TclAllocObjStorage(objPtr); \
    TclIncrObjsAllocated(); \
    (objPtr)->refCount = 0; \
    (objPtr)->bytes    = tclEmptyStringRep; \
    (objPtr)->length   = 0; \
    (objPtr)->typePtr  = NULL

#define TclDecrRefCount(objPtr) \
    if (--(objPtr)->refCount <= 0) { \
	if (((objPtr)->typePtr != NULL) \
		&& ((objPtr)->typePtr->freeIntRepProc != NULL)) { \
	    (objPtr)->typePtr->freeIntRepProc(objPtr); \
	} \
	if (((objPtr)->bytes != NULL) \
		&& ((objPtr)->bytes != tclEmptyStringRep)) { \
	    ckfree((char *) (objPtr)->bytes); \
	} \
        TclFreeObjStorage(objPtr); \
	TclIncrObjsFreed(); \
    }

#ifdef TCL_MEM_DEBUG
#  define TclAllocObjStorage(objPtr) \
       (objPtr) = (Tcl_Obj *) \
           Tcl_DbCkalloc(sizeof(Tcl_Obj), __FILE__, __LINE__)

#  define TclFreeObjStorage(objPtr) \
       if ((objPtr)->refCount < -1) { \
           panic("Reference count for %lx was negative: %s line %d", \
	           (objPtr), __FILE__, __LINE__); \
       } \
       ckfree((char *) (objPtr))
     
#  define TclDbNewObj(objPtr, file, line) \
       (objPtr) = (Tcl_Obj *) Tcl_DbCkalloc(sizeof(Tcl_Obj), (file), (line)); \
       (objPtr)->refCount = 0; \
       (objPtr)->bytes    = tclEmptyStringRep; \
       (objPtr)->length   = 0; \
       (objPtr)->typePtr  = NULL; \
       TclIncrObjsAllocated()
     
#elif defined(PURIFY)

/*
 * The PURIFY mode is like the regular mode, but instead of doing block
 * Tcl_Obj allocation and keeping a freed list for efficiency, it always
 * allocates and frees a single Tcl_Obj so that tools like Purify can
 * better track memory leaks
 */

#  define TclAllocObjStorage(objPtr) \
       (objPtr) = (Tcl_Obj *) Tcl_Ckalloc(sizeof(Tcl_Obj))

#  define TclFreeObjStorage(objPtr) \
       ckfree((char *) (objPtr))

#elif defined(TCL_THREADS) && defined(USE_THREAD_ALLOC)

/*
 * The TCL_THREADS mode is like the regular mode but allocates Tcl_Obj's
 * from per-thread caches.
 */

EXTERN Tcl_Obj *TclThreadAllocObj _ANSI_ARGS_((void));
EXTERN void TclThreadFreeObj _ANSI_ARGS_((Tcl_Obj *));

#  define TclAllocObjStorage(objPtr) \
       (objPtr) = TclThreadAllocObj()

#  define TclFreeObjStorage(objPtr) \
       TclThreadFreeObj((objPtr))

#else /* not TCL_MEM_DEBUG */

#ifdef TCL_THREADS
/* declared in tclObj.c */
extern Tcl_Mutex tclObjMutex;
#endif

#  define TclAllocObjStorage(objPtr) \
       Tcl_MutexLock(&tclObjMutex); \
       if (tclFreeObjList == NULL) { \
	   TclAllocateFreeObjects(); \
       } \
       (objPtr) = tclFreeObjList; \
       tclFreeObjList = (Tcl_Obj *) \
	   tclFreeObjList->internalRep.otherValuePtr; \
       Tcl_MutexUnlock(&tclObjMutex)

#  define TclFreeObjStorage(objPtr) \
       Tcl_MutexLock(&tclObjMutex); \
       (objPtr)->internalRep.otherValuePtr = (VOID *) tclFreeObjList; \
       tclFreeObjList = (objPtr); \
       Tcl_MutexUnlock(&tclObjMutex)

#endif /* TCL_MEM_DEBUG */

/*
 *----------------------------------------------------------------
 * Macro used by the Tcl core to set a Tcl_Obj's string representation
 * to a copy of the "len" bytes starting at "bytePtr". This code
 * works even if the byte array contains NULLs as long as the length
 * is correct. Because "len" is referenced multiple times, it should
 * be as simple an expression as possible. The ANSI C "prototype" for
 * this macro is:
 *
 * EXTERN void	TclInitStringRep _ANSI_ARGS_((Tcl_Obj *objPtr,
 *		    char *bytePtr, int len));
 *----------------------------------------------------------------
 */

#define TclInitStringRep(objPtr, bytePtr, len) \
    if ((len) == 0) { \
	(objPtr)->bytes	 = tclEmptyStringRep; \
	(objPtr)->length = 0; \
    } else { \
	(objPtr)->bytes = (char *) ckalloc((unsigned) ((len) + 1)); \
	memcpy((VOID *) (objPtr)->bytes, (VOID *) (bytePtr), \
		(unsigned) (len)); \
	(objPtr)->bytes[len] = '\0'; \
	(objPtr)->length = (len); \
    }

/*
 *----------------------------------------------------------------
 * Macro used by the Tcl core to get the string representation's
 * byte array pointer from a Tcl_Obj. This is an inline version
 * of Tcl_GetString(). The macro's expression result is the string
 * rep's byte pointer which might be NULL. The bytes referenced by 
 * this pointer must not be modified by the caller.
 * The ANSI C "prototype" for this macro is:
 *
 * EXTERN char *  TclGetString _ANSI_ARGS_((Tcl_Obj *objPtr));
 *----------------------------------------------------------------
 */

#define TclGetString(objPtr) \
    ((objPtr)->bytes? (objPtr)->bytes : Tcl_GetString((objPtr)))

/*
 *----------------------------------------------------------------
 * Macro used by the Tcl core to compare Unicode strings.  On
 * big-endian systems we can use the more efficient memcmp, but
 * this would not be lexically correct on little-endian systems.
 * The ANSI C "prototype" for this macro is:
 *
 * EXTERN int TclUniCharNcmp _ANSI_ARGS_((CONST Tcl_UniChar *cs,
 *         CONST Tcl_UniChar *ct, unsigned long n));
 *----------------------------------------------------------------
 */
#ifdef WORDS_BIGENDIAN
#   define TclUniCharNcmp(cs,ct,n) memcmp((cs),(ct),(n)*sizeof(Tcl_UniChar))
#else /* !WORDS_BIGENDIAN */
#   define TclUniCharNcmp Tcl_UniCharNcmp
#endif /* WORDS_BIGENDIAN */

#include "tclIntDecls.h"

# undef TCL_STORAGE_CLASS
# define TCL_STORAGE_CLASS DLLIMPORT

#endif /* _TCLINT */

@


1.4
log
@touched all sources to ease next import
@
text
@d10 1
d15 1
a15 1
 * RCS: @@(#) $Id: tclInt.h,v 1.7.8.2 2000/09/15 16:55:23 spolk Exp $
a30 2
#include <stdio.h>

d35 2
d94 1
a94 1
    Tcl_Interp* interp, char* name, int length,
d98 1
a98 1
    Tcl_Interp* interp, char* name, Tcl_Namespace *context,
d102 1
a102 1
    char* name, Tcl_Namespace *context, int flags,
d188 7
a194 5
    int resolverEpoch;		 /* Incremented whenever the name resolution
				  * rules change for this namespace; this
				  * invalidates all byte codes compiled in
				  * the namespace, causing the code to be
				  * recompiled under the new rules. */
d276 37
d657 1
a657 1
    Tcl_CmdTraceProc *proc;	/* Procedure to call to trace command. */
d660 4
d667 19
a766 5
EXTERN TclHandle	TclHandleCreate _ANSI_ARGS_((VOID *ptr));
EXTERN void		TclHandleFree _ANSI_ARGS_((TclHandle handle));
EXTERN TclHandle	TclHandlePreserve _ANSI_ARGS_((TclHandle handle));
EXTERN void		TclHandleRelease _ANSI_ARGS_((TclHandle handle)); 

d913 2
d1083 2
a1084 4
    int deleted;		/* Means that the command is in the process
				 * of being deleted (its deleteProc is
				 * currently executing). Other attempts to
				 * delete the command should be ignored. */
d1092 2
d1097 24
d1221 1
a1221 1
     * and tclvar.c for usage.
d1240 1
a1240 1
    ActiveVarTrace *activeTracePtr;
d1310 1
a1310 1
    char *scriptFile;		/* NULL means there is no nested source
d1312 1
a1312 3
				 * the name of the file being sourced (it's
				 * not malloc-ed:  it points to an argument
				 * to Tcl_EvalFile. */
d1333 10
d1401 3
d1415 1
d1478 1
a1478 1
 * The following macros are used to specify the runtime platform
d1489 13
d1546 1
a1546 1
	int objIndex, CONST char *fileName, Tcl_Obj **attrObjPtrPtr));
d1548 1
a1548 1
	int objIndex, CONST char *fileName, Tcl_Obj *attrObjPtr));
d1563 16
d1580 1
a1580 2
 * Data structures related to hooking 'TclStat(...)' and
 * 'TclAccess(...)'.
d1587 1
a1587 1
	char *fileName, char *modeString,
a1589 4
typedef int (*TclCmdProcType) _ANSI_ARGS_((ClientData clientData,
	Tcl_Interp *interp, int argc, char *argv[]));
typedef int (*TclObjCmdProcType) _ANSI_ARGS_((ClientData clientData,
	Tcl_Interp *interp, int objc, struct Tcl_Obj * CONST objv[]));
d1592 3
a1594 1
 * Opaque names for platform specific types.
d1597 2
a1598 36
typedef struct TclpTime_t_ *TclpTime_t;

/* 
 * The following structure is used to pass glob type data amongst
 * the various glob routines and TclpMatchFilesTypes.  Currently
 * most of the fields are ignored.  However they will be used in
 * a future release to implement glob's ability to find files
 * of particular types/permissions/etc only.
 */
typedef struct GlobTypeData {
    /* Corresponds to bcdpfls as in 'find -t' */
    int type;
    /* Corresponds to file permissions */
    int perm;
    /* Acceptable mac type */
    Tcl_Obj* macType;
    /* Acceptable mac creator */
    Tcl_Obj* macCreator;
} GlobTypeData;

/*
 * type and permission definitions for glob command
 */
#define TCL_GLOB_TYPE_BLOCK		(1<<0)
#define TCL_GLOB_TYPE_CHAR		(1<<1)
#define TCL_GLOB_TYPE_DIR		(1<<2)
#define TCL_GLOB_TYPE_PIPE		(1<<3)
#define TCL_GLOB_TYPE_FILE		(1<<4)
#define TCL_GLOB_TYPE_LINK		(1<<5)
#define TCL_GLOB_TYPE_SOCK		(1<<6)

#define TCL_GLOB_PERM_RONLY		(1<<0)
#define TCL_GLOB_PERM_HIDDEN		(1<<1)
#define TCL_GLOB_PERM_R			(1<<2)
#define TCL_GLOB_PERM_W			(1<<3)
#define TCL_GLOB_PERM_X			(1<<4)
a1613 2
extern char *			tclpFileAttrStrings[];
extern CONST TclFileAttrProcs	tclpFileAttrProcs[];
d1623 1
d1628 15
d1654 2
d1665 1
a1673 5
EXTERN int		TclAccess _ANSI_ARGS_((CONST char *path,
			    int mode));
EXTERN int		TclAccessDeleteProc _ANSI_ARGS_((TclAccessProc_ *proc));
EXTERN int		TclAccessInsertProc _ANSI_ARGS_((TclAccessProc_ *proc));
EXTERN void		TclAllocateFreeObjects _ANSI_ARGS_((void));
d1677 1
a1677 27
			    char *value));
EXTERN int		TclCleanupChildren _ANSI_ARGS_((Tcl_Interp *interp,
			    int numPids, Tcl_Pid *pidPtr,
			    Tcl_Channel errorChan));
EXTERN void		TclCleanupCommand _ANSI_ARGS_((Command *cmdPtr));
EXTERN int		TclCopyChannel _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_Channel inChan, Tcl_Channel outChan,
			    int toRead, Tcl_Obj *cmdPtr));
/*
 * TclCreatePipeline unofficially exported for use by BLT.
 */
EXTERN int		TclCreatePipeline _ANSI_ARGS_((Tcl_Interp *interp,
			    int argc, char **argv, Tcl_Pid **pidArrayPtr,
			    TclFile *inPipePtr, TclFile *outPipePtr,
			    TclFile *errFilePtr));
EXTERN int		TclCreateProc _ANSI_ARGS_((Tcl_Interp *interp,
			    Namespace *nsPtr, char *procName,
			    Tcl_Obj *argsPtr, Tcl_Obj *bodyPtr,
			    Proc **procPtrPtr));
EXTERN void		TclDeleteCompiledLocalVars _ANSI_ARGS_((
			    Interp *iPtr, CallFrame *framePtr));
EXTERN void		TclDeleteVars _ANSI_ARGS_((Interp *iPtr,
			    Tcl_HashTable *tablePtr));
EXTERN int		TclDoGlob _ANSI_ARGS_((Tcl_Interp *interp,
			    char *separators, Tcl_DString *headPtr,
			    char *tail, GlobTypeData *types));
EXTERN void		TclDumpMemoryInfo _ANSI_ARGS_((FILE *outFile));
a1679 2
EXTERN void		TclExprFloatError _ANSI_ARGS_((Tcl_Interp *interp,
			    double value));
d1683 1
a1683 1
			    int argc, char **argv)) ;
d1685 1
a1685 1
			    int argc, char **argv));
d1687 1
a1687 1
			    int argc, char **argv)) ;
d1689 1
a1689 1
			    int argc, char **argv)) ;
d1697 1
d1701 1
a1704 33
EXTERN Proc *		TclFindProc _ANSI_ARGS_((Interp *iPtr,
			    char *procName));
EXTERN int		TclFormatInt _ANSI_ARGS_((char *buffer, long n));
EXTERN void		TclFreePackageInfo _ANSI_ARGS_((Interp *iPtr));
EXTERN int		TclGetDate _ANSI_ARGS_((char *p,
			    unsigned long now, long zone,
			    unsigned long *timePtr));
EXTERN Tcl_Obj *	TclGetElementOfIndexedArray _ANSI_ARGS_((
			    Tcl_Interp *interp, int localIndex,
			    Tcl_Obj *elemPtr, int leaveErrorMsg));
EXTERN char *		TclGetExtension _ANSI_ARGS_((char *name));
EXTERN int		TclGetFrame _ANSI_ARGS_((Tcl_Interp *interp,
			    char *string, CallFrame **framePtrPtr));
EXTERN TclCmdProcType	TclGetInterpProc _ANSI_ARGS_((void));
EXTERN int		TclGetIntForIndex _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_Obj *objPtr, int endValue, int *indexPtr));
EXTERN Tcl_Obj *	TclGetIndexedScalar _ANSI_ARGS_((Tcl_Interp *interp,
			    int localIndex, int leaveErrorMsg));
EXTERN int		TclGetLong _ANSI_ARGS_((Tcl_Interp *interp,
			    char *string, long *longPtr));
EXTERN int		TclGetLoadedPackages _ANSI_ARGS_((
			    Tcl_Interp *interp, char *targetName));
EXTERN int		TclGetNamespaceForQualName _ANSI_ARGS_((
			    Tcl_Interp *interp, char *qualName,
			    Namespace *cxtNsPtr, int flags,
			    Namespace **nsPtrPtr, Namespace **altNsPtrPtr,
			    Namespace **actualCxtPtrPtr,
			    char **simpleNamePtr));
EXTERN TclObjCmdProcType TclGetObjInterpProc _ANSI_ARGS_((void));
EXTERN int		TclGetOpenMode _ANSI_ARGS_((Tcl_Interp *interp,
			    char *string, int *seekFlagPtr));
EXTERN Tcl_Command	TclGetOriginalCommand _ANSI_ARGS_((
			    Tcl_Command command));
d1706 2
a1707 18
			    char *pattern, char *unquotedPrefix, 
			    int globFlags, GlobTypeData* types));
EXTERN int		TclGlobalInvoke _ANSI_ARGS_((Tcl_Interp *interp,
			    int argc, char **argv, int flags));
EXTERN int		TclGuessPackageName _ANSI_ARGS_((char *fileName,
			    Tcl_DString *bufPtr));
EXTERN int		TclHideUnsafeCommands _ANSI_ARGS_((
			    Tcl_Interp *interp));
EXTERN int		TclInExit _ANSI_ARGS_((void));
EXTERN Tcl_Obj *	TclIncrElementOfIndexedArray _ANSI_ARGS_((
			    Tcl_Interp *interp, int localIndex,
			    Tcl_Obj *elemPtr, long incrAmount));
EXTERN Tcl_Obj *	TclIncrIndexedScalar _ANSI_ARGS_((
			    Tcl_Interp *interp, int localIndex,
			    long incrAmount));
EXTERN Tcl_Obj *	TclIncrVar2 _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_Obj *part1Ptr, Tcl_Obj *part2Ptr,
			    long incrAmount, int flags));
a1708 3
EXTERN void		TclInitCompiledLocals _ANSI_ARGS_((
			    Tcl_Interp *interp, CallFrame *framePtr,
			    Namespace *nsPtr));
a1715 8
EXTERN int		TclInvoke _ANSI_ARGS_((Tcl_Interp *interp,
			    int argc, char **argv, int flags));
EXTERN int		TclInvokeObjectCommand _ANSI_ARGS_((
			    ClientData clientData, Tcl_Interp *interp,
			    int argc, char **argv));
EXTERN int		TclInvokeStringCommand _ANSI_ARGS_((
			    ClientData clientData, Tcl_Interp *interp,
			    int objc, Tcl_Obj *CONST objv[]));
d1718 30
a1747 21
EXTERN Proc *		TclIsProc _ANSI_ARGS_((Command *cmdPtr));
EXTERN Var *		TclLookupVar _ANSI_ARGS_((Tcl_Interp *interp,
			    char *part1, char *part2, int flags, char *msg,
			    int createPart1, int createPart2,
			    Var **arrayPtrPtr));
EXTERN int		TclMathInProgress _ANSI_ARGS_((void));
EXTERN int		TclNeedSpace _ANSI_ARGS_((char *start, char *end));
EXTERN Tcl_Obj *	TclNewProcBodyObj _ANSI_ARGS_((Proc *procPtr));
EXTERN int		TclObjCommandComplete _ANSI_ARGS_((Tcl_Obj *cmdPtr));
EXTERN int		TclObjInterpProc _ANSI_ARGS_((ClientData clientData,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *CONST objv[]));
EXTERN int		TclObjInvoke _ANSI_ARGS_((Tcl_Interp *interp,
			    int objc, Tcl_Obj *CONST objv[], int flags));
EXTERN int		TclObjInvokeGlobal _ANSI_ARGS_((Tcl_Interp *interp,
			    int objc, Tcl_Obj *CONST objv[], int flags));
EXTERN int		TclOpenFileChannelDeleteProc _ANSI_ARGS_((
			    TclOpenFileChannelProc_ *proc));
EXTERN int		TclOpenFileChannelInsertProc _ANSI_ARGS_((
			    TclOpenFileChannelProc_ *proc));
EXTERN int		TclpAccess _ANSI_ARGS_((CONST char *filename,
d1749 2
a1750 1
EXTERN char *		TclpAlloc _ANSI_ARGS_((unsigned int size));
d1752 1
a1752 7
EXTERN int		TclpCopyFile _ANSI_ARGS_((CONST char *source,
			    CONST char *dest));
EXTERN int		TclpCopyDirectory _ANSI_ARGS_((CONST char *source,
			    CONST char *dest, Tcl_DString *errorPtr));
EXTERN int		TclpCreateDirectory _ANSI_ARGS_((CONST char *path));
EXTERN int		TclpDeleteFile _ANSI_ARGS_((CONST char *path));
EXTERN void		TclpExit _ANSI_ARGS_((int status));
a1763 9
EXTERN void		TclpFree _ANSI_ARGS_((char *ptr));
EXTERN unsigned long	TclpGetClicks _ANSI_ARGS_((void));
EXTERN Tcl_Channel	TclpGetDefaultStdChannel _ANSI_ARGS_((int type));
EXTERN unsigned long	TclpGetSeconds _ANSI_ARGS_((void));
EXTERN void		TclpGetTime _ANSI_ARGS_((Tcl_Time *time));
EXTERN int		TclpGetTimeZone _ANSI_ARGS_((unsigned long time));
EXTERN char *		TclpGetUserHome _ANSI_ARGS_((CONST char *name,
			    Tcl_DString *bufferPtr));
EXTERN int		TclpHasSockets _ANSI_ARGS_((Tcl_Interp *interp));
d1768 8
a1775 1
EXTERN int		TclpListVolumes _ANSI_ARGS_((Tcl_Interp *interp));
d1781 30
d1812 1
a1812 1
			    char *fileName, char *modeString,
d1814 2
a1817 2
EXTERN char *		TclpRealloc _ANSI_ARGS_((char *ptr,
			    unsigned int size));
a1818 5
EXTERN int		TclpRemoveDirectory _ANSI_ARGS_((CONST char *path,
			    int recursive, Tcl_DString *errorPtr));
EXTERN int		TclpRenameFile _ANSI_ARGS_((CONST char *source,
			    CONST char *dest));
EXTERN void		TclpSetInitialEncodings _ANSI_ARGS_((void));
d1820 1
a1820 17
EXTERN VOID *		TclpSysAlloc _ANSI_ARGS_((long size, int isBin));
EXTERN void		TclpSysFree _ANSI_ARGS_((VOID *ptr));
EXTERN VOID *		TclpSysRealloc _ANSI_ARGS_((VOID *cp,
			    unsigned int size));
EXTERN void		TclpUnloadFile _ANSI_ARGS_((ClientData clientData));
EXTERN char *		TclPrecTraceProc _ANSI_ARGS_((ClientData clientData,
			    Tcl_Interp *interp, char *name1, char *name2,
			    int flags));
EXTERN int		TclPreventAliasLoop _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_Interp *cmdInterp, Tcl_Command cmd));
EXTERN void		TclProcCleanupProc _ANSI_ARGS_((Proc *procPtr));
EXTERN int		TclProcCompileProc _ANSI_ARGS_((Tcl_Interp *interp,
			    Proc *procPtr, Tcl_Obj *bodyPtr, Namespace *nsPtr,
			    CONST char *description, CONST char *procName));
EXTERN void		TclProcDeleteProc _ANSI_ARGS_((ClientData clientData));
EXTERN int		TclProcInterpProc _ANSI_ARGS_((ClientData clientData,
			    Tcl_Interp *interp, int argc, char **argv));
d1830 1
d1832 2
a1833 23
EXTERN int		TclRenameCommand _ANSI_ARGS_((Tcl_Interp *interp,
			    char *oldName, char *newName)) ;
EXTERN void		TclResetShadowedCmdRefs _ANSI_ARGS_((
			    Tcl_Interp *interp, Command *newCmdPtr));
EXTERN int		TclServiceIdle _ANSI_ARGS_((void));
EXTERN Tcl_Obj *	TclSetElementOfIndexedArray _ANSI_ARGS_((
			    Tcl_Interp *interp, int localIndex,
			    Tcl_Obj *elemPtr, Tcl_Obj *objPtr,
			    int leaveErrorMsg));
EXTERN Tcl_Obj *	TclSetIndexedScalar _ANSI_ARGS_((Tcl_Interp *interp,
			    int localIndex, Tcl_Obj *objPtr,
			    int leaveErrorMsg));
EXTERN char *		TclSetPreInitScript _ANSI_ARGS_((char *string));
EXTERN void		TclSetupEnv _ANSI_ARGS_((Tcl_Interp *interp));
EXTERN int		TclSockGetPort _ANSI_ARGS_((Tcl_Interp *interp,
			    char *string, char *proto, int *portPtr));
EXTERN int		TclSockMinimumBuffers _ANSI_ARGS_((int sock,
			    int size));
EXTERN int		TclStat _ANSI_ARGS_((CONST char *path,
			    struct stat *buf));
EXTERN int		TclStatDeleteProc _ANSI_ARGS_((TclStatProc_ *proc));
EXTERN int		TclStatInsertProc _ANSI_ARGS_((TclStatProc_ *proc));
EXTERN void		TclTeardownNamespace _ANSI_ARGS_((Namespace *nsPtr));
d1836 10
a1845 1
EXTERN int		TclUpdateReturnInfo _ANSI_ARGS_((Interp *iPtr));
d1943 2
d2016 1
a2016 1
		    Tcl_Interp *interp, int argc, char **argv));
d2033 2
d2051 14
d2067 2
d2073 24
d2111 4
d2128 3
a2130 4
#ifdef TCL_MEM_DEBUG
#  define TclNewObj(objPtr) \
    (objPtr) = (Tcl_Obj *) \
	 Tcl_DbCkalloc(sizeof(Tcl_Obj), __FILE__, __LINE__); \
d2134 3
a2136 12
    (objPtr)->typePtr  = NULL; \
    TclIncrObjsAllocated()
     
#  define TclDbNewObj(objPtr, file, line) \
    (objPtr) = (Tcl_Obj *) Tcl_DbCkalloc(sizeof(Tcl_Obj), (file), (line)); \
    (objPtr)->refCount = 0; \
    (objPtr)->bytes    = tclEmptyStringRep; \
    (objPtr)->length   = 0; \
    (objPtr)->typePtr  = NULL; \
    TclIncrObjsAllocated()
     
#  define TclDecrRefCount(objPtr) \
d2138 4
a2141 3
	if ((objPtr)->refCount < -1) \
	    panic("Reference count for %lx was negative: %s line %d", \
		  (objPtr), __FILE__, __LINE__); \
d2146 1
a2146 5
	if (((objPtr)->typePtr != NULL) \
		&& ((objPtr)->typePtr->freeIntRepProc != NULL)) { \
	    (objPtr)->typePtr->freeIntRepProc(objPtr); \
	} \
	ckfree((char *) (objPtr)); \
d2150 51
d2204 1
d2208 15
a2222 14
#  define TclNewObj(objPtr) \
    Tcl_MutexLock(&tclObjMutex); \
    if (tclFreeObjList == NULL) { \
	TclAllocateFreeObjects(); \
    } \
    (objPtr) = tclFreeObjList; \
    tclFreeObjList = (Tcl_Obj *) \
	tclFreeObjList->internalRep.otherValuePtr; \
    (objPtr)->refCount = 0; \
    (objPtr)->bytes    = tclEmptyStringRep; \
    (objPtr)->length   = 0; \
    (objPtr)->typePtr  = NULL; \
    TclIncrObjsAllocated(); \
    Tcl_MutexUnlock(&tclObjMutex)
a2223 16
#  define TclDecrRefCount(objPtr) \
    if (--(objPtr)->refCount <= 0) { \
	if (((objPtr)->bytes != NULL) \
		&& ((objPtr)->bytes != tclEmptyStringRep)) { \
	    ckfree((char *) (objPtr)->bytes); \
	} \
	if (((objPtr)->typePtr != NULL) \
		&& ((objPtr)->typePtr->freeIntRepProc != NULL)) { \
	    (objPtr)->typePtr->freeIntRepProc(objPtr); \
	} \
	Tcl_MutexLock(&tclObjMutex); \
	(objPtr)->internalRep.otherValuePtr = (VOID *) tclFreeObjList; \
	tclFreeObjList = (objPtr); \
	TclIncrObjsFreed(); \
	Tcl_MutexUnlock(&tclObjMutex); \
    }
d2268 17
a2290 1

@


1.3
log
@touched all sources to ease next import
@
text
@@


1.3.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@a9 1
 * Copyright (c) 2001, 2002 by Kevin B. Kenny.  All rights reserved.
d14 1
a14 1
 * RCS: @@(#) $Id: tclInt.h,v 1.111 2002/08/14 17:31:43 msofer Exp $
d30 2
a35 2
#include <stdio.h>

d93 1
a93 1
    Tcl_Interp* interp, CONST84 char* name, int length,
d97 1
a97 1
    Tcl_Interp* interp, CONST84 char* name, Tcl_Namespace *context,
d101 1
a101 1
    CONST84 char* name, Tcl_Namespace *context, int flags,
d187 5
a191 7
    int resolverEpoch;		 /* Incremented whenever (a) the name resolution
				  * rules change for this namespace or (b) a 
				  * newly added command shadows a command that
				  * is compiled to bytecodes.
				  * This invalidates all byte codes compiled
				  * in the namespace, causing the code to be
				  * recompiled under the new rules.*/
a272 37
 * The following structure defines a command trace, which is used to
 * invoke a specific C procedure whenever certain operations are performed
 * on a command.
 */

typedef struct CommandTrace {
    Tcl_CommandTraceProc *traceProc;/* Procedure to call when operations given
				     * by flags are performed on command. */
    ClientData clientData;	    /* Argument to pass to proc. */
    int flags;			    /* What events the trace procedure is
				     * interested in:  OR-ed combination of
				     * TCL_TRACE_RENAME, TCL_TRACE_DELETE. */
    struct CommandTrace *nextPtr;   /* Next in list of traces associated with
				     * a particular command. */
} CommandTrace;

/*
 * When a command trace is active (i.e. its associated procedure is
 * executing), one of the following structures is linked into a list
 * associated with the command's interpreter.  The information in
 * the structure is needed in order for Tcl to behave reasonably
 * if traces are deleted while traces are active.
 */

typedef struct ActiveCommandTrace {
    struct Command *cmdPtr;	/* Command that's being traced. */
    struct ActiveCommandTrace *nextPtr;
				/* Next in list of all active command
				 * traces for the interpreter, or NULL
				 * if no more. */
    CommandTrace *nextTracePtr;	/* Next trace to check after current
				 * trace procedure returns;  if this
				 * trace gets deleted, must update pointer
				 * to avoid using free'd memory. */
} ActiveCommandTrace;

/*
d617 1
a617 1
    Tcl_CmdObjTraceProc *proc;	/* Procedure to call to trace command. */
a619 4
    int flags;			/* Flags governing the trace - see
				 * Tcl_CreateObjTrace for details */
    Tcl_CmdObjTraceDeleteProc* delProc;
				/* Procedure to call when trace is deleted */
a622 19
 * When an interpreter trace is active (i.e. its associated procedure
 * is executing), one of the following structures is linked into a list
 * associated with the interpreter.  The information in the structure
 * is needed in order for Tcl to behave reasonably if traces are
 * deleted while traces are active.
 */

typedef struct ActiveInterpTrace {
    struct ActiveInterpTrace *nextPtr;
				/* Next in list of all active command
				 * traces for the interpreter, or NULL
				 * if no more. */
    Trace *nextTracePtr;	/* Next trace to check after current
				 * trace procedure returns;  if this
				 * trace gets deleted, must update pointer
				 * to avoid using free'd memory. */
} ActiveInterpTrace;

/*
d704 5
a854 2
    Tcl_Obj *errorInfo;
    Tcl_Obj *errorCode;
d1023 4
a1026 2
    int flags;			/* Miscellaneous bits of information about
				 * command. See below for definitions. */
a1033 2
    CommandTrace *tracePtr;	/* First in list of all traces set for this
				 * command. */
a1036 24
 * Flag bits for commands. 
 *
 * CMD_IS_DELETED -		Means that the command is in the process
 *                              of being deleted (its deleteProc is
 *                              currently executing). Other attempts to
 *                              delete the command should be ignored.
 * CMD_TRACE_ACTIVE -		1 means that trace processing is currently
 *				underway for a rename/delete change.
 *				See the two flags below for which is
 *				currently being processed.
 * CMD_HAS_EXEC_TRACES -	1 means that this command has at least
 *                              one execution trace (as opposed to simple
 *                              delete/rename traces) in its tracePtr list.
 * TCL_TRACE_RENAME -           A rename trace is in progress. Further
 *                              recursive renames will not be traced.
 * TCL_TRACE_DELETE -           A delete trace is in progress. Further 
 *                              recursive deletes will not be traced.
 * (these last two flags are defined in tcl.h)
 */
#define CMD_IS_DELETED		0x1
#define CMD_TRACE_ACTIVE	0x2
#define CMD_HAS_EXEC_TRACES	0x4

/*
d1137 1
a1137 1
     * and tclVar.c for usage.
d1156 1
a1156 1
    ActiveVarTrace *activeVarTracePtr;
d1226 1
a1226 1
    Tcl_Obj *scriptFile;	/* NULL means there is no nested source
d1228 3
a1230 1
				 * pathPtr of the file being sourced. */
a1250 10
    ActiveCommandTrace *activeCmdTracePtr;
				/* First in list of active command traces for
				 * interp, or NULL if no active traces. */
    ActiveInterpTrace *activeInterpTracePtr;
				/* First in list of active traces for
				 * interp, or NULL if no active traces. */

    int tracesForbiddingInline; /* Count of traces (in the list headed by
				 * tracePtr) that forbid inline bytecode
				 * compilation */
a1308 3
 * INTERP_TRACE_IN_PROGRESS: Non-zero means that an interp trace is currently
 *			active; so no further trace callbacks should be
 *			invoked.
a1319 1
#define INTERP_TRACE_IN_PROGRESS	0x200
d1382 1
a1382 1
 * The following enum values are used to specify the runtime platform
a1392 13
 *  The following enum values are used to indicate the translation
 *  of a Tcl channel.  Declared here so that each platform can define
 *  TCL_PLATFORM_TRANSLATION to the native translation on that platform
 */

typedef enum TclEolTranslation {
    TCL_TRANSLATE_AUTO,                 /* Eol == \r, \n and \r\n. */
    TCL_TRANSLATE_CR,                   /* Eol == \r. */
    TCL_TRANSLATE_LF,                   /* Eol == \n. */
    TCL_TRANSLATE_CRLF                  /* Eol == \r\n. */
} TclEolTranslation;

/*
d1437 1
a1437 1
	int objIndex, Tcl_Obj *fileName, Tcl_Obj **attrObjPtrPtr));
d1439 1
a1439 1
	int objIndex, Tcl_Obj *fileName, Tcl_Obj *attrObjPtr));
a1453 16
 * Opaque names for platform specific types.
 */

typedef struct TclpTime_t_    *TclpTime_t;

/*
 * The "globParameters" argument of the function TclGlob is an
 * or'ed combination of the following values:
 */

#define TCL_GLOBMODE_NO_COMPLAIN      1
#define TCL_GLOBMODE_JOIN             2
#define TCL_GLOBMODE_DIR              4
#define TCL_GLOBMODE_TAILS            8

/*
d1455 2
a1456 1
 * Data structures related to obsolete filesystem hooks
d1463 1
a1463 1
	CONST char *fileName, CONST char *modeString,
d1466 4
d1472 1
a1472 3
 *----------------------------------------------------------------
 * Data structures related to procedures
 *----------------------------------------------------------------
d1475 36
a1510 2
typedef Tcl_CmdProc *TclCmdProcType;
typedef Tcl_ObjCmdProc *TclObjCmdProcType;
d1526 2
a1536 1
extern Tcl_ObjType	tclEndOffsetType;
a1540 15
extern Tcl_ObjType	tclArraySearchType;
extern Tcl_ObjType	tclIndexType;
extern Tcl_ObjType	tclNsNameType;
#ifndef TCL_WIDE_INT_IS_LONG
extern Tcl_ObjType	tclWideIntType;
#endif

/*
 * Variables denoting the hash key types defined in the core.
 */

extern Tcl_HashKeyType tclArrayHashKeyType;
extern Tcl_HashKeyType tclOneWordHashKeyType;
extern Tcl_HashKeyType tclStringHashKeyType;
extern Tcl_HashKeyType tclObjHashKeyType;
a1551 2
#define TCL_MAX_SHARED_OBJ_STATS 5
extern long		tclObjsShared[TCL_MAX_SHARED_OBJ_STATS];
a1560 1
extern char		tclEmptyString;
d1569 5
d1577 27
a1603 1
			    CONST char *value));
d1606 2
d1611 1
a1611 1
			    int objc, Tcl_Obj *CONST objv[])) ;
d1613 1
a1613 1
			    int objc, Tcl_Obj *CONST objv[]));
d1615 1
a1615 1
			    int objc, Tcl_Obj *CONST objv[])) ;
d1617 1
a1617 1
			    int objc, Tcl_Obj *CONST objv[])) ;
a1624 1
EXTERN void		TclFinalizeFilesystem _ANSI_ARGS_((void));
a1627 1
EXTERN void		TclFinalizeAsync _ANSI_ARGS_((void));
d1631 33
d1665 18
a1682 2
			    char *pattern, Tcl_Obj *unquotedPrefix, 
			    int globFlags, Tcl_GlobTypeData* types));
d1684 3
d1694 8
d1704 21
a1724 30
EXTERN int              TclJoinThread _ANSI_ARGS_((Tcl_ThreadId id,
			    int* result));
EXTERN Tcl_Obj *	TclLindexList _ANSI_ARGS_((Tcl_Interp* interp,
						   Tcl_Obj* listPtr,
						   Tcl_Obj* argPtr ));
EXTERN Tcl_Obj *	TclLindexFlat _ANSI_ARGS_((Tcl_Interp* interp,
						   Tcl_Obj* listPtr,
						   int indexCount,
						   Tcl_Obj *CONST indexArray[]
						   ));
EXTERN Tcl_Obj *	TclLsetList _ANSI_ARGS_((Tcl_Interp* interp,
						 Tcl_Obj* listPtr,
						 Tcl_Obj* indexPtr,
						 Tcl_Obj* valuePtr  
						 ));
EXTERN Tcl_Obj *	TclLsetFlat _ANSI_ARGS_((Tcl_Interp* interp,
						 Tcl_Obj* listPtr,
						 int indexCount,
						 Tcl_Obj *CONST indexArray[],
						 Tcl_Obj* valuePtr
						 ));
EXTERN int              TclParseBackslash _ANSI_ARGS_((CONST char *src,
                            int numBytes, int *readPtr, char *dst));
EXTERN int		TclParseHex _ANSI_ARGS_((CONST char *src, int numBytes,
                            Tcl_UniChar *resultPtr));
EXTERN int		TclParseInteger _ANSI_ARGS_((CONST char *string,
			    int numBytes));
EXTERN int		TclParseWhiteSpace _ANSI_ARGS_((CONST char *src,
			    int numBytes, Tcl_Parse *parsePtr, char *typePtr));
EXTERN int		TclpObjAccess _ANSI_ARGS_((Tcl_Obj *filename,
d1726 1
a1726 2
EXTERN int              TclpObjLstat _ANSI_ARGS_((Tcl_Obj *pathPtr, 
			    Tcl_StatBuf *buf));
d1728 7
a1734 1
EXTERN Tcl_Obj*         TclpTempFileName _ANSI_ARGS_((void));
d1746 9
d1759 1
a1759 8
EXTERN int              TclpLoadFile _ANSI_ARGS_((Tcl_Interp *interp, 
				Tcl_Obj *pathPtr,
				CONST char *sym1, CONST char *sym2, 
				Tcl_PackageInitProc **proc1Ptr,
				Tcl_PackageInitProc **proc2Ptr, 
				ClientData *clientDataPtr,
				Tcl_FSUnloadFileProc **unloadProcPtr));
EXTERN Tcl_Obj*		TclpObjListVolumes _ANSI_ARGS_((void));
a1764 30
EXTERN int              TclpObjNormalizePath _ANSI_ARGS_((Tcl_Interp *interp, 
			    Tcl_Obj *pathPtr, int nextCheckpoint));
EXTERN int		TclpObjCreateDirectory _ANSI_ARGS_((Tcl_Obj *pathPtr));
EXTERN void             TclpNativeJoinPath _ANSI_ARGS_((Tcl_Obj *prefix, 
							char *joining));
EXTERN Tcl_Obj*         TclpNativeSplitPath _ANSI_ARGS_((Tcl_Obj *pathPtr, 
							 int *lenPtr));
EXTERN Tcl_PathType     TclpGetNativePathType _ANSI_ARGS_((Tcl_Obj *pathObjPtr,
			    int *driveNameLengthPtr, Tcl_Obj **driveNameRef));
EXTERN int 		TclCrossFilesystemCopy _ANSI_ARGS_((Tcl_Interp *interp, 
			    Tcl_Obj *source, Tcl_Obj *target));
EXTERN int		TclpObjDeleteFile _ANSI_ARGS_((Tcl_Obj *pathPtr));
EXTERN int		TclpObjCopyDirectory _ANSI_ARGS_((Tcl_Obj *srcPathPtr, 
				Tcl_Obj *destPathPtr, Tcl_Obj **errorPtr));
EXTERN int		TclpObjCopyFile _ANSI_ARGS_((Tcl_Obj *srcPathPtr, 
				Tcl_Obj *destPathPtr));
EXTERN int		TclpObjRemoveDirectory _ANSI_ARGS_((Tcl_Obj *pathPtr, 
				int recursive, Tcl_Obj **errorPtr));
EXTERN int		TclpObjRenameFile _ANSI_ARGS_((Tcl_Obj *srcPathPtr, 
				Tcl_Obj *destPathPtr));
EXTERN int		TclpMatchInDirectory _ANSI_ARGS_((Tcl_Interp *interp, 
			        Tcl_Obj *resultPtr, Tcl_Obj *pathPtr, 
				CONST char *pattern, Tcl_GlobTypeData *types));
EXTERN Tcl_Obj*		TclpObjGetCwd _ANSI_ARGS_((Tcl_Interp *interp));
EXTERN Tcl_Obj*		TclpObjLink _ANSI_ARGS_((Tcl_Obj *pathPtr, 
				Tcl_Obj *toPtr, int linkType));
EXTERN int		TclpObjChdir _ANSI_ARGS_((Tcl_Obj *pathPtr));
EXTERN Tcl_Obj*         TclFileDirname _ANSI_ARGS_((Tcl_Interp *interp, 
						    Tcl_Obj*pathPtr));
EXTERN int		TclpObjStat _ANSI_ARGS_((Tcl_Obj *pathPtr, Tcl_StatBuf *buf));
d1766 1
a1766 1
			    Tcl_Obj *pathPtr, int mode,
a1767 2
EXTERN void		TclpPanic _ANSI_ARGS_(TCL_VARARGS(CONST char *,
			    format));
d1770 2
d1773 5
d1779 17
a1795 1
EXTERN void		TclpUnloadFile _ANSI_ARGS_((Tcl_LoadHandle loadHandle));
a1804 1
EXTERN VOID             TclRememberJoinableThread _ANSI_ARGS_((Tcl_ThreadId id));
d1806 23
a1828 2
EXTERN VOID             TclSignalExitThread _ANSI_ARGS_((Tcl_ThreadId id,
			     int result));
d1831 1
a1831 10
EXTERN Tcl_Obj*         TclpNativeToNormalized 
                            _ANSI_ARGS_((ClientData clientData));
EXTERN Tcl_Obj*	        TclpFilesystemPathType
					_ANSI_ARGS_((Tcl_Obj* pathObjPtr));
EXTERN Tcl_PackageInitProc* TclpFindSymbol _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_LoadHandle loadHandle, CONST char *symbol));
EXTERN int              TclpDlopen _ANSI_ARGS_((Tcl_Interp *interp, 
			    Tcl_Obj *pathPtr, 
	                    Tcl_LoadHandle *loadHandle, 
		            Tcl_FSUnloadFileProc **unloadProcPtr));
a1928 2
EXTERN int	Tcl_LsetObjCmd _ANSI_ARGS_((ClientData clientData,
                    Tcl_Interp* interp, int objc, Tcl_Obj *CONST objv[]));
d2000 1
a2000 1
		    Tcl_Interp *interp, int argc, CONST84 char **argv));
a2016 2
EXTERN int	TclCompileAppendCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
a2032 14
EXTERN int	TclCompileLappendCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
EXTERN int	TclCompileLindexCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
EXTERN int	TclCompileListCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
EXTERN int	TclCompileLlengthCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
EXTERN int	TclCompileLsetCmd _ANSI_ARGS_((Tcl_Interp* interp,
		    Tcl_Parse* parsePtr, struct CompileEnv* envPtr));
EXTERN int	TclCompileRegexpCmd _ANSI_ARGS_((Tcl_Interp* interp,
		    Tcl_Parse* parsePtr, struct CompileEnv* envPtr));
EXTERN int	TclCompileReturnCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
a2034 2
EXTERN int	TclCompileStringCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
a2038 24
 * Functions defined in generic/tclVar.c and currenttly exported only 
 * for use by the bytecode compiler and engine. Some of these could later 
 * be placed in the public interface.
 */

EXTERN Var *	TclLookupArrayElement _ANSI_ARGS_((Tcl_Interp *interp,
		    CONST char *arrayName, CONST char *elName, CONST int flags,
		    CONST char *msg, CONST int createPart1,
		    CONST int createPart2, Var *arrayPtr));	
EXTERN Var *    TclObjLookupVar _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Obj *part1Ptr, CONST char *part2, int flags,
		    CONST char *msg, CONST int createPart1,
		    CONST int createPart2, Var **arrayPtrPtr));
EXTERN Tcl_Obj *TclPtrGetVar _ANSI_ARGS_((Tcl_Interp *interp, Var *varPtr,
		    Var *arrayPtr, CONST char *part1, CONST char *part2,
		    CONST int flags));
EXTERN Tcl_Obj *TclPtrSetVar _ANSI_ARGS_((Tcl_Interp *interp, Var *varPtr,
		    Var *arrayPtr, CONST char *part1, CONST char *part2,
		    Tcl_Obj *newValuePtr, CONST int flags));
EXTERN Tcl_Obj *TclPtrIncrVar _ANSI_ARGS_((Tcl_Interp *interp, Var *varPtr,
		    Var *arrayPtr, CONST char *part1, CONST char *part2,
		    CONST long i, CONST int flags));

/*
a2052 4
 *
 * These macros are defined in terms of two macros that depend on 
 * memory allocator in use: TclAllocObjStorage, TclFreeObjStorage.
 * They are defined below.
d2066 12
a2077 3
#define TclNewObj(objPtr) \
    TclAllocObjStorage(objPtr); \
    TclIncrObjsAllocated(); \
d2081 4
a2084 3
    (objPtr)->typePtr  = NULL

#define TclDecrRefCount(objPtr) \
d2086 7
d2097 1
a2097 5
	if (((objPtr)->bytes != NULL) \
		&& ((objPtr)->bytes != tclEmptyStringRep)) { \
	    ckfree((char *) (objPtr)->bytes); \
	} \
        TclFreeObjStorage(objPtr); \
a2100 51
#ifdef TCL_MEM_DEBUG
#  define TclAllocObjStorage(objPtr) \
       (objPtr) = (Tcl_Obj *) \
           Tcl_DbCkalloc(sizeof(Tcl_Obj), __FILE__, __LINE__)

#  define TclFreeObjStorage(objPtr) \
       if ((objPtr)->refCount < -1) { \
           panic("Reference count for %lx was negative: %s line %d", \
	           (objPtr), __FILE__, __LINE__); \
       } \
       ckfree((char *) (objPtr))
     
#  define TclDbNewObj(objPtr, file, line) \
       (objPtr) = (Tcl_Obj *) Tcl_DbCkalloc(sizeof(Tcl_Obj), (file), (line)); \
       (objPtr)->refCount = 0; \
       (objPtr)->bytes    = tclEmptyStringRep; \
       (objPtr)->length   = 0; \
       (objPtr)->typePtr  = NULL; \
       TclIncrObjsAllocated()
     
#elif defined(PURIFY)

/*
 * The PURIFY mode is like the regular mode, but instead of doing block
 * Tcl_Obj allocation and keeping a freed list for efficiency, it always
 * allocates and frees a single Tcl_Obj so that tools like Purify can
 * better track memory leaks
 */

#  define TclAllocObjStorage(objPtr) \
       (objPtr) = (Tcl_Obj *) Tcl_Ckalloc(sizeof(Tcl_Obj))

#  define TclFreeObjStorage(objPtr) \
       ckfree((char *) (objPtr))

#elif defined(TCL_THREADS) && defined(USE_THREAD_ALLOC)

/*
 * The TCL_THREADS mode is like the regular mode but allocates Tcl_Obj's
 * from per-thread caches.
 */

EXTERN Tcl_Obj *TclThreadAllocObj _ANSI_ARGS_((void));
EXTERN void TclThreadFreeObj _ANSI_ARGS_((Tcl_Obj *));

#  define TclAllocObjStorage(objPtr) \
       (objPtr) = TclThreadAllocObj()

#  define TclFreeObjStorage(objPtr) \
       TclThreadFreeObj((objPtr))

a2103 1
/* declared in tclObj.c */
d2107 14
a2120 15
#  define TclAllocObjStorage(objPtr) \
       Tcl_MutexLock(&tclObjMutex); \
       if (tclFreeObjList == NULL) { \
	   TclAllocateFreeObjects(); \
       } \
       (objPtr) = tclFreeObjList; \
       tclFreeObjList = (Tcl_Obj *) \
	   tclFreeObjList->internalRep.otherValuePtr; \
       Tcl_MutexUnlock(&tclObjMutex)

#  define TclFreeObjStorage(objPtr) \
       Tcl_MutexLock(&tclObjMutex); \
       (objPtr)->internalRep.otherValuePtr = (VOID *) tclFreeObjList; \
       tclFreeObjList = (objPtr); \
       Tcl_MutexUnlock(&tclObjMutex)
d2122 16
a2181 17
/*
 *----------------------------------------------------------------
 * Macro used by the Tcl core to compare Unicode strings.  On
 * big-endian systems we can use the more efficient memcmp, but
 * this would not be lexically correct on little-endian systems.
 * The ANSI C "prototype" for this macro is:
 *
 * EXTERN int TclUniCharNcmp _ANSI_ARGS_((CONST Tcl_UniChar *cs,
 *         CONST Tcl_UniChar *ct, unsigned long n));
 *----------------------------------------------------------------
 */
#ifdef WORDS_BIGENDIAN
#   define TclUniCharNcmp(cs,ct,n) memcmp((cs),(ct),(n)*sizeof(Tcl_UniChar))
#else /* !WORDS_BIGENDIAN */
#   define TclUniCharNcmp Tcl_UniCharNcmp
#endif /* WORDS_BIGENDIAN */

d2188 1
@


1.3.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@a9 1
 * Copyright (c) 2001, 2002 by Kevin B. Kenny.  All rights reserved.
d14 1
a14 1
 * RCS: @@(#) $Id: tclInt.h,v 1.111 2002/08/14 17:31:43 msofer Exp $
d30 2
a35 2
#include <stdio.h>

d93 1
a93 1
    Tcl_Interp* interp, CONST84 char* name, int length,
d97 1
a97 1
    Tcl_Interp* interp, CONST84 char* name, Tcl_Namespace *context,
d101 1
a101 1
    CONST84 char* name, Tcl_Namespace *context, int flags,
d187 5
a191 7
    int resolverEpoch;		 /* Incremented whenever (a) the name resolution
				  * rules change for this namespace or (b) a 
				  * newly added command shadows a command that
				  * is compiled to bytecodes.
				  * This invalidates all byte codes compiled
				  * in the namespace, causing the code to be
				  * recompiled under the new rules.*/
a272 37
 * The following structure defines a command trace, which is used to
 * invoke a specific C procedure whenever certain operations are performed
 * on a command.
 */

typedef struct CommandTrace {
    Tcl_CommandTraceProc *traceProc;/* Procedure to call when operations given
				     * by flags are performed on command. */
    ClientData clientData;	    /* Argument to pass to proc. */
    int flags;			    /* What events the trace procedure is
				     * interested in:  OR-ed combination of
				     * TCL_TRACE_RENAME, TCL_TRACE_DELETE. */
    struct CommandTrace *nextPtr;   /* Next in list of traces associated with
				     * a particular command. */
} CommandTrace;

/*
 * When a command trace is active (i.e. its associated procedure is
 * executing), one of the following structures is linked into a list
 * associated with the command's interpreter.  The information in
 * the structure is needed in order for Tcl to behave reasonably
 * if traces are deleted while traces are active.
 */

typedef struct ActiveCommandTrace {
    struct Command *cmdPtr;	/* Command that's being traced. */
    struct ActiveCommandTrace *nextPtr;
				/* Next in list of all active command
				 * traces for the interpreter, or NULL
				 * if no more. */
    CommandTrace *nextTracePtr;	/* Next trace to check after current
				 * trace procedure returns;  if this
				 * trace gets deleted, must update pointer
				 * to avoid using free'd memory. */
} ActiveCommandTrace;

/*
d617 1
a617 1
    Tcl_CmdObjTraceProc *proc;	/* Procedure to call to trace command. */
a619 4
    int flags;			/* Flags governing the trace - see
				 * Tcl_CreateObjTrace for details */
    Tcl_CmdObjTraceDeleteProc* delProc;
				/* Procedure to call when trace is deleted */
a622 19
 * When an interpreter trace is active (i.e. its associated procedure
 * is executing), one of the following structures is linked into a list
 * associated with the interpreter.  The information in the structure
 * is needed in order for Tcl to behave reasonably if traces are
 * deleted while traces are active.
 */

typedef struct ActiveInterpTrace {
    struct ActiveInterpTrace *nextPtr;
				/* Next in list of all active command
				 * traces for the interpreter, or NULL
				 * if no more. */
    Trace *nextTracePtr;	/* Next trace to check after current
				 * trace procedure returns;  if this
				 * trace gets deleted, must update pointer
				 * to avoid using free'd memory. */
} ActiveInterpTrace;

/*
d704 5
a854 2
    Tcl_Obj *errorInfo;
    Tcl_Obj *errorCode;
d1023 4
a1026 2
    int flags;			/* Miscellaneous bits of information about
				 * command. See below for definitions. */
a1033 2
    CommandTrace *tracePtr;	/* First in list of all traces set for this
				 * command. */
a1036 24
 * Flag bits for commands. 
 *
 * CMD_IS_DELETED -		Means that the command is in the process
 *                              of being deleted (its deleteProc is
 *                              currently executing). Other attempts to
 *                              delete the command should be ignored.
 * CMD_TRACE_ACTIVE -		1 means that trace processing is currently
 *				underway for a rename/delete change.
 *				See the two flags below for which is
 *				currently being processed.
 * CMD_HAS_EXEC_TRACES -	1 means that this command has at least
 *                              one execution trace (as opposed to simple
 *                              delete/rename traces) in its tracePtr list.
 * TCL_TRACE_RENAME -           A rename trace is in progress. Further
 *                              recursive renames will not be traced.
 * TCL_TRACE_DELETE -           A delete trace is in progress. Further 
 *                              recursive deletes will not be traced.
 * (these last two flags are defined in tcl.h)
 */
#define CMD_IS_DELETED		0x1
#define CMD_TRACE_ACTIVE	0x2
#define CMD_HAS_EXEC_TRACES	0x4

/*
d1137 1
a1137 1
     * and tclVar.c for usage.
d1156 1
a1156 1
    ActiveVarTrace *activeVarTracePtr;
d1226 1
a1226 1
    Tcl_Obj *scriptFile;	/* NULL means there is no nested source
d1228 3
a1230 1
				 * pathPtr of the file being sourced. */
a1250 10
    ActiveCommandTrace *activeCmdTracePtr;
				/* First in list of active command traces for
				 * interp, or NULL if no active traces. */
    ActiveInterpTrace *activeInterpTracePtr;
				/* First in list of active traces for
				 * interp, or NULL if no active traces. */

    int tracesForbiddingInline; /* Count of traces (in the list headed by
				 * tracePtr) that forbid inline bytecode
				 * compilation */
a1308 3
 * INTERP_TRACE_IN_PROGRESS: Non-zero means that an interp trace is currently
 *			active; so no further trace callbacks should be
 *			invoked.
a1319 1
#define INTERP_TRACE_IN_PROGRESS	0x200
d1382 1
a1382 1
 * The following enum values are used to specify the runtime platform
a1392 13
 *  The following enum values are used to indicate the translation
 *  of a Tcl channel.  Declared here so that each platform can define
 *  TCL_PLATFORM_TRANSLATION to the native translation on that platform
 */

typedef enum TclEolTranslation {
    TCL_TRANSLATE_AUTO,                 /* Eol == \r, \n and \r\n. */
    TCL_TRANSLATE_CR,                   /* Eol == \r. */
    TCL_TRANSLATE_LF,                   /* Eol == \n. */
    TCL_TRANSLATE_CRLF                  /* Eol == \r\n. */
} TclEolTranslation;

/*
d1437 1
a1437 1
	int objIndex, Tcl_Obj *fileName, Tcl_Obj **attrObjPtrPtr));
d1439 1
a1439 1
	int objIndex, Tcl_Obj *fileName, Tcl_Obj *attrObjPtr));
a1453 16
 * Opaque names for platform specific types.
 */

typedef struct TclpTime_t_    *TclpTime_t;

/*
 * The "globParameters" argument of the function TclGlob is an
 * or'ed combination of the following values:
 */

#define TCL_GLOBMODE_NO_COMPLAIN      1
#define TCL_GLOBMODE_JOIN             2
#define TCL_GLOBMODE_DIR              4
#define TCL_GLOBMODE_TAILS            8

/*
d1455 2
a1456 1
 * Data structures related to obsolete filesystem hooks
d1463 1
a1463 1
	CONST char *fileName, CONST char *modeString,
d1466 4
d1472 1
a1472 3
 *----------------------------------------------------------------
 * Data structures related to procedures
 *----------------------------------------------------------------
d1475 36
a1510 2
typedef Tcl_CmdProc *TclCmdProcType;
typedef Tcl_ObjCmdProc *TclObjCmdProcType;
d1526 2
a1536 1
extern Tcl_ObjType	tclEndOffsetType;
a1540 15
extern Tcl_ObjType	tclArraySearchType;
extern Tcl_ObjType	tclIndexType;
extern Tcl_ObjType	tclNsNameType;
#ifndef TCL_WIDE_INT_IS_LONG
extern Tcl_ObjType	tclWideIntType;
#endif

/*
 * Variables denoting the hash key types defined in the core.
 */

extern Tcl_HashKeyType tclArrayHashKeyType;
extern Tcl_HashKeyType tclOneWordHashKeyType;
extern Tcl_HashKeyType tclStringHashKeyType;
extern Tcl_HashKeyType tclObjHashKeyType;
a1551 2
#define TCL_MAX_SHARED_OBJ_STATS 5
extern long		tclObjsShared[TCL_MAX_SHARED_OBJ_STATS];
a1560 1
extern char		tclEmptyString;
d1569 5
d1577 27
a1603 1
			    CONST char *value));
d1606 2
d1611 1
a1611 1
			    int objc, Tcl_Obj *CONST objv[])) ;
d1613 1
a1613 1
			    int objc, Tcl_Obj *CONST objv[]));
d1615 1
a1615 1
			    int objc, Tcl_Obj *CONST objv[])) ;
d1617 1
a1617 1
			    int objc, Tcl_Obj *CONST objv[])) ;
a1624 1
EXTERN void		TclFinalizeFilesystem _ANSI_ARGS_((void));
a1627 1
EXTERN void		TclFinalizeAsync _ANSI_ARGS_((void));
d1631 33
d1665 18
a1682 2
			    char *pattern, Tcl_Obj *unquotedPrefix, 
			    int globFlags, Tcl_GlobTypeData* types));
d1684 3
d1694 8
d1704 21
a1724 30
EXTERN int              TclJoinThread _ANSI_ARGS_((Tcl_ThreadId id,
			    int* result));
EXTERN Tcl_Obj *	TclLindexList _ANSI_ARGS_((Tcl_Interp* interp,
						   Tcl_Obj* listPtr,
						   Tcl_Obj* argPtr ));
EXTERN Tcl_Obj *	TclLindexFlat _ANSI_ARGS_((Tcl_Interp* interp,
						   Tcl_Obj* listPtr,
						   int indexCount,
						   Tcl_Obj *CONST indexArray[]
						   ));
EXTERN Tcl_Obj *	TclLsetList _ANSI_ARGS_((Tcl_Interp* interp,
						 Tcl_Obj* listPtr,
						 Tcl_Obj* indexPtr,
						 Tcl_Obj* valuePtr  
						 ));
EXTERN Tcl_Obj *	TclLsetFlat _ANSI_ARGS_((Tcl_Interp* interp,
						 Tcl_Obj* listPtr,
						 int indexCount,
						 Tcl_Obj *CONST indexArray[],
						 Tcl_Obj* valuePtr
						 ));
EXTERN int              TclParseBackslash _ANSI_ARGS_((CONST char *src,
                            int numBytes, int *readPtr, char *dst));
EXTERN int		TclParseHex _ANSI_ARGS_((CONST char *src, int numBytes,
                            Tcl_UniChar *resultPtr));
EXTERN int		TclParseInteger _ANSI_ARGS_((CONST char *string,
			    int numBytes));
EXTERN int		TclParseWhiteSpace _ANSI_ARGS_((CONST char *src,
			    int numBytes, Tcl_Parse *parsePtr, char *typePtr));
EXTERN int		TclpObjAccess _ANSI_ARGS_((Tcl_Obj *filename,
d1726 1
a1726 2
EXTERN int              TclpObjLstat _ANSI_ARGS_((Tcl_Obj *pathPtr, 
			    Tcl_StatBuf *buf));
d1728 7
a1734 1
EXTERN Tcl_Obj*         TclpTempFileName _ANSI_ARGS_((void));
d1746 9
d1759 1
a1759 8
EXTERN int              TclpLoadFile _ANSI_ARGS_((Tcl_Interp *interp, 
				Tcl_Obj *pathPtr,
				CONST char *sym1, CONST char *sym2, 
				Tcl_PackageInitProc **proc1Ptr,
				Tcl_PackageInitProc **proc2Ptr, 
				ClientData *clientDataPtr,
				Tcl_FSUnloadFileProc **unloadProcPtr));
EXTERN Tcl_Obj*		TclpObjListVolumes _ANSI_ARGS_((void));
a1764 30
EXTERN int              TclpObjNormalizePath _ANSI_ARGS_((Tcl_Interp *interp, 
			    Tcl_Obj *pathPtr, int nextCheckpoint));
EXTERN int		TclpObjCreateDirectory _ANSI_ARGS_((Tcl_Obj *pathPtr));
EXTERN void             TclpNativeJoinPath _ANSI_ARGS_((Tcl_Obj *prefix, 
							char *joining));
EXTERN Tcl_Obj*         TclpNativeSplitPath _ANSI_ARGS_((Tcl_Obj *pathPtr, 
							 int *lenPtr));
EXTERN Tcl_PathType     TclpGetNativePathType _ANSI_ARGS_((Tcl_Obj *pathObjPtr,
			    int *driveNameLengthPtr, Tcl_Obj **driveNameRef));
EXTERN int 		TclCrossFilesystemCopy _ANSI_ARGS_((Tcl_Interp *interp, 
			    Tcl_Obj *source, Tcl_Obj *target));
EXTERN int		TclpObjDeleteFile _ANSI_ARGS_((Tcl_Obj *pathPtr));
EXTERN int		TclpObjCopyDirectory _ANSI_ARGS_((Tcl_Obj *srcPathPtr, 
				Tcl_Obj *destPathPtr, Tcl_Obj **errorPtr));
EXTERN int		TclpObjCopyFile _ANSI_ARGS_((Tcl_Obj *srcPathPtr, 
				Tcl_Obj *destPathPtr));
EXTERN int		TclpObjRemoveDirectory _ANSI_ARGS_((Tcl_Obj *pathPtr, 
				int recursive, Tcl_Obj **errorPtr));
EXTERN int		TclpObjRenameFile _ANSI_ARGS_((Tcl_Obj *srcPathPtr, 
				Tcl_Obj *destPathPtr));
EXTERN int		TclpMatchInDirectory _ANSI_ARGS_((Tcl_Interp *interp, 
			        Tcl_Obj *resultPtr, Tcl_Obj *pathPtr, 
				CONST char *pattern, Tcl_GlobTypeData *types));
EXTERN Tcl_Obj*		TclpObjGetCwd _ANSI_ARGS_((Tcl_Interp *interp));
EXTERN Tcl_Obj*		TclpObjLink _ANSI_ARGS_((Tcl_Obj *pathPtr, 
				Tcl_Obj *toPtr, int linkType));
EXTERN int		TclpObjChdir _ANSI_ARGS_((Tcl_Obj *pathPtr));
EXTERN Tcl_Obj*         TclFileDirname _ANSI_ARGS_((Tcl_Interp *interp, 
						    Tcl_Obj*pathPtr));
EXTERN int		TclpObjStat _ANSI_ARGS_((Tcl_Obj *pathPtr, Tcl_StatBuf *buf));
d1766 1
a1766 1
			    Tcl_Obj *pathPtr, int mode,
a1767 2
EXTERN void		TclpPanic _ANSI_ARGS_(TCL_VARARGS(CONST char *,
			    format));
d1770 2
d1773 5
d1779 17
a1795 1
EXTERN void		TclpUnloadFile _ANSI_ARGS_((Tcl_LoadHandle loadHandle));
a1804 1
EXTERN VOID             TclRememberJoinableThread _ANSI_ARGS_((Tcl_ThreadId id));
d1806 23
a1828 2
EXTERN VOID             TclSignalExitThread _ANSI_ARGS_((Tcl_ThreadId id,
			     int result));
d1831 1
a1831 10
EXTERN Tcl_Obj*         TclpNativeToNormalized 
                            _ANSI_ARGS_((ClientData clientData));
EXTERN Tcl_Obj*	        TclpFilesystemPathType
					_ANSI_ARGS_((Tcl_Obj* pathObjPtr));
EXTERN Tcl_PackageInitProc* TclpFindSymbol _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_LoadHandle loadHandle, CONST char *symbol));
EXTERN int              TclpDlopen _ANSI_ARGS_((Tcl_Interp *interp, 
			    Tcl_Obj *pathPtr, 
	                    Tcl_LoadHandle *loadHandle, 
		            Tcl_FSUnloadFileProc **unloadProcPtr));
a1928 2
EXTERN int	Tcl_LsetObjCmd _ANSI_ARGS_((ClientData clientData,
                    Tcl_Interp* interp, int objc, Tcl_Obj *CONST objv[]));
d2000 1
a2000 1
		    Tcl_Interp *interp, int argc, CONST84 char **argv));
a2016 2
EXTERN int	TclCompileAppendCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
a2032 14
EXTERN int	TclCompileLappendCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
EXTERN int	TclCompileLindexCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
EXTERN int	TclCompileListCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
EXTERN int	TclCompileLlengthCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
EXTERN int	TclCompileLsetCmd _ANSI_ARGS_((Tcl_Interp* interp,
		    Tcl_Parse* parsePtr, struct CompileEnv* envPtr));
EXTERN int	TclCompileRegexpCmd _ANSI_ARGS_((Tcl_Interp* interp,
		    Tcl_Parse* parsePtr, struct CompileEnv* envPtr));
EXTERN int	TclCompileReturnCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
a2034 2
EXTERN int	TclCompileStringCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
a2038 24
 * Functions defined in generic/tclVar.c and currenttly exported only 
 * for use by the bytecode compiler and engine. Some of these could later 
 * be placed in the public interface.
 */

EXTERN Var *	TclLookupArrayElement _ANSI_ARGS_((Tcl_Interp *interp,
		    CONST char *arrayName, CONST char *elName, CONST int flags,
		    CONST char *msg, CONST int createPart1,
		    CONST int createPart2, Var *arrayPtr));	
EXTERN Var *    TclObjLookupVar _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Obj *part1Ptr, CONST char *part2, int flags,
		    CONST char *msg, CONST int createPart1,
		    CONST int createPart2, Var **arrayPtrPtr));
EXTERN Tcl_Obj *TclPtrGetVar _ANSI_ARGS_((Tcl_Interp *interp, Var *varPtr,
		    Var *arrayPtr, CONST char *part1, CONST char *part2,
		    CONST int flags));
EXTERN Tcl_Obj *TclPtrSetVar _ANSI_ARGS_((Tcl_Interp *interp, Var *varPtr,
		    Var *arrayPtr, CONST char *part1, CONST char *part2,
		    Tcl_Obj *newValuePtr, CONST int flags));
EXTERN Tcl_Obj *TclPtrIncrVar _ANSI_ARGS_((Tcl_Interp *interp, Var *varPtr,
		    Var *arrayPtr, CONST char *part1, CONST char *part2,
		    CONST long i, CONST int flags));

/*
a2052 4
 *
 * These macros are defined in terms of two macros that depend on 
 * memory allocator in use: TclAllocObjStorage, TclFreeObjStorage.
 * They are defined below.
d2066 12
a2077 3
#define TclNewObj(objPtr) \
    TclAllocObjStorage(objPtr); \
    TclIncrObjsAllocated(); \
d2081 4
a2084 3
    (objPtr)->typePtr  = NULL

#define TclDecrRefCount(objPtr) \
d2086 7
d2097 1
a2097 5
	if (((objPtr)->bytes != NULL) \
		&& ((objPtr)->bytes != tclEmptyStringRep)) { \
	    ckfree((char *) (objPtr)->bytes); \
	} \
        TclFreeObjStorage(objPtr); \
a2100 51
#ifdef TCL_MEM_DEBUG
#  define TclAllocObjStorage(objPtr) \
       (objPtr) = (Tcl_Obj *) \
           Tcl_DbCkalloc(sizeof(Tcl_Obj), __FILE__, __LINE__)

#  define TclFreeObjStorage(objPtr) \
       if ((objPtr)->refCount < -1) { \
           panic("Reference count for %lx was negative: %s line %d", \
	           (objPtr), __FILE__, __LINE__); \
       } \
       ckfree((char *) (objPtr))
     
#  define TclDbNewObj(objPtr, file, line) \
       (objPtr) = (Tcl_Obj *) Tcl_DbCkalloc(sizeof(Tcl_Obj), (file), (line)); \
       (objPtr)->refCount = 0; \
       (objPtr)->bytes    = tclEmptyStringRep; \
       (objPtr)->length   = 0; \
       (objPtr)->typePtr  = NULL; \
       TclIncrObjsAllocated()
     
#elif defined(PURIFY)

/*
 * The PURIFY mode is like the regular mode, but instead of doing block
 * Tcl_Obj allocation and keeping a freed list for efficiency, it always
 * allocates and frees a single Tcl_Obj so that tools like Purify can
 * better track memory leaks
 */

#  define TclAllocObjStorage(objPtr) \
       (objPtr) = (Tcl_Obj *) Tcl_Ckalloc(sizeof(Tcl_Obj))

#  define TclFreeObjStorage(objPtr) \
       ckfree((char *) (objPtr))

#elif defined(TCL_THREADS) && defined(USE_THREAD_ALLOC)

/*
 * The TCL_THREADS mode is like the regular mode but allocates Tcl_Obj's
 * from per-thread caches.
 */

EXTERN Tcl_Obj *TclThreadAllocObj _ANSI_ARGS_((void));
EXTERN void TclThreadFreeObj _ANSI_ARGS_((Tcl_Obj *));

#  define TclAllocObjStorage(objPtr) \
       (objPtr) = TclThreadAllocObj()

#  define TclFreeObjStorage(objPtr) \
       TclThreadFreeObj((objPtr))

a2103 1
/* declared in tclObj.c */
d2107 14
a2120 15
#  define TclAllocObjStorage(objPtr) \
       Tcl_MutexLock(&tclObjMutex); \
       if (tclFreeObjList == NULL) { \
	   TclAllocateFreeObjects(); \
       } \
       (objPtr) = tclFreeObjList; \
       tclFreeObjList = (Tcl_Obj *) \
	   tclFreeObjList->internalRep.otherValuePtr; \
       Tcl_MutexUnlock(&tclObjMutex)

#  define TclFreeObjStorage(objPtr) \
       Tcl_MutexLock(&tclObjMutex); \
       (objPtr)->internalRep.otherValuePtr = (VOID *) tclFreeObjList; \
       tclFreeObjList = (objPtr); \
       Tcl_MutexUnlock(&tclObjMutex)
d2122 16
a2181 17
/*
 *----------------------------------------------------------------
 * Macro used by the Tcl core to compare Unicode strings.  On
 * big-endian systems we can use the more efficient memcmp, but
 * this would not be lexically correct on little-endian systems.
 * The ANSI C "prototype" for this macro is:
 *
 * EXTERN int TclUniCharNcmp _ANSI_ARGS_((CONST Tcl_UniChar *cs,
 *         CONST Tcl_UniChar *ct, unsigned long n));
 *----------------------------------------------------------------
 */
#ifdef WORDS_BIGENDIAN
#   define TclUniCharNcmp(cs,ct,n) memcmp((cs),(ct),(n)*sizeof(Tcl_UniChar))
#else /* !WORDS_BIGENDIAN */
#   define TclUniCharNcmp Tcl_UniCharNcmp
#endif /* WORDS_BIGENDIAN */

d2188 1
@


1.2
log
@touched all Tcl files to ease next import.
@
text
@@


1.2.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.2.16.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@a9 1
 * Copyright (c) 2001, 2002 by Kevin B. Kenny.  All rights reserved.
d30 2
a35 2
#include <stdio.h>

d93 1
a93 1
    Tcl_Interp* interp, CONST84 char* name, int length,
d97 1
a97 1
    Tcl_Interp* interp, CONST84 char* name, Tcl_Namespace *context,
d101 1
a101 1
    CONST84 char* name, Tcl_Namespace *context, int flags,
d187 5
a191 7
    int resolverEpoch;		 /* Incremented whenever (a) the name resolution
				  * rules change for this namespace or (b) a 
				  * newly added command shadows a command that
				  * is compiled to bytecodes.
				  * This invalidates all byte codes compiled
				  * in the namespace, causing the code to be
				  * recompiled under the new rules.*/
a272 37
 * The following structure defines a command trace, which is used to
 * invoke a specific C procedure whenever certain operations are performed
 * on a command.
 */

typedef struct CommandTrace {
    Tcl_CommandTraceProc *traceProc;/* Procedure to call when operations given
				     * by flags are performed on command. */
    ClientData clientData;	    /* Argument to pass to proc. */
    int flags;			    /* What events the trace procedure is
				     * interested in:  OR-ed combination of
				     * TCL_TRACE_RENAME, TCL_TRACE_DELETE. */
    struct CommandTrace *nextPtr;   /* Next in list of traces associated with
				     * a particular command. */
} CommandTrace;

/*
 * When a command trace is active (i.e. its associated procedure is
 * executing), one of the following structures is linked into a list
 * associated with the command's interpreter.  The information in
 * the structure is needed in order for Tcl to behave reasonably
 * if traces are deleted while traces are active.
 */

typedef struct ActiveCommandTrace {
    struct Command *cmdPtr;	/* Command that's being traced. */
    struct ActiveCommandTrace *nextPtr;
				/* Next in list of all active command
				 * traces for the interpreter, or NULL
				 * if no more. */
    CommandTrace *nextTracePtr;	/* Next trace to check after current
				 * trace procedure returns;  if this
				 * trace gets deleted, must update pointer
				 * to avoid using free'd memory. */
} ActiveCommandTrace;

/*
d617 1
a617 1
    Tcl_CmdObjTraceProc *proc;	/* Procedure to call to trace command. */
a619 4
    int flags;			/* Flags governing the trace - see
				 * Tcl_CreateObjTrace for details */
    Tcl_CmdObjTraceDeleteProc* delProc;
				/* Procedure to call when trace is deleted */
a622 19
 * When an interpreter trace is active (i.e. its associated procedure
 * is executing), one of the following structures is linked into a list
 * associated with the interpreter.  The information in the structure
 * is needed in order for Tcl to behave reasonably if traces are
 * deleted while traces are active.
 */

typedef struct ActiveInterpTrace {
    struct ActiveInterpTrace *nextPtr;
				/* Next in list of all active command
				 * traces for the interpreter, or NULL
				 * if no more. */
    Trace *nextTracePtr;	/* Next trace to check after current
				 * trace procedure returns;  if this
				 * trace gets deleted, must update pointer
				 * to avoid using free'd memory. */
} ActiveInterpTrace;

/*
d704 5
a854 2
    Tcl_Obj *errorInfo;
    Tcl_Obj *errorCode;
d1023 4
a1026 2
    int flags;			/* Miscellaneous bits of information about
				 * command. See below for definitions. */
a1033 2
    CommandTrace *tracePtr;	/* First in list of all traces set for this
				 * command. */
a1036 24
 * Flag bits for commands. 
 *
 * CMD_IS_DELETED -		Means that the command is in the process
 *                              of being deleted (its deleteProc is
 *                              currently executing). Other attempts to
 *                              delete the command should be ignored.
 * CMD_TRACE_ACTIVE -		1 means that trace processing is currently
 *				underway for a rename/delete change.
 *				See the two flags below for which is
 *				currently being processed.
 * CMD_HAS_EXEC_TRACES -	1 means that this command has at least
 *                              one execution trace (as opposed to simple
 *                              delete/rename traces) in its tracePtr list.
 * TCL_TRACE_RENAME -           A rename trace is in progress. Further
 *                              recursive renames will not be traced.
 * TCL_TRACE_DELETE -           A delete trace is in progress. Further 
 *                              recursive deletes will not be traced.
 * (these last two flags are defined in tcl.h)
 */
#define CMD_IS_DELETED		0x1
#define CMD_TRACE_ACTIVE	0x2
#define CMD_HAS_EXEC_TRACES	0x4

/*
d1137 1
a1137 1
     * and tclVar.c for usage.
d1156 1
a1156 1
    ActiveVarTrace *activeVarTracePtr;
d1226 1
a1226 1
    Tcl_Obj *scriptFile;	/* NULL means there is no nested source
d1228 3
a1230 1
				 * pathPtr of the file being sourced. */
a1250 10
    ActiveCommandTrace *activeCmdTracePtr;
				/* First in list of active command traces for
				 * interp, or NULL if no active traces. */
    ActiveInterpTrace *activeInterpTracePtr;
				/* First in list of active traces for
				 * interp, or NULL if no active traces. */

    int tracesForbiddingInline; /* Count of traces (in the list headed by
				 * tracePtr) that forbid inline bytecode
				 * compilation */
a1308 3
 * INTERP_TRACE_IN_PROGRESS: Non-zero means that an interp trace is currently
 *			active; so no further trace callbacks should be
 *			invoked.
a1319 1
#define INTERP_TRACE_IN_PROGRESS	0x200
d1382 1
a1382 1
 * The following enum values are used to specify the runtime platform
a1392 13
 *  The following enum values are used to indicate the translation
 *  of a Tcl channel.  Declared here so that each platform can define
 *  TCL_PLATFORM_TRANSLATION to the native translation on that platform
 */

typedef enum TclEolTranslation {
    TCL_TRANSLATE_AUTO,                 /* Eol == \r, \n and \r\n. */
    TCL_TRANSLATE_CR,                   /* Eol == \r. */
    TCL_TRANSLATE_LF,                   /* Eol == \n. */
    TCL_TRANSLATE_CRLF                  /* Eol == \r\n. */
} TclEolTranslation;

/*
d1437 1
a1437 1
	int objIndex, Tcl_Obj *fileName, Tcl_Obj **attrObjPtrPtr));
d1439 1
a1439 1
	int objIndex, Tcl_Obj *fileName, Tcl_Obj *attrObjPtr));
a1453 16
 * Opaque names for platform specific types.
 */

typedef struct TclpTime_t_    *TclpTime_t;

/*
 * The "globParameters" argument of the function TclGlob is an
 * or'ed combination of the following values:
 */

#define TCL_GLOBMODE_NO_COMPLAIN      1
#define TCL_GLOBMODE_JOIN             2
#define TCL_GLOBMODE_DIR              4
#define TCL_GLOBMODE_TAILS            8

/*
d1455 2
a1456 1
 * Data structures related to obsolete filesystem hooks
d1463 1
a1463 1
	CONST char *fileName, CONST char *modeString,
d1466 4
d1472 1
a1472 3
 *----------------------------------------------------------------
 * Data structures related to procedures
 *----------------------------------------------------------------
d1475 36
a1510 2
typedef Tcl_CmdProc *TclCmdProcType;
typedef Tcl_ObjCmdProc *TclObjCmdProcType;
d1526 2
a1536 1
extern Tcl_ObjType	tclEndOffsetType;
a1540 15
extern Tcl_ObjType	tclArraySearchType;
extern Tcl_ObjType	tclIndexType;
extern Tcl_ObjType	tclNsNameType;
#ifndef TCL_WIDE_INT_IS_LONG
extern Tcl_ObjType	tclWideIntType;
#endif

/*
 * Variables denoting the hash key types defined in the core.
 */

extern Tcl_HashKeyType tclArrayHashKeyType;
extern Tcl_HashKeyType tclOneWordHashKeyType;
extern Tcl_HashKeyType tclStringHashKeyType;
extern Tcl_HashKeyType tclObjHashKeyType;
a1551 2
#define TCL_MAX_SHARED_OBJ_STATS 5
extern long		tclObjsShared[TCL_MAX_SHARED_OBJ_STATS];
a1560 1
extern char		tclEmptyString;
d1569 5
d1577 27
a1603 1
			    CONST char *value));
d1606 2
d1611 1
a1611 1
			    int objc, Tcl_Obj *CONST objv[])) ;
d1613 1
a1613 1
			    int objc, Tcl_Obj *CONST objv[]));
d1615 1
a1615 1
			    int objc, Tcl_Obj *CONST objv[])) ;
d1617 1
a1617 1
			    int objc, Tcl_Obj *CONST objv[])) ;
a1624 1
EXTERN void		TclFinalizeFilesystem _ANSI_ARGS_((void));
a1627 1
EXTERN void		TclFinalizeAsync _ANSI_ARGS_((void));
d1631 33
d1665 18
a1682 2
			    char *pattern, Tcl_Obj *unquotedPrefix, 
			    int globFlags, Tcl_GlobTypeData* types));
d1684 3
d1694 8
d1704 21
a1724 30
EXTERN int              TclJoinThread _ANSI_ARGS_((Tcl_ThreadId id,
			    int* result));
EXTERN Tcl_Obj *	TclLindexList _ANSI_ARGS_((Tcl_Interp* interp,
						   Tcl_Obj* listPtr,
						   Tcl_Obj* argPtr ));
EXTERN Tcl_Obj *	TclLindexFlat _ANSI_ARGS_((Tcl_Interp* interp,
						   Tcl_Obj* listPtr,
						   int indexCount,
						   Tcl_Obj *CONST indexArray[]
						   ));
EXTERN Tcl_Obj *	TclLsetList _ANSI_ARGS_((Tcl_Interp* interp,
						 Tcl_Obj* listPtr,
						 Tcl_Obj* indexPtr,
						 Tcl_Obj* valuePtr  
						 ));
EXTERN Tcl_Obj *	TclLsetFlat _ANSI_ARGS_((Tcl_Interp* interp,
						 Tcl_Obj* listPtr,
						 int indexCount,
						 Tcl_Obj *CONST indexArray[],
						 Tcl_Obj* valuePtr
						 ));
EXTERN int              TclParseBackslash _ANSI_ARGS_((CONST char *src,
                            int numBytes, int *readPtr, char *dst));
EXTERN int		TclParseHex _ANSI_ARGS_((CONST char *src, int numBytes,
                            Tcl_UniChar *resultPtr));
EXTERN int		TclParseInteger _ANSI_ARGS_((CONST char *string,
			    int numBytes));
EXTERN int		TclParseWhiteSpace _ANSI_ARGS_((CONST char *src,
			    int numBytes, Tcl_Parse *parsePtr, char *typePtr));
EXTERN int		TclpObjAccess _ANSI_ARGS_((Tcl_Obj *filename,
d1726 1
a1726 2
EXTERN int              TclpObjLstat _ANSI_ARGS_((Tcl_Obj *pathPtr, 
			    Tcl_StatBuf *buf));
d1728 7
a1734 1
EXTERN Tcl_Obj*         TclpTempFileName _ANSI_ARGS_((void));
d1746 9
d1759 1
a1759 8
EXTERN int              TclpLoadFile _ANSI_ARGS_((Tcl_Interp *interp, 
				Tcl_Obj *pathPtr,
				CONST char *sym1, CONST char *sym2, 
				Tcl_PackageInitProc **proc1Ptr,
				Tcl_PackageInitProc **proc2Ptr, 
				ClientData *clientDataPtr,
				Tcl_FSUnloadFileProc **unloadProcPtr));
EXTERN Tcl_Obj*		TclpObjListVolumes _ANSI_ARGS_((void));
a1764 30
EXTERN int              TclpObjNormalizePath _ANSI_ARGS_((Tcl_Interp *interp, 
			    Tcl_Obj *pathPtr, int nextCheckpoint));
EXTERN int		TclpObjCreateDirectory _ANSI_ARGS_((Tcl_Obj *pathPtr));
EXTERN void             TclpNativeJoinPath _ANSI_ARGS_((Tcl_Obj *prefix, 
							char *joining));
EXTERN Tcl_Obj*         TclpNativeSplitPath _ANSI_ARGS_((Tcl_Obj *pathPtr, 
							 int *lenPtr));
EXTERN Tcl_PathType     TclpGetNativePathType _ANSI_ARGS_((Tcl_Obj *pathObjPtr,
			    int *driveNameLengthPtr, Tcl_Obj **driveNameRef));
EXTERN int 		TclCrossFilesystemCopy _ANSI_ARGS_((Tcl_Interp *interp, 
			    Tcl_Obj *source, Tcl_Obj *target));
EXTERN int		TclpObjDeleteFile _ANSI_ARGS_((Tcl_Obj *pathPtr));
EXTERN int		TclpObjCopyDirectory _ANSI_ARGS_((Tcl_Obj *srcPathPtr, 
				Tcl_Obj *destPathPtr, Tcl_Obj **errorPtr));
EXTERN int		TclpObjCopyFile _ANSI_ARGS_((Tcl_Obj *srcPathPtr, 
				Tcl_Obj *destPathPtr));
EXTERN int		TclpObjRemoveDirectory _ANSI_ARGS_((Tcl_Obj *pathPtr, 
				int recursive, Tcl_Obj **errorPtr));
EXTERN int		TclpObjRenameFile _ANSI_ARGS_((Tcl_Obj *srcPathPtr, 
				Tcl_Obj *destPathPtr));
EXTERN int		TclpMatchInDirectory _ANSI_ARGS_((Tcl_Interp *interp, 
			        Tcl_Obj *resultPtr, Tcl_Obj *pathPtr, 
				CONST char *pattern, Tcl_GlobTypeData *types));
EXTERN Tcl_Obj*		TclpObjGetCwd _ANSI_ARGS_((Tcl_Interp *interp));
EXTERN Tcl_Obj*		TclpObjLink _ANSI_ARGS_((Tcl_Obj *pathPtr, 
				Tcl_Obj *toPtr, int linkType));
EXTERN int		TclpObjChdir _ANSI_ARGS_((Tcl_Obj *pathPtr));
EXTERN Tcl_Obj*         TclFileDirname _ANSI_ARGS_((Tcl_Interp *interp, 
						    Tcl_Obj*pathPtr));
EXTERN int		TclpObjStat _ANSI_ARGS_((Tcl_Obj *pathPtr, Tcl_StatBuf *buf));
d1766 1
a1766 1
			    Tcl_Obj *pathPtr, int mode,
a1767 2
EXTERN void		TclpPanic _ANSI_ARGS_(TCL_VARARGS(CONST char *,
			    format));
d1770 2
d1773 5
d1779 17
a1795 1
EXTERN void		TclpUnloadFile _ANSI_ARGS_((Tcl_LoadHandle loadHandle));
a1804 1
EXTERN VOID             TclRememberJoinableThread _ANSI_ARGS_((Tcl_ThreadId id));
d1806 23
a1828 2
EXTERN VOID             TclSignalExitThread _ANSI_ARGS_((Tcl_ThreadId id,
			     int result));
d1831 1
a1831 10
EXTERN Tcl_Obj*         TclpNativeToNormalized 
                            _ANSI_ARGS_((ClientData clientData));
EXTERN Tcl_Obj*	        TclpFilesystemPathType
					_ANSI_ARGS_((Tcl_Obj* pathObjPtr));
EXTERN Tcl_PackageInitProc* TclpFindSymbol _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_LoadHandle loadHandle, CONST char *symbol));
EXTERN int              TclpDlopen _ANSI_ARGS_((Tcl_Interp *interp, 
			    Tcl_Obj *pathPtr, 
	                    Tcl_LoadHandle *loadHandle, 
		            Tcl_FSUnloadFileProc **unloadProcPtr));
a1928 2
EXTERN int	Tcl_LsetObjCmd _ANSI_ARGS_((ClientData clientData,
                    Tcl_Interp* interp, int objc, Tcl_Obj *CONST objv[]));
d2000 1
a2000 1
		    Tcl_Interp *interp, int argc, CONST84 char **argv));
a2016 2
EXTERN int	TclCompileAppendCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
a2032 14
EXTERN int	TclCompileLappendCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
EXTERN int	TclCompileLindexCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
EXTERN int	TclCompileListCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
EXTERN int	TclCompileLlengthCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
EXTERN int	TclCompileLsetCmd _ANSI_ARGS_((Tcl_Interp* interp,
		    Tcl_Parse* parsePtr, struct CompileEnv* envPtr));
EXTERN int	TclCompileRegexpCmd _ANSI_ARGS_((Tcl_Interp* interp,
		    Tcl_Parse* parsePtr, struct CompileEnv* envPtr));
EXTERN int	TclCompileReturnCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
a2034 2
EXTERN int	TclCompileStringCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
a2038 24
 * Functions defined in generic/tclVar.c and currenttly exported only 
 * for use by the bytecode compiler and engine. Some of these could later 
 * be placed in the public interface.
 */

EXTERN Var *	TclLookupArrayElement _ANSI_ARGS_((Tcl_Interp *interp,
		    CONST char *arrayName, CONST char *elName, CONST int flags,
		    CONST char *msg, CONST int createPart1,
		    CONST int createPart2, Var *arrayPtr));	
EXTERN Var *    TclObjLookupVar _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Obj *part1Ptr, CONST char *part2, int flags,
		    CONST char *msg, CONST int createPart1,
		    CONST int createPart2, Var **arrayPtrPtr));
EXTERN Tcl_Obj *TclPtrGetVar _ANSI_ARGS_((Tcl_Interp *interp, Var *varPtr,
		    Var *arrayPtr, CONST char *part1, CONST char *part2,
		    CONST int flags));
EXTERN Tcl_Obj *TclPtrSetVar _ANSI_ARGS_((Tcl_Interp *interp, Var *varPtr,
		    Var *arrayPtr, CONST char *part1, CONST char *part2,
		    Tcl_Obj *newValuePtr, CONST int flags));
EXTERN Tcl_Obj *TclPtrIncrVar _ANSI_ARGS_((Tcl_Interp *interp, Var *varPtr,
		    Var *arrayPtr, CONST char *part1, CONST char *part2,
		    CONST long i, CONST int flags));

/*
a2052 4
 *
 * These macros are defined in terms of two macros that depend on 
 * memory allocator in use: TclAllocObjStorage, TclFreeObjStorage.
 * They are defined below.
d2066 12
a2077 3
#define TclNewObj(objPtr) \
    TclAllocObjStorage(objPtr); \
    TclIncrObjsAllocated(); \
d2081 4
a2084 3
    (objPtr)->typePtr  = NULL

#define TclDecrRefCount(objPtr) \
d2086 7
d2097 1
a2097 5
	if (((objPtr)->bytes != NULL) \
		&& ((objPtr)->bytes != tclEmptyStringRep)) { \
	    ckfree((char *) (objPtr)->bytes); \
	} \
        TclFreeObjStorage(objPtr); \
a2100 51
#ifdef TCL_MEM_DEBUG
#  define TclAllocObjStorage(objPtr) \
       (objPtr) = (Tcl_Obj *) \
           Tcl_DbCkalloc(sizeof(Tcl_Obj), __FILE__, __LINE__)

#  define TclFreeObjStorage(objPtr) \
       if ((objPtr)->refCount < -1) { \
           panic("Reference count for %lx was negative: %s line %d", \
	           (objPtr), __FILE__, __LINE__); \
       } \
       ckfree((char *) (objPtr))
     
#  define TclDbNewObj(objPtr, file, line) \
       (objPtr) = (Tcl_Obj *) Tcl_DbCkalloc(sizeof(Tcl_Obj), (file), (line)); \
       (objPtr)->refCount = 0; \
       (objPtr)->bytes    = tclEmptyStringRep; \
       (objPtr)->length   = 0; \
       (objPtr)->typePtr  = NULL; \
       TclIncrObjsAllocated()
     
#elif defined(PURIFY)

/*
 * The PURIFY mode is like the regular mode, but instead of doing block
 * Tcl_Obj allocation and keeping a freed list for efficiency, it always
 * allocates and frees a single Tcl_Obj so that tools like Purify can
 * better track memory leaks
 */

#  define TclAllocObjStorage(objPtr) \
       (objPtr) = (Tcl_Obj *) Tcl_Ckalloc(sizeof(Tcl_Obj))

#  define TclFreeObjStorage(objPtr) \
       ckfree((char *) (objPtr))

#elif defined(TCL_THREADS) && defined(USE_THREAD_ALLOC)

/*
 * The TCL_THREADS mode is like the regular mode but allocates Tcl_Obj's
 * from per-thread caches.
 */

EXTERN Tcl_Obj *TclThreadAllocObj _ANSI_ARGS_((void));
EXTERN void TclThreadFreeObj _ANSI_ARGS_((Tcl_Obj *));

#  define TclAllocObjStorage(objPtr) \
       (objPtr) = TclThreadAllocObj()

#  define TclFreeObjStorage(objPtr) \
       TclThreadFreeObj((objPtr))

a2103 1
/* declared in tclObj.c */
d2107 14
a2120 15
#  define TclAllocObjStorage(objPtr) \
       Tcl_MutexLock(&tclObjMutex); \
       if (tclFreeObjList == NULL) { \
	   TclAllocateFreeObjects(); \
       } \
       (objPtr) = tclFreeObjList; \
       tclFreeObjList = (Tcl_Obj *) \
	   tclFreeObjList->internalRep.otherValuePtr; \
       Tcl_MutexUnlock(&tclObjMutex)

#  define TclFreeObjStorage(objPtr) \
       Tcl_MutexLock(&tclObjMutex); \
       (objPtr)->internalRep.otherValuePtr = (VOID *) tclFreeObjList; \
       tclFreeObjList = (objPtr); \
       Tcl_MutexUnlock(&tclObjMutex)
d2122 16
a2181 17
/*
 *----------------------------------------------------------------
 * Macro used by the Tcl core to compare Unicode strings.  On
 * big-endian systems we can use the more efficient memcmp, but
 * this would not be lexically correct on little-endian systems.
 * The ANSI C "prototype" for this macro is:
 *
 * EXTERN int TclUniCharNcmp _ANSI_ARGS_((CONST Tcl_UniChar *cs,
 *         CONST Tcl_UniChar *ct, unsigned long n));
 *----------------------------------------------------------------
 */
#ifdef WORDS_BIGENDIAN
#   define TclUniCharNcmp(cs,ct,n) memcmp((cs),(ct),(n)*sizeof(Tcl_UniChar))
#else /* !WORDS_BIGENDIAN */
#   define TclUniCharNcmp Tcl_UniCharNcmp
#endif /* WORDS_BIGENDIAN */

d2188 1
@


1.1
log
@Initial revision
@
text
@a6 1
 * Copyright (c) 1994-1997 Sun Microsystems, Inc.
d8 2
a9 1
 * Copyright (c) 1998 by Scriptics Corporation.
d14 1
a14 1
 * RCS: @@(#) $Id: tclInt.h,v 1.11 1999/01/26 03:53:14 jingham Exp $
d25 1
a25 1
 * the three groups of #includes is important.  For example, stdio.h
a34 3
#ifndef _REGEXP
#include "tclRegexp.h"
#endif
a51 5
#if defined(__STDC__) || defined(HAS_STDARG)
#   include <stdarg.h>
#else
#   include <varargs.h>
#endif
d53 1
a54 1
# undef TCL_STORAGE_CLASS
d56 6
d101 2
a102 2
 	char* name, Tcl_Namespace *context, int flags,
 	Tcl_Command *rPtr));
d106 1
a106 1
 					 * resolution. */
d108 2
a109 2
 					 * resolution for variables that
 					 * can only be handled at runtime. */
d111 2
a112 2
 					/* Procedure handling variable name
 					 * resolution at compile time. */
d144 1
a144 1
                                  * by strings; values have type
d161 2
a162 2
                                  * registered in the namespace. Indexed by
                                  * strings; values have type (Command *).
d170 1
a170 1
                                  * by strings; values have type (Var *). */
d233 2
a234 2
#define NS_DYING  	0x01
#define NS_DEAD  	0x02
d266 2
a267 2
				 * TCL_TRACE_READS, TCL_TRACE_WRITES, and
				 * TCL_TRACE_UNSETS. */
d275 1
a275 1
 * associated with the variable's interpreter.  The information in
d307 1
a307 1
			 	 * to be enumerated (it's leftover from
d309 1
a309 1
				 * an "array anymore" command).  NULL
d387 1
a387 1
 * VAR_LINK - 			1 means this Var structure contains a
d438 1
a438 1
#define VAR_UNDEFINED	        0x8
d610 1
a610 1
 * The structure below defines a command trace.  This is used to allow Tcl
d632 1
a632 1
} AssocData;    
d696 16
a711 1
 * Data structures related to history.   These are used primarily
d779 15
d802 3
a804 3
 * Forward declaration to prevent an error when the forward reference to
 * CompileEnv is encountered in the procedure type CompileProc declared
 * below.
d828 10
a837 2
typedef int (CompileProc) _ANSI_ARGS_((Tcl_Interp *interp, char *string,
	char *lastChar, int compileFlags, struct CompileEnv *compEnvPtr));
a848 6
typedef union StackItem {
    Tcl_Obj *o;			/* Stack item as a pointer to a Tcl_Obj. */
    int      i;			/* Stack item as an integer. */
    VOID    *p;			/* Stack item as an arbitrary pointer. */
} StackItem;

d850 1
a850 1
    StackItem *stackPtr;	/* Points to the first item in the
d858 87
d960 1
a960 1
    				/* Points to the imported command created in
d979 1
a979 1
                                 * refers to. */
d1011 1
a1011 1
                                 * that point to this command when it is
d1013 1
a1013 1
    CompileProc *compileProc;   /* Procedure called to compile command. NULL
d1082 1
a1082 1
     * a Tcl_Interp struct (see tcl.h).  If you change one, be sure to
d1096 1
a1096 1
    char *result;               /* If the last command returned a string
d1099 7
a1105 7
    Tcl_FreeProc *freeProc;     /* Zero means a string result is statically
                                 * allocated. TCL_DYNAMIC means string
                                 * result was allocated with ckalloc and
                                 * should be freed with ckfree. Other values
                                 * give address of procedure to invoke to
                                 * free the string result. Tcl_Eval must
                                 * free it before executing next command. */
d1109 19
a1127 4
    Tcl_Obj *objResultPtr;	/* If the last command returned an object
				 * result, this points to it. Should not be
				 * accessed directly; see comment above. */
    Namespace *globalNsPtr;     /* The interpreter's global namespace. */
d1129 1
a1129 1
				 * defined for the interpreter.  Indexed by
d1133 2
d1142 1
a1142 1
				 * interpreter.  It's used to delay deletion
d1168 1
a1168 1
     * results.  See Tcl_AppendResult code for details.
d1172 1
a1172 1
				 * by Tcl_AppendResult.  Malloc-ed.  NULL
a1179 17
     * A cache of compiled regular expressions.  See Tcl_RegExpCompile
     * in tclUtil.c for details.
     */

#define NUM_REGEXPS 5
    char *patterns[NUM_REGEXPS];/* Strings corresponding to compiled
				 * regular expression patterns.  NULL
				 * means that this slot isn't used.
				 * Malloc-ed. */
    int patLengths[NUM_REGEXPS];/* Number of non-null characters in
				 * corresponding entry in patterns.
				 * -1 means entry isn't used. */
    regexp *regexps[NUM_REGEXPS];
				/* Compiled forms of above strings.  Also
				 * malloc-ed, or NULL if not in use yet. */

    /*
d1204 6
d1224 1
a1224 1
				 * Tcl_AddInterpResolver and
d1235 2
a1236 2
                                 * this interpreter. Cleaned up when
                                 * this interpreter is deleted. */
d1238 1
a1238 1
                                 * execution. Contains a pointer to the
d1246 14
d1268 1
a1268 1
 *			a code other than TCL_OK or TCL_ERROR;  0 means
d1291 1
a1291 1
 *			error.  Zero means Tcl_Eval must clear the
d1300 1
a1300 1
 *			interp has not be initialized.  This is set 1
d1302 18
a1319 13
 * SAFE_INTERP:         Non zero means that the current interp is a
 *                      safe interp (ie it has only the safe commands
 *                      installed, less priviledge than a regular interp).
 */

#define DELETED			 1
#define ERR_IN_PROGRESS		 2
#define ERR_ALREADY_LOGGED	 4
#define ERROR_CODE_SET		 8
#define EXPR_INITIALIZED	 0x10
#define DONT_COMPILE_CMDS_INLINE 0x20
#define RAND_SEED_INITIALIZED	 0x40
#define SAFE_INTERP              0x80
a1350 42
/*
 * A table used to classify input characters to assist in parsing
 * Tcl commands.  The table should be indexed with a signed character
 * using the CHAR_TYPE macro.  The character may have a negative
 * value.  The CHAR_TYPE macro takes a pointer to a signed character
 * and a pointer to the last character in the source string.  If the
 * src pointer is pointing at the terminating null of the string,
 * CHAR_TYPE returns TCL_COMMAND_END.
 */

extern unsigned char tclTypeTable[];
#define CHAR_TYPE(src,last) \
	(((src)==(last))?TCL_COMMAND_END:(tclTypeTable)[(int)(*(src) + 128)])

/*
 * Possible values returned by CHAR_TYPE. Note that except for TCL_DOLLAR,
 * these are all one byte values with a single bit set 1. This means these
 * values may be bit-or'ed together (except for TCL_DOLLAR) to quickly test
 * whether a character is one of several different kinds of characters.
 *
 * TCL_NORMAL -		All characters that don't have special significance
 *			to the Tcl language.
 * TCL_SPACE -		Character is space, tab, or return.
 * TCL_COMMAND_END -	Character is newline or semicolon or close-bracket
 *			or terminating null.
 * TCL_QUOTE -		Character is a double-quote.
 * TCL_OPEN_BRACKET -	Character is a "[".
 * TCL_OPEN_BRACE -	Character is a "{".
 * TCL_CLOSE_BRACE -	Character is a "}".
 * TCL_BACKSLASH -	Character is a "\".
 * TCL_DOLLAR - 	Character is a "$".
 */

#define TCL_NORMAL		0x01
#define TCL_SPACE		0x02
#define TCL_COMMAND_END		0x04
#define TCL_QUOTE		0x08
#define TCL_OPEN_BRACKET	0x10
#define TCL_OPEN_BRACE		0x20
#define TCL_CLOSE_BRACE		0x40
#define TCL_BACKSLASH		0x80
#define TCL_DOLLAR		0x00
d1402 4
d1410 1
d1427 1
d1437 1
a1437 2
	int objIndex, char *fileName, 
	Tcl_Obj **attrObjPtrPtr));
d1439 1
a1439 2
	int objIndex, char *fileName, 
	Tcl_Obj *attrObjPtr));
d1442 1
a1442 1
    TclGetFileAttrProc *getProc; 	/* The procedure for getting attrs. */
d1460 1
a1460 2
typedef struct stat TclStat_;
typedef int (TclStatProc_) _ANSI_ARGS_((CONST char *path, TclStat_ *buf));
d1472 41
d1521 3
a1523 1
extern Tcl_ChannelType	 	tclFileChannelType;
d1527 1
a1527 1
extern CONST TclFileAttrProcs   tclpFileAttrProcs[];
d1534 1
d1550 2
a1551 2
extern long 		tclObjsAlloced;
extern long 		tclObjsFreed;
a1568 1
EXTERN void		panic _ANSI_ARGS_(TCL_VARARGS(char *,format));
d1574 4
a1577 2
EXTERN int		TclChdir _ANSI_ARGS_((Tcl_Interp *interp,
			    char *dirName));
d1579 1
a1579 1
		            int numPids, Tcl_Pid *pidPtr,
a1581 2
EXTERN int		TclCopyAndCollapse _ANSI_ARGS_((int count,
			    char *src, char *dst));
d1597 1
a1597 1
    			    Interp *iPtr, CallFrame *framePtr));
d1602 1
a1602 1
			    char *tail));
d1604 2
a1605 2
EXTERN void		TclExpandParseValue _ANSI_ARGS_((ParseValue *pvPtr,
			    int needed));
d1612 1
a1612 1
EXTERN int 		TclFileDeleteCmd _ANSI_ARGS_((Tcl_Interp *interp,
d1618 1
d1620 2
d1623 8
a1630 4
EXTERN void		TclFinalizeExecEnv _ANSI_ARGS_((void));
EXTERN int		TclFindElement _ANSI_ARGS_((Tcl_Interp *interp,
			    char *list, int listLength, char **elementPtr,
			    char **nextPtr, int *sizePtr, int *bracePtr));
a1634 3
EXTERN void		TclGetAndDetachPids _ANSI_ARGS_((Tcl_Interp *interp,
		            Tcl_Channel chan));
EXTERN char *		TclGetCwd _ANSI_ARGS_((Tcl_Interp *interp));
a1637 1
EXTERN Tcl_Channel	TclGetDefaultStdChannel _ANSI_ARGS_((int type));
d1639 1
a1639 1
                            Tcl_Interp *interp, int localIndex,
a1640 1
EXTERN char *		TclGetEnv _ANSI_ARGS_((CONST char *name));
d1661 1
a1661 1
        		    char *string, int *seekFlagPtr));
d1664 3
a1666 2
EXTERN char *		TclGetUserHome _ANSI_ARGS_((char *name,
			    Tcl_DString *bufferPtr));
d1668 1
a1668 1
		            int argc, char **argv, int flags));
a1670 1
EXTERN int		TclHasSockets _ANSI_ARGS_((Tcl_Interp *interp));
d1672 1
a1672 1
    			    Tcl_Interp *interp));
d1675 1
a1675 1
                            Tcl_Interp *interp, int localIndex,
d1678 1
a1678 1
                            Tcl_Interp *interp, int localIndex,
d1682 2
a1683 1
			    long incrAmount, int part1NotParsed));
d1687 7
a1693 2
EXTERN void		TclInitNamespaces _ANSI_ARGS_((void));
EXTERN int		TclInterpInit _ANSI_ARGS_((Tcl_Interp *interp));
d1695 1
a1695 1
		            int argc, char **argv, int flags));
d1697 2
a1698 2
                            ClientData clientData, Tcl_Interp *interp,
                            int argc, char **argv));
d1700 4
a1703 2
                            ClientData clientData, Tcl_Interp *interp,
                            int objc, Tcl_Obj *CONST objv[]));
a1704 5
EXTERN int		TclLoadFile _ANSI_ARGS_((Tcl_Interp *interp,
			    char *fileName, char *sym1, char *sym2,
			    Tcl_PackageInitProc **proc1Ptr,
			    Tcl_PackageInitProc **proc2Ptr));
EXTERN int		TclLooksLikeInt _ANSI_ARGS_((char *p));
d1709 1
a1709 3
EXTERN int		TclMatchFiles _ANSI_ARGS_((Tcl_Interp *interp,
			    char *separators, Tcl_DString *dirPtr,
			    char *pattern, char *tail));
d1714 1
a1714 1
		    	    Tcl_Interp *interp, int objc,
d1717 1
a1717 1
		            int objc, Tcl_Obj *CONST objv[], int flags));
d1719 1
a1719 1
		            int objc, Tcl_Obj *CONST objv[], int flags));
d1724 2
a1726 6

/*
 * On a Mac, we can exit gracefully if the stack gets too small.
 */

#ifdef MAC_TCL
d1728 18
a1745 22
#else
#define TclpCheckStackSpace() (1)
#endif

EXTERN int		TclpCloseFile _ANSI_ARGS_((TclFile file));
EXTERN int		TclpCopyFile _ANSI_ARGS_((char *source, char *dest));
EXTERN int              TclpCopyDirectory _ANSI_ARGS_((char *source,
			    char *dest, Tcl_DString *errorPtr));
EXTERN Tcl_Channel	TclpCreateCommandChannel _ANSI_ARGS_((
    			    TclFile readFile, TclFile writeFile,
			    TclFile errorFile, int numPids, Tcl_Pid *pidPtr));
EXTERN int              TclpCreateDirectory _ANSI_ARGS_((char *path));
EXTERN int              TclpCreatePipe _ANSI_ARGS_((TclFile *readPipe,
			    TclFile *writePipe));
EXTERN int		TclpCreateProcess _ANSI_ARGS_((Tcl_Interp *interp,
			    int argc, char **argv, TclFile inputFile, 
			    TclFile outputFile, TclFile errorFile,
			    Tcl_Pid *pidPtr));
EXTERN TclFile		TclpCreateTempFile _ANSI_ARGS_((char *contents, 
			    Tcl_DString *namePtr));
EXTERN int              TclpDeleteFile _ANSI_ARGS_((char *path));
EXTERN void		TclpFinalize _ANSI_ARGS_((void));
d1748 1
d1752 7
a1758 1
EXTERN char *		TclpGetTZName _ANSI_ARGS_((void));
d1760 5
a1764 3
EXTERN TclFile		TclpMakeFile _ANSI_ARGS_((Tcl_Channel channel,
			    int direction));
EXTERN TclFile		TclpOpenFile _ANSI_ARGS_((char *fname, int mode));
d1768 2
d1772 2
a1773 1
EXTERN int              TclpRemoveDirectory _ANSI_ARGS_((char *path,
d1775 7
a1781 9
EXTERN int              TclpRenameFile _ANSI_ARGS_((char *source, char *dest));
#ifndef TclpSysAlloc
EXTERN VOID * 		TclpSysAlloc _ANSI_ARGS_((long size, int isBin));
#endif
#ifndef TclpSysFree
EXTERN void 		TclpSysFree _ANSI_ARGS_((VOID *ptr));
#endif
#ifndef TclpSysRealloc
EXTERN VOID * 		TclpSysRealloc _ANSI_ARGS_((VOID *cp,
d1783 1
a1783 11
#endif
EXTERN int		TclParseBraces _ANSI_ARGS_((Tcl_Interp *interp,
			    char *string, char **termPtr, ParseValue *pvPtr));
EXTERN int		TclParseNestedCmd _ANSI_ARGS_((Tcl_Interp *interp,
			    char *string, int flags, char **termPtr,
			    ParseValue *pvPtr));
EXTERN int		TclParseQuotes _ANSI_ARGS_((Tcl_Interp *interp,
			    char *string, int termChar, int flags,
			    char **termPtr, ParseValue *pvPtr));
EXTERN void		TclPlatformExit _ANSI_ARGS_((int status));
EXTERN void		TclPlatformInit _ANSI_ARGS_((Tcl_Interp *interp));
d1788 1
a1788 3
		            Tcl_Interp *cmdInterp, Tcl_Command cmd));
EXTERN void		TclPrintByteCodeObj _ANSI_ARGS_((Tcl_Interp *interp,
		            Tcl_Obj *objPtr));
d1791 2
a1792 2
 			    Proc *procPtr, Tcl_Obj *bodyPtr, Namespace *nsPtr,
 			    CONST char *description, CONST char *procName));
d1795 11
a1805 1
		    	    Tcl_Interp *interp, int argc, char **argv));
d1812 1
a1812 1
                            Tcl_Interp *interp, int localIndex,
d1821 1
a1821 1
		            char *string, char *proto, int *portPtr));
d1823 1
a1823 1
        		    int size));
d1825 1
a1825 1
			    TclStat_ *buf));
d1829 2
a1830 5
EXTERN int		TclTestChannelCmd _ANSI_ARGS_((ClientData clientData,
			    Tcl_Interp *interp, int argc, char **argv));
EXTERN int		TclTestChannelEventCmd _ANSI_ARGS_((
    			    ClientData clientData, Tcl_Interp *interp,
                            int argc, char **argv));
a1831 2
EXTERN char *		TclWordEnd _ANSI_ARGS_((char *start, char *lastChar,
			    int nested, int *semiPtr));
d1847 2
a1848 2
EXTERN int	Tcl_BreakCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int argc, char **argv));
d1861 4
a1864 2
EXTERN int	Tcl_ContinueCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int argc, char **argv));
d1871 2
a1872 2
EXTERN int	Tcl_ExecCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int argc, char **argv));
d1879 2
a1880 2
EXTERN int	Tcl_FconfigureCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int argc, char **argv));
d1885 2
a1886 2
EXTERN int	Tcl_FileEventCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int argc, char **argv));
d1889 2
a1890 2
EXTERN int	Tcl_ForCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int argc, char **argv));
d1899 6
a1904 6
EXTERN int	Tcl_GlobCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int argc, char **argv));
EXTERN int	Tcl_IfCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int argc, char **argv));
EXTERN int	Tcl_IncrCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int argc, char **argv));
d1921 2
a1922 2
EXTERN int	Tcl_LoadCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int argc, char **argv));
d1933 4
a1936 4
EXTERN int	Tcl_OpenCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int argc, char **argv));
EXTERN int	Tcl_PackageCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int argc, char **argv));
d1939 1
a1939 1
EXTERN int	Tcl_ProcObjCmd _ANSI_ARGS_((ClientData clientData,
d1941 1
a1941 1
EXTERN int	Tcl_PutsObjCmd _ANSI_ARGS_((ClientData clientData,
a1942 2
EXTERN int	Tcl_PwdCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int argc, char **argv));
d1945 4
a1948 4
EXTERN int	Tcl_RegexpCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int argc, char **argv));
EXTERN int	Tcl_RegsubCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int argc, char **argv));
d1953 6
a1958 6
EXTERN int	Tcl_ScanCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int argc, char **argv));
EXTERN int	Tcl_SeekCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int argc, char **argv));
EXTERN int	Tcl_SetCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int argc, char **argv));
d1961 2
a1962 2
EXTERN int	Tcl_SocketCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int argc, char **argv));
d1967 2
a1968 2
EXTERN int	Tcl_SubstCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int argc, char **argv));
d1971 2
a1972 2
EXTERN int	Tcl_TellCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int argc, char **argv));
d1975 2
a1976 2
EXTERN int	Tcl_TraceCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int argc, char **argv));
d1979 2
a1980 2
EXTERN int	Tcl_UpdateCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int argc, char **argv));
d1987 4
a1990 4
EXTERN int	Tcl_VwaitCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int argc, char **argv));
EXTERN int	Tcl_WhileCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int argc, char **argv));
d1999 1
a1999 1
EXTERN int 	Tcl_EchoCmd _ANSI_ARGS_((ClientData clientData,
d2001 3
a2003 3
EXTERN int 	Tcl_LsCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int argc, char **argv));
EXTERN int 	Tcl_BeepObjCmd _ANSI_ARGS_((ClientData clientData,
d2005 1
a2005 1
EXTERN int 	Tcl_MacSourceObjCmd _ANSI_ARGS_((ClientData clientData,
d2018 1
a2018 2
		    char *string, char *lastChar, int compileFlags,
		    struct CompileEnv *compileEnvPtr));
d2020 1
a2020 2
		    char *string, char *lastChar, int compileFlags,
		    struct CompileEnv *compileEnvPtr));
d2022 1
a2022 2
		    char *string, char *lastChar, int compileFlags,
		    struct CompileEnv *compileEnvPtr));
d2024 1
a2024 2
		    char *string, char *lastChar, int compileFlags,
		    struct CompileEnv *compileEnvPtr));
d2026 1
a2026 2
		    char *string, char *lastChar, int compileFlags,
		    struct CompileEnv *compileEnvPtr));
d2028 1
a2028 2
		    char *string, char *lastChar, int compileFlags,
		    struct CompileEnv *compileEnvPtr));
d2030 1
a2030 2
		    char *string, char *lastChar, int compileFlags,
		    struct CompileEnv *compileEnvPtr));
d2032 1
a2032 2
		    char *string, char *lastChar, int compileFlags,
		    struct CompileEnv *compileEnvPtr));
d2034 1
a2034 2
		    char *string, char *lastChar, int compileFlags,
		    struct CompileEnv *compileEnvPtr));
d2036 1
a2036 2
		    char *string, char *lastChar, int compileFlags,
		    struct CompileEnv *compileEnvPtr));
d2068 2
a2069 1
    (objPtr) = (Tcl_Obj *) Tcl_DbCkalloc(sizeof(Tcl_Obj), __FILE__, __LINE__); \
d2075 1
d2083 1
d2086 2
a2087 2
 	if ((objPtr)->refCount < -1) \
            panic("Reference count for %lx was negative: %s line %d", \
d2089 2
a2090 2
        if (((objPtr)->bytes != NULL) \
	        && ((objPtr)->bytes != tclEmptyStringRep)) { \
d2092 3
a2094 3
        } \
        if (((objPtr)->typePtr != NULL) \
	        && ((objPtr)->typePtr->freeIntRepProc != NULL)) { \
d2096 3
a2098 3
        } \
        ckfree((char *) (objPtr)); \
        TclIncrObjsFreed(); \
d2100 1
d2102 5
d2108 1
d2119 3
a2121 1
    TclIncrObjsAllocated()
d2124 2
a2125 2
        if (((objPtr)->bytes != NULL) \
	        && ((objPtr)->bytes != tclEmptyStringRep)) { \
d2127 3
a2129 3
        } \
        if (((objPtr)->typePtr != NULL) \
	        && ((objPtr)->typePtr->freeIntRepProc != NULL)) { \
d2131 6
a2136 4
        } \
        (objPtr)->internalRep.otherValuePtr = (VOID *) tclFreeObjList; \
        tclFreeObjList = (objPtr); \
        TclIncrObjsFreed(); \
d2156 1
a2156 1
        (objPtr)->bytes  = tclEmptyStringRep; \
d2161 1
a2161 1
	        (unsigned) (len)); \
d2169 5
a2173 7
 * byte array pointer and length from a Tcl_Obj. This is an inline
 * version of Tcl_GetStringFromObj(). "lengthPtr" must be the
 * address of an integer variable or NULL; If non-NULL, that variable
 * will be set to the string rep's length. The macro's expression
 * result is the string rep's byte pointer which might be NULL.
 * Note that the bytes referenced by this pointer must not be modified
 * by the caller. The ANSI C "prototype" for this macro is:
d2175 1
a2175 13
 * EXTERN char *  TclGetStringFromObj _ANSI_ARGS_((Tcl_Obj *objPtr,
 *		       int *lengthPtr));
 *----------------------------------------------------------------
 */

#define TclGetStringFromObj(objPtr, lengthPtr) \
    ((objPtr)->bytes? \
        ((lengthPtr)? \
	    ((*(lengthPtr) = (objPtr)->length), (objPtr)->bytes) : \
	    (objPtr)->bytes) : \
        Tcl_GetStringFromObj((objPtr), (lengthPtr)))

/*
a2176 7
 * Macro used by the Tcl core to reset an interpreter's Tcl object
 * result to an unshared empty string object with ref count one.
 * This does not clear any error information for the interpreter.
 * The ANSI C "prototype" for this macro is:
 *
 * EXTERN void	TclResetObjResult _ANSI_ARGS_((Tcl_Interp *interp));
 *---------------------------------------------------------------
d2179 2
a2180 29
#define TclResetObjResult(interp) \
    { \
        register Tcl_Obj *objResultPtr = ((Interp *) interp)->objResultPtr; \
        if (Tcl_IsShared(objResultPtr)) { \
	    TclDecrRefCount(objResultPtr); \
	    TclNewObj(objResultPtr); \
	    Tcl_IncrRefCount(objResultPtr); \
	    ((Interp *) interp)->objResultPtr = objResultPtr; \
        } else { \
	    if ((objResultPtr->bytes != NULL) \
		    && (objResultPtr->bytes != tclEmptyStringRep)) { \
	        ckfree((char *) objResultPtr->bytes); \
	    } \
	    objResultPtr->bytes  = tclEmptyStringRep; \
	    objResultPtr->length = 0; \
	    if ((objResultPtr->typePtr != NULL) \
	            && (objResultPtr->typePtr->freeIntRepProc != NULL)) { \
	        objResultPtr->typePtr->freeIntRepProc(objResultPtr); \
	    } \
	    objResultPtr->typePtr = (Tcl_ObjType *) NULL; \
        } \
    }

/*
 *----------------------------------------------------------------
 * Procedures used in conjunction with Tcl namespaces. They are
 * defined here instead of in tcl.h since they are not stable yet.
 *----------------------------------------------------------------
 */
d2182 1
a2182 60
EXTERN void		Tcl_AddInterpResolvers _ANSI_ARGS_((Tcl_Interp *interp,
 			    char *name, Tcl_ResolveCmdProc *cmdProc,
 			    Tcl_ResolveVarProc *varProc,
 			    Tcl_ResolveCompiledVarProc *compiledVarProc));
EXTERN int		Tcl_AppendExportList _ANSI_ARGS_((
			    Tcl_Interp *interp, Tcl_Namespace *nsPtr,
			    Tcl_Obj *objPtr));
EXTERN Tcl_Namespace *	Tcl_CreateNamespace _ANSI_ARGS_((Tcl_Interp *interp,
			    char *name, ClientData clientData,
			    Tcl_NamespaceDeleteProc *deleteProc));
EXTERN void		Tcl_DeleteNamespace _ANSI_ARGS_((
			    Tcl_Namespace *nsPtr));
EXTERN int		Tcl_Export _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_Namespace *nsPtr, char *pattern,
			    int resetListFirst));
EXTERN Tcl_Command	Tcl_FindCommand _ANSI_ARGS_((Tcl_Interp *interp,
			    char *name, Tcl_Namespace *contextNsPtr,
			    int flags));
EXTERN Tcl_Namespace *	Tcl_FindNamespace _ANSI_ARGS_((Tcl_Interp *interp,
			    char *name, Tcl_Namespace *contextNsPtr,
			    int flags));
EXTERN int              Tcl_GetInterpResolvers _ANSI_ARGS_((Tcl_Interp *interp,
                            char *name, Tcl_ResolverInfo *resInfo));
EXTERN int              Tcl_GetNamespaceResolvers _ANSI_ARGS_((
			    Tcl_Namespace *namespacePtr,
			    Tcl_ResolverInfo *resInfo));
EXTERN void		Tcl_GetVariableFullName _ANSI_ARGS_((
			    Tcl_Interp *interp, Tcl_Var variable,
  			    Tcl_Obj *objPtr));
EXTERN Tcl_Var		Tcl_FindNamespaceVar _ANSI_ARGS_((
			    Tcl_Interp *interp, char *name,
			    Tcl_Namespace *contextNsPtr, int flags));
EXTERN int		Tcl_ForgetImport _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_Namespace *nsPtr, char *pattern));
EXTERN Tcl_Command	Tcl_GetCommandFromObj _ANSI_ARGS_((
			    Tcl_Interp *interp, Tcl_Obj *objPtr));
EXTERN void		Tcl_GetCommandFullName _ANSI_ARGS_((
			    Tcl_Interp *interp, Tcl_Command command,
			    Tcl_Obj *objPtr));
EXTERN Tcl_Namespace *	Tcl_GetCurrentNamespace _ANSI_ARGS_((
			    Tcl_Interp *interp));
EXTERN Tcl_Namespace *	Tcl_GetGlobalNamespace _ANSI_ARGS_((
			    Tcl_Interp *interp));
EXTERN void		Tcl_GetVariableFullName _ANSI_ARGS_((
			    Tcl_Interp *interp, Tcl_Var variable,
			    Tcl_Obj *objPtr));
EXTERN int		Tcl_Import _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_Namespace *nsPtr, char *pattern,
			    int allowOverwrite));
EXTERN void		Tcl_PopCallFrame _ANSI_ARGS_((Tcl_Interp* interp));
EXTERN int		Tcl_PushCallFrame _ANSI_ARGS_((Tcl_Interp* interp,
			    Tcl_CallFrame *framePtr, Tcl_Namespace *nsPtr,
			    int isProcCallFrame)); 
EXTERN int		Tcl_RemoveInterpResolvers _ANSI_ARGS_((
			    Tcl_Interp *interp, char *name));
EXTERN void		Tcl_SetNamespaceResolvers _ANSI_ARGS_((
			    Tcl_Namespace *namespacePtr,
			    Tcl_ResolveCmdProc *cmdProc,
			    Tcl_ResolveVarProc *varProc,
			    Tcl_ResolveCompiledVarProc *compiledVarProc));
d2188 1
@


1.1.1.1
log
@import dejagnu-1999-11-08 snapshot
@
text
@@


1.1.1.2
log
@Tcl 8.3 upgrade
@
text
@d7 1
d9 1
a9 2
 * Copyright (c) 1994-1998 Sun Microsystems, Inc.
 * Copyright (c) 1998-1999 by Scriptics Corporation.
d14 1
a14 1
 * RCS: @@(#) $Id: tclInt.h,v 1.7.8.2 2000/09/15 16:55:23 spolk Exp $
d25 1
a25 1
 * the three groups of #includes is important.	For example, stdio.h
d35 3
d55 5
a60 1
#undef TCL_STORAGE_CLASS
d62 1
a63 6
#else
# ifdef USE_TCL_STUBS
#  define TCL_STORAGE_CLASS
# else
#  define TCL_STORAGE_CLASS DLLIMPORT
# endif
d103 2
a104 2
    char* name, Tcl_Namespace *context, int flags,
    Tcl_Command *rPtr));
d108 1
a108 1
					 * resolution. */
d110 2
a111 2
					 * resolution for variables that
					 * can only be handled at runtime. */
d113 2
a114 2
					/* Procedure handling variable name
					 * resolution at compile time. */
d146 1
a146 1
				  * by strings; values have type
d163 2
a164 2
				  * registered in the namespace. Indexed by
				  * strings; values have type (Command *).
d172 1
a172 1
				  * by strings; values have type (Var *). */
d235 2
a236 2
#define NS_DYING	0x01
#define NS_DEAD		0x02
d268 2
a269 2
				 * TCL_TRACE_READS, TCL_TRACE_WRITES,
				 * TCL_TRACE_UNSETS and TCL_TRACE_ARRAY. */
d277 1
a277 1
 * associated with the variable's interpreter.	The information in
d309 1
a309 1
				 * to be enumerated (it's leftover from
d311 1
a311 1
				 * an "array anymore" command).	 NULL
d389 1
a389 1
 * VAR_LINK -			1 means this Var structure contains a
d440 1
a440 1
#define VAR_UNDEFINED		0x8
d612 1
a612 1
 * The structure below defines a command trace.	 This is used to allow Tcl
d634 1
a634 1
} AssocData;	
d698 1
a698 16
 * Data structures and procedures related to TclHandles, which
 * are a very lightweight method of preserving enough information
 * to determine if an arbitrary malloc'd block has been deleted.
 *----------------------------------------------------------------
 */

typedef VOID **TclHandle;

EXTERN TclHandle	TclHandleCreate _ANSI_ARGS_((VOID *ptr));
EXTERN void		TclHandleFree _ANSI_ARGS_((TclHandle handle));
EXTERN TclHandle	TclHandlePreserve _ANSI_ARGS_((TclHandle handle));
EXTERN void		TclHandleRelease _ANSI_ARGS_((TclHandle handle)); 

/*
 *----------------------------------------------------------------
 * Data structures related to history.	 These are used primarily
a765 15
 * These are a thin layer over TclpThreadKeyDataGet and TclpThreadKeyDataSet
 * when threads are used, or an emulation if there are no threads.  These
 * are really internal and Tcl clients should use Tcl_GetThreadData.
 */

EXTERN VOID *TclThreadDataKeyGet _ANSI_ARGS_((Tcl_ThreadDataKey *keyPtr));
EXTERN void TclThreadDataKeySet _ANSI_ARGS_((Tcl_ThreadDataKey *keyPtr, VOID *data));

/*
 * This is a convenience macro used to initialize a thread local storage ptr.
 */
#define TCL_TSD_INIT(keyPtr)	(ThreadSpecificData *)Tcl_GetThreadData((keyPtr), sizeof(ThreadSpecificData))


/*
d774 3
a776 3
 * Forward declaration to prevent errors when the forward references to
 * Tcl_Parse and CompileEnv are encountered in the procedure type
 * CompileProc declared below.
d800 2
a801 10
typedef int (CompileProc) _ANSI_ARGS_((Tcl_Interp *interp,
	Tcl_Parse *parsePtr, struct CompileEnv *compEnvPtr));

/*
 * The type of procedure called from the compilation hook point in
 * SetByteCodeFromAny.
 */

typedef int (CompileHookProc) _ANSI_ARGS_((Tcl_Interp *interp,
	struct CompileEnv *compEnvPtr, ClientData clientData));
d813 6
d820 1
a820 1
    Tcl_Obj **stackPtr;		/* Points to the first item in the
a827 87
 * The definitions for the LiteralTable and LiteralEntry structures. Each
 * interpreter contains a LiteralTable. It is used to reduce the storage
 * needed for all the Tcl objects that hold the literals of scripts compiled
 * by the interpreter. A literal's object is shared by all the ByteCodes
 * that refer to the literal. Each distinct literal has one LiteralEntry
 * entry in the LiteralTable. A literal table is a specialized hash table
 * that is indexed by the literal's string representation, which may contain
 * null characters.
 *
 * Note that we reduce the space needed for literals by sharing literal
 * objects both within a ByteCode (each ByteCode contains a local
 * LiteralTable) and across all an interpreter's ByteCodes (with the
 * interpreter's global LiteralTable).
 */

typedef struct LiteralEntry {
    struct LiteralEntry *nextPtr;	/* Points to next entry in this
					 * hash bucket or NULL if end of
					 * chain. */
    Tcl_Obj *objPtr;			/* Points to Tcl object that
					 * holds the literal's bytes and
					 * length. */
    int refCount;			/* If in an interpreter's global
					 * literal table, the number of
					 * ByteCode structures that share
					 * the literal object; the literal
					 * entry can be freed when refCount
					 * drops to 0. If in a local literal
					 * table, -1. */
} LiteralEntry;

typedef struct LiteralTable {
    LiteralEntry **buckets;		/* Pointer to bucket array. Each
					 * element points to first entry in
					 * bucket's hash chain, or NULL. */
    LiteralEntry *staticBuckets[TCL_SMALL_HASH_TABLE];
					/* Bucket array used for small
					 * tables to avoid mallocs and
					 * frees. */
    int numBuckets;			/* Total number of buckets allocated
					 * at **buckets. */
    int numEntries;			/* Total number of entries present
					 * in table. */
    int rebuildSize;			/* Enlarge table when numEntries
					 * gets to be this large. */
    int mask;				/* Mask value used in hashing
					 * function. */
} LiteralTable;

/*
 * The following structure defines for each Tcl interpreter various
 * statistics-related information about the bytecode compiler and
 * interpreter's operation in that interpreter.
 */

#ifdef TCL_COMPILE_STATS
typedef struct ByteCodeStats {
    long numExecutions;		  /* Number of ByteCodes executed. */
    long numCompilations;	  /* Number of ByteCodes created. */
    long numByteCodesFreed;	  /* Number of ByteCodes destroyed. */
    long instructionCount[256];	  /* Number of times each instruction was
				   * executed. */

    double totalSrcBytes;	  /* Total source bytes ever compiled. */
    double totalByteCodeBytes;	  /* Total bytes for all ByteCodes. */
    double currentSrcBytes;	  /* Src bytes for all current ByteCodes. */
    double currentByteCodeBytes;  /* Code bytes in all current ByteCodes. */

    long srcCount[32];		  /* Source size distribution: # of srcs of
				   * size [2**(n-1)..2**n), n in [0..32). */
    long byteCodeCount[32];	  /* ByteCode size distribution. */
    long lifetimeCount[32];	  /* ByteCode lifetime distribution (ms). */
    
    double currentInstBytes;	  /* Instruction bytes-current ByteCodes. */
    double currentLitBytes;	  /* Current literal bytes. */
    double currentExceptBytes;	  /* Current exception table bytes. */
    double currentAuxBytes;	  /* Current auxiliary information bytes. */
    double currentCmdMapBytes;	  /* Current src<->code map bytes. */
    
    long numLiteralsCreated;	  /* Total literal objects ever compiled. */
    double totalLitStringBytes;	  /* Total string bytes in all literals. */
    double currentLitStringBytes; /* String bytes in current literals. */
    long literalCount[32];	  /* Distribution of literal string sizes. */
} ByteCodeStats;
#endif /* TCL_COMPILE_STATS */

/*
d843 1
a843 1
				/* Points to the imported command created in
d862 1
a862 1
				 * refers to. */
d894 1
a894 1
				 * that point to this command when it is
d896 1
a896 1
    CompileProc *compileProc;	/* Procedure called to compile command. NULL
d965 1
a965 1
     * a Tcl_Interp struct (see tcl.h).	 If you change one, be sure to
d979 1
a979 1
    char *result;		/* If the last command returned a string
d982 7
a988 7
    Tcl_FreeProc *freeProc;	/* Zero means a string result is statically
				 * allocated. TCL_DYNAMIC means string
				 * result was allocated with ckalloc and
				 * should be freed with ckfree. Other values
				 * give address of procedure to invoke to
				 * free the string result. Tcl_Eval must
				 * free it before executing next command. */
d992 4
a995 19
    struct TclStubs *stubTable;
				/* Pointer to the exported Tcl stub table.
				 * On previous versions of Tcl this is a
				 * pointer to the objResultPtr or a pointer
				 * to a buckets array in a hash table. We
				 * therefore have to do some careful checking
				 * before we can use this. */

    TclHandle handle;		/* Handle used to keep track of when this
				 * interp is deleted. */

    Namespace *globalNsPtr;	/* The interpreter's global namespace. */
    Tcl_HashTable *hiddenCmdTablePtr;
				/* Hash table used by tclBasic.c to keep
				 * track of hidden commands on a per-interp
				 * basis. */
    ClientData interpInfo;	/* Information used by tclInterp.c to keep
				 * track of master/slave interps on
				 * a per-interp basis. */
d997 1
a997 1
				 * defined for the interpreter.	 Indexed by
a1000 2


d1008 1
a1008 1
				 * interpreter.	 It's used to delay deletion
d1034 1
a1034 1
     * results.	 See Tcl_AppendResult code for details.
d1038 1
a1038 1
				 * by Tcl_AppendResult.	 Malloc-ed.  NULL
d1046 17
a1086 6
    LiteralTable literalTable;	/* Contains LiteralEntry's describing all
				 * Tcl objects holding literals of scripts
				 * compiled by the interpreter. Indexed by
				 * the string representations of literals.
				 * Used to avoid creating duplicate
				 * objects. */
d1101 1
a1101 1
				 * Tcl_AddInterpResolvers and
d1112 2
a1113 2
				 * this interpreter. Cleaned up when
				 * this interpreter is deleted. */
d1115 1
a1115 1
				 * execution. Contains a pointer to the
a1122 14
    Tcl_Obj *objResultPtr;	/* If the last command returned an object
				 * result, this points to it. Should not be
				 * accessed directly; see comment above. */
    Tcl_ThreadId threadId;	/* ID of thread that owns the interpreter */

    /*
     * Statistical information about the bytecode compiler and interpreter's
     * operation.
     */

#ifdef TCL_COMPILE_STATS
    ByteCodeStats stats;	/* Holds compilation and execution
				 * statistics for this interpreter. */
#endif /* TCL_COMPILE_STATS */	  
d1131 1
a1131 1
 *			a code other than TCL_OK or TCL_ERROR;	0 means
d1154 1
a1154 1
 *			error.	Zero means Tcl_Eval must clear the
d1163 1
a1163 1
 *			interp has not be initialized.	This is set 1
d1165 13
a1177 18
 * SAFE_INTERP:		Non zero means that the current interp is a
 *			safe interp (ie it has only the safe commands
 *			installed, less priviledge than a regular interp).
 * USE_EVAL_DIRECT:	Non-zero means don't use the compiler or byte-code
 *			interpreter; instead, have Tcl_EvalObj call
 *			Tcl_EvalEx. Used primarily for testing the
 *			new parser.
 */

#define DELETED				    1
#define ERR_IN_PROGRESS			    2
#define ERR_ALREADY_LOGGED		    4
#define ERROR_CODE_SET			    8
#define EXPR_INITIALIZED		 0x10
#define DONT_COMPILE_CMDS_INLINE	 0x20
#define RAND_SEED_INITIALIZED		 0x40
#define SAFE_INTERP			 0x80
#define USE_EVAL_DIRECT			0x100
d1209 42
a1301 4
 * TCL_INVOKE_NO_TRACEBACK	Does not record traceback information if
 *				the invoked command returns an error.  Used
 *				if the caller plans on recording its own
 *				traceback information.
a1305 1
#define TCL_INVOKE_NO_TRACEBACK	(1<<2)
a1321 1

d1331 2
a1332 1
	int objIndex, CONST char *fileName, Tcl_Obj **attrObjPtrPtr));
d1334 2
a1335 1
	int objIndex, CONST char *fileName, Tcl_Obj *attrObjPtr));
d1338 1
a1338 1
    TclGetFileAttrProc *getProc;	/* The procedure for getting attrs. */
d1356 2
a1357 1
typedef int (TclStatProc_) _ANSI_ARGS_((CONST char *path, struct stat *buf));
a1368 41
 * Opaque names for platform specific types.
 */

typedef struct TclpTime_t_ *TclpTime_t;

/* 
 * The following structure is used to pass glob type data amongst
 * the various glob routines and TclpMatchFilesTypes.  Currently
 * most of the fields are ignored.  However they will be used in
 * a future release to implement glob's ability to find files
 * of particular types/permissions/etc only.
 */
typedef struct GlobTypeData {
    /* Corresponds to bcdpfls as in 'find -t' */
    int type;
    /* Corresponds to file permissions */
    int perm;
    /* Acceptable mac type */
    Tcl_Obj* macType;
    /* Acceptable mac creator */
    Tcl_Obj* macCreator;
} GlobTypeData;

/*
 * type and permission definitions for glob command
 */
#define TCL_GLOB_TYPE_BLOCK		(1<<0)
#define TCL_GLOB_TYPE_CHAR		(1<<1)
#define TCL_GLOB_TYPE_DIR		(1<<2)
#define TCL_GLOB_TYPE_PIPE		(1<<3)
#define TCL_GLOB_TYPE_FILE		(1<<4)
#define TCL_GLOB_TYPE_LINK		(1<<5)
#define TCL_GLOB_TYPE_SOCK		(1<<6)

#define TCL_GLOB_PERM_RONLY		(1<<0)
#define TCL_GLOB_PERM_HIDDEN		(1<<1)
#define TCL_GLOB_PERM_R			(1<<2)
#define TCL_GLOB_PERM_W			(1<<3)
#define TCL_GLOB_PERM_X			(1<<4)

/*
d1377 1
a1377 3
extern char *			tclNativeExecutableName;
extern char *			tclDefaultEncodingDir;
extern Tcl_ChannelType		tclFileChannelType;
d1381 1
a1381 1
extern CONST TclFileAttrProcs	tclpFileAttrProcs[];
a1387 1
extern Tcl_ObjType	tclByteArrayType;
d1403 2
a1404 2
extern long		tclObjsAlloced;
extern long		tclObjsFreed;
d1422 1
d1428 2
a1429 4
EXTERN int		TclArraySet _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_Obj *arrayNameObj, Tcl_Obj *arrayElemObj));
EXTERN int		TclCheckBadOctal _ANSI_ARGS_((Tcl_Interp *interp,
			    char *value));
d1431 1
a1431 1
			    int numPids, Tcl_Pid *pidPtr,
d1434 2
d1451 1
a1451 1
			    Interp *iPtr, CallFrame *framePtr));
d1456 1
a1456 1
			    char *tail, GlobTypeData *types));
d1458 2
a1459 2
EXTERN void		TclExpandTokenArray _ANSI_ARGS_((
			    Tcl_Parse *parsePtr));
d1466 1
a1466 1
EXTERN int		TclFileDeleteCmd _ANSI_ARGS_((Tcl_Interp *interp,
a1471 1
EXTERN void		TclFinalizeAllocSubsystem _ANSI_ARGS_((void));
a1472 2
EXTERN void		TclFinalizeCompilation _ANSI_ARGS_((void));
EXTERN void		TclFinalizeEncodingSubsystem _ANSI_ARGS_((void));
d1474 4
a1477 8
EXTERN void		TclFinalizeExecution _ANSI_ARGS_((void));
EXTERN void		TclFinalizeIOSubsystem _ANSI_ARGS_((void));
EXTERN void		TclFinalizeLoad _ANSI_ARGS_((void));
EXTERN void		TclFinalizeMemorySubsystem _ANSI_ARGS_((void));
EXTERN void		TclFinalizeNotifier _ANSI_ARGS_((void));
EXTERN void		TclFinalizeSynchronization _ANSI_ARGS_((void));
EXTERN void		TclFinalizeThreadData _ANSI_ARGS_((void));
EXTERN void		TclFindEncodings _ANSI_ARGS_((CONST char *argv0));
d1482 3
d1488 1
d1490 1
a1490 1
			    Tcl_Interp *interp, int localIndex,
d1492 1
d1513 1
a1513 1
			    char *string, int *seekFlagPtr));
d1516 2
a1517 3
EXTERN int		TclGlob _ANSI_ARGS_((Tcl_Interp *interp,
			    char *pattern, char *unquotedPrefix, 
			    int globFlags, GlobTypeData* types));
d1519 1
a1519 1
			    int argc, char **argv, int flags));
d1522 1
d1524 1
a1524 1
			    Tcl_Interp *interp));
d1527 1
a1527 1
			    Tcl_Interp *interp, int localIndex,
d1530 1
a1530 1
			    Tcl_Interp *interp, int localIndex,
d1534 1
a1534 2
			    long incrAmount, int flags));
EXTERN void		TclInitAlloc _ANSI_ARGS_((void));
d1538 2
a1539 7
EXTERN void		TclInitDbCkalloc _ANSI_ARGS_((void));
EXTERN void		TclInitEncodingSubsystem _ANSI_ARGS_((void));
EXTERN void		TclInitIOSubsystem _ANSI_ARGS_((void));
EXTERN void		TclInitNamespaceSubsystem _ANSI_ARGS_((void));
EXTERN void		TclInitNotifier _ANSI_ARGS_((void));
EXTERN void		TclInitObjSubsystem _ANSI_ARGS_((void));
EXTERN void		TclInitSubsystems _ANSI_ARGS_((CONST char *argv0));
d1541 1
a1541 1
			    int argc, char **argv, int flags));
d1543 2
a1544 2
			    ClientData clientData, Tcl_Interp *interp,
			    int argc, char **argv));
d1546 2
a1547 4
			    ClientData clientData, Tcl_Interp *interp,
			    int objc, Tcl_Obj *CONST objv[]));
EXTERN int		TclIsLocalScalar _ANSI_ARGS_((CONST char *src,
			    int len));
d1549 5
d1558 3
a1560 1
EXTERN int		TclMathInProgress _ANSI_ARGS_((void));
d1565 1
a1565 1
			    Tcl_Interp *interp, int objc,
d1568 1
a1568 1
			    int objc, Tcl_Obj *CONST objv[], int flags));
d1570 1
a1570 1
			    int objc, Tcl_Obj *CONST objv[], int flags));
a1574 2
EXTERN int		TclpAccess _ANSI_ARGS_((CONST char *filename,
			    int mode));
d1576 6
d1583 22
a1604 18
EXTERN int		TclpCopyFile _ANSI_ARGS_((CONST char *source,
			    CONST char *dest));
EXTERN int		TclpCopyDirectory _ANSI_ARGS_((CONST char *source,
			    CONST char *dest, Tcl_DString *errorPtr));
EXTERN int		TclpCreateDirectory _ANSI_ARGS_((CONST char *path));
EXTERN int		TclpDeleteFile _ANSI_ARGS_((CONST char *path));
EXTERN void		TclpExit _ANSI_ARGS_((int status));
EXTERN void		TclpFinalizeCondition _ANSI_ARGS_((
			    Tcl_Condition *condPtr));
EXTERN void		TclpFinalizeMutex _ANSI_ARGS_((Tcl_Mutex *mutexPtr));
EXTERN void		TclpFinalizeThreadData _ANSI_ARGS_((
			    Tcl_ThreadDataKey *keyPtr));
EXTERN void		TclpFinalizeThreadDataKey _ANSI_ARGS_((
			    Tcl_ThreadDataKey *keyPtr));
EXTERN char *		TclpFindExecutable _ANSI_ARGS_((
			    CONST char *argv0));
EXTERN int		TclpFindVariable _ANSI_ARGS_((CONST char *name,
			    int *lengthPtr));
a1606 1
EXTERN Tcl_Channel	TclpGetDefaultStdChannel _ANSI_ARGS_((int type));
d1610 1
a1610 7
EXTERN char *		TclpGetUserHome _ANSI_ARGS_((CONST char *name,
			    Tcl_DString *bufferPtr));
EXTERN int		TclpHasSockets _ANSI_ARGS_((Tcl_Interp *interp));
EXTERN void		TclpInitLibraryPath _ANSI_ARGS_((CONST char *argv0));
EXTERN void		TclpInitLock _ANSI_ARGS_((void));
EXTERN void		TclpInitPlatform _ANSI_ARGS_((void));
EXTERN void		TclpInitUnlock _ANSI_ARGS_((void));
d1612 3
a1614 5
EXTERN void		TclpMasterLock _ANSI_ARGS_((void));
EXTERN void		TclpMasterUnlock _ANSI_ARGS_((void));
EXTERN int		TclpMatchFiles _ANSI_ARGS_((Tcl_Interp *interp,
			    char *separators, Tcl_DString *dirPtr,
			    char *pattern, char *tail));
a1617 2
EXTERN char *		TclpReadlink _ANSI_ARGS_((CONST char *fileName,
			    Tcl_DString *linkPtr));
d1620 1
a1620 2
EXTERN void		TclpReleaseFile _ANSI_ARGS_((TclFile file));
EXTERN int		TclpRemoveDirectory _ANSI_ARGS_((CONST char *path,
d1622 9
a1630 7
EXTERN int		TclpRenameFile _ANSI_ARGS_((CONST char *source,
			    CONST char *dest));
EXTERN void		TclpSetInitialEncodings _ANSI_ARGS_((void));
EXTERN void		TclpSetVariables _ANSI_ARGS_((Tcl_Interp *interp));
EXTERN VOID *		TclpSysAlloc _ANSI_ARGS_((long size, int isBin));
EXTERN void		TclpSysFree _ANSI_ARGS_((VOID *ptr));
EXTERN VOID *		TclpSysRealloc _ANSI_ARGS_((VOID *cp,
d1632 11
a1642 1
EXTERN void		TclpUnloadFile _ANSI_ARGS_((ClientData clientData));
d1647 3
a1649 1
			    Tcl_Interp *cmdInterp, Tcl_Command cmd));
d1652 2
a1653 2
			    Proc *procPtr, Tcl_Obj *bodyPtr, Namespace *nsPtr,
			    CONST char *description, CONST char *procName));
d1656 1
a1656 11
			    Tcl_Interp *interp, int argc, char **argv));
EXTERN VOID *		TclpThreadDataKeyGet _ANSI_ARGS_((
			    Tcl_ThreadDataKey *keyPtr));
EXTERN void		TclpThreadDataKeyInit _ANSI_ARGS_((
			    Tcl_ThreadDataKey *keyPtr));
EXTERN void		TclpThreadDataKeySet _ANSI_ARGS_((
			    Tcl_ThreadDataKey *keyPtr, VOID *data));
EXTERN void		TclpThreadExit _ANSI_ARGS_((int status));
EXTERN void		TclRememberCondition _ANSI_ARGS_((Tcl_Condition *mutex));
EXTERN void		TclRememberDataKey _ANSI_ARGS_((Tcl_ThreadDataKey *mutex));
EXTERN void		TclRememberMutex _ANSI_ARGS_((Tcl_Mutex *mutex));
d1663 1
a1663 1
			    Tcl_Interp *interp, int localIndex,
d1672 1
a1672 1
			    char *string, char *proto, int *portPtr));
d1674 1
a1674 1
			    int size));
d1676 1
a1676 1
			    struct stat *buf));
d1680 5
a1684 2
EXTERN void		TclTransferResult _ANSI_ARGS_((Tcl_Interp *sourceInterp,
			    int result, Tcl_Interp *targetInterp));
d1686 2
d1703 2
a1704 2
EXTERN int	Tcl_BreakObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
d1717 2
a1718 4
EXTERN int	Tcl_ContinueObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_EncodingObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
d1725 2
a1726 2
EXTERN int	Tcl_ExecObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
d1733 2
a1734 2
EXTERN int	Tcl_FconfigureObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
d1739 2
a1740 2
EXTERN int	Tcl_FileEventObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
d1743 2
a1744 2
EXTERN int	Tcl_ForObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
d1753 6
a1758 6
EXTERN int	Tcl_GlobObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_IfObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_IncrObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
d1775 2
a1776 2
EXTERN int	Tcl_LoadObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
d1787 5
a1791 3
EXTERN int	Tcl_OpenObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_PackageObjCmd _ANSI_ARGS_((ClientData clientData,
d1793 1
a1793 1
EXTERN int	Tcl_PidObjCmd _ANSI_ARGS_((ClientData clientData,
d1797 2
a1798 2
EXTERN int	Tcl_PwdObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
d1801 4
a1804 4
EXTERN int	Tcl_RegexpObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_RegsubObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
d1809 6
a1814 6
EXTERN int	Tcl_ScanObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_SeekObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_SetObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
d1817 2
a1818 2
EXTERN int	Tcl_SocketObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
d1823 2
a1824 2
EXTERN int	Tcl_SubstObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
d1827 2
a1828 2
EXTERN int	Tcl_TellObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
d1831 2
a1832 2
EXTERN int	Tcl_TraceObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
d1835 2
a1836 2
EXTERN int	Tcl_UpdateObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
d1843 4
a1846 4
EXTERN int	Tcl_VwaitObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_WhileObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
d1855 1
a1855 1
EXTERN int	Tcl_EchoCmd _ANSI_ARGS_((ClientData clientData,
d1857 3
a1859 3
EXTERN int	Tcl_LsObjCmd _ANSI_ARGS_((ClientData clientData,
		    Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	Tcl_BeepObjCmd _ANSI_ARGS_((ClientData clientData,
d1861 1
a1861 1
EXTERN int	Tcl_MacSourceObjCmd _ANSI_ARGS_((ClientData clientData,
d1874 2
a1875 1
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
d1877 2
a1878 1
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
d1880 2
a1881 1
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
d1883 2
a1884 1
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
d1886 2
a1887 1
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
d1889 2
a1890 1
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
d1892 2
a1893 1
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
d1895 2
a1896 1
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
d1898 2
a1899 1
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
d1901 2
a1902 1
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
d1934 1
a1934 2
    (objPtr) = (Tcl_Obj *) \
	 Tcl_DbCkalloc(sizeof(Tcl_Obj), __FILE__, __LINE__); \
a1939 1
     
a1946 1
     
d1949 2
a1950 2
	if ((objPtr)->refCount < -1) \
	    panic("Reference count for %lx was negative: %s line %d", \
d1952 2
a1953 2
	if (((objPtr)->bytes != NULL) \
		&& ((objPtr)->bytes != tclEmptyStringRep)) { \
d1955 3
a1957 3
	} \
	if (((objPtr)->typePtr != NULL) \
		&& ((objPtr)->typePtr->freeIntRepProc != NULL)) { \
d1959 3
a1961 3
	} \
	ckfree((char *) (objPtr)); \
	TclIncrObjsFreed(); \
a1962 1

a1963 5

#ifdef TCL_THREADS
extern Tcl_Mutex tclObjMutex;
#endif

a1964 1
    Tcl_MutexLock(&tclObjMutex); \
d1975 1
a1975 3
    TclIncrObjsAllocated(); \
    Tcl_MutexUnlock(&tclObjMutex)

d1978 2
a1979 2
	if (((objPtr)->bytes != NULL) \
		&& ((objPtr)->bytes != tclEmptyStringRep)) { \
d1981 3
a1983 3
	} \
	if (((objPtr)->typePtr != NULL) \
		&& ((objPtr)->typePtr->freeIntRepProc != NULL)) { \
d1985 4
a1988 6
	} \
	Tcl_MutexLock(&tclObjMutex); \
	(objPtr)->internalRep.otherValuePtr = (VOID *) tclFreeObjList; \
	tclFreeObjList = (objPtr); \
	TclIncrObjsFreed(); \
	Tcl_MutexUnlock(&tclObjMutex); \
d2008 1
a2008 1
	(objPtr)->bytes	 = tclEmptyStringRep; \
d2013 1
a2013 1
		(unsigned) (len)); \
d2021 25
a2045 4
 * byte array pointer from a Tcl_Obj. This is an inline version
 * of Tcl_GetString(). The macro's expression result is the string
 * rep's byte pointer which might be NULL. The bytes referenced by 
 * this pointer must not be modified by the caller.
d2048 31
a2078 1
 * EXTERN char *  TclGetString _ANSI_ARGS_((Tcl_Obj *objPtr));
d2082 60
a2141 4
#define TclGetString(objPtr) \
    ((objPtr)->bytes? (objPtr)->bytes : Tcl_GetString((objPtr)))

#include "tclIntDecls.h"
a2146 1

@


1.1.1.3
log
@import tcl 8.4.0
@
text
@a9 1
 * Copyright (c) 2001, 2002 by Kevin B. Kenny.  All rights reserved.
d14 1
a14 1
 * RCS: @@(#) $Id: tclInt.h,v 1.111 2002/08/14 17:31:43 msofer Exp $
d30 2
a35 2
#include <stdio.h>

d93 1
a93 1
    Tcl_Interp* interp, CONST84 char* name, int length,
d97 1
a97 1
    Tcl_Interp* interp, CONST84 char* name, Tcl_Namespace *context,
d101 1
a101 1
    CONST84 char* name, Tcl_Namespace *context, int flags,
d187 5
a191 7
    int resolverEpoch;		 /* Incremented whenever (a) the name resolution
				  * rules change for this namespace or (b) a 
				  * newly added command shadows a command that
				  * is compiled to bytecodes.
				  * This invalidates all byte codes compiled
				  * in the namespace, causing the code to be
				  * recompiled under the new rules.*/
a272 37
 * The following structure defines a command trace, which is used to
 * invoke a specific C procedure whenever certain operations are performed
 * on a command.
 */

typedef struct CommandTrace {
    Tcl_CommandTraceProc *traceProc;/* Procedure to call when operations given
				     * by flags are performed on command. */
    ClientData clientData;	    /* Argument to pass to proc. */
    int flags;			    /* What events the trace procedure is
				     * interested in:  OR-ed combination of
				     * TCL_TRACE_RENAME, TCL_TRACE_DELETE. */
    struct CommandTrace *nextPtr;   /* Next in list of traces associated with
				     * a particular command. */
} CommandTrace;

/*
 * When a command trace is active (i.e. its associated procedure is
 * executing), one of the following structures is linked into a list
 * associated with the command's interpreter.  The information in
 * the structure is needed in order for Tcl to behave reasonably
 * if traces are deleted while traces are active.
 */

typedef struct ActiveCommandTrace {
    struct Command *cmdPtr;	/* Command that's being traced. */
    struct ActiveCommandTrace *nextPtr;
				/* Next in list of all active command
				 * traces for the interpreter, or NULL
				 * if no more. */
    CommandTrace *nextTracePtr;	/* Next trace to check after current
				 * trace procedure returns;  if this
				 * trace gets deleted, must update pointer
				 * to avoid using free'd memory. */
} ActiveCommandTrace;

/*
d617 1
a617 1
    Tcl_CmdObjTraceProc *proc;	/* Procedure to call to trace command. */
a619 4
    int flags;			/* Flags governing the trace - see
				 * Tcl_CreateObjTrace for details */
    Tcl_CmdObjTraceDeleteProc* delProc;
				/* Procedure to call when trace is deleted */
a622 19
 * When an interpreter trace is active (i.e. its associated procedure
 * is executing), one of the following structures is linked into a list
 * associated with the interpreter.  The information in the structure
 * is needed in order for Tcl to behave reasonably if traces are
 * deleted while traces are active.
 */

typedef struct ActiveInterpTrace {
    struct ActiveInterpTrace *nextPtr;
				/* Next in list of all active command
				 * traces for the interpreter, or NULL
				 * if no more. */
    Trace *nextTracePtr;	/* Next trace to check after current
				 * trace procedure returns;  if this
				 * trace gets deleted, must update pointer
				 * to avoid using free'd memory. */
} ActiveInterpTrace;

/*
d704 5
a854 2
    Tcl_Obj *errorInfo;
    Tcl_Obj *errorCode;
d1023 4
a1026 2
    int flags;			/* Miscellaneous bits of information about
				 * command. See below for definitions. */
a1033 2
    CommandTrace *tracePtr;	/* First in list of all traces set for this
				 * command. */
a1036 24
 * Flag bits for commands. 
 *
 * CMD_IS_DELETED -		Means that the command is in the process
 *                              of being deleted (its deleteProc is
 *                              currently executing). Other attempts to
 *                              delete the command should be ignored.
 * CMD_TRACE_ACTIVE -		1 means that trace processing is currently
 *				underway for a rename/delete change.
 *				See the two flags below for which is
 *				currently being processed.
 * CMD_HAS_EXEC_TRACES -	1 means that this command has at least
 *                              one execution trace (as opposed to simple
 *                              delete/rename traces) in its tracePtr list.
 * TCL_TRACE_RENAME -           A rename trace is in progress. Further
 *                              recursive renames will not be traced.
 * TCL_TRACE_DELETE -           A delete trace is in progress. Further 
 *                              recursive deletes will not be traced.
 * (these last two flags are defined in tcl.h)
 */
#define CMD_IS_DELETED		0x1
#define CMD_TRACE_ACTIVE	0x2
#define CMD_HAS_EXEC_TRACES	0x4

/*
d1137 1
a1137 1
     * and tclVar.c for usage.
d1156 1
a1156 1
    ActiveVarTrace *activeVarTracePtr;
d1226 1
a1226 1
    Tcl_Obj *scriptFile;	/* NULL means there is no nested source
d1228 3
a1230 1
				 * pathPtr of the file being sourced. */
a1250 10
    ActiveCommandTrace *activeCmdTracePtr;
				/* First in list of active command traces for
				 * interp, or NULL if no active traces. */
    ActiveInterpTrace *activeInterpTracePtr;
				/* First in list of active traces for
				 * interp, or NULL if no active traces. */

    int tracesForbiddingInline; /* Count of traces (in the list headed by
				 * tracePtr) that forbid inline bytecode
				 * compilation */
a1308 3
 * INTERP_TRACE_IN_PROGRESS: Non-zero means that an interp trace is currently
 *			active; so no further trace callbacks should be
 *			invoked.
a1319 1
#define INTERP_TRACE_IN_PROGRESS	0x200
d1382 1
a1382 1
 * The following enum values are used to specify the runtime platform
a1392 13
 *  The following enum values are used to indicate the translation
 *  of a Tcl channel.  Declared here so that each platform can define
 *  TCL_PLATFORM_TRANSLATION to the native translation on that platform
 */

typedef enum TclEolTranslation {
    TCL_TRANSLATE_AUTO,                 /* Eol == \r, \n and \r\n. */
    TCL_TRANSLATE_CR,                   /* Eol == \r. */
    TCL_TRANSLATE_LF,                   /* Eol == \n. */
    TCL_TRANSLATE_CRLF                  /* Eol == \r\n. */
} TclEolTranslation;

/*
d1437 1
a1437 1
	int objIndex, Tcl_Obj *fileName, Tcl_Obj **attrObjPtrPtr));
d1439 1
a1439 1
	int objIndex, Tcl_Obj *fileName, Tcl_Obj *attrObjPtr));
a1453 16
 * Opaque names for platform specific types.
 */

typedef struct TclpTime_t_    *TclpTime_t;

/*
 * The "globParameters" argument of the function TclGlob is an
 * or'ed combination of the following values:
 */

#define TCL_GLOBMODE_NO_COMPLAIN      1
#define TCL_GLOBMODE_JOIN             2
#define TCL_GLOBMODE_DIR              4
#define TCL_GLOBMODE_TAILS            8

/*
d1455 2
a1456 1
 * Data structures related to obsolete filesystem hooks
d1463 1
a1463 1
	CONST char *fileName, CONST char *modeString,
d1466 4
d1472 1
a1472 3
 *----------------------------------------------------------------
 * Data structures related to procedures
 *----------------------------------------------------------------
d1475 36
a1510 2
typedef Tcl_CmdProc *TclCmdProcType;
typedef Tcl_ObjCmdProc *TclObjCmdProcType;
d1526 2
a1536 1
extern Tcl_ObjType	tclEndOffsetType;
a1540 15
extern Tcl_ObjType	tclArraySearchType;
extern Tcl_ObjType	tclIndexType;
extern Tcl_ObjType	tclNsNameType;
#ifndef TCL_WIDE_INT_IS_LONG
extern Tcl_ObjType	tclWideIntType;
#endif

/*
 * Variables denoting the hash key types defined in the core.
 */

extern Tcl_HashKeyType tclArrayHashKeyType;
extern Tcl_HashKeyType tclOneWordHashKeyType;
extern Tcl_HashKeyType tclStringHashKeyType;
extern Tcl_HashKeyType tclObjHashKeyType;
a1551 2
#define TCL_MAX_SHARED_OBJ_STATS 5
extern long		tclObjsShared[TCL_MAX_SHARED_OBJ_STATS];
a1560 1
extern char		tclEmptyString;
d1569 5
d1577 27
a1603 1
			    CONST char *value));
d1606 2
d1611 1
a1611 1
			    int objc, Tcl_Obj *CONST objv[])) ;
d1613 1
a1613 1
			    int objc, Tcl_Obj *CONST objv[]));
d1615 1
a1615 1
			    int objc, Tcl_Obj *CONST objv[])) ;
d1617 1
a1617 1
			    int objc, Tcl_Obj *CONST objv[])) ;
a1624 1
EXTERN void		TclFinalizeFilesystem _ANSI_ARGS_((void));
a1627 1
EXTERN void		TclFinalizeAsync _ANSI_ARGS_((void));
d1631 33
d1665 18
a1682 2
			    char *pattern, Tcl_Obj *unquotedPrefix, 
			    int globFlags, Tcl_GlobTypeData* types));
d1684 3
d1694 8
d1704 21
a1724 30
EXTERN int              TclJoinThread _ANSI_ARGS_((Tcl_ThreadId id,
			    int* result));
EXTERN Tcl_Obj *	TclLindexList _ANSI_ARGS_((Tcl_Interp* interp,
						   Tcl_Obj* listPtr,
						   Tcl_Obj* argPtr ));
EXTERN Tcl_Obj *	TclLindexFlat _ANSI_ARGS_((Tcl_Interp* interp,
						   Tcl_Obj* listPtr,
						   int indexCount,
						   Tcl_Obj *CONST indexArray[]
						   ));
EXTERN Tcl_Obj *	TclLsetList _ANSI_ARGS_((Tcl_Interp* interp,
						 Tcl_Obj* listPtr,
						 Tcl_Obj* indexPtr,
						 Tcl_Obj* valuePtr  
						 ));
EXTERN Tcl_Obj *	TclLsetFlat _ANSI_ARGS_((Tcl_Interp* interp,
						 Tcl_Obj* listPtr,
						 int indexCount,
						 Tcl_Obj *CONST indexArray[],
						 Tcl_Obj* valuePtr
						 ));
EXTERN int              TclParseBackslash _ANSI_ARGS_((CONST char *src,
                            int numBytes, int *readPtr, char *dst));
EXTERN int		TclParseHex _ANSI_ARGS_((CONST char *src, int numBytes,
                            Tcl_UniChar *resultPtr));
EXTERN int		TclParseInteger _ANSI_ARGS_((CONST char *string,
			    int numBytes));
EXTERN int		TclParseWhiteSpace _ANSI_ARGS_((CONST char *src,
			    int numBytes, Tcl_Parse *parsePtr, char *typePtr));
EXTERN int		TclpObjAccess _ANSI_ARGS_((Tcl_Obj *filename,
d1726 1
a1726 2
EXTERN int              TclpObjLstat _ANSI_ARGS_((Tcl_Obj *pathPtr, 
			    Tcl_StatBuf *buf));
d1728 7
a1734 1
EXTERN Tcl_Obj*         TclpTempFileName _ANSI_ARGS_((void));
d1746 9
d1759 1
a1759 8
EXTERN int              TclpLoadFile _ANSI_ARGS_((Tcl_Interp *interp, 
				Tcl_Obj *pathPtr,
				CONST char *sym1, CONST char *sym2, 
				Tcl_PackageInitProc **proc1Ptr,
				Tcl_PackageInitProc **proc2Ptr, 
				ClientData *clientDataPtr,
				Tcl_FSUnloadFileProc **unloadProcPtr));
EXTERN Tcl_Obj*		TclpObjListVolumes _ANSI_ARGS_((void));
a1764 30
EXTERN int              TclpObjNormalizePath _ANSI_ARGS_((Tcl_Interp *interp, 
			    Tcl_Obj *pathPtr, int nextCheckpoint));
EXTERN int		TclpObjCreateDirectory _ANSI_ARGS_((Tcl_Obj *pathPtr));
EXTERN void             TclpNativeJoinPath _ANSI_ARGS_((Tcl_Obj *prefix, 
							char *joining));
EXTERN Tcl_Obj*         TclpNativeSplitPath _ANSI_ARGS_((Tcl_Obj *pathPtr, 
							 int *lenPtr));
EXTERN Tcl_PathType     TclpGetNativePathType _ANSI_ARGS_((Tcl_Obj *pathObjPtr,
			    int *driveNameLengthPtr, Tcl_Obj **driveNameRef));
EXTERN int 		TclCrossFilesystemCopy _ANSI_ARGS_((Tcl_Interp *interp, 
			    Tcl_Obj *source, Tcl_Obj *target));
EXTERN int		TclpObjDeleteFile _ANSI_ARGS_((Tcl_Obj *pathPtr));
EXTERN int		TclpObjCopyDirectory _ANSI_ARGS_((Tcl_Obj *srcPathPtr, 
				Tcl_Obj *destPathPtr, Tcl_Obj **errorPtr));
EXTERN int		TclpObjCopyFile _ANSI_ARGS_((Tcl_Obj *srcPathPtr, 
				Tcl_Obj *destPathPtr));
EXTERN int		TclpObjRemoveDirectory _ANSI_ARGS_((Tcl_Obj *pathPtr, 
				int recursive, Tcl_Obj **errorPtr));
EXTERN int		TclpObjRenameFile _ANSI_ARGS_((Tcl_Obj *srcPathPtr, 
				Tcl_Obj *destPathPtr));
EXTERN int		TclpMatchInDirectory _ANSI_ARGS_((Tcl_Interp *interp, 
			        Tcl_Obj *resultPtr, Tcl_Obj *pathPtr, 
				CONST char *pattern, Tcl_GlobTypeData *types));
EXTERN Tcl_Obj*		TclpObjGetCwd _ANSI_ARGS_((Tcl_Interp *interp));
EXTERN Tcl_Obj*		TclpObjLink _ANSI_ARGS_((Tcl_Obj *pathPtr, 
				Tcl_Obj *toPtr, int linkType));
EXTERN int		TclpObjChdir _ANSI_ARGS_((Tcl_Obj *pathPtr));
EXTERN Tcl_Obj*         TclFileDirname _ANSI_ARGS_((Tcl_Interp *interp, 
						    Tcl_Obj*pathPtr));
EXTERN int		TclpObjStat _ANSI_ARGS_((Tcl_Obj *pathPtr, Tcl_StatBuf *buf));
d1766 1
a1766 1
			    Tcl_Obj *pathPtr, int mode,
a1767 2
EXTERN void		TclpPanic _ANSI_ARGS_(TCL_VARARGS(CONST char *,
			    format));
d1770 2
d1773 5
d1779 17
a1795 1
EXTERN void		TclpUnloadFile _ANSI_ARGS_((Tcl_LoadHandle loadHandle));
a1804 1
EXTERN VOID             TclRememberJoinableThread _ANSI_ARGS_((Tcl_ThreadId id));
d1806 23
a1828 2
EXTERN VOID             TclSignalExitThread _ANSI_ARGS_((Tcl_ThreadId id,
			     int result));
d1831 1
a1831 10
EXTERN Tcl_Obj*         TclpNativeToNormalized 
                            _ANSI_ARGS_((ClientData clientData));
EXTERN Tcl_Obj*	        TclpFilesystemPathType
					_ANSI_ARGS_((Tcl_Obj* pathObjPtr));
EXTERN Tcl_PackageInitProc* TclpFindSymbol _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_LoadHandle loadHandle, CONST char *symbol));
EXTERN int              TclpDlopen _ANSI_ARGS_((Tcl_Interp *interp, 
			    Tcl_Obj *pathPtr, 
	                    Tcl_LoadHandle *loadHandle, 
		            Tcl_FSUnloadFileProc **unloadProcPtr));
a1928 2
EXTERN int	Tcl_LsetObjCmd _ANSI_ARGS_((ClientData clientData,
                    Tcl_Interp* interp, int objc, Tcl_Obj *CONST objv[]));
d2000 1
a2000 1
		    Tcl_Interp *interp, int argc, CONST84 char **argv));
a2016 2
EXTERN int	TclCompileAppendCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
a2032 14
EXTERN int	TclCompileLappendCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
EXTERN int	TclCompileLindexCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
EXTERN int	TclCompileListCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
EXTERN int	TclCompileLlengthCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
EXTERN int	TclCompileLsetCmd _ANSI_ARGS_((Tcl_Interp* interp,
		    Tcl_Parse* parsePtr, struct CompileEnv* envPtr));
EXTERN int	TclCompileRegexpCmd _ANSI_ARGS_((Tcl_Interp* interp,
		    Tcl_Parse* parsePtr, struct CompileEnv* envPtr));
EXTERN int	TclCompileReturnCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
a2034 2
EXTERN int	TclCompileStringCmd _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Parse *parsePtr, struct CompileEnv *envPtr));
a2038 24
 * Functions defined in generic/tclVar.c and currenttly exported only 
 * for use by the bytecode compiler and engine. Some of these could later 
 * be placed in the public interface.
 */

EXTERN Var *	TclLookupArrayElement _ANSI_ARGS_((Tcl_Interp *interp,
		    CONST char *arrayName, CONST char *elName, CONST int flags,
		    CONST char *msg, CONST int createPart1,
		    CONST int createPart2, Var *arrayPtr));	
EXTERN Var *    TclObjLookupVar _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Obj *part1Ptr, CONST char *part2, int flags,
		    CONST char *msg, CONST int createPart1,
		    CONST int createPart2, Var **arrayPtrPtr));
EXTERN Tcl_Obj *TclPtrGetVar _ANSI_ARGS_((Tcl_Interp *interp, Var *varPtr,
		    Var *arrayPtr, CONST char *part1, CONST char *part2,
		    CONST int flags));
EXTERN Tcl_Obj *TclPtrSetVar _ANSI_ARGS_((Tcl_Interp *interp, Var *varPtr,
		    Var *arrayPtr, CONST char *part1, CONST char *part2,
		    Tcl_Obj *newValuePtr, CONST int flags));
EXTERN Tcl_Obj *TclPtrIncrVar _ANSI_ARGS_((Tcl_Interp *interp, Var *varPtr,
		    Var *arrayPtr, CONST char *part1, CONST char *part2,
		    CONST long i, CONST int flags));

/*
a2052 4
 *
 * These macros are defined in terms of two macros that depend on 
 * memory allocator in use: TclAllocObjStorage, TclFreeObjStorage.
 * They are defined below.
d2066 12
a2077 3
#define TclNewObj(objPtr) \
    TclAllocObjStorage(objPtr); \
    TclIncrObjsAllocated(); \
d2081 4
a2084 3
    (objPtr)->typePtr  = NULL

#define TclDecrRefCount(objPtr) \
d2086 7
d2097 1
a2097 5
	if (((objPtr)->bytes != NULL) \
		&& ((objPtr)->bytes != tclEmptyStringRep)) { \
	    ckfree((char *) (objPtr)->bytes); \
	} \
        TclFreeObjStorage(objPtr); \
a2100 51
#ifdef TCL_MEM_DEBUG
#  define TclAllocObjStorage(objPtr) \
       (objPtr) = (Tcl_Obj *) \
           Tcl_DbCkalloc(sizeof(Tcl_Obj), __FILE__, __LINE__)

#  define TclFreeObjStorage(objPtr) \
       if ((objPtr)->refCount < -1) { \
           panic("Reference count for %lx was negative: %s line %d", \
	           (objPtr), __FILE__, __LINE__); \
       } \
       ckfree((char *) (objPtr))
     
#  define TclDbNewObj(objPtr, file, line) \
       (objPtr) = (Tcl_Obj *) Tcl_DbCkalloc(sizeof(Tcl_Obj), (file), (line)); \
       (objPtr)->refCount = 0; \
       (objPtr)->bytes    = tclEmptyStringRep; \
       (objPtr)->length   = 0; \
       (objPtr)->typePtr  = NULL; \
       TclIncrObjsAllocated()
     
#elif defined(PURIFY)

/*
 * The PURIFY mode is like the regular mode, but instead of doing block
 * Tcl_Obj allocation and keeping a freed list for efficiency, it always
 * allocates and frees a single Tcl_Obj so that tools like Purify can
 * better track memory leaks
 */

#  define TclAllocObjStorage(objPtr) \
       (objPtr) = (Tcl_Obj *) Tcl_Ckalloc(sizeof(Tcl_Obj))

#  define TclFreeObjStorage(objPtr) \
       ckfree((char *) (objPtr))

#elif defined(TCL_THREADS) && defined(USE_THREAD_ALLOC)

/*
 * The TCL_THREADS mode is like the regular mode but allocates Tcl_Obj's
 * from per-thread caches.
 */

EXTERN Tcl_Obj *TclThreadAllocObj _ANSI_ARGS_((void));
EXTERN void TclThreadFreeObj _ANSI_ARGS_((Tcl_Obj *));

#  define TclAllocObjStorage(objPtr) \
       (objPtr) = TclThreadAllocObj()

#  define TclFreeObjStorage(objPtr) \
       TclThreadFreeObj((objPtr))

a2103 1
/* declared in tclObj.c */
d2107 14
a2120 15
#  define TclAllocObjStorage(objPtr) \
       Tcl_MutexLock(&tclObjMutex); \
       if (tclFreeObjList == NULL) { \
	   TclAllocateFreeObjects(); \
       } \
       (objPtr) = tclFreeObjList; \
       tclFreeObjList = (Tcl_Obj *) \
	   tclFreeObjList->internalRep.otherValuePtr; \
       Tcl_MutexUnlock(&tclObjMutex)

#  define TclFreeObjStorage(objPtr) \
       Tcl_MutexLock(&tclObjMutex); \
       (objPtr)->internalRep.otherValuePtr = (VOID *) tclFreeObjList; \
       tclFreeObjList = (objPtr); \
       Tcl_MutexUnlock(&tclObjMutex)
d2122 16
a2181 17
/*
 *----------------------------------------------------------------
 * Macro used by the Tcl core to compare Unicode strings.  On
 * big-endian systems we can use the more efficient memcmp, but
 * this would not be lexically correct on little-endian systems.
 * The ANSI C "prototype" for this macro is:
 *
 * EXTERN int TclUniCharNcmp _ANSI_ARGS_((CONST Tcl_UniChar *cs,
 *         CONST Tcl_UniChar *ct, unsigned long n));
 *----------------------------------------------------------------
 */
#ifdef WORDS_BIGENDIAN
#   define TclUniCharNcmp(cs,ct,n) memcmp((cs),(ct),(n)*sizeof(Tcl_UniChar))
#else /* !WORDS_BIGENDIAN */
#   define TclUniCharNcmp Tcl_UniCharNcmp
#endif /* WORDS_BIGENDIAN */

d2188 1
@


