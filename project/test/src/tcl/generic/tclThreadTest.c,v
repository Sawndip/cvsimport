head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.60
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.58
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.56
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.54
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.52
	gdb_7_0-branch:1.5.0.50
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tcl8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.48
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.46
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.44
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.42
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.40
	gdb_6_5-2006-05-14-branchpoint:1.5
	readline_5_1-import-branch:1.5.0.38
	readline_5_1-import-branchpoint:1.5
	gdb_6_4-branch:1.5.0.36
	gdb_6_4-2005-11-01-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.34
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	ezannoni_pie-20040323-branch:1.5.0.32
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.30
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.28
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.26
	gdb_5_1-2001-07-29-branch:1.5.0.24
	cagney_x86i386-20030821-branch:1.5.0.22
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.20
	gdb_6_0-2003-06-23-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.18
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.16
	cagney_writestrings-20030508-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.14
	cagney_fileio-20030521-branchpoint:1.5
	carlton_dictionary-20030430-merge:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.12
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.10
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.8
	cagney_lazyid-20030317-branchpoint:1.5
	offbyone-20030313-branch:1.5.0.6
	offbyone-20030313-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.4
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.2
	interps-20030202-branchpoint:1.5
	TCL8_4_1:1.1.1.2
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.2
	TCL_8_4_1:1.1.1.2
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.4
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TCL_8_4_0:1.1.1.2
	carlton_dictionary-branch:1.2.0.16
	carlton_dictionary-20020920-branchpoint:1.2
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.14
	gdb_5_3-branch:1.2.0.12
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.10
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.8
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.6
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	cygnus_cvs_20020108_pre:1.2
	TCL_8_3:1.1.1.1
	NET:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.5
date	2003.01.21.19.40.06;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.26.19.47.53;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.37.03;	author kseitz;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2001.09.09.23.56.06;	author irox;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	2001.09.09.22.40.56;	author irox;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2002.09.27.21.49.05;	author kseitz;	state Exp;
branches;
next	;

1.3.4.1
date	2003.12.14.20.28.44;	author drow;	state Exp;
branches;
next	;

1.2.16.1
date	2002.12.23.19.40.25;	author carlton;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2003.02.07.19.18.14;	author carlton;	state Exp;
branches;
next	;

1.1.1.1
date	2001.09.09.22.40.56;	author irox;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.24.19.56.09;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tcl 8.4.1
@
text
@/* 
 * tclThreadTest.c --
 *
 *	This file implements the testthread command.  Eventually this
 *	should be tclThreadCmd.c
 *	Some of this code is based on work done by Richard Hipp on behalf of
 *	Conservation Through Innovation, Limited, with their permission.
 *
 * Copyright (c) 1998 by Sun Microsystems, Inc.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tclThreadTest.c,v 1.16 2002/01/26 01:10:08 dgp Exp $
 */

#include "tclInt.h"

#ifdef TCL_THREADS
/*
 * Each thread has an single instance of the following structure.  There
 * is one instance of this structure per thread even if that thread contains
 * multiple interpreters.  The interpreter identified by this structure is
 * the main interpreter for the thread.  
 *
 * The main interpreter is the one that will process any messages 
 * received by a thread.  Any thread can send messages but only the
 * main interpreter can receive them.
 */

typedef struct ThreadSpecificData {
    Tcl_ThreadId  threadId;          /* Tcl ID for this thread */
    Tcl_Interp *interp;              /* Main interpreter for this thread */
    int flags;                       /* See the TP_ defines below... */
    struct ThreadSpecificData *nextPtr;	/* List for "thread names" */
    struct ThreadSpecificData *prevPtr;	/* List for "thread names" */
} ThreadSpecificData;
static Tcl_ThreadDataKey dataKey;

/*
 * This list is used to list all threads that have interpreters.
 * This is protected by threadMutex.
 */

static struct ThreadSpecificData *threadList;

/*
 * The following bit-values are legal for the "flags" field of the
 * ThreadSpecificData structure.
 */
#define TP_Dying               0x001 /* This thread is being cancelled */

/*
 * An instance of the following structure contains all information that is
 * passed into a new thread when the thread is created using either the
 * "thread create" Tcl command or the TclCreateThread() C function.
 */

typedef struct ThreadCtrl {
    char *script;    /* The TCL command this thread should execute */
    int flags;        /* Initial value of the "flags" field in the 
                       * ThreadSpecificData structure for the new thread.
                       * Might contain TP_Detached or TP_TclThread. */
    Tcl_Condition condWait;
    /* This condition variable is used to synchronize
     * the parent and child threads.  The child won't run
     * until it acquires threadMutex, and the parent function
     * won't complete until signaled on this condition
     * variable. */
} ThreadCtrl;

/*
 * This is the event used to send scripts to other threads.
 */

typedef struct ThreadEvent {
    Tcl_Event event;		/* Must be first */
    char *script;		/* The script to execute. */
    struct ThreadEventResult *resultPtr;
				/* To communicate the result.  This is
				 * NULL if we don't care about it. */
} ThreadEvent;

typedef struct ThreadEventResult {
    Tcl_Condition done;		/* Signaled when the script completes */
    int code;			/* Return value of Tcl_Eval */
    char *result;		/* Result from the script */
    char *errorInfo;		/* Copy of errorInfo variable */
    char *errorCode;		/* Copy of errorCode variable */
    Tcl_ThreadId srcThreadId;	/* Id of sending thread, in case it dies */
    Tcl_ThreadId dstThreadId;	/* Id of target thread, in case it dies */
    struct ThreadEvent *eventPtr;	/* Back pointer */
    struct ThreadEventResult *nextPtr;	/* List for cleanup */
    struct ThreadEventResult *prevPtr;

} ThreadEventResult;

static ThreadEventResult *resultList;

/*
 * This is for simple error handling when a thread script exits badly.
 */

static Tcl_ThreadId errorThreadId;
static char *errorProcString;

/* 
 * Access to the list of threads and to the thread send results is
 * guarded by this mutex. 
 */

TCL_DECLARE_MUTEX(threadMutex)

#undef TCL_STORAGE_CLASS
#define TCL_STORAGE_CLASS DLLEXPORT

EXTERN int	TclThread_Init _ANSI_ARGS_((Tcl_Interp *interp));
EXTERN int	Tcl_ThreadObjCmd _ANSI_ARGS_((ClientData clientData,
	Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[]));
EXTERN int	TclCreateThread _ANSI_ARGS_((Tcl_Interp *interp,
	char *script, int joinable));
EXTERN int	TclThreadList _ANSI_ARGS_((Tcl_Interp *interp));
EXTERN int	TclThreadSend _ANSI_ARGS_((Tcl_Interp *interp, Tcl_ThreadId id,
	char *script, int wait));

#undef TCL_STORAGE_CLASS
#define TCL_STORAGE_CLASS DLLIMPORT

Tcl_ThreadCreateType	NewTestThread _ANSI_ARGS_((ClientData clientData));
static void	ListRemove _ANSI_ARGS_((ThreadSpecificData *tsdPtr));
static void	ListUpdateInner _ANSI_ARGS_((ThreadSpecificData *tsdPtr));
static int	ThreadEventProc _ANSI_ARGS_((Tcl_Event *evPtr, int mask));
static void	ThreadErrorProc _ANSI_ARGS_((Tcl_Interp *interp));
static void	ThreadFreeProc _ANSI_ARGS_((ClientData clientData));
static int	ThreadDeleteEvent _ANSI_ARGS_((Tcl_Event *eventPtr,
	ClientData clientData));
static void	ThreadExitProc _ANSI_ARGS_((ClientData clientData));


/*
 *----------------------------------------------------------------------
 *
 * TclThread_Init --
 *
 *	Initialize the test thread command.
 *
 * Results:
 *      TCL_OK if the package was properly initialized.
 *
 * Side effects:
 *	Add the "testthread" command to the interp.
 *
 *----------------------------------------------------------------------
 */

int
TclThread_Init(interp)
    Tcl_Interp *interp; /* The current Tcl interpreter */
{
    
    Tcl_CreateObjCommand(interp,"testthread", Tcl_ThreadObjCmd, 
	    (ClientData)NULL ,NULL);
    if (Tcl_PkgProvide(interp, "Thread", "1.0" ) != TCL_OK) {
	return TCL_ERROR;
    }
    return TCL_OK;
}


/*
 *----------------------------------------------------------------------
 *
 * Tcl_ThreadObjCmd --
 *
 *	This procedure is invoked to process the "testthread" Tcl command.
 *	See the user documentation for details on what it does.
 *
 *	thread create ?-joinable? ?script?
 *	thread send id ?-async? script
 *	thread exit
 *	thread info id
 *	thread names
 *	thread wait
 *	thread errorproc proc
 *	thread join id
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
int
Tcl_ThreadObjCmd(dummy, interp, objc, objv)
    ClientData dummy;			/* Not used. */
    Tcl_Interp *interp;			/* Current interpreter. */
    int objc;				/* Number of arguments. */
    Tcl_Obj *CONST objv[];		/* Argument objects. */
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    int option;
    static CONST char *threadOptions[] = {"create", "exit", "id", "join", "names",
				    "send", "wait", "errorproc",
				    (char *) NULL};
    enum options {THREAD_CREATE, THREAD_EXIT, THREAD_ID, THREAD_JOIN,
		  THREAD_NAMES, THREAD_SEND, THREAD_WAIT, THREAD_ERRORPROC};

    if (objc < 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "option ?args?");
	return TCL_ERROR;
    }
    if (Tcl_GetIndexFromObj(interp, objv[1], threadOptions,
	    "option", 0, &option) != TCL_OK) {
	return TCL_ERROR;
    }

    /* 
     * Make sure the initial thread is on the list before doing anything.
     */

    if (tsdPtr->interp == NULL) {
	Tcl_MutexLock(&threadMutex);
	tsdPtr->interp = interp;
	ListUpdateInner(tsdPtr);
	Tcl_CreateThreadExitHandler(ThreadExitProc, NULL);
	Tcl_MutexUnlock(&threadMutex);
    }

    switch ((enum options)option) {
	case THREAD_CREATE: {
	    char *script;
	    int   joinable, len;

	    if (objc == 2) {
	        /* Neither joinable nor special script
		 */

	        joinable = 0;
		script   = "testthread wait";	/* Just enter the event loop */

	    } else if (objc == 3) {
	        /* Possibly -joinable, then no special script,
		 * no joinable, then its a script.
		 */

	        script = Tcl_GetString(objv[2]);
		len    = strlen (script);

		if ((len > 1) &&
		    (script [0] == '-') && (script [1] == 'j') &&
		    (0 == strncmp (script, "-joinable", (size_t) len))) {
		    joinable = 1;
		    script   = "testthread wait"; /* Just enter the event loop
						   */
		} else {
		    /* Remember the script */
		    joinable = 0;
		}
	    } else if (objc == 4) {
	        /* Definitely a script available, but is the flag
		 * -joinable ?
		 */

	        script = Tcl_GetString(objv[2]);
		len    = strlen (script);

		joinable = ((len > 1) &&
			    (script [0] == '-') && (script [1] == 'j') &&
			    (0 == strncmp (script, "-joinable", (size_t) len)));

		script = Tcl_GetString(objv[3]);
	    } else {
		Tcl_WrongNumArgs(interp, 2, objv, "?-joinable? ?script?");
		return TCL_ERROR;
	    }
	    return TclCreateThread(interp, script, joinable);
	}
	case THREAD_EXIT: {
	    if (objc > 2) {
		Tcl_WrongNumArgs(interp, 1, objv, NULL);
		return TCL_ERROR;
	    }
	    ListRemove(NULL);
	    Tcl_ExitThread(0);
	    return TCL_OK;
	}
	case THREAD_ID:
	    if (objc == 2) {
		Tcl_Obj *idObj = Tcl_NewLongObj((long)Tcl_GetCurrentThread());
		Tcl_SetObjResult(interp, idObj);
		return TCL_OK;
	    } else {
		Tcl_WrongNumArgs(interp, 2, objv, NULL);
		return TCL_ERROR;
	    }
        case THREAD_JOIN: {
	    long id;
	    int result, status;

	    if (objc != 3) {
		Tcl_WrongNumArgs(interp, 1, objv, "join id");
		return TCL_ERROR;
	    }
	    if (Tcl_GetLongFromObj(interp, objv[2], &id) != TCL_OK) {
		return TCL_ERROR;
	    }

	    result = Tcl_JoinThread ((Tcl_ThreadId) id, &status);
	    if (result == TCL_OK) {
	        Tcl_SetIntObj (Tcl_GetObjResult (interp), status);
	    } else {
	        char buf [20];
		sprintf (buf, "%ld", id);
		Tcl_AppendResult (interp, "cannot join thread ", buf, NULL);
	    }
	    return result;
	}
	case THREAD_NAMES: {
	    if (objc > 2) {
		Tcl_WrongNumArgs(interp, 2, objv, NULL);
		return TCL_ERROR;
	    }
	    return TclThreadList(interp);
	}
	case THREAD_SEND: {
	    long id;
	    char *script;
	    int wait, arg;

	    if ((objc != 4) && (objc != 5)) {
		Tcl_WrongNumArgs(interp, 1, objv, "send ?-async? id script");
		return TCL_ERROR;
	    }
	    if (objc == 5) {
		if (strcmp("-async", Tcl_GetString(objv[2])) != 0) {
		    Tcl_WrongNumArgs(interp, 1, objv, "send ?-async? id script");
		    return TCL_ERROR;
		}
		wait = 0;
		arg = 3;
	    } else {
		wait = 1;
		arg = 2;
	    }
	    if (Tcl_GetLongFromObj(interp, objv[arg], &id) != TCL_OK) {
		return TCL_ERROR;
	    }
	    arg++;
	    script = Tcl_GetString(objv[arg]);
	    return TclThreadSend(interp, (Tcl_ThreadId) id, script, wait);
	}
	case THREAD_WAIT: {
	    while (1) {
		(void) Tcl_DoOneEvent(TCL_ALL_EVENTS);
	    }
	}
	case THREAD_ERRORPROC: {
	    /*
	     * Arrange for this proc to handle thread death errors.
	     */

	    char *proc;
	    if (objc != 3) {
		Tcl_WrongNumArgs(interp, 1, objv, "errorproc proc");
		return TCL_ERROR;
	    }
	    Tcl_MutexLock(&threadMutex);
	    errorThreadId = Tcl_GetCurrentThread();
	    if (errorProcString) {
		ckfree(errorProcString);
	    }
	    proc = Tcl_GetString(objv[2]);
	    errorProcString = ckalloc(strlen(proc)+1);
	    strcpy(errorProcString, proc);
	    Tcl_MutexUnlock(&threadMutex);
	    return TCL_OK;
	}
    }
    return TCL_OK;
}


/*
 *----------------------------------------------------------------------
 *
 * TclCreateThread --
 *
 *	This procedure is invoked to create a thread containing an interp to
 *	run a script.  This returns after the thread has started executing.
 *
 * Results:
 *	A standard Tcl result, which is the thread ID.
 *
 * Side effects:
 *	Create a thread.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
int
TclCreateThread(interp, script, joinable)
    Tcl_Interp *interp;			/* Current interpreter. */
    char *script;			/* Script to execute */
    int         joinable;		/* Flag, joinable thread or not */
{
    ThreadCtrl ctrl;
    Tcl_ThreadId id;

    ctrl.script = script;
    ctrl.condWait = NULL;
    ctrl.flags = 0;

    joinable = joinable ? TCL_THREAD_JOINABLE : TCL_THREAD_NOFLAGS;

    Tcl_MutexLock(&threadMutex);
    if (Tcl_CreateThread(&id, NewTestThread, (ClientData) &ctrl,
		 TCL_THREAD_STACK_DEFAULT, joinable) != TCL_OK) {
	Tcl_MutexUnlock(&threadMutex);
        Tcl_AppendResult(interp,"can't create a new thread",0);
	ckfree((void*)ctrl.script);
	return TCL_ERROR;
    }

    /*
     * Wait for the thread to start because it is using something on our stack!
     */

    Tcl_ConditionWait(&ctrl.condWait, &threadMutex, NULL);
    Tcl_MutexUnlock(&threadMutex);
    Tcl_ConditionFinalize(&ctrl.condWait);
    Tcl_SetObjResult(interp, Tcl_NewLongObj((long)id));
    return TCL_OK;
}

/*
 *------------------------------------------------------------------------
 *
 * NewTestThread --
 *
 *    This routine is the "main()" for a new thread whose task is to
 *    execute a single TCL script.  The argument to this function is
 *    a pointer to a structure that contains the text of the TCL script
 *    to be executed.
 *
 *    Space to hold the script field of the ThreadControl structure passed 
 *    in as the only argument was obtained from malloc() and must be freed 
 *    by this function before it exits.  Space to hold the ThreadControl
 *    structure itself is released by the calling function, and the
 *    two condition variables in the ThreadControl structure are destroyed
 *    by the calling function.  The calling function will destroy the
 *    ThreadControl structure and the condition variable as soon as
 *    ctrlPtr->condWait is signaled, so this routine must make copies of
 *    any data it might need after that point.
 *
 * Results:
 *    none
 *
 * Side effects:
 *    A TCL script is executed in a new thread.
 *
 *------------------------------------------------------------------------
 */
Tcl_ThreadCreateType
NewTestThread(clientData)
    ClientData clientData;
{
    ThreadCtrl *ctrlPtr = (ThreadCtrl*)clientData;
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    int result;
    char *threadEvalScript;

    /*
     * Initialize the interpreter.  This should be more general.
     */

    tsdPtr->interp = Tcl_CreateInterp();
    result = Tcl_Init(tsdPtr->interp);
    result = TclThread_Init(tsdPtr->interp);

    /*
     * Update the list of threads.
     */

    Tcl_MutexLock(&threadMutex);
    ListUpdateInner(tsdPtr);
    /*
     * We need to keep a pointer to the alloc'ed mem of the script
     * we are eval'ing, for the case that we exit during evaluation
     */
    threadEvalScript = (char *) ckalloc(strlen(ctrlPtr->script)+1);
    strcpy(threadEvalScript, ctrlPtr->script);

    Tcl_CreateThreadExitHandler(ThreadExitProc, (ClientData) threadEvalScript);

    /*
     * Notify the parent we are alive.
     */

    Tcl_ConditionNotify(&ctrlPtr->condWait);
    Tcl_MutexUnlock(&threadMutex);

    /*
     * Run the script.
     */

    Tcl_Preserve((ClientData) tsdPtr->interp);
    result = Tcl_Eval(tsdPtr->interp, threadEvalScript);
    if (result != TCL_OK) {
	ThreadErrorProc(tsdPtr->interp);
    }

    /*
     * Clean up.
     */

    ListRemove(tsdPtr);
    Tcl_Release((ClientData) tsdPtr->interp);
    Tcl_DeleteInterp(tsdPtr->interp);
    Tcl_ExitThread(result);

    TCL_THREAD_CREATE_RETURN;
}

/*
 *------------------------------------------------------------------------
 *
 * ThreadErrorProc --
 *
 *    Send a message to the thread willing to hear about errors.
 *
 * Results:
 *    none
 *
 * Side effects:
 *    Send an event.
 *
 *------------------------------------------------------------------------
 */
static void
ThreadErrorProc(interp)
    Tcl_Interp *interp;		/* Interp that failed */
{
    Tcl_Channel errChannel;
    CONST char *errorInfo, *argv[3];
    char *script;
    char buf[TCL_DOUBLE_SPACE+1];
    sprintf(buf, "%ld", (long) Tcl_GetCurrentThread());

    errorInfo = Tcl_GetVar(interp, "errorInfo", TCL_GLOBAL_ONLY);
    if (errorProcString == NULL) {
	errChannel = Tcl_GetStdChannel(TCL_STDERR);
	Tcl_WriteChars(errChannel, "Error from thread ", -1);
	Tcl_WriteChars(errChannel, buf, -1);
	Tcl_WriteChars(errChannel, "\n", 1);
	Tcl_WriteChars(errChannel, errorInfo, -1);
	Tcl_WriteChars(errChannel, "\n", 1);
    } else {
	argv[0] = errorProcString;
	argv[1] = buf;
	argv[2] = errorInfo;
	script = Tcl_Merge(3, argv);
	TclThreadSend(interp, errorThreadId, script, 0);
	ckfree(script);
    }
}


/*
 *------------------------------------------------------------------------
 *
 * ListUpdateInner --
 *
 *    Add the thread local storage to the list.  This assumes
 *	the caller has obtained the mutex.
 *
 * Results:
 *    none
 *
 * Side effects:
 *    Add the thread local storage to its list.
 *
 *------------------------------------------------------------------------
 */
static void
ListUpdateInner(tsdPtr)
    ThreadSpecificData *tsdPtr;
{
    if (tsdPtr == NULL) {
	tsdPtr = TCL_TSD_INIT(&dataKey);
    }
    tsdPtr->threadId = Tcl_GetCurrentThread();
    tsdPtr->nextPtr = threadList;
    if (threadList) {
	threadList->prevPtr = tsdPtr;
    }
    tsdPtr->prevPtr = NULL;
    threadList = tsdPtr;
}

/*
 *------------------------------------------------------------------------
 *
 * ListRemove --
 *
 *    Remove the thread local storage from its list.  This grabs the
 *	mutex to protect the list.
 *
 * Results:
 *    none
 *
 * Side effects:
 *    Remove the thread local storage from its list.
 *
 *------------------------------------------------------------------------
 */
static void
ListRemove(tsdPtr)
    ThreadSpecificData *tsdPtr;
{
    if (tsdPtr == NULL) {
	tsdPtr = TCL_TSD_INIT(&dataKey);
    }
    Tcl_MutexLock(&threadMutex);
    if (tsdPtr->prevPtr) {
	tsdPtr->prevPtr->nextPtr = tsdPtr->nextPtr;
    } else {
	threadList = tsdPtr->nextPtr;
    }
    if (tsdPtr->nextPtr) {
	tsdPtr->nextPtr->prevPtr = tsdPtr->prevPtr;
    }
    tsdPtr->nextPtr = tsdPtr->prevPtr = 0;
    Tcl_MutexUnlock(&threadMutex);
}


/*
 *------------------------------------------------------------------------
 *
 * TclThreadList --
 *
 *    Return a list of threads running Tcl interpreters.
 *
 * Results:
 *    A standard Tcl result.
 *
 * Side effects:
 *    None.
 *
 *------------------------------------------------------------------------
 */
int
TclThreadList(interp)
    Tcl_Interp *interp;
{
    ThreadSpecificData *tsdPtr;
    Tcl_Obj *listPtr;

    listPtr = Tcl_NewListObj(0, NULL);
    Tcl_MutexLock(&threadMutex);
    for (tsdPtr = threadList ; tsdPtr ; tsdPtr = tsdPtr->nextPtr) {
	Tcl_ListObjAppendElement(interp, listPtr,
		Tcl_NewLongObj((long)tsdPtr->threadId));
    }
    Tcl_MutexUnlock(&threadMutex);
    Tcl_SetObjResult(interp, listPtr);
    return TCL_OK;
}


/*
 *------------------------------------------------------------------------
 *
 * TclThreadSend --
 *
 *    Send a script to another thread.
 *
 * Results:
 *    A standard Tcl result.
 *
 * Side effects:
 *    None.
 *
 *------------------------------------------------------------------------
 */
int
TclThreadSend(interp, id, script, wait)
    Tcl_Interp *interp;		/* The current interpreter. */
    Tcl_ThreadId id;		/* Thread Id of other interpreter. */
    char *script;		/* The script to evaluate. */
    int wait;			/* If 1, we block for the result. */
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    ThreadEvent *threadEventPtr;
    ThreadEventResult *resultPtr;
    int found, code;
    Tcl_ThreadId threadId = (Tcl_ThreadId) id;

    /* 
     * Verify the thread exists.
     */

    Tcl_MutexLock(&threadMutex);
    found = 0;
    for (tsdPtr = threadList ; tsdPtr ; tsdPtr = tsdPtr->nextPtr) {
	if (tsdPtr->threadId == threadId) {
	    found = 1;
	    break;
	}
    }
    if (!found) {
	Tcl_MutexUnlock(&threadMutex);
	Tcl_AppendResult(interp, "invalid thread id", NULL);
	return TCL_ERROR;
    }

    /*
     * Short circut sends to ourself.  Ought to do something with -async,
     * like run in an idle handler.
     */

    if (threadId == Tcl_GetCurrentThread()) {
        Tcl_MutexUnlock(&threadMutex);
	return Tcl_GlobalEval(interp, script);
    }

    /* 
     * Create the event for its event queue.
     */

    threadEventPtr = (ThreadEvent *) ckalloc(sizeof(ThreadEvent));
    threadEventPtr->script = ckalloc(strlen(script) + 1);
    strcpy(threadEventPtr->script, script);
    if (!wait) {
	resultPtr = threadEventPtr->resultPtr = NULL;
    } else {
	resultPtr = (ThreadEventResult *) ckalloc(sizeof(ThreadEventResult));
	threadEventPtr->resultPtr = resultPtr;

	/*
	 * Initialize the result fields.
	 */

	resultPtr->done = NULL;
	resultPtr->code = 0;
	resultPtr->result = NULL;
	resultPtr->errorInfo = NULL;
	resultPtr->errorCode = NULL;

	/* 
	 * Maintain the cleanup list.
	 */

	resultPtr->srcThreadId = Tcl_GetCurrentThread();
	resultPtr->dstThreadId = threadId;
	resultPtr->eventPtr = threadEventPtr;
	resultPtr->nextPtr = resultList;
	if (resultList) {
	    resultList->prevPtr = resultPtr;
	}
	resultPtr->prevPtr = NULL;
	resultList = resultPtr;
    }

    /*
     * Queue the event and poke the other thread's notifier.
     */

    threadEventPtr->event.proc = ThreadEventProc;
    Tcl_ThreadQueueEvent(threadId, (Tcl_Event *)threadEventPtr, 
	    TCL_QUEUE_TAIL);
    Tcl_ThreadAlert(threadId);

    if (!wait) {
	Tcl_MutexUnlock(&threadMutex);
	return TCL_OK;
    }

    /* 
     * Block on the results and then get them.
     */

    Tcl_ResetResult(interp);
    while (resultPtr->result == NULL) {
        Tcl_ConditionWait(&resultPtr->done, &threadMutex, NULL);
    }

    /*
     * Unlink result from the result list.
     */

    if (resultPtr->prevPtr) {
	resultPtr->prevPtr->nextPtr = resultPtr->nextPtr;
    } else {
	resultList = resultPtr->nextPtr;
    }
    if (resultPtr->nextPtr) {
	resultPtr->nextPtr->prevPtr = resultPtr->prevPtr;
    }
    resultPtr->eventPtr = NULL;
    resultPtr->nextPtr = NULL;
    resultPtr->prevPtr = NULL;

    Tcl_MutexUnlock(&threadMutex);

    if (resultPtr->code != TCL_OK) {
	if (resultPtr->errorCode) {
	    Tcl_SetErrorCode(interp, resultPtr->errorCode, NULL);
	    ckfree(resultPtr->errorCode);
	}
	if (resultPtr->errorInfo) {
	    Tcl_AddErrorInfo(interp, resultPtr->errorInfo);
	    ckfree(resultPtr->errorInfo);
	}
    }
    Tcl_SetResult(interp, resultPtr->result, TCL_DYNAMIC);
    Tcl_ConditionFinalize(&resultPtr->done);
    code = resultPtr->code;

    ckfree((char *) resultPtr);

    return code;
}


/*
 *------------------------------------------------------------------------
 *
 * ThreadEventProc --
 *
 *    Handle the event in the target thread.
 *
 * Results:
 *    Returns 1 to indicate that the event was processed.
 *
 * Side effects:
 *    Fills out the ThreadEventResult struct.
 *
 *------------------------------------------------------------------------
 */
static int
ThreadEventProc(evPtr, mask)
    Tcl_Event *evPtr;		/* Really ThreadEvent */
    int mask;
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    ThreadEvent *threadEventPtr = (ThreadEvent *)evPtr;
    ThreadEventResult *resultPtr = threadEventPtr->resultPtr;
    Tcl_Interp *interp = tsdPtr->interp;
    int code;
    CONST char *result, *errorCode, *errorInfo;

    if (interp == NULL) {
	code = TCL_ERROR;
	result = "no target interp!";
	errorCode = "THREAD";
	errorInfo = "";
    } else {
	Tcl_Preserve((ClientData) interp);
	Tcl_ResetResult(interp);
	Tcl_CreateThreadExitHandler(ThreadFreeProc,
		(ClientData) threadEventPtr->script);
	code = Tcl_GlobalEval(interp, threadEventPtr->script);
	Tcl_DeleteThreadExitHandler(ThreadFreeProc,
		(ClientData) threadEventPtr->script);
	result = Tcl_GetStringResult(interp);
	if (code != TCL_OK) {
	    errorCode = Tcl_GetVar(interp, "errorCode", TCL_GLOBAL_ONLY);
	    errorInfo = Tcl_GetVar(interp, "errorInfo", TCL_GLOBAL_ONLY);
	} else {
	    errorCode = errorInfo = NULL;
	}
    }
    ckfree(threadEventPtr->script);
    if (resultPtr) {
	Tcl_MutexLock(&threadMutex);
	resultPtr->code = code;
	resultPtr->result = ckalloc(strlen(result) + 1);
	strcpy(resultPtr->result, result);
	if (errorCode != NULL) {
	    resultPtr->errorCode = ckalloc(strlen(errorCode) + 1);
	    strcpy(resultPtr->errorCode, errorCode);
	}
	if (errorInfo != NULL) {
	    resultPtr->errorInfo = ckalloc(strlen(errorInfo) + 1);
	    strcpy(resultPtr->errorInfo, errorInfo);
	}
	Tcl_ConditionNotify(&resultPtr->done);
	Tcl_MutexUnlock(&threadMutex);
    }
    if (interp != NULL) {
	Tcl_Release((ClientData) interp);
    }
    return 1;
}

/*
 *------------------------------------------------------------------------
 *
 * ThreadFreeProc --
 *
 *    This is called from when we are exiting and memory needs
 *    to be freed.
 *
 * Results:
 *    None.
 *
 * Side effects:
 *	Clears up mem specified in ClientData
 *
 *------------------------------------------------------------------------
 */
     /* ARGSUSED */
static void
ThreadFreeProc(clientData)
    ClientData clientData;
{
    if (clientData) {
	ckfree((char *) clientData);
    }
}

/*
 *------------------------------------------------------------------------
 *
 * ThreadDeleteEvent --
 *
 *    This is called from the ThreadExitProc to delete memory related
 *    to events that we put on the queue.
 *
 * Results:
 *    1 it was our event and we want it removed, 0 otherwise.
 *
 * Side effects:
 *	It cleans up our events in the event queue for this thread.
 *
 *------------------------------------------------------------------------
 */
     /* ARGSUSED */
static int
ThreadDeleteEvent(eventPtr, clientData)
    Tcl_Event *eventPtr;		/* Really ThreadEvent */
    ClientData clientData;		/* dummy */
{
    if (eventPtr->proc == ThreadEventProc) {
	ckfree((char *) ((ThreadEvent *) eventPtr)->script);
	return 1;
    }
    /*
     * If it was NULL, we were in the middle of servicing the event
     * and it should be removed
     */
    return (eventPtr->proc == NULL);
}

/*
 *------------------------------------------------------------------------
 *
 * ThreadExitProc --
 *
 *    This is called when the thread exits.  
 *
 * Results:
 *    None.
 *
 * Side effects:
 *	It unblocks anyone that is waiting on a send to this thread.
 *	It cleans up any events in the event queue for this thread.
 *
 *------------------------------------------------------------------------
 */
     /* ARGSUSED */
static void
ThreadExitProc(clientData)
    ClientData clientData;
{
    char *threadEvalScript = (char *) clientData;
    ThreadEventResult *resultPtr, *nextPtr;
    Tcl_ThreadId self = Tcl_GetCurrentThread();

    Tcl_MutexLock(&threadMutex);

    if (threadEvalScript) {
	ckfree((char *) threadEvalScript);
	threadEvalScript = NULL;
    }
    Tcl_DeleteEvents((Tcl_EventDeleteProc *)ThreadDeleteEvent, NULL);

    for (resultPtr = resultList ; resultPtr ; resultPtr = nextPtr) {
	nextPtr = resultPtr->nextPtr;
	if (resultPtr->srcThreadId == self) {
	    /*
	     * We are going away.  By freeing up the result we signal
	     * to the other thread we don't care about the result.
	     */
	    if (resultPtr->prevPtr) {
		resultPtr->prevPtr->nextPtr = resultPtr->nextPtr;
	    } else {
		resultList = resultPtr->nextPtr;
	    }
	    if (resultPtr->nextPtr) {
		resultPtr->nextPtr->prevPtr = resultPtr->prevPtr;
	    }
	    resultPtr->nextPtr = resultPtr->prevPtr = 0;
	    resultPtr->eventPtr->resultPtr = NULL;
	    ckfree((char *)resultPtr);
	} else if (resultPtr->dstThreadId == self) {
	    /*
	     * Dang.  The target is going away.  Unblock the caller.
	     * The result string must be dynamically allocated because
	     * the main thread is going to call free on it.
	     */

	    char *msg = "target thread died";
	    resultPtr->result = ckalloc(strlen(msg)+1);
	    strcpy(resultPtr->result, msg);
	    resultPtr->code = TCL_ERROR;
	    Tcl_ConditionNotify(&resultPtr->done);
	}
    }
    Tcl_MutexUnlock(&threadMutex);
}

#endif /* TCL_THREADS */
@


1.4
log
@touched all sources to ease next import
@
text
@d14 1
a14 1
 * RCS: @@(#) $Id: tclThreadTest.c,v 1.6.8.2 2000/09/15 16:55:33 spolk Exp $
d121 1
a121 1
	CONST char *script));
d129 1
a129 1
Tcl_ThreadCreateType	NewThread _ANSI_ARGS_((ClientData clientData));
d178 1
a178 1
 *	thread create
d185 1
d206 5
a210 4
    static char *threadOptions[] = {"create", "exit", "id", "names",
				    "send", "wait", "errorproc", (char *) NULL};
    enum options {THREAD_CREATE, THREAD_EXIT, THREAD_ID, THREAD_NAMES,
		  THREAD_SEND, THREAD_WAIT, THREAD_ERRORPROC};
d236 2
d239 6
a244 1
		script = "testthread wait";	/* Just enter the event loop */
d246 30
a275 1
		script = Tcl_GetString(objv[2]);
d277 1
a277 1
		Tcl_WrongNumArgs(interp, 2, objv, "?script?");
d280 1
a280 1
	    return TclCreateThread(interp, script);
d300 22
d406 1
a406 1
TclCreateThread(interp, script)
d408 2
a409 1
    CONST char *script;			/* Script to execute */
d414 1
a414 1
    ctrl.script = (char *) script;
d418 2
d421 2
a422 2
    if (Tcl_CreateThread(&id, NewThread, (ClientData) &ctrl,
		 TCL_THREAD_STACK_DEFAULT, TCL_THREAD_NOFLAGS) != TCL_OK) {
d443 1
a443 1
 * NewThread --
d469 1
a469 1
NewThread(clientData)
d549 2
a550 2
    char *errorInfo, *script;
    char *argv[3];
d846 1
a846 1
int
d856 1
a856 1
    char *result, *errorCode, *errorInfo;
d919 1
a919 1
void
d945 1
a945 1
int
d978 1
a978 1
void
a1029 1

@


1.3
log
@touched all sources to ease next import
@
text
@@


1.3.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d14 1
a14 1
 * RCS: @@(#) $Id: tclThreadTest.c,v 1.16 2002/01/26 01:10:08 dgp Exp $
d121 1
a121 1
	char *script, int joinable));
d129 1
a129 1
Tcl_ThreadCreateType	NewTestThread _ANSI_ARGS_((ClientData clientData));
d178 1
a178 1
 *	thread create ?-joinable? ?script?
a184 1
 *	thread join id
d205 4
a208 5
    static CONST char *threadOptions[] = {"create", "exit", "id", "join", "names",
				    "send", "wait", "errorproc",
				    (char *) NULL};
    enum options {THREAD_CREATE, THREAD_EXIT, THREAD_ID, THREAD_JOIN,
		  THREAD_NAMES, THREAD_SEND, THREAD_WAIT, THREAD_ERRORPROC};
a233 2
	    int   joinable, len;

d235 1
a235 6
	        /* Neither joinable nor special script
		 */

	        joinable = 0;
		script   = "testthread wait";	/* Just enter the event loop */

d237 1
a237 30
	        /* Possibly -joinable, then no special script,
		 * no joinable, then its a script.
		 */

	        script = Tcl_GetString(objv[2]);
		len    = strlen (script);

		if ((len > 1) &&
		    (script [0] == '-') && (script [1] == 'j') &&
		    (0 == strncmp (script, "-joinable", (size_t) len))) {
		    joinable = 1;
		    script   = "testthread wait"; /* Just enter the event loop
						   */
		} else {
		    /* Remember the script */
		    joinable = 0;
		}
	    } else if (objc == 4) {
	        /* Definitely a script available, but is the flag
		 * -joinable ?
		 */

	        script = Tcl_GetString(objv[2]);
		len    = strlen (script);

		joinable = ((len > 1) &&
			    (script [0] == '-') && (script [1] == 'j') &&
			    (0 == strncmp (script, "-joinable", (size_t) len)));

		script = Tcl_GetString(objv[3]);
d239 1
a239 1
		Tcl_WrongNumArgs(interp, 2, objv, "?-joinable? ?script?");
d242 1
a242 1
	    return TclCreateThread(interp, script, joinable);
a261 22
        case THREAD_JOIN: {
	    long id;
	    int result, status;

	    if (objc != 3) {
		Tcl_WrongNumArgs(interp, 1, objv, "join id");
		return TCL_ERROR;
	    }
	    if (Tcl_GetLongFromObj(interp, objv[2], &id) != TCL_OK) {
		return TCL_ERROR;
	    }

	    result = Tcl_JoinThread ((Tcl_ThreadId) id, &status);
	    if (result == TCL_OK) {
	        Tcl_SetIntObj (Tcl_GetObjResult (interp), status);
	    } else {
	        char buf [20];
		sprintf (buf, "%ld", id);
		Tcl_AppendResult (interp, "cannot join thread ", buf, NULL);
	    }
	    return result;
	}
d346 1
a346 1
TclCreateThread(interp, script, joinable)
d348 1
a348 2
    char *script;			/* Script to execute */
    int         joinable;		/* Flag, joinable thread or not */
d353 1
a353 1
    ctrl.script = script;
a356 2
    joinable = joinable ? TCL_THREAD_JOINABLE : TCL_THREAD_NOFLAGS;

d358 2
a359 2
    if (Tcl_CreateThread(&id, NewTestThread, (ClientData) &ctrl,
		 TCL_THREAD_STACK_DEFAULT, joinable) != TCL_OK) {
d380 1
a380 1
 * NewTestThread --
d406 1
a406 1
NewTestThread(clientData)
d486 2
a487 2
    CONST char *errorInfo, *argv[3];
    char *script;
d783 1
a783 1
static int
d793 1
a793 1
    CONST char *result, *errorCode, *errorInfo;
d856 1
a856 1
static void
d882 1
a882 1
static int
d915 1
a915 1
static void
d967 1
@


1.3.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@d14 1
a14 1
 * RCS: @@(#) $Id: tclThreadTest.c,v 1.16 2002/01/26 01:10:08 dgp Exp $
d121 1
a121 1
	char *script, int joinable));
d129 1
a129 1
Tcl_ThreadCreateType	NewTestThread _ANSI_ARGS_((ClientData clientData));
d178 1
a178 1
 *	thread create ?-joinable? ?script?
a184 1
 *	thread join id
d205 4
a208 5
    static CONST char *threadOptions[] = {"create", "exit", "id", "join", "names",
				    "send", "wait", "errorproc",
				    (char *) NULL};
    enum options {THREAD_CREATE, THREAD_EXIT, THREAD_ID, THREAD_JOIN,
		  THREAD_NAMES, THREAD_SEND, THREAD_WAIT, THREAD_ERRORPROC};
a233 2
	    int   joinable, len;

d235 1
a235 6
	        /* Neither joinable nor special script
		 */

	        joinable = 0;
		script   = "testthread wait";	/* Just enter the event loop */

d237 1
a237 30
	        /* Possibly -joinable, then no special script,
		 * no joinable, then its a script.
		 */

	        script = Tcl_GetString(objv[2]);
		len    = strlen (script);

		if ((len > 1) &&
		    (script [0] == '-') && (script [1] == 'j') &&
		    (0 == strncmp (script, "-joinable", (size_t) len))) {
		    joinable = 1;
		    script   = "testthread wait"; /* Just enter the event loop
						   */
		} else {
		    /* Remember the script */
		    joinable = 0;
		}
	    } else if (objc == 4) {
	        /* Definitely a script available, but is the flag
		 * -joinable ?
		 */

	        script = Tcl_GetString(objv[2]);
		len    = strlen (script);

		joinable = ((len > 1) &&
			    (script [0] == '-') && (script [1] == 'j') &&
			    (0 == strncmp (script, "-joinable", (size_t) len)));

		script = Tcl_GetString(objv[3]);
d239 1
a239 1
		Tcl_WrongNumArgs(interp, 2, objv, "?-joinable? ?script?");
d242 1
a242 1
	    return TclCreateThread(interp, script, joinable);
a261 22
        case THREAD_JOIN: {
	    long id;
	    int result, status;

	    if (objc != 3) {
		Tcl_WrongNumArgs(interp, 1, objv, "join id");
		return TCL_ERROR;
	    }
	    if (Tcl_GetLongFromObj(interp, objv[2], &id) != TCL_OK) {
		return TCL_ERROR;
	    }

	    result = Tcl_JoinThread ((Tcl_ThreadId) id, &status);
	    if (result == TCL_OK) {
	        Tcl_SetIntObj (Tcl_GetObjResult (interp), status);
	    } else {
	        char buf [20];
		sprintf (buf, "%ld", id);
		Tcl_AppendResult (interp, "cannot join thread ", buf, NULL);
	    }
	    return result;
	}
d346 1
a346 1
TclCreateThread(interp, script, joinable)
d348 1
a348 2
    char *script;			/* Script to execute */
    int         joinable;		/* Flag, joinable thread or not */
d353 1
a353 1
    ctrl.script = script;
a356 2
    joinable = joinable ? TCL_THREAD_JOINABLE : TCL_THREAD_NOFLAGS;

d358 2
a359 2
    if (Tcl_CreateThread(&id, NewTestThread, (ClientData) &ctrl,
		 TCL_THREAD_STACK_DEFAULT, joinable) != TCL_OK) {
d380 1
a380 1
 * NewTestThread --
d406 1
a406 1
NewTestThread(clientData)
d486 2
a487 2
    CONST char *errorInfo, *argv[3];
    char *script;
d783 1
a783 1
static int
d793 1
a793 1
    CONST char *result, *errorCode, *errorInfo;
d856 1
a856 1
static void
d882 1
a882 1
static int
d915 1
a915 1
static void
d967 1
@


1.2
log
@touched all Tcl files to ease next import.
@
text
@@


1.2.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.2.16.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d121 1
a121 1
	char *script, int joinable));
d129 1
a129 1
Tcl_ThreadCreateType	NewTestThread _ANSI_ARGS_((ClientData clientData));
d178 1
a178 1
 *	thread create ?-joinable? ?script?
a184 1
 *	thread join id
d205 4
a208 5
    static CONST char *threadOptions[] = {"create", "exit", "id", "join", "names",
				    "send", "wait", "errorproc",
				    (char *) NULL};
    enum options {THREAD_CREATE, THREAD_EXIT, THREAD_ID, THREAD_JOIN,
		  THREAD_NAMES, THREAD_SEND, THREAD_WAIT, THREAD_ERRORPROC};
a233 2
	    int   joinable, len;

d235 1
a235 6
	        /* Neither joinable nor special script
		 */

	        joinable = 0;
		script   = "testthread wait";	/* Just enter the event loop */

d237 1
a237 30
	        /* Possibly -joinable, then no special script,
		 * no joinable, then its a script.
		 */

	        script = Tcl_GetString(objv[2]);
		len    = strlen (script);

		if ((len > 1) &&
		    (script [0] == '-') && (script [1] == 'j') &&
		    (0 == strncmp (script, "-joinable", (size_t) len))) {
		    joinable = 1;
		    script   = "testthread wait"; /* Just enter the event loop
						   */
		} else {
		    /* Remember the script */
		    joinable = 0;
		}
	    } else if (objc == 4) {
	        /* Definitely a script available, but is the flag
		 * -joinable ?
		 */

	        script = Tcl_GetString(objv[2]);
		len    = strlen (script);

		joinable = ((len > 1) &&
			    (script [0] == '-') && (script [1] == 'j') &&
			    (0 == strncmp (script, "-joinable", (size_t) len)));

		script = Tcl_GetString(objv[3]);
d239 1
a239 1
		Tcl_WrongNumArgs(interp, 2, objv, "?-joinable? ?script?");
d242 1
a242 1
	    return TclCreateThread(interp, script, joinable);
a261 22
        case THREAD_JOIN: {
	    long id;
	    int result, status;

	    if (objc != 3) {
		Tcl_WrongNumArgs(interp, 1, objv, "join id");
		return TCL_ERROR;
	    }
	    if (Tcl_GetLongFromObj(interp, objv[2], &id) != TCL_OK) {
		return TCL_ERROR;
	    }

	    result = Tcl_JoinThread ((Tcl_ThreadId) id, &status);
	    if (result == TCL_OK) {
	        Tcl_SetIntObj (Tcl_GetObjResult (interp), status);
	    } else {
	        char buf [20];
		sprintf (buf, "%ld", id);
		Tcl_AppendResult (interp, "cannot join thread ", buf, NULL);
	    }
	    return result;
	}
d346 1
a346 1
TclCreateThread(interp, script, joinable)
d348 1
a348 2
    char *script;			/* Script to execute */
    int         joinable;		/* Flag, joinable thread or not */
d353 1
a353 1
    ctrl.script = script;
a356 2
    joinable = joinable ? TCL_THREAD_JOINABLE : TCL_THREAD_NOFLAGS;

d358 2
a359 2
    if (Tcl_CreateThread(&id, NewTestThread, (ClientData) &ctrl,
		 TCL_THREAD_STACK_DEFAULT, joinable) != TCL_OK) {
d380 1
a380 1
 * NewTestThread --
d406 1
a406 1
NewTestThread(clientData)
d486 2
a487 2
    CONST char *errorInfo, *argv[3];
    char *script;
d783 1
a783 1
static int
d793 1
a793 1
    CONST char *result, *errorCode, *errorInfo;
d856 1
a856 1
static void
d882 1
a882 1
static int
d915 1
a915 1
static void
d967 1
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Tcl 8.3 upgrade
@
text
@@


1.1.1.2
log
@import tcl 8.4.0
@
text
@d14 1
a14 1
 * RCS: @@(#) $Id: tclThreadTest.c,v 1.16 2002/01/26 01:10:08 dgp Exp $
d121 1
a121 1
	char *script, int joinable));
d129 1
a129 1
Tcl_ThreadCreateType	NewTestThread _ANSI_ARGS_((ClientData clientData));
d178 1
a178 1
 *	thread create ?-joinable? ?script?
a184 1
 *	thread join id
d205 4
a208 5
    static CONST char *threadOptions[] = {"create", "exit", "id", "join", "names",
				    "send", "wait", "errorproc",
				    (char *) NULL};
    enum options {THREAD_CREATE, THREAD_EXIT, THREAD_ID, THREAD_JOIN,
		  THREAD_NAMES, THREAD_SEND, THREAD_WAIT, THREAD_ERRORPROC};
a233 2
	    int   joinable, len;

d235 1
a235 6
	        /* Neither joinable nor special script
		 */

	        joinable = 0;
		script   = "testthread wait";	/* Just enter the event loop */

d237 1
a237 30
	        /* Possibly -joinable, then no special script,
		 * no joinable, then its a script.
		 */

	        script = Tcl_GetString(objv[2]);
		len    = strlen (script);

		if ((len > 1) &&
		    (script [0] == '-') && (script [1] == 'j') &&
		    (0 == strncmp (script, "-joinable", (size_t) len))) {
		    joinable = 1;
		    script   = "testthread wait"; /* Just enter the event loop
						   */
		} else {
		    /* Remember the script */
		    joinable = 0;
		}
	    } else if (objc == 4) {
	        /* Definitely a script available, but is the flag
		 * -joinable ?
		 */

	        script = Tcl_GetString(objv[2]);
		len    = strlen (script);

		joinable = ((len > 1) &&
			    (script [0] == '-') && (script [1] == 'j') &&
			    (0 == strncmp (script, "-joinable", (size_t) len)));

		script = Tcl_GetString(objv[3]);
d239 1
a239 1
		Tcl_WrongNumArgs(interp, 2, objv, "?-joinable? ?script?");
d242 1
a242 1
	    return TclCreateThread(interp, script, joinable);
a261 22
        case THREAD_JOIN: {
	    long id;
	    int result, status;

	    if (objc != 3) {
		Tcl_WrongNumArgs(interp, 1, objv, "join id");
		return TCL_ERROR;
	    }
	    if (Tcl_GetLongFromObj(interp, objv[2], &id) != TCL_OK) {
		return TCL_ERROR;
	    }

	    result = Tcl_JoinThread ((Tcl_ThreadId) id, &status);
	    if (result == TCL_OK) {
	        Tcl_SetIntObj (Tcl_GetObjResult (interp), status);
	    } else {
	        char buf [20];
		sprintf (buf, "%ld", id);
		Tcl_AppendResult (interp, "cannot join thread ", buf, NULL);
	    }
	    return result;
	}
d346 1
a346 1
TclCreateThread(interp, script, joinable)
d348 1
a348 2
    char *script;			/* Script to execute */
    int         joinable;		/* Flag, joinable thread or not */
d353 1
a353 1
    ctrl.script = script;
a356 2
    joinable = joinable ? TCL_THREAD_JOINABLE : TCL_THREAD_NOFLAGS;

d358 2
a359 2
    if (Tcl_CreateThread(&id, NewTestThread, (ClientData) &ctrl,
		 TCL_THREAD_STACK_DEFAULT, joinable) != TCL_OK) {
d380 1
a380 1
 * NewTestThread --
d406 1
a406 1
NewTestThread(clientData)
d486 2
a487 2
    CONST char *errorInfo, *argv[3];
    char *script;
d783 1
a783 1
static int
d793 1
a793 1
    CONST char *result, *errorCode, *errorInfo;
d856 1
a856 1
static void
d882 1
a882 1
static int
d915 1
a915 1
static void
d967 1
@

