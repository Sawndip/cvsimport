head	1.8;
access;
symbols
	sid-snapshot-20180601:1.8
	sid-snapshot-20180501:1.8
	sid-snapshot-20180401:1.8
	sid-snapshot-20180301:1.8
	sid-snapshot-20180201:1.8
	sid-snapshot-20180101:1.8
	sid-snapshot-20171201:1.8
	sid-snapshot-20171101:1.8
	sid-snapshot-20171001:1.8
	sid-snapshot-20170901:1.8
	sid-snapshot-20170801:1.8
	sid-snapshot-20170701:1.8
	sid-snapshot-20170601:1.8
	sid-snapshot-20170501:1.8
	sid-snapshot-20170401:1.8
	sid-snapshot-20170301:1.8
	sid-snapshot-20170201:1.8
	sid-snapshot-20170101:1.8
	sid-snapshot-20161201:1.8
	sid-snapshot-20161101:1.8
	sid-snapshot-20160901:1.8
	sid-snapshot-20160801:1.8
	sid-snapshot-20160701:1.8
	sid-snapshot-20160601:1.8
	sid-snapshot-20160501:1.8
	sid-snapshot-20160401:1.8
	sid-snapshot-20160301:1.8
	sid-snapshot-20160201:1.8
	sid-snapshot-20160101:1.8
	sid-snapshot-20151201:1.8
	sid-snapshot-20151101:1.8
	sid-snapshot-20151001:1.8
	sid-snapshot-20150901:1.8
	sid-snapshot-20150801:1.8
	sid-snapshot-20150701:1.8
	sid-snapshot-20150601:1.8
	sid-snapshot-20150501:1.8
	sid-snapshot-20150401:1.8
	sid-snapshot-20150301:1.8
	sid-snapshot-20150201:1.8
	sid-snapshot-20150101:1.8
	sid-snapshot-20141201:1.8
	sid-snapshot-20141101:1.8
	sid-snapshot-20141001:1.8
	sid-snapshot-20140901:1.8
	sid-snapshot-20140801:1.8
	sid-snapshot-20140701:1.8
	sid-snapshot-20140601:1.8
	sid-snapshot-20140501:1.8
	sid-snapshot-20140401:1.8
	sid-snapshot-20140301:1.8
	sid-snapshot-20140201:1.8
	sid-snapshot-20140101:1.8
	sid-snapshot-20131201:1.8
	sid-snapshot-20131101:1.8
	sid-snapshot-20131001:1.8
	sid-snapshot-20130901:1.8
	sid-snapshot-20130801:1.8
	sid-snapshot-20130701:1.8
	sid-snapshot-20130601:1.8
	insight_7_6-2013-04-10-branchpoint:1.8
	gdb_7_6-branch:1.8.0.56
	sid-snapshot-20130501:1.8
	sid-snapshot-20130401:1.8
	sid-snapshot-20130301:1.8
	sid-snapshot-20130201:1.8
	sid-snapshot-20130101:1.8
	sid-snapshot-20121201:1.8
	sid-snapshot-20121101:1.8
	sid-snapshot-20121001:1.8
	sid-snapshot-20120901:1.8
	gdb_7_5-branch:1.8.0.54
	sid-snapshot-20120801:1.8
	sid-snapshot-20120701:1.8
	sid-snapshot-20120601:1.8
	sid-snapshot-20120501:1.8
	sid-snapshot-20120401:1.8
	gdb_7_4-branch:1.8.0.52
	sid-snapshot-20120301:1.8
	sid-snapshot-20120201:1.8
	sid-snapshot-20120101:1.8
	sid-snapshot-20111201:1.8
	sid-snapshot-20111101:1.8
	sid-snapshot-20111001:1.8
	sid-snapshot-20110901:1.8
	gdb_7_3-branch:1.8.0.50
	sid-snapshot-20110801:1.8
	sid-snapshot-20110701:1.8
	sid-snapshot-20110601:1.8
	sid-snapshot-20110501:1.8
	sid-snapshot-20110401:1.8
	sid-snapshot-20110301:1.8
	sid-snapshot-20110201:1.8
	sid-snapshot-20110101:1.8
	sid-snapshot-20101201:1.8
	sid-snapshot-20101101:1.8
	sid-snapshot-20101001:1.8
	sid-snapshot-20100901:1.8
	sid-snapshot-20100801:1.8
	sid-snapshot-20100701:1.8
	sid-snapshot-20100601:1.8
	sid-snapshot-20100501:1.8
	sid-snapshot-20100401:1.8
	sid-snapshot-20100301:1.8
	gdb_7_1-branch:1.8.0.48
	gdb_7_0-branch:1.8.0.46
	sid-snapshot-20100201:1.8
	sid-snapshot-20100101:1.8
	sid-snapshot-20091201:1.8
	sid-snapshot-20091101:1.8
	sid-snapshot-20091001:1.8
	arc-sim-20090309:1.8
	sid-snapshot-20090901:1.8
	sid-snapshot-20090801:1.8
	sid-snapshot-20090701:1.8
	sid-snapshot-20090601:1.8
	sid-snapshot-20090501:1.8
	kevinb-pre-tcl8_5_7_merge:1.8
	sid-snapshot-20090401:1.8
	arc-insight_6_8-branch:1.8.0.44
	arc-insight_6_8-branchpoint:1.8
	insight_6_8-branch:1.8.0.42
	insight_6_8-branchpoint:1.8
	sid-snapshot-20090301:1.8
	sid-snapshot-20090201:1.8
	sid-snapshot-20090101:1.8
	sid-snapshot-20081201:1.8
	sid-snapshot-20081101:1.8
	sid-snapshot-20081001:1.8
	sid-snapshot-20080901:1.8
	sid-snapshot-20080801:1.8
	sid-snapshot-20080701:1.8
	sid-snapshot-20080601:1.8
	sid-snapshot-20080501:1.8
	sid-snapshot-20080403:1.8
	sid-snapshot-20080401:1.8
	gdb_6_8-branch:1.8.0.40
	sid-snapshot-20080301:1.8
	sid-snapshot-20080201:1.8
	sid-snapshot-20080101:1.8
	sid-snapshot-20071201:1.8
	sid-snapshot-20071101:1.8
	sid-snapshot-20071001:1.8
	insight_6_6-20070208-release:1.8
	gdb_6_6-branch:1.8.0.38
	gdb_6_6-2006-11-15-branchpoint:1.8
	insight_6_5-20061003-release:1.8
	gdb_6_5-branch:1.8.0.36
	gdb_6_5-2006-05-14-branchpoint:1.8
	readline_5_1-import-branch:1.8.0.34
	readline_5_1-import-branchpoint:1.8
	gdb_6_4-branch:1.8.0.32
	gdb_6_4-2005-11-01-branchpoint:1.8
	msnyder-tracepoint-checkpoint-branch:1.8.0.30
	msnyder-tracepoint-checkpoint-branchpoint:1.8
	gdb_6_1-2004-04-05-release:1.8
	ezannoni_pie-20040323-branch:1.8.0.28
	ezannoni_pie-20040323-branchpoint:1.8
	cagney_tramp-20040321-mergepoint:1.8
	cagney_tramp-20040309-branch:1.8.0.26
	cagney_tramp-20040309-branchpoint:1.8
	gdb_6_1-branch:1.8.0.24
	gdb_6_1-2004-03-01-gmt-branchpoint:1.8
	drow-cplus-merge-20040208:1.8
	carlton_dictionary-20040126-merge:1.8
	drow-cplus-merge-20040113:1.8
	drow-cplus-merge-20031224:1.8
	drow-cplus-merge-20031220:1.8
	carlton_dictionary-20031215-merge:1.8
	drow-cplus-merge-20031214:1.8
	carlton-dictionary-20031111-merge:1.8
	gdb_6_0-2003-10-04-release:1.8
	carlton_dictionary-20030917-merge:1.8
	ezannoni_pie-20030916-branchpoint:1.8
	ezannoni_pie-20030916-branch:1.8.0.22
	cagney_x86i386-20030821-branch:1.8.0.20
	cagney_x86i386-20030821-branchpoint:1.8
	carlton_dictionary-20030805-merge:1.8
	carlton_dictionary-20030627-merge:1.8
	gdb_6_0-branch:1.8.0.18
	gdb_6_0-2003-06-23-branchpoint:1.8
	cagney_convert-20030606-branch:1.8.0.16
	cagney_convert-20030606-branchpoint:1.8
	cagney_writestrings-20030508-branch:1.8.0.14
	cagney_writestrings-20030508-branchpoint:1.8
	carlton_dictionary-20030523-merge:1.8
	cagney_fileio-20030521-branch:1.8.0.12
	cagney_fileio-20030521-branchpoint:1.8
	carlton_dictionary-20030430-merge:1.8
	carlton_dictionary-20030416-merge:1.8
	cagney_frameaddr-20030409-mergepoint:1.8
	cagney_frameaddr-20030403-branchpoint:1.8
	cagney_frameaddr-20030403-branch:1.8.0.10
	cagney_framebase-20030330-mergepoint:1.8
	cagney_framebase-20030326-branch:1.8.0.8
	cagney_framebase-20030326-branchpoint:1.8
	cagney_lazyid-20030317-branch:1.8.0.6
	cagney_lazyid-20030317-branchpoint:1.8
	offbyone-20030313-branch:1.8.0.4
	offbyone-20030313-branchpoint:1.8
	carlton_dictionary-20030305-merge:1.8
	cagney_offbyone-20030303-branch:1.8.0.2
	cagney_offbyone-20030303-branchpoint:1.8
	carlton_dictionary-20030207-merge:1.7
	interps-20030202-branch:1.7.0.2
	interps-20030202-branchpoint:1.7
	TCL8_4_1:1.1.1.5
	cagney-unwind-20030108-branch:1.6.0.2
	cagney-unwind-20030108-branchpoint:1.6
	carlton_dictionary-20021223-merge:1.6
	gdb_5_3-2002-12-12-release:1.4
	TCL_8_4_1:1.1.1.5
	carlton_dictionary-20021115-merge:1.5
	kseitz_interps-20021105-merge:1.5
	kseitz_interps-20021103-merge:1.5
	drow-cplus-merge-20021020:1.5
	drow-cplus-merge-20021025:1.5
	carlton_dictionary-20021025-merge:1.5
	carlton_dictionary-20021011-merge:1.5
	drow-cplus-branch:1.5.0.4
	drow-cplus-branchpoint:1.5
	kseitz_interps-20020930-merge:1.5
	carlton_dictionary-20020927-merge:1.5
	tcltk840-20020924-branch:1.5.0.2
	tcltk840-20020924-branchpoint:1.5
	TCL_8_4_0:1.1.1.4
	carlton_dictionary-branch:1.4.0.16
	carlton_dictionary-20020920-branchpoint:1.4
	sid-20020905-branchpoint:1.4
	sid-20020905-branch:1.4.0.14
	gdb_5_3-branch:1.4.0.12
	gdb_5_3-2002-09-04-branchpoint:1.4
	kseitz_interps-20020829-merge:1.4
	cagney_sysregs-20020825-branch:1.4.0.10
	cagney_sysregs-20020825-branchpoint:1.4
	readline_4_3-import-branch:1.4.0.8
	readline_4_3-import-branchpoint:1.4
	gdb_5_2_1-2002-07-23-release:1.4
	kseitz_interps-20020528-branch:1.4.0.6
	kseitz_interps-20020528-branchpoint:1.4
	cagney_regbuf-20020515-branch:1.4.0.4
	cagney_regbuf-20020515-branchpoint:1.4
	gdb_5_2-2002-04-29-release:1.4
	gdb_5_2-branch:1.4.0.2
	gdb_5_2-2002-03-03-branchpoint:1.4
	gdb_5_1_1-2002-01-24-release:1.2
	cygnus_cvs_20020108_pre:1.4
	gdb_5_1_0_1-2002-01-03-branch:1.2.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.2
	gdb_5_1-2001-11-21-release:1.2
	gdb_s390-2001-09-26-branch:1.2.0.4
	gdb_s390-2001-09-26-branchpoint:1.2
	TCL_8_3:1.1.1.3
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.2.0.2
	gdb_5_1-2001-07-29-branchpoint:1.2
	insight-precleanup-2001-01-01:1.1.1.2
	gdb_5_0-2000-05-19-release:1.1.1.2
	gdb_4_18_2-2000-05-18-release:1.1.1.2
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.2
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.2
	gdb_5_0-2000-04-10-branch:1.1.1.2.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.2
	repo-unification-2000-02-06:1.1.1.2
	dejagnu-2000-02-04:1.1.1.2
	dejagnu-2000-01-31:1.1.1.2
	dejagnu-2000-01-24:1.1.1.1
	dejagnu-2000-01-17:1.1.1.1
	dejagnu-2000-01-10:1.1.1.1
	dejagnu-2000-01-04:1.1.1.1
	dejagnu-1999-12-21:1.1.1.1
	dejagnu-1999-12-13:1.1.1.1
	dejagnu-1999-12-07:1.1.1.1
	dejagnu-1999-12-06:1.1.1.1
	dejagnu-1999-11-15:1.1.1.1
	dejagnu-1999-11-08:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.8
date	2003.02.07.19.51.59;	author hunt;	state Exp;
branches;
next	1.7;

1.7
date	2003.01.21.19.40.02;	author hunt;	state Exp;
branches;
next	1.6;

1.6
date	2002.11.26.19.47.52;	author hunt;	state Exp;
branches;
next	1.5;

1.5
date	2002.09.24.18.37.02;	author kseitz;	state Exp;
branches
	1.5.2.1
	1.5.4.1;
next	1.4;

1.4
date	2001.09.09.23.56.05;	author irox;	state Exp;
branches
	1.4.16.1;
next	1.3;

1.3
date	2001.09.09.23.26.06;	author irox;	state Exp;
branches;
next	1.2;

1.2
date	2001.04.10.20.08.27;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	99.11.09.01.28.43;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.5.2.1
date	2002.09.27.21.49.03;	author kseitz;	state Exp;
branches;
next	;

1.5.4.1
date	2003.12.14.20.28.43;	author drow;	state Exp;
branches;
next	;

1.4.16.1
date	2002.12.23.19.40.18;	author carlton;	state Exp;
branches;
next	1.4.16.2;

1.4.16.2
date	2003.02.07.19.18.11;	author carlton;	state Exp;
branches;
next	1.4.16.3;

1.4.16.3
date	2003.03.06.00.56.43;	author carlton;	state Exp;
branches;
next	;

1.1.1.1
date	99.11.09.01.28.43;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2000.02.01.03.15.26;	author jsm;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2001.09.09.22.40.55;	author irox;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.09.24.19.55.58;	author kseitz;	state Exp;
branches;
next	1.1.1.5;

1.1.1.5
date	2002.11.26.20.00.14;	author hunt;	state Exp;
branches;
next	;


desc
@@


1.8
log
@2003-02-06  Martin M. Hunt  <hunt@@redhat.com>

	* win/tcl.m4 (SC_CONFIG_CFLAGS): Don't default to -O.
	* unix/tcl.m4 (SC_CONFIG_CFLAGS): Don't default to -O.
	CFLAGS gets set to "-O2" by default in top level
	configure. Adding "-O" here causes the "-O2" to be
	ignored, but only when the user types "make" within
	the tcl subdirectory. This caused some confusion.
	* win/configure: Rebuilt.
	* unix/configure: Rebuilt.

	* generic/tclEnv.c (TclUnsetEnv): Cast arg to unsigned.

	Import from latest tcl sources to fix a bug with
	"file copy"
	2003-01-25  Mo DeJong  <mdejong@@users.sourceforge.net>
	* win/tclWinFCmd.c (DoRenameFile, DoCopyFile, squelch_warnings):
	Re-implement inline ASM SEH handlers for gcc.
	The esp and ebp registers are now saved on the
	stack instead of in global variables so that
	the code is thread safe. Add additional checks
	when TCL_MEM_DEBUG is defined to be sure the
	values were recovered from the stack properly.
	Remove squelch_warnings functions and add
	a dummy call in the handler methods to squelch
	compiler warnings.
	* win/tclWinReg.c: Add casts to avoid compiler
	warning. Fix assignment in if expression bug.
@
text
@/* 
 * tclEnv.c --
 *
 *	Tcl support for environment variables, including a setenv
 *	procedure.  This file contains the generic portion of the
 *	environment module.  It is primarily responsible for keeping
 *	the "env" arrays in sync with the system environment variables.
 *
 * Copyright (c) 1991-1994 The Regents of the University of California.
 * Copyright (c) 1994-1998 Sun Microsystems, Inc.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tclEnv.c,v 1.19 2002/10/14 22:25:10 hobbs Exp $
 */

#include "tclInt.h"
#include "tclPort.h"

TCL_DECLARE_MUTEX(envMutex)	/* To serialize access to environ */

static int cacheSize = 0;	/* Number of env strings in environCache. */
static char **environCache = NULL;
				/* Array containing all of the environment
				 * strings that Tcl has allocated. */

#ifndef USE_PUTENV
static int environSize = 0;	/* Non-zero means that the environ array was
				 * malloced and has this many total entries
				 * allocated to it (not all may be in use at
				 * once).  Zero means that the environment
				 * array is in its original static state. */
#endif

/*
 * For MacOS X
 */
#if defined(__APPLE__) && defined(__DYNAMIC__)
#include <crt_externs.h>
char **environ = NULL;
#endif

/*
 * Declarations for local procedures defined in this file:
 */

static char *		EnvTraceProc _ANSI_ARGS_((ClientData clientData,
			    Tcl_Interp *interp, CONST char *name1, 
			    CONST char *name2, int flags));
static void		ReplaceString _ANSI_ARGS_((CONST char *oldStr,
			    char *newStr));
void			TclSetEnv _ANSI_ARGS_((CONST char *name,
			    CONST char *value));
void			TclUnsetEnv _ANSI_ARGS_((CONST char *name));

#if defined (__CYGWIN__) && defined(__WIN32__)
static void		TclCygwinPutenv _ANSI_ARGS_((CONST char *string));
#endif

/*
 *----------------------------------------------------------------------
 *
 * TclSetupEnv --
 *
 *	This procedure is invoked for an interpreter to make environment
 *	variables accessible from that interpreter via the "env"
 *	associative array.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The interpreter is added to a list of interpreters managed
 *	by us, so that its view of envariables can be kept consistent
 *	with the view in other interpreters.  If this is the first
 *	call to TclSetupEnv, then additional initialization happens,
 *	such as copying the environment to dynamically-allocated space
 *	for ease of management.
 *
 *----------------------------------------------------------------------
 */

void
TclSetupEnv(interp)
    Tcl_Interp *interp;		/* Interpreter whose "env" array is to be
				 * managed. */
{
    Tcl_DString envString;
    char *p1, *p2;
    int i;

    /*
     * For MacOS X
     */
#if defined(__APPLE__) && defined(__DYNAMIC__)
    environ = *_NSGetEnviron();
#endif

    /*
     * Synchronize the values in the environ array with the contents
     * of the Tcl "env" variable.  To do this:
     *    1) Remove the trace that fires when the "env" var is unset.
     *    2) Unset the "env" variable.
     *    3) If there are no environ variables, create an empty "env"
     *       array.  Otherwise populate the array with current values.
     *    4) Add a trace that synchronizes the "env" array.
     */
    
    Tcl_UntraceVar2(interp, "env", (char *) NULL,
	    TCL_GLOBAL_ONLY | TCL_TRACE_WRITES | TCL_TRACE_UNSETS |
	    TCL_TRACE_READS | TCL_TRACE_ARRAY,  EnvTraceProc,
	    (ClientData) NULL);
    
    Tcl_UnsetVar2(interp, "env", (char *) NULL, TCL_GLOBAL_ONLY); 
    
    if (environ[0] == NULL) {
	Tcl_Obj *varNamePtr;
	
	varNamePtr = Tcl_NewStringObj("env", -1);
	Tcl_IncrRefCount(varNamePtr);
	TclArraySet(interp, varNamePtr, NULL);	
	Tcl_DecrRefCount(varNamePtr);
    } else {
	Tcl_MutexLock(&envMutex);
	for (i = 0; environ[i] != NULL; i++) {
	    p1 = Tcl_ExternalToUtfDString(NULL, environ[i], -1, &envString);
	    p2 = strchr(p1, '=');
	    if (p2 == NULL) {
		/*
		 * This condition seem to happen occasionally under some
		 * versions of Solaris; ignore the entry.
		 */
		
		continue;
	    }
	    p2++;
	    p2[-1] = '\0';
	    Tcl_SetVar2(interp, "env", p1, p2, TCL_GLOBAL_ONLY);	
	    Tcl_DStringFree(&envString);
	}
	Tcl_MutexUnlock(&envMutex);
    }

    Tcl_TraceVar2(interp, "env", (char *) NULL,
	    TCL_GLOBAL_ONLY | TCL_TRACE_WRITES | TCL_TRACE_UNSETS |
	    TCL_TRACE_READS | TCL_TRACE_ARRAY,  EnvTraceProc,
	    (ClientData) NULL);
}

/*
 *----------------------------------------------------------------------
 *
 * TclSetEnv --
 *
 *	Set an environment variable, replacing an existing value
 *	or creating a new variable if there doesn't exist a variable
 *	by the given name.  This procedure is intended to be a
 *	stand-in for the  UNIX "setenv" procedure so that applications
 *	using that procedure will interface properly to Tcl.  To make
 *	it a stand-in, the Makefile must define "TclSetEnv" to "setenv".
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The environ array gets updated.
 *
 *----------------------------------------------------------------------
 */

void
TclSetEnv(name, value)
    CONST char *name;		/* Name of variable whose value is to be
				 * set (UTF-8). */
    CONST char *value;		/* New value for variable (UTF-8). */
{
    Tcl_DString envString;
    int index, length, nameLength;
    char *p, *oldValue;
    CONST char *p2;

    /*
     * Figure out where the entry is going to go.  If the name doesn't
     * already exist, enlarge the array if necessary to make room.  If the
     * name exists, free its old entry.
     */

    Tcl_MutexLock(&envMutex);
    index = TclpFindVariable(name, &length);

    if (index == -1) {
#ifndef USE_PUTENV
	if ((length + 2) > environSize) {
	    char **newEnviron;

	    newEnviron = (char **) ckalloc((unsigned)
		    ((length + 5) * sizeof(char *)));
	    memcpy((VOID *) newEnviron, (VOID *) environ,
		    length*sizeof(char *));
	    if (environSize != 0) {
		ckfree((char *) environ);
	    }
	    environ = newEnviron;
	    environSize = length + 5;
#if defined(__APPLE__) && defined(__DYNAMIC__)
	    {
	    char ***e = _NSGetEnviron();
	    *e = environ;
	    }
#endif
	}
	index = length;
	environ[index + 1] = NULL;
#endif
	oldValue = NULL;
	nameLength = strlen(name);
    } else {
	CONST char *env;

	/*
	 * Compare the new value to the existing value.  If they're
	 * the same then quit immediately (e.g. don't rewrite the
	 * value or propagate it to other interpreters).  Otherwise,
	 * when there are N interpreters there will be N! propagations
	 * of the same value among the interpreters.
	 */

	env = Tcl_ExternalToUtfDString(NULL, environ[index], -1, &envString);
	if (strcmp(value, (env + length + 1)) == 0) {
	    Tcl_DStringFree(&envString);
	    Tcl_MutexUnlock(&envMutex);
	    return;
	}
	Tcl_DStringFree(&envString);

	oldValue = environ[index];
	nameLength = length;
    }
	

    /*
     * Create a new entry.  Build a complete UTF string that contains
     * a "name=value" pattern.  Then convert the string to the native
     * encoding, and set the environ array value.
     */

    p = (char *) ckalloc((unsigned) (nameLength + strlen(value) + 2));
    strcpy(p, name);
    p[nameLength] = '=';
    strcpy(p+nameLength+1, value);
    p2 = Tcl_UtfToExternalDString(NULL, p, -1, &envString);

    /*
     * Copy the native string to heap memory.
     */
    
    p = (char *) ckrealloc(p, (unsigned) (strlen(p2) + 1));
    strcpy(p, p2);
    Tcl_DStringFree(&envString);

#ifdef USE_PUTENV
    /*
     * Update the system environment.
     */

    putenv(p);
    index = TclpFindVariable(name, &length);
#else
    environ[index] = p;
#endif

    /*
     * Watch out for versions of putenv that copy the string (e.g. VC++).
     * In this case we need to free the string immediately.  Otherwise
     * update the string in the cache.
     */

    if ((index != -1) && (environ[index] == p)) {
	ReplaceString(oldValue, p);
#ifdef HAVE_PUTENV_THAT_COPIES
    } else {
	/* This putenv() copies instead of taking ownership */
	ckfree(p);
#endif
    }

    Tcl_MutexUnlock(&envMutex);
    
    if (!strcmp(name, "HOME")) {
	/* 
	 * If the user's home directory has changed, we must invalidate
	 * the filesystem cache, because '~' expansions will now be
	 * incorrect.
	 */
        Tcl_FSMountsChanged(NULL);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_PutEnv --
 *
 *	Set an environment variable.  Similar to setenv except that
 *	the information is passed in a single string of the form
 *	NAME=value, rather than as separate name strings.  This procedure
 *	is intended to be a stand-in for the  UNIX "putenv" procedure
 *	so that applications using that procedure will interface
 *	properly to Tcl.  To make it a stand-in, the Makefile will
 *	define "Tcl_PutEnv" to "putenv".
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The environ array gets updated, as do all of the interpreters
 *	that we manage.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_PutEnv(string)
    CONST char *string;		/* Info about environment variable in the
				 * form NAME=value. (native) */
{
    Tcl_DString nameString;   
    CONST char *name;
    char *value;

    if (string == NULL) {
	return 0;
    }

    /*
     * First convert the native string to UTF.  Then separate the
     * string into name and value parts, and call TclSetEnv to do
     * all of the real work.
     */

    name = Tcl_ExternalToUtfDString(NULL, string, -1, &nameString);
    value = strchr(name, '=');

    if ((value != NULL) && (value != name)) {
	value[0] = '\0';
	TclSetEnv(name, value+1);
    }

    Tcl_DStringFree(&nameString);
    return 0;
}

/*
 *----------------------------------------------------------------------
 *
 * TclUnsetEnv --
 *
 *	Remove an environment variable, updating the "env" arrays
 *	in all interpreters managed by us.  This function is intended
 *	to replace the UNIX "unsetenv" function (but to do this the
 *	Makefile must be modified to redefine "TclUnsetEnv" to
 *	"unsetenv".
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Interpreters are updated, as is environ.
 *
 *----------------------------------------------------------------------
 */

void
TclUnsetEnv(name)
    CONST char *name;		/* Name of variable to remove (UTF-8). */
{
    char *oldValue;
    int length;
    int index;
#ifdef USE_PUTENV
    Tcl_DString envString;
    char *string;
#else
    char **envPtr;
#endif

    Tcl_MutexLock(&envMutex);
    index = TclpFindVariable(name, &length);

    /*
     * First make sure that the environment variable exists to avoid
     * doing needless work and to avoid recursion on the unset.
     */
    
    if (index == -1) {
	Tcl_MutexUnlock(&envMutex);
	return;
    }
    /*
     * Remember the old value so we can free it if Tcl created the string.
     */

    oldValue = environ[index];

    /*
     * Update the system environment.  This must be done before we 
     * update the interpreters or we will recurse.
     */

#ifdef USE_PUTENV
    string = ckalloc((unsigned int) length+2);
    memcpy((VOID *) string, (VOID *) name, (size_t) length);
    string[length] = '=';
    string[length+1] = '\0';
    
    Tcl_UtfToExternalDString(NULL, string, -1, &envString);
    string = ckrealloc(string, (unsigned) (Tcl_DStringLength(&envString)+1));
    strcpy(string, Tcl_DStringValue(&envString));
    Tcl_DStringFree(&envString);

    putenv(string);

    /*
     * Watch out for versions of putenv that copy the string (e.g. VC++).
     * In this case we need to free the string immediately.  Otherwise
     * update the string in the cache.
     */

    if (environ[index] == string) {
	ReplaceString(oldValue, string);
    }
#else
    for (envPtr = environ+index+1; ; envPtr++) {
	envPtr[-1] = *envPtr;
	if (*envPtr == NULL) {
	    break;
	}
    }
    ReplaceString(oldValue, NULL);
#endif

    Tcl_MutexUnlock(&envMutex);
}

/*
 *---------------------------------------------------------------------------
 *
 * TclGetEnv --
 *
 *	Retrieve the value of an environment variable.
 *
 * Results:
 *	The result is a pointer to a string specifying the value of the
 *	environment variable, or NULL if that environment variable does
 *	not exist.  Storage for the result string is allocated in valuePtr;
 *	the caller must call Tcl_DStringFree() when the result is no
 *	longer needed.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

CONST char *
TclGetEnv(name, valuePtr)
    CONST char *name;		/* Name of environment variable to find
				 * (UTF-8). */
    Tcl_DString *valuePtr;	/* Uninitialized or free DString in which
				 * the value of the environment variable is
				 * stored. */
{
    int length, index;
    CONST char *result;

    Tcl_MutexLock(&envMutex);
    index = TclpFindVariable(name, &length);
    result = NULL;
    if (index != -1) {
	Tcl_DString envStr;
	
	result = Tcl_ExternalToUtfDString(NULL, environ[index], -1, &envStr);
	result += length;
	if (*result == '=') {
	    result++;
	    Tcl_DStringInit(valuePtr);
	    Tcl_DStringAppend(valuePtr, result, -1);
	    result = Tcl_DStringValue(valuePtr);
	} else {
	    result = NULL;
	}
	Tcl_DStringFree(&envStr);
    }
    Tcl_MutexUnlock(&envMutex);
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * EnvTraceProc --
 *
 *	This procedure is invoked whenever an environment variable
 *	is read, modified or deleted.  It propagates the change to the global
 *	"environ" array.
 *
 * Results:
 *	Always returns NULL to indicate success.
 *
 * Side effects:
 *	Environment variable changes get propagated.  If the whole
 *	"env" array is deleted, then we stop managing things for
 *	this interpreter (usually this happens because the whole
 *	interpreter is being deleted).
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
static char *
EnvTraceProc(clientData, interp, name1, name2, flags)
    ClientData clientData;	/* Not used. */
    Tcl_Interp *interp;		/* Interpreter whose "env" variable is
				 * being modified. */
    CONST char *name1;		/* Better be "env". */
    CONST char *name2;		/* Name of variable being modified, or NULL
				 * if whole array is being deleted (UTF-8). */
    int flags;			/* Indicates what's happening. */
{
    /*
     * For array traces, let TclSetupEnv do all the work.
     */

    if (flags & TCL_TRACE_ARRAY) {
	TclSetupEnv(interp);
	return NULL;
    }

    /*
     * If name2 is NULL, then return and do nothing.
     */
     
    if (name2 == NULL) {
	return NULL;
    }

    /*
     * If a value is being set, call TclSetEnv to do all of the work.
     */

    if (flags & TCL_TRACE_WRITES) {
	CONST char *value;
	
	value = Tcl_GetVar2(interp, "env", name2, TCL_GLOBAL_ONLY);
	TclSetEnv(name2, value);
    }

    /*
     * If a value is being read, call TclGetEnv to do all of the work.
     */

    if (flags & TCL_TRACE_READS) {
	Tcl_DString valueString;
	CONST char *value;

	value = TclGetEnv(name2, &valueString);
	if (value == NULL) {
	    return "no such variable";
	}
	Tcl_SetVar2(interp, name1, name2, value, 0);
	Tcl_DStringFree(&valueString);
    }

    /*
     * For unset traces, let TclUnsetEnv do all the work.
     */

    if (flags & TCL_TRACE_UNSETS) {
	TclUnsetEnv(name2);
    }
    return NULL;
}

/*
 *----------------------------------------------------------------------
 *
 * ReplaceString --
 *
 *	Replace one string with another in the environment variable
 *	cache.  The cache keeps track of all of the environment
 *	variables that Tcl has modified so they can be freed later.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	May free the old string.
 *
 *----------------------------------------------------------------------
 */

static void
ReplaceString(oldStr, newStr)
    CONST char *oldStr;		/* Old environment string. */
    char *newStr;		/* New environment string. */
{
    int i;
    char **newCache;

    /*
     * Check to see if the old value was allocated by Tcl.  If so,
     * it needs to be deallocated to avoid memory leaks.  Note that this
     * algorithm is O(n), not O(1).  This will result in n-squared behavior
     * if lots of environment changes are being made.
     */

    for (i = 0; i < cacheSize; i++) {
	if ((environCache[i] == oldStr) || (environCache[i] == NULL)) {
	    break;
	}
    }
    if (i < cacheSize) {
	/*
	 * Replace or delete the old value.
	 */

	if (environCache[i]) {
	    ckfree(environCache[i]);
	}
	    
	if (newStr) {
	    environCache[i] = newStr;
	} else {
	    for (; i < cacheSize-1; i++) {
		environCache[i] = environCache[i+1];
	    }
	    environCache[cacheSize-1] = NULL;
	}
    } else {	
        int allocatedSize = (cacheSize + 5) * sizeof(char *);

	/*
	 * We need to grow the cache in order to hold the new string.
	 */

	newCache = (char **) ckalloc((unsigned) allocatedSize);
        (VOID *) memset(newCache, (int) 0, (size_t) allocatedSize);
        
	if (environCache) {
	    memcpy((VOID *) newCache, (VOID *) environCache,
		    (size_t) (cacheSize * sizeof(char*)));
	    ckfree((char *) environCache);
	}
	environCache = newCache;
	environCache[cacheSize] = newStr;
	environCache[cacheSize+1] = NULL;
	cacheSize += 5;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * TclFinalizeEnvironment --
 *
 *	This function releases any storage allocated by this module
 *	that isn't still in use by the global environment.  Any
 *	strings that are still in the environment will be leaked.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	May deallocate storage.
 *
 *----------------------------------------------------------------------
 */

void
TclFinalizeEnvironment()
{
    /*
     * For now we just deallocate the cache array and none of the environment
     * strings.  This may leak more memory that strictly necessary, since some
     * of the strings may no longer be in the environment.  However,
     * determining which ones are ok to delete is n-squared, and is pretty
     * unlikely, so we don't bother.
     */

    if (environCache) {
	ckfree((char *) environCache);
	environCache = NULL;
	cacheSize    = 0;
#ifndef USE_PUTENV
	environSize  = 0;
#endif
    }
}

#if defined(__CYGWIN__) && defined(__WIN32__)

#include <windows.h>

/*
 * When using cygwin, when an environment variable changes, we need to synch
 * with both the cygwin environment (in case the application C code calls
 * fork) and the Windows environment (in case the application TCL code calls
 * exec, which calls the Windows CreateProcess function).
 */

static void
TclCygwinPutenv(str)
    const char *str;
{
    char *name, *value;

    /* Get the name and value, so that we can change the environment
       variable for Windows.  */
    name = (char *) alloca (strlen (str) + 1);
    strcpy (name, str);
    for (value = name; *value != '=' && *value != '\0'; ++value)
	;
    if (*value == '\0') {
	    /* Can't happen.  */
	    return;
	}
    *value = '\0';
    ++value;
    if (*value == '\0') {
	value = NULL;
    }

    /* Set the cygwin environment variable.  */
#undef putenv
    if (value == NULL) {
	unsetenv (name);
    } else {
	putenv(str);
    }

    /*
     * Before changing the environment variable in Windows, if this is PATH,
     * we need to convert the value back to a Windows style path.
     *
     * FIXME: The calling program may know it is running under windows, and
     * may have set the path to a Windows path, or, worse, appended or
     * prepended a Windows path to PATH.
     */
    if (strcmp (name, "PATH") != 0) {
	/* If this is Path, eliminate any PATH variable, to prevent any
	   confusion.  */
	if (strcmp (name, "Path") == 0) {
	    SetEnvironmentVariable ("PATH", (char *) NULL);
	    unsetenv ("PATH");
	}

	SetEnvironmentVariable (name, value);
    } else {
	char *buf;

	    /* Eliminate any Path variable, to prevent any confusion.  */
	SetEnvironmentVariable ("Path", (char *) NULL);
	unsetenv ("Path");

	if (value == NULL) {
	    buf = NULL;
	} else {
	    int size;

	    size = cygwin_posix_to_win32_path_list_buf_size (value);
	    buf = (char *) alloca (size + 1);
	    cygwin_posix_to_win32_path_list (value, buf);
	}

	SetEnvironmentVariable (name, buf);
    }
}

#endif /* __CYGWIN__ && __WIN32__ */
@


1.7
log
@Updated to tcl 8.4.1
@
text
@d412 1
a412 1
    string = ckalloc(length+2);
@


1.6
log
@touched all sources to ease next import
@
text
@d15 1
a15 1
 * RCS: @@(#) $Id: tclEnv.c,v 1.6.8.4 2000/09/15 16:55:09 spolk Exp $
a22 22
/* CYGNUS LOCAL */
#if defined(__CYGWIN__) && defined(__WIN32__)

/* Under cygwin, the environment is imported from the cygwin DLL.  */

__declspec(dllimport) extern char **__cygwin_environ;

#define environ (__cygwin_environ)

/* We need to use a special putenv function to handle PATH.  */
#ifndef USE_PUTENV
#define USE_PUTENV
#endif
#define putenv TclCygwin32Putenv
#endif
/* END CYGNUS LOCAL */

#ifdef TCL_THREADS

static Tcl_Mutex envMutex;	/* To serialize access to environ */
#endif

d49 2
a50 2
			    Tcl_Interp *interp, char *name1, char *name2,
			    int flags));
a56 1
/* CYGNUS LOCAL */
d58 1
a58 1
static void		TclCygwin32Putenv _ANSI_ARGS_((CONST char *string));
d180 2
a181 1
    char *p, *p2, *oldValue;
a198 6

	    /* CYGNUS LOCAL: Added to avoid an error from Purify,
               although I don't personally see where the error would
               occur--ian.  */
	    memset((VOID *) newEnviron, 0, (length+5) * sizeof(char *));

d206 6
d219 1
a219 1
	char *env;
d281 5
d289 9
d329 2
a330 2
    int nameLength;
    char *name, *value;
d344 4
a347 6
    if (value == NULL) {
	return 0;
    }
    nameLength = value - name;
    if (nameLength == 0) {
	return 0;
a349 2
    value[0] = '\0';
    TclSetEnv(name, value+1);
d379 1
a379 1
    unsigned int length;
d466 1
a466 1
char *
d475 1
a475 1
    char *result;
d526 2
a527 2
    char *name1;		/* Better be "env". */
    char *name2;		/* Name of variable being modified, or NULL
d553 1
a553 1
	char *value;
d565 1
a565 1
	char *value;
d656 1
a656 1
	environCache[cacheSize] = (char *) newStr;
a700 1
/* CYGNUS LOCAL */
d703 1
a703 1
#include "windows.h"
d705 6
a710 5
/* When using cygwin, when an environment variable changes, we need
   to synch with both the cygwin environment (in case the
   application C code calls fork) and the Windows environment (in case
   the application TCL code calls exec, which calls the Windows
   CreateProcess function).  */
d713 2
a714 2
TclCygwin32Putenv(str)
     const char *str;
d716 1
a716 1
  char *name, *value;
d718 15
a732 15
  /* Get the name and value, so that we can change the environment
     variable for Windows.  */
  name = (char *) alloca (strlen (str) + 1);
  strcpy (name, str);
  for (value = name; *value != '=' && *value != '\0'; ++value)
    ;
  if (*value == '\0')
    {
      /* Can't happen.  */
      return;
    }
  *value = '\0';
  ++value;
  if (*value == '\0')
    value = NULL;
d734 1
a734 1
  /* Set the cygwin environment variable.  */
d736 38
a773 40
  if (value == NULL)
    unsetenv (name);
  else
    putenv(str);

  /* Before changing the environment variable in Windows, if this is
     PATH, we need to convert the value back to a Windows style path.

     FIXME: The calling program may now it is running under windows,
     and may have set the path to a Windows path, or, worse, appended
     or prepended a Windows path to PATH.  */
  if (strcmp (name, "PATH") != 0)
    {
      /* If this is Path, eliminate any PATH variable, to prevent any
         confusion.  */
      if (strcmp (name, "Path") == 0)
	{
	  SetEnvironmentVariable ("PATH", (char *) NULL);
	  unsetenv ("PATH");
	}

      SetEnvironmentVariable (name, value);
    }
  else
    {
      char *buf;

      /* Eliminate any Path variable, to prevent any confusion.  */
      SetEnvironmentVariable ("Path", (char *) NULL);
      unsetenv ("Path");

      if (value == NULL)
	buf = NULL;
      else
	{
	  int size;

	  size = cygwin_posix_to_win32_path_list_buf_size (value);
	  buf = (char *) alloca (size + 1);
	  cygwin_posix_to_win32_path_list (value, buf);
d776 1
a776 1
      SetEnvironmentVariable (name, buf);
d780 1
a780 3
#endif /* __CYGWIN__ */
/* END CYGNUS LOCAL */

@


1.5
log
@touched all sources to ease next import
@
text
@@


1.5.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d15 1
a15 1
 * RCS: @@(#) $Id: tclEnv.c,v 1.19 2002/10/14 22:25:10 hobbs Exp $
d23 22
d71 2
a72 2
			    Tcl_Interp *interp, CONST char *name1, 
			    CONST char *name2, int flags));
d79 1
d81 1
a81 1
static void		TclCygwinPutenv _ANSI_ARGS_((CONST char *string));
d203 1
a203 2
    char *p, *oldValue;
    CONST char *p2;
d221 6
a233 6
#if defined(__APPLE__) && defined(__DYNAMIC__)
	    {
	    char ***e = _NSGetEnviron();
	    *e = environ;
	    }
#endif
d241 1
a241 1
	CONST char *env;
a302 5
#ifdef HAVE_PUTENV_THAT_COPIES
    } else {
	/* This putenv() copies instead of taking ownership */
	ckfree(p);
#endif
a305 9
    
    if (!strcmp(name, "HOME")) {
	/* 
	 * If the user's home directory has changed, we must invalidate
	 * the filesystem cache, because '~' expansions will now be
	 * incorrect.
	 */
        Tcl_FSMountsChanged(NULL);
    }
d337 2
a338 2
    CONST char *name;
    char *value;
d352 6
a357 4

    if ((value != NULL) && (value != name)) {
	value[0] = '\0';
	TclSetEnv(name, value+1);
d360 2
d391 1
a391 1
    int length;
d424 1
a424 1
    string = ckalloc((unsigned int) length+2);
d478 1
a478 1
CONST char *
d487 1
a487 1
    CONST char *result;
d538 2
a539 2
    CONST char *name1;		/* Better be "env". */
    CONST char *name2;		/* Name of variable being modified, or NULL
d565 1
a565 1
	CONST char *value;
d577 1
a577 1
	CONST char *value;
d668 1
a668 1
	environCache[cacheSize] = newStr;
d713 1
d716 1
a716 1
#include <windows.h>
d718 5
a722 6
/*
 * When using cygwin, when an environment variable changes, we need to synch
 * with both the cygwin environment (in case the application C code calls
 * fork) and the Windows environment (in case the application TCL code calls
 * exec, which calls the Windows CreateProcess function).
 */
d725 2
a726 2
TclCygwinPutenv(str)
    const char *str;
d728 1
a728 1
    char *name, *value;
d730 15
a744 15
    /* Get the name and value, so that we can change the environment
       variable for Windows.  */
    name = (char *) alloca (strlen (str) + 1);
    strcpy (name, str);
    for (value = name; *value != '=' && *value != '\0'; ++value)
	;
    if (*value == '\0') {
	    /* Can't happen.  */
	    return;
	}
    *value = '\0';
    ++value;
    if (*value == '\0') {
	value = NULL;
    }
d746 1
a746 1
    /* Set the cygwin environment variable.  */
d748 40
a787 38
    if (value == NULL) {
	unsetenv (name);
    } else {
	putenv(str);
    }

    /*
     * Before changing the environment variable in Windows, if this is PATH,
     * we need to convert the value back to a Windows style path.
     *
     * FIXME: The calling program may know it is running under windows, and
     * may have set the path to a Windows path, or, worse, appended or
     * prepended a Windows path to PATH.
     */
    if (strcmp (name, "PATH") != 0) {
	/* If this is Path, eliminate any PATH variable, to prevent any
	   confusion.  */
	if (strcmp (name, "Path") == 0) {
	    SetEnvironmentVariable ("PATH", (char *) NULL);
	    unsetenv ("PATH");
	}

	SetEnvironmentVariable (name, value);
    } else {
	char *buf;

	    /* Eliminate any Path variable, to prevent any confusion.  */
	SetEnvironmentVariable ("Path", (char *) NULL);
	unsetenv ("Path");

	if (value == NULL) {
	    buf = NULL;
	} else {
	    int size;

	    size = cygwin_posix_to_win32_path_list_buf_size (value);
	    buf = (char *) alloca (size + 1);
	    cygwin_posix_to_win32_path_list (value, buf);
d790 1
a790 1
	SetEnvironmentVariable (name, buf);
d794 3
a796 1
#endif /* __CYGWIN__ && __WIN32__ */
@


1.5.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@d15 1
a15 1
 * RCS: @@(#) $Id: tclEnv.c,v 1.17 2002/08/28 22:48:10 davygrvy Exp $
d23 22
d71 2
a72 2
			    Tcl_Interp *interp, CONST char *name1, 
			    CONST char *name2, int flags));
d79 4
d203 1
a203 2
    char *p, *oldValue;
    CONST char *p2;
d221 6
a233 6
#if defined(__APPLE__) && defined(__DYNAMIC__)
	    {
	    char ***e = _NSGetEnviron();
	    *e = environ;
	    }
#endif
d241 1
a241 1
	CONST char *env;
a302 5
#ifdef HAVE_PUTENV_THAT_COPIES
    } else {
	/* This putenv() copies instead of taking ownership */
	ckfree(p);
#endif
a305 9
    
    if (!strcmp(name, "HOME")) {
	/* 
	 * If the user's home directory has changed, we must invalidate
	 * the filesystem cache, because '~' expansions will now be
	 * incorrect.
	 */
        Tcl_FSMountsChanged(NULL);
    }
d338 1
a338 2
    CONST char *name;
    char *value;
d391 1
a391 1
    int length;
d478 1
a478 1
CONST char *
d487 1
a487 1
    CONST char *result;
d538 2
a539 2
    CONST char *name1;		/* Better be "env". */
    CONST char *name2;		/* Name of variable being modified, or NULL
d565 1
a565 1
	CONST char *value;
d577 1
a577 1
	CONST char *value;
d668 1
a668 1
	environCache[cacheSize] = newStr;
d712 85
@


1.4
log
@touched all Tcl files to ease next import.
@
text
@@


1.4.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.4.16.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d23 22
d71 2
a72 2
			    Tcl_Interp *interp, CONST char *name1, 
			    CONST char *name2, int flags));
d79 1
d81 1
a81 1
static void		TclCygwinPutenv _ANSI_ARGS_((CONST char *string));
d203 1
a203 2
    char *p, *oldValue;
    CONST char *p2;
d221 6
a233 6
#if defined(__APPLE__) && defined(__DYNAMIC__)
	    {
	    char ***e = _NSGetEnviron();
	    *e = environ;
	    }
#endif
d241 1
a241 1
	CONST char *env;
a302 5
#ifdef HAVE_PUTENV_THAT_COPIES
    } else {
	/* This putenv() copies instead of taking ownership */
	ckfree(p);
#endif
a305 9
    
    if (!strcmp(name, "HOME")) {
	/* 
	 * If the user's home directory has changed, we must invalidate
	 * the filesystem cache, because '~' expansions will now be
	 * incorrect.
	 */
        Tcl_FSMountsChanged(NULL);
    }
d337 2
a338 2
    CONST char *name;
    char *value;
d352 6
a357 4

    if ((value != NULL) && (value != name)) {
	value[0] = '\0';
	TclSetEnv(name, value+1);
d360 2
d391 1
a391 1
    int length;
d478 1
a478 1
CONST char *
d487 1
a487 1
    CONST char *result;
d538 2
a539 2
    CONST char *name1;		/* Better be "env". */
    CONST char *name2;		/* Name of variable being modified, or NULL
d565 1
a565 1
	CONST char *value;
d577 1
a577 1
	CONST char *value;
d668 1
a668 1
	environCache[cacheSize] = newStr;
d713 1
d716 1
a716 1
#include <windows.h>
d718 5
a722 6
/*
 * When using cygwin, when an environment variable changes, we need to synch
 * with both the cygwin environment (in case the application C code calls
 * fork) and the Windows environment (in case the application TCL code calls
 * exec, which calls the Windows CreateProcess function).
 */
d725 2
a726 2
TclCygwinPutenv(str)
    const char *str;
d728 1
a728 1
    char *name, *value;
d730 15
a744 15
    /* Get the name and value, so that we can change the environment
       variable for Windows.  */
    name = (char *) alloca (strlen (str) + 1);
    strcpy (name, str);
    for (value = name; *value != '=' && *value != '\0'; ++value)
	;
    if (*value == '\0') {
	    /* Can't happen.  */
	    return;
	}
    *value = '\0';
    ++value;
    if (*value == '\0') {
	value = NULL;
    }
d746 1
a746 1
    /* Set the cygwin environment variable.  */
d748 40
a787 38
    if (value == NULL) {
	unsetenv (name);
    } else {
	putenv(str);
    }

    /*
     * Before changing the environment variable in Windows, if this is PATH,
     * we need to convert the value back to a Windows style path.
     *
     * FIXME: The calling program may know it is running under windows, and
     * may have set the path to a Windows path, or, worse, appended or
     * prepended a Windows path to PATH.
     */
    if (strcmp (name, "PATH") != 0) {
	/* If this is Path, eliminate any PATH variable, to prevent any
	   confusion.  */
	if (strcmp (name, "Path") == 0) {
	    SetEnvironmentVariable ("PATH", (char *) NULL);
	    unsetenv ("PATH");
	}

	SetEnvironmentVariable (name, value);
    } else {
	char *buf;

	    /* Eliminate any Path variable, to prevent any confusion.  */
	SetEnvironmentVariable ("Path", (char *) NULL);
	unsetenv ("Path");

	if (value == NULL) {
	    buf = NULL;
	} else {
	    int size;

	    size = cygwin_posix_to_win32_path_list_buf_size (value);
	    buf = (char *) alloca (size + 1);
	    cygwin_posix_to_win32_path_list (value, buf);
d790 1
a790 1
	SetEnvironmentVariable (name, buf);
d794 3
a796 1
#endif /* __CYGWIN__ && __WIN32__ */
@


1.4.16.3
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d412 1
a412 1
    string = ckalloc((unsigned int) length+2);
@


1.3
log
@Tcl8.3 upgrade merge.
@
text
@@


1.2
log
@Fixes for newer cygwin gccs.
Use modern Cygwin conditional.
@
text
@d10 1
a10 1
 * Copyright (c) 1994-1996 Sun Microsystems, Inc.
d15 1
a15 1
 * RCS: @@(#) $Id: tclEnv.c,v 1.21 2000/01/26 20:03:51 dj Exp $
d21 2
d28 1
a28 1
extern char ***_imp____cygwin_environ;
d30 1
a30 1
#define environ (*_imp____cygwin_environ)
a36 1

d40 4
a43 17
/*
 * The structure below is used to keep track of all of the interpereters
 * for which we're managing the "env" array.  It's needed so that they
 * can all be updated whenever an environment variable is changed
 * anywhere.
 */

typedef struct EnvInterp {
    Tcl_Interp *interp;		/* Interpreter for which we're managing
				 * the env array. */
    struct EnvInterp *nextPtr;	/* Next in list of all such interpreters,
				 * or zero. */
} EnvInterp;

static EnvInterp *firstInterpPtr = NULL;
				/* First in list of all managed interpreters,
				 * or NULL if none. */
d59 8
a72 2
static int		FindVariable _ANSI_ARGS_((CONST char *name,
			    int *lengthPtr));
d100 1
a100 1
 *	call to Tcl_SetupEnv, then additional initialization happens,
d112 3
a114 4
    EnvInterp *eiPtr;
    char *p, *p2;
    Tcl_DString ds;
    int i, sz;
d116 5
a120 4
#ifdef MAC_TCL
    if (environ == NULL) {
	environSize = TclMacCreateEnv();
    }
d124 7
a130 2
     * Next, initialize the DString we are going to use for copying
     * the names of the environment variables.
a131 2

    Tcl_DStringInit(&ds);
d133 20
a152 23
    /*
     * Next, add the interpreter to the list of those that we manage.
     */

    eiPtr = (EnvInterp *) ckalloc(sizeof(EnvInterp));
    eiPtr->interp = interp;
    eiPtr->nextPtr = firstInterpPtr;
    firstInterpPtr = eiPtr;

    /*
     * Store the environment variable values into the interpreter's
     * "env" array, and arrange for us to be notified on future
     * writes and unsets to that array.
     */

    (void) Tcl_UnsetVar2(interp, "env", (char *) NULL, TCL_GLOBAL_ONLY);
    for (i = 0; ; i++) {
	p = environ[i];
	if (p == NULL) {
	    break;
	}
	for (p2 = p; *p2 != '='; p2++) {
	    if (*p2 == 0) {
d154 1
a154 2
		 * This condition doesn't seem like it should ever happen,
		 * but it does seem to happen occasionally under some
d157 2
a158 2

		goto nextEntry;
d160 4
d165 1
a165 7
        sz = p2 - p;
        Tcl_DStringSetLength(&ds, 0);
        Tcl_DStringAppend(&ds, p, sz);
	(void) Tcl_SetVar2(interp, "env", Tcl_DStringValue(&ds),
                p2+1, TCL_GLOBAL_ONLY);
	nextEntry:
	continue;
d167 1
d169 3
a171 8
	    TCL_GLOBAL_ONLY | TCL_TRACE_WRITES | TCL_TRACE_UNSETS,
	    EnvTraceProc, (ClientData) NULL);

    /*
     * Finally clean up the DString.
     */

    Tcl_DStringFree(&ds);
d190 1
a190 2
 *	The environ array gets updated, as do all of the interpreters
 *	that we manage.
d198 2
a199 2
				 * set. */
    CONST char *value;		/* New value for variable. */
d201 1
d203 1
a203 8
    char *p, *oldValue;
    EnvInterp *eiPtr;

#ifdef MAC_TCL
    if (environ == NULL) {
	environSize = TclMacCreateEnv();
    }
#endif
d207 2
a208 2
     * already exist, enlarge the array if necessary to make room.  If
     * the name exists, free its old entry.
d211 3
a213 1
    index = FindVariable(name, &length);
d216 1
a216 1
	if ((length+2) > environSize) {
d220 1
a220 1
		    ((length+5) * sizeof(char *)));
d233 1
a233 1
	    environSize = length+5;
d236 1
a236 1
	environ[index+1] = NULL;
d241 2
d251 4
a254 1
	if (strcmp(value, environ[index]+length+1) == 0) {
d257 2
d265 3
a267 1
     * Create a new entry.
d274 9
d284 1
a288 1
#ifdef USE_PUTENV
d290 1
d296 3
a298 7
     * Replace the old value with the new value in the cache.
     */

    ReplaceString(oldValue, p);

    /*
     * Update all of the interpreters.
d301 2
a302 16
    /* CYGNUS LOCAL: The original code was bogus.  If we are being
       called because of a trace on the env array, then the call to
       Tcl_SetVar2 would free value.  We avoid that by checking
       whether the value is the same before calling Tcl_SetVar2.

       NOTE: This is not necessary in tcl8.1a2 which handles this in a
       completely different, and better, way.  */

    for (eiPtr= firstInterpPtr; eiPtr != NULL; eiPtr = eiPtr->nextPtr) {
	CONST char *v;

	v = Tcl_GetVar2(eiPtr->interp, "env", (char *) name, TCL_GLOBAL_ONLY);
	if (v == NULL || (v != value && strcmp (v, value) != 0)) {
	    (void) Tcl_SetVar2(eiPtr->interp, "env", (char *) name,
		    (char *) value, TCL_GLOBAL_ONLY);
	}
d305 1
d334 1
a334 1
				 * form NAME=value. */
d336 1
d345 3
a347 2
     * Separate the string into name and value parts, then call
     * TclSetEnv to do all of the real work.
d350 2
a351 1
    value = strchr(string, '=');
d355 1
a355 1
    nameLength = value - string;
d359 2
a360 3
    name = (char *) ckalloc((unsigned) nameLength+1);
    memcpy((VOID *) name, (VOID *) string, (size_t) nameLength);
    name[nameLength] = 0;
d362 1
a362 1
    ckfree(name);
d388 1
a388 1
    CONST char *name;			/* Name of variable to remove. */
a389 1
    EnvInterp *eiPtr;
d391 2
a392 1
    int length, index;
d394 1
d400 2
a401 7
#ifdef MAC_TCL
    if (environ == NULL) {
	environSize = TclMacCreateEnv();
    }
#endif

    index = FindVariable(name, &length);
d409 1
d428 6
d435 10
a444 1
    ckfree(string);
d452 1
d455 1
a455 14
    /*
     * Replace the old value in the cache.
     */

    ReplaceString(oldValue, NULL);

    /*
     * Update all of the interpreters.
     */

    for (eiPtr = firstInterpPtr; eiPtr != NULL; eiPtr = eiPtr->nextPtr) {
	(void) Tcl_UnsetVar2(eiPtr->interp, "env", (char *) name,
		TCL_GLOBAL_ONLY);
    }
d459 1
a459 1
 *----------------------------------------------------------------------
d466 5
a470 2
 *	Returns a pointer to a static string in the environment,
 *	or NULL if the value was not found.
d479 6
a484 2
TclGetEnv(name)
    CONST char *name;		/* Name of variable to find. */
d487 1
d489 17
a505 11
#ifdef MAC_TCL
    if (environ == NULL) {
	environSize = TclMacCreateEnv();
    }
#endif

    index = FindVariable(name, &length);
    if ((index != -1) &&  (*(environ[index]+length) == '=')) {
	return environ[index]+length+1;
    } else {
	return NULL;
d507 2
d517 2
a518 3
 *	is modified or deleted.  It propagates the change to the
 *	"environ" array and to any other interpreters for whom
 *	we're managing an "env" array.
d539 2
a540 2
    char *name2;		/* Name of variable being modified, or
				 * NULL if whole array is being deleted. */
d544 1
a544 2
     * First see if the whole "env" variable is being deleted.  If
     * so, just forget about this interpreter.
d547 9
a556 22
	register EnvInterp *eiPtr, *prevPtr;

	if ((flags & (TCL_TRACE_UNSETS|TCL_TRACE_DESTROYED))
		!= (TCL_TRACE_UNSETS|TCL_TRACE_DESTROYED)) {
	    panic("EnvTraceProc called with confusing arguments");
	}
	eiPtr = firstInterpPtr;
	if (eiPtr->interp == interp) {
	    firstInterpPtr = eiPtr->nextPtr;
	} else {
	    for (prevPtr = eiPtr, eiPtr = eiPtr->nextPtr; ;
		    prevPtr = eiPtr, eiPtr = eiPtr->nextPtr) {
		if (eiPtr == NULL) {
		    panic("EnvTraceProc couldn't find interpreter");
		}
		if (eiPtr->interp == interp) {
		    prevPtr->nextPtr = eiPtr->nextPtr;
		    break;
		}
	    }
	}
	ckfree((char *) eiPtr);
d565 4
a568 1
	TclSetEnv(name2, Tcl_GetVar2(interp, "env", name2, TCL_GLOBAL_ONLY));
d571 20
d659 1
a659 1
	newCache = (char **) ckalloc((size_t) allocatedSize);
a676 44
 * FindVariable --
 *
 *	Locate the entry in environ for a given name.
 *
 * Results:
 *	The return value is the index in environ of an entry with the
 *	name "name", or -1 if there is no such entry.   The integer at
 *	*lengthPtr is filled in with the length of name (if a matching
 *	entry is found) or the length of the environ array (if no matching
 *	entry is found).
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static int
FindVariable(name, lengthPtr)
    CONST char *name;		/* Name of desired environment variable. */
    int *lengthPtr;		/* Used to return length of name (for
				 * successful searches) or number of non-NULL
				 * entries in environ (for unsuccessful
				 * searches). */
{
    int i;
    register CONST char *p1, *p2;

    for (i = 0, p1 = environ[i]; p1 != NULL; i++, p1 = environ[i]) {
	for (p2 = name; *p2 == *p1; p1++, p2++) {
	    /* NULL loop body. */
	}
	if ((*p1 == '=') && (*p2 == '\0')) {
	    *lengthPtr = p2-name;
	    return i;
	}
    }
    *lengthPtr = i;
    return -1;
}

/*
 *----------------------------------------------------------------------
 *
d796 1
@


1.1
log
@Initial revision
@
text
@d15 1
a15 1
 * RCS: @@(#) $Id: tclEnv.c,v 1.20 1999/10/19 21:38:01 dj Exp $
d22 1
a22 1
#ifdef __CYGWIN32__
d24 1
a24 1
/* On cygwin32, the environment is imported from the cygwin32 DLL.  */
d26 1
a26 1
extern char ***__imp___cygwin_environ;
d28 1
a28 1
#define environ (*__imp___cygwin_environ)
d86 1
a86 1
#ifdef __CYGWIN32__
d748 1
a748 1
#ifdef __CYGWIN32__
d752 2
a753 2
/* When using cygwin32, when an environment variable changes, we need
   to synch with both the cygwin32 environment (in case the
d780 1
a780 1
  /* Set the cygwin32 environment variable.  */
d819 1
a819 1
	  size = cygwin32_posix_to_win32_path_list_buf_size (value);
d821 1
a821 1
	  cygwin32_posix_to_win32_path_list (value, buf);
d828 1
a828 1
#endif /* __CYGWIN32__ */
@


1.1.1.1
log
@import dejagnu-1999-11-08 snapshot
@
text
@@


1.1.1.2
log
@import dejagnu-2000-01-31 snapshot
@
text
@d15 1
a15 1
 * RCS: @@(#) $Id: tclEnv.c,v 1.21 2000/01/26 20:03:51 dj Exp $
d26 1
a26 1
extern char ***_imp____cygwin_environ;
d28 1
a28 1
#define environ (*_imp____cygwin_environ)
@


1.1.1.3
log
@Tcl 8.3 upgrade
@
text
@d10 1
a10 1
 * Copyright (c) 1994-1998 Sun Microsystems, Inc.
d15 1
a15 1
 * RCS: @@(#) $Id: tclEnv.c,v 1.6.8.4 2000/09/15 16:55:09 spolk Exp $
a20 2
TCL_DECLARE_MUTEX(envMutex)	/* To serialize access to environ */

d26 1
a26 1
__declspec(dllimport) extern char **__cygwin_environ;
d28 1
a28 1
#define environ (__cygwin_environ)
d35 1
d39 17
a55 4
#ifdef TCL_THREADS

static Tcl_Mutex envMutex;	/* To serialize access to environ */
#endif
a70 8
 * For MacOS X
 */
#if defined(__APPLE__) && defined(__DYNAMIC__)
#include <crt_externs.h>
char **environ = NULL;
#endif

/*
d77 2
d106 1
a106 1
 *	call to TclSetupEnv, then additional initialization happens,
d118 15
a132 3
    Tcl_DString envString;
    char *p1, *p2;
    int i;
d134 2
d137 1
a137 1
     * For MacOS X
d139 5
a143 3
#if defined(__APPLE__) && defined(__DYNAMIC__)
    environ = *_NSGetEnviron();
#endif
d146 3
a148 7
     * Synchronize the values in the environ array with the contents
     * of the Tcl "env" variable.  To do this:
     *    1) Remove the trace that fires when the "env" var is unset.
     *    2) Unset the "env" variable.
     *    3) If there are no environ variables, create an empty "env"
     *       array.  Otherwise populate the array with current values.
     *    4) Add a trace that synchronizes the "env" array.
d150 9
a158 21
    
    Tcl_UntraceVar2(interp, "env", (char *) NULL,
	    TCL_GLOBAL_ONLY | TCL_TRACE_WRITES | TCL_TRACE_UNSETS |
	    TCL_TRACE_READS | TCL_TRACE_ARRAY,  EnvTraceProc,
	    (ClientData) NULL);
    
    Tcl_UnsetVar2(interp, "env", (char *) NULL, TCL_GLOBAL_ONLY); 
    
    if (environ[0] == NULL) {
	Tcl_Obj *varNamePtr;
	
	varNamePtr = Tcl_NewStringObj("env", -1);
	Tcl_IncrRefCount(varNamePtr);
	TclArraySet(interp, varNamePtr, NULL);	
	Tcl_DecrRefCount(varNamePtr);
    } else {
	Tcl_MutexLock(&envMutex);
	for (i = 0; environ[i] != NULL; i++) {
	    p1 = Tcl_ExternalToUtfDString(NULL, environ[i], -1, &envString);
	    p2 = strchr(p1, '=');
	    if (p2 == NULL) {
d160 2
a161 1
		 * This condition seem to happen occasionally under some
d164 2
a165 2
		
		continue;
a166 4
	    p2++;
	    p2[-1] = '\0';
	    Tcl_SetVar2(interp, "env", p1, p2, TCL_GLOBAL_ONLY);	
	    Tcl_DStringFree(&envString);
d168 7
a174 1
	Tcl_MutexUnlock(&envMutex);
d176 3
d180 5
a184 4
    Tcl_TraceVar2(interp, "env", (char *) NULL,
	    TCL_GLOBAL_ONLY | TCL_TRACE_WRITES | TCL_TRACE_UNSETS |
	    TCL_TRACE_READS | TCL_TRACE_ARRAY,  EnvTraceProc,
	    (ClientData) NULL);
d203 2
a204 1
 *	The environ array gets updated.
d212 2
a213 2
				 * set (UTF-8). */
    CONST char *value;		/* New value for variable (UTF-8). */
a214 1
    Tcl_DString envString;
d216 8
a223 1
    char *p, *p2, *oldValue;
d227 2
a228 2
     * already exist, enlarge the array if necessary to make room.  If the
     * name exists, free its old entry.
d231 1
a231 3
    Tcl_MutexLock(&envMutex);
    index = TclpFindVariable(name, &length);

d234 1
a234 1
	if ((length + 2) > environSize) {
d238 1
a238 1
		    ((length + 5) * sizeof(char *)));
d251 1
a251 1
	    environSize = length + 5;
d254 1
a254 1
	environ[index + 1] = NULL;
a258 2
	char *env;

d267 1
a267 4
	env = Tcl_ExternalToUtfDString(NULL, environ[index], -1, &envString);
	if (strcmp(value, (env + length + 1)) == 0) {
	    Tcl_DStringFree(&envString);
	    Tcl_MutexUnlock(&envMutex);
a269 2
	Tcl_DStringFree(&envString);

d276 1
a276 3
     * Create a new entry.  Build a complete UTF string that contains
     * a "name=value" pattern.  Then convert the string to the native
     * encoding, and set the environ array value.
a282 1
    p2 = Tcl_UtfToExternalDString(NULL, p, -1, &envString);
d285 1
a285 1
     * Copy the native string to heap memory.
a286 4
    
    p = (char *) ckrealloc(p, (unsigned) (strlen(p2) + 1));
    strcpy(p, p2);
    Tcl_DStringFree(&envString);
a288 4
    /*
     * Update the system environment.
     */

a289 1
    index = TclpFindVariable(name, &length);
d295 7
a301 3
     * Watch out for versions of putenv that copy the string (e.g. VC++).
     * In this case we need to free the string immediately.  Otherwise
     * update the string in the cache.
d304 16
a319 2
    if ((index != -1) && (environ[index] == p)) {
	ReplaceString(oldValue, p);
a321 1
    Tcl_MutexUnlock(&envMutex);
d350 1
a350 1
				 * form NAME=value. (native) */
a351 1
    Tcl_DString nameString;   
d360 2
a361 3
     * First convert the native string to UTF.  Then separate the
     * string into name and value parts, and call TclSetEnv to do
     * all of the real work.
d364 1
a364 2
    name = Tcl_ExternalToUtfDString(NULL, string, -1, &nameString);
    value = strchr(name, '=');
d368 1
a368 1
    nameLength = value - name;
d372 3
a374 2

    value[0] = '\0';
d376 1
a376 1
    Tcl_DStringFree(&nameString);
d402 1
a402 1
    CONST char *name;		/* Name of variable to remove (UTF-8). */
d404 1
d406 1
a406 2
    unsigned int length;
    int index;
a407 1
    Tcl_DString envString;
d413 7
a419 2
    Tcl_MutexLock(&envMutex);
    index = TclpFindVariable(name, &length);
a426 1
	Tcl_MutexUnlock(&envMutex);
a444 6
    
    Tcl_UtfToExternalDString(NULL, string, -1, &envString);
    string = ckrealloc(string, (unsigned) (Tcl_DStringLength(&envString)+1));
    strcpy(string, Tcl_DStringValue(&envString));
    Tcl_DStringFree(&envString);

d446 1
a446 10

    /*
     * Watch out for versions of putenv that copy the string (e.g. VC++).
     * In this case we need to free the string immediately.  Otherwise
     * update the string in the cache.
     */

    if (environ[index] == string) {
	ReplaceString(oldValue, string);
    }
d454 6
a460 1
#endif
d462 8
a469 1
    Tcl_MutexUnlock(&envMutex);
d473 1
a473 1
 *---------------------------------------------------------------------------
d480 2
a481 5
 *	The result is a pointer to a string specifying the value of the
 *	environment variable, or NULL if that environment variable does
 *	not exist.  Storage for the result string is allocated in valuePtr;
 *	the caller must call Tcl_DStringFree() when the result is no
 *	longer needed.
d490 2
a491 6
TclGetEnv(name, valuePtr)
    CONST char *name;		/* Name of environment variable to find
				 * (UTF-8). */
    Tcl_DString *valuePtr;	/* Uninitialized or free DString in which
				 * the value of the environment variable is
				 * stored. */
a493 1
    char *result;
d495 11
a505 17
    Tcl_MutexLock(&envMutex);
    index = TclpFindVariable(name, &length);
    result = NULL;
    if (index != -1) {
	Tcl_DString envStr;
	
	result = Tcl_ExternalToUtfDString(NULL, environ[index], -1, &envStr);
	result += length;
	if (*result == '=') {
	    result++;
	    Tcl_DStringInit(valuePtr);
	    Tcl_DStringAppend(valuePtr, result, -1);
	    result = Tcl_DStringValue(valuePtr);
	} else {
	    result = NULL;
	}
	Tcl_DStringFree(&envStr);
a506 2
    Tcl_MutexUnlock(&envMutex);
    return result;
d515 3
a517 2
 *	is read, modified or deleted.  It propagates the change to the global
 *	"environ" array.
d538 2
a539 2
    char *name2;		/* Name of variable being modified, or NULL
				 * if whole array is being deleted (UTF-8). */
d543 2
a544 1
     * For array traces, let TclSetupEnv do all the work.
d547 2
a548 4
    if (flags & TCL_TRACE_ARRAY) {
	TclSetupEnv(interp);
	return NULL;
    }
d550 20
a569 5
    /*
     * If name2 is NULL, then return and do nothing.
     */
     
    if (name2 == NULL) {
d578 1
a578 20
	char *value;
	
	value = Tcl_GetVar2(interp, "env", name2, TCL_GLOBAL_ONLY);
	TclSetEnv(name2, value);
    }

    /*
     * If a value is being read, call TclGetEnv to do all of the work.
     */

    if (flags & TCL_TRACE_READS) {
	Tcl_DString valueString;
	char *value;

	value = TclGetEnv(name2, &valueString);
	if (value == NULL) {
	    return "no such variable";
	}
	Tcl_SetVar2(interp, name1, name2, value, 0);
	Tcl_DStringFree(&valueString);
a580 4
    /*
     * For unset traces, let TclUnsetEnv do all the work.
     */

d649 1
a649 1
	newCache = (char **) ckalloc((unsigned) allocatedSize);
d667 44
d750 2
a829 1

@


1.1.1.4
log
@import tcl 8.4.0
@
text
@d15 1
a15 1
 * RCS: @@(#) $Id: tclEnv.c,v 1.17 2002/08/28 22:48:10 davygrvy Exp $
d23 22
d71 2
a72 2
			    Tcl_Interp *interp, CONST char *name1, 
			    CONST char *name2, int flags));
d79 4
d203 1
a203 2
    char *p, *oldValue;
    CONST char *p2;
d221 6
a233 6
#if defined(__APPLE__) && defined(__DYNAMIC__)
	    {
	    char ***e = _NSGetEnviron();
	    *e = environ;
	    }
#endif
d241 1
a241 1
	CONST char *env;
a302 5
#ifdef HAVE_PUTENV_THAT_COPIES
    } else {
	/* This putenv() copies instead of taking ownership */
	ckfree(p);
#endif
a305 9
    
    if (!strcmp(name, "HOME")) {
	/* 
	 * If the user's home directory has changed, we must invalidate
	 * the filesystem cache, because '~' expansions will now be
	 * incorrect.
	 */
        Tcl_FSMountsChanged(NULL);
    }
d338 1
a338 2
    CONST char *name;
    char *value;
d391 1
a391 1
    int length;
d478 1
a478 1
CONST char *
d487 1
a487 1
    CONST char *result;
d538 2
a539 2
    CONST char *name1;		/* Better be "env". */
    CONST char *name2;		/* Name of variable being modified, or NULL
d565 1
a565 1
	CONST char *value;
d577 1
a577 1
	CONST char *value;
d668 1
a668 1
	environCache[cacheSize] = newStr;
d712 83
@


1.1.1.5
log
@import tcl 8.4.1
@
text
@d15 1
a15 1
 * RCS: @@(#) $Id: tclEnv.c,v 1.19 2002/10/14 22:25:10 hobbs Exp $
a56 3
#if defined (__CYGWIN__) && defined(__WIN32__)
static void		TclCygwinPutenv _ANSI_ARGS_((CONST char *string));
#endif
d326 1
d342 6
a347 4

    if ((value != NULL) && (value != name)) {
	value[0] = '\0';
	TclSetEnv(name, value+1);
d350 2
a701 81

#if defined(__CYGWIN__) && defined(__WIN32__)

#include <windows.h>

/*
 * When using cygwin, when an environment variable changes, we need to synch
 * with both the cygwin environment (in case the application C code calls
 * fork) and the Windows environment (in case the application TCL code calls
 * exec, which calls the Windows CreateProcess function).
 */

static void
TclCygwinPutenv(str)
    const char *str;
{
    char *name, *value;

    /* Get the name and value, so that we can change the environment
       variable for Windows.  */
    name = (char *) alloca (strlen (str) + 1);
    strcpy (name, str);
    for (value = name; *value != '=' && *value != '\0'; ++value)
	;
    if (*value == '\0') {
	    /* Can't happen.  */
	    return;
	}
    *value = '\0';
    ++value;
    if (*value == '\0') {
	value = NULL;
    }

    /* Set the cygwin environment variable.  */
#undef putenv
    if (value == NULL) {
	unsetenv (name);
    } else {
	putenv(str);
    }

    /*
     * Before changing the environment variable in Windows, if this is PATH,
     * we need to convert the value back to a Windows style path.
     *
     * FIXME: The calling program may know it is running under windows, and
     * may have set the path to a Windows path, or, worse, appended or
     * prepended a Windows path to PATH.
     */
    if (strcmp (name, "PATH") != 0) {
	/* If this is Path, eliminate any PATH variable, to prevent any
	   confusion.  */
	if (strcmp (name, "Path") == 0) {
	    SetEnvironmentVariable ("PATH", (char *) NULL);
	    unsetenv ("PATH");
	}

	SetEnvironmentVariable (name, value);
    } else {
	char *buf;

	    /* Eliminate any Path variable, to prevent any confusion.  */
	SetEnvironmentVariable ("Path", (char *) NULL);
	unsetenv ("Path");

	if (value == NULL) {
	    buf = NULL;
	} else {
	    int size;

	    size = cygwin_posix_to_win32_path_list_buf_size (value);
	    buf = (char *) alloca (size + 1);
	    cygwin_posix_to_win32_path_list (value, buf);
	}

	SetEnvironmentVariable (name, buf);
    }
}

#endif /* __CYGWIN__ && __WIN32__ */
@


