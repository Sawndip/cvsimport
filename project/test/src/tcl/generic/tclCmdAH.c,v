head	1.6;
access;
symbols
	sid-snapshot-20180601:1.6
	sid-snapshot-20180501:1.6
	sid-snapshot-20180401:1.6
	sid-snapshot-20180301:1.6
	sid-snapshot-20180201:1.6
	sid-snapshot-20180101:1.6
	sid-snapshot-20171201:1.6
	sid-snapshot-20171101:1.6
	sid-snapshot-20171001:1.6
	sid-snapshot-20170901:1.6
	sid-snapshot-20170801:1.6
	sid-snapshot-20170701:1.6
	sid-snapshot-20170601:1.6
	sid-snapshot-20170501:1.6
	sid-snapshot-20170401:1.6
	sid-snapshot-20170301:1.6
	sid-snapshot-20170201:1.6
	sid-snapshot-20170101:1.6
	sid-snapshot-20161201:1.6
	sid-snapshot-20161101:1.6
	sid-snapshot-20160901:1.6
	sid-snapshot-20160801:1.6
	sid-snapshot-20160701:1.6
	sid-snapshot-20160601:1.6
	sid-snapshot-20160501:1.6
	sid-snapshot-20160401:1.6
	sid-snapshot-20160301:1.6
	sid-snapshot-20160201:1.6
	sid-snapshot-20160101:1.6
	sid-snapshot-20151201:1.6
	sid-snapshot-20151101:1.6
	sid-snapshot-20151001:1.6
	sid-snapshot-20150901:1.6
	sid-snapshot-20150801:1.6
	sid-snapshot-20150701:1.6
	sid-snapshot-20150601:1.6
	sid-snapshot-20150501:1.6
	sid-snapshot-20150401:1.6
	sid-snapshot-20150301:1.6
	sid-snapshot-20150201:1.6
	sid-snapshot-20150101:1.6
	sid-snapshot-20141201:1.6
	sid-snapshot-20141101:1.6
	sid-snapshot-20141001:1.6
	sid-snapshot-20140901:1.6
	sid-snapshot-20140801:1.6
	sid-snapshot-20140701:1.6
	sid-snapshot-20140601:1.6
	sid-snapshot-20140501:1.6
	sid-snapshot-20140401:1.6
	sid-snapshot-20140301:1.6
	sid-snapshot-20140201:1.6
	sid-snapshot-20140101:1.6
	sid-snapshot-20131201:1.6
	sid-snapshot-20131101:1.6
	sid-snapshot-20131001:1.6
	sid-snapshot-20130901:1.6
	sid-snapshot-20130801:1.6
	sid-snapshot-20130701:1.6
	sid-snapshot-20130601:1.6
	insight_7_6-2013-04-10-branchpoint:1.6
	gdb_7_6-branch:1.6.0.34
	sid-snapshot-20130501:1.6
	sid-snapshot-20130401:1.6
	sid-snapshot-20130301:1.6
	sid-snapshot-20130201:1.6
	sid-snapshot-20130101:1.6
	sid-snapshot-20121201:1.6
	sid-snapshot-20121101:1.6
	sid-snapshot-20121001:1.6
	sid-snapshot-20120901:1.6
	gdb_7_5-branch:1.6.0.32
	sid-snapshot-20120801:1.6
	sid-snapshot-20120701:1.6
	sid-snapshot-20120601:1.6
	sid-snapshot-20120501:1.6
	sid-snapshot-20120401:1.6
	gdb_7_4-branch:1.6.0.30
	sid-snapshot-20120301:1.6
	sid-snapshot-20120201:1.6
	sid-snapshot-20120101:1.6
	sid-snapshot-20111201:1.6
	sid-snapshot-20111101:1.6
	sid-snapshot-20111001:1.6
	sid-snapshot-20110901:1.6
	gdb_7_3-branch:1.6.0.28
	sid-snapshot-20110801:1.6
	sid-snapshot-20110701:1.6
	sid-snapshot-20110601:1.6
	sid-snapshot-20110501:1.6
	sid-snapshot-20110401:1.6
	sid-snapshot-20110301:1.6
	sid-snapshot-20110201:1.6
	sid-snapshot-20110101:1.6
	sid-snapshot-20101201:1.6
	sid-snapshot-20101101:1.6
	sid-snapshot-20101001:1.6
	sid-snapshot-20100901:1.6
	sid-snapshot-20100801:1.6
	sid-snapshot-20100701:1.6
	sid-snapshot-20100601:1.6
	sid-snapshot-20100501:1.6
	sid-snapshot-20100401:1.6
	sid-snapshot-20100301:1.6
	gdb_7_1-branch:1.6.0.26
	gdb_7_0-branch:1.6.0.24
	sid-snapshot-20100201:1.6
	sid-snapshot-20100101:1.6
	sid-snapshot-20091201:1.6
	sid-snapshot-20091101:1.6
	sid-snapshot-20091001:1.6
	arc-sim-20090309:1.6
	sid-snapshot-20090901:1.6
	sid-snapshot-20090801:1.6
	sid-snapshot-20090701:1.6
	sid-snapshot-20090601:1.6
	sid-snapshot-20090501:1.6
	kevinb-pre-tcl8_5_7_merge:1.6
	sid-snapshot-20090401:1.6
	arc-insight_6_8-branch:1.6.0.22
	arc-insight_6_8-branchpoint:1.6
	insight_6_8-branch:1.6.0.20
	insight_6_8-branchpoint:1.6
	sid-snapshot-20090301:1.6
	sid-snapshot-20090201:1.6
	sid-snapshot-20090101:1.6
	sid-snapshot-20081201:1.6
	sid-snapshot-20081101:1.6
	sid-snapshot-20081001:1.6
	sid-snapshot-20080901:1.6
	sid-snapshot-20080801:1.6
	sid-snapshot-20080701:1.6
	sid-snapshot-20080601:1.6
	sid-snapshot-20080501:1.6
	sid-snapshot-20080403:1.6
	sid-snapshot-20080401:1.6
	gdb_6_8-branch:1.6.0.18
	sid-snapshot-20080301:1.6
	sid-snapshot-20080201:1.6
	sid-snapshot-20080101:1.6
	sid-snapshot-20071201:1.6
	sid-snapshot-20071101:1.6
	sid-snapshot-20071001:1.6
	insight_6_6-20070208-release:1.6
	gdb_6_6-branch:1.6.0.16
	gdb_6_6-2006-11-15-branchpoint:1.6
	insight_6_5-20061003-release:1.6
	gdb_6_5-branch:1.6.0.14
	gdb_6_5-2006-05-14-branchpoint:1.6
	readline_5_1-import-branch:1.6.0.12
	readline_5_1-import-branchpoint:1.6
	gdb_6_4-branch:1.6.0.10
	gdb_6_4-2005-11-01-branchpoint:1.6
	msnyder-tracepoint-checkpoint-branch:1.6.0.8
	msnyder-tracepoint-checkpoint-branchpoint:1.6
	gdb_6_1-2004-04-05-release:1.6
	ezannoni_pie-20040323-branch:1.6.0.6
	ezannoni_pie-20040323-branchpoint:1.6
	cagney_tramp-20040321-mergepoint:1.6
	cagney_tramp-20040309-branch:1.6.0.4
	cagney_tramp-20040309-branchpoint:1.6
	gdb_6_1-branch:1.6.0.2
	gdb_6_1-2004-03-01-gmt-branchpoint:1.6
	drow-cplus-merge-20040208:1.6
	carlton_dictionary-20040126-merge:1.6
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.24
	cagney_x86i386-20030821-branch:1.5.0.22
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.20
	gdb_6_0-2003-06-23-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.18
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.16
	cagney_writestrings-20030508-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.14
	cagney_fileio-20030521-branchpoint:1.5
	carlton_dictionary-20030430-merge:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.12
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.10
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.8
	cagney_lazyid-20030317-branchpoint:1.5
	offbyone-20030313-branch:1.5.0.6
	offbyone-20030313-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.4
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.2
	interps-20030202-branchpoint:1.5
	TCL8_4_1:1.1.1.3
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.2
	TCL_8_4_1:1.1.1.3
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.4
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TCL_8_4_0:1.1.1.3
	carlton_dictionary-branch:1.2.0.16
	carlton_dictionary-20020920-branchpoint:1.2
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.14
	gdb_5_3-branch:1.2.0.12
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.10
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.8
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.6
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TCL_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	dejagnu-2000-02-04:1.1.1.1
	dejagnu-2000-01-31:1.1.1.1
	dejagnu-2000-01-24:1.1.1.1
	dejagnu-2000-01-17:1.1.1.1
	dejagnu-2000-01-10:1.1.1.1
	dejagnu-2000-01-04:1.1.1.1
	dejagnu-1999-12-21:1.1.1.1
	dejagnu-1999-12-13:1.1.1.1
	dejagnu-1999-12-07:1.1.1.1
	dejagnu-1999-12-06:1.1.1.1
	dejagnu-1999-11-15:1.1.1.1
	dejagnu-1999-11-08:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.6
date	2004.01.21.14.38.50;	author kseitz;	state Exp;
branches;
next	1.5;

1.5
date	2003.01.21.19.40.02;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.26.19.47.51;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.37.02;	author kseitz;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2001.09.09.23.56.04;	author irox;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	99.11.09.01.28.43;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2002.09.27.21.49.02;	author kseitz;	state Exp;
branches;
next	;

1.3.4.1
date	2003.12.14.20.28.42;	author drow;	state Exp;
branches;
next	1.3.4.2;

1.3.4.2
date	2004.02.09.19.44.05;	author drow;	state Exp;
branches;
next	;

1.2.16.1
date	2002.12.23.19.40.16;	author carlton;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2003.02.07.19.18.10;	author carlton;	state Exp;
branches;
next	1.2.16.3;

1.2.16.3
date	2004.01.26.19.11.56;	author carlton;	state Exp;
branches;
next	;

1.1.1.1
date	99.11.09.01.28.43;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.09.22.40.54;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.19.55.55;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.6
log
@        From tcl repository:
        2003-10-22  Donal K. Fellows  <fellowsd@@cs.man.ac.uk>
        * generic/tclCmdAH.c (Tcl_FileObjCmd): Changed FILE_ prefix to FCMD_
        to stop symbol/#def clashes on Cygwin/Mingw32 on NT.
@
text
@/* 
 * tclCmdAH.c --
 *
 *	This file contains the top-level command routines for most of
 *	the Tcl built-in commands whose names begin with the letters
 *	A to H.
 *
 * Copyright (c) 1987-1993 The Regents of the University of California.
 * Copyright (c) 1994-1997 Sun Microsystems, Inc.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tclCmdAH.c,v 1.27 2002/07/02 12:16:05 vincentdarley Exp $
 */

#include "tclInt.h"
#include "tclPort.h"
#include <locale.h>

/*
 * Prototypes for local procedures defined in this file:
 */

static int		CheckAccess _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_Obj *objPtr, int mode));
static int		GetStatBuf _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_Obj *objPtr, Tcl_FSStatProc *statProc,
			    Tcl_StatBuf *statPtr));
static char *		GetTypeFromMode _ANSI_ARGS_((int mode));
static int		StoreStatData _ANSI_ARGS_((Tcl_Interp *interp,
			    char *varName, Tcl_StatBuf *statPtr));

/*
 *----------------------------------------------------------------------
 *
 * Tcl_BreakObjCmd --
 *
 *	This procedure is invoked to process the "break" Tcl command.
 *	See the user documentation for details on what it does.
 *
 *	With the bytecode compiler, this procedure is only called when
 *	a command name is computed at runtime, and is "break" or the name
 *	to which "break" was renamed: e.g., "set z break; $z"
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
int
Tcl_BreakObjCmd(dummy, interp, objc, objv)
    ClientData dummy;			/* Not used. */
    Tcl_Interp *interp;			/* Current interpreter. */
    int objc;				/* Number of arguments. */
    Tcl_Obj *CONST objv[];		/* Argument objects. */
{
    if (objc != 1) {
	Tcl_WrongNumArgs(interp, 1, objv, NULL);
	return TCL_ERROR;
    }
    return TCL_BREAK;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_CaseObjCmd --
 *
 *	This procedure is invoked to process the "case" Tcl command.
 *	See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl object result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
int
Tcl_CaseObjCmd(dummy, interp, objc, objv)
    ClientData dummy;		/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    register int i;
    int body, result, caseObjc;
    char *string, *arg;
    Tcl_Obj *CONST *caseObjv;
    Tcl_Obj *armPtr;

    if (objc < 3) {
	Tcl_WrongNumArgs(interp, 1, objv,
		"string ?in? patList body ... ?default body?");
	return TCL_ERROR;
    }

    string = Tcl_GetString(objv[1]);
    body = -1;

    arg = Tcl_GetString(objv[2]);
    if (strcmp(arg, "in") == 0) {
	i = 3;
    } else {
	i = 2;
    }
    caseObjc = objc - i;
    caseObjv = objv + i;

    /*
     * If all of the pattern/command pairs are lumped into a single
     * argument, split them out again.
     */

    if (caseObjc == 1) {
	Tcl_Obj **newObjv;
	
	Tcl_ListObjGetElements(interp, caseObjv[0], &caseObjc, &newObjv);
	caseObjv = newObjv;
    }

    for (i = 0;  i < caseObjc;  i += 2) {
	int patObjc, j;
	CONST char **patObjv;
	char *pat;
	unsigned char *p;

	if (i == (caseObjc - 1)) {
	    Tcl_ResetResult(interp);
	    Tcl_AppendToObj(Tcl_GetObjResult(interp),
	            "extra case pattern with no body", -1);
	    return TCL_ERROR;
	}

	/*
	 * Check for special case of single pattern (no list) with
	 * no backslash sequences.
	 */

	pat = Tcl_GetString(caseObjv[i]);
	for (p = (unsigned char *) pat; *p != '\0'; p++) {
	    if (isspace(*p) || (*p == '\\')) {	/* INTL: ISO space, UCHAR */
		break;
	    }
	}
	if (*p == '\0') {
	    if ((*pat == 'd') && (strcmp(pat, "default") == 0)) {
		body = i + 1;
	    }
	    if (Tcl_StringMatch(string, pat)) {
		body = i + 1;
		goto match;
	    }
	    continue;
	}


	/*
	 * Break up pattern lists, then check each of the patterns
	 * in the list.
	 */

	result = Tcl_SplitList(interp, pat, &patObjc, &patObjv);
	if (result != TCL_OK) {
	    return result;
	}
	for (j = 0; j < patObjc; j++) {
	    if (Tcl_StringMatch(string, patObjv[j])) {
		body = i + 1;
		break;
	    }
	}
	ckfree((char *) patObjv);
	if (j < patObjc) {
	    break;
	}
    }

    match:
    if (body != -1) {
	armPtr = caseObjv[body - 1];
	result = Tcl_EvalObjEx(interp, caseObjv[body], 0);
	if (result == TCL_ERROR) {
	    char msg[100 + TCL_INTEGER_SPACE];
	    
	    arg = Tcl_GetString(armPtr);
	    sprintf(msg,
		    "\n    (\"%.50s\" arm line %d)", arg,
	            interp->errorLine);
	    Tcl_AddObjErrorInfo(interp, msg, -1);
	}
	return result;
    }

    /*
     * Nothing matched: return nothing.
     */

    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_CatchObjCmd --
 *
 *	This object-based procedure is invoked to process the "catch" Tcl 
 *	command. See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl object result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
int
Tcl_CatchObjCmd(dummy, interp, objc, objv)
    ClientData dummy;		/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    Tcl_Obj *varNamePtr = NULL;
    int result;

    if ((objc != 2) && (objc != 3)) {
	Tcl_WrongNumArgs(interp, 1, objv, "command ?varName?");
	return TCL_ERROR;
    }

    /*
     * Save a pointer to the variable name object, if any, in case the
     * Tcl_EvalObj reallocates the bytecode interpreter's evaluation
     * stack rendering objv invalid.
     */
    
    if (objc == 3) {
	varNamePtr = objv[2];
    }

    result = Tcl_EvalObjEx(interp, objv[1], 0);
    
    if (objc == 3) {
	if (Tcl_ObjSetVar2(interp, varNamePtr, NULL,
		Tcl_GetObjResult(interp), 0) == NULL) {
	    Tcl_ResetResult(interp);
	    Tcl_AppendToObj(Tcl_GetObjResult(interp),  
	            "couldn't save command result in variable", -1);
	    return TCL_ERROR;
	}
    }

    /*
     * Set the interpreter's object result to an integer object holding the
     * integer Tcl_EvalObj result. Note that we don't bother generating a
     * string representation. We reset the interpreter's object result
     * to an unshared empty object and then set it to be an integer object.
     */

    Tcl_ResetResult(interp);
    Tcl_SetIntObj(Tcl_GetObjResult(interp), result);
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_CdObjCmd --
 *
 *	This procedure is invoked to process the "cd" Tcl command.
 *	See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
int
Tcl_CdObjCmd(dummy, interp, objc, objv)
    ClientData dummy;		/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    Tcl_Obj *dir;
    int result;

    if (objc > 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "?dirName?");
	return TCL_ERROR;
    }

    if (objc == 2) {
	dir = objv[1];
    } else {
	dir = Tcl_NewStringObj("~",1);
	Tcl_IncrRefCount(dir);
    }
    if (Tcl_FSConvertToPathType(interp, dir) != TCL_OK) {
	result = TCL_ERROR;
    } else {
	result = Tcl_FSChdir(dir);
	if (result != TCL_OK) {
	    Tcl_AppendResult(interp, "couldn't change working directory to \"",
		    Tcl_GetString(dir), "\": ", Tcl_PosixError(interp), (char *) NULL);
	    result = TCL_ERROR;
	}
    }
    if (objc != 2) {
	Tcl_DecrRefCount(dir);
    }
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_ConcatObjCmd --
 *
 *	This object-based procedure is invoked to process the "concat" Tcl
 *	command. See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl object result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
int
Tcl_ConcatObjCmd(dummy, interp, objc, objv)
    ClientData dummy;		/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    if (objc >= 2) {
	Tcl_SetObjResult(interp, Tcl_ConcatObj(objc-1, objv+1));
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_ContinueObjCmd -
 *
 *	This procedure is invoked to process the "continue" Tcl command.
 *	See the user documentation for details on what it does.
 *
 *	With the bytecode compiler, this procedure is only called when
 *	a command name is computed at runtime, and is "continue" or the name
 *	to which "continue" was renamed: e.g., "set z continue; $z"
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
int
Tcl_ContinueObjCmd(dummy, interp, objc, objv)
    ClientData dummy;			/* Not used. */
    Tcl_Interp *interp;			/* Current interpreter. */
    int objc;				/* Number of arguments. */
    Tcl_Obj *CONST objv[];		/* Argument objects. */
{
    if (objc != 1) {
	Tcl_WrongNumArgs(interp, 1, objv, NULL);
	return TCL_ERROR;
    }
    return TCL_CONTINUE;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_EncodingObjCmd --
 *
 *	This command manipulates encodings.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_EncodingObjCmd(dummy, interp, objc, objv)
    ClientData dummy;		/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    int index, length;
    Tcl_Encoding encoding;
    char *string;
    Tcl_DString ds;
    Tcl_Obj *resultPtr;

    static CONST char *optionStrings[] = {
	"convertfrom", "convertto", "names", "system",
	NULL
    };
    enum options {
	ENC_CONVERTFROM, ENC_CONVERTTO, ENC_NAMES, ENC_SYSTEM
    };

    if (objc < 2) {
    	Tcl_WrongNumArgs(interp, 1, objv, "option ?arg ...?");
        return TCL_ERROR;
    }
    if (Tcl_GetIndexFromObj(interp, objv[1], optionStrings, "option", 0,
	    &index) != TCL_OK) {
	return TCL_ERROR;
    }

    switch ((enum options) index) {
	case ENC_CONVERTTO:
	case ENC_CONVERTFROM: {
	    char *name;
	    Tcl_Obj *data;
	    if (objc == 3) {
		name = NULL;
		data = objv[2];
	    } else if (objc == 4) {
		name = Tcl_GetString(objv[2]);
		data = objv[3];
	    } else {
		Tcl_WrongNumArgs(interp, 2, objv, "?encoding? data");
		return TCL_ERROR;
	    }
	    
	    encoding = Tcl_GetEncoding(interp, name);
	    if (!encoding) {
		return TCL_ERROR;
	    }

	    if ((enum options) index == ENC_CONVERTFROM) {
		/*
		 * Treat the string as binary data.
		 */

		string = (char *) Tcl_GetByteArrayFromObj(data, &length);
		Tcl_ExternalToUtfDString(encoding, string, length, &ds);

		/*
		 * Note that we cannot use Tcl_DStringResult here because
		 * it will truncate the string at the first null byte.
		 */

		Tcl_SetStringObj(Tcl_GetObjResult(interp),
			Tcl_DStringValue(&ds), Tcl_DStringLength(&ds));
		Tcl_DStringFree(&ds);
	    } else {
		/*
		 * Store the result as binary data.
		 */

		string = Tcl_GetStringFromObj(data, &length);
		Tcl_UtfToExternalDString(encoding, string, length, &ds);
		resultPtr = Tcl_GetObjResult(interp);
		Tcl_SetByteArrayObj(resultPtr, 
			(unsigned char *) Tcl_DStringValue(&ds),
			Tcl_DStringLength(&ds));
		Tcl_DStringFree(&ds);
	    }

	    Tcl_FreeEncoding(encoding);
	    break;
	}
	case ENC_NAMES: {
	    if (objc > 2) {
		Tcl_WrongNumArgs(interp, 2, objv, NULL);
		return TCL_ERROR;
	    }
	    Tcl_GetEncodingNames(interp);
	    break;
	}
	case ENC_SYSTEM: {
	    if (objc > 3) {
		Tcl_WrongNumArgs(interp, 2, objv, "?encoding?");
		return TCL_ERROR;
	    }
	    if (objc == 2) {
		Tcl_SetStringObj(Tcl_GetObjResult(interp),
			Tcl_GetEncodingName(NULL), -1);
	    } else {
	        return Tcl_SetSystemEncoding(interp,
			Tcl_GetStringFromObj(objv[2], NULL));
	    }
	    break;
	}
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_ErrorObjCmd --
 *
 *	This procedure is invoked to process the "error" Tcl command.
 *	See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl object result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
int
Tcl_ErrorObjCmd(dummy, interp, objc, objv)
    ClientData dummy;		/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    Interp *iPtr = (Interp *) interp;
    char *info;
    int infoLen;

    if ((objc < 2) || (objc > 4)) {
	Tcl_WrongNumArgs(interp, 1, objv, "message ?errorInfo? ?errorCode?");
	return TCL_ERROR;
    }
    
    if (objc >= 3) {		/* process the optional info argument */
	info = Tcl_GetStringFromObj(objv[2], &infoLen);
	if (*info != 0) {
	    Tcl_AddObjErrorInfo(interp, info, infoLen);
	    iPtr->flags |= ERR_ALREADY_LOGGED;
	}
    }
    
    if (objc == 4) {
	Tcl_SetVar2Ex(interp, "errorCode", NULL, objv[3], TCL_GLOBAL_ONLY);
	iPtr->flags |= ERROR_CODE_SET;
    }
    
    Tcl_SetObjResult(interp, objv[1]);
    return TCL_ERROR;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_EvalObjCmd --
 *
 *	This object-based procedure is invoked to process the "eval" Tcl 
 *	command. See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl object result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
int
Tcl_EvalObjCmd(dummy, interp, objc, objv)
    ClientData dummy;		/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    int result;
    register Tcl_Obj *objPtr;

    if (objc < 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "arg ?arg ...?");
	return TCL_ERROR;
    }
    
    if (objc == 2) {
	result = Tcl_EvalObjEx(interp, objv[1], TCL_EVAL_DIRECT);
    } else {
	/*
	 * More than one argument: concatenate them together with spaces
	 * between, then evaluate the result.  Tcl_EvalObjEx will delete
	 * the object when it decrements its refcount after eval'ing it.
	 */
    	objPtr = Tcl_ConcatObj(objc-1, objv+1);
	result = Tcl_EvalObjEx(interp, objPtr, TCL_EVAL_DIRECT);
    }
    if (result == TCL_ERROR) {
	char msg[32 + TCL_INTEGER_SPACE];

	sprintf(msg, "\n    (\"eval\" body line %d)", interp->errorLine);
	Tcl_AddObjErrorInfo(interp, msg, -1);
    }
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_ExitObjCmd --
 *
 *	This procedure is invoked to process the "exit" Tcl command.
 *	See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl object result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
int
Tcl_ExitObjCmd(dummy, interp, objc, objv)
    ClientData dummy;		/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    int value;

    if ((objc != 1) && (objc != 2)) {
	Tcl_WrongNumArgs(interp, 1, objv, "?returnCode?");
	return TCL_ERROR;
    }
    
    if (objc == 1) {
	value = 0;
    } else if (Tcl_GetIntFromObj(interp, objv[1], &value) != TCL_OK) {
	return TCL_ERROR;
    }
    Tcl_Exit(value);
    /*NOTREACHED*/
    return TCL_OK;			/* Better not ever reach this! */
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_ExprObjCmd --
 *
 *	This object-based procedure is invoked to process the "expr" Tcl
 *	command. See the user documentation for details on what it does.
 *
 *	With the bytecode compiler, this procedure is called in two
 *	circumstances: 1) to execute expr commands that are too complicated
 *	or too unsafe to try compiling directly into an inline sequence of
 *	instructions, and 2) to execute commands where the command name is
 *	computed at runtime and is "expr" or the name to which "expr" was
 *	renamed (e.g., "set z expr; $z 2+3")
 *
 * Results:
 *	A standard Tcl object result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
int
Tcl_ExprObjCmd(dummy, interp, objc, objv)
    ClientData dummy;		/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{	 
    register Tcl_Obj *objPtr;
    Tcl_Obj *resultPtr;
    register char *bytes;
    int length, i, result;

    if (objc < 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "arg ?arg ...?");
	return TCL_ERROR;
    }

    if (objc == 2) {
	result = Tcl_ExprObj(interp, objv[1], &resultPtr);
	if (result == TCL_OK) {
	    Tcl_SetObjResult(interp, resultPtr);
	    Tcl_DecrRefCount(resultPtr);  /* done with the result object */
	}
	return result;
    }

    /*
     * Create a new object holding the concatenated argument strings.
     */

    /*** QUESTION: Do we need to copy the slow way? ***/
    bytes = Tcl_GetStringFromObj(objv[1], &length);
    objPtr = Tcl_NewStringObj(bytes, length);
    Tcl_IncrRefCount(objPtr);
    for (i = 2;  i < objc;  i++) {
	Tcl_AppendToObj(objPtr, " ", 1);
	bytes = Tcl_GetStringFromObj(objv[i], &length);
	Tcl_AppendToObj(objPtr, bytes, length);
    }

    /*
     * Evaluate the concatenated string object.
     */

    result = Tcl_ExprObj(interp, objPtr, &resultPtr);
    if (result == TCL_OK) {
	Tcl_SetObjResult(interp, resultPtr);
	Tcl_DecrRefCount(resultPtr);  /* done with the result object */
    }

    /*
     * Free allocated resources.
     */
    
    Tcl_DecrRefCount(objPtr);
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_FileObjCmd --
 *
 *	This procedure is invoked to process the "file" Tcl command.
 *	See the user documentation for details on what it does.
 *	PLEASE NOTE THAT THIS FAILS WITH FILENAMES AND PATHS WITH
 *	EMBEDDED NULLS, WHICH COULD THEORETICALLY HAPPEN ON A MAC.
 *      With the object-based Tcl_FS APIs, the above NOTE may no
 *      longer be true.  In any case this assertion should be tested.
 *      
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
int
Tcl_FileObjCmd(dummy, interp, objc, objv)
    ClientData dummy;		/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    int index;

/*
 * This list of constants should match the fileOption string array below.
 */

    static CONST char *fileOptions[] = {
	"atime",	"attributes",	"channels",	"copy",
	"delete",
	"dirname",	"executable",	"exists",	"extension",
	"isdirectory",	"isfile",	"join",		"link",
	"lstat",        "mtime",	"mkdir",	"nativename",	
	"normalize",    "owned",
	"pathtype",	"readable",	"readlink",	"rename",
	"rootname",	"separator",    "size",		"split",	
	"stat",         "system", 
	"tail",		"type",		"volumes",	"writable",
	(char *) NULL
    };
    enum options {
	FCMD_ATIME,	FCMD_ATTRIBUTES, FCMD_CHANNELS,	FCMD_COPY,
	FCMD_DELETE,
	FCMD_DIRNAME,	FCMD_EXECUTABLE, FCMD_EXISTS,	FCMD_EXTENSION,
	FCMD_ISDIRECTORY, FCMD_ISFILE,	FCMD_JOIN,	FCMD_LINK, 
	FCMD_LSTAT,     FCMD_MTIME,	FCMD_MKDIR,	FCMD_NATIVENAME, 
	FCMD_NORMALIZE, FCMD_OWNED,
	FCMD_PATHTYPE,	FCMD_READABLE,	FCMD_READLINK,	FCMD_RENAME,
	FCMD_ROOTNAME,	FCMD_SEPARATOR, FCMD_SIZE,	FCMD_SPLIT,	
	FCMD_STAT,      FCMD_SYSTEM, 
	FCMD_TAIL,	FCMD_TYPE,	FCMD_VOLUMES,	FCMD_WRITABLE
    };

    if (objc < 2) {
    	Tcl_WrongNumArgs(interp, 1, objv, "option ?arg ...?");
        return TCL_ERROR;
    }
    if (Tcl_GetIndexFromObj(interp, objv[1], fileOptions, "option", 0,
	    &index) != TCL_OK) {
    	return TCL_ERROR;
    }

    switch ((enum options) index) {
    	case FCMD_ATIME: {
	    Tcl_StatBuf buf;
	    struct utimbuf tval;

	    if ((objc < 3) || (objc > 4)) {
		Tcl_WrongNumArgs(interp, 2, objv, "name ?time?");
		return TCL_ERROR;
	    }
	    if (GetStatBuf(interp, objv[2], Tcl_FSStat, &buf) != TCL_OK) {
		return TCL_ERROR;
	    }
	    if (objc == 4) {
		if (Tcl_GetLongFromObj(interp, objv[3],
			(long*)(&buf.st_atime)) != TCL_OK) {
		    return TCL_ERROR;
		}
		tval.actime = buf.st_atime;
		tval.modtime = buf.st_mtime;
		if (Tcl_FSUtime(objv[2], &tval) != 0) {
		    Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
			    "could not set access time for file \"",
			    Tcl_GetString(objv[2]), "\": ",
			    Tcl_PosixError(interp), (char *) NULL);
		    return TCL_ERROR;
		}
		/*
		 * Do another stat to ensure that the we return the
		 * new recognized atime - hopefully the same as the
		 * one we sent in.  However, fs's like FAT don't
		 * even know what atime is.
		 */
		if (GetStatBuf(interp, objv[2], Tcl_FSStat, &buf) != TCL_OK) {
		    return TCL_ERROR;
		}
	    }
	    Tcl_SetLongObj(Tcl_GetObjResult(interp), (long) buf.st_atime);
	    return TCL_OK;
	}
	case FCMD_ATTRIBUTES: {
            return TclFileAttrsCmd(interp, objc, objv);
	}
	case FCMD_CHANNELS: {
	    if ((objc < 2) || (objc > 3)) {
		Tcl_WrongNumArgs(interp, 2, objv, "?pattern?");
		return TCL_ERROR;
	    }
	    return Tcl_GetChannelNamesEx(interp,
		    ((objc == 2) ? NULL : Tcl_GetString(objv[2])));
	}
	case FCMD_COPY: {
	    return TclFileCopyCmd(interp, objc, objv);
	}	    
	case FCMD_DELETE: {
	    return TclFileDeleteCmd(interp, objc, objv);
	}
    	case FCMD_DIRNAME: {
	    Tcl_Obj *dirPtr;
	    if (objc != 3) {
		goto only3Args;
	    }
	    dirPtr = TclFileDirname(interp, objv[2]);
	    if (dirPtr == NULL) {
	        return TCL_ERROR;
	    } else {
		Tcl_SetObjResult(interp, dirPtr);
		Tcl_DecrRefCount(dirPtr);
		return TCL_OK;
	    }
	}
	case FCMD_EXECUTABLE: {
	    if (objc != 3) {
		goto only3Args;
	    }
	    return CheckAccess(interp, objv[2], X_OK);
	}
	case FCMD_EXISTS: {
	    if (objc != 3) {
		goto only3Args;
	    }
	    return CheckAccess(interp, objv[2], F_OK);
	}
	case FCMD_EXTENSION: {
	    char *fileName, *extension;
	    if (objc != 3) {
	    	goto only3Args;
	    }
	    fileName = Tcl_GetString(objv[2]);
	    extension = TclGetExtension(fileName);
	    if (extension != NULL) {
	    	Tcl_SetStringObj(Tcl_GetObjResult(interp), extension, -1);
	    }
	    return TCL_OK;
	}
    	case FCMD_ISDIRECTORY: {
	    int value;
	    Tcl_StatBuf buf;

	    if (objc != 3) {
		goto only3Args;
	    }
	    value = 0;
	    if (GetStatBuf(NULL, objv[2], Tcl_FSStat, &buf) == TCL_OK) {
		value = S_ISDIR(buf.st_mode);
	    }
	    Tcl_SetBooleanObj(Tcl_GetObjResult(interp), value);
	    return TCL_OK;
	}
    	case FCMD_ISFILE: {
	    int value;
	    Tcl_StatBuf buf;
	    
    	    if (objc != 3) {
    	    	goto only3Args;
    	    }
	    value = 0;
	    if (GetStatBuf(NULL, objv[2], Tcl_FSStat, &buf) == TCL_OK) {
		value = S_ISREG(buf.st_mode);
	    }
	    Tcl_SetBooleanObj(Tcl_GetObjResult(interp), value);
	    return TCL_OK;
	}
	case FCMD_JOIN: {
	    Tcl_Obj *resObj;

	    if (objc < 3) {
		Tcl_WrongNumArgs(interp, 2, objv, "name ?name ...?");
		return TCL_ERROR;
	    }
	    resObj = Tcl_FSJoinToPath(NULL, objc - 2, objv + 2);
	    Tcl_SetObjResult(interp, resObj);
	    return TCL_OK;
	}
	case FCMD_LINK: {
	    Tcl_Obj *contents;
	    int index;
	    
	    if (objc < 3 || objc > 5) {
		Tcl_WrongNumArgs(interp, 2, objv, 
				 "?-linktype? linkname ?target?");
		return TCL_ERROR;
	    }
	    
	    /* Index of the 'source' argument */
	    if (objc == 5) {
		index = 3;
	    } else {
		index = 2;
	    }
	    
	    if (objc > 3) {
		int linkAction;
		if (objc == 5) {
		    /* We have a '-linktype' argument */
		    static CONST char *linkTypes[] = {
			"-symbolic", "-hard", NULL
		    };
		    if (Tcl_GetIndexFromObj(interp, objv[2], linkTypes, 
				     "switch", 0, &linkAction) != TCL_OK) {
			return TCL_ERROR;
		    }
		    if (linkAction == 0) {
		        linkAction = TCL_CREATE_SYMBOLIC_LINK;
		    } else {
			linkAction = TCL_CREATE_HARD_LINK;
		    }
		} else {
		    linkAction = TCL_CREATE_SYMBOLIC_LINK|TCL_CREATE_HARD_LINK;
		}
		if (Tcl_FSConvertToPathType(interp, objv[index]) != TCL_OK) {
		    return TCL_ERROR;
		}
		/* Create link from source to target */
		contents = Tcl_FSLink(objv[index], objv[index+1], linkAction);
		if (contents == NULL) {
		    /* 
		     * We handle two common error cases specially, and
		     * for all other errors, we use the standard posix
		     * error message.
		     */
		    if (errno == EEXIST) {
			Tcl_AppendResult(interp, "could not create new link \"", 
				Tcl_GetString(objv[index]), 
				"\": that path already exists", (char *) NULL);
		    } else if (errno == ENOENT) {
			Tcl_AppendResult(interp, "could not create new link \"", 
				Tcl_GetString(objv[index]), 
				"\" since target \"", 
				Tcl_GetString(objv[index+1]), 
				"\" doesn't exist", 
				(char *) NULL);
		    } else {
			Tcl_AppendResult(interp, "could not create new link \"", 
				Tcl_GetString(objv[index]), "\" pointing to \"", 
				Tcl_GetString(objv[index+1]), "\": ", 
				Tcl_PosixError(interp), (char *) NULL);
		    }
		    return TCL_ERROR;
		}
	    } else {
		if (Tcl_FSConvertToPathType(interp, objv[index]) != TCL_OK) {
		    return TCL_ERROR;
		}
		/* Read link */
		contents = Tcl_FSLink(objv[index], NULL, 0);
		if (contents == NULL) {
		    Tcl_AppendResult(interp, "could not read link \"", 
			    Tcl_GetString(objv[index]), "\": ", 
			    Tcl_PosixError(interp), (char *) NULL);
		    return TCL_ERROR;
		}
	    }
	    Tcl_SetObjResult(interp, contents);
	    if (objc == 3) {
		/* 
		 * If we are reading a link, we need to free this
		 * result refCount.  If we are creating a link, this
		 * will just be objv[index+1], and so we don't own it.
		 */
		Tcl_DecrRefCount(contents);
	    }
	    return TCL_OK;
	}
    	case FCMD_LSTAT: {
	    char *varName;
	    Tcl_StatBuf buf;

    	    if (objc != 4) {
    	    	Tcl_WrongNumArgs(interp, 2, objv, "name varName");
    	    	return TCL_ERROR;
    	    }
	    if (GetStatBuf(interp, objv[2], Tcl_FSLstat, &buf) != TCL_OK) {
		return TCL_ERROR;
	    }
	    varName = Tcl_GetString(objv[3]);
	    return StoreStatData(interp, varName, &buf);
	}
	case FCMD_MTIME: {
	    Tcl_StatBuf buf;
	    struct utimbuf tval;

	    if ((objc < 3) || (objc > 4)) {
		Tcl_WrongNumArgs(interp, 2, objv, "name ?time?");
		return TCL_ERROR;
	    }
	    if (GetStatBuf(interp, objv[2], Tcl_FSStat, &buf) != TCL_OK) {
		return TCL_ERROR;
	    }
	    if (objc == 4) {
		if (Tcl_GetLongFromObj(interp, objv[3],
			(long*)(&buf.st_mtime)) != TCL_OK) {
		    return TCL_ERROR;
		}
		tval.actime = buf.st_atime;
		tval.modtime = buf.st_mtime;
		if (Tcl_FSUtime(objv[2], &tval) != 0) {
		    Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
			    "could not set modification time for file \"",
			    Tcl_GetString(objv[2]), "\": ",
			    Tcl_PosixError(interp), (char *) NULL);
		    return TCL_ERROR;
		}
		/*
		 * Do another stat to ensure that the we return the
		 * new recognized atime - hopefully the same as the
		 * one we sent in.  However, fs's like FAT don't
		 * even know what atime is.
		 */
		if (GetStatBuf(interp, objv[2], Tcl_FSStat, &buf) != TCL_OK) {
		    return TCL_ERROR;
		}
	    }
	    Tcl_SetLongObj(Tcl_GetObjResult(interp), (long) buf.st_mtime);
	    return TCL_OK;
	}
	case FCMD_MKDIR: {
	    if (objc < 3) {
		Tcl_WrongNumArgs(interp, 2, objv, "name ?name ...?");
		return TCL_ERROR;
	    }
	    return TclFileMakeDirsCmd(interp, objc, objv);
	}
	case FCMD_NATIVENAME: {
	    CONST char *fileName;
	    Tcl_DString ds;

	    if (objc != 3) {
		goto only3Args;
	    }
	    fileName = Tcl_GetString(objv[2]);
	    fileName = Tcl_TranslateFileName(interp, fileName, &ds);
	    if (fileName == NULL) {
		return TCL_ERROR;
	    }
	    Tcl_SetStringObj(Tcl_GetObjResult(interp), fileName, 
			     Tcl_DStringLength(&ds));
	    Tcl_DStringFree(&ds);
	    return TCL_OK;
	}
	case FCMD_NORMALIZE: {
	    Tcl_Obj *fileName;

	    if (objc != 3) {
		Tcl_WrongNumArgs(interp, 2, objv, "filename");
		return TCL_ERROR;
	    }

	    fileName = Tcl_FSGetNormalizedPath(interp, objv[2]);
	    Tcl_SetObjResult(interp, fileName);
	    return TCL_OK;
	}
	case FCMD_OWNED: {
	    int value;
	    Tcl_StatBuf buf;
	    
	    if (objc != 3) {
		goto only3Args;
	    }
	    value = 0;
	    if (GetStatBuf(NULL, objv[2], Tcl_FSStat, &buf) == TCL_OK) {
		/*
		 * For Windows and Macintosh, there are no user ids 
		 * associated with a file, so we always return 1.
		 */

#if (defined(__WIN32__) || defined(MAC_TCL))
		value = 1;
#else
		value = (geteuid() == buf.st_uid);
#endif
	    }	    
	    Tcl_SetBooleanObj(Tcl_GetObjResult(interp), value);
	    return TCL_OK;
	}
	case FCMD_PATHTYPE: {
	    if (objc != 3) {
		goto only3Args;
	    }
	    switch (Tcl_FSGetPathType(objv[2])) {
	    	case TCL_PATH_ABSOLUTE:
	    	    Tcl_SetStringObj(Tcl_GetObjResult(interp), "absolute", -1);
		    break;
	    	case TCL_PATH_RELATIVE:
	    	    Tcl_SetStringObj(Tcl_GetObjResult(interp), "relative", -1);
	    	    break;
	    	case TCL_PATH_VOLUME_RELATIVE:
		    Tcl_SetStringObj(Tcl_GetObjResult(interp), 
				     "volumerelative", -1);
		    break;
	    }
	    return TCL_OK;
	}
    	case FCMD_READABLE: {
	    if (objc != 3) {
		goto only3Args;
	    }
	    return CheckAccess(interp, objv[2], R_OK);
	}
	case FCMD_READLINK: {
	    Tcl_Obj *contents;
		
	    if (objc != 3) {
		goto only3Args;
	    }
	    
	    if (Tcl_FSConvertToPathType(interp, objv[2]) != TCL_OK) {
		return TCL_ERROR;
	    }

	    contents = Tcl_FSLink(objv[2], NULL, 0);

	    if (contents == NULL) {
	    	Tcl_AppendResult(interp, "could not readlink \"", 
	    		Tcl_GetString(objv[2]), "\": ", 
	    		Tcl_PosixError(interp), (char *) NULL);
	    	return TCL_ERROR;
	    }
	    Tcl_SetObjResult(interp, contents);
	    Tcl_DecrRefCount(contents);
	    return TCL_OK;
	}
	case FCMD_RENAME: {
	    return TclFileRenameCmd(interp, objc, objv);
	}
	case FCMD_ROOTNAME: {
	    int length;
	    char *fileName, *extension;
	    
	    if (objc != 3) {
		goto only3Args;
	    }
	    fileName = Tcl_GetStringFromObj(objv[2], &length);
	    extension = TclGetExtension(fileName);
	    if (extension == NULL) {
	    	Tcl_SetObjResult(interp, objv[2]);
	    } else {
	        Tcl_SetStringObj(Tcl_GetObjResult(interp), fileName,
			(int) (length - strlen(extension)));
	    }
	    return TCL_OK;
	}
	case FCMD_SEPARATOR: {
	    if ((objc < 2) || (objc > 3)) {
		Tcl_WrongNumArgs(interp, 2, objv, "?name?");
		return TCL_ERROR;
	    }
	    if (objc == 2) {
	        char *separator = NULL; /* lint */
		switch (tclPlatform) {
		    case TCL_PLATFORM_UNIX:
			separator = "/";
			break;
		    case TCL_PLATFORM_WINDOWS:
			separator = "\\";
			break;
		    case TCL_PLATFORM_MAC:
			separator = ":";
			break;
		}
		Tcl_SetObjResult(interp, Tcl_NewStringObj(separator,1));
	    } else {
		Tcl_Obj *separatorObj = Tcl_FSPathSeparator(objv[2]);
		if (separatorObj != NULL) {
		    Tcl_SetObjResult(interp, separatorObj);
		} else {
		    Tcl_SetObjResult(interp, 
			    Tcl_NewStringObj("Unrecognised path",-1));
		    return TCL_ERROR;
		}
	    }
	    return TCL_OK;
	}
	case FCMD_SIZE: {
	    Tcl_StatBuf buf;
	    
	    if (objc != 3) {
		goto only3Args;
	    }
	    if (GetStatBuf(interp, objv[2], Tcl_FSStat, &buf) != TCL_OK) {
		return TCL_ERROR;
	    }
	    Tcl_SetWideIntObj(Tcl_GetObjResult(interp),
		    (Tcl_WideInt) buf.st_size);
	    return TCL_OK;
	}
	case FCMD_SPLIT: {
	    if (objc != 3) {
		goto only3Args;
	    }
	    Tcl_SetObjResult(interp, Tcl_FSSplitPath(objv[2], NULL));
	    return TCL_OK;
	}
	case FCMD_STAT: {
	    char *varName;
	    Tcl_StatBuf buf;
	    
	    if (objc != 4) {
	    	Tcl_WrongNumArgs(interp, 1, objv, "stat name varName");
		return TCL_ERROR;
	    }
	    if (GetStatBuf(interp, objv[2], Tcl_FSStat, &buf) != TCL_OK) {
		return TCL_ERROR;
	    }
	    varName = Tcl_GetString(objv[3]);
	    return StoreStatData(interp, varName, &buf);
	}
	case FCMD_SYSTEM: {
	    Tcl_Obj* fsInfo;
	    if (objc != 3) {
		goto only3Args;
	    }
	    fsInfo = Tcl_FSFileSystemInfo(objv[2]);
	    if (fsInfo != NULL) {
		Tcl_SetObjResult(interp, fsInfo);
		return TCL_OK;
	    } else {
		Tcl_SetObjResult(interp, 
				 Tcl_NewStringObj("Unrecognised path",-1));
		return TCL_ERROR;
	    }
	}
    	case FCMD_TAIL: {
	    int splitElements;
	    Tcl_Obj *splitPtr;

	    if (objc != 3) {
		goto only3Args;
	    }
	    /* 
	     * The behaviour we want here is slightly different to
	     * the standard Tcl_FSSplitPath in the handling of home
	     * directories; Tcl_FSSplitPath preserves the "~" while 
	     * this code computes the actual full path name, if we
	     * had just a single component.
	     */	    
	    splitPtr = Tcl_FSSplitPath(objv[2], &splitElements);
	    if ((splitElements == 1) && (Tcl_GetString(objv[2])[0] == '~')) {
		Tcl_DecrRefCount(splitPtr);
		splitPtr = Tcl_FSGetNormalizedPath(interp, objv[2]);
		if (splitPtr == NULL) {
		    return TCL_ERROR;
		}
		splitPtr = Tcl_FSSplitPath(splitPtr, &splitElements);
	    }

	    /*
	     * Return the last component, unless it is the only component,
	     * and it is the root of an absolute path.
	     */

	    if (splitElements > 0) {
	    	if ((splitElements > 1)
		  || (Tcl_FSGetPathType(objv[2]) == TCL_PATH_RELATIVE)) {
		    
		    Tcl_Obj *tail = NULL;
		    Tcl_ListObjIndex(NULL, splitPtr, splitElements-1, &tail);
		    Tcl_SetObjResult(interp, tail);
	    	}
	    }
	    Tcl_DecrRefCount(splitPtr);
	    return TCL_OK;
	}
	case FCMD_TYPE: {
	    Tcl_StatBuf buf;

	    if (objc != 3) {
	    	goto only3Args;
	    }
	    if (GetStatBuf(interp, objv[2], Tcl_FSLstat, &buf) != TCL_OK) {
		return TCL_ERROR;
	    }
	    Tcl_SetStringObj(Tcl_GetObjResult(interp), 
		    GetTypeFromMode((unsigned short) buf.st_mode), -1);
	    return TCL_OK;
	}
	case FCMD_VOLUMES: {
	    if (objc != 2) {
		Tcl_WrongNumArgs(interp, 2, objv, NULL);
		return TCL_ERROR;
	    }
	    Tcl_SetObjResult(interp, Tcl_FSListVolumes());
	    return TCL_OK;
	}
	case FCMD_WRITABLE: {
	    if (objc != 3) {
	    	goto only3Args;
	    }
	    return CheckAccess(interp, objv[2], W_OK);
	}
    }

    only3Args:
    Tcl_WrongNumArgs(interp, 2, objv, "name");
    return TCL_ERROR;
}

/*
 *---------------------------------------------------------------------------
 *
 * CheckAccess --
 *
 *	Utility procedure used by Tcl_FileObjCmd() to query file
 *	attributes available through the access() system call.
 *
 * Results:
 *	Always returns TCL_OK.  Sets interp's result to boolean true or
 *	false depending on whether the file has the specified attribute.
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
 */
  
static int
CheckAccess(interp, objPtr, mode)
    Tcl_Interp *interp;		/* Interp for status return.  Must not be
				 * NULL. */
    Tcl_Obj *objPtr;		/* Name of file to check. */
    int mode;			/* Attribute to check; passed as argument to
				 * access(). */
{
    int value;
    
    if (Tcl_FSConvertToPathType(interp, objPtr) != TCL_OK) {
	value = 0;
    } else {
	value = (Tcl_FSAccess(objPtr, mode) == 0);
    }
    Tcl_SetBooleanObj(Tcl_GetObjResult(interp), value);

    return TCL_OK;
}

/*
 *---------------------------------------------------------------------------
 *
 * GetStatBuf --
 *
 *	Utility procedure used by Tcl_FileObjCmd() to query file
 *	attributes available through the stat() or lstat() system call.
 *
 * Results:
 *	The return value is TCL_OK if the specified file exists and can
 *	be stat'ed, TCL_ERROR otherwise.  If TCL_ERROR is returned, an
 *	error message is left in interp's result.  If TCL_OK is returned,
 *	*statPtr is filled with information about the specified file.
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
 */

static int
GetStatBuf(interp, objPtr, statProc, statPtr)
    Tcl_Interp *interp;		/* Interp for error return.  May be NULL. */
    Tcl_Obj *objPtr;		/* Path name to examine. */
    Tcl_FSStatProc *statProc;	/* Either stat() or lstat() depending on
				 * desired behavior. */
    Tcl_StatBuf *statPtr;	/* Filled with info about file obtained by
				 * calling (*statProc)(). */
{
    int status;
    
    if (Tcl_FSConvertToPathType(interp, objPtr) != TCL_OK) {
	return TCL_ERROR;
    }

    status = (*statProc)(objPtr, statPtr);
    
    if (status < 0) {
	if (interp != NULL) {
	    Tcl_AppendResult(interp, "could not read \"",
		    Tcl_GetString(objPtr), "\": ",
		    Tcl_PosixError(interp), (char *) NULL);
	}
	return TCL_ERROR;
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * StoreStatData --
 *
 *	This is a utility procedure that breaks out the fields of a
 *	"stat" structure and stores them in textual form into the
 *	elements of an associative array.
 *
 * Results:
 *	Returns a standard Tcl return value.  If an error occurs then
 *	a message is left in interp's result.
 *
 * Side effects:
 *	Elements of the associative array given by "varName" are modified.
 *
 *----------------------------------------------------------------------
 */

static int
StoreStatData(interp, varName, statPtr)
    Tcl_Interp *interp;			/* Interpreter for error reports. */
    char *varName;			/* Name of associative array variable
					 * in which to store stat results. */
    Tcl_StatBuf *statPtr;		/* Pointer to buffer containing
					 * stat data to store in varName. */
{
    Tcl_Obj *var = Tcl_NewStringObj(varName, -1);
    Tcl_Obj *field = Tcl_NewObj();
    Tcl_Obj *value;
    register unsigned short mode;

    /*
     * Assume Tcl_ObjSetVar2() does not keep a copy of the field name!
     */
#define STORE_ARY(fieldName, object) \
    Tcl_SetStringObj(field, (fieldName), -1); \
    value = (object); \
    if (Tcl_ObjSetVar2(interp,var,field,value,TCL_LEAVE_ERR_MSG) == NULL) { \
	Tcl_DecrRefCount(var); \
	Tcl_DecrRefCount(field); \
	Tcl_DecrRefCount(value); \
	return TCL_ERROR; \
    }

    Tcl_IncrRefCount(var);
    Tcl_IncrRefCount(field);
    STORE_ARY("dev",   Tcl_NewLongObj((long)statPtr->st_dev));
    /*
     * Watch out porters; the inode is meant to be an *unsigned* value,
     * so the cast might fail when there isn't a real arithmentic 'long
     * long' type...
     */
    STORE_ARY("ino",   Tcl_NewWideIntObj((Tcl_WideInt)statPtr->st_ino));
    STORE_ARY("nlink", Tcl_NewLongObj((long)statPtr->st_nlink));
    STORE_ARY("uid",   Tcl_NewLongObj((long)statPtr->st_uid));
    STORE_ARY("gid",   Tcl_NewLongObj((long)statPtr->st_gid));
    STORE_ARY("size",  Tcl_NewWideIntObj((Tcl_WideInt)statPtr->st_size));
#ifdef HAVE_ST_BLOCKS
    STORE_ARY("blocks",Tcl_NewWideIntObj((Tcl_WideInt)statPtr->st_blocks));
#endif
    STORE_ARY("atime", Tcl_NewLongObj((long)statPtr->st_atime));
    STORE_ARY("mtime", Tcl_NewLongObj((long)statPtr->st_mtime));
    STORE_ARY("ctime", Tcl_NewLongObj((long)statPtr->st_ctime));
    mode = (unsigned short) statPtr->st_mode;
    STORE_ARY("mode",  Tcl_NewIntObj(mode));
    STORE_ARY("type",  Tcl_NewStringObj(GetTypeFromMode(mode), -1));
#undef STORE_ARY
    Tcl_DecrRefCount(var);
    Tcl_DecrRefCount(field);
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * GetTypeFromMode --
 *
 *	Given a mode word, returns a string identifying the type of a
 *	file.
 *
 * Results:
 *	A static text string giving the file type from mode.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static char *
GetTypeFromMode(mode)
    int mode;
{
    if (S_ISREG(mode)) {
	return "file";
    } else if (S_ISDIR(mode)) {
	return "directory";
    } else if (S_ISCHR(mode)) {
	return "characterSpecial";
    } else if (S_ISBLK(mode)) {
	return "blockSpecial";
    } else if (S_ISFIFO(mode)) {
	return "fifo";
#ifdef S_ISLNK
    } else if (S_ISLNK(mode)) {
	return "link";
#endif
#ifdef S_ISSOCK
    } else if (S_ISSOCK(mode)) {
	return "socket";
#endif
    }
    return "unknown";
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_ForObjCmd --
 *
 *      This procedure is invoked to process the "for" Tcl command.
 *      See the user documentation for details on what it does.
 *
 *	With the bytecode compiler, this procedure is only called when
 *	a command name is computed at runtime, and is "for" or the name
 *	to which "for" was renamed: e.g.,
 *	"set z for; $z {set i 0} {$i<100} {incr i} {puts $i}"
 *
 * Results:
 *      A standard Tcl result.
 *
 * Side effects:
 *      See the user documentation.
 *
 *----------------------------------------------------------------------
 */

        /* ARGSUSED */
int
Tcl_ForObjCmd(dummy, interp, objc, objv)
    ClientData dummy;                   /* Not used. */
    Tcl_Interp *interp;                 /* Current interpreter. */
    int objc;                           /* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    int result, value;

    if (objc != 5) {
        Tcl_WrongNumArgs(interp, 1, objv, "start test next command");
        return TCL_ERROR;
    }

    result = Tcl_EvalObjEx(interp, objv[1], 0);
    if (result != TCL_OK) {
        if (result == TCL_ERROR) {
            Tcl_AddErrorInfo(interp, "\n    (\"for\" initial command)");
        }
        return result;
    }
    while (1) {
	/*
	 * We need to reset the result before passing it off to
	 * Tcl_ExprBooleanObj.  Otherwise, any error message will be appended
	 * to the result of the last evaluation.
	 */

	Tcl_ResetResult(interp);
        result = Tcl_ExprBooleanObj(interp, objv[2], &value);
        if (result != TCL_OK) {
            return result;
        }
        if (!value) {
            break;
        }
        result = Tcl_EvalObjEx(interp, objv[4], 0);
        if ((result != TCL_OK) && (result != TCL_CONTINUE)) {
            if (result == TCL_ERROR) {
                char msg[32 + TCL_INTEGER_SPACE];

                sprintf(msg, "\n    (\"for\" body line %d)",interp->errorLine);
                Tcl_AddErrorInfo(interp, msg);
            }
            break;
        }
        result = Tcl_EvalObjEx(interp, objv[3], 0);
	if (result == TCL_BREAK) {
            break;
        } else if (result != TCL_OK) {
            if (result == TCL_ERROR) {
                Tcl_AddErrorInfo(interp, "\n    (\"for\" loop-end command)");
            }
            return result;
        }
    }
    if (result == TCL_BREAK) {
        result = TCL_OK;
    }
    if (result == TCL_OK) {
        Tcl_ResetResult(interp);
    }
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_ForeachObjCmd --
 *
 *	This object-based procedure is invoked to process the "foreach" Tcl
 *	command.  See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl object result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
int
Tcl_ForeachObjCmd(dummy, interp, objc, objv)
    ClientData dummy;		/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    int result = TCL_OK;
    int i;			/* i selects a value list */
    int j, maxj;		/* Number of loop iterations */
    int v;			/* v selects a loop variable */
    int numLists;		/* Count of value lists */
    Tcl_Obj *bodyPtr;

    /*
     * We copy the argument object pointers into a local array to avoid
     * the problem that "objv" might become invalid. It is a pointer into
     * the evaluation stack and that stack might be grown and reallocated
     * if the loop body requires a large amount of stack space.
     */
    
#define NUM_ARGS 9
    Tcl_Obj *(argObjStorage[NUM_ARGS]);
    Tcl_Obj **argObjv = argObjStorage;
    
#define STATIC_LIST_SIZE 4
    int indexArray[STATIC_LIST_SIZE];
    int varcListArray[STATIC_LIST_SIZE];
    Tcl_Obj **varvListArray[STATIC_LIST_SIZE];
    int argcListArray[STATIC_LIST_SIZE];
    Tcl_Obj **argvListArray[STATIC_LIST_SIZE];

    int *index = indexArray;		   /* Array of value list indices */
    int *varcList = varcListArray;	   /* # loop variables per list */
    Tcl_Obj ***varvList = varvListArray;   /* Array of var name lists */
    int *argcList = argcListArray;	   /* Array of value list sizes */
    Tcl_Obj ***argvList = argvListArray;   /* Array of value lists */

    if (objc < 4 || (objc%2 != 0)) {
	Tcl_WrongNumArgs(interp, 1, objv,
		"varList list ?varList list ...? command");
	return TCL_ERROR;
    }

    /*
     * Create the object argument array "argObjv". Make sure argObjv is
     * large enough to hold the objc arguments.
     */

    if (objc > NUM_ARGS) {
	argObjv = (Tcl_Obj **) ckalloc(objc * sizeof(Tcl_Obj *));
    }
    for (i = 0;  i < objc;  i++) {
	argObjv[i] = objv[i];
    }

    /*
     * Manage numList parallel value lists.
     * argvList[i] is a value list counted by argcList[i]
     * varvList[i] is the list of variables associated with the value list
     * varcList[i] is the number of variables associated with the value list
     * index[i] is the current pointer into the value list argvList[i]
     */

    numLists = (objc-2)/2;
    if (numLists > STATIC_LIST_SIZE) {
	index = (int *) ckalloc(numLists * sizeof(int));
	varcList = (int *) ckalloc(numLists * sizeof(int));
	varvList = (Tcl_Obj ***) ckalloc(numLists * sizeof(Tcl_Obj **));
	argcList = (int *) ckalloc(numLists * sizeof(int));
	argvList = (Tcl_Obj ***) ckalloc(numLists * sizeof(Tcl_Obj **));
    }
    for (i = 0;  i < numLists;  i++) {
	index[i] = 0;
	varcList[i] = 0;
	varvList[i] = (Tcl_Obj **) NULL;
	argcList[i] = 0;
	argvList[i] = (Tcl_Obj **) NULL;
    }

    /*
     * Break up the value lists and variable lists into elements
     */

    maxj = 0;
    for (i = 0;  i < numLists;  i++) {
	result = Tcl_ListObjGetElements(interp, argObjv[1+i*2],
	        &varcList[i], &varvList[i]);
	if (result != TCL_OK) {
	    goto done;
	}
	if (varcList[i] < 1) {
	    Tcl_AppendToObj(Tcl_GetObjResult(interp),
	            "foreach varlist is empty", -1);
	    result = TCL_ERROR;
	    goto done;
	}
	
	result = Tcl_ListObjGetElements(interp, argObjv[2+i*2],
	        &argcList[i], &argvList[i]);
	if (result != TCL_OK) {
	    goto done;
	}
	
	j = argcList[i] / varcList[i];
	if ((argcList[i] % varcList[i]) != 0) {
	    j++;
	}
	if (j > maxj) {
	    maxj = j;
	}
    }

    /*
     * Iterate maxj times through the lists in parallel
     * If some value lists run out of values, set loop vars to ""
     */
    
    bodyPtr = argObjv[objc-1];
    for (j = 0;  j < maxj;  j++) {
	for (i = 0;  i < numLists;  i++) {
	    /*
	     * Refetch the list members; we assume that the sizes are
	     * the same, but the array of elements might be different
	     * if the internal rep of the objects has been lost and
	     * recreated (it is too difficult to accurately tell when
	     * this happens, which can lead to some wierd crashes,
	     * like Bug #494348...)
	     */

	    result = Tcl_ListObjGetElements(interp, argObjv[1+i*2],
		    &varcList[i], &varvList[i]);
	    if (result != TCL_OK) {
		panic("Tcl_ForeachObjCmd: could not reconvert variable list %d to a list object\n", i);
	    }
	    result = Tcl_ListObjGetElements(interp, argObjv[2+i*2],
		    &argcList[i], &argvList[i]);
	    if (result != TCL_OK) {
		panic("Tcl_ForeachObjCmd: could not reconvert value list %d to a list object\n", i);
	    }
	    
	    for (v = 0;  v < varcList[i];  v++) {
		int k = index[i]++;
		Tcl_Obj *valuePtr, *varValuePtr;
		int isEmptyObj = 0;
		
		if (k < argcList[i]) {
		    valuePtr = argvList[i][k];
		} else {
		    valuePtr = Tcl_NewObj(); /* empty string */
		    isEmptyObj = 1;
		}
		varValuePtr = Tcl_ObjSetVar2(interp, varvList[i][v],
			NULL, valuePtr, 0);
		if (varValuePtr == NULL) {
		    if (isEmptyObj) {
			Tcl_DecrRefCount(valuePtr);
		    }
		    Tcl_ResetResult(interp);
		    Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
			"couldn't set loop variable: \"",
			Tcl_GetString(varvList[i][v]), "\"", (char *) NULL);
		    result = TCL_ERROR;
		    goto done;
		}

	    }
	}

	result = Tcl_EvalObjEx(interp, bodyPtr, 0);
	if (result != TCL_OK) {
	    if (result == TCL_CONTINUE) {
		result = TCL_OK;
	    } else if (result == TCL_BREAK) {
		result = TCL_OK;
		break;
	    } else if (result == TCL_ERROR) {
                char msg[32 + TCL_INTEGER_SPACE];

		sprintf(msg, "\n    (\"foreach\" body line %d)",
			interp->errorLine);
		Tcl_AddObjErrorInfo(interp, msg, -1);
		break;
	    } else {
		break;
	    }
	}
    }
    if (result == TCL_OK) {
	Tcl_ResetResult(interp);
    }

    done:
    if (numLists > STATIC_LIST_SIZE) {
	ckfree((char *) index);
	ckfree((char *) varcList);
	ckfree((char *) argcList);
	ckfree((char *) varvList);
	ckfree((char *) argvList);
    }
    if (argObjv != argObjStorage) {
	ckfree((char *) argObjv);
    }
    return result;
#undef STATIC_LIST_SIZE
#undef NUM_ARGS
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_FormatObjCmd --
 *
 *	This procedure is invoked to process the "format" Tcl command.
 *	See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
int
Tcl_FormatObjCmd(dummy, interp, objc, objv)
    ClientData dummy;    	/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    char *format;		/* Used to read characters from the format
				 * string. */
    int formatLen;		/* The length of the format string */
    char *endPtr;		/* Points to the last char in format array */
    char newFormat[43];		/* A new format specifier is generated here. */
    int width;			/* Field width from field specifier, or 0 if
				 * no width given. */
    int precision;		/* Field precision from field specifier, or 0
				 * if no precision given. */
    int size;			/* Number of bytes needed for result of
				 * conversion, based on type of conversion
				 * ("e", "s", etc.), width, and precision. */
    long intValue;		/* Used to hold value to pass to sprintf, if
				 * it's a one-word integer or char value */
    char *ptrValue = NULL;	/* Used to hold value to pass to sprintf, if
				 * it's a one-word value. */
    double doubleValue;		/* Used to hold value to pass to sprintf if
				 * it's a double value. */
#ifndef TCL_WIDE_INT_IS_LONG
    Tcl_WideInt wideValue;	/* Used to hold value to pass to sprintf if
				 * it's a 'long long' value. */
#endif /* TCL_WIDE_INT_IS_LONG */
    int whichValue;		/* Indicates which of intValue, ptrValue,
				 * or doubleValue has the value to pass to
				 * sprintf, according to the following
				 * definitions: */
#   define INT_VALUE 0
#   define CHAR_VALUE 1
#   define PTR_VALUE 2
#   define DOUBLE_VALUE 3
#   define STRING_VALUE 4
#   define WIDE_VALUE 5
#   define MAX_FLOAT_SIZE 320

    Tcl_Obj *resultPtr;  	/* Where result is stored finally. */
    char staticBuf[MAX_FLOAT_SIZE + 1];
                                /* A static buffer to copy the format results 
				 * into */
    char *dst = staticBuf;      /* The buffer that sprintf writes into each
				 * time the format processes a specifier */
    int dstSize = MAX_FLOAT_SIZE;
                                /* The size of the dst buffer */
    int noPercent;		/* Special case for speed:  indicates there's
				 * no field specifier, just a string to copy.*/
    int objIndex;		/* Index of argument to substitute next. */
    int gotXpg = 0;		/* Non-zero means that an XPG3 %n$-style
				 * specifier has been seen. */
    int gotSequential = 0;	/* Non-zero means that a regular sequential
				 * (non-XPG3) conversion specifier has been
				 * seen. */
    int useShort;		/* Value to be printed is short (half word). */
    char *end;			/* Used to locate end of numerical fields. */
    int stringLen = 0;		/* Length of string in characters rather
				 * than bytes.  Used for %s substitution. */
    int gotMinus;		/* Non-zero indicates that a minus flag has
				 * been seen in the current field. */
    int gotPrecision;		/* Non-zero indicates that a precision has
				 * been set for the current field. */
    int gotZero;		/* Non-zero indicates that a zero flag has
				 * been seen in the current field. */
#ifndef TCL_WIDE_INT_IS_LONG
    int useWide;		/* Value to be printed is Tcl_WideInt. */
#endif /* TCL_WIDE_INT_IS_LONG */

    /*
     * This procedure is a bit nasty.  The goal is to use sprintf to
     * do most of the dirty work.  There are several problems:
     * 1. this procedure can't trust its arguments.
     * 2. we must be able to provide a large enough result area to hold
     *    whatever's generated.  This is hard to estimate.
     * 3. there's no way to move the arguments from objv to the call
     *    to sprintf in a reasonable way.  This is particularly nasty
     *    because some of the arguments may be two-word values (doubles
     *    and wide-ints).
     * So, what happens here is to scan the format string one % group
     * at a time, making many individual calls to sprintf.
     */

    if (objc < 2) {
        Tcl_WrongNumArgs(interp, 1, objv, "formatString ?arg arg ...?");
	return TCL_ERROR;
    }

    format = Tcl_GetStringFromObj(objv[1], &formatLen);
    endPtr = format + formatLen;
    resultPtr = Tcl_NewObj();
    objIndex = 2;

    while (format < endPtr) {
	register char *newPtr = newFormat;

	width = precision = noPercent = useShort = 0;
	gotZero = gotMinus = gotPrecision = 0;
#ifndef TCL_WIDE_INT_IS_LONG
	useWide = 0;
#endif /* TCL_WIDE_INT_IS_LONG */
	whichValue = PTR_VALUE;

	/*
	 * Get rid of any characters before the next field specifier.
	 */
	if (*format != '%') {
	    ptrValue = format;
	    while ((*format != '%') && (format < endPtr)) {
		format++;
	    }
	    size = format - ptrValue;
	    noPercent = 1;
	    goto doField;
	}

	if (format[1] == '%') {
	    ptrValue = format;
	    size = 1;
	    noPercent = 1;
	    format += 2;
	    goto doField;
	}

	/*
	 * Parse off a field specifier, compute how many characters
	 * will be needed to store the result, and substitute for
	 * "*" size specifiers.
	 */
	*newPtr = '%';
	newPtr++;
	format++;
	if (isdigit(UCHAR(*format))) { /* INTL: Tcl source. */
	    int tmp;

	    /*
	     * Check for an XPG3-style %n$ specification.  Note: there
	     * must not be a mixture of XPG3 specs and non-XPG3 specs
	     * in the same format string.
	     */

	    tmp = strtoul(format, &end, 10);	/* INTL: "C" locale. */
	    if (*end != '$') {
		goto notXpg;
	    }
	    format = end+1;
	    gotXpg = 1;
	    if (gotSequential) {
		goto mixedXPG;
	    }
	    objIndex = tmp+1;
	    if ((objIndex < 2) || (objIndex >= objc)) {
		goto badIndex;
	    }
	    goto xpgCheckDone;
	}

	notXpg:
	gotSequential = 1;
	if (gotXpg) {
	    goto mixedXPG;
	}

	xpgCheckDone:
	while ((*format == '-') || (*format == '#') || (*format == '0')
		|| (*format == ' ') || (*format == '+')) {
	    if (*format == '-') {
		gotMinus = 1;
	    }
	    if (*format == '0') {
		/*
		 * This will be handled by sprintf for numbers, but we
		 * need to do the char/string ones ourselves
		 */
		gotZero = 1;
	    }
	    *newPtr = *format;
	    newPtr++;
	    format++;
	}
	if (isdigit(UCHAR(*format))) {		/* INTL: Tcl source. */
	    width = strtoul(format, &end, 10);	/* INTL: Tcl source. */
	    format = end;
	} else if (*format == '*') {
	    if (objIndex >= objc) {
		goto badIndex;
	    }
	    if (Tcl_GetIntFromObj(interp,	/* INTL: Tcl source. */
		    objv[objIndex], &width) != TCL_OK) {
		goto fmtError;
	    }
	    if (width < 0) {
		width = -width;
		*newPtr = '-';
		gotMinus = 1;
		newPtr++;
	    }
	    objIndex++;
	    format++;
	}
	if (width > 100000) {
	    /*
	     * Don't allow arbitrarily large widths:  could cause core
	     * dump when we try to allocate a zillion bytes of memory
	     * below.
	     */

	    width = 100000;
	} else if (width < 0) {
	    width = 0;
	}
	if (width != 0) {
	    TclFormatInt(newPtr, width);	/* INTL: printf format. */
	    while (*newPtr != 0) {
		newPtr++;
	    }
	}
	if (*format == '.') {
	    *newPtr = '.';
	    newPtr++;
	    format++;
	    gotPrecision = 1;
	}
	if (isdigit(UCHAR(*format))) {		/* INTL: Tcl source. */
	    precision = strtoul(format, &end, 10);  /* INTL: "C" locale. */
	    format = end;
	} else if (*format == '*') {
	    if (objIndex >= objc) {
		goto badIndex;
	    }
	    if (Tcl_GetIntFromObj(interp,	/* INTL: Tcl source. */
		    objv[objIndex], &precision) != TCL_OK) {
		goto fmtError;
	    }
	    objIndex++;
	    format++;
	}
	if (gotPrecision) {
	    TclFormatInt(newPtr, precision);	/* INTL: printf format. */
	    while (*newPtr != 0) {
		newPtr++;
	    }
	}
	if (*format == 'l') {
#ifndef TCL_WIDE_INT_IS_LONG
	    useWide = 1;
	    strcpy(newPtr, TCL_LL_MODIFIER);
	    newPtr += TCL_LL_MODIFIER_SIZE;
#endif /* TCL_WIDE_INT_IS_LONG */
	    format++;
	} else if (*format == 'h') {
	    useShort = 1;
	    *newPtr = 'h';
	    newPtr++;
	    format++;
	}
	*newPtr = *format;
	newPtr++;
	*newPtr = 0;
	if (objIndex >= objc) {
	    goto badIndex;
	}
	switch (*format) {
	    case 'i':
		newPtr[-1] = 'd';
	    case 'd':
	    case 'o':
	    case 'u':
	    case 'x':
	    case 'X':
#ifndef TCL_WIDE_INT_IS_LONG
		if (useWide) {
		    if (Tcl_GetWideIntFromObj(interp, /* INTL: Tcl source. */
			    objv[objIndex], &wideValue) != TCL_OK) {
			goto fmtError;
		    }
		    whichValue = WIDE_VALUE;
		    size = 40 + precision;
		    break;
		}
#endif /* TCL_WIDE_INT_IS_LONG */
		if (Tcl_GetLongFromObj(interp,	      /* INTL: Tcl source. */
			objv[objIndex], &intValue) != TCL_OK) {
		    goto fmtError;
		}
#if (LONG_MAX > INT_MAX)
		/*
		 * Add the 'l' for long format type because we are on
		 * an LP64 archtecture and we are really going to pass
		 * a long argument to sprintf.
		 */
		newPtr++;
		*newPtr = 0;
		newPtr[-1] = newPtr[-2];
		newPtr[-2] = 'l';
#endif /* LONG_MAX > INT_MAX */
		whichValue = INT_VALUE;
		size = 40 + precision;
		break;
	    case 's':
		/*
		 * Compute the length of the string in characters and add
		 * any additional space required by the field width.  All of
		 * the extra characters will be spaces, so one byte per
		 * character is adequate.
		 */

		whichValue = STRING_VALUE;
		ptrValue = Tcl_GetStringFromObj(objv[objIndex], &size);
		stringLen = Tcl_NumUtfChars(ptrValue, size);
		if (gotPrecision && (precision < stringLen)) {
		    stringLen = precision;
		}
		size = Tcl_UtfAtIndex(ptrValue, stringLen) - ptrValue;
		if (width > stringLen) {
		    size += (width - stringLen);
		}
		break;
	    case 'c':
		if (Tcl_GetLongFromObj(interp,	/* INTL: Tcl source. */
			objv[objIndex], &intValue) != TCL_OK) {
		    goto fmtError;
		}
		whichValue = CHAR_VALUE;
		size = width + TCL_UTF_MAX;
		break;
	    case 'e':
	    case 'E':
	    case 'f':
	    case 'g':
	    case 'G':
		if (Tcl_GetDoubleFromObj(interp, /* INTL: Tcl source. */
			objv[objIndex], &doubleValue) != TCL_OK) {
		    goto fmtError;
		}
		whichValue = DOUBLE_VALUE;
		size = MAX_FLOAT_SIZE;
		if (precision > 10) {
		    size += precision;
		}
		break;
	    case 0:
		Tcl_SetResult(interp,
		        "format string ended in middle of field specifier",
			TCL_STATIC);
		goto fmtError;
	    default: {
		char buf[40];
		sprintf(buf, "bad field specifier \"%c\"", *format);
		Tcl_SetResult(interp, buf, TCL_VOLATILE);
		goto fmtError;
	    }
	}
	objIndex++;
	format++;

	/*
	 * Make sure that there's enough space to hold the formatted
	 * result, then format it.
	 */

	doField:
	if (width > size) {
	    size = width;
	}
	if (noPercent) {
	    Tcl_AppendToObj(resultPtr, ptrValue, size);
	} else {
	    if (size > dstSize) {
	        if (dst != staticBuf) {
		    ckfree(dst);
		}
		dst = (char *) ckalloc((unsigned) (size + 1));
		dstSize = size;
	    }
	    switch (whichValue) {
		case DOUBLE_VALUE: {
		    sprintf(dst, newFormat, doubleValue); /* INTL: user locale. */
		    break;
		}
#ifndef TCL_WIDE_INT_IS_LONG
		case WIDE_VALUE: {
		    sprintf(dst, newFormat, wideValue);
		    break;
		}
#endif /* TCL_WIDE_INT_IS_LONG */
		case INT_VALUE: {
		    if (useShort) {
			sprintf(dst, newFormat, (short) intValue);
		    } else {
			sprintf(dst, newFormat, intValue);
		    }
		    break;
		}
		case CHAR_VALUE: {
		    char *ptr;
		    char padChar = (gotZero ? '0' : ' ');
		    ptr = dst;
		    if (!gotMinus) {
			for ( ; --width > 0; ptr++) {
			    *ptr = padChar;
			}
		    }
		    ptr += Tcl_UniCharToUtf(intValue, ptr);
		    for ( ; --width > 0; ptr++) {
			*ptr = padChar;
		    }
		    *ptr = '\0';
		    break;
		}
		case STRING_VALUE: {
		    char *ptr;
		    char padChar = (gotZero ? '0' : ' ');
		    int pad;

		    ptr = dst;
		    if (width > stringLen) {
			pad = width - stringLen;
		    } else {
			pad = 0;
		    }

		    if (!gotMinus) {
			while (pad > 0) {
			    *ptr++ = padChar;
			    pad--;
			}
		    }

		    size = Tcl_UtfAtIndex(ptrValue, stringLen) - ptrValue; 
		    if (size) {
			memcpy(ptr, ptrValue, (size_t) size);
			ptr += size;
		    }
		    while (pad > 0) {
			*ptr++ = padChar;
			pad--;
		    }
		    *ptr = '\0';
		    break;
		}
		default: {
		    sprintf(dst, newFormat, ptrValue);
		    break;
		}
	    }
	    Tcl_AppendToObj(resultPtr, dst, -1);
	}
    }

    Tcl_SetObjResult(interp, resultPtr);
    if(dst != staticBuf) {
        ckfree(dst);
    }
    return TCL_OK;

    mixedXPG:
    Tcl_SetResult(interp, 
            "cannot mix \"%\" and \"%n$\" conversion specifiers", TCL_STATIC);
    goto fmtError;

    badIndex:
    if (gotXpg) {
        Tcl_SetResult(interp, 
                "\"%n$\" argument index out of range", TCL_STATIC);
    } else {
        Tcl_SetResult(interp, 
                "not enough arguments for all format specifiers", TCL_STATIC);
    }

    fmtError:
    if(dst != staticBuf) {
        ckfree(dst);
    }
    Tcl_DecrRefCount(resultPtr);
    return TCL_ERROR;
}
@


1.5
log
@Updated to tcl 8.4.1
@
text
@d804 10
a813 10
	FILE_ATIME,	FILE_ATTRIBUTES, FILE_CHANNELS,	FILE_COPY,
	FILE_DELETE,
	FILE_DIRNAME,	FILE_EXECUTABLE, FILE_EXISTS,	FILE_EXTENSION,
	FILE_ISDIRECTORY, FILE_ISFILE,	FILE_JOIN,	FILE_LINK, 
	FILE_LSTAT,     FILE_MTIME,	FILE_MKDIR,	FILE_NATIVENAME, 
	FILE_NORMALIZE, FILE_OWNED,
	FILE_PATHTYPE,	FILE_READABLE,	FILE_READLINK,	FILE_RENAME,
	FILE_ROOTNAME,	FILE_SEPARATOR, FILE_SIZE,	FILE_SPLIT,	
	FILE_STAT,      FILE_SYSTEM, 
	FILE_TAIL,	FILE_TYPE,	FILE_VOLUMES,	FILE_WRITABLE
d826 1
a826 1
    	case FILE_ATIME: {
d864 1
a864 1
	case FILE_ATTRIBUTES: {
d867 1
a867 1
	case FILE_CHANNELS: {
d875 1
a875 1
	case FILE_COPY: {
d878 1
a878 1
	case FILE_DELETE: {
d881 1
a881 1
    	case FILE_DIRNAME: {
d895 1
a895 1
	case FILE_EXECUTABLE: {
d901 1
a901 1
	case FILE_EXISTS: {
d907 1
a907 1
	case FILE_EXTENSION: {
d919 1
a919 1
    	case FILE_ISDIRECTORY: {
d933 1
a933 1
    	case FILE_ISFILE: {
d947 1
a947 1
	case FILE_JOIN: {
d958 1
a958 1
	case FILE_LINK: {
d1048 1
a1048 1
    	case FILE_LSTAT: {
d1062 1
a1062 1
	case FILE_MTIME: {
d1100 1
a1100 1
	case FILE_MKDIR: {
d1107 1
a1107 1
	case FILE_NATIVENAME: {
d1124 1
a1124 1
	case FILE_NORMALIZE: {
d1136 1
a1136 1
	case FILE_OWNED: {
d1159 1
a1159 1
	case FILE_PATHTYPE: {
d1177 1
a1177 1
    	case FILE_READABLE: {
d1183 1
a1183 1
	case FILE_READLINK: {
d1206 1
a1206 1
	case FILE_RENAME: {
d1209 1
a1209 1
	case FILE_ROOTNAME: {
d1226 1
a1226 1
	case FILE_SEPARATOR: {
d1257 1
a1257 1
	case FILE_SIZE: {
d1270 1
a1270 1
	case FILE_SPLIT: {
d1277 1
a1277 1
	case FILE_STAT: {
d1291 1
a1291 1
	case FILE_SYSTEM: {
d1306 1
a1306 1
    	case FILE_TAIL: {
d1347 1
a1347 1
	case FILE_TYPE: {
d1360 1
a1360 1
	case FILE_VOLUMES: {
d1368 1
a1368 1
	case FILE_WRITABLE: {
@


1.4
log
@touched all sources to ease next import
@
text
@d14 1
a14 1
 * RCS: @@(#) $Id: tclCmdAH.c,v 1.7.8.1 2000/04/06 22:38:28 spolk Exp $
a20 2
typedef int (StatProc)_ANSI_ARGS_((CONST char *path, struct stat *buf));

d28 2
a29 2
			    Tcl_Obj *objPtr, StatProc *statProc,
			    struct stat *statPtr));
a30 2
static int		SplitPath _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_Obj *objPtr, int *argcPtr, char ***argvPtr));
d32 1
a32 3
			    char *varName, struct stat *statPtr));
static char **		StringifyObjects _ANSI_ARGS_((int objc,
			    Tcl_Obj *CONST objv[]));
d96 1
a96 1
    int body, result;
a97 1
    int caseObjc;
d133 1
a133 1
	char **patObjv;
d303 1
a303 2
    char *dirName;
    Tcl_DString ds;
d312 1
a312 1
	dirName = Tcl_GetString(objv[1]);
d314 2
a315 1
	dirName = "~";
d317 9
a325 2
    if (Tcl_TranslateFileName(interp, dirName, &ds) == NULL) {
	return TCL_ERROR;
d327 2
a328 8

    result = Tcl_Chdir(Tcl_DStringValue(&ds));
    Tcl_DStringFree(&ds);

    if (result != 0) {
	Tcl_AppendResult(interp, "couldn't change working directory to \"",
		dirName, "\": ", Tcl_PosixError(interp), (char *) NULL);
	return TCL_ERROR;
d330 1
a330 1
    return TCL_OK;
d429 1
a429 1
    static char *optionStrings[] = {
d514 2
a515 1
	        Tcl_SetResult(interp, Tcl_GetEncodingName(NULL), TCL_STATIC);
d727 1
d764 3
a766 1
 *
a783 1
    Tcl_Obj *resultPtr;
d790 1
a790 1
    static char *fileOptions[] = {
d794 3
a796 2
	"isdirectory",	"isfile",	"join",		"lstat",
	"mtime",	"mkdir",	"nativename",	"owned",
d798 2
a799 1
	"rootname",	"size",		"split",	"stat",
d807 3
a809 2
	FILE_ISDIRECTORY, FILE_ISFILE,	FILE_JOIN,	FILE_LSTAT,
	FILE_MTIME,	FILE_MKDIR,	FILE_NATIVENAME, FILE_OWNED,
d811 2
a812 1
	FILE_ROOTNAME,	FILE_SIZE,	FILE_SPLIT,	FILE_STAT,
a824 1
    resultPtr = Tcl_GetObjResult(interp);
d827 1
a827 2
	    struct stat buf;
	    char *fileName;
d834 1
a834 1
	    if (GetStatBuf(interp, objv[2], TclStat, &buf) != TCL_OK) {
d844 2
a845 3
		fileName = Tcl_GetString(objv[2]);
		if (utime(fileName, &tval) != 0) {
		    Tcl_AppendStringsToObj(resultPtr,
d847 1
a847 1
			    fileName, "\": ",
d857 1
a857 1
		if (GetStatBuf(interp, objv[2], TclStat, &buf) != TCL_OK) {
d861 1
a861 1
	    Tcl_SetLongObj(resultPtr, (long) buf.st_atime);
d876 1
a876 7
	    int result;
	    char **argv;

	    argv = StringifyObjects(objc, objv);
	    result = TclFileCopyCmd(interp, objc, argv);
	    ckfree((char *) argv);
	    return result;
d879 1
a879 7
	    int result;
	    char **argv;

	    argv = StringifyObjects(objc, objv);
	    result = TclFileDeleteCmd(interp, objc, argv);
	    ckfree((char *) argv);
	    return result;
d882 1
a882 3
    	    int argc;
	    char **argv;

d886 3
a888 22
	    if (SplitPath(interp, objv[2], &argc, &argv) != TCL_OK) {
		return TCL_ERROR;
	    }

	    /*
	     * Return all but the last component.  If there is only one
	     * component, return it if the path was non-relative, otherwise
	     * return the current directory.
	     */

	    if (argc > 1) {
		Tcl_DString ds;

		Tcl_DStringInit(&ds);
	    	Tcl_JoinPath(argc - 1, argv, &ds);
	    	Tcl_SetStringObj(resultPtr, Tcl_DStringValue(&ds),
			Tcl_DStringLength(&ds));
		Tcl_DStringFree(&ds);
	    } else if ((argc == 0)
		    || (Tcl_GetPathType(argv[0]) == TCL_PATH_RELATIVE)) {
		Tcl_SetStringObj(resultPtr,
			((tclPlatform == TCL_PLATFORM_MAC) ? ":" : "."), 1);
d890 3
a892 1
	    	Tcl_SetStringObj(resultPtr, argv[0], -1);
a893 2
	    ckfree((char *) argv);
	    return TCL_OK;
d915 1
a915 1
	    	Tcl_SetStringObj(resultPtr, extension, -1);
d921 1
a921 1
	    struct stat buf;
d927 1
a927 1
	    if (GetStatBuf(NULL, objv[2], TclStat, &buf) == TCL_OK) {
d930 1
a930 1
	    Tcl_SetBooleanObj(resultPtr, value);
d935 1
a935 1
	    struct stat buf;
d941 1
a941 1
	    if (GetStatBuf(NULL, objv[2], TclStat, &buf) == TCL_OK) {
d944 1
a944 1
	    Tcl_SetBooleanObj(resultPtr, value);
d948 1
a948 2
	    char **argv;
	    Tcl_DString ds;
d954 92
a1045 7
	    argv = StringifyObjects(objc - 2, objv + 2);
	    Tcl_DStringInit(&ds);
	    Tcl_JoinPath(objc - 2, argv, &ds);
	    Tcl_SetStringObj(resultPtr, Tcl_DStringValue(&ds),
		    Tcl_DStringLength(&ds));
	    Tcl_DStringFree(&ds);
	    ckfree((char *) argv);
d1050 1
a1050 1
	    struct stat buf;
d1056 1
a1056 1
	    if (GetStatBuf(interp, objv[2], TclpLstat, &buf) != TCL_OK) {
d1063 1
a1063 2
	    struct stat buf;
	    char *fileName;
d1070 1
a1070 1
	    if (GetStatBuf(interp, objv[2], TclStat, &buf) != TCL_OK) {
d1080 2
a1081 3
		fileName = Tcl_GetString(objv[2]);
		if (utime(fileName, &tval) != 0) {
		    Tcl_AppendStringsToObj(resultPtr,
d1083 1
a1083 1
			    fileName, "\": ",
d1093 1
a1093 1
		if (GetStatBuf(interp, objv[2], TclStat, &buf) != TCL_OK) {
d1097 1
a1097 1
	    Tcl_SetLongObj(resultPtr, (long) buf.st_mtime);
a1100 3
	    char **argv;
	    int result;

d1105 1
a1105 4
	    argv = StringifyObjects(objc, objv);
	    result = TclFileMakeDirsCmd(interp, objc, argv);
	    ckfree((char *) argv);
	    return result;
d1108 1
a1108 1
	    char *fileName;
d1119 2
a1120 1
	    Tcl_SetStringObj(resultPtr, fileName, Tcl_DStringLength(&ds));
d1124 12
d1138 1
a1138 1
	    struct stat buf;
d1144 1
a1144 1
	    if (GetStatBuf(NULL, objv[2], TclStat, &buf) == TCL_OK) {
d1156 1
a1156 1
	    Tcl_SetBooleanObj(resultPtr, value);
a1159 2
	    char *fileName;

d1163 1
a1163 2
	    fileName = Tcl_GetString(objv[2]);
	    switch (Tcl_GetPathType(fileName)) {
d1165 1
a1165 1
	    	    Tcl_SetStringObj(resultPtr, "absolute", -1);
d1168 1
a1168 1
	    	    Tcl_SetStringObj(resultPtr, "relative", -1);
d1171 2
a1172 1
		    Tcl_SetStringObj(resultPtr, "volumerelative", -1);
d1184 1
a1184 2
	    char *fileName, *contents;
	    Tcl_DString name, link;
d1190 1
a1190 3
	    fileName = Tcl_GetString(objv[2]);
	    fileName = Tcl_TranslateFileName(interp, fileName, &name);
	    if (fileName == NULL) {
d1194 1
a1194 14
	    /*
	     * If S_IFLNK isn't defined it means that the machine doesn't
	     * support symbolic links, so the file can't possibly be a
	     * symbolic link.  Generate an EINVAL error, which is what
	     * happens on machines that do support symbolic links when
	     * you invoke readlink on a file that isn't a symbolic link.
	     */

#ifndef S_IFLNK
	    contents = NULL;
	    errno = EINVAL;
#else
	    contents = TclpReadlink(fileName, &link);
#endif /* S_IFLNK */
a1195 1
	    Tcl_DStringFree(&name);
d1202 2
a1203 1
	    Tcl_DStringResult(interp, &link);
d1207 1
a1207 7
	    int result;
	    char **argv;

	    argv = StringifyObjects(objc, objv);
	    result = TclFileRenameCmd(interp, objc, argv);
	    ckfree((char *) argv);
	    return result;
d1221 1
a1221 1
	        Tcl_SetStringObj(resultPtr, fileName,
d1226 31
d1258 1
a1258 1
	    struct stat buf;
d1263 1
a1263 1
	    if (GetStatBuf(interp, objv[2], TclStat, &buf) != TCL_OK) {
d1266 2
a1267 1
	    Tcl_SetLongObj(resultPtr, (long) buf.st_size);
a1270 5
	    int i, argc;
	    char **argv;
	    char *fileName;
	    Tcl_Obj *objPtr;
	    
d1274 1
a1274 7
	    fileName = Tcl_GetString(objv[2]);
	    Tcl_SplitPath(fileName, &argc, &argv);
	    for (i = 0; i < argc; i++) {
		objPtr = Tcl_NewStringObj(argv[i], -1);
		Tcl_ListObjAppendElement(NULL, resultPtr, objPtr);
	    }
	    ckfree((char *) argv);
d1279 1
a1279 1
	    struct stat buf;
d1285 1
a1285 1
	    if (GetStatBuf(interp, objv[2], TclStat, &buf) != TCL_OK) {
d1291 15
d1307 2
a1308 2
	    int argc;
	    char **argv;
d1313 15
a1327 2
	    if (SplitPath(interp, objv[2], &argc, &argv) != TCL_OK) {
		return TCL_ERROR;
d1335 7
a1341 4
	    if (argc > 0) {
	    	if ((argc > 1)
		    	|| (Tcl_GetPathType(argv[0]) == TCL_PATH_RELATIVE)) {
		    Tcl_SetStringObj(resultPtr, argv[argc - 1], -1);
d1344 1
a1344 1
	    ckfree((char *) argv);
d1348 1
a1348 1
	    struct stat buf;
d1353 1
a1353 1
	    if (GetStatBuf(interp, objv[2], TclpLstat, &buf) != TCL_OK) {
d1356 1
a1356 1
	    Tcl_SetStringObj(resultPtr, 
d1365 2
a1366 1
	    return TclpListVolumes(interp);
a1383 57
 * SplitPath --
 *
 *	Utility procedure used by Tcl_FileObjCmd() to split a path.
 *	Differs from standard Tcl_SplitPath in its handling of home
 *	directories; Tcl_SplitPath preserves the "~" while this
 *	procedure computes the actual full path name.
 *
 * Results:
 *	The return value is TCL_OK if the path could be split, TCL_ERROR
 *	otherwise.  If TCL_ERROR was returned, an error message is left
 *	in interp.  If TCL_OK was returned, *argvPtr is set to a newly
 *	allocated array of strings that represent the individual
 *	directories in the specified path, and *argcPtr is filled with
 *	the length of that array.
 *
 * Side effects:
 *	Memory allocated.  The caller must eventually free this memory
 *	by calling ckfree() on *argvPtr.
 *
 *---------------------------------------------------------------------------
 */

static int
SplitPath(interp, objPtr, argcPtr, argvPtr)
    Tcl_Interp *interp;		/* Interp for error return.  May be NULL. */
    Tcl_Obj *objPtr;		/* Path to be split. */
    int *argcPtr;		/* Filled with length of following array. */
    char ***argvPtr;		/* Filled with array of strings representing
				 * the elements of the specified path. */
{
    char *fileName;

    fileName = Tcl_GetString(objPtr);

    /*
     * If there is only one element, and it starts with a tilde,
     * perform tilde substitution and resplit the path.
     */

    Tcl_SplitPath(fileName, argcPtr, argvPtr);
    if ((*argcPtr == 1) && (fileName[0] == '~')) {
	Tcl_DString ds;
	
	ckfree((char *) *argvPtr);
	fileName = Tcl_TranslateFileName(interp, fileName, &ds);
	if (fileName == NULL) {
	    return TCL_ERROR;
	}
	Tcl_SplitPath(fileName, argcPtr, argvPtr);
	Tcl_DStringFree(&ds);
    }
    return TCL_OK;
}

/*
 *---------------------------------------------------------------------------
 *
a1407 2
    char *fileName;
    Tcl_DString ds;
d1409 1
a1409 3
    fileName = Tcl_GetString(objPtr);
    fileName = Tcl_TranslateFileName(interp, fileName, &ds);
    if (fileName == NULL) {
d1412 1
a1412 2
	value = (TclAccess(fileName, mode) == 0);
        Tcl_DStringFree(&ds);
d1443 1
a1443 1
    StatProc *statProc;		/* Either stat() or lstat() depending on
d1445 1
a1445 1
    struct stat *statPtr;	/* Filled with info about file obtained by
a1447 2
    char *fileName;
    Tcl_DString ds;
d1450 1
a1450 3
    fileName = Tcl_GetString(objPtr);
    fileName = Tcl_TranslateFileName(interp, fileName, &ds);
    if (fileName == NULL) {
d1454 1
a1454 2
    status = (*statProc)(Tcl_DStringValue(&ds), statPtr);
    Tcl_DStringFree(&ds);
d1491 1
a1491 1
    struct stat *statPtr;		/* Pointer to buffer containing
d1494 4
a1497 1
    char string[TCL_INTEGER_SPACE];
d1499 11
a1509 54
    TclFormatInt(string, (long) statPtr->st_dev);
    if (Tcl_SetVar2(interp, varName, "dev", string, TCL_LEAVE_ERR_MSG)
	    == NULL) {
	return TCL_ERROR;
    }
    TclFormatInt(string, (long) statPtr->st_ino);
    if (Tcl_SetVar2(interp, varName, "ino", string, TCL_LEAVE_ERR_MSG)
	    == NULL) {
	return TCL_ERROR;
    }
    TclFormatInt(string, (unsigned short) statPtr->st_mode);
    if (Tcl_SetVar2(interp, varName, "mode", string, TCL_LEAVE_ERR_MSG)
	    == NULL) {
	return TCL_ERROR;
    }
    TclFormatInt(string, (long) statPtr->st_nlink);
    if (Tcl_SetVar2(interp, varName, "nlink", string, TCL_LEAVE_ERR_MSG)
	    == NULL) {
	return TCL_ERROR;
    }
    TclFormatInt(string, (long) statPtr->st_uid);
    if (Tcl_SetVar2(interp, varName, "uid", string, TCL_LEAVE_ERR_MSG)
	    == NULL) {
	return TCL_ERROR;
    }
    TclFormatInt(string, (long) statPtr->st_gid);
    if (Tcl_SetVar2(interp, varName, "gid", string, TCL_LEAVE_ERR_MSG)
	    == NULL) {
	return TCL_ERROR;
    }
    sprintf(string, "%lu", (unsigned long) statPtr->st_size);
    if (Tcl_SetVar2(interp, varName, "size", string, TCL_LEAVE_ERR_MSG)
	    == NULL) {
	return TCL_ERROR;
    }
    TclFormatInt(string, (long) statPtr->st_atime);
    if (Tcl_SetVar2(interp, varName, "atime", string, TCL_LEAVE_ERR_MSG)
	    == NULL) {
	return TCL_ERROR;
    }
    TclFormatInt(string, (long) statPtr->st_mtime);
    if (Tcl_SetVar2(interp, varName, "mtime", string, TCL_LEAVE_ERR_MSG)
	    == NULL) {
	return TCL_ERROR;
    }
    TclFormatInt(string, (long) statPtr->st_ctime);
    if (Tcl_SetVar2(interp, varName, "ctime", string, TCL_LEAVE_ERR_MSG)
	    == NULL) {
	return TCL_ERROR;
    }
    if (Tcl_SetVar2(interp, varName, "type",
	    GetTypeFromMode((unsigned short) statPtr->st_mode), 
	    TCL_LEAVE_ERR_MSG) == NULL) {
	return TCL_ERROR;
d1511 26
d1715 11
a1725 11
    int indexArray[STATIC_LIST_SIZE];	  /* Array of value list indices */
    int varcListArray[STATIC_LIST_SIZE];  /* # loop variables per list */
    Tcl_Obj **varvListArray[STATIC_LIST_SIZE]; /* Array of var name lists */
    int argcListArray[STATIC_LIST_SIZE];  /* Array of value list sizes */
    Tcl_Obj **argvListArray[STATIC_LIST_SIZE]; /* Array of value lists */

    int *index = indexArray;
    int *varcList = varcListArray;
    Tcl_Obj ***varvList = varvListArray;
    int *argcList = argcListArray;
    Tcl_Obj ***argvList = argvListArray;
d1811 6
a1816 3
	     * If a variable or value list object has been converted to
	     * another kind of Tcl object, convert it back to a list object
	     * and refetch the pointer to its element array.
d1819 9
a1827 13
	    if (argObjv[1+i*2]->typePtr != &tclListType) {
		result = Tcl_ListObjGetElements(interp, argObjv[1+i*2],
		        &varcList[i], &varvList[i]);
		if (result != TCL_OK) {
		    panic("Tcl_ForeachObjCmd: could not reconvert variable list %d to a list object\n", i);
		}
	    }
	    if (argObjv[2+i*2]->typePtr != &tclListType) {
		result = Tcl_ListObjGetElements(interp, argObjv[2+i*2],
	                &argcList[i], &argvList[i]);
		if (result != TCL_OK) {
		    panic("Tcl_ForeachObjCmd: could not reconvert value list %d to a list object\n", i);
		}
d1924 1
a1924 1
    int formatLen;              /* The length of the format string */
d1926 1
a1926 1
    char newFormat[40];		/* A new format specifier is generated here. */
d1934 1
a1934 1
    int intValue;		/* Used to hold value to pass to sprintf, if
d1940 4
d1953 1
d1955 1
a1955 1
    
d1982 3
d1994 2
a1995 1
     *    because some of the arguments may be two-word values (doubles).
d2005 1
a2005 1
    format = (char *) Tcl_GetStringFromObj(objv[1], &formatLen);
d2015 3
d2097 1
a2097 1
	if (isdigit(UCHAR(*format))) { /* INTL: Tcl source. */
d2140 1
a2140 1
	if (isdigit(UCHAR(*format))) { /* INTL: Tcl source. */
d2161 5
d2187 12
a2198 1
		if (Tcl_GetIntFromObj(interp,	/* INTL: Tcl source. */
d2202 11
d2236 1
a2236 1
		if (Tcl_GetIntFromObj(interp,	/* INTL: Tcl source. */
d2297 6
a2392 40
}

/*
 *---------------------------------------------------------------------------
 *
 * StringifyObjects --
 *
 *	Helper function to bridge the gap between an object-based procedure
 *	and an older string-based procedure.
 * 
 *	Given an array of objects, allocate an array that consists of the
 *	string representations of those objects.
 *
 * Results:
 *	The return value is a pointer to the newly allocated array of
 *	strings.  Elements 0 to (objc-1) of the string array point to the
 *	string representation of the corresponding element in the source
 *	object array; element objc of the string array is NULL.
 *
 * Side effects:
 *	Memory allocated.  The caller must eventually free this memory
 *	by calling ckfree() on the return value.
 *
 *---------------------------------------------------------------------------
 */

static char **
StringifyObjects(objc, objv)
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    int i;
    char **argv;
    
    argv = (char **) ckalloc((objc + 1) * sizeof(char *));
    for (i = 0; i < objc; i++) {
    	argv[i] = Tcl_GetString(objv[i]);
    }
    argv[i] = NULL;
    return argv;
@


1.3
log
@touched all sources to ease next import
@
text
@@


1.3.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d14 1
a14 1
 * RCS: @@(#) $Id: tclCmdAH.c,v 1.27 2002/07/02 12:16:05 vincentdarley Exp $
d21 2
d30 2
a31 2
			    Tcl_Obj *objPtr, Tcl_FSStatProc *statProc,
			    Tcl_StatBuf *statPtr));
d33 2
d36 3
a38 1
			    char *varName, Tcl_StatBuf *statPtr));
d102 1
a102 1
    int body, result, caseObjc;
d104 1
d140 1
a140 1
	CONST char **patObjv;
d310 2
a311 1
    Tcl_Obj *dir;
d320 1
a320 1
	dir = objv[1];
d322 1
a322 2
	dir = Tcl_NewStringObj("~",1);
	Tcl_IncrRefCount(dir);
d324 2
a325 9
    if (Tcl_FSConvertToPathType(interp, dir) != TCL_OK) {
	result = TCL_ERROR;
    } else {
	result = Tcl_FSChdir(dir);
	if (result != TCL_OK) {
	    Tcl_AppendResult(interp, "couldn't change working directory to \"",
		    Tcl_GetString(dir), "\": ", Tcl_PosixError(interp), (char *) NULL);
	    result = TCL_ERROR;
	}
d327 8
a334 2
    if (objc != 2) {
	Tcl_DecrRefCount(dir);
d336 1
a336 1
    return result;
d435 1
a435 1
    static CONST char *optionStrings[] = {
d520 1
a520 2
		Tcl_SetStringObj(Tcl_GetObjResult(interp),
			Tcl_GetEncodingName(NULL), -1);
a731 1
    /*** QUESTION: Do we need to copy the slow way? ***/
d768 1
a768 3
 *      With the object-based Tcl_FS APIs, the above NOTE may no
 *      longer be true.  In any case this assertion should be tested.
 *      
d786 1
d793 1
a793 1
    static CONST char *fileOptions[] = {
d797 2
a798 3
	"isdirectory",	"isfile",	"join",		"link",
	"lstat",        "mtime",	"mkdir",	"nativename",	
	"normalize",    "owned",
d800 1
a800 2
	"rootname",	"separator",    "size",		"split",	
	"stat",         "system", 
d808 2
a809 3
	FILE_ISDIRECTORY, FILE_ISFILE,	FILE_JOIN,	FILE_LINK, 
	FILE_LSTAT,     FILE_MTIME,	FILE_MKDIR,	FILE_NATIVENAME, 
	FILE_NORMALIZE, FILE_OWNED,
d811 1
a811 2
	FILE_ROOTNAME,	FILE_SEPARATOR, FILE_SIZE,	FILE_SPLIT,	
	FILE_STAT,      FILE_SYSTEM, 
d824 1
d827 2
a828 1
	    Tcl_StatBuf buf;
d835 1
a835 1
	    if (GetStatBuf(interp, objv[2], Tcl_FSStat, &buf) != TCL_OK) {
d845 3
a847 2
		if (Tcl_FSUtime(objv[2], &tval) != 0) {
		    Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
d849 1
a849 1
			    Tcl_GetString(objv[2]), "\": ",
d859 1
a859 1
		if (GetStatBuf(interp, objv[2], Tcl_FSStat, &buf) != TCL_OK) {
d863 1
a863 1
	    Tcl_SetLongObj(Tcl_GetObjResult(interp), (long) buf.st_atime);
d878 7
a884 1
	    return TclFileCopyCmd(interp, objc, objv);
d887 7
a893 1
	    return TclFileDeleteCmd(interp, objc, objv);
d896 3
a898 1
	    Tcl_Obj *dirPtr;
d902 22
a923 3
	    dirPtr = TclFileDirname(interp, objv[2]);
	    if (dirPtr == NULL) {
	        return TCL_ERROR;
d925 1
a925 3
		Tcl_SetObjResult(interp, dirPtr);
		Tcl_DecrRefCount(dirPtr);
		return TCL_OK;
d927 2
d950 1
a950 1
	    	Tcl_SetStringObj(Tcl_GetObjResult(interp), extension, -1);
d956 1
a956 1
	    Tcl_StatBuf buf;
d962 1
a962 1
	    if (GetStatBuf(NULL, objv[2], Tcl_FSStat, &buf) == TCL_OK) {
d965 1
a965 1
	    Tcl_SetBooleanObj(Tcl_GetObjResult(interp), value);
d970 1
a970 1
	    Tcl_StatBuf buf;
d976 1
a976 1
	    if (GetStatBuf(NULL, objv[2], Tcl_FSStat, &buf) == TCL_OK) {
d979 1
a979 1
	    Tcl_SetBooleanObj(Tcl_GetObjResult(interp), value);
d983 2
a984 1
	    Tcl_Obj *resObj;
d990 7
a996 92
	    resObj = Tcl_FSJoinToPath(NULL, objc - 2, objv + 2);
	    Tcl_SetObjResult(interp, resObj);
	    return TCL_OK;
	}
	case FILE_LINK: {
	    Tcl_Obj *contents;
	    int index;
	    
	    if (objc < 3 || objc > 5) {
		Tcl_WrongNumArgs(interp, 2, objv, 
				 "?-linktype? linkname ?target?");
		return TCL_ERROR;
	    }
	    
	    /* Index of the 'source' argument */
	    if (objc == 5) {
		index = 3;
	    } else {
		index = 2;
	    }
	    
	    if (objc > 3) {
		int linkAction;
		if (objc == 5) {
		    /* We have a '-linktype' argument */
		    static CONST char *linkTypes[] = {
			"-symbolic", "-hard", NULL
		    };
		    if (Tcl_GetIndexFromObj(interp, objv[2], linkTypes, 
				     "switch", 0, &linkAction) != TCL_OK) {
			return TCL_ERROR;
		    }
		    if (linkAction == 0) {
		        linkAction = TCL_CREATE_SYMBOLIC_LINK;
		    } else {
			linkAction = TCL_CREATE_HARD_LINK;
		    }
		} else {
		    linkAction = TCL_CREATE_SYMBOLIC_LINK|TCL_CREATE_HARD_LINK;
		}
		if (Tcl_FSConvertToPathType(interp, objv[index]) != TCL_OK) {
		    return TCL_ERROR;
		}
		/* Create link from source to target */
		contents = Tcl_FSLink(objv[index], objv[index+1], linkAction);
		if (contents == NULL) {
		    /* 
		     * We handle two common error cases specially, and
		     * for all other errors, we use the standard posix
		     * error message.
		     */
		    if (errno == EEXIST) {
			Tcl_AppendResult(interp, "could not create new link \"", 
				Tcl_GetString(objv[index]), 
				"\": that path already exists", (char *) NULL);
		    } else if (errno == ENOENT) {
			Tcl_AppendResult(interp, "could not create new link \"", 
				Tcl_GetString(objv[index]), 
				"\" since target \"", 
				Tcl_GetString(objv[index+1]), 
				"\" doesn't exist", 
				(char *) NULL);
		    } else {
			Tcl_AppendResult(interp, "could not create new link \"", 
				Tcl_GetString(objv[index]), "\" pointing to \"", 
				Tcl_GetString(objv[index+1]), "\": ", 
				Tcl_PosixError(interp), (char *) NULL);
		    }
		    return TCL_ERROR;
		}
	    } else {
		if (Tcl_FSConvertToPathType(interp, objv[index]) != TCL_OK) {
		    return TCL_ERROR;
		}
		/* Read link */
		contents = Tcl_FSLink(objv[index], NULL, 0);
		if (contents == NULL) {
		    Tcl_AppendResult(interp, "could not read link \"", 
			    Tcl_GetString(objv[index]), "\": ", 
			    Tcl_PosixError(interp), (char *) NULL);
		    return TCL_ERROR;
		}
	    }
	    Tcl_SetObjResult(interp, contents);
	    if (objc == 3) {
		/* 
		 * If we are reading a link, we need to free this
		 * result refCount.  If we are creating a link, this
		 * will just be objv[index+1], and so we don't own it.
		 */
		Tcl_DecrRefCount(contents);
	    }
d1001 1
a1001 1
	    Tcl_StatBuf buf;
d1007 1
a1007 1
	    if (GetStatBuf(interp, objv[2], Tcl_FSLstat, &buf) != TCL_OK) {
d1014 2
a1015 1
	    Tcl_StatBuf buf;
d1022 1
a1022 1
	    if (GetStatBuf(interp, objv[2], Tcl_FSStat, &buf) != TCL_OK) {
d1032 3
a1034 2
		if (Tcl_FSUtime(objv[2], &tval) != 0) {
		    Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
d1036 1
a1036 1
			    Tcl_GetString(objv[2]), "\": ",
d1046 1
a1046 1
		if (GetStatBuf(interp, objv[2], Tcl_FSStat, &buf) != TCL_OK) {
d1050 1
a1050 1
	    Tcl_SetLongObj(Tcl_GetObjResult(interp), (long) buf.st_mtime);
d1054 3
d1061 4
a1064 1
	    return TclFileMakeDirsCmd(interp, objc, objv);
d1067 1
a1067 1
	    CONST char *fileName;
d1078 1
a1078 2
	    Tcl_SetStringObj(Tcl_GetObjResult(interp), fileName, 
			     Tcl_DStringLength(&ds));
a1081 12
	case FILE_NORMALIZE: {
	    Tcl_Obj *fileName;

	    if (objc != 3) {
		Tcl_WrongNumArgs(interp, 2, objv, "filename");
		return TCL_ERROR;
	    }

	    fileName = Tcl_FSGetNormalizedPath(interp, objv[2]);
	    Tcl_SetObjResult(interp, fileName);
	    return TCL_OK;
	}
d1084 1
a1084 1
	    Tcl_StatBuf buf;
d1090 1
a1090 1
	    if (GetStatBuf(NULL, objv[2], Tcl_FSStat, &buf) == TCL_OK) {
d1102 1
a1102 1
	    Tcl_SetBooleanObj(Tcl_GetObjResult(interp), value);
d1106 2
d1111 2
a1112 1
	    switch (Tcl_FSGetPathType(objv[2])) {
d1114 1
a1114 1
	    	    Tcl_SetStringObj(Tcl_GetObjResult(interp), "absolute", -1);
d1117 1
a1117 1
	    	    Tcl_SetStringObj(Tcl_GetObjResult(interp), "relative", -1);
d1120 1
a1120 2
		    Tcl_SetStringObj(Tcl_GetObjResult(interp), 
				     "volumerelative", -1);
d1132 2
a1133 1
	    Tcl_Obj *contents;
d1139 3
a1141 1
	    if (Tcl_FSConvertToPathType(interp, objv[2]) != TCL_OK) {
d1145 14
a1158 1
	    contents = Tcl_FSLink(objv[2], NULL, 0);
d1160 1
d1167 1
a1167 2
	    Tcl_SetObjResult(interp, contents);
	    Tcl_DecrRefCount(contents);
d1171 7
a1177 1
	    return TclFileRenameCmd(interp, objc, objv);
d1191 1
a1191 1
	        Tcl_SetStringObj(Tcl_GetObjResult(interp), fileName,
a1195 31
	case FILE_SEPARATOR: {
	    if ((objc < 2) || (objc > 3)) {
		Tcl_WrongNumArgs(interp, 2, objv, "?name?");
		return TCL_ERROR;
	    }
	    if (objc == 2) {
	        char *separator = NULL; /* lint */
		switch (tclPlatform) {
		    case TCL_PLATFORM_UNIX:
			separator = "/";
			break;
		    case TCL_PLATFORM_WINDOWS:
			separator = "\\";
			break;
		    case TCL_PLATFORM_MAC:
			separator = ":";
			break;
		}
		Tcl_SetObjResult(interp, Tcl_NewStringObj(separator,1));
	    } else {
		Tcl_Obj *separatorObj = Tcl_FSPathSeparator(objv[2]);
		if (separatorObj != NULL) {
		    Tcl_SetObjResult(interp, separatorObj);
		} else {
		    Tcl_SetObjResult(interp, 
			    Tcl_NewStringObj("Unrecognised path",-1));
		    return TCL_ERROR;
		}
	    }
	    return TCL_OK;
	}
d1197 1
a1197 1
	    Tcl_StatBuf buf;
d1202 1
a1202 1
	    if (GetStatBuf(interp, objv[2], Tcl_FSStat, &buf) != TCL_OK) {
d1205 1
a1205 2
	    Tcl_SetWideIntObj(Tcl_GetObjResult(interp),
		    (Tcl_WideInt) buf.st_size);
d1209 5
d1217 7
a1223 1
	    Tcl_SetObjResult(interp, Tcl_FSSplitPath(objv[2], NULL));
d1228 1
a1228 1
	    Tcl_StatBuf buf;
d1234 1
a1234 1
	    if (GetStatBuf(interp, objv[2], Tcl_FSStat, &buf) != TCL_OK) {
a1239 15
	case FILE_SYSTEM: {
	    Tcl_Obj* fsInfo;
	    if (objc != 3) {
		goto only3Args;
	    }
	    fsInfo = Tcl_FSFileSystemInfo(objv[2]);
	    if (fsInfo != NULL) {
		Tcl_SetObjResult(interp, fsInfo);
		return TCL_OK;
	    } else {
		Tcl_SetObjResult(interp, 
				 Tcl_NewStringObj("Unrecognised path",-1));
		return TCL_ERROR;
	    }
	}
d1241 2
a1242 2
	    int splitElements;
	    Tcl_Obj *splitPtr;
d1247 2
a1248 15
	    /* 
	     * The behaviour we want here is slightly different to
	     * the standard Tcl_FSSplitPath in the handling of home
	     * directories; Tcl_FSSplitPath preserves the "~" while 
	     * this code computes the actual full path name, if we
	     * had just a single component.
	     */	    
	    splitPtr = Tcl_FSSplitPath(objv[2], &splitElements);
	    if ((splitElements == 1) && (Tcl_GetString(objv[2])[0] == '~')) {
		Tcl_DecrRefCount(splitPtr);
		splitPtr = Tcl_FSGetNormalizedPath(interp, objv[2]);
		if (splitPtr == NULL) {
		    return TCL_ERROR;
		}
		splitPtr = Tcl_FSSplitPath(splitPtr, &splitElements);
d1256 4
a1259 7
	    if (splitElements > 0) {
	    	if ((splitElements > 1)
		  || (Tcl_FSGetPathType(objv[2]) == TCL_PATH_RELATIVE)) {
		    
		    Tcl_Obj *tail = NULL;
		    Tcl_ListObjIndex(NULL, splitPtr, splitElements-1, &tail);
		    Tcl_SetObjResult(interp, tail);
d1262 1
a1262 1
	    Tcl_DecrRefCount(splitPtr);
d1266 1
a1266 1
	    Tcl_StatBuf buf;
d1271 1
a1271 1
	    if (GetStatBuf(interp, objv[2], Tcl_FSLstat, &buf) != TCL_OK) {
d1274 1
a1274 1
	    Tcl_SetStringObj(Tcl_GetObjResult(interp), 
d1283 1
a1283 2
	    Tcl_SetObjResult(interp, Tcl_FSListVolumes());
	    return TCL_OK;
d1301 57
d1382 2
d1385 3
a1387 1
    if (Tcl_FSConvertToPathType(interp, objPtr) != TCL_OK) {
d1390 2
a1391 1
	value = (Tcl_FSAccess(objPtr, mode) == 0);
d1422 1
a1422 1
    Tcl_FSStatProc *statProc;	/* Either stat() or lstat() depending on
d1424 1
a1424 1
    Tcl_StatBuf *statPtr;	/* Filled with info about file obtained by
d1427 2
d1431 3
a1433 1
    if (Tcl_FSConvertToPathType(interp, objPtr) != TCL_OK) {
d1437 2
a1438 1
    status = (*statProc)(objPtr, statPtr);
d1475 1
a1475 1
    Tcl_StatBuf *statPtr;		/* Pointer to buffer containing
d1478 1
a1478 4
    Tcl_Obj *var = Tcl_NewStringObj(varName, -1);
    Tcl_Obj *field = Tcl_NewObj();
    Tcl_Obj *value;
    register unsigned short mode;
d1480 54
a1533 11
    /*
     * Assume Tcl_ObjSetVar2() does not keep a copy of the field name!
     */
#define STORE_ARY(fieldName, object) \
    Tcl_SetStringObj(field, (fieldName), -1); \
    value = (object); \
    if (Tcl_ObjSetVar2(interp,var,field,value,TCL_LEAVE_ERR_MSG) == NULL) { \
	Tcl_DecrRefCount(var); \
	Tcl_DecrRefCount(field); \
	Tcl_DecrRefCount(value); \
	return TCL_ERROR; \
a1534 26

    Tcl_IncrRefCount(var);
    Tcl_IncrRefCount(field);
    STORE_ARY("dev",   Tcl_NewLongObj((long)statPtr->st_dev));
    /*
     * Watch out porters; the inode is meant to be an *unsigned* value,
     * so the cast might fail when there isn't a real arithmentic 'long
     * long' type...
     */
    STORE_ARY("ino",   Tcl_NewWideIntObj((Tcl_WideInt)statPtr->st_ino));
    STORE_ARY("nlink", Tcl_NewLongObj((long)statPtr->st_nlink));
    STORE_ARY("uid",   Tcl_NewLongObj((long)statPtr->st_uid));
    STORE_ARY("gid",   Tcl_NewLongObj((long)statPtr->st_gid));
    STORE_ARY("size",  Tcl_NewWideIntObj((Tcl_WideInt)statPtr->st_size));
#ifdef HAVE_ST_BLOCKS
    STORE_ARY("blocks",Tcl_NewWideIntObj((Tcl_WideInt)statPtr->st_blocks));
#endif
    STORE_ARY("atime", Tcl_NewLongObj((long)statPtr->st_atime));
    STORE_ARY("mtime", Tcl_NewLongObj((long)statPtr->st_mtime));
    STORE_ARY("ctime", Tcl_NewLongObj((long)statPtr->st_ctime));
    mode = (unsigned short) statPtr->st_mode;
    STORE_ARY("mode",  Tcl_NewIntObj(mode));
    STORE_ARY("type",  Tcl_NewStringObj(GetTypeFromMode(mode), -1));
#undef STORE_ARY
    Tcl_DecrRefCount(var);
    Tcl_DecrRefCount(field);
d1713 11
a1723 11
    int indexArray[STATIC_LIST_SIZE];
    int varcListArray[STATIC_LIST_SIZE];
    Tcl_Obj **varvListArray[STATIC_LIST_SIZE];
    int argcListArray[STATIC_LIST_SIZE];
    Tcl_Obj **argvListArray[STATIC_LIST_SIZE];

    int *index = indexArray;		   /* Array of value list indices */
    int *varcList = varcListArray;	   /* # loop variables per list */
    Tcl_Obj ***varvList = varvListArray;   /* Array of var name lists */
    int *argcList = argcListArray;	   /* Array of value list sizes */
    Tcl_Obj ***argvList = argvListArray;   /* Array of value lists */
d1809 3
a1811 6
	     * Refetch the list members; we assume that the sizes are
	     * the same, but the array of elements might be different
	     * if the internal rep of the objects has been lost and
	     * recreated (it is too difficult to accurately tell when
	     * this happens, which can lead to some wierd crashes,
	     * like Bug #494348...)
d1814 13
a1826 9
	    result = Tcl_ListObjGetElements(interp, argObjv[1+i*2],
		    &varcList[i], &varvList[i]);
	    if (result != TCL_OK) {
		panic("Tcl_ForeachObjCmd: could not reconvert variable list %d to a list object\n", i);
	    }
	    result = Tcl_ListObjGetElements(interp, argObjv[2+i*2],
		    &argcList[i], &argvList[i]);
	    if (result != TCL_OK) {
		panic("Tcl_ForeachObjCmd: could not reconvert value list %d to a list object\n", i);
d1923 1
a1923 1
    int formatLen;		/* The length of the format string */
d1925 1
a1925 1
    char newFormat[43];		/* A new format specifier is generated here. */
d1933 1
a1933 1
    long intValue;		/* Used to hold value to pass to sprintf, if
a1938 4
#ifndef TCL_WIDE_INT_IS_LONG
    Tcl_WideInt wideValue;	/* Used to hold value to pass to sprintf if
				 * it's a 'long long' value. */
#endif /* TCL_WIDE_INT_IS_LONG */
a1947 1
#   define WIDE_VALUE 5
d1949 1
a1949 1

a1975 3
#ifndef TCL_WIDE_INT_IS_LONG
    int useWide;		/* Value to be printed is Tcl_WideInt. */
#endif /* TCL_WIDE_INT_IS_LONG */
d1985 1
a1985 2
     *    because some of the arguments may be two-word values (doubles
     *    and wide-ints).
d1995 1
a1995 1
    format = Tcl_GetStringFromObj(objv[1], &formatLen);
a2004 3
#ifndef TCL_WIDE_INT_IS_LONG
	useWide = 0;
#endif /* TCL_WIDE_INT_IS_LONG */
d2084 1
a2084 1
	if (isdigit(UCHAR(*format))) {		/* INTL: Tcl source. */
d2127 1
a2127 1
	if (isdigit(UCHAR(*format))) {		/* INTL: Tcl source. */
a2147 5
#ifndef TCL_WIDE_INT_IS_LONG
	    useWide = 1;
	    strcpy(newPtr, TCL_LL_MODIFIER);
	    newPtr += TCL_LL_MODIFIER_SIZE;
#endif /* TCL_WIDE_INT_IS_LONG */
d2169 1
a2169 12
#ifndef TCL_WIDE_INT_IS_LONG
		if (useWide) {
		    if (Tcl_GetWideIntFromObj(interp, /* INTL: Tcl source. */
			    objv[objIndex], &wideValue) != TCL_OK) {
			goto fmtError;
		    }
		    whichValue = WIDE_VALUE;
		    size = 40 + precision;
		    break;
		}
#endif /* TCL_WIDE_INT_IS_LONG */
		if (Tcl_GetLongFromObj(interp,	      /* INTL: Tcl source. */
a2172 11
#if (LONG_MAX > INT_MAX)
		/*
		 * Add the 'l' for long format type because we are on
		 * an LP64 archtecture and we are really going to pass
		 * a long argument to sprintf.
		 */
		newPtr++;
		*newPtr = 0;
		newPtr[-1] = newPtr[-2];
		newPtr[-2] = 'l';
#endif /* LONG_MAX > INT_MAX */
d2196 1
a2196 1
		if (Tcl_GetLongFromObj(interp,	/* INTL: Tcl source. */
a2256 6
#ifndef TCL_WIDE_INT_IS_LONG
		case WIDE_VALUE: {
		    sprintf(dst, newFormat, wideValue);
		    break;
		}
#endif /* TCL_WIDE_INT_IS_LONG */
d2347 40
@


1.3.4.2
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d804 10
a813 10
	FCMD_ATIME,	FCMD_ATTRIBUTES, FCMD_CHANNELS,	FCMD_COPY,
	FCMD_DELETE,
	FCMD_DIRNAME,	FCMD_EXECUTABLE, FCMD_EXISTS,	FCMD_EXTENSION,
	FCMD_ISDIRECTORY, FCMD_ISFILE,	FCMD_JOIN,	FCMD_LINK, 
	FCMD_LSTAT,     FCMD_MTIME,	FCMD_MKDIR,	FCMD_NATIVENAME, 
	FCMD_NORMALIZE, FCMD_OWNED,
	FCMD_PATHTYPE,	FCMD_READABLE,	FCMD_READLINK,	FCMD_RENAME,
	FCMD_ROOTNAME,	FCMD_SEPARATOR, FCMD_SIZE,	FCMD_SPLIT,	
	FCMD_STAT,      FCMD_SYSTEM, 
	FCMD_TAIL,	FCMD_TYPE,	FCMD_VOLUMES,	FCMD_WRITABLE
d826 1
a826 1
    	case FCMD_ATIME: {
d864 1
a864 1
	case FCMD_ATTRIBUTES: {
d867 1
a867 1
	case FCMD_CHANNELS: {
d875 1
a875 1
	case FCMD_COPY: {
d878 1
a878 1
	case FCMD_DELETE: {
d881 1
a881 1
    	case FCMD_DIRNAME: {
d895 1
a895 1
	case FCMD_EXECUTABLE: {
d901 1
a901 1
	case FCMD_EXISTS: {
d907 1
a907 1
	case FCMD_EXTENSION: {
d919 1
a919 1
    	case FCMD_ISDIRECTORY: {
d933 1
a933 1
    	case FCMD_ISFILE: {
d947 1
a947 1
	case FCMD_JOIN: {
d958 1
a958 1
	case FCMD_LINK: {
d1048 1
a1048 1
    	case FCMD_LSTAT: {
d1062 1
a1062 1
	case FCMD_MTIME: {
d1100 1
a1100 1
	case FCMD_MKDIR: {
d1107 1
a1107 1
	case FCMD_NATIVENAME: {
d1124 1
a1124 1
	case FCMD_NORMALIZE: {
d1136 1
a1136 1
	case FCMD_OWNED: {
d1159 1
a1159 1
	case FCMD_PATHTYPE: {
d1177 1
a1177 1
    	case FCMD_READABLE: {
d1183 1
a1183 1
	case FCMD_READLINK: {
d1206 1
a1206 1
	case FCMD_RENAME: {
d1209 1
a1209 1
	case FCMD_ROOTNAME: {
d1226 1
a1226 1
	case FCMD_SEPARATOR: {
d1257 1
a1257 1
	case FCMD_SIZE: {
d1270 1
a1270 1
	case FCMD_SPLIT: {
d1277 1
a1277 1
	case FCMD_STAT: {
d1291 1
a1291 1
	case FCMD_SYSTEM: {
d1306 1
a1306 1
    	case FCMD_TAIL: {
d1347 1
a1347 1
	case FCMD_TYPE: {
d1360 1
a1360 1
	case FCMD_VOLUMES: {
d1368 1
a1368 1
	case FCMD_WRITABLE: {
@


1.3.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@d14 1
a14 1
 * RCS: @@(#) $Id: tclCmdAH.c,v 1.27 2002/07/02 12:16:05 vincentdarley Exp $
d21 2
d30 2
a31 2
			    Tcl_Obj *objPtr, Tcl_FSStatProc *statProc,
			    Tcl_StatBuf *statPtr));
d33 2
d36 3
a38 1
			    char *varName, Tcl_StatBuf *statPtr));
d102 1
a102 1
    int body, result, caseObjc;
d104 1
d140 1
a140 1
	CONST char **patObjv;
d310 2
a311 1
    Tcl_Obj *dir;
d320 1
a320 1
	dir = objv[1];
d322 1
a322 2
	dir = Tcl_NewStringObj("~",1);
	Tcl_IncrRefCount(dir);
d324 2
a325 9
    if (Tcl_FSConvertToPathType(interp, dir) != TCL_OK) {
	result = TCL_ERROR;
    } else {
	result = Tcl_FSChdir(dir);
	if (result != TCL_OK) {
	    Tcl_AppendResult(interp, "couldn't change working directory to \"",
		    Tcl_GetString(dir), "\": ", Tcl_PosixError(interp), (char *) NULL);
	    result = TCL_ERROR;
	}
d327 8
a334 2
    if (objc != 2) {
	Tcl_DecrRefCount(dir);
d336 1
a336 1
    return result;
d435 1
a435 1
    static CONST char *optionStrings[] = {
d520 1
a520 2
		Tcl_SetStringObj(Tcl_GetObjResult(interp),
			Tcl_GetEncodingName(NULL), -1);
a731 1
    /*** QUESTION: Do we need to copy the slow way? ***/
d768 1
a768 3
 *      With the object-based Tcl_FS APIs, the above NOTE may no
 *      longer be true.  In any case this assertion should be tested.
 *      
d786 1
d793 1
a793 1
    static CONST char *fileOptions[] = {
d797 2
a798 3
	"isdirectory",	"isfile",	"join",		"link",
	"lstat",        "mtime",	"mkdir",	"nativename",	
	"normalize",    "owned",
d800 1
a800 2
	"rootname",	"separator",    "size",		"split",	
	"stat",         "system", 
d808 2
a809 3
	FILE_ISDIRECTORY, FILE_ISFILE,	FILE_JOIN,	FILE_LINK, 
	FILE_LSTAT,     FILE_MTIME,	FILE_MKDIR,	FILE_NATIVENAME, 
	FILE_NORMALIZE, FILE_OWNED,
d811 1
a811 2
	FILE_ROOTNAME,	FILE_SEPARATOR, FILE_SIZE,	FILE_SPLIT,	
	FILE_STAT,      FILE_SYSTEM, 
d824 1
d827 2
a828 1
	    Tcl_StatBuf buf;
d835 1
a835 1
	    if (GetStatBuf(interp, objv[2], Tcl_FSStat, &buf) != TCL_OK) {
d845 3
a847 2
		if (Tcl_FSUtime(objv[2], &tval) != 0) {
		    Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
d849 1
a849 1
			    Tcl_GetString(objv[2]), "\": ",
d859 1
a859 1
		if (GetStatBuf(interp, objv[2], Tcl_FSStat, &buf) != TCL_OK) {
d863 1
a863 1
	    Tcl_SetLongObj(Tcl_GetObjResult(interp), (long) buf.st_atime);
d878 7
a884 1
	    return TclFileCopyCmd(interp, objc, objv);
d887 7
a893 1
	    return TclFileDeleteCmd(interp, objc, objv);
d896 3
a898 1
	    Tcl_Obj *dirPtr;
d902 22
a923 3
	    dirPtr = TclFileDirname(interp, objv[2]);
	    if (dirPtr == NULL) {
	        return TCL_ERROR;
d925 1
a925 3
		Tcl_SetObjResult(interp, dirPtr);
		Tcl_DecrRefCount(dirPtr);
		return TCL_OK;
d927 2
d950 1
a950 1
	    	Tcl_SetStringObj(Tcl_GetObjResult(interp), extension, -1);
d956 1
a956 1
	    Tcl_StatBuf buf;
d962 1
a962 1
	    if (GetStatBuf(NULL, objv[2], Tcl_FSStat, &buf) == TCL_OK) {
d965 1
a965 1
	    Tcl_SetBooleanObj(Tcl_GetObjResult(interp), value);
d970 1
a970 1
	    Tcl_StatBuf buf;
d976 1
a976 1
	    if (GetStatBuf(NULL, objv[2], Tcl_FSStat, &buf) == TCL_OK) {
d979 1
a979 1
	    Tcl_SetBooleanObj(Tcl_GetObjResult(interp), value);
d983 2
a984 1
	    Tcl_Obj *resObj;
d990 7
a996 92
	    resObj = Tcl_FSJoinToPath(NULL, objc - 2, objv + 2);
	    Tcl_SetObjResult(interp, resObj);
	    return TCL_OK;
	}
	case FILE_LINK: {
	    Tcl_Obj *contents;
	    int index;
	    
	    if (objc < 3 || objc > 5) {
		Tcl_WrongNumArgs(interp, 2, objv, 
				 "?-linktype? linkname ?target?");
		return TCL_ERROR;
	    }
	    
	    /* Index of the 'source' argument */
	    if (objc == 5) {
		index = 3;
	    } else {
		index = 2;
	    }
	    
	    if (objc > 3) {
		int linkAction;
		if (objc == 5) {
		    /* We have a '-linktype' argument */
		    static CONST char *linkTypes[] = {
			"-symbolic", "-hard", NULL
		    };
		    if (Tcl_GetIndexFromObj(interp, objv[2], linkTypes, 
				     "switch", 0, &linkAction) != TCL_OK) {
			return TCL_ERROR;
		    }
		    if (linkAction == 0) {
		        linkAction = TCL_CREATE_SYMBOLIC_LINK;
		    } else {
			linkAction = TCL_CREATE_HARD_LINK;
		    }
		} else {
		    linkAction = TCL_CREATE_SYMBOLIC_LINK|TCL_CREATE_HARD_LINK;
		}
		if (Tcl_FSConvertToPathType(interp, objv[index]) != TCL_OK) {
		    return TCL_ERROR;
		}
		/* Create link from source to target */
		contents = Tcl_FSLink(objv[index], objv[index+1], linkAction);
		if (contents == NULL) {
		    /* 
		     * We handle two common error cases specially, and
		     * for all other errors, we use the standard posix
		     * error message.
		     */
		    if (errno == EEXIST) {
			Tcl_AppendResult(interp, "could not create new link \"", 
				Tcl_GetString(objv[index]), 
				"\": that path already exists", (char *) NULL);
		    } else if (errno == ENOENT) {
			Tcl_AppendResult(interp, "could not create new link \"", 
				Tcl_GetString(objv[index]), 
				"\" since target \"", 
				Tcl_GetString(objv[index+1]), 
				"\" doesn't exist", 
				(char *) NULL);
		    } else {
			Tcl_AppendResult(interp, "could not create new link \"", 
				Tcl_GetString(objv[index]), "\" pointing to \"", 
				Tcl_GetString(objv[index+1]), "\": ", 
				Tcl_PosixError(interp), (char *) NULL);
		    }
		    return TCL_ERROR;
		}
	    } else {
		if (Tcl_FSConvertToPathType(interp, objv[index]) != TCL_OK) {
		    return TCL_ERROR;
		}
		/* Read link */
		contents = Tcl_FSLink(objv[index], NULL, 0);
		if (contents == NULL) {
		    Tcl_AppendResult(interp, "could not read link \"", 
			    Tcl_GetString(objv[index]), "\": ", 
			    Tcl_PosixError(interp), (char *) NULL);
		    return TCL_ERROR;
		}
	    }
	    Tcl_SetObjResult(interp, contents);
	    if (objc == 3) {
		/* 
		 * If we are reading a link, we need to free this
		 * result refCount.  If we are creating a link, this
		 * will just be objv[index+1], and so we don't own it.
		 */
		Tcl_DecrRefCount(contents);
	    }
d1001 1
a1001 1
	    Tcl_StatBuf buf;
d1007 1
a1007 1
	    if (GetStatBuf(interp, objv[2], Tcl_FSLstat, &buf) != TCL_OK) {
d1014 2
a1015 1
	    Tcl_StatBuf buf;
d1022 1
a1022 1
	    if (GetStatBuf(interp, objv[2], Tcl_FSStat, &buf) != TCL_OK) {
d1032 3
a1034 2
		if (Tcl_FSUtime(objv[2], &tval) != 0) {
		    Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
d1036 1
a1036 1
			    Tcl_GetString(objv[2]), "\": ",
d1046 1
a1046 1
		if (GetStatBuf(interp, objv[2], Tcl_FSStat, &buf) != TCL_OK) {
d1050 1
a1050 1
	    Tcl_SetLongObj(Tcl_GetObjResult(interp), (long) buf.st_mtime);
d1054 3
d1061 4
a1064 1
	    return TclFileMakeDirsCmd(interp, objc, objv);
d1067 1
a1067 1
	    CONST char *fileName;
d1078 1
a1078 2
	    Tcl_SetStringObj(Tcl_GetObjResult(interp), fileName, 
			     Tcl_DStringLength(&ds));
a1081 12
	case FILE_NORMALIZE: {
	    Tcl_Obj *fileName;

	    if (objc != 3) {
		Tcl_WrongNumArgs(interp, 2, objv, "filename");
		return TCL_ERROR;
	    }

	    fileName = Tcl_FSGetNormalizedPath(interp, objv[2]);
	    Tcl_SetObjResult(interp, fileName);
	    return TCL_OK;
	}
d1084 1
a1084 1
	    Tcl_StatBuf buf;
d1090 1
a1090 1
	    if (GetStatBuf(NULL, objv[2], Tcl_FSStat, &buf) == TCL_OK) {
d1096 1
a1096 1
#if (defined(__WIN32__) || defined(MAC_TCL) || defined(__CYGWIN__))
d1102 1
a1102 1
	    Tcl_SetBooleanObj(Tcl_GetObjResult(interp), value);
d1106 2
d1111 2
a1112 1
	    switch (Tcl_FSGetPathType(objv[2])) {
d1114 1
a1114 1
	    	    Tcl_SetStringObj(Tcl_GetObjResult(interp), "absolute", -1);
d1117 1
a1117 1
	    	    Tcl_SetStringObj(Tcl_GetObjResult(interp), "relative", -1);
d1120 1
a1120 2
		    Tcl_SetStringObj(Tcl_GetObjResult(interp), 
				     "volumerelative", -1);
d1132 2
a1133 1
	    Tcl_Obj *contents;
d1139 3
a1141 1
	    if (Tcl_FSConvertToPathType(interp, objv[2]) != TCL_OK) {
d1145 14
a1158 1
	    contents = Tcl_FSLink(objv[2], NULL, 0);
d1160 1
d1167 1
a1167 2
	    Tcl_SetObjResult(interp, contents);
	    Tcl_DecrRefCount(contents);
d1171 7
a1177 1
	    return TclFileRenameCmd(interp, objc, objv);
d1191 1
a1191 1
	        Tcl_SetStringObj(Tcl_GetObjResult(interp), fileName,
a1195 31
	case FILE_SEPARATOR: {
	    if ((objc < 2) || (objc > 3)) {
		Tcl_WrongNumArgs(interp, 2, objv, "?name?");
		return TCL_ERROR;
	    }
	    if (objc == 2) {
	        char *separator = NULL; /* lint */
		switch (tclPlatform) {
		    case TCL_PLATFORM_UNIX:
			separator = "/";
			break;
		    case TCL_PLATFORM_WINDOWS:
			separator = "\\";
			break;
		    case TCL_PLATFORM_MAC:
			separator = ":";
			break;
		}
		Tcl_SetObjResult(interp, Tcl_NewStringObj(separator,1));
	    } else {
		Tcl_Obj *separatorObj = Tcl_FSPathSeparator(objv[2]);
		if (separatorObj != NULL) {
		    Tcl_SetObjResult(interp, separatorObj);
		} else {
		    Tcl_SetObjResult(interp, 
			    Tcl_NewStringObj("Unrecognised path",-1));
		    return TCL_ERROR;
		}
	    }
	    return TCL_OK;
	}
d1197 1
a1197 1
	    Tcl_StatBuf buf;
d1202 1
a1202 1
	    if (GetStatBuf(interp, objv[2], Tcl_FSStat, &buf) != TCL_OK) {
d1205 1
a1205 2
	    Tcl_SetWideIntObj(Tcl_GetObjResult(interp),
		    (Tcl_WideInt) buf.st_size);
d1209 5
d1217 7
a1223 1
	    Tcl_SetObjResult(interp, Tcl_FSSplitPath(objv[2], NULL));
d1228 1
a1228 1
	    Tcl_StatBuf buf;
d1234 1
a1234 1
	    if (GetStatBuf(interp, objv[2], Tcl_FSStat, &buf) != TCL_OK) {
a1239 15
	case FILE_SYSTEM: {
	    Tcl_Obj* fsInfo;
	    if (objc != 3) {
		goto only3Args;
	    }
	    fsInfo = Tcl_FSFileSystemInfo(objv[2]);
	    if (fsInfo != NULL) {
		Tcl_SetObjResult(interp, fsInfo);
		return TCL_OK;
	    } else {
		Tcl_SetObjResult(interp, 
				 Tcl_NewStringObj("Unrecognised path",-1));
		return TCL_ERROR;
	    }
	}
d1241 2
a1242 2
	    int splitElements;
	    Tcl_Obj *splitPtr;
d1247 2
a1248 15
	    /* 
	     * The behaviour we want here is slightly different to
	     * the standard Tcl_FSSplitPath in the handling of home
	     * directories; Tcl_FSSplitPath preserves the "~" while 
	     * this code computes the actual full path name, if we
	     * had just a single component.
	     */	    
	    splitPtr = Tcl_FSSplitPath(objv[2], &splitElements);
	    if ((splitElements == 1) && (Tcl_GetString(objv[2])[0] == '~')) {
		Tcl_DecrRefCount(splitPtr);
		splitPtr = Tcl_FSGetNormalizedPath(interp, objv[2]);
		if (splitPtr == NULL) {
		    return TCL_ERROR;
		}
		splitPtr = Tcl_FSSplitPath(splitPtr, &splitElements);
d1256 4
a1259 7
	    if (splitElements > 0) {
	    	if ((splitElements > 1)
		  || (Tcl_FSGetPathType(objv[2]) == TCL_PATH_RELATIVE)) {
		    
		    Tcl_Obj *tail = NULL;
		    Tcl_ListObjIndex(NULL, splitPtr, splitElements-1, &tail);
		    Tcl_SetObjResult(interp, tail);
d1262 1
a1262 1
	    Tcl_DecrRefCount(splitPtr);
d1266 1
a1266 1
	    Tcl_StatBuf buf;
d1271 1
a1271 1
	    if (GetStatBuf(interp, objv[2], Tcl_FSLstat, &buf) != TCL_OK) {
d1274 1
a1274 1
	    Tcl_SetStringObj(Tcl_GetObjResult(interp), 
d1283 1
a1283 2
	    Tcl_SetObjResult(interp, Tcl_FSListVolumes());
	    return TCL_OK;
d1301 57
d1382 2
d1385 3
a1387 1
    if (Tcl_FSConvertToPathType(interp, objPtr) != TCL_OK) {
d1390 2
a1391 1
	value = (Tcl_FSAccess(objPtr, mode) == 0);
d1422 1
a1422 1
    Tcl_FSStatProc *statProc;	/* Either stat() or lstat() depending on
d1424 1
a1424 1
    Tcl_StatBuf *statPtr;	/* Filled with info about file obtained by
d1427 2
d1431 3
a1433 1
    if (Tcl_FSConvertToPathType(interp, objPtr) != TCL_OK) {
d1437 2
a1438 1
    status = (*statProc)(objPtr, statPtr);
d1475 1
a1475 1
    Tcl_StatBuf *statPtr;		/* Pointer to buffer containing
d1478 1
a1478 4
    Tcl_Obj *var = Tcl_NewStringObj(varName, -1);
    Tcl_Obj *field = Tcl_NewObj();
    Tcl_Obj *value;
    register unsigned short mode;
d1480 54
a1533 11
    /*
     * Assume Tcl_ObjSetVar2() does not keep a copy of the field name!
     */
#define STORE_ARY(fieldName, object) \
    Tcl_SetStringObj(field, (fieldName), -1); \
    value = (object); \
    if (Tcl_ObjSetVar2(interp,var,field,value,TCL_LEAVE_ERR_MSG) == NULL) { \
	Tcl_DecrRefCount(var); \
	Tcl_DecrRefCount(field); \
	Tcl_DecrRefCount(value); \
	return TCL_ERROR; \
a1534 26

    Tcl_IncrRefCount(var);
    Tcl_IncrRefCount(field);
    STORE_ARY("dev",   Tcl_NewLongObj((long)statPtr->st_dev));
    /*
     * Watch out porters; the inode is meant to be an *unsigned* value,
     * so the cast might fail when there isn't a real arithmentic 'long
     * long' type...
     */
    STORE_ARY("ino",   Tcl_NewWideIntObj((Tcl_WideInt)statPtr->st_ino));
    STORE_ARY("nlink", Tcl_NewLongObj((long)statPtr->st_nlink));
    STORE_ARY("uid",   Tcl_NewLongObj((long)statPtr->st_uid));
    STORE_ARY("gid",   Tcl_NewLongObj((long)statPtr->st_gid));
    STORE_ARY("size",  Tcl_NewWideIntObj((Tcl_WideInt)statPtr->st_size));
#ifdef HAVE_ST_BLOCKS
    STORE_ARY("blocks",Tcl_NewWideIntObj((Tcl_WideInt)statPtr->st_blocks));
#endif
    STORE_ARY("atime", Tcl_NewLongObj((long)statPtr->st_atime));
    STORE_ARY("mtime", Tcl_NewLongObj((long)statPtr->st_mtime));
    STORE_ARY("ctime", Tcl_NewLongObj((long)statPtr->st_ctime));
    mode = (unsigned short) statPtr->st_mode;
    STORE_ARY("mode",  Tcl_NewIntObj(mode));
    STORE_ARY("type",  Tcl_NewStringObj(GetTypeFromMode(mode), -1));
#undef STORE_ARY
    Tcl_DecrRefCount(var);
    Tcl_DecrRefCount(field);
d1713 11
a1723 11
    int indexArray[STATIC_LIST_SIZE];
    int varcListArray[STATIC_LIST_SIZE];
    Tcl_Obj **varvListArray[STATIC_LIST_SIZE];
    int argcListArray[STATIC_LIST_SIZE];
    Tcl_Obj **argvListArray[STATIC_LIST_SIZE];

    int *index = indexArray;		   /* Array of value list indices */
    int *varcList = varcListArray;	   /* # loop variables per list */
    Tcl_Obj ***varvList = varvListArray;   /* Array of var name lists */
    int *argcList = argcListArray;	   /* Array of value list sizes */
    Tcl_Obj ***argvList = argvListArray;   /* Array of value lists */
d1809 3
a1811 6
	     * Refetch the list members; we assume that the sizes are
	     * the same, but the array of elements might be different
	     * if the internal rep of the objects has been lost and
	     * recreated (it is too difficult to accurately tell when
	     * this happens, which can lead to some wierd crashes,
	     * like Bug #494348...)
d1814 13
a1826 9
	    result = Tcl_ListObjGetElements(interp, argObjv[1+i*2],
		    &varcList[i], &varvList[i]);
	    if (result != TCL_OK) {
		panic("Tcl_ForeachObjCmd: could not reconvert variable list %d to a list object\n", i);
	    }
	    result = Tcl_ListObjGetElements(interp, argObjv[2+i*2],
		    &argcList[i], &argvList[i]);
	    if (result != TCL_OK) {
		panic("Tcl_ForeachObjCmd: could not reconvert value list %d to a list object\n", i);
d1923 1
a1923 1
    int formatLen;		/* The length of the format string */
d1925 1
a1925 1
    char newFormat[43];		/* A new format specifier is generated here. */
d1933 1
a1933 1
    long intValue;		/* Used to hold value to pass to sprintf, if
a1938 4
#ifndef TCL_WIDE_INT_IS_LONG
    Tcl_WideInt wideValue;	/* Used to hold value to pass to sprintf if
				 * it's a 'long long' value. */
#endif /* TCL_WIDE_INT_IS_LONG */
a1947 1
#   define WIDE_VALUE 5
d1949 1
a1949 1

a1975 3
#ifndef TCL_WIDE_INT_IS_LONG
    int useWide;		/* Value to be printed is Tcl_WideInt. */
#endif /* TCL_WIDE_INT_IS_LONG */
d1985 1
a1985 2
     *    because some of the arguments may be two-word values (doubles
     *    and wide-ints).
d1995 1
a1995 1
    format = Tcl_GetStringFromObj(objv[1], &formatLen);
a2004 3
#ifndef TCL_WIDE_INT_IS_LONG
	useWide = 0;
#endif /* TCL_WIDE_INT_IS_LONG */
d2084 1
a2084 1
	if (isdigit(UCHAR(*format))) {		/* INTL: Tcl source. */
d2127 1
a2127 1
	if (isdigit(UCHAR(*format))) {		/* INTL: Tcl source. */
a2147 5
#ifndef TCL_WIDE_INT_IS_LONG
	    useWide = 1;
	    strcpy(newPtr, TCL_LL_MODIFIER);
	    newPtr += TCL_LL_MODIFIER_SIZE;
#endif /* TCL_WIDE_INT_IS_LONG */
d2169 1
a2169 12
#ifndef TCL_WIDE_INT_IS_LONG
		if (useWide) {
		    if (Tcl_GetWideIntFromObj(interp, /* INTL: Tcl source. */
			    objv[objIndex], &wideValue) != TCL_OK) {
			goto fmtError;
		    }
		    whichValue = WIDE_VALUE;
		    size = 40 + precision;
		    break;
		}
#endif /* TCL_WIDE_INT_IS_LONG */
		if (Tcl_GetLongFromObj(interp,	      /* INTL: Tcl source. */
a2172 11
#if (LONG_MAX > INT_MAX)
		/*
		 * Add the 'l' for long format type because we are on
		 * an LP64 archtecture and we are really going to pass
		 * a long argument to sprintf.
		 */
		newPtr++;
		*newPtr = 0;
		newPtr[-1] = newPtr[-2];
		newPtr[-2] = 'l';
#endif /* LONG_MAX > INT_MAX */
d2196 1
a2196 1
		if (Tcl_GetLongFromObj(interp,	/* INTL: Tcl source. */
a2256 6
#ifndef TCL_WIDE_INT_IS_LONG
		case WIDE_VALUE: {
		    sprintf(dst, newFormat, wideValue);
		    break;
		}
#endif /* TCL_WIDE_INT_IS_LONG */
d2347 40
@


1.2
log
@touched all Tcl files to ease next import.
@
text
@@


1.2.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.2.16.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d21 2
d30 2
a31 2
			    Tcl_Obj *objPtr, Tcl_FSStatProc *statProc,
			    Tcl_StatBuf *statPtr));
d33 2
d36 3
a38 1
			    char *varName, Tcl_StatBuf *statPtr));
d102 1
a102 1
    int body, result, caseObjc;
d104 1
d140 1
a140 1
	CONST char **patObjv;
d310 2
a311 1
    Tcl_Obj *dir;
d320 1
a320 1
	dir = objv[1];
d322 1
a322 2
	dir = Tcl_NewStringObj("~",1);
	Tcl_IncrRefCount(dir);
d324 2
a325 9
    if (Tcl_FSConvertToPathType(interp, dir) != TCL_OK) {
	result = TCL_ERROR;
    } else {
	result = Tcl_FSChdir(dir);
	if (result != TCL_OK) {
	    Tcl_AppendResult(interp, "couldn't change working directory to \"",
		    Tcl_GetString(dir), "\": ", Tcl_PosixError(interp), (char *) NULL);
	    result = TCL_ERROR;
	}
d327 8
a334 2
    if (objc != 2) {
	Tcl_DecrRefCount(dir);
d336 1
a336 1
    return result;
d435 1
a435 1
    static CONST char *optionStrings[] = {
d520 1
a520 2
		Tcl_SetStringObj(Tcl_GetObjResult(interp),
			Tcl_GetEncodingName(NULL), -1);
a731 1
    /*** QUESTION: Do we need to copy the slow way? ***/
d768 1
a768 3
 *      With the object-based Tcl_FS APIs, the above NOTE may no
 *      longer be true.  In any case this assertion should be tested.
 *      
d786 1
d793 1
a793 1
    static CONST char *fileOptions[] = {
d797 2
a798 3
	"isdirectory",	"isfile",	"join",		"link",
	"lstat",        "mtime",	"mkdir",	"nativename",	
	"normalize",    "owned",
d800 1
a800 2
	"rootname",	"separator",    "size",		"split",	
	"stat",         "system", 
d808 2
a809 3
	FILE_ISDIRECTORY, FILE_ISFILE,	FILE_JOIN,	FILE_LINK, 
	FILE_LSTAT,     FILE_MTIME,	FILE_MKDIR,	FILE_NATIVENAME, 
	FILE_NORMALIZE, FILE_OWNED,
d811 1
a811 2
	FILE_ROOTNAME,	FILE_SEPARATOR, FILE_SIZE,	FILE_SPLIT,	
	FILE_STAT,      FILE_SYSTEM, 
d824 1
d827 2
a828 1
	    Tcl_StatBuf buf;
d835 1
a835 1
	    if (GetStatBuf(interp, objv[2], Tcl_FSStat, &buf) != TCL_OK) {
d845 3
a847 2
		if (Tcl_FSUtime(objv[2], &tval) != 0) {
		    Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
d849 1
a849 1
			    Tcl_GetString(objv[2]), "\": ",
d859 1
a859 1
		if (GetStatBuf(interp, objv[2], Tcl_FSStat, &buf) != TCL_OK) {
d863 1
a863 1
	    Tcl_SetLongObj(Tcl_GetObjResult(interp), (long) buf.st_atime);
d878 7
a884 1
	    return TclFileCopyCmd(interp, objc, objv);
d887 7
a893 1
	    return TclFileDeleteCmd(interp, objc, objv);
d896 3
a898 1
	    Tcl_Obj *dirPtr;
d902 22
a923 3
	    dirPtr = TclFileDirname(interp, objv[2]);
	    if (dirPtr == NULL) {
	        return TCL_ERROR;
d925 1
a925 3
		Tcl_SetObjResult(interp, dirPtr);
		Tcl_DecrRefCount(dirPtr);
		return TCL_OK;
d927 2
d950 1
a950 1
	    	Tcl_SetStringObj(Tcl_GetObjResult(interp), extension, -1);
d956 1
a956 1
	    Tcl_StatBuf buf;
d962 1
a962 1
	    if (GetStatBuf(NULL, objv[2], Tcl_FSStat, &buf) == TCL_OK) {
d965 1
a965 1
	    Tcl_SetBooleanObj(Tcl_GetObjResult(interp), value);
d970 1
a970 1
	    Tcl_StatBuf buf;
d976 1
a976 1
	    if (GetStatBuf(NULL, objv[2], Tcl_FSStat, &buf) == TCL_OK) {
d979 1
a979 1
	    Tcl_SetBooleanObj(Tcl_GetObjResult(interp), value);
d983 2
a984 1
	    Tcl_Obj *resObj;
d990 7
a996 92
	    resObj = Tcl_FSJoinToPath(NULL, objc - 2, objv + 2);
	    Tcl_SetObjResult(interp, resObj);
	    return TCL_OK;
	}
	case FILE_LINK: {
	    Tcl_Obj *contents;
	    int index;
	    
	    if (objc < 3 || objc > 5) {
		Tcl_WrongNumArgs(interp, 2, objv, 
				 "?-linktype? linkname ?target?");
		return TCL_ERROR;
	    }
	    
	    /* Index of the 'source' argument */
	    if (objc == 5) {
		index = 3;
	    } else {
		index = 2;
	    }
	    
	    if (objc > 3) {
		int linkAction;
		if (objc == 5) {
		    /* We have a '-linktype' argument */
		    static CONST char *linkTypes[] = {
			"-symbolic", "-hard", NULL
		    };
		    if (Tcl_GetIndexFromObj(interp, objv[2], linkTypes, 
				     "switch", 0, &linkAction) != TCL_OK) {
			return TCL_ERROR;
		    }
		    if (linkAction == 0) {
		        linkAction = TCL_CREATE_SYMBOLIC_LINK;
		    } else {
			linkAction = TCL_CREATE_HARD_LINK;
		    }
		} else {
		    linkAction = TCL_CREATE_SYMBOLIC_LINK|TCL_CREATE_HARD_LINK;
		}
		if (Tcl_FSConvertToPathType(interp, objv[index]) != TCL_OK) {
		    return TCL_ERROR;
		}
		/* Create link from source to target */
		contents = Tcl_FSLink(objv[index], objv[index+1], linkAction);
		if (contents == NULL) {
		    /* 
		     * We handle two common error cases specially, and
		     * for all other errors, we use the standard posix
		     * error message.
		     */
		    if (errno == EEXIST) {
			Tcl_AppendResult(interp, "could not create new link \"", 
				Tcl_GetString(objv[index]), 
				"\": that path already exists", (char *) NULL);
		    } else if (errno == ENOENT) {
			Tcl_AppendResult(interp, "could not create new link \"", 
				Tcl_GetString(objv[index]), 
				"\" since target \"", 
				Tcl_GetString(objv[index+1]), 
				"\" doesn't exist", 
				(char *) NULL);
		    } else {
			Tcl_AppendResult(interp, "could not create new link \"", 
				Tcl_GetString(objv[index]), "\" pointing to \"", 
				Tcl_GetString(objv[index+1]), "\": ", 
				Tcl_PosixError(interp), (char *) NULL);
		    }
		    return TCL_ERROR;
		}
	    } else {
		if (Tcl_FSConvertToPathType(interp, objv[index]) != TCL_OK) {
		    return TCL_ERROR;
		}
		/* Read link */
		contents = Tcl_FSLink(objv[index], NULL, 0);
		if (contents == NULL) {
		    Tcl_AppendResult(interp, "could not read link \"", 
			    Tcl_GetString(objv[index]), "\": ", 
			    Tcl_PosixError(interp), (char *) NULL);
		    return TCL_ERROR;
		}
	    }
	    Tcl_SetObjResult(interp, contents);
	    if (objc == 3) {
		/* 
		 * If we are reading a link, we need to free this
		 * result refCount.  If we are creating a link, this
		 * will just be objv[index+1], and so we don't own it.
		 */
		Tcl_DecrRefCount(contents);
	    }
d1001 1
a1001 1
	    Tcl_StatBuf buf;
d1007 1
a1007 1
	    if (GetStatBuf(interp, objv[2], Tcl_FSLstat, &buf) != TCL_OK) {
d1014 2
a1015 1
	    Tcl_StatBuf buf;
d1022 1
a1022 1
	    if (GetStatBuf(interp, objv[2], Tcl_FSStat, &buf) != TCL_OK) {
d1032 3
a1034 2
		if (Tcl_FSUtime(objv[2], &tval) != 0) {
		    Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
d1036 1
a1036 1
			    Tcl_GetString(objv[2]), "\": ",
d1046 1
a1046 1
		if (GetStatBuf(interp, objv[2], Tcl_FSStat, &buf) != TCL_OK) {
d1050 1
a1050 1
	    Tcl_SetLongObj(Tcl_GetObjResult(interp), (long) buf.st_mtime);
d1054 3
d1061 4
a1064 1
	    return TclFileMakeDirsCmd(interp, objc, objv);
d1067 1
a1067 1
	    CONST char *fileName;
d1078 1
a1078 2
	    Tcl_SetStringObj(Tcl_GetObjResult(interp), fileName, 
			     Tcl_DStringLength(&ds));
a1081 12
	case FILE_NORMALIZE: {
	    Tcl_Obj *fileName;

	    if (objc != 3) {
		Tcl_WrongNumArgs(interp, 2, objv, "filename");
		return TCL_ERROR;
	    }

	    fileName = Tcl_FSGetNormalizedPath(interp, objv[2]);
	    Tcl_SetObjResult(interp, fileName);
	    return TCL_OK;
	}
d1084 1
a1084 1
	    Tcl_StatBuf buf;
d1090 1
a1090 1
	    if (GetStatBuf(NULL, objv[2], Tcl_FSStat, &buf) == TCL_OK) {
d1102 1
a1102 1
	    Tcl_SetBooleanObj(Tcl_GetObjResult(interp), value);
d1106 2
d1111 2
a1112 1
	    switch (Tcl_FSGetPathType(objv[2])) {
d1114 1
a1114 1
	    	    Tcl_SetStringObj(Tcl_GetObjResult(interp), "absolute", -1);
d1117 1
a1117 1
	    	    Tcl_SetStringObj(Tcl_GetObjResult(interp), "relative", -1);
d1120 1
a1120 2
		    Tcl_SetStringObj(Tcl_GetObjResult(interp), 
				     "volumerelative", -1);
d1132 2
a1133 1
	    Tcl_Obj *contents;
d1139 3
a1141 1
	    if (Tcl_FSConvertToPathType(interp, objv[2]) != TCL_OK) {
d1145 14
a1158 1
	    contents = Tcl_FSLink(objv[2], NULL, 0);
d1160 1
d1167 1
a1167 2
	    Tcl_SetObjResult(interp, contents);
	    Tcl_DecrRefCount(contents);
d1171 7
a1177 1
	    return TclFileRenameCmd(interp, objc, objv);
d1191 1
a1191 1
	        Tcl_SetStringObj(Tcl_GetObjResult(interp), fileName,
a1195 31
	case FILE_SEPARATOR: {
	    if ((objc < 2) || (objc > 3)) {
		Tcl_WrongNumArgs(interp, 2, objv, "?name?");
		return TCL_ERROR;
	    }
	    if (objc == 2) {
	        char *separator = NULL; /* lint */
		switch (tclPlatform) {
		    case TCL_PLATFORM_UNIX:
			separator = "/";
			break;
		    case TCL_PLATFORM_WINDOWS:
			separator = "\\";
			break;
		    case TCL_PLATFORM_MAC:
			separator = ":";
			break;
		}
		Tcl_SetObjResult(interp, Tcl_NewStringObj(separator,1));
	    } else {
		Tcl_Obj *separatorObj = Tcl_FSPathSeparator(objv[2]);
		if (separatorObj != NULL) {
		    Tcl_SetObjResult(interp, separatorObj);
		} else {
		    Tcl_SetObjResult(interp, 
			    Tcl_NewStringObj("Unrecognised path",-1));
		    return TCL_ERROR;
		}
	    }
	    return TCL_OK;
	}
d1197 1
a1197 1
	    Tcl_StatBuf buf;
d1202 1
a1202 1
	    if (GetStatBuf(interp, objv[2], Tcl_FSStat, &buf) != TCL_OK) {
d1205 1
a1205 2
	    Tcl_SetWideIntObj(Tcl_GetObjResult(interp),
		    (Tcl_WideInt) buf.st_size);
d1209 5
d1217 7
a1223 1
	    Tcl_SetObjResult(interp, Tcl_FSSplitPath(objv[2], NULL));
d1228 1
a1228 1
	    Tcl_StatBuf buf;
d1234 1
a1234 1
	    if (GetStatBuf(interp, objv[2], Tcl_FSStat, &buf) != TCL_OK) {
a1239 15
	case FILE_SYSTEM: {
	    Tcl_Obj* fsInfo;
	    if (objc != 3) {
		goto only3Args;
	    }
	    fsInfo = Tcl_FSFileSystemInfo(objv[2]);
	    if (fsInfo != NULL) {
		Tcl_SetObjResult(interp, fsInfo);
		return TCL_OK;
	    } else {
		Tcl_SetObjResult(interp, 
				 Tcl_NewStringObj("Unrecognised path",-1));
		return TCL_ERROR;
	    }
	}
d1241 2
a1242 2
	    int splitElements;
	    Tcl_Obj *splitPtr;
d1247 2
a1248 15
	    /* 
	     * The behaviour we want here is slightly different to
	     * the standard Tcl_FSSplitPath in the handling of home
	     * directories; Tcl_FSSplitPath preserves the "~" while 
	     * this code computes the actual full path name, if we
	     * had just a single component.
	     */	    
	    splitPtr = Tcl_FSSplitPath(objv[2], &splitElements);
	    if ((splitElements == 1) && (Tcl_GetString(objv[2])[0] == '~')) {
		Tcl_DecrRefCount(splitPtr);
		splitPtr = Tcl_FSGetNormalizedPath(interp, objv[2]);
		if (splitPtr == NULL) {
		    return TCL_ERROR;
		}
		splitPtr = Tcl_FSSplitPath(splitPtr, &splitElements);
d1256 4
a1259 7
	    if (splitElements > 0) {
	    	if ((splitElements > 1)
		  || (Tcl_FSGetPathType(objv[2]) == TCL_PATH_RELATIVE)) {
		    
		    Tcl_Obj *tail = NULL;
		    Tcl_ListObjIndex(NULL, splitPtr, splitElements-1, &tail);
		    Tcl_SetObjResult(interp, tail);
d1262 1
a1262 1
	    Tcl_DecrRefCount(splitPtr);
d1266 1
a1266 1
	    Tcl_StatBuf buf;
d1271 1
a1271 1
	    if (GetStatBuf(interp, objv[2], Tcl_FSLstat, &buf) != TCL_OK) {
d1274 1
a1274 1
	    Tcl_SetStringObj(Tcl_GetObjResult(interp), 
d1283 1
a1283 2
	    Tcl_SetObjResult(interp, Tcl_FSListVolumes());
	    return TCL_OK;
d1301 57
d1382 2
d1385 3
a1387 1
    if (Tcl_FSConvertToPathType(interp, objPtr) != TCL_OK) {
d1390 2
a1391 1
	value = (Tcl_FSAccess(objPtr, mode) == 0);
d1422 1
a1422 1
    Tcl_FSStatProc *statProc;	/* Either stat() or lstat() depending on
d1424 1
a1424 1
    Tcl_StatBuf *statPtr;	/* Filled with info about file obtained by
d1427 2
d1431 3
a1433 1
    if (Tcl_FSConvertToPathType(interp, objPtr) != TCL_OK) {
d1437 2
a1438 1
    status = (*statProc)(objPtr, statPtr);
d1475 1
a1475 1
    Tcl_StatBuf *statPtr;		/* Pointer to buffer containing
d1478 1
a1478 4
    Tcl_Obj *var = Tcl_NewStringObj(varName, -1);
    Tcl_Obj *field = Tcl_NewObj();
    Tcl_Obj *value;
    register unsigned short mode;
d1480 54
a1533 11
    /*
     * Assume Tcl_ObjSetVar2() does not keep a copy of the field name!
     */
#define STORE_ARY(fieldName, object) \
    Tcl_SetStringObj(field, (fieldName), -1); \
    value = (object); \
    if (Tcl_ObjSetVar2(interp,var,field,value,TCL_LEAVE_ERR_MSG) == NULL) { \
	Tcl_DecrRefCount(var); \
	Tcl_DecrRefCount(field); \
	Tcl_DecrRefCount(value); \
	return TCL_ERROR; \
a1534 26

    Tcl_IncrRefCount(var);
    Tcl_IncrRefCount(field);
    STORE_ARY("dev",   Tcl_NewLongObj((long)statPtr->st_dev));
    /*
     * Watch out porters; the inode is meant to be an *unsigned* value,
     * so the cast might fail when there isn't a real arithmentic 'long
     * long' type...
     */
    STORE_ARY("ino",   Tcl_NewWideIntObj((Tcl_WideInt)statPtr->st_ino));
    STORE_ARY("nlink", Tcl_NewLongObj((long)statPtr->st_nlink));
    STORE_ARY("uid",   Tcl_NewLongObj((long)statPtr->st_uid));
    STORE_ARY("gid",   Tcl_NewLongObj((long)statPtr->st_gid));
    STORE_ARY("size",  Tcl_NewWideIntObj((Tcl_WideInt)statPtr->st_size));
#ifdef HAVE_ST_BLOCKS
    STORE_ARY("blocks",Tcl_NewWideIntObj((Tcl_WideInt)statPtr->st_blocks));
#endif
    STORE_ARY("atime", Tcl_NewLongObj((long)statPtr->st_atime));
    STORE_ARY("mtime", Tcl_NewLongObj((long)statPtr->st_mtime));
    STORE_ARY("ctime", Tcl_NewLongObj((long)statPtr->st_ctime));
    mode = (unsigned short) statPtr->st_mode;
    STORE_ARY("mode",  Tcl_NewIntObj(mode));
    STORE_ARY("type",  Tcl_NewStringObj(GetTypeFromMode(mode), -1));
#undef STORE_ARY
    Tcl_DecrRefCount(var);
    Tcl_DecrRefCount(field);
d1713 11
a1723 11
    int indexArray[STATIC_LIST_SIZE];
    int varcListArray[STATIC_LIST_SIZE];
    Tcl_Obj **varvListArray[STATIC_LIST_SIZE];
    int argcListArray[STATIC_LIST_SIZE];
    Tcl_Obj **argvListArray[STATIC_LIST_SIZE];

    int *index = indexArray;		   /* Array of value list indices */
    int *varcList = varcListArray;	   /* # loop variables per list */
    Tcl_Obj ***varvList = varvListArray;   /* Array of var name lists */
    int *argcList = argcListArray;	   /* Array of value list sizes */
    Tcl_Obj ***argvList = argvListArray;   /* Array of value lists */
d1809 3
a1811 6
	     * Refetch the list members; we assume that the sizes are
	     * the same, but the array of elements might be different
	     * if the internal rep of the objects has been lost and
	     * recreated (it is too difficult to accurately tell when
	     * this happens, which can lead to some wierd crashes,
	     * like Bug #494348...)
d1814 13
a1826 9
	    result = Tcl_ListObjGetElements(interp, argObjv[1+i*2],
		    &varcList[i], &varvList[i]);
	    if (result != TCL_OK) {
		panic("Tcl_ForeachObjCmd: could not reconvert variable list %d to a list object\n", i);
	    }
	    result = Tcl_ListObjGetElements(interp, argObjv[2+i*2],
		    &argcList[i], &argvList[i]);
	    if (result != TCL_OK) {
		panic("Tcl_ForeachObjCmd: could not reconvert value list %d to a list object\n", i);
d1923 1
a1923 1
    int formatLen;		/* The length of the format string */
d1925 1
a1925 1
    char newFormat[43];		/* A new format specifier is generated here. */
d1933 1
a1933 1
    long intValue;		/* Used to hold value to pass to sprintf, if
a1938 4
#ifndef TCL_WIDE_INT_IS_LONG
    Tcl_WideInt wideValue;	/* Used to hold value to pass to sprintf if
				 * it's a 'long long' value. */
#endif /* TCL_WIDE_INT_IS_LONG */
a1947 1
#   define WIDE_VALUE 5
d1949 1
a1949 1

a1975 3
#ifndef TCL_WIDE_INT_IS_LONG
    int useWide;		/* Value to be printed is Tcl_WideInt. */
#endif /* TCL_WIDE_INT_IS_LONG */
d1985 1
a1985 2
     *    because some of the arguments may be two-word values (doubles
     *    and wide-ints).
d1995 1
a1995 1
    format = Tcl_GetStringFromObj(objv[1], &formatLen);
a2004 3
#ifndef TCL_WIDE_INT_IS_LONG
	useWide = 0;
#endif /* TCL_WIDE_INT_IS_LONG */
d2084 1
a2084 1
	if (isdigit(UCHAR(*format))) {		/* INTL: Tcl source. */
d2127 1
a2127 1
	if (isdigit(UCHAR(*format))) {		/* INTL: Tcl source. */
a2147 5
#ifndef TCL_WIDE_INT_IS_LONG
	    useWide = 1;
	    strcpy(newPtr, TCL_LL_MODIFIER);
	    newPtr += TCL_LL_MODIFIER_SIZE;
#endif /* TCL_WIDE_INT_IS_LONG */
d2169 1
a2169 12
#ifndef TCL_WIDE_INT_IS_LONG
		if (useWide) {
		    if (Tcl_GetWideIntFromObj(interp, /* INTL: Tcl source. */
			    objv[objIndex], &wideValue) != TCL_OK) {
			goto fmtError;
		    }
		    whichValue = WIDE_VALUE;
		    size = 40 + precision;
		    break;
		}
#endif /* TCL_WIDE_INT_IS_LONG */
		if (Tcl_GetLongFromObj(interp,	      /* INTL: Tcl source. */
a2172 11
#if (LONG_MAX > INT_MAX)
		/*
		 * Add the 'l' for long format type because we are on
		 * an LP64 archtecture and we are really going to pass
		 * a long argument to sprintf.
		 */
		newPtr++;
		*newPtr = 0;
		newPtr[-1] = newPtr[-2];
		newPtr[-2] = 'l';
#endif /* LONG_MAX > INT_MAX */
d2196 1
a2196 1
		if (Tcl_GetLongFromObj(interp,	/* INTL: Tcl source. */
a2256 6
#ifndef TCL_WIDE_INT_IS_LONG
		case WIDE_VALUE: {
		    sprintf(dst, newFormat, wideValue);
		    break;
		}
#endif /* TCL_WIDE_INT_IS_LONG */
d2347 40
@


1.2.16.3
log
@2004-01-26  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20040126-merge.
@
text
@d804 10
a813 10
	FCMD_ATIME,	FCMD_ATTRIBUTES, FCMD_CHANNELS,	FCMD_COPY,
	FCMD_DELETE,
	FCMD_DIRNAME,	FCMD_EXECUTABLE, FCMD_EXISTS,	FCMD_EXTENSION,
	FCMD_ISDIRECTORY, FCMD_ISFILE,	FCMD_JOIN,	FCMD_LINK, 
	FCMD_LSTAT,     FCMD_MTIME,	FCMD_MKDIR,	FCMD_NATIVENAME, 
	FCMD_NORMALIZE, FCMD_OWNED,
	FCMD_PATHTYPE,	FCMD_READABLE,	FCMD_READLINK,	FCMD_RENAME,
	FCMD_ROOTNAME,	FCMD_SEPARATOR, FCMD_SIZE,	FCMD_SPLIT,	
	FCMD_STAT,      FCMD_SYSTEM, 
	FCMD_TAIL,	FCMD_TYPE,	FCMD_VOLUMES,	FCMD_WRITABLE
d826 1
a826 1
    	case FCMD_ATIME: {
d864 1
a864 1
	case FCMD_ATTRIBUTES: {
d867 1
a867 1
	case FCMD_CHANNELS: {
d875 1
a875 1
	case FCMD_COPY: {
d878 1
a878 1
	case FCMD_DELETE: {
d881 1
a881 1
    	case FCMD_DIRNAME: {
d895 1
a895 1
	case FCMD_EXECUTABLE: {
d901 1
a901 1
	case FCMD_EXISTS: {
d907 1
a907 1
	case FCMD_EXTENSION: {
d919 1
a919 1
    	case FCMD_ISDIRECTORY: {
d933 1
a933 1
    	case FCMD_ISFILE: {
d947 1
a947 1
	case FCMD_JOIN: {
d958 1
a958 1
	case FCMD_LINK: {
d1048 1
a1048 1
    	case FCMD_LSTAT: {
d1062 1
a1062 1
	case FCMD_MTIME: {
d1100 1
a1100 1
	case FCMD_MKDIR: {
d1107 1
a1107 1
	case FCMD_NATIVENAME: {
d1124 1
a1124 1
	case FCMD_NORMALIZE: {
d1136 1
a1136 1
	case FCMD_OWNED: {
d1159 1
a1159 1
	case FCMD_PATHTYPE: {
d1177 1
a1177 1
    	case FCMD_READABLE: {
d1183 1
a1183 1
	case FCMD_READLINK: {
d1206 1
a1206 1
	case FCMD_RENAME: {
d1209 1
a1209 1
	case FCMD_ROOTNAME: {
d1226 1
a1226 1
	case FCMD_SEPARATOR: {
d1257 1
a1257 1
	case FCMD_SIZE: {
d1270 1
a1270 1
	case FCMD_SPLIT: {
d1277 1
a1277 1
	case FCMD_STAT: {
d1291 1
a1291 1
	case FCMD_SYSTEM: {
d1306 1
a1306 1
    	case FCMD_TAIL: {
d1347 1
a1347 1
	case FCMD_TYPE: {
d1360 1
a1360 1
	case FCMD_VOLUMES: {
d1368 1
a1368 1
	case FCMD_WRITABLE: {
@


1.1
log
@Initial revision
@
text
@d14 1
a14 1
 * RCS: @@(#) $Id: tclCmdAH.c,v 1.12 1999/01/26 03:53:09 jingham Exp $
d19 3
d27 5
d33 2
d37 2
d43 1
a43 1
 * Tcl_BreakCmd --
d63 1
a63 1
Tcl_BreakCmd(dummy, interp, argc, argv)
d66 2
a67 2
    int argc;				/* Number of arguments. */
    char **argv;			/* Argument strings. */
d69 2
a70 3
    if (argc != 1) {
	Tcl_AppendResult(interp, "wrong # args: should be \"",
		argv[0], "\"", (char *) NULL);
d104 1
a104 1
    int argLen, caseObjc;
d114 1
a114 5
    /*
     * THIS FAILS IF AN OBJECT'S STRING REP HAS A NULL BYTE.
     */
    
    string = Tcl_GetStringFromObj(objv[1], &argLen);
d117 1
a117 1
    arg = Tcl_GetStringFromObj(objv[2], &argLen);
a128 1
     * THIS FAILS IF THE ARG'S STRING REP CONTAINS A NULL
d142 1
a142 1
	register char *p;
d144 1
a144 1
	if (i == (caseObjc-1)) {
d156 3
a158 3
	pat = Tcl_GetStringFromObj(caseObjv[i], &argLen);
	for (p = pat;  *p != 0;  p++) {	/* FAILS IF NULL BYTE */
	    if (isspace(UCHAR(*p)) || (*p == '\\')) {
d162 1
a162 1
	if (*p == 0) {
d164 1
a164 1
		body = i+1;
d167 1
a167 1
		body = i+1;
d185 1
a185 1
		body = i+1;
d197 2
a198 2
	armPtr = caseObjv[body-1];
	result = Tcl_EvalObj(interp, caseObjv[body]);
d200 1
a200 1
	    char msg[100];
d202 3
a204 2
	    arg = Tcl_GetStringFromObj(armPtr, &argLen);
	    sprintf(msg, "\n    (\"%.*s\" arm line %d)", argLen, arg,
d260 2
a261 2
    
    result = Tcl_EvalObj(interp, objv[1]);
d265 1
a265 1
		    Tcl_GetObjResult(interp), TCL_PARSE_PART1) == NULL) {
d311 1
a311 2
    int dirLength;
    Tcl_DString buffer;
d315 1
a315 1
	Tcl_WrongNumArgs(interp, 1, objv, "dirName");
d320 1
a320 1
	dirName = Tcl_GetStringFromObj(objv[1], &dirLength);
d324 10
a333 2
    dirName = Tcl_TranslateFileName(interp, dirName, &buffer);
    if (dirName == NULL) {
d336 1
a336 3
    result = TclChdir(interp, dirName);
    Tcl_DStringFree(&buffer);
    return result;
d345 1
a345 1
 *	command. See the user documentation for details on what it does/
d373 1
a373 1
 * Tcl_ContinueCmd -
d393 1
a393 1
Tcl_ContinueCmd(dummy, interp, argc, argv)
d396 2
a397 2
    int argc;				/* Number of arguments. */
    char **argv;			/* Argument strings. */
d399 2
a400 3
    if (argc != 1) {
	Tcl_AppendResult(interp, "wrong # args: should be \"", argv[0],
		"\"", (char *) NULL);
d409 125
a556 1
    register Tcl_Obj *namePtr;
d574 1
a574 3
	namePtr = Tcl_NewStringObj("errorCode", -1);
	Tcl_ObjSetVar2(interp, namePtr, (Tcl_Obj *) NULL, objv[3],
		TCL_GLOBAL_ONLY);
a575 1
	Tcl_DecrRefCount(namePtr); /* we're done with name object */
d616 1
a616 1
	result = Tcl_EvalObj(interp, objv[1]);
d620 2
a621 1
	 * between, then evaluate the result.
d623 2
a624 4
    
	objPtr = Tcl_ConcatObj(objc-1, objv+1);
	result = Tcl_EvalObj(interp, objPtr);
	Tcl_DecrRefCount(objPtr);  /* we're done with the object */
d627 2
a628 1
	char msg[60];
d708 1
a708 1
{
a729 1
     * THIS FAILS IF AN OBJECT'S STRING REP HAS A NULL BYTE.
a785 7
    char *fileName, *extension, *errorString;
    int statOp = 0;		/* Init. to avoid compiler warning. */
    int length;
    int mode = 0;			/* Initialized only to prevent
					 * compiler warning message. */
    struct stat statBuf;
    Tcl_DString buffer;
d787 1
a787 1
    int index, result;
d793 21
a813 14
enum {FILE_ATIME, FILE_ATTRIBUTES, FILE_COPY, FILE_DELETE, FILE_DIRNAME,
	FILE_EXECUTABLE, FILE_EXISTS, FILE_EXTENSION, FILE_ISDIRECTORY,
	FILE_ISFILE, FILE_JOIN, FILE_LSTAT, FILE_MTIME, FILE_MKDIR,
	FILE_NATIVENAME, FILE_OWNED, FILE_PATHTYPE, FILE_READABLE,
	FILE_READLINK, FILE_RENAME, FILE_ROOTNAME, FILE_SIZE, FILE_SPLIT,
	FILE_STAT, FILE_TAIL, FILE_TYPE, FILE_VOLUMES, FILE_WRITABLE};


    static char *fileOptions[] = {"atime", "attributes", "copy", "delete", 
    	    "dirname", "executable", "exists", "extension", "isdirectory", 
    	    "isfile", "join", "lstat", "mtime", "mkdir", "nativename", 
    	    "owned", "pathtype", "readable", "readlink", "rename",
    	    "rootname", "size", "split", "stat", "tail", "type", "volumes", 
    	    "writable", (char *) NULL};
d819 2
a820 3

    if (Tcl_GetIndexFromObj(interp, objv[1], fileOptions, "option", 0, &index)
	    != TCL_OK) {
a822 20
    
    result = TCL_OK;
    /* 
     * First, do the volumes command, since it is the only one that
     * has objc == 2.
     */
	
    if ( index == FILE_VOLUMES) {
        if ( objc != 2 ) {
	    Tcl_WrongNumArgs(interp, 1, objv, "volumes");
	    return TCL_ERROR;
	}
	result = TclpListVolumes(interp);
	return result;
    }
    
    if (objc < 3) {
	Tcl_WrongNumArgs(interp, 2, objv, "name ?arg ...?");
	return TCL_ERROR;
    }
a823 1
    Tcl_DStringInit(&buffer);
d825 5
a829 1
    
d831 42
a872 15
    /*
     * Handle operations on the file name.
     */
    
    switch (index) {
        case FILE_ATTRIBUTES:
            result = TclFileAttrsCmd(interp, objc - 2, objv + 2);
    	    goto done;
    	case FILE_DIRNAME:	{
    	    int pargc;
	    char **pargv;

	    if (objc != 3) {
	    	errorString = "dirname name";
	    	goto not3Args;
d874 6
d881 8
a888 1
	    fileName = Tcl_GetStringFromObj(objv[2], &length);
d890 8
a897 4
	    /*
	     * If there is only one element, and it starts with a tilde,
	     * perform tilde substitution and resplit the path.
	     */
d899 5
a903 10
	    Tcl_SplitPath(fileName, &pargc, &pargv);
	    if ((pargc == 1) && (*fileName == '~')) {
	        ckfree((char*) pargv);
	        fileName = Tcl_TranslateFileName(interp, fileName, &buffer);
	        if (fileName == NULL) {
		    result = TCL_ERROR;
		    goto done;
	        }
	        Tcl_SplitPath(fileName, &pargc, &pargv);
	        Tcl_DStringSetLength(&buffer, 0);
d912 12
a923 8
	    if (pargc > 1) {
	    	Tcl_JoinPath(pargc-1, pargv, &buffer);
	    	Tcl_SetStringObj(resultPtr, Tcl_DStringValue(&buffer),
	    		buffer.length);
	    } else if ((pargc == 0)
		    || (Tcl_GetPathType(pargv[0]) == TCL_PATH_RELATIVE)) {
		Tcl_SetStringObj(resultPtr, (tclPlatform == TCL_PLATFORM_MAC)
			? ":" : ".", 1);
d925 28
a952 3
	    	Tcl_SetStringObj(resultPtr, pargv[0], -1);	    }
	    ckfree((char *)pargv);
	    goto done;
d954 3
a956 3
    	case FILE_TAIL: {
	    int pargc;
	    char **pargv;
d959 1
a959 2
	    	errorString = "tail name";
	    	goto not3Args;
d961 10
d972 13
a984 1
	    fileName = Tcl_GetStringFromObj(objv[2], &length);
d986 16
a1001 4
	    /*
	     * If there is only one element, and it starts with a tilde,
	     * perform tilde substitution and resplit the path.
	     */
d1003 6
a1008 10
	    Tcl_SplitPath(fileName, &pargc, &pargv);
	    if ((pargc == 1) && (*fileName == '~')) {
	    	ckfree((char*) pargv);
	    	fileName = Tcl_TranslateFileName(interp, fileName, &buffer);
	    	if (fileName == NULL) {
		    result = TCL_ERROR;
		    goto done;
	        }
	        Tcl_SplitPath(fileName, &pargc, &pargv);
	        Tcl_DStringSetLength(&buffer, 0);
d1010 7
d1018 38
a1055 4
	    /*
	     * Return the last component, unless it is the only component,
	     * and it is the root of an absolute path.
	     */
d1057 8
a1064 8
	    if (pargc > 0) {
	    	if ((pargc > 1)
		    	|| (Tcl_GetPathType(pargv[0]) == TCL_PATH_RELATIVE)) {
		    Tcl_SetStringObj(resultPtr, pargv[pargc - 1], -1);
	    	}
	    }
	    ckfree((char *)pargv);
	    goto done;
d1066 1
a1066 1
	case FILE_ROOTNAME: {
d1068 2
a1069 1
	    
d1071 6
a1076 2
	    	errorString = "rootname name";
	    	goto not3Args;
d1078 7
d1086 2
a1087 7
	    fileName = Tcl_GetStringFromObj(objv[2], &length);
	    extension = TclGetExtension(fileName);
	    if (extension == NULL) {
	    	Tcl_SetObjResult(interp, objv[2]);
	    } else {
	        Tcl_SetStringObj(resultPtr, fileName,
			(int) (length - strlen(extension)));
d1089 15
a1103 1
	    goto done;
d1105 2
a1106 6
	case FILE_EXTENSION:
	    if (objc != 3) {
	    	errorString = "extension name";
	    	goto not3Args;
	    }
	    extension = TclGetExtension(Tcl_GetStringFromObj(objv[2],&length));
a1107 5
	    if (extension != NULL) {
	    	Tcl_SetStringObj(resultPtr, extension, (int)strlen(extension));
	    }
	    goto done;
	case FILE_PATHTYPE:
d1109 1
a1109 2
	    	errorString = "pathtype name";
	    	goto not3Args;
d1111 2
a1112 1
	    switch (Tcl_GetPathType(Tcl_GetStringFromObj(objv[2], &length))) {
d1123 3
a1125 6
	    goto done;
	case FILE_SPLIT: {
	    int pargc, i;
	    char **pargvList;
	    Tcl_Obj *listObjPtr;
		
d1127 1
a1127 2
    	    	errorString = "split name";
	    	goto not3Args;
d1129 5
d1135 2
a1136 6
	    Tcl_SplitPath(Tcl_GetStringFromObj(objv[2], &length), &pargc,
	    	    &pargvList);
	    listObjPtr = Tcl_NewListObj(0, (Tcl_Obj **) NULL);
	    for (i = 0; i < pargc; i++) {
	    	Tcl_ListObjAppendElement(interp, listObjPtr,
			Tcl_NewStringObj(pargvList[i], -1));
a1137 7
	    ckfree((char *) pargvList);
	    Tcl_SetObjResult(interp, listObjPtr);
	    goto done;
	}
	case FILE_JOIN: {
	    char **pargv = (char **) ckalloc((objc - 2) * sizeof(char *));
	    int i;
d1139 4
a1142 2
	    for (i = 2; i < objc; i++) {
	    	pargv[i - 2] = Tcl_GetStringFromObj(objv[i], &length);
d1144 25
a1168 6
	    Tcl_JoinPath(objc - 2, pargv, &buffer);
	    Tcl_SetStringObj(resultPtr, Tcl_DStringValue(&buffer), 
                    buffer.length);
	    ckfree((char *) pargv);
	    Tcl_DStringFree(&buffer);
	    goto done;
d1171 11
a1181 2
	    char **pargv = (char **) ckalloc(objc * sizeof(char *));
	    int i;
d1183 2
a1184 2
	    for (i = 0; i < objc; i++) {
	    	pargv[i] = Tcl_GetStringFromObj(objv[i], &length);
d1186 9
a1194 3
	    result = TclFileRenameCmd(interp, objc, pargv);
	    ckfree((char *) pargv);
	    goto done;
d1196 2
a1197 3
	case FILE_MKDIR: {
	    char **pargv = (char **) ckalloc(objc * sizeof(char *));
	    int i;
d1199 2
a1200 2
	    for (i = 0; i < objc; i++) {
	    	pargv[i] = Tcl_GetStringFromObj(objv[i], &length);
d1202 2
a1203 10
	    result = TclFileMakeDirsCmd(interp, objc, pargv);
	    ckfree((char *) pargv);
	    goto done;
	}
	case FILE_DELETE: {
	    char **pargv = (char **) ckalloc(objc * sizeof(char *));
	    int i;
	    
	    for (i = 0; i < objc; i++) {
	    	pargv[i] = Tcl_GetStringFromObj(objv[i], &length);
d1205 2
a1206 3
	    result = TclFileDeleteCmd(interp, objc, pargv);
	    ckfree((char *) pargv);
	    goto done;
d1208 5
a1212 3
	case FILE_COPY: {
	    char **pargv = (char **) ckalloc(objc * sizeof(char *));
	    int i;
a1213 46
	    for (i = 0; i < objc; i++) {
	    	pargv[i] = Tcl_GetStringFromObj(objv[i], &length);
	    }
	    result = TclFileCopyCmd(interp, objc, pargv);
	    ckfree((char *) pargv);
	    goto done;
	}
	case FILE_NATIVENAME:
	    fileName = Tcl_TranslateFileName(interp,
	    	    Tcl_GetStringFromObj(objv[2], &length), &buffer);
	    if (fileName == NULL) {
		result = TCL_ERROR ;
	    } else {
		Tcl_SetStringObj(resultPtr, fileName, -1);
	    }
	    goto done;
    }

    /*
     * Next, handle operations that can be satisfied with the "access"
     * kernel call.
     */

    fileName = Tcl_TranslateFileName(interp,
	    Tcl_GetStringFromObj(objv[2], &length), &buffer);
	
    switch (index) {
    	case FILE_READABLE:
    	    if (objc != 3) {
	    	errorString = "readable name";
	    	goto not3Args;
	    }
	    mode = R_OK;
checkAccess:
	    /*
	     * The result might have been set within Tcl_TranslateFileName
	     * (like no such user "blah" for file exists ~blah)
	     * but we don't want to flag an error in that case.
	     */
	    if (fileName == NULL) {
		Tcl_SetObjResult(interp, Tcl_NewBooleanObj(0));
	    } else {
		Tcl_SetBooleanObj(resultPtr, (TclAccess(fileName, mode) != -1));
	    }
	    goto done;
	  case FILE_WRITABLE:
d1215 1
a1215 2
	    	errorString = "writable name";
	    	goto not3Args;
d1217 16
a1232 6
	    mode = W_OK;
	    goto checkAccess;
	  case FILE_EXECUTABLE:
	    if (objc != 3) {
	    	errorString = "executable name";
	    	goto not3Args;
d1234 2
a1235 6
	    mode = X_OK;
	    goto checkAccess;
	  case FILE_EXISTS:
	    if (objc != 3) {
	    	errorString = "exists name";
	    	goto not3Args;
d1237 6
a1242 3
	    mode = F_OK;
	    goto checkAccess;
    }
a1243 54
	
    /*
     * Lastly, check stuff that requires the file to be stat-ed.
     */

    if (fileName == NULL) {
	result = TCL_ERROR;
	goto done;
    }
    
    switch (index) {
    	case FILE_ATIME:
    	    if (objc != 3) {
	    	errorString = "atime name";
	    	goto not3Args;
	    }
	    
	    if (TclStat(fileName, &statBuf) == -1) {
	    	goto badStat;
	    }
	    Tcl_SetLongObj(resultPtr, (long) statBuf.st_atime);
	    goto done;
    	case FILE_ISDIRECTORY:
    	    if (objc != 3) {
    	    	errorString = "isdirectory name";
    	    	goto not3Args;
    	    }
    	    statOp = 2;
    	    break;
    	case FILE_ISFILE:
    	    if (objc != 3) {
    	    	errorString = "isfile name";
    	    	goto not3Args;
    	    }
    	    statOp = 1;
    	    break;
    	case FILE_LSTAT:
    	    if (objc != 4) {
    	    	Tcl_WrongNumArgs(interp, 1, objv, "lstat name varName");
    	    	result = TCL_ERROR;
    	    	goto done;
    	    }
    	    
    	    if (lstat(fileName, &statBuf) == -1) {
    	    	Tcl_AppendStringsToObj(resultPtr, "couldn't lstat \"",
    	    		Tcl_GetStringFromObj(objv[2], &length), "\": ",
    	    		Tcl_PosixError(interp), (char *) NULL);
    	    	result = TCL_ERROR;
    	    	goto done;
    	    }
    	    result = StoreStatData(interp, Tcl_GetStringFromObj(objv[3],
    	    	    &length), &statBuf);
    	    goto done;
	case FILE_MTIME:
d1245 1
a1245 5
	    	errorString = "mtime name";
	    	goto not3Args;
	    }
	    if (TclStat(fileName, &statBuf) == -1) {
	    	goto badStat;
d1247 2
a1248 16
	    Tcl_SetLongObj(resultPtr, (long) statBuf.st_mtime);
	    goto done;
	case FILE_OWNED:
	    if (objc != 3) {
	    	errorString = "owned name";
	    	goto not3Args;
	    }	        	    
    	    statOp = 0;
    	    break;
	case FILE_READLINK: {
	    char linkValue[MAXPATHLEN + 1];
	    int linkLength;
		
	    if (objc != 3) {
	    	errorString = "readlink name";
	        goto not3Args;
d1252 2
a1253 5
	     * If S_IFLNK isn't defined it means that the machine doesn't
	     * support symbolic links, so the file can't possibly be a
	     * symbolic link.  Generate an EINVAL error, which is what
	     * happens on machines that do support symbolic links when
	     * you invoke readlink on a file that isn't a symbolic link.
d1256 5
a1260 12
#ifndef S_IFLNK
	    linkLength = -1;
	    errno = EINVAL;
#else
	    linkLength = readlink(fileName, linkValue, sizeof(linkValue) - 1);
#endif /* S_IFLNK */
	    if (linkLength == -1) {
	    	Tcl_AppendStringsToObj(resultPtr, "couldn't readlink \"", 
	    		Tcl_GetStringFromObj(objv[2], &length), "\": ", 
	    		Tcl_PosixError(interp), (char *) NULL);
	    	result = TCL_ERROR;
	    	goto done;
d1262 2
a1263 3
	    linkValue[linkLength] = 0;
	    Tcl_SetStringObj(resultPtr, linkValue, linkLength);
	    goto done;
d1265 3
a1267 1
	case FILE_SIZE:
d1269 1
a1269 2
	    	errorString = "size name";
	    	goto not3Args;
d1271 2
a1272 2
	    if (TclStat(fileName, &statBuf) == -1) {
	    	goto badStat;
d1274 8
a1281 7
	    Tcl_SetLongObj(resultPtr, (long) statBuf.st_size);
	    goto done;
	case FILE_STAT:
	    if (objc != 4) {
	    	Tcl_WrongNumArgs(interp, 1, objv, "stat name varName");
	    	result = TCL_ERROR;
	    	goto done;
d1283 3
a1285 13

	    if (TclStat(fileName, &statBuf) == -1) {
badStat:
		Tcl_AppendStringsToObj(resultPtr, "couldn't stat \"", 
			Tcl_GetStringFromObj(objv[2], &length),
		    	"\": ", Tcl_PosixError(interp), (char *) NULL);
	    	result = TCL_ERROR;
	    	goto done;
	    }
	    result = StoreStatData(interp, Tcl_GetStringFromObj(objv[3],
	    	    &length), &statBuf);
	    goto done;
	case FILE_TYPE:
d1287 1
a1287 2
	    	errorString = "type name";
	    	goto not3Args;
d1289 2
a1290 6
	    if (lstat(fileName, &statBuf) == -1) {
	    	goto badStat;
	    }
	    errorString = GetTypeFromMode((int) statBuf.st_mode);
	    Tcl_SetStringObj(resultPtr, errorString, -1);
	    goto done;
d1293 58
a1350 3
    if (TclStat(fileName, &statBuf) == -1) {
    	Tcl_SetBooleanObj(resultPtr, 0);
	goto done;
d1352 65
a1416 6
    switch (statOp) {
	case 0:
	    /*
	     * For Windows and Macintosh, there are no user ids 
	     * associated with a file, so we always return 1.
	     */
d1418 17
a1434 12
#if (defined(__WIN32__) || defined(MAC_TCL))
	    mode = 1;
#else
	    mode = (geteuid() == statBuf.st_uid);
#endif
	    break;
	case 1:
	    mode = S_ISREG(statBuf.st_mode);
	    break;
	case 2:
	    mode = S_ISDIR(statBuf.st_mode);
	    break;
a1435 1
    Tcl_SetBooleanObj(resultPtr, mode);
d1437 12
a1448 8
done:
    Tcl_DStringFree(&buffer);
    return result;

not3Args:
    Tcl_WrongNumArgs(interp, 1, objv, errorString);
    result = TCL_ERROR;
    goto done;
d1462 1
a1462 1
 *	a message is left in interp->result.
d1478 1
a1478 1
    char string[30];
d1480 1
a1480 1
    sprintf(string, "%ld", (long) statPtr->st_dev);
d1485 1
a1485 1
    sprintf(string, "%ld", (long) statPtr->st_ino);
d1490 1
a1490 1
    sprintf(string, "%ld", (long) statPtr->st_mode);
d1495 1
a1495 1
    sprintf(string, "%ld", (long) statPtr->st_nlink);
d1500 1
a1500 1
    sprintf(string, "%ld", (long) statPtr->st_uid);
d1505 1
a1505 1
    sprintf(string, "%ld", (long) statPtr->st_gid);
d1515 1
a1515 1
    sprintf(string, "%ld", (long) statPtr->st_atime);
d1520 1
a1520 1
    sprintf(string, "%ld", (long) statPtr->st_mtime);
d1525 1
a1525 1
    sprintf(string, "%ld", (long) statPtr->st_ctime);
d1531 2
a1532 2
	    GetTypeFromMode((int) statPtr->st_mode), TCL_LEAVE_ERR_MSG) 
            == NULL) {
d1584 1
a1584 1
 * Tcl_ForCmd --
d1605 1
a1605 1
Tcl_ForCmd(dummy, interp, argc, argv)
d1608 2
a1609 2
    int argc;                           /* Number of arguments. */
    char **argv;                        /* Argument strings. */
d1613 2
a1614 3
    if (argc != 5) {
        Tcl_AppendResult(interp, "wrong # args: should be \"", argv[0],
                " start test next command\"", (char *) NULL);
d1618 1
a1618 1
    result = Tcl_Eval(interp, argv[1]);
d1626 8
a1633 1
        result = Tcl_ExprBoolean(interp, argv[2], &value);
d1640 1
a1640 1
        result = Tcl_Eval(interp, argv[4]);
d1643 2
a1644 1
                char msg[60];
d1650 1
a1650 1
        result = Tcl_Eval(interp, argv[3]);
a1768 1
     * THIS FAILS IF THE OBJECT'S STRING REP HAS A NULL BYTE.
d1840 2
a1841 2
		varValuePtr = Tcl_ObjSetVar2(interp, varvList[i][v], NULL,
			valuePtr, TCL_PARSE_PART1);
d1849 1
a1849 2
			Tcl_GetStringFromObj(varvList[i][v], (int *) NULL),
			"\"", (char *) NULL);
d1857 1
a1857 1
	result = Tcl_EvalObj(interp, bodyPtr);
d1865 2
a1866 1
		char msg[100];
d1921 1
a1921 1
    register char *format;	/* Used to read characters from the format
d1924 1
a1924 1
    char *endPtr;               /* Points to the last char in format array */
d1944 4
a1947 2
#   define PTR_VALUE 1
#   define DOUBLE_VALUE 2
d1968 8
d1983 1
a1983 1
     * 2. there's no way to move the arguments from objv to the call
d1991 1
a1991 2
        Tcl_WrongNumArgs(interp, 1, objv,
		"formatString ?arg arg ...?");
d1995 1
a1995 1
    format = Tcl_GetStringFromObj(objv[1], &formatLen);
d2004 1
d2036 1
a2036 1
	if (isdigit(UCHAR(*format))) {
d2045 1
a2045 1
	    tmp = strtoul(format, &end, 10);
d2070 10
d2084 2
a2085 2
	if (isdigit(UCHAR(*format))) {
	    width = strtoul(format, &end, 10);
d2091 2
a2092 2
	    if (Tcl_GetIntFromObj(interp, objv[objIndex], 
                    &width) != TCL_OK) {
d2095 6
d2116 1
a2116 1
	    TclFormatInt(newPtr, width);
d2125 1
d2127 2
a2128 2
	if (isdigit(UCHAR(*format))) {
	    precision = strtoul(format, &end, 10);
d2134 2
a2135 2
	    if (Tcl_GetIntFromObj(interp, objv[objIndex], 
                    &precision) != TCL_OK) {
d2141 2
a2142 2
	if (precision != 0) {
	    TclFormatInt(newPtr, precision);
d2169 2
a2170 2
		if (Tcl_GetIntFromObj(interp, objv[objIndex], 
		        (int *) &intValue) != TCL_OK) {
d2177 8
d2186 8
d2196 2
a2197 2
		if (Tcl_GetIntFromObj(interp, objv[objIndex], 
                        (int *) &intValue) != TCL_OK) {
d2200 2
a2201 2
		whichValue = INT_VALUE;
		size = 1;
d2208 2
a2209 2
		if (Tcl_GetDoubleFromObj(interp, objv[objIndex], 
			&doubleValue) != TCL_OK) {
d2223 6
a2228 7
	    default:
		{
		    char buf[40];
		    sprintf(buf, "bad field specifier \"%c\"", *format);
		    Tcl_SetResult(interp, buf, TCL_VOLATILE);
		    goto fmtError;
		}
d2252 47
d2300 15
a2314 7
	    if (whichValue == DOUBLE_VALUE) {
	        sprintf(dst, newFormat, doubleValue);
	    } else if (whichValue == INT_VALUE) {
		if (useShort) {
		    sprintf(dst, newFormat, (short) intValue);
		} else {
		    sprintf(dst, newFormat, intValue);
a2315 2
	    } else {
	        sprintf(dst, newFormat, ptrValue);
d2347 40
@


1.1.1.1
log
@import dejagnu-1999-11-08 snapshot
@
text
@@


1.1.1.2
log
@Tcl 8.3 upgrade
@
text
@d14 1
a14 1
 * RCS: @@(#) $Id: tclCmdAH.c,v 1.7.8.1 2000/04/06 22:38:28 spolk Exp $
a18 3
#include <locale.h>

typedef int (StatProc)_ANSI_ARGS_((CONST char *path, struct stat *buf));
a23 5
static int		CheckAccess _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_Obj *objPtr, int mode));
static int		GetStatBuf _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_Obj *objPtr, StatProc *statProc,
			    struct stat *statPtr));
a24 2
static int		SplitPath _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_Obj *objPtr, int *argcPtr, char ***argvPtr));
a26 2
static char **		StringifyObjects _ANSI_ARGS_((int objc,
			    Tcl_Obj *CONST objv[]));
d31 1
a31 1
 * Tcl_BreakObjCmd --
d51 1
a51 1
Tcl_BreakObjCmd(dummy, interp, objc, objv)
d54 2
a55 2
    int objc;				/* Number of arguments. */
    Tcl_Obj *CONST objv[];		/* Argument objects. */
d57 3
a59 2
    if (objc != 1) {
	Tcl_WrongNumArgs(interp, 1, objv, NULL);
d93 1
a93 1
    int caseObjc;
d103 5
a107 1
    string = Tcl_GetString(objv[1]);
d110 1
a110 1
    arg = Tcl_GetString(objv[2]);
d122 1
d136 1
a136 1
	unsigned char *p;
d138 1
a138 1
	if (i == (caseObjc - 1)) {
d150 3
a152 3
	pat = Tcl_GetString(caseObjv[i]);
	for (p = (unsigned char *) pat; *p != '\0'; p++) {
	    if (isspace(*p) || (*p == '\\')) {	/* INTL: ISO space, UCHAR */
d156 1
a156 1
	if (*p == '\0') {
d158 1
a158 1
		body = i + 1;
d161 1
a161 1
		body = i + 1;
d179 1
a179 1
		body = i + 1;
d191 2
a192 2
	armPtr = caseObjv[body - 1];
	result = Tcl_EvalObjEx(interp, caseObjv[body], 0);
d194 1
a194 1
	    char msg[100 + TCL_INTEGER_SPACE];
d196 2
a197 3
	    arg = Tcl_GetString(armPtr);
	    sprintf(msg,
		    "\n    (\"%.50s\" arm line %d)", arg,
d253 2
a254 2

    result = Tcl_EvalObjEx(interp, objv[1], 0);
d258 1
a258 1
		Tcl_GetObjResult(interp), 0) == NULL) {
d304 2
a305 1
    Tcl_DString ds;
d309 1
a309 1
	Tcl_WrongNumArgs(interp, 1, objv, "?dirName?");
d314 1
a314 1
	dirName = Tcl_GetString(objv[1]);
d318 2
a319 1
    if (Tcl_TranslateFileName(interp, dirName, &ds) == NULL) {
d322 3
a324 10

    result = Tcl_Chdir(Tcl_DStringValue(&ds));
    Tcl_DStringFree(&ds);

    if (result != 0) {
	Tcl_AppendResult(interp, "couldn't change working directory to \"",
		dirName, "\": ", Tcl_PosixError(interp), (char *) NULL);
	return TCL_ERROR;
    }
    return TCL_OK;
d333 1
a333 1
 *	command. See the user documentation for details on what it does.
d361 1
a361 1
 * Tcl_ContinueObjCmd -
d381 1
a381 1
Tcl_ContinueObjCmd(dummy, interp, objc, objv)
d384 2
a385 2
    int objc;				/* Number of arguments. */
    Tcl_Obj *CONST objv[];		/* Argument objects. */
d387 3
a389 2
    if (objc != 1) {
	Tcl_WrongNumArgs(interp, 1, objv, NULL);
a397 125
 * Tcl_EncodingObjCmd --
 *
 *	This command manipulates encodings.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_EncodingObjCmd(dummy, interp, objc, objv)
    ClientData dummy;		/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    int index, length;
    Tcl_Encoding encoding;
    char *string;
    Tcl_DString ds;
    Tcl_Obj *resultPtr;

    static char *optionStrings[] = {
	"convertfrom", "convertto", "names", "system",
	NULL
    };
    enum options {
	ENC_CONVERTFROM, ENC_CONVERTTO, ENC_NAMES, ENC_SYSTEM
    };

    if (objc < 2) {
    	Tcl_WrongNumArgs(interp, 1, objv, "option ?arg ...?");
        return TCL_ERROR;
    }
    if (Tcl_GetIndexFromObj(interp, objv[1], optionStrings, "option", 0,
	    &index) != TCL_OK) {
	return TCL_ERROR;
    }

    switch ((enum options) index) {
	case ENC_CONVERTTO:
	case ENC_CONVERTFROM: {
	    char *name;
	    Tcl_Obj *data;
	    if (objc == 3) {
		name = NULL;
		data = objv[2];
	    } else if (objc == 4) {
		name = Tcl_GetString(objv[2]);
		data = objv[3];
	    } else {
		Tcl_WrongNumArgs(interp, 2, objv, "?encoding? data");
		return TCL_ERROR;
	    }
	    
	    encoding = Tcl_GetEncoding(interp, name);
	    if (!encoding) {
		return TCL_ERROR;
	    }

	    if ((enum options) index == ENC_CONVERTFROM) {
		/*
		 * Treat the string as binary data.
		 */

		string = (char *) Tcl_GetByteArrayFromObj(data, &length);
		Tcl_ExternalToUtfDString(encoding, string, length, &ds);

		/*
		 * Note that we cannot use Tcl_DStringResult here because
		 * it will truncate the string at the first null byte.
		 */

		Tcl_SetStringObj(Tcl_GetObjResult(interp),
			Tcl_DStringValue(&ds), Tcl_DStringLength(&ds));
		Tcl_DStringFree(&ds);
	    } else {
		/*
		 * Store the result as binary data.
		 */

		string = Tcl_GetStringFromObj(data, &length);
		Tcl_UtfToExternalDString(encoding, string, length, &ds);
		resultPtr = Tcl_GetObjResult(interp);
		Tcl_SetByteArrayObj(resultPtr, 
			(unsigned char *) Tcl_DStringValue(&ds),
			Tcl_DStringLength(&ds));
		Tcl_DStringFree(&ds);
	    }

	    Tcl_FreeEncoding(encoding);
	    break;
	}
	case ENC_NAMES: {
	    if (objc > 2) {
		Tcl_WrongNumArgs(interp, 2, objv, NULL);
		return TCL_ERROR;
	    }
	    Tcl_GetEncodingNames(interp);
	    break;
	}
	case ENC_SYSTEM: {
	    if (objc > 3) {
		Tcl_WrongNumArgs(interp, 2, objv, "?encoding?");
		return TCL_ERROR;
	    }
	    if (objc == 2) {
	        Tcl_SetResult(interp, Tcl_GetEncodingName(NULL), TCL_STATIC);
	    } else {
	        return Tcl_SetSystemEncoding(interp,
			Tcl_GetStringFromObj(objv[2], NULL));
	    }
	    break;
	}
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
d421 1
d439 3
a441 1
	Tcl_SetVar2Ex(interp, "errorCode", NULL, objv[3], TCL_GLOBAL_ONLY);
d443 1
d484 1
a484 1
	result = Tcl_EvalObjEx(interp, objv[1], TCL_EVAL_DIRECT);
d488 1
a488 2
	 * between, then evaluate the result.  Tcl_EvalObjEx will delete
	 * the object when it decrements its refcount after eval'ing it.
d490 4
a493 2
    	objPtr = Tcl_ConcatObj(objc-1, objv+1);
	result = Tcl_EvalObjEx(interp, objPtr, TCL_EVAL_DIRECT);
d496 1
a496 2
	char msg[32 + TCL_INTEGER_SPACE];

d576 1
a576 1
{	 
d598 1
d655 7
d663 1
a663 1
    int index;
d669 14
a682 21
    static char *fileOptions[] = {
	"atime",	"attributes",	"channels",	"copy",
	"delete",
	"dirname",	"executable",	"exists",	"extension",
	"isdirectory",	"isfile",	"join",		"lstat",
	"mtime",	"mkdir",	"nativename",	"owned",
	"pathtype",	"readable",	"readlink",	"rename",
	"rootname",	"size",		"split",	"stat",
	"tail",		"type",		"volumes",	"writable",
	(char *) NULL
    };
    enum options {
	FILE_ATIME,	FILE_ATTRIBUTES, FILE_CHANNELS,	FILE_COPY,
	FILE_DELETE,
	FILE_DIRNAME,	FILE_EXECUTABLE, FILE_EXISTS,	FILE_EXTENSION,
	FILE_ISDIRECTORY, FILE_ISFILE,	FILE_JOIN,	FILE_LSTAT,
	FILE_MTIME,	FILE_MKDIR,	FILE_NATIVENAME, FILE_OWNED,
	FILE_PATHTYPE,	FILE_READABLE,	FILE_READLINK,	FILE_RENAME,
	FILE_ROOTNAME,	FILE_SIZE,	FILE_SPLIT,	FILE_STAT,
	FILE_TAIL,	FILE_TYPE,	FILE_VOLUMES,	FILE_WRITABLE
    };
d688 3
a690 2
    if (Tcl_GetIndexFromObj(interp, objv[1], fileOptions, "option", 0,
	    &index) != TCL_OK) {
d693 20
d714 1
d716 13
a728 5
    switch ((enum options) index) {
    	case FILE_ATIME: {
	    struct stat buf;
	    char *fileName;
	    struct utimbuf tval;
d730 3
a732 31
	    if ((objc < 3) || (objc > 4)) {
		Tcl_WrongNumArgs(interp, 2, objv, "name ?time?");
		return TCL_ERROR;
	    }
	    if (GetStatBuf(interp, objv[2], TclStat, &buf) != TCL_OK) {
		return TCL_ERROR;
	    }
	    if (objc == 4) {
		if (Tcl_GetLongFromObj(interp, objv[3],
			(long*)(&buf.st_atime)) != TCL_OK) {
		    return TCL_ERROR;
		}
		tval.actime = buf.st_atime;
		tval.modtime = buf.st_mtime;
		fileName = Tcl_GetString(objv[2]);
		if (utime(fileName, &tval) != 0) {
		    Tcl_AppendStringsToObj(resultPtr,
			    "could not set access time for file \"",
			    fileName, "\": ",
			    Tcl_PosixError(interp), (char *) NULL);
		    return TCL_ERROR;
		}
		/*
		 * Do another stat to ensure that the we return the
		 * new recognized atime - hopefully the same as the
		 * one we sent in.  However, fs's like FAT don't
		 * even know what atime is.
		 */
		if (GetStatBuf(interp, objv[2], TclStat, &buf) != TCL_OK) {
		    return TCL_ERROR;
		}
a733 17
	    Tcl_SetLongObj(resultPtr, (long) buf.st_atime);
	    return TCL_OK;
	}
	case FILE_ATTRIBUTES: {
            return TclFileAttrsCmd(interp, objc, objv);
	}
	case FILE_CHANNELS: {
	    if ((objc < 2) || (objc > 3)) {
		Tcl_WrongNumArgs(interp, 2, objv, "?pattern?");
		return TCL_ERROR;
	    }
	    return Tcl_GetChannelNamesEx(interp,
		    ((objc == 2) ? NULL : Tcl_GetString(objv[2])));
	}
	case FILE_COPY: {
	    int result;
	    char **argv;
d735 1
a735 8
	    argv = StringifyObjects(objc, objv);
	    result = TclFileCopyCmd(interp, objc, argv);
	    ckfree((char *) argv);
	    return result;
	}	    
	case FILE_DELETE: {
	    int result;
	    char **argv;
d737 4
a740 8
	    argv = StringifyObjects(objc, objv);
	    result = TclFileDeleteCmd(interp, objc, argv);
	    ckfree((char *) argv);
	    return result;
	}
    	case FILE_DIRNAME: {
    	    int argc;
	    char **argv;
d742 10
a751 5
	    if (objc != 3) {
		goto only3Args;
	    }
	    if (SplitPath(interp, objv[2], &argc, &argv) != TCL_OK) {
		return TCL_ERROR;
d760 8
a767 12
	    if (argc > 1) {
		Tcl_DString ds;

		Tcl_DStringInit(&ds);
	    	Tcl_JoinPath(argc - 1, argv, &ds);
	    	Tcl_SetStringObj(resultPtr, Tcl_DStringValue(&ds),
			Tcl_DStringLength(&ds));
		Tcl_DStringFree(&ds);
	    } else if ((argc == 0)
		    || (Tcl_GetPathType(argv[0]) == TCL_PATH_RELATIVE)) {
		Tcl_SetStringObj(resultPtr,
			((tclPlatform == TCL_PLATFORM_MAC) ? ":" : "."), 1);
d769 3
a771 4
	    	Tcl_SetStringObj(resultPtr, argv[0], -1);
	    }
	    ckfree((char *) argv);
	    return TCL_OK;
d773 3
a775 27
	case FILE_EXECUTABLE: {
	    if (objc != 3) {
		goto only3Args;
	    }
	    return CheckAccess(interp, objv[2], X_OK);
	}
	case FILE_EXISTS: {
	    if (objc != 3) {
		goto only3Args;
	    }
	    return CheckAccess(interp, objv[2], F_OK);
	}
	case FILE_EXTENSION: {
	    char *fileName, *extension;
	    if (objc != 3) {
	    	goto only3Args;
	    }
	    fileName = Tcl_GetString(objv[2]);
	    extension = TclGetExtension(fileName);
	    if (extension != NULL) {
	    	Tcl_SetStringObj(resultPtr, extension, -1);
	    }
	    return TCL_OK;
	}
    	case FILE_ISDIRECTORY: {
	    int value;
	    struct stat buf;
d778 2
a779 1
		goto only3Args;
a780 10
	    value = 0;
	    if (GetStatBuf(NULL, objv[2], TclStat, &buf) == TCL_OK) {
		value = S_ISDIR(buf.st_mode);
	    }
	    Tcl_SetBooleanObj(resultPtr, value);
	    return TCL_OK;
	}
    	case FILE_ISFILE: {
	    int value;
	    struct stat buf;
d782 1
a782 13
    	    if (objc != 3) {
    	    	goto only3Args;
    	    }
	    value = 0;
	    if (GetStatBuf(NULL, objv[2], TclStat, &buf) == TCL_OK) {
		value = S_ISREG(buf.st_mode);
	    }
	    Tcl_SetBooleanObj(resultPtr, value);
	    return TCL_OK;
	}
	case FILE_JOIN: {
	    char **argv;
	    Tcl_DString ds;
d784 4
a787 16
	    if (objc < 3) {
		Tcl_WrongNumArgs(interp, 2, objv, "name ?name ...?");
		return TCL_ERROR;
	    }
	    argv = StringifyObjects(objc - 2, objv + 2);
	    Tcl_DStringInit(&ds);
	    Tcl_JoinPath(objc - 2, argv, &ds);
	    Tcl_SetStringObj(resultPtr, Tcl_DStringValue(&ds),
		    Tcl_DStringLength(&ds));
	    Tcl_DStringFree(&ds);
	    ckfree((char *) argv);
	    return TCL_OK;
	}
    	case FILE_LSTAT: {
	    char *varName;
	    struct stat buf;
d789 10
a798 6
    	    if (objc != 4) {
    	    	Tcl_WrongNumArgs(interp, 2, objv, "name varName");
    	    	return TCL_ERROR;
    	    }
	    if (GetStatBuf(interp, objv[2], TclpLstat, &buf) != TCL_OK) {
		return TCL_ERROR;
a799 7
	    varName = Tcl_GetString(objv[3]);
	    return StoreStatData(interp, varName, &buf);
	}
	case FILE_MTIME: {
	    struct stat buf;
	    char *fileName;
	    struct utimbuf tval;
d801 10
a810 31
	    if ((objc < 3) || (objc > 4)) {
		Tcl_WrongNumArgs(interp, 2, objv, "name ?time?");
		return TCL_ERROR;
	    }
	    if (GetStatBuf(interp, objv[2], TclStat, &buf) != TCL_OK) {
		return TCL_ERROR;
	    }
	    if (objc == 4) {
		if (Tcl_GetLongFromObj(interp, objv[3],
			(long*)(&buf.st_mtime)) != TCL_OK) {
		    return TCL_ERROR;
		}
		tval.actime = buf.st_atime;
		tval.modtime = buf.st_mtime;
		fileName = Tcl_GetString(objv[2]);
		if (utime(fileName, &tval) != 0) {
		    Tcl_AppendStringsToObj(resultPtr,
			    "could not set modification time for file \"",
			    fileName, "\": ",
			    Tcl_PosixError(interp), (char *) NULL);
		    return TCL_ERROR;
		}
		/*
		 * Do another stat to ensure that the we return the
		 * new recognized atime - hopefully the same as the
		 * one we sent in.  However, fs's like FAT don't
		 * even know what atime is.
		 */
		if (GetStatBuf(interp, objv[2], TclStat, &buf) != TCL_OK) {
		    return TCL_ERROR;
		}
d812 2
a813 2
	    Tcl_SetLongObj(resultPtr, (long) buf.st_mtime);
	    return TCL_OK;
d815 1
a815 14
	case FILE_MKDIR: {
	    char **argv;
	    int result;

	    if (objc < 3) {
		Tcl_WrongNumArgs(interp, 2, objv, "name ?name ...?");
		return TCL_ERROR;
	    }
	    argv = StringifyObjects(objc, objv);
	    result = TclFileMakeDirsCmd(interp, objc, argv);
	    ckfree((char *) argv);
	    return result;
	}
	case FILE_NATIVENAME: {
d817 1
a817 2
	    Tcl_DString ds;

d819 2
a820 1
		goto only3Args;
d822 8
a829 4
	    fileName = Tcl_GetString(objv[2]);
	    fileName = Tcl_TranslateFileName(interp, fileName, &ds);
	    if (fileName == NULL) {
		return TCL_ERROR;
d831 3
a833 8
	    Tcl_SetStringObj(resultPtr, fileName, Tcl_DStringLength(&ds));
	    Tcl_DStringFree(&ds);
	    return TCL_OK;
	}
	case FILE_OWNED: {
	    int value;
	    struct stat buf;
	    
d835 2
a836 1
		goto only3Args;
d838 1
a838 18
	    value = 0;
	    if (GetStatBuf(NULL, objv[2], TclStat, &buf) == TCL_OK) {
		/*
		 * For Windows and Macintosh, there are no user ids 
		 * associated with a file, so we always return 1.
		 */

#if (defined(__WIN32__) || defined(MAC_TCL))
		value = 1;
#else
		value = (geteuid() == buf.st_uid);
#endif
	    }	    
	    Tcl_SetBooleanObj(resultPtr, value);
	    return TCL_OK;
	}
	case FILE_PATHTYPE: {
	    char *fileName;
d840 5
d846 2
a847 1
		goto only3Args;
d849 1
a849 2
	    fileName = Tcl_GetString(objv[2]);
	    switch (Tcl_GetPathType(fileName)) {
d860 6
a865 3
	    return TCL_OK;
	}
    	case FILE_READABLE: {
d867 2
a868 1
		goto only3Args;
a869 5
	    return CheckAccess(interp, objv[2], R_OK);
	}
	case FILE_READLINK: {
	    char *fileName, *contents;
	    Tcl_DString name, link;
d871 6
a876 2
	    if (objc != 3) {
		goto only3Args;
d878 7
d886 2
a887 4
	    fileName = Tcl_GetString(objv[2]);
	    fileName = Tcl_TranslateFileName(interp, fileName, &name);
	    if (fileName == NULL) {
		return TCL_ERROR;
d889 6
a894 25

	    /*
	     * If S_IFLNK isn't defined it means that the machine doesn't
	     * support symbolic links, so the file can't possibly be a
	     * symbolic link.  Generate an EINVAL error, which is what
	     * happens on machines that do support symbolic links when
	     * you invoke readlink on a file that isn't a symbolic link.
	     */

#ifndef S_IFLNK
	    contents = NULL;
	    errno = EINVAL;
#else
	    contents = TclpReadlink(fileName, &link);
#endif /* S_IFLNK */

	    Tcl_DStringFree(&name);
	    if (contents == NULL) {
	    	Tcl_AppendResult(interp, "could not readlink \"", 
	    		Tcl_GetString(objv[2]), "\": ", 
	    		Tcl_PosixError(interp), (char *) NULL);
	    	return TCL_ERROR;
	    }
	    Tcl_DStringResult(interp, &link);
	    return TCL_OK;
d897 9
a905 7
	    int result;
	    char **argv;

	    argv = StringifyObjects(objc, objv);
	    result = TclFileRenameCmd(interp, objc, argv);
	    ckfree((char *) argv);
	    return result;
d907 3
a909 3
	case FILE_ROOTNAME: {
	    int length;
	    char *fileName, *extension;
d911 2
a912 2
	    if (objc != 3) {
		goto only3Args;
d914 10
a923 7
	    fileName = Tcl_GetStringFromObj(objv[2], &length);
	    extension = TclGetExtension(fileName);
	    if (extension == NULL) {
	    	Tcl_SetObjResult(interp, objv[2]);
	    } else {
	        Tcl_SetStringObj(resultPtr, fileName,
			(int) (length - strlen(extension)));
d925 3
a927 1
	    return TCL_OK;
d929 3
a931 2
	case FILE_SIZE: {
	    struct stat buf;
d933 46
d980 2
a981 1
		goto only3Args;
d983 6
a988 2
	    if (GetStatBuf(interp, objv[2], TclStat, &buf) != TCL_OK) {
		return TCL_ERROR;
d990 3
a992 9
	    Tcl_SetLongObj(resultPtr, (long) buf.st_size);
	    return TCL_OK;
	}
	case FILE_SPLIT: {
	    int i, argc;
	    char **argv;
	    char *fileName;
	    Tcl_Obj *objPtr;
	    
d994 22
a1015 1
		goto only3Args;
a1016 12
	    fileName = Tcl_GetString(objv[2]);
	    Tcl_SplitPath(fileName, &argc, &argv);
	    for (i = 0; i < argc; i++) {
		objPtr = Tcl_NewStringObj(argv[i], -1);
		Tcl_ListObjAppendElement(NULL, resultPtr, objPtr);
	    }
	    ckfree((char *) argv);
	    return TCL_OK;
	}
	case FILE_STAT: {
	    char *varName;
	    struct stat buf;
d1018 40
a1057 3
	    if (objc != 4) {
	    	Tcl_WrongNumArgs(interp, 1, objv, "stat name varName");
		return TCL_ERROR;
d1059 2
a1060 2
	    if (GetStatBuf(interp, objv[2], TclStat, &buf) != TCL_OK) {
		return TCL_ERROR;
d1062 13
a1074 7
	    varName = Tcl_GetString(objv[3]);
	    return StoreStatData(interp, varName, &buf);
	}
    	case FILE_TAIL: {
	    int argc;
	    char **argv;

d1076 2
a1077 4
		goto only3Args;
	    }
	    if (SplitPath(interp, objv[2], &argc, &argv) != TCL_OK) {
		return TCL_ERROR;
d1081 5
a1085 2
	     * Return the last component, unless it is the only component,
	     * and it is the root of an absolute path.
d1088 12
a1099 5
	    if (argc > 0) {
	    	if ((argc > 1)
		    	|| (Tcl_GetPathType(argv[0]) == TCL_PATH_RELATIVE)) {
		    Tcl_SetStringObj(resultPtr, argv[argc - 1], -1);
	    	}
d1101 3
a1103 2
	    ckfree((char *) argv);
	    return TCL_OK;
d1105 1
a1105 3
	case FILE_TYPE: {
	    struct stat buf;

d1107 5
a1111 1
	    	goto only3Args;
d1113 7
a1119 2
	    if (GetStatBuf(interp, objv[2], TclpLstat, &buf) != TCL_OK) {
		return TCL_ERROR;
d1121 8
a1128 8
	    Tcl_SetStringObj(resultPtr, 
		    GetTypeFromMode((unsigned short) buf.st_mode), -1);
	    return TCL_OK;
	}
	case FILE_VOLUMES: {
	    if (objc != 2) {
		Tcl_WrongNumArgs(interp, 2, objv, NULL);
		return TCL_ERROR;
d1130 4
a1133 3
	    return TclpListVolumes(interp);
	}
	case FILE_WRITABLE: {
d1135 2
a1136 1
	    	goto only3Args;
d1138 6
a1143 2
	    return CheckAccess(interp, objv[2], W_OK);
	}
d1146 10
a1155 29
    only3Args:
    Tcl_WrongNumArgs(interp, 2, objv, "name");
    return TCL_ERROR;
}

/*
 *---------------------------------------------------------------------------
 *
 * SplitPath --
 *
 *	Utility procedure used by Tcl_FileObjCmd() to split a path.
 *	Differs from standard Tcl_SplitPath in its handling of home
 *	directories; Tcl_SplitPath preserves the "~" while this
 *	procedure computes the actual full path name.
 *
 * Results:
 *	The return value is TCL_OK if the path could be split, TCL_ERROR
 *	otherwise.  If TCL_ERROR was returned, an error message is left
 *	in interp.  If TCL_OK was returned, *argvPtr is set to a newly
 *	allocated array of strings that represent the individual
 *	directories in the specified path, and *argcPtr is filled with
 *	the length of that array.
 *
 * Side effects:
 *	Memory allocated.  The caller must eventually free this memory
 *	by calling ckfree() on *argvPtr.
 *
 *---------------------------------------------------------------------------
 */
d1157 12
a1168 69
static int
SplitPath(interp, objPtr, argcPtr, argvPtr)
    Tcl_Interp *interp;		/* Interp for error return.  May be NULL. */
    Tcl_Obj *objPtr;		/* Path to be split. */
    int *argcPtr;		/* Filled with length of following array. */
    char ***argvPtr;		/* Filled with array of strings representing
				 * the elements of the specified path. */
{
    char *fileName;

    fileName = Tcl_GetString(objPtr);

    /*
     * If there is only one element, and it starts with a tilde,
     * perform tilde substitution and resplit the path.
     */

    Tcl_SplitPath(fileName, argcPtr, argvPtr);
    if ((*argcPtr == 1) && (fileName[0] == '~')) {
	Tcl_DString ds;
	
	ckfree((char *) *argvPtr);
	fileName = Tcl_TranslateFileName(interp, fileName, &ds);
	if (fileName == NULL) {
	    return TCL_ERROR;
	}
	Tcl_SplitPath(fileName, argcPtr, argvPtr);
	Tcl_DStringFree(&ds);
    }
    return TCL_OK;
}

/*
 *---------------------------------------------------------------------------
 *
 * CheckAccess --
 *
 *	Utility procedure used by Tcl_FileObjCmd() to query file
 *	attributes available through the access() system call.
 *
 * Results:
 *	Always returns TCL_OK.  Sets interp's result to boolean true or
 *	false depending on whether the file has the specified attribute.
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
 */
  
static int
CheckAccess(interp, objPtr, mode)
    Tcl_Interp *interp;		/* Interp for status return.  Must not be
				 * NULL. */
    Tcl_Obj *objPtr;		/* Name of file to check. */
    int mode;			/* Attribute to check; passed as argument to
				 * access(). */
{
    int value;
    char *fileName;
    Tcl_DString ds;
    
    fileName = Tcl_GetString(objPtr);
    fileName = Tcl_TranslateFileName(interp, fileName, &ds);
    if (fileName == NULL) {
	value = 0;
    } else {
	value = (TclAccess(fileName, mode) == 0);
        Tcl_DStringFree(&ds);
d1170 1
a1170 1
    Tcl_SetBooleanObj(Tcl_GetObjResult(interp), value);
d1172 3
a1174 22
    return TCL_OK;
}

/*
 *---------------------------------------------------------------------------
 *
 * GetStatBuf --
 *
 *	Utility procedure used by Tcl_FileObjCmd() to query file
 *	attributes available through the stat() or lstat() system call.
 *
 * Results:
 *	The return value is TCL_OK if the specified file exists and can
 *	be stat'ed, TCL_ERROR otherwise.  If TCL_ERROR is returned, an
 *	error message is left in interp's result.  If TCL_OK is returned,
 *	*statPtr is filled with information about the specified file.
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
 */
d1176 4
a1179 31
static int
GetStatBuf(interp, objPtr, statProc, statPtr)
    Tcl_Interp *interp;		/* Interp for error return.  May be NULL. */
    Tcl_Obj *objPtr;		/* Path name to examine. */
    StatProc *statProc;		/* Either stat() or lstat() depending on
				 * desired behavior. */
    struct stat *statPtr;	/* Filled with info about file obtained by
				 * calling (*statProc)(). */
{
    char *fileName;
    Tcl_DString ds;
    int status;
    
    fileName = Tcl_GetString(objPtr);
    fileName = Tcl_TranslateFileName(interp, fileName, &ds);
    if (fileName == NULL) {
	return TCL_ERROR;
    }

    status = (*statProc)(Tcl_DStringValue(&ds), statPtr);
    Tcl_DStringFree(&ds);
    
    if (status < 0) {
	if (interp != NULL) {
	    Tcl_AppendResult(interp, "could not read \"",
		    Tcl_GetString(objPtr), "\": ",
		    Tcl_PosixError(interp), (char *) NULL);
	}
	return TCL_ERROR;
    }
    return TCL_OK;
d1193 1
a1193 1
 *	a message is left in interp's result.
d1209 1
a1209 1
    char string[TCL_INTEGER_SPACE];
d1211 1
a1211 1
    TclFormatInt(string, (long) statPtr->st_dev);
d1216 1
a1216 1
    TclFormatInt(string, (long) statPtr->st_ino);
d1221 1
a1221 1
    TclFormatInt(string, (unsigned short) statPtr->st_mode);
d1226 1
a1226 1
    TclFormatInt(string, (long) statPtr->st_nlink);
d1231 1
a1231 1
    TclFormatInt(string, (long) statPtr->st_uid);
d1236 1
a1236 1
    TclFormatInt(string, (long) statPtr->st_gid);
d1246 1
a1246 1
    TclFormatInt(string, (long) statPtr->st_atime);
d1251 1
a1251 1
    TclFormatInt(string, (long) statPtr->st_mtime);
d1256 1
a1256 1
    TclFormatInt(string, (long) statPtr->st_ctime);
d1262 2
a1263 2
	    GetTypeFromMode((unsigned short) statPtr->st_mode), 
	    TCL_LEAVE_ERR_MSG) == NULL) {
d1315 1
a1315 1
 * Tcl_ForObjCmd --
d1336 1
a1336 1
Tcl_ForObjCmd(dummy, interp, objc, objv)
d1339 2
a1340 2
    int objc;                           /* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
d1344 3
a1346 2
    if (objc != 5) {
        Tcl_WrongNumArgs(interp, 1, objv, "start test next command");
d1350 1
a1350 1
    result = Tcl_EvalObjEx(interp, objv[1], 0);
d1358 1
a1358 8
	/*
	 * We need to reset the result before passing it off to
	 * Tcl_ExprBooleanObj.  Otherwise, any error message will be appended
	 * to the result of the last evaluation.
	 */

	Tcl_ResetResult(interp);
        result = Tcl_ExprBooleanObj(interp, objv[2], &value);
d1365 1
a1365 1
        result = Tcl_EvalObjEx(interp, objv[4], 0);
d1368 1
a1368 2
                char msg[32 + TCL_INTEGER_SPACE];

d1374 1
a1374 1
        result = Tcl_EvalObjEx(interp, objv[3], 0);
d1493 1
d1565 2
a1566 2
		varValuePtr = Tcl_ObjSetVar2(interp, varvList[i][v],
			NULL, valuePtr, 0);
d1574 2
a1575 1
			Tcl_GetString(varvList[i][v]), "\"", (char *) NULL);
d1583 1
a1583 1
	result = Tcl_EvalObjEx(interp, bodyPtr, 0);
d1591 1
a1591 2
                char msg[32 + TCL_INTEGER_SPACE];

d1646 1
a1646 1
    char *format;		/* Used to read characters from the format
d1649 1
a1649 1
    char *endPtr;		/* Points to the last char in format array */
d1669 2
a1670 4
#   define CHAR_VALUE 1
#   define PTR_VALUE 2
#   define DOUBLE_VALUE 3
#   define STRING_VALUE 4
a1690 8
    int stringLen = 0;		/* Length of string in characters rather
				 * than bytes.  Used for %s substitution. */
    int gotMinus;		/* Non-zero indicates that a minus flag has
				 * been seen in the current field. */
    int gotPrecision;		/* Non-zero indicates that a precision has
				 * been set for the current field. */
    int gotZero;		/* Non-zero indicates that a zero flag has
				 * been seen in the current field. */
d1698 1
a1698 1
     * 3. there's no way to move the arguments from objv to the call
d1706 2
a1707 1
        Tcl_WrongNumArgs(interp, 1, objv, "formatString ?arg arg ...?");
d1711 1
a1711 1
    format = (char *) Tcl_GetStringFromObj(objv[1], &formatLen);
a1719 1
	gotZero = gotMinus = gotPrecision = 0;
d1751 1
a1751 1
	if (isdigit(UCHAR(*format))) { /* INTL: Tcl source. */
d1760 1
a1760 1
	    tmp = strtoul(format, &end, 10);	/* INTL: "C" locale. */
a1784 10
	    if (*format == '-') {
		gotMinus = 1;
	    }
	    if (*format == '0') {
		/*
		 * This will be handled by sprintf for numbers, but we
		 * need to do the char/string ones ourselves
		 */
		gotZero = 1;
	    }
d1789 2
a1790 2
	if (isdigit(UCHAR(*format))) { /* INTL: Tcl source. */
	    width = strtoul(format, &end, 10);	/* INTL: Tcl source. */
d1796 2
a1797 2
	    if (Tcl_GetIntFromObj(interp,	/* INTL: Tcl source. */
		    objv[objIndex], &width) != TCL_OK) {
a1799 6
	    if (width < 0) {
		width = -width;
		*newPtr = '-';
		gotMinus = 1;
		newPtr++;
	    }
d1815 1
a1815 1
	    TclFormatInt(newPtr, width);	/* INTL: printf format. */
a1823 1
	    gotPrecision = 1;
d1825 2
a1826 2
	if (isdigit(UCHAR(*format))) { /* INTL: Tcl source. */
	    precision = strtoul(format, &end, 10);  /* INTL: "C" locale. */
d1832 2
a1833 2
	    if (Tcl_GetIntFromObj(interp,	/* INTL: Tcl source. */
		    objv[objIndex], &precision) != TCL_OK) {
d1839 2
a1840 2
	if (gotPrecision) {
	    TclFormatInt(newPtr, precision);	/* INTL: printf format. */
d1867 2
a1868 2
		if (Tcl_GetIntFromObj(interp,	/* INTL: Tcl source. */
			objv[objIndex], &intValue) != TCL_OK) {
a1874 8
		/*
		 * Compute the length of the string in characters and add
		 * any additional space required by the field width.  All of
		 * the extra characters will be spaces, so one byte per
		 * character is adequate.
		 */

		whichValue = STRING_VALUE;
a1875 8
		stringLen = Tcl_NumUtfChars(ptrValue, size);
		if (gotPrecision && (precision < stringLen)) {
		    stringLen = precision;
		}
		size = Tcl_UtfAtIndex(ptrValue, stringLen) - ptrValue;
		if (width > stringLen) {
		    size += (width - stringLen);
		}
d1878 2
a1879 2
		if (Tcl_GetIntFromObj(interp,	/* INTL: Tcl source. */
			objv[objIndex], &intValue) != TCL_OK) {
d1882 2
a1883 2
		whichValue = CHAR_VALUE;
		size = width + TCL_UTF_MAX;
d1890 2
a1891 2
		if (Tcl_GetDoubleFromObj(interp, /* INTL: Tcl source. */
			objv[objIndex], &doubleValue) != TCL_OK) {
d1905 7
a1911 6
	    default: {
		char buf[40];
		sprintf(buf, "bad field specifier \"%c\"", *format);
		Tcl_SetResult(interp, buf, TCL_VOLATILE);
		goto fmtError;
	    }
a1934 40
	    switch (whichValue) {
		case DOUBLE_VALUE: {
		    sprintf(dst, newFormat, doubleValue); /* INTL: user locale. */
		    break;
		}
		case INT_VALUE: {
		    if (useShort) {
			sprintf(dst, newFormat, (short) intValue);
		    } else {
			sprintf(dst, newFormat, intValue);
		    }
		    break;
		}
		case CHAR_VALUE: {
		    char *ptr;
		    char padChar = (gotZero ? '0' : ' ');
		    ptr = dst;
		    if (!gotMinus) {
			for ( ; --width > 0; ptr++) {
			    *ptr = padChar;
			}
		    }
		    ptr += Tcl_UniCharToUtf(intValue, ptr);
		    for ( ; --width > 0; ptr++) {
			*ptr = padChar;
		    }
		    *ptr = '\0';
		    break;
		}
		case STRING_VALUE: {
		    char *ptr;
		    char padChar = (gotZero ? '0' : ' ');
		    int pad;

		    ptr = dst;
		    if (width > stringLen) {
			pad = width - stringLen;
		    } else {
			pad = 0;
		    }
d1936 7
a1942 22
		    if (!gotMinus) {
			while (pad > 0) {
			    *ptr++ = padChar;
			    pad--;
			}
		    }

		    size = Tcl_UtfAtIndex(ptrValue, stringLen) - ptrValue; 
		    if (size) {
			memcpy(ptr, ptrValue, (size_t) size);
			ptr += size;
		    }
		    while (pad > 0) {
			*ptr++ = padChar;
			pad--;
		    }
		    *ptr = '\0';
		    break;
		}
		default: {
		    sprintf(dst, newFormat, ptrValue);
		    break;
d1944 2
a1976 40
}

/*
 *---------------------------------------------------------------------------
 *
 * StringifyObjects --
 *
 *	Helper function to bridge the gap between an object-based procedure
 *	and an older string-based procedure.
 * 
 *	Given an array of objects, allocate an array that consists of the
 *	string representations of those objects.
 *
 * Results:
 *	The return value is a pointer to the newly allocated array of
 *	strings.  Elements 0 to (objc-1) of the string array point to the
 *	string representation of the corresponding element in the source
 *	object array; element objc of the string array is NULL.
 *
 * Side effects:
 *	Memory allocated.  The caller must eventually free this memory
 *	by calling ckfree() on the return value.
 *
 *---------------------------------------------------------------------------
 */

static char **
StringifyObjects(objc, objv)
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    int i;
    char **argv;
    
    argv = (char **) ckalloc((objc + 1) * sizeof(char *));
    for (i = 0; i < objc; i++) {
    	argv[i] = Tcl_GetString(objv[i]);
    }
    argv[i] = NULL;
    return argv;
@


1.1.1.3
log
@import tcl 8.4.0
@
text
@d14 1
a14 1
 * RCS: @@(#) $Id: tclCmdAH.c,v 1.27 2002/07/02 12:16:05 vincentdarley Exp $
d21 2
d30 2
a31 2
			    Tcl_Obj *objPtr, Tcl_FSStatProc *statProc,
			    Tcl_StatBuf *statPtr));
d33 2
d36 3
a38 1
			    char *varName, Tcl_StatBuf *statPtr));
d102 1
a102 1
    int body, result, caseObjc;
d104 1
d140 1
a140 1
	CONST char **patObjv;
d310 2
a311 1
    Tcl_Obj *dir;
d320 1
a320 1
	dir = objv[1];
d322 1
a322 2
	dir = Tcl_NewStringObj("~",1);
	Tcl_IncrRefCount(dir);
d324 2
a325 9
    if (Tcl_FSConvertToPathType(interp, dir) != TCL_OK) {
	result = TCL_ERROR;
    } else {
	result = Tcl_FSChdir(dir);
	if (result != TCL_OK) {
	    Tcl_AppendResult(interp, "couldn't change working directory to \"",
		    Tcl_GetString(dir), "\": ", Tcl_PosixError(interp), (char *) NULL);
	    result = TCL_ERROR;
	}
d327 8
a334 2
    if (objc != 2) {
	Tcl_DecrRefCount(dir);
d336 1
a336 1
    return result;
d435 1
a435 1
    static CONST char *optionStrings[] = {
d520 1
a520 2
		Tcl_SetStringObj(Tcl_GetObjResult(interp),
			Tcl_GetEncodingName(NULL), -1);
a731 1
    /*** QUESTION: Do we need to copy the slow way? ***/
d768 1
a768 3
 *      With the object-based Tcl_FS APIs, the above NOTE may no
 *      longer be true.  In any case this assertion should be tested.
 *      
d786 1
d793 1
a793 1
    static CONST char *fileOptions[] = {
d797 2
a798 3
	"isdirectory",	"isfile",	"join",		"link",
	"lstat",        "mtime",	"mkdir",	"nativename",	
	"normalize",    "owned",
d800 1
a800 2
	"rootname",	"separator",    "size",		"split",	
	"stat",         "system", 
d808 2
a809 3
	FILE_ISDIRECTORY, FILE_ISFILE,	FILE_JOIN,	FILE_LINK, 
	FILE_LSTAT,     FILE_MTIME,	FILE_MKDIR,	FILE_NATIVENAME, 
	FILE_NORMALIZE, FILE_OWNED,
d811 1
a811 2
	FILE_ROOTNAME,	FILE_SEPARATOR, FILE_SIZE,	FILE_SPLIT,	
	FILE_STAT,      FILE_SYSTEM, 
d824 1
d827 2
a828 1
	    Tcl_StatBuf buf;
d835 1
a835 1
	    if (GetStatBuf(interp, objv[2], Tcl_FSStat, &buf) != TCL_OK) {
d845 3
a847 2
		if (Tcl_FSUtime(objv[2], &tval) != 0) {
		    Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
d849 1
a849 1
			    Tcl_GetString(objv[2]), "\": ",
d859 1
a859 1
		if (GetStatBuf(interp, objv[2], Tcl_FSStat, &buf) != TCL_OK) {
d863 1
a863 1
	    Tcl_SetLongObj(Tcl_GetObjResult(interp), (long) buf.st_atime);
d878 7
a884 1
	    return TclFileCopyCmd(interp, objc, objv);
d887 7
a893 1
	    return TclFileDeleteCmd(interp, objc, objv);
d896 3
a898 1
	    Tcl_Obj *dirPtr;
d902 22
a923 3
	    dirPtr = TclFileDirname(interp, objv[2]);
	    if (dirPtr == NULL) {
	        return TCL_ERROR;
d925 1
a925 3
		Tcl_SetObjResult(interp, dirPtr);
		Tcl_DecrRefCount(dirPtr);
		return TCL_OK;
d927 2
d950 1
a950 1
	    	Tcl_SetStringObj(Tcl_GetObjResult(interp), extension, -1);
d956 1
a956 1
	    Tcl_StatBuf buf;
d962 1
a962 1
	    if (GetStatBuf(NULL, objv[2], Tcl_FSStat, &buf) == TCL_OK) {
d965 1
a965 1
	    Tcl_SetBooleanObj(Tcl_GetObjResult(interp), value);
d970 1
a970 1
	    Tcl_StatBuf buf;
d976 1
a976 1
	    if (GetStatBuf(NULL, objv[2], Tcl_FSStat, &buf) == TCL_OK) {
d979 1
a979 1
	    Tcl_SetBooleanObj(Tcl_GetObjResult(interp), value);
d983 2
a984 1
	    Tcl_Obj *resObj;
d990 7
a996 92
	    resObj = Tcl_FSJoinToPath(NULL, objc - 2, objv + 2);
	    Tcl_SetObjResult(interp, resObj);
	    return TCL_OK;
	}
	case FILE_LINK: {
	    Tcl_Obj *contents;
	    int index;
	    
	    if (objc < 3 || objc > 5) {
		Tcl_WrongNumArgs(interp, 2, objv, 
				 "?-linktype? linkname ?target?");
		return TCL_ERROR;
	    }
	    
	    /* Index of the 'source' argument */
	    if (objc == 5) {
		index = 3;
	    } else {
		index = 2;
	    }
	    
	    if (objc > 3) {
		int linkAction;
		if (objc == 5) {
		    /* We have a '-linktype' argument */
		    static CONST char *linkTypes[] = {
			"-symbolic", "-hard", NULL
		    };
		    if (Tcl_GetIndexFromObj(interp, objv[2], linkTypes, 
				     "switch", 0, &linkAction) != TCL_OK) {
			return TCL_ERROR;
		    }
		    if (linkAction == 0) {
		        linkAction = TCL_CREATE_SYMBOLIC_LINK;
		    } else {
			linkAction = TCL_CREATE_HARD_LINK;
		    }
		} else {
		    linkAction = TCL_CREATE_SYMBOLIC_LINK|TCL_CREATE_HARD_LINK;
		}
		if (Tcl_FSConvertToPathType(interp, objv[index]) != TCL_OK) {
		    return TCL_ERROR;
		}
		/* Create link from source to target */
		contents = Tcl_FSLink(objv[index], objv[index+1], linkAction);
		if (contents == NULL) {
		    /* 
		     * We handle two common error cases specially, and
		     * for all other errors, we use the standard posix
		     * error message.
		     */
		    if (errno == EEXIST) {
			Tcl_AppendResult(interp, "could not create new link \"", 
				Tcl_GetString(objv[index]), 
				"\": that path already exists", (char *) NULL);
		    } else if (errno == ENOENT) {
			Tcl_AppendResult(interp, "could not create new link \"", 
				Tcl_GetString(objv[index]), 
				"\" since target \"", 
				Tcl_GetString(objv[index+1]), 
				"\" doesn't exist", 
				(char *) NULL);
		    } else {
			Tcl_AppendResult(interp, "could not create new link \"", 
				Tcl_GetString(objv[index]), "\" pointing to \"", 
				Tcl_GetString(objv[index+1]), "\": ", 
				Tcl_PosixError(interp), (char *) NULL);
		    }
		    return TCL_ERROR;
		}
	    } else {
		if (Tcl_FSConvertToPathType(interp, objv[index]) != TCL_OK) {
		    return TCL_ERROR;
		}
		/* Read link */
		contents = Tcl_FSLink(objv[index], NULL, 0);
		if (contents == NULL) {
		    Tcl_AppendResult(interp, "could not read link \"", 
			    Tcl_GetString(objv[index]), "\": ", 
			    Tcl_PosixError(interp), (char *) NULL);
		    return TCL_ERROR;
		}
	    }
	    Tcl_SetObjResult(interp, contents);
	    if (objc == 3) {
		/* 
		 * If we are reading a link, we need to free this
		 * result refCount.  If we are creating a link, this
		 * will just be objv[index+1], and so we don't own it.
		 */
		Tcl_DecrRefCount(contents);
	    }
d1001 1
a1001 1
	    Tcl_StatBuf buf;
d1007 1
a1007 1
	    if (GetStatBuf(interp, objv[2], Tcl_FSLstat, &buf) != TCL_OK) {
d1014 2
a1015 1
	    Tcl_StatBuf buf;
d1022 1
a1022 1
	    if (GetStatBuf(interp, objv[2], Tcl_FSStat, &buf) != TCL_OK) {
d1032 3
a1034 2
		if (Tcl_FSUtime(objv[2], &tval) != 0) {
		    Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
d1036 1
a1036 1
			    Tcl_GetString(objv[2]), "\": ",
d1046 1
a1046 1
		if (GetStatBuf(interp, objv[2], Tcl_FSStat, &buf) != TCL_OK) {
d1050 1
a1050 1
	    Tcl_SetLongObj(Tcl_GetObjResult(interp), (long) buf.st_mtime);
d1054 3
d1061 4
a1064 1
	    return TclFileMakeDirsCmd(interp, objc, objv);
d1067 1
a1067 1
	    CONST char *fileName;
d1078 1
a1078 2
	    Tcl_SetStringObj(Tcl_GetObjResult(interp), fileName, 
			     Tcl_DStringLength(&ds));
a1081 12
	case FILE_NORMALIZE: {
	    Tcl_Obj *fileName;

	    if (objc != 3) {
		Tcl_WrongNumArgs(interp, 2, objv, "filename");
		return TCL_ERROR;
	    }

	    fileName = Tcl_FSGetNormalizedPath(interp, objv[2]);
	    Tcl_SetObjResult(interp, fileName);
	    return TCL_OK;
	}
d1084 1
a1084 1
	    Tcl_StatBuf buf;
d1090 1
a1090 1
	    if (GetStatBuf(NULL, objv[2], Tcl_FSStat, &buf) == TCL_OK) {
d1102 1
a1102 1
	    Tcl_SetBooleanObj(Tcl_GetObjResult(interp), value);
d1106 2
d1111 2
a1112 1
	    switch (Tcl_FSGetPathType(objv[2])) {
d1114 1
a1114 1
	    	    Tcl_SetStringObj(Tcl_GetObjResult(interp), "absolute", -1);
d1117 1
a1117 1
	    	    Tcl_SetStringObj(Tcl_GetObjResult(interp), "relative", -1);
d1120 1
a1120 2
		    Tcl_SetStringObj(Tcl_GetObjResult(interp), 
				     "volumerelative", -1);
d1132 2
a1133 1
	    Tcl_Obj *contents;
d1139 3
a1141 1
	    if (Tcl_FSConvertToPathType(interp, objv[2]) != TCL_OK) {
d1145 14
a1158 1
	    contents = Tcl_FSLink(objv[2], NULL, 0);
d1160 1
d1167 1
a1167 2
	    Tcl_SetObjResult(interp, contents);
	    Tcl_DecrRefCount(contents);
d1171 7
a1177 1
	    return TclFileRenameCmd(interp, objc, objv);
d1191 1
a1191 1
	        Tcl_SetStringObj(Tcl_GetObjResult(interp), fileName,
a1195 31
	case FILE_SEPARATOR: {
	    if ((objc < 2) || (objc > 3)) {
		Tcl_WrongNumArgs(interp, 2, objv, "?name?");
		return TCL_ERROR;
	    }
	    if (objc == 2) {
	        char *separator = NULL; /* lint */
		switch (tclPlatform) {
		    case TCL_PLATFORM_UNIX:
			separator = "/";
			break;
		    case TCL_PLATFORM_WINDOWS:
			separator = "\\";
			break;
		    case TCL_PLATFORM_MAC:
			separator = ":";
			break;
		}
		Tcl_SetObjResult(interp, Tcl_NewStringObj(separator,1));
	    } else {
		Tcl_Obj *separatorObj = Tcl_FSPathSeparator(objv[2]);
		if (separatorObj != NULL) {
		    Tcl_SetObjResult(interp, separatorObj);
		} else {
		    Tcl_SetObjResult(interp, 
			    Tcl_NewStringObj("Unrecognised path",-1));
		    return TCL_ERROR;
		}
	    }
	    return TCL_OK;
	}
d1197 1
a1197 1
	    Tcl_StatBuf buf;
d1202 1
a1202 1
	    if (GetStatBuf(interp, objv[2], Tcl_FSStat, &buf) != TCL_OK) {
d1205 1
a1205 2
	    Tcl_SetWideIntObj(Tcl_GetObjResult(interp),
		    (Tcl_WideInt) buf.st_size);
d1209 5
d1217 7
a1223 1
	    Tcl_SetObjResult(interp, Tcl_FSSplitPath(objv[2], NULL));
d1228 1
a1228 1
	    Tcl_StatBuf buf;
d1234 1
a1234 1
	    if (GetStatBuf(interp, objv[2], Tcl_FSStat, &buf) != TCL_OK) {
a1239 15
	case FILE_SYSTEM: {
	    Tcl_Obj* fsInfo;
	    if (objc != 3) {
		goto only3Args;
	    }
	    fsInfo = Tcl_FSFileSystemInfo(objv[2]);
	    if (fsInfo != NULL) {
		Tcl_SetObjResult(interp, fsInfo);
		return TCL_OK;
	    } else {
		Tcl_SetObjResult(interp, 
				 Tcl_NewStringObj("Unrecognised path",-1));
		return TCL_ERROR;
	    }
	}
d1241 2
a1242 2
	    int splitElements;
	    Tcl_Obj *splitPtr;
d1247 2
a1248 15
	    /* 
	     * The behaviour we want here is slightly different to
	     * the standard Tcl_FSSplitPath in the handling of home
	     * directories; Tcl_FSSplitPath preserves the "~" while 
	     * this code computes the actual full path name, if we
	     * had just a single component.
	     */	    
	    splitPtr = Tcl_FSSplitPath(objv[2], &splitElements);
	    if ((splitElements == 1) && (Tcl_GetString(objv[2])[0] == '~')) {
		Tcl_DecrRefCount(splitPtr);
		splitPtr = Tcl_FSGetNormalizedPath(interp, objv[2]);
		if (splitPtr == NULL) {
		    return TCL_ERROR;
		}
		splitPtr = Tcl_FSSplitPath(splitPtr, &splitElements);
d1256 4
a1259 7
	    if (splitElements > 0) {
	    	if ((splitElements > 1)
		  || (Tcl_FSGetPathType(objv[2]) == TCL_PATH_RELATIVE)) {
		    
		    Tcl_Obj *tail = NULL;
		    Tcl_ListObjIndex(NULL, splitPtr, splitElements-1, &tail);
		    Tcl_SetObjResult(interp, tail);
d1262 1
a1262 1
	    Tcl_DecrRefCount(splitPtr);
d1266 1
a1266 1
	    Tcl_StatBuf buf;
d1271 1
a1271 1
	    if (GetStatBuf(interp, objv[2], Tcl_FSLstat, &buf) != TCL_OK) {
d1274 1
a1274 1
	    Tcl_SetStringObj(Tcl_GetObjResult(interp), 
d1283 1
a1283 2
	    Tcl_SetObjResult(interp, Tcl_FSListVolumes());
	    return TCL_OK;
d1301 57
d1382 2
d1385 3
a1387 1
    if (Tcl_FSConvertToPathType(interp, objPtr) != TCL_OK) {
d1390 2
a1391 1
	value = (Tcl_FSAccess(objPtr, mode) == 0);
d1422 1
a1422 1
    Tcl_FSStatProc *statProc;	/* Either stat() or lstat() depending on
d1424 1
a1424 1
    Tcl_StatBuf *statPtr;	/* Filled with info about file obtained by
d1427 2
d1431 3
a1433 1
    if (Tcl_FSConvertToPathType(interp, objPtr) != TCL_OK) {
d1437 2
a1438 1
    status = (*statProc)(objPtr, statPtr);
d1475 1
a1475 1
    Tcl_StatBuf *statPtr;		/* Pointer to buffer containing
d1478 1
a1478 4
    Tcl_Obj *var = Tcl_NewStringObj(varName, -1);
    Tcl_Obj *field = Tcl_NewObj();
    Tcl_Obj *value;
    register unsigned short mode;
d1480 54
a1533 11
    /*
     * Assume Tcl_ObjSetVar2() does not keep a copy of the field name!
     */
#define STORE_ARY(fieldName, object) \
    Tcl_SetStringObj(field, (fieldName), -1); \
    value = (object); \
    if (Tcl_ObjSetVar2(interp,var,field,value,TCL_LEAVE_ERR_MSG) == NULL) { \
	Tcl_DecrRefCount(var); \
	Tcl_DecrRefCount(field); \
	Tcl_DecrRefCount(value); \
	return TCL_ERROR; \
a1534 26

    Tcl_IncrRefCount(var);
    Tcl_IncrRefCount(field);
    STORE_ARY("dev",   Tcl_NewLongObj((long)statPtr->st_dev));
    /*
     * Watch out porters; the inode is meant to be an *unsigned* value,
     * so the cast might fail when there isn't a real arithmentic 'long
     * long' type...
     */
    STORE_ARY("ino",   Tcl_NewWideIntObj((Tcl_WideInt)statPtr->st_ino));
    STORE_ARY("nlink", Tcl_NewLongObj((long)statPtr->st_nlink));
    STORE_ARY("uid",   Tcl_NewLongObj((long)statPtr->st_uid));
    STORE_ARY("gid",   Tcl_NewLongObj((long)statPtr->st_gid));
    STORE_ARY("size",  Tcl_NewWideIntObj((Tcl_WideInt)statPtr->st_size));
#ifdef HAVE_ST_BLOCKS
    STORE_ARY("blocks",Tcl_NewWideIntObj((Tcl_WideInt)statPtr->st_blocks));
#endif
    STORE_ARY("atime", Tcl_NewLongObj((long)statPtr->st_atime));
    STORE_ARY("mtime", Tcl_NewLongObj((long)statPtr->st_mtime));
    STORE_ARY("ctime", Tcl_NewLongObj((long)statPtr->st_ctime));
    mode = (unsigned short) statPtr->st_mode;
    STORE_ARY("mode",  Tcl_NewIntObj(mode));
    STORE_ARY("type",  Tcl_NewStringObj(GetTypeFromMode(mode), -1));
#undef STORE_ARY
    Tcl_DecrRefCount(var);
    Tcl_DecrRefCount(field);
d1713 11
a1723 11
    int indexArray[STATIC_LIST_SIZE];
    int varcListArray[STATIC_LIST_SIZE];
    Tcl_Obj **varvListArray[STATIC_LIST_SIZE];
    int argcListArray[STATIC_LIST_SIZE];
    Tcl_Obj **argvListArray[STATIC_LIST_SIZE];

    int *index = indexArray;		   /* Array of value list indices */
    int *varcList = varcListArray;	   /* # loop variables per list */
    Tcl_Obj ***varvList = varvListArray;   /* Array of var name lists */
    int *argcList = argcListArray;	   /* Array of value list sizes */
    Tcl_Obj ***argvList = argvListArray;   /* Array of value lists */
d1809 3
a1811 6
	     * Refetch the list members; we assume that the sizes are
	     * the same, but the array of elements might be different
	     * if the internal rep of the objects has been lost and
	     * recreated (it is too difficult to accurately tell when
	     * this happens, which can lead to some wierd crashes,
	     * like Bug #494348...)
d1814 13
a1826 9
	    result = Tcl_ListObjGetElements(interp, argObjv[1+i*2],
		    &varcList[i], &varvList[i]);
	    if (result != TCL_OK) {
		panic("Tcl_ForeachObjCmd: could not reconvert variable list %d to a list object\n", i);
	    }
	    result = Tcl_ListObjGetElements(interp, argObjv[2+i*2],
		    &argcList[i], &argvList[i]);
	    if (result != TCL_OK) {
		panic("Tcl_ForeachObjCmd: could not reconvert value list %d to a list object\n", i);
d1923 1
a1923 1
    int formatLen;		/* The length of the format string */
d1925 1
a1925 1
    char newFormat[43];		/* A new format specifier is generated here. */
d1933 1
a1933 1
    long intValue;		/* Used to hold value to pass to sprintf, if
a1938 4
#ifndef TCL_WIDE_INT_IS_LONG
    Tcl_WideInt wideValue;	/* Used to hold value to pass to sprintf if
				 * it's a 'long long' value. */
#endif /* TCL_WIDE_INT_IS_LONG */
a1947 1
#   define WIDE_VALUE 5
d1949 1
a1949 1

a1975 3
#ifndef TCL_WIDE_INT_IS_LONG
    int useWide;		/* Value to be printed is Tcl_WideInt. */
#endif /* TCL_WIDE_INT_IS_LONG */
d1985 1
a1985 2
     *    because some of the arguments may be two-word values (doubles
     *    and wide-ints).
d1995 1
a1995 1
    format = Tcl_GetStringFromObj(objv[1], &formatLen);
a2004 3
#ifndef TCL_WIDE_INT_IS_LONG
	useWide = 0;
#endif /* TCL_WIDE_INT_IS_LONG */
d2084 1
a2084 1
	if (isdigit(UCHAR(*format))) {		/* INTL: Tcl source. */
d2127 1
a2127 1
	if (isdigit(UCHAR(*format))) {		/* INTL: Tcl source. */
a2147 5
#ifndef TCL_WIDE_INT_IS_LONG
	    useWide = 1;
	    strcpy(newPtr, TCL_LL_MODIFIER);
	    newPtr += TCL_LL_MODIFIER_SIZE;
#endif /* TCL_WIDE_INT_IS_LONG */
d2169 1
a2169 12
#ifndef TCL_WIDE_INT_IS_LONG
		if (useWide) {
		    if (Tcl_GetWideIntFromObj(interp, /* INTL: Tcl source. */
			    objv[objIndex], &wideValue) != TCL_OK) {
			goto fmtError;
		    }
		    whichValue = WIDE_VALUE;
		    size = 40 + precision;
		    break;
		}
#endif /* TCL_WIDE_INT_IS_LONG */
		if (Tcl_GetLongFromObj(interp,	      /* INTL: Tcl source. */
a2172 11
#if (LONG_MAX > INT_MAX)
		/*
		 * Add the 'l' for long format type because we are on
		 * an LP64 archtecture and we are really going to pass
		 * a long argument to sprintf.
		 */
		newPtr++;
		*newPtr = 0;
		newPtr[-1] = newPtr[-2];
		newPtr[-2] = 'l';
#endif /* LONG_MAX > INT_MAX */
d2196 1
a2196 1
		if (Tcl_GetLongFromObj(interp,	/* INTL: Tcl source. */
a2256 6
#ifndef TCL_WIDE_INT_IS_LONG
		case WIDE_VALUE: {
		    sprintf(dst, newFormat, wideValue);
		    break;
		}
#endif /* TCL_WIDE_INT_IS_LONG */
d2347 40
@


