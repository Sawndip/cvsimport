head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.58
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.56
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.54
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.52
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.50
	gdb_7_0-branch:1.5.0.48
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tcl8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.46
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.44
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.42
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.40
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.38
	gdb_6_5-2006-05-14-branchpoint:1.5
	readline_5_1-import-branch:1.5.0.36
	readline_5_1-import-branchpoint:1.5
	gdb_6_4-branch:1.5.0.34
	gdb_6_4-2005-11-01-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.32
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	ezannoni_pie-20040323-branch:1.5.0.30
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.28
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.26
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.24
	cagney_x86i386-20030821-branch:1.5.0.22
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.20
	gdb_6_0-2003-06-23-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.18
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.16
	cagney_writestrings-20030508-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.14
	cagney_fileio-20030521-branchpoint:1.5
	carlton_dictionary-20030430-merge:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.12
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.10
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.8
	cagney_lazyid-20030317-branchpoint:1.5
	offbyone-20030313-branch:1.5.0.6
	offbyone-20030313-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.4
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.2
	interps-20030202-branchpoint:1.5
	TCL8_4_1:1.1.1.3
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.2
	TCL_8_4_1:1.1.1.3
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.4
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TCL_8_4_0:1.1.1.3
	carlton_dictionary-branch:1.2.0.16
	carlton_dictionary-20020920-branchpoint:1.2
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.14
	gdb_5_3-branch:1.2.0.12
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.10
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.8
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.6
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TCL_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	dejagnu-2000-02-04:1.1.1.1
	dejagnu-2000-01-31:1.1.1.1
	dejagnu-2000-01-24:1.1.1.1
	dejagnu-2000-01-17:1.1.1.1
	dejagnu-2000-01-10:1.1.1.1
	dejagnu-2000-01-04:1.1.1.1
	dejagnu-1999-12-21:1.1.1.1
	dejagnu-1999-12-13:1.1.1.1
	dejagnu-1999-12-07:1.1.1.1
	dejagnu-1999-12-06:1.1.1.1
	dejagnu-1999-11-15:1.1.1.1
	dejagnu-1999-11-08:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.5
date	2003.01.21.19.40.06;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.26.19.47.53;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.37.03;	author kseitz;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2001.09.09.23.56.06;	author irox;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	99.11.09.01.28.43;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2002.09.27.21.49.05;	author kseitz;	state Exp;
branches;
next	;

1.3.4.1
date	2003.12.14.20.28.44;	author drow;	state Exp;
branches;
next	;

1.2.16.1
date	2002.12.23.19.40.24;	author carlton;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2003.02.07.19.18.14;	author carlton;	state Exp;
branches;
next	;

1.1.1.1
date	99.11.09.01.28.43;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.09.22.40.56;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.19.56.07;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tcl 8.4.1
@
text
@/* 
 * tclStringObj.c --
 *
 *	This file contains procedures that implement string operations on Tcl
 *	objects.  Some string operations work with UTF strings and others
 *	require Unicode format.  Functions that require knowledge of the width
 *	of each character, such as indexing, operate on Unicode data.
 *
 *	A Unicode string is an internationalized string.  Conceptually, a
 *	Unicode string is an array of 16-bit quantities organized as a sequence
 *	of properly formed UTF-8 characters.  There is a one-to-one map between
 *	Unicode and UTF characters.  Because Unicode characters have a fixed
 *	width, operations such as indexing operate on Unicode data.  The String
 *	ojbect is opitmized for the case where each UTF char in a string is
 *	only one byte.  In this case, we store the value of numChars, but we
 *	don't store the Unicode data (unless Tcl_GetUnicode is explicitly
 *	called).
 *
 *	The String object type stores one or both formats.  The default
 *	behavior is to store UTF.  Once Unicode is calculated by a function, it
 *	is stored in the internal rep for future access (without an additional
 *	O(n) cost).
 *
 *	To allow many appends to be done to an object without constantly
 *	reallocating the space for the string or Unicode representation, we
 *	allocate double the space for the string or Unicode and use the
 *	internal representation to keep track of how much space is used
 *	vs. allocated.
 *
 * Copyright (c) 1995-1997 Sun Microsystems, Inc.
 * Copyright (c) 1999 by Scriptics Corporation.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tclStringObj.c,v 1.24 2002/01/26 01:10:08 dgp Exp $ */

#include "tclInt.h"

/*
 * Prototypes for procedures defined later in this file:
 */

static void		AppendUnicodeToUnicodeRep _ANSI_ARGS_((
    			    Tcl_Obj *objPtr, CONST Tcl_UniChar *unicode,
			    int appendNumChars));
static void		AppendUnicodeToUtfRep _ANSI_ARGS_((
    			    Tcl_Obj *objPtr, CONST Tcl_UniChar *unicode,
			    int numChars));
static void		AppendUtfToUnicodeRep _ANSI_ARGS_((Tcl_Obj *objPtr,
    			    CONST char *bytes, int numBytes));
static void		AppendUtfToUtfRep _ANSI_ARGS_((Tcl_Obj *objPtr,
    			    CONST char *bytes, int numBytes));

static void		FillUnicodeRep _ANSI_ARGS_((Tcl_Obj *objPtr));

static void		FreeStringInternalRep _ANSI_ARGS_((Tcl_Obj *objPtr));
static void		DupStringInternalRep _ANSI_ARGS_((Tcl_Obj *objPtr,
			    Tcl_Obj *copyPtr));
static int		SetStringFromAny _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_Obj *objPtr));
static void		UpdateStringOfString _ANSI_ARGS_((Tcl_Obj *objPtr));

/*
 * The structure below defines the string Tcl object type by means of
 * procedures that can be invoked by generic object code.
 */

Tcl_ObjType tclStringType = {
    "string",				/* name */
    FreeStringInternalRep,		/* freeIntRepPro */
    DupStringInternalRep,		/* dupIntRepProc */
    UpdateStringOfString,		/* updateStringProc */
    SetStringFromAny			/* setFromAnyProc */
};

/*
 * The following structure is the internal rep for a String object.
 * It keeps track of how much memory has been used and how much has been
 * allocated for the Unicode and UTF string to enable growing and
 * shrinking of the UTF and Unicode reps of the String object with fewer
 * mallocs.  To optimize string length and indexing operations, this
 * structure also stores the number of characters (same of UTF and Unicode!)
 * once that value has been computed.
 */

typedef struct String {
    int numChars;		/* The number of chars in the string.
				 * -1 means this value has not been
				 * calculated. >= 0 means that there is a
				 * valid Unicode rep, or that the number
				 * of UTF bytes == the number of chars. */
    size_t allocated;		/* The amount of space actually allocated
				 * for the UTF string (minus 1 byte for
				 * the termination char). */
    size_t uallocated;		/* The amount of space actually allocated
				 * for the Unicode string. 0 means the
				 * Unicode string rep is invalid. */
    Tcl_UniChar unicode[2];	/* The array of Unicode chars.  The actual
				 * size of this field depends on the
				 * 'uallocated' field above. */
} String;

#define STRING_SIZE(len)	\
		((unsigned) (sizeof(String) + ((len-1) * sizeof(Tcl_UniChar))))
#define GET_STRING(objPtr) \
		((String *) (objPtr)->internalRep.otherValuePtr)
#define SET_STRING(objPtr, stringPtr) \
		(objPtr)->internalRep.otherValuePtr = (VOID *) (stringPtr)

/*
 * TCL STRING GROWTH ALGORITHM
 *
 * When growing strings (during an append, for example), the following growth
 * algorithm is used:
 *
 *   Attempt to allocate 2 * (originalLength + appendLength)
 *   On failure:
 *	attempt to allocate originalLength + 2*appendLength +
 *			TCL_GROWTH_MIN_ALLOC 
 *
 * This algorithm allows very good performance, as it rapidly increases the
 * memory allocated for a given string, which minimizes the number of
 * reallocations that must be performed.  However, using only the doubling
 * algorithm can lead to a significant waste of memory.  In particular, it
 * may fail even when there is sufficient memory available to complete the
 * append request (but there is not 2 * totalLength memory available).  So when
 * the doubling fails (because there is not enough memory available), the
 * algorithm requests a smaller amount of memory, which is still enough to
 * cover the request, but which hopefully will be less than the total available
 * memory.
 * 
 * The addition of TCL_GROWTH_MIN_ALLOC allows for efficient handling
 * of very small appends.  Without this extra slush factor, a sequence
 * of several small appends would cause several memory allocations.
 * As long as TCL_GROWTH_MIN_ALLOC is a reasonable size, we can
 * avoid that behavior.
 *
 * The growth algorithm can be tuned by adjusting the following parameters:
 *
 * TCL_GROWTH_MIN_ALLOC		Additional space, in bytes, to allocate when
 *				the double allocation has failed.
 *				Default is 1024 (1 kilobyte).
 */
#ifndef TCL_GROWTH_MIN_ALLOC
#define TCL_GROWTH_MIN_ALLOC	1024
#endif


/*
 *----------------------------------------------------------------------
 *
 * Tcl_NewStringObj --
 *
 *	This procedure is normally called when not debugging: i.e., when
 *	TCL_MEM_DEBUG is not defined. It creates a new string object and
 *	initializes it from the byte pointer and length arguments.
 *
 *	When TCL_MEM_DEBUG is defined, this procedure just returns the
 *	result of calling the debugging version Tcl_DbNewStringObj.
 *
 * Results:
 *	A newly created string object is returned that has ref count zero.
 *
 * Side effects:
 *	The new object's internal string representation will be set to a
 *	copy of the length bytes starting at "bytes". If "length" is
 *	negative, use bytes up to the first NULL byte; i.e., assume "bytes"
 *	points to a C-style NULL-terminated string. The object's type is set
 *	to NULL. An extra NULL is added to the end of the new object's byte
 *	array.
 *
 *----------------------------------------------------------------------
 */

#ifdef TCL_MEM_DEBUG
#undef Tcl_NewStringObj

Tcl_Obj *
Tcl_NewStringObj(bytes, length)
    CONST char *bytes;		/* Points to the first of the length bytes
				 * used to initialize the new object. */
    int length;			/* The number of bytes to copy from "bytes"
				 * when initializing the new object. If 
				 * negative, use bytes up to the first
				 * NULL byte. */
{
    return Tcl_DbNewStringObj(bytes, length, "unknown", 0);
}

#else /* if not TCL_MEM_DEBUG */

Tcl_Obj *
Tcl_NewStringObj(bytes, length)
    CONST char *bytes;		/* Points to the first of the length bytes
				 * used to initialize the new object. */
    int length;			/* The number of bytes to copy from "bytes"
				 * when initializing the new object. If 
				 * negative, use bytes up to the first
				 * NULL byte. */
{
    register Tcl_Obj *objPtr;

    if (length < 0) {
	length = (bytes? strlen(bytes) : 0);
    }
    TclNewObj(objPtr);
    TclInitStringRep(objPtr, bytes, length);
    return objPtr;
}
#endif /* TCL_MEM_DEBUG */

/*
 *----------------------------------------------------------------------
 *
 * Tcl_DbNewStringObj --
 *
 *	This procedure is normally called when debugging: i.e., when
 *	TCL_MEM_DEBUG is defined. It creates new string objects. It is the
 *	same as the Tcl_NewStringObj procedure above except that it calls
 *	Tcl_DbCkalloc directly with the file name and line number from its
 *	caller. This simplifies debugging since then the [memory active]
 *	command	will report the correct file name and line number when
 *	reporting objects that haven't been freed.
 *
 *	When TCL_MEM_DEBUG is not defined, this procedure just returns the
 *	result of calling Tcl_NewStringObj.
 *
 * Results:
 *	A newly created string object is returned that has ref count zero.
 *
 * Side effects:
 *	The new object's internal string representation will be set to a
 *	copy of the length bytes starting at "bytes". If "length" is
 *	negative, use bytes up to the first NULL byte; i.e., assume "bytes"
 *	points to a C-style NULL-terminated string. The object's type is set
 *	to NULL. An extra NULL is added to the end of the new object's byte
 *	array.
 *
 *----------------------------------------------------------------------
 */

#ifdef TCL_MEM_DEBUG

Tcl_Obj *
Tcl_DbNewStringObj(bytes, length, file, line)
    CONST char *bytes;		/* Points to the first of the length bytes
				 * used to initialize the new object. */
    int length;			/* The number of bytes to copy from "bytes"
				 * when initializing the new object. If 
				 * negative, use bytes up to the first
				 * NULL byte. */
    CONST char *file;		/* The name of the source file calling this
				 * procedure; used for debugging. */
    int line;			/* Line number in the source file; used
				 * for debugging. */
{
    register Tcl_Obj *objPtr;

    if (length < 0) {
	length = (bytes? strlen(bytes) : 0);
    }
    TclDbNewObj(objPtr, file, line);
    TclInitStringRep(objPtr, bytes, length);
    return objPtr;
}

#else /* if not TCL_MEM_DEBUG */

Tcl_Obj *
Tcl_DbNewStringObj(bytes, length, file, line)
    CONST char *bytes;		/* Points to the first of the length bytes
				 * used to initialize the new object. */
    register int length;	/* The number of bytes to copy from "bytes"
				 * when initializing the new object. If 
				 * negative, use bytes up to the first
				 * NULL byte. */
    CONST char *file;		/* The name of the source file calling this
				 * procedure; used for debugging. */
    int line;			/* Line number in the source file; used
				 * for debugging. */
{
    return Tcl_NewStringObj(bytes, length);
}
#endif /* TCL_MEM_DEBUG */

/*
 *---------------------------------------------------------------------------
 *
 * Tcl_NewUnicodeObj --
 *
 *	This procedure is creates a new String object and initializes
 *	it from the given Unicode String.  If the Utf String is the same size
 *	as the Unicode string, don't duplicate the data.
 *
 * Results:
 *	The newly created object is returned.  This object will have no
 *	initial string representation.  The returned object has a ref count
 *	of 0.
 *
 * Side effects:
 *	Memory allocated for new object and copy of Unicode argument.
 *
 *---------------------------------------------------------------------------
 */

Tcl_Obj *
Tcl_NewUnicodeObj(unicode, numChars)
    CONST Tcl_UniChar *unicode;	/* The unicode string used to initialize
				 * the new object. */
    int numChars;		/* Number of characters in the unicode
				 * string. */
{
    Tcl_Obj *objPtr;
    String *stringPtr;
    size_t uallocated;

    if (numChars < 0) {
	numChars = 0;
	if (unicode) {
	    while (unicode[numChars] != 0) { numChars++; }
	}
    }
    uallocated = (numChars + 1) * sizeof(Tcl_UniChar);

    /*
     * Create a new obj with an invalid string rep.
     */

    TclNewObj(objPtr);
    Tcl_InvalidateStringRep(objPtr);
    objPtr->typePtr = &tclStringType;

    stringPtr = (String *) ckalloc(STRING_SIZE(uallocated));
    stringPtr->numChars = numChars;
    stringPtr->uallocated = uallocated;
    stringPtr->allocated = 0;
    memcpy((VOID *) stringPtr->unicode, (VOID *) unicode, uallocated);
    stringPtr->unicode[numChars] = 0;
    SET_STRING(objPtr, stringPtr);
    return objPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetCharLength --
 *
 *	Get the length of the Unicode string from the Tcl object.
 *
 * Results:
 *	Pointer to unicode string representing the unicode object.
 *
 * Side effects:
 *	Frees old internal rep.  Allocates memory for new "String"
 *	internal rep.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_GetCharLength(objPtr)
    Tcl_Obj *objPtr;	/* The String object to get the num chars of. */
{
    String *stringPtr;
    
    SetStringFromAny(NULL, objPtr);
    stringPtr = GET_STRING(objPtr);

    /*
     * If numChars is unknown, then calculate the number of characaters
     * while populating the Unicode string.
     */
    
    if (stringPtr->numChars == -1) {

	stringPtr->numChars = Tcl_NumUtfChars(objPtr->bytes, objPtr->length);

 	if (stringPtr->numChars == objPtr->length) {

	    /*
	     * Since we've just calculated the number of chars, and all
	     * UTF chars are 1-byte long, we don't need to store the
	     * unicode string.
	     */

	    stringPtr->uallocated = 0;

	} else {
    
	    /*
	     * Since we've just calucalated the number of chars, and not
	     * all UTF chars are 1-byte long, go ahead and populate the
	     * unicode string.
	     */

	    FillUnicodeRep(objPtr);

	    /*
	     * We need to fetch the pointer again because we have just
	     * reallocated the structure to make room for the Unicode data.
	     */
	    
	    stringPtr = GET_STRING(objPtr);
	}
    }
    return stringPtr->numChars;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetUniChar --
 *
 *	Get the index'th Unicode character from the String object.  The
 *	index is assumed to be in the appropriate range.
 *
 * Results:
 *	Returns the index'th Unicode character in the Object.
 *
 * Side effects:
 *	Fills unichar with the index'th Unicode character.
 *
 *----------------------------------------------------------------------
 */

Tcl_UniChar
Tcl_GetUniChar(objPtr, index)
    Tcl_Obj *objPtr;	/* The object to get the Unicode charater from. */
    int index;		/* Get the index'th Unicode character. */
{
    Tcl_UniChar unichar;
    String *stringPtr;
    
    SetStringFromAny(NULL, objPtr);
    stringPtr = GET_STRING(objPtr);

    if (stringPtr->numChars == -1) {

	/*
	 * We haven't yet calculated the length, so we don't have the
	 * Unicode str.  We need to know the number of chars before we
	 * can do indexing.
	 */

	Tcl_GetCharLength(objPtr);

	/*
	 * We need to fetch the pointer again because we may have just
	 * reallocated the structure.
	 */
	
	stringPtr = GET_STRING(objPtr);
    }
    if (stringPtr->uallocated == 0) {

	/*
	 * All of the characters in the Utf string are 1 byte chars,
	 * so we don't store the unicode char.  We get the Utf string
	 * and convert the index'th byte to a Unicode character.
	 */
	
	Tcl_UtfToUniChar(&objPtr->bytes[index], &unichar);	
    } else {
	unichar = stringPtr->unicode[index];
    }
    return unichar;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetUnicode --
 *
 *	Get the Unicode form of the String object.  If
 *	the object is not already a String object, it will be converted
 *	to one.  If the String object does not have a Unicode rep, then
 *	one is create from the UTF string format.
 *
 * Results:
 *	Returns a pointer to the object's internal Unicode string.
 *
 * Side effects:
 *	Converts the object to have the String internal rep.
 *
 *----------------------------------------------------------------------
 */

Tcl_UniChar *
Tcl_GetUnicode(objPtr)
    Tcl_Obj *objPtr;	/* The object to find the unicode string for. */
{
    String *stringPtr;
    
    SetStringFromAny(NULL, objPtr);
    stringPtr = GET_STRING(objPtr);
    
    if ((stringPtr->numChars == -1) || (stringPtr->uallocated == 0)) {

	/*
	 * We haven't yet calculated the length, or all of the characters
	 * in the Utf string are 1 byte chars (so we didn't store the
	 * unicode str).  Since this function must return a unicode string,
	 * and one has not yet been stored, force the Unicode to be
	 * calculated and stored now.
	 */

	FillUnicodeRep(objPtr);

	/*
	 * We need to fetch the pointer again because we have just
	 * reallocated the structure to make room for the Unicode data.
	 */
	
	stringPtr = GET_STRING(objPtr);
    }
    return stringPtr->unicode;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetUnicodeFromObj --
 *
 *	Get the Unicode form of the String object with length.  If
 *	the object is not already a String object, it will be converted
 *	to one.  If the String object does not have a Unicode rep, then
 *	one is create from the UTF string format.
 *
 * Results:
 *	Returns a pointer to the object's internal Unicode string.
 *
 * Side effects:
 *	Converts the object to have the String internal rep.
 *
 *----------------------------------------------------------------------
 */

Tcl_UniChar *
Tcl_GetUnicodeFromObj(objPtr, lengthPtr)
    Tcl_Obj *objPtr;	/* The object to find the unicode string for. */
    int *lengthPtr;	/* If non-NULL, the location where the
			 * string rep's unichar length should be
			 * stored. If NULL, no length is stored. */
{
    String *stringPtr;
    
    SetStringFromAny(NULL, objPtr);
    stringPtr = GET_STRING(objPtr);
    
    if ((stringPtr->numChars == -1) || (stringPtr->uallocated == 0)) {

	/*
	 * We haven't yet calculated the length, or all of the characters
	 * in the Utf string are 1 byte chars (so we didn't store the
	 * unicode str).  Since this function must return a unicode string,
	 * and one has not yet been stored, force the Unicode to be
	 * calculated and stored now.
	 */

	FillUnicodeRep(objPtr);

	/*
	 * We need to fetch the pointer again because we have just
	 * reallocated the structure to make room for the Unicode data.
	 */
	
	stringPtr = GET_STRING(objPtr);
    }

    if (lengthPtr != NULL) {
	*lengthPtr = stringPtr->numChars;
    }
    return stringPtr->unicode;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetRange --
 *
 *	Create a Tcl Object that contains the chars between first and last
 *	of the object indicated by "objPtr".  If the object is not already
 *	a String object, convert it to one.  The first and last indices
 *	are assumed to be in the appropriate range.
 *
 * Results:
 *	Returns a new Tcl Object of the String type.
 *
 * Side effects:
 *	Changes the internal rep of "objPtr" to the String type.
 *
 *----------------------------------------------------------------------
 */

Tcl_Obj *
Tcl_GetRange(objPtr, first, last)
    Tcl_Obj *objPtr;		/* The Tcl object to find the range of. */
    int first;			/* First index of the range. */
    int last;			/* Last index of the range. */
{
    Tcl_Obj *newObjPtr;		/* The Tcl object to find the range of. */
    String *stringPtr;
    
    SetStringFromAny(NULL, objPtr);
    stringPtr = GET_STRING(objPtr);

    if (stringPtr->numChars == -1) {
    
	/*
	 * We haven't yet calculated the length, so we don't have the
	 * Unicode str.  We need to know the number of chars before we
	 * can do indexing.
	 */

	Tcl_GetCharLength(objPtr);

	/*
	 * We need to fetch the pointer again because we may have just
	 * reallocated the structure.
	 */
	
	stringPtr = GET_STRING(objPtr);
    }

    if (stringPtr->numChars == objPtr->length) {
	char *str = Tcl_GetString(objPtr);

	/*
	 * All of the characters in the Utf string are 1 byte chars,
	 * so we don't store the unicode char.  Create a new string
	 * object containing the specified range of chars.
	 */
	
	newObjPtr = Tcl_NewStringObj(&str[first], last-first+1);

	/*
	 * Since we know the new string only has 1-byte chars, we
	 * can set it's numChars field.
	 */
	
	SetStringFromAny(NULL, newObjPtr);
	stringPtr = GET_STRING(newObjPtr);
	stringPtr->numChars = last-first+1;
    } else {
	newObjPtr = Tcl_NewUnicodeObj(stringPtr->unicode + first,
		last-first+1);
    }
    return newObjPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_SetStringObj --
 *
 *	Modify an object to hold a string that is a copy of the bytes
 *	indicated by the byte pointer and length arguments. 
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The object's string representation will be set to a copy of
 *	the "length" bytes starting at "bytes". If "length" is negative, use
 *	bytes up to the first NULL byte; i.e., assume "bytes" points to a
 *	C-style NULL-terminated string. The object's old string and internal
 *	representations are freed and the object's type is set NULL.
 *
 *----------------------------------------------------------------------
 */

void
Tcl_SetStringObj(objPtr, bytes, length)
    register Tcl_Obj *objPtr;	/* Object whose internal rep to init. */
    CONST char *bytes;		/* Points to the first of the length bytes
				 * used to initialize the object. */
    register int length;	/* The number of bytes to copy from "bytes"
				 * when initializing the object. If 
				 * negative, use bytes up to the first
				 * NULL byte.*/
{
    register Tcl_ObjType *oldTypePtr = objPtr->typePtr;

    /*
     * Free any old string rep, then set the string rep to a copy of
     * the length bytes starting at "bytes".
     */

    if (Tcl_IsShared(objPtr)) {
	panic("Tcl_SetStringObj called with shared object");
    }

    /*
     * Set the type to NULL and free any internal rep for the old type.
     */

    if ((oldTypePtr != NULL) && (oldTypePtr->freeIntRepProc != NULL)) {
	oldTypePtr->freeIntRepProc(objPtr);
    }
    objPtr->typePtr = NULL;

    Tcl_InvalidateStringRep(objPtr);
    if (length < 0) {
	length = (bytes? strlen(bytes) : 0);
    }
    TclInitStringRep(objPtr, bytes, length);
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_SetObjLength --
 *
 *	This procedure changes the length of the string representation
 *	of an object.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	If the size of objPtr's string representation is greater than
 *	length, then it is reduced to length and a new terminating null
 *	byte is stored in the strength.  If the length of the string
 *	representation is greater than length, the storage space is
 *	reallocated to the given length; a null byte is stored at the
 *	end, but other bytes past the end of the original string
 *	representation are undefined.  The object's internal
 *	representation is changed to "expendable string".
 *
 *----------------------------------------------------------------------
 */

void
Tcl_SetObjLength(objPtr, length)
    register Tcl_Obj *objPtr;	/* Pointer to object.  This object must
				 * not currently be shared. */
    register int length;	/* Number of bytes desired for string
				 * representation of object, not including
				 * terminating null byte. */
{
    char *new;
    String *stringPtr;

    if (Tcl_IsShared(objPtr)) {
	panic("Tcl_SetObjLength called with shared object");
    }
    SetStringFromAny(NULL, objPtr);
        
    /*
     * Invalidate the unicode data.
     */

    stringPtr = GET_STRING(objPtr);
    stringPtr->numChars = -1;
    stringPtr->uallocated = 0;

    if (length > (int) stringPtr->allocated) {

	/*
	 * Not enough space in current string. Reallocate the string
	 * space and free the old string.
	 */
 	if (objPtr->bytes != tclEmptyStringRep) {
	    new = (char *) ckrealloc((char *)objPtr->bytes,
		    (unsigned)(length+1));
	} else {
	    new = (char *) ckalloc((unsigned) (length+1));
	    if (objPtr->bytes != NULL && objPtr->length != 0) {
 	    	memcpy((VOID *) new, (VOID *) objPtr->bytes,
 		    	(size_t) objPtr->length);
 	    	Tcl_InvalidateStringRep(objPtr);
	    }
	}
	objPtr->bytes = new;
	stringPtr->allocated = length;
    }
    
    objPtr->length = length;
    if ((objPtr->bytes != NULL) && (objPtr->bytes != tclEmptyStringRep)) {
	objPtr->bytes[length] = 0;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_AttemptSetObjLength --
 *
 *	This procedure changes the length of the string representation
 *	of an object.  It uses the attempt* (non-panic'ing) memory allocators.
 *
 * Results:
 *	1 if the requested memory was allocated, 0 otherwise.
 *
 * Side effects:
 *	If the size of objPtr's string representation is greater than
 *	length, then it is reduced to length and a new terminating null
 *	byte is stored in the strength.  If the length of the string
 *	representation is greater than length, the storage space is
 *	reallocated to the given length; a null byte is stored at the
 *	end, but other bytes past the end of the original string
 *	representation are undefined.  The object's internal
 *	representation is changed to "expendable string".
 *
 *----------------------------------------------------------------------
 */

int
Tcl_AttemptSetObjLength(objPtr, length)
    register Tcl_Obj *objPtr;	/* Pointer to object.  This object must
				 * not currently be shared. */
    register int length;	/* Number of bytes desired for string
				 * representation of object, not including
				 * terminating null byte. */
{
    char *new;
    String *stringPtr;

    if (Tcl_IsShared(objPtr)) {
	panic("Tcl_AttemptSetObjLength called with shared object");
    }
    SetStringFromAny(NULL, objPtr);
        
    /*
     * Invalidate the unicode data.
     */

    stringPtr = GET_STRING(objPtr);
    stringPtr->numChars = -1;
    stringPtr->uallocated = 0;

    if (length > (int) stringPtr->allocated) {

	/*
	 * Not enough space in current string. Reallocate the string
	 * space and free the old string.
	 */
 	if (objPtr->bytes != tclEmptyStringRep) {
	    new = (char *) attemptckrealloc((char *)objPtr->bytes,
		    (unsigned)(length+1));
	    if (new == NULL) {
		return 0;
	    }
 	} else {
	    new = (char *) attemptckalloc((unsigned) (length+1));
	    if (new == NULL) {
		return 0;
	    }
	    if (objPtr->bytes != NULL && objPtr->length != 0) {
 	    	memcpy((VOID *) new, (VOID *) objPtr->bytes,
 		    	(size_t) objPtr->length);
 	    	Tcl_InvalidateStringRep(objPtr);
	    }
	}
	objPtr->bytes = new;
	stringPtr->allocated = length;
    }
    
    objPtr->length = length;
    if ((objPtr->bytes != NULL) && (objPtr->bytes != tclEmptyStringRep)) {
	objPtr->bytes[length] = 0;
    }
    return 1;
}

/*
 *---------------------------------------------------------------------------
 *
 * TclSetUnicodeObj --
 *
 *	Modify an object to hold the Unicode string indicated by "unicode".
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Memory allocated for new "String" internal rep.
 *
 *---------------------------------------------------------------------------
 */

void
Tcl_SetUnicodeObj(objPtr, unicode, numChars)
    Tcl_Obj *objPtr;		/* The object to set the string of. */
    CONST Tcl_UniChar *unicode;	/* The unicode string used to initialize
				 * the object. */
    int numChars;		/* Number of characters in the unicode
				 * string. */
{
    Tcl_ObjType *typePtr;
    String *stringPtr;
    size_t uallocated;

    if (numChars < 0) {
	numChars = 0;
	if (unicode) {
	    while (unicode[numChars] != 0) { numChars++; }
	}
    }
    uallocated = (numChars + 1) * sizeof(Tcl_UniChar);

    /*
     * Free the internal rep if one exists, and invalidate the string rep.
     */

    typePtr = objPtr->typePtr;
    if ((typePtr != NULL) && (typePtr->freeIntRepProc) != NULL) {
	(*typePtr->freeIntRepProc)(objPtr);
    }
    objPtr->typePtr = &tclStringType;

    /*
     * Allocate enough space for the String structure + Unicode string.
     */
	
    stringPtr = (String *) ckalloc(STRING_SIZE(uallocated));
    stringPtr->numChars = numChars;
    stringPtr->uallocated = uallocated;
    stringPtr->allocated = 0;
    memcpy((VOID *) stringPtr->unicode, (VOID *) unicode, uallocated);
    stringPtr->unicode[numChars] = 0;
    SET_STRING(objPtr, stringPtr);
    Tcl_InvalidateStringRep(objPtr);
    return;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_AppendToObj --
 *
 *	This procedure appends a sequence of bytes to an object.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The bytes at *bytes are appended to the string representation
 *	of objPtr.
 *
 *----------------------------------------------------------------------
 */

void
Tcl_AppendToObj(objPtr, bytes, length)
    register Tcl_Obj *objPtr;	/* Points to the object to append to. */
    CONST char *bytes;		/* Points to the bytes to append to the
				 * object. */
    register int length;	/* The number of bytes to append from
				 * "bytes". If < 0, then append all bytes
				 * up to NULL byte. */
{
    String *stringPtr;

    if (Tcl_IsShared(objPtr)) {
	panic("Tcl_AppendToObj called with shared object");
    }
    
    SetStringFromAny(NULL, objPtr);

    if (length < 0) {
	length = (bytes ? strlen(bytes) : 0);
    }
    if (length == 0) {
	return;
    }

    /*
     * If objPtr has a valid Unicode rep, then append the Unicode
     * conversion of "bytes" to the objPtr's Unicode rep, otherwise
     * append "bytes" to objPtr's string rep.
     */

    stringPtr = GET_STRING(objPtr);
    if (stringPtr->uallocated > 0) {
	AppendUtfToUnicodeRep(objPtr, bytes, length);

	stringPtr = GET_STRING(objPtr);
    } else {
	AppendUtfToUtfRep(objPtr, bytes, length);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_AppendUnicodeToObj --
 *
 *	This procedure appends a Unicode string to an object in the
 *	most efficient manner possible.  Length must be >= 0.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Invalidates the string rep and creates a new Unicode string.
 *
 *----------------------------------------------------------------------
 */

void
Tcl_AppendUnicodeToObj(objPtr, unicode, length)
    register Tcl_Obj *objPtr;	/* Points to the object to append to. */
    CONST Tcl_UniChar *unicode;	/* The unicode string to append to the
			         * object. */
    int length;			/* Number of chars in "unicode". */
{
    String *stringPtr;

    if (Tcl_IsShared(objPtr)) {
	panic("Tcl_AppendUnicodeToObj called with shared object");
    }

    if (length == 0) {
	return;
    }

    SetStringFromAny(NULL, objPtr);
    stringPtr = GET_STRING(objPtr);

    /*
     * If objPtr has a valid Unicode rep, then append the "unicode"
     * to the objPtr's Unicode rep, otherwise the UTF conversion of
     * "unicode" to objPtr's string rep.
     */

    if (stringPtr->uallocated > 0) {
	AppendUnicodeToUnicodeRep(objPtr, unicode, length);
    } else {
	AppendUnicodeToUtfRep(objPtr, unicode, length);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_AppendObjToObj --
 *
 *	This procedure appends the string rep of one object to another.
 *	"objPtr" cannot be a shared object.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The string rep of appendObjPtr is appended to the string 
 *	representation of objPtr.
 *
 *----------------------------------------------------------------------
 */

void
Tcl_AppendObjToObj(objPtr, appendObjPtr)
    Tcl_Obj *objPtr;		/* Points to the object to append to. */
    Tcl_Obj *appendObjPtr;	/* Object to append. */
{
    String *stringPtr;
    int length, numChars, allOneByteChars;
    char *bytes;

    SetStringFromAny(NULL, objPtr);

    /*
     * If objPtr has a valid Unicode rep, then get a Unicode string
     * from appendObjPtr and append it.
     */

    stringPtr = GET_STRING(objPtr);
    if (stringPtr->uallocated > 0) {
	
	/*
	 * If appendObjPtr is not of the "String" type, don't convert it.
	 */

	if (appendObjPtr->typePtr == &tclStringType) {
	    stringPtr = GET_STRING(appendObjPtr);
	    if ((stringPtr->numChars == -1)
		    || (stringPtr->uallocated == 0)) {
		
		/*
		 * If appendObjPtr is a string obj with no valide Unicode
		 * rep, then fill its unicode rep.
		 */

		FillUnicodeRep(appendObjPtr);
		stringPtr = GET_STRING(appendObjPtr);
	    }
	    AppendUnicodeToUnicodeRep(objPtr, stringPtr->unicode,
		    stringPtr->numChars);
	} else {
	    bytes = Tcl_GetStringFromObj(appendObjPtr, &length);
	    AppendUtfToUnicodeRep(objPtr, bytes, length);
	}
	return;
    }

    /*
     * Append to objPtr's UTF string rep.  If we know the number of
     * characters in both objects before appending, then set the combined
     * number of characters in the final (appended-to) object.
     */

    bytes = Tcl_GetStringFromObj(appendObjPtr, &length);

    allOneByteChars = 0;
    numChars = stringPtr->numChars;
    if ((numChars >= 0) && (appendObjPtr->typePtr == &tclStringType)) {
	stringPtr = GET_STRING(appendObjPtr);
	if ((stringPtr->numChars >= 0) && (stringPtr->numChars == length)) {
	    numChars += stringPtr->numChars;
	    allOneByteChars = 1;
	}
    }

    AppendUtfToUtfRep(objPtr, bytes, length);

    if (allOneByteChars) {
	stringPtr = GET_STRING(objPtr);
	stringPtr->numChars = numChars;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * AppendUnicodeToUnicodeRep --
 *
 *	This procedure appends the contents of "unicode" to the Unicode
 *	rep of "objPtr".  objPtr must already have a valid Unicode rep.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	objPtr's internal rep is reallocated.
 *
 *----------------------------------------------------------------------
 */

static void
AppendUnicodeToUnicodeRep(objPtr, unicode, appendNumChars)
    Tcl_Obj *objPtr;	        /* Points to the object to append to. */
    CONST Tcl_UniChar *unicode; /* String to append. */
    int appendNumChars;	        /* Number of chars of "unicode" to append. */
{
    String *stringPtr, *tmpString;
    size_t numChars;

    if (appendNumChars < 0) {
	appendNumChars = 0;
	if (unicode) {
	    while (unicode[appendNumChars] != 0) { appendNumChars++; }
	}
    }
    if (appendNumChars == 0) {
	return;
    }

    SetStringFromAny(NULL, objPtr);
    stringPtr = GET_STRING(objPtr);

    /*
     * If not enough space has been allocated for the unicode rep,
     * reallocate the internal rep object with additional space.  First try to
     * double the required allocation; if that fails, try a more modest
     * increase.  See the "TCL STRING GROWTH ALGORITHM" comment at the top of
     * this file for an explanation of this growth algorithm.
     */

    numChars = stringPtr->numChars + appendNumChars;

    if (numChars >= stringPtr->uallocated) {
 	stringPtr->uallocated = 2 * numChars;
	tmpString = (String *) attemptckrealloc((char *)stringPtr,
		STRING_SIZE(stringPtr->uallocated));
	if (tmpString == NULL) {
	    stringPtr->uallocated =
		numChars + appendNumChars + TCL_GROWTH_MIN_ALLOC;
	    tmpString = (String *) ckrealloc((char *)stringPtr,
		    STRING_SIZE(stringPtr->uallocated));
	}
	stringPtr = tmpString;
	SET_STRING(objPtr, stringPtr);
    }

    /*
     * Copy the new string onto the end of the old string, then add the
     * trailing null.
     */

    memcpy((VOID*) (stringPtr->unicode + stringPtr->numChars), unicode,
	    appendNumChars * sizeof(Tcl_UniChar));
    stringPtr->unicode[numChars] = 0;
    stringPtr->numChars = numChars;

    Tcl_InvalidateStringRep(objPtr);
}

/*
 *----------------------------------------------------------------------
 *
 * AppendUnicodeToUtfRep --
 *
 *	This procedure converts the contents of "unicode" to UTF and
 *	appends the UTF to the string rep of "objPtr".
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	objPtr's internal rep is reallocated.
 *
 *----------------------------------------------------------------------
 */

static void
AppendUnicodeToUtfRep(objPtr, unicode, numChars)
    Tcl_Obj *objPtr;	        /* Points to the object to append to. */
    CONST Tcl_UniChar *unicode; /* String to convert to UTF. */
    int numChars;	        /* Number of chars of "unicode" to convert. */
{
    Tcl_DString dsPtr;
    CONST char *bytes;
    
    if (numChars < 0) {
	numChars = 0;
	if (unicode) {
	    while (unicode[numChars] != 0) { numChars++; }
	}
    }
    if (numChars == 0) {
	return;
    }

    Tcl_DStringInit(&dsPtr);
    bytes = Tcl_UniCharToUtfDString(unicode, numChars, &dsPtr);
    AppendUtfToUtfRep(objPtr, bytes, Tcl_DStringLength(&dsPtr));
    Tcl_DStringFree(&dsPtr);
}

/*
 *----------------------------------------------------------------------
 *
 * AppendUtfToUnicodeRep --
 *
 *	This procedure converts the contents of "bytes" to Unicode and
 *	appends the Unicode to the Unicode rep of "objPtr".  objPtr must
 *	already have a valid Unicode rep.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	objPtr's internal rep is reallocated.
 *
 *----------------------------------------------------------------------
 */

static void
AppendUtfToUnicodeRep(objPtr, bytes, numBytes)
    Tcl_Obj *objPtr;	/* Points to the object to append to. */
    CONST char *bytes;	/* String to convert to Unicode. */
    int numBytes;	/* Number of bytes of "bytes" to convert. */
{
    Tcl_DString dsPtr;
    int numChars;
    Tcl_UniChar *unicode;

    if (numBytes < 0) {
	numBytes = (bytes ? strlen(bytes) : 0);
    }
    if (numBytes == 0) {
	return;
    }
    
    Tcl_DStringInit(&dsPtr);
    numChars = Tcl_NumUtfChars(bytes, numBytes);
    unicode = (Tcl_UniChar *)Tcl_UtfToUniCharDString(bytes, numBytes, &dsPtr);
    AppendUnicodeToUnicodeRep(objPtr, unicode, numChars);
    Tcl_DStringFree(&dsPtr);
}

/*
 *----------------------------------------------------------------------
 *
 * AppendUtfToUtfRep --
 *
 *	This procedure appends "numBytes" bytes of "bytes" to the UTF string
 *	rep of "objPtr".  objPtr must already have a valid String rep.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	objPtr's internal rep is reallocated.
 *
 *----------------------------------------------------------------------
 */

static void
AppendUtfToUtfRep(objPtr, bytes, numBytes)
    Tcl_Obj *objPtr;	/* Points to the object to append to. */
    CONST char *bytes;	/* String to append. */
    int numBytes;	/* Number of bytes of "bytes" to append. */
{
    String *stringPtr;
    int newLength, oldLength;

    if (numBytes < 0) {
	numBytes = (bytes ? strlen(bytes) : 0);
    }
    if (numBytes == 0) {
	return;
    }

    /*
     * Copy the new string onto the end of the old string, then add the
     * trailing null.
     */

    oldLength = objPtr->length;
    newLength = numBytes + oldLength;

    stringPtr = GET_STRING(objPtr);
    if (newLength > (int) stringPtr->allocated) {

	/*
	 * There isn't currently enough space in the string representation
	 * so allocate additional space.  First, try to double the length
	 * required.  If that fails, try a more modest allocation.  See the
	 * "TCL STRING GROWTH ALGORITHM" comment at the top of this file for an
	 * explanation of this growth algorithm.
	 */

	if (Tcl_AttemptSetObjLength(objPtr, 2 * newLength) == 0) {
	    Tcl_SetObjLength(objPtr,
		    newLength + numBytes + TCL_GROWTH_MIN_ALLOC);
	}
    } else {

	/*
	 * Invalidate the unicode data.
	 */
	
	stringPtr->numChars = -1;
	stringPtr->uallocated = 0;
    }
    
    memcpy((VOID *) (objPtr->bytes + oldLength), (VOID *) bytes,
	    (size_t) numBytes);
    objPtr->bytes[newLength] = 0;
    objPtr->length = newLength;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_AppendStringsToObjVA --
 *
 *	This procedure appends one or more null-terminated strings
 *	to an object.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The contents of all the string arguments are appended to the
 *	string representation of objPtr.
 *
 *----------------------------------------------------------------------
 */

void
Tcl_AppendStringsToObjVA (objPtr, argList)
    Tcl_Obj *objPtr;		/* Points to the object to append to. */
    va_list argList;		/* Variable argument list. */
{
#define STATIC_LIST_SIZE 16
    String *stringPtr;
    int newLength, oldLength, attemptLength;
    register char *string, *dst;
    char *static_list[STATIC_LIST_SIZE];
    char **args = static_list;
    int nargs_space = STATIC_LIST_SIZE;
    int nargs, i;

    if (Tcl_IsShared(objPtr)) {
	panic("Tcl_AppendStringsToObj called with shared object");
    }

    SetStringFromAny(NULL, objPtr);

    /*
     * Figure out how much space is needed for all the strings, and
     * expand the string representation if it isn't big enough. If no
     * bytes would be appended, just return.  Note that on some platforms
     * (notably OS/390) the argList is an array so we need to use memcpy.
     */

    nargs = 0;
    newLength = 0;
    oldLength = objPtr->length;
    while (1) {
	string = va_arg(argList, char *);
	if (string == NULL) {
	    break;
	}
 	if (nargs >= nargs_space) {
 	    /* 
 	     * Expand the args buffer
 	     */
 	    nargs_space += STATIC_LIST_SIZE;
 	    if (args == static_list) {
 	    	args = (void *)ckalloc(nargs_space * sizeof(char *));
 		for (i = 0; i < nargs; ++i) {
 		    args[i] = static_list[i];
 		}
 	    } else {
 		args = (void *)ckrealloc((void *)args,
			nargs_space * sizeof(char *));
 	    }
 	}
	newLength += strlen(string);
	args[nargs++] = string;
    }
    if (newLength == 0) {
	goto done;
    }

    stringPtr = GET_STRING(objPtr);
    if (oldLength + newLength > (int) stringPtr->allocated) {

	/*
	 * There isn't currently enough space in the string
	 * representation, so allocate additional space.  If the current
	 * string representation isn't empty (i.e. it looks like we're
	 * doing a series of appends) then try to allocate extra space to
	 * accomodate future growth: first try to double the required memory;
	 * if that fails, try a more modest allocation.  See the "TCL STRING
	 * GROWTH ALGORITHM" comment at the top of this file for an explanation
	 * of this growth algorithm.  Otherwise, if the current string
	 * representation is empty, exactly enough memory is allocated.
	 */

	if (oldLength == 0) {
	    Tcl_SetObjLength(objPtr, newLength);
	} else {
	    attemptLength = 2 * (oldLength + newLength);
	    if (Tcl_AttemptSetObjLength(objPtr, attemptLength) == 0) {
		attemptLength = oldLength + (2 * newLength) +
		    TCL_GROWTH_MIN_ALLOC;
		Tcl_SetObjLength(objPtr, attemptLength);
	    }
	}
    }

    /*
     * Make a second pass through the arguments, appending all the
     * strings to the object.
     */

    dst = objPtr->bytes + oldLength;
    for (i = 0; i < nargs; ++i) {
 	string = args[i];
	if (string == NULL) {
	    break;
	}
	while (*string != 0) {
	    *dst = *string;
	    dst++;
	    string++;
	}
    }

    /*
     * Add a null byte to terminate the string.  However, be careful:
     * it's possible that the object is totally empty (if it was empty
     * originally and there was nothing to append).  In this case dst is
     * NULL; just leave everything alone.
     */

    if (dst != NULL) {
	*dst = 0;
    }
    objPtr->length = oldLength + newLength;

    done:
    /*
     * If we had to allocate a buffer from the heap, 
     * free it now.
     */
 
    if (args != static_list) {
     	ckfree((void *)args);
    }
#undef STATIC_LIST_SIZE
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_AppendStringsToObj --
 *
 *	This procedure appends one or more null-terminated strings
 *	to an object.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The contents of all the string arguments are appended to the
 *	string representation of objPtr.
 *
 *----------------------------------------------------------------------
 */

void
Tcl_AppendStringsToObj TCL_VARARGS_DEF(Tcl_Obj *,arg1)
{
    register Tcl_Obj *objPtr;
    va_list argList;

    objPtr = TCL_VARARGS_START(Tcl_Obj *,arg1,argList);
    Tcl_AppendStringsToObjVA(objPtr, argList);
    va_end(argList);
}

/*
 *---------------------------------------------------------------------------
 *
 * FillUnicodeRep --
 *
 *	Populate the Unicode internal rep with the Unicode form of its string
 *	rep.  The object must alread have a "String" internal rep.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Reallocates the String internal rep.
 *
 *---------------------------------------------------------------------------
 */

static void
FillUnicodeRep(objPtr)
    Tcl_Obj *objPtr;	/* The object in which to fill the unicode rep. */
{
    String *stringPtr;
    size_t uallocated;
    char *src, *srcEnd;
    Tcl_UniChar *dst;
    src = objPtr->bytes;
    
    stringPtr = GET_STRING(objPtr);
    if (stringPtr->numChars == -1) {
	stringPtr->numChars = Tcl_NumUtfChars(src, objPtr->length);
    }

    uallocated = stringPtr->numChars * sizeof(Tcl_UniChar);
    if (uallocated > stringPtr->uallocated) {
    
	/*
	 * If not enough space has been allocated for the unicode rep,
	 * reallocate the internal rep object.
	 */

	/*
	 * There isn't currently enough space in the Unicode
	 * representation so allocate additional space.  If the current
	 * Unicode representation isn't empty (i.e. it looks like we've
	 * done some appends) then overallocate the space so
	 * that we won't have to do as much reallocation in the future.
	 */

	if (stringPtr->uallocated > 0) {
	    uallocated *= 2;
	}
	stringPtr = (String *) ckrealloc((char*) stringPtr,
		STRING_SIZE(uallocated));
	stringPtr->uallocated = uallocated;
    }

    /*
     * Convert src to Unicode and store the coverted data in "unicode".
     */
    
    srcEnd = src + objPtr->length;
    for (dst = stringPtr->unicode; src < srcEnd; dst++) {
	src += Tcl_UtfToUniChar(src, dst);
    }
    *dst = 0;
    
    SET_STRING(objPtr, stringPtr);
}

/*
 *----------------------------------------------------------------------
 *
 * DupStringInternalRep --
 *
 *	Initialize the internal representation of a new Tcl_Obj to a
 *	copy of the internal representation of an existing string object.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	copyPtr's internal rep is set to a copy of srcPtr's internal
 *	representation.
 *
 *----------------------------------------------------------------------
 */

static void
DupStringInternalRep(srcPtr, copyPtr)
    register Tcl_Obj *srcPtr;	/* Object with internal rep to copy.  Must
				 * have an internal rep of type "String". */
    register Tcl_Obj *copyPtr;	/* Object with internal rep to set.  Must
				 * not currently have an internal rep.*/
{
    String *srcStringPtr = GET_STRING(srcPtr);
    String *copyStringPtr = NULL;

    /*
     * If the src obj is a string of 1-byte Utf chars, then copy the
     * string rep of the source object and create an "empty" Unicode
     * internal rep for the new object.  Otherwise, copy Unicode
     * internal rep, and invalidate the string rep of the new object.
     */
    
    if (srcStringPtr->uallocated == 0) {
    	copyStringPtr = (String *) ckalloc(sizeof(String));
	copyStringPtr->uallocated = 0;
    } else {
	copyStringPtr = (String *) ckalloc(
	    STRING_SIZE(srcStringPtr->uallocated));
	copyStringPtr->uallocated = srcStringPtr->uallocated;

	memcpy((VOID *) copyStringPtr->unicode,
		(VOID *) srcStringPtr->unicode,
		(size_t) srcStringPtr->numChars * sizeof(Tcl_UniChar));
	copyStringPtr->unicode[srcStringPtr->numChars] = 0;
    }
    copyStringPtr->numChars = srcStringPtr->numChars;
    copyStringPtr->allocated = srcStringPtr->allocated;

    /*
     * Tricky point: the string value was copied by generic object
     * management code, so it doesn't contain any extra bytes that
     * might exist in the source object.
     */

    copyStringPtr->allocated = copyPtr->length;

    SET_STRING(copyPtr, copyStringPtr);
    copyPtr->typePtr = &tclStringType;
}

/*
 *----------------------------------------------------------------------
 *
 * SetStringFromAny --
 *
 *	Create an internal representation of type "String" for an object.
 *
 * Results:
 *	This operation always succeeds and returns TCL_OK.
 *
 * Side effects:
 *	Any old internal reputation for objPtr is freed and the
 *	internal representation is set to "String".
 *
 *----------------------------------------------------------------------
 */

static int
SetStringFromAny(interp, objPtr)
    Tcl_Interp *interp;		/* Used for error reporting if not NULL. */
    register Tcl_Obj *objPtr;	/* The object to convert. */
{
    /*
     * The Unicode object is opitmized for the case where each UTF char
     * in a string is only one byte.  In this case, we store the value of
     * numChars, but we don't copy the bytes to the unicodeObj->unicode.
     */

    if (objPtr->typePtr != &tclStringType) {
	String *stringPtr;

	if (objPtr->typePtr != NULL) {
	    if (objPtr->bytes == NULL) {
		objPtr->typePtr->updateStringProc(objPtr);
	    }
	    if ((objPtr->typePtr->freeIntRepProc) != NULL) {
		(*objPtr->typePtr->freeIntRepProc)(objPtr);
	    }
	}
	objPtr->typePtr = &tclStringType;

	/*
	 * Allocate enough space for the basic String structure.
	 */

	stringPtr = (String *) ckalloc(sizeof(String));
	stringPtr->numChars = -1;
	stringPtr->uallocated = 0;

	if (objPtr->bytes != NULL) {
	    stringPtr->allocated = objPtr->length;	    
 	    objPtr->bytes[objPtr->length] = 0;
	} else {
	    objPtr->length = 0;
	}
	SET_STRING(objPtr, stringPtr);
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * UpdateStringOfString --
 *
 *	Update the string representation for an object whose internal
 *	representation is "String".
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The object's string may be set by converting its Unicode
 *	represention to UTF format.
 *
 *----------------------------------------------------------------------
 */

static void
UpdateStringOfString(objPtr)
    Tcl_Obj *objPtr;		/* Object with string rep to update. */
{
    int i, length, size;
    Tcl_UniChar *unicode;
    char dummy[TCL_UTF_MAX];
    char *dst;
    String *stringPtr;

    stringPtr = GET_STRING(objPtr);
    if ((objPtr->bytes == NULL) || (stringPtr->allocated == 0)) {

	if (stringPtr->numChars <= 0) {

	    /*
	     * If there is no Unicode rep, or the string has 0 chars,
	     * then set the string rep to an empty string.
	     */

	    objPtr->bytes = tclEmptyStringRep;
	    objPtr->length = 0;
	    return;
	}

	unicode = stringPtr->unicode;
	length = stringPtr->numChars * sizeof(Tcl_UniChar);

	/*
	 * Translate the Unicode string to UTF.  "size" will hold the
	 * amount of space the UTF string needs.
	 */

	size = 0;
	for (i = 0; i < stringPtr->numChars; i++) {
	    size += Tcl_UniCharToUtf((int) unicode[i], dummy);
	}
	
	dst = (char *) ckalloc((unsigned) (size + 1));
	objPtr->bytes = dst;
	objPtr->length = size;
	stringPtr->allocated = size;

	for (i = 0; i < stringPtr->numChars; i++) {
	    dst += Tcl_UniCharToUtf(unicode[i], dst);
	}
	*dst = '\0';
    }
    return;
}

/*
 *----------------------------------------------------------------------
 *
 * FreeStringInternalRep --
 *
 *	Deallocate the storage associated with a String data object's
 *	internal representation.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Frees memory. 
 *
 *----------------------------------------------------------------------
 */

static void
FreeStringInternalRep(objPtr)
    Tcl_Obj *objPtr;		/* Object with internal rep to free. */
{
    ckfree((char *) GET_STRING(objPtr));
}
@


1.4
log
@touched all sources to ease next import
@
text
@d36 1
a36 2
 * RCS: @@(#) $Id: tclStringObj.c,v 1.6.8.1 2000/04/06 22:38:29 spolk Exp $
 */
d45 1
a45 1
    			    Tcl_Obj *objPtr, Tcl_UniChar *unicode,
d48 1
a48 1
    			    Tcl_Obj *objPtr, Tcl_UniChar *unicode,
d51 1
a51 1
    			    char *bytes, int numBytes));
d53 1
a53 1
    			    char *bytes, int numBytes));
d111 38
d222 3
a224 3
 *	caller. This simplifies debugging since then the checkmem command
 *	will report the correct file name and line number when reporting
 *	objects that haven't been freed.
d253 1
a253 1
    char *file;			/* The name of the source file calling this
d278 1
a278 1
    char *file;			/* The name of the source file calling this
d290 1
a290 1
 * TclNewUnicodeObj --
d293 1
a293 1
 *	it from the given Utf String.  If the Utf String is the same size
d309 1
a309 1
    Tcl_UniChar *unicode;	/* The unicode string used to initialize
d523 57
d596 1
a596 1
Tcl_Obj*
d598 1
a598 2
   
 Tcl_Obj *objPtr;		/* The Tcl object to find the range of. */
d676 1
a676 1
    char *bytes;		/* Points to the first of the length bytes
d764 44
d809 46
a854 5
	new = (char *) ckalloc((unsigned) (length+1));
	if (objPtr->bytes != NULL) {
	    memcpy((VOID *) new, (VOID *) objPtr->bytes,
		    (size_t) objPtr->length);
	    Tcl_InvalidateStringRep(objPtr);
d864 1
d886 1
a886 1
    Tcl_UniChar *unicode;	/* The unicode string used to initialize
d948 1
a948 1
    char *bytes;		/* Points to the bytes to append to the
d1005 1
a1005 1
    Tcl_UniChar *unicode;	/* The unicode string to append to the
d1020 1
a1020 9

    /*
     * TEMPORARY!!!  This is terribly inefficient, but it works, and Don
     * needs for me to check this stuff in ASAP.  -Melissa
     */
    
/*     UpdateStringOfString(objPtr); */
/*     AppendUnicodeToUtfRep(objPtr, unicode, length); */
/*     return; */
a1027 1
    stringPtr = GET_STRING(objPtr);
d1143 3
a1145 3
    Tcl_Obj *objPtr;	      /* Points to the object to append to. */
    Tcl_UniChar *unicode;     /* String to append. */
    int appendNumChars;	      /* Number of chars of "unicode" to append. */
d1147 2
a1148 3
    String *stringPtr;
    int numChars;
    size_t newSize;
d1162 1
a1162 1
    
d1165 4
a1168 3
     * reallocate the internal rep object with double the amount of
     * space needed, so the unicode string can grow without being
     * reallocated.
a1171 1
    newSize = (numChars + 1) * sizeof(Tcl_UniChar);
d1173 3
a1175 3
    if (newSize > stringPtr->uallocated) {
	stringPtr->uallocated = newSize * 2;
	stringPtr = (String *) ckrealloc((char*)stringPtr,
d1177 7
a1196 1
    SET_STRING(objPtr, stringPtr);
d1219 3
a1221 3
    Tcl_Obj *objPtr;	      /* Points to the object to append to. */
    Tcl_UniChar *unicode;     /* String to convert to UTF. */
    int numChars;	      /* Number of chars of "unicode" to convert. */
d1224 1
a1224 1
    char *bytes;
d1237 1
a1237 1
    bytes = (char *)Tcl_UniCharToUtfDString(unicode, numChars, &dsPtr);
d1263 1
a1263 1
    char *bytes;		/* String to convert to Unicode. */
d1304 1
a1304 1
    char *bytes;	/* String to append. */
d1329 5
a1333 4
	 * There isn't currently enough space in the string
	 * representation so allocate additional space.  Overallocate the
	 * space by doubling it so that we won't have to do as much
	 * reallocation in the future.
d1336 4
a1339 1
	Tcl_SetObjLength(objPtr, 2*newLength);
d1381 1
a1381 1
    int newLength, oldLength;
d1402 2
a1403 1
    newLength = oldLength = objPtr->length;
d1427 1
a1427 1
    if (newLength == oldLength) {
d1432 1
a1432 1
    if (newLength > (int) stringPtr->allocated) {
d1436 1
a1436 1
	 * representation so allocate additional space.  If the current
d1438 6
a1443 2
	 * doing a series of appends) then overallocate the space so
	 * that we won't have to do as much reallocation in the future.
d1446 10
a1455 2
	Tcl_SetObjLength(objPtr,
		(objPtr->length == 0) ? newLength : 2*newLength);
d1486 1
a1486 1
    objPtr->length = newLength;
d1681 1
a1681 1
    Tcl_Obj *objPtr;		/* The object to convert. */
a1682 2
    String *stringPtr;

d1690 1
@


1.3
log
@touched all sources to ease next import
@
text
@@


1.3.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d36 2
a37 1
 * RCS: @@(#) $Id: tclStringObj.c,v 1.24 2002/01/26 01:10:08 dgp Exp $ */
d46 1
a46 1
    			    Tcl_Obj *objPtr, CONST Tcl_UniChar *unicode,
d49 1
a49 1
    			    Tcl_Obj *objPtr, CONST Tcl_UniChar *unicode,
d52 1
a52 1
    			    CONST char *bytes, int numBytes));
d54 1
a54 1
    			    CONST char *bytes, int numBytes));
a111 38
/*
 * TCL STRING GROWTH ALGORITHM
 *
 * When growing strings (during an append, for example), the following growth
 * algorithm is used:
 *
 *   Attempt to allocate 2 * (originalLength + appendLength)
 *   On failure:
 *	attempt to allocate originalLength + 2*appendLength +
 *			TCL_GROWTH_MIN_ALLOC 
 *
 * This algorithm allows very good performance, as it rapidly increases the
 * memory allocated for a given string, which minimizes the number of
 * reallocations that must be performed.  However, using only the doubling
 * algorithm can lead to a significant waste of memory.  In particular, it
 * may fail even when there is sufficient memory available to complete the
 * append request (but there is not 2 * totalLength memory available).  So when
 * the doubling fails (because there is not enough memory available), the
 * algorithm requests a smaller amount of memory, which is still enough to
 * cover the request, but which hopefully will be less than the total available
 * memory.
 * 
 * The addition of TCL_GROWTH_MIN_ALLOC allows for efficient handling
 * of very small appends.  Without this extra slush factor, a sequence
 * of several small appends would cause several memory allocations.
 * As long as TCL_GROWTH_MIN_ALLOC is a reasonable size, we can
 * avoid that behavior.
 *
 * The growth algorithm can be tuned by adjusting the following parameters:
 *
 * TCL_GROWTH_MIN_ALLOC		Additional space, in bytes, to allocate when
 *				the double allocation has failed.
 *				Default is 1024 (1 kilobyte).
 */
#ifndef TCL_GROWTH_MIN_ALLOC
#define TCL_GROWTH_MIN_ALLOC	1024
#endif

d185 3
a187 3
 *	caller. This simplifies debugging since then the [memory active]
 *	command	will report the correct file name and line number when
 *	reporting objects that haven't been freed.
d216 1
a216 1
    CONST char *file;		/* The name of the source file calling this
d241 1
a241 1
    CONST char *file;		/* The name of the source file calling this
d253 1
a253 1
 * Tcl_NewUnicodeObj --
d256 1
a256 1
 *	it from the given Unicode String.  If the Utf String is the same size
d272 1
a272 1
    CONST Tcl_UniChar *unicode;	/* The unicode string used to initialize
a485 57
 * Tcl_GetUnicodeFromObj --
 *
 *	Get the Unicode form of the String object with length.  If
 *	the object is not already a String object, it will be converted
 *	to one.  If the String object does not have a Unicode rep, then
 *	one is create from the UTF string format.
 *
 * Results:
 *	Returns a pointer to the object's internal Unicode string.
 *
 * Side effects:
 *	Converts the object to have the String internal rep.
 *
 *----------------------------------------------------------------------
 */

Tcl_UniChar *
Tcl_GetUnicodeFromObj(objPtr, lengthPtr)
    Tcl_Obj *objPtr;	/* The object to find the unicode string for. */
    int *lengthPtr;	/* If non-NULL, the location where the
			 * string rep's unichar length should be
			 * stored. If NULL, no length is stored. */
{
    String *stringPtr;
    
    SetStringFromAny(NULL, objPtr);
    stringPtr = GET_STRING(objPtr);
    
    if ((stringPtr->numChars == -1) || (stringPtr->uallocated == 0)) {

	/*
	 * We haven't yet calculated the length, or all of the characters
	 * in the Utf string are 1 byte chars (so we didn't store the
	 * unicode str).  Since this function must return a unicode string,
	 * and one has not yet been stored, force the Unicode to be
	 * calculated and stored now.
	 */

	FillUnicodeRep(objPtr);

	/*
	 * We need to fetch the pointer again because we have just
	 * reallocated the structure to make room for the Unicode data.
	 */
	
	stringPtr = GET_STRING(objPtr);
    }

    if (lengthPtr != NULL) {
	*lengthPtr = stringPtr->numChars;
    }
    return stringPtr->unicode;
}

/*
 *----------------------------------------------------------------------
 *
d502 1
a502 1
Tcl_Obj *
d504 2
a505 1
    Tcl_Obj *objPtr;		/* The Tcl object to find the range of. */
d583 1
a583 1
    CONST char *bytes;		/* Points to the first of the length bytes
a670 44
 	if (objPtr->bytes != tclEmptyStringRep) {
	    new = (char *) ckrealloc((char *)objPtr->bytes,
		    (unsigned)(length+1));
	} else {
	    new = (char *) ckalloc((unsigned) (length+1));
	    if (objPtr->bytes != NULL && objPtr->length != 0) {
 	    	memcpy((VOID *) new, (VOID *) objPtr->bytes,
 		    	(size_t) objPtr->length);
 	    	Tcl_InvalidateStringRep(objPtr);
	    }
	}
	objPtr->bytes = new;
	stringPtr->allocated = length;
    }
    
    objPtr->length = length;
    if ((objPtr->bytes != NULL) && (objPtr->bytes != tclEmptyStringRep)) {
	objPtr->bytes[length] = 0;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_AttemptSetObjLength --
 *
 *	This procedure changes the length of the string representation
 *	of an object.  It uses the attempt* (non-panic'ing) memory allocators.
 *
 * Results:
 *	1 if the requested memory was allocated, 0 otherwise.
 *
 * Side effects:
 *	If the size of objPtr's string representation is greater than
 *	length, then it is reduced to length and a new terminating null
 *	byte is stored in the strength.  If the length of the string
 *	representation is greater than length, the storage space is
 *	reallocated to the given length; a null byte is stored at the
 *	end, but other bytes past the end of the original string
 *	representation are undefined.  The object's internal
 *	representation is changed to "expendable string".
 *
 *----------------------------------------------------------------------
 */
d672 5
a676 46
int
Tcl_AttemptSetObjLength(objPtr, length)
    register Tcl_Obj *objPtr;	/* Pointer to object.  This object must
				 * not currently be shared. */
    register int length;	/* Number of bytes desired for string
				 * representation of object, not including
				 * terminating null byte. */
{
    char *new;
    String *stringPtr;

    if (Tcl_IsShared(objPtr)) {
	panic("Tcl_AttemptSetObjLength called with shared object");
    }
    SetStringFromAny(NULL, objPtr);
        
    /*
     * Invalidate the unicode data.
     */

    stringPtr = GET_STRING(objPtr);
    stringPtr->numChars = -1;
    stringPtr->uallocated = 0;

    if (length > (int) stringPtr->allocated) {

	/*
	 * Not enough space in current string. Reallocate the string
	 * space and free the old string.
	 */
 	if (objPtr->bytes != tclEmptyStringRep) {
	    new = (char *) attemptckrealloc((char *)objPtr->bytes,
		    (unsigned)(length+1));
	    if (new == NULL) {
		return 0;
	    }
 	} else {
	    new = (char *) attemptckalloc((unsigned) (length+1));
	    if (new == NULL) {
		return 0;
	    }
	    if (objPtr->bytes != NULL && objPtr->length != 0) {
 	    	memcpy((VOID *) new, (VOID *) objPtr->bytes,
 		    	(size_t) objPtr->length);
 	    	Tcl_InvalidateStringRep(objPtr);
	    }
a685 1
    return 1;
d707 1
a707 1
    CONST Tcl_UniChar *unicode;	/* The unicode string used to initialize
d769 1
a769 1
    CONST char *bytes;		/* Points to the bytes to append to the
d826 1
a826 1
    CONST Tcl_UniChar *unicode;	/* The unicode string to append to the
d841 9
a849 1
    stringPtr = GET_STRING(objPtr);
d857 1
d973 3
a975 3
    Tcl_Obj *objPtr;	        /* Points to the object to append to. */
    CONST Tcl_UniChar *unicode; /* String to append. */
    int appendNumChars;	        /* Number of chars of "unicode" to append. */
d977 3
a979 2
    String *stringPtr, *tmpString;
    size_t numChars;
d993 1
a993 1

d996 3
a998 4
     * reallocate the internal rep object with additional space.  First try to
     * double the required allocation; if that fails, try a more modest
     * increase.  See the "TCL STRING GROWTH ALGORITHM" comment at the top of
     * this file for an explanation of this growth algorithm.
d1002 1
d1004 3
a1006 3
    if (numChars >= stringPtr->uallocated) {
 	stringPtr->uallocated = 2 * numChars;
	tmpString = (String *) attemptckrealloc((char *)stringPtr,
a1007 7
	if (tmpString == NULL) {
	    stringPtr->uallocated =
		numChars + appendNumChars + TCL_GROWTH_MIN_ALLOC;
	    tmpString = (String *) ckrealloc((char *)stringPtr,
		    STRING_SIZE(stringPtr->uallocated));
	}
	stringPtr = tmpString;
d1021 1
d1044 3
a1046 3
    Tcl_Obj *objPtr;	        /* Points to the object to append to. */
    CONST Tcl_UniChar *unicode; /* String to convert to UTF. */
    int numChars;	        /* Number of chars of "unicode" to convert. */
d1049 1
a1049 1
    CONST char *bytes;
d1062 1
a1062 1
    bytes = Tcl_UniCharToUtfDString(unicode, numChars, &dsPtr);
d1088 1
a1088 1
    CONST char *bytes;	/* String to convert to Unicode. */
d1129 1
a1129 1
    CONST char *bytes;	/* String to append. */
d1154 4
a1157 5
	 * There isn't currently enough space in the string representation
	 * so allocate additional space.  First, try to double the length
	 * required.  If that fails, try a more modest allocation.  See the
	 * "TCL STRING GROWTH ALGORITHM" comment at the top of this file for an
	 * explanation of this growth algorithm.
d1160 1
a1160 4
	if (Tcl_AttemptSetObjLength(objPtr, 2 * newLength) == 0) {
	    Tcl_SetObjLength(objPtr,
		    newLength + numBytes + TCL_GROWTH_MIN_ALLOC);
	}
d1202 1
a1202 1
    int newLength, oldLength, attemptLength;
d1223 1
a1223 2
    newLength = 0;
    oldLength = objPtr->length;
d1247 1
a1247 1
    if (newLength == 0) {
d1252 1
a1252 1
    if (oldLength + newLength > (int) stringPtr->allocated) {
d1256 1
a1256 1
	 * representation, so allocate additional space.  If the current
d1258 2
a1259 6
	 * doing a series of appends) then try to allocate extra space to
	 * accomodate future growth: first try to double the required memory;
	 * if that fails, try a more modest allocation.  See the "TCL STRING
	 * GROWTH ALGORITHM" comment at the top of this file for an explanation
	 * of this growth algorithm.  Otherwise, if the current string
	 * representation is empty, exactly enough memory is allocated.
d1262 2
a1263 10
	if (oldLength == 0) {
	    Tcl_SetObjLength(objPtr, newLength);
	} else {
	    attemptLength = 2 * (oldLength + newLength);
	    if (Tcl_AttemptSetObjLength(objPtr, attemptLength) == 0) {
		attemptLength = oldLength + (2 * newLength) +
		    TCL_GROWTH_MIN_ALLOC;
		Tcl_SetObjLength(objPtr, attemptLength);
	    }
	}
d1294 1
a1294 1
    objPtr->length = oldLength + newLength;
d1489 1
a1489 1
    register Tcl_Obj *objPtr;	/* The object to convert. */
d1491 2
a1499 1
	String *stringPtr;
@


1.3.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@d36 2
a37 1
 * RCS: @@(#) $Id: tclStringObj.c,v 1.24 2002/01/26 01:10:08 dgp Exp $ */
d46 1
a46 1
    			    Tcl_Obj *objPtr, CONST Tcl_UniChar *unicode,
d49 1
a49 1
    			    Tcl_Obj *objPtr, CONST Tcl_UniChar *unicode,
d52 1
a52 1
    			    CONST char *bytes, int numBytes));
d54 1
a54 1
    			    CONST char *bytes, int numBytes));
a111 38
/*
 * TCL STRING GROWTH ALGORITHM
 *
 * When growing strings (during an append, for example), the following growth
 * algorithm is used:
 *
 *   Attempt to allocate 2 * (originalLength + appendLength)
 *   On failure:
 *	attempt to allocate originalLength + 2*appendLength +
 *			TCL_GROWTH_MIN_ALLOC 
 *
 * This algorithm allows very good performance, as it rapidly increases the
 * memory allocated for a given string, which minimizes the number of
 * reallocations that must be performed.  However, using only the doubling
 * algorithm can lead to a significant waste of memory.  In particular, it
 * may fail even when there is sufficient memory available to complete the
 * append request (but there is not 2 * totalLength memory available).  So when
 * the doubling fails (because there is not enough memory available), the
 * algorithm requests a smaller amount of memory, which is still enough to
 * cover the request, but which hopefully will be less than the total available
 * memory.
 * 
 * The addition of TCL_GROWTH_MIN_ALLOC allows for efficient handling
 * of very small appends.  Without this extra slush factor, a sequence
 * of several small appends would cause several memory allocations.
 * As long as TCL_GROWTH_MIN_ALLOC is a reasonable size, we can
 * avoid that behavior.
 *
 * The growth algorithm can be tuned by adjusting the following parameters:
 *
 * TCL_GROWTH_MIN_ALLOC		Additional space, in bytes, to allocate when
 *				the double allocation has failed.
 *				Default is 1024 (1 kilobyte).
 */
#ifndef TCL_GROWTH_MIN_ALLOC
#define TCL_GROWTH_MIN_ALLOC	1024
#endif

d185 3
a187 3
 *	caller. This simplifies debugging since then the [memory active]
 *	command	will report the correct file name and line number when
 *	reporting objects that haven't been freed.
d216 1
a216 1
    CONST char *file;		/* The name of the source file calling this
d241 1
a241 1
    CONST char *file;		/* The name of the source file calling this
d253 1
a253 1
 * Tcl_NewUnicodeObj --
d256 1
a256 1
 *	it from the given Unicode String.  If the Utf String is the same size
d272 1
a272 1
    CONST Tcl_UniChar *unicode;	/* The unicode string used to initialize
a485 57
 * Tcl_GetUnicodeFromObj --
 *
 *	Get the Unicode form of the String object with length.  If
 *	the object is not already a String object, it will be converted
 *	to one.  If the String object does not have a Unicode rep, then
 *	one is create from the UTF string format.
 *
 * Results:
 *	Returns a pointer to the object's internal Unicode string.
 *
 * Side effects:
 *	Converts the object to have the String internal rep.
 *
 *----------------------------------------------------------------------
 */

Tcl_UniChar *
Tcl_GetUnicodeFromObj(objPtr, lengthPtr)
    Tcl_Obj *objPtr;	/* The object to find the unicode string for. */
    int *lengthPtr;	/* If non-NULL, the location where the
			 * string rep's unichar length should be
			 * stored. If NULL, no length is stored. */
{
    String *stringPtr;
    
    SetStringFromAny(NULL, objPtr);
    stringPtr = GET_STRING(objPtr);
    
    if ((stringPtr->numChars == -1) || (stringPtr->uallocated == 0)) {

	/*
	 * We haven't yet calculated the length, or all of the characters
	 * in the Utf string are 1 byte chars (so we didn't store the
	 * unicode str).  Since this function must return a unicode string,
	 * and one has not yet been stored, force the Unicode to be
	 * calculated and stored now.
	 */

	FillUnicodeRep(objPtr);

	/*
	 * We need to fetch the pointer again because we have just
	 * reallocated the structure to make room for the Unicode data.
	 */
	
	stringPtr = GET_STRING(objPtr);
    }

    if (lengthPtr != NULL) {
	*lengthPtr = stringPtr->numChars;
    }
    return stringPtr->unicode;
}

/*
 *----------------------------------------------------------------------
 *
d502 1
a502 1
Tcl_Obj *
d504 2
a505 1
    Tcl_Obj *objPtr;		/* The Tcl object to find the range of. */
d583 1
a583 1
    CONST char *bytes;		/* Points to the first of the length bytes
a670 44
 	if (objPtr->bytes != tclEmptyStringRep) {
	    new = (char *) ckrealloc((char *)objPtr->bytes,
		    (unsigned)(length+1));
	} else {
	    new = (char *) ckalloc((unsigned) (length+1));
	    if (objPtr->bytes != NULL && objPtr->length != 0) {
 	    	memcpy((VOID *) new, (VOID *) objPtr->bytes,
 		    	(size_t) objPtr->length);
 	    	Tcl_InvalidateStringRep(objPtr);
	    }
	}
	objPtr->bytes = new;
	stringPtr->allocated = length;
    }
    
    objPtr->length = length;
    if ((objPtr->bytes != NULL) && (objPtr->bytes != tclEmptyStringRep)) {
	objPtr->bytes[length] = 0;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_AttemptSetObjLength --
 *
 *	This procedure changes the length of the string representation
 *	of an object.  It uses the attempt* (non-panic'ing) memory allocators.
 *
 * Results:
 *	1 if the requested memory was allocated, 0 otherwise.
 *
 * Side effects:
 *	If the size of objPtr's string representation is greater than
 *	length, then it is reduced to length and a new terminating null
 *	byte is stored in the strength.  If the length of the string
 *	representation is greater than length, the storage space is
 *	reallocated to the given length; a null byte is stored at the
 *	end, but other bytes past the end of the original string
 *	representation are undefined.  The object's internal
 *	representation is changed to "expendable string".
 *
 *----------------------------------------------------------------------
 */
d672 5
a676 46
int
Tcl_AttemptSetObjLength(objPtr, length)
    register Tcl_Obj *objPtr;	/* Pointer to object.  This object must
				 * not currently be shared. */
    register int length;	/* Number of bytes desired for string
				 * representation of object, not including
				 * terminating null byte. */
{
    char *new;
    String *stringPtr;

    if (Tcl_IsShared(objPtr)) {
	panic("Tcl_AttemptSetObjLength called with shared object");
    }
    SetStringFromAny(NULL, objPtr);
        
    /*
     * Invalidate the unicode data.
     */

    stringPtr = GET_STRING(objPtr);
    stringPtr->numChars = -1;
    stringPtr->uallocated = 0;

    if (length > (int) stringPtr->allocated) {

	/*
	 * Not enough space in current string. Reallocate the string
	 * space and free the old string.
	 */
 	if (objPtr->bytes != tclEmptyStringRep) {
	    new = (char *) attemptckrealloc((char *)objPtr->bytes,
		    (unsigned)(length+1));
	    if (new == NULL) {
		return 0;
	    }
 	} else {
	    new = (char *) attemptckalloc((unsigned) (length+1));
	    if (new == NULL) {
		return 0;
	    }
	    if (objPtr->bytes != NULL && objPtr->length != 0) {
 	    	memcpy((VOID *) new, (VOID *) objPtr->bytes,
 		    	(size_t) objPtr->length);
 	    	Tcl_InvalidateStringRep(objPtr);
	    }
a685 1
    return 1;
d707 1
a707 1
    CONST Tcl_UniChar *unicode;	/* The unicode string used to initialize
d769 1
a769 1
    CONST char *bytes;		/* Points to the bytes to append to the
d826 1
a826 1
    CONST Tcl_UniChar *unicode;	/* The unicode string to append to the
d841 9
a849 1
    stringPtr = GET_STRING(objPtr);
d857 1
d973 3
a975 3
    Tcl_Obj *objPtr;	        /* Points to the object to append to. */
    CONST Tcl_UniChar *unicode; /* String to append. */
    int appendNumChars;	        /* Number of chars of "unicode" to append. */
d977 3
a979 2
    String *stringPtr, *tmpString;
    size_t numChars;
d993 1
a993 1

d996 3
a998 4
     * reallocate the internal rep object with additional space.  First try to
     * double the required allocation; if that fails, try a more modest
     * increase.  See the "TCL STRING GROWTH ALGORITHM" comment at the top of
     * this file for an explanation of this growth algorithm.
d1002 1
d1004 3
a1006 3
    if (numChars >= stringPtr->uallocated) {
 	stringPtr->uallocated = 2 * numChars;
	tmpString = (String *) attemptckrealloc((char *)stringPtr,
a1007 7
	if (tmpString == NULL) {
	    stringPtr->uallocated =
		numChars + appendNumChars + TCL_GROWTH_MIN_ALLOC;
	    tmpString = (String *) ckrealloc((char *)stringPtr,
		    STRING_SIZE(stringPtr->uallocated));
	}
	stringPtr = tmpString;
d1021 1
d1044 3
a1046 3
    Tcl_Obj *objPtr;	        /* Points to the object to append to. */
    CONST Tcl_UniChar *unicode; /* String to convert to UTF. */
    int numChars;	        /* Number of chars of "unicode" to convert. */
d1049 1
a1049 1
    CONST char *bytes;
d1062 1
a1062 1
    bytes = Tcl_UniCharToUtfDString(unicode, numChars, &dsPtr);
d1088 1
a1088 1
    CONST char *bytes;	/* String to convert to Unicode. */
d1129 1
a1129 1
    CONST char *bytes;	/* String to append. */
d1154 4
a1157 5
	 * There isn't currently enough space in the string representation
	 * so allocate additional space.  First, try to double the length
	 * required.  If that fails, try a more modest allocation.  See the
	 * "TCL STRING GROWTH ALGORITHM" comment at the top of this file for an
	 * explanation of this growth algorithm.
d1160 1
a1160 4
	if (Tcl_AttemptSetObjLength(objPtr, 2 * newLength) == 0) {
	    Tcl_SetObjLength(objPtr,
		    newLength + numBytes + TCL_GROWTH_MIN_ALLOC);
	}
d1202 1
a1202 1
    int newLength, oldLength, attemptLength;
d1223 1
a1223 2
    newLength = 0;
    oldLength = objPtr->length;
d1247 1
a1247 1
    if (newLength == 0) {
d1252 1
a1252 1
    if (oldLength + newLength > (int) stringPtr->allocated) {
d1256 1
a1256 1
	 * representation, so allocate additional space.  If the current
d1258 2
a1259 6
	 * doing a series of appends) then try to allocate extra space to
	 * accomodate future growth: first try to double the required memory;
	 * if that fails, try a more modest allocation.  See the "TCL STRING
	 * GROWTH ALGORITHM" comment at the top of this file for an explanation
	 * of this growth algorithm.  Otherwise, if the current string
	 * representation is empty, exactly enough memory is allocated.
d1262 2
a1263 10
	if (oldLength == 0) {
	    Tcl_SetObjLength(objPtr, newLength);
	} else {
	    attemptLength = 2 * (oldLength + newLength);
	    if (Tcl_AttemptSetObjLength(objPtr, attemptLength) == 0) {
		attemptLength = oldLength + (2 * newLength) +
		    TCL_GROWTH_MIN_ALLOC;
		Tcl_SetObjLength(objPtr, attemptLength);
	    }
	}
d1294 1
a1294 1
    objPtr->length = oldLength + newLength;
d1489 1
a1489 1
    register Tcl_Obj *objPtr;	/* The object to convert. */
d1491 2
a1499 1
	String *stringPtr;
@


1.2
log
@touched all Tcl files to ease next import.
@
text
@@


1.2.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.2.16.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d36 2
a37 1
 * RCS: @@(#) $Id$ */
d46 1
a46 1
    			    Tcl_Obj *objPtr, CONST Tcl_UniChar *unicode,
d49 1
a49 1
    			    Tcl_Obj *objPtr, CONST Tcl_UniChar *unicode,
d52 1
a52 1
    			    CONST char *bytes, int numBytes));
d54 1
a54 1
    			    CONST char *bytes, int numBytes));
a111 38
/*
 * TCL STRING GROWTH ALGORITHM
 *
 * When growing strings (during an append, for example), the following growth
 * algorithm is used:
 *
 *   Attempt to allocate 2 * (originalLength + appendLength)
 *   On failure:
 *	attempt to allocate originalLength + 2*appendLength +
 *			TCL_GROWTH_MIN_ALLOC 
 *
 * This algorithm allows very good performance, as it rapidly increases the
 * memory allocated for a given string, which minimizes the number of
 * reallocations that must be performed.  However, using only the doubling
 * algorithm can lead to a significant waste of memory.  In particular, it
 * may fail even when there is sufficient memory available to complete the
 * append request (but there is not 2 * totalLength memory available).  So when
 * the doubling fails (because there is not enough memory available), the
 * algorithm requests a smaller amount of memory, which is still enough to
 * cover the request, but which hopefully will be less than the total available
 * memory.
 * 
 * The addition of TCL_GROWTH_MIN_ALLOC allows for efficient handling
 * of very small appends.  Without this extra slush factor, a sequence
 * of several small appends would cause several memory allocations.
 * As long as TCL_GROWTH_MIN_ALLOC is a reasonable size, we can
 * avoid that behavior.
 *
 * The growth algorithm can be tuned by adjusting the following parameters:
 *
 * TCL_GROWTH_MIN_ALLOC		Additional space, in bytes, to allocate when
 *				the double allocation has failed.
 *				Default is 1024 (1 kilobyte).
 */
#ifndef TCL_GROWTH_MIN_ALLOC
#define TCL_GROWTH_MIN_ALLOC	1024
#endif

d185 3
a187 3
 *	caller. This simplifies debugging since then the [memory active]
 *	command	will report the correct file name and line number when
 *	reporting objects that haven't been freed.
d216 1
a216 1
    CONST char *file;		/* The name of the source file calling this
d241 1
a241 1
    CONST char *file;		/* The name of the source file calling this
d253 1
a253 1
 * Tcl_NewUnicodeObj --
d256 1
a256 1
 *	it from the given Unicode String.  If the Utf String is the same size
d272 1
a272 1
    CONST Tcl_UniChar *unicode;	/* The unicode string used to initialize
a485 57
 * Tcl_GetUnicodeFromObj --
 *
 *	Get the Unicode form of the String object with length.  If
 *	the object is not already a String object, it will be converted
 *	to one.  If the String object does not have a Unicode rep, then
 *	one is create from the UTF string format.
 *
 * Results:
 *	Returns a pointer to the object's internal Unicode string.
 *
 * Side effects:
 *	Converts the object to have the String internal rep.
 *
 *----------------------------------------------------------------------
 */

Tcl_UniChar *
Tcl_GetUnicodeFromObj(objPtr, lengthPtr)
    Tcl_Obj *objPtr;	/* The object to find the unicode string for. */
    int *lengthPtr;	/* If non-NULL, the location where the
			 * string rep's unichar length should be
			 * stored. If NULL, no length is stored. */
{
    String *stringPtr;
    
    SetStringFromAny(NULL, objPtr);
    stringPtr = GET_STRING(objPtr);
    
    if ((stringPtr->numChars == -1) || (stringPtr->uallocated == 0)) {

	/*
	 * We haven't yet calculated the length, or all of the characters
	 * in the Utf string are 1 byte chars (so we didn't store the
	 * unicode str).  Since this function must return a unicode string,
	 * and one has not yet been stored, force the Unicode to be
	 * calculated and stored now.
	 */

	FillUnicodeRep(objPtr);

	/*
	 * We need to fetch the pointer again because we have just
	 * reallocated the structure to make room for the Unicode data.
	 */
	
	stringPtr = GET_STRING(objPtr);
    }

    if (lengthPtr != NULL) {
	*lengthPtr = stringPtr->numChars;
    }
    return stringPtr->unicode;
}

/*
 *----------------------------------------------------------------------
 *
d502 1
a502 1
Tcl_Obj *
d504 2
a505 1
    Tcl_Obj *objPtr;		/* The Tcl object to find the range of. */
d583 1
a583 1
    CONST char *bytes;		/* Points to the first of the length bytes
a670 44
 	if (objPtr->bytes != tclEmptyStringRep) {
	    new = (char *) ckrealloc((char *)objPtr->bytes,
		    (unsigned)(length+1));
	} else {
	    new = (char *) ckalloc((unsigned) (length+1));
	    if (objPtr->bytes != NULL && objPtr->length != 0) {
 	    	memcpy((VOID *) new, (VOID *) objPtr->bytes,
 		    	(size_t) objPtr->length);
 	    	Tcl_InvalidateStringRep(objPtr);
	    }
	}
	objPtr->bytes = new;
	stringPtr->allocated = length;
    }
    
    objPtr->length = length;
    if ((objPtr->bytes != NULL) && (objPtr->bytes != tclEmptyStringRep)) {
	objPtr->bytes[length] = 0;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_AttemptSetObjLength --
 *
 *	This procedure changes the length of the string representation
 *	of an object.  It uses the attempt* (non-panic'ing) memory allocators.
 *
 * Results:
 *	1 if the requested memory was allocated, 0 otherwise.
 *
 * Side effects:
 *	If the size of objPtr's string representation is greater than
 *	length, then it is reduced to length and a new terminating null
 *	byte is stored in the strength.  If the length of the string
 *	representation is greater than length, the storage space is
 *	reallocated to the given length; a null byte is stored at the
 *	end, but other bytes past the end of the original string
 *	representation are undefined.  The object's internal
 *	representation is changed to "expendable string".
 *
 *----------------------------------------------------------------------
 */
d672 5
a676 46
int
Tcl_AttemptSetObjLength(objPtr, length)
    register Tcl_Obj *objPtr;	/* Pointer to object.  This object must
				 * not currently be shared. */
    register int length;	/* Number of bytes desired for string
				 * representation of object, not including
				 * terminating null byte. */
{
    char *new;
    String *stringPtr;

    if (Tcl_IsShared(objPtr)) {
	panic("Tcl_AttemptSetObjLength called with shared object");
    }
    SetStringFromAny(NULL, objPtr);
        
    /*
     * Invalidate the unicode data.
     */

    stringPtr = GET_STRING(objPtr);
    stringPtr->numChars = -1;
    stringPtr->uallocated = 0;

    if (length > (int) stringPtr->allocated) {

	/*
	 * Not enough space in current string. Reallocate the string
	 * space and free the old string.
	 */
 	if (objPtr->bytes != tclEmptyStringRep) {
	    new = (char *) attemptckrealloc((char *)objPtr->bytes,
		    (unsigned)(length+1));
	    if (new == NULL) {
		return 0;
	    }
 	} else {
	    new = (char *) attemptckalloc((unsigned) (length+1));
	    if (new == NULL) {
		return 0;
	    }
	    if (objPtr->bytes != NULL && objPtr->length != 0) {
 	    	memcpy((VOID *) new, (VOID *) objPtr->bytes,
 		    	(size_t) objPtr->length);
 	    	Tcl_InvalidateStringRep(objPtr);
	    }
a685 1
    return 1;
d707 1
a707 1
    CONST Tcl_UniChar *unicode;	/* The unicode string used to initialize
d769 1
a769 1
    CONST char *bytes;		/* Points to the bytes to append to the
d826 1
a826 1
    CONST Tcl_UniChar *unicode;	/* The unicode string to append to the
d841 9
a849 1
    stringPtr = GET_STRING(objPtr);
d857 1
d973 3
a975 3
    Tcl_Obj *objPtr;	        /* Points to the object to append to. */
    CONST Tcl_UniChar *unicode; /* String to append. */
    int appendNumChars;	        /* Number of chars of "unicode" to append. */
d977 3
a979 2
    String *stringPtr, *tmpString;
    size_t numChars;
d993 1
a993 1

d996 3
a998 4
     * reallocate the internal rep object with additional space.  First try to
     * double the required allocation; if that fails, try a more modest
     * increase.  See the "TCL STRING GROWTH ALGORITHM" comment at the top of
     * this file for an explanation of this growth algorithm.
d1002 1
d1004 3
a1006 3
    if (numChars >= stringPtr->uallocated) {
 	stringPtr->uallocated = 2 * numChars;
	tmpString = (String *) attemptckrealloc((char *)stringPtr,
a1007 7
	if (tmpString == NULL) {
	    stringPtr->uallocated =
		numChars + appendNumChars + TCL_GROWTH_MIN_ALLOC;
	    tmpString = (String *) ckrealloc((char *)stringPtr,
		    STRING_SIZE(stringPtr->uallocated));
	}
	stringPtr = tmpString;
d1021 1
d1044 3
a1046 3
    Tcl_Obj *objPtr;	        /* Points to the object to append to. */
    CONST Tcl_UniChar *unicode; /* String to convert to UTF. */
    int numChars;	        /* Number of chars of "unicode" to convert. */
d1049 1
a1049 1
    CONST char *bytes;
d1062 1
a1062 1
    bytes = Tcl_UniCharToUtfDString(unicode, numChars, &dsPtr);
d1088 1
a1088 1
    CONST char *bytes;	/* String to convert to Unicode. */
d1129 1
a1129 1
    CONST char *bytes;	/* String to append. */
d1154 4
a1157 5
	 * There isn't currently enough space in the string representation
	 * so allocate additional space.  First, try to double the length
	 * required.  If that fails, try a more modest allocation.  See the
	 * "TCL STRING GROWTH ALGORITHM" comment at the top of this file for an
	 * explanation of this growth algorithm.
d1160 1
a1160 4
	if (Tcl_AttemptSetObjLength(objPtr, 2 * newLength) == 0) {
	    Tcl_SetObjLength(objPtr,
		    newLength + numBytes + TCL_GROWTH_MIN_ALLOC);
	}
d1202 1
a1202 1
    int newLength, oldLength, attemptLength;
d1223 1
a1223 2
    newLength = 0;
    oldLength = objPtr->length;
d1247 1
a1247 1
    if (newLength == 0) {
d1252 1
a1252 1
    if (oldLength + newLength > (int) stringPtr->allocated) {
d1256 1
a1256 1
	 * representation, so allocate additional space.  If the current
d1258 2
a1259 6
	 * doing a series of appends) then try to allocate extra space to
	 * accomodate future growth: first try to double the required memory;
	 * if that fails, try a more modest allocation.  See the "TCL STRING
	 * GROWTH ALGORITHM" comment at the top of this file for an explanation
	 * of this growth algorithm.  Otherwise, if the current string
	 * representation is empty, exactly enough memory is allocated.
d1262 2
a1263 10
	if (oldLength == 0) {
	    Tcl_SetObjLength(objPtr, newLength);
	} else {
	    attemptLength = 2 * (oldLength + newLength);
	    if (Tcl_AttemptSetObjLength(objPtr, attemptLength) == 0) {
		attemptLength = oldLength + (2 * newLength) +
		    TCL_GROWTH_MIN_ALLOC;
		Tcl_SetObjLength(objPtr, attemptLength);
	    }
	}
d1294 1
a1294 1
    objPtr->length = oldLength + newLength;
d1489 1
a1489 1
    register Tcl_Obj *objPtr;	/* The object to convert. */
d1491 2
a1499 1
	String *stringPtr;
@


1.1
log
@Initial revision
@
text
@d4 25
a28 7
 *	This file contains procedures that implement string operations
 *	on Tcl objects.  To do this efficiently (i.e. to allow many
 *	appends to be done to an object without constantly reallocating
 *	the space for the string representation) we overallocate the
 *	space for the string and use the internal representation to keep
 *	track of the extra space.  Objects with this internal
 *	representation are called "expandable string objects".
d31 1
d36 1
a36 1
 * RCS: @@(#) $Id: tclStringObj.c,v 1.2 1998/09/14 18:40:02 stanton Exp $
d45 14
a58 1
static void		ConvertToStringType _ANSI_ARGS_((Tcl_Obj *objPtr));
d72 1
a72 1
    (Tcl_FreeInternalRepProc *) NULL,	/* freeIntRepProc */
d77 35
d144 1
a144 1
    register char *bytes;	/* Points to the first of the length bytes
d146 1
a146 1
    register int length;	/* The number of bytes to copy from "bytes"
d158 1
a158 1
    register char *bytes;	/* Points to the first of the length bytes
d160 1
a160 1
    register int length;	/* The number of bytes to copy from "bytes"
d210 1
a210 1
    register char *bytes;	/* Points to the first of the length bytes
d212 1
a212 1
    register int length;	/* The number of bytes to copy from "bytes"
d235 1
a235 1
    register char *bytes;	/* Points to the first of the length bytes
d251 309
a600 6
    Tcl_InvalidateStringRep(objPtr);
    if (length < 0) {
	length = strlen(bytes);
    }
    TclInitStringRep(objPtr, bytes, length);
        
d609 6
d650 1
d655 12
a666 5
    if (objPtr->typePtr != &tclStringType) {
	ConvertToStringType(objPtr);
    }
    
    if ((long)length > objPtr->internalRep.longValue) {
d679 1
a679 1
	objPtr->internalRep.longValue = (long) length;
d681 1
d689 61
d775 1
a775 1
    int newLength, oldLength;
d780 3
a782 3
    if (objPtr->typePtr != &tclStringType) {
	ConvertToStringType(objPtr);
    }
d784 1
a784 1
	length = strlen(bytes);
a788 9
    oldLength = objPtr->length;
    newLength = length + oldLength;
    if ((long)newLength > objPtr->internalRep.longValue) {
	/*
	 * There isn't currently enough space in the string
	 * representation so allocate additional space.  In fact,
	 * overallocate so that there is room for future growth without
	 * having to reallocate again.
	 */
d790 13
a802 7
	Tcl_SetObjLength(objPtr, 2*newLength);
    }
    if (length > 0) {
	memcpy((VOID *) (objPtr->bytes + oldLength), (VOID *) bytes,
	       (size_t) length);
	objPtr->length = newLength;
	objPtr->bytes[objPtr->length] = 0;
d809 1
a809 1
 * Tcl_AppendStringsToObj --
d811 2
a812 2
 *	This procedure appends one or more null-terminated strings
 *	to an object.
d818 1
a818 2
 *	The contents of all the string arguments are appended to the
 *	string representation of objPtr.
d824 5
a828 1
Tcl_AppendStringsToObj TCL_VARARGS_DEF(Tcl_Obj *,arg1)
d830 1
a830 4
    va_list argList;
    register Tcl_Obj *objPtr;
    int newLength, oldLength;
    register char *string, *dst;
a831 1
    objPtr = (Tcl_Obj *) TCL_VARARGS_START(Tcl_Obj *,arg1,argList);
d833 1
a833 1
	panic("Tcl_AppendStringsToObj called with shared object");
d835 3
a837 2
    if (objPtr->typePtr != &tclStringType) {
	ConvertToStringType(objPtr);
d840 11
d852 3
a854 3
     * Figure out how much space is needed for all the strings, and
     * expand the string representation if it isn't big enough. If no
     * bytes would be appended, just return.
d857 389
a1245 7
    newLength = oldLength = objPtr->length;
    while (1) {
	string = va_arg(argList, char *);
	if (string == NULL) {
	    break;
	}
	newLength += strlen(string);
d1248 1
a1248 1
	return;
d1251 3
a1253 1
    if ((long)newLength > objPtr->internalRep.longValue) {
a1270 1
    TCL_VARARGS_START(Tcl_Obj *,arg1,argList);
d1272 2
a1273 2
    while (1) {
	string = va_arg(argList, char *);
d1295 11
a1305 1
    va_end(argList);
d1311 1
a1311 1
 * ConvertToStringType --
d1313 2
a1314 2
 *	This procedure converts the internal representation of an object
 *	to "expandable string" type.
d1320 2
a1321 4
 *	Any old internal reputation for objPtr is freed and the
 *	internal representation is set to that for an expandable string
 *	(the field internalRep.longValue holds 1 less than the allocated
 *	length of objPtr's string representation).
d1326 28
d1355 32
a1386 10
ConvertToStringType(objPtr)
    register Tcl_Obj *objPtr;	/* Pointer to object.  Must have a
				 * typePtr that isn't &tclStringType. */
{
    if (objPtr->typePtr != NULL) {
	if (objPtr->bytes == NULL) {
	    objPtr->typePtr->updateStringProc(objPtr);
	}
	if (objPtr->typePtr->freeIntRepProc != NULL) {
	    objPtr->typePtr->freeIntRepProc(objPtr);
d1388 3
d1392 8
a1399 6
    objPtr->typePtr = &tclStringType;
    if (objPtr->bytes != NULL) {
	objPtr->internalRep.longValue = (long)objPtr->length;
    } else {
	objPtr->internalRep.longValue = 0;
	objPtr->length = 0;
d1401 3
d1427 1
a1427 2
				 * have an internal representation of type
				 * "expandable string". */
d1431 26
d1463 3
a1465 1
    copyPtr->internalRep.longValue = (long)copyPtr->length;
d1474 1
a1474 2
 *	Create an internal representation of type "expandable string"
 *	for an object.
d1480 2
a1481 2
 *	This procedure does nothing; there is no advantage in converting
 *	the internal representation now, so we just defer it.
d1491 36
d1536 1
a1536 1
 *	representation is "expandable string".
d1542 2
a1543 1
 *	None.
d1552 38
a1589 6
    /*
     * The string is almost always valid already, in which case there's
     * nothing for us to do. The only case we have to worry about is if
     * the object is totally null. In this case, set the string rep to
     * an empty string.
     */
d1591 4
a1594 3
    if (objPtr->bytes == NULL) {
	objPtr->bytes = tclEmptyStringRep;
	objPtr->length = 0;
d1597 24
@


1.1.1.1
log
@import dejagnu-1999-11-08 snapshot
@
text
@@


1.1.1.2
log
@Tcl 8.3 upgrade
@
text
@d4 7
a10 25
 *	This file contains procedures that implement string operations on Tcl
 *	objects.  Some string operations work with UTF strings and others
 *	require Unicode format.  Functions that require knowledge of the width
 *	of each character, such as indexing, operate on Unicode data.
 *
 *	A Unicode string is an internationalized string.  Conceptually, a
 *	Unicode string is an array of 16-bit quantities organized as a sequence
 *	of properly formed UTF-8 characters.  There is a one-to-one map between
 *	Unicode and UTF characters.  Because Unicode characters have a fixed
 *	width, operations such as indexing operate on Unicode data.  The String
 *	ojbect is opitmized for the case where each UTF char in a string is
 *	only one byte.  In this case, we store the value of numChars, but we
 *	don't store the Unicode data (unless Tcl_GetUnicode is explicitly
 *	called).
 *
 *	The String object type stores one or both formats.  The default
 *	behavior is to store UTF.  Once Unicode is calculated by a function, it
 *	is stored in the internal rep for future access (without an additional
 *	O(n) cost).
 *
 *	To allow many appends to be done to an object without constantly
 *	reallocating the space for the string or Unicode representation, we
 *	allocate double the space for the string or Unicode and use the
 *	internal representation to keep track of how much space is used
 *	vs. allocated.
a12 1
 * Copyright (c) 1999 by Scriptics Corporation.
d17 1
a17 1
 * RCS: @@(#) $Id: tclStringObj.c,v 1.6.8.1 2000/04/06 22:38:29 spolk Exp $
d26 1
a26 14
static void		AppendUnicodeToUnicodeRep _ANSI_ARGS_((
    			    Tcl_Obj *objPtr, Tcl_UniChar *unicode,
			    int appendNumChars));
static void		AppendUnicodeToUtfRep _ANSI_ARGS_((
    			    Tcl_Obj *objPtr, Tcl_UniChar *unicode,
			    int numChars));
static void		AppendUtfToUnicodeRep _ANSI_ARGS_((Tcl_Obj *objPtr,
    			    char *bytes, int numBytes));
static void		AppendUtfToUtfRep _ANSI_ARGS_((Tcl_Obj *objPtr,
    			    char *bytes, int numBytes));

static void		FillUnicodeRep _ANSI_ARGS_((Tcl_Obj *objPtr));

static void		FreeStringInternalRep _ANSI_ARGS_((Tcl_Obj *objPtr));
d40 1
a40 1
    FreeStringInternalRep,		/* freeIntRepPro */
a44 35

/*
 * The following structure is the internal rep for a String object.
 * It keeps track of how much memory has been used and how much has been
 * allocated for the Unicode and UTF string to enable growing and
 * shrinking of the UTF and Unicode reps of the String object with fewer
 * mallocs.  To optimize string length and indexing operations, this
 * structure also stores the number of characters (same of UTF and Unicode!)
 * once that value has been computed.
 */

typedef struct String {
    int numChars;		/* The number of chars in the string.
				 * -1 means this value has not been
				 * calculated. >= 0 means that there is a
				 * valid Unicode rep, or that the number
				 * of UTF bytes == the number of chars. */
    size_t allocated;		/* The amount of space actually allocated
				 * for the UTF string (minus 1 byte for
				 * the termination char). */
    size_t uallocated;		/* The amount of space actually allocated
				 * for the Unicode string. 0 means the
				 * Unicode string rep is invalid. */
    Tcl_UniChar unicode[2];	/* The array of Unicode chars.  The actual
				 * size of this field depends on the
				 * 'uallocated' field above. */
} String;

#define STRING_SIZE(len)	\
		((unsigned) (sizeof(String) + ((len-1) * sizeof(Tcl_UniChar))))
#define GET_STRING(objPtr) \
		((String *) (objPtr)->internalRep.otherValuePtr)
#define SET_STRING(objPtr, stringPtr) \
		(objPtr)->internalRep.otherValuePtr = (VOID *) (stringPtr)

d77 1
a77 1
    CONST char *bytes;		/* Points to the first of the length bytes
d79 1
a79 1
    int length;			/* The number of bytes to copy from "bytes"
d91 1
a91 1
    CONST char *bytes;		/* Points to the first of the length bytes
d93 1
a93 1
    int length;			/* The number of bytes to copy from "bytes"
d143 1
a143 1
    CONST char *bytes;		/* Points to the first of the length bytes
d145 1
a145 1
    int length;			/* The number of bytes to copy from "bytes"
d168 1
a168 1
    CONST char *bytes;		/* Points to the first of the length bytes
a183 309
 *---------------------------------------------------------------------------
 *
 * TclNewUnicodeObj --
 *
 *	This procedure is creates a new String object and initializes
 *	it from the given Utf String.  If the Utf String is the same size
 *	as the Unicode string, don't duplicate the data.
 *
 * Results:
 *	The newly created object is returned.  This object will have no
 *	initial string representation.  The returned object has a ref count
 *	of 0.
 *
 * Side effects:
 *	Memory allocated for new object and copy of Unicode argument.
 *
 *---------------------------------------------------------------------------
 */

Tcl_Obj *
Tcl_NewUnicodeObj(unicode, numChars)
    Tcl_UniChar *unicode;	/* The unicode string used to initialize
				 * the new object. */
    int numChars;		/* Number of characters in the unicode
				 * string. */
{
    Tcl_Obj *objPtr;
    String *stringPtr;
    size_t uallocated;

    if (numChars < 0) {
	numChars = 0;
	if (unicode) {
	    while (unicode[numChars] != 0) { numChars++; }
	}
    }
    uallocated = (numChars + 1) * sizeof(Tcl_UniChar);

    /*
     * Create a new obj with an invalid string rep.
     */

    TclNewObj(objPtr);
    Tcl_InvalidateStringRep(objPtr);
    objPtr->typePtr = &tclStringType;

    stringPtr = (String *) ckalloc(STRING_SIZE(uallocated));
    stringPtr->numChars = numChars;
    stringPtr->uallocated = uallocated;
    stringPtr->allocated = 0;
    memcpy((VOID *) stringPtr->unicode, (VOID *) unicode, uallocated);
    stringPtr->unicode[numChars] = 0;
    SET_STRING(objPtr, stringPtr);
    return objPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetCharLength --
 *
 *	Get the length of the Unicode string from the Tcl object.
 *
 * Results:
 *	Pointer to unicode string representing the unicode object.
 *
 * Side effects:
 *	Frees old internal rep.  Allocates memory for new "String"
 *	internal rep.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_GetCharLength(objPtr)
    Tcl_Obj *objPtr;	/* The String object to get the num chars of. */
{
    String *stringPtr;
    
    SetStringFromAny(NULL, objPtr);
    stringPtr = GET_STRING(objPtr);

    /*
     * If numChars is unknown, then calculate the number of characaters
     * while populating the Unicode string.
     */
    
    if (stringPtr->numChars == -1) {

	stringPtr->numChars = Tcl_NumUtfChars(objPtr->bytes, objPtr->length);

 	if (stringPtr->numChars == objPtr->length) {

	    /*
	     * Since we've just calculated the number of chars, and all
	     * UTF chars are 1-byte long, we don't need to store the
	     * unicode string.
	     */

	    stringPtr->uallocated = 0;

	} else {
    
	    /*
	     * Since we've just calucalated the number of chars, and not
	     * all UTF chars are 1-byte long, go ahead and populate the
	     * unicode string.
	     */

	    FillUnicodeRep(objPtr);

	    /*
	     * We need to fetch the pointer again because we have just
	     * reallocated the structure to make room for the Unicode data.
	     */
	    
	    stringPtr = GET_STRING(objPtr);
	}
    }
    return stringPtr->numChars;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetUniChar --
 *
 *	Get the index'th Unicode character from the String object.  The
 *	index is assumed to be in the appropriate range.
 *
 * Results:
 *	Returns the index'th Unicode character in the Object.
 *
 * Side effects:
 *	Fills unichar with the index'th Unicode character.
 *
 *----------------------------------------------------------------------
 */

Tcl_UniChar
Tcl_GetUniChar(objPtr, index)
    Tcl_Obj *objPtr;	/* The object to get the Unicode charater from. */
    int index;		/* Get the index'th Unicode character. */
{
    Tcl_UniChar unichar;
    String *stringPtr;
    
    SetStringFromAny(NULL, objPtr);
    stringPtr = GET_STRING(objPtr);

    if (stringPtr->numChars == -1) {

	/*
	 * We haven't yet calculated the length, so we don't have the
	 * Unicode str.  We need to know the number of chars before we
	 * can do indexing.
	 */

	Tcl_GetCharLength(objPtr);

	/*
	 * We need to fetch the pointer again because we may have just
	 * reallocated the structure.
	 */
	
	stringPtr = GET_STRING(objPtr);
    }
    if (stringPtr->uallocated == 0) {

	/*
	 * All of the characters in the Utf string are 1 byte chars,
	 * so we don't store the unicode char.  We get the Utf string
	 * and convert the index'th byte to a Unicode character.
	 */
	
	Tcl_UtfToUniChar(&objPtr->bytes[index], &unichar);	
    } else {
	unichar = stringPtr->unicode[index];
    }
    return unichar;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetUnicode --
 *
 *	Get the Unicode form of the String object.  If
 *	the object is not already a String object, it will be converted
 *	to one.  If the String object does not have a Unicode rep, then
 *	one is create from the UTF string format.
 *
 * Results:
 *	Returns a pointer to the object's internal Unicode string.
 *
 * Side effects:
 *	Converts the object to have the String internal rep.
 *
 *----------------------------------------------------------------------
 */

Tcl_UniChar *
Tcl_GetUnicode(objPtr)
    Tcl_Obj *objPtr;	/* The object to find the unicode string for. */
{
    String *stringPtr;
    
    SetStringFromAny(NULL, objPtr);
    stringPtr = GET_STRING(objPtr);
    
    if ((stringPtr->numChars == -1) || (stringPtr->uallocated == 0)) {

	/*
	 * We haven't yet calculated the length, or all of the characters
	 * in the Utf string are 1 byte chars (so we didn't store the
	 * unicode str).  Since this function must return a unicode string,
	 * and one has not yet been stored, force the Unicode to be
	 * calculated and stored now.
	 */

	FillUnicodeRep(objPtr);

	/*
	 * We need to fetch the pointer again because we have just
	 * reallocated the structure to make room for the Unicode data.
	 */
	
	stringPtr = GET_STRING(objPtr);
    }
    return stringPtr->unicode;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetRange --
 *
 *	Create a Tcl Object that contains the chars between first and last
 *	of the object indicated by "objPtr".  If the object is not already
 *	a String object, convert it to one.  The first and last indices
 *	are assumed to be in the appropriate range.
 *
 * Results:
 *	Returns a new Tcl Object of the String type.
 *
 * Side effects:
 *	Changes the internal rep of "objPtr" to the String type.
 *
 *----------------------------------------------------------------------
 */

Tcl_Obj*
Tcl_GetRange(objPtr, first, last)
   
 Tcl_Obj *objPtr;		/* The Tcl object to find the range of. */
    int first;			/* First index of the range. */
    int last;			/* Last index of the range. */
{
    Tcl_Obj *newObjPtr;		/* The Tcl object to find the range of. */
    String *stringPtr;
    
    SetStringFromAny(NULL, objPtr);
    stringPtr = GET_STRING(objPtr);

    if (stringPtr->numChars == -1) {
    
	/*
	 * We haven't yet calculated the length, so we don't have the
	 * Unicode str.  We need to know the number of chars before we
	 * can do indexing.
	 */

	Tcl_GetCharLength(objPtr);

	/*
	 * We need to fetch the pointer again because we may have just
	 * reallocated the structure.
	 */
	
	stringPtr = GET_STRING(objPtr);
    }

    if (stringPtr->numChars == objPtr->length) {
	char *str = Tcl_GetString(objPtr);

	/*
	 * All of the characters in the Utf string are 1 byte chars,
	 * so we don't store the unicode char.  Create a new string
	 * object containing the specified range of chars.
	 */
	
	newObjPtr = Tcl_NewStringObj(&str[first], last-first+1);

	/*
	 * Since we know the new string only has 1-byte chars, we
	 * can set it's numChars field.
	 */
	
	SetStringFromAny(NULL, newObjPtr);
	stringPtr = GET_STRING(newObjPtr);
	stringPtr->numChars = last-first+1;
    } else {
	newObjPtr = Tcl_NewUnicodeObj(stringPtr->unicode + first,
		last-first+1);
    }
    return newObjPtr;
}

/*
d225 6
a238 6

    Tcl_InvalidateStringRep(objPtr);
    if (length < 0) {
	length = (bytes? strlen(bytes) : 0);
    }
    TclInitStringRep(objPtr, bytes, length);
a273 1
    String *stringPtr;
d278 5
a282 12
    SetStringFromAny(NULL, objPtr);
        
    /*
     * Invalidate the unicode data.
     */

    stringPtr = GET_STRING(objPtr);
    stringPtr->numChars = -1;
    stringPtr->uallocated = 0;

    if (length > (int) stringPtr->allocated) {

d295 1
a295 1
	stringPtr->allocated = length;
a296 1
    
a303 61
 *---------------------------------------------------------------------------
 *
 * TclSetUnicodeObj --
 *
 *	Modify an object to hold the Unicode string indicated by "unicode".
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Memory allocated for new "String" internal rep.
 *
 *---------------------------------------------------------------------------
 */

void
Tcl_SetUnicodeObj(objPtr, unicode, numChars)
    Tcl_Obj *objPtr;		/* The object to set the string of. */
    Tcl_UniChar *unicode;	/* The unicode string used to initialize
				 * the object. */
    int numChars;		/* Number of characters in the unicode
				 * string. */
{
    Tcl_ObjType *typePtr;
    String *stringPtr;
    size_t uallocated;

    if (numChars < 0) {
	numChars = 0;
	if (unicode) {
	    while (unicode[numChars] != 0) { numChars++; }
	}
    }
    uallocated = (numChars + 1) * sizeof(Tcl_UniChar);

    /*
     * Free the internal rep if one exists, and invalidate the string rep.
     */

    typePtr = objPtr->typePtr;
    if ((typePtr != NULL) && (typePtr->freeIntRepProc) != NULL) {
	(*typePtr->freeIntRepProc)(objPtr);
    }
    objPtr->typePtr = &tclStringType;

    /*
     * Allocate enough space for the String structure + Unicode string.
     */
	
    stringPtr = (String *) ckalloc(STRING_SIZE(uallocated));
    stringPtr->numChars = numChars;
    stringPtr->uallocated = uallocated;
    stringPtr->allocated = 0;
    memcpy((VOID *) stringPtr->unicode, (VOID *) unicode, uallocated);
    stringPtr->unicode[numChars] = 0;
    SET_STRING(objPtr, stringPtr);
    Tcl_InvalidateStringRep(objPtr);
    return;
}

/*
d329 1
a329 1
    String *stringPtr;
d334 3
a336 3
    
    SetStringFromAny(NULL, objPtr);

d338 1
a338 1
	length = (bytes ? strlen(bytes) : 0);
d343 9
d353 7
a359 13
    /*
     * If objPtr has a valid Unicode rep, then append the Unicode
     * conversion of "bytes" to the objPtr's Unicode rep, otherwise
     * append "bytes" to objPtr's string rep.
     */

    stringPtr = GET_STRING(objPtr);
    if (stringPtr->uallocated > 0) {
	AppendUtfToUnicodeRep(objPtr, bytes, length);

	stringPtr = GET_STRING(objPtr);
    } else {
	AppendUtfToUtfRep(objPtr, bytes, length);
d366 1
a366 1
 * Tcl_AppendUnicodeToObj --
d368 2
a369 2
 *	This procedure appends a Unicode string to an object in the
 *	most efficient manner possible.  Length must be >= 0.
d375 2
a376 1
 *	Invalidates the string rep and creates a new Unicode string.
d382 1
a382 5
Tcl_AppendUnicodeToObj(objPtr, unicode, length)
    register Tcl_Obj *objPtr;	/* Points to the object to append to. */
    Tcl_UniChar *unicode;	/* The unicode string to append to the
			         * object. */
    int length;			/* Number of chars in "unicode". */
d384 4
a387 1
    String *stringPtr;
d389 1
d391 1
a391 1
	panic("Tcl_AppendUnicodeToObj called with shared object");
d393 2
a394 3

    if (length == 0) {
	return;
a396 2
    SetStringFromAny(NULL, objPtr);

d398 3
a400 2
     * TEMPORARY!!!  This is terribly inefficient, but it works, and Don
     * needs for me to check this stuff in ASAP.  -Melissa
a401 4
    
/*     UpdateStringOfString(objPtr); */
/*     AppendUnicodeToUtfRep(objPtr, unicode, length); */
/*     return; */
d403 11
a413 5
    /*
     * If objPtr has a valid Unicode rep, then append the "unicode"
     * to the objPtr's Unicode rep, otherwise the UTF conversion of
     * "unicode" to objPtr's string rep.
     */
d415 7
a421 403
    stringPtr = GET_STRING(objPtr);
    if (stringPtr->uallocated > 0) {
	AppendUnicodeToUnicodeRep(objPtr, unicode, length);
    } else {
	AppendUnicodeToUtfRep(objPtr, unicode, length);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_AppendObjToObj --
 *
 *	This procedure appends the string rep of one object to another.
 *	"objPtr" cannot be a shared object.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The string rep of appendObjPtr is appended to the string 
 *	representation of objPtr.
 *
 *----------------------------------------------------------------------
 */

void
Tcl_AppendObjToObj(objPtr, appendObjPtr)
    Tcl_Obj *objPtr;		/* Points to the object to append to. */
    Tcl_Obj *appendObjPtr;	/* Object to append. */
{
    String *stringPtr;
    int length, numChars, allOneByteChars;
    char *bytes;

    SetStringFromAny(NULL, objPtr);

    /*
     * If objPtr has a valid Unicode rep, then get a Unicode string
     * from appendObjPtr and append it.
     */

    stringPtr = GET_STRING(objPtr);
    if (stringPtr->uallocated > 0) {
	
	/*
	 * If appendObjPtr is not of the "String" type, don't convert it.
	 */

	if (appendObjPtr->typePtr == &tclStringType) {
	    stringPtr = GET_STRING(appendObjPtr);
	    if ((stringPtr->numChars == -1)
		    || (stringPtr->uallocated == 0)) {
		
		/*
		 * If appendObjPtr is a string obj with no valide Unicode
		 * rep, then fill its unicode rep.
		 */

		FillUnicodeRep(appendObjPtr);
		stringPtr = GET_STRING(appendObjPtr);
	    }
	    AppendUnicodeToUnicodeRep(objPtr, stringPtr->unicode,
		    stringPtr->numChars);
	} else {
	    bytes = Tcl_GetStringFromObj(appendObjPtr, &length);
	    AppendUtfToUnicodeRep(objPtr, bytes, length);
	}
	return;
    }

    /*
     * Append to objPtr's UTF string rep.  If we know the number of
     * characters in both objects before appending, then set the combined
     * number of characters in the final (appended-to) object.
     */

    bytes = Tcl_GetStringFromObj(appendObjPtr, &length);

    allOneByteChars = 0;
    numChars = stringPtr->numChars;
    if ((numChars >= 0) && (appendObjPtr->typePtr == &tclStringType)) {
	stringPtr = GET_STRING(appendObjPtr);
	if ((stringPtr->numChars >= 0) && (stringPtr->numChars == length)) {
	    numChars += stringPtr->numChars;
	    allOneByteChars = 1;
	}
    }

    AppendUtfToUtfRep(objPtr, bytes, length);

    if (allOneByteChars) {
	stringPtr = GET_STRING(objPtr);
	stringPtr->numChars = numChars;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * AppendUnicodeToUnicodeRep --
 *
 *	This procedure appends the contents of "unicode" to the Unicode
 *	rep of "objPtr".  objPtr must already have a valid Unicode rep.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	objPtr's internal rep is reallocated.
 *
 *----------------------------------------------------------------------
 */

static void
AppendUnicodeToUnicodeRep(objPtr, unicode, appendNumChars)
    Tcl_Obj *objPtr;	      /* Points to the object to append to. */
    Tcl_UniChar *unicode;     /* String to append. */
    int appendNumChars;	      /* Number of chars of "unicode" to append. */
{
    String *stringPtr;
    int numChars;
    size_t newSize;

    if (appendNumChars < 0) {
	appendNumChars = 0;
	if (unicode) {
	    while (unicode[appendNumChars] != 0) { appendNumChars++; }
	}
    }
    if (appendNumChars == 0) {
	return;
    }

    SetStringFromAny(NULL, objPtr);
    stringPtr = GET_STRING(objPtr);
    
    /*
     * If not enough space has been allocated for the unicode rep,
     * reallocate the internal rep object with double the amount of
     * space needed, so the unicode string can grow without being
     * reallocated.
     */

    numChars = stringPtr->numChars + appendNumChars;
    newSize = (numChars + 1) * sizeof(Tcl_UniChar);

    if (newSize > stringPtr->uallocated) {
	stringPtr->uallocated = newSize * 2;
	stringPtr = (String *) ckrealloc((char*)stringPtr,
		STRING_SIZE(stringPtr->uallocated));
	SET_STRING(objPtr, stringPtr);
    }

    /*
     * Copy the new string onto the end of the old string, then add the
     * trailing null.
     */

    memcpy((VOID*) (stringPtr->unicode + stringPtr->numChars), unicode,
	    appendNumChars * sizeof(Tcl_UniChar));
    stringPtr->unicode[numChars] = 0;
    stringPtr->numChars = numChars;

    SET_STRING(objPtr, stringPtr);
    Tcl_InvalidateStringRep(objPtr);
}

/*
 *----------------------------------------------------------------------
 *
 * AppendUnicodeToUtfRep --
 *
 *	This procedure converts the contents of "unicode" to UTF and
 *	appends the UTF to the string rep of "objPtr".
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	objPtr's internal rep is reallocated.
 *
 *----------------------------------------------------------------------
 */

static void
AppendUnicodeToUtfRep(objPtr, unicode, numChars)
    Tcl_Obj *objPtr;	      /* Points to the object to append to. */
    Tcl_UniChar *unicode;     /* String to convert to UTF. */
    int numChars;	      /* Number of chars of "unicode" to convert. */
{
    Tcl_DString dsPtr;
    char *bytes;
    
    if (numChars < 0) {
	numChars = 0;
	if (unicode) {
	    while (unicode[numChars] != 0) { numChars++; }
	}
    }
    if (numChars == 0) {
	return;
    }

    Tcl_DStringInit(&dsPtr);
    bytes = (char *)Tcl_UniCharToUtfDString(unicode, numChars, &dsPtr);
    AppendUtfToUtfRep(objPtr, bytes, Tcl_DStringLength(&dsPtr));
    Tcl_DStringFree(&dsPtr);
}

/*
 *----------------------------------------------------------------------
 *
 * AppendUtfToUnicodeRep --
 *
 *	This procedure converts the contents of "bytes" to Unicode and
 *	appends the Unicode to the Unicode rep of "objPtr".  objPtr must
 *	already have a valid Unicode rep.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	objPtr's internal rep is reallocated.
 *
 *----------------------------------------------------------------------
 */

static void
AppendUtfToUnicodeRep(objPtr, bytes, numBytes)
    Tcl_Obj *objPtr;	/* Points to the object to append to. */
    char *bytes;		/* String to convert to Unicode. */
    int numBytes;	/* Number of bytes of "bytes" to convert. */
{
    Tcl_DString dsPtr;
    int numChars;
    Tcl_UniChar *unicode;

    if (numBytes < 0) {
	numBytes = (bytes ? strlen(bytes) : 0);
    }
    if (numBytes == 0) {
	return;
    }
    
    Tcl_DStringInit(&dsPtr);
    numChars = Tcl_NumUtfChars(bytes, numBytes);
    unicode = (Tcl_UniChar *)Tcl_UtfToUniCharDString(bytes, numBytes, &dsPtr);
    AppendUnicodeToUnicodeRep(objPtr, unicode, numChars);
    Tcl_DStringFree(&dsPtr);
}

/*
 *----------------------------------------------------------------------
 *
 * AppendUtfToUtfRep --
 *
 *	This procedure appends "numBytes" bytes of "bytes" to the UTF string
 *	rep of "objPtr".  objPtr must already have a valid String rep.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	objPtr's internal rep is reallocated.
 *
 *----------------------------------------------------------------------
 */

static void
AppendUtfToUtfRep(objPtr, bytes, numBytes)
    Tcl_Obj *objPtr;	/* Points to the object to append to. */
    char *bytes;	/* String to append. */
    int numBytes;	/* Number of bytes of "bytes" to append. */
{
    String *stringPtr;
    int newLength, oldLength;

    if (numBytes < 0) {
	numBytes = (bytes ? strlen(bytes) : 0);
    }
    if (numBytes == 0) {
	return;
    }

    /*
     * Copy the new string onto the end of the old string, then add the
     * trailing null.
     */

    oldLength = objPtr->length;
    newLength = numBytes + oldLength;

    stringPtr = GET_STRING(objPtr);
    if (newLength > (int) stringPtr->allocated) {

	/*
	 * There isn't currently enough space in the string
	 * representation so allocate additional space.  Overallocate the
	 * space by doubling it so that we won't have to do as much
	 * reallocation in the future.
	 */

	Tcl_SetObjLength(objPtr, 2*newLength);
    } else {

	/*
	 * Invalidate the unicode data.
	 */
	
	stringPtr->numChars = -1;
	stringPtr->uallocated = 0;
    }
    
    memcpy((VOID *) (objPtr->bytes + oldLength), (VOID *) bytes,
	    (size_t) numBytes);
    objPtr->bytes[newLength] = 0;
    objPtr->length = newLength;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_AppendStringsToObjVA --
 *
 *	This procedure appends one or more null-terminated strings
 *	to an object.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The contents of all the string arguments are appended to the
 *	string representation of objPtr.
 *
 *----------------------------------------------------------------------
 */

void
Tcl_AppendStringsToObjVA (objPtr, argList)
    Tcl_Obj *objPtr;		/* Points to the object to append to. */
    va_list argList;		/* Variable argument list. */
{
#define STATIC_LIST_SIZE 16
    String *stringPtr;
    int newLength, oldLength;
    register char *string, *dst;
    char *static_list[STATIC_LIST_SIZE];
    char **args = static_list;
    int nargs_space = STATIC_LIST_SIZE;
    int nargs, i;

    if (Tcl_IsShared(objPtr)) {
	panic("Tcl_AppendStringsToObj called with shared object");
    }

    SetStringFromAny(NULL, objPtr);

    /*
     * Figure out how much space is needed for all the strings, and
     * expand the string representation if it isn't big enough. If no
     * bytes would be appended, just return.  Note that on some platforms
     * (notably OS/390) the argList is an array so we need to use memcpy.
     */

    nargs = 0;
    newLength = oldLength = objPtr->length;
    while (1) {
	string = va_arg(argList, char *);
	if (string == NULL) {
	    break;
	}
 	if (nargs >= nargs_space) {
 	    /* 
 	     * Expand the args buffer
 	     */
 	    nargs_space += STATIC_LIST_SIZE;
 	    if (args == static_list) {
 	    	args = (void *)ckalloc(nargs_space * sizeof(char *));
 		for (i = 0; i < nargs; ++i) {
 		    args[i] = static_list[i];
 		}
 	    } else {
 		args = (void *)ckrealloc((void *)args,
			nargs_space * sizeof(char *));
 	    }
 	}
	newLength += strlen(string);
	args[nargs++] = string;
    }
    if (newLength == oldLength) {
	goto done;
    }

    stringPtr = GET_STRING(objPtr);
    if (newLength > (int) stringPtr->allocated) {

	/*
	 * There isn't currently enough space in the string
	 * representation so allocate additional space.  If the current
	 * string representation isn't empty (i.e. it looks like we're
	 * doing a series of appends) then overallocate the space so
	 * that we won't have to do as much reallocation in the future.
d433 1
d435 2
a436 2
    for (i = 0; i < nargs; ++i) {
 	string = args[i];
d458 1
a458 11

    done:
    /*
     * If we had to allocate a buffer from the heap, 
     * free it now.
     */
 
    if (args != static_list) {
     	ckfree((void *)args);
    }
#undef STATIC_LIST_SIZE
d464 1
a464 1
 * Tcl_AppendStringsToObj --
d466 2
a467 2
 *	This procedure appends one or more null-terminated strings
 *	to an object.
d473 4
a476 2
 *	The contents of all the string arguments are appended to the
 *	string representation of objPtr.
a480 28
void
Tcl_AppendStringsToObj TCL_VARARGS_DEF(Tcl_Obj *,arg1)
{
    register Tcl_Obj *objPtr;
    va_list argList;

    objPtr = TCL_VARARGS_START(Tcl_Obj *,arg1,argList);
    Tcl_AppendStringsToObjVA(objPtr, argList);
    va_end(argList);
}

/*
 *---------------------------------------------------------------------------
 *
 * FillUnicodeRep --
 *
 *	Populate the Unicode internal rep with the Unicode form of its string
 *	rep.  The object must alread have a "String" internal rep.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Reallocates the String internal rep.
 *
 *---------------------------------------------------------------------------
 */

d482 10
a491 32
FillUnicodeRep(objPtr)
    Tcl_Obj *objPtr;	/* The object in which to fill the unicode rep. */
{
    String *stringPtr;
    size_t uallocated;
    char *src, *srcEnd;
    Tcl_UniChar *dst;
    src = objPtr->bytes;
    
    stringPtr = GET_STRING(objPtr);
    if (stringPtr->numChars == -1) {
	stringPtr->numChars = Tcl_NumUtfChars(src, objPtr->length);
    }

    uallocated = stringPtr->numChars * sizeof(Tcl_UniChar);
    if (uallocated > stringPtr->uallocated) {
    
	/*
	 * If not enough space has been allocated for the unicode rep,
	 * reallocate the internal rep object.
	 */

	/*
	 * There isn't currently enough space in the Unicode
	 * representation so allocate additional space.  If the current
	 * Unicode representation isn't empty (i.e. it looks like we've
	 * done some appends) then overallocate the space so
	 * that we won't have to do as much reallocation in the future.
	 */

	if (stringPtr->uallocated > 0) {
	    uallocated *= 2;
a492 3
	stringPtr = (String *) ckrealloc((char*) stringPtr,
		STRING_SIZE(uallocated));
	stringPtr->uallocated = uallocated;
d494 6
a499 8

    /*
     * Convert src to Unicode and store the coverted data in "unicode".
     */
    
    srcEnd = src + objPtr->length;
    for (dst = stringPtr->unicode; src < srcEnd; dst++) {
	src += Tcl_UtfToUniChar(src, dst);
a500 3
    *dst = 0;
    
    SET_STRING(objPtr, stringPtr);
d524 2
a525 1
				 * have an internal rep of type "String". */
a528 26
    String *srcStringPtr = GET_STRING(srcPtr);
    String *copyStringPtr = NULL;

    /*
     * If the src obj is a string of 1-byte Utf chars, then copy the
     * string rep of the source object and create an "empty" Unicode
     * internal rep for the new object.  Otherwise, copy Unicode
     * internal rep, and invalidate the string rep of the new object.
     */
    
    if (srcStringPtr->uallocated == 0) {
    	copyStringPtr = (String *) ckalloc(sizeof(String));
	copyStringPtr->uallocated = 0;
    } else {
	copyStringPtr = (String *) ckalloc(
	    STRING_SIZE(srcStringPtr->uallocated));
	copyStringPtr->uallocated = srcStringPtr->uallocated;

	memcpy((VOID *) copyStringPtr->unicode,
		(VOID *) srcStringPtr->unicode,
		(size_t) srcStringPtr->numChars * sizeof(Tcl_UniChar));
	copyStringPtr->unicode[srcStringPtr->numChars] = 0;
    }
    copyStringPtr->numChars = srcStringPtr->numChars;
    copyStringPtr->allocated = srcStringPtr->allocated;

d535 1
a535 3
    copyStringPtr->allocated = copyPtr->length;

    SET_STRING(copyPtr, copyStringPtr);
d544 2
a545 1
 *	Create an internal representation of type "String" for an object.
d551 2
a552 2
 *	Any old internal reputation for objPtr is freed and the
 *	internal representation is set to "String".
a561 36
    String *stringPtr;

    /*
     * The Unicode object is opitmized for the case where each UTF char
     * in a string is only one byte.  In this case, we store the value of
     * numChars, but we don't copy the bytes to the unicodeObj->unicode.
     */

    if (objPtr->typePtr != &tclStringType) {

	if (objPtr->typePtr != NULL) {
	    if (objPtr->bytes == NULL) {
		objPtr->typePtr->updateStringProc(objPtr);
	    }
	    if ((objPtr->typePtr->freeIntRepProc) != NULL) {
		(*objPtr->typePtr->freeIntRepProc)(objPtr);
	    }
	}
	objPtr->typePtr = &tclStringType;

	/*
	 * Allocate enough space for the basic String structure.
	 */

	stringPtr = (String *) ckalloc(sizeof(String));
	stringPtr->numChars = -1;
	stringPtr->uallocated = 0;

	if (objPtr->bytes != NULL) {
	    stringPtr->allocated = objPtr->length;	    
 	    objPtr->bytes[objPtr->length] = 0;
	} else {
	    objPtr->length = 0;
	}
	SET_STRING(objPtr, stringPtr);
    }
d571 1
a571 1
 *	representation is "String".
d577 1
a577 2
 *	The object's string may be set by converting its Unicode
 *	represention to UTF format.
d586 6
a591 20
    int i, length, size;
    Tcl_UniChar *unicode;
    char dummy[TCL_UTF_MAX];
    char *dst;
    String *stringPtr;

    stringPtr = GET_STRING(objPtr);
    if ((objPtr->bytes == NULL) || (stringPtr->allocated == 0)) {

	if (stringPtr->numChars <= 0) {

	    /*
	     * If there is no Unicode rep, or the string has 0 chars,
	     * then set the string rep to an empty string.
	     */

	    objPtr->bytes = tclEmptyStringRep;
	    objPtr->length = 0;
	    return;
	}
d593 3
a595 22
	unicode = stringPtr->unicode;
	length = stringPtr->numChars * sizeof(Tcl_UniChar);

	/*
	 * Translate the Unicode string to UTF.  "size" will hold the
	 * amount of space the UTF string needs.
	 */

	size = 0;
	for (i = 0; i < stringPtr->numChars; i++) {
	    size += Tcl_UniCharToUtf((int) unicode[i], dummy);
	}
	
	dst = (char *) ckalloc((unsigned) (size + 1));
	objPtr->bytes = dst;
	objPtr->length = size;
	stringPtr->allocated = size;

	for (i = 0; i < stringPtr->numChars; i++) {
	    dst += Tcl_UniCharToUtf(unicode[i], dst);
	}
	*dst = '\0';
a597 24
}

/*
 *----------------------------------------------------------------------
 *
 * FreeStringInternalRep --
 *
 *	Deallocate the storage associated with a String data object's
 *	internal representation.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Frees memory. 
 *
 *----------------------------------------------------------------------
 */

static void
FreeStringInternalRep(objPtr)
    Tcl_Obj *objPtr;		/* Object with internal rep to free. */
{
    ckfree((char *) GET_STRING(objPtr));
@


1.1.1.3
log
@import tcl 8.4.0
@
text
@d36 2
a37 1
 * RCS: @@(#) $Id: tclStringObj.c,v 1.24 2002/01/26 01:10:08 dgp Exp $ */
d46 1
a46 1
    			    Tcl_Obj *objPtr, CONST Tcl_UniChar *unicode,
d49 1
a49 1
    			    Tcl_Obj *objPtr, CONST Tcl_UniChar *unicode,
d52 1
a52 1
    			    CONST char *bytes, int numBytes));
d54 1
a54 1
    			    CONST char *bytes, int numBytes));
a111 38
/*
 * TCL STRING GROWTH ALGORITHM
 *
 * When growing strings (during an append, for example), the following growth
 * algorithm is used:
 *
 *   Attempt to allocate 2 * (originalLength + appendLength)
 *   On failure:
 *	attempt to allocate originalLength + 2*appendLength +
 *			TCL_GROWTH_MIN_ALLOC 
 *
 * This algorithm allows very good performance, as it rapidly increases the
 * memory allocated for a given string, which minimizes the number of
 * reallocations that must be performed.  However, using only the doubling
 * algorithm can lead to a significant waste of memory.  In particular, it
 * may fail even when there is sufficient memory available to complete the
 * append request (but there is not 2 * totalLength memory available).  So when
 * the doubling fails (because there is not enough memory available), the
 * algorithm requests a smaller amount of memory, which is still enough to
 * cover the request, but which hopefully will be less than the total available
 * memory.
 * 
 * The addition of TCL_GROWTH_MIN_ALLOC allows for efficient handling
 * of very small appends.  Without this extra slush factor, a sequence
 * of several small appends would cause several memory allocations.
 * As long as TCL_GROWTH_MIN_ALLOC is a reasonable size, we can
 * avoid that behavior.
 *
 * The growth algorithm can be tuned by adjusting the following parameters:
 *
 * TCL_GROWTH_MIN_ALLOC		Additional space, in bytes, to allocate when
 *				the double allocation has failed.
 *				Default is 1024 (1 kilobyte).
 */
#ifndef TCL_GROWTH_MIN_ALLOC
#define TCL_GROWTH_MIN_ALLOC	1024
#endif

d185 3
a187 3
 *	caller. This simplifies debugging since then the [memory active]
 *	command	will report the correct file name and line number when
 *	reporting objects that haven't been freed.
d216 1
a216 1
    CONST char *file;		/* The name of the source file calling this
d241 1
a241 1
    CONST char *file;		/* The name of the source file calling this
d253 1
a253 1
 * Tcl_NewUnicodeObj --
d256 1
a256 1
 *	it from the given Unicode String.  If the Utf String is the same size
d272 1
a272 1
    CONST Tcl_UniChar *unicode;	/* The unicode string used to initialize
a485 57
 * Tcl_GetUnicodeFromObj --
 *
 *	Get the Unicode form of the String object with length.  If
 *	the object is not already a String object, it will be converted
 *	to one.  If the String object does not have a Unicode rep, then
 *	one is create from the UTF string format.
 *
 * Results:
 *	Returns a pointer to the object's internal Unicode string.
 *
 * Side effects:
 *	Converts the object to have the String internal rep.
 *
 *----------------------------------------------------------------------
 */

Tcl_UniChar *
Tcl_GetUnicodeFromObj(objPtr, lengthPtr)
    Tcl_Obj *objPtr;	/* The object to find the unicode string for. */
    int *lengthPtr;	/* If non-NULL, the location where the
			 * string rep's unichar length should be
			 * stored. If NULL, no length is stored. */
{
    String *stringPtr;
    
    SetStringFromAny(NULL, objPtr);
    stringPtr = GET_STRING(objPtr);
    
    if ((stringPtr->numChars == -1) || (stringPtr->uallocated == 0)) {

	/*
	 * We haven't yet calculated the length, or all of the characters
	 * in the Utf string are 1 byte chars (so we didn't store the
	 * unicode str).  Since this function must return a unicode string,
	 * and one has not yet been stored, force the Unicode to be
	 * calculated and stored now.
	 */

	FillUnicodeRep(objPtr);

	/*
	 * We need to fetch the pointer again because we have just
	 * reallocated the structure to make room for the Unicode data.
	 */
	
	stringPtr = GET_STRING(objPtr);
    }

    if (lengthPtr != NULL) {
	*lengthPtr = stringPtr->numChars;
    }
    return stringPtr->unicode;
}

/*
 *----------------------------------------------------------------------
 *
d502 1
a502 1
Tcl_Obj *
d504 2
a505 1
    Tcl_Obj *objPtr;		/* The Tcl object to find the range of. */
d583 1
a583 1
    CONST char *bytes;		/* Points to the first of the length bytes
a670 44
 	if (objPtr->bytes != tclEmptyStringRep) {
	    new = (char *) ckrealloc((char *)objPtr->bytes,
		    (unsigned)(length+1));
	} else {
	    new = (char *) ckalloc((unsigned) (length+1));
	    if (objPtr->bytes != NULL && objPtr->length != 0) {
 	    	memcpy((VOID *) new, (VOID *) objPtr->bytes,
 		    	(size_t) objPtr->length);
 	    	Tcl_InvalidateStringRep(objPtr);
	    }
	}
	objPtr->bytes = new;
	stringPtr->allocated = length;
    }
    
    objPtr->length = length;
    if ((objPtr->bytes != NULL) && (objPtr->bytes != tclEmptyStringRep)) {
	objPtr->bytes[length] = 0;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_AttemptSetObjLength --
 *
 *	This procedure changes the length of the string representation
 *	of an object.  It uses the attempt* (non-panic'ing) memory allocators.
 *
 * Results:
 *	1 if the requested memory was allocated, 0 otherwise.
 *
 * Side effects:
 *	If the size of objPtr's string representation is greater than
 *	length, then it is reduced to length and a new terminating null
 *	byte is stored in the strength.  If the length of the string
 *	representation is greater than length, the storage space is
 *	reallocated to the given length; a null byte is stored at the
 *	end, but other bytes past the end of the original string
 *	representation are undefined.  The object's internal
 *	representation is changed to "expendable string".
 *
 *----------------------------------------------------------------------
 */
d672 5
a676 46
int
Tcl_AttemptSetObjLength(objPtr, length)
    register Tcl_Obj *objPtr;	/* Pointer to object.  This object must
				 * not currently be shared. */
    register int length;	/* Number of bytes desired for string
				 * representation of object, not including
				 * terminating null byte. */
{
    char *new;
    String *stringPtr;

    if (Tcl_IsShared(objPtr)) {
	panic("Tcl_AttemptSetObjLength called with shared object");
    }
    SetStringFromAny(NULL, objPtr);
        
    /*
     * Invalidate the unicode data.
     */

    stringPtr = GET_STRING(objPtr);
    stringPtr->numChars = -1;
    stringPtr->uallocated = 0;

    if (length > (int) stringPtr->allocated) {

	/*
	 * Not enough space in current string. Reallocate the string
	 * space and free the old string.
	 */
 	if (objPtr->bytes != tclEmptyStringRep) {
	    new = (char *) attemptckrealloc((char *)objPtr->bytes,
		    (unsigned)(length+1));
	    if (new == NULL) {
		return 0;
	    }
 	} else {
	    new = (char *) attemptckalloc((unsigned) (length+1));
	    if (new == NULL) {
		return 0;
	    }
	    if (objPtr->bytes != NULL && objPtr->length != 0) {
 	    	memcpy((VOID *) new, (VOID *) objPtr->bytes,
 		    	(size_t) objPtr->length);
 	    	Tcl_InvalidateStringRep(objPtr);
	    }
a685 1
    return 1;
d707 1
a707 1
    CONST Tcl_UniChar *unicode;	/* The unicode string used to initialize
d769 1
a769 1
    CONST char *bytes;		/* Points to the bytes to append to the
d826 1
a826 1
    CONST Tcl_UniChar *unicode;	/* The unicode string to append to the
d841 9
a849 1
    stringPtr = GET_STRING(objPtr);
d857 1
d973 3
a975 3
    Tcl_Obj *objPtr;	        /* Points to the object to append to. */
    CONST Tcl_UniChar *unicode; /* String to append. */
    int appendNumChars;	        /* Number of chars of "unicode" to append. */
d977 3
a979 2
    String *stringPtr, *tmpString;
    size_t numChars;
d993 1
a993 1

d996 3
a998 4
     * reallocate the internal rep object with additional space.  First try to
     * double the required allocation; if that fails, try a more modest
     * increase.  See the "TCL STRING GROWTH ALGORITHM" comment at the top of
     * this file for an explanation of this growth algorithm.
d1002 1
d1004 3
a1006 3
    if (numChars >= stringPtr->uallocated) {
 	stringPtr->uallocated = 2 * numChars;
	tmpString = (String *) attemptckrealloc((char *)stringPtr,
a1007 7
	if (tmpString == NULL) {
	    stringPtr->uallocated =
		numChars + appendNumChars + TCL_GROWTH_MIN_ALLOC;
	    tmpString = (String *) ckrealloc((char *)stringPtr,
		    STRING_SIZE(stringPtr->uallocated));
	}
	stringPtr = tmpString;
d1021 1
d1044 3
a1046 3
    Tcl_Obj *objPtr;	        /* Points to the object to append to. */
    CONST Tcl_UniChar *unicode; /* String to convert to UTF. */
    int numChars;	        /* Number of chars of "unicode" to convert. */
d1049 1
a1049 1
    CONST char *bytes;
d1062 1
a1062 1
    bytes = Tcl_UniCharToUtfDString(unicode, numChars, &dsPtr);
d1088 1
a1088 1
    CONST char *bytes;	/* String to convert to Unicode. */
d1129 1
a1129 1
    CONST char *bytes;	/* String to append. */
d1154 4
a1157 5
	 * There isn't currently enough space in the string representation
	 * so allocate additional space.  First, try to double the length
	 * required.  If that fails, try a more modest allocation.  See the
	 * "TCL STRING GROWTH ALGORITHM" comment at the top of this file for an
	 * explanation of this growth algorithm.
d1160 1
a1160 4
	if (Tcl_AttemptSetObjLength(objPtr, 2 * newLength) == 0) {
	    Tcl_SetObjLength(objPtr,
		    newLength + numBytes + TCL_GROWTH_MIN_ALLOC);
	}
d1202 1
a1202 1
    int newLength, oldLength, attemptLength;
d1223 1
a1223 2
    newLength = 0;
    oldLength = objPtr->length;
d1247 1
a1247 1
    if (newLength == 0) {
d1252 1
a1252 1
    if (oldLength + newLength > (int) stringPtr->allocated) {
d1256 1
a1256 1
	 * representation, so allocate additional space.  If the current
d1258 2
a1259 6
	 * doing a series of appends) then try to allocate extra space to
	 * accomodate future growth: first try to double the required memory;
	 * if that fails, try a more modest allocation.  See the "TCL STRING
	 * GROWTH ALGORITHM" comment at the top of this file for an explanation
	 * of this growth algorithm.  Otherwise, if the current string
	 * representation is empty, exactly enough memory is allocated.
d1262 2
a1263 10
	if (oldLength == 0) {
	    Tcl_SetObjLength(objPtr, newLength);
	} else {
	    attemptLength = 2 * (oldLength + newLength);
	    if (Tcl_AttemptSetObjLength(objPtr, attemptLength) == 0) {
		attemptLength = oldLength + (2 * newLength) +
		    TCL_GROWTH_MIN_ALLOC;
		Tcl_SetObjLength(objPtr, attemptLength);
	    }
	}
d1294 1
a1294 1
    objPtr->length = oldLength + newLength;
d1489 1
a1489 1
    register Tcl_Obj *objPtr;	/* The object to convert. */
d1491 2
a1499 1
	String *stringPtr;
@


