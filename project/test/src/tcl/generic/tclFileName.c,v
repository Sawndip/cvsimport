head	1.10;
access;
symbols
	sid-snapshot-20180601:1.10
	sid-snapshot-20180501:1.10
	sid-snapshot-20180401:1.10
	sid-snapshot-20180301:1.10
	sid-snapshot-20180201:1.10
	sid-snapshot-20180101:1.10
	sid-snapshot-20171201:1.10
	sid-snapshot-20171101:1.10
	sid-snapshot-20171001:1.10
	sid-snapshot-20170901:1.10
	sid-snapshot-20170801:1.10
	sid-snapshot-20170701:1.10
	sid-snapshot-20170601:1.10
	sid-snapshot-20170501:1.10
	sid-snapshot-20170401:1.10
	sid-snapshot-20170301:1.10
	sid-snapshot-20170201:1.10
	sid-snapshot-20170101:1.10
	sid-snapshot-20161201:1.10
	sid-snapshot-20161101:1.10
	sid-snapshot-20160901:1.10
	sid-snapshot-20160801:1.10
	sid-snapshot-20160701:1.10
	sid-snapshot-20160601:1.10
	sid-snapshot-20160501:1.10
	sid-snapshot-20160401:1.10
	sid-snapshot-20160301:1.10
	sid-snapshot-20160201:1.10
	sid-snapshot-20160101:1.10
	sid-snapshot-20151201:1.10
	sid-snapshot-20151101:1.10
	sid-snapshot-20151001:1.10
	sid-snapshot-20150901:1.10
	sid-snapshot-20150801:1.10
	sid-snapshot-20150701:1.10
	sid-snapshot-20150601:1.10
	sid-snapshot-20150501:1.10
	sid-snapshot-20150401:1.10
	sid-snapshot-20150301:1.10
	sid-snapshot-20150201:1.10
	sid-snapshot-20150101:1.10
	sid-snapshot-20141201:1.10
	sid-snapshot-20141101:1.10
	sid-snapshot-20141001:1.10
	sid-snapshot-20140901:1.10
	sid-snapshot-20140801:1.10
	sid-snapshot-20140701:1.10
	sid-snapshot-20140601:1.10
	sid-snapshot-20140501:1.10
	sid-snapshot-20140401:1.10
	sid-snapshot-20140301:1.10
	sid-snapshot-20140201:1.10
	sid-snapshot-20140101:1.10
	sid-snapshot-20131201:1.10
	sid-snapshot-20131101:1.10
	sid-snapshot-20131001:1.10
	sid-snapshot-20130901:1.10
	sid-snapshot-20130801:1.10
	sid-snapshot-20130701:1.10
	sid-snapshot-20130601:1.10
	insight_7_6-2013-04-10-branchpoint:1.10
	gdb_7_6-branch:1.10.0.56
	sid-snapshot-20130501:1.10
	sid-snapshot-20130401:1.10
	sid-snapshot-20130301:1.10
	sid-snapshot-20130201:1.10
	sid-snapshot-20130101:1.10
	sid-snapshot-20121201:1.10
	sid-snapshot-20121101:1.10
	sid-snapshot-20121001:1.10
	sid-snapshot-20120901:1.10
	gdb_7_5-branch:1.10.0.54
	sid-snapshot-20120801:1.10
	sid-snapshot-20120701:1.10
	sid-snapshot-20120601:1.10
	sid-snapshot-20120501:1.10
	sid-snapshot-20120401:1.10
	gdb_7_4-branch:1.10.0.52
	sid-snapshot-20120301:1.10
	sid-snapshot-20120201:1.10
	sid-snapshot-20120101:1.10
	sid-snapshot-20111201:1.10
	sid-snapshot-20111101:1.10
	sid-snapshot-20111001:1.10
	sid-snapshot-20110901:1.10
	gdb_7_3-branch:1.10.0.50
	sid-snapshot-20110801:1.10
	sid-snapshot-20110701:1.10
	sid-snapshot-20110601:1.10
	sid-snapshot-20110501:1.10
	sid-snapshot-20110401:1.10
	sid-snapshot-20110301:1.10
	sid-snapshot-20110201:1.10
	sid-snapshot-20110101:1.10
	sid-snapshot-20101201:1.10
	sid-snapshot-20101101:1.10
	sid-snapshot-20101001:1.10
	sid-snapshot-20100901:1.10
	sid-snapshot-20100801:1.10
	sid-snapshot-20100701:1.10
	sid-snapshot-20100601:1.10
	sid-snapshot-20100501:1.10
	sid-snapshot-20100401:1.10
	sid-snapshot-20100301:1.10
	gdb_7_1-branch:1.10.0.48
	gdb_7_0-branch:1.10.0.46
	sid-snapshot-20100201:1.10
	sid-snapshot-20100101:1.10
	sid-snapshot-20091201:1.10
	sid-snapshot-20091101:1.10
	sid-snapshot-20091001:1.10
	arc-sim-20090309:1.10
	sid-snapshot-20090901:1.10
	sid-snapshot-20090801:1.10
	sid-snapshot-20090701:1.10
	sid-snapshot-20090601:1.10
	sid-snapshot-20090501:1.10
	kevinb-pre-tcl8_5_7_merge:1.10
	sid-snapshot-20090401:1.10
	arc-insight_6_8-branch:1.10.0.44
	arc-insight_6_8-branchpoint:1.10
	insight_6_8-branch:1.10.0.42
	insight_6_8-branchpoint:1.10
	sid-snapshot-20090301:1.10
	sid-snapshot-20090201:1.10
	sid-snapshot-20090101:1.10
	sid-snapshot-20081201:1.10
	sid-snapshot-20081101:1.10
	sid-snapshot-20081001:1.10
	sid-snapshot-20080901:1.10
	sid-snapshot-20080801:1.10
	sid-snapshot-20080701:1.10
	sid-snapshot-20080601:1.10
	sid-snapshot-20080501:1.10
	sid-snapshot-20080403:1.10
	sid-snapshot-20080401:1.10
	gdb_6_8-branch:1.10.0.40
	sid-snapshot-20080301:1.10
	sid-snapshot-20080201:1.10
	sid-snapshot-20080101:1.10
	sid-snapshot-20071201:1.10
	sid-snapshot-20071101:1.10
	sid-snapshot-20071001:1.10
	insight_6_6-20070208-release:1.10
	gdb_6_6-branch:1.10.0.38
	gdb_6_6-2006-11-15-branchpoint:1.10
	insight_6_5-20061003-release:1.10
	gdb_6_5-branch:1.10.0.36
	gdb_6_5-2006-05-14-branchpoint:1.10
	readline_5_1-import-branch:1.10.0.34
	readline_5_1-import-branchpoint:1.10
	gdb_6_4-branch:1.10.0.32
	gdb_6_4-2005-11-01-branchpoint:1.10
	msnyder-tracepoint-checkpoint-branch:1.10.0.30
	msnyder-tracepoint-checkpoint-branchpoint:1.10
	gdb_6_1-2004-04-05-release:1.10
	ezannoni_pie-20040323-branch:1.10.0.28
	ezannoni_pie-20040323-branchpoint:1.10
	cagney_tramp-20040321-mergepoint:1.10
	cagney_tramp-20040309-branch:1.10.0.26
	cagney_tramp-20040309-branchpoint:1.10
	gdb_6_1-branch:1.10.0.24
	gdb_6_1-2004-03-01-gmt-branchpoint:1.10
	drow-cplus-merge-20040208:1.10
	carlton_dictionary-20040126-merge:1.10
	drow-cplus-merge-20040113:1.10
	drow-cplus-merge-20031224:1.10
	drow-cplus-merge-20031220:1.10
	carlton_dictionary-20031215-merge:1.10
	drow-cplus-merge-20031214:1.10
	carlton-dictionary-20031111-merge:1.10
	gdb_6_0-2003-10-04-release:1.10
	carlton_dictionary-20030917-merge:1.10
	ezannoni_pie-20030916-branchpoint:1.10
	ezannoni_pie-20030916-branch:1.10.0.22
	cagney_x86i386-20030821-branch:1.10.0.20
	cagney_x86i386-20030821-branchpoint:1.10
	carlton_dictionary-20030805-merge:1.10
	carlton_dictionary-20030627-merge:1.10
	gdb_6_0-branch:1.10.0.18
	gdb_6_0-2003-06-23-branchpoint:1.10
	cagney_convert-20030606-branch:1.10.0.16
	cagney_convert-20030606-branchpoint:1.10
	cagney_writestrings-20030508-branch:1.10.0.14
	cagney_writestrings-20030508-branchpoint:1.10
	carlton_dictionary-20030523-merge:1.10
	cagney_fileio-20030521-branch:1.10.0.12
	cagney_fileio-20030521-branchpoint:1.10
	carlton_dictionary-20030430-merge:1.10
	carlton_dictionary-20030416-merge:1.10
	cagney_frameaddr-20030409-mergepoint:1.10
	cagney_frameaddr-20030403-branchpoint:1.10
	cagney_frameaddr-20030403-branch:1.10.0.10
	cagney_framebase-20030330-mergepoint:1.10
	cagney_framebase-20030326-branch:1.10.0.8
	cagney_framebase-20030326-branchpoint:1.10
	cagney_lazyid-20030317-branch:1.10.0.6
	cagney_lazyid-20030317-branchpoint:1.10
	offbyone-20030313-branch:1.10.0.4
	offbyone-20030313-branchpoint:1.10
	carlton_dictionary-20030305-merge:1.10
	cagney_offbyone-20030303-branch:1.10.0.2
	cagney_offbyone-20030303-branchpoint:1.10
	carlton_dictionary-20030207-merge:1.9
	interps-20030202-branch:1.9.0.2
	interps-20030202-branchpoint:1.9
	TCL8_4_1:1.1.1.4
	cagney-unwind-20030108-branch:1.8.0.2
	cagney-unwind-20030108-branchpoint:1.8
	carlton_dictionary-20021223-merge:1.8
	gdb_5_3-2002-12-12-release:1.6
	TCL_8_4_1:1.1.1.4
	carlton_dictionary-20021115-merge:1.7
	kseitz_interps-20021105-merge:1.7
	kseitz_interps-20021103-merge:1.7
	drow-cplus-merge-20021020:1.7
	drow-cplus-merge-20021025:1.7
	carlton_dictionary-20021025-merge:1.7
	carlton_dictionary-20021011-merge:1.7
	drow-cplus-branch:1.7.0.4
	drow-cplus-branchpoint:1.7
	kseitz_interps-20020930-merge:1.7
	carlton_dictionary-20020927-merge:1.7
	tcltk840-20020924-branch:1.7.0.2
	tcltk840-20020924-branchpoint:1.7
	TCL_8_4_0:1.1.1.3
	carlton_dictionary-branch:1.6.0.16
	carlton_dictionary-20020920-branchpoint:1.6
	sid-20020905-branchpoint:1.6
	sid-20020905-branch:1.6.0.14
	gdb_5_3-branch:1.6.0.12
	gdb_5_3-2002-09-04-branchpoint:1.6
	kseitz_interps-20020829-merge:1.6
	cagney_sysregs-20020825-branch:1.6.0.10
	cagney_sysregs-20020825-branchpoint:1.6
	readline_4_3-import-branch:1.6.0.8
	readline_4_3-import-branchpoint:1.6
	gdb_5_2_1-2002-07-23-release:1.6
	kseitz_interps-20020528-branch:1.6.0.6
	kseitz_interps-20020528-branchpoint:1.6
	cagney_regbuf-20020515-branch:1.6.0.4
	cagney_regbuf-20020515-branchpoint:1.6
	gdb_5_2-2002-04-29-release:1.6
	gdb_5_2-branch:1.6.0.2
	gdb_5_2-2002-03-03-branchpoint:1.6
	gdb_5_1_1-2002-01-24-release:1.4
	cygnus_cvs_20020108_pre:1.6
	gdb_5_1_0_1-2002-01-03-branch:1.4.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.4
	gdb_5_1-2001-11-21-release:1.4
	gdb_s390-2001-09-26-branch:1.4.0.4
	gdb_s390-2001-09-26-branchpoint:1.4
	TCL_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.4.0.2
	gdb_5_1-2001-07-29-branchpoint:1.4
	insight-precleanup-2001-01-01:1.4
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	dejagnu-2000-02-04:1.1.1.1
	dejagnu-2000-01-31:1.1.1.1
	dejagnu-2000-01-24:1.1.1.1
	dejagnu-2000-01-17:1.1.1.1
	dejagnu-2000-01-10:1.1.1.1
	dejagnu-2000-01-04:1.1.1.1
	dejagnu-1999-12-21:1.1.1.1
	dejagnu-1999-12-13:1.1.1.1
	dejagnu-1999-12-07:1.1.1.1
	dejagnu-1999-12-06:1.1.1.1
	dejagnu-1999-11-15:1.1.1.1
	dejagnu-1999-11-08:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.10
date	2003.02.12.04.20.58;	author hunt;	state Exp;
branches;
next	1.9;

1.9
date	2003.01.21.19.40.03;	author hunt;	state Exp;
branches;
next	1.8;

1.8
date	2002.11.26.19.47.52;	author hunt;	state Exp;
branches;
next	1.7;

1.7
date	2002.09.24.18.37.02;	author kseitz;	state Exp;
branches
	1.7.2.1
	1.7.4.1;
next	1.6;

1.6
date	2001.09.09.23.56.05;	author irox;	state Exp;
branches
	1.6.16.1;
next	1.5;

1.5
date	2001.09.09.23.26.06;	author irox;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.06.16.18.48;	author cgf;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.06.07.07.38;	author cagney;	state Exp;
branches;
next	1.2;

1.2
date	2000.06.05.23.07.29;	author cgf;	state Exp;
branches;
next	1.1;

1.1
date	99.11.09.01.28.43;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.7.2.1
date	2002.09.27.21.49.03;	author kseitz;	state Exp;
branches;
next	;

1.7.4.1
date	2003.12.14.20.28.43;	author drow;	state Exp;
branches;
next	;

1.6.16.1
date	2002.12.23.19.40.19;	author carlton;	state Exp;
branches;
next	1.6.16.2;

1.6.16.2
date	2003.02.07.19.18.11;	author carlton;	state Exp;
branches;
next	1.6.16.3;

1.6.16.3
date	2003.03.06.00.56.43;	author carlton;	state Exp;
branches;
next	;

1.1.1.1
date	99.11.09.01.28.43;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.09.22.40.55;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.19.56.00;	author kseitz;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.11.26.20.00.16;	author hunt;	state Exp;
branches;
next	;


desc
@@


1.10
log
@2003-02-11  Martin M. Hunt  <hunt@@redhat.com>
	From Mumit Khan  <khan@@nanotech.wisc.edu>

	* generic/tclIOUtil.c (SetFsPathFromAny): Add Cygwin specific
	code to convert POSIX filename to native format.
	* generic/tclFileName.c (Tcl_TranslateFileName): And remove
	from here.
	(TclDoGlob): Adjust.
	* win/tclWinFile.c (TclpObjChdir): Use chdir on Cygwin.
@
text
@/* 
 * tclFileName.c --
 *
 *	This file contains routines for converting file names betwen
 *	native and network form.
 *
 * Copyright (c) 1995-1998 Sun Microsystems, Inc.
 * Copyright (c) 1998-1999 by Scriptics Corporation.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tclFileName.c,v 1.38 2002/09/27 00:50:10 hobbs Exp $
 */

#include "tclInt.h"
#include "tclPort.h"
#include "tclRegexp.h"

/* 
 * This define is used to activate Tcl's interpretation of Unix-style
 * paths (containing forward slashes, '.' and '..') on MacOS.  A 
 * side-effect of this is that some paths become ambiguous.
 */
#define MAC_UNDERSTANDS_UNIX_PATHS

#ifdef MAC_UNDERSTANDS_UNIX_PATHS
/*
 * The following regular expression matches the root portion of a Macintosh
 * absolute path.  It will match degenerate Unix-style paths, tilde paths,
 * Unix-style paths, and Mac paths.  The various subexpressions in this
 * can be summarised as follows: ^(/..|~user/unix|~user:mac|/unix|mac:dir).
 * The subexpression indices which match the root portions, are as follows:
 * 
 * degenerate unix-style: 2
 * unix-tilde: 5
 * mac-tilde: 7
 * unix-style: 9 (or 10 to cut off the irrelevant header).
 * mac: 12
 * 
 */

#define MAC_ROOT_PATTERN "^((/+([.][.]?/+)*([.][.]?)?)|(~[^:/]*)(/[^:]*)?|(~[^:]*)(:.*)?|/+([.][.]?/+)*([^:/]+)(/[^:]*)?|([^:]+):.*)$"

/*
 * The following variables are used to hold precompiled regular expressions
 * for use in filename matching.
 */

typedef struct ThreadSpecificData {
    int initialized;
    Tcl_Obj *macRootPatternPtr;
} ThreadSpecificData;

static Tcl_ThreadDataKey dataKey;

static void		FileNameCleanup _ANSI_ARGS_((ClientData clientData));
static void		FileNameInit _ANSI_ARGS_((void));

#endif

/*
 * The following variable is set in the TclPlatformInit call to one
 * of: TCL_PLATFORM_UNIX, TCL_PLATFORM_MAC, or TCL_PLATFORM_WINDOWS.
 */

TclPlatformType tclPlatform = TCL_PLATFORM_UNIX;

/*
 * Prototypes for local procedures defined in this file:
 */

static CONST char *	DoTildeSubst _ANSI_ARGS_((Tcl_Interp *interp,
			    CONST char *user, Tcl_DString *resultPtr));
static CONST char *	ExtractWinRoot _ANSI_ARGS_((CONST char *path,
			    Tcl_DString *resultPtr, int offset, 
			    Tcl_PathType *typePtr));
static int		SkipToChar _ANSI_ARGS_((char **stringPtr,
			    char *match));
static Tcl_Obj*		SplitMacPath _ANSI_ARGS_((CONST char *path));
static Tcl_Obj*		SplitWinPath _ANSI_ARGS_((CONST char *path));
static Tcl_Obj*		SplitUnixPath _ANSI_ARGS_((CONST char *path));
#ifdef MAC_UNDERSTANDS_UNIX_PATHS

/*
 *----------------------------------------------------------------------
 *
 * FileNameInit --
 *
 *	This procedure initializes the patterns used by this module.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Compiles the regular expressions.
 *
 *----------------------------------------------------------------------
 */

static void
FileNameInit()
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    if (!tsdPtr->initialized) {
	tsdPtr->initialized = 1;
	tsdPtr->macRootPatternPtr = Tcl_NewStringObj(MAC_ROOT_PATTERN, -1);
	Tcl_CreateThreadExitHandler(FileNameCleanup, NULL);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * FileNameCleanup --
 *
 *	This procedure is a Tcl_ExitProc used to clean up the static
 *	data structures used in this file.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Deallocates storage used by the procedures in this file.
 *
 *----------------------------------------------------------------------
 */

static void
FileNameCleanup(clientData)
    ClientData clientData;	/* Not used. */
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    Tcl_DecrRefCount(tsdPtr->macRootPatternPtr);
    tsdPtr->initialized = 0;
}
#endif

/*
 *----------------------------------------------------------------------
 *
 * ExtractWinRoot --
 *
 *	Matches the root portion of a Windows path and appends it
 *	to the specified Tcl_DString.
 *	
 * Results:
 *	Returns the position in the path immediately after the root
 *	including any trailing slashes.
 *	Appends a cleaned up version of the root to the Tcl_DString
 *	at the specified offest.
 *
 * Side effects:
 *	Modifies the specified Tcl_DString.
 *
 *----------------------------------------------------------------------
 */

static CONST char *
ExtractWinRoot(path, resultPtr, offset, typePtr)
    CONST char *path;		/* Path to parse. */
    Tcl_DString *resultPtr;	/* Buffer to hold result. */
    int offset;			/* Offset in buffer where result should be
				 * stored. */
    Tcl_PathType *typePtr;	/* Where to store pathType result */
{
    if (path[0] == '/' || path[0] == '\\') {
	/* Might be a UNC or Vol-Relative path */
	CONST char *host, *share, *tail;
	int hlen, slen;
	if (path[1] != '/' && path[1] != '\\') {
	    Tcl_DStringSetLength(resultPtr, offset);
	    *typePtr = TCL_PATH_VOLUME_RELATIVE;
	    Tcl_DStringAppend(resultPtr, "/", 1);
	    return &path[1];
	}
	host = &path[2];

	/* Skip separators */
	while (host[0] == '/' || host[0] == '\\') host++;

	for (hlen = 0; host[hlen];hlen++) {
	    if (host[hlen] == '/' || host[hlen] == '\\')
		break;
	}
	if (host[hlen] == 0 || host[hlen+1] == 0) {
	    /* 
	     * The path given is simply of the form 
	     * '/foo', '//foo', '/////foo' or the same
	     * with backslashes.  If there is exactly
	     * one leading '/' the path is volume relative
	     * (see filename man page).  If there are more
	     * than one, we are simply assuming they
	     * are superfluous and we trim them away.
	     * (An alternative interpretation would
	     * be that it is a host name, but we have
	     * been documented that that is not the case).
	     */
	    *typePtr = TCL_PATH_VOLUME_RELATIVE;
	    Tcl_DStringAppend(resultPtr, "/", 1);
	    return &path[2];
	}
	Tcl_DStringSetLength(resultPtr, offset);
	share = &host[hlen];

	/* Skip separators */
	while (share[0] == '/' || share[0] == '\\') share++;

	for (slen = 0; share[slen];slen++) {
	    if (share[slen] == '/' || share[slen] == '\\')
		break;
	}
	Tcl_DStringAppend(resultPtr, "//", 2);
	Tcl_DStringAppend(resultPtr, host, hlen);
	Tcl_DStringAppend(resultPtr, "/", 1);
	Tcl_DStringAppend(resultPtr, share, slen);

	tail = &share[slen];

	/* Skip separators */
	while (tail[0] == '/' || tail[0] == '\\') tail++;

	*typePtr = TCL_PATH_ABSOLUTE;
	return tail;
    } else if (*path && path[1] == ':') {
	/* Might be a drive sep */
	Tcl_DStringSetLength(resultPtr, offset);

	if (path[2] != '/' && path[2] != '\\') {
	    *typePtr = TCL_PATH_VOLUME_RELATIVE;
	    Tcl_DStringAppend(resultPtr, path, 2);
	    return &path[2];
	} else {
	    char *tail = (char*)&path[3];

	    /* Skip separators */
	    while (*tail && (tail[0] == '/' || tail[0] == '\\')) tail++;

	    *typePtr = TCL_PATH_ABSOLUTE;
	    Tcl_DStringAppend(resultPtr, path, 2);
	    Tcl_DStringAppend(resultPtr, "/", 1);

	    return tail;
	}
    } else {
	*typePtr = TCL_PATH_RELATIVE;
	return path;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetPathType --
 *
 *	Determines whether a given path is relative to the current
 *	directory, relative to the current volume, or absolute.
 *	
 *	The objectified Tcl_FSGetPathType should be used in
 *	preference to this function (as you can see below, this
 *	is just a wrapper around that other function).
 *
 * Results:
 *	Returns one of TCL_PATH_ABSOLUTE, TCL_PATH_RELATIVE, or
 *	TCL_PATH_VOLUME_RELATIVE.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_PathType
Tcl_GetPathType(path)
    CONST char *path;
{
    Tcl_PathType type;
    Tcl_Obj *tempObj = Tcl_NewStringObj(path,-1);
    Tcl_IncrRefCount(tempObj);
    type = Tcl_FSGetPathType(tempObj);
    Tcl_DecrRefCount(tempObj);
    return type;
}

/*
 *----------------------------------------------------------------------
 *
 * TclpGetNativePathType --
 *
 *	Determines whether a given path is relative to the current
 *	directory, relative to the current volume, or absolute, but
 *	ONLY FOR THE NATIVE FILESYSTEM. This function is called from
 *	tclIOUtil.c (but needs to be here due to its dependence on
 *	static variables/functions in this file).  The exported
 *	function Tcl_FSGetPathType should be used by extensions.
 *
 * Results:
 *	Returns one of TCL_PATH_ABSOLUTE, TCL_PATH_RELATIVE, or
 *	TCL_PATH_VOLUME_RELATIVE.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_PathType
TclpGetNativePathType(pathObjPtr, driveNameLengthPtr, driveNameRef)
    Tcl_Obj *pathObjPtr;
    int *driveNameLengthPtr;
    Tcl_Obj **driveNameRef;
{
    Tcl_PathType type = TCL_PATH_ABSOLUTE;
    int pathLen;
    char *path = Tcl_GetStringFromObj(pathObjPtr, &pathLen);
    
    if (path[0] == '~') {
	/* 
	 * This case is common to all platforms.
	 * Paths that begin with ~ are absolute.
	 */
	if (driveNameLengthPtr != NULL) {
	    char *end = path + 1;
	    while ((*end != '\0') && (*end != '/')) {
		end++;
	    }
	    *driveNameLengthPtr = end - path;
	}
    } else {
	switch (tclPlatform) {
	    case TCL_PLATFORM_UNIX: {
		char *origPath = path;
	        
		/*
		 * Paths that begin with / are absolute.
		 */

#ifdef __QNX__
		/*
		 * Check for QNX //<node id> prefix
		 */
		if (*path && (pathLen > 3) && (path[0] == '/') 
		  && (path[1] == '/') && isdigit(UCHAR(path[2]))) {
		    path += 3;
		    while (isdigit(UCHAR(*path))) {
			++path;
		    }
		}
#endif
		if (path[0] == '/') {
		    if (driveNameLengthPtr != NULL) {
			/* 
			 * We need this addition in case the QNX code 
			 * was used 
			 */
			*driveNameLengthPtr = (1 + path - origPath);
		    }
		} else {
		    type = TCL_PATH_RELATIVE;
		}
		break;
	    }
	    case TCL_PLATFORM_MAC:
		if (path[0] == ':') {
		    type = TCL_PATH_RELATIVE;
		} else {
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
		    ThreadSpecificData *tsdPtr;
		    Tcl_RegExp re;

		    tsdPtr = TCL_TSD_INIT(&dataKey);

		    /*
		     * Since we have eliminated the easy cases, use the
		     * root pattern to look for the other types.
		     */

		    FileNameInit();
		    re = Tcl_GetRegExpFromObj(NULL, tsdPtr->macRootPatternPtr,
			    REG_ADVANCED);

		    if (!Tcl_RegExpExec(NULL, re, path, path)) {
			type = TCL_PATH_RELATIVE;
		    } else {
			CONST char *root, *end;
			Tcl_RegExpRange(re, 2, &root, &end);
			if (root != NULL) {
			    type = TCL_PATH_RELATIVE;
			} else {
			    if (driveNameLengthPtr != NULL) {
				Tcl_RegExpRange(re, 0, &root, &end);
				*driveNameLengthPtr = end - root;
			    }
			    if (driveNameRef != NULL) {
				if (*root == '/') {
				    char *c;
				    int gotColon = 0;
				    *driveNameRef = Tcl_NewStringObj(root + 1,
					    end - root -1);
				    c = Tcl_GetString(*driveNameRef);
				    while (*c != '\0') {
					if (*c == '/') {
					    gotColon++;
					    *c = ':';
					}
					c++;
				    }
				    /* 
				     * If there is no colon, we have just a
				     * volume name so we must add a colon so
				     * it is an absolute path.
				     */
				    if (gotColon == 0) {
				        Tcl_AppendToObj(*driveNameRef, ":", 1);
				    } else if ((gotColon > 1) &&
					    (*(c-1) == ':')) {
					/* We have an extra colon */
				        Tcl_SetObjLength(*driveNameRef, 
					  c - Tcl_GetString(*driveNameRef) - 1);
				    }
				}
			    }
			}
		    }
#else
		    if (path[0] == '~') {
		    } else if (path[0] == ':') {
			type = TCL_PATH_RELATIVE;
		    } else {
			char *colonPos = strchr(path,':');
			if (colonPos == NULL) {
			    type = TCL_PATH_RELATIVE;
			} else {
			}
		    }
		    if (type == TCL_PATH_ABSOLUTE) {
			if (driveNameLengthPtr != NULL) {
			    *driveNameLengthPtr = strlen(path);
			}
		    }
#endif
		}
		break;
	    
	    case TCL_PLATFORM_WINDOWS: {
		Tcl_DString ds;
		CONST char *rootEnd;
		
		Tcl_DStringInit(&ds);
		rootEnd = ExtractWinRoot(path, &ds, 0, &type);
		if ((rootEnd != path) && (driveNameLengthPtr != NULL)) {
		    *driveNameLengthPtr = rootEnd - path;
		    if (driveNameRef != NULL) {
			*driveNameRef = Tcl_NewStringObj(Tcl_DStringValue(&ds),
				Tcl_DStringLength(&ds));
			Tcl_IncrRefCount(*driveNameRef);
		    }
		}
		Tcl_DStringFree(&ds);
		break;
	    }
	}
    }
    return type;
}

/*
 *---------------------------------------------------------------------------
 *
 * TclpNativeSplitPath --
 *
 *      This function takes the given Tcl_Obj, which should be a valid
 *      path, and returns a Tcl List object containing each segment
 *      of that path as an element.
 *
 *      Note this function currently calls the older Split(Plat)Path
 *      functions, which require more memory allocation than is
 *      desirable.
 *      
 * Results:
 *      Returns list object with refCount of zero.  If the passed in
 *      lenPtr is non-NULL, we use it to return the number of elements
 *      in the returned list.
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
 */

Tcl_Obj* 
TclpNativeSplitPath(pathPtr, lenPtr)
    Tcl_Obj *pathPtr;		/* Path to split. */
    int *lenPtr;		/* int to store number of path elements. */
{
    Tcl_Obj *resultPtr = NULL;  /* Needed only to prevent gcc warnings. */

    /*
     * Perform platform specific splitting. 
     */

    switch (tclPlatform) {
	case TCL_PLATFORM_UNIX:
	    resultPtr = SplitUnixPath(Tcl_GetString(pathPtr));
	    break;

	case TCL_PLATFORM_WINDOWS:
	    resultPtr = SplitWinPath(Tcl_GetString(pathPtr));
	    break;
	    
	case TCL_PLATFORM_MAC:
	    resultPtr = SplitMacPath(Tcl_GetString(pathPtr));
	    break;
    }

    /*
     * Compute the number of elements in the result.
     */

    if (lenPtr != NULL) {
	Tcl_ListObjLength(NULL, resultPtr, lenPtr);
    }
    return resultPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_SplitPath --
 *
 *	Split a path into a list of path components.  The first element
 *	of the list will have the same path type as the original path.
 *
 * Results:
 *	Returns a standard Tcl result.  The interpreter result contains
 *	a list of path components.
 *	*argvPtr will be filled in with the address of an array
 *	whose elements point to the elements of path, in order.
 *	*argcPtr will get filled in with the number of valid elements
 *	in the array.  A single block of memory is dynamically allocated
 *	to hold both the argv array and a copy of the path elements.
 *	The caller must eventually free this memory by calling ckfree()
 *	on *argvPtr.  Note:  *argvPtr and *argcPtr are only modified
 *	if the procedure returns normally.
 *
 * Side effects:
 *	Allocates memory.
 *
 *----------------------------------------------------------------------
 */

void
Tcl_SplitPath(path, argcPtr, argvPtr)
    CONST char *path;		/* Pointer to string containing a path. */
    int *argcPtr;		/* Pointer to location to fill in with
				 * the number of elements in the path. */
    CONST char ***argvPtr;	/* Pointer to place to store pointer to array
				 * of pointers to path elements. */
{
    Tcl_Obj *resultPtr = NULL;  /* Needed only to prevent gcc warnings. */
    Tcl_Obj *tmpPtr, *eltPtr;
    int i, size, len;
    char *p, *str;

    /*
     * Perform the splitting, using objectified, vfs-aware code.
     */

    tmpPtr = Tcl_NewStringObj(path, -1);
    Tcl_IncrRefCount(tmpPtr);
    resultPtr = Tcl_FSSplitPath(tmpPtr, argcPtr);
    Tcl_DecrRefCount(tmpPtr);

    /* Calculate space required for the result */
    
    size = 1;
    for (i = 0; i < *argcPtr; i++) {
	Tcl_ListObjIndex(NULL, resultPtr, i, &eltPtr);
	Tcl_GetStringFromObj(eltPtr, &len);
	size += len + 1;
    }
    
    /*
     * Allocate a buffer large enough to hold the contents of all of
     * the list plus the argv pointers and the terminating NULL pointer.
     */

    *argvPtr = (CONST char **) ckalloc((unsigned)
	    ((((*argcPtr) + 1) * sizeof(char *)) + size));

    /*
     * Position p after the last argv pointer and copy the contents of
     * the list in, piece by piece.
     */

    p = (char *) &(*argvPtr)[(*argcPtr) + 1];
    for (i = 0; i < *argcPtr; i++) {
	Tcl_ListObjIndex(NULL, resultPtr, i, &eltPtr);
	str = Tcl_GetStringFromObj(eltPtr, &len);
	memcpy((VOID *) p, (VOID *) str, (size_t) len+1);
	p += len+1;
    }
    
    /*
     * Now set up the argv pointers.
     */

    p = (char *) &(*argvPtr)[(*argcPtr) + 1];

    for (i = 0; i < *argcPtr; i++) {
	(*argvPtr)[i] = p;
	while ((*p++) != '\0') {}
    }
    (*argvPtr)[i] = NULL;

    /*
     * Free the result ptr given to us by Tcl_FSSplitPath
     */

    Tcl_DecrRefCount(resultPtr);
}

/*
 *----------------------------------------------------------------------
 *
 * SplitUnixPath --
 *
 *	This routine is used by Tcl_(FS)SplitPath to handle splitting
 *	Unix paths.
 *
 * Results:
 *	Returns a newly allocated Tcl list object.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static Tcl_Obj*
SplitUnixPath(path)
    CONST char *path;		/* Pointer to string containing a path. */
{
    int length;
    CONST char *p, *elementStart;
    Tcl_Obj *result = Tcl_NewObj();

    /*
     * Deal with the root directory as a special case.
     */

#ifdef __QNX__
    /*
     * Check for QNX //<node id> prefix
     */
    if ((path[0] == '/') && (path[1] == '/')
	    && isdigit(UCHAR(path[2]))) { /* INTL: digit */
	path += 3;
	while (isdigit(UCHAR(*path))) { /* INTL: digit */
	    ++path;
	}
    }
#endif

    if (path[0] == '/') {
	Tcl_ListObjAppendElement(NULL, result, Tcl_NewStringObj("/",1));
	p = path+1;
    } else {
	p = path;
    }

    /*
     * Split on slashes.  Embedded elements that start with tilde will be
     * prefixed with "./" so they are not affected by tilde substitution.
     */

    for (;;) {
	elementStart = p;
	while ((*p != '\0') && (*p != '/')) {
	    p++;
	}
	length = p - elementStart;
	if (length > 0) {
	    Tcl_Obj *nextElt;
	    if ((elementStart[0] == '~') && (elementStart != path)) {
		nextElt = Tcl_NewStringObj("./",2);
		Tcl_AppendToObj(nextElt, elementStart, length);
	    } else {
		nextElt = Tcl_NewStringObj(elementStart, length);
	    }
	    Tcl_ListObjAppendElement(NULL, result, nextElt);
	}
	if (*p++ == '\0') {
	    break;
	}
    }
    return result;
}


/*
 *----------------------------------------------------------------------
 *
 * SplitWinPath --
 *
 *	This routine is used by Tcl_(FS)SplitPath to handle splitting
 *	Windows paths.
 *
 * Results:
 *	Returns a newly allocated Tcl list object.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static Tcl_Obj*
SplitWinPath(path)
    CONST char *path;		/* Pointer to string containing a path. */
{
    int length;
    CONST char *p, *elementStart;
    Tcl_PathType type = TCL_PATH_ABSOLUTE;
    Tcl_DString buf;
    Tcl_Obj *result = Tcl_NewObj();
    Tcl_DStringInit(&buf);
    
    p = ExtractWinRoot(path, &buf, 0, &type);

    /*
     * Terminate the root portion, if we matched something.
     */

    if (p != path) {
	Tcl_ListObjAppendElement(NULL, result, 
				 Tcl_NewStringObj(Tcl_DStringValue(&buf), 
						  Tcl_DStringLength(&buf)));
    }
    Tcl_DStringFree(&buf);
    
    /*
     * Split on slashes.  Embedded elements that start with tilde will be
     * prefixed with "./" so they are not affected by tilde substitution.
     */

    do {
	elementStart = p;
	while ((*p != '\0') && (*p != '/') && (*p != '\\')) {
	    p++;
	}
	length = p - elementStart;
	if (length > 0) {
	    Tcl_Obj *nextElt;
	    if ((elementStart[0] == '~') && (elementStart != path)) {
		nextElt = Tcl_NewStringObj("./",2);
		Tcl_AppendToObj(nextElt, elementStart, length);
	    } else {
		nextElt = Tcl_NewStringObj(elementStart, length);
	    }
	    Tcl_ListObjAppendElement(NULL, result, nextElt);
	}
    } while (*p++ != '\0');

    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * SplitMacPath --
 *
 *	This routine is used by Tcl_(FS)SplitPath to handle splitting
 *	Macintosh paths.
 *
 * Results:
 *	Returns a newly allocated Tcl list object.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static Tcl_Obj*
SplitMacPath(path)
    CONST char *path;		/* Pointer to string containing a path. */
{
    int isMac = 0;		/* 1 if is Mac-style, 0 if Unix-style path. */
    int length;
    CONST char *p, *elementStart;
    Tcl_Obj *result;
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
    Tcl_RegExp re;
    int i;
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
#endif
    
    result = Tcl_NewObj();
    
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
    /*
     * Initialize the path name parser for Macintosh path names.
     */

    FileNameInit();

    /*
     * Match the root portion of a Mac path name.
     */

    i = 0;			/* Needed only to prevent gcc warnings. */

    re = Tcl_GetRegExpFromObj(NULL, tsdPtr->macRootPatternPtr, REG_ADVANCED);

    if (Tcl_RegExpExec(NULL, re, path, path) == 1) {
	CONST char *start, *end;
	Tcl_Obj *nextElt;

	/*
	 * Treat degenerate absolute paths like / and /../.. as
	 * Mac relative file names for lack of anything else to do.
	 */

	Tcl_RegExpRange(re, 2, &start, &end);
	if (start) {
	    Tcl_Obj *elt = Tcl_NewStringObj(":", 1);
	    Tcl_RegExpRange(re, 0, &start, &end);
	    Tcl_AppendToObj(elt, path, end - start);
	    Tcl_ListObjAppendElement(NULL, result, elt);
	    return result;
	}

	Tcl_RegExpRange(re, 5, &start, &end);
	if (start) {
	    /*
	     * Unix-style tilde prefixed paths.
	     */

	    isMac = 0;
	    i = 5;
	} else {
	    Tcl_RegExpRange(re, 7, &start, &end);
	    if (start) {
		/*
		 * Mac-style tilde prefixed paths.
		 */

		isMac = 1;
		i = 7;
	    } else {
		Tcl_RegExpRange(re, 10, &start, &end);
		if (start) {
		    /*
		     * Normal Unix style paths.
		     */

		    isMac = 0;
		    i = 10;
		} else {
		    Tcl_RegExpRange(re, 12, &start, &end);
		    if (start) {
			/*
			 * Normal Mac style paths.
			 */

			isMac = 1;
			i = 12;
		    }
		}
	    }
	}
	Tcl_RegExpRange(re, i, &start, &end);
	length = end - start;

	/*
	 * Append the element and terminate it with a : 
	 */

	nextElt = Tcl_NewStringObj(start, length);
	Tcl_AppendToObj(nextElt, ":", 1);
	Tcl_ListObjAppendElement(NULL, result, nextElt);
	p = end;
    } else {
	isMac = (strchr(path, ':') != NULL);
	p = path;
    }
#else
    if ((path[0] != ':') && (path[0] == '~' || (strchr(path,':') != NULL))) {
	CONST char *end;
	Tcl_Obj *nextElt;

	isMac = 1;
	
	end = strchr(path,':');
	if (end == NULL) {
	    length = strlen(path);
	} else {
	    length = end - path;
	}

	/*
	 * Append the element and terminate it with a :
	 */

	nextElt = Tcl_NewStringObj(path, length);
	Tcl_AppendToObj(nextElt, ":", 1);
	Tcl_ListObjAppendElement(NULL, result, nextElt);
	p = path + length;
    } else {
	isMac = (strchr(path, ':') != NULL);
	isMac = 1;
	p = path;
    }
#endif
    
    if (isMac) {

	/*
	 * p is pointing at the first colon in the path.  There
	 * will always be one, since this is a Mac-style path.
	 * (This is no longer true if MAC_UNDERSTANDS_UNIX_PATHS 
	 * is false, so we must check whether 'p' points to the
	 * end of the string.)
	 */
	elementStart = p;
	if (*p == ':') {
	    p++;
	}
	
	while ((p = strchr(p, ':')) != NULL) {
	    length = p - elementStart;
	    if (length == 1) {
		while (*p == ':') {
		    Tcl_ListObjAppendElement(NULL, result,
			    Tcl_NewStringObj("::", 2));
		    elementStart = p++;
		}
	    } else {
		/*
		 * If this is a simple component, drop the leading colon.
		 */

		if ((elementStart[1] != '~')
			&& (strchr(elementStart+1, '/') == NULL)) {
		    elementStart++;
		    length--;
		}
		Tcl_ListObjAppendElement(NULL, result, 
			Tcl_NewStringObj(elementStart, length));
		elementStart = p++;
	    }
	}
	if (elementStart[0] != ':') {
	    if (elementStart[0] != '\0') {
		Tcl_ListObjAppendElement(NULL, result, 
			Tcl_NewStringObj(elementStart, -1));
	    }
	} else {
	    if (elementStart[1] != '\0' || elementStart == path) {
		if ((elementStart[1] != '~') && (elementStart[1] != '\0')
			&& (strchr(elementStart+1, '/') == NULL)) {
		    elementStart++;
		}
		Tcl_ListObjAppendElement(NULL, result, 
			Tcl_NewStringObj(elementStart, -1));
	    }
	}
    } else {

	/*
	 * Split on slashes, suppress extra /'s, and convert .. to ::. 
	 */

	for (;;) {
	    elementStart = p;
	    while ((*p != '\0') && (*p != '/')) {
		p++;
	    }
	    length = p - elementStart;
	    if (length > 0) {
		if ((length == 1) && (elementStart[0] == '.')) {
		    Tcl_ListObjAppendElement(NULL, result, 
					     Tcl_NewStringObj(":", 1));
		} else if ((length == 2) && (elementStart[0] == '.')
			&& (elementStart[1] == '.')) {
		    Tcl_ListObjAppendElement(NULL, result, 
					     Tcl_NewStringObj("::", 2));
		} else {
		    Tcl_Obj *nextElt;
		    if (*elementStart == '~') {
			nextElt = Tcl_NewStringObj(":",1);
			Tcl_AppendToObj(nextElt, elementStart, length);
		    } else {
			nextElt = Tcl_NewStringObj(elementStart, length);
		    }
		    Tcl_ListObjAppendElement(NULL, result, nextElt);
		}
	    }
	    if (*p++ == '\0') {
		break;
	    }
	}
    }
    return result;
}

/*
 *---------------------------------------------------------------------------
 *
 * Tcl_FSJoinToPath --
 *
 *      This function takes the given object, which should usually be a
 *      valid path or NULL, and joins onto it the array of paths
 *      segments given.
 *
 * Results:
 *      Returns object with refCount of zero
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
 */

Tcl_Obj* 
Tcl_FSJoinToPath(basePtr, objc, objv)
    Tcl_Obj *basePtr;
    int objc;
    Tcl_Obj *CONST objv[];
{
    int i;
    Tcl_Obj *lobj, *ret;

    if (basePtr == NULL) {
	lobj = Tcl_NewListObj(0, NULL);
    } else {
	lobj = Tcl_NewListObj(1, &basePtr);
    }
    
    for (i = 0; i<objc;i++) {
	Tcl_ListObjAppendElement(NULL, lobj, objv[i]);
    }
    ret = Tcl_FSJoinPath(lobj, -1);
    Tcl_DecrRefCount(lobj);
    return ret;
}

/*
 *---------------------------------------------------------------------------
 *
 * TclpNativeJoinPath --
 *
 *      'prefix' is absolute, 'joining' is relative to prefix.
 *
 * Results:
 *      modifies prefix
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
 */

void
TclpNativeJoinPath(prefix, joining)
    Tcl_Obj *prefix;
    char* joining;
{
    int length, needsSep;
    char *dest, *p, *start;
    
    start = Tcl_GetStringFromObj(prefix, &length);

    /*
     * Remove the ./ from tilde prefixed elements unless
     * it is the first component.
     */
    
    p = joining;
    
    if (length != 0) {
	if ((p[0] == '.') && (p[1] == '/') && (p[2] == '~')) {
	    p += 2;
	}
    }
       
    if (*p == '\0') {
	return;
    }


    switch (tclPlatform) {
        case TCL_PLATFORM_UNIX:
	    /*
	     * Append a separator if needed.
	     */

	    if (length > 0 && (start[length-1] != '/')) {
		Tcl_AppendToObj(prefix, "/", 1);
		length++;
	    }
	    needsSep = 0;
	    
	    /*
	     * Append the element, eliminating duplicate and trailing
	     * slashes.
	     */

	    Tcl_SetObjLength(prefix, length + (int) strlen(p));
	    
	    dest = Tcl_GetString(prefix) + length;
	    for (; *p != '\0'; p++) {
		if (*p == '/') {
		    while (p[1] == '/') {
			p++;
		    }
		    if (p[1] != '\0') {
			if (needsSep) {
			    *dest++ = '/';
			}
		    }
		} else {
		    *dest++ = *p;
		    needsSep = 1;
		}
	    }
	    length = dest - Tcl_GetString(prefix);
	    Tcl_SetObjLength(prefix, length);
	    break;

	case TCL_PLATFORM_WINDOWS:
	    /*
	     * Check to see if we need to append a separator.
	     */

	    if ((length > 0) && 
		(start[length-1] != '/') && (start[length-1] != ':')) {
		Tcl_AppendToObj(prefix, "/", 1);
		length++;
	    }
	    needsSep = 0;
	    
	    /*
	     * Append the element, eliminating duplicate and
	     * trailing slashes.
	     */

	    Tcl_SetObjLength(prefix, length + (int) strlen(p));
	    dest = Tcl_GetString(prefix) + length;
	    for (; *p != '\0'; p++) {
		if ((*p == '/') || (*p == '\\')) {
		    while ((p[1] == '/') || (p[1] == '\\')) {
			p++;
		    }
		    if ((p[1] != '\0') && needsSep) {
			*dest++ = '/';
		    }
		} else {
		    *dest++ = *p;
		    needsSep = 1;
		}
	    }
	    length = dest - Tcl_GetString(prefix);
	    Tcl_SetObjLength(prefix, length);
	    break;

	case TCL_PLATFORM_MAC: {
	    int newLength;
	    
	    /*
	     * Sort out separators.  We basically add the object we've
	     * been given, but we have to make sure that there is
	     * exactly one separator inbetween (unless the object we're
	     * adding contains multiple contiguous colons, all of which
	     * we must add).  Also if an object is just ':' we don't
	     * bother to add it unless it's the very first element.
	     */

#ifdef MAC_UNDERSTANDS_UNIX_PATHS
	    int adjustedPath = 0;
	    if ((strchr(p, ':') == NULL) && (strchr(p, '/') != NULL)) {
		char *start = p;
		adjustedPath = 1;
		while (*start != '\0') {
		    if (*start == '/') {
		        *start = ':';
		    }
		    start++;
		}
	    }
#endif
	    if (length > 0) {
		if ((p[0] == ':') && (p[1] == '\0')) {
		    return;
		}
		if (start[length-1] != ':') {
		    if (*p != '\0' && *p != ':') {
			Tcl_AppendToObj(prefix, ":", 1);
			length++;
		    }
		} else if (*p == ':') {
		    p++;
		}
	    } else {
		if (*p != '\0' && *p != ':') {
		    Tcl_AppendToObj(prefix, ":", 1);
		    length++;
		}
	    }
	    
	    /*
	     * Append the element
	     */

	    newLength = strlen(p);
	    /* 
	     * It may not be good to just do 'Tcl_AppendToObj(prefix,
	     * p, newLength)' because the object may contain duplicate
	     * colons which we want to get rid of.
	     */
	    Tcl_AppendToObj(prefix, p, newLength);
	    
	    /* Remove spurious trailing single ':' */
	    dest = Tcl_GetString(prefix) + length + newLength;
	    if (*(dest-1) == ':') {
		if (dest-1 > Tcl_GetString(prefix)) {
		    if (*(dest-2) != ':') {
		        Tcl_SetObjLength(prefix, length + newLength -1);
		    }
		}
	    }
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
	    /* Revert the path to what it was */
	    if (adjustedPath) {
		char *start = joining;
		while (*start != '\0') {
		    if (*start == ':') {
			*start = '/';
		    }
		    start++;
		}
	    }
#endif
	    break;
	}
    }
    return;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_JoinPath --
 *
 *	Combine a list of paths in a platform specific manner.  The
 *	function 'Tcl_FSJoinPath' should be used in preference where
 *	possible.
 *
 * Results:
 *	Appends the joined path to the end of the specified 
 *	Tcl_DString returning a pointer to the resulting string.  Note
 *	that the Tcl_DString must already be initialized.
 *
 * Side effects:
 *	Modifies the Tcl_DString.
 *
 *----------------------------------------------------------------------
 */

char *
Tcl_JoinPath(argc, argv, resultPtr)
    int argc;
    CONST char * CONST *argv;
    Tcl_DString *resultPtr;	/* Pointer to previously initialized DString */
{
    int i, len;
    Tcl_Obj *listObj = Tcl_NewObj();
    Tcl_Obj *resultObj;
    char *resultStr;

    /* Build the list of paths */
    for (i = 0; i < argc; i++) {
        Tcl_ListObjAppendElement(NULL, listObj,
		Tcl_NewStringObj(argv[i], -1));
    }

    /* Ask the objectified code to join the paths */
    Tcl_IncrRefCount(listObj);
    resultObj = Tcl_FSJoinPath(listObj, argc);
    Tcl_IncrRefCount(resultObj);
    Tcl_DecrRefCount(listObj);

    /* Store the result */
    resultStr = Tcl_GetStringFromObj(resultObj, &len);
    Tcl_DStringAppend(resultPtr, resultStr, len);
    Tcl_DecrRefCount(resultObj);

    /* Return a pointer to the result */
    return Tcl_DStringValue(resultPtr);
}

/*
 *---------------------------------------------------------------------------
 *
 * Tcl_TranslateFileName --
 *
 *	Converts a file name into a form usable by the native system
 *	interfaces.  If the name starts with a tilde, it will produce a
 *	name where the tilde and following characters have been replaced
 *	by the home directory location for the named user.
 *
 * Results:
 *	The return value is a pointer to a string containing the name
 *	after tilde substitution.  If there was no tilde substitution,
 *	the return value is a pointer to a copy of the original string.
 *	If there was an error in processing the name, then an error
 *	message is left in the interp's result (if interp was not NULL)
 *	and the return value is NULL.  Space for the return value is
 *	allocated in bufferPtr; the caller must call Tcl_DStringFree()
 *	to free the space if the return value was not NULL.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

char *
Tcl_TranslateFileName(interp, name, bufferPtr)
    Tcl_Interp *interp;		/* Interpreter in which to store error
				 * message (if necessary). */
    CONST char *name;		/* File name, which may begin with "~" (to
				 * indicate current user's home directory) or
				 * "~<user>" (to indicate any user's home
				 * directory). */
    Tcl_DString *bufferPtr;	/* Uninitialized or free DString filled
				 * with name after tilde substitution. */
{
    Tcl_Obj *path = Tcl_NewStringObj(name, -1);
    CONST char *result;

    Tcl_IncrRefCount(path);
    result = Tcl_FSGetTranslatedStringPath(interp, path);
    if (result == NULL) {
	Tcl_DecrRefCount(path);
	return NULL;
    }
    Tcl_DStringInit(bufferPtr);
    Tcl_DStringAppend(bufferPtr, result, -1);
    Tcl_DecrRefCount(path);

    /*
     * Convert forward slashes to backslashes in Windows paths because
     * some system interfaces don't accept forward slashes.
     */

    if (tclPlatform == TCL_PLATFORM_WINDOWS) {
	register char *p;
	for (p = Tcl_DStringValue(bufferPtr); *p != '\0'; p++) {
	    if (*p == '/') {
		*p = '\\';
	    }
	}
    }
    return Tcl_DStringValue(bufferPtr);
}

/*
 *----------------------------------------------------------------------
 *
 * TclGetExtension --
 *
 *	This function returns a pointer to the beginning of the
 *	extension part of a file name.
 *
 * Results:
 *	Returns a pointer into name which indicates where the extension
 *	starts.  If there is no extension, returns NULL.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

char *
TclGetExtension(name)
    char *name;			/* File name to parse. */
{
    char *p, *lastSep;

    /*
     * First find the last directory separator.
     */

    lastSep = NULL;		/* Needed only to prevent gcc warnings. */
    switch (tclPlatform) {
	case TCL_PLATFORM_UNIX:
	    lastSep = strrchr(name, '/');
	    break;

	case TCL_PLATFORM_MAC:
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
	    if (strchr(name, ':') == NULL) {
		lastSep = strrchr(name, '/');
	    } else {
		lastSep = strrchr(name, ':');
	    }
#else
	    lastSep = strrchr(name, ':');
#endif
	    break;

	case TCL_PLATFORM_WINDOWS:
	    lastSep = NULL;
	    for (p = name; *p != '\0'; p++) {
		if (strchr("/\\:", *p) != NULL) {
		    lastSep = p;
		}
	    }
	    break;
    }
    p = strrchr(name, '.');
    if ((p != NULL) && (lastSep != NULL) && (lastSep > p)) {
	p = NULL;
    }

    /*
     * In earlier versions, we used to back up to the first period in a series
     * so that "foo..o" would be split into "foo" and "..o".  This is a
     * confusing and usually incorrect behavior, so now we split at the last
     * period in the name.
     */

    return p;
}

/*
 *----------------------------------------------------------------------
 *
 * DoTildeSubst --
 *
 *	Given a string following a tilde, this routine returns the
 *	corresponding home directory.
 *
 * Results:
 *	The result is a pointer to a static string containing the home
 *	directory in native format.  If there was an error in processing
 *	the substitution, then an error message is left in the interp's
 *	result and the return value is NULL.  On success, the results
 *	are appended to resultPtr, and the contents of resultPtr are
 *	returned.
 *
 * Side effects:
 *	Information may be left in resultPtr.
 *
 *----------------------------------------------------------------------
 */

static CONST char *
DoTildeSubst(interp, user, resultPtr)
    Tcl_Interp *interp;		/* Interpreter in which to store error
				 * message (if necessary). */
    CONST char *user;		/* Name of user whose home directory should be
				 * substituted, or "" for current user. */
    Tcl_DString *resultPtr;	/* Initialized DString filled with name
				 * after tilde substitution. */
{
    CONST char *dir;

    if (*user == '\0') {
	Tcl_DString dirString;
	
	dir = TclGetEnv("HOME", &dirString);
	if (dir == NULL) {
	    if (interp) {
		Tcl_ResetResult(interp);
		Tcl_AppendResult(interp, "couldn't find HOME environment ",
			"variable to expand path", (char *) NULL);
	    }
	    return NULL;
	}
	Tcl_JoinPath(1, &dir, resultPtr);
	Tcl_DStringFree(&dirString);
    } else {
	if (TclpGetUserHome(user, resultPtr) == NULL) {	
	    if (interp) {
		Tcl_ResetResult(interp);
		Tcl_AppendResult(interp, "user \"", user, "\" doesn't exist",
			(char *) NULL);
	    }
	    return NULL;
	}
    }
    return Tcl_DStringValue(resultPtr);
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_GlobObjCmd --
 *
 *	This procedure is invoked to process the "glob" Tcl command.
 *	See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
int
Tcl_GlobObjCmd(dummy, interp, objc, objv)
    ClientData dummy;			/* Not used. */
    Tcl_Interp *interp;			/* Current interpreter. */
    int objc;				/* Number of arguments. */
    Tcl_Obj *CONST objv[];		/* Argument objects. */
{
    int index, i, globFlags, length, join, dir, result;
    char *string, *separators;
    Tcl_Obj *typePtr, *resultPtr, *look;
    Tcl_Obj *pathOrDir = NULL;
    Tcl_DString prefix;
    static CONST char *options[] = {
	"-directory", "-join", "-nocomplain", "-path", "-tails", 
	"-types", "--", NULL
    };
    enum options {
	GLOB_DIR, GLOB_JOIN, GLOB_NOCOMPLAIN, GLOB_PATH, GLOB_TAILS, 
	GLOB_TYPE, GLOB_LAST
    };
    enum pathDirOptions {PATH_NONE = -1 , PATH_GENERAL = 0, PATH_DIR = 1};
    Tcl_GlobTypeData *globTypes = NULL;

    globFlags = 0;
    join = 0;
    dir = PATH_NONE;
    typePtr = NULL;
    resultPtr = Tcl_GetObjResult(interp);
    for (i = 1; i < objc; i++) {
	if (Tcl_GetIndexFromObj(interp, objv[i], options, "option", 0, &index)
		!= TCL_OK) {
	    string = Tcl_GetStringFromObj(objv[i], &length);
	    if (string[0] == '-') {
		/*
		 * It looks like the command contains an option so signal
		 * an error
		 */
		return TCL_ERROR;
	    } else {
		/*
		 * This clearly isn't an option; assume it's the first
		 * glob pattern.  We must clear the error
		 */
		Tcl_ResetResult(interp);
		break;
	    }
	}
	switch (index) {
	    case GLOB_NOCOMPLAIN:			/* -nocomplain */
	        globFlags |= TCL_GLOBMODE_NO_COMPLAIN;
		break;
	    case GLOB_DIR:				/* -dir */
		if (i == (objc-1)) {
		    Tcl_AppendToObj(resultPtr,
			    "missing argument to \"-directory\"", -1);
		    return TCL_ERROR;
		}
		if (dir != PATH_NONE) {
		    Tcl_AppendToObj(resultPtr,
			    "\"-directory\" cannot be used with \"-path\"",
			    -1);
		    return TCL_ERROR;
		}
		dir = PATH_DIR;
		globFlags |= TCL_GLOBMODE_DIR;
		pathOrDir = objv[i+1];
		i++;
		break;
	    case GLOB_JOIN:				/* -join */
		join = 1;
		break;
	    case GLOB_TAILS:				/* -tails */
	        globFlags |= TCL_GLOBMODE_TAILS;
		break;
	    case GLOB_PATH:				/* -path */
	        if (i == (objc-1)) {
		    Tcl_AppendToObj(resultPtr,
			    "missing argument to \"-path\"", -1);
		    return TCL_ERROR;
		}
		if (dir != PATH_NONE) {
		    Tcl_AppendToObj(resultPtr,
			    "\"-path\" cannot be used with \"-directory\"",
			    -1);
		    return TCL_ERROR;
		}
		dir = PATH_GENERAL;
		pathOrDir = objv[i+1];
		i++;
		break;
	    case GLOB_TYPE:				/* -types */
	        if (i == (objc-1)) {
		    Tcl_AppendToObj(resultPtr,
			    "missing argument to \"-types\"", -1);
		    return TCL_ERROR;
		}
		typePtr = objv[i+1];
		if (Tcl_ListObjLength(interp, typePtr, &length) != TCL_OK) {
		    return TCL_ERROR;
		}
		i++;
		break;
	    case GLOB_LAST:				/* -- */
	        i++;
		goto endOfForLoop;
		break;
	}
    }
    endOfForLoop:
    if (objc - i < 1) {
        Tcl_WrongNumArgs(interp, 1, objv, "?switches? name ?name ...?");
	return TCL_ERROR;
    }
    if ((globFlags & TCL_GLOBMODE_TAILS) && (pathOrDir == NULL)) {
	Tcl_AppendToObj(resultPtr,
	  "\"-tails\" must be used with either \"-directory\" or \"-path\"",
	  -1);
	return TCL_ERROR;
    }
    
    separators = NULL;		/* lint. */
    switch (tclPlatform) {
	case TCL_PLATFORM_UNIX:
	    separators = "/";
	    break;
	case TCL_PLATFORM_WINDOWS:
	    separators = "/\\:";
	    break;
	case TCL_PLATFORM_MAC:
	    separators = ":";
	    break;
    }
    if (dir == PATH_GENERAL) {
	int pathlength;
	char *last;
	char *first = Tcl_GetStringFromObj(pathOrDir,&pathlength);

	/*
	 * Find the last path separator in the path
	 */
	last = first + pathlength;
	for (; last != first; last--) {
	    if (strchr(separators, *(last-1)) != NULL) {
		break;
	    }
	}
	if (last == first + pathlength) {
	    /* It's really a directory */
	    dir = PATH_DIR;
	} else {
	    Tcl_DString pref;
	    char *search, *find;
	    Tcl_DStringInit(&pref);
	    if (last == first) {
		/* The whole thing is a prefix */
		Tcl_DStringAppend(&pref, first, -1);
		pathOrDir = NULL;
	    } else {
		/* Have to split off the end */
		Tcl_DStringAppend(&pref, last, first+pathlength-last);
		pathOrDir = Tcl_NewStringObj(first, last-first-1);
	    }
	    /* Need to quote 'prefix' */
	    Tcl_DStringInit(&prefix);
	    search = Tcl_DStringValue(&pref);
	    while ((find = (strpbrk(search, "\\[]*?{}"))) != NULL) {
	        Tcl_DStringAppend(&prefix, search, find-search);
	        Tcl_DStringAppend(&prefix, "\\", 1);
	        Tcl_DStringAppend(&prefix, find, 1);
	        search = find+1;
	        if (*search == '\0') {
	            break;
	        }
	    }
	    if (*search != '\0') {
		Tcl_DStringAppend(&prefix, search, -1);
	    }
	    Tcl_DStringFree(&pref);
	}
    }
    
    if (pathOrDir != NULL) {
	Tcl_IncrRefCount(pathOrDir);
    }
    
    if (typePtr != NULL) {
	/* 
	 * The rest of the possible type arguments (except 'd') are
	 * platform specific.  We don't complain when they are used
	 * on an incompatible platform.
	 */
	Tcl_ListObjLength(interp, typePtr, &length);
	globTypes = (Tcl_GlobTypeData*) ckalloc(sizeof(Tcl_GlobTypeData));
	globTypes->type = 0;
	globTypes->perm = 0;
	globTypes->macType = NULL;
	globTypes->macCreator = NULL;
	while(--length >= 0) {
	    int len;
	    char *str;
	    Tcl_ListObjIndex(interp, typePtr, length, &look);
	    str = Tcl_GetStringFromObj(look, &len);
	    if (strcmp("readonly", str) == 0) {
		globTypes->perm |= TCL_GLOB_PERM_RONLY;
	    } else if (strcmp("hidden", str) == 0) {
		globTypes->perm |= TCL_GLOB_PERM_HIDDEN;
	    } else if (len == 1) {
		switch (str[0]) {
		  case 'r':
		    globTypes->perm |= TCL_GLOB_PERM_R;
		    break;
		  case 'w':
		    globTypes->perm |= TCL_GLOB_PERM_W;
		    break;
		  case 'x':
		    globTypes->perm |= TCL_GLOB_PERM_X;
		    break;
		  case 'b':
		    globTypes->type |= TCL_GLOB_TYPE_BLOCK;
		    break;
		  case 'c':
		    globTypes->type |= TCL_GLOB_TYPE_CHAR;
		    break;
		  case 'd':
		    globTypes->type |= TCL_GLOB_TYPE_DIR;
		    break;
		  case 'p':
		    globTypes->type |= TCL_GLOB_TYPE_PIPE;
		    break;
		  case 'f':
		    globTypes->type |= TCL_GLOB_TYPE_FILE;
		    break;
	          case 'l':
		    globTypes->type |= TCL_GLOB_TYPE_LINK;
		    break;
		  case 's':
		    globTypes->type |= TCL_GLOB_TYPE_SOCK;
		    break;
		  default:
		    goto badTypesArg;
		}
	    } else if (len == 4) {
		/* This is assumed to be a MacOS file type */
		if (globTypes->macType != NULL) {
		    goto badMacTypesArg;
		}
		globTypes->macType = look;
		Tcl_IncrRefCount(look);
	    } else {
		Tcl_Obj* item;
		if ((Tcl_ListObjLength(NULL, look, &len) == TCL_OK) &&
			(len == 3)) {
		    Tcl_ListObjIndex(interp, look, 0, &item);
		    if (!strcmp("macintosh", Tcl_GetString(item))) {
			Tcl_ListObjIndex(interp, look, 1, &item);
			if (!strcmp("type", Tcl_GetString(item))) {
			    Tcl_ListObjIndex(interp, look, 2, &item);
			    if (globTypes->macType != NULL) {
				goto badMacTypesArg;
			    }
			    globTypes->macType = item;
			    Tcl_IncrRefCount(item);
			    continue;
			} else if (!strcmp("creator", Tcl_GetString(item))) {
			    Tcl_ListObjIndex(interp, look, 2, &item);
			    if (globTypes->macCreator != NULL) {
				goto badMacTypesArg;
			    }
			    globTypes->macCreator = item;
			    Tcl_IncrRefCount(item);
			    continue;
			}
		    }
		}
		/*
		 * Error cases.  We re-get the interpreter's result,
		 * just to be sure it hasn't changed, and we reset
		 * the 'join' flag to zero, since we haven't yet
		 * made use of it.
		 */
		badTypesArg:
		resultPtr = Tcl_GetObjResult(interp);
		Tcl_AppendToObj(resultPtr, "bad argument to \"-types\": ", -1);
		Tcl_AppendObjToObj(resultPtr, look);
		result = TCL_ERROR;
		join = 0;
		goto endOfGlob;
		badMacTypesArg:
		resultPtr = Tcl_GetObjResult(interp);
		Tcl_AppendToObj(resultPtr,
		   "only one MacOS type or creator argument"
		   " to \"-types\" allowed", -1);
		result = TCL_ERROR;
		join = 0;
		goto endOfGlob;
	    }
	}
    }

    /* 
     * Now we perform the actual glob below.  This may involve joining
     * together the pattern arguments, dealing with particular file types
     * etc.  We use a 'goto' to ensure we free any memory allocated along
     * the way.
     */
    objc -= i;
    objv += i;
    /* 
     * We re-retrieve this, in case it was changed in 
     * the Tcl_ResetResult above 
     */
    resultPtr = Tcl_GetObjResult(interp);
    result = TCL_OK;
    if (join) {
	if (dir != PATH_GENERAL) {
	    Tcl_DStringInit(&prefix);
	}
	for (i = 0; i < objc; i++) {
	    string = Tcl_GetStringFromObj(objv[i], &length);
	    Tcl_DStringAppend(&prefix, string, length);
	    if (i != objc -1) {
		Tcl_DStringAppend(&prefix, separators, 1);
	    }
	}
	if (TclGlob(interp, Tcl_DStringValue(&prefix), pathOrDir,
		globFlags, globTypes) != TCL_OK) {
	    result = TCL_ERROR;
	    goto endOfGlob;
	}
    } else {
	if (dir == PATH_GENERAL) {
	    Tcl_DString str;
	    for (i = 0; i < objc; i++) {
		Tcl_DStringInit(&str);
		if (dir == PATH_GENERAL) {
		    Tcl_DStringAppend(&str, Tcl_DStringValue(&prefix),
			    Tcl_DStringLength(&prefix));
		}
		string = Tcl_GetStringFromObj(objv[i], &length);
		Tcl_DStringAppend(&str, string, length);
		if (TclGlob(interp, Tcl_DStringValue(&str), pathOrDir,
			globFlags, globTypes) != TCL_OK) {
		    result = TCL_ERROR;
		    Tcl_DStringFree(&str);
		    goto endOfGlob;
		}
	    }
	    Tcl_DStringFree(&str);
	} else {
	    for (i = 0; i < objc; i++) {
		string = Tcl_GetString(objv[i]);
		if (TclGlob(interp, string, pathOrDir,
			globFlags, globTypes) != TCL_OK) {
		    result = TCL_ERROR;
		    goto endOfGlob;
		}
	    }
	}
    }
    if ((globFlags & TCL_GLOBMODE_NO_COMPLAIN) == 0) {
	if (Tcl_ListObjLength(interp, Tcl_GetObjResult(interp),
		&length) != TCL_OK) {
	    /* This should never happen.  Maybe we should be more dramatic */
	    result = TCL_ERROR;
	    goto endOfGlob;
	}
	if (length == 0) {
	    Tcl_AppendResult(interp, "no files matched glob pattern",
		    (join || (objc == 1)) ? " \"" : "s \"", (char *) NULL);
	    if (join) {
		Tcl_AppendResult(interp, Tcl_DStringValue(&prefix),
			(char *) NULL);
	    } else {
		char *sep = "";
		for (i = 0; i < objc; i++) {
		    string = Tcl_GetString(objv[i]);
		    Tcl_AppendResult(interp, sep, string, (char *) NULL);
		    sep = " ";
		}
	    }
	    Tcl_AppendResult(interp, "\"", (char *) NULL);
	    result = TCL_ERROR;
	}
    }
  endOfGlob:
    if (join || (dir == PATH_GENERAL)) {
	Tcl_DStringFree(&prefix);
    }
    if (pathOrDir != NULL) {
	Tcl_DecrRefCount(pathOrDir);
    }
    if (globTypes != NULL) {
	if (globTypes->macType != NULL) {
	    Tcl_DecrRefCount(globTypes->macType);
	}
	if (globTypes->macCreator != NULL) {
	    Tcl_DecrRefCount(globTypes->macCreator);
	}
	ckfree((char *) globTypes);
    }
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * TclGlob --
 *
 *	This procedure prepares arguments for the TclDoGlob call.
 *	It sets the separator string based on the platform, performs
 *      tilde substitution, and calls TclDoGlob.
 *      
 *      The interpreter's result, on entry to this function, must
 *      be a valid Tcl list (e.g. it could be empty), since we will
 *      lappend any new results to that list.  If it is not a valid
 *      list, this function will fail to do anything very meaningful.
 *
 * Results:
 *	The return value is a standard Tcl result indicating whether
 *	an error occurred in globbing.  After a normal return the
 *	result in interp (set by TclDoGlob) holds all of the file names
 *	given by the pattern and unquotedPrefix arguments.  After an 
 *	error the result in interp will hold an error message, unless
 *	the 'TCL_GLOBMODE_NO_COMPLAIN' flag was given, in which case
 *	an error results in a TCL_OK return leaving the interpreter's
 *	result unmodified.
 *
 * Side effects:
 *	The 'pattern' is written to.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
int
TclGlob(interp, pattern, unquotedPrefix, globFlags, types)
    Tcl_Interp *interp;		/* Interpreter for returning error message
				 * or appending list of matching file names. */
    char *pattern;		/* Glob pattern to match. Must not refer
				 * to a static string. */
    Tcl_Obj *unquotedPrefix;	/* Prefix to glob pattern, if non-null, which
                             	 * is considered literally. */
    int globFlags;		/* Stores or'ed combination of flags */
    Tcl_GlobTypeData *types;	/* Struct containing acceptable types.
				 * May be NULL. */
{
    char *separators;
    CONST char *head;
    char *tail, *start;
    char c;
    int result, prefixLen;
    Tcl_DString buffer;
    Tcl_Obj *oldResult;

    separators = NULL;		/* lint. */
    switch (tclPlatform) {
	case TCL_PLATFORM_UNIX:
	    separators = "/";
	    break;
	case TCL_PLATFORM_WINDOWS:
	    separators = "/\\:";
	    break;
	case TCL_PLATFORM_MAC:
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
	    if (unquotedPrefix == NULL) {
		separators = (strchr(pattern, ':') == NULL) ? "/" : ":";
	    } else {
		separators = ":";
	    }
#else
	    separators = ":";
#endif
	    break;
    }

    Tcl_DStringInit(&buffer);
    if (unquotedPrefix != NULL) {
	start = Tcl_GetString(unquotedPrefix);
    } else {
	start = pattern;
    }

    /*
     * Perform tilde substitution, if needed.
     */

    if (start[0] == '~') {
	
	/*
	 * Find the first path separator after the tilde.
	 */
	for (tail = start; *tail != '\0'; tail++) {
	    if (*tail == '\\') {
		if (strchr(separators, tail[1]) != NULL) {
		    break;
		}
	    } else if (strchr(separators, *tail) != NULL) {
		break;
	    }
	}

	/*
	 * Determine the home directory for the specified user.  
	 */
	
	c = *tail;
	*tail = '\0';
	if (globFlags & TCL_GLOBMODE_NO_COMPLAIN) {
	    /* 
	     * We will ignore any error message here, and we
	     * don't want to mess up the interpreter's result.
	     */
	    head = DoTildeSubst(NULL, start+1, &buffer);
	} else {
	    head = DoTildeSubst(interp, start+1, &buffer);
	}
	*tail = c;
	if (head == NULL) {
	    if (globFlags & TCL_GLOBMODE_NO_COMPLAIN) {
		return TCL_OK;
	    } else {
		return TCL_ERROR;
	    }
	}
	if (head != Tcl_DStringValue(&buffer)) {
	    Tcl_DStringAppend(&buffer, head, -1);
	}
	if (unquotedPrefix != NULL) {
	    Tcl_DStringAppend(&buffer, tail, -1);
	    tail = pattern;
	}
    } else {
	tail = pattern;
	if (unquotedPrefix != NULL) {
	    Tcl_DStringAppend(&buffer,Tcl_GetString(unquotedPrefix),-1);
	}
    }
    
    /* 
     * We want to remember the length of the current prefix,
     * in case we are using TCL_GLOBMODE_TAILS.  Also if we
     * are using TCL_GLOBMODE_DIR, we must make sure the
     * prefix ends in a directory separator.
     */
    prefixLen = Tcl_DStringLength(&buffer);

    if (prefixLen > 0) {
	c = Tcl_DStringValue(&buffer)[prefixLen-1];
	if (strchr(separators, c) == NULL) {
	    /* 
	     * If the prefix is a directory, make sure it ends in a
	     * directory separator.
	     */
	    if (globFlags & TCL_GLOBMODE_DIR) {
		Tcl_DStringAppend(&buffer,separators,1);
	    }
	    prefixLen++;
	}
    }

    /* 
     * We need to get the old result, in case it is over-written
     * below when we still need it.
     */
    oldResult = Tcl_GetObjResult(interp);
    Tcl_IncrRefCount(oldResult);
    Tcl_ResetResult(interp);
    
    result = TclDoGlob(interp, separators, &buffer, tail, types);
    
    if (result != TCL_OK) {
	if (globFlags & TCL_GLOBMODE_NO_COMPLAIN) {
	    /* Put back the old result and reset the return code */
	    Tcl_SetObjResult(interp, oldResult);
	    result = TCL_OK;
	}
    } else {
	/* 
	 * Now we must concatenate the 'oldResult' and the current
	 * result, and then place that into the interpreter.
	 * 
	 * If we only want the tails, we must strip off the prefix now.
	 * It may seem more efficient to pass the tails flag down into
	 * TclDoGlob, Tcl_FSMatchInDirectory, but those functions are
	 * continually adjusting the prefix as the various pieces of
	 * the pattern are assimilated, so that would add a lot of
	 * complexity to the code.  This way is a little slower (when
	 * the -tails flag is given), but much simpler to code.
	 */
	int objc, i;
	Tcl_Obj **objv;

	/* Ensure sole ownership */
	if (Tcl_IsShared(oldResult)) {
	    Tcl_DecrRefCount(oldResult);
	    oldResult = Tcl_DuplicateObj(oldResult);
	    Tcl_IncrRefCount(oldResult);
	}

	Tcl_ListObjGetElements(NULL, Tcl_GetObjResult(interp), 
			       &objc, &objv);
#ifdef MAC_TCL
	/* adjust prefixLen if TclDoGlob prepended a ':' */
	if ((prefixLen > 0) && (objc > 0)
	&& (Tcl_DStringValue(&buffer)[0] != ':')) {
	    char *str = Tcl_GetStringFromObj(objv[0],NULL);
	    if (str[0] == ':') {
		    prefixLen++;
	    }
	}
#endif
	for (i = 0; i< objc; i++) {
	    Tcl_Obj* elt;
	    if (globFlags & TCL_GLOBMODE_TAILS) {
		int len;
		char *oldStr = Tcl_GetStringFromObj(objv[i],&len);
		if (len == prefixLen) {
		    if ((pattern[0] == '\0')
			|| (strchr(separators, pattern[0]) == NULL)) {
			elt = Tcl_NewStringObj(".",1);
		    } else {
			elt = Tcl_NewStringObj("/",1);
		    }
		} else {
		    elt = Tcl_NewStringObj(oldStr + prefixLen, 
						len - prefixLen);
		}
	    } else {
		elt = objv[i];
	    }
	    /* Assumption that 'oldResult' is a valid list */
	    Tcl_ListObjAppendElement(interp, oldResult, elt);
	}
	Tcl_SetObjResult(interp, oldResult);
    }
    /* 
     * Release our temporary copy.  All code paths above must
     * end here so we free our reference.
     */
    Tcl_DecrRefCount(oldResult);
    Tcl_DStringFree(&buffer);
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * SkipToChar --
 *
 *	This function traverses a glob pattern looking for the next
 *	unquoted occurance of the specified character at the same braces
 *	nesting level.
 *
 * Results:
 *	Updates stringPtr to point to the matching character, or to
 *	the end of the string if nothing matched.  The return value
 *	is 1 if a match was found at the top level, otherwise it is 0.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static int
SkipToChar(stringPtr, match)
    char **stringPtr;			/* Pointer string to check. */
    char *match;			/* Pointer to character to find. */
{
    int quoted, level;
    register char *p;

    quoted = 0;
    level = 0;

    for (p = *stringPtr; *p != '\0'; p++) {
	if (quoted) {
	    quoted = 0;
	    continue;
	}
	if ((level == 0) && (*p == *match)) {
	    *stringPtr = p;
	    return 1;
	}
	if (*p == '{') {
	    level++;
	} else if (*p == '}') {
	    level--;
	} else if (*p == '\\') {
	    quoted = 1;
	}
    }
    *stringPtr = p;
    return 0;
}

/*
 *----------------------------------------------------------------------
 *
 * TclDoGlob --
 *
 *	This recursive procedure forms the heart of the globbing
 *	code.  It performs a depth-first traversal of the tree
 *	given by the path name to be globbed.  The directory and
 *	remainder are assumed to be native format paths.  The prefix 
 *	contained in 'headPtr' is not used as a glob pattern, simply
 *	as a path specifier, so it can contain unquoted glob-sensitive
 *	characters (if the directories to which it points contain
 *	such strange characters).
 *
 * Results:
 *	The return value is a standard Tcl result indicating whether
 *	an error occurred in globbing.  After a normal return the
 *	result in interp will be set to hold all of the file names
 *	given by the dir and rem arguments.  After an error the
 *	result in interp will hold an error message.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
TclDoGlob(interp, separators, headPtr, tail, types)
    Tcl_Interp *interp;		/* Interpreter to use for error reporting
				 * (e.g. unmatched brace). */
    char *separators;		/* String containing separator characters
				 * that should be used to identify globbing
				 * boundaries. */
    Tcl_DString *headPtr;	/* Completely expanded prefix. */
    char *tail;			/* The unexpanded remainder of the path.
				 * Must not be a pointer to a static string. */
    Tcl_GlobTypeData *types;	/* List object containing list of acceptable 
                            	 * types. May be NULL. */
{
    int baseLength, quoted, count;
    int result = TCL_OK;
    char *name, *p, *openBrace, *closeBrace, *firstSpecialChar, savedChar;
    char lastChar = 0;
    
    int length = Tcl_DStringLength(headPtr);

    if (length > 0) {
	lastChar = Tcl_DStringValue(headPtr)[length-1];
    }

    /*
     * Consume any leading directory separators, leaving tail pointing
     * just past the last initial separator.
     */

    count = 0;
    name = tail;
    for (; *tail != '\0'; tail++) {
	if ((*tail == '\\') && (strchr(separators, tail[1]) != NULL)) {
	    tail++;
	} else if (strchr(separators, *tail) == NULL) {
	    break;
	}
	count++;
    }

    /*
     * Deal with path separators.  On the Mac, we have to watch out
     * for multiple separators, since they are special in Mac-style
     * paths.
     */

    switch (tclPlatform) {
	case TCL_PLATFORM_MAC:
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
	    if (*separators == '/') {
		if (((length == 0) && (count == 0))
			|| ((length > 0) && (lastChar != ':'))) {
		    Tcl_DStringAppend(headPtr, ":", 1);
		}
	    } else {
#endif
		if (count == 0) {
		    if ((length > 0) && (lastChar != ':')) {
			Tcl_DStringAppend(headPtr, ":", 1);
		    }
		} else {
		    if (lastChar == ':') {
			count--;
		    }
		    while (count-- > 0) {
			Tcl_DStringAppend(headPtr, ":", 1);
		    }
		}
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
	    }
#endif
	    break;
	case TCL_PLATFORM_WINDOWS:
	    /*
	     * If this is a drive relative path, add the colon and the
	     * trailing slash if needed.  Otherwise add the slash if
	     * this is the first absolute element, or a later relative
	     * element.  Add an extra slash if this is a UNC path.
	     */

	    if (*name == ':') {
		Tcl_DStringAppend(headPtr, ":", 1);
		if (count > 1) {
		    Tcl_DStringAppend(headPtr, "/", 1);
		}
	    } else if ((*tail != '\0')
		    && (((length > 0)
			    && (strchr(separators, lastChar) == NULL))
			    || ((length == 0) && (count > 0)))) {
		Tcl_DStringAppend(headPtr, "/", 1);
		if ((length == 0) && (count > 1)) {
		    Tcl_DStringAppend(headPtr, "/", 1);
		}
	    }
	    
	    break;
	case TCL_PLATFORM_UNIX:
	    /*
	     * Add a separator if this is the first absolute element, or
	     * a later relative element.
	     */

	    if ((*tail != '\0')
		    && (((length > 0)
			    && (strchr(separators, lastChar) == NULL))
			    || ((length == 0) && (count > 0)))) {
		Tcl_DStringAppend(headPtr, "/", 1);
	    }
	    break;
    }

    /*
     * Look for the first matching pair of braces or the first
     * directory separator that is not inside a pair of braces.
     */

    openBrace = closeBrace = NULL;
    quoted = 0;
    for (p = tail; *p != '\0'; p++) {
	if (quoted) {
	    quoted = 0;
	} else if (*p == '\\') {
	    quoted = 1;
	    if (strchr(separators, p[1]) != NULL) {
		break;			/* Quoted directory separator. */
	    }
	} else if (strchr(separators, *p) != NULL) {
	    break;			/* Unquoted directory separator. */
	} else if (*p == '{') {
	    openBrace = p;
	    p++;
	    if (SkipToChar(&p, "}")) {
		closeBrace = p;		/* Balanced braces. */
		break;
	    }
	    Tcl_SetResult(interp, "unmatched open-brace in file name",
		    TCL_STATIC);
	    return TCL_ERROR;
	} else if (*p == '}') {
	    Tcl_SetResult(interp, "unmatched close-brace in file name",
		    TCL_STATIC);
	    return TCL_ERROR;
	}
    }

    /*
     * Substitute the alternate patterns from the braces and recurse.
     */

    if (openBrace != NULL) {
	char *element;
	Tcl_DString newName;
	Tcl_DStringInit(&newName);

	/*
	 * For each element within in the outermost pair of braces,
	 * append the element and the remainder to the fixed portion
	 * before the first brace and recursively call TclDoGlob.
	 */

	Tcl_DStringAppend(&newName, tail, openBrace-tail);
	baseLength = Tcl_DStringLength(&newName);
	length = Tcl_DStringLength(headPtr);
	*closeBrace = '\0';
	for (p = openBrace; p != closeBrace; ) {
	    p++;
	    element = p;
	    SkipToChar(&p, ",");
	    Tcl_DStringSetLength(headPtr, length);
	    Tcl_DStringSetLength(&newName, baseLength);
	    Tcl_DStringAppend(&newName, element, p-element);
	    Tcl_DStringAppend(&newName, closeBrace+1, -1);
	    result = TclDoGlob(interp, separators, headPtr, 
			       Tcl_DStringValue(&newName), types);
	    if (result != TCL_OK) {
		break;
	    }
	}
	*closeBrace = '}';
	Tcl_DStringFree(&newName);
	return result;
    }

    /*
     * At this point, there are no more brace substitutions to perform on
     * this path component.  The variable p is pointing at a quoted or
     * unquoted directory separator or the end of the string.  So we need
     * to check for special globbing characters in the current pattern.
     * We avoid modifying tail if p is pointing at the end of the string.
     */

    if (*p != '\0') {

	/*
	 * Note that we are modifying the string in place.  This won't work
	 * if the string is a static.
	 */

	savedChar = *p;
	*p = '\0';
	firstSpecialChar = strpbrk(tail, "*[]?\\");
	*p = savedChar;
    } else {
	firstSpecialChar = strpbrk(tail, "*[]?\\");
    }

    if (firstSpecialChar != NULL) {
	int ret;
	Tcl_Obj *head = Tcl_NewStringObj(Tcl_DStringValue(headPtr),-1);
	Tcl_IncrRefCount(head);
	/*
	 * Look for matching files in the given directory.  The
	 * implementation of this function is platform specific.  For
	 * each file that matches, it will add the match onto the
	 * resultPtr given.
	 */
	if (*p == '\0') {
	    ret = Tcl_FSMatchInDirectory(interp, Tcl_GetObjResult(interp), 
					 head, tail, types);
	} else {
	    Tcl_Obj* resultPtr;

	    /* 
	     * We do the recursion ourselves.  This makes implementing
	     * Tcl_FSMatchInDirectory for each filesystem much easier.
	     */
	    Tcl_GlobTypeData dirOnly = { TCL_GLOB_TYPE_DIR, 0, NULL, NULL };
	    char save = *p;
	    
	    *p = '\0';
	    resultPtr = Tcl_NewListObj(0, NULL);
	    ret = Tcl_FSMatchInDirectory(interp, resultPtr, 
					 head, tail, &dirOnly);
	    *p = save;
	    if (ret == TCL_OK) {
		int resLength;
		ret = Tcl_ListObjLength(interp, resultPtr, &resLength);
		if (ret == TCL_OK) {
		    int i;
		    for (i =0; i< resLength; i++) {
			Tcl_Obj *elt;
			Tcl_DString ds;
			Tcl_ListObjIndex(interp, resultPtr, i, &elt);
			Tcl_DStringInit(&ds);
			Tcl_DStringAppend(&ds, Tcl_GetString(elt), -1);
			if(tclPlatform == TCL_PLATFORM_MAC) {
			    Tcl_DStringAppend(&ds, ":",1);
			} else {			
			    Tcl_DStringAppend(&ds, "/",1);
			}
			ret = TclDoGlob(interp, separators, &ds, p+1, types);
			Tcl_DStringFree(&ds);
			if (ret != TCL_OK) {
			    break;
			}
		    }
		}
	    }
	    Tcl_DecrRefCount(resultPtr);
	}
	Tcl_DecrRefCount(head);
	return ret;
    }
    Tcl_DStringAppend(headPtr, tail, p-tail);
    if (*p != '\0') {
	return TclDoGlob(interp, separators, headPtr, p, types);
    } else {
	/*
	 * This is the code path reached by a command like 'glob foo'.
	 *
	 * There are no more wildcards in the pattern and no more
	 * unprocessed characters in the tail, so now we can construct
	 * the path, and pass it to Tcl_FSMatchInDirectory with an
	 * empty pattern to verify the existence of the file and check
	 * it is of the correct type (if a 'types' flag it given -- if
	 * no such flag was given, we could just use 'Tcl_FSLStat', but
	 * for simplicity we keep to a common approach).
	 */

	Tcl_Obj *nameObj;
	/* Used to deal with one special case pertinent to MacOS */
	int macSpecialCase = 0;

	switch (tclPlatform) {
	    case TCL_PLATFORM_MAC: {
		if (strchr(Tcl_DStringValue(headPtr), ':') == NULL) {
		    Tcl_DStringAppend(headPtr, ":", 1);
		}
		macSpecialCase = 1;
		break;
	    }
	    case TCL_PLATFORM_WINDOWS: {
		if (Tcl_DStringLength(headPtr) == 0) {
		    if (((*name == '\\') && (name[1] == '/' || name[1] == '\\'))
			    || (*name == '/')) {
			Tcl_DStringAppend(headPtr, "/", 1);
		    } else {
			Tcl_DStringAppend(headPtr, ".", 1);
		    }
		}
#if defined(__CYGWIN__) && defined(__WIN32__)
		{

		extern int cygwin_conv_to_win32_path 
		    _ANSI_ARGS_((CONST char *, char *));
		char winbuf[MAX_PATH+1];

		cygwin_conv_to_win32_path(Tcl_DStringValue(headPtr), winbuf);
		Tcl_DStringFree(headPtr);
		Tcl_DStringAppend(headPtr, winbuf, -1);

		}
#endif /* __CYGWIN__ && __WIN32__ */
		/* 
		 * Convert to forward slashes.  This is required to pass
		 * some Tcl tests.  We should probably remove the conversions
		 * here and in tclWinFile.c, since they aren't needed since
		 * the dropping of support for Win32s.
		 */
		for (p = Tcl_DStringValue(headPtr); *p != '\0'; p++) {
		    if (*p == '\\') {
			*p = '/';
		    }
		}
		break;
	    }
	    case TCL_PLATFORM_UNIX: {
		if (Tcl_DStringLength(headPtr) == 0) {
		    if ((*name == '\\' && name[1] == '/') || (*name == '/')) {
			Tcl_DStringAppend(headPtr, "/", 1);
		    } else {
			Tcl_DStringAppend(headPtr, ".", 1);
		    }
		}
		break;
	    }
	}
	/* Common for all platforms */
	name = Tcl_DStringValue(headPtr);
	nameObj = Tcl_NewStringObj(name, Tcl_DStringLength(headPtr));

	Tcl_IncrRefCount(nameObj);
	Tcl_FSMatchInDirectory(interp, Tcl_GetObjResult(interp), nameObj, 
			       NULL, types);
	Tcl_DecrRefCount(nameObj);
	return TCL_OK;
    }
}


/*
 *---------------------------------------------------------------------------
 *
 * TclFileDirname
 *
 *	This procedure calculates the directory above a given 
 *	path: basically 'file dirname'.  It is used both by
 *	the 'dirname' subcommand of file and by code in tclIOUtil.c.
 *
 * Results:
 *	NULL if an error occurred, otherwise a Tcl_Obj owned by
 *	the caller (i.e. most likely with refCount 1).
 *
 * Side effects:
 *      None.
 *
 *---------------------------------------------------------------------------
 */

Tcl_Obj*
TclFileDirname(interp, pathPtr)
    Tcl_Interp *interp;		/* Used for error reporting */
    Tcl_Obj *pathPtr;           /* Path to take dirname of */
{
    int splitElements;
    Tcl_Obj *splitPtr;
    Tcl_Obj *splitResultPtr = NULL;

    /* 
     * The behaviour we want here is slightly different to
     * the standard Tcl_FSSplitPath in the handling of home
     * directories; Tcl_FSSplitPath preserves the "~" while 
     * this code computes the actual full path name, if we
     * had just a single component.
     */	    
    splitPtr = Tcl_FSSplitPath(pathPtr, &splitElements);
    if ((splitElements == 1) && (Tcl_GetString(pathPtr)[0] == '~')) {
	Tcl_DecrRefCount(splitPtr);
	splitPtr = Tcl_FSGetNormalizedPath(interp, pathPtr);
	if (splitPtr == NULL) {
	    return NULL;
	}
	splitPtr = Tcl_FSSplitPath(splitPtr, &splitElements);
    }

    /*
     * Return all but the last component.  If there is only one
     * component, return it if the path was non-relative, otherwise
     * return the current directory.
     */

    if (splitElements > 1) {
	splitResultPtr = Tcl_FSJoinPath(splitPtr, splitElements - 1);
    } else if (splitElements == 0 || 
      (Tcl_FSGetPathType(pathPtr) == TCL_PATH_RELATIVE)) {
	splitResultPtr = Tcl_NewStringObj(
		((tclPlatform == TCL_PLATFORM_MAC) ? ":" : "."), 1);
    } else {
	Tcl_ListObjIndex(NULL, splitPtr, 0, &splitResultPtr);
    }
    Tcl_IncrRefCount(splitResultPtr);
    Tcl_DecrRefCount(splitPtr);
    return splitResultPtr;
}

/*
 *---------------------------------------------------------------------------
 *
 * Tcl_AllocStatBuf
 *
 *     This procedure allocates a Tcl_StatBuf on the heap.  It exists
 *     so that extensions may be used unchanged on systems where
 *     largefile support is optional.
 *
 * Results:
 *     A pointer to a Tcl_StatBuf which may be deallocated by being
 *     passed to ckfree().
 *
 * Side effects:
 *      None.
 *
 *---------------------------------------------------------------------------
 */

Tcl_StatBuf *
Tcl_AllocStatBuf() {
    return (Tcl_StatBuf *) ckalloc(sizeof(Tcl_StatBuf));
}
@


1.9
log
@Updated to tcl 8.4.1
@
text
@a1358 18
#if defined(__CYGWIN__) && defined(__WIN32__)

	extern int cygwin_conv_to_win32_path 
	    _ANSI_ARGS_((CONST char *, char *));
	char winbuf[MAX_PATH];

	/*
	 * In the Cygwin world, call conv_to_win32_path in order to use the
	 * mount table to translate the file name into something Windows will
	 * understand.  Take care when converting empty strings!
	 */
	if (Tcl_DStringLength(bufferPtr)) {
	    cygwin_conv_to_win32_path(Tcl_DStringValue(bufferPtr), winbuf);
	    Tcl_DStringFree(bufferPtr);
	    Tcl_DStringAppend(bufferPtr, winbuf, -1);
	}
#else /* __CYGWIN__ && __WIN32__ */

a1364 1
#endif /* __CYGWIN__ && __WIN32__ */
a2319 19
#if defined(__CYGWIN__) && defined(__WIN32__)
	    {

	    extern int cygwin_conv_to_win32_path 
	    	_ANSI_ARGS_((CONST char *, char *));
	    char winbuf[MAX_PATH];

	    /*
	     * In the Cygwin world, call conv_to_win32_path in order to use
	     * the mount table to translate the file name into something
	     * Windows will understand.
	     */
	    cygwin_conv_to_win32_path(Tcl_DStringValue(headPtr), winbuf);
	    Tcl_DStringFree(headPtr);
	    Tcl_DStringAppend(headPtr, winbuf, -1);

	    }
#endif /* __CYGWIN__ && __WIN32__ */

d2535 1
a2535 1
			Tcl_DStringAppend(headPtr, "\\", 1);
d2540 13
@


1.8
log
@touched all sources to ease next import
@
text
@d13 1
a13 1
 * RCS: @@(#) $Id: tclFileName.c,v 1.6.8.2 2000/09/15 16:55:12 spolk Exp $
d20 4
a23 4
/*
 * The following regular expression matches the root portion of a Windows
 * absolute or volume relative path.  It will match both UNC and drive relative
 * paths.
d25 1
d27 1
a27 2
#define WIN_ROOT_PATTERN "^(([a-zA-Z]:)|[/\\\\][/\\\\]+([^/\\\\]+)[/\\\\]+([^/\\\\]+)|([/\\\\]))([/\\\\])*"

d31 10
a40 1
 * Unix-style paths, and Mac paths.
d57 5
a69 9
 * The "globParameters" argument of the globbing functions is an 
 * or'ed combination of the following values:
 */

#define GLOBMODE_NO_COMPLAIN      1
#define GLOBMODE_JOIN             2
#define GLOBMODE_DIR              4

/*
d73 1
a73 1
static char *		DoTildeSubst _ANSI_ARGS_((Tcl_Interp *interp,
d76 2
a77 3
			    Tcl_DString *resultPtr, int offset, Tcl_PathType *typePtr));
static void		FileNameCleanup _ANSI_ARGS_((ClientData clientData));
static void		FileNameInit _ANSI_ARGS_((void));
d80 4
a83 6
static char *		SplitMacPath _ANSI_ARGS_((CONST char *path,
			    Tcl_DString *bufPtr));
static char *		SplitWinPath _ANSI_ARGS_((CONST char *path,
			    Tcl_DString *bufPtr));
static char *		SplitUnixPath _ANSI_ARGS_((CONST char *path,
			    Tcl_DString *bufPtr));
d137 1
a166 3
    FileNameInit();


d169 1
a169 1
	char *host, *share, *tail;
d176 2
a177 2
    }
	host = (char *)&path[2];
d179 1
a179 1
	/* Skip seperators */
d187 12
d206 1
a206 1
	/* Skip seperators */
d220 1
a220 1
	/* Skip seperators */
d225 1
a225 1
    } else if (path[1] == ':') {
d233 1
a233 1
    } else {
d236 2
a237 2
	    /* Skip seperators */
	    while (tail[0] == '/' || tail[0] == '\\') tail++;
d241 1
a241 1
	Tcl_DStringAppend(resultPtr, "/", 1);
d243 1
a243 1
    return tail;
d258 4
d275 37
a311 1
    char *path;
a312 1
    ThreadSpecificData *tsdPtr;
d314 12
a325 10
    Tcl_RegExp re;

    switch (tclPlatform) {
   	case TCL_PLATFORM_UNIX:
	    /*
	     * Paths that begin with / or ~ are absolute.
	     */

	    if ((path[0] != '/') && (path[0] != '~')) {
		type = TCL_PATH_RELATIVE;
d327 10
a336 7
	    break;

	case TCL_PLATFORM_MAC:
	    if (path[0] == ':') {
		type = TCL_PATH_RELATIVE;
	    } else if (path[0] != '~') {
		tsdPtr = TCL_TSD_INIT(&dataKey);
d338 1
d340 1
a340 2
		 * Since we have eliminated the easy cases, use the
		 * root pattern to look for the other types.
d342 28
d371 1
a371 3
		FileNameInit();
		re = Tcl_GetRegExpFromObj(NULL, tsdPtr->macRootPatternPtr,
			REG_ADVANCED);
d373 8
a380 4
		if (!Tcl_RegExpExec(NULL, re, path, path)) {
		    type = TCL_PATH_RELATIVE;
		} else {
		    char *unixRoot, *dummy;
d382 1
a382 2
		    Tcl_RegExpRange(re, 2, &unixRoot, &dummy);
		    if (unixRoot) {
d384 56
d441 1
d443 3
a445 5
	    }
	    break;
	
	case TCL_PLATFORM_WINDOWS:
	    if (path[0] != '~') {
d447 2
a448 1

d450 9
a458 1
		(VOID)ExtractWinRoot(path, &ds, 0, &type);
d460 1
d462 43
d506 16
d523 1
a523 1
    return type;
d557 1
a557 1
    char ***argvPtr;		/* Pointer to place to store pointer to array
d560 4
a563 5
    int i, size;
    char *p;
    Tcl_DString buffer;

    Tcl_DStringInit(&buffer);
d566 1
a566 3
     * Perform platform specific splitting.  These routines will leave the
     * result in the specified buffer.  Individual elements are terminated
     * with a null character.
d569 4
a572 5
    p = NULL;			/* Needed only to prevent gcc warnings. */
    switch (tclPlatform) {
   	case TCL_PLATFORM_UNIX:
	    p = SplitUnixPath(path, &buffer);
	    break;
d574 7
a580 19
	case TCL_PLATFORM_WINDOWS:
	    p = SplitWinPath(path, &buffer);
	    break;
	    
	case TCL_PLATFORM_MAC:
	    p = SplitMacPath(path, &buffer);
	    break;
    }

    /*
     * Compute the number of elements in the result.
     */

    size = Tcl_DStringLength(&buffer);
    *argcPtr = 0;
    for (i = 0; i < size; i++) {
	if (p[i] == '\0') {
	    (*argcPtr)++;
	}
d584 2
a585 2
     * Allocate a buffer large enough to hold the contents of the
     * DString plus the argv pointers and the terminating NULL pointer.
d588 1
a588 1
    *argvPtr = (char **) ckalloc((unsigned)
d593 1
a593 1
     * the DString.
d597 7
a603 2
    memcpy((VOID *) p, (VOID *) Tcl_DStringValue(&buffer), (size_t) size);

d608 2
d616 5
a620 1
    Tcl_DStringFree(&buffer);
d628 1
a628 1
 *	This routine is used by Tcl_SplitPath to handle splitting
d632 1
a632 2
 *	Stores a null separated array of strings in the specified
 *	Tcl_DString.
d640 2
a641 2
static char *
SplitUnixPath(path, bufPtr)
a642 1
    Tcl_DString *bufPtr;	/* Pointer to DString to use for the result. */
d646 1
d666 1
a666 1
	Tcl_DStringAppend(bufPtr, "/", 2);
d684 1
d686 4
a689 1
		Tcl_DStringAppend(bufPtr, "./", 2);
d691 1
a691 2
	    Tcl_DStringAppend(bufPtr, elementStart, length);
	    Tcl_DStringAppend(bufPtr, "", 1);
d697 1
a697 1
    return Tcl_DStringValue(bufPtr);
d699 1
d706 1
a706 1
 *	This routine is used by Tcl_SplitPath to handle splitting
d710 1
a710 2
 *	Stores a null separated array of strings in the specified
 *	Tcl_DString.
d718 2
a719 2
static char *
SplitWinPath(path, bufPtr)
a720 1
    Tcl_DString *bufPtr;	/* Pointer to DString to use for the result. */
d725 5
a729 2

    p = ExtractWinRoot(path, bufPtr, 0, &type);
d736 3
a738 1
	Tcl_DStringAppend(bufPtr, "", 1);
d740 2
a741 1

d754 1
d756 4
a759 1
		Tcl_DStringAppend(bufPtr, "./", 2);
d761 1
a761 2
	    Tcl_DStringAppend(bufPtr, elementStart, length);
	    Tcl_DStringAppend(bufPtr, "", 1);
d765 1
a765 1
    return Tcl_DStringValue(bufPtr);
d773 1
a773 1
 *	This routine is used by Tcl_SplitPath to handle splitting
d777 1
a777 1
 *	Returns a newly allocated argv array.
d785 2
a786 2
static char *
SplitMacPath(path, bufPtr)
a787 1
    Tcl_DString *bufPtr;	/* Pointer to DString to use for the result. */
d790 1
a790 1
    int i, length;
d792 2
d795 1
d797 5
a801 1

d817 2
a818 1
	char *start, *end;
d827 1
a827 1
	    Tcl_DStringAppend(bufPtr, ":", 1);
d829 3
a831 2
	    Tcl_DStringAppend(bufPtr, path, end - start + 1);
	    return Tcl_DStringValue(bufPtr);
a853 1

a862 1

a872 1

d877 1
a877 2
	 * Append the element and terminate it with a : and a null.  Note that
	 * we are forcing the DString to contain an extra null at the end.
d880 3
a882 2
	Tcl_DStringAppend(bufPtr, start, length);
	Tcl_DStringAppend(bufPtr, ":", 2);
d888 28
d922 3
d926 5
a930 2

	elementStart = p++;
d935 2
a936 1
		    Tcl_DStringAppend(bufPtr, "::", 3);
d949 2
a950 2
		Tcl_DStringAppend(bufPtr, elementStart, length);
		Tcl_DStringAppend(bufPtr, "", 1);
d954 8
a961 2
	if (elementStart[1] != '\0' || elementStart == path) {
	    if ((elementStart[1] != '~') && (elementStart[1] != '\0')
d964 3
a967 2
	    Tcl_DStringAppend(bufPtr, elementStart, -1);
	    Tcl_DStringAppend(bufPtr, "", 1);
d983 2
a984 1
		    Tcl_DStringAppend(bufPtr, ":", 2);
d987 2
a988 1
		    Tcl_DStringAppend(bufPtr, "::", 3);
d990 1
d992 4
a995 1
			Tcl_DStringAppend(bufPtr, ":", 1);
d997 1
a997 2
		    Tcl_DStringAppend(bufPtr, elementStart, length);
		    Tcl_DStringAppend(bufPtr, "", 1);
d1005 42
a1046 1
    return Tcl_DStringValue(bufPtr);
d1050 1
a1050 1
 *----------------------------------------------------------------------
d1052 1
a1052 1
 * Tcl_JoinPath --
d1054 1
a1054 1
 *	Combine a list of paths in a platform specific manner.
d1057 1
a1057 3
 *	Appends the joined path to the end of the specified
 *	returning a pointer to the resulting string.  Note that
 *	the Tcl_DString must already be initialized.
d1060 1
a1060 1
 *	Modifies the Tcl_DString.
d1062 1
a1062 1
 *----------------------------------------------------------------------
d1065 4
a1068 5
char *
Tcl_JoinPath(argc, argv, resultPtr)
    int argc;
    char **argv;
    Tcl_DString *resultPtr;	/* Pointer to previously initialized DString. */
d1070 21
a1090 5
    int oldLength, length, i, needsSep;
    Tcl_DString buffer;
    char c, *dest;
    CONST char *p;
    Tcl_PathType type = TCL_PATH_ABSOLUTE;
a1091 2
    Tcl_DStringInit(&buffer);
    oldLength = Tcl_DStringLength(resultPtr);
d1094 15
a1108 9
   	case TCL_PLATFORM_UNIX:
	    for (i = 0; i < argc; i++) {
		p = argv[i];
		/*
		 * If the path is absolute, reset the result buffer.
		 * Consume any duplicate leading slashes or a ./ in
		 * front of a tilde prefixed path that isn't at the
		 * beginning of the path.
		 */
d1110 4
a1113 12
#ifdef __QNX__
		/*
		 * Check for QNX //<node id> prefix
		 */
		if (*p && (strlen(p) > 3) && (p[0] == '/') && (p[1] == '/')
			&& isdigit(UCHAR(p[2]))) { /* INTL: digit */
		    p += 3;
		    while (isdigit(UCHAR(*p))) { /* INTL: digit */
			++p;
		    }
		}
#endif
d1115 1
a1115 3
		    Tcl_DStringSetLength(resultPtr, oldLength);
		    Tcl_DStringAppend(resultPtr, "/", 1);
		    while (*p == '/') {
d1118 8
a1125 6
		} else if (*p == '~') {
		    Tcl_DStringSetLength(resultPtr, oldLength);
		} else if ((Tcl_DStringLength(resultPtr) != oldLength)
			&& (p[0] == '.') && (p[1] == '/')
			&& (p[2] == '~')) {
		    p += 2;
d1127 4
d1132 4
a1135 3
		if (*p == '\0') {
		    continue;
		}
d1137 11
a1147 3
		/*
		 * Append a separator if needed.
		 */
d1149 9
a1157 24
		length = Tcl_DStringLength(resultPtr);
		if ((length != oldLength)
			&& (Tcl_DStringValue(resultPtr)[length-1] != '/')) {
		    Tcl_DStringAppend(resultPtr, "/", 1);
		    length++;
		}

		/*
		 * Append the element, eliminating duplicate and trailing
		 * slashes.
		 */

		Tcl_DStringSetLength(resultPtr, (int) (length + strlen(p)));
		dest = Tcl_DStringValue(resultPtr) + length;
		for (; *p != '\0'; p++) {
		    if (*p == '/') {
			while (p[1] == '/') {
			    p++;
			}
			if (p[1] != '\0') {
			    *dest++ = '/';
			}
		    } else {
			*dest++ = *p;
d1159 3
a1162 2
		length = dest - Tcl_DStringValue(resultPtr);
		Tcl_DStringSetLength(resultPtr, length);
d1164 2
d1168 3
a1170 1
	case TCL_PLATFORM_WINDOWS:
d1172 6
a1177 3
	     * Iterate over all of the components.  If a component is
	     * absolute, then reset the result and start building the
	     * path from the current component on.
d1180 8
a1187 23
	    for (i = 0; i < argc; i++) {
		p = ExtractWinRoot(argv[i], resultPtr, oldLength, &type);
		length = Tcl_DStringLength(resultPtr);
		
		/*
		 * If the pointer didn't move, then this is a relative path
		 * or a tilde prefixed path.
		 */

		if (p == argv[i]) {
		    /*
		     * Remove the ./ from tilde prefixed elements unless
		     * it is the first component.
		     */

		    if ((length != oldLength)
			    && (p[0] == '.')
			    && ((p[1] == '/') || (p[1] == '\\'))
			    && (p[2] == '~')) {
			p += 2;
		    } else if (*p == '~') {
			Tcl_DStringSetLength(resultPtr, oldLength);
			length = oldLength;
d1189 7
d1197 4
a1200 12

		if (*p != '\0') {
		    /*
		     * Check to see if we need to append a separator.
		     */

		    
		    if (length != oldLength) {
			c = Tcl_DStringValue(resultPtr)[length-1];
			if ((c != '/') && (c != ':')) {
			    Tcl_DStringAppend(resultPtr, "/", 1);
			}
d1202 13
d1216 14
a1229 19
		    /*
		     * Append the element, eliminating duplicate and
		     * trailing slashes.
		     */

		    length = Tcl_DStringLength(resultPtr);
		    Tcl_DStringSetLength(resultPtr, (int) (length + strlen(p)));
		    dest = Tcl_DStringValue(resultPtr) + length;
		    for (; *p != '\0'; p++) {
			if ((*p == '/') || (*p == '\\')) {
			    while ((p[1] == '/') || (p[1] == '\\')) {
				p++;
			    }
			    if (p[1] != '\0') {
				*dest++ = '/';
			    }
			} else {
			    *dest++ = *p;
			}
a1230 2
		    length = dest - Tcl_DStringValue(resultPtr);
		    Tcl_DStringSetLength(resultPtr, length);
d1233 7
a1239 42
	    break;

	case TCL_PLATFORM_MAC:
	    needsSep = 1;
	    for (i = 0; i < argc; i++) {
		Tcl_DStringSetLength(&buffer, 0);
		p = SplitMacPath(argv[i], &buffer);
		if ((*p != ':') && (*p != '\0')
			&& (strchr(p, ':') != NULL)) {
		    Tcl_DStringSetLength(resultPtr, oldLength);
		    length = strlen(p);
		    Tcl_DStringAppend(resultPtr, p, length);
		    needsSep = 0;
		    p += length+1;
		}

		/*
		 * Now append the rest of the path elements, skipping
		 * : unless it is the first element of the path, and
		 * watching out for :: et al. so we don't end up with
		 * too many colons in the result.
		 */

		for (; *p != '\0'; p += length+1) {
		    if (p[0] == ':' && p[1] == '\0') {
			if (Tcl_DStringLength(resultPtr) != oldLength) {
			    p++;
			} else {
			    needsSep = 0;
			}
		    } else {
			c = p[1];
			if (*p == ':') {
			    if (!needsSep) {
				p++;
			    }
			} else {
			    if (needsSep) {
				Tcl_DStringAppend(resultPtr, ":", 1);
			    }
			}
			needsSep = (c == ':') ? 0 : 1;
d1241 1
a1241 2
		    length = strlen(p);
		    Tcl_DStringAppend(resultPtr, p, length);
d1244 1
d1246 1
a1246 1
			       
d1248 52
a1299 1
    Tcl_DStringFree(&buffer);
d1333 1
a1333 1
    char *name;			/* File name, which may begin with "~" (to
d1340 12
a1351 1
    register char *p;
d1354 2
a1355 1
     * Handle tilde substitutions, if needed.
d1358 6
a1363 4
    if (name[0] == '~') {
	int argc, length;
	char **argv;
	Tcl_DString temp;
a1364 2
	Tcl_SplitPath(name, &argc, (char ***) &argv);
	
d1366 3
a1368 2
	 * Strip the trailing ':' off of a Mac path before passing the user
	 * name to DoTildeSubst.
d1370 4
a1373 12

	if (tclPlatform == TCL_PLATFORM_MAC) {
	    length = strlen(argv[0]);
	    argv[0][length-1] = '\0';
	}
	
	Tcl_DStringInit(&temp);
	argv[0] = DoTildeSubst(interp, argv[0]+1, &temp);
	if (argv[0] == NULL) {
	    Tcl_DStringFree(&temp);
	    ckfree((char *)argv);
	    return NULL;
d1375 1
a1375 13
	Tcl_DStringInit(bufferPtr);
	Tcl_JoinPath(argc, (char **) argv, bufferPtr);
	Tcl_DStringFree(&temp);
	ckfree((char*)argv);
    } else {
	Tcl_DStringInit(bufferPtr);
	Tcl_JoinPath(1, (char **) &name, bufferPtr);
    }

    /*
     * Convert forward slashes to backslashes in Windows paths because
     * some system interfaces don't accept forward slashes.
     */
d1377 1
a1377 2
#ifndef __CYGWIN__
    if (tclPlatform == TCL_PLATFORM_WINDOWS) {
d1383 1
a1384 1
#endif
d1423 1
d1429 3
d1444 1
a1444 2
    if ((p != NULL) && (lastSep != NULL)
	    && (lastSep > p)) {
d1480 1
a1480 1
static char *
d1489 1
a1489 1
    char *dir;
d1515 1
a1515 1
    return resultPtr->string;
d1543 2
a1544 2
    int index, i, globFlags, pathlength, length, join, dir, result;
    char *string, *pathOrDir, *separators;
d1546 5
a1550 3
    Tcl_DString prefix, directory;
    static char *options[] = {
	"-directory", "-join", "-nocomplain", "-path", "-types", "--", NULL
d1553 2
a1554 1
	GLOB_DIR, GLOB_JOIN, GLOB_NOCOMPLAIN, GLOB_PATH, GLOB_TYPE, GLOB_LAST
d1557 1
a1557 1
    GlobTypeData *globTypes = NULL;
a1561 1
    pathOrDir = NULL;
d1585 1
a1585 1
	        globFlags |= GLOBMODE_NO_COMPLAIN;
d1593 1
a1593 1
		if (dir != -1) {
d1600 2
a1601 2
		globFlags |= GLOBMODE_DIR;
		pathOrDir = Tcl_GetStringFromObj(objv[i+1], &pathlength);
d1607 3
d1616 1
a1616 1
		if (dir != -1) {
d1623 1
a1623 1
		pathOrDir = Tcl_GetStringFromObj(objv[i+1], &pathlength);
d1649 7
a1655 1

d1669 1
d1671 1
d1676 2
a1677 2
	last = pathOrDir + pathlength;
	for (; last != pathOrDir; last--) {
d1682 1
a1682 1
	if (last == pathOrDir + pathlength) {
d1684 1
a1684 1
	    dir = 1;
d1689 1
a1689 2
	    Tcl_DStringInit(&directory);
	    if (last == pathOrDir) {
d1691 1
a1691 1
		Tcl_DStringAppend(&pref, pathOrDir, -1);
d1695 2
a1696 3
		Tcl_DStringAppend(&pref, last, pathOrDir+pathlength-last);
		Tcl_DStringAppend(&directory, pathOrDir, last-pathOrDir-1);
		pathOrDir = Tcl_DStringValue(&directory);
d1716 5
a1720 1

d1728 1
a1728 1
	globTypes = (GlobTypeData*) ckalloc(sizeof(GlobTypeData));
d1811 4
a1814 1
		 * Error cases
d1817 1
d1821 1
d1824 1
d1826 2
a1827 1
			"only one MacOS type or creator argument to \"-types\" allowed", -1);
d1829 1
d1895 1
a1895 1
    if ((globFlags & GLOBMODE_NO_COMPLAIN) == 0) {
d1923 3
a1925 3
	if (dir == PATH_GENERAL) {
	    Tcl_DStringFree(&directory);
	}
d1947 5
d1957 5
a1961 2
 *	given by the dir and rem arguments.  After an error the
 *	result in interp will hold an error message.
d1964 1
a1964 1
 *	The currentArgString is written to.
d1976 2
a1977 2
    char *unquotedPrefix;	/* Prefix to glob pattern, if non-null, which
                             	 * is considered literally.  May be static. */
d1979 1
a1979 1
    GlobTypeData *types;	/* Struct containing acceptable types.
d1983 2
a1984 1
    char *head, *tail, *start;
d1986 1
a1986 1
    int result;
d1988 1
d1999 1
d2005 3
d2013 1
a2013 1
	start = unquotedPrefix;
d2038 1
a2038 2
	 * Determine the home directory for the specified user.  Note that
	 * we don't allow special characters in the user name.
d2043 7
a2049 10
	/*
	 * I don't think we need to worry about special characters in
	 * the user name anymore (Vince Darley, June 1999), since the
	 * new code is designed to handle special chars.
	 */
#ifndef NOT_NEEDED_ANYMORE
	head = DoTildeSubst(interp, start+1, &buffer);
#else
	
	if (strpbrk(start+1, "\\[]*?{}") == NULL) {
a2050 7
	} else {
	    if (!(globFlags & GLOBMODE_NO_COMPLAIN)) {
		Tcl_ResetResult(interp);
		Tcl_AppendResult(interp, "globbing characters not ",
			"supported in user names", (char *) NULL);
	    }
	    head = NULL;
a2051 1
#endif
d2054 1
a2054 10
	    if (globFlags & GLOBMODE_NO_COMPLAIN) {
		/*
		 * We should in fact pass down the nocomplain flag 
		 * or save the interp result or use another mechanism
		 * so the interp result is not mangled on errors in that case.
		 * but that would a bigger change than reasonable for a patch
		 * release.
		 * (see fileName.test 15.2-15.4 for expected behaviour)
		 */
		Tcl_ResetResult(interp);
d2070 1
a2070 1
	    Tcl_DStringAppend(&buffer,unquotedPrefix,-1);
d2073 1
d2075 15
a2089 7
     * If the prefix is a directory, make sure it ends in a directory
     * separator.
     */
    if (unquotedPrefix != NULL) {
	if (globFlags & GLOBMODE_DIR) {
	    c = Tcl_DStringValue(&buffer)[Tcl_DStringLength(&buffer)-1];
	    if (strchr(separators, c) == NULL) {
d2092 1
d2096 8
d2105 1
a2105 1
    Tcl_DStringFree(&buffer);
d2107 61
a2167 3
	if (globFlags & GLOBMODE_NO_COMPLAIN) {
	    Tcl_ResetResult(interp);
	    return TCL_OK;
d2169 1
d2171 6
d2269 2
a2270 2
    GlobTypeData *types;	/* List object containing list of acceptable types.
				 * May be NULL. */
d2307 1
d2314 1
d2327 1
d2329 1
d2339 19
d2450 2
a2451 2
	    result = TclDoGlob(interp, separators,
		    headPtr, Tcl_DStringValue(&newName), types);
d2476 4
a2479 4
	 savedChar = *p;
	 *p = '\0';
	 firstSpecialChar = strpbrk(tail, "*[]?\\");
	 *p = savedChar;
d2485 3
d2489 4
a2492 5
	 * Look for matching files in the current directory.  The
	 * implementation of this function is platform specific, but may
	 * recursively call TclDoGlob.  For each file that matches, it will
	 * add the match onto the interp's result, or call TclDoGlob if there
	 * are more characters to be processed.
d2494 5
d2500 40
a2539 1
	return TclpMatchFilesTypes(interp, separators, headPtr, tail, p, types);
d2544 12
a2555 1
    }
d2557 8
a2564 19
    /*
     * There are no more wildcards in the pattern and no more unprocessed
     * characters in the tail, so now we can construct the path and verify
     * the existence of the file.
     */

    switch (tclPlatform) {
	case TCL_PLATFORM_MAC: {
	    if (strchr(Tcl_DStringValue(headPtr), ':') == NULL) {
		Tcl_DStringAppend(headPtr, ":", 1);
	    }
	    name = Tcl_DStringValue(headPtr);
	    if (TclpAccess(name, F_OK) == 0) {
		if ((name[1] != '\0') && (strchr(name+1, ':') == NULL)) {
		    Tcl_ListObjAppendElement(interp, Tcl_GetObjResult(interp), 
					     Tcl_NewStringObj(name + 1,-1));
		} else {
		    Tcl_ListObjAppendElement(interp, Tcl_GetObjResult(interp), 
					     Tcl_NewStringObj(name,-1));
d2566 2
d2569 8
a2576 18
	    break;
	}
	case TCL_PLATFORM_WINDOWS: {
	    int exists;
#ifndef __CYGWIN__

	    /*
	     * We need to convert slashes to backslashes before checking
	     * for the existence of the file.  Once we are done, we need
	     * to convert the slashes back.
	     */

	    if (Tcl_DStringLength(headPtr) == 0) {
		if (((*name == '\\') && (name[1] == '/' || name[1] == '\\'))
			|| (*name == '/')) {
		    Tcl_DStringAppend(headPtr, "\\", 1);
		} else {
		    Tcl_DStringAppend(headPtr, ".", 1);
d2578 6
a2583 1
	    } else {
d2585 2
a2586 2
		    if (*p == '/') {
			*p = '\\';
d2589 1
d2591 7
a2597 7
#endif
	    name = Tcl_DStringValue(headPtr);
	    exists = (TclpAccess(name, F_OK) == 0);

	    for (p = name; *p != '\0'; p++) {
		if (*p == '\\') {
		    *p = '/';
d2599 1
a2600 5
	    if (exists) {
		Tcl_ListObjAppendElement(interp, Tcl_GetObjResult(interp), 
					 Tcl_NewStringObj(name,-1));
	    }
	    break;
d2602 54
a2655 14
	case TCL_PLATFORM_UNIX: {
	    if (Tcl_DStringLength(headPtr) == 0) {
		if ((*name == '\\' && name[1] == '/') || (*name == '/')) {
		    Tcl_DStringAppend(headPtr, "/", 1);
		} else {
		    Tcl_DStringAppend(headPtr, ".", 1);
		}
	    }
	    name = Tcl_DStringValue(headPtr);
	    if (TclpAccess(name, F_OK) == 0) {
		Tcl_ListObjAppendElement(interp, Tcl_GetObjResult(interp), 
					 Tcl_NewStringObj(name,-1));
	    }
	    break;
d2657 1
d2660 18
a2677 1
    return TCL_OK;
d2679 19
d2699 4
@


1.7
log
@touched all sources to ease next import
@
text
@@


1.7.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d13 1
a13 1
 * RCS: @@(#) $Id: tclFileName.c,v 1.38 2002/09/27 00:50:10 hobbs Exp $
d20 4
a23 4
/* 
 * This define is used to activate Tcl's interpretation of Unix-style
 * paths (containing forward slashes, '.' and '..') on MacOS.  A 
 * side-effect of this is that some paths become ambiguous.
a24 1
#define MAC_UNDERSTANDS_UNIX_PATHS
d26 2
a27 1
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
d31 1
a31 10
 * Unix-style paths, and Mac paths.  The various subexpressions in this
 * can be summarised as follows: ^(/..|~user/unix|~user:mac|/unix|mac:dir).
 * The subexpression indices which match the root portions, are as follows:
 * 
 * degenerate unix-style: 2
 * unix-tilde: 5
 * mac-tilde: 7
 * unix-style: 9 (or 10 to cut off the irrelevant header).
 * mac: 12
 * 
a47 5
static void		FileNameCleanup _ANSI_ARGS_((ClientData clientData));
static void		FileNameInit _ANSI_ARGS_((void));

#endif

d56 9
d68 1
a68 1
static CONST char *	DoTildeSubst _ANSI_ARGS_((Tcl_Interp *interp,
d71 3
a73 2
			    Tcl_DString *resultPtr, int offset, 
			    Tcl_PathType *typePtr));
d76 6
a81 4
static Tcl_Obj*		SplitMacPath _ANSI_ARGS_((CONST char *path));
static Tcl_Obj*		SplitWinPath _ANSI_ARGS_((CONST char *path));
static Tcl_Obj*		SplitUnixPath _ANSI_ARGS_((CONST char *path));
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
a134 1
#endif
d164 3
d169 1
a169 1
	CONST char *host, *share, *tail;
d176 2
a177 2
	}
	host = &path[2];
d179 1
a179 1
	/* Skip separators */
a186 12
	    /* 
	     * The path given is simply of the form 
	     * '/foo', '//foo', '/////foo' or the same
	     * with backslashes.  If there is exactly
	     * one leading '/' the path is volume relative
	     * (see filename man page).  If there are more
	     * than one, we are simply assuming they
	     * are superfluous and we trim them away.
	     * (An alternative interpretation would
	     * be that it is a host name, but we have
	     * been documented that that is not the case).
	     */
d194 1
a194 1
	/* Skip separators */
d208 1
a208 1
	/* Skip separators */
d213 1
a213 1
    } else if (*path && path[1] == ':') {
d221 1
a221 1
	} else {
d224 2
a225 2
	    /* Skip separators */
	    while (*tail && (tail[0] == '/' || tail[0] == '\\')) tail++;
d229 1
a229 1
	    Tcl_DStringAppend(resultPtr, "/", 1);
d231 1
a231 1
	    return tail;
a245 4
 *	
 *	The objectified Tcl_FSGetPathType should be used in
 *	preference to this function (as you can see below, this
 *	is just a wrapper around that other function).
d259 1
a259 1
    CONST char *path;
d261 9
a269 29
    Tcl_PathType type;
    Tcl_Obj *tempObj = Tcl_NewStringObj(path,-1);
    Tcl_IncrRefCount(tempObj);
    type = Tcl_FSGetPathType(tempObj);
    Tcl_DecrRefCount(tempObj);
    return type;
}

/*
 *----------------------------------------------------------------------
 *
 * TclpGetNativePathType --
 *
 *	Determines whether a given path is relative to the current
 *	directory, relative to the current volume, or absolute, but
 *	ONLY FOR THE NATIVE FILESYSTEM. This function is called from
 *	tclIOUtil.c (but needs to be here due to its dependence on
 *	static variables/functions in this file).  The exported
 *	function Tcl_FSGetPathType should be used by extensions.
 *
 * Results:
 *	Returns one of TCL_PATH_ABSOLUTE, TCL_PATH_RELATIVE, or
 *	TCL_PATH_VOLUME_RELATIVE.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
d271 2
a272 19
Tcl_PathType
TclpGetNativePathType(pathObjPtr, driveNameLengthPtr, driveNameRef)
    Tcl_Obj *pathObjPtr;
    int *driveNameLengthPtr;
    Tcl_Obj **driveNameRef;
{
    Tcl_PathType type = TCL_PATH_ABSOLUTE;
    int pathLen;
    char *path = Tcl_GetStringFromObj(pathObjPtr, &pathLen);
    
    if (path[0] == '~') {
	/* 
	 * This case is common to all platforms.
	 * Paths that begin with ~ are absolute.
	 */
	if (driveNameLengthPtr != NULL) {
	    char *end = path + 1;
	    while ((*end != '\0') && (*end != '/')) {
		end++;
d274 8
a281 7
	    *driveNameLengthPtr = end - path;
	}
    } else {
	switch (tclPlatform) {
	    case TCL_PLATFORM_UNIX: {
		char *origPath = path;
	        
d283 2
a284 1
		 * Paths that begin with / are absolute.
d287 5
a291 27
#ifdef __QNX__
		/*
		 * Check for QNX //<node id> prefix
		 */
		if (*path && (pathLen > 3) && (path[0] == '/') 
		  && (path[1] == '/') && isdigit(UCHAR(path[2]))) {
		    path += 3;
		    while (isdigit(UCHAR(*path))) {
			++path;
		    }
		}
#endif
		if (path[0] == '/') {
		    if (driveNameLengthPtr != NULL) {
			/* 
			 * We need this addition in case the QNX code 
			 * was used 
			 */
			*driveNameLengthPtr = (1 + path - origPath);
		    }
		} else {
		    type = TCL_PATH_RELATIVE;
		}
		break;
	    }
	    case TCL_PLATFORM_MAC:
		if (path[0] == ':') {
d294 1
a294 10
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
		    ThreadSpecificData *tsdPtr;
		    Tcl_RegExp re;

		    tsdPtr = TCL_TSD_INIT(&dataKey);

		    /*
		     * Since we have eliminated the easy cases, use the
		     * root pattern to look for the other types.
		     */
d296 2
a297 50
		    FileNameInit();
		    re = Tcl_GetRegExpFromObj(NULL, tsdPtr->macRootPatternPtr,
			    REG_ADVANCED);

		    if (!Tcl_RegExpExec(NULL, re, path, path)) {
			type = TCL_PATH_RELATIVE;
		    } else {
			CONST char *root, *end;
			Tcl_RegExpRange(re, 2, &root, &end);
			if (root != NULL) {
			    type = TCL_PATH_RELATIVE;
			} else {
			    if (driveNameLengthPtr != NULL) {
				Tcl_RegExpRange(re, 0, &root, &end);
				*driveNameLengthPtr = end - root;
			    }
			    if (driveNameRef != NULL) {
				if (*root == '/') {
				    char *c;
				    int gotColon = 0;
				    *driveNameRef = Tcl_NewStringObj(root + 1,
					    end - root -1);
				    c = Tcl_GetString(*driveNameRef);
				    while (*c != '\0') {
					if (*c == '/') {
					    gotColon++;
					    *c = ':';
					}
					c++;
				    }
				    /* 
				     * If there is no colon, we have just a
				     * volume name so we must add a colon so
				     * it is an absolute path.
				     */
				    if (gotColon == 0) {
				        Tcl_AppendToObj(*driveNameRef, ":", 1);
				    } else if ((gotColon > 1) &&
					    (*(c-1) == ':')) {
					/* We have an extra colon */
				        Tcl_SetObjLength(*driveNameRef, 
					  c - Tcl_GetString(*driveNameRef) - 1);
				    }
				}
			    }
			}
		    }
#else
		    if (path[0] == '~') {
		    } else if (path[0] == ':') {
a298 11
		    } else {
			char *colonPos = strchr(path,':');
			if (colonPos == NULL) {
			    type = TCL_PATH_RELATIVE;
			} else {
			}
		    }
		    if (type == TCL_PATH_ABSOLUTE) {
			if (driveNameLengthPtr != NULL) {
			    *driveNameLengthPtr = strlen(path);
			}
a299 1
#endif
d301 5
a305 3
		break;
	    
	    case TCL_PLATFORM_WINDOWS: {
d307 1
a307 2
		CONST char *rootEnd;
		
d309 1
a309 9
		rootEnd = ExtractWinRoot(path, &ds, 0, &type);
		if ((rootEnd != path) && (driveNameLengthPtr != NULL)) {
		    *driveNameLengthPtr = rootEnd - path;
		    if (driveNameRef != NULL) {
			*driveNameRef = Tcl_NewStringObj(Tcl_DStringValue(&ds),
				Tcl_DStringLength(&ds));
			Tcl_IncrRefCount(*driveNameRef);
		    }
		}
a310 1
		break;
d312 1
a312 1
	}
a317 59
 *---------------------------------------------------------------------------
 *
 * TclpNativeSplitPath --
 *
 *      This function takes the given Tcl_Obj, which should be a valid
 *      path, and returns a Tcl List object containing each segment
 *      of that path as an element.
 *
 *      Note this function currently calls the older Split(Plat)Path
 *      functions, which require more memory allocation than is
 *      desirable.
 *      
 * Results:
 *      Returns list object with refCount of zero.  If the passed in
 *      lenPtr is non-NULL, we use it to return the number of elements
 *      in the returned list.
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
 */

Tcl_Obj* 
TclpNativeSplitPath(pathPtr, lenPtr)
    Tcl_Obj *pathPtr;		/* Path to split. */
    int *lenPtr;		/* int to store number of path elements. */
{
    Tcl_Obj *resultPtr = NULL;  /* Needed only to prevent gcc warnings. */

    /*
     * Perform platform specific splitting. 
     */

    switch (tclPlatform) {
	case TCL_PLATFORM_UNIX:
	    resultPtr = SplitUnixPath(Tcl_GetString(pathPtr));
	    break;

	case TCL_PLATFORM_WINDOWS:
	    resultPtr = SplitWinPath(Tcl_GetString(pathPtr));
	    break;
	    
	case TCL_PLATFORM_MAC:
	    resultPtr = SplitMacPath(Tcl_GetString(pathPtr));
	    break;
    }

    /*
     * Compute the number of elements in the result.
     */

    if (lenPtr != NULL) {
	Tcl_ListObjLength(NULL, resultPtr, lenPtr);
    }
    return resultPtr;
}

/*
d348 1
a348 1
    CONST char ***argvPtr;	/* Pointer to place to store pointer to array
d351 5
a355 4
    Tcl_Obj *resultPtr = NULL;  /* Needed only to prevent gcc warnings. */
    Tcl_Obj *tmpPtr, *eltPtr;
    int i, size, len;
    char *p, *str;
d358 3
a360 1
     * Perform the splitting, using objectified, vfs-aware code.
d363 18
a380 4
    tmpPtr = Tcl_NewStringObj(path, -1);
    Tcl_IncrRefCount(tmpPtr);
    resultPtr = Tcl_FSSplitPath(tmpPtr, argcPtr);
    Tcl_DecrRefCount(tmpPtr);
d382 6
a387 7
    /* Calculate space required for the result */
    
    size = 1;
    for (i = 0; i < *argcPtr; i++) {
	Tcl_ListObjIndex(NULL, resultPtr, i, &eltPtr);
	Tcl_GetStringFromObj(eltPtr, &len);
	size += len + 1;
d391 2
a392 2
     * Allocate a buffer large enough to hold the contents of all of
     * the list plus the argv pointers and the terminating NULL pointer.
d395 1
a395 1
    *argvPtr = (CONST char **) ckalloc((unsigned)
d400 1
a400 1
     * the list in, piece by piece.
d404 2
a405 7
    for (i = 0; i < *argcPtr; i++) {
	Tcl_ListObjIndex(NULL, resultPtr, i, &eltPtr);
	str = Tcl_GetStringFromObj(eltPtr, &len);
	memcpy((VOID *) p, (VOID *) str, (size_t) len+1);
	p += len+1;
    }
    
a409 2
    p = (char *) &(*argvPtr)[(*argcPtr) + 1];

d416 1
a416 5
    /*
     * Free the result ptr given to us by Tcl_FSSplitPath
     */

    Tcl_DecrRefCount(resultPtr);
d424 1
a424 1
 *	This routine is used by Tcl_(FS)SplitPath to handle splitting
d428 2
a429 1
 *	Returns a newly allocated Tcl list object.
d437 2
a438 2
static Tcl_Obj*
SplitUnixPath(path)
d440 1
a443 1
    Tcl_Obj *result = Tcl_NewObj();
d463 1
a463 1
	Tcl_ListObjAppendElement(NULL, result, Tcl_NewStringObj("/",1));
a480 1
	    Tcl_Obj *nextElt;
d482 1
a482 4
		nextElt = Tcl_NewStringObj("./",2);
		Tcl_AppendToObj(nextElt, elementStart, length);
	    } else {
		nextElt = Tcl_NewStringObj(elementStart, length);
d484 2
a485 1
	    Tcl_ListObjAppendElement(NULL, result, nextElt);
d491 1
a491 1
    return result;
a492 1

d499 1
a499 1
 *	This routine is used by Tcl_(FS)SplitPath to handle splitting
d503 2
a504 1
 *	Returns a newly allocated Tcl list object.
d512 2
a513 2
static Tcl_Obj*
SplitWinPath(path)
d515 1
d520 2
a521 5
    Tcl_DString buf;
    Tcl_Obj *result = Tcl_NewObj();
    Tcl_DStringInit(&buf);
    
    p = ExtractWinRoot(path, &buf, 0, &type);
d528 1
a528 3
	Tcl_ListObjAppendElement(NULL, result, 
				 Tcl_NewStringObj(Tcl_DStringValue(&buf), 
						  Tcl_DStringLength(&buf)));
d530 1
a530 2
    Tcl_DStringFree(&buf);
    
a542 1
	    Tcl_Obj *nextElt;
d544 1
a544 4
		nextElt = Tcl_NewStringObj("./",2);
		Tcl_AppendToObj(nextElt, elementStart, length);
	    } else {
		nextElt = Tcl_NewStringObj(elementStart, length);
d546 2
a547 1
	    Tcl_ListObjAppendElement(NULL, result, nextElt);
d551 1
a551 1
    return result;
d559 1
a559 1
 *	This routine is used by Tcl_(FS)SplitPath to handle splitting
d563 1
a563 1
 *	Returns a newly allocated Tcl list object.
d571 2
a572 2
static Tcl_Obj*
SplitMacPath(path)
d574 1
d577 1
a577 1
    int length;
a578 2
    Tcl_Obj *result;
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
a579 1
    int i;
d581 1
a581 5
#endif
    
    result = Tcl_NewObj();
    
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
d597 1
a597 2
	CONST char *start, *end;
	Tcl_Obj *nextElt;
d606 1
a606 1
	    Tcl_Obj *elt = Tcl_NewStringObj(":", 1);
d608 2
a609 3
	    Tcl_AppendToObj(elt, path, end - start);
	    Tcl_ListObjAppendElement(NULL, result, elt);
	    return result;
d632 1
d642 1
d653 1
d658 2
a659 1
	 * Append the element and terminate it with a : 
d662 2
a663 3
	nextElt = Tcl_NewStringObj(start, length);
	Tcl_AppendToObj(nextElt, ":", 1);
	Tcl_ListObjAppendElement(NULL, result, nextElt);
a668 28
#else
    if ((path[0] != ':') && (path[0] == '~' || (strchr(path,':') != NULL))) {
	CONST char *end;
	Tcl_Obj *nextElt;

	isMac = 1;
	
	end = strchr(path,':');
	if (end == NULL) {
	    length = strlen(path);
	} else {
	    length = end - path;
	}

	/*
	 * Append the element and terminate it with a :
	 */

	nextElt = Tcl_NewStringObj(path, length);
	Tcl_AppendToObj(nextElt, ":", 1);
	Tcl_ListObjAppendElement(NULL, result, nextElt);
	p = path + length;
    } else {
	isMac = (strchr(path, ':') != NULL);
	isMac = 1;
	p = path;
    }
#endif
a674 3
	 * (This is no longer true if MAC_UNDERSTANDS_UNIX_PATHS 
	 * is false, so we must check whether 'p' points to the
	 * end of the string.)
d676 2
a677 5
	elementStart = p;
	if (*p == ':') {
	    p++;
	}
	
d682 1
a682 2
		    Tcl_ListObjAppendElement(NULL, result,
			    Tcl_NewStringObj("::", 2));
d695 2
a696 2
		Tcl_ListObjAppendElement(NULL, result, 
			Tcl_NewStringObj(elementStart, length));
d700 2
a701 8
	if (elementStart[0] != ':') {
	    if (elementStart[0] != '\0') {
		Tcl_ListObjAppendElement(NULL, result, 
			Tcl_NewStringObj(elementStart, -1));
	    }
	} else {
	    if (elementStart[1] != '\0' || elementStart == path) {
		if ((elementStart[1] != '~') && (elementStart[1] != '\0')
a703 3
		}
		Tcl_ListObjAppendElement(NULL, result, 
			Tcl_NewStringObj(elementStart, -1));
d705 2
d722 1
a722 2
		    Tcl_ListObjAppendElement(NULL, result, 
					     Tcl_NewStringObj(":", 1));
d725 1
a725 2
		    Tcl_ListObjAppendElement(NULL, result, 
					     Tcl_NewStringObj("::", 2));
a726 1
		    Tcl_Obj *nextElt;
d728 1
a728 4
			nextElt = Tcl_NewStringObj(":",1);
			Tcl_AppendToObj(nextElt, elementStart, length);
		    } else {
			nextElt = Tcl_NewStringObj(elementStart, length);
d730 2
a731 1
		    Tcl_ListObjAppendElement(NULL, result, nextElt);
d739 1
a739 1
    return result;
d743 1
a743 1
 *---------------------------------------------------------------------------
d745 1
a745 1
 * Tcl_FSJoinToPath --
d747 1
a747 3
 *      This function takes the given object, which should usually be a
 *      valid path or NULL, and joins onto it the array of paths
 *      segments given.
d750 3
a752 1
 *      Returns object with refCount of zero
d755 1
a755 1
 *	None.
d757 1
a757 1
 *---------------------------------------------------------------------------
d760 5
a764 5
Tcl_Obj* 
Tcl_FSJoinToPath(basePtr, objc, objv)
    Tcl_Obj *basePtr;
    int objc;
    Tcl_Obj *CONST objv[];
d766 8
a773 2
    int i;
    Tcl_Obj *lobj, *ret;
d775 10
a784 29
    if (basePtr == NULL) {
	lobj = Tcl_NewListObj(0, NULL);
    } else {
	lobj = Tcl_NewListObj(1, &basePtr);
    }
    
    for (i = 0; i<objc;i++) {
	Tcl_ListObjAppendElement(NULL, lobj, objv[i]);
    }
    ret = Tcl_FSJoinPath(lobj, -1);
    Tcl_DecrRefCount(lobj);
    return ret;
}

/*
 *---------------------------------------------------------------------------
 *
 * TclpNativeJoinPath --
 *
 *      'prefix' is absolute, 'joining' is relative to prefix.
 *
 * Results:
 *      modifies prefix
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
 */
d786 25
a810 9
void
TclpNativeJoinPath(prefix, joining)
    Tcl_Obj *prefix;
    char* joining;
{
    int length, needsSep;
    char *dest, *p, *start;
    
    start = Tcl_GetStringFromObj(prefix, &length);
d812 3
a814 16
    /*
     * Remove the ./ from tilde prefixed elements unless
     * it is the first component.
     */
    
    p = joining;
    
    if (length != 0) {
	if ((p[0] == '.') && (p[1] == '/') && (p[2] == '~')) {
	    p += 2;
	}
    }
       
    if (*p == '\0') {
	return;
    }
d816 3
d820 6
a825 5
    switch (tclPlatform) {
        case TCL_PLATFORM_UNIX:
	    /*
	     * Append a separator if needed.
	     */
d827 4
a830 10
	    if (length > 0 && (start[length-1] != '/')) {
		Tcl_AppendToObj(prefix, "/", 1);
		length++;
	    }
	    needsSep = 0;
	    
	    /*
	     * Append the element, eliminating duplicate and trailing
	     * slashes.
	     */
d832 8
a839 10
	    Tcl_SetObjLength(prefix, length + (int) strlen(p));
	    
	    dest = Tcl_GetString(prefix) + length;
	    for (; *p != '\0'; p++) {
		if (*p == '/') {
		    while (p[1] == '/') {
			p++;
		    }
		    if (p[1] != '\0') {
			if (needsSep) {
d842 2
a844 3
		} else {
		    *dest++ = *p;
		    needsSep = 1;
d846 2
a848 2
	    length = dest - Tcl_GetString(prefix);
	    Tcl_SetObjLength(prefix, length);
d853 3
a855 1
	     * Check to see if we need to append a separator.
d858 14
a871 11
	    if ((length > 0) && 
		(start[length-1] != '/') && (start[length-1] != ':')) {
		Tcl_AppendToObj(prefix, "/", 1);
		length++;
	    }
	    needsSep = 0;
	    
	    /*
	     * Append the element, eliminating duplicate and
	     * trailing slashes.
	     */
d873 8
a880 9
	    Tcl_SetObjLength(prefix, length + (int) strlen(p));
	    dest = Tcl_GetString(prefix) + length;
	    for (; *p != '\0'; p++) {
		if ((*p == '/') || (*p == '\\')) {
		    while ((p[1] == '/') || (p[1] == '\\')) {
			p++;
		    }
		    if ((p[1] != '\0') && needsSep) {
			*dest++ = '/';
a881 3
		} else {
		    *dest++ = *p;
		    needsSep = 1;
a882 4
	    }
	    length = dest - Tcl_GetString(prefix);
	    Tcl_SetObjLength(prefix, length);
	    break;
d884 4
a887 11
	case TCL_PLATFORM_MAC: {
	    int newLength;
	    
	    /*
	     * Sort out separators.  We basically add the object we've
	     * been given, but we have to make sure that there is
	     * exactly one separator inbetween (unless the object we're
	     * adding contains multiple contiguous colons, all of which
	     * we must add).  Also if an object is just ':' we don't
	     * bother to add it unless it's the very first element.
	     */
d889 6
a894 8
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
	    int adjustedPath = 0;
	    if ((strchr(p, ':') == NULL) && (strchr(p, '/') != NULL)) {
		char *start = p;
		adjustedPath = 1;
		while (*start != '\0') {
		    if (*start == '/') {
		        *start = ':';
d896 20
a915 12
		    start++;
		}
	    }
#endif
	    if (length > 0) {
		if ((p[0] == ':') && (p[1] == '\0')) {
		    return;
		}
		if (start[length-1] != ':') {
		    if (*p != '\0' && *p != ':') {
			Tcl_AppendToObj(prefix, ":", 1);
			length++;
d917 2
a918 7
		} else if (*p == ':') {
		    p++;
		}
	    } else {
		if (*p != '\0' && *p != ':') {
		    Tcl_AppendToObj(prefix, ":", 1);
		    length++;
d921 1
a921 4
	    
	    /*
	     * Append the element
	     */
d923 12
a934 15
	    newLength = strlen(p);
	    /* 
	     * It may not be good to just do 'Tcl_AppendToObj(prefix,
	     * p, newLength)' because the object may contain duplicate
	     * colons which we want to get rid of.
	     */
	    Tcl_AppendToObj(prefix, p, newLength);
	    
	    /* Remove spurious trailing single ':' */
	    dest = Tcl_GetString(prefix) + length + newLength;
	    if (*(dest-1) == ':') {
		if (dest-1 > Tcl_GetString(prefix)) {
		    if (*(dest-2) != ':') {
		        Tcl_SetObjLength(prefix, length + newLength -1);
		    }
d936 27
a962 8
	    }
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
	    /* Revert the path to what it was */
	    if (adjustedPath) {
		char *start = joining;
		while (*start != '\0') {
		    if (*start == ':') {
			*start = '/';
d964 2
a965 1
		    start++;
a967 1
#endif
d969 1
a969 1
	}
d971 1
a971 52
    return;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_JoinPath --
 *
 *	Combine a list of paths in a platform specific manner.  The
 *	function 'Tcl_FSJoinPath' should be used in preference where
 *	possible.
 *
 * Results:
 *	Appends the joined path to the end of the specified 
 *	Tcl_DString returning a pointer to the resulting string.  Note
 *	that the Tcl_DString must already be initialized.
 *
 * Side effects:
 *	Modifies the Tcl_DString.
 *
 *----------------------------------------------------------------------
 */

char *
Tcl_JoinPath(argc, argv, resultPtr)
    int argc;
    CONST char * CONST *argv;
    Tcl_DString *resultPtr;	/* Pointer to previously initialized DString */
{
    int i, len;
    Tcl_Obj *listObj = Tcl_NewObj();
    Tcl_Obj *resultObj;
    char *resultStr;

    /* Build the list of paths */
    for (i = 0; i < argc; i++) {
        Tcl_ListObjAppendElement(NULL, listObj,
		Tcl_NewStringObj(argv[i], -1));
    }

    /* Ask the objectified code to join the paths */
    Tcl_IncrRefCount(listObj);
    resultObj = Tcl_FSJoinPath(listObj, argc);
    Tcl_IncrRefCount(resultObj);
    Tcl_DecrRefCount(listObj);

    /* Store the result */
    resultStr = Tcl_GetStringFromObj(resultObj, &len);
    Tcl_DStringAppend(resultPtr, resultStr, len);
    Tcl_DecrRefCount(resultObj);

    /* Return a pointer to the result */
d1005 1
a1005 1
    CONST char *name;		/* File name, which may begin with "~" (to
d1012 17
a1028 2
    Tcl_Obj *path = Tcl_NewStringObj(name, -1);
    CONST char *result;
d1030 20
a1049 9
    Tcl_IncrRefCount(path);
    result = Tcl_FSGetTranslatedStringPath(interp, path);
    if (result == NULL) {
	Tcl_DecrRefCount(path);
	return NULL;
    }
    Tcl_DStringInit(bufferPtr);
    Tcl_DStringAppend(bufferPtr, result, -1);
    Tcl_DecrRefCount(path);
d1056 1
a1057 1
	register char *p;
d1064 1
a1102 1
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
a1107 3
#else
	    lastSep = strrchr(name, ':');
#endif
d1120 2
a1121 1
    if ((p != NULL) && (lastSep != NULL) && (lastSep > p)) {
d1157 1
a1157 1
static CONST char *
d1166 1
a1166 1
    CONST char *dir;
d1192 1
a1192 1
    return Tcl_DStringValue(resultPtr);
d1220 2
a1221 2
    int index, i, globFlags, length, join, dir, result;
    char *string, *separators;
d1223 3
a1225 5
    Tcl_Obj *pathOrDir = NULL;
    Tcl_DString prefix;
    static CONST char *options[] = {
	"-directory", "-join", "-nocomplain", "-path", "-tails", 
	"-types", "--", NULL
d1228 1
a1228 2
	GLOB_DIR, GLOB_JOIN, GLOB_NOCOMPLAIN, GLOB_PATH, GLOB_TAILS, 
	GLOB_TYPE, GLOB_LAST
d1231 1
a1231 1
    Tcl_GlobTypeData *globTypes = NULL;
d1236 1
d1260 1
a1260 1
	        globFlags |= TCL_GLOBMODE_NO_COMPLAIN;
d1268 1
a1268 1
		if (dir != PATH_NONE) {
d1275 2
a1276 2
		globFlags |= TCL_GLOBMODE_DIR;
		pathOrDir = objv[i+1];
a1281 3
	    case GLOB_TAILS:				/* -tails */
	        globFlags |= TCL_GLOBMODE_TAILS;
		break;
d1288 1
a1288 1
		if (dir != PATH_NONE) {
d1295 1
a1295 1
		pathOrDir = objv[i+1];
d1321 1
a1321 7
    if ((globFlags & TCL_GLOBMODE_TAILS) && (pathOrDir == NULL)) {
	Tcl_AppendToObj(resultPtr,
	  "\"-tails\" must be used with either \"-directory\" or \"-path\"",
	  -1);
	return TCL_ERROR;
    }
    
a1334 1
	int pathlength;
a1335 1
	char *first = Tcl_GetStringFromObj(pathOrDir,&pathlength);
d1340 2
a1341 2
	last = first + pathlength;
	for (; last != first; last--) {
d1346 1
a1346 1
	if (last == first + pathlength) {
d1348 1
a1348 1
	    dir = PATH_DIR;
d1353 2
a1354 1
	    if (last == first) {
d1356 1
a1356 1
		Tcl_DStringAppend(&pref, first, -1);
d1360 3
a1362 2
		Tcl_DStringAppend(&pref, last, first+pathlength-last);
		pathOrDir = Tcl_NewStringObj(first, last-first-1);
d1382 1
a1382 5
    
    if (pathOrDir != NULL) {
	Tcl_IncrRefCount(pathOrDir);
    }
    
d1390 1
a1390 1
	globTypes = (Tcl_GlobTypeData*) ckalloc(sizeof(Tcl_GlobTypeData));
d1473 1
a1473 4
		 * Error cases.  We re-get the interpreter's result,
		 * just to be sure it hasn't changed, and we reset
		 * the 'join' flag to zero, since we haven't yet
		 * made use of it.
a1475 1
		resultPtr = Tcl_GetObjResult(interp);
a1478 1
		join = 0;
a1480 1
		resultPtr = Tcl_GetObjResult(interp);
d1482 1
a1482 2
		   "only one MacOS type or creator argument"
		   " to \"-types\" allowed", -1);
a1483 1
		join = 0;
d1549 1
a1549 1
    if ((globFlags & TCL_GLOBMODE_NO_COMPLAIN) == 0) {
d1577 3
a1579 3
    }
    if (pathOrDir != NULL) {
	Tcl_DecrRefCount(pathOrDir);
a1600 5
 *      
 *      The interpreter's result, on entry to this function, must
 *      be a valid Tcl list (e.g. it could be empty), since we will
 *      lappend any new results to that list.  If it is not a valid
 *      list, this function will fail to do anything very meaningful.
d1606 2
a1607 5
 *	given by the pattern and unquotedPrefix arguments.  After an 
 *	error the result in interp will hold an error message, unless
 *	the 'TCL_GLOBMODE_NO_COMPLAIN' flag was given, in which case
 *	an error results in a TCL_OK return leaving the interpreter's
 *	result unmodified.
d1610 1
a1610 1
 *	The 'pattern' is written to.
d1622 2
a1623 2
    Tcl_Obj *unquotedPrefix;	/* Prefix to glob pattern, if non-null, which
                             	 * is considered literally. */
d1625 1
a1625 1
    Tcl_GlobTypeData *types;	/* Struct containing acceptable types.
d1629 1
a1629 2
    CONST char *head;
    char *tail, *start;
d1631 1
a1631 1
    int result, prefixLen;
a1632 1
    Tcl_Obj *oldResult;
a1642 1
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
a1647 3
#else
	    separators = ":";
#endif
d1653 1
a1653 1
	start = Tcl_GetString(unquotedPrefix);
d1678 2
a1679 1
	 * Determine the home directory for the specified user.  
d1684 11
a1694 6
	if (globFlags & TCL_GLOBMODE_NO_COMPLAIN) {
	    /* 
	     * We will ignore any error message here, and we
	     * don't want to mess up the interpreter's result.
	     */
	    head = DoTildeSubst(NULL, start+1, &buffer);
d1696 6
a1701 1
	    head = DoTildeSubst(interp, start+1, &buffer);
d1703 1
d1706 10
a1715 1
	    if (globFlags & TCL_GLOBMODE_NO_COMPLAIN) {
d1731 1
a1731 1
	    Tcl_DStringAppend(&buffer,Tcl_GetString(unquotedPrefix),-1);
a1733 1
    
d1735 7
a1741 15
     * We want to remember the length of the current prefix,
     * in case we are using TCL_GLOBMODE_TAILS.  Also if we
     * are using TCL_GLOBMODE_DIR, we must make sure the
     * prefix ends in a directory separator.
     */
    prefixLen = Tcl_DStringLength(&buffer);

    if (prefixLen > 0) {
	c = Tcl_DStringValue(&buffer)[prefixLen-1];
	if (strchr(separators, c) == NULL) {
	    /* 
	     * If the prefix is a directory, make sure it ends in a
	     * directory separator.
	     */
	    if (globFlags & TCL_GLOBMODE_DIR) {
a1743 1
	    prefixLen++;
a1746 8
    /* 
     * We need to get the old result, in case it is over-written
     * below when we still need it.
     */
    oldResult = Tcl_GetObjResult(interp);
    Tcl_IncrRefCount(oldResult);
    Tcl_ResetResult(interp);
    
d1748 1
a1748 1
    
d1750 3
a1752 61
	if (globFlags & TCL_GLOBMODE_NO_COMPLAIN) {
	    /* Put back the old result and reset the return code */
	    Tcl_SetObjResult(interp, oldResult);
	    result = TCL_OK;
	}
    } else {
	/* 
	 * Now we must concatenate the 'oldResult' and the current
	 * result, and then place that into the interpreter.
	 * 
	 * If we only want the tails, we must strip off the prefix now.
	 * It may seem more efficient to pass the tails flag down into
	 * TclDoGlob, Tcl_FSMatchInDirectory, but those functions are
	 * continually adjusting the prefix as the various pieces of
	 * the pattern are assimilated, so that would add a lot of
	 * complexity to the code.  This way is a little slower (when
	 * the -tails flag is given), but much simpler to code.
	 */
	int objc, i;
	Tcl_Obj **objv;

	/* Ensure sole ownership */
	if (Tcl_IsShared(oldResult)) {
	    Tcl_DecrRefCount(oldResult);
	    oldResult = Tcl_DuplicateObj(oldResult);
	    Tcl_IncrRefCount(oldResult);
	}

	Tcl_ListObjGetElements(NULL, Tcl_GetObjResult(interp), 
			       &objc, &objv);
#ifdef MAC_TCL
	/* adjust prefixLen if TclDoGlob prepended a ':' */
	if ((prefixLen > 0) && (objc > 0)
	&& (Tcl_DStringValue(&buffer)[0] != ':')) {
	    char *str = Tcl_GetStringFromObj(objv[0],NULL);
	    if (str[0] == ':') {
		    prefixLen++;
	    }
	}
#endif
	for (i = 0; i< objc; i++) {
	    Tcl_Obj* elt;
	    if (globFlags & TCL_GLOBMODE_TAILS) {
		int len;
		char *oldStr = Tcl_GetStringFromObj(objv[i],&len);
		if (len == prefixLen) {
		    if ((pattern[0] == '\0')
			|| (strchr(separators, pattern[0]) == NULL)) {
			elt = Tcl_NewStringObj(".",1);
		    } else {
			elt = Tcl_NewStringObj("/",1);
		    }
		} else {
		    elt = Tcl_NewStringObj(oldStr + prefixLen, 
						len - prefixLen);
		}
	    } else {
		elt = objv[i];
	    }
	    /* Assumption that 'oldResult' is a valid list */
	    Tcl_ListObjAppendElement(interp, oldResult, elt);
a1753 1
	Tcl_SetObjResult(interp, oldResult);
a1754 6
    /* 
     * Release our temporary copy.  All code paths above must
     * end here so we free our reference.
     */
    Tcl_DecrRefCount(oldResult);
    Tcl_DStringFree(&buffer);
d1847 2
a1848 2
    Tcl_GlobTypeData *types;	/* List object containing list of acceptable 
                            	 * types. May be NULL. */
a1884 1
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
a1890 1
#endif
a1902 1
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
a1903 1
#endif
d2005 2
a2006 2
	    result = TclDoGlob(interp, separators, headPtr, 
			       Tcl_DStringValue(&newName), types);
d2031 4
a2034 4
	savedChar = *p;
	*p = '\0';
	firstSpecialChar = strpbrk(tail, "*[]?\\");
	*p = savedChar;
a2039 3
	int ret;
	Tcl_Obj *head = Tcl_NewStringObj(Tcl_DStringValue(headPtr),-1);
	Tcl_IncrRefCount(head);
d2041 5
a2045 4
	 * Look for matching files in the given directory.  The
	 * implementation of this function is platform specific.  For
	 * each file that matches, it will add the match onto the
	 * resultPtr given.
a2046 5
	if (*p == '\0') {
	    ret = Tcl_FSMatchInDirectory(interp, Tcl_GetObjResult(interp), 
					 head, tail, types);
	} else {
	    Tcl_Obj* resultPtr;
d2048 1
a2048 40
	    /* 
	     * We do the recursion ourselves.  This makes implementing
	     * Tcl_FSMatchInDirectory for each filesystem much easier.
	     */
	    Tcl_GlobTypeData dirOnly = { TCL_GLOB_TYPE_DIR, 0, NULL, NULL };
	    char save = *p;
	    
	    *p = '\0';
	    resultPtr = Tcl_NewListObj(0, NULL);
	    ret = Tcl_FSMatchInDirectory(interp, resultPtr, 
					 head, tail, &dirOnly);
	    *p = save;
	    if (ret == TCL_OK) {
		int resLength;
		ret = Tcl_ListObjLength(interp, resultPtr, &resLength);
		if (ret == TCL_OK) {
		    int i;
		    for (i =0; i< resLength; i++) {
			Tcl_Obj *elt;
			Tcl_DString ds;
			Tcl_ListObjIndex(interp, resultPtr, i, &elt);
			Tcl_DStringInit(&ds);
			Tcl_DStringAppend(&ds, Tcl_GetString(elt), -1);
			if(tclPlatform == TCL_PLATFORM_MAC) {
			    Tcl_DStringAppend(&ds, ":",1);
			} else {			
			    Tcl_DStringAppend(&ds, "/",1);
			}
			ret = TclDoGlob(interp, separators, &ds, p+1, types);
			Tcl_DStringFree(&ds);
			if (ret != TCL_OK) {
			    break;
			}
		    }
		}
	    }
	    Tcl_DecrRefCount(resultPtr);
	}
	Tcl_DecrRefCount(head);
	return ret;
d2053 7
a2059 12
    } else {
	/*
	 * This is the code path reached by a command like 'glob foo'.
	 *
	 * There are no more wildcards in the pattern and no more
	 * unprocessed characters in the tail, so now we can construct
	 * the path, and pass it to Tcl_FSMatchInDirectory with an
	 * empty pattern to verify the existence of the file and check
	 * it is of the correct type (if a 'types' flag it given -- if
	 * no such flag was given, we could just use 'Tcl_FSLStat', but
	 * for simplicity we keep to a common approach).
	 */
d2061 13
a2073 8
	Tcl_Obj *nameObj;
	/* Used to deal with one special case pertinent to MacOS */
	int macSpecialCase = 0;

	switch (tclPlatform) {
	    case TCL_PLATFORM_MAC: {
		if (strchr(Tcl_DStringValue(headPtr), ':') == NULL) {
		    Tcl_DStringAppend(headPtr, ":", 1);
a2074 2
		macSpecialCase = 1;
		break;
d2076 18
a2093 8
	    case TCL_PLATFORM_WINDOWS: {
		if (Tcl_DStringLength(headPtr) == 0) {
		    if (((*name == '\\') && (name[1] == '/' || name[1] == '\\'))
			    || (*name == '/')) {
			Tcl_DStringAppend(headPtr, "/", 1);
		    } else {
			Tcl_DStringAppend(headPtr, ".", 1);
		    }
d2095 1
a2095 19
#if defined(__CYGWIN__) && defined(__WIN32__)
		{

		extern int cygwin_conv_to_win32_path 
		    _ANSI_ARGS_((CONST char *, char *));
		char winbuf[MAX_PATH+1];

		cygwin_conv_to_win32_path(Tcl_DStringValue(headPtr), winbuf);
		Tcl_DStringFree(headPtr);
		Tcl_DStringAppend(headPtr, winbuf, -1);

		}
#endif /* __CYGWIN__ && __WIN32__ */
		/* 
		 * Convert to forward slashes.  This is required to pass
		 * some Tcl tests.  We should probably remove the conversions
		 * here and in tclWinFile.c, since they aren't needed since
		 * the dropping of support for Win32s.
		 */
d2097 2
a2098 2
		    if (*p == '\\') {
			*p = '/';
a2100 1
		break;
d2102 7
a2108 7
	    case TCL_PLATFORM_UNIX: {
		if (Tcl_DStringLength(headPtr) == 0) {
		    if ((*name == '\\' && name[1] == '/') || (*name == '/')) {
			Tcl_DStringAppend(headPtr, "/", 1);
		    } else {
			Tcl_DStringAppend(headPtr, ".", 1);
		    }
a2109 1
		break;
d2111 5
d2117 14
a2130 54
	/* Common for all platforms */
	name = Tcl_DStringValue(headPtr);
	nameObj = Tcl_NewStringObj(name, Tcl_DStringLength(headPtr));

	Tcl_IncrRefCount(nameObj);
	Tcl_FSMatchInDirectory(interp, Tcl_GetObjResult(interp), nameObj, 
			       NULL, types);
	Tcl_DecrRefCount(nameObj);
	return TCL_OK;
    }
}


/*
 *---------------------------------------------------------------------------
 *
 * TclFileDirname
 *
 *	This procedure calculates the directory above a given 
 *	path: basically 'file dirname'.  It is used both by
 *	the 'dirname' subcommand of file and by code in tclIOUtil.c.
 *
 * Results:
 *	NULL if an error occurred, otherwise a Tcl_Obj owned by
 *	the caller (i.e. most likely with refCount 1).
 *
 * Side effects:
 *      None.
 *
 *---------------------------------------------------------------------------
 */

Tcl_Obj*
TclFileDirname(interp, pathPtr)
    Tcl_Interp *interp;		/* Used for error reporting */
    Tcl_Obj *pathPtr;           /* Path to take dirname of */
{
    int splitElements;
    Tcl_Obj *splitPtr;
    Tcl_Obj *splitResultPtr = NULL;

    /* 
     * The behaviour we want here is slightly different to
     * the standard Tcl_FSSplitPath in the handling of home
     * directories; Tcl_FSSplitPath preserves the "~" while 
     * this code computes the actual full path name, if we
     * had just a single component.
     */	    
    splitPtr = Tcl_FSSplitPath(pathPtr, &splitElements);
    if ((splitElements == 1) && (Tcl_GetString(pathPtr)[0] == '~')) {
	Tcl_DecrRefCount(splitPtr);
	splitPtr = Tcl_FSGetNormalizedPath(interp, pathPtr);
	if (splitPtr == NULL) {
	    return NULL;
a2131 1
	splitPtr = Tcl_FSSplitPath(splitPtr, &splitElements);
d2134 1
a2134 18
    /*
     * Return all but the last component.  If there is only one
     * component, return it if the path was non-relative, otherwise
     * return the current directory.
     */

    if (splitElements > 1) {
	splitResultPtr = Tcl_FSJoinPath(splitPtr, splitElements - 1);
    } else if (splitElements == 0 || 
      (Tcl_FSGetPathType(pathPtr) == TCL_PATH_RELATIVE)) {
	splitResultPtr = Tcl_NewStringObj(
		((tclPlatform == TCL_PLATFORM_MAC) ? ":" : "."), 1);
    } else {
	Tcl_ListObjIndex(NULL, splitPtr, 0, &splitResultPtr);
    }
    Tcl_IncrRefCount(splitResultPtr);
    Tcl_DecrRefCount(splitPtr);
    return splitResultPtr;
a2135 19

/*
 *---------------------------------------------------------------------------
 *
 * Tcl_AllocStatBuf
 *
 *     This procedure allocates a Tcl_StatBuf on the heap.  It exists
 *     so that extensions may be used unchanged on systems where
 *     largefile support is optional.
 *
 * Results:
 *     A pointer to a Tcl_StatBuf which may be deallocated by being
 *     passed to ckfree().
 *
 * Side effects:
 *      None.
 *
 *---------------------------------------------------------------------------
 */
a2136 4
Tcl_StatBuf *
Tcl_AllocStatBuf() {
    return (Tcl_StatBuf *) ckalloc(sizeof(Tcl_StatBuf));
}
@


1.7.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@d13 1
a13 1
 * RCS: @@(#) $Id: tclFileName.c,v 1.37 2002/06/05 11:59:33 das Exp $
d20 4
a23 4
/* 
 * This define is used to activate Tcl's interpretation of Unix-style
 * paths (containing forward slashes, '.' and '..') on MacOS.  A 
 * side-effect of this is that some paths become ambiguous.
a24 1
#define MAC_UNDERSTANDS_UNIX_PATHS
d26 2
a27 1
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
d31 1
a31 10
 * Unix-style paths, and Mac paths.  The various subexpressions in this
 * can be summarised as follows: ^(/..|~user/unix|~user:mac|/unix|mac:dir).
 * The subexpression indices which match the root portions, are as follows:
 * 
 * degenerate unix-style: 2
 * unix-tilde: 5
 * mac-tilde: 7
 * unix-style: 9 (or 10 to cut off the irrelevant header).
 * mac: 12
 * 
a47 5
static void		FileNameCleanup _ANSI_ARGS_((ClientData clientData));
static void		FileNameInit _ANSI_ARGS_((void));

#endif

d56 9
d68 1
a68 1
static CONST char *	DoTildeSubst _ANSI_ARGS_((Tcl_Interp *interp,
d71 3
a73 2
			    Tcl_DString *resultPtr, int offset, 
			    Tcl_PathType *typePtr));
d76 6
a81 4
static Tcl_Obj*		SplitMacPath _ANSI_ARGS_((CONST char *path));
static Tcl_Obj*		SplitWinPath _ANSI_ARGS_((CONST char *path));
static Tcl_Obj*		SplitUnixPath _ANSI_ARGS_((CONST char *path));
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
a134 1
#endif
d164 3
d169 1
a169 1
	CONST char *host, *share, *tail;
d176 2
a177 2
	}
	host = &path[2];
d179 1
a179 1
	/* Skip separators */
a186 12
	    /* 
	     * The path given is simply of the form 
	     * '/foo', '//foo', '/////foo' or the same
	     * with backslashes.  If there is exactly
	     * one leading '/' the path is volume relative
	     * (see filename man page).  If there are more
	     * than one, we are simply assuming they
	     * are superfluous and we trim them away.
	     * (An alternative interpretation would
	     * be that it is a host name, but we have
	     * been documented that that is not the case).
	     */
d194 1
a194 1
	/* Skip separators */
d208 1
a208 1
	/* Skip separators */
d213 1
a213 1
    } else if (*path && path[1] == ':') {
d221 1
a221 1
	} else {
d224 2
a225 2
	    /* Skip separators */
	    while (*tail && (tail[0] == '/' || tail[0] == '\\')) tail++;
d229 1
a229 1
	    Tcl_DStringAppend(resultPtr, "/", 1);
d231 1
a231 1
	    return tail;
a245 4
 *	
 *	The objectified Tcl_FSGetPathType should be used in
 *	preference to this function (as you can see below, this
 *	is just a wrapper around that other function).
d259 1
a259 1
    CONST char *path;
d261 9
a269 29
    Tcl_PathType type;
    Tcl_Obj *tempObj = Tcl_NewStringObj(path,-1);
    Tcl_IncrRefCount(tempObj);
    type = Tcl_FSGetPathType(tempObj);
    Tcl_DecrRefCount(tempObj);
    return type;
}

/*
 *----------------------------------------------------------------------
 *
 * TclpGetNativePathType --
 *
 *	Determines whether a given path is relative to the current
 *	directory, relative to the current volume, or absolute, but
 *	ONLY FOR THE NATIVE FILESYSTEM. This function is called from
 *	tclIOUtil.c (but needs to be here due to its dependence on
 *	static variables/functions in this file).  The exported
 *	function Tcl_FSGetPathType should be used by extensions.
 *
 * Results:
 *	Returns one of TCL_PATH_ABSOLUTE, TCL_PATH_RELATIVE, or
 *	TCL_PATH_VOLUME_RELATIVE.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
d271 2
a272 19
Tcl_PathType
TclpGetNativePathType(pathObjPtr, driveNameLengthPtr, driveNameRef)
    Tcl_Obj *pathObjPtr;
    int *driveNameLengthPtr;
    Tcl_Obj **driveNameRef;
{
    Tcl_PathType type = TCL_PATH_ABSOLUTE;
    int pathLen;
    char *path = Tcl_GetStringFromObj(pathObjPtr, &pathLen);
    
    if (path[0] == '~') {
	/* 
	 * This case is common to all platforms.
	 * Paths that begin with ~ are absolute.
	 */
	if (driveNameLengthPtr != NULL) {
	    char *end = path + 1;
	    while ((*end != '\0') && (*end != '/')) {
		end++;
d274 8
a281 7
	    *driveNameLengthPtr = end - path;
	}
    } else {
	switch (tclPlatform) {
	    case TCL_PLATFORM_UNIX: {
		char *origPath = path;
	        
d283 2
a284 1
		 * Paths that begin with / are absolute.
d287 5
a291 27
#ifdef __QNX__
		/*
		 * Check for QNX //<node id> prefix
		 */
		if (*path && (pathLen > 3) && (path[0] == '/') 
		  && (path[1] == '/') && isdigit(UCHAR(path[2]))) {
		    path += 3;
		    while (isdigit(UCHAR(*path))) {
			++path;
		    }
		}
#endif
		if (path[0] == '/') {
		    if (driveNameLengthPtr != NULL) {
			/* 
			 * We need this addition in case the QNX code 
			 * was used 
			 */
			*driveNameLengthPtr = (1 + path - origPath);
		    }
		} else {
		    type = TCL_PATH_RELATIVE;
		}
		break;
	    }
	    case TCL_PLATFORM_MAC:
		if (path[0] == ':') {
d294 1
a294 10
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
		    ThreadSpecificData *tsdPtr;
		    Tcl_RegExp re;

		    tsdPtr = TCL_TSD_INIT(&dataKey);

		    /*
		     * Since we have eliminated the easy cases, use the
		     * root pattern to look for the other types.
		     */
d296 2
a297 50
		    FileNameInit();
		    re = Tcl_GetRegExpFromObj(NULL, tsdPtr->macRootPatternPtr,
			    REG_ADVANCED);

		    if (!Tcl_RegExpExec(NULL, re, path, path)) {
			type = TCL_PATH_RELATIVE;
		    } else {
			CONST char *root, *end;
			Tcl_RegExpRange(re, 2, &root, &end);
			if (root != NULL) {
			    type = TCL_PATH_RELATIVE;
			} else {
			    if (driveNameLengthPtr != NULL) {
				Tcl_RegExpRange(re, 0, &root, &end);
				*driveNameLengthPtr = end - root;
			    }
			    if (driveNameRef != NULL) {
				if (*root == '/') {
				    char *c;
				    int gotColon = 0;
				    *driveNameRef = Tcl_NewStringObj(root + 1,
					    end - root -1);
				    c = Tcl_GetString(*driveNameRef);
				    while (*c != '\0') {
					if (*c == '/') {
					    gotColon++;
					    *c = ':';
					}
					c++;
				    }
				    /* 
				     * If there is no colon, we have just a
				     * volume name so we must add a colon so
				     * it is an absolute path.
				     */
				    if (gotColon == 0) {
				        Tcl_AppendToObj(*driveNameRef, ":", 1);
				    } else if ((gotColon > 1) &&
					    (*(c-1) == ':')) {
					/* We have an extra colon */
				        Tcl_SetObjLength(*driveNameRef, 
					  c - Tcl_GetString(*driveNameRef) - 1);
				    }
				}
			    }
			}
		    }
#else
		    if (path[0] == '~') {
		    } else if (path[0] == ':') {
a298 11
		    } else {
			char *colonPos = strchr(path,':');
			if (colonPos == NULL) {
			    type = TCL_PATH_RELATIVE;
			} else {
			}
		    }
		    if (type == TCL_PATH_ABSOLUTE) {
			if (driveNameLengthPtr != NULL) {
			    *driveNameLengthPtr = strlen(path);
			}
a299 1
#endif
d301 5
a305 3
		break;
	    
	    case TCL_PLATFORM_WINDOWS: {
d307 1
a307 2
		CONST char *rootEnd;
		
d309 1
a309 9
		rootEnd = ExtractWinRoot(path, &ds, 0, &type);
		if ((rootEnd != path) && (driveNameLengthPtr != NULL)) {
		    *driveNameLengthPtr = rootEnd - path;
		    if (driveNameRef != NULL) {
			*driveNameRef = Tcl_NewStringObj(Tcl_DStringValue(&ds),
				Tcl_DStringLength(&ds));
			Tcl_IncrRefCount(*driveNameRef);
		    }
		}
a310 1
		break;
d312 1
a312 1
	}
a317 59
 *---------------------------------------------------------------------------
 *
 * TclpNativeSplitPath --
 *
 *      This function takes the given Tcl_Obj, which should be a valid
 *      path, and returns a Tcl List object containing each segment
 *      of that path as an element.
 *
 *      Note this function currently calls the older Split(Plat)Path
 *      functions, which require more memory allocation than is
 *      desirable.
 *      
 * Results:
 *      Returns list object with refCount of zero.  If the passed in
 *      lenPtr is non-NULL, we use it to return the number of elements
 *      in the returned list.
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
 */

Tcl_Obj* 
TclpNativeSplitPath(pathPtr, lenPtr)
    Tcl_Obj *pathPtr;		/* Path to split. */
    int *lenPtr;		/* int to store number of path elements. */
{
    Tcl_Obj *resultPtr = NULL;  /* Needed only to prevent gcc warnings. */

    /*
     * Perform platform specific splitting. 
     */

    switch (tclPlatform) {
	case TCL_PLATFORM_UNIX:
	    resultPtr = SplitUnixPath(Tcl_GetString(pathPtr));
	    break;

	case TCL_PLATFORM_WINDOWS:
	    resultPtr = SplitWinPath(Tcl_GetString(pathPtr));
	    break;
	    
	case TCL_PLATFORM_MAC:
	    resultPtr = SplitMacPath(Tcl_GetString(pathPtr));
	    break;
    }

    /*
     * Compute the number of elements in the result.
     */

    if (lenPtr != NULL) {
	Tcl_ListObjLength(NULL, resultPtr, lenPtr);
    }
    return resultPtr;
}

/*
d348 1
a348 1
    CONST char ***argvPtr;	/* Pointer to place to store pointer to array
d351 5
a355 4
    Tcl_Obj *resultPtr = NULL;  /* Needed only to prevent gcc warnings. */
    Tcl_Obj *tmpPtr, *eltPtr;
    int i, size, len;
    char *p, *str;
d358 3
a360 1
     * Perform the splitting, using objectified, vfs-aware code.
d363 18
a380 4
    tmpPtr = Tcl_NewStringObj(path, -1);
    Tcl_IncrRefCount(tmpPtr);
    resultPtr = Tcl_FSSplitPath(tmpPtr, argcPtr);
    Tcl_DecrRefCount(tmpPtr);
d382 6
a387 7
    /* Calculate space required for the result */
    
    size = 1;
    for (i = 0; i < *argcPtr; i++) {
	Tcl_ListObjIndex(NULL, resultPtr, i, &eltPtr);
	Tcl_GetStringFromObj(eltPtr, &len);
	size += len + 1;
d391 2
a392 2
     * Allocate a buffer large enough to hold the contents of all of
     * the list plus the argv pointers and the terminating NULL pointer.
d395 1
a395 1
    *argvPtr = (CONST char **) ckalloc((unsigned)
d400 1
a400 1
     * the list in, piece by piece.
d404 2
a405 7
    for (i = 0; i < *argcPtr; i++) {
	Tcl_ListObjIndex(NULL, resultPtr, i, &eltPtr);
	str = Tcl_GetStringFromObj(eltPtr, &len);
	memcpy((VOID *) p, (VOID *) str, (size_t) len+1);
	p += len+1;
    }
    
a409 2
    p = (char *) &(*argvPtr)[(*argcPtr) + 1];

d416 1
a416 5
    /*
     * Free the result ptr given to us by Tcl_FSSplitPath
     */

    Tcl_DecrRefCount(resultPtr);
d424 1
a424 1
 *	This routine is used by Tcl_(FS)SplitPath to handle splitting
d428 2
a429 1
 *	Returns a newly allocated Tcl list object.
d437 2
a438 2
static Tcl_Obj*
SplitUnixPath(path)
d440 1
a443 1
    Tcl_Obj *result = Tcl_NewObj();
d463 1
a463 1
	Tcl_ListObjAppendElement(NULL, result, Tcl_NewStringObj("/",1));
a480 1
	    Tcl_Obj *nextElt;
d482 1
a482 4
		nextElt = Tcl_NewStringObj("./",2);
		Tcl_AppendToObj(nextElt, elementStart, length);
	    } else {
		nextElt = Tcl_NewStringObj(elementStart, length);
d484 2
a485 1
	    Tcl_ListObjAppendElement(NULL, result, nextElt);
d491 1
a491 1
    return result;
a492 1

d499 1
a499 1
 *	This routine is used by Tcl_(FS)SplitPath to handle splitting
d503 2
a504 1
 *	Returns a newly allocated Tcl list object.
d512 2
a513 2
static Tcl_Obj*
SplitWinPath(path)
d515 1
d520 2
a521 5
    Tcl_DString buf;
    Tcl_Obj *result = Tcl_NewObj();
    Tcl_DStringInit(&buf);
    
    p = ExtractWinRoot(path, &buf, 0, &type);
d528 1
a528 3
	Tcl_ListObjAppendElement(NULL, result, 
				 Tcl_NewStringObj(Tcl_DStringValue(&buf), 
						  Tcl_DStringLength(&buf)));
d530 1
a530 2
    Tcl_DStringFree(&buf);
    
a542 1
	    Tcl_Obj *nextElt;
d544 1
a544 4
		nextElt = Tcl_NewStringObj("./",2);
		Tcl_AppendToObj(nextElt, elementStart, length);
	    } else {
		nextElt = Tcl_NewStringObj(elementStart, length);
d546 2
a547 1
	    Tcl_ListObjAppendElement(NULL, result, nextElt);
d551 1
a551 1
    return result;
d559 1
a559 1
 *	This routine is used by Tcl_(FS)SplitPath to handle splitting
d563 1
a563 1
 *	Returns a newly allocated Tcl list object.
d571 2
a572 2
static Tcl_Obj*
SplitMacPath(path)
d574 1
d577 1
a577 1
    int length;
a578 2
    Tcl_Obj *result;
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
a579 1
    int i;
d581 1
a581 5
#endif
    
    result = Tcl_NewObj();
    
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
d597 1
a597 2
	CONST char *start, *end;
	Tcl_Obj *nextElt;
d606 1
a606 1
	    Tcl_Obj *elt = Tcl_NewStringObj(":", 1);
d608 2
a609 3
	    Tcl_AppendToObj(elt, path, end - start);
	    Tcl_ListObjAppendElement(NULL, result, elt);
	    return result;
d632 1
d642 1
d653 1
d658 2
a659 1
	 * Append the element and terminate it with a : 
d662 2
a663 3
	nextElt = Tcl_NewStringObj(start, length);
	Tcl_AppendToObj(nextElt, ":", 1);
	Tcl_ListObjAppendElement(NULL, result, nextElt);
a668 28
#else
    if ((path[0] != ':') && (path[0] == '~' || (strchr(path,':') != NULL))) {
	CONST char *end;
	Tcl_Obj *nextElt;

	isMac = 1;
	
	end = strchr(path,':');
	if (end == NULL) {
	    length = strlen(path);
	} else {
	    length = end - path;
	}

	/*
	 * Append the element and terminate it with a :
	 */

	nextElt = Tcl_NewStringObj(path, length);
	Tcl_AppendToObj(nextElt, ":", 1);
	Tcl_ListObjAppendElement(NULL, result, nextElt);
	p = path + length;
    } else {
	isMac = (strchr(path, ':') != NULL);
	isMac = 1;
	p = path;
    }
#endif
a674 3
	 * (This is no longer true if MAC_UNDERSTANDS_UNIX_PATHS 
	 * is false, so we must check whether 'p' points to the
	 * end of the string.)
d676 2
a677 5
	elementStart = p;
	if (*p == ':') {
	    p++;
	}
	
d682 1
a682 2
		    Tcl_ListObjAppendElement(NULL, result,
			    Tcl_NewStringObj("::", 2));
d695 2
a696 2
		Tcl_ListObjAppendElement(NULL, result, 
			Tcl_NewStringObj(elementStart, length));
d700 2
a701 8
	if (elementStart[0] != ':') {
	    if (elementStart[0] != '\0') {
		Tcl_ListObjAppendElement(NULL, result, 
			Tcl_NewStringObj(elementStart, -1));
	    }
	} else {
	    if (elementStart[1] != '\0' || elementStart == path) {
		if ((elementStart[1] != '~') && (elementStart[1] != '\0')
a703 3
		}
		Tcl_ListObjAppendElement(NULL, result, 
			Tcl_NewStringObj(elementStart, -1));
d705 2
d722 1
a722 2
		    Tcl_ListObjAppendElement(NULL, result, 
					     Tcl_NewStringObj(":", 1));
d725 1
a725 2
		    Tcl_ListObjAppendElement(NULL, result, 
					     Tcl_NewStringObj("::", 2));
a726 1
		    Tcl_Obj *nextElt;
d728 1
a728 4
			nextElt = Tcl_NewStringObj(":",1);
			Tcl_AppendToObj(nextElt, elementStart, length);
		    } else {
			nextElt = Tcl_NewStringObj(elementStart, length);
d730 2
a731 1
		    Tcl_ListObjAppendElement(NULL, result, nextElt);
d739 1
a739 1
    return result;
d743 1
a743 1
 *---------------------------------------------------------------------------
d745 1
a745 1
 * Tcl_FSJoinToPath --
d747 1
a747 3
 *      This function takes the given object, which should usually be a
 *      valid path or NULL, and joins onto it the array of paths
 *      segments given.
d750 3
a752 1
 *      Returns object with refCount of zero
d755 1
a755 1
 *	None.
d757 1
a757 1
 *---------------------------------------------------------------------------
d760 5
a764 5
Tcl_Obj* 
Tcl_FSJoinToPath(basePtr, objc, objv)
    Tcl_Obj *basePtr;
    int objc;
    Tcl_Obj *CONST objv[];
d766 8
a773 2
    int i;
    Tcl_Obj *lobj, *ret;
d775 10
a784 29
    if (basePtr == NULL) {
	lobj = Tcl_NewListObj(0, NULL);
    } else {
	lobj = Tcl_NewListObj(1, &basePtr);
    }
    
    for (i = 0; i<objc;i++) {
	Tcl_ListObjAppendElement(NULL, lobj, objv[i]);
    }
    ret = Tcl_FSJoinPath(lobj, -1);
    Tcl_DecrRefCount(lobj);
    return ret;
}

/*
 *---------------------------------------------------------------------------
 *
 * TclpNativeJoinPath --
 *
 *      'prefix' is absolute, 'joining' is relative to prefix.
 *
 * Results:
 *      modifies prefix
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
 */
d786 25
a810 9
void
TclpNativeJoinPath(prefix, joining)
    Tcl_Obj *prefix;
    char* joining;
{
    int length, needsSep;
    char *dest, *p, *start;
    
    start = Tcl_GetStringFromObj(prefix, &length);
d812 3
a814 16
    /*
     * Remove the ./ from tilde prefixed elements unless
     * it is the first component.
     */
    
    p = joining;
    
    if (length != 0) {
	if ((p[0] == '.') && (p[1] == '/') && (p[2] == '~')) {
	    p += 2;
	}
    }
       
    if (*p == '\0') {
	return;
    }
d816 3
d820 6
a825 5
    switch (tclPlatform) {
        case TCL_PLATFORM_UNIX:
	    /*
	     * Append a separator if needed.
	     */
d827 4
a830 10
	    if (length > 0 && (start[length-1] != '/')) {
		Tcl_AppendToObj(prefix, "/", 1);
		length++;
	    }
	    needsSep = 0;
	    
	    /*
	     * Append the element, eliminating duplicate and trailing
	     * slashes.
	     */
d832 8
a839 10
	    Tcl_SetObjLength(prefix, length + (int) strlen(p));
	    
	    dest = Tcl_GetString(prefix) + length;
	    for (; *p != '\0'; p++) {
		if (*p == '/') {
		    while (p[1] == '/') {
			p++;
		    }
		    if (p[1] != '\0') {
			if (needsSep) {
d842 2
a844 3
		} else {
		    *dest++ = *p;
		    needsSep = 1;
d846 2
a848 2
	    length = dest - Tcl_GetString(prefix);
	    Tcl_SetObjLength(prefix, length);
d853 3
a855 1
	     * Check to see if we need to append a separator.
d858 14
a871 11
	    if ((length > 0) && 
		(start[length-1] != '/') && (start[length-1] != ':')) {
		Tcl_AppendToObj(prefix, "/", 1);
		length++;
	    }
	    needsSep = 0;
	    
	    /*
	     * Append the element, eliminating duplicate and
	     * trailing slashes.
	     */
d873 8
a880 6
	    Tcl_SetObjLength(prefix, length + (int) strlen(p));
	    dest = Tcl_GetString(prefix) + length;
	    for (; *p != '\0'; p++) {
		if ((*p == '/') || (*p == '\\')) {
		    while ((p[1] == '/') || (p[1] == '\\')) {
			p++;
a881 6
		    if ((p[1] != '\0') && needsSep) {
			*dest++ = '/';
		    }
		} else {
		    *dest++ = *p;
		    needsSep = 1;
a882 4
	    }
	    length = dest - Tcl_GetString(prefix);
	    Tcl_SetObjLength(prefix, length);
	    break;
d884 4
a887 11
	case TCL_PLATFORM_MAC: {
	    int newLength;
	    
	    /*
	     * Sort out separators.  We basically add the object we've
	     * been given, but we have to make sure that there is
	     * exactly one separator inbetween (unless the object we're
	     * adding contains multiple contiguous colons, all of which
	     * we must add).  Also if an object is just ':' we don't
	     * bother to add it unless it's the very first element.
	     */
d889 6
a894 8
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
	    int adjustedPath = 0;
	    if ((strchr(p, ':') == NULL) && (strchr(p, '/') != NULL)) {
		char *start = p;
		adjustedPath = 1;
		while (*start != '\0') {
		    if (*start == '/') {
		        *start = ':';
d896 20
a915 12
		    start++;
		}
	    }
#endif
	    if (length > 0) {
		if ((p[0] == ':') && (p[1] == '\0')) {
		    return;
		}
		if (start[length-1] != ':') {
		    if (*p != '\0' && *p != ':') {
			Tcl_AppendToObj(prefix, ":", 1);
			length++;
d917 2
a918 7
		} else if (*p == ':') {
		    p++;
		}
	    } else {
		if (*p != '\0' && *p != ':') {
		    Tcl_AppendToObj(prefix, ":", 1);
		    length++;
d921 1
a921 4
	    
	    /*
	     * Append the element
	     */
d923 12
a934 15
	    newLength = strlen(p);
	    /* 
	     * It may not be good to just do 'Tcl_AppendToObj(prefix,
	     * p, newLength)' because the object may contain duplicate
	     * colons which we want to get rid of.
	     */
	    Tcl_AppendToObj(prefix, p, newLength);
	    
	    /* Remove spurious trailing single ':' */
	    dest = Tcl_GetString(prefix) + length + newLength;
	    if (*(dest-1) == ':') {
		if (dest-1 > Tcl_GetString(prefix)) {
		    if (*(dest-2) != ':') {
		        Tcl_SetObjLength(prefix, length + newLength -1);
		    }
d936 27
a962 8
	    }
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
	    /* Revert the path to what it was */
	    if (adjustedPath) {
		char *start = joining;
		while (*start != '\0') {
		    if (*start == ':') {
			*start = '/';
d964 2
a965 1
		    start++;
a967 1
#endif
d969 1
a969 1
	}
d971 1
a971 52
    return;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_JoinPath --
 *
 *	Combine a list of paths in a platform specific manner.  The
 *	function 'Tcl_FSJoinPath' should be used in preference where
 *	possible.
 *
 * Results:
 *	Appends the joined path to the end of the specified 
 *	Tcl_DString returning a pointer to the resulting string.  Note
 *	that the Tcl_DString must already be initialized.
 *
 * Side effects:
 *	Modifies the Tcl_DString.
 *
 *----------------------------------------------------------------------
 */

char *
Tcl_JoinPath(argc, argv, resultPtr)
    int argc;
    CONST char * CONST *argv;
    Tcl_DString *resultPtr;	/* Pointer to previously initialized DString */
{
    int i, len;
    Tcl_Obj *listObj = Tcl_NewObj();
    Tcl_Obj *resultObj;
    char *resultStr;

    /* Build the list of paths */
    for (i = 0; i < argc; i++) {
        Tcl_ListObjAppendElement(NULL, listObj,
		Tcl_NewStringObj(argv[i], -1));
    }

    /* Ask the objectified code to join the paths */
    Tcl_IncrRefCount(listObj);
    resultObj = Tcl_FSJoinPath(listObj, argc);
    Tcl_IncrRefCount(resultObj);
    Tcl_DecrRefCount(listObj);

    /* Store the result */
    resultStr = Tcl_GetStringFromObj(resultObj, &len);
    Tcl_DStringAppend(resultPtr, resultStr, len);
    Tcl_DecrRefCount(resultObj);

    /* Return a pointer to the result */
d1005 1
a1005 1
    CONST char *name;		/* File name, which may begin with "~" (to
d1012 17
a1028 2
    Tcl_Obj *path = Tcl_NewStringObj(name, -1);
    CONST char *result;
d1030 20
a1049 9
    Tcl_IncrRefCount(path);
    result = Tcl_FSGetTranslatedStringPath(interp, path);
    if (result == NULL) {
	Tcl_DecrRefCount(path);
	return NULL;
    }
    Tcl_DStringInit(bufferPtr);
    Tcl_DStringAppend(bufferPtr, result, -1);
    Tcl_DecrRefCount(path);
d1056 1
a1057 1
	register char *p;
d1064 1
a1102 1
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
a1107 3
#else
	    lastSep = strrchr(name, ':');
#endif
d1120 2
a1121 1
    if ((p != NULL) && (lastSep != NULL) && (lastSep > p)) {
d1157 1
a1157 1
static CONST char *
d1166 1
a1166 1
    CONST char *dir;
d1192 1
a1192 1
    return Tcl_DStringValue(resultPtr);
d1220 2
a1221 2
    int index, i, globFlags, length, join, dir, result;
    char *string, *separators;
d1223 3
a1225 5
    Tcl_Obj *pathOrDir = NULL;
    Tcl_DString prefix;
    static CONST char *options[] = {
	"-directory", "-join", "-nocomplain", "-path", "-tails", 
	"-types", "--", NULL
d1228 1
a1228 2
	GLOB_DIR, GLOB_JOIN, GLOB_NOCOMPLAIN, GLOB_PATH, GLOB_TAILS, 
	GLOB_TYPE, GLOB_LAST
d1231 1
a1231 1
    Tcl_GlobTypeData *globTypes = NULL;
d1236 1
d1260 1
a1260 1
	        globFlags |= TCL_GLOBMODE_NO_COMPLAIN;
d1268 1
a1268 1
		if (dir != PATH_NONE) {
d1275 2
a1276 2
		globFlags |= TCL_GLOBMODE_DIR;
		pathOrDir = objv[i+1];
a1281 3
	    case GLOB_TAILS:				/* -tails */
	        globFlags |= TCL_GLOBMODE_TAILS;
		break;
d1288 1
a1288 1
		if (dir != PATH_NONE) {
d1295 1
a1295 1
		pathOrDir = objv[i+1];
d1321 1
a1321 7
    if ((globFlags & TCL_GLOBMODE_TAILS) && (pathOrDir == NULL)) {
	Tcl_AppendToObj(resultPtr,
	  "\"-tails\" must be used with either \"-directory\" or \"-path\"",
	  -1);
	return TCL_ERROR;
    }
    
a1334 1
	int pathlength;
a1335 1
	char *first = Tcl_GetStringFromObj(pathOrDir,&pathlength);
d1340 2
a1341 2
	last = first + pathlength;
	for (; last != first; last--) {
d1346 1
a1346 1
	if (last == first + pathlength) {
d1348 1
a1348 1
	    dir = PATH_DIR;
d1353 2
a1354 1
	    if (last == first) {
d1356 1
a1356 1
		Tcl_DStringAppend(&pref, first, -1);
d1360 3
a1362 2
		Tcl_DStringAppend(&pref, last, first+pathlength-last);
		pathOrDir = Tcl_NewStringObj(first, last-first-1);
d1382 1
a1382 5
    
    if (pathOrDir != NULL) {
	Tcl_IncrRefCount(pathOrDir);
    }
    
d1390 1
a1390 1
	globTypes = (Tcl_GlobTypeData*) ckalloc(sizeof(Tcl_GlobTypeData));
d1473 1
a1473 4
		 * Error cases.  We re-get the interpreter's result,
		 * just to be sure it hasn't changed, and we reset
		 * the 'join' flag to zero, since we haven't yet
		 * made use of it.
a1475 1
		resultPtr = Tcl_GetObjResult(interp);
a1478 1
		join = 0;
a1480 1
		resultPtr = Tcl_GetObjResult(interp);
d1482 1
a1482 2
		   "only one MacOS type or creator argument"
		   " to \"-types\" allowed", -1);
a1483 1
		join = 0;
d1549 1
a1549 1
    if ((globFlags & TCL_GLOBMODE_NO_COMPLAIN) == 0) {
d1577 3
a1579 3
    }
    if (pathOrDir != NULL) {
	Tcl_DecrRefCount(pathOrDir);
a1600 5
 *      
 *      The interpreter's result, on entry to this function, must
 *      be a valid Tcl list (e.g. it could be empty), since we will
 *      lappend any new results to that list.  If it is not a valid
 *      list, this function will fail to do anything very meaningful.
d1606 2
a1607 5
 *	given by the pattern and unquotedPrefix arguments.  After an 
 *	error the result in interp will hold an error message, unless
 *	the 'TCL_GLOBMODE_NO_COMPLAIN' flag was given, in which case
 *	an error results in a TCL_OK return leaving the interpreter's
 *	result unmodified.
d1610 1
a1610 1
 *	The 'pattern' is written to.
d1622 2
a1623 2
    Tcl_Obj *unquotedPrefix;	/* Prefix to glob pattern, if non-null, which
                             	 * is considered literally. */
d1625 1
a1625 1
    Tcl_GlobTypeData *types;	/* Struct containing acceptable types.
d1629 1
a1629 2
    CONST char *head;
    char *tail, *start;
d1631 1
a1631 1
    int result, prefixLen;
a1632 1
    Tcl_Obj *oldResult;
a1642 1
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
a1647 3
#else
	    separators = ":";
#endif
d1653 1
a1653 1
	start = Tcl_GetString(unquotedPrefix);
d1678 2
a1679 1
	 * Determine the home directory for the specified user.  
d1684 11
a1694 6
	if (globFlags & TCL_GLOBMODE_NO_COMPLAIN) {
	    /* 
	     * We will ignore any error message here, and we
	     * don't want to mess up the interpreter's result.
	     */
	    head = DoTildeSubst(NULL, start+1, &buffer);
d1696 6
a1701 1
	    head = DoTildeSubst(interp, start+1, &buffer);
d1703 1
d1706 10
a1715 1
	    if (globFlags & TCL_GLOBMODE_NO_COMPLAIN) {
d1731 1
a1731 1
	    Tcl_DStringAppend(&buffer,Tcl_GetString(unquotedPrefix),-1);
a1733 1
    
d1735 7
a1741 15
     * We want to remember the length of the current prefix,
     * in case we are using TCL_GLOBMODE_TAILS.  Also if we
     * are using TCL_GLOBMODE_DIR, we must make sure the
     * prefix ends in a directory separator.
     */
    prefixLen = Tcl_DStringLength(&buffer);

    if (prefixLen > 0) {
	c = Tcl_DStringValue(&buffer)[prefixLen-1];
	if (strchr(separators, c) == NULL) {
	    /* 
	     * If the prefix is a directory, make sure it ends in a
	     * directory separator.
	     */
	    if (globFlags & TCL_GLOBMODE_DIR) {
a1743 1
	    prefixLen++;
a1746 8
    /* 
     * We need to get the old result, in case it is over-written
     * below when we still need it.
     */
    oldResult = Tcl_GetObjResult(interp);
    Tcl_IncrRefCount(oldResult);
    Tcl_ResetResult(interp);
    
d1748 1
a1748 1
    
d1750 3
a1752 61
	if (globFlags & TCL_GLOBMODE_NO_COMPLAIN) {
	    /* Put back the old result and reset the return code */
	    Tcl_SetObjResult(interp, oldResult);
	    result = TCL_OK;
	}
    } else {
	/* 
	 * Now we must concatenate the 'oldResult' and the current
	 * result, and then place that into the interpreter.
	 * 
	 * If we only want the tails, we must strip off the prefix now.
	 * It may seem more efficient to pass the tails flag down into
	 * TclDoGlob, Tcl_FSMatchInDirectory, but those functions are
	 * continually adjusting the prefix as the various pieces of
	 * the pattern are assimilated, so that would add a lot of
	 * complexity to the code.  This way is a little slower (when
	 * the -tails flag is given), but much simpler to code.
	 */
	int objc, i;
	Tcl_Obj **objv;

	/* Ensure sole ownership */
	if (Tcl_IsShared(oldResult)) {
	    Tcl_DecrRefCount(oldResult);
	    oldResult = Tcl_DuplicateObj(oldResult);
	    Tcl_IncrRefCount(oldResult);
	}

	Tcl_ListObjGetElements(NULL, Tcl_GetObjResult(interp), 
			       &objc, &objv);
#ifdef MAC_TCL
	/* adjust prefixLen if TclDoGlob prepended a ':' */
	if ((prefixLen > 0) && (objc > 0)
	&& (Tcl_DStringValue(&buffer)[0] != ':')) {
	    char *str = Tcl_GetStringFromObj(objv[0],NULL);
	    if (str[0] == ':') {
		    prefixLen++;
	    }
	}
#endif
	for (i = 0; i< objc; i++) {
	    Tcl_Obj* elt;
	    if (globFlags & TCL_GLOBMODE_TAILS) {
		int len;
		char *oldStr = Tcl_GetStringFromObj(objv[i],&len);
		if (len == prefixLen) {
		    if ((pattern[0] == '\0')
			|| (strchr(separators, pattern[0]) == NULL)) {
			elt = Tcl_NewStringObj(".",1);
		    } else {
			elt = Tcl_NewStringObj("/",1);
		    }
		} else {
		    elt = Tcl_NewStringObj(oldStr + prefixLen, 
						len - prefixLen);
		}
	    } else {
		elt = objv[i];
	    }
	    /* Assumption that 'oldResult' is a valid list */
	    Tcl_ListObjAppendElement(interp, oldResult, elt);
a1753 1
	Tcl_SetObjResult(interp, oldResult);
a1754 6
    /* 
     * Release our temporary copy.  All code paths above must
     * end here so we free our reference.
     */
    Tcl_DecrRefCount(oldResult);
    Tcl_DStringFree(&buffer);
d1847 2
a1848 2
    Tcl_GlobTypeData *types;	/* List object containing list of acceptable 
                            	 * types. May be NULL. */
a1884 1
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
a1890 1
#endif
a1902 1
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
a1903 1
#endif
d2005 2
a2006 2
	    result = TclDoGlob(interp, separators, headPtr, 
			       Tcl_DStringValue(&newName), types);
d2031 4
a2034 4
	savedChar = *p;
	*p = '\0';
	firstSpecialChar = strpbrk(tail, "*[]?\\");
	*p = savedChar;
a2039 3
	int ret;
	Tcl_Obj *head = Tcl_NewStringObj(Tcl_DStringValue(headPtr),-1);
	Tcl_IncrRefCount(head);
d2041 5
a2045 4
	 * Look for matching files in the given directory.  The
	 * implementation of this function is platform specific.  For
	 * each file that matches, it will add the match onto the
	 * resultPtr given.
a2046 5
	if (*p == '\0') {
	    ret = Tcl_FSMatchInDirectory(interp, Tcl_GetObjResult(interp), 
					 head, tail, types);
	} else {
	    Tcl_Obj* resultPtr;
d2048 1
a2048 40
	    /* 
	     * We do the recursion ourselves.  This makes implementing
	     * Tcl_FSMatchInDirectory for each filesystem much easier.
	     */
	    Tcl_GlobTypeData dirOnly = { TCL_GLOB_TYPE_DIR, 0, NULL, NULL };
	    char save = *p;
	    
	    *p = '\0';
	    resultPtr = Tcl_NewListObj(0, NULL);
	    ret = Tcl_FSMatchInDirectory(interp, resultPtr, 
					 head, tail, &dirOnly);
	    *p = save;
	    if (ret == TCL_OK) {
		int resLength;
		ret = Tcl_ListObjLength(interp, resultPtr, &resLength);
		if (ret == TCL_OK) {
		    int i;
		    for (i =0; i< resLength; i++) {
			Tcl_Obj *elt;
			Tcl_DString ds;
			Tcl_ListObjIndex(interp, resultPtr, i, &elt);
			Tcl_DStringInit(&ds);
			Tcl_DStringAppend(&ds, Tcl_GetString(elt), -1);
			if(tclPlatform == TCL_PLATFORM_MAC) {
			    Tcl_DStringAppend(&ds, ":",1);
			} else {			
			    Tcl_DStringAppend(&ds, "/",1);
			}
			ret = TclDoGlob(interp, separators, &ds, p+1, types);
			Tcl_DStringFree(&ds);
			if (ret != TCL_OK) {
			    break;
			}
		    }
		}
	    }
	    Tcl_DecrRefCount(resultPtr);
	}
	Tcl_DecrRefCount(head);
	return ret;
d2053 7
a2059 12
    } else {
	/*
	 * This is the code path reached by a command like 'glob foo'.
	 *
	 * There are no more wildcards in the pattern and no more
	 * unprocessed characters in the tail, so now we can construct
	 * the path, and pass it to Tcl_FSMatchInDirectory with an
	 * empty pattern to verify the existence of the file and check
	 * it is of the correct type (if a 'types' flag it given -- if
	 * no such flag was given, we could just use 'Tcl_FSLStat', but
	 * for simplicity we keep to a common approach).
	 */
d2061 13
a2073 8
	Tcl_Obj *nameObj;
	/* Used to deal with one special case pertinent to MacOS */
	int macSpecialCase = 0;

	switch (tclPlatform) {
	    case TCL_PLATFORM_MAC: {
		if (strchr(Tcl_DStringValue(headPtr), ':') == NULL) {
		    Tcl_DStringAppend(headPtr, ":", 1);
a2074 2
		macSpecialCase = 1;
		break;
d2076 18
a2093 8
	    case TCL_PLATFORM_WINDOWS: {
		if (Tcl_DStringLength(headPtr) == 0) {
		    if (((*name == '\\') && (name[1] == '/' || name[1] == '\\'))
			    || (*name == '/')) {
			Tcl_DStringAppend(headPtr, "\\", 1);
		    } else {
			Tcl_DStringAppend(headPtr, ".", 1);
		    }
d2095 1
a2095 6
		/* 
		 * Convert to forward slashes.  This is required to pass
		 * some Tcl tests.  We should probably remove the conversions
		 * here and in tclWinFile.c, since they aren't needed since
		 * the dropping of support for Win32s.
		 */
d2097 2
a2098 2
		    if (*p == '\\') {
			*p = '/';
a2100 1
		break;
d2102 7
a2108 7
	    case TCL_PLATFORM_UNIX: {
		if (Tcl_DStringLength(headPtr) == 0) {
		    if ((*name == '\\' && name[1] == '/') || (*name == '/')) {
			Tcl_DStringAppend(headPtr, "/", 1);
		    } else {
			Tcl_DStringAppend(headPtr, ".", 1);
		    }
a2109 1
		break;
d2111 5
d2117 14
a2130 54
	/* Common for all platforms */
	name = Tcl_DStringValue(headPtr);
	nameObj = Tcl_NewStringObj(name, Tcl_DStringLength(headPtr));

	Tcl_IncrRefCount(nameObj);
	Tcl_FSMatchInDirectory(interp, Tcl_GetObjResult(interp), nameObj, 
			       NULL, types);
	Tcl_DecrRefCount(nameObj);
	return TCL_OK;
    }
}


/*
 *---------------------------------------------------------------------------
 *
 * TclFileDirname
 *
 *	This procedure calculates the directory above a given 
 *	path: basically 'file dirname'.  It is used both by
 *	the 'dirname' subcommand of file and by code in tclIOUtil.c.
 *
 * Results:
 *	NULL if an error occurred, otherwise a Tcl_Obj owned by
 *	the caller (i.e. most likely with refCount 1).
 *
 * Side effects:
 *      None.
 *
 *---------------------------------------------------------------------------
 */

Tcl_Obj*
TclFileDirname(interp, pathPtr)
    Tcl_Interp *interp;		/* Used for error reporting */
    Tcl_Obj *pathPtr;           /* Path to take dirname of */
{
    int splitElements;
    Tcl_Obj *splitPtr;
    Tcl_Obj *splitResultPtr = NULL;

    /* 
     * The behaviour we want here is slightly different to
     * the standard Tcl_FSSplitPath in the handling of home
     * directories; Tcl_FSSplitPath preserves the "~" while 
     * this code computes the actual full path name, if we
     * had just a single component.
     */	    
    splitPtr = Tcl_FSSplitPath(pathPtr, &splitElements);
    if ((splitElements == 1) && (Tcl_GetString(pathPtr)[0] == '~')) {
	Tcl_DecrRefCount(splitPtr);
	splitPtr = Tcl_FSGetNormalizedPath(interp, pathPtr);
	if (splitPtr == NULL) {
	    return NULL;
a2131 1
	splitPtr = Tcl_FSSplitPath(splitPtr, &splitElements);
d2134 1
a2134 18
    /*
     * Return all but the last component.  If there is only one
     * component, return it if the path was non-relative, otherwise
     * return the current directory.
     */

    if (splitElements > 1) {
	splitResultPtr = Tcl_FSJoinPath(splitPtr, splitElements - 1);
    } else if (splitElements == 0 || 
      (Tcl_FSGetPathType(pathPtr) == TCL_PATH_RELATIVE)) {
	splitResultPtr = Tcl_NewStringObj(
		((tclPlatform == TCL_PLATFORM_MAC) ? ":" : "."), 1);
    } else {
	Tcl_ListObjIndex(NULL, splitPtr, 0, &splitResultPtr);
    }
    Tcl_IncrRefCount(splitResultPtr);
    Tcl_DecrRefCount(splitPtr);
    return splitResultPtr;
a2135 19

/*
 *---------------------------------------------------------------------------
 *
 * Tcl_AllocStatBuf
 *
 *     This procedure allocates a Tcl_StatBuf on the heap.  It exists
 *     so that extensions may be used unchanged on systems where
 *     largefile support is optional.
 *
 * Results:
 *     A pointer to a Tcl_StatBuf which may be deallocated by being
 *     passed to ckfree().
 *
 * Side effects:
 *      None.
 *
 *---------------------------------------------------------------------------
 */
a2136 4
Tcl_StatBuf *
Tcl_AllocStatBuf() {
    return (Tcl_StatBuf *) ckalloc(sizeof(Tcl_StatBuf));
}
@


1.6
log
@touched all Tcl files to ease next import.
@
text
@@


1.6.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.6.16.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d20 4
a23 4
/* 
 * This define is used to activate Tcl's interpretation of Unix-style
 * paths (containing forward slashes, '.' and '..') on MacOS.  A 
 * side-effect of this is that some paths become ambiguous.
a24 1
#define MAC_UNDERSTANDS_UNIX_PATHS
d26 2
a27 1
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
d31 1
a31 10
 * Unix-style paths, and Mac paths.  The various subexpressions in this
 * can be summarised as follows: ^(/..|~user/unix|~user:mac|/unix|mac:dir).
 * The subexpression indices which match the root portions, are as follows:
 * 
 * degenerate unix-style: 2
 * unix-tilde: 5
 * mac-tilde: 7
 * unix-style: 9 (or 10 to cut off the irrelevant header).
 * mac: 12
 * 
a47 5
static void		FileNameCleanup _ANSI_ARGS_((ClientData clientData));
static void		FileNameInit _ANSI_ARGS_((void));

#endif

d56 9
d68 1
a68 1
static CONST char *	DoTildeSubst _ANSI_ARGS_((Tcl_Interp *interp,
d71 3
a73 2
			    Tcl_DString *resultPtr, int offset, 
			    Tcl_PathType *typePtr));
d76 6
a81 4
static Tcl_Obj*		SplitMacPath _ANSI_ARGS_((CONST char *path));
static Tcl_Obj*		SplitWinPath _ANSI_ARGS_((CONST char *path));
static Tcl_Obj*		SplitUnixPath _ANSI_ARGS_((CONST char *path));
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
a134 1
#endif
d164 3
d169 1
a169 1
	CONST char *host, *share, *tail;
d176 2
a177 2
	}
	host = &path[2];
d179 1
a179 1
	/* Skip separators */
a186 12
	    /* 
	     * The path given is simply of the form 
	     * '/foo', '//foo', '/////foo' or the same
	     * with backslashes.  If there is exactly
	     * one leading '/' the path is volume relative
	     * (see filename man page).  If there are more
	     * than one, we are simply assuming they
	     * are superfluous and we trim them away.
	     * (An alternative interpretation would
	     * be that it is a host name, but we have
	     * been documented that that is not the case).
	     */
d194 1
a194 1
	/* Skip separators */
d208 1
a208 1
	/* Skip separators */
d213 1
a213 1
    } else if (*path && path[1] == ':') {
d221 1
a221 1
	} else {
d224 2
a225 2
	    /* Skip separators */
	    while (*tail && (tail[0] == '/' || tail[0] == '\\')) tail++;
d229 1
a229 1
	    Tcl_DStringAppend(resultPtr, "/", 1);
d231 1
a231 1
	    return tail;
a245 4
 *	
 *	The objectified Tcl_FSGetPathType should be used in
 *	preference to this function (as you can see below, this
 *	is just a wrapper around that other function).
d259 1
a259 1
    CONST char *path;
d261 9
a269 29
    Tcl_PathType type;
    Tcl_Obj *tempObj = Tcl_NewStringObj(path,-1);
    Tcl_IncrRefCount(tempObj);
    type = Tcl_FSGetPathType(tempObj);
    Tcl_DecrRefCount(tempObj);
    return type;
}

/*
 *----------------------------------------------------------------------
 *
 * TclpGetNativePathType --
 *
 *	Determines whether a given path is relative to the current
 *	directory, relative to the current volume, or absolute, but
 *	ONLY FOR THE NATIVE FILESYSTEM. This function is called from
 *	tclIOUtil.c (but needs to be here due to its dependence on
 *	static variables/functions in this file).  The exported
 *	function Tcl_FSGetPathType should be used by extensions.
 *
 * Results:
 *	Returns one of TCL_PATH_ABSOLUTE, TCL_PATH_RELATIVE, or
 *	TCL_PATH_VOLUME_RELATIVE.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
d271 2
a272 19
Tcl_PathType
TclpGetNativePathType(pathObjPtr, driveNameLengthPtr, driveNameRef)
    Tcl_Obj *pathObjPtr;
    int *driveNameLengthPtr;
    Tcl_Obj **driveNameRef;
{
    Tcl_PathType type = TCL_PATH_ABSOLUTE;
    int pathLen;
    char *path = Tcl_GetStringFromObj(pathObjPtr, &pathLen);
    
    if (path[0] == '~') {
	/* 
	 * This case is common to all platforms.
	 * Paths that begin with ~ are absolute.
	 */
	if (driveNameLengthPtr != NULL) {
	    char *end = path + 1;
	    while ((*end != '\0') && (*end != '/')) {
		end++;
d274 8
a281 7
	    *driveNameLengthPtr = end - path;
	}
    } else {
	switch (tclPlatform) {
	    case TCL_PLATFORM_UNIX: {
		char *origPath = path;
	        
d283 2
a284 1
		 * Paths that begin with / are absolute.
d287 5
a291 27
#ifdef __QNX__
		/*
		 * Check for QNX //<node id> prefix
		 */
		if (*path && (pathLen > 3) && (path[0] == '/') 
		  && (path[1] == '/') && isdigit(UCHAR(path[2]))) {
		    path += 3;
		    while (isdigit(UCHAR(*path))) {
			++path;
		    }
		}
#endif
		if (path[0] == '/') {
		    if (driveNameLengthPtr != NULL) {
			/* 
			 * We need this addition in case the QNX code 
			 * was used 
			 */
			*driveNameLengthPtr = (1 + path - origPath);
		    }
		} else {
		    type = TCL_PATH_RELATIVE;
		}
		break;
	    }
	    case TCL_PLATFORM_MAC:
		if (path[0] == ':') {
d294 1
a294 10
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
		    ThreadSpecificData *tsdPtr;
		    Tcl_RegExp re;

		    tsdPtr = TCL_TSD_INIT(&dataKey);

		    /*
		     * Since we have eliminated the easy cases, use the
		     * root pattern to look for the other types.
		     */
d296 2
a297 5
		    FileNameInit();
		    re = Tcl_GetRegExpFromObj(NULL, tsdPtr->macRootPatternPtr,
			    REG_ADVANCED);

		    if (!Tcl_RegExpExec(NULL, re, path, path)) {
a298 56
		    } else {
			CONST char *root, *end;
			Tcl_RegExpRange(re, 2, &root, &end);
			if (root != NULL) {
			    type = TCL_PATH_RELATIVE;
			} else {
			    if (driveNameLengthPtr != NULL) {
				Tcl_RegExpRange(re, 0, &root, &end);
				*driveNameLengthPtr = end - root;
			    }
			    if (driveNameRef != NULL) {
				if (*root == '/') {
				    char *c;
				    int gotColon = 0;
				    *driveNameRef = Tcl_NewStringObj(root + 1,
					    end - root -1);
				    c = Tcl_GetString(*driveNameRef);
				    while (*c != '\0') {
					if (*c == '/') {
					    gotColon++;
					    *c = ':';
					}
					c++;
				    }
				    /* 
				     * If there is no colon, we have just a
				     * volume name so we must add a colon so
				     * it is an absolute path.
				     */
				    if (gotColon == 0) {
				        Tcl_AppendToObj(*driveNameRef, ":", 1);
				    } else if ((gotColon > 1) &&
					    (*(c-1) == ':')) {
					/* We have an extra colon */
				        Tcl_SetObjLength(*driveNameRef, 
					  c - Tcl_GetString(*driveNameRef) - 1);
				    }
				}
			    }
			}
		    }
#else
		    if (path[0] == '~') {
		    } else if (path[0] == ':') {
			type = TCL_PATH_RELATIVE;
		    } else {
			char *colonPos = strchr(path,':');
			if (colonPos == NULL) {
			    type = TCL_PATH_RELATIVE;
			} else {
			}
		    }
		    if (type == TCL_PATH_ABSOLUTE) {
			if (driveNameLengthPtr != NULL) {
			    *driveNameLengthPtr = strlen(path);
			}
a299 1
#endif
d301 5
a305 3
		break;
	    
	    case TCL_PLATFORM_WINDOWS: {
d307 1
a307 2
		CONST char *rootEnd;
		
d309 1
a309 9
		rootEnd = ExtractWinRoot(path, &ds, 0, &type);
		if ((rootEnd != path) && (driveNameLengthPtr != NULL)) {
		    *driveNameLengthPtr = rootEnd - path;
		    if (driveNameRef != NULL) {
			*driveNameRef = Tcl_NewStringObj(Tcl_DStringValue(&ds),
				Tcl_DStringLength(&ds));
			Tcl_IncrRefCount(*driveNameRef);
		    }
		}
a310 1
		break;
d312 1
a312 1
	}
a317 59
 *---------------------------------------------------------------------------
 *
 * TclpNativeSplitPath --
 *
 *      This function takes the given Tcl_Obj, which should be a valid
 *      path, and returns a Tcl List object containing each segment
 *      of that path as an element.
 *
 *      Note this function currently calls the older Split(Plat)Path
 *      functions, which require more memory allocation than is
 *      desirable.
 *      
 * Results:
 *      Returns list object with refCount of zero.  If the passed in
 *      lenPtr is non-NULL, we use it to return the number of elements
 *      in the returned list.
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
 */

Tcl_Obj* 
TclpNativeSplitPath(pathPtr, lenPtr)
    Tcl_Obj *pathPtr;		/* Path to split. */
    int *lenPtr;		/* int to store number of path elements. */
{
    Tcl_Obj *resultPtr = NULL;  /* Needed only to prevent gcc warnings. */

    /*
     * Perform platform specific splitting. 
     */

    switch (tclPlatform) {
	case TCL_PLATFORM_UNIX:
	    resultPtr = SplitUnixPath(Tcl_GetString(pathPtr));
	    break;

	case TCL_PLATFORM_WINDOWS:
	    resultPtr = SplitWinPath(Tcl_GetString(pathPtr));
	    break;
	    
	case TCL_PLATFORM_MAC:
	    resultPtr = SplitMacPath(Tcl_GetString(pathPtr));
	    break;
    }

    /*
     * Compute the number of elements in the result.
     */

    if (lenPtr != NULL) {
	Tcl_ListObjLength(NULL, resultPtr, lenPtr);
    }
    return resultPtr;
}

/*
d348 1
a348 1
    CONST char ***argvPtr;	/* Pointer to place to store pointer to array
d351 5
a355 4
    Tcl_Obj *resultPtr = NULL;  /* Needed only to prevent gcc warnings. */
    Tcl_Obj *tmpPtr, *eltPtr;
    int i, size, len;
    char *p, *str;
d358 3
a360 1
     * Perform the splitting, using objectified, vfs-aware code.
d363 18
a380 4
    tmpPtr = Tcl_NewStringObj(path, -1);
    Tcl_IncrRefCount(tmpPtr);
    resultPtr = Tcl_FSSplitPath(tmpPtr, argcPtr);
    Tcl_DecrRefCount(tmpPtr);
d382 6
a387 7
    /* Calculate space required for the result */
    
    size = 1;
    for (i = 0; i < *argcPtr; i++) {
	Tcl_ListObjIndex(NULL, resultPtr, i, &eltPtr);
	Tcl_GetStringFromObj(eltPtr, &len);
	size += len + 1;
d391 2
a392 2
     * Allocate a buffer large enough to hold the contents of all of
     * the list plus the argv pointers and the terminating NULL pointer.
d395 1
a395 1
    *argvPtr = (CONST char **) ckalloc((unsigned)
d400 1
a400 1
     * the list in, piece by piece.
d404 2
a405 7
    for (i = 0; i < *argcPtr; i++) {
	Tcl_ListObjIndex(NULL, resultPtr, i, &eltPtr);
	str = Tcl_GetStringFromObj(eltPtr, &len);
	memcpy((VOID *) p, (VOID *) str, (size_t) len+1);
	p += len+1;
    }
    
a409 2
    p = (char *) &(*argvPtr)[(*argcPtr) + 1];

d416 1
a416 5
    /*
     * Free the result ptr given to us by Tcl_FSSplitPath
     */

    Tcl_DecrRefCount(resultPtr);
d424 1
a424 1
 *	This routine is used by Tcl_(FS)SplitPath to handle splitting
d428 2
a429 1
 *	Returns a newly allocated Tcl list object.
d437 2
a438 2
static Tcl_Obj*
SplitUnixPath(path)
d440 1
a443 1
    Tcl_Obj *result = Tcl_NewObj();
d463 1
a463 1
	Tcl_ListObjAppendElement(NULL, result, Tcl_NewStringObj("/",1));
a480 1
	    Tcl_Obj *nextElt;
d482 1
a482 4
		nextElt = Tcl_NewStringObj("./",2);
		Tcl_AppendToObj(nextElt, elementStart, length);
	    } else {
		nextElt = Tcl_NewStringObj(elementStart, length);
d484 2
a485 1
	    Tcl_ListObjAppendElement(NULL, result, nextElt);
d491 1
a491 1
    return result;
a492 1

d499 1
a499 1
 *	This routine is used by Tcl_(FS)SplitPath to handle splitting
d503 2
a504 1
 *	Returns a newly allocated Tcl list object.
d512 2
a513 2
static Tcl_Obj*
SplitWinPath(path)
d515 1
d520 2
a521 5
    Tcl_DString buf;
    Tcl_Obj *result = Tcl_NewObj();
    Tcl_DStringInit(&buf);
    
    p = ExtractWinRoot(path, &buf, 0, &type);
d528 1
a528 3
	Tcl_ListObjAppendElement(NULL, result, 
				 Tcl_NewStringObj(Tcl_DStringValue(&buf), 
						  Tcl_DStringLength(&buf)));
d530 1
a530 2
    Tcl_DStringFree(&buf);
    
a542 1
	    Tcl_Obj *nextElt;
d544 1
a544 4
		nextElt = Tcl_NewStringObj("./",2);
		Tcl_AppendToObj(nextElt, elementStart, length);
	    } else {
		nextElt = Tcl_NewStringObj(elementStart, length);
d546 2
a547 1
	    Tcl_ListObjAppendElement(NULL, result, nextElt);
d551 1
a551 1
    return result;
d559 1
a559 1
 *	This routine is used by Tcl_(FS)SplitPath to handle splitting
d563 1
a563 1
 *	Returns a newly allocated Tcl list object.
d571 2
a572 2
static Tcl_Obj*
SplitMacPath(path)
d574 1
d577 1
a577 1
    int length;
a578 2
    Tcl_Obj *result;
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
a579 1
    int i;
d581 1
a581 5
#endif
    
    result = Tcl_NewObj();
    
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
d597 1
a597 2
	CONST char *start, *end;
	Tcl_Obj *nextElt;
d606 1
a606 1
	    Tcl_Obj *elt = Tcl_NewStringObj(":", 1);
d608 2
a609 3
	    Tcl_AppendToObj(elt, path, end - start);
	    Tcl_ListObjAppendElement(NULL, result, elt);
	    return result;
d632 1
d642 1
d653 1
d658 2
a659 1
	 * Append the element and terminate it with a : 
d662 2
a663 3
	nextElt = Tcl_NewStringObj(start, length);
	Tcl_AppendToObj(nextElt, ":", 1);
	Tcl_ListObjAppendElement(NULL, result, nextElt);
a668 28
#else
    if ((path[0] != ':') && (path[0] == '~' || (strchr(path,':') != NULL))) {
	CONST char *end;
	Tcl_Obj *nextElt;

	isMac = 1;
	
	end = strchr(path,':');
	if (end == NULL) {
	    length = strlen(path);
	} else {
	    length = end - path;
	}

	/*
	 * Append the element and terminate it with a :
	 */

	nextElt = Tcl_NewStringObj(path, length);
	Tcl_AppendToObj(nextElt, ":", 1);
	Tcl_ListObjAppendElement(NULL, result, nextElt);
	p = path + length;
    } else {
	isMac = (strchr(path, ':') != NULL);
	isMac = 1;
	p = path;
    }
#endif
a674 3
	 * (This is no longer true if MAC_UNDERSTANDS_UNIX_PATHS 
	 * is false, so we must check whether 'p' points to the
	 * end of the string.)
d676 2
a677 5
	elementStart = p;
	if (*p == ':') {
	    p++;
	}
	
d682 1
a682 2
		    Tcl_ListObjAppendElement(NULL, result,
			    Tcl_NewStringObj("::", 2));
d695 2
a696 2
		Tcl_ListObjAppendElement(NULL, result, 
			Tcl_NewStringObj(elementStart, length));
d700 2
a701 8
	if (elementStart[0] != ':') {
	    if (elementStart[0] != '\0') {
		Tcl_ListObjAppendElement(NULL, result, 
			Tcl_NewStringObj(elementStart, -1));
	    }
	} else {
	    if (elementStart[1] != '\0' || elementStart == path) {
		if ((elementStart[1] != '~') && (elementStart[1] != '\0')
a703 3
		}
		Tcl_ListObjAppendElement(NULL, result, 
			Tcl_NewStringObj(elementStart, -1));
d705 2
d722 1
a722 2
		    Tcl_ListObjAppendElement(NULL, result, 
					     Tcl_NewStringObj(":", 1));
d725 1
a725 2
		    Tcl_ListObjAppendElement(NULL, result, 
					     Tcl_NewStringObj("::", 2));
a726 1
		    Tcl_Obj *nextElt;
d728 1
a728 4
			nextElt = Tcl_NewStringObj(":",1);
			Tcl_AppendToObj(nextElt, elementStart, length);
		    } else {
			nextElt = Tcl_NewStringObj(elementStart, length);
d730 2
a731 1
		    Tcl_ListObjAppendElement(NULL, result, nextElt);
d739 1
a739 1
    return result;
d743 1
a743 1
 *---------------------------------------------------------------------------
d745 1
a745 1
 * Tcl_FSJoinToPath --
d747 1
a747 3
 *      This function takes the given object, which should usually be a
 *      valid path or NULL, and joins onto it the array of paths
 *      segments given.
d750 3
a752 1
 *      Returns object with refCount of zero
d755 1
a755 1
 *	None.
d757 1
a757 1
 *---------------------------------------------------------------------------
d760 5
a764 5
Tcl_Obj* 
Tcl_FSJoinToPath(basePtr, objc, objv)
    Tcl_Obj *basePtr;
    int objc;
    Tcl_Obj *CONST objv[];
d766 5
a770 59
    int i;
    Tcl_Obj *lobj, *ret;

    if (basePtr == NULL) {
	lobj = Tcl_NewListObj(0, NULL);
    } else {
	lobj = Tcl_NewListObj(1, &basePtr);
    }
    
    for (i = 0; i<objc;i++) {
	Tcl_ListObjAppendElement(NULL, lobj, objv[i]);
    }
    ret = Tcl_FSJoinPath(lobj, -1);
    Tcl_DecrRefCount(lobj);
    return ret;
}

/*
 *---------------------------------------------------------------------------
 *
 * TclpNativeJoinPath --
 *
 *      'prefix' is absolute, 'joining' is relative to prefix.
 *
 * Results:
 *      modifies prefix
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
 */

void
TclpNativeJoinPath(prefix, joining)
    Tcl_Obj *prefix;
    char* joining;
{
    int length, needsSep;
    char *dest, *p, *start;
    
    start = Tcl_GetStringFromObj(prefix, &length);

    /*
     * Remove the ./ from tilde prefixed elements unless
     * it is the first component.
     */
    
    p = joining;
    
    if (length != 0) {
	if ((p[0] == '.') && (p[1] == '/') && (p[2] == '~')) {
	    p += 2;
	}
    }
       
    if (*p == '\0') {
	return;
    }
d772 2
d776 9
a784 4
        case TCL_PLATFORM_UNIX:
	    /*
	     * Append a separator if needed.
	     */
d786 12
a797 15
	    if (length > 0 && (start[length-1] != '/')) {
		Tcl_AppendToObj(prefix, "/", 1);
		length++;
	    }
	    needsSep = 0;
	    
	    /*
	     * Append the element, eliminating duplicate and trailing
	     * slashes.
	     */

	    Tcl_SetObjLength(prefix, length + (int) strlen(p));
	    
	    dest = Tcl_GetString(prefix) + length;
	    for (; *p != '\0'; p++) {
d799 3
a801 1
		    while (p[1] == '/') {
d804 10
a813 8
		    if (p[1] != '\0') {
			if (needsSep) {
			    *dest++ = '/';
			}
		    }
		} else {
		    *dest++ = *p;
		    needsSep = 1;
a814 4
	    }
	    length = dest - Tcl_GetString(prefix);
	    Tcl_SetObjLength(prefix, length);
	    break;
d816 10
a825 4
	case TCL_PLATFORM_WINDOWS:
	    /*
	     * Check to see if we need to append a separator.
	     */
d827 4
a830 11
	    if ((length > 0) && 
		(start[length-1] != '/') && (start[length-1] != ':')) {
		Tcl_AppendToObj(prefix, "/", 1);
		length++;
	    }
	    needsSep = 0;
	    
	    /*
	     * Append the element, eliminating duplicate and
	     * trailing slashes.
	     */
d832 12
a843 9
	    Tcl_SetObjLength(prefix, length + (int) strlen(p));
	    dest = Tcl_GetString(prefix) + length;
	    for (; *p != '\0'; p++) {
		if ((*p == '/') || (*p == '\\')) {
		    while ((p[1] == '/') || (p[1] == '\\')) {
			p++;
		    }
		    if ((p[1] != '\0') && needsSep) {
			*dest++ = '/';
a844 3
		} else {
		    *dest++ = *p;
		    needsSep = 1;
d846 2
a848 2
	    length = dest - Tcl_GetString(prefix);
	    Tcl_SetObjLength(prefix, length);
d851 1
a851 3
	case TCL_PLATFORM_MAC: {
	    int newLength;
	    
d853 3
a855 6
	     * Sort out separators.  We basically add the object we've
	     * been given, but we have to make sure that there is
	     * exactly one separator inbetween (unless the object we're
	     * adding contains multiple contiguous colons, all of which
	     * we must add).  Also if an object is just ':' we don't
	     * bother to add it unless it's the very first element.
d858 23
a880 8
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
	    int adjustedPath = 0;
	    if ((strchr(p, ':') == NULL) && (strchr(p, '/') != NULL)) {
		char *start = p;
		adjustedPath = 1;
		while (*start != '\0') {
		    if (*start == '/') {
		        *start = ':';
a881 1
		    start++;
d883 33
a915 10
	    }
#endif
	    if (length > 0) {
		if ((p[0] == ':') && (p[1] == '\0')) {
		    return;
		}
		if (start[length-1] != ':') {
		    if (*p != '\0' && *p != ':') {
			Tcl_AppendToObj(prefix, ":", 1);
			length++;
d917 2
a918 7
		} else if (*p == ':') {
		    p++;
		}
	    } else {
		if (*p != '\0' && *p != ':') {
		    Tcl_AppendToObj(prefix, ":", 1);
		    length++;
d921 1
a921 4
	    
	    /*
	     * Append the element
	     */
d923 12
a934 15
	    newLength = strlen(p);
	    /* 
	     * It may not be good to just do 'Tcl_AppendToObj(prefix,
	     * p, newLength)' because the object may contain duplicate
	     * colons which we want to get rid of.
	     */
	    Tcl_AppendToObj(prefix, p, newLength);
	    
	    /* Remove spurious trailing single ':' */
	    dest = Tcl_GetString(prefix) + length + newLength;
	    if (*(dest-1) == ':') {
		if (dest-1 > Tcl_GetString(prefix)) {
		    if (*(dest-2) != ':') {
		        Tcl_SetObjLength(prefix, length + newLength -1);
		    }
d936 27
a962 8
	    }
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
	    /* Revert the path to what it was */
	    if (adjustedPath) {
		char *start = joining;
		while (*start != '\0') {
		    if (*start == ':') {
			*start = '/';
d964 2
a965 1
		    start++;
a967 1
#endif
d969 1
a969 1
	}
d971 1
a971 52
    return;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_JoinPath --
 *
 *	Combine a list of paths in a platform specific manner.  The
 *	function 'Tcl_FSJoinPath' should be used in preference where
 *	possible.
 *
 * Results:
 *	Appends the joined path to the end of the specified 
 *	Tcl_DString returning a pointer to the resulting string.  Note
 *	that the Tcl_DString must already be initialized.
 *
 * Side effects:
 *	Modifies the Tcl_DString.
 *
 *----------------------------------------------------------------------
 */

char *
Tcl_JoinPath(argc, argv, resultPtr)
    int argc;
    CONST char * CONST *argv;
    Tcl_DString *resultPtr;	/* Pointer to previously initialized DString */
{
    int i, len;
    Tcl_Obj *listObj = Tcl_NewObj();
    Tcl_Obj *resultObj;
    char *resultStr;

    /* Build the list of paths */
    for (i = 0; i < argc; i++) {
        Tcl_ListObjAppendElement(NULL, listObj,
		Tcl_NewStringObj(argv[i], -1));
    }

    /* Ask the objectified code to join the paths */
    Tcl_IncrRefCount(listObj);
    resultObj = Tcl_FSJoinPath(listObj, argc);
    Tcl_IncrRefCount(resultObj);
    Tcl_DecrRefCount(listObj);

    /* Store the result */
    resultStr = Tcl_GetStringFromObj(resultObj, &len);
    Tcl_DStringAppend(resultPtr, resultStr, len);
    Tcl_DecrRefCount(resultObj);

    /* Return a pointer to the result */
d1005 1
a1005 1
    CONST char *name;		/* File name, which may begin with "~" (to
d1012 1
a1012 12
    Tcl_Obj *path = Tcl_NewStringObj(name, -1);
    CONST char *result;

    Tcl_IncrRefCount(path);
    result = Tcl_FSGetTranslatedStringPath(interp, path);
    if (result == NULL) {
	Tcl_DecrRefCount(path);
	return NULL;
    }
    Tcl_DStringInit(bufferPtr);
    Tcl_DStringAppend(bufferPtr, result, -1);
    Tcl_DecrRefCount(path);
d1015 1
a1015 2
     * Convert forward slashes to backslashes in Windows paths because
     * some system interfaces don't accept forward slashes.
d1018 4
a1021 6
    if (tclPlatform == TCL_PLATFORM_WINDOWS) {
#if defined(__CYGWIN__) && defined(__WIN32__)

	extern int cygwin_conv_to_win32_path 
	    _ANSI_ARGS_((CONST char *, char *));
	char winbuf[MAX_PATH];
d1023 2
d1026 2
a1027 3
	 * In the Cygwin world, call conv_to_win32_path in order to use the
	 * mount table to translate the file name into something Windows will
	 * understand.  Take care when converting empty strings!
d1029 12
a1040 4
	if (Tcl_DStringLength(bufferPtr)) {
	    cygwin_conv_to_win32_path(Tcl_DStringValue(bufferPtr), winbuf);
	    Tcl_DStringFree(bufferPtr);
	    Tcl_DStringAppend(bufferPtr, winbuf, -1);
d1042 13
a1054 1
#else /* __CYGWIN__ && __WIN32__ */
d1056 2
a1057 1
	register char *p;
a1062 1
#endif /* __CYGWIN__ && __WIN32__ */
d1064 1
a1102 1
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
a1107 3
#else
	    lastSep = strrchr(name, ':');
#endif
d1120 2
a1121 1
    if ((p != NULL) && (lastSep != NULL) && (lastSep > p)) {
d1157 1
a1157 1
static CONST char *
d1166 1
a1166 1
    CONST char *dir;
d1192 1
a1192 1
    return Tcl_DStringValue(resultPtr);
d1220 2
a1221 2
    int index, i, globFlags, length, join, dir, result;
    char *string, *separators;
d1223 3
a1225 5
    Tcl_Obj *pathOrDir = NULL;
    Tcl_DString prefix;
    static CONST char *options[] = {
	"-directory", "-join", "-nocomplain", "-path", "-tails", 
	"-types", "--", NULL
d1228 1
a1228 2
	GLOB_DIR, GLOB_JOIN, GLOB_NOCOMPLAIN, GLOB_PATH, GLOB_TAILS, 
	GLOB_TYPE, GLOB_LAST
d1231 1
a1231 1
    Tcl_GlobTypeData *globTypes = NULL;
d1236 1
d1260 1
a1260 1
	        globFlags |= TCL_GLOBMODE_NO_COMPLAIN;
d1268 1
a1268 1
		if (dir != PATH_NONE) {
d1275 2
a1276 2
		globFlags |= TCL_GLOBMODE_DIR;
		pathOrDir = objv[i+1];
a1281 3
	    case GLOB_TAILS:				/* -tails */
	        globFlags |= TCL_GLOBMODE_TAILS;
		break;
d1288 1
a1288 1
		if (dir != PATH_NONE) {
d1295 1
a1295 1
		pathOrDir = objv[i+1];
d1321 1
a1321 7
    if ((globFlags & TCL_GLOBMODE_TAILS) && (pathOrDir == NULL)) {
	Tcl_AppendToObj(resultPtr,
	  "\"-tails\" must be used with either \"-directory\" or \"-path\"",
	  -1);
	return TCL_ERROR;
    }
    
a1334 1
	int pathlength;
a1335 1
	char *first = Tcl_GetStringFromObj(pathOrDir,&pathlength);
d1340 2
a1341 2
	last = first + pathlength;
	for (; last != first; last--) {
d1346 1
a1346 1
	if (last == first + pathlength) {
d1348 1
a1348 1
	    dir = PATH_DIR;
d1353 2
a1354 1
	    if (last == first) {
d1356 1
a1356 1
		Tcl_DStringAppend(&pref, first, -1);
d1360 3
a1362 2
		Tcl_DStringAppend(&pref, last, first+pathlength-last);
		pathOrDir = Tcl_NewStringObj(first, last-first-1);
d1382 1
a1382 5
    
    if (pathOrDir != NULL) {
	Tcl_IncrRefCount(pathOrDir);
    }
    
d1390 1
a1390 1
	globTypes = (Tcl_GlobTypeData*) ckalloc(sizeof(Tcl_GlobTypeData));
d1473 1
a1473 4
		 * Error cases.  We re-get the interpreter's result,
		 * just to be sure it hasn't changed, and we reset
		 * the 'join' flag to zero, since we haven't yet
		 * made use of it.
a1475 1
		resultPtr = Tcl_GetObjResult(interp);
a1478 1
		join = 0;
a1480 1
		resultPtr = Tcl_GetObjResult(interp);
d1482 1
a1482 2
		   "only one MacOS type or creator argument"
		   " to \"-types\" allowed", -1);
a1483 1
		join = 0;
d1549 1
a1549 1
    if ((globFlags & TCL_GLOBMODE_NO_COMPLAIN) == 0) {
d1577 3
a1579 3
    }
    if (pathOrDir != NULL) {
	Tcl_DecrRefCount(pathOrDir);
a1600 5
 *      
 *      The interpreter's result, on entry to this function, must
 *      be a valid Tcl list (e.g. it could be empty), since we will
 *      lappend any new results to that list.  If it is not a valid
 *      list, this function will fail to do anything very meaningful.
d1606 2
a1607 5
 *	given by the pattern and unquotedPrefix arguments.  After an 
 *	error the result in interp will hold an error message, unless
 *	the 'TCL_GLOBMODE_NO_COMPLAIN' flag was given, in which case
 *	an error results in a TCL_OK return leaving the interpreter's
 *	result unmodified.
d1610 1
a1610 1
 *	The 'pattern' is written to.
d1622 2
a1623 2
    Tcl_Obj *unquotedPrefix;	/* Prefix to glob pattern, if non-null, which
                             	 * is considered literally. */
d1625 1
a1625 1
    Tcl_GlobTypeData *types;	/* Struct containing acceptable types.
d1629 1
a1629 2
    CONST char *head;
    char *tail, *start;
d1631 1
a1631 1
    int result, prefixLen;
a1632 1
    Tcl_Obj *oldResult;
a1642 1
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
a1647 3
#else
	    separators = ":";
#endif
d1653 1
a1653 1
	start = Tcl_GetString(unquotedPrefix);
d1678 2
a1679 1
	 * Determine the home directory for the specified user.  
d1684 11
a1694 6
	if (globFlags & TCL_GLOBMODE_NO_COMPLAIN) {
	    /* 
	     * We will ignore any error message here, and we
	     * don't want to mess up the interpreter's result.
	     */
	    head = DoTildeSubst(NULL, start+1, &buffer);
d1696 6
a1701 1
	    head = DoTildeSubst(interp, start+1, &buffer);
d1703 1
d1706 10
a1715 1
	    if (globFlags & TCL_GLOBMODE_NO_COMPLAIN) {
d1731 1
a1731 1
	    Tcl_DStringAppend(&buffer,Tcl_GetString(unquotedPrefix),-1);
a1733 1
    
d1735 7
a1741 15
     * We want to remember the length of the current prefix,
     * in case we are using TCL_GLOBMODE_TAILS.  Also if we
     * are using TCL_GLOBMODE_DIR, we must make sure the
     * prefix ends in a directory separator.
     */
    prefixLen = Tcl_DStringLength(&buffer);

    if (prefixLen > 0) {
	c = Tcl_DStringValue(&buffer)[prefixLen-1];
	if (strchr(separators, c) == NULL) {
	    /* 
	     * If the prefix is a directory, make sure it ends in a
	     * directory separator.
	     */
	    if (globFlags & TCL_GLOBMODE_DIR) {
a1743 1
	    prefixLen++;
a1746 8
    /* 
     * We need to get the old result, in case it is over-written
     * below when we still need it.
     */
    oldResult = Tcl_GetObjResult(interp);
    Tcl_IncrRefCount(oldResult);
    Tcl_ResetResult(interp);
    
d1748 1
a1748 1
    
d1750 3
a1752 61
	if (globFlags & TCL_GLOBMODE_NO_COMPLAIN) {
	    /* Put back the old result and reset the return code */
	    Tcl_SetObjResult(interp, oldResult);
	    result = TCL_OK;
	}
    } else {
	/* 
	 * Now we must concatenate the 'oldResult' and the current
	 * result, and then place that into the interpreter.
	 * 
	 * If we only want the tails, we must strip off the prefix now.
	 * It may seem more efficient to pass the tails flag down into
	 * TclDoGlob, Tcl_FSMatchInDirectory, but those functions are
	 * continually adjusting the prefix as the various pieces of
	 * the pattern are assimilated, so that would add a lot of
	 * complexity to the code.  This way is a little slower (when
	 * the -tails flag is given), but much simpler to code.
	 */
	int objc, i;
	Tcl_Obj **objv;

	/* Ensure sole ownership */
	if (Tcl_IsShared(oldResult)) {
	    Tcl_DecrRefCount(oldResult);
	    oldResult = Tcl_DuplicateObj(oldResult);
	    Tcl_IncrRefCount(oldResult);
	}

	Tcl_ListObjGetElements(NULL, Tcl_GetObjResult(interp), 
			       &objc, &objv);
#ifdef MAC_TCL
	/* adjust prefixLen if TclDoGlob prepended a ':' */
	if ((prefixLen > 0) && (objc > 0)
	&& (Tcl_DStringValue(&buffer)[0] != ':')) {
	    char *str = Tcl_GetStringFromObj(objv[0],NULL);
	    if (str[0] == ':') {
		    prefixLen++;
	    }
	}
#endif
	for (i = 0; i< objc; i++) {
	    Tcl_Obj* elt;
	    if (globFlags & TCL_GLOBMODE_TAILS) {
		int len;
		char *oldStr = Tcl_GetStringFromObj(objv[i],&len);
		if (len == prefixLen) {
		    if ((pattern[0] == '\0')
			|| (strchr(separators, pattern[0]) == NULL)) {
			elt = Tcl_NewStringObj(".",1);
		    } else {
			elt = Tcl_NewStringObj("/",1);
		    }
		} else {
		    elt = Tcl_NewStringObj(oldStr + prefixLen, 
						len - prefixLen);
		}
	    } else {
		elt = objv[i];
	    }
	    /* Assumption that 'oldResult' is a valid list */
	    Tcl_ListObjAppendElement(interp, oldResult, elt);
a1753 1
	Tcl_SetObjResult(interp, oldResult);
a1754 6
    /* 
     * Release our temporary copy.  All code paths above must
     * end here so we free our reference.
     */
    Tcl_DecrRefCount(oldResult);
    Tcl_DStringFree(&buffer);
d1847 2
a1848 2
    Tcl_GlobTypeData *types;	/* List object containing list of acceptable 
                            	 * types. May be NULL. */
a1884 1
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
a1890 1
#endif
a1902 1
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
a1903 1
#endif
a1912 19
#if defined(__CYGWIN__) && defined(__WIN32__)
	    {

	    extern int cygwin_conv_to_win32_path 
	    	_ANSI_ARGS_((CONST char *, char *));
	    char winbuf[MAX_PATH];

	    /*
	     * In the Cygwin world, call conv_to_win32_path in order to use
	     * the mount table to translate the file name into something
	     * Windows will understand.
	     */
	    cygwin_conv_to_win32_path(Tcl_DStringValue(headPtr), winbuf);
	    Tcl_DStringFree(headPtr);
	    Tcl_DStringAppend(headPtr, winbuf, -1);

	    }
#endif /* __CYGWIN__ && __WIN32__ */

d2005 2
a2006 2
	    result = TclDoGlob(interp, separators, headPtr, 
			       Tcl_DStringValue(&newName), types);
d2031 4
a2034 4
	savedChar = *p;
	*p = '\0';
	firstSpecialChar = strpbrk(tail, "*[]?\\");
	*p = savedChar;
a2039 3
	int ret;
	Tcl_Obj *head = Tcl_NewStringObj(Tcl_DStringValue(headPtr),-1);
	Tcl_IncrRefCount(head);
d2041 5
a2045 4
	 * Look for matching files in the given directory.  The
	 * implementation of this function is platform specific.  For
	 * each file that matches, it will add the match onto the
	 * resultPtr given.
a2046 5
	if (*p == '\0') {
	    ret = Tcl_FSMatchInDirectory(interp, Tcl_GetObjResult(interp), 
					 head, tail, types);
	} else {
	    Tcl_Obj* resultPtr;
d2048 1
a2048 40
	    /* 
	     * We do the recursion ourselves.  This makes implementing
	     * Tcl_FSMatchInDirectory for each filesystem much easier.
	     */
	    Tcl_GlobTypeData dirOnly = { TCL_GLOB_TYPE_DIR, 0, NULL, NULL };
	    char save = *p;
	    
	    *p = '\0';
	    resultPtr = Tcl_NewListObj(0, NULL);
	    ret = Tcl_FSMatchInDirectory(interp, resultPtr, 
					 head, tail, &dirOnly);
	    *p = save;
	    if (ret == TCL_OK) {
		int resLength;
		ret = Tcl_ListObjLength(interp, resultPtr, &resLength);
		if (ret == TCL_OK) {
		    int i;
		    for (i =0; i< resLength; i++) {
			Tcl_Obj *elt;
			Tcl_DString ds;
			Tcl_ListObjIndex(interp, resultPtr, i, &elt);
			Tcl_DStringInit(&ds);
			Tcl_DStringAppend(&ds, Tcl_GetString(elt), -1);
			if(tclPlatform == TCL_PLATFORM_MAC) {
			    Tcl_DStringAppend(&ds, ":",1);
			} else {			
			    Tcl_DStringAppend(&ds, "/",1);
			}
			ret = TclDoGlob(interp, separators, &ds, p+1, types);
			Tcl_DStringFree(&ds);
			if (ret != TCL_OK) {
			    break;
			}
		    }
		}
	    }
	    Tcl_DecrRefCount(resultPtr);
	}
	Tcl_DecrRefCount(head);
	return ret;
d2053 7
a2059 12
    } else {
	/*
	 * This is the code path reached by a command like 'glob foo'.
	 *
	 * There are no more wildcards in the pattern and no more
	 * unprocessed characters in the tail, so now we can construct
	 * the path, and pass it to Tcl_FSMatchInDirectory with an
	 * empty pattern to verify the existence of the file and check
	 * it is of the correct type (if a 'types' flag it given -- if
	 * no such flag was given, we could just use 'Tcl_FSLStat', but
	 * for simplicity we keep to a common approach).
	 */
d2061 13
a2073 8
	Tcl_Obj *nameObj;
	/* Used to deal with one special case pertinent to MacOS */
	int macSpecialCase = 0;

	switch (tclPlatform) {
	    case TCL_PLATFORM_MAC: {
		if (strchr(Tcl_DStringValue(headPtr), ':') == NULL) {
		    Tcl_DStringAppend(headPtr, ":", 1);
a2074 2
		macSpecialCase = 1;
		break;
d2076 18
a2093 8
	    case TCL_PLATFORM_WINDOWS: {
		if (Tcl_DStringLength(headPtr) == 0) {
		    if (((*name == '\\') && (name[1] == '/' || name[1] == '\\'))
			    || (*name == '/')) {
			Tcl_DStringAppend(headPtr, "\\", 1);
		    } else {
			Tcl_DStringAppend(headPtr, ".", 1);
		    }
d2095 1
a2095 6
		/* 
		 * Convert to forward slashes.  This is required to pass
		 * some Tcl tests.  We should probably remove the conversions
		 * here and in tclWinFile.c, since they aren't needed since
		 * the dropping of support for Win32s.
		 */
d2097 2
a2098 2
		    if (*p == '\\') {
			*p = '/';
a2100 1
		break;
d2102 7
a2108 7
	    case TCL_PLATFORM_UNIX: {
		if (Tcl_DStringLength(headPtr) == 0) {
		    if ((*name == '\\' && name[1] == '/') || (*name == '/')) {
			Tcl_DStringAppend(headPtr, "/", 1);
		    } else {
			Tcl_DStringAppend(headPtr, ".", 1);
		    }
a2109 1
		break;
d2111 5
d2117 14
a2130 54
	/* Common for all platforms */
	name = Tcl_DStringValue(headPtr);
	nameObj = Tcl_NewStringObj(name, Tcl_DStringLength(headPtr));

	Tcl_IncrRefCount(nameObj);
	Tcl_FSMatchInDirectory(interp, Tcl_GetObjResult(interp), nameObj, 
			       NULL, types);
	Tcl_DecrRefCount(nameObj);
	return TCL_OK;
    }
}


/*
 *---------------------------------------------------------------------------
 *
 * TclFileDirname
 *
 *	This procedure calculates the directory above a given 
 *	path: basically 'file dirname'.  It is used both by
 *	the 'dirname' subcommand of file and by code in tclIOUtil.c.
 *
 * Results:
 *	NULL if an error occurred, otherwise a Tcl_Obj owned by
 *	the caller (i.e. most likely with refCount 1).
 *
 * Side effects:
 *      None.
 *
 *---------------------------------------------------------------------------
 */

Tcl_Obj*
TclFileDirname(interp, pathPtr)
    Tcl_Interp *interp;		/* Used for error reporting */
    Tcl_Obj *pathPtr;           /* Path to take dirname of */
{
    int splitElements;
    Tcl_Obj *splitPtr;
    Tcl_Obj *splitResultPtr = NULL;

    /* 
     * The behaviour we want here is slightly different to
     * the standard Tcl_FSSplitPath in the handling of home
     * directories; Tcl_FSSplitPath preserves the "~" while 
     * this code computes the actual full path name, if we
     * had just a single component.
     */	    
    splitPtr = Tcl_FSSplitPath(pathPtr, &splitElements);
    if ((splitElements == 1) && (Tcl_GetString(pathPtr)[0] == '~')) {
	Tcl_DecrRefCount(splitPtr);
	splitPtr = Tcl_FSGetNormalizedPath(interp, pathPtr);
	if (splitPtr == NULL) {
	    return NULL;
a2131 1
	splitPtr = Tcl_FSSplitPath(splitPtr, &splitElements);
d2134 1
a2134 18
    /*
     * Return all but the last component.  If there is only one
     * component, return it if the path was non-relative, otherwise
     * return the current directory.
     */

    if (splitElements > 1) {
	splitResultPtr = Tcl_FSJoinPath(splitPtr, splitElements - 1);
    } else if (splitElements == 0 || 
      (Tcl_FSGetPathType(pathPtr) == TCL_PATH_RELATIVE)) {
	splitResultPtr = Tcl_NewStringObj(
		((tclPlatform == TCL_PLATFORM_MAC) ? ":" : "."), 1);
    } else {
	Tcl_ListObjIndex(NULL, splitPtr, 0, &splitResultPtr);
    }
    Tcl_IncrRefCount(splitResultPtr);
    Tcl_DecrRefCount(splitPtr);
    return splitResultPtr;
a2135 19

/*
 *---------------------------------------------------------------------------
 *
 * Tcl_AllocStatBuf
 *
 *     This procedure allocates a Tcl_StatBuf on the heap.  It exists
 *     so that extensions may be used unchanged on systems where
 *     largefile support is optional.
 *
 * Results:
 *     A pointer to a Tcl_StatBuf which may be deallocated by being
 *     passed to ckfree().
 *
 * Side effects:
 *      None.
 *
 *---------------------------------------------------------------------------
 */
a2136 4
Tcl_StatBuf *
Tcl_AllocStatBuf() {
    return (Tcl_StatBuf *) ckalloc(sizeof(Tcl_StatBuf));
}
@


1.6.16.3
log
@2003-03-05  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline.  Tag is carlton_dictionary-20030305-merge.
@
text
@d1359 18
d1383 1
d2339 19
d2573 1
a2573 1
			Tcl_DStringAppend(headPtr, "/", 1);
a2577 13
#if defined(__CYGWIN__) && defined(__WIN32__)
		{

		extern int cygwin_conv_to_win32_path 
		    _ANSI_ARGS_((CONST char *, char *));
		char winbuf[MAX_PATH+1];

		cygwin_conv_to_win32_path(Tcl_DStringValue(headPtr), winbuf);
		Tcl_DStringFree(headPtr);
		Tcl_DStringAppend(headPtr, winbuf, -1);

		}
#endif /* __CYGWIN__ && __WIN32__ */
@


1.5
log
@Tcl8.3 upgrade merge.
@
text
@@


1.4
log
@* generic/tclFilename.c (Tcl_TranslateFileName): Reinstate Mon Jun 5 18:18:32
2000 Christopher Faylor <cgf@@cygnus.com> minus a typo.
@
text
@d7 2
a8 1
 * Copyright (c) 1995-1996 Sun Microsystems, Inc.
d13 1
a13 1
 * RCS: @@(#) $Id: tclFileName.c,v 1.9 1999/01/26 03:53:12 jingham Exp $
a20 7
 * This variable indicates whether the cleanup procedure has been
 * registered for this file yet.
 */

static int initialized = 0;

/*
d26 1
a26 1
#define WIN_ROOT_PATTERN "^(([a-zA-Z]:)|[/\\][/\\]+([^/\\]+)[/\\]+([^/\\]+)|([/\\]))([/\\])*"
d41 6
a46 2
static regexp *winRootPatternPtr = NULL;
static regexp *macRootPatternPtr = NULL;
d56 9
d69 3
a71 3
			    char *user, Tcl_DString *resultPtr));
static char *		ExtractWinRoot _ANSI_ARGS_((char *path,
			    Tcl_DString *resultPtr, int offset));
d73 1
d76 1
a76 1
static char *		SplitMacPath _ANSI_ARGS_((char *path,
d78 1
a78 1
static char *		SplitWinPath _ANSI_ARGS_((char *path,
d80 1
a80 1
static char *		SplitUnixPath _ANSI_ARGS_((char *path,
d86 27
d131 3
a133 9
    if (winRootPatternPtr != NULL) {
	ckfree((char *)winRootPatternPtr);
        winRootPatternPtr = (regexp *) NULL;
    }
    if (macRootPatternPtr != NULL) {
	ckfree((char *)macRootPatternPtr);
        macRootPatternPtr = (regexp *) NULL;
    }
    initialized = 0;
d156 3
a158 3
static char *
ExtractWinRoot(path, resultPtr, offset)
    char *path;			/* Path to parse. */
d162 1
d164 1
a164 1
    int length;
a165 3
    /*
     * Initialize the path name parser for Windows path names.
     */
d167 9
a175 6
    if (winRootPatternPtr == NULL) {
	winRootPatternPtr = TclRegComp(WIN_ROOT_PATTERN);
	if (!initialized) {
	    Tcl_CreateExitHandler(FileNameCleanup, NULL);
	    initialized = 1;
	}
d177 1
d179 2
a180 3
    /*
     * Match the root portion of a Windows path name.
     */
d182 11
a192 3
    if (!TclRegExec(winRootPatternPtr, path, path)) {
	return path;
    }
d194 2
a195 1
    Tcl_DStringSetLength(resultPtr, offset);
d197 3
a199 4
    if (winRootPatternPtr->startp[2] != NULL) {
	Tcl_DStringAppend(resultPtr, winRootPatternPtr->startp[2], 2);
	if (winRootPatternPtr->startp[6] != NULL) {
	    Tcl_DStringAppend(resultPtr, "/", 1);
a200 1
    } else if (winRootPatternPtr->startp[4] != NULL) {
d202 1
a202 3
	length = winRootPatternPtr->endp[3]
	    - winRootPatternPtr->startp[3];
	Tcl_DStringAppend(resultPtr, winRootPatternPtr->startp[3], length);
d204 17
a220 3
	length = winRootPatternPtr->endp[4]
	    - winRootPatternPtr->startp[4];
	Tcl_DStringAppend(resultPtr, winRootPatternPtr->startp[4], length);
d222 7
d230 6
a236 1
    return winRootPatternPtr->endp[0];
d261 1
d263 1
d280 1
d287 12
a298 5
		if (!macRootPatternPtr) {
		    macRootPatternPtr = TclRegComp(MAC_ROOT_PATTERN);
		    if (!initialized) {
			Tcl_CreateExitHandler(FileNameCleanup, NULL);
			initialized = 1;
a300 4
		if (!TclRegExec(macRootPatternPtr, path, path)
			|| (macRootPatternPtr->startp[2] != NULL)) {
		    type = TCL_PATH_RELATIVE;
		}
d306 1
d308 3
a310 21
		/*
		 * Since we have eliminated the easy cases, check for
		 * drive relative paths using the regular expression.
		 */

		if (!winRootPatternPtr) {
		    winRootPatternPtr = TclRegComp(WIN_ROOT_PATTERN);
		    if (!initialized) {
			Tcl_CreateExitHandler(FileNameCleanup, NULL);
			initialized = 1;
		    }
		}
		if (TclRegExec(winRootPatternPtr, path, path)) {
		    if (winRootPatternPtr->startp[5]
			    || (winRootPatternPtr->startp[2]
				    && !(winRootPatternPtr->startp[6]))) {
			type = TCL_PATH_VOLUME_RELATIVE;
		    }
		} else {
		    type = TCL_PATH_RELATIVE;
		}
d345 1
a345 1
    char *path;			/* Pointer to string containing a path. */
d354 1
d439 1
a439 1
    char *path;			/* Pointer to string containing a path. */
d443 1
a443 1
    char *p, *elementStart;
d449 13
d514 1
a514 1
    char *path;			/* Pointer to string containing a path. */
d518 2
a519 1
    char *p, *elementStart;
d521 1
a521 1
    p = ExtractWinRoot(path, bufPtr, 0);
d573 1
a573 1
    char *path;			/* Pointer to string containing a path. */
d578 3
a580 1
    char *p, *elementStart;
d586 1
a586 7
    if (macRootPatternPtr == NULL) {
	macRootPatternPtr = TclRegComp(MAC_ROOT_PATTERN);
	if (!initialized) {
	    Tcl_CreateExitHandler(FileNameCleanup, NULL);
	    initialized = 1;
	}
    }
d593 6
a598 1
    if (TclRegExec(macRootPatternPtr, path, path) == 1) {
d604 2
a605 1
	if (macRootPatternPtr->startp[2] != NULL) {
d607 2
a608 2
	    Tcl_DStringAppend(bufPtr, path, macRootPatternPtr->endp[0]
		    - macRootPatternPtr->startp[0] + 1);
d612 2
a613 2
	if (macRootPatternPtr->startp[5] != NULL) {

d620 6
a625 1
	} else if (macRootPatternPtr->startp[7] != NULL) {
d627 5
a631 3
	    /*
	     * Mac-style tilde prefixed paths.
	     */
d633 3
a635 3
	    isMac = 1;
	    i = 7;
	} else if (macRootPatternPtr->startp[10] != NULL) {
d637 5
a641 3
	    /*
	     * Normal Unix style paths.
	     */
d643 3
a645 3
	    isMac = 0;
	    i = 10;
	} else if (macRootPatternPtr->startp[12] != NULL) {
d647 5
a651 6
	    /*
	     * Normal Mac style paths.
	     */

	    isMac = 1;
	    i = 12;
d654 2
a655 2
	length = macRootPatternPtr->endp[i]
	    - macRootPatternPtr->startp[i];
d662 1
a662 1
	Tcl_DStringAppend(bufPtr, macRootPatternPtr->startp[i], length);
d664 1
a664 1
	p = macRootPatternPtr->endp[i];
d768 3
a770 1
    char *p, c, *dest;
d786 12
d859 1
a859 1
		p = ExtractWinRoot(argv[i], resultPtr, oldLength);
d976 1
a976 1
 *----------------------------------------------------------------------
d981 3
a983 3
 *	interfaces.  If the name starts with a tilde, it will produce
 *	a name where the tilde and following characters have been
 *	replaced by the home directory location for the named user.
d986 8
a993 6
 *	The result is a pointer to a static string containing
 *	the new name.  If there was an error in processing the
 *	name, then an error message is left in interp->result
 *	and the return value is NULL.  The result will be stored
 *	in bufferPtr; the caller must call Tcl_DStringFree(bufferPtr)
 *	to free the name if the return value was not NULL.
d996 1
a996 1
 *	Information may be left in bufferPtr.
d1005 6
a1010 7
    char *name;			/* File name, which may begin with "~"
				 * (to indicate current user's home directory)
				 * or "~<user>" (to indicate any user's
				 * home directory). */
    Tcl_DString *bufferPtr;	/* May be used to hold result.  Must not hold
				 * anything at the time of the call, and need
				 * not even be initialized. */
d1023 1
a1023 1
	Tcl_SplitPath(name, &argc, &argv);
d1026 2
a1027 2
	 * Strip the trailing ':' off of a Mac path
	 * before passing the user name to DoTildeSubst.
d1043 1
a1043 1
	Tcl_JoinPath(argc, argv, bufferPtr);
d1048 1
a1048 1
	Tcl_JoinPath(1, &name, bufferPtr);
d1126 4
a1129 2
     * Back up to the first period in a series of contiguous dots.
     * This is needed so foo..o will be split on the first dot.
a1131 5
    if (p != NULL) {
	while ((p > name) && *(p-1) == '.') {
	    p--;
	}
    }
d1146 4
a1149 3
 *	the substitution, then an error message is left in interp->result
 *	and the return value is NULL.  On success, the results are appended
 * 	to resultPtr, and the contents of resultPtr are returned.
d1161 1
a1161 1
    char *user;			/* Name of user whose home directory should be
d1163 2
a1164 3
    Tcl_DString *resultPtr;	/* May be used to hold result.  Must not hold
				 * anything at the time of the call, and need
				 * not even be initialized. */
d1169 3
a1171 1
	dir = TclGetEnv("HOME");
d1181 1
d1183 1
a1183 3
	
	/* lint, TclGetuserHome() always NULL under windows. */
	if (TclGetUserHome(user, resultPtr) == NULL) {	
d1198 1
a1198 1
 * Tcl_GlobCmd --
d1214 1
a1214 1
Tcl_GlobCmd(dummy, interp, argc, argv)
d1217 2
a1218 2
    int argc;				/* Number of arguments. */
    char **argv;			/* Argument strings. */
d1220 94
a1313 18
    int i, noComplain, firstArg;
    char c;
    int result = TCL_OK;
    Tcl_DString buffer;
    char *separators, *head, *tail;

    noComplain = 0;
    for (firstArg = 1; (firstArg < argc) && (argv[firstArg][0] == '-');
	    firstArg++) {
	if (strcmp(argv[firstArg], "-nocomplain") == 0) {
	    noComplain = 1;
	} else if (strcmp(argv[firstArg], "--") == 0) {
	    firstArg++;
	    break;
	} else {
	    Tcl_AppendResult(interp, "bad switch \"", argv[firstArg],
		    "\": must be -nocomplain or --", (char *) NULL);
	    return TCL_ERROR;
d1316 3
a1318 3
    if (firstArg >= argc) {
	Tcl_AppendResult(interp, "wrong # args: should be \"", argv[0],
		" ?switches? name ?name ...?\"", (char *) NULL);
d1322 2
a1323 4
    Tcl_DStringInit(&buffer);
    separators = NULL;		/* Needed only to prevent gcc warnings. */
    for (i = firstArg; i < argc; i++) {
	switch (tclPlatform) {
d1331 1
a1331 1
	    separators = (strchr(argv[i], ':') == NULL) ? "/" : ":";
d1333 3
a1335 3
	}

	Tcl_DStringSetLength(&buffer, 0);
d1338 1
a1338 1
	 * Perform tilde substitution, if needed.
d1340 42
d1383 105
a1487 2
	if (argv[i][0] == '~') {
	    char *p;
d1489 79
a1567 11
	    /*
	     * Find the first path separator after the tilde.
	     */

	    for (tail = argv[i]; *tail != '\0'; tail++) {
		if (*tail == '\\') {
		    if (strchr(separators, tail[1]) != NULL) {
			break;
		    }
		} else if (strchr(separators, *tail) != NULL) {
		    break;
d1570 44
d1615 18
a1632 4
	    /*
	     * Determine the home directory for the specified user.  Note that
	     * we don't allow special characters in the user name.
	     */
d1634 11
a1644 5
	    c = *tail;
	    *tail = '\0';
	    p = strpbrk(argv[i]+1, "\\[]*?{}");
	    if (p == NULL) {
		head = DoTildeSubst(interp, argv[i]+1, &buffer);
d1646 25
a1670 15
		if (!noComplain) {
		    Tcl_ResetResult(interp);
		    Tcl_AppendResult(interp, "globbing characters not ",
			    "supported in user names", (char *) NULL);
		}
		head = NULL;
	    }
	    *tail = c;
	    if (head == NULL) {
		if (noComplain) {
		    Tcl_ResetResult(interp);
		    continue;
		} else {
		    result = TCL_ERROR;
		    goto done;
d1672 2
d1675 25
a1699 2
	    if (head != Tcl_DStringValue(&buffer)) {
		Tcl_DStringAppend(&buffer, head, -1);
d1701 1
a1701 2
	} else {
	    tail = argv[i];
d1703 4
a1706 4

	result = TclDoGlob(interp, separators, &buffer, tail);
	if (result != TCL_OK) {
	    if (noComplain) {
d1709 1
a1709 1
		 * or save the interp result or use another mecanism
d1716 1
a1716 2
		result = TCL_OK;
		continue;
d1718 25
a1742 1
		goto done;
d1747 6
a1752 8
    if ((*interp->result == 0) && !noComplain) {
	char *sep = "";

	Tcl_AppendResult(interp, "no files matched glob pattern",
		(argc == 2) ? " \"" : "s \"", (char *) NULL);
	for (i = firstArg; i < argc; i++) {
	    Tcl_AppendResult(interp, sep, argv[i], (char *) NULL);
	    sep = " ";
a1753 2
	Tcl_AppendResult(interp, "\"", (char *) NULL);
	result = TCL_ERROR;
a1754 2
done:
    Tcl_DStringFree(&buffer);
d1818 5
a1822 1
 *	remainder are assumed to be native format paths.
d1838 1
a1838 1
TclDoGlob(interp, separators, headPtr, tail)
d1845 4
a1848 1
    char *tail;			/* The unexpanded remainder of the path. */
d1852 1
a1852 1
    char *p, *openBrace, *closeBrace, *name, *firstSpecialChar, savedChar;
d1854 1
d2006 1
a2006 1
		    headPtr, Tcl_DStringValue(&newName));
d2025 6
d2044 1
a2044 1
	 * add the match onto the interp->result, or call TclDoGlob if there
d2048 1
a2048 1
	return TclMatchFiles(interp, separators, headPtr, tail, p);
d2052 1
a2052 1
	return TclDoGlob(interp, separators, headPtr, p);
d2062 1
a2062 1
	case TCL_PLATFORM_MAC:
d2067 1
a2067 1
	    if (TclAccess(name, F_OK) == 0) {
d2069 2
a2070 1
		    Tcl_AppendElement(interp, name+1);
d2072 2
a2073 1
		    Tcl_AppendElement(interp, name);
d2077 1
d2081 1
d2104 2
a2105 1
	    exists = (TclAccess(name, F_OK) == 0);
d2112 2
a2113 1
		Tcl_AppendElement(interp, name);
d2117 1
a2117 1
	case TCL_PLATFORM_UNIX:
d2126 3
a2128 2
	    if (TclAccess(name, F_OK) == 0) {
		Tcl_AppendElement(interp, name);
d2131 1
d2136 1
@


1.3
log
@Revert part of Mon Jun 5 18:48:32 2000 Christopher Faylor
<cgf@@cygnus.com>, didn't compile.
@
text
@d966 1
d974 1
@


1.2
log
@* generic/tclFileName.c (Tcl_TranslateFileName): Cygwin paths (and Windows in
general, actually) do not need to have '/'s translated into '\'s.
(TclDoGlob): Ditto.
* win/tclWinFile.c (TclMatchFiles): Ditto.
* generic/tclInitScript.h: Look in "../bin/usr/share" as well as
"../bin/share".
@
text
@a965 2
#ifndef __CYGWIN__
    cygwin_conv_to_win32_path (Tcl_DStringValue(bufferPtr)
a972 1
#endif
@


1.1
log
@Initial revision
@
text
@d966 2
d975 1
d1574 1
d1595 1
@


1.1.1.1
log
@import dejagnu-1999-11-08 snapshot
@
text
@@


1.1.1.2
log
@Tcl 8.3 upgrade
@
text
@d7 1
a7 2
 * Copyright (c) 1995-1998 Sun Microsystems, Inc.
 * Copyright (c) 1998-1999 by Scriptics Corporation.
d12 1
a12 1
 * RCS: @@(#) $Id: tclFileName.c,v 1.6.8.2 2000/09/15 16:55:12 spolk Exp $
d20 7
d32 1
a32 1
#define WIN_ROOT_PATTERN "^(([a-zA-Z]:)|[/\\\\][/\\\\]+([^/\\\\]+)[/\\\\]+([^/\\\\]+)|([/\\\\]))([/\\\\])*"
d47 2
a48 6
typedef struct ThreadSpecificData {
    int initialized;
    Tcl_Obj *macRootPatternPtr;
} ThreadSpecificData;

static Tcl_ThreadDataKey dataKey;
a57 9
 * The "globParameters" argument of the globbing functions is an 
 * or'ed combination of the following values:
 */

#define GLOBMODE_NO_COMPLAIN      1
#define GLOBMODE_JOIN             2
#define GLOBMODE_DIR              4

/*
d62 3
a64 3
			    CONST char *user, Tcl_DString *resultPtr));
static CONST char *	ExtractWinRoot _ANSI_ARGS_((CONST char *path,
			    Tcl_DString *resultPtr, int offset, Tcl_PathType *typePtr));
a65 1
static void		FileNameInit _ANSI_ARGS_((void));
d68 1
a68 1
static char *		SplitMacPath _ANSI_ARGS_((CONST char *path,
d70 1
a70 1
static char *		SplitWinPath _ANSI_ARGS_((CONST char *path,
d72 1
a72 1
static char *		SplitUnixPath _ANSI_ARGS_((CONST char *path,
a77 27
 * FileNameInit --
 *
 *	This procedure initializes the patterns used by this module.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Compiles the regular expressions.
 *
 *----------------------------------------------------------------------
 */

static void
FileNameInit()
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    if (!tsdPtr->initialized) {
	tsdPtr->initialized = 1;
	tsdPtr->macRootPatternPtr = Tcl_NewStringObj(MAC_ROOT_PATTERN, -1);
	Tcl_CreateThreadExitHandler(FileNameCleanup, NULL);
    }
}

/*
 *----------------------------------------------------------------------
 *
d96 9
a104 3
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    Tcl_DecrRefCount(tsdPtr->macRootPatternPtr);
    tsdPtr->initialized = 0;
d127 3
a129 3
static CONST char *
ExtractWinRoot(path, resultPtr, offset, typePtr)
    CONST char *path;		/* Path to parse. */
a132 1
    Tcl_PathType *typePtr;	/* Where to store pathType result */
d134 1
a134 1
    FileNameInit();
d136 3
d140 6
a145 9
    if (path[0] == '/' || path[0] == '\\') {
	/* Might be a UNC or Vol-Relative path */
	char *host, *share, *tail;
	int hlen, slen;
	if (path[1] != '/' && path[1] != '\\') {
	    Tcl_DStringSetLength(resultPtr, offset);
	    *typePtr = TCL_PATH_VOLUME_RELATIVE;
	    Tcl_DStringAppend(resultPtr, "/", 1);
	    return &path[1];
a146 1
	host = (char *)&path[2];
d148 3
a150 2
	/* Skip seperators */
	while (host[0] == '/' || host[0] == '\\') host++;
d152 3
a154 11
	for (hlen = 0; host[hlen];hlen++) {
	    if (host[hlen] == '/' || host[hlen] == '\\')
		break;
	}
	if (host[hlen] == 0 || host[hlen+1] == 0) {
	    *typePtr = TCL_PATH_VOLUME_RELATIVE;
	    Tcl_DStringAppend(resultPtr, "/", 1);
	    return &path[2];
	}
	Tcl_DStringSetLength(resultPtr, offset);
	share = &host[hlen];
d156 1
a156 2
	/* Skip seperators */
	while (share[0] == '/' || share[0] == '\\') share++;
d158 4
a161 3
	for (slen = 0; share[slen];slen++) {
	    if (share[slen] == '/' || share[slen] == '\\')
		break;
d163 1
d165 3
a167 1
	Tcl_DStringAppend(resultPtr, host, hlen);
d169 3
a171 17
	Tcl_DStringAppend(resultPtr, share, slen);

	tail = &share[slen];

	/* Skip seperators */
	while (tail[0] == '/' || tail[0] == '\\') tail++;

	*typePtr = TCL_PATH_ABSOLUTE;
	return tail;
    } else if (path[1] == ':') {
	/* Might be a drive sep */
	Tcl_DStringSetLength(resultPtr, offset);

	if (path[2] != '/' && path[2] != '\\') {
	    *typePtr = TCL_PATH_VOLUME_RELATIVE;
	    Tcl_DStringAppend(resultPtr, path, 2);
	    return &path[2];
a172 7
	    char *tail = (char*)&path[3];

	    /* Skip seperators */
	    while (tail[0] == '/' || tail[0] == '\\') tail++;

	    *typePtr = TCL_PATH_ABSOLUTE;
	    Tcl_DStringAppend(resultPtr, path, 2);
a173 6

    return tail;
	}
    } else {
	*typePtr = TCL_PATH_RELATIVE;
	return path;
d175 1
a199 1
    ThreadSpecificData *tsdPtr;
a200 1
    Tcl_RegExp re;
a216 1
		tsdPtr = TCL_TSD_INIT(&dataKey);
d223 9
a231 5
		FileNameInit();
		re = Tcl_GetRegExpFromObj(NULL, tsdPtr->macRootPatternPtr,
			REG_ADVANCED);

		if (!Tcl_RegExpExec(NULL, re, path, path)) {
a232 7
		} else {
		    char *unixRoot, *dummy;

		    Tcl_RegExpRange(re, 2, &unixRoot, &dummy);
		    if (unixRoot) {
			type = TCL_PATH_RELATIVE;
		    }
a238 1
		Tcl_DString ds;
d240 21
a260 3
		Tcl_DStringInit(&ds);
		(VOID)ExtractWinRoot(path, &ds, 0, &type);
		Tcl_DStringFree(&ds);
d295 1
a295 1
    CONST char *path;		/* Pointer to string containing a path. */
a303 1

d388 1
a388 1
    CONST char *path;		/* Pointer to string containing a path. */
d392 1
a392 1
    CONST char *p, *elementStart;
a397 13
#ifdef __QNX__
    /*
     * Check for QNX //<node id> prefix
     */
    if ((path[0] == '/') && (path[1] == '/')
	    && isdigit(UCHAR(path[2]))) { /* INTL: digit */
	path += 3;
	while (isdigit(UCHAR(*path))) { /* INTL: digit */
	    ++path;
	}
    }
#endif

d450 1
a450 1
    CONST char *path;		/* Pointer to string containing a path. */
d454 1
a454 2
    CONST char *p, *elementStart;
    Tcl_PathType type = TCL_PATH_ABSOLUTE;
d456 1
a456 1
    p = ExtractWinRoot(path, bufPtr, 0, &type);
d508 1
a508 1
    CONST char *path;		/* Pointer to string containing a path. */
d513 1
a513 3
    CONST char *p, *elementStart;
    Tcl_RegExp re;
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
d519 7
a525 1
    FileNameInit();
d532 1
a532 6

    re = Tcl_GetRegExpFromObj(NULL, tsdPtr->macRootPatternPtr, REG_ADVANCED);

    if (Tcl_RegExpExec(NULL, re, path, path) == 1) {
	char *start, *end;

d538 1
a538 2
	Tcl_RegExpRange(re, 2, &start, &end);
	if (start) {
d540 2
a541 2
	    Tcl_RegExpRange(re, 0, &start, &end);
	    Tcl_DStringAppend(bufPtr, path, end - start + 1);
d545 2
a546 2
	Tcl_RegExpRange(re, 5, &start, &end);
	if (start) {
d553 5
a557 6
	} else {
	    Tcl_RegExpRange(re, 7, &start, &end);
	    if (start) {
		/*
		 * Mac-style tilde prefixed paths.
		 */
d559 3
a561 5
		isMac = 1;
		i = 7;
	    } else {
		Tcl_RegExpRange(re, 10, &start, &end);
		if (start) {
d563 3
a565 3
		    /*
		     * Normal Unix style paths.
		     */
d567 3
a569 5
		    isMac = 0;
		    i = 10;
		} else {
		    Tcl_RegExpRange(re, 12, &start, &end);
		    if (start) {
d571 3
a573 3
			/*
			 * Normal Mac style paths.
			 */
d575 2
a576 5
			isMac = 1;
			i = 12;
		    }
		}
	    }
d579 2
a580 2
	Tcl_RegExpRange(re, i, &start, &end);
	length = end - start;
d587 1
a587 1
	Tcl_DStringAppend(bufPtr, start, length);
d589 1
a589 1
	p = end;
d693 1
a693 3
    char c, *dest;
    CONST char *p;
    Tcl_PathType type = TCL_PATH_ABSOLUTE;
a708 12
#ifdef __QNX__
		/*
		 * Check for QNX //<node id> prefix
		 */
		if (*p && (strlen(p) > 3) && (p[0] == '/') && (p[1] == '/')
			&& isdigit(UCHAR(p[2]))) { /* INTL: digit */
		    p += 3;
		    while (isdigit(UCHAR(*p))) { /* INTL: digit */
			++p;
		    }
		}
#endif
d770 1
a770 1
		p = ExtractWinRoot(argv[i], resultPtr, oldLength, &type);
d887 1
a887 1
 *---------------------------------------------------------------------------
d892 3
a894 3
 *	interfaces.  If the name starts with a tilde, it will produce a
 *	name where the tilde and following characters have been replaced
 *	by the home directory location for the named user.
d897 6
a902 8
 *	The return value is a pointer to a string containing the name
 *	after tilde substitution.  If there was no tilde substitution,
 *	the return value is a pointer to a copy of the original string.
 *	If there was an error in processing the name, then an error
 *	message is left in the interp's result (if interp was not NULL)
 *	and the return value is NULL.  Space for the return value is
 *	allocated in bufferPtr; the caller must call Tcl_DStringFree()
 *	to free the space if the return value was not NULL.
d905 1
a905 1
 *	None.
d914 7
a920 6
    char *name;			/* File name, which may begin with "~" (to
				 * indicate current user's home directory) or
				 * "~<user>" (to indicate any user's home
				 * directory). */
    Tcl_DString *bufferPtr;	/* Uninitialized or free DString filled
				 * with name after tilde substitution. */
d933 1
a933 1
	Tcl_SplitPath(name, &argc, (char ***) &argv);
d936 2
a937 2
	 * Strip the trailing ':' off of a Mac path before passing the user
	 * name to DoTildeSubst.
d953 1
a953 1
	Tcl_JoinPath(argc, (char **) argv, bufferPtr);
d958 1
a958 1
	Tcl_JoinPath(1, (char **) &name, bufferPtr);
d1034 2
a1035 4
     * In earlier versions, we used to back up to the first period in a series
     * so that "foo..o" would be split into "foo" and "..o".  This is a
     * confusing and usually incorrect behavior, so now we split at the last
     * period in the name.
d1038 5
d1057 3
a1059 4
 *	the substitution, then an error message is left in the interp's
 *	result and the return value is NULL.  On success, the results
 *	are appended to resultPtr, and the contents of resultPtr are
 *	returned.
d1071 1
a1071 1
    CONST char *user;		/* Name of user whose home directory should be
d1073 3
a1075 2
    Tcl_DString *resultPtr;	/* Initialized DString filled with name
				 * after tilde substitution. */
d1080 1
a1080 3
	Tcl_DString dirString;
	
	dir = TclGetEnv("HOME", &dirString);
a1089 1
	Tcl_DStringFree(&dirString);
d1091 3
a1093 1
	if (TclpGetUserHome(user, resultPtr) == NULL) {	
d1108 1
a1108 1
 * Tcl_GlobObjCmd --
d1124 1
a1124 1
Tcl_GlobObjCmd(dummy, interp, objc, objv)
d1127 2
a1128 2
    int objc;				/* Number of arguments. */
    Tcl_Obj *CONST objv[];		/* Argument objects. */
d1130 18
a1147 94
    int index, i, globFlags, pathlength, length, join, dir, result;
    char *string, *pathOrDir, *separators;
    Tcl_Obj *typePtr, *resultPtr, *look;
    Tcl_DString prefix, directory;
    static char *options[] = {
	"-directory", "-join", "-nocomplain", "-path", "-types", "--", NULL
    };
    enum options {
	GLOB_DIR, GLOB_JOIN, GLOB_NOCOMPLAIN, GLOB_PATH, GLOB_TYPE, GLOB_LAST
    };
    enum pathDirOptions {PATH_NONE = -1 , PATH_GENERAL = 0, PATH_DIR = 1};
    GlobTypeData *globTypes = NULL;

    globFlags = 0;
    join = 0;
    dir = PATH_NONE;
    pathOrDir = NULL;
    typePtr = NULL;
    resultPtr = Tcl_GetObjResult(interp);
    for (i = 1; i < objc; i++) {
	if (Tcl_GetIndexFromObj(interp, objv[i], options, "option", 0, &index)
		!= TCL_OK) {
	    string = Tcl_GetStringFromObj(objv[i], &length);
	    if (string[0] == '-') {
		/*
		 * It looks like the command contains an option so signal
		 * an error
		 */
		return TCL_ERROR;
	    } else {
		/*
		 * This clearly isn't an option; assume it's the first
		 * glob pattern.  We must clear the error
		 */
		Tcl_ResetResult(interp);
		break;
	    }
	}
	switch (index) {
	    case GLOB_NOCOMPLAIN:			/* -nocomplain */
	        globFlags |= GLOBMODE_NO_COMPLAIN;
		break;
	    case GLOB_DIR:				/* -dir */
		if (i == (objc-1)) {
		    Tcl_AppendToObj(resultPtr,
			    "missing argument to \"-directory\"", -1);
		    return TCL_ERROR;
		}
		if (dir != -1) {
		    Tcl_AppendToObj(resultPtr,
			    "\"-directory\" cannot be used with \"-path\"",
			    -1);
		    return TCL_ERROR;
		}
		dir = PATH_DIR;
		globFlags |= GLOBMODE_DIR;
		pathOrDir = Tcl_GetStringFromObj(objv[i+1], &pathlength);
		i++;
		break;
	    case GLOB_JOIN:				/* -join */
		join = 1;
		break;
	    case GLOB_PATH:				/* -path */
	        if (i == (objc-1)) {
		    Tcl_AppendToObj(resultPtr,
			    "missing argument to \"-path\"", -1);
		    return TCL_ERROR;
		}
		if (dir != -1) {
		    Tcl_AppendToObj(resultPtr,
			    "\"-path\" cannot be used with \"-directory\"",
			    -1);
		    return TCL_ERROR;
		}
		dir = PATH_GENERAL;
		pathOrDir = Tcl_GetStringFromObj(objv[i+1], &pathlength);
		i++;
		break;
	    case GLOB_TYPE:				/* -types */
	        if (i == (objc-1)) {
		    Tcl_AppendToObj(resultPtr,
			    "missing argument to \"-types\"", -1);
		    return TCL_ERROR;
		}
		typePtr = objv[i+1];
		if (Tcl_ListObjLength(interp, typePtr, &length) != TCL_OK) {
		    return TCL_ERROR;
		}
		i++;
		break;
	    case GLOB_LAST:				/* -- */
	        i++;
		goto endOfForLoop;
		break;
d1150 3
a1152 3
    endOfForLoop:
    if (objc - i < 1) {
        Tcl_WrongNumArgs(interp, 1, objv, "?switches? name ?name ...?");
d1156 4
a1159 2
    separators = NULL;		/* lint. */
    switch (tclPlatform) {
d1167 1
a1167 1
	    separators = ":";
d1169 3
a1171 3
    }
    if (dir == PATH_GENERAL) {
	char *last;
d1174 1
a1174 1
	 * Find the last path separator in the path
a1175 42
	last = pathOrDir + pathlength;
	for (; last != pathOrDir; last--) {
	    if (strchr(separators, *(last-1)) != NULL) {
		break;
	    }
	}
	if (last == pathOrDir + pathlength) {
	    /* It's really a directory */
	    dir = 1;
	} else {
	    Tcl_DString pref;
	    char *search, *find;
	    Tcl_DStringInit(&pref);
	    Tcl_DStringInit(&directory);
	    if (last == pathOrDir) {
		/* The whole thing is a prefix */
		Tcl_DStringAppend(&pref, pathOrDir, -1);
		pathOrDir = NULL;
	    } else {
		/* Have to split off the end */
		Tcl_DStringAppend(&pref, last, pathOrDir+pathlength-last);
		Tcl_DStringAppend(&directory, pathOrDir, last-pathOrDir-1);
		pathOrDir = Tcl_DStringValue(&directory);
	    }
	    /* Need to quote 'prefix' */
	    Tcl_DStringInit(&prefix);
	    search = Tcl_DStringValue(&pref);
	    while ((find = (strpbrk(search, "\\[]*?{}"))) != NULL) {
	        Tcl_DStringAppend(&prefix, search, find-search);
	        Tcl_DStringAppend(&prefix, "\\", 1);
	        Tcl_DStringAppend(&prefix, find, 1);
	        search = find+1;
	        if (*search == '\0') {
	            break;
	        }
	    }
	    if (*search != '\0') {
		Tcl_DStringAppend(&prefix, search, -1);
	    }
	    Tcl_DStringFree(&pref);
	}
    }
d1177 13
a1189 49
    if (typePtr != NULL) {
	/* 
	 * The rest of the possible type arguments (except 'd') are
	 * platform specific.  We don't complain when they are used
	 * on an incompatible platform.
	 */
	Tcl_ListObjLength(interp, typePtr, &length);
	globTypes = (GlobTypeData*) ckalloc(sizeof(GlobTypeData));
	globTypes->type = 0;
	globTypes->perm = 0;
	globTypes->macType = NULL;
	globTypes->macCreator = NULL;
	while(--length >= 0) {
	    int len;
	    char *str;
	    Tcl_ListObjIndex(interp, typePtr, length, &look);
	    str = Tcl_GetStringFromObj(look, &len);
	    if (strcmp("readonly", str) == 0) {
		globTypes->perm |= TCL_GLOB_PERM_RONLY;
	    } else if (strcmp("hidden", str) == 0) {
		globTypes->perm |= TCL_GLOB_PERM_HIDDEN;
	    } else if (len == 1) {
		switch (str[0]) {
		  case 'r':
		    globTypes->perm |= TCL_GLOB_PERM_R;
		    break;
		  case 'w':
		    globTypes->perm |= TCL_GLOB_PERM_W;
		    break;
		  case 'x':
		    globTypes->perm |= TCL_GLOB_PERM_X;
		    break;
		  case 'b':
		    globTypes->type |= TCL_GLOB_TYPE_BLOCK;
		    break;
		  case 'c':
		    globTypes->type |= TCL_GLOB_TYPE_CHAR;
		    break;
		  case 'd':
		    globTypes->type |= TCL_GLOB_TYPE_DIR;
		    break;
		  case 'p':
		    globTypes->type |= TCL_GLOB_TYPE_PIPE;
		    break;
		  case 'f':
		    globTypes->type |= TCL_GLOB_TYPE_FILE;
		    break;
	          case 'l':
		    globTypes->type |= TCL_GLOB_TYPE_LINK;
a1190 10
		  case 's':
		    globTypes->type |= TCL_GLOB_TYPE_SOCK;
		    break;
		  default:
		    goto badTypesArg;
		}
	    } else if (len == 4) {
		/* This is assumed to be a MacOS file type */
		if (globTypes->macType != NULL) {
		    goto badMacTypesArg;
a1191 41
		globTypes->macType = look;
		Tcl_IncrRefCount(look);
	    } else {
		Tcl_Obj* item;
		if ((Tcl_ListObjLength(NULL, look, &len) == TCL_OK) &&
			(len == 3)) {
		    Tcl_ListObjIndex(interp, look, 0, &item);
		    if (!strcmp("macintosh", Tcl_GetString(item))) {
			Tcl_ListObjIndex(interp, look, 1, &item);
			if (!strcmp("type", Tcl_GetString(item))) {
			    Tcl_ListObjIndex(interp, look, 2, &item);
			    if (globTypes->macType != NULL) {
				goto badMacTypesArg;
			    }
			    globTypes->macType = item;
			    Tcl_IncrRefCount(item);
			    continue;
			} else if (!strcmp("creator", Tcl_GetString(item))) {
			    Tcl_ListObjIndex(interp, look, 2, &item);
			    if (globTypes->macCreator != NULL) {
				goto badMacTypesArg;
			    }
			    globTypes->macCreator = item;
			    Tcl_IncrRefCount(item);
			    continue;
			}
		    }
		}
		/*
		 * Error cases
		 */
		badTypesArg:
		Tcl_AppendToObj(resultPtr, "bad argument to \"-types\": ", -1);
		Tcl_AppendObjToObj(resultPtr, look);
		result = TCL_ERROR;
		goto endOfGlob;
		badMacTypesArg:
		Tcl_AppendToObj(resultPtr,
			"only one MacOS type or creator argument to \"-types\" allowed", -1);
		result = TCL_ERROR;
		goto endOfGlob;
a1192 2
	}
    }
d1194 24
a1217 43
    /* 
     * Now we perform the actual glob below.  This may involve joining
     * together the pattern arguments, dealing with particular file types
     * etc.  We use a 'goto' to ensure we free any memory allocated along
     * the way.
     */
    objc -= i;
    objv += i;
    /* 
     * We re-retrieve this, in case it was changed in 
     * the Tcl_ResetResult above 
     */
    resultPtr = Tcl_GetObjResult(interp);
    result = TCL_OK;
    if (join) {
	if (dir != PATH_GENERAL) {
	    Tcl_DStringInit(&prefix);
	}
	for (i = 0; i < objc; i++) {
	    string = Tcl_GetStringFromObj(objv[i], &length);
	    Tcl_DStringAppend(&prefix, string, length);
	    if (i != objc -1) {
		Tcl_DStringAppend(&prefix, separators, 1);
	    }
	}
	if (TclGlob(interp, Tcl_DStringValue(&prefix), pathOrDir,
		globFlags, globTypes) != TCL_OK) {
	    result = TCL_ERROR;
	    goto endOfGlob;
	}
    } else {
	if (dir == PATH_GENERAL) {
	    Tcl_DString str;
	    for (i = 0; i < objc; i++) {
		Tcl_DStringInit(&str);
		if (dir == PATH_GENERAL) {
		    Tcl_DStringAppend(&str, Tcl_DStringValue(&prefix),
			    Tcl_DStringLength(&prefix));
		}
		string = Tcl_GetStringFromObj(objv[i], &length);
		Tcl_DStringAppend(&str, string, length);
		if (TclGlob(interp, Tcl_DStringValue(&str), pathOrDir,
			globFlags, globTypes) != TCL_OK) {
d1219 1
a1219 2
		    Tcl_DStringFree(&str);
		    goto endOfGlob;
d1222 3
a1224 1
	    Tcl_DStringFree(&str);
d1226 1
a1226 136
	    for (i = 0; i < objc; i++) {
		string = Tcl_GetString(objv[i]);
		if (TclGlob(interp, string, pathOrDir,
			globFlags, globTypes) != TCL_OK) {
		    result = TCL_ERROR;
		    goto endOfGlob;
		}
	    }
	}
    }
    if ((globFlags & GLOBMODE_NO_COMPLAIN) == 0) {
	if (Tcl_ListObjLength(interp, Tcl_GetObjResult(interp),
		&length) != TCL_OK) {
	    /* This should never happen.  Maybe we should be more dramatic */
	    result = TCL_ERROR;
	    goto endOfGlob;
	}
	if (length == 0) {
	    Tcl_AppendResult(interp, "no files matched glob pattern",
		    (join || (objc == 1)) ? " \"" : "s \"", (char *) NULL);
	    if (join) {
		Tcl_AppendResult(interp, Tcl_DStringValue(&prefix),
			(char *) NULL);
	    } else {
		char *sep = "";
		for (i = 0; i < objc; i++) {
		    string = Tcl_GetString(objv[i]);
		    Tcl_AppendResult(interp, sep, string, (char *) NULL);
		    sep = " ";
		}
	    }
	    Tcl_AppendResult(interp, "\"", (char *) NULL);
	    result = TCL_ERROR;
	}
    }
  endOfGlob:
    if (join || (dir == PATH_GENERAL)) {
	Tcl_DStringFree(&prefix);
	if (dir == PATH_GENERAL) {
	    Tcl_DStringFree(&directory);
	}
    }
    if (globTypes != NULL) {
	if (globTypes->macType != NULL) {
	    Tcl_DecrRefCount(globTypes->macType);
	}
	if (globTypes->macCreator != NULL) {
	    Tcl_DecrRefCount(globTypes->macCreator);
	}
	ckfree((char *) globTypes);
    }
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * TclGlob --
 *
 *	This procedure prepares arguments for the TclDoGlob call.
 *	It sets the separator string based on the platform, performs
 *      tilde substitution, and calls TclDoGlob.
 *
 * Results:
 *	The return value is a standard Tcl result indicating whether
 *	an error occurred in globbing.  After a normal return the
 *	result in interp (set by TclDoGlob) holds all of the file names
 *	given by the dir and rem arguments.  After an error the
 *	result in interp will hold an error message.
 *
 * Side effects:
 *	The currentArgString is written to.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
int
TclGlob(interp, pattern, unquotedPrefix, globFlags, types)
    Tcl_Interp *interp;		/* Interpreter for returning error message
				 * or appending list of matching file names. */
    char *pattern;		/* Glob pattern to match. Must not refer
				 * to a static string. */
    char *unquotedPrefix;	/* Prefix to glob pattern, if non-null, which
                             	 * is considered literally.  May be static. */
    int globFlags;		/* Stores or'ed combination of flags */
    GlobTypeData *types;	/* Struct containing acceptable types.
				 * May be NULL. */
{
    char *separators;
    char *head, *tail, *start;
    char c;
    int result;
    Tcl_DString buffer;

    separators = NULL;		/* lint. */
    switch (tclPlatform) {
	case TCL_PLATFORM_UNIX:
	    separators = "/";
	    break;
	case TCL_PLATFORM_WINDOWS:
	    separators = "/\\:";
	    break;
	case TCL_PLATFORM_MAC:
	    if (unquotedPrefix == NULL) {
		separators = (strchr(pattern, ':') == NULL) ? "/" : ":";
	    } else {
		separators = ":";
	    }
	    break;
    }

    Tcl_DStringInit(&buffer);
    if (unquotedPrefix != NULL) {
	start = unquotedPrefix;
    } else {
	start = pattern;
    }

    /*
     * Perform tilde substitution, if needed.
     */

    if (start[0] == '~') {
	
	/*
	 * Find the first path separator after the tilde.
	 */
	for (tail = start; *tail != '\0'; tail++) {
	    if (*tail == '\\') {
		if (strchr(separators, tail[1]) != NULL) {
		    break;
		}
	    } else if (strchr(separators, *tail) != NULL) {
		break;
	    }
d1229 3
a1231 30
	/*
	 * Determine the home directory for the specified user.  Note that
	 * we don't allow special characters in the user name.
	 */
	
	c = *tail;
	*tail = '\0';
	/*
	 * I don't think we need to worry about special characters in
	 * the user name anymore (Vince Darley, June 1999), since the
	 * new code is designed to handle special chars.
	 */
#ifndef NOT_NEEDED_ANYMORE
	head = DoTildeSubst(interp, start+1, &buffer);
#else
	
	if (strpbrk(start+1, "\\[]*?{}") == NULL) {
	    head = DoTildeSubst(interp, start+1, &buffer);
	} else {
	    if (!(globFlags & GLOBMODE_NO_COMPLAIN)) {
		Tcl_ResetResult(interp);
		Tcl_AppendResult(interp, "globbing characters not ",
			"supported in user names", (char *) NULL);
	    }
	    head = NULL;
	}
#endif
	*tail = c;
	if (head == NULL) {
	    if (globFlags & GLOBMODE_NO_COMPLAIN) {
d1234 1
a1234 1
		 * or save the interp result or use another mechanism
d1241 2
a1242 1
		return TCL_OK;
d1244 1
a1244 1
		return TCL_ERROR;
a1246 12
	if (head != Tcl_DStringValue(&buffer)) {
	    Tcl_DStringAppend(&buffer, head, -1);
	}
	if (unquotedPrefix != NULL) {
	    Tcl_DStringAppend(&buffer, tail, -1);
	    tail = pattern;
	}
    } else {
	tail = pattern;
	if (unquotedPrefix != NULL) {
	    Tcl_DStringAppend(&buffer,unquotedPrefix,-1);
	}
d1248 9
a1256 10
    /* 
     * If the prefix is a directory, make sure it ends in a directory
     * separator.
     */
    if (unquotedPrefix != NULL) {
	if (globFlags & GLOBMODE_DIR) {
	    c = Tcl_DStringValue(&buffer)[Tcl_DStringLength(&buffer)-1];
	    if (strchr(separators, c) == NULL) {
		Tcl_DStringAppend(&buffer,separators,1);
	    }
d1258 2
d1261 1
a1261 2

    result = TclDoGlob(interp, separators, &buffer, tail, types);
a1262 6
    if (result != TCL_OK) {
	if (globFlags & GLOBMODE_NO_COMPLAIN) {
	    Tcl_ResetResult(interp);
	    return TCL_OK;
	}
    }
d1326 1
a1326 5
 *	remainder are assumed to be native format paths.  The prefix 
 *	contained in 'headPtr' is not used as a glob pattern, simply
 *	as a path specifier, so it can contain unquoted glob-sensitive
 *	characters (if the directories to which it points contain
 *	such strange characters).
d1342 1
a1342 1
TclDoGlob(interp, separators, headPtr, tail, types)
d1349 1
a1349 4
    char *tail;			/* The unexpanded remainder of the path.
				 * Must not be a pointer to a static string. */
    GlobTypeData *types;	/* List object containing list of acceptable types.
				 * May be NULL. */
d1353 1
a1353 1
    char *name, *p, *openBrace, *closeBrace, *firstSpecialChar, savedChar;
a1354 1
    
d1506 1
a1506 1
		    headPtr, Tcl_DStringValue(&newName), types);
a1524 6

	/*
	 * Note that we are modifying the string in place.  This won't work
	 * if the string is a static.
	 */

d1538 1
a1538 1
	 * add the match onto the interp's result, or call TclDoGlob if there
d1542 1
a1542 1
	return TclpMatchFilesTypes(interp, separators, headPtr, tail, p, types);
d1546 1
a1546 1
	return TclDoGlob(interp, separators, headPtr, p, types);
d1556 1
a1556 1
	case TCL_PLATFORM_MAC: {
d1561 1
a1561 1
	    if (TclpAccess(name, F_OK) == 0) {
d1563 1
a1563 2
		    Tcl_ListObjAppendElement(interp, Tcl_GetObjResult(interp), 
					     Tcl_NewStringObj(name + 1,-1));
d1565 1
a1565 2
		    Tcl_ListObjAppendElement(interp, Tcl_GetObjResult(interp), 
					     Tcl_NewStringObj(name,-1));
a1568 1
	}
a1570 1
	    
d1592 1
a1592 2
	    exists = (TclpAccess(name, F_OK) == 0);

d1599 1
a1599 2
		Tcl_ListObjAppendElement(interp, Tcl_GetObjResult(interp), 
					 Tcl_NewStringObj(name,-1));
d1603 1
a1603 1
	case TCL_PLATFORM_UNIX: {
d1612 2
a1613 3
	    if (TclpAccess(name, F_OK) == 0) {
		Tcl_ListObjAppendElement(interp, Tcl_GetObjResult(interp), 
					 Tcl_NewStringObj(name,-1));
a1615 1
	}
a1619 1

@


1.1.1.3
log
@import tcl 8.4.0
@
text
@d13 1
a13 1
 * RCS: @@(#) $Id: tclFileName.c,v 1.37 2002/06/05 11:59:33 das Exp $
d20 4
a23 4
/* 
 * This define is used to activate Tcl's interpretation of Unix-style
 * paths (containing forward slashes, '.' and '..') on MacOS.  A 
 * side-effect of this is that some paths become ambiguous.
a24 1
#define MAC_UNDERSTANDS_UNIX_PATHS
d26 2
a27 1
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
d31 1
a31 10
 * Unix-style paths, and Mac paths.  The various subexpressions in this
 * can be summarised as follows: ^(/..|~user/unix|~user:mac|/unix|mac:dir).
 * The subexpression indices which match the root portions, are as follows:
 * 
 * degenerate unix-style: 2
 * unix-tilde: 5
 * mac-tilde: 7
 * unix-style: 9 (or 10 to cut off the irrelevant header).
 * mac: 12
 * 
a47 5
static void		FileNameCleanup _ANSI_ARGS_((ClientData clientData));
static void		FileNameInit _ANSI_ARGS_((void));

#endif

d56 9
d68 1
a68 1
static CONST char *	DoTildeSubst _ANSI_ARGS_((Tcl_Interp *interp,
d71 3
a73 2
			    Tcl_DString *resultPtr, int offset, 
			    Tcl_PathType *typePtr));
d76 6
a81 4
static Tcl_Obj*		SplitMacPath _ANSI_ARGS_((CONST char *path));
static Tcl_Obj*		SplitWinPath _ANSI_ARGS_((CONST char *path));
static Tcl_Obj*		SplitUnixPath _ANSI_ARGS_((CONST char *path));
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
a134 1
#endif
d164 3
d169 1
a169 1
	CONST char *host, *share, *tail;
d176 2
a177 2
	}
	host = &path[2];
d179 1
a179 1
	/* Skip separators */
a186 12
	    /* 
	     * The path given is simply of the form 
	     * '/foo', '//foo', '/////foo' or the same
	     * with backslashes.  If there is exactly
	     * one leading '/' the path is volume relative
	     * (see filename man page).  If there are more
	     * than one, we are simply assuming they
	     * are superfluous and we trim them away.
	     * (An alternative interpretation would
	     * be that it is a host name, but we have
	     * been documented that that is not the case).
	     */
d194 1
a194 1
	/* Skip separators */
d208 1
a208 1
	/* Skip separators */
d213 1
a213 1
    } else if (*path && path[1] == ':') {
d221 1
a221 1
	} else {
d224 2
a225 2
	    /* Skip separators */
	    while (*tail && (tail[0] == '/' || tail[0] == '\\')) tail++;
d229 1
a229 1
	    Tcl_DStringAppend(resultPtr, "/", 1);
d231 1
a231 1
	    return tail;
a245 4
 *	
 *	The objectified Tcl_FSGetPathType should be used in
 *	preference to this function (as you can see below, this
 *	is just a wrapper around that other function).
d259 1
a259 1
    CONST char *path;
d261 9
a269 29
    Tcl_PathType type;
    Tcl_Obj *tempObj = Tcl_NewStringObj(path,-1);
    Tcl_IncrRefCount(tempObj);
    type = Tcl_FSGetPathType(tempObj);
    Tcl_DecrRefCount(tempObj);
    return type;
}

/*
 *----------------------------------------------------------------------
 *
 * TclpGetNativePathType --
 *
 *	Determines whether a given path is relative to the current
 *	directory, relative to the current volume, or absolute, but
 *	ONLY FOR THE NATIVE FILESYSTEM. This function is called from
 *	tclIOUtil.c (but needs to be here due to its dependence on
 *	static variables/functions in this file).  The exported
 *	function Tcl_FSGetPathType should be used by extensions.
 *
 * Results:
 *	Returns one of TCL_PATH_ABSOLUTE, TCL_PATH_RELATIVE, or
 *	TCL_PATH_VOLUME_RELATIVE.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
d271 2
a272 19
Tcl_PathType
TclpGetNativePathType(pathObjPtr, driveNameLengthPtr, driveNameRef)
    Tcl_Obj *pathObjPtr;
    int *driveNameLengthPtr;
    Tcl_Obj **driveNameRef;
{
    Tcl_PathType type = TCL_PATH_ABSOLUTE;
    int pathLen;
    char *path = Tcl_GetStringFromObj(pathObjPtr, &pathLen);
    
    if (path[0] == '~') {
	/* 
	 * This case is common to all platforms.
	 * Paths that begin with ~ are absolute.
	 */
	if (driveNameLengthPtr != NULL) {
	    char *end = path + 1;
	    while ((*end != '\0') && (*end != '/')) {
		end++;
d274 8
a281 7
	    *driveNameLengthPtr = end - path;
	}
    } else {
	switch (tclPlatform) {
	    case TCL_PLATFORM_UNIX: {
		char *origPath = path;
	        
d283 2
a284 1
		 * Paths that begin with / are absolute.
d287 5
a291 27
#ifdef __QNX__
		/*
		 * Check for QNX //<node id> prefix
		 */
		if (*path && (pathLen > 3) && (path[0] == '/') 
		  && (path[1] == '/') && isdigit(UCHAR(path[2]))) {
		    path += 3;
		    while (isdigit(UCHAR(*path))) {
			++path;
		    }
		}
#endif
		if (path[0] == '/') {
		    if (driveNameLengthPtr != NULL) {
			/* 
			 * We need this addition in case the QNX code 
			 * was used 
			 */
			*driveNameLengthPtr = (1 + path - origPath);
		    }
		} else {
		    type = TCL_PATH_RELATIVE;
		}
		break;
	    }
	    case TCL_PLATFORM_MAC:
		if (path[0] == ':') {
d294 1
a294 10
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
		    ThreadSpecificData *tsdPtr;
		    Tcl_RegExp re;

		    tsdPtr = TCL_TSD_INIT(&dataKey);

		    /*
		     * Since we have eliminated the easy cases, use the
		     * root pattern to look for the other types.
		     */
d296 2
a297 5
		    FileNameInit();
		    re = Tcl_GetRegExpFromObj(NULL, tsdPtr->macRootPatternPtr,
			    REG_ADVANCED);

		    if (!Tcl_RegExpExec(NULL, re, path, path)) {
a298 40
		    } else {
			CONST char *root, *end;
			Tcl_RegExpRange(re, 2, &root, &end);
			if (root != NULL) {
			    type = TCL_PATH_RELATIVE;
			} else {
			    if (driveNameLengthPtr != NULL) {
				Tcl_RegExpRange(re, 0, &root, &end);
				*driveNameLengthPtr = end - root;
			    }
			    if (driveNameRef != NULL) {
				if (*root == '/') {
				    char *c;
				    int gotColon = 0;
				    *driveNameRef = Tcl_NewStringObj(root + 1,
					    end - root -1);
				    c = Tcl_GetString(*driveNameRef);
				    while (*c != '\0') {
					if (*c == '/') {
					    gotColon++;
					    *c = ':';
					}
					c++;
				    }
				    /* 
				     * If there is no colon, we have just a
				     * volume name so we must add a colon so
				     * it is an absolute path.
				     */
				    if (gotColon == 0) {
				        Tcl_AppendToObj(*driveNameRef, ":", 1);
				    } else if ((gotColon > 1) &&
					    (*(c-1) == ':')) {
					/* We have an extra colon */
				        Tcl_SetObjLength(*driveNameRef, 
					  c - Tcl_GetString(*driveNameRef) - 1);
				    }
				}
			    }
			}
a299 17
#else
		    if (path[0] == '~') {
		    } else if (path[0] == ':') {
			type = TCL_PATH_RELATIVE;
		    } else {
			char *colonPos = strchr(path,':');
			if (colonPos == NULL) {
			    type = TCL_PATH_RELATIVE;
			} else {
			}
		    }
		    if (type == TCL_PATH_ABSOLUTE) {
			if (driveNameLengthPtr != NULL) {
			    *driveNameLengthPtr = strlen(path);
			}
		    }
#endif
d301 5
a305 3
		break;
	    
	    case TCL_PLATFORM_WINDOWS: {
d307 1
a307 2
		CONST char *rootEnd;
		
d309 1
a309 9
		rootEnd = ExtractWinRoot(path, &ds, 0, &type);
		if ((rootEnd != path) && (driveNameLengthPtr != NULL)) {
		    *driveNameLengthPtr = rootEnd - path;
		    if (driveNameRef != NULL) {
			*driveNameRef = Tcl_NewStringObj(Tcl_DStringValue(&ds),
				Tcl_DStringLength(&ds));
			Tcl_IncrRefCount(*driveNameRef);
		    }
		}
a310 1
		break;
d312 1
a312 1
	}
a317 59
 *---------------------------------------------------------------------------
 *
 * TclpNativeSplitPath --
 *
 *      This function takes the given Tcl_Obj, which should be a valid
 *      path, and returns a Tcl List object containing each segment
 *      of that path as an element.
 *
 *      Note this function currently calls the older Split(Plat)Path
 *      functions, which require more memory allocation than is
 *      desirable.
 *      
 * Results:
 *      Returns list object with refCount of zero.  If the passed in
 *      lenPtr is non-NULL, we use it to return the number of elements
 *      in the returned list.
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
 */

Tcl_Obj* 
TclpNativeSplitPath(pathPtr, lenPtr)
    Tcl_Obj *pathPtr;		/* Path to split. */
    int *lenPtr;		/* int to store number of path elements. */
{
    Tcl_Obj *resultPtr = NULL;  /* Needed only to prevent gcc warnings. */

    /*
     * Perform platform specific splitting. 
     */

    switch (tclPlatform) {
	case TCL_PLATFORM_UNIX:
	    resultPtr = SplitUnixPath(Tcl_GetString(pathPtr));
	    break;

	case TCL_PLATFORM_WINDOWS:
	    resultPtr = SplitWinPath(Tcl_GetString(pathPtr));
	    break;
	    
	case TCL_PLATFORM_MAC:
	    resultPtr = SplitMacPath(Tcl_GetString(pathPtr));
	    break;
    }

    /*
     * Compute the number of elements in the result.
     */

    if (lenPtr != NULL) {
	Tcl_ListObjLength(NULL, resultPtr, lenPtr);
    }
    return resultPtr;
}

/*
d348 1
a348 1
    CONST char ***argvPtr;	/* Pointer to place to store pointer to array
d351 5
a355 4
    Tcl_Obj *resultPtr = NULL;  /* Needed only to prevent gcc warnings. */
    Tcl_Obj *tmpPtr, *eltPtr;
    int i, size, len;
    char *p, *str;
d358 3
a360 1
     * Perform the splitting, using objectified, vfs-aware code.
d363 18
a380 4
    tmpPtr = Tcl_NewStringObj(path, -1);
    Tcl_IncrRefCount(tmpPtr);
    resultPtr = Tcl_FSSplitPath(tmpPtr, argcPtr);
    Tcl_DecrRefCount(tmpPtr);
d382 6
a387 7
    /* Calculate space required for the result */
    
    size = 1;
    for (i = 0; i < *argcPtr; i++) {
	Tcl_ListObjIndex(NULL, resultPtr, i, &eltPtr);
	Tcl_GetStringFromObj(eltPtr, &len);
	size += len + 1;
d391 2
a392 2
     * Allocate a buffer large enough to hold the contents of all of
     * the list plus the argv pointers and the terminating NULL pointer.
d395 1
a395 1
    *argvPtr = (CONST char **) ckalloc((unsigned)
d400 1
a400 1
     * the list in, piece by piece.
d404 2
a405 7
    for (i = 0; i < *argcPtr; i++) {
	Tcl_ListObjIndex(NULL, resultPtr, i, &eltPtr);
	str = Tcl_GetStringFromObj(eltPtr, &len);
	memcpy((VOID *) p, (VOID *) str, (size_t) len+1);
	p += len+1;
    }
    
a409 2
    p = (char *) &(*argvPtr)[(*argcPtr) + 1];

d416 1
a416 5
    /*
     * Free the result ptr given to us by Tcl_FSSplitPath
     */

    Tcl_DecrRefCount(resultPtr);
d424 1
a424 1
 *	This routine is used by Tcl_(FS)SplitPath to handle splitting
d428 2
a429 1
 *	Returns a newly allocated Tcl list object.
d437 2
a438 2
static Tcl_Obj*
SplitUnixPath(path)
d440 1
a443 1
    Tcl_Obj *result = Tcl_NewObj();
d463 1
a463 1
	Tcl_ListObjAppendElement(NULL, result, Tcl_NewStringObj("/",1));
a480 1
	    Tcl_Obj *nextElt;
d482 1
a482 4
		nextElt = Tcl_NewStringObj("./",2);
		Tcl_AppendToObj(nextElt, elementStart, length);
	    } else {
		nextElt = Tcl_NewStringObj(elementStart, length);
d484 2
a485 1
	    Tcl_ListObjAppendElement(NULL, result, nextElt);
d491 1
a491 1
    return result;
a492 1

d499 1
a499 1
 *	This routine is used by Tcl_(FS)SplitPath to handle splitting
d503 2
a504 1
 *	Returns a newly allocated Tcl list object.
d512 2
a513 2
static Tcl_Obj*
SplitWinPath(path)
d515 1
d520 2
a521 5
    Tcl_DString buf;
    Tcl_Obj *result = Tcl_NewObj();
    Tcl_DStringInit(&buf);
    
    p = ExtractWinRoot(path, &buf, 0, &type);
d528 1
a528 3
	Tcl_ListObjAppendElement(NULL, result, 
				 Tcl_NewStringObj(Tcl_DStringValue(&buf), 
						  Tcl_DStringLength(&buf)));
d530 1
a530 2
    Tcl_DStringFree(&buf);
    
a542 1
	    Tcl_Obj *nextElt;
d544 1
a544 4
		nextElt = Tcl_NewStringObj("./",2);
		Tcl_AppendToObj(nextElt, elementStart, length);
	    } else {
		nextElt = Tcl_NewStringObj(elementStart, length);
d546 2
a547 1
	    Tcl_ListObjAppendElement(NULL, result, nextElt);
d551 1
a551 1
    return result;
d559 1
a559 1
 *	This routine is used by Tcl_(FS)SplitPath to handle splitting
d563 1
a563 1
 *	Returns a newly allocated Tcl list object.
d571 2
a572 2
static Tcl_Obj*
SplitMacPath(path)
d574 1
d577 1
a577 1
    int length;
a578 2
    Tcl_Obj *result;
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
a579 1
    int i;
d581 1
a581 5
#endif
    
    result = Tcl_NewObj();
    
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
d597 1
a597 2
	CONST char *start, *end;
	Tcl_Obj *nextElt;
d606 1
a606 1
	    Tcl_Obj *elt = Tcl_NewStringObj(":", 1);
d608 2
a609 3
	    Tcl_AppendToObj(elt, path, end - start);
	    Tcl_ListObjAppendElement(NULL, result, elt);
	    return result;
d632 1
d642 1
d653 1
d658 2
a659 1
	 * Append the element and terminate it with a : 
d662 2
a663 3
	nextElt = Tcl_NewStringObj(start, length);
	Tcl_AppendToObj(nextElt, ":", 1);
	Tcl_ListObjAppendElement(NULL, result, nextElt);
a668 28
#else
    if ((path[0] != ':') && (path[0] == '~' || (strchr(path,':') != NULL))) {
	CONST char *end;
	Tcl_Obj *nextElt;

	isMac = 1;
	
	end = strchr(path,':');
	if (end == NULL) {
	    length = strlen(path);
	} else {
	    length = end - path;
	}

	/*
	 * Append the element and terminate it with a :
	 */

	nextElt = Tcl_NewStringObj(path, length);
	Tcl_AppendToObj(nextElt, ":", 1);
	Tcl_ListObjAppendElement(NULL, result, nextElt);
	p = path + length;
    } else {
	isMac = (strchr(path, ':') != NULL);
	isMac = 1;
	p = path;
    }
#endif
a674 3
	 * (This is no longer true if MAC_UNDERSTANDS_UNIX_PATHS 
	 * is false, so we must check whether 'p' points to the
	 * end of the string.)
d676 2
a677 5
	elementStart = p;
	if (*p == ':') {
	    p++;
	}
	
d682 1
a682 2
		    Tcl_ListObjAppendElement(NULL, result,
			    Tcl_NewStringObj("::", 2));
d695 2
a696 2
		Tcl_ListObjAppendElement(NULL, result, 
			Tcl_NewStringObj(elementStart, length));
d700 2
a701 8
	if (elementStart[0] != ':') {
	    if (elementStart[0] != '\0') {
		Tcl_ListObjAppendElement(NULL, result, 
			Tcl_NewStringObj(elementStart, -1));
	    }
	} else {
	    if (elementStart[1] != '\0' || elementStart == path) {
		if ((elementStart[1] != '~') && (elementStart[1] != '\0')
a703 3
		}
		Tcl_ListObjAppendElement(NULL, result, 
			Tcl_NewStringObj(elementStart, -1));
d705 2
d722 1
a722 2
		    Tcl_ListObjAppendElement(NULL, result, 
					     Tcl_NewStringObj(":", 1));
d725 1
a725 2
		    Tcl_ListObjAppendElement(NULL, result, 
					     Tcl_NewStringObj("::", 2));
a726 1
		    Tcl_Obj *nextElt;
d728 1
a728 4
			nextElt = Tcl_NewStringObj(":",1);
			Tcl_AppendToObj(nextElt, elementStart, length);
		    } else {
			nextElt = Tcl_NewStringObj(elementStart, length);
d730 2
a731 1
		    Tcl_ListObjAppendElement(NULL, result, nextElt);
d739 1
a739 1
    return result;
d743 1
a743 1
 *---------------------------------------------------------------------------
d745 1
a745 1
 * Tcl_FSJoinToPath --
d747 1
a747 3
 *      This function takes the given object, which should usually be a
 *      valid path or NULL, and joins onto it the array of paths
 *      segments given.
d750 3
a752 1
 *      Returns object with refCount of zero
d755 1
a755 1
 *	None.
d757 1
a757 1
 *---------------------------------------------------------------------------
d760 5
a764 5
Tcl_Obj* 
Tcl_FSJoinToPath(basePtr, objc, objv)
    Tcl_Obj *basePtr;
    int objc;
    Tcl_Obj *CONST objv[];
d766 5
a770 2
    int i;
    Tcl_Obj *lobj, *ret;
d772 13
a784 29
    if (basePtr == NULL) {
	lobj = Tcl_NewListObj(0, NULL);
    } else {
	lobj = Tcl_NewListObj(1, &basePtr);
    }
    
    for (i = 0; i<objc;i++) {
	Tcl_ListObjAppendElement(NULL, lobj, objv[i]);
    }
    ret = Tcl_FSJoinPath(lobj, -1);
    Tcl_DecrRefCount(lobj);
    return ret;
}

/*
 *---------------------------------------------------------------------------
 *
 * TclpNativeJoinPath --
 *
 *      'prefix' is absolute, 'joining' is relative to prefix.
 *
 * Results:
 *      modifies prefix
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
 */
d786 25
a810 9
void
TclpNativeJoinPath(prefix, joining)
    Tcl_Obj *prefix;
    char* joining;
{
    int length, needsSep;
    char *dest, *p, *start;
    
    start = Tcl_GetStringFromObj(prefix, &length);
d812 3
a814 16
    /*
     * Remove the ./ from tilde prefixed elements unless
     * it is the first component.
     */
    
    p = joining;
    
    if (length != 0) {
	if ((p[0] == '.') && (p[1] == '/') && (p[2] == '~')) {
	    p += 2;
	}
    }
       
    if (*p == '\0') {
	return;
    }
d816 3
d820 6
a825 5
    switch (tclPlatform) {
        case TCL_PLATFORM_UNIX:
	    /*
	     * Append a separator if needed.
	     */
d827 4
a830 10
	    if (length > 0 && (start[length-1] != '/')) {
		Tcl_AppendToObj(prefix, "/", 1);
		length++;
	    }
	    needsSep = 0;
	    
	    /*
	     * Append the element, eliminating duplicate and trailing
	     * slashes.
	     */
d832 8
a839 10
	    Tcl_SetObjLength(prefix, length + (int) strlen(p));
	    
	    dest = Tcl_GetString(prefix) + length;
	    for (; *p != '\0'; p++) {
		if (*p == '/') {
		    while (p[1] == '/') {
			p++;
		    }
		    if (p[1] != '\0') {
			if (needsSep) {
d842 2
a844 3
		} else {
		    *dest++ = *p;
		    needsSep = 1;
d846 2
a848 2
	    length = dest - Tcl_GetString(prefix);
	    Tcl_SetObjLength(prefix, length);
d853 3
a855 1
	     * Check to see if we need to append a separator.
d858 14
a871 11
	    if ((length > 0) && 
		(start[length-1] != '/') && (start[length-1] != ':')) {
		Tcl_AppendToObj(prefix, "/", 1);
		length++;
	    }
	    needsSep = 0;
	    
	    /*
	     * Append the element, eliminating duplicate and
	     * trailing slashes.
	     */
d873 8
a880 6
	    Tcl_SetObjLength(prefix, length + (int) strlen(p));
	    dest = Tcl_GetString(prefix) + length;
	    for (; *p != '\0'; p++) {
		if ((*p == '/') || (*p == '\\')) {
		    while ((p[1] == '/') || (p[1] == '\\')) {
			p++;
a881 6
		    if ((p[1] != '\0') && needsSep) {
			*dest++ = '/';
		    }
		} else {
		    *dest++ = *p;
		    needsSep = 1;
a882 4
	    }
	    length = dest - Tcl_GetString(prefix);
	    Tcl_SetObjLength(prefix, length);
	    break;
d884 4
a887 11
	case TCL_PLATFORM_MAC: {
	    int newLength;
	    
	    /*
	     * Sort out separators.  We basically add the object we've
	     * been given, but we have to make sure that there is
	     * exactly one separator inbetween (unless the object we're
	     * adding contains multiple contiguous colons, all of which
	     * we must add).  Also if an object is just ':' we don't
	     * bother to add it unless it's the very first element.
	     */
d889 6
a894 8
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
	    int adjustedPath = 0;
	    if ((strchr(p, ':') == NULL) && (strchr(p, '/') != NULL)) {
		char *start = p;
		adjustedPath = 1;
		while (*start != '\0') {
		    if (*start == '/') {
		        *start = ':';
d896 20
a915 12
		    start++;
		}
	    }
#endif
	    if (length > 0) {
		if ((p[0] == ':') && (p[1] == '\0')) {
		    return;
		}
		if (start[length-1] != ':') {
		    if (*p != '\0' && *p != ':') {
			Tcl_AppendToObj(prefix, ":", 1);
			length++;
d917 2
a918 7
		} else if (*p == ':') {
		    p++;
		}
	    } else {
		if (*p != '\0' && *p != ':') {
		    Tcl_AppendToObj(prefix, ":", 1);
		    length++;
d921 1
a921 4
	    
	    /*
	     * Append the element
	     */
d923 12
a934 15
	    newLength = strlen(p);
	    /* 
	     * It may not be good to just do 'Tcl_AppendToObj(prefix,
	     * p, newLength)' because the object may contain duplicate
	     * colons which we want to get rid of.
	     */
	    Tcl_AppendToObj(prefix, p, newLength);
	    
	    /* Remove spurious trailing single ':' */
	    dest = Tcl_GetString(prefix) + length + newLength;
	    if (*(dest-1) == ':') {
		if (dest-1 > Tcl_GetString(prefix)) {
		    if (*(dest-2) != ':') {
		        Tcl_SetObjLength(prefix, length + newLength -1);
		    }
d936 27
a962 8
	    }
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
	    /* Revert the path to what it was */
	    if (adjustedPath) {
		char *start = joining;
		while (*start != '\0') {
		    if (*start == ':') {
			*start = '/';
d964 2
a965 1
		    start++;
a967 1
#endif
d969 1
a969 1
	}
d971 1
a971 52
    return;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_JoinPath --
 *
 *	Combine a list of paths in a platform specific manner.  The
 *	function 'Tcl_FSJoinPath' should be used in preference where
 *	possible.
 *
 * Results:
 *	Appends the joined path to the end of the specified 
 *	Tcl_DString returning a pointer to the resulting string.  Note
 *	that the Tcl_DString must already be initialized.
 *
 * Side effects:
 *	Modifies the Tcl_DString.
 *
 *----------------------------------------------------------------------
 */

char *
Tcl_JoinPath(argc, argv, resultPtr)
    int argc;
    CONST char * CONST *argv;
    Tcl_DString *resultPtr;	/* Pointer to previously initialized DString */
{
    int i, len;
    Tcl_Obj *listObj = Tcl_NewObj();
    Tcl_Obj *resultObj;
    char *resultStr;

    /* Build the list of paths */
    for (i = 0; i < argc; i++) {
        Tcl_ListObjAppendElement(NULL, listObj,
		Tcl_NewStringObj(argv[i], -1));
    }

    /* Ask the objectified code to join the paths */
    Tcl_IncrRefCount(listObj);
    resultObj = Tcl_FSJoinPath(listObj, argc);
    Tcl_IncrRefCount(resultObj);
    Tcl_DecrRefCount(listObj);

    /* Store the result */
    resultStr = Tcl_GetStringFromObj(resultObj, &len);
    Tcl_DStringAppend(resultPtr, resultStr, len);
    Tcl_DecrRefCount(resultObj);

    /* Return a pointer to the result */
d1005 1
a1005 1
    CONST char *name;		/* File name, which may begin with "~" (to
d1012 10
a1021 2
    Tcl_Obj *path = Tcl_NewStringObj(name, -1);
    CONST char *result;
d1023 27
a1049 9
    Tcl_IncrRefCount(path);
    result = Tcl_FSGetTranslatedStringPath(interp, path);
    if (result == NULL) {
	Tcl_DecrRefCount(path);
	return NULL;
    }
    Tcl_DStringInit(bufferPtr);
    Tcl_DStringAppend(bufferPtr, result, -1);
    Tcl_DecrRefCount(path);
a1056 1
	register char *p;
a1100 1
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
a1105 3
#else
	    lastSep = strrchr(name, ':');
#endif
d1118 2
a1119 1
    if ((p != NULL) && (lastSep != NULL) && (lastSep > p)) {
d1155 1
a1155 1
static CONST char *
d1164 1
a1164 1
    CONST char *dir;
d1190 1
a1190 1
    return Tcl_DStringValue(resultPtr);
d1218 2
a1219 2
    int index, i, globFlags, length, join, dir, result;
    char *string, *separators;
d1221 3
a1223 5
    Tcl_Obj *pathOrDir = NULL;
    Tcl_DString prefix;
    static CONST char *options[] = {
	"-directory", "-join", "-nocomplain", "-path", "-tails", 
	"-types", "--", NULL
d1226 1
a1226 2
	GLOB_DIR, GLOB_JOIN, GLOB_NOCOMPLAIN, GLOB_PATH, GLOB_TAILS, 
	GLOB_TYPE, GLOB_LAST
d1229 1
a1229 1
    Tcl_GlobTypeData *globTypes = NULL;
d1234 1
d1258 1
a1258 1
	        globFlags |= TCL_GLOBMODE_NO_COMPLAIN;
d1266 1
a1266 1
		if (dir != PATH_NONE) {
d1273 2
a1274 2
		globFlags |= TCL_GLOBMODE_DIR;
		pathOrDir = objv[i+1];
a1279 3
	    case GLOB_TAILS:				/* -tails */
	        globFlags |= TCL_GLOBMODE_TAILS;
		break;
d1286 1
a1286 1
		if (dir != PATH_NONE) {
d1293 1
a1293 1
		pathOrDir = objv[i+1];
d1319 1
a1319 7
    if ((globFlags & TCL_GLOBMODE_TAILS) && (pathOrDir == NULL)) {
	Tcl_AppendToObj(resultPtr,
	  "\"-tails\" must be used with either \"-directory\" or \"-path\"",
	  -1);
	return TCL_ERROR;
    }
    
a1332 1
	int pathlength;
a1333 1
	char *first = Tcl_GetStringFromObj(pathOrDir,&pathlength);
d1338 2
a1339 2
	last = first + pathlength;
	for (; last != first; last--) {
d1344 1
a1344 1
	if (last == first + pathlength) {
d1346 1
a1346 1
	    dir = PATH_DIR;
d1351 2
a1352 1
	    if (last == first) {
d1354 1
a1354 1
		Tcl_DStringAppend(&pref, first, -1);
d1358 3
a1360 2
		Tcl_DStringAppend(&pref, last, first+pathlength-last);
		pathOrDir = Tcl_NewStringObj(first, last-first-1);
d1380 1
a1380 5
    
    if (pathOrDir != NULL) {
	Tcl_IncrRefCount(pathOrDir);
    }
    
d1388 1
a1388 1
	globTypes = (Tcl_GlobTypeData*) ckalloc(sizeof(Tcl_GlobTypeData));
d1471 1
a1471 4
		 * Error cases.  We re-get the interpreter's result,
		 * just to be sure it hasn't changed, and we reset
		 * the 'join' flag to zero, since we haven't yet
		 * made use of it.
a1473 1
		resultPtr = Tcl_GetObjResult(interp);
a1476 1
		join = 0;
a1478 1
		resultPtr = Tcl_GetObjResult(interp);
d1480 1
a1480 2
		   "only one MacOS type or creator argument"
		   " to \"-types\" allowed", -1);
a1481 1
		join = 0;
d1547 1
a1547 1
    if ((globFlags & TCL_GLOBMODE_NO_COMPLAIN) == 0) {
d1575 3
a1577 3
    }
    if (pathOrDir != NULL) {
	Tcl_DecrRefCount(pathOrDir);
a1598 5
 *      
 *      The interpreter's result, on entry to this function, must
 *      be a valid Tcl list (e.g. it could be empty), since we will
 *      lappend any new results to that list.  If it is not a valid
 *      list, this function will fail to do anything very meaningful.
d1604 2
a1605 5
 *	given by the pattern and unquotedPrefix arguments.  After an 
 *	error the result in interp will hold an error message, unless
 *	the 'TCL_GLOBMODE_NO_COMPLAIN' flag was given, in which case
 *	an error results in a TCL_OK return leaving the interpreter's
 *	result unmodified.
d1608 1
a1608 1
 *	The 'pattern' is written to.
d1620 2
a1621 2
    Tcl_Obj *unquotedPrefix;	/* Prefix to glob pattern, if non-null, which
                             	 * is considered literally. */
d1623 1
a1623 1
    Tcl_GlobTypeData *types;	/* Struct containing acceptable types.
d1627 1
a1627 2
    CONST char *head;
    char *tail, *start;
d1629 1
a1629 1
    int result, prefixLen;
a1630 1
    Tcl_Obj *oldResult;
a1640 1
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
a1645 3
#else
	    separators = ":";
#endif
d1651 1
a1651 1
	start = Tcl_GetString(unquotedPrefix);
d1676 2
a1677 1
	 * Determine the home directory for the specified user.  
d1682 11
a1692 6
	if (globFlags & TCL_GLOBMODE_NO_COMPLAIN) {
	    /* 
	     * We will ignore any error message here, and we
	     * don't want to mess up the interpreter's result.
	     */
	    head = DoTildeSubst(NULL, start+1, &buffer);
d1694 6
a1699 1
	    head = DoTildeSubst(interp, start+1, &buffer);
d1701 1
d1704 10
a1713 1
	    if (globFlags & TCL_GLOBMODE_NO_COMPLAIN) {
d1729 1
a1729 1
	    Tcl_DStringAppend(&buffer,Tcl_GetString(unquotedPrefix),-1);
a1731 1
    
d1733 7
a1739 15
     * We want to remember the length of the current prefix,
     * in case we are using TCL_GLOBMODE_TAILS.  Also if we
     * are using TCL_GLOBMODE_DIR, we must make sure the
     * prefix ends in a directory separator.
     */
    prefixLen = Tcl_DStringLength(&buffer);

    if (prefixLen > 0) {
	c = Tcl_DStringValue(&buffer)[prefixLen-1];
	if (strchr(separators, c) == NULL) {
	    /* 
	     * If the prefix is a directory, make sure it ends in a
	     * directory separator.
	     */
	    if (globFlags & TCL_GLOBMODE_DIR) {
a1741 1
	    prefixLen++;
a1744 8
    /* 
     * We need to get the old result, in case it is over-written
     * below when we still need it.
     */
    oldResult = Tcl_GetObjResult(interp);
    Tcl_IncrRefCount(oldResult);
    Tcl_ResetResult(interp);
    
d1746 1
a1746 1
    
d1748 3
a1750 61
	if (globFlags & TCL_GLOBMODE_NO_COMPLAIN) {
	    /* Put back the old result and reset the return code */
	    Tcl_SetObjResult(interp, oldResult);
	    result = TCL_OK;
	}
    } else {
	/* 
	 * Now we must concatenate the 'oldResult' and the current
	 * result, and then place that into the interpreter.
	 * 
	 * If we only want the tails, we must strip off the prefix now.
	 * It may seem more efficient to pass the tails flag down into
	 * TclDoGlob, Tcl_FSMatchInDirectory, but those functions are
	 * continually adjusting the prefix as the various pieces of
	 * the pattern are assimilated, so that would add a lot of
	 * complexity to the code.  This way is a little slower (when
	 * the -tails flag is given), but much simpler to code.
	 */
	int objc, i;
	Tcl_Obj **objv;

	/* Ensure sole ownership */
	if (Tcl_IsShared(oldResult)) {
	    Tcl_DecrRefCount(oldResult);
	    oldResult = Tcl_DuplicateObj(oldResult);
	    Tcl_IncrRefCount(oldResult);
	}

	Tcl_ListObjGetElements(NULL, Tcl_GetObjResult(interp), 
			       &objc, &objv);
#ifdef MAC_TCL
	/* adjust prefixLen if TclDoGlob prepended a ':' */
	if ((prefixLen > 0) && (objc > 0)
	&& (Tcl_DStringValue(&buffer)[0] != ':')) {
	    char *str = Tcl_GetStringFromObj(objv[0],NULL);
	    if (str[0] == ':') {
		    prefixLen++;
	    }
	}
#endif
	for (i = 0; i< objc; i++) {
	    Tcl_Obj* elt;
	    if (globFlags & TCL_GLOBMODE_TAILS) {
		int len;
		char *oldStr = Tcl_GetStringFromObj(objv[i],&len);
		if (len == prefixLen) {
		    if ((pattern[0] == '\0')
			|| (strchr(separators, pattern[0]) == NULL)) {
			elt = Tcl_NewStringObj(".",1);
		    } else {
			elt = Tcl_NewStringObj("/",1);
		    }
		} else {
		    elt = Tcl_NewStringObj(oldStr + prefixLen, 
						len - prefixLen);
		}
	    } else {
		elt = objv[i];
	    }
	    /* Assumption that 'oldResult' is a valid list */
	    Tcl_ListObjAppendElement(interp, oldResult, elt);
a1751 1
	Tcl_SetObjResult(interp, oldResult);
a1752 6
    /* 
     * Release our temporary copy.  All code paths above must
     * end here so we free our reference.
     */
    Tcl_DecrRefCount(oldResult);
    Tcl_DStringFree(&buffer);
d1845 2
a1846 2
    Tcl_GlobTypeData *types;	/* List object containing list of acceptable 
                            	 * types. May be NULL. */
a1882 1
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
a1888 1
#endif
a1900 1
#ifdef MAC_UNDERSTANDS_UNIX_PATHS
a1901 1
#endif
d2003 2
a2004 2
	    result = TclDoGlob(interp, separators, headPtr, 
			       Tcl_DStringValue(&newName), types);
d2029 4
a2032 4
	savedChar = *p;
	*p = '\0';
	firstSpecialChar = strpbrk(tail, "*[]?\\");
	*p = savedChar;
a2037 3
	int ret;
	Tcl_Obj *head = Tcl_NewStringObj(Tcl_DStringValue(headPtr),-1);
	Tcl_IncrRefCount(head);
d2039 5
a2043 4
	 * Look for matching files in the given directory.  The
	 * implementation of this function is platform specific.  For
	 * each file that matches, it will add the match onto the
	 * resultPtr given.
a2044 5
	if (*p == '\0') {
	    ret = Tcl_FSMatchInDirectory(interp, Tcl_GetObjResult(interp), 
					 head, tail, types);
	} else {
	    Tcl_Obj* resultPtr;
d2046 1
a2046 40
	    /* 
	     * We do the recursion ourselves.  This makes implementing
	     * Tcl_FSMatchInDirectory for each filesystem much easier.
	     */
	    Tcl_GlobTypeData dirOnly = { TCL_GLOB_TYPE_DIR, 0, NULL, NULL };
	    char save = *p;
	    
	    *p = '\0';
	    resultPtr = Tcl_NewListObj(0, NULL);
	    ret = Tcl_FSMatchInDirectory(interp, resultPtr, 
					 head, tail, &dirOnly);
	    *p = save;
	    if (ret == TCL_OK) {
		int resLength;
		ret = Tcl_ListObjLength(interp, resultPtr, &resLength);
		if (ret == TCL_OK) {
		    int i;
		    for (i =0; i< resLength; i++) {
			Tcl_Obj *elt;
			Tcl_DString ds;
			Tcl_ListObjIndex(interp, resultPtr, i, &elt);
			Tcl_DStringInit(&ds);
			Tcl_DStringAppend(&ds, Tcl_GetString(elt), -1);
			if(tclPlatform == TCL_PLATFORM_MAC) {
			    Tcl_DStringAppend(&ds, ":",1);
			} else {			
			    Tcl_DStringAppend(&ds, "/",1);
			}
			ret = TclDoGlob(interp, separators, &ds, p+1, types);
			Tcl_DStringFree(&ds);
			if (ret != TCL_OK) {
			    break;
			}
		    }
		}
	    }
	    Tcl_DecrRefCount(resultPtr);
	}
	Tcl_DecrRefCount(head);
	return ret;
d2051 7
a2057 12
    } else {
	/*
	 * This is the code path reached by a command like 'glob foo'.
	 *
	 * There are no more wildcards in the pattern and no more
	 * unprocessed characters in the tail, so now we can construct
	 * the path, and pass it to Tcl_FSMatchInDirectory with an
	 * empty pattern to verify the existence of the file and check
	 * it is of the correct type (if a 'types' flag it given -- if
	 * no such flag was given, we could just use 'Tcl_FSLStat', but
	 * for simplicity we keep to a common approach).
	 */
d2059 13
a2071 8
	Tcl_Obj *nameObj;
	/* Used to deal with one special case pertinent to MacOS */
	int macSpecialCase = 0;

	switch (tclPlatform) {
	    case TCL_PLATFORM_MAC: {
		if (strchr(Tcl_DStringValue(headPtr), ':') == NULL) {
		    Tcl_DStringAppend(headPtr, ":", 1);
a2072 2
		macSpecialCase = 1;
		break;
d2074 17
a2090 8
	    case TCL_PLATFORM_WINDOWS: {
		if (Tcl_DStringLength(headPtr) == 0) {
		    if (((*name == '\\') && (name[1] == '/' || name[1] == '\\'))
			    || (*name == '/')) {
			Tcl_DStringAppend(headPtr, "\\", 1);
		    } else {
			Tcl_DStringAppend(headPtr, ".", 1);
		    }
d2092 1
a2092 6
		/* 
		 * Convert to forward slashes.  This is required to pass
		 * some Tcl tests.  We should probably remove the conversions
		 * here and in tclWinFile.c, since they aren't needed since
		 * the dropping of support for Win32s.
		 */
d2094 2
a2095 2
		    if (*p == '\\') {
			*p = '/';
a2097 1
		break;
d2099 6
a2104 7
	    case TCL_PLATFORM_UNIX: {
		if (Tcl_DStringLength(headPtr) == 0) {
		    if ((*name == '\\' && name[1] == '/') || (*name == '/')) {
			Tcl_DStringAppend(headPtr, "/", 1);
		    } else {
			Tcl_DStringAppend(headPtr, ".", 1);
		    }
a2105 1
		break;
d2107 5
d2113 14
a2126 54
	/* Common for all platforms */
	name = Tcl_DStringValue(headPtr);
	nameObj = Tcl_NewStringObj(name, Tcl_DStringLength(headPtr));

	Tcl_IncrRefCount(nameObj);
	Tcl_FSMatchInDirectory(interp, Tcl_GetObjResult(interp), nameObj, 
			       NULL, types);
	Tcl_DecrRefCount(nameObj);
	return TCL_OK;
    }
}


/*
 *---------------------------------------------------------------------------
 *
 * TclFileDirname
 *
 *	This procedure calculates the directory above a given 
 *	path: basically 'file dirname'.  It is used both by
 *	the 'dirname' subcommand of file and by code in tclIOUtil.c.
 *
 * Results:
 *	NULL if an error occurred, otherwise a Tcl_Obj owned by
 *	the caller (i.e. most likely with refCount 1).
 *
 * Side effects:
 *      None.
 *
 *---------------------------------------------------------------------------
 */

Tcl_Obj*
TclFileDirname(interp, pathPtr)
    Tcl_Interp *interp;		/* Used for error reporting */
    Tcl_Obj *pathPtr;           /* Path to take dirname of */
{
    int splitElements;
    Tcl_Obj *splitPtr;
    Tcl_Obj *splitResultPtr = NULL;

    /* 
     * The behaviour we want here is slightly different to
     * the standard Tcl_FSSplitPath in the handling of home
     * directories; Tcl_FSSplitPath preserves the "~" while 
     * this code computes the actual full path name, if we
     * had just a single component.
     */	    
    splitPtr = Tcl_FSSplitPath(pathPtr, &splitElements);
    if ((splitElements == 1) && (Tcl_GetString(pathPtr)[0] == '~')) {
	Tcl_DecrRefCount(splitPtr);
	splitPtr = Tcl_FSGetNormalizedPath(interp, pathPtr);
	if (splitPtr == NULL) {
	    return NULL;
a2127 1
	splitPtr = Tcl_FSSplitPath(splitPtr, &splitElements);
d2130 1
a2130 18
    /*
     * Return all but the last component.  If there is only one
     * component, return it if the path was non-relative, otherwise
     * return the current directory.
     */

    if (splitElements > 1) {
	splitResultPtr = Tcl_FSJoinPath(splitPtr, splitElements - 1);
    } else if (splitElements == 0 || 
      (Tcl_FSGetPathType(pathPtr) == TCL_PATH_RELATIVE)) {
	splitResultPtr = Tcl_NewStringObj(
		((tclPlatform == TCL_PLATFORM_MAC) ? ":" : "."), 1);
    } else {
	Tcl_ListObjIndex(NULL, splitPtr, 0, &splitResultPtr);
    }
    Tcl_IncrRefCount(splitResultPtr);
    Tcl_DecrRefCount(splitPtr);
    return splitResultPtr;
a2131 19

/*
 *---------------------------------------------------------------------------
 *
 * Tcl_AllocStatBuf
 *
 *     This procedure allocates a Tcl_StatBuf on the heap.  It exists
 *     so that extensions may be used unchanged on systems where
 *     largefile support is optional.
 *
 * Results:
 *     A pointer to a Tcl_StatBuf which may be deallocated by being
 *     passed to ckfree().
 *
 * Side effects:
 *      None.
 *
 *---------------------------------------------------------------------------
 */
a2132 4
Tcl_StatBuf *
Tcl_AllocStatBuf() {
    return (Tcl_StatBuf *) ckalloc(sizeof(Tcl_StatBuf));
}
@


1.1.1.4
log
@import tcl 8.4.1
@
text
@d13 1
a13 1
 * RCS: @@(#) $Id: tclFileName.c,v 1.38 2002/09/27 00:50:10 hobbs Exp $
a1358 18
#if defined(__CYGWIN__) && defined(__WIN32__)

	extern int cygwin_conv_to_win32_path 
	    _ANSI_ARGS_((CONST char *, char *));
	char winbuf[MAX_PATH];

	/*
	 * In the Cygwin world, call conv_to_win32_path in order to use the
	 * mount table to translate the file name into something Windows will
	 * understand.  Take care when converting empty strings!
	 */
	if (Tcl_DStringLength(bufferPtr)) {
	    cygwin_conv_to_win32_path(Tcl_DStringValue(bufferPtr), winbuf);
	    Tcl_DStringFree(bufferPtr);
	    Tcl_DStringAppend(bufferPtr, winbuf, -1);
	}
#else /* __CYGWIN__ && __WIN32__ */

a1364 1
#endif /* __CYGWIN__ && __WIN32__ */
a2318 19

#if defined(__CYGWIN__) && defined(__WIN32__)
	    {

	    extern int cygwin_conv_to_win32_path 
	    	_ANSI_ARGS_((CONST char *, char *));
	    char winbuf[MAX_PATH];

	    /*
	     * In the Cygwin world, call conv_to_win32_path in order to use
	     * the mount table to translate the file name into something
	     * Windows will understand.
	     */
	    cygwin_conv_to_win32_path(Tcl_DStringValue(headPtr), winbuf);
	    Tcl_DStringFree(headPtr);
	    Tcl_DStringAppend(headPtr, winbuf, -1);

	    }
#endif /* __CYGWIN__ && __WIN32__ */
@


