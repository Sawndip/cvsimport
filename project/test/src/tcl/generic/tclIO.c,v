head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.58
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.56
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.54
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.52
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.50
	gdb_7_0-branch:1.5.0.48
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tcl8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.46
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.44
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.42
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.40
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.38
	gdb_6_5-2006-05-14-branchpoint:1.5
	readline_5_1-import-branch:1.5.0.36
	readline_5_1-import-branchpoint:1.5
	gdb_6_4-branch:1.5.0.34
	gdb_6_4-2005-11-01-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.32
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	ezannoni_pie-20040323-branch:1.5.0.30
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.28
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.26
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.24
	cagney_x86i386-20030821-branch:1.5.0.22
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.20
	gdb_6_0-2003-06-23-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.18
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.16
	cagney_writestrings-20030508-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.14
	cagney_fileio-20030521-branchpoint:1.5
	carlton_dictionary-20030430-merge:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.12
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.10
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.8
	cagney_lazyid-20030317-branchpoint:1.5
	offbyone-20030313-branch:1.5.0.6
	offbyone-20030313-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.4
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.2
	interps-20030202-branchpoint:1.5
	TCL8_4_1:1.1.1.3
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.2
	TCL_8_4_1:1.1.1.3
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.4
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TCL_8_4_0:1.1.1.3
	carlton_dictionary-branch:1.2.0.16
	carlton_dictionary-20020920-branchpoint:1.2
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.14
	gdb_5_3-branch:1.2.0.12
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.10
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.8
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.6
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TCL_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	dejagnu-2000-02-04:1.1.1.1
	dejagnu-2000-01-31:1.1.1.1
	dejagnu-2000-01-24:1.1.1.1
	dejagnu-2000-01-17:1.1.1.1
	dejagnu-2000-01-10:1.1.1.1
	dejagnu-2000-01-04:1.1.1.1
	dejagnu-1999-12-21:1.1.1.1
	dejagnu-1999-12-13:1.1.1.1
	dejagnu-1999-12-07:1.1.1.1
	dejagnu-1999-12-06:1.1.1.1
	dejagnu-1999-11-15:1.1.1.1
	dejagnu-1999-11-08:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.5
date	2003.01.21.19.40.03;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.26.19.47.52;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.37.02;	author kseitz;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2001.09.09.23.56.05;	author irox;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	99.11.09.01.28.43;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2002.09.27.21.49.03;	author kseitz;	state Exp;
branches;
next	;

1.3.4.1
date	2003.12.14.20.28.43;	author drow;	state Exp;
branches;
next	;

1.2.16.1
date	2002.12.23.19.40.19;	author carlton;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2003.02.07.19.18.12;	author carlton;	state Exp;
branches;
next	;

1.1.1.1
date	99.11.09.01.28.43;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.09.22.40.55;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.19.56.01;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tcl 8.4.1
@
text
@/* 
 * tclIO.c --
 *
 *	This file provides the generic portions (those that are the same on
 *	all platforms and for all channel types) of Tcl's IO facilities.
 *
 * Copyright (c) 1998-2000 Ajuba Solutions
 * Copyright (c) 1995-1997 Sun Microsystems, Inc.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tclIO.c,v 1.57 2002/07/30 18:36:25 andreas_kupries Exp $
 */

#include "tclInt.h"
#include "tclPort.h"
#include "tclIO.h"
#include <assert.h>


/*
 * All static variables used in this file are collected into a single
 * instance of the following structure.  For multi-threaded implementations,
 * there is one instance of this structure for each thread.
 *
 * Notice that different structures with the same name appear in other
 * files.  The structure defined below is used in this file only.
 */

typedef struct ThreadSpecificData {

    /*
     * This variable holds the list of nested ChannelHandlerEventProc 
     * invocations.
     */
    NextChannelHandler *nestedHandlerPtr;

    /*
     * List of all channels currently open, indexed by ChannelState,
     * as only one ChannelState exists per set of stacked channels.
     */
    ChannelState *firstCSPtr;
#ifdef oldcode
    /*
     * Has a channel exit handler been created yet?
     */
    int channelExitHandlerCreated;

    /*
     * Has the channel event source been created and registered with the
     * notifier?
     */
    int channelEventSourceCreated;
#endif
    /*
     * Static variables to hold channels for stdin, stdout and stderr.
     */
    Tcl_Channel stdinChannel;
    int stdinInitialized;
    Tcl_Channel stdoutChannel;
    int stdoutInitialized;
    Tcl_Channel stderrChannel;
    int stderrInitialized;

} ThreadSpecificData;

static Tcl_ThreadDataKey dataKey;

/*
 * Static functions in this file:
 */

static ChannelBuffer *	AllocChannelBuffer _ANSI_ARGS_((int length));
static void		ChannelTimerProc _ANSI_ARGS_((
				ClientData clientData));
static int		CheckChannelErrors _ANSI_ARGS_((ChannelState *statePtr,
				int direction));
static int		CheckFlush _ANSI_ARGS_((Channel *chanPtr,
				ChannelBuffer *bufPtr, int newlineFlag));
static int		CheckForDeadChannel _ANSI_ARGS_((Tcl_Interp *interp,
				ChannelState *statePtr));
static void		CheckForStdChannelsBeingClosed _ANSI_ARGS_((
				Tcl_Channel chan));
static void		CleanupChannelHandlers _ANSI_ARGS_((
				Tcl_Interp *interp, Channel *chanPtr));
static int		CloseChannel _ANSI_ARGS_((Tcl_Interp *interp,
				Channel *chanPtr, int errorCode));
static void		CommonGetsCleanup _ANSI_ARGS_((Channel *chanPtr,
				Tcl_Encoding encoding));
static int		CopyAndTranslateBuffer _ANSI_ARGS_((
				ChannelState *statePtr, char *result,
				int space));
static int		CopyBuffer _ANSI_ARGS_((
				Channel *chanPtr, char *result, int space));
static int		CopyData _ANSI_ARGS_((CopyState *csPtr, int mask));
static void		CopyEventProc _ANSI_ARGS_((ClientData clientData,
				int mask));
static void		CreateScriptRecord _ANSI_ARGS_((
				Tcl_Interp *interp, Channel *chanPtr,
				int mask, Tcl_Obj *scriptPtr));
static void		DeleteChannelTable _ANSI_ARGS_((
				ClientData clientData, Tcl_Interp *interp));
static void		DeleteScriptRecord _ANSI_ARGS_((Tcl_Interp *interp,
				Channel *chanPtr, int mask));
static int              DetachChannel _ANSI_ARGS_((Tcl_Interp *interp,
				Tcl_Channel chan));
static void		DiscardInputQueued _ANSI_ARGS_((ChannelState *statePtr,
				int discardSavedBuffers));
static void		DiscardOutputQueued _ANSI_ARGS_((
				ChannelState *chanPtr));
static int		DoRead _ANSI_ARGS_((Channel *chanPtr, char *srcPtr,
				int slen));
static int		DoWrite _ANSI_ARGS_((Channel *chanPtr, CONST char *src,
				int srcLen));
static int		DoReadChars _ANSI_ARGS_ ((Channel* chan,
				Tcl_Obj* objPtr, int toRead, int appendFlag));
static int		DoWriteChars _ANSI_ARGS_ ((Channel* chan,
				CONST char* src, int len));
static int		FilterInputBytes _ANSI_ARGS_((Channel *chanPtr,
				GetsState *statePtr));
static int		FlushChannel _ANSI_ARGS_((Tcl_Interp *interp,
				Channel *chanPtr, int calledFromAsyncFlush));
static Tcl_HashTable *	GetChannelTable _ANSI_ARGS_((Tcl_Interp *interp));
static int		GetInput _ANSI_ARGS_((Channel *chanPtr));
static int		HaveVersion _ANSI_ARGS_((Tcl_ChannelType *typePtr,
				Tcl_ChannelTypeVersion minimumVersion));
static void		PeekAhead _ANSI_ARGS_((Channel *chanPtr,
				char **dstEndPtr, GetsState *gsPtr));
static int		ReadBytes _ANSI_ARGS_((ChannelState *statePtr,
				Tcl_Obj *objPtr, int charsLeft,
				int *offsetPtr));
static int		ReadChars _ANSI_ARGS_((ChannelState *statePtr,
				Tcl_Obj *objPtr, int charsLeft,
				int *offsetPtr, int *factorPtr));
static void		RecycleBuffer _ANSI_ARGS_((ChannelState *statePtr,
				ChannelBuffer *bufPtr, int mustDiscard));
static int		StackSetBlockMode _ANSI_ARGS_((Channel *chanPtr,
				int mode));
static int		SetBlockMode _ANSI_ARGS_((Tcl_Interp *interp,
				Channel *chanPtr, int mode));
static void		StopCopy _ANSI_ARGS_((CopyState *csPtr));
static int		TranslateInputEOL _ANSI_ARGS_((ChannelState *statePtr,
				char *dst, CONST char *src,
				int *dstLenPtr, int *srcLenPtr));
static int		TranslateOutputEOL _ANSI_ARGS_((ChannelState *statePtr,
				char *dst, CONST char *src,
				int *dstLenPtr, int *srcLenPtr));
static void		UpdateInterest _ANSI_ARGS_((Channel *chanPtr));
static int		WriteBytes _ANSI_ARGS_((Channel *chanPtr,
				CONST char *src, int srcLen));
static int		WriteChars _ANSI_ARGS_((Channel *chanPtr,
				CONST char *src, int srcLen));


/*
 *---------------------------------------------------------------------------
 *
 * TclInitIOSubsystem --
 *
 *	Initialize all resources used by this subsystem on a per-process
 *	basis.  
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Depends on the memory subsystems.
 *
 *---------------------------------------------------------------------------
 */

void
TclInitIOSubsystem()
{
    /*
     * By fetching thread local storage we take care of
     * allocating it for each thread.
     */
    (void) TCL_TSD_INIT(&dataKey);
}   

/*
 *-------------------------------------------------------------------------
 *
 * TclFinalizeIOSubsystem --
 *
 *	Releases all resources used by this subsystem on a per-process 
 *	basis.  Closes all extant channels that have not already been 
 *	closed because they were not owned by any interp.  
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Depends on encoding and memory subsystems.
 *
 *-------------------------------------------------------------------------
 */

	/* ARGSUSED */
void
TclFinalizeIOSubsystem()
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    Channel *chanPtr;			/* Iterates over open channels. */
    ChannelState *nextCSPtr;		/* Iterates over open channels. */
    ChannelState *statePtr;		/* state of channel stack */

    for (statePtr = tsdPtr->firstCSPtr; statePtr != (ChannelState *) NULL;
	 statePtr = nextCSPtr) {
	chanPtr		= statePtr->topChanPtr;
        nextCSPtr	= statePtr->nextCSPtr;

        /*
         * Set the channel back into blocking mode to ensure that we wait
         * for all data to flush out.
         */
        
        (void) Tcl_SetChannelOption(NULL, (Tcl_Channel) chanPtr,
                "-blocking", "on");

        if ((chanPtr == (Channel *) tsdPtr->stdinChannel) ||
                (chanPtr == (Channel *) tsdPtr->stdoutChannel) ||
                (chanPtr == (Channel *) tsdPtr->stderrChannel)) {

            /*
             * Decrement the refcount which was earlier artificially bumped
             * up to keep the channel from being closed.
             */

            statePtr->refCount--;
        }

        if (statePtr->refCount <= 0) {

	    /*
             * Close it only if the refcount indicates that the channel is not
             * referenced from any interpreter. If it is, that interpreter will
             * close the channel when it gets destroyed.
             */

            (void) Tcl_Close((Tcl_Interp *) NULL, (Tcl_Channel) chanPtr);

        } else {

            /*
             * The refcount is greater than zero, so flush the channel.
             */

            Tcl_Flush((Tcl_Channel) chanPtr);

            /*
             * Call the device driver to actually close the underlying
             * device for this channel.
             */
            
	    if (chanPtr->typePtr->closeProc != TCL_CLOSE2PROC) {
		(chanPtr->typePtr->closeProc)(chanPtr->instanceData,
			(Tcl_Interp *) NULL);
	    } else {
		(chanPtr->typePtr->close2Proc)(chanPtr->instanceData,
			(Tcl_Interp *) NULL, 0);
	    }

            /*
             * Finally, we clean up the fields in the channel data structure
             * since all of them have been deleted already. We mark the
             * channel with CHANNEL_DEAD to prevent any further IO operations
             * on it.
             */

            chanPtr->instanceData = (ClientData) NULL;
            statePtr->flags |= CHANNEL_DEAD;
        }
    }
}


/*
 *----------------------------------------------------------------------
 *
 * Tcl_SetStdChannel --
 *
 *	This function is used to change the channels that are used
 *	for stdin/stdout/stderr in new interpreters.
 *
 * Results:
 *	None
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

void
Tcl_SetStdChannel(channel, type)
    Tcl_Channel channel;
    int type;			/* One of TCL_STDIN, TCL_STDOUT, TCL_STDERR. */
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    switch (type) {
	case TCL_STDIN:
	    tsdPtr->stdinInitialized = 1;
	    tsdPtr->stdinChannel = channel;
	    break;
	case TCL_STDOUT:
	    tsdPtr->stdoutInitialized = 1;
	    tsdPtr->stdoutChannel = channel;
	    break;
	case TCL_STDERR:
	    tsdPtr->stderrInitialized = 1;
	    tsdPtr->stderrChannel = channel;
	    break;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetStdChannel --
 *
 *	Returns the specified standard channel.
 *
 * Results:
 *	Returns the specified standard channel, or NULL.
 *
 * Side effects:
 *	May cause the creation of a standard channel and the underlying
 *	file.
 *
 *----------------------------------------------------------------------
 */
Tcl_Channel
Tcl_GetStdChannel(type)
    int type;			/* One of TCL_STDIN, TCL_STDOUT, TCL_STDERR. */
{
    Tcl_Channel channel = NULL;
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    /*
     * If the channels were not created yet, create them now and
     * store them in the static variables. 
     */

    switch (type) {
	case TCL_STDIN:
	    if (!tsdPtr->stdinInitialized) {
		tsdPtr->stdinChannel = TclpGetDefaultStdChannel(TCL_STDIN);
		tsdPtr->stdinInitialized = 1;

		/*
                 * Artificially bump the refcount to ensure that the channel
                 * is only closed on exit.
                 *
                 * NOTE: Must only do this if stdinChannel is not NULL. It
                 * can be NULL in situations where Tcl is unable to connect
                 * to the standard input.
                 */

                if (tsdPtr->stdinChannel != (Tcl_Channel) NULL) {
                    (void) Tcl_RegisterChannel((Tcl_Interp *) NULL,
                            tsdPtr->stdinChannel);
                }
	    }
	    channel = tsdPtr->stdinChannel;
	    break;
	case TCL_STDOUT:
	    if (!tsdPtr->stdoutInitialized) {
		tsdPtr->stdoutChannel = TclpGetDefaultStdChannel(TCL_STDOUT);
		tsdPtr->stdoutInitialized = 1;
                if (tsdPtr->stdoutChannel != (Tcl_Channel) NULL) {
                    (void) Tcl_RegisterChannel((Tcl_Interp *) NULL,
                            tsdPtr->stdoutChannel);
                }
	    }
	    channel = tsdPtr->stdoutChannel;
	    break;
	case TCL_STDERR:
	    if (!tsdPtr->stderrInitialized) {
		tsdPtr->stderrChannel = TclpGetDefaultStdChannel(TCL_STDERR);
		tsdPtr->stderrInitialized = 1;
                if (tsdPtr->stderrChannel != (Tcl_Channel) NULL) {
                    (void) Tcl_RegisterChannel((Tcl_Interp *) NULL,
                            tsdPtr->stderrChannel);
                }
	    }
	    channel = tsdPtr->stderrChannel;
	    break;
    }
    return channel;
}


/*
 *----------------------------------------------------------------------
 *
 * Tcl_CreateCloseHandler
 *
 *	Creates a close callback which will be called when the channel is
 *	closed.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Causes the callback to be called in the future when the channel
 *	will be closed.
 *
 *----------------------------------------------------------------------
 */

void
Tcl_CreateCloseHandler(chan, proc, clientData)
    Tcl_Channel chan;		/* The channel for which to create the
                                 * close callback. */
    Tcl_CloseProc *proc;	/* The callback routine to call when the
                                 * channel will be closed. */
    ClientData clientData;	/* Arbitrary data to pass to the
                                 * close callback. */
{
    ChannelState *statePtr;
    CloseCallback *cbPtr;

    statePtr = ((Channel *) chan)->state;

    cbPtr = (CloseCallback *) ckalloc((unsigned) sizeof(CloseCallback));
    cbPtr->proc = proc;
    cbPtr->clientData = clientData;

    cbPtr->nextPtr = statePtr->closeCbPtr;
    statePtr->closeCbPtr = cbPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_DeleteCloseHandler --
 *
 *	Removes a callback that would have been called on closing
 *	the channel. If there is no matching callback then this
 *	function has no effect.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The callback will not be called in the future when the channel
 *	is eventually closed.
 *
 *----------------------------------------------------------------------
 */

void
Tcl_DeleteCloseHandler(chan, proc, clientData)
    Tcl_Channel chan;		/* The channel for which to cancel the
                                 * close callback. */
    Tcl_CloseProc *proc;	/* The procedure for the callback to
                                 * remove. */
    ClientData clientData;	/* The callback data for the callback
                                 * to remove. */
{
    ChannelState *statePtr;
    CloseCallback *cbPtr, *cbPrevPtr;

    statePtr = ((Channel *) chan)->state;
    for (cbPtr = statePtr->closeCbPtr, cbPrevPtr = (CloseCallback *) NULL;
	 cbPtr != (CloseCallback *) NULL;
	 cbPtr = cbPtr->nextPtr) {
        if ((cbPtr->proc == proc) && (cbPtr->clientData == clientData)) {
            if (cbPrevPtr == (CloseCallback *) NULL) {
                statePtr->closeCbPtr = cbPtr->nextPtr;
            }
            ckfree((char *) cbPtr);
            break;
        } else {
            cbPrevPtr = cbPtr;
        }
    }
}

/*
 *----------------------------------------------------------------------
 *
 * GetChannelTable --
 *
 *	Gets and potentially initializes the channel table for an
 *	interpreter. If it is initializing the table it also inserts
 *	channels for stdin, stdout and stderr if the interpreter is
 *	trusted.
 *
 * Results:
 *	A pointer to the hash table created, for use by the caller.
 *
 * Side effects:
 *	Initializes the channel table for an interpreter. May create
 *	channels for stdin, stdout and stderr.
 *
 *----------------------------------------------------------------------
 */

static Tcl_HashTable *
GetChannelTable(interp)
    Tcl_Interp *interp;
{
    Tcl_HashTable *hTblPtr;	/* Hash table of channels. */
    Tcl_Channel stdinChan, stdoutChan, stderrChan;

    hTblPtr = (Tcl_HashTable *) Tcl_GetAssocData(interp, "tclIO", NULL);
    if (hTblPtr == (Tcl_HashTable *) NULL) {
        hTblPtr = (Tcl_HashTable *) ckalloc((unsigned) sizeof(Tcl_HashTable));
        Tcl_InitHashTable(hTblPtr, TCL_STRING_KEYS);

        (void) Tcl_SetAssocData(interp, "tclIO",
                (Tcl_InterpDeleteProc *) DeleteChannelTable,
                (ClientData) hTblPtr);

        /*
         * If the interpreter is trusted (not "safe"), insert channels
         * for stdin, stdout and stderr (possibly creating them in the
         * process).
         */

        if (Tcl_IsSafe(interp) == 0) {
            stdinChan = Tcl_GetStdChannel(TCL_STDIN);
            if (stdinChan != NULL) {
                Tcl_RegisterChannel(interp, stdinChan);
            }
            stdoutChan = Tcl_GetStdChannel(TCL_STDOUT);
            if (stdoutChan != NULL) {
                Tcl_RegisterChannel(interp, stdoutChan);
            }
            stderrChan = Tcl_GetStdChannel(TCL_STDERR);
            if (stderrChan != NULL) {
                Tcl_RegisterChannel(interp, stderrChan);
            }
        }

    }
    return hTblPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * DeleteChannelTable --
 *
 *	Deletes the channel table for an interpreter, closing any open
 *	channels whose refcount reaches zero. This procedure is invoked
 *	when an interpreter is deleted, via the AssocData cleanup
 *	mechanism.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Deletes the hash table of channels. May close channels. May flush
 *	output on closed channels. Removes any channeEvent handlers that were
 *	registered in this interpreter.
 *
 *----------------------------------------------------------------------
 */

static void
DeleteChannelTable(clientData, interp)
    ClientData clientData;	/* The per-interpreter data structure. */
    Tcl_Interp *interp;		/* The interpreter being deleted. */
{
    Tcl_HashTable *hTblPtr;	/* The hash table. */
    Tcl_HashSearch hSearch;	/* Search variable. */
    Tcl_HashEntry *hPtr;	/* Search variable. */
    Channel *chanPtr;		/* Channel being deleted. */
    ChannelState *statePtr;	/* State of Channel being deleted. */
    EventScriptRecord *sPtr, *prevPtr, *nextPtr;
    				/* Variables to loop over all channel events
                                 * registered, to delete the ones that refer
                                 * to the interpreter being deleted. */

    /*
     * Delete all the registered channels - this will close channels whose
     * refcount reaches zero.
     */
    
    hTblPtr = (Tcl_HashTable *) clientData;
    for (hPtr = Tcl_FirstHashEntry(hTblPtr, &hSearch);
	 hPtr != (Tcl_HashEntry *) NULL;
	 hPtr = Tcl_FirstHashEntry(hTblPtr, &hSearch)) {

        chanPtr = (Channel *) Tcl_GetHashValue(hPtr);
	statePtr = chanPtr->state;

        /*
         * Remove any fileevents registered in this interpreter.
         */
        
        for (sPtr = statePtr->scriptRecordPtr,
                 prevPtr = (EventScriptRecord *) NULL;
	     sPtr != (EventScriptRecord *) NULL;
	     sPtr = nextPtr) {
            nextPtr = sPtr->nextPtr;
            if (sPtr->interp == interp) {
                if (prevPtr == (EventScriptRecord *) NULL) {
                    statePtr->scriptRecordPtr = nextPtr;
                } else {
                    prevPtr->nextPtr = nextPtr;
                }

                Tcl_DeleteChannelHandler((Tcl_Channel) chanPtr,
                        TclChannelEventScriptInvoker, (ClientData) sPtr);

		Tcl_DecrRefCount(sPtr->scriptPtr);
                ckfree((char *) sPtr);
            } else {
                prevPtr = sPtr;
            }
        }

        /*
         * Cannot call Tcl_UnregisterChannel because that procedure calls
         * Tcl_GetAssocData to get the channel table, which might already
         * be inaccessible from the interpreter structure. Instead, we
         * emulate the behavior of Tcl_UnregisterChannel directly here.
         */

        Tcl_DeleteHashEntry(hPtr);
        statePtr->refCount--;
        if (statePtr->refCount <= 0) {
            if (!(statePtr->flags & BG_FLUSH_SCHEDULED)) {
                (void) Tcl_Close(interp, (Tcl_Channel) chanPtr);
            }
        }
    }
    Tcl_DeleteHashTable(hTblPtr);
    ckfree((char *) hTblPtr);
}

/*
 *----------------------------------------------------------------------
 *
 * CheckForStdChannelsBeingClosed --
 *
 *	Perform special handling for standard channels being closed. When
 *	given a standard channel, if the refcount is now 1, it means that
 *	the last reference to the standard channel is being explicitly
 *	closed. Now bump the refcount artificially down to 0, to ensure the
 *	normal handling of channels being closed will occur. Also reset the
 *	static pointer to the channel to NULL, to avoid dangling references.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Manipulates the refcount on standard channels. May smash the global
 *	static pointer to a standard channel.
 *
 *----------------------------------------------------------------------
 */

static void
CheckForStdChannelsBeingClosed(chan)
    Tcl_Channel chan;
{
    ChannelState *statePtr = ((Channel *) chan)->state;
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    if ((chan == tsdPtr->stdinChannel) && (tsdPtr->stdinInitialized)) {
        if (statePtr->refCount < 2) {
            statePtr->refCount = 0;
            tsdPtr->stdinChannel = NULL;
            return;
        }
    } else if ((chan == tsdPtr->stdoutChannel)
	    && (tsdPtr->stdoutInitialized)) {
        if (statePtr->refCount < 2) {
            statePtr->refCount = 0;
            tsdPtr->stdoutChannel = NULL;
            return;
        }
    } else if ((chan == tsdPtr->stderrChannel)
	    && (tsdPtr->stderrInitialized)) {
        if (statePtr->refCount < 2) {
            statePtr->refCount = 0;
            tsdPtr->stderrChannel = NULL;
            return;
        }
    }
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_IsStandardChannel --
 *
 *	Test if the given channel is a standard channel.  No attempt
 *	is made to check if the channel or the standard channels
 *	are initialized or otherwise valid.
 *
 * Results:
 *	Returns 1 if true, 0 if false.
 *
 * Side effects:
 *      None.
 *
 *----------------------------------------------------------------------
 */
int 
Tcl_IsStandardChannel(chan)
    Tcl_Channel chan;		/* Channel to check. */
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    if ((chan == tsdPtr->stdinChannel) 
	|| (chan == tsdPtr->stdoutChannel)
	|| (chan == tsdPtr->stderrChannel)) {
	return 1;
    } else {
	return 0;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_RegisterChannel --
 *
 *	Adds an already-open channel to the channel table of an interpreter.
 *	If the interpreter passed as argument is NULL, it only increments
 *	the channel refCount.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	May increment the reference count of a channel.
 *
 *----------------------------------------------------------------------
 */

void
Tcl_RegisterChannel(interp, chan)
    Tcl_Interp *interp;		/* Interpreter in which to add the channel. */
    Tcl_Channel chan;		/* The channel to add to this interpreter
                                 * channel table. */
{
    Tcl_HashTable *hTblPtr;	/* Hash table of channels. */
    Tcl_HashEntry *hPtr;	/* Search variable. */
    int new;			/* Is the hash entry new or does it exist? */
    Channel *chanPtr;		/* The actual channel. */
    ChannelState *statePtr;	/* State of the actual channel. */

    /*
     * Always (un)register bottom-most channel in the stack.  This makes
     * management of the channel list easier because no manipulation is
     * necessary during (un)stack operation.
     */
    chanPtr = ((Channel *) chan)->state->bottomChanPtr;
    statePtr = chanPtr->state;

    if (statePtr->channelName == (CONST char *) NULL) {
        panic("Tcl_RegisterChannel: channel without name");
    }
    if (interp != (Tcl_Interp *) NULL) {
        hTblPtr = GetChannelTable(interp);
        hPtr = Tcl_CreateHashEntry(hTblPtr, statePtr->channelName, &new);
        if (new == 0) {
            if (chan == (Tcl_Channel) Tcl_GetHashValue(hPtr)) {
                return;
            }

	    panic("Tcl_RegisterChannel: duplicate channel names");
        }
        Tcl_SetHashValue(hPtr, (ClientData) chanPtr);
    }
    statePtr->refCount++;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_UnregisterChannel --
 *
 *	Deletes the hash entry for a channel associated with an interpreter.
 *	If the interpreter given as argument is NULL, it only decrements the
 *	reference count.  (This all happens in the Tcl_DetachChannel helper
 *	function).
 *	
 *	Finally, if the reference count of the channel drops to zero,
 *	it is deleted.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	Calls Tcl_DetachChannel which deletes the hash entry for a channel 
 *	associated with an interpreter.
 *	
 *	May delete the channel, which can have a variety of consequences,
 *	especially if we are forced to close the channel.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_UnregisterChannel(interp, chan)
    Tcl_Interp *interp;		/* Interpreter in which channel is defined. */
    Tcl_Channel chan;		/* Channel to delete. */
{
    ChannelState *statePtr;	/* State of the real channel. */

    if (DetachChannel(interp, chan) != TCL_OK) {
        return TCL_OK;
    }
    
    statePtr = ((Channel *) chan)->state->bottomChanPtr->state;

    /*
     * Perform special handling for standard channels being closed. If the
     * refCount is now 1 it means that the last reference to the standard
     * channel is being explicitly closed, so bump the refCount down
     * artificially to 0. This will ensure that the channel is actually
     * closed, below. Also set the static pointer to NULL for the channel.
     */

    CheckForStdChannelsBeingClosed(chan);

    /*
     * If the refCount reached zero, close the actual channel.
     */

    if (statePtr->refCount <= 0) {

        /*
         * Ensure that if there is another buffer, it gets flushed
         * whether or not we are doing a background flush.
         */

        if ((statePtr->curOutPtr != NULL) &&
                (statePtr->curOutPtr->nextAdded >
                        statePtr->curOutPtr->nextRemoved)) {
            statePtr->flags |= BUFFER_READY;
        }
	Tcl_Preserve((ClientData)statePtr);
        if (!(statePtr->flags & BG_FLUSH_SCHEDULED)) {
	    /* We don't want to re-enter Tcl_Close */
	    if (!(statePtr->flags & CHANNEL_CLOSED)) {
		if (Tcl_Close(interp, chan) != TCL_OK) {
		    statePtr->flags |= CHANNEL_CLOSED;
		    Tcl_Release((ClientData)statePtr);
		    return TCL_ERROR;
		}
	    }
        }
        statePtr->flags |= CHANNEL_CLOSED;
	Tcl_Release((ClientData)statePtr);
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_DetachChannel --
 *
 *	Deletes the hash entry for a channel associated with an interpreter.
 *	If the interpreter given as argument is NULL, it only decrements the
 *	reference count.  Even if the ref count drops to zero, the 
 *	channel is NOT closed or cleaned up.  This allows a channel to
 *	be detached from an interpreter and left in the same state it
 *	was in when it was originally returned by 'Tcl_OpenFileChannel',
 *	for example.
 *	
 *	This function cannot be used on the standard channels, and
 *	will return TCL_ERROR if that is attempted.
 *	
 *	This function should only be necessary for special purposes
 *	in which you need to generate a pristine channel from one
 *	that has already been used.  All ordinary purposes will almost
 *	always want to use Tcl_UnregisterChannel instead.
 *	
 *	Provided the channel is not attached to any other interpreter,
 *	it can then be closed with Tcl_Close, rather than with 
 *	Tcl_UnregisterChannel.
 *
 * Results:
 *	A standard Tcl result.  If the channel is not currently registered
 *	with the given interpreter, TCL_ERROR is returned, otherwise
 *	TCL_OK.  However no error messages are left in the interp's result.
 *
 * Side effects:
 *	Deletes the hash entry for a channel associated with an 
 *	interpreter.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_DetachChannel(interp, chan)
    Tcl_Interp *interp;		/* Interpreter in which channel is defined. */
    Tcl_Channel chan;		/* Channel to delete. */
{
    if (Tcl_IsStandardChannel(chan)) {
        return TCL_ERROR;
    }
    
    return DetachChannel(interp, chan);
}

/*
 *----------------------------------------------------------------------
 *
 * DetachChannel --
 *
 *	Deletes the hash entry for a channel associated with an interpreter.
 *	If the interpreter given as argument is NULL, it only decrements the
 *	reference count.  Even if the ref count drops to zero, the 
 *	channel is NOT closed or cleaned up.  This allows a channel to
 *	be detached from an interpreter and left in the same state it
 *	was in when it was originally returned by 'Tcl_OpenFileChannel',
 *	for example.
 *
 * Results:
 *	A standard Tcl result.  If the channel is not currently registered
 *	with the given interpreter, TCL_ERROR is returned, otherwise
 *	TCL_OK.  However no error messages are left in the interp's result.
 *
 * Side effects:
 *	Deletes the hash entry for a channel associated with an 
 *	interpreter.
 *
 *----------------------------------------------------------------------
 */

static int
DetachChannel(interp, chan)
    Tcl_Interp *interp;		/* Interpreter in which channel is defined. */
    Tcl_Channel chan;		/* Channel to delete. */
{
    Tcl_HashTable *hTblPtr;	/* Hash table of channels. */
    Tcl_HashEntry *hPtr;	/* Search variable. */
    Channel *chanPtr;		/* The real IO channel. */
    ChannelState *statePtr;	/* State of the real channel. */

    /*
     * Always (un)register bottom-most channel in the stack.  This makes
     * management of the channel list easier because no manipulation is
     * necessary during (un)stack operation.
     */
    chanPtr = ((Channel *) chan)->state->bottomChanPtr;
    statePtr = chanPtr->state;

    if (interp != (Tcl_Interp *) NULL) {
	hTblPtr = (Tcl_HashTable *) Tcl_GetAssocData(interp, "tclIO", NULL);
	if (hTblPtr == (Tcl_HashTable *) NULL) {
	    return TCL_ERROR;
	}
	hPtr = Tcl_FindHashEntry(hTblPtr, statePtr->channelName);
	if (hPtr == (Tcl_HashEntry *) NULL) {
	    return TCL_ERROR;
	}
	if ((Channel *) Tcl_GetHashValue(hPtr) != chanPtr) {
	    return TCL_ERROR;
	}
	Tcl_DeleteHashEntry(hPtr);

	/*
	 * Remove channel handlers that refer to this interpreter, so that they
	 * will not be present if the actual close is delayed and more events
	 * happen on the channel. This may occur if the channel is shared
	 * between several interpreters, or if the channel has async
	 * flushing active.
	 */
    
	CleanupChannelHandlers(interp, chanPtr);
    }

    statePtr->refCount--;
    
    return TCL_OK;
}


/*
 *---------------------------------------------------------------------------
 *
 * Tcl_GetChannel --
 *
 *	Finds an existing Tcl_Channel structure by name in a given
 *	interpreter. This function is public because it is used by
 *	channel-type-specific functions.
 *
 * Results:
 *	A Tcl_Channel or NULL on failure. If failed, interp's result
 *	object contains an error message.  *modePtr is filled with the
 *	modes in which the channel was opened.
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
 */

Tcl_Channel
Tcl_GetChannel(interp, chanName, modePtr)
    Tcl_Interp *interp;		/* Interpreter in which to find or create
                                 * the channel. */
    CONST char *chanName;	/* The name of the channel. */
    int *modePtr;		/* Where to store the mode in which the
                                 * channel was opened? Will contain an ORed
                                 * combination of TCL_READABLE and
                                 * TCL_WRITABLE, if non-NULL. */
{
    Channel *chanPtr;		/* The actual channel. */
    Tcl_HashTable *hTblPtr;	/* Hash table of channels. */
    Tcl_HashEntry *hPtr;	/* Search variable. */
    CONST char *name;		/* Translated name. */

    /*
     * Substitute "stdin", etc.  Note that even though we immediately
     * find the channel using Tcl_GetStdChannel, we still need to look
     * it up in the specified interpreter to ensure that it is present
     * in the channel table.  Otherwise, safe interpreters would always
     * have access to the standard channels.
     */

    name = chanName;
    if ((chanName[0] == 's') && (chanName[1] == 't')) {
	chanPtr = NULL;
	if (strcmp(chanName, "stdin") == 0) {
	    chanPtr = (Channel *) Tcl_GetStdChannel(TCL_STDIN);
	} else if (strcmp(chanName, "stdout") == 0) {
	    chanPtr = (Channel *) Tcl_GetStdChannel(TCL_STDOUT);
	} else if (strcmp(chanName, "stderr") == 0) {
	    chanPtr = (Channel *) Tcl_GetStdChannel(TCL_STDERR);
	}
	if (chanPtr != NULL) {
	    name = chanPtr->state->channelName;
	}
    }

    hTblPtr = GetChannelTable(interp);
    hPtr = Tcl_FindHashEntry(hTblPtr, name);
    if (hPtr == (Tcl_HashEntry *) NULL) {
        Tcl_AppendResult(interp, "can not find channel named \"",
                chanName, "\"", (char *) NULL);
        return NULL;
    }

    /*
     * Always return bottom-most channel in the stack.  This one lives
     * the longest - other channels may go away unnoticed.
     * The other APIs compensate where necessary to retrieve the
     * topmost channel again.
     */
    chanPtr = (Channel *) Tcl_GetHashValue(hPtr);
    chanPtr = chanPtr->state->bottomChanPtr;
    if (modePtr != NULL) {
        *modePtr = (chanPtr->state->flags & (TCL_READABLE|TCL_WRITABLE));
    }
    
    return (Tcl_Channel) chanPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_CreateChannel --
 *
 *	Creates a new entry in the hash table for a Tcl_Channel
 *	record.
 *
 * Results:
 *	Returns the new Tcl_Channel.
 *
 * Side effects:
 *	Creates a new Tcl_Channel instance and inserts it into the
 *	hash table.
 *
 *----------------------------------------------------------------------
 */

Tcl_Channel
Tcl_CreateChannel(typePtr, chanName, instanceData, mask)
    Tcl_ChannelType *typePtr;	/* The channel type record. */
    CONST char *chanName;	/* Name of channel to record. */
    ClientData instanceData;	/* Instance specific data. */
    int mask;			/* TCL_READABLE & TCL_WRITABLE to indicate
                                 * if the channel is readable, writable. */
{
    Channel *chanPtr;		/* The channel structure newly created. */
    ChannelState *statePtr;	/* The stack-level independent state info
				 * for the channel. */
    CONST char *name;
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    /*
     * With the change of the Tcl_ChannelType structure to use a version in
     * 8.3.2+, we have to make sure that our assumption that the structure
     * remains a binary compatible size is true.
     *
     * If this assertion fails on some system, then it can be removed
     * only if the user recompiles code with older channel drivers in
     * the new system as well.
     */

    assert(sizeof(Tcl_ChannelTypeVersion) == sizeof(Tcl_DriverBlockModeProc*));

    /*
     * JH: We could subsequently memset these to 0 to avoid the
     * numerous assignments to 0/NULL below.
     */
    chanPtr  = (Channel *) ckalloc((unsigned) sizeof(Channel));
    statePtr = (ChannelState *) ckalloc((unsigned) sizeof(ChannelState));
    chanPtr->state = statePtr;

    chanPtr->instanceData	= instanceData;
    chanPtr->typePtr		= typePtr;

    /*
     * Set all the bits that are part of the stack-independent state
     * information for the channel.
     */

    if (chanName != (char *) NULL) {
	char *tmp = ckalloc((unsigned) (strlen(chanName) + 1));
        statePtr->channelName = tmp;
        strcpy(tmp, chanName);
    } else {
        panic("Tcl_CreateChannel: NULL channel name");
    }

    statePtr->flags		= mask;

    /*
     * Set the channel to system default encoding.
     */

    statePtr->encoding = NULL;
    name = Tcl_GetEncodingName(NULL);
    if (strcmp(name, "binary") != 0) {
    	statePtr->encoding = Tcl_GetEncoding(NULL, name);
    }
    statePtr->inputEncodingState	= NULL;
    statePtr->inputEncodingFlags	= TCL_ENCODING_START;
    statePtr->outputEncodingState	= NULL;
    statePtr->outputEncodingFlags	= TCL_ENCODING_START;

    /*
     * Set the channel up initially in AUTO input translation mode to
     * accept "\n", "\r" and "\r\n". Output translation mode is set to
     * a platform specific default value. The eofChar is set to 0 for both
     * input and output, so that Tcl does not look for an in-file EOF
     * indicator (e.g. ^Z) and does not append an EOF indicator to files.
     */

    statePtr->inputTranslation	= TCL_TRANSLATE_AUTO;
    statePtr->outputTranslation	= TCL_PLATFORM_TRANSLATION;
    statePtr->inEofChar		= 0;
    statePtr->outEofChar	= 0;

    statePtr->unreportedError	= 0;
    statePtr->refCount		= 0;
    statePtr->closeCbPtr	= (CloseCallback *) NULL;
    statePtr->curOutPtr		= (ChannelBuffer *) NULL;
    statePtr->outQueueHead	= (ChannelBuffer *) NULL;
    statePtr->outQueueTail	= (ChannelBuffer *) NULL;
    statePtr->saveInBufPtr	= (ChannelBuffer *) NULL;
    statePtr->inQueueHead	= (ChannelBuffer *) NULL;
    statePtr->inQueueTail	= (ChannelBuffer *) NULL;
    statePtr->chPtr		= (ChannelHandler *) NULL;
    statePtr->interestMask	= 0;
    statePtr->scriptRecordPtr	= (EventScriptRecord *) NULL;
    statePtr->bufSize		= CHANNELBUFFER_DEFAULT_SIZE;
    statePtr->timer		= NULL;
    statePtr->csPtr		= NULL;

    statePtr->outputStage	= NULL;
    if ((statePtr->encoding != NULL) && (statePtr->flags & TCL_WRITABLE)) {
	statePtr->outputStage = (char *)
	    ckalloc((unsigned) (statePtr->bufSize + 2));
    }

    /*
     * As we are creating the channel, it is obviously the top for now
     */
    statePtr->topChanPtr	= chanPtr;
    statePtr->bottomChanPtr	= chanPtr;
    chanPtr->downChanPtr	= (Channel *) NULL;
    chanPtr->upChanPtr		= (Channel *) NULL;
    chanPtr->inQueueHead        = (ChannelBuffer*) NULL;
    chanPtr->inQueueTail        = (ChannelBuffer*) NULL;

    /*
     * Link the channel into the list of all channels; create an on-exit
     * handler if there is not one already, to close off all the channels
     * in the list on exit.
     *
     * JH: Could call Tcl_SpliceChannel, but need to avoid NULL check.
     */

    statePtr->nextCSPtr	= tsdPtr->firstCSPtr;
    tsdPtr->firstCSPtr	= statePtr;

    /*
     * TIP #10. Mark the current thread as the one managing the new
     *          channel. Note: 'Tcl_GetCurrentThread' returns sensible
     *          values even for a non-threaded core.
     */

    statePtr->managingThread = Tcl_GetCurrentThread ();

    /*
     * Install this channel in the first empty standard channel slot, if
     * the channel was previously closed explicitly.
     */

    if ((tsdPtr->stdinChannel == NULL) &&
	    (tsdPtr->stdinInitialized == 1)) {
	Tcl_SetStdChannel((Tcl_Channel) chanPtr, TCL_STDIN);
        Tcl_RegisterChannel((Tcl_Interp *) NULL, (Tcl_Channel) chanPtr);
    } else if ((tsdPtr->stdoutChannel == NULL) &&
	    (tsdPtr->stdoutInitialized == 1)) {
	Tcl_SetStdChannel((Tcl_Channel) chanPtr, TCL_STDOUT);
        Tcl_RegisterChannel((Tcl_Interp *) NULL, (Tcl_Channel) chanPtr);
    } else if ((tsdPtr->stderrChannel == NULL) &&
	    (tsdPtr->stderrInitialized == 1)) {
	Tcl_SetStdChannel((Tcl_Channel) chanPtr, TCL_STDERR);
        Tcl_RegisterChannel((Tcl_Interp *) NULL, (Tcl_Channel) chanPtr);
    } 
    return (Tcl_Channel) chanPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_StackChannel --
 *
 *	Replaces an entry in the hash table for a Tcl_Channel
 *	record. The replacement is a new channel with same name,
 *	it supercedes the replaced channel. Input and output of
 *	the superceded channel is now going through the newly
 *	created channel and allows the arbitrary filtering/manipulation
 *	of the dataflow.
 *
 *	Andreas Kupries <a.kupries@@westend.com>, 12/13/1998
 *	"Trf-Patch for filtering channels"
 *
 * Results:
 *	Returns the new Tcl_Channel, which actually contains the
 *      saved information about prevChan.
 *
 * Side effects:
 *    A new channel structure is allocated and linked below
 *    the existing channel.  The channel operations and client
 *    data of the existing channel are copied down to the newly
 *    created channel, and the current channel has its operations
 *    replaced by the new typePtr.
 *
 *----------------------------------------------------------------------
 */

Tcl_Channel
Tcl_StackChannel(interp, typePtr, instanceData, mask, prevChan)
    Tcl_Interp	    *interp;	   /* The interpreter we are working in */
    Tcl_ChannelType *typePtr;	   /* The channel type record for the new
				    * channel. */
    ClientData	     instanceData; /* Instance specific data for the new
				    * channel. */
    int		     mask;	   /* TCL_READABLE & TCL_WRITABLE to indicate
				    * if the channel is readable, writable. */
    Tcl_Channel	     prevChan;	   /* The channel structure to replace */
{
    ThreadSpecificData	*tsdPtr = TCL_TSD_INIT(&dataKey);
    Channel		*chanPtr, *prevChanPtr;
    ChannelState	*statePtr;

    /*
     * Find the given channel in the list of all channels.
     * If we don't find it, then it was never registered correctly.
     *
     * This operation should occur at the top of a channel stack.
     */

    statePtr    = (ChannelState *) tsdPtr->firstCSPtr;
    prevChanPtr = ((Channel *) prevChan)->state->topChanPtr;

    while (statePtr->topChanPtr != prevChanPtr) {
	statePtr = statePtr->nextCSPtr;
    }

    if (statePtr == NULL) {
	Tcl_AppendResult(interp, "couldn't find state for channel \"",
		Tcl_GetChannelName(prevChan), "\"", (char *) NULL);
        return (Tcl_Channel) NULL;
    }

    /*
     * Here we check if the given "mask" matches the "flags"
     * of the already existing channel.
     *
     *	  | - | R | W | RW |
     *	--+---+---+---+----+	<=>  0 != (chan->mask & prevChan->mask)
     *	- |   |   |   |    |
     *	R |   | + |   | +  |	The superceding channel is allowed to
     *	W |   |   | + | +  |	restrict the capabilities of the
     *	RW|   | + | + | +  |	superceded one !
     *	--+---+---+---+----+
     */

    if ((mask & (statePtr->flags & (TCL_READABLE | TCL_WRITABLE))) == 0) {
	Tcl_AppendResult(interp,
		"reading and writing both disallowed for channel \"",
		Tcl_GetChannelName(prevChan), "\"", (char *) NULL);
        return (Tcl_Channel) NULL;
    }

    /*
     * Flush the buffers. This ensures that any data still in them
     * at this time is not handled by the new transformation. Restrict
     * this to writable channels. Take care to hide a possible bg-copy
     * in progress from Tcl_Flush and the CheckForChannelErrors inside.
     */

    if ((mask & TCL_WRITABLE) != 0) {
        CopyState *csPtr;

        csPtr           = statePtr->csPtr;
	statePtr->csPtr = (CopyState*) NULL;

	if (Tcl_Flush((Tcl_Channel) prevChanPtr) != TCL_OK) {
	    statePtr->csPtr = csPtr;
	    Tcl_AppendResult(interp, "could not flush channel \"",
		    Tcl_GetChannelName(prevChan), "\"", (char *) NULL);
	    return (Tcl_Channel) NULL;
	}

	statePtr->csPtr = csPtr;
    }
    /*
     * Discard any input in the buffers. They are not yet read by the
     * user of the channel, so they have to go through the new
     * transformation before reading. As the buffers contain the
     * untransformed form their contents are not only useless but actually
     * distorts our view of the system.
     *
     * To preserve the information without having to read them again and
     * to avoid problems with the location in the channel (seeking might
     * be impossible) we move the buffers from the common state structure
     * into the channel itself. We use the buffers in the channel below
     * the new transformation to hold the data. In the future this allows
     * us to write transformations which pre-read data and push the unused
     * part back when they are going away.
     */

    if (((mask & TCL_READABLE) != 0) &&
	(statePtr->inQueueHead != (ChannelBuffer*) NULL)) {
      /*
       * Remark: It is possible that the channel buffers contain data from
       * some earlier push-backs.
       */

      statePtr->inQueueTail->nextPtr = prevChanPtr->inQueueHead;
      prevChanPtr->inQueueHead       = statePtr->inQueueHead;

      if (prevChanPtr->inQueueTail == (ChannelBuffer*) NULL) {
	prevChanPtr->inQueueTail = statePtr->inQueueTail;
      }

      statePtr->inQueueHead          = (ChannelBuffer*) NULL;
      statePtr->inQueueTail          = (ChannelBuffer*) NULL;
    }

    chanPtr = (Channel *) ckalloc((unsigned) sizeof(Channel));

    /*
     * Save some of the current state into the new structure,
     * reinitialize the parts which will stay with the transformation.
     *
     * Remarks:
     */

    chanPtr->state		= statePtr;
    chanPtr->instanceData	= instanceData;
    chanPtr->typePtr		= typePtr;
    chanPtr->downChanPtr	= prevChanPtr;
    chanPtr->upChanPtr		= (Channel *) NULL;
    chanPtr->inQueueHead        = (ChannelBuffer*) NULL;
    chanPtr->inQueueTail        = (ChannelBuffer*) NULL;

    /*
     * Place new block at the head of a possibly existing list of previously
     * stacked channels.
     */

    prevChanPtr->upChanPtr	= chanPtr;
    statePtr->topChanPtr	= chanPtr;

    return (Tcl_Channel) chanPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_UnstackChannel --
 *
 *	Unstacks an entry in the hash table for a Tcl_Channel
 *	record. This is the reverse to 'Tcl_StackChannel'.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	If TCL_ERROR is returned, the posix error code will be set
 *	with Tcl_SetErrno.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_UnstackChannel (interp, chan)
    Tcl_Interp *interp; /* The interpreter we are working in */
    Tcl_Channel chan;   /* The channel to unstack */
{
    Channel      *chanPtr  = (Channel *) chan;
    ChannelState *statePtr = chanPtr->state;
    int result = 0;

    /*
     * This operation should occur at the top of a channel stack.
     */

    chanPtr = statePtr->topChanPtr;

    if (chanPtr->downChanPtr != (Channel *) NULL) {
        /*
	 * Instead of manipulating the per-thread / per-interp list/hashtable
	 * of registered channels we wind down the state of the transformation,
	 * and then restore the state of underlying channel into the old
	 * structure.
	 */
	Channel *downChanPtr = chanPtr->downChanPtr;

	/*
	 * Flush the buffers. This ensures that any data still in them
	 * at this time _is_ handled by the transformation we are unstacking
	 * right now. Restrict this to writable channels. Take care to hide
	 * a possible bg-copy in progress from Tcl_Flush and the
	 * CheckForChannelErrors inside.
	 */

	if (statePtr->flags & TCL_WRITABLE) {
	    CopyState*    csPtr;

	    csPtr           = statePtr->csPtr;
	    statePtr->csPtr = (CopyState*) NULL;

	    if (Tcl_Flush((Tcl_Channel) chanPtr) != TCL_OK) {
	        statePtr->csPtr = csPtr;
		Tcl_AppendResult(interp, "could not flush channel \"",
			Tcl_GetChannelName((Tcl_Channel) chanPtr), "\"",
			(char *) NULL);
		return TCL_ERROR;
	    }

	    statePtr->csPtr = csPtr;
	}

	/*
	 * Anything in the input queue and the push-back buffers of
	 * the transformation going away is transformed data, but not
	 * yet read. As unstacking means that the caller does not want
	 * to see transformed data any more we have to discard these
	 * bytes. To avoid writing an analogue to 'DiscardInputQueued'
	 * we move the information in the push back buffers to the
	 * input queue and then call 'DiscardInputQueued' on that.
	 */

	if (((statePtr->flags & TCL_READABLE)  != 0) &&
	    ((statePtr->inQueueHead != (ChannelBuffer*) NULL) ||
	     (chanPtr->inQueueHead  != (ChannelBuffer*) NULL))) {

	    if ((statePtr->inQueueHead != (ChannelBuffer*) NULL) &&
		(chanPtr->inQueueHead  != (ChannelBuffer*) NULL)) {
	        statePtr->inQueueTail->nextPtr = chanPtr->inQueueHead;
		statePtr->inQueueTail = chanPtr->inQueueTail;
	        statePtr->inQueueHead = statePtr->inQueueTail;

	    } else if (chanPtr->inQueueHead != (ChannelBuffer*) NULL) {
	        statePtr->inQueueHead = chanPtr->inQueueHead;
		statePtr->inQueueTail = chanPtr->inQueueTail;
	    }

	    chanPtr->inQueueHead          = (ChannelBuffer*) NULL;
	    chanPtr->inQueueTail          = (ChannelBuffer*) NULL;

	    DiscardInputQueued (statePtr, 0);
	}

	statePtr->topChanPtr	= downChanPtr;
	downChanPtr->upChanPtr	= (Channel *) NULL;

	/*
	 * Leave this link intact for closeproc
	 *  chanPtr->downChanPtr	= (Channel *) NULL;
	 */

	/*
	 * Close and free the channel driver state.
	 */

	if (chanPtr->typePtr->closeProc != TCL_CLOSE2PROC) {
	    result = (chanPtr->typePtr->closeProc)(chanPtr->instanceData,
		    interp);
	} else {
	    result = (chanPtr->typePtr->close2Proc)(chanPtr->instanceData,
		    interp, 0);
	}

	chanPtr->typePtr	= NULL;
	/*
	 * AK: Tcl_NotifyChannel may hold a reference to this block of memory
	 */
	Tcl_EventuallyFree((ClientData) chanPtr, TCL_DYNAMIC);
	UpdateInterest(downChanPtr);

	if (result != 0) {
	    Tcl_SetErrno(result);
	    return TCL_ERROR;
	}
    } else {
        /*
	 * This channel does not cover another one.
	 * Simply do a close, if necessary.
	 */

        if (statePtr->refCount <= 0) {
            if (Tcl_Close(interp, chan) != TCL_OK) {
                return TCL_ERROR;
            }
	}
    }

    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetStackedChannel --
 *
 *	Determines whether the specified channel is stacked upon another.
 *
 * Results:
 *	NULL if the channel is not stacked upon another one, or a reference
 *	to the channel it is stacked upon. This reference can be used in
 *	queries, but modification is not allowed.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_Channel
Tcl_GetStackedChannel(chan)
    Tcl_Channel chan;
{
    Channel *chanPtr = (Channel *) chan;	/* The actual channel. */

    return (Tcl_Channel) chanPtr->downChanPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetTopChannel --
 *
 *	Returns the top channel of a channel stack.
 *
 * Results:
 *	NULL if the channel is not stacked upon another one, or a reference
 *	to the channel it is stacked upon. This reference can be used in
 *	queries, but modification is not allowed.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_Channel
Tcl_GetTopChannel(chan)
    Tcl_Channel chan;
{
    Channel *chanPtr = (Channel *) chan;	/* The actual channel. */

    return (Tcl_Channel) chanPtr->state->topChanPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetChannelInstanceData --
 *
 *	Returns the client data associated with a channel.
 *
 * Results:
 *	The client data.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

ClientData
Tcl_GetChannelInstanceData(chan)
    Tcl_Channel chan;		/* Channel for which to return client data. */
{
    Channel *chanPtr = (Channel *) chan;	/* The actual channel. */

    return chanPtr->instanceData;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetChannelThread --
 *
 *	Given a channel structure, returns the thread managing it.
 *	TIP #10
 *
 * Results:
 *	Returns the id of the thread managing the channel.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_ThreadId
Tcl_GetChannelThread(chan)
    Tcl_Channel chan;		/* The channel to return managing thread for. */
{
    Channel *chanPtr = (Channel *) chan;	/* The actual channel. */

    return chanPtr->state->managingThread;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetChannelType --
 *
 *	Given a channel structure, returns the channel type structure.
 *
 * Results:
 *	Returns a pointer to the channel type structure.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_ChannelType *
Tcl_GetChannelType(chan)
    Tcl_Channel chan;		/* The channel to return type for. */
{
    Channel *chanPtr = (Channel *) chan;	/* The actual channel. */

    return chanPtr->typePtr;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetChannelMode --
 *
 *	Computes a mask indicating whether the channel is open for
 *	reading and writing.
 *
 * Results:
 *	An OR-ed combination of TCL_READABLE and TCL_WRITABLE.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_GetChannelMode(chan)
    Tcl_Channel chan;		/* The channel for which the mode is
                                 * being computed. */
{
    ChannelState *statePtr = ((Channel *) chan)->state;
					/* State of actual channel. */

    return (statePtr->flags & (TCL_READABLE | TCL_WRITABLE));
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetChannelName --
 *
 *	Returns the string identifying the channel name.
 *
 * Results:
 *	The string containing the channel name. This memory is
 *	owned by the generic layer and should not be modified by
 *	the caller.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

CONST char *
Tcl_GetChannelName(chan)
    Tcl_Channel chan;		/* The channel for which to return the name. */
{
    ChannelState *statePtr;	/* State of actual channel. */

    statePtr = ((Channel *) chan)->state;
    return statePtr->channelName;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetChannelHandle --
 *
 *	Returns an OS handle associated with a channel.
 *
 * Results:
 *	Returns TCL_OK and places the handle in handlePtr, or returns
 *	TCL_ERROR on failure.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_GetChannelHandle(chan, direction, handlePtr)
    Tcl_Channel chan;		/* The channel to get file from. */
    int direction;		/* TCL_WRITABLE or TCL_READABLE. */
    ClientData *handlePtr;	/* Where to store handle */
{
    Channel *chanPtr;		/* The actual channel. */
    ClientData handle;
    int result;

    chanPtr = ((Channel *) chan)->state->bottomChanPtr;
    result = (chanPtr->typePtr->getHandleProc)(chanPtr->instanceData,
	    direction, &handle);
    if (handlePtr) {
	*handlePtr = handle;
    }
    return result;
}

/*
 *---------------------------------------------------------------------------
 *
 * AllocChannelBuffer --
 *
 *	A channel buffer has BUFFER_PADDING bytes extra at beginning to
 *	hold any bytes of a native-encoding character that got split by
 *	the end of the previous buffer and need to be moved to the
 *	beginning of the next buffer to make a contiguous string so it
 *	can be converted to UTF-8.
 *
 *	A channel buffer has BUFFER_PADDING bytes extra at the end to
 *	hold any bytes of a native-encoding character (generated from a
 *	UTF-8 character) that overflow past the end of the buffer and
 *	need to be moved to the next buffer.
 *
 * Results:
 *	A newly allocated channel buffer.
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
 */

static ChannelBuffer *
AllocChannelBuffer(length)
    int length;			/* Desired length of channel buffer. */
{
    ChannelBuffer *bufPtr;
    int n;

    n = length + CHANNELBUFFER_HEADER_SIZE + BUFFER_PADDING + BUFFER_PADDING;
    bufPtr = (ChannelBuffer *) ckalloc((unsigned) n);
    bufPtr->nextAdded	= BUFFER_PADDING;
    bufPtr->nextRemoved	= BUFFER_PADDING;
    bufPtr->bufLength	= length + BUFFER_PADDING;
    bufPtr->nextPtr	= (ChannelBuffer *) NULL;
    return bufPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * RecycleBuffer --
 *
 *	Helper function to recycle input and output buffers. Ensures
 *	that two input buffers are saved (one in the input queue and
 *	another in the saveInBufPtr field) and that curOutPtr is set
 *	to a buffer. Only if these conditions are met is the buffer
 *	freed to the OS.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	May free a buffer to the OS.
 *
 *----------------------------------------------------------------------
 */

static void
RecycleBuffer(statePtr, bufPtr, mustDiscard)
    ChannelState *statePtr;	/* ChannelState in which to recycle buffers. */
    ChannelBuffer *bufPtr;	/* The buffer to recycle. */
    int mustDiscard;		/* If nonzero, free the buffer to the
                                 * OS, always. */
{
    /*
     * Do we have to free the buffer to the OS?
     */

    if (mustDiscard) {
        ckfree((char *) bufPtr);
        return;
    }

    /*
     * Only save buffers which are at least as big as the requested
     * buffersize for the channel. This is to honor dynamic changes
     * of the buffersize made by the user.
     */

    if ((bufPtr->bufLength - BUFFER_PADDING) < statePtr->bufSize) {
        ckfree((char *) bufPtr);
        return;
    }

    /*
     * Only save buffers for the input queue if the channel is readable.
     */
    
    if (statePtr->flags & TCL_READABLE) {
        if (statePtr->inQueueHead == (ChannelBuffer *) NULL) {
            statePtr->inQueueHead = bufPtr;
            statePtr->inQueueTail = bufPtr;
            goto keepit;
        }
        if (statePtr->saveInBufPtr == (ChannelBuffer *) NULL) {
            statePtr->saveInBufPtr = bufPtr;
            goto keepit;
        }
    }

    /*
     * Only save buffers for the output queue if the channel is writable.
     */

    if (statePtr->flags & TCL_WRITABLE) {
        if (statePtr->curOutPtr == (ChannelBuffer *) NULL) {
            statePtr->curOutPtr = bufPtr;
            goto keepit;
        }
    }

    /*
     * If we reached this code we return the buffer to the OS.
     */

    ckfree((char *) bufPtr);
    return;

    keepit:
    bufPtr->nextRemoved = BUFFER_PADDING;
    bufPtr->nextAdded = BUFFER_PADDING;
    bufPtr->nextPtr = (ChannelBuffer *) NULL;
}

/*
 *----------------------------------------------------------------------
 *
 * DiscardOutputQueued --
 *
 *	Discards all output queued in the output queue of a channel.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Recycles buffers.
 *
 *----------------------------------------------------------------------
 */

static void
DiscardOutputQueued(statePtr)
    ChannelState *statePtr;	/* ChannelState for which to discard output. */
{
    ChannelBuffer *bufPtr;
    
    while (statePtr->outQueueHead != (ChannelBuffer *) NULL) {
        bufPtr = statePtr->outQueueHead;
        statePtr->outQueueHead = bufPtr->nextPtr;
        RecycleBuffer(statePtr, bufPtr, 0);
    }
    statePtr->outQueueHead = (ChannelBuffer *) NULL;
    statePtr->outQueueTail = (ChannelBuffer *) NULL;
}

/*
 *----------------------------------------------------------------------
 *
 * CheckForDeadChannel --
 *
 *	This function checks is a given channel is Dead.
 *      (A channel that has been closed but not yet deallocated.)
 *
 * Results:
 *	True (1) if channel is Dead, False (0) if channel is Ok
 *
 * Side effects:
 *      None
 *
 *----------------------------------------------------------------------
 */

static int
CheckForDeadChannel(interp, statePtr)
    Tcl_Interp *interp;		/* For error reporting (can be NULL) */
    ChannelState *statePtr;	/* The channel state to check. */
{
    if (statePtr->flags & CHANNEL_DEAD) {
        Tcl_SetErrno(EINVAL);
	if (interp) {
	    Tcl_AppendResult(interp,
		    "unable to access channel: invalid channel",
		    (char *) NULL);   
	}
	return 1;
    }
    return 0;
}

/*
 *----------------------------------------------------------------------
 *
 * FlushChannel --
 *
 *	This function flushes as much of the queued output as is possible
 *	now. If calledFromAsyncFlush is nonzero, it is being called in an
 *	event handler to flush channel output asynchronously.
 *
 * Results:
 *	0 if successful, else the error code that was returned by the
 *	channel type operation.
 *
 * Side effects:
 *	May produce output on a channel. May block indefinitely if the
 *	channel is synchronous. May schedule an async flush on the channel.
 *	May recycle memory for buffers in the output queue.
 *
 *----------------------------------------------------------------------
 */

static int
FlushChannel(interp, chanPtr, calledFromAsyncFlush)
    Tcl_Interp *interp;			/* For error reporting during close. */
    Channel *chanPtr;			/* The channel to flush on. */
    int calledFromAsyncFlush;		/* If nonzero then we are being
                                         * called from an asynchronous
                                         * flush callback. */
{
    ChannelState *statePtr = chanPtr->state;
					/* State of the channel stack. */
    ChannelBuffer *bufPtr;		/* Iterates over buffered output
                                         * queue. */
    int toWrite;			/* Amount of output data in current
                                         * buffer available to be written. */
    int written;			/* Amount of output data actually
                                         * written in current round. */
    int errorCode = 0;			/* Stores POSIX error codes from
                                         * channel driver operations. */
    int wroteSome = 0;			/* Set to one if any data was
					 * written to the driver. */

    /*
     * Prevent writing on a dead channel -- a channel that has been closed
     * but not yet deallocated. This can occur if the exit handler for the
     * channel deallocation runs before all channels are deregistered in
     * all interpreters.
     */
    
    if (CheckForDeadChannel(interp, statePtr)) return -1;
    
    /*
     * Loop over the queued buffers and attempt to flush as
     * much as possible of the queued output to the channel.
     */

    while (1) {

        /*
         * If the queue is empty and there is a ready current buffer, OR if
         * the current buffer is full, then move the current buffer to the
         * queue.
         */

        if (((statePtr->curOutPtr != (ChannelBuffer *) NULL) &&
                (statePtr->curOutPtr->nextAdded == statePtr->curOutPtr->bufLength))
                || ((statePtr->flags & BUFFER_READY) &&
                        (statePtr->outQueueHead == (ChannelBuffer *) NULL))) {
            statePtr->flags &= (~(BUFFER_READY));
            statePtr->curOutPtr->nextPtr = (ChannelBuffer *) NULL;
            if (statePtr->outQueueHead == (ChannelBuffer *) NULL) {
                statePtr->outQueueHead = statePtr->curOutPtr;
            } else {
                statePtr->outQueueTail->nextPtr = statePtr->curOutPtr;
            }
            statePtr->outQueueTail = statePtr->curOutPtr;
            statePtr->curOutPtr = (ChannelBuffer *) NULL;
        }
        bufPtr = statePtr->outQueueHead;

        /*
         * If we are not being called from an async flush and an async
         * flush is active, we just return without producing any output.
         */

        if ((!calledFromAsyncFlush) &&
                (statePtr->flags & BG_FLUSH_SCHEDULED)) {
            return 0;
        }

        /*
         * If the output queue is still empty, break out of the while loop.
         */

        if (bufPtr == (ChannelBuffer *) NULL) {
            break;	/* Out of the "while (1)". */
        }

        /*
         * Produce the output on the channel.
         */

        toWrite = bufPtr->nextAdded - bufPtr->nextRemoved;
        written = (chanPtr->typePtr->outputProc) (chanPtr->instanceData,
                bufPtr->buf + bufPtr->nextRemoved, toWrite,
		&errorCode);

	/*
         * If the write failed completely attempt to start the asynchronous
         * flush mechanism and break out of this loop - do not attempt to
         * write any more output at this time.
         */

        if (written < 0) {
            
            /*
             * If the last attempt to write was interrupted, simply retry.
             */
            
            if (errorCode == EINTR) {
                errorCode = 0;
                continue;
            }

            /*
             * If the channel is non-blocking and we would have blocked,
             * start a background flushing handler and break out of the loop.
             */

            if ((errorCode == EWOULDBLOCK) || (errorCode == EAGAIN)) {
		/*
		 * This used to check for CHANNEL_NONBLOCKING, and panic
		 * if the channel was blocking.  However, it appears
		 * that setting stdin to -blocking 0 has some effect on
		 * the stdout when it's a tty channel (dup'ed underneath)
		 */
		if (!(statePtr->flags & BG_FLUSH_SCHEDULED)) {
		    statePtr->flags |= BG_FLUSH_SCHEDULED;
		    UpdateInterest(chanPtr);
		}
		errorCode = 0;
		break;
            }

            /*
             * Decide whether to report the error upwards or defer it.
             */

            if (calledFromAsyncFlush) {
                if (statePtr->unreportedError == 0) {
                    statePtr->unreportedError = errorCode;
                }
            } else {
                Tcl_SetErrno(errorCode);
		if (interp != NULL) {

		    /*
		     * Casting away CONST here is safe because the
		     * TCL_VOLATILE flag guarantees CONST treatment
		     * of the Posix error string.
		     */

		    Tcl_SetResult(interp,
			    (char *) Tcl_PosixError(interp), TCL_VOLATILE);
		}
            }

            /*
             * When we get an error we throw away all the output
             * currently queued.
             */

            DiscardOutputQueued(statePtr);
            continue;
        } else {
	    wroteSome = 1;
	}

        bufPtr->nextRemoved += written;

        /*
         * If this buffer is now empty, recycle it.
         */

        if (bufPtr->nextRemoved == bufPtr->nextAdded) {
            statePtr->outQueueHead = bufPtr->nextPtr;
            if (statePtr->outQueueHead == (ChannelBuffer *) NULL) {
                statePtr->outQueueTail = (ChannelBuffer *) NULL;
            }
            RecycleBuffer(statePtr, bufPtr, 0);
        }
    }	/* Closes "while (1)". */

    /*
     * If we wrote some data while flushing in the background, we are done.
     * We can't finish the background flush until we run out of data and
     * the channel becomes writable again.  This ensures that all of the
     * pending data has been flushed at the system level.
     */

    if (statePtr->flags & BG_FLUSH_SCHEDULED) {
	if (wroteSome) {
	    return errorCode;
	} else if (statePtr->outQueueHead == (ChannelBuffer *) NULL) {
	    statePtr->flags &= (~(BG_FLUSH_SCHEDULED));
	    (chanPtr->typePtr->watchProc)(chanPtr->instanceData,
		    statePtr->interestMask);
	}
    }

    /*
     * If the channel is flagged as closed, delete it when the refCount
     * drops to zero, the output queue is empty and there is no output
     * in the current output buffer.
     */

    if ((statePtr->flags & CHANNEL_CLOSED) && (statePtr->refCount <= 0) &&
            (statePtr->outQueueHead == (ChannelBuffer *) NULL) &&
            ((statePtr->curOutPtr == (ChannelBuffer *) NULL) ||
                    (statePtr->curOutPtr->nextAdded ==
                            statePtr->curOutPtr->nextRemoved))) {
	return CloseChannel(interp, chanPtr, errorCode);
    }
    return errorCode;
}

/*
 *----------------------------------------------------------------------
 *
 * CloseChannel --
 *
 *	Utility procedure to close a channel and free associated resources.
 *
 *	If the channel was stacked, then the it will copy the necessary
 *	elements of the NEXT channel into the TOP channel, in essence
 *	unstacking the channel.  The NEXT channel will then be freed.
 *
 *	If the channel was not stacked, then we will free all the bits
 *	for the TOP channel, including the data structure itself.
 *
 * Results:
 *	1 if the channel was stacked, 0 otherwise.
 *
 * Side effects:
 *	May close the actual channel; may free memory.
 *	May change the value of errno.
 *
 *----------------------------------------------------------------------
 */

static int
CloseChannel(interp, chanPtr, errorCode)
    Tcl_Interp *interp;			/* For error reporting. */
    Channel *chanPtr;			/* The channel to close. */
    int errorCode;			/* Status of operation so far. */
{
    int result = 0;			/* Of calling driver close
                                         * operation. */
    ChannelState *statePtr;		/* state of the channel stack. */
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    if (chanPtr == NULL) {
        return result;
    }
    statePtr = chanPtr->state;

    /*
     * No more input can be consumed so discard any leftover input.
     */

    DiscardInputQueued(statePtr, 1);

    /*
     * Discard a leftover buffer in the current output buffer field.
     */

    if (statePtr->curOutPtr != (ChannelBuffer *) NULL) {
        ckfree((char *) statePtr->curOutPtr);
        statePtr->curOutPtr = (ChannelBuffer *) NULL;
    }
    
    /*
     * The caller guarantees that there are no more buffers
     * queued for output.
     */

    if (statePtr->outQueueHead != (ChannelBuffer *) NULL) {
        panic("TclFlush, closed channel: queued output left");
    }

    /*
     * If the EOF character is set in the channel, append that to the
     * output device.
     */

    if ((statePtr->outEofChar != 0) && (statePtr->flags & TCL_WRITABLE)) {
        int dummy;
        char c;

        c = (char) statePtr->outEofChar;
        (chanPtr->typePtr->outputProc) (chanPtr->instanceData, &c, 1, &dummy);
    }

    /*
     * Remove this channel from of the list of all channels.
     */
    Tcl_CutChannel((Tcl_Channel) chanPtr);

    /*
     * Close and free the channel driver state.
     */

    if (chanPtr->typePtr->closeProc != TCL_CLOSE2PROC) {
	result = (chanPtr->typePtr->closeProc)(chanPtr->instanceData, interp);
    } else {
	result = (chanPtr->typePtr->close2Proc)(chanPtr->instanceData, interp,
		0);
    }

    /*
     * Some resources can be cleared only if the bottom channel
     * in a stack is closed. All the other channels in the stack
     * are not allowed to remove.
     */

    if (chanPtr == statePtr->bottomChanPtr) {
	if (statePtr->channelName != (char *) NULL) {
	    ckfree((char *) statePtr->channelName);
	    statePtr->channelName = NULL;
	}

	Tcl_FreeEncoding(statePtr->encoding);
	if (statePtr->outputStage != NULL) {
	    ckfree((char *) statePtr->outputStage);
	    statePtr->outputStage = (char *) NULL;
	}
    }

    /*
     * If we are being called synchronously, report either
     * any latent error on the channel or the current error.
     */

    if (statePtr->unreportedError != 0) {
        errorCode = statePtr->unreportedError;
    }
    if (errorCode == 0) {
        errorCode = result;
        if (errorCode != 0) {
            Tcl_SetErrno(errorCode);
        }
    }

    /*
     * Cancel any outstanding timer.
     */

    Tcl_DeleteTimerHandler(statePtr->timer);

    /*
     * Mark the channel as deleted by clearing the type structure.
     */

    if (chanPtr->downChanPtr != (Channel *) NULL) {
	Channel *downChanPtr = chanPtr->downChanPtr;

	statePtr->nextCSPtr	= tsdPtr->firstCSPtr;
	tsdPtr->firstCSPtr	= statePtr;

	statePtr->topChanPtr	= downChanPtr;
	downChanPtr->upChanPtr	= (Channel *) NULL;
	chanPtr->typePtr	= NULL;

	Tcl_EventuallyFree((ClientData) chanPtr, TCL_DYNAMIC);
	return Tcl_Close(interp, (Tcl_Channel) downChanPtr);
    }

    /*
     * There is only the TOP Channel, so we free the remaining
     * pointers we have and then ourselves.  Since this is the
     * last of the channels in the stack, make sure to free the
     * ChannelState structure associated with it.  We use
     * Tcl_EventuallyFree to allow for any last
     */
    chanPtr->typePtr = NULL;

    Tcl_EventuallyFree((ClientData) statePtr, TCL_DYNAMIC);
    Tcl_EventuallyFree((ClientData) chanPtr, TCL_DYNAMIC);

    return errorCode;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_CutChannel --
 *
 *	Removes a channel from the (thread-)global list of all channels
 *	(in that thread).  This is actually the statePtr for the stack
 *	of channel.
 *
 * Results:
 *	Nothing.
 *
 * Side effects:
 *	Resets the field 'nextCSPtr' of the specified channel state to NULL.
 *
 * NOTE:
 *	The channel to splice out of the list must not be referenced
 *	in any interpreter. This is something this procedure cannot
 *	check (despite the refcount) because the caller usually wants
 *	fiddle with the channel (like transfering it to a different
 *	thread) and thus keeps the refcount artifically high to prevent
 *	its destruction.
 *
 *----------------------------------------------------------------------
 */

void
Tcl_CutChannel(chan)
    Tcl_Channel chan;			/* The channel being removed. Must
                                         * not be referenced in any
                                         * interpreter. */
{
    ThreadSpecificData* tsdPtr  = TCL_TSD_INIT(&dataKey);
    ChannelState *prevCSPtr;		/* Preceding channel state in list of
                                         * all states - used to splice a
                                         * channel out of the list on close. */
    ChannelState *statePtr = ((Channel *) chan)->state;
					/* state of the channel stack. */

    /*
     * Remove this channel from of the list of all channels
     * (in the current thread).
     */

    if (tsdPtr->firstCSPtr && (statePtr == tsdPtr->firstCSPtr)) {
        tsdPtr->firstCSPtr = statePtr->nextCSPtr;
    } else {
        for (prevCSPtr = tsdPtr->firstCSPtr;
	     prevCSPtr && (prevCSPtr->nextCSPtr != statePtr);
	     prevCSPtr = prevCSPtr->nextCSPtr) {
            /* Empty loop body. */
        }
        if (prevCSPtr == (ChannelState *) NULL) {
            panic("FlushChannel: damaged channel list");
        }
        prevCSPtr->nextCSPtr = statePtr->nextCSPtr;
    }

    statePtr->nextCSPtr = (ChannelState *) NULL;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_SpliceChannel --
 *
 *	Adds a channel to the (thread-)global list of all channels
 *	(in that thread). Expects that the field 'nextChanPtr' in
 *	the channel is set to NULL.
 *
 * Results:
 *	Nothing.
 *
 * Side effects:
 *	Nothing.
 *
 * NOTE:
 *	The channel to add to the list must not be referenced in any
 *	interpreter. This is something this procedure cannot check
 *	(despite the refcount) because the caller usually wants figgle
 *	with the channel (like transfering it to a different thread)
 *	and thus keeps the refcount artifically high to prevent its
 *	destruction.
 *
 *----------------------------------------------------------------------
 */

void
Tcl_SpliceChannel(chan)
    Tcl_Channel chan;			/* The channel being added. Must
                                         * not be referenced in any
                                         * interpreter. */
{
    ThreadSpecificData	*tsdPtr = TCL_TSD_INIT(&dataKey);
    ChannelState	*statePtr = ((Channel *) chan)->state;

    if (statePtr->nextCSPtr != (ChannelState *) NULL) {
        panic("Tcl_SpliceChannel: trying to add channel used in different list");
    }

    statePtr->nextCSPtr	= tsdPtr->firstCSPtr;
    tsdPtr->firstCSPtr	= statePtr;

    /*
     * TIP #10. Mark the current thread as the new one managing this
     *          channel. Note: 'Tcl_GetCurrentThread' returns sensible
     *          values even for a non-threaded core.
     */

    statePtr->managingThread = Tcl_GetCurrentThread ();
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_Close --
 *
 *	Closes a channel.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	Closes the channel if this is the last reference.
 *
 * NOTE:
 *	Tcl_Close removes the channel as far as the user is concerned.
 *	However, it may continue to exist for a while longer if it has
 *	a background flush scheduled. The device itself is eventually
 *	closed and the channel record removed, in CloseChannel, above.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
int
Tcl_Close(interp, chan)
    Tcl_Interp *interp;			/* Interpreter for errors. */
    Tcl_Channel chan;			/* The channel being closed. Must
                                         * not be referenced in any
                                         * interpreter. */
{
    CloseCallback *cbPtr;		/* Iterate over close callbacks
                                         * for this channel. */
    Channel *chanPtr;			/* The real IO channel. */
    ChannelState *statePtr;		/* State of real IO channel. */
    int result;				/* Of calling FlushChannel. */

    if (chan == (Tcl_Channel) NULL) {
        return TCL_OK;
    }

    /*
     * Perform special handling for standard channels being closed. If the
     * refCount is now 1 it means that the last reference to the standard
     * channel is being explicitly closed, so bump the refCount down
     * artificially to 0. This will ensure that the channel is actually
     * closed, below. Also set the static pointer to NULL for the channel.
     */

    CheckForStdChannelsBeingClosed(chan);

    /*
     * This operation should occur at the top of a channel stack.
     */

    chanPtr	= (Channel *) chan;
    statePtr	= chanPtr->state;
    chanPtr	= statePtr->topChanPtr;

    if (statePtr->refCount > 0) {
        panic("called Tcl_Close on channel with refCount > 0");
    }

    /*
     * When the channel has an escape sequence driven encoding such as
     * iso2022, the terminated escape sequence must write to the buffer.
     */
    if ((statePtr->encoding != NULL) && (statePtr->curOutPtr != NULL)
	    && (CheckChannelErrors(statePtr, TCL_WRITABLE) == 0)) {
        statePtr->outputEncodingFlags |= TCL_ENCODING_END;
        WriteChars(chanPtr, "", 0);
    }

    Tcl_ClearChannelHandlers(chan);

    /*
     * Invoke the registered close callbacks and delete their records.
     */

    while (statePtr->closeCbPtr != (CloseCallback *) NULL) {
        cbPtr = statePtr->closeCbPtr;
        statePtr->closeCbPtr = cbPtr->nextPtr;
        (cbPtr->proc) (cbPtr->clientData);
        ckfree((char *) cbPtr);
    }

    /*
     * Ensure that the last output buffer will be flushed.
     */
    
    if ((statePtr->curOutPtr != (ChannelBuffer *) NULL) &&
	    (statePtr->curOutPtr->nextAdded > statePtr->curOutPtr->nextRemoved)) {
        statePtr->flags |= BUFFER_READY;
    }

    /*
     * If this channel supports it, close the read side, since we don't need it
     * anymore and this will help avoid deadlocks on some channel types.
     */

    if (chanPtr->typePtr->closeProc == TCL_CLOSE2PROC) {
	result = (chanPtr->typePtr->close2Proc)(chanPtr->instanceData, interp,
		TCL_CLOSE_READ);
    } else {
	result = 0;
    }

    /*
     * The call to FlushChannel will flush any queued output and invoke
     * the close function of the channel driver, or it will set up the
     * channel to be flushed and closed asynchronously.
     */

    statePtr->flags |= CHANNEL_CLOSED;
    if ((FlushChannel(interp, chanPtr, 0) != 0) || (result != 0)) {
        return TCL_ERROR;
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_ClearChannelHandlers --
 *
 *	Removes all channel handlers and event scripts from the channel,
 *	cancels all background copies involving the channel and any interest
 *	in events.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	See above. Deallocates memory.
 *
 *----------------------------------------------------------------------
 */

void
Tcl_ClearChannelHandlers (channel)
    Tcl_Channel channel;
{
    ChannelHandler *chPtr, *chNext;	/* Iterate over channel handlers. */
    EventScriptRecord *ePtr, *eNextPtr;	/* Iterate over eventscript records. */
    Channel *chanPtr;			/* The real IO channel. */
    ChannelState *statePtr;		/* State of real IO channel. */
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    NextChannelHandler *nhPtr;

    /*
     * This operation should occur at the top of a channel stack.
     */

    chanPtr	= (Channel *) channel;
    statePtr	= chanPtr->state;
    chanPtr	= statePtr->topChanPtr;

    /*
     * Remove any references to channel handlers for this channel that
     * may be about to be invoked.
     */

    for (nhPtr = tsdPtr->nestedHandlerPtr;
	 nhPtr != (NextChannelHandler *) NULL;
	 nhPtr = nhPtr->nestedHandlerPtr) {
        if (nhPtr->nextHandlerPtr &&
		(nhPtr->nextHandlerPtr->chanPtr == chanPtr)) {
	    nhPtr->nextHandlerPtr = NULL;
        }
    }

    /*
     * Remove all the channel handler records attached to the channel
     * itself.
     */

    for (chPtr = statePtr->chPtr;
	 chPtr != (ChannelHandler *) NULL;
	 chPtr = chNext) {
        chNext = chPtr->nextPtr;
        ckfree((char *) chPtr);
    }
    statePtr->chPtr = (ChannelHandler *) NULL;

    /*
     * Cancel any pending copy operation.
     */

    StopCopy(statePtr->csPtr);

    /*
     * Must set the interest mask now to 0, otherwise infinite loops
     * will occur if Tcl_DoOneEvent is called before the channel is
     * finally deleted in FlushChannel. This can happen if the channel
     * has a background flush active.
     */
        
    statePtr->interestMask = 0;
    
    /*
     * Remove any EventScript records for this channel.
     */

    for (ePtr = statePtr->scriptRecordPtr;
	 ePtr != (EventScriptRecord *) NULL;
	 ePtr = eNextPtr) {
        eNextPtr = ePtr->nextPtr;
	Tcl_DecrRefCount(ePtr->scriptPtr);
        ckfree((char *) ePtr);
    }
    statePtr->scriptRecordPtr = (EventScriptRecord *) NULL;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_Write --
 *
 *	Puts a sequence of bytes into an output buffer, may queue the
 *	buffer for output if it gets full, and also remembers whether the
 *	current buffer is ready e.g. if it contains a newline and we are in
 *	line buffering mode. Compensates stacking, i.e. will redirect the
 *	data from the specified channel to the topmost channel in a stack.
 *
 *	No encoding conversions are applied to the bytes being read.
 *
 * Results:
 *	The number of bytes written or -1 in case of error. If -1,
 *	Tcl_GetErrno will return the error code.
 *
 * Side effects:
 *	May buffer up output and may cause output to be produced on the
 *	channel.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_Write(chan, src, srcLen)
    Tcl_Channel chan;			/* The channel to buffer output for. */
    CONST char *src;			/* Data to queue in output buffer. */
    int srcLen;				/* Length of data in bytes, or < 0 for
					 * strlen(). */
{
    /*
     * Always use the topmost channel of the stack
     */
    Channel *chanPtr;
    ChannelState *statePtr;	/* state info for channel */

    statePtr = ((Channel *) chan)->state;
    chanPtr  = statePtr->topChanPtr;

    if (CheckChannelErrors(statePtr, TCL_WRITABLE) != 0) {
	return -1;
    }

    if (srcLen < 0) {
        srcLen = strlen(src);
    }
    return DoWrite(chanPtr, src, srcLen);
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_WriteRaw --
 *
 *	Puts a sequence of bytes into an output buffer, may queue the
 *	buffer for output if it gets full, and also remembers whether the
 *	current buffer is ready e.g. if it contains a newline and we are in
 *	line buffering mode. Writes directly to the driver of the channel,
 *	does not compensate for stacking.
 *
 *	No encoding conversions are applied to the bytes being read.
 *
 * Results:
 *	The number of bytes written or -1 in case of error. If -1,
 *	Tcl_GetErrno will return the error code.
 *
 * Side effects:
 *	May buffer up output and may cause output to be produced on the
 *	channel.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_WriteRaw(chan, src, srcLen)
    Tcl_Channel chan;			/* The channel to buffer output for. */
    CONST char *src;			/* Data to queue in output buffer. */
    int srcLen;				/* Length of data in bytes, or < 0 for
					 * strlen(). */
{
    Channel *chanPtr = ((Channel *) chan);
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    int errorCode, written;

    if (CheckChannelErrors(statePtr, TCL_WRITABLE | CHANNEL_RAW_MODE) != 0) {
	return -1;
    }

    if (srcLen < 0) {
        srcLen = strlen(src);
    }

    /*
     * Go immediately to the driver, do all the error handling by ourselves.
     * The code was stolen from 'FlushChannel'.
     */

    written = (chanPtr->typePtr->outputProc) (chanPtr->instanceData,
	    src, srcLen, &errorCode);

    if (written < 0) {
	Tcl_SetErrno(errorCode);
    }

    return written;
}

/*
 *---------------------------------------------------------------------------
 *
 * Tcl_WriteChars --
 *
 *	Takes a sequence of UTF-8 characters and converts them for output
 *	using the channel's current encoding, may queue the buffer for
 *	output if it gets full, and also remembers whether the current
 *	buffer is ready e.g. if it contains a newline and we are in
 *	line buffering mode. Compensates stacking, i.e. will redirect the
 *	data from the specified channel to the topmost channel in a stack.
 *
 * Results:
 *	The number of bytes written or -1 in case of error. If -1,
 *	Tcl_GetErrno will return the error code.
 *
 * Side effects:
 *	May buffer up output and may cause output to be produced on the
 *	channel.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_WriteChars(chan, src, len)
    Tcl_Channel chan;		/* The channel to buffer output for. */
    CONST char *src;		/* UTF-8 characters to queue in output buffer. */
    int len;			/* Length of string in bytes, or < 0 for 
				 * strlen(). */
{
    ChannelState *statePtr;	/* state info for channel */

    statePtr = ((Channel *) chan)->state;

    if (CheckChannelErrors(statePtr, TCL_WRITABLE) != 0) {
	return -1;
    }

    return DoWriteChars ((Channel*) chan, src, len);
}

/*
 *---------------------------------------------------------------------------
 *
 * DoWriteChars --
 *
 *	Takes a sequence of UTF-8 characters and converts them for output
 *	using the channel's current encoding, may queue the buffer for
 *	output if it gets full, and also remembers whether the current
 *	buffer is ready e.g. if it contains a newline and we are in
 *	line buffering mode. Compensates stacking, i.e. will redirect the
 *	data from the specified channel to the topmost channel in a stack.
 *
 * Results:
 *	The number of bytes written or -1 in case of error. If -1,
 *	Tcl_GetErrno will return the error code.
 *
 * Side effects:
 *	May buffer up output and may cause output to be produced on the
 *	channel.
 *
 *----------------------------------------------------------------------
 */

static int
DoWriteChars(chanPtr, src, len)
    Channel* chanPtr;		/* The channel to buffer output for. */
    CONST char *src;		/* UTF-8 characters to queue in output buffer. */
    int len;			/* Length of string in bytes, or < 0 for 
				 * strlen(). */
{
    /*
     * Always use the topmost channel of the stack
     */
    ChannelState *statePtr;	/* state info for channel */

    statePtr = chanPtr->state;
    chanPtr  = statePtr->topChanPtr;

    if (len < 0) {
        len = strlen(src);
    }
    if (statePtr->encoding == NULL) {
	/*
	 * Inefficient way to convert UTF-8 to byte-array, but the  
	 * code parallels the way it is done for objects.
	 */

	Tcl_Obj *objPtr;
	int result;

	objPtr = Tcl_NewStringObj(src, len);
	src = (char *) Tcl_GetByteArrayFromObj(objPtr, &len);
	result = WriteBytes(chanPtr, src, len);
	Tcl_DecrRefCount(objPtr);
	return result;
    }
    return WriteChars(chanPtr, src, len);
}

/*
 *---------------------------------------------------------------------------
 *
 * Tcl_WriteObj --
 *
 *	Takes the Tcl object and queues its contents for output.  If the 
 *	encoding of the channel is NULL, takes the byte-array representation 
 *	of the object and queues those bytes for output.  Otherwise, takes 
 *	the characters in the UTF-8 (string) representation of the object 
 *	and converts them for output using the channel's current encoding.  
 *	May flush internal buffers to output if one becomes full or is ready 
 *	for some other reason, e.g. if it contains a newline and the channel 
 *	is in line buffering mode.
 *
 * Results:
 *	The number of bytes written or -1 in case of error. If -1, 
 *	Tcl_GetErrno() will return the error code.
 *
 * Side effects:
 *	May buffer up output and may cause output to be produced on the
 *	channel.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_WriteObj(chan, objPtr)
    Tcl_Channel chan;		/* The channel to buffer output for. */
    Tcl_Obj *objPtr;		/* The object to write. */
{
    /*
     * Always use the topmost channel of the stack
     */
    Channel *chanPtr;
    ChannelState *statePtr;	/* state info for channel */
    char *src;
    int srcLen;

    statePtr = ((Channel *) chan)->state;
    chanPtr  = statePtr->topChanPtr;

    if (CheckChannelErrors(statePtr, TCL_WRITABLE) != 0) {
	return -1;
    }
    if (statePtr->encoding == NULL) {
	src = (char *) Tcl_GetByteArrayFromObj(objPtr, &srcLen);
	return WriteBytes(chanPtr, src, srcLen);
    } else {
	src = Tcl_GetStringFromObj(objPtr, &srcLen);
	return WriteChars(chanPtr, src, srcLen);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * WriteBytes --
 *
 *	Write a sequence of bytes into an output buffer, may queue the
 *	buffer for output if it gets full, and also remembers whether the
 *	current buffer is ready e.g. if it contains a newline and we are in
 *	line buffering mode.
 *
 * Results:
 *	The number of bytes written or -1 in case of error. If -1,
 *	Tcl_GetErrno will return the error code.
 *
 * Side effects:
 *	May buffer up output and may cause output to be produced on the
 *	channel.
 *
 *----------------------------------------------------------------------
 */

static int
WriteBytes(chanPtr, src, srcLen)
    Channel *chanPtr;		/* The channel to buffer output for. */
    CONST char *src;		/* Bytes to write. */
    int srcLen;			/* Number of bytes to write. */
{
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    ChannelBuffer *bufPtr;
    char *dst;
    int dstMax, sawLF, savedLF, total, dstLen, toWrite;
    
    total = 0;
    sawLF = 0;
    savedLF = 0;

    /*
     * Loop over all bytes in src, storing them in output buffer with
     * proper EOL translation.
     */

    while (srcLen + savedLF > 0) {
	bufPtr = statePtr->curOutPtr;
	if (bufPtr == NULL) {
	    bufPtr = AllocChannelBuffer(statePtr->bufSize);
	    statePtr->curOutPtr	= bufPtr;
	}
	dst = bufPtr->buf + bufPtr->nextAdded;
	dstMax = bufPtr->bufLength - bufPtr->nextAdded;
	dstLen = dstMax;

	toWrite = dstLen;
	if (toWrite > srcLen) {
	    toWrite = srcLen;
	}

	if (savedLF) {
	    /*
	     * A '\n' was left over from last call to TranslateOutputEOL()
	     * and we need to store it in this buffer.  If the channel is
	     * line-based, we will need to flush it.
	     */

	    *dst++ = '\n';
	    dstLen--;
	    sawLF++;
	}
	sawLF += TranslateOutputEOL(statePtr, dst, src, &dstLen, &toWrite);
	dstLen += savedLF;
	savedLF = 0;

	if (dstLen > dstMax) {
	    savedLF = 1;
	    dstLen = dstMax;
	}
	bufPtr->nextAdded += dstLen;
	if (CheckFlush(chanPtr, bufPtr, sawLF) != 0) {
	    return -1;
	}
	total += dstLen;
	src += toWrite;
	srcLen -= toWrite;
	sawLF = 0;
    }
    return total;
}

/*
 *----------------------------------------------------------------------
 *
 * WriteChars --
 *
 *	Convert UTF-8 bytes to the channel's external encoding and
 *	write the produced bytes into an output buffer, may queue the 
 *	buffer for output if it gets full, and also remembers whether the
 *	current buffer is ready e.g. if it contains a newline and we are in
 *	line buffering mode.
 *
 * Results:
 *	The number of bytes written or -1 in case of error. If -1,
 *	Tcl_GetErrno will return the error code.
 *
 * Side effects:
 *	May buffer up output and may cause output to be produced on the
 *	channel.
 *
 *----------------------------------------------------------------------
 */

static int
WriteChars(chanPtr, src, srcLen)
    Channel *chanPtr;		/* The channel to buffer output for. */
    CONST char *src;		/* UTF-8 string to write. */
    int srcLen;			/* Length of UTF-8 string in bytes. */
{
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    ChannelBuffer *bufPtr;
    char *dst, *stage;
    int saved, savedLF, sawLF, total, dstLen, stageMax, dstWrote;
    int stageLen, toWrite, stageRead, endEncoding, result;
    int consumedSomething;
    Tcl_Encoding encoding;
    char safe[BUFFER_PADDING];
    
    total = 0;
    sawLF = 0;
    savedLF = 0;
    saved = 0;
    encoding = statePtr->encoding;

    /*
     * Write the terminated escape sequence even if srcLen is 0.
     */

    endEncoding = ((statePtr->outputEncodingFlags & TCL_ENCODING_END) != 0);

    /*
     * Loop over all UTF-8 characters in src, storing them in staging buffer
     * with proper EOL translation.
     */

    consumedSomething = 1;
    while (consumedSomething && (srcLen + savedLF + endEncoding > 0)) {
        consumedSomething = 0;
	stage = statePtr->outputStage;
	stageMax = statePtr->bufSize;
	stageLen = stageMax;

	toWrite = stageLen;
	if (toWrite > srcLen) {
	    toWrite = srcLen;
	}

	if (savedLF) {
	    /*
	     * A '\n' was left over from last call to TranslateOutputEOL()
	     * and we need to store it in the staging buffer.  If the
	     * channel is line-based, we will need to flush the output
	     * buffer (after translating the staging buffer).
	     */
	    
	    *stage++ = '\n';
	    stageLen--;
	    sawLF++;
	}
	sawLF += TranslateOutputEOL(statePtr, stage, src, &stageLen, &toWrite);

	stage -= savedLF;
	stageLen += savedLF;
	savedLF = 0;

	if (stageLen > stageMax) {
	    savedLF = 1;
	    stageLen = stageMax;
	}
	src += toWrite;
	srcLen -= toWrite;

	/*
	 * Loop over all UTF-8 characters in staging buffer, converting them
	 * to external encoding, storing them in output buffer.
	 */

	while (stageLen + saved + endEncoding > 0) {
	    bufPtr = statePtr->curOutPtr;
	    if (bufPtr == NULL) {
		bufPtr = AllocChannelBuffer(statePtr->bufSize);
		statePtr->curOutPtr = bufPtr;
	    }
	    dst = bufPtr->buf + bufPtr->nextAdded;
	    dstLen = bufPtr->bufLength - bufPtr->nextAdded;

	    if (saved != 0) {
		/*
		 * Here's some translated bytes left over from the last
		 * buffer that we need to stick at the beginning of this
		 * buffer.
		 */
		 
		memcpy((VOID *) dst, (VOID *) safe, (size_t) saved);
		bufPtr->nextAdded += saved;
		dst += saved;
		dstLen -= saved;
		saved = 0;
	    }

	    result = Tcl_UtfToExternal(NULL, encoding, stage, stageLen,
		    statePtr->outputEncodingFlags,
		    &statePtr->outputEncodingState, dst,
		    dstLen + BUFFER_PADDING, &stageRead, &dstWrote, NULL);

	    /* Fix for SF #506297, reported by Martin Forssen
	     * <ruric@@users.sourceforge.net>.
	     *
	     * The encoding chosen in the script exposing the bug writes out
	     * three intro characters when TCL_ENCODING_START is set, but does
	     * not consume any input as TCL_ENCODING_END is cleared. As some
	     * output was generated the enclosing loop calls UtfToExternal
	     * again, again with START set. Three more characters in the out
	     * and still no use of input ... To break this infinite loop we
	     * remove TCL_ENCODING_START from the set of flags after the first
	     * call (no condition is required, the later calls remove an unset
	     * flag, which is a no-op). This causes the subsequent calls to
	     * UtfToExternal to consume and convert the actual input.
	     */

	    statePtr->outputEncodingFlags &= ~TCL_ENCODING_START;
	    /*
	     * The following code must be executed only when result is not 0.
	     */
	    if (result && ((stageRead + dstWrote) == 0)) {
		/*
		 * We have an incomplete UTF-8 character at the end of the
		 * staging buffer.  It will get moved to the beginning of the
		 * staging buffer followed by more bytes from src.
		 */

		src -= stageLen;
		srcLen += stageLen;
		stageLen = 0;
		savedLF = 0;
		break;
	    }
	    bufPtr->nextAdded += dstWrote;
	    if (bufPtr->nextAdded > bufPtr->bufLength) {
		/*
		 * When translating from UTF-8 to external encoding, we
		 * allowed the translation to produce a character that
		 * crossed the end of the output buffer, so that we would
		 * get a completely full buffer before flushing it.  The
		 * extra bytes will be moved to the beginning of the next
		 * buffer.
		 */

		saved = bufPtr->nextAdded - bufPtr->bufLength;
		memcpy((VOID *) safe, (VOID *) (dst + dstLen), (size_t) saved);
		bufPtr->nextAdded = bufPtr->bufLength;
	    }
	    if (CheckFlush(chanPtr, bufPtr, sawLF) != 0) {
		return -1;
	    }

	    total += dstWrote;
	    stage += stageRead;
	    stageLen -= stageRead;
	    sawLF = 0;

	    consumedSomething = 1;

	    /*
	     * If all translated characters are written to the buffer,
	     * endEncoding is set to 0 because the escape sequence may be
	     * output.
	     */

	    if ((stageLen + saved == 0) && (result == 0)) {
		endEncoding = 0;
	    }
	}
    }

    /* If nothing was written and it happened because there was no progress
     * in the UTF conversion, we throw an error.
     */

    if (!consumedSomething && (total == 0)) {
        Tcl_SetErrno (EINVAL);
        return -1;
    }
    return total;
}

/*
 *---------------------------------------------------------------------------
 *
 * TranslateOutputEOL --
 *
 *	Helper function for WriteBytes() and WriteChars().  Converts the
 *	'\n' characters in the source buffer into the appropriate EOL
 *	form specified by the output translation mode.
 *
 *	EOL translation stops either when the source buffer is empty
 *	or the output buffer is full.
 *
 *	When converting to CRLF mode and there is only 1 byte left in
 *	the output buffer, this routine stores the '\r' in the last
 *	byte and then stores the '\n' in the byte just past the end of the 
 *	buffer.  The caller is responsible for passing in a buffer that
 *	is large enough to hold the extra byte.
 *
 * Results:
 *	The return value is 1 if a '\n' was translated from the source
 *	buffer, or 0 otherwise -- this can be used by the caller to
 *	decide to flush a line-based channel even though the channel
 *	buffer is not full.
 *
 *	*dstLenPtr is filled with how many bytes of the output buffer
 *	were used.  As mentioned above, this can be one more that
 *	the output buffer's specified length if a CRLF was stored.
 *
 *	*srcLenPtr is filled with how many bytes of the source buffer
 *	were consumed.  
 *
 * Side effects:
 *	It may be obvious, but bears mentioning that when converting
 *	in CRLF mode (which requires two bytes of storage in the output
 *	buffer), the number of bytes consumed from the source buffer
 *	will be less than the number of bytes stored in the output buffer.
 *
 *---------------------------------------------------------------------------
 */

static int
TranslateOutputEOL(statePtr, dst, src, dstLenPtr, srcLenPtr)
    ChannelState *statePtr;	/* Channel being read, for translation and
				 * buffering modes. */
    char *dst;			/* Output buffer filled with UTF-8 chars by
				 * applying appropriate EOL translation to
				 * source characters. */
    CONST char *src;		/* Source UTF-8 characters. */
    int *dstLenPtr;		/* On entry, the maximum length of output
				 * buffer in bytes.  On exit, the number of
				 * bytes actually used in output buffer. */
    int *srcLenPtr;		/* On entry, the length of source buffer.
				 * On exit, the number of bytes read from
				 * the source buffer. */
{
    char *dstEnd;
    int srcLen, newlineFound;
    
    newlineFound = 0;
    srcLen = *srcLenPtr;

    switch (statePtr->outputTranslation) {
	case TCL_TRANSLATE_LF: {
	    for (dstEnd = dst + srcLen; dst < dstEnd; ) {
		if (*src == '\n') {
		    newlineFound = 1;
		}
		*dst++ = *src++;
	    }
	    *dstLenPtr = srcLen;
	    break;
	}
	case TCL_TRANSLATE_CR: {
	    for (dstEnd = dst + srcLen; dst < dstEnd;) {
		if (*src == '\n') {
		    *dst++ = '\r';
		    newlineFound = 1;
		    src++;
		} else {
		    *dst++ = *src++;
		}
	    }
	    *dstLenPtr = srcLen;
	    break;
	}
	case TCL_TRANSLATE_CRLF: {
	    /*
	     * Since this causes the number of bytes to grow, we
	     * start off trying to put 'srcLen' bytes into the
	     * output buffer, but allow it to store more bytes, as
	     * long as there's still source bytes and room in the
	     * output buffer.
	     */

	    char *dstStart, *dstMax;
	    CONST char *srcStart;
	    
	    dstStart = dst;
	    dstMax = dst + *dstLenPtr;

	    srcStart = src;
	    
	    if (srcLen < *dstLenPtr) {
		dstEnd = dst + srcLen;
	    } else {
		dstEnd = dst + *dstLenPtr;
	    }
	    while (dst < dstEnd) {
		if (*src == '\n') {
		    if (dstEnd < dstMax) {
			dstEnd++;
		    }
		    *dst++ = '\r';
		    newlineFound = 1;
		}
		*dst++ = *src++;
	    }
	    *srcLenPtr = src - srcStart;
	    *dstLenPtr = dst - dstStart;
	    break;
	}
	default: {
	    break;
	}
    }
    return newlineFound;
}

/*
 *---------------------------------------------------------------------------
 *
 * CheckFlush --
 *
 *	Helper function for WriteBytes() and WriteChars().  If the
 *	channel buffer is ready to be flushed, flush it.
 *
 * Results:
 *	The return value is -1 if there was a problem flushing the
 *	channel buffer, or 0 otherwise.
 *
 * Side effects:
 *	The buffer will be recycled if it is flushed.
 *
 *---------------------------------------------------------------------------
 */

static int
CheckFlush(chanPtr, bufPtr, newlineFlag)
    Channel *chanPtr;		/* Channel being read, for buffering mode. */
    ChannelBuffer *bufPtr;	/* Channel buffer to possibly flush. */
    int newlineFlag;		/* Non-zero if a the channel buffer
				 * contains a newline. */
{
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    /*
     * The current buffer is ready for output:
     * 1. if it is full.
     * 2. if it contains a newline and this channel is line-buffered.
     * 3. if it contains any output and this channel is unbuffered.
     */

    if ((statePtr->flags & BUFFER_READY) == 0) {
	if (bufPtr->nextAdded == bufPtr->bufLength) {
	    statePtr->flags |= BUFFER_READY;
	} else if (statePtr->flags & CHANNEL_LINEBUFFERED) {
	    if (newlineFlag != 0) {
		statePtr->flags |= BUFFER_READY;
	    }
	} else if (statePtr->flags & CHANNEL_UNBUFFERED) {
	    statePtr->flags |= BUFFER_READY;
	}
    }
    if (statePtr->flags & BUFFER_READY) {
	if (FlushChannel(NULL, chanPtr, 0) != 0) {
	    return -1;
	}
    }
    return 0;
}

/*
 *---------------------------------------------------------------------------
 *
 * Tcl_Gets --
 *
 *	Reads a complete line of input from the channel into a Tcl_DString.
 *
 * Results:
 *	Length of line read (in characters) or -1 if error, EOF, or blocked.
 *	If -1, use Tcl_GetErrno() to retrieve the POSIX error code for the
 *	error or condition that occurred.
 *
 * Side effects:
 *	May flush output on the channel.  May cause input to be consumed
 *	from the channel.
 *
 *---------------------------------------------------------------------------
 */

int
Tcl_Gets(chan, lineRead)
    Tcl_Channel chan;		/* Channel from which to read. */
    Tcl_DString *lineRead;	/* The line read will be appended to this
				 * DString as UTF-8 characters.  The caller
				 * must have initialized it and is responsible
				 * for managing the storage. */
{
    Tcl_Obj *objPtr;
    int charsStored, length;
    char *string;

    objPtr = Tcl_NewObj();
    charsStored = Tcl_GetsObj(chan, objPtr);
    if (charsStored > 0) {
	string = Tcl_GetStringFromObj(objPtr, &length);
	Tcl_DStringAppend(lineRead, string, length);
    }
    Tcl_DecrRefCount(objPtr);
    return charsStored;
}

/*
 *---------------------------------------------------------------------------
 *
 * Tcl_GetsObj --
 *
 *	Accumulate input from the input channel until end-of-line or
 *	end-of-file has been seen.  Bytes read from the input channel
 *	are converted to UTF-8 using the encoding specified by the
 *	channel.
 *
 * Results:
 *	Number of characters accumulated in the object or -1 if error,
 *	blocked, or EOF.  If -1, use Tcl_GetErrno() to retrieve the
 *	POSIX error code for the error or condition that occurred.
 *
 * Side effects:
 *	Consumes input from the channel.
 *
 *	On reading EOF, leave channel pointing at EOF char.
 *	On reading EOL, leave channel pointing after EOL, but don't
 *	return EOL in dst buffer.
 *
 *---------------------------------------------------------------------------
 */

int
Tcl_GetsObj(chan, objPtr)
    Tcl_Channel chan;		/* Channel from which to read. */
    Tcl_Obj *objPtr;		/* The line read will be appended to this
				 * object as UTF-8 characters. */
{
    GetsState gs;
    Channel *chanPtr = (Channel *) chan;
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    ChannelBuffer *bufPtr;
    int inEofChar, skip, copiedTotal, oldLength, oldFlags, oldRemoved;
    Tcl_Encoding encoding;
    char *dst, *dstEnd, *eol, *eof;
    Tcl_EncodingState oldState;

    /*
     * This operation should occur at the top of a channel stack.
     */

    chanPtr = statePtr->topChanPtr;

    if (CheckChannelErrors(statePtr, TCL_READABLE) != 0) {
	copiedTotal = -1;
	goto done;
    }

    bufPtr = statePtr->inQueueHead;
    encoding = statePtr->encoding;

    /*
     * Preserved so we can restore the channel's state in case we don't
     * find a newline in the available input.
     */

    Tcl_GetStringFromObj(objPtr, &oldLength);
    oldFlags = statePtr->inputEncodingFlags;
    oldState = statePtr->inputEncodingState;
    oldRemoved = BUFFER_PADDING;
    if (bufPtr != NULL) {
	oldRemoved = bufPtr->nextRemoved;
    }

    /*
     * If there is no encoding, use "iso8859-1" -- Tcl_GetsObj() doesn't
     * produce ByteArray objects.  To avoid circularity problems,
     * "iso8859-1" is builtin to Tcl.
     */

    if (encoding == NULL) {
	encoding = Tcl_GetEncoding(NULL, "iso8859-1");
    }

    /*
     * Object used by FilterInputBytes to keep track of how much data has
     * been consumed from the channel buffers.
     */

    gs.objPtr		= objPtr;
    gs.dstPtr		= &dst;
    gs.encoding		= encoding;
    gs.bufPtr		= bufPtr;
    gs.state		= oldState;
    gs.rawRead		= 0;
    gs.bytesWrote	= 0;
    gs.charsWrote	= 0;
    gs.totalChars	= 0;

    dst = objPtr->bytes + oldLength;
    dstEnd = dst;

    skip = 0;
    eof = NULL;
    inEofChar = statePtr->inEofChar;

    while (1) {
	if (dst >= dstEnd) {
	    if (FilterInputBytes(chanPtr, &gs) != 0) {
		goto restore;
	    }
	    dstEnd = dst + gs.bytesWrote;
	}
	
	/*
	 * Remember if EOF char is seen, then look for EOL anyhow, because
	 * the EOL might be before the EOF char.
	 */

	if (inEofChar != '\0') {
	    for (eol = dst; eol < dstEnd; eol++) {
		if (*eol == inEofChar) {
		    dstEnd = eol;
		    eof = eol;
		    break;
		}
	    }
	}

	/*
	 * On EOL, leave current file position pointing after the EOL, but
	 * don't store the EOL in the output string.
	 */

	eol = dst;
	switch (statePtr->inputTranslation) {
	    case TCL_TRANSLATE_LF: {
		for (eol = dst; eol < dstEnd; eol++) {
		    if (*eol == '\n') {
			skip = 1;
			goto goteol;
		    }
		}
		break;
	    }
	    case TCL_TRANSLATE_CR: {
		for (eol = dst; eol < dstEnd; eol++) {
		    if (*eol == '\r') {
			skip = 1;
			goto goteol;
		    }
		}
		break;
	    }
	    case TCL_TRANSLATE_CRLF: {
		for (eol = dst; eol < dstEnd; eol++) {
		    if (*eol == '\r') {
			eol++;
			if (eol >= dstEnd) {
			    int offset;
			    
			    offset = eol - objPtr->bytes;
			    dst = dstEnd;
			    if (FilterInputBytes(chanPtr, &gs) != 0) {
				goto restore;
			    }
			    dstEnd = dst + gs.bytesWrote;
			    eol = objPtr->bytes + offset;
			    if (eol >= dstEnd) {
				skip = 0;
				goto goteol;
			    }
			}
			if (*eol == '\n') {
			    eol--;
			    skip = 2;
			    goto goteol;
			}
		    }
		}
		break;
	    }
	    case TCL_TRANSLATE_AUTO: {
		skip = 1;
		if (statePtr->flags & INPUT_SAW_CR) {
		    statePtr->flags &= ~INPUT_SAW_CR;
		    if (*eol == '\n') {
			/*
			 * Skip the raw bytes that make up the '\n'.
			 */

			char tmp[1 + TCL_UTF_MAX];
			int rawRead;

			bufPtr = gs.bufPtr;
			Tcl_ExternalToUtf(NULL, gs.encoding,
				bufPtr->buf + bufPtr->nextRemoved,
				gs.rawRead, statePtr->inputEncodingFlags,
				&gs.state, tmp, 1 + TCL_UTF_MAX, &rawRead,
				NULL, NULL);
			bufPtr->nextRemoved += rawRead;
			gs.rawRead -= rawRead;
			gs.bytesWrote--;
			gs.charsWrote--;
			memmove(dst, dst + 1, (size_t) (dstEnd - dst));
			dstEnd--;
		    }
		}
		for (eol = dst; eol < dstEnd; eol++) {
		    if (*eol == '\r') {
			eol++;
			if (eol == dstEnd) {
			    /*
			     * If buffer ended on \r, peek ahead to see if a
			     * \n is available.
			     */

			    int offset;
			    
			    offset = eol - objPtr->bytes;
			    dst = dstEnd;
			    PeekAhead(chanPtr, &dstEnd, &gs);
			    eol = objPtr->bytes + offset;
			    if (eol >= dstEnd) {
				eol--;
				statePtr->flags |= INPUT_SAW_CR;
				goto goteol;
			    }
			}
			if (*eol == '\n') {
			    skip++;
			}
			eol--;
			goto goteol;
		    } else if (*eol == '\n') {
			goto goteol;
		    }
		}
	    }
	}
	if (eof != NULL) {
	    /*
	     * EOF character was seen.  On EOF, leave current file position
	     * pointing at the EOF character, but don't store the EOF
	     * character in the output string.
	     */

	    dstEnd = eof;
	    statePtr->flags |= (CHANNEL_EOF | CHANNEL_STICKY_EOF);
	    statePtr->inputEncodingFlags |= TCL_ENCODING_END;
	}
	if (statePtr->flags & CHANNEL_EOF) {
	    skip = 0;
	    eol = dstEnd;
	    if (eol == objPtr->bytes + oldLength) {
		/*
		 * If we didn't append any bytes before encountering EOF,
		 * caller needs to see -1.
		 */

		Tcl_SetObjLength(objPtr, oldLength);
		CommonGetsCleanup(chanPtr, encoding);
		copiedTotal = -1;
		goto done;
	    }
	    goto goteol;
	}
	dst = dstEnd;
    }

    /*
     * Found EOL or EOF, but the output buffer may now contain too many
     * UTF-8 characters.  We need to know how many raw bytes correspond to
     * the number of UTF-8 characters we want, plus how many raw bytes
     * correspond to the character(s) making up EOL (if any), so we can
     * remove the correct number of bytes from the channel buffer.
     */
     
    goteol:
    bufPtr = gs.bufPtr;
    statePtr->inputEncodingState = gs.state;
    Tcl_ExternalToUtf(NULL, gs.encoding, bufPtr->buf + bufPtr->nextRemoved,
	    gs.rawRead, statePtr->inputEncodingFlags,
	    &statePtr->inputEncodingState, dst,
	    eol - dst + skip + TCL_UTF_MAX, &gs.rawRead, NULL,
	    &gs.charsWrote);
    bufPtr->nextRemoved += gs.rawRead;

    /*
     * Recycle all the emptied buffers.
     */

    Tcl_SetObjLength(objPtr, eol - objPtr->bytes);
    CommonGetsCleanup(chanPtr, encoding);
    statePtr->flags &= ~CHANNEL_BLOCKED;
    copiedTotal = gs.totalChars + gs.charsWrote - skip;
    goto done;

    /*
     * Couldn't get a complete line.  This only happens if we get a error
     * reading from the channel or we are non-blocking and there wasn't
     * an EOL or EOF in the data available.
     */

    restore:
    bufPtr = statePtr->inQueueHead;
    bufPtr->nextRemoved = oldRemoved;

    for (bufPtr = bufPtr->nextPtr; bufPtr != NULL; bufPtr = bufPtr->nextPtr) {
	bufPtr->nextRemoved = BUFFER_PADDING;
    }
    CommonGetsCleanup(chanPtr, encoding);

    statePtr->inputEncodingState = oldState;
    statePtr->inputEncodingFlags = oldFlags;
    Tcl_SetObjLength(objPtr, oldLength);

    /*
     * We didn't get a complete line so we need to indicate to UpdateInterest
     * that the gets blocked.  It will wait for more data instead of firing
     * a timer, avoiding a busy wait.  This is where we are assuming that the
     * next operation is a gets.  No more file events will be delivered on 
     * this channel until new data arrives or some operation is performed
     * on the channel (e.g. gets, read, fconfigure) that changes the blocking
     * state.  Note that this means a file event will not be delivered even
     * though a read would be able to consume the buffered data.
     */

    statePtr->flags |= CHANNEL_NEED_MORE_DATA;
    copiedTotal = -1;

    done:
    /*
     * Update the notifier state so we don't block while there is still
     * data in the buffers.
     */

    UpdateInterest(chanPtr);
    return copiedTotal;
}

/*
 *---------------------------------------------------------------------------
 *
 * FilterInputBytes --
 *
 *	Helper function for Tcl_GetsObj.  Produces UTF-8 characters from
 *	raw bytes read from the channel.  
 *
 *	Consumes available bytes from channel buffers.  When channel
 *	buffers are exhausted, reads more bytes from channel device into
 *	a new channel buffer.  It is the caller's responsibility to
 *	free the channel buffers that have been exhausted.
 *
 * Results:
 *	The return value is -1 if there was an error reading from the
 *	channel, 0 otherwise.
 *
 * Side effects:
 *	Status object keeps track of how much data from channel buffers
 *	has been consumed and where UTF-8 bytes should be stored.
 *
 *---------------------------------------------------------------------------
 */
 
static int
FilterInputBytes(chanPtr, gsPtr)
    Channel *chanPtr;		/* Channel to read. */
    GetsState *gsPtr;		/* Current state of gets operation. */
{
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    ChannelBuffer *bufPtr;
    char *raw, *rawStart, *rawEnd;
    char *dst;
    int offset, toRead, dstNeeded, spaceLeft, result, rawLen, length;
    Tcl_Obj *objPtr;
#define ENCODING_LINESIZE   20	/* Lower bound on how many bytes to convert
				 * at a time.  Since we don't know a priori
				 * how many bytes of storage this many source
				 * bytes will use, we actually need at least
				 * ENCODING_LINESIZE * TCL_MAX_UTF bytes of
				 * room. */

    objPtr = gsPtr->objPtr;

    /*
     * Subtract the number of bytes that were removed from channel buffer
     * during last call.
     */

    bufPtr = gsPtr->bufPtr;
    if (bufPtr != NULL) {
	bufPtr->nextRemoved += gsPtr->rawRead;
	if (bufPtr->nextRemoved >= bufPtr->nextAdded) {
	    bufPtr = bufPtr->nextPtr;
	}
    }
    gsPtr->totalChars += gsPtr->charsWrote;

    if ((bufPtr == NULL) || (bufPtr->nextAdded == BUFFER_PADDING)) {
	/*
	 * All channel buffers were exhausted and the caller still hasn't
	 * seen EOL.  Need to read more bytes from the channel device.
	 * Side effect is to allocate another channel buffer.
	 */

	read:
        if (statePtr->flags & CHANNEL_BLOCKED) {
            if (statePtr->flags & CHANNEL_NONBLOCKING) {
		gsPtr->charsWrote = 0;
		gsPtr->rawRead = 0;
		return -1;
	    }
            statePtr->flags &= ~CHANNEL_BLOCKED;
        }
	if (GetInput(chanPtr) != 0) {
	    gsPtr->charsWrote = 0;
	    gsPtr->rawRead = 0;
	    return -1;
	}
	bufPtr = statePtr->inQueueTail;
	gsPtr->bufPtr = bufPtr;
    }

    /*
     * Convert some of the bytes from the channel buffer to UTF-8.  Space in
     * objPtr's string rep is used to hold the UTF-8 characters.  Grow the
     * string rep if we need more space.
     */

    rawStart = bufPtr->buf + bufPtr->nextRemoved;
    raw = rawStart;
    rawEnd = bufPtr->buf + bufPtr->nextAdded;
    rawLen = rawEnd - rawStart;

    dst = *gsPtr->dstPtr;
    offset = dst - objPtr->bytes;
    toRead = ENCODING_LINESIZE;
    if (toRead > rawLen) {
	toRead = rawLen;
    }
    dstNeeded = toRead * TCL_UTF_MAX + 1;
    spaceLeft = objPtr->length - offset - TCL_UTF_MAX - 1;
    if (dstNeeded > spaceLeft) {
	length = offset * 2;
	if (offset < dstNeeded) {
	    length = offset + dstNeeded;
	}
	length += TCL_UTF_MAX + 1;
	Tcl_SetObjLength(objPtr, length);
	spaceLeft = length - offset;
	dst = objPtr->bytes + offset;
	*gsPtr->dstPtr = dst;
    }
    gsPtr->state = statePtr->inputEncodingState;
    result = Tcl_ExternalToUtf(NULL, gsPtr->encoding, raw, rawLen,
	    statePtr->inputEncodingFlags, &statePtr->inputEncodingState,
	    dst, spaceLeft, &gsPtr->rawRead, &gsPtr->bytesWrote,
	    &gsPtr->charsWrote);

    /*
     * Make sure that if we go through 'gets', that we reset the
     * TCL_ENCODING_START flag still.  [Bug #523988]
     */
    statePtr->inputEncodingFlags &= ~TCL_ENCODING_START;

    if (result == TCL_CONVERT_MULTIBYTE) {
	/*
	 * The last few bytes in this channel buffer were the start of a
	 * multibyte sequence.  If this buffer was full, then move them to
	 * the next buffer so the bytes will be contiguous.  
	 */

	ChannelBuffer *nextPtr;
	int extra;
	
	nextPtr = bufPtr->nextPtr;
	if (bufPtr->nextAdded < bufPtr->bufLength) {
	    if (gsPtr->rawRead > 0) {
		/*
		 * Some raw bytes were converted to UTF-8.  Fall through,
		 * returning those UTF-8 characters because a EOL might be
		 * present in them.
		 */
	    } else if (statePtr->flags & CHANNEL_EOF) {
		/*
		 * There was a partial character followed by EOF on the
		 * device.  Fall through, returning that nothing was found.
		 */

		bufPtr->nextRemoved = bufPtr->nextAdded;
	    } else {
		/*
		 * There are no more cached raw bytes left.  See if we can
		 * get some more.
		 */

		goto read;
	    }
	} else {
	    if (nextPtr == NULL) {
		nextPtr = AllocChannelBuffer(statePtr->bufSize);
		bufPtr->nextPtr = nextPtr;
		statePtr->inQueueTail = nextPtr;
	    }
	    extra = rawLen - gsPtr->rawRead;
	    memcpy((VOID *) (nextPtr->buf + BUFFER_PADDING - extra),
		    (VOID *) (raw + gsPtr->rawRead), (size_t) extra);
	    nextPtr->nextRemoved -= extra;
	    bufPtr->nextAdded -= extra;
	}
    }

    gsPtr->bufPtr = bufPtr;
    return 0;
}

/*
 *---------------------------------------------------------------------------
 *
 * PeekAhead --
 *
 *	Helper function used by Tcl_GetsObj().  Called when we've seen a
 *	\r at the end of the UTF-8 string and want to look ahead one
 *	character to see if it is a \n.
 *
 * Results:
 *	*gsPtr->dstPtr is filled with a pointer to the start of the range of
 *	UTF-8 characters that were found by peeking and *dstEndPtr is filled
 *	with a pointer to the bytes just after the end of the range.
 *
 * Side effects:
 *	If no more raw bytes were available in one of the channel buffers,
 *	tries to perform a non-blocking read to get more bytes from the
 *	channel device.
 *
 *---------------------------------------------------------------------------
 */

static void
PeekAhead(chanPtr, dstEndPtr, gsPtr)
    Channel *chanPtr;		/* The channel to read. */
    char **dstEndPtr;		/* Filled with pointer to end of new range
				 * of UTF-8 characters. */
    GetsState *gsPtr;		/* Current state of gets operation. */
{
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    ChannelBuffer *bufPtr;
    Tcl_DriverBlockModeProc *blockModeProc;
    int bytesLeft;

    bufPtr = gsPtr->bufPtr;

    /*
     * If there's any more raw input that's still buffered, we'll peek into
     * that.  Otherwise, only get more data from the channel driver if it
     * looks like there might actually be more data.  The assumption is that
     * if the channel buffer is filled right up to the end, then there
     * might be more data to read.
     */

    blockModeProc = NULL;
    if (bufPtr->nextPtr == NULL) {
	bytesLeft = bufPtr->nextAdded - (bufPtr->nextRemoved + gsPtr->rawRead);
	if (bytesLeft == 0) {
	    if (bufPtr->nextAdded < bufPtr->bufLength) {
		/*
		 * Don't peek ahead if last read was short read.
		 */
		 
		goto cleanup;
	    }
	    if ((statePtr->flags & CHANNEL_NONBLOCKING) == 0) {
		blockModeProc = Tcl_ChannelBlockModeProc(chanPtr->typePtr);
		if (blockModeProc == NULL) {
		    /*
		     * Don't peek ahead if cannot set non-blocking mode.
		     */

		    goto cleanup;
		}
		StackSetBlockMode(chanPtr, TCL_MODE_NONBLOCKING);
	    }
	}
    }
    if (FilterInputBytes(chanPtr, gsPtr) == 0) {
	*dstEndPtr = *gsPtr->dstPtr + gsPtr->bytesWrote;
    }
    if (blockModeProc != NULL) {
	StackSetBlockMode(chanPtr, TCL_MODE_BLOCKING);
    }
    return;

    cleanup:
    bufPtr->nextRemoved += gsPtr->rawRead;
    gsPtr->rawRead = 0;
    gsPtr->totalChars += gsPtr->charsWrote;
    gsPtr->bytesWrote = 0;
    gsPtr->charsWrote = 0;
}

/*
 *---------------------------------------------------------------------------
 *
 * CommonGetsCleanup --
 *
 *	Helper function for Tcl_GetsObj() to restore the channel after
 *	a "gets" operation.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Encoding may be freed.
 *
 *---------------------------------------------------------------------------
 */
 
static void
CommonGetsCleanup(chanPtr, encoding)
    Channel *chanPtr;
    Tcl_Encoding encoding;
{
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    ChannelBuffer *bufPtr, *nextPtr;
    
    bufPtr = statePtr->inQueueHead;
    for ( ; bufPtr != NULL; bufPtr = nextPtr) {
	nextPtr = bufPtr->nextPtr;
	if (bufPtr->nextRemoved < bufPtr->nextAdded) {
	    break;
	}
	RecycleBuffer(statePtr, bufPtr, 0);
    }
    statePtr->inQueueHead = bufPtr;
    if (bufPtr == NULL) {
	statePtr->inQueueTail = NULL;
    } else {
	/*
	 * If any multi-byte characters were split across channel buffer
	 * boundaries, the split-up bytes were moved to the next channel
	 * buffer by FilterInputBytes().  Move the bytes back to their
	 * original buffer because the caller could change the channel's
	 * encoding which could change the interpretation of whether those
	 * bytes really made up multi-byte characters after all.
	 */
	 
	nextPtr = bufPtr->nextPtr;
	for ( ; nextPtr != NULL; nextPtr = bufPtr->nextPtr) {
	    int extra;

	    extra = bufPtr->bufLength - bufPtr->nextAdded;
	    if (extra > 0) {
		memcpy((VOID *) (bufPtr->buf + bufPtr->nextAdded),
			(VOID *) (nextPtr->buf + BUFFER_PADDING - extra),
			(size_t) extra);
		bufPtr->nextAdded += extra;
		nextPtr->nextRemoved = BUFFER_PADDING;
	    }
	    bufPtr = nextPtr;
	}
    }
    if (statePtr->encoding == NULL) {
	Tcl_FreeEncoding(encoding);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_Read --
 *
 *	Reads a given number of bytes from a channel.  EOL and EOF
 *	translation is done on the bytes being read, so the the number
 *	of bytes consumed from the channel may not be equal to the
 *	number of bytes stored in the destination buffer.
 *
 *	No encoding conversions are applied to the bytes being read.
 *
 * Results:
 *	The number of bytes read, or -1 on error. Use Tcl_GetErrno()
 *	to retrieve the error code for the error that occurred.
 *
 * Side effects:
 *	May cause input to be buffered.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_Read(chan, dst, bytesToRead)
    Tcl_Channel chan;		/* The channel from which to read. */
    char *dst;			/* Where to store input read. */
    int bytesToRead;		/* Maximum number of bytes to read. */
{
    Channel *chanPtr = (Channel *) chan;		
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */

    /*
     * This operation should occur at the top of a channel stack.
     */

    chanPtr = statePtr->topChanPtr;

    if (CheckChannelErrors(statePtr, TCL_READABLE) != 0) {
	return -1;
    }

    return DoRead(chanPtr, dst, bytesToRead);
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_ReadRaw --
 *
 *	Reads a given number of bytes from a channel.  EOL and EOF
 *	translation is done on the bytes being read, so the the number
 *	of bytes consumed from the channel may not be equal to the
 *	number of bytes stored in the destination buffer.
 *
 *	No encoding conversions are applied to the bytes being read.
 *
 * Results:
 *	The number of bytes read, or -1 on error. Use Tcl_GetErrno()
 *	to retrieve the error code for the error that occurred.
 *
 * Side effects:
 *	May cause input to be buffered.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_ReadRaw(chan, bufPtr, bytesToRead)
    Tcl_Channel chan;		/* The channel from which to read. */
    char *bufPtr;		/* Where to store input read. */
    int bytesToRead;		/* Maximum number of bytes to read. */
{
    Channel *chanPtr = (Channel *) chan;		
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    int nread, result;
    int copied, copiedNow;

    /*
     * The check below does too much because it will reject a call to this
     * function with a channel which is part of an 'fcopy'. But we have to
     * allow this here or else the chaining in the transformation drivers
     * will fail with 'file busy' error instead of retrieving and
     * transforming the data to copy.
     *
     * We let the check procedure now believe that there is no fcopy in
     * progress. A better solution than this might be an additional flag
     * argument to switch off specific checks.
     */

    if (CheckChannelErrors(statePtr, TCL_READABLE | CHANNEL_RAW_MODE) != 0) {
	return -1;
    }

    /*
     * Check for information in the push-back buffers. If there is
     * some, use it. Go to the driver only if there is none (anymore)
     * and the caller requests more bytes.
     */

    for (copied = 0; copied < bytesToRead; copied += copiedNow) {
        copiedNow = CopyBuffer(chanPtr, bufPtr + copied,
                bytesToRead - copied);
        if (copiedNow == 0) {
            if (statePtr->flags & CHANNEL_EOF) {
		goto done;
            }
            if (statePtr->flags & CHANNEL_BLOCKED) {
                if (statePtr->flags & CHANNEL_NONBLOCKING) {
		    goto done;
                }
                statePtr->flags &= (~(CHANNEL_BLOCKED));
            }

	    if ((statePtr->flags & CHANNEL_TIMER_FEV) &&
		(statePtr->flags & CHANNEL_NONBLOCKING)) {
	        nread  = -1;
	        result = EWOULDBLOCK;
	    } else {
	      /*
	       * Now go to the driver to get as much as is possible to
	       * fill the remaining request. Do all the error handling
	       * by ourselves.  The code was stolen from 'GetInput' and
	       * slightly adapted (different return value here).
	       *
	       * The case of 'bytesToRead == 0' at this point cannot happen.
	       */

	      nread = (chanPtr->typePtr->inputProc)(chanPtr->instanceData,
			  bufPtr + copied, bytesToRead - copied, &result);
	    }
	    if (nread > 0) {
	        /*
		 * If we get a short read, signal up that we may be
		 * BLOCKED. We should avoid calling the driver because
		 * on some platforms we will block in the low level
		 * reading code even though the channel is set into
		 * nonblocking mode.
		 */
            
	        if (nread < (bytesToRead - copied)) {
		    statePtr->flags |= CHANNEL_BLOCKED;
		}
	    } else if (nread == 0) {
	        statePtr->flags |= CHANNEL_EOF;
		statePtr->inputEncodingFlags |= TCL_ENCODING_END;
	    } else if (nread < 0) {
	        if ((result == EWOULDBLOCK) || (result == EAGAIN)) {
		    if (copied > 0) {
		      /*
		       * Information that was copied earlier has precedence
		       * over EAGAIN/WOULDBLOCK handling.
		       */
		      return copied;
		    }

		    statePtr->flags |= CHANNEL_BLOCKED;
		    result = EAGAIN;
		}

		Tcl_SetErrno(result);
		return -1;
	    } 

	    return copied + nread;
        }
    }

done:
    return copied;
}

/*
 *---------------------------------------------------------------------------
 *
 * Tcl_ReadChars --
 *
 *	Reads from the channel until the requested number of characters
 *	have been seen, EOF is seen, or the channel would block.  EOL
 *	and EOF translation is done.  If reading binary data, the raw
 *	bytes are wrapped in a Tcl byte array object.  Otherwise, the raw
 *	bytes are converted to UTF-8 using the channel's current encoding
 *	and stored in a Tcl string object.
 *
 * Results:
 *	The number of characters read, or -1 on error. Use Tcl_GetErrno()
 *	to retrieve the error code for the error that occurred.
 *
 * Side effects:
 *	May cause input to be buffered.
 *
 *---------------------------------------------------------------------------
 */
 
int
Tcl_ReadChars(chan, objPtr, toRead, appendFlag)
    Tcl_Channel chan;		/* The channel to read. */
    Tcl_Obj *objPtr;		/* Input data is stored in this object. */
    int toRead;			/* Maximum number of characters to store,
				 * or -1 to read all available data (up to EOF
				 * or when channel blocks). */
    int appendFlag;		/* If non-zero, data read from the channel
				 * will be appended to the object.  Otherwise,
				 * the data will replace the existing contents
				 * of the object. */

{
    Channel*      chanPtr  = (Channel *) chan;
    ChannelState* statePtr = chanPtr->state;	/* state info for channel */
    
    /*
     * This operation should occur at the top of a channel stack.
     */

    chanPtr = statePtr->topChanPtr;

    if (CheckChannelErrors(statePtr, TCL_READABLE) != 0) {
        /*
	 * Update the notifier state so we don't block while there is still
	 * data in the buffers.
	 */
        UpdateInterest(chanPtr);
	return -1;
    }

    return DoReadChars (chanPtr, objPtr, toRead, appendFlag);
}
/*
 *---------------------------------------------------------------------------
 *
 * DoReadChars --
 *
 *	Reads from the channel until the requested number of characters
 *	have been seen, EOF is seen, or the channel would block.  EOL
 *	and EOF translation is done.  If reading binary data, the raw
 *	bytes are wrapped in a Tcl byte array object.  Otherwise, the raw
 *	bytes are converted to UTF-8 using the channel's current encoding
 *	and stored in a Tcl string object.
 *
 * Results:
 *	The number of characters read, or -1 on error. Use Tcl_GetErrno()
 *	to retrieve the error code for the error that occurred.
 *
 * Side effects:
 *	May cause input to be buffered.
 *
 *---------------------------------------------------------------------------
 */
 
static int
DoReadChars(chanPtr, objPtr, toRead, appendFlag)
    Channel* chanPtr;		/* The channel to read. */
    Tcl_Obj *objPtr;		/* Input data is stored in this object. */
    int toRead;			/* Maximum number of characters to store,
				 * or -1 to read all available data (up to EOF
				 * or when channel blocks). */
    int appendFlag;		/* If non-zero, data read from the channel
				 * will be appended to the object.  Otherwise,
				 * the data will replace the existing contents
				 * of the object. */

{
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    ChannelBuffer *bufPtr;
    int offset, factor, copied, copiedNow, result;
    Tcl_Encoding encoding;
#define UTF_EXPANSION_FACTOR	1024
    
    /*
     * This operation should occur at the top of a channel stack.
     */

    chanPtr  = statePtr->topChanPtr;
    encoding = statePtr->encoding;
    factor   = UTF_EXPANSION_FACTOR;

    if (appendFlag == 0) {
	if (encoding == NULL) {
	    Tcl_SetByteArrayLength(objPtr, 0);
	} else {
	    Tcl_SetObjLength(objPtr, 0);
	}
	offset = 0;
    } else {
	if (encoding == NULL) {
	    Tcl_GetByteArrayFromObj(objPtr, &offset);
	} else {
	    Tcl_GetStringFromObj(objPtr, &offset);
	}
    }

    for (copied = 0; (unsigned) toRead > 0; ) {
	copiedNow = -1;
	if (statePtr->inQueueHead != NULL) {
	    if (encoding == NULL) {
		copiedNow = ReadBytes(statePtr, objPtr, toRead, &offset);
	    } else {
		copiedNow = ReadChars(statePtr, objPtr, toRead, &offset,
			&factor);
	    }

	    /*
	     * If the current buffer is empty recycle it.
	     */

	    bufPtr = statePtr->inQueueHead;
	    if (bufPtr->nextRemoved == bufPtr->nextAdded) {
		ChannelBuffer *nextPtr;

		nextPtr = bufPtr->nextPtr;
		RecycleBuffer(statePtr, bufPtr, 0);
		statePtr->inQueueHead = nextPtr;
		if (nextPtr == NULL) {
		    statePtr->inQueueTail = NULL;
		}
	    }
	}
	if (copiedNow < 0) {
	    if (statePtr->flags & CHANNEL_EOF) {
		break;
	    }
	    if (statePtr->flags & CHANNEL_BLOCKED) {
		if (statePtr->flags & CHANNEL_NONBLOCKING) {
		    break;
		}
		statePtr->flags &= ~CHANNEL_BLOCKED;
	    }
	    result = GetInput(chanPtr);
	    if (result != 0) {
		if (result == EAGAIN) {
		    break;
		}
		copied = -1;
		goto done;
	    }
	} else {
	    copied += copiedNow;
	    toRead -= copiedNow;
	}
    }
    statePtr->flags &= ~CHANNEL_BLOCKED;
    if (encoding == NULL) {
	Tcl_SetByteArrayLength(objPtr, offset);
    } else {
	Tcl_SetObjLength(objPtr, offset);
    }

    done:
    /*
     * Update the notifier state so we don't block while there is still
     * data in the buffers.
     */

    UpdateInterest(chanPtr);
    return copied;
}
/*
 *---------------------------------------------------------------------------
 *
 * ReadBytes --
 *
 *	Reads from the channel until the requested number of bytes have
 *	been seen, EOF is seen, or the channel would block.  Bytes from
 *	the channel are stored in objPtr as a ByteArray object.  EOL
 *	and EOF translation are done.
 *
 *	'bytesToRead' can safely be a very large number because
 *	space is only allocated to hold data read from the channel
 *	as needed.
 *
 * Results:
 *	The return value is the number of bytes appended to the object
 *	and *offsetPtr is filled with the total number of bytes in the
 *	object (greater than the return value if there were already bytes
 *	in the object).
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
 */

static int
ReadBytes(statePtr, objPtr, bytesToRead, offsetPtr)
    ChannelState *statePtr;	/* State of the channel to read. */
    Tcl_Obj *objPtr;		/* Input data is appended to this ByteArray
				 * object.  Its length is how much space
				 * has been allocated to hold data, not how
				 * many bytes of data have been stored in the
				 * object. */
    int bytesToRead;		/* Maximum number of bytes to store,
				 * or < 0 to get all available bytes.
				 * Bytes are obtained from the first
				 * buffer in the queue -- even if this number
				 * is larger than the number of bytes
				 * available in the first buffer, only the
				 * bytes from the first buffer are
				 * returned. */
    int *offsetPtr;		/* On input, contains how many bytes of
				 * objPtr have been used to hold data.  On
				 * output, filled with how many bytes are now
				 * being used. */
{
    int toRead, srcLen, offset, length, srcRead, dstWrote;
    ChannelBuffer *bufPtr;
    char *src, *dst;

    offset = *offsetPtr;

    bufPtr = statePtr->inQueueHead; 
    src = bufPtr->buf + bufPtr->nextRemoved;
    srcLen = bufPtr->nextAdded - bufPtr->nextRemoved;

    toRead = bytesToRead;
    if ((unsigned) toRead > (unsigned) srcLen) {
	toRead = srcLen;
    }

    dst = (char *) Tcl_GetByteArrayFromObj(objPtr, &length);
    if (toRead > length - offset - 1) {
	/*
	 * Double the existing size of the object or make enough room to
	 * hold all the characters we may get from the source buffer,
	 * whichever is larger.
	 */

	length = offset * 2;
	if (offset < toRead) {
	    length = offset + toRead + 1;
	}
	dst = (char *) Tcl_SetByteArrayLength(objPtr, length);
    }
    dst += offset;

    if (statePtr->flags & INPUT_NEED_NL) {
	statePtr->flags &= ~INPUT_NEED_NL;
	if ((srcLen == 0) || (*src != '\n')) {
	    *dst = '\r';
	    *offsetPtr += 1;
	    return 1;
	}
	*dst++ = '\n';
	src++;
	srcLen--;
	toRead--;
    }

    srcRead = srcLen;
    dstWrote = toRead;
    if (TranslateInputEOL(statePtr, dst, src, &dstWrote, &srcRead) != 0) {
	if (dstWrote == 0) {
	    return -1;
	}
    }
    bufPtr->nextRemoved += srcRead;
    *offsetPtr += dstWrote;
    return dstWrote;
}

/*
 *---------------------------------------------------------------------------
 *
 * ReadChars --
 *
 *	Reads from the channel until the requested number of UTF-8
 *	characters have been seen, EOF is seen, or the channel would
 *	block.  Raw bytes from the channel are converted to UTF-8
 *	and stored in objPtr.  EOL and EOF translation is done.
 *
 *	'charsToRead' can safely be a very large number because
 *	space is only allocated to hold data read from the channel
 *	as needed.
 *
 * Results:
 *	The return value is the number of characters appended to
 *	the object, *offsetPtr is filled with the number of bytes that
 *	were appended, and *factorPtr is filled with the expansion
 *	factor used to guess how many bytes of UTF-8 to allocate to
 *	hold N source bytes.
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
 */

static int
ReadChars(statePtr, objPtr, charsToRead, offsetPtr, factorPtr)
    ChannelState *statePtr;	/* State of channel to read. */
    Tcl_Obj *objPtr;		/* Input data is appended to this object.
				 * objPtr->length is how much space has been
				 * allocated to hold data, not how many bytes
				 * of data have been stored in the object. */
    int charsToRead;		/* Maximum number of characters to store,
				 * or -1 to get all available characters.
				 * Characters are obtained from the first
				 * buffer in the queue -- even if this number
				 * is larger than the number of characters
				 * available in the first buffer, only the
				 * characters from the first buffer are
				 * returned. */
    int *offsetPtr;		/* On input, contains how many bytes of
				 * objPtr have been used to hold data.  On
				 * output, filled with how many bytes are now
				 * being used. */
    int *factorPtr;		/* On input, contains a guess of how many
				 * bytes need to be allocated to hold the
				 * result of converting N source bytes to
				 * UTF-8.  On output, contains another guess
				 * based on the data seen so far. */
{
    int toRead, factor, offset, spaceLeft, length, srcLen, dstNeeded;
    int srcRead, dstWrote, numChars, dstRead;
    ChannelBuffer *bufPtr;
    char *src, *dst;
    Tcl_EncodingState oldState;

    factor = *factorPtr;
    offset = *offsetPtr;

    bufPtr = statePtr->inQueueHead; 
    src = bufPtr->buf + bufPtr->nextRemoved;
    srcLen = bufPtr->nextAdded - bufPtr->nextRemoved;

    toRead = charsToRead;
    if ((unsigned)toRead > (unsigned)srcLen) {
	toRead = srcLen;
    }

    /*
     * 'factor' is how much we guess that the bytes in the source buffer
     * will expand when converted to UTF-8 chars.  This guess comes from
     * analyzing how many characters were produced by the previous
     * pass.
     */

    dstNeeded = toRead * factor / UTF_EXPANSION_FACTOR;
    spaceLeft = objPtr->length - offset - TCL_UTF_MAX - 1;

    if (dstNeeded > spaceLeft) {
	/*
	 * Double the existing size of the object or make enough room to
	 * hold all the characters we want from the source buffer,
	 * whichever is larger.
	 */

	length = offset * 2;
	if (offset < dstNeeded) {
	    length = offset + dstNeeded;
	}
	spaceLeft = length - offset;
	length += TCL_UTF_MAX + 1;
	Tcl_SetObjLength(objPtr, length);
    }
    if (toRead == srcLen) {
	/*
	 * Want to convert the whole buffer in one pass.  If we have
	 * enough space, convert it using all available space in object
	 * rather than using the factor.
	 */

	dstNeeded = spaceLeft;
    }
    dst = objPtr->bytes + offset;

    oldState = statePtr->inputEncodingState;
    if (statePtr->flags & INPUT_NEED_NL) {
	/*
	 * We want a '\n' because the last character we saw was '\r'.
	 */

	statePtr->flags &= ~INPUT_NEED_NL;
	Tcl_ExternalToUtf(NULL, statePtr->encoding, src, srcLen,
		statePtr->inputEncodingFlags, &statePtr->inputEncodingState,
		dst, TCL_UTF_MAX + 1, &srcRead, &dstWrote, &numChars);
	if ((dstWrote > 0) && (*dst == '\n')) {
	    /*
	     * The next char was a '\n'.  Consume it and produce a '\n'.
	     */

	    bufPtr->nextRemoved += srcRead;
	} else {
	    /*
	     * The next char was not a '\n'.  Produce a '\r'.
	     */

	    *dst = '\r';
	}
	statePtr->inputEncodingFlags &= ~TCL_ENCODING_START;
	*offsetPtr += 1;
        return 1;
    }

    Tcl_ExternalToUtf(NULL, statePtr->encoding, src, srcLen,
	    statePtr->inputEncodingFlags, &statePtr->inputEncodingState, dst,
	    dstNeeded + TCL_UTF_MAX, &srcRead, &dstWrote, &numChars);
    if (srcRead == 0) {
	/*
	 * Not enough bytes in src buffer to make a complete char.  Copy
	 * the bytes to the next buffer to make a new contiguous string,
	 * then tell the caller to fill the buffer with more bytes.
	 */

	ChannelBuffer *nextPtr;
	
	nextPtr = bufPtr->nextPtr;
	if (nextPtr == NULL) {
	    if (srcLen > 0) {
	        /*
		 * There isn't enough data in the buffers to complete the next
		 * character, so we need to wait for more data before the next
		 * file event can be delivered.
		 *
		 * SF #478856.
		 *
		 * The exception to this is if the input buffer was
		 * completely empty before we tried to convert its
		 * contents. Nothing in, nothing out, and no incomplete
		 * character data. The conversion before the current one
		 * was complete.
		 */

	        statePtr->flags |= CHANNEL_NEED_MORE_DATA;
	    }
	    return -1;
	}
	nextPtr->nextRemoved -= srcLen;
	memcpy((VOID *) (nextPtr->buf + nextPtr->nextRemoved), (VOID *) src,
		(size_t) srcLen);
	RecycleBuffer(statePtr, bufPtr, 0);
	statePtr->inQueueHead = nextPtr;
	return ReadChars(statePtr, objPtr, charsToRead, offsetPtr, factorPtr);
    }

    dstRead = dstWrote;
    if (TranslateInputEOL(statePtr, dst, dst, &dstWrote, &dstRead) != 0) {
	/*
	 * Hit EOF char.  How many bytes of src correspond to where the
	 * EOF was located in dst? Run the conversion again with an
	 * output buffer just big enough to hold the data so we can
	 * get the correct value for srcRead.
	 */
	 
	if (dstWrote == 0) {
	    return -1;
	}
	statePtr->inputEncodingState = oldState;
	Tcl_ExternalToUtf(NULL, statePtr->encoding, src, srcLen,
		statePtr->inputEncodingFlags, &statePtr->inputEncodingState,
		dst, dstRead + TCL_UTF_MAX, &srcRead, &dstWrote, &numChars);
	TranslateInputEOL(statePtr, dst, dst, &dstWrote, &dstRead);
    } 

    /*
     * The number of characters that we got may be less than the number
     * that we started with because "\r\n" sequences may have been
     * turned into just '\n' in dst.
     */

    numChars -= (dstRead - dstWrote);

    if ((unsigned) numChars > (unsigned) toRead) {
	/*
	 * Got too many chars.
	 */

	CONST char *eof;

	eof = Tcl_UtfAtIndex(dst, toRead);
	statePtr->inputEncodingState = oldState;
	Tcl_ExternalToUtf(NULL, statePtr->encoding, src, srcLen,
		statePtr->inputEncodingFlags, &statePtr->inputEncodingState,
		dst, eof - dst + TCL_UTF_MAX, &srcRead, &dstWrote, &numChars);
	dstRead = dstWrote;
	TranslateInputEOL(statePtr, dst, dst, &dstWrote, &dstRead);
	numChars -= (dstRead - dstWrote);
    }
    statePtr->inputEncodingFlags &= ~TCL_ENCODING_START;

    bufPtr->nextRemoved += srcRead;
    if (dstWrote > srcRead + 1) {
	*factorPtr = dstWrote * UTF_EXPANSION_FACTOR / srcRead;
    }
    *offsetPtr += dstWrote;
    return numChars;
}

/*
 *---------------------------------------------------------------------------
 *
 * TranslateInputEOL --
 *
 *	Perform input EOL and EOF translation on the source buffer,
 *	leaving the translated result in the destination buffer.  
 *
 * Results:
 *	The return value is 1 if the EOF character was found when copying
 *	bytes to the destination buffer, 0 otherwise.  
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
 */

static int
TranslateInputEOL(statePtr, dstStart, srcStart, dstLenPtr, srcLenPtr)
    ChannelState *statePtr;	/* Channel being read, for EOL translation
				 * and EOF character. */
    char *dstStart;		/* Output buffer filled with chars by
				 * applying appropriate EOL translation to
				 * source characters. */
    CONST char *srcStart;	/* Source characters. */
    int *dstLenPtr;		/* On entry, the maximum length of output
				 * buffer in bytes; must be <= *srcLenPtr.  On
				 * exit, the number of bytes actually used in
				 * output buffer. */
    int *srcLenPtr;		/* On entry, the length of source buffer.
				 * On exit, the number of bytes read from
				 * the source buffer. */
{
    int dstLen, srcLen, inEofChar;
    CONST char *eof;

    dstLen = *dstLenPtr;

    eof = NULL;
    inEofChar = statePtr->inEofChar;
    if (inEofChar != '\0') {
	/*
	 * Find EOF in translated buffer then compress out the EOL.  The
	 * source buffer may be much longer than the destination buffer --
	 * we only want to return EOF if the EOF has been copied to the
	 * destination buffer.
	 */

	CONST char *src, *srcMax;

	srcMax = srcStart + *srcLenPtr;
	for (src = srcStart; src < srcMax; src++) {
	    if (*src == inEofChar) {
		eof = src;
		srcLen = src - srcStart;
		if (srcLen < dstLen) {
		    dstLen = srcLen;
		}
		*srcLenPtr = srcLen;
		break;
	    }
	}
    }
    switch (statePtr->inputTranslation) {
	case TCL_TRANSLATE_LF: {
	    if (dstStart != srcStart) {
		memcpy((VOID *) dstStart, (VOID *) srcStart, (size_t) dstLen);
	    }
	    srcLen = dstLen;
	    break;
	}
	case TCL_TRANSLATE_CR: {
	    char *dst, *dstEnd;
	    
	    if (dstStart != srcStart) {
		memcpy((VOID *) dstStart, (VOID *) srcStart, (size_t) dstLen);
	    }
	    dstEnd = dstStart + dstLen;
	    for (dst = dstStart; dst < dstEnd; dst++) {
		if (*dst == '\r') {
		    *dst = '\n';
		}
	    }
	    srcLen = dstLen;
	    break;
	}
	case TCL_TRANSLATE_CRLF: {
	    char *dst;
	    CONST char *src, *srcEnd, *srcMax;
	    
	    dst = dstStart;
	    src = srcStart;
	    srcEnd = srcStart + dstLen;
	    srcMax = srcStart + *srcLenPtr;

	    for ( ; src < srcEnd; ) {
		if (*src == '\r') {
		    src++;
		    if (src >= srcMax) {
			statePtr->flags |= INPUT_NEED_NL;
		    } else if (*src == '\n') {
			*dst++ = *src++;
		    } else {
			*dst++ = '\r';
		    }
		} else {
		    *dst++ = *src++;
		}
	    }
	    srcLen = src - srcStart;
	    dstLen = dst - dstStart;
	    break;
	}
	case TCL_TRANSLATE_AUTO: {
	    char *dst;
	    CONST char *src, *srcEnd, *srcMax;

	    dst = dstStart;
	    src = srcStart;
	    srcEnd = srcStart + dstLen;
	    srcMax = srcStart + *srcLenPtr;

	    if ((statePtr->flags & INPUT_SAW_CR) && (src < srcMax)) {
		if (*src == '\n') {
		    src++;
		}
		statePtr->flags &= ~INPUT_SAW_CR;
	    }
	    for ( ; src < srcEnd; ) {
		if (*src == '\r') {
		    src++;
		    if (src >= srcMax) {
			statePtr->flags |= INPUT_SAW_CR;
		    } else if (*src == '\n') {
			if (srcEnd < srcMax) {
			    srcEnd++;
			}
			src++;
		    }
		    *dst++ = '\n';
		} else {
		    *dst++ = *src++;
		}
	    }
	    srcLen = src - srcStart;
	    dstLen = dst - dstStart;
	    break;
	}
	default: {		/* lint. */
	    return 0;
	}
    }
    *dstLenPtr = dstLen;

    if ((eof != NULL) && (srcStart + srcLen >= eof)) {
	/*
	 * EOF character was seen in EOL translated range.  Leave current
	 * file position pointing at the EOF character, but don't store the
	 * EOF character in the output string.
	 */

	statePtr->flags |= (CHANNEL_EOF | CHANNEL_STICKY_EOF);
	statePtr->inputEncodingFlags |= TCL_ENCODING_END;
	statePtr->flags &= ~(INPUT_SAW_CR | INPUT_NEED_NL);
	return 1;
    }

    *srcLenPtr = srcLen;
    return 0;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_Ungets --
 *
 *	Causes the supplied string to be added to the input queue of
 *	the channel, at either the head or tail of the queue.
 *
 * Results:
 *	The number of bytes stored in the channel, or -1 on error.
 *
 * Side effects:
 *	Adds input to the input queue of a channel.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_Ungets(chan, str, len, atEnd)
    Tcl_Channel chan;		/* The channel for which to add the input. */
    CONST char *str;		/* The input itself. */
    int len;			/* The length of the input. */
    int atEnd;			/* If non-zero, add at end of queue; otherwise
                                 * add at head of queue. */    
{
    Channel *chanPtr;		/* The real IO channel. */
    ChannelState *statePtr;	/* State of actual channel. */
    ChannelBuffer *bufPtr;	/* Buffer to contain the data. */
    int i, flags;

    chanPtr = (Channel *) chan;
    statePtr = chanPtr->state;

    /*
     * This operation should occur at the top of a channel stack.
     */

    chanPtr = statePtr->topChanPtr;

    /*
     * CheckChannelErrors clears too many flag bits in this one case.
     */
     
    flags = statePtr->flags;
    if (CheckChannelErrors(statePtr, TCL_READABLE) != 0) {
	len = -1;
	goto done;
    }
    statePtr->flags = flags;

    /*
     * If we have encountered a sticky EOF, just punt without storing.
     * (sticky EOF is set if we have seen the input eofChar, to prevent
     * reading beyond the eofChar). Otherwise, clear the EOF flags, and
     * clear the BLOCKED bit. We want to discover these conditions anew
     * in each operation.
     */

    if (statePtr->flags & CHANNEL_STICKY_EOF) {
	goto done;
    }
    statePtr->flags &= (~(CHANNEL_BLOCKED | CHANNEL_EOF));

    bufPtr = AllocChannelBuffer(len);
    for (i = 0; i < len; i++) {
        bufPtr->buf[i] = str[i];
    }
    bufPtr->nextAdded += len;

    if (statePtr->inQueueHead == (ChannelBuffer *) NULL) {
        bufPtr->nextPtr = (ChannelBuffer *) NULL;
        statePtr->inQueueHead = bufPtr;
        statePtr->inQueueTail = bufPtr;
    } else if (atEnd) {
        bufPtr->nextPtr = (ChannelBuffer *) NULL;
        statePtr->inQueueTail->nextPtr = bufPtr;
        statePtr->inQueueTail = bufPtr;
    } else {
        bufPtr->nextPtr = statePtr->inQueueHead;
        statePtr->inQueueHead = bufPtr;
    }

    done:
    /*
     * Update the notifier state so we don't block while there is still
     * data in the buffers.
     */

    UpdateInterest(chanPtr);
    return len;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_Flush --
 *
 *	Flushes output data on a channel.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	May flush output queued on this channel.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_Flush(chan)
    Tcl_Channel chan;			/* The Channel to flush. */
{
    int result;				/* Of calling FlushChannel. */
    Channel *chanPtr  = (Channel *) chan;	/* The actual channel. */
    ChannelState *statePtr = chanPtr->state;	/* State of actual channel. */

    /*
     * This operation should occur at the top of a channel stack.
     */

    chanPtr = statePtr->topChanPtr;

    if (CheckChannelErrors(statePtr, TCL_WRITABLE) != 0) {
	return -1;
    }

    /*
     * Force current output buffer to be output also.
     */

    if ((statePtr->curOutPtr != NULL)
	    && (statePtr->curOutPtr->nextAdded > 0)) {
        statePtr->flags |= BUFFER_READY;
    }
    
    result = FlushChannel(NULL, chanPtr, 0);
    if (result != 0) {
        return TCL_ERROR;
    }

    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * DiscardInputQueued --
 *
 *	Discards any input read from the channel but not yet consumed
 *	by Tcl reading commands.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	May discard input from the channel. If discardLastBuffer is zero,
 *	leaves one buffer in place for back-filling.
 *
 *----------------------------------------------------------------------
 */

static void
DiscardInputQueued(statePtr, discardSavedBuffers)
    ChannelState *statePtr;	/* Channel on which to discard
                                 * the queued input. */
    int discardSavedBuffers;	/* If non-zero, discard all buffers including
                                 * last one. */
{
    ChannelBuffer *bufPtr, *nxtPtr;	/* Loop variables. */

    bufPtr = statePtr->inQueueHead;
    statePtr->inQueueHead = (ChannelBuffer *) NULL;
    statePtr->inQueueTail = (ChannelBuffer *) NULL;
    for (; bufPtr != (ChannelBuffer *) NULL; bufPtr = nxtPtr) {
        nxtPtr = bufPtr->nextPtr;
        RecycleBuffer(statePtr, bufPtr, discardSavedBuffers);
    }

    /*
     * If discardSavedBuffers is nonzero, must also discard any previously
     * saved buffer in the saveInBufPtr field.
     */
    
    if (discardSavedBuffers) {
        if (statePtr->saveInBufPtr != (ChannelBuffer *) NULL) {
            ckfree((char *) statePtr->saveInBufPtr);
            statePtr->saveInBufPtr = (ChannelBuffer *) NULL;
        }
    }
}

/*
 *---------------------------------------------------------------------------
 *
 * GetInput --
 *
 *	Reads input data from a device into a channel buffer.  
 *
 * Results:
 *	The return value is the Posix error code if an error occurred while
 *	reading from the file, or 0 otherwise.  
 *
 * Side effects:
 *	Reads from the underlying device.
 *
 *---------------------------------------------------------------------------
 */

static int
GetInput(chanPtr)
    Channel *chanPtr;		/* Channel to read input from. */
{
    int toRead;			/* How much to read? */
    int result;			/* Of calling driver. */
    int nread;			/* How much was read from channel? */
    ChannelBuffer *bufPtr;	/* New buffer to add to input queue. */
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */

    /*
     * Prevent reading from a dead channel -- a channel that has been closed
     * but not yet deallocated, which can happen if the exit handler for
     * channel cleanup has run but the channel is still registered in some
     * interpreter.
     */
    
    if (CheckForDeadChannel(NULL, statePtr)) {
	return EINVAL;
    }

    /*
     * First check for more buffers in the pushback area of the
     * topmost channel in the stack and use them. They can be the
     * result of a transformation which went away without reading all
     * the information placed in the area when it was stacked.
     *
     * Two possibilities for the state: No buffers in it, or a single
     * empty buffer. In the latter case we can recycle it now.
     */

    if (chanPtr->inQueueHead != (ChannelBuffer*) NULL) {
        if (statePtr->inQueueHead != (ChannelBuffer*) NULL) {
	    RecycleBuffer(statePtr, statePtr->inQueueHead, 0);
	    statePtr->inQueueHead = (ChannelBuffer*) NULL;
	}

	statePtr->inQueueHead = chanPtr->inQueueHead;
	statePtr->inQueueTail = chanPtr->inQueueTail;
	chanPtr->inQueueHead  = (ChannelBuffer*) NULL;
	chanPtr->inQueueTail  = (ChannelBuffer*) NULL;
	return 0;
    }

    /*
     * Nothing in the pushback area, fall back to the usual handling
     * (driver, etc.)
     */

    /*
     * See if we can fill an existing buffer. If we can, read only
     * as much as will fit in it. Otherwise allocate a new buffer,
     * add it to the input queue and attempt to fill it to the max.
     */

    bufPtr = statePtr->inQueueTail;
    if ((bufPtr != NULL) && (bufPtr->nextAdded < bufPtr->bufLength)) {
        toRead = bufPtr->bufLength - bufPtr->nextAdded;
    } else {
	bufPtr = statePtr->saveInBufPtr;
	statePtr->saveInBufPtr = NULL;

	/*
	 * Check the actual buffersize against the requested
	 * buffersize. Buffers which are smaller than requested are
	 * squashed. This is done to honor dynamic changes of the
	 * buffersize made by the user.
	 */

	if ((bufPtr != NULL) && ((bufPtr->bufLength - BUFFER_PADDING) < statePtr->bufSize)) {
	  ckfree((char *) bufPtr);
	  bufPtr = NULL;
	}

	if (bufPtr == NULL) {
	    bufPtr = AllocChannelBuffer(statePtr->bufSize);
	}
        bufPtr->nextPtr = (ChannelBuffer *) NULL;

	/* SF #427196: Use the actual size of the buffer to determine
	 * the number of bytes to read from the channel and not the
	 * size for new buffers. They can be different if the
	 * buffersize was changed between reads.
	 *
	 * Note: This affects performance negatively if the buffersize
	 * was extended but this small buffer is reused for all
	 * subsequent reads. The system never uses buffers with the
	 * requested bigger size in that case. An adjunct patch could
	 * try and delete all unused buffers it encounters and which
	 * are smaller than the formally requested buffersize.
	 */

	toRead = bufPtr->bufLength - bufPtr->nextAdded;

        if (statePtr->inQueueTail == NULL) {
            statePtr->inQueueHead = bufPtr;
        } else {
            statePtr->inQueueTail->nextPtr = bufPtr;
        }
        statePtr->inQueueTail = bufPtr;
    }

    /*
     * If EOF is set, we should avoid calling the driver because on some
     * platforms it is impossible to read from a device after EOF.
     */

    if (statePtr->flags & CHANNEL_EOF) {
	return 0;
    }

    if ((statePtr->flags & CHANNEL_TIMER_FEV) &&
	(statePtr->flags & CHANNEL_NONBLOCKING)) {
        nread = -1;
        result = EWOULDBLOCK;
    } else {
        nread = (chanPtr->typePtr->inputProc)(chanPtr->instanceData,
		    bufPtr->buf + bufPtr->nextAdded, toRead, &result);
    }

    if (nread > 0) {
	bufPtr->nextAdded += nread;

	/*
	 * If we get a short read, signal up that we may be BLOCKED. We
	 * should avoid calling the driver because on some platforms we
	 * will block in the low level reading code even though the
	 * channel is set into nonblocking mode.
	 */
            
	if (nread < toRead) {
	    statePtr->flags |= CHANNEL_BLOCKED;
	}
    } else if (nread == 0) {
	statePtr->flags |= CHANNEL_EOF;
	statePtr->inputEncodingFlags |= TCL_ENCODING_END;
    } else if (nread < 0) {
	if ((result == EWOULDBLOCK) || (result == EAGAIN)) {
	    statePtr->flags |= CHANNEL_BLOCKED;
	    result = EAGAIN;
	}
	Tcl_SetErrno(result);
	return result;
    }
    return 0;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_Seek --
 *
 *	Implements seeking on Tcl Channels. This is a public function
 *	so that other C facilities may be implemented on top of it.
 *
 * Results:
 *	The new access point or -1 on error. If error, use Tcl_GetErrno()
 *	to retrieve the POSIX error code for the error that occurred.
 *
 * Side effects:
 *	May flush output on the channel. May discard queued input.
 *
 *----------------------------------------------------------------------
 */

Tcl_WideInt
Tcl_Seek(chan, offset, mode)
    Tcl_Channel chan;		/* The channel on which to seek. */
    Tcl_WideInt offset;		/* Offset to seek to. */
    int mode;			/* Relative to which location to seek? */
{
    Channel *chanPtr = (Channel *) chan;	/* The real IO channel. */
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    int inputBuffered, outputBuffered;
				/* # bytes held in buffers. */
    int result;			/* Of device driver operations. */
    Tcl_WideInt curPos;		/* Position on the device. */
    int wasAsync;		/* Was the channel nonblocking before the
                                 * seek operation? If so, must restore to
                                 * nonblocking mode after the seek. */

    if (CheckChannelErrors(statePtr, TCL_WRITABLE | TCL_READABLE) != 0) {
	return Tcl_LongAsWide(-1);
    }

    /*
     * Disallow seek on dead channels -- channels that have been closed but
     * not yet been deallocated. Such channels can be found if the exit
     * handler for channel cleanup has run but the channel is still
     * registered in an interpreter.
     */

    if (CheckForDeadChannel(NULL, statePtr)) {
	return Tcl_LongAsWide(-1);
    }

    /*
     * This operation should occur at the top of a channel stack.
     */

    chanPtr = statePtr->topChanPtr;

    /*
     * Disallow seek on channels whose type does not have a seek procedure
     * defined. This means that the channel does not support seeking.
     */

    if (chanPtr->typePtr->seekProc == (Tcl_DriverSeekProc *) NULL) {
        Tcl_SetErrno(EINVAL);
        return Tcl_LongAsWide(-1);
    }

    /*
     * Compute how much input and output is buffered. If both input and
     * output is buffered, cannot compute the current position.
     */

    inputBuffered = Tcl_InputBuffered(chan);
    outputBuffered = Tcl_OutputBuffered(chan);

    if ((inputBuffered != 0) && (outputBuffered != 0)) {
        Tcl_SetErrno(EFAULT);
        return Tcl_LongAsWide(-1);
    }

    /*
     * If we are seeking relative to the current position, compute the
     * corrected offset taking into account the amount of unread input.
     */

    if (mode == SEEK_CUR) {
        offset -= inputBuffered;
    }

    /*
     * Discard any queued input - this input should not be read after
     * the seek.
     */

    DiscardInputQueued(statePtr, 0);

    /*
     * Reset EOF and BLOCKED flags. We invalidate them by moving the
     * access point. Also clear CR related flags.
     */

    statePtr->flags &=
        (~(CHANNEL_EOF | CHANNEL_STICKY_EOF | CHANNEL_BLOCKED | INPUT_SAW_CR));
    
    /*
     * If the channel is in asynchronous output mode, switch it back
     * to synchronous mode and cancel any async flush that may be
     * scheduled. After the flush, the channel will be put back into
     * asynchronous output mode.
     */

    wasAsync = 0;
    if (statePtr->flags & CHANNEL_NONBLOCKING) {
        wasAsync = 1;
        result = StackSetBlockMode(chanPtr, TCL_MODE_BLOCKING);
	if (result != 0) {
	    return Tcl_LongAsWide(-1);
	}
        statePtr->flags &= (~(CHANNEL_NONBLOCKING));
        if (statePtr->flags & BG_FLUSH_SCHEDULED) {
            statePtr->flags &= (~(BG_FLUSH_SCHEDULED));
        }
    }
    
    /*
     * If the flush fails we cannot recover the original position. In
     * that case the seek is not attempted because we do not know where
     * the access position is - instead we return the error. FlushChannel
     * has already called Tcl_SetErrno() to report the error upwards.
     * If the flush succeeds we do the seek also.
     */
    
    if (FlushChannel(NULL, chanPtr, 0) != 0) {
        curPos = -1;
    } else {

        /*
         * Now seek to the new position in the channel as requested by the
         * caller.  Note that we prefer the wideSeekProc if that is
	 * available and non-NULL...
         */

	if (HaveVersion(chanPtr->typePtr, TCL_CHANNEL_VERSION_3) &&
		chanPtr->typePtr->wideSeekProc != NULL) {
	    curPos = (chanPtr->typePtr->wideSeekProc) (chanPtr->instanceData,
		    offset, mode, &result);
	} else if (offset < Tcl_LongAsWide(LONG_MIN) ||
		offset > Tcl_LongAsWide(LONG_MAX)) {
	    Tcl_SetErrno(EOVERFLOW);
	    curPos = Tcl_LongAsWide(-1);
	} else {
	    curPos = Tcl_LongAsWide((chanPtr->typePtr->seekProc) (
		    chanPtr->instanceData, Tcl_WideAsLong(offset), mode,
		    &result));
	    if (curPos == Tcl_LongAsWide(-1)) {
		Tcl_SetErrno(result);
	    }
	}
    }
    
    /*
     * Restore to nonblocking mode if that was the previous behavior.
     *
     * NOTE: Even if there was an async flush active we do not restore
     * it now because we already flushed all the queued output, above.
     */
    
    if (wasAsync) {
        statePtr->flags |= CHANNEL_NONBLOCKING;
        result = StackSetBlockMode(chanPtr, TCL_MODE_NONBLOCKING);
	if (result != 0) {
	    return Tcl_LongAsWide(-1);
	}
    }

    return curPos;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_Tell --
 *
 *	Returns the position of the next character to be read/written on
 *	this channel.
 *
 * Results:
 *	A nonnegative integer on success, -1 on failure. If failed,
 *	use Tcl_GetErrno() to retrieve the POSIX error code for the
 *	error that occurred.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_WideInt
Tcl_Tell(chan)
    Tcl_Channel chan;			/* The channel to return pos for. */
{
    Channel *chanPtr = (Channel *) chan;	/* The real IO channel. */
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    int inputBuffered, outputBuffered;	/* # bytes held in buffers. */
    int result;				/* Of calling device driver. */
    Tcl_WideInt curPos;			/* Position on device. */

    if (CheckChannelErrors(statePtr, TCL_WRITABLE | TCL_READABLE) != 0) {
	return Tcl_LongAsWide(-1);
    }

    /*
     * Disallow tell on dead channels -- channels that have been closed but
     * not yet been deallocated. Such channels can be found if the exit
     * handler for channel cleanup has run but the channel is still
     * registered in an interpreter.
     */

    if (CheckForDeadChannel(NULL, statePtr)) {
	return Tcl_LongAsWide(-1);
    }

    /*
     * This operation should occur at the top of a channel stack.
     */

    chanPtr = statePtr->topChanPtr;

    /*
     * Disallow tell on channels whose type does not have a seek procedure
     * defined. This means that the channel does not support seeking.
     */

    if (chanPtr->typePtr->seekProc == (Tcl_DriverSeekProc *) NULL) {
        Tcl_SetErrno(EINVAL);
        return Tcl_LongAsWide(-1);
    }

    /*
     * Compute how much input and output is buffered. If both input and
     * output is buffered, cannot compute the current position.
     */

    inputBuffered = Tcl_InputBuffered(chan);
    outputBuffered = Tcl_OutputBuffered(chan);

    if ((inputBuffered != 0) && (outputBuffered != 0)) {
        Tcl_SetErrno(EFAULT);
        return Tcl_LongAsWide(-1);
    }

    /*
     * Get the current position in the device and compute the position
     * where the next character will be read or written.  Note that we
     * prefer the wideSeekProc if that is available and non-NULL...
     */

    if (HaveVersion(chanPtr->typePtr, TCL_CHANNEL_VERSION_3) &&
	    chanPtr->typePtr->wideSeekProc != NULL) {
	curPos = (chanPtr->typePtr->wideSeekProc) (chanPtr->instanceData,
		Tcl_LongAsWide(0), SEEK_CUR, &result);
    } else {
	curPos = Tcl_LongAsWide((chanPtr->typePtr->seekProc) (
		chanPtr->instanceData, 0, SEEK_CUR, &result));
    }
    if (curPos == Tcl_LongAsWide(-1)) {
        Tcl_SetErrno(result);
        return Tcl_LongAsWide(-1);
    }
    if (inputBuffered != 0) {
        return curPos - inputBuffered;
    }
    return curPos + outputBuffered;
}

/*
 *---------------------------------------------------------------------------
 *
 * Tcl_SeekOld, Tcl_TellOld --
 *
 *	Backward-compatability versions of the seek/tell interface that
 *	do not support 64-bit offsets.  This interface is not documented
 *	or expected to be supported indefinitely.
 *
 * Results:
 *	As for Tcl_Seek and Tcl_Tell respectively, except truncated to
 *	whatever value will fit in an 'int'.
 *
 * Side effects:
 *	As for Tcl_Seek and Tcl_Tell respectively.
 *
 *---------------------------------------------------------------------------
 */

int
Tcl_SeekOld(chan, offset, mode)
    Tcl_Channel chan;		/* The channel on which to seek. */
    int offset;			/* Offset to seek to. */
    int mode;			/* Relative to which location to seek? */
{
    Tcl_WideInt wOffset, wResult;

    wOffset = Tcl_LongAsWide((long)offset);
    wResult = Tcl_Seek(chan, wOffset, mode);
    return (int)Tcl_WideAsLong(wResult);
}

int
Tcl_TellOld(chan)
    Tcl_Channel chan;		/* The channel to return pos for. */
{
    Tcl_WideInt wResult;

    wResult = Tcl_Tell(chan);
    return (int)Tcl_WideAsLong(wResult);
}

/*
 *---------------------------------------------------------------------------
 *
 * CheckChannelErrors --
 *
 *	See if the channel is in an ready state and can perform the
 *	desired operation.
 *
 * Results:
 *	The return value is 0 if the channel is OK, otherwise the
 *	return value is -1 and errno is set to indicate the error.
 *
 * Side effects:
 *	May clear the EOF and/or BLOCKED bits if reading from channel.
 *
 *---------------------------------------------------------------------------
 */
 
static int
CheckChannelErrors(statePtr, flags)
    ChannelState *statePtr;	/* Channel to check. */
    int flags;			/* Test if channel supports desired operation:
				 * TCL_READABLE, TCL_WRITABLE.  Also indicates
				 * Raw read or write for special close
				 * processing*/
{
    int direction = flags & (TCL_READABLE|TCL_WRITABLE);

    /*
     * Check for unreported error.
     */

    if (statePtr->unreportedError != 0) {
        Tcl_SetErrno(statePtr->unreportedError);
        statePtr->unreportedError = 0;
        return -1;
    }

    /*
     * Only the raw read and write operations are allowed during close
     * in order to drain data from stacked channels.
     */

    if ((statePtr->flags & CHANNEL_CLOSED) &&
	    ((flags & CHANNEL_RAW_MODE) == 0)) {
        Tcl_SetErrno(EACCES);
        return -1;
    }

    /*
     * Fail if the channel is not opened for desired operation.
     */

    if ((statePtr->flags & direction) == 0) {
        Tcl_SetErrno(EACCES);
        return -1;
    }

    /*
     * Fail if the channel is in the middle of a background copy.
     *
     * Don't do this tests for raw channels here or else the chaining in the
     * transformation drivers will fail with 'file busy' error instead of
     * retrieving and transforming the data to copy.
     */

    if ((statePtr->csPtr != NULL) && ((flags & CHANNEL_RAW_MODE) == 0)) {
	Tcl_SetErrno(EBUSY);
	return -1;
    }

    if (direction == TCL_READABLE) {
	/*
	 * If we have not encountered a sticky EOF, clear the EOF bit
	 * (sticky EOF is set if we have seen the input eofChar, to prevent
	 * reading beyond the eofChar). Also, always clear the BLOCKED bit.
	 * We want to discover these conditions anew in each operation.
	 */

	if ((statePtr->flags & CHANNEL_STICKY_EOF) == 0) {
	    statePtr->flags &= ~CHANNEL_EOF;
	}
	statePtr->flags &= ~(CHANNEL_BLOCKED | CHANNEL_NEED_MORE_DATA);
    }

    return 0;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_Eof --
 *
 *	Returns 1 if the channel is at EOF, 0 otherwise.
 *
 * Results:
 *	1 or 0, always.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_Eof(chan)
    Tcl_Channel chan;			/* Does this channel have EOF? */
{
    ChannelState *statePtr = ((Channel *) chan)->state;
					/* State of real channel structure. */

    return ((statePtr->flags & CHANNEL_STICKY_EOF) ||
            ((statePtr->flags & CHANNEL_EOF) &&
		    (Tcl_InputBuffered(chan) == 0))) ? 1 : 0;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_InputBlocked --
 *
 *	Returns 1 if input is blocked on this channel, 0 otherwise.
 *
 * Results:
 *	0 or 1, always.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_InputBlocked(chan)
    Tcl_Channel chan;			/* Is this channel blocked? */
{
    ChannelState *statePtr = ((Channel *) chan)->state;
					/* State of real channel structure. */

    return (statePtr->flags & CHANNEL_BLOCKED) ? 1 : 0;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_InputBuffered --
 *
 *	Returns the number of bytes of input currently buffered in the
 *	common internal buffer of a channel.
 *
 * Results:
 *	The number of input bytes buffered, or zero if the channel is not
 *	open for reading.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_InputBuffered(chan)
    Tcl_Channel chan;			/* The channel to query. */
{
    ChannelState *statePtr = ((Channel *) chan)->state;
					/* State of real channel structure. */
    ChannelBuffer *bufPtr;
    int bytesBuffered;

    for (bytesBuffered = 0, bufPtr = statePtr->inQueueHead;
	 bufPtr != (ChannelBuffer *) NULL;
	 bufPtr = bufPtr->nextPtr) {
        bytesBuffered += (bufPtr->nextAdded - bufPtr->nextRemoved);
    }

    /*
     * Don't forget the bytes in the topmost pushback area.
     */

    for (bufPtr = statePtr->topChanPtr->inQueueHead;
	 bufPtr != (ChannelBuffer *) NULL;
	 bufPtr = bufPtr->nextPtr) {
        bytesBuffered += (bufPtr->nextAdded - bufPtr->nextRemoved);
    }

    return bytesBuffered;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_OutputBuffered --
 *
 *    Returns the number of bytes of output currently buffered in the
 *    common internal buffer of a channel.
 *
 * Results:
 *    The number of output bytes buffered, or zero if the channel is not
 *    open for writing.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_OutputBuffered(chan)
    Tcl_Channel chan;                 /* The channel to query. */
{
    ChannelState *statePtr = ((Channel *) chan)->state;
                                      /* State of real channel structure. */
    ChannelBuffer *bufPtr;
    int bytesBuffered;

    for (bytesBuffered = 0, bufPtr = statePtr->outQueueHead;
	bufPtr != (ChannelBuffer *) NULL;
	bufPtr = bufPtr->nextPtr) {
	bytesBuffered += (bufPtr->nextAdded - bufPtr->nextRemoved);
    }
    if ((statePtr->curOutPtr != (ChannelBuffer *) NULL) &&
	(statePtr->curOutPtr->nextAdded > statePtr->curOutPtr->nextRemoved)) {
	statePtr->flags |= BUFFER_READY;
	bytesBuffered +=
	    (statePtr->curOutPtr->nextAdded - statePtr->curOutPtr->nextRemoved);
    }

    return bytesBuffered;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_ChannelBuffered --
 *
 *	Returns the number of bytes of input currently buffered in the
 *	internal buffer (push back area) of a channel.
 *
 * Results:
 *	The number of input bytes buffered, or zero if the channel is not
 *	open for reading.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_ChannelBuffered(chan)
    Tcl_Channel chan;			/* The channel to query. */
{
    Channel *chanPtr = (Channel *) chan;
					/* real channel structure. */
    ChannelBuffer *bufPtr;
    int bytesBuffered;

    for (bytesBuffered = 0, bufPtr = chanPtr->inQueueHead;
	 bufPtr != (ChannelBuffer *) NULL;
	 bufPtr = bufPtr->nextPtr) {
        bytesBuffered += (bufPtr->nextAdded - bufPtr->nextRemoved);
    }

    return bytesBuffered;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_SetChannelBufferSize --
 *
 *	Sets the size of buffers to allocate to store input or output
 *	in the channel. The size must be between 10 bytes and 1 MByte.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Sets the size of buffers subsequently allocated for this channel.
 *
 *----------------------------------------------------------------------
 */

void
Tcl_SetChannelBufferSize(chan, sz)
    Tcl_Channel chan;			/* The channel whose buffer size
                                         * to set. */
    int sz;				/* The size to set. */
{
    ChannelState *statePtr;		/* State of real channel structure. */
    
    /*
     * If the buffer size is smaller than 10 bytes or larger than one MByte,
     * do not accept the requested size and leave the current buffer size.
     */
    
    if (sz < 10) {
        return;
    }
    if (sz > (1024 * 1024)) {
        return;
    }

    statePtr = ((Channel *) chan)->state;
    statePtr->bufSize = sz;

    if (statePtr->outputStage != NULL) {
	ckfree((char *) statePtr->outputStage);
	statePtr->outputStage = NULL;
    }
    if ((statePtr->encoding != NULL) && (statePtr->flags & TCL_WRITABLE)) {
	statePtr->outputStage = (char *)
	    ckalloc((unsigned) (statePtr->bufSize + 2));
    }
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetChannelBufferSize --
 *
 *	Retrieves the size of buffers to allocate for this channel.
 *
 * Results:
 *	The size.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_GetChannelBufferSize(chan)
    Tcl_Channel chan;		/* The channel for which to find the
                                 * buffer size. */
{
    ChannelState *statePtr = ((Channel *) chan)->state;
					/* State of real channel structure. */

    return statePtr->bufSize;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_BadChannelOption --
 *
 *	This procedure generates a "bad option" error message in an
 *	(optional) interpreter.  It is used by channel drivers when 
 *      a invalid Set/Get option is requested. Its purpose is to concatenate
 *      the generic options list to the specific ones and factorize
 *      the generic options error message string.
 *
 * Results:
 *	TCL_ERROR.
 *
 * Side effects:
 *	An error message is generated in interp's result object to
 *	indicate that a command was invoked with the a bad option
 *	The message has the form
 *		bad option "blah": should be one of 
 *              <...generic options...>+<...specific options...>
 *	"blah" is the optionName argument and "<specific options>"
 *	is a space separated list of specific option words.
 *      The function takes good care of inserting minus signs before
 *      each option, commas after, and an "or" before the last option.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_BadChannelOption(interp, optionName, optionList)
    Tcl_Interp *interp;			/* Current interpreter. (can be NULL)*/
    CONST char *optionName;		/* 'bad option' name */
    CONST char *optionList;		/* Specific options list to append 
					 * to the standard generic options.
					 * can be NULL for generic options 
					 * only.
					 */
{
    if (interp) {
	CONST char *genericopt = 
	    "blocking buffering buffersize encoding eofchar translation";
	CONST char **argv;
	int  argc, i;
	Tcl_DString ds;

	Tcl_DStringInit(&ds);
	Tcl_DStringAppend(&ds, genericopt, -1);
	if (optionList && (*optionList)) {
	    Tcl_DStringAppend(&ds, " ", 1);
	    Tcl_DStringAppend(&ds, optionList, -1);
	}
	if (Tcl_SplitList(interp, Tcl_DStringValue(&ds), 
		&argc, &argv) != TCL_OK) {
	    panic("malformed option list in channel driver");
	}
	Tcl_ResetResult(interp);
	Tcl_AppendResult(interp, "bad option \"", optionName, 
		"\": should be one of ", (char *) NULL);
	argc--;
	for (i = 0; i < argc; i++) {
	    Tcl_AppendResult(interp, "-", argv[i], ", ", (char *) NULL);
	}
	Tcl_AppendResult(interp, "or -", argv[i], (char *) NULL);
	Tcl_DStringFree(&ds);
	ckfree((char *) argv);
    }
    Tcl_SetErrno(EINVAL);
    return TCL_ERROR;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetChannelOption --
 *
 *	Gets a mode associated with an IO channel. If the optionName arg
 *	is non NULL, retrieves the value of that option. If the optionName
 *	arg is NULL, retrieves a list of alternating option names and
 *	values for the given channel.
 *
 * Results:
 *	A standard Tcl result. Also sets the supplied DString to the
 *	string value of the option(s) returned.
 *
 * Side effects:
 *      None.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_GetChannelOption(interp, chan, optionName, dsPtr)
    Tcl_Interp *interp;		/* For error reporting - can be NULL. */
    Tcl_Channel chan;		/* Channel on which to get option. */
    CONST char *optionName;	/* Option to get. */
    Tcl_DString *dsPtr;		/* Where to store value(s). */
{
    size_t len;			/* Length of optionName string. */
    char optionVal[128];	/* Buffer for sprintf. */
    Channel *chanPtr = (Channel *) chan;
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    int flags;

    /*
     * Disallow options on dead channels -- channels that have been closed but
     * not yet been deallocated. Such channels can be found if the exit
     * handler for channel cleanup has run but the channel is still
     * registered in an interpreter.
     */

    if (CheckForDeadChannel(interp, statePtr)) {
	return TCL_ERROR;
    }

    /*
     * This operation should occur at the top of a channel stack.
     */

    chanPtr = statePtr->topChanPtr;

    /*
     * If we are in the middle of a background copy, use the saved flags.
     */

    if (statePtr->csPtr) {
	if (chanPtr == statePtr->csPtr->readPtr) {
	    flags = statePtr->csPtr->readFlags;
	} else {
	    flags = statePtr->csPtr->writeFlags;
	}
    } else {
	flags = statePtr->flags;
    }

    /*
     * If the optionName is NULL it means that we want a list of all
     * options and values.
     */
    
    if (optionName == (char *) NULL) {
        len = 0;
    } else {
        len = strlen(optionName);
    }
    
    if ((len == 0) || ((len > 2) && (optionName[1] == 'b') &&
            (strncmp(optionName, "-blocking", len) == 0))) {
        if (len == 0) {
            Tcl_DStringAppendElement(dsPtr, "-blocking");
        }
        Tcl_DStringAppendElement(dsPtr,
		(flags & CHANNEL_NONBLOCKING) ? "0" : "1");
        if (len > 0) {
            return TCL_OK;
        }
    }
    if ((len == 0) || ((len > 7) && (optionName[1] == 'b') &&
            (strncmp(optionName, "-buffering", len) == 0))) {
        if (len == 0) {
            Tcl_DStringAppendElement(dsPtr, "-buffering");
        }
        if (flags & CHANNEL_LINEBUFFERED) {
            Tcl_DStringAppendElement(dsPtr, "line");
        } else if (flags & CHANNEL_UNBUFFERED) {
            Tcl_DStringAppendElement(dsPtr, "none");
        } else {
            Tcl_DStringAppendElement(dsPtr, "full");
        }
        if (len > 0) {
            return TCL_OK;
        }
    }
    if ((len == 0) || ((len > 7) && (optionName[1] == 'b') &&
            (strncmp(optionName, "-buffersize", len) == 0))) {
        if (len == 0) {
            Tcl_DStringAppendElement(dsPtr, "-buffersize");
        }
        TclFormatInt(optionVal, statePtr->bufSize);
        Tcl_DStringAppendElement(dsPtr, optionVal);
        if (len > 0) {
            return TCL_OK;
        }
    }
    if ((len == 0) ||
	    ((len > 2) && (optionName[1] == 'e') &&
		    (strncmp(optionName, "-encoding", len) == 0))) {
	if (len == 0) {
	    Tcl_DStringAppendElement(dsPtr, "-encoding");
	}
	if (statePtr->encoding == NULL) {
	    Tcl_DStringAppendElement(dsPtr, "binary");
	} else {
	    Tcl_DStringAppendElement(dsPtr,
		    Tcl_GetEncodingName(statePtr->encoding));
	}
	if (len > 0) {
	    return TCL_OK;
	}
    }
    if ((len == 0) ||
            ((len > 2) && (optionName[1] == 'e') &&
                    (strncmp(optionName, "-eofchar", len) == 0))) {
        if (len == 0) {
            Tcl_DStringAppendElement(dsPtr, "-eofchar");
        }
        if (((flags & (TCL_READABLE|TCL_WRITABLE)) ==
                (TCL_READABLE|TCL_WRITABLE)) && (len == 0)) {
            Tcl_DStringStartSublist(dsPtr);
        }
        if (flags & TCL_READABLE) {
            if (statePtr->inEofChar == 0) {
                Tcl_DStringAppendElement(dsPtr, "");
            } else {
                char buf[4];

                sprintf(buf, "%c", statePtr->inEofChar);
                Tcl_DStringAppendElement(dsPtr, buf);
            }
        }
        if (flags & TCL_WRITABLE) {
            if (statePtr->outEofChar == 0) {
                Tcl_DStringAppendElement(dsPtr, "");
            } else {
                char buf[4];

                sprintf(buf, "%c", statePtr->outEofChar);
                Tcl_DStringAppendElement(dsPtr, buf);
            }
        }
        if ( !(flags & (TCL_READABLE|TCL_WRITABLE))) {
            /* Not readable or writable (server socket) */
            Tcl_DStringAppendElement(dsPtr, "");
        }
        if (((flags & (TCL_READABLE|TCL_WRITABLE)) ==
                (TCL_READABLE|TCL_WRITABLE)) && (len == 0)) {
            Tcl_DStringEndSublist(dsPtr);
        }
        if (len > 0) {
            return TCL_OK;
        }
    }
    if ((len == 0) ||
            ((len > 1) && (optionName[1] == 't') &&
                    (strncmp(optionName, "-translation", len) == 0))) {
        if (len == 0) {
            Tcl_DStringAppendElement(dsPtr, "-translation");
        }
        if (((flags & (TCL_READABLE|TCL_WRITABLE)) ==
                (TCL_READABLE|TCL_WRITABLE)) && (len == 0)) {
            Tcl_DStringStartSublist(dsPtr);
        }
        if (flags & TCL_READABLE) {
            if (statePtr->inputTranslation == TCL_TRANSLATE_AUTO) {
                Tcl_DStringAppendElement(dsPtr, "auto");
            } else if (statePtr->inputTranslation == TCL_TRANSLATE_CR) {
                Tcl_DStringAppendElement(dsPtr, "cr");
            } else if (statePtr->inputTranslation == TCL_TRANSLATE_CRLF) {
                Tcl_DStringAppendElement(dsPtr, "crlf");
            } else {
                Tcl_DStringAppendElement(dsPtr, "lf");
            }
        }
        if (flags & TCL_WRITABLE) {
            if (statePtr->outputTranslation == TCL_TRANSLATE_AUTO) {
                Tcl_DStringAppendElement(dsPtr, "auto");
            } else if (statePtr->outputTranslation == TCL_TRANSLATE_CR) {
                Tcl_DStringAppendElement(dsPtr, "cr");
            } else if (statePtr->outputTranslation == TCL_TRANSLATE_CRLF) {
                Tcl_DStringAppendElement(dsPtr, "crlf");
            } else {
                Tcl_DStringAppendElement(dsPtr, "lf");
            }
        }
        if ( !(flags & (TCL_READABLE|TCL_WRITABLE))) {
            /* Not readable or writable (server socket) */
            Tcl_DStringAppendElement(dsPtr, "auto");
        }
        if (((flags & (TCL_READABLE|TCL_WRITABLE)) ==
                (TCL_READABLE|TCL_WRITABLE)) && (len == 0)) {
            Tcl_DStringEndSublist(dsPtr);
        }
        if (len > 0) {
            return TCL_OK;
        }
    }
    if (chanPtr->typePtr->getOptionProc != (Tcl_DriverGetOptionProc *) NULL) {
	/*
	 * let the driver specific handle additional options
	 * and result code and message.
	 */

        return (chanPtr->typePtr->getOptionProc) (chanPtr->instanceData,
		interp, optionName, dsPtr);
    } else {
	/*
	 * no driver specific options case.
	 */

        if (len == 0) {
            return TCL_OK;
        }
	return Tcl_BadChannelOption(interp, optionName, NULL);
    }
}

/*
 *---------------------------------------------------------------------------
 *
 * Tcl_SetChannelOption --
 *
 *	Sets an option on a channel.
 *
 * Results:
 *	A standard Tcl result.  On error, sets interp's result object
 *	if interp is not NULL.
 *
 * Side effects:
 *	May modify an option on a device.
 *
 *---------------------------------------------------------------------------
 */

int
Tcl_SetChannelOption(interp, chan, optionName, newValue)
    Tcl_Interp *interp;		/* For error reporting - can be NULL. */
    Tcl_Channel chan;		/* Channel on which to set mode. */
    CONST char *optionName;	/* Which option to set? */
    CONST char *newValue;	/* New value for option. */
{
    Channel *chanPtr = (Channel *) chan;	/* The real IO channel. */
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    size_t len;			/* Length of optionName string. */
    int argc;
    CONST char **argv;

    /*
     * If the channel is in the middle of a background copy, fail.
     */

    if (statePtr->csPtr) {
	if (interp) {
	    Tcl_AppendResult(interp,
		    "unable to set channel options: background copy in progress",
		    (char *) NULL);
	}
        return TCL_ERROR;
    }

    /*
     * Disallow options on dead channels -- channels that have been closed but
     * not yet been deallocated. Such channels can be found if the exit
     * handler for channel cleanup has run but the channel is still
     * registered in an interpreter.
     */

    if (CheckForDeadChannel(NULL, statePtr)) {
	return TCL_ERROR;
    }

    /*
     * This operation should occur at the top of a channel stack.
     */

    chanPtr = statePtr->topChanPtr;

    len = strlen(optionName);

    if ((len > 2) && (optionName[1] == 'b') &&
            (strncmp(optionName, "-blocking", len) == 0)) {
	int newMode;
        if (Tcl_GetBoolean(interp, newValue, &newMode) == TCL_ERROR) {
            return TCL_ERROR;
        }
        if (newMode) {
            newMode = TCL_MODE_BLOCKING;
        } else {
            newMode = TCL_MODE_NONBLOCKING;
        }
	return SetBlockMode(interp, chanPtr, newMode);
    } else if ((len > 7) && (optionName[1] == 'b') &&
            (strncmp(optionName, "-buffering", len) == 0)) {
        len = strlen(newValue);
        if ((newValue[0] == 'f') && (strncmp(newValue, "full", len) == 0)) {
            statePtr->flags &=
                (~(CHANNEL_UNBUFFERED|CHANNEL_LINEBUFFERED));
        } else if ((newValue[0] == 'l') &&
                (strncmp(newValue, "line", len) == 0)) {
            statePtr->flags &= (~(CHANNEL_UNBUFFERED));
            statePtr->flags |= CHANNEL_LINEBUFFERED;
        } else if ((newValue[0] == 'n') &&
                (strncmp(newValue, "none", len) == 0)) {
            statePtr->flags &= (~(CHANNEL_LINEBUFFERED));
            statePtr->flags |= CHANNEL_UNBUFFERED;
        } else {
            if (interp) {
                Tcl_AppendResult(interp, "bad value for -buffering: ",
                        "must be one of full, line, or none",
                        (char *) NULL);
                return TCL_ERROR;
            }
        }
	return TCL_OK;
    } else if ((len > 7) && (optionName[1] == 'b') &&
            (strncmp(optionName, "-buffersize", len) == 0)) {
        statePtr->bufSize = atoi(newValue);	/* INTL: "C", UTF safe. */
        if ((statePtr->bufSize < 10) || (statePtr->bufSize > (1024 * 1024))) {
            statePtr->bufSize = CHANNELBUFFER_DEFAULT_SIZE;
        }
    } else if ((len > 2) && (optionName[1] == 'e') &&
	    (strncmp(optionName, "-encoding", len) == 0)) {
	Tcl_Encoding encoding;

	if ((newValue[0] == '\0') || (strcmp(newValue, "binary") == 0)) {
	    encoding = NULL;
	} else {
	    encoding = Tcl_GetEncoding(interp, newValue);
	    if (encoding == NULL) {
		return TCL_ERROR;
	    }
	}
	/*
	 * When the channel has an escape sequence driven encoding such as
	 * iso2022, the terminated escape sequence must write to the buffer.
	 */
	if ((statePtr->encoding != NULL) && (statePtr->curOutPtr != NULL)
		&& (CheckChannelErrors(statePtr, TCL_WRITABLE) == 0)) {
	    statePtr->outputEncodingFlags |= TCL_ENCODING_END;
	    WriteChars(chanPtr, "", 0);
	}
	Tcl_FreeEncoding(statePtr->encoding);
	statePtr->encoding = encoding;
	statePtr->inputEncodingState = NULL;
	statePtr->inputEncodingFlags = TCL_ENCODING_START;
	statePtr->outputEncodingState = NULL;
	statePtr->outputEncodingFlags = TCL_ENCODING_START;
	statePtr->flags &= ~CHANNEL_NEED_MORE_DATA;
	UpdateInterest(chanPtr);
    } else if ((len > 2) && (optionName[1] == 'e') &&
            (strncmp(optionName, "-eofchar", len) == 0)) {
        if (Tcl_SplitList(interp, newValue, &argc, &argv) == TCL_ERROR) {
            return TCL_ERROR;
        }
        if (argc == 0) {
            statePtr->inEofChar = 0;
            statePtr->outEofChar = 0;
        } else if (argc == 1) {
            if (statePtr->flags & TCL_WRITABLE) {
                statePtr->outEofChar = (int) argv[0][0];
            }
            if (statePtr->flags & TCL_READABLE) {
                statePtr->inEofChar = (int) argv[0][0];
            }
        } else if (argc != 2) {
            if (interp) {
                Tcl_AppendResult(interp,
                        "bad value for -eofchar: should be a list of zero,",
                        " one, or two elements", (char *) NULL);
            }
            ckfree((char *) argv);
            return TCL_ERROR;
        } else {
            if (statePtr->flags & TCL_READABLE) {
                statePtr->inEofChar = (int) argv[0][0];
            }
            if (statePtr->flags & TCL_WRITABLE) {
                statePtr->outEofChar = (int) argv[1][0];
            }
        }
        if (argv != NULL) {
            ckfree((char *) argv);
        }
	return TCL_OK;
    } else if ((len > 1) && (optionName[1] == 't') &&
            (strncmp(optionName, "-translation", len) == 0)) {
	CONST char *readMode, *writeMode;

        if (Tcl_SplitList(interp, newValue, &argc, &argv) == TCL_ERROR) {
            return TCL_ERROR;
        }

        if (argc == 1) {
	    readMode = (statePtr->flags & TCL_READABLE) ? argv[0] : NULL;
	    writeMode = (statePtr->flags & TCL_WRITABLE) ? argv[0] : NULL;
	} else if (argc == 2) {
	    readMode = (statePtr->flags & TCL_READABLE) ? argv[0] : NULL;
	    writeMode = (statePtr->flags & TCL_WRITABLE) ? argv[1] : NULL;
	} else {
            if (interp) {
                Tcl_AppendResult(interp,
                        "bad value for -translation: must be a one or two",
                        " element list", (char *) NULL);
            }
            ckfree((char *) argv);
            return TCL_ERROR;
	}

	if (readMode) {
	    TclEolTranslation translation;
	    if (*readMode == '\0') {
		translation = statePtr->inputTranslation;
	    } else if (strcmp(readMode, "auto") == 0) {
		translation = TCL_TRANSLATE_AUTO;
	    } else if (strcmp(readMode, "binary") == 0) {
		translation = TCL_TRANSLATE_LF;
		statePtr->inEofChar = 0;
		Tcl_FreeEncoding(statePtr->encoding);		    
		statePtr->encoding = NULL;
	    } else if (strcmp(readMode, "lf") == 0) {
		translation = TCL_TRANSLATE_LF;
	    } else if (strcmp(readMode, "cr") == 0) {
		translation = TCL_TRANSLATE_CR;
	    } else if (strcmp(readMode, "crlf") == 0) {
		translation = TCL_TRANSLATE_CRLF;
	    } else if (strcmp(readMode, "platform") == 0) {
		translation = TCL_PLATFORM_TRANSLATION;
	    } else {
		if (interp) {
		    Tcl_AppendResult(interp,
			    "bad value for -translation: ",
			    "must be one of auto, binary, cr, lf, crlf,",
			    " or platform", (char *) NULL);
		}
		ckfree((char *) argv);
		return TCL_ERROR;
	    }

	    /*
	     * Reset the EOL flags since we need to look at any buffered
	     * data to see if the new translation mode allows us to
	     * complete the line.
	     */

	    if (translation != statePtr->inputTranslation) {
		statePtr->inputTranslation = translation;
		statePtr->flags &= ~(INPUT_SAW_CR);
		statePtr->flags &= ~(CHANNEL_NEED_MORE_DATA);
		UpdateInterest(chanPtr);
	    }
	}
	if (writeMode) {
	    if (*writeMode == '\0') {
		/* Do nothing. */
	    } else if (strcmp(writeMode, "auto") == 0) {
		/*
		 * This is a hack to get TCP sockets to produce output
		 * in CRLF mode if they are being set into AUTO mode.
		 * A better solution for achieving this effect will be
		 * coded later.
		 */

		if (strcmp(Tcl_ChannelName(chanPtr->typePtr), "tcp") == 0) {
		    statePtr->outputTranslation = TCL_TRANSLATE_CRLF;
		} else {
		    statePtr->outputTranslation = TCL_PLATFORM_TRANSLATION;
		}
	    } else if (strcmp(writeMode, "binary") == 0) {
		statePtr->outEofChar = 0;
		statePtr->outputTranslation = TCL_TRANSLATE_LF;
		Tcl_FreeEncoding(statePtr->encoding);		    
		statePtr->encoding = NULL;
	    } else if (strcmp(writeMode, "lf") == 0) {
		statePtr->outputTranslation = TCL_TRANSLATE_LF;
	    } else if (strcmp(writeMode, "cr") == 0) {
		statePtr->outputTranslation = TCL_TRANSLATE_CR;
	    } else if (strcmp(writeMode, "crlf") == 0) {
		statePtr->outputTranslation = TCL_TRANSLATE_CRLF;
	    } else if (strcmp(writeMode, "platform") == 0) {
		statePtr->outputTranslation = TCL_PLATFORM_TRANSLATION;
	    } else {
		if (interp) {
		    Tcl_AppendResult(interp,
			    "bad value for -translation: ",
			    "must be one of auto, binary, cr, lf, crlf,",
			    " or platform", (char *) NULL);
		}
		ckfree((char *) argv);
		return TCL_ERROR;
	    }
	}
        ckfree((char *) argv);            
        return TCL_OK;
    } else if (chanPtr->typePtr->setOptionProc != NULL) {
        return (*chanPtr->typePtr->setOptionProc)(chanPtr->instanceData,
                interp, optionName, newValue);
    } else {
	return Tcl_BadChannelOption(interp, optionName, (char *) NULL);
    }

    /*
     * If bufsize changes, need to get rid of old utility buffer.
     */

    if (statePtr->saveInBufPtr != NULL) {
	RecycleBuffer(statePtr, statePtr->saveInBufPtr, 1);
	statePtr->saveInBufPtr = NULL;
    }
    if (statePtr->inQueueHead != NULL) {
	if ((statePtr->inQueueHead->nextPtr == NULL)
		&& (statePtr->inQueueHead->nextAdded ==
			statePtr->inQueueHead->nextRemoved)) {
	    RecycleBuffer(statePtr, statePtr->inQueueHead, 1);
	    statePtr->inQueueHead = NULL;
	    statePtr->inQueueTail = NULL;
	}
    }

    /*
     * If encoding or bufsize changes, need to update output staging buffer.
     */

    if (statePtr->outputStage != NULL) {
	ckfree((char *) statePtr->outputStage);
	statePtr->outputStage = NULL;
    }
    if ((statePtr->encoding != NULL) && (statePtr->flags & TCL_WRITABLE)) {
	statePtr->outputStage = (char *) 
	    ckalloc((unsigned) (statePtr->bufSize + 2));
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * CleanupChannelHandlers --
 *
 *	Removes channel handlers that refer to the supplied interpreter,
 *	so that if the actual channel is not closed now, these handlers
 *	will not run on subsequent events on the channel. This would be
 *	erroneous, because the interpreter no longer has a reference to
 *	this channel.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Removes channel handlers.
 *
 *----------------------------------------------------------------------
 */

static void
CleanupChannelHandlers(interp, chanPtr)
    Tcl_Interp *interp;
    Channel *chanPtr;
{
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    EventScriptRecord *sPtr, *prevPtr, *nextPtr;

    /*
     * Remove fileevent records on this channel that refer to the
     * given interpreter.
     */
    
    for (sPtr = statePtr->scriptRecordPtr,
             prevPtr = (EventScriptRecord *) NULL;
	 sPtr != (EventScriptRecord *) NULL;
	 sPtr = nextPtr) {
        nextPtr = sPtr->nextPtr;
        if (sPtr->interp == interp) {
            if (prevPtr == (EventScriptRecord *) NULL) {
                statePtr->scriptRecordPtr = nextPtr;
            } else {
                prevPtr->nextPtr = nextPtr;
            }

            Tcl_DeleteChannelHandler((Tcl_Channel) chanPtr,
                    TclChannelEventScriptInvoker, (ClientData) sPtr);

	    Tcl_DecrRefCount(sPtr->scriptPtr);
            ckfree((char *) sPtr);
        } else {
            prevPtr = sPtr;
        }
    }
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_NotifyChannel --
 *
 *	This procedure is called by a channel driver when a driver
 *	detects an event on a channel.  This procedure is responsible
 *	for actually handling the event by invoking any channel
 *	handler callbacks.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Whatever the channel handler callback procedure does.
 *
 *----------------------------------------------------------------------
 */

void
Tcl_NotifyChannel(channel, mask)
    Tcl_Channel channel;	/* Channel that detected an event. */
    int mask;			/* OR'ed combination of TCL_READABLE,
				 * TCL_WRITABLE, or TCL_EXCEPTION: indicates
				 * which events were detected. */
{
    Channel *chanPtr = (Channel *) channel;
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    ChannelHandler *chPtr;
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    NextChannelHandler nh;
    Channel* upChanPtr;
    Tcl_ChannelType* upTypePtr;

    /*
     * In contrast to the other API functions this procedure walks towards
     * the top of a stack and not down from it.
     *
     * The channel calling this procedure is the one who generated the event,
     * and thus does not take part in handling it. IOW, its HandlerProc is
     * not called, instead we begin with the channel above it.
     *
     * This behaviour also allows the transformation channels to
     * generate their own events and pass them upward.
     */

    while (mask && (chanPtr->upChanPtr != ((Channel*) NULL))) {
	Tcl_DriverHandlerProc* upHandlerProc;

        upChanPtr = chanPtr->upChanPtr;
	upTypePtr = upChanPtr->typePtr;
	upHandlerProc = Tcl_ChannelHandlerProc(upTypePtr);
	if (upHandlerProc != NULL) {
	    mask = (*upHandlerProc) (upChanPtr->instanceData, mask);
	}

	/* ELSE:
	 * Ignore transformations which are unable to handle the event
	 * coming from below. Assume that they don't change the mask and
	 * pass it on.
	 */

	chanPtr = upChanPtr;
    }

    channel = (Tcl_Channel) chanPtr;

    /*
     * Here we have either reached the top of the stack or the mask is
     * empty.  We break out of the procedure if it is the latter.
     */

    if (!mask) {
        return;
    }

    /*
     * We are now above the topmost channel in a stack and have events
     * left. Now call the channel handlers as usual.
     *
     * Preserve the channel struct in case the script closes it.
     */
     
    Tcl_Preserve((ClientData) channel);
    Tcl_Preserve((ClientData) statePtr);

    /*
     * If we are flushing in the background, be sure to call FlushChannel
     * for writable events.  Note that we have to discard the writable
     * event so we don't call any write handlers before the flush is
     * complete.
     */

    if ((statePtr->flags & BG_FLUSH_SCHEDULED) && (mask & TCL_WRITABLE)) {
	FlushChannel(NULL, chanPtr, 1);
	mask &= ~TCL_WRITABLE;
    }

    /*
     * Add this invocation to the list of recursive invocations of
     * ChannelHandlerEventProc.
     */
    
    nh.nextHandlerPtr = (ChannelHandler *) NULL;
    nh.nestedHandlerPtr = tsdPtr->nestedHandlerPtr;
    tsdPtr->nestedHandlerPtr = &nh;

    for (chPtr = statePtr->chPtr; chPtr != (ChannelHandler *) NULL; ) {
	/*
	 * If this channel handler is interested in any of the events that
	 * have occurred on the channel, invoke its procedure.
	 */

	if ((chPtr->mask & mask) != 0) {
	    nh.nextHandlerPtr = chPtr->nextPtr;
	    (*(chPtr->proc))(chPtr->clientData, mask);
	    chPtr = nh.nextHandlerPtr;
	} else {
	    chPtr = chPtr->nextPtr;
	}
    }

    /*
     * Update the notifier interest, since it may have changed after
     * invoking event handlers. Skip that if the channel was deleted
     * in the call to the channel handler.
     */

    if (chanPtr->typePtr != NULL) {
        UpdateInterest(chanPtr);
    }

    Tcl_Release((ClientData) statePtr);
    Tcl_Release((ClientData) channel);

    tsdPtr->nestedHandlerPtr = nh.nestedHandlerPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * UpdateInterest --
 *
 *	Arrange for the notifier to call us back at appropriate times
 *	based on the current state of the channel.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	May schedule a timer or driver handler.
 *
 *----------------------------------------------------------------------
 */

static void
UpdateInterest(chanPtr)
    Channel *chanPtr;		/* Channel to update. */
{
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    int mask = statePtr->interestMask;

    /*
     * If there are flushed buffers waiting to be written, then
     * we need to watch for the channel to become writable.
     */

    if (statePtr->flags & BG_FLUSH_SCHEDULED) {
	mask |= TCL_WRITABLE;
    }

    /*
     * If there is data in the input queue, and we aren't waiting for more
     * data, then we need to schedule a timer so we don't block in the
     * notifier.  Also, cancel the read interest so we don't get duplicate
     * events.
     */

    if (mask & TCL_READABLE) {
	if (!(statePtr->flags & CHANNEL_NEED_MORE_DATA)
		&& (statePtr->inQueueHead != (ChannelBuffer *) NULL)
		&& (statePtr->inQueueHead->nextRemoved <
			statePtr->inQueueHead->nextAdded)) {
	    mask &= ~TCL_READABLE;
	    if (!statePtr->timer) {
		statePtr->timer = Tcl_CreateTimerHandler(0, ChannelTimerProc,
			(ClientData) chanPtr);
	    }
	}
    }
    (chanPtr->typePtr->watchProc)(chanPtr->instanceData, mask);
}

/*
 *----------------------------------------------------------------------
 *
 * ChannelTimerProc --
 *
 *	Timer handler scheduled by UpdateInterest to monitor the
 *	channel buffers until they are empty.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	May invoke channel handlers.
 *
 *----------------------------------------------------------------------
 */

static void
ChannelTimerProc(clientData)
    ClientData clientData;
{
    Channel *chanPtr = (Channel *) clientData;
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */

    if (!(statePtr->flags & CHANNEL_NEED_MORE_DATA)
	    && (statePtr->interestMask & TCL_READABLE)
	    && (statePtr->inQueueHead != (ChannelBuffer *) NULL)
	    && (statePtr->inQueueHead->nextRemoved <
		    statePtr->inQueueHead->nextAdded)) {
	/*
	 * Restart the timer in case a channel handler reenters the
	 * event loop before UpdateInterest gets called by Tcl_NotifyChannel.
	 */

	statePtr->timer = Tcl_CreateTimerHandler(0, ChannelTimerProc,
		(ClientData) chanPtr);

	/* Set the TIMER flag to notify the higher levels that the
	 * driver might have no data for us. We do this only if we are
	 * in non-blocking mode and the driver has no BlockModeProc
	 * because only then we really don't know if the driver will
	 * block or not. A similar test is done in "PeekAhead".
	 */

	if ((statePtr->flags & CHANNEL_NONBLOCKING) &&
	    (Tcl_ChannelBlockModeProc(chanPtr->typePtr) == NULL)) {
	    statePtr->flags |= CHANNEL_TIMER_FEV;
	}
	Tcl_Preserve((ClientData) statePtr);
	Tcl_NotifyChannel((Tcl_Channel)chanPtr, TCL_READABLE);

	statePtr->flags &= ~CHANNEL_TIMER_FEV; 
	Tcl_Release((ClientData) statePtr);
    } else {
	statePtr->timer = NULL;
	UpdateInterest(chanPtr);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_CreateChannelHandler --
 *
 *	Arrange for a given procedure to be invoked whenever the
 *	channel indicated by the chanPtr arg becomes readable or
 *	writable.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	From now on, whenever the I/O channel given by chanPtr becomes
 *	ready in the way indicated by mask, proc will be invoked.
 *	See the manual entry for details on the calling sequence
 *	to proc.  If there is already an event handler for chan, proc
 *	and clientData, then the mask will be updated.
 *
 *----------------------------------------------------------------------
 */

void
Tcl_CreateChannelHandler(chan, mask, proc, clientData)
    Tcl_Channel chan;		/* The channel to create the handler for. */
    int mask;			/* OR'ed combination of TCL_READABLE,
				 * TCL_WRITABLE, and TCL_EXCEPTION:
				 * indicates conditions under which
				 * proc should be called. Use 0 to
                                 * disable a registered handler. */
    Tcl_ChannelProc *proc;	/* Procedure to call for each
				 * selected event. */
    ClientData clientData;	/* Arbitrary data to pass to proc. */
{
    ChannelHandler *chPtr;
    Channel *chanPtr = (Channel *) chan;
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */

    /*
     * Check whether this channel handler is not already registered. If
     * it is not, create a new record, else reuse existing record (smash
     * current values).
     */

    for (chPtr = statePtr->chPtr;
	 chPtr != (ChannelHandler *) NULL;
	 chPtr = chPtr->nextPtr) {
        if ((chPtr->chanPtr == chanPtr) && (chPtr->proc == proc) &&
                (chPtr->clientData == clientData)) {
            break;
        }
    }
    if (chPtr == (ChannelHandler *) NULL) {
        chPtr = (ChannelHandler *) ckalloc((unsigned) sizeof(ChannelHandler));
        chPtr->mask = 0;
        chPtr->proc = proc;
        chPtr->clientData = clientData;
        chPtr->chanPtr = chanPtr;
        chPtr->nextPtr = statePtr->chPtr;
        statePtr->chPtr = chPtr;
    }

    /*
     * The remainder of the initialization below is done regardless of
     * whether or not this is a new record or a modification of an old
     * one.
     */

    chPtr->mask = mask;

    /*
     * Recompute the interest mask for the channel - this call may actually
     * be disabling an existing handler.
     */
    
    statePtr->interestMask = 0;
    for (chPtr = statePtr->chPtr;
	 chPtr != (ChannelHandler *) NULL;
	 chPtr = chPtr->nextPtr) {
	statePtr->interestMask |= chPtr->mask;
    }

    UpdateInterest(statePtr->topChanPtr);
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_DeleteChannelHandler --
 *
 *	Cancel a previously arranged callback arrangement for an IO
 *	channel.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	If a callback was previously registered for this chan, proc and
 *	 clientData , it is removed and the callback will no longer be called
 *	when the channel becomes ready for IO.
 *
 *----------------------------------------------------------------------
 */

void
Tcl_DeleteChannelHandler(chan, proc, clientData)
    Tcl_Channel chan;		/* The channel for which to remove the
                                 * callback. */
    Tcl_ChannelProc *proc;	/* The procedure in the callback to delete. */
    ClientData clientData;	/* The client data in the callback
                                 * to delete. */
    
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    ChannelHandler *chPtr, *prevChPtr;
    Channel *chanPtr = (Channel *) chan;
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    NextChannelHandler *nhPtr;

    /*
     * Find the entry and the previous one in the list.
     */

    for (prevChPtr = (ChannelHandler *) NULL, chPtr = statePtr->chPtr;
	 chPtr != (ChannelHandler *) NULL;
	 chPtr = chPtr->nextPtr) {
        if ((chPtr->chanPtr == chanPtr) && (chPtr->clientData == clientData)
                && (chPtr->proc == proc)) {
            break;
        }
        prevChPtr = chPtr;
    }

    /*
     * If not found, return without doing anything.
     */

    if (chPtr == (ChannelHandler *) NULL) {
        return;
    }

    /*
     * If ChannelHandlerEventProc is about to process this handler, tell it to
     * process the next one instead - we are going to delete *this* one.
     */

    for (nhPtr = tsdPtr->nestedHandlerPtr;
	 nhPtr != (NextChannelHandler *) NULL;
	 nhPtr = nhPtr->nestedHandlerPtr) {
        if (nhPtr->nextHandlerPtr == chPtr) {
            nhPtr->nextHandlerPtr = chPtr->nextPtr;
        }
    }

    /*
     * Splice it out of the list of channel handlers.
     */
    
    if (prevChPtr == (ChannelHandler *) NULL) {
        statePtr->chPtr = chPtr->nextPtr;
    } else {
        prevChPtr->nextPtr = chPtr->nextPtr;
    }
    ckfree((char *) chPtr);

    /*
     * Recompute the interest list for the channel, so that infinite loops
     * will not result if Tcl_DeleteChannelHandler is called inside an
     * event.
     */

    statePtr->interestMask = 0;
    for (chPtr = statePtr->chPtr;
	 chPtr != (ChannelHandler *) NULL;
	 chPtr = chPtr->nextPtr) {
        statePtr->interestMask |= chPtr->mask;
    }

    UpdateInterest(statePtr->topChanPtr);
}

/*
 *----------------------------------------------------------------------
 *
 * DeleteScriptRecord --
 *
 *	Delete a script record for this combination of channel, interp
 *	and mask.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Deletes a script record and cancels a channel event handler.
 *
 *----------------------------------------------------------------------
 */

static void
DeleteScriptRecord(interp, chanPtr, mask)
    Tcl_Interp *interp;		/* Interpreter in which script was to be
                                 * executed. */
    Channel *chanPtr;		/* The channel for which to delete the
                                 * script record (if any). */
    int mask;			/* Events in mask must exactly match mask
                                 * of script to delete. */
{
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    EventScriptRecord *esPtr, *prevEsPtr;

    for (esPtr = statePtr->scriptRecordPtr,
             prevEsPtr = (EventScriptRecord *) NULL;
	 esPtr != (EventScriptRecord *) NULL;
	 prevEsPtr = esPtr, esPtr = esPtr->nextPtr) {
        if ((esPtr->interp == interp) && (esPtr->mask == mask)) {
            if (esPtr == statePtr->scriptRecordPtr) {
                statePtr->scriptRecordPtr = esPtr->nextPtr;
            } else {
                prevEsPtr->nextPtr = esPtr->nextPtr;
            }

            Tcl_DeleteChannelHandler((Tcl_Channel) chanPtr,
                    TclChannelEventScriptInvoker, (ClientData) esPtr);
            
	    Tcl_DecrRefCount(esPtr->scriptPtr);
            ckfree((char *) esPtr);

            break;
        }
    }
}

/*
 *----------------------------------------------------------------------
 *
 * CreateScriptRecord --
 *
 *	Creates a record to store a script to be executed when a specific
 *	event fires on a specific channel.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Causes the script to be stored for later execution.
 *
 *----------------------------------------------------------------------
 */

static void
CreateScriptRecord(interp, chanPtr, mask, scriptPtr)
    Tcl_Interp *interp;			/* Interpreter in which to execute
                                         * the stored script. */
    Channel *chanPtr;			/* Channel for which script is to
                                         * be stored. */
    int mask;				/* Set of events for which script
                                         * will be invoked. */
    Tcl_Obj *scriptPtr;			/* Pointer to script object. */
{
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    EventScriptRecord *esPtr;

    for (esPtr = statePtr->scriptRecordPtr;
	 esPtr != (EventScriptRecord *) NULL;
	 esPtr = esPtr->nextPtr) {
        if ((esPtr->interp == interp) && (esPtr->mask == mask)) {
	    Tcl_DecrRefCount(esPtr->scriptPtr);
	    esPtr->scriptPtr = (Tcl_Obj *) NULL;
            break;
        }
    }
    if (esPtr == (EventScriptRecord *) NULL) {
        esPtr = (EventScriptRecord *) ckalloc((unsigned)
                sizeof(EventScriptRecord));
        Tcl_CreateChannelHandler((Tcl_Channel) chanPtr, mask,
                TclChannelEventScriptInvoker, (ClientData) esPtr);
        esPtr->nextPtr = statePtr->scriptRecordPtr;
        statePtr->scriptRecordPtr = esPtr;
    }
    esPtr->chanPtr = chanPtr;
    esPtr->interp = interp;
    esPtr->mask = mask;
    Tcl_IncrRefCount(scriptPtr);
    esPtr->scriptPtr = scriptPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * TclChannelEventScriptInvoker --
 *
 *	Invokes a script scheduled by "fileevent" for when the channel
 *	becomes ready for IO. This function is invoked by the channel
 *	handler which was created by the Tcl "fileevent" command.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Whatever the script does.
 *
 *----------------------------------------------------------------------
 */

void
TclChannelEventScriptInvoker(clientData, mask)
    ClientData clientData;	/* The script+interp record. */
    int mask;			/* Not used. */
{
    Tcl_Interp *interp;		/* Interpreter in which to eval the script. */
    Channel *chanPtr;		/* The channel for which this handler is
                                 * registered. */
    EventScriptRecord *esPtr;	/* The event script + interpreter to eval it
                                 * in. */
    int result;			/* Result of call to eval script. */

    esPtr	= (EventScriptRecord *) clientData;
    chanPtr	= esPtr->chanPtr;
    mask	= esPtr->mask;
    interp	= esPtr->interp;

    /*
     * We must preserve the interpreter so we can report errors on it
     * later.  Note that we do not need to preserve the channel because
     * that is done by Tcl_NotifyChannel before calling channel handlers.
     */
    
    Tcl_Preserve((ClientData) interp);
    result = Tcl_EvalObjEx(interp, esPtr->scriptPtr, TCL_EVAL_GLOBAL);

    /*
     * On error, cause a background error and remove the channel handler
     * and the script record.
     *
     * NOTE: Must delete channel handler before causing the background error
     * because the background error may want to reinstall the handler.
     */
    
    if (result != TCL_OK) {
	if (chanPtr->typePtr != NULL) {
	    DeleteScriptRecord(interp, chanPtr, mask);
	}
        Tcl_BackgroundError(interp);
    }
    Tcl_Release((ClientData) interp);
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_FileEventObjCmd --
 *
 *	This procedure implements the "fileevent" Tcl command. See the
 *	user documentation for details on what it does. This command is
 *	based on the Tk command "fileevent" which in turn is based on work
 *	contributed by Mark Diekhans.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	May create a channel handler for the specified channel.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
int
Tcl_FileEventObjCmd(clientData, interp, objc, objv)
    ClientData clientData;		/* Not used. */
    Tcl_Interp *interp;			/* Interpreter in which the channel
                                         * for which to create the handler
                                         * is found. */
    int objc;				/* Number of arguments. */
    Tcl_Obj *CONST objv[];		/* Argument objects. */
{
    Channel *chanPtr;			/* The channel to create
                                         * the handler for. */
    ChannelState *statePtr;		/* state info for channel */
    Tcl_Channel chan;			/* The opaque type for the channel. */
    char *chanName;
    int modeIndex;			/* Index of mode argument. */
    int mask;
    static CONST char *modeOptions[] = {"readable", "writable", NULL};
    static int maskArray[] = {TCL_READABLE, TCL_WRITABLE};

    if ((objc != 3) && (objc != 4)) {
	Tcl_WrongNumArgs(interp, 1, objv, "channelId event ?script?");
	return TCL_ERROR;
    }
    if (Tcl_GetIndexFromObj(interp, objv[2], modeOptions, "event name", 0,
	    &modeIndex) != TCL_OK) {
	return TCL_ERROR;
    }
    mask = maskArray[modeIndex];

    chanName = Tcl_GetString(objv[1]);
    chan = Tcl_GetChannel(interp, chanName, NULL);
    if (chan == (Tcl_Channel) NULL) {
	return TCL_ERROR;
    }
    chanPtr  = (Channel *) chan;
    statePtr = chanPtr->state;
    if ((statePtr->flags & mask) == 0) {
        Tcl_AppendResult(interp, "channel is not ",
                (mask == TCL_READABLE) ? "readable" : "writable",
                (char *) NULL);
        return TCL_ERROR;
    }
    
    /*
     * If we are supposed to return the script, do so.
     */

    if (objc == 3) {
	EventScriptRecord *esPtr;
	for (esPtr = statePtr->scriptRecordPtr;
             esPtr != (EventScriptRecord *) NULL;
             esPtr = esPtr->nextPtr) {
	    if ((esPtr->interp == interp) && (esPtr->mask == mask)) {
		Tcl_SetObjResult(interp, esPtr->scriptPtr);
		break;
	    }
	}
        return TCL_OK;
    }

    /*
     * If we are supposed to delete a stored script, do so.
     */

    if (*(Tcl_GetString(objv[3])) == '\0') {
        DeleteScriptRecord(interp, chanPtr, mask);
        return TCL_OK;
    }

    /*
     * Make the script record that will link between the event and the
     * script to invoke. This also creates a channel event handler which
     * will evaluate the script in the supplied interpreter.
     */

    CreateScriptRecord(interp, chanPtr, mask, objv[3]);
    
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * TclCopyChannel --
 *
 *	This routine copies data from one channel to another, either
 *	synchronously or asynchronously.  If a command script is
 *	supplied, the operation runs in the background.  The script
 *	is invoked when the copy completes.  Otherwise the function
 *	waits until the copy is completed before returning.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	May schedule a background copy operation that causes both
 *	channels to be marked busy.
 *
 *----------------------------------------------------------------------
 */

int
TclCopyChannel(interp, inChan, outChan, toRead, cmdPtr)
    Tcl_Interp *interp;		/* Current interpreter. */
    Tcl_Channel inChan;		/* Channel to read from. */
    Tcl_Channel outChan;	/* Channel to write to. */
    int toRead;			/* Amount of data to copy, or -1 for all. */
    Tcl_Obj *cmdPtr;		/* Pointer to script to execute or NULL. */
{
    Channel *inPtr = (Channel *) inChan;
    Channel *outPtr = (Channel *) outChan;
    ChannelState *inStatePtr, *outStatePtr;
    int readFlags, writeFlags;
    CopyState *csPtr;
    int nonBlocking = (cmdPtr) ? CHANNEL_NONBLOCKING : 0;

    inStatePtr	= inPtr->state;
    outStatePtr	= outPtr->state;

    if (inStatePtr->csPtr) {
	Tcl_AppendStringsToObj(Tcl_GetObjResult(interp), "channel \"",
		Tcl_GetChannelName(inChan), "\" is busy", NULL);
	return TCL_ERROR;
    }
    if (outStatePtr->csPtr) {
	Tcl_AppendStringsToObj(Tcl_GetObjResult(interp), "channel \"",
		Tcl_GetChannelName(outChan), "\" is busy", NULL);
	return TCL_ERROR;
    }

    readFlags	= inStatePtr->flags;
    writeFlags	= outStatePtr->flags;

    /*
     * Set up the blocking mode appropriately.  Background copies need
     * non-blocking channels.  Foreground copies need blocking channels.
     * If there is an error, restore the old blocking mode.
     */

    if (nonBlocking != (readFlags & CHANNEL_NONBLOCKING)) {
	if (SetBlockMode(interp, inPtr,
		nonBlocking ? TCL_MODE_NONBLOCKING : TCL_MODE_BLOCKING)
		!= TCL_OK) {
	    return TCL_ERROR;
	}
    }	    
    if (inPtr != outPtr) {
	if (nonBlocking != (writeFlags & CHANNEL_NONBLOCKING)) {
	    if (SetBlockMode(NULL, outPtr,
		    nonBlocking ? TCL_MODE_NONBLOCKING : TCL_MODE_BLOCKING)
		    != TCL_OK) {
		if (nonBlocking != (readFlags & CHANNEL_NONBLOCKING)) {
		    SetBlockMode(NULL, inPtr,
			    (readFlags & CHANNEL_NONBLOCKING)
			    ? TCL_MODE_NONBLOCKING : TCL_MODE_BLOCKING);
		    return TCL_ERROR;
		}
	    }
	}
    }

    /*
     * Make sure the output side is unbuffered.
     */

    outStatePtr->flags = (outStatePtr->flags & ~(CHANNEL_LINEBUFFERED))
	| CHANNEL_UNBUFFERED;

    /*
     * Allocate a new CopyState to maintain info about the current copy in
     * progress.  This structure will be deallocated when the copy is
     * completed.
     */

    csPtr = (CopyState*) ckalloc(sizeof(CopyState) + inStatePtr->bufSize);
    csPtr->bufSize    = inStatePtr->bufSize;
    csPtr->readPtr    = inPtr;
    csPtr->writePtr   = outPtr;
    csPtr->readFlags  = readFlags;
    csPtr->writeFlags = writeFlags;
    csPtr->toRead     = toRead;
    csPtr->total      = 0;
    csPtr->interp     = interp;
    if (cmdPtr) {
	Tcl_IncrRefCount(cmdPtr);
    }
    csPtr->cmdPtr = cmdPtr;
    inStatePtr->csPtr = csPtr;
    outStatePtr->csPtr = csPtr;

    /*
     * Start copying data between the channels.
     */

    return CopyData(csPtr, 0);
}

/*
 *----------------------------------------------------------------------
 *
 * CopyData --
 *
 *	This function implements the lowest level of the copying
 *	mechanism for TclCopyChannel.
 *
 * Results:
 *	Returns TCL_OK on success, else TCL_ERROR.
 *
 * Side effects:
 *	Moves data between channels, may create channel handlers.
 *
 *----------------------------------------------------------------------
 */

static int
CopyData(csPtr, mask)
    CopyState *csPtr;		/* State of copy operation. */
    int mask;			/* Current channel event flags. */
{
    Tcl_Interp *interp;
    Tcl_Obj *cmdPtr, *errObj = NULL, *bufObj = NULL;
    Tcl_Channel inChan, outChan;
    ChannelState *inStatePtr, *outStatePtr;
    int result = TCL_OK, size, total, sizeb;
    char* buffer;

    int inBinary, outBinary, sameEncoding; /* Encoding control */
    int underflow;	/* input underflow */

    inChan	= (Tcl_Channel) csPtr->readPtr;
    outChan	= (Tcl_Channel) csPtr->writePtr;
    inStatePtr	= csPtr->readPtr->state;
    outStatePtr	= csPtr->writePtr->state;
    interp	= csPtr->interp;
    cmdPtr	= csPtr->cmdPtr;

    /*
     * Copy the data the slow way, using the translation mechanism.
     *
     * Note: We have make sure that we use the topmost channel in a stack
     * for the copying. The caller uses Tcl_GetChannel to access it, and
     * thus gets the bottom of the stack.
     */

    inBinary     = (inStatePtr->encoding  == NULL);
    outBinary    = (outStatePtr->encoding == NULL);
    sameEncoding = (inStatePtr->encoding  == outStatePtr->encoding);

    if (!(inBinary || sameEncoding)) {
        bufObj = Tcl_NewObj ();
	Tcl_IncrRefCount (bufObj);
    }

    while (csPtr->toRead != 0) {
	/*
	 * Check for unreported background errors.
	 */

	if (inStatePtr->unreportedError != 0) {
	    Tcl_SetErrno(inStatePtr->unreportedError);
	    inStatePtr->unreportedError = 0;
	    goto readError;
	}
	if (outStatePtr->unreportedError != 0) {
	    Tcl_SetErrno(outStatePtr->unreportedError);
	    outStatePtr->unreportedError = 0;
	    goto writeError;
	}
	
	/*
	 * Read up to bufSize bytes.
	 */

	if ((csPtr->toRead == -1) || (csPtr->toRead > csPtr->bufSize)) {
	    sizeb = csPtr->bufSize;
	} else {
	    sizeb = csPtr->toRead;
	}

	if (inBinary || sameEncoding) {
	    size = DoRead(inStatePtr->topChanPtr, csPtr->buffer, sizeb);
	} else {
	    size = DoReadChars(inStatePtr->topChanPtr, bufObj, sizeb, 0 /* No append */);
	}
	underflow = (size >= 0) && (size < sizeb);	/* input underflow */

	if (size < 0) {
	    readError:
	    errObj = Tcl_NewObj();
	    Tcl_AppendStringsToObj(errObj, "error reading \"",
		    Tcl_GetChannelName(inChan), "\": ",
		    Tcl_PosixError(interp), (char *) NULL);
	    break;
	} else if (underflow) {
	    /*
	     * We had an underflow on the read side.  If we are at EOF,
	     * then the copying is done, otherwise set up a channel
	     * handler to detect when the channel becomes readable again.
	     */
	    
	    if ((size == 0) && Tcl_Eof(inChan)) {
		break;
	    }
	    if (! Tcl_Eof(inChan) && !(mask & TCL_READABLE)) {
		if (mask & TCL_WRITABLE) {
		    Tcl_DeleteChannelHandler(outChan, CopyEventProc,
			    (ClientData) csPtr);
		}
		Tcl_CreateChannelHandler(inChan, TCL_READABLE,
			CopyEventProc, (ClientData) csPtr);
	    }
	    if (size == 0) {
	        if (bufObj != (Tcl_Obj*) NULL) {
		    Tcl_DecrRefCount (bufObj);
		    bufObj = (Tcl_Obj*) NULL;
		}
		return TCL_OK;
	    }
	}

	/*
	 * Now write the buffer out.
	 */

	if (inBinary || sameEncoding) {
	    buffer = csPtr->buffer;
	    sizeb = size;
	} else {
	    buffer = Tcl_GetStringFromObj (bufObj, &sizeb);
	}

	if (outBinary || sameEncoding) {
	    sizeb = DoWrite(outStatePtr->topChanPtr, buffer, sizeb);
	} else {
	    sizeb = DoWriteChars(outStatePtr->topChanPtr, buffer, sizeb);
	}

	if (inBinary || sameEncoding) {
	    /* Both read and write counted bytes */
	    size = sizeb;
	} /* else : Read counted characters, write counted bytes, i.e. size != sizeb */

	if (sizeb < 0) {
	    writeError:
	    errObj = Tcl_NewObj();
	    Tcl_AppendStringsToObj(errObj, "error writing \"",
		    Tcl_GetChannelName(outChan), "\": ",
		    Tcl_PosixError(interp), (char *) NULL);
	    break;
	}

	/*
	 * Update the current byte count.  Do it now so the count is
	 * valid before a return or break takes us out of the loop.
	 * The invariant at the top of the loop should be that 
	 * csPtr->toRead holds the number of bytes left to copy.
	 */

	if (csPtr->toRead != -1) {
	    csPtr->toRead -= size;
	}
	csPtr->total += size;

	/*
	 * Break loop if EOF && (size>0)
	 */

        if (Tcl_Eof(inChan)) {
            break;
        }

	/*
	 * Check to see if the write is happening in the background.  If so,
	 * stop copying and wait for the channel to become writable again.
	 * After input underflow we already installed a readable handler
	 * therefore we don't need a writable handler.
	 */

	if ( ! underflow && (outStatePtr->flags & BG_FLUSH_SCHEDULED) ) {
	    if (!(mask & TCL_WRITABLE)) {
		if (mask & TCL_READABLE) {
		    Tcl_DeleteChannelHandler(inChan, CopyEventProc,
			    (ClientData) csPtr);
		}
		Tcl_CreateChannelHandler(outChan, TCL_WRITABLE,
			CopyEventProc, (ClientData) csPtr);
	    }
	    if (bufObj != (Tcl_Obj*) NULL) {
	        Tcl_DecrRefCount (bufObj);
		bufObj = (Tcl_Obj*) NULL;
	    }
	    return TCL_OK;
	}

	/*
	 * For background copies, we only do one buffer per invocation so
	 * we don't starve the rest of the system.
	 */

	if (cmdPtr) {
	    /*
	     * The first time we enter this code, there won't be a
	     * channel handler established yet, so do it here.
	     */

	    if (mask == 0) {
		Tcl_CreateChannelHandler(outChan, TCL_WRITABLE,
			CopyEventProc, (ClientData) csPtr);
	    }
	    if (bufObj != (Tcl_Obj*) NULL) {
	        Tcl_DecrRefCount (bufObj);
		bufObj = (Tcl_Obj*) NULL;
	    }
	    return TCL_OK;
	}
    } /* while */

    if (bufObj != (Tcl_Obj*) NULL) {
        Tcl_DecrRefCount (bufObj);
	bufObj = (Tcl_Obj*) NULL;
    }

    /*
     * Make the callback or return the number of bytes transferred.
     * The local total is used because StopCopy frees csPtr.
     */

    total = csPtr->total;
    if (cmdPtr) {
	/*
	 * Get a private copy of the command so we can mutate it
	 * by adding arguments.  Note that StopCopy frees our saved
	 * reference to the original command obj.
	 */

	cmdPtr = Tcl_DuplicateObj(cmdPtr);
	Tcl_IncrRefCount(cmdPtr);
	StopCopy(csPtr);
	Tcl_Preserve((ClientData) interp);

	Tcl_ListObjAppendElement(interp, cmdPtr, Tcl_NewIntObj(total));
	if (errObj) {
	    Tcl_ListObjAppendElement(interp, cmdPtr, errObj);
	}
	if (Tcl_EvalObjEx(interp, cmdPtr, TCL_EVAL_GLOBAL) != TCL_OK) {
	    Tcl_BackgroundError(interp);
	    result = TCL_ERROR;
	}
	Tcl_DecrRefCount(cmdPtr);
	Tcl_Release((ClientData) interp);
    } else {
	StopCopy(csPtr);
	if (errObj) {
	    Tcl_SetObjResult(interp, errObj);
	    result = TCL_ERROR;
	} else {
	    Tcl_ResetResult(interp);
	    Tcl_SetIntObj(Tcl_GetObjResult(interp), total);
	}
    }
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * DoRead --
 *
 *	Reads a given number of bytes from a channel.
 *
 *	No encoding conversions are applied to the bytes being read.
 *
 * Results:
 *	The number of characters read, or -1 on error. Use Tcl_GetErrno()
 *	to retrieve the error code for the error that occurred.
 *
 * Side effects:
 *	May cause input to be buffered.
 *
 *----------------------------------------------------------------------
 */

static int
DoRead(chanPtr, bufPtr, toRead)
    Channel *chanPtr;		/* The channel from which to read. */
    char *bufPtr;		/* Where to store input read. */
    int toRead;			/* Maximum number of bytes to read. */
{
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    int copied;			/* How many characters were copied into
                                 * the result string? */
    int copiedNow;		/* How many characters were copied from
                                 * the current input buffer? */
    int result;			/* Of calling GetInput. */

    /*
     * If we have not encountered a sticky EOF, clear the EOF bit. Either
     * way clear the BLOCKED bit. We want to discover these anew during
     * each operation.
     */

    if (!(statePtr->flags & CHANNEL_STICKY_EOF)) {
        statePtr->flags &= ~CHANNEL_EOF;
    }
    statePtr->flags &= ~(CHANNEL_BLOCKED | CHANNEL_NEED_MORE_DATA);
    
    for (copied = 0; copied < toRead; copied += copiedNow) {
        copiedNow = CopyAndTranslateBuffer(statePtr, bufPtr + copied,
                toRead - copied);
        if (copiedNow == 0) {
            if (statePtr->flags & CHANNEL_EOF) {
		goto done;
            }
            if (statePtr->flags & CHANNEL_BLOCKED) {
                if (statePtr->flags & CHANNEL_NONBLOCKING) {
		    goto done;
                }
                statePtr->flags &= (~(CHANNEL_BLOCKED));
            }
            result = GetInput(chanPtr);
            if (result != 0) {
                if (result != EAGAIN) {
                    copied = -1;
                }
		goto done;
            }
        }
    }

    statePtr->flags &= (~(CHANNEL_BLOCKED));

    done:
    /*
     * Update the notifier state so we don't block while there is still
     * data in the buffers.
     */

    UpdateInterest(chanPtr);
    return copied;
}

/*
 *----------------------------------------------------------------------
 *
 * CopyAndTranslateBuffer --
 *
 *	Copy at most one buffer of input to the result space, doing
 *	eol translations according to mode in effect currently.
 *
 * Results:
 *	Number of bytes stored in the result buffer (as opposed to the
 *	number of bytes read from the channel).  May return
 *	zero if no input is available to be translated.
 *
 * Side effects:
 *	Consumes buffered input. May deallocate one buffer.
 *
 *----------------------------------------------------------------------
 */

static int
CopyAndTranslateBuffer(statePtr, result, space)
    ChannelState *statePtr;	/* Channel state from which to read input. */
    char *result;		/* Where to store the copied input. */
    int space;			/* How many bytes are available in result
                                 * to store the copied input? */
{
    ChannelBuffer *bufPtr;	/* The buffer from which to copy bytes. */
    int bytesInBuffer;		/* How many bytes are available to be
                                 * copied in the current input buffer? */
    int copied;			/* How many characters were already copied
                                 * into the destination space? */
    int i;			/* Iterates over the copied input looking
                                 * for the input eofChar. */
    
    /*
     * If there is no input at all, return zero. The invariant is that either
     * there is no buffer in the queue, or if the first buffer is empty, it
     * is also the last buffer (and thus there is no input in the queue).
     * Note also that if the buffer is empty, we leave it in the queue.
     */
    
    if (statePtr->inQueueHead == (ChannelBuffer *) NULL) {
        return 0;
    }
    bufPtr = statePtr->inQueueHead;
    bytesInBuffer = bufPtr->nextAdded - bufPtr->nextRemoved;

    copied = 0;
    switch (statePtr->inputTranslation) {
        case TCL_TRANSLATE_LF: {
            if (bytesInBuffer == 0) {
                return 0;
            }

	    /*
             * Copy the current chunk into the result buffer.
             */

	    if (bytesInBuffer < space) {
		space = bytesInBuffer;
	    }
	    memcpy((VOID *) result,
		    (VOID *) (bufPtr->buf + bufPtr->nextRemoved),
		    (size_t) space);
	    bufPtr->nextRemoved += space;
	    copied = space;
            break;
	}
        case TCL_TRANSLATE_CR: {
	    char *end;
	    
            if (bytesInBuffer == 0) {
                return 0;
            }

	    /*
             * Copy the current chunk into the result buffer, then
             * replace all \r with \n.
             */

	    if (bytesInBuffer < space) {
		space = bytesInBuffer;
	    }
	    memcpy((VOID *) result,
		    (VOID *) (bufPtr->buf + bufPtr->nextRemoved),
		    (size_t) space);
	    bufPtr->nextRemoved += space;
	    copied = space;

	    for (end = result + copied; result < end; result++) {
		if (*result == '\r') {
		    *result = '\n';
		}
            }
            break;
	}
        case TCL_TRANSLATE_CRLF: {
	    char *src, *end, *dst;
	    int curByte;
	    
            /*
             * If there is a held-back "\r" at EOF, produce it now.
             */
            
	    if (bytesInBuffer == 0) {
                if ((statePtr->flags & (INPUT_SAW_CR | CHANNEL_EOF)) ==
                        (INPUT_SAW_CR | CHANNEL_EOF)) {
                    result[0] = '\r';
                    statePtr->flags &= ~INPUT_SAW_CR;
                    return 1;
                }
                return 0;
            }

            /*
             * Copy the current chunk and replace "\r\n" with "\n"
             * (but not standalone "\r"!).
             */

	    if (bytesInBuffer < space) {
		space = bytesInBuffer;
	    }
	    memcpy((VOID *) result,
		    (VOID *) (bufPtr->buf + bufPtr->nextRemoved),
		    (size_t) space);
	    bufPtr->nextRemoved += space;
	    copied = space;

	    end = result + copied;
	    dst = result;
	    for (src = result; src < end; src++) {
		curByte = *src;
		if (curByte == '\n') {
                    statePtr->flags &= ~INPUT_SAW_CR;
		} else if (statePtr->flags & INPUT_SAW_CR) {
		    statePtr->flags &= ~INPUT_SAW_CR;
		    *dst = '\r';
		    dst++;
		}
		if (curByte == '\r') {
		    statePtr->flags |= INPUT_SAW_CR;
		} else {
		    *dst = (char) curByte;
		    dst++;
		}
	    }
	    copied = dst - result;
	    break;
	}
        case TCL_TRANSLATE_AUTO: {
	    char *src, *end, *dst;
	    int curByte;
	
            if (bytesInBuffer == 0) {
                return 0;
            }

            /*
             * Loop over the current buffer, converting "\r" and "\r\n"
             * to "\n".
             */

	    if (bytesInBuffer < space) {
		space = bytesInBuffer;
	    }
	    memcpy((VOID *) result,
		    (VOID *) (bufPtr->buf + bufPtr->nextRemoved),
		    (size_t) space);
	    bufPtr->nextRemoved += space;
	    copied = space;

	    end = result + copied;
	    dst = result;
	    for (src = result; src < end; src++) {
		curByte = *src;
		if (curByte == '\r') {
		    statePtr->flags |= INPUT_SAW_CR;
		    *dst = '\n';
		    dst++;
		} else {
		    if ((curByte != '\n') || 
			    !(statePtr->flags & INPUT_SAW_CR)) {
			*dst = (char) curByte;
			dst++;
		    }
		    statePtr->flags &= ~INPUT_SAW_CR;
		}
	    }
	    copied = dst - result;
            break;
	}
        default: {
            panic("unknown eol translation mode");
	}
    }

    /*
     * If an in-stream EOF character is set for this channel, check that
     * the input we copied so far does not contain the EOF char.  If it does,
     * copy only up to and excluding that character.
     */
    
    if (statePtr->inEofChar != 0) {
        for (i = 0; i < copied; i++) {
            if (result[i] == (char) statePtr->inEofChar) {
		/*
		 * Set sticky EOF so that no further input is presented
		 * to the caller.
		 */
		
		statePtr->flags |= (CHANNEL_EOF | CHANNEL_STICKY_EOF);
		statePtr->inputEncodingFlags |= TCL_ENCODING_END;
		copied = i;
                break;
            }
        }
    }

    /*
     * If the current buffer is empty recycle it.
     */

    if (bufPtr->nextRemoved == bufPtr->nextAdded) {
        statePtr->inQueueHead = bufPtr->nextPtr;
        if (statePtr->inQueueHead == (ChannelBuffer *) NULL) {
            statePtr->inQueueTail = (ChannelBuffer *) NULL;
        }
        RecycleBuffer(statePtr, bufPtr, 0);
    }

    /*
     * Return the number of characters copied into the result buffer.
     * This may be different from the number of bytes consumed, because
     * of EOL translations.
     */

    return copied;
}

/*
 *----------------------------------------------------------------------
 *
 * CopyBuffer --
 *
 *	Copy at most one buffer of input to the result space.
 *
 * Results:
 *	Number of bytes stored in the result buffer.  May return
 *	zero if no input is available.
 *
 * Side effects:
 *	Consumes buffered input. May deallocate one buffer.
 *
 *----------------------------------------------------------------------
 */

static int
CopyBuffer(chanPtr, result, space)
    Channel *chanPtr;		/* Channel from which to read input. */
    char *result;		/* Where to store the copied input. */
    int space;			/* How many bytes are available in result
                                 * to store the copied input? */
{
    ChannelBuffer *bufPtr;	/* The buffer from which to copy bytes. */
    int bytesInBuffer;		/* How many bytes are available to be
                                 * copied in the current input buffer? */
    int copied;			/* How many characters were already copied
                                 * into the destination space? */
    
    /*
     * If there is no input at all, return zero. The invariant is that
     * either there is no buffer in the queue, or if the first buffer
     * is empty, it is also the last buffer (and thus there is no
     * input in the queue).  Note also that if the buffer is empty, we
     * don't leave it in the queue, but recycle it.
     */
    
    if (chanPtr->inQueueHead == (ChannelBuffer *) NULL) {
        return 0;
    }
    bufPtr = chanPtr->inQueueHead;
    bytesInBuffer = bufPtr->nextAdded - bufPtr->nextRemoved;

    copied = 0;

    if (bytesInBuffer == 0) {
        RecycleBuffer(chanPtr->state, bufPtr, 0);
	chanPtr->inQueueHead = (ChannelBuffer*) NULL;
	chanPtr->inQueueTail = (ChannelBuffer*) NULL;
        return 0;
    }

    /*
     * Copy the current chunk into the result buffer.
     */

    if (bytesInBuffer < space) {
        space = bytesInBuffer;
    }

    memcpy((VOID *) result,
	   (VOID *) (bufPtr->buf + bufPtr->nextRemoved),
	   (size_t) space);
    bufPtr->nextRemoved += space;
    copied = space;

    /*
     * We don't care about in-stream EOF characters here as the data
     * read here may still flow through one or more transformations,
     * i.e. is not in its final state yet.
     */

    /*
     * If the current buffer is empty recycle it.
     */

    if (bufPtr->nextRemoved == bufPtr->nextAdded) {
        chanPtr->inQueueHead = bufPtr->nextPtr;
        if (chanPtr->inQueueHead == (ChannelBuffer *) NULL) {
            chanPtr->inQueueTail = (ChannelBuffer *) NULL;
        }
        RecycleBuffer(chanPtr->state, bufPtr, 0);
    }

    /*
     * Return the number of characters copied into the result buffer.
     */

    return copied;
}

/*
 *----------------------------------------------------------------------
 *
 * DoWrite --
 *
 *	Puts a sequence of characters into an output buffer, may queue the
 *	buffer for output if it gets full, and also remembers whether the
 *	current buffer is ready e.g. if it contains a newline and we are in
 *	line buffering mode.
 *
 * Results:
 *	The number of bytes written or -1 in case of error. If -1,
 *	Tcl_GetErrno will return the error code.
 *
 * Side effects:
 *	May buffer up output and may cause output to be produced on the
 *	channel.
 *
 *----------------------------------------------------------------------
 */

static int
DoWrite(chanPtr, src, srcLen)
    Channel *chanPtr;			/* The channel to buffer output for. */
    CONST char *src;			/* Data to write. */
    int srcLen;				/* Number of bytes to write. */
{
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    ChannelBuffer *outBufPtr;		/* Current output buffer. */
    int foundNewline;			/* Did we find a newline in output? */
    char *dPtr;
    CONST char *sPtr;			/* Search variables for newline. */
    int crsent;				/* In CRLF eol translation mode,
                                         * remember the fact that a CR was
                                         * output to the channel without
                                         * its following NL. */
    int i;				/* Loop index for newline search. */
    int destCopied;			/* How many bytes were used in this
                                         * destination buffer to hold the
                                         * output? */
    int totalDestCopied;		/* How many bytes total were
                                         * copied to the channel buffer? */
    int srcCopied;			/* How many bytes were copied from
                                         * the source string? */
    char *destPtr;			/* Where in line to copy to? */

    /*
     * If we are in network (or windows) translation mode, record the fact
     * that we have not yet sent a CR to the channel.
     */

    crsent = 0;
    
    /*
     * Loop filling buffers and flushing them until all output has been
     * consumed.
     */

    srcCopied = 0;
    totalDestCopied = 0;

    while (srcLen > 0) {
        
        /*
         * Make sure there is a current output buffer to accept output.
         */

        if (statePtr->curOutPtr == (ChannelBuffer *) NULL) {
            statePtr->curOutPtr = AllocChannelBuffer(statePtr->bufSize);
        }

        outBufPtr = statePtr->curOutPtr;

        destCopied = outBufPtr->bufLength - outBufPtr->nextAdded;
        if (destCopied > srcLen) {
            destCopied = srcLen;
        }
        
        destPtr = outBufPtr->buf + outBufPtr->nextAdded;
        switch (statePtr->outputTranslation) {
            case TCL_TRANSLATE_LF:
                srcCopied = destCopied;
                memcpy((VOID *) destPtr, (VOID *) src, (size_t) destCopied);
                break;
            case TCL_TRANSLATE_CR:
                srcCopied = destCopied;
                memcpy((VOID *) destPtr, (VOID *) src, (size_t) destCopied);
                for (dPtr = destPtr; dPtr < destPtr + destCopied; dPtr++) {
                    if (*dPtr == '\n') {
                        *dPtr = '\r';
                    }
                }
                break;
            case TCL_TRANSLATE_CRLF:
                for (srcCopied = 0, dPtr = destPtr, sPtr = src;
                     dPtr < destPtr + destCopied;
                     dPtr++, sPtr++, srcCopied++) {
                    if (*sPtr == '\n') {
                        if (crsent) {
                            *dPtr = '\n';
                            crsent = 0;
                        } else {
                            *dPtr = '\r';
                            crsent = 1;
                            sPtr--, srcCopied--;
                        }
                    } else {
                        *dPtr = *sPtr;
                    }
                }
                break;
            case TCL_TRANSLATE_AUTO:
                panic("Tcl_Write: AUTO output translation mode not supported");
            default:
                panic("Tcl_Write: unknown output translation mode");
        }

        /*
         * The current buffer is ready for output if it is full, or if it
         * contains a newline and this channel is line-buffered, or if it
         * contains any output and this channel is unbuffered.
         */

        outBufPtr->nextAdded += destCopied;
        if (!(statePtr->flags & BUFFER_READY)) {
            if (outBufPtr->nextAdded == outBufPtr->bufLength) {
                statePtr->flags |= BUFFER_READY;
            } else if (statePtr->flags & CHANNEL_LINEBUFFERED) {
                for (sPtr = src, i = 0, foundNewline = 0;
		     (i < srcCopied) && (!foundNewline);
		     i++, sPtr++) {
                    if (*sPtr == '\n') {
                        foundNewline = 1;
                        break;
                    }
                }
                if (foundNewline) {
                    statePtr->flags |= BUFFER_READY;
                }
            } else if (statePtr->flags & CHANNEL_UNBUFFERED) {
                statePtr->flags |= BUFFER_READY;
            }
        }
        
        totalDestCopied += srcCopied;
        src += srcCopied;
        srcLen -= srcCopied;

        if (statePtr->flags & BUFFER_READY) {
            if (FlushChannel(NULL, chanPtr, 0) != 0) {
                return -1;
            }
        }
    } /* Closes "while" */

    return totalDestCopied;
}

/*
 *----------------------------------------------------------------------
 *
 * CopyEventProc --
 *
 *	This routine is invoked as a channel event handler for
 *	the background copy operation.  It is just a trivial wrapper
 *	around the CopyData routine.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static void
CopyEventProc(clientData, mask)
    ClientData clientData;
    int mask;
{
    (void) CopyData((CopyState *)clientData, mask);
}

/*
 *----------------------------------------------------------------------
 *
 * StopCopy --
 *
 *	This routine halts a copy that is in progress.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Removes any pending channel handlers and restores the blocking
 *	and buffering modes of the channels.  The CopyState is freed.
 *
 *----------------------------------------------------------------------
 */

static void
StopCopy(csPtr)
    CopyState *csPtr;		/* State for bg copy to stop . */
{
    ChannelState *inStatePtr, *outStatePtr;
    int nonBlocking;

    if (!csPtr) {
	return;
    }

    inStatePtr	= csPtr->readPtr->state;
    outStatePtr	= csPtr->writePtr->state;

    /*
     * Restore the old blocking mode and output buffering mode.
     */

    nonBlocking = (csPtr->readFlags & CHANNEL_NONBLOCKING);
    if (nonBlocking != (inStatePtr->flags & CHANNEL_NONBLOCKING)) {
	SetBlockMode(NULL, csPtr->readPtr,
		nonBlocking ? TCL_MODE_NONBLOCKING : TCL_MODE_BLOCKING);
    }
    if (csPtr->readPtr != csPtr->writePtr) {
	nonBlocking = (csPtr->writeFlags & CHANNEL_NONBLOCKING);
	if (nonBlocking != (outStatePtr->flags & CHANNEL_NONBLOCKING)) {
	    SetBlockMode(NULL, csPtr->writePtr,
		    nonBlocking ? TCL_MODE_NONBLOCKING : TCL_MODE_BLOCKING);
	}
    }
    outStatePtr->flags &= ~(CHANNEL_LINEBUFFERED | CHANNEL_UNBUFFERED);
    outStatePtr->flags |=
	csPtr->writeFlags & (CHANNEL_LINEBUFFERED | CHANNEL_UNBUFFERED);

    if (csPtr->cmdPtr) {
	Tcl_DeleteChannelHandler((Tcl_Channel)csPtr->readPtr, CopyEventProc,
		(ClientData)csPtr);
	if (csPtr->readPtr != csPtr->writePtr) {
	    Tcl_DeleteChannelHandler((Tcl_Channel)csPtr->writePtr,
		    CopyEventProc, (ClientData)csPtr);
	}
        Tcl_DecrRefCount(csPtr->cmdPtr);
    }
    inStatePtr->csPtr  = NULL;
    outStatePtr->csPtr = NULL;
    ckfree((char*) csPtr);
}

/*
 *----------------------------------------------------------------------
 *
 * StackSetBlockMode --
 *
 *	This function sets the blocking mode for a channel, iterating
 *	through each channel in a stack and updates the state flags.
 *
 * Results:
 *	0 if OK, result code from failed blockModeProc otherwise.
 *
 * Side effects:
 *	Modifies the blocking mode of the channel and possibly generates
 *	an error.
 *
 *----------------------------------------------------------------------
 */

static int
StackSetBlockMode(chanPtr, mode)
    Channel *chanPtr;		/* Channel to modify. */
    int mode;			/* One of TCL_MODE_BLOCKING or
				 * TCL_MODE_NONBLOCKING. */
{
    int result = 0;
    Tcl_DriverBlockModeProc *blockModeProc;

    /*
     * Start at the top of the channel stack
     */

    chanPtr = chanPtr->state->topChanPtr;
    while (chanPtr != (Channel *) NULL) {
	blockModeProc = Tcl_ChannelBlockModeProc(chanPtr->typePtr);
	if (blockModeProc != NULL) {
	    result = (*blockModeProc) (chanPtr->instanceData, mode);
	    if (result != 0) {
		Tcl_SetErrno(result);
		return result;
	    }
	}
	chanPtr = chanPtr->downChanPtr;
    }
    return 0;
}

/*
 *----------------------------------------------------------------------
 *
 * SetBlockMode --
 *
 *	This function sets the blocking mode for a channel and updates
 *	the state flags.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	Modifies the blocking mode of the channel and possibly generates
 *	an error.
 *
 *----------------------------------------------------------------------
 */

static int
SetBlockMode(interp, chanPtr, mode)
    Tcl_Interp *interp;		/* Interp for error reporting. */
    Channel *chanPtr;		/* Channel to modify. */
    int mode;			/* One of TCL_MODE_BLOCKING or
				 * TCL_MODE_NONBLOCKING. */
{
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    int result = 0;

    result = StackSetBlockMode(chanPtr, mode);
    if (result != 0) {
	if (interp != (Tcl_Interp *) NULL) {
	    Tcl_AppendResult(interp, "error setting blocking mode: ",
		    Tcl_PosixError(interp), (char *) NULL);
	}
	return TCL_ERROR;
    }
    if (mode == TCL_MODE_BLOCKING) {
	statePtr->flags &= (~(CHANNEL_NONBLOCKING | BG_FLUSH_SCHEDULED));
    } else {
	statePtr->flags |= CHANNEL_NONBLOCKING;
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetChannelNames --
 *
 *	Return the names of all open channels in the interp.
 *
 * Results:
 *	TCL_OK or TCL_ERROR.
 *
 * Side effects:
 *	Interp result modified with list of channel names.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_GetChannelNames(interp)
    Tcl_Interp *interp;		/* Interp for error reporting. */
{
    return Tcl_GetChannelNamesEx(interp, (char *) NULL);
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetChannelNamesEx --
 *
 *	Return the names of open channels in the interp filtered
 *	filtered through a pattern.  If pattern is NULL, it returns
 *	all the open channels.
 *
 * Results:
 *	TCL_OK or TCL_ERROR.
 *
 * Side effects:
 *	Interp result modified with list of channel names.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_GetChannelNamesEx(interp, pattern)
    Tcl_Interp *interp;		/* Interp for error reporting. */
    CONST char *pattern;	/* pattern to filter on. */
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    ChannelState *statePtr;
    CONST char *name;		/* name for channel */
    Tcl_Obj *resultPtr;		/* pointer to result object */
    Tcl_HashTable *hTblPtr;	/* Hash table of channels. */
    Tcl_HashEntry *hPtr;	/* Search variable. */
    Tcl_HashSearch hSearch;	/* Search variable. */

    if (interp == (Tcl_Interp *) NULL) {
	return TCL_OK;
    }

    /*
     * Get the channel table that stores the channels registered
     * for this interpreter.
     */
    hTblPtr	= GetChannelTable(interp);
    resultPtr	= Tcl_GetObjResult(interp);

    for (hPtr = Tcl_FirstHashEntry(hTblPtr, &hSearch);
	 hPtr != (Tcl_HashEntry *) NULL;
	 hPtr = Tcl_NextHashEntry(&hSearch)) {

	statePtr = ((Channel *) Tcl_GetHashValue(hPtr))->state;
        if (statePtr->topChanPtr == (Channel *) tsdPtr->stdinChannel) {
	    name = "stdin";
	} else if (statePtr->topChanPtr == (Channel *) tsdPtr->stdoutChannel) {
	    name = "stdout";
	} else if (statePtr->topChanPtr == (Channel *) tsdPtr->stderrChannel) {
	    name = "stderr";
	} else {
	    /*
	     * This is also stored in Tcl_GetHashKey(hTblPtr, hPtr),
	     * but it's simpler to just grab the name from the statePtr.
	     */
	    name = statePtr->channelName;
	}

	if (((pattern == NULL) || Tcl_StringMatch(name, pattern)) &&
		(Tcl_ListObjAppendElement(interp, resultPtr,
			Tcl_NewStringObj(name, -1)) != TCL_OK)) {
	    return TCL_ERROR;
	}
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_IsChannelRegistered --
 *
 *	Checks whether the channel is associated with the interp.
 *	See also Tcl_RegisterChannel and Tcl_UnregisterChannel.
 *
 * Results:
 *	0 if the channel is not registered in the interpreter, 1 else.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_IsChannelRegistered (interp, chan)
     Tcl_Interp* interp;	/* The interp to query of the channel */
     Tcl_Channel chan;		/* The channel to check */
{
    Tcl_HashTable	*hTblPtr;	/* Hash table of channels. */
    Tcl_HashEntry	*hPtr;		/* Search variable. */
    Channel		*chanPtr;	/* The real IO channel. */
    ChannelState	*statePtr;	/* State of the real channel. */

    /*
     * Always check bottom-most channel in the stack.  This is the one
     * that gets registered.
     */
    chanPtr = ((Channel *) chan)->state->bottomChanPtr;
    statePtr = chanPtr->state;

    hTblPtr = (Tcl_HashTable *) Tcl_GetAssocData(interp, "tclIO", NULL);
    if (hTblPtr == (Tcl_HashTable *) NULL) {
        return 0;
    }
    hPtr = Tcl_FindHashEntry(hTblPtr, statePtr->channelName);
    if (hPtr == (Tcl_HashEntry *) NULL) {
        return 0;
    }
    if ((Channel *) Tcl_GetHashValue(hPtr) != chanPtr) {
        return 0;
    }

    return 1;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_IsChannelShared --
 *
 *	Checks whether the channel is shared by multiple interpreters.
 *
 * Results:
 *	A boolean value (0 = Not shared, 1 = Shared).
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_IsChannelShared (chan)
    Tcl_Channel chan;	/* The channel to query */
{
    ChannelState *statePtr = ((Channel *) chan)->state;
					/* State of real channel structure. */

    return ((statePtr->refCount > 1) ? 1 : 0);
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_IsChannelExisting --
 *
 *	Checks whether a channel of the given name exists in the
 *	(thread)-global list of all channels.
 *	See Tcl_GetChannelNamesEx for function exposed at the Tcl level.
 *
 * Results:
 *	A boolean value (0 = Does not exist, 1 = Does exist).
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_IsChannelExisting(chanName)
    CONST char* chanName;	/* The name of the channel to look for. */
{
    ChannelState *statePtr;
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    CONST char *name;
    int chanNameLen;

    chanNameLen = strlen(chanName);
    for (statePtr = tsdPtr->firstCSPtr;
	 statePtr != NULL;
	 statePtr = statePtr->nextCSPtr) {
        if (statePtr->topChanPtr == (Channel *) tsdPtr->stdinChannel) {
	    name = "stdin";
	} else if (statePtr->topChanPtr == (Channel *) tsdPtr->stdoutChannel) {
	    name = "stdout";
	} else if (statePtr->topChanPtr == (Channel *) tsdPtr->stderrChannel) {
	    name = "stderr";
	} else {
	    name = statePtr->channelName;
	}

	if ((*chanName == *name) &&
		(memcmp(name, chanName, (size_t) chanNameLen) == 0)) {
	    return 1;
	}
    }

    return 0;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_ChannelName --
 *
 *	Return the name of the channel type.
 *
 * Results:
 *	A pointer the name of the channel type.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

CONST char *
Tcl_ChannelName(chanTypePtr)
    Tcl_ChannelType *chanTypePtr;	/* Pointer to channel type. */
{
    return chanTypePtr->typeName;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_ChannelVersion --
 *
 *	Return the of version of the channel type.
 *
 * Results:
 *	One of the TCL_CHANNEL_VERSION_* constants from tcl.h
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_ChannelTypeVersion
Tcl_ChannelVersion(chanTypePtr)
    Tcl_ChannelType *chanTypePtr;	/* Pointer to channel type. */
{
    if (chanTypePtr->version == TCL_CHANNEL_VERSION_2) {
	return TCL_CHANNEL_VERSION_2;
    } else if (chanTypePtr->version == TCL_CHANNEL_VERSION_3) {
	return TCL_CHANNEL_VERSION_3;
    } else {
	/*
	 * In <v2 channel versions, the version field is occupied
	 * by the Tcl_DriverBlockModeProc
	 */
	return TCL_CHANNEL_VERSION_1;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * HaveVersion --
 *
 *	Return whether a channel type is (at least) of a given version.
 *
 * Results:
 *	True if the minimum version is exceeded by the version actually
 *	present.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
HaveVersion(chanTypePtr, minimumVersion)
    Tcl_ChannelType *chanTypePtr;
    Tcl_ChannelTypeVersion minimumVersion;
{
    Tcl_ChannelTypeVersion actualVersion = Tcl_ChannelVersion(chanTypePtr);

    return ((int)actualVersion) >= ((int)minimumVersion);
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_ChannelBlockModeProc --
 *
 *	Return the Tcl_DriverBlockModeProc of the channel type.
 *
 * Results:
 *	A pointer to the proc.
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------- */

Tcl_DriverBlockModeProc *
Tcl_ChannelBlockModeProc(chanTypePtr)
    Tcl_ChannelType *chanTypePtr;	/* Pointer to channel type. */
{
    if (HaveVersion(chanTypePtr, TCL_CHANNEL_VERSION_2)) {
	return chanTypePtr->blockModeProc;
    } else {
	/*
	 * The v1 structure had the blockModeProc in a different place.
	 */
	return (Tcl_DriverBlockModeProc *) (chanTypePtr->version);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_ChannelCloseProc --
 *
 *	Return the Tcl_DriverCloseProc of the channel type.
 *
 * Results:
 *	A pointer to the proc.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_DriverCloseProc *
Tcl_ChannelCloseProc(chanTypePtr)
    Tcl_ChannelType *chanTypePtr;	/* Pointer to channel type. */
{
    return chanTypePtr->closeProc;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_ChannelClose2Proc --
 *
 *	Return the Tcl_DriverClose2Proc of the channel type.
 *
 * Results:
 *	A pointer to the proc.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_DriverClose2Proc *
Tcl_ChannelClose2Proc(chanTypePtr)
    Tcl_ChannelType *chanTypePtr;	/* Pointer to channel type. */
{
    return chanTypePtr->close2Proc;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_ChannelInputProc --
 *
 *	Return the Tcl_DriverInputProc of the channel type.
 *
 * Results:
 *	A pointer to the proc.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_DriverInputProc *
Tcl_ChannelInputProc(chanTypePtr)
    Tcl_ChannelType *chanTypePtr;	/* Pointer to channel type. */
{
    return chanTypePtr->inputProc;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_ChannelOutputProc --
 *
 *	Return the Tcl_DriverOutputProc of the channel type.
 *
 * Results:
 *	A pointer to the proc.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_DriverOutputProc *
Tcl_ChannelOutputProc(chanTypePtr)
    Tcl_ChannelType *chanTypePtr;	/* Pointer to channel type. */
{
    return chanTypePtr->outputProc;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_ChannelSeekProc --
 *
 *	Return the Tcl_DriverSeekProc of the channel type.
 *
 * Results:
 *	A pointer to the proc.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_DriverSeekProc *
Tcl_ChannelSeekProc(chanTypePtr)
    Tcl_ChannelType *chanTypePtr;	/* Pointer to channel type. */
{
    return chanTypePtr->seekProc;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_ChannelSetOptionProc --
 *
 *	Return the Tcl_DriverSetOptionProc of the channel type.
 *
 * Results:
 *	A pointer to the proc.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_DriverSetOptionProc *
Tcl_ChannelSetOptionProc(chanTypePtr)
    Tcl_ChannelType *chanTypePtr;	/* Pointer to channel type. */
{
    return chanTypePtr->setOptionProc;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_ChannelGetOptionProc --
 *
 *	Return the Tcl_DriverGetOptionProc of the channel type.
 *
 * Results:
 *	A pointer to the proc.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_DriverGetOptionProc *
Tcl_ChannelGetOptionProc(chanTypePtr)
    Tcl_ChannelType *chanTypePtr;	/* Pointer to channel type. */
{
    return chanTypePtr->getOptionProc;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_ChannelWatchProc --
 *
 *	Return the Tcl_DriverWatchProc of the channel type.
 *
 * Results:
 *	A pointer to the proc.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_DriverWatchProc *
Tcl_ChannelWatchProc(chanTypePtr)
    Tcl_ChannelType *chanTypePtr;	/* Pointer to channel type. */
{
    return chanTypePtr->watchProc;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_ChannelGetHandleProc --
 *
 *	Return the Tcl_DriverGetHandleProc of the channel type.
 *
 * Results:
 *	A pointer to the proc.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_DriverGetHandleProc *
Tcl_ChannelGetHandleProc(chanTypePtr)
    Tcl_ChannelType *chanTypePtr;	/* Pointer to channel type. */
{
    return chanTypePtr->getHandleProc;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_ChannelFlushProc --
 *
 *	Return the Tcl_DriverFlushProc of the channel type.
 *
 * Results:
 *	A pointer to the proc.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_DriverFlushProc *
Tcl_ChannelFlushProc(chanTypePtr)
    Tcl_ChannelType *chanTypePtr;	/* Pointer to channel type. */
{
    if (HaveVersion(chanTypePtr, TCL_CHANNEL_VERSION_2)) {
	return chanTypePtr->flushProc;
    } else {
	return NULL;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_ChannelHandlerProc --
 *
 *	Return the Tcl_DriverHandlerProc of the channel type.
 *
 * Results:
 *	A pointer to the proc.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_DriverHandlerProc *
Tcl_ChannelHandlerProc(chanTypePtr)
    Tcl_ChannelType *chanTypePtr;	/* Pointer to channel type. */
{
    if (HaveVersion(chanTypePtr, TCL_CHANNEL_VERSION_2)) {
	return chanTypePtr->handlerProc;
    } else {
	return NULL;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_ChannelWideSeekProc --
 *
 *	Return the Tcl_DriverWideSeekProc of the channel type.
 *
 * Results:
 *	A pointer to the proc.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_DriverWideSeekProc *
Tcl_ChannelWideSeekProc(chanTypePtr)
    Tcl_ChannelType *chanTypePtr;	/* Pointer to channel type. */
{
    if (HaveVersion(chanTypePtr, TCL_CHANNEL_VERSION_3)) {
	return chanTypePtr->wideSeekProc;
    } else {
	return NULL;
    }
}
@


1.4
log
@touched all sources to ease next import
@
text
@d13 1
a13 1
 * RCS: @@(#) $Id: tclIO.c,v 1.8.8.2 2000/09/15 16:55:16 spolk Exp $
d95 1
a95 2
				Channel *chanPtr, char *result,
				int space));
d106 2
d114 1
a114 1
static int		DoWrite _ANSI_ARGS_((Channel *chanPtr, char *src,
d116 4
d126 2
d134 2
a135 2
				Tcl_Obj *objPtr, int charsLeft, int *offsetPtr,
				int *factorPtr));
d144 2
a145 2
				char *dst, CONST char *src, int *dstLenPtr,
				int *srcLenPtr));
d147 2
a148 2
				char *dst, CONST char *src, int *dstLenPtr,
				int *srcLenPtr));
d693 32
d760 1
a760 1
    if (statePtr->channelName == (char *) NULL) {
d785 5
a789 1
 *	reference count.
d795 5
a799 1
 *	Deletes the hash entry for a channel associated with an interpreter.
a808 3
    Tcl_HashTable *hTblPtr;	/* Hash table of channels. */
    Tcl_HashEntry *hPtr;	/* Search variable. */
    Channel *chanPtr;		/* The real IO channel. */
d811 3
a813 29
    /*
     * Always (un)register bottom-most channel in the stack.  This makes
     * management of the channel list easier because no manipulation is
     * necessary during (un)stack operation.
     */
    chanPtr = ((Channel *) chan)->state->bottomChanPtr;
    statePtr = chanPtr->state;

    if (interp != (Tcl_Interp *) NULL) {
        hTblPtr = (Tcl_HashTable *) Tcl_GetAssocData(interp, "tclIO", NULL);
        if (hTblPtr == (Tcl_HashTable *) NULL) {
            return TCL_OK;
        }
        hPtr = Tcl_FindHashEntry(hTblPtr, statePtr->channelName);
        if (hPtr == (Tcl_HashEntry *) NULL) {
            return TCL_OK;
        }
        if ((Channel *) Tcl_GetHashValue(hPtr) != chanPtr) {
            return TCL_OK;
        }
        Tcl_DeleteHashEntry(hPtr);

        /*
         * Remove channel handlers that refer to this interpreter, so that they
         * will not be present if the actual close is delayed and more events
         * happen on the channel. This may occur if the channel is shared
         * between several interpreters, or if the channel has async
         * flushing active.
         */
d815 1
a815 2
        CleanupChannelHandlers(interp, chanPtr);
    }
a816 2
    statePtr->refCount--;
    
d843 1
a843 1
        statePtr->flags |= CHANNEL_CLOSED;
d845 8
a852 3
            if (Tcl_Close(interp, chan) != TCL_OK) {
                return TCL_ERROR;
            }
d854 2
d861 123
d1007 1
a1007 1
    char *chanName;		/* The name of the channel. */
d1016 1
a1016 1
    char *name;			/* Translated name. */
d1085 1
a1085 1
    char *chanName;		/* Name of channel to record. */
d1108 4
d1125 3
a1127 2
        statePtr->channelName = ckalloc((unsigned) (strlen(chanName) + 1));
        strcpy(statePtr->channelName, chanName);
d1197 11
d1210 1
a1210 2
    statePtr->nextCSPtr  = tsdPtr->firstCSPtr;
    tsdPtr->firstCSPtr   = statePtr;
d1628 26
d1722 1
a1722 1
char *
d1846 11
d2065 1
a2065 1
                (char *) bufPtr->buf + bufPtr->nextRemoved, toWrite,
d2116 7
d2124 1
a2124 1
			    Tcl_PosixError(interp), TCL_VOLATILE);
a2218 3
    ChannelState *prevCSPtr;		/* Preceding channel state in list of
                                         * all states - used to splice a
                                         * channel out of the list on close. */
a2262 8
#if 0
    /*
     * Remove TCL_READABLE and TCL_WRITABLE from statePtr->flags, so
     * that close callbacks can not do input or output (assuming they
     * squirreled the channel away in their clientData). This also
     * prevents infinite loops if the callback calls any C API that
     * could call FlushChannel.
     */
d2265 1
a2265 1
     * This prevents any data from being flushed from stacked channels.
d2267 1
a2267 20
    statePtr->flags &= (~(TCL_READABLE|TCL_WRITABLE));
#endif

    /*
     * Splice this channel out of the list of all channels.
     */

    if (tsdPtr->firstCSPtr && (statePtr == tsdPtr->firstCSPtr)) {
        tsdPtr->firstCSPtr = statePtr->nextCSPtr;
    } else {
        for (prevCSPtr = tsdPtr->firstCSPtr;
	     prevCSPtr && (prevCSPtr->nextCSPtr != statePtr);
	     prevCSPtr = prevCSPtr->nextCSPtr) {
            /* Empty loop body. */
        }
        if (prevCSPtr == (ChannelState *) NULL) {
            panic("FlushChannel: damaged channel list");
        }
        prevCSPtr->nextCSPtr = statePtr->nextCSPtr;
    }
d2288 1
a2288 1
	    ckfree(statePtr->channelName);
a2324 17
#if 0
	int code = TCL_OK;

	while (chanPtr->downChanPtr != (Channel *) NULL) {
	    /*
	     * Unwind the state of the transformation, and then restore the
	     * state of (unstack) the underlying channel into the TOP channel
	     * structure.
	     */
	    code = Tcl_UnstackChannel(interp, (Tcl_Channel) chanPtr);
	    if (code == TCL_ERROR) {
		errorCode = Tcl_GetErrno();
		break;
	    }
	    chanPtr = chanPtr->downChanPtr;
	}
#else
a2335 1
#endif
d2340 4
a2343 1
     * pointers we have and then ourselves.
d2347 1
d2356 112
a2494 1
    ChannelHandler *chPtr, *chNext;	/* Iterate over channel handlers. */
a2496 1
    EventScriptRecord *ePtr, *eNextPtr;	/* Iterate over eventscript records. */
a2499 2
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    NextChannelHandler *nhPtr;
d2528 94
a2674 44
        
    /*
     * Invoke the registered close callbacks and delete their records.
     */

    while (statePtr->closeCbPtr != (CloseCallback *) NULL) {
        cbPtr = statePtr->closeCbPtr;
        statePtr->closeCbPtr = cbPtr->nextPtr;
        (cbPtr->proc) (cbPtr->clientData);
        ckfree((char *) cbPtr);
    }

    /*
     * Ensure that the last output buffer will be flushed.
     */
    
    if ((statePtr->curOutPtr != (ChannelBuffer *) NULL) &&
	    (statePtr->curOutPtr->nextAdded > statePtr->curOutPtr->nextRemoved)) {
        statePtr->flags |= BUFFER_READY;
    }

    /*
     * If this channel supports it, close the read side, since we don't need it
     * anymore and this will help avoid deadlocks on some channel types.
     */

    if (chanPtr->typePtr->closeProc == TCL_CLOSE2PROC) {
	result = (chanPtr->typePtr->close2Proc)(chanPtr->instanceData, interp,
		TCL_CLOSE_READ);
    } else {
	result = 0;
    }

    /*
     * The call to FlushChannel will flush any queued output and invoke
     * the close function of the channel driver, or it will set up the
     * channel to be flushed and closed asynchronously.
     */

    statePtr->flags |= CHANNEL_CLOSED;
    if ((FlushChannel(interp, chanPtr, 0) != 0) || (result != 0)) {
        return TCL_ERROR;
    }
    return TCL_OK;
d2685 4
a2688 1
 *	line buffering mode.
d2704 1
a2704 1
    char *src;				/* Data to queue in output buffer. */
d2735 4
a2738 1
 *	line buffering mode.
d2754 1
a2754 1
    char *src;				/* Data to queue in output buffer. */
d2794 43
a2836 1
 *	line buffering mode.
d2849 3
a2851 3
int
Tcl_WriteChars(chan, src, len)
    Tcl_Channel chan;		/* The channel to buffer output for. */
a2858 1
    Channel *chanPtr;
d2861 1
a2861 1
    statePtr = ((Channel *) chan)->state;
a2863 3
    if (CheckChannelErrors(statePtr, TCL_WRITABLE) != 0) {
	return -1;
    }
d2968 1
a2968 1
    int dstLen, dstMax, sawLF, savedLF, total, toWrite;
d3056 3
a3058 2
    int saved, savedLF, sawLF, total, toWrite, flags;
    int dstWrote, dstLen, stageLen, stageMax, stageRead;
d3069 6
d3079 3
a3081 1
    while (srcLen + savedLF > 0) {
a3115 5
	flags = statePtr->outputEncodingFlags;
	if (srcLen == 0) {
	    flags |= TCL_ENCODING_END;
	}

d3121 1
a3121 1
	while (stageLen + saved > 0) {
d3144 2
a3145 1
	    Tcl_UtfToExternal(NULL, encoding, stage, stageLen, flags,
d3148 21
a3168 1
	    if (stageRead + dstWrote == 0) {
d3204 12
d3218 9
d3486 1
a3486 1
    int inEofChar, skip, copiedTotal;
a3489 1
    int oldLength, oldFlags, oldRemoved;
d3698 1
a3698 1
	    if (eol == objPtr->bytes) {
d3700 1
a3700 1
		 * If we didn't produce any bytes before encountering EOF,
d3704 1
a3704 1
		Tcl_SetObjLength(objPtr, 0);
d3727 3
a3729 2
	    &statePtr->inputEncodingState, dst, eol - dst + skip + TCL_UTF_MAX,
	    &gs.rawRead, NULL, &gs.charsWrote);
d3820 1
a3820 1
#define ENCODING_LINESIZE   30	/* Lower bound on how many bytes to convert
d3849 1
a3849 1
	 
d3902 8
a3909 1
	    &gsPtr->charsWrote); 
d4180 1
a4180 1
    char *bufPtr;			/* Where to store input read. */
d4224 13
a4236 8
	    /*
	     * Now go to the driver to get as much as is possible to
	     * fill the remaining request. Do all the error handling
	     * by ourselves.  The code was stolen from 'GetInput' and
	     * slightly adapted (different return value here).
	     *
	     * The case of 'bytesToRead == 0' at this point cannot happen.
	     */
d4238 1
a4238 1
	    nread = (chanPtr->typePtr->inputProc)(chanPtr->instanceData,
d4240 1
d4317 55
a4371 1
    Channel *chanPtr = (Channel *) chan;
d4382 1
a4382 7
    chanPtr = statePtr->topChanPtr;

    if (CheckChannelErrors(statePtr, TCL_READABLE) != 0) {
	copied = -1;
	goto done;
    }

d4384 1
a4384 1
    factor = UTF_EXPANSION_FACTOR;
d4423 1
a4423 1
		    statePtr->inQueueTail = nextPtr;
a4494 8
    int bytesToRead;		/* Maximum number of characters to store,
				 * or < 0 to get all available characters.
				 * Characters are obtained from the first
				 * buffer in the queue -- even if this number
				 * is larger than the number of characters
				 * available in the first buffer, only the
				 * characters from the first buffer are
				 * returned. */
d4500 8
d4513 1
a4513 1
    int toRead, srcLen, srcRead, dstWrote, offset, length;
d4599 4
a4610 4
    Tcl_Obj *objPtr;		/* Input data is appended to this object.
				 * objPtr->length is how much space has been
				 * allocated to hold data, not how many bytes
				 * of data have been stored in the object. */
d4621 2
a4622 2
    int toRead, factor, offset, spaceLeft, length;
    int srcLen, srcRead, dstNeeded, dstRead, dstWrote, numChars;
d4635 1
a4635 1
    if ((unsigned) toRead > (unsigned) srcLen) {
d4717 14
a4730 5
	    /*
	     * There isn't enough data in the buffers to complete the next
	     * character, so we need to wait for more data before the next
	     * file event can be delivered.
	     */
d4732 2
a4733 1
	    statePtr->flags |= CHANNEL_NEED_MORE_DATA;
d4748 3
a4750 1
	 * EOF was located in dst?
d4776 1
a4776 1
	char *eof;
d4989 1
a4989 1
    char *str;			/* The input itself. */
d5238 13
d5256 15
a5270 1
        toRead = statePtr->bufSize;
d5278 1
a5278 1
      
d5288 8
a5295 2
    nread = (chanPtr->typePtr->inputProc)(chanPtr->instanceData,
	    bufPtr->buf + bufPtr->nextAdded, toRead, &result);
d5320 1
a5320 1
    } 
d5342 1
a5342 1
int
d5345 1
a5345 1
    int offset;			/* Offset to seek to. */
a5349 1
    ChannelBuffer *bufPtr;
d5351 1
d5353 1
a5353 1
    int curPos;			/* Position on the device. */
d5359 1
a5359 1
	return -1;
d5369 3
a5371 1
    if (CheckForDeadChannel(NULL, statePtr)) return -1;
d5386 1
a5386 1
        return -1;
d5394 2
a5395 27
    for (bufPtr = statePtr->inQueueHead, inputBuffered = 0;
	 bufPtr != (ChannelBuffer *) NULL;
	 bufPtr = bufPtr->nextPtr) {
        inputBuffered += (bufPtr->nextAdded - bufPtr->nextRemoved);
    }

    /*
     * Don't forget the bytes in the topmost pushback area.
     */

    for (bufPtr = statePtr->topChanPtr->inQueueHead;
	 bufPtr != (ChannelBuffer *) NULL;
	 bufPtr = bufPtr->nextPtr) {
        inputBuffered += (bufPtr->nextAdded - bufPtr->nextRemoved);
    }

    for (bufPtr = statePtr->outQueueHead, outputBuffered = 0;
	 bufPtr != (ChannelBuffer *) NULL;
	 bufPtr = bufPtr->nextPtr) {
        outputBuffered += (bufPtr->nextAdded - bufPtr->nextRemoved);
    }
    if ((statePtr->curOutPtr != (ChannelBuffer *) NULL) &&
	    (statePtr->curOutPtr->nextAdded > statePtr->curOutPtr->nextRemoved)) {
        statePtr->flags |= BUFFER_READY;
        outputBuffered +=
            (statePtr->curOutPtr->nextAdded - statePtr->curOutPtr->nextRemoved);
    }
d5399 1
a5399 1
        return -1;
d5438 1
a5438 1
	    return -1;
d5460 2
a5461 1
         * caller.
d5464 16
a5479 5
        curPos = (chanPtr->typePtr->seekProc) (chanPtr->instanceData,
                (long) offset, mode, &result);
        if (curPos == -1) {
            Tcl_SetErrno(result);
        }
d5493 1
a5493 1
	    return -1;
d5519 1
a5519 1
int
d5525 1
a5525 2
    ChannelBuffer *bufPtr;
    int inputBuffered, outputBuffered;
d5527 1
a5527 1
    int curPos;				/* Position on device. */
d5530 1
a5530 1
	return -1;
d5541 1
a5541 1
	return -1;
d5557 1
a5557 1
        return -1;
d5565 2
a5566 16
    for (bufPtr = statePtr->inQueueHead, inputBuffered = 0;
	 bufPtr != (ChannelBuffer *) NULL;
	 bufPtr = bufPtr->nextPtr) {
        inputBuffered += (bufPtr->nextAdded - bufPtr->nextRemoved);
    }
    for (bufPtr = statePtr->outQueueHead, outputBuffered = 0;
	 bufPtr != (ChannelBuffer *) NULL;
	 bufPtr = bufPtr->nextPtr) {
        outputBuffered += (bufPtr->nextAdded - bufPtr->nextRemoved);
    }
    if ((statePtr->curOutPtr != (ChannelBuffer *) NULL) &&
	    (statePtr->curOutPtr->nextAdded > statePtr->curOutPtr->nextRemoved)) {
        statePtr->flags |= BUFFER_READY;
        outputBuffered +=
            (statePtr->curOutPtr->nextAdded - statePtr->curOutPtr->nextRemoved);
    }
d5570 1
a5570 1
        return -1;
d5575 2
a5576 1
     * where the next character will be read or written.
d5579 9
a5587 3
    curPos = (chanPtr->typePtr->seekProc) (chanPtr->instanceData,
            (long) 0, SEEK_CUR, &result);
    if (curPos == -1) {
d5589 1
a5589 1
        return -1;
d5592 1
a5592 1
        return (curPos - inputBuffered);
d5594 43
a5636 1
    return (curPos + outputBuffered);
d5717 1
a5717 1
	
d5830 42
d6013 2
a6014 2
    char *optionName;			/* 'bad option' name */
    char *optionList;			/* Specific options list to append 
d6023 1
a6023 1
	char **argv;
d6028 1
a6028 1
	Tcl_DStringAppend(&ds, (char *) genericopt, -1);
d6076 1
a6076 1
    char *optionName;		/* Option to get. */
d6211 4
d6255 4
d6308 2
a6309 2
    char *optionName;		/* Which option to set? */
    char *newValue;		/* New value for option. */
a6310 1
    int newMode;		/* New (numeric) mode to sert. */
d6315 1
a6315 1
    char **argv;
d6351 1
d6402 9
d6437 2
a6438 2
                        "bad value for -eofchar: should be a list of one or",
                        " two elements", (char *) NULL);
d6450 1
a6450 1
        if (argv != (char **) NULL) {
d6456 1
a6456 1
	char *readMode, *writeMode;
d6479 1
d6481 1
a6481 1
		newMode = statePtr->inputTranslation;
d6483 1
a6483 1
		newMode = TCL_TRANSLATE_AUTO;
d6485 1
a6485 1
		newMode = TCL_TRANSLATE_LF;
d6490 1
a6490 1
		newMode = TCL_TRANSLATE_LF;
d6492 1
a6492 1
		newMode = TCL_TRANSLATE_CR;
d6494 1
a6494 1
		newMode = TCL_TRANSLATE_CRLF;
d6496 1
a6496 1
		newMode = TCL_PLATFORM_TRANSLATION;
d6514 2
a6515 2
	    if (newMode != statePtr->inputTranslation) {
		statePtr->inputTranslation = (Tcl_EolTranslation) newMode;
d6532 1
a6532 1
		if (strcmp(chanPtr->typePtr->typeName, "tcp") == 0) {
a6689 1
#ifdef TCL_CHANNEL_VERSION_2
d6706 2
d6710 3
a6712 9

	if ((Tcl_ChannelVersion(upTypePtr) == TCL_CHANNEL_VERSION_2) &&
		(Tcl_ChannelHandlerProc(upTypePtr) !=
			((Tcl_DriverHandlerProc *) NULL))) {

	    Tcl_DriverHandlerProc* handlerProc =
		Tcl_ChannelHandlerProc(upTypePtr);

	  mask = (*handlerProc) (upChanPtr->instanceData, mask);
d6743 1
d6753 2
a6754 2
      FlushChannel(NULL, chanPtr, 1);
      mask &= ~TCL_WRITABLE;
d6767 4
d6772 7
a6778 12
      /*
       * If this channel handler is interested in any of the events that
       * have occurred on the channel, invoke its procedure.
       */
        
      if ((chPtr->mask & mask) != 0) {
	nh.nextHandlerPtr = chPtr->nextPtr;
	(*(chPtr->proc))(chPtr->clientData, mask);
	chPtr = nh.nextHandlerPtr;
      } else {
	chPtr = chPtr->nextPtr;
      }
d6791 1
a6794 73
#else
    /* Walk all channels in a stack ! and notify them in order.
     */

    while (chanPtr != (Channel *) NULL) {
        /*
	 * Preserve the channel struct in case the script closes it.
	 */
     
        Tcl_Preserve((ClientData) channel);

	/*
	 * If we are flushing in the background, be sure to call FlushChannel
	 * for writable events.  Note that we have to discard the writable
	 * event so we don't call any write handlers before the flush is
	 * complete.
	 */

	if ((statePtr->flags & BG_FLUSH_SCHEDULED) && (mask & TCL_WRITABLE)) {
	    FlushChannel(NULL, chanPtr, 1);
	    mask &= ~TCL_WRITABLE;
	}

	/*
	 * Add this invocation to the list of recursive invocations of
	 * ChannelHandlerEventProc.
	 */
    
	nh.nextHandlerPtr = (ChannelHandler *) NULL;
	nh.nestedHandlerPtr = tsdPtr->nestedHandlerPtr;
	tsdPtr->nestedHandlerPtr = &nh;

	for (chPtr = statePtr->chPtr; chPtr != (ChannelHandler *) NULL; ) {

	    /*
	     * If this channel handler is interested in any of the events that
	     * have occurred on the channel, invoke its procedure.
	     */
        
	    if ((chPtr->mask & mask) != 0) {
		nh.nextHandlerPtr = chPtr->nextPtr;
		(*(chPtr->proc))(chPtr->clientData, mask);
		chPtr = nh.nextHandlerPtr;
	    } else {
		chPtr = chPtr->nextPtr;
	    }
	}

	/*
	 * Update the notifier interest, since it may have changed after
	 * invoking event handlers. Skip that if the channel was deleted
	 * in the call to the channel handler.
	 */

	if (chanPtr->typePtr != NULL) {
	    UpdateInterest(chanPtr);

	    /* Walk down the stack.
	     */
	    chanPtr = chanPtr->downChanPtr;
	} else {
	    /* Stop walking the chain, the whole stack was destroyed!
	     */
	    chanPtr = (Channel *) NULL;
	}

	Tcl_Release((ClientData) channel);

	tsdPtr->nestedHandlerPtr = nh.nestedHandlerPtr;

	channel = (Tcl_Channel) chanPtr;
    }
#endif
d6888 13
d6902 3
a6904 1
 
d7294 1
a7294 1
    static char *modeOptions[] = {"readable", "writable", NULL};
d7427 1
a7427 1
		    nonBlocking ? TCL_MODE_BLOCKING : TCL_MODE_NONBLOCKING)
d7498 1
a7498 1
    Tcl_Obj *cmdPtr, *errObj = NULL;
d7501 5
a7505 3
    int result = TCL_OK;
    int size;
    int total;
d7522 9
a7531 1

d7552 1
a7552 1
	    size = csPtr->bufSize;
d7554 1
a7554 1
	    size = csPtr->toRead;
d7556 7
a7562 1
	size = DoRead(inStatePtr->topChanPtr, csPtr->buffer, size);
d7571 1
a7571 1
	} else if (size == 0) {
d7578 1
a7578 1
	    if (Tcl_Eof(inChan)) {
d7580 2
a7581 1
	    } else if (!(mask & TCL_READABLE)) {
d7589 7
a7595 1
	    return TCL_OK;
d7602 19
a7620 2
	size = DoWrite(outStatePtr->topChanPtr, csPtr->buffer, size);
	if (size < 0) {
d7630 20
d7652 2
d7656 1
a7656 1
	if (outStatePtr->flags & BG_FLUSH_SCHEDULED) {
d7659 1
a7659 1
		    Tcl_DeleteChannelHandler(outChan, CopyEventProc,
d7665 4
a7672 9
	 * Update the current byte count if we care.
	 */

	if (csPtr->toRead != -1) {
	    csPtr->toRead -= size;
	}
	csPtr->total += size;

	/*
d7687 4
d7693 5
d7748 2
d8174 1
a8174 1
    char *src;				/* Data to write. */
d8181 1
a8181 1
    char *sPtr;				/* Search variables for newline. */
d8375 1
d8533 1
a8533 1
    char *pattern;		/* pattern to filter on. */
d8535 1
d8537 20
a8556 3
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    char *name;
    Tcl_Obj *resultPtr;
d8558 1
a8558 4
    resultPtr = Tcl_GetObjResult(interp);
    for (statePtr = tsdPtr->firstCSPtr;
	 statePtr != NULL;
	 statePtr = statePtr->nextCSPtr) {
d8566 4
d8572 1
d8585 125
d8723 1
a8723 1
char *
d8727 1
a8727 1
    return (chanTypePtr->typeName);
d8738 1
a8738 1
 *	TCL_CHANNEL_VERSION_2 or TCL_CHANNEL_VERSION_1.
d8752 2
d8766 27
d8803 1
a8803 2
 *----------------------------------------------------------------------
 */
d8809 2
a8810 2
    if (chanTypePtr->version == TCL_CHANNEL_VERSION_2) {
	return (chanTypePtr->blockModeProc);
d8812 3
d8839 1
a8839 1
    return (chanTypePtr->closeProc);
d8862 1
a8862 1
    return (chanTypePtr->close2Proc);
d8885 1
a8885 1
    return (chanTypePtr->inputProc);
d8908 1
a8908 1
    return (chanTypePtr->outputProc);
d8931 1
a8931 1
    return (chanTypePtr->seekProc);
d8954 1
a8954 1
    return (chanTypePtr->setOptionProc);
d8977 1
a8977 1
    return (chanTypePtr->getOptionProc);
d9000 1
a9000 1
    return (chanTypePtr->watchProc);
d9023 1
a9023 1
    return (chanTypePtr->getHandleProc);
d9046 5
a9050 1
    return (chanTypePtr->flushProc);
d9073 5
a9077 1
    return (chanTypePtr->handlerProc);
d9079 16
d9096 10
@


1.3
log
@touched all sources to ease next import
@
text
@@


1.3.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d13 1
a13 1
 * RCS: @@(#) $Id: tclIO.c,v 1.57 2002/07/30 18:36:25 andreas_kupries Exp $
d95 2
a96 1
				Channel *chanPtr, char *result, int space));
a106 2
static int              DetachChannel _ANSI_ARGS_((Tcl_Interp *interp,
				Tcl_Channel chan));
d113 1
a113 1
static int		DoWrite _ANSI_ARGS_((Channel *chanPtr, CONST char *src,
a114 4
static int		DoReadChars _ANSI_ARGS_ ((Channel* chan,
				Tcl_Obj* objPtr, int toRead, int appendFlag));
static int		DoWriteChars _ANSI_ARGS_ ((Channel* chan,
				CONST char* src, int len));
a120 2
static int		HaveVersion _ANSI_ARGS_((Tcl_ChannelType *typePtr,
				Tcl_ChannelTypeVersion minimumVersion));
d127 2
a128 2
				Tcl_Obj *objPtr, int charsLeft,
				int *offsetPtr, int *factorPtr));
d137 2
a138 2
				char *dst, CONST char *src,
				int *dstLenPtr, int *srcLenPtr));
d140 2
a141 2
				char *dst, CONST char *src,
				int *dstLenPtr, int *srcLenPtr));
a685 32
 * Tcl_IsStandardChannel --
 *
 *	Test if the given channel is a standard channel.  No attempt
 *	is made to check if the channel or the standard channels
 *	are initialized or otherwise valid.
 *
 * Results:
 *	Returns 1 if true, 0 if false.
 *
 * Side effects:
 *      None.
 *
 *----------------------------------------------------------------------
 */
int 
Tcl_IsStandardChannel(chan)
    Tcl_Channel chan;		/* Channel to check. */
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    if ((chan == tsdPtr->stdinChannel) 
	|| (chan == tsdPtr->stdoutChannel)
	|| (chan == tsdPtr->stderrChannel)) {
	return 1;
    } else {
	return 0;
    }
}

/*
 *----------------------------------------------------------------------
 *
d721 1
a721 1
    if (statePtr->channelName == (CONST char *) NULL) {
d746 1
a746 5
 *	reference count.  (This all happens in the Tcl_DetachChannel helper
 *	function).
 *	
 *	Finally, if the reference count of the channel drops to zero,
 *	it is deleted.
d752 1
a752 5
 *	Calls Tcl_DetachChannel which deletes the hash entry for a channel 
 *	associated with an interpreter.
 *	
 *	May delete the channel, which can have a variety of consequences,
 *	especially if we are forced to close the channel.
d762 3
d767 31
a797 2
    if (DetachChannel(interp, chan) != TCL_OK) {
        return TCL_OK;
d799 2
a801 2
    statePtr = ((Channel *) chan)->state->bottomChanPtr->state;

d828 1
a828 1
	Tcl_Preserve((ClientData)statePtr);
d830 3
a832 8
	    /* We don't want to re-enter Tcl_Close */
	    if (!(statePtr->flags & CHANNEL_CLOSED)) {
		if (Tcl_Close(interp, chan) != TCL_OK) {
		    statePtr->flags |= CHANNEL_CLOSED;
		    Tcl_Release((ClientData)statePtr);
		    return TCL_ERROR;
		}
	    }
a833 2
        statePtr->flags |= CHANNEL_CLOSED;
	Tcl_Release((ClientData)statePtr);
a838 123
 *----------------------------------------------------------------------
 *
 * Tcl_DetachChannel --
 *
 *	Deletes the hash entry for a channel associated with an interpreter.
 *	If the interpreter given as argument is NULL, it only decrements the
 *	reference count.  Even if the ref count drops to zero, the 
 *	channel is NOT closed or cleaned up.  This allows a channel to
 *	be detached from an interpreter and left in the same state it
 *	was in when it was originally returned by 'Tcl_OpenFileChannel',
 *	for example.
 *	
 *	This function cannot be used on the standard channels, and
 *	will return TCL_ERROR if that is attempted.
 *	
 *	This function should only be necessary for special purposes
 *	in which you need to generate a pristine channel from one
 *	that has already been used.  All ordinary purposes will almost
 *	always want to use Tcl_UnregisterChannel instead.
 *	
 *	Provided the channel is not attached to any other interpreter,
 *	it can then be closed with Tcl_Close, rather than with 
 *	Tcl_UnregisterChannel.
 *
 * Results:
 *	A standard Tcl result.  If the channel is not currently registered
 *	with the given interpreter, TCL_ERROR is returned, otherwise
 *	TCL_OK.  However no error messages are left in the interp's result.
 *
 * Side effects:
 *	Deletes the hash entry for a channel associated with an 
 *	interpreter.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_DetachChannel(interp, chan)
    Tcl_Interp *interp;		/* Interpreter in which channel is defined. */
    Tcl_Channel chan;		/* Channel to delete. */
{
    if (Tcl_IsStandardChannel(chan)) {
        return TCL_ERROR;
    }
    
    return DetachChannel(interp, chan);
}

/*
 *----------------------------------------------------------------------
 *
 * DetachChannel --
 *
 *	Deletes the hash entry for a channel associated with an interpreter.
 *	If the interpreter given as argument is NULL, it only decrements the
 *	reference count.  Even if the ref count drops to zero, the 
 *	channel is NOT closed or cleaned up.  This allows a channel to
 *	be detached from an interpreter and left in the same state it
 *	was in when it was originally returned by 'Tcl_OpenFileChannel',
 *	for example.
 *
 * Results:
 *	A standard Tcl result.  If the channel is not currently registered
 *	with the given interpreter, TCL_ERROR is returned, otherwise
 *	TCL_OK.  However no error messages are left in the interp's result.
 *
 * Side effects:
 *	Deletes the hash entry for a channel associated with an 
 *	interpreter.
 *
 *----------------------------------------------------------------------
 */

static int
DetachChannel(interp, chan)
    Tcl_Interp *interp;		/* Interpreter in which channel is defined. */
    Tcl_Channel chan;		/* Channel to delete. */
{
    Tcl_HashTable *hTblPtr;	/* Hash table of channels. */
    Tcl_HashEntry *hPtr;	/* Search variable. */
    Channel *chanPtr;		/* The real IO channel. */
    ChannelState *statePtr;	/* State of the real channel. */

    /*
     * Always (un)register bottom-most channel in the stack.  This makes
     * management of the channel list easier because no manipulation is
     * necessary during (un)stack operation.
     */
    chanPtr = ((Channel *) chan)->state->bottomChanPtr;
    statePtr = chanPtr->state;

    if (interp != (Tcl_Interp *) NULL) {
	hTblPtr = (Tcl_HashTable *) Tcl_GetAssocData(interp, "tclIO", NULL);
	if (hTblPtr == (Tcl_HashTable *) NULL) {
	    return TCL_ERROR;
	}
	hPtr = Tcl_FindHashEntry(hTblPtr, statePtr->channelName);
	if (hPtr == (Tcl_HashEntry *) NULL) {
	    return TCL_ERROR;
	}
	if ((Channel *) Tcl_GetHashValue(hPtr) != chanPtr) {
	    return TCL_ERROR;
	}
	Tcl_DeleteHashEntry(hPtr);

	/*
	 * Remove channel handlers that refer to this interpreter, so that they
	 * will not be present if the actual close is delayed and more events
	 * happen on the channel. This may occur if the channel is shared
	 * between several interpreters, or if the channel has async
	 * flushing active.
	 */
    
	CleanupChannelHandlers(interp, chanPtr);
    }

    statePtr->refCount--;
    
    return TCL_OK;
}


/*
d862 1
a862 1
    CONST char *chanName;	/* The name of the channel. */
d871 1
a871 1
    CONST char *name;		/* Translated name. */
d940 1
a940 1
    CONST char *chanName;	/* Name of channel to record. */
a962 4
    /*
     * JH: We could subsequently memset these to 0 to avoid the
     * numerous assignments to 0/NULL below.
     */
d976 2
a977 3
	char *tmp = ckalloc((unsigned) (strlen(chanName) + 1));
        statePtr->channelName = tmp;
        strcpy(tmp, chanName);
a1046 11
     *
     * JH: Could call Tcl_SpliceChannel, but need to avoid NULL check.
     */

    statePtr->nextCSPtr	= tsdPtr->firstCSPtr;
    tsdPtr->firstCSPtr	= statePtr;

    /*
     * TIP #10. Mark the current thread as the one managing the new
     *          channel. Note: 'Tcl_GetCurrentThread' returns sensible
     *          values even for a non-threaded core.
d1049 2
a1050 1
    statePtr->managingThread = Tcl_GetCurrentThread ();
a1467 26
 * Tcl_GetChannelThread --
 *
 *	Given a channel structure, returns the thread managing it.
 *	TIP #10
 *
 * Results:
 *	Returns the id of the thread managing the channel.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_ThreadId
Tcl_GetChannelThread(chan)
    Tcl_Channel chan;		/* The channel to return managing thread for. */
{
    Channel *chanPtr = (Channel *) chan;	/* The actual channel. */

    return chanPtr->state->managingThread;
}

/*
 *----------------------------------------------------------------------
 *
d1536 1
a1536 1
CONST char *
a1659 11
     * Only save buffers which are at least as big as the requested
     * buffersize for the channel. This is to honor dynamic changes
     * of the buffersize made by the user.
     */

    if ((bufPtr->bufLength - BUFFER_PADDING) < statePtr->bufSize) {
        ckfree((char *) bufPtr);
        return;
    }

    /*
d1868 1
a1868 1
                bufPtr->buf + bufPtr->nextRemoved, toWrite,
a1918 7

		    /*
		     * Casting away CONST here is safe because the
		     * TCL_VOLATILE flag guarantees CONST treatment
		     * of the Posix error string.
		     */

d1920 1
a1920 1
			    (char *) Tcl_PosixError(interp), TCL_VOLATILE);
d2015 3
d2062 8
d2072 1
a2072 1
     * Remove this channel from of the list of all channels.
d2074 20
a2093 1
    Tcl_CutChannel((Tcl_Channel) chanPtr);
d2114 1
a2114 1
	    ckfree((char *) statePtr->channelName);
d2151 17
d2179 1
d2184 1
a2184 4
     * pointers we have and then ourselves.  Since this is the
     * last of the channels in the stack, make sure to free the
     * ChannelState structure associated with it.  We use
     * Tcl_EventuallyFree to allow for any last
a2187 1
    Tcl_EventuallyFree((ClientData) statePtr, TCL_DYNAMIC);
a2195 112
 * Tcl_CutChannel --
 *
 *	Removes a channel from the (thread-)global list of all channels
 *	(in that thread).  This is actually the statePtr for the stack
 *	of channel.
 *
 * Results:
 *	Nothing.
 *
 * Side effects:
 *	Resets the field 'nextCSPtr' of the specified channel state to NULL.
 *
 * NOTE:
 *	The channel to splice out of the list must not be referenced
 *	in any interpreter. This is something this procedure cannot
 *	check (despite the refcount) because the caller usually wants
 *	fiddle with the channel (like transfering it to a different
 *	thread) and thus keeps the refcount artifically high to prevent
 *	its destruction.
 *
 *----------------------------------------------------------------------
 */

void
Tcl_CutChannel(chan)
    Tcl_Channel chan;			/* The channel being removed. Must
                                         * not be referenced in any
                                         * interpreter. */
{
    ThreadSpecificData* tsdPtr  = TCL_TSD_INIT(&dataKey);
    ChannelState *prevCSPtr;		/* Preceding channel state in list of
                                         * all states - used to splice a
                                         * channel out of the list on close. */
    ChannelState *statePtr = ((Channel *) chan)->state;
					/* state of the channel stack. */

    /*
     * Remove this channel from of the list of all channels
     * (in the current thread).
     */

    if (tsdPtr->firstCSPtr && (statePtr == tsdPtr->firstCSPtr)) {
        tsdPtr->firstCSPtr = statePtr->nextCSPtr;
    } else {
        for (prevCSPtr = tsdPtr->firstCSPtr;
	     prevCSPtr && (prevCSPtr->nextCSPtr != statePtr);
	     prevCSPtr = prevCSPtr->nextCSPtr) {
            /* Empty loop body. */
        }
        if (prevCSPtr == (ChannelState *) NULL) {
            panic("FlushChannel: damaged channel list");
        }
        prevCSPtr->nextCSPtr = statePtr->nextCSPtr;
    }

    statePtr->nextCSPtr = (ChannelState *) NULL;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_SpliceChannel --
 *
 *	Adds a channel to the (thread-)global list of all channels
 *	(in that thread). Expects that the field 'nextChanPtr' in
 *	the channel is set to NULL.
 *
 * Results:
 *	Nothing.
 *
 * Side effects:
 *	Nothing.
 *
 * NOTE:
 *	The channel to add to the list must not be referenced in any
 *	interpreter. This is something this procedure cannot check
 *	(despite the refcount) because the caller usually wants figgle
 *	with the channel (like transfering it to a different thread)
 *	and thus keeps the refcount artifically high to prevent its
 *	destruction.
 *
 *----------------------------------------------------------------------
 */

void
Tcl_SpliceChannel(chan)
    Tcl_Channel chan;			/* The channel being added. Must
                                         * not be referenced in any
                                         * interpreter. */
{
    ThreadSpecificData	*tsdPtr = TCL_TSD_INIT(&dataKey);
    ChannelState	*statePtr = ((Channel *) chan)->state;

    if (statePtr->nextCSPtr != (ChannelState *) NULL) {
        panic("Tcl_SpliceChannel: trying to add channel used in different list");
    }

    statePtr->nextCSPtr	= tsdPtr->firstCSPtr;
    tsdPtr->firstCSPtr	= statePtr;

    /*
     * TIP #10. Mark the current thread as the new one managing this
     *          channel. Note: 'Tcl_GetCurrentThread' returns sensible
     *          values even for a non-threaded core.
     */

    statePtr->managingThread = Tcl_GetCurrentThread ();
}

/*
 *----------------------------------------------------------------------
 *
d2223 1
d2226 1
d2230 2
a2259 94
     * When the channel has an escape sequence driven encoding such as
     * iso2022, the terminated escape sequence must write to the buffer.
     */
    if ((statePtr->encoding != NULL) && (statePtr->curOutPtr != NULL)
	    && (CheckChannelErrors(statePtr, TCL_WRITABLE) == 0)) {
        statePtr->outputEncodingFlags |= TCL_ENCODING_END;
        WriteChars(chanPtr, "", 0);
    }

    Tcl_ClearChannelHandlers(chan);

    /*
     * Invoke the registered close callbacks and delete their records.
     */

    while (statePtr->closeCbPtr != (CloseCallback *) NULL) {
        cbPtr = statePtr->closeCbPtr;
        statePtr->closeCbPtr = cbPtr->nextPtr;
        (cbPtr->proc) (cbPtr->clientData);
        ckfree((char *) cbPtr);
    }

    /*
     * Ensure that the last output buffer will be flushed.
     */
    
    if ((statePtr->curOutPtr != (ChannelBuffer *) NULL) &&
	    (statePtr->curOutPtr->nextAdded > statePtr->curOutPtr->nextRemoved)) {
        statePtr->flags |= BUFFER_READY;
    }

    /*
     * If this channel supports it, close the read side, since we don't need it
     * anymore and this will help avoid deadlocks on some channel types.
     */

    if (chanPtr->typePtr->closeProc == TCL_CLOSE2PROC) {
	result = (chanPtr->typePtr->close2Proc)(chanPtr->instanceData, interp,
		TCL_CLOSE_READ);
    } else {
	result = 0;
    }

    /*
     * The call to FlushChannel will flush any queued output and invoke
     * the close function of the channel driver, or it will set up the
     * channel to be flushed and closed asynchronously.
     */

    statePtr->flags |= CHANNEL_CLOSED;
    if ((FlushChannel(interp, chanPtr, 0) != 0) || (result != 0)) {
        return TCL_ERROR;
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_ClearChannelHandlers --
 *
 *	Removes all channel handlers and event scripts from the channel,
 *	cancels all background copies involving the channel and any interest
 *	in events.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	See above. Deallocates memory.
 *
 *----------------------------------------------------------------------
 */

void
Tcl_ClearChannelHandlers (channel)
    Tcl_Channel channel;
{
    ChannelHandler *chPtr, *chNext;	/* Iterate over channel handlers. */
    EventScriptRecord *ePtr, *eNextPtr;	/* Iterate over eventscript records. */
    Channel *chanPtr;			/* The real IO channel. */
    ChannelState *statePtr;		/* State of real IO channel. */
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    NextChannelHandler *nhPtr;

    /*
     * This operation should occur at the top of a channel stack.
     */

    chanPtr	= (Channel *) channel;
    statePtr	= chanPtr->state;
    chanPtr	= statePtr->topChanPtr;

    /*
d2313 44
d2367 1
a2367 4
 *	line buffering mode. Compensates stacking, i.e. will redirect the
 *	data from the specified channel to the topmost channel in a stack.
 *
 *	No encoding conversions are applied to the bytes being read.
d2383 1
a2383 1
    CONST char *src;			/* Data to queue in output buffer. */
d2414 1
a2414 4
 *	line buffering mode. Writes directly to the driver of the channel,
 *	does not compensate for stacking.
 *
 *	No encoding conversions are applied to the bytes being read.
d2430 1
a2430 1
    CONST char *src;			/* Data to queue in output buffer. */
d2470 1
a2470 43
 *	line buffering mode. Compensates stacking, i.e. will redirect the
 *	data from the specified channel to the topmost channel in a stack.
 *
 * Results:
 *	The number of bytes written or -1 in case of error. If -1,
 *	Tcl_GetErrno will return the error code.
 *
 * Side effects:
 *	May buffer up output and may cause output to be produced on the
 *	channel.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_WriteChars(chan, src, len)
    Tcl_Channel chan;		/* The channel to buffer output for. */
    CONST char *src;		/* UTF-8 characters to queue in output buffer. */
    int len;			/* Length of string in bytes, or < 0 for 
				 * strlen(). */
{
    ChannelState *statePtr;	/* state info for channel */

    statePtr = ((Channel *) chan)->state;

    if (CheckChannelErrors(statePtr, TCL_WRITABLE) != 0) {
	return -1;
    }

    return DoWriteChars ((Channel*) chan, src, len);
}

/*
 *---------------------------------------------------------------------------
 *
 * DoWriteChars --
 *
 *	Takes a sequence of UTF-8 characters and converts them for output
 *	using the channel's current encoding, may queue the buffer for
 *	output if it gets full, and also remembers whether the current
 *	buffer is ready e.g. if it contains a newline and we are in
 *	line buffering mode. Compensates stacking, i.e. will redirect the
 *	data from the specified channel to the topmost channel in a stack.
d2483 3
a2485 3
static int
DoWriteChars(chanPtr, src, len)
    Channel* chanPtr;		/* The channel to buffer output for. */
d2493 1
d2496 1
a2496 1
    statePtr = chanPtr->state;
d2499 3
d2606 1
a2606 1
    int dstMax, sawLF, savedLF, total, dstLen, toWrite;
d2694 2
a2695 3
    int saved, savedLF, sawLF, total, dstLen, stageMax, dstWrote;
    int stageLen, toWrite, stageRead, endEncoding, result;
    int consumedSomething;
a2705 6
     * Write the terminated escape sequence even if srcLen is 0.
     */

    endEncoding = ((statePtr->outputEncodingFlags & TCL_ENCODING_END) != 0);

    /*
d2710 1
a2710 3
    consumedSomething = 1;
    while (consumedSomething && (srcLen + savedLF + endEncoding > 0)) {
        consumedSomething = 0;
d2745 5
d2755 1
a2755 1
	while (stageLen + saved + endEncoding > 0) {
d2778 1
a2778 2
	    result = Tcl_UtfToExternal(NULL, encoding, stage, stageLen,
		    statePtr->outputEncodingFlags,
d2781 1
a2781 21

	    /* Fix for SF #506297, reported by Martin Forssen
	     * <ruric@@users.sourceforge.net>.
	     *
	     * The encoding chosen in the script exposing the bug writes out
	     * three intro characters when TCL_ENCODING_START is set, but does
	     * not consume any input as TCL_ENCODING_END is cleared. As some
	     * output was generated the enclosing loop calls UtfToExternal
	     * again, again with START set. Three more characters in the out
	     * and still no use of input ... To break this infinite loop we
	     * remove TCL_ENCODING_START from the set of flags after the first
	     * call (no condition is required, the later calls remove an unset
	     * flag, which is a no-op). This causes the subsequent calls to
	     * UtfToExternal to consume and convert the actual input.
	     */

	    statePtr->outputEncodingFlags &= ~TCL_ENCODING_START;
	    /*
	     * The following code must be executed only when result is not 0.
	     */
	    if (result && ((stageRead + dstWrote) == 0)) {
a2816 12

	    consumedSomething = 1;

	    /*
	     * If all translated characters are written to the buffer,
	     * endEncoding is set to 0 because the escape sequence may be
	     * output.
	     */

	    if ((stageLen + saved == 0) && (result == 0)) {
		endEncoding = 0;
	    }
a2818 9

    /* If nothing was written and it happened because there was no progress
     * in the UTF conversion, we throw an error.
     */

    if (!consumedSomething && (total == 0)) {
        Tcl_SetErrno (EINVAL);
        return -1;
    }
d3078 1
a3078 1
    int inEofChar, skip, copiedTotal, oldLength, oldFlags, oldRemoved;
d3082 1
d3291 1
a3291 1
	    if (eol == objPtr->bytes + oldLength) {
d3293 1
a3293 1
		 * If we didn't append any bytes before encountering EOF,
d3297 1
a3297 1
		Tcl_SetObjLength(objPtr, oldLength);
d3320 2
a3321 3
	    &statePtr->inputEncodingState, dst,
	    eol - dst + skip + TCL_UTF_MAX, &gs.rawRead, NULL,
	    &gs.charsWrote);
d3412 1
a3412 1
#define ENCODING_LINESIZE   20	/* Lower bound on how many bytes to convert
d3441 1
a3441 1

d3494 1
a3494 8
	    &gsPtr->charsWrote);

    /*
     * Make sure that if we go through 'gets', that we reset the
     * TCL_ENCODING_START flag still.  [Bug #523988]
     */
    statePtr->inputEncodingFlags &= ~TCL_ENCODING_START;

d3765 1
a3765 1
    char *bufPtr;		/* Where to store input read. */
d3809 8
a3816 13
	    if ((statePtr->flags & CHANNEL_TIMER_FEV) &&
		(statePtr->flags & CHANNEL_NONBLOCKING)) {
	        nread  = -1;
	        result = EWOULDBLOCK;
	    } else {
	      /*
	       * Now go to the driver to get as much as is possible to
	       * fill the remaining request. Do all the error handling
	       * by ourselves.  The code was stolen from 'GetInput' and
	       * slightly adapted (different return value here).
	       *
	       * The case of 'bytesToRead == 0' at this point cannot happen.
	       */
d3818 1
a3818 1
	      nread = (chanPtr->typePtr->inputProc)(chanPtr->instanceData,
a3819 1
	    }
d3896 6
a3901 2
    Channel*      chanPtr  = (Channel *) chan;
    ChannelState* statePtr = chanPtr->state;	/* state info for channel */
d3910 2
a3911 6
        /*
	 * Update the notifier state so we don't block while there is still
	 * data in the buffers.
	 */
        UpdateInterest(chanPtr);
	return -1;
a3913 48
    return DoReadChars (chanPtr, objPtr, toRead, appendFlag);
}
/*
 *---------------------------------------------------------------------------
 *
 * DoReadChars --
 *
 *	Reads from the channel until the requested number of characters
 *	have been seen, EOF is seen, or the channel would block.  EOL
 *	and EOF translation is done.  If reading binary data, the raw
 *	bytes are wrapped in a Tcl byte array object.  Otherwise, the raw
 *	bytes are converted to UTF-8 using the channel's current encoding
 *	and stored in a Tcl string object.
 *
 * Results:
 *	The number of characters read, or -1 on error. Use Tcl_GetErrno()
 *	to retrieve the error code for the error that occurred.
 *
 * Side effects:
 *	May cause input to be buffered.
 *
 *---------------------------------------------------------------------------
 */
 
static int
DoReadChars(chanPtr, objPtr, toRead, appendFlag)
    Channel* chanPtr;		/* The channel to read. */
    Tcl_Obj *objPtr;		/* Input data is stored in this object. */
    int toRead;			/* Maximum number of characters to store,
				 * or -1 to read all available data (up to EOF
				 * or when channel blocks). */
    int appendFlag;		/* If non-zero, data read from the channel
				 * will be appended to the object.  Otherwise,
				 * the data will replace the existing contents
				 * of the object. */

{
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    ChannelBuffer *bufPtr;
    int offset, factor, copied, copiedNow, result;
    Tcl_Encoding encoding;
#define UTF_EXPANSION_FACTOR	1024
    
    /*
     * This operation should occur at the top of a channel stack.
     */

    chanPtr  = statePtr->topChanPtr;
d3915 1
a3915 1
    factor   = UTF_EXPANSION_FACTOR;
d3954 1
a3954 1
		    statePtr->inQueueTail = NULL;
d4026 8
a4038 8
    int bytesToRead;		/* Maximum number of bytes to store,
				 * or < 0 to get all available bytes.
				 * Bytes are obtained from the first
				 * buffer in the queue -- even if this number
				 * is larger than the number of bytes
				 * available in the first buffer, only the
				 * bytes from the first buffer are
				 * returned. */
d4044 1
a4044 1
    int toRead, srcLen, offset, length, srcRead, dstWrote;
a4129 4
    Tcl_Obj *objPtr;		/* Input data is appended to this object.
				 * objPtr->length is how much space has been
				 * allocated to hold data, not how many bytes
				 * of data have been stored in the object. */
d4138 4
d4152 2
a4153 2
    int toRead, factor, offset, spaceLeft, length, srcLen, dstNeeded;
    int srcRead, dstWrote, numChars, dstRead;
d4166 1
a4166 1
    if ((unsigned)toRead > (unsigned)srcLen) {
d4248 5
a4252 14
	    if (srcLen > 0) {
	        /*
		 * There isn't enough data in the buffers to complete the next
		 * character, so we need to wait for more data before the next
		 * file event can be delivered.
		 *
		 * SF #478856.
		 *
		 * The exception to this is if the input buffer was
		 * completely empty before we tried to convert its
		 * contents. Nothing in, nothing out, and no incomplete
		 * character data. The conversion before the current one
		 * was complete.
		 */
d4254 1
a4254 2
	        statePtr->flags |= CHANNEL_NEED_MORE_DATA;
	    }
d4269 1
a4269 3
	 * EOF was located in dst? Run the conversion again with an
	 * output buffer just big enough to hold the data so we can
	 * get the correct value for srcRead.
d4295 1
a4295 1
	CONST char *eof;
d4508 1
a4508 1
    CONST char *str;		/* The input itself. */
a4756 13

	/*
	 * Check the actual buffersize against the requested
	 * buffersize. Buffers which are smaller than requested are
	 * squashed. This is done to honor dynamic changes of the
	 * buffersize made by the user.
	 */

	if ((bufPtr != NULL) && ((bufPtr->bufLength - BUFFER_PADDING) < statePtr->bufSize)) {
	  ckfree((char *) bufPtr);
	  bufPtr = NULL;
	}

d4762 1
a4762 15
	/* SF #427196: Use the actual size of the buffer to determine
	 * the number of bytes to read from the channel and not the
	 * size for new buffers. They can be different if the
	 * buffersize was changed between reads.
	 *
	 * Note: This affects performance negatively if the buffersize
	 * was extended but this small buffer is reused for all
	 * subsequent reads. The system never uses buffers with the
	 * requested bigger size in that case. An adjunct patch could
	 * try and delete all unused buffers it encounters and which
	 * are smaller than the formally requested buffersize.
	 */

	toRead = bufPtr->bufLength - bufPtr->nextAdded;

d4770 1
a4770 1

d4780 2
a4781 8
    if ((statePtr->flags & CHANNEL_TIMER_FEV) &&
	(statePtr->flags & CHANNEL_NONBLOCKING)) {
        nread = -1;
        result = EWOULDBLOCK;
    } else {
        nread = (chanPtr->typePtr->inputProc)(chanPtr->instanceData,
		    bufPtr->buf + bufPtr->nextAdded, toRead, &result);
    }
d4806 1
a4806 1
    }
d4828 1
a4828 1
Tcl_WideInt
d4831 1
a4831 1
    Tcl_WideInt offset;		/* Offset to seek to. */
d4836 1
a4837 1
				/* # bytes held in buffers. */
d4839 1
a4839 1
    Tcl_WideInt curPos;		/* Position on the device. */
d4845 1
a4845 1
	return Tcl_LongAsWide(-1);
d4855 1
a4855 3
    if (CheckForDeadChannel(NULL, statePtr)) {
	return Tcl_LongAsWide(-1);
    }
d4870 1
a4870 1
        return Tcl_LongAsWide(-1);
d4878 27
a4904 2
    inputBuffered = Tcl_InputBuffered(chan);
    outputBuffered = Tcl_OutputBuffered(chan);
d4908 1
a4908 1
        return Tcl_LongAsWide(-1);
d4947 1
a4947 1
	    return Tcl_LongAsWide(-1);
d4969 1
a4969 2
         * caller.  Note that we prefer the wideSeekProc if that is
	 * available and non-NULL...
d4972 5
a4976 16
	if (HaveVersion(chanPtr->typePtr, TCL_CHANNEL_VERSION_3) &&
		chanPtr->typePtr->wideSeekProc != NULL) {
	    curPos = (chanPtr->typePtr->wideSeekProc) (chanPtr->instanceData,
		    offset, mode, &result);
	} else if (offset < Tcl_LongAsWide(LONG_MIN) ||
		offset > Tcl_LongAsWide(LONG_MAX)) {
	    Tcl_SetErrno(EOVERFLOW);
	    curPos = Tcl_LongAsWide(-1);
	} else {
	    curPos = Tcl_LongAsWide((chanPtr->typePtr->seekProc) (
		    chanPtr->instanceData, Tcl_WideAsLong(offset), mode,
		    &result));
	    if (curPos == Tcl_LongAsWide(-1)) {
		Tcl_SetErrno(result);
	    }
	}
d4990 1
a4990 1
	    return Tcl_LongAsWide(-1);
d5016 1
a5016 1
Tcl_WideInt
d5022 2
a5023 1
    int inputBuffered, outputBuffered;	/* # bytes held in buffers. */
d5025 1
a5025 1
    Tcl_WideInt curPos;			/* Position on device. */
d5028 1
a5028 1
	return Tcl_LongAsWide(-1);
d5039 1
a5039 1
	return Tcl_LongAsWide(-1);
d5055 1
a5055 1
        return Tcl_LongAsWide(-1);
d5063 16
a5078 2
    inputBuffered = Tcl_InputBuffered(chan);
    outputBuffered = Tcl_OutputBuffered(chan);
d5082 1
a5082 1
        return Tcl_LongAsWide(-1);
d5087 1
a5087 2
     * where the next character will be read or written.  Note that we
     * prefer the wideSeekProc if that is available and non-NULL...
d5090 3
a5092 9
    if (HaveVersion(chanPtr->typePtr, TCL_CHANNEL_VERSION_3) &&
	    chanPtr->typePtr->wideSeekProc != NULL) {
	curPos = (chanPtr->typePtr->wideSeekProc) (chanPtr->instanceData,
		Tcl_LongAsWide(0), SEEK_CUR, &result);
    } else {
	curPos = Tcl_LongAsWide((chanPtr->typePtr->seekProc) (
		chanPtr->instanceData, 0, SEEK_CUR, &result));
    }
    if (curPos == Tcl_LongAsWide(-1)) {
d5094 1
a5094 1
        return Tcl_LongAsWide(-1);
d5097 1
a5097 1
        return curPos - inputBuffered;
d5099 1
a5099 43
    return curPos + outputBuffered;
}

/*
 *---------------------------------------------------------------------------
 *
 * Tcl_SeekOld, Tcl_TellOld --
 *
 *	Backward-compatability versions of the seek/tell interface that
 *	do not support 64-bit offsets.  This interface is not documented
 *	or expected to be supported indefinitely.
 *
 * Results:
 *	As for Tcl_Seek and Tcl_Tell respectively, except truncated to
 *	whatever value will fit in an 'int'.
 *
 * Side effects:
 *	As for Tcl_Seek and Tcl_Tell respectively.
 *
 *---------------------------------------------------------------------------
 */

int
Tcl_SeekOld(chan, offset, mode)
    Tcl_Channel chan;		/* The channel on which to seek. */
    int offset;			/* Offset to seek to. */
    int mode;			/* Relative to which location to seek? */
{
    Tcl_WideInt wOffset, wResult;

    wOffset = Tcl_LongAsWide((long)offset);
    wResult = Tcl_Seek(chan, wOffset, mode);
    return (int)Tcl_WideAsLong(wResult);
}

int
Tcl_TellOld(chan)
    Tcl_Channel chan;		/* The channel to return pos for. */
{
    Tcl_WideInt wResult;

    wResult = Tcl_Tell(chan);
    return (int)Tcl_WideAsLong(wResult);
d5180 1
a5180 1

a5292 42
 * Tcl_OutputBuffered --
 *
 *    Returns the number of bytes of output currently buffered in the
 *    common internal buffer of a channel.
 *
 * Results:
 *    The number of output bytes buffered, or zero if the channel is not
 *    open for writing.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_OutputBuffered(chan)
    Tcl_Channel chan;                 /* The channel to query. */
{
    ChannelState *statePtr = ((Channel *) chan)->state;
                                      /* State of real channel structure. */
    ChannelBuffer *bufPtr;
    int bytesBuffered;

    for (bytesBuffered = 0, bufPtr = statePtr->outQueueHead;
	bufPtr != (ChannelBuffer *) NULL;
	bufPtr = bufPtr->nextPtr) {
	bytesBuffered += (bufPtr->nextAdded - bufPtr->nextRemoved);
    }
    if ((statePtr->curOutPtr != (ChannelBuffer *) NULL) &&
	(statePtr->curOutPtr->nextAdded > statePtr->curOutPtr->nextRemoved)) {
	statePtr->flags |= BUFFER_READY;
	bytesBuffered +=
	    (statePtr->curOutPtr->nextAdded - statePtr->curOutPtr->nextRemoved);
    }

    return bytesBuffered;
}

/*
 *----------------------------------------------------------------------
 *
d5434 2
a5435 2
    CONST char *optionName;		/* 'bad option' name */
    CONST char *optionList;		/* Specific options list to append 
d5444 1
a5444 1
	CONST char **argv;
d5449 1
a5449 1
	Tcl_DStringAppend(&ds, genericopt, -1);
d5497 1
a5497 1
    CONST char *optionName;	/* Option to get. */
a5631 4
        if ( !(flags & (TCL_READABLE|TCL_WRITABLE))) {
            /* Not readable or writable (server socket) */
            Tcl_DStringAppendElement(dsPtr, "");
        }
a5671 4
        if ( !(flags & (TCL_READABLE|TCL_WRITABLE))) {
            /* Not readable or writable (server socket) */
            Tcl_DStringAppendElement(dsPtr, "auto");
        }
d5721 2
a5722 2
    CONST char *optionName;	/* Which option to set? */
    CONST char *newValue;	/* New value for option. */
d5724 1
d5729 1
a5729 1
    CONST char **argv;
a5764 1
	int newMode;
a5814 9
	/*
	 * When the channel has an escape sequence driven encoding such as
	 * iso2022, the terminated escape sequence must write to the buffer.
	 */
	if ((statePtr->encoding != NULL) && (statePtr->curOutPtr != NULL)
		&& (CheckChannelErrors(statePtr, TCL_WRITABLE) == 0)) {
	    statePtr->outputEncodingFlags |= TCL_ENCODING_END;
	    WriteChars(chanPtr, "", 0);
	}
d5841 2
a5842 2
                        "bad value for -eofchar: should be a list of zero,",
                        " one, or two elements", (char *) NULL);
d5854 1
a5854 1
        if (argv != NULL) {
d5860 1
a5860 1
	CONST char *readMode, *writeMode;
a5882 1
	    TclEolTranslation translation;
d5884 1
a5884 1
		translation = statePtr->inputTranslation;
d5886 1
a5886 1
		translation = TCL_TRANSLATE_AUTO;
d5888 1
a5888 1
		translation = TCL_TRANSLATE_LF;
d5893 1
a5893 1
		translation = TCL_TRANSLATE_LF;
d5895 1
a5895 1
		translation = TCL_TRANSLATE_CR;
d5897 1
a5897 1
		translation = TCL_TRANSLATE_CRLF;
d5899 1
a5899 1
		translation = TCL_PLATFORM_TRANSLATION;
d5917 2
a5918 2
	    if (translation != statePtr->inputTranslation) {
		statePtr->inputTranslation = translation;
d5935 1
a5935 1
		if (strcmp(Tcl_ChannelName(chanPtr->typePtr), "tcp") == 0) {
d6093 1
a6109 2
	Tcl_DriverHandlerProc* upHandlerProc;

d6112 9
a6120 3
	upHandlerProc = Tcl_ChannelHandlerProc(upTypePtr);
	if (upHandlerProc != NULL) {
	    mask = (*upHandlerProc) (upChanPtr->instanceData, mask);
a6150 1
    Tcl_Preserve((ClientData) statePtr);
d6160 2
a6161 2
	FlushChannel(NULL, chanPtr, 1);
	mask &= ~TCL_WRITABLE;
a6173 4
	/*
	 * If this channel handler is interested in any of the events that
	 * have occurred on the channel, invoke its procedure.
	 */
d6175 12
a6186 7
	if ((chPtr->mask & mask) != 0) {
	    nh.nextHandlerPtr = chPtr->nextPtr;
	    (*(chPtr->proc))(chPtr->clientData, mask);
	    chPtr = nh.nextHandlerPtr;
	} else {
	    chPtr = chPtr->nextPtr;
	}
a6198 1
    Tcl_Release((ClientData) statePtr);
d6202 73
a6367 13

	/* Set the TIMER flag to notify the higher levels that the
	 * driver might have no data for us. We do this only if we are
	 * in non-blocking mode and the driver has no BlockModeProc
	 * because only then we really don't know if the driver will
	 * block or not. A similar test is done in "PeekAhead".
	 */

	if ((statePtr->flags & CHANNEL_NONBLOCKING) &&
	    (Tcl_ChannelBlockModeProc(chanPtr->typePtr) == NULL)) {
	    statePtr->flags |= CHANNEL_TIMER_FEV;
	}
	Tcl_Preserve((ClientData) statePtr);
d6369 1
a6369 3

	statePtr->flags &= ~CHANNEL_TIMER_FEV; 
	Tcl_Release((ClientData) statePtr);
d6759 1
a6759 1
    static CONST char *modeOptions[] = {"readable", "writable", NULL};
d6892 1
a6892 1
		    nonBlocking ? TCL_MODE_NONBLOCKING : TCL_MODE_BLOCKING)
d6963 1
a6963 1
    Tcl_Obj *cmdPtr, *errObj = NULL, *bufObj = NULL;
d6966 3
a6968 5
    int result = TCL_OK, size, total, sizeb;
    char* buffer;

    int inBinary, outBinary, sameEncoding; /* Encoding control */
    int underflow;	/* input underflow */
d6985 1
a6985 8
    inBinary     = (inStatePtr->encoding  == NULL);
    outBinary    = (outStatePtr->encoding == NULL);
    sameEncoding = (inStatePtr->encoding  == outStatePtr->encoding);

    if (!(inBinary || sameEncoding)) {
        bufObj = Tcl_NewObj ();
	Tcl_IncrRefCount (bufObj);
    }
a6986 1
    while (csPtr->toRead != 0) {
d7007 1
a7007 1
	    sizeb = csPtr->bufSize;
d7009 1
a7009 1
	    sizeb = csPtr->toRead;
d7011 1
a7011 7

	if (inBinary || sameEncoding) {
	    size = DoRead(inStatePtr->topChanPtr, csPtr->buffer, sizeb);
	} else {
	    size = DoReadChars(inStatePtr->topChanPtr, bufObj, sizeb, 0 /* No append */);
	}
	underflow = (size >= 0) && (size < sizeb);	/* input underflow */
d7020 1
a7020 1
	} else if (underflow) {
d7027 1
a7027 1
	    if ((size == 0) && Tcl_Eof(inChan)) {
d7029 1
a7029 2
	    }
	    if (! Tcl_Eof(inChan) && !(mask & TCL_READABLE)) {
d7037 1
a7037 7
	    if (size == 0) {
	        if (bufObj != (Tcl_Obj*) NULL) {
		    Tcl_DecrRefCount (bufObj);
		    bufObj = (Tcl_Obj*) NULL;
		}
		return TCL_OK;
	    }
d7044 2
a7045 19
	if (inBinary || sameEncoding) {
	    buffer = csPtr->buffer;
	    sizeb = size;
	} else {
	    buffer = Tcl_GetStringFromObj (bufObj, &sizeb);
	}

	if (outBinary || sameEncoding) {
	    sizeb = DoWrite(outStatePtr->topChanPtr, buffer, sizeb);
	} else {
	    sizeb = DoWriteChars(outStatePtr->topChanPtr, buffer, sizeb);
	}

	if (inBinary || sameEncoding) {
	    /* Both read and write counted bytes */
	    size = sizeb;
	} /* else : Read counted characters, write counted bytes, i.e. size != sizeb */

	if (sizeb < 0) {
a7054 20
	 * Update the current byte count.  Do it now so the count is
	 * valid before a return or break takes us out of the loop.
	 * The invariant at the top of the loop should be that 
	 * csPtr->toRead holds the number of bytes left to copy.
	 */

	if (csPtr->toRead != -1) {
	    csPtr->toRead -= size;
	}
	csPtr->total += size;

	/*
	 * Break loop if EOF && (size>0)
	 */

        if (Tcl_Eof(inChan)) {
            break;
        }

	/*
a7056 2
	 * After input underflow we already installed a readable handler
	 * therefore we don't need a writable handler.
d7059 1
a7059 1
	if ( ! underflow && (outStatePtr->flags & BG_FLUSH_SCHEDULED) ) {
d7062 1
a7062 1
		    Tcl_DeleteChannelHandler(inChan, CopyEventProc,
a7067 4
	    if (bufObj != (Tcl_Obj*) NULL) {
	        Tcl_DecrRefCount (bufObj);
		bufObj = (Tcl_Obj*) NULL;
	    }
d7072 9
a7094 4
	    if (bufObj != (Tcl_Obj*) NULL) {
	        Tcl_DecrRefCount (bufObj);
		bufObj = (Tcl_Obj*) NULL;
	    }
a7096 5
    } /* while */

    if (bufObj != (Tcl_Obj*) NULL) {
        Tcl_DecrRefCount (bufObj);
	bufObj = (Tcl_Obj*) NULL;
a7146 2
 *	No encoding conversions are applied to the bytes being read.
 *
d7571 1
a7571 1
    CONST char *src;			/* Data to write. */
d7578 1
a7578 1
    CONST char *sPtr;			/* Search variables for newline. */
a7771 1
	nonBlocking = (csPtr->writeFlags & CHANNEL_NONBLOCKING);
d7929 1
a7929 1
    CONST char *pattern;	/* pattern to filter on. */
d7931 1
d7933 2
a7934 6
    ChannelState *statePtr;
    CONST char *name;		/* name for channel */
    Tcl_Obj *resultPtr;		/* pointer to result object */
    Tcl_HashTable *hTblPtr;	/* Hash table of channels. */
    Tcl_HashEntry *hPtr;	/* Search variable. */
    Tcl_HashSearch hSearch;	/* Search variable. */
d7936 4
a7939 16
    if (interp == (Tcl_Interp *) NULL) {
	return TCL_OK;
    }

    /*
     * Get the channel table that stores the channels registered
     * for this interpreter.
     */
    hTblPtr	= GetChannelTable(interp);
    resultPtr	= Tcl_GetObjResult(interp);

    for (hPtr = Tcl_FirstHashEntry(hTblPtr, &hSearch);
	 hPtr != (Tcl_HashEntry *) NULL;
	 hPtr = Tcl_NextHashEntry(&hSearch)) {

	statePtr = ((Channel *) Tcl_GetHashValue(hPtr))->state;
a7946 4
	    /*
	     * This is also stored in Tcl_GetHashKey(hTblPtr, hPtr),
	     * but it's simpler to just grab the name from the statePtr.
	     */
a7948 1

a7960 125
 * Tcl_IsChannelRegistered --
 *
 *	Checks whether the channel is associated with the interp.
 *	See also Tcl_RegisterChannel and Tcl_UnregisterChannel.
 *
 * Results:
 *	0 if the channel is not registered in the interpreter, 1 else.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_IsChannelRegistered (interp, chan)
     Tcl_Interp* interp;	/* The interp to query of the channel */
     Tcl_Channel chan;		/* The channel to check */
{
    Tcl_HashTable	*hTblPtr;	/* Hash table of channels. */
    Tcl_HashEntry	*hPtr;		/* Search variable. */
    Channel		*chanPtr;	/* The real IO channel. */
    ChannelState	*statePtr;	/* State of the real channel. */

    /*
     * Always check bottom-most channel in the stack.  This is the one
     * that gets registered.
     */
    chanPtr = ((Channel *) chan)->state->bottomChanPtr;
    statePtr = chanPtr->state;

    hTblPtr = (Tcl_HashTable *) Tcl_GetAssocData(interp, "tclIO", NULL);
    if (hTblPtr == (Tcl_HashTable *) NULL) {
        return 0;
    }
    hPtr = Tcl_FindHashEntry(hTblPtr, statePtr->channelName);
    if (hPtr == (Tcl_HashEntry *) NULL) {
        return 0;
    }
    if ((Channel *) Tcl_GetHashValue(hPtr) != chanPtr) {
        return 0;
    }

    return 1;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_IsChannelShared --
 *
 *	Checks whether the channel is shared by multiple interpreters.
 *
 * Results:
 *	A boolean value (0 = Not shared, 1 = Shared).
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_IsChannelShared (chan)
    Tcl_Channel chan;	/* The channel to query */
{
    ChannelState *statePtr = ((Channel *) chan)->state;
					/* State of real channel structure. */

    return ((statePtr->refCount > 1) ? 1 : 0);
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_IsChannelExisting --
 *
 *	Checks whether a channel of the given name exists in the
 *	(thread)-global list of all channels.
 *	See Tcl_GetChannelNamesEx for function exposed at the Tcl level.
 *
 * Results:
 *	A boolean value (0 = Does not exist, 1 = Does exist).
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_IsChannelExisting(chanName)
    CONST char* chanName;	/* The name of the channel to look for. */
{
    ChannelState *statePtr;
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    CONST char *name;
    int chanNameLen;

    chanNameLen = strlen(chanName);
    for (statePtr = tsdPtr->firstCSPtr;
	 statePtr != NULL;
	 statePtr = statePtr->nextCSPtr) {
        if (statePtr->topChanPtr == (Channel *) tsdPtr->stdinChannel) {
	    name = "stdin";
	} else if (statePtr->topChanPtr == (Channel *) tsdPtr->stdoutChannel) {
	    name = "stdout";
	} else if (statePtr->topChanPtr == (Channel *) tsdPtr->stderrChannel) {
	    name = "stderr";
	} else {
	    name = statePtr->channelName;
	}

	if ((*chanName == *name) &&
		(memcmp(name, chanName, (size_t) chanNameLen) == 0)) {
	    return 1;
	}
    }

    return 0;
}

/*
 *----------------------------------------------------------------------
 *
d7974 1
a7974 1
CONST char *
d7978 1
a7978 1
    return chanTypePtr->typeName;
d7989 1
a7989 1
 *	One of the TCL_CHANNEL_VERSION_* constants from tcl.h
a8002 2
    } else if (chanTypePtr->version == TCL_CHANNEL_VERSION_3) {
	return TCL_CHANNEL_VERSION_3;
a8014 27
 * HaveVersion --
 *
 *	Return whether a channel type is (at least) of a given version.
 *
 * Results:
 *	True if the minimum version is exceeded by the version actually
 *	present.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
HaveVersion(chanTypePtr, minimumVersion)
    Tcl_ChannelType *chanTypePtr;
    Tcl_ChannelTypeVersion minimumVersion;
{
    Tcl_ChannelTypeVersion actualVersion = Tcl_ChannelVersion(chanTypePtr);

    return ((int)actualVersion) >= ((int)minimumVersion);
}

/*
 *----------------------------------------------------------------------
 *
d8025 2
a8026 1
 *---------------------------------------------------------------------- */
d8032 2
a8033 2
    if (HaveVersion(chanTypePtr, TCL_CHANNEL_VERSION_2)) {
	return chanTypePtr->blockModeProc;
a8034 3
	/*
	 * The v1 structure had the blockModeProc in a different place.
	 */
d8059 1
a8059 1
    return chanTypePtr->closeProc;
d8082 1
a8082 1
    return chanTypePtr->close2Proc;
d8105 1
a8105 1
    return chanTypePtr->inputProc;
d8128 1
a8128 1
    return chanTypePtr->outputProc;
d8151 1
a8151 1
    return chanTypePtr->seekProc;
d8174 1
a8174 1
    return chanTypePtr->setOptionProc;
d8197 1
a8197 1
    return chanTypePtr->getOptionProc;
d8220 1
a8220 1
    return chanTypePtr->watchProc;
d8243 1
a8243 1
    return chanTypePtr->getHandleProc;
d8266 1
a8266 5
    if (HaveVersion(chanTypePtr, TCL_CHANNEL_VERSION_2)) {
	return chanTypePtr->flushProc;
    } else {
	return NULL;
    }
d8289 1
a8289 5
    if (HaveVersion(chanTypePtr, TCL_CHANNEL_VERSION_2)) {
	return chanTypePtr->handlerProc;
    } else {
	return NULL;
    }
a8290 16

/*
 *----------------------------------------------------------------------
 *
 * Tcl_ChannelWideSeekProc --
 *
 *	Return the Tcl_DriverWideSeekProc of the channel type.
 *
 * Results:
 *	A pointer to the proc.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
a8291 10
Tcl_DriverWideSeekProc *
Tcl_ChannelWideSeekProc(chanTypePtr)
    Tcl_ChannelType *chanTypePtr;	/* Pointer to channel type. */
{
    if (HaveVersion(chanTypePtr, TCL_CHANNEL_VERSION_3)) {
	return chanTypePtr->wideSeekProc;
    } else {
	return NULL;
    }
}
@


1.3.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@d13 1
a13 1
 * RCS: @@(#) $Id: tclIO.c,v 1.57 2002/07/30 18:36:25 andreas_kupries Exp $
d95 2
a96 1
				Channel *chanPtr, char *result, int space));
a106 2
static int              DetachChannel _ANSI_ARGS_((Tcl_Interp *interp,
				Tcl_Channel chan));
d113 1
a113 1
static int		DoWrite _ANSI_ARGS_((Channel *chanPtr, CONST char *src,
a114 4
static int		DoReadChars _ANSI_ARGS_ ((Channel* chan,
				Tcl_Obj* objPtr, int toRead, int appendFlag));
static int		DoWriteChars _ANSI_ARGS_ ((Channel* chan,
				CONST char* src, int len));
a120 2
static int		HaveVersion _ANSI_ARGS_((Tcl_ChannelType *typePtr,
				Tcl_ChannelTypeVersion minimumVersion));
d127 2
a128 2
				Tcl_Obj *objPtr, int charsLeft,
				int *offsetPtr, int *factorPtr));
d137 2
a138 2
				char *dst, CONST char *src,
				int *dstLenPtr, int *srcLenPtr));
d140 2
a141 2
				char *dst, CONST char *src,
				int *dstLenPtr, int *srcLenPtr));
a685 32
 * Tcl_IsStandardChannel --
 *
 *	Test if the given channel is a standard channel.  No attempt
 *	is made to check if the channel or the standard channels
 *	are initialized or otherwise valid.
 *
 * Results:
 *	Returns 1 if true, 0 if false.
 *
 * Side effects:
 *      None.
 *
 *----------------------------------------------------------------------
 */
int 
Tcl_IsStandardChannel(chan)
    Tcl_Channel chan;		/* Channel to check. */
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    if ((chan == tsdPtr->stdinChannel) 
	|| (chan == tsdPtr->stdoutChannel)
	|| (chan == tsdPtr->stderrChannel)) {
	return 1;
    } else {
	return 0;
    }
}

/*
 *----------------------------------------------------------------------
 *
d721 1
a721 1
    if (statePtr->channelName == (CONST char *) NULL) {
d746 1
a746 5
 *	reference count.  (This all happens in the Tcl_DetachChannel helper
 *	function).
 *	
 *	Finally, if the reference count of the channel drops to zero,
 *	it is deleted.
d752 1
a752 5
 *	Calls Tcl_DetachChannel which deletes the hash entry for a channel 
 *	associated with an interpreter.
 *	
 *	May delete the channel, which can have a variety of consequences,
 *	especially if we are forced to close the channel.
d762 3
d767 31
a797 2
    if (DetachChannel(interp, chan) != TCL_OK) {
        return TCL_OK;
d799 2
a801 2
    statePtr = ((Channel *) chan)->state->bottomChanPtr->state;

d828 1
a828 1
	Tcl_Preserve((ClientData)statePtr);
d830 3
a832 8
	    /* We don't want to re-enter Tcl_Close */
	    if (!(statePtr->flags & CHANNEL_CLOSED)) {
		if (Tcl_Close(interp, chan) != TCL_OK) {
		    statePtr->flags |= CHANNEL_CLOSED;
		    Tcl_Release((ClientData)statePtr);
		    return TCL_ERROR;
		}
	    }
a833 2
        statePtr->flags |= CHANNEL_CLOSED;
	Tcl_Release((ClientData)statePtr);
a838 123
 *----------------------------------------------------------------------
 *
 * Tcl_DetachChannel --
 *
 *	Deletes the hash entry for a channel associated with an interpreter.
 *	If the interpreter given as argument is NULL, it only decrements the
 *	reference count.  Even if the ref count drops to zero, the 
 *	channel is NOT closed or cleaned up.  This allows a channel to
 *	be detached from an interpreter and left in the same state it
 *	was in when it was originally returned by 'Tcl_OpenFileChannel',
 *	for example.
 *	
 *	This function cannot be used on the standard channels, and
 *	will return TCL_ERROR if that is attempted.
 *	
 *	This function should only be necessary for special purposes
 *	in which you need to generate a pristine channel from one
 *	that has already been used.  All ordinary purposes will almost
 *	always want to use Tcl_UnregisterChannel instead.
 *	
 *	Provided the channel is not attached to any other interpreter,
 *	it can then be closed with Tcl_Close, rather than with 
 *	Tcl_UnregisterChannel.
 *
 * Results:
 *	A standard Tcl result.  If the channel is not currently registered
 *	with the given interpreter, TCL_ERROR is returned, otherwise
 *	TCL_OK.  However no error messages are left in the interp's result.
 *
 * Side effects:
 *	Deletes the hash entry for a channel associated with an 
 *	interpreter.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_DetachChannel(interp, chan)
    Tcl_Interp *interp;		/* Interpreter in which channel is defined. */
    Tcl_Channel chan;		/* Channel to delete. */
{
    if (Tcl_IsStandardChannel(chan)) {
        return TCL_ERROR;
    }
    
    return DetachChannel(interp, chan);
}

/*
 *----------------------------------------------------------------------
 *
 * DetachChannel --
 *
 *	Deletes the hash entry for a channel associated with an interpreter.
 *	If the interpreter given as argument is NULL, it only decrements the
 *	reference count.  Even if the ref count drops to zero, the 
 *	channel is NOT closed or cleaned up.  This allows a channel to
 *	be detached from an interpreter and left in the same state it
 *	was in when it was originally returned by 'Tcl_OpenFileChannel',
 *	for example.
 *
 * Results:
 *	A standard Tcl result.  If the channel is not currently registered
 *	with the given interpreter, TCL_ERROR is returned, otherwise
 *	TCL_OK.  However no error messages are left in the interp's result.
 *
 * Side effects:
 *	Deletes the hash entry for a channel associated with an 
 *	interpreter.
 *
 *----------------------------------------------------------------------
 */

static int
DetachChannel(interp, chan)
    Tcl_Interp *interp;		/* Interpreter in which channel is defined. */
    Tcl_Channel chan;		/* Channel to delete. */
{
    Tcl_HashTable *hTblPtr;	/* Hash table of channels. */
    Tcl_HashEntry *hPtr;	/* Search variable. */
    Channel *chanPtr;		/* The real IO channel. */
    ChannelState *statePtr;	/* State of the real channel. */

    /*
     * Always (un)register bottom-most channel in the stack.  This makes
     * management of the channel list easier because no manipulation is
     * necessary during (un)stack operation.
     */
    chanPtr = ((Channel *) chan)->state->bottomChanPtr;
    statePtr = chanPtr->state;

    if (interp != (Tcl_Interp *) NULL) {
	hTblPtr = (Tcl_HashTable *) Tcl_GetAssocData(interp, "tclIO", NULL);
	if (hTblPtr == (Tcl_HashTable *) NULL) {
	    return TCL_ERROR;
	}
	hPtr = Tcl_FindHashEntry(hTblPtr, statePtr->channelName);
	if (hPtr == (Tcl_HashEntry *) NULL) {
	    return TCL_ERROR;
	}
	if ((Channel *) Tcl_GetHashValue(hPtr) != chanPtr) {
	    return TCL_ERROR;
	}
	Tcl_DeleteHashEntry(hPtr);

	/*
	 * Remove channel handlers that refer to this interpreter, so that they
	 * will not be present if the actual close is delayed and more events
	 * happen on the channel. This may occur if the channel is shared
	 * between several interpreters, or if the channel has async
	 * flushing active.
	 */
    
	CleanupChannelHandlers(interp, chanPtr);
    }

    statePtr->refCount--;
    
    return TCL_OK;
}


/*
d862 1
a862 1
    CONST char *chanName;	/* The name of the channel. */
d871 1
a871 1
    CONST char *name;		/* Translated name. */
d940 1
a940 1
    CONST char *chanName;	/* Name of channel to record. */
a962 4
    /*
     * JH: We could subsequently memset these to 0 to avoid the
     * numerous assignments to 0/NULL below.
     */
d976 2
a977 3
	char *tmp = ckalloc((unsigned) (strlen(chanName) + 1));
        statePtr->channelName = tmp;
        strcpy(tmp, chanName);
a1046 11
     *
     * JH: Could call Tcl_SpliceChannel, but need to avoid NULL check.
     */

    statePtr->nextCSPtr	= tsdPtr->firstCSPtr;
    tsdPtr->firstCSPtr	= statePtr;

    /*
     * TIP #10. Mark the current thread as the one managing the new
     *          channel. Note: 'Tcl_GetCurrentThread' returns sensible
     *          values even for a non-threaded core.
d1049 2
a1050 1
    statePtr->managingThread = Tcl_GetCurrentThread ();
a1467 26
 * Tcl_GetChannelThread --
 *
 *	Given a channel structure, returns the thread managing it.
 *	TIP #10
 *
 * Results:
 *	Returns the id of the thread managing the channel.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_ThreadId
Tcl_GetChannelThread(chan)
    Tcl_Channel chan;		/* The channel to return managing thread for. */
{
    Channel *chanPtr = (Channel *) chan;	/* The actual channel. */

    return chanPtr->state->managingThread;
}

/*
 *----------------------------------------------------------------------
 *
d1536 1
a1536 1
CONST char *
a1659 11
     * Only save buffers which are at least as big as the requested
     * buffersize for the channel. This is to honor dynamic changes
     * of the buffersize made by the user.
     */

    if ((bufPtr->bufLength - BUFFER_PADDING) < statePtr->bufSize) {
        ckfree((char *) bufPtr);
        return;
    }

    /*
d1868 1
a1868 1
                bufPtr->buf + bufPtr->nextRemoved, toWrite,
a1918 7

		    /*
		     * Casting away CONST here is safe because the
		     * TCL_VOLATILE flag guarantees CONST treatment
		     * of the Posix error string.
		     */

d1920 1
a1920 1
			    (char *) Tcl_PosixError(interp), TCL_VOLATILE);
d2015 3
d2062 8
d2072 1
a2072 1
     * Remove this channel from of the list of all channels.
d2074 20
a2093 1
    Tcl_CutChannel((Tcl_Channel) chanPtr);
d2114 1
a2114 1
	    ckfree((char *) statePtr->channelName);
d2151 17
d2179 1
d2184 1
a2184 4
     * pointers we have and then ourselves.  Since this is the
     * last of the channels in the stack, make sure to free the
     * ChannelState structure associated with it.  We use
     * Tcl_EventuallyFree to allow for any last
a2187 1
    Tcl_EventuallyFree((ClientData) statePtr, TCL_DYNAMIC);
a2195 112
 * Tcl_CutChannel --
 *
 *	Removes a channel from the (thread-)global list of all channels
 *	(in that thread).  This is actually the statePtr for the stack
 *	of channel.
 *
 * Results:
 *	Nothing.
 *
 * Side effects:
 *	Resets the field 'nextCSPtr' of the specified channel state to NULL.
 *
 * NOTE:
 *	The channel to splice out of the list must not be referenced
 *	in any interpreter. This is something this procedure cannot
 *	check (despite the refcount) because the caller usually wants
 *	fiddle with the channel (like transfering it to a different
 *	thread) and thus keeps the refcount artifically high to prevent
 *	its destruction.
 *
 *----------------------------------------------------------------------
 */

void
Tcl_CutChannel(chan)
    Tcl_Channel chan;			/* The channel being removed. Must
                                         * not be referenced in any
                                         * interpreter. */
{
    ThreadSpecificData* tsdPtr  = TCL_TSD_INIT(&dataKey);
    ChannelState *prevCSPtr;		/* Preceding channel state in list of
                                         * all states - used to splice a
                                         * channel out of the list on close. */
    ChannelState *statePtr = ((Channel *) chan)->state;
					/* state of the channel stack. */

    /*
     * Remove this channel from of the list of all channels
     * (in the current thread).
     */

    if (tsdPtr->firstCSPtr && (statePtr == tsdPtr->firstCSPtr)) {
        tsdPtr->firstCSPtr = statePtr->nextCSPtr;
    } else {
        for (prevCSPtr = tsdPtr->firstCSPtr;
	     prevCSPtr && (prevCSPtr->nextCSPtr != statePtr);
	     prevCSPtr = prevCSPtr->nextCSPtr) {
            /* Empty loop body. */
        }
        if (prevCSPtr == (ChannelState *) NULL) {
            panic("FlushChannel: damaged channel list");
        }
        prevCSPtr->nextCSPtr = statePtr->nextCSPtr;
    }

    statePtr->nextCSPtr = (ChannelState *) NULL;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_SpliceChannel --
 *
 *	Adds a channel to the (thread-)global list of all channels
 *	(in that thread). Expects that the field 'nextChanPtr' in
 *	the channel is set to NULL.
 *
 * Results:
 *	Nothing.
 *
 * Side effects:
 *	Nothing.
 *
 * NOTE:
 *	The channel to add to the list must not be referenced in any
 *	interpreter. This is something this procedure cannot check
 *	(despite the refcount) because the caller usually wants figgle
 *	with the channel (like transfering it to a different thread)
 *	and thus keeps the refcount artifically high to prevent its
 *	destruction.
 *
 *----------------------------------------------------------------------
 */

void
Tcl_SpliceChannel(chan)
    Tcl_Channel chan;			/* The channel being added. Must
                                         * not be referenced in any
                                         * interpreter. */
{
    ThreadSpecificData	*tsdPtr = TCL_TSD_INIT(&dataKey);
    ChannelState	*statePtr = ((Channel *) chan)->state;

    if (statePtr->nextCSPtr != (ChannelState *) NULL) {
        panic("Tcl_SpliceChannel: trying to add channel used in different list");
    }

    statePtr->nextCSPtr	= tsdPtr->firstCSPtr;
    tsdPtr->firstCSPtr	= statePtr;

    /*
     * TIP #10. Mark the current thread as the new one managing this
     *          channel. Note: 'Tcl_GetCurrentThread' returns sensible
     *          values even for a non-threaded core.
     */

    statePtr->managingThread = Tcl_GetCurrentThread ();
}

/*
 *----------------------------------------------------------------------
 *
d2223 1
d2226 1
d2230 2
a2259 94
     * When the channel has an escape sequence driven encoding such as
     * iso2022, the terminated escape sequence must write to the buffer.
     */
    if ((statePtr->encoding != NULL) && (statePtr->curOutPtr != NULL)
	    && (CheckChannelErrors(statePtr, TCL_WRITABLE) == 0)) {
        statePtr->outputEncodingFlags |= TCL_ENCODING_END;
        WriteChars(chanPtr, "", 0);
    }

    Tcl_ClearChannelHandlers(chan);

    /*
     * Invoke the registered close callbacks and delete their records.
     */

    while (statePtr->closeCbPtr != (CloseCallback *) NULL) {
        cbPtr = statePtr->closeCbPtr;
        statePtr->closeCbPtr = cbPtr->nextPtr;
        (cbPtr->proc) (cbPtr->clientData);
        ckfree((char *) cbPtr);
    }

    /*
     * Ensure that the last output buffer will be flushed.
     */
    
    if ((statePtr->curOutPtr != (ChannelBuffer *) NULL) &&
	    (statePtr->curOutPtr->nextAdded > statePtr->curOutPtr->nextRemoved)) {
        statePtr->flags |= BUFFER_READY;
    }

    /*
     * If this channel supports it, close the read side, since we don't need it
     * anymore and this will help avoid deadlocks on some channel types.
     */

    if (chanPtr->typePtr->closeProc == TCL_CLOSE2PROC) {
	result = (chanPtr->typePtr->close2Proc)(chanPtr->instanceData, interp,
		TCL_CLOSE_READ);
    } else {
	result = 0;
    }

    /*
     * The call to FlushChannel will flush any queued output and invoke
     * the close function of the channel driver, or it will set up the
     * channel to be flushed and closed asynchronously.
     */

    statePtr->flags |= CHANNEL_CLOSED;
    if ((FlushChannel(interp, chanPtr, 0) != 0) || (result != 0)) {
        return TCL_ERROR;
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_ClearChannelHandlers --
 *
 *	Removes all channel handlers and event scripts from the channel,
 *	cancels all background copies involving the channel and any interest
 *	in events.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	See above. Deallocates memory.
 *
 *----------------------------------------------------------------------
 */

void
Tcl_ClearChannelHandlers (channel)
    Tcl_Channel channel;
{
    ChannelHandler *chPtr, *chNext;	/* Iterate over channel handlers. */
    EventScriptRecord *ePtr, *eNextPtr;	/* Iterate over eventscript records. */
    Channel *chanPtr;			/* The real IO channel. */
    ChannelState *statePtr;		/* State of real IO channel. */
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    NextChannelHandler *nhPtr;

    /*
     * This operation should occur at the top of a channel stack.
     */

    chanPtr	= (Channel *) channel;
    statePtr	= chanPtr->state;
    chanPtr	= statePtr->topChanPtr;

    /*
d2313 44
d2367 1
a2367 4
 *	line buffering mode. Compensates stacking, i.e. will redirect the
 *	data from the specified channel to the topmost channel in a stack.
 *
 *	No encoding conversions are applied to the bytes being read.
d2383 1
a2383 1
    CONST char *src;			/* Data to queue in output buffer. */
d2414 1
a2414 4
 *	line buffering mode. Writes directly to the driver of the channel,
 *	does not compensate for stacking.
 *
 *	No encoding conversions are applied to the bytes being read.
d2430 1
a2430 1
    CONST char *src;			/* Data to queue in output buffer. */
d2470 1
a2470 43
 *	line buffering mode. Compensates stacking, i.e. will redirect the
 *	data from the specified channel to the topmost channel in a stack.
 *
 * Results:
 *	The number of bytes written or -1 in case of error. If -1,
 *	Tcl_GetErrno will return the error code.
 *
 * Side effects:
 *	May buffer up output and may cause output to be produced on the
 *	channel.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_WriteChars(chan, src, len)
    Tcl_Channel chan;		/* The channel to buffer output for. */
    CONST char *src;		/* UTF-8 characters to queue in output buffer. */
    int len;			/* Length of string in bytes, or < 0 for 
				 * strlen(). */
{
    ChannelState *statePtr;	/* state info for channel */

    statePtr = ((Channel *) chan)->state;

    if (CheckChannelErrors(statePtr, TCL_WRITABLE) != 0) {
	return -1;
    }

    return DoWriteChars ((Channel*) chan, src, len);
}

/*
 *---------------------------------------------------------------------------
 *
 * DoWriteChars --
 *
 *	Takes a sequence of UTF-8 characters and converts them for output
 *	using the channel's current encoding, may queue the buffer for
 *	output if it gets full, and also remembers whether the current
 *	buffer is ready e.g. if it contains a newline and we are in
 *	line buffering mode. Compensates stacking, i.e. will redirect the
 *	data from the specified channel to the topmost channel in a stack.
d2483 3
a2485 3
static int
DoWriteChars(chanPtr, src, len)
    Channel* chanPtr;		/* The channel to buffer output for. */
d2493 1
d2496 1
a2496 1
    statePtr = chanPtr->state;
d2499 3
d2606 1
a2606 1
    int dstMax, sawLF, savedLF, total, dstLen, toWrite;
d2694 2
a2695 3
    int saved, savedLF, sawLF, total, dstLen, stageMax, dstWrote;
    int stageLen, toWrite, stageRead, endEncoding, result;
    int consumedSomething;
a2705 6
     * Write the terminated escape sequence even if srcLen is 0.
     */

    endEncoding = ((statePtr->outputEncodingFlags & TCL_ENCODING_END) != 0);

    /*
d2710 1
a2710 3
    consumedSomething = 1;
    while (consumedSomething && (srcLen + savedLF + endEncoding > 0)) {
        consumedSomething = 0;
d2745 5
d2755 1
a2755 1
	while (stageLen + saved + endEncoding > 0) {
d2778 1
a2778 2
	    result = Tcl_UtfToExternal(NULL, encoding, stage, stageLen,
		    statePtr->outputEncodingFlags,
d2781 1
a2781 21

	    /* Fix for SF #506297, reported by Martin Forssen
	     * <ruric@@users.sourceforge.net>.
	     *
	     * The encoding chosen in the script exposing the bug writes out
	     * three intro characters when TCL_ENCODING_START is set, but does
	     * not consume any input as TCL_ENCODING_END is cleared. As some
	     * output was generated the enclosing loop calls UtfToExternal
	     * again, again with START set. Three more characters in the out
	     * and still no use of input ... To break this infinite loop we
	     * remove TCL_ENCODING_START from the set of flags after the first
	     * call (no condition is required, the later calls remove an unset
	     * flag, which is a no-op). This causes the subsequent calls to
	     * UtfToExternal to consume and convert the actual input.
	     */

	    statePtr->outputEncodingFlags &= ~TCL_ENCODING_START;
	    /*
	     * The following code must be executed only when result is not 0.
	     */
	    if (result && ((stageRead + dstWrote) == 0)) {
a2816 12

	    consumedSomething = 1;

	    /*
	     * If all translated characters are written to the buffer,
	     * endEncoding is set to 0 because the escape sequence may be
	     * output.
	     */

	    if ((stageLen + saved == 0) && (result == 0)) {
		endEncoding = 0;
	    }
a2818 9

    /* If nothing was written and it happened because there was no progress
     * in the UTF conversion, we throw an error.
     */

    if (!consumedSomething && (total == 0)) {
        Tcl_SetErrno (EINVAL);
        return -1;
    }
d3078 1
a3078 1
    int inEofChar, skip, copiedTotal, oldLength, oldFlags, oldRemoved;
d3082 1
d3291 1
a3291 1
	    if (eol == objPtr->bytes + oldLength) {
d3293 1
a3293 1
		 * If we didn't append any bytes before encountering EOF,
d3297 1
a3297 1
		Tcl_SetObjLength(objPtr, oldLength);
d3320 2
a3321 3
	    &statePtr->inputEncodingState, dst,
	    eol - dst + skip + TCL_UTF_MAX, &gs.rawRead, NULL,
	    &gs.charsWrote);
d3412 1
a3412 1
#define ENCODING_LINESIZE   20	/* Lower bound on how many bytes to convert
d3441 1
a3441 1

d3494 1
a3494 8
	    &gsPtr->charsWrote);

    /*
     * Make sure that if we go through 'gets', that we reset the
     * TCL_ENCODING_START flag still.  [Bug #523988]
     */
    statePtr->inputEncodingFlags &= ~TCL_ENCODING_START;

d3765 1
a3765 1
    char *bufPtr;		/* Where to store input read. */
d3809 8
a3816 13
	    if ((statePtr->flags & CHANNEL_TIMER_FEV) &&
		(statePtr->flags & CHANNEL_NONBLOCKING)) {
	        nread  = -1;
	        result = EWOULDBLOCK;
	    } else {
	      /*
	       * Now go to the driver to get as much as is possible to
	       * fill the remaining request. Do all the error handling
	       * by ourselves.  The code was stolen from 'GetInput' and
	       * slightly adapted (different return value here).
	       *
	       * The case of 'bytesToRead == 0' at this point cannot happen.
	       */
d3818 1
a3818 1
	      nread = (chanPtr->typePtr->inputProc)(chanPtr->instanceData,
a3819 1
	    }
d3896 6
a3901 2
    Channel*      chanPtr  = (Channel *) chan;
    ChannelState* statePtr = chanPtr->state;	/* state info for channel */
d3910 2
a3911 6
        /*
	 * Update the notifier state so we don't block while there is still
	 * data in the buffers.
	 */
        UpdateInterest(chanPtr);
	return -1;
a3913 48
    return DoReadChars (chanPtr, objPtr, toRead, appendFlag);
}
/*
 *---------------------------------------------------------------------------
 *
 * DoReadChars --
 *
 *	Reads from the channel until the requested number of characters
 *	have been seen, EOF is seen, or the channel would block.  EOL
 *	and EOF translation is done.  If reading binary data, the raw
 *	bytes are wrapped in a Tcl byte array object.  Otherwise, the raw
 *	bytes are converted to UTF-8 using the channel's current encoding
 *	and stored in a Tcl string object.
 *
 * Results:
 *	The number of characters read, or -1 on error. Use Tcl_GetErrno()
 *	to retrieve the error code for the error that occurred.
 *
 * Side effects:
 *	May cause input to be buffered.
 *
 *---------------------------------------------------------------------------
 */
 
static int
DoReadChars(chanPtr, objPtr, toRead, appendFlag)
    Channel* chanPtr;		/* The channel to read. */
    Tcl_Obj *objPtr;		/* Input data is stored in this object. */
    int toRead;			/* Maximum number of characters to store,
				 * or -1 to read all available data (up to EOF
				 * or when channel blocks). */
    int appendFlag;		/* If non-zero, data read from the channel
				 * will be appended to the object.  Otherwise,
				 * the data will replace the existing contents
				 * of the object. */

{
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    ChannelBuffer *bufPtr;
    int offset, factor, copied, copiedNow, result;
    Tcl_Encoding encoding;
#define UTF_EXPANSION_FACTOR	1024
    
    /*
     * This operation should occur at the top of a channel stack.
     */

    chanPtr  = statePtr->topChanPtr;
d3915 1
a3915 1
    factor   = UTF_EXPANSION_FACTOR;
d3954 1
a3954 1
		    statePtr->inQueueTail = NULL;
d4026 8
a4038 8
    int bytesToRead;		/* Maximum number of bytes to store,
				 * or < 0 to get all available bytes.
				 * Bytes are obtained from the first
				 * buffer in the queue -- even if this number
				 * is larger than the number of bytes
				 * available in the first buffer, only the
				 * bytes from the first buffer are
				 * returned. */
d4044 1
a4044 1
    int toRead, srcLen, offset, length, srcRead, dstWrote;
a4129 4
    Tcl_Obj *objPtr;		/* Input data is appended to this object.
				 * objPtr->length is how much space has been
				 * allocated to hold data, not how many bytes
				 * of data have been stored in the object. */
d4138 4
d4152 2
a4153 2
    int toRead, factor, offset, spaceLeft, length, srcLen, dstNeeded;
    int srcRead, dstWrote, numChars, dstRead;
d4166 1
a4166 1
    if ((unsigned)toRead > (unsigned)srcLen) {
d4248 5
a4252 14
	    if (srcLen > 0) {
	        /*
		 * There isn't enough data in the buffers to complete the next
		 * character, so we need to wait for more data before the next
		 * file event can be delivered.
		 *
		 * SF #478856.
		 *
		 * The exception to this is if the input buffer was
		 * completely empty before we tried to convert its
		 * contents. Nothing in, nothing out, and no incomplete
		 * character data. The conversion before the current one
		 * was complete.
		 */
d4254 1
a4254 2
	        statePtr->flags |= CHANNEL_NEED_MORE_DATA;
	    }
d4269 1
a4269 3
	 * EOF was located in dst? Run the conversion again with an
	 * output buffer just big enough to hold the data so we can
	 * get the correct value for srcRead.
d4295 1
a4295 1
	CONST char *eof;
d4508 1
a4508 1
    CONST char *str;		/* The input itself. */
a4756 13

	/*
	 * Check the actual buffersize against the requested
	 * buffersize. Buffers which are smaller than requested are
	 * squashed. This is done to honor dynamic changes of the
	 * buffersize made by the user.
	 */

	if ((bufPtr != NULL) && ((bufPtr->bufLength - BUFFER_PADDING) < statePtr->bufSize)) {
	  ckfree((char *) bufPtr);
	  bufPtr = NULL;
	}

d4762 1
a4762 15
	/* SF #427196: Use the actual size of the buffer to determine
	 * the number of bytes to read from the channel and not the
	 * size for new buffers. They can be different if the
	 * buffersize was changed between reads.
	 *
	 * Note: This affects performance negatively if the buffersize
	 * was extended but this small buffer is reused for all
	 * subsequent reads. The system never uses buffers with the
	 * requested bigger size in that case. An adjunct patch could
	 * try and delete all unused buffers it encounters and which
	 * are smaller than the formally requested buffersize.
	 */

	toRead = bufPtr->bufLength - bufPtr->nextAdded;

d4770 1
a4770 1

d4780 2
a4781 8
    if ((statePtr->flags & CHANNEL_TIMER_FEV) &&
	(statePtr->flags & CHANNEL_NONBLOCKING)) {
        nread = -1;
        result = EWOULDBLOCK;
    } else {
        nread = (chanPtr->typePtr->inputProc)(chanPtr->instanceData,
		    bufPtr->buf + bufPtr->nextAdded, toRead, &result);
    }
d4806 1
a4806 1
    }
d4828 1
a4828 1
Tcl_WideInt
d4831 1
a4831 1
    Tcl_WideInt offset;		/* Offset to seek to. */
d4836 1
a4837 1
				/* # bytes held in buffers. */
d4839 1
a4839 1
    Tcl_WideInt curPos;		/* Position on the device. */
d4845 1
a4845 1
	return Tcl_LongAsWide(-1);
d4855 1
a4855 3
    if (CheckForDeadChannel(NULL, statePtr)) {
	return Tcl_LongAsWide(-1);
    }
d4870 1
a4870 1
        return Tcl_LongAsWide(-1);
d4878 27
a4904 2
    inputBuffered = Tcl_InputBuffered(chan);
    outputBuffered = Tcl_OutputBuffered(chan);
d4908 1
a4908 1
        return Tcl_LongAsWide(-1);
d4947 1
a4947 1
	    return Tcl_LongAsWide(-1);
d4969 1
a4969 2
         * caller.  Note that we prefer the wideSeekProc if that is
	 * available and non-NULL...
d4972 5
a4976 16
	if (HaveVersion(chanPtr->typePtr, TCL_CHANNEL_VERSION_3) &&
		chanPtr->typePtr->wideSeekProc != NULL) {
	    curPos = (chanPtr->typePtr->wideSeekProc) (chanPtr->instanceData,
		    offset, mode, &result);
	} else if (offset < Tcl_LongAsWide(LONG_MIN) ||
		offset > Tcl_LongAsWide(LONG_MAX)) {
	    Tcl_SetErrno(EOVERFLOW);
	    curPos = Tcl_LongAsWide(-1);
	} else {
	    curPos = Tcl_LongAsWide((chanPtr->typePtr->seekProc) (
		    chanPtr->instanceData, Tcl_WideAsLong(offset), mode,
		    &result));
	    if (curPos == Tcl_LongAsWide(-1)) {
		Tcl_SetErrno(result);
	    }
	}
d4990 1
a4990 1
	    return Tcl_LongAsWide(-1);
d5016 1
a5016 1
Tcl_WideInt
d5022 2
a5023 1
    int inputBuffered, outputBuffered;	/* # bytes held in buffers. */
d5025 1
a5025 1
    Tcl_WideInt curPos;			/* Position on device. */
d5028 1
a5028 1
	return Tcl_LongAsWide(-1);
d5039 1
a5039 1
	return Tcl_LongAsWide(-1);
d5055 1
a5055 1
        return Tcl_LongAsWide(-1);
d5063 16
a5078 2
    inputBuffered = Tcl_InputBuffered(chan);
    outputBuffered = Tcl_OutputBuffered(chan);
d5082 1
a5082 1
        return Tcl_LongAsWide(-1);
d5087 1
a5087 2
     * where the next character will be read or written.  Note that we
     * prefer the wideSeekProc if that is available and non-NULL...
d5090 3
a5092 9
    if (HaveVersion(chanPtr->typePtr, TCL_CHANNEL_VERSION_3) &&
	    chanPtr->typePtr->wideSeekProc != NULL) {
	curPos = (chanPtr->typePtr->wideSeekProc) (chanPtr->instanceData,
		Tcl_LongAsWide(0), SEEK_CUR, &result);
    } else {
	curPos = Tcl_LongAsWide((chanPtr->typePtr->seekProc) (
		chanPtr->instanceData, 0, SEEK_CUR, &result));
    }
    if (curPos == Tcl_LongAsWide(-1)) {
d5094 1
a5094 1
        return Tcl_LongAsWide(-1);
d5097 1
a5097 1
        return curPos - inputBuffered;
d5099 1
a5099 43
    return curPos + outputBuffered;
}

/*
 *---------------------------------------------------------------------------
 *
 * Tcl_SeekOld, Tcl_TellOld --
 *
 *	Backward-compatability versions of the seek/tell interface that
 *	do not support 64-bit offsets.  This interface is not documented
 *	or expected to be supported indefinitely.
 *
 * Results:
 *	As for Tcl_Seek and Tcl_Tell respectively, except truncated to
 *	whatever value will fit in an 'int'.
 *
 * Side effects:
 *	As for Tcl_Seek and Tcl_Tell respectively.
 *
 *---------------------------------------------------------------------------
 */

int
Tcl_SeekOld(chan, offset, mode)
    Tcl_Channel chan;		/* The channel on which to seek. */
    int offset;			/* Offset to seek to. */
    int mode;			/* Relative to which location to seek? */
{
    Tcl_WideInt wOffset, wResult;

    wOffset = Tcl_LongAsWide((long)offset);
    wResult = Tcl_Seek(chan, wOffset, mode);
    return (int)Tcl_WideAsLong(wResult);
}

int
Tcl_TellOld(chan)
    Tcl_Channel chan;		/* The channel to return pos for. */
{
    Tcl_WideInt wResult;

    wResult = Tcl_Tell(chan);
    return (int)Tcl_WideAsLong(wResult);
d5180 1
a5180 1

a5292 42
 * Tcl_OutputBuffered --
 *
 *    Returns the number of bytes of output currently buffered in the
 *    common internal buffer of a channel.
 *
 * Results:
 *    The number of output bytes buffered, or zero if the channel is not
 *    open for writing.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_OutputBuffered(chan)
    Tcl_Channel chan;                 /* The channel to query. */
{
    ChannelState *statePtr = ((Channel *) chan)->state;
                                      /* State of real channel structure. */
    ChannelBuffer *bufPtr;
    int bytesBuffered;

    for (bytesBuffered = 0, bufPtr = statePtr->outQueueHead;
	bufPtr != (ChannelBuffer *) NULL;
	bufPtr = bufPtr->nextPtr) {
	bytesBuffered += (bufPtr->nextAdded - bufPtr->nextRemoved);
    }
    if ((statePtr->curOutPtr != (ChannelBuffer *) NULL) &&
	(statePtr->curOutPtr->nextAdded > statePtr->curOutPtr->nextRemoved)) {
	statePtr->flags |= BUFFER_READY;
	bytesBuffered +=
	    (statePtr->curOutPtr->nextAdded - statePtr->curOutPtr->nextRemoved);
    }

    return bytesBuffered;
}

/*
 *----------------------------------------------------------------------
 *
d5434 2
a5435 2
    CONST char *optionName;		/* 'bad option' name */
    CONST char *optionList;		/* Specific options list to append 
d5444 1
a5444 1
	CONST char **argv;
d5449 1
a5449 1
	Tcl_DStringAppend(&ds, genericopt, -1);
d5497 1
a5497 1
    CONST char *optionName;	/* Option to get. */
a5631 4
        if ( !(flags & (TCL_READABLE|TCL_WRITABLE))) {
            /* Not readable or writable (server socket) */
            Tcl_DStringAppendElement(dsPtr, "");
        }
a5671 4
        if ( !(flags & (TCL_READABLE|TCL_WRITABLE))) {
            /* Not readable or writable (server socket) */
            Tcl_DStringAppendElement(dsPtr, "auto");
        }
d5721 2
a5722 2
    CONST char *optionName;	/* Which option to set? */
    CONST char *newValue;	/* New value for option. */
d5724 1
d5729 1
a5729 1
    CONST char **argv;
a5764 1
	int newMode;
a5814 9
	/*
	 * When the channel has an escape sequence driven encoding such as
	 * iso2022, the terminated escape sequence must write to the buffer.
	 */
	if ((statePtr->encoding != NULL) && (statePtr->curOutPtr != NULL)
		&& (CheckChannelErrors(statePtr, TCL_WRITABLE) == 0)) {
	    statePtr->outputEncodingFlags |= TCL_ENCODING_END;
	    WriteChars(chanPtr, "", 0);
	}
d5841 2
a5842 2
                        "bad value for -eofchar: should be a list of zero,",
                        " one, or two elements", (char *) NULL);
d5854 1
a5854 1
        if (argv != NULL) {
d5860 1
a5860 1
	CONST char *readMode, *writeMode;
a5882 1
	    TclEolTranslation translation;
d5884 1
a5884 1
		translation = statePtr->inputTranslation;
d5886 1
a5886 1
		translation = TCL_TRANSLATE_AUTO;
d5888 1
a5888 1
		translation = TCL_TRANSLATE_LF;
d5893 1
a5893 1
		translation = TCL_TRANSLATE_LF;
d5895 1
a5895 1
		translation = TCL_TRANSLATE_CR;
d5897 1
a5897 1
		translation = TCL_TRANSLATE_CRLF;
d5899 1
a5899 1
		translation = TCL_PLATFORM_TRANSLATION;
d5917 2
a5918 2
	    if (translation != statePtr->inputTranslation) {
		statePtr->inputTranslation = translation;
d5935 1
a5935 1
		if (strcmp(Tcl_ChannelName(chanPtr->typePtr), "tcp") == 0) {
d6093 1
a6109 2
	Tcl_DriverHandlerProc* upHandlerProc;

d6112 9
a6120 3
	upHandlerProc = Tcl_ChannelHandlerProc(upTypePtr);
	if (upHandlerProc != NULL) {
	    mask = (*upHandlerProc) (upChanPtr->instanceData, mask);
a6150 1
    Tcl_Preserve((ClientData) statePtr);
d6160 2
a6161 2
	FlushChannel(NULL, chanPtr, 1);
	mask &= ~TCL_WRITABLE;
a6173 4
	/*
	 * If this channel handler is interested in any of the events that
	 * have occurred on the channel, invoke its procedure.
	 */
d6175 12
a6186 7
	if ((chPtr->mask & mask) != 0) {
	    nh.nextHandlerPtr = chPtr->nextPtr;
	    (*(chPtr->proc))(chPtr->clientData, mask);
	    chPtr = nh.nextHandlerPtr;
	} else {
	    chPtr = chPtr->nextPtr;
	}
a6198 1
    Tcl_Release((ClientData) statePtr);
d6202 73
a6367 13

	/* Set the TIMER flag to notify the higher levels that the
	 * driver might have no data for us. We do this only if we are
	 * in non-blocking mode and the driver has no BlockModeProc
	 * because only then we really don't know if the driver will
	 * block or not. A similar test is done in "PeekAhead".
	 */

	if ((statePtr->flags & CHANNEL_NONBLOCKING) &&
	    (Tcl_ChannelBlockModeProc(chanPtr->typePtr) == NULL)) {
	    statePtr->flags |= CHANNEL_TIMER_FEV;
	}
	Tcl_Preserve((ClientData) statePtr);
d6369 1
a6369 3

	statePtr->flags &= ~CHANNEL_TIMER_FEV; 
	Tcl_Release((ClientData) statePtr);
d6759 1
a6759 1
    static CONST char *modeOptions[] = {"readable", "writable", NULL};
d6892 1
a6892 1
		    nonBlocking ? TCL_MODE_NONBLOCKING : TCL_MODE_BLOCKING)
d6963 1
a6963 1
    Tcl_Obj *cmdPtr, *errObj = NULL, *bufObj = NULL;
d6966 3
a6968 5
    int result = TCL_OK, size, total, sizeb;
    char* buffer;

    int inBinary, outBinary, sameEncoding; /* Encoding control */
    int underflow;	/* input underflow */
d6985 1
a6985 8
    inBinary     = (inStatePtr->encoding  == NULL);
    outBinary    = (outStatePtr->encoding == NULL);
    sameEncoding = (inStatePtr->encoding  == outStatePtr->encoding);

    if (!(inBinary || sameEncoding)) {
        bufObj = Tcl_NewObj ();
	Tcl_IncrRefCount (bufObj);
    }
a6986 1
    while (csPtr->toRead != 0) {
d7007 1
a7007 1
	    sizeb = csPtr->bufSize;
d7009 1
a7009 1
	    sizeb = csPtr->toRead;
d7011 1
a7011 7

	if (inBinary || sameEncoding) {
	    size = DoRead(inStatePtr->topChanPtr, csPtr->buffer, sizeb);
	} else {
	    size = DoReadChars(inStatePtr->topChanPtr, bufObj, sizeb, 0 /* No append */);
	}
	underflow = (size >= 0) && (size < sizeb);	/* input underflow */
d7020 1
a7020 1
	} else if (underflow) {
d7027 1
a7027 1
	    if ((size == 0) && Tcl_Eof(inChan)) {
d7029 1
a7029 2
	    }
	    if (! Tcl_Eof(inChan) && !(mask & TCL_READABLE)) {
d7037 1
a7037 7
	    if (size == 0) {
	        if (bufObj != (Tcl_Obj*) NULL) {
		    Tcl_DecrRefCount (bufObj);
		    bufObj = (Tcl_Obj*) NULL;
		}
		return TCL_OK;
	    }
d7044 2
a7045 19
	if (inBinary || sameEncoding) {
	    buffer = csPtr->buffer;
	    sizeb = size;
	} else {
	    buffer = Tcl_GetStringFromObj (bufObj, &sizeb);
	}

	if (outBinary || sameEncoding) {
	    sizeb = DoWrite(outStatePtr->topChanPtr, buffer, sizeb);
	} else {
	    sizeb = DoWriteChars(outStatePtr->topChanPtr, buffer, sizeb);
	}

	if (inBinary || sameEncoding) {
	    /* Both read and write counted bytes */
	    size = sizeb;
	} /* else : Read counted characters, write counted bytes, i.e. size != sizeb */

	if (sizeb < 0) {
a7054 20
	 * Update the current byte count.  Do it now so the count is
	 * valid before a return or break takes us out of the loop.
	 * The invariant at the top of the loop should be that 
	 * csPtr->toRead holds the number of bytes left to copy.
	 */

	if (csPtr->toRead != -1) {
	    csPtr->toRead -= size;
	}
	csPtr->total += size;

	/*
	 * Break loop if EOF && (size>0)
	 */

        if (Tcl_Eof(inChan)) {
            break;
        }

	/*
a7056 2
	 * After input underflow we already installed a readable handler
	 * therefore we don't need a writable handler.
d7059 1
a7059 1
	if ( ! underflow && (outStatePtr->flags & BG_FLUSH_SCHEDULED) ) {
d7062 1
a7062 1
		    Tcl_DeleteChannelHandler(inChan, CopyEventProc,
a7067 4
	    if (bufObj != (Tcl_Obj*) NULL) {
	        Tcl_DecrRefCount (bufObj);
		bufObj = (Tcl_Obj*) NULL;
	    }
d7072 9
a7094 4
	    if (bufObj != (Tcl_Obj*) NULL) {
	        Tcl_DecrRefCount (bufObj);
		bufObj = (Tcl_Obj*) NULL;
	    }
a7096 5
    } /* while */

    if (bufObj != (Tcl_Obj*) NULL) {
        Tcl_DecrRefCount (bufObj);
	bufObj = (Tcl_Obj*) NULL;
a7146 2
 *	No encoding conversions are applied to the bytes being read.
 *
d7571 1
a7571 1
    CONST char *src;			/* Data to write. */
d7578 1
a7578 1
    CONST char *sPtr;			/* Search variables for newline. */
a7771 1
	nonBlocking = (csPtr->writeFlags & CHANNEL_NONBLOCKING);
d7929 1
a7929 1
    CONST char *pattern;	/* pattern to filter on. */
d7931 1
d7933 2
a7934 6
    ChannelState *statePtr;
    CONST char *name;		/* name for channel */
    Tcl_Obj *resultPtr;		/* pointer to result object */
    Tcl_HashTable *hTblPtr;	/* Hash table of channels. */
    Tcl_HashEntry *hPtr;	/* Search variable. */
    Tcl_HashSearch hSearch;	/* Search variable. */
d7936 4
a7939 16
    if (interp == (Tcl_Interp *) NULL) {
	return TCL_OK;
    }

    /*
     * Get the channel table that stores the channels registered
     * for this interpreter.
     */
    hTblPtr	= GetChannelTable(interp);
    resultPtr	= Tcl_GetObjResult(interp);

    for (hPtr = Tcl_FirstHashEntry(hTblPtr, &hSearch);
	 hPtr != (Tcl_HashEntry *) NULL;
	 hPtr = Tcl_NextHashEntry(&hSearch)) {

	statePtr = ((Channel *) Tcl_GetHashValue(hPtr))->state;
a7946 4
	    /*
	     * This is also stored in Tcl_GetHashKey(hTblPtr, hPtr),
	     * but it's simpler to just grab the name from the statePtr.
	     */
a7948 1

a7960 125
 * Tcl_IsChannelRegistered --
 *
 *	Checks whether the channel is associated with the interp.
 *	See also Tcl_RegisterChannel and Tcl_UnregisterChannel.
 *
 * Results:
 *	0 if the channel is not registered in the interpreter, 1 else.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_IsChannelRegistered (interp, chan)
     Tcl_Interp* interp;	/* The interp to query of the channel */
     Tcl_Channel chan;		/* The channel to check */
{
    Tcl_HashTable	*hTblPtr;	/* Hash table of channels. */
    Tcl_HashEntry	*hPtr;		/* Search variable. */
    Channel		*chanPtr;	/* The real IO channel. */
    ChannelState	*statePtr;	/* State of the real channel. */

    /*
     * Always check bottom-most channel in the stack.  This is the one
     * that gets registered.
     */
    chanPtr = ((Channel *) chan)->state->bottomChanPtr;
    statePtr = chanPtr->state;

    hTblPtr = (Tcl_HashTable *) Tcl_GetAssocData(interp, "tclIO", NULL);
    if (hTblPtr == (Tcl_HashTable *) NULL) {
        return 0;
    }
    hPtr = Tcl_FindHashEntry(hTblPtr, statePtr->channelName);
    if (hPtr == (Tcl_HashEntry *) NULL) {
        return 0;
    }
    if ((Channel *) Tcl_GetHashValue(hPtr) != chanPtr) {
        return 0;
    }

    return 1;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_IsChannelShared --
 *
 *	Checks whether the channel is shared by multiple interpreters.
 *
 * Results:
 *	A boolean value (0 = Not shared, 1 = Shared).
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_IsChannelShared (chan)
    Tcl_Channel chan;	/* The channel to query */
{
    ChannelState *statePtr = ((Channel *) chan)->state;
					/* State of real channel structure. */

    return ((statePtr->refCount > 1) ? 1 : 0);
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_IsChannelExisting --
 *
 *	Checks whether a channel of the given name exists in the
 *	(thread)-global list of all channels.
 *	See Tcl_GetChannelNamesEx for function exposed at the Tcl level.
 *
 * Results:
 *	A boolean value (0 = Does not exist, 1 = Does exist).
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_IsChannelExisting(chanName)
    CONST char* chanName;	/* The name of the channel to look for. */
{
    ChannelState *statePtr;
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    CONST char *name;
    int chanNameLen;

    chanNameLen = strlen(chanName);
    for (statePtr = tsdPtr->firstCSPtr;
	 statePtr != NULL;
	 statePtr = statePtr->nextCSPtr) {
        if (statePtr->topChanPtr == (Channel *) tsdPtr->stdinChannel) {
	    name = "stdin";
	} else if (statePtr->topChanPtr == (Channel *) tsdPtr->stdoutChannel) {
	    name = "stdout";
	} else if (statePtr->topChanPtr == (Channel *) tsdPtr->stderrChannel) {
	    name = "stderr";
	} else {
	    name = statePtr->channelName;
	}

	if ((*chanName == *name) &&
		(memcmp(name, chanName, (size_t) chanNameLen) == 0)) {
	    return 1;
	}
    }

    return 0;
}

/*
 *----------------------------------------------------------------------
 *
d7974 1
a7974 1
CONST char *
d7978 1
a7978 1
    return chanTypePtr->typeName;
d7989 1
a7989 1
 *	One of the TCL_CHANNEL_VERSION_* constants from tcl.h
a8002 2
    } else if (chanTypePtr->version == TCL_CHANNEL_VERSION_3) {
	return TCL_CHANNEL_VERSION_3;
a8014 27
 * HaveVersion --
 *
 *	Return whether a channel type is (at least) of a given version.
 *
 * Results:
 *	True if the minimum version is exceeded by the version actually
 *	present.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
HaveVersion(chanTypePtr, minimumVersion)
    Tcl_ChannelType *chanTypePtr;
    Tcl_ChannelTypeVersion minimumVersion;
{
    Tcl_ChannelTypeVersion actualVersion = Tcl_ChannelVersion(chanTypePtr);

    return ((int)actualVersion) >= ((int)minimumVersion);
}

/*
 *----------------------------------------------------------------------
 *
d8025 2
a8026 1
 *---------------------------------------------------------------------- */
d8032 2
a8033 2
    if (HaveVersion(chanTypePtr, TCL_CHANNEL_VERSION_2)) {
	return chanTypePtr->blockModeProc;
a8034 3
	/*
	 * The v1 structure had the blockModeProc in a different place.
	 */
d8059 1
a8059 1
    return chanTypePtr->closeProc;
d8082 1
a8082 1
    return chanTypePtr->close2Proc;
d8105 1
a8105 1
    return chanTypePtr->inputProc;
d8128 1
a8128 1
    return chanTypePtr->outputProc;
d8151 1
a8151 1
    return chanTypePtr->seekProc;
d8174 1
a8174 1
    return chanTypePtr->setOptionProc;
d8197 1
a8197 1
    return chanTypePtr->getOptionProc;
d8220 1
a8220 1
    return chanTypePtr->watchProc;
d8243 1
a8243 1
    return chanTypePtr->getHandleProc;
d8266 1
a8266 5
    if (HaveVersion(chanTypePtr, TCL_CHANNEL_VERSION_2)) {
	return chanTypePtr->flushProc;
    } else {
	return NULL;
    }
d8289 1
a8289 5
    if (HaveVersion(chanTypePtr, TCL_CHANNEL_VERSION_2)) {
	return chanTypePtr->handlerProc;
    } else {
	return NULL;
    }
a8290 16

/*
 *----------------------------------------------------------------------
 *
 * Tcl_ChannelWideSeekProc --
 *
 *	Return the Tcl_DriverWideSeekProc of the channel type.
 *
 * Results:
 *	A pointer to the proc.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
a8291 10
Tcl_DriverWideSeekProc *
Tcl_ChannelWideSeekProc(chanTypePtr)
    Tcl_ChannelType *chanTypePtr;	/* Pointer to channel type. */
{
    if (HaveVersion(chanTypePtr, TCL_CHANNEL_VERSION_3)) {
	return chanTypePtr->wideSeekProc;
    } else {
	return NULL;
    }
}
@


1.2
log
@touched all Tcl files to ease next import.
@
text
@@


1.2.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.2.16.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d95 2
a96 1
				Channel *chanPtr, char *result, int space));
a106 2
static int              DetachChannel _ANSI_ARGS_((Tcl_Interp *interp,
				Tcl_Channel chan));
d113 1
a113 1
static int		DoWrite _ANSI_ARGS_((Channel *chanPtr, CONST char *src,
a114 4
static int		DoReadChars _ANSI_ARGS_ ((Channel* chan,
				Tcl_Obj* objPtr, int toRead, int appendFlag));
static int		DoWriteChars _ANSI_ARGS_ ((Channel* chan,
				CONST char* src, int len));
a120 2
static int		HaveVersion _ANSI_ARGS_((Tcl_ChannelType *typePtr,
				Tcl_ChannelTypeVersion minimumVersion));
d127 2
a128 2
				Tcl_Obj *objPtr, int charsLeft,
				int *offsetPtr, int *factorPtr));
d137 2
a138 2
				char *dst, CONST char *src,
				int *dstLenPtr, int *srcLenPtr));
d140 2
a141 2
				char *dst, CONST char *src,
				int *dstLenPtr, int *srcLenPtr));
a685 32
 * Tcl_IsStandardChannel --
 *
 *	Test if the given channel is a standard channel.  No attempt
 *	is made to check if the channel or the standard channels
 *	are initialized or otherwise valid.
 *
 * Results:
 *	Returns 1 if true, 0 if false.
 *
 * Side effects:
 *      None.
 *
 *----------------------------------------------------------------------
 */
int 
Tcl_IsStandardChannel(chan)
    Tcl_Channel chan;		/* Channel to check. */
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    if ((chan == tsdPtr->stdinChannel) 
	|| (chan == tsdPtr->stdoutChannel)
	|| (chan == tsdPtr->stderrChannel)) {
	return 1;
    } else {
	return 0;
    }
}

/*
 *----------------------------------------------------------------------
 *
d721 1
a721 1
    if (statePtr->channelName == (CONST char *) NULL) {
d746 1
a746 5
 *	reference count.  (This all happens in the Tcl_DetachChannel helper
 *	function).
 *	
 *	Finally, if the reference count of the channel drops to zero,
 *	it is deleted.
d752 1
a752 5
 *	Calls Tcl_DetachChannel which deletes the hash entry for a channel 
 *	associated with an interpreter.
 *	
 *	May delete the channel, which can have a variety of consequences,
 *	especially if we are forced to close the channel.
d762 3
d767 31
a797 2
    if (DetachChannel(interp, chan) != TCL_OK) {
        return TCL_OK;
d799 2
a801 2
    statePtr = ((Channel *) chan)->state->bottomChanPtr->state;

d828 1
a828 1
	Tcl_Preserve((ClientData)statePtr);
d830 3
a832 8
	    /* We don't want to re-enter Tcl_Close */
	    if (!(statePtr->flags & CHANNEL_CLOSED)) {
		if (Tcl_Close(interp, chan) != TCL_OK) {
		    statePtr->flags |= CHANNEL_CLOSED;
		    Tcl_Release((ClientData)statePtr);
		    return TCL_ERROR;
		}
	    }
a833 121
        statePtr->flags |= CHANNEL_CLOSED;
	Tcl_Release((ClientData)statePtr);
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_DetachChannel --
 *
 *	Deletes the hash entry for a channel associated with an interpreter.
 *	If the interpreter given as argument is NULL, it only decrements the
 *	reference count.  Even if the ref count drops to zero, the 
 *	channel is NOT closed or cleaned up.  This allows a channel to
 *	be detached from an interpreter and left in the same state it
 *	was in when it was originally returned by 'Tcl_OpenFileChannel',
 *	for example.
 *	
 *	This function cannot be used on the standard channels, and
 *	will return TCL_ERROR if that is attempted.
 *	
 *	This function should only be necessary for special purposes
 *	in which you need to generate a pristine channel from one
 *	that has already been used.  All ordinary purposes will almost
 *	always want to use Tcl_UnregisterChannel instead.
 *	
 *	Provided the channel is not attached to any other interpreter,
 *	it can then be closed with Tcl_Close, rather than with 
 *	Tcl_UnregisterChannel.
 *
 * Results:
 *	A standard Tcl result.  If the channel is not currently registered
 *	with the given interpreter, TCL_ERROR is returned, otherwise
 *	TCL_OK.  However no error messages are left in the interp's result.
 *
 * Side effects:
 *	Deletes the hash entry for a channel associated with an 
 *	interpreter.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_DetachChannel(interp, chan)
    Tcl_Interp *interp;		/* Interpreter in which channel is defined. */
    Tcl_Channel chan;		/* Channel to delete. */
{
    if (Tcl_IsStandardChannel(chan)) {
        return TCL_ERROR;
    }
    
    return DetachChannel(interp, chan);
}

/*
 *----------------------------------------------------------------------
 *
 * DetachChannel --
 *
 *	Deletes the hash entry for a channel associated with an interpreter.
 *	If the interpreter given as argument is NULL, it only decrements the
 *	reference count.  Even if the ref count drops to zero, the 
 *	channel is NOT closed or cleaned up.  This allows a channel to
 *	be detached from an interpreter and left in the same state it
 *	was in when it was originally returned by 'Tcl_OpenFileChannel',
 *	for example.
 *
 * Results:
 *	A standard Tcl result.  If the channel is not currently registered
 *	with the given interpreter, TCL_ERROR is returned, otherwise
 *	TCL_OK.  However no error messages are left in the interp's result.
 *
 * Side effects:
 *	Deletes the hash entry for a channel associated with an 
 *	interpreter.
 *
 *----------------------------------------------------------------------
 */

static int
DetachChannel(interp, chan)
    Tcl_Interp *interp;		/* Interpreter in which channel is defined. */
    Tcl_Channel chan;		/* Channel to delete. */
{
    Tcl_HashTable *hTblPtr;	/* Hash table of channels. */
    Tcl_HashEntry *hPtr;	/* Search variable. */
    Channel *chanPtr;		/* The real IO channel. */
    ChannelState *statePtr;	/* State of the real channel. */

    /*
     * Always (un)register bottom-most channel in the stack.  This makes
     * management of the channel list easier because no manipulation is
     * necessary during (un)stack operation.
     */
    chanPtr = ((Channel *) chan)->state->bottomChanPtr;
    statePtr = chanPtr->state;

    if (interp != (Tcl_Interp *) NULL) {
	hTblPtr = (Tcl_HashTable *) Tcl_GetAssocData(interp, "tclIO", NULL);
	if (hTblPtr == (Tcl_HashTable *) NULL) {
	    return TCL_ERROR;
	}
	hPtr = Tcl_FindHashEntry(hTblPtr, statePtr->channelName);
	if (hPtr == (Tcl_HashEntry *) NULL) {
	    return TCL_ERROR;
	}
	if ((Channel *) Tcl_GetHashValue(hPtr) != chanPtr) {
	    return TCL_ERROR;
	}
	Tcl_DeleteHashEntry(hPtr);

	/*
	 * Remove channel handlers that refer to this interpreter, so that they
	 * will not be present if the actual close is delayed and more events
	 * happen on the channel. This may occur if the channel is shared
	 * between several interpreters, or if the channel has async
	 * flushing active.
	 */
    
	CleanupChannelHandlers(interp, chanPtr);
a834 3

    statePtr->refCount--;
    
a836 1

d862 1
a862 1
    CONST char *chanName;	/* The name of the channel. */
d871 1
a871 1
    CONST char *name;		/* Translated name. */
d940 1
a940 1
    CONST char *chanName;	/* Name of channel to record. */
a962 4
    /*
     * JH: We could subsequently memset these to 0 to avoid the
     * numerous assignments to 0/NULL below.
     */
d976 2
a977 3
	char *tmp = ckalloc((unsigned) (strlen(chanName) + 1));
        statePtr->channelName = tmp;
        strcpy(tmp, chanName);
a1046 2
     *
     * JH: Could call Tcl_SpliceChannel, but need to avoid NULL check.
d1049 2
a1050 10
    statePtr->nextCSPtr	= tsdPtr->firstCSPtr;
    tsdPtr->firstCSPtr	= statePtr;

    /*
     * TIP #10. Mark the current thread as the one managing the new
     *          channel. Note: 'Tcl_GetCurrentThread' returns sensible
     *          values even for a non-threaded core.
     */

    statePtr->managingThread = Tcl_GetCurrentThread ();
a1467 26
 * Tcl_GetChannelThread --
 *
 *	Given a channel structure, returns the thread managing it.
 *	TIP #10
 *
 * Results:
 *	Returns the id of the thread managing the channel.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_ThreadId
Tcl_GetChannelThread(chan)
    Tcl_Channel chan;		/* The channel to return managing thread for. */
{
    Channel *chanPtr = (Channel *) chan;	/* The actual channel. */

    return chanPtr->state->managingThread;
}

/*
 *----------------------------------------------------------------------
 *
d1536 1
a1536 1
CONST char *
a1659 11
     * Only save buffers which are at least as big as the requested
     * buffersize for the channel. This is to honor dynamic changes
     * of the buffersize made by the user.
     */

    if ((bufPtr->bufLength - BUFFER_PADDING) < statePtr->bufSize) {
        ckfree((char *) bufPtr);
        return;
    }

    /*
d1868 1
a1868 1
                bufPtr->buf + bufPtr->nextRemoved, toWrite,
a1918 7

		    /*
		     * Casting away CONST here is safe because the
		     * TCL_VOLATILE flag guarantees CONST treatment
		     * of the Posix error string.
		     */

d1920 1
a1920 1
			    (char *) Tcl_PosixError(interp), TCL_VOLATILE);
d2015 3
d2062 8
d2072 1
a2072 1
     * Remove this channel from of the list of all channels.
d2074 20
a2093 1
    Tcl_CutChannel((Tcl_Channel) chanPtr);
d2114 1
a2114 1
	    ckfree((char *) statePtr->channelName);
d2151 17
d2179 1
d2184 1
a2184 4
     * pointers we have and then ourselves.  Since this is the
     * last of the channels in the stack, make sure to free the
     * ChannelState structure associated with it.  We use
     * Tcl_EventuallyFree to allow for any last
a2187 1
    Tcl_EventuallyFree((ClientData) statePtr, TCL_DYNAMIC);
a2195 112
 * Tcl_CutChannel --
 *
 *	Removes a channel from the (thread-)global list of all channels
 *	(in that thread).  This is actually the statePtr for the stack
 *	of channel.
 *
 * Results:
 *	Nothing.
 *
 * Side effects:
 *	Resets the field 'nextCSPtr' of the specified channel state to NULL.
 *
 * NOTE:
 *	The channel to splice out of the list must not be referenced
 *	in any interpreter. This is something this procedure cannot
 *	check (despite the refcount) because the caller usually wants
 *	fiddle with the channel (like transfering it to a different
 *	thread) and thus keeps the refcount artifically high to prevent
 *	its destruction.
 *
 *----------------------------------------------------------------------
 */

void
Tcl_CutChannel(chan)
    Tcl_Channel chan;			/* The channel being removed. Must
                                         * not be referenced in any
                                         * interpreter. */
{
    ThreadSpecificData* tsdPtr  = TCL_TSD_INIT(&dataKey);
    ChannelState *prevCSPtr;		/* Preceding channel state in list of
                                         * all states - used to splice a
                                         * channel out of the list on close. */
    ChannelState *statePtr = ((Channel *) chan)->state;
					/* state of the channel stack. */

    /*
     * Remove this channel from of the list of all channels
     * (in the current thread).
     */

    if (tsdPtr->firstCSPtr && (statePtr == tsdPtr->firstCSPtr)) {
        tsdPtr->firstCSPtr = statePtr->nextCSPtr;
    } else {
        for (prevCSPtr = tsdPtr->firstCSPtr;
	     prevCSPtr && (prevCSPtr->nextCSPtr != statePtr);
	     prevCSPtr = prevCSPtr->nextCSPtr) {
            /* Empty loop body. */
        }
        if (prevCSPtr == (ChannelState *) NULL) {
            panic("FlushChannel: damaged channel list");
        }
        prevCSPtr->nextCSPtr = statePtr->nextCSPtr;
    }

    statePtr->nextCSPtr = (ChannelState *) NULL;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_SpliceChannel --
 *
 *	Adds a channel to the (thread-)global list of all channels
 *	(in that thread). Expects that the field 'nextChanPtr' in
 *	the channel is set to NULL.
 *
 * Results:
 *	Nothing.
 *
 * Side effects:
 *	Nothing.
 *
 * NOTE:
 *	The channel to add to the list must not be referenced in any
 *	interpreter. This is something this procedure cannot check
 *	(despite the refcount) because the caller usually wants figgle
 *	with the channel (like transfering it to a different thread)
 *	and thus keeps the refcount artifically high to prevent its
 *	destruction.
 *
 *----------------------------------------------------------------------
 */

void
Tcl_SpliceChannel(chan)
    Tcl_Channel chan;			/* The channel being added. Must
                                         * not be referenced in any
                                         * interpreter. */
{
    ThreadSpecificData	*tsdPtr = TCL_TSD_INIT(&dataKey);
    ChannelState	*statePtr = ((Channel *) chan)->state;

    if (statePtr->nextCSPtr != (ChannelState *) NULL) {
        panic("Tcl_SpliceChannel: trying to add channel used in different list");
    }

    statePtr->nextCSPtr	= tsdPtr->firstCSPtr;
    tsdPtr->firstCSPtr	= statePtr;

    /*
     * TIP #10. Mark the current thread as the new one managing this
     *          channel. Note: 'Tcl_GetCurrentThread' returns sensible
     *          values even for a non-threaded core.
     */

    statePtr->managingThread = Tcl_GetCurrentThread ();
}

/*
 *----------------------------------------------------------------------
 *
d2223 1
d2226 1
d2230 2
a2259 94
     * When the channel has an escape sequence driven encoding such as
     * iso2022, the terminated escape sequence must write to the buffer.
     */
    if ((statePtr->encoding != NULL) && (statePtr->curOutPtr != NULL)
	    && (CheckChannelErrors(statePtr, TCL_WRITABLE) == 0)) {
        statePtr->outputEncodingFlags |= TCL_ENCODING_END;
        WriteChars(chanPtr, "", 0);
    }

    Tcl_ClearChannelHandlers(chan);

    /*
     * Invoke the registered close callbacks and delete their records.
     */

    while (statePtr->closeCbPtr != (CloseCallback *) NULL) {
        cbPtr = statePtr->closeCbPtr;
        statePtr->closeCbPtr = cbPtr->nextPtr;
        (cbPtr->proc) (cbPtr->clientData);
        ckfree((char *) cbPtr);
    }

    /*
     * Ensure that the last output buffer will be flushed.
     */
    
    if ((statePtr->curOutPtr != (ChannelBuffer *) NULL) &&
	    (statePtr->curOutPtr->nextAdded > statePtr->curOutPtr->nextRemoved)) {
        statePtr->flags |= BUFFER_READY;
    }

    /*
     * If this channel supports it, close the read side, since we don't need it
     * anymore and this will help avoid deadlocks on some channel types.
     */

    if (chanPtr->typePtr->closeProc == TCL_CLOSE2PROC) {
	result = (chanPtr->typePtr->close2Proc)(chanPtr->instanceData, interp,
		TCL_CLOSE_READ);
    } else {
	result = 0;
    }

    /*
     * The call to FlushChannel will flush any queued output and invoke
     * the close function of the channel driver, or it will set up the
     * channel to be flushed and closed asynchronously.
     */

    statePtr->flags |= CHANNEL_CLOSED;
    if ((FlushChannel(interp, chanPtr, 0) != 0) || (result != 0)) {
        return TCL_ERROR;
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_ClearChannelHandlers --
 *
 *	Removes all channel handlers and event scripts from the channel,
 *	cancels all background copies involving the channel and any interest
 *	in events.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	See above. Deallocates memory.
 *
 *----------------------------------------------------------------------
 */

void
Tcl_ClearChannelHandlers (channel)
    Tcl_Channel channel;
{
    ChannelHandler *chPtr, *chNext;	/* Iterate over channel handlers. */
    EventScriptRecord *ePtr, *eNextPtr;	/* Iterate over eventscript records. */
    Channel *chanPtr;			/* The real IO channel. */
    ChannelState *statePtr;		/* State of real IO channel. */
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    NextChannelHandler *nhPtr;

    /*
     * This operation should occur at the top of a channel stack.
     */

    chanPtr	= (Channel *) channel;
    statePtr	= chanPtr->state;
    chanPtr	= statePtr->topChanPtr;

    /*
d2313 44
d2367 1
a2367 4
 *	line buffering mode. Compensates stacking, i.e. will redirect the
 *	data from the specified channel to the topmost channel in a stack.
 *
 *	No encoding conversions are applied to the bytes being read.
d2383 1
a2383 1
    CONST char *src;			/* Data to queue in output buffer. */
d2414 1
a2414 4
 *	line buffering mode. Writes directly to the driver of the channel,
 *	does not compensate for stacking.
 *
 *	No encoding conversions are applied to the bytes being read.
d2430 1
a2430 1
    CONST char *src;			/* Data to queue in output buffer. */
d2470 1
a2470 43
 *	line buffering mode. Compensates stacking, i.e. will redirect the
 *	data from the specified channel to the topmost channel in a stack.
 *
 * Results:
 *	The number of bytes written or -1 in case of error. If -1,
 *	Tcl_GetErrno will return the error code.
 *
 * Side effects:
 *	May buffer up output and may cause output to be produced on the
 *	channel.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_WriteChars(chan, src, len)
    Tcl_Channel chan;		/* The channel to buffer output for. */
    CONST char *src;		/* UTF-8 characters to queue in output buffer. */
    int len;			/* Length of string in bytes, or < 0 for 
				 * strlen(). */
{
    ChannelState *statePtr;	/* state info for channel */

    statePtr = ((Channel *) chan)->state;

    if (CheckChannelErrors(statePtr, TCL_WRITABLE) != 0) {
	return -1;
    }

    return DoWriteChars ((Channel*) chan, src, len);
}

/*
 *---------------------------------------------------------------------------
 *
 * DoWriteChars --
 *
 *	Takes a sequence of UTF-8 characters and converts them for output
 *	using the channel's current encoding, may queue the buffer for
 *	output if it gets full, and also remembers whether the current
 *	buffer is ready e.g. if it contains a newline and we are in
 *	line buffering mode. Compensates stacking, i.e. will redirect the
 *	data from the specified channel to the topmost channel in a stack.
d2483 3
a2485 3
static int
DoWriteChars(chanPtr, src, len)
    Channel* chanPtr;		/* The channel to buffer output for. */
d2493 1
d2496 1
a2496 1
    statePtr = chanPtr->state;
d2499 3
d2606 1
a2606 1
    int dstMax, sawLF, savedLF, total, dstLen, toWrite;
d2694 2
a2695 3
    int saved, savedLF, sawLF, total, dstLen, stageMax, dstWrote;
    int stageLen, toWrite, stageRead, endEncoding, result;
    int consumedSomething;
a2705 6
     * Write the terminated escape sequence even if srcLen is 0.
     */

    endEncoding = ((statePtr->outputEncodingFlags & TCL_ENCODING_END) != 0);

    /*
d2710 1
a2710 3
    consumedSomething = 1;
    while (consumedSomething && (srcLen + savedLF + endEncoding > 0)) {
        consumedSomething = 0;
d2745 5
d2755 1
a2755 1
	while (stageLen + saved + endEncoding > 0) {
d2778 1
a2778 2
	    result = Tcl_UtfToExternal(NULL, encoding, stage, stageLen,
		    statePtr->outputEncodingFlags,
d2781 1
a2781 21

	    /* Fix for SF #506297, reported by Martin Forssen
	     * <ruric@@users.sourceforge.net>.
	     *
	     * The encoding chosen in the script exposing the bug writes out
	     * three intro characters when TCL_ENCODING_START is set, but does
	     * not consume any input as TCL_ENCODING_END is cleared. As some
	     * output was generated the enclosing loop calls UtfToExternal
	     * again, again with START set. Three more characters in the out
	     * and still no use of input ... To break this infinite loop we
	     * remove TCL_ENCODING_START from the set of flags after the first
	     * call (no condition is required, the later calls remove an unset
	     * flag, which is a no-op). This causes the subsequent calls to
	     * UtfToExternal to consume and convert the actual input.
	     */

	    statePtr->outputEncodingFlags &= ~TCL_ENCODING_START;
	    /*
	     * The following code must be executed only when result is not 0.
	     */
	    if (result && ((stageRead + dstWrote) == 0)) {
a2816 12

	    consumedSomething = 1;

	    /*
	     * If all translated characters are written to the buffer,
	     * endEncoding is set to 0 because the escape sequence may be
	     * output.
	     */

	    if ((stageLen + saved == 0) && (result == 0)) {
		endEncoding = 0;
	    }
a2818 9

    /* If nothing was written and it happened because there was no progress
     * in the UTF conversion, we throw an error.
     */

    if (!consumedSomething && (total == 0)) {
        Tcl_SetErrno (EINVAL);
        return -1;
    }
d3078 1
a3078 1
    int inEofChar, skip, copiedTotal, oldLength, oldFlags, oldRemoved;
d3082 1
d3291 1
a3291 1
	    if (eol == objPtr->bytes + oldLength) {
d3293 1
a3293 1
		 * If we didn't append any bytes before encountering EOF,
d3297 1
a3297 1
		Tcl_SetObjLength(objPtr, oldLength);
d3320 2
a3321 3
	    &statePtr->inputEncodingState, dst,
	    eol - dst + skip + TCL_UTF_MAX, &gs.rawRead, NULL,
	    &gs.charsWrote);
d3412 1
a3412 1
#define ENCODING_LINESIZE   20	/* Lower bound on how many bytes to convert
d3441 1
a3441 1

d3494 1
a3494 8
	    &gsPtr->charsWrote);

    /*
     * Make sure that if we go through 'gets', that we reset the
     * TCL_ENCODING_START flag still.  [Bug #523988]
     */
    statePtr->inputEncodingFlags &= ~TCL_ENCODING_START;

d3765 1
a3765 1
    char *bufPtr;		/* Where to store input read. */
d3809 8
a3816 13
	    if ((statePtr->flags & CHANNEL_TIMER_FEV) &&
		(statePtr->flags & CHANNEL_NONBLOCKING)) {
	        nread  = -1;
	        result = EWOULDBLOCK;
	    } else {
	      /*
	       * Now go to the driver to get as much as is possible to
	       * fill the remaining request. Do all the error handling
	       * by ourselves.  The code was stolen from 'GetInput' and
	       * slightly adapted (different return value here).
	       *
	       * The case of 'bytesToRead == 0' at this point cannot happen.
	       */
d3818 1
a3818 1
	      nread = (chanPtr->typePtr->inputProc)(chanPtr->instanceData,
a3819 1
	    }
d3896 6
a3901 2
    Channel*      chanPtr  = (Channel *) chan;
    ChannelState* statePtr = chanPtr->state;	/* state info for channel */
d3910 2
a3911 6
        /*
	 * Update the notifier state so we don't block while there is still
	 * data in the buffers.
	 */
        UpdateInterest(chanPtr);
	return -1;
a3913 48
    return DoReadChars (chanPtr, objPtr, toRead, appendFlag);
}
/*
 *---------------------------------------------------------------------------
 *
 * DoReadChars --
 *
 *	Reads from the channel until the requested number of characters
 *	have been seen, EOF is seen, or the channel would block.  EOL
 *	and EOF translation is done.  If reading binary data, the raw
 *	bytes are wrapped in a Tcl byte array object.  Otherwise, the raw
 *	bytes are converted to UTF-8 using the channel's current encoding
 *	and stored in a Tcl string object.
 *
 * Results:
 *	The number of characters read, or -1 on error. Use Tcl_GetErrno()
 *	to retrieve the error code for the error that occurred.
 *
 * Side effects:
 *	May cause input to be buffered.
 *
 *---------------------------------------------------------------------------
 */
 
static int
DoReadChars(chanPtr, objPtr, toRead, appendFlag)
    Channel* chanPtr;		/* The channel to read. */
    Tcl_Obj *objPtr;		/* Input data is stored in this object. */
    int toRead;			/* Maximum number of characters to store,
				 * or -1 to read all available data (up to EOF
				 * or when channel blocks). */
    int appendFlag;		/* If non-zero, data read from the channel
				 * will be appended to the object.  Otherwise,
				 * the data will replace the existing contents
				 * of the object. */

{
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    ChannelBuffer *bufPtr;
    int offset, factor, copied, copiedNow, result;
    Tcl_Encoding encoding;
#define UTF_EXPANSION_FACTOR	1024
    
    /*
     * This operation should occur at the top of a channel stack.
     */

    chanPtr  = statePtr->topChanPtr;
d3915 1
a3915 1
    factor   = UTF_EXPANSION_FACTOR;
d3954 1
a3954 1
		    statePtr->inQueueTail = NULL;
d4026 8
a4038 8
    int bytesToRead;		/* Maximum number of bytes to store,
				 * or < 0 to get all available bytes.
				 * Bytes are obtained from the first
				 * buffer in the queue -- even if this number
				 * is larger than the number of bytes
				 * available in the first buffer, only the
				 * bytes from the first buffer are
				 * returned. */
d4044 1
a4044 1
    int toRead, srcLen, offset, length, srcRead, dstWrote;
a4129 4
    Tcl_Obj *objPtr;		/* Input data is appended to this object.
				 * objPtr->length is how much space has been
				 * allocated to hold data, not how many bytes
				 * of data have been stored in the object. */
d4138 4
d4152 2
a4153 2
    int toRead, factor, offset, spaceLeft, length, srcLen, dstNeeded;
    int srcRead, dstWrote, numChars, dstRead;
d4166 1
a4166 1
    if ((unsigned)toRead > (unsigned)srcLen) {
d4248 5
a4252 14
	    if (srcLen > 0) {
	        /*
		 * There isn't enough data in the buffers to complete the next
		 * character, so we need to wait for more data before the next
		 * file event can be delivered.
		 *
		 * SF #478856.
		 *
		 * The exception to this is if the input buffer was
		 * completely empty before we tried to convert its
		 * contents. Nothing in, nothing out, and no incomplete
		 * character data. The conversion before the current one
		 * was complete.
		 */
d4254 1
a4254 2
	        statePtr->flags |= CHANNEL_NEED_MORE_DATA;
	    }
d4269 1
a4269 3
	 * EOF was located in dst? Run the conversion again with an
	 * output buffer just big enough to hold the data so we can
	 * get the correct value for srcRead.
d4295 1
a4295 1
	CONST char *eof;
d4508 1
a4508 1
    CONST char *str;		/* The input itself. */
a4756 13

	/*
	 * Check the actual buffersize against the requested
	 * buffersize. Buffers which are smaller than requested are
	 * squashed. This is done to honor dynamic changes of the
	 * buffersize made by the user.
	 */

	if ((bufPtr != NULL) && ((bufPtr->bufLength - BUFFER_PADDING) < statePtr->bufSize)) {
	  ckfree((char *) bufPtr);
	  bufPtr = NULL;
	}

d4762 1
a4762 15
	/* SF #427196: Use the actual size of the buffer to determine
	 * the number of bytes to read from the channel and not the
	 * size for new buffers. They can be different if the
	 * buffersize was changed between reads.
	 *
	 * Note: This affects performance negatively if the buffersize
	 * was extended but this small buffer is reused for all
	 * subsequent reads. The system never uses buffers with the
	 * requested bigger size in that case. An adjunct patch could
	 * try and delete all unused buffers it encounters and which
	 * are smaller than the formally requested buffersize.
	 */

	toRead = bufPtr->bufLength - bufPtr->nextAdded;

d4770 1
a4770 1

d4780 2
a4781 8
    if ((statePtr->flags & CHANNEL_TIMER_FEV) &&
	(statePtr->flags & CHANNEL_NONBLOCKING)) {
        nread = -1;
        result = EWOULDBLOCK;
    } else {
        nread = (chanPtr->typePtr->inputProc)(chanPtr->instanceData,
		    bufPtr->buf + bufPtr->nextAdded, toRead, &result);
    }
d4806 1
a4806 1
    }
d4828 1
a4828 1
Tcl_WideInt
d4831 1
a4831 1
    Tcl_WideInt offset;		/* Offset to seek to. */
d4836 1
a4837 1
				/* # bytes held in buffers. */
d4839 1
a4839 1
    Tcl_WideInt curPos;		/* Position on the device. */
d4845 1
a4845 1
	return Tcl_LongAsWide(-1);
d4855 1
a4855 3
    if (CheckForDeadChannel(NULL, statePtr)) {
	return Tcl_LongAsWide(-1);
    }
d4870 1
a4870 1
        return Tcl_LongAsWide(-1);
d4878 27
a4904 2
    inputBuffered = Tcl_InputBuffered(chan);
    outputBuffered = Tcl_OutputBuffered(chan);
d4908 1
a4908 1
        return Tcl_LongAsWide(-1);
d4947 1
a4947 1
	    return Tcl_LongAsWide(-1);
d4969 1
a4969 2
         * caller.  Note that we prefer the wideSeekProc if that is
	 * available and non-NULL...
d4972 5
a4976 16
	if (HaveVersion(chanPtr->typePtr, TCL_CHANNEL_VERSION_3) &&
		chanPtr->typePtr->wideSeekProc != NULL) {
	    curPos = (chanPtr->typePtr->wideSeekProc) (chanPtr->instanceData,
		    offset, mode, &result);
	} else if (offset < Tcl_LongAsWide(LONG_MIN) ||
		offset > Tcl_LongAsWide(LONG_MAX)) {
	    Tcl_SetErrno(EOVERFLOW);
	    curPos = Tcl_LongAsWide(-1);
	} else {
	    curPos = Tcl_LongAsWide((chanPtr->typePtr->seekProc) (
		    chanPtr->instanceData, Tcl_WideAsLong(offset), mode,
		    &result));
	    if (curPos == Tcl_LongAsWide(-1)) {
		Tcl_SetErrno(result);
	    }
	}
d4990 1
a4990 1
	    return Tcl_LongAsWide(-1);
d5016 1
a5016 1
Tcl_WideInt
d5022 2
a5023 1
    int inputBuffered, outputBuffered;	/* # bytes held in buffers. */
d5025 1
a5025 1
    Tcl_WideInt curPos;			/* Position on device. */
d5028 1
a5028 1
	return Tcl_LongAsWide(-1);
d5039 1
a5039 1
	return Tcl_LongAsWide(-1);
d5055 1
a5055 1
        return Tcl_LongAsWide(-1);
d5063 16
a5078 2
    inputBuffered = Tcl_InputBuffered(chan);
    outputBuffered = Tcl_OutputBuffered(chan);
d5082 1
a5082 1
        return Tcl_LongAsWide(-1);
d5087 1
a5087 2
     * where the next character will be read or written.  Note that we
     * prefer the wideSeekProc if that is available and non-NULL...
d5090 3
a5092 9
    if (HaveVersion(chanPtr->typePtr, TCL_CHANNEL_VERSION_3) &&
	    chanPtr->typePtr->wideSeekProc != NULL) {
	curPos = (chanPtr->typePtr->wideSeekProc) (chanPtr->instanceData,
		Tcl_LongAsWide(0), SEEK_CUR, &result);
    } else {
	curPos = Tcl_LongAsWide((chanPtr->typePtr->seekProc) (
		chanPtr->instanceData, 0, SEEK_CUR, &result));
    }
    if (curPos == Tcl_LongAsWide(-1)) {
d5094 1
a5094 1
        return Tcl_LongAsWide(-1);
d5097 1
a5097 1
        return curPos - inputBuffered;
d5099 1
a5099 43
    return curPos + outputBuffered;
}

/*
 *---------------------------------------------------------------------------
 *
 * Tcl_SeekOld, Tcl_TellOld --
 *
 *	Backward-compatability versions of the seek/tell interface that
 *	do not support 64-bit offsets.  This interface is not documented
 *	or expected to be supported indefinitely.
 *
 * Results:
 *	As for Tcl_Seek and Tcl_Tell respectively, except truncated to
 *	whatever value will fit in an 'int'.
 *
 * Side effects:
 *	As for Tcl_Seek and Tcl_Tell respectively.
 *
 *---------------------------------------------------------------------------
 */

int
Tcl_SeekOld(chan, offset, mode)
    Tcl_Channel chan;		/* The channel on which to seek. */
    int offset;			/* Offset to seek to. */
    int mode;			/* Relative to which location to seek? */
{
    Tcl_WideInt wOffset, wResult;

    wOffset = Tcl_LongAsWide((long)offset);
    wResult = Tcl_Seek(chan, wOffset, mode);
    return (int)Tcl_WideAsLong(wResult);
}

int
Tcl_TellOld(chan)
    Tcl_Channel chan;		/* The channel to return pos for. */
{
    Tcl_WideInt wResult;

    wResult = Tcl_Tell(chan);
    return (int)Tcl_WideAsLong(wResult);
d5180 1
a5180 1

a5292 42
 * Tcl_OutputBuffered --
 *
 *    Returns the number of bytes of output currently buffered in the
 *    common internal buffer of a channel.
 *
 * Results:
 *    The number of output bytes buffered, or zero if the channel is not
 *    open for writing.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_OutputBuffered(chan)
    Tcl_Channel chan;                 /* The channel to query. */
{
    ChannelState *statePtr = ((Channel *) chan)->state;
                                      /* State of real channel structure. */
    ChannelBuffer *bufPtr;
    int bytesBuffered;

    for (bytesBuffered = 0, bufPtr = statePtr->outQueueHead;
	bufPtr != (ChannelBuffer *) NULL;
	bufPtr = bufPtr->nextPtr) {
	bytesBuffered += (bufPtr->nextAdded - bufPtr->nextRemoved);
    }
    if ((statePtr->curOutPtr != (ChannelBuffer *) NULL) &&
	(statePtr->curOutPtr->nextAdded > statePtr->curOutPtr->nextRemoved)) {
	statePtr->flags |= BUFFER_READY;
	bytesBuffered +=
	    (statePtr->curOutPtr->nextAdded - statePtr->curOutPtr->nextRemoved);
    }

    return bytesBuffered;
}

/*
 *----------------------------------------------------------------------
 *
d5434 2
a5435 2
    CONST char *optionName;		/* 'bad option' name */
    CONST char *optionList;		/* Specific options list to append 
d5444 1
a5444 1
	CONST char **argv;
d5449 1
a5449 1
	Tcl_DStringAppend(&ds, genericopt, -1);
d5497 1
a5497 1
    CONST char *optionName;	/* Option to get. */
a5631 4
        if ( !(flags & (TCL_READABLE|TCL_WRITABLE))) {
            /* Not readable or writable (server socket) */
            Tcl_DStringAppendElement(dsPtr, "");
        }
a5671 4
        if ( !(flags & (TCL_READABLE|TCL_WRITABLE))) {
            /* Not readable or writable (server socket) */
            Tcl_DStringAppendElement(dsPtr, "auto");
        }
d5721 2
a5722 2
    CONST char *optionName;	/* Which option to set? */
    CONST char *newValue;	/* New value for option. */
d5724 1
d5729 1
a5729 1
    CONST char **argv;
a5764 1
	int newMode;
a5814 9
	/*
	 * When the channel has an escape sequence driven encoding such as
	 * iso2022, the terminated escape sequence must write to the buffer.
	 */
	if ((statePtr->encoding != NULL) && (statePtr->curOutPtr != NULL)
		&& (CheckChannelErrors(statePtr, TCL_WRITABLE) == 0)) {
	    statePtr->outputEncodingFlags |= TCL_ENCODING_END;
	    WriteChars(chanPtr, "", 0);
	}
d5841 2
a5842 2
                        "bad value for -eofchar: should be a list of zero,",
                        " one, or two elements", (char *) NULL);
d5854 1
a5854 1
        if (argv != NULL) {
d5860 1
a5860 1
	CONST char *readMode, *writeMode;
a5882 1
	    TclEolTranslation translation;
d5884 1
a5884 1
		translation = statePtr->inputTranslation;
d5886 1
a5886 1
		translation = TCL_TRANSLATE_AUTO;
d5888 1
a5888 1
		translation = TCL_TRANSLATE_LF;
d5893 1
a5893 1
		translation = TCL_TRANSLATE_LF;
d5895 1
a5895 1
		translation = TCL_TRANSLATE_CR;
d5897 1
a5897 1
		translation = TCL_TRANSLATE_CRLF;
d5899 1
a5899 1
		translation = TCL_PLATFORM_TRANSLATION;
d5917 2
a5918 2
	    if (translation != statePtr->inputTranslation) {
		statePtr->inputTranslation = translation;
d5935 1
a5935 1
		if (strcmp(Tcl_ChannelName(chanPtr->typePtr), "tcp") == 0) {
d6093 1
d6110 6
a6115 1
	Tcl_DriverHandlerProc* upHandlerProc;
d6117 4
a6120 5
        upChanPtr = chanPtr->upChanPtr;
	upTypePtr = upChanPtr->typePtr;
	upHandlerProc = Tcl_ChannelHandlerProc(upTypePtr);
	if (upHandlerProc != NULL) {
	    mask = (*upHandlerProc) (upChanPtr->instanceData, mask);
a6150 1
    Tcl_Preserve((ClientData) statePtr);
d6160 2
a6161 2
	FlushChannel(NULL, chanPtr, 1);
	mask &= ~TCL_WRITABLE;
a6173 4
	/*
	 * If this channel handler is interested in any of the events that
	 * have occurred on the channel, invoke its procedure.
	 */
d6175 12
a6186 7
	if ((chPtr->mask & mask) != 0) {
	    nh.nextHandlerPtr = chPtr->nextPtr;
	    (*(chPtr->proc))(chPtr->clientData, mask);
	    chPtr = nh.nextHandlerPtr;
	} else {
	    chPtr = chPtr->nextPtr;
	}
a6198 1
    Tcl_Release((ClientData) statePtr);
d6202 73
a6367 13

	/* Set the TIMER flag to notify the higher levels that the
	 * driver might have no data for us. We do this only if we are
	 * in non-blocking mode and the driver has no BlockModeProc
	 * because only then we really don't know if the driver will
	 * block or not. A similar test is done in "PeekAhead".
	 */

	if ((statePtr->flags & CHANNEL_NONBLOCKING) &&
	    (Tcl_ChannelBlockModeProc(chanPtr->typePtr) == NULL)) {
	    statePtr->flags |= CHANNEL_TIMER_FEV;
	}
	Tcl_Preserve((ClientData) statePtr);
d6369 1
a6369 3

	statePtr->flags &= ~CHANNEL_TIMER_FEV; 
	Tcl_Release((ClientData) statePtr);
d6759 1
a6759 1
    static CONST char *modeOptions[] = {"readable", "writable", NULL};
d6892 1
a6892 1
		    nonBlocking ? TCL_MODE_NONBLOCKING : TCL_MODE_BLOCKING)
d6963 1
a6963 1
    Tcl_Obj *cmdPtr, *errObj = NULL, *bufObj = NULL;
d6966 3
a6968 5
    int result = TCL_OK, size, total, sizeb;
    char* buffer;

    int inBinary, outBinary, sameEncoding; /* Encoding control */
    int underflow;	/* input underflow */
d6985 1
a6985 8
    inBinary     = (inStatePtr->encoding  == NULL);
    outBinary    = (outStatePtr->encoding == NULL);
    sameEncoding = (inStatePtr->encoding  == outStatePtr->encoding);

    if (!(inBinary || sameEncoding)) {
        bufObj = Tcl_NewObj ();
	Tcl_IncrRefCount (bufObj);
    }
a6986 1
    while (csPtr->toRead != 0) {
d7007 1
a7007 1
	    sizeb = csPtr->bufSize;
d7009 1
a7009 1
	    sizeb = csPtr->toRead;
d7011 1
a7011 7

	if (inBinary || sameEncoding) {
	    size = DoRead(inStatePtr->topChanPtr, csPtr->buffer, sizeb);
	} else {
	    size = DoReadChars(inStatePtr->topChanPtr, bufObj, sizeb, 0 /* No append */);
	}
	underflow = (size >= 0) && (size < sizeb);	/* input underflow */
d7020 1
a7020 1
	} else if (underflow) {
d7027 1
a7027 1
	    if ((size == 0) && Tcl_Eof(inChan)) {
d7029 1
a7029 2
	    }
	    if (! Tcl_Eof(inChan) && !(mask & TCL_READABLE)) {
d7037 1
a7037 7
	    if (size == 0) {
	        if (bufObj != (Tcl_Obj*) NULL) {
		    Tcl_DecrRefCount (bufObj);
		    bufObj = (Tcl_Obj*) NULL;
		}
		return TCL_OK;
	    }
d7044 2
a7045 19
	if (inBinary || sameEncoding) {
	    buffer = csPtr->buffer;
	    sizeb = size;
	} else {
	    buffer = Tcl_GetStringFromObj (bufObj, &sizeb);
	}

	if (outBinary || sameEncoding) {
	    sizeb = DoWrite(outStatePtr->topChanPtr, buffer, sizeb);
	} else {
	    sizeb = DoWriteChars(outStatePtr->topChanPtr, buffer, sizeb);
	}

	if (inBinary || sameEncoding) {
	    /* Both read and write counted bytes */
	    size = sizeb;
	} /* else : Read counted characters, write counted bytes, i.e. size != sizeb */

	if (sizeb < 0) {
a7054 20
	 * Update the current byte count.  Do it now so the count is
	 * valid before a return or break takes us out of the loop.
	 * The invariant at the top of the loop should be that 
	 * csPtr->toRead holds the number of bytes left to copy.
	 */

	if (csPtr->toRead != -1) {
	    csPtr->toRead -= size;
	}
	csPtr->total += size;

	/*
	 * Break loop if EOF && (size>0)
	 */

        if (Tcl_Eof(inChan)) {
            break;
        }

	/*
a7056 2
	 * After input underflow we already installed a readable handler
	 * therefore we don't need a writable handler.
d7059 1
a7059 1
	if ( ! underflow && (outStatePtr->flags & BG_FLUSH_SCHEDULED) ) {
d7062 1
a7062 1
		    Tcl_DeleteChannelHandler(inChan, CopyEventProc,
a7067 4
	    if (bufObj != (Tcl_Obj*) NULL) {
	        Tcl_DecrRefCount (bufObj);
		bufObj = (Tcl_Obj*) NULL;
	    }
d7072 9
a7094 4
	    if (bufObj != (Tcl_Obj*) NULL) {
	        Tcl_DecrRefCount (bufObj);
		bufObj = (Tcl_Obj*) NULL;
	    }
a7096 5
    } /* while */

    if (bufObj != (Tcl_Obj*) NULL) {
        Tcl_DecrRefCount (bufObj);
	bufObj = (Tcl_Obj*) NULL;
a7146 2
 *	No encoding conversions are applied to the bytes being read.
 *
d7571 1
a7571 1
    CONST char *src;			/* Data to write. */
d7578 1
a7578 1
    CONST char *sPtr;			/* Search variables for newline. */
a7771 1
	nonBlocking = (csPtr->writeFlags & CHANNEL_NONBLOCKING);
d7929 1
a7929 1
    CONST char *pattern;	/* pattern to filter on. */
d7931 1
d7933 2
a7934 6
    ChannelState *statePtr;
    CONST char *name;		/* name for channel */
    Tcl_Obj *resultPtr;		/* pointer to result object */
    Tcl_HashTable *hTblPtr;	/* Hash table of channels. */
    Tcl_HashEntry *hPtr;	/* Search variable. */
    Tcl_HashSearch hSearch;	/* Search variable. */
d7936 4
a7939 16
    if (interp == (Tcl_Interp *) NULL) {
	return TCL_OK;
    }

    /*
     * Get the channel table that stores the channels registered
     * for this interpreter.
     */
    hTblPtr	= GetChannelTable(interp);
    resultPtr	= Tcl_GetObjResult(interp);

    for (hPtr = Tcl_FirstHashEntry(hTblPtr, &hSearch);
	 hPtr != (Tcl_HashEntry *) NULL;
	 hPtr = Tcl_NextHashEntry(&hSearch)) {

	statePtr = ((Channel *) Tcl_GetHashValue(hPtr))->state;
a7946 4
	    /*
	     * This is also stored in Tcl_GetHashKey(hTblPtr, hPtr),
	     * but it's simpler to just grab the name from the statePtr.
	     */
a7948 1

a7960 125
 * Tcl_IsChannelRegistered --
 *
 *	Checks whether the channel is associated with the interp.
 *	See also Tcl_RegisterChannel and Tcl_UnregisterChannel.
 *
 * Results:
 *	0 if the channel is not registered in the interpreter, 1 else.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_IsChannelRegistered (interp, chan)
     Tcl_Interp* interp;	/* The interp to query of the channel */
     Tcl_Channel chan;		/* The channel to check */
{
    Tcl_HashTable	*hTblPtr;	/* Hash table of channels. */
    Tcl_HashEntry	*hPtr;		/* Search variable. */
    Channel		*chanPtr;	/* The real IO channel. */
    ChannelState	*statePtr;	/* State of the real channel. */

    /*
     * Always check bottom-most channel in the stack.  This is the one
     * that gets registered.
     */
    chanPtr = ((Channel *) chan)->state->bottomChanPtr;
    statePtr = chanPtr->state;

    hTblPtr = (Tcl_HashTable *) Tcl_GetAssocData(interp, "tclIO", NULL);
    if (hTblPtr == (Tcl_HashTable *) NULL) {
        return 0;
    }
    hPtr = Tcl_FindHashEntry(hTblPtr, statePtr->channelName);
    if (hPtr == (Tcl_HashEntry *) NULL) {
        return 0;
    }
    if ((Channel *) Tcl_GetHashValue(hPtr) != chanPtr) {
        return 0;
    }

    return 1;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_IsChannelShared --
 *
 *	Checks whether the channel is shared by multiple interpreters.
 *
 * Results:
 *	A boolean value (0 = Not shared, 1 = Shared).
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_IsChannelShared (chan)
    Tcl_Channel chan;	/* The channel to query */
{
    ChannelState *statePtr = ((Channel *) chan)->state;
					/* State of real channel structure. */

    return ((statePtr->refCount > 1) ? 1 : 0);
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_IsChannelExisting --
 *
 *	Checks whether a channel of the given name exists in the
 *	(thread)-global list of all channels.
 *	See Tcl_GetChannelNamesEx for function exposed at the Tcl level.
 *
 * Results:
 *	A boolean value (0 = Does not exist, 1 = Does exist).
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_IsChannelExisting(chanName)
    CONST char* chanName;	/* The name of the channel to look for. */
{
    ChannelState *statePtr;
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    CONST char *name;
    int chanNameLen;

    chanNameLen = strlen(chanName);
    for (statePtr = tsdPtr->firstCSPtr;
	 statePtr != NULL;
	 statePtr = statePtr->nextCSPtr) {
        if (statePtr->topChanPtr == (Channel *) tsdPtr->stdinChannel) {
	    name = "stdin";
	} else if (statePtr->topChanPtr == (Channel *) tsdPtr->stdoutChannel) {
	    name = "stdout";
	} else if (statePtr->topChanPtr == (Channel *) tsdPtr->stderrChannel) {
	    name = "stderr";
	} else {
	    name = statePtr->channelName;
	}

	if ((*chanName == *name) &&
		(memcmp(name, chanName, (size_t) chanNameLen) == 0)) {
	    return 1;
	}
    }

    return 0;
}

/*
 *----------------------------------------------------------------------
 *
d7974 1
a7974 1
CONST char *
d7978 1
a7978 1
    return chanTypePtr->typeName;
d7989 1
a7989 1
 *	One of the TCL_CHANNEL_VERSION_* constants from tcl.h
a8002 2
    } else if (chanTypePtr->version == TCL_CHANNEL_VERSION_3) {
	return TCL_CHANNEL_VERSION_3;
a8014 27
 * HaveVersion --
 *
 *	Return whether a channel type is (at least) of a given version.
 *
 * Results:
 *	True if the minimum version is exceeded by the version actually
 *	present.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
HaveVersion(chanTypePtr, minimumVersion)
    Tcl_ChannelType *chanTypePtr;
    Tcl_ChannelTypeVersion minimumVersion;
{
    Tcl_ChannelTypeVersion actualVersion = Tcl_ChannelVersion(chanTypePtr);

    return ((int)actualVersion) >= ((int)minimumVersion);
}

/*
 *----------------------------------------------------------------------
 *
d8025 2
a8026 1
 *---------------------------------------------------------------------- */
d8032 2
a8033 2
    if (HaveVersion(chanTypePtr, TCL_CHANNEL_VERSION_2)) {
	return chanTypePtr->blockModeProc;
a8034 3
	/*
	 * The v1 structure had the blockModeProc in a different place.
	 */
d8059 1
a8059 1
    return chanTypePtr->closeProc;
d8082 1
a8082 1
    return chanTypePtr->close2Proc;
d8105 1
a8105 1
    return chanTypePtr->inputProc;
d8128 1
a8128 1
    return chanTypePtr->outputProc;
d8151 1
a8151 1
    return chanTypePtr->seekProc;
d8174 1
a8174 1
    return chanTypePtr->setOptionProc;
d8197 1
a8197 1
    return chanTypePtr->getOptionProc;
d8220 1
a8220 1
    return chanTypePtr->watchProc;
d8243 1
a8243 1
    return chanTypePtr->getHandleProc;
d8266 1
a8266 5
    if (HaveVersion(chanTypePtr, TCL_CHANNEL_VERSION_2)) {
	return chanTypePtr->flushProc;
    } else {
	return NULL;
    }
d8289 1
a8289 5
    if (HaveVersion(chanTypePtr, TCL_CHANNEL_VERSION_2)) {
	return chanTypePtr->handlerProc;
    } else {
	return NULL;
    }
a8290 16

/*
 *----------------------------------------------------------------------
 *
 * Tcl_ChannelWideSeekProc --
 *
 *	Return the Tcl_DriverWideSeekProc of the channel type.
 *
 * Results:
 *	A pointer to the proc.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
a8291 10
Tcl_DriverWideSeekProc *
Tcl_ChannelWideSeekProc(chanTypePtr)
    Tcl_ChannelType *chanTypePtr;	/* Pointer to channel type. */
{
    if (HaveVersion(chanTypePtr, TCL_CHANNEL_VERSION_3)) {
	return chanTypePtr->wideSeekProc;
    } else {
	return NULL;
    }
}
@


1.1
log
@Initial revision
@
text
@d7 1
a7 1
 * Copyright (c) 1998 Scriptics Corporation
d13 1
a13 1
 * RCS: @@(#) $Id: tclIO.c,v 1.11 1999/01/26 03:53:13 jingham Exp $
d16 4
a19 2
#include	"tclInt.h"
#include	"tclPort.h"
d21 1
d23 6
a28 5
 * Make sure that both EAGAIN and EWOULDBLOCK are defined. This does not
 * compile on systems where neither is defined. We want both defined so
 * that we can test safely for both. In the code we still have to test for
 * both because there may be systems on which both are defined and have
 * different values.
d31 24
a54 8
#if ((!defined(EWOULDBLOCK)) && (defined(EAGAIN)))
#   define EWOULDBLOCK EAGAIN
#endif
#if ((!defined(EAGAIN)) && (defined(EWOULDBLOCK)))
#   define EAGAIN EWOULDBLOCK
#endif
#if ((!defined(EAGAIN)) && (!defined(EWOULDBLOCK)))
    error one of EWOULDBLOCK or EAGAIN must be defined
d56 11
d68 1
a68 269
/*
 * The following structure encapsulates the state for a background channel
 * copy.  Note that the data buffer for the copy will be appended to this
 * structure.
 */

typedef struct CopyState {
    struct Channel *readPtr;	/* Pointer to input channel. */
    struct Channel *writePtr;	/* Pointer to output channel. */
    int readFlags;		/* Original read channel flags. */
    int writeFlags;		/* Original write channel flags. */
    int toRead;			/* Number of bytes to copy, or -1. */
    int total;			/* Total bytes transferred (written). */
    Tcl_Interp *interp;		/* Interp that started the copy. */
    Tcl_Obj *cmdPtr;		/* Command to be invoked at completion. */
    int bufSize;		/* Size of appended buffer. */
    char buffer[1];		/* Copy buffer, this must be the last
				 * field. */
} CopyState;

/*
 * struct ChannelBuffer:
 *
 * Buffers data being sent to or from a channel.
 */

typedef struct ChannelBuffer {
    int nextAdded;		/* The next position into which a character
                                 * will be put in the buffer. */
    int nextRemoved;		/* Position of next byte to be removed
                                 * from the buffer. */
    int bufSize;		/* How big is the buffer? */
    struct ChannelBuffer *nextPtr;
    				/* Next buffer in chain. */
    char buf[4];		/* Placeholder for real buffer. The real
                                 * buffer occuppies this space + bufSize-4
                                 * bytes. This must be the last field in
                                 * the structure. */
} ChannelBuffer;

#define CHANNELBUFFER_HEADER_SIZE	(sizeof(ChannelBuffer) - 4)

/*
 * The following defines the *default* buffer size for channels.
 */

#define CHANNELBUFFER_DEFAULT_SIZE	(1024 * 4)

/*
 * Structure to record a close callback. One such record exists for
 * each close callback registered for a channel.
 */

typedef struct CloseCallback {
    Tcl_CloseProc *proc;		/* The procedure to call. */
    ClientData clientData;		/* Arbitrary one-word data to pass
                                         * to the callback. */
    struct CloseCallback *nextPtr;	/* For chaining close callbacks. */
} CloseCallback;

/*
 * The following structure describes the information saved from a call to
 * "fileevent". This is used later when the event being waited for to
 * invoke the saved script in the interpreter designed in this record.
 */

typedef struct EventScriptRecord {
    struct Channel *chanPtr;	/* The channel for which this script is
                                 * registered. This is used only when an
                                 * error occurs during evaluation of the
                                 * script, to delete the handler. */
    char *script;		/* Script to invoke. */
    Tcl_Interp *interp;		/* In what interpreter to invoke script? */
    int mask;			/* Events must overlap current mask for the
                                 * stored script to be invoked. */
    struct EventScriptRecord *nextPtr;
    				/* Next in chain of records. */
} EventScriptRecord;

/*
 * struct Channel:
 *
 * One of these structures is allocated for each open channel. It contains data
 * specific to the channel but which belongs to the generic part of the Tcl
 * channel mechanism, and it points at an instance specific (and type
 * specific) * instance data, and at a channel type structure.
 */

typedef struct Channel {
    char *channelName;		/* The name of the channel instance in Tcl
                                 * commands. Storage is owned by the generic IO
                                 * code,  is dynamically allocated. */
    int	flags;			/* ORed combination of the flags defined
                                 * below. */
    Tcl_EolTranslation inputTranslation;
				/* What translation to apply for end of line
                                 * sequences on input? */    
    Tcl_EolTranslation outputTranslation;
    				/* What translation to use for generating
                                 * end of line sequences in output? */
    int inEofChar;		/* If nonzero, use this as a signal of EOF
                                 * on input. */
    int outEofChar;             /* If nonzero, append this to the channel
                                 * when it is closed if it is open for
                                 * writing. */
    int unreportedError;	/* Non-zero if an error report was deferred
                                 * because it happened in the background. The
                                 * value is the POSIX error code. */
    ClientData instanceData;	/* Instance specific data. */
    Tcl_ChannelType *typePtr;	/* Pointer to channel type structure. */
    int refCount;		/* How many interpreters hold references to
                                 * this IO channel? */
    CloseCallback *closeCbPtr;	/* Callbacks registered to be called when the
                                 * channel is closed. */
    ChannelBuffer *curOutPtr;	/* Current output buffer being filled. */
    ChannelBuffer *outQueueHead;/* Points at first buffer in output queue. */
    ChannelBuffer *outQueueTail;/* Points at last buffer in output queue. */

    ChannelBuffer *saveInBufPtr;/* Buffer saved for input queue - eliminates
                                 * need to allocate a new buffer for "gets"
                                 * that crosses buffer boundaries. */
    ChannelBuffer *inQueueHead;	/* Points at first buffer in input queue. */
    ChannelBuffer *inQueueTail;	/* Points at last buffer in input queue. */

    struct ChannelHandler *chPtr;/* List of channel handlers registered
                                  * for this channel. */
    int interestMask;		/* Mask of all events this channel has
                                 * handlers for. */
    struct Channel *nextChanPtr;/* Next in list of channels currently open. */
    EventScriptRecord *scriptRecordPtr;
    				/* Chain of all scripts registered for
                                 * event handlers ("fileevent") on this
                                 * channel. */
    int bufSize;		/* What size buffers to allocate? */
    Tcl_TimerToken timer;	/* Handle to wakeup timer for this channel. */
    CopyState *csPtr;		/* State of background copy, or NULL. */
} Channel;
    
/*
 * Values for the flags field in Channel. Any ORed combination of the
 * following flags can be stored in the field. These flags record various
 * options and state bits about the channel. In addition to the flags below,
 * the channel can also have TCL_READABLE (1<<1) and TCL_WRITABLE (1<<2) set.
 */

#define CHANNEL_NONBLOCKING	(1<<3)	/* Channel is currently in
					 * nonblocking mode. */
#define CHANNEL_LINEBUFFERED	(1<<4)	/* Output to the channel must be
					 * flushed after every newline. */
#define CHANNEL_UNBUFFERED	(1<<5)	/* Output to the channel must always
					 * be flushed immediately. */
#define BUFFER_READY		(1<<6)	/* Current output buffer (the
					 * curOutPtr field in the
                                         * channel structure) should be
                                         * output as soon as possible even
                                         * though it may not be full. */
#define BG_FLUSH_SCHEDULED	(1<<7)	/* A background flush of the
					 * queued output buffers has been
                                         * scheduled. */
#define CHANNEL_CLOSED		(1<<8)	/* Channel has been closed. No
					 * further Tcl-level IO on the
                                         * channel is allowed. */
#define CHANNEL_EOF		(1<<9)	/* EOF occurred on this channel.
					 * This bit is cleared before every
                                         * input operation. */
#define CHANNEL_STICKY_EOF	(1<<10)	/* EOF occurred on this channel because
					 * we saw the input eofChar. This bit
                                         * prevents clearing of the EOF bit
                                         * before every input operation. */
#define CHANNEL_BLOCKED	(1<<11)	/* EWOULDBLOCK or EAGAIN occurred
					 * on this channel. This bit is
                                         * cleared before every input or
                                         * output operation. */
#define INPUT_SAW_CR		(1<<12)	/* Channel is in CRLF eol input
					 * translation mode and the last
                                         * byte seen was a "\r". */
#define CHANNEL_DEAD		(1<<13)	/* The channel has been closed by
					 * the exit handler (on exit) but
                                         * not deallocated. When any IO
                                         * operation sees this flag on a
                                         * channel, it does not call driver
                                         * level functions to avoid referring
                                         * to deallocated data. */
#define CHANNEL_GETS_BLOCKED	(1<<14)	/* The last input operation was a gets
					 * that failed to get a comlete line.
					 * When set, file events will not be
					 * delivered for buffered data unless
					 * an EOL is present. */

/*
 * For each channel handler registered in a call to Tcl_CreateChannelHandler,
 * there is one record of the following type. All of records for a specific
 * channel are chained together in a singly linked list which is stored in
 * the channel structure.
 */

typedef struct ChannelHandler {
    Channel *chanPtr;		/* The channel structure for this channel. */
    int mask;			/* Mask of desired events. */
    Tcl_ChannelProc *proc;	/* Procedure to call in the type of
                                 * Tcl_CreateChannelHandler. */
    ClientData clientData;	/* Argument to pass to procedure. */
    struct ChannelHandler *nextPtr;
    				/* Next one in list of registered handlers. */
} ChannelHandler;

/*
 * This structure keeps track of the current ChannelHandler being invoked in
 * the current invocation of ChannelHandlerEventProc. There is a potential
 * problem if a ChannelHandler is deleted while it is the current one, since
 * ChannelHandlerEventProc needs to look at the nextPtr field. To handle this
 * problem, structures of the type below indicate the next handler to be
 * processed for any (recursively nested) dispatches in progress. The
 * nextHandlerPtr field is updated if the handler being pointed to is deleted.
 * The nextPtr field is used to chain together all recursive invocations, so
 * that Tcl_DeleteChannelHandler can find all the recursively nested
 * invocations of ChannelHandlerEventProc and compare the handler being
 * deleted against the NEXT handler to be invoked in that invocation; when it
 * finds such a situation, Tcl_DeleteChannelHandler updates the nextHandlerPtr
 * field of the structure to the next handler.
 */

typedef struct NextChannelHandler {
    ChannelHandler *nextHandlerPtr;	/* The next handler to be invoked in
                                         * this invocation. */
    struct NextChannelHandler *nestedHandlerPtr;
					/* Next nested invocation of
                                         * ChannelHandlerEventProc. */
} NextChannelHandler;

/*
 * This variable holds the list of nested ChannelHandlerEventProc invocations.
 */

static NextChannelHandler *nestedHandlerPtr = (NextChannelHandler *) NULL;

/*
 * List of all channels currently open.
 */

static Channel *firstChanPtr = (Channel *) NULL;

/*
 * Has a channel exit handler been created yet?
 */

static int channelExitHandlerCreated = 0;

/*
 * The following structure describes the event that is added to the Tcl
 * event queue by the channel handler check procedure.
 */

typedef struct ChannelHandlerEvent {
    Tcl_Event header;		/* Standard header for all events. */
    Channel *chanPtr;		/* The channel that is ready. */
    int readyMask;		/* Events that have occurred. */
} ChannelHandlerEvent;

/*
 * Static variables to hold channels for stdin, stdout and stderr.
 */

static Tcl_Channel stdinChannel = NULL;
static int stdinInitialized = 0;
static Tcl_Channel stdoutChannel = NULL;
static int stdoutInitialized = 0;
static Tcl_Channel stderrChannel = NULL;
static int stderrInitialized = 0;
d74 1
a74 2
static void		ChannelEventScriptInvoker _ANSI_ARGS_((
			    ClientData clientData, int flags));
d76 7
a82 1
			    ClientData clientData));
d84 1
a84 1
			    Tcl_Channel chan));
d86 1
a86 1
			    Tcl_Interp *interp, Channel *chanPtr));
d88 3
a90 2
                            Channel *chanPtr, int errorCode));
static void		CloseChannelsOnExit _ANSI_ARGS_((ClientData data));
d92 5
a96 1
			    Channel *chanPtr, char *result, int space));
d99 1
a99 1
			    int mask));
d101 2
a102 2
			    Tcl_Interp *interp, Channel *chanPtr,
                            int mask, char *script));
d104 1
a104 1
			    ClientData clientData, Tcl_Interp *interp));
d106 3
a108 3
        		    Channel *chanPtr, int mask));
static void		DiscardInputQueued _ANSI_ARGS_((
			    Channel *chanPtr, int discardSavedBuffers));
d110 1
a110 1
    			    Channel *chanPtr));
d112 5
a116 3
			    int slen));
static int		DoWrite _ANSI_ARGS_((Channel *chanPtr, char *srcPtr,
			    int slen));
d118 2
a119 3
                            Channel *chanPtr, int calledFromAsyncFlush));
static Tcl_HashTable	*GetChannelTable _ANSI_ARGS_((Tcl_Interp *interp));
static int		GetEOL _ANSI_ARGS_((Channel *chanPtr));
d121 12
a132 8
static void		RecycleBuffer _ANSI_ARGS_((Channel *chanPtr,
		            ChannelBuffer *bufPtr, int mustDiscard));
static int		ScanBufferForEOL _ANSI_ARGS_((Channel *chanPtr,
                            ChannelBuffer *bufPtr,
                            Tcl_EolTranslation translation, int eofChar,
		            int *bytesToEOLPtr, int *crSeenPtr));
static int		ScanInputForEOL _ANSI_ARGS_((Channel *chanPtr,
		            int *bytesQueuedPtr));
d134 1
a134 1
		            Channel *chanPtr, int mode));
d136 6
d143 32
a174 2
static int		CheckForDeadChannel _ANSI_ARGS_((Tcl_Interp *interp,
							Channel *chan));
d177 1
a177 1
 *----------------------------------------------------------------------
d179 1
a179 1
 * SetBlockMode --
d181 3
a183 2
 *	This function sets the blocking mode for a channel and updates
 *	the state flags.
d186 1
a186 1
 *	A standard Tcl result.
d189 1
a189 2
 *	Modifies the blocking mode of the channel and possibly generates
 *	an error.
d191 1
a191 1
 *----------------------------------------------------------------------
d194 3
a196 6
static int
SetBlockMode(interp, chanPtr, mode)
    Tcl_Interp *interp;		/* Interp for error reporting. */
    Channel *chanPtr;		/* Channel to modify. */
    int mode;			/* One of TCL_MODE_BLOCKING or
				 * TCL_MODE_NONBLOCKING. */
d198 71
a268 17
    int result = 0;
    if (chanPtr->typePtr->blockModeProc != NULL) {
	result = (chanPtr->typePtr->blockModeProc) (chanPtr->instanceData,
		mode);
    }
    if (result != 0) {
	Tcl_SetErrno(result);
	if (interp != (Tcl_Interp *) NULL) {
	    Tcl_AppendResult(interp, "error setting blocking mode: ",
		    Tcl_PosixError(interp), (char *) NULL);
	}
	return TCL_ERROR;
    }
    if (mode == TCL_MODE_BLOCKING) {
	chanPtr->flags &= (~(CHANNEL_NONBLOCKING | BG_FLUSH_SCHEDULED));
    } else {
	chanPtr->flags |= CHANNEL_NONBLOCKING;
a269 1
    return TCL_OK;
d271 1
d295 1
d298 2
a299 2
            stdinInitialized = 1;
	    stdinChannel = channel;
d302 2
a303 2
	    stdoutInitialized = 1;
	    stdoutChannel = channel;
d306 2
a307 2
	    stderrInitialized = 1;
	    stderrChannel = channel;
a327 1

d333 1
d337 1
a337 4
     * store them in the static variables.  Note that we need to set
     * stdinInitialized before calling TclGetDefaultStdChannel in order
     * to avoid recursive loops when TclGetDefaultStdChannel calls
     * Tcl_CreateChannel.
d342 3
a344 3
	    if (!stdinInitialized) {
		stdinChannel = TclGetDefaultStdChannel(TCL_STDIN);
		stdinInitialized = 1;
d346 1
a346 1
                /*
d355 1
a355 1
                if (stdinChannel != (Tcl_Channel) NULL) {
d357 1
a357 1
                            stdinChannel);
d360 1
a360 1
	    channel = stdinChannel;
d363 4
a366 14
	    if (!stdoutInitialized) {
		stdoutChannel = TclGetDefaultStdChannel(TCL_STDOUT);
		stdoutInitialized = 1;

                /*
                 * Artificially bump the refcount to ensure that the channel
                 * is only closed on exit.
                 *
                 * NOTE: Must only do this if stdoutChannel is not NULL. It
                 * can be NULL in situations where Tcl is unable to connect
                 * to the standard output.
                 */

                if (stdoutChannel != (Tcl_Channel) NULL) {
d368 1
a368 1
                            stdoutChannel);
d371 1
a371 1
	    channel = stdoutChannel;
d374 4
a377 14
	    if (!stderrInitialized) {
		stderrChannel = TclGetDefaultStdChannel(TCL_STDERR);
		stderrInitialized = 1;

                /*
                 * Artificially bump the refcount to ensure that the channel
                 * is only closed on exit.
                 *
                 * NOTE: Must only do this if stderrChannel is not NULL. It
                 * can be NULL in situations where Tcl is unable to connect
                 * to the standard error.
                 */

                if (stderrChannel != (Tcl_Channel) NULL) {
d379 1
a379 1
                            stderrChannel);
d382 1
a382 1
	    channel = stderrChannel;
d387 1
d416 1
a416 1
    Channel *chanPtr;
d419 1
a419 1
    chanPtr = (Channel *) chan;
d425 2
a426 2
    cbPtr->nextPtr = chanPtr->closeCbPtr;
    chanPtr->closeCbPtr = cbPtr;
d457 1
a457 1
    Channel *chanPtr;
d460 4
a463 4
    chanPtr = (Channel *) chan;
    for (cbPtr = chanPtr->closeCbPtr, cbPrevPtr = (CloseCallback *) NULL;
             cbPtr != (CloseCallback *) NULL;
             cbPtr = cbPtr->nextPtr) {
d466 1
a466 1
                chanPtr->closeCbPtr = cbPtr->nextPtr;
a478 103
 * CloseChannelsOnExit --
 *
 *	Closes all the existing channels, on exit. This	routine is called
 *	during exit processing.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Closes all channels.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
static void
CloseChannelsOnExit(clientData)
    ClientData clientData;		/* NULL - unused. */
{
    Channel *chanPtr;			/* Iterates over open channels. */
    Channel *nextChanPtr;		/* Iterates over open channels. */


    for (chanPtr = firstChanPtr; chanPtr != (Channel *) NULL;
             chanPtr = nextChanPtr) {
        nextChanPtr = chanPtr->nextChanPtr;

        /*
         * Set the channel back into blocking mode to ensure that we wait
         * for all data to flush out.
         */
        
        (void) Tcl_SetChannelOption(NULL, (Tcl_Channel) chanPtr,
                "-blocking", "on");

        if ((chanPtr == (Channel *) stdinChannel) ||
                (chanPtr == (Channel *) stdoutChannel) ||
                (chanPtr == (Channel *) stderrChannel)) {

            /*
             * Decrement the refcount which was earlier artificially bumped
             * up to keep the channel from being closed.
             */

            chanPtr->refCount--;
        }

        if (chanPtr->refCount <= 0) {

	    /*
             * Close it only if the refcount indicates that the channel is not
             * referenced from any interpreter. If it is, that interpreter will
             * close the channel when it gets destroyed.
             */

            (void) Tcl_Close((Tcl_Interp *) NULL, (Tcl_Channel) chanPtr);

        } else {

            /*
             * The refcount is greater than zero, so flush the channel.
             */

            Tcl_Flush((Tcl_Channel) chanPtr);

            /*
             * Call the device driver to actually close the underlying
             * device for this channel.
             */
            
            (chanPtr->typePtr->closeProc) (chanPtr->instanceData,
                    (Tcl_Interp *) NULL);

            /*
             * Finally, we clean up the fields in the channel data structure
             * since all of them have been deleted already. We mark the
             * channel with CHANNEL_DEAD to prevent any further IO operations
             * on it.
             */

            chanPtr->instanceData = (ClientData) NULL;
            chanPtr->flags |= CHANNEL_DEAD;
        }
    }

    /*
     * Reinitialize all the variables to the initial state:
     */
    
    firstChanPtr = (Channel *) NULL;
    nestedHandlerPtr = (NextChannelHandler *) NULL;
    channelExitHandlerCreated = 0;
    stdinChannel = NULL;
    stdinInitialized = 0;
    stdoutChannel = NULL;
    stdoutInitialized = 0;
    stderrChannel = NULL;
    stderrInitialized = 0;
}

/*
 *----------------------------------------------------------------------
 *
d566 2
a567 1
    Channel *chanPtr;	/* Channel being deleted. */
d572 1
a572 1
    
d580 2
a581 2
             hPtr != (Tcl_HashEntry *) NULL;
             hPtr = Tcl_FirstHashEntry(hTblPtr, &hSearch)) {
d584 1
d590 1
a590 1
        for (sPtr = chanPtr->scriptRecordPtr,
d592 2
a593 2
                 sPtr != (EventScriptRecord *) NULL;
                 sPtr = nextPtr) {
d597 1
a597 1
                    chanPtr->scriptRecordPtr = nextPtr;
d603 1
a603 1
                        ChannelEventScriptInvoker, (ClientData) sPtr);
d605 1
a605 1
		ckfree(sPtr->script);
d620 3
a622 3
        chanPtr->refCount--;
        if (chanPtr->refCount <= 0) {
            if (!(chanPtr->flags & BG_FLUSH_SCHEDULED)) {
d657 7
a663 6
    Channel *chanPtr = (Channel *) chan;
    
    if ((chan == stdinChannel) && (stdinInitialized)) {
        if (chanPtr->refCount < 2) {
            chanPtr->refCount = 0;
            stdinChannel = NULL;
d666 5
a670 4
    } else if ((chan == stdoutChannel) && (stdoutInitialized)) {
        if (chanPtr->refCount < 2) {
            chanPtr->refCount = 0;
            stdoutChannel = NULL;
d673 5
a677 4
    } else if ((chan == stderrChannel) && (stderrInitialized)) {
        if (chanPtr->refCount < 2) {
            chanPtr->refCount = 0;
            stderrChannel = NULL;
d686 1
a686 1
 * Tcl_UnregisterChannel --
d688 3
a690 3
 *	Deletes the hash entry for a channel associated with an interpreter.
 *	If the interpreter given as argument is NULL, it only decrements the
 *	reference count.
d693 1
a693 1
 *	A standard Tcl result.
d696 1
a696 1
 *	Deletes the hash entry for a channel associated with an interpreter.
d701 5
a705 4
int
Tcl_UnregisterChannel(interp, chan)
    Tcl_Interp *interp;		/* Interpreter in which channel is defined. */
    Tcl_Channel chan;		/* Channel to delete. */
d709 65
a773 1
    Channel *chanPtr;		/* The real IO channel. */
a774 2
    chanPtr = (Channel *) chan;
    
d780 1
a780 1
        hPtr = Tcl_FindHashEntry(hTblPtr, chanPtr->channelName);
d800 1
a800 1
    chanPtr->refCount--;
d816 1
a816 1
    if (chanPtr->refCount <= 0) {
d823 4
a826 4
        if ((chanPtr->curOutPtr != NULL) &&
                (chanPtr->curOutPtr->nextAdded >
                        chanPtr->curOutPtr->nextRemoved)) {
            chanPtr->flags |= BUFFER_READY;
d828 2
a829 2
        chanPtr->flags |= CHANNEL_CLOSED;
        if (!(chanPtr->flags & BG_FLUSH_SCHEDULED)) {
d839 1
a839 49
 *----------------------------------------------------------------------
 *
 * Tcl_RegisterChannel --
 *
 *	Adds an already-open channel to the channel table of an interpreter.
 *	If the interpreter passed as argument is NULL, it only increments
 *	the channel refCount.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	May increment the reference count of a channel.
 *
 *----------------------------------------------------------------------
 */

void
Tcl_RegisterChannel(interp, chan)
    Tcl_Interp *interp;		/* Interpreter in which to add the channel. */
    Tcl_Channel chan;		/* The channel to add to this interpreter
                                 * channel table. */
{
    Tcl_HashTable *hTblPtr;	/* Hash table of channels. */
    Tcl_HashEntry *hPtr;	/* Search variable. */
    int new;			/* Is the hash entry new or does it exist? */
    Channel *chanPtr;		/* The actual channel. */

    chanPtr = (Channel *) chan;

    if (chanPtr->channelName == (char *) NULL) {
        panic("Tcl_RegisterChannel: channel without name");
    }
    if (interp != (Tcl_Interp *) NULL) {
        hTblPtr = GetChannelTable(interp);
        hPtr = Tcl_CreateHashEntry(hTblPtr, chanPtr->channelName, &new);
        if (new == 0) {
            if (chan == (Tcl_Channel) Tcl_GetHashValue(hPtr)) {
                return;
            }
            panic("Tcl_RegisterChannel: duplicate channel names");
        }
        Tcl_SetHashValue(hPtr, (ClientData) chanPtr);
    }
    chanPtr->refCount++;
}

/*
 *----------------------------------------------------------------------
d848 3
a850 3
 *	A Tcl_Channel or NULL on failure. If failed, interp->result
 *	contains an error message. It also returns, in modePtr, the
 *	modes in which the channel is opened.
d855 1
a855 1
 *----------------------------------------------------------------------
d885 1
a885 1
	    chanPtr = (Channel *)Tcl_GetStdChannel(TCL_STDIN);
d887 1
a887 1
	    chanPtr = (Channel *)Tcl_GetStdChannel(TCL_STDOUT);
d889 1
a889 1
	    chanPtr = (Channel *)Tcl_GetStdChannel(TCL_STDERR);
d892 1
a892 1
	    name = chanPtr->channelName;
d895 1
a895 1
    
d904 6
d911 1
d913 1
a913 1
        *modePtr = (chanPtr->flags & (TCL_READABLE|TCL_WRITABLE));
d946 28
a974 2
    chanPtr = (Channel *) ckalloc((unsigned) sizeof(Channel));
    
d976 2
a977 2
        chanPtr->channelName = ckalloc((unsigned) (strlen(chanName) + 1));
        strcpy(chanPtr->channelName, chanName);
d982 15
a996 1
    chanPtr->flags = mask;
d1006 36
a1041 22
    chanPtr->inputTranslation = TCL_TRANSLATE_AUTO;
    chanPtr->outputTranslation = TCL_PLATFORM_TRANSLATION;
    chanPtr->inEofChar = 0;
    chanPtr->outEofChar = 0;

    chanPtr->unreportedError = 0;
    chanPtr->instanceData = instanceData;
    chanPtr->typePtr = typePtr;
    chanPtr->refCount = 0;
    chanPtr->closeCbPtr = (CloseCallback *) NULL;
    chanPtr->curOutPtr = (ChannelBuffer *) NULL;
    chanPtr->outQueueHead = (ChannelBuffer *) NULL;
    chanPtr->outQueueTail = (ChannelBuffer *) NULL;
    chanPtr->saveInBufPtr = (ChannelBuffer *) NULL;
    chanPtr->inQueueHead = (ChannelBuffer *) NULL;
    chanPtr->inQueueTail = (ChannelBuffer *) NULL;
    chanPtr->chPtr = (ChannelHandler *) NULL;
    chanPtr->interestMask = 0;
    chanPtr->scriptRecordPtr = (EventScriptRecord *) NULL;
    chanPtr->bufSize = CHANNELBUFFER_DEFAULT_SIZE;
    chanPtr->timer = NULL;
    chanPtr->csPtr = NULL;
d1049 2
a1050 2
    chanPtr->nextChanPtr = firstChanPtr;
    firstChanPtr = chanPtr;
a1051 5
    if (!channelExitHandlerCreated) {
        channelExitHandlerCreated = 1;
        Tcl_CreateExitHandler(CloseChannelsOnExit, (ClientData) NULL);
    }
    
d1057 3
a1059 2
    if ((stdinChannel == NULL) && (stdinInitialized == 1)) {
	Tcl_SetStdChannel((Tcl_Channel)chanPtr, TCL_STDIN);
d1061 3
a1063 2
    } else if ((stdoutChannel == NULL) && (stdoutInitialized == 1)) {
	Tcl_SetStdChannel((Tcl_Channel)chanPtr, TCL_STDOUT);
d1065 3
a1067 2
    } else if ((stderrChannel == NULL) && (stderrInitialized == 1)) {
	Tcl_SetStdChannel((Tcl_Channel)chanPtr, TCL_STDERR);
d1076 8
a1083 1
 * Tcl_GetChannelMode --
d1085 2
a1086 2
 *	Computes a mask indicating whether the channel is open for
 *	reading and writing.
d1089 2
a1090 1
 *	An OR-ed combination of TCL_READABLE and TCL_WRITABLE.
d1093 5
a1097 1
 *	None.
d1102 135
a1236 6
int
Tcl_GetChannelMode(chan)
    Tcl_Channel chan;		/* The channel for which the mode is
                                 * being computed. */
{
    Channel *chanPtr;		/* The actual channel. */
d1238 1
a1238 2
    chanPtr = (Channel *) chan;
    return (chanPtr->flags & (TCL_READABLE | TCL_WRITABLE));
d1244 1
a1244 1
 * Tcl_GetChannelName --
d1246 2
a1247 1
 *	Returns the string identifying the channel name.
d1250 1
a1250 3
 *	The string containing the channel name. This memory is
 *	owned by the generic layer and should not be modified by
 *	the caller.
d1253 2
a1254 1
 *	None.
d1259 4
a1262 3
char *
Tcl_GetChannelName(chan)
    Tcl_Channel chan;		/* The channel for which to return the name. */
d1264 118
a1381 1
    Channel *chanPtr;		/* The actual channel. */
d1383 1
a1383 2
    chanPtr = (Channel *) chan;
    return chanPtr->channelName;
d1389 1
a1389 1
 * Tcl_GetChannelType --
d1391 1
a1391 1
 *	Given a channel structure, returns the channel type structure.
d1394 3
a1396 1
 *	Returns a pointer to the channel type structure.
d1404 3
a1406 3
Tcl_ChannelType *
Tcl_GetChannelType(chan)
    Tcl_Channel chan;		/* The channel to return type for. */
d1408 1
a1408 1
    Channel *chanPtr;		/* The actual channel. */
d1410 1
a1410 2
    chanPtr = (Channel *) chan;
    return chanPtr->typePtr;
d1416 1
a1416 1
 * Tcl_GetChannelHandle --
d1418 1
a1418 1
 *	Returns an OS handle associated with a channel.
d1421 3
a1423 2
 *	Returns TCL_OK and places the handle in handlePtr, or returns
 *	TCL_ERROR on failure.
d1431 137
a1567 5
int
Tcl_GetChannelHandle(chan, direction, handlePtr)
    Tcl_Channel chan;		/* The channel to get file from. */
    int direction;		/* TCL_WRITABLE or TCL_READABLE. */
    ClientData *handlePtr;	/* Where to store handle */
d1573 1
a1573 1
    chanPtr = (Channel *) chan;
d1583 3
a1585 1
 *----------------------------------------------------------------------
d1587 5
a1591 1
 * Tcl_GetChannelInstanceData --
d1593 4
a1596 1
 *	Returns the client data associated with a channel.
d1599 1
a1599 1
 *	The client data.
d1604 1
a1604 1
 *----------------------------------------------------------------------
d1607 3
a1609 3
ClientData
Tcl_GetChannelInstanceData(chan)
    Tcl_Channel chan;		/* Channel for which to return client data. */
d1611 2
a1612 1
    Channel *chanPtr;		/* The actual channel. */
d1614 7
a1620 2
    chanPtr = (Channel *) chan;
    return chanPtr->instanceData;
d1644 2
a1645 2
RecycleBuffer(chanPtr, bufPtr, mustDiscard)
    Channel *chanPtr;		/* Channel for which to recycle buffers. */
d1658 1
a1658 1
    
d1663 4
a1666 4
    if (chanPtr->flags & TCL_READABLE) {
        if (chanPtr->inQueueHead == (ChannelBuffer *) NULL) {
            chanPtr->inQueueHead = bufPtr;
            chanPtr->inQueueTail = bufPtr;
d1669 2
a1670 2
        if (chanPtr->saveInBufPtr == (ChannelBuffer *) NULL) {
            chanPtr->saveInBufPtr = bufPtr;
d1679 3
a1681 3
    if (chanPtr->flags & TCL_WRITABLE) {
        if (chanPtr->curOutPtr == (ChannelBuffer *) NULL) {
            chanPtr->curOutPtr = bufPtr;
d1693 3
a1695 3
keepit:
    bufPtr->nextRemoved = 0;
    bufPtr->nextAdded = 0;
d1716 2
a1717 2
DiscardOutputQueued(chanPtr)
    Channel *chanPtr;		/* The channel for which to discard output. */
d1721 4
a1724 4
    while (chanPtr->outQueueHead != (ChannelBuffer *) NULL) {
        bufPtr = chanPtr->outQueueHead;
        chanPtr->outQueueHead = bufPtr->nextPtr;
        RecycleBuffer(chanPtr, bufPtr, 0);
d1726 2
a1727 2
    chanPtr->outQueueHead = (ChannelBuffer *) NULL;
    chanPtr->outQueueTail = (ChannelBuffer *) NULL;
d1748 1
a1748 1
CheckForDeadChannel(interp, chanPtr)
d1750 1
a1750 1
    Channel    *chanPtr;	/* The channel to check. */
d1752 1
a1752 1
    if (chanPtr->flags & CHANNEL_DEAD) {
d1756 2
a1757 2
			     "unable to access channel: invalid channel",
			     (char *) NULL);   
d1793 2
d1801 1
a1801 1
    int errorCode;			/* Stores POSIX error codes from
d1803 2
a1804 1
    errorCode = 0;
d1813 1
a1813 1
    if (CheckForDeadChannel(interp,chanPtr)) return -1;
d1827 9
a1835 9
        
        if (((chanPtr->curOutPtr != (ChannelBuffer *) NULL) &&
                (chanPtr->curOutPtr->nextAdded == chanPtr->curOutPtr->bufSize))
                || ((chanPtr->flags & BUFFER_READY) &&
                        (chanPtr->outQueueHead == (ChannelBuffer *) NULL))) {
            chanPtr->flags &= (~(BUFFER_READY));
            chanPtr->curOutPtr->nextPtr = (ChannelBuffer *) NULL;
            if (chanPtr->outQueueHead == (ChannelBuffer *) NULL) {
                chanPtr->outQueueHead = chanPtr->curOutPtr;
d1837 1
a1837 1
                chanPtr->outQueueTail->nextPtr = chanPtr->curOutPtr;
d1839 2
a1840 2
            chanPtr->outQueueTail = chanPtr->curOutPtr;
            chanPtr->curOutPtr = (ChannelBuffer *) NULL;
d1842 1
a1842 1
        bufPtr = chanPtr->outQueueHead;
d1850 1
a1850 1
                (chanPtr->flags & BG_FLUSH_SCHEDULED)) {
d1865 1
a1865 1
        
d1868 3
a1870 2
                bufPtr->buf + bufPtr->nextRemoved, toWrite, &errorCode);
            
d1894 12
a1905 10
		if (chanPtr->flags & CHANNEL_NONBLOCKING) {
		    if (!(chanPtr->flags & BG_FLUSH_SCHEDULED)) {
			chanPtr->flags |= BG_FLUSH_SCHEDULED;
			UpdateInterest(chanPtr);
                    }
                    errorCode = 0;
                    break;
		} else {
		    panic("Blocking channel driver did not block on output");
                }
d1913 2
a1914 2
                if (chanPtr->unreportedError == 0) {
                    chanPtr->unreportedError = errorCode;
d1929 1
a1929 1
            DiscardOutputQueued(chanPtr);
d1931 3
a1933 1
        }
d1942 3
a1944 3
            chanPtr->outQueueHead = bufPtr->nextPtr;
            if (chanPtr->outQueueHead == (ChannelBuffer *) NULL) {
                chanPtr->outQueueTail = (ChannelBuffer *) NULL;
d1946 1
a1946 1
            RecycleBuffer(chanPtr, bufPtr, 0);
d1949 1
a1949 1
    
d1951 4
a1954 2
     * If the queue became empty and we have the asynchronous flushing
     * mechanism active, cancel the asynchronous flushing.
d1957 8
a1964 5
    if ((chanPtr->outQueueHead == (ChannelBuffer *) NULL) &&
            (chanPtr->flags & BG_FLUSH_SCHEDULED)) {
        chanPtr->flags &= (~(BG_FLUSH_SCHEDULED));
	(chanPtr->typePtr->watchProc)(chanPtr->instanceData,
		chanPtr->interestMask);
d1973 6
a1978 6
    if ((chanPtr->flags & CHANNEL_CLOSED) && (chanPtr->refCount <= 0) &&
            (chanPtr->outQueueHead == (ChannelBuffer *) NULL) &&
            ((chanPtr->curOutPtr == (ChannelBuffer *) NULL) ||
                    (chanPtr->curOutPtr->nextAdded ==
                            chanPtr->curOutPtr->nextRemoved))) {
        return CloseChannel(interp, chanPtr, errorCode);
d1988 8
a1995 2
 *	Utility procedure to close a channel and free its associated
 *	resources.
d1998 1
a1998 1
 *	0 on success or a POSIX error code if the operation failed.
d2002 1
d2015 2
a2016 2
    Channel *prevChanPtr;		/* Preceding channel in list of
                                         * all channels - used to splice a
d2018 3
a2020 1
        
d2024 2
a2025 1
    
d2030 1
a2030 1
    DiscardInputQueued(chanPtr, 1);
d2036 3
a2038 3
    if (chanPtr->curOutPtr != (ChannelBuffer *) NULL) {
        ckfree((char *) chanPtr->curOutPtr);
        chanPtr->curOutPtr = (ChannelBuffer *) NULL;
d2046 1
a2046 1
    if (chanPtr->outQueueHead != (ChannelBuffer *) NULL) {
d2055 1
a2055 1
    if ((chanPtr->outEofChar != 0) && (chanPtr->flags & TCL_WRITABLE)) {
d2059 1
a2059 1
        c = (char) chanPtr->outEofChar;
d2062 1
a2062 1

d2064 1
a2064 1
     * Remove TCL_READABLE and TCL_WRITABLE from chanPtr->flags, so
d2071 6
a2076 2
    chanPtr->flags &= (~(TCL_READABLE|TCL_WRITABLE));
        
d2081 2
a2082 2
    if (chanPtr == firstChanPtr) {
        firstChanPtr = chanPtr->nextChanPtr;
d2084 3
a2086 4
        for (prevChanPtr = firstChanPtr;
                 (prevChanPtr != (Channel *) NULL) &&
                     (prevChanPtr->nextChanPtr != chanPtr);
                 prevChanPtr = prevChanPtr->nextChanPtr) {
d2089 1
a2089 1
        if (prevChanPtr == (Channel *) NULL) {
d2092 12
a2103 1
        prevChanPtr->nextChanPtr = chanPtr->nextChanPtr;
d2107 3
a2109 1
     * OK, close the channel itself.
d2111 12
a2122 5
        
    result = (chanPtr->typePtr->closeProc) (chanPtr->instanceData, interp);
    
    if (chanPtr->channelName != (char *) NULL) {
        ckfree(chanPtr->channelName);
d2124 1
a2124 1
    
d2129 3
a2131 3
        
    if (chanPtr->unreportedError != 0) {
        errorCode = chanPtr->unreportedError;
d2144 1
a2144 1
    Tcl_DeleteTimerHandler(chanPtr->timer);
d2150 36
d2228 1
d2230 1
d2236 1
a2236 1
    
d2247 9
a2255 2
    chanPtr = (Channel *) chan;
    if (chanPtr->refCount > 0) {
d2264 3
a2266 3
    for (nhPtr = nestedHandlerPtr;
             nhPtr != (NextChannelHandler *) NULL;
             nhPtr = nhPtr->nestedHandlerPtr) {
d2277 4
a2280 4
        
    for (chPtr = chanPtr->chPtr;
             chPtr != (ChannelHandler *) NULL;
             chPtr = chNext) {
d2284 2
a2285 3
    chanPtr->chPtr = (ChannelHandler *) NULL;
    
    
d2290 1
a2290 1
    StopCopy(chanPtr->csPtr);
d2299 1
a2299 1
    chanPtr->interestMask = 0;
d2305 3
a2307 3
    for (ePtr = chanPtr->scriptRecordPtr;
             ePtr != (EventScriptRecord *) NULL;
             ePtr = eNextPtr) {
d2309 1
a2309 1
	ckfree(ePtr->script);
d2312 1
a2312 1
    chanPtr->scriptRecordPtr = (EventScriptRecord *) NULL;
d2318 3
a2320 3
    while (chanPtr->closeCbPtr != (CloseCallback *) NULL) {
        cbPtr = chanPtr->closeCbPtr;
        chanPtr->closeCbPtr = cbPtr->nextPtr;
d2329 15
a2343 3
    if ((chanPtr->curOutPtr != (ChannelBuffer *) NULL) &&
           (chanPtr->curOutPtr->nextAdded > chanPtr->curOutPtr->nextRemoved)) {
        chanPtr->flags |= BUFFER_READY;
d2351 3
a2353 4
    
    chanPtr->flags |= CHANNEL_CLOSED;
    result = FlushChannel(interp, chanPtr, 0);
    if (result != 0) {
a2355 1

d2364 1
a2364 1
 *	Puts a sequence of characters into an output buffer, may queue the
d2381 1
a2381 1
Tcl_Write(chan, srcPtr, slen)
d2383 3
a2385 4
    char *srcPtr;			/* Output to buffer. */
    int slen;				/* Its length. Negative means
                                         * the output is null terminated
                                         * and we must compute its length. */
a2386 2
    Channel *chanPtr = (Channel *) chan;

d2388 1
a2388 11
     * Check for unreported error.
     */

    if (chanPtr->unreportedError != 0) {
        Tcl_SetErrno(chanPtr->unreportedError);
        chanPtr->unreportedError = 0;
        return -1;
    }
    
    /*
     * If the channel is not open for writing punt.
d2390 2
d2393 2
a2394 8
    if (!(chanPtr->flags & TCL_WRITABLE)) {
        Tcl_SetErrno(EACCES);
        return -1;
    }
    
    /*
     * If the channel is in the middle of a background copy, fail.
     */
d2396 1
a2396 2
    if (chanPtr->csPtr) {
	Tcl_SetErrno(EBUSY);
d2400 2
a2401 7
    /*
     * If length passed is negative, assume that the output is null terminated
     * and compute its length.
     */
    
    if (slen < 0) {
        slen = strlen(srcPtr);
d2403 1
a2403 2

    return DoWrite(chanPtr, srcPtr, slen);
d2409 1
a2409 1
 * DoWrite --
d2411 1
a2411 1
 *	Puts a sequence of characters into an output buffer, may queue the
d2427 18
a2444 27
static int
DoWrite(chanPtr, srcPtr, slen)
    Channel *chanPtr;			/* The channel to buffer output for. */
    char *srcPtr;			/* Data to write. */
    int slen;				/* Number of bytes to write. */
{
    ChannelBuffer *outBufPtr;		/* Current output buffer. */
    int foundNewline;			/* Did we find a newline in output? */
    char *dPtr, *sPtr;			/* Search variables for newline. */
    int crsent;				/* In CRLF eol translation mode,
                                         * remember the fact that a CR was
                                         * output to the channel without
                                         * its following NL. */
    int i;				/* Loop index for newline search. */
    int destCopied;			/* How many bytes were used in this
                                         * destination buffer to hold the
                                         * output? */
    int totalDestCopied;		/* How many bytes total were
                                         * copied to the channel buffer? */
    int srcCopied;			/* How many bytes were copied from
                                         * the source string? */
    char *destPtr;			/* Where in line to copy to? */

    /*
     * If we are in network (or windows) translation mode, record the fact
     * that we have not yet sent a CR to the channel.
     */
a2445 2
    crsent = 0;
    
d2447 2
a2448 2
     * Loop filling buffers and flushing them until all output has been
     * consumed.
d2451 2
a2452 2
    srcCopied = 0;
    totalDestCopied = 0;
d2454 3
a2456 98
    while (slen > 0) {
        
        /*
         * Make sure there is a current output buffer to accept output.
         */

        if (chanPtr->curOutPtr == (ChannelBuffer *) NULL) {
            chanPtr->curOutPtr = (ChannelBuffer *) ckalloc((unsigned)
                    (CHANNELBUFFER_HEADER_SIZE + chanPtr->bufSize));
            chanPtr->curOutPtr->nextAdded = 0;
            chanPtr->curOutPtr->nextRemoved = 0;
            chanPtr->curOutPtr->bufSize = chanPtr->bufSize;
            chanPtr->curOutPtr->nextPtr = (ChannelBuffer *) NULL;
        }

        outBufPtr = chanPtr->curOutPtr;

        destCopied = outBufPtr->bufSize - outBufPtr->nextAdded;
        if (destCopied > slen) {
            destCopied = slen;
        }
        
        destPtr = outBufPtr->buf + outBufPtr->nextAdded;
        switch (chanPtr->outputTranslation) {
            case TCL_TRANSLATE_LF:
                srcCopied = destCopied;
                memcpy((VOID *) destPtr, (VOID *) srcPtr, (size_t) destCopied);
                break;
            case TCL_TRANSLATE_CR:
                srcCopied = destCopied;
                memcpy((VOID *) destPtr, (VOID *) srcPtr, (size_t) destCopied);
                for (dPtr = destPtr; dPtr < destPtr + destCopied; dPtr++) {
                    if (*dPtr == '\n') {
                        *dPtr = '\r';
                    }
                }
                break;
            case TCL_TRANSLATE_CRLF:
                for (srcCopied = 0, dPtr = destPtr, sPtr = srcPtr;
                     dPtr < destPtr + destCopied;
                     dPtr++, sPtr++, srcCopied++) {
                    if (*sPtr == '\n') {
                        if (crsent) {
                            *dPtr = '\n';
                            crsent = 0;
                        } else {
                            *dPtr = '\r';
                            crsent = 1;
                            sPtr--, srcCopied--;
                        }
                    } else {
                        *dPtr = *sPtr;
                    }
                }
                break;
            case TCL_TRANSLATE_AUTO:
                panic("Tcl_Write: AUTO output translation mode not supported");
            default:
                panic("Tcl_Write: unknown output translation mode");
        }

        /*
         * The current buffer is ready for output if it is full, or if it
         * contains a newline and this channel is line-buffered, or if it
         * contains any output and this channel is unbuffered.
         */

        outBufPtr->nextAdded += destCopied;
        if (!(chanPtr->flags & BUFFER_READY)) {
            if (outBufPtr->nextAdded == outBufPtr->bufSize) {
                chanPtr->flags |= BUFFER_READY;
            } else if (chanPtr->flags & CHANNEL_LINEBUFFERED) {
                for (sPtr = srcPtr, i = 0, foundNewline = 0;
                         (i < srcCopied) && (!foundNewline);
                         i++, sPtr++) {
                    if (*sPtr == '\n') {
                        foundNewline = 1;
                        break;
                    }
                }
                if (foundNewline) {
                    chanPtr->flags |= BUFFER_READY;
                }
            } else if (chanPtr->flags & CHANNEL_UNBUFFERED) {
                chanPtr->flags |= BUFFER_READY;
            }
        }
        
        totalDestCopied += srcCopied;
        srcPtr += srcCopied;
        slen -= srcCopied;

        if (chanPtr->flags & BUFFER_READY) {
            if (FlushChannel(NULL, chanPtr, 0) != 0) {
                return -1;
            }
        }
    } /* Closes "while" */
d2458 1
a2458 1
    return totalDestCopied;
d2462 1
a2462 1
 *----------------------------------------------------------------------
d2464 1
a2464 1
 * Tcl_Flush --
d2466 5
a2470 1
 *	Flushes output data on a channel.
d2473 2
a2474 1
 *	A standard Tcl result.
d2477 2
a2478 1
 *	May flush output queued on this channel.
d2484 5
a2488 2
Tcl_Flush(chan)
    Tcl_Channel chan;			/* The Channel to flush. */
a2489 5
    int result;				/* Of calling FlushChannel. */
    Channel *chanPtr;			/* The actual channel. */

    chanPtr = (Channel *) chan;

d2491 1
a2491 1
     * Check for unreported error.
d2493 5
d2499 2
a2500 4
    if (chanPtr->unreportedError != 0) {
        Tcl_SetErrno(chanPtr->unreportedError);
        chanPtr->unreportedError = 0;
        return TCL_ERROR;
d2502 2
a2503 8

    /*
     * If the channel is not open for writing punt.
     */

    if (!(chanPtr->flags & TCL_WRITABLE)) {
        Tcl_SetErrno(EACCES);
        return TCL_ERROR;
d2505 5
a2509 4
    
    /*
     * If the channel is in the middle of a background copy, fail.
     */
d2511 2
a2512 4
    if (chanPtr->csPtr) {
	Tcl_SetErrno(EBUSY);
	return -1;
    }
d2514 5
a2518 12
    /*
     * Force current output buffer to be output also.
     */
    
    if ((chanPtr->curOutPtr != (ChannelBuffer *) NULL) &&
            (chanPtr->curOutPtr->nextAdded > 0)) {
        chanPtr->flags |= BUFFER_READY;
    }
    
    result = FlushChannel(NULL, chanPtr, 0);
    if (result != 0) {
        return TCL_ERROR;
d2520 1
a2520 2

    return TCL_OK;
d2524 1
a2524 1
 *----------------------------------------------------------------------
d2526 1
a2526 1
 * DiscardInputQueued --
d2528 8
a2535 2
 *	Discards any input read from the channel but not yet consumed
 *	by Tcl reading commands.
d2538 2
a2539 1
 *	None.
d2542 2
a2543 2
 *	May discard input from the channel. If discardLastBuffer is zero,
 *	leaves one buffer in place for back-filling.
d2548 4
a2551 6
static void
DiscardInputQueued(chanPtr, discardSavedBuffers)
    Channel *chanPtr;		/* Channel on which to discard
                                 * the queued input. */
    int discardSavedBuffers;	/* If non-zero, discard all buffers including
                                 * last one. */
d2553 10
a2562 1
    ChannelBuffer *bufPtr, *nxtPtr;	/* Loop variables. */
d2564 2
a2565 6
    bufPtr = chanPtr->inQueueHead;
    chanPtr->inQueueHead = (ChannelBuffer *) NULL;
    chanPtr->inQueueTail = (ChannelBuffer *) NULL;
    for (; bufPtr != (ChannelBuffer *) NULL; bufPtr = nxtPtr) {
        nxtPtr = bufPtr->nextPtr;
        RecycleBuffer(chanPtr, bufPtr, discardSavedBuffers);
d2567 6
a2572 11

    /*
     * If discardSavedBuffers is nonzero, must also discard any previously
     * saved buffer in the saveInBufPtr field.
     */
    
    if (discardSavedBuffers) {
        if (chanPtr->saveInBufPtr != (ChannelBuffer *) NULL) {
            ckfree((char *) chanPtr->saveInBufPtr);
            chanPtr->saveInBufPtr = (ChannelBuffer *) NULL;
        }
d2579 1
a2579 1
 * GetInput --
d2581 4
a2584 1
 *	Reads input data from a device or file into an input buffer.
d2587 2
a2588 1
 *	A Posix error code or 0.
d2591 2
a2592 1
 *	Reads from the underlying device.
d2598 4
a2601 2
GetInput(chanPtr)
    Channel *chanPtr;			/* Channel to read input from. */
d2603 4
a2606 11
    int toRead;				/* How much to read? */
    int result;				/* Of calling driver. */
    int nread;				/* How much was read from channel? */
    ChannelBuffer *bufPtr;		/* New buffer to add to input queue. */

    /*
     * Prevent reading from a dead channel -- a channel that has been closed
     * but not yet deallocated, which can happen if the exit handler for
     * channel cleanup has run but the channel is still registered in some
     * interpreter.
     */
d2608 3
a2610 1
    if (CheckForDeadChannel(NULL,chanPtr)) return EINVAL;
d2613 2
a2614 3
     * See if we can fill an existing buffer. If we can, read only
     * as much as will fit in it. Otherwise allocate a new buffer,
     * add it to the input queue and attempt to fill it to the max.
d2617 14
a2630 29
    if ((chanPtr->inQueueTail != (ChannelBuffer *) NULL) &&
           (chanPtr->inQueueTail->nextAdded < chanPtr->inQueueTail->bufSize)) {
        bufPtr = chanPtr->inQueueTail;
        toRead = bufPtr->bufSize - bufPtr->nextAdded;
    } else {
	if (chanPtr->saveInBufPtr != (ChannelBuffer *) NULL) {
	    bufPtr = chanPtr->saveInBufPtr;
	    chanPtr->saveInBufPtr = (ChannelBuffer *) NULL;
	} else {
	    bufPtr = (ChannelBuffer *) ckalloc(
		((unsigned) CHANNELBUFFER_HEADER_SIZE + chanPtr->bufSize));
	    bufPtr->bufSize = chanPtr->bufSize;
	}
	bufPtr->nextRemoved = 0;
	bufPtr->nextAdded = 0;
        toRead = bufPtr->bufSize;
        if (chanPtr->inQueueTail == (ChannelBuffer *) NULL) {
            chanPtr->inQueueHead = bufPtr;
        } else {
            chanPtr->inQueueTail->nextPtr = bufPtr;
        }
        chanPtr->inQueueTail = bufPtr;
        bufPtr->nextPtr = (ChannelBuffer *) NULL;
    }
      
    /*
     * If EOF is set, we should avoid calling the driver because on some
     * platforms it is impossible to read from a device after EOF.
     */
d2632 6
a2637 3
    if (chanPtr->flags & CHANNEL_EOF) {
	return 0;
    }
d2639 11
a2649 16
    nread = (chanPtr->typePtr->inputProc) (chanPtr->instanceData,
	    bufPtr->buf + bufPtr->nextAdded, toRead, &result);

    if (nread == 0) {
	chanPtr->flags |= CHANNEL_EOF;
    } else if (nread < 0) {
	if ((result == EWOULDBLOCK) || (result == EAGAIN)) {
	    chanPtr->flags |= CHANNEL_BLOCKED;
	    result = EAGAIN;
	    if (chanPtr->flags & CHANNEL_NONBLOCKING) {
		Tcl_SetErrno(result);
	    } else {
		panic("Blocking channel driver did not block on input");
	    }
	} else {
	    Tcl_SetErrno(result);
d2651 3
a2653 13
	return result;
    } else {
	bufPtr->nextAdded += nread;

	/*
	 * If we get a short read, signal up that we may be BLOCKED. We
	 * should avoid calling the driver because on some platforms we
	 * will block in the low level reading code even though the
	 * channel is set into nonblocking mode.
	 */
            
	if (nread < toRead) {
	    chanPtr->flags |= CHANNEL_BLOCKED;
d2655 4
d2660 1
a2660 1
    return 0;
d2666 1
a2666 1
 * CopyAndTranslateBuffer --
d2668 5
a2672 2
 *	Copy at most one buffer of input to the result space, doing
 *	eol translations according to mode in effect currently.
d2675 2
a2676 2
 *	Number of characters (as opposed to bytes) copied. May return
 *	zero if no input is available to be translated.
d2679 2
a2680 1
 *	Consumes buffered input. May deallocate one buffer.
d2686 4
a2689 5
CopyAndTranslateBuffer(chanPtr, result, space)
    Channel *chanPtr;		/* The channel from which to read input. */
    char *result;		/* Where to store the copied input. */
    int space;			/* How many bytes are available in result
                                 * to store the copied input? */
d2691 28
a2718 27
    int bytesInBuffer;		/* How many bytes are available to be
                                 * copied in the current input buffer? */
    int copied;			/* How many characters were already copied
                                 * into the destination space? */
    ChannelBuffer *bufPtr;	/* The buffer from which to copy bytes. */
    char curByte;		/* The byte we are currently translating. */
    int i;			/* Iterates over the copied input looking
                                 * for the input eofChar. */
    
    /*
     * If there is no input at all, return zero. The invariant is that either
     * there is no buffer in the queue, or if the first buffer is empty, it
     * is also the last buffer (and thus there is no input in the queue).
     * Note also that if the buffer is empty, we leave it in the queue.
     */
    
    if (chanPtr->inQueueHead == (ChannelBuffer *) NULL) {
        return 0;
    }
    bufPtr = chanPtr->inQueueHead;
    bytesInBuffer = bufPtr->nextAdded - bufPtr->nextRemoved;
    if (bytesInBuffer < space) {
        space = bytesInBuffer;
    }
    copied = 0;
    switch (chanPtr->inputTranslation) {
        case TCL_TRANSLATE_LF:
d2720 1
a2720 4
            if (space == 0) {
                return 0;
            }
            
d2722 11
a2732 2
             * Copy the current chunk into the result buffer.
             */
d2734 10
a2743 6
            memcpy((VOID *) result,
                    (VOID *)(bufPtr->buf + bufPtr->nextRemoved),
                    (size_t) space);
            bufPtr->nextRemoved += space;
            copied = space;
            break;
d2745 4
a2748 1
        case TCL_TRANSLATE_CR:
d2750 4
a2753 3
            if (space == 0) {
                return 0;
            }
d2755 8
a2762 4
	    /*
             * Copy the current chunk into the result buffer, then
             * replace all \r with \n.
             */
d2764 13
a2776 10
            memcpy((VOID *) result,
                    (VOID *)(bufPtr->buf + bufPtr->nextRemoved),
                    (size_t) space);
            bufPtr->nextRemoved += space;
            for (copied = 0; copied < space; copied++) {
                if (result[copied] == '\r') {
                    result[copied] = '\n';
                }
            }
            break;
d2778 9
a2786 1
        case TCL_TRANSLATE_CRLF:
d2788 16
a2803 13
            /*
             * If there is a held-back "\r" at EOF, produce it now.
             */
            
            if (space == 0) {
                if ((chanPtr->flags & (INPUT_SAW_CR | CHANNEL_EOF)) ==
                        (INPUT_SAW_CR | CHANNEL_EOF)) {
                    result[0] = '\r';
                    chanPtr->flags &= (~(INPUT_SAW_CR));
                    return 1;
                }
                return 0;
            }
d2805 7
a2811 4
            /*
             * Copy the current chunk and replace "\r\n" with "\n"
             * (but not standalone "\r"!).
             */
d2813 5
a2817 128
            for (copied = 0;
                     (copied < space) &&
                         (bufPtr->nextRemoved < bufPtr->nextAdded);
                     copied++) {
                curByte = bufPtr->buf[bufPtr->nextRemoved];
                bufPtr->nextRemoved++;
                if (curByte == '\r') {
                    if (chanPtr->flags & INPUT_SAW_CR) {
                        result[copied] = '\r';
                    } else {
                        chanPtr->flags |= INPUT_SAW_CR;
                        copied--;
                    }
                } else if (curByte == '\n') {
                    chanPtr->flags &= (~(INPUT_SAW_CR));
                    result[copied] = '\n';
                } else {
                    if (chanPtr->flags & INPUT_SAW_CR) {
                        chanPtr->flags &= (~(INPUT_SAW_CR));
                        result[copied] = '\r';
                        bufPtr->nextRemoved--;
                    } else {
                        result[copied] = curByte;
                    }
                }
            }
            break;
                
        case TCL_TRANSLATE_AUTO:
            
            if (space == 0) {
                return 0;
            }

            /*
             * Loop over the current buffer, converting "\r" and "\r\n"
             * to "\n".
             */

            for (copied = 0;
                     (copied < space) &&
                         (bufPtr->nextRemoved < bufPtr->nextAdded); ) {
                curByte = bufPtr->buf[bufPtr->nextRemoved];
                bufPtr->nextRemoved++;
                if (curByte == '\r') {
                    result[copied] = '\n';
		    copied++;
                    if (bufPtr->nextRemoved < bufPtr->nextAdded) {
                        if (bufPtr->buf[bufPtr->nextRemoved] == '\n') {
                            bufPtr->nextRemoved++;
                        }
                        chanPtr->flags &= (~(INPUT_SAW_CR));
                    } else {
                        chanPtr->flags |= INPUT_SAW_CR;
                    }
                } else {
                    if (curByte == '\n') {
                        if (!(chanPtr->flags & INPUT_SAW_CR)) {
                            result[copied] = '\n';
			    copied++;
                        }
                    } else {
                        result[copied] = curByte;
			copied++;
                    }
                    chanPtr->flags &= (~(INPUT_SAW_CR));
                }
            }
            break;

        default:
            panic("unknown eol translation mode");
    }

    /*
     * If an in-stream EOF character is set for this channel,, check that
     * the input we copied so far does not contain the EOF char. If it does,
     * copy only up to and excluding that character.
     */
    
    if (chanPtr->inEofChar != 0) {
        for (i = 0; i < copied; i++) {
            if (result[i] == (char) chanPtr->inEofChar) {
                break;
            }
        }
        if (i < copied) {

            /*
             * Set sticky EOF so that no further input is presented
             * to the caller.
             */
            
            chanPtr->flags |= (CHANNEL_EOF | CHANNEL_STICKY_EOF);

            /*
             * Reset the start of valid data in the input buffer to the
             * position of the eofChar, so that subsequent reads will
             * encounter it immediately. First we set it to the position
             * of the last byte consumed if all result bytes were the
             * product of one input byte; since it is possible that "\r\n"
             * contracted to "\n" in the result, we have to search back
             * from that position until we find the eofChar, because it
             * is possible that its actual position in the buffer is n
             * bytes further back (n is the number of "\r\n" sequences
             * that were contracted to "\n" in the result).
             */
                  
            bufPtr->nextRemoved -= (copied - i);
            while ((bufPtr->nextRemoved > 0) &&
                    (bufPtr->buf[bufPtr->nextRemoved] !=
                            (char) chanPtr->inEofChar)) {
                bufPtr->nextRemoved--;
            }
            copied = i;
        }
    }

    /*
     * If the current buffer is empty recycle it.
     */

    if (bufPtr->nextRemoved == bufPtr->nextAdded) {
        chanPtr->inQueueHead = bufPtr->nextPtr;
        if (chanPtr->inQueueHead == (ChannelBuffer *) NULL) {
            chanPtr->inQueueTail = (ChannelBuffer *) NULL;
        }
        RecycleBuffer(chanPtr, bufPtr, 0);
d2819 1
a2819 8

    /*
     * Return the number of characters copied into the result buffer.
     * This may be different from the number of bytes consumed, because
     * of EOL translations.
     */

    return copied;
d2823 7
a2829 1
 *----------------------------------------------------------------------
d2831 2
a2832 1
 * ScanBufferForEOL --
d2834 5
a2838 3
 *	Scans one buffer for EOL according to the specified EOL
 *	translation mode. If it sees the input eofChar for the channel
 *	it stops also.
d2841 11
a2851 3
 *	TRUE if EOL is found, FALSE otherwise. Also sets output parameter
 *	bytesToEOLPtr to the number of bytes so far to EOL, and crSeenPtr
 *	to whether a "\r" was seen.
d2854 4
a2857 1
 *	None.
d2859 1
a2859 1
 *----------------------------------------------------------------------
d2863 52
a2914 25
ScanBufferForEOL(chanPtr, bufPtr, translation, eofChar, bytesToEOLPtr,
                 crSeenPtr)
    Channel *chanPtr;
    ChannelBuffer *bufPtr;		/* Buffer to scan for EOL. */
    Tcl_EolTranslation translation;	/* Translation mode to use. */
    int eofChar;			/* EOF char to look for. */
    int *bytesToEOLPtr;			/* Running counter. */
    int *crSeenPtr;			/* Has "\r" been seen? */
{
    char *rPtr;				/* Iterates over input string. */
    char *sPtr;				/* Where to stop search? */
    int EOLFound;
    int bytesToEOL;
    
    for (EOLFound = 0, rPtr = bufPtr->buf + bufPtr->nextRemoved,
             sPtr = bufPtr->buf + bufPtr->nextAdded,
             bytesToEOL = *bytesToEOLPtr;
             (!EOLFound) && (rPtr < sPtr);
             rPtr++) {
        switch (translation) {
            case TCL_TRANSLATE_AUTO:
                if ((*rPtr == (char) eofChar) && (eofChar != 0)) {
                    chanPtr->flags |= (CHANNEL_EOF | CHANNEL_STICKY_EOF);
                    EOLFound = 1;
                } else if (*rPtr == '\n') {
d2916 5
a2920 10
		    /*
                     * CopyAndTranslateBuffer wants to know the length
                     * of the result, not the input. The input is one
                     * larger because "\r\n" shrinks to "\n".
                     */

                    if (!(*crSeenPtr)) {
                        bytesToEOL++;
			EOLFound = 1;
                    } else {
d2922 11
a2932 16
			/*
			 * This is a lf at the begining of a buffer
			 * where the previous buffer ended in a cr.
			 * Consume this lf because we've already emitted
			 * the newline for this crlf sequence. ALSO, if
                         * bytesToEOL is 0 (which means that we are at the
                         * first character of the scan), unset the
                         * INPUT_SAW_CR flag in the channel, because we
                         * already handled it; leaving it set would cause
                         * CopyAndTranslateBuffer to potentially consume
                         * another lf if one follows the current byte.
			 */

			bufPtr->nextRemoved++;
                        *crSeenPtr = 0;
                        chanPtr->flags &= (~(INPUT_SAW_CR));
d2934 12
a2945 59
                } else if (*rPtr == '\r') {
                    bytesToEOL++;
                    EOLFound = 1;
                } else {
                    *crSeenPtr = 0;
                    bytesToEOL++;
                }
                break;
            case TCL_TRANSLATE_LF:
                if ((*rPtr == (char) eofChar) && (eofChar != 0)) {
                    chanPtr->flags |= (CHANNEL_EOF | CHANNEL_STICKY_EOF);
                    EOLFound = 1;
                } else {
                    if (*rPtr == '\n') {
                        EOLFound = 1;
                    }
                    bytesToEOL++;
                }
                break;
            case TCL_TRANSLATE_CR:
                if ((*rPtr == (char) eofChar) && (eofChar != 0)) {
                    chanPtr->flags |= (CHANNEL_EOF | CHANNEL_STICKY_EOF);
                    EOLFound = 1;
                } else {
                    if (*rPtr == '\r') {
                        EOLFound = 1;
                    }
                    bytesToEOL++;
                }
                break;
            case TCL_TRANSLATE_CRLF:
                if ((*rPtr == (char) eofChar) && (eofChar != 0)) {
                    chanPtr->flags |= (CHANNEL_EOF | CHANNEL_STICKY_EOF);
                    EOLFound = 1;
                } else if (*rPtr == '\n') {

                    /*
                     * CopyAndTranslateBuffer wants to know the length
                     * of the result, not the input. The input is one
                     * larger because crlf shrinks to lf.
                     */

                    if (*crSeenPtr) {
                        EOLFound = 1;
                    } else {
                        bytesToEOL++;
                    }
                } else {
                    if (*rPtr == '\r') {
                        *crSeenPtr = 1;
                    } else {
                        *crSeenPtr = 0;
                    }
                    bytesToEOL++;
                }
                break;
            default:
                panic("unknown eol translation mode");
        }
d2947 1
a2947 3

    *bytesToEOLPtr = bytesToEOL;
    return EOLFound;
d2951 1
a2951 1
 *----------------------------------------------------------------------
d2953 1
a2953 1
 * ScanInputForEOL --
d2955 2
a2956 3
 *	Scans queued input for chanPtr for an end of line (according to the
 *	current EOL translation mode) and returns the number of bytes
 *	upto and including the end of line, or -1 if none was found.
d2959 2
a2960 3
 *	Count of bytes upto and including the end of line if one is present
 *	or -1 if none was found. Also returns in an output parameter the
 *	number of bytes queued if no end of line was found.
d2963 1
a2963 1
 *	None.
d2965 1
a2965 1
 *----------------------------------------------------------------------
d2969 29
a2997 21
ScanInputForEOL(chanPtr, bytesQueuedPtr)
    Channel *chanPtr;	/* Channel for which to scan queued
                                 * input for end of line. */
    int *bytesQueuedPtr;	/* Where to store the number of bytes
                                 * currently queued if no end of line
                                 * was found. */
{
    ChannelBuffer *bufPtr;	/* Iterates over queued buffers. */
    int bytesToEOL;		/* How many bytes to end of line? */
    int EOLFound;		/* Did we find an end of line? */
    int crSeen;			/* Did we see a "\r" in CRLF mode? */

    *bytesQueuedPtr = 0;
    bytesToEOL = 0;
    EOLFound = 0;
    for (bufPtr = chanPtr->inQueueHead,
             crSeen = (chanPtr->flags & INPUT_SAW_CR) ? 1 : 0;
            (!EOLFound) && (bufPtr != (ChannelBuffer *) NULL);
            bufPtr = bufPtr->nextPtr) {
        EOLFound = ScanBufferForEOL(chanPtr, bufPtr, chanPtr->inputTranslation,
                chanPtr->inEofChar, &bytesToEOL, &crSeen);
d2999 33
d3033 5
a3037 3
    if (EOLFound == 0) {
        *bytesQueuedPtr = bytesToEOL;
        return -1;
d3039 2
a3040 1
    return bytesToEOL;        
d3044 1
a3044 1
 *----------------------------------------------------------------------
d3046 1
a3046 1
 * GetEOL --
d3048 4
a3051 2
 *	Accumulate input into the channel input buffer queue until an
 *	end of line has been seen.
d3054 3
a3056 1
 *	Number of bytes buffered (at least 1) or -1 on failure.
d3061 5
a3065 1
 *----------------------------------------------------------------------
d3068 5
a3072 3
static int
GetEOL(chanPtr)
    Channel *chanPtr;	/* Channel to queue input on. */
d3074 9
a3082 4
    int bytesToEOL;		/* How many bytes in buffer up to and
                                 * including the end of line? */
    int bytesQueued;		/* How many bytes are queued currently
                                 * in the input chain of the channel? */
d3085 1
a3085 1
     * Check for unreported error.
d3088 5
a3092 4
    if (chanPtr->unreportedError != 0) {
        Tcl_SetErrno(chanPtr->unreportedError);
        chanPtr->unreportedError = 0;
        return -1;
d3095 3
d3099 2
a3100 1
     * Punt if the channel is not opened for reading.
d3103 6
a3108 3
    if (!(chanPtr->flags & TCL_READABLE)) {
        Tcl_SetErrno(EACCES);
        return -1;
d3112 3
a3114 1
     * If the channel is in the middle of a background copy, fail.
d3117 2
a3118 3
    if (chanPtr->csPtr) {
	Tcl_SetErrno(EBUSY);
	return -1;
d3122 2
a3123 4
     * If we have not encountered a sticky EOF, clear the EOF bit
     * (sticky EOF is set if we have seen the input eofChar, to prevent
     * reading beyond the eofChar). Also, always clear the BLOCKED bit.
     * We want to discover these conditions anew in each operation.
d3125 17
a3141 5
    
    if (!(chanPtr->flags & CHANNEL_STICKY_EOF)) {
        chanPtr->flags &= (~(CHANNEL_EOF));
    }
    chanPtr->flags &= (~(CHANNEL_BLOCKED | CHANNEL_GETS_BLOCKED));
d3144 134
a3277 6
        bytesToEOL = ScanInputForEOL(chanPtr, &bytesQueued);
        if (bytesToEOL > 0) {
            chanPtr->flags &= (~(CHANNEL_BLOCKED));
            return bytesToEOL;
        }
        if (chanPtr->flags & CHANNEL_EOF) {
d3279 3
a3281 3
	     * Boundary case where cr was at the end of the previous buffer
	     * and this buffer just has a newline.  At EOF our caller wants
	     * to see -1 for the line length.
d3283 63
a3345 11
            return (bytesQueued == 0) ? -1 : bytesQueued ;
        }
        if (chanPtr->flags & CHANNEL_BLOCKED) {
            if (chanPtr->flags & CHANNEL_NONBLOCKING) {
		goto blocked;
            }
            chanPtr->flags &= (~(CHANNEL_BLOCKED));
        }
	if (GetInput(chanPtr) != 0) {
	    goto blocked;
        }
d3347 1
d3349 3
a3351 1
    blocked:
d3364 11
a3374 2
    chanPtr->flags |= CHANNEL_GETS_BLOCKED;
    return -1;
d3376 1
a3376 1

d3378 3
a3380 1
 *----------------------------------------------------------------------
d3382 2
a3383 1
 * Tcl_Read --
d3385 4
a3388 1
 *	Reads a given number of characters from a channel.
d3391 2
a3392 2
 *	The number of characters read, or -1 on error. Use Tcl_GetErrno()
 *	to retrieve the error code for the error that occurred.
d3395 2
a3396 1
 *	May cause input to be buffered.
d3398 1
a3398 1
 *----------------------------------------------------------------------
d3400 34
d3435 24
a3458 9
int
Tcl_Read(chan, bufPtr, toRead)
    Tcl_Channel chan;		/* The channel from which to read. */
    char *bufPtr;		/* Where to store input read. */
    int toRead;			/* Maximum number of characters to read. */
{
    Channel *chanPtr;		/* The real IO channel. */
    
    chanPtr = (Channel *) chan;
d3461 3
a3463 1
     * Check for unreported error.
d3466 10
a3475 4
    if (chanPtr->unreportedError != 0) {
        Tcl_SetErrno(chanPtr->unreportedError);
        chanPtr->unreportedError = 0;
        return -1;
d3477 24
d3502 16
a3517 3
    /*
     * Punt if the channel is not opened for reading.
     */
d3519 6
a3524 8
    if (!(chanPtr->flags & TCL_READABLE)) {
        Tcl_SetErrno(EACCES);
        return -1;
    }
    
    /*
     * If the channel is in the middle of a background copy, fail.
     */
d3526 14
a3539 3
    if (chanPtr->csPtr) {
	Tcl_SetErrno(EBUSY);
	return -1;
d3542 2
a3543 1
    return DoRead(chanPtr, bufPtr, toRead);
d3547 1
a3547 1
 *----------------------------------------------------------------------
d3549 1
a3549 1
 * DoRead --
d3551 3
a3553 1
 *	Reads a given number of characters from a channel.
d3556 3
a3558 2
 *	The number of characters read, or -1 on error. Use Tcl_GetErrno()
 *	to retrieve the error code for the error that occurred.
d3561 3
a3563 1
 *	May cause input to be buffered.
d3565 1
a3565 1
 *----------------------------------------------------------------------
d3568 6
a3573 5
static int
DoRead(chanPtr, bufPtr, toRead)
    Channel *chanPtr;		/* The channel from which to read. */
    char *bufPtr;		/* Where to store input read. */
    int toRead;			/* Maximum number of characters to read. */
d3575 7
a3581 6
    int copied;			/* How many characters were copied into
                                 * the result string? */
    int copiedNow;		/* How many characters were copied from
                                 * the current input buffer? */
    int result;			/* Of calling GetInput. */
    
d3583 5
a3587 3
     * If we have not encountered a sticky EOF, clear the EOF bit. Either
     * way clear the BLOCKED bit. We want to discover these anew during
     * each operation.
d3590 26
a3615 2
    if (!(chanPtr->flags & CHANNEL_STICKY_EOF)) {
        chanPtr->flags &= (~(CHANNEL_EOF));
d3617 2
a3618 23
    chanPtr->flags &= (~(CHANNEL_BLOCKED | CHANNEL_GETS_BLOCKED));
    
    for (copied = 0; copied < toRead; copied += copiedNow) {
        copiedNow = CopyAndTranslateBuffer(chanPtr, bufPtr + copied,
                toRead - copied);
        if (copiedNow == 0) {
            if (chanPtr->flags & CHANNEL_EOF) {
		goto done;
            }
            if (chanPtr->flags & CHANNEL_BLOCKED) {
                if (chanPtr->flags & CHANNEL_NONBLOCKING) {
		    goto done;
                }
                chanPtr->flags &= (~(CHANNEL_BLOCKED));
            }
            result = GetInput(chanPtr);
            if (result != 0) {
                if (result != EAGAIN) {
		    copied = -1;
                }
		goto done;
            }
        }
d3620 1
d3622 6
a3627 10
    chanPtr->flags &= (~(CHANNEL_BLOCKED));

    done:
    /*
     * Update the notifier state so we don't block while there is still
     * data in the buffers.
     */

    UpdateInterest(chanPtr);
    return copied;
d3631 1
a3631 1
 *----------------------------------------------------------------------
d3633 1
a3633 1
 * Tcl_Gets --
d3635 2
a3636 2
 *	Reads a complete line of input from the channel into a
 *	Tcl_DString.
d3639 1
a3639 3
 *	Length of line read or -1 if error, EOF or blocked. If -1, use
 *	Tcl_GetErrno() to retrieve the POSIX error code for the
 *	error or condition that occurred.
d3642 1
a3642 2
 *	May flush output on the channel. May cause input to be
 *	consumed from the channel.
d3644 1
a3644 1
 *----------------------------------------------------------------------
d3646 8
a3653 23

int
Tcl_Gets(chan, lineRead)
    Tcl_Channel chan;		/* Channel from which to read. */
    Tcl_DString *lineRead;	/* The characters of the line read
                                 * (excluding the terminating newline if
                                 * present) will be appended to this
                                 * DString. The caller must have initialized
                                 * it and is responsible for managing the
                                 * storage. */
{
    Channel *chanPtr;		/* The channel to read from. */
    char *buf;			/* Points into DString where data
                                 * will be stored. */
    int offset;			/* Offset from start of DString at
                                 * which to append the line just read. */
    int copiedTotal;		/* Accumulates total length of input copied. */
    int copiedNow;		/* How many bytes were copied from the
                                 * current input buffer? */
    int lineLen;		/* Length of line read, including the
                                 * translated newline. If this is zero
                                 * and neither EOF nor BLOCKED is set,
                                 * the current line is empty. */
d3655 7
a3661 6
    chanPtr = (Channel *) chan;

    lineLen = GetEOL(chanPtr);
    if (lineLen < 0) {
	copiedTotal = -1;
	goto done;
d3663 27
a3689 7
    offset = Tcl_DStringLength(lineRead);
    Tcl_DStringSetLength(lineRead, lineLen + offset);
    buf = Tcl_DStringValue(lineRead) + offset;

    for (copiedTotal = 0; copiedTotal < lineLen; copiedTotal += copiedNow) {
        copiedNow = CopyAndTranslateBuffer(chanPtr, buf + copiedTotal,
                lineLen - copiedTotal);
d3691 2
a3692 2
    if ((copiedTotal > 0) && (buf[copiedTotal - 1] == '\n')) {
        copiedTotal--;
a3693 10
    Tcl_DStringSetLength(lineRead, copiedTotal + offset);

    done:
    /*
     * Update the notifier state so we don't block while there is still
     * data in the buffers.
     */

    UpdateInterest(chanPtr);
    return copiedTotal;
d3699 6
a3704 1
 * Tcl_GetsObj --
d3706 1
a3706 2
 *	Reads a complete line of input from the channel into a
 *	string object.
d3709 2
a3710 3
 *	Length of line read or -1 if error, EOF or blocked. If -1, use
 *	Tcl_GetErrno() to retrieve the POSIX error code for the
 *	error or condition that occurred.
d3713 1
a3713 2
 *	May flush output on the channel. May cause input to be
 *	consumed from the channel.
d3719 11
a3729 23
Tcl_GetsObj(chan, objPtr)
    Tcl_Channel chan;		/* Channel from which to read. */
    Tcl_Obj *objPtr;		/* The characters of the line read
                                 * (excluding the terminating newline if
                                 * present) will be appended to this
                                 * object. The caller must have initialized
                                 * it and is responsible for managing the
                                 * storage. */
{
    Channel *chanPtr;		/* The channel to read from. */
    char *buf;			/* Points into DString where data
                                 * will be stored. */
    int offset;			/* Offset from start of DString at
                                 * which to append the line just read. */
    int copiedTotal;		/* Accumulates total length of input copied. */
    int copiedNow;		/* How many bytes were copied from the
                                 * current input buffer? */
    int lineLen;		/* Length of line read, including the
                                 * translated newline. If this is zero
                                 * and neither EOF nor BLOCKED is set,
                                 * the current line is empty. */
    
    chanPtr = (Channel *) chan;
d3731 1
a3731 5
    lineLen = GetEOL(chanPtr);
    if (lineLen < 0) {
	copiedTotal = -1;
	goto done;
    }
d3733 2
a3734 7
    (void) Tcl_GetStringFromObj(objPtr, &offset);
    Tcl_SetObjLength(objPtr, lineLen + offset);
    buf = Tcl_GetStringFromObj(objPtr, NULL) + offset;

    for (copiedTotal = 0; copiedTotal < lineLen; copiedTotal += copiedNow) {
        copiedNow = CopyAndTranslateBuffer(chanPtr, buf + copiedTotal,
                lineLen - copiedTotal);
a3735 10
    if ((copiedTotal > 0) && (buf[copiedTotal - 1] == '\n')) {
        copiedTotal--;
    }
    Tcl_SetObjLength(objPtr, copiedTotal + offset);

    done:
    /*
     * Update the notifier state so we don't block while there is still
     * data in the buffers.
     */
d3737 1
a3737 2
    UpdateInterest(chanPtr);
    return copiedTotal;
d3743 6
a3748 1
 * Tcl_Ungets --
d3750 1
a3750 2
 *	Causes the supplied string to be added to the input queue of
 *	the channel, at either the head or tail of the queue.
d3753 2
a3754 1
 *	The number of bytes stored in the channel, or -1 on error.
d3757 1
a3757 1
 *	Adds input to the input queue of a channel.
d3763 4
a3766 6
Tcl_Ungets(chan, str, len, atEnd)
    Tcl_Channel chan;		/* The channel for which to add the input. */
    char *str;			/* The input itself. */
    int len;			/* The length of the input. */
    int atEnd;			/* If non-zero, add at end of queue; otherwise
                                 * add at head of queue. */    
d3768 4
a3771 5
    Channel *chanPtr;		/* The real IO channel. */
    ChannelBuffer *bufPtr;	/* Buffer to contain the data. */
    int i;

    chanPtr = (Channel *) chan;
d3774 9
a3782 1
     * Check for unreported error.
d3785 2
a3786 4
    if (chanPtr->unreportedError != 0) {
        Tcl_SetErrno(chanPtr->unreportedError);
        chanPtr->unreportedError = 0;
        return -1;
d3790 3
a3792 1
     * Punt if the channel is not opened for reading.
d3795 60
a3854 3
    if (!(chanPtr->flags & TCL_READABLE)) {
        Tcl_SetErrno(EACCES);
        return -1;
d3857 46
d3904 1
a3904 1
     * If the channel is in the middle of a background copy, fail.
d3907 5
a3911 3
    if (chanPtr->csPtr) {
	Tcl_SetErrno(EBUSY);
	return -1;
d3914 2
a3915 7
    /*
     * If we have encountered a sticky EOF, just punt without storing.
     * (sticky EOF is set if we have seen the input eofChar, to prevent
     * reading beyond the eofChar). Otherwise, clear the EOF flags, and
     * clear the BLOCKED bit. We want to discover these conditions anew
     * in each operation.
     */
d3917 13
a3929 2
    if (chanPtr->flags & CHANNEL_STICKY_EOF) {
        return len;
a3930 1
    chanPtr->flags &= (~(CHANNEL_BLOCKED | CHANNEL_EOF));
d3932 48
a3979 4
    bufPtr = (ChannelBuffer *) ckalloc((unsigned)
            (CHANNELBUFFER_HEADER_SIZE + len));
    for (i = 0; i < len; i++) {
        bufPtr->buf[i] = str[i];
d3981 3
a3983 12
    bufPtr->bufSize = len;
    bufPtr->nextAdded = len;
    bufPtr->nextRemoved = 0;

    if (chanPtr->inQueueHead == (ChannelBuffer *) NULL) {
        bufPtr->nextPtr = (ChannelBuffer *) NULL;
        chanPtr->inQueueHead = bufPtr;
        chanPtr->inQueueTail = bufPtr;
    } else if (atEnd) {
        bufPtr->nextPtr = (ChannelBuffer *) NULL;
        chanPtr->inQueueTail->nextPtr = bufPtr;
        chanPtr->inQueueTail = bufPtr;
d3985 1
a3985 2
        bufPtr->nextPtr = chanPtr->inQueueHead;
        chanPtr->inQueueHead = bufPtr;
d3988 1
d3995 1
a3995 1
    return len;
a3996 1

d3998 3
a4000 1
 *----------------------------------------------------------------------
d4002 4
a4005 1
 * Tcl_Seek --
d4007 3
a4009 2
 *	Implements seeking on Tcl Channels. This is a public function
 *	so that other C facilities may be implemented on top of it.
d4012 4
a4015 2
 *	The new access point or -1 on error. If error, use Tcl_GetErrno()
 *	to retrieve the POSIX error code for the error that occurred.
d4018 1
a4018 1
 *	May flush output on the channel. May discard queued input.
d4020 1
a4020 1
 *----------------------------------------------------------------------
d4023 20
a4042 5
int
Tcl_Seek(chan, offset, mode)
    Tcl_Channel chan;		/* The channel on which to seek. */
    int offset;			/* Offset to seek to. */
    int mode;			/* Relative to which location to seek? */
d4044 1
a4044 1
    Channel *chanPtr;		/* The real IO channel. */
d4046 1
a4046 6
    int inputBuffered, outputBuffered;
    int result;			/* Of device driver operations. */
    int curPos;			/* Position on the device. */
    int wasAsync;		/* Was the channel nonblocking before the
                                 * seek operation? If so, must restore to
                                 * nonblocking mode after the seek. */
d4048 1
a4048 1
    chanPtr = (Channel *) chan;
d4050 3
a4052 3
    /*
     * Check for unreported error.
     */
d4054 3
a4056 4
    if (chanPtr->unreportedError != 0) {
        Tcl_SetErrno(chanPtr->unreportedError);
        chanPtr->unreportedError = 0;
        return -1;
d4059 7
a4065 4
    /*
     * Disallow seek on channels that are open for neither writing nor
     * reading (e.g. socket server channels).
     */
d4067 5
a4071 3
    if (!(chanPtr->flags & (TCL_WRITABLE|TCL_READABLE))) {
        Tcl_SetErrno(EACCES);
        return -1;
d4073 1
d4075 12
a4086 3
    /*
     * If the channel is in the middle of a background copy, fail.
     */
d4088 6
a4093 3
    if (chanPtr->csPtr) {
	Tcl_SetErrno(EBUSY);
	return -1;
d4095 31
d4127 30
a4156 6
    /*
     * Disallow seek on dead channels -- channels that have been closed but
     * not yet been deallocated. Such channels can be found if the exit
     * handler for channel cleanup has run but the channel is still
     * registered in an interpreter.
     */
d4158 2
a4159 1
    if (CheckForDeadChannel(NULL,chanPtr)) return -1;
d4161 3
a4163 4
    /*
     * Disallow seek on channels whose type does not have a seek procedure
     * defined. This means that the channel does not support seeking.
     */
d4165 3
a4167 3
    if (chanPtr->typePtr->seekProc == (Tcl_DriverSeekProc *) NULL) {
        Tcl_SetErrno(EINVAL);
        return -1;
d4171 4
a4174 2
     * Compute how much input and output is buffered. If both input and
     * output is buffered, cannot compute the current position.
d4177 17
a4193 4
    for (bufPtr = chanPtr->inQueueHead, inputBuffered = 0;
             bufPtr != (ChannelBuffer *) NULL;
             bufPtr = bufPtr->nextPtr) {
        inputBuffered += (bufPtr->nextAdded - bufPtr->nextRemoved);
d4195 8
a4202 4
    for (bufPtr = chanPtr->outQueueHead, outputBuffered = 0;
             bufPtr != (ChannelBuffer *) NULL;
             bufPtr = bufPtr->nextPtr) {
        outputBuffered += (bufPtr->nextAdded - bufPtr->nextRemoved);
d4204 28
a4231 5
    if ((chanPtr->curOutPtr != (ChannelBuffer *) NULL) &&
           (chanPtr->curOutPtr->nextAdded > chanPtr->curOutPtr->nextRemoved)) {
        chanPtr->flags |= BUFFER_READY;
        outputBuffered +=
            (chanPtr->curOutPtr->nextAdded - chanPtr->curOutPtr->nextRemoved);
d4234 9
a4242 4
    if ((inputBuffered != 0) && (outputBuffered != 0)) {
        Tcl_SetErrno(EFAULT);
        return -1;
    }
d4244 9
a4252 4
    /*
     * If we are seeking relative to the current position, compute the
     * corrected offset taking into account the amount of unread input.
     */
d4254 9
a4262 2
    if (mode == SEEK_CUR) {
        offset -= inputBuffered;
d4265 17
d4283 3
a4285 2
     * Discard any queued input - this input should not be read after
     * the seek.
d4288 1
a4288 1
    DiscardInputQueued(chanPtr, 0);
d4290 6
a4295 4
    /*
     * Reset EOF and BLOCKED flags. We invalidate them by moving the
     * access point. Also clear CR related flags.
     */
d4297 10
a4306 9
    chanPtr->flags &=
        (~(CHANNEL_EOF | CHANNEL_STICKY_EOF | CHANNEL_BLOCKED | INPUT_SAW_CR));
    
    /*
     * If the channel is in asynchronous output mode, switch it back
     * to synchronous mode and cancel any async flush that may be
     * scheduled. After the flush, the channel will be put back into
     * asynchronous output mode.
     */
d4308 3
a4310 16
    wasAsync = 0;
    if (chanPtr->flags & CHANNEL_NONBLOCKING) {
        wasAsync = 1;
        result = 0;
        if (chanPtr->typePtr->blockModeProc != NULL) {
            result = (chanPtr->typePtr->blockModeProc) (chanPtr->instanceData,
                    TCL_MODE_BLOCKING);
        }
        if (result != 0) {
            Tcl_SetErrno(result);
            return -1;
        }
        chanPtr->flags &= (~(CHANNEL_NONBLOCKING));
        if (chanPtr->flags & BG_FLUSH_SCHEDULED) {
            chanPtr->flags &= (~(BG_FLUSH_SCHEDULED));
        }
d4312 52
a4363 12
    
    /*
     * If the flush fails we cannot recover the original position. In
     * that case the seek is not attempted because we do not know where
     * the access position is - instead we return the error. FlushChannel
     * has already called Tcl_SetErrno() to report the error upwards.
     * If the flush succeeds we do the seek also.
     */
    
    if (FlushChannel(NULL, chanPtr, 0) != 0) {
        curPos = -1;
    } else {
d4365 1
a4365 4
        /*
         * Now seek to the new position in the channel as requested by the
         * caller.
         */
d4367 101
a4467 5
        curPos = (chanPtr->typePtr->seekProc) (chanPtr->instanceData,
                (long) offset, mode, &result);
        if (curPos == -1) {
            Tcl_SetErrno(result);
        }
d4469 13
a4481 19
    
    /*
     * Restore to nonblocking mode if that was the previous behavior.
     *
     * NOTE: Even if there was an async flush active we do not restore
     * it now because we already flushed all the queued output, above.
     */
    
    if (wasAsync) {
        chanPtr->flags |= CHANNEL_NONBLOCKING;
        result = 0;
        if (chanPtr->typePtr->blockModeProc != NULL) {
            result = (chanPtr->typePtr->blockModeProc) (chanPtr->instanceData,
                    TCL_MODE_NONBLOCKING);
        }
        if (result != 0) {
            Tcl_SetErrno(result);
            return -1;
        }
d4484 2
a4485 1
    return curPos;
d4491 1
a4491 1
 * Tcl_Tell --
d4493 2
a4494 2
 *	Returns the position of the next character to be read/written on
 *	this channel.
d4497 1
a4497 3
 *	A nonnegative integer on success, -1 on failure. If failed,
 *	use Tcl_GetErrno() to retrieve the POSIX error code for the
 *	error that occurred.
d4500 1
a4500 1
 *	None.
d4506 6
a4511 2
Tcl_Tell(chan)
    Tcl_Channel chan;			/* The channel to return pos for. */
d4513 4
a4516 5
    Channel *chanPtr;			/* The actual channel to tell on. */
    ChannelBuffer *bufPtr;
    int inputBuffered, outputBuffered;
    int result;				/* Of calling device driver. */
    int curPos;				/* Position on device. */
d4519 1
d4522 1
a4522 14
     * Check for unreported error.
     */

    if (chanPtr->unreportedError != 0) {
        Tcl_SetErrno(chanPtr->unreportedError);
        chanPtr->unreportedError = 0;
        return -1;
    }

    /*
     * Disallow tell on dead channels -- channels that have been closed but
     * not yet been deallocated. Such channels can be found if the exit
     * handler for channel cleanup has run but the channel is still
     * registered in an interpreter.
d4525 1
a4525 1
    if (CheckForDeadChannel(NULL,chanPtr)) return -1;
d4528 1
a4528 2
     * Disallow tell on channels that are open for neither
     * writing nor reading (e.g. socket server channels).
d4530 5
a4534 4

    if (!(chanPtr->flags & (TCL_WRITABLE|TCL_READABLE))) {
        Tcl_SetErrno(EACCES);
        return -1;
d4536 1
d4539 5
a4543 1
     * If the channel is in the middle of a background copy, fail.
d4546 2
a4547 3
    if (chanPtr->csPtr) {
	Tcl_SetErrno(EBUSY);
	return -1;
d4549 1
d4551 3
a4553 8
    /*
     * Disallow tell on channels whose type does not have a seek procedure
     * defined. This means that the channel does not support seeking.
     */

    if (chanPtr->typePtr->seekProc == (Tcl_DriverSeekProc *) NULL) {
        Tcl_SetErrno(EINVAL);
        return -1;
d4555 1
d4557 11
a4567 25
    /*
     * Compute how much input and output is buffered. If both input and
     * output is buffered, cannot compute the current position.
     */

    for (bufPtr = chanPtr->inQueueHead, inputBuffered = 0;
             bufPtr != (ChannelBuffer *) NULL;
             bufPtr = bufPtr->nextPtr) {
        inputBuffered += (bufPtr->nextAdded - bufPtr->nextRemoved);
    }
    for (bufPtr = chanPtr->outQueueHead, outputBuffered = 0;
             bufPtr != (ChannelBuffer *) NULL;
             bufPtr = bufPtr->nextPtr) {
        outputBuffered += (bufPtr->nextAdded - bufPtr->nextRemoved);
    }
    if ((chanPtr->curOutPtr != (ChannelBuffer *) NULL) &&
           (chanPtr->curOutPtr->nextAdded > chanPtr->curOutPtr->nextRemoved)) {
        chanPtr->flags |= BUFFER_READY;
        outputBuffered +=
            (chanPtr->curOutPtr->nextAdded - chanPtr->curOutPtr->nextRemoved);
    }

    if ((inputBuffered != 0) && (outputBuffered != 0)) {
        Tcl_SetErrno(EFAULT);
        return -1;
d4570 1
d4572 2
a4573 2
     * Get the current position in the device and compute the position
     * where the next character will be read or written.
d4576 2
a4577 10
    curPos = (chanPtr->typePtr->seekProc) (chanPtr->instanceData,
            (long) 0, SEEK_CUR, &result);
    if (curPos == -1) {
        Tcl_SetErrno(result);
        return -1;
    }
    if (inputBuffered != 0) {
        return (curPos - inputBuffered);
    }
    return (curPos + outputBuffered);
d4583 1
a4583 1
 * Tcl_Eof --
d4585 1
a4585 1
 *	Returns 1 if the channel is at EOF, 0 otherwise.
d4588 1
a4588 1
 *	1 or 0, always.
d4591 1
a4591 1
 *	None.
d4597 2
a4598 2
Tcl_Eof(chan)
    Tcl_Channel chan;			/* Does this channel have EOF? */
d4600 27
a4626 1
    Channel *chanPtr;		/* The real channel structure. */
d4628 1
a4628 4
    chanPtr = (Channel *) chan;
    return ((chanPtr->flags & CHANNEL_STICKY_EOF) ||
            ((chanPtr->flags & CHANNEL_EOF) && (Tcl_InputBuffered(chan) == 0)))
        ? 1 : 0;
d4634 1
a4634 1
 * Tcl_InputBlocked --
d4636 2
a4637 1
 *	Returns 1 if input is blocked on this channel, 0 otherwise.
d4640 1
a4640 1
 *	0 or 1, always.
d4643 2
a4644 1
 *	None.
d4649 6
a4654 3
int
Tcl_InputBlocked(chan)
    Tcl_Channel chan;			/* Is this channel blocked? */
d4656 9
a4664 1
    Channel *chanPtr;		/* The real channel structure. */
d4666 11
a4676 2
    chanPtr = (Channel *) chan;
    return (chanPtr->flags & CHANNEL_BLOCKED) ? 1 : 0;
d4680 1
a4680 1
 *----------------------------------------------------------------------
d4682 1
a4682 1
 * Tcl_InputBuffered --
d4684 1
a4684 2
 *	Returns the number of bytes of input currently buffered in the
 *	internal buffer of a channel.
d4687 2
a4688 2
 *	The number of input bytes buffered, or zero if the channel is not
 *	open for reading.
d4691 1
a4691 1
 *	None.
d4693 1
a4693 1
 *----------------------------------------------------------------------
d4696 3
a4698 3
int
Tcl_InputBuffered(chan)
    Tcl_Channel chan;			/* The channel to query. */
d4700 75
a4774 3
    Channel *chanPtr;
    int bytesBuffered;
    ChannelBuffer *bufPtr;
d4776 2
a4777 5
    chanPtr = (Channel *) chan;
    for (bytesBuffered = 0, bufPtr = chanPtr->inQueueHead;
             bufPtr != (ChannelBuffer *) NULL;
             bufPtr = bufPtr->nextPtr) {
        bytesBuffered += (bufPtr->nextAdded - bufPtr->nextRemoved);
d4779 29
a4807 1
    return bytesBuffered;
d4813 1
a4813 1
 * Tcl_SetChannelBufferSize --
d4815 2
a4816 2
 *	Sets the size of buffers to allocate to store input or output
 *	in the channel. The size must be between 10 bytes and 1 MByte.
d4819 2
a4820 1
 *	None.
d4823 1
a4823 1
 *	Sets the size of buffers subsequently allocated for this channel.
d4828 5
a4832 5
void
Tcl_SetChannelBufferSize(chan, sz)
    Tcl_Channel chan;			/* The channel whose buffer size
                                         * to set. */
    int sz;				/* The size to set. */
d4834 120
a4953 1
    Channel *chanPtr;
d4956 5
a4960 2
     * If the buffer size is smaller than 10 bytes or larger than one MByte,
     * do not accept the requested size and leave the current buffer size.
d4963 14
a4976 2
    if (sz < 10) {
        return;
d4978 14
a4991 2
    if (sz > (1024 * 1024)) {
        return;
d4994 1
a4994 2
    chanPtr = (Channel *) chan;
    chanPtr->bufSize = sz;
d5000 1
a5000 1
 * Tcl_GetChannelBufferSize --
d5002 2
a5003 1
 *	Retrieves the size of buffers to allocate for this channel.
d5006 3
a5008 1
 *	The size.
d5017 2
a5018 3
Tcl_GetChannelBufferSize(chan)
    Tcl_Channel chan;		/* The channel for which to find the
                                 * buffer size. */
d5020 27
a5046 1
    Channel *chanPtr;
d5048 168
a5215 2
    chanPtr = (Channel *) chan;
    return chanPtr->bufSize;
d5221 1
a5221 1
 * Tcl_BadChannelOption --
d5223 1
a5223 5
 *	This procedure generates a "bad option" error message in an
 *	(optional) interpreter.  It is used by channel drivers when 
 *      a invalid Set/Get option is requested. Its purpose is to concatenate
 *      the generic options list to the specific ones and factorize
 *      the generic options error message string.
d5226 1
a5226 1
 *	TCL_ERROR.
d5229 1
a5229 9
 *	An error message is generated in interp's result object to
 *	indicate that a command was invoked with the a bad option
 *	The message has the form
 *		bad option "blah": should be one of 
 *              <...generic options...>+<...specific options...>
 *	"blah" is the optionName argument and "<specific options>"
 *	is a space separated list of specific option words.
 *      The function takes good care of inserting minus signs before
 *      each option, commas after, and an "or" before the last option.
d5235 2
a5236 8
Tcl_BadChannelOption(interp, optionName, optionList)
    Tcl_Interp *interp;			/* Current interpreter. (can be NULL)*/
    char *optionName;			/* 'bad option' name */
    char *optionList;			/* Specific options list to append 
					 * to the standard generic options.
					 * can be NULL for generic options 
					 * only.
					 */
d5238 2
a5239 6
    if (interp) {
	CONST char *genericopt = 
	    	"blocking buffering buffersize eofchar translation";
	char **argv;
	int  argc, i;
	Tcl_DString ds;
d5241 1
a5241 23
	Tcl_DStringInit(&ds);
	Tcl_DStringAppend(&ds, (char *) genericopt, -1);
	if (optionList && (*optionList)) {
	    Tcl_DStringAppend(&ds, " ", 1);
	    Tcl_DStringAppend(&ds, optionList, -1);
	}
	if (Tcl_SplitList(interp, Tcl_DStringValue(&ds), 
	      	  &argc, &argv) != TCL_OK) {
	    panic("malformed option list in channel driver");
	}
	Tcl_ResetResult(interp);
	Tcl_AppendResult(interp, "bad option \"", optionName, 
		 "\": should be one of ", (char *) NULL);
	argc--;
	for (i = 0; i < argc; i++) {
	    Tcl_AppendResult(interp, "-", argv[i], ", ", (char *) NULL);
	}
	Tcl_AppendResult(interp, "or -", argv[i], (char *) NULL);
	Tcl_DStringFree(&ds);
	ckfree((char *) argv);
    }
    Tcl_SetErrno(EINVAL);
    return TCL_ERROR;
d5247 1
a5247 1
 * Tcl_GetChannelOption --
d5249 2
a5250 4
 *	Gets a mode associated with an IO channel. If the optionName arg
 *	is non NULL, retrieves the value of that option. If the optionName
 *	arg is NULL, retrieves a list of alternating option names and
 *	values for the given channel.
d5253 2
a5254 2
 *	A standard Tcl result. Also sets the supplied DString to the
 *	string value of the option(s) returned.
d5257 1
a5257 1
 *      None.
d5263 2
a5264 5
Tcl_GetChannelOption(interp, chan, optionName, dsPtr)
    Tcl_Interp *interp;		/* For error reporting - can be NULL. */
    Tcl_Channel chan;		/* Channel on which to get option. */
    char *optionName;		/* Option to get. */
    Tcl_DString *dsPtr;		/* Where to store value(s). */
d5266 10
a5275 4
    size_t len;			/* Length of optionName string. */
    char optionVal[128];	/* Buffer for sprintf. */
    Channel *chanPtr = (Channel *) chan;
    int flags;
d5278 1
a5278 1
     * If we are in the middle of a background copy, use the saved flags.
d5281 4
a5284 8
    if (chanPtr->csPtr) {
	if (chanPtr == chanPtr->csPtr->readPtr) {
	    flags = chanPtr->csPtr->readFlags;
	} else {
	    flags = chanPtr->csPtr->writeFlags;
	}
    } else {
	flags = chanPtr->flags;
d5287 20
a5306 6
    /*
     * Disallow options on dead channels -- channels that have been closed but
     * not yet been deallocated. Such channels can be found if the exit
     * handler for channel cleanup has run but the channel is still
     * registered in an interpreter.
     */
d5308 8
a5315 1
    if (CheckForDeadChannel(interp,chanPtr)) return TCL_ERROR;
d5317 229
a5545 9
    /*
     * If the optionName is NULL it means that we want a list of all
     * options and values.
     */
    
    if (optionName == (char *) NULL) {
        len = 0;
    } else {
        len = strlen(optionName);
d5580 1
a5580 1
        TclFormatInt(optionVal, chanPtr->bufSize);
d5587 17
a5603 1
            ((len > 1) && (optionName[1] == 'e') &&
d5613 1
a5613 1
            if (chanPtr->inEofChar == 0) {
d5618 1
a5618 1
                sprintf(buf, "%c", chanPtr->inEofChar);
d5623 1
a5623 1
            if (chanPtr->outEofChar == 0) {
d5628 1
a5628 1
                sprintf(buf, "%c", chanPtr->outEofChar);
d5651 1
a5651 1
            if (chanPtr->inputTranslation == TCL_TRANSLATE_AUTO) {
d5653 1
a5653 1
            } else if (chanPtr->inputTranslation == TCL_TRANSLATE_CR) {
d5655 1
a5655 1
            } else if (chanPtr->inputTranslation == TCL_TRANSLATE_CRLF) {
d5662 1
a5662 1
            if (chanPtr->outputTranslation == TCL_TRANSLATE_AUTO) {
d5664 1
a5664 1
            } else if (chanPtr->outputTranslation == TCL_TRANSLATE_CR) {
d5666 1
a5666 1
            } else if (chanPtr->outputTranslation == TCL_TRANSLATE_CRLF) {
d5687 1
a5687 1
		  interp, optionName, dsPtr);
d5701 1
a5701 1
 *----------------------------------------------------------------------
d5708 2
a5709 2
 *	A standard Tcl result. Also sets interp->result on error if
 *	interp is not NULL.
d5714 1
a5714 1
 *----------------------------------------------------------------------
d5725 2
a5726 1
    Channel *chanPtr;		/* The real IO channel. */
a5729 2
    
    chanPtr = (Channel *) chan;
d5735 1
a5735 1
    if (chanPtr->csPtr) {
d5738 2
a5739 2
	         "unable to set channel options: background copy in progress",
		 (char *) NULL);
a5743 1

d5751 10
a5760 2
    if (CheckForDeadChannel(NULL,chanPtr)) return TCL_ERROR;
    
d5774 1
a5774 3
    }

    if ((len > 7) && (optionName[1] == 'b') &&
d5778 1
a5778 1
            chanPtr->flags &=
d5782 2
a5783 2
            chanPtr->flags &= (~(CHANNEL_UNBUFFERED));
            chanPtr->flags |= CHANNEL_LINEBUFFERED;
d5786 2
a5787 2
            chanPtr->flags &= (~(CHANNEL_LINEBUFFERED));
            chanPtr->flags |= CHANNEL_UNBUFFERED;
d5796 10
a5805 2
        return TCL_OK;
    }
d5807 17
a5823 10
    if ((len > 7) && (optionName[1] == 'b') &&
            (strncmp(optionName, "-buffersize", len) == 0)) {
        chanPtr->bufSize = atoi(newValue);
        if ((chanPtr->bufSize < 10) || (chanPtr->bufSize > (1024 * 1024))) {
            chanPtr->bufSize = CHANNELBUFFER_DEFAULT_SIZE;
        }
        return TCL_OK;
    }
    
    if ((len > 1) && (optionName[1] == 'e') &&
d5829 2
a5830 2
            chanPtr->inEofChar = 0;
            chanPtr->outEofChar = 0;
d5832 2
a5833 2
            if (chanPtr->flags & TCL_WRITABLE) {
                chanPtr->outEofChar = (int) argv[0][0];
d5835 2
a5836 2
            if (chanPtr->flags & TCL_READABLE) {
                chanPtr->inEofChar = (int) argv[0][0];
d5847 2
a5848 2
            if (chanPtr->flags & TCL_READABLE) {
                chanPtr->inEofChar = (int) argv[0][0];
d5850 2
a5851 2
            if (chanPtr->flags & TCL_WRITABLE) {
                chanPtr->outEofChar = (int) argv[1][0];
d5857 2
a5858 4
        return TCL_OK;
    }

    if ((len > 1) && (optionName[1] == 't') &&
d5867 2
a5868 2
	    readMode = (chanPtr->flags & TCL_READABLE) ? argv[0] : NULL;
	    writeMode = (chanPtr->flags & TCL_WRITABLE) ? argv[0] : NULL;
d5870 2
a5871 2
	    readMode = (chanPtr->flags & TCL_READABLE) ? argv[0] : NULL;
	    writeMode = (chanPtr->flags & TCL_WRITABLE) ? argv[1] : NULL;
d5884 1
a5884 1
		newMode = chanPtr->inputTranslation;
a5887 1
		chanPtr->inEofChar = 0;
d5889 3
d5917 4
a5920 4
	    if (newMode != chanPtr->inputTranslation) {
		chanPtr->inputTranslation = (Tcl_EolTranslation) newMode;
		chanPtr->flags &= ~(INPUT_SAW_CR);
		chanPtr->flags &= ~(CHANNEL_GETS_BLOCKED);
d5936 1
a5936 1
		    chanPtr->outputTranslation = TCL_TRANSLATE_CRLF;
d5938 1
a5938 1
		    chanPtr->outputTranslation = TCL_PLATFORM_TRANSLATION;
d5941 4
a5944 2
		chanPtr->outEofChar = 0;
		chanPtr->outputTranslation = TCL_TRANSLATE_LF;
d5946 1
a5946 1
		chanPtr->outputTranslation = TCL_TRANSLATE_LF;
d5948 1
a5948 1
		chanPtr->outputTranslation = TCL_TRANSLATE_CR;
d5950 1
a5950 1
		chanPtr->outputTranslation = TCL_TRANSLATE_CRLF;
d5952 1
a5952 1
		chanPtr->outputTranslation = TCL_PLATFORM_TRANSLATION;
d5966 23
d5991 11
a6001 3
    if (chanPtr->typePtr->setOptionProc != (Tcl_DriverSetOptionProc *) NULL) {
        return (chanPtr->typePtr->setOptionProc) (chanPtr->instanceData,
                interp, optionName, newValue);
d6003 1
a6003 2
    
    return Tcl_BadChannelOption(interp, optionName, (char *) NULL);
d6031 1
d6039 1
a6039 1
    for (sPtr = chanPtr->scriptRecordPtr,
d6041 2
a6042 2
             sPtr != (EventScriptRecord *) NULL;
             sPtr = nextPtr) {
d6046 1
a6046 1
                chanPtr->scriptRecordPtr = nextPtr;
d6052 1
a6052 1
                    ChannelEventScriptInvoker, (ClientData) sPtr);
d6054 1
a6054 1
	    ckfree(sPtr->script);
d6089 1
d6091 1
d6093 3
d6098 9
a6106 1
     * Preserve the channel struct in case the script closes it.
d6108 43
a6150 2
     
    Tcl_Preserve((ClientData) channel);
d6159 3
a6161 3
    if ((chanPtr->flags & BG_FLUSH_SCHEDULED) && (mask & TCL_WRITABLE)) {
	FlushChannel(NULL, chanPtr, 1);
	mask &= ~TCL_WRITABLE;
d6170 4
a6173 4
    nh.nestedHandlerPtr = nestedHandlerPtr;
    nestedHandlerPtr = &nh;
    
    for (chPtr = chanPtr->chPtr; chPtr != (ChannelHandler *) NULL; ) {
d6175 4
a6178 4
        /*
         * If this channel handler is interested in any of the events that
         * have occurred on the channel, invoke its procedure.
         */
d6180 7
a6186 7
        if ((chPtr->mask & mask) != 0) {
            nh.nextHandlerPtr = chPtr->nextPtr;
	    (*(chPtr->proc))(chPtr->clientData, mask);
            chPtr = nh.nextHandlerPtr;
        } else {
            chPtr = chPtr->nextPtr;
	}
d6191 2
a6192 1
     * invoking event handlers.
d6196 1
a6196 1
	UpdateInterest(chanPtr);
d6201 74
a6274 1
    nestedHandlerPtr = nh.nestedHandlerPtr;
d6298 2
a6299 1
    int mask = chanPtr->interestMask;
d6306 1
a6306 1
    if (chanPtr->flags & BG_FLUSH_SCHEDULED) {
d6311 2
a6312 2
     * If there is data in the input queue, and we aren't blocked waiting for
     * an EOL, then we need to schedule a timer so we don't block in the
d6318 4
a6321 4
	if (!(chanPtr->flags & CHANNEL_GETS_BLOCKED)
		&& (chanPtr->inQueueHead != (ChannelBuffer *) NULL)
		&& (chanPtr->inQueueHead->nextRemoved <
			chanPtr->inQueueHead->nextAdded)) {
d6323 2
a6324 2
	    if (!chanPtr->timer) {
		chanPtr->timer = Tcl_CreateTimerHandler(0, ChannelTimerProc,
d6354 1
d6356 5
a6360 5
    if (!(chanPtr->flags & CHANNEL_GETS_BLOCKED)
	    && (chanPtr->interestMask & TCL_READABLE)
	    && (chanPtr->inQueueHead != (ChannelBuffer *) NULL)
	    && (chanPtr->inQueueHead->nextRemoved <
		    chanPtr->inQueueHead->nextAdded)) {
d6366 2
a6367 2
	chanPtr->timer = Tcl_CreateTimerHandler(0, ChannelTimerProc,
			(ClientData) chanPtr);
d6370 2
a6371 2
   } else {
	chanPtr->timer = NULL;
d6411 2
a6412 1
    Channel *chanPtr;
a6413 2
    chanPtr = (Channel *) chan;
    
d6420 3
a6422 3
    for (chPtr = chanPtr->chPtr;
             chPtr != (ChannelHandler *) NULL;
             chPtr = chPtr->nextPtr) {
d6434 2
a6435 2
        chPtr->nextPtr = chanPtr->chPtr;
        chanPtr->chPtr = chPtr;
d6451 2
a6452 2
    chanPtr->interestMask = 0;
    for (chPtr = chanPtr->chPtr;
d6455 1
a6455 1
	chanPtr->interestMask |= chPtr->mask;
d6458 1
a6458 1
    UpdateInterest(chanPtr);
d6489 1
d6491 2
a6492 1
    Channel *chanPtr;
a6494 2
    chanPtr = (Channel *) chan;

d6499 3
a6501 3
    for (prevChPtr = (ChannelHandler *) NULL, chPtr = chanPtr->chPtr;
             chPtr != (ChannelHandler *) NULL;
             chPtr = chPtr->nextPtr) {
d6508 1
a6508 1
    
d6522 3
a6524 3
    for (nhPtr = nestedHandlerPtr;
             nhPtr != (NextChannelHandler *) NULL;
             nhPtr = nhPtr->nestedHandlerPtr) {
d6535 1
a6535 1
        chanPtr->chPtr = chPtr->nextPtr;
d6543 2
a6544 1
     * will not result if Tcl_DeleteChanelHandler is called inside an event.
d6547 5
a6551 5
    chanPtr->interestMask = 0;
    for (chPtr = chanPtr->chPtr;
             chPtr != (ChannelHandler *) NULL;
             chPtr = chPtr->nextPtr) {
        chanPtr->interestMask |= chPtr->mask;
d6554 1
a6554 1
    UpdateInterest(chanPtr);
d6583 1
d6586 1
a6586 1
    for (esPtr = chanPtr->scriptRecordPtr,
d6588 2
a6589 2
             esPtr != (EventScriptRecord *) NULL;
             prevEsPtr = esPtr, esPtr = esPtr->nextPtr) {
d6591 2
a6592 2
            if (esPtr == chanPtr->scriptRecordPtr) {
                chanPtr->scriptRecordPtr = esPtr->nextPtr;
d6598 1
a6598 1
                    ChannelEventScriptInvoker, (ClientData) esPtr);
d6600 1
a6600 1
	    ckfree(esPtr->script);
d6626 1
a6626 1
CreateScriptRecord(interp, chanPtr, mask, script)
d6633 1
a6633 2
    char *script;			/* A copy of this script is stored
                                         * in the newly created record. */
d6635 1
d6638 3
a6640 3
    for (esPtr = chanPtr->scriptRecordPtr;
             esPtr != (EventScriptRecord *) NULL;
             esPtr = esPtr->nextPtr) {
d6642 2
a6643 2
	    ckfree(esPtr->script);
            esPtr->script = (char *) NULL;
d6651 3
a6653 3
                ChannelEventScriptInvoker, (ClientData) esPtr);
        esPtr->nextPtr = chanPtr->scriptRecordPtr;
        chanPtr->scriptRecordPtr = esPtr;
d6658 2
a6659 2
    esPtr->script = ckalloc((unsigned) (strlen(script) + 1));
    strcpy(esPtr->script, script);
d6665 1
a6665 1
 * ChannelEventScriptInvoker --
d6680 2
a6681 2
static void
ChannelEventScriptInvoker(clientData, mask)
a6687 1
    char *script;		/* Script to eval. */
d6692 4
a6695 6
    esPtr = (EventScriptRecord *) clientData;

    chanPtr = esPtr->chanPtr;
    mask = esPtr->mask;
    interp = esPtr->interp;
    script = esPtr->script;
d6704 1
a6704 1
    result = Tcl_GlobalEval(interp, script);
d6726 1
a6726 1
 * Tcl_FileEventCmd --
d6744 1
a6744 1
Tcl_FileEventCmd(clientData, interp, argc, argv)
d6749 2
a6750 2
    int argc;				/* Number of arguments. */
    char **argv;			/* Argument strings. */
d6754 1
d6756 5
a6760 7
    int c;				/* First char of mode argument. */
    int mask;				/* Mask for events of interest. */
    size_t length;			/* Length of mode argument. */

    /*
     * Parse arguments.
     */
d6762 2
a6763 3
    if ((argc != 3) && (argc != 4)) {
	Tcl_AppendResult(interp, "wrong # args: must be \"", argv[0],
		" channelId event ?script?", (char *) NULL);
d6766 2
a6767 9
    c = argv[2][0];
    length = strlen(argv[2]);
    if ((c == 'r') && (strncmp(argv[2], "readable", length) == 0)) {
        mask = TCL_READABLE;
    } else if ((c == 'w') && (strncmp(argv[2], "writable", length) == 0)) {
        mask = TCL_WRITABLE;
    } else {
	Tcl_AppendResult(interp, "bad event name \"", argv[2],
		"\": must be readable or writable", (char *) NULL);
d6770 4
a6773 1
    chan = Tcl_GetChannel(interp, argv[1], NULL);
d6775 1
a6775 1
        return TCL_ERROR;
d6777 3
a6779 3
    
    chanPtr = (Channel *) chan;
    if ((chanPtr->flags & mask) == 0) {
d6790 1
a6790 1
    if (argc == 3) {
d6792 1
a6792 1
	for (esPtr = chanPtr->scriptRecordPtr;
d6796 1
a6796 1
		Tcl_SetResult(interp, esPtr->script, TCL_STATIC);
d6807 1
a6807 1
    if (argv[3][0] == 0) {
d6818 1
a6818 1
    CreateScriptRecord(interp, chanPtr, mask, argv[3]);
d6826 1
a6826 1
 * TclTestChannelCmd --
d6828 5
a6832 4
 *	Implements the Tcl "testchannel" debugging command and its
 *	subcommands. This is part of the testing environment but must be
 *	in this file instead of tclTest.c because it needs access to the
 *	fields of struct Channel.
d6838 2
a6839 1
 *	None.
a6843 1
	/* ARGSUSED */
d6845 6
a6850 5
TclTestChannelCmd(clientData, interp, argc, argv)
    ClientData clientData;	/* Not used. */
    Tcl_Interp *interp;		/* Interpreter for result. */
    int argc;			/* Count of additional args. */
    char **argv;		/* Additional arg strings. */
d6852 19
a6870 15
    char *cmdName;		/* Sub command. */
    Tcl_HashTable *hTblPtr;	/* Hash table of channels. */
    Tcl_HashSearch hSearch;	/* Search variable. */
    Tcl_HashEntry *hPtr;	/* Search variable. */
    Channel *chanPtr;		/* The actual channel. */
    Tcl_Channel chan;		/* The opaque type. */
    size_t len;			/* Length of subcommand string. */
    int IOQueued;		/* How much IO is queued inside channel? */
    ChannelBuffer *bufPtr;	/* For iterating over queued IO. */
    char buf[128];		/* For sprintf. */
    
    if (argc < 2) {
        Tcl_AppendResult(interp, "wrong # args: should be \"", argv[0],
                " subcommand ?additional args..?\"", (char *) NULL);
        return TCL_ERROR;
a6871 2
    cmdName = argv[1];
    len = strlen(cmdName);
d6873 29
a6901 7
    chanPtr = (Channel *) NULL;
    if (argc > 2) {
        chan = Tcl_GetChannel(interp, argv[2], NULL);
        if (chan == (Tcl_Channel) NULL) {
            return TCL_ERROR;
        }
        chanPtr = (Channel *) chan;
a6902 99
    
    if ((cmdName[0] == 'i') && (strncmp(cmdName, "info", len) == 0)) {
        if (argc != 3) {
            Tcl_AppendResult(interp, "wrong # args: should be \"", argv[0],
                    " info channelName\"", (char *) NULL);
            return TCL_ERROR;
        }
        Tcl_AppendElement(interp, argv[2]);
        Tcl_AppendElement(interp, chanPtr->typePtr->typeName);
        if (chanPtr->flags & TCL_READABLE) {
            Tcl_AppendElement(interp, "read");
        } else {
            Tcl_AppendElement(interp, "");
        }
        if (chanPtr->flags & TCL_WRITABLE) {
            Tcl_AppendElement(interp, "write");
        } else {
            Tcl_AppendElement(interp, "");
        }
        if (chanPtr->flags & CHANNEL_NONBLOCKING) {
            Tcl_AppendElement(interp, "nonblocking");
        } else {
            Tcl_AppendElement(interp, "blocking");
        }
        if (chanPtr->flags & CHANNEL_LINEBUFFERED) {
            Tcl_AppendElement(interp, "line");
        } else if (chanPtr->flags & CHANNEL_UNBUFFERED) {
            Tcl_AppendElement(interp, "none");
        } else {
            Tcl_AppendElement(interp, "full");
        }
        if (chanPtr->flags & BG_FLUSH_SCHEDULED) {
            Tcl_AppendElement(interp, "async_flush");
        } else {
            Tcl_AppendElement(interp, "");
        }
        if (chanPtr->flags & CHANNEL_EOF) {
            Tcl_AppendElement(interp, "eof");
        } else {
            Tcl_AppendElement(interp, "");
        }
        if (chanPtr->flags & CHANNEL_BLOCKED) {
            Tcl_AppendElement(interp, "blocked");
        } else {
            Tcl_AppendElement(interp, "unblocked");
        }
        if (chanPtr->inputTranslation == TCL_TRANSLATE_AUTO) {
            Tcl_AppendElement(interp, "auto");
            if (chanPtr->flags & INPUT_SAW_CR) {
                Tcl_AppendElement(interp, "saw_cr");
            } else {
                Tcl_AppendElement(interp, "");
            }
        } else if (chanPtr->inputTranslation == TCL_TRANSLATE_LF) {
            Tcl_AppendElement(interp, "lf");
            Tcl_AppendElement(interp, "");
        } else if (chanPtr->inputTranslation == TCL_TRANSLATE_CR) {
            Tcl_AppendElement(interp, "cr");
            Tcl_AppendElement(interp, "");
        } else if (chanPtr->inputTranslation == TCL_TRANSLATE_CRLF) {
            Tcl_AppendElement(interp, "crlf");
            if (chanPtr->flags & INPUT_SAW_CR) {
                Tcl_AppendElement(interp, "queued_cr");
            } else {
                Tcl_AppendElement(interp, "");
            }
        }
        if (chanPtr->outputTranslation == TCL_TRANSLATE_AUTO) {
            Tcl_AppendElement(interp, "auto");
        } else if (chanPtr->outputTranslation == TCL_TRANSLATE_LF) {
            Tcl_AppendElement(interp, "lf");
        } else if (chanPtr->outputTranslation == TCL_TRANSLATE_CR) {
            Tcl_AppendElement(interp, "cr");
        } else if (chanPtr->outputTranslation == TCL_TRANSLATE_CRLF) {
            Tcl_AppendElement(interp, "crlf");
        }
        for (IOQueued = 0, bufPtr = chanPtr->inQueueHead;
                 bufPtr != (ChannelBuffer *) NULL;
                 bufPtr = bufPtr->nextPtr) {
            IOQueued += bufPtr->nextAdded - bufPtr->nextRemoved;
        }
        TclFormatInt(buf, IOQueued);
        Tcl_AppendElement(interp, buf);
        
        IOQueued = 0;
        if (chanPtr->curOutPtr != (ChannelBuffer *) NULL) {
            IOQueued = chanPtr->curOutPtr->nextAdded -
                chanPtr->curOutPtr->nextRemoved;
        }
        for (bufPtr = chanPtr->outQueueHead;
                 bufPtr != (ChannelBuffer *) NULL;
                 bufPtr = bufPtr->nextPtr) {
            IOQueued += (bufPtr->nextAdded - bufPtr->nextRemoved);
        }
        TclFormatInt(buf, IOQueued);
        Tcl_AppendElement(interp, buf);
        
        TclFormatInt(buf, Tcl_Tell((Tcl_Channel) chanPtr));
        Tcl_AppendElement(interp, buf);
d6904 3
a6906 2
        TclFormatInt(buf, chanPtr->refCount);
        Tcl_AppendElement(interp, buf);
d6908 2
a6909 2
        return TCL_OK;
    }
d6911 5
a6915 60
    if ((cmdName[0] == 'i') &&
            (strncmp(cmdName, "inputbuffered", len) == 0)) {
        if (argc != 3) {
            Tcl_AppendResult(interp, "channel name required",
                    (char *) NULL);
            return TCL_ERROR;
        }
        
        for (IOQueued = 0, bufPtr = chanPtr->inQueueHead;
                 bufPtr != (ChannelBuffer *) NULL;
                 bufPtr = bufPtr->nextPtr) {
            IOQueued += bufPtr->nextAdded - bufPtr->nextRemoved;
        }
        sprintf(buf, "%d", IOQueued);
        Tcl_AppendResult(interp, buf, (char *) NULL);
        return TCL_OK;
    }
        
    if ((cmdName[0] == 'm') && (strncmp(cmdName, "mode", len) == 0)) {
        if (argc != 3) {
            Tcl_AppendResult(interp, "channel name required",
                    (char *) NULL);
            return TCL_ERROR;
        }
        
        if (chanPtr->flags & TCL_READABLE) {
            Tcl_AppendElement(interp, "read");
        } else {
            Tcl_AppendElement(interp, "");
        }
        if (chanPtr->flags & TCL_WRITABLE) {
            Tcl_AppendElement(interp, "write");
        } else {
            Tcl_AppendElement(interp, "");
        }
        return TCL_OK;
    }
    
    if ((cmdName[0] == 'n') && (strncmp(cmdName, "name", len) == 0)) {
        if (argc != 3) {
            Tcl_AppendResult(interp, "channel name required",
                    (char *) NULL);
            return TCL_ERROR;
        }
        Tcl_AppendResult(interp, chanPtr->channelName, (char *) NULL);
        return TCL_OK;
    }
    
    if ((cmdName[0] == 'o') && (strncmp(cmdName, "open", len) == 0)) {
        hTblPtr = (Tcl_HashTable *) Tcl_GetAssocData(interp, "tclIO", NULL);
        if (hTblPtr == (Tcl_HashTable *) NULL) {
            return TCL_OK;
        }
        for (hPtr = Tcl_FirstHashEntry(hTblPtr, &hSearch);
                 hPtr != (Tcl_HashEntry *) NULL;
                 hPtr = Tcl_NextHashEntry(&hSearch)) {
            Tcl_AppendElement(interp, Tcl_GetHashKey(hTblPtr, hPtr));
        }
        return TCL_OK;
    }
d6917 11
a6927 51
    if ((cmdName[0] == 'o') &&
            (strncmp(cmdName, "outputbuffered", len) == 0)) {
        if (argc != 3) {
            Tcl_AppendResult(interp, "channel name required",
                    (char *) NULL);
            return TCL_ERROR;
        }
        
        IOQueued = 0;
        if (chanPtr->curOutPtr != (ChannelBuffer *) NULL) {
            IOQueued = chanPtr->curOutPtr->nextAdded -
                chanPtr->curOutPtr->nextRemoved;
        }
        for (bufPtr = chanPtr->outQueueHead;
                 bufPtr != (ChannelBuffer *) NULL;
                 bufPtr = bufPtr->nextPtr) {
            IOQueued += (bufPtr->nextAdded - bufPtr->nextRemoved);
        }
        sprintf(buf, "%d", IOQueued);
        Tcl_AppendResult(interp, buf, (char *) NULL);
        return TCL_OK;
    }
        
    if ((cmdName[0] == 'q') &&
            (strncmp(cmdName, "queuedcr", len) == 0)) {
        if (argc != 3) {
            Tcl_AppendResult(interp, "channel name required",
                    (char *) NULL);
            return TCL_ERROR;
        }
        
        Tcl_AppendResult(interp,
                (chanPtr->flags & INPUT_SAW_CR) ? "1" : "0",
                (char *) NULL);
        return TCL_OK;
    }
    
    if ((cmdName[0] == 'r') && (strncmp(cmdName, "readable", len) == 0)) {
        hTblPtr = (Tcl_HashTable *) Tcl_GetAssocData(interp, "tclIO", NULL);
        if (hTblPtr == (Tcl_HashTable *) NULL) {
            return TCL_OK;
        }
        for (hPtr = Tcl_FirstHashEntry(hTblPtr, &hSearch);
                 hPtr != (Tcl_HashEntry *) NULL;
                 hPtr = Tcl_NextHashEntry(&hSearch)) {
            chanPtr = (Channel *) Tcl_GetHashValue(hPtr);
            if (chanPtr->flags & TCL_READABLE) {
                Tcl_AppendElement(interp, Tcl_GetHashKey(hTblPtr, hPtr));
            }
        }
        return TCL_OK;
d6929 3
d6933 3
a6935 37
    if ((cmdName[0] == 'r') && (strncmp(cmdName, "refcount", len) == 0)) {
        if (argc != 3) {
            Tcl_AppendResult(interp, "channel name required",
                    (char *) NULL);
            return TCL_ERROR;
        }
        
        sprintf(buf, "%d", chanPtr->refCount);
        Tcl_AppendResult(interp, buf, (char *) NULL);
        return TCL_OK;
    }
    
    if ((cmdName[0] == 't') && (strncmp(cmdName, "type", len) == 0)) {
        if (argc != 3) {
            Tcl_AppendResult(interp, "channel name required",
                    (char *) NULL);
            return TCL_ERROR;
        }
        Tcl_AppendResult(interp, chanPtr->typePtr->typeName, (char *) NULL);
        return TCL_OK;
    }
    
    if ((cmdName[0] == 'w') && (strncmp(cmdName, "writable", len) == 0)) {
        hTblPtr = (Tcl_HashTable *) Tcl_GetAssocData(interp, "tclIO", NULL);
        if (hTblPtr == (Tcl_HashTable *) NULL) {
            return TCL_OK;
        }
        for (hPtr = Tcl_FirstHashEntry(hTblPtr, &hSearch);
                 hPtr != (Tcl_HashEntry *) NULL;
                 hPtr = Tcl_NextHashEntry(&hSearch)) {
            chanPtr = (Channel *) Tcl_GetHashValue(hPtr);
            if (chanPtr->flags & TCL_WRITABLE) {
                Tcl_AppendElement(interp, Tcl_GetHashKey(hTblPtr, hPtr));
            }
        }
        return TCL_OK;
    }
d6937 1
a6937 4
    Tcl_AppendResult(interp, "bad option \"", cmdName, "\": should be ",
            "info, open, readable, or writable",
            (char *) NULL);
    return TCL_ERROR;
d6943 1
a6943 1
 * TclTestChannelEventCmd --
d6945 2
a6946 4
 *	This procedure implements the "testchannelevent" command. It is
 *	used to test the Tcl channel event mechanism. It is present in
 *	this file instead of tclTest.c because it needs access to the
 *	internal structure of the channel.
d6949 1
a6949 1
 *	A standard Tcl result.
d6952 1
a6952 1
 *	Creates, deletes and returns channel event handlers.
d6957 4
a6960 7
	/* ARGSUSED */
int
TclTestChannelEventCmd(dummy, interp, argc, argv)
    ClientData dummy;			/* Not used. */
    Tcl_Interp *interp;			/* Current interpreter. */
    int argc;				/* Number of arguments. */
    char **argv;			/* Argument strings. */
d6962 46
a7007 28
    Channel *chanPtr;
    EventScriptRecord *esPtr, *prevEsPtr, *nextEsPtr;
    char *cmd;
    int index, i, mask, len;

    if ((argc < 3) || (argc > 5)) {
        Tcl_AppendResult(interp, "wrong # args: should be \"", argv[0],
                " channelName cmd ?arg1? ?arg2?\"", (char *) NULL);
        return TCL_ERROR;
    }
    chanPtr = (Channel *) Tcl_GetChannel(interp, argv[1], NULL);
    if (chanPtr == (Channel *) NULL) {
        return TCL_ERROR;
    }
    cmd = argv[2];
    len = strlen(cmd);
    if ((cmd[0] == 'a') && (strncmp(cmd, "add", (unsigned) len) == 0)) {
        if (argc != 5) {
            Tcl_AppendResult(interp, "wrong # args: should be \"", argv[0],
                    " channelName add eventSpec script\"", (char *) NULL);
            return TCL_ERROR;
        }
        if (strcmp(argv[3], "readable") == 0) {
            mask = TCL_READABLE;
        } else if (strcmp(argv[3], "writable") == 0) {
            mask = TCL_WRITABLE;
        } else if (strcmp(argv[3], "none") == 0) {
            mask = 0;
d7009 61
a7069 4
            Tcl_AppendResult(interp, "bad event name \"", argv[3],
                    "\": must be readable, writable, or none", (char *) NULL);
            return TCL_ERROR;
        }
d7071 3
a7073 10
        esPtr = (EventScriptRecord *) ckalloc((unsigned)
                sizeof(EventScriptRecord));
        esPtr->nextPtr = chanPtr->scriptRecordPtr;
        chanPtr->scriptRecordPtr = esPtr;
        
        esPtr->chanPtr = chanPtr;
        esPtr->interp = interp;
        esPtr->mask = mask;
        esPtr->script = ckalloc((unsigned) (strlen(argv[4]) + 1));
        strcpy(esPtr->script, argv[4]);
d7075 4
a7078 5
        Tcl_CreateChannelHandler((Tcl_Channel) chanPtr, mask,
                ChannelEventScriptInvoker, (ClientData) esPtr);
        
        return TCL_OK;
    }
d7080 4
a7083 42
    if ((cmd[0] == 'd') && (strncmp(cmd, "delete", (unsigned) len) == 0)) {
        if (argc != 4) {
            Tcl_AppendResult(interp, "wrong # args: should be \"", argv[0],
                    " channelName delete index\"", (char *) NULL);
            return TCL_ERROR;
        }
        if (Tcl_GetInt(interp, argv[3], &index) == TCL_ERROR) {
            return TCL_ERROR;
        }
        if (index < 0) {
            Tcl_AppendResult(interp, "bad event index: ", argv[3],
                    ": must be nonnegative", (char *) NULL);
            return TCL_ERROR;
        }
        for (i = 0, esPtr = chanPtr->scriptRecordPtr;
                 (i < index) && (esPtr != (EventScriptRecord *) NULL);
                 i++, esPtr = esPtr->nextPtr) {
	    /* Empty loop body. */
        }
        if (esPtr == (EventScriptRecord *) NULL) {
            Tcl_AppendResult(interp, "bad event index ", argv[3],
                    ": out of range", (char *) NULL);
            return TCL_ERROR;
        }
        if (esPtr == chanPtr->scriptRecordPtr) {
            chanPtr->scriptRecordPtr = esPtr->nextPtr;
        } else {
            for (prevEsPtr = chanPtr->scriptRecordPtr;
                     (prevEsPtr != (EventScriptRecord *) NULL) &&
                         (prevEsPtr->nextPtr != esPtr);
                     prevEsPtr = prevEsPtr->nextPtr) {
                /* Empty loop body. */
            }
            if (prevEsPtr == (EventScriptRecord *) NULL) {
                panic("TclTestChannelEventCmd: damaged event script list");
            }
            prevEsPtr->nextPtr = esPtr->nextPtr;
        }
        Tcl_DeleteChannelHandler((Tcl_Channel) chanPtr,
                ChannelEventScriptInvoker, (ClientData) esPtr);
	ckfree(esPtr->script);
        ckfree((char *) esPtr);
d7085 5
a7089 2
        return TCL_OK;
    }
d7091 3
a7093 15
    if ((cmd[0] == 'l') && (strncmp(cmd, "list", (unsigned) len) == 0)) {
        if (argc != 3) {
            Tcl_AppendResult(interp, "wrong # args: should be \"", argv[0],
                    " channelName list\"", (char *) NULL);
            return TCL_ERROR;
        }
        for (esPtr = chanPtr->scriptRecordPtr;
                 esPtr != (EventScriptRecord *) NULL;
                 esPtr = esPtr->nextPtr) {
	    char *event;
	    if (esPtr->mask) {
		event = ((esPtr->mask == TCL_READABLE)
			? "readable" : "writable");
	    } else {
		event = "none";
d7095 2
a7096 4
            Tcl_AppendElement(interp, event);
            Tcl_AppendElement(interp, esPtr->script);
        }
        return TCL_OK;
d7099 12
a7110 18
    if ((cmd[0] == 'r') && (strncmp(cmd, "removeall", (unsigned) len) == 0)) {
        if (argc != 3) {
            Tcl_AppendResult(interp, "wrong # args: should be \"", argv[0],
                    " channelName removeall\"", (char *) NULL);
            return TCL_ERROR;
        }
        for (esPtr = chanPtr->scriptRecordPtr;
                 esPtr != (EventScriptRecord *) NULL;
                 esPtr = nextEsPtr) {
            nextEsPtr = esPtr->nextPtr;
            Tcl_DeleteChannelHandler((Tcl_Channel) chanPtr,
                    ChannelEventScriptInvoker, (ClientData) esPtr);
	    ckfree(esPtr->script);
            ckfree((char *) esPtr);
        }
        chanPtr->scriptRecordPtr = (EventScriptRecord *) NULL;
        return TCL_OK;
    }
d7112 4
a7115 24
    if  ((cmd[0] == 's') && (strncmp(cmd, "set", (unsigned) len) == 0)) {
        if (argc != 5) {
            Tcl_AppendResult(interp, "wrong # args: should be \"", argv[0],
                    " channelName delete index event\"", (char *) NULL);
            return TCL_ERROR;
        }
        if (Tcl_GetInt(interp, argv[3], &index) == TCL_ERROR) {
            return TCL_ERROR;
        }
        if (index < 0) {
            Tcl_AppendResult(interp, "bad event index: ", argv[3],
                    ": must be nonnegative", (char *) NULL);
            return TCL_ERROR;
        }
        for (i = 0, esPtr = chanPtr->scriptRecordPtr;
                 (i < index) && (esPtr != (EventScriptRecord *) NULL);
                 i++, esPtr = esPtr->nextPtr) {
	    /* Empty loop body. */
        }
        if (esPtr == (EventScriptRecord *) NULL) {
            Tcl_AppendResult(interp, "bad event index ", argv[3],
                    ": out of range", (char *) NULL);
            return TCL_ERROR;
        }
d7117 15
a7131 6
        if (strcmp(argv[4], "readable") == 0) {
            mask = TCL_READABLE;
        } else if (strcmp(argv[4], "writable") == 0) {
            mask = TCL_WRITABLE;
        } else if (strcmp(argv[4], "none") == 0) {
            mask = 0;
d7133 5
a7137 13
            Tcl_AppendResult(interp, "bad event name \"", argv[4],
                    "\": must be readable, writable, or none", (char *) NULL);
            return TCL_ERROR;
        }
	esPtr->mask = mask;
        Tcl_CreateChannelHandler((Tcl_Channel) chanPtr, mask,
                ChannelEventScriptInvoker, (ClientData) esPtr);
	return TCL_OK;
    }    
    Tcl_AppendResult(interp, "bad command ", cmd, ", must be one of ",
            "add, delete, list, set, or removeall", (char *) NULL);
    return TCL_ERROR;

d7143 1
a7143 1
 * TclCopyChannel --
d7145 1
a7145 5
 *	This routine copies data from one channel to another, either
 *	synchronously or asynchronously.  If a command script is
 *	supplied, the operation runs in the background.  The script
 *	is invoked when the copy completes.  Otherwise the function
 *	waits until the copy is completed before returning.
d7148 2
a7149 1
 *	A standard Tcl result.
d7152 1
a7152 2
 *	May schedule a background copy operation that causes both
 *	channels to be marked busy.
d7157 18
a7174 13
int
TclCopyChannel(interp, inChan, outChan, toRead, cmdPtr)
    Tcl_Interp *interp;		/* Current interpreter. */
    Tcl_Channel inChan;		/* Channel to read from. */
    Tcl_Channel outChan;	/* Channel to write to. */
    int toRead;			/* Amount of data to copy, or -1 for all. */
    Tcl_Obj *cmdPtr;		/* Pointer to script to execute or NULL. */
{
    Channel *inPtr = (Channel *) inChan;
    Channel *outPtr = (Channel *) outChan;
    int readFlags, writeFlags;
    CopyState *csPtr;
    int nonBlocking = (cmdPtr) ? CHANNEL_NONBLOCKING : 0;
d7176 2
a7177 4
    if (inPtr->csPtr) {
	Tcl_AppendStringsToObj(Tcl_GetObjResult(interp), "channel \"",
		Tcl_GetChannelName(inChan), "\" is busy", NULL);
	return TCL_ERROR;
d7179 23
a7201 4
    if (outPtr->csPtr) {
	Tcl_AppendStringsToObj(Tcl_GetObjResult(interp), "channel \"",
		Tcl_GetChannelName(outChan), "\" is busy", NULL);
	return TCL_ERROR;
d7204 30
a7233 2
    readFlags = inPtr->flags;
    writeFlags = outPtr->flags;
d7235 15
d7251 4
a7254 3
     * Set up the blocking mode appropriately.  Background copies need
     * non-blocking channels.  Foreground copies need blocking channels.
     * If there is an error, restore the old blocking mode.
d7256 78
d7335 29
a7363 5
    if (nonBlocking != (readFlags & CHANNEL_NONBLOCKING)) {
	if (SetBlockMode(interp, inPtr,
		nonBlocking ? TCL_MODE_NONBLOCKING : TCL_MODE_BLOCKING)
		!= TCL_OK) {
	    return TCL_ERROR;
d7365 37
a7401 11
    }	    
    if (inPtr != outPtr) {
	if (nonBlocking != (writeFlags & CHANNEL_NONBLOCKING)) {
	    if (SetBlockMode(NULL, outPtr,
		    nonBlocking ? TCL_MODE_BLOCKING : TCL_MODE_NONBLOCKING)
		    != TCL_OK) {
		if (nonBlocking != (readFlags & CHANNEL_NONBLOCKING)) {
		    SetBlockMode(NULL, inPtr,
			    (readFlags & CHANNEL_NONBLOCKING)
			    ? TCL_MODE_NONBLOCKING : TCL_MODE_BLOCKING);
		    return TCL_ERROR;
d7404 5
d7413 97
a7509 1
     * Make sure the output side is unbuffered.
d7512 15
a7526 2
    outPtr->flags = (outPtr->flags & ~(CHANNEL_LINEBUFFERED))
	| CHANNEL_UNBUFFERED;
d7529 640
a8168 4
     * Allocate a new CopyState to maintain info about the current copy in
     * progress.  This structure will be deallocated when the copy is
     * completed.
     */
d8170 22
a8191 15
    csPtr = (CopyState*) ckalloc(sizeof(CopyState) + inPtr->bufSize);
    csPtr->bufSize = inPtr->bufSize;
    csPtr->readPtr = inPtr;
    csPtr->writePtr = outPtr;
    csPtr->readFlags = readFlags;
    csPtr->writeFlags = writeFlags;
    csPtr->toRead = toRead;
    csPtr->total = 0;
    csPtr->interp = interp;
    if (cmdPtr) {
	Tcl_IncrRefCount(cmdPtr);
    }
    csPtr->cmdPtr = cmdPtr;
    inPtr->csPtr = csPtr;
    outPtr->csPtr = csPtr;
d8193 22
a8214 3
    /*
     * Start copying data between the channels.
     */
d8216 5
a8220 1
    return CopyData(csPtr, 0);
d8226 1
a8226 1
 * CopyData --
d8228 1
a8228 2
 *	This function implements the lowest level of the copying
 *	mechanism for TclCopyChannel.
d8231 1
a8231 1
 *	Returns TCL_OK on success, else TCL_ERROR.
d8234 1
a8234 1
 *	Moves data between channels, may create channel handlers.
d8239 3
a8241 4
static int
CopyData(csPtr, mask)
    CopyState *csPtr;		/* State of copy operation. */
    int mask;			/* Current channel event flags. */
d8243 1
a8243 170
    Tcl_Interp *interp;
    Tcl_Obj *cmdPtr, *errObj = NULL;
    Tcl_Channel inChan, outChan;
    int result = TCL_OK;
    int size;
    int total;

    inChan = (Tcl_Channel)csPtr->readPtr;
    outChan = (Tcl_Channel)csPtr->writePtr;
    interp = csPtr->interp;
    cmdPtr = csPtr->cmdPtr;

    /*
     * Copy the data the slow way, using the translation mechanism.
     */

    while (csPtr->toRead != 0) {

	/*
	 * Check for unreported background errors.
	 */

	if (csPtr->readPtr->unreportedError != 0) {
	    Tcl_SetErrno(csPtr->readPtr->unreportedError);
	    csPtr->readPtr->unreportedError = 0;
	    goto readError;
	}
	if (csPtr->writePtr->unreportedError != 0) {
	    Tcl_SetErrno(csPtr->writePtr->unreportedError);
	    csPtr->writePtr->unreportedError = 0;
	    goto writeError;
	}
	
	/*
	 * Read up to bufSize bytes.
	 */

	if ((csPtr->toRead == -1)
		|| (csPtr->toRead > csPtr->bufSize)) {
	    size = csPtr->bufSize;
	} else {
	    size = csPtr->toRead;
	}
	size = DoRead(csPtr->readPtr, csPtr->buffer, size);

	if (size < 0) {
	    readError:
	    errObj = Tcl_NewObj();
	    Tcl_AppendStringsToObj(errObj, "error reading \"",
		    Tcl_GetChannelName(inChan), "\": ",
		    Tcl_PosixError(interp), (char *) NULL);
	    break;
	} else if (size == 0) {
	    /*
	     * We had an underflow on the read side.  If we are at EOF,
	     * then the copying is done, otherwise set up a channel
	     * handler to detect when the channel becomes readable again.
	     */
	    
	    if (Tcl_Eof(inChan)) {
		break;
	    } else if (!(mask & TCL_READABLE)) {
		if (mask & TCL_WRITABLE) {
		    Tcl_DeleteChannelHandler(outChan, CopyEventProc,
			    (ClientData) csPtr);
		}
		Tcl_CreateChannelHandler(inChan, TCL_READABLE,
			CopyEventProc, (ClientData) csPtr);
	    }
	    return TCL_OK;
	}

	/*
	 * Now write the buffer out.
	 */

	size = DoWrite(csPtr->writePtr, csPtr->buffer, size);
	if (size < 0) {
	    writeError:
	    errObj = Tcl_NewObj();
	    Tcl_AppendStringsToObj(errObj, "error writing \"",
		    Tcl_GetChannelName(outChan), "\": ",
		    Tcl_PosixError(interp), (char *) NULL);
	    break;
	}

	/*
	 * Check to see if the write is happening in the background.  If so,
	 * stop copying and wait for the channel to become writable again.
	 */

	if (csPtr->writePtr->flags & BG_FLUSH_SCHEDULED) {
	    if (!(mask & TCL_WRITABLE)) {
		if (mask & TCL_READABLE) {
		    Tcl_DeleteChannelHandler(outChan, CopyEventProc,
			    (ClientData) csPtr);
		}
		Tcl_CreateChannelHandler(outChan, TCL_WRITABLE,
			CopyEventProc, (ClientData) csPtr);
	    }
	    return TCL_OK;
	}

	/*
	 * Update the current byte count if we care.
	 */

	if (csPtr->toRead != -1) {
	    csPtr->toRead -= size;
	}
	csPtr->total += size;

	/*
	 * For background copies, we only do one buffer per invocation so
	 * we don't starve the rest of the system.
	 */

	if (cmdPtr) {
	    /*
	     * The first time we enter this code, there won't be a
	     * channel handler established yet, so do it here.
	     */

	    if (mask == 0) {
		Tcl_CreateChannelHandler(outChan, TCL_WRITABLE,
			CopyEventProc, (ClientData) csPtr);
	    }
	    return TCL_OK;
	}
    }

    /*
     * Make the callback or return the number of bytes transferred.
     * The local total is used because StopCopy frees csPtr.
     */

    total = csPtr->total;
    if (cmdPtr) {
	/*
	 * Get a private copy of the command so we can mutate it
	 * by adding arguments.  Note that StopCopy frees our saved
	 * reference to the original command obj.
	 */

	cmdPtr = Tcl_DuplicateObj(cmdPtr);
	Tcl_IncrRefCount(cmdPtr);
	StopCopy(csPtr);
	Tcl_Preserve((ClientData) interp);

	Tcl_ListObjAppendElement(interp, cmdPtr, Tcl_NewIntObj(total));
	if (errObj) {
	    Tcl_ListObjAppendElement(interp, cmdPtr, errObj);
	}
	if (Tcl_GlobalEvalObj(interp, cmdPtr) != TCL_OK) {
	    Tcl_BackgroundError(interp);
	    result = TCL_ERROR;
	}
	Tcl_DecrRefCount(cmdPtr);
	Tcl_Release((ClientData) interp);
    } else {
	StopCopy(csPtr);
	if (errObj) {
	    Tcl_SetObjResult(interp, errObj);
	    result = TCL_ERROR;
	} else {
	    Tcl_ResetResult(interp);
	    Tcl_SetIntObj(Tcl_GetObjResult(interp), total);
	}
    }
    return result;
d8249 1
a8249 1
 * CopyEventProc --
d8251 1
a8251 3
 *	This routine is invoked as a channel event handler for
 *	the background copy operation.  It is just a trivial wrapper
 *	around the CopyData routine.
d8254 1
a8254 1
 *	None.
d8262 3
a8264 4
static void
CopyEventProc(clientData, mask)
    ClientData clientData;
    int mask;
d8266 1
a8266 1
    (void) CopyData((CopyState *)clientData, mask);
d8272 1
a8272 1
 * StopCopy --
d8274 1
a8274 1
 *	This routine halts a copy that is in progress.
d8277 1
a8277 1
 *	None.
d8280 1
a8280 2
 *	Removes any pending channel handlers and restores the blocking
 *	and buffering modes of the channels.  The CopyState is freed.
d8285 3
a8287 3
static void
StopCopy(csPtr)
    CopyState *csPtr;		/* State for bg copy to stop . */
d8289 2
a8290 25
    int nonBlocking;

    if (!csPtr) {
	return;
    }

    /*
     * Restore the old blocking mode and output buffering mode.
     */

    nonBlocking = (csPtr->readFlags & CHANNEL_NONBLOCKING);
    if (nonBlocking != (csPtr->readPtr->flags & CHANNEL_NONBLOCKING)) {
	SetBlockMode(NULL, csPtr->readPtr,
		nonBlocking ? TCL_MODE_NONBLOCKING : TCL_MODE_BLOCKING);
    }
    if (csPtr->writePtr != csPtr->writePtr) {
	if (nonBlocking != (csPtr->writePtr->flags & CHANNEL_NONBLOCKING)) {
	    SetBlockMode(NULL, csPtr->writePtr,
		    nonBlocking ? TCL_MODE_NONBLOCKING : TCL_MODE_BLOCKING);
	}
    }
    csPtr->writePtr->flags &= ~(CHANNEL_LINEBUFFERED | CHANNEL_UNBUFFERED);
    csPtr->writePtr->flags |=
	csPtr->writeFlags & (CHANNEL_LINEBUFFERED | CHANNEL_UNBUFFERED);
	    
a8291 13
    if (csPtr->cmdPtr) {
	Tcl_DeleteChannelHandler((Tcl_Channel)csPtr->readPtr, CopyEventProc,
	    (ClientData)csPtr);
	if (csPtr->readPtr != csPtr->writePtr) {
	    Tcl_DeleteChannelHandler((Tcl_Channel)csPtr->writePtr,
		    CopyEventProc, (ClientData)csPtr);
	}
        Tcl_DecrRefCount(csPtr->cmdPtr);
    }
    csPtr->readPtr->csPtr = NULL;
    csPtr->writePtr->csPtr = NULL;
    ckfree((char*) csPtr);
}
@


1.1.1.1
log
@import dejagnu-1999-11-08 snapshot
@
text
@@


1.1.1.2
log
@Tcl 8.3 upgrade
@
text
@d7 1
a7 1
 * Copyright (c) 1998-2000 Ajuba Solutions
d13 1
a13 1
 * RCS: @@(#) $Id: tclIO.c,v 1.8.8.2 2000/09/15 16:55:16 spolk Exp $
d16 2
a17 4
#include "tclInt.h"
#include "tclPort.h"
#include "tclIO.h"
#include <assert.h>
a18 1

d20 5
a24 6
 * All static variables used in this file are collected into a single
 * instance of the following structure.  For multi-threaded implementations,
 * there is one instance of this structure for each thread.
 *
 * Notice that different structures with the same name appear in other
 * files.  The structure defined below is used in this file only.
d27 8
a34 24
typedef struct ThreadSpecificData {

    /*
     * This variable holds the list of nested ChannelHandlerEventProc 
     * invocations.
     */
    NextChannelHandler *nestedHandlerPtr;

    /*
     * List of all channels currently open, indexed by ChannelState,
     * as only one ChannelState exists per set of stacked channels.
     */
    ChannelState *firstCSPtr;
#ifdef oldcode
    /*
     * Has a channel exit handler been created yet?
     */
    int channelExitHandlerCreated;

    /*
     * Has the channel event source been created and registered with the
     * notifier?
     */
    int channelEventSourceCreated;
a35 9
    /*
     * Static variables to hold channels for stdin, stdout and stderr.
     */
    Tcl_Channel stdinChannel;
    int stdinInitialized;
    Tcl_Channel stdoutChannel;
    int stdoutInitialized;
    Tcl_Channel stderrChannel;
    int stderrInitialized;
d37 269
a305 3
} ThreadSpecificData;

static Tcl_ThreadDataKey dataKey;
d311 2
a312 1
static ChannelBuffer *	AllocChannelBuffer _ANSI_ARGS_((int length));
d314 1
a314 7
				ClientData clientData));
static int		CheckChannelErrors _ANSI_ARGS_((ChannelState *statePtr,
				int direction));
static int		CheckFlush _ANSI_ARGS_((Channel *chanPtr,
				ChannelBuffer *bufPtr, int newlineFlag));
static int		CheckForDeadChannel _ANSI_ARGS_((Tcl_Interp *interp,
				ChannelState *statePtr));
d316 1
a316 1
				Tcl_Channel chan));
d318 1
a318 1
				Tcl_Interp *interp, Channel *chanPtr));
d320 2
a321 3
				Channel *chanPtr, int errorCode));
static void		CommonGetsCleanup _ANSI_ARGS_((Channel *chanPtr,
				Tcl_Encoding encoding));
d323 1
a323 5
				ChannelState *statePtr, char *result,
				int space));
static int		CopyBuffer _ANSI_ARGS_((
				Channel *chanPtr, char *result,
				int space));
d326 1
a326 1
				int mask));
d328 2
a329 2
				Tcl_Interp *interp, Channel *chanPtr,
				int mask, Tcl_Obj *scriptPtr));
d331 1
a331 1
				ClientData clientData, Tcl_Interp *interp));
d333 3
a335 3
				Channel *chanPtr, int mask));
static void		DiscardInputQueued _ANSI_ARGS_((ChannelState *statePtr,
				int discardSavedBuffers));
d337 1
a337 1
				ChannelState *chanPtr));
d339 3
a341 5
				int slen));
static int		DoWrite _ANSI_ARGS_((Channel *chanPtr, char *src,
				int srcLen));
static int		FilterInputBytes _ANSI_ARGS_((Channel *chanPtr,
				GetsState *statePtr));
d343 3
a345 2
				Channel *chanPtr, int calledFromAsyncFlush));
static Tcl_HashTable *	GetChannelTable _ANSI_ARGS_((Tcl_Interp *interp));
d347 8
a354 12
static void		PeekAhead _ANSI_ARGS_((Channel *chanPtr,
				char **dstEndPtr, GetsState *gsPtr));
static int		ReadBytes _ANSI_ARGS_((ChannelState *statePtr,
				Tcl_Obj *objPtr, int charsLeft,
				int *offsetPtr));
static int		ReadChars _ANSI_ARGS_((ChannelState *statePtr,
				Tcl_Obj *objPtr, int charsLeft, int *offsetPtr,
				int *factorPtr));
static void		RecycleBuffer _ANSI_ARGS_((ChannelState *statePtr,
				ChannelBuffer *bufPtr, int mustDiscard));
static int		StackSetBlockMode _ANSI_ARGS_((Channel *chanPtr,
				int mode));
d356 1
a356 1
				Channel *chanPtr, int mode));
a357 6
static int		TranslateInputEOL _ANSI_ARGS_((ChannelState *statePtr,
				char *dst, CONST char *src, int *dstLenPtr,
				int *srcLenPtr));
static int		TranslateOutputEOL _ANSI_ARGS_((ChannelState *statePtr,
				char *dst, CONST char *src, int *dstLenPtr,
				int *srcLenPtr));
d359 2
a360 5
static int		WriteBytes _ANSI_ARGS_((Channel *chanPtr,
				CONST char *src, int srcLen));
static int		WriteChars _ANSI_ARGS_((Channel *chanPtr,
				CONST char *src, int srcLen));

d363 1
a363 1
 *---------------------------------------------------------------------------
d365 1
a365 1
 * TclInitIOSubsystem --
d367 2
a368 2
 *	Initialize all resources used by this subsystem on a per-process
 *	basis.  
d371 1
a371 1
 *	None.
d374 2
a375 1
 *	Depends on the memory subsystems.
d377 1
a377 1
 *---------------------------------------------------------------------------
d380 6
a385 2
void
TclInitIOSubsystem()
d387 17
a403 100
    /*
     * By fetching thread local storage we take care of
     * allocating it for each thread.
     */
    (void) TCL_TSD_INIT(&dataKey);
}   

/*
 *-------------------------------------------------------------------------
 *
 * TclFinalizeIOSubsystem --
 *
 *	Releases all resources used by this subsystem on a per-process 
 *	basis.  Closes all extant channels that have not already been 
 *	closed because they were not owned by any interp.  
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Depends on encoding and memory subsystems.
 *
 *-------------------------------------------------------------------------
 */

	/* ARGSUSED */
void
TclFinalizeIOSubsystem()
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    Channel *chanPtr;			/* Iterates over open channels. */
    ChannelState *nextCSPtr;		/* Iterates over open channels. */
    ChannelState *statePtr;		/* state of channel stack */

    for (statePtr = tsdPtr->firstCSPtr; statePtr != (ChannelState *) NULL;
	 statePtr = nextCSPtr) {
	chanPtr		= statePtr->topChanPtr;
        nextCSPtr	= statePtr->nextCSPtr;

        /*
         * Set the channel back into blocking mode to ensure that we wait
         * for all data to flush out.
         */
        
        (void) Tcl_SetChannelOption(NULL, (Tcl_Channel) chanPtr,
                "-blocking", "on");

        if ((chanPtr == (Channel *) tsdPtr->stdinChannel) ||
                (chanPtr == (Channel *) tsdPtr->stdoutChannel) ||
                (chanPtr == (Channel *) tsdPtr->stderrChannel)) {

            /*
             * Decrement the refcount which was earlier artificially bumped
             * up to keep the channel from being closed.
             */

            statePtr->refCount--;
        }

        if (statePtr->refCount <= 0) {

	    /*
             * Close it only if the refcount indicates that the channel is not
             * referenced from any interpreter. If it is, that interpreter will
             * close the channel when it gets destroyed.
             */

            (void) Tcl_Close((Tcl_Interp *) NULL, (Tcl_Channel) chanPtr);

        } else {

            /*
             * The refcount is greater than zero, so flush the channel.
             */

            Tcl_Flush((Tcl_Channel) chanPtr);

            /*
             * Call the device driver to actually close the underlying
             * device for this channel.
             */
            
	    if (chanPtr->typePtr->closeProc != TCL_CLOSE2PROC) {
		(chanPtr->typePtr->closeProc)(chanPtr->instanceData,
			(Tcl_Interp *) NULL);
	    } else {
		(chanPtr->typePtr->close2Proc)(chanPtr->instanceData,
			(Tcl_Interp *) NULL, 0);
	    }

            /*
             * Finally, we clean up the fields in the channel data structure
             * since all of them have been deleted already. We mark the
             * channel with CHANNEL_DEAD to prevent any further IO operations
             * on it.
             */

            chanPtr->instanceData = (ClientData) NULL;
            statePtr->flags |= CHANNEL_DEAD;
        }
d405 1
a406 1

a429 1
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
d432 2
a433 2
	    tsdPtr->stdinInitialized = 1;
	    tsdPtr->stdinChannel = channel;
d436 2
a437 2
	    tsdPtr->stdoutInitialized = 1;
	    tsdPtr->stdoutChannel = channel;
d440 2
a441 2
	    tsdPtr->stderrInitialized = 1;
	    tsdPtr->stderrChannel = channel;
d462 1
a467 1
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
d471 4
a474 1
     * store them in the static variables. 
d479 3
a481 3
	    if (!tsdPtr->stdinInitialized) {
		tsdPtr->stdinChannel = TclpGetDefaultStdChannel(TCL_STDIN);
		tsdPtr->stdinInitialized = 1;
d483 1
a483 1
		/*
d492 1
a492 1
                if (tsdPtr->stdinChannel != (Tcl_Channel) NULL) {
d494 1
a494 1
                            tsdPtr->stdinChannel);
d497 1
a497 1
	    channel = tsdPtr->stdinChannel;
d500 14
a513 4
	    if (!tsdPtr->stdoutInitialized) {
		tsdPtr->stdoutChannel = TclpGetDefaultStdChannel(TCL_STDOUT);
		tsdPtr->stdoutInitialized = 1;
                if (tsdPtr->stdoutChannel != (Tcl_Channel) NULL) {
d515 1
a515 1
                            tsdPtr->stdoutChannel);
d518 1
a518 1
	    channel = tsdPtr->stdoutChannel;
d521 14
a534 4
	    if (!tsdPtr->stderrInitialized) {
		tsdPtr->stderrChannel = TclpGetDefaultStdChannel(TCL_STDERR);
		tsdPtr->stderrInitialized = 1;
                if (tsdPtr->stderrChannel != (Tcl_Channel) NULL) {
d536 1
a536 1
                            tsdPtr->stderrChannel);
d539 1
a539 1
	    channel = tsdPtr->stderrChannel;
a543 1

d572 1
a572 1
    ChannelState *statePtr;
d575 1
a575 1
    statePtr = ((Channel *) chan)->state;
d581 2
a582 2
    cbPtr->nextPtr = statePtr->closeCbPtr;
    statePtr->closeCbPtr = cbPtr;
d613 1
a613 1
    ChannelState *statePtr;
d616 4
a619 4
    statePtr = ((Channel *) chan)->state;
    for (cbPtr = statePtr->closeCbPtr, cbPrevPtr = (CloseCallback *) NULL;
	 cbPtr != (CloseCallback *) NULL;
	 cbPtr = cbPtr->nextPtr) {
d622 1
a622 1
                statePtr->closeCbPtr = cbPtr->nextPtr;
d635 103
d825 1
a825 2
    Channel *chanPtr;		/* Channel being deleted. */
    ChannelState *statePtr;	/* State of Channel being deleted. */
d830 1
a830 1

d838 2
a839 2
	 hPtr != (Tcl_HashEntry *) NULL;
	 hPtr = Tcl_FirstHashEntry(hTblPtr, &hSearch)) {
a841 1
	statePtr = chanPtr->state;
d847 1
a847 1
        for (sPtr = statePtr->scriptRecordPtr,
d849 2
a850 2
	     sPtr != (EventScriptRecord *) NULL;
	     sPtr = nextPtr) {
d854 1
a854 1
                    statePtr->scriptRecordPtr = nextPtr;
d860 1
a860 1
                        TclChannelEventScriptInvoker, (ClientData) sPtr);
d862 1
a862 1
		Tcl_DecrRefCount(sPtr->scriptPtr);
d877 3
a879 3
        statePtr->refCount--;
        if (statePtr->refCount <= 0) {
            if (!(statePtr->flags & BG_FLUSH_SCHEDULED)) {
d914 6
a919 7
    ChannelState *statePtr = ((Channel *) chan)->state;
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    if ((chan == tsdPtr->stdinChannel) && (tsdPtr->stdinInitialized)) {
        if (statePtr->refCount < 2) {
            statePtr->refCount = 0;
            tsdPtr->stdinChannel = NULL;
d922 4
a925 5
    } else if ((chan == tsdPtr->stdoutChannel)
	    && (tsdPtr->stdoutInitialized)) {
        if (statePtr->refCount < 2) {
            statePtr->refCount = 0;
            tsdPtr->stdoutChannel = NULL;
d928 4
a931 5
    } else if ((chan == tsdPtr->stderrChannel)
	    && (tsdPtr->stderrInitialized)) {
        if (statePtr->refCount < 2) {
            statePtr->refCount = 0;
            tsdPtr->stderrChannel = NULL;
d940 1
a940 1
 * Tcl_RegisterChannel --
d942 3
a944 3
 *	Adds an already-open channel to the channel table of an interpreter.
 *	If the interpreter passed as argument is NULL, it only increments
 *	the channel refCount.
d947 1
a947 1
 *	None.
d950 1
a950 1
 *	May increment the reference count of a channel.
d955 4
a958 5
void
Tcl_RegisterChannel(interp, chan)
    Tcl_Interp *interp;		/* Interpreter in which to add the channel. */
    Tcl_Channel chan;		/* The channel to add to this interpreter
                                 * channel table. */
d962 1
a962 3
    int new;			/* Is the hash entry new or does it exist? */
    Channel *chanPtr;		/* The actual channel. */
    ChannelState *statePtr;	/* State of the actual channel. */
d964 2
a965 11
    /*
     * Always (un)register bottom-most channel in the stack.  This makes
     * management of the channel list easier because no manipulation is
     * necessary during (un)stack operation.
     */
    chanPtr = ((Channel *) chan)->state->bottomChanPtr;
    statePtr = chanPtr->state;

    if (statePtr->channelName == (char *) NULL) {
        panic("Tcl_RegisterChannel: channel without name");
    }
d967 1
a967 52
        hTblPtr = GetChannelTable(interp);
        hPtr = Tcl_CreateHashEntry(hTblPtr, statePtr->channelName, &new);
        if (new == 0) {
            if (chan == (Tcl_Channel) Tcl_GetHashValue(hPtr)) {
                return;
            }

	    panic("Tcl_RegisterChannel: duplicate channel names");
        }
        Tcl_SetHashValue(hPtr, (ClientData) chanPtr);
    }
    statePtr->refCount++;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_UnregisterChannel --
 *
 *	Deletes the hash entry for a channel associated with an interpreter.
 *	If the interpreter given as argument is NULL, it only decrements the
 *	reference count.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	Deletes the hash entry for a channel associated with an interpreter.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_UnregisterChannel(interp, chan)
    Tcl_Interp *interp;		/* Interpreter in which channel is defined. */
    Tcl_Channel chan;		/* Channel to delete. */
{
    Tcl_HashTable *hTblPtr;	/* Hash table of channels. */
    Tcl_HashEntry *hPtr;	/* Search variable. */
    Channel *chanPtr;		/* The real IO channel. */
    ChannelState *statePtr;	/* State of the real channel. */

    /*
     * Always (un)register bottom-most channel in the stack.  This makes
     * management of the channel list easier because no manipulation is
     * necessary during (un)stack operation.
     */
    chanPtr = ((Channel *) chan)->state->bottomChanPtr;
    statePtr = chanPtr->state;

    if (interp != (Tcl_Interp *) NULL) {
        hTblPtr = (Tcl_HashTable *) Tcl_GetAssocData(interp, "tclIO", NULL);
d971 1
a971 1
        hPtr = Tcl_FindHashEntry(hTblPtr, statePtr->channelName);
d991 1
a991 1
    statePtr->refCount--;
d1007 1
a1007 1
    if (statePtr->refCount <= 0) {
d1014 4
a1017 4
        if ((statePtr->curOutPtr != NULL) &&
                (statePtr->curOutPtr->nextAdded >
                        statePtr->curOutPtr->nextRemoved)) {
            statePtr->flags |= BUFFER_READY;
d1019 2
a1020 2
        statePtr->flags |= CHANNEL_CLOSED;
        if (!(statePtr->flags & BG_FLUSH_SCHEDULED)) {
d1030 49
a1078 1
 *---------------------------------------------------------------------------
d1087 3
a1089 3
 *	A Tcl_Channel or NULL on failure. If failed, interp's result
 *	object contains an error message.  *modePtr is filled with the
 *	modes in which the channel was opened.
d1094 1
a1094 1
 *---------------------------------------------------------------------------
d1124 1
a1124 1
	    chanPtr = (Channel *) Tcl_GetStdChannel(TCL_STDIN);
d1126 1
a1126 1
	    chanPtr = (Channel *) Tcl_GetStdChannel(TCL_STDOUT);
d1128 1
a1128 1
	    chanPtr = (Channel *) Tcl_GetStdChannel(TCL_STDERR);
d1131 1
a1131 1
	    name = chanPtr->state->channelName;
d1134 1
a1134 1

a1142 6
    /*
     * Always return bottom-most channel in the stack.  This one lives
     * the longest - other channels may go away unnoticed.
     * The other APIs compensate where necessary to retrieve the
     * topmost channel again.
     */
a1143 1
    chanPtr = chanPtr->state->bottomChanPtr;
d1145 1
a1145 1
        *modePtr = (chanPtr->state->flags & (TCL_READABLE|TCL_WRITABLE));
a1177 28
    ChannelState *statePtr;	/* The stack-level independent state info
				 * for the channel. */
    CONST char *name;
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    /*
     * With the change of the Tcl_ChannelType structure to use a version in
     * 8.3.2+, we have to make sure that our assumption that the structure
     * remains a binary compatible size is true.
     *
     * If this assertion fails on some system, then it can be removed
     * only if the user recompiles code with older channel drivers in
     * the new system as well.
     */

    assert(sizeof(Tcl_ChannelTypeVersion) == sizeof(Tcl_DriverBlockModeProc*));

    chanPtr  = (Channel *) ckalloc((unsigned) sizeof(Channel));
    statePtr = (ChannelState *) ckalloc((unsigned) sizeof(ChannelState));
    chanPtr->state = statePtr;

    chanPtr->instanceData	= instanceData;
    chanPtr->typePtr		= typePtr;

    /*
     * Set all the bits that are part of the stack-independent state
     * information for the channel.
     */
d1179 2
d1182 2
a1183 2
        statePtr->channelName = ckalloc((unsigned) (strlen(chanName) + 1));
        strcpy(statePtr->channelName, chanName);
d1188 1
a1188 15
    statePtr->flags		= mask;

    /*
     * Set the channel to system default encoding.
     */

    statePtr->encoding = NULL;
    name = Tcl_GetEncodingName(NULL);
    if (strcmp(name, "binary") != 0) {
    	statePtr->encoding = Tcl_GetEncoding(NULL, name);
    }
    statePtr->inputEncodingState	= NULL;
    statePtr->inputEncodingFlags	= TCL_ENCODING_START;
    statePtr->outputEncodingState	= NULL;
    statePtr->outputEncodingFlags	= TCL_ENCODING_START;
d1198 22
a1219 36
    statePtr->inputTranslation	= TCL_TRANSLATE_AUTO;
    statePtr->outputTranslation	= TCL_PLATFORM_TRANSLATION;
    statePtr->inEofChar		= 0;
    statePtr->outEofChar	= 0;

    statePtr->unreportedError	= 0;
    statePtr->refCount		= 0;
    statePtr->closeCbPtr	= (CloseCallback *) NULL;
    statePtr->curOutPtr		= (ChannelBuffer *) NULL;
    statePtr->outQueueHead	= (ChannelBuffer *) NULL;
    statePtr->outQueueTail	= (ChannelBuffer *) NULL;
    statePtr->saveInBufPtr	= (ChannelBuffer *) NULL;
    statePtr->inQueueHead	= (ChannelBuffer *) NULL;
    statePtr->inQueueTail	= (ChannelBuffer *) NULL;
    statePtr->chPtr		= (ChannelHandler *) NULL;
    statePtr->interestMask	= 0;
    statePtr->scriptRecordPtr	= (EventScriptRecord *) NULL;
    statePtr->bufSize		= CHANNELBUFFER_DEFAULT_SIZE;
    statePtr->timer		= NULL;
    statePtr->csPtr		= NULL;

    statePtr->outputStage	= NULL;
    if ((statePtr->encoding != NULL) && (statePtr->flags & TCL_WRITABLE)) {
	statePtr->outputStage = (char *)
	    ckalloc((unsigned) (statePtr->bufSize + 2));
    }

    /*
     * As we are creating the channel, it is obviously the top for now
     */
    statePtr->topChanPtr	= chanPtr;
    statePtr->bottomChanPtr	= chanPtr;
    chanPtr->downChanPtr	= (Channel *) NULL;
    chanPtr->upChanPtr		= (Channel *) NULL;
    chanPtr->inQueueHead        = (ChannelBuffer*) NULL;
    chanPtr->inQueueTail        = (ChannelBuffer*) NULL;
d1227 2
a1228 2
    statePtr->nextCSPtr  = tsdPtr->firstCSPtr;
    tsdPtr->firstCSPtr   = statePtr;
d1230 5
d1240 2
a1241 3
    if ((tsdPtr->stdinChannel == NULL) &&
	    (tsdPtr->stdinInitialized == 1)) {
	Tcl_SetStdChannel((Tcl_Channel) chanPtr, TCL_STDIN);
d1243 2
a1244 3
    } else if ((tsdPtr->stdoutChannel == NULL) &&
	    (tsdPtr->stdoutInitialized == 1)) {
	Tcl_SetStdChannel((Tcl_Channel) chanPtr, TCL_STDOUT);
d1246 2
a1247 3
    } else if ((tsdPtr->stderrChannel == NULL) &&
	    (tsdPtr->stderrInitialized == 1)) {
	Tcl_SetStdChannel((Tcl_Channel) chanPtr, TCL_STDERR);
d1256 1
a1256 1
 * Tcl_StackChannel --
d1258 2
a1259 9
 *	Replaces an entry in the hash table for a Tcl_Channel
 *	record. The replacement is a new channel with same name,
 *	it supercedes the replaced channel. Input and output of
 *	the superceded channel is now going through the newly
 *	created channel and allows the arbitrary filtering/manipulation
 *	of the dataflow.
 *
 *	Andreas Kupries <a.kupries@@westend.com>, 12/13/1998
 *	"Trf-Patch for filtering channels"
d1262 1
a1262 2
 *	Returns the new Tcl_Channel, which actually contains the
 *      saved information about prevChan.
d1265 1
a1265 5
 *    A new channel structure is allocated and linked below
 *    the existing channel.  The channel operations and client
 *    data of the existing channel are copied down to the newly
 *    created channel, and the current channel has its operations
 *    replaced by the new typePtr.
d1270 6
a1275 14
Tcl_Channel
Tcl_StackChannel(interp, typePtr, instanceData, mask, prevChan)
    Tcl_Interp	    *interp;	   /* The interpreter we are working in */
    Tcl_ChannelType *typePtr;	   /* The channel type record for the new
				    * channel. */
    ClientData	     instanceData; /* Instance specific data for the new
				    * channel. */
    int		     mask;	   /* TCL_READABLE & TCL_WRITABLE to indicate
				    * if the channel is readable, writable. */
    Tcl_Channel	     prevChan;	   /* The channel structure to replace */
{
    ThreadSpecificData	*tsdPtr = TCL_TSD_INIT(&dataKey);
    Channel		*chanPtr, *prevChanPtr;
    ChannelState	*statePtr;
d1277 2
a1278 122
    /*
     * Find the given channel in the list of all channels.
     * If we don't find it, then it was never registered correctly.
     *
     * This operation should occur at the top of a channel stack.
     */

    statePtr    = (ChannelState *) tsdPtr->firstCSPtr;
    prevChanPtr = ((Channel *) prevChan)->state->topChanPtr;

    while (statePtr->topChanPtr != prevChanPtr) {
	statePtr = statePtr->nextCSPtr;
    }

    if (statePtr == NULL) {
	Tcl_AppendResult(interp, "couldn't find state for channel \"",
		Tcl_GetChannelName(prevChan), "\"", (char *) NULL);
        return (Tcl_Channel) NULL;
    }

    /*
     * Here we check if the given "mask" matches the "flags"
     * of the already existing channel.
     *
     *	  | - | R | W | RW |
     *	--+---+---+---+----+	<=>  0 != (chan->mask & prevChan->mask)
     *	- |   |   |   |    |
     *	R |   | + |   | +  |	The superceding channel is allowed to
     *	W |   |   | + | +  |	restrict the capabilities of the
     *	RW|   | + | + | +  |	superceded one !
     *	--+---+---+---+----+
     */

    if ((mask & (statePtr->flags & (TCL_READABLE | TCL_WRITABLE))) == 0) {
	Tcl_AppendResult(interp,
		"reading and writing both disallowed for channel \"",
		Tcl_GetChannelName(prevChan), "\"", (char *) NULL);
        return (Tcl_Channel) NULL;
    }

    /*
     * Flush the buffers. This ensures that any data still in them
     * at this time is not handled by the new transformation. Restrict
     * this to writable channels. Take care to hide a possible bg-copy
     * in progress from Tcl_Flush and the CheckForChannelErrors inside.
     */

    if ((mask & TCL_WRITABLE) != 0) {
        CopyState *csPtr;

        csPtr           = statePtr->csPtr;
	statePtr->csPtr = (CopyState*) NULL;

	if (Tcl_Flush((Tcl_Channel) prevChanPtr) != TCL_OK) {
	    statePtr->csPtr = csPtr;
	    Tcl_AppendResult(interp, "could not flush channel \"",
		    Tcl_GetChannelName(prevChan), "\"", (char *) NULL);
	    return (Tcl_Channel) NULL;
	}

	statePtr->csPtr = csPtr;
    }
    /*
     * Discard any input in the buffers. They are not yet read by the
     * user of the channel, so they have to go through the new
     * transformation before reading. As the buffers contain the
     * untransformed form their contents are not only useless but actually
     * distorts our view of the system.
     *
     * To preserve the information without having to read them again and
     * to avoid problems with the location in the channel (seeking might
     * be impossible) we move the buffers from the common state structure
     * into the channel itself. We use the buffers in the channel below
     * the new transformation to hold the data. In the future this allows
     * us to write transformations which pre-read data and push the unused
     * part back when they are going away.
     */

    if (((mask & TCL_READABLE) != 0) &&
	(statePtr->inQueueHead != (ChannelBuffer*) NULL)) {
      /*
       * Remark: It is possible that the channel buffers contain data from
       * some earlier push-backs.
       */

      statePtr->inQueueTail->nextPtr = prevChanPtr->inQueueHead;
      prevChanPtr->inQueueHead       = statePtr->inQueueHead;

      if (prevChanPtr->inQueueTail == (ChannelBuffer*) NULL) {
	prevChanPtr->inQueueTail = statePtr->inQueueTail;
      }

      statePtr->inQueueHead          = (ChannelBuffer*) NULL;
      statePtr->inQueueTail          = (ChannelBuffer*) NULL;
    }

    chanPtr = (Channel *) ckalloc((unsigned) sizeof(Channel));

    /*
     * Save some of the current state into the new structure,
     * reinitialize the parts which will stay with the transformation.
     *
     * Remarks:
     */

    chanPtr->state		= statePtr;
    chanPtr->instanceData	= instanceData;
    chanPtr->typePtr		= typePtr;
    chanPtr->downChanPtr	= prevChanPtr;
    chanPtr->upChanPtr		= (Channel *) NULL;
    chanPtr->inQueueHead        = (ChannelBuffer*) NULL;
    chanPtr->inQueueTail        = (ChannelBuffer*) NULL;

    /*
     * Place new block at the head of a possibly existing list of previously
     * stacked channels.
     */

    prevChanPtr->upChanPtr	= chanPtr;
    statePtr->topChanPtr	= chanPtr;

    return (Tcl_Channel) chanPtr;
d1284 1
a1284 1
 * Tcl_UnstackChannel --
d1286 1
a1286 2
 *	Unstacks an entry in the hash table for a Tcl_Channel
 *	record. This is the reverse to 'Tcl_StackChannel'.
d1289 3
a1291 1
 *	A standard Tcl result.
d1294 1
a1294 2
 *	If TCL_ERROR is returned, the posix error code will be set
 *	with Tcl_SetErrno.
d1299 3
a1301 4
int
Tcl_UnstackChannel (interp, chan)
    Tcl_Interp *interp; /* The interpreter we are working in */
    Tcl_Channel chan;   /* The channel to unstack */
d1303 1
a1303 3
    Channel      *chanPtr  = (Channel *) chan;
    ChannelState *statePtr = chanPtr->state;
    int result = 0;
d1305 2
a1306 116
    /*
     * This operation should occur at the top of a channel stack.
     */

    chanPtr = statePtr->topChanPtr;

    if (chanPtr->downChanPtr != (Channel *) NULL) {
        /*
	 * Instead of manipulating the per-thread / per-interp list/hashtable
	 * of registered channels we wind down the state of the transformation,
	 * and then restore the state of underlying channel into the old
	 * structure.
	 */
	Channel *downChanPtr = chanPtr->downChanPtr;

	/*
	 * Flush the buffers. This ensures that any data still in them
	 * at this time _is_ handled by the transformation we are unstacking
	 * right now. Restrict this to writable channels. Take care to hide
	 * a possible bg-copy in progress from Tcl_Flush and the
	 * CheckForChannelErrors inside.
	 */

	if (statePtr->flags & TCL_WRITABLE) {
	    CopyState*    csPtr;

	    csPtr           = statePtr->csPtr;
	    statePtr->csPtr = (CopyState*) NULL;

	    if (Tcl_Flush((Tcl_Channel) chanPtr) != TCL_OK) {
	        statePtr->csPtr = csPtr;
		Tcl_AppendResult(interp, "could not flush channel \"",
			Tcl_GetChannelName((Tcl_Channel) chanPtr), "\"",
			(char *) NULL);
		return TCL_ERROR;
	    }

	    statePtr->csPtr = csPtr;
	}

	/*
	 * Anything in the input queue and the push-back buffers of
	 * the transformation going away is transformed data, but not
	 * yet read. As unstacking means that the caller does not want
	 * to see transformed data any more we have to discard these
	 * bytes. To avoid writing an analogue to 'DiscardInputQueued'
	 * we move the information in the push back buffers to the
	 * input queue and then call 'DiscardInputQueued' on that.
	 */

	if (((statePtr->flags & TCL_READABLE)  != 0) &&
	    ((statePtr->inQueueHead != (ChannelBuffer*) NULL) ||
	     (chanPtr->inQueueHead  != (ChannelBuffer*) NULL))) {

	    if ((statePtr->inQueueHead != (ChannelBuffer*) NULL) &&
		(chanPtr->inQueueHead  != (ChannelBuffer*) NULL)) {
	        statePtr->inQueueTail->nextPtr = chanPtr->inQueueHead;
		statePtr->inQueueTail = chanPtr->inQueueTail;
	        statePtr->inQueueHead = statePtr->inQueueTail;

	    } else if (chanPtr->inQueueHead != (ChannelBuffer*) NULL) {
	        statePtr->inQueueHead = chanPtr->inQueueHead;
		statePtr->inQueueTail = chanPtr->inQueueTail;
	    }

	    chanPtr->inQueueHead          = (ChannelBuffer*) NULL;
	    chanPtr->inQueueTail          = (ChannelBuffer*) NULL;

	    DiscardInputQueued (statePtr, 0);
	}

	statePtr->topChanPtr	= downChanPtr;
	downChanPtr->upChanPtr	= (Channel *) NULL;

	/*
	 * Leave this link intact for closeproc
	 *  chanPtr->downChanPtr	= (Channel *) NULL;
	 */

	/*
	 * Close and free the channel driver state.
	 */

	if (chanPtr->typePtr->closeProc != TCL_CLOSE2PROC) {
	    result = (chanPtr->typePtr->closeProc)(chanPtr->instanceData,
		    interp);
	} else {
	    result = (chanPtr->typePtr->close2Proc)(chanPtr->instanceData,
		    interp, 0);
	}

	chanPtr->typePtr	= NULL;
	/*
	 * AK: Tcl_NotifyChannel may hold a reference to this block of memory
	 */
	Tcl_EventuallyFree((ClientData) chanPtr, TCL_DYNAMIC);
	UpdateInterest(downChanPtr);

	if (result != 0) {
	    Tcl_SetErrno(result);
	    return TCL_ERROR;
	}
    } else {
        /*
	 * This channel does not cover another one.
	 * Simply do a close, if necessary.
	 */

        if (statePtr->refCount <= 0) {
            if (Tcl_Close(interp, chan) != TCL_OK) {
                return TCL_ERROR;
            }
	}
    }

    return TCL_OK;
d1312 1
a1312 1
 * Tcl_GetStackedChannel --
d1314 1
a1314 1
 *	Determines whether the specified channel is stacked upon another.
d1317 1
a1317 3
 *	NULL if the channel is not stacked upon another one, or a reference
 *	to the channel it is stacked upon. This reference can be used in
 *	queries, but modification is not allowed.
d1325 3
a1327 3
Tcl_Channel
Tcl_GetStackedChannel(chan)
    Tcl_Channel chan;
d1329 1
a1329 1
    Channel *chanPtr = (Channel *) chan;	/* The actual channel. */
d1331 2
a1332 1
    return (Tcl_Channel) chanPtr->downChanPtr;
d1338 1
a1338 1
 * Tcl_GetTopChannel --
d1340 1
a1340 1
 *	Returns the top channel of a channel stack.
d1343 2
a1344 3
 *	NULL if the channel is not stacked upon another one, or a reference
 *	to the channel it is stacked upon. This reference can be used in
 *	queries, but modification is not allowed.
d1352 9
a1360 5
Tcl_Channel
Tcl_GetTopChannel(chan)
    Tcl_Channel chan;
{
    Channel *chanPtr = (Channel *) chan;	/* The actual channel. */
d1362 7
a1368 1
    return (Tcl_Channel) chanPtr->state->topChanPtr;
d1391 1
a1391 1
    Channel *chanPtr = (Channel *) chan;	/* The actual channel. */
d1393 1
a1399 158
 * Tcl_GetChannelType --
 *
 *	Given a channel structure, returns the channel type structure.
 *
 * Results:
 *	Returns a pointer to the channel type structure.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_ChannelType *
Tcl_GetChannelType(chan)
    Tcl_Channel chan;		/* The channel to return type for. */
{
    Channel *chanPtr = (Channel *) chan;	/* The actual channel. */

    return chanPtr->typePtr;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetChannelMode --
 *
 *	Computes a mask indicating whether the channel is open for
 *	reading and writing.
 *
 * Results:
 *	An OR-ed combination of TCL_READABLE and TCL_WRITABLE.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_GetChannelMode(chan)
    Tcl_Channel chan;		/* The channel for which the mode is
                                 * being computed. */
{
    ChannelState *statePtr = ((Channel *) chan)->state;
					/* State of actual channel. */

    return (statePtr->flags & (TCL_READABLE | TCL_WRITABLE));
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetChannelName --
 *
 *	Returns the string identifying the channel name.
 *
 * Results:
 *	The string containing the channel name. This memory is
 *	owned by the generic layer and should not be modified by
 *	the caller.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

char *
Tcl_GetChannelName(chan)
    Tcl_Channel chan;		/* The channel for which to return the name. */
{
    ChannelState *statePtr;	/* State of actual channel. */

    statePtr = ((Channel *) chan)->state;
    return statePtr->channelName;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetChannelHandle --
 *
 *	Returns an OS handle associated with a channel.
 *
 * Results:
 *	Returns TCL_OK and places the handle in handlePtr, or returns
 *	TCL_ERROR on failure.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_GetChannelHandle(chan, direction, handlePtr)
    Tcl_Channel chan;		/* The channel to get file from. */
    int direction;		/* TCL_WRITABLE or TCL_READABLE. */
    ClientData *handlePtr;	/* Where to store handle */
{
    Channel *chanPtr;		/* The actual channel. */
    ClientData handle;
    int result;

    chanPtr = ((Channel *) chan)->state->bottomChanPtr;
    result = (chanPtr->typePtr->getHandleProc)(chanPtr->instanceData,
	    direction, &handle);
    if (handlePtr) {
	*handlePtr = handle;
    }
    return result;
}

/*
 *---------------------------------------------------------------------------
 *
 * AllocChannelBuffer --
 *
 *	A channel buffer has BUFFER_PADDING bytes extra at beginning to
 *	hold any bytes of a native-encoding character that got split by
 *	the end of the previous buffer and need to be moved to the
 *	beginning of the next buffer to make a contiguous string so it
 *	can be converted to UTF-8.
 *
 *	A channel buffer has BUFFER_PADDING bytes extra at the end to
 *	hold any bytes of a native-encoding character (generated from a
 *	UTF-8 character) that overflow past the end of the buffer and
 *	need to be moved to the next buffer.
 *
 * Results:
 *	A newly allocated channel buffer.
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
 */

static ChannelBuffer *
AllocChannelBuffer(length)
    int length;			/* Desired length of channel buffer. */
{
    ChannelBuffer *bufPtr;
    int n;

    n = length + CHANNELBUFFER_HEADER_SIZE + BUFFER_PADDING + BUFFER_PADDING;
    bufPtr = (ChannelBuffer *) ckalloc((unsigned) n);
    bufPtr->nextAdded	= BUFFER_PADDING;
    bufPtr->nextRemoved	= BUFFER_PADDING;
    bufPtr->bufLength	= length + BUFFER_PADDING;
    bufPtr->nextPtr	= (ChannelBuffer *) NULL;
    return bufPtr;
}

/*
 *----------------------------------------------------------------------
 *
d1418 2
a1419 2
RecycleBuffer(statePtr, bufPtr, mustDiscard)
    ChannelState *statePtr;	/* ChannelState in which to recycle buffers. */
d1432 1
a1432 1

d1437 4
a1440 4
    if (statePtr->flags & TCL_READABLE) {
        if (statePtr->inQueueHead == (ChannelBuffer *) NULL) {
            statePtr->inQueueHead = bufPtr;
            statePtr->inQueueTail = bufPtr;
d1443 2
a1444 2
        if (statePtr->saveInBufPtr == (ChannelBuffer *) NULL) {
            statePtr->saveInBufPtr = bufPtr;
d1453 3
a1455 3
    if (statePtr->flags & TCL_WRITABLE) {
        if (statePtr->curOutPtr == (ChannelBuffer *) NULL) {
            statePtr->curOutPtr = bufPtr;
d1467 3
a1469 3
    keepit:
    bufPtr->nextRemoved = BUFFER_PADDING;
    bufPtr->nextAdded = BUFFER_PADDING;
d1490 2
a1491 2
DiscardOutputQueued(statePtr)
    ChannelState *statePtr;	/* ChannelState for which to discard output. */
d1495 4
a1498 4
    while (statePtr->outQueueHead != (ChannelBuffer *) NULL) {
        bufPtr = statePtr->outQueueHead;
        statePtr->outQueueHead = bufPtr->nextPtr;
        RecycleBuffer(statePtr, bufPtr, 0);
d1500 2
a1501 2
    statePtr->outQueueHead = (ChannelBuffer *) NULL;
    statePtr->outQueueTail = (ChannelBuffer *) NULL;
d1522 1
a1522 1
CheckForDeadChannel(interp, statePtr)
d1524 1
a1524 1
    ChannelState *statePtr;	/* The channel state to check. */
d1526 1
a1526 1
    if (statePtr->flags & CHANNEL_DEAD) {
d1530 2
a1531 2
		    "unable to access channel: invalid channel",
		    (char *) NULL);   
a1566 2
    ChannelState *statePtr = chanPtr->state;
					/* State of the channel stack. */
d1573 1
a1573 1
    int errorCode = 0;			/* Stores POSIX error codes from
d1575 1
a1575 2
    int wroteSome = 0;			/* Set to one if any data was
					 * written to the driver. */
d1584 1
a1584 1
    if (CheckForDeadChannel(interp, statePtr)) return -1;
d1598 9
a1606 9

        if (((statePtr->curOutPtr != (ChannelBuffer *) NULL) &&
                (statePtr->curOutPtr->nextAdded == statePtr->curOutPtr->bufLength))
                || ((statePtr->flags & BUFFER_READY) &&
                        (statePtr->outQueueHead == (ChannelBuffer *) NULL))) {
            statePtr->flags &= (~(BUFFER_READY));
            statePtr->curOutPtr->nextPtr = (ChannelBuffer *) NULL;
            if (statePtr->outQueueHead == (ChannelBuffer *) NULL) {
                statePtr->outQueueHead = statePtr->curOutPtr;
d1608 1
a1608 1
                statePtr->outQueueTail->nextPtr = statePtr->curOutPtr;
d1610 2
a1611 2
            statePtr->outQueueTail = statePtr->curOutPtr;
            statePtr->curOutPtr = (ChannelBuffer *) NULL;
d1613 1
a1613 1
        bufPtr = statePtr->outQueueHead;
d1621 1
a1621 1
                (statePtr->flags & BG_FLUSH_SCHEDULED)) {
d1636 1
a1636 1

d1639 2
a1640 3
                (char *) bufPtr->buf + bufPtr->nextRemoved, toWrite,
		&errorCode);

d1664 10
a1673 12
		/*
		 * This used to check for CHANNEL_NONBLOCKING, and panic
		 * if the channel was blocking.  However, it appears
		 * that setting stdin to -blocking 0 has some effect on
		 * the stdout when it's a tty channel (dup'ed underneath)
		 */
		if (!(statePtr->flags & BG_FLUSH_SCHEDULED)) {
		    statePtr->flags |= BG_FLUSH_SCHEDULED;
		    UpdateInterest(chanPtr);
		}
		errorCode = 0;
		break;
d1681 2
a1682 2
                if (statePtr->unreportedError == 0) {
                    statePtr->unreportedError = errorCode;
d1697 1
a1697 1
            DiscardOutputQueued(statePtr);
d1699 1
a1699 3
        } else {
	    wroteSome = 1;
	}
d1708 3
a1710 3
            statePtr->outQueueHead = bufPtr->nextPtr;
            if (statePtr->outQueueHead == (ChannelBuffer *) NULL) {
                statePtr->outQueueTail = (ChannelBuffer *) NULL;
d1712 1
a1712 1
            RecycleBuffer(statePtr, bufPtr, 0);
d1715 1
a1715 1

d1717 2
a1718 4
     * If we wrote some data while flushing in the background, we are done.
     * We can't finish the background flush until we run out of data and
     * the channel becomes writable again.  This ensures that all of the
     * pending data has been flushed at the system level.
d1721 5
a1725 8
    if (statePtr->flags & BG_FLUSH_SCHEDULED) {
	if (wroteSome) {
	    return errorCode;
	} else if (statePtr->outQueueHead == (ChannelBuffer *) NULL) {
	    statePtr->flags &= (~(BG_FLUSH_SCHEDULED));
	    (chanPtr->typePtr->watchProc)(chanPtr->instanceData,
		    statePtr->interestMask);
	}
d1734 6
a1739 6
    if ((statePtr->flags & CHANNEL_CLOSED) && (statePtr->refCount <= 0) &&
            (statePtr->outQueueHead == (ChannelBuffer *) NULL) &&
            ((statePtr->curOutPtr == (ChannelBuffer *) NULL) ||
                    (statePtr->curOutPtr->nextAdded ==
                            statePtr->curOutPtr->nextRemoved))) {
	return CloseChannel(interp, chanPtr, errorCode);
d1749 2
a1750 8
 *	Utility procedure to close a channel and free associated resources.
 *
 *	If the channel was stacked, then the it will copy the necessary
 *	elements of the NEXT channel into the TOP channel, in essence
 *	unstacking the channel.  The NEXT channel will then be freed.
 *
 *	If the channel was not stacked, then we will free all the bits
 *	for the TOP channel, including the data structure itself.
d1753 1
a1753 1
 *	1 if the channel was stacked, 0 otherwise.
a1756 1
 *	May change the value of errno.
d1769 2
a1770 2
    ChannelState *prevCSPtr;		/* Preceding channel state in list of
                                         * all states - used to splice a
d1772 1
a1772 3
    ChannelState *statePtr;		/* state of the channel stack. */
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

d1776 1
a1776 2
    statePtr = chanPtr->state;

d1781 1
a1781 1
    DiscardInputQueued(statePtr, 1);
d1787 3
a1789 3
    if (statePtr->curOutPtr != (ChannelBuffer *) NULL) {
        ckfree((char *) statePtr->curOutPtr);
        statePtr->curOutPtr = (ChannelBuffer *) NULL;
d1797 1
a1797 1
    if (statePtr->outQueueHead != (ChannelBuffer *) NULL) {
d1806 1
a1806 1
    if ((statePtr->outEofChar != 0) && (statePtr->flags & TCL_WRITABLE)) {
d1810 1
a1810 1
        c = (char) statePtr->outEofChar;
d1813 1
a1813 1
#if 0
d1815 1
a1815 1
     * Remove TCL_READABLE and TCL_WRITABLE from statePtr->flags, so
d1822 2
a1823 6
    /*
     * This prevents any data from being flushed from stacked channels.
     */
    statePtr->flags &= (~(TCL_READABLE|TCL_WRITABLE));
#endif

d1828 2
a1829 2
    if (tsdPtr->firstCSPtr && (statePtr == tsdPtr->firstCSPtr)) {
        tsdPtr->firstCSPtr = statePtr->nextCSPtr;
d1831 4
a1834 3
        for (prevCSPtr = tsdPtr->firstCSPtr;
	     prevCSPtr && (prevCSPtr->nextCSPtr != statePtr);
	     prevCSPtr = prevCSPtr->nextCSPtr) {
d1837 1
a1837 1
        if (prevCSPtr == (ChannelState *) NULL) {
d1840 1
a1840 1
        prevCSPtr->nextCSPtr = statePtr->nextCSPtr;
d1844 1
a1844 1
     * Close and free the channel driver state.
d1846 5
a1850 6

    if (chanPtr->typePtr->closeProc != TCL_CLOSE2PROC) {
	result = (chanPtr->typePtr->closeProc)(chanPtr->instanceData, interp);
    } else {
	result = (chanPtr->typePtr->close2Proc)(chanPtr->instanceData, interp,
		0);
d1852 1
a1852 20

    /*
     * Some resources can be cleared only if the bottom channel
     * in a stack is closed. All the other channels in the stack
     * are not allowed to remove.
     */

    if (chanPtr == statePtr->bottomChanPtr) {
	if (statePtr->channelName != (char *) NULL) {
	    ckfree(statePtr->channelName);
	    statePtr->channelName = NULL;
	}

	Tcl_FreeEncoding(statePtr->encoding);
	if (statePtr->outputStage != NULL) {
	    ckfree((char *) statePtr->outputStage);
	    statePtr->outputStage = (char *) NULL;
	}
    }

d1857 3
a1859 3

    if (statePtr->unreportedError != 0) {
        errorCode = statePtr->unreportedError;
d1872 1
a1872 1
    Tcl_DeleteTimerHandler(statePtr->timer);
a1877 36
    if (chanPtr->downChanPtr != (Channel *) NULL) {
#if 0
	int code = TCL_OK;

	while (chanPtr->downChanPtr != (Channel *) NULL) {
	    /*
	     * Unwind the state of the transformation, and then restore the
	     * state of (unstack) the underlying channel into the TOP channel
	     * structure.
	     */
	    code = Tcl_UnstackChannel(interp, (Tcl_Channel) chanPtr);
	    if (code == TCL_ERROR) {
		errorCode = Tcl_GetErrno();
		break;
	    }
	    chanPtr = chanPtr->downChanPtr;
	}
#else
	Channel *downChanPtr = chanPtr->downChanPtr;

	statePtr->nextCSPtr	= tsdPtr->firstCSPtr;
	tsdPtr->firstCSPtr	= statePtr;

	statePtr->topChanPtr	= downChanPtr;
	downChanPtr->upChanPtr	= (Channel *) NULL;
	chanPtr->typePtr	= NULL;

	Tcl_EventuallyFree((ClientData) chanPtr, TCL_DYNAMIC);
	return Tcl_Close(interp, (Tcl_Channel) downChanPtr);
#endif
    }

    /*
     * There is only the TOP Channel, so we free the remaining
     * pointers we have and then ourselves.
     */
a1919 1
    ChannelState *statePtr;		/* State of real IO channel. */
a1920 1
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
d1926 1
a1926 1

d1937 2
a1938 9
    /*
     * This operation should occur at the top of a channel stack.
     */

    chanPtr	= (Channel *) chan;
    statePtr	= chanPtr->state;
    chanPtr	= statePtr->topChanPtr;

    if (statePtr->refCount > 0) {
d1947 3
a1949 3
    for (nhPtr = tsdPtr->nestedHandlerPtr;
	 nhPtr != (NextChannelHandler *) NULL;
	 nhPtr = nhPtr->nestedHandlerPtr) {
d1960 4
a1963 4

    for (chPtr = statePtr->chPtr;
	 chPtr != (ChannelHandler *) NULL;
	 chPtr = chNext) {
d1967 3
a1969 2
    statePtr->chPtr = (ChannelHandler *) NULL;

d1974 1
a1974 1
    StopCopy(statePtr->csPtr);
d1983 1
a1983 1
    statePtr->interestMask = 0;
d1989 3
a1991 3
    for (ePtr = statePtr->scriptRecordPtr;
	 ePtr != (EventScriptRecord *) NULL;
	 ePtr = eNextPtr) {
d1993 1
a1993 1
	Tcl_DecrRefCount(ePtr->scriptPtr);
d1996 1
a1996 1
    statePtr->scriptRecordPtr = (EventScriptRecord *) NULL;
d2002 3
a2004 3
    while (statePtr->closeCbPtr != (CloseCallback *) NULL) {
        cbPtr = statePtr->closeCbPtr;
        statePtr->closeCbPtr = cbPtr->nextPtr;
d2013 3
a2015 15
    if ((statePtr->curOutPtr != (ChannelBuffer *) NULL) &&
	    (statePtr->curOutPtr->nextAdded > statePtr->curOutPtr->nextRemoved)) {
        statePtr->flags |= BUFFER_READY;
    }

    /*
     * If this channel supports it, close the read side, since we don't need it
     * anymore and this will help avoid deadlocks on some channel types.
     */

    if (chanPtr->typePtr->closeProc == TCL_CLOSE2PROC) {
	result = (chanPtr->typePtr->close2Proc)(chanPtr->instanceData, interp,
		TCL_CLOSE_READ);
    } else {
	result = 0;
d2023 4
a2026 3

    statePtr->flags |= CHANNEL_CLOSED;
    if ((FlushChannel(interp, chanPtr, 0) != 0) || (result != 0)) {
d2029 1
d2038 1
a2038 1
 *	Puts a sequence of bytes into an output buffer, may queue the
d2055 1
a2055 1
Tcl_Write(chan, src, srcLen)
d2057 4
a2060 3
    char *src;				/* Data to queue in output buffer. */
    int srcLen;				/* Length of data in bytes, or < 0 for
					 * strlen(). */
d2062 12
d2075 1
a2075 1
     * Always use the topmost channel of the stack
a2076 2
    Channel *chanPtr;
    ChannelState *statePtr;	/* state info for channel */
d2078 8
a2085 2
    statePtr = ((Channel *) chan)->state;
    chanPtr  = statePtr->topChanPtr;
d2087 2
a2088 1
    if (CheckChannelErrors(statePtr, TCL_WRITABLE) != 0) {
d2092 7
a2098 2
    if (srcLen < 0) {
        srcLen = strlen(src);
d2100 2
a2101 1
    return DoWrite(chanPtr, src, srcLen);
d2107 1
a2107 1
 * Tcl_WriteRaw --
d2109 1
a2109 1
 *	Puts a sequence of bytes into an output buffer, may queue the
d2125 22
a2146 10
int
Tcl_WriteRaw(chan, src, srcLen)
    Tcl_Channel chan;			/* The channel to buffer output for. */
    char *src;				/* Data to queue in output buffer. */
    int srcLen;				/* Length of data in bytes, or < 0 for
					 * strlen(). */
{
    Channel *chanPtr = ((Channel *) chan);
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    int errorCode, written;
d2148 4
a2151 7
    if (CheckChannelErrors(statePtr, TCL_WRITABLE | CHANNEL_RAW_MODE) != 0) {
	return -1;
    }

    if (srcLen < 0) {
        srcLen = strlen(src);
    }
d2153 2
d2156 2
a2157 2
     * Go immediately to the driver, do all the error handling by ourselves.
     * The code was stolen from 'FlushChannel'.
d2160 94
a2253 2
    written = (chanPtr->typePtr->outputProc) (chanPtr->instanceData,
	    src, srcLen, &errorCode);
d2255 6
a2260 3
    if (written < 0) {
	Tcl_SetErrno(errorCode);
    }
d2262 1
a2262 1
    return written;
d2266 1
a2266 1
 *---------------------------------------------------------------------------
d2268 1
a2268 1
 * Tcl_WriteChars --
d2270 1
a2270 5
 *	Takes a sequence of UTF-8 characters and converts them for output
 *	using the channel's current encoding, may queue the buffer for
 *	output if it gets full, and also remembers whether the current
 *	buffer is ready e.g. if it contains a newline and we are in
 *	line buffering mode.
d2273 1
a2273 2
 *	The number of bytes written or -1 in case of error. If -1,
 *	Tcl_GetErrno will return the error code.
d2276 1
a2276 2
 *	May buffer up output and may cause output to be produced on the
 *	channel.
d2282 2
a2283 5
Tcl_WriteChars(chan, src, len)
    Tcl_Channel chan;		/* The channel to buffer output for. */
    CONST char *src;		/* UTF-8 characters to queue in output buffer. */
    int len;			/* Length of string in bytes, or < 0 for 
				 * strlen(). */
d2285 15
d2301 1
a2301 1
     * Always use the topmost channel of the stack
a2302 2
    Channel *chanPtr;
    ChannelState *statePtr;	/* state info for channel */
d2304 8
a2311 2
    statePtr = ((Channel *) chan)->state;
    chanPtr  = statePtr->topChanPtr;
d2313 2
a2314 1
    if (CheckChannelErrors(statePtr, TCL_WRITABLE) != 0) {
d2317 13
a2329 2
    if (len < 0) {
        len = strlen(src);
a2330 5
    if (statePtr->encoding == NULL) {
	/*
	 * Inefficient way to convert UTF-8 to byte-array, but the  
	 * code parallels the way it is done for objects.
	 */
d2332 1
a2332 10
	Tcl_Obj *objPtr;
	int result;

	objPtr = Tcl_NewStringObj(src, len);
	src = (char *) Tcl_GetByteArrayFromObj(objPtr, &len);
	result = WriteBytes(chanPtr, src, len);
	Tcl_DecrRefCount(objPtr);
	return result;
    }
    return WriteChars(chanPtr, src, len);
d2336 1
a2336 1
 *---------------------------------------------------------------------------
d2338 1
a2338 1
 * Tcl_WriteObj --
d2340 2
a2341 8
 *	Takes the Tcl object and queues its contents for output.  If the 
 *	encoding of the channel is NULL, takes the byte-array representation 
 *	of the object and queues those bytes for output.  Otherwise, takes 
 *	the characters in the UTF-8 (string) representation of the object 
 *	and converts them for output using the channel's current encoding.  
 *	May flush internal buffers to output if one becomes full or is ready 
 *	for some other reason, e.g. if it contains a newline and the channel 
 *	is in line buffering mode.
d2344 1
a2344 2
 *	The number of bytes written or -1 in case of error. If -1, 
 *	Tcl_GetErrno() will return the error code.
d2347 2
a2348 2
 *	May buffer up output and may cause output to be produced on the
 *	channel.
d2353 6
a2358 4
int
Tcl_WriteObj(chan, objPtr)
    Tcl_Channel chan;		/* The channel to buffer output for. */
    Tcl_Obj *objPtr;		/* The object to write. */
d2360 10
d2371 2
a2372 1
     * Always use the topmost channel of the stack
d2374 6
a2379 17
    Channel *chanPtr;
    ChannelState *statePtr;	/* state info for channel */
    char *src;
    int srcLen;

    statePtr = ((Channel *) chan)->state;
    chanPtr  = statePtr->topChanPtr;

    if (CheckChannelErrors(statePtr, TCL_WRITABLE) != 0) {
	return -1;
    }
    if (statePtr->encoding == NULL) {
	src = (char *) Tcl_GetByteArrayFromObj(objPtr, &srcLen);
	return WriteBytes(chanPtr, src, srcLen);
    } else {
	src = Tcl_GetStringFromObj(objPtr, &srcLen);
	return WriteChars(chanPtr, src, srcLen);
d2386 1
a2386 1
 * WriteBytes --
d2388 1
a2388 4
 *	Write a sequence of bytes into an output buffer, may queue the
 *	buffer for output if it gets full, and also remembers whether the
 *	current buffer is ready e.g. if it contains a newline and we are in
 *	line buffering mode.
d2391 1
a2391 2
 *	The number of bytes written or -1 in case of error. If -1,
 *	Tcl_GetErrno will return the error code.
d2394 1
a2394 2
 *	May buffer up output and may cause output to be produced on the
 *	channel.
d2400 2
a2401 4
WriteBytes(chanPtr, src, srcLen)
    Channel *chanPtr;		/* The channel to buffer output for. */
    CONST char *src;		/* Bytes to write. */
    int srcLen;			/* Number of bytes to write. */
d2403 11
a2413 4
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    ChannelBuffer *bufPtr;
    char *dst;
    int dstLen, dstMax, sawLF, savedLF, total, toWrite;
d2415 7
a2421 3
    total = 0;
    sawLF = 0;
    savedLF = 0;
d2423 25
d2449 2
a2450 2
     * Loop over all bytes in src, storing them in output buffer with
     * proper EOL translation.
d2453 3
a2455 14
    while (srcLen + savedLF > 0) {
	bufPtr = statePtr->curOutPtr;
	if (bufPtr == NULL) {
	    bufPtr = AllocChannelBuffer(statePtr->bufSize);
	    statePtr->curOutPtr	= bufPtr;
	}
	dst = bufPtr->buf + bufPtr->nextAdded;
	dstMax = bufPtr->bufLength - bufPtr->nextAdded;
	dstLen = dstMax;

	toWrite = dstLen;
	if (toWrite > srcLen) {
	    toWrite = srcLen;
	}
d2457 2
a2458 6
	if (savedLF) {
	    /*
	     * A '\n' was left over from last call to TranslateOutputEOL()
	     * and we need to store it in this buffer.  If the channel is
	     * line-based, we will need to flush it.
	     */
d2460 13
a2472 3
	    *dst++ = '\n';
	    dstLen--;
	    sawLF++;
d2474 13
a2486 11
	sawLF += TranslateOutputEOL(statePtr, dst, src, &dstLen, &toWrite);
	dstLen += savedLF;
	savedLF = 0;

	if (dstLen > dstMax) {
	    savedLF = 1;
	    dstLen = dstMax;
	}
	bufPtr->nextAdded += dstLen;
	if (CheckFlush(chanPtr, bufPtr, sawLF) != 0) {
	    return -1;
a2487 4
	total += dstLen;
	src += toWrite;
	srcLen -= toWrite;
	sawLF = 0;
d2489 1
a2489 1
    return total;
d2495 1
a2495 1
 * WriteChars --
d2497 2
a2498 5
 *	Convert UTF-8 bytes to the channel's external encoding and
 *	write the produced bytes into an output buffer, may queue the 
 *	buffer for output if it gets full, and also remembers whether the
 *	current buffer is ready e.g. if it contains a newline and we are in
 *	line buffering mode.
d2501 2
a2502 2
 *	The number of bytes written or -1 in case of error. If -1,
 *	Tcl_GetErrno will return the error code.
d2505 1
a2505 2
 *	May buffer up output and may cause output to be produced on the
 *	channel.
d2511 5
a2515 4
WriteChars(chanPtr, src, srcLen)
    Channel *chanPtr;		/* The channel to buffer output for. */
    CONST char *src;		/* UTF-8 string to write. */
    int srcLen;			/* Length of UTF-8 string in bytes. */
d2517 48
a2564 28
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    ChannelBuffer *bufPtr;
    char *dst, *stage;
    int saved, savedLF, sawLF, total, toWrite, flags;
    int dstWrote, dstLen, stageLen, stageMax, stageRead;
    Tcl_Encoding encoding;
    char safe[BUFFER_PADDING];
    
    total = 0;
    sawLF = 0;
    savedLF = 0;
    saved = 0;
    encoding = statePtr->encoding;

    /*
     * Loop over all UTF-8 characters in src, storing them in staging buffer
     * with proper EOL translation.
     */

    while (srcLen + savedLF > 0) {
	stage = statePtr->outputStage;
	stageMax = statePtr->bufSize;
	stageLen = stageMax;

	toWrite = stageLen;
	if (toWrite > srcLen) {
	    toWrite = srcLen;
	}
a2565 1
	if (savedLF) {
d2567 35
a2601 11
	     * A '\n' was left over from last call to TranslateOutputEOL()
	     * and we need to store it in the staging buffer.  If the
	     * channel is line-based, we will need to flush the output
	     * buffer (after translating the staging buffer).
	     */
	    
	    *stage++ = '\n';
	    stageLen--;
	    sawLF++;
	}
	sawLF += TranslateOutputEOL(statePtr, stage, src, &stageLen, &toWrite);
d2603 33
a2635 10
	stage -= savedLF;
	stageLen += savedLF;
	savedLF = 0;

	if (stageLen > stageMax) {
	    savedLF = 1;
	    stageLen = stageMax;
	}
	src += toWrite;
	srcLen -= toWrite;
d2637 4
a2640 4
	flags = statePtr->outputEncodingFlags;
	if (srcLen == 0) {
	    flags |= TCL_ENCODING_END;
	}
d2642 30
a2671 4
	/*
	 * Loop over all UTF-8 characters in staging buffer, converting them
	 * to external encoding, storing them in output buffer.
	 */
d2673 3
a2675 8
	while (stageLen + saved > 0) {
	    bufPtr = statePtr->curOutPtr;
	    if (bufPtr == NULL) {
		bufPtr = AllocChannelBuffer(statePtr->bufSize);
		statePtr->curOutPtr = bufPtr;
	    }
	    dst = bufPtr->buf + bufPtr->nextAdded;
	    dstLen = bufPtr->bufLength - bufPtr->nextAdded;
d2677 13
a2689 13
	    if (saved != 0) {
		/*
		 * Here's some translated bytes left over from the last
		 * buffer that we need to stick at the beginning of this
		 * buffer.
		 */
		 
		memcpy((VOID *) dst, (VOID *) safe, (size_t) saved);
		bufPtr->nextAdded += saved;
		dst += saved;
		dstLen -= saved;
		saved = 0;
	    }
d2691 6
a2696 9
	    Tcl_UtfToExternal(NULL, encoding, stage, stageLen, flags,
		    &statePtr->outputEncodingState, dst,
		    dstLen + BUFFER_PADDING, &stageRead, &dstWrote, NULL);
	    if (stageRead + dstWrote == 0) {
		/*
		 * We have an incomplete UTF-8 character at the end of the
		 * staging buffer.  It will get moved to the beginning of the
		 * staging buffer followed by more bytes from src.
		 */
d2698 22
a2719 16
		src -= stageLen;
		srcLen += stageLen;
		stageLen = 0;
		savedLF = 0;
		break;
	    }
	    bufPtr->nextAdded += dstWrote;
	    if (bufPtr->nextAdded > bufPtr->bufLength) {
		/*
		 * When translating from UTF-8 to external encoding, we
		 * allowed the translation to produce a character that
		 * crossed the end of the output buffer, so that we would
		 * get a completely full buffer before flushing it.  The
		 * extra bytes will be moved to the beginning of the next
		 * buffer.
		 */
d2721 3
a2723 7
		saved = bufPtr->nextAdded - bufPtr->bufLength;
		memcpy((VOID *) safe, (VOID *) (dst + dstLen), (size_t) saved);
		bufPtr->nextAdded = bufPtr->bufLength;
	    }
	    if (CheckFlush(chanPtr, bufPtr, sawLF) != 0) {
		return -1;
	    }
d2725 6
a2730 5
	    total += dstWrote;
	    stage += stageRead;
	    stageLen -= stageRead;
	    sawLF = 0;
	}
d2732 8
a2739 1
    return total;
d2743 1
a2743 3
 *---------------------------------------------------------------------------
 *
 * TranslateOutputEOL --
d2745 1
a2745 3
 *	Helper function for WriteBytes() and WriteChars().  Converts the
 *	'\n' characters in the source buffer into the appropriate EOL
 *	form specified by the output translation mode.
d2747 3
a2749 8
 *	EOL translation stops either when the source buffer is empty
 *	or the output buffer is full.
 *
 *	When converting to CRLF mode and there is only 1 byte left in
 *	the output buffer, this routine stores the '\r' in the last
 *	byte and then stores the '\n' in the byte just past the end of the 
 *	buffer.  The caller is responsible for passing in a buffer that
 *	is large enough to hold the extra byte.
d2752 3
a2754 11
 *	The return value is 1 if a '\n' was translated from the source
 *	buffer, or 0 otherwise -- this can be used by the caller to
 *	decide to flush a line-based channel even though the channel
 *	buffer is not full.
 *
 *	*dstLenPtr is filled with how many bytes of the output buffer
 *	were used.  As mentioned above, this can be one more that
 *	the output buffer's specified length if a CRLF was stored.
 *
 *	*srcLenPtr is filled with how many bytes of the source buffer
 *	were consumed.  
d2757 1
a2757 4
 *	It may be obvious, but bears mentioning that when converting
 *	in CRLF mode (which requires two bytes of storage in the output
 *	buffer), the number of bytes consumed from the source buffer
 *	will be less than the number of bytes stored in the output buffer.
d2759 1
a2759 1
 *---------------------------------------------------------------------------
d2763 36
a2798 52
TranslateOutputEOL(statePtr, dst, src, dstLenPtr, srcLenPtr)
    ChannelState *statePtr;	/* Channel being read, for translation and
				 * buffering modes. */
    char *dst;			/* Output buffer filled with UTF-8 chars by
				 * applying appropriate EOL translation to
				 * source characters. */
    CONST char *src;		/* Source UTF-8 characters. */
    int *dstLenPtr;		/* On entry, the maximum length of output
				 * buffer in bytes.  On exit, the number of
				 * bytes actually used in output buffer. */
    int *srcLenPtr;		/* On entry, the length of source buffer.
				 * On exit, the number of bytes read from
				 * the source buffer. */
{
    char *dstEnd;
    int srcLen, newlineFound;
    
    newlineFound = 0;
    srcLen = *srcLenPtr;

    switch (statePtr->outputTranslation) {
	case TCL_TRANSLATE_LF: {
	    for (dstEnd = dst + srcLen; dst < dstEnd; ) {
		if (*src == '\n') {
		    newlineFound = 1;
		}
		*dst++ = *src++;
	    }
	    *dstLenPtr = srcLen;
	    break;
	}
	case TCL_TRANSLATE_CR: {
	    for (dstEnd = dst + srcLen; dst < dstEnd;) {
		if (*src == '\n') {
		    *dst++ = '\r';
		    newlineFound = 1;
		    src++;
		} else {
		    *dst++ = *src++;
		}
	    }
	    *dstLenPtr = srcLen;
	    break;
	}
	case TCL_TRANSLATE_CRLF: {
	    /*
	     * Since this causes the number of bytes to grow, we
	     * start off trying to put 'srcLen' bytes into the
	     * output buffer, but allow it to store more bytes, as
	     * long as there's still source bytes and room in the
	     * output buffer.
	     */
d2800 12
a2811 5
	    char *dstStart, *dstMax;
	    CONST char *srcStart;
	    
	    dstStart = dst;
	    dstMax = dst + *dstLenPtr;
d2813 3
a2815 11
	    srcStart = src;
	    
	    if (srcLen < *dstLenPtr) {
		dstEnd = dst + srcLen;
	    } else {
		dstEnd = dst + *dstLenPtr;
	    }
	    while (dst < dstEnd) {
		if (*src == '\n') {
		    if (dstEnd < dstMax) {
			dstEnd++;
d2817 59
a2875 12
		    *dst++ = '\r';
		    newlineFound = 1;
		}
		*dst++ = *src++;
	    }
	    *srcLenPtr = src - srcStart;
	    *dstLenPtr = dst - dstStart;
	    break;
	}
	default: {
	    break;
	}
d2877 3
a2879 1
    return newlineFound;
d2883 1
a2883 1
 *---------------------------------------------------------------------------
d2885 1
a2885 1
 * CheckFlush --
d2887 3
a2889 2
 *	Helper function for WriteBytes() and WriteChars().  If the
 *	channel buffer is ready to be flushed, flush it.
d2892 3
a2894 2
 *	The return value is -1 if there was a problem flushing the
 *	channel buffer, or 0 otherwise.
d2897 1
a2897 1
 *	The buffer will be recycled if it is flushed.
d2899 1
a2899 1
 *---------------------------------------------------------------------------
d2903 21
a2923 29
CheckFlush(chanPtr, bufPtr, newlineFlag)
    Channel *chanPtr;		/* Channel being read, for buffering mode. */
    ChannelBuffer *bufPtr;	/* Channel buffer to possibly flush. */
    int newlineFlag;		/* Non-zero if a the channel buffer
				 * contains a newline. */
{
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    /*
     * The current buffer is ready for output:
     * 1. if it is full.
     * 2. if it contains a newline and this channel is line-buffered.
     * 3. if it contains any output and this channel is unbuffered.
     */

    if ((statePtr->flags & BUFFER_READY) == 0) {
	if (bufPtr->nextAdded == bufPtr->bufLength) {
	    statePtr->flags |= BUFFER_READY;
	} else if (statePtr->flags & CHANNEL_LINEBUFFERED) {
	    if (newlineFlag != 0) {
		statePtr->flags |= BUFFER_READY;
	    }
	} else if (statePtr->flags & CHANNEL_UNBUFFERED) {
	    statePtr->flags |= BUFFER_READY;
	}
    }
    if (statePtr->flags & BUFFER_READY) {
	if (FlushChannel(NULL, chanPtr, 0) != 0) {
	    return -1;
	}
a2924 21
    return 0;
}

/*
 *---------------------------------------------------------------------------
 *
 * Tcl_Gets --
 *
 *	Reads a complete line of input from the channel into a Tcl_DString.
 *
 * Results:
 *	Length of line read (in characters) or -1 if error, EOF, or blocked.
 *	If -1, use Tcl_GetErrno() to retrieve the POSIX error code for the
 *	error or condition that occurred.
 *
 * Side effects:
 *	May flush output on the channel.  May cause input to be consumed
 *	from the channel.
 *
 *---------------------------------------------------------------------------
 */
d2926 3
a2928 17
int
Tcl_Gets(chan, lineRead)
    Tcl_Channel chan;		/* Channel from which to read. */
    Tcl_DString *lineRead;	/* The line read will be appended to this
				 * DString as UTF-8 characters.  The caller
				 * must have initialized it and is responsible
				 * for managing the storage. */
{
    Tcl_Obj *objPtr;
    int charsStored, length;
    char *string;

    objPtr = Tcl_NewObj();
    charsStored = Tcl_GetsObj(chan, objPtr);
    if (charsStored > 0) {
	string = Tcl_GetStringFromObj(objPtr, &length);
	Tcl_DStringAppend(lineRead, string, length);
d2930 1
a2930 2
    Tcl_DecrRefCount(objPtr);
    return charsStored;
d2934 1
a2934 1
 *---------------------------------------------------------------------------
d2936 1
a2936 1
 * Tcl_GetsObj --
d2938 2
a2939 4
 *	Accumulate input from the input channel until end-of-line or
 *	end-of-file has been seen.  Bytes read from the input channel
 *	are converted to UTF-8 using the encoding specified by the
 *	channel.
d2942 1
a2942 3
 *	Number of characters accumulated in the object or -1 if error,
 *	blocked, or EOF.  If -1, use Tcl_GetErrno() to retrieve the
 *	POSIX error code for the error or condition that occurred.
d2947 1
a2947 5
 *	On reading EOF, leave channel pointing at EOF char.
 *	On reading EOL, leave channel pointing after EOL, but don't
 *	return EOL in dst buffer.
 *
 *---------------------------------------------------------------------------
d2950 3
a2952 5
int
Tcl_GetsObj(chan, objPtr)
    Tcl_Channel chan;		/* Channel from which to read. */
    Tcl_Obj *objPtr;		/* The line read will be appended to this
				 * object as UTF-8 characters. */
d2954 4
a2957 9
    GetsState gs;
    Channel *chanPtr = (Channel *) chan;
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    ChannelBuffer *bufPtr;
    int inEofChar, skip, copiedTotal;
    Tcl_Encoding encoding;
    char *dst, *dstEnd, *eol, *eof;
    Tcl_EncodingState oldState;
    int oldLength, oldFlags, oldRemoved;
d2960 1
a2960 1
     * This operation should occur at the top of a channel stack.
d2963 4
a2966 5
    chanPtr = statePtr->topChanPtr;

    if (CheckChannelErrors(statePtr, TCL_READABLE) != 0) {
	copiedTotal = -1;
	goto done;
a2968 3
    bufPtr = statePtr->inQueueHead;
    encoding = statePtr->encoding;

d2970 1
a2970 2
     * Preserved so we can restore the channel's state in case we don't
     * find a newline in the available input.
d2973 3
a2975 6
    Tcl_GetStringFromObj(objPtr, &oldLength);
    oldFlags = statePtr->inputEncodingFlags;
    oldState = statePtr->inputEncodingState;
    oldRemoved = BUFFER_PADDING;
    if (bufPtr != NULL) {
	oldRemoved = bufPtr->nextRemoved;
d2979 1
a2979 3
     * If there is no encoding, use "iso8859-1" -- Tcl_GetsObj() doesn't
     * produce ByteArray objects.  To avoid circularity problems,
     * "iso8859-1" is builtin to Tcl.
d2982 3
a2984 2
    if (encoding == NULL) {
	encoding = Tcl_GetEncoding(NULL, "iso8859-1");
d2988 4
a2991 2
     * Object used by FilterInputBytes to keep track of how much data has
     * been consumed from the channel buffers.
d2993 5
a2997 17

    gs.objPtr		= objPtr;
    gs.dstPtr		= &dst;
    gs.encoding		= encoding;
    gs.bufPtr		= bufPtr;
    gs.state		= oldState;
    gs.rawRead		= 0;
    gs.bytesWrote	= 0;
    gs.charsWrote	= 0;
    gs.totalChars	= 0;

    dst = objPtr->bytes + oldLength;
    dstEnd = dst;

    skip = 0;
    eof = NULL;
    inEofChar = statePtr->inEofChar;
d3000 6
a3005 134
	if (dst >= dstEnd) {
	    if (FilterInputBytes(chanPtr, &gs) != 0) {
		goto restore;
	    }
	    dstEnd = dst + gs.bytesWrote;
	}
	
	/*
	 * Remember if EOF char is seen, then look for EOL anyhow, because
	 * the EOL might be before the EOF char.
	 */

	if (inEofChar != '\0') {
	    for (eol = dst; eol < dstEnd; eol++) {
		if (*eol == inEofChar) {
		    dstEnd = eol;
		    eof = eol;
		    break;
		}
	    }
	}

	/*
	 * On EOL, leave current file position pointing after the EOL, but
	 * don't store the EOL in the output string.
	 */

	eol = dst;
	switch (statePtr->inputTranslation) {
	    case TCL_TRANSLATE_LF: {
		for (eol = dst; eol < dstEnd; eol++) {
		    if (*eol == '\n') {
			skip = 1;
			goto goteol;
		    }
		}
		break;
	    }
	    case TCL_TRANSLATE_CR: {
		for (eol = dst; eol < dstEnd; eol++) {
		    if (*eol == '\r') {
			skip = 1;
			goto goteol;
		    }
		}
		break;
	    }
	    case TCL_TRANSLATE_CRLF: {
		for (eol = dst; eol < dstEnd; eol++) {
		    if (*eol == '\r') {
			eol++;
			if (eol >= dstEnd) {
			    int offset;
			    
			    offset = eol - objPtr->bytes;
			    dst = dstEnd;
			    if (FilterInputBytes(chanPtr, &gs) != 0) {
				goto restore;
			    }
			    dstEnd = dst + gs.bytesWrote;
			    eol = objPtr->bytes + offset;
			    if (eol >= dstEnd) {
				skip = 0;
				goto goteol;
			    }
			}
			if (*eol == '\n') {
			    eol--;
			    skip = 2;
			    goto goteol;
			}
		    }
		}
		break;
	    }
	    case TCL_TRANSLATE_AUTO: {
		skip = 1;
		if (statePtr->flags & INPUT_SAW_CR) {
		    statePtr->flags &= ~INPUT_SAW_CR;
		    if (*eol == '\n') {
			/*
			 * Skip the raw bytes that make up the '\n'.
			 */

			char tmp[1 + TCL_UTF_MAX];
			int rawRead;

			bufPtr = gs.bufPtr;
			Tcl_ExternalToUtf(NULL, gs.encoding,
				bufPtr->buf + bufPtr->nextRemoved,
				gs.rawRead, statePtr->inputEncodingFlags,
				&gs.state, tmp, 1 + TCL_UTF_MAX, &rawRead,
				NULL, NULL);
			bufPtr->nextRemoved += rawRead;
			gs.rawRead -= rawRead;
			gs.bytesWrote--;
			gs.charsWrote--;
			memmove(dst, dst + 1, (size_t) (dstEnd - dst));
			dstEnd--;
		    }
		}
		for (eol = dst; eol < dstEnd; eol++) {
		    if (*eol == '\r') {
			eol++;
			if (eol == dstEnd) {
			    /*
			     * If buffer ended on \r, peek ahead to see if a
			     * \n is available.
			     */

			    int offset;
			    
			    offset = eol - objPtr->bytes;
			    dst = dstEnd;
			    PeekAhead(chanPtr, &dstEnd, &gs);
			    eol = objPtr->bytes + offset;
			    if (eol >= dstEnd) {
				eol--;
				statePtr->flags |= INPUT_SAW_CR;
				goto goteol;
			    }
			}
			if (*eol == '\n') {
			    skip++;
			}
			eol--;
			goto goteol;
		    } else if (*eol == '\n') {
			goto goteol;
		    }
		}
	    }
	}
	if (eof != NULL) {
d3007 3
a3009 3
	     * EOF character was seen.  On EOF, leave current file position
	     * pointing at the EOF character, but don't store the EOF
	     * character in the output string.
d3011 11
a3021 63

	    dstEnd = eof;
	    statePtr->flags |= (CHANNEL_EOF | CHANNEL_STICKY_EOF);
	    statePtr->inputEncodingFlags |= TCL_ENCODING_END;
	}
	if (statePtr->flags & CHANNEL_EOF) {
	    skip = 0;
	    eol = dstEnd;
	    if (eol == objPtr->bytes) {
		/*
		 * If we didn't produce any bytes before encountering EOF,
		 * caller needs to see -1.
		 */

		Tcl_SetObjLength(objPtr, 0);
		CommonGetsCleanup(chanPtr, encoding);
		copiedTotal = -1;
		goto done;
	    }
	    goto goteol;
	}
	dst = dstEnd;
    }

    /*
     * Found EOL or EOF, but the output buffer may now contain too many
     * UTF-8 characters.  We need to know how many raw bytes correspond to
     * the number of UTF-8 characters we want, plus how many raw bytes
     * correspond to the character(s) making up EOL (if any), so we can
     * remove the correct number of bytes from the channel buffer.
     */
     
    goteol:
    bufPtr = gs.bufPtr;
    statePtr->inputEncodingState = gs.state;
    Tcl_ExternalToUtf(NULL, gs.encoding, bufPtr->buf + bufPtr->nextRemoved,
	    gs.rawRead, statePtr->inputEncodingFlags,
	    &statePtr->inputEncodingState, dst, eol - dst + skip + TCL_UTF_MAX,
	    &gs.rawRead, NULL, &gs.charsWrote);
    bufPtr->nextRemoved += gs.rawRead;

    /*
     * Recycle all the emptied buffers.
     */

    Tcl_SetObjLength(objPtr, eol - objPtr->bytes);
    CommonGetsCleanup(chanPtr, encoding);
    statePtr->flags &= ~CHANNEL_BLOCKED;
    copiedTotal = gs.totalChars + gs.charsWrote - skip;
    goto done;

    /*
     * Couldn't get a complete line.  This only happens if we get a error
     * reading from the channel or we are non-blocking and there wasn't
     * an EOL or EOF in the data available.
     */

    restore:
    bufPtr = statePtr->inQueueHead;
    bufPtr->nextRemoved = oldRemoved;

    for (bufPtr = bufPtr->nextPtr; bufPtr != NULL; bufPtr = bufPtr->nextPtr) {
	bufPtr->nextRemoved = BUFFER_PADDING;
a3022 1
    CommonGetsCleanup(chanPtr, encoding);
d3024 1
a3024 3
    statePtr->inputEncodingState = oldState;
    statePtr->inputEncodingFlags = oldFlags;
    Tcl_SetObjLength(objPtr, oldLength);
d3037 2
a3038 11
    statePtr->flags |= CHANNEL_NEED_MORE_DATA;
    copiedTotal = -1;

    done:
    /*
     * Update the notifier state so we don't block while there is still
     * data in the buffers.
     */

    UpdateInterest(chanPtr);
    return copiedTotal;
d3040 1
a3040 1

d3042 1
a3042 1
 *---------------------------------------------------------------------------
d3044 1
a3044 4
 * FilterInputBytes --
 *
 *	Helper function for Tcl_GetsObj.  Produces UTF-8 characters from
 *	raw bytes read from the channel.  
d3046 1
a3046 4
 *	Consumes available bytes from channel buffers.  When channel
 *	buffers are exhausted, reads more bytes from channel device into
 *	a new channel buffer.  It is the caller's responsibility to
 *	free the channel buffers that have been exhausted.
d3049 2
a3050 2
 *	The return value is -1 if there was an error reading from the
 *	channel, 0 otherwise.
d3053 1
a3053 2
 *	Status object keeps track of how much data from channel buffers
 *	has been consumed and where UTF-8 bytes should be stored.
d3055 1
a3055 1
 *---------------------------------------------------------------------------
d3057 6
a3062 5
 
static int
FilterInputBytes(chanPtr, gsPtr)
    Channel *chanPtr;		/* Channel to read. */
    GetsState *gsPtr;		/* Current state of gets operation. */
d3064 7
a3070 28
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    ChannelBuffer *bufPtr;
    char *raw, *rawStart, *rawEnd;
    char *dst;
    int offset, toRead, dstNeeded, spaceLeft, result, rawLen, length;
    Tcl_Obj *objPtr;
#define ENCODING_LINESIZE   30	/* Lower bound on how many bytes to convert
				 * at a time.  Since we don't know a priori
				 * how many bytes of storage this many source
				 * bytes will use, we actually need at least
				 * ENCODING_LINESIZE * TCL_MAX_UTF bytes of
				 * room. */

    objPtr = gsPtr->objPtr;

    /*
     * Subtract the number of bytes that were removed from channel buffer
     * during last call.
     */

    bufPtr = gsPtr->bufPtr;
    if (bufPtr != NULL) {
	bufPtr->nextRemoved += gsPtr->rawRead;
	if (bufPtr->nextRemoved >= bufPtr->nextAdded) {
	    bufPtr = bufPtr->nextPtr;
	}
    }
    gsPtr->totalChars += gsPtr->charsWrote;
d3072 4
a3075 23
    if ((bufPtr == NULL) || (bufPtr->nextAdded == BUFFER_PADDING)) {
	/*
	 * All channel buffers were exhausted and the caller still hasn't
	 * seen EOL.  Need to read more bytes from the channel device.
	 * Side effect is to allocate another channel buffer.
	 */
	 
	read:
        if (statePtr->flags & CHANNEL_BLOCKED) {
            if (statePtr->flags & CHANNEL_NONBLOCKING) {
		gsPtr->charsWrote = 0;
		gsPtr->rawRead = 0;
		return -1;
	    }
            statePtr->flags &= ~CHANNEL_BLOCKED;
        }
	if (GetInput(chanPtr) != 0) {
	    gsPtr->charsWrote = 0;
	    gsPtr->rawRead = 0;
	    return -1;
	}
	bufPtr = statePtr->inQueueTail;
	gsPtr->bufPtr = bufPtr;
d3079 1
a3079 3
     * Convert some of the bytes from the channel buffer to UTF-8.  Space in
     * objPtr's string rep is used to hold the UTF-8 characters.  Grow the
     * string rep if we need more space.
d3082 3
a3084 10
    rawStart = bufPtr->buf + bufPtr->nextRemoved;
    raw = rawStart;
    rawEnd = bufPtr->buf + bufPtr->nextAdded;
    rawLen = rawEnd - rawStart;

    dst = *gsPtr->dstPtr;
    offset = dst - objPtr->bytes;
    toRead = ENCODING_LINESIZE;
    if (toRead > rawLen) {
	toRead = rawLen;
d3086 4
a3089 24
    dstNeeded = toRead * TCL_UTF_MAX + 1;
    spaceLeft = objPtr->length - offset - TCL_UTF_MAX - 1;
    if (dstNeeded > spaceLeft) {
	length = offset * 2;
	if (offset < dstNeeded) {
	    length = offset + dstNeeded;
	}
	length += TCL_UTF_MAX + 1;
	Tcl_SetObjLength(objPtr, length);
	spaceLeft = length - offset;
	dst = objPtr->bytes + offset;
	*gsPtr->dstPtr = dst;
    }
    gsPtr->state = statePtr->inputEncodingState;
    result = Tcl_ExternalToUtf(NULL, gsPtr->encoding, raw, rawLen,
	    statePtr->inputEncodingFlags, &statePtr->inputEncodingState,
	    dst, spaceLeft, &gsPtr->rawRead, &gsPtr->bytesWrote,
	    &gsPtr->charsWrote); 
    if (result == TCL_CONVERT_MULTIBYTE) {
	/*
	 * The last few bytes in this channel buffer were the start of a
	 * multibyte sequence.  If this buffer was full, then move them to
	 * the next buffer so the bytes will be contiguous.  
	 */
d3091 3
a3093 38
	ChannelBuffer *nextPtr;
	int extra;
	
	nextPtr = bufPtr->nextPtr;
	if (bufPtr->nextAdded < bufPtr->bufLength) {
	    if (gsPtr->rawRead > 0) {
		/*
		 * Some raw bytes were converted to UTF-8.  Fall through,
		 * returning those UTF-8 characters because a EOL might be
		 * present in them.
		 */
	    } else if (statePtr->flags & CHANNEL_EOF) {
		/*
		 * There was a partial character followed by EOF on the
		 * device.  Fall through, returning that nothing was found.
		 */

		bufPtr->nextRemoved = bufPtr->nextAdded;
	    } else {
		/*
		 * There are no more cached raw bytes left.  See if we can
		 * get some more.
		 */

		goto read;
	    }
	} else {
	    if (nextPtr == NULL) {
		nextPtr = AllocChannelBuffer(statePtr->bufSize);
		bufPtr->nextPtr = nextPtr;
		statePtr->inQueueTail = nextPtr;
	    }
	    extra = rawLen - gsPtr->rawRead;
	    memcpy((VOID *) (nextPtr->buf + BUFFER_PADDING - extra),
		    (VOID *) (raw + gsPtr->rawRead), (size_t) extra);
	    nextPtr->nextRemoved -= extra;
	    bufPtr->nextAdded -= extra;
	}
d3096 1
a3096 2
    gsPtr->bufPtr = bufPtr;
    return 0;
d3100 1
a3100 1
 *---------------------------------------------------------------------------
d3102 1
a3102 1
 * PeekAhead --
d3104 1
a3104 3
 *	Helper function used by Tcl_GetsObj().  Called when we've seen a
 *	\r at the end of the UTF-8 string and want to look ahead one
 *	character to see if it is a \n.
d3107 2
a3108 3
 *	*gsPtr->dstPtr is filled with a pointer to the start of the range of
 *	UTF-8 characters that were found by peeking and *dstEndPtr is filled
 *	with a pointer to the bytes just after the end of the range.
d3111 1
a3111 3
 *	If no more raw bytes were available in one of the channel buffers,
 *	tries to perform a non-blocking read to get more bytes from the
 *	channel device.
d3113 1
a3113 1
 *---------------------------------------------------------------------------
d3116 5
a3120 6
static void
PeekAhead(chanPtr, dstEndPtr, gsPtr)
    Channel *chanPtr;		/* The channel to read. */
    char **dstEndPtr;		/* Filled with pointer to end of new range
				 * of UTF-8 characters. */
    GetsState *gsPtr;		/* Current state of gets operation. */
d3122 6
a3127 7
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    ChannelBuffer *bufPtr;
    Tcl_DriverBlockModeProc *blockModeProc;
    int bytesLeft;

    bufPtr = gsPtr->bufPtr;

d3129 3
a3131 5
     * If there's any more raw input that's still buffered, we'll peek into
     * that.  Otherwise, only get more data from the channel driver if it
     * looks like there might actually be more data.  The assumption is that
     * if the channel buffer is filled right up to the end, then there
     * might be more data to read.
d3134 2
a3135 23
    blockModeProc = NULL;
    if (bufPtr->nextPtr == NULL) {
	bytesLeft = bufPtr->nextAdded - (bufPtr->nextRemoved + gsPtr->rawRead);
	if (bytesLeft == 0) {
	    if (bufPtr->nextAdded < bufPtr->bufLength) {
		/*
		 * Don't peek ahead if last read was short read.
		 */
		 
		goto cleanup;
	    }
	    if ((statePtr->flags & CHANNEL_NONBLOCKING) == 0) {
		blockModeProc = Tcl_ChannelBlockModeProc(chanPtr->typePtr);
		if (blockModeProc == NULL) {
		    /*
		     * Don't peek ahead if cannot set non-blocking mode.
		     */

		    goto cleanup;
		}
		StackSetBlockMode(chanPtr, TCL_MODE_NONBLOCKING);
	    }
	}
d3137 23
a3159 2
    if (FilterInputBytes(chanPtr, gsPtr) == 0) {
	*dstEndPtr = *gsPtr->dstPtr + gsPtr->bytesWrote;
a3160 4
    if (blockModeProc != NULL) {
	StackSetBlockMode(chanPtr, TCL_MODE_BLOCKING);
    }
    return;
d3162 10
a3171 6
    cleanup:
    bufPtr->nextRemoved += gsPtr->rawRead;
    gsPtr->rawRead = 0;
    gsPtr->totalChars += gsPtr->charsWrote;
    gsPtr->bytesWrote = 0;
    gsPtr->charsWrote = 0;
d3175 1
a3175 1
 *---------------------------------------------------------------------------
d3177 1
a3177 1
 * CommonGetsCleanup --
d3179 2
a3180 2
 *	Helper function for Tcl_GetsObj() to restore the channel after
 *	a "gets" operation.
d3183 3
a3185 1
 *	None.
d3188 2
a3189 1
 *	Encoding may be freed.
d3191 1
a3191 1
 *---------------------------------------------------------------------------
d3193 23
a3215 8
 
static void
CommonGetsCleanup(chanPtr, encoding)
    Channel *chanPtr;
    Tcl_Encoding encoding;
{
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    ChannelBuffer *bufPtr, *nextPtr;
d3217 6
a3222 7
    bufPtr = statePtr->inQueueHead;
    for ( ; bufPtr != NULL; bufPtr = nextPtr) {
	nextPtr = bufPtr->nextPtr;
	if (bufPtr->nextRemoved < bufPtr->nextAdded) {
	    break;
	}
	RecycleBuffer(statePtr, bufPtr, 0);
d3224 7
a3230 27
    statePtr->inQueueHead = bufPtr;
    if (bufPtr == NULL) {
	statePtr->inQueueTail = NULL;
    } else {
	/*
	 * If any multi-byte characters were split across channel buffer
	 * boundaries, the split-up bytes were moved to the next channel
	 * buffer by FilterInputBytes().  Move the bytes back to their
	 * original buffer because the caller could change the channel's
	 * encoding which could change the interpretation of whether those
	 * bytes really made up multi-byte characters after all.
	 */
	 
	nextPtr = bufPtr->nextPtr;
	for ( ; nextPtr != NULL; nextPtr = bufPtr->nextPtr) {
	    int extra;

	    extra = bufPtr->bufLength - bufPtr->nextAdded;
	    if (extra > 0) {
		memcpy((VOID *) (bufPtr->buf + bufPtr->nextAdded),
			(VOID *) (nextPtr->buf + BUFFER_PADDING - extra),
			(size_t) extra);
		bufPtr->nextAdded += extra;
		nextPtr->nextRemoved = BUFFER_PADDING;
	    }
	    bufPtr = nextPtr;
	}
d3232 2
a3233 2
    if (statePtr->encoding == NULL) {
	Tcl_FreeEncoding(encoding);
d3235 10
d3250 1
a3250 6
 * Tcl_Read --
 *
 *	Reads a given number of bytes from a channel.  EOL and EOF
 *	translation is done on the bytes being read, so the the number
 *	of bytes consumed from the channel may not be equal to the
 *	number of bytes stored in the destination buffer.
d3252 2
a3253 1
 *	No encoding conversions are applied to the bytes being read.
d3256 3
a3258 2
 *	The number of bytes read, or -1 on error. Use Tcl_GetErrno()
 *	to retrieve the error code for the error that occurred.
d3261 2
a3262 1
 *	May cause input to be buffered.
d3268 42
a3309 7
Tcl_Read(chan, dst, bytesToRead)
    Tcl_Channel chan;		/* The channel from which to read. */
    char *dst;			/* Where to store input read. */
    int bytesToRead;		/* Maximum number of bytes to read. */
{
    Channel *chanPtr = (Channel *) chan;		
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
d3311 1
d3313 2
a3314 1
     * This operation should occur at the top of a channel stack.
d3317 2
a3318 7
    chanPtr = statePtr->topChanPtr;

    if (CheckChannelErrors(statePtr, TCL_READABLE) != 0) {
	return -1;
    }

    return DoRead(chanPtr, dst, bytesToRead);
d3324 1
a3324 1
 * Tcl_ReadRaw --
d3326 2
a3327 6
 *	Reads a given number of bytes from a channel.  EOL and EOF
 *	translation is done on the bytes being read, so the the number
 *	of bytes consumed from the channel may not be equal to the
 *	number of bytes stored in the destination buffer.
 *
 *	No encoding conversions are applied to the bytes being read.
d3330 1
a3330 2
 *	The number of bytes read, or -1 on error. Use Tcl_GetErrno()
 *	to retrieve the error code for the error that occurred.
d3333 1
a3333 1
 *	May cause input to be buffered.
d3339 6
a3344 4
Tcl_ReadRaw(chan, bufPtr, bytesToRead)
    Tcl_Channel chan;		/* The channel from which to read. */
    char *bufPtr;			/* Where to store input read. */
    int bytesToRead;		/* Maximum number of bytes to read. */
d3346 5
a3350 4
    Channel *chanPtr = (Channel *) chan;		
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    int nread, result;
    int copied, copiedNow;
d3353 1
a3353 9
     * The check below does too much because it will reject a call to this
     * function with a channel which is part of an 'fcopy'. But we have to
     * allow this here or else the chaining in the transformation drivers
     * will fail with 'file busy' error instead of retrieving and
     * transforming the data to copy.
     *
     * We let the check procedure now believe that there is no fcopy in
     * progress. A better solution than this might be an additional flag
     * argument to switch off specific checks.
d3356 4
a3359 2
    if (CheckChannelErrors(statePtr, TCL_READABLE | CHANNEL_RAW_MODE) != 0) {
	return -1;
d3363 1
a3363 3
     * Check for information in the push-back buffers. If there is
     * some, use it. Go to the driver only if there is none (anymore)
     * and the caller requests more bytes.
d3366 4
a3369 13
    for (copied = 0; copied < bytesToRead; copied += copiedNow) {
        copiedNow = CopyBuffer(chanPtr, bufPtr + copied,
                bytesToRead - copied);
        if (copiedNow == 0) {
            if (statePtr->flags & CHANNEL_EOF) {
		goto done;
            }
            if (statePtr->flags & CHANNEL_BLOCKED) {
                if (statePtr->flags & CHANNEL_NONBLOCKING) {
		    goto done;
                }
                statePtr->flags &= (~(CHANNEL_BLOCKED));
            }
d3371 3
a3373 8
	    /*
	     * Now go to the driver to get as much as is possible to
	     * fill the remaining request. Do all the error handling
	     * by ourselves.  The code was stolen from 'GetInput' and
	     * slightly adapted (different return value here).
	     *
	     * The case of 'bytesToRead == 0' at this point cannot happen.
	     */
d3375 3
a3377 37
	    nread = (chanPtr->typePtr->inputProc)(chanPtr->instanceData,
			  bufPtr + copied, bytesToRead - copied, &result);
	    if (nread > 0) {
	        /*
		 * If we get a short read, signal up that we may be
		 * BLOCKED. We should avoid calling the driver because
		 * on some platforms we will block in the low level
		 * reading code even though the channel is set into
		 * nonblocking mode.
		 */
            
	        if (nread < (bytesToRead - copied)) {
		    statePtr->flags |= CHANNEL_BLOCKED;
		}
	    } else if (nread == 0) {
	        statePtr->flags |= CHANNEL_EOF;
		statePtr->inputEncodingFlags |= TCL_ENCODING_END;
	    } else if (nread < 0) {
	        if ((result == EWOULDBLOCK) || (result == EAGAIN)) {
		    if (copied > 0) {
		      /*
		       * Information that was copied earlier has precedence
		       * over EAGAIN/WOULDBLOCK handling.
		       */
		      return copied;
		    }

		    statePtr->flags |= CHANNEL_BLOCKED;
		    result = EAGAIN;
		}

		Tcl_SetErrno(result);
		return -1;
	    } 

	    return copied + nread;
        }
a3379 46
done:
    return copied;
}

/*
 *---------------------------------------------------------------------------
 *
 * Tcl_ReadChars --
 *
 *	Reads from the channel until the requested number of characters
 *	have been seen, EOF is seen, or the channel would block.  EOL
 *	and EOF translation is done.  If reading binary data, the raw
 *	bytes are wrapped in a Tcl byte array object.  Otherwise, the raw
 *	bytes are converted to UTF-8 using the channel's current encoding
 *	and stored in a Tcl string object.
 *
 * Results:
 *	The number of characters read, or -1 on error. Use Tcl_GetErrno()
 *	to retrieve the error code for the error that occurred.
 *
 * Side effects:
 *	May cause input to be buffered.
 *
 *---------------------------------------------------------------------------
 */
 
int
Tcl_ReadChars(chan, objPtr, toRead, appendFlag)
    Tcl_Channel chan;		/* The channel to read. */
    Tcl_Obj *objPtr;		/* Input data is stored in this object. */
    int toRead;			/* Maximum number of characters to store,
				 * or -1 to read all available data (up to EOF
				 * or when channel blocks). */
    int appendFlag;		/* If non-zero, data read from the channel
				 * will be appended to the object.  Otherwise,
				 * the data will replace the existing contents
				 * of the object. */

{
    Channel *chanPtr = (Channel *) chan;
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    ChannelBuffer *bufPtr;
    int offset, factor, copied, copiedNow, result;
    Tcl_Encoding encoding;
#define UTF_EXPANSION_FACTOR	1024
    
d3381 5
a3385 1
     * This operation should occur at the top of a channel stack.
d3388 2
a3389 5
    chanPtr = statePtr->topChanPtr;

    if (CheckChannelErrors(statePtr, TCL_READABLE) != 0) {
	copied = -1;
	goto done;
d3391 1
d3393 4
a3396 16
    encoding = statePtr->encoding;
    factor = UTF_EXPANSION_FACTOR;

    if (appendFlag == 0) {
	if (encoding == NULL) {
	    Tcl_SetByteArrayLength(objPtr, 0);
	} else {
	    Tcl_SetObjLength(objPtr, 0);
	}
	offset = 0;
    } else {
	if (encoding == NULL) {
	    Tcl_GetByteArrayFromObj(objPtr, &offset);
	} else {
	    Tcl_GetStringFromObj(objPtr, &offset);
	}
d3398 3
d3402 8
a3409 52
    for (copied = 0; (unsigned) toRead > 0; ) {
	copiedNow = -1;
	if (statePtr->inQueueHead != NULL) {
	    if (encoding == NULL) {
		copiedNow = ReadBytes(statePtr, objPtr, toRead, &offset);
	    } else {
		copiedNow = ReadChars(statePtr, objPtr, toRead, &offset,
			&factor);
	    }

	    /*
	     * If the current buffer is empty recycle it.
	     */

	    bufPtr = statePtr->inQueueHead;
	    if (bufPtr->nextRemoved == bufPtr->nextAdded) {
		ChannelBuffer *nextPtr;

		nextPtr = bufPtr->nextPtr;
		RecycleBuffer(statePtr, bufPtr, 0);
		statePtr->inQueueHead = nextPtr;
		if (nextPtr == NULL) {
		    statePtr->inQueueTail = nextPtr;
		}
	    }
	}
	if (copiedNow < 0) {
	    if (statePtr->flags & CHANNEL_EOF) {
		break;
	    }
	    if (statePtr->flags & CHANNEL_BLOCKED) {
		if (statePtr->flags & CHANNEL_NONBLOCKING) {
		    break;
		}
		statePtr->flags &= ~CHANNEL_BLOCKED;
	    }
	    result = GetInput(chanPtr);
	    if (result != 0) {
		if (result == EAGAIN) {
		    break;
		}
		copied = -1;
		goto done;
	    }
	} else {
	    copied += copiedNow;
	    toRead -= copiedNow;
	}
    }
    statePtr->flags &= ~CHANNEL_BLOCKED;
    if (encoding == NULL) {
	Tcl_SetByteArrayLength(objPtr, offset);
d3411 2
a3412 1
	Tcl_SetObjLength(objPtr, offset);
a3414 1
    done:
d3421 1
a3421 1
    return copied;
d3423 1
d3425 1
a3425 1
 *---------------------------------------------------------------------------
d3427 1
a3427 1
 * ReadBytes --
d3429 2
a3430 8
 *	Reads from the channel until the requested number of bytes have
 *	been seen, EOF is seen, or the channel would block.  Bytes from
 *	the channel are stored in objPtr as a ByteArray object.  EOL
 *	and EOF translation are done.
 *
 *	'bytesToRead' can safely be a very large number because
 *	space is only allocated to hold data read from the channel
 *	as needed.
d3433 2
a3434 4
 *	The return value is the number of bytes appended to the object
 *	and *offsetPtr is filled with the total number of bytes in the
 *	object (greater than the return value if there were already bytes
 *	in the object).
d3437 1
a3437 1
 *	None.
d3439 1
a3439 1
 *---------------------------------------------------------------------------
d3442 5
a3446 20
static int
ReadBytes(statePtr, objPtr, bytesToRead, offsetPtr)
    ChannelState *statePtr;	/* State of the channel to read. */
    int bytesToRead;		/* Maximum number of characters to store,
				 * or < 0 to get all available characters.
				 * Characters are obtained from the first
				 * buffer in the queue -- even if this number
				 * is larger than the number of characters
				 * available in the first buffer, only the
				 * characters from the first buffer are
				 * returned. */
    Tcl_Obj *objPtr;		/* Input data is appended to this ByteArray
				 * object.  Its length is how much space
				 * has been allocated to hold data, not how
				 * many bytes of data have been stored in the
				 * object. */
    int *offsetPtr;		/* On input, contains how many bytes of
				 * objPtr have been used to hold data.  On
				 * output, filled with how many bytes are now
				 * being used. */
d3448 1
a3448 1
    int toRead, srcLen, srcRead, dstWrote, offset, length;
d3450 6
a3455 1
    char *src, *dst;
d3457 1
a3457 1
    offset = *offsetPtr;
d3459 3
a3461 3
    bufPtr = statePtr->inQueueHead; 
    src = bufPtr->buf + bufPtr->nextRemoved;
    srcLen = bufPtr->nextAdded - bufPtr->nextRemoved;
d3463 4
a3466 3
    toRead = bytesToRead;
    if ((unsigned) toRead > (unsigned) srcLen) {
	toRead = srcLen;
d3469 4
a3472 7
    dst = (char *) Tcl_GetByteArrayFromObj(objPtr, &length);
    if (toRead > length - offset - 1) {
	/*
	 * Double the existing size of the object or make enough room to
	 * hold all the characters we may get from the source buffer,
	 * whichever is larger.
	 */
d3474 3
a3476 5
	length = offset * 2;
	if (offset < toRead) {
	    length = offset + toRead + 1;
	}
	dst = (char *) Tcl_SetByteArrayLength(objPtr, length);
a3477 1
    dst += offset;
d3479 3
a3481 12
    if (statePtr->flags & INPUT_NEED_NL) {
	statePtr->flags &= ~INPUT_NEED_NL;
	if ((srcLen == 0) || (*src != '\n')) {
	    *dst = '\r';
	    *offsetPtr += 1;
	    return 1;
	}
	*dst++ = '\n';
	src++;
	srcLen--;
	toRead--;
    }
d3483 3
a3485 6
    srcRead = srcLen;
    dstWrote = toRead;
    if (TranslateInputEOL(statePtr, dst, src, &dstWrote, &srcRead) != 0) {
	if (dstWrote == 0) {
	    return -1;
	}
a3486 31
    bufPtr->nextRemoved += srcRead;
    *offsetPtr += dstWrote;
    return dstWrote;
}

/*
 *---------------------------------------------------------------------------
 *
 * ReadChars --
 *
 *	Reads from the channel until the requested number of UTF-8
 *	characters have been seen, EOF is seen, or the channel would
 *	block.  Raw bytes from the channel are converted to UTF-8
 *	and stored in objPtr.  EOL and EOF translation is done.
 *
 *	'charsToRead' can safely be a very large number because
 *	space is only allocated to hold data read from the channel
 *	as needed.
 *
 * Results:
 *	The return value is the number of characters appended to
 *	the object, *offsetPtr is filled with the number of bytes that
 *	were appended, and *factorPtr is filled with the expansion
 *	factor used to guess how many bytes of UTF-8 to allocate to
 *	hold N source bytes.
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
 */
d3488 6
a3493 30
static int
ReadChars(statePtr, objPtr, charsToRead, offsetPtr, factorPtr)
    ChannelState *statePtr;	/* State of channel to read. */
    int charsToRead;		/* Maximum number of characters to store,
				 * or -1 to get all available characters.
				 * Characters are obtained from the first
				 * buffer in the queue -- even if this number
				 * is larger than the number of characters
				 * available in the first buffer, only the
				 * characters from the first buffer are
				 * returned. */
    Tcl_Obj *objPtr;		/* Input data is appended to this object.
				 * objPtr->length is how much space has been
				 * allocated to hold data, not how many bytes
				 * of data have been stored in the object. */
    int *offsetPtr;		/* On input, contains how many bytes of
				 * objPtr have been used to hold data.  On
				 * output, filled with how many bytes are now
				 * being used. */
    int *factorPtr;		/* On input, contains a guess of how many
				 * bytes need to be allocated to hold the
				 * result of converting N source bytes to
				 * UTF-8.  On output, contains another guess
				 * based on the data seen so far. */
{
    int toRead, factor, offset, spaceLeft, length;
    int srcLen, srcRead, dstNeeded, dstRead, dstWrote, numChars;
    ChannelBuffer *bufPtr;
    char *src, *dst;
    Tcl_EncodingState oldState;
d3495 1
a3495 2
    factor = *factorPtr;
    offset = *offsetPtr;
d3497 4
a3500 3
    bufPtr = statePtr->inQueueHead; 
    src = bufPtr->buf + bufPtr->nextRemoved;
    srcLen = bufPtr->nextAdded - bufPtr->nextRemoved;
d3502 3
a3504 3
    toRead = charsToRead;
    if ((unsigned) toRead > (unsigned) srcLen) {
	toRead = srcLen;
d3508 2
a3509 4
     * 'factor' is how much we guess that the bytes in the source buffer
     * will expand when converted to UTF-8 chars.  This guess comes from
     * analyzing how many characters were produced by the previous
     * pass.
d3512 9
a3520 17
    dstNeeded = toRead * factor / UTF_EXPANSION_FACTOR;
    spaceLeft = objPtr->length - offset - TCL_UTF_MAX - 1;

    if (dstNeeded > spaceLeft) {
	/*
	 * Double the existing size of the object or make enough room to
	 * hold all the characters we want from the source buffer,
	 * whichever is larger.
	 */

	length = offset * 2;
	if (offset < dstNeeded) {
	    length = offset + dstNeeded;
	}
	spaceLeft = length - offset;
	length += TCL_UTF_MAX + 1;
	Tcl_SetObjLength(objPtr, length);
d3522 5
a3526 8
    if (toRead == srcLen) {
	/*
	 * Want to convert the whole buffer in one pass.  If we have
	 * enough space, convert it using all available space in object
	 * rather than using the factor.
	 */

	dstNeeded = spaceLeft;
a3527 1
    dst = objPtr->bytes + offset;
d3529 3
a3531 26
    oldState = statePtr->inputEncodingState;
    if (statePtr->flags & INPUT_NEED_NL) {
	/*
	 * We want a '\n' because the last character we saw was '\r'.
	 */

	statePtr->flags &= ~INPUT_NEED_NL;
	Tcl_ExternalToUtf(NULL, statePtr->encoding, src, srcLen,
		statePtr->inputEncodingFlags, &statePtr->inputEncodingState,
		dst, TCL_UTF_MAX + 1, &srcRead, &dstWrote, &numChars);
	if ((dstWrote > 0) && (*dst == '\n')) {
	    /*
	     * The next char was a '\n'.  Consume it and produce a '\n'.
	     */

	    bufPtr->nextRemoved += srcRead;
	} else {
	    /*
	     * The next char was not a '\n'.  Produce a '\r'.
	     */

	    *dst = '\r';
	}
	statePtr->inputEncodingFlags &= ~TCL_ENCODING_START;
	*offsetPtr += 1;
        return 1;
d3534 4
a3537 9
    Tcl_ExternalToUtf(NULL, statePtr->encoding, src, srcLen,
	    statePtr->inputEncodingFlags, &statePtr->inputEncodingState, dst,
	    dstNeeded + TCL_UTF_MAX, &srcRead, &dstWrote, &numChars);
    if (srcRead == 0) {
	/*
	 * Not enough bytes in src buffer to make a complete char.  Copy
	 * the bytes to the next buffer to make a new contiguous string,
	 * then tell the caller to fill the buffer with more bytes.
	 */
d3539 2
a3540 19
	ChannelBuffer *nextPtr;
	
	nextPtr = bufPtr->nextPtr;
	if (nextPtr == NULL) {
	    /*
	     * There isn't enough data in the buffers to complete the next
	     * character, so we need to wait for more data before the next
	     * file event can be delivered.
	     */

	    statePtr->flags |= CHANNEL_NEED_MORE_DATA;
	    return -1;
	}
	nextPtr->nextRemoved -= srcLen;
	memcpy((VOID *) (nextPtr->buf + nextPtr->nextRemoved), (VOID *) src,
		(size_t) srcLen);
	RecycleBuffer(statePtr, bufPtr, 0);
	statePtr->inQueueHead = nextPtr;
	return ReadChars(statePtr, objPtr, charsToRead, offsetPtr, factorPtr);
a3542 17
    dstRead = dstWrote;
    if (TranslateInputEOL(statePtr, dst, dst, &dstWrote, &dstRead) != 0) {
	/*
	 * Hit EOF char.  How many bytes of src correspond to where the
	 * EOF was located in dst?
	 */
	 
	if (dstWrote == 0) {
	    return -1;
	}
	statePtr->inputEncodingState = oldState;
	Tcl_ExternalToUtf(NULL, statePtr->encoding, src, srcLen,
		statePtr->inputEncodingFlags, &statePtr->inputEncodingState,
		dst, dstRead + TCL_UTF_MAX, &srcRead, &dstWrote, &numChars);
	TranslateInputEOL(statePtr, dst, dst, &dstWrote, &dstRead);
    } 

d3544 2
a3545 3
     * The number of characters that we got may be less than the number
     * that we started with because "\r\n" sequences may have been
     * turned into just '\n' in dst.
d3548 1
a3548 1
    numChars -= (dstRead - dstWrote);
d3550 4
a3553 4
    if ((unsigned) numChars > (unsigned) toRead) {
	/*
	 * Got too many chars.
	 */
d3555 9
a3563 1
	char *eof;
d3565 16
a3580 8
	eof = Tcl_UtfAtIndex(dst, toRead);
	statePtr->inputEncodingState = oldState;
	Tcl_ExternalToUtf(NULL, statePtr->encoding, src, srcLen,
		statePtr->inputEncodingFlags, &statePtr->inputEncodingState,
		dst, eof - dst + TCL_UTF_MAX, &srcRead, &dstWrote, &numChars);
	dstRead = dstWrote;
	TranslateInputEOL(statePtr, dst, dst, &dstWrote, &dstRead);
	numChars -= (dstRead - dstWrote);
d3582 12
a3593 1
    statePtr->inputEncodingFlags &= ~TCL_ENCODING_START;
d3595 4
a3598 25
    bufPtr->nextRemoved += srcRead;
    if (dstWrote > srcRead + 1) {
	*factorPtr = dstWrote * UTF_EXPANSION_FACTOR / srcRead;
    }
    *offsetPtr += dstWrote;
    return numChars;
}

/*
 *---------------------------------------------------------------------------
 *
 * TranslateInputEOL --
 *
 *	Perform input EOL and EOF translation on the source buffer,
 *	leaving the translated result in the destination buffer.  
 *
 * Results:
 *	The return value is 1 if the EOF character was found when copying
 *	bytes to the destination buffer, 0 otherwise.  
 *
 * Side effects:
 *	None.
 *
 *---------------------------------------------------------------------------
 */
d3600 5
a3604 45
static int
TranslateInputEOL(statePtr, dstStart, srcStart, dstLenPtr, srcLenPtr)
    ChannelState *statePtr;	/* Channel being read, for EOL translation
				 * and EOF character. */
    char *dstStart;		/* Output buffer filled with chars by
				 * applying appropriate EOL translation to
				 * source characters. */
    CONST char *srcStart;	/* Source characters. */
    int *dstLenPtr;		/* On entry, the maximum length of output
				 * buffer in bytes; must be <= *srcLenPtr.  On
				 * exit, the number of bytes actually used in
				 * output buffer. */
    int *srcLenPtr;		/* On entry, the length of source buffer.
				 * On exit, the number of bytes read from
				 * the source buffer. */
{
    int dstLen, srcLen, inEofChar;
    CONST char *eof;

    dstLen = *dstLenPtr;

    eof = NULL;
    inEofChar = statePtr->inEofChar;
    if (inEofChar != '\0') {
	/*
	 * Find EOF in translated buffer then compress out the EOL.  The
	 * source buffer may be much longer than the destination buffer --
	 * we only want to return EOF if the EOF has been copied to the
	 * destination buffer.
	 */

	CONST char *src, *srcMax;

	srcMax = srcStart + *srcLenPtr;
	for (src = srcStart; src < srcMax; src++) {
	    if (*src == inEofChar) {
		eof = src;
		srcLen = src - srcStart;
		if (srcLen < dstLen) {
		    dstLen = srcLen;
		}
		*srcLenPtr = srcLen;
		break;
	    }
	}
d3606 19
a3624 88
    switch (statePtr->inputTranslation) {
	case TCL_TRANSLATE_LF: {
	    if (dstStart != srcStart) {
		memcpy((VOID *) dstStart, (VOID *) srcStart, (size_t) dstLen);
	    }
	    srcLen = dstLen;
	    break;
	}
	case TCL_TRANSLATE_CR: {
	    char *dst, *dstEnd;
	    
	    if (dstStart != srcStart) {
		memcpy((VOID *) dstStart, (VOID *) srcStart, (size_t) dstLen);
	    }
	    dstEnd = dstStart + dstLen;
	    for (dst = dstStart; dst < dstEnd; dst++) {
		if (*dst == '\r') {
		    *dst = '\n';
		}
	    }
	    srcLen = dstLen;
	    break;
	}
	case TCL_TRANSLATE_CRLF: {
	    char *dst;
	    CONST char *src, *srcEnd, *srcMax;
	    
	    dst = dstStart;
	    src = srcStart;
	    srcEnd = srcStart + dstLen;
	    srcMax = srcStart + *srcLenPtr;

	    for ( ; src < srcEnd; ) {
		if (*src == '\r') {
		    src++;
		    if (src >= srcMax) {
			statePtr->flags |= INPUT_NEED_NL;
		    } else if (*src == '\n') {
			*dst++ = *src++;
		    } else {
			*dst++ = '\r';
		    }
		} else {
		    *dst++ = *src++;
		}
	    }
	    srcLen = src - srcStart;
	    dstLen = dst - dstStart;
	    break;
	}
	case TCL_TRANSLATE_AUTO: {
	    char *dst;
	    CONST char *src, *srcEnd, *srcMax;

	    dst = dstStart;
	    src = srcStart;
	    srcEnd = srcStart + dstLen;
	    srcMax = srcStart + *srcLenPtr;

	    if ((statePtr->flags & INPUT_SAW_CR) && (src < srcMax)) {
		if (*src == '\n') {
		    src++;
		}
		statePtr->flags &= ~INPUT_SAW_CR;
	    }
	    for ( ; src < srcEnd; ) {
		if (*src == '\r') {
		    src++;
		    if (src >= srcMax) {
			statePtr->flags |= INPUT_SAW_CR;
		    } else if (*src == '\n') {
			if (srcEnd < srcMax) {
			    srcEnd++;
			}
			src++;
		    }
		    *dst++ = '\n';
		} else {
		    *dst++ = *src++;
		}
	    }
	    srcLen = src - srcStart;
	    dstLen = dst - dstStart;
	    break;
	}
	default: {		/* lint. */
	    return 0;
	}
a3625 1
    *dstLenPtr = dstLen;
d3627 1
a3627 15
    if ((eof != NULL) && (srcStart + srcLen >= eof)) {
	/*
	 * EOF character was seen in EOL translated range.  Leave current
	 * file position pointing at the EOF character, but don't store the
	 * EOF character in the output string.
	 */

	statePtr->flags |= (CHANNEL_EOF | CHANNEL_STICKY_EOF);
	statePtr->inputEncodingFlags |= TCL_ENCODING_END;
	statePtr->flags &= ~(INPUT_SAW_CR | INPUT_NEED_NL);
	return 1;
    }

    *srcLenPtr = srcLen;
    return 0;
d3633 1
a3633 1
 * Tcl_Ungets --
d3635 2
a3636 2
 *	Causes the supplied string to be added to the input queue of
 *	the channel, at either the head or tail of the queue.
d3639 3
a3641 1
 *	The number of bytes stored in the channel, or -1 on error.
d3644 1
a3644 1
 *	Adds input to the input queue of a channel.
d3650 2
a3651 6
Tcl_Ungets(chan, str, len, atEnd)
    Tcl_Channel chan;		/* The channel for which to add the input. */
    char *str;			/* The input itself. */
    int len;			/* The length of the input. */
    int atEnd;			/* If non-zero, add at end of queue; otherwise
                                 * add at head of queue. */    
d3653 5
a3657 4
    Channel *chanPtr;		/* The real IO channel. */
    ChannelState *statePtr;	/* State of actual channel. */
    ChannelBuffer *bufPtr;	/* Buffer to contain the data. */
    int i, flags;
a3659 1
    statePtr = chanPtr->state;
d3662 21
a3682 1
     * This operation should occur at the top of a channel stack.
d3685 4
a3688 1
    chanPtr = statePtr->topChanPtr;
d3691 1
a3691 1
     * CheckChannelErrors clears too many flag bits in this one case.
d3693 4
a3696 5
     
    flags = statePtr->flags;
    if (CheckChannelErrors(statePtr, TCL_READABLE) != 0) {
	len = -1;
	goto done;
a3697 1
    statePtr->flags = flags;
d3700 2
a3701 5
     * If we have encountered a sticky EOF, just punt without storing.
     * (sticky EOF is set if we have seen the input eofChar, to prevent
     * reading beyond the eofChar). Otherwise, clear the EOF flags, and
     * clear the BLOCKED bit. We want to discover these conditions anew
     * in each operation.
d3704 3
a3706 2
    if (statePtr->flags & CHANNEL_STICKY_EOF) {
	goto done;
a3707 1
    statePtr->flags &= (~(CHANNEL_BLOCKED | CHANNEL_EOF));
d3709 20
a3728 3
    bufPtr = AllocChannelBuffer(len);
    for (i = 0; i < len; i++) {
        bufPtr->buf[i] = str[i];
a3729 1
    bufPtr->nextAdded += len;
d3731 3
a3733 11
    if (statePtr->inQueueHead == (ChannelBuffer *) NULL) {
        bufPtr->nextPtr = (ChannelBuffer *) NULL;
        statePtr->inQueueHead = bufPtr;
        statePtr->inQueueTail = bufPtr;
    } else if (atEnd) {
        bufPtr->nextPtr = (ChannelBuffer *) NULL;
        statePtr->inQueueTail->nextPtr = bufPtr;
        statePtr->inQueueTail = bufPtr;
    } else {
        bufPtr->nextPtr = statePtr->inQueueHead;
        statePtr->inQueueHead = bufPtr;
a3735 1
    done:
d3737 2
a3738 2
     * Update the notifier state so we don't block while there is still
     * data in the buffers.
d3741 10
a3750 2
    UpdateInterest(chanPtr);
    return len;
d3756 1
a3756 1
 * Tcl_Flush --
d3758 1
a3758 1
 *	Flushes output data on a channel.
d3761 1
a3761 1
 *	A standard Tcl result.
d3764 1
a3764 1
 *	May flush output queued on this channel.
d3770 2
a3771 2
Tcl_Flush(chan)
    Tcl_Channel chan;			/* The Channel to flush. */
d3773 1
a3773 3
    int result;				/* Of calling FlushChannel. */
    Channel *chanPtr  = (Channel *) chan;	/* The actual channel. */
    ChannelState *statePtr = chanPtr->state;	/* State of actual channel. */
d3775 4
a3778 25
    /*
     * This operation should occur at the top of a channel stack.
     */

    chanPtr = statePtr->topChanPtr;

    if (CheckChannelErrors(statePtr, TCL_WRITABLE) != 0) {
	return -1;
    }

    /*
     * Force current output buffer to be output also.
     */

    if ((statePtr->curOutPtr != NULL)
	    && (statePtr->curOutPtr->nextAdded > 0)) {
        statePtr->flags |= BUFFER_READY;
    }
    
    result = FlushChannel(NULL, chanPtr, 0);
    if (result != 0) {
        return TCL_ERROR;
    }

    return TCL_OK;
d3784 1
a3784 1
 * DiscardInputQueued --
d3786 1
a3786 2
 *	Discards any input read from the channel but not yet consumed
 *	by Tcl reading commands.
d3789 1
a3789 1
 *	None.
d3792 1
a3792 2
 *	May discard input from the channel. If discardLastBuffer is zero,
 *	leaves one buffer in place for back-filling.
d3797 3
a3799 6
static void
DiscardInputQueued(statePtr, discardSavedBuffers)
    ChannelState *statePtr;	/* Channel on which to discard
                                 * the queued input. */
    int discardSavedBuffers;	/* If non-zero, discard all buffers including
                                 * last one. */
d3801 1
a3801 1
    ChannelBuffer *bufPtr, *nxtPtr;	/* Loop variables. */
d3803 2
a3804 19
    bufPtr = statePtr->inQueueHead;
    statePtr->inQueueHead = (ChannelBuffer *) NULL;
    statePtr->inQueueTail = (ChannelBuffer *) NULL;
    for (; bufPtr != (ChannelBuffer *) NULL; bufPtr = nxtPtr) {
        nxtPtr = bufPtr->nextPtr;
        RecycleBuffer(statePtr, bufPtr, discardSavedBuffers);
    }

    /*
     * If discardSavedBuffers is nonzero, must also discard any previously
     * saved buffer in the saveInBufPtr field.
     */
    
    if (discardSavedBuffers) {
        if (statePtr->saveInBufPtr != (ChannelBuffer *) NULL) {
            ckfree((char *) statePtr->saveInBufPtr);
            statePtr->saveInBufPtr = (ChannelBuffer *) NULL;
        }
    }
d3808 1
a3808 1
 *---------------------------------------------------------------------------
d3810 1
a3810 1
 * GetInput --
d3812 2
a3813 1
 *	Reads input data from a device into a channel buffer.  
d3816 2
a3817 2
 *	The return value is the Posix error code if an error occurred while
 *	reading from the file, or 0 otherwise.  
d3820 1
a3820 1
 *	Reads from the underlying device.
d3822 1
a3822 1
 *---------------------------------------------------------------------------
d3825 39
a3863 3
static int
GetInput(chanPtr)
    Channel *chanPtr;		/* Channel to read input from. */
d3865 2
a3866 6
    int toRead;			/* How much to read? */
    int result;			/* Of calling driver. */
    int nread;			/* How much was read from channel? */
    ChannelBuffer *bufPtr;	/* New buffer to add to input queue. */
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */

d3868 2
a3869 4
     * Prevent reading from a dead channel -- a channel that has been closed
     * but not yet deallocated, which can happen if the exit handler for
     * channel cleanup has run but the channel is still registered in some
     * interpreter.
d3872 5
a3876 2
    if (CheckForDeadChannel(NULL, statePtr)) {
	return EINVAL;
d3879 19
a3897 9
    /*
     * First check for more buffers in the pushback area of the
     * topmost channel in the stack and use them. They can be the
     * result of a transformation which went away without reading all
     * the information placed in the area when it was stacked.
     *
     * Two possibilities for the state: No buffers in it, or a single
     * empty buffer. In the latter case we can recycle it now.
     */
d3899 6
a3904 5
    if (chanPtr->inQueueHead != (ChannelBuffer*) NULL) {
        if (statePtr->inQueueHead != (ChannelBuffer*) NULL) {
	    RecycleBuffer(statePtr, statePtr->inQueueHead, 0);
	    statePtr->inQueueHead = (ChannelBuffer*) NULL;
	}
d3906 31
a3936 6
	statePtr->inQueueHead = chanPtr->inQueueHead;
	statePtr->inQueueTail = chanPtr->inQueueTail;
	chanPtr->inQueueHead  = (ChannelBuffer*) NULL;
	chanPtr->inQueueTail  = (ChannelBuffer*) NULL;
	return 0;
    }
d3938 16
a3953 4
    /*
     * Nothing in the pushback area, fall back to the usual handling
     * (driver, etc.)
     */
d3955 5
a3959 14
    /*
     * See if we can fill an existing buffer. If we can, read only
     * as much as will fit in it. Otherwise allocate a new buffer,
     * add it to the input queue and attempt to fill it to the max.
     */

    bufPtr = statePtr->inQueueTail;
    if ((bufPtr != NULL) && (bufPtr->nextAdded < bufPtr->bufLength)) {
        toRead = bufPtr->bufLength - bufPtr->nextAdded;
    } else {
	bufPtr = statePtr->saveInBufPtr;
	statePtr->saveInBufPtr = NULL;
	if (bufPtr == NULL) {
	    bufPtr = AllocChannelBuffer(statePtr->bufSize);
d3961 3
a3963 35
        bufPtr->nextPtr = (ChannelBuffer *) NULL;

        toRead = statePtr->bufSize;
        if (statePtr->inQueueTail == NULL) {
            statePtr->inQueueHead = bufPtr;
        } else {
            statePtr->inQueueTail->nextPtr = bufPtr;
        }
        statePtr->inQueueTail = bufPtr;
    }
      
    /*
     * If EOF is set, we should avoid calling the driver because on some
     * platforms it is impossible to read from a device after EOF.
     */

    if (statePtr->flags & CHANNEL_EOF) {
	return 0;
    }

    nread = (chanPtr->typePtr->inputProc)(chanPtr->instanceData,
	    bufPtr->buf + bufPtr->nextAdded, toRead, &result);

    if (nread > 0) {
	bufPtr->nextAdded += nread;

	/*
	 * If we get a short read, signal up that we may be BLOCKED. We
	 * should avoid calling the driver because on some platforms we
	 * will block in the low level reading code even though the
	 * channel is set into nonblocking mode.
	 */
            
	if (nread < toRead) {
	    statePtr->flags |= CHANNEL_BLOCKED;
d3965 6
a3970 7
    } else if (nread == 0) {
	statePtr->flags |= CHANNEL_EOF;
	statePtr->inputEncodingFlags |= TCL_ENCODING_END;
    } else if (nread < 0) {
	if ((result == EWOULDBLOCK) || (result == EAGAIN)) {
	    statePtr->flags |= CHANNEL_BLOCKED;
	    result = EAGAIN;
d3972 6
a3977 4
	Tcl_SetErrno(result);
	return result;
    } 
    return 0;
d3983 1
a3983 1
 * Tcl_Seek --
d3985 4
a3988 2
 *	Implements seeking on Tcl Channels. This is a public function
 *	so that other C facilities may be implemented on top of it.
d3991 2
a3992 2
 *	The new access point or -1 on error. If error, use Tcl_GetErrno()
 *	to retrieve the POSIX error code for the error that occurred.
d3995 1
a3995 1
 *	May flush output on the channel. May discard queued input.
d4001 5
a4005 4
Tcl_Seek(chan, offset, mode)
    Tcl_Channel chan;		/* The channel on which to seek. */
    int offset;			/* Offset to seek to. */
    int mode;			/* Relative to which location to seek? */
d4007 8
a4014 9
    Channel *chanPtr = (Channel *) chan;	/* The real IO channel. */
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    ChannelBuffer *bufPtr;
    int inputBuffered, outputBuffered;
    int result;			/* Of device driver operations. */
    int curPos;			/* Position on the device. */
    int wasAsync;		/* Was the channel nonblocking before the
                                 * seek operation? If so, must restore to
                                 * nonblocking mode after the seek. */
d4016 8
a4023 2
    if (CheckChannelErrors(statePtr, TCL_WRITABLE | TCL_READABLE) != 0) {
	return -1;
d4027 1
a4027 1
     * Disallow seek on dead channels -- channels that have been closed but
d4033 1
a4033 1
    if (CheckForDeadChannel(NULL, statePtr)) return -1;
d4036 2
a4037 1
     * This operation should occur at the top of a channel stack.
d4039 5
a4043 11

    chanPtr = statePtr->topChanPtr;

    /*
     * Disallow seek on channels whose type does not have a seek procedure
     * defined. This means that the channel does not support seeking.
     */

    if (chanPtr->typePtr->seekProc == (Tcl_DriverSeekProc *) NULL) {
        Tcl_SetErrno(EINVAL);
        return -1;
d4045 11
a4055 10

    /*
     * Compute how much input and output is buffered. If both input and
     * output is buffered, cannot compute the current position.
     */

    for (bufPtr = statePtr->inQueueHead, inputBuffered = 0;
	 bufPtr != (ChannelBuffer *) NULL;
	 bufPtr = bufPtr->nextPtr) {
        inputBuffered += (bufPtr->nextAdded - bufPtr->nextRemoved);
d4057 15
a4071 9

    /*
     * Don't forget the bytes in the topmost pushback area.
     */

    for (bufPtr = statePtr->topChanPtr->inQueueHead;
	 bufPtr != (ChannelBuffer *) NULL;
	 bufPtr = bufPtr->nextPtr) {
        inputBuffered += (bufPtr->nextAdded - bufPtr->nextRemoved);
d4073 10
a4082 11

    for (bufPtr = statePtr->outQueueHead, outputBuffered = 0;
	 bufPtr != (ChannelBuffer *) NULL;
	 bufPtr = bufPtr->nextPtr) {
        outputBuffered += (bufPtr->nextAdded - bufPtr->nextRemoved);
    }
    if ((statePtr->curOutPtr != (ChannelBuffer *) NULL) &&
	    (statePtr->curOutPtr->nextAdded > statePtr->curOutPtr->nextRemoved)) {
        statePtr->flags |= BUFFER_READY;
        outputBuffered +=
            (statePtr->curOutPtr->nextAdded - statePtr->curOutPtr->nextRemoved);
d4084 15
d4100 9
a4108 4
    if ((inputBuffered != 0) && (outputBuffered != 0)) {
        Tcl_SetErrno(EFAULT);
        return -1;
    }
d4110 11
a4120 7
    /*
     * If we are seeking relative to the current position, compute the
     * corrected offset taking into account the amount of unread input.
     */

    if (mode == SEEK_CUR) {
        offset -= inputBuffered;
d4122 38
a4159 33

    /*
     * Discard any queued input - this input should not be read after
     * the seek.
     */

    DiscardInputQueued(statePtr, 0);

    /*
     * Reset EOF and BLOCKED flags. We invalidate them by moving the
     * access point. Also clear CR related flags.
     */

    statePtr->flags &=
        (~(CHANNEL_EOF | CHANNEL_STICKY_EOF | CHANNEL_BLOCKED | INPUT_SAW_CR));
    
    /*
     * If the channel is in asynchronous output mode, switch it back
     * to synchronous mode and cancel any async flush that may be
     * scheduled. After the flush, the channel will be put back into
     * asynchronous output mode.
     */

    wasAsync = 0;
    if (statePtr->flags & CHANNEL_NONBLOCKING) {
        wasAsync = 1;
        result = StackSetBlockMode(chanPtr, TCL_MODE_BLOCKING);
	if (result != 0) {
	    return -1;
	}
        statePtr->flags &= (~(CHANNEL_NONBLOCKING));
        if (statePtr->flags & BG_FLUSH_SCHEDULED) {
            statePtr->flags &= (~(BG_FLUSH_SCHEDULED));
d4162 8
a4169 11
    
    /*
     * If the flush fails we cannot recover the original position. In
     * that case the seek is not attempted because we do not know where
     * the access position is - instead we return the error. FlushChannel
     * has already called Tcl_SetErrno() to report the error upwards.
     * If the flush succeeds we do the seek also.
     */
    
    if (FlushChannel(NULL, chanPtr, 0) != 0) {
        curPos = -1;
d4171 3
d4175 2
a4176 9
        /*
         * Now seek to the new position in the channel as requested by the
         * caller.
         */

        curPos = (chanPtr->typePtr->seekProc) (chanPtr->instanceData,
                (long) offset, mode, &result);
        if (curPos == -1) {
            Tcl_SetErrno(result);
d4178 1
a4179 17
    
    /*
     * Restore to nonblocking mode if that was the previous behavior.
     *
     * NOTE: Even if there was an async flush active we do not restore
     * it now because we already flushed all the queued output, above.
     */
    
    if (wasAsync) {
        statePtr->flags |= CHANNEL_NONBLOCKING;
        result = StackSetBlockMode(chanPtr, TCL_MODE_NONBLOCKING);
	if (result != 0) {
	    return -1;
	}
    }

    return curPos;
d4185 1
a4185 1
 * Tcl_Tell --
d4187 1
a4187 2
 *	Returns the position of the next character to be read/written on
 *	this channel.
d4190 2
a4191 3
 *	A nonnegative integer on success, -1 on failure. If failed,
 *	use Tcl_GetErrno() to retrieve the POSIX error code for the
 *	error that occurred.
d4194 1
a4194 1
 *	None.
d4200 5
a4204 2
Tcl_Tell(chan)
    Tcl_Channel chan;			/* The channel to return pos for. */
d4206 11
a4216 6
    Channel *chanPtr = (Channel *) chan;	/* The real IO channel. */
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    ChannelBuffer *bufPtr;
    int inputBuffered, outputBuffered;
    int result;				/* Of calling device driver. */
    int curPos;				/* Position on device. */
d4218 7
a4224 2
    if (CheckChannelErrors(statePtr, TCL_WRITABLE | TCL_READABLE) != 0) {
	return -1;
d4227 1
d4229 1
a4229 1
     * Disallow tell on dead channels -- channels that have been closed but
d4235 3
a4237 3
    if (CheckForDeadChannel(NULL, statePtr)) {
	return -1;
    }
d4239 11
a4249 14
    /*
     * This operation should occur at the top of a channel stack.
     */

    chanPtr = statePtr->topChanPtr;

    /*
     * Disallow tell on channels whose type does not have a seek procedure
     * defined. This means that the channel does not support seeking.
     */

    if (chanPtr->typePtr->seekProc == (Tcl_DriverSeekProc *) NULL) {
        Tcl_SetErrno(EINVAL);
        return -1;
d4252 24
a4275 4
    /*
     * Compute how much input and output is buffered. If both input and
     * output is buffered, cannot compute the current position.
     */
d4277 7
a4283 4
    for (bufPtr = statePtr->inQueueHead, inputBuffered = 0;
	 bufPtr != (ChannelBuffer *) NULL;
	 bufPtr = bufPtr->nextPtr) {
        inputBuffered += (bufPtr->nextAdded - bufPtr->nextRemoved);
d4285 36
a4320 4
    for (bufPtr = statePtr->outQueueHead, outputBuffered = 0;
	 bufPtr != (ChannelBuffer *) NULL;
	 bufPtr = bufPtr->nextPtr) {
        outputBuffered += (bufPtr->nextAdded - bufPtr->nextRemoved);
d4322 105
a4426 5
    if ((statePtr->curOutPtr != (ChannelBuffer *) NULL) &&
	    (statePtr->curOutPtr->nextAdded > statePtr->curOutPtr->nextRemoved)) {
        statePtr->flags |= BUFFER_READY;
        outputBuffered +=
            (statePtr->curOutPtr->nextAdded - statePtr->curOutPtr->nextRemoved);
d4429 3
a4431 3
    if ((inputBuffered != 0) && (outputBuffered != 0)) {
        Tcl_SetErrno(EFAULT);
        return -1;
d4433 30
d4465 2
a4466 2
     * Get the current position in the device and compute the position
     * where the next character will be read or written.
d4468 15
d4484 5
a4488 8
    curPos = (chanPtr->typePtr->seekProc) (chanPtr->instanceData,
            (long) 0, SEEK_CUR, &result);
    if (curPos == -1) {
        Tcl_SetErrno(result);
        return -1;
    }
    if (inputBuffered != 0) {
        return (curPos - inputBuffered);
a4489 1
    return (curPos + outputBuffered);
d4493 1
a4493 1
 *---------------------------------------------------------------------------
d4495 1
a4495 1
 * CheckChannelErrors --
d4497 4
a4500 2
 *	See if the channel is in an ready state and can perform the
 *	desired operation.
d4503 1
a4503 2
 *	The return value is 0 if the channel is OK, otherwise the
 *	return value is -1 and errno is set to indicate the error.
d4506 1
a4506 1
 *	May clear the EOF and/or BLOCKED bits if reading from channel.
d4508 1
a4508 1
 *---------------------------------------------------------------------------
d4510 7
a4516 8
 
static int
CheckChannelErrors(statePtr, flags)
    ChannelState *statePtr;	/* Channel to check. */
    int flags;			/* Test if channel supports desired operation:
				 * TCL_READABLE, TCL_WRITABLE.  Also indicates
				 * Raw read or write for special close
				 * processing*/
d4518 3
a4520 1
    int direction = flags & (TCL_READABLE|TCL_WRITABLE);
d4523 1
a4523 1
     * Check for unreported error.
d4525 2
a4526 6

    if (statePtr->unreportedError != 0) {
        Tcl_SetErrno(statePtr->unreportedError);
        statePtr->unreportedError = 0;
        return -1;
    }
d4529 4
a4532 2
     * Only the raw read and write operations are allowed during close
     * in order to drain data from stacked channels.
d4535 3
a4537 4
    if ((statePtr->flags & CHANNEL_CLOSED) &&
	    ((flags & CHANNEL_RAW_MODE) == 0)) {
        Tcl_SetErrno(EACCES);
        return -1;
d4541 2
a4542 1
     * Fail if the channel is not opened for desired operation.
d4544 6
d4551 12
a4562 3
    if ((statePtr->flags & direction) == 0) {
        Tcl_SetErrno(EACCES);
        return -1;
d4566 2
a4567 5
     * Fail if the channel is in the middle of a background copy.
     *
     * Don't do this tests for raw channels here or else the chaining in the
     * transformation drivers will fail with 'file busy' error instead of
     * retrieving and transforming the data to copy.
d4570 2
a4571 3
    if ((statePtr->csPtr != NULL) && ((flags & CHANNEL_RAW_MODE) == 0)) {
	Tcl_SetErrno(EBUSY);
	return -1;
d4574 1
a4574 13
    if (direction == TCL_READABLE) {
	/*
	 * If we have not encountered a sticky EOF, clear the EOF bit
	 * (sticky EOF is set if we have seen the input eofChar, to prevent
	 * reading beyond the eofChar). Also, always clear the BLOCKED bit.
	 * We want to discover these conditions anew in each operation.
	 */
	
	if ((statePtr->flags & CHANNEL_STICKY_EOF) == 0) {
	    statePtr->flags &= ~CHANNEL_EOF;
	}
	statePtr->flags &= ~(CHANNEL_BLOCKED | CHANNEL_NEED_MORE_DATA);
    }
d4576 1
a4576 1
    return 0;
d4582 1
a4582 1
 * Tcl_Eof --
d4584 2
a4585 1
 *	Returns 1 if the channel is at EOF, 0 otherwise.
d4588 1
a4588 1
 *	1 or 0, always.
d4591 1
a4591 1
 *	None.
d4596 3
a4598 3
int
Tcl_Eof(chan)
    Tcl_Channel chan;			/* Does this channel have EOF? */
d4600 6
a4605 2
    ChannelState *statePtr = ((Channel *) chan)->state;
					/* State of real channel structure. */
d4607 24
a4630 3
    return ((statePtr->flags & CHANNEL_STICKY_EOF) ||
            ((statePtr->flags & CHANNEL_EOF) &&
		    (Tcl_InputBuffered(chan) == 0))) ? 1 : 0;
d4636 1
a4636 1
 * Tcl_InputBlocked --
d4638 2
a4639 1
 *	Returns 1 if input is blocked on this channel, 0 otherwise.
d4642 1
a4642 1
 *	0 or 1, always.
d4645 1
a4645 1
 *	None.
d4650 3
a4652 3
int
Tcl_InputBlocked(chan)
    Tcl_Channel chan;			/* Is this channel blocked? */
d4654 11
a4664 2
    ChannelState *statePtr = ((Channel *) chan)->state;
					/* State of real channel structure. */
d4666 8
a4673 1
    return (statePtr->flags & CHANNEL_BLOCKED) ? 1 : 0;
d4679 1
a4679 1
 * Tcl_InputBuffered --
d4681 3
a4683 2
 *	Returns the number of bytes of input currently buffered in the
 *	common internal buffer of a channel.
d4686 1
a4686 2
 *	The number of input bytes buffered, or zero if the channel is not
 *	open for reading.
d4689 5
a4693 1
 *	None.
d4698 11
a4708 3
int
Tcl_InputBuffered(chan)
    Tcl_Channel chan;			/* The channel to query. */
d4710 10
a4719 4
    ChannelState *statePtr = ((Channel *) chan)->state;
					/* State of real channel structure. */
    ChannelBuffer *bufPtr;
    int bytesBuffered;
d4721 16
a4736 4
    for (bytesBuffered = 0, bufPtr = statePtr->inQueueHead;
	 bufPtr != (ChannelBuffer *) NULL;
	 bufPtr = bufPtr->nextPtr) {
        bytesBuffered += (bufPtr->nextAdded - bufPtr->nextRemoved);
d4740 3
a4742 1
     * Don't forget the bytes in the topmost pushback area.
d4745 12
a4756 4
    for (bufPtr = statePtr->topChanPtr->inQueueHead;
	 bufPtr != (ChannelBuffer *) NULL;
	 bufPtr = bufPtr->nextPtr) {
        bytesBuffered += (bufPtr->nextAdded - bufPtr->nextRemoved);
d4759 1
a4759 1
    return bytesBuffered;
d4765 1
a4765 1
 * Tcl_ChannelBuffered --
d4767 2
a4768 2
 *	Returns the number of bytes of input currently buffered in the
 *	internal buffer (push back area) of a channel.
d4771 1
a4771 2
 *	The number of input bytes buffered, or zero if the channel is not
 *	open for reading.
d4774 3
a4776 1
 *	None.
d4781 8
a4788 3
int
Tcl_ChannelBuffered(chan)
    Tcl_Channel chan;			/* The channel to query. */
d4790 56
a4845 4
    Channel *chanPtr = (Channel *) chan;
					/* real channel structure. */
    ChannelBuffer *bufPtr;
    int bytesBuffered;
d4847 5
a4851 4
    for (bytesBuffered = 0, bufPtr = chanPtr->inQueueHead;
	 bufPtr != (ChannelBuffer *) NULL;
	 bufPtr = bufPtr->nextPtr) {
        bytesBuffered += (bufPtr->nextAdded - bufPtr->nextRemoved);
d4854 1
a4854 1
    return bytesBuffered;
d4860 1
a4860 1
 * Tcl_SetChannelBufferSize --
d4862 2
a4863 2
 *	Sets the size of buffers to allocate to store input or output
 *	in the channel. The size must be between 10 bytes and 1 MByte.
d4869 1
a4869 1
 *	Sets the size of buffers subsequently allocated for this channel.
d4874 8
a4881 5
void
Tcl_SetChannelBufferSize(chan, sz)
    Tcl_Channel chan;			/* The channel whose buffer size
                                         * to set. */
    int sz;				/* The size to set. */
d4883 12
a4894 13
    ChannelState *statePtr;		/* State of real channel structure. */
    
    /*
     * If the buffer size is smaller than 10 bytes or larger than one MByte,
     * do not accept the requested size and leave the current buffer size.
     */
    
    if (sz < 10) {
        return;
    }
    if (sz > (1024 * 1024)) {
        return;
    }
d4896 5
a4900 2
    statePtr = ((Channel *) chan)->state;
    statePtr->bufSize = sz;
d4902 2
a4903 7
    if (statePtr->outputStage != NULL) {
	ckfree((char *) statePtr->outputStage);
	statePtr->outputStage = NULL;
    }
    if ((statePtr->encoding != NULL) && (statePtr->flags & TCL_WRITABLE)) {
	statePtr->outputStage = (char *)
	    ckalloc((unsigned) (statePtr->bufSize + 2));
d4910 1
a4910 1
 * Tcl_GetChannelBufferSize --
d4912 2
a4913 1
 *	Retrieves the size of buffers to allocate for this channel.
d4916 1
a4916 1
 *	The size.
d4919 1
a4919 1
 *	None.
d4924 10
a4933 4
int
Tcl_GetChannelBufferSize(chan)
    Tcl_Channel chan;		/* The channel for which to find the
                                 * buffer size. */
d4935 1
a4935 2
    ChannelState *statePtr = ((Channel *) chan)->state;
					/* State of real channel structure. */
d4937 22
a4958 1
    return statePtr->bufSize;
d4964 1
a4964 1
 * Tcl_BadChannelOption --
d4966 3
a4968 5
 *	This procedure generates a "bad option" error message in an
 *	(optional) interpreter.  It is used by channel drivers when 
 *      a invalid Set/Get option is requested. Its purpose is to concatenate
 *      the generic options list to the specific ones and factorize
 *      the generic options error message string.
d4971 1
a4971 1
 *	TCL_ERROR.
d4974 1
a4974 9
 *	An error message is generated in interp's result object to
 *	indicate that a command was invoked with the a bad option
 *	The message has the form
 *		bad option "blah": should be one of 
 *              <...generic options...>+<...specific options...>
 *	"blah" is the optionName argument and "<specific options>"
 *	is a space separated list of specific option words.
 *      The function takes good care of inserting minus signs before
 *      each option, commas after, and an "or" before the last option.
d4979 4
a4982 9
int
Tcl_BadChannelOption(interp, optionName, optionList)
    Tcl_Interp *interp;			/* Current interpreter. (can be NULL)*/
    char *optionName;			/* 'bad option' name */
    char *optionList;			/* Specific options list to append 
					 * to the standard generic options.
					 * can be NULL for generic options 
					 * only.
					 */
d4984 23
a5006 6
    if (interp) {
	CONST char *genericopt = 
	    "blocking buffering buffersize encoding eofchar translation";
	char **argv;
	int  argc, i;
	Tcl_DString ds;
d5008 11
a5018 5
	Tcl_DStringInit(&ds);
	Tcl_DStringAppend(&ds, (char *) genericopt, -1);
	if (optionList && (*optionList)) {
	    Tcl_DStringAppend(&ds, " ", 1);
	    Tcl_DStringAppend(&ds, optionList, -1);
d5020 1
a5020 14
	if (Tcl_SplitList(interp, Tcl_DStringValue(&ds), 
		&argc, &argv) != TCL_OK) {
	    panic("malformed option list in channel driver");
	}
	Tcl_ResetResult(interp);
	Tcl_AppendResult(interp, "bad option \"", optionName, 
		"\": should be one of ", (char *) NULL);
	argc--;
	for (i = 0; i < argc; i++) {
	    Tcl_AppendResult(interp, "-", argv[i], ", ", (char *) NULL);
	}
	Tcl_AppendResult(interp, "or -", argv[i], (char *) NULL);
	Tcl_DStringFree(&ds);
	ckfree((char *) argv);
d5022 1
a5022 2
    Tcl_SetErrno(EINVAL);
    return TCL_ERROR;
d5028 1
a5028 1
 * Tcl_GetChannelOption --
d5030 4
a5033 4
 *	Gets a mode associated with an IO channel. If the optionName arg
 *	is non NULL, retrieves the value of that option. If the optionName
 *	arg is NULL, retrieves a list of alternating option names and
 *	values for the given channel.
d5036 1
a5036 2
 *	A standard Tcl result. Also sets the supplied DString to the
 *	string value of the option(s) returned.
d5039 1
a5039 1
 *      None.
d5044 1
d5046 7
a5052 5
Tcl_GetChannelOption(interp, chan, optionName, dsPtr)
    Tcl_Interp *interp;		/* For error reporting - can be NULL. */
    Tcl_Channel chan;		/* Channel on which to get option. */
    char *optionName;		/* Option to get. */
    Tcl_DString *dsPtr;		/* Where to store value(s). */
d5054 6
a5059 5
    size_t len;			/* Length of optionName string. */
    char optionVal[128];	/* Buffer for sprintf. */
    Channel *chanPtr = (Channel *) chan;
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    int flags;
d5062 1
a5062 4
     * Disallow options on dead channels -- channels that have been closed but
     * not yet been deallocated. Such channels can be found if the exit
     * handler for channel cleanup has run but the channel is still
     * registered in an interpreter.
d5065 14
a5078 1
    if (CheckForDeadChannel(interp, statePtr)) {
d5081 13
a5093 1

d5095 1
a5095 1
     * This operation should occur at the top of a channel stack.
d5098 12
a5109 1
    chanPtr = statePtr->topChanPtr;
d5112 1
a5112 1
     * If we are in the middle of a background copy, use the saved flags.
d5115 3
a5117 8
    if (statePtr->csPtr) {
	if (chanPtr == statePtr->csPtr->readPtr) {
	    flags = statePtr->csPtr->readFlags;
	} else {
	    flags = statePtr->csPtr->writeFlags;
	}
    } else {
	flags = statePtr->flags;
d5121 3
a5123 2
     * If the optionName is NULL it means that we want a list of all
     * options and values.
d5125 2
d5128 56
a5183 4
    if (optionName == (char *) NULL) {
        len = 0;
    } else {
        len = strlen(optionName);
d5186 12
a5197 4
    if ((len == 0) || ((len > 2) && (optionName[1] == 'b') &&
            (strncmp(optionName, "-blocking", len) == 0))) {
        if (len == 0) {
            Tcl_DStringAppendElement(dsPtr, "-blocking");
d5199 4
a5202 4
        Tcl_DStringAppendElement(dsPtr,
		(flags & CHANNEL_NONBLOCKING) ? "0" : "1");
        if (len > 0) {
            return TCL_OK;
d5204 4
a5207 5
    }
    if ((len == 0) || ((len > 7) && (optionName[1] == 'b') &&
            (strncmp(optionName, "-buffering", len) == 0))) {
        if (len == 0) {
            Tcl_DStringAppendElement(dsPtr, "-buffering");
d5209 4
a5212 4
        if (flags & CHANNEL_LINEBUFFERED) {
            Tcl_DStringAppendElement(dsPtr, "line");
        } else if (flags & CHANNEL_UNBUFFERED) {
            Tcl_DStringAppendElement(dsPtr, "none");
d5214 1
a5214 1
            Tcl_DStringAppendElement(dsPtr, "full");
d5216 4
a5219 2
        if (len > 0) {
            return TCL_OK;
d5221 4
a5224 5
    }
    if ((len == 0) || ((len > 7) && (optionName[1] == 'b') &&
            (strncmp(optionName, "-buffersize", len) == 0))) {
        if (len == 0) {
            Tcl_DStringAppendElement(dsPtr, "-buffersize");
d5226 4
a5229 4
        TclFormatInt(optionVal, statePtr->bufSize);
        Tcl_DStringAppendElement(dsPtr, optionVal);
        if (len > 0) {
            return TCL_OK;
d5231 58
d5290 17
a5306 15
    if ((len == 0) ||
	    ((len > 2) && (optionName[1] == 'e') &&
		    (strncmp(optionName, "-encoding", len) == 0))) {
	if (len == 0) {
	    Tcl_DStringAppendElement(dsPtr, "-encoding");
	}
	if (statePtr->encoding == NULL) {
	    Tcl_DStringAppendElement(dsPtr, "binary");
	} else {
	    Tcl_DStringAppendElement(dsPtr,
		    Tcl_GetEncodingName(statePtr->encoding));
	}
	if (len > 0) {
	    return TCL_OK;
	}
d5308 6
a5313 5
    if ((len == 0) ||
            ((len > 2) && (optionName[1] == 'e') &&
                    (strncmp(optionName, "-eofchar", len) == 0))) {
        if (len == 0) {
            Tcl_DStringAppendElement(dsPtr, "-eofchar");
d5315 5
a5319 3
        if (((flags & (TCL_READABLE|TCL_WRITABLE)) ==
                (TCL_READABLE|TCL_WRITABLE)) && (len == 0)) {
            Tcl_DStringStartSublist(dsPtr);
d5321 4
a5324 9
        if (flags & TCL_READABLE) {
            if (statePtr->inEofChar == 0) {
                Tcl_DStringAppendElement(dsPtr, "");
            } else {
                char buf[4];

                sprintf(buf, "%c", statePtr->inEofChar);
                Tcl_DStringAppendElement(dsPtr, buf);
            }
d5326 8
a5333 9
        if (flags & TCL_WRITABLE) {
            if (statePtr->outEofChar == 0) {
                Tcl_DStringAppendElement(dsPtr, "");
            } else {
                char buf[4];

                sprintf(buf, "%c", statePtr->outEofChar);
                Tcl_DStringAppendElement(dsPtr, buf);
            }
d5335 8
a5342 3
        if (((flags & (TCL_READABLE|TCL_WRITABLE)) ==
                (TCL_READABLE|TCL_WRITABLE)) && (len == 0)) {
            Tcl_DStringEndSublist(dsPtr);
d5344 4
a5347 2
        if (len > 0) {
            return TCL_OK;
d5349 1
d5351 18
a5368 5
    if ((len == 0) ||
            ((len > 1) && (optionName[1] == 't') &&
                    (strncmp(optionName, "-translation", len) == 0))) {
        if (len == 0) {
            Tcl_DStringAppendElement(dsPtr, "-translation");
d5370 11
a5380 3
        if (((flags & (TCL_READABLE|TCL_WRITABLE)) ==
                (TCL_READABLE|TCL_WRITABLE)) && (len == 0)) {
            Tcl_DStringStartSublist(dsPtr);
d5382 11
a5392 10
        if (flags & TCL_READABLE) {
            if (statePtr->inputTranslation == TCL_TRANSLATE_AUTO) {
                Tcl_DStringAppendElement(dsPtr, "auto");
            } else if (statePtr->inputTranslation == TCL_TRANSLATE_CR) {
                Tcl_DStringAppendElement(dsPtr, "cr");
            } else if (statePtr->inputTranslation == TCL_TRANSLATE_CRLF) {
                Tcl_DStringAppendElement(dsPtr, "crlf");
            } else {
                Tcl_DStringAppendElement(dsPtr, "lf");
            }
d5394 6
a5399 9
        if (flags & TCL_WRITABLE) {
            if (statePtr->outputTranslation == TCL_TRANSLATE_AUTO) {
                Tcl_DStringAppendElement(dsPtr, "auto");
            } else if (statePtr->outputTranslation == TCL_TRANSLATE_CR) {
                Tcl_DStringAppendElement(dsPtr, "cr");
            } else if (statePtr->outputTranslation == TCL_TRANSLATE_CRLF) {
                Tcl_DStringAppendElement(dsPtr, "crlf");
            } else {
                Tcl_DStringAppendElement(dsPtr, "lf");
d5402 8
a5409 3
        if (((flags & (TCL_READABLE|TCL_WRITABLE)) ==
                (TCL_READABLE|TCL_WRITABLE)) && (len == 0)) {
            Tcl_DStringEndSublist(dsPtr);
d5411 11
a5421 2
        if (len > 0) {
            return TCL_OK;
d5423 2
d5426 4
a5429 14
    if (chanPtr->typePtr->getOptionProc != (Tcl_DriverGetOptionProc *) NULL) {
	/*
	 * let the driver specific handle additional options
	 * and result code and message.
	 */

        return (chanPtr->typePtr->getOptionProc) (chanPtr->instanceData,
		interp, optionName, dsPtr);
    } else {
	/*
	 * no driver specific options case.
	 */

        if (len == 0) {
d5432 9
a5440 1
	return Tcl_BadChannelOption(interp, optionName, NULL);
d5442 5
d5450 1
a5450 1
 *---------------------------------------------------------------------------
d5452 1
a5452 1
 * Tcl_SetChannelOption --
d5454 4
a5457 1
 *	Sets an option on a channel.
d5460 1
a5460 2
 *	A standard Tcl result.  On error, sets interp's result object
 *	if interp is not NULL.
d5463 1
a5463 1
 *	May modify an option on a device.
d5465 1
a5465 1
 *---------------------------------------------------------------------------
d5468 1
d5470 5
a5474 5
Tcl_SetChannelOption(interp, chan, optionName, newValue)
    Tcl_Interp *interp;		/* For error reporting - can be NULL. */
    Tcl_Channel chan;		/* Channel on which to set mode. */
    char *optionName;		/* Which option to set? */
    char *newValue;		/* New value for option. */
d5476 12
a5487 17
    int newMode;		/* New (numeric) mode to sert. */
    Channel *chanPtr = (Channel *) chan;	/* The real IO channel. */
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    size_t len;			/* Length of optionName string. */
    int argc;
    char **argv;

    /*
     * If the channel is in the middle of a background copy, fail.
     */

    if (statePtr->csPtr) {
	if (interp) {
	    Tcl_AppendResult(interp,
		    "unable to set channel options: background copy in progress",
		    (char *) NULL);
	}
d5490 19
d5510 10
a5519 6
    /*
     * Disallow options on dead channels -- channels that have been closed but
     * not yet been deallocated. Such channels can be found if the exit
     * handler for channel cleanup has run but the channel is still
     * registered in an interpreter.
     */
d5521 4
a5524 2
    if (CheckForDeadChannel(NULL, statePtr)) {
	return TCL_ERROR;
d5527 4
a5530 11
    /*
     * This operation should occur at the top of a channel stack.
     */

    chanPtr = statePtr->topChanPtr;

    len = strlen(optionName);

    if ((len > 2) && (optionName[1] == 'b') &&
            (strncmp(optionName, "-blocking", len) == 0)) {
        if (Tcl_GetBoolean(interp, newValue, &newMode) == TCL_ERROR) {
d5533 2
a5534 4
        if (newMode) {
            newMode = TCL_MODE_BLOCKING;
        } else {
            newMode = TCL_MODE_NONBLOCKING;
d5536 4
a5539 22
	return SetBlockMode(interp, chanPtr, newMode);
    } else if ((len > 7) && (optionName[1] == 'b') &&
            (strncmp(optionName, "-buffering", len) == 0)) {
        len = strlen(newValue);
        if ((newValue[0] == 'f') && (strncmp(newValue, "full", len) == 0)) {
            statePtr->flags &=
                (~(CHANNEL_UNBUFFERED|CHANNEL_LINEBUFFERED));
        } else if ((newValue[0] == 'l') &&
                (strncmp(newValue, "line", len) == 0)) {
            statePtr->flags &= (~(CHANNEL_UNBUFFERED));
            statePtr->flags |= CHANNEL_LINEBUFFERED;
        } else if ((newValue[0] == 'n') &&
                (strncmp(newValue, "none", len) == 0)) {
            statePtr->flags &= (~(CHANNEL_LINEBUFFERED));
            statePtr->flags |= CHANNEL_UNBUFFERED;
        } else {
            if (interp) {
                Tcl_AppendResult(interp, "bad value for -buffering: ",
                        "must be one of full, line, or none",
                        (char *) NULL);
                return TCL_ERROR;
            }
d5541 8
a5548 30
	return TCL_OK;
    } else if ((len > 7) && (optionName[1] == 'b') &&
            (strncmp(optionName, "-buffersize", len) == 0)) {
        statePtr->bufSize = atoi(newValue);	/* INTL: "C", UTF safe. */
        if ((statePtr->bufSize < 10) || (statePtr->bufSize > (1024 * 1024))) {
            statePtr->bufSize = CHANNELBUFFER_DEFAULT_SIZE;
        }
    } else if ((len > 2) && (optionName[1] == 'e') &&
	    (strncmp(optionName, "-encoding", len) == 0)) {
	Tcl_Encoding encoding;

	if ((newValue[0] == '\0') || (strcmp(newValue, "binary") == 0)) {
	    encoding = NULL;
	} else {
	    encoding = Tcl_GetEncoding(interp, newValue);
	    if (encoding == NULL) {
		return TCL_ERROR;
	    }
	}
	Tcl_FreeEncoding(statePtr->encoding);
	statePtr->encoding = encoding;
	statePtr->inputEncodingState = NULL;
	statePtr->inputEncodingFlags = TCL_ENCODING_START;
	statePtr->outputEncodingState = NULL;
	statePtr->outputEncodingFlags = TCL_ENCODING_START;
	statePtr->flags &= ~CHANNEL_NEED_MORE_DATA;
	UpdateInterest(chanPtr);
    } else if ((len > 2) && (optionName[1] == 'e') &&
            (strncmp(optionName, "-eofchar", len) == 0)) {
        if (Tcl_SplitList(interp, newValue, &argc, &argv) == TCL_ERROR) {
d5551 8
a5558 6
        if (argc == 0) {
            statePtr->inEofChar = 0;
            statePtr->outEofChar = 0;
        } else if (argc == 1) {
            if (statePtr->flags & TCL_WRITABLE) {
                statePtr->outEofChar = (int) argv[0][0];
d5560 2
a5561 2
            if (statePtr->flags & TCL_READABLE) {
                statePtr->inEofChar = (int) argv[0][0];
d5563 14
a5576 7
        } else if (argc != 2) {
            if (interp) {
                Tcl_AppendResult(interp,
                        "bad value for -eofchar: should be a list of one or",
                        " two elements", (char *) NULL);
            }
            ckfree((char *) argv);
a5577 7
        } else {
            if (statePtr->flags & TCL_READABLE) {
                statePtr->inEofChar = (int) argv[0][0];
            }
            if (statePtr->flags & TCL_WRITABLE) {
                statePtr->outEofChar = (int) argv[1][0];
            }
d5579 12
a5590 2
        if (argv != (char **) NULL) {
            ckfree((char *) argv);
d5592 2
a5593 4
	return TCL_OK;
    } else if ((len > 1) && (optionName[1] == 't') &&
            (strncmp(optionName, "-translation", len) == 0)) {
	char *readMode, *writeMode;
d5595 41
a5635 1
        if (Tcl_SplitList(interp, newValue, &argc, &argv) == TCL_ERROR) {
d5639 6
a5644 6
        if (argc == 1) {
	    readMode = (statePtr->flags & TCL_READABLE) ? argv[0] : NULL;
	    writeMode = (statePtr->flags & TCL_WRITABLE) ? argv[0] : NULL;
	} else if (argc == 2) {
	    readMode = (statePtr->flags & TCL_READABLE) ? argv[0] : NULL;
	    writeMode = (statePtr->flags & TCL_WRITABLE) ? argv[1] : NULL;
d5646 2
a5647 6
            if (interp) {
                Tcl_AppendResult(interp,
                        "bad value for -translation: must be a one or two",
                        " element list", (char *) NULL);
            }
            ckfree((char *) argv);
d5649 9
a5657 96
	}

	if (readMode) {
	    if (*readMode == '\0') {
		newMode = statePtr->inputTranslation;
	    } else if (strcmp(readMode, "auto") == 0) {
		newMode = TCL_TRANSLATE_AUTO;
	    } else if (strcmp(readMode, "binary") == 0) {
		newMode = TCL_TRANSLATE_LF;
		statePtr->inEofChar = 0;
		Tcl_FreeEncoding(statePtr->encoding);		    
		statePtr->encoding = NULL;
	    } else if (strcmp(readMode, "lf") == 0) {
		newMode = TCL_TRANSLATE_LF;
	    } else if (strcmp(readMode, "cr") == 0) {
		newMode = TCL_TRANSLATE_CR;
	    } else if (strcmp(readMode, "crlf") == 0) {
		newMode = TCL_TRANSLATE_CRLF;
	    } else if (strcmp(readMode, "platform") == 0) {
		newMode = TCL_PLATFORM_TRANSLATION;
	    } else {
		if (interp) {
		    Tcl_AppendResult(interp,
			    "bad value for -translation: ",
			    "must be one of auto, binary, cr, lf, crlf,",
			    " or platform", (char *) NULL);
		}
		ckfree((char *) argv);
		return TCL_ERROR;
	    }

	    /*
	     * Reset the EOL flags since we need to look at any buffered
	     * data to see if the new translation mode allows us to
	     * complete the line.
	     */

	    if (newMode != statePtr->inputTranslation) {
		statePtr->inputTranslation = (Tcl_EolTranslation) newMode;
		statePtr->flags &= ~(INPUT_SAW_CR);
		statePtr->flags &= ~(CHANNEL_NEED_MORE_DATA);
		UpdateInterest(chanPtr);
	    }
	}
	if (writeMode) {
	    if (*writeMode == '\0') {
		/* Do nothing. */
	    } else if (strcmp(writeMode, "auto") == 0) {
		/*
		 * This is a hack to get TCP sockets to produce output
		 * in CRLF mode if they are being set into AUTO mode.
		 * A better solution for achieving this effect will be
		 * coded later.
		 */

		if (strcmp(chanPtr->typePtr->typeName, "tcp") == 0) {
		    statePtr->outputTranslation = TCL_TRANSLATE_CRLF;
		} else {
		    statePtr->outputTranslation = TCL_PLATFORM_TRANSLATION;
		}
	    } else if (strcmp(writeMode, "binary") == 0) {
		statePtr->outEofChar = 0;
		statePtr->outputTranslation = TCL_TRANSLATE_LF;
		Tcl_FreeEncoding(statePtr->encoding);		    
		statePtr->encoding = NULL;
	    } else if (strcmp(writeMode, "lf") == 0) {
		statePtr->outputTranslation = TCL_TRANSLATE_LF;
	    } else if (strcmp(writeMode, "cr") == 0) {
		statePtr->outputTranslation = TCL_TRANSLATE_CR;
	    } else if (strcmp(writeMode, "crlf") == 0) {
		statePtr->outputTranslation = TCL_TRANSLATE_CRLF;
	    } else if (strcmp(writeMode, "platform") == 0) {
		statePtr->outputTranslation = TCL_PLATFORM_TRANSLATION;
	    } else {
		if (interp) {
		    Tcl_AppendResult(interp,
			    "bad value for -translation: ",
			    "must be one of auto, binary, cr, lf, crlf,",
			    " or platform", (char *) NULL);
		}
		ckfree((char *) argv);
		return TCL_ERROR;
	    }
	}
        ckfree((char *) argv);            
        return TCL_OK;
    } else if (chanPtr->typePtr->setOptionProc != NULL) {
        return (*chanPtr->typePtr->setOptionProc)(chanPtr->instanceData,
                interp, optionName, newValue);
    } else {
	return Tcl_BadChannelOption(interp, optionName, (char *) NULL);
    }

    /*
     * If bufsize changes, need to get rid of old utility buffer.
     */
a5658 27
    if (statePtr->saveInBufPtr != NULL) {
	RecycleBuffer(statePtr, statePtr->saveInBufPtr, 1);
	statePtr->saveInBufPtr = NULL;
    }
    if (statePtr->inQueueHead != NULL) {
	if ((statePtr->inQueueHead->nextPtr == NULL)
		&& (statePtr->inQueueHead->nextAdded ==
			statePtr->inQueueHead->nextRemoved)) {
	    RecycleBuffer(statePtr, statePtr->inQueueHead, 1);
	    statePtr->inQueueHead = NULL;
	    statePtr->inQueueTail = NULL;
	}
    }

    /*
     * If encoding or bufsize changes, need to update output staging buffer.
     */

    if (statePtr->outputStage != NULL) {
	ckfree((char *) statePtr->outputStage);
	statePtr->outputStage = NULL;
    }
    if ((statePtr->encoding != NULL) && (statePtr->flags & TCL_WRITABLE)) {
	statePtr->outputStage = (char *) 
	    ckalloc((unsigned) (statePtr->bufSize + 2));
    }
    return TCL_OK;
d5664 1
a5664 1
 * CleanupChannelHandlers --
d5666 5
a5670 5
 *	Removes channel handlers that refer to the supplied interpreter,
 *	so that if the actual channel is not closed now, these handlers
 *	will not run on subsequent events on the channel. This would be
 *	erroneous, because the interpreter no longer has a reference to
 *	this channel.
d5673 1
a5673 1
 *	None.
d5676 2
a5677 1
 *	Removes channel handlers.
d5682 7
a5688 4
static void
CleanupChannelHandlers(interp, chanPtr)
    Tcl_Interp *interp;
    Channel *chanPtr;
d5690 5
a5694 2
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    EventScriptRecord *sPtr, *prevPtr, *nextPtr;
d5696 9
a5704 25
    /*
     * Remove fileevent records on this channel that refer to the
     * given interpreter.
     */
    
    for (sPtr = statePtr->scriptRecordPtr,
             prevPtr = (EventScriptRecord *) NULL;
	 sPtr != (EventScriptRecord *) NULL;
	 sPtr = nextPtr) {
        nextPtr = sPtr->nextPtr;
        if (sPtr->interp == interp) {
            if (prevPtr == (EventScriptRecord *) NULL) {
                statePtr->scriptRecordPtr = nextPtr;
            } else {
                prevPtr->nextPtr = nextPtr;
            }

            Tcl_DeleteChannelHandler((Tcl_Channel) chanPtr,
                    TclChannelEventScriptInvoker, (ClientData) sPtr);

	    Tcl_DecrRefCount(sPtr->scriptPtr);
            ckfree((char *) sPtr);
        } else {
            prevPtr = sPtr;
        }
a5705 20
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_NotifyChannel --
 *
 *	This procedure is called by a channel driver when a driver
 *	detects an event on a channel.  This procedure is responsible
 *	for actually handling the event by invoking any channel
 *	handler callbacks.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Whatever the channel handler callback procedure does.
 *
 *----------------------------------------------------------------------
 */
d5707 2
a5708 15
void
Tcl_NotifyChannel(channel, mask)
    Tcl_Channel channel;	/* Channel that detected an event. */
    int mask;			/* OR'ed combination of TCL_READABLE,
				 * TCL_WRITABLE, or TCL_EXCEPTION: indicates
				 * which events were detected. */
{
    Channel *chanPtr = (Channel *) channel;
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    ChannelHandler *chPtr;
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    NextChannelHandler nh;
#ifdef TCL_CHANNEL_VERSION_2
    Channel* upChanPtr;
    Tcl_ChannelType* upTypePtr;
d5711 3
a5713 9
     * In contrast to the other API functions this procedure walks towards
     * the top of a stack and not down from it.
     *
     * The channel calling this procedure is the one who generated the event,
     * and thus does not take part in handling it. IOW, its HandlerProc is
     * not called, instead we begin with the channel above it.
     *
     * This behaviour also allows the transformation channels to
     * generate their own events and pass them upward.
d5716 19
a5734 12
    while (mask && (chanPtr->upChanPtr != ((Channel*) NULL))) {
        upChanPtr = chanPtr->upChanPtr;
	upTypePtr = upChanPtr->typePtr;

	if ((Tcl_ChannelVersion(upTypePtr) == TCL_CHANNEL_VERSION_2) &&
		(Tcl_ChannelHandlerProc(upTypePtr) !=
			((Tcl_DriverHandlerProc *) NULL))) {

	    Tcl_DriverHandlerProc* handlerProc =
		Tcl_ChannelHandlerProc(upTypePtr);

	  mask = (*handlerProc) (upChanPtr->instanceData, mask);
a5735 8

	/* ELSE:
	 * Ignore transformations which are unable to handle the event
	 * coming from below. Assume that they don't change the mask and
	 * pass it on.
	 */

	chanPtr = upChanPtr;
a5737 2
    channel = (Tcl_Channel) chanPtr;

d5739 1
a5739 2
     * Here we have either reached the top of the stack or the mask is
     * empty.  We break out of the procedure if it is the latter.
d5742 2
a5743 3
    if (!mask) {
        return;
    }
d5746 3
a5748 4
     * We are now above the topmost channel in a stack and have events
     * left. Now call the channel handlers as usual.
     *
     * Preserve the channel struct in case the script closes it.
a5749 2
     
    Tcl_Preserve((ClientData) channel);
d5751 11
a5761 10
    /*
     * If we are flushing in the background, be sure to call FlushChannel
     * for writable events.  Note that we have to discard the writable
     * event so we don't call any write handlers before the flush is
     * complete.
     */

    if ((statePtr->flags & BG_FLUSH_SCHEDULED) && (mask & TCL_WRITABLE)) {
      FlushChannel(NULL, chanPtr, 1);
      mask &= ~TCL_WRITABLE;
d5763 3
d5768 1
a5768 2
     * Add this invocation to the list of recursive invocations of
     * ChannelHandlerEventProc.
a5769 4
    
    nh.nextHandlerPtr = (ChannelHandler *) NULL;
    nh.nestedHandlerPtr = tsdPtr->nestedHandlerPtr;
    tsdPtr->nestedHandlerPtr = &nh;
d5771 1
a5771 1979
    for (chPtr = statePtr->chPtr; chPtr != (ChannelHandler *) NULL; ) {

      /*
       * If this channel handler is interested in any of the events that
       * have occurred on the channel, invoke its procedure.
       */
        
      if ((chPtr->mask & mask) != 0) {
	nh.nextHandlerPtr = chPtr->nextPtr;
	(*(chPtr->proc))(chPtr->clientData, mask);
	chPtr = nh.nextHandlerPtr;
      } else {
	chPtr = chPtr->nextPtr;
      }
    }

    /*
     * Update the notifier interest, since it may have changed after
     * invoking event handlers. Skip that if the channel was deleted
     * in the call to the channel handler.
     */

    if (chanPtr->typePtr != NULL) {
        UpdateInterest(chanPtr);
    }

    Tcl_Release((ClientData) channel);

    tsdPtr->nestedHandlerPtr = nh.nestedHandlerPtr;
#else
    /* Walk all channels in a stack ! and notify them in order.
     */

    while (chanPtr != (Channel *) NULL) {
        /*
	 * Preserve the channel struct in case the script closes it.
	 */
     
        Tcl_Preserve((ClientData) channel);

	/*
	 * If we are flushing in the background, be sure to call FlushChannel
	 * for writable events.  Note that we have to discard the writable
	 * event so we don't call any write handlers before the flush is
	 * complete.
	 */

	if ((statePtr->flags & BG_FLUSH_SCHEDULED) && (mask & TCL_WRITABLE)) {
	    FlushChannel(NULL, chanPtr, 1);
	    mask &= ~TCL_WRITABLE;
	}

	/*
	 * Add this invocation to the list of recursive invocations of
	 * ChannelHandlerEventProc.
	 */
    
	nh.nextHandlerPtr = (ChannelHandler *) NULL;
	nh.nestedHandlerPtr = tsdPtr->nestedHandlerPtr;
	tsdPtr->nestedHandlerPtr = &nh;

	for (chPtr = statePtr->chPtr; chPtr != (ChannelHandler *) NULL; ) {

	    /*
	     * If this channel handler is interested in any of the events that
	     * have occurred on the channel, invoke its procedure.
	     */
        
	    if ((chPtr->mask & mask) != 0) {
		nh.nextHandlerPtr = chPtr->nextPtr;
		(*(chPtr->proc))(chPtr->clientData, mask);
		chPtr = nh.nextHandlerPtr;
	    } else {
		chPtr = chPtr->nextPtr;
	    }
	}

	/*
	 * Update the notifier interest, since it may have changed after
	 * invoking event handlers. Skip that if the channel was deleted
	 * in the call to the channel handler.
	 */

	if (chanPtr->typePtr != NULL) {
	    UpdateInterest(chanPtr);

	    /* Walk down the stack.
	     */
	    chanPtr = chanPtr->downChanPtr;
	} else {
	    /* Stop walking the chain, the whole stack was destroyed!
	     */
	    chanPtr = (Channel *) NULL;
	}

	Tcl_Release((ClientData) channel);

	tsdPtr->nestedHandlerPtr = nh.nestedHandlerPtr;

	channel = (Tcl_Channel) chanPtr;
    }
#endif
}

/*
 *----------------------------------------------------------------------
 *
 * UpdateInterest --
 *
 *	Arrange for the notifier to call us back at appropriate times
 *	based on the current state of the channel.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	May schedule a timer or driver handler.
 *
 *----------------------------------------------------------------------
 */

static void
UpdateInterest(chanPtr)
    Channel *chanPtr;		/* Channel to update. */
{
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    int mask = statePtr->interestMask;

    /*
     * If there are flushed buffers waiting to be written, then
     * we need to watch for the channel to become writable.
     */

    if (statePtr->flags & BG_FLUSH_SCHEDULED) {
	mask |= TCL_WRITABLE;
    }

    /*
     * If there is data in the input queue, and we aren't waiting for more
     * data, then we need to schedule a timer so we don't block in the
     * notifier.  Also, cancel the read interest so we don't get duplicate
     * events.
     */

    if (mask & TCL_READABLE) {
	if (!(statePtr->flags & CHANNEL_NEED_MORE_DATA)
		&& (statePtr->inQueueHead != (ChannelBuffer *) NULL)
		&& (statePtr->inQueueHead->nextRemoved <
			statePtr->inQueueHead->nextAdded)) {
	    mask &= ~TCL_READABLE;
	    if (!statePtr->timer) {
		statePtr->timer = Tcl_CreateTimerHandler(0, ChannelTimerProc,
			(ClientData) chanPtr);
	    }
	}
    }
    (chanPtr->typePtr->watchProc)(chanPtr->instanceData, mask);
}

/*
 *----------------------------------------------------------------------
 *
 * ChannelTimerProc --
 *
 *	Timer handler scheduled by UpdateInterest to monitor the
 *	channel buffers until they are empty.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	May invoke channel handlers.
 *
 *----------------------------------------------------------------------
 */

static void
ChannelTimerProc(clientData)
    ClientData clientData;
{
    Channel *chanPtr = (Channel *) clientData;
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */

    if (!(statePtr->flags & CHANNEL_NEED_MORE_DATA)
	    && (statePtr->interestMask & TCL_READABLE)
	    && (statePtr->inQueueHead != (ChannelBuffer *) NULL)
	    && (statePtr->inQueueHead->nextRemoved <
		    statePtr->inQueueHead->nextAdded)) {
	/*
	 * Restart the timer in case a channel handler reenters the
	 * event loop before UpdateInterest gets called by Tcl_NotifyChannel.
	 */

	statePtr->timer = Tcl_CreateTimerHandler(0, ChannelTimerProc,
		(ClientData) chanPtr);
	Tcl_NotifyChannel((Tcl_Channel)chanPtr, TCL_READABLE);
 
    } else {
	statePtr->timer = NULL;
	UpdateInterest(chanPtr);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_CreateChannelHandler --
 *
 *	Arrange for a given procedure to be invoked whenever the
 *	channel indicated by the chanPtr arg becomes readable or
 *	writable.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	From now on, whenever the I/O channel given by chanPtr becomes
 *	ready in the way indicated by mask, proc will be invoked.
 *	See the manual entry for details on the calling sequence
 *	to proc.  If there is already an event handler for chan, proc
 *	and clientData, then the mask will be updated.
 *
 *----------------------------------------------------------------------
 */

void
Tcl_CreateChannelHandler(chan, mask, proc, clientData)
    Tcl_Channel chan;		/* The channel to create the handler for. */
    int mask;			/* OR'ed combination of TCL_READABLE,
				 * TCL_WRITABLE, and TCL_EXCEPTION:
				 * indicates conditions under which
				 * proc should be called. Use 0 to
                                 * disable a registered handler. */
    Tcl_ChannelProc *proc;	/* Procedure to call for each
				 * selected event. */
    ClientData clientData;	/* Arbitrary data to pass to proc. */
{
    ChannelHandler *chPtr;
    Channel *chanPtr = (Channel *) chan;
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */

    /*
     * Check whether this channel handler is not already registered. If
     * it is not, create a new record, else reuse existing record (smash
     * current values).
     */

    for (chPtr = statePtr->chPtr;
	 chPtr != (ChannelHandler *) NULL;
	 chPtr = chPtr->nextPtr) {
        if ((chPtr->chanPtr == chanPtr) && (chPtr->proc == proc) &&
                (chPtr->clientData == clientData)) {
            break;
        }
    }
    if (chPtr == (ChannelHandler *) NULL) {
        chPtr = (ChannelHandler *) ckalloc((unsigned) sizeof(ChannelHandler));
        chPtr->mask = 0;
        chPtr->proc = proc;
        chPtr->clientData = clientData;
        chPtr->chanPtr = chanPtr;
        chPtr->nextPtr = statePtr->chPtr;
        statePtr->chPtr = chPtr;
    }

    /*
     * The remainder of the initialization below is done regardless of
     * whether or not this is a new record or a modification of an old
     * one.
     */

    chPtr->mask = mask;

    /*
     * Recompute the interest mask for the channel - this call may actually
     * be disabling an existing handler.
     */
    
    statePtr->interestMask = 0;
    for (chPtr = statePtr->chPtr;
	 chPtr != (ChannelHandler *) NULL;
	 chPtr = chPtr->nextPtr) {
	statePtr->interestMask |= chPtr->mask;
    }

    UpdateInterest(statePtr->topChanPtr);
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_DeleteChannelHandler --
 *
 *	Cancel a previously arranged callback arrangement for an IO
 *	channel.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	If a callback was previously registered for this chan, proc and
 *	 clientData , it is removed and the callback will no longer be called
 *	when the channel becomes ready for IO.
 *
 *----------------------------------------------------------------------
 */

void
Tcl_DeleteChannelHandler(chan, proc, clientData)
    Tcl_Channel chan;		/* The channel for which to remove the
                                 * callback. */
    Tcl_ChannelProc *proc;	/* The procedure in the callback to delete. */
    ClientData clientData;	/* The client data in the callback
                                 * to delete. */
    
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    ChannelHandler *chPtr, *prevChPtr;
    Channel *chanPtr = (Channel *) chan;
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    NextChannelHandler *nhPtr;

    /*
     * Find the entry and the previous one in the list.
     */

    for (prevChPtr = (ChannelHandler *) NULL, chPtr = statePtr->chPtr;
	 chPtr != (ChannelHandler *) NULL;
	 chPtr = chPtr->nextPtr) {
        if ((chPtr->chanPtr == chanPtr) && (chPtr->clientData == clientData)
                && (chPtr->proc == proc)) {
            break;
        }
        prevChPtr = chPtr;
    }

    /*
     * If not found, return without doing anything.
     */

    if (chPtr == (ChannelHandler *) NULL) {
        return;
    }

    /*
     * If ChannelHandlerEventProc is about to process this handler, tell it to
     * process the next one instead - we are going to delete *this* one.
     */

    for (nhPtr = tsdPtr->nestedHandlerPtr;
	 nhPtr != (NextChannelHandler *) NULL;
	 nhPtr = nhPtr->nestedHandlerPtr) {
        if (nhPtr->nextHandlerPtr == chPtr) {
            nhPtr->nextHandlerPtr = chPtr->nextPtr;
        }
    }

    /*
     * Splice it out of the list of channel handlers.
     */
    
    if (prevChPtr == (ChannelHandler *) NULL) {
        statePtr->chPtr = chPtr->nextPtr;
    } else {
        prevChPtr->nextPtr = chPtr->nextPtr;
    }
    ckfree((char *) chPtr);

    /*
     * Recompute the interest list for the channel, so that infinite loops
     * will not result if Tcl_DeleteChannelHandler is called inside an
     * event.
     */

    statePtr->interestMask = 0;
    for (chPtr = statePtr->chPtr;
	 chPtr != (ChannelHandler *) NULL;
	 chPtr = chPtr->nextPtr) {
        statePtr->interestMask |= chPtr->mask;
    }

    UpdateInterest(statePtr->topChanPtr);
}

/*
 *----------------------------------------------------------------------
 *
 * DeleteScriptRecord --
 *
 *	Delete a script record for this combination of channel, interp
 *	and mask.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Deletes a script record and cancels a channel event handler.
 *
 *----------------------------------------------------------------------
 */

static void
DeleteScriptRecord(interp, chanPtr, mask)
    Tcl_Interp *interp;		/* Interpreter in which script was to be
                                 * executed. */
    Channel *chanPtr;		/* The channel for which to delete the
                                 * script record (if any). */
    int mask;			/* Events in mask must exactly match mask
                                 * of script to delete. */
{
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    EventScriptRecord *esPtr, *prevEsPtr;

    for (esPtr = statePtr->scriptRecordPtr,
             prevEsPtr = (EventScriptRecord *) NULL;
	 esPtr != (EventScriptRecord *) NULL;
	 prevEsPtr = esPtr, esPtr = esPtr->nextPtr) {
        if ((esPtr->interp == interp) && (esPtr->mask == mask)) {
            if (esPtr == statePtr->scriptRecordPtr) {
                statePtr->scriptRecordPtr = esPtr->nextPtr;
            } else {
                prevEsPtr->nextPtr = esPtr->nextPtr;
            }

            Tcl_DeleteChannelHandler((Tcl_Channel) chanPtr,
                    TclChannelEventScriptInvoker, (ClientData) esPtr);
            
	    Tcl_DecrRefCount(esPtr->scriptPtr);
            ckfree((char *) esPtr);

            break;
        }
    }
}

/*
 *----------------------------------------------------------------------
 *
 * CreateScriptRecord --
 *
 *	Creates a record to store a script to be executed when a specific
 *	event fires on a specific channel.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Causes the script to be stored for later execution.
 *
 *----------------------------------------------------------------------
 */

static void
CreateScriptRecord(interp, chanPtr, mask, scriptPtr)
    Tcl_Interp *interp;			/* Interpreter in which to execute
                                         * the stored script. */
    Channel *chanPtr;			/* Channel for which script is to
                                         * be stored. */
    int mask;				/* Set of events for which script
                                         * will be invoked. */
    Tcl_Obj *scriptPtr;			/* Pointer to script object. */
{
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    EventScriptRecord *esPtr;

    for (esPtr = statePtr->scriptRecordPtr;
	 esPtr != (EventScriptRecord *) NULL;
	 esPtr = esPtr->nextPtr) {
        if ((esPtr->interp == interp) && (esPtr->mask == mask)) {
	    Tcl_DecrRefCount(esPtr->scriptPtr);
	    esPtr->scriptPtr = (Tcl_Obj *) NULL;
            break;
        }
    }
    if (esPtr == (EventScriptRecord *) NULL) {
        esPtr = (EventScriptRecord *) ckalloc((unsigned)
                sizeof(EventScriptRecord));
        Tcl_CreateChannelHandler((Tcl_Channel) chanPtr, mask,
                TclChannelEventScriptInvoker, (ClientData) esPtr);
        esPtr->nextPtr = statePtr->scriptRecordPtr;
        statePtr->scriptRecordPtr = esPtr;
    }
    esPtr->chanPtr = chanPtr;
    esPtr->interp = interp;
    esPtr->mask = mask;
    Tcl_IncrRefCount(scriptPtr);
    esPtr->scriptPtr = scriptPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * TclChannelEventScriptInvoker --
 *
 *	Invokes a script scheduled by "fileevent" for when the channel
 *	becomes ready for IO. This function is invoked by the channel
 *	handler which was created by the Tcl "fileevent" command.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Whatever the script does.
 *
 *----------------------------------------------------------------------
 */

void
TclChannelEventScriptInvoker(clientData, mask)
    ClientData clientData;	/* The script+interp record. */
    int mask;			/* Not used. */
{
    Tcl_Interp *interp;		/* Interpreter in which to eval the script. */
    Channel *chanPtr;		/* The channel for which this handler is
                                 * registered. */
    EventScriptRecord *esPtr;	/* The event script + interpreter to eval it
                                 * in. */
    int result;			/* Result of call to eval script. */

    esPtr	= (EventScriptRecord *) clientData;
    chanPtr	= esPtr->chanPtr;
    mask	= esPtr->mask;
    interp	= esPtr->interp;

    /*
     * We must preserve the interpreter so we can report errors on it
     * later.  Note that we do not need to preserve the channel because
     * that is done by Tcl_NotifyChannel before calling channel handlers.
     */
    
    Tcl_Preserve((ClientData) interp);
    result = Tcl_EvalObjEx(interp, esPtr->scriptPtr, TCL_EVAL_GLOBAL);

    /*
     * On error, cause a background error and remove the channel handler
     * and the script record.
     *
     * NOTE: Must delete channel handler before causing the background error
     * because the background error may want to reinstall the handler.
     */
    
    if (result != TCL_OK) {
	if (chanPtr->typePtr != NULL) {
	    DeleteScriptRecord(interp, chanPtr, mask);
	}
        Tcl_BackgroundError(interp);
    }
    Tcl_Release((ClientData) interp);
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_FileEventObjCmd --
 *
 *	This procedure implements the "fileevent" Tcl command. See the
 *	user documentation for details on what it does. This command is
 *	based on the Tk command "fileevent" which in turn is based on work
 *	contributed by Mark Diekhans.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	May create a channel handler for the specified channel.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
int
Tcl_FileEventObjCmd(clientData, interp, objc, objv)
    ClientData clientData;		/* Not used. */
    Tcl_Interp *interp;			/* Interpreter in which the channel
                                         * for which to create the handler
                                         * is found. */
    int objc;				/* Number of arguments. */
    Tcl_Obj *CONST objv[];		/* Argument objects. */
{
    Channel *chanPtr;			/* The channel to create
                                         * the handler for. */
    ChannelState *statePtr;		/* state info for channel */
    Tcl_Channel chan;			/* The opaque type for the channel. */
    char *chanName;
    int modeIndex;			/* Index of mode argument. */
    int mask;
    static char *modeOptions[] = {"readable", "writable", NULL};
    static int maskArray[] = {TCL_READABLE, TCL_WRITABLE};

    if ((objc != 3) && (objc != 4)) {
	Tcl_WrongNumArgs(interp, 1, objv, "channelId event ?script?");
	return TCL_ERROR;
    }
    if (Tcl_GetIndexFromObj(interp, objv[2], modeOptions, "event name", 0,
	    &modeIndex) != TCL_OK) {
	return TCL_ERROR;
    }
    mask = maskArray[modeIndex];

    chanName = Tcl_GetString(objv[1]);
    chan = Tcl_GetChannel(interp, chanName, NULL);
    if (chan == (Tcl_Channel) NULL) {
	return TCL_ERROR;
    }
    chanPtr  = (Channel *) chan;
    statePtr = chanPtr->state;
    if ((statePtr->flags & mask) == 0) {
        Tcl_AppendResult(interp, "channel is not ",
                (mask == TCL_READABLE) ? "readable" : "writable",
                (char *) NULL);
        return TCL_ERROR;
    }
    
    /*
     * If we are supposed to return the script, do so.
     */

    if (objc == 3) {
	EventScriptRecord *esPtr;
	for (esPtr = statePtr->scriptRecordPtr;
             esPtr != (EventScriptRecord *) NULL;
             esPtr = esPtr->nextPtr) {
	    if ((esPtr->interp == interp) && (esPtr->mask == mask)) {
		Tcl_SetObjResult(interp, esPtr->scriptPtr);
		break;
	    }
	}
        return TCL_OK;
    }

    /*
     * If we are supposed to delete a stored script, do so.
     */

    if (*(Tcl_GetString(objv[3])) == '\0') {
        DeleteScriptRecord(interp, chanPtr, mask);
        return TCL_OK;
    }

    /*
     * Make the script record that will link between the event and the
     * script to invoke. This also creates a channel event handler which
     * will evaluate the script in the supplied interpreter.
     */

    CreateScriptRecord(interp, chanPtr, mask, objv[3]);
    
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * TclCopyChannel --
 *
 *	This routine copies data from one channel to another, either
 *	synchronously or asynchronously.  If a command script is
 *	supplied, the operation runs in the background.  The script
 *	is invoked when the copy completes.  Otherwise the function
 *	waits until the copy is completed before returning.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	May schedule a background copy operation that causes both
 *	channels to be marked busy.
 *
 *----------------------------------------------------------------------
 */

int
TclCopyChannel(interp, inChan, outChan, toRead, cmdPtr)
    Tcl_Interp *interp;		/* Current interpreter. */
    Tcl_Channel inChan;		/* Channel to read from. */
    Tcl_Channel outChan;	/* Channel to write to. */
    int toRead;			/* Amount of data to copy, or -1 for all. */
    Tcl_Obj *cmdPtr;		/* Pointer to script to execute or NULL. */
{
    Channel *inPtr = (Channel *) inChan;
    Channel *outPtr = (Channel *) outChan;
    ChannelState *inStatePtr, *outStatePtr;
    int readFlags, writeFlags;
    CopyState *csPtr;
    int nonBlocking = (cmdPtr) ? CHANNEL_NONBLOCKING : 0;

    inStatePtr	= inPtr->state;
    outStatePtr	= outPtr->state;

    if (inStatePtr->csPtr) {
	Tcl_AppendStringsToObj(Tcl_GetObjResult(interp), "channel \"",
		Tcl_GetChannelName(inChan), "\" is busy", NULL);
	return TCL_ERROR;
    }
    if (outStatePtr->csPtr) {
	Tcl_AppendStringsToObj(Tcl_GetObjResult(interp), "channel \"",
		Tcl_GetChannelName(outChan), "\" is busy", NULL);
	return TCL_ERROR;
    }

    readFlags	= inStatePtr->flags;
    writeFlags	= outStatePtr->flags;

    /*
     * Set up the blocking mode appropriately.  Background copies need
     * non-blocking channels.  Foreground copies need blocking channels.
     * If there is an error, restore the old blocking mode.
     */

    if (nonBlocking != (readFlags & CHANNEL_NONBLOCKING)) {
	if (SetBlockMode(interp, inPtr,
		nonBlocking ? TCL_MODE_NONBLOCKING : TCL_MODE_BLOCKING)
		!= TCL_OK) {
	    return TCL_ERROR;
	}
    }	    
    if (inPtr != outPtr) {
	if (nonBlocking != (writeFlags & CHANNEL_NONBLOCKING)) {
	    if (SetBlockMode(NULL, outPtr,
		    nonBlocking ? TCL_MODE_BLOCKING : TCL_MODE_NONBLOCKING)
		    != TCL_OK) {
		if (nonBlocking != (readFlags & CHANNEL_NONBLOCKING)) {
		    SetBlockMode(NULL, inPtr,
			    (readFlags & CHANNEL_NONBLOCKING)
			    ? TCL_MODE_NONBLOCKING : TCL_MODE_BLOCKING);
		    return TCL_ERROR;
		}
	    }
	}
    }

    /*
     * Make sure the output side is unbuffered.
     */

    outStatePtr->flags = (outStatePtr->flags & ~(CHANNEL_LINEBUFFERED))
	| CHANNEL_UNBUFFERED;

    /*
     * Allocate a new CopyState to maintain info about the current copy in
     * progress.  This structure will be deallocated when the copy is
     * completed.
     */

    csPtr = (CopyState*) ckalloc(sizeof(CopyState) + inStatePtr->bufSize);
    csPtr->bufSize    = inStatePtr->bufSize;
    csPtr->readPtr    = inPtr;
    csPtr->writePtr   = outPtr;
    csPtr->readFlags  = readFlags;
    csPtr->writeFlags = writeFlags;
    csPtr->toRead     = toRead;
    csPtr->total      = 0;
    csPtr->interp     = interp;
    if (cmdPtr) {
	Tcl_IncrRefCount(cmdPtr);
    }
    csPtr->cmdPtr = cmdPtr;
    inStatePtr->csPtr = csPtr;
    outStatePtr->csPtr = csPtr;

    /*
     * Start copying data between the channels.
     */

    return CopyData(csPtr, 0);
}

/*
 *----------------------------------------------------------------------
 *
 * CopyData --
 *
 *	This function implements the lowest level of the copying
 *	mechanism for TclCopyChannel.
 *
 * Results:
 *	Returns TCL_OK on success, else TCL_ERROR.
 *
 * Side effects:
 *	Moves data between channels, may create channel handlers.
 *
 *----------------------------------------------------------------------
 */

static int
CopyData(csPtr, mask)
    CopyState *csPtr;		/* State of copy operation. */
    int mask;			/* Current channel event flags. */
{
    Tcl_Interp *interp;
    Tcl_Obj *cmdPtr, *errObj = NULL;
    Tcl_Channel inChan, outChan;
    ChannelState *inStatePtr, *outStatePtr;
    int result = TCL_OK;
    int size;
    int total;

    inChan	= (Tcl_Channel) csPtr->readPtr;
    outChan	= (Tcl_Channel) csPtr->writePtr;
    inStatePtr	= csPtr->readPtr->state;
    outStatePtr	= csPtr->writePtr->state;
    interp	= csPtr->interp;
    cmdPtr	= csPtr->cmdPtr;

    /*
     * Copy the data the slow way, using the translation mechanism.
     *
     * Note: We have make sure that we use the topmost channel in a stack
     * for the copying. The caller uses Tcl_GetChannel to access it, and
     * thus gets the bottom of the stack.
     */

    while (csPtr->toRead != 0) {

	/*
	 * Check for unreported background errors.
	 */

	if (inStatePtr->unreportedError != 0) {
	    Tcl_SetErrno(inStatePtr->unreportedError);
	    inStatePtr->unreportedError = 0;
	    goto readError;
	}
	if (outStatePtr->unreportedError != 0) {
	    Tcl_SetErrno(outStatePtr->unreportedError);
	    outStatePtr->unreportedError = 0;
	    goto writeError;
	}
	
	/*
	 * Read up to bufSize bytes.
	 */

	if ((csPtr->toRead == -1) || (csPtr->toRead > csPtr->bufSize)) {
	    size = csPtr->bufSize;
	} else {
	    size = csPtr->toRead;
	}
	size = DoRead(inStatePtr->topChanPtr, csPtr->buffer, size);

	if (size < 0) {
	    readError:
	    errObj = Tcl_NewObj();
	    Tcl_AppendStringsToObj(errObj, "error reading \"",
		    Tcl_GetChannelName(inChan), "\": ",
		    Tcl_PosixError(interp), (char *) NULL);
	    break;
	} else if (size == 0) {
	    /*
	     * We had an underflow on the read side.  If we are at EOF,
	     * then the copying is done, otherwise set up a channel
	     * handler to detect when the channel becomes readable again.
	     */
	    
	    if (Tcl_Eof(inChan)) {
		break;
	    } else if (!(mask & TCL_READABLE)) {
		if (mask & TCL_WRITABLE) {
		    Tcl_DeleteChannelHandler(outChan, CopyEventProc,
			    (ClientData) csPtr);
		}
		Tcl_CreateChannelHandler(inChan, TCL_READABLE,
			CopyEventProc, (ClientData) csPtr);
	    }
	    return TCL_OK;
	}

	/*
	 * Now write the buffer out.
	 */

	size = DoWrite(outStatePtr->topChanPtr, csPtr->buffer, size);
	if (size < 0) {
	    writeError:
	    errObj = Tcl_NewObj();
	    Tcl_AppendStringsToObj(errObj, "error writing \"",
		    Tcl_GetChannelName(outChan), "\": ",
		    Tcl_PosixError(interp), (char *) NULL);
	    break;
	}

	/*
	 * Check to see if the write is happening in the background.  If so,
	 * stop copying and wait for the channel to become writable again.
	 */

	if (outStatePtr->flags & BG_FLUSH_SCHEDULED) {
	    if (!(mask & TCL_WRITABLE)) {
		if (mask & TCL_READABLE) {
		    Tcl_DeleteChannelHandler(outChan, CopyEventProc,
			    (ClientData) csPtr);
		}
		Tcl_CreateChannelHandler(outChan, TCL_WRITABLE,
			CopyEventProc, (ClientData) csPtr);
	    }
	    return TCL_OK;
	}

	/*
	 * Update the current byte count if we care.
	 */

	if (csPtr->toRead != -1) {
	    csPtr->toRead -= size;
	}
	csPtr->total += size;

	/*
	 * For background copies, we only do one buffer per invocation so
	 * we don't starve the rest of the system.
	 */

	if (cmdPtr) {
	    /*
	     * The first time we enter this code, there won't be a
	     * channel handler established yet, so do it here.
	     */

	    if (mask == 0) {
		Tcl_CreateChannelHandler(outChan, TCL_WRITABLE,
			CopyEventProc, (ClientData) csPtr);
	    }
	    return TCL_OK;
	}
    }

    /*
     * Make the callback or return the number of bytes transferred.
     * The local total is used because StopCopy frees csPtr.
     */

    total = csPtr->total;
    if (cmdPtr) {
	/*
	 * Get a private copy of the command so we can mutate it
	 * by adding arguments.  Note that StopCopy frees our saved
	 * reference to the original command obj.
	 */

	cmdPtr = Tcl_DuplicateObj(cmdPtr);
	Tcl_IncrRefCount(cmdPtr);
	StopCopy(csPtr);
	Tcl_Preserve((ClientData) interp);

	Tcl_ListObjAppendElement(interp, cmdPtr, Tcl_NewIntObj(total));
	if (errObj) {
	    Tcl_ListObjAppendElement(interp, cmdPtr, errObj);
	}
	if (Tcl_EvalObjEx(interp, cmdPtr, TCL_EVAL_GLOBAL) != TCL_OK) {
	    Tcl_BackgroundError(interp);
	    result = TCL_ERROR;
	}
	Tcl_DecrRefCount(cmdPtr);
	Tcl_Release((ClientData) interp);
    } else {
	StopCopy(csPtr);
	if (errObj) {
	    Tcl_SetObjResult(interp, errObj);
	    result = TCL_ERROR;
	} else {
	    Tcl_ResetResult(interp);
	    Tcl_SetIntObj(Tcl_GetObjResult(interp), total);
	}
    }
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * DoRead --
 *
 *	Reads a given number of bytes from a channel.
 *
 * Results:
 *	The number of characters read, or -1 on error. Use Tcl_GetErrno()
 *	to retrieve the error code for the error that occurred.
 *
 * Side effects:
 *	May cause input to be buffered.
 *
 *----------------------------------------------------------------------
 */

static int
DoRead(chanPtr, bufPtr, toRead)
    Channel *chanPtr;		/* The channel from which to read. */
    char *bufPtr;		/* Where to store input read. */
    int toRead;			/* Maximum number of bytes to read. */
{
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    int copied;			/* How many characters were copied into
                                 * the result string? */
    int copiedNow;		/* How many characters were copied from
                                 * the current input buffer? */
    int result;			/* Of calling GetInput. */

    /*
     * If we have not encountered a sticky EOF, clear the EOF bit. Either
     * way clear the BLOCKED bit. We want to discover these anew during
     * each operation.
     */

    if (!(statePtr->flags & CHANNEL_STICKY_EOF)) {
        statePtr->flags &= ~CHANNEL_EOF;
    }
    statePtr->flags &= ~(CHANNEL_BLOCKED | CHANNEL_NEED_MORE_DATA);
    
    for (copied = 0; copied < toRead; copied += copiedNow) {
        copiedNow = CopyAndTranslateBuffer(statePtr, bufPtr + copied,
                toRead - copied);
        if (copiedNow == 0) {
            if (statePtr->flags & CHANNEL_EOF) {
		goto done;
            }
            if (statePtr->flags & CHANNEL_BLOCKED) {
                if (statePtr->flags & CHANNEL_NONBLOCKING) {
		    goto done;
                }
                statePtr->flags &= (~(CHANNEL_BLOCKED));
            }
            result = GetInput(chanPtr);
            if (result != 0) {
                if (result != EAGAIN) {
                    copied = -1;
                }
		goto done;
            }
        }
    }

    statePtr->flags &= (~(CHANNEL_BLOCKED));

    done:
    /*
     * Update the notifier state so we don't block while there is still
     * data in the buffers.
     */

    UpdateInterest(chanPtr);
    return copied;
}

/*
 *----------------------------------------------------------------------
 *
 * CopyAndTranslateBuffer --
 *
 *	Copy at most one buffer of input to the result space, doing
 *	eol translations according to mode in effect currently.
 *
 * Results:
 *	Number of bytes stored in the result buffer (as opposed to the
 *	number of bytes read from the channel).  May return
 *	zero if no input is available to be translated.
 *
 * Side effects:
 *	Consumes buffered input. May deallocate one buffer.
 *
 *----------------------------------------------------------------------
 */

static int
CopyAndTranslateBuffer(statePtr, result, space)
    ChannelState *statePtr;	/* Channel state from which to read input. */
    char *result;		/* Where to store the copied input. */
    int space;			/* How many bytes are available in result
                                 * to store the copied input? */
{
    ChannelBuffer *bufPtr;	/* The buffer from which to copy bytes. */
    int bytesInBuffer;		/* How many bytes are available to be
                                 * copied in the current input buffer? */
    int copied;			/* How many characters were already copied
                                 * into the destination space? */
    int i;			/* Iterates over the copied input looking
                                 * for the input eofChar. */
    
    /*
     * If there is no input at all, return zero. The invariant is that either
     * there is no buffer in the queue, or if the first buffer is empty, it
     * is also the last buffer (and thus there is no input in the queue).
     * Note also that if the buffer is empty, we leave it in the queue.
     */
    
    if (statePtr->inQueueHead == (ChannelBuffer *) NULL) {
        return 0;
    }
    bufPtr = statePtr->inQueueHead;
    bytesInBuffer = bufPtr->nextAdded - bufPtr->nextRemoved;

    copied = 0;
    switch (statePtr->inputTranslation) {
        case TCL_TRANSLATE_LF: {
            if (bytesInBuffer == 0) {
                return 0;
            }

	    /*
             * Copy the current chunk into the result buffer.
             */

	    if (bytesInBuffer < space) {
		space = bytesInBuffer;
	    }
	    memcpy((VOID *) result,
		    (VOID *) (bufPtr->buf + bufPtr->nextRemoved),
		    (size_t) space);
	    bufPtr->nextRemoved += space;
	    copied = space;
            break;
	}
        case TCL_TRANSLATE_CR: {
	    char *end;
	    
            if (bytesInBuffer == 0) {
                return 0;
            }

	    /*
             * Copy the current chunk into the result buffer, then
             * replace all \r with \n.
             */

	    if (bytesInBuffer < space) {
		space = bytesInBuffer;
	    }
	    memcpy((VOID *) result,
		    (VOID *) (bufPtr->buf + bufPtr->nextRemoved),
		    (size_t) space);
	    bufPtr->nextRemoved += space;
	    copied = space;

	    for (end = result + copied; result < end; result++) {
		if (*result == '\r') {
		    *result = '\n';
		}
            }
            break;
	}
        case TCL_TRANSLATE_CRLF: {
	    char *src, *end, *dst;
	    int curByte;
	    
            /*
             * If there is a held-back "\r" at EOF, produce it now.
             */
            
	    if (bytesInBuffer == 0) {
                if ((statePtr->flags & (INPUT_SAW_CR | CHANNEL_EOF)) ==
                        (INPUT_SAW_CR | CHANNEL_EOF)) {
                    result[0] = '\r';
                    statePtr->flags &= ~INPUT_SAW_CR;
                    return 1;
                }
                return 0;
            }

            /*
             * Copy the current chunk and replace "\r\n" with "\n"
             * (but not standalone "\r"!).
             */

	    if (bytesInBuffer < space) {
		space = bytesInBuffer;
	    }
	    memcpy((VOID *) result,
		    (VOID *) (bufPtr->buf + bufPtr->nextRemoved),
		    (size_t) space);
	    bufPtr->nextRemoved += space;
	    copied = space;

	    end = result + copied;
	    dst = result;
	    for (src = result; src < end; src++) {
		curByte = *src;
		if (curByte == '\n') {
                    statePtr->flags &= ~INPUT_SAW_CR;
		} else if (statePtr->flags & INPUT_SAW_CR) {
		    statePtr->flags &= ~INPUT_SAW_CR;
		    *dst = '\r';
		    dst++;
		}
		if (curByte == '\r') {
		    statePtr->flags |= INPUT_SAW_CR;
		} else {
		    *dst = (char) curByte;
		    dst++;
		}
	    }
	    copied = dst - result;
	    break;
	}
        case TCL_TRANSLATE_AUTO: {
	    char *src, *end, *dst;
	    int curByte;
	
            if (bytesInBuffer == 0) {
                return 0;
            }

            /*
             * Loop over the current buffer, converting "\r" and "\r\n"
             * to "\n".
             */

	    if (bytesInBuffer < space) {
		space = bytesInBuffer;
	    }
	    memcpy((VOID *) result,
		    (VOID *) (bufPtr->buf + bufPtr->nextRemoved),
		    (size_t) space);
	    bufPtr->nextRemoved += space;
	    copied = space;

	    end = result + copied;
	    dst = result;
	    for (src = result; src < end; src++) {
		curByte = *src;
		if (curByte == '\r') {
		    statePtr->flags |= INPUT_SAW_CR;
		    *dst = '\n';
		    dst++;
		} else {
		    if ((curByte != '\n') || 
			    !(statePtr->flags & INPUT_SAW_CR)) {
			*dst = (char) curByte;
			dst++;
		    }
		    statePtr->flags &= ~INPUT_SAW_CR;
		}
	    }
	    copied = dst - result;
            break;
	}
        default: {
            panic("unknown eol translation mode");
	}
    }

    /*
     * If an in-stream EOF character is set for this channel, check that
     * the input we copied so far does not contain the EOF char.  If it does,
     * copy only up to and excluding that character.
     */
    
    if (statePtr->inEofChar != 0) {
        for (i = 0; i < copied; i++) {
            if (result[i] == (char) statePtr->inEofChar) {
		/*
		 * Set sticky EOF so that no further input is presented
		 * to the caller.
		 */
		
		statePtr->flags |= (CHANNEL_EOF | CHANNEL_STICKY_EOF);
		statePtr->inputEncodingFlags |= TCL_ENCODING_END;
		copied = i;
                break;
            }
        }
    }

    /*
     * If the current buffer is empty recycle it.
     */

    if (bufPtr->nextRemoved == bufPtr->nextAdded) {
        statePtr->inQueueHead = bufPtr->nextPtr;
        if (statePtr->inQueueHead == (ChannelBuffer *) NULL) {
            statePtr->inQueueTail = (ChannelBuffer *) NULL;
        }
        RecycleBuffer(statePtr, bufPtr, 0);
    }

    /*
     * Return the number of characters copied into the result buffer.
     * This may be different from the number of bytes consumed, because
     * of EOL translations.
     */

    return copied;
}

/*
 *----------------------------------------------------------------------
 *
 * CopyBuffer --
 *
 *	Copy at most one buffer of input to the result space.
 *
 * Results:
 *	Number of bytes stored in the result buffer.  May return
 *	zero if no input is available.
 *
 * Side effects:
 *	Consumes buffered input. May deallocate one buffer.
 *
 *----------------------------------------------------------------------
 */

static int
CopyBuffer(chanPtr, result, space)
    Channel *chanPtr;		/* Channel from which to read input. */
    char *result;		/* Where to store the copied input. */
    int space;			/* How many bytes are available in result
                                 * to store the copied input? */
{
    ChannelBuffer *bufPtr;	/* The buffer from which to copy bytes. */
    int bytesInBuffer;		/* How many bytes are available to be
                                 * copied in the current input buffer? */
    int copied;			/* How many characters were already copied
                                 * into the destination space? */
    
    /*
     * If there is no input at all, return zero. The invariant is that
     * either there is no buffer in the queue, or if the first buffer
     * is empty, it is also the last buffer (and thus there is no
     * input in the queue).  Note also that if the buffer is empty, we
     * don't leave it in the queue, but recycle it.
     */
    
    if (chanPtr->inQueueHead == (ChannelBuffer *) NULL) {
        return 0;
    }
    bufPtr = chanPtr->inQueueHead;
    bytesInBuffer = bufPtr->nextAdded - bufPtr->nextRemoved;

    copied = 0;

    if (bytesInBuffer == 0) {
        RecycleBuffer(chanPtr->state, bufPtr, 0);
	chanPtr->inQueueHead = (ChannelBuffer*) NULL;
	chanPtr->inQueueTail = (ChannelBuffer*) NULL;
        return 0;
    }

    /*
     * Copy the current chunk into the result buffer.
     */

    if (bytesInBuffer < space) {
        space = bytesInBuffer;
    }

    memcpy((VOID *) result,
	   (VOID *) (bufPtr->buf + bufPtr->nextRemoved),
	   (size_t) space);
    bufPtr->nextRemoved += space;
    copied = space;

    /*
     * We don't care about in-stream EOF characters here as the data
     * read here may still flow through one or more transformations,
     * i.e. is not in its final state yet.
     */

    /*
     * If the current buffer is empty recycle it.
     */

    if (bufPtr->nextRemoved == bufPtr->nextAdded) {
        chanPtr->inQueueHead = bufPtr->nextPtr;
        if (chanPtr->inQueueHead == (ChannelBuffer *) NULL) {
            chanPtr->inQueueTail = (ChannelBuffer *) NULL;
        }
        RecycleBuffer(chanPtr->state, bufPtr, 0);
    }

    /*
     * Return the number of characters copied into the result buffer.
     */

    return copied;
}

/*
 *----------------------------------------------------------------------
 *
 * DoWrite --
 *
 *	Puts a sequence of characters into an output buffer, may queue the
 *	buffer for output if it gets full, and also remembers whether the
 *	current buffer is ready e.g. if it contains a newline and we are in
 *	line buffering mode.
 *
 * Results:
 *	The number of bytes written or -1 in case of error. If -1,
 *	Tcl_GetErrno will return the error code.
 *
 * Side effects:
 *	May buffer up output and may cause output to be produced on the
 *	channel.
 *
 *----------------------------------------------------------------------
 */

static int
DoWrite(chanPtr, src, srcLen)
    Channel *chanPtr;			/* The channel to buffer output for. */
    char *src;				/* Data to write. */
    int srcLen;				/* Number of bytes to write. */
{
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    ChannelBuffer *outBufPtr;		/* Current output buffer. */
    int foundNewline;			/* Did we find a newline in output? */
    char *dPtr;
    char *sPtr;				/* Search variables for newline. */
    int crsent;				/* In CRLF eol translation mode,
                                         * remember the fact that a CR was
                                         * output to the channel without
                                         * its following NL. */
    int i;				/* Loop index for newline search. */
    int destCopied;			/* How many bytes were used in this
                                         * destination buffer to hold the
                                         * output? */
    int totalDestCopied;		/* How many bytes total were
                                         * copied to the channel buffer? */
    int srcCopied;			/* How many bytes were copied from
                                         * the source string? */
    char *destPtr;			/* Where in line to copy to? */

    /*
     * If we are in network (or windows) translation mode, record the fact
     * that we have not yet sent a CR to the channel.
     */

    crsent = 0;
    
    /*
     * Loop filling buffers and flushing them until all output has been
     * consumed.
     */

    srcCopied = 0;
    totalDestCopied = 0;

    while (srcLen > 0) {
        
        /*
         * Make sure there is a current output buffer to accept output.
         */

        if (statePtr->curOutPtr == (ChannelBuffer *) NULL) {
            statePtr->curOutPtr = AllocChannelBuffer(statePtr->bufSize);
        }

        outBufPtr = statePtr->curOutPtr;

        destCopied = outBufPtr->bufLength - outBufPtr->nextAdded;
        if (destCopied > srcLen) {
            destCopied = srcLen;
        }
        
        destPtr = outBufPtr->buf + outBufPtr->nextAdded;
        switch (statePtr->outputTranslation) {
            case TCL_TRANSLATE_LF:
                srcCopied = destCopied;
                memcpy((VOID *) destPtr, (VOID *) src, (size_t) destCopied);
                break;
            case TCL_TRANSLATE_CR:
                srcCopied = destCopied;
                memcpy((VOID *) destPtr, (VOID *) src, (size_t) destCopied);
                for (dPtr = destPtr; dPtr < destPtr + destCopied; dPtr++) {
                    if (*dPtr == '\n') {
                        *dPtr = '\r';
                    }
                }
                break;
            case TCL_TRANSLATE_CRLF:
                for (srcCopied = 0, dPtr = destPtr, sPtr = src;
                     dPtr < destPtr + destCopied;
                     dPtr++, sPtr++, srcCopied++) {
                    if (*sPtr == '\n') {
                        if (crsent) {
                            *dPtr = '\n';
                            crsent = 0;
                        } else {
                            *dPtr = '\r';
                            crsent = 1;
                            sPtr--, srcCopied--;
                        }
                    } else {
                        *dPtr = *sPtr;
                    }
                }
                break;
            case TCL_TRANSLATE_AUTO:
                panic("Tcl_Write: AUTO output translation mode not supported");
            default:
                panic("Tcl_Write: unknown output translation mode");
        }

        /*
         * The current buffer is ready for output if it is full, or if it
         * contains a newline and this channel is line-buffered, or if it
         * contains any output and this channel is unbuffered.
         */

        outBufPtr->nextAdded += destCopied;
        if (!(statePtr->flags & BUFFER_READY)) {
            if (outBufPtr->nextAdded == outBufPtr->bufLength) {
                statePtr->flags |= BUFFER_READY;
            } else if (statePtr->flags & CHANNEL_LINEBUFFERED) {
                for (sPtr = src, i = 0, foundNewline = 0;
		     (i < srcCopied) && (!foundNewline);
		     i++, sPtr++) {
                    if (*sPtr == '\n') {
                        foundNewline = 1;
                        break;
                    }
                }
                if (foundNewline) {
                    statePtr->flags |= BUFFER_READY;
                }
            } else if (statePtr->flags & CHANNEL_UNBUFFERED) {
                statePtr->flags |= BUFFER_READY;
            }
        }
        
        totalDestCopied += srcCopied;
        src += srcCopied;
        srcLen -= srcCopied;

        if (statePtr->flags & BUFFER_READY) {
            if (FlushChannel(NULL, chanPtr, 0) != 0) {
                return -1;
            }
        }
    } /* Closes "while" */

    return totalDestCopied;
}

/*
 *----------------------------------------------------------------------
 *
 * CopyEventProc --
 *
 *	This routine is invoked as a channel event handler for
 *	the background copy operation.  It is just a trivial wrapper
 *	around the CopyData routine.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static void
CopyEventProc(clientData, mask)
    ClientData clientData;
    int mask;
{
    (void) CopyData((CopyState *)clientData, mask);
}

/*
 *----------------------------------------------------------------------
 *
 * StopCopy --
 *
 *	This routine halts a copy that is in progress.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Removes any pending channel handlers and restores the blocking
 *	and buffering modes of the channels.  The CopyState is freed.
 *
 *----------------------------------------------------------------------
 */

static void
StopCopy(csPtr)
    CopyState *csPtr;		/* State for bg copy to stop . */
{
    ChannelState *inStatePtr, *outStatePtr;
    int nonBlocking;

    if (!csPtr) {
	return;
    }

    inStatePtr	= csPtr->readPtr->state;
    outStatePtr	= csPtr->writePtr->state;

    /*
     * Restore the old blocking mode and output buffering mode.
     */

    nonBlocking = (csPtr->readFlags & CHANNEL_NONBLOCKING);
    if (nonBlocking != (inStatePtr->flags & CHANNEL_NONBLOCKING)) {
	SetBlockMode(NULL, csPtr->readPtr,
		nonBlocking ? TCL_MODE_NONBLOCKING : TCL_MODE_BLOCKING);
    }
    if (csPtr->readPtr != csPtr->writePtr) {
	if (nonBlocking != (outStatePtr->flags & CHANNEL_NONBLOCKING)) {
	    SetBlockMode(NULL, csPtr->writePtr,
		    nonBlocking ? TCL_MODE_NONBLOCKING : TCL_MODE_BLOCKING);
	}
    }
    outStatePtr->flags &= ~(CHANNEL_LINEBUFFERED | CHANNEL_UNBUFFERED);
    outStatePtr->flags |=
	csPtr->writeFlags & (CHANNEL_LINEBUFFERED | CHANNEL_UNBUFFERED);

    if (csPtr->cmdPtr) {
	Tcl_DeleteChannelHandler((Tcl_Channel)csPtr->readPtr, CopyEventProc,
		(ClientData)csPtr);
	if (csPtr->readPtr != csPtr->writePtr) {
	    Tcl_DeleteChannelHandler((Tcl_Channel)csPtr->writePtr,
		    CopyEventProc, (ClientData)csPtr);
	}
        Tcl_DecrRefCount(csPtr->cmdPtr);
    }
    inStatePtr->csPtr  = NULL;
    outStatePtr->csPtr = NULL;
    ckfree((char*) csPtr);
}

/*
 *----------------------------------------------------------------------
 *
 * StackSetBlockMode --
 *
 *	This function sets the blocking mode for a channel, iterating
 *	through each channel in a stack and updates the state flags.
 *
 * Results:
 *	0 if OK, result code from failed blockModeProc otherwise.
 *
 * Side effects:
 *	Modifies the blocking mode of the channel and possibly generates
 *	an error.
 *
 *----------------------------------------------------------------------
 */

static int
StackSetBlockMode(chanPtr, mode)
    Channel *chanPtr;		/* Channel to modify. */
    int mode;			/* One of TCL_MODE_BLOCKING or
				 * TCL_MODE_NONBLOCKING. */
{
    int result = 0;
    Tcl_DriverBlockModeProc *blockModeProc;

    /*
     * Start at the top of the channel stack
     */

    chanPtr = chanPtr->state->topChanPtr;
    while (chanPtr != (Channel *) NULL) {
	blockModeProc = Tcl_ChannelBlockModeProc(chanPtr->typePtr);
	if (blockModeProc != NULL) {
	    result = (*blockModeProc) (chanPtr->instanceData, mode);
	    if (result != 0) {
		Tcl_SetErrno(result);
		return result;
	    }
	}
	chanPtr = chanPtr->downChanPtr;
    }
    return 0;
}

/*
 *----------------------------------------------------------------------
 *
 * SetBlockMode --
 *
 *	This function sets the blocking mode for a channel and updates
 *	the state flags.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	Modifies the blocking mode of the channel and possibly generates
 *	an error.
 *
 *----------------------------------------------------------------------
 */

static int
SetBlockMode(interp, chanPtr, mode)
    Tcl_Interp *interp;		/* Interp for error reporting. */
    Channel *chanPtr;		/* Channel to modify. */
    int mode;			/* One of TCL_MODE_BLOCKING or
				 * TCL_MODE_NONBLOCKING. */
{
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    int result = 0;

    result = StackSetBlockMode(chanPtr, mode);
    if (result != 0) {
	if (interp != (Tcl_Interp *) NULL) {
	    Tcl_AppendResult(interp, "error setting blocking mode: ",
		    Tcl_PosixError(interp), (char *) NULL);
	}
	return TCL_ERROR;
    }
    if (mode == TCL_MODE_BLOCKING) {
	statePtr->flags &= (~(CHANNEL_NONBLOCKING | BG_FLUSH_SCHEDULED));
    } else {
	statePtr->flags |= CHANNEL_NONBLOCKING;
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetChannelNames --
 *
 *	Return the names of all open channels in the interp.
 *
 * Results:
 *	TCL_OK or TCL_ERROR.
 *
 * Side effects:
 *	Interp result modified with list of channel names.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_GetChannelNames(interp)
    Tcl_Interp *interp;		/* Interp for error reporting. */
{
    return Tcl_GetChannelNamesEx(interp, (char *) NULL);
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetChannelNamesEx --
 *
 *	Return the names of open channels in the interp filtered
 *	filtered through a pattern.  If pattern is NULL, it returns
 *	all the open channels.
 *
 * Results:
 *	TCL_OK or TCL_ERROR.
 *
 * Side effects:
 *	Interp result modified with list of channel names.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_GetChannelNamesEx(interp, pattern)
    Tcl_Interp *interp;		/* Interp for error reporting. */
    char *pattern;		/* pattern to filter on. */
{
    ChannelState *statePtr;
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    char *name;
    Tcl_Obj *resultPtr;

    resultPtr = Tcl_GetObjResult(interp);
    for (statePtr = tsdPtr->firstCSPtr;
	 statePtr != NULL;
	 statePtr = statePtr->nextCSPtr) {
        if (statePtr->topChanPtr == (Channel *) tsdPtr->stdinChannel) {
	    name = "stdin";
	} else if (statePtr->topChanPtr == (Channel *) tsdPtr->stdoutChannel) {
	    name = "stdout";
	} else if (statePtr->topChanPtr == (Channel *) tsdPtr->stderrChannel) {
	    name = "stderr";
	} else {
	    name = statePtr->channelName;
	}
	if (((pattern == NULL) || Tcl_StringMatch(name, pattern)) &&
		(Tcl_ListObjAppendElement(interp, resultPtr,
			Tcl_NewStringObj(name, -1)) != TCL_OK)) {
	    return TCL_ERROR;
	}
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_ChannelName --
 *
 *	Return the name of the channel type.
 *
 * Results:
 *	A pointer the name of the channel type.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

char *
Tcl_ChannelName(chanTypePtr)
    Tcl_ChannelType *chanTypePtr;	/* Pointer to channel type. */
{
    return (chanTypePtr->typeName);
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_ChannelVersion --
 *
 *	Return the of version of the channel type.
 *
 * Results:
 *	TCL_CHANNEL_VERSION_2 or TCL_CHANNEL_VERSION_1.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_ChannelTypeVersion
Tcl_ChannelVersion(chanTypePtr)
    Tcl_ChannelType *chanTypePtr;	/* Pointer to channel type. */
{
    if (chanTypePtr->version == TCL_CHANNEL_VERSION_2) {
	return TCL_CHANNEL_VERSION_2;
    } else {
	/*
	 * In <v2 channel versions, the version field is occupied
	 * by the Tcl_DriverBlockModeProc
	 */
	return TCL_CHANNEL_VERSION_1;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_ChannelBlockModeProc --
 *
 *	Return the Tcl_DriverBlockModeProc of the channel type.
 *
 * Results:
 *	A pointer to the proc.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_DriverBlockModeProc *
Tcl_ChannelBlockModeProc(chanTypePtr)
    Tcl_ChannelType *chanTypePtr;	/* Pointer to channel type. */
{
    if (chanTypePtr->version == TCL_CHANNEL_VERSION_2) {
	return (chanTypePtr->blockModeProc);
    } else {
	return (Tcl_DriverBlockModeProc *) (chanTypePtr->version);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_ChannelCloseProc --
 *
 *	Return the Tcl_DriverCloseProc of the channel type.
 *
 * Results:
 *	A pointer to the proc.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_DriverCloseProc *
Tcl_ChannelCloseProc(chanTypePtr)
    Tcl_ChannelType *chanTypePtr;	/* Pointer to channel type. */
{
    return (chanTypePtr->closeProc);
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_ChannelClose2Proc --
 *
 *	Return the Tcl_DriverClose2Proc of the channel type.
 *
 * Results:
 *	A pointer to the proc.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_DriverClose2Proc *
Tcl_ChannelClose2Proc(chanTypePtr)
    Tcl_ChannelType *chanTypePtr;	/* Pointer to channel type. */
{
    return (chanTypePtr->close2Proc);
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_ChannelInputProc --
 *
 *	Return the Tcl_DriverInputProc of the channel type.
 *
 * Results:
 *	A pointer to the proc.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_DriverInputProc *
Tcl_ChannelInputProc(chanTypePtr)
    Tcl_ChannelType *chanTypePtr;	/* Pointer to channel type. */
{
    return (chanTypePtr->inputProc);
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_ChannelOutputProc --
 *
 *	Return the Tcl_DriverOutputProc of the channel type.
 *
 * Results:
 *	A pointer to the proc.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_DriverOutputProc *
Tcl_ChannelOutputProc(chanTypePtr)
    Tcl_ChannelType *chanTypePtr;	/* Pointer to channel type. */
{
    return (chanTypePtr->outputProc);
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_ChannelSeekProc --
 *
 *	Return the Tcl_DriverSeekProc of the channel type.
 *
 * Results:
 *	A pointer to the proc.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_DriverSeekProc *
Tcl_ChannelSeekProc(chanTypePtr)
    Tcl_ChannelType *chanTypePtr;	/* Pointer to channel type. */
{
    return (chanTypePtr->seekProc);
d5777 1
a5777 1
 * Tcl_ChannelSetOptionProc --
d5779 2
a5780 1
 *	Return the Tcl_DriverSetOptionProc of the channel type.
d5783 1
a5783 1
 *	A pointer to the proc.
d5786 1
a5786 1
 *	None.
d5791 4
a5794 3
Tcl_DriverSetOptionProc *
Tcl_ChannelSetOptionProc(chanTypePtr)
    Tcl_ChannelType *chanTypePtr;	/* Pointer to channel type. */
d5796 170
a5965 1
    return (chanTypePtr->setOptionProc);
d5971 1
a5971 1
 * Tcl_ChannelGetOptionProc --
d5973 3
a5975 1
 *	Return the Tcl_DriverGetOptionProc of the channel type.
d5978 1
a5978 1
 *	A pointer to the proc.
d5986 4
a5989 3
Tcl_DriverGetOptionProc *
Tcl_ChannelGetOptionProc(chanTypePtr)
    Tcl_ChannelType *chanTypePtr;	/* Pointer to channel type. */
d5991 1
a5991 1
    return (chanTypePtr->getOptionProc);
d5997 1
a5997 1
 * Tcl_ChannelWatchProc --
d5999 1
a5999 1
 *	Return the Tcl_DriverWatchProc of the channel type.
d6002 1
a6002 1
 *	A pointer to the proc.
d6005 2
a6006 1
 *	None.
d6011 3
a6013 3
Tcl_DriverWatchProc *
Tcl_ChannelWatchProc(chanTypePtr)
    Tcl_ChannelType *chanTypePtr;	/* Pointer to channel type. */
d6015 5
a6019 18
    return (chanTypePtr->watchProc);
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_ChannelGetHandleProc --
 *
 *	Return the Tcl_DriverGetHandleProc of the channel type.
 *
 * Results:
 *	A pointer to the proc.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
d6021 3
a6023 22
Tcl_DriverGetHandleProc *
Tcl_ChannelGetHandleProc(chanTypePtr)
    Tcl_ChannelType *chanTypePtr;	/* Pointer to channel type. */
{
    return (chanTypePtr->getHandleProc);
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_ChannelFlushProc --
 *
 *	Return the Tcl_DriverFlushProc of the channel type.
 *
 * Results:
 *	A pointer to the proc.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
d6025 15
a6039 22
Tcl_DriverFlushProc *
Tcl_ChannelFlushProc(chanTypePtr)
    Tcl_ChannelType *chanTypePtr;	/* Pointer to channel type. */
{
    return (chanTypePtr->flushProc);
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_ChannelHandlerProc --
 *
 *	Return the Tcl_DriverHandlerProc of the channel type.
 *
 * Results:
 *	A pointer to the proc.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
d6041 12
a6052 5
Tcl_DriverHandlerProc *
Tcl_ChannelHandlerProc(chanTypePtr)
    Tcl_ChannelType *chanTypePtr;	/* Pointer to channel type. */
{
    return (chanTypePtr->handlerProc);
a6053 1

@


1.1.1.3
log
@import tcl 8.4.0
@
text
@d13 1
a13 1
 * RCS: @@(#) $Id: tclIO.c,v 1.57 2002/07/30 18:36:25 andreas_kupries Exp $
d95 2
a96 1
				Channel *chanPtr, char *result, int space));
a106 2
static int              DetachChannel _ANSI_ARGS_((Tcl_Interp *interp,
				Tcl_Channel chan));
d113 1
a113 1
static int		DoWrite _ANSI_ARGS_((Channel *chanPtr, CONST char *src,
a114 4
static int		DoReadChars _ANSI_ARGS_ ((Channel* chan,
				Tcl_Obj* objPtr, int toRead, int appendFlag));
static int		DoWriteChars _ANSI_ARGS_ ((Channel* chan,
				CONST char* src, int len));
a120 2
static int		HaveVersion _ANSI_ARGS_((Tcl_ChannelType *typePtr,
				Tcl_ChannelTypeVersion minimumVersion));
d127 2
a128 2
				Tcl_Obj *objPtr, int charsLeft,
				int *offsetPtr, int *factorPtr));
d137 2
a138 2
				char *dst, CONST char *src,
				int *dstLenPtr, int *srcLenPtr));
d140 2
a141 2
				char *dst, CONST char *src,
				int *dstLenPtr, int *srcLenPtr));
a685 32
 * Tcl_IsStandardChannel --
 *
 *	Test if the given channel is a standard channel.  No attempt
 *	is made to check if the channel or the standard channels
 *	are initialized or otherwise valid.
 *
 * Results:
 *	Returns 1 if true, 0 if false.
 *
 * Side effects:
 *      None.
 *
 *----------------------------------------------------------------------
 */
int 
Tcl_IsStandardChannel(chan)
    Tcl_Channel chan;		/* Channel to check. */
{
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);

    if ((chan == tsdPtr->stdinChannel) 
	|| (chan == tsdPtr->stdoutChannel)
	|| (chan == tsdPtr->stderrChannel)) {
	return 1;
    } else {
	return 0;
    }
}

/*
 *----------------------------------------------------------------------
 *
d721 1
a721 1
    if (statePtr->channelName == (CONST char *) NULL) {
d746 1
a746 5
 *	reference count.  (This all happens in the Tcl_DetachChannel helper
 *	function).
 *	
 *	Finally, if the reference count of the channel drops to zero,
 *	it is deleted.
d752 1
a752 5
 *	Calls Tcl_DetachChannel which deletes the hash entry for a channel 
 *	associated with an interpreter.
 *	
 *	May delete the channel, which can have a variety of consequences,
 *	especially if we are forced to close the channel.
d762 3
d767 31
a797 2
    if (DetachChannel(interp, chan) != TCL_OK) {
        return TCL_OK;
d799 2
a801 2
    statePtr = ((Channel *) chan)->state->bottomChanPtr->state;

d828 1
a828 1
	Tcl_Preserve((ClientData)statePtr);
d830 3
a832 8
	    /* We don't want to re-enter Tcl_Close */
	    if (!(statePtr->flags & CHANNEL_CLOSED)) {
		if (Tcl_Close(interp, chan) != TCL_OK) {
		    statePtr->flags |= CHANNEL_CLOSED;
		    Tcl_Release((ClientData)statePtr);
		    return TCL_ERROR;
		}
	    }
a833 2
        statePtr->flags |= CHANNEL_CLOSED;
	Tcl_Release((ClientData)statePtr);
a838 123
 *----------------------------------------------------------------------
 *
 * Tcl_DetachChannel --
 *
 *	Deletes the hash entry for a channel associated with an interpreter.
 *	If the interpreter given as argument is NULL, it only decrements the
 *	reference count.  Even if the ref count drops to zero, the 
 *	channel is NOT closed or cleaned up.  This allows a channel to
 *	be detached from an interpreter and left in the same state it
 *	was in when it was originally returned by 'Tcl_OpenFileChannel',
 *	for example.
 *	
 *	This function cannot be used on the standard channels, and
 *	will return TCL_ERROR if that is attempted.
 *	
 *	This function should only be necessary for special purposes
 *	in which you need to generate a pristine channel from one
 *	that has already been used.  All ordinary purposes will almost
 *	always want to use Tcl_UnregisterChannel instead.
 *	
 *	Provided the channel is not attached to any other interpreter,
 *	it can then be closed with Tcl_Close, rather than with 
 *	Tcl_UnregisterChannel.
 *
 * Results:
 *	A standard Tcl result.  If the channel is not currently registered
 *	with the given interpreter, TCL_ERROR is returned, otherwise
 *	TCL_OK.  However no error messages are left in the interp's result.
 *
 * Side effects:
 *	Deletes the hash entry for a channel associated with an 
 *	interpreter.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_DetachChannel(interp, chan)
    Tcl_Interp *interp;		/* Interpreter in which channel is defined. */
    Tcl_Channel chan;		/* Channel to delete. */
{
    if (Tcl_IsStandardChannel(chan)) {
        return TCL_ERROR;
    }
    
    return DetachChannel(interp, chan);
}

/*
 *----------------------------------------------------------------------
 *
 * DetachChannel --
 *
 *	Deletes the hash entry for a channel associated with an interpreter.
 *	If the interpreter given as argument is NULL, it only decrements the
 *	reference count.  Even if the ref count drops to zero, the 
 *	channel is NOT closed or cleaned up.  This allows a channel to
 *	be detached from an interpreter and left in the same state it
 *	was in when it was originally returned by 'Tcl_OpenFileChannel',
 *	for example.
 *
 * Results:
 *	A standard Tcl result.  If the channel is not currently registered
 *	with the given interpreter, TCL_ERROR is returned, otherwise
 *	TCL_OK.  However no error messages are left in the interp's result.
 *
 * Side effects:
 *	Deletes the hash entry for a channel associated with an 
 *	interpreter.
 *
 *----------------------------------------------------------------------
 */

static int
DetachChannel(interp, chan)
    Tcl_Interp *interp;		/* Interpreter in which channel is defined. */
    Tcl_Channel chan;		/* Channel to delete. */
{
    Tcl_HashTable *hTblPtr;	/* Hash table of channels. */
    Tcl_HashEntry *hPtr;	/* Search variable. */
    Channel *chanPtr;		/* The real IO channel. */
    ChannelState *statePtr;	/* State of the real channel. */

    /*
     * Always (un)register bottom-most channel in the stack.  This makes
     * management of the channel list easier because no manipulation is
     * necessary during (un)stack operation.
     */
    chanPtr = ((Channel *) chan)->state->bottomChanPtr;
    statePtr = chanPtr->state;

    if (interp != (Tcl_Interp *) NULL) {
	hTblPtr = (Tcl_HashTable *) Tcl_GetAssocData(interp, "tclIO", NULL);
	if (hTblPtr == (Tcl_HashTable *) NULL) {
	    return TCL_ERROR;
	}
	hPtr = Tcl_FindHashEntry(hTblPtr, statePtr->channelName);
	if (hPtr == (Tcl_HashEntry *) NULL) {
	    return TCL_ERROR;
	}
	if ((Channel *) Tcl_GetHashValue(hPtr) != chanPtr) {
	    return TCL_ERROR;
	}
	Tcl_DeleteHashEntry(hPtr);

	/*
	 * Remove channel handlers that refer to this interpreter, so that they
	 * will not be present if the actual close is delayed and more events
	 * happen on the channel. This may occur if the channel is shared
	 * between several interpreters, or if the channel has async
	 * flushing active.
	 */
    
	CleanupChannelHandlers(interp, chanPtr);
    }

    statePtr->refCount--;
    
    return TCL_OK;
}


/*
d862 1
a862 1
    CONST char *chanName;	/* The name of the channel. */
d871 1
a871 1
    CONST char *name;		/* Translated name. */
d940 1
a940 1
    CONST char *chanName;	/* Name of channel to record. */
a962 4
    /*
     * JH: We could subsequently memset these to 0 to avoid the
     * numerous assignments to 0/NULL below.
     */
d976 2
a977 3
	char *tmp = ckalloc((unsigned) (strlen(chanName) + 1));
        statePtr->channelName = tmp;
        strcpy(tmp, chanName);
a1046 11
     *
     * JH: Could call Tcl_SpliceChannel, but need to avoid NULL check.
     */

    statePtr->nextCSPtr	= tsdPtr->firstCSPtr;
    tsdPtr->firstCSPtr	= statePtr;

    /*
     * TIP #10. Mark the current thread as the one managing the new
     *          channel. Note: 'Tcl_GetCurrentThread' returns sensible
     *          values even for a non-threaded core.
d1049 2
a1050 1
    statePtr->managingThread = Tcl_GetCurrentThread ();
a1467 26
 * Tcl_GetChannelThread --
 *
 *	Given a channel structure, returns the thread managing it.
 *	TIP #10
 *
 * Results:
 *	Returns the id of the thread managing the channel.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

Tcl_ThreadId
Tcl_GetChannelThread(chan)
    Tcl_Channel chan;		/* The channel to return managing thread for. */
{
    Channel *chanPtr = (Channel *) chan;	/* The actual channel. */

    return chanPtr->state->managingThread;
}

/*
 *----------------------------------------------------------------------
 *
d1536 1
a1536 1
CONST char *
a1659 11
     * Only save buffers which are at least as big as the requested
     * buffersize for the channel. This is to honor dynamic changes
     * of the buffersize made by the user.
     */

    if ((bufPtr->bufLength - BUFFER_PADDING) < statePtr->bufSize) {
        ckfree((char *) bufPtr);
        return;
    }

    /*
d1868 1
a1868 1
                bufPtr->buf + bufPtr->nextRemoved, toWrite,
a1918 7

		    /*
		     * Casting away CONST here is safe because the
		     * TCL_VOLATILE flag guarantees CONST treatment
		     * of the Posix error string.
		     */

d1920 1
a1920 1
			    (char *) Tcl_PosixError(interp), TCL_VOLATILE);
d2015 3
d2062 8
d2072 1
a2072 1
     * Remove this channel from of the list of all channels.
d2074 20
a2093 1
    Tcl_CutChannel((Tcl_Channel) chanPtr);
d2114 1
a2114 1
	    ckfree((char *) statePtr->channelName);
d2151 17
d2179 1
d2184 1
a2184 4
     * pointers we have and then ourselves.  Since this is the
     * last of the channels in the stack, make sure to free the
     * ChannelState structure associated with it.  We use
     * Tcl_EventuallyFree to allow for any last
a2187 1
    Tcl_EventuallyFree((ClientData) statePtr, TCL_DYNAMIC);
a2195 112
 * Tcl_CutChannel --
 *
 *	Removes a channel from the (thread-)global list of all channels
 *	(in that thread).  This is actually the statePtr for the stack
 *	of channel.
 *
 * Results:
 *	Nothing.
 *
 * Side effects:
 *	Resets the field 'nextCSPtr' of the specified channel state to NULL.
 *
 * NOTE:
 *	The channel to splice out of the list must not be referenced
 *	in any interpreter. This is something this procedure cannot
 *	check (despite the refcount) because the caller usually wants
 *	fiddle with the channel (like transfering it to a different
 *	thread) and thus keeps the refcount artifically high to prevent
 *	its destruction.
 *
 *----------------------------------------------------------------------
 */

void
Tcl_CutChannel(chan)
    Tcl_Channel chan;			/* The channel being removed. Must
                                         * not be referenced in any
                                         * interpreter. */
{
    ThreadSpecificData* tsdPtr  = TCL_TSD_INIT(&dataKey);
    ChannelState *prevCSPtr;		/* Preceding channel state in list of
                                         * all states - used to splice a
                                         * channel out of the list on close. */
    ChannelState *statePtr = ((Channel *) chan)->state;
					/* state of the channel stack. */

    /*
     * Remove this channel from of the list of all channels
     * (in the current thread).
     */

    if (tsdPtr->firstCSPtr && (statePtr == tsdPtr->firstCSPtr)) {
        tsdPtr->firstCSPtr = statePtr->nextCSPtr;
    } else {
        for (prevCSPtr = tsdPtr->firstCSPtr;
	     prevCSPtr && (prevCSPtr->nextCSPtr != statePtr);
	     prevCSPtr = prevCSPtr->nextCSPtr) {
            /* Empty loop body. */
        }
        if (prevCSPtr == (ChannelState *) NULL) {
            panic("FlushChannel: damaged channel list");
        }
        prevCSPtr->nextCSPtr = statePtr->nextCSPtr;
    }

    statePtr->nextCSPtr = (ChannelState *) NULL;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_SpliceChannel --
 *
 *	Adds a channel to the (thread-)global list of all channels
 *	(in that thread). Expects that the field 'nextChanPtr' in
 *	the channel is set to NULL.
 *
 * Results:
 *	Nothing.
 *
 * Side effects:
 *	Nothing.
 *
 * NOTE:
 *	The channel to add to the list must not be referenced in any
 *	interpreter. This is something this procedure cannot check
 *	(despite the refcount) because the caller usually wants figgle
 *	with the channel (like transfering it to a different thread)
 *	and thus keeps the refcount artifically high to prevent its
 *	destruction.
 *
 *----------------------------------------------------------------------
 */

void
Tcl_SpliceChannel(chan)
    Tcl_Channel chan;			/* The channel being added. Must
                                         * not be referenced in any
                                         * interpreter. */
{
    ThreadSpecificData	*tsdPtr = TCL_TSD_INIT(&dataKey);
    ChannelState	*statePtr = ((Channel *) chan)->state;

    if (statePtr->nextCSPtr != (ChannelState *) NULL) {
        panic("Tcl_SpliceChannel: trying to add channel used in different list");
    }

    statePtr->nextCSPtr	= tsdPtr->firstCSPtr;
    tsdPtr->firstCSPtr	= statePtr;

    /*
     * TIP #10. Mark the current thread as the new one managing this
     *          channel. Note: 'Tcl_GetCurrentThread' returns sensible
     *          values even for a non-threaded core.
     */

    statePtr->managingThread = Tcl_GetCurrentThread ();
}

/*
 *----------------------------------------------------------------------
 *
d2223 1
d2226 1
d2230 2
a2259 94
     * When the channel has an escape sequence driven encoding such as
     * iso2022, the terminated escape sequence must write to the buffer.
     */
    if ((statePtr->encoding != NULL) && (statePtr->curOutPtr != NULL)
	    && (CheckChannelErrors(statePtr, TCL_WRITABLE) == 0)) {
        statePtr->outputEncodingFlags |= TCL_ENCODING_END;
        WriteChars(chanPtr, "", 0);
    }

    Tcl_ClearChannelHandlers(chan);

    /*
     * Invoke the registered close callbacks and delete their records.
     */

    while (statePtr->closeCbPtr != (CloseCallback *) NULL) {
        cbPtr = statePtr->closeCbPtr;
        statePtr->closeCbPtr = cbPtr->nextPtr;
        (cbPtr->proc) (cbPtr->clientData);
        ckfree((char *) cbPtr);
    }

    /*
     * Ensure that the last output buffer will be flushed.
     */
    
    if ((statePtr->curOutPtr != (ChannelBuffer *) NULL) &&
	    (statePtr->curOutPtr->nextAdded > statePtr->curOutPtr->nextRemoved)) {
        statePtr->flags |= BUFFER_READY;
    }

    /*
     * If this channel supports it, close the read side, since we don't need it
     * anymore and this will help avoid deadlocks on some channel types.
     */

    if (chanPtr->typePtr->closeProc == TCL_CLOSE2PROC) {
	result = (chanPtr->typePtr->close2Proc)(chanPtr->instanceData, interp,
		TCL_CLOSE_READ);
    } else {
	result = 0;
    }

    /*
     * The call to FlushChannel will flush any queued output and invoke
     * the close function of the channel driver, or it will set up the
     * channel to be flushed and closed asynchronously.
     */

    statePtr->flags |= CHANNEL_CLOSED;
    if ((FlushChannel(interp, chanPtr, 0) != 0) || (result != 0)) {
        return TCL_ERROR;
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_ClearChannelHandlers --
 *
 *	Removes all channel handlers and event scripts from the channel,
 *	cancels all background copies involving the channel and any interest
 *	in events.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	See above. Deallocates memory.
 *
 *----------------------------------------------------------------------
 */

void
Tcl_ClearChannelHandlers (channel)
    Tcl_Channel channel;
{
    ChannelHandler *chPtr, *chNext;	/* Iterate over channel handlers. */
    EventScriptRecord *ePtr, *eNextPtr;	/* Iterate over eventscript records. */
    Channel *chanPtr;			/* The real IO channel. */
    ChannelState *statePtr;		/* State of real IO channel. */
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    NextChannelHandler *nhPtr;

    /*
     * This operation should occur at the top of a channel stack.
     */

    chanPtr	= (Channel *) channel;
    statePtr	= chanPtr->state;
    chanPtr	= statePtr->topChanPtr;

    /*
d2313 44
d2367 1
a2367 4
 *	line buffering mode. Compensates stacking, i.e. will redirect the
 *	data from the specified channel to the topmost channel in a stack.
 *
 *	No encoding conversions are applied to the bytes being read.
d2383 1
a2383 1
    CONST char *src;			/* Data to queue in output buffer. */
d2414 1
a2414 4
 *	line buffering mode. Writes directly to the driver of the channel,
 *	does not compensate for stacking.
 *
 *	No encoding conversions are applied to the bytes being read.
d2430 1
a2430 1
    CONST char *src;			/* Data to queue in output buffer. */
d2470 1
a2470 43
 *	line buffering mode. Compensates stacking, i.e. will redirect the
 *	data from the specified channel to the topmost channel in a stack.
 *
 * Results:
 *	The number of bytes written or -1 in case of error. If -1,
 *	Tcl_GetErrno will return the error code.
 *
 * Side effects:
 *	May buffer up output and may cause output to be produced on the
 *	channel.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_WriteChars(chan, src, len)
    Tcl_Channel chan;		/* The channel to buffer output for. */
    CONST char *src;		/* UTF-8 characters to queue in output buffer. */
    int len;			/* Length of string in bytes, or < 0 for 
				 * strlen(). */
{
    ChannelState *statePtr;	/* state info for channel */

    statePtr = ((Channel *) chan)->state;

    if (CheckChannelErrors(statePtr, TCL_WRITABLE) != 0) {
	return -1;
    }

    return DoWriteChars ((Channel*) chan, src, len);
}

/*
 *---------------------------------------------------------------------------
 *
 * DoWriteChars --
 *
 *	Takes a sequence of UTF-8 characters and converts them for output
 *	using the channel's current encoding, may queue the buffer for
 *	output if it gets full, and also remembers whether the current
 *	buffer is ready e.g. if it contains a newline and we are in
 *	line buffering mode. Compensates stacking, i.e. will redirect the
 *	data from the specified channel to the topmost channel in a stack.
d2483 3
a2485 3
static int
DoWriteChars(chanPtr, src, len)
    Channel* chanPtr;		/* The channel to buffer output for. */
d2493 1
d2496 1
a2496 1
    statePtr = chanPtr->state;
d2499 3
d2606 1
a2606 1
    int dstMax, sawLF, savedLF, total, dstLen, toWrite;
d2694 2
a2695 3
    int saved, savedLF, sawLF, total, dstLen, stageMax, dstWrote;
    int stageLen, toWrite, stageRead, endEncoding, result;
    int consumedSomething;
a2705 6
     * Write the terminated escape sequence even if srcLen is 0.
     */

    endEncoding = ((statePtr->outputEncodingFlags & TCL_ENCODING_END) != 0);

    /*
d2710 1
a2710 3
    consumedSomething = 1;
    while (consumedSomething && (srcLen + savedLF + endEncoding > 0)) {
        consumedSomething = 0;
d2745 5
d2755 1
a2755 1
	while (stageLen + saved + endEncoding > 0) {
d2778 1
a2778 2
	    result = Tcl_UtfToExternal(NULL, encoding, stage, stageLen,
		    statePtr->outputEncodingFlags,
d2781 1
a2781 21

	    /* Fix for SF #506297, reported by Martin Forssen
	     * <ruric@@users.sourceforge.net>.
	     *
	     * The encoding chosen in the script exposing the bug writes out
	     * three intro characters when TCL_ENCODING_START is set, but does
	     * not consume any input as TCL_ENCODING_END is cleared. As some
	     * output was generated the enclosing loop calls UtfToExternal
	     * again, again with START set. Three more characters in the out
	     * and still no use of input ... To break this infinite loop we
	     * remove TCL_ENCODING_START from the set of flags after the first
	     * call (no condition is required, the later calls remove an unset
	     * flag, which is a no-op). This causes the subsequent calls to
	     * UtfToExternal to consume and convert the actual input.
	     */

	    statePtr->outputEncodingFlags &= ~TCL_ENCODING_START;
	    /*
	     * The following code must be executed only when result is not 0.
	     */
	    if (result && ((stageRead + dstWrote) == 0)) {
a2816 12

	    consumedSomething = 1;

	    /*
	     * If all translated characters are written to the buffer,
	     * endEncoding is set to 0 because the escape sequence may be
	     * output.
	     */

	    if ((stageLen + saved == 0) && (result == 0)) {
		endEncoding = 0;
	    }
a2818 9

    /* If nothing was written and it happened because there was no progress
     * in the UTF conversion, we throw an error.
     */

    if (!consumedSomething && (total == 0)) {
        Tcl_SetErrno (EINVAL);
        return -1;
    }
d3078 1
a3078 1
    int inEofChar, skip, copiedTotal, oldLength, oldFlags, oldRemoved;
d3082 1
d3291 1
a3291 1
	    if (eol == objPtr->bytes + oldLength) {
d3293 1
a3293 1
		 * If we didn't append any bytes before encountering EOF,
d3297 1
a3297 1
		Tcl_SetObjLength(objPtr, oldLength);
d3320 2
a3321 3
	    &statePtr->inputEncodingState, dst,
	    eol - dst + skip + TCL_UTF_MAX, &gs.rawRead, NULL,
	    &gs.charsWrote);
d3412 1
a3412 1
#define ENCODING_LINESIZE   20	/* Lower bound on how many bytes to convert
d3441 1
a3441 1

d3494 1
a3494 8
	    &gsPtr->charsWrote);

    /*
     * Make sure that if we go through 'gets', that we reset the
     * TCL_ENCODING_START flag still.  [Bug #523988]
     */
    statePtr->inputEncodingFlags &= ~TCL_ENCODING_START;

d3765 1
a3765 1
    char *bufPtr;		/* Where to store input read. */
d3809 8
a3816 13
	    if ((statePtr->flags & CHANNEL_TIMER_FEV) &&
		(statePtr->flags & CHANNEL_NONBLOCKING)) {
	        nread  = -1;
	        result = EWOULDBLOCK;
	    } else {
	      /*
	       * Now go to the driver to get as much as is possible to
	       * fill the remaining request. Do all the error handling
	       * by ourselves.  The code was stolen from 'GetInput' and
	       * slightly adapted (different return value here).
	       *
	       * The case of 'bytesToRead == 0' at this point cannot happen.
	       */
d3818 1
a3818 1
	      nread = (chanPtr->typePtr->inputProc)(chanPtr->instanceData,
a3819 1
	    }
d3896 6
a3901 2
    Channel*      chanPtr  = (Channel *) chan;
    ChannelState* statePtr = chanPtr->state;	/* state info for channel */
d3910 2
a3911 6
        /*
	 * Update the notifier state so we don't block while there is still
	 * data in the buffers.
	 */
        UpdateInterest(chanPtr);
	return -1;
a3913 48
    return DoReadChars (chanPtr, objPtr, toRead, appendFlag);
}
/*
 *---------------------------------------------------------------------------
 *
 * DoReadChars --
 *
 *	Reads from the channel until the requested number of characters
 *	have been seen, EOF is seen, or the channel would block.  EOL
 *	and EOF translation is done.  If reading binary data, the raw
 *	bytes are wrapped in a Tcl byte array object.  Otherwise, the raw
 *	bytes are converted to UTF-8 using the channel's current encoding
 *	and stored in a Tcl string object.
 *
 * Results:
 *	The number of characters read, or -1 on error. Use Tcl_GetErrno()
 *	to retrieve the error code for the error that occurred.
 *
 * Side effects:
 *	May cause input to be buffered.
 *
 *---------------------------------------------------------------------------
 */
 
static int
DoReadChars(chanPtr, objPtr, toRead, appendFlag)
    Channel* chanPtr;		/* The channel to read. */
    Tcl_Obj *objPtr;		/* Input data is stored in this object. */
    int toRead;			/* Maximum number of characters to store,
				 * or -1 to read all available data (up to EOF
				 * or when channel blocks). */
    int appendFlag;		/* If non-zero, data read from the channel
				 * will be appended to the object.  Otherwise,
				 * the data will replace the existing contents
				 * of the object. */

{
    ChannelState *statePtr = chanPtr->state;	/* state info for channel */
    ChannelBuffer *bufPtr;
    int offset, factor, copied, copiedNow, result;
    Tcl_Encoding encoding;
#define UTF_EXPANSION_FACTOR	1024
    
    /*
     * This operation should occur at the top of a channel stack.
     */

    chanPtr  = statePtr->topChanPtr;
d3915 1
a3915 1
    factor   = UTF_EXPANSION_FACTOR;
d3954 1
a3954 1
		    statePtr->inQueueTail = NULL;
d4026 8
a4038 8
    int bytesToRead;		/* Maximum number of bytes to store,
				 * or < 0 to get all available bytes.
				 * Bytes are obtained from the first
				 * buffer in the queue -- even if this number
				 * is larger than the number of bytes
				 * available in the first buffer, only the
				 * bytes from the first buffer are
				 * returned. */
d4044 1
a4044 1
    int toRead, srcLen, offset, length, srcRead, dstWrote;
a4129 4
    Tcl_Obj *objPtr;		/* Input data is appended to this object.
				 * objPtr->length is how much space has been
				 * allocated to hold data, not how many bytes
				 * of data have been stored in the object. */
d4138 4
d4152 2
a4153 2
    int toRead, factor, offset, spaceLeft, length, srcLen, dstNeeded;
    int srcRead, dstWrote, numChars, dstRead;
d4166 1
a4166 1
    if ((unsigned)toRead > (unsigned)srcLen) {
d4248 5
a4252 14
	    if (srcLen > 0) {
	        /*
		 * There isn't enough data in the buffers to complete the next
		 * character, so we need to wait for more data before the next
		 * file event can be delivered.
		 *
		 * SF #478856.
		 *
		 * The exception to this is if the input buffer was
		 * completely empty before we tried to convert its
		 * contents. Nothing in, nothing out, and no incomplete
		 * character data. The conversion before the current one
		 * was complete.
		 */
d4254 1
a4254 2
	        statePtr->flags |= CHANNEL_NEED_MORE_DATA;
	    }
d4269 1
a4269 3
	 * EOF was located in dst? Run the conversion again with an
	 * output buffer just big enough to hold the data so we can
	 * get the correct value for srcRead.
d4295 1
a4295 1
	CONST char *eof;
d4508 1
a4508 1
    CONST char *str;		/* The input itself. */
a4756 13

	/*
	 * Check the actual buffersize against the requested
	 * buffersize. Buffers which are smaller than requested are
	 * squashed. This is done to honor dynamic changes of the
	 * buffersize made by the user.
	 */

	if ((bufPtr != NULL) && ((bufPtr->bufLength - BUFFER_PADDING) < statePtr->bufSize)) {
	  ckfree((char *) bufPtr);
	  bufPtr = NULL;
	}

d4762 1
a4762 15
	/* SF #427196: Use the actual size of the buffer to determine
	 * the number of bytes to read from the channel and not the
	 * size for new buffers. They can be different if the
	 * buffersize was changed between reads.
	 *
	 * Note: This affects performance negatively if the buffersize
	 * was extended but this small buffer is reused for all
	 * subsequent reads. The system never uses buffers with the
	 * requested bigger size in that case. An adjunct patch could
	 * try and delete all unused buffers it encounters and which
	 * are smaller than the formally requested buffersize.
	 */

	toRead = bufPtr->bufLength - bufPtr->nextAdded;

d4770 1
a4770 1

d4780 2
a4781 8
    if ((statePtr->flags & CHANNEL_TIMER_FEV) &&
	(statePtr->flags & CHANNEL_NONBLOCKING)) {
        nread = -1;
        result = EWOULDBLOCK;
    } else {
        nread = (chanPtr->typePtr->inputProc)(chanPtr->instanceData,
		    bufPtr->buf + bufPtr->nextAdded, toRead, &result);
    }
d4806 1
a4806 1
    }
d4828 1
a4828 1
Tcl_WideInt
d4831 1
a4831 1
    Tcl_WideInt offset;		/* Offset to seek to. */
d4836 1
a4837 1
				/* # bytes held in buffers. */
d4839 1
a4839 1
    Tcl_WideInt curPos;		/* Position on the device. */
d4845 1
a4845 1
	return Tcl_LongAsWide(-1);
d4855 1
a4855 3
    if (CheckForDeadChannel(NULL, statePtr)) {
	return Tcl_LongAsWide(-1);
    }
d4870 1
a4870 1
        return Tcl_LongAsWide(-1);
d4878 27
a4904 2
    inputBuffered = Tcl_InputBuffered(chan);
    outputBuffered = Tcl_OutputBuffered(chan);
d4908 1
a4908 1
        return Tcl_LongAsWide(-1);
d4947 1
a4947 1
	    return Tcl_LongAsWide(-1);
d4969 1
a4969 2
         * caller.  Note that we prefer the wideSeekProc if that is
	 * available and non-NULL...
d4972 5
a4976 16
	if (HaveVersion(chanPtr->typePtr, TCL_CHANNEL_VERSION_3) &&
		chanPtr->typePtr->wideSeekProc != NULL) {
	    curPos = (chanPtr->typePtr->wideSeekProc) (chanPtr->instanceData,
		    offset, mode, &result);
	} else if (offset < Tcl_LongAsWide(LONG_MIN) ||
		offset > Tcl_LongAsWide(LONG_MAX)) {
	    Tcl_SetErrno(EOVERFLOW);
	    curPos = Tcl_LongAsWide(-1);
	} else {
	    curPos = Tcl_LongAsWide((chanPtr->typePtr->seekProc) (
		    chanPtr->instanceData, Tcl_WideAsLong(offset), mode,
		    &result));
	    if (curPos == Tcl_LongAsWide(-1)) {
		Tcl_SetErrno(result);
	    }
	}
d4990 1
a4990 1
	    return Tcl_LongAsWide(-1);
d5016 1
a5016 1
Tcl_WideInt
d5022 2
a5023 1
    int inputBuffered, outputBuffered;	/* # bytes held in buffers. */
d5025 1
a5025 1
    Tcl_WideInt curPos;			/* Position on device. */
d5028 1
a5028 1
	return Tcl_LongAsWide(-1);
d5039 1
a5039 1
	return Tcl_LongAsWide(-1);
d5055 1
a5055 1
        return Tcl_LongAsWide(-1);
d5063 16
a5078 2
    inputBuffered = Tcl_InputBuffered(chan);
    outputBuffered = Tcl_OutputBuffered(chan);
d5082 1
a5082 1
        return Tcl_LongAsWide(-1);
d5087 1
a5087 2
     * where the next character will be read or written.  Note that we
     * prefer the wideSeekProc if that is available and non-NULL...
d5090 3
a5092 9
    if (HaveVersion(chanPtr->typePtr, TCL_CHANNEL_VERSION_3) &&
	    chanPtr->typePtr->wideSeekProc != NULL) {
	curPos = (chanPtr->typePtr->wideSeekProc) (chanPtr->instanceData,
		Tcl_LongAsWide(0), SEEK_CUR, &result);
    } else {
	curPos = Tcl_LongAsWide((chanPtr->typePtr->seekProc) (
		chanPtr->instanceData, 0, SEEK_CUR, &result));
    }
    if (curPos == Tcl_LongAsWide(-1)) {
d5094 1
a5094 1
        return Tcl_LongAsWide(-1);
d5097 1
a5097 1
        return curPos - inputBuffered;
d5099 1
a5099 43
    return curPos + outputBuffered;
}

/*
 *---------------------------------------------------------------------------
 *
 * Tcl_SeekOld, Tcl_TellOld --
 *
 *	Backward-compatability versions of the seek/tell interface that
 *	do not support 64-bit offsets.  This interface is not documented
 *	or expected to be supported indefinitely.
 *
 * Results:
 *	As for Tcl_Seek and Tcl_Tell respectively, except truncated to
 *	whatever value will fit in an 'int'.
 *
 * Side effects:
 *	As for Tcl_Seek and Tcl_Tell respectively.
 *
 *---------------------------------------------------------------------------
 */

int
Tcl_SeekOld(chan, offset, mode)
    Tcl_Channel chan;		/* The channel on which to seek. */
    int offset;			/* Offset to seek to. */
    int mode;			/* Relative to which location to seek? */
{
    Tcl_WideInt wOffset, wResult;

    wOffset = Tcl_LongAsWide((long)offset);
    wResult = Tcl_Seek(chan, wOffset, mode);
    return (int)Tcl_WideAsLong(wResult);
}

int
Tcl_TellOld(chan)
    Tcl_Channel chan;		/* The channel to return pos for. */
{
    Tcl_WideInt wResult;

    wResult = Tcl_Tell(chan);
    return (int)Tcl_WideAsLong(wResult);
d5180 1
a5180 1

a5292 42
 * Tcl_OutputBuffered --
 *
 *    Returns the number of bytes of output currently buffered in the
 *    common internal buffer of a channel.
 *
 * Results:
 *    The number of output bytes buffered, or zero if the channel is not
 *    open for writing.
 *
 * Side effects:
 *    None.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_OutputBuffered(chan)
    Tcl_Channel chan;                 /* The channel to query. */
{
    ChannelState *statePtr = ((Channel *) chan)->state;
                                      /* State of real channel structure. */
    ChannelBuffer *bufPtr;
    int bytesBuffered;

    for (bytesBuffered = 0, bufPtr = statePtr->outQueueHead;
	bufPtr != (ChannelBuffer *) NULL;
	bufPtr = bufPtr->nextPtr) {
	bytesBuffered += (bufPtr->nextAdded - bufPtr->nextRemoved);
    }
    if ((statePtr->curOutPtr != (ChannelBuffer *) NULL) &&
	(statePtr->curOutPtr->nextAdded > statePtr->curOutPtr->nextRemoved)) {
	statePtr->flags |= BUFFER_READY;
	bytesBuffered +=
	    (statePtr->curOutPtr->nextAdded - statePtr->curOutPtr->nextRemoved);
    }

    return bytesBuffered;
}

/*
 *----------------------------------------------------------------------
 *
d5434 2
a5435 2
    CONST char *optionName;		/* 'bad option' name */
    CONST char *optionList;		/* Specific options list to append 
d5444 1
a5444 1
	CONST char **argv;
d5449 1
a5449 1
	Tcl_DStringAppend(&ds, genericopt, -1);
d5497 1
a5497 1
    CONST char *optionName;	/* Option to get. */
a5631 4
        if ( !(flags & (TCL_READABLE|TCL_WRITABLE))) {
            /* Not readable or writable (server socket) */
            Tcl_DStringAppendElement(dsPtr, "");
        }
a5671 4
        if ( !(flags & (TCL_READABLE|TCL_WRITABLE))) {
            /* Not readable or writable (server socket) */
            Tcl_DStringAppendElement(dsPtr, "auto");
        }
d5721 2
a5722 2
    CONST char *optionName;	/* Which option to set? */
    CONST char *newValue;	/* New value for option. */
d5724 1
d5729 1
a5729 1
    CONST char **argv;
a5764 1
	int newMode;
a5814 9
	/*
	 * When the channel has an escape sequence driven encoding such as
	 * iso2022, the terminated escape sequence must write to the buffer.
	 */
	if ((statePtr->encoding != NULL) && (statePtr->curOutPtr != NULL)
		&& (CheckChannelErrors(statePtr, TCL_WRITABLE) == 0)) {
	    statePtr->outputEncodingFlags |= TCL_ENCODING_END;
	    WriteChars(chanPtr, "", 0);
	}
d5841 2
a5842 2
                        "bad value for -eofchar: should be a list of zero,",
                        " one, or two elements", (char *) NULL);
d5854 1
a5854 1
        if (argv != NULL) {
d5860 1
a5860 1
	CONST char *readMode, *writeMode;
a5882 1
	    TclEolTranslation translation;
d5884 1
a5884 1
		translation = statePtr->inputTranslation;
d5886 1
a5886 1
		translation = TCL_TRANSLATE_AUTO;
d5888 1
a5888 1
		translation = TCL_TRANSLATE_LF;
d5893 1
a5893 1
		translation = TCL_TRANSLATE_LF;
d5895 1
a5895 1
		translation = TCL_TRANSLATE_CR;
d5897 1
a5897 1
		translation = TCL_TRANSLATE_CRLF;
d5899 1
a5899 1
		translation = TCL_PLATFORM_TRANSLATION;
d5917 2
a5918 2
	    if (translation != statePtr->inputTranslation) {
		statePtr->inputTranslation = translation;
d5935 1
a5935 1
		if (strcmp(Tcl_ChannelName(chanPtr->typePtr), "tcp") == 0) {
d6093 1
a6109 2
	Tcl_DriverHandlerProc* upHandlerProc;

d6112 9
a6120 3
	upHandlerProc = Tcl_ChannelHandlerProc(upTypePtr);
	if (upHandlerProc != NULL) {
	    mask = (*upHandlerProc) (upChanPtr->instanceData, mask);
a6150 1
    Tcl_Preserve((ClientData) statePtr);
d6160 2
a6161 2
	FlushChannel(NULL, chanPtr, 1);
	mask &= ~TCL_WRITABLE;
a6173 4
	/*
	 * If this channel handler is interested in any of the events that
	 * have occurred on the channel, invoke its procedure.
	 */
d6175 12
a6186 7
	if ((chPtr->mask & mask) != 0) {
	    nh.nextHandlerPtr = chPtr->nextPtr;
	    (*(chPtr->proc))(chPtr->clientData, mask);
	    chPtr = nh.nextHandlerPtr;
	} else {
	    chPtr = chPtr->nextPtr;
	}
a6198 1
    Tcl_Release((ClientData) statePtr);
d6202 73
a6367 13

	/* Set the TIMER flag to notify the higher levels that the
	 * driver might have no data for us. We do this only if we are
	 * in non-blocking mode and the driver has no BlockModeProc
	 * because only then we really don't know if the driver will
	 * block or not. A similar test is done in "PeekAhead".
	 */

	if ((statePtr->flags & CHANNEL_NONBLOCKING) &&
	    (Tcl_ChannelBlockModeProc(chanPtr->typePtr) == NULL)) {
	    statePtr->flags |= CHANNEL_TIMER_FEV;
	}
	Tcl_Preserve((ClientData) statePtr);
d6369 1
a6369 3

	statePtr->flags &= ~CHANNEL_TIMER_FEV; 
	Tcl_Release((ClientData) statePtr);
d6759 1
a6759 1
    static CONST char *modeOptions[] = {"readable", "writable", NULL};
d6892 1
a6892 1
		    nonBlocking ? TCL_MODE_NONBLOCKING : TCL_MODE_BLOCKING)
d6963 1
a6963 1
    Tcl_Obj *cmdPtr, *errObj = NULL, *bufObj = NULL;
d6966 3
a6968 5
    int result = TCL_OK, size, total, sizeb;
    char* buffer;

    int inBinary, outBinary, sameEncoding; /* Encoding control */
    int underflow;	/* input underflow */
d6985 1
a6985 8
    inBinary     = (inStatePtr->encoding  == NULL);
    outBinary    = (outStatePtr->encoding == NULL);
    sameEncoding = (inStatePtr->encoding  == outStatePtr->encoding);

    if (!(inBinary || sameEncoding)) {
        bufObj = Tcl_NewObj ();
	Tcl_IncrRefCount (bufObj);
    }
a6986 1
    while (csPtr->toRead != 0) {
d7007 1
a7007 1
	    sizeb = csPtr->bufSize;
d7009 1
a7009 1
	    sizeb = csPtr->toRead;
d7011 1
a7011 7

	if (inBinary || sameEncoding) {
	    size = DoRead(inStatePtr->topChanPtr, csPtr->buffer, sizeb);
	} else {
	    size = DoReadChars(inStatePtr->topChanPtr, bufObj, sizeb, 0 /* No append */);
	}
	underflow = (size >= 0) && (size < sizeb);	/* input underflow */
d7020 1
a7020 1
	} else if (underflow) {
d7027 1
a7027 1
	    if ((size == 0) && Tcl_Eof(inChan)) {
d7029 1
a7029 2
	    }
	    if (! Tcl_Eof(inChan) && !(mask & TCL_READABLE)) {
d7037 1
a7037 7
	    if (size == 0) {
	        if (bufObj != (Tcl_Obj*) NULL) {
		    Tcl_DecrRefCount (bufObj);
		    bufObj = (Tcl_Obj*) NULL;
		}
		return TCL_OK;
	    }
d7044 2
a7045 19
	if (inBinary || sameEncoding) {
	    buffer = csPtr->buffer;
	    sizeb = size;
	} else {
	    buffer = Tcl_GetStringFromObj (bufObj, &sizeb);
	}

	if (outBinary || sameEncoding) {
	    sizeb = DoWrite(outStatePtr->topChanPtr, buffer, sizeb);
	} else {
	    sizeb = DoWriteChars(outStatePtr->topChanPtr, buffer, sizeb);
	}

	if (inBinary || sameEncoding) {
	    /* Both read and write counted bytes */
	    size = sizeb;
	} /* else : Read counted characters, write counted bytes, i.e. size != sizeb */

	if (sizeb < 0) {
a7054 20
	 * Update the current byte count.  Do it now so the count is
	 * valid before a return or break takes us out of the loop.
	 * The invariant at the top of the loop should be that 
	 * csPtr->toRead holds the number of bytes left to copy.
	 */

	if (csPtr->toRead != -1) {
	    csPtr->toRead -= size;
	}
	csPtr->total += size;

	/*
	 * Break loop if EOF && (size>0)
	 */

        if (Tcl_Eof(inChan)) {
            break;
        }

	/*
a7056 2
	 * After input underflow we already installed a readable handler
	 * therefore we don't need a writable handler.
d7059 1
a7059 1
	if ( ! underflow && (outStatePtr->flags & BG_FLUSH_SCHEDULED) ) {
d7062 1
a7062 1
		    Tcl_DeleteChannelHandler(inChan, CopyEventProc,
a7067 4
	    if (bufObj != (Tcl_Obj*) NULL) {
	        Tcl_DecrRefCount (bufObj);
		bufObj = (Tcl_Obj*) NULL;
	    }
d7072 9
a7094 4
	    if (bufObj != (Tcl_Obj*) NULL) {
	        Tcl_DecrRefCount (bufObj);
		bufObj = (Tcl_Obj*) NULL;
	    }
a7096 5
    } /* while */

    if (bufObj != (Tcl_Obj*) NULL) {
        Tcl_DecrRefCount (bufObj);
	bufObj = (Tcl_Obj*) NULL;
a7146 2
 *	No encoding conversions are applied to the bytes being read.
 *
d7571 1
a7571 1
    CONST char *src;			/* Data to write. */
d7578 1
a7578 1
    CONST char *sPtr;			/* Search variables for newline. */
a7771 1
	nonBlocking = (csPtr->writeFlags & CHANNEL_NONBLOCKING);
d7929 1
a7929 1
    CONST char *pattern;	/* pattern to filter on. */
d7931 1
d7933 2
a7934 6
    ChannelState *statePtr;
    CONST char *name;		/* name for channel */
    Tcl_Obj *resultPtr;		/* pointer to result object */
    Tcl_HashTable *hTblPtr;	/* Hash table of channels. */
    Tcl_HashEntry *hPtr;	/* Search variable. */
    Tcl_HashSearch hSearch;	/* Search variable. */
d7936 4
a7939 16
    if (interp == (Tcl_Interp *) NULL) {
	return TCL_OK;
    }

    /*
     * Get the channel table that stores the channels registered
     * for this interpreter.
     */
    hTblPtr	= GetChannelTable(interp);
    resultPtr	= Tcl_GetObjResult(interp);

    for (hPtr = Tcl_FirstHashEntry(hTblPtr, &hSearch);
	 hPtr != (Tcl_HashEntry *) NULL;
	 hPtr = Tcl_NextHashEntry(&hSearch)) {

	statePtr = ((Channel *) Tcl_GetHashValue(hPtr))->state;
a7946 4
	    /*
	     * This is also stored in Tcl_GetHashKey(hTblPtr, hPtr),
	     * but it's simpler to just grab the name from the statePtr.
	     */
a7948 1

a7960 125
 * Tcl_IsChannelRegistered --
 *
 *	Checks whether the channel is associated with the interp.
 *	See also Tcl_RegisterChannel and Tcl_UnregisterChannel.
 *
 * Results:
 *	0 if the channel is not registered in the interpreter, 1 else.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_IsChannelRegistered (interp, chan)
     Tcl_Interp* interp;	/* The interp to query of the channel */
     Tcl_Channel chan;		/* The channel to check */
{
    Tcl_HashTable	*hTblPtr;	/* Hash table of channels. */
    Tcl_HashEntry	*hPtr;		/* Search variable. */
    Channel		*chanPtr;	/* The real IO channel. */
    ChannelState	*statePtr;	/* State of the real channel. */

    /*
     * Always check bottom-most channel in the stack.  This is the one
     * that gets registered.
     */
    chanPtr = ((Channel *) chan)->state->bottomChanPtr;
    statePtr = chanPtr->state;

    hTblPtr = (Tcl_HashTable *) Tcl_GetAssocData(interp, "tclIO", NULL);
    if (hTblPtr == (Tcl_HashTable *) NULL) {
        return 0;
    }
    hPtr = Tcl_FindHashEntry(hTblPtr, statePtr->channelName);
    if (hPtr == (Tcl_HashEntry *) NULL) {
        return 0;
    }
    if ((Channel *) Tcl_GetHashValue(hPtr) != chanPtr) {
        return 0;
    }

    return 1;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_IsChannelShared --
 *
 *	Checks whether the channel is shared by multiple interpreters.
 *
 * Results:
 *	A boolean value (0 = Not shared, 1 = Shared).
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_IsChannelShared (chan)
    Tcl_Channel chan;	/* The channel to query */
{
    ChannelState *statePtr = ((Channel *) chan)->state;
					/* State of real channel structure. */

    return ((statePtr->refCount > 1) ? 1 : 0);
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_IsChannelExisting --
 *
 *	Checks whether a channel of the given name exists in the
 *	(thread)-global list of all channels.
 *	See Tcl_GetChannelNamesEx for function exposed at the Tcl level.
 *
 * Results:
 *	A boolean value (0 = Does not exist, 1 = Does exist).
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_IsChannelExisting(chanName)
    CONST char* chanName;	/* The name of the channel to look for. */
{
    ChannelState *statePtr;
    ThreadSpecificData *tsdPtr = TCL_TSD_INIT(&dataKey);
    CONST char *name;
    int chanNameLen;

    chanNameLen = strlen(chanName);
    for (statePtr = tsdPtr->firstCSPtr;
	 statePtr != NULL;
	 statePtr = statePtr->nextCSPtr) {
        if (statePtr->topChanPtr == (Channel *) tsdPtr->stdinChannel) {
	    name = "stdin";
	} else if (statePtr->topChanPtr == (Channel *) tsdPtr->stdoutChannel) {
	    name = "stdout";
	} else if (statePtr->topChanPtr == (Channel *) tsdPtr->stderrChannel) {
	    name = "stderr";
	} else {
	    name = statePtr->channelName;
	}

	if ((*chanName == *name) &&
		(memcmp(name, chanName, (size_t) chanNameLen) == 0)) {
	    return 1;
	}
    }

    return 0;
}

/*
 *----------------------------------------------------------------------
 *
d7974 1
a7974 1
CONST char *
d7978 1
a7978 1
    return chanTypePtr->typeName;
d7989 1
a7989 1
 *	One of the TCL_CHANNEL_VERSION_* constants from tcl.h
a8002 2
    } else if (chanTypePtr->version == TCL_CHANNEL_VERSION_3) {
	return TCL_CHANNEL_VERSION_3;
a8014 27
 * HaveVersion --
 *
 *	Return whether a channel type is (at least) of a given version.
 *
 * Results:
 *	True if the minimum version is exceeded by the version actually
 *	present.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

int
HaveVersion(chanTypePtr, minimumVersion)
    Tcl_ChannelType *chanTypePtr;
    Tcl_ChannelTypeVersion minimumVersion;
{
    Tcl_ChannelTypeVersion actualVersion = Tcl_ChannelVersion(chanTypePtr);

    return ((int)actualVersion) >= ((int)minimumVersion);
}

/*
 *----------------------------------------------------------------------
 *
d8025 2
a8026 1
 *---------------------------------------------------------------------- */
d8032 2
a8033 2
    if (HaveVersion(chanTypePtr, TCL_CHANNEL_VERSION_2)) {
	return chanTypePtr->blockModeProc;
a8034 3
	/*
	 * The v1 structure had the blockModeProc in a different place.
	 */
d8059 1
a8059 1
    return chanTypePtr->closeProc;
d8082 1
a8082 1
    return chanTypePtr->close2Proc;
d8105 1
a8105 1
    return chanTypePtr->inputProc;
d8128 1
a8128 1
    return chanTypePtr->outputProc;
d8151 1
a8151 1
    return chanTypePtr->seekProc;
d8174 1
a8174 1
    return chanTypePtr->setOptionProc;
d8197 1
a8197 1
    return chanTypePtr->getOptionProc;
d8220 1
a8220 1
    return chanTypePtr->watchProc;
d8243 1
a8243 1
    return chanTypePtr->getHandleProc;
d8266 1
a8266 5
    if (HaveVersion(chanTypePtr, TCL_CHANNEL_VERSION_2)) {
	return chanTypePtr->flushProc;
    } else {
	return NULL;
    }
d8289 1
a8289 5
    if (HaveVersion(chanTypePtr, TCL_CHANNEL_VERSION_2)) {
	return chanTypePtr->handlerProc;
    } else {
	return NULL;
    }
a8290 16

/*
 *----------------------------------------------------------------------
 *
 * Tcl_ChannelWideSeekProc --
 *
 *	Return the Tcl_DriverWideSeekProc of the channel type.
 *
 * Results:
 *	A pointer to the proc.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */
a8291 10
Tcl_DriverWideSeekProc *
Tcl_ChannelWideSeekProc(chanTypePtr)
    Tcl_ChannelType *chanTypePtr;	/* Pointer to channel type. */
{
    if (HaveVersion(chanTypePtr, TCL_CHANNEL_VERSION_3)) {
	return chanTypePtr->wideSeekProc;
    } else {
	return NULL;
    }
}
@


