head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.58
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.56
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.54
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.52
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.50
	gdb_7_0-branch:1.5.0.48
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tcl8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.46
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.44
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.42
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.40
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.38
	gdb_6_5-2006-05-14-branchpoint:1.5
	readline_5_1-import-branch:1.5.0.36
	readline_5_1-import-branchpoint:1.5
	gdb_6_4-branch:1.5.0.34
	gdb_6_4-2005-11-01-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.32
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	ezannoni_pie-20040323-branch:1.5.0.30
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.28
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.26
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.24
	cagney_x86i386-20030821-branch:1.5.0.22
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.20
	gdb_6_0-2003-06-23-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.18
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.16
	cagney_writestrings-20030508-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.14
	cagney_fileio-20030521-branchpoint:1.5
	carlton_dictionary-20030430-merge:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.12
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.10
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.8
	cagney_lazyid-20030317-branchpoint:1.5
	offbyone-20030313-branch:1.5.0.6
	offbyone-20030313-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.4
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.2
	interps-20030202-branchpoint:1.5
	TCL8_4_1:1.1.1.3
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.2
	TCL_8_4_1:1.1.1.3
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.4
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TCL_8_4_0:1.1.1.3
	carlton_dictionary-branch:1.2.0.16
	carlton_dictionary-20020920-branchpoint:1.2
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.14
	gdb_5_3-branch:1.2.0.12
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.10
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.8
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.6
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TCL_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	dejagnu-2000-02-04:1.1.1.1
	dejagnu-2000-01-31:1.1.1.1
	dejagnu-2000-01-24:1.1.1.1
	dejagnu-2000-01-17:1.1.1.1
	dejagnu-2000-01-10:1.1.1.1
	dejagnu-2000-01-04:1.1.1.1
	dejagnu-1999-12-21:1.1.1.1
	dejagnu-1999-12-13:1.1.1.1
	dejagnu-1999-12-07:1.1.1.1
	dejagnu-1999-12-06:1.1.1.1
	dejagnu-1999-11-15:1.1.1.1
	dejagnu-1999-11-08:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.5
date	2003.01.21.19.40.02;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.26.19.47.51;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.37.02;	author kseitz;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2001.09.09.23.56.04;	author irox;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	99.11.09.01.28.43;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2002.09.27.21.49.02;	author kseitz;	state Exp;
branches;
next	;

1.3.4.1
date	2003.12.14.20.28.42;	author drow;	state Exp;
branches;
next	;

1.2.16.1
date	2002.12.23.19.40.17;	author carlton;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2003.02.07.19.18.10;	author carlton;	state Exp;
branches;
next	;

1.1.1.1
date	99.11.09.01.28.43;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.09.22.40.54;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.19.55.55;	author kseitz;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tcl 8.4.1
@
text
@/* 
 * tclCmdIL.c --
 *
 *	This file contains the top-level command routines for most of
 *	the Tcl built-in commands whose names begin with the letters
 *	I through L.  It contains only commands in the generic core
 *	(i.e. those that don't depend much upon UNIX facilities).
 *
 * Copyright (c) 1987-1993 The Regents of the University of California.
 * Copyright (c) 1993-1997 Lucent Technologies.
 * Copyright (c) 1994-1997 Sun Microsystems, Inc.
 * Copyright (c) 1998-1999 by Scriptics Corporation.
 * Copyright (c) 2001 by Kevin B. Kenny.  All rights reserved.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tclCmdIL.c,v 1.44 2002/06/11 13:22:36 msofer Exp $
 */

#include "tclInt.h"
#include "tclPort.h"
#include "tclRegexp.h"

/*
 * During execution of the "lsort" command, structures of the following
 * type are used to arrange the objects being sorted into a collection
 * of linked lists.
 */

typedef struct SortElement {
    Tcl_Obj *objPtr;			/* Object being sorted. */
    int count;				/* number of same elements in list */
    struct SortElement *nextPtr;        /* Next element in the list, or
					 * NULL for end of list. */
} SortElement;

/*
 * The "lsort" command needs to pass certain information down to the
 * function that compares two list elements, and the comparison function
 * needs to pass success or failure information back up to the top-level
 * "lsort" command.  The following structure is used to pass this
 * information.
 */

typedef struct SortInfo {
    int isIncreasing;		/* Nonzero means sort in increasing order. */
    int sortMode;		/* The sort mode.  One of SORTMODE_*
				 * values defined below */
    Tcl_Obj *compareCmdPtr;     /* The Tcl comparison command when sortMode
				 * is SORTMODE_COMMAND.  Pre-initialized to
				 * hold base of command.*/
    int index;			/* If the -index option was specified, this
				 * holds the index of the list element
				 * to extract for comparison.  If -index
				 * wasn't specified, this is -1. */
    Tcl_Interp *interp;		/* The interpreter in which the sortis
				 * being done. */
    int resultCode;		/* Completion code for the lsort command.
				 * If an error occurs during the sort this
				 * is changed from TCL_OK to  TCL_ERROR. */
} SortInfo;

/*
 * The "sortMode" field of the SortInfo structure can take on any of the
 * following values.
 */

#define SORTMODE_ASCII      0
#define SORTMODE_INTEGER    1
#define SORTMODE_REAL       2
#define SORTMODE_COMMAND    3
#define SORTMODE_DICTIONARY 4

/*
 * Magic values for the index field of the SortInfo structure.
 * Note that the index "end-1" will be translated to SORTIDX_END-1, etc.
 */
#define SORTIDX_NONE	-1		/* Not indexed; use whole value. */
#define SORTIDX_END	-2		/* Indexed from end. */

/*
 * Forward declarations for procedures defined in this file:
 */

static void		AppendLocals _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_Obj *listPtr, CONST char *pattern,
			    int includeLinks));
static int		DictionaryCompare _ANSI_ARGS_((char *left,
			    char *right));
static int		InfoArgsCmd _ANSI_ARGS_((ClientData dummy,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *CONST objv[]));
static int		InfoBodyCmd _ANSI_ARGS_((ClientData dummy,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *CONST objv[]));
static int		InfoCmdCountCmd _ANSI_ARGS_((ClientData dummy,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *CONST objv[]));
static int		InfoCommandsCmd _ANSI_ARGS_((ClientData dummy,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *CONST objv[]));
static int		InfoCompleteCmd _ANSI_ARGS_((ClientData dummy,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *CONST objv[]));
static int		InfoDefaultCmd _ANSI_ARGS_((ClientData dummy,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *CONST objv[]));
static int		InfoExistsCmd _ANSI_ARGS_((ClientData dummy,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *CONST objv[]));
static int		InfoFunctionsCmd _ANSI_ARGS_((ClientData dummy,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *CONST objv[]));
static int		InfoGlobalsCmd _ANSI_ARGS_((ClientData dummy,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *CONST objv[]));
static int		InfoHostnameCmd _ANSI_ARGS_((ClientData dummy,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *CONST objv[]));
static int		InfoLevelCmd _ANSI_ARGS_((ClientData dummy,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *CONST objv[]));
static int		InfoLibraryCmd _ANSI_ARGS_((ClientData dummy,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *CONST objv[]));
static int		InfoLoadedCmd _ANSI_ARGS_((ClientData dummy,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *CONST objv[]));
static int		InfoLocalsCmd _ANSI_ARGS_((ClientData dummy,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *CONST objv[]));
static int		InfoNameOfExecutableCmd _ANSI_ARGS_((
			    ClientData dummy, Tcl_Interp *interp, int objc,
			    Tcl_Obj *CONST objv[]));
static int		InfoPatchLevelCmd _ANSI_ARGS_((ClientData dummy,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *CONST objv[]));
static int		InfoProcsCmd _ANSI_ARGS_((ClientData dummy,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *CONST objv[]));
static int		InfoScriptCmd _ANSI_ARGS_((ClientData dummy,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *CONST objv[]));
static int		InfoSharedlibCmd _ANSI_ARGS_((ClientData dummy,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *CONST objv[]));
static int		InfoTclVersionCmd _ANSI_ARGS_((ClientData dummy,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *CONST objv[]));
static int		InfoVarsCmd _ANSI_ARGS_((ClientData dummy,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *CONST objv[]));
static SortElement *    MergeSort _ANSI_ARGS_((SortElement *headPt,
			    SortInfo *infoPtr));
static SortElement *    MergeLists _ANSI_ARGS_((SortElement *leftPtr,
			    SortElement *rightPtr, SortInfo *infoPtr));
static int		SortCompare _ANSI_ARGS_((Tcl_Obj *firstPtr,
			    Tcl_Obj *second, SortInfo *infoPtr));

/*
 *----------------------------------------------------------------------
 *
 * Tcl_IfObjCmd --
 *
 *	This procedure is invoked to process the "if" Tcl command.
 *	See the user documentation for details on what it does.
 *
 *	With the bytecode compiler, this procedure is only called when
 *	a command name is computed at runtime, and is "if" or the name
 *	to which "if" was renamed: e.g., "set z if; $z 1 {puts foo}"
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
int
Tcl_IfObjCmd(dummy, interp, objc, objv)
    ClientData dummy;			/* Not used. */
    Tcl_Interp *interp;			/* Current interpreter. */
    int objc;				/* Number of arguments. */
    Tcl_Obj *CONST objv[];		/* Argument objects. */
{
    int thenScriptIndex = 0;	/* then script to be evaled after syntax check */
    int i, result, value;
    char *clause;
    i = 1;
    while (1) {
	/*
	 * At this point in the loop, objv and objc refer to an expression
	 * to test, either for the main expression or an expression
	 * following an "elseif".  The arguments after the expression must
	 * be "then" (optional) and a script to execute if the expression is
	 * true.
	 */

	if (i >= objc) {
	    clause = Tcl_GetString(objv[i-1]);
	    Tcl_AppendResult(interp, "wrong # args: no expression after \"",
		    clause, "\" argument", (char *) NULL);
	    return TCL_ERROR;
	}
	if (!thenScriptIndex) {
	    result = Tcl_ExprBooleanObj(interp, objv[i], &value);
	    if (result != TCL_OK) {
		return result;
	    }
	}
	i++;
	if (i >= objc) {
	    missingScript:
	    clause = Tcl_GetString(objv[i-1]);
	    Tcl_AppendResult(interp, "wrong # args: no script following \"",
		    clause, "\" argument", (char *) NULL);
	    return TCL_ERROR;
	}
	clause = Tcl_GetString(objv[i]);
	if ((i < objc) && (strcmp(clause, "then") == 0)) {
	    i++;
	}
	if (i >= objc) {
	    goto missingScript;
	}
	if (value) {
	    thenScriptIndex = i;
	    value = 0;
	}
	
	/*
	 * The expression evaluated to false.  Skip the command, then
	 * see if there is an "else" or "elseif" clause.
	 */

	i++;
	if (i >= objc) {
	    if (thenScriptIndex) {
		return Tcl_EvalObjEx(interp, objv[thenScriptIndex], 0);
	    }
	    return TCL_OK;
	}
	clause = Tcl_GetString(objv[i]);
	if ((clause[0] == 'e') && (strcmp(clause, "elseif") == 0)) {
	    i++;
	    continue;
	}
	break;
    }

    /*
     * Couldn't find a "then" or "elseif" clause to execute.  Check now
     * for an "else" clause.  We know that there's at least one more
     * argument when we get here.
     */

    if (strcmp(clause, "else") == 0) {
	i++;
	if (i >= objc) {
	    Tcl_AppendResult(interp,
		    "wrong # args: no script following \"else\" argument",
		    (char *) NULL);
	    return TCL_ERROR;
	}
    }
    if (i < objc - 1) {
	Tcl_AppendResult(interp,
		"wrong # args: extra words after \"else\" clause in \"if\" command",
		(char *) NULL);
	return TCL_ERROR;
    }
    if (thenScriptIndex) {
	return Tcl_EvalObjEx(interp, objv[thenScriptIndex], 0);
    }
    return Tcl_EvalObjEx(interp, objv[i], 0);
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_IncrObjCmd --
 *
 *	This procedure is invoked to process the "incr" Tcl command.
 *	See the user documentation for details on what it does.
 *
 *	With the bytecode compiler, this procedure is only called when
 *	a command name is computed at runtime, and is "incr" or the name
 *	to which "incr" was renamed: e.g., "set z incr; $z i -1"
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

    /* ARGSUSED */
int
Tcl_IncrObjCmd(dummy, interp, objc, objv)
    ClientData dummy;			/* Not used. */
    Tcl_Interp *interp;			/* Current interpreter. */
    int objc;				/* Number of arguments. */
    Tcl_Obj *CONST objv[];		/* Argument objects. */
{
    long incrAmount;
    Tcl_Obj *newValuePtr;
    
    if ((objc != 2) && (objc != 3)) {
        Tcl_WrongNumArgs(interp, 1, objv, "varName ?increment?");
	return TCL_ERROR;
    }

    /*
     * Calculate the amount to increment by.
     */
    
    if (objc == 2) {
	incrAmount = 1;
    } else {
#ifdef TCL_WIDE_INT_IS_LONG
	if (Tcl_GetLongFromObj(interp, objv[2], &incrAmount) != TCL_OK) {
	    Tcl_AddErrorInfo(interp, "\n    (reading increment)");
	    return TCL_ERROR;
	}
#else
	/*
	 * Need to be a bit cautious to ensure that [expr]-like rules
	 * are enforced for interpretation of wide integers, despite
	 * the fact that the underlying API itself is a 'long' only one.
	 */
	if (objv[2]->typePtr == &tclIntType) {
	    incrAmount = objv[2]->internalRep.longValue;
	} else if (objv[2]->typePtr == &tclWideIntType) {
	    incrAmount = Tcl_WideAsLong(objv[2]->internalRep.wideValue);
	} else {
	    Tcl_WideInt wide;

	    if (Tcl_GetWideIntFromObj(interp, objv[2], &wide) != TCL_OK) {
		Tcl_AddErrorInfo(interp, "\n    (reading increment)");
		return TCL_ERROR;
	    }
	    incrAmount = Tcl_WideAsLong(wide);
	    if ((wide <= Tcl_LongAsWide(LONG_MAX))
		    && (wide >= Tcl_LongAsWide(LONG_MIN))) {
		objv[2]->typePtr = &tclIntType;
		objv[2]->internalRep.longValue = incrAmount;
	    }
	}
#endif
    }
    
    /*
     * Increment the variable's value.
     */

    newValuePtr = TclIncrVar2(interp, objv[1], (Tcl_Obj *) NULL, incrAmount,
	    TCL_LEAVE_ERR_MSG);
    if (newValuePtr == NULL) {
	return TCL_ERROR;
    }

    /*
     * Set the interpreter's object result to refer to the variable's new
     * value object.
     */

    Tcl_SetObjResult(interp, newValuePtr);
    return TCL_OK; 
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_InfoObjCmd --
 *
 *	This procedure is invoked to process the "info" Tcl command.
 *	See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
int
Tcl_InfoObjCmd(clientData, interp, objc, objv)
    ClientData clientData;	/* Arbitrary value passed to the command. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    static CONST char *subCmds[] = {
            "args", "body", "cmdcount", "commands",
	     "complete", "default", "exists", "functions", "globals",
	     "hostname", "level", "library", "loaded",
	     "locals", "nameofexecutable", "patchlevel", "procs",
	     "script", "sharedlibextension", "tclversion", "vars",
	     (char *) NULL};
    enum ISubCmdIdx {
	    IArgsIdx, IBodyIdx, ICmdCountIdx, ICommandsIdx,
	    ICompleteIdx, IDefaultIdx, IExistsIdx, IFunctionsIdx, IGlobalsIdx,
	    IHostnameIdx, ILevelIdx, ILibraryIdx, ILoadedIdx,
	    ILocalsIdx, INameOfExecutableIdx, IPatchLevelIdx, IProcsIdx,
	    IScriptIdx, ISharedLibExtensionIdx, ITclVersionIdx, IVarsIdx
    };
    int index, result;

    if (objc < 2) {
        Tcl_WrongNumArgs(interp, 1, objv, "option ?arg arg ...?");
        return TCL_ERROR;
    }
    
    result = Tcl_GetIndexFromObj(interp, objv[1], subCmds, "option", 0,
	    (int *) &index);
    if (result != TCL_OK) {
	return result;
    }

    switch (index) {
        case IArgsIdx:
	    result = InfoArgsCmd(clientData, interp, objc, objv);
            break;
	case IBodyIdx:
	    result = InfoBodyCmd(clientData, interp, objc, objv);
	    break;
	case ICmdCountIdx:
	    result = InfoCmdCountCmd(clientData, interp, objc, objv);
	    break;
        case ICommandsIdx:
	    result = InfoCommandsCmd(clientData, interp, objc, objv);
	    break;
        case ICompleteIdx:
	    result = InfoCompleteCmd(clientData, interp, objc, objv);
	    break;
	case IDefaultIdx:
	    result = InfoDefaultCmd(clientData, interp, objc, objv);
	    break;
	case IExistsIdx:
	    result = InfoExistsCmd(clientData, interp, objc, objv);
	    break;
	case IFunctionsIdx:
	    result = InfoFunctionsCmd(clientData, interp, objc, objv);
	    break;
        case IGlobalsIdx:
	    result = InfoGlobalsCmd(clientData, interp, objc, objv);
	    break;
        case IHostnameIdx:
	    result = InfoHostnameCmd(clientData, interp, objc, objv);
	    break;
	case ILevelIdx:
	    result = InfoLevelCmd(clientData, interp, objc, objv);
	    break;
	case ILibraryIdx:
	    result = InfoLibraryCmd(clientData, interp, objc, objv);
	    break;
        case ILoadedIdx:
	    result = InfoLoadedCmd(clientData, interp, objc, objv);
	    break;
        case ILocalsIdx:
	    result = InfoLocalsCmd(clientData, interp, objc, objv);
	    break;
	case INameOfExecutableIdx:
	    result = InfoNameOfExecutableCmd(clientData, interp, objc, objv);
	    break;
	case IPatchLevelIdx:
	    result = InfoPatchLevelCmd(clientData, interp, objc, objv);
	    break;
        case IProcsIdx:
	    result = InfoProcsCmd(clientData, interp, objc, objv);
	    break;
        case IScriptIdx:
	    result = InfoScriptCmd(clientData, interp, objc, objv);
	    break;
	case ISharedLibExtensionIdx:
	    result = InfoSharedlibCmd(clientData, interp, objc, objv);
	    break;
	case ITclVersionIdx:
	    result = InfoTclVersionCmd(clientData, interp, objc, objv);
	    break;
	case IVarsIdx:
	    result = InfoVarsCmd(clientData, interp, objc, objv);
	    break;
    }
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * InfoArgsCmd --
 *
 *      Called to implement the "info args" command that returns the
 *      argument list for a procedure. Handles the following syntax:
 *
 *          info args procName
 *
 * Results:
 *      Returns TCL_OK if successful and TCL_ERROR if there is an error.
 *
 * Side effects:
 *      Returns a result in the interpreter's result object. If there is
 *	an error, the result is an error message.
 *
 *----------------------------------------------------------------------
 */

static int
InfoArgsCmd(dummy, interp, objc, objv)
    ClientData dummy;		/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    register Interp *iPtr = (Interp *) interp;
    char *name;
    Proc *procPtr;
    CompiledLocal *localPtr;
    Tcl_Obj *listObjPtr;

    if (objc != 3) {
        Tcl_WrongNumArgs(interp, 2, objv, "procname");
        return TCL_ERROR;
    }

    name = Tcl_GetString(objv[2]);
    procPtr = TclFindProc(iPtr, name);
    if (procPtr == NULL) {
        Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
                "\"", name, "\" isn't a procedure", (char *) NULL);
        return TCL_ERROR;
    }

    /*
     * Build a return list containing the arguments.
     */
    
    listObjPtr = Tcl_NewListObj(0, (Tcl_Obj **) NULL);
    for (localPtr = procPtr->firstLocalPtr;  localPtr != NULL;
            localPtr = localPtr->nextPtr) {
        if (TclIsVarArgument(localPtr)) {
            Tcl_ListObjAppendElement(interp, listObjPtr,
		    Tcl_NewStringObj(localPtr->name, -1));
        }
    }
    Tcl_SetObjResult(interp, listObjPtr);
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * InfoBodyCmd --
 *
 *      Called to implement the "info body" command that returns the body
 *      for a procedure. Handles the following syntax:
 *
 *          info body procName
 *
 * Results:
 *      Returns TCL_OK if successful and TCL_ERROR if there is an error.
 *
 * Side effects:
 *      Returns a result in the interpreter's result object. If there is
 *	an error, the result is an error message.
 *
 *----------------------------------------------------------------------
 */

static int
InfoBodyCmd(dummy, interp, objc, objv)
    ClientData dummy;		/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    register Interp *iPtr = (Interp *) interp;
    char *name;
    Proc *procPtr;
    Tcl_Obj *bodyPtr, *resultPtr;
    
    if (objc != 3) {
        Tcl_WrongNumArgs(interp, 2, objv, "procname");
        return TCL_ERROR;
    }

    name = Tcl_GetString(objv[2]);
    procPtr = TclFindProc(iPtr, name);
    if (procPtr == NULL) {
        Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
		"\"", name, "\" isn't a procedure", (char *) NULL);
        return TCL_ERROR;
    }

    /* 
     * Here we used to return procPtr->bodyPtr, except when the body was
     * bytecompiled - in that case, the return was a copy of the body's
     * string rep. In order to better isolate the implementation details
     * of the compiler/engine subsystem, we now always return a copy of 
     * the string rep. It is important to return a copy so that later 
     * manipulations of the object do not invalidate the internal rep.
     */

    bodyPtr = procPtr->bodyPtr;
    if (bodyPtr->bytes == NULL) {
	/*
	 * The string rep might not be valid if the procedure has
	 * never been run before.  [Bug #545644]
	 */
	(void) Tcl_GetString(bodyPtr);
    }
    resultPtr = Tcl_NewStringObj(bodyPtr->bytes, bodyPtr->length);
    
    Tcl_SetObjResult(interp, resultPtr);
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * InfoCmdCountCmd --
 *
 *      Called to implement the "info cmdcount" command that returns the
 *      number of commands that have been executed. Handles the following
 *      syntax:
 *
 *          info cmdcount
 *
 * Results:
 *      Returns TCL_OK if successful and TCL_ERROR if there is an error.
 *
 * Side effects:
 *      Returns a result in the interpreter's result object. If there is
 *	an error, the result is an error message.
 *
 *----------------------------------------------------------------------
 */

static int
InfoCmdCountCmd(dummy, interp, objc, objv)
    ClientData dummy;		/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    Interp *iPtr = (Interp *) interp;
    
    if (objc != 2) {
        Tcl_WrongNumArgs(interp, 2, objv, NULL);
        return TCL_ERROR;
    }

    Tcl_SetIntObj(Tcl_GetObjResult(interp), iPtr->cmdCount);
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * InfoCommandsCmd --
 *
 *	Called to implement the "info commands" command that returns the
 *	list of commands in the interpreter that match an optional pattern.
 *	The pattern, if any, consists of an optional sequence of namespace
 *	names separated by "::" qualifiers, which is followed by a
 *	glob-style pattern that restricts which commands are returned.
 *	Handles the following syntax:
 *
 *          info commands ?pattern?
 *
 * Results:
 *      Returns TCL_OK if successful and TCL_ERROR if there is an error.
 *
 * Side effects:
 *      Returns a result in the interpreter's result object. If there is
 *	an error, the result is an error message.
 *
 *----------------------------------------------------------------------
 */

static int
InfoCommandsCmd(dummy, interp, objc, objv)
    ClientData dummy;		/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    char *cmdName, *pattern;
    CONST char *simplePattern;
    register Tcl_HashEntry *entryPtr;
    Tcl_HashSearch search;
    Namespace *nsPtr;
    Namespace *globalNsPtr = (Namespace *) Tcl_GetGlobalNamespace(interp);
    Namespace *currNsPtr   = (Namespace *) Tcl_GetCurrentNamespace(interp);
    Tcl_Obj *listPtr, *elemObjPtr;
    int specificNsInPattern = 0;  /* Init. to avoid compiler warning. */
    Tcl_Command cmd;

    /*
     * Get the pattern and find the "effective namespace" in which to
     * list commands.
     */

    if (objc == 2) {
        simplePattern = NULL;
	nsPtr = currNsPtr;
	specificNsInPattern = 0;
    } else if (objc == 3) {
	/*
	 * From the pattern, get the effective namespace and the simple
	 * pattern (no namespace qualifiers or ::'s) at the end. If an
	 * error was found while parsing the pattern, return it. Otherwise,
	 * if the namespace wasn't found, just leave nsPtr NULL: we will
	 * return an empty list since no commands there can be found.
	 */

	Namespace *dummy1NsPtr, *dummy2NsPtr;
	

	pattern = Tcl_GetString(objv[2]);
	TclGetNamespaceForQualName(interp, pattern, (Namespace *) NULL,
           /*flags*/ 0, &nsPtr, &dummy1NsPtr, &dummy2NsPtr, &simplePattern);

	if (nsPtr != NULL) {	/* we successfully found the pattern's ns */
	    specificNsInPattern = (strcmp(simplePattern, pattern) != 0);
	}
    } else {
        Tcl_WrongNumArgs(interp, 2, objv, "?pattern?");
        return TCL_ERROR;
    }

    /*
     * Scan through the effective namespace's command table and create a
     * list with all commands that match the pattern. If a specific
     * namespace was requested in the pattern, qualify the command names
     * with the namespace name.
     */

    listPtr = Tcl_NewListObj(0, (Tcl_Obj **) NULL);

    if (nsPtr != NULL) {
	entryPtr = Tcl_FirstHashEntry(&nsPtr->cmdTable, &search);
	while (entryPtr != NULL) {
	    cmdName = Tcl_GetHashKey(&nsPtr->cmdTable, entryPtr);
	    if ((simplePattern == NULL)
	            || Tcl_StringMatch(cmdName, simplePattern)) {
		if (specificNsInPattern) {
		    cmd = (Tcl_Command) Tcl_GetHashValue(entryPtr);
		    elemObjPtr = Tcl_NewObj();
		    Tcl_GetCommandFullName(interp, cmd, elemObjPtr);
		} else {
		    elemObjPtr = Tcl_NewStringObj(cmdName, -1);
		}
		Tcl_ListObjAppendElement(interp, listPtr, elemObjPtr);
	    }
	    entryPtr = Tcl_NextHashEntry(&search);
	}

	/*
	 * If the effective namespace isn't the global :: namespace, and a
	 * specific namespace wasn't requested in the pattern, then add in
	 * all global :: commands that match the simple pattern. Of course,
	 * we add in only those commands that aren't hidden by a command in
	 * the effective namespace.
	 */
	
	if ((nsPtr != globalNsPtr) && !specificNsInPattern) {
	    entryPtr = Tcl_FirstHashEntry(&globalNsPtr->cmdTable, &search);
	    while (entryPtr != NULL) {
		cmdName = Tcl_GetHashKey(&globalNsPtr->cmdTable, entryPtr);
		if ((simplePattern == NULL)
	                || Tcl_StringMatch(cmdName, simplePattern)) {
		    if (Tcl_FindHashEntry(&nsPtr->cmdTable, cmdName) == NULL) {
			Tcl_ListObjAppendElement(interp, listPtr,
				Tcl_NewStringObj(cmdName, -1));
		    }
		}
		entryPtr = Tcl_NextHashEntry(&search);
	    }
	}
    }
    
    Tcl_SetObjResult(interp, listPtr);
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * InfoCompleteCmd --
 *
 *      Called to implement the "info complete" command that determines
 *      whether a string is a complete Tcl command. Handles the following
 *      syntax:
 *
 *          info complete command
 *
 * Results:
 *      Returns TCL_OK if successful and TCL_ERROR if there is an error.
 *
 * Side effects:
 *      Returns a result in the interpreter's result object. If there is
 *	an error, the result is an error message.
 *
 *----------------------------------------------------------------------
 */

static int
InfoCompleteCmd(dummy, interp, objc, objv)
    ClientData dummy;		/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    if (objc != 3) {
        Tcl_WrongNumArgs(interp, 2, objv, "command");
        return TCL_ERROR;
    }

    if (TclObjCommandComplete(objv[2])) {
	Tcl_SetIntObj(Tcl_GetObjResult(interp), 1);
    } else {
	Tcl_SetIntObj(Tcl_GetObjResult(interp), 0);
    }

    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * InfoDefaultCmd --
 *
 *      Called to implement the "info default" command that returns the
 *      default value for a procedure argument. Handles the following
 *      syntax:
 *
 *          info default procName arg varName
 *
 * Results:
 *      Returns TCL_OK if successful and TCL_ERROR if there is an error.
 *
 * Side effects:
 *      Returns a result in the interpreter's result object. If there is
 *	an error, the result is an error message.
 *
 *----------------------------------------------------------------------
 */

static int
InfoDefaultCmd(dummy, interp, objc, objv)
    ClientData dummy;		/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    Interp *iPtr = (Interp *) interp;
    char *procName, *argName, *varName;
    Proc *procPtr;
    CompiledLocal *localPtr;
    Tcl_Obj *valueObjPtr;

    if (objc != 5) {
        Tcl_WrongNumArgs(interp, 2, objv, "procname arg varname");
        return TCL_ERROR;
    }

    procName = Tcl_GetString(objv[2]);
    argName = Tcl_GetString(objv[3]);

    procPtr = TclFindProc(iPtr, procName);
    if (procPtr == NULL) {
	Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
		"\"", procName, "\" isn't a procedure", (char *) NULL);
        return TCL_ERROR;
    }

    for (localPtr = procPtr->firstLocalPtr;  localPtr != NULL;
            localPtr = localPtr->nextPtr) {
        if (TclIsVarArgument(localPtr)
		&& (strcmp(argName, localPtr->name) == 0)) {
            if (localPtr->defValuePtr != NULL) {
		valueObjPtr = Tcl_ObjSetVar2(interp, objv[4], NULL,
			localPtr->defValuePtr, 0);
                if (valueObjPtr == NULL) {
                    defStoreError:
		    varName = Tcl_GetString(objv[4]);
		    Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
	                    "couldn't store default value in variable \"",
			    varName, "\"", (char *) NULL);
                    return TCL_ERROR;
                }
		Tcl_SetIntObj(Tcl_GetObjResult(interp), 1);
            } else {
                Tcl_Obj *nullObjPtr = Tcl_NewObj();
                valueObjPtr = Tcl_ObjSetVar2(interp, objv[4], NULL,
			nullObjPtr, 0);
                if (valueObjPtr == NULL) {
                    Tcl_DecrRefCount(nullObjPtr); /* free unneeded obj */
                    goto defStoreError;
                }
		Tcl_SetIntObj(Tcl_GetObjResult(interp), 0);
            }
            return TCL_OK;
        }
    }

    Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
	    "procedure \"", procName, "\" doesn't have an argument \"",
	    argName, "\"", (char *) NULL);
    return TCL_ERROR;
}

/*
 *----------------------------------------------------------------------
 *
 * InfoExistsCmd --
 *
 *      Called to implement the "info exists" command that determines
 *      whether a variable exists. Handles the following syntax:
 *
 *          info exists varName
 *
 * Results:
 *      Returns TCL_OK if successful and TCL_ERROR if there is an error.
 *
 * Side effects:
 *      Returns a result in the interpreter's result object. If there is
 *	an error, the result is an error message.
 *
 *----------------------------------------------------------------------
 */

static int
InfoExistsCmd(dummy, interp, objc, objv)
    ClientData dummy;		/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    char *varName;
    Var *varPtr;

    if (objc != 3) {
        Tcl_WrongNumArgs(interp, 2, objv, "varName");
        return TCL_ERROR;
    }

    varName = Tcl_GetString(objv[2]);
    varPtr = TclVarTraceExists(interp, varName);
    if ((varPtr != NULL) && !TclIsVarUndefined(varPtr)) {
        Tcl_SetIntObj(Tcl_GetObjResult(interp), 1);
    } else {
        Tcl_SetIntObj(Tcl_GetObjResult(interp), 0);
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * InfoFunctionsCmd --
 *
 *      Called to implement the "info functions" command that returns the
 *      list of math functions matching an optional pattern. Handles the
 *      following syntax:
 *
 *          info functions ?pattern?
 *
 * Results:
 *      Returns TCL_OK if successful and TCL_ERROR if there is an error.
 *
 * Side effects:
 *      Returns a result in the interpreter's result object. If there is
 *	an error, the result is an error message.
 *
 *----------------------------------------------------------------------
 */

static int
InfoFunctionsCmd(dummy, interp, objc, objv)
    ClientData dummy;		/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    char *pattern;
    Tcl_Obj *listPtr;

    if (objc == 2) {
        pattern = NULL;
    } else if (objc == 3) {
        pattern = Tcl_GetString(objv[2]);
    } else {
        Tcl_WrongNumArgs(interp, 2, objv, "?pattern?");
        return TCL_ERROR;
    }

    listPtr = Tcl_ListMathFuncs(interp, pattern);
    if (listPtr == NULL) {
	return TCL_ERROR;
    }
    Tcl_SetObjResult(interp, listPtr);
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * InfoGlobalsCmd --
 *
 *      Called to implement the "info globals" command that returns the list
 *      of global variables matching an optional pattern. Handles the
 *      following syntax:
 *
 *          info globals ?pattern?
 *
 * Results:
 *      Returns TCL_OK if successful and TCL_ERROR if there is an error.
 *
 * Side effects:
 *      Returns a result in the interpreter's result object. If there is
 *	an error, the result is an error message.
 *
 *----------------------------------------------------------------------
 */

static int
InfoGlobalsCmd(dummy, interp, objc, objv)
    ClientData dummy;		/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    char *varName, *pattern;
    Namespace *globalNsPtr = (Namespace *) Tcl_GetGlobalNamespace(interp);
    register Tcl_HashEntry *entryPtr;
    Tcl_HashSearch search;
    Var *varPtr;
    Tcl_Obj *listPtr;

    if (objc == 2) {
        pattern = NULL;
    } else if (objc == 3) {
        pattern = Tcl_GetString(objv[2]);
    } else {
        Tcl_WrongNumArgs(interp, 2, objv, "?pattern?");
        return TCL_ERROR;
    }

    /*
     * Scan through the global :: namespace's variable table and create a
     * list of all global variables that match the pattern.
     */
    
    listPtr = Tcl_NewListObj(0, (Tcl_Obj **) NULL);
    for (entryPtr = Tcl_FirstHashEntry(&globalNsPtr->varTable, &search);
            entryPtr != NULL;
            entryPtr = Tcl_NextHashEntry(&search)) {
        varPtr = (Var *) Tcl_GetHashValue(entryPtr);
        if (TclIsVarUndefined(varPtr)) {
            continue;
        }
        varName = Tcl_GetHashKey(&globalNsPtr->varTable, entryPtr);
        if ((pattern == NULL) || Tcl_StringMatch(varName, pattern)) {
            Tcl_ListObjAppendElement(interp, listPtr,
		    Tcl_NewStringObj(varName, -1));
        }
    }
    Tcl_SetObjResult(interp, listPtr);
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * InfoHostnameCmd --
 *
 *      Called to implement the "info hostname" command that returns the
 *      host name. Handles the following syntax:
 *
 *          info hostname
 *
 * Results:
 *      Returns TCL_OK if successful and TCL_ERROR if there is an error.
 *
 * Side effects:
 *      Returns a result in the interpreter's result object. If there is
 *	an error, the result is an error message.
 *
 *----------------------------------------------------------------------
 */

static int
InfoHostnameCmd(dummy, interp, objc, objv)
    ClientData dummy;		/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    CONST char *name;
    if (objc != 2) {
        Tcl_WrongNumArgs(interp, 2, objv, NULL);
        return TCL_ERROR;
    }

    name = Tcl_GetHostName();
    if (name) {
	Tcl_SetStringObj(Tcl_GetObjResult(interp), name, -1);
	return TCL_OK;
    } else {
	Tcl_SetStringObj(Tcl_GetObjResult(interp),
		"unable to determine name of host", -1);
	return TCL_ERROR;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * InfoLevelCmd --
 *
 *      Called to implement the "info level" command that returns
 *      information about the call stack. Handles the following syntax:
 *
 *          info level ?number?
 *
 * Results:
 *      Returns TCL_OK if successful and TCL_ERROR if there is an error.
 *
 * Side effects:
 *      Returns a result in the interpreter's result object. If there is
 *	an error, the result is an error message.
 *
 *----------------------------------------------------------------------
 */

static int
InfoLevelCmd(dummy, interp, objc, objv)
    ClientData dummy;		/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    Interp *iPtr = (Interp *) interp;
    int level;
    CallFrame *framePtr;
    Tcl_Obj *listPtr;

    if (objc == 2) {		/* just "info level" */
        if (iPtr->varFramePtr == NULL) {
            Tcl_SetIntObj(Tcl_GetObjResult(interp), 0);
        } else {
            Tcl_SetIntObj(Tcl_GetObjResult(interp), iPtr->varFramePtr->level);
        }
        return TCL_OK;
    } else if (objc == 3) {
        if (Tcl_GetIntFromObj(interp, objv[2], &level) != TCL_OK) {
            return TCL_ERROR;
        }
        if (level <= 0) {
            if (iPtr->varFramePtr == NULL) {
                levelError:
		Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
			"bad level \"",
			Tcl_GetString(objv[2]),
			"\"", (char *) NULL);
                return TCL_ERROR;
            }
            level += iPtr->varFramePtr->level;
        }
        for (framePtr = iPtr->varFramePtr;  framePtr != NULL;
                framePtr = framePtr->callerVarPtr) {
            if (framePtr->level == level) {
                break;
            }
        }
        if (framePtr == NULL) {
            goto levelError;
        }

        listPtr = Tcl_NewListObj(framePtr->objc, framePtr->objv);
        Tcl_SetObjResult(interp, listPtr);
        return TCL_OK;
    }

    Tcl_WrongNumArgs(interp, 2, objv, "?number?");
    return TCL_ERROR;
}

/*
 *----------------------------------------------------------------------
 *
 * InfoLibraryCmd --
 *
 *      Called to implement the "info library" command that returns the
 *      library directory for the Tcl installation. Handles the following
 *      syntax:
 *
 *          info library
 *
 * Results:
 *      Returns TCL_OK if successful and TCL_ERROR if there is an error.
 *
 * Side effects:
 *      Returns a result in the interpreter's result object. If there is
 *	an error, the result is an error message.
 *
 *----------------------------------------------------------------------
 */

static int
InfoLibraryCmd(dummy, interp, objc, objv)
    ClientData dummy;		/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    CONST char *libDirName;

    if (objc != 2) {
        Tcl_WrongNumArgs(interp, 2, objv, NULL);
        return TCL_ERROR;
    }

    libDirName = Tcl_GetVar(interp, "tcl_library", TCL_GLOBAL_ONLY);
    if (libDirName != NULL) {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), libDirName, -1);
        return TCL_OK;
    }
    Tcl_SetStringObj(Tcl_GetObjResult(interp), 
            "no library has been specified for Tcl", -1);
    return TCL_ERROR;
}

/*
 *----------------------------------------------------------------------
 *
 * InfoLoadedCmd --
 *
 *      Called to implement the "info loaded" command that returns the
 *      packages that have been loaded into an interpreter. Handles the
 *      following syntax:
 *
 *          info loaded ?interp?
 *
 * Results:
 *      Returns TCL_OK if successful and TCL_ERROR if there is an error.
 *
 * Side effects:
 *      Returns a result in the interpreter's result object. If there is
 *	an error, the result is an error message.
 *
 *----------------------------------------------------------------------
 */

static int
InfoLoadedCmd(dummy, interp, objc, objv)
    ClientData dummy;		/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    char *interpName;
    int result;

    if ((objc != 2) && (objc != 3)) {
        Tcl_WrongNumArgs(interp, 2, objv, "?interp?");
        return TCL_ERROR;
    }

    if (objc == 2) {		/* get loaded pkgs in all interpreters */
	interpName = NULL;
    } else {			/* get pkgs just in specified interp */
	interpName = Tcl_GetString(objv[2]);
    }
    result = TclGetLoadedPackages(interp, interpName);
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * InfoLocalsCmd --
 *
 *      Called to implement the "info locals" command to return a list of
 *      local variables that match an optional pattern. Handles the
 *      following syntax:
 *
 *          info locals ?pattern?
 *
 * Results:
 *      Returns TCL_OK if successful and TCL_ERROR if there is an error.
 *
 * Side effects:
 *      Returns a result in the interpreter's result object. If there is
 *	an error, the result is an error message.
 *
 *----------------------------------------------------------------------
 */

static int
InfoLocalsCmd(dummy, interp, objc, objv)
    ClientData dummy;		/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    Interp *iPtr = (Interp *) interp;
    char *pattern;
    Tcl_Obj *listPtr;

    if (objc == 2) {
        pattern = NULL;
    } else if (objc == 3) {
        pattern = Tcl_GetString(objv[2]);
    } else {
        Tcl_WrongNumArgs(interp, 2, objv, "?pattern?");
        return TCL_ERROR;
    }
    
    if (iPtr->varFramePtr == NULL || !iPtr->varFramePtr->isProcCallFrame) {
        return TCL_OK;
    }

    /*
     * Return a list containing names of first the compiled locals (i.e. the
     * ones stored in the call frame), then the variables in the local hash
     * table (if one exists).
     */
    
    listPtr = Tcl_NewListObj(0, (Tcl_Obj **) NULL);
    AppendLocals(interp, listPtr, pattern, 0);
    Tcl_SetObjResult(interp, listPtr);
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * AppendLocals --
 *
 *	Append the local variables for the current frame to the
 *	specified list object.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static void
AppendLocals(interp, listPtr, pattern, includeLinks)
    Tcl_Interp *interp;		/* Current interpreter. */
    Tcl_Obj *listPtr;		/* List object to append names to. */
    CONST char *pattern;	/* Pattern to match against. */
    int includeLinks;		/* 1 if upvars should be included, else 0. */
{
    Interp *iPtr = (Interp *) interp;
    CompiledLocal *localPtr;
    Var *varPtr;
    int i, localVarCt;
    char *varName;
    Tcl_HashTable *localVarTablePtr;
    register Tcl_HashEntry *entryPtr;
    Tcl_HashSearch search;

    localPtr = iPtr->varFramePtr->procPtr->firstLocalPtr;
    localVarCt = iPtr->varFramePtr->numCompiledLocals;
    varPtr = iPtr->varFramePtr->compiledLocals;
    localVarTablePtr = iPtr->varFramePtr->varTablePtr;

    for (i = 0; i < localVarCt; i++) {
	/*
	 * Skip nameless (temporary) variables and undefined variables
	 */

	if (!TclIsVarTemporary(localPtr) && !TclIsVarUndefined(varPtr)
	        && (includeLinks || !TclIsVarLink(varPtr))) {
	    varName = varPtr->name;
	    if ((pattern == NULL) || Tcl_StringMatch(varName, pattern)) {
		Tcl_ListObjAppendElement(interp, listPtr,
		        Tcl_NewStringObj(varName, -1));
	    }
        }
	varPtr++;
	localPtr = localPtr->nextPtr;
    }
    
    if (localVarTablePtr != NULL) {
	for (entryPtr = Tcl_FirstHashEntry(localVarTablePtr, &search);
	        entryPtr != NULL;
                entryPtr = Tcl_NextHashEntry(&search)) {
	    varPtr = (Var *) Tcl_GetHashValue(entryPtr);
	    if (!TclIsVarUndefined(varPtr)
		    && (includeLinks || !TclIsVarLink(varPtr))) {
		varName = Tcl_GetHashKey(localVarTablePtr, entryPtr);
		if ((pattern == NULL)
		        || Tcl_StringMatch(varName, pattern)) {
		    Tcl_ListObjAppendElement(interp, listPtr,
			    Tcl_NewStringObj(varName, -1));
		}
	    }
	}
    }
}

/*
 *----------------------------------------------------------------------
 *
 * InfoNameOfExecutableCmd --
 *
 *      Called to implement the "info nameofexecutable" command that returns
 *      the name of the binary file running this application. Handles the
 *      following syntax:
 *
 *          info nameofexecutable
 *
 * Results:
 *      Returns TCL_OK if successful and TCL_ERROR if there is an error.
 *
 * Side effects:
 *      Returns a result in the interpreter's result object. If there is
 *	an error, the result is an error message.
 *
 *----------------------------------------------------------------------
 */

static int
InfoNameOfExecutableCmd(dummy, interp, objc, objv)
    ClientData dummy;		/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    CONST char *nameOfExecutable;

    if (objc != 2) {
        Tcl_WrongNumArgs(interp, 2, objv, NULL);
        return TCL_ERROR;
    }

    nameOfExecutable = Tcl_GetNameOfExecutable();
    
    if (nameOfExecutable != NULL) {
	Tcl_SetStringObj(Tcl_GetObjResult(interp), nameOfExecutable, -1);
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * InfoPatchLevelCmd --
 *
 *      Called to implement the "info patchlevel" command that returns the
 *      default value for an argument to a procedure. Handles the following
 *      syntax:
 *
 *          info patchlevel
 *
 * Results:
 *      Returns TCL_OK if successful and TCL_ERROR if there is an error.
 *
 * Side effects:
 *      Returns a result in the interpreter's result object. If there is
 *	an error, the result is an error message.
 *
 *----------------------------------------------------------------------
 */

static int
InfoPatchLevelCmd(dummy, interp, objc, objv)
    ClientData dummy;		/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    CONST char *patchlevel;

    if (objc != 2) {
        Tcl_WrongNumArgs(interp, 2, objv, NULL);
        return TCL_ERROR;
    }

    patchlevel = Tcl_GetVar(interp, "tcl_patchLevel",
            (TCL_GLOBAL_ONLY | TCL_LEAVE_ERR_MSG));
    if (patchlevel != NULL) {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), patchlevel, -1);
        return TCL_OK;
    }
    return TCL_ERROR;
}

/*
 *----------------------------------------------------------------------
 *
 * InfoProcsCmd --
 *
 *	Called to implement the "info procs" command that returns the
 *	list of procedures in the interpreter that match an optional pattern.
 *	The pattern, if any, consists of an optional sequence of namespace
 *	names separated by "::" qualifiers, which is followed by a
 *	glob-style pattern that restricts which commands are returned.
 *	Handles the following syntax:
 *
 *          info procs ?pattern?
 *
 * Results:
 *      Returns TCL_OK if successful and TCL_ERROR if there is an error.
 *
 * Side effects:
 *      Returns a result in the interpreter's result object. If there is
 *	an error, the result is an error message.
 *
 *----------------------------------------------------------------------
 */

static int
InfoProcsCmd(dummy, interp, objc, objv)
    ClientData dummy;		/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    char *cmdName, *pattern;
    CONST char *simplePattern;
    Namespace *nsPtr;
#ifdef INFO_PROCS_SEARCH_GLOBAL_NS
    Namespace *globalNsPtr = (Namespace *) Tcl_GetGlobalNamespace(interp);
#endif
    Namespace *currNsPtr   = (Namespace *) Tcl_GetCurrentNamespace(interp);
    Tcl_Obj *listPtr, *elemObjPtr;
    int specificNsInPattern = 0;  /* Init. to avoid compiler warning. */
    register Tcl_HashEntry *entryPtr;
    Tcl_HashSearch search;
    Command *cmdPtr, *realCmdPtr;

    /*
     * Get the pattern and find the "effective namespace" in which to
     * list procs.
     */

    if (objc == 2) {
	simplePattern = NULL;
	nsPtr = currNsPtr;
	specificNsInPattern = 0;
    } else if (objc == 3) {
	/*
	 * From the pattern, get the effective namespace and the simple
	 * pattern (no namespace qualifiers or ::'s) at the end. If an
	 * error was found while parsing the pattern, return it. Otherwise,
	 * if the namespace wasn't found, just leave nsPtr NULL: we will
	 * return an empty list since no commands there can be found.
	 */

	Namespace *dummy1NsPtr, *dummy2NsPtr;

	pattern = Tcl_GetString(objv[2]);
	TclGetNamespaceForQualName(interp, pattern, (Namespace *) NULL,
		/*flags*/ 0, &nsPtr, &dummy1NsPtr, &dummy2NsPtr,
		&simplePattern);

	if (nsPtr != NULL) {	/* we successfully found the pattern's ns */
	    specificNsInPattern = (strcmp(simplePattern, pattern) != 0);
	}
    } else {
        Tcl_WrongNumArgs(interp, 2, objv, "?pattern?");
        return TCL_ERROR;
    }

    /*
     * Scan through the effective namespace's command table and create a
     * list with all procs that match the pattern. If a specific
     * namespace was requested in the pattern, qualify the command names
     * with the namespace name.
     */

    listPtr = Tcl_NewListObj(0, (Tcl_Obj **) NULL);
    if (nsPtr != NULL) {
	entryPtr = Tcl_FirstHashEntry(&nsPtr->cmdTable, &search);
	while (entryPtr != NULL) {
	    cmdName = Tcl_GetHashKey(&nsPtr->cmdTable, entryPtr);
	    if ((simplePattern == NULL)
	            || Tcl_StringMatch(cmdName, simplePattern)) {
		cmdPtr = (Command *) Tcl_GetHashValue(entryPtr);

		realCmdPtr = (Command *)
		    TclGetOriginalCommand((Tcl_Command) cmdPtr);

		if (TclIsProc(cmdPtr)
		        || ((realCmdPtr != NULL) && TclIsProc(realCmdPtr))) {
		    if (specificNsInPattern) {
			elemObjPtr = Tcl_NewObj();
			Tcl_GetCommandFullName(interp, (Tcl_Command) cmdPtr,
				elemObjPtr);
		    } else {
			elemObjPtr = Tcl_NewStringObj(cmdName, -1);
		    }

		    Tcl_ListObjAppendElement(interp, listPtr, elemObjPtr);
		}
	    }
	    entryPtr = Tcl_NextHashEntry(&search);
	}

	/*
	 * If the effective namespace isn't the global :: namespace, and a
	 * specific namespace wasn't requested in the pattern, then add in
	 * all global :: procs that match the simple pattern. Of course,
	 * we add in only those procs that aren't hidden by a proc in
	 * the effective namespace.
	 */

#ifdef INFO_PROCS_SEARCH_GLOBAL_NS
	/*
	 * If "info procs" worked like "info commands", returning the
	 * commands also seen in the global namespace, then you would
	 * include this code.  As this could break backwards compatibilty
	 * with 8.0-8.2, we decided not to "fix" it in 8.3, leaving the
	 * behavior slightly different.
	 */
	if ((nsPtr != globalNsPtr) && !specificNsInPattern) {
	    entryPtr = Tcl_FirstHashEntry(&globalNsPtr->cmdTable, &search);
	    while (entryPtr != NULL) {
		cmdName = Tcl_GetHashKey(&globalNsPtr->cmdTable, entryPtr);
		if ((simplePattern == NULL)
	                || Tcl_StringMatch(cmdName, simplePattern)) {
		    if (Tcl_FindHashEntry(&nsPtr->cmdTable, cmdName) == NULL) {
			cmdPtr = (Command *) Tcl_GetHashValue(entryPtr);
			realCmdPtr = (Command *) TclGetOriginalCommand(
			        (Tcl_Command) cmdPtr);

			if (TclIsProc(cmdPtr) || ((realCmdPtr != NULL)
				&& TclIsProc(realCmdPtr))) {
			    Tcl_ListObjAppendElement(interp, listPtr,
			            Tcl_NewStringObj(cmdName, -1));
			}
		    }
		}
		entryPtr = Tcl_NextHashEntry(&search);
	    }
	}
#endif
    }

    Tcl_SetObjResult(interp, listPtr);
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * InfoScriptCmd --
 *
 *      Called to implement the "info script" command that returns the
 *      script file that is currently being evaluated. Handles the
 *      following syntax:
 *
 *          info script ?newName?
 *
 *	If newName is specified, it will set that as the internal name.
 *
 * Results:
 *      Returns TCL_OK if successful and TCL_ERROR if there is an error.
 *
 * Side effects:
 *      Returns a result in the interpreter's result object. If there is
 *	an error, the result is an error message.  It may change the
 *	internal script filename.
 *
 *----------------------------------------------------------------------
 */

static int
InfoScriptCmd(dummy, interp, objc, objv)
    ClientData dummy;		/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    Interp *iPtr = (Interp *) interp;
    if ((objc != 2) && (objc != 3)) {
        Tcl_WrongNumArgs(interp, 2, objv, "?filename?");
        return TCL_ERROR;
    }

    if (objc == 3) {
	if (iPtr->scriptFile != NULL) {
	    Tcl_DecrRefCount(iPtr->scriptFile);
	}
	iPtr->scriptFile = objv[2];
	Tcl_IncrRefCount(iPtr->scriptFile);
    }
    if (iPtr->scriptFile != NULL) {
        Tcl_SetObjResult(interp, iPtr->scriptFile);
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * InfoSharedlibCmd --
 *
 *      Called to implement the "info sharedlibextension" command that
 *      returns the file extension used for shared libraries. Handles the
 *      following syntax:
 *
 *          info sharedlibextension
 *
 * Results:
 *      Returns TCL_OK if successful and TCL_ERROR if there is an error.
 *
 * Side effects:
 *      Returns a result in the interpreter's result object. If there is
 *	an error, the result is an error message.
 *
 *----------------------------------------------------------------------
 */

static int
InfoSharedlibCmd(dummy, interp, objc, objv)
    ClientData dummy;		/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    if (objc != 2) {
        Tcl_WrongNumArgs(interp, 2, objv, NULL);
        return TCL_ERROR;
    }
    
#ifdef TCL_SHLIB_EXT
    Tcl_SetStringObj(Tcl_GetObjResult(interp), TCL_SHLIB_EXT, -1);
#endif
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * InfoTclVersionCmd --
 *
 *      Called to implement the "info tclversion" command that returns the
 *      version number for this Tcl library. Handles the following syntax:
 *
 *          info tclversion
 *
 * Results:
 *      Returns TCL_OK if successful and TCL_ERROR if there is an error.
 *
 * Side effects:
 *      Returns a result in the interpreter's result object. If there is
 *	an error, the result is an error message.
 *
 *----------------------------------------------------------------------
 */

static int
InfoTclVersionCmd(dummy, interp, objc, objv)
    ClientData dummy;		/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    CONST char *version;

    if (objc != 2) {
        Tcl_WrongNumArgs(interp, 2, objv, NULL);
        return TCL_ERROR;
    }

    version = Tcl_GetVar(interp, "tcl_version",
        (TCL_GLOBAL_ONLY | TCL_LEAVE_ERR_MSG));
    if (version != NULL) {
        Tcl_SetStringObj(Tcl_GetObjResult(interp), version, -1);
        return TCL_OK;
    }
    return TCL_ERROR;
}

/*
 *----------------------------------------------------------------------
 *
 * InfoVarsCmd --
 *
 *	Called to implement the "info vars" command that returns the
 *	list of variables in the interpreter that match an optional pattern.
 *	The pattern, if any, consists of an optional sequence of namespace
 *	names separated by "::" qualifiers, which is followed by a
 *	glob-style pattern that restricts which variables are returned.
 *	Handles the following syntax:
 *
 *          info vars ?pattern?
 *
 * Results:
 *      Returns TCL_OK if successful and TCL_ERROR if there is an error.
 *
 * Side effects:
 *      Returns a result in the interpreter's result object. If there is
 *	an error, the result is an error message.
 *
 *----------------------------------------------------------------------
 */

static int
InfoVarsCmd(dummy, interp, objc, objv)
    ClientData dummy;		/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    Interp *iPtr = (Interp *) interp;
    char *varName, *pattern;
    CONST char *simplePattern;
    register Tcl_HashEntry *entryPtr;
    Tcl_HashSearch search;
    Var *varPtr;
    Namespace *nsPtr;
    Namespace *globalNsPtr = (Namespace *) Tcl_GetGlobalNamespace(interp);
    Namespace *currNsPtr   = (Namespace *) Tcl_GetCurrentNamespace(interp);
    Tcl_Obj *listPtr, *elemObjPtr;
    int specificNsInPattern = 0;  /* Init. to avoid compiler warning. */

    /*
     * Get the pattern and find the "effective namespace" in which to
     * list variables. We only use this effective namespace if there's
     * no active Tcl procedure frame.
     */

    if (objc == 2) {
        simplePattern = NULL;
	nsPtr = currNsPtr;
	specificNsInPattern = 0;
    } else if (objc == 3) {
	/*
	 * From the pattern, get the effective namespace and the simple
	 * pattern (no namespace qualifiers or ::'s) at the end. If an
	 * error was found while parsing the pattern, return it. Otherwise,
	 * if the namespace wasn't found, just leave nsPtr NULL: we will
	 * return an empty list since no variables there can be found.
	 */

	Namespace *dummy1NsPtr, *dummy2NsPtr;

        pattern = Tcl_GetString(objv[2]);
	TclGetNamespaceForQualName(interp, pattern, (Namespace *) NULL,
		/*flags*/ 0, &nsPtr, &dummy1NsPtr, &dummy2NsPtr,
		&simplePattern);

	if (nsPtr != NULL) {	/* we successfully found the pattern's ns */
	    specificNsInPattern = (strcmp(simplePattern, pattern) != 0);
	}
    } else {
        Tcl_WrongNumArgs(interp, 2, objv, "?pattern?");
        return TCL_ERROR;
    }

    /*
     * If the namespace specified in the pattern wasn't found, just return.
     */

    if (nsPtr == NULL) {
	return TCL_OK;
    }
    
    listPtr = Tcl_NewListObj(0, (Tcl_Obj **) NULL);
    
    if ((iPtr->varFramePtr == NULL)
	    || !iPtr->varFramePtr->isProcCallFrame
	    || specificNsInPattern) {
	/*
	 * There is no frame pointer, the frame pointer was pushed only
	 * to activate a namespace, or we are in a procedure call frame
	 * but a specific namespace was specified. Create a list containing
	 * only the variables in the effective namespace's variable table.
	 */
	
	entryPtr = Tcl_FirstHashEntry(&nsPtr->varTable, &search);
	while (entryPtr != NULL) {
	    varPtr = (Var *) Tcl_GetHashValue(entryPtr);
	    if (!TclIsVarUndefined(varPtr)
		    || (varPtr->flags & VAR_NAMESPACE_VAR)) {
		varName = Tcl_GetHashKey(&nsPtr->varTable, entryPtr);
		if ((simplePattern == NULL)
	                || Tcl_StringMatch(varName, simplePattern)) {
		    if (specificNsInPattern) {
			elemObjPtr = Tcl_NewObj();
			Tcl_GetVariableFullName(interp, (Tcl_Var) varPtr,
			        elemObjPtr);
		    } else {
			elemObjPtr = Tcl_NewStringObj(varName, -1);
		    }
		    Tcl_ListObjAppendElement(interp, listPtr, elemObjPtr);
		}
	    }
	    entryPtr = Tcl_NextHashEntry(&search);
	}

	/*
	 * If the effective namespace isn't the global :: namespace, and a
	 * specific namespace wasn't requested in the pattern (i.e., the
	 * pattern only specifies variable names), then add in all global ::
	 * variables that match the simple pattern. Of course, add in only
	 * those variables that aren't hidden by a variable in the effective
	 * namespace.
	 */

	if ((nsPtr != globalNsPtr) && !specificNsInPattern) {
	    entryPtr = Tcl_FirstHashEntry(&globalNsPtr->varTable, &search);
	    while (entryPtr != NULL) {
		varPtr = (Var *) Tcl_GetHashValue(entryPtr);
		if (!TclIsVarUndefined(varPtr)
		        || (varPtr->flags & VAR_NAMESPACE_VAR)) {
		    varName = Tcl_GetHashKey(&globalNsPtr->varTable,
			    entryPtr);
		    if ((simplePattern == NULL)
	                    || Tcl_StringMatch(varName, simplePattern)) {
			if (Tcl_FindHashEntry(&nsPtr->varTable, varName) == NULL) {
			    Tcl_ListObjAppendElement(interp, listPtr,
			            Tcl_NewStringObj(varName, -1));
			}
		    }
		}
		entryPtr = Tcl_NextHashEntry(&search);
	    }
	}
    } else if (((Interp *)interp)->varFramePtr->procPtr != NULL) {
	AppendLocals(interp, listPtr, simplePattern, 1);
    }
    
    Tcl_SetObjResult(interp, listPtr);
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_JoinObjCmd --
 *
 *	This procedure is invoked to process the "join" Tcl command.
 *	See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl object result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
int
Tcl_JoinObjCmd(dummy, interp, objc, objv)
    ClientData dummy;		/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* The argument objects. */
{
    char *joinString, *bytes;
    int joinLength, listLen, length, i, result;
    Tcl_Obj **elemPtrs;
    Tcl_Obj *resObjPtr;

    if (objc == 2) {
	joinString = " ";
	joinLength = 1;
    } else if (objc == 3) {
	joinString = Tcl_GetStringFromObj(objv[2], &joinLength);
    } else {
	Tcl_WrongNumArgs(interp, 1, objv, "list ?joinString?");
	return TCL_ERROR;
    }

    /*
     * Make sure the list argument is a list object and get its length and
     * a pointer to its array of element pointers.
     */

    result = Tcl_ListObjGetElements(interp, objv[1], &listLen, &elemPtrs);
    if (result != TCL_OK) {
	return result;
    }

    /*
     * Now concatenate strings to form the "joined" result. We append
     * directly into the interpreter's result object.
     */

    resObjPtr = Tcl_GetObjResult(interp);

    for (i = 0;  i < listLen;  i++) {
	bytes = Tcl_GetStringFromObj(elemPtrs[i], &length);
	if (i > 0) {
	    Tcl_AppendToObj(resObjPtr, joinString, joinLength);
	}
	Tcl_AppendToObj(resObjPtr, bytes, length);
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_LindexObjCmd --
 *
 *	This object-based procedure is invoked to process the "lindex" Tcl
 *	command. See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl object result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

    /* ARGSUSED */
int
Tcl_LindexObjCmd(dummy, interp, objc, objv)
    ClientData dummy;		/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{

    Tcl_Obj *elemPtr;		/* Pointer to the element being extracted */

    if (objc < 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "list ?index...?");
	return TCL_ERROR;
    }

    /*
     * If objc == 3, then objv[ 2 ] may be either a single index or
     * a list of indices: go to TclLindexList to determine which.
     * If objc >= 4, or objc == 2, then objv[ 2 .. objc-2 ] are all
     * single indices and processed as such in TclLindexFlat.
     */

    if ( objc == 3 ) {

	elemPtr = TclLindexList( interp, objv[ 1 ], objv[ 2 ] );

    } else {

	elemPtr = TclLindexFlat( interp, objv[ 1 ], objc-2, objv+2 );

    }
	
    /*
     * Set the interpreter's object result to the last element extracted
     */

    if ( elemPtr == NULL ) {
	return TCL_ERROR;
    } else {
	Tcl_SetObjResult(interp, elemPtr);
	Tcl_DecrRefCount( elemPtr );
	return TCL_OK;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * TclLindexList --
 *
 *	This procedure handles the 'lindex' command when objc==3.
 *
 * Results:
 *	Returns a pointer to the object extracted, or NULL if an
 *	error occurred.
 *
 * Side effects:
 *	None.
 *
 * If objv[1] can be parsed as a list, TclLindexList handles extraction
 * of the desired element locally.  Otherwise, it invokes
 * TclLindexFlat to treat objv[1] as a scalar.
 *
 * The reference count of the returned object includes one reference
 * corresponding to the pointer returned.  Thus, the calling code will
 * usually do something like:
 *	Tcl_SetObjResult( interp, result );
 *	Tcl_DecrRefCount( result );
 *
 *----------------------------------------------------------------------
 */

Tcl_Obj *
TclLindexList( interp, listPtr, argPtr )
    Tcl_Interp* interp;		/* Tcl interpreter */
    Tcl_Obj* listPtr;		/* List being unpacked */
    Tcl_Obj* argPtr;		/* Index or index list */
{

    Tcl_Obj **elemPtrs;		/* Elements of the list being manipulated. */
    int listLen;		/* Length of the list being manipulated. */
    int index;			/* Index into the list */
    int result;			/* Result returned from a Tcl library call */
    int i;			/* Current index number */
    Tcl_Obj** indices;		/* Array of list indices */
    int indexCount;		/* Size of the array of list indices */
    Tcl_Obj* oldListPtr;	/* Temp location to preserve the list
				 * pointer when replacing it with a sublist */

    /*
     * Determine whether argPtr designates a list or a single index.
     * We have to be careful about the order of the checks to avoid
     * repeated shimmering; see TIP#22 and TIP#33 for the details.
     */

    if ( argPtr->typePtr != &tclListType 
	 && TclGetIntForIndex( NULL , argPtr, 0, &index ) == TCL_OK ) {

	/*
	 * argPtr designates a single index.
	 */

	return TclLindexFlat( interp, listPtr, 1, &argPtr );

    } else if ( Tcl_ListObjGetElements( NULL, argPtr, &indexCount, &indices )
		!= TCL_OK ) {

	/*
	 * argPtr designates something that is neither an index nor a
	 * well-formed list.  Report the error via TclLindexFlat.
	 */
	
	return TclLindexFlat( interp, listPtr, 1, &argPtr );
    }

    /*
     * Record the reference to the list that we are maintaining in
     * the activation record.
     */

    Tcl_IncrRefCount( listPtr );

    /*
     * argPtr designates a list, and the 'else if' above has parsed it
     * into indexCount and indices.
     */

    for ( i = 0; i < indexCount; ++i ) {

	/*
	 * Convert the current listPtr to a list if necessary.
	 */
	    
	result = Tcl_ListObjGetElements( interp, listPtr,
					 &listLen, &elemPtrs);
	if (result != TCL_OK) {
	    Tcl_DecrRefCount( listPtr );
	    return NULL;
	}
	    
	/*
	 * Get the index from indices[ i ]
	 */
	
	result = TclGetIntForIndex( interp, indices[ i ],
				    /*endValue*/ (listLen - 1),
				    &index );
	if ( result != TCL_OK ) {
	    /*
	     * Index could not be parsed
	     */

	    Tcl_DecrRefCount( listPtr );
	    return NULL;

	} else if ( index < 0
		    || index >= listLen ) {
	    /*
	     * Index is out of range
	     */
	    Tcl_DecrRefCount( listPtr );
	    listPtr = Tcl_NewObj();
	    Tcl_IncrRefCount( listPtr );
	    return listPtr;
	}
	
	/*
	 * Make sure listPtr still refers to a list object.
	 * If it shared a Tcl_Obj structure with the arguments, then
	 * it might have just been converted to something else.
	 */
	
	if (listPtr->typePtr != &tclListType) {
	    result = Tcl_ListObjGetElements(interp, listPtr, &listLen,
					    &elemPtrs);
	    if (result != TCL_OK) {
		Tcl_DecrRefCount( listPtr );
		return NULL;
	    }
	}
	
	/*
	 * Extract the pointer to the appropriate element
	 */
	
	oldListPtr = listPtr;
	listPtr = elemPtrs[ index ];
	Tcl_IncrRefCount( listPtr );
	Tcl_DecrRefCount( oldListPtr );
	
	/*
	 * The work we did above may have caused the internal rep
	 * of *argPtr to change to something else.  Get it back.
	 */
	
	result = Tcl_ListObjGetElements( interp, argPtr,
					 &indexCount, &indices );
	if ( result != TCL_OK ) {
	    /* 
	     * This can't happen unless some extension corrupted a Tcl_Obj.
	     */
	    Tcl_DecrRefCount( listPtr );
	    return NULL;
	}
	
    } /* end for */

    /*
     * Return the last object extracted.  Its reference count will include
     * the reference being returned.
     */

    return listPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * TclLindexFlat --
 *
 *	This procedure handles the 'lindex' command, given that the
 *	arguments to the command are known to be a flat list.
 *
 * Results:
 *	Returns a standard Tcl result.
 *
 * Side effects:
 *	None.
 *
 * This procedure is called from either tclExecute.c or
 * Tcl_LindexObjCmd whenever either is presented with
 * objc == 2 or objc >= 4.  It is also called from TclLindexList
 * for the objc==3 case once it is determined that objv[2] cannot
 * be parsed as a list.
 *
 *----------------------------------------------------------------------
 */

Tcl_Obj *
TclLindexFlat( interp, listPtr, indexCount, indexArray )
    Tcl_Interp* interp;		/* Tcl interpreter */
    Tcl_Obj* listPtr;		/* Tcl object representing the list */
    int indexCount;		/* Count of indices */
    Tcl_Obj* CONST indexArray[];
				/* Array of pointers to Tcl objects
				 * representing the indices in the
				 * list */
{

    int i;			/* Current list index */
    int result;			/* Result of Tcl library calls */
    int listLen;		/* Length of the current list being 
				 * processed */
    Tcl_Obj** elemPtrs;		/* Array of pointers to the elements
				 * of the current list */
    int index;			/* Parsed version of the current element
				 * of indexArray  */
    Tcl_Obj* oldListPtr;	/* Temporary to hold listPtr so that
				 * its ref count can be decremented. */

    /*
     * Record the reference to the 'listPtr' object that we are
     * maintaining in the C activation record.
     */

    Tcl_IncrRefCount( listPtr );

    for ( i = 0; i < indexCount; ++i ) {

	/*
	 * Convert the current listPtr to a list if necessary.
	 */
	
	result = Tcl_ListObjGetElements(interp, listPtr,
					&listLen, &elemPtrs);
	if (result != TCL_OK) {
	    Tcl_DecrRefCount( listPtr );
	    return NULL;
	}
	
	/*
	 * Get the index from objv[i]
	 */
	
	result = TclGetIntForIndex( interp, indexArray[ i ],
				    /*endValue*/ (listLen - 1),
				    &index );
	if ( result != TCL_OK ) {

	    /* Index could not be parsed */

	    Tcl_DecrRefCount( listPtr );
	    return NULL;

	} else if ( index < 0
		    || index >= listLen ) {
	    
	    /*
	     * Index is out of range
	     */
		
	    Tcl_DecrRefCount( listPtr );
	    listPtr = Tcl_NewObj();
	    Tcl_IncrRefCount( listPtr );
	    return listPtr;
	}
	    
	/*
	 * Make sure listPtr still refers to a list object.
	 * It might have been converted to something else above
	 * if objv[1] overlaps with one of the other parameters.
	 */
	
	if (listPtr->typePtr != &tclListType) {
	    result = Tcl_ListObjGetElements(interp, listPtr, &listLen,
					    &elemPtrs);
	    if (result != TCL_OK) {
		Tcl_DecrRefCount( listPtr );
		return NULL;
	    }
	}
	
	/*
	 * Extract the pointer to the appropriate element
	 */
	
	oldListPtr = listPtr;
	listPtr = elemPtrs[ index ];
	Tcl_IncrRefCount( listPtr );
	Tcl_DecrRefCount( oldListPtr );
	
    }

    return listPtr;

}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_LinsertObjCmd --
 *
 *	This object-based procedure is invoked to process the "linsert" Tcl
 *	command. See the user documentation for details on what it does.
 *
 * Results:
 *	A new Tcl list object formed by inserting zero or more elements 
 *	into a list.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
int
Tcl_LinsertObjCmd(dummy, interp, objc, objv)
    ClientData dummy;		/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    register int objc;		/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    Tcl_Obj *listPtr;
    int index, isDuplicate, len, result;

    if (objc < 4) {
	Tcl_WrongNumArgs(interp, 1, objv, "list index element ?element ...?");
	return TCL_ERROR;
    }

    result = Tcl_ListObjLength(interp, objv[1], &len);
    if (result != TCL_OK) {
	return result;
    }

    /*
     * Get the index.  "end" is interpreted to be the index after the last
     * element, such that using it will cause any inserted elements to be
     * appended to the list.
     */

    result = TclGetIntForIndex(interp, objv[2], /*end*/ len, &index);
    if (result != TCL_OK) {
	return result;
    }
    if (index > len) {
	index = len;
    }

    /*
     * If the list object is unshared we can modify it directly. Otherwise
     * we create a copy to modify: this is "copy on write".
     */

    listPtr = objv[1];
    isDuplicate = 0;
    if (Tcl_IsShared(listPtr)) {
	listPtr = Tcl_DuplicateObj(listPtr);
	isDuplicate = 1;
    }

    if ((objc == 4) && (index == len)) {
	/*
	 * Special case: insert one element at the end of the list.
	 */
	result = Tcl_ListObjAppendElement(interp, listPtr, objv[3]);
    } else if (objc > 3) {
	result = Tcl_ListObjReplace(interp, listPtr, index, 0,
				    (objc-3), &(objv[3]));
    }
    if (result != TCL_OK) {
	if (isDuplicate) {
	    Tcl_DecrRefCount(listPtr); /* free unneeded obj */
	}
	return result;
    }
    
    /*
     * Set the interpreter's object result.
     */

    Tcl_SetObjResult(interp, listPtr);
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_ListObjCmd --
 *
 *	This procedure is invoked to process the "list" Tcl command.
 *	See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl object result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
int
Tcl_ListObjCmd(dummy, interp, objc, objv)
    ClientData dummy;			/* Not used. */
    Tcl_Interp *interp;			/* Current interpreter. */
    register int objc;			/* Number of arguments. */
    register Tcl_Obj *CONST objv[];	/* The argument objects. */
{
    /*
     * If there are no list elements, the result is an empty object.
     * Otherwise modify the interpreter's result object to be a list object.
     */
    
    if (objc > 1) {
	Tcl_SetListObj(Tcl_GetObjResult(interp), (objc-1), &(objv[1]));
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_LlengthObjCmd --
 *
 *	This object-based procedure is invoked to process the "llength" Tcl
 *	command.  See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl object result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
int
Tcl_LlengthObjCmd(dummy, interp, objc, objv)
    ClientData dummy;			/* Not used. */
    Tcl_Interp *interp;			/* Current interpreter. */
    int objc;				/* Number of arguments. */
    register Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    int listLen, result;

    if (objc != 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "list");
	return TCL_ERROR;
    }

    result = Tcl_ListObjLength(interp, objv[1], &listLen);
    if (result != TCL_OK) {
	return result;
    }

    /*
     * Set the interpreter's object result to an integer object holding the
     * length. 
     */

    Tcl_SetIntObj(Tcl_GetObjResult(interp), listLen);
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_LrangeObjCmd --
 *
 *	This procedure is invoked to process the "lrange" Tcl command.
 *	See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl object result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
int
Tcl_LrangeObjCmd(notUsed, interp, objc, objv)
    ClientData notUsed;			/* Not used. */
    Tcl_Interp *interp;			/* Current interpreter. */
    int objc;				/* Number of arguments. */
    register Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    Tcl_Obj *listPtr;
    Tcl_Obj **elemPtrs;
    int listLen, first, last, numElems, result;

    if (objc != 4) {
	Tcl_WrongNumArgs(interp, 1, objv, "list first last");
	return TCL_ERROR;
    }

    /*
     * Make sure the list argument is a list object and get its length and
     * a pointer to its array of element pointers.
     */

    listPtr = objv[1];
    result = Tcl_ListObjGetElements(interp, listPtr, &listLen, &elemPtrs);
    if (result != TCL_OK) {
	return result;
    }

    /*
     * Get the first and last indexes.
     */

    result = TclGetIntForIndex(interp, objv[2], /*endValue*/ (listLen - 1),
	    &first);
    if (result != TCL_OK) {
	return result;
    }
    if (first < 0) {
	first = 0;
    }

    result = TclGetIntForIndex(interp, objv[3], /*endValue*/ (listLen - 1),
	    &last);
    if (result != TCL_OK) {
	return result;
    }
    if (last >= listLen) {
	last = (listLen - 1);
    }
    
    if (first > last) {
	return TCL_OK;		/* the result is an empty object */
    }

    /*
     * Make sure listPtr still refers to a list object. It might have been
     * converted to an int above if the argument objects were shared.
     */  

    if (listPtr->typePtr != &tclListType) {
        result = Tcl_ListObjGetElements(interp, listPtr, &listLen,
                &elemPtrs);
        if (result != TCL_OK) {
            return result;
        }
    }

    /*
     * Extract a range of fields. We modify the interpreter's result object
     * to be a list object containing the specified elements.
     */

    numElems = (last - first + 1);
    Tcl_SetListObj(Tcl_GetObjResult(interp), numElems, &(elemPtrs[first]));
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_LreplaceObjCmd --
 *
 *	This object-based procedure is invoked to process the "lreplace" 
 *	Tcl command. See the user documentation for details on what it does.
 *
 * Results:
 *	A new Tcl list object formed by replacing zero or more elements of
 *	a list.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
int
Tcl_LreplaceObjCmd(dummy, interp, objc, objv)
    ClientData dummy;		/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    register Tcl_Obj *listPtr;
    int isDuplicate, first, last, listLen, numToDelete, result;

    if (objc < 4) {
	Tcl_WrongNumArgs(interp, 1, objv,
		"list first last ?element element ...?");
	return TCL_ERROR;
    }

    result = Tcl_ListObjLength(interp, objv[1], &listLen);
    if (result != TCL_OK) {
	return result;
    }

    /*
     * Get the first and last indexes.  "end" is interpreted to be the index
     * for the last element, such that using it will cause that element to
     * be included for deletion.
     */

    result = TclGetIntForIndex(interp, objv[2], /*end*/ (listLen - 1), &first);
    if (result != TCL_OK) {
	return result;
    }

    result = TclGetIntForIndex(interp, objv[3], /*end*/ (listLen - 1), &last);
    if (result != TCL_OK) {
	return result;
    }

    if (first < 0)  {
    	first = 0;
    }

    /*
     * Complain if the user asked for a start element that is greater than the
     * list length.  This won't ever trigger for the "end*" case as that will
     * be properly constrained by TclGetIntForIndex because we use listLen-1
     * (to allow for replacing the last elem).
     */

    if ((first >= listLen) && (listLen > 0)) {
	Tcl_AppendStringsToObj(Tcl_GetObjResult(interp),
		"list doesn't contain element ",
		Tcl_GetString(objv[2]), (int *) NULL);
	return TCL_ERROR;
    }
    if (last >= listLen) {
    	last = (listLen - 1);
    }
    if (first <= last) {
	numToDelete = (last - first + 1);
    } else {
	numToDelete = 0;
    }

    /*
     * If the list object is unshared we can modify it directly, otherwise
     * we create a copy to modify: this is "copy on write".
     */

    listPtr = objv[1];
    isDuplicate = 0;
    if (Tcl_IsShared(listPtr)) {
	listPtr = Tcl_DuplicateObj(listPtr);
	isDuplicate = 1;
    }
    if (objc > 4) {
	result = Tcl_ListObjReplace(interp, listPtr, first, numToDelete,
	        (objc-4), &(objv[4]));
    } else {
	result = Tcl_ListObjReplace(interp, listPtr, first, numToDelete,
		0, NULL);
    }
    if (result != TCL_OK) {
	if (isDuplicate) {
	    Tcl_DecrRefCount(listPtr); /* free unneeded obj */
	}
	return result;
    }

    /*
     * Set the interpreter's object result. 
     */

    Tcl_SetObjResult(interp, listPtr);
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_LsearchObjCmd --
 *
 *	This procedure is invoked to process the "lsearch" Tcl command.
 *	See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_LsearchObjCmd(clientData, interp, objc, objv)
    ClientData clientData;	/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument values. */
{
    char *bytes, *patternBytes;
    int i, match, mode, index, result, listc, length, elemLen;
    int dataType, isIncreasing, lower, upper, patInt, objInt;
    int offset, allMatches, inlineReturn, negatedMatch;
    double patDouble, objDouble;
    Tcl_Obj *patObj, **listv, *listPtr, *startPtr;
    static CONST char *options[] = {
	"-all",	    "-ascii", "-decreasing", "-dictionary",
	"-exact",   "-glob",  "-increasing", "-inline",
	"-integer", "-not",   "-real",	     "-regexp",
	"-sorted",  "-start", NULL
    };
    enum options {
	LSEARCH_ALL, LSEARCH_ASCII, LSEARCH_DECREASING, LSEARCH_DICTIONARY,
	LSEARCH_EXACT, LSEARCH_GLOB, LSEARCH_INCREASING, LSEARCH_INLINE,
	LSEARCH_INTEGER, LSEARCH_NOT, LSEARCH_REAL, LSEARCH_REGEXP,
	LSEARCH_SORTED, LSEARCH_START
    };
    enum datatypes {
	ASCII, DICTIONARY, INTEGER, REAL
    };
    enum modes {
	EXACT, GLOB, REGEXP, SORTED
    };

    mode = GLOB;
    dataType = ASCII;
    isIncreasing = 1;
    allMatches = 0;
    inlineReturn = 0;
    negatedMatch = 0;
    listPtr = NULL;
    startPtr = NULL;
    offset = 0;

    if (objc < 3) {
	Tcl_WrongNumArgs(interp, 1, objv, "?options? list pattern");
	return TCL_ERROR;
    }

    for (i = 1; i < objc-2; i++) {
	if (Tcl_GetIndexFromObj(interp, objv[i], options, "option", 0, &index)
		!= TCL_OK) {
	    if (startPtr) {
		Tcl_DecrRefCount(startPtr);
	    }
	    return TCL_ERROR;
	}
	switch ((enum options) index) {
	case LSEARCH_ALL:		/* -all */
	    allMatches = 1;
	    break;
	case LSEARCH_ASCII:		/* -ascii */
	    dataType = ASCII;
	    break;
	case LSEARCH_DECREASING:	/* -decreasing */
	    isIncreasing = 0;
	    break;
	case LSEARCH_DICTIONARY:	/* -dictionary */
	    dataType = DICTIONARY;
	    break;
	case LSEARCH_EXACT:		/* -increasing */
	    mode = EXACT;
	    break;
	case LSEARCH_GLOB:		/* -glob */
	    mode = GLOB;
	    break;
	case LSEARCH_INCREASING:	/* -increasing */
	    isIncreasing = 1;
	    break;
	case LSEARCH_INLINE:		/* -inline */
	    inlineReturn = 1;
	    break;
	case LSEARCH_INTEGER:		/* -integer */
	    dataType = INTEGER;
	    break;
	case LSEARCH_NOT:		/* -not */
	    negatedMatch = 1;
	    break;
	case LSEARCH_REAL:		/* -real */
	    dataType = REAL;
	    break;
	case LSEARCH_REGEXP:		/* -regexp */
	    mode = REGEXP;
	    break;
	case LSEARCH_SORTED:		/* -sorted */
	    mode = SORTED;
	    break;
	case LSEARCH_START:		/* -start */
	    /*
	     * If there was a previous -start option, release its saved
	     * index because it will either be replaced or there will be
	     * an error.
	     */
	    if (startPtr) {
		Tcl_DecrRefCount(startPtr);
	    }
	    if (i > objc-4) {
		Tcl_AppendResult(interp, "missing starting index", NULL);
		return TCL_ERROR;
	    }
	    i++;
	    if (objv[i] == objv[objc - 2]) {
		/*
		 * Take copy to prevent shimmering problems.  Note
		 * that it does not matter if the index obj is also a
		 * component of the list being searched.  We only need
		 * to copy where the list and the index are
		 * one-and-the-same.
		 */
		startPtr = Tcl_DuplicateObj(objv[i]);
	    } else {
		startPtr = objv[i];
		Tcl_IncrRefCount(startPtr);
	    }
	}
    }

    /*
     * Make sure the list argument is a list object and get its length and
     * a pointer to its array of element pointers.
     */

    result = Tcl_ListObjGetElements(interp, objv[objc - 2], &listc, &listv);
    if (result != TCL_OK) {
	if (startPtr) {
	    Tcl_DecrRefCount(startPtr);
	}
	return result;
    }

    /*
     * Get the user-specified start offset.
     */
    if (startPtr) {
	result = TclGetIntForIndex(interp, startPtr, listc-1, &offset);
	Tcl_DecrRefCount(startPtr);
	if (result != TCL_OK) {
	    return result;
	}
	if (offset < 0) {
	    offset = 0;
	} else if (offset > listc-1) {
	    offset = listc-1;
	}
    }

    patObj = objv[objc - 1];
    patternBytes = NULL;
    if ((enum modes) mode == EXACT || (enum modes) mode == SORTED) {
	switch ((enum datatypes) dataType) {
	case ASCII:
	case DICTIONARY:
	    patternBytes = Tcl_GetStringFromObj(patObj, &length);
	    break;
	case INTEGER:
	    result = Tcl_GetIntFromObj(interp, patObj, &patInt);
	    if (result != TCL_OK) {
		return result;
	    }
	    break;
	case REAL:
	    result = Tcl_GetDoubleFromObj(interp, patObj, &patDouble);
	    if (result != TCL_OK) {
		return result;
	    }
	    break;
	}
    } else {
	patternBytes = Tcl_GetStringFromObj(patObj, &length);
    }

    /*
     * Set default index value to -1, indicating failure; if we find the
     * item in the course of our search, index will be set to the correct
     * value.
     */
    index = -1;
    match = 0;

    if ((enum modes) mode == SORTED && !allMatches && !negatedMatch) {
	/*
	 * If the data is sorted, we can do a more intelligent search.
	 * Note that there is no point in being smart when -all was
	 * specified; in that case, we have to look at all items anyway,
	 * and there is no sense in doing this when the match sense is
	 * inverted.
	 */
	lower = offset - 1;
	upper = listc;
	while (lower + 1 != upper) {
	    i = (lower + upper)/2;
	    switch ((enum datatypes) dataType) {
	    case ASCII:
		bytes = Tcl_GetString(listv[i]);
		match = strcmp(patternBytes, bytes);
		break;
	    case DICTIONARY:
		bytes = Tcl_GetString(listv[i]);
		match = DictionaryCompare(patternBytes, bytes);
		break;
	    case INTEGER:
		result = Tcl_GetIntFromObj(interp, listv[i], &objInt);
		if (result != TCL_OK) {
		    return result;
		}
		if (patInt == objInt) {
		    match = 0;
		} else if (patInt < objInt) {
		    match = -1;
		} else {
		    match = 1;
		}
		break;
	    case REAL:
		result = Tcl_GetDoubleFromObj(interp, listv[i], &objDouble);
		if (result != TCL_OK) {
		    return result;
		}
		if (patDouble == objDouble) {
		    match = 0;
		} else if (patDouble < objDouble) {
		    match = -1;
		} else {
		    match = 1;
		}
		break;
	    }
	    if (match == 0) {
		/*
		 * Normally, binary search is written to stop when it
		 * finds a match.  If there are duplicates of an element in
		 * the list, our first match might not be the first occurance.
		 * Consider:  0 0 0 1 1 1 2 2 2
		 * To maintain consistancy with standard lsearch semantics,
		 * we must find the leftmost occurance of the pattern in the
		 * list.  Thus we don't just stop searching here.  This
		 * variation means that a search always makes log n
		 * comparisons (normal binary search might "get lucky" with
		 * an early comparison).
		 */
		index = i;
		upper = i;
	    } else if (match > 0) {
		if (isIncreasing) {
		    lower = i;
		} else {
		    upper = i;
		}
	    } else {
		if (isIncreasing) {
		    upper = i;
		} else {
		    lower = i;
		}
	    }
	}

    } else {
	/*
	 * We need to do a linear search, because (at least one) of:
	 *   - our matcher can only tell equal vs. not equal
	 *   - our matching sense is negated
	 *   - we're building a list of all matched items
	 */
	if (allMatches) {
	    listPtr = Tcl_NewListObj(0, (Tcl_Obj **) NULL);
	}
	for (i = offset; i < listc; i++) {
	    match = 0;
	    switch ((enum modes) mode) {
	    case SORTED:
	    case EXACT:
		switch ((enum datatypes) dataType) {
		case ASCII:
		    bytes = Tcl_GetStringFromObj(listv[i], &elemLen);
		    if (length == elemLen) {
			match = (memcmp(bytes, patternBytes,
				(size_t) length) == 0);
		    }
		    break;
		case DICTIONARY:
		    bytes = Tcl_GetString(listv[i]);
		    match = (DictionaryCompare(bytes, patternBytes) == 0);
		    break;
		case INTEGER:
		    result = Tcl_GetIntFromObj(interp, listv[i], &objInt);
		    if (result != TCL_OK) {
			if (listPtr) {
			    Tcl_DecrRefCount(listPtr);
			}
			return result;
		    }
		    match = (objInt == patInt);
		    break;
		case REAL:
		    result = Tcl_GetDoubleFromObj(interp, listv[i],
			    &objDouble);
		    if (result != TCL_OK) {
			if (listPtr) {
			    Tcl_DecrRefCount(listPtr);
			}
			return result;
		    }
		    match = (objDouble == patDouble);
		    break;
		}
		break;
	    case GLOB:
		match = Tcl_StringMatch(Tcl_GetString(listv[i]),
			patternBytes);
		break;
	    case REGEXP:
		match = Tcl_RegExpMatchObj(interp, listv[i], patObj);
		if (match < 0) {
		    if (listPtr) {
			Tcl_DecrRefCount(listPtr);
		    }
		    return TCL_ERROR;
		}
		break;
	    }
	    /*
	     * Invert match condition for -not
	     */
	    if (negatedMatch) {
		match = !match;
	    }
	    if (match != 0) {
		if (!allMatches) {
		    index = i;
		    break;
		} else if (inlineReturn) {
		    /*
		     * Note that these appends are not expected to fail.
		     */
		    Tcl_ListObjAppendElement(interp, listPtr, listv[i]);
		} else {
		    Tcl_ListObjAppendElement(interp, listPtr,
			    Tcl_NewIntObj(i));
		}
	    }
	}
    }

    /*
     * Return everything or a single value.
     */
    if (allMatches) {
	Tcl_SetObjResult(interp, listPtr);
    } else if (!inlineReturn) {
	Tcl_SetIntObj(Tcl_GetObjResult(interp), index);
    } else if (index < 0) {
	/*
	 * Is this superfluous?  The result should be a blank object
	 * by default...
	 */
	Tcl_SetObjResult(interp, Tcl_NewObj());
    } else {
	Tcl_SetObjResult(interp, listv[index]);
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_LsetObjCmd --
 *
 *	This procedure is invoked to process the "lset" Tcl command.
 *	See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_LsetObjCmd( clientData, interp, objc, objv )
    ClientData clientData;	/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument values. */
{

    Tcl_Obj* listPtr;		/* Pointer to the list being altered. */
    Tcl_Obj* finalValuePtr;	/* Value finally assigned to the variable */

    /* Check parameter count */

    if ( objc < 3 ) {
	Tcl_WrongNumArgs( interp, 1, objv, "listVar index ?index...? value" );
	return TCL_ERROR;
    }

    /* Look up the list variable's value */

    listPtr = Tcl_ObjGetVar2( interp, objv[ 1 ], (Tcl_Obj*) NULL,
			      TCL_LEAVE_ERR_MSG );
    if ( listPtr == NULL ) {
	return TCL_ERROR;
    }

    /* 
     * Substitute the value in the value.  Return either the value or
     * else an unshared copy of it.
     */

    if ( objc == 4 ) {
	finalValuePtr = TclLsetList( interp, listPtr,
				     objv[ 2 ], objv[ 3 ] );
    } else {
	finalValuePtr = TclLsetFlat( interp, listPtr,
				     objc-3, objv+2, objv[ objc-1 ] );
    }

    /*
     * If substitution has failed, bail out.
     */

    if ( finalValuePtr == NULL ) {
	return TCL_ERROR;
    }

    /* Finally, update the variable so that traces fire. */

    listPtr = Tcl_ObjSetVar2( interp, objv[1], NULL, finalValuePtr,
			      TCL_LEAVE_ERR_MSG );
    Tcl_DecrRefCount( finalValuePtr );
    if ( listPtr == NULL ) {
	return TCL_ERROR;
    }

    /* Return the new value of the variable as the interpreter result. */

    Tcl_SetObjResult( interp, listPtr );
    return TCL_OK;

}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_LsortObjCmd --
 *
 *	This procedure is invoked to process the "lsort" Tcl command.
 *	See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_LsortObjCmd(clientData, interp, objc, objv)
    ClientData clientData;	/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument values. */
{
    int i, index, unique;
    Tcl_Obj *resultPtr;
    int length;
    Tcl_Obj *cmdPtr, **listObjPtrs;
    SortElement *elementArray;
    SortElement *elementPtr;        
    SortInfo sortInfo;                  /* Information about this sort that
                                         * needs to be passed to the 
                                         * comparison function */
    static CONST char *switches[] = {
	"-ascii", "-command", "-decreasing", "-dictionary", "-increasing",
	"-index", "-integer", "-real", "-unique", (char *) NULL
    };

    resultPtr = Tcl_GetObjResult(interp);
    if (objc < 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "?options? list");
	return TCL_ERROR;
    }

    /*
     * Parse arguments to set up the mode for the sort.
     */

    sortInfo.isIncreasing = 1;
    sortInfo.sortMode = SORTMODE_ASCII;
    sortInfo.index = SORTIDX_NONE;
    sortInfo.interp = interp;
    sortInfo.resultCode = TCL_OK;
    cmdPtr = NULL;
    unique = 0;
    for (i = 1; i < objc-1; i++) {
	if (Tcl_GetIndexFromObj(interp, objv[i], switches, "option", 0, &index)
		!= TCL_OK) {
	    return TCL_ERROR;
	}
	switch (index) {
	    case 0:			/* -ascii */
		sortInfo.sortMode = SORTMODE_ASCII;
		break;
	    case 1:			/* -command */
		if (i == (objc-2)) {
		    Tcl_AppendToObj(resultPtr,
			    "\"-command\" option must be followed by comparison command",
			    -1);
		    return TCL_ERROR;
		}
		sortInfo.sortMode = SORTMODE_COMMAND;
		cmdPtr = objv[i+1];
		i++;
		break;
	    case 2:			/* -decreasing */
		sortInfo.isIncreasing = 0;
		break;
	    case 3:			/* -dictionary */
		sortInfo.sortMode = SORTMODE_DICTIONARY;
		break;
	    case 4:			/* -increasing */
		sortInfo.isIncreasing = 1;
		break;
	    case 5:			/* -index */
		if (i == (objc-2)) {
		    Tcl_AppendToObj(resultPtr,
			    "\"-index\" option must be followed by list index",
			    -1);
		    return TCL_ERROR;
		}
		if (TclGetIntForIndex(interp, objv[i+1], SORTIDX_END,
			&sortInfo.index) != TCL_OK) {
		    return TCL_ERROR;
		}
		i++;
		break;
	    case 6:			/* -integer */
		sortInfo.sortMode = SORTMODE_INTEGER;
		break;
	    case 7:			/* -real */
		sortInfo.sortMode = SORTMODE_REAL;
		break;
	    case 8:			/* -unique */
		unique = 1;
		break;
	}
    }
    if (sortInfo.sortMode == SORTMODE_COMMAND) {
	/*
	 * The existing command is a list. We want to flatten it, append
	 * two dummy arguments on the end, and replace these arguments
	 * later.
	 */

        Tcl_Obj *newCommandPtr = Tcl_DuplicateObj(cmdPtr);
	Tcl_Obj *newObjPtr = Tcl_NewObj();

	Tcl_IncrRefCount(newCommandPtr);
	if (Tcl_ListObjAppendElement(interp, newCommandPtr, newObjPtr)
		!= TCL_OK) {
	    Tcl_DecrRefCount(newCommandPtr);
	    Tcl_IncrRefCount(newObjPtr);
	    Tcl_DecrRefCount(newObjPtr);
	    return TCL_ERROR;
	}
	Tcl_ListObjAppendElement(interp, newCommandPtr, Tcl_NewObj());
	sortInfo.compareCmdPtr = newCommandPtr;
    }

    sortInfo.resultCode = Tcl_ListObjGetElements(interp, objv[objc-1],
	    &length, &listObjPtrs);
    if (sortInfo.resultCode != TCL_OK || length <= 0) {
	goto done;
    }
    elementArray = (SortElement *) ckalloc(length * sizeof(SortElement));
    for (i=0; i < length; i++){
	elementArray[i].objPtr = listObjPtrs[i];
	elementArray[i].count = 0;
	elementArray[i].nextPtr = &elementArray[i+1];
    }
    elementArray[length-1].nextPtr = NULL;
    elementPtr = MergeSort(elementArray, &sortInfo);
    if (sortInfo.resultCode == TCL_OK) {
	/*
	 * Note: must clear the interpreter's result object: it could
	 * have been set by the -command script.
	 */

	Tcl_ResetResult(interp);
	resultPtr = Tcl_GetObjResult(interp);
	if (unique) {
	    for (; elementPtr != NULL; elementPtr = elementPtr->nextPtr){
		if (elementPtr->count == 0) {
		    Tcl_ListObjAppendElement(interp, resultPtr,
			    elementPtr->objPtr);
		}
	    }
	} else {
	    for (; elementPtr != NULL; elementPtr = elementPtr->nextPtr){
		Tcl_ListObjAppendElement(interp, resultPtr,
			elementPtr->objPtr);
	    }
	}
    }
    ckfree((char*) elementArray);

    done:
    if (sortInfo.sortMode == SORTMODE_COMMAND) {
	Tcl_DecrRefCount(sortInfo.compareCmdPtr);
	sortInfo.compareCmdPtr = NULL;
    }
    return sortInfo.resultCode;
}

/*
 *----------------------------------------------------------------------
 *
 * MergeSort -
 *
 *	This procedure sorts a linked list of SortElement structures
 *	use the merge-sort algorithm.
 *
 * Results:
 *      A pointer to the head of the list after sorting is returned.
 *
 * Side effects:
 *	None, unless a user-defined comparison command does something
 *	weird.
 *
 *----------------------------------------------------------------------
 */

static SortElement *
MergeSort(headPtr, infoPtr)
    SortElement *headPtr;               /* First element on the list */
    SortInfo *infoPtr;                  /* Information needed by the
                                         * comparison operator */
{
    /*
     * The subList array below holds pointers to temporary lists built
     * during the merge sort.  Element i of the array holds a list of
     * length 2**i.
     */

#   define NUM_LISTS 30
    SortElement *subList[NUM_LISTS];
    SortElement *elementPtr;
    int i;

    for(i = 0; i < NUM_LISTS; i++){
        subList[i] = NULL;
    }
    while (headPtr != NULL) {
	elementPtr = headPtr;
	headPtr = headPtr->nextPtr;
	elementPtr->nextPtr = 0;
	for (i = 0; (i < NUM_LISTS) && (subList[i] != NULL); i++){
	    elementPtr = MergeLists(subList[i], elementPtr, infoPtr);
	    subList[i] = NULL;
	}
	if (i >= NUM_LISTS) {
	    i = NUM_LISTS-1;
	}
	subList[i] = elementPtr;
    }
    elementPtr = NULL;
    for (i = 0; i < NUM_LISTS; i++){
        elementPtr = MergeLists(subList[i], elementPtr, infoPtr);
    }
    return elementPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * MergeLists -
 *
 *	This procedure combines two sorted lists of SortElement structures
 *	into a single sorted list.
 *
 * Results:
 *      The unified list of SortElement structures.
 *
 * Side effects:
 *	None, unless a user-defined comparison command does something
 *	weird.
 *
 *----------------------------------------------------------------------
 */

static SortElement *
MergeLists(leftPtr, rightPtr, infoPtr)
    SortElement *leftPtr;               /* First list to be merged; may be
					 * NULL. */
    SortElement *rightPtr;              /* Second list to be merged; may be
					 * NULL. */
    SortInfo *infoPtr;                  /* Information needed by the
                                         * comparison operator. */
{
    SortElement *headPtr;
    SortElement *tailPtr;
    int cmp;

    if (leftPtr == NULL) {
        return rightPtr;
    }
    if (rightPtr == NULL) {
        return leftPtr;
    }
    cmp = SortCompare(leftPtr->objPtr, rightPtr->objPtr, infoPtr);
    if (cmp > 0) {
	tailPtr = rightPtr;
	rightPtr = rightPtr->nextPtr;
    } else {
	if (cmp == 0) {
	    leftPtr->count++;
	}
	tailPtr = leftPtr;
	leftPtr = leftPtr->nextPtr;
    }
    headPtr = tailPtr;
    while ((leftPtr != NULL) && (rightPtr != NULL)) {
	cmp = SortCompare(leftPtr->objPtr, rightPtr->objPtr, infoPtr);
	if (cmp > 0) {
	    tailPtr->nextPtr = rightPtr;
	    tailPtr = rightPtr;
	    rightPtr = rightPtr->nextPtr;
	} else {
	    if (cmp == 0) {
		leftPtr->count++;
	    }
	    tailPtr->nextPtr = leftPtr;
	    tailPtr = leftPtr;
	    leftPtr = leftPtr->nextPtr;
	}
    }
    if (leftPtr != NULL) {
       tailPtr->nextPtr = leftPtr;
    } else {
       tailPtr->nextPtr = rightPtr;
    }
    return headPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * SortCompare --
 *
 *	This procedure is invoked by MergeLists to determine the proper
 *	ordering between two elements.
 *
 * Results:
 *      A negative results means the the first element comes before the
 *      second, and a positive results means that the second element
 *      should come first.  A result of zero means the two elements
 *      are equal and it doesn't matter which comes first.
 *
 * Side effects:
 *	None, unless a user-defined comparison command does something
 *	weird.
 *
 *----------------------------------------------------------------------
 */

static int
SortCompare(objPtr1, objPtr2, infoPtr)
    Tcl_Obj *objPtr1, *objPtr2;		/* Values to be compared. */
    SortInfo *infoPtr;                  /* Information passed from the
                                         * top-level "lsort" command */
{
    int order, listLen, index;
    Tcl_Obj *objPtr;
    char buffer[TCL_INTEGER_SPACE];

    order = 0;
    if (infoPtr->resultCode != TCL_OK) {
	/*
	 * Once an error has occurred, skip any future comparisons
	 * so as to preserve the error message in sortInterp->result.
	 */

	return order;
    }
    if (infoPtr->index != SORTIDX_NONE) {
	/*
	 * The "-index" option was specified.  Treat each object as a
	 * list, extract the requested element from each list, and
	 * compare the elements, not the lists.  "end"-relative indices
	 * are signaled here with large negative values.
	 */

	if (Tcl_ListObjLength(infoPtr->interp, objPtr1, &listLen) != TCL_OK) {
	    infoPtr->resultCode = TCL_ERROR;
	    return order;
	}
	if (infoPtr->index < SORTIDX_NONE) {
	    index = listLen + infoPtr->index + 1;
	} else {
	    index = infoPtr->index;
	}

	if (Tcl_ListObjIndex(infoPtr->interp, objPtr1, index, &objPtr)
		!= TCL_OK) {
	    infoPtr->resultCode = TCL_ERROR;
	    return order;
	}
	if (objPtr == NULL) {
	    objPtr = objPtr1;
	    missingElement:
	    TclFormatInt(buffer, infoPtr->index);
	    Tcl_AppendStringsToObj(Tcl_GetObjResult(infoPtr->interp),
			"element ", buffer, " missing from sublist \"",
			Tcl_GetString(objPtr), "\"", (char *) NULL);
	    infoPtr->resultCode = TCL_ERROR;
	    return order;
	}
	objPtr1 = objPtr;

	if (Tcl_ListObjLength(infoPtr->interp, objPtr2, &listLen) != TCL_OK) {
	    infoPtr->resultCode = TCL_ERROR;
	    return order;
	}
	if (infoPtr->index < SORTIDX_NONE) {
	    index = listLen + infoPtr->index + 1;
	} else {
	    index = infoPtr->index;
	}

	if (Tcl_ListObjIndex(infoPtr->interp, objPtr2, index, &objPtr)
		!= TCL_OK) {
	    infoPtr->resultCode = TCL_ERROR;
	    return order;
	}
	if (objPtr == NULL) {
	    objPtr = objPtr2;
	    goto missingElement;
	}
	objPtr2 = objPtr;
    }
    if (infoPtr->sortMode == SORTMODE_ASCII) {
	order = strcmp(Tcl_GetString(objPtr1), Tcl_GetString(objPtr2));
    } else if (infoPtr->sortMode == SORTMODE_DICTIONARY) {
	order = DictionaryCompare(
		Tcl_GetString(objPtr1),	Tcl_GetString(objPtr2));
    } else if (infoPtr->sortMode == SORTMODE_INTEGER) {
	long a, b;

	if ((Tcl_GetLongFromObj(infoPtr->interp, objPtr1, &a) != TCL_OK)
		|| (Tcl_GetLongFromObj(infoPtr->interp, objPtr2, &b)
		!= TCL_OK)) {
	    infoPtr->resultCode = TCL_ERROR;
	    return order;
	}
	if (a > b) {
	    order = 1;
	} else if (b > a) {
	    order = -1;
	}
    } else if (infoPtr->sortMode == SORTMODE_REAL) {
	double a, b;

	if ((Tcl_GetDoubleFromObj(infoPtr->interp, objPtr1, &a) != TCL_OK)
	      || (Tcl_GetDoubleFromObj(infoPtr->interp, objPtr2, &b)
		      != TCL_OK)) {
	    infoPtr->resultCode = TCL_ERROR;
	    return order;
	}
	if (a > b) {
	    order = 1;
	} else if (b > a) {
	    order = -1;
	}
    } else {
	Tcl_Obj **objv, *paramObjv[2];
	int objc;

	paramObjv[0] = objPtr1;
	paramObjv[1] = objPtr2;

  	/*
 	 * We made space in the command list for the two things to
	 * compare. Replace them and evaluate the result.
	 */

	Tcl_ListObjLength(infoPtr->interp, infoPtr->compareCmdPtr, &objc);
	Tcl_ListObjReplace(infoPtr->interp, infoPtr->compareCmdPtr, objc - 2,
		2, 2, paramObjv);
   	Tcl_ListObjGetElements(infoPtr->interp, infoPtr->compareCmdPtr,
		&objc, &objv);

	infoPtr->resultCode = Tcl_EvalObjv(infoPtr->interp, objc, objv, 0);
  
  	if (infoPtr->resultCode != TCL_OK) {
	    Tcl_AddErrorInfo(infoPtr->interp,
		    "\n    (-compare command)");
	    return order;
	}

	/*
	 * Parse the result of the command.
	 */

	if (Tcl_GetIntFromObj(infoPtr->interp,
		Tcl_GetObjResult(infoPtr->interp), &order) != TCL_OK) {
	    Tcl_ResetResult(infoPtr->interp);
	    Tcl_AppendToObj(Tcl_GetObjResult(infoPtr->interp),
		    "-compare command returned non-numeric result", -1);
	    infoPtr->resultCode = TCL_ERROR;
	    return order;
	}
    }
    if (!infoPtr->isIncreasing) {
	order = -order;
    }
    return order;
}

/*
 *----------------------------------------------------------------------
 *
 * DictionaryCompare
 *
 *	This function compares two strings as if they were being used in
 *	an index or card catalog.  The case of alphabetic characters is
 *	ignored, except to break ties.  Thus "B" comes before "b" but
 *	after "a".  Also, integers embedded in the strings compare in
 *	numerical order.  In other words, "x10y" comes after "x9y", not
 *      before it as it would when using strcmp().
 *
 * Results:
 *      A negative result means that the first element comes before the
 *      second, and a positive result means that the second element
 *      should come first.  A result of zero means the two elements
 *      are equal and it doesn't matter which comes first.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

static int
DictionaryCompare(left, right)
    char *left, *right;          /* The strings to compare */
{
    Tcl_UniChar uniLeft, uniRight, uniLeftLower, uniRightLower;
    int diff, zeros;
    int secondaryDiff = 0;

    while (1) {
	if (isdigit(UCHAR(*right)) /* INTL: digit */
		&& isdigit(UCHAR(*left))) { /* INTL: digit */
	    /*
	     * There are decimal numbers embedded in the two
	     * strings.  Compare them as numbers, rather than
	     * strings.  If one number has more leading zeros than
	     * the other, the number with more leading zeros sorts
	     * later, but only as a secondary choice.
	     */

	    zeros = 0;
	    while ((*right == '0') && (isdigit(UCHAR(right[1])))) {
		right++;
		zeros--;
	    }
	    while ((*left == '0') && (isdigit(UCHAR(left[1])))) {
		left++;
		zeros++;
	    }
	    if (secondaryDiff == 0) {
		secondaryDiff = zeros;
	    }

	    /*
	     * The code below compares the numbers in the two
	     * strings without ever converting them to integers.  It
	     * does this by first comparing the lengths of the
	     * numbers and then comparing the digit values.
	     */

	    diff = 0;
	    while (1) {
		if (diff == 0) {
		    diff = UCHAR(*left) - UCHAR(*right);
		}
		right++;
		left++;
		if (!isdigit(UCHAR(*right))) { /* INTL: digit */
		    if (isdigit(UCHAR(*left))) { /* INTL: digit */
			return 1;
		    } else {
			/*
			 * The two numbers have the same length. See
			 * if their values are different.
			 */

			if (diff != 0) {
			    return diff;
			}
			break;
		    }
		} else if (!isdigit(UCHAR(*left))) { /* INTL: digit */
		    return -1;
		}
	    }
	    continue;
	}

	/*
	 * Convert character to Unicode for comparison purposes.  If either
	 * string is at the terminating null, do a byte-wise comparison and
	 * bail out immediately.
	 */

	if ((*left != '\0') && (*right != '\0')) {
	    left += Tcl_UtfToUniChar(left, &uniLeft);
	    right += Tcl_UtfToUniChar(right, &uniRight);
	    /*
	     * Convert both chars to lower for the comparison, because
	     * dictionary sorts are case insensitve.  Covert to lower, not
	     * upper, so chars between Z and a will sort before A (where most
	     * other interesting punctuations occur)
	     */
	    uniLeftLower = Tcl_UniCharToLower(uniLeft);
	    uniRightLower = Tcl_UniCharToLower(uniRight);
	} else {
	    diff = UCHAR(*left) - UCHAR(*right);
	    break;
	}

        diff = uniLeftLower - uniRightLower;
        if (diff) {
	    return diff;
	} else if (secondaryDiff == 0) {
	    if (Tcl_UniCharIsUpper(uniLeft) &&
		    Tcl_UniCharIsLower(uniRight)) {
		secondaryDiff = -1;
	    } else if (Tcl_UniCharIsUpper(uniRight)
		    && Tcl_UniCharIsLower(uniLeft)) {
		secondaryDiff = 1;
	    }
        }
    }
    if (diff == 0) {
	diff = secondaryDiff;
    }
    return diff;
}
@


1.4
log
@touched all sources to ease next import
@
text
@d13 1
d18 1
a18 1
 * RCS: @@(#) $Id: tclCmdIL.c,v 1.6.8.3 2000/09/15 16:55:02 spolk Exp $
a22 1
#include "tclCompile.h"
d76 7
d87 1
a87 1
			    Tcl_Obj *listPtr, char *pattern,
d112 3
d326 1
d331 25
d402 1
a402 1
    static char *subCmds[] = {
d404 1
a404 1
	     "complete", "default", "exists", "globals",
d411 1
a411 1
	    ICompleteIdx, IDefaultIdx, IExistsIdx, IGlobalsIdx,
d451 3
d604 7
a610 10
    /*
     * We should not return a bytecompiled body.  If it is precompiled,
     * then the bodyPtr's string representation is bogus, since sources
     * are not available.  If it was just a bytecompiled body, then it
     * is likely to not be of any use to the caller, as it was compiled
     * for a separate procedure context [Bug: 3412], and noone else can
     * reasonably use it.
     * In order to make sure that later manipulations of the object do not
     * invalidate the internal representation, we make a copy of the string
     * representation and return that one, instead.
d614 6
a619 3
    resultPtr = bodyPtr;
    if (bodyPtr->typePtr == &tclByteCodeType) {
	resultPtr = Tcl_NewStringObj(bodyPtr->bytes, bodyPtr->length);
d621 1
d697 2
a698 1
    char *cmdName, *pattern, *simplePattern;
d971 48
d1110 1
a1110 1
    char *name;
d1228 1
a1228 1
    char *libDirName;
d1368 1
a1368 1
    char *pattern;		/* Pattern to match against. */
d1390 2
a1391 1
	if (!TclIsVarTemporary(localPtr) && !TclIsVarUndefined(varPtr)) {
d1458 1
a1458 1
	Tcl_SetStringObj(Tcl_GetObjResult(interp), (char *)nameOfExecutable, -1);
d1491 1
a1491 1
    char *patchlevel;
d1538 2
a1539 1
    char *cmdName, *pattern, *simplePattern;
a1599 8
		if (specificNsInPattern) {
		    elemObjPtr = Tcl_NewObj();
		    Tcl_GetCommandFullName(interp, (Tcl_Command) cmdPtr,
		            elemObjPtr);
		} else {
		    elemObjPtr = Tcl_NewStringObj(cmdName, -1);
		}

d1605 8
d1672 3
a1674 1
 *          info script
d1681 2
a1682 1
 *	an error, the result is an error message.
d1695 2
a1696 2
    if (objc != 2) {
        Tcl_WrongNumArgs(interp, 2, objv, NULL);
d1700 7
d1708 1
a1708 1
        Tcl_SetStringObj(Tcl_GetObjResult(interp), iPtr->scriptFile, -1);
d1779 1
a1779 1
    char *version;
d1827 2
a1828 1
    char *varName, *pattern, *simplePattern;
a2040 3
    Tcl_Obj *listPtr;
    Tcl_Obj **elemPtrs;
    int listLen, index, result;
d2042 4
a2045 2
    if (objc != 3) {
	Tcl_WrongNumArgs(interp, 1, objv, "list index");
d2050 4
a2053 1
     * Convert the first argument to a list if necessary.
d2056 20
a2075 4
    listPtr = objv[1];
    result = Tcl_ListObjGetElements(interp, listPtr, &listLen, &elemPtrs);
    if (result != TCL_OK) {
	return result;
d2077 45
d2124 3
a2126 1
     * Get the index from objv[2].
d2129 12
a2140 6
    result = TclGetIntForIndex(interp, objv[2], /*endValue*/ (listLen - 1),
	    &index);
    if (result != TCL_OK) {
	return result;
    }
    if ((index < 0) || (index >= listLen)) {
d2142 2
a2143 1
	 * The index is out of range: the result is an empty string object.
d2146 1
a2146 1
	return TCL_OK;
d2150 9
a2158 2
     * Make sure listPtr still refers to a list object. It might have been
     * converted to an int above if the argument objects were shared.
d2161 8
a2168 3
    if (listPtr->typePtr != &tclListType) {
	result = Tcl_ListObjGetElements(interp, listPtr, &listLen,
	        &elemPtrs);
d2170 67
a2236 1
	    return result;
d2238 55
a2292 1
    }
d2295 2
a2296 1
     * Set the interpreter's object result to the index-th list element.
d2299 70
a2368 2
    Tcl_SetObjResult(interp, elemPtrs[index]);
    return TCL_OK;
d2397 1
a2397 2
    Tcl_Obj *listPtr, *resultPtr;
    Tcl_ObjType *typePtr;
d2399 1
a2399 1
   
a2404 5
    /*
     * Get the index first since, if a conversion to int is needed, it
     * will invalidate the list's internal representation.
     */

d2410 7
a2416 1
    result = TclGetIntForIndex(interp, objv[2], /*endValue*/ len, &index);
d2420 3
d2426 1
a2426 2
     * we create a copy to modify: this is "copy on write". We create the
     * duplicate directly in the interpreter's object result.
d2428 1
a2428 1
    
d2432 1
a2432 24
	/*
	 * The following code must reflect the logic in Tcl_DuplicateObj()
	 * except that it must duplicate the list object directly into the
	 * interpreter's result.
	 */
	
	Tcl_ResetResult(interp);
	resultPtr = Tcl_GetObjResult(interp);
	typePtr = listPtr->typePtr;
	if (listPtr->bytes == NULL) {
	    resultPtr->bytes = NULL;
	} else if (listPtr->bytes != tclEmptyStringRep) {
	    len = listPtr->length;
	    TclInitStringRep(resultPtr, listPtr->bytes, len);
	}
	if (typePtr != NULL) {
	    if (typePtr->dupIntRepProc == NULL) {
		resultPtr->internalRep = listPtr->internalRep;
		resultPtr->typePtr = typePtr;
	    } else {
		(*typePtr->dupIntRepProc)(listPtr, resultPtr);
	    }
	}
	listPtr = resultPtr;
d2435 2
a2436 2
    
    if ((objc == 4) && (index == INT_MAX)) {
a2439 1

d2446 3
d2456 1
a2456 3
    if (!isDuplicate) {
	Tcl_SetObjResult(interp, listPtr);
    }
d2663 1
a2663 3
    int createdNewObj, first, last, listLen, numToDelete;
    int firstArgLen, result;
    char *firstArg;
d2671 1
a2671 12
    /*
     * If the list object is unshared we can modify it directly, otherwise
     * we create a copy to modify: this is "copy on write".
     */
    
    listPtr = objv[1];
    createdNewObj = 0;
    if (Tcl_IsShared(listPtr)) {
	listPtr = Tcl_DuplicateObj(listPtr);
	createdNewObj = 1;
    }
    result = Tcl_ListObjLength(interp, listPtr, &listLen);
a2672 4
        errorReturn:
	if (createdNewObj) {
	    Tcl_DecrRefCount(listPtr); /* free unneeded obj */
	}
d2677 3
a2679 1
     * Get the first and last indexes.
d2682 1
a2682 2
    result = TclGetIntForIndex(interp, objv[2], /*endValue*/ (listLen - 1),
	    &first);
d2684 1
a2684 1
	goto errorReturn;
a2685 1
    firstArg = Tcl_GetStringFromObj(objv[2], &firstArgLen);
d2687 1
a2687 2
    result = TclGetIntForIndex(interp, objv[3], /*endValue*/ (listLen - 1),
	    &last);
d2689 1
a2689 1
	goto errorReturn;
d2695 9
a2703 2
    if ((first >= listLen) && (listLen > 0)
	    && (strncmp(firstArg, "end", (unsigned) firstArgLen) != 0)) {
d2707 1
a2707 2
	result = TCL_ERROR;
	goto errorReturn;
d2718 11
d2737 4
a2740 1
	goto errorReturn;
d2777 9
a2785 3
    Tcl_Obj *patObj, **listv;
    static char *options[] = {
	"-exact",	"-glob",	"-regexp",	NULL
d2788 4
a2791 1
	LSEARCH_EXACT,	LSEARCH_GLOB,	LSEARCH_REGEXP
d2793 16
d2810 11
a2820 4
    mode = LSEARCH_GLOB;
    if (objc == 4) {
	if (Tcl_GetIndexFromObj(interp, objv[1], options, "search mode", 0,
		&mode) != TCL_OK) {
d2823 68
a2890 3
    } else if (objc != 3) {
	Tcl_WrongNumArgs(interp, 1, objv, "?mode? list pattern");
	return TCL_ERROR;
d2900 3
d2906 16
d2923 23
a2945 1
    patternBytes = Tcl_GetStringFromObj(patObj, &length);
d2947 5
d2953 34
a2986 8
    for (i = 0; i < listc; i++) {
	match = 0;
	switch ((enum options) mode) {
	    case LSEARCH_EXACT: {
		bytes = Tcl_GetStringFromObj(listv[i], &elemLen);
		if (length == elemLen) {
		    match = (memcmp(bytes, patternBytes,
			    (size_t) length) == 0);
d2989 41
d3031 51
a3081 2
	    case LSEARCH_GLOB: {
		match = Tcl_StringMatch(Tcl_GetString(listv[i]), patternBytes);
d3083 5
a3087 2
	    }
	    case LSEARCH_REGEXP: {
d3090 3
d3097 20
a3116 4
	}
	if (match != 0) {
	    index = i;
	    break;
d3119 96
a3214 1
    Tcl_SetIntObj(Tcl_GetObjResult(interp), index);
d3216 1
d3252 1
a3252 1
    static char *switches[] = {
d3269 1
a3269 1
    sortInfo.index = -1;
d3310 2
a3311 2
		if (TclGetIntForIndex(interp, objv[i+1], -2, &sortInfo.index)
			!= TCL_OK) {
a3313 1
		cmdPtr = objv[i+1];
d3351 1
a3351 1
    if (sortInfo.resultCode != TCL_OK) {
a3353 3
    if (length <= 0) {
        return TCL_OK;
    }
d3564 1
a3564 1
    if (infoPtr->index != -1) {
d3568 2
a3569 2
	 * compare the elements, not the lists.  The special index "end"
	 * is signaled here with a large negative index.
d3576 2
a3577 2
	if (infoPtr->index < -1) {
	    index = listLen - 1;
d3603 2
a3604 2
	if (infoPtr->index < -1) {
	    index = listLen - 1;
a3828 1

@


1.3
log
@touched all sources to ease next import
@
text
@@


1.3.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@a12 1
 * Copyright (c) 2001 by Kevin B. Kenny.  All rights reserved.
d17 1
a17 1
 * RCS: @@(#) $Id: tclCmdIL.c,v 1.44 2002/06/11 13:22:36 msofer Exp $
d22 1
a75 7
 * Magic values for the index field of the SortInfo structure.
 * Note that the index "end-1" will be translated to SORTIDX_END-1, etc.
 */
#define SORTIDX_NONE	-1		/* Not indexed; use whole value. */
#define SORTIDX_END	-2		/* Indexed from end. */

/*
d80 1
a80 1
			    Tcl_Obj *listPtr, CONST char *pattern,
a104 3
static int		InfoFunctionsCmd _ANSI_ARGS_((ClientData dummy,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *CONST objv[]));
a315 1
#ifdef TCL_WIDE_INT_IS_LONG
a319 25
#else
	/*
	 * Need to be a bit cautious to ensure that [expr]-like rules
	 * are enforced for interpretation of wide integers, despite
	 * the fact that the underlying API itself is a 'long' only one.
	 */
	if (objv[2]->typePtr == &tclIntType) {
	    incrAmount = objv[2]->internalRep.longValue;
	} else if (objv[2]->typePtr == &tclWideIntType) {
	    incrAmount = Tcl_WideAsLong(objv[2]->internalRep.wideValue);
	} else {
	    Tcl_WideInt wide;

	    if (Tcl_GetWideIntFromObj(interp, objv[2], &wide) != TCL_OK) {
		Tcl_AddErrorInfo(interp, "\n    (reading increment)");
		return TCL_ERROR;
	    }
	    incrAmount = Tcl_WideAsLong(wide);
	    if ((wide <= Tcl_LongAsWide(LONG_MAX))
		    && (wide >= Tcl_LongAsWide(LONG_MIN))) {
		objv[2]->typePtr = &tclIntType;
		objv[2]->internalRep.longValue = incrAmount;
	    }
	}
#endif
d366 1
a366 1
    static CONST char *subCmds[] = {
d368 1
a368 1
	     "complete", "default", "exists", "functions", "globals",
d375 1
a375 1
	    ICompleteIdx, IDefaultIdx, IExistsIdx, IFunctionsIdx, IGlobalsIdx,
a414 3
	case IFunctionsIdx:
	    result = InfoFunctionsCmd(clientData, interp, objc, objv);
	    break;
d565 10
a574 7
    /* 
     * Here we used to return procPtr->bodyPtr, except when the body was
     * bytecompiled - in that case, the return was a copy of the body's
     * string rep. In order to better isolate the implementation details
     * of the compiler/engine subsystem, we now always return a copy of 
     * the string rep. It is important to return a copy so that later 
     * manipulations of the object do not invalidate the internal rep.
d578 3
a580 6
    if (bodyPtr->bytes == NULL) {
	/*
	 * The string rep might not be valid if the procedure has
	 * never been run before.  [Bug #545644]
	 */
	(void) Tcl_GetString(bodyPtr);
a581 1
    resultPtr = Tcl_NewStringObj(bodyPtr->bytes, bodyPtr->length);
d657 1
a657 2
    char *cmdName, *pattern;
    CONST char *simplePattern;
a929 48
 * InfoFunctionsCmd --
 *
 *      Called to implement the "info functions" command that returns the
 *      list of math functions matching an optional pattern. Handles the
 *      following syntax:
 *
 *          info functions ?pattern?
 *
 * Results:
 *      Returns TCL_OK if successful and TCL_ERROR if there is an error.
 *
 * Side effects:
 *      Returns a result in the interpreter's result object. If there is
 *	an error, the result is an error message.
 *
 *----------------------------------------------------------------------
 */

static int
InfoFunctionsCmd(dummy, interp, objc, objv)
    ClientData dummy;		/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    char *pattern;
    Tcl_Obj *listPtr;

    if (objc == 2) {
        pattern = NULL;
    } else if (objc == 3) {
        pattern = Tcl_GetString(objv[2]);
    } else {
        Tcl_WrongNumArgs(interp, 2, objv, "?pattern?");
        return TCL_ERROR;
    }

    listPtr = Tcl_ListMathFuncs(interp, pattern);
    if (listPtr == NULL) {
	return TCL_ERROR;
    }
    Tcl_SetObjResult(interp, listPtr);
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
d1021 1
a1021 1
    CONST char *name;
d1139 1
a1139 1
    CONST char *libDirName;
d1279 1
a1279 1
    CONST char *pattern;	/* Pattern to match against. */
d1301 1
a1301 2
	if (!TclIsVarTemporary(localPtr) && !TclIsVarUndefined(varPtr)
	        && (includeLinks || !TclIsVarLink(varPtr))) {
d1368 1
a1368 1
	Tcl_SetStringObj(Tcl_GetObjResult(interp), nameOfExecutable, -1);
d1401 1
a1401 1
    CONST char *patchlevel;
d1448 1
a1448 2
    char *cmdName, *pattern;
    CONST char *simplePattern;
d1509 8
a1521 8
		    if (specificNsInPattern) {
			elemObjPtr = Tcl_NewObj();
			Tcl_GetCommandFullName(interp, (Tcl_Command) cmdPtr,
				elemObjPtr);
		    } else {
			elemObjPtr = Tcl_NewStringObj(cmdName, -1);
		    }

d1581 1
a1581 3
 *          info script ?newName?
 *
 *	If newName is specified, it will set that as the internal name.
d1588 1
a1588 2
 *	an error, the result is an error message.  It may change the
 *	internal script filename.
d1601 2
a1602 2
    if ((objc != 2) && (objc != 3)) {
        Tcl_WrongNumArgs(interp, 2, objv, "?filename?");
a1605 7
    if (objc == 3) {
	if (iPtr->scriptFile != NULL) {
	    Tcl_DecrRefCount(iPtr->scriptFile);
	}
	iPtr->scriptFile = objv[2];
	Tcl_IncrRefCount(iPtr->scriptFile);
    }
d1607 1
a1607 1
        Tcl_SetObjResult(interp, iPtr->scriptFile);
d1678 1
a1678 1
    CONST char *version;
d1726 1
a1726 2
    char *varName, *pattern;
    CONST char *simplePattern;
d1939 3
d1943 2
a1944 4
    Tcl_Obj *elemPtr;		/* Pointer to the element being extracted */

    if (objc < 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "list ?index...?");
d1949 1
a1949 4
     * If objc == 3, then objv[ 2 ] may be either a single index or
     * a list of indices: go to TclLindexList to determine which.
     * If objc >= 4, or objc == 2, then objv[ 2 .. objc-2 ] are all
     * single indices and processed as such in TclLindexFlat.
d1952 5
a1956 7
    if ( objc == 3 ) {

	elemPtr = TclLindexList( interp, objv[ 1 ], objv[ 2 ] );

    } else {

	elemPtr = TclLindexFlat( interp, objv[ 1 ], objc-2, objv+2 );
a1957 2
    }
	
d1959 1
a1959 1
     * Set the interpreter's object result to the last element extracted
d1962 4
a1965 6
    if ( elemPtr == NULL ) {
	return TCL_ERROR;
    } else {
	Tcl_SetObjResult(interp, elemPtr);
	Tcl_DecrRefCount( elemPtr );
	return TCL_OK;
d1967 1
a1967 64
}

/*
 *----------------------------------------------------------------------
 *
 * TclLindexList --
 *
 *	This procedure handles the 'lindex' command when objc==3.
 *
 * Results:
 *	Returns a pointer to the object extracted, or NULL if an
 *	error occurred.
 *
 * Side effects:
 *	None.
 *
 * If objv[1] can be parsed as a list, TclLindexList handles extraction
 * of the desired element locally.  Otherwise, it invokes
 * TclLindexFlat to treat objv[1] as a scalar.
 *
 * The reference count of the returned object includes one reference
 * corresponding to the pointer returned.  Thus, the calling code will
 * usually do something like:
 *	Tcl_SetObjResult( interp, result );
 *	Tcl_DecrRefCount( result );
 *
 *----------------------------------------------------------------------
 */

Tcl_Obj *
TclLindexList( interp, listPtr, argPtr )
    Tcl_Interp* interp;		/* Tcl interpreter */
    Tcl_Obj* listPtr;		/* List being unpacked */
    Tcl_Obj* argPtr;		/* Index or index list */
{

    Tcl_Obj **elemPtrs;		/* Elements of the list being manipulated. */
    int listLen;		/* Length of the list being manipulated. */
    int index;			/* Index into the list */
    int result;			/* Result returned from a Tcl library call */
    int i;			/* Current index number */
    Tcl_Obj** indices;		/* Array of list indices */
    int indexCount;		/* Size of the array of list indices */
    Tcl_Obj* oldListPtr;	/* Temp location to preserve the list
				 * pointer when replacing it with a sublist */

    /*
     * Determine whether argPtr designates a list or a single index.
     * We have to be careful about the order of the checks to avoid
     * repeated shimmering; see TIP#22 and TIP#33 for the details.
     */

    if ( argPtr->typePtr != &tclListType 
	 && TclGetIntForIndex( NULL , argPtr, 0, &index ) == TCL_OK ) {

	/*
	 * argPtr designates a single index.
	 */

	return TclLindexFlat( interp, listPtr, 1, &argPtr );

    } else if ( Tcl_ListObjGetElements( NULL, argPtr, &indexCount, &indices )
		!= TCL_OK ) {

d1969 1
a1969 2
	 * argPtr designates something that is neither an index nor a
	 * well-formed list.  Report the error via TclLindexFlat.
d1972 1
a1972 1
	return TclLindexFlat( interp, listPtr, 1, &argPtr );
d1976 2
a1977 2
     * Record the reference to the list that we are maintaining in
     * the activation record.
d1980 3
a1982 15
    Tcl_IncrRefCount( listPtr );

    /*
     * argPtr designates a list, and the 'else if' above has parsed it
     * into indexCount and indices.
     */

    for ( i = 0; i < indexCount; ++i ) {

	/*
	 * Convert the current listPtr to a list if necessary.
	 */
	    
	result = Tcl_ListObjGetElements( interp, listPtr,
					 &listLen, &elemPtrs);
d1984 1
a1984 2
	    Tcl_DecrRefCount( listPtr );
	    return NULL;
d1986 1
a1986 67
	    
	/*
	 * Get the index from indices[ i ]
	 */
	
	result = TclGetIntForIndex( interp, indices[ i ],
				    /*endValue*/ (listLen - 1),
				    &index );
	if ( result != TCL_OK ) {
	    /*
	     * Index could not be parsed
	     */

	    Tcl_DecrRefCount( listPtr );
	    return NULL;

	} else if ( index < 0
		    || index >= listLen ) {
	    /*
	     * Index is out of range
	     */
	    Tcl_DecrRefCount( listPtr );
	    listPtr = Tcl_NewObj();
	    Tcl_IncrRefCount( listPtr );
	    return listPtr;
	}
	
	/*
	 * Make sure listPtr still refers to a list object.
	 * If it shared a Tcl_Obj structure with the arguments, then
	 * it might have just been converted to something else.
	 */
	
	if (listPtr->typePtr != &tclListType) {
	    result = Tcl_ListObjGetElements(interp, listPtr, &listLen,
					    &elemPtrs);
	    if (result != TCL_OK) {
		Tcl_DecrRefCount( listPtr );
		return NULL;
	    }
	}
	
	/*
	 * Extract the pointer to the appropriate element
	 */
	
	oldListPtr = listPtr;
	listPtr = elemPtrs[ index ];
	Tcl_IncrRefCount( listPtr );
	Tcl_DecrRefCount( oldListPtr );
	
	/*
	 * The work we did above may have caused the internal rep
	 * of *argPtr to change to something else.  Get it back.
	 */
	
	result = Tcl_ListObjGetElements( interp, argPtr,
					 &indexCount, &indices );
	if ( result != TCL_OK ) {
	    /* 
	     * This can't happen unless some extension corrupted a Tcl_Obj.
	     */
	    Tcl_DecrRefCount( listPtr );
	    return NULL;
	}
	
    } /* end for */
d1989 1
a1989 2
     * Return the last object extracted.  Its reference count will include
     * the reference being returned.
d1992 2
a1993 123
    return listPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * TclLindexFlat --
 *
 *	This procedure handles the 'lindex' command, given that the
 *	arguments to the command are known to be a flat list.
 *
 * Results:
 *	Returns a standard Tcl result.
 *
 * Side effects:
 *	None.
 *
 * This procedure is called from either tclExecute.c or
 * Tcl_LindexObjCmd whenever either is presented with
 * objc == 2 or objc >= 4.  It is also called from TclLindexList
 * for the objc==3 case once it is determined that objv[2] cannot
 * be parsed as a list.
 *
 *----------------------------------------------------------------------
 */

Tcl_Obj *
TclLindexFlat( interp, listPtr, indexCount, indexArray )
    Tcl_Interp* interp;		/* Tcl interpreter */
    Tcl_Obj* listPtr;		/* Tcl object representing the list */
    int indexCount;		/* Count of indices */
    Tcl_Obj* CONST indexArray[];
				/* Array of pointers to Tcl objects
				 * representing the indices in the
				 * list */
{

    int i;			/* Current list index */
    int result;			/* Result of Tcl library calls */
    int listLen;		/* Length of the current list being 
				 * processed */
    Tcl_Obj** elemPtrs;		/* Array of pointers to the elements
				 * of the current list */
    int index;			/* Parsed version of the current element
				 * of indexArray  */
    Tcl_Obj* oldListPtr;	/* Temporary to hold listPtr so that
				 * its ref count can be decremented. */

    /*
     * Record the reference to the 'listPtr' object that we are
     * maintaining in the C activation record.
     */

    Tcl_IncrRefCount( listPtr );

    for ( i = 0; i < indexCount; ++i ) {

	/*
	 * Convert the current listPtr to a list if necessary.
	 */
	
	result = Tcl_ListObjGetElements(interp, listPtr,
					&listLen, &elemPtrs);
	if (result != TCL_OK) {
	    Tcl_DecrRefCount( listPtr );
	    return NULL;
	}
	
	/*
	 * Get the index from objv[i]
	 */
	
	result = TclGetIntForIndex( interp, indexArray[ i ],
				    /*endValue*/ (listLen - 1),
				    &index );
	if ( result != TCL_OK ) {

	    /* Index could not be parsed */

	    Tcl_DecrRefCount( listPtr );
	    return NULL;

	} else if ( index < 0
		    || index >= listLen ) {
	    
	    /*
	     * Index is out of range
	     */
		
	    Tcl_DecrRefCount( listPtr );
	    listPtr = Tcl_NewObj();
	    Tcl_IncrRefCount( listPtr );
	    return listPtr;
	}
	    
	/*
	 * Make sure listPtr still refers to a list object.
	 * It might have been converted to something else above
	 * if objv[1] overlaps with one of the other parameters.
	 */
	
	if (listPtr->typePtr != &tclListType) {
	    result = Tcl_ListObjGetElements(interp, listPtr, &listLen,
					    &elemPtrs);
	    if (result != TCL_OK) {
		Tcl_DecrRefCount( listPtr );
		return NULL;
	    }
	}
	
	/*
	 * Extract the pointer to the appropriate element
	 */
	
	oldListPtr = listPtr;
	listPtr = elemPtrs[ index ];
	Tcl_IncrRefCount( listPtr );
	Tcl_DecrRefCount( oldListPtr );
	
    }

    return listPtr;

d2022 2
a2023 1
    Tcl_Obj *listPtr;
d2025 1
a2025 1

d2031 5
d2041 1
a2041 7
    /*
     * Get the index.  "end" is interpreted to be the index after the last
     * element, such that using it will cause any inserted elements to be
     * appended to the list.
     */

    result = TclGetIntForIndex(interp, objv[2], /*end*/ len, &index);
a2044 3
    if (index > len) {
	index = len;
    }
d2048 2
a2049 1
     * we create a copy to modify: this is "copy on write".
d2051 1
a2051 1

d2055 24
a2078 1
	listPtr = Tcl_DuplicateObj(listPtr);
d2081 2
a2082 2

    if ((objc == 4) && (index == len)) {
d2086 1
a2092 3
	if (isDuplicate) {
	    Tcl_DecrRefCount(listPtr); /* free unneeded obj */
	}
d2100 3
a2102 1
    Tcl_SetObjResult(interp, listPtr);
d2309 3
a2311 1
    int isDuplicate, first, last, listLen, numToDelete, result;
d2319 12
a2330 1
    result = Tcl_ListObjLength(interp, objv[1], &listLen);
d2332 4
d2340 1
a2340 3
     * Get the first and last indexes.  "end" is interpreted to be the index
     * for the last element, such that using it will cause that element to
     * be included for deletion.
d2343 2
a2344 1
    result = TclGetIntForIndex(interp, objv[2], /*end*/ (listLen - 1), &first);
d2346 1
a2346 1
	return result;
d2348 1
d2350 2
a2351 1
    result = TclGetIntForIndex(interp, objv[3], /*end*/ (listLen - 1), &last);
d2353 1
a2353 1
	return result;
d2359 2
a2360 9

    /*
     * Complain if the user asked for a start element that is greater than the
     * list length.  This won't ever trigger for the "end*" case as that will
     * be properly constrained by TclGetIntForIndex because we use listLen-1
     * (to allow for replacing the last elem).
     */

    if ((first >= listLen) && (listLen > 0)) {
d2364 2
a2365 1
	return TCL_ERROR;
a2375 11
    /*
     * If the list object is unshared we can modify it directly, otherwise
     * we create a copy to modify: this is "copy on write".
     */

    listPtr = objv[1];
    isDuplicate = 0;
    if (Tcl_IsShared(listPtr)) {
	listPtr = Tcl_DuplicateObj(listPtr);
	isDuplicate = 1;
    }
d2384 1
a2384 4
	if (isDuplicate) {
	    Tcl_DecrRefCount(listPtr); /* free unneeded obj */
	}
	return result;
d2421 3
a2423 9
    int dataType, isIncreasing, lower, upper, patInt, objInt;
    int offset, allMatches, inlineReturn, negatedMatch;
    double patDouble, objDouble;
    Tcl_Obj *patObj, **listv, *listPtr, *startPtr;
    static CONST char *options[] = {
	"-all",	    "-ascii", "-decreasing", "-dictionary",
	"-exact",   "-glob",  "-increasing", "-inline",
	"-integer", "-not",   "-real",	     "-regexp",
	"-sorted",  "-start", NULL
d2426 1
a2426 4
	LSEARCH_ALL, LSEARCH_ASCII, LSEARCH_DECREASING, LSEARCH_DICTIONARY,
	LSEARCH_EXACT, LSEARCH_GLOB, LSEARCH_INCREASING, LSEARCH_INLINE,
	LSEARCH_INTEGER, LSEARCH_NOT, LSEARCH_REAL, LSEARCH_REGEXP,
	LSEARCH_SORTED, LSEARCH_START
a2427 16
    enum datatypes {
	ASCII, DICTIONARY, INTEGER, REAL
    };
    enum modes {
	EXACT, GLOB, REGEXP, SORTED
    };

    mode = GLOB;
    dataType = ASCII;
    isIncreasing = 1;
    allMatches = 0;
    inlineReturn = 0;
    negatedMatch = 0;
    listPtr = NULL;
    startPtr = NULL;
    offset = 0;
d2429 4
a2432 11
    if (objc < 3) {
	Tcl_WrongNumArgs(interp, 1, objv, "?options? list pattern");
	return TCL_ERROR;
    }

    for (i = 1; i < objc-2; i++) {
	if (Tcl_GetIndexFromObj(interp, objv[i], options, "option", 0, &index)
		!= TCL_OK) {
	    if (startPtr) {
		Tcl_DecrRefCount(startPtr);
	    }
d2435 3
a2437 68
	switch ((enum options) index) {
	case LSEARCH_ALL:		/* -all */
	    allMatches = 1;
	    break;
	case LSEARCH_ASCII:		/* -ascii */
	    dataType = ASCII;
	    break;
	case LSEARCH_DECREASING:	/* -decreasing */
	    isIncreasing = 0;
	    break;
	case LSEARCH_DICTIONARY:	/* -dictionary */
	    dataType = DICTIONARY;
	    break;
	case LSEARCH_EXACT:		/* -increasing */
	    mode = EXACT;
	    break;
	case LSEARCH_GLOB:		/* -glob */
	    mode = GLOB;
	    break;
	case LSEARCH_INCREASING:	/* -increasing */
	    isIncreasing = 1;
	    break;
	case LSEARCH_INLINE:		/* -inline */
	    inlineReturn = 1;
	    break;
	case LSEARCH_INTEGER:		/* -integer */
	    dataType = INTEGER;
	    break;
	case LSEARCH_NOT:		/* -not */
	    negatedMatch = 1;
	    break;
	case LSEARCH_REAL:		/* -real */
	    dataType = REAL;
	    break;
	case LSEARCH_REGEXP:		/* -regexp */
	    mode = REGEXP;
	    break;
	case LSEARCH_SORTED:		/* -sorted */
	    mode = SORTED;
	    break;
	case LSEARCH_START:		/* -start */
	    /*
	     * If there was a previous -start option, release its saved
	     * index because it will either be replaced or there will be
	     * an error.
	     */
	    if (startPtr) {
		Tcl_DecrRefCount(startPtr);
	    }
	    if (i > objc-4) {
		Tcl_AppendResult(interp, "missing starting index", NULL);
		return TCL_ERROR;
	    }
	    i++;
	    if (objv[i] == objv[objc - 2]) {
		/*
		 * Take copy to prevent shimmering problems.  Note
		 * that it does not matter if the index obj is also a
		 * component of the list being searched.  We only need
		 * to copy where the list and the index are
		 * one-and-the-same.
		 */
		startPtr = Tcl_DuplicateObj(objv[i]);
	    } else {
		startPtr = objv[i];
		Tcl_IncrRefCount(startPtr);
	    }
	}
a2446 3
	if (startPtr) {
	    Tcl_DecrRefCount(startPtr);
	}
a2449 16
    /*
     * Get the user-specified start offset.
     */
    if (startPtr) {
	result = TclGetIntForIndex(interp, startPtr, listc-1, &offset);
	Tcl_DecrRefCount(startPtr);
	if (result != TCL_OK) {
	    return result;
	}
	if (offset < 0) {
	    offset = 0;
	} else if (offset > listc-1) {
	    offset = listc-1;
	}
    }

d2451 1
a2451 23
    patternBytes = NULL;
    if ((enum modes) mode == EXACT || (enum modes) mode == SORTED) {
	switch ((enum datatypes) dataType) {
	case ASCII:
	case DICTIONARY:
	    patternBytes = Tcl_GetStringFromObj(patObj, &length);
	    break;
	case INTEGER:
	    result = Tcl_GetIntFromObj(interp, patObj, &patInt);
	    if (result != TCL_OK) {
		return result;
	    }
	    break;
	case REAL:
	    result = Tcl_GetDoubleFromObj(interp, patObj, &patDouble);
	    if (result != TCL_OK) {
		return result;
	    }
	    break;
	}
    } else {
	patternBytes = Tcl_GetStringFromObj(patObj, &length);
    }
a2452 5
    /*
     * Set default index value to -1, indicating failure; if we find the
     * item in the course of our search, index will be set to the correct
     * value.
     */
d2454 8
a2461 34
    match = 0;

    if ((enum modes) mode == SORTED && !allMatches && !negatedMatch) {
	/*
	 * If the data is sorted, we can do a more intelligent search.
	 * Note that there is no point in being smart when -all was
	 * specified; in that case, we have to look at all items anyway,
	 * and there is no sense in doing this when the match sense is
	 * inverted.
	 */
	lower = offset - 1;
	upper = listc;
	while (lower + 1 != upper) {
	    i = (lower + upper)/2;
	    switch ((enum datatypes) dataType) {
	    case ASCII:
		bytes = Tcl_GetString(listv[i]);
		match = strcmp(patternBytes, bytes);
		break;
	    case DICTIONARY:
		bytes = Tcl_GetString(listv[i]);
		match = DictionaryCompare(patternBytes, bytes);
		break;
	    case INTEGER:
		result = Tcl_GetIntFromObj(interp, listv[i], &objInt);
		if (result != TCL_OK) {
		    return result;
		}
		if (patInt == objInt) {
		    match = 0;
		} else if (patInt < objInt) {
		    match = -1;
		} else {
		    match = 1;
d2464 3
a2466 12
	    case REAL:
		result = Tcl_GetDoubleFromObj(interp, listv[i], &objDouble);
		if (result != TCL_OK) {
		    return result;
		}
		if (patDouble == objDouble) {
		    match = 0;
		} else if (patDouble < objDouble) {
		    match = -1;
		} else {
		    match = 1;
		}
d2469 1
a2469 85
	    if (match == 0) {
		/*
		 * Normally, binary search is written to stop when it
		 * finds a match.  If there are duplicates of an element in
		 * the list, our first match might not be the first occurance.
		 * Consider:  0 0 0 1 1 1 2 2 2
		 * To maintain consistancy with standard lsearch semantics,
		 * we must find the leftmost occurance of the pattern in the
		 * list.  Thus we don't just stop searching here.  This
		 * variation means that a search always makes log n
		 * comparisons (normal binary search might "get lucky" with
		 * an early comparison).
		 */
		index = i;
		upper = i;
	    } else if (match > 0) {
		if (isIncreasing) {
		    lower = i;
		} else {
		    upper = i;
		}
	    } else {
		if (isIncreasing) {
		    upper = i;
		} else {
		    lower = i;
		}
	    }
	}

    } else {
	/*
	 * We need to do a linear search, because (at least one) of:
	 *   - our matcher can only tell equal vs. not equal
	 *   - our matching sense is negated
	 *   - we're building a list of all matched items
	 */
	if (allMatches) {
	    listPtr = Tcl_NewListObj(0, (Tcl_Obj **) NULL);
	}
	for (i = offset; i < listc; i++) {
	    match = 0;
	    switch ((enum modes) mode) {
	    case SORTED:
	    case EXACT:
		switch ((enum datatypes) dataType) {
		case ASCII:
		    bytes = Tcl_GetStringFromObj(listv[i], &elemLen);
		    if (length == elemLen) {
			match = (memcmp(bytes, patternBytes,
				(size_t) length) == 0);
		    }
		    break;
		case DICTIONARY:
		    bytes = Tcl_GetString(listv[i]);
		    match = (DictionaryCompare(bytes, patternBytes) == 0);
		    break;
		case INTEGER:
		    result = Tcl_GetIntFromObj(interp, listv[i], &objInt);
		    if (result != TCL_OK) {
			if (listPtr) {
			    Tcl_DecrRefCount(listPtr);
			}
			return result;
		    }
		    match = (objInt == patInt);
		    break;
		case REAL:
		    result = Tcl_GetDoubleFromObj(interp, listv[i],
			    &objDouble);
		    if (result != TCL_OK) {
			if (listPtr) {
			    Tcl_DecrRefCount(listPtr);
			}
			return result;
		    }
		    match = (objDouble == patDouble);
		    break;
		}
		break;
	    case GLOB:
		match = Tcl_StringMatch(Tcl_GetString(listv[i]),
			patternBytes);
		break;
	    case REGEXP:
a2471 3
		    if (listPtr) {
			Tcl_DecrRefCount(listPtr);
		    }
a2475 20
	    /*
	     * Invert match condition for -not
	     */
	    if (negatedMatch) {
		match = !match;
	    }
	    if (match != 0) {
		if (!allMatches) {
		    index = i;
		    break;
		} else if (inlineReturn) {
		    /*
		     * Note that these appends are not expected to fail.
		     */
		    Tcl_ListObjAppendElement(interp, listPtr, listv[i]);
		} else {
		    Tcl_ListObjAppendElement(interp, listPtr,
			    Tcl_NewIntObj(i));
		}
	    }
d2477 4
d2482 1
a2482 17

    /*
     * Return everything or a single value.
     */
    if (allMatches) {
	Tcl_SetObjResult(interp, listPtr);
    } else if (!inlineReturn) {
	Tcl_SetIntObj(Tcl_GetObjResult(interp), index);
    } else if (index < 0) {
	/*
	 * Is this superfluous?  The result should be a blank object
	 * by default...
	 */
	Tcl_SetObjResult(interp, Tcl_NewObj());
    } else {
	Tcl_SetObjResult(interp, listv[index]);
    }
a2488 80
 * Tcl_LsetObjCmd --
 *
 *	This procedure is invoked to process the "lset" Tcl command.
 *	See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_LsetObjCmd( clientData, interp, objc, objv )
    ClientData clientData;	/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument values. */
{

    Tcl_Obj* listPtr;		/* Pointer to the list being altered. */
    Tcl_Obj* finalValuePtr;	/* Value finally assigned to the variable */

    /* Check parameter count */

    if ( objc < 3 ) {
	Tcl_WrongNumArgs( interp, 1, objv, "listVar index ?index...? value" );
	return TCL_ERROR;
    }

    /* Look up the list variable's value */

    listPtr = Tcl_ObjGetVar2( interp, objv[ 1 ], (Tcl_Obj*) NULL,
			      TCL_LEAVE_ERR_MSG );
    if ( listPtr == NULL ) {
	return TCL_ERROR;
    }

    /* 
     * Substitute the value in the value.  Return either the value or
     * else an unshared copy of it.
     */

    if ( objc == 4 ) {
	finalValuePtr = TclLsetList( interp, listPtr,
				     objv[ 2 ], objv[ 3 ] );
    } else {
	finalValuePtr = TclLsetFlat( interp, listPtr,
				     objc-3, objv+2, objv[ objc-1 ] );
    }

    /*
     * If substitution has failed, bail out.
     */

    if ( finalValuePtr == NULL ) {
	return TCL_ERROR;
    }

    /* Finally, update the variable so that traces fire. */

    listPtr = Tcl_ObjSetVar2( interp, objv[1], NULL, finalValuePtr,
			      TCL_LEAVE_ERR_MSG );
    Tcl_DecrRefCount( finalValuePtr );
    if ( listPtr == NULL ) {
	return TCL_ERROR;
    }

    /* Return the new value of the variable as the interpreter result. */

    Tcl_SetObjResult( interp, listPtr );
    return TCL_OK;

}

/*
 *----------------------------------------------------------------------
 *
d2519 1
a2519 1
    static CONST char *switches[] = {
d2536 1
a2536 1
    sortInfo.index = SORTIDX_NONE;
d2577 2
a2578 2
		if (TclGetIntForIndex(interp, objv[i+1], SORTIDX_END,
			&sortInfo.index) != TCL_OK) {
d2581 1
d2619 1
a2619 1
    if (sortInfo.resultCode != TCL_OK || length <= 0) {
d2622 3
d2835 1
a2835 1
    if (infoPtr->index != SORTIDX_NONE) {
d2839 2
a2840 2
	 * compare the elements, not the lists.  "end"-relative indices
	 * are signaled here with large negative values.
d2847 2
a2848 2
	if (infoPtr->index < SORTIDX_NONE) {
	    index = listLen + infoPtr->index + 1;
d2874 2
a2875 2
	if (infoPtr->index < SORTIDX_NONE) {
	    index = listLen + infoPtr->index + 1;
d3100 1
@


1.3.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@a12 1
 * Copyright (c) 2001 by Kevin B. Kenny.  All rights reserved.
d17 1
a17 1
 * RCS: @@(#) $Id: tclCmdIL.c,v 1.44 2002/06/11 13:22:36 msofer Exp $
d22 1
a75 7
 * Magic values for the index field of the SortInfo structure.
 * Note that the index "end-1" will be translated to SORTIDX_END-1, etc.
 */
#define SORTIDX_NONE	-1		/* Not indexed; use whole value. */
#define SORTIDX_END	-2		/* Indexed from end. */

/*
d80 1
a80 1
			    Tcl_Obj *listPtr, CONST char *pattern,
a104 3
static int		InfoFunctionsCmd _ANSI_ARGS_((ClientData dummy,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *CONST objv[]));
a315 1
#ifdef TCL_WIDE_INT_IS_LONG
a319 25
#else
	/*
	 * Need to be a bit cautious to ensure that [expr]-like rules
	 * are enforced for interpretation of wide integers, despite
	 * the fact that the underlying API itself is a 'long' only one.
	 */
	if (objv[2]->typePtr == &tclIntType) {
	    incrAmount = objv[2]->internalRep.longValue;
	} else if (objv[2]->typePtr == &tclWideIntType) {
	    incrAmount = Tcl_WideAsLong(objv[2]->internalRep.wideValue);
	} else {
	    Tcl_WideInt wide;

	    if (Tcl_GetWideIntFromObj(interp, objv[2], &wide) != TCL_OK) {
		Tcl_AddErrorInfo(interp, "\n    (reading increment)");
		return TCL_ERROR;
	    }
	    incrAmount = Tcl_WideAsLong(wide);
	    if ((wide <= Tcl_LongAsWide(LONG_MAX))
		    && (wide >= Tcl_LongAsWide(LONG_MIN))) {
		objv[2]->typePtr = &tclIntType;
		objv[2]->internalRep.longValue = incrAmount;
	    }
	}
#endif
d366 1
a366 1
    static CONST char *subCmds[] = {
d368 1
a368 1
	     "complete", "default", "exists", "functions", "globals",
d375 1
a375 1
	    ICompleteIdx, IDefaultIdx, IExistsIdx, IFunctionsIdx, IGlobalsIdx,
a414 3
	case IFunctionsIdx:
	    result = InfoFunctionsCmd(clientData, interp, objc, objv);
	    break;
d565 10
a574 7
    /* 
     * Here we used to return procPtr->bodyPtr, except when the body was
     * bytecompiled - in that case, the return was a copy of the body's
     * string rep. In order to better isolate the implementation details
     * of the compiler/engine subsystem, we now always return a copy of 
     * the string rep. It is important to return a copy so that later 
     * manipulations of the object do not invalidate the internal rep.
d578 3
a580 6
    if (bodyPtr->bytes == NULL) {
	/*
	 * The string rep might not be valid if the procedure has
	 * never been run before.  [Bug #545644]
	 */
	(void) Tcl_GetString(bodyPtr);
a581 1
    resultPtr = Tcl_NewStringObj(bodyPtr->bytes, bodyPtr->length);
d657 1
a657 2
    char *cmdName, *pattern;
    CONST char *simplePattern;
a929 48
 * InfoFunctionsCmd --
 *
 *      Called to implement the "info functions" command that returns the
 *      list of math functions matching an optional pattern. Handles the
 *      following syntax:
 *
 *          info functions ?pattern?
 *
 * Results:
 *      Returns TCL_OK if successful and TCL_ERROR if there is an error.
 *
 * Side effects:
 *      Returns a result in the interpreter's result object. If there is
 *	an error, the result is an error message.
 *
 *----------------------------------------------------------------------
 */

static int
InfoFunctionsCmd(dummy, interp, objc, objv)
    ClientData dummy;		/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    char *pattern;
    Tcl_Obj *listPtr;

    if (objc == 2) {
        pattern = NULL;
    } else if (objc == 3) {
        pattern = Tcl_GetString(objv[2]);
    } else {
        Tcl_WrongNumArgs(interp, 2, objv, "?pattern?");
        return TCL_ERROR;
    }

    listPtr = Tcl_ListMathFuncs(interp, pattern);
    if (listPtr == NULL) {
	return TCL_ERROR;
    }
    Tcl_SetObjResult(interp, listPtr);
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
d1021 1
a1021 1
    CONST char *name;
d1139 1
a1139 1
    CONST char *libDirName;
d1279 1
a1279 1
    CONST char *pattern;	/* Pattern to match against. */
d1301 1
a1301 2
	if (!TclIsVarTemporary(localPtr) && !TclIsVarUndefined(varPtr)
	        && (includeLinks || !TclIsVarLink(varPtr))) {
d1368 1
a1368 1
	Tcl_SetStringObj(Tcl_GetObjResult(interp), nameOfExecutable, -1);
d1401 1
a1401 1
    CONST char *patchlevel;
d1448 1
a1448 2
    char *cmdName, *pattern;
    CONST char *simplePattern;
d1509 8
a1521 8
		    if (specificNsInPattern) {
			elemObjPtr = Tcl_NewObj();
			Tcl_GetCommandFullName(interp, (Tcl_Command) cmdPtr,
				elemObjPtr);
		    } else {
			elemObjPtr = Tcl_NewStringObj(cmdName, -1);
		    }

d1581 1
a1581 3
 *          info script ?newName?
 *
 *	If newName is specified, it will set that as the internal name.
d1588 1
a1588 2
 *	an error, the result is an error message.  It may change the
 *	internal script filename.
d1601 2
a1602 2
    if ((objc != 2) && (objc != 3)) {
        Tcl_WrongNumArgs(interp, 2, objv, "?filename?");
a1605 7
    if (objc == 3) {
	if (iPtr->scriptFile != NULL) {
	    Tcl_DecrRefCount(iPtr->scriptFile);
	}
	iPtr->scriptFile = objv[2];
	Tcl_IncrRefCount(iPtr->scriptFile);
    }
d1607 1
a1607 1
        Tcl_SetObjResult(interp, iPtr->scriptFile);
d1678 1
a1678 1
    CONST char *version;
d1726 1
a1726 2
    char *varName, *pattern;
    CONST char *simplePattern;
d1939 3
d1943 2
a1944 4
    Tcl_Obj *elemPtr;		/* Pointer to the element being extracted */

    if (objc < 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "list ?index...?");
d1949 1
a1949 4
     * If objc == 3, then objv[ 2 ] may be either a single index or
     * a list of indices: go to TclLindexList to determine which.
     * If objc >= 4, or objc == 2, then objv[ 2 .. objc-2 ] are all
     * single indices and processed as such in TclLindexFlat.
d1952 5
a1956 7
    if ( objc == 3 ) {

	elemPtr = TclLindexList( interp, objv[ 1 ], objv[ 2 ] );

    } else {

	elemPtr = TclLindexFlat( interp, objv[ 1 ], objc-2, objv+2 );
a1957 2
    }
	
d1959 1
a1959 1
     * Set the interpreter's object result to the last element extracted
d1962 4
a1965 6
    if ( elemPtr == NULL ) {
	return TCL_ERROR;
    } else {
	Tcl_SetObjResult(interp, elemPtr);
	Tcl_DecrRefCount( elemPtr );
	return TCL_OK;
d1967 1
a1967 64
}

/*
 *----------------------------------------------------------------------
 *
 * TclLindexList --
 *
 *	This procedure handles the 'lindex' command when objc==3.
 *
 * Results:
 *	Returns a pointer to the object extracted, or NULL if an
 *	error occurred.
 *
 * Side effects:
 *	None.
 *
 * If objv[1] can be parsed as a list, TclLindexList handles extraction
 * of the desired element locally.  Otherwise, it invokes
 * TclLindexFlat to treat objv[1] as a scalar.
 *
 * The reference count of the returned object includes one reference
 * corresponding to the pointer returned.  Thus, the calling code will
 * usually do something like:
 *	Tcl_SetObjResult( interp, result );
 *	Tcl_DecrRefCount( result );
 *
 *----------------------------------------------------------------------
 */

Tcl_Obj *
TclLindexList( interp, listPtr, argPtr )
    Tcl_Interp* interp;		/* Tcl interpreter */
    Tcl_Obj* listPtr;		/* List being unpacked */
    Tcl_Obj* argPtr;		/* Index or index list */
{

    Tcl_Obj **elemPtrs;		/* Elements of the list being manipulated. */
    int listLen;		/* Length of the list being manipulated. */
    int index;			/* Index into the list */
    int result;			/* Result returned from a Tcl library call */
    int i;			/* Current index number */
    Tcl_Obj** indices;		/* Array of list indices */
    int indexCount;		/* Size of the array of list indices */
    Tcl_Obj* oldListPtr;	/* Temp location to preserve the list
				 * pointer when replacing it with a sublist */

    /*
     * Determine whether argPtr designates a list or a single index.
     * We have to be careful about the order of the checks to avoid
     * repeated shimmering; see TIP#22 and TIP#33 for the details.
     */

    if ( argPtr->typePtr != &tclListType 
	 && TclGetIntForIndex( NULL , argPtr, 0, &index ) == TCL_OK ) {

	/*
	 * argPtr designates a single index.
	 */

	return TclLindexFlat( interp, listPtr, 1, &argPtr );

    } else if ( Tcl_ListObjGetElements( NULL, argPtr, &indexCount, &indices )
		!= TCL_OK ) {

d1969 1
a1969 2
	 * argPtr designates something that is neither an index nor a
	 * well-formed list.  Report the error via TclLindexFlat.
d1972 1
a1972 1
	return TclLindexFlat( interp, listPtr, 1, &argPtr );
d1976 2
a1977 2
     * Record the reference to the list that we are maintaining in
     * the activation record.
d1980 3
a1982 15
    Tcl_IncrRefCount( listPtr );

    /*
     * argPtr designates a list, and the 'else if' above has parsed it
     * into indexCount and indices.
     */

    for ( i = 0; i < indexCount; ++i ) {

	/*
	 * Convert the current listPtr to a list if necessary.
	 */
	    
	result = Tcl_ListObjGetElements( interp, listPtr,
					 &listLen, &elemPtrs);
d1984 1
a1984 2
	    Tcl_DecrRefCount( listPtr );
	    return NULL;
d1986 1
a1986 67
	    
	/*
	 * Get the index from indices[ i ]
	 */
	
	result = TclGetIntForIndex( interp, indices[ i ],
				    /*endValue*/ (listLen - 1),
				    &index );
	if ( result != TCL_OK ) {
	    /*
	     * Index could not be parsed
	     */

	    Tcl_DecrRefCount( listPtr );
	    return NULL;

	} else if ( index < 0
		    || index >= listLen ) {
	    /*
	     * Index is out of range
	     */
	    Tcl_DecrRefCount( listPtr );
	    listPtr = Tcl_NewObj();
	    Tcl_IncrRefCount( listPtr );
	    return listPtr;
	}
	
	/*
	 * Make sure listPtr still refers to a list object.
	 * If it shared a Tcl_Obj structure with the arguments, then
	 * it might have just been converted to something else.
	 */
	
	if (listPtr->typePtr != &tclListType) {
	    result = Tcl_ListObjGetElements(interp, listPtr, &listLen,
					    &elemPtrs);
	    if (result != TCL_OK) {
		Tcl_DecrRefCount( listPtr );
		return NULL;
	    }
	}
	
	/*
	 * Extract the pointer to the appropriate element
	 */
	
	oldListPtr = listPtr;
	listPtr = elemPtrs[ index ];
	Tcl_IncrRefCount( listPtr );
	Tcl_DecrRefCount( oldListPtr );
	
	/*
	 * The work we did above may have caused the internal rep
	 * of *argPtr to change to something else.  Get it back.
	 */
	
	result = Tcl_ListObjGetElements( interp, argPtr,
					 &indexCount, &indices );
	if ( result != TCL_OK ) {
	    /* 
	     * This can't happen unless some extension corrupted a Tcl_Obj.
	     */
	    Tcl_DecrRefCount( listPtr );
	    return NULL;
	}
	
    } /* end for */
d1989 1
a1989 2
     * Return the last object extracted.  Its reference count will include
     * the reference being returned.
d1992 2
a1993 123
    return listPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * TclLindexFlat --
 *
 *	This procedure handles the 'lindex' command, given that the
 *	arguments to the command are known to be a flat list.
 *
 * Results:
 *	Returns a standard Tcl result.
 *
 * Side effects:
 *	None.
 *
 * This procedure is called from either tclExecute.c or
 * Tcl_LindexObjCmd whenever either is presented with
 * objc == 2 or objc >= 4.  It is also called from TclLindexList
 * for the objc==3 case once it is determined that objv[2] cannot
 * be parsed as a list.
 *
 *----------------------------------------------------------------------
 */

Tcl_Obj *
TclLindexFlat( interp, listPtr, indexCount, indexArray )
    Tcl_Interp* interp;		/* Tcl interpreter */
    Tcl_Obj* listPtr;		/* Tcl object representing the list */
    int indexCount;		/* Count of indices */
    Tcl_Obj* CONST indexArray[];
				/* Array of pointers to Tcl objects
				 * representing the indices in the
				 * list */
{

    int i;			/* Current list index */
    int result;			/* Result of Tcl library calls */
    int listLen;		/* Length of the current list being 
				 * processed */
    Tcl_Obj** elemPtrs;		/* Array of pointers to the elements
				 * of the current list */
    int index;			/* Parsed version of the current element
				 * of indexArray  */
    Tcl_Obj* oldListPtr;	/* Temporary to hold listPtr so that
				 * its ref count can be decremented. */

    /*
     * Record the reference to the 'listPtr' object that we are
     * maintaining in the C activation record.
     */

    Tcl_IncrRefCount( listPtr );

    for ( i = 0; i < indexCount; ++i ) {

	/*
	 * Convert the current listPtr to a list if necessary.
	 */
	
	result = Tcl_ListObjGetElements(interp, listPtr,
					&listLen, &elemPtrs);
	if (result != TCL_OK) {
	    Tcl_DecrRefCount( listPtr );
	    return NULL;
	}
	
	/*
	 * Get the index from objv[i]
	 */
	
	result = TclGetIntForIndex( interp, indexArray[ i ],
				    /*endValue*/ (listLen - 1),
				    &index );
	if ( result != TCL_OK ) {

	    /* Index could not be parsed */

	    Tcl_DecrRefCount( listPtr );
	    return NULL;

	} else if ( index < 0
		    || index >= listLen ) {
	    
	    /*
	     * Index is out of range
	     */
		
	    Tcl_DecrRefCount( listPtr );
	    listPtr = Tcl_NewObj();
	    Tcl_IncrRefCount( listPtr );
	    return listPtr;
	}
	    
	/*
	 * Make sure listPtr still refers to a list object.
	 * It might have been converted to something else above
	 * if objv[1] overlaps with one of the other parameters.
	 */
	
	if (listPtr->typePtr != &tclListType) {
	    result = Tcl_ListObjGetElements(interp, listPtr, &listLen,
					    &elemPtrs);
	    if (result != TCL_OK) {
		Tcl_DecrRefCount( listPtr );
		return NULL;
	    }
	}
	
	/*
	 * Extract the pointer to the appropriate element
	 */
	
	oldListPtr = listPtr;
	listPtr = elemPtrs[ index ];
	Tcl_IncrRefCount( listPtr );
	Tcl_DecrRefCount( oldListPtr );
	
    }

    return listPtr;

d2022 2
a2023 1
    Tcl_Obj *listPtr;
d2025 1
a2025 1

d2031 5
d2041 1
a2041 7
    /*
     * Get the index.  "end" is interpreted to be the index after the last
     * element, such that using it will cause any inserted elements to be
     * appended to the list.
     */

    result = TclGetIntForIndex(interp, objv[2], /*end*/ len, &index);
a2044 3
    if (index > len) {
	index = len;
    }
d2048 2
a2049 1
     * we create a copy to modify: this is "copy on write".
d2051 1
a2051 1

d2055 24
a2078 1
	listPtr = Tcl_DuplicateObj(listPtr);
d2081 2
a2082 2

    if ((objc == 4) && (index == len)) {
d2086 1
a2092 3
	if (isDuplicate) {
	    Tcl_DecrRefCount(listPtr); /* free unneeded obj */
	}
d2100 3
a2102 1
    Tcl_SetObjResult(interp, listPtr);
d2309 3
a2311 1
    int isDuplicate, first, last, listLen, numToDelete, result;
d2319 12
a2330 1
    result = Tcl_ListObjLength(interp, objv[1], &listLen);
d2332 4
d2340 1
a2340 3
     * Get the first and last indexes.  "end" is interpreted to be the index
     * for the last element, such that using it will cause that element to
     * be included for deletion.
d2343 2
a2344 1
    result = TclGetIntForIndex(interp, objv[2], /*end*/ (listLen - 1), &first);
d2346 1
a2346 1
	return result;
d2348 1
d2350 2
a2351 1
    result = TclGetIntForIndex(interp, objv[3], /*end*/ (listLen - 1), &last);
d2353 1
a2353 1
	return result;
d2359 2
a2360 9

    /*
     * Complain if the user asked for a start element that is greater than the
     * list length.  This won't ever trigger for the "end*" case as that will
     * be properly constrained by TclGetIntForIndex because we use listLen-1
     * (to allow for replacing the last elem).
     */

    if ((first >= listLen) && (listLen > 0)) {
d2364 2
a2365 1
	return TCL_ERROR;
a2375 11
    /*
     * If the list object is unshared we can modify it directly, otherwise
     * we create a copy to modify: this is "copy on write".
     */

    listPtr = objv[1];
    isDuplicate = 0;
    if (Tcl_IsShared(listPtr)) {
	listPtr = Tcl_DuplicateObj(listPtr);
	isDuplicate = 1;
    }
d2384 1
a2384 4
	if (isDuplicate) {
	    Tcl_DecrRefCount(listPtr); /* free unneeded obj */
	}
	return result;
d2421 3
a2423 9
    int dataType, isIncreasing, lower, upper, patInt, objInt;
    int offset, allMatches, inlineReturn, negatedMatch;
    double patDouble, objDouble;
    Tcl_Obj *patObj, **listv, *listPtr, *startPtr;
    static CONST char *options[] = {
	"-all",	    "-ascii", "-decreasing", "-dictionary",
	"-exact",   "-glob",  "-increasing", "-inline",
	"-integer", "-not",   "-real",	     "-regexp",
	"-sorted",  "-start", NULL
d2426 1
a2426 4
	LSEARCH_ALL, LSEARCH_ASCII, LSEARCH_DECREASING, LSEARCH_DICTIONARY,
	LSEARCH_EXACT, LSEARCH_GLOB, LSEARCH_INCREASING, LSEARCH_INLINE,
	LSEARCH_INTEGER, LSEARCH_NOT, LSEARCH_REAL, LSEARCH_REGEXP,
	LSEARCH_SORTED, LSEARCH_START
a2427 16
    enum datatypes {
	ASCII, DICTIONARY, INTEGER, REAL
    };
    enum modes {
	EXACT, GLOB, REGEXP, SORTED
    };

    mode = GLOB;
    dataType = ASCII;
    isIncreasing = 1;
    allMatches = 0;
    inlineReturn = 0;
    negatedMatch = 0;
    listPtr = NULL;
    startPtr = NULL;
    offset = 0;
d2429 4
a2432 11
    if (objc < 3) {
	Tcl_WrongNumArgs(interp, 1, objv, "?options? list pattern");
	return TCL_ERROR;
    }

    for (i = 1; i < objc-2; i++) {
	if (Tcl_GetIndexFromObj(interp, objv[i], options, "option", 0, &index)
		!= TCL_OK) {
	    if (startPtr) {
		Tcl_DecrRefCount(startPtr);
	    }
d2435 3
a2437 68
	switch ((enum options) index) {
	case LSEARCH_ALL:		/* -all */
	    allMatches = 1;
	    break;
	case LSEARCH_ASCII:		/* -ascii */
	    dataType = ASCII;
	    break;
	case LSEARCH_DECREASING:	/* -decreasing */
	    isIncreasing = 0;
	    break;
	case LSEARCH_DICTIONARY:	/* -dictionary */
	    dataType = DICTIONARY;
	    break;
	case LSEARCH_EXACT:		/* -increasing */
	    mode = EXACT;
	    break;
	case LSEARCH_GLOB:		/* -glob */
	    mode = GLOB;
	    break;
	case LSEARCH_INCREASING:	/* -increasing */
	    isIncreasing = 1;
	    break;
	case LSEARCH_INLINE:		/* -inline */
	    inlineReturn = 1;
	    break;
	case LSEARCH_INTEGER:		/* -integer */
	    dataType = INTEGER;
	    break;
	case LSEARCH_NOT:		/* -not */
	    negatedMatch = 1;
	    break;
	case LSEARCH_REAL:		/* -real */
	    dataType = REAL;
	    break;
	case LSEARCH_REGEXP:		/* -regexp */
	    mode = REGEXP;
	    break;
	case LSEARCH_SORTED:		/* -sorted */
	    mode = SORTED;
	    break;
	case LSEARCH_START:		/* -start */
	    /*
	     * If there was a previous -start option, release its saved
	     * index because it will either be replaced or there will be
	     * an error.
	     */
	    if (startPtr) {
		Tcl_DecrRefCount(startPtr);
	    }
	    if (i > objc-4) {
		Tcl_AppendResult(interp, "missing starting index", NULL);
		return TCL_ERROR;
	    }
	    i++;
	    if (objv[i] == objv[objc - 2]) {
		/*
		 * Take copy to prevent shimmering problems.  Note
		 * that it does not matter if the index obj is also a
		 * component of the list being searched.  We only need
		 * to copy where the list and the index are
		 * one-and-the-same.
		 */
		startPtr = Tcl_DuplicateObj(objv[i]);
	    } else {
		startPtr = objv[i];
		Tcl_IncrRefCount(startPtr);
	    }
	}
a2446 3
	if (startPtr) {
	    Tcl_DecrRefCount(startPtr);
	}
a2449 16
    /*
     * Get the user-specified start offset.
     */
    if (startPtr) {
	result = TclGetIntForIndex(interp, startPtr, listc-1, &offset);
	Tcl_DecrRefCount(startPtr);
	if (result != TCL_OK) {
	    return result;
	}
	if (offset < 0) {
	    offset = 0;
	} else if (offset > listc-1) {
	    offset = listc-1;
	}
    }

d2451 1
a2451 23
    patternBytes = NULL;
    if ((enum modes) mode == EXACT || (enum modes) mode == SORTED) {
	switch ((enum datatypes) dataType) {
	case ASCII:
	case DICTIONARY:
	    patternBytes = Tcl_GetStringFromObj(patObj, &length);
	    break;
	case INTEGER:
	    result = Tcl_GetIntFromObj(interp, patObj, &patInt);
	    if (result != TCL_OK) {
		return result;
	    }
	    break;
	case REAL:
	    result = Tcl_GetDoubleFromObj(interp, patObj, &patDouble);
	    if (result != TCL_OK) {
		return result;
	    }
	    break;
	}
    } else {
	patternBytes = Tcl_GetStringFromObj(patObj, &length);
    }
a2452 5
    /*
     * Set default index value to -1, indicating failure; if we find the
     * item in the course of our search, index will be set to the correct
     * value.
     */
d2454 8
a2461 34
    match = 0;

    if ((enum modes) mode == SORTED && !allMatches && !negatedMatch) {
	/*
	 * If the data is sorted, we can do a more intelligent search.
	 * Note that there is no point in being smart when -all was
	 * specified; in that case, we have to look at all items anyway,
	 * and there is no sense in doing this when the match sense is
	 * inverted.
	 */
	lower = offset - 1;
	upper = listc;
	while (lower + 1 != upper) {
	    i = (lower + upper)/2;
	    switch ((enum datatypes) dataType) {
	    case ASCII:
		bytes = Tcl_GetString(listv[i]);
		match = strcmp(patternBytes, bytes);
		break;
	    case DICTIONARY:
		bytes = Tcl_GetString(listv[i]);
		match = DictionaryCompare(patternBytes, bytes);
		break;
	    case INTEGER:
		result = Tcl_GetIntFromObj(interp, listv[i], &objInt);
		if (result != TCL_OK) {
		    return result;
		}
		if (patInt == objInt) {
		    match = 0;
		} else if (patInt < objInt) {
		    match = -1;
		} else {
		    match = 1;
d2464 3
a2466 12
	    case REAL:
		result = Tcl_GetDoubleFromObj(interp, listv[i], &objDouble);
		if (result != TCL_OK) {
		    return result;
		}
		if (patDouble == objDouble) {
		    match = 0;
		} else if (patDouble < objDouble) {
		    match = -1;
		} else {
		    match = 1;
		}
d2469 1
a2469 85
	    if (match == 0) {
		/*
		 * Normally, binary search is written to stop when it
		 * finds a match.  If there are duplicates of an element in
		 * the list, our first match might not be the first occurance.
		 * Consider:  0 0 0 1 1 1 2 2 2
		 * To maintain consistancy with standard lsearch semantics,
		 * we must find the leftmost occurance of the pattern in the
		 * list.  Thus we don't just stop searching here.  This
		 * variation means that a search always makes log n
		 * comparisons (normal binary search might "get lucky" with
		 * an early comparison).
		 */
		index = i;
		upper = i;
	    } else if (match > 0) {
		if (isIncreasing) {
		    lower = i;
		} else {
		    upper = i;
		}
	    } else {
		if (isIncreasing) {
		    upper = i;
		} else {
		    lower = i;
		}
	    }
	}

    } else {
	/*
	 * We need to do a linear search, because (at least one) of:
	 *   - our matcher can only tell equal vs. not equal
	 *   - our matching sense is negated
	 *   - we're building a list of all matched items
	 */
	if (allMatches) {
	    listPtr = Tcl_NewListObj(0, (Tcl_Obj **) NULL);
	}
	for (i = offset; i < listc; i++) {
	    match = 0;
	    switch ((enum modes) mode) {
	    case SORTED:
	    case EXACT:
		switch ((enum datatypes) dataType) {
		case ASCII:
		    bytes = Tcl_GetStringFromObj(listv[i], &elemLen);
		    if (length == elemLen) {
			match = (memcmp(bytes, patternBytes,
				(size_t) length) == 0);
		    }
		    break;
		case DICTIONARY:
		    bytes = Tcl_GetString(listv[i]);
		    match = (DictionaryCompare(bytes, patternBytes) == 0);
		    break;
		case INTEGER:
		    result = Tcl_GetIntFromObj(interp, listv[i], &objInt);
		    if (result != TCL_OK) {
			if (listPtr) {
			    Tcl_DecrRefCount(listPtr);
			}
			return result;
		    }
		    match = (objInt == patInt);
		    break;
		case REAL:
		    result = Tcl_GetDoubleFromObj(interp, listv[i],
			    &objDouble);
		    if (result != TCL_OK) {
			if (listPtr) {
			    Tcl_DecrRefCount(listPtr);
			}
			return result;
		    }
		    match = (objDouble == patDouble);
		    break;
		}
		break;
	    case GLOB:
		match = Tcl_StringMatch(Tcl_GetString(listv[i]),
			patternBytes);
		break;
	    case REGEXP:
a2471 3
		    if (listPtr) {
			Tcl_DecrRefCount(listPtr);
		    }
a2475 20
	    /*
	     * Invert match condition for -not
	     */
	    if (negatedMatch) {
		match = !match;
	    }
	    if (match != 0) {
		if (!allMatches) {
		    index = i;
		    break;
		} else if (inlineReturn) {
		    /*
		     * Note that these appends are not expected to fail.
		     */
		    Tcl_ListObjAppendElement(interp, listPtr, listv[i]);
		} else {
		    Tcl_ListObjAppendElement(interp, listPtr,
			    Tcl_NewIntObj(i));
		}
	    }
d2477 4
d2482 1
a2482 17

    /*
     * Return everything or a single value.
     */
    if (allMatches) {
	Tcl_SetObjResult(interp, listPtr);
    } else if (!inlineReturn) {
	Tcl_SetIntObj(Tcl_GetObjResult(interp), index);
    } else if (index < 0) {
	/*
	 * Is this superfluous?  The result should be a blank object
	 * by default...
	 */
	Tcl_SetObjResult(interp, Tcl_NewObj());
    } else {
	Tcl_SetObjResult(interp, listv[index]);
    }
a2488 80
 * Tcl_LsetObjCmd --
 *
 *	This procedure is invoked to process the "lset" Tcl command.
 *	See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_LsetObjCmd( clientData, interp, objc, objv )
    ClientData clientData;	/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument values. */
{

    Tcl_Obj* listPtr;		/* Pointer to the list being altered. */
    Tcl_Obj* finalValuePtr;	/* Value finally assigned to the variable */

    /* Check parameter count */

    if ( objc < 3 ) {
	Tcl_WrongNumArgs( interp, 1, objv, "listVar index ?index...? value" );
	return TCL_ERROR;
    }

    /* Look up the list variable's value */

    listPtr = Tcl_ObjGetVar2( interp, objv[ 1 ], (Tcl_Obj*) NULL,
			      TCL_LEAVE_ERR_MSG );
    if ( listPtr == NULL ) {
	return TCL_ERROR;
    }

    /* 
     * Substitute the value in the value.  Return either the value or
     * else an unshared copy of it.
     */

    if ( objc == 4 ) {
	finalValuePtr = TclLsetList( interp, listPtr,
				     objv[ 2 ], objv[ 3 ] );
    } else {
	finalValuePtr = TclLsetFlat( interp, listPtr,
				     objc-3, objv+2, objv[ objc-1 ] );
    }

    /*
     * If substitution has failed, bail out.
     */

    if ( finalValuePtr == NULL ) {
	return TCL_ERROR;
    }

    /* Finally, update the variable so that traces fire. */

    listPtr = Tcl_ObjSetVar2( interp, objv[1], NULL, finalValuePtr,
			      TCL_LEAVE_ERR_MSG );
    Tcl_DecrRefCount( finalValuePtr );
    if ( listPtr == NULL ) {
	return TCL_ERROR;
    }

    /* Return the new value of the variable as the interpreter result. */

    Tcl_SetObjResult( interp, listPtr );
    return TCL_OK;

}

/*
 *----------------------------------------------------------------------
 *
d2519 1
a2519 1
    static CONST char *switches[] = {
d2536 1
a2536 1
    sortInfo.index = SORTIDX_NONE;
d2577 2
a2578 2
		if (TclGetIntForIndex(interp, objv[i+1], SORTIDX_END,
			&sortInfo.index) != TCL_OK) {
d2581 1
d2619 1
a2619 1
    if (sortInfo.resultCode != TCL_OK || length <= 0) {
d2622 3
d2835 1
a2835 1
    if (infoPtr->index != SORTIDX_NONE) {
d2839 2
a2840 2
	 * compare the elements, not the lists.  "end"-relative indices
	 * are signaled here with large negative values.
d2847 2
a2848 2
	if (infoPtr->index < SORTIDX_NONE) {
	    index = listLen + infoPtr->index + 1;
d2874 2
a2875 2
	if (infoPtr->index < SORTIDX_NONE) {
	    index = listLen + infoPtr->index + 1;
d3100 1
@


1.2
log
@touched all Tcl files to ease next import.
@
text
@@


1.2.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.2.16.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@a12 1
 * Copyright (c) 2001 by Kevin B. Kenny.  All rights reserved.
d22 1
a75 7
 * Magic values for the index field of the SortInfo structure.
 * Note that the index "end-1" will be translated to SORTIDX_END-1, etc.
 */
#define SORTIDX_NONE	-1		/* Not indexed; use whole value. */
#define SORTIDX_END	-2		/* Indexed from end. */

/*
d80 1
a80 1
			    Tcl_Obj *listPtr, CONST char *pattern,
a104 3
static int		InfoFunctionsCmd _ANSI_ARGS_((ClientData dummy,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *CONST objv[]));
a315 1
#ifdef TCL_WIDE_INT_IS_LONG
a319 25
#else
	/*
	 * Need to be a bit cautious to ensure that [expr]-like rules
	 * are enforced for interpretation of wide integers, despite
	 * the fact that the underlying API itself is a 'long' only one.
	 */
	if (objv[2]->typePtr == &tclIntType) {
	    incrAmount = objv[2]->internalRep.longValue;
	} else if (objv[2]->typePtr == &tclWideIntType) {
	    incrAmount = Tcl_WideAsLong(objv[2]->internalRep.wideValue);
	} else {
	    Tcl_WideInt wide;

	    if (Tcl_GetWideIntFromObj(interp, objv[2], &wide) != TCL_OK) {
		Tcl_AddErrorInfo(interp, "\n    (reading increment)");
		return TCL_ERROR;
	    }
	    incrAmount = Tcl_WideAsLong(wide);
	    if ((wide <= Tcl_LongAsWide(LONG_MAX))
		    && (wide >= Tcl_LongAsWide(LONG_MIN))) {
		objv[2]->typePtr = &tclIntType;
		objv[2]->internalRep.longValue = incrAmount;
	    }
	}
#endif
d366 1
a366 1
    static CONST char *subCmds[] = {
d368 1
a368 1
	     "complete", "default", "exists", "functions", "globals",
d375 1
a375 1
	    ICompleteIdx, IDefaultIdx, IExistsIdx, IFunctionsIdx, IGlobalsIdx,
a414 3
	case IFunctionsIdx:
	    result = InfoFunctionsCmd(clientData, interp, objc, objv);
	    break;
d565 10
a574 7
    /* 
     * Here we used to return procPtr->bodyPtr, except when the body was
     * bytecompiled - in that case, the return was a copy of the body's
     * string rep. In order to better isolate the implementation details
     * of the compiler/engine subsystem, we now always return a copy of 
     * the string rep. It is important to return a copy so that later 
     * manipulations of the object do not invalidate the internal rep.
d578 3
a580 6
    if (bodyPtr->bytes == NULL) {
	/*
	 * The string rep might not be valid if the procedure has
	 * never been run before.  [Bug #545644]
	 */
	(void) Tcl_GetString(bodyPtr);
a581 1
    resultPtr = Tcl_NewStringObj(bodyPtr->bytes, bodyPtr->length);
d657 1
a657 2
    char *cmdName, *pattern;
    CONST char *simplePattern;
a929 48
 * InfoFunctionsCmd --
 *
 *      Called to implement the "info functions" command that returns the
 *      list of math functions matching an optional pattern. Handles the
 *      following syntax:
 *
 *          info functions ?pattern?
 *
 * Results:
 *      Returns TCL_OK if successful and TCL_ERROR if there is an error.
 *
 * Side effects:
 *      Returns a result in the interpreter's result object. If there is
 *	an error, the result is an error message.
 *
 *----------------------------------------------------------------------
 */

static int
InfoFunctionsCmd(dummy, interp, objc, objv)
    ClientData dummy;		/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    char *pattern;
    Tcl_Obj *listPtr;

    if (objc == 2) {
        pattern = NULL;
    } else if (objc == 3) {
        pattern = Tcl_GetString(objv[2]);
    } else {
        Tcl_WrongNumArgs(interp, 2, objv, "?pattern?");
        return TCL_ERROR;
    }

    listPtr = Tcl_ListMathFuncs(interp, pattern);
    if (listPtr == NULL) {
	return TCL_ERROR;
    }
    Tcl_SetObjResult(interp, listPtr);
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
d1021 1
a1021 1
    CONST char *name;
d1139 1
a1139 1
    CONST char *libDirName;
d1279 1
a1279 1
    CONST char *pattern;	/* Pattern to match against. */
d1301 1
a1301 2
	if (!TclIsVarTemporary(localPtr) && !TclIsVarUndefined(varPtr)
	        && (includeLinks || !TclIsVarLink(varPtr))) {
d1368 1
a1368 1
	Tcl_SetStringObj(Tcl_GetObjResult(interp), nameOfExecutable, -1);
d1401 1
a1401 1
    CONST char *patchlevel;
d1448 1
a1448 2
    char *cmdName, *pattern;
    CONST char *simplePattern;
d1509 8
a1521 8
		    if (specificNsInPattern) {
			elemObjPtr = Tcl_NewObj();
			Tcl_GetCommandFullName(interp, (Tcl_Command) cmdPtr,
				elemObjPtr);
		    } else {
			elemObjPtr = Tcl_NewStringObj(cmdName, -1);
		    }

d1581 1
a1581 3
 *          info script ?newName?
 *
 *	If newName is specified, it will set that as the internal name.
d1588 1
a1588 2
 *	an error, the result is an error message.  It may change the
 *	internal script filename.
d1601 2
a1602 2
    if ((objc != 2) && (objc != 3)) {
        Tcl_WrongNumArgs(interp, 2, objv, "?filename?");
a1605 7
    if (objc == 3) {
	if (iPtr->scriptFile != NULL) {
	    Tcl_DecrRefCount(iPtr->scriptFile);
	}
	iPtr->scriptFile = objv[2];
	Tcl_IncrRefCount(iPtr->scriptFile);
    }
d1607 1
a1607 1
        Tcl_SetObjResult(interp, iPtr->scriptFile);
d1678 1
a1678 1
    CONST char *version;
d1726 1
a1726 2
    char *varName, *pattern;
    CONST char *simplePattern;
d1939 3
d1943 2
a1944 4
    Tcl_Obj *elemPtr;		/* Pointer to the element being extracted */

    if (objc < 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "list ?index...?");
d1949 1
a1949 4
     * If objc == 3, then objv[ 2 ] may be either a single index or
     * a list of indices: go to TclLindexList to determine which.
     * If objc >= 4, or objc == 2, then objv[ 2 .. objc-2 ] are all
     * single indices and processed as such in TclLindexFlat.
d1952 5
a1956 7
    if ( objc == 3 ) {

	elemPtr = TclLindexList( interp, objv[ 1 ], objv[ 2 ] );

    } else {

	elemPtr = TclLindexFlat( interp, objv[ 1 ], objc-2, objv+2 );
a1957 2
    }
	
d1959 1
a1959 1
     * Set the interpreter's object result to the last element extracted
d1962 4
a1965 6
    if ( elemPtr == NULL ) {
	return TCL_ERROR;
    } else {
	Tcl_SetObjResult(interp, elemPtr);
	Tcl_DecrRefCount( elemPtr );
	return TCL_OK;
d1967 1
a1967 64
}

/*
 *----------------------------------------------------------------------
 *
 * TclLindexList --
 *
 *	This procedure handles the 'lindex' command when objc==3.
 *
 * Results:
 *	Returns a pointer to the object extracted, or NULL if an
 *	error occurred.
 *
 * Side effects:
 *	None.
 *
 * If objv[1] can be parsed as a list, TclLindexList handles extraction
 * of the desired element locally.  Otherwise, it invokes
 * TclLindexFlat to treat objv[1] as a scalar.
 *
 * The reference count of the returned object includes one reference
 * corresponding to the pointer returned.  Thus, the calling code will
 * usually do something like:
 *	Tcl_SetObjResult( interp, result );
 *	Tcl_DecrRefCount( result );
 *
 *----------------------------------------------------------------------
 */

Tcl_Obj *
TclLindexList( interp, listPtr, argPtr )
    Tcl_Interp* interp;		/* Tcl interpreter */
    Tcl_Obj* listPtr;		/* List being unpacked */
    Tcl_Obj* argPtr;		/* Index or index list */
{

    Tcl_Obj **elemPtrs;		/* Elements of the list being manipulated. */
    int listLen;		/* Length of the list being manipulated. */
    int index;			/* Index into the list */
    int result;			/* Result returned from a Tcl library call */
    int i;			/* Current index number */
    Tcl_Obj** indices;		/* Array of list indices */
    int indexCount;		/* Size of the array of list indices */
    Tcl_Obj* oldListPtr;	/* Temp location to preserve the list
				 * pointer when replacing it with a sublist */

    /*
     * Determine whether argPtr designates a list or a single index.
     * We have to be careful about the order of the checks to avoid
     * repeated shimmering; see TIP#22 and TIP#33 for the details.
     */

    if ( argPtr->typePtr != &tclListType 
	 && TclGetIntForIndex( NULL , argPtr, 0, &index ) == TCL_OK ) {

	/*
	 * argPtr designates a single index.
	 */

	return TclLindexFlat( interp, listPtr, 1, &argPtr );

    } else if ( Tcl_ListObjGetElements( NULL, argPtr, &indexCount, &indices )
		!= TCL_OK ) {

d1969 1
a1969 2
	 * argPtr designates something that is neither an index nor a
	 * well-formed list.  Report the error via TclLindexFlat.
d1972 1
a1972 1
	return TclLindexFlat( interp, listPtr, 1, &argPtr );
d1976 2
a1977 2
     * Record the reference to the list that we are maintaining in
     * the activation record.
d1980 3
a1982 15
    Tcl_IncrRefCount( listPtr );

    /*
     * argPtr designates a list, and the 'else if' above has parsed it
     * into indexCount and indices.
     */

    for ( i = 0; i < indexCount; ++i ) {

	/*
	 * Convert the current listPtr to a list if necessary.
	 */
	    
	result = Tcl_ListObjGetElements( interp, listPtr,
					 &listLen, &elemPtrs);
d1984 1
a1984 2
	    Tcl_DecrRefCount( listPtr );
	    return NULL;
d1986 1
a1986 67
	    
	/*
	 * Get the index from indices[ i ]
	 */
	
	result = TclGetIntForIndex( interp, indices[ i ],
				    /*endValue*/ (listLen - 1),
				    &index );
	if ( result != TCL_OK ) {
	    /*
	     * Index could not be parsed
	     */

	    Tcl_DecrRefCount( listPtr );
	    return NULL;

	} else if ( index < 0
		    || index >= listLen ) {
	    /*
	     * Index is out of range
	     */
	    Tcl_DecrRefCount( listPtr );
	    listPtr = Tcl_NewObj();
	    Tcl_IncrRefCount( listPtr );
	    return listPtr;
	}
	
	/*
	 * Make sure listPtr still refers to a list object.
	 * If it shared a Tcl_Obj structure with the arguments, then
	 * it might have just been converted to something else.
	 */
	
	if (listPtr->typePtr != &tclListType) {
	    result = Tcl_ListObjGetElements(interp, listPtr, &listLen,
					    &elemPtrs);
	    if (result != TCL_OK) {
		Tcl_DecrRefCount( listPtr );
		return NULL;
	    }
	}
	
	/*
	 * Extract the pointer to the appropriate element
	 */
	
	oldListPtr = listPtr;
	listPtr = elemPtrs[ index ];
	Tcl_IncrRefCount( listPtr );
	Tcl_DecrRefCount( oldListPtr );
	
	/*
	 * The work we did above may have caused the internal rep
	 * of *argPtr to change to something else.  Get it back.
	 */
	
	result = Tcl_ListObjGetElements( interp, argPtr,
					 &indexCount, &indices );
	if ( result != TCL_OK ) {
	    /* 
	     * This can't happen unless some extension corrupted a Tcl_Obj.
	     */
	    Tcl_DecrRefCount( listPtr );
	    return NULL;
	}
	
    } /* end for */
d1989 1
a1989 2
     * Return the last object extracted.  Its reference count will include
     * the reference being returned.
d1992 2
a1993 123
    return listPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * TclLindexFlat --
 *
 *	This procedure handles the 'lindex' command, given that the
 *	arguments to the command are known to be a flat list.
 *
 * Results:
 *	Returns a standard Tcl result.
 *
 * Side effects:
 *	None.
 *
 * This procedure is called from either tclExecute.c or
 * Tcl_LindexObjCmd whenever either is presented with
 * objc == 2 or objc >= 4.  It is also called from TclLindexList
 * for the objc==3 case once it is determined that objv[2] cannot
 * be parsed as a list.
 *
 *----------------------------------------------------------------------
 */

Tcl_Obj *
TclLindexFlat( interp, listPtr, indexCount, indexArray )
    Tcl_Interp* interp;		/* Tcl interpreter */
    Tcl_Obj* listPtr;		/* Tcl object representing the list */
    int indexCount;		/* Count of indices */
    Tcl_Obj* CONST indexArray[];
				/* Array of pointers to Tcl objects
				 * representing the indices in the
				 * list */
{

    int i;			/* Current list index */
    int result;			/* Result of Tcl library calls */
    int listLen;		/* Length of the current list being 
				 * processed */
    Tcl_Obj** elemPtrs;		/* Array of pointers to the elements
				 * of the current list */
    int index;			/* Parsed version of the current element
				 * of indexArray  */
    Tcl_Obj* oldListPtr;	/* Temporary to hold listPtr so that
				 * its ref count can be decremented. */

    /*
     * Record the reference to the 'listPtr' object that we are
     * maintaining in the C activation record.
     */

    Tcl_IncrRefCount( listPtr );

    for ( i = 0; i < indexCount; ++i ) {

	/*
	 * Convert the current listPtr to a list if necessary.
	 */
	
	result = Tcl_ListObjGetElements(interp, listPtr,
					&listLen, &elemPtrs);
	if (result != TCL_OK) {
	    Tcl_DecrRefCount( listPtr );
	    return NULL;
	}
	
	/*
	 * Get the index from objv[i]
	 */
	
	result = TclGetIntForIndex( interp, indexArray[ i ],
				    /*endValue*/ (listLen - 1),
				    &index );
	if ( result != TCL_OK ) {

	    /* Index could not be parsed */

	    Tcl_DecrRefCount( listPtr );
	    return NULL;

	} else if ( index < 0
		    || index >= listLen ) {
	    
	    /*
	     * Index is out of range
	     */
		
	    Tcl_DecrRefCount( listPtr );
	    listPtr = Tcl_NewObj();
	    Tcl_IncrRefCount( listPtr );
	    return listPtr;
	}
	    
	/*
	 * Make sure listPtr still refers to a list object.
	 * It might have been converted to something else above
	 * if objv[1] overlaps with one of the other parameters.
	 */
	
	if (listPtr->typePtr != &tclListType) {
	    result = Tcl_ListObjGetElements(interp, listPtr, &listLen,
					    &elemPtrs);
	    if (result != TCL_OK) {
		Tcl_DecrRefCount( listPtr );
		return NULL;
	    }
	}
	
	/*
	 * Extract the pointer to the appropriate element
	 */
	
	oldListPtr = listPtr;
	listPtr = elemPtrs[ index ];
	Tcl_IncrRefCount( listPtr );
	Tcl_DecrRefCount( oldListPtr );
	
    }

    return listPtr;

d2022 2
a2023 1
    Tcl_Obj *listPtr;
d2025 1
a2025 1

d2031 5
d2041 1
a2041 7
    /*
     * Get the index.  "end" is interpreted to be the index after the last
     * element, such that using it will cause any inserted elements to be
     * appended to the list.
     */

    result = TclGetIntForIndex(interp, objv[2], /*end*/ len, &index);
a2044 3
    if (index > len) {
	index = len;
    }
d2048 2
a2049 1
     * we create a copy to modify: this is "copy on write".
d2051 1
a2051 1

d2055 24
a2078 1
	listPtr = Tcl_DuplicateObj(listPtr);
d2081 2
a2082 2

    if ((objc == 4) && (index == len)) {
d2086 1
a2092 3
	if (isDuplicate) {
	    Tcl_DecrRefCount(listPtr); /* free unneeded obj */
	}
d2100 3
a2102 1
    Tcl_SetObjResult(interp, listPtr);
d2309 3
a2311 1
    int isDuplicate, first, last, listLen, numToDelete, result;
d2319 12
a2330 1
    result = Tcl_ListObjLength(interp, objv[1], &listLen);
d2332 4
d2340 1
a2340 3
     * Get the first and last indexes.  "end" is interpreted to be the index
     * for the last element, such that using it will cause that element to
     * be included for deletion.
d2343 2
a2344 1
    result = TclGetIntForIndex(interp, objv[2], /*end*/ (listLen - 1), &first);
d2346 1
a2346 1
	return result;
d2348 1
d2350 2
a2351 1
    result = TclGetIntForIndex(interp, objv[3], /*end*/ (listLen - 1), &last);
d2353 1
a2353 1
	return result;
d2359 2
a2360 9

    /*
     * Complain if the user asked for a start element that is greater than the
     * list length.  This won't ever trigger for the "end*" case as that will
     * be properly constrained by TclGetIntForIndex because we use listLen-1
     * (to allow for replacing the last elem).
     */

    if ((first >= listLen) && (listLen > 0)) {
d2364 2
a2365 1
	return TCL_ERROR;
a2375 11
    /*
     * If the list object is unshared we can modify it directly, otherwise
     * we create a copy to modify: this is "copy on write".
     */

    listPtr = objv[1];
    isDuplicate = 0;
    if (Tcl_IsShared(listPtr)) {
	listPtr = Tcl_DuplicateObj(listPtr);
	isDuplicate = 1;
    }
d2384 1
a2384 4
	if (isDuplicate) {
	    Tcl_DecrRefCount(listPtr); /* free unneeded obj */
	}
	return result;
d2421 3
a2423 9
    int dataType, isIncreasing, lower, upper, patInt, objInt;
    int offset, allMatches, inlineReturn, negatedMatch;
    double patDouble, objDouble;
    Tcl_Obj *patObj, **listv, *listPtr, *startPtr;
    static CONST char *options[] = {
	"-all",	    "-ascii", "-decreasing", "-dictionary",
	"-exact",   "-glob",  "-increasing", "-inline",
	"-integer", "-not",   "-real",	     "-regexp",
	"-sorted",  "-start", NULL
d2426 1
a2426 4
	LSEARCH_ALL, LSEARCH_ASCII, LSEARCH_DECREASING, LSEARCH_DICTIONARY,
	LSEARCH_EXACT, LSEARCH_GLOB, LSEARCH_INCREASING, LSEARCH_INLINE,
	LSEARCH_INTEGER, LSEARCH_NOT, LSEARCH_REAL, LSEARCH_REGEXP,
	LSEARCH_SORTED, LSEARCH_START
a2427 16
    enum datatypes {
	ASCII, DICTIONARY, INTEGER, REAL
    };
    enum modes {
	EXACT, GLOB, REGEXP, SORTED
    };

    mode = GLOB;
    dataType = ASCII;
    isIncreasing = 1;
    allMatches = 0;
    inlineReturn = 0;
    negatedMatch = 0;
    listPtr = NULL;
    startPtr = NULL;
    offset = 0;
d2429 4
a2432 11
    if (objc < 3) {
	Tcl_WrongNumArgs(interp, 1, objv, "?options? list pattern");
	return TCL_ERROR;
    }

    for (i = 1; i < objc-2; i++) {
	if (Tcl_GetIndexFromObj(interp, objv[i], options, "option", 0, &index)
		!= TCL_OK) {
	    if (startPtr) {
		Tcl_DecrRefCount(startPtr);
	    }
d2435 3
a2437 68
	switch ((enum options) index) {
	case LSEARCH_ALL:		/* -all */
	    allMatches = 1;
	    break;
	case LSEARCH_ASCII:		/* -ascii */
	    dataType = ASCII;
	    break;
	case LSEARCH_DECREASING:	/* -decreasing */
	    isIncreasing = 0;
	    break;
	case LSEARCH_DICTIONARY:	/* -dictionary */
	    dataType = DICTIONARY;
	    break;
	case LSEARCH_EXACT:		/* -increasing */
	    mode = EXACT;
	    break;
	case LSEARCH_GLOB:		/* -glob */
	    mode = GLOB;
	    break;
	case LSEARCH_INCREASING:	/* -increasing */
	    isIncreasing = 1;
	    break;
	case LSEARCH_INLINE:		/* -inline */
	    inlineReturn = 1;
	    break;
	case LSEARCH_INTEGER:		/* -integer */
	    dataType = INTEGER;
	    break;
	case LSEARCH_NOT:		/* -not */
	    negatedMatch = 1;
	    break;
	case LSEARCH_REAL:		/* -real */
	    dataType = REAL;
	    break;
	case LSEARCH_REGEXP:		/* -regexp */
	    mode = REGEXP;
	    break;
	case LSEARCH_SORTED:		/* -sorted */
	    mode = SORTED;
	    break;
	case LSEARCH_START:		/* -start */
	    /*
	     * If there was a previous -start option, release its saved
	     * index because it will either be replaced or there will be
	     * an error.
	     */
	    if (startPtr) {
		Tcl_DecrRefCount(startPtr);
	    }
	    if (i > objc-4) {
		Tcl_AppendResult(interp, "missing starting index", NULL);
		return TCL_ERROR;
	    }
	    i++;
	    if (objv[i] == objv[objc - 2]) {
		/*
		 * Take copy to prevent shimmering problems.  Note
		 * that it does not matter if the index obj is also a
		 * component of the list being searched.  We only need
		 * to copy where the list and the index are
		 * one-and-the-same.
		 */
		startPtr = Tcl_DuplicateObj(objv[i]);
	    } else {
		startPtr = objv[i];
		Tcl_IncrRefCount(startPtr);
	    }
	}
a2446 3
	if (startPtr) {
	    Tcl_DecrRefCount(startPtr);
	}
a2449 16
    /*
     * Get the user-specified start offset.
     */
    if (startPtr) {
	result = TclGetIntForIndex(interp, startPtr, listc-1, &offset);
	Tcl_DecrRefCount(startPtr);
	if (result != TCL_OK) {
	    return result;
	}
	if (offset < 0) {
	    offset = 0;
	} else if (offset > listc-1) {
	    offset = listc-1;
	}
    }

d2451 1
a2451 23
    patternBytes = NULL;
    if ((enum modes) mode == EXACT || (enum modes) mode == SORTED) {
	switch ((enum datatypes) dataType) {
	case ASCII:
	case DICTIONARY:
	    patternBytes = Tcl_GetStringFromObj(patObj, &length);
	    break;
	case INTEGER:
	    result = Tcl_GetIntFromObj(interp, patObj, &patInt);
	    if (result != TCL_OK) {
		return result;
	    }
	    break;
	case REAL:
	    result = Tcl_GetDoubleFromObj(interp, patObj, &patDouble);
	    if (result != TCL_OK) {
		return result;
	    }
	    break;
	}
    } else {
	patternBytes = Tcl_GetStringFromObj(patObj, &length);
    }
a2452 5
    /*
     * Set default index value to -1, indicating failure; if we find the
     * item in the course of our search, index will be set to the correct
     * value.
     */
d2454 8
a2461 34
    match = 0;

    if ((enum modes) mode == SORTED && !allMatches && !negatedMatch) {
	/*
	 * If the data is sorted, we can do a more intelligent search.
	 * Note that there is no point in being smart when -all was
	 * specified; in that case, we have to look at all items anyway,
	 * and there is no sense in doing this when the match sense is
	 * inverted.
	 */
	lower = offset - 1;
	upper = listc;
	while (lower + 1 != upper) {
	    i = (lower + upper)/2;
	    switch ((enum datatypes) dataType) {
	    case ASCII:
		bytes = Tcl_GetString(listv[i]);
		match = strcmp(patternBytes, bytes);
		break;
	    case DICTIONARY:
		bytes = Tcl_GetString(listv[i]);
		match = DictionaryCompare(patternBytes, bytes);
		break;
	    case INTEGER:
		result = Tcl_GetIntFromObj(interp, listv[i], &objInt);
		if (result != TCL_OK) {
		    return result;
		}
		if (patInt == objInt) {
		    match = 0;
		} else if (patInt < objInt) {
		    match = -1;
		} else {
		    match = 1;
d2464 3
a2466 12
	    case REAL:
		result = Tcl_GetDoubleFromObj(interp, listv[i], &objDouble);
		if (result != TCL_OK) {
		    return result;
		}
		if (patDouble == objDouble) {
		    match = 0;
		} else if (patDouble < objDouble) {
		    match = -1;
		} else {
		    match = 1;
		}
d2469 1
a2469 85
	    if (match == 0) {
		/*
		 * Normally, binary search is written to stop when it
		 * finds a match.  If there are duplicates of an element in
		 * the list, our first match might not be the first occurance.
		 * Consider:  0 0 0 1 1 1 2 2 2
		 * To maintain consistancy with standard lsearch semantics,
		 * we must find the leftmost occurance of the pattern in the
		 * list.  Thus we don't just stop searching here.  This
		 * variation means that a search always makes log n
		 * comparisons (normal binary search might "get lucky" with
		 * an early comparison).
		 */
		index = i;
		upper = i;
	    } else if (match > 0) {
		if (isIncreasing) {
		    lower = i;
		} else {
		    upper = i;
		}
	    } else {
		if (isIncreasing) {
		    upper = i;
		} else {
		    lower = i;
		}
	    }
	}

    } else {
	/*
	 * We need to do a linear search, because (at least one) of:
	 *   - our matcher can only tell equal vs. not equal
	 *   - our matching sense is negated
	 *   - we're building a list of all matched items
	 */
	if (allMatches) {
	    listPtr = Tcl_NewListObj(0, (Tcl_Obj **) NULL);
	}
	for (i = offset; i < listc; i++) {
	    match = 0;
	    switch ((enum modes) mode) {
	    case SORTED:
	    case EXACT:
		switch ((enum datatypes) dataType) {
		case ASCII:
		    bytes = Tcl_GetStringFromObj(listv[i], &elemLen);
		    if (length == elemLen) {
			match = (memcmp(bytes, patternBytes,
				(size_t) length) == 0);
		    }
		    break;
		case DICTIONARY:
		    bytes = Tcl_GetString(listv[i]);
		    match = (DictionaryCompare(bytes, patternBytes) == 0);
		    break;
		case INTEGER:
		    result = Tcl_GetIntFromObj(interp, listv[i], &objInt);
		    if (result != TCL_OK) {
			if (listPtr) {
			    Tcl_DecrRefCount(listPtr);
			}
			return result;
		    }
		    match = (objInt == patInt);
		    break;
		case REAL:
		    result = Tcl_GetDoubleFromObj(interp, listv[i],
			    &objDouble);
		    if (result != TCL_OK) {
			if (listPtr) {
			    Tcl_DecrRefCount(listPtr);
			}
			return result;
		    }
		    match = (objDouble == patDouble);
		    break;
		}
		break;
	    case GLOB:
		match = Tcl_StringMatch(Tcl_GetString(listv[i]),
			patternBytes);
		break;
	    case REGEXP:
a2471 3
		    if (listPtr) {
			Tcl_DecrRefCount(listPtr);
		    }
a2475 20
	    /*
	     * Invert match condition for -not
	     */
	    if (negatedMatch) {
		match = !match;
	    }
	    if (match != 0) {
		if (!allMatches) {
		    index = i;
		    break;
		} else if (inlineReturn) {
		    /*
		     * Note that these appends are not expected to fail.
		     */
		    Tcl_ListObjAppendElement(interp, listPtr, listv[i]);
		} else {
		    Tcl_ListObjAppendElement(interp, listPtr,
			    Tcl_NewIntObj(i));
		}
	    }
d2477 4
d2482 1
a2482 17

    /*
     * Return everything or a single value.
     */
    if (allMatches) {
	Tcl_SetObjResult(interp, listPtr);
    } else if (!inlineReturn) {
	Tcl_SetIntObj(Tcl_GetObjResult(interp), index);
    } else if (index < 0) {
	/*
	 * Is this superfluous?  The result should be a blank object
	 * by default...
	 */
	Tcl_SetObjResult(interp, Tcl_NewObj());
    } else {
	Tcl_SetObjResult(interp, listv[index]);
    }
a2488 80
 * Tcl_LsetObjCmd --
 *
 *	This procedure is invoked to process the "lset" Tcl command.
 *	See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_LsetObjCmd( clientData, interp, objc, objv )
    ClientData clientData;	/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument values. */
{

    Tcl_Obj* listPtr;		/* Pointer to the list being altered. */
    Tcl_Obj* finalValuePtr;	/* Value finally assigned to the variable */

    /* Check parameter count */

    if ( objc < 3 ) {
	Tcl_WrongNumArgs( interp, 1, objv, "listVar index ?index...? value" );
	return TCL_ERROR;
    }

    /* Look up the list variable's value */

    listPtr = Tcl_ObjGetVar2( interp, objv[ 1 ], (Tcl_Obj*) NULL,
			      TCL_LEAVE_ERR_MSG );
    if ( listPtr == NULL ) {
	return TCL_ERROR;
    }

    /* 
     * Substitute the value in the value.  Return either the value or
     * else an unshared copy of it.
     */

    if ( objc == 4 ) {
	finalValuePtr = TclLsetList( interp, listPtr,
				     objv[ 2 ], objv[ 3 ] );
    } else {
	finalValuePtr = TclLsetFlat( interp, listPtr,
				     objc-3, objv+2, objv[ objc-1 ] );
    }

    /*
     * If substitution has failed, bail out.
     */

    if ( finalValuePtr == NULL ) {
	return TCL_ERROR;
    }

    /* Finally, update the variable so that traces fire. */

    listPtr = Tcl_ObjSetVar2( interp, objv[1], NULL, finalValuePtr,
			      TCL_LEAVE_ERR_MSG );
    Tcl_DecrRefCount( finalValuePtr );
    if ( listPtr == NULL ) {
	return TCL_ERROR;
    }

    /* Return the new value of the variable as the interpreter result. */

    Tcl_SetObjResult( interp, listPtr );
    return TCL_OK;

}

/*
 *----------------------------------------------------------------------
 *
d2519 1
a2519 1
    static CONST char *switches[] = {
d2536 1
a2536 1
    sortInfo.index = SORTIDX_NONE;
d2577 2
a2578 2
		if (TclGetIntForIndex(interp, objv[i+1], SORTIDX_END,
			&sortInfo.index) != TCL_OK) {
d2581 1
d2619 1
a2619 1
    if (sortInfo.resultCode != TCL_OK || length <= 0) {
d2622 3
d2835 1
a2835 1
    if (infoPtr->index != SORTIDX_NONE) {
d2839 2
a2840 2
	 * compare the elements, not the lists.  "end"-relative indices
	 * are signaled here with large negative values.
d2847 2
a2848 2
	if (infoPtr->index < SORTIDX_NONE) {
	    index = listLen + infoPtr->index + 1;
d2874 2
a2875 2
	if (infoPtr->index < SORTIDX_NONE) {
	    index = listLen + infoPtr->index + 1;
d3100 1
@


1.1
log
@Initial revision
@
text
@d12 1
a12 1
 * Copyright (c) 1998 by Scriptics Corporation.
d17 1
a17 1
 * RCS: @@(#) $Id: tclCmdIL.c,v 1.15 1999/01/28 05:19:50 jingham Exp $
d23 1
d33 1
d50 1
a50 1
    Tcl_DString compareCmd;	/* The Tcl comparison command when sortMode
d154 1
a154 1
 * Tcl_IfCmd --
d174 1
a174 1
Tcl_IfCmd(dummy, interp, argc, argv)
d177 2
a178 2
    int argc;				/* Number of arguments. */
    char **argv;			/* Argument strings. */
d180 1
d182 1
a182 1

d186 1
a186 1
	 * At this point in the loop, argv and argc refer to an expression
d193 2
a194 1
	if (i >= argc) {
d196 1
a196 1
		    argv[i-1], "\" argument", (char *) NULL);
d199 5
a203 3
	result = Tcl_ExprBoolean(interp, argv[i], &value);
	if (result != TCL_OK) {
	    return result;
d206 9
a214 1
	if ((i < argc) && (strcmp(argv[i], "then") == 0)) {
d217 2
a218 4
	if (i >= argc) {
	    Tcl_AppendResult(interp, "wrong # args: no script following \"",
		    argv[i-1], "\" argument", (char *) NULL);
	    return TCL_ERROR;
d221 2
a222 1
	    return Tcl_Eval(interp, argv[i]);
d231 4
a234 1
	if (i >= argc) {
d237 2
a238 1
	if ((argv[i][0] == 'e') && (strcmp(argv[i], "elseif") == 0)) {
d251 1
a251 1
    if (strcmp(argv[i], "else") == 0) {
d253 1
a253 1
	if (i >= argc) {
d260 10
a269 1
    return Tcl_Eval(interp, argv[i]);
d275 1
a275 1
 * Tcl_IncrCmd --
d295 1
a295 1
Tcl_IncrCmd(dummy, interp, argc, argv)
d298 2
a299 2
    int argc;				/* Number of arguments. */
    char **argv;			/* Argument strings. */
d301 5
a305 7
    int value;
    char *oldString, *result;
    char newString[30];

    if ((argc != 2) && (argc != 3)) {
	Tcl_AppendResult(interp, "wrong # args: should be \"", argv[0],
		" varName ?increment?\"", (char *) NULL);
d309 6
a314 11
    oldString = Tcl_GetVar(interp, argv[1], TCL_LEAVE_ERR_MSG);
    if (oldString == NULL) {
	return TCL_ERROR;
    }
    if (Tcl_GetInt(interp, oldString, &value) != TCL_OK) {
	Tcl_AddErrorInfo(interp,
		"\n    (reading value of variable to increment)");
	return TCL_ERROR;
    }
    if (argc == 2) {
	value += 1;
d316 2
a317 5
	int increment;

	if (Tcl_GetInt(interp, argv[2], &increment) != TCL_OK) {
	    Tcl_AddErrorInfo(interp,
		    "\n    (reading increment)");
a319 1
	value += increment;
d321 8
a328 3
    TclFormatInt(newString, value);
    result = Tcl_SetVar(interp, argv[1], newString, TCL_LEAVE_ERR_MSG);
    if (result == NULL) {
d333 2
a334 1
     * Copy the result since the variable's value might change.
d336 2
a337 2
    
    Tcl_SetResult(interp, result, TCL_VOLATILE);
d379 2
a380 2
    } index;
    int result;
d469 1
a469 1
 *      Returns TCL_OK is successful and TCL_ERROR is there is an error.
d496 1
a496 1
    name = Tcl_GetStringFromObj(objv[2], (int *) NULL);
d531 1
a531 1
 *      Returns TCL_OK is successful and TCL_ERROR is there is an error.
d557 1
a557 1
    name = Tcl_GetStringFromObj(objv[2], (int *) NULL);
d566 6
a571 3
     * we need to check if the body from this procedure had been generated
     * from a precompiled body. If that is the case, then the bodyPtr's
     * string representation is bogus, since sources are not available.
d580 1
a580 5
        ByteCode *codePtr = (ByteCode *) bodyPtr->internalRep.otherValuePtr;

        if (codePtr->flags & TCL_BYTECODE_PRECOMPILED) {
            resultPtr = Tcl_NewStringObj(bodyPtr->bytes, bodyPtr->length);
        }
d599 1
a599 1
 *      Returns TCL_OK is successful and TCL_ERROR is there is an error.
d641 1
a641 1
 *      Returns TCL_OK is successful and TCL_ERROR is there is an error.
a665 1
    int result;
d687 5
a691 7
        pattern = Tcl_GetStringFromObj(objv[2], (int *) NULL);
	result = TclGetNamespaceForQualName(interp, pattern,
		(Namespace *) NULL, /*flags*/ TCL_LEAVE_ERR_MSG,
		&nsPtr, &dummy1NsPtr, &dummy2NsPtr, &simplePattern);
	if (result != TCL_OK) {
	    return TCL_ERROR;
	}
d767 1
a767 1
 *      Returns TCL_OK is successful and TCL_ERROR is there is an error.
d809 1
a809 1
 *      Returns TCL_OK is successful and TCL_ERROR is there is an error.
d836 2
a837 2
    procName = Tcl_GetStringFromObj(objv[2], (int *) NULL);
    argName = Tcl_GetStringFromObj(objv[3], (int *) NULL);
d852 1
a852 1
                        localPtr->defValuePtr, 0);
d855 1
a855 1
		    varName = Tcl_GetStringFromObj(objv[4], (int *) NULL);
d865 1
a865 1
                    nullObjPtr, 0);
d893 1
a893 1
 *      Returns TCL_OK is successful and TCL_ERROR is there is an error.
d910 1
a910 1
    Var *varPtr, *arrayPtr;
d917 2
a918 4
    varName = Tcl_GetStringFromObj(objv[2], (int *) NULL);
    varPtr = TclLookupVar(interp, varName, (char *) NULL,
            TCL_PARSE_PART1, "access",
            /*createPart1*/ 0, /*createPart2*/ 0, &arrayPtr);
d939 1
a939 1
 *      Returns TCL_OK is successful and TCL_ERROR is there is an error.
d965 1
a965 1
        pattern = Tcl_GetStringFromObj(objv[2], (int *) NULL);
d1005 1
a1005 1
 *      Returns TCL_OK is successful and TCL_ERROR is there is an error.
d1049 1
a1049 1
 *      Returns TCL_OK is successful and TCL_ERROR is there is an error.
d1086 1
a1086 1
			Tcl_GetStringFromObj(objv[2], (int *) NULL),
d1123 1
a1123 1
 *      Returns TCL_OK is successful and TCL_ERROR is there is an error.
d1168 1
a1168 1
 *      Returns TCL_OK is successful and TCL_ERROR is there is an error.
d1195 1
a1195 1
	interpName = Tcl_GetStringFromObj(objv[2], (int *) NULL);
d1213 1
a1213 1
 *      Returns TCL_OK is successful and TCL_ERROR is there is an error.
d1236 1
a1236 1
        pattern = Tcl_GetStringFromObj(objv[2], (int *) NULL);
d1342 1
a1342 1
 *      Returns TCL_OK is successful and TCL_ERROR is there is an error.
d1385 1
a1385 1
 *      Returns TCL_OK is successful and TCL_ERROR is there is an error.
d1422 6
a1427 3
 *      Called to implement the "info procs" command that returns the
 *      procedures in the current namespace that match an optional pattern.
 *      Handles the following syntax:
d1432 1
a1432 1
 *      Returns TCL_OK is successful and TCL_ERROR is there is an error.
d1448 8
a1455 2
    char *cmdName, *pattern;
    Namespace *currNsPtr = (Namespace *) Tcl_GetCurrentNamespace(interp);
d1458 6
a1463 2
    Command *cmdPtr;
    Tcl_Obj *listPtr;
d1466 3
a1468 1
        pattern = NULL;
d1470 18
a1487 1
        pattern = Tcl_GetStringFromObj(objv[2], (int *) NULL);
d1494 4
a1497 2
     * Scan through the current namespace's command table and return a list
     * of all procs that match the pattern.
d1499 1
a1499 1
    
d1501 65
a1565 11
    for (entryPtr = Tcl_FirstHashEntry(&currNsPtr->cmdTable, &search);
            entryPtr != NULL;
            entryPtr = Tcl_NextHashEntry(&search)) {
        cmdName = Tcl_GetHashKey(&currNsPtr->cmdTable, entryPtr);
        cmdPtr = (Command *) Tcl_GetHashValue(entryPtr);
        if (TclIsProc(cmdPtr)) {
            if ((pattern == NULL) || Tcl_StringMatch(cmdName, pattern)) {
                Tcl_ListObjAppendElement(interp, listPtr,
		        Tcl_NewStringObj(cmdName, -1));
            }
        }
d1567 1
d1584 1
a1584 1
 *      Returns TCL_OK is successful and TCL_ERROR is there is an error.
d1624 1
a1624 1
 *      Returns TCL_OK is successful and TCL_ERROR is there is an error.
d1662 1
a1662 1
 *      Returns TCL_OK is successful and TCL_ERROR is there is an error.
d1709 1
a1709 1
 *      Returns TCL_OK is successful and TCL_ERROR is there is an error.
a1734 1
    int result;
d1757 5
a1761 7
        pattern = Tcl_GetStringFromObj(objv[2], (int *) NULL);
	result = TclGetNamespaceForQualName(interp, pattern,
		(Namespace *) NULL, /*flags*/ TCL_LEAVE_ERR_MSG,
		&nsPtr, &dummy1NsPtr, &dummy2NsPtr, &simplePattern);
	if (result != TCL_OK) {
	    return TCL_ERROR;
	}
d1839 1
a1839 1
    } else {
d2025 1
a2025 1

d2036 6
a2041 2
    result = TclGetIntForIndex(interp, objv[2], /*endValue*/ INT_MAX,
	    &index);
d2363 1
a2363 1
		Tcl_GetStringFromObj(objv[2], (int *) NULL), (int *) NULL);
a2418 5
#define EXACT	0
#define GLOB	1
#define REGEXP	2
#define DICTIONARY 3
#define NOCASE  4
d2420 8
a2427 4
    int i, match, mode, index, result, listLen, length, elemLen;
    Tcl_Obj **elemPtrs;
    static char *switches[] =
	    {"-exact", "-glob", "-regexp", "-dictionary", "-nocase", (char *) NULL};
d2429 1
a2429 1
    mode = GLOB;
d2431 2
a2432 2
	if (Tcl_GetIndexFromObj(interp, objv[1], switches,
		"search mode", 0, &mode) != TCL_OK) {
d2445 1
a2445 1
    result = Tcl_ListObjGetElements(interp, objv[objc-2], &listLen, &elemPtrs);
d2450 3
a2452 2
    patternBytes = Tcl_GetStringFromObj(objv[objc-1], &length);
 
d2454 1
a2454 1
    for (i = 0; i < listLen; i++) {
d2456 3
a2458 3
	bytes = Tcl_GetStringFromObj(elemPtrs[i], &elemLen);
	switch (mode) {
	    case EXACT:
d2464 3
a2466 5
	    case GLOB:
		/*
		 * WARNING: will not work with data containing NULLs.
		 */
		match = Tcl_StringMatch(bytes, patternBytes);
d2468 3
a2470 5
	    case REGEXP:
		/*
		 * WARNING: will not work with data containing NULLs.
		 */
		match = Tcl_RegExpMatch(interp, bytes, patternBytes);
d2475 1
a2475 8
	     case DICTIONARY:
	     case NOCASE:
#if defined(__MSVC__) || defined(_MSC_VER)
		match = strnicmp (bytes, patternBytes, length) == 0;
#else
	     	match = strncasecmp (bytes, patternBytes, length) == 0;
#endif
		break;
d2477 1
a2477 1
	if (match) {
a2481 1

d2510 1
a2510 1
    int i, index, dummy;
d2519 4
a2522 3
    static char *switches[] =
	    {"-ascii", "-command", "-decreasing", "-dictionary",
	    "-increasing", "-index", "-integer", "-real", (char *) NULL};
d2540 1
d2590 3
d2596 19
a2614 3
	Tcl_DStringInit(&sortInfo.compareCmd);
	Tcl_DStringAppend(&sortInfo.compareCmd,
		Tcl_GetStringFromObj(cmdPtr, &dummy), -1);
d2628 1
d2641 12
a2652 2
	for (; elementPtr != NULL; elementPtr = elementPtr->nextPtr){
	    Tcl_ListObjAppendElement(interp, resultPtr, elementPtr->objPtr);
d2659 2
a2660 1
	Tcl_DStringFree(&sortInfo.compareCmd);
d2752 1
d2760 2
a2761 1
    if (SortCompare(leftPtr->objPtr, rightPtr->objPtr, infoPtr) > 0) {
d2765 3
d2773 2
a2774 1
	if (SortCompare(leftPtr->objPtr, rightPtr->objPtr, infoPtr) > 0) {
d2779 3
d2822 1
a2822 1
    int order, dummy, listLen, index;
d2824 1
a2824 1
    char buffer[30];
d2861 1
a2861 1
	    sprintf(buffer, "%d", infoPtr->index);
d2864 1
a2864 2
			Tcl_GetStringFromObj(objPtr, (int *) NULL),
			"\"", (char *) NULL);
d2892 1
a2892 2
	order = strcmp(Tcl_GetStringFromObj(objPtr1, &dummy),
		Tcl_GetStringFromObj(objPtr2, &dummy));
d2895 1
a2895 2
		Tcl_GetStringFromObj(objPtr1, &dummy),
		Tcl_GetStringFromObj(objPtr2, &dummy));
d2897 1
a2897 1
	int a, b;
d2899 2
a2900 2
	if ((Tcl_GetIntFromObj(infoPtr->interp, objPtr1, &a) != TCL_OK)
		|| (Tcl_GetIntFromObj(infoPtr->interp, objPtr2, &b)
d2925 2
a2926 1
	int oldLength;
d2928 6
a2933 3
	/*
	 * Generate and evaluate a command to determine which string comes
	 * first.
d2936 9
a2944 9
	oldLength = Tcl_DStringLength(&infoPtr->compareCmd);
	Tcl_DStringAppendElement(&infoPtr->compareCmd,
		Tcl_GetStringFromObj(objPtr1, &dummy));
	Tcl_DStringAppendElement(&infoPtr->compareCmd,
		Tcl_GetStringFromObj(objPtr2, &dummy));
	infoPtr->resultCode = Tcl_Eval(infoPtr->interp, 
		Tcl_DStringValue(&infoPtr->compareCmd));
	Tcl_DStringTrunc(&infoPtr->compareCmd, oldLength);
	if (infoPtr->resultCode != TCL_OK) {
d2997 1
d3002 2
a3003 1
	if (isdigit(UCHAR(*right)) && isdigit(UCHAR(*left))) {
d3039 2
a3040 2
		if (!isdigit(UCHAR(*right))) {
		    if (isdigit(UCHAR(*left))) {
d3053 1
a3053 1
		} else if (!isdigit(UCHAR(*left))) {
d3059 24
a3082 1
        diff = UCHAR(*left) - UCHAR(*right);
d3084 9
a3092 17
            if (isupper(UCHAR(*left)) && islower(UCHAR(*right))) {
                diff = UCHAR(tolower(*left)) - UCHAR(*right);
                if (diff) {
		    return diff;
                } else if (secondaryDiff == 0) {
		    secondaryDiff = -1;
                }
            } else if (isupper(UCHAR(*right)) && islower(UCHAR(*left))) {
                diff = UCHAR(*left) - UCHAR(tolower(UCHAR(*right)));
                if (diff) {
		    return diff;
                } else if (secondaryDiff == 0) {
		    secondaryDiff = 1;
                }
            } else {
                return diff;
            }
a3093 5
        if (*left == 0) {
	    break;
	}
        left++;
        right++;
d3100 1
@


1.1.1.1
log
@import dejagnu-1999-11-08 snapshot
@
text
@@


1.1.1.2
log
@Tcl 8.3 upgrade
@
text
@d12 1
a12 1
 * Copyright (c) 1998-1999 by Scriptics Corporation.
d17 1
a17 1
 * RCS: @@(#) $Id: tclCmdIL.c,v 1.6.8.3 2000/09/15 16:55:02 spolk Exp $
a22 1
#include "tclRegexp.h"
a31 1
    int count;				/* number of same elements in list */
d48 1
a48 1
    Tcl_Obj *compareCmdPtr;     /* The Tcl comparison command when sortMode
d152 1
a152 1
 * Tcl_IfObjCmd --
d172 1
a172 1
Tcl_IfObjCmd(dummy, interp, objc, objv)
d175 2
a176 2
    int objc;				/* Number of arguments. */
    Tcl_Obj *CONST objv[];		/* Argument objects. */
a177 1
    int thenScriptIndex = 0;	/* then script to be evaled after syntax check */
d179 1
a179 1
    char *clause;
d183 1
a183 1
	 * At this point in the loop, objv and objc refer to an expression
d190 1
a190 2
	if (i >= objc) {
	    clause = Tcl_GetString(objv[i-1]);
d192 1
a192 1
		    clause, "\" argument", (char *) NULL);
d195 3
a197 5
	if (!thenScriptIndex) {
	    result = Tcl_ExprBooleanObj(interp, objv[i], &value);
	    if (result != TCL_OK) {
		return result;
	    }
d200 4
a203 3
	if (i >= objc) {
	    missingScript:
	    clause = Tcl_GetString(objv[i-1]);
d205 1
a205 1
		    clause, "\" argument", (char *) NULL);
a207 7
	clause = Tcl_GetString(objv[i]);
	if ((i < objc) && (strcmp(clause, "then") == 0)) {
	    i++;
	}
	if (i >= objc) {
	    goto missingScript;
	}
d209 1
a209 2
	    thenScriptIndex = i;
	    value = 0;
d218 1
a218 4
	if (i >= objc) {
	    if (thenScriptIndex) {
		return Tcl_EvalObjEx(interp, objv[thenScriptIndex], 0);
	    }
d221 1
a221 2
	clause = Tcl_GetString(objv[i]);
	if ((clause[0] == 'e') && (strcmp(clause, "elseif") == 0)) {
d234 1
a234 1
    if (strcmp(clause, "else") == 0) {
d236 1
a236 1
	if (i >= objc) {
d243 1
a243 10
    if (i < objc - 1) {
	Tcl_AppendResult(interp,
		"wrong # args: extra words after \"else\" clause in \"if\" command",
		(char *) NULL);
	return TCL_ERROR;
    }
    if (thenScriptIndex) {
	return Tcl_EvalObjEx(interp, objv[thenScriptIndex], 0);
    }
    return Tcl_EvalObjEx(interp, objv[i], 0);
d249 1
a249 1
 * Tcl_IncrObjCmd --
d269 1
a269 1
Tcl_IncrObjCmd(dummy, interp, objc, objv)
d272 2
a273 2
    int objc;				/* Number of arguments. */
    Tcl_Obj *CONST objv[];		/* Argument objects. */
d275 7
a281 5
    long incrAmount;
    Tcl_Obj *newValuePtr;
    
    if ((objc != 2) && (objc != 3)) {
        Tcl_WrongNumArgs(interp, 1, objv, "varName ?increment?");
d285 11
a295 6
    /*
     * Calculate the amount to increment by.
     */
    
    if (objc == 2) {
	incrAmount = 1;
d297 5
a301 2
	if (Tcl_GetLongFromObj(interp, objv[2], &incrAmount) != TCL_OK) {
	    Tcl_AddErrorInfo(interp, "\n    (reading increment)");
d304 1
d306 3
a308 8
    
    /*
     * Increment the variable's value.
     */

    newValuePtr = TclIncrVar2(interp, objv[1], (Tcl_Obj *) NULL, incrAmount,
	    TCL_LEAVE_ERR_MSG);
    if (newValuePtr == NULL) {
d313 1
a313 2
     * Set the interpreter's object result to refer to the variable's new
     * value object.
d315 2
a316 2

    Tcl_SetObjResult(interp, newValuePtr);
d358 2
a359 2
    };
    int index, result;
d448 1
a448 1
 *      Returns TCL_OK if successful and TCL_ERROR if there is an error.
d475 1
a475 1
    name = Tcl_GetString(objv[2]);
d510 1
a510 1
 *      Returns TCL_OK if successful and TCL_ERROR if there is an error.
d536 1
a536 1
    name = Tcl_GetString(objv[2]);
d545 3
a547 6
     * We should not return a bytecompiled body.  If it is precompiled,
     * then the bodyPtr's string representation is bogus, since sources
     * are not available.  If it was just a bytecompiled body, then it
     * is likely to not be of any use to the caller, as it was compiled
     * for a separate procedure context [Bug: 3412], and noone else can
     * reasonably use it.
d556 5
a560 1
	resultPtr = Tcl_NewStringObj(bodyPtr->bytes, bodyPtr->length);
d579 1
a579 1
 *      Returns TCL_OK if successful and TCL_ERROR if there is an error.
d621 1
a621 1
 *      Returns TCL_OK if successful and TCL_ERROR if there is an error.
d646 1
d668 7
a674 5

	pattern = Tcl_GetString(objv[2]);
	TclGetNamespaceForQualName(interp, pattern, (Namespace *) NULL,
           /*flags*/ 0, &nsPtr, &dummy1NsPtr, &dummy2NsPtr, &simplePattern);

d750 1
a750 1
 *      Returns TCL_OK if successful and TCL_ERROR if there is an error.
d792 1
a792 1
 *      Returns TCL_OK if successful and TCL_ERROR if there is an error.
d819 2
a820 2
    procName = Tcl_GetString(objv[2]);
    argName = Tcl_GetString(objv[3]);
d835 1
a835 1
			localPtr->defValuePtr, 0);
d838 1
a838 1
		    varName = Tcl_GetString(objv[4]);
d848 1
a848 1
			nullObjPtr, 0);
d876 1
a876 1
 *      Returns TCL_OK if successful and TCL_ERROR if there is an error.
d893 1
a893 1
    Var *varPtr;
d900 4
a903 2
    varName = Tcl_GetString(objv[2]);
    varPtr = TclVarTraceExists(interp, varName);
d924 1
a924 1
 *      Returns TCL_OK if successful and TCL_ERROR if there is an error.
d950 1
a950 1
        pattern = Tcl_GetString(objv[2]);
d990 1
a990 1
 *      Returns TCL_OK if successful and TCL_ERROR if there is an error.
d1034 1
a1034 1
 *      Returns TCL_OK if successful and TCL_ERROR if there is an error.
d1071 1
a1071 1
			Tcl_GetString(objv[2]),
d1108 1
a1108 1
 *      Returns TCL_OK if successful and TCL_ERROR if there is an error.
d1153 1
a1153 1
 *      Returns TCL_OK if successful and TCL_ERROR if there is an error.
d1180 1
a1180 1
	interpName = Tcl_GetString(objv[2]);
d1198 1
a1198 1
 *      Returns TCL_OK if successful and TCL_ERROR if there is an error.
d1221 1
a1221 1
        pattern = Tcl_GetString(objv[2]);
d1327 1
a1327 1
 *      Returns TCL_OK if successful and TCL_ERROR if there is an error.
d1370 1
a1370 1
 *      Returns TCL_OK if successful and TCL_ERROR if there is an error.
d1407 3
a1409 6
 *	Called to implement the "info procs" command that returns the
 *	list of procedures in the interpreter that match an optional pattern.
 *	The pattern, if any, consists of an optional sequence of namespace
 *	names separated by "::" qualifiers, which is followed by a
 *	glob-style pattern that restricts which commands are returned.
 *	Handles the following syntax:
d1414 1
a1414 1
 *      Returns TCL_OK if successful and TCL_ERROR if there is an error.
d1430 2
a1431 8
    char *cmdName, *pattern, *simplePattern;
    Namespace *nsPtr;
#ifdef INFO_PROCS_SEARCH_GLOBAL_NS
    Namespace *globalNsPtr = (Namespace *) Tcl_GetGlobalNamespace(interp);
#endif
    Namespace *currNsPtr   = (Namespace *) Tcl_GetCurrentNamespace(interp);
    Tcl_Obj *listPtr, *elemObjPtr;
    int specificNsInPattern = 0;  /* Init. to avoid compiler warning. */
d1434 2
a1435 6
    Command *cmdPtr, *realCmdPtr;

    /*
     * Get the pattern and find the "effective namespace" in which to
     * list procs.
     */
d1438 1
a1438 3
	simplePattern = NULL;
	nsPtr = currNsPtr;
	specificNsInPattern = 0;
d1440 1
a1440 18
	/*
	 * From the pattern, get the effective namespace and the simple
	 * pattern (no namespace qualifiers or ::'s) at the end. If an
	 * error was found while parsing the pattern, return it. Otherwise,
	 * if the namespace wasn't found, just leave nsPtr NULL: we will
	 * return an empty list since no commands there can be found.
	 */

	Namespace *dummy1NsPtr, *dummy2NsPtr;

	pattern = Tcl_GetString(objv[2]);
	TclGetNamespaceForQualName(interp, pattern, (Namespace *) NULL,
		/*flags*/ 0, &nsPtr, &dummy1NsPtr, &dummy2NsPtr,
		&simplePattern);

	if (nsPtr != NULL) {	/* we successfully found the pattern's ns */
	    specificNsInPattern = (strcmp(simplePattern, pattern) != 0);
	}
d1447 2
a1448 4
     * Scan through the effective namespace's command table and create a
     * list with all procs that match the pattern. If a specific
     * namespace was requested in the pattern, qualify the command names
     * with the namespace name.
d1450 1
a1450 1

d1452 11
a1462 65
    if (nsPtr != NULL) {
	entryPtr = Tcl_FirstHashEntry(&nsPtr->cmdTable, &search);
	while (entryPtr != NULL) {
	    cmdName = Tcl_GetHashKey(&nsPtr->cmdTable, entryPtr);
	    if ((simplePattern == NULL)
	            || Tcl_StringMatch(cmdName, simplePattern)) {
		cmdPtr = (Command *) Tcl_GetHashValue(entryPtr);

		if (specificNsInPattern) {
		    elemObjPtr = Tcl_NewObj();
		    Tcl_GetCommandFullName(interp, (Tcl_Command) cmdPtr,
		            elemObjPtr);
		} else {
		    elemObjPtr = Tcl_NewStringObj(cmdName, -1);
		}

		realCmdPtr = (Command *)
		    TclGetOriginalCommand((Tcl_Command) cmdPtr);

		if (TclIsProc(cmdPtr)
		        || ((realCmdPtr != NULL) && TclIsProc(realCmdPtr))) {
		    Tcl_ListObjAppendElement(interp, listPtr, elemObjPtr);
		}
	    }
	    entryPtr = Tcl_NextHashEntry(&search);
	}

	/*
	 * If the effective namespace isn't the global :: namespace, and a
	 * specific namespace wasn't requested in the pattern, then add in
	 * all global :: procs that match the simple pattern. Of course,
	 * we add in only those procs that aren't hidden by a proc in
	 * the effective namespace.
	 */

#ifdef INFO_PROCS_SEARCH_GLOBAL_NS
	/*
	 * If "info procs" worked like "info commands", returning the
	 * commands also seen in the global namespace, then you would
	 * include this code.  As this could break backwards compatibilty
	 * with 8.0-8.2, we decided not to "fix" it in 8.3, leaving the
	 * behavior slightly different.
	 */
	if ((nsPtr != globalNsPtr) && !specificNsInPattern) {
	    entryPtr = Tcl_FirstHashEntry(&globalNsPtr->cmdTable, &search);
	    while (entryPtr != NULL) {
		cmdName = Tcl_GetHashKey(&globalNsPtr->cmdTable, entryPtr);
		if ((simplePattern == NULL)
	                || Tcl_StringMatch(cmdName, simplePattern)) {
		    if (Tcl_FindHashEntry(&nsPtr->cmdTable, cmdName) == NULL) {
			cmdPtr = (Command *) Tcl_GetHashValue(entryPtr);
			realCmdPtr = (Command *) TclGetOriginalCommand(
			        (Tcl_Command) cmdPtr);

			if (TclIsProc(cmdPtr) || ((realCmdPtr != NULL)
				&& TclIsProc(realCmdPtr))) {
			    Tcl_ListObjAppendElement(interp, listPtr,
			            Tcl_NewStringObj(cmdName, -1));
			}
		    }
		}
		entryPtr = Tcl_NextHashEntry(&search);
	    }
	}
#endif
a1463 1

d1480 1
a1480 1
 *      Returns TCL_OK if successful and TCL_ERROR if there is an error.
d1520 1
a1520 1
 *      Returns TCL_OK if successful and TCL_ERROR if there is an error.
d1558 1
a1558 1
 *      Returns TCL_OK if successful and TCL_ERROR if there is an error.
d1605 1
a1605 1
 *      Returns TCL_OK if successful and TCL_ERROR if there is an error.
d1631 1
d1654 7
a1660 5
        pattern = Tcl_GetString(objv[2]);
	TclGetNamespaceForQualName(interp, pattern, (Namespace *) NULL,
		/*flags*/ 0, &nsPtr, &dummy1NsPtr, &dummy2NsPtr,
		&simplePattern);

d1738 1
a1738 1
    } else if (((Interp *)interp)->varFramePtr->procPtr != NULL) {
d1924 1
a1924 1
   
d1935 2
a1936 6
    result = Tcl_ListObjLength(interp, objv[1], &len);
    if (result != TCL_OK) {
	return result;
    }

    result = TclGetIntForIndex(interp, objv[2], /*endValue*/ len, &index);
d2258 1
a2258 1
		Tcl_GetString(objv[2]), (int *) NULL);
d2314 5
d2320 4
a2323 8
    int i, match, mode, index, result, listc, length, elemLen;
    Tcl_Obj *patObj, **listv;
    static char *options[] = {
	"-exact",	"-glob",	"-regexp",	NULL
    };
    enum options {
	LSEARCH_EXACT,	LSEARCH_GLOB,	LSEARCH_REGEXP
    };
d2325 1
a2325 1
    mode = LSEARCH_GLOB;
d2327 2
a2328 2
	if (Tcl_GetIndexFromObj(interp, objv[1], options, "search mode", 0,
		&mode) != TCL_OK) {
d2341 1
a2341 1
    result = Tcl_ListObjGetElements(interp, objv[objc - 2], &listc, &listv);
d2346 2
a2347 3
    patObj = objv[objc - 1];
    patternBytes = Tcl_GetStringFromObj(patObj, &length);

d2349 1
a2349 1
    for (i = 0; i < listc; i++) {
d2351 3
a2353 3
	switch ((enum options) mode) {
	    case LSEARCH_EXACT: {
		bytes = Tcl_GetStringFromObj(listv[i], &elemLen);
d2359 5
a2363 3
	    }
	    case LSEARCH_GLOB: {
		match = Tcl_StringMatch(Tcl_GetString(listv[i]), patternBytes);
d2365 5
a2369 3
	    }
	    case LSEARCH_REGEXP: {
		match = Tcl_RegExpMatchObj(interp, listv[i], patObj);
d2374 8
a2381 1
	    }
d2383 1
a2383 1
	if (match != 0) {
d2388 1
d2417 1
a2417 1
    int i, index, unique;
d2426 3
a2428 4
    static char *switches[] = {
	"-ascii", "-command", "-decreasing", "-dictionary", "-increasing",
	"-index", "-integer", "-real", "-unique", (char *) NULL
    };
a2445 1
    unique = 0;
a2494 3
	    case 8:			/* -unique */
		unique = 1;
		break;
d2498 3
a2500 19
	/*
	 * The existing command is a list. We want to flatten it, append
	 * two dummy arguments on the end, and replace these arguments
	 * later.
	 */

        Tcl_Obj *newCommandPtr = Tcl_DuplicateObj(cmdPtr);
	Tcl_Obj *newObjPtr = Tcl_NewObj();

	Tcl_IncrRefCount(newCommandPtr);
	if (Tcl_ListObjAppendElement(interp, newCommandPtr, newObjPtr)
		!= TCL_OK) {
	    Tcl_DecrRefCount(newCommandPtr);
	    Tcl_IncrRefCount(newObjPtr);
	    Tcl_DecrRefCount(newObjPtr);
	    return TCL_ERROR;
	}
	Tcl_ListObjAppendElement(interp, newCommandPtr, Tcl_NewObj());
	sortInfo.compareCmdPtr = newCommandPtr;
a2513 1
	elementArray[i].count = 0;
d2526 2
a2527 12
	if (unique) {
	    for (; elementPtr != NULL; elementPtr = elementPtr->nextPtr){
		if (elementPtr->count == 0) {
		    Tcl_ListObjAppendElement(interp, resultPtr,
			    elementPtr->objPtr);
		}
	    }
	} else {
	    for (; elementPtr != NULL; elementPtr = elementPtr->nextPtr){
		Tcl_ListObjAppendElement(interp, resultPtr,
			elementPtr->objPtr);
	    }
d2534 1
a2534 2
	Tcl_DecrRefCount(sortInfo.compareCmdPtr);
	sortInfo.compareCmdPtr = NULL;
a2625 1
    int cmp;
d2633 1
a2633 2
    cmp = SortCompare(leftPtr->objPtr, rightPtr->objPtr, infoPtr);
    if (cmp > 0) {
a2636 3
	if (cmp == 0) {
	    leftPtr->count++;
	}
d2642 1
a2642 2
	cmp = SortCompare(leftPtr->objPtr, rightPtr->objPtr, infoPtr);
	if (cmp > 0) {
a2646 3
	    if (cmp == 0) {
		leftPtr->count++;
	    }
d2687 1
a2687 1
    int order, listLen, index;
d2689 1
a2689 1
    char buffer[TCL_INTEGER_SPACE];
d2726 1
a2726 1
	    TclFormatInt(buffer, infoPtr->index);
d2729 2
a2730 1
			Tcl_GetString(objPtr), "\"", (char *) NULL);
d2758 2
a2759 1
	order = strcmp(Tcl_GetString(objPtr1), Tcl_GetString(objPtr2));
d2762 2
a2763 1
		Tcl_GetString(objPtr1),	Tcl_GetString(objPtr2));
d2765 1
a2765 1
	long a, b;
d2767 2
a2768 2
	if ((Tcl_GetLongFromObj(infoPtr->interp, objPtr1, &a) != TCL_OK)
		|| (Tcl_GetLongFromObj(infoPtr->interp, objPtr2, &b)
d2793 1
a2793 2
	Tcl_Obj **objv, *paramObjv[2];
	int objc;
d2795 3
a2797 6
	paramObjv[0] = objPtr1;
	paramObjv[1] = objPtr2;

  	/*
 	 * We made space in the command list for the two things to
	 * compare. Replace them and evaluate the result.
d2800 9
a2808 9
	Tcl_ListObjLength(infoPtr->interp, infoPtr->compareCmdPtr, &objc);
	Tcl_ListObjReplace(infoPtr->interp, infoPtr->compareCmdPtr, objc - 2,
		2, 2, paramObjv);
   	Tcl_ListObjGetElements(infoPtr->interp, infoPtr->compareCmdPtr,
		&objc, &objv);

	infoPtr->resultCode = Tcl_EvalObjv(infoPtr->interp, objc, objv, 0);
  
  	if (infoPtr->resultCode != TCL_OK) {
a2860 1
    Tcl_UniChar uniLeft, uniRight, uniLeftLower, uniRightLower;
d2865 1
a2865 2
	if (isdigit(UCHAR(*right)) /* INTL: digit */
		&& isdigit(UCHAR(*left))) { /* INTL: digit */
d2901 2
a2902 2
		if (!isdigit(UCHAR(*right))) { /* INTL: digit */
		    if (isdigit(UCHAR(*left))) { /* INTL: digit */
d2915 1
a2915 1
		} else if (!isdigit(UCHAR(*left))) { /* INTL: digit */
d2921 21
a2941 20

	/*
	 * Convert character to Unicode for comparison purposes.  If either
	 * string is at the terminating null, do a byte-wise comparison and
	 * bail out immediately.
	 */

	if ((*left != '\0') && (*right != '\0')) {
	    left += Tcl_UtfToUniChar(left, &uniLeft);
	    right += Tcl_UtfToUniChar(right, &uniRight);
	    /*
	     * Convert both chars to lower for the comparison, because
	     * dictionary sorts are case insensitve.  Covert to lower, not
	     * upper, so chars between Z and a will sort before A (where most
	     * other interesting punctuations occur)
	     */
	    uniLeftLower = Tcl_UniCharToLower(uniLeft);
	    uniRightLower = Tcl_UniCharToLower(uniRight);
	} else {
	    diff = UCHAR(*left) - UCHAR(*right);
d2944 2
a2945 13

        diff = uniLeftLower - uniRightLower;
        if (diff) {
	    return diff;
	} else if (secondaryDiff == 0) {
	    if (Tcl_UniCharIsUpper(uniLeft) &&
		    Tcl_UniCharIsLower(uniRight)) {
		secondaryDiff = -1;
	    } else if (Tcl_UniCharIsUpper(uniRight)
		    && Tcl_UniCharIsLower(uniLeft)) {
		secondaryDiff = 1;
	    }
        }
a2951 1

@


1.1.1.3
log
@import tcl 8.4.0
@
text
@a12 1
 * Copyright (c) 2001 by Kevin B. Kenny.  All rights reserved.
d17 1
a17 1
 * RCS: @@(#) $Id: tclCmdIL.c,v 1.44 2002/06/11 13:22:36 msofer Exp $
d22 1
a75 7
 * Magic values for the index field of the SortInfo structure.
 * Note that the index "end-1" will be translated to SORTIDX_END-1, etc.
 */
#define SORTIDX_NONE	-1		/* Not indexed; use whole value. */
#define SORTIDX_END	-2		/* Indexed from end. */

/*
d80 1
a80 1
			    Tcl_Obj *listPtr, CONST char *pattern,
a104 3
static int		InfoFunctionsCmd _ANSI_ARGS_((ClientData dummy,
			    Tcl_Interp *interp, int objc,
			    Tcl_Obj *CONST objv[]));
a315 1
#ifdef TCL_WIDE_INT_IS_LONG
a319 25
#else
	/*
	 * Need to be a bit cautious to ensure that [expr]-like rules
	 * are enforced for interpretation of wide integers, despite
	 * the fact that the underlying API itself is a 'long' only one.
	 */
	if (objv[2]->typePtr == &tclIntType) {
	    incrAmount = objv[2]->internalRep.longValue;
	} else if (objv[2]->typePtr == &tclWideIntType) {
	    incrAmount = Tcl_WideAsLong(objv[2]->internalRep.wideValue);
	} else {
	    Tcl_WideInt wide;

	    if (Tcl_GetWideIntFromObj(interp, objv[2], &wide) != TCL_OK) {
		Tcl_AddErrorInfo(interp, "\n    (reading increment)");
		return TCL_ERROR;
	    }
	    incrAmount = Tcl_WideAsLong(wide);
	    if ((wide <= Tcl_LongAsWide(LONG_MAX))
		    && (wide >= Tcl_LongAsWide(LONG_MIN))) {
		objv[2]->typePtr = &tclIntType;
		objv[2]->internalRep.longValue = incrAmount;
	    }
	}
#endif
d366 1
a366 1
    static CONST char *subCmds[] = {
d368 1
a368 1
	     "complete", "default", "exists", "functions", "globals",
d375 1
a375 1
	    ICompleteIdx, IDefaultIdx, IExistsIdx, IFunctionsIdx, IGlobalsIdx,
a414 3
	case IFunctionsIdx:
	    result = InfoFunctionsCmd(clientData, interp, objc, objv);
	    break;
d565 10
a574 7
    /* 
     * Here we used to return procPtr->bodyPtr, except when the body was
     * bytecompiled - in that case, the return was a copy of the body's
     * string rep. In order to better isolate the implementation details
     * of the compiler/engine subsystem, we now always return a copy of 
     * the string rep. It is important to return a copy so that later 
     * manipulations of the object do not invalidate the internal rep.
d578 3
a580 6
    if (bodyPtr->bytes == NULL) {
	/*
	 * The string rep might not be valid if the procedure has
	 * never been run before.  [Bug #545644]
	 */
	(void) Tcl_GetString(bodyPtr);
a581 1
    resultPtr = Tcl_NewStringObj(bodyPtr->bytes, bodyPtr->length);
d657 1
a657 2
    char *cmdName, *pattern;
    CONST char *simplePattern;
a929 48
 * InfoFunctionsCmd --
 *
 *      Called to implement the "info functions" command that returns the
 *      list of math functions matching an optional pattern. Handles the
 *      following syntax:
 *
 *          info functions ?pattern?
 *
 * Results:
 *      Returns TCL_OK if successful and TCL_ERROR if there is an error.
 *
 * Side effects:
 *      Returns a result in the interpreter's result object. If there is
 *	an error, the result is an error message.
 *
 *----------------------------------------------------------------------
 */

static int
InfoFunctionsCmd(dummy, interp, objc, objv)
    ClientData dummy;		/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    char *pattern;
    Tcl_Obj *listPtr;

    if (objc == 2) {
        pattern = NULL;
    } else if (objc == 3) {
        pattern = Tcl_GetString(objv[2]);
    } else {
        Tcl_WrongNumArgs(interp, 2, objv, "?pattern?");
        return TCL_ERROR;
    }

    listPtr = Tcl_ListMathFuncs(interp, pattern);
    if (listPtr == NULL) {
	return TCL_ERROR;
    }
    Tcl_SetObjResult(interp, listPtr);
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
d1021 1
a1021 1
    CONST char *name;
d1139 1
a1139 1
    CONST char *libDirName;
d1279 1
a1279 1
    CONST char *pattern;	/* Pattern to match against. */
d1301 1
a1301 2
	if (!TclIsVarTemporary(localPtr) && !TclIsVarUndefined(varPtr)
	        && (includeLinks || !TclIsVarLink(varPtr))) {
d1368 1
a1368 1
	Tcl_SetStringObj(Tcl_GetObjResult(interp), nameOfExecutable, -1);
d1401 1
a1401 1
    CONST char *patchlevel;
d1448 1
a1448 2
    char *cmdName, *pattern;
    CONST char *simplePattern;
d1509 8
a1521 8
		    if (specificNsInPattern) {
			elemObjPtr = Tcl_NewObj();
			Tcl_GetCommandFullName(interp, (Tcl_Command) cmdPtr,
				elemObjPtr);
		    } else {
			elemObjPtr = Tcl_NewStringObj(cmdName, -1);
		    }

d1581 1
a1581 3
 *          info script ?newName?
 *
 *	If newName is specified, it will set that as the internal name.
d1588 1
a1588 2
 *	an error, the result is an error message.  It may change the
 *	internal script filename.
d1601 2
a1602 2
    if ((objc != 2) && (objc != 3)) {
        Tcl_WrongNumArgs(interp, 2, objv, "?filename?");
a1605 7
    if (objc == 3) {
	if (iPtr->scriptFile != NULL) {
	    Tcl_DecrRefCount(iPtr->scriptFile);
	}
	iPtr->scriptFile = objv[2];
	Tcl_IncrRefCount(iPtr->scriptFile);
    }
d1607 1
a1607 1
        Tcl_SetObjResult(interp, iPtr->scriptFile);
d1678 1
a1678 1
    CONST char *version;
d1726 1
a1726 2
    char *varName, *pattern;
    CONST char *simplePattern;
d1939 3
d1943 2
a1944 4
    Tcl_Obj *elemPtr;		/* Pointer to the element being extracted */

    if (objc < 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "list ?index...?");
d1949 1
a1949 4
     * If objc == 3, then objv[ 2 ] may be either a single index or
     * a list of indices: go to TclLindexList to determine which.
     * If objc >= 4, or objc == 2, then objv[ 2 .. objc-2 ] are all
     * single indices and processed as such in TclLindexFlat.
d1952 5
a1956 7
    if ( objc == 3 ) {

	elemPtr = TclLindexList( interp, objv[ 1 ], objv[ 2 ] );

    } else {

	elemPtr = TclLindexFlat( interp, objv[ 1 ], objc-2, objv+2 );
a1957 2
    }
	
d1959 1
a1959 1
     * Set the interpreter's object result to the last element extracted
d1962 4
a1965 6
    if ( elemPtr == NULL ) {
	return TCL_ERROR;
    } else {
	Tcl_SetObjResult(interp, elemPtr);
	Tcl_DecrRefCount( elemPtr );
	return TCL_OK;
d1967 1
a1967 64
}

/*
 *----------------------------------------------------------------------
 *
 * TclLindexList --
 *
 *	This procedure handles the 'lindex' command when objc==3.
 *
 * Results:
 *	Returns a pointer to the object extracted, or NULL if an
 *	error occurred.
 *
 * Side effects:
 *	None.
 *
 * If objv[1] can be parsed as a list, TclLindexList handles extraction
 * of the desired element locally.  Otherwise, it invokes
 * TclLindexFlat to treat objv[1] as a scalar.
 *
 * The reference count of the returned object includes one reference
 * corresponding to the pointer returned.  Thus, the calling code will
 * usually do something like:
 *	Tcl_SetObjResult( interp, result );
 *	Tcl_DecrRefCount( result );
 *
 *----------------------------------------------------------------------
 */

Tcl_Obj *
TclLindexList( interp, listPtr, argPtr )
    Tcl_Interp* interp;		/* Tcl interpreter */
    Tcl_Obj* listPtr;		/* List being unpacked */
    Tcl_Obj* argPtr;		/* Index or index list */
{

    Tcl_Obj **elemPtrs;		/* Elements of the list being manipulated. */
    int listLen;		/* Length of the list being manipulated. */
    int index;			/* Index into the list */
    int result;			/* Result returned from a Tcl library call */
    int i;			/* Current index number */
    Tcl_Obj** indices;		/* Array of list indices */
    int indexCount;		/* Size of the array of list indices */
    Tcl_Obj* oldListPtr;	/* Temp location to preserve the list
				 * pointer when replacing it with a sublist */

    /*
     * Determine whether argPtr designates a list or a single index.
     * We have to be careful about the order of the checks to avoid
     * repeated shimmering; see TIP#22 and TIP#33 for the details.
     */

    if ( argPtr->typePtr != &tclListType 
	 && TclGetIntForIndex( NULL , argPtr, 0, &index ) == TCL_OK ) {

	/*
	 * argPtr designates a single index.
	 */

	return TclLindexFlat( interp, listPtr, 1, &argPtr );

    } else if ( Tcl_ListObjGetElements( NULL, argPtr, &indexCount, &indices )
		!= TCL_OK ) {

d1969 1
a1969 2
	 * argPtr designates something that is neither an index nor a
	 * well-formed list.  Report the error via TclLindexFlat.
d1972 1
a1972 1
	return TclLindexFlat( interp, listPtr, 1, &argPtr );
d1976 2
a1977 2
     * Record the reference to the list that we are maintaining in
     * the activation record.
d1980 3
a1982 15
    Tcl_IncrRefCount( listPtr );

    /*
     * argPtr designates a list, and the 'else if' above has parsed it
     * into indexCount and indices.
     */

    for ( i = 0; i < indexCount; ++i ) {

	/*
	 * Convert the current listPtr to a list if necessary.
	 */
	    
	result = Tcl_ListObjGetElements( interp, listPtr,
					 &listLen, &elemPtrs);
d1984 1
a1984 2
	    Tcl_DecrRefCount( listPtr );
	    return NULL;
d1986 1
a1986 67
	    
	/*
	 * Get the index from indices[ i ]
	 */
	
	result = TclGetIntForIndex( interp, indices[ i ],
				    /*endValue*/ (listLen - 1),
				    &index );
	if ( result != TCL_OK ) {
	    /*
	     * Index could not be parsed
	     */

	    Tcl_DecrRefCount( listPtr );
	    return NULL;

	} else if ( index < 0
		    || index >= listLen ) {
	    /*
	     * Index is out of range
	     */
	    Tcl_DecrRefCount( listPtr );
	    listPtr = Tcl_NewObj();
	    Tcl_IncrRefCount( listPtr );
	    return listPtr;
	}
	
	/*
	 * Make sure listPtr still refers to a list object.
	 * If it shared a Tcl_Obj structure with the arguments, then
	 * it might have just been converted to something else.
	 */
	
	if (listPtr->typePtr != &tclListType) {
	    result = Tcl_ListObjGetElements(interp, listPtr, &listLen,
					    &elemPtrs);
	    if (result != TCL_OK) {
		Tcl_DecrRefCount( listPtr );
		return NULL;
	    }
	}
	
	/*
	 * Extract the pointer to the appropriate element
	 */
	
	oldListPtr = listPtr;
	listPtr = elemPtrs[ index ];
	Tcl_IncrRefCount( listPtr );
	Tcl_DecrRefCount( oldListPtr );
	
	/*
	 * The work we did above may have caused the internal rep
	 * of *argPtr to change to something else.  Get it back.
	 */
	
	result = Tcl_ListObjGetElements( interp, argPtr,
					 &indexCount, &indices );
	if ( result != TCL_OK ) {
	    /* 
	     * This can't happen unless some extension corrupted a Tcl_Obj.
	     */
	    Tcl_DecrRefCount( listPtr );
	    return NULL;
	}
	
    } /* end for */
d1989 1
a1989 2
     * Return the last object extracted.  Its reference count will include
     * the reference being returned.
d1992 2
a1993 123
    return listPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * TclLindexFlat --
 *
 *	This procedure handles the 'lindex' command, given that the
 *	arguments to the command are known to be a flat list.
 *
 * Results:
 *	Returns a standard Tcl result.
 *
 * Side effects:
 *	None.
 *
 * This procedure is called from either tclExecute.c or
 * Tcl_LindexObjCmd whenever either is presented with
 * objc == 2 or objc >= 4.  It is also called from TclLindexList
 * for the objc==3 case once it is determined that objv[2] cannot
 * be parsed as a list.
 *
 *----------------------------------------------------------------------
 */

Tcl_Obj *
TclLindexFlat( interp, listPtr, indexCount, indexArray )
    Tcl_Interp* interp;		/* Tcl interpreter */
    Tcl_Obj* listPtr;		/* Tcl object representing the list */
    int indexCount;		/* Count of indices */
    Tcl_Obj* CONST indexArray[];
				/* Array of pointers to Tcl objects
				 * representing the indices in the
				 * list */
{

    int i;			/* Current list index */
    int result;			/* Result of Tcl library calls */
    int listLen;		/* Length of the current list being 
				 * processed */
    Tcl_Obj** elemPtrs;		/* Array of pointers to the elements
				 * of the current list */
    int index;			/* Parsed version of the current element
				 * of indexArray  */
    Tcl_Obj* oldListPtr;	/* Temporary to hold listPtr so that
				 * its ref count can be decremented. */

    /*
     * Record the reference to the 'listPtr' object that we are
     * maintaining in the C activation record.
     */

    Tcl_IncrRefCount( listPtr );

    for ( i = 0; i < indexCount; ++i ) {

	/*
	 * Convert the current listPtr to a list if necessary.
	 */
	
	result = Tcl_ListObjGetElements(interp, listPtr,
					&listLen, &elemPtrs);
	if (result != TCL_OK) {
	    Tcl_DecrRefCount( listPtr );
	    return NULL;
	}
	
	/*
	 * Get the index from objv[i]
	 */
	
	result = TclGetIntForIndex( interp, indexArray[ i ],
				    /*endValue*/ (listLen - 1),
				    &index );
	if ( result != TCL_OK ) {

	    /* Index could not be parsed */

	    Tcl_DecrRefCount( listPtr );
	    return NULL;

	} else if ( index < 0
		    || index >= listLen ) {
	    
	    /*
	     * Index is out of range
	     */
		
	    Tcl_DecrRefCount( listPtr );
	    listPtr = Tcl_NewObj();
	    Tcl_IncrRefCount( listPtr );
	    return listPtr;
	}
	    
	/*
	 * Make sure listPtr still refers to a list object.
	 * It might have been converted to something else above
	 * if objv[1] overlaps with one of the other parameters.
	 */
	
	if (listPtr->typePtr != &tclListType) {
	    result = Tcl_ListObjGetElements(interp, listPtr, &listLen,
					    &elemPtrs);
	    if (result != TCL_OK) {
		Tcl_DecrRefCount( listPtr );
		return NULL;
	    }
	}
	
	/*
	 * Extract the pointer to the appropriate element
	 */
	
	oldListPtr = listPtr;
	listPtr = elemPtrs[ index ];
	Tcl_IncrRefCount( listPtr );
	Tcl_DecrRefCount( oldListPtr );
	
    }

    return listPtr;

d2022 2
a2023 1
    Tcl_Obj *listPtr;
d2025 1
a2025 1

d2031 5
d2041 1
a2041 7
    /*
     * Get the index.  "end" is interpreted to be the index after the last
     * element, such that using it will cause any inserted elements to be
     * appended to the list.
     */

    result = TclGetIntForIndex(interp, objv[2], /*end*/ len, &index);
a2044 3
    if (index > len) {
	index = len;
    }
d2048 2
a2049 1
     * we create a copy to modify: this is "copy on write".
d2051 1
a2051 1

d2055 24
a2078 1
	listPtr = Tcl_DuplicateObj(listPtr);
d2081 2
a2082 2

    if ((objc == 4) && (index == len)) {
d2086 1
a2092 3
	if (isDuplicate) {
	    Tcl_DecrRefCount(listPtr); /* free unneeded obj */
	}
d2100 3
a2102 1
    Tcl_SetObjResult(interp, listPtr);
d2309 3
a2311 1
    int isDuplicate, first, last, listLen, numToDelete, result;
d2319 12
a2330 1
    result = Tcl_ListObjLength(interp, objv[1], &listLen);
d2332 4
d2340 1
a2340 3
     * Get the first and last indexes.  "end" is interpreted to be the index
     * for the last element, such that using it will cause that element to
     * be included for deletion.
d2343 2
a2344 1
    result = TclGetIntForIndex(interp, objv[2], /*end*/ (listLen - 1), &first);
d2346 1
a2346 1
	return result;
d2348 1
d2350 2
a2351 1
    result = TclGetIntForIndex(interp, objv[3], /*end*/ (listLen - 1), &last);
d2353 1
a2353 1
	return result;
d2359 2
a2360 9

    /*
     * Complain if the user asked for a start element that is greater than the
     * list length.  This won't ever trigger for the "end*" case as that will
     * be properly constrained by TclGetIntForIndex because we use listLen-1
     * (to allow for replacing the last elem).
     */

    if ((first >= listLen) && (listLen > 0)) {
d2364 2
a2365 1
	return TCL_ERROR;
a2375 11
    /*
     * If the list object is unshared we can modify it directly, otherwise
     * we create a copy to modify: this is "copy on write".
     */

    listPtr = objv[1];
    isDuplicate = 0;
    if (Tcl_IsShared(listPtr)) {
	listPtr = Tcl_DuplicateObj(listPtr);
	isDuplicate = 1;
    }
d2384 1
a2384 4
	if (isDuplicate) {
	    Tcl_DecrRefCount(listPtr); /* free unneeded obj */
	}
	return result;
d2421 3
a2423 9
    int dataType, isIncreasing, lower, upper, patInt, objInt;
    int offset, allMatches, inlineReturn, negatedMatch;
    double patDouble, objDouble;
    Tcl_Obj *patObj, **listv, *listPtr, *startPtr;
    static CONST char *options[] = {
	"-all",	    "-ascii", "-decreasing", "-dictionary",
	"-exact",   "-glob",  "-increasing", "-inline",
	"-integer", "-not",   "-real",	     "-regexp",
	"-sorted",  "-start", NULL
d2426 1
a2426 4
	LSEARCH_ALL, LSEARCH_ASCII, LSEARCH_DECREASING, LSEARCH_DICTIONARY,
	LSEARCH_EXACT, LSEARCH_GLOB, LSEARCH_INCREASING, LSEARCH_INLINE,
	LSEARCH_INTEGER, LSEARCH_NOT, LSEARCH_REAL, LSEARCH_REGEXP,
	LSEARCH_SORTED, LSEARCH_START
a2427 16
    enum datatypes {
	ASCII, DICTIONARY, INTEGER, REAL
    };
    enum modes {
	EXACT, GLOB, REGEXP, SORTED
    };

    mode = GLOB;
    dataType = ASCII;
    isIncreasing = 1;
    allMatches = 0;
    inlineReturn = 0;
    negatedMatch = 0;
    listPtr = NULL;
    startPtr = NULL;
    offset = 0;
d2429 4
a2432 11
    if (objc < 3) {
	Tcl_WrongNumArgs(interp, 1, objv, "?options? list pattern");
	return TCL_ERROR;
    }

    for (i = 1; i < objc-2; i++) {
	if (Tcl_GetIndexFromObj(interp, objv[i], options, "option", 0, &index)
		!= TCL_OK) {
	    if (startPtr) {
		Tcl_DecrRefCount(startPtr);
	    }
d2435 3
a2437 68
	switch ((enum options) index) {
	case LSEARCH_ALL:		/* -all */
	    allMatches = 1;
	    break;
	case LSEARCH_ASCII:		/* -ascii */
	    dataType = ASCII;
	    break;
	case LSEARCH_DECREASING:	/* -decreasing */
	    isIncreasing = 0;
	    break;
	case LSEARCH_DICTIONARY:	/* -dictionary */
	    dataType = DICTIONARY;
	    break;
	case LSEARCH_EXACT:		/* -increasing */
	    mode = EXACT;
	    break;
	case LSEARCH_GLOB:		/* -glob */
	    mode = GLOB;
	    break;
	case LSEARCH_INCREASING:	/* -increasing */
	    isIncreasing = 1;
	    break;
	case LSEARCH_INLINE:		/* -inline */
	    inlineReturn = 1;
	    break;
	case LSEARCH_INTEGER:		/* -integer */
	    dataType = INTEGER;
	    break;
	case LSEARCH_NOT:		/* -not */
	    negatedMatch = 1;
	    break;
	case LSEARCH_REAL:		/* -real */
	    dataType = REAL;
	    break;
	case LSEARCH_REGEXP:		/* -regexp */
	    mode = REGEXP;
	    break;
	case LSEARCH_SORTED:		/* -sorted */
	    mode = SORTED;
	    break;
	case LSEARCH_START:		/* -start */
	    /*
	     * If there was a previous -start option, release its saved
	     * index because it will either be replaced or there will be
	     * an error.
	     */
	    if (startPtr) {
		Tcl_DecrRefCount(startPtr);
	    }
	    if (i > objc-4) {
		Tcl_AppendResult(interp, "missing starting index", NULL);
		return TCL_ERROR;
	    }
	    i++;
	    if (objv[i] == objv[objc - 2]) {
		/*
		 * Take copy to prevent shimmering problems.  Note
		 * that it does not matter if the index obj is also a
		 * component of the list being searched.  We only need
		 * to copy where the list and the index are
		 * one-and-the-same.
		 */
		startPtr = Tcl_DuplicateObj(objv[i]);
	    } else {
		startPtr = objv[i];
		Tcl_IncrRefCount(startPtr);
	    }
	}
a2446 3
	if (startPtr) {
	    Tcl_DecrRefCount(startPtr);
	}
a2449 16
    /*
     * Get the user-specified start offset.
     */
    if (startPtr) {
	result = TclGetIntForIndex(interp, startPtr, listc-1, &offset);
	Tcl_DecrRefCount(startPtr);
	if (result != TCL_OK) {
	    return result;
	}
	if (offset < 0) {
	    offset = 0;
	} else if (offset > listc-1) {
	    offset = listc-1;
	}
    }

d2451 1
a2451 23
    patternBytes = NULL;
    if ((enum modes) mode == EXACT || (enum modes) mode == SORTED) {
	switch ((enum datatypes) dataType) {
	case ASCII:
	case DICTIONARY:
	    patternBytes = Tcl_GetStringFromObj(patObj, &length);
	    break;
	case INTEGER:
	    result = Tcl_GetIntFromObj(interp, patObj, &patInt);
	    if (result != TCL_OK) {
		return result;
	    }
	    break;
	case REAL:
	    result = Tcl_GetDoubleFromObj(interp, patObj, &patDouble);
	    if (result != TCL_OK) {
		return result;
	    }
	    break;
	}
    } else {
	patternBytes = Tcl_GetStringFromObj(patObj, &length);
    }
a2452 5
    /*
     * Set default index value to -1, indicating failure; if we find the
     * item in the course of our search, index will be set to the correct
     * value.
     */
d2454 8
a2461 34
    match = 0;

    if ((enum modes) mode == SORTED && !allMatches && !negatedMatch) {
	/*
	 * If the data is sorted, we can do a more intelligent search.
	 * Note that there is no point in being smart when -all was
	 * specified; in that case, we have to look at all items anyway,
	 * and there is no sense in doing this when the match sense is
	 * inverted.
	 */
	lower = offset - 1;
	upper = listc;
	while (lower + 1 != upper) {
	    i = (lower + upper)/2;
	    switch ((enum datatypes) dataType) {
	    case ASCII:
		bytes = Tcl_GetString(listv[i]);
		match = strcmp(patternBytes, bytes);
		break;
	    case DICTIONARY:
		bytes = Tcl_GetString(listv[i]);
		match = DictionaryCompare(patternBytes, bytes);
		break;
	    case INTEGER:
		result = Tcl_GetIntFromObj(interp, listv[i], &objInt);
		if (result != TCL_OK) {
		    return result;
		}
		if (patInt == objInt) {
		    match = 0;
		} else if (patInt < objInt) {
		    match = -1;
		} else {
		    match = 1;
d2464 3
a2466 12
	    case REAL:
		result = Tcl_GetDoubleFromObj(interp, listv[i], &objDouble);
		if (result != TCL_OK) {
		    return result;
		}
		if (patDouble == objDouble) {
		    match = 0;
		} else if (patDouble < objDouble) {
		    match = -1;
		} else {
		    match = 1;
		}
d2469 1
a2469 85
	    if (match == 0) {
		/*
		 * Normally, binary search is written to stop when it
		 * finds a match.  If there are duplicates of an element in
		 * the list, our first match might not be the first occurance.
		 * Consider:  0 0 0 1 1 1 2 2 2
		 * To maintain consistancy with standard lsearch semantics,
		 * we must find the leftmost occurance of the pattern in the
		 * list.  Thus we don't just stop searching here.  This
		 * variation means that a search always makes log n
		 * comparisons (normal binary search might "get lucky" with
		 * an early comparison).
		 */
		index = i;
		upper = i;
	    } else if (match > 0) {
		if (isIncreasing) {
		    lower = i;
		} else {
		    upper = i;
		}
	    } else {
		if (isIncreasing) {
		    upper = i;
		} else {
		    lower = i;
		}
	    }
	}

    } else {
	/*
	 * We need to do a linear search, because (at least one) of:
	 *   - our matcher can only tell equal vs. not equal
	 *   - our matching sense is negated
	 *   - we're building a list of all matched items
	 */
	if (allMatches) {
	    listPtr = Tcl_NewListObj(0, (Tcl_Obj **) NULL);
	}
	for (i = offset; i < listc; i++) {
	    match = 0;
	    switch ((enum modes) mode) {
	    case SORTED:
	    case EXACT:
		switch ((enum datatypes) dataType) {
		case ASCII:
		    bytes = Tcl_GetStringFromObj(listv[i], &elemLen);
		    if (length == elemLen) {
			match = (memcmp(bytes, patternBytes,
				(size_t) length) == 0);
		    }
		    break;
		case DICTIONARY:
		    bytes = Tcl_GetString(listv[i]);
		    match = (DictionaryCompare(bytes, patternBytes) == 0);
		    break;
		case INTEGER:
		    result = Tcl_GetIntFromObj(interp, listv[i], &objInt);
		    if (result != TCL_OK) {
			if (listPtr) {
			    Tcl_DecrRefCount(listPtr);
			}
			return result;
		    }
		    match = (objInt == patInt);
		    break;
		case REAL:
		    result = Tcl_GetDoubleFromObj(interp, listv[i],
			    &objDouble);
		    if (result != TCL_OK) {
			if (listPtr) {
			    Tcl_DecrRefCount(listPtr);
			}
			return result;
		    }
		    match = (objDouble == patDouble);
		    break;
		}
		break;
	    case GLOB:
		match = Tcl_StringMatch(Tcl_GetString(listv[i]),
			patternBytes);
		break;
	    case REGEXP:
a2471 3
		    if (listPtr) {
			Tcl_DecrRefCount(listPtr);
		    }
a2475 20
	    /*
	     * Invert match condition for -not
	     */
	    if (negatedMatch) {
		match = !match;
	    }
	    if (match != 0) {
		if (!allMatches) {
		    index = i;
		    break;
		} else if (inlineReturn) {
		    /*
		     * Note that these appends are not expected to fail.
		     */
		    Tcl_ListObjAppendElement(interp, listPtr, listv[i]);
		} else {
		    Tcl_ListObjAppendElement(interp, listPtr,
			    Tcl_NewIntObj(i));
		}
	    }
d2477 4
d2482 1
a2482 17

    /*
     * Return everything or a single value.
     */
    if (allMatches) {
	Tcl_SetObjResult(interp, listPtr);
    } else if (!inlineReturn) {
	Tcl_SetIntObj(Tcl_GetObjResult(interp), index);
    } else if (index < 0) {
	/*
	 * Is this superfluous?  The result should be a blank object
	 * by default...
	 */
	Tcl_SetObjResult(interp, Tcl_NewObj());
    } else {
	Tcl_SetObjResult(interp, listv[index]);
    }
a2488 80
 * Tcl_LsetObjCmd --
 *
 *	This procedure is invoked to process the "lset" Tcl command.
 *	See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl result.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_LsetObjCmd( clientData, interp, objc, objv )
    ClientData clientData;	/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument values. */
{

    Tcl_Obj* listPtr;		/* Pointer to the list being altered. */
    Tcl_Obj* finalValuePtr;	/* Value finally assigned to the variable */

    /* Check parameter count */

    if ( objc < 3 ) {
	Tcl_WrongNumArgs( interp, 1, objv, "listVar index ?index...? value" );
	return TCL_ERROR;
    }

    /* Look up the list variable's value */

    listPtr = Tcl_ObjGetVar2( interp, objv[ 1 ], (Tcl_Obj*) NULL,
			      TCL_LEAVE_ERR_MSG );
    if ( listPtr == NULL ) {
	return TCL_ERROR;
    }

    /* 
     * Substitute the value in the value.  Return either the value or
     * else an unshared copy of it.
     */

    if ( objc == 4 ) {
	finalValuePtr = TclLsetList( interp, listPtr,
				     objv[ 2 ], objv[ 3 ] );
    } else {
	finalValuePtr = TclLsetFlat( interp, listPtr,
				     objc-3, objv+2, objv[ objc-1 ] );
    }

    /*
     * If substitution has failed, bail out.
     */

    if ( finalValuePtr == NULL ) {
	return TCL_ERROR;
    }

    /* Finally, update the variable so that traces fire. */

    listPtr = Tcl_ObjSetVar2( interp, objv[1], NULL, finalValuePtr,
			      TCL_LEAVE_ERR_MSG );
    Tcl_DecrRefCount( finalValuePtr );
    if ( listPtr == NULL ) {
	return TCL_ERROR;
    }

    /* Return the new value of the variable as the interpreter result. */

    Tcl_SetObjResult( interp, listPtr );
    return TCL_OK;

}

/*
 *----------------------------------------------------------------------
 *
d2519 1
a2519 1
    static CONST char *switches[] = {
d2536 1
a2536 1
    sortInfo.index = SORTIDX_NONE;
d2577 2
a2578 2
		if (TclGetIntForIndex(interp, objv[i+1], SORTIDX_END,
			&sortInfo.index) != TCL_OK) {
d2581 1
d2619 1
a2619 1
    if (sortInfo.resultCode != TCL_OK || length <= 0) {
d2622 3
d2835 1
a2835 1
    if (infoPtr->index != SORTIDX_NONE) {
d2839 2
a2840 2
	 * compare the elements, not the lists.  "end"-relative indices
	 * are signaled here with large negative values.
d2847 2
a2848 2
	if (infoPtr->index < SORTIDX_NONE) {
	    index = listLen + infoPtr->index + 1;
d2874 2
a2875 2
	if (infoPtr->index < SORTIDX_NONE) {
	    index = listLen + infoPtr->index + 1;
d3100 1
@


