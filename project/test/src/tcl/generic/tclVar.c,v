head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.58
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.56
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.54
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.52
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.50
	gdb_7_0-branch:1.5.0.48
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tcl8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.46
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.44
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.42
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.40
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.38
	gdb_6_5-2006-05-14-branchpoint:1.5
	readline_5_1-import-branch:1.5.0.36
	readline_5_1-import-branchpoint:1.5
	gdb_6_4-branch:1.5.0.34
	gdb_6_4-2005-11-01-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.32
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	ezannoni_pie-20040323-branch:1.5.0.30
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.28
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.26
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.24
	cagney_x86i386-20030821-branch:1.5.0.22
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.20
	gdb_6_0-2003-06-23-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.18
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.16
	cagney_writestrings-20030508-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.14
	cagney_fileio-20030521-branchpoint:1.5
	carlton_dictionary-20030430-merge:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.12
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.10
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.8
	cagney_lazyid-20030317-branchpoint:1.5
	offbyone-20030313-branch:1.5.0.6
	offbyone-20030313-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.4
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.2
	interps-20030202-branchpoint:1.5
	TCL8_4_1:1.1.1.4
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.2
	TCL_8_4_1:1.1.1.4
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.4
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TCL_8_4_0:1.1.1.3
	carlton_dictionary-branch:1.2.0.16
	carlton_dictionary-20020920-branchpoint:1.2
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.14
	gdb_5_3-branch:1.2.0.12
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.10
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.8
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.6
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.2
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.8
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.6
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	TCL_8_3:1.1.1.2
	NET:1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.4
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	dejagnu-2000-02-04:1.1.1.1
	dejagnu-2000-01-31:1.1.1.1
	dejagnu-2000-01-24:1.1.1.1
	dejagnu-2000-01-17:1.1.1.1
	dejagnu-2000-01-10:1.1.1.1
	dejagnu-2000-01-04:1.1.1.1
	dejagnu-1999-12-21:1.1.1.1
	dejagnu-1999-12-13:1.1.1.1
	dejagnu-1999-12-07:1.1.1.1
	dejagnu-1999-12-06:1.1.1.1
	dejagnu-1999-11-15:1.1.1.1
	dejagnu-1999-11-08:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.5
date	2003.01.21.19.40.07;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.26.19.47.53;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.37.03;	author kseitz;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2001.09.09.23.56.06;	author irox;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	99.11.09.01.28.43;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2002.09.27.21.49.05;	author kseitz;	state Exp;
branches;
next	;

1.3.4.1
date	2003.12.14.20.28.45;	author drow;	state Exp;
branches;
next	;

1.2.16.1
date	2002.12.23.19.40.27;	author carlton;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2003.02.07.19.18.14;	author carlton;	state Exp;
branches;
next	;

1.1.1.1
date	99.11.09.01.28.43;	author jsm;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.09.09.22.40.56;	author irox;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.09.24.19.56.10;	author kseitz;	state Exp;
branches;
next	1.1.1.4;

1.1.1.4
date	2002.11.26.20.00.32;	author hunt;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tcl 8.4.1
@
text
@/* 
 * tclVar.c --
 *
 *	This file contains routines that implement Tcl variables
 *	(both scalars and arrays).
 *
 *	The implementation of arrays is modelled after an initial
 *	implementation by Mark Diekhans and Karl Lehenbauer.
 *
 * Copyright (c) 1987-1994 The Regents of the University of California.
 * Copyright (c) 1994-1997 Sun Microsystems, Inc.
 * Copyright (c) 1998-1999 by Scriptics Corporation.
 * Copyright (c) 2001 by Kevin B. Kenny.  All rights reserved.
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tclVar.c,v 1.68 2002/10/17 17:41:44 dgp Exp $
 */

#include "tclInt.h"
#include "tclPort.h"

/*
 * The strings below are used to indicate what went wrong when a
 * variable access is denied.
 */

static CONST char *noSuchVar =		"no such variable";
static CONST char *isArray =		"variable is array";
static CONST char *needArray =		"variable isn't array";
static CONST char *noSuchElement =	"no such element in array";
static CONST char *danglingElement =
				"upvar refers to element in deleted array";
static CONST char *danglingVar =	
				"upvar refers to variable in deleted namespace";
static CONST char *badNamespace =	"parent namespace doesn't exist";
static CONST char *missingName =	"missing variable name";
static CONST char *isArrayElement =	"name refers to an element in an array";

/*
 * Forward references to procedures defined later in this file:
 */

static int		CallVarTraces _ANSI_ARGS_((Interp *iPtr, Var *arrayPtr,
			    Var *varPtr, CONST char *part1, CONST char *part2,
			    int flags, CONST int leaveErrMsg));
static void		CleanupVar _ANSI_ARGS_((Var *varPtr,
			    Var *arrayPtr));
static void		DeleteSearches _ANSI_ARGS_((Var *arrayVarPtr));
static void		DeleteArray _ANSI_ARGS_((Interp *iPtr,
			    CONST char *arrayName, Var *varPtr, int flags));
static void		DisposeTraceResult _ANSI_ARGS_((int flags,
			    char *result));
static int              ObjMakeUpvar _ANSI_ARGS_((Tcl_Interp *interp, 
                            CallFrame *framePtr, Tcl_Obj *otherP1Ptr, 
                            CONST char *otherP2, CONST int otherFlags,
		            CONST char *myName, CONST int myFlags, int index));
static Var *		NewVar _ANSI_ARGS_((void));
static ArraySearch *	ParseSearchId _ANSI_ARGS_((Tcl_Interp *interp,
			    CONST Var *varPtr, CONST char *varName,
			    Tcl_Obj *handleObj));
static void		VarErrMsg _ANSI_ARGS_((Tcl_Interp *interp,
			    CONST char *part1, CONST char *part2,
			    CONST char *operation, CONST char *reason));
static int		SetArraySearchObj _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_Obj *objPtr));


/*
 * Functions defined in this file that may be exported in the future
 * for use by the bytecode compiler and engine or to the public interface.
 */

Var *		TclLookupSimpleVar _ANSI_ARGS_((Tcl_Interp *interp,
		    CONST char *varName, int flags, CONST int create,
		    CONST char **errMsgPtr, int *indexPtr));
int		TclObjUnsetVar2 _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Obj *part1Ptr, CONST char *part2, int flags));

static Tcl_FreeInternalRepProc FreeLocalVarName;
static Tcl_DupInternalRepProc DupLocalVarName;
static Tcl_UpdateStringProc UpdateLocalVarName;
static Tcl_FreeInternalRepProc FreeNsVarName;
static Tcl_DupInternalRepProc DupNsVarName;
static Tcl_FreeInternalRepProc FreeParsedVarName;
static Tcl_DupInternalRepProc DupParsedVarName;
static Tcl_UpdateStringProc UpdateParsedVarName;

/*
 * Types of Tcl_Objs used to cache variable lookups.
 *
 * 
 * localVarName - INTERNALREP DEFINITION:
 *   twoPtrValue.ptr1 = pointer to the corresponding Proc 
 *   twoPtrValue.ptr2 = index into locals table
 *
 * nsVarName - INTERNALREP DEFINITION:
 *   twoPtrValue.ptr1: pointer to the namespace containing the 
 *                     reference
 *   twoPtrValue.ptr2: pointer to the corresponding Var 
 *
 * parsedVarName - INTERNALREP DEFINITION:
 *   twoPtrValue.ptr1 = pointer to the array name Tcl_Obj, 
 *                      or NULL if it is a scalar variable
 *   twoPtrValue.ptr2 = pointer to the element name string
 *                      (owned by this Tcl_Obj), or NULL if 
 *                      it is a scalar variable
 */

Tcl_ObjType tclLocalVarNameType = {
    "localVarName",
    FreeLocalVarName, DupLocalVarName, UpdateLocalVarName, NULL
};

Tcl_ObjType tclNsVarNameType = {
    "namespaceVarName",
    FreeNsVarName, DupNsVarName, NULL, NULL
};

Tcl_ObjType tclParsedVarNameType = {
    "parsedVarName",
    FreeParsedVarName, DupParsedVarName, UpdateParsedVarName, NULL
};

/*
 * Type of Tcl_Objs used to speed up array searches.
 *
 * INTERNALREP DEFINITION:
 *   twoPtrValue.ptr1 = searchIdNumber as offset from (char*)NULL
 *   twoPtrValue.ptr2 = variableNameStartInString as offset from (char*)NULL
 *
 * Note that the value stored in ptr2 is the offset into the string of
 * the start of the variable name and not the address of the variable
 * name itself, as this can be safely copied.
 */
Tcl_ObjType tclArraySearchType = {
    "array search",
    NULL, NULL, NULL, SetArraySearchObj
};


/*
 *----------------------------------------------------------------------
 *
 * TclLookupVar --
 *
 *	This procedure is used to locate a variable given its name(s). It
 *      has been mostly superseded by TclObjLookupVar, it is now only used 
 *      by the string-based interfaces. It is kept in tcl8.4 mainly because 
 *      it is in the internal stubs table, so that some extension may be 
 *      calling it. 
 *
 * Results:
 *	The return value is a pointer to the variable structure indicated by
 *	part1 and part2, or NULL if the variable couldn't be found. If the
 *	variable is found, *arrayPtrPtr is filled in with the address of the
 *	variable structure for the array that contains the variable (or NULL
 *	if the variable is a scalar). If the variable can't be found and
 *	either createPart1 or createPart2 are 1, a new as-yet-undefined
 *	(VAR_UNDEFINED) variable structure is created, entered into a hash
 *	table, and returned.
 *
 *	If the variable isn't found and creation wasn't specified, or some
 *	other error occurs, NULL is returned and an error message is left in
 *	the interp's result if TCL_LEAVE_ERR_MSG is set in flags. 
 *
 *	Note: it's possible for the variable returned to be VAR_UNDEFINED
 *	even if createPart1 or createPart2 are 1 (these only cause the hash
 *	table entry or array to be created). For example, the variable might
 *	be a global that has been unset but is still referenced by a
 *	procedure, or a variable that has been unset but it only being kept
 *	in existence (if VAR_UNDEFINED) by a trace.
 *
 * Side effects:
 *	New hashtable entries may be created if createPart1 or createPart2
 *	are 1.
 *
 *----------------------------------------------------------------------
 */
Var *
TclLookupVar(interp, part1, part2, flags, msg, createPart1, createPart2,
        arrayPtrPtr)
    Tcl_Interp *interp;		/* Interpreter to use for lookup. */
    CONST char *part1;	        /* If part2 isn't NULL, this is the name of
				 * an array. Otherwise, this
				 * is a full variable name that could
				 * include a parenthesized array element. */
    CONST char *part2;		/* Name of element within array, or NULL. */
    int flags;			/* Only TCL_GLOBAL_ONLY, TCL_NAMESPACE_ONLY,
				 * and TCL_LEAVE_ERR_MSG bits matter. */
    CONST char *msg;			/* Verb to use in error messages, e.g.
				 * "read" or "set". Only needed if
				 * TCL_LEAVE_ERR_MSG is set in flags. */
    int createPart1;		/* If 1, create hash table entry for part 1
				 * of name, if it doesn't already exist. If
				 * 0, return error if it doesn't exist. */
    int createPart2;		/* If 1, create hash table entry for part 2
				 * of name, if it doesn't already exist. If
				 * 0, return error if it doesn't exist. */
    Var **arrayPtrPtr;		/* If the name refers to an element of an
				 * array, *arrayPtrPtr gets filled in with
				 * address of array variable. Otherwise
				 * this is set to NULL. */
{
    Var *varPtr;
    CONST char *elName;		/* Name of array element or NULL; may be
				 * same as part2, or may be openParen+1. */
    int openParen, closeParen;
                                /* If this procedure parses a name into
				 * array and index, these are the offsets to 
				 * the parens around the index.  Otherwise 
				 * they are -1. */
    register CONST char *p;
    CONST char *errMsg = NULL;
    int index;
#define VAR_NAME_BUF_SIZE 26
    char buffer[VAR_NAME_BUF_SIZE];
    char *newVarName = buffer;

    varPtr = NULL;
    *arrayPtrPtr = NULL;
    openParen = closeParen = -1;

    /*
     * Parse part1 into array name and index.
     * Always check if part1 is an array element name and allow it only if
     * part2 is not given.   
     * (if one does not care about creating array elements that can't be used
     *  from tcl, and prefer slightly better performance, one can put
     *  the following in an   if (part2 == NULL) { ... } block and remove
     *  the part2's test and error reporting  or move that code in array set)
     */

    elName = part2;
    for (p = part1; *p ; p++) {
	if (*p == '(') {
	    openParen = p - part1;
	    do {
		p++;
	    } while (*p != '\0');
	    p--;
	    if (*p == ')') {
		if (part2 != NULL) {
		    if (flags & TCL_LEAVE_ERR_MSG) {
			VarErrMsg(interp, part1, part2, msg, needArray);
		    }
		    return NULL;
		}
		closeParen = p - part1;
	    } else {
		openParen = -1;
	    }
	    break;
	}
    }
    if (openParen != -1) {
	if (closeParen >= VAR_NAME_BUF_SIZE) {
	    newVarName = ckalloc((unsigned int) (closeParen+1));
	}
	memcpy(newVarName, part1, (unsigned int) closeParen);
	newVarName[openParen] = '\0';
	newVarName[closeParen] = '\0';
	part1 = newVarName;
	elName = newVarName + openParen + 1;
    }

    varPtr = TclLookupSimpleVar(interp, part1, flags, 
            createPart1, &errMsg, &index);
    if (varPtr == NULL) {
	if ((errMsg != NULL) && (flags & TCL_LEAVE_ERR_MSG)) {
	    VarErrMsg(interp, part1, elName, msg, errMsg);
	}
    } else {
	while (TclIsVarLink(varPtr)) {
	    varPtr = varPtr->value.linkPtr;
	}
	if (elName != NULL) {
	    *arrayPtrPtr = varPtr;
	    varPtr = TclLookupArrayElement(interp, part1, elName, flags, 
		    msg, createPart1, createPart2, varPtr);
	}
    }
    if (newVarName != buffer) {
	ckfree(newVarName);
    }

    return varPtr;
	
#undef VAR_NAME_BUF_SIZE
}

/*
 *----------------------------------------------------------------------
 *
 * TclObjLookupVar --
 *
 *	This procedure is used by virtually all of the variable code to
 *	locate a variable given its name(s). The parsing into array/element
 *      components and (if possible) the lookup results are cached in 
 *      part1Ptr, which is converted to one of the varNameTypes.
 *
 * Results:
 *	The return value is a pointer to the variable structure indicated by
 *	part1Ptr and part2, or NULL if the variable couldn't be found. If 
 *      the variable is found, *arrayPtrPtr is filled with the address of the
 *	variable structure for the array that contains the variable (or NULL
 *	if the variable is a scalar). If the variable can't be found and
 *	either createPart1 or createPart2 are 1, a new as-yet-undefined
 *	(VAR_UNDEFINED) variable structure is created, entered into a hash
 *	table, and returned.
 *
 *	If the variable isn't found and creation wasn't specified, or some
 *	other error occurs, NULL is returned and an error message is left in
 *	the interp's result if TCL_LEAVE_ERR_MSG is set in flags. 
 *
 *	Note: it's possible for the variable returned to be VAR_UNDEFINED
 *	even if createPart1 or createPart2 are 1 (these only cause the hash
 *	table entry or array to be created). For example, the variable might
 *	be a global that has been unset but is still referenced by a
 *	procedure, or a variable that has been unset but it only being kept
 *	in existence (if VAR_UNDEFINED) by a trace.
 *
 * Side effects:
 *	New hashtable entries may be created if createPart1 or createPart2
 *	are 1.
 *      The object part1Ptr is converted to one of tclLocalVarNameType, 
 *      tclNsVarNameType or tclParsedVarNameType and caches as much of the
 *      lookup as it can.
 *
 *----------------------------------------------------------------------
 */
Var *
TclObjLookupVar(interp, part1Ptr, part2, flags, msg, createPart1, createPart2,
        arrayPtrPtr)
    Tcl_Interp *interp;		/* Interpreter to use for lookup. */
    register Tcl_Obj *part1Ptr;	/* If part2 isn't NULL, this is the name 
				 * of an array. Otherwise, this is a full 
				 * variable name that could include a parenthesized 
				 * array element. */
    CONST char *part2;		/* Name of element within array, or NULL. */
    int flags;		        /* Only TCL_GLOBAL_ONLY, TCL_NAMESPACE_ONLY,
				 * and TCL_LEAVE_ERR_MSG bits matter. */
    CONST char *msg;		/* Verb to use in error messages, e.g.
				 * "read" or "set". Only needed if
				 * TCL_LEAVE_ERR_MSG is set in flags. */
    CONST int createPart1;	/* If 1, create hash table entry for part 1
				 * of name, if it doesn't already exist. If
				 * 0, return error if it doesn't exist. */
    CONST int createPart2;	/* If 1, create hash table entry for part 2
				 * of name, if it doesn't already exist. If
				 * 0, return error if it doesn't exist. */
    Var **arrayPtrPtr;		/* If the name refers to an element of an
				 * array, *arrayPtrPtr gets filled in with
				 * address of array variable. Otherwise
				 * this is set to NULL. */
{
    Interp *iPtr = (Interp *) interp;
    register Var *varPtr;	/* Points to the variable's in-frame Var
				 * structure. */
    char *part1;
    int index, len1, len2;
    int parsed = 0;
    Tcl_Obj *objPtr;
    Tcl_ObjType *typePtr = part1Ptr->typePtr;
    CONST char *errMsg = NULL;
    CallFrame *varFramePtr = iPtr->varFramePtr;
    Namespace *nsPtr;

    /*
     * If part1Ptr is a tclParsedVarNameType, separate it into the 
     * pre-parsed parts.
     */

    *arrayPtrPtr = NULL;
    if (typePtr == &tclParsedVarNameType) {
	if (part1Ptr->internalRep.twoPtrValue.ptr1 != NULL) {
	    if (part2 != NULL) {
		/*
		 * ERROR: part1Ptr is already an array element, cannot 
		 * specify a part2.
		 */

		if (flags & TCL_LEAVE_ERR_MSG) {
		    part1 = TclGetString(part1Ptr);
		    VarErrMsg(interp, part1, part2, msg, needArray);
		}
		return NULL;
	    }
	    part2 = (char *) part1Ptr->internalRep.twoPtrValue.ptr2;
	    part1Ptr = (Tcl_Obj *) part1Ptr->internalRep.twoPtrValue.ptr1;
	    typePtr = part1Ptr->typePtr;
	}
	parsed = 1;
    }
    part1 = Tcl_GetStringFromObj(part1Ptr, &len1);    

    nsPtr = ((varFramePtr == NULL)? iPtr->globalNsPtr : varFramePtr->nsPtr);
    if (nsPtr->varResProc != NULL || iPtr->resolverPtr != NULL) {
	goto doParse;
    }
    
    if (typePtr == &tclLocalVarNameType) {
	Proc *procPtr = (Proc *) part1Ptr->internalRep.twoPtrValue.ptr1;
	int localIndex = (int) part1Ptr->internalRep.twoPtrValue.ptr2;
	int useLocal;

	useLocal = ((varFramePtr != NULL) && varFramePtr->isProcCallFrame
	        && !(flags & (TCL_GLOBAL_ONLY | TCL_NAMESPACE_ONLY)));
	if (useLocal && (procPtr == varFramePtr->procPtr)) {
	    /*
	     * part1Ptr points to an indexed local variable of the
	     * correct procedure: use the cached value.
	     */
	    
	    varPtr = &(varFramePtr->compiledLocals[localIndex]);
	    goto donePart1;
	}
	goto doneParsing;
    } else if (typePtr == &tclNsVarNameType) {
	Namespace *cachedNsPtr;
	int useGlobal, useReference;

	varPtr = (Var *) part1Ptr->internalRep.twoPtrValue.ptr2;
	cachedNsPtr = (Namespace *) part1Ptr->internalRep.twoPtrValue.ptr1;
	useGlobal = (cachedNsPtr == iPtr->globalNsPtr) 
	    && ((flags & TCL_GLOBAL_ONLY) 
		|| ((*part1 == ':') && (*(part1+1) == ':'))
		|| (varFramePtr == NULL) 
		|| (!varFramePtr->isProcCallFrame 
		    && (nsPtr == iPtr->globalNsPtr)));
	useReference = useGlobal || ((cachedNsPtr == nsPtr) 
	        && ((flags & TCL_NAMESPACE_ONLY) 
		    || (varFramePtr && !varFramePtr->isProcCallFrame 
			&& !(flags & TCL_GLOBAL_ONLY)
			/* careful: an undefined ns variable could
			 * be hiding a valid global reference. */
			&& !(varPtr->flags & VAR_UNDEFINED))));
	if (useReference && (varPtr->hPtr != NULL)) {
	    /*
	     * A straight global or namespace reference, use it. It isn't 
	     * so simple to deal with 'implicit' namespace references, i.e., 
	     * those where the reference could be to either a namespace 
	     * or a global variable. Those we lookup again.
	     *
	     * If (varPtr->hPtr == NULL), this might be a reference to a
	     * variable in a deleted namespace, kept alive by e.g. part1Ptr.
	     * We could conceivably be so unlucky that a new namespace was
	     * created at the same address as the deleted one, so to be 
	     * safe we test for a valid hPtr.
	     */
	    goto donePart1;
	}
	goto doneParsing;
    }

    doParse:
    if (!parsed && (*(part1 + len1 - 1) == ')')) {
	/*
	 * part1Ptr is possibly an unparsed array element.
	 */
	register int i;
	char *newPart2;
	len2 = -1;
	for (i = 0; i < len1; i++) {
	    if (*(part1 + i) == '(') {
		if (part2 != NULL) {
		    if (flags & TCL_LEAVE_ERR_MSG) {
			VarErrMsg(interp, part1, part2, msg, needArray);
		    }
		}			

		/*
		 * part1Ptr points to an array element; first copy 
		 * the element name to a new string part2.
		 */

		part2 = part1 + i + 1;
		len2 = len1 - i - 2;
		len1 = i;

		newPart2 = ckalloc((unsigned int) (len2+1));
		memcpy(newPart2, part2, (unsigned int) len2);
		*(newPart2+len2) = '\0';
		part2 = newPart2;

		/*
		 * Free the internal rep of the original part1Ptr, now
		 * renamed objPtr, and set it to tclParsedVarNameType.
		 */

		objPtr = part1Ptr;
		if ((typePtr != NULL) && (typePtr->freeIntRepProc != NULL)) {
		    typePtr->freeIntRepProc(objPtr);
		}
		objPtr->typePtr = &tclParsedVarNameType;

		/*
		 * Define a new string object to hold the new part1Ptr, i.e., 
		 * the array name. Set the internal rep of objPtr, reset
		 * typePtr and part1 to contain the references to the
		 * array name.
		 */

		part1Ptr = Tcl_NewStringObj(part1, len1);
		Tcl_IncrRefCount(part1Ptr);

		objPtr->internalRep.twoPtrValue.ptr1 = (VOID *) part1Ptr;
		objPtr->internalRep.twoPtrValue.ptr2 = (VOID *) part2;		

		typePtr = part1Ptr->typePtr;
		part1 = TclGetString(part1Ptr);
		break;
	    }
	}
    }
    
    doneParsing:
    /*
     * part1Ptr is not an array element; look it up, and convert 
     * it to one of the cached types if possible.
     */

    if ((typePtr != NULL) && (typePtr->freeIntRepProc != NULL)) {
	typePtr->freeIntRepProc(part1Ptr);
	part1Ptr->typePtr = NULL;
    }

    varPtr = TclLookupSimpleVar(interp, part1, flags, 
            createPart1, &errMsg, &index);
    if (varPtr == NULL) {
	if ((errMsg != NULL) && (flags & TCL_LEAVE_ERR_MSG)) {
	    VarErrMsg(interp, part1, part2, msg, errMsg);
	}
	return NULL;
    }

    /*
     * Cache the newly found variable if possible.
     */

    if (index >= 0) {
        /*
	 * An indexed local variable.
	 */

	Proc *procPtr = ((Interp *) interp)->varFramePtr->procPtr;

	part1Ptr->typePtr = &tclLocalVarNameType;
	procPtr->refCount++;
	part1Ptr->internalRep.twoPtrValue.ptr1 = (VOID *) procPtr;
	part1Ptr->internalRep.twoPtrValue.ptr2 = (VOID *) index;
    } else if (index > -3) {
	Namespace *nsPtr;
    
	nsPtr = ((index == -1)? iPtr->globalNsPtr : varFramePtr->nsPtr);
	varPtr->refCount++;
	part1Ptr->typePtr = &tclNsVarNameType;
	part1Ptr->internalRep.twoPtrValue.ptr1 = (VOID *) nsPtr;
	part1Ptr->internalRep.twoPtrValue.ptr2 = (VOID *) varPtr;
    } else {
	/*
	 * At least mark part1Ptr as already parsed.
	 */
	part1Ptr->typePtr = &tclParsedVarNameType;
	part1Ptr->internalRep.twoPtrValue.ptr1 = NULL;
	part1Ptr->internalRep.twoPtrValue.ptr2 = NULL;
    }
    
    donePart1:
#if 0
    if (varPtr == NULL) {
	if (flags & TCL_LEAVE_ERR_MSG) {
	    part1 = TclGetString(part1Ptr);
	    VarErrMsg(interp, part1, part2, msg, 
		    "Cached variable reference is NULL.");
	}
	return NULL;
    }
#endif
    while (TclIsVarLink(varPtr)) {
	varPtr = varPtr->value.linkPtr;
    }

    if (part2 != NULL) {
	/*
	 * Array element sought: look it up.
	 */

	part1 = TclGetString(part1Ptr);
	*arrayPtrPtr = varPtr;
	varPtr = TclLookupArrayElement(interp, part1, part2, 
                flags, msg, createPart1, createPart2, varPtr);
    }
    return varPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * TclLookupSimpleVar --
 *
 *	This procedure is used by to locate a simple variable (i.e., not
 *      an array element) given its name.
 *
 * Results:
 *	The return value is a pointer to the variable structure indicated by
 *	varName, or NULL if the variable couldn't be found. If the variable 
 *      can't be found and create is 1, a new as-yet-undefined (VAR_UNDEFINED) 
 *      variable structure is created, entered into a hash table, and returned.
 *
 *      If the current CallFrame corresponds to a proc and the variable found is
 *      one of the compiledLocals, its index is placed in *indexPtr. Otherwise,
 *      *indexPtr will be set to (according to the needs of TclObjLookupVar):
 *               -1 a global reference
 *               -2 a reference to a namespace variable
 *               -3 a non-cachable reference, i.e., one of:
 *                    . non-indexed local var
 *                    . a reference of unknown origin;
 *                    . resolution by a namespace or interp resolver
 *
 *	If the variable isn't found and creation wasn't specified, or some
 *	other error occurs, NULL is returned and the corresponding error
 *	message is left in *errMsgPtr. 
 *
 *	Note: it's possible for the variable returned to be VAR_UNDEFINED
 *	even if create is 1 (this only causes the hash table entry to be
 *	created).  For example, the variable might be a global that has been
 *	unset but is still referenced by a procedure, or a variable that has
 *	been unset but it only being kept in existence (if VAR_UNDEFINED) by
 *	a trace.
 *
 * Side effects:
 *	A new hashtable entry may be created if create is 1.
 *
 *----------------------------------------------------------------------
 */

Var *
TclLookupSimpleVar(interp, varName, flags, create, errMsgPtr, indexPtr)
    Tcl_Interp *interp;		/* Interpreter to use for lookup. */
    CONST char *varName;        /* This is a simple variable name that could
				 * representa scalar or an array. */
    int flags;		        /* Only TCL_GLOBAL_ONLY, TCL_NAMESPACE_ONLY,
				 * and TCL_LEAVE_ERR_MSG bits matter. */
    CONST int create;		/* If 1, create hash table entry for varname,
				 * if it doesn't already exist. If 0, return 
				 * error if it doesn't exist. */
    CONST char **errMsgPtr;
    int *indexPtr;
{    
    Interp *iPtr = (Interp *) interp;
    CallFrame *varFramePtr = iPtr->varFramePtr;
				/* Points to the procedure call frame whose
				 * variables are currently in use. Same as
				 * the current procedure's frame, if any,
				 * unless an "uplevel" is executing. */
    Tcl_HashTable *tablePtr;	/* Points to the hashtable, if any, in which
				 * to look up the variable. */
    Tcl_Var var;                /* Used to search for global names. */
    Var *varPtr;		/* Points to the Var structure returned for
				 * the variable. */
    Namespace *varNsPtr, *cxtNsPtr, *dummy1Ptr, *dummy2Ptr;
    ResolverScheme *resPtr;
    Tcl_HashEntry *hPtr;
    int new, i, result;

    varPtr = NULL;
    varNsPtr = NULL;		/* set non-NULL if a nonlocal variable */
    *indexPtr = -3;

    /*
     * If this namespace has a variable resolver, then give it first
     * crack at the variable resolution.  It may return a Tcl_Var
     * value, it may signal to continue onward, or it may signal
     * an error.
     */
    if ((flags & TCL_GLOBAL_ONLY) || iPtr->varFramePtr == NULL) {
        cxtNsPtr = iPtr->globalNsPtr;
    } else {
        cxtNsPtr = iPtr->varFramePtr->nsPtr;
    }

    if (cxtNsPtr->varResProc != NULL || iPtr->resolverPtr != NULL) {
        resPtr = iPtr->resolverPtr;

        if (cxtNsPtr->varResProc) {
            result = (*cxtNsPtr->varResProc)(interp, varName,
		    (Tcl_Namespace *) cxtNsPtr, flags, &var);
        } else {
            result = TCL_CONTINUE;
        }

        while (result == TCL_CONTINUE && resPtr) {
            if (resPtr->varResProc) {
                result = (*resPtr->varResProc)(interp, varName,
			(Tcl_Namespace *) cxtNsPtr, flags, &var);
            }
            resPtr = resPtr->nextPtr;
        }

        if (result == TCL_OK) {
            varPtr = (Var *) var;
	    return varPtr;
        } else if (result != TCL_CONTINUE) {
	    return NULL;
        }
    }

    /*
     * Look up varName. Look it up as either a namespace variable or as a
     * local variable in a procedure call frame (varFramePtr).
     * Interpret varName as a namespace variable if:
     *    1) so requested by a TCL_GLOBAL_ONLY or TCL_NAMESPACE_ONLY flag,
     *    2) there is no active frame (we're at the global :: scope),
     *    3) the active frame was pushed to define the namespace context
     *       for a "namespace eval" or "namespace inscope" command,
     *    4) the name has namespace qualifiers ("::"s).
     * Otherwise, if varName is a local variable, search first in the
     * frame's array of compiler-allocated local variables, then in its
     * hashtable for runtime-created local variables.
     *
     * If create and the variable isn't found, create the variable and,
     * if necessary, create varFramePtr's local var hashtable.
     */

    if (((flags & (TCL_GLOBAL_ONLY | TCL_NAMESPACE_ONLY)) != 0)
	    || (varFramePtr == NULL)
	    || !varFramePtr->isProcCallFrame
	    || (strstr(varName, "::") != NULL)) {
	CONST char *tail;
	int lookGlobal;
	
	lookGlobal = (flags & TCL_GLOBAL_ONLY) 
	    || (cxtNsPtr == iPtr->globalNsPtr)
	    || ((*varName == ':') && (*(varName+1) == ':'));
	if (lookGlobal) {
	    *indexPtr = -1;
	    flags = (flags | TCL_GLOBAL_ONLY) & ~TCL_NAMESPACE_ONLY;
	} else if (flags & TCL_NAMESPACE_ONLY) {
	    *indexPtr = -2;
	}

	/*
	 * Don't pass TCL_LEAVE_ERR_MSG, we may yet create the variable,
	 * or otherwise generate our own error!
	 */
	var = Tcl_FindNamespaceVar(interp, varName, (Tcl_Namespace *) cxtNsPtr,
		flags & ~TCL_LEAVE_ERR_MSG);
	if (var != (Tcl_Var) NULL) {
            varPtr = (Var *) var;
        }
	if (varPtr == NULL) {
	    if (create) {   /* var wasn't found so create it  */
		TclGetNamespaceForQualName(interp, varName, cxtNsPtr,
			flags, &varNsPtr, &dummy1Ptr, &dummy2Ptr, &tail);
		if (varNsPtr == NULL) {
		    *errMsgPtr = badNamespace;
		    return NULL;
		}
		if (tail == NULL) {
		    *errMsgPtr = missingName;
		    return NULL;
		}
		hPtr = Tcl_CreateHashEntry(&varNsPtr->varTable, tail, &new);
		varPtr = NewVar();
		Tcl_SetHashValue(hPtr, varPtr);
		varPtr->hPtr = hPtr;
		varPtr->nsPtr = varNsPtr;
		if ((lookGlobal)  || (varNsPtr == NULL)) {
		    /*
		     * The variable was created starting from the global
		     * namespace: a global reference is returned even if 
		     * it wasn't explicitly requested.
		     */
		    *indexPtr = -1;
		} else {
		    *indexPtr = -2;
		}
	    } else {		/* var wasn't found and not to create it */
		*errMsgPtr = noSuchVar;
		return NULL;
	    }
	}
    } else {			/* local var: look in frame varFramePtr */
	Proc *procPtr = varFramePtr->procPtr;
	int localCt = procPtr->numCompiledLocals;
	CompiledLocal *localPtr = procPtr->firstLocalPtr;
	Var *localVarPtr = varFramePtr->compiledLocals;
	int varNameLen = strlen(varName);
	
	for (i = 0;  i < localCt;  i++) {
	    if (!TclIsVarTemporary(localPtr)) {
		register char *localName = localVarPtr->name;
		if ((varName[0] == localName[0])
		        && (varNameLen == localPtr->nameLength)
		        && (strcmp(varName, localName) == 0)) {
		    *indexPtr = i;
		    return localVarPtr;
		}
	    }
	    localVarPtr++;
	    localPtr = localPtr->nextPtr;
	}
	tablePtr = varFramePtr->varTablePtr;
	if (create) {
	    if (tablePtr == NULL) {
		tablePtr = (Tcl_HashTable *)
		    ckalloc(sizeof(Tcl_HashTable));
		Tcl_InitHashTable(tablePtr, TCL_STRING_KEYS);
		varFramePtr->varTablePtr = tablePtr;
	    }
	    hPtr = Tcl_CreateHashEntry(tablePtr, varName, &new);
	    if (new) {
		varPtr = NewVar();
		Tcl_SetHashValue(hPtr, varPtr);
		varPtr->hPtr = hPtr;
		varPtr->nsPtr = NULL; /* a local variable */
	    } else {
		varPtr = (Var *) Tcl_GetHashValue(hPtr);
	    }
	} else {
	    hPtr = NULL;
	    if (tablePtr != NULL) {
		hPtr = Tcl_FindHashEntry(tablePtr, varName);
	    }
	    if (hPtr == NULL) {
		*errMsgPtr = noSuchVar;
		return NULL;
	    }
	    varPtr = (Var *) Tcl_GetHashValue(hPtr);
	}
    }
    return varPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * TclLookupArrayElement --
 *
 *	This procedure is used to locate a variable which is in an array's 
 *      hashtable given a pointer to the array's Var structure and the 
 *      element's name.
 *
 * Results:
 *	The return value is a pointer to the variable structure , or NULL if 
 *      the variable couldn't be found. 
 *
 *      If arrayPtr points to a variable that isn't an array and createPart1 
 *      is 1, the corresponding variable will be converted to an array. 
 *      Otherwise, NULL is returned and an error message is left in
 *	the interp's result if TCL_LEAVE_ERR_MSG is set in flags.
 *
 *      If the variable is not found and createPart2 is 1, the variable is
 *      created. Otherwise, NULL is returned and an error message is left in
 *	the interp's result if TCL_LEAVE_ERR_MSG is set in flags.
 *
 *	Note: it's possible for the variable returned to be VAR_UNDEFINED
 *	even if createPart1 or createPart2 are 1 (these only cause the hash
 *	table entry or array to be created). For example, the variable might
 *	be a global that has been unset but is still referenced by a
 *	procedure, or a variable that has been unset but it only being kept
 *	in existence (if VAR_UNDEFINED) by a trace.
 *
 * Side effects:
 *      The variable at arrayPtr may be converted to be an array if 
 *      createPart1 is 1. A new hashtable entry may be created if createPart2 
 *      is 1.
 *
 *----------------------------------------------------------------------
 */

Var *
TclLookupArrayElement(interp, arrayName, elName, flags, msg, createArray, createElem, arrayPtr)
    Tcl_Interp *interp;		/* Interpreter to use for lookup. */
    CONST char *arrayName;	        /* This is the name of the array. */
    CONST char *elName;		/* Name of element within array. */
    CONST int flags;		/* Only TCL_LEAVE_ERR_MSG bit matters. */
    CONST char *msg;			/* Verb to use in error messages, e.g.
				 * "read" or "set". Only needed if
				 * TCL_LEAVE_ERR_MSG is set in flags. */
    CONST int createArray;	/* If 1, transform arrayName to be an array
				 * if it isn't one yet and the transformation 
				 * is possible. If 0, return error if it 
				 * isn't already an array. */
    CONST int createElem;	/* If 1, create hash table entry for the 
				 * element, if it doesn't already exist. If
				 * 0, return error if it doesn't exist. */
    Var *arrayPtr;	        /* Pointer to the array's Var structure. */
{
    Tcl_HashEntry *hPtr;
    int new;
    Var *varPtr;

    /*
     * We're dealing with an array element. Make sure the variable is an
     * array and look up the element (create the element if desired).
     */

    if (TclIsVarUndefined(arrayPtr) && !TclIsVarArrayElement(arrayPtr)) {
	if (!createArray) {
	    if (flags & TCL_LEAVE_ERR_MSG) {
		VarErrMsg(interp, arrayName, elName, msg, noSuchVar);
	    }
	    return NULL;
	}

	/*
	 * Make sure we are not resurrecting a namespace variable from a
	 * deleted namespace!
	 */
	if ((arrayPtr->flags & VAR_IN_HASHTABLE) && (arrayPtr->hPtr == NULL)) {
	    if (flags & TCL_LEAVE_ERR_MSG) {
		VarErrMsg(interp, arrayName, elName, msg, danglingVar);
	    }
	    return NULL;
	}

	TclSetVarArray(arrayPtr);
	TclClearVarUndefined(arrayPtr);
	arrayPtr->value.tablePtr =
	    (Tcl_HashTable *) ckalloc(sizeof(Tcl_HashTable));
	Tcl_InitHashTable(arrayPtr->value.tablePtr, TCL_STRING_KEYS);
    } else if (!TclIsVarArray(arrayPtr)) {
	if (flags & TCL_LEAVE_ERR_MSG) {
	    VarErrMsg(interp, arrayName, elName, msg, needArray);
	}
	return NULL;
    }

    if (createElem) {
	hPtr = Tcl_CreateHashEntry(arrayPtr->value.tablePtr, elName, &new);
	if (new) {
	    if (arrayPtr->searchPtr != NULL) {
		DeleteSearches(arrayPtr);
	    }
	    varPtr = NewVar();
	    Tcl_SetHashValue(hPtr, varPtr);
	    varPtr->hPtr = hPtr;
	    varPtr->nsPtr = arrayPtr->nsPtr;
	    TclSetVarArrayElement(varPtr);
	}
    } else {
	hPtr = Tcl_FindHashEntry(arrayPtr->value.tablePtr, elName);
	if (hPtr == NULL) {
	    if (flags & TCL_LEAVE_ERR_MSG) {
		VarErrMsg(interp, arrayName, elName, msg, noSuchElement);
	    }
	    return NULL;
	}
    }
    return (Var *) Tcl_GetHashValue(hPtr);
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetVar --
 *
 *	Return the value of a Tcl variable as a string.
 *
 * Results:
 *	The return value points to the current value of varName as a string.
 *	If the variable is not defined or can't be read because of a clash
 *	in array usage then a NULL pointer is returned and an error message
 *	is left in the interp's result if the TCL_LEAVE_ERR_MSG flag is set.
 *	Note: the return value is only valid up until the next change to the
 *	variable; if you depend on the value lasting longer than that, then
 *	make yourself a private copy.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

CONST char *
Tcl_GetVar(interp, varName, flags)
    Tcl_Interp *interp;		/* Command interpreter in which varName is
				 * to be looked up. */
    CONST char *varName;	/* Name of a variable in interp. */
    int flags;			/* OR-ed combination of TCL_GLOBAL_ONLY,
				 * TCL_NAMESPACE_ONLY or TCL_LEAVE_ERR_MSG
				 * bits. */
{
    return Tcl_GetVar2(interp, varName, (char *) NULL, flags);
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetVar2 --
 *
 *	Return the value of a Tcl variable as a string, given a two-part
 *	name consisting of array name and element within array.
 *
 * Results:
 *	The return value points to the current value of the variable given
 *	by part1 and part2 as a string. If the specified variable doesn't
 *	exist, or if there is a clash in array usage, then NULL is returned
 *	and a message will be left in the interp's result if the
 *	TCL_LEAVE_ERR_MSG flag is set. Note: the return value is only valid
 *	up until the next change to the variable; if you depend on the value
 *	lasting longer than that, then make yourself a private copy.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

CONST char *
Tcl_GetVar2(interp, part1, part2, flags)
    Tcl_Interp *interp;		/* Command interpreter in which variable is
				 * to be looked up. */
    CONST char *part1;		/* Name of an array (if part2 is non-NULL)
				 * or the name of a variable. */
    CONST char *part2;		/* If non-NULL, gives the name of an element
				 * in the array part1. */
    int flags;			/* OR-ed combination of TCL_GLOBAL_ONLY,
				 * TCL_NAMESPACE_ONLY and TCL_LEAVE_ERR_MSG
                                 * bits. */
{
    Tcl_Obj *objPtr;

    objPtr = Tcl_GetVar2Ex(interp, part1, part2, flags);
    if (objPtr == NULL) {
	return NULL;
    }
    return TclGetString(objPtr);
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetVar2Ex --
 *
 *	Return the value of a Tcl variable as a Tcl object, given a
 *	two-part name consisting of array name and element within array.
 *
 * Results:
 *	The return value points to the current object value of the variable
 *	given by part1Ptr and part2Ptr. If the specified variable doesn't
 *	exist, or if there is a clash in array usage, then NULL is returned
 *	and a message will be left in the interpreter's result if the
 *	TCL_LEAVE_ERR_MSG flag is set.
 *
 * Side effects:
 *	The ref count for the returned object is _not_ incremented to
 *	reflect the returned reference; if you want to keep a reference to
 *	the object you must increment its ref count yourself.
 *
 *----------------------------------------------------------------------
 */

Tcl_Obj *
Tcl_GetVar2Ex(interp, part1, part2, flags)
    Tcl_Interp *interp;		/* Command interpreter in which variable is
				 * to be looked up. */
    CONST char *part1;		/* Name of an array (if part2 is non-NULL)
				 * or the name of a variable. */
    CONST char *part2;		/* If non-NULL, gives the name of an element
				 * in the array part1. */
    int flags;			/* OR-ed combination of TCL_GLOBAL_ONLY,
				 * and TCL_LEAVE_ERR_MSG bits. */
{
    Var *varPtr, *arrayPtr;

    /*
     * We need a special flag check to see if we want to create part 1,
     * because commands like lappend require read traces to trigger for
     * previously non-existent values.
     */
    varPtr = TclLookupVar(interp, part1, part2, flags, "read",
            /*createPart1*/ (flags & TCL_TRACE_READS),
	    /*createPart2*/ 1, &arrayPtr);
    if (varPtr == NULL) {
	return NULL;
    }

    return TclPtrGetVar(interp, varPtr, arrayPtr, part1, part2, flags);
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_ObjGetVar2 --
 *
 *	Return the value of a Tcl variable as a Tcl object, given a
 *	two-part name consisting of array name and element within array.
 *
 * Results:
 *	The return value points to the current object value of the variable
 *	given by part1Ptr and part2Ptr. If the specified variable doesn't
 *	exist, or if there is a clash in array usage, then NULL is returned
 *	and a message will be left in the interpreter's result if the
 *	TCL_LEAVE_ERR_MSG flag is set.
 *
 * Side effects:
 *	The ref count for the returned object is _not_ incremented to
 *	reflect the returned reference; if you want to keep a reference to
 *	the object you must increment its ref count yourself.
 *
 *----------------------------------------------------------------------
 */

Tcl_Obj *
Tcl_ObjGetVar2(interp, part1Ptr, part2Ptr, flags)
    Tcl_Interp *interp;		/* Command interpreter in which variable is
				 * to be looked up. */
    register Tcl_Obj *part1Ptr;	/* Points to an object holding the name of
				 * an array (if part2 is non-NULL) or the
				 * name of a variable. */
    register Tcl_Obj *part2Ptr;	/* If non-null, points to an object holding
				 * the name of an element in the array
				 * part1Ptr. */
    int flags;			/* OR-ed combination of TCL_GLOBAL_ONLY and
				 * TCL_LEAVE_ERR_MSG bits. */
{
    Var *varPtr, *arrayPtr;
    char *part1, *part2;

    part1 = Tcl_GetString(part1Ptr);
    part2 = ((part2Ptr == NULL) ? NULL : Tcl_GetString(part2Ptr));
    
    /*
     * We need a special flag check to see if we want to create part 1,
     * because commands like lappend require read traces to trigger for
     * previously non-existent values.
     */
    varPtr = TclObjLookupVar(interp, part1Ptr, part2, flags, "read",
            /*createPart1*/ (flags & TCL_TRACE_READS),
	    /*createPart2*/ 1, &arrayPtr);
    if (varPtr == NULL) {
	return NULL;
    }

    return TclPtrGetVar(interp, varPtr, arrayPtr, part1, part2, flags);
}

/*
 *----------------------------------------------------------------------
 *
 * TclPtrGetVar --
 *
 *	Return the value of a Tcl variable as a Tcl object, given the
 *      pointers to the variable's (and possibly containing array's) 
 *      VAR structure.
 *
 * Results:
 *	The return value points to the current object value of the variable
 *	given by varPtr. If the specified variable doesn't exist, or if there 
 *      is a clash in array usage, then NULL is returned and a message will be 
 *      left in the interpreter's result if the TCL_LEAVE_ERR_MSG flag is set.
 *
 * Side effects:
 *	The ref count for the returned object is _not_ incremented to
 *	reflect the returned reference; if you want to keep a reference to
 *	the object you must increment its ref count yourself.
 *
 *----------------------------------------------------------------------
 */

Tcl_Obj *
TclPtrGetVar(interp, varPtr, arrayPtr, part1, part2, flags)
    Tcl_Interp *interp;		/* Command interpreter in which variable is
				 * to be looked up. */
    register Var *varPtr;       /* The variable to be read.*/
    Var *arrayPtr;              /* NULL for scalar variables, pointer to
				 * the containing array otherwise. */
    CONST char *part1;		/* Name of an array (if part2 is non-NULL)
				 * or the name of a variable. */
    CONST char *part2;		/* If non-NULL, gives the name of an element
				 * in the array part1. */
    CONST int flags;		/* OR-ed combination of TCL_GLOBAL_ONLY,
				 * and TCL_LEAVE_ERR_MSG bits. */
{
    Interp *iPtr = (Interp *) interp;
    CONST char *msg;

    /*
     * Invoke any traces that have been set for the variable.
     */

    if ((varPtr->tracePtr != NULL)
	    || ((arrayPtr != NULL) && (arrayPtr->tracePtr != NULL))) {
	if (TCL_ERROR == CallVarTraces(iPtr, arrayPtr, varPtr, part1, part2,
		(flags & (TCL_NAMESPACE_ONLY|TCL_GLOBAL_ONLY))
		| TCL_TRACE_READS, (flags & TCL_LEAVE_ERR_MSG))) {
	    goto errorReturn;
	}
    }

    /*
     * Return the element if it's an existing scalar variable.
     */
    
    if (TclIsVarScalar(varPtr) && !TclIsVarUndefined(varPtr)) {
	return varPtr->value.objPtr;
    }
    
    if (flags & TCL_LEAVE_ERR_MSG) {
	if (TclIsVarUndefined(varPtr) && (arrayPtr != NULL)
	        && !TclIsVarUndefined(arrayPtr)) {
	    msg = noSuchElement;
	} else if (TclIsVarArray(varPtr)) {
	    msg = isArray;
	} else {
	    msg = noSuchVar;
	}
	VarErrMsg(interp, part1, part2, "read", msg);
    }

    /*
     * An error. If the variable doesn't exist anymore and no-one's using
     * it, then free up the relevant structures and hash table entries.
     */

    errorReturn:
    if (TclIsVarUndefined(varPtr)) {
	CleanupVar(varPtr, arrayPtr);
    }
    return NULL;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_SetObjCmd --
 *
 *	This procedure is invoked to process the "set" Tcl command.
 *	See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl result value.
 *
 * Side effects:
 *	A variable's value may be changed.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
int
Tcl_SetObjCmd(dummy, interp, objc, objv)
    ClientData dummy;			/* Not used. */
    register Tcl_Interp *interp;	/* Current interpreter. */
    int objc;				/* Number of arguments. */
    Tcl_Obj *CONST objv[];		/* Argument objects. */
{
    Tcl_Obj *varValueObj;

    if (objc == 2) {
	varValueObj = Tcl_ObjGetVar2(interp, objv[1], NULL, TCL_LEAVE_ERR_MSG);
	if (varValueObj == NULL) {
	    return TCL_ERROR;
	}
	Tcl_SetObjResult(interp, varValueObj);
	return TCL_OK;
    } else if (objc == 3) {

	varValueObj = Tcl_ObjSetVar2(interp, objv[1], NULL, objv[2],
		TCL_LEAVE_ERR_MSG);
	if (varValueObj == NULL) {
	    return TCL_ERROR;
	}
	Tcl_SetObjResult(interp, varValueObj);
	return TCL_OK;
    } else {
	Tcl_WrongNumArgs(interp, 1, objv, "varName ?newValue?");
	return TCL_ERROR;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_SetVar --
 *
 *	Change the value of a variable.
 *
 * Results:
 *	Returns a pointer to the malloc'ed string which is the character
 *	representation of the variable's new value. The caller must not
 *	modify this string. If the write operation was disallowed then NULL
 *	is returned; if the TCL_LEAVE_ERR_MSG flag is set, then an
 *	explanatory message will be left in the interp's result. Note that the
 *	returned string may not be the same as newValue; this is because
 *	variable traces may modify the variable's value.
 *
 * Side effects:
 *	If varName is defined as a local or global variable in interp,
 *	its value is changed to newValue. If varName isn't currently
 *	defined, then a new global variable by that name is created.
 *
 *----------------------------------------------------------------------
 */

CONST char *
Tcl_SetVar(interp, varName, newValue, flags)
    Tcl_Interp *interp;		/* Command interpreter in which varName is
				 * to be looked up. */
    CONST char *varName;	/* Name of a variable in interp. */
    CONST char *newValue;	/* New value for varName. */
    int flags;			/* Various flags that tell how to set value:
				 * any of TCL_GLOBAL_ONLY,
				 * TCL_NAMESPACE_ONLY, TCL_APPEND_VALUE,
				 * TCL_LIST_ELEMENT, TCL_LEAVE_ERR_MSG. */
{
    return Tcl_SetVar2(interp, varName, (char *) NULL, newValue, flags);
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_SetVar2 --
 *
 *      Given a two-part variable name, which may refer either to a
 *      scalar variable or an element of an array, change the value
 *      of the variable.  If the named scalar or array or element
 *      doesn't exist then create one.
 *
 * Results:
 *	Returns a pointer to the malloc'ed string which is the character
 *	representation of the variable's new value. The caller must not
 *	modify this string. If the write operation was disallowed because an
 *	array was expected but not found (or vice versa), then NULL is
 *	returned; if the TCL_LEAVE_ERR_MSG flag is set, then an explanatory
 *	message will be left in the interp's result. Note that the returned
 *	string may not be the same as newValue; this is because variable
 *	traces may modify the variable's value.
 *
 * Side effects:
 *      The value of the given variable is set. If either the array
 *      or the entry didn't exist then a new one is created.
 *
 *----------------------------------------------------------------------
 */

CONST char *
Tcl_SetVar2(interp, part1, part2, newValue, flags)
    Tcl_Interp *interp;         /* Command interpreter in which variable is
                                 * to be looked up. */
    CONST char *part1;          /* If part2 is NULL, this is name of scalar
                                 * variable. Otherwise it is the name of
                                 * an array. */
    CONST char *part2;		/* Name of an element within an array, or
				 * NULL. */
    CONST char *newValue;       /* New value for variable. */
    int flags;                  /* Various flags that tell how to set value:
				 * any of TCL_GLOBAL_ONLY,
				 * TCL_NAMESPACE_ONLY, TCL_APPEND_VALUE,
				 * TCL_LIST_ELEMENT, or TCL_LEAVE_ERR_MSG */
{
    register Tcl_Obj *valuePtr;
    Tcl_Obj *varValuePtr;

    /*
     * Create an object holding the variable's new value and use
     * Tcl_SetVar2Ex to actually set the variable.
     */

    valuePtr = Tcl_NewStringObj(newValue, -1);
    Tcl_IncrRefCount(valuePtr);

    varValuePtr = Tcl_SetVar2Ex(interp, part1, part2, valuePtr, flags);
    Tcl_DecrRefCount(valuePtr); /* done with the object */
    
    if (varValuePtr == NULL) {
	return NULL;
    }
    return TclGetString(varValuePtr);
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_SetVar2Ex --
 *
 *	Given a two-part variable name, which may refer either to a scalar
 *	variable or an element of an array, change the value of the variable
 *	to a new Tcl object value. If the named scalar or array or element
 *	doesn't exist then create one.
 *
 * Results:
 *	Returns a pointer to the Tcl_Obj holding the new value of the
 *	variable. If the write operation was disallowed because an array was
 *	expected but not found (or vice versa), then NULL is returned; if
 *	the TCL_LEAVE_ERR_MSG flag is set, then an explanatory message will
 *	be left in the interpreter's result. Note that the returned object
 *	may not be the same one referenced by newValuePtr; this is because
 *	variable traces may modify the variable's value.
 *
 * Side effects:
 *	The value of the given variable is set. If either the array or the
 *	entry didn't exist then a new variable is created.
 *
 *	The reference count is decremented for any old value of the variable
 *	and incremented for its new value. If the new value for the variable
 *	is not the same one referenced by newValuePtr (perhaps as a result
 *	of a variable trace), then newValuePtr's ref count is left unchanged
 *	by Tcl_SetVar2Ex. newValuePtr's ref count is also left unchanged if
 *	we are appending it as a string value: that is, if "flags" includes
 *	TCL_APPEND_VALUE but not TCL_LIST_ELEMENT.
 *
 *	The reference count for the returned object is _not_ incremented: if
 *	you want to keep a reference to the object you must increment its
 *	ref count yourself.
 *
 *----------------------------------------------------------------------
 */

Tcl_Obj *
Tcl_SetVar2Ex(interp, part1, part2, newValuePtr, flags)
    Tcl_Interp *interp;		/* Command interpreter in which variable is
				 * to be found. */
    CONST char *part1;		/* Name of an array (if part2 is non-NULL)
				 * or the name of a variable. */
    CONST char *part2;		/* If non-NULL, gives the name of an element
				 * in the array part1. */
    Tcl_Obj *newValuePtr;	/* New value for variable. */
    int flags;			/* Various flags that tell how to set value:
				 * any of TCL_GLOBAL_ONLY,
				 * TCL_NAMESPACE_ONLY, TCL_APPEND_VALUE,
				 * TCL_LIST_ELEMENT or TCL_LEAVE_ERR_MSG. */
{
    Var *varPtr, *arrayPtr;

    varPtr = TclLookupVar(interp, part1, part2, flags, "set",
	    /*createPart1*/ 1, /*createPart2*/ 1, &arrayPtr);
    if (varPtr == NULL) {
	return NULL;
    }

    return TclPtrSetVar(interp, varPtr, arrayPtr, part1, part2, 
            newValuePtr, flags);
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_ObjSetVar2 --
 *
 *	This function is the same as Tcl_SetVar2Ex above, except the
 *	variable names are passed in Tcl object instead of strings.
 *
 * Results:
 *	Returns a pointer to the Tcl_Obj holding the new value of the
 *	variable. If the write operation was disallowed because an array was
 *	expected but not found (or vice versa), then NULL is returned; if
 *	the TCL_LEAVE_ERR_MSG flag is set, then an explanatory message will
 *	be left in the interpreter's result. Note that the returned object
 *	may not be the same one referenced by newValuePtr; this is because
 *	variable traces may modify the variable's value.
 *
 * Side effects:
 *	The value of the given variable is set. If either the array or the
 *	entry didn't exist then a new variable is created.
 *
 *----------------------------------------------------------------------
 */

Tcl_Obj *
Tcl_ObjSetVar2(interp, part1Ptr, part2Ptr, newValuePtr, flags)
    Tcl_Interp *interp;		/* Command interpreter in which variable is
				 * to be found. */
    register Tcl_Obj *part1Ptr;	/* Points to an object holding the name of
				 * an array (if part2 is non-NULL) or the
				 * name of a variable. */
    register Tcl_Obj *part2Ptr;	/* If non-null, points to an object holding
				 * the name of an element in the array
				 * part1Ptr. */
    Tcl_Obj *newValuePtr;	/* New value for variable. */
    int flags;			/* Various flags that tell how to set value:
				 * any of TCL_GLOBAL_ONLY,
				 * TCL_NAMESPACE_ONLY, TCL_APPEND_VALUE,
				 * TCL_LIST_ELEMENT, or TCL_LEAVE_ERR_MSG. */
{
    Var *varPtr, *arrayPtr;
    char *part1, *part2;

    part1 = TclGetString(part1Ptr);
    part2 = ((part2Ptr == NULL) ? NULL : Tcl_GetString(part2Ptr));    

    varPtr = TclObjLookupVar(interp, part1Ptr, part2, flags, "set",
	    /*createPart1*/ 1, /*createPart2*/ 1, &arrayPtr);
    if (varPtr == NULL) {
	return NULL;
    }

    return TclPtrSetVar(interp, varPtr, arrayPtr, part1, part2, 
            newValuePtr, flags);
}


/*
 *----------------------------------------------------------------------
 *
 * TclPtrSetVar --
 *
 *	This function is the same as Tcl_SetVar2Ex above, except that
 *      it requires pointers to the variable's Var structs in addition
 *	to the variable names.
 *
 * Results:
 *	Returns a pointer to the Tcl_Obj holding the new value of the
 *	variable. If the write operation was disallowed because an array was
 *	expected but not found (or vice versa), then NULL is returned; if
 *	the TCL_LEAVE_ERR_MSG flag is set, then an explanatory message will
 *	be left in the interpreter's result. Note that the returned object
 *	may not be the same one referenced by newValuePtr; this is because
 *	variable traces may modify the variable's value.
 *
 * Side effects:
 *	The value of the given variable is set. If either the array or the
 *	entry didn't exist then a new variable is created.

 *
 *----------------------------------------------------------------------
 */

Tcl_Obj *
TclPtrSetVar(interp, varPtr, arrayPtr, part1, part2, newValuePtr, flags)
    Tcl_Interp *interp;		/* Command interpreter in which variable is
				 * to be looked up. */
    register Var *varPtr;
    Var *arrayPtr;
    CONST char *part1;		/* Name of an array (if part2 is non-NULL)
				 * or the name of a variable. */
    CONST char *part2;		/* If non-NULL, gives the name of an element
				 * in the array part1. */
    Tcl_Obj *newValuePtr;	/* New value for variable. */
    CONST int flags;			/* OR-ed combination of TCL_GLOBAL_ONLY,
				 * and TCL_LEAVE_ERR_MSG bits. */
{
    Interp *iPtr = (Interp *) interp;
    Tcl_Obj *oldValuePtr;
    Tcl_Obj *resultPtr = NULL;
    int result;

    /*
     * If the variable is in a hashtable and its hPtr field is NULL, then we
     * may have an upvar to an array element where the array was deleted
     * or an upvar to a namespace variable whose namespace was deleted.
     * Generate an error (allowing the variable to be reset would screw up
     * our storage allocation and is meaningless anyway).
     */

    if ((varPtr->flags & VAR_IN_HASHTABLE) && (varPtr->hPtr == NULL)) {
	if (flags & TCL_LEAVE_ERR_MSG) {
	    if (TclIsVarArrayElement(varPtr)) {
		VarErrMsg(interp, part1, part2, "set", danglingElement);
	    } else {
		VarErrMsg(interp, part1, part2, "set", danglingVar);
	    }
	}
	return NULL;
    }

    /*
     * It's an error to try to set an array variable itself.
     */

    if (TclIsVarArray(varPtr) && !TclIsVarUndefined(varPtr)) {
	if (flags & TCL_LEAVE_ERR_MSG) {
	    VarErrMsg(interp, part1, part2, "set", isArray);
	}
	return NULL;
    }

    /*
     * Invoke any read traces that have been set for the variable if it
     * is requested; this is only done in the core when lappending.
     */

    if ((flags & TCL_TRACE_READS) && ((varPtr->tracePtr != NULL) 
	    || ((arrayPtr != NULL) && (arrayPtr->tracePtr != NULL)))) {
	if (TCL_ERROR == CallVarTraces(iPtr, arrayPtr, varPtr, part1, part2,
		TCL_TRACE_READS, (flags & TCL_LEAVE_ERR_MSG))) {
	    return NULL;
	}
    }

    /*
     * Set the variable's new value. If appending, append the new value to
     * the variable, either as a list element or as a string. Also, if
     * appending, then if the variable's old value is unshared we can modify
     * it directly, otherwise we must create a new copy to modify: this is
     * "copy on write".
     */

    oldValuePtr = varPtr->value.objPtr;
    if (flags & TCL_APPEND_VALUE) {
	if (TclIsVarUndefined(varPtr) && (oldValuePtr != NULL)) {
	    Tcl_DecrRefCount(oldValuePtr);     /* discard old value */
	    varPtr->value.objPtr = NULL;
	    oldValuePtr = NULL;
	}
	if (flags & TCL_LIST_ELEMENT) {	       /* append list element */
	    if (oldValuePtr == NULL) {
		TclNewObj(oldValuePtr);
		varPtr->value.objPtr = oldValuePtr;
		Tcl_IncrRefCount(oldValuePtr); /* since var is referenced */
	    } else if (Tcl_IsShared(oldValuePtr)) {
		varPtr->value.objPtr = Tcl_DuplicateObj(oldValuePtr);
		Tcl_DecrRefCount(oldValuePtr);
		oldValuePtr = varPtr->value.objPtr;
		Tcl_IncrRefCount(oldValuePtr); /* since var is referenced */
	    }
	    result = Tcl_ListObjAppendElement(interp, oldValuePtr,
		    newValuePtr);
	    if (result != TCL_OK) {
		return NULL;
	    }
	} else {		               /* append string */
	    /*
	     * We append newValuePtr's bytes but don't change its ref count.
	     */

	    if (oldValuePtr == NULL) {
		varPtr->value.objPtr = newValuePtr;
		Tcl_IncrRefCount(newValuePtr);
	    } else {
		if (Tcl_IsShared(oldValuePtr)) {   /* append to copy */
		    varPtr->value.objPtr = Tcl_DuplicateObj(oldValuePtr);
		    TclDecrRefCount(oldValuePtr);
		    oldValuePtr = varPtr->value.objPtr;
		    Tcl_IncrRefCount(oldValuePtr); /* since var is ref */
		}
		Tcl_AppendObjToObj(oldValuePtr, newValuePtr);
	    }
	}
    } else if (newValuePtr != oldValuePtr) {
	/*
	 * In this case we are replacing the value, so we don't need to
	 * do more than swap the objects.
	 */

	varPtr->value.objPtr = newValuePtr;
	Tcl_IncrRefCount(newValuePtr);      /* var is another ref */
	if (oldValuePtr != NULL) {
	    TclDecrRefCount(oldValuePtr);   /* discard old value */
	}
    }
    TclSetVarScalar(varPtr);
    TclClearVarUndefined(varPtr);
    if (arrayPtr != NULL) {
	TclClearVarUndefined(arrayPtr);
    }

    /*
     * Invoke any write traces for the variable.
     */

    if ((varPtr->tracePtr != NULL)
	    || ((arrayPtr != NULL) && (arrayPtr->tracePtr != NULL))) {
	if (TCL_ERROR == CallVarTraces(iPtr, arrayPtr, varPtr, part1, part2,
	        (flags & (TCL_GLOBAL_ONLY|TCL_NAMESPACE_ONLY))
		| TCL_TRACE_WRITES, (flags & TCL_LEAVE_ERR_MSG))) {
	    goto cleanup;
	}
    }

    /*
     * Return the variable's value unless the variable was changed in some
     * gross way by a trace (e.g. it was unset and then recreated as an
     * array). 
     */

    if (TclIsVarScalar(varPtr) && !TclIsVarUndefined(varPtr)) {
	return varPtr->value.objPtr;
    }

    /*
     * A trace changed the value in some gross way. Return an empty string
     * object.
     */
    
    resultPtr = iPtr->emptyObjPtr;

    /*
     * If the variable doesn't exist anymore and no-one's using it, then
     * free up the relevant structures and hash table entries.
     */

    cleanup:
    if (TclIsVarUndefined(varPtr)) {
	CleanupVar(varPtr, arrayPtr);
    }
    return resultPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * TclIncrVar2 --
 *
 *	Given a two-part variable name, which may refer either to a scalar
 *	variable or an element of an array, increment the Tcl object value
 *	of the variable by a specified amount.
 *
 * Results:
 *	Returns a pointer to the Tcl_Obj holding the new value of the
 *	variable. If the specified variable doesn't exist, or there is a
 *	clash in array usage, or an error occurs while executing variable
 *	traces, then NULL is returned and a message will be left in
 *	the interpreter's result.
 *
 * Side effects:
 *	The value of the given variable is incremented by the specified
 *	amount. If either the array or the entry didn't exist then a new
 *	variable is created. The ref count for the returned object is _not_
 *	incremented to reflect the returned reference; if you want to keep a
 *	reference to the object you must increment its ref count yourself.
 *
 *----------------------------------------------------------------------
 */

Tcl_Obj *
TclIncrVar2(interp, part1Ptr, part2Ptr, incrAmount, flags)
    Tcl_Interp *interp;		/* Command interpreter in which variable is
				 * to be found. */
    Tcl_Obj *part1Ptr;		/* Points to an object holding the name of
				 * an array (if part2 is non-NULL) or the
				 * name of a variable. */
    Tcl_Obj *part2Ptr;		/* If non-null, points to an object holding
				 * the name of an element in the array
				 * part1Ptr. */
    long incrAmount;		/* Amount to be added to variable. */
    int flags;                  /* Various flags that tell how to incr value:
				 * any of TCL_GLOBAL_ONLY,
				 * TCL_NAMESPACE_ONLY, TCL_APPEND_VALUE,
				 * TCL_LIST_ELEMENT, TCL_LEAVE_ERR_MSG. */
{
    Var *varPtr, *arrayPtr;
    char *part1, *part2;

    part1 = TclGetString(part1Ptr);
    part2 = ((part2Ptr == NULL)? NULL : TclGetString(part2Ptr));

    varPtr = TclObjLookupVar(interp, part1Ptr, part2, flags, "read",
	    0, 1, &arrayPtr);
    if (varPtr == NULL) {
	Tcl_AddObjErrorInfo(interp,
		"\n    (reading value of variable to increment)", -1);
	return NULL;
    }
    return TclPtrIncrVar(interp, varPtr, arrayPtr, part1, part2,
	    incrAmount, flags);
}

/*
 *----------------------------------------------------------------------
 *
 * TclPtrIncrVar --
 *
 *	Given the pointers to a variable and possible containing array, 
 *      increment the Tcl object value of the variable by a specified 
 *      amount.
 *
 * Results:
 *	Returns a pointer to the Tcl_Obj holding the new value of the
 *	variable. If the specified variable doesn't exist, or there is a
 *	clash in array usage, or an error occurs while executing variable
 *	traces, then NULL is returned and a message will be left in
 *	the interpreter's result.
 *
 * Side effects:
 *	The value of the given variable is incremented by the specified
 *	amount. If either the array or the entry didn't exist then a new
 *	variable is created. The ref count for the returned object is _not_
 *	incremented to reflect the returned reference; if you want to keep a
 *	reference to the object you must increment its ref count yourself.
 *
 *----------------------------------------------------------------------
 */

Tcl_Obj *
TclPtrIncrVar(interp, varPtr, arrayPtr, part1, part2, incrAmount, flags)
    Tcl_Interp *interp;		/* Command interpreter in which variable is
				 * to be found. */
    Var *varPtr;
    Var *arrayPtr;
    CONST char *part1;		/* Points to an object holding the name of
				 * an array (if part2 is non-NULL) or the
				 * name of a variable. */
    CONST char *part2;		/* If non-null, points to an object holding
				 * the name of an element in the array
				 * part1Ptr. */
    CONST long incrAmount;	/* Amount to be added to variable. */
    CONST int flags;            /* Various flags that tell how to incr value:
				 * any of TCL_GLOBAL_ONLY,
				 * TCL_NAMESPACE_ONLY, TCL_APPEND_VALUE,
				 * TCL_LIST_ELEMENT, TCL_LEAVE_ERR_MSG. */
{
    register Tcl_Obj *varValuePtr;
    int createdNewObj;		/* Set 1 if var's value object is shared
				 * so we must increment a copy (i.e. copy
				 * on write). */
    long i;

    varValuePtr = TclPtrGetVar(interp, varPtr, arrayPtr, part1, part2, flags);

    if (varValuePtr == NULL) {
	Tcl_AddObjErrorInfo(interp,
		"\n    (reading value of variable to increment)", -1);
	return NULL;
    }

    /*
     * Increment the variable's value. If the object is unshared we can
     * modify it directly, otherwise we must create a new copy to modify:
     * this is "copy on write". Then free the variable's old string
     * representation, if any, since it will no longer be valid.
     */

    createdNewObj = 0;
    if (Tcl_IsShared(varValuePtr)) {
	varValuePtr = Tcl_DuplicateObj(varValuePtr);
	createdNewObj = 1;
    }
#ifdef TCL_WIDE_INT_IS_LONG
    if (Tcl_GetLongFromObj(interp, varValuePtr, &i) != TCL_OK) {
	if (createdNewObj) {
	    Tcl_DecrRefCount(varValuePtr); /* free unneeded copy */
	}
	return NULL;
    }
    Tcl_SetLongObj(varValuePtr, (i + incrAmount));
#else
    if (varValuePtr->typePtr == &tclWideIntType) {
	Tcl_WideInt wide = varValuePtr->internalRep.wideValue;
	Tcl_SetWideIntObj(varValuePtr, wide + Tcl_LongAsWide(incrAmount));
    } else if (varValuePtr->typePtr == &tclIntType) {
	i = varValuePtr->internalRep.longValue;
	Tcl_SetIntObj(varValuePtr, i + incrAmount);
    } else {
	/*
	 * Not an integer or wide internal-rep...
	 */
	Tcl_WideInt wide;
	if (Tcl_GetWideIntFromObj(interp, varValuePtr, &wide) != TCL_OK) {
	    if (createdNewObj) {
		Tcl_DecrRefCount(varValuePtr); /* free unneeded copy */
	    }
	    return NULL;
	}
	if (wide <= Tcl_LongAsWide(LONG_MAX)
		&& wide >= Tcl_LongAsWide(LONG_MIN)) {
	    Tcl_SetLongObj(varValuePtr, Tcl_WideAsLong(wide) + incrAmount);
	} else {
	    Tcl_SetWideIntObj(varValuePtr, wide + Tcl_LongAsWide(incrAmount));
	}
    }
#endif

    /*
     * Store the variable's new value and run any write traces.
     */
    
    return TclPtrSetVar(interp, varPtr, arrayPtr, part1, part2,
	    varValuePtr, flags);
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_UnsetVar --
 *
 *	Delete a variable, so that it may not be accessed anymore.
 *
 * Results:
 *	Returns TCL_OK if the variable was successfully deleted, TCL_ERROR
 *	if the variable can't be unset.  In the event of an error,
 *	if the TCL_LEAVE_ERR_MSG flag is set then an error message
 *	is left in the interp's result.
 *
 * Side effects:
 *	If varName is defined as a local or global variable in interp,
 *	it is deleted.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_UnsetVar(interp, varName, flags)
    Tcl_Interp *interp;		/* Command interpreter in which varName is
				 * to be looked up. */
    CONST char *varName;	/* Name of a variable in interp.  May be
				 * either a scalar name or an array name
				 * or an element in an array. */
    int flags;			/* OR-ed combination of any of
				 * TCL_GLOBAL_ONLY, TCL_NAMESPACE_ONLY or
				 * TCL_LEAVE_ERR_MSG. */
{
    return Tcl_UnsetVar2(interp, varName, (char *) NULL, flags);
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_UnsetVar2 --
 *
 *	Delete a variable, given a 2-part name.
 *
 * Results:
 *	Returns TCL_OK if the variable was successfully deleted, TCL_ERROR
 *	if the variable can't be unset.  In the event of an error,
 *	if the TCL_LEAVE_ERR_MSG flag is set then an error message
 *	is left in the interp's result.
 *
 * Side effects:
 *	If part1 and part2 indicate a local or global variable in interp,
 *	it is deleted.  If part1 is an array name and part2 is NULL, then
 *	the whole array is deleted.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_UnsetVar2(interp, part1, part2, flags)
    Tcl_Interp *interp;		/* Command interpreter in which varName is
				 * to be looked up. */
    CONST char *part1;		/* Name of variable or array. */
    CONST char *part2;		/* Name of element within array or NULL. */
    int flags;			/* OR-ed combination of any of
				 * TCL_GLOBAL_ONLY, TCL_NAMESPACE_ONLY,
				 * TCL_LEAVE_ERR_MSG. */
{
    int result;
    Tcl_Obj *part1Ptr;

    part1Ptr = Tcl_NewStringObj(part1, -1);
    Tcl_IncrRefCount(part1Ptr);
    result = TclObjUnsetVar2(interp, part1Ptr, part2, flags);
    TclDecrRefCount(part1Ptr);

    return result;
}


/*
 *----------------------------------------------------------------------
 *
 * TclObjUnsetVar2 --
 *
 *	Delete a variable, given a 2-object name.
 *
 * Results:
 *	Returns TCL_OK if the variable was successfully deleted, TCL_ERROR
 *	if the variable can't be unset.  In the event of an error,
 *	if the TCL_LEAVE_ERR_MSG flag is set then an error message
 *	is left in the interp's result.
 *
 * Side effects:
 *	If part1ptr and part2Ptr indicate a local or global variable in interp,
 *	it is deleted.  If part1Ptr is an array name and part2Ptr is NULL, then
 *	the whole array is deleted.
 *
 *----------------------------------------------------------------------
 */

int
TclObjUnsetVar2(interp, part1Ptr, part2, flags)
    Tcl_Interp *interp;		/* Command interpreter in which varName is
				 * to be looked up. */
    Tcl_Obj *part1Ptr;		/* Name of variable or array. */
    CONST char *part2;		/* Name of element within array or NULL. */
    int flags;			/* OR-ed combination of any of
				 * TCL_GLOBAL_ONLY, TCL_NAMESPACE_ONLY,
				 * TCL_LEAVE_ERR_MSG. */
{
    Var dummyVar;
    Var *varPtr, *dummyVarPtr;
    Interp *iPtr = (Interp *) interp;
    Var *arrayPtr;
    ActiveVarTrace *activePtr;
    Tcl_Obj *objPtr;
    int result;
    char *part1;

    part1 = TclGetString(part1Ptr);
    varPtr = TclObjLookupVar(interp, part1Ptr, part2, flags, "unset",
	    /*createPart1*/ 0, /*createPart2*/ 0, &arrayPtr);
    if (varPtr == NULL) {
	return TCL_ERROR;
    }
 
    result = (TclIsVarUndefined(varPtr)? TCL_ERROR : TCL_OK);

    if ((arrayPtr != NULL) && (arrayPtr->searchPtr != NULL)) {
	DeleteSearches(arrayPtr);
    }

    /*
     * The code below is tricky, because of the possibility that
     * a trace procedure might try to access a variable being
     * deleted. To handle this situation gracefully, do things
     * in three steps:
     * 1. Copy the contents of the variable to a dummy variable
     *    structure, and mark the original Var structure as undefined.
     * 2. Invoke traces and clean up the variable, using the dummy copy.
     * 3. If at the end of this the original variable is still
     *    undefined and has no outstanding references, then delete
     *	  it (but it could have gotten recreated by a trace).
     */

    dummyVar = *varPtr;
    TclSetVarUndefined(varPtr);
    TclSetVarScalar(varPtr);
    varPtr->value.objPtr = NULL; /* dummyVar points to any value object */
    varPtr->tracePtr = NULL;
    varPtr->searchPtr = NULL;

    /*
     * Call trace procedures for the variable being deleted. Then delete
     * its traces. Be sure to abort any other traces for the variable
     * that are still pending. Special tricks:
     * 1. We need to increment varPtr's refCount around this: CallVarTraces
     *    will use dummyVar so it won't increment varPtr's refCount itself.
     * 2. Turn off the VAR_TRACE_ACTIVE flag in dummyVar: we want to
     *    call unset traces even if other traces are pending.
     */

    if ((dummyVar.tracePtr != NULL)
	    || ((arrayPtr != NULL) && (arrayPtr->tracePtr != NULL))) {
	varPtr->refCount++;
	dummyVar.flags &= ~VAR_TRACE_ACTIVE;
	CallVarTraces(iPtr, arrayPtr, &dummyVar, part1, part2,
		(flags & (TCL_GLOBAL_ONLY|TCL_NAMESPACE_ONLY))
		| TCL_TRACE_UNSETS, /* leaveErrMsg */ 0);
	while (dummyVar.tracePtr != NULL) {
	    VarTrace *tracePtr = dummyVar.tracePtr;
	    dummyVar.tracePtr = tracePtr->nextPtr;
	    Tcl_EventuallyFree((ClientData) tracePtr, TCL_DYNAMIC);
	}
	for (activePtr = iPtr->activeVarTracePtr;  activePtr != NULL;
	     activePtr = activePtr->nextPtr) {
	    if (activePtr->varPtr == varPtr) {
		activePtr->nextTracePtr = NULL;
	    }
	}
	varPtr->refCount--;
    }

    /*
     * If the variable is an array, delete all of its elements. This must be
     * done after calling the traces on the array, above (that's the way
     * traces are defined). If it is a scalar, "discard" its object
     * (decrement the ref count of its object, if any).
     */

    dummyVarPtr = &dummyVar;
    if (TclIsVarArray(dummyVarPtr) && !TclIsVarUndefined(dummyVarPtr)) {
	/*
	 * Deleting the elements of the array may cause traces to be fired
	 * on those elements.  Before deleting them, bump the reference count
	 * of the array, so that if those trace procs make a global or upvar
	 * link to the array, the array is not deleted when the call stack
	 * gets popped (we will delete the array ourselves later in this
	 * function).
	 *
	 * Bumping the count can lead to the odd situation that elements of the
	 * array are being deleted when the array still exists, but since the
	 * array is about to be removed anyway, that shouldn't really matter.
	 */
	varPtr->refCount++;
	DeleteArray(iPtr, part1, dummyVarPtr,
		(flags & (TCL_GLOBAL_ONLY|TCL_NAMESPACE_ONLY)) 
		| TCL_TRACE_UNSETS);
	/* Decr ref count */
	varPtr->refCount--;
    }
    if (TclIsVarScalar(dummyVarPtr)
	    && (dummyVarPtr->value.objPtr != NULL)) {
	objPtr = dummyVarPtr->value.objPtr;
	TclDecrRefCount(objPtr);
	dummyVarPtr->value.objPtr = NULL;
    }

    /*
     * If the variable was a namespace variable, decrement its reference count.
     */
    
    if (varPtr->flags & VAR_NAMESPACE_VAR) {
	varPtr->flags &= ~VAR_NAMESPACE_VAR;
	varPtr->refCount--;
    }

    /*
     * It's an error to unset an undefined variable.
     */
	
    if (result != TCL_OK) {
	if (flags & TCL_LEAVE_ERR_MSG) {
	    VarErrMsg(interp, part1, part2, "unset", 
		    ((arrayPtr == NULL) ? noSuchVar : noSuchElement));
	}
    }

    /*
     * Finally, if the variable is truly not in use then free up its Var
     * structure and remove it from its hash table, if any. The ref count of
     * its value object, if any, was decremented above.
     */

    CleanupVar(varPtr, arrayPtr);
    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_TraceVar --
 *
 *	Arrange for reads and/or writes to a variable to cause a
 *	procedure to be invoked, which can monitor the operations
 *	and/or change their actions.
 *
 * Results:
 *	A standard Tcl return value.
 *
 * Side effects:
 *	A trace is set up on the variable given by varName, such that
 *	future references to the variable will be intermediated by
 *	proc.  See the manual entry for complete details on the calling
 *	sequence for proc.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_TraceVar(interp, varName, flags, proc, clientData)
    Tcl_Interp *interp;		/* Interpreter in which variable is
				 * to be traced. */
    CONST char *varName;	/* Name of variable;  may end with "(index)"
				 * to signify an array reference. */
    int flags;			/* OR-ed collection of bits, including any
				 * of TCL_TRACE_READS, TCL_TRACE_WRITES,
				 * TCL_TRACE_UNSETS, TCL_GLOBAL_ONLY, and
				 * TCL_NAMESPACE_ONLY. */
    Tcl_VarTraceProc *proc;	/* Procedure to call when specified ops are
				 * invoked upon varName. */
    ClientData clientData;	/* Arbitrary argument to pass to proc. */
{
    return Tcl_TraceVar2(interp, varName, (char *) NULL, 
	    flags, proc, clientData);
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_TraceVar2 --
 *
 *	Arrange for reads and/or writes to a variable to cause a
 *	procedure to be invoked, which can monitor the operations
 *	and/or change their actions.
 *
 * Results:
 *	A standard Tcl return value.
 *
 * Side effects:
 *	A trace is set up on the variable given by part1 and part2, such
 *	that future references to the variable will be intermediated by
 *	proc.  See the manual entry for complete details on the calling
 *	sequence for proc.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_TraceVar2(interp, part1, part2, flags, proc, clientData)
    Tcl_Interp *interp;		/* Interpreter in which variable is
				 * to be traced. */
    CONST char *part1;		/* Name of scalar variable or array. */
    CONST char *part2;		/* Name of element within array;  NULL means
				 * trace applies to scalar variable or array
				 * as-a-whole. */
    int flags;			/* OR-ed collection of bits, including any
				 * of TCL_TRACE_READS, TCL_TRACE_WRITES,
				 * TCL_TRACE_UNSETS, TCL_GLOBAL_ONLY,
				 * and TCL_NAMESPACE_ONLY. */
    Tcl_VarTraceProc *proc;	/* Procedure to call when specified ops are
				 * invoked upon varName. */
    ClientData clientData;	/* Arbitrary argument to pass to proc. */
{
    Var *varPtr, *arrayPtr;
    register VarTrace *tracePtr;
    int flagMask;
    
    /* 
     * We strip 'flags' down to just the parts which are relevant to
     * TclLookupVar, to avoid conflicts between trace flags and
     * internal namespace flags such as 'FIND_ONLY_NS'.  This can
     * now occur since we have trace flags with values 0x1000 and higher.
     */
    flagMask = TCL_GLOBAL_ONLY | TCL_NAMESPACE_ONLY;
    varPtr = TclLookupVar(interp, part1, part2,
	    (flags & flagMask) | TCL_LEAVE_ERR_MSG,
	    "trace", /*createPart1*/ 1, /*createPart2*/ 1, &arrayPtr);
    if (varPtr == NULL) {
	return TCL_ERROR;
    }

    /*
     * Check for a nonsense flag combination.  Note that this is a
     * panic() because there should be no code path that ever sets
     * both flags.
     */
    if ((flags&TCL_TRACE_RESULT_DYNAMIC) && (flags&TCL_TRACE_RESULT_OBJECT)) {
	panic("bad result flag combination");
    }

    /*
     * Set up trace information.
     */

    flagMask = TCL_TRACE_READS | TCL_TRACE_WRITES | TCL_TRACE_UNSETS | 
	TCL_TRACE_ARRAY | TCL_TRACE_RESULT_DYNAMIC | TCL_TRACE_RESULT_OBJECT;
#ifndef TCL_REMOVE_OBSOLETE_TRACES
    flagMask |= TCL_TRACE_OLD_STYLE;
#endif
    tracePtr = (VarTrace *) ckalloc(sizeof(VarTrace));
    tracePtr->traceProc		= proc;
    tracePtr->clientData	= clientData;
    tracePtr->flags		= flags & flagMask;
    tracePtr->nextPtr		= varPtr->tracePtr;
    varPtr->tracePtr		= tracePtr;
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_UntraceVar --
 *
 *	Remove a previously-created trace for a variable.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	If there exists a trace for the variable given by varName
 *	with the given flags, proc, and clientData, then that trace
 *	is removed.
 *
 *----------------------------------------------------------------------
 */

void
Tcl_UntraceVar(interp, varName, flags, proc, clientData)
    Tcl_Interp *interp;		/* Interpreter containing variable. */
    CONST char *varName;	/* Name of variable; may end with "(index)"
				 * to signify an array reference. */
    int flags;			/* OR-ed collection of bits describing
				 * current trace, including any of
				 * TCL_TRACE_READS, TCL_TRACE_WRITES,
				 * TCL_TRACE_UNSETS, TCL_GLOBAL_ONLY
				 * and TCL_NAMESPACE_ONLY. */
    Tcl_VarTraceProc *proc;	/* Procedure assocated with trace. */
    ClientData clientData;	/* Arbitrary argument to pass to proc. */
{
    Tcl_UntraceVar2(interp, varName, (char *) NULL, flags, proc, clientData);
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_UntraceVar2 --
 *
 *	Remove a previously-created trace for a variable.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	If there exists a trace for the variable given by part1
 *	and part2 with the given flags, proc, and clientData, then
 *	that trace is removed.
 *
 *----------------------------------------------------------------------
 */

void
Tcl_UntraceVar2(interp, part1, part2, flags, proc, clientData)
    Tcl_Interp *interp;		/* Interpreter containing variable. */
    CONST char *part1;		/* Name of variable or array. */
    CONST char *part2;		/* Name of element within array;  NULL means
				 * trace applies to scalar variable or array
				 * as-a-whole. */
    int flags;			/* OR-ed collection of bits describing
				 * current trace, including any of
				 * TCL_TRACE_READS, TCL_TRACE_WRITES,
				 * TCL_TRACE_UNSETS, TCL_GLOBAL_ONLY,
				 * and TCL_NAMESPACE_ONLY. */
    Tcl_VarTraceProc *proc;	/* Procedure assocated with trace. */
    ClientData clientData;	/* Arbitrary argument to pass to proc. */
{
    register VarTrace *tracePtr;
    VarTrace *prevPtr;
    Var *varPtr, *arrayPtr;
    Interp *iPtr = (Interp *) interp;
    ActiveVarTrace *activePtr;
    int flagMask;
    
    /*
     * Set up a mask to mask out the parts of the flags that we are not
     * interested in now.
     */
    flagMask = TCL_GLOBAL_ONLY | TCL_NAMESPACE_ONLY;
    varPtr = TclLookupVar(interp, part1, part2, flags & flagMask,
	    /*msg*/ (char *) NULL,
	    /*createPart1*/ 0, /*createPart2*/ 0, &arrayPtr);
    if (varPtr == NULL) {
	return;
    }


    /*
     * Set up a mask to mask out the parts of the flags that we are not
     * interested in now.
     */
    flagMask = TCL_TRACE_READS | TCL_TRACE_WRITES | TCL_TRACE_UNSETS |
	TCL_TRACE_ARRAY | TCL_TRACE_RESULT_DYNAMIC | TCL_TRACE_RESULT_OBJECT; 
#ifndef TCL_REMOVE_OBSOLETE_TRACES
    flagMask |= TCL_TRACE_OLD_STYLE;
#endif
    flags &= flagMask;
    for (tracePtr = varPtr->tracePtr, prevPtr = NULL;  ;
	 prevPtr = tracePtr, tracePtr = tracePtr->nextPtr) {
	if (tracePtr == NULL) {
	    return;
	}
	if ((tracePtr->traceProc == proc) && (tracePtr->flags == flags)
		&& (tracePtr->clientData == clientData)) {
	    break;
	}
    }

    /*
     * The code below makes it possible to delete traces while traces
     * are active: it makes sure that the deleted trace won't be
     * processed by CallVarTraces.
     */

    for (activePtr = iPtr->activeVarTracePtr;  activePtr != NULL;
	 activePtr = activePtr->nextPtr) {
	if (activePtr->nextTracePtr == tracePtr) {
	    activePtr->nextTracePtr = tracePtr->nextPtr;
	}
    }
    if (prevPtr == NULL) {
	varPtr->tracePtr = tracePtr->nextPtr;
    } else {
	prevPtr->nextPtr = tracePtr->nextPtr;
    }
    Tcl_EventuallyFree((ClientData) tracePtr, TCL_DYNAMIC);

    /*
     * If this is the last trace on the variable, and the variable is
     * unset and unused, then free up the variable.
     */

    if (TclIsVarUndefined(varPtr)) {
	CleanupVar(varPtr, (Var *) NULL);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_VarTraceInfo --
 *
 *	Return the clientData value associated with a trace on a
 *	variable.  This procedure can also be used to step through
 *	all of the traces on a particular variable that have the
 *	same trace procedure.
 *
 * Results:
 *	The return value is the clientData value associated with
 *	a trace on the given variable.  Information will only be
 *	returned for a trace with proc as trace procedure.  If
 *	the clientData argument is NULL then the first such trace is
 *	returned;  otherwise, the next relevant one after the one
 *	given by clientData will be returned.  If the variable
 *	doesn't exist, or if there are no (more) traces for it,
 *	then NULL is returned.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

ClientData
Tcl_VarTraceInfo(interp, varName, flags, proc, prevClientData)
    Tcl_Interp *interp;		/* Interpreter containing variable. */
    CONST char *varName;	/* Name of variable;  may end with "(index)"
				 * to signify an array reference. */
    int flags;			/* OR-ed combo or TCL_GLOBAL_ONLY,
				 * TCL_NAMESPACE_ONLY (can be 0). */
    Tcl_VarTraceProc *proc;	/* Procedure assocated with trace. */
    ClientData prevClientData;	/* If non-NULL, gives last value returned
				 * by this procedure, so this call will
				 * return the next trace after that one.
				 * If NULL, this call will return the
				 * first trace. */
{
    return Tcl_VarTraceInfo2(interp, varName, (char *) NULL,
	    flags, proc, prevClientData);
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_VarTraceInfo2 --
 *
 *	Same as Tcl_VarTraceInfo, except takes name in two pieces
 *	instead of one.
 *
 * Results:
 *	Same as Tcl_VarTraceInfo.
 *
 * Side effects:
 *	None.
 *
 *----------------------------------------------------------------------
 */

ClientData
Tcl_VarTraceInfo2(interp, part1, part2, flags, proc, prevClientData)
    Tcl_Interp *interp;		/* Interpreter containing variable. */
    CONST char *part1;		/* Name of variable or array. */
    CONST char *part2;		/* Name of element within array;  NULL means
				 * trace applies to scalar variable or array
				 * as-a-whole. */
    int flags;			/* OR-ed combination of TCL_GLOBAL_ONLY,
				 * TCL_NAMESPACE_ONLY. */
    Tcl_VarTraceProc *proc;	/* Procedure assocated with trace. */
    ClientData prevClientData;	/* If non-NULL, gives last value returned
				 * by this procedure, so this call will
				 * return the next trace after that one.
				 * If NULL, this call will return the
				 * first trace. */
{
    register VarTrace *tracePtr;
    Var *varPtr, *arrayPtr;

    varPtr = TclLookupVar(interp, part1, part2,
	    flags & (TCL_GLOBAL_ONLY|TCL_NAMESPACE_ONLY),
	    /*msg*/ (char *) NULL,
	    /*createPart1*/ 0, /*createPart2*/ 0, &arrayPtr);
    if (varPtr == NULL) {
	return NULL;
    }

    /*
     * Find the relevant trace, if any, and return its clientData.
     */

    tracePtr = varPtr->tracePtr;
    if (prevClientData != NULL) {
	for ( ;  tracePtr != NULL;  tracePtr = tracePtr->nextPtr) {
	    if ((tracePtr->clientData == prevClientData)
		    && (tracePtr->traceProc == proc)) {
		tracePtr = tracePtr->nextPtr;
		break;
	    }
	}
    }
    for ( ;  tracePtr != NULL;  tracePtr = tracePtr->nextPtr) {
	if (tracePtr->traceProc == proc) {
	    return tracePtr->clientData;
	}
    }
    return NULL;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_UnsetObjCmd --
 *
 *	This object-based procedure is invoked to process the "unset" Tcl
 *	command. See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl object result value.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
int
Tcl_UnsetObjCmd(dummy, interp, objc, objv)
    ClientData dummy;		/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    register int i, flags = TCL_LEAVE_ERR_MSG;
    register char *name;

    if (objc < 1) {
	Tcl_WrongNumArgs(interp, 1, objv,
		"?-nocomplain? ?--? ?varName varName ...?");
	return TCL_ERROR;
    } else if (objc == 1) {
	/*
	 * Do nothing if no arguments supplied, so as to match
	 * command documentation.
	 */
	return TCL_OK;
    }

    /*
     * Simple, restrictive argument parsing.  The only options are --
     * and -nocomplain (which must come first and be given exactly to
     * be an option).
     */
    i = 1;
    name = TclGetString(objv[i]);
    if (name[0] == '-') {
 	if (strcmp("-nocomplain", name) == 0) {
	    i++;
 	    if (i == objc) {
		return TCL_OK;
	    }
 	    flags = 0;
 	    name = TclGetString(objv[i]);
 	}
 	if (strcmp("--", name) == 0) {
 	    i++;
 	}
    }

    for (; i < objc;  i++) {
	if ((TclObjUnsetVar2(interp, objv[i], NULL, flags) != TCL_OK)
		&& (flags == TCL_LEAVE_ERR_MSG)) {
	    return TCL_ERROR;
	}
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_AppendObjCmd --
 *
 *	This object-based procedure is invoked to process the "append" 
 *	Tcl command. See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl object result value.
 *
 * Side effects:
 *	A variable's value may be changed.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
int
Tcl_AppendObjCmd(dummy, interp, objc, objv)
    ClientData dummy;		/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    Var *varPtr, *arrayPtr;
    char *part1;

    register Tcl_Obj *varValuePtr = NULL;
    					/* Initialized to avoid compiler
				         * warning. */
    int i;

    if (objc < 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "varName ?value value ...?");
	return TCL_ERROR;
    }

    if (objc == 2) {
	varValuePtr = Tcl_ObjGetVar2(interp, objv[1], NULL, TCL_LEAVE_ERR_MSG);
	if (varValuePtr == NULL) {
	    return TCL_ERROR;
	}
    } else {
	varPtr = TclObjLookupVar(interp, objv[1], NULL, TCL_LEAVE_ERR_MSG,
		"set", /*createPart1*/ 1, /*createPart2*/ 1, &arrayPtr);
	part1 = TclGetString(objv[1]);
	if (varPtr == NULL) {
	    return TCL_ERROR;
	}
	for (i = 2;  i < objc;  i++) {	  
	    /*
	     * Note that we do not need to increase the refCount of
	     * the Var pointers: should a trace delete the variable,
	     * the return value of TclPtrSetVar will be NULL, and we 
	     * will not access the variable again.
	     */

	    varValuePtr = TclPtrSetVar(interp, varPtr, arrayPtr, part1, NULL, 
	            objv[i], (TCL_APPEND_VALUE | TCL_LEAVE_ERR_MSG));
	    if (varValuePtr == NULL) {
		return TCL_ERROR;
	    }
	}
    }
    Tcl_SetObjResult(interp, varValuePtr);
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_LappendObjCmd --
 *
 *	This object-based procedure is invoked to process the "lappend" 
 *	Tcl command. See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl object result value.
 *
 * Side effects:
 *	A variable's value may be changed.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
int
Tcl_LappendObjCmd(dummy, interp, objc, objv)
    ClientData dummy;		/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    Tcl_Obj *varValuePtr, *newValuePtr;
    register List *listRepPtr;
    register Tcl_Obj **elemPtrs;
    int numElems, numRequired, createdNewObj, createVar, i, j;
    Var *varPtr, *arrayPtr;
    char *part1;

    if (objc < 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "varName ?value value ...?");
	return TCL_ERROR;
    }
    if (objc == 2) {
	newValuePtr = Tcl_ObjGetVar2(interp, objv[1], (Tcl_Obj *) NULL, 0);
	if (newValuePtr == NULL) {
	    /*
	     * The variable doesn't exist yet. Just create it with an empty
	     * initial value.
	     */
	    
	    varValuePtr = Tcl_NewObj();
	    newValuePtr = Tcl_ObjSetVar2(interp, objv[1], NULL, varValuePtr,
		    TCL_LEAVE_ERR_MSG);
	    if (newValuePtr == NULL) {
		Tcl_DecrRefCount(varValuePtr); /* free unneeded object */
		return TCL_ERROR;
	    }
	}
    } else {
	/*
	 * We have arguments to append. We used to call Tcl_SetVar2 to
	 * append each argument one at a time to ensure that traces were run
	 * for each append step. We now append the arguments all at once
	 * because it's faster. Note that a read trace and a write trace for
	 * the variable will now each only be called once. Also, if the
	 * variable's old value is unshared we modify it directly, otherwise
	 * we create a new copy to modify: this is "copy on write".
	 */

	createdNewObj = 0;
	createVar = 1;

	/*
	 * Use the TCL_TRACE_READS flag to ensure that if we have an
	 * array with no elements set yet, but with a read trace on it,
	 * we will create the variable and get read traces triggered.
	 * Note that you have to protect the variable pointers around
	 * the TclPtrGetVar call to insure that they remain valid 
	 * even if the variable was undefined and unused.
	 */

	varPtr = TclObjLookupVar(interp, objv[1], NULL, TCL_LEAVE_ERR_MSG,
		"set", /*createPart1*/ 1, /*createPart2*/ 1, &arrayPtr);
	if (varPtr == NULL) {
	    return TCL_ERROR;
	}
	varPtr->refCount++;
	if (arrayPtr != NULL) {
	    arrayPtr->refCount++;
	}
	part1 = TclGetString(objv[1]);
	varValuePtr = TclPtrGetVar(interp, varPtr, arrayPtr, part1, NULL, 
	        (TCL_TRACE_READS | TCL_LEAVE_ERR_MSG));
	varPtr->refCount--;
	if (arrayPtr != NULL) {
	    arrayPtr->refCount--;
	}

	if (varValuePtr == NULL) {
	    /*
	     * We couldn't read the old value: either the var doesn't yet
	     * exist or it's an array element.  If it's new, we will try to
	     * create it with Tcl_ObjSetVar2 below.
	     */
	    
	    createVar = (TclIsVarUndefined(varPtr));
	    varValuePtr = Tcl_NewObj();
	    createdNewObj = 1;
	} else if (Tcl_IsShared(varValuePtr)) {	
	    varValuePtr = Tcl_DuplicateObj(varValuePtr);
	    createdNewObj = 1;
	}

	/*
	 * Convert the variable's old value to a list object if necessary.
	 */

	if (varValuePtr->typePtr != &tclListType) {
	    int result = tclListType.setFromAnyProc(interp, varValuePtr);
	    if (result != TCL_OK) {
		if (createdNewObj) {
		    Tcl_DecrRefCount(varValuePtr); /* free unneeded obj. */
		}
		return result;
	    }
	}
	listRepPtr = (List *) varValuePtr->internalRep.twoPtrValue.ptr1;
	elemPtrs = listRepPtr->elements;
	numElems = listRepPtr->elemCount;

	/*
	 * If there is no room in the current array of element pointers,
	 * allocate a new, larger array and copy the pointers to it.
	 */
	
	numRequired = numElems + (objc-2);
	if (numRequired > listRepPtr->maxElemCount) {
	    int newMax = (2 * numRequired);
	    Tcl_Obj **newElemPtrs = (Tcl_Obj **)
		ckalloc((unsigned) (newMax * sizeof(Tcl_Obj *)));
	    
	    memcpy((VOID *) newElemPtrs, (VOID *) elemPtrs,
		    (size_t) (numElems * sizeof(Tcl_Obj *)));
	    listRepPtr->maxElemCount = newMax;
	    listRepPtr->elements = newElemPtrs;
	    ckfree((char *) elemPtrs);
	    elemPtrs = newElemPtrs;
	}

	/*
	 * Insert the new elements at the end of the list.
	 */

	for (i = 2, j = numElems;  i < objc;  i++, j++) {
            elemPtrs[j] = objv[i];
            Tcl_IncrRefCount(objv[i]);
        }
	listRepPtr->elemCount = numRequired;

	/*
	 * Invalidate and free any old string representation since it no
	 * longer reflects the list's internal representation.
	 */

	Tcl_InvalidateStringRep(varValuePtr);

	/*
	 * Now store the list object back into the variable. If there is an
	 * error setting the new value, decrement its ref count if it
	 * was new and we didn't create the variable.
	 */
	
	newValuePtr = TclPtrSetVar(interp, varPtr, arrayPtr, part1, NULL, 
	            varValuePtr, TCL_LEAVE_ERR_MSG);	
	if (newValuePtr == NULL) {
	    if (createdNewObj && !createVar) {
		Tcl_DecrRefCount(varValuePtr); /* free unneeded obj */
	    }
	    return TCL_ERROR;
	}
    }

    /*
     * Set the interpreter's object result to refer to the variable's value
     * object.
     */

    Tcl_SetObjResult(interp, newValuePtr);
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_ArrayObjCmd --
 *
 *	This object-based procedure is invoked to process the "array" Tcl
 *	command. See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl result object.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
int
Tcl_ArrayObjCmd(dummy, interp, objc, objv)
    ClientData dummy;		/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    /*
     * The list of constants below should match the arrayOptions string array
     * below.
     */

    enum {ARRAY_ANYMORE, ARRAY_DONESEARCH,  ARRAY_EXISTS, ARRAY_GET,
	  ARRAY_NAMES, ARRAY_NEXTELEMENT, ARRAY_SET, ARRAY_SIZE,
	  ARRAY_STARTSEARCH, ARRAY_STATISTICS, ARRAY_UNSET}; 
    static CONST char *arrayOptions[] = {
	"anymore", "donesearch", "exists", "get", "names", "nextelement",
	"set", "size", "startsearch", "statistics", "unset", (char *) NULL
    };

    Interp *iPtr = (Interp *) interp;
    Var *varPtr, *arrayPtr;
    Tcl_HashEntry *hPtr;
    Tcl_Obj *resultPtr, *varNamePtr;
    int notArray;
    char *varName;
    int index, result;


    if (objc < 3) {
	Tcl_WrongNumArgs(interp, 1, objv, "option arrayName ?arg ...?");
	return TCL_ERROR;
    }

    if (Tcl_GetIndexFromObj(interp, objv[1], arrayOptions, "option",
	    0, &index) != TCL_OK) {
    	return TCL_ERROR;
    }

    /*
     * Locate the array variable
     */
    
    varNamePtr = objv[2];
    varName = TclGetString(varNamePtr);
    varPtr = TclObjLookupVar(interp, varNamePtr, NULL, /*flags*/ 0,
            /*msg*/ 0, /*createPart1*/ 0, /*createPart2*/ 0, &arrayPtr);

    /*
     * Special array trace used to keep the env array in sync for
     * array names, array get, etc.
     */

    if (varPtr != NULL && varPtr->tracePtr != NULL
	    && (TclIsVarArray(varPtr) || TclIsVarUndefined(varPtr))) {
	if (TCL_ERROR == CallVarTraces(iPtr, arrayPtr, varPtr, varName, NULL,
		(TCL_LEAVE_ERR_MSG|TCL_NAMESPACE_ONLY|TCL_GLOBAL_ONLY|
		TCL_TRACE_ARRAY), /* leaveErrMsg */ 1)) {
	    return TCL_ERROR;
	}
    }

    /*
     * Verify that it is indeed an array variable. This test comes after
     * the traces - the variable may actually become an array as an effect 
     * of said traces.
     */

    notArray = 0;
    if ((varPtr == NULL) || !TclIsVarArray(varPtr)
	    || TclIsVarUndefined(varPtr)) {
	notArray = 1;
    }

    /*
     * We have to wait to get the resultPtr until here because
     * CallVarTraces can affect the result.
     */

    resultPtr = Tcl_GetObjResult(interp);

    switch (index) {
        case ARRAY_ANYMORE: {
	    ArraySearch *searchPtr;
	    
	    if (objc != 4) {
	        Tcl_WrongNumArgs(interp, 2, objv, 
                        "arrayName searchId");
		return TCL_ERROR;
	    }
	    if (notArray) {
	        goto error;
	    }
	    searchPtr = ParseSearchId(interp, varPtr, varName, objv[3]);
	    if (searchPtr == NULL) {
	        return TCL_ERROR;
	    }
	    while (1) {
	        Var *varPtr2;

		if (searchPtr->nextEntry != NULL) {
		    varPtr2 = (Var *) Tcl_GetHashValue(searchPtr->nextEntry);
		    if (!TclIsVarUndefined(varPtr2)) {
		        break;
		    }
		}
		searchPtr->nextEntry = Tcl_NextHashEntry(&searchPtr->search);
		if (searchPtr->nextEntry == NULL) {
		    Tcl_SetIntObj(resultPtr, 0);
		    return TCL_OK;
		}
	    }
	    Tcl_SetIntObj(resultPtr, 1);
	    break;
	}
        case ARRAY_DONESEARCH: {
	    ArraySearch *searchPtr, *prevPtr;

	    if (objc != 4) {
	        Tcl_WrongNumArgs(interp, 2, objv, 
                        "arrayName searchId");
		return TCL_ERROR;
	    }
	    if (notArray) {
	        goto error;
	    }
	    searchPtr = ParseSearchId(interp, varPtr, varName, objv[3]);
	    if (searchPtr == NULL) {
	        return TCL_ERROR;
	    }
	    if (varPtr->searchPtr == searchPtr) {
	        varPtr->searchPtr = searchPtr->nextPtr;
	    } else {
	        for (prevPtr = varPtr->searchPtr;  ;
		     prevPtr = prevPtr->nextPtr) {
		    if (prevPtr->nextPtr == searchPtr) {
		        prevPtr->nextPtr = searchPtr->nextPtr;
			break;
		    }
		}
	    }
	    ckfree((char *) searchPtr);
	    break;
	}
        case ARRAY_EXISTS: {
	    if (objc != 3) {
	        Tcl_WrongNumArgs(interp, 2, objv, "arrayName");
	        return TCL_ERROR;
	    }
	    Tcl_SetIntObj(resultPtr, !notArray);
	    break;
	}
        case ARRAY_GET: {
	    Tcl_HashSearch search;
	    Var *varPtr2;
	    char *pattern = NULL;
	    char *name;
	    Tcl_Obj *namePtr, *valuePtr, *nameLstPtr, *tmpResPtr, **namePtrPtr;
	    int i, count;
	    
	    if ((objc != 3) && (objc != 4)) {
	        Tcl_WrongNumArgs(interp, 2, objv, "arrayName ?pattern?");
		return TCL_ERROR;
	    }
	    if (notArray) {
	        return TCL_OK;
	    }
	    if (objc == 4) {
	        pattern = TclGetString(objv[3]);
	    }

	    /*
	     * Store the array names in a new object.
	     */

	    nameLstPtr = Tcl_NewObj();
	    Tcl_IncrRefCount(nameLstPtr);

	    for (hPtr = Tcl_FirstHashEntry(varPtr->value.tablePtr, &search);
		 hPtr != NULL;  hPtr = Tcl_NextHashEntry(&search)) {
	        varPtr2 = (Var *) Tcl_GetHashValue(hPtr);
		if (TclIsVarUndefined(varPtr2)) {
		    continue;
		}
		name = Tcl_GetHashKey(varPtr->value.tablePtr, hPtr);
		if ((objc == 4) && !Tcl_StringMatch(name, pattern)) {
		    continue;	/* element name doesn't match pattern */
		}
		
		namePtr = Tcl_NewStringObj(name, -1);
		result = Tcl_ListObjAppendElement(interp, nameLstPtr,
		        namePtr);
		if (result != TCL_OK) {
		    Tcl_DecrRefCount(namePtr); /* free unneeded name obj */
		    Tcl_DecrRefCount(nameLstPtr);
		    return result;
		}
	    }

	    /*
	     * Make sure the Var structure of the array is not removed by
	     * a trace while we're working.
	     */

	    varPtr->refCount++;

	    /*
	     * Get the array values corresponding to each element name 
	     */

	    tmpResPtr = Tcl_NewObj();
	    result = Tcl_ListObjGetElements(interp, nameLstPtr,
		    &count, &namePtrPtr);
	    if (result != TCL_OK) {
		goto errorInArrayGet;
	    }
	    
	    for (i = 0; i < count; i++) { 
		namePtr = *namePtrPtr++;
		valuePtr = Tcl_ObjGetVar2(interp, objv[2], namePtr,
	                TCL_LEAVE_ERR_MSG);
		if (valuePtr == NULL) {
		    /*
		     * Some trace played a trick on us; we need to diagnose to
		     * adapt our behaviour: was the array element unset, or did
		     * the modification modify the complete array?
		     */

		    if (TclIsVarArray(varPtr) && !TclIsVarUndefined(varPtr)) {
			/*
			 * The array itself looks OK, the variable was
			 * undefined: forget it.
			 */
			
			continue;
		    } else {
			result = TCL_ERROR;
			goto errorInArrayGet;
		    }
		}
		result = Tcl_ListObjAppendElement(interp, tmpResPtr, namePtr);
		if (result != TCL_OK) {
		    goto errorInArrayGet;
		}
		result = Tcl_ListObjAppendElement(interp, tmpResPtr, valuePtr);
		if (result != TCL_OK) {
		    goto errorInArrayGet;
		}
	    }
	    varPtr->refCount--;
	    Tcl_SetObjResult(interp, tmpResPtr);
	    Tcl_DecrRefCount(nameLstPtr);
	    break;

	    errorInArrayGet:
	    varPtr->refCount--;
	    Tcl_DecrRefCount(nameLstPtr);
	    Tcl_DecrRefCount(tmpResPtr); /* free unneeded temp result obj */
	    return result;
	}
        case ARRAY_NAMES: {
	    Tcl_HashSearch search;
	    Var *varPtr2;
	    char *pattern = NULL;
	    char *name;
	    Tcl_Obj *namePtr;
	    int mode, matched = 0;
	    static CONST char *options[] = {
		"-exact", "-glob", "-regexp", (char *) NULL
	    };
	    enum options { OPT_EXACT, OPT_GLOB, OPT_REGEXP };

	    mode = OPT_GLOB;
	    
	    if ((objc < 3) || (objc > 5)) {
  	        Tcl_WrongNumArgs(interp, 2, objv,
			"arrayName ?mode? ?pattern?");
		return TCL_ERROR;
	    }
	    if (notArray) {
	        return TCL_OK;
	    }
	    if (objc == 4) {
	        pattern = Tcl_GetString(objv[3]);
	    } else if (objc == 5) {
		pattern = Tcl_GetString(objv[4]);
		if (Tcl_GetIndexFromObj(interp, objv[3], options, "option",
			0, &mode) != TCL_OK) {
		    return TCL_ERROR;
		}
	    }       		
	    for (hPtr = Tcl_FirstHashEntry(varPtr->value.tablePtr, &search);
		 hPtr != NULL; hPtr = Tcl_NextHashEntry(&search)) {
	        varPtr2 = (Var *) Tcl_GetHashValue(hPtr);
		if (TclIsVarUndefined(varPtr2)) {
		    continue;
		}
		name = Tcl_GetHashKey(varPtr->value.tablePtr, hPtr);
		if (objc > 3) {
		    switch ((enum options) mode) {
			case OPT_EXACT:
			    matched = (strcmp(name, pattern) == 0);
			    break;
			case OPT_GLOB:
			    matched = Tcl_StringMatch(name, pattern);
			    break;
			case OPT_REGEXP:
			    matched = Tcl_RegExpMatch(interp, name,
				    pattern);
			    if (matched < 0) {
				return TCL_ERROR;
			    }
			    break;
		    }
		    if (matched == 0) {
			continue;
		    }
		}
		
		namePtr = Tcl_NewStringObj(name, -1);
		result = Tcl_ListObjAppendElement(interp, resultPtr, namePtr);
		if (result != TCL_OK) {
		    Tcl_DecrRefCount(namePtr); /* free unneeded name obj */
		    return result;
		}
	    }
	    break;
	}
        case ARRAY_NEXTELEMENT: {
	    ArraySearch *searchPtr;
	    Tcl_HashEntry *hPtr;
	    
	    if (objc != 4) {
	        Tcl_WrongNumArgs(interp, 2, objv, 
                        "arrayName searchId");
		return TCL_ERROR;
	    }
	    if (notArray) {
  	        goto error;
	    }
	    searchPtr = ParseSearchId(interp, varPtr, varName, objv[3]);
	    if (searchPtr == NULL) {
	        return TCL_ERROR;
	    }
	    while (1) {
	        Var *varPtr2;

		hPtr = searchPtr->nextEntry;
		if (hPtr == NULL) {
		    hPtr = Tcl_NextHashEntry(&searchPtr->search);
		    if (hPtr == NULL) {
		        return TCL_OK;
		    }
		} else {
		    searchPtr->nextEntry = NULL;
		}
		varPtr2 = (Var *) Tcl_GetHashValue(hPtr);
		if (!TclIsVarUndefined(varPtr2)) {
		    break;
		}
	    }
	    Tcl_SetStringObj(resultPtr,
	            Tcl_GetHashKey(varPtr->value.tablePtr, hPtr), -1);
	    break;
	}
        case ARRAY_SET: {
	    if (objc != 4) {
	        Tcl_WrongNumArgs(interp, 2, objv, "arrayName list");
		return TCL_ERROR;
	    }
	    return(TclArraySet(interp, objv[2], objv[3]));
	}
        case ARRAY_SIZE: {
	    Tcl_HashSearch search;
	    Var *varPtr2;
	    int size;

	    if (objc != 3) {
	        Tcl_WrongNumArgs(interp, 2, objv, "arrayName");
		return TCL_ERROR;
	    }
	    size = 0;
	    if (!notArray) {
	        for (hPtr = Tcl_FirstHashEntry(varPtr->value.tablePtr, 
                        &search);
		     hPtr != NULL;  hPtr = Tcl_NextHashEntry(&search)) {
		    varPtr2 = (Var *) Tcl_GetHashValue(hPtr);
		    if (TclIsVarUndefined(varPtr2)) {
		        continue;
		    }
		    size++;
		}
	    }
	    Tcl_SetIntObj(resultPtr, size);
	    break;
	}
        case ARRAY_STARTSEARCH: {
	    ArraySearch *searchPtr;

	    if (objc != 3) {
	        Tcl_WrongNumArgs(interp, 2, objv, "arrayName");
		return TCL_ERROR;
	    }
	    if (notArray) {
	        goto error;
	    }
	    searchPtr = (ArraySearch *) ckalloc(sizeof(ArraySearch));
	    if (varPtr->searchPtr == NULL) {
	        searchPtr->id = 1;
		Tcl_AppendStringsToObj(resultPtr, "s-1-", varName,
		        (char *) NULL);
	    } else {
	        char string[TCL_INTEGER_SPACE];

		searchPtr->id = varPtr->searchPtr->id + 1;
		TclFormatInt(string, searchPtr->id);
		Tcl_AppendStringsToObj(resultPtr, "s-", string, "-", varName,
			(char *) NULL);
	    }
	    searchPtr->varPtr = varPtr;
	    searchPtr->nextEntry = Tcl_FirstHashEntry(varPtr->value.tablePtr,
		    &searchPtr->search);
	    searchPtr->nextPtr = varPtr->searchPtr;
	    varPtr->searchPtr = searchPtr;
	    break;
	}

	case ARRAY_STATISTICS: {
	    CONST char *stats;

	    if (notArray) {
		goto error;
	    }

	    stats = Tcl_HashStats(varPtr->value.tablePtr);
	    if (stats != NULL) {
		Tcl_SetStringObj(Tcl_GetObjResult(interp), stats, -1);
		ckfree((void *)stats);
	    } else {
		Tcl_SetResult(interp, "error reading array statistics",
			TCL_STATIC);
		return TCL_ERROR;
	    }
	    break;
        }
	
	case ARRAY_UNSET: {
	    Tcl_HashSearch search;
	    Var *varPtr2;
	    char *pattern = NULL;
	    char *name;
          
	    if ((objc != 3) && (objc != 4)) {
		Tcl_WrongNumArgs(interp, 2, objv, "arrayName ?pattern?");
		return TCL_ERROR;
	    }
	    if (notArray) {
		return TCL_OK;
	    }
	    if (objc == 3) {
		/*
		 * When no pattern is given, just unset the whole array
		 */
		if (TclObjUnsetVar2(interp, varNamePtr, NULL, 0)
			!= TCL_OK) {
		    return TCL_ERROR;
		}
	    } else {
		pattern = Tcl_GetString(objv[3]);
		for (hPtr = Tcl_FirstHashEntry(varPtr->value.tablePtr,
			&search);
		     hPtr != NULL; hPtr = Tcl_NextHashEntry(&search)) {
		    varPtr2 = (Var *) Tcl_GetHashValue(hPtr);
		    if (TclIsVarUndefined(varPtr2)) {
			continue;
		    }
		    name = Tcl_GetHashKey(varPtr->value.tablePtr, hPtr);
		    if (Tcl_StringMatch(name, pattern) &&
			    (TclObjUnsetVar2(interp, varNamePtr, name, 0)
				    != TCL_OK)) {
			return TCL_ERROR;
		    }
		}
	    }
	    break;
	}
    }
    return TCL_OK;

    error:
    Tcl_AppendStringsToObj(resultPtr, "\"", varName, "\" isn't an array",
	    (char *) NULL);
    return TCL_ERROR;
}

/*
 *----------------------------------------------------------------------
 *
 * TclArraySet --
 *
 *	Set the elements of an array.  If there are no elements to
 *	set, create an empty array.  This routine is used by the
 *	Tcl_ArrayObjCmd and by the TclSetupEnv routine.
 *
 * Results:
 *	A standard Tcl result object.
 *
 * Side effects:
 *	A variable will be created if one does not already exist.
 *
 *----------------------------------------------------------------------
 */

int
TclArraySet(interp, arrayNameObj, arrayElemObj)
    Tcl_Interp *interp;		/* Current interpreter. */
    Tcl_Obj *arrayNameObj;	/* The array name. */
    Tcl_Obj *arrayElemObj;	/* The array elements list.  If this is
				 * NULL, create an empty array. */
{
    Var *varPtr, *arrayPtr;
    Tcl_Obj **elemPtrs;
    int result, elemLen, i, nameLen;
    char *varName, *p;
    
    varName = Tcl_GetStringFromObj(arrayNameObj, &nameLen);
    p = varName + nameLen - 1;
    if (*p == ')') {
	while (--p >= varName) {
	    if (*p == '(') {
		VarErrMsg(interp, varName, NULL, "set", needArray);
		return TCL_ERROR;
	    }
	}
    }

    varPtr = TclObjLookupVar(interp, arrayNameObj, NULL,
	    /*flags*/ TCL_LEAVE_ERR_MSG, /*msg*/ "set", /*createPart1*/ 1,
	    /*createPart2*/ 0, &arrayPtr);
    if (varPtr == NULL) {
	return TCL_ERROR;
    }

    if (arrayElemObj != NULL) {
	result = Tcl_ListObjGetElements(interp, arrayElemObj,
		&elemLen, &elemPtrs);
	if (result != TCL_OK) {
	    return result;
	}
	if (elemLen & 1) {
	    Tcl_ResetResult(interp);
	    Tcl_AppendToObj(Tcl_GetObjResult(interp),
		    "list must have an even number of elements", -1);
	    return TCL_ERROR;
	}
	if (elemLen > 0) {
	    /*
	     * We needn't worry about traces invalidating arrayPtr:
	     * should that be the case, TclPtrSetVar will return NULL
	     * so that we break out of the loop and return an error.
	     */

	    for (i = 0;  i < elemLen;  i += 2) {
		char *part2 = TclGetString(elemPtrs[i]);
		Var *elemVarPtr = TclLookupArrayElement(interp, varName, 
                        part2, TCL_LEAVE_ERR_MSG, "set", 1, 1, varPtr);
		if ((elemVarPtr == NULL) ||
		        (TclPtrSetVar(interp, elemVarPtr, varPtr, varName,
			 part2, elemPtrs[i+1], TCL_LEAVE_ERR_MSG) == NULL)) {
		    result = TCL_ERROR;
		    break;
		}
	    }
	    return result;
	}
    }
    
    /*
     * The list is empty make sure we have an array, or create
     * one if necessary.
     */
    
    if (varPtr != NULL) {
	if (!TclIsVarUndefined(varPtr) && TclIsVarArray(varPtr)) {
	    /*
	     * Already an array, done.
	     */
	    
	    return TCL_OK;
	}
	if (TclIsVarArrayElement(varPtr) || !TclIsVarUndefined(varPtr)) {
	    /*
	     * Either an array element, or a scalar: lose!
	     */
	    
	    VarErrMsg(interp, varName, (char *)NULL, "array set", needArray);
	    return TCL_ERROR;
	}
    }
    TclSetVarArray(varPtr);
    TclClearVarUndefined(varPtr);
    varPtr->value.tablePtr =
	(Tcl_HashTable *) ckalloc(sizeof(Tcl_HashTable));
    Tcl_InitHashTable(varPtr->value.tablePtr, TCL_STRING_KEYS);
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * ObjMakeUpvar --
 *
 *	This procedure does all of the work of the "global" and "upvar"
 *	commands.
 *
 * Results:
 *	A standard Tcl completion code. If an error occurs then an
 *	error message is left in iPtr->result.
 *
 * Side effects:
 *	The variable given by myName is linked to the variable in framePtr
 *	given by otherP1 and otherP2, so that references to myName are
 *	redirected to the other variable like a symbolic link.
 *
 *----------------------------------------------------------------------
 */

static int
ObjMakeUpvar(interp, framePtr, otherP1Ptr, otherP2, otherFlags, myName, myFlags, index)
    Tcl_Interp *interp;		/* Interpreter containing variables. Used
			         * for error messages, too. */
    CallFrame *framePtr;	/* Call frame containing "other" variable.
				 * NULL means use global :: context. */
    Tcl_Obj *otherP1Ptr;
    CONST char *otherP2;	/* Two-part name of variable in framePtr. */
    CONST int otherFlags;	/* 0, TCL_GLOBAL_ONLY or TCL_NAMESPACE_ONLY:
				 * indicates scope of "other" variable. */
    CONST char *myName;		/* Name of variable which will refer to
				 * otherP1/otherP2. Must be a scalar. */
    CONST int myFlags;		/* 0, TCL_GLOBAL_ONLY or TCL_NAMESPACE_ONLY:
				 * indicates scope of myName. */
    int index;                  /* If the variable to be linked is an indexed
				 * scalar, this is its index. Otherwise, -1. */
{
    Interp *iPtr = (Interp *) interp;
    Var *otherPtr, *varPtr, *arrayPtr;
    CallFrame *varFramePtr;
    CONST char *errMsg;

    /*
     * Find "other" in "framePtr". If not looking up other in just the
     * current namespace, temporarily replace the current var frame
     * pointer in the interpreter in order to use TclObjLookupVar.
     */

    varFramePtr = iPtr->varFramePtr;
    if (!(otherFlags & TCL_NAMESPACE_ONLY)) {
	iPtr->varFramePtr = framePtr;
    }
    otherPtr = TclObjLookupVar(interp, otherP1Ptr, otherP2,
	    (otherFlags | TCL_LEAVE_ERR_MSG), "access",
            /*createPart1*/ 1, /*createPart2*/ 1, &arrayPtr);
    if (!(otherFlags & TCL_NAMESPACE_ONLY)) {
	iPtr->varFramePtr = varFramePtr;
    }
    if (otherPtr == NULL) {
	return TCL_ERROR;
    }

    if (index >= 0) {
	if (!varFramePtr->isProcCallFrame) {
	    panic("ObjMakeUpVar called with an index outside from a proc.\n");
	}
	varPtr = &(varFramePtr->compiledLocals[index]);
    } else {
	/*
	 * Check that we are not trying to create a namespace var linked to
	 * a local variable in a procedure. If we allowed this, the local
	 * variable in the shorter-lived procedure frame could go away
	 * leaving the namespace var's reference invalid.
	 */
	
	if (((otherP2 ? arrayPtr->nsPtr : otherPtr->nsPtr) == NULL) 
	    && ((myFlags & (TCL_GLOBAL_ONLY | TCL_NAMESPACE_ONLY))
		|| (varFramePtr == NULL)
		|| !varFramePtr->isProcCallFrame
		|| (strstr(myName, "::") != NULL))) {
	    Tcl_AppendResult((Tcl_Interp *) iPtr, "bad variable name \"",
		    myName, "\": upvar won't create namespace variable that ",
		    "refers to procedure variable", (char *) NULL);
	    return TCL_ERROR;
	}
	
	/*
	 * Lookup and eventually create the new variable.
	 */
	
	varPtr = TclLookupSimpleVar(interp, myName, myFlags, /*create*/ 1, 
				    &errMsg, &index);
	if (varPtr == NULL) {
	    VarErrMsg(interp, myName, NULL, "create", errMsg);
	    return TCL_ERROR;
	}
    }

    if (varPtr == otherPtr) {
	Tcl_SetResult((Tcl_Interp *) iPtr,
		      "can't upvar from variable to itself", TCL_STATIC);
	return TCL_ERROR;
    }

    if (varPtr->tracePtr != NULL) {
	Tcl_AppendResult((Tcl_Interp *) iPtr, "variable \"", myName,
	        "\" has traces: can't use for upvar", (char *) NULL);
	return TCL_ERROR;
    } else if (!TclIsVarUndefined(varPtr)) {
	/*
	 * The variable already existed. Make sure this variable "varPtr"
	 * isn't the same as "otherPtr" (avoid circular links). Also, if
	 * it's not an upvar then it's an error. If it is an upvar, then
	 * just disconnect it from the thing it currently refers to.
	 */

	if (TclIsVarLink(varPtr)) {
	    Var *linkPtr = varPtr->value.linkPtr;
	    if (linkPtr == otherPtr) {
		return TCL_OK;
	    }
	    linkPtr->refCount--;
	    if (TclIsVarUndefined(linkPtr)) {
		CleanupVar(linkPtr, (Var *) NULL);
	    }
	} else {
	    Tcl_AppendResult((Tcl_Interp *) iPtr, "variable \"", myName,
		    "\" already exists", (char *) NULL);
	    return TCL_ERROR;
	}
    }
    TclSetVarLink(varPtr);
    TclClearVarUndefined(varPtr);
    varPtr->value.linkPtr = otherPtr;
    otherPtr->refCount++;
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_UpVar --
 *
 *	This procedure links one variable to another, just like
 *	the "upvar" command.
 *
 * Results:
 *	A standard Tcl completion code.  If an error occurs then
 *	an error message is left in the interp's result.
 *
 * Side effects:
 *	The variable in frameName whose name is given by varName becomes
 *	accessible under the name localName, so that references to
 *	localName are redirected to the other variable like a symbolic
 *	link.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_UpVar(interp, frameName, varName, localName, flags)
    Tcl_Interp *interp;		/* Command interpreter in which varName is
				 * to be looked up. */
    CONST char *frameName;	/* Name of the frame containing the source
				 * variable, such as "1" or "#0". */
    CONST char *varName;	/* Name of a variable in interp to link to.
				 * May be either a scalar name or an
				 * element in an array. */
    CONST char *localName;	/* Name of link variable. */
    int flags;			/* 0, TCL_GLOBAL_ONLY or TCL_NAMESPACE_ONLY:
				 * indicates scope of localName. */
{
    return Tcl_UpVar2(interp, frameName, varName, NULL, localName, flags);
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_UpVar2 --
 *
 *	This procedure links one variable to another, just like
 *	the "upvar" command.
 *
 * Results:
 *	A standard Tcl completion code.  If an error occurs then
 *	an error message is left in the interp's result.
 *
 * Side effects:
 *	The variable in frameName whose name is given by part1 and
 *	part2 becomes accessible under the name localName, so that
 *	references to localName are redirected to the other variable
 *	like a symbolic link.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_UpVar2(interp, frameName, part1, part2, localName, flags)
    Tcl_Interp *interp;		/* Interpreter containing variables.  Used
				 * for error messages too. */
    CONST char *frameName;	/* Name of the frame containing the source
				 * variable, such as "1" or "#0". */
    CONST char *part1;
    CONST char *part2;		/* Two parts of source variable name to
				 * link to. */
    CONST char *localName;	/* Name of link variable. */
    int flags;			/* 0, TCL_GLOBAL_ONLY or TCL_NAMESPACE_ONLY:
				 * indicates scope of localName. */
{
    int result;
    CallFrame *framePtr;
    Tcl_Obj *part1Ptr;

    if (TclGetFrame(interp, frameName, &framePtr) == -1) {
	return TCL_ERROR;
    }

    part1Ptr = Tcl_NewStringObj(part1, -1);
    Tcl_IncrRefCount(part1Ptr);
    result = ObjMakeUpvar(interp, framePtr, part1Ptr, part2, 0,
	    localName, flags, -1);
    TclDecrRefCount(part1Ptr);

    return result;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetVariableFullName --
 *
 *	Given a Tcl_Var token returned by Tcl_FindNamespaceVar, this
 *	procedure appends to an object the namespace variable's full
 *	name, qualified by a sequence of parent namespace names.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      The variable's fully-qualified name is appended to the string
 *	representation of objPtr.
 *
 *----------------------------------------------------------------------
 */

void
Tcl_GetVariableFullName(interp, variable, objPtr)
    Tcl_Interp *interp;	        /* Interpreter containing the variable. */
    Tcl_Var variable;		/* Token for the variable returned by a
				 * previous call to Tcl_FindNamespaceVar. */
    Tcl_Obj *objPtr;		/* Points to the object onto which the
				 * variable's full name is appended. */
{
    Interp *iPtr = (Interp *) interp;
    register Var *varPtr = (Var *) variable;
    char *name;

    /*
     * Add the full name of the containing namespace (if any), followed by
     * the "::" separator, then the variable name.
     */

    if (varPtr != NULL) {
	if (!TclIsVarArrayElement(varPtr)) {
	    if (varPtr->nsPtr != NULL) {
		Tcl_AppendToObj(objPtr, varPtr->nsPtr->fullName, -1);
		if (varPtr->nsPtr != iPtr->globalNsPtr) {
		    Tcl_AppendToObj(objPtr, "::", 2);
		}
	    }
	    if (varPtr->name != NULL) {
		Tcl_AppendToObj(objPtr, varPtr->name, -1);
	    } else if (varPtr->hPtr != NULL) {
		name = Tcl_GetHashKey(varPtr->hPtr->tablePtr, varPtr->hPtr);
		Tcl_AppendToObj(objPtr, name, -1);
	    }
	}
    }
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_GlobalObjCmd --
 *
 *	This object-based procedure is invoked to process the "global" Tcl
 *	command. See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl object result value.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_GlobalObjCmd(dummy, interp, objc, objv)
    ClientData dummy;		/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    Interp *iPtr = (Interp *) interp;
    register Tcl_Obj *objPtr;
    char *varName;
    register char *tail;
    int result, i;

    if (objc < 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "varName ?varName ...?");
	return TCL_ERROR;
    }

    /*
     * If we are not executing inside a Tcl procedure, just return.
     */
    
    if ((iPtr->varFramePtr == NULL)
	    || !iPtr->varFramePtr->isProcCallFrame) {
	return TCL_OK;
    }

    for (i = 1;  i < objc;  i++) {
	/*
	 * Make a local variable linked to its counterpart in the global ::
	 * namespace.
	 */
	
	objPtr = objv[i];
	varName = TclGetString(objPtr);

	/*
	 * The variable name might have a scope qualifier, but the name for
         * the local "link" variable must be the simple name at the tail.
	 */

	for (tail = varName;  *tail != '\0';  tail++) {
	    /* empty body */
	}
        while ((tail > varName) && ((*tail != ':') || (*(tail-1) != ':'))) {
            tail--;
	}
        if ((*tail == ':') && (tail > varName)) {
            tail++;
	}

	/*
	 * Link to the variable "varName" in the global :: namespace.
	 */
	
	result = ObjMakeUpvar(interp, (CallFrame *) NULL,
		objPtr, NULL, /*otherFlags*/ TCL_GLOBAL_ONLY,
	        /*myName*/ tail, /*myFlags*/ 0, -1);
	if (result != TCL_OK) {
	    return result;
	}
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_VariableObjCmd --
 *
 *	Invoked to implement the "variable" command that creates one or more
 *	global variables. Handles the following syntax:
 *
 *	    variable ?name value...? name ?value?
 *
 *	One or more variables can be created. The variables are initialized
 *	with the specified values. The value for the last variable is
 *	optional.
 *
 *	If the variable does not exist, it is created and given the optional
 *	value. If it already exists, it is simply set to the optional
 *	value. Normally, "name" is an unqualified name, so it is created in
 *	the current namespace. If it includes namespace qualifiers, it can
 *	be created in another namespace.
 *
 *	If the variable command is executed inside a Tcl procedure, it
 *	creates a local variable linked to the newly-created namespace
 *	variable.
 *
 * Results:
 *	Returns TCL_OK if the variable is found or created. Returns
 *	TCL_ERROR if anything goes wrong.
 *
 * Side effects:
 *	If anything goes wrong, this procedure returns an error message
 *	as the result in the interpreter's result object.
 *
 *----------------------------------------------------------------------
 */

int
Tcl_VariableObjCmd(dummy, interp, objc, objv)
    ClientData dummy;		/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    Interp *iPtr = (Interp *) interp;
    char *varName, *tail, *cp;
    Var *varPtr, *arrayPtr;
    Tcl_Obj *varValuePtr;
    int i, result;
    Tcl_Obj *varNamePtr;

    if (objc < 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "?name value...? name ?value?");
	return TCL_ERROR;
    }

    for (i = 1;  i < objc;  i = i+2) {
	/*
	 * Look up each variable in the current namespace context, creating
	 * it if necessary.
	 */
	
	varNamePtr = objv[i];
	varName = TclGetString(varNamePtr);
	varPtr = TclObjLookupVar(interp, varNamePtr, NULL,
                (TCL_NAMESPACE_ONLY | TCL_LEAVE_ERR_MSG), "define",
                /*createPart1*/ 1, /*createPart2*/ 0, &arrayPtr);
	
        if (arrayPtr != NULL) {
            /*
             * Variable cannot be an element in an array.  If arrayPtr is
             * non-null, it is, so throw up an error and return.
             */
            VarErrMsg(interp, varName, NULL, "define", isArrayElement);
            return TCL_ERROR;
        }

	if (varPtr == NULL) {
	    return TCL_ERROR;
	}

	/*
	 * Mark the variable as a namespace variable and increment its 
	 * reference count so that it will persist until its namespace is
	 * destroyed or until the variable is unset.
	 */

	if (!(varPtr->flags & VAR_NAMESPACE_VAR)) {
	    varPtr->flags |= VAR_NAMESPACE_VAR;
	    varPtr->refCount++;
	}

	/*
	 * If a value was specified, set the variable to that value.
	 * Otherwise, if the variable is new, leave it undefined.
	 * (If the variable already exists and no value was specified,
	 * leave its value unchanged; just create the local link if
	 * we're in a Tcl procedure).
	 */

	if (i+1 < objc) {	/* a value was specified */
	    varValuePtr = TclPtrSetVar(interp, varPtr, arrayPtr, varName, NULL,
		    objv[i+1], (TCL_NAMESPACE_ONLY | TCL_LEAVE_ERR_MSG));
	    if (varValuePtr == NULL) {
		return TCL_ERROR;
	    }
	}

	/*
	 * If we are executing inside a Tcl procedure, create a local
	 * variable linked to the new namespace variable "varName".
	 */

	if ((iPtr->varFramePtr != NULL)
	        && iPtr->varFramePtr->isProcCallFrame) {
	    /*
	     * varName might have a scope qualifier, but the name for the
	     * local "link" variable must be the simple name at the tail.
	     *
	     * Locate tail in one pass: drop any prefix after two *or more*
	     * consecutive ":" characters).
	     */

	    for (tail = cp = varName;  *cp != '\0'; ) {
		if (*cp++ == ':') {
		    while (*cp == ':') {
			tail = ++cp;
		    }
		}
	    }
	    
	    /*
	     * Create a local link "tail" to the variable "varName" in the
	     * current namespace.
	     */
	    
	    result = ObjMakeUpvar(interp, (CallFrame *) NULL,
		    /*otherP1*/ varNamePtr, /*otherP2*/ NULL,
                    /*otherFlags*/ TCL_NAMESPACE_ONLY,
		    /*myName*/ tail, /*myFlags*/ 0, -1);
	    if (result != TCL_OK) {
		return result;
	    }
	}
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_UpvarObjCmd --
 *
 *	This object-based procedure is invoked to process the "upvar"
 *	Tcl command. See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl object result value.
 *
 * Side effects:
 *	See the user documentation.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
int
Tcl_UpvarObjCmd(dummy, interp, objc, objv)
    ClientData dummy;		/* Not used. */
    Tcl_Interp *interp;		/* Current interpreter. */
    int objc;			/* Number of arguments. */
    Tcl_Obj *CONST objv[];	/* Argument objects. */
{
    CallFrame *framePtr;
    char *frameSpec, *localName;
    int result;

    if (objc < 3) {
	upvarSyntax:
	Tcl_WrongNumArgs(interp, 1, objv,
		"?level? otherVar localVar ?otherVar localVar ...?");
	return TCL_ERROR;
    }

    /*
     * Find the call frame containing each of the "other variables" to be
     * linked to. 
     */

    frameSpec = TclGetString(objv[1]);
    result = TclGetFrame(interp, frameSpec, &framePtr);
    if (result == -1) {
	return TCL_ERROR;
    }
    objc -= result+1;
    if ((objc & 1) != 0) {
	goto upvarSyntax;
    }
    objv += result+1;

    /*
     * Iterate over each (other variable, local variable) pair.
     * Divide the other variable name into two parts, then call
     * MakeUpvar to do all the work of linking it to the local variable.
     */

    for ( ;  objc > 0;  objc -= 2, objv += 2) {
	localName = TclGetString(objv[1]);
	result = ObjMakeUpvar(interp, framePtr, /* othervarName */ objv[0],
		NULL, 0, /* myVarName */ localName, /*flags*/ 0, -1);
	if (result != TCL_OK) {
	    return TCL_ERROR;
	}
    }
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * DisposeTraceResult--
 *
 *	This procedure is called to dispose of the result returned from
 *	a trace procedure.  The disposal method appropriate to the type
 *	of result is determined by flags.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The memory allocated for the trace result may be freed.
 *
 *----------------------------------------------------------------------
 */

void
DisposeTraceResult(flags, result)
    int flags;			/* Indicates type of result to determine
				 * proper disposal method */
    char *result;		/* The result returned from a trace
				 * procedure to be disposed */
{
    if (flags & TCL_TRACE_RESULT_DYNAMIC) {
	ckfree(result);
    } else if (flags & TCL_TRACE_RESULT_OBJECT) {
	Tcl_DecrRefCount((Tcl_Obj *) result);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * CallVarTraces --
 *
 *	This procedure is invoked to find and invoke relevant
 *	trace procedures associated with a particular operation on
 *	a variable. This procedure invokes traces both on the
 *	variable and on its containing array (where relevant).
 *
 * Results:
 *      Returns TCL_OK to indicate normal operation.  Returns TCL_ERROR
 *      if invocation of a trace procedure indicated an error.  When
 *      TCL_ERROR is returned and leaveErrMsg is true, then the
 *      ::errorInfo variable of iPtr has information about the error
 *      appended to it.
 *
 * Side effects:
 *	Almost anything can happen, depending on trace; this procedure
 *	itself doesn't have any side effects.
 *
 *----------------------------------------------------------------------
 */

int 
CallVarTraces(iPtr, arrayPtr, varPtr, part1, part2, flags, leaveErrMsg)
    Interp *iPtr;		/* Interpreter containing variable. */
    register Var *arrayPtr;	/* Pointer to array variable that contains
				 * the variable, or NULL if the variable
				 * isn't an element of an array. */
    Var *varPtr;		/* Variable whose traces are to be
				 * invoked. */
    CONST char *part1;
    CONST char *part2;		/* Variable's two-part name. */
    int flags;			/* Flags passed to trace procedures:
				 * indicates what's happening to variable,
				 * plus other stuff like TCL_GLOBAL_ONLY,
				 * TCL_NAMESPACE_ONLY, and
				 * TCL_INTERP_DESTROYED. */
    CONST int leaveErrMsg;	/* If true, and one of the traces indicates an
				 * error, then leave an error message and stack
				 * trace information in *iPTr. */
{
    register VarTrace *tracePtr;
    ActiveVarTrace active;
    char *result;
    CONST char *openParen, *p;
    Tcl_DString nameCopy;
    int copiedName;
    int code = TCL_OK;
    int disposeFlags = 0;

    /*
     * If there are already similar trace procedures active for the
     * variable, don't call them again.
     */

    if (varPtr->flags & VAR_TRACE_ACTIVE) {
	return code;
    }
    varPtr->flags |= VAR_TRACE_ACTIVE;
    varPtr->refCount++;
    if (arrayPtr != NULL) {
	arrayPtr->refCount++;
    }

    /*
     * If the variable name hasn't been parsed into array name and
     * element, do it here.  If there really is an array element,
     * make a copy of the original name so that NULLs can be
     * inserted into it to separate the names (can't modify the name
     * string in place, because the string might get used by the
     * callbacks we invoke).
     */

    copiedName = 0;
    if (part2 == NULL) {
	for (p = part1; *p ; p++) {
	    if (*p == '(') {
		openParen = p;
		do {
		    p++;
		} while (*p != '\0');
		p--;
		if (*p == ')') {
		    int offset = (openParen - part1);
		    char *newPart1;
		    Tcl_DStringInit(&nameCopy);
		    Tcl_DStringAppend(&nameCopy, part1, (p-part1));
		    newPart1 = Tcl_DStringValue(&nameCopy);
		    newPart1[offset] = 0;
		    part1 = newPart1;
		    part2 = newPart1 + offset + 1;
		    copiedName = 1;
		}
		break;
	    }
	}
    }

    /*
     * Invoke traces on the array containing the variable, if relevant.
     */

    result = NULL;
    active.nextPtr = iPtr->activeVarTracePtr;
    iPtr->activeVarTracePtr = &active;
    Tcl_Preserve((ClientData) iPtr);
    if (arrayPtr != NULL && !(arrayPtr->flags & VAR_TRACE_ACTIVE)) {
	active.varPtr = arrayPtr;
	for (tracePtr = arrayPtr->tracePtr;  tracePtr != NULL;
	     tracePtr = active.nextTracePtr) {
	    active.nextTracePtr = tracePtr->nextPtr;
	    if (!(tracePtr->flags & flags)) {
		continue;
	    }
	    Tcl_Preserve((ClientData) tracePtr);
	    result = (*tracePtr->traceProc)(tracePtr->clientData,
		    (Tcl_Interp *) iPtr, part1, part2, flags);
	    if (result != NULL) {
		if (flags & TCL_TRACE_UNSETS) {
		    /* Ignore errors in unset traces */
		    DisposeTraceResult(tracePtr->flags, result);
		} else {
	            disposeFlags = tracePtr->flags;
		    code = TCL_ERROR;
		}
	    }
	    Tcl_Release((ClientData) tracePtr);
	    if (code == TCL_ERROR) {
		goto done;
	    }
	}
    }

    /*
     * Invoke traces on the variable itself.
     */

    if (flags & TCL_TRACE_UNSETS) {
	flags |= TCL_TRACE_DESTROYED;
    }
    active.varPtr = varPtr;
    for (tracePtr = varPtr->tracePtr; tracePtr != NULL;
	 tracePtr = active.nextTracePtr) {
	active.nextTracePtr = tracePtr->nextPtr;
	if (!(tracePtr->flags & flags)) {
	    continue;
	}
	Tcl_Preserve((ClientData) tracePtr);
	result = (*tracePtr->traceProc)(tracePtr->clientData,
		(Tcl_Interp *) iPtr, part1, part2, flags);
	if (result != NULL) {
	    if (flags & TCL_TRACE_UNSETS) {
		/* Ignore errors in unset traces */
		DisposeTraceResult(tracePtr->flags, result);
	    } else {
		disposeFlags = tracePtr->flags;
		code = TCL_ERROR;
	    }
	}
	Tcl_Release((ClientData) tracePtr);
	if (code == TCL_ERROR) {
	    goto done;
	}
    }

    /*
     * Restore the variable's flags, remove the record of our active
     * traces, and then return.
     */

    done:
    if (code == TCL_ERROR) {
	if (leaveErrMsg) {
	    CONST char *type = "";
	    switch (flags&(TCL_TRACE_READS|TCL_TRACE_WRITES|TCL_TRACE_ARRAY)) {
		case TCL_TRACE_READS: {
		    type = "read";
		    break;
		}
		case TCL_TRACE_WRITES: {
		    type = "set";
		    break;
		}
		case TCL_TRACE_ARRAY: {
		    type = "trace array";
		    break;
		}
	    }
	    if (disposeFlags & TCL_TRACE_RESULT_OBJECT) {
		VarErrMsg((Tcl_Interp *) iPtr, part1, part2, type,
			Tcl_GetString((Tcl_Obj *) result));
	    } else {
		VarErrMsg((Tcl_Interp *) iPtr, part1, part2, type, result);
	    }
	}
	DisposeTraceResult(disposeFlags,result);
    }

    if (arrayPtr != NULL) {
	arrayPtr->refCount--;
    }
    if (copiedName) {
	Tcl_DStringFree(&nameCopy);
    }
    varPtr->flags &= ~VAR_TRACE_ACTIVE;
    varPtr->refCount--;
    iPtr->activeVarTracePtr = active.nextPtr;
    Tcl_Release((ClientData) iPtr);
    return code;
}

/*
 *----------------------------------------------------------------------
 *
 * NewVar --
 *
 *	Create a new heap-allocated variable that will eventually be
 *	entered into a hashtable.
 *
 * Results:
 *	The return value is a pointer to the new variable structure. It is
 *	marked as a scalar variable (and not a link or array variable). Its
 *	value initially is NULL. The variable is not part of any hash table
 *	yet. Since it will be in a hashtable and not in a call frame, its
 *	name field is set NULL. It is initially marked as undefined.
 *
 * Side effects:
 *	Storage gets allocated.
 *
 *----------------------------------------------------------------------
 */

static Var *
NewVar()
{
    register Var *varPtr;

    varPtr = (Var *) ckalloc(sizeof(Var));
    varPtr->value.objPtr = NULL;
    varPtr->name = NULL;
    varPtr->nsPtr = NULL;
    varPtr->hPtr = NULL;
    varPtr->refCount = 0;
    varPtr->tracePtr = NULL;
    varPtr->searchPtr = NULL;
    varPtr->flags = (VAR_SCALAR | VAR_UNDEFINED | VAR_IN_HASHTABLE);
    return varPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * SetArraySearchObj --
 *
 *	This function converts the given tcl object into one that
 *	has the "array search" internal type.
 *
 * Results:
 *	TCL_OK if the conversion succeeded, and TCL_ERROR if it failed
 *	(when an error message will be placed in the interpreter's
 *	result.)
 *
 * Side effects:
 *	Updates the internal type and representation of the object to
 *	make this an array-search object.  See the tclArraySearchType
 *	declaration above for details of the internal representation.
 *
 *----------------------------------------------------------------------
 */

static int
SetArraySearchObj(interp, objPtr)
    Tcl_Interp *interp;
    Tcl_Obj *objPtr;
{
    char *string;
    char *end;
    int id;
    size_t offset;

    /*
     * Get the string representation. Make it up-to-date if necessary.
     */

    string = Tcl_GetString(objPtr);

    /*
     * Parse the id into the three parts separated by dashes.
     */
    if ((string[0] != 's') || (string[1] != '-')) {
	syntax:
	Tcl_AppendResult(interp, "illegal search identifier \"", string,
		"\"", (char *) NULL);
	return TCL_ERROR;
    }
    id = strtoul(string+2, &end, 10);
    if ((end == (string+2)) || (*end != '-')) {
	goto syntax;
    }
    /*
     * Can't perform value check in this context, so place reference
     * to place in string to use for the check in the object instead.
     */
    end++;
    offset = end - string;

    if (objPtr->typePtr != NULL && objPtr->typePtr->freeIntRepProc != NULL) {
	objPtr->typePtr->freeIntRepProc(objPtr);
    }
    objPtr->typePtr = &tclArraySearchType;
    objPtr->internalRep.twoPtrValue.ptr1 = (VOID *)(((char *)NULL)+id);
    objPtr->internalRep.twoPtrValue.ptr2 = (VOID *)(((char *)NULL)+offset);
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * ParseSearchId --
 *
 *	This procedure translates from a tcl object to a pointer to an
 *	active array search (if there is one that matches the string).
 *
 * Results:
 *	The return value is a pointer to the array search indicated
 *	by string, or NULL if there isn't one.  If NULL is returned,
 *	the interp's result contains an error message.
 *
 * Side effects:
 *	The tcl object might have its internal type and representation
 *	modified.
 *
 *----------------------------------------------------------------------
 */

static ArraySearch *
ParseSearchId(interp, varPtr, varName, handleObj)
    Tcl_Interp *interp;		/* Interpreter containing variable. */
    CONST Var *varPtr;		/* Array variable search is for. */
    CONST char *varName;	/* Name of array variable that search is
				 * supposed to be for. */
    Tcl_Obj *handleObj;		/* Object containing id of search. Must have
				 * form "search-num-var" where "num" is a
				 * decimal number and "var" is a variable
				 * name. */
{
    register char *string;
    register size_t offset;
    int id;
    ArraySearch *searchPtr;

    /*
     * Parse the id.
     */
    if (Tcl_ConvertToType(interp, handleObj, &tclArraySearchType) != TCL_OK) {
	return NULL;
    }
    /*
     * Cast is safe, since always came from an int in the first place.
     */
    id = (int)(((char*)handleObj->internalRep.twoPtrValue.ptr1) -
	       ((char*)NULL));
    string = Tcl_GetString(handleObj);
    offset = (((char*)handleObj->internalRep.twoPtrValue.ptr2) -
	      ((char*)NULL));
    /*
     * This test cannot be placed inside the Tcl_Obj machinery, since
     * it is dependent on the variable context.
     */
    if (strcmp(string+offset, varName) != 0) {
	Tcl_AppendResult(interp, "search identifier \"", string,
		"\" isn't for variable \"", varName, "\"", (char *) NULL);
	return NULL;
    }

    /*
     * Search through the list of active searches on the interpreter
     * to see if the desired one exists.
     *
     * Note that we cannot store the searchPtr directly in the Tcl_Obj
     * as that would run into trouble when DeleteSearches() was called
     * so we must scan this list every time.
     */

    for (searchPtr = varPtr->searchPtr; searchPtr != NULL;
	 searchPtr = searchPtr->nextPtr) {
	if (searchPtr->id == id) {
	    return searchPtr;
	}
    }
    Tcl_AppendResult(interp, "couldn't find search \"", string, "\"",
	    (char *) NULL);
    return NULL;
}

/*
 *----------------------------------------------------------------------
 *
 * DeleteSearches --
 *
 *	This procedure is called to free up all of the searches
 *	associated with an array variable.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Memory is released to the storage allocator.
 *
 *----------------------------------------------------------------------
 */

static void
DeleteSearches(arrayVarPtr)
    register Var *arrayVarPtr;		/* Variable whose searches are
					 * to be deleted. */
{
    ArraySearch *searchPtr;

    while (arrayVarPtr->searchPtr != NULL) {
	searchPtr = arrayVarPtr->searchPtr;
	arrayVarPtr->searchPtr = searchPtr->nextPtr;
	ckfree((char *) searchPtr);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * TclDeleteVars --
 *
 *	This procedure is called to recycle all the storage space
 *	associated with a table of variables. For this procedure
 *	to work correctly, it must not be possible for any of the
 *	variables in the table to be accessed from Tcl commands
 *	(e.g. from trace procedures).
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Variables are deleted and trace procedures are invoked, if
 *	any are declared.
 *
 *----------------------------------------------------------------------
 */

void
TclDeleteVars(iPtr, tablePtr)
    Interp *iPtr;		/* Interpreter to which variables belong. */
    Tcl_HashTable *tablePtr;	/* Hash table containing variables to
				 * delete. */
{
    Tcl_Interp *interp = (Tcl_Interp *) iPtr;
    Tcl_HashSearch search;
    Tcl_HashEntry *hPtr;
    register Var *varPtr;
    Var *linkPtr;
    int flags;
    ActiveVarTrace *activePtr;
    Tcl_Obj *objPtr;
    Namespace *currNsPtr = (Namespace *) Tcl_GetCurrentNamespace(interp);

    /*
     * Determine what flags to pass to the trace callback procedures.
     */

    flags = TCL_TRACE_UNSETS;
    if (tablePtr == &iPtr->globalNsPtr->varTable) {
	flags |= TCL_GLOBAL_ONLY;
    } else if (tablePtr == &currNsPtr->varTable) {
	flags |= TCL_NAMESPACE_ONLY;
    }
    if (Tcl_InterpDeleted(interp)) {
	flags |= TCL_INTERP_DESTROYED;
    }

    for (hPtr = Tcl_FirstHashEntry(tablePtr, &search);  hPtr != NULL;
	 hPtr = Tcl_NextHashEntry(&search)) {
	varPtr = (Var *) Tcl_GetHashValue(hPtr);

	/*
	 * For global/upvar variables referenced in procedures, decrement
	 * the reference count on the variable referred to, and free
	 * the referenced variable if it's no longer needed. Don't delete
	 * the hash entry for the other variable if it's in the same table
	 * as us: this will happen automatically later on.
	 */

	if (TclIsVarLink(varPtr)) {
	    linkPtr = varPtr->value.linkPtr;
	    linkPtr->refCount--;
	    if ((linkPtr->refCount == 0) && TclIsVarUndefined(linkPtr)
		    && (linkPtr->tracePtr == NULL)
		    && (linkPtr->flags & VAR_IN_HASHTABLE)) {
		if (linkPtr->hPtr == NULL) {
		    ckfree((char *) linkPtr);
		} else if (linkPtr->hPtr->tablePtr != tablePtr) {
		    Tcl_DeleteHashEntry(linkPtr->hPtr);
		    ckfree((char *) linkPtr);
		}
	    }
	}

	/*
	 * Invoke traces on the variable that is being deleted, then
	 * free up the variable's space (no need to free the hash entry
	 * here, unless we're dealing with a global variable: the
	 * hash entries will be deleted automatically when the whole
	 * table is deleted). Note that we give CallVarTraces the variable's
	 * fully-qualified name so that any called trace procedures can
	 * refer to these variables being deleted.
	 */

	if (varPtr->tracePtr != NULL) {
	    objPtr = Tcl_NewObj();
	    Tcl_IncrRefCount(objPtr); /* until done with traces */
	    Tcl_GetVariableFullName(interp, (Tcl_Var) varPtr, objPtr);
	    CallVarTraces(iPtr, (Var *) NULL, varPtr, Tcl_GetString(objPtr),
		    NULL, flags, /* leaveErrMsg */ 0);
	    Tcl_DecrRefCount(objPtr); /* free no longer needed obj */

	    while (varPtr->tracePtr != NULL) {
		VarTrace *tracePtr = varPtr->tracePtr;
		varPtr->tracePtr = tracePtr->nextPtr;
		Tcl_EventuallyFree((ClientData) tracePtr, TCL_DYNAMIC);
	    }
	    for (activePtr = iPtr->activeVarTracePtr; activePtr != NULL;
		 activePtr = activePtr->nextPtr) {
		if (activePtr->varPtr == varPtr) {
		    activePtr->nextTracePtr = NULL;
		}
	    }
	}
	    
	if (TclIsVarArray(varPtr)) {
	    DeleteArray(iPtr, Tcl_GetHashKey(tablePtr, hPtr), varPtr,
	            flags);
	    varPtr->value.tablePtr = NULL;
	}
	if (TclIsVarScalar(varPtr) && (varPtr->value.objPtr != NULL)) {
	    objPtr = varPtr->value.objPtr;
	    TclDecrRefCount(objPtr);
	    varPtr->value.objPtr = NULL;
	}
	varPtr->hPtr = NULL;
	varPtr->tracePtr = NULL;
	TclSetVarUndefined(varPtr);
	TclSetVarScalar(varPtr);

	/*
	 * If the variable was a namespace variable, decrement its 
	 * reference count. We are in the process of destroying its
	 * namespace so that namespace will no longer "refer" to the
	 * variable.
	 */

	if (varPtr->flags & VAR_NAMESPACE_VAR) {
	    varPtr->flags &= ~VAR_NAMESPACE_VAR;
	    varPtr->refCount--;
	}

	/*
	 * Recycle the variable's memory space if there aren't any upvar's
	 * pointing to it. If there are upvars to this variable, then the
	 * variable will get freed when the last upvar goes away.
	 */

	if (varPtr->refCount == 0) {
	    ckfree((char *) varPtr); /* this Var must be VAR_IN_HASHTABLE */
	}
    }
    Tcl_DeleteHashTable(tablePtr);
}

/*
 *----------------------------------------------------------------------
 *
 * TclDeleteCompiledLocalVars --
 *
 *	This procedure is called to recycle storage space associated with
 *	the compiler-allocated array of local variables in a procedure call
 *	frame. This procedure resembles TclDeleteVars above except that each
 *	variable is stored in a call frame and not a hash table. For this
 *	procedure to work correctly, it must not be possible for any of the
 *	variable in the table to be accessed from Tcl commands (e.g. from
 *	trace procedures).
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Variables are deleted and trace procedures are invoked, if
 *	any are declared.
 *
 *----------------------------------------------------------------------
 */

void
TclDeleteCompiledLocalVars(iPtr, framePtr)
    Interp *iPtr;		/* Interpreter to which variables belong. */
    CallFrame *framePtr;	/* Procedure call frame containing
				 * compiler-assigned local variables to
				 * delete. */
{
    register Var *varPtr;
    int flags;			/* Flags passed to trace procedures. */
    Var *linkPtr;
    ActiveVarTrace *activePtr;
    int numLocals, i;

    flags = TCL_TRACE_UNSETS;
    numLocals = framePtr->numCompiledLocals;
    varPtr = framePtr->compiledLocals;
    for (i = 0;  i < numLocals;  i++) {
	/*
	 * For global/upvar variables referenced in procedures, decrement
	 * the reference count on the variable referred to, and free
	 * the referenced variable if it's no longer needed. Don't delete
	 * the hash entry for the other variable if it's in the same table
	 * as us: this will happen automatically later on.
	 */

	if (TclIsVarLink(varPtr)) {
	    linkPtr = varPtr->value.linkPtr;
	    linkPtr->refCount--;
	    if ((linkPtr->refCount == 0) && TclIsVarUndefined(linkPtr)
		    && (linkPtr->tracePtr == NULL)
		    && (linkPtr->flags & VAR_IN_HASHTABLE)) {
		if (linkPtr->hPtr == NULL) {
		    ckfree((char *) linkPtr);
		} else {
		    Tcl_DeleteHashEntry(linkPtr->hPtr);
		    ckfree((char *) linkPtr);
		}
	    }
	}

	/*
	 * Invoke traces on the variable that is being deleted. Then delete
	 * the variable's trace records.
	 */

	if (varPtr->tracePtr != NULL) {
	    CallVarTraces(iPtr, (Var *) NULL, varPtr, varPtr->name, NULL,
		    flags, /* leaveErrMsg */ 0);
	    while (varPtr->tracePtr != NULL) {
		VarTrace *tracePtr = varPtr->tracePtr;
		varPtr->tracePtr = tracePtr->nextPtr;
		Tcl_EventuallyFree((ClientData) tracePtr, TCL_DYNAMIC);
	    }
	    for (activePtr = iPtr->activeVarTracePtr; activePtr != NULL;
		 activePtr = activePtr->nextPtr) {
		if (activePtr->varPtr == varPtr) {
		    activePtr->nextTracePtr = NULL;
		}
	    }
	}

        /*
	 * Now if the variable is an array, delete its element hash table.
	 * Otherwise, if it's a scalar variable, decrement the ref count
	 * of its value.
	 */
	    
	if (TclIsVarArray(varPtr) && (varPtr->value.tablePtr != NULL)) {
	    DeleteArray(iPtr, varPtr->name, varPtr, flags);
	}
	if (TclIsVarScalar(varPtr) && (varPtr->value.objPtr != NULL)) {
	    TclDecrRefCount(varPtr->value.objPtr);
	    varPtr->value.objPtr = NULL;
	}
	varPtr->hPtr = NULL;
	varPtr->tracePtr = NULL;
	TclSetVarUndefined(varPtr);
	TclSetVarScalar(varPtr);
	varPtr++;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * DeleteArray --
 *
 *	This procedure is called to free up everything in an array
 *	variable.  It's the caller's responsibility to make sure
 *	that the array is no longer accessible before this procedure
 *	is called.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	All storage associated with varPtr's array elements is deleted
 *	(including the array's hash table). Deletion trace procedures for
 *	array elements are invoked, then deleted. Any pending traces for
 *	array elements are also deleted.
 *
 *----------------------------------------------------------------------
 */

static void
DeleteArray(iPtr, arrayName, varPtr, flags)
    Interp *iPtr;			/* Interpreter containing array. */
    CONST char *arrayName;	        /* Name of array (used for trace
					 * callbacks). */
    Var *varPtr;			/* Pointer to variable structure. */
    int flags;				/* Flags to pass to CallVarTraces:
					 * TCL_TRACE_UNSETS and sometimes
					 * TCL_INTERP_DESTROYED,
					 * TCL_NAMESPACE_ONLY, or
					 * TCL_GLOBAL_ONLY. */
{
    Tcl_HashSearch search;
    register Tcl_HashEntry *hPtr;
    register Var *elPtr;
    ActiveVarTrace *activePtr;
    Tcl_Obj *objPtr;

    DeleteSearches(varPtr);
    for (hPtr = Tcl_FirstHashEntry(varPtr->value.tablePtr, &search);
	 hPtr != NULL;  hPtr = Tcl_NextHashEntry(&search)) {
	elPtr = (Var *) Tcl_GetHashValue(hPtr);
	if (TclIsVarScalar(elPtr) && (elPtr->value.objPtr != NULL)) {
	    objPtr = elPtr->value.objPtr;
	    TclDecrRefCount(objPtr);
	    elPtr->value.objPtr = NULL;
	}
	elPtr->hPtr = NULL;
	if (elPtr->tracePtr != NULL) {
	    elPtr->flags &= ~VAR_TRACE_ACTIVE;
	    CallVarTraces(iPtr, (Var *) NULL, elPtr, arrayName,
		    Tcl_GetHashKey(varPtr->value.tablePtr, hPtr), flags,
		    /* leaveErrMsg */ 0);
	    while (elPtr->tracePtr != NULL) {
		VarTrace *tracePtr = elPtr->tracePtr;
		elPtr->tracePtr = tracePtr->nextPtr;
		Tcl_EventuallyFree((ClientData) tracePtr,TCL_DYNAMIC);
	    }
	    for (activePtr = iPtr->activeVarTracePtr; activePtr != NULL;
		 activePtr = activePtr->nextPtr) {
		if (activePtr->varPtr == elPtr) {
		    activePtr->nextTracePtr = NULL;
		}
	    }
	}
	TclSetVarUndefined(elPtr);
	TclSetVarScalar(elPtr);

	/*
	 * Even though array elements are not supposed to be namespace
	 * variables, some combinations of [upvar] and [variable] may
	 * create such beasts - see [Bug 604239]. This is necessary to
	 * avoid leaking the corresponding Var struct, and is otherwise
	 * harmless. 
	 */

	if (elPtr->flags & VAR_NAMESPACE_VAR) {
	    elPtr->flags &= ~VAR_NAMESPACE_VAR;
	    elPtr->refCount--;
	}
	if (elPtr->refCount == 0) {
	    ckfree((char *) elPtr); /* element Vars are VAR_IN_HASHTABLE */
	}
    }
    Tcl_DeleteHashTable(varPtr->value.tablePtr);
    ckfree((char *) varPtr->value.tablePtr);
}

/*
 *----------------------------------------------------------------------
 *
 * CleanupVar --
 *
 *	This procedure is called when it looks like it may be OK to free up
 *	a variable's storage. If the variable is in a hashtable, its Var
 *	structure and hash table entry will be freed along with those of its
 *	containing array, if any. This procedure is called, for example,
 *	when a trace on a variable deletes a variable.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	If the variable (or its containing array) really is dead and in a
 *	hashtable, then its Var structure, and possibly its hash table
 *	entry, is freed up.
 *
 *----------------------------------------------------------------------
 */

static void
CleanupVar(varPtr, arrayPtr)
    Var *varPtr;		/* Pointer to variable that may be a
				 * candidate for being expunged. */
    Var *arrayPtr;		/* Array that contains the variable, or
				 * NULL if this variable isn't an array
				 * element. */
{
    if (TclIsVarUndefined(varPtr) && (varPtr->refCount == 0)
	    && (varPtr->tracePtr == NULL)
	    && (varPtr->flags & VAR_IN_HASHTABLE)) {
	if (varPtr->hPtr != NULL) {
	    Tcl_DeleteHashEntry(varPtr->hPtr);
	}
	ckfree((char *) varPtr);
    }
    if (arrayPtr != NULL) {
	if (TclIsVarUndefined(arrayPtr) && (arrayPtr->refCount == 0)
		&& (arrayPtr->tracePtr == NULL)
	        && (arrayPtr->flags & VAR_IN_HASHTABLE)) {
	    if (arrayPtr->hPtr != NULL) {
		Tcl_DeleteHashEntry(arrayPtr->hPtr);
	    }
	    ckfree((char *) arrayPtr);
	}
    }
}
/*
 *----------------------------------------------------------------------
 *
 * VarErrMsg --
 *
 *      Generate a reasonable error message describing why a variable
 *      operation failed.
 *
 * Results:
 *      None.
 *
 * Side effects:
 *      The interp's result is set to hold a message identifying the
 *      variable given by part1 and part2 and describing why the
 *      variable operation failed.
 *
 *----------------------------------------------------------------------
 */

static void
VarErrMsg(interp, part1, part2, operation, reason)
    Tcl_Interp *interp;         /* Interpreter in which to record message. */
    CONST char *part1;
    CONST char *part2;		/* Variable's two-part name. */
    CONST char *operation;      /* String describing operation that failed,
                                 * e.g. "read", "set", or "unset". */
    CONST char *reason;         /* String describing why operation failed. */
{
    Tcl_ResetResult(interp);
    Tcl_AppendResult(interp, "can't ", operation, " \"", part1,
	    (char *) NULL);
    if (part2 != NULL) {
        Tcl_AppendResult(interp, "(", part2, ")", (char *) NULL);
    }
    Tcl_AppendResult(interp, "\": ", reason, (char *) NULL);
}

/*
 *----------------------------------------------------------------------
 *
 * TclTraceVarExists --
 *
 *	This is called from info exists.  We need to trigger read
 *	and/or array traces because they may end up creating a
 *	variable that doesn't currently exist.
 *
 * Results:
 *	A pointer to the Var structure, or NULL.
 *
 * Side effects:
 *	May fill in error messages in the interp.
 *
 *----------------------------------------------------------------------
 */

Var *
TclVarTraceExists(interp, varName)
    Tcl_Interp *interp;		/* The interpreter */
    CONST char *varName;	/* The variable name */
{
    Var *varPtr;
    Var *arrayPtr;

    /*
     * The choice of "create" flag values is delicate here, and
     * matches the semantics of GetVar.  Things are still not perfect,
     * however, because if you do "info exists x" you get a varPtr
     * and therefore trigger traces.  However, if you do 
     * "info exists x(i)", then you only get a varPtr if x is already
     * known to be an array.  Otherwise you get NULL, and no trace
     * is triggered.  This matches Tcl 7.6 semantics.
     */

    varPtr = TclLookupVar(interp, varName, (char *) NULL,
            0, "access", /*createPart1*/ 0, /*createPart2*/ 1, &arrayPtr);

    if (varPtr == NULL) {
	return NULL;
    }

    if ((varPtr->tracePtr != NULL)
	    || ((arrayPtr != NULL) && (arrayPtr->tracePtr != NULL))) {
	CallVarTraces((Interp *)interp, arrayPtr, varPtr, varName, NULL,
		TCL_TRACE_READS, /* leaveErrMsg */ 0);
    }

    /*
     * If the variable doesn't exist anymore and no-one's using
     * it, then free up the relevant structures and hash table entries.
     */

    if (TclIsVarUndefined(varPtr)) {
	CleanupVar(varPtr, arrayPtr);
	return NULL;
    }

    return varPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * Internal functions for variable name object types --
 *
 *----------------------------------------------------------------------
 */

/* 
 * localVarName -
 *
 * INTERNALREP DEFINITION:
 *   twoPtrValue.ptr1 = pointer to the corresponding Proc 
 *   twoPtrValue.ptr2 = index into locals table
*/

static void 
FreeLocalVarName(objPtr)
    Tcl_Obj *objPtr;
{
    register Proc *procPtr = (Proc *) objPtr->internalRep.twoPtrValue.ptr1;
    procPtr->refCount--;
    if (procPtr->refCount <= 0) {
	TclProcCleanupProc(procPtr);
    }
}

static void
DupLocalVarName(srcPtr, dupPtr)
    Tcl_Obj *srcPtr;
    Tcl_Obj *dupPtr;
{
    register Proc *procPtr = (Proc *) srcPtr->internalRep.twoPtrValue.ptr1;

    dupPtr->internalRep.twoPtrValue.ptr1 = (VOID *) procPtr;
    dupPtr->internalRep.twoPtrValue.ptr2 = srcPtr->internalRep.twoPtrValue.ptr2;
    procPtr->refCount++;
    dupPtr->typePtr = &tclLocalVarNameType;
}

static void
UpdateLocalVarName(objPtr)
    Tcl_Obj *objPtr;
{
    Proc *procPtr = (Proc *) objPtr->internalRep.twoPtrValue.ptr1;
    unsigned int index = (unsigned int) objPtr->internalRep.twoPtrValue.ptr2;
    CompiledLocal *localPtr = procPtr->firstLocalPtr;
    unsigned int nameLen;

    if (localPtr == NULL) {
	goto emptyName;
    }
    while (index--) {
	localPtr = localPtr->nextPtr;
	if (localPtr == NULL) {
	    goto emptyName;
	}
    }

    nameLen = (unsigned int) localPtr->nameLength;
    objPtr->bytes = ckalloc(nameLen + 1);
    memcpy(objPtr->bytes, localPtr->name, nameLen + 1);
    objPtr->length = nameLen;
    return;

    emptyName:
    objPtr->bytes = ckalloc(1);
    *(objPtr->bytes) = '\0';
    objPtr->length = 0;
}

/* 
 * nsVarName -
 *
 * INTERNALREP DEFINITION:
 *   twoPtrValue.ptr1: pointer to the namespace containing the 
 *                     reference.
 *   twoPtrValue.ptr2: pointer to the corresponding Var 
*/

static void 
FreeNsVarName(objPtr)
    Tcl_Obj *objPtr;
{
    register Var *varPtr = (Var *) objPtr->internalRep.twoPtrValue.ptr2;

    varPtr->refCount--;
    if (TclIsVarUndefined(varPtr) && (varPtr->refCount <= 0)) {
	if (TclIsVarLink(varPtr)) {
	    Var *linkPtr = varPtr->value.linkPtr;
	    linkPtr->refCount--;
	    if (TclIsVarUndefined(linkPtr) && (linkPtr->refCount <= 0)) {
		CleanupVar(linkPtr, (Var *) NULL);
	    }
	}
	CleanupVar(varPtr, NULL);
    }
}

static void
DupNsVarName(srcPtr, dupPtr)
    Tcl_Obj *srcPtr;
    Tcl_Obj *dupPtr;
{
    Namespace *nsPtr = (Namespace *) srcPtr->internalRep.twoPtrValue.ptr1;
    register Var *varPtr = (Var *) srcPtr->internalRep.twoPtrValue.ptr2;

    dupPtr->internalRep.twoPtrValue.ptr1 =  (VOID *) nsPtr;
    dupPtr->internalRep.twoPtrValue.ptr2 = (VOID *) varPtr;
    varPtr->refCount++;
    dupPtr->typePtr = &tclNsVarNameType;
}

/* 
 * parsedVarName -
 *
 * INTERNALREP DEFINITION:
 *   twoPtrValue.ptr1 = pointer to the array name Tcl_Obj
 *                      (NULL if scalar)
 *   twoPtrValue.ptr2 = pointer to the element name string
 *                      (owned by this Tcl_Obj), or NULL if 
 *                      it is a scalar variable
 */

static void 
FreeParsedVarName(objPtr)
    Tcl_Obj *objPtr;
{
    register Tcl_Obj *arrayPtr =
	    (Tcl_Obj *) objPtr->internalRep.twoPtrValue.ptr1;
    register char *elem = (char *) objPtr->internalRep.twoPtrValue.ptr2;
    
    if (arrayPtr != NULL) {
	TclDecrRefCount(arrayPtr);
	ckfree(elem);
    }
}

static void
DupParsedVarName(srcPtr, dupPtr)
    Tcl_Obj *srcPtr;
    Tcl_Obj *dupPtr;
{
    register Tcl_Obj *arrayPtr =
	    (Tcl_Obj *) srcPtr->internalRep.twoPtrValue.ptr1;
    register char *elem = (char *) srcPtr->internalRep.twoPtrValue.ptr2;
    char *elemCopy;
    unsigned int elemLen;

    if (arrayPtr != NULL) {
	Tcl_IncrRefCount(arrayPtr);
	elemLen = strlen(elem);
	elemCopy = ckalloc(elemLen+1);
	memcpy(elemCopy, elem, elemLen);
	*(elemCopy + elemLen) = '\0';
	elem = elemCopy;
    }

    dupPtr->internalRep.twoPtrValue.ptr1 = (VOID *) arrayPtr;
    dupPtr->internalRep.twoPtrValue.ptr2 = (VOID *) elem;
    dupPtr->typePtr = &tclParsedVarNameType;
}

static void
UpdateParsedVarName(objPtr)
    Tcl_Obj *objPtr;
{
    Tcl_Obj *arrayPtr = (Tcl_Obj *) objPtr->internalRep.twoPtrValue.ptr1;
    char *part2 = (char *) objPtr->internalRep.twoPtrValue.ptr2;
    char *part1, *p;
    int len1, len2, totalLen;

    if (arrayPtr == NULL) {
	/*
	 * This is a parsed scalar name: what is it
	 * doing here?
	 */
	panic("ERROR: scalar parsedVarName without a string rep.\n");
    }
    part1 = Tcl_GetStringFromObj(arrayPtr, &len1);
    len2 = strlen(part2);
	
    totalLen = len1 + len2 + 2;
    p = ckalloc((unsigned int) totalLen + 1);
    objPtr->bytes = p;
    objPtr->length = totalLen;

    memcpy(p, part1, (unsigned int) len1);
    p += len1;
    *p++ = '(';
    memcpy(p, part2, (unsigned int) len2);
    p += len2;
    *p++ = ')';
    *p   = '\0';
}
@


1.4
log
@touched all sources to ease next import
@
text
@d13 1
d18 1
a18 1
 * RCS: @@(#) $Id: tclVar.c,v 1.7.8.1 2000/04/06 22:38:30 spolk Exp $
d29 11
a39 9
static char *noSuchVar =	"no such variable";
static char *isArray =		"variable is array";
static char *needArray =	"variable isn't array";
static char *noSuchElement =	"no such element in array";
static char *danglingElement =  "upvar refers to element in deleted array";
static char *danglingVar =     "upvar refers to variable in deleted namespace";
static char *badNamespace =	"parent namespace doesn't exist";
static char *missingName =	"missing variable name";
static char *isArrayElement =   "name refers to an element in an array";
d45 3
a47 3
static  char *		CallTraces _ANSI_ARGS_((Interp *iPtr, Var *arrayPtr,
			    Var *varPtr, char *part1, char *part2,
			    int flags));
d52 7
a58 5
			    char *arrayName, Var *varPtr, int flags));
static int		MakeUpvar _ANSI_ARGS_((
			    Interp *iPtr, CallFrame *framePtr,
			    char *otherP1, char *otherP2, int otherFlags,
			    char *myName, int myFlags));
d61 2
a62 1
			    Var *varPtr, char *varName, char *string));
d64 78
a141 2
			    char *part1, char *part2, char *operation,
			    char *reason));
d148 5
a152 2
 *	This procedure is used by virtually all of the variable code to
 *	locate a variable given its name(s).
a180 1

d185 1
a185 1
    register char *part1;	/* If part2 isn't NULL, this is the name of
d189 1
a189 1
    char *part2;		/* Name of element within array, or NULL. */
d192 1
a192 1
    char *msg;			/* Verb to use in error messages, e.g.
d206 2
a207 12
    Interp *iPtr = (Interp *) interp;
    CallFrame *varFramePtr = iPtr->varFramePtr;
				/* Points to the procedure call frame whose
				 * variables are currently in use. Same as
				 * the current procedure's frame, if any,
				 * unless an "uplevel" is executing. */
    Tcl_HashTable *tablePtr;	/* Points to the hashtable, if any, in which
				 * to look up the variable. */
    Tcl_Var var;                /* Used to search for global names. */
    Var *varPtr;		/* Points to the Var structure returned for
    				 * the variable. */
    char *elName;		/* Name of array element or NULL; may be
d209 1
a209 1
    char *openParen, *closeParen;
d211 9
a219 9
				 * array and index, these point to the
				 * parens around the index.  Otherwise they
				 * are NULL. These are needed to restore
				 * the parens after parsing the name. */
    Namespace *varNsPtr, *cxtNsPtr, *dummy1Ptr, *dummy2Ptr;
    ResolverScheme *resPtr;
    Tcl_HashEntry *hPtr;
    register char *p;
    int new, i, result;
d223 1
a223 2
    openParen = closeParen = NULL;
    varNsPtr = NULL;		/* set non-NULL if a nonlocal variable */
d238 1
a238 1
	    openParen = p;
a244 1
		    openParen = NULL;
d248 1
a248 1
		    goto done;
d250 1
a250 3
		closeParen = p;
		*openParen = 0;
		elName = openParen+1;
d252 1
a252 1
		openParen = NULL;
d257 414
d678 1
a678 1
    if ((flags & TCL_GLOBAL_ONLY) != 0 || iPtr->varFramePtr == NULL) {
d688 1
a688 1
            result = (*cxtNsPtr->varResProc)(interp, part1,
d696 1
a696 1
                result = (*resPtr->varResProc)(interp, part1,
d704 1
a704 1
            goto lookupVarPart2;
d706 1
a706 1
            return (Var *) NULL;
d711 1
a711 1
     * Look up part1. Look it up as either a namespace variable or as a
d713 1
a713 1
     * Interpret part1 as a namespace variable if:
d719 1
a719 1
     * Otherwise, if part1 is a local variable, search first in the
d723 1
a723 1
     * If createPart1 and the variable isn't found, create the variable and,
d730 3
a732 2
	    || (strstr(part1, "::") != NULL)) {
	char *tail;
d734 10
d748 1
a748 1
	var = Tcl_FindNamespaceVar(interp, part1, (Tcl_Namespace *) NULL,
d754 2
a755 2
	    if (createPart1) {   /* var wasn't found so create it  */
		TclGetNamespaceForQualName(interp, part1, (Namespace *) NULL,
a756 1

d758 2
a759 4
		    if (flags & TCL_LEAVE_ERR_MSG) {
			VarErrMsg(interp, part1, part2, msg, badNamespace);
		    }
		    goto done;
d762 2
a763 4
		    if (flags & TCL_LEAVE_ERR_MSG) {
			VarErrMsg(interp, part1, part2, msg, missingName);
		    }
		    goto done;
d770 10
d781 2
a782 4
		if (flags & TCL_LEAVE_ERR_MSG) {
		    VarErrMsg(interp, part1, part2, msg, noSuchVar);
		}
		goto done;
d790 1
a790 1
	int part1Len = strlen(part1);
d795 5
a799 5
		if ((part1[0] == localName[0])
		        && (part1Len == localPtr->nameLength)
		        && (strcmp(part1, localName) == 0)) {
		    varPtr = localVarPtr;
		    break;
d805 14
a818 18
	if (varPtr == NULL) {	/* look in the frame's var hash table */
	    tablePtr = varFramePtr->varTablePtr;
	    if (createPart1) {
		if (tablePtr == NULL) {
		    tablePtr = (Tcl_HashTable *)
			ckalloc(sizeof(Tcl_HashTable));
		    Tcl_InitHashTable(tablePtr, TCL_STRING_KEYS);
		    varFramePtr->varTablePtr = tablePtr;
		}
		hPtr = Tcl_CreateHashEntry(tablePtr, part1, &new);
		if (new) {
		    varPtr = NewVar();
		    Tcl_SetHashValue(hPtr, varPtr);
		    varPtr->hPtr = hPtr;
                    varPtr->nsPtr = NULL; /* a local variable */
		} else {
		    varPtr = (Var *) Tcl_GetHashValue(hPtr);
		}
a819 10
		hPtr = NULL;
		if (tablePtr != NULL) {
		    hPtr = Tcl_FindHashEntry(tablePtr, part1);
		}
		if (hPtr == NULL) {
		    if (flags & TCL_LEAVE_ERR_MSG) {
			VarErrMsg(interp, part1, part2, msg, noSuchVar);
		    }
		    goto done;
		}
d822 10
d834 39
d874 21
a894 23
    lookupVarPart2:
    if (openParen != NULL) {
	*openParen = '(';
	openParen = NULL;
    }

    /*
     * If varPtr is a link variable, we have a reference to some variable
     * that was created through an "upvar" or "global" command. Traverse
     * through any links until we find the referenced variable.
     */
	
    while (TclIsVarLink(varPtr)) {
	varPtr = varPtr->value.linkPtr;
    }

    /*
     * If we're not dealing with an array element, return varPtr.
     */
    
    if (elName == NULL) {
        goto done;
    }
d901 2
a902 2
    if (TclIsVarUndefined(varPtr) && !TclIsVarArrayElement(varPtr)) {
	if (!createPart1) {
d904 1
a904 1
		VarErrMsg(interp, part1, part2, msg, noSuchVar);
d906 1
a906 2
	    varPtr = NULL;
	    goto done;
d913 1
a913 1
	if ((varPtr->flags & VAR_IN_HASHTABLE) && (varPtr->hPtr == NULL)) {
d915 1
a915 1
		VarErrMsg(interp, part1, part2, msg, danglingVar);
d917 1
a917 2
	    varPtr = NULL;
	    goto done;
d920 3
a922 3
	TclSetVarArray(varPtr);
	TclClearVarUndefined(varPtr);
	varPtr->value.tablePtr =
d924 2
a925 2
	Tcl_InitHashTable(varPtr->value.tablePtr, TCL_STRING_KEYS);
    } else if (!TclIsVarArray(varPtr)) {
d927 1
a927 1
	    VarErrMsg(interp, part1, part2, msg, needArray);
d929 1
a929 2
	varPtr = NULL;
	goto done;
d931 3
a933 9
    *arrayPtrPtr = varPtr;
    if (closeParen != NULL) {
	*closeParen = 0;
    }
    if (createPart2) {
	hPtr = Tcl_CreateHashEntry(varPtr->value.tablePtr, elName, &new);
	if (closeParen != NULL) {
	    *closeParen = ')';
	}
d935 2
a936 2
	    if (varPtr->searchPtr != NULL) {
		DeleteSearches(varPtr);
d941 1
a941 1
	    varPtr->nsPtr = varNsPtr;
d945 1
a945 4
	hPtr = Tcl_FindHashEntry(varPtr->value.tablePtr, elName);
	if (closeParen != NULL) {
	    *closeParen = ')';
	}
d948 1
a948 1
		VarErrMsg(interp, part1, part2, msg, noSuchElement);
d950 1
a950 2
	    varPtr = NULL;
	    goto done;
d953 1
a953 7
    varPtr = (Var *) Tcl_GetHashValue(hPtr);

    done:
    if (openParen != NULL) {
        *openParen = '(';
    }
    return varPtr;
d978 1
a978 1
char *
d982 1
a982 1
    char *varName;		/* Name of a variable in interp. */
d1013 1
a1013 1
char *
d1017 1
a1017 1
    char *part1;		/* Name of an array (if part2 is non-NULL)
d1019 1
a1019 1
    char *part2;		/* If non-NULL, gives the name of an element
d1033 52
d1118 2
a1119 3
    int flags;			/* OR-ed combination of TCL_GLOBAL_ONLY,
				 * TCL_LEAVE_ERR_MSG, and
				 * TCL_PARSE_PART1 bits. */
d1121 1
d1125 12
a1136 4
    if (part2Ptr != NULL) {
	part2 = Tcl_GetString(part2Ptr);
    } else {
	part2 = NULL;
d1138 2
a1139 2
    
    return Tcl_GetVar2Ex(interp, part1, part2, flags);
d1145 1
a1145 1
 * Tcl_GetVar2Ex --
d1147 3
a1149 2
 *	Return the value of a Tcl variable as a Tcl object, given a
 *	two-part name consisting of array name and element within array.
d1153 3
a1155 4
 *	given by part1Ptr and part2Ptr. If the specified variable doesn't
 *	exist, or if there is a clash in array usage, then NULL is returned
 *	and a message will be left in the interpreter's result if the
 *	TCL_LEAVE_ERR_MSG flag is set.
d1166 1
a1166 1
Tcl_GetVar2Ex(interp, part1, part2, flags)
d1169 4
a1172 1
    char *part1;		/* Name of an array (if part2 is non-NULL)
d1174 1
a1174 1
    char *part2;		/* If non-NULL, gives the name of an element
d1176 1
a1176 1
    int flags;			/* OR-ed combination of TCL_GLOBAL_ONLY,
d1180 1
a1180 9
    register Var *varPtr;
    Var *arrayPtr;
    char *msg;

    varPtr = TclLookupVar(interp, part1, part2, flags, "read",
            /*createPart1*/ 0, /*createPart2*/ 1, &arrayPtr);
    if (varPtr == NULL) {
	return NULL;
    }
d1188 3
a1190 6
	msg = CallTraces(iPtr, arrayPtr, varPtr, part1, part2,
		(flags & (TCL_NAMESPACE_ONLY|TCL_GLOBAL_ONLY)) | TCL_TRACE_READS);
	if (msg != NULL) {
	    if (flags & TCL_LEAVE_ERR_MSG) {
		VarErrMsg(interp, part1, part2, "read", msg);
	    }
d1230 1
a1230 1
 * TclGetIndexedScalar --
d1232 2
a1233 3
 *	Return the Tcl object value of a local scalar variable in the active
 *	procedure, given its index in the procedure's array of compiler
 *	allocated local variables.
d1236 1
a1236 5
 *	The return value points to the current object value of the variable
 *	given by localIndex. If the specified variable doesn't exist, or
 *	there is a clash in array usage, or an error occurs while executing
 *	variable traces, then NULL is returned and a message will be left in
 *	the interpreter's result if leaveErrorMsg is 1.
d1239 1
a1239 3
 *	The ref count for the returned object is _not_ incremented to
 *	reflect the returned reference; if you want to keep a reference to
 *	the object you must increment its ref count yourself.
d1244 7
a1250 9
Tcl_Obj *
TclGetIndexedScalar(interp, localIndex, leaveErrorMsg)
    Tcl_Interp *interp;		/* Command interpreter in which variable is
				 * to be looked up. */
    register int localIndex;	/* Index of variable in procedure's array
				 * of local variables. */
    int leaveErrorMsg;		/* 1 if to leave an error message in
				 * interpreter's result on an error.
				 * Otherwise no error message is left. */
d1252 1
a1252 11
    Interp *iPtr = (Interp *) interp;
    CallFrame *varFramePtr = iPtr->varFramePtr;
				/* Points to the procedure call frame whose
				 * variables are currently in use. Same as
				 * the current procedure's frame, if any,
				 * unless an "uplevel" is executing. */
    Var *compiledLocals = varFramePtr->compiledLocals;
    register Var *varPtr;	/* Points to the variable's in-frame Var
				 * structure. */
    char *varName;		/* Name of the local variable. */
    char *msg;
d1254 4
a1257 43
#ifdef TCL_COMPILE_DEBUG
    int localCt = varFramePtr->procPtr->numCompiledLocals;

    if (compiledLocals == NULL) {
	fprintf(stderr, "\nTclGetIndexedScalar: can't get local %i in frame 0x%x, no compiled locals\n",
		localIndex, (unsigned int) varFramePtr);
	panic("TclGetIndexedScalar: no compiled locals in frame 0x%x",
		(unsigned int) varFramePtr);
    }
    if ((localIndex < 0) || (localIndex >= localCt)) {
	fprintf(stderr, "\nTclGetIndexedScalar: can't get local %i in frame 0x%x with %i locals\n",
		localIndex, (unsigned int) varFramePtr, localCt);
	panic("TclGetIndexedScalar: bad local index %i in frame 0x%x",
		localIndex, (unsigned int) varFramePtr);
    }
#endif /* TCL_COMPILE_DEBUG */
    
    varPtr = &(compiledLocals[localIndex]);
    varName = varPtr->name;

    /*
     * If varPtr is a link variable, we have a reference to some variable
     * that was created through an "upvar" or "global" command, or we have a
     * reference to a variable in an enclosing namespace. Traverse through
     * any links until we find the referenced variable.
     */
	
    while (TclIsVarLink(varPtr)) {
	varPtr = varPtr->value.linkPtr;
    }

    /*
     * Invoke any traces that have been set for the variable.
     */

    if (varPtr->tracePtr != NULL) {
	msg = CallTraces(iPtr, /*arrayPtr*/ NULL, varPtr, varName, NULL,
		TCL_TRACE_READS);
	if (msg != NULL) {
	    if (leaveErrorMsg) {
		VarErrMsg(interp, varName, NULL, "read", msg);
	    }
	    return NULL;
d1259 3
a1261 15
    }

    /*
     * Make sure we're dealing with a scalar variable and not an array, and
     * that the variable exists (isn't undefined).
     */

    if (!TclIsVarScalar(varPtr) || TclIsVarUndefined(varPtr)) {
	if (leaveErrorMsg) {
	    if (TclIsVarArray(varPtr)) {
		msg = isArray;
	    } else {
		msg = noSuchVar;
	    }
	    VarErrMsg(interp, varName, NULL, "read", msg);
d1263 4
d1268 5
a1272 1
	return NULL;
a1273 1
    return varPtr->value.objPtr;
d1279 1
a1279 1
 * TclGetElementOfIndexedArray --
d1281 1
a1281 4
 *	Return the Tcl object value for an element in a local array
 *	variable. The element is named by the object elemPtr while the 
 *	array is specified by its index in the active procedure's array
 *	of compiler allocated local variables.
d1284 7
a1290 5
 *	The return value points to the current object value of the
 *	element. If the specified array or element doesn't exist, or there
 *	is a clash in array usage, or an error occurs while executing
 *	variable traces, then NULL is returned and a message will be left in
 *	the interpreter's result if leaveErrorMsg is 1.
d1293 3
a1295 3
 *	The ref count for the returned object is _not_ incremented to
 *	reflect the returned reference; if you want to keep a reference to
 *	the object you must increment its ref count yourself.
d1300 3
a1302 3
Tcl_Obj *
TclGetElementOfIndexedArray(interp, localIndex, elemPtr, leaveErrorMsg)
    Tcl_Interp *interp;		/* Command interpreter in which variable is
d1304 6
a1309 7
    int localIndex;		/* Index of array variable in procedure's
				 * array of local variables. */
    Tcl_Obj *elemPtr;		/* Points to an object holding the name of
				 * an element to get in the array. */
    int leaveErrorMsg;		/* 1 if to leave an error message in
				 * the interpreter's result on an error.
				 * Otherwise no error message is left. */
d1311 12
a1322 226
    Interp *iPtr = (Interp *) interp;
    CallFrame *varFramePtr = iPtr->varFramePtr;
				/* Points to the procedure call frame whose
				 * variables are currently in use. Same as
				 * the current procedure's frame, if any,
				 * unless an "uplevel" is executing. */
    Var *compiledLocals = varFramePtr->compiledLocals;
    Var *arrayPtr;		/* Points to the array's in-frame Var
				 * structure. */
    char *arrayName;		/* Name of the local array. */
    Tcl_HashEntry *hPtr;
    Var *varPtr = NULL;		/* Points to the element's Var structure
				 * that we return. Initialized to avoid
				 * compiler warning. */
    char *elem, *msg;
    int new;

#ifdef TCL_COMPILE_DEBUG
    Proc *procPtr = varFramePtr->procPtr;
    int localCt = procPtr->numCompiledLocals;

    if (compiledLocals == NULL) {
	fprintf(stderr, "\nTclGetElementOfIndexedArray: can't get element of local %i in frame 0x%x, no compiled locals\n",
		localIndex, (unsigned int) varFramePtr);
	panic("TclGetIndexedScalar: no compiled locals in frame 0x%x",
		(unsigned int) varFramePtr);
    }
    if ((localIndex < 0) || (localIndex >= localCt)) {
	fprintf(stderr, "\nTclGetIndexedScalar: can't get element of local %i in frame 0x%x with %i locals\n",
		localIndex, (unsigned int) varFramePtr, localCt);
	panic("TclGetElementOfIndexedArray: bad local index %i in frame 0x%x",
		localIndex, (unsigned int) varFramePtr);
    }
#endif /* TCL_COMPILE_DEBUG */

    elem = TclGetString(elemPtr);
    arrayPtr = &(compiledLocals[localIndex]);
    arrayName = arrayPtr->name;

    /*
     * If arrayPtr is a link variable, we have a reference to some variable
     * that was created through an "upvar" or "global" command, or we have a
     * reference to a variable in an enclosing namespace. Traverse through
     * any links until we find the referenced variable.
     */
	
    while (TclIsVarLink(arrayPtr)) {
	arrayPtr = arrayPtr->value.linkPtr;
    }

    /*
     * Make sure we're dealing with an array and that the array variable
     * exists (isn't undefined).
     */

    if (!TclIsVarArray(arrayPtr) || TclIsVarUndefined(arrayPtr)) {
	if (leaveErrorMsg) {
	    VarErrMsg(interp, arrayName, elem, "read", noSuchVar);
	}
	goto errorReturn;
    } 

    /*
     * Look up the element. Note that we must create the element (but leave
     * it marked undefined) if it does not already exist. This allows a
     * trace to create new array elements "on the fly" that did not exist
     * before. A trace is always passed a variable for the array element. If
     * the trace does not define the variable, it will be deleted below (at
     * errorReturn) and an error returned.
     */

    hPtr = Tcl_CreateHashEntry(arrayPtr->value.tablePtr, elem, &new);
    if (new) {
	if (arrayPtr->searchPtr != NULL) {
	    DeleteSearches(arrayPtr);
	}
	varPtr = NewVar();
	Tcl_SetHashValue(hPtr, varPtr);
	varPtr->hPtr = hPtr;
	varPtr->nsPtr = varFramePtr->nsPtr;
	TclSetVarArrayElement(varPtr);
    } else {
	varPtr = (Var *) Tcl_GetHashValue(hPtr);
    }

    /*
     * Invoke any traces that have been set for the element variable.
     */

    if ((varPtr->tracePtr != NULL)
            || ((arrayPtr != NULL) && (arrayPtr->tracePtr != NULL))) {
	msg = CallTraces(iPtr, arrayPtr, varPtr, arrayName, elem,
	        TCL_TRACE_READS);
	if (msg != NULL) {
	    if (leaveErrorMsg) {
		VarErrMsg(interp, arrayName, elem, "read", msg);
	    }
	    goto errorReturn;
	}
    }

    /*
     * Return the element if it's an existing scalar variable.
     */
    
    if (TclIsVarScalar(varPtr) && !TclIsVarUndefined(varPtr)) {
	return varPtr->value.objPtr;
    }
    
    if (leaveErrorMsg) {
	if (TclIsVarArray(varPtr)) {
	    msg = isArray;
	} else {
	    msg = noSuchVar;
	}
	VarErrMsg(interp, arrayName, elem, "read", msg);
    }

    /*
     * An error. If the variable doesn't exist anymore and no-one's using
     * it, then free up the relevant structures and hash table entries.
     */

    errorReturn:
    if ((varPtr != NULL) && TclIsVarUndefined(varPtr)) {
	CleanupVar(varPtr, NULL); /* the array is not in a hashtable */
    }
    return NULL;
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_SetObjCmd --
 *
 *	This procedure is invoked to process the "set" Tcl command.
 *	See the user documentation for details on what it does.
 *
 * Results:
 *	A standard Tcl result value.
 *
 * Side effects:
 *	A variable's value may be changed.
 *
 *----------------------------------------------------------------------
 */

	/* ARGSUSED */
int
Tcl_SetObjCmd(dummy, interp, objc, objv)
    ClientData dummy;			/* Not used. */
    register Tcl_Interp *interp;	/* Current interpreter. */
    int objc;				/* Number of arguments. */
    Tcl_Obj *CONST objv[];		/* Argument objects. */
{
    Tcl_Obj *varValueObj;

    if (objc == 2) {
	varValueObj = Tcl_ObjGetVar2(interp, objv[1], NULL, TCL_LEAVE_ERR_MSG);
	if (varValueObj == NULL) {
	    return TCL_ERROR;
	}
	Tcl_SetObjResult(interp, varValueObj);
	return TCL_OK;
    } else if (objc == 3) {

	varValueObj = Tcl_ObjSetVar2(interp, objv[1], NULL, objv[2],
		TCL_LEAVE_ERR_MSG);
	if (varValueObj == NULL) {
	    return TCL_ERROR;
	}
	Tcl_SetObjResult(interp, varValueObj);
	return TCL_OK;
    } else {
	Tcl_WrongNumArgs(interp, 1, objv, "varName ?newValue?");
	return TCL_ERROR;
    }
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_SetVar --
 *
 *	Change the value of a variable.
 *
 * Results:
 *	Returns a pointer to the malloc'ed string which is the character
 *	representation of the variable's new value. The caller must not
 *	modify this string. If the write operation was disallowed then NULL
 *	is returned; if the TCL_LEAVE_ERR_MSG flag is set, then an
 *	explanatory message will be left in the interp's result. Note that the
 *	returned string may not be the same as newValue; this is because
 *	variable traces may modify the variable's value.
 *
 * Side effects:
 *	If varName is defined as a local or global variable in interp,
 *	its value is changed to newValue. If varName isn't currently
 *	defined, then a new global variable by that name is created.
 *
 *----------------------------------------------------------------------
 */

char *
Tcl_SetVar(interp, varName, newValue, flags)
    Tcl_Interp *interp;		/* Command interpreter in which varName is
				 * to be looked up. */
    char *varName;		/* Name of a variable in interp. */
    char *newValue;		/* New value for varName. */
    int flags;			/* Various flags that tell how to set value:
				 * any of TCL_GLOBAL_ONLY,
				 * TCL_NAMESPACE_ONLY, TCL_APPEND_VALUE,
				 * TCL_LIST_ELEMENT, TCL_LEAVE_ERR_MSG. */
{
    return Tcl_SetVar2(interp, varName, (char *) NULL, newValue, flags);
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_SetVar2 --
 *
 *      Given a two-part variable name, which may refer either to a
 *      scalar variable or an element of an array, change the value
 *      of the variable.  If the named scalar or array or element
 *      doesn't exist then create one.
d1341 1
a1341 1
char *
d1345 1
a1345 1
    char *part1;                /* If part2 is NULL, this is name of scalar
d1348 1
a1348 1
    char *part2;                /* Name of an element within an array, or
d1350 1
a1350 1
    char *newValue;             /* New value for variable. */
a1378 54
 * Tcl_ObjSetVar2 --
 *
 *	This function is the same as Tcl_SetVar2Ex below, except the
 *	variable names are passed in Tcl object instead of strings.
 *
 * Results:
 *	Returns a pointer to the Tcl_Obj holding the new value of the
 *	variable. If the write operation was disallowed because an array was
 *	expected but not found (or vice versa), then NULL is returned; if
 *	the TCL_LEAVE_ERR_MSG flag is set, then an explanatory message will
 *	be left in the interpreter's result. Note that the returned object
 *	may not be the same one referenced by newValuePtr; this is because
 *	variable traces may modify the variable's value.
 *
 * Side effects:
 *	The value of the given variable is set. If either the array or the
 *	entry didn't exist then a new variable is created.

 *
 *----------------------------------------------------------------------
 */

Tcl_Obj *
Tcl_ObjSetVar2(interp, part1Ptr, part2Ptr, newValuePtr, flags)
    Tcl_Interp *interp;		/* Command interpreter in which variable is
				 * to be found. */
    register Tcl_Obj *part1Ptr;	/* Points to an object holding the name of
				 * an array (if part2 is non-NULL) or the
				 * name of a variable. */
    register Tcl_Obj *part2Ptr;	/* If non-null, points to an object holding
				 * the name of an element in the array
				 * part1Ptr. */
    Tcl_Obj *newValuePtr;	/* New value for variable. */
    int flags;			/* Various flags that tell how to set value:
				 * any of TCL_GLOBAL_ONLY,
				 * TCL_NAMESPACE_ONLY, TCL_APPEND_VALUE,
				 * TCL_LIST_ELEMENT, TCL_LEAVE_ERR_MSG, or
				 * TCL_PARSE_PART1. */
{
    char *part1, *part2;

    part1 = Tcl_GetString(part1Ptr);
    if (part2Ptr != NULL) {
	part2 = Tcl_GetString(part2Ptr);
    } else {
	part2 = NULL;
    }
    
    return Tcl_SetVar2Ex(interp, part1, part2, newValuePtr, flags);
}

/*
 *----------------------------------------------------------------------
 *
d1418 1
a1418 1
    char *part1;		/* Name of an array (if part2 is non-NULL)
d1420 1
a1420 1
    char *part2;		/* If non-NULL, gives the name of an element
d1428 1
a1428 7
    Interp *iPtr = (Interp *) interp;
    register Var *varPtr;
    Var *arrayPtr;
    Tcl_Obj *oldValuePtr;
    Tcl_Obj *resultPtr = NULL;
    char *bytes;
    int length, result;
d1436 2
a1437 166
    /*
     * If the variable is in a hashtable and its hPtr field is NULL, then we
     * may have an upvar to an array element where the array was deleted
     * or an upvar to a namespace variable whose namespace was deleted.
     * Generate an error (allowing the variable to be reset would screw up
     * our storage allocation and is meaningless anyway).
     */

    if ((varPtr->flags & VAR_IN_HASHTABLE) && (varPtr->hPtr == NULL)) {
	if (flags & TCL_LEAVE_ERR_MSG) {
	    if (TclIsVarArrayElement(varPtr)) {
		VarErrMsg(interp, part1, part2, "set", danglingElement);
	    } else {
		VarErrMsg(interp, part1, part2, "set", danglingVar);
	    }
	}
	return NULL;
    }

    /*
     * It's an error to try to set an array variable itself.
     */

    if (TclIsVarArray(varPtr) && !TclIsVarUndefined(varPtr)) {
	if (flags & TCL_LEAVE_ERR_MSG) {
	    VarErrMsg(interp, part1, part2, "set", isArray);
	}
	return NULL;
    }

    /*
     * At this point, if we were appending, we used to call read traces: we
     * treated append as a read-modify-write. However, it seemed unlikely to
     * us that a real program would be interested in such reads being done
     * during a set operation.
     */

    /*
     * Set the variable's new value. If appending, append the new value to
     * the variable, either as a list element or as a string. Also, if
     * appending, then if the variable's old value is unshared we can modify
     * it directly, otherwise we must create a new copy to modify: this is
     * "copy on write".
     */

    oldValuePtr = varPtr->value.objPtr;
    if (flags & TCL_APPEND_VALUE) {
	if (TclIsVarUndefined(varPtr) && (oldValuePtr != NULL)) {
	    Tcl_DecrRefCount(oldValuePtr);     /* discard old value */
	    varPtr->value.objPtr = NULL;
	    oldValuePtr = NULL;
	}
	if (flags & TCL_LIST_ELEMENT) {	       /* append list element */
	    if (oldValuePtr == NULL) {
		TclNewObj(oldValuePtr);
		varPtr->value.objPtr = oldValuePtr;
		Tcl_IncrRefCount(oldValuePtr); /* since var is referenced */
	    } else if (Tcl_IsShared(oldValuePtr)) {
		varPtr->value.objPtr = Tcl_DuplicateObj(oldValuePtr);
		Tcl_DecrRefCount(oldValuePtr);
		oldValuePtr = varPtr->value.objPtr;
		Tcl_IncrRefCount(oldValuePtr); /* since var is referenced */
	    }
	    result = Tcl_ListObjAppendElement(interp, oldValuePtr,
		    newValuePtr);
	    if (result != TCL_OK) {
		return NULL;
	    }
	} else {		               /* append string */
	    /*
	     * We append newValuePtr's bytes but don't change its ref count.
	     */

	    bytes = Tcl_GetStringFromObj(newValuePtr, &length);
	    if (oldValuePtr == NULL) {
		varPtr->value.objPtr = Tcl_NewStringObj(bytes, length);
		Tcl_IncrRefCount(varPtr->value.objPtr);
	    } else {
		if (Tcl_IsShared(oldValuePtr)) {   /* append to copy */
		    varPtr->value.objPtr = Tcl_DuplicateObj(oldValuePtr);
		    TclDecrRefCount(oldValuePtr);
		    oldValuePtr = varPtr->value.objPtr;
		    Tcl_IncrRefCount(oldValuePtr); /* since var is ref */
		}
		Tcl_AppendObjToObj(oldValuePtr, newValuePtr);
	    }
	}
    } else {
	if (flags & TCL_LIST_ELEMENT) {	       /* set var to list element */
	    int neededBytes, listFlags;

	    /*
	     * We set the variable to the result of converting newValuePtr's
	     * string rep to a list element. We do not change newValuePtr's
	     * ref count.
	     */

	    if (oldValuePtr != NULL) {
		Tcl_DecrRefCount(oldValuePtr); /* discard old value */
	    }
	    bytes = Tcl_GetStringFromObj(newValuePtr, &length);
	    neededBytes = Tcl_ScanElement(bytes, &listFlags);
	    oldValuePtr = Tcl_NewObj();
	    oldValuePtr->bytes = (char *)
		ckalloc((unsigned) (neededBytes + 1));
	    oldValuePtr->length = Tcl_ConvertElement(bytes,
		    oldValuePtr->bytes, listFlags);
	    varPtr->value.objPtr = oldValuePtr;
	    Tcl_IncrRefCount(varPtr->value.objPtr);
	} else if (newValuePtr != oldValuePtr) {
	    varPtr->value.objPtr = newValuePtr;
	    Tcl_IncrRefCount(newValuePtr);      /* var is another ref */
	    if (oldValuePtr != NULL) {
		TclDecrRefCount(oldValuePtr);   /* discard old value */
	    }
	}
    }
    TclSetVarScalar(varPtr);
    TclClearVarUndefined(varPtr);
    if (arrayPtr != NULL) {
	TclClearVarUndefined(arrayPtr);
    }

    /*
     * Invoke any write traces for the variable.
     */

    if ((varPtr->tracePtr != NULL)
	    || ((arrayPtr != NULL) && (arrayPtr->tracePtr != NULL))) {
	char *msg = CallTraces(iPtr, arrayPtr, varPtr, part1, part2,
	        (flags & (TCL_GLOBAL_ONLY|TCL_NAMESPACE_ONLY)) | TCL_TRACE_WRITES);
	if (msg != NULL) {
	    if (flags & TCL_LEAVE_ERR_MSG) {
		VarErrMsg(interp, part1, part2, "set", msg);
	    }
	    goto cleanup;
	}
    }

    /*
     * Return the variable's value unless the variable was changed in some
     * gross way by a trace (e.g. it was unset and then recreated as an
     * array). 
     */

    if (TclIsVarScalar(varPtr) && !TclIsVarUndefined(varPtr)) {
	return varPtr->value.objPtr;
    }

    /*
     * A trace changed the value in some gross way. Return an empty string
     * object.
     */
    
    resultPtr = iPtr->emptyObjPtr;

    /*
     * If the variable doesn't exist anymore and no-one's using it, then
     * free up the relevant structures and hash table entries.
     */

    cleanup:
    if (TclIsVarUndefined(varPtr)) {
	CleanupVar(varPtr, arrayPtr);
    }
    return resultPtr;
d1443 1
a1443 1
 * TclSetIndexedScalar --
d1445 2
a1446 3
 *	Change the Tcl object value of a local scalar variable in the active
 *	procedure, given its compile-time allocated index in the procedure's
 *	array of local variables.
d1450 10
a1459 18
 *	variable given by localIndex. If the specified variable doesn't
 *	exist, or there is a clash in array usage, or an error occurs while
 *	executing variable traces, then NULL is returned and a message will
 *	be left in the interpreter's result if leaveErrorMsg is 1. Note
 *	that the returned object may not be the same one referenced by
 *	newValuePtr; this is because variable traces may modify the
 *	variable's value.
 *
 * Side effects:
 *	The value of the given variable is set. The reference count is
 *	decremented for any old value of the variable and incremented for
 *	its new value. If as a result of a variable trace the new value for
 *	the variable is not the same one referenced by newValuePtr, then
 *	newValuePtr's ref count is left unchanged. The ref count for the
 *	returned object is _not_ incremented to reflect the returned
 *	reference; if you want to keep a reference to the object you must
 *	increment its ref count yourself. This procedure does not create
 *	new variables, but only sets those recognized at compile time.
d1465 1
a1465 1
TclSetIndexedScalar(interp, localIndex, newValuePtr, leaveErrorMsg)
d1468 6
a1473 2
    int localIndex;		/* Index of variable in procedure's array
				 * of local variables. */
d1475 4
a1478 3
    int leaveErrorMsg;		/* 1 if to leave an error message in
				 * the interpreter's result on an error.
				 * Otherwise no error message is left. */
d1480 2
a1481 12
    Interp *iPtr = (Interp *) interp;
    CallFrame *varFramePtr = iPtr->varFramePtr;
				/* Points to the procedure call frame whose
				 * variables are currently in use. Same as
				 * the current procedure's frame, if any,
				 * unless an "uplevel" is executing. */
    Var *compiledLocals = varFramePtr->compiledLocals;
    register Var *varPtr;	/* Points to the variable's in-frame Var
				 * structure. */
    char *varName;		/* Name of the local variable. */
    Tcl_Obj *oldValuePtr;
    Tcl_Obj *resultPtr = NULL;
d1483 2
a1484 20
#ifdef TCL_COMPILE_DEBUG
    Proc *procPtr = varFramePtr->procPtr;
    int localCt = procPtr->numCompiledLocals;

    if (compiledLocals == NULL) {
	fprintf(stderr, "\nTclSetIndexedScalar: can't set local %i in frame 0x%x, no compiled locals\n",
		localIndex, (unsigned int) varFramePtr);
	panic("TclSetIndexedScalar: no compiled locals in frame 0x%x",
		(unsigned int) varFramePtr);
    }
    if ((localIndex < 0) || (localIndex >= localCt)) {
	fprintf(stderr, "\nTclSetIndexedScalar: can't set local %i in frame 0x%x with %i locals\n",
		localIndex, (unsigned int) varFramePtr, localCt);
	panic("TclSetIndexedScalar: bad local index %i in frame 0x%x",
		localIndex, (unsigned int) varFramePtr);
    }
#endif /* TCL_COMPILE_DEBUG */
    
    varPtr = &(compiledLocals[localIndex]);
    varName = varPtr->name;
d1486 3
a1488 38
    /*
     * If varPtr is a link variable, we have a reference to some variable
     * that was created through an "upvar" or "global" command, or we have a
     * reference to a variable in an enclosing namespace. Traverse through
     * any links until we find the referenced variable.
     */
	
    while (TclIsVarLink(varPtr)) {
	varPtr = varPtr->value.linkPtr;
    }

    /*
     * If the variable is in a hashtable and its hPtr field is NULL, then we
     * may have an upvar to an array element where the array was deleted
     * or an upvar to a namespace variable whose namespace was deleted.
     * Generate an error (allowing the variable to be reset would screw up
     * our storage allocation and is meaningless anyway).
     */

    if ((varPtr->flags & VAR_IN_HASHTABLE) && (varPtr->hPtr == NULL)) {
	if (leaveErrorMsg) {
	    if (TclIsVarArrayElement(varPtr)) {
		VarErrMsg(interp, varName, NULL, "set", danglingElement);
	    } else {
		VarErrMsg(interp, varName, NULL, "set", danglingVar);
	    }
	}
	return NULL;
    }

    /*
     * It's an error to try to set an array variable itself.
     */

    if (TclIsVarArray(varPtr) && !TclIsVarUndefined(varPtr)) {
	if (leaveErrorMsg) {
	    VarErrMsg(interp, varName, NULL, "set", isArray);
	}
d1491 3
a1493 55

    /*
     * Set the variable's new value and discard its old value. We don't
     * append with this "set" procedure so the old value isn't needed.
     */

    oldValuePtr = varPtr->value.objPtr;
    if (newValuePtr != oldValuePtr) {        /* set new value */
	varPtr->value.objPtr = newValuePtr;
	Tcl_IncrRefCount(newValuePtr);       /* var is another ref to obj */
	if (oldValuePtr != NULL) {
	    TclDecrRefCount(oldValuePtr);    /* discard old value */
	}
    }
    TclSetVarScalar(varPtr);
    TclClearVarUndefined(varPtr);

    /*
     * Invoke any write traces for the variable.
     */

    if (varPtr->tracePtr != NULL) {
	char *msg = CallTraces(iPtr, /*arrayPtr*/ NULL, varPtr,
	        varName, (char *) NULL, TCL_TRACE_WRITES);
	if (msg != NULL) {
	    if (leaveErrorMsg) {
		VarErrMsg(interp, varName, NULL, "set", msg);
	    }
	    goto cleanup;
	}
    }

    /*
     * Return the variable's value unless the variable was changed in some
     * gross way by a trace (e.g. it was unset and then recreated as an
     * array). If it was changed is a gross way, just return an empty string
     * object.
     */

    if (TclIsVarScalar(varPtr) && !TclIsVarUndefined(varPtr)) {
	return varPtr->value.objPtr;
    }
    
    resultPtr = Tcl_NewObj();

    /*
     * If the variable doesn't exist anymore and no-one's using it, then
     * free up the relevant structures and hash table entries.
     */

    cleanup:
    if (TclIsVarUndefined(varPtr)) {
	CleanupVar(varPtr, NULL);
    }
    return resultPtr;
d1496 1
d1500 1
a1500 1
 * TclSetElementOfIndexedArray --
d1502 3
a1504 4
 *	Change the Tcl object value of an element in a local array
 *	variable. The element is named by the object elemPtr while the array
 *	is specified by its index in the active procedure's array of
 *	compiler allocated local variables.
d1508 11
a1518 19
 *	element. If the specified array or element doesn't exist, or there
 *	is a clash in array usage, or an error occurs while executing
 *	variable traces, then NULL is returned and a message will be left in
 *	the interpreter's result if leaveErrorMsg is 1. Note that the
 *	returned object may not be the same one referenced by newValuePtr;
 *	this is because variable traces may modify the variable's value.
 *
 * Side effects:
 *	The value of the given array element is set. The reference count is
 *	decremented for any old value of the element and incremented for its
 *	new value. If as a result of a variable trace the new value for the
 *	element is not the same one referenced by newValuePtr, then
 *	newValuePtr's ref count is left unchanged. The ref count for the
 *	returned object is _not_ incremented to reflect the returned
 *	reference; if you want to keep a reference to the object you must
 *	increment its ref count yourself. This procedure will not create new
 *	array variables, but only sets elements of those arrays recognized
 *	at compile time. However, if the entry doesn't exist then a new
 *	variable is created.
d1524 9
a1532 8
TclSetElementOfIndexedArray(interp, localIndex, elemPtr, newValuePtr,
        leaveErrorMsg)
    Tcl_Interp *interp;		/* Command interpreter in which the array is
				 * to be found. */
    int localIndex;		/* Index of array variable in procedure's
				 * array of local variables. */
    Tcl_Obj *elemPtr;		/* Points to an object holding the name of
				 * an element to set in the array. */
d1534 2
a1535 3
    int leaveErrorMsg;		/* 1 if to leave an error message in
				 * the interpreter's result on an error.
				 * Otherwise no error message is left. */
d1538 1
a1538 13
    CallFrame *varFramePtr = iPtr->varFramePtr;
				/* Points to the procedure call frame whose
				 * variables are currently in use. Same as
				 * the current procedure's frame, if any,
				 * unless an "uplevel" is executing. */
    Var *compiledLocals = varFramePtr->compiledLocals;
    Var *arrayPtr;		/* Points to the array's in-frame Var
				 * structure. */
    char *arrayName;		/* Name of the local array. */
    char *elem;
    Tcl_HashEntry *hPtr;
    Var *varPtr = NULL;		/* Points to the element's Var structure
				 * that we return. */
d1540 1
a1540 35
    Tcl_Obj *oldValuePtr;
    int new;
    
#ifdef TCL_COMPILE_DEBUG
    Proc *procPtr = varFramePtr->procPtr;
    int localCt = procPtr->numCompiledLocals;

    if (compiledLocals == NULL) {
	fprintf(stderr, "\nTclSetElementOfIndexedArray: can't set element of local %i in frame 0x%x, no compiled locals\n",
		localIndex, (unsigned int) varFramePtr);
	panic("TclSetIndexedScalar: no compiled locals in frame 0x%x",
		(unsigned int) varFramePtr);
    }
    if ((localIndex < 0) || (localIndex >= localCt)) {
	fprintf(stderr, "\nTclSetIndexedScalar: can't set elememt of local %i in frame 0x%x with %i locals\n",
		localIndex, (unsigned int) varFramePtr, localCt);
	panic("TclSetElementOfIndexedArray: bad local index %i in frame 0x%x",
		localIndex, (unsigned int) varFramePtr);
    }
#endif /* TCL_COMPILE_DEBUG */

    elem = TclGetString(elemPtr);
    arrayPtr = &(compiledLocals[localIndex]);
    arrayName = arrayPtr->name;

    /*
     * If arrayPtr is a link variable, we have a reference to some variable
     * that was created through an "upvar" or "global" command, or we have a
     * reference to a variable in an enclosing namespace. Traverse through
     * any links until we find the referenced variable.
     */
	
    while (TclIsVarLink(arrayPtr)) {
	arrayPtr = arrayPtr->value.linkPtr;
    }
d1550 4
a1553 4
    if ((arrayPtr->flags & VAR_IN_HASHTABLE) && (arrayPtr->hPtr == NULL)) {
	if (leaveErrorMsg) {
	    if (TclIsVarArrayElement(arrayPtr)) {
		VarErrMsg(interp, arrayName, elem, "set", danglingElement);
d1555 1
a1555 1
		VarErrMsg(interp, arrayName, elem, "set", danglingVar);
d1558 1
a1558 1
	goto errorReturn;
d1562 1
a1562 1
     * Make sure we're dealing with an array.
d1565 3
a1567 9
    if (TclIsVarUndefined(arrayPtr) && !TclIsVarArrayElement(arrayPtr)) {
	TclSetVarArray(arrayPtr);
	arrayPtr->value.tablePtr =
	    (Tcl_HashTable *) ckalloc(sizeof(Tcl_HashTable));
	Tcl_InitHashTable(arrayPtr->value.tablePtr, TCL_STRING_KEYS);
	TclClearVarUndefined(arrayPtr);
    } else if (!TclIsVarArray(arrayPtr)) {
	if (leaveErrorMsg) {
	    VarErrMsg(interp, arrayName, elem, "set", needArray);
d1569 2
a1570 2
	goto errorReturn;
    } 
d1573 2
a1574 1
     * Look up the element.
d1577 5
a1581 4
    hPtr = Tcl_CreateHashEntry(arrayPtr->value.tablePtr, elem, &new);
    if (new) {
	if (arrayPtr->searchPtr != NULL) {
	    DeleteSearches(arrayPtr);
a1582 5
	varPtr = NewVar();
	Tcl_SetHashValue(hPtr, varPtr);
	varPtr->hPtr = hPtr;
        varPtr->nsPtr = varFramePtr->nsPtr;
	TclSetVarArrayElement(varPtr);
a1583 1
    varPtr = (Var *) Tcl_GetHashValue(hPtr);
d1586 5
a1590 1
     * It's an error to try to set an array variable itself.
d1593 6
a1598 3
    if (TclIsVarArray(varPtr)) {
	if (leaveErrorMsg) {
	    VarErrMsg(interp, arrayName, elem, "set", isArray);
d1600 20
a1619 2
	goto errorReturn;
    }
d1621 18
a1638 4
    /*
     * Set the variable's new value and discard the old one. We don't
     * append with this "set" procedure so the old value isn't needed.
     */
a1639 2
    oldValuePtr = varPtr->value.objPtr;
    if (newValuePtr != oldValuePtr) {	     /* set new value */
d1641 1
a1641 1
	Tcl_IncrRefCount(newValuePtr);       /* var is another ref to obj */
d1643 1
a1643 1
	    TclDecrRefCount(oldValuePtr);    /* discard old value */
d1648 3
d1653 1
a1653 1
     * Invoke any write traces for the element variable.
d1658 4
a1661 7
	char *msg = CallTraces(iPtr, arrayPtr, varPtr, arrayName, elem,
		TCL_TRACE_WRITES);
	if (msg != NULL) {
	    if (leaveErrorMsg) {
		VarErrMsg(interp, arrayName, elem, "set", msg);
	    }
	    goto errorReturn;
d1666 3
a1668 3
     * Return the element's value unless it was changed in some gross way by
     * a trace (e.g. it was unset and then recreated as an array). If it was
     * changed is a gross way, just return an empty string object.
d1674 5
d1680 1
a1680 1
    resultPtr = Tcl_NewObj();
d1683 2
a1684 2
     * An error. If the variable doesn't exist anymore and no-one's using
     * it, then free up the relevant structures and hash table entries.
d1687 3
a1689 5
    errorReturn:
    if (varPtr != NULL) {
	if (TclIsVarUndefined(varPtr)) {
	    CleanupVar(varPtr, NULL); /* note: array isn't in hashtable */
	}
d1736 5
a1740 7
    register Tcl_Obj *varValuePtr;
    Tcl_Obj *resultPtr;
    int createdNewObj;		/* Set 1 if var's value object is shared
				 * so we must increment a copy (i.e. copy
				 * on write). */
    long i;
    int result;
d1742 3
a1744 2
    varValuePtr = Tcl_ObjGetVar2(interp, part1Ptr, part2Ptr, flags);
    if (varValuePtr == NULL) {
d1749 2
a1750 31

    /*
     * Increment the variable's value. If the object is unshared we can
     * modify it directly, otherwise we must create a new copy to modify:
     * this is "copy on write". Then free the variable's old string
     * representation, if any, since it will no longer be valid.
     */

    createdNewObj = 0;
    if (Tcl_IsShared(varValuePtr)) {
	varValuePtr = Tcl_DuplicateObj(varValuePtr);
	createdNewObj = 1;
    }
    result = Tcl_GetLongFromObj(interp, varValuePtr, &i);
    if (result != TCL_OK) {
	if (createdNewObj) {
	    Tcl_DecrRefCount(varValuePtr); /* free unneeded copy */
	}
	return NULL;
    }
    Tcl_SetLongObj(varValuePtr, (i + incrAmount));

    /*
     * Store the variable's new value and run any write traces.
     */
    
    resultPtr = Tcl_ObjSetVar2(interp, part1Ptr, part2Ptr, varValuePtr, flags);
    if (resultPtr == NULL) {
	return NULL;
    }
    return resultPtr;
d1756 1
a1756 1
 * TclIncrIndexedScalar --
d1758 3
a1760 3
 *	Increments the Tcl object value of a local scalar variable in the
 *	active procedure, given its compile-time allocated index in the
 *	procedure's array of local variables.
d1764 4
a1767 4
 *	variable given by localIndex. If the specified variable doesn't
 *	exist, or there is a clash in array usage, or an error occurs while
 *	executing variable traces, then NULL is returned and a message will
 *	be left in the interpreter's result. 
d1771 4
a1774 3
 *	amount. The ref count for the returned object is _not_ incremented
 *	to reflect the returned reference; if you want to keep a reference
 *	to the object you must increment its ref count yourself.
d1780 1
a1780 1
TclIncrIndexedScalar(interp, localIndex, incrAmount)
d1783 13
a1795 3
    int localIndex;		/* Index of variable in procedure's array
				 * of local variables. */
    long incrAmount;		/* Amount to be added to variable. */
a1797 1
    Tcl_Obj *resultPtr;
a1801 1
    int result;
d1803 2
a1804 2
    varValuePtr = TclGetIndexedScalar(interp, localIndex,
	    /*leaveErrorMsg*/ 1);
d1812 4
a1815 5
     * Reach into the object's representation to extract and increment the
     * variable's value. If the object is unshared we can modify it
     * directly, otherwise we must create a new copy to modify: this is
     * "copy on write". Then free the variable's old string representation,
     * if any, since it will no longer be valid.
d1820 1
a1821 1
	varValuePtr = Tcl_DuplicateObj(varValuePtr);
d1823 2
a1824 2
    result = Tcl_GetLongFromObj(interp, varValuePtr, &i);
    if (result != TCL_OK) {
d1831 23
a1853 83

    /*
     * Store the variable's new value and run any write traces.
     */
    
    resultPtr = TclSetIndexedScalar(interp, localIndex, varValuePtr,
	    /*leaveErrorMsg*/ 1);
    if (resultPtr == NULL) {
	return NULL;
    }
    return resultPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * TclIncrElementOfIndexedArray --
 *
 *	Increments the Tcl object value of an element in a local array
 *	variable. The element is named by the object elemPtr while the array
 *	is specified by its index in the active procedure's array of
 *	compiler allocated local variables.
 *
 * Results:
 *	Returns a pointer to the Tcl_Obj holding the new value of the
 *	element. If the specified array or element doesn't exist, or there
 *	is a clash in array usage, or an error occurs while executing
 *	variable traces, then NULL is returned and a message will be left in
 *	the interpreter's result.
 *
 * Side effects:
 *	The value of the given array element is incremented by the specified
 *	amount. The ref count for the returned object is _not_ incremented
 *	to reflect the returned reference; if you want to keep a reference
 *	to the object you must increment its ref count yourself. If the
 *	entry doesn't exist then a new variable is created.
 *
 *----------------------------------------------------------------------
 */

Tcl_Obj *
TclIncrElementOfIndexedArray(interp, localIndex, elemPtr, incrAmount)
    Tcl_Interp *interp;		/* Command interpreter in which the array is
				 * to be found. */
    int localIndex;		/* Index of array variable in procedure's
				 * array of local variables. */
    Tcl_Obj *elemPtr;		/* Points to an object holding the name of
				 * an element to increment in the array. */
    long incrAmount;		/* Amount to be added to variable. */
{
    register Tcl_Obj *varValuePtr;
    Tcl_Obj *resultPtr;
    int createdNewObj;		/* Set 1 if var's value object is shared
				 * so we must increment a copy (i.e. copy
				 * on write). */
    long i;
    int result;

    varValuePtr = TclGetElementOfIndexedArray(interp, localIndex, elemPtr,
	    /*leaveErrorMsg*/ 1);
    if (varValuePtr == NULL) {
	Tcl_AddObjErrorInfo(interp,
		"\n    (reading value of variable to increment)", -1);
	return NULL;
    }

    /*
     * Reach into the object's representation to extract and increment the
     * variable's value. If the object is unshared we can modify it
     * directly, otherwise we must create a new copy to modify: this is
     * "copy on write". Then free the variable's old string representation,
     * if any, since it will no longer be valid.
     */

    createdNewObj = 0;
    if (Tcl_IsShared(varValuePtr)) {
	createdNewObj = 1;
	varValuePtr = Tcl_DuplicateObj(varValuePtr);
    }
    result = Tcl_GetLongFromObj(interp, varValuePtr, &i);
    if (result != TCL_OK) {
	if (createdNewObj) {
	    Tcl_DecrRefCount(varValuePtr); /* free unneeded copy */
a1854 1
	return NULL;
d1856 2
a1857 2
    Tcl_SetLongObj(varValuePtr, (i + incrAmount));
    
d1862 2
a1863 7
    resultPtr = TclSetElementOfIndexedArray(interp, localIndex, elemPtr,
	    varValuePtr,
	    /*leaveErrorMsg*/ 1);
    if (resultPtr == NULL) {
	return NULL;
    }
    return resultPtr;
d1890 1
a1890 1
    char *varName;		/* Name of a variable in interp.  May be
d1925 45
a1969 2
    char *part1;		/* Name of variable or array. */
    char *part2;		/* Name of element within array or NULL. */
d1981 1
d1983 2
a1984 1
    varPtr = TclLookupVar(interp, part1, part2, flags, "unset",
d1989 1
d2020 1
a2020 1
     * 1. We need to increment varPtr's refCount around this: CallTraces
d2030 3
a2032 2
	(void) CallTraces(iPtr, arrayPtr, &dummyVar, part1, part2,
		(flags & (TCL_GLOBAL_ONLY|TCL_NAMESPACE_ONLY)) | TCL_TRACE_UNSETS);
d2036 1
a2036 1
	    ckfree((char *) tracePtr);
d2038 1
a2038 1
	for (activePtr = iPtr->activeTracePtr;  activePtr != NULL;
d2070 2
a2071 1
		(flags & (TCL_GLOBAL_ONLY|TCL_NAMESPACE_ONLY)) | TCL_TRACE_UNSETS);
d2137 1
a2137 1
    char *varName;		/* Name of variable;  may end with "(index)"
d2176 2
a2177 2
    char *part1;		/* Name of scalar variable or array. */
    char *part2;		/* Name of element within array;  NULL means
d2190 11
a2200 2

    varPtr = TclLookupVar(interp, part1, part2, (flags | TCL_LEAVE_ERR_MSG),
d2207 9
d2219 5
d2225 5
a2229 7
    tracePtr->traceProc = proc;
    tracePtr->clientData = clientData;
    tracePtr->flags = 
	flags & (TCL_TRACE_READS | TCL_TRACE_WRITES | TCL_TRACE_UNSETS | 
		TCL_TRACE_ARRAY);
    tracePtr->nextPtr = varPtr->tracePtr;
    varPtr->tracePtr = tracePtr;
d2254 1
a2254 1
    char *varName;		/* Name of variable; may end with "(index)"
d2288 2
a2289 2
    char *part1;		/* Name of variable or array. */
    char *part2;		/* Name of element within array;  NULL means
d2305 8
a2312 3

    varPtr = TclLookupVar(interp, part1, part2,
	    flags & (TCL_GLOBAL_ONLY|TCL_NAMESPACE_ONLY),
d2319 11
a2329 2
    flags &= (TCL_TRACE_READS | TCL_TRACE_WRITES | TCL_TRACE_UNSETS |
	    TCL_TRACE_ARRAY);
d2344 1
a2344 1
     * processed by CallTraces.
d2347 1
a2347 1
    for (activePtr = iPtr->activeTracePtr;  activePtr != NULL;
d2358 1
a2358 1
    ckfree((char *) tracePtr);
d2399 1
a2399 1
    char *varName;		/* Name of variable;  may end with "(index)"
d2434 2
a2435 2
    char *part1;		/* Name of variable or array. */
    char *part2;		/* Name of element within array;  NULL means
d2505 1
a2505 1
    register int i;
d2508 3
a2510 2
    if (objc < 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "varName ?varName ...?");
d2512 27
d2540 4
a2543 5
    
    for (i = 1;  i < objc;  i++) {
	name = TclGetString(objv[i]);
	if (Tcl_UnsetVar2(interp, name, (char *) NULL,
		TCL_LEAVE_ERR_MSG) != TCL_OK) {
d2575 3
d2587 1
d2594 16
a2609 3
	for (i = 2;  i < objc;  i++) {
	    varValuePtr = Tcl_ObjSetVar2(interp, objv[1], (Tcl_Obj *) NULL,
		    objv[i], (TCL_APPEND_VALUE | TCL_LEAVE_ERR_MSG));
d2648 2
d2656 1
a2656 2
	newValuePtr = Tcl_ObjGetVar2(interp, objv[1], (Tcl_Obj *) NULL,
		(TCL_LEAVE_ERR_MSG));
d2663 3
a2665 3
	    Tcl_Obj *nullObjPtr = Tcl_NewObj();
	    newValuePtr = Tcl_ObjSetVar2(interp, objv[1], NULL,
		    nullObjPtr, TCL_LEAVE_ERR_MSG);
d2667 1
a2667 1
		Tcl_DecrRefCount(nullObjPtr); /* free unneeded object */
d2684 27
a2710 1
	varValuePtr = Tcl_ObjGetVar2(interp, objv[1], NULL, 0);
d2714 1
a2714 1
	     * exist or it's an array element. If it's new, we will try to
d2718 1
a2718 13
	    char *p, *varName;
	    int nameBytes, i;

	    varName = Tcl_GetStringFromObj(objv[1], &nameBytes);
	    for (i = 0, p = varName;  i < nameBytes;  i++, p++) {
		if (*p == '(') {
		    p = (varName + nameBytes-1);	
		    if (*p == ')') { /* last char is ')' => array ref */
			createVar = 0;
		    }
		    break;
		}
	    }
d2739 1
a2739 1
	listRepPtr = (List *) varValuePtr->internalRep.otherValuePtr;
d2785 2
a2786 2
	newValuePtr = Tcl_ObjSetVar2(interp, objv[1], NULL, varValuePtr,
		TCL_LEAVE_ERR_MSG);
d2836 2
a2837 2
	  ARRAY_STARTSEARCH, ARRAY_UNSET}; 
    static char *arrayOptions[] = {
d2839 1
a2839 1
	"set", "size", "startsearch", "unset", (char *) NULL
d2845 1
a2845 1
    Tcl_Obj *resultPtr = Tcl_GetObjResult(interp);
d2847 1
a2847 1
    char *varName, *msg;
d2862 1
a2862 1
     * Locate the array variable (and it better be an array).
d2865 3
a2867 2
    varName = TclGetString(objv[2]);
    varPtr = TclLookupVar(interp, varName, (char *) NULL, /*flags*/ 0,
d2870 20
d2897 2
a2898 2
     * Special array trace used to keep the env array in sync for
     * array names, array get, etc.
d2901 1
a2901 9
    if (varPtr != NULL && varPtr->tracePtr != NULL) {
	msg = CallTraces(iPtr, arrayPtr, varPtr, varName, NULL,
		(TCL_LEAVE_ERR_MSG|TCL_NAMESPACE_ONLY|TCL_GLOBAL_ONLY|
		TCL_TRACE_ARRAY));
	if (msg != NULL) {
	    VarErrMsg(interp, varName, NULL, "trace array", msg);
	    return TCL_ERROR;
	}
    }
a2905 1
	    char *searchId;
d2915 1
a2915 2
	    searchId = Tcl_GetString(objv[3]);
	    searchPtr = ParseSearchId(interp, varPtr, varName, searchId);
a2938 1
	    char *searchId;
d2948 1
a2948 2
	    searchId = Tcl_GetString(objv[3]);
	    searchPtr = ParseSearchId(interp, varPtr, varName, searchId);
d2979 2
a2980 1
	    Tcl_Obj *namePtr, *valuePtr;
d2992 8
d3012 1
a3012 1
		result = Tcl_ListObjAppendElement(interp, resultPtr,
d3016 1
d3019 1
d3021 20
d3044 21
a3064 2
		    Tcl_DecrRefCount(namePtr); /* free unneeded name obj */
		    return result;
d3066 1
a3066 2
		result = Tcl_ListObjAppendElement(interp, resultPtr,
			valuePtr);
d3068 1
a3068 2
		    Tcl_DecrRefCount(namePtr); /* free unneeded name obj */
		    return result;
d3071 3
d3075 6
d3088 7
d3096 3
a3098 2
	    if ((objc != 3) && (objc != 4)) {
  	        Tcl_WrongNumArgs(interp, 2, objv, "arrayName ?pattern?");
d3106 7
a3112 1
	    }
d3120 19
a3138 2
		if ((objc == 4) && !Tcl_StringMatch(name, pattern)) {
 		    continue;	/* element name doesn't match pattern */
a3151 1
	    char *searchId;
d3162 1
a3162 2
	    searchId = Tcl_GetString(objv[3]);
	    searchPtr = ParseSearchId(interp, varPtr, varName, searchId);
d3248 21
a3268 1
        case ARRAY_UNSET: {
d3285 1
a3285 1
		if (Tcl_UnsetVar2(interp, varName, (char *) NULL, 0)
d3300 1
a3300 1
			    (Tcl_UnsetVar2(interp, varName, name, 0)
d3344 1
a3344 1
    int result, elemLen, i;
d3347 5
a3351 8
    varName = TclGetString(arrayNameObj);
    for (p = varName; *p ; p++) {
	if (*p == '(') {
	    do {
		p++;
	    } while (*p != '\0');
	    p--;
	    if (*p == ')') {
a3354 1
	    break;
d3358 6
a3363 2
    varPtr = TclLookupVar(interp, varName, (char *) NULL, /*flags*/ 0,
            /*msg*/ 0, /*createPart1*/ 0, /*createPart2*/ 0, &arrayPtr);
d3378 6
d3385 6
a3390 2
		if (Tcl_ObjSetVar2(interp, arrayNameObj, elemPtrs[i],
			elemPtrs[i+1], TCL_LEAVE_ERR_MSG) == NULL) {
a3419 16
    } else {
	/*
	 * Create variable for new array.
	 */
	
	varPtr = TclLookupVar(interp, varName, (char *) NULL,
		TCL_LEAVE_ERR_MSG, "set",
	        /*createPart1*/ 1, /*createPart2*/ 0, &arrayPtr);

	/*
	 * Still couldn't do it - this can occur if a non-existent
	 * namespace was specified
	 */
	if (varPtr == NULL) {
	    return TCL_ERROR;
	}
d3432 1
a3432 1
 * MakeUpvar --
d3450 3
a3452 3
MakeUpvar(iPtr, framePtr, otherP1, otherP2, otherFlags, myName, myFlags)
    Interp *iPtr;		/* Interpreter containing variables. Used
				 * for error messages, too. */
d3455 3
a3457 2
    char *otherP1, *otherP2;	/* Two-part name of variable in framePtr. */
    int otherFlags;		/* 0, TCL_GLOBAL_ONLY or TCL_NAMESPACE_ONLY:
d3459 1
a3459 1
    char *myName;		/* Name of variable which will refer to
d3461 1
a3461 1
    int myFlags;		/* 0, TCL_GLOBAL_ONLY or TCL_NAMESPACE_ONLY:
d3463 2
d3466 1
a3466 1
    Tcl_HashEntry *hPtr;
d3469 1
a3469 5
    CallFrame *savedFramePtr = NULL;  /* Init. to avoid compiler warning. */
    Tcl_HashTable *tablePtr;
    Namespace *nsPtr, *altNsPtr, *dummyNsPtr;
    char *tail;
    int new;
d3474 1
a3474 1
     * pointer in the interpreter in order to use TclLookupVar.
d3477 1
a3478 1
	savedFramePtr = iPtr->varFramePtr;
d3481 1
a3481 1
    otherPtr = TclLookupVar((Tcl_Interp *) iPtr, otherP1, otherP2,
d3485 1
a3485 1
	iPtr->varFramePtr = savedFramePtr;
d3491 6
a3496 32
    /*
     * Now create a hashtable entry for "myName". Create it as either a
     * namespace variable or as a local variable in a procedure call
     * frame. Interpret myName as a namespace variable if:
     *    1) so requested by a TCL_GLOBAL_ONLY or TCL_NAMESPACE_ONLY flag,
     *    2) there is no active frame (we're at the global :: scope),
     *    3) the active frame was pushed to define the namespace context
     *       for a "namespace eval" or "namespace inscope" command,
     *    4) the name has namespace qualifiers ("::"s).
     * If creating myName in the active procedure, look first in the
     * frame's array of compiler-allocated local variables, then in its
     * hashtable for runtime-created local variables. Create that
     * procedure's local variable hashtable if necessary.
     */

    varFramePtr = iPtr->varFramePtr;
    if ((myFlags & (TCL_GLOBAL_ONLY | TCL_NAMESPACE_ONLY))
	    || (varFramePtr == NULL)
	    || !varFramePtr->isProcCallFrame
	    || (strstr(myName, "::") != NULL)) {
	TclGetNamespaceForQualName((Tcl_Interp *) iPtr, myName,
		(Namespace *) NULL, myFlags, &nsPtr, &altNsPtr, &dummyNsPtr, &tail);

        if (nsPtr == NULL) {
            nsPtr = altNsPtr;
        }
        if (nsPtr == NULL) {
	    Tcl_AppendResult((Tcl_Interp *) iPtr, "bad variable name \"",
		    myName, "\": unknown namespace", (char *) NULL);
            return TCL_ERROR;
        }
	
d3503 6
a3508 2

	if ((otherP2 ? arrayPtr->nsPtr : otherPtr->nsPtr) == NULL) {
d3510 8
a3517 4
                    myName, "\": upvar won't create namespace variable that refers to procedure variable",
		    (char *) NULL);
            return TCL_ERROR;
        }
d3519 5
a3523 48
	hPtr = Tcl_CreateHashEntry(&nsPtr->varTable, tail, &new);
	if (new) {
	    varPtr = NewVar();
	    Tcl_SetHashValue(hPtr, varPtr);
	    varPtr->hPtr = hPtr;
            varPtr->nsPtr = nsPtr;
	} else {
	    varPtr = (Var *) Tcl_GetHashValue(hPtr);
	}
    } else {			/* look in the call frame */
	Proc *procPtr = varFramePtr->procPtr;
	int localCt = procPtr->numCompiledLocals;
	CompiledLocal *localPtr = procPtr->firstLocalPtr;
	Var *localVarPtr = varFramePtr->compiledLocals;
	int nameLen = strlen(myName);
	int i;

	varPtr = NULL;
	for (i = 0;  i < localCt;  i++) {
	    if (!TclIsVarTemporary(localPtr)) {
		char *localName = localVarPtr->name;
		if ((myName[0] == localName[0])
		        && (nameLen == localPtr->nameLength)
		        && (strcmp(myName, localName) == 0)) {
		    varPtr = localVarPtr;
		    new = 0;
		    break;
		}
	    }
	    localVarPtr++;
	    localPtr = localPtr->nextPtr;
	}
	if (varPtr == NULL) {	/* look in frame's local var hashtable */
	    tablePtr = varFramePtr->varTablePtr;
	    if (tablePtr == NULL) {
		tablePtr = (Tcl_HashTable *) ckalloc(sizeof(Tcl_HashTable));
		Tcl_InitHashTable(tablePtr, TCL_STRING_KEYS);
		varFramePtr->varTablePtr = tablePtr;
	    }
	    hPtr = Tcl_CreateHashEntry(tablePtr, myName, &new);
	    if (new) {
		varPtr = NewVar();
		Tcl_SetHashValue(hPtr, varPtr);
		varPtr->hPtr = hPtr;
                varPtr->nsPtr = varFramePtr->nsPtr;
	    } else {
		varPtr = (Var *) Tcl_GetHashValue(hPtr);
	    }
d3527 11
a3537 1
    if (!new) {
d3539 1
a3539 1
	 * The variable already exists. Make sure this variable "varPtr"
a3544 5
	if (varPtr == otherPtr) {
	    Tcl_SetResult((Tcl_Interp *) iPtr,
		    "can't upvar from variable to itself", TCL_STATIC);
	    return TCL_ERROR;
	}
d3554 1
a3554 1
	} else if (!TclIsVarUndefined(varPtr)) {
a3557 4
	} else if (varPtr->tracePtr != NULL) {
	    Tcl_AppendResult((Tcl_Interp *) iPtr, "variable \"", myName,
		    "\" has traces: can't use for upvar", (char *) NULL);
	    return TCL_ERROR;
d3592 1
a3592 1
    char *frameName;		/* Name of the frame containing the source
d3594 1
a3594 1
    char *varName;		/* Name of a variable in interp to link to.
d3597 1
a3597 1
    char *localName;		/* Name of link variable. */
d3601 1
a3601 37
    int result;
    CallFrame *framePtr;
    register char *p;

    result = TclGetFrame(interp, frameName, &framePtr);
    if (result == -1) {
	return TCL_ERROR;
    }

    /*
     * Figure out whether varName is an array reference, then call
     * MakeUpvar to do all the real work.
     */

    for (p = varName;  *p != '\0';  p++) {
	if (*p == '(') {
	    char *openParen = p;
	    do {
		p++;
	    } while (*p != '\0');
	    p--;
	    if (*p != ')') {
		goto scalar;
	    }
	    *openParen = '\0';
	    *p = '\0';
	    result = MakeUpvar((Interp *) interp, framePtr, varName,
		    openParen+1, 0, localName, flags);
	    *openParen = '(';
	    *p = ')';
	    return result;
	}
    }

    scalar:
    return MakeUpvar((Interp *) interp, framePtr, varName, (char *) NULL,
	    0, localName, flags);
d3629 1
a3629 1
    char *frameName;		/* Name of the frame containing the source
d3631 2
a3632 1
    char *part1, *part2;	/* Two parts of source variable name to
d3634 1
a3634 1
    char *localName;		/* Name of link variable. */
d3640 1
d3642 1
a3642 2
    result = TclGetFrame(interp, frameName, &framePtr);
    if (result == -1) {
d3645 8
a3652 2
    return MakeUpvar((Interp *) interp, framePtr, part1, part2, 0,
	    localName, flags);
d3773 1
a3773 1
        if (*tail == ':') {
d3781 3
a3783 3
	result = MakeUpvar(iPtr, (CallFrame *) NULL,
		varName, (char *) NULL, /*otherFlags*/ TCL_GLOBAL_ONLY,
	        /*myName*/ tail, /*myFlags*/ 0);
d3838 6
d3851 3
a3853 2
	varName = TclGetString(objv[i]);
	varPtr = TclLookupVar(interp, varName, (char *) NULL,
d3890 2
a3891 2
	    varValuePtr = Tcl_ObjSetVar2(interp, objv[i], NULL, objv[i+1],
		    (TCL_NAMESPACE_ONLY | TCL_LEAVE_ERR_MSG));
d3925 2
a3926 2
	    result = MakeUpvar(iPtr, (CallFrame *) NULL,
		    /*otherP1*/ varName, /*otherP2*/ (char *) NULL,
d3928 1
a3928 1
		    /*myName*/ tail, /*myFlags*/ 0);
a3961 1
    register Interp *iPtr = (Interp *) interp;
d3963 1
a3963 2
    char *frameSpec, *otherVarName, *myVarName;
    register char *p;
d3996 3
a3998 28
	myVarName = TclGetString(objv[1]);
	otherVarName = TclGetString(objv[0]);
	for (p = otherVarName;  *p != 0;  p++) {
	    if (*p == '(') {
		char *openParen = p;

		do {
		    p++;
		} while (*p != '\0');
		p--;
		if (*p != ')') {
		    goto scalar;
		}
		*openParen = '\0';
		*p = '\0';
		result = MakeUpvar(iPtr, framePtr,
		        otherVarName, openParen+1, /*otherFlags*/ 0,
			myVarName, /*flags*/ 0);
		*openParen = '(';
		*p = ')';
		goto checkResult;
	    }
	}
	scalar:
	result = MakeUpvar(iPtr, framePtr, otherVarName, (char *) NULL, 0,
	        myVarName, /*flags*/ 0);

	checkResult:
d4009 33
a4041 1
 * CallTraces --
d4049 5
a4053 6
 *	The return value is NULL if no trace procedures were invoked, or
 *	if all the invoked trace procedures returned successfully.
 *	The return value is non-NULL if a trace procedure returned an
 *	error (in this case no more trace procedures were invoked after
 *	the error was returned). In this case the return value is a
 *	pointer to a static string describing the error.
d4062 2
a4063 2
static char *
CallTraces(iPtr, arrayPtr, varPtr, part1, part2, flags)
d4070 2
a4071 1
    char *part1, *part2;	/* Variable's two-part name. */
d4077 3
d4083 2
a4084 1
    char *result, *openParen, *p;
d4087 2
d4096 1
a4096 1
	return NULL;
d4100 3
d4123 2
d4127 4
a4130 4
		    part2 = Tcl_DStringValue(&nameCopy)
			+ (openParen + 1 - part1);
		    part2[-1] = 0;
		    part1 = Tcl_DStringValue(&nameCopy);
d4143 4
a4146 4
    active.nextPtr = iPtr->activeTracePtr;
    iPtr->activeTracePtr = &active;
    if (arrayPtr != NULL) {
	arrayPtr->refCount++;
d4154 1
d4159 2
a4160 1
		    result = NULL;
d4162 2
a4163 1
		    goto done;
d4166 4
d4187 1
d4192 2
a4193 1
		result = NULL;
d4195 2
a4196 1
		goto done;
d4199 4
d4211 27
d4246 3
a4248 2
    iPtr->activeTracePtr = active.nextPtr;
    return result;
d4292 66
d4360 1
a4360 1
 *	This procedure translates from a string to a pointer to an
d4369 2
a4370 1
 *	None.
d4376 1
a4376 1
ParseSearchId(interp, varPtr, varName, string)
d4378 2
a4379 2
    Var *varPtr;		/* Array variable search is for. */
    char *varName;		/* Name of array variable that search is
d4381 1
a4381 1
    char *string;		/* String containing id of search. Must have
d4386 2
a4387 1
    char *end;
d4392 1
a4392 1
     * Parse the id into the three parts separated by dashes.
d4394 1
a4394 5

    if ((string[0] != 's') || (string[1] != '-')) {
	syntax:
	Tcl_AppendResult(interp, "illegal search identifier \"", string,
		"\"", (char *) NULL);
d4397 13
a4409 5
    id = strtoul(string+2, &end, 10);
    if ((end == (string+2)) || (*end != '-')) {
	goto syntax;
    }
    if (strcmp(end+1, varName) != 0) {
d4418 4
d4509 1
a4509 1
	flags |= (TCL_INTERP_DESTROYED | TCL_GLOBAL_ONLY);
d4513 3
d4549 1
a4549 1
	 * table is deleted). Note that we give CallTraces the variable's
d4558 2
a4559 2
	    (void) CallTraces(iPtr, (Var *) NULL, varPtr,
		    Tcl_GetString(objPtr), (char *) NULL, flags);
d4565 1
a4565 1
		ckfree((char *) tracePtr);
d4567 1
a4567 1
	    for (activePtr = iPtr->activeTracePtr; activePtr != NULL;
d4684 2
a4685 2
	    (void) CallTraces(iPtr, (Var *) NULL, varPtr,
		    varPtr->name, (char *) NULL, flags);
d4689 1
a4689 1
		ckfree((char *) tracePtr);
d4691 1
a4691 1
	    for (activePtr = iPtr->activeTracePtr; activePtr != NULL;
d4745 1
a4745 1
    char *arrayName;			/* Name of array (used for trace
d4748 1
a4748 1
    int flags;				/* Flags to pass to CallTraces:
d4772 3
a4774 2
	    (void) CallTraces(iPtr, (Var *) NULL, elPtr, arrayName,
		    Tcl_GetHashKey(varPtr->value.tablePtr, hPtr), flags);
d4778 1
a4778 1
		ckfree((char *) tracePtr);
d4780 1
a4780 1
	    for (activePtr = iPtr->activeTracePtr; activePtr != NULL;
d4789 13
d4881 3
a4883 2
    char *part1, *part2;        /* Variable's two-part name. */
    char *operation;            /* String describing operation that failed,
d4885 1
a4885 1
    char *reason;               /* String describing why operation failed. */
a4894 1

d4917 1
a4917 1
    char *varName;		/* The variable name */
a4920 1
    char *msg;
d4933 2
a4934 2
            0, "access",
            /*createPart1*/ 0, /*createPart2*/ 1, &arrayPtr);
a4937 10
    if ((varPtr != NULL) &&
	    ((varPtr->tracePtr != NULL)
	    || ((arrayPtr != NULL) && (arrayPtr->tracePtr != NULL)))) {
	msg = CallTraces((Interp *)interp, arrayPtr, varPtr, varName,
		(char *) NULL, TCL_TRACE_READS);
	if (msg != NULL) {
	    /*
	     * If the variable doesn't exist anymore and no-one's using
	     * it, then free up the relevant structures and hash table entries.
	     */
d4939 112
a5050 2
	    if (TclIsVarUndefined(varPtr)) {
		CleanupVar(varPtr, arrayPtr);
a5051 1
	    return NULL;
d5053 83
d5137 15
a5151 1
    return varPtr;
@


1.3
log
@touched all sources to ease next import
@
text
@@


1.3.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@a12 1
 * Copyright (c) 2001 by Kevin B. Kenny.  All rights reserved.
d17 1
a17 1
 * RCS: @@(#) $Id: tclVar.c,v 1.68 2002/10/17 17:41:44 dgp Exp $
d28 9
a36 11
static CONST char *noSuchVar =		"no such variable";
static CONST char *isArray =		"variable is array";
static CONST char *needArray =		"variable isn't array";
static CONST char *noSuchElement =	"no such element in array";
static CONST char *danglingElement =
				"upvar refers to element in deleted array";
static CONST char *danglingVar =	
				"upvar refers to variable in deleted namespace";
static CONST char *badNamespace =	"parent namespace doesn't exist";
static CONST char *missingName =	"missing variable name";
static CONST char *isArrayElement =	"name refers to an element in an array";
d42 3
a44 3
static int		CallVarTraces _ANSI_ARGS_((Interp *iPtr, Var *arrayPtr,
			    Var *varPtr, CONST char *part1, CONST char *part2,
			    int flags, CONST int leaveErrMsg));
d49 5
a53 7
			    CONST char *arrayName, Var *varPtr, int flags));
static void		DisposeTraceResult _ANSI_ARGS_((int flags,
			    char *result));
static int              ObjMakeUpvar _ANSI_ARGS_((Tcl_Interp *interp, 
                            CallFrame *framePtr, Tcl_Obj *otherP1Ptr, 
                            CONST char *otherP2, CONST int otherFlags,
		            CONST char *myName, CONST int myFlags, int index));
d56 1
a56 2
			    CONST Var *varPtr, CONST char *varName,
			    Tcl_Obj *handleObj));
d58 2
a59 78
			    CONST char *part1, CONST char *part2,
			    CONST char *operation, CONST char *reason));
static int		SetArraySearchObj _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_Obj *objPtr));


/*
 * Functions defined in this file that may be exported in the future
 * for use by the bytecode compiler and engine or to the public interface.
 */

Var *		TclLookupSimpleVar _ANSI_ARGS_((Tcl_Interp *interp,
		    CONST char *varName, int flags, CONST int create,
		    CONST char **errMsgPtr, int *indexPtr));
int		TclObjUnsetVar2 _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Obj *part1Ptr, CONST char *part2, int flags));

static Tcl_FreeInternalRepProc FreeLocalVarName;
static Tcl_DupInternalRepProc DupLocalVarName;
static Tcl_UpdateStringProc UpdateLocalVarName;
static Tcl_FreeInternalRepProc FreeNsVarName;
static Tcl_DupInternalRepProc DupNsVarName;
static Tcl_FreeInternalRepProc FreeParsedVarName;
static Tcl_DupInternalRepProc DupParsedVarName;
static Tcl_UpdateStringProc UpdateParsedVarName;

/*
 * Types of Tcl_Objs used to cache variable lookups.
 *
 * 
 * localVarName - INTERNALREP DEFINITION:
 *   twoPtrValue.ptr1 = pointer to the corresponding Proc 
 *   twoPtrValue.ptr2 = index into locals table
 *
 * nsVarName - INTERNALREP DEFINITION:
 *   twoPtrValue.ptr1: pointer to the namespace containing the 
 *                     reference
 *   twoPtrValue.ptr2: pointer to the corresponding Var 
 *
 * parsedVarName - INTERNALREP DEFINITION:
 *   twoPtrValue.ptr1 = pointer to the array name Tcl_Obj, 
 *                      or NULL if it is a scalar variable
 *   twoPtrValue.ptr2 = pointer to the element name string
 *                      (owned by this Tcl_Obj), or NULL if 
 *                      it is a scalar variable
 */

Tcl_ObjType tclLocalVarNameType = {
    "localVarName",
    FreeLocalVarName, DupLocalVarName, UpdateLocalVarName, NULL
};

Tcl_ObjType tclNsVarNameType = {
    "namespaceVarName",
    FreeNsVarName, DupNsVarName, NULL, NULL
};

Tcl_ObjType tclParsedVarNameType = {
    "parsedVarName",
    FreeParsedVarName, DupParsedVarName, UpdateParsedVarName, NULL
};

/*
 * Type of Tcl_Objs used to speed up array searches.
 *
 * INTERNALREP DEFINITION:
 *   twoPtrValue.ptr1 = searchIdNumber as offset from (char*)NULL
 *   twoPtrValue.ptr2 = variableNameStartInString as offset from (char*)NULL
 *
 * Note that the value stored in ptr2 is the offset into the string of
 * the start of the variable name and not the address of the variable
 * name itself, as this can be safely copied.
 */
Tcl_ObjType tclArraySearchType = {
    "array search",
    NULL, NULL, NULL, SetArraySearchObj
};

d66 2
a67 5
 *	This procedure is used to locate a variable given its name(s). It
 *      has been mostly superseded by TclObjLookupVar, it is now only used 
 *      by the string-based interfaces. It is kept in tcl8.4 mainly because 
 *      it is in the internal stubs table, so that some extension may be 
 *      calling it. 
d96 1
d101 1
a101 1
    CONST char *part1;	        /* If part2 isn't NULL, this is the name of
d105 1
a105 1
    CONST char *part2;		/* Name of element within array, or NULL. */
d108 1
a108 1
    CONST char *msg;			/* Verb to use in error messages, e.g.
d122 12
a133 2
    Var *varPtr;
    CONST char *elName;		/* Name of array element or NULL; may be
d135 1
a135 1
    int openParen, closeParen;
d137 9
a145 9
				 * array and index, these are the offsets to 
				 * the parens around the index.  Otherwise 
				 * they are -1. */
    register CONST char *p;
    CONST char *errMsg = NULL;
    int index;
#define VAR_NAME_BUF_SIZE 26
    char buffer[VAR_NAME_BUF_SIZE];
    char *newVarName = buffer;
d149 2
a150 1
    openParen = closeParen = -1;
d165 1
a165 1
	    openParen = p - part1;
d172 1
d176 1
a176 1
		    return NULL;
d178 3
a180 1
		closeParen = p - part1;
d182 1
a182 1
		openParen = -1;
a186 414
    if (openParen != -1) {
	if (closeParen >= VAR_NAME_BUF_SIZE) {
	    newVarName = ckalloc((unsigned int) (closeParen+1));
	}
	memcpy(newVarName, part1, (unsigned int) closeParen);
	newVarName[openParen] = '\0';
	newVarName[closeParen] = '\0';
	part1 = newVarName;
	elName = newVarName + openParen + 1;
    }

    varPtr = TclLookupSimpleVar(interp, part1, flags, 
            createPart1, &errMsg, &index);
    if (varPtr == NULL) {
	if ((errMsg != NULL) && (flags & TCL_LEAVE_ERR_MSG)) {
	    VarErrMsg(interp, part1, elName, msg, errMsg);
	}
    } else {
	while (TclIsVarLink(varPtr)) {
	    varPtr = varPtr->value.linkPtr;
	}
	if (elName != NULL) {
	    *arrayPtrPtr = varPtr;
	    varPtr = TclLookupArrayElement(interp, part1, elName, flags, 
		    msg, createPart1, createPart2, varPtr);
	}
    }
    if (newVarName != buffer) {
	ckfree(newVarName);
    }

    return varPtr;
	
#undef VAR_NAME_BUF_SIZE
}

/*
 *----------------------------------------------------------------------
 *
 * TclObjLookupVar --
 *
 *	This procedure is used by virtually all of the variable code to
 *	locate a variable given its name(s). The parsing into array/element
 *      components and (if possible) the lookup results are cached in 
 *      part1Ptr, which is converted to one of the varNameTypes.
 *
 * Results:
 *	The return value is a pointer to the variable structure indicated by
 *	part1Ptr and part2, or NULL if the variable couldn't be found. If 
 *      the variable is found, *arrayPtrPtr is filled with the address of the
 *	variable structure for the array that contains the variable (or NULL
 *	if the variable is a scalar). If the variable can't be found and
 *	either createPart1 or createPart2 are 1, a new as-yet-undefined
 *	(VAR_UNDEFINED) variable structure is created, entered into a hash
 *	table, and returned.
 *
 *	If the variable isn't found and creation wasn't specified, or some
 *	other error occurs, NULL is returned and an error message is left in
 *	the interp's result if TCL_LEAVE_ERR_MSG is set in flags. 
 *
 *	Note: it's possible for the variable returned to be VAR_UNDEFINED
 *	even if createPart1 or createPart2 are 1 (these only cause the hash
 *	table entry or array to be created). For example, the variable might
 *	be a global that has been unset but is still referenced by a
 *	procedure, or a variable that has been unset but it only being kept
 *	in existence (if VAR_UNDEFINED) by a trace.
 *
 * Side effects:
 *	New hashtable entries may be created if createPart1 or createPart2
 *	are 1.
 *      The object part1Ptr is converted to one of tclLocalVarNameType, 
 *      tclNsVarNameType or tclParsedVarNameType and caches as much of the
 *      lookup as it can.
 *
 *----------------------------------------------------------------------
 */
Var *
TclObjLookupVar(interp, part1Ptr, part2, flags, msg, createPart1, createPart2,
        arrayPtrPtr)
    Tcl_Interp *interp;		/* Interpreter to use for lookup. */
    register Tcl_Obj *part1Ptr;	/* If part2 isn't NULL, this is the name 
				 * of an array. Otherwise, this is a full 
				 * variable name that could include a parenthesized 
				 * array element. */
    CONST char *part2;		/* Name of element within array, or NULL. */
    int flags;		        /* Only TCL_GLOBAL_ONLY, TCL_NAMESPACE_ONLY,
				 * and TCL_LEAVE_ERR_MSG bits matter. */
    CONST char *msg;		/* Verb to use in error messages, e.g.
				 * "read" or "set". Only needed if
				 * TCL_LEAVE_ERR_MSG is set in flags. */
    CONST int createPart1;	/* If 1, create hash table entry for part 1
				 * of name, if it doesn't already exist. If
				 * 0, return error if it doesn't exist. */
    CONST int createPart2;	/* If 1, create hash table entry for part 2
				 * of name, if it doesn't already exist. If
				 * 0, return error if it doesn't exist. */
    Var **arrayPtrPtr;		/* If the name refers to an element of an
				 * array, *arrayPtrPtr gets filled in with
				 * address of array variable. Otherwise
				 * this is set to NULL. */
{
    Interp *iPtr = (Interp *) interp;
    register Var *varPtr;	/* Points to the variable's in-frame Var
				 * structure. */
    char *part1;
    int index, len1, len2;
    int parsed = 0;
    Tcl_Obj *objPtr;
    Tcl_ObjType *typePtr = part1Ptr->typePtr;
    CONST char *errMsg = NULL;
    CallFrame *varFramePtr = iPtr->varFramePtr;
    Namespace *nsPtr;

    /*
     * If part1Ptr is a tclParsedVarNameType, separate it into the 
     * pre-parsed parts.
     */

    *arrayPtrPtr = NULL;
    if (typePtr == &tclParsedVarNameType) {
	if (part1Ptr->internalRep.twoPtrValue.ptr1 != NULL) {
	    if (part2 != NULL) {
		/*
		 * ERROR: part1Ptr is already an array element, cannot 
		 * specify a part2.
		 */

		if (flags & TCL_LEAVE_ERR_MSG) {
		    part1 = TclGetString(part1Ptr);
		    VarErrMsg(interp, part1, part2, msg, needArray);
		}
		return NULL;
	    }
	    part2 = (char *) part1Ptr->internalRep.twoPtrValue.ptr2;
	    part1Ptr = (Tcl_Obj *) part1Ptr->internalRep.twoPtrValue.ptr1;
	    typePtr = part1Ptr->typePtr;
	}
	parsed = 1;
    }
    part1 = Tcl_GetStringFromObj(part1Ptr, &len1);    

    nsPtr = ((varFramePtr == NULL)? iPtr->globalNsPtr : varFramePtr->nsPtr);
    if (nsPtr->varResProc != NULL || iPtr->resolverPtr != NULL) {
	goto doParse;
    }
    
    if (typePtr == &tclLocalVarNameType) {
	Proc *procPtr = (Proc *) part1Ptr->internalRep.twoPtrValue.ptr1;
	int localIndex = (int) part1Ptr->internalRep.twoPtrValue.ptr2;
	int useLocal;

	useLocal = ((varFramePtr != NULL) && varFramePtr->isProcCallFrame
	        && !(flags & (TCL_GLOBAL_ONLY | TCL_NAMESPACE_ONLY)));
	if (useLocal && (procPtr == varFramePtr->procPtr)) {
	    /*
	     * part1Ptr points to an indexed local variable of the
	     * correct procedure: use the cached value.
	     */
	    
	    varPtr = &(varFramePtr->compiledLocals[localIndex]);
	    goto donePart1;
	}
	goto doneParsing;
    } else if (typePtr == &tclNsVarNameType) {
	Namespace *cachedNsPtr;
	int useGlobal, useReference;

	varPtr = (Var *) part1Ptr->internalRep.twoPtrValue.ptr2;
	cachedNsPtr = (Namespace *) part1Ptr->internalRep.twoPtrValue.ptr1;
	useGlobal = (cachedNsPtr == iPtr->globalNsPtr) 
	    && ((flags & TCL_GLOBAL_ONLY) 
		|| ((*part1 == ':') && (*(part1+1) == ':'))
		|| (varFramePtr == NULL) 
		|| (!varFramePtr->isProcCallFrame 
		    && (nsPtr == iPtr->globalNsPtr)));
	useReference = useGlobal || ((cachedNsPtr == nsPtr) 
	        && ((flags & TCL_NAMESPACE_ONLY) 
		    || (varFramePtr && !varFramePtr->isProcCallFrame 
			&& !(flags & TCL_GLOBAL_ONLY)
			/* careful: an undefined ns variable could
			 * be hiding a valid global reference. */
			&& !(varPtr->flags & VAR_UNDEFINED))));
	if (useReference && (varPtr->hPtr != NULL)) {
	    /*
	     * A straight global or namespace reference, use it. It isn't 
	     * so simple to deal with 'implicit' namespace references, i.e., 
	     * those where the reference could be to either a namespace 
	     * or a global variable. Those we lookup again.
	     *
	     * If (varPtr->hPtr == NULL), this might be a reference to a
	     * variable in a deleted namespace, kept alive by e.g. part1Ptr.
	     * We could conceivably be so unlucky that a new namespace was
	     * created at the same address as the deleted one, so to be 
	     * safe we test for a valid hPtr.
	     */
	    goto donePart1;
	}
	goto doneParsing;
    }

    doParse:
    if (!parsed && (*(part1 + len1 - 1) == ')')) {
	/*
	 * part1Ptr is possibly an unparsed array element.
	 */
	register int i;
	char *newPart2;
	len2 = -1;
	for (i = 0; i < len1; i++) {
	    if (*(part1 + i) == '(') {
		if (part2 != NULL) {
		    if (flags & TCL_LEAVE_ERR_MSG) {
			VarErrMsg(interp, part1, part2, msg, needArray);
		    }
		}			

		/*
		 * part1Ptr points to an array element; first copy 
		 * the element name to a new string part2.
		 */

		part2 = part1 + i + 1;
		len2 = len1 - i - 2;
		len1 = i;

		newPart2 = ckalloc((unsigned int) (len2+1));
		memcpy(newPart2, part2, (unsigned int) len2);
		*(newPart2+len2) = '\0';
		part2 = newPart2;

		/*
		 * Free the internal rep of the original part1Ptr, now
		 * renamed objPtr, and set it to tclParsedVarNameType.
		 */

		objPtr = part1Ptr;
		if ((typePtr != NULL) && (typePtr->freeIntRepProc != NULL)) {
		    typePtr->freeIntRepProc(objPtr);
		}
		objPtr->typePtr = &tclParsedVarNameType;

		/*
		 * Define a new string object to hold the new part1Ptr, i.e., 
		 * the array name. Set the internal rep of objPtr, reset
		 * typePtr and part1 to contain the references to the
		 * array name.
		 */

		part1Ptr = Tcl_NewStringObj(part1, len1);
		Tcl_IncrRefCount(part1Ptr);

		objPtr->internalRep.twoPtrValue.ptr1 = (VOID *) part1Ptr;
		objPtr->internalRep.twoPtrValue.ptr2 = (VOID *) part2;		

		typePtr = part1Ptr->typePtr;
		part1 = TclGetString(part1Ptr);
		break;
	    }
	}
    }
    
    doneParsing:
    /*
     * part1Ptr is not an array element; look it up, and convert 
     * it to one of the cached types if possible.
     */

    if ((typePtr != NULL) && (typePtr->freeIntRepProc != NULL)) {
	typePtr->freeIntRepProc(part1Ptr);
	part1Ptr->typePtr = NULL;
    }

    varPtr = TclLookupSimpleVar(interp, part1, flags, 
            createPart1, &errMsg, &index);
    if (varPtr == NULL) {
	if ((errMsg != NULL) && (flags & TCL_LEAVE_ERR_MSG)) {
	    VarErrMsg(interp, part1, part2, msg, errMsg);
	}
	return NULL;
    }

    /*
     * Cache the newly found variable if possible.
     */

    if (index >= 0) {
        /*
	 * An indexed local variable.
	 */

	Proc *procPtr = ((Interp *) interp)->varFramePtr->procPtr;

	part1Ptr->typePtr = &tclLocalVarNameType;
	procPtr->refCount++;
	part1Ptr->internalRep.twoPtrValue.ptr1 = (VOID *) procPtr;
	part1Ptr->internalRep.twoPtrValue.ptr2 = (VOID *) index;
    } else if (index > -3) {
	Namespace *nsPtr;
    
	nsPtr = ((index == -1)? iPtr->globalNsPtr : varFramePtr->nsPtr);
	varPtr->refCount++;
	part1Ptr->typePtr = &tclNsVarNameType;
	part1Ptr->internalRep.twoPtrValue.ptr1 = (VOID *) nsPtr;
	part1Ptr->internalRep.twoPtrValue.ptr2 = (VOID *) varPtr;
    } else {
	/*
	 * At least mark part1Ptr as already parsed.
	 */
	part1Ptr->typePtr = &tclParsedVarNameType;
	part1Ptr->internalRep.twoPtrValue.ptr1 = NULL;
	part1Ptr->internalRep.twoPtrValue.ptr2 = NULL;
    }
    
    donePart1:
#if 0
    if (varPtr == NULL) {
	if (flags & TCL_LEAVE_ERR_MSG) {
	    part1 = TclGetString(part1Ptr);
	    VarErrMsg(interp, part1, part2, msg, 
		    "Cached variable reference is NULL.");
	}
	return NULL;
    }
#endif
    while (TclIsVarLink(varPtr)) {
	varPtr = varPtr->value.linkPtr;
    }

    if (part2 != NULL) {
	/*
	 * Array element sought: look it up.
	 */

	part1 = TclGetString(part1Ptr);
	*arrayPtrPtr = varPtr;
	varPtr = TclLookupArrayElement(interp, part1, part2, 
                flags, msg, createPart1, createPart2, varPtr);
    }
    return varPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * TclLookupSimpleVar --
 *
 *	This procedure is used by to locate a simple variable (i.e., not
 *      an array element) given its name.
 *
 * Results:
 *	The return value is a pointer to the variable structure indicated by
 *	varName, or NULL if the variable couldn't be found. If the variable 
 *      can't be found and create is 1, a new as-yet-undefined (VAR_UNDEFINED) 
 *      variable structure is created, entered into a hash table, and returned.
 *
 *      If the current CallFrame corresponds to a proc and the variable found is
 *      one of the compiledLocals, its index is placed in *indexPtr. Otherwise,
 *      *indexPtr will be set to (according to the needs of TclObjLookupVar):
 *               -1 a global reference
 *               -2 a reference to a namespace variable
 *               -3 a non-cachable reference, i.e., one of:
 *                    . non-indexed local var
 *                    . a reference of unknown origin;
 *                    . resolution by a namespace or interp resolver
 *
 *	If the variable isn't found and creation wasn't specified, or some
 *	other error occurs, NULL is returned and the corresponding error
 *	message is left in *errMsgPtr. 
 *
 *	Note: it's possible for the variable returned to be VAR_UNDEFINED
 *	even if create is 1 (this only causes the hash table entry to be
 *	created).  For example, the variable might be a global that has been
 *	unset but is still referenced by a procedure, or a variable that has
 *	been unset but it only being kept in existence (if VAR_UNDEFINED) by
 *	a trace.
 *
 * Side effects:
 *	A new hashtable entry may be created if create is 1.
 *
 *----------------------------------------------------------------------
 */

Var *
TclLookupSimpleVar(interp, varName, flags, create, errMsgPtr, indexPtr)
    Tcl_Interp *interp;		/* Interpreter to use for lookup. */
    CONST char *varName;        /* This is a simple variable name that could
				 * representa scalar or an array. */
    int flags;		        /* Only TCL_GLOBAL_ONLY, TCL_NAMESPACE_ONLY,
				 * and TCL_LEAVE_ERR_MSG bits matter. */
    CONST int create;		/* If 1, create hash table entry for varname,
				 * if it doesn't already exist. If 0, return 
				 * error if it doesn't exist. */
    CONST char **errMsgPtr;
    int *indexPtr;
{    
    Interp *iPtr = (Interp *) interp;
    CallFrame *varFramePtr = iPtr->varFramePtr;
				/* Points to the procedure call frame whose
				 * variables are currently in use. Same as
				 * the current procedure's frame, if any,
				 * unless an "uplevel" is executing. */
    Tcl_HashTable *tablePtr;	/* Points to the hashtable, if any, in which
				 * to look up the variable. */
    Tcl_Var var;                /* Used to search for global names. */
    Var *varPtr;		/* Points to the Var structure returned for
				 * the variable. */
    Namespace *varNsPtr, *cxtNsPtr, *dummy1Ptr, *dummy2Ptr;
    ResolverScheme *resPtr;
    Tcl_HashEntry *hPtr;
    int new, i, result;

    varPtr = NULL;
    varNsPtr = NULL;		/* set non-NULL if a nonlocal variable */
    *indexPtr = -3;
d194 1
a194 1
    if ((flags & TCL_GLOBAL_ONLY) || iPtr->varFramePtr == NULL) {
d204 1
a204 1
            result = (*cxtNsPtr->varResProc)(interp, varName,
d212 1
a212 1
                result = (*resPtr->varResProc)(interp, varName,
d220 1
a220 1
	    return varPtr;
d222 1
a222 1
	    return NULL;
d227 1
a227 1
     * Look up varName. Look it up as either a namespace variable or as a
d229 1
a229 1
     * Interpret varName as a namespace variable if:
d235 1
a235 1
     * Otherwise, if varName is a local variable, search first in the
d239 1
a239 1
     * If create and the variable isn't found, create the variable and,
d246 2
a247 3
	    || (strstr(varName, "::") != NULL)) {
	CONST char *tail;
	int lookGlobal;
a248 10
	lookGlobal = (flags & TCL_GLOBAL_ONLY) 
	    || (cxtNsPtr == iPtr->globalNsPtr)
	    || ((*varName == ':') && (*(varName+1) == ':'));
	if (lookGlobal) {
	    *indexPtr = -1;
	    flags = (flags | TCL_GLOBAL_ONLY) & ~TCL_NAMESPACE_ONLY;
	} else if (flags & TCL_NAMESPACE_ONLY) {
	    *indexPtr = -2;
	}

d253 1
a253 1
	var = Tcl_FindNamespaceVar(interp, varName, (Tcl_Namespace *) cxtNsPtr,
d259 2
a260 2
	    if (create) {   /* var wasn't found so create it  */
		TclGetNamespaceForQualName(interp, varName, cxtNsPtr,
d262 1
d264 4
a267 2
		    *errMsgPtr = badNamespace;
		    return NULL;
d270 4
a273 2
		    *errMsgPtr = missingName;
		    return NULL;
d280 3
a282 9
		if ((lookGlobal)  || (varNsPtr == NULL)) {
		    /*
		     * The variable was created starting from the global
		     * namespace: a global reference is returned even if 
		     * it wasn't explicitly requested.
		     */
		    *indexPtr = -1;
		} else {
		    *indexPtr = -2;
d284 1
a284 3
	    } else {		/* var wasn't found and not to create it */
		*errMsgPtr = noSuchVar;
		return NULL;
d292 1
a292 1
	int varNameLen = strlen(varName);
d297 5
a301 5
		if ((varName[0] == localName[0])
		        && (varNameLen == localPtr->nameLength)
		        && (strcmp(varName, localName) == 0)) {
		    *indexPtr = i;
		    return localVarPtr;
d307 29
a335 15
	tablePtr = varFramePtr->varTablePtr;
	if (create) {
	    if (tablePtr == NULL) {
		tablePtr = (Tcl_HashTable *)
		    ckalloc(sizeof(Tcl_HashTable));
		Tcl_InitHashTable(tablePtr, TCL_STRING_KEYS);
		varFramePtr->varTablePtr = tablePtr;
	    }
	    hPtr = Tcl_CreateHashEntry(tablePtr, varName, &new);
	    if (new) {
		varPtr = NewVar();
		Tcl_SetHashValue(hPtr, varPtr);
		varPtr->hPtr = hPtr;
		varPtr->nsPtr = NULL; /* a local variable */
	    } else {
a337 10
	} else {
	    hPtr = NULL;
	    if (tablePtr != NULL) {
		hPtr = Tcl_FindHashEntry(tablePtr, varName);
	    }
	    if (hPtr == NULL) {
		*errMsgPtr = noSuchVar;
		return NULL;
	    }
	    varPtr = (Var *) Tcl_GetHashValue(hPtr);
a339 39
    return varPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * TclLookupArrayElement --
 *
 *	This procedure is used to locate a variable which is in an array's 
 *      hashtable given a pointer to the array's Var structure and the 
 *      element's name.
 *
 * Results:
 *	The return value is a pointer to the variable structure , or NULL if 
 *      the variable couldn't be found. 
 *
 *      If arrayPtr points to a variable that isn't an array and createPart1 
 *      is 1, the corresponding variable will be converted to an array. 
 *      Otherwise, NULL is returned and an error message is left in
 *	the interp's result if TCL_LEAVE_ERR_MSG is set in flags.
 *
 *      If the variable is not found and createPart2 is 1, the variable is
 *      created. Otherwise, NULL is returned and an error message is left in
 *	the interp's result if TCL_LEAVE_ERR_MSG is set in flags.
 *
 *	Note: it's possible for the variable returned to be VAR_UNDEFINED
 *	even if createPart1 or createPart2 are 1 (these only cause the hash
 *	table entry or array to be created). For example, the variable might
 *	be a global that has been unset but is still referenced by a
 *	procedure, or a variable that has been unset but it only being kept
 *	in existence (if VAR_UNDEFINED) by a trace.
 *
 * Side effects:
 *      The variable at arrayPtr may be converted to be an array if 
 *      createPart1 is 1. A new hashtable entry may be created if createPart2 
 *      is 1.
 *
 *----------------------------------------------------------------------
 */
d341 23
a363 21
Var *
TclLookupArrayElement(interp, arrayName, elName, flags, msg, createArray, createElem, arrayPtr)
    Tcl_Interp *interp;		/* Interpreter to use for lookup. */
    CONST char *arrayName;	        /* This is the name of the array. */
    CONST char *elName;		/* Name of element within array. */
    CONST int flags;		/* Only TCL_LEAVE_ERR_MSG bit matters. */
    CONST char *msg;			/* Verb to use in error messages, e.g.
				 * "read" or "set". Only needed if
				 * TCL_LEAVE_ERR_MSG is set in flags. */
    CONST int createArray;	/* If 1, transform arrayName to be an array
				 * if it isn't one yet and the transformation 
				 * is possible. If 0, return error if it 
				 * isn't already an array. */
    CONST int createElem;	/* If 1, create hash table entry for the 
				 * element, if it doesn't already exist. If
				 * 0, return error if it doesn't exist. */
    Var *arrayPtr;	        /* Pointer to the array's Var structure. */
{
    Tcl_HashEntry *hPtr;
    int new;
    Var *varPtr;
d370 2
a371 2
    if (TclIsVarUndefined(arrayPtr) && !TclIsVarArrayElement(arrayPtr)) {
	if (!createArray) {
d373 1
a373 1
		VarErrMsg(interp, arrayName, elName, msg, noSuchVar);
d375 2
a376 1
	    return NULL;
d383 1
a383 1
	if ((arrayPtr->flags & VAR_IN_HASHTABLE) && (arrayPtr->hPtr == NULL)) {
d385 1
a385 1
		VarErrMsg(interp, arrayName, elName, msg, danglingVar);
d387 2
a388 1
	    return NULL;
d391 3
a393 3
	TclSetVarArray(arrayPtr);
	TclClearVarUndefined(arrayPtr);
	arrayPtr->value.tablePtr =
d395 2
a396 2
	Tcl_InitHashTable(arrayPtr->value.tablePtr, TCL_STRING_KEYS);
    } else if (!TclIsVarArray(arrayPtr)) {
d398 1
a398 1
	    VarErrMsg(interp, arrayName, elName, msg, needArray);
d400 2
a401 1
	return NULL;
d403 9
a411 3

    if (createElem) {
	hPtr = Tcl_CreateHashEntry(arrayPtr->value.tablePtr, elName, &new);
d413 2
a414 2
	    if (arrayPtr->searchPtr != NULL) {
		DeleteSearches(arrayPtr);
d419 1
a419 1
	    varPtr->nsPtr = arrayPtr->nsPtr;
d423 4
a426 1
	hPtr = Tcl_FindHashEntry(arrayPtr->value.tablePtr, elName);
d429 1
a429 1
		VarErrMsg(interp, arrayName, elName, msg, noSuchElement);
d431 2
a432 1
	    return NULL;
d435 7
a441 1
    return (Var *) Tcl_GetHashValue(hPtr);
d466 1
a466 1
CONST char *
d470 1
a470 1
    CONST char *varName;	/* Name of a variable in interp. */
d501 1
a501 1
CONST char *
d505 1
a505 1
    CONST char *part1;		/* Name of an array (if part2 is non-NULL)
d507 1
a507 1
    CONST char *part2;		/* If non-NULL, gives the name of an element
a520 52

/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetVar2Ex --
 *
 *	Return the value of a Tcl variable as a Tcl object, given a
 *	two-part name consisting of array name and element within array.
 *
 * Results:
 *	The return value points to the current object value of the variable
 *	given by part1Ptr and part2Ptr. If the specified variable doesn't
 *	exist, or if there is a clash in array usage, then NULL is returned
 *	and a message will be left in the interpreter's result if the
 *	TCL_LEAVE_ERR_MSG flag is set.
 *
 * Side effects:
 *	The ref count for the returned object is _not_ incremented to
 *	reflect the returned reference; if you want to keep a reference to
 *	the object you must increment its ref count yourself.
 *
 *----------------------------------------------------------------------
 */

Tcl_Obj *
Tcl_GetVar2Ex(interp, part1, part2, flags)
    Tcl_Interp *interp;		/* Command interpreter in which variable is
				 * to be looked up. */
    CONST char *part1;		/* Name of an array (if part2 is non-NULL)
				 * or the name of a variable. */
    CONST char *part2;		/* If non-NULL, gives the name of an element
				 * in the array part1. */
    int flags;			/* OR-ed combination of TCL_GLOBAL_ONLY,
				 * and TCL_LEAVE_ERR_MSG bits. */
{
    Var *varPtr, *arrayPtr;

    /*
     * We need a special flag check to see if we want to create part 1,
     * because commands like lappend require read traces to trigger for
     * previously non-existent values.
     */
    varPtr = TclLookupVar(interp, part1, part2, flags, "read",
            /*createPart1*/ (flags & TCL_TRACE_READS),
	    /*createPart2*/ 1, &arrayPtr);
    if (varPtr == NULL) {
	return NULL;
    }

    return TclPtrGetVar(interp, varPtr, arrayPtr, part1, part2, flags);
}

d554 3
a556 2
    int flags;			/* OR-ed combination of TCL_GLOBAL_ONLY and
				 * TCL_LEAVE_ERR_MSG bits. */
a557 1
    Var *varPtr, *arrayPtr;
d561 5
a565 1
    part2 = ((part2Ptr == NULL) ? NULL : Tcl_GetString(part2Ptr));
d567 1
a567 13
    /*
     * We need a special flag check to see if we want to create part 1,
     * because commands like lappend require read traces to trigger for
     * previously non-existent values.
     */
    varPtr = TclObjLookupVar(interp, part1Ptr, part2, flags, "read",
            /*createPart1*/ (flags & TCL_TRACE_READS),
	    /*createPart2*/ 1, &arrayPtr);
    if (varPtr == NULL) {
	return NULL;
    }

    return TclPtrGetVar(interp, varPtr, arrayPtr, part1, part2, flags);
d573 1
a573 1
 * TclPtrGetVar --
d575 2
a576 3
 *	Return the value of a Tcl variable as a Tcl object, given the
 *      pointers to the variable's (and possibly containing array's) 
 *      VAR structure.
d580 4
a583 3
 *	given by varPtr. If the specified variable doesn't exist, or if there 
 *      is a clash in array usage, then NULL is returned and a message will be 
 *      left in the interpreter's result if the TCL_LEAVE_ERR_MSG flag is set.
d594 1
a594 1
TclPtrGetVar(interp, varPtr, arrayPtr, part1, part2, flags)
d597 1
a597 4
    register Var *varPtr;       /* The variable to be read.*/
    Var *arrayPtr;              /* NULL for scalar variables, pointer to
				 * the containing array otherwise. */
    CONST char *part1;		/* Name of an array (if part2 is non-NULL)
d599 1
a599 1
    CONST char *part2;		/* If non-NULL, gives the name of an element
d601 1
a601 1
    CONST int flags;		/* OR-ed combination of TCL_GLOBAL_ONLY,
d605 9
a613 1
    CONST char *msg;
d621 6
a626 3
	if (TCL_ERROR == CallVarTraces(iPtr, arrayPtr, varPtr, part1, part2,
		(flags & (TCL_NAMESPACE_ONLY|TCL_GLOBAL_ONLY))
		| TCL_TRACE_READS, (flags & TCL_LEAVE_ERR_MSG))) {
d666 1
a666 1
 * Tcl_SetObjCmd --
d668 3
a670 2
 *	This procedure is invoked to process the "set" Tcl command.
 *	See the user documentation for details on what it does.
d673 5
a677 1
 *	A standard Tcl result value.
d680 3
a682 1
 *	A variable's value may be changed.
d687 9
a695 7
	/* ARGSUSED */
int
Tcl_SetObjCmd(dummy, interp, objc, objv)
    ClientData dummy;			/* Not used. */
    register Tcl_Interp *interp;	/* Current interpreter. */
    int objc;				/* Number of arguments. */
    Tcl_Obj *CONST objv[];		/* Argument objects. */
d697 46
a742 1
    Tcl_Obj *varValueObj;
d744 8
a751 4
    if (objc == 2) {
	varValueObj = Tcl_ObjGetVar2(interp, objv[1], NULL, TCL_LEAVE_ERR_MSG);
	if (varValueObj == NULL) {
	    return TCL_ERROR;
d753 15
a767 3
	Tcl_SetObjResult(interp, varValueObj);
	return TCL_OK;
    } else if (objc == 3) {
a768 4
	varValueObj = Tcl_ObjSetVar2(interp, objv[1], NULL, objv[2],
		TCL_LEAVE_ERR_MSG);
	if (varValueObj == NULL) {
	    return TCL_ERROR;
d770 1
a770 5
	Tcl_SetObjResult(interp, varValueObj);
	return TCL_OK;
    } else {
	Tcl_WrongNumArgs(interp, 1, objv, "varName ?newValue?");
	return TCL_ERROR;
d772 1
d778 1
a778 1
 * Tcl_SetVar --
d780 4
a783 1
 *	Change the value of a variable.
d786 5
a790 7
 *	Returns a pointer to the malloc'ed string which is the character
 *	representation of the variable's new value. The caller must not
 *	modify this string. If the write operation was disallowed then NULL
 *	is returned; if the TCL_LEAVE_ERR_MSG flag is set, then an
 *	explanatory message will be left in the interp's result. Note that the
 *	returned string may not be the same as newValue; this is because
 *	variable traces may modify the variable's value.
d793 3
a795 3
 *	If varName is defined as a local or global variable in interp,
 *	its value is changed to newValue. If varName isn't currently
 *	defined, then a new global variable by that name is created.
d800 3
a802 3
CONST char *
Tcl_SetVar(interp, varName, newValue, flags)
    Tcl_Interp *interp;		/* Command interpreter in which varName is
d804 221
a1024 6
    CONST char *varName;	/* Name of a variable in interp. */
    CONST char *newValue;	/* New value for varName. */
    int flags;			/* Various flags that tell how to set value:
				 * any of TCL_GLOBAL_ONLY,
				 * TCL_NAMESPACE_ONLY, TCL_APPEND_VALUE,
				 * TCL_LIST_ELEMENT, TCL_LEAVE_ERR_MSG. */
d1056 1
a1056 1
CONST char *
d1060 1
a1060 1
    CONST char *part1;          /* If part2 is NULL, this is name of scalar
d1063 1
a1063 1
    CONST char *part2;		/* Name of an element within an array, or
d1065 1
a1065 1
    CONST char *newValue;       /* New value for variable. */
a1093 64
 * Tcl_SetVar2Ex --
 *
 *	Given a two-part variable name, which may refer either to a scalar
 *	variable or an element of an array, change the value of the variable
 *	to a new Tcl object value. If the named scalar or array or element
 *	doesn't exist then create one.
 *
 * Results:
 *	Returns a pointer to the Tcl_Obj holding the new value of the
 *	variable. If the write operation was disallowed because an array was
 *	expected but not found (or vice versa), then NULL is returned; if
 *	the TCL_LEAVE_ERR_MSG flag is set, then an explanatory message will
 *	be left in the interpreter's result. Note that the returned object
 *	may not be the same one referenced by newValuePtr; this is because
 *	variable traces may modify the variable's value.
 *
 * Side effects:
 *	The value of the given variable is set. If either the array or the
 *	entry didn't exist then a new variable is created.
 *
 *	The reference count is decremented for any old value of the variable
 *	and incremented for its new value. If the new value for the variable
 *	is not the same one referenced by newValuePtr (perhaps as a result
 *	of a variable trace), then newValuePtr's ref count is left unchanged
 *	by Tcl_SetVar2Ex. newValuePtr's ref count is also left unchanged if
 *	we are appending it as a string value: that is, if "flags" includes
 *	TCL_APPEND_VALUE but not TCL_LIST_ELEMENT.
 *
 *	The reference count for the returned object is _not_ incremented: if
 *	you want to keep a reference to the object you must increment its
 *	ref count yourself.
 *
 *----------------------------------------------------------------------
 */

Tcl_Obj *
Tcl_SetVar2Ex(interp, part1, part2, newValuePtr, flags)
    Tcl_Interp *interp;		/* Command interpreter in which variable is
				 * to be found. */
    CONST char *part1;		/* Name of an array (if part2 is non-NULL)
				 * or the name of a variable. */
    CONST char *part2;		/* If non-NULL, gives the name of an element
				 * in the array part1. */
    Tcl_Obj *newValuePtr;	/* New value for variable. */
    int flags;			/* Various flags that tell how to set value:
				 * any of TCL_GLOBAL_ONLY,
				 * TCL_NAMESPACE_ONLY, TCL_APPEND_VALUE,
				 * TCL_LIST_ELEMENT or TCL_LEAVE_ERR_MSG. */
{
    Var *varPtr, *arrayPtr;

    varPtr = TclLookupVar(interp, part1, part2, flags, "set",
	    /*createPart1*/ 1, /*createPart2*/ 1, &arrayPtr);
    if (varPtr == NULL) {
	return NULL;
    }

    return TclPtrSetVar(interp, varPtr, arrayPtr, part1, part2, 
            newValuePtr, flags);
}

/*
 *----------------------------------------------------------------------
 *
d1096 1
a1096 1
 *	This function is the same as Tcl_SetVar2Ex above, except the
d1111 1
d1130 2
a1131 1
				 * TCL_LIST_ELEMENT, or TCL_LEAVE_ERR_MSG. */
a1132 1
    Var *varPtr, *arrayPtr;
d1135 5
a1139 7
    part1 = TclGetString(part1Ptr);
    part2 = ((part2Ptr == NULL) ? NULL : Tcl_GetString(part2Ptr));    

    varPtr = TclObjLookupVar(interp, part1Ptr, part2, flags, "set",
	    /*createPart1*/ 1, /*createPart2*/ 1, &arrayPtr);
    if (varPtr == NULL) {
	return NULL;
d1141 2
a1142 3

    return TclPtrSetVar(interp, varPtr, arrayPtr, part1, part2, 
            newValuePtr, flags);
a1144 1

d1148 1
a1148 1
 * TclPtrSetVar --
d1150 4
a1153 3
 *	This function is the same as Tcl_SetVar2Ex above, except that
 *      it requires pointers to the variable's Var structs in addition
 *	to the variable names.
d1167 12
a1178 1

d1184 1
a1184 1
TclPtrSetVar(interp, varPtr, arrayPtr, part1, part2, newValuePtr, flags)
d1186 2
a1187 4
				 * to be looked up. */
    register Var *varPtr;
    Var *arrayPtr;
    CONST char *part1;		/* Name of an array (if part2 is non-NULL)
d1189 1
a1189 1
    CONST char *part2;		/* If non-NULL, gives the name of an element
d1192 4
a1195 2
    CONST int flags;			/* OR-ed combination of TCL_GLOBAL_ONLY,
				 * and TCL_LEAVE_ERR_MSG bits. */
d1198 2
d1202 8
a1209 1
    int result;
d1242 4
a1245 2
     * Invoke any read traces that have been set for the variable if it
     * is requested; this is only done in the core when lappending.
a1247 8
    if ((flags & TCL_TRACE_READS) && ((varPtr->tracePtr != NULL) 
	    || ((arrayPtr != NULL) && (arrayPtr->tracePtr != NULL)))) {
	if (TCL_ERROR == CallVarTraces(iPtr, arrayPtr, varPtr, part1, part2,
		TCL_TRACE_READS, (flags & TCL_LEAVE_ERR_MSG))) {
	    return NULL;
	}
    }

d1284 1
d1286 2
a1287 2
		varPtr->value.objPtr = newValuePtr;
		Tcl_IncrRefCount(newValuePtr);
d1298 9
a1306 5
    } else if (newValuePtr != oldValuePtr) {
	/*
	 * In this case we are replacing the value, so we don't need to
	 * do more than swap the objects.
	 */
d1308 18
a1325 4
	varPtr->value.objPtr = newValuePtr;
	Tcl_IncrRefCount(newValuePtr);      /* var is another ref */
	if (oldValuePtr != NULL) {
	    TclDecrRefCount(oldValuePtr);   /* discard old value */
d1340 6
a1345 3
	if (TCL_ERROR == CallVarTraces(iPtr, arrayPtr, varPtr, part1, part2,
	        (flags & (TCL_GLOBAL_ONLY|TCL_NAMESPACE_ONLY))
		| TCL_TRACE_WRITES, (flags & TCL_LEAVE_ERR_MSG))) {
d1382 397
d1818 7
a1824 2
    Var *varPtr, *arrayPtr;
    char *part1, *part2;
d1826 2
a1827 6
    part1 = TclGetString(part1Ptr);
    part2 = ((part2Ptr == NULL)? NULL : TclGetString(part2Ptr));

    varPtr = TclObjLookupVar(interp, part1Ptr, part2, flags, "read",
	    0, 1, &arrayPtr);
    if (varPtr == NULL) {
d1832 31
a1862 2
    return TclPtrIncrVar(interp, varPtr, arrayPtr, part1, part2,
	    incrAmount, flags);
d1868 1
a1868 1
 * TclPtrIncrVar --
d1870 3
a1872 3
 *	Given the pointers to a variable and possible containing array, 
 *      increment the Tcl object value of the variable by a specified 
 *      amount.
d1876 4
a1879 4
 *	variable. If the specified variable doesn't exist, or there is a
 *	clash in array usage, or an error occurs while executing variable
 *	traces, then NULL is returned and a message will be left in
 *	the interpreter's result.
d1883 3
a1885 4
 *	amount. If either the array or the entry didn't exist then a new
 *	variable is created. The ref count for the returned object is _not_
 *	incremented to reflect the returned reference; if you want to keep a
 *	reference to the object you must increment its ref count yourself.
d1891 1
a1891 1
TclPtrIncrVar(interp, varPtr, arrayPtr, part1, part2, incrAmount, flags)
d1894 3
a1896 13
    Var *varPtr;
    Var *arrayPtr;
    CONST char *part1;		/* Points to an object holding the name of
				 * an array (if part2 is non-NULL) or the
				 * name of a variable. */
    CONST char *part2;		/* If non-null, points to an object holding
				 * the name of an element in the array
				 * part1Ptr. */
    CONST long incrAmount;	/* Amount to be added to variable. */
    CONST int flags;            /* Various flags that tell how to incr value:
				 * any of TCL_GLOBAL_ONLY,
				 * TCL_NAMESPACE_ONLY, TCL_APPEND_VALUE,
				 * TCL_LIST_ELEMENT, TCL_LEAVE_ERR_MSG. */
d1899 1
d1904 1
d1906 2
a1907 2
    varValuePtr = TclPtrGetVar(interp, varPtr, arrayPtr, part1, part2, flags);

d1915 5
a1919 4
     * Increment the variable's value. If the object is unshared we can
     * modify it directly, otherwise we must create a new copy to modify:
     * this is "copy on write". Then free the variable's old string
     * representation, if any, since it will no longer be valid.
d1924 1
a1925 1
	createdNewObj = 1;
d1927 2
a1928 2
#ifdef TCL_WIDE_INT_IS_LONG
    if (Tcl_GetLongFromObj(interp, varValuePtr, &i) != TCL_OK) {
d1935 83
a2017 23
#else
    if (varValuePtr->typePtr == &tclWideIntType) {
	Tcl_WideInt wide = varValuePtr->internalRep.wideValue;
	Tcl_SetWideIntObj(varValuePtr, wide + Tcl_LongAsWide(incrAmount));
    } else if (varValuePtr->typePtr == &tclIntType) {
	i = varValuePtr->internalRep.longValue;
	Tcl_SetIntObj(varValuePtr, i + incrAmount);
    } else {
	/*
	 * Not an integer or wide internal-rep...
	 */
	Tcl_WideInt wide;
	if (Tcl_GetWideIntFromObj(interp, varValuePtr, &wide) != TCL_OK) {
	    if (createdNewObj) {
		Tcl_DecrRefCount(varValuePtr); /* free unneeded copy */
	    }
	    return NULL;
	}
	if (wide <= Tcl_LongAsWide(LONG_MAX)
		&& wide >= Tcl_LongAsWide(LONG_MIN)) {
	    Tcl_SetLongObj(varValuePtr, Tcl_WideAsLong(wide) + incrAmount);
	} else {
	    Tcl_SetWideIntObj(varValuePtr, wide + Tcl_LongAsWide(incrAmount));
d2019 1
d2021 2
a2022 2
#endif

d2027 7
a2033 2
    return TclPtrSetVar(interp, varPtr, arrayPtr, part1, part2,
	    varValuePtr, flags);
d2060 1
a2060 1
    CONST char *varName;	/* Name of a variable in interp.  May be
d2095 2
a2096 45
    CONST char *part1;		/* Name of variable or array. */
    CONST char *part2;		/* Name of element within array or NULL. */
    int flags;			/* OR-ed combination of any of
				 * TCL_GLOBAL_ONLY, TCL_NAMESPACE_ONLY,
				 * TCL_LEAVE_ERR_MSG. */
{
    int result;
    Tcl_Obj *part1Ptr;

    part1Ptr = Tcl_NewStringObj(part1, -1);
    Tcl_IncrRefCount(part1Ptr);
    result = TclObjUnsetVar2(interp, part1Ptr, part2, flags);
    TclDecrRefCount(part1Ptr);

    return result;
}


/*
 *----------------------------------------------------------------------
 *
 * TclObjUnsetVar2 --
 *
 *	Delete a variable, given a 2-object name.
 *
 * Results:
 *	Returns TCL_OK if the variable was successfully deleted, TCL_ERROR
 *	if the variable can't be unset.  In the event of an error,
 *	if the TCL_LEAVE_ERR_MSG flag is set then an error message
 *	is left in the interp's result.
 *
 * Side effects:
 *	If part1ptr and part2Ptr indicate a local or global variable in interp,
 *	it is deleted.  If part1Ptr is an array name and part2Ptr is NULL, then
 *	the whole array is deleted.
 *
 *----------------------------------------------------------------------
 */

int
TclObjUnsetVar2(interp, part1Ptr, part2, flags)
    Tcl_Interp *interp;		/* Command interpreter in which varName is
				 * to be looked up. */
    Tcl_Obj *part1Ptr;		/* Name of variable or array. */
    CONST char *part2;		/* Name of element within array or NULL. */
a2107 1
    char *part1;
d2109 1
a2109 2
    part1 = TclGetString(part1Ptr);
    varPtr = TclObjLookupVar(interp, part1Ptr, part2, flags, "unset",
a2113 1
 
d2144 1
a2144 1
     * 1. We need to increment varPtr's refCount around this: CallVarTraces
d2154 2
a2155 3
	CallVarTraces(iPtr, arrayPtr, &dummyVar, part1, part2,
		(flags & (TCL_GLOBAL_ONLY|TCL_NAMESPACE_ONLY))
		| TCL_TRACE_UNSETS, /* leaveErrMsg */ 0);
d2159 1
a2159 1
	    Tcl_EventuallyFree((ClientData) tracePtr, TCL_DYNAMIC);
d2161 1
a2161 1
	for (activePtr = iPtr->activeVarTracePtr;  activePtr != NULL;
d2193 1
a2193 2
		(flags & (TCL_GLOBAL_ONLY|TCL_NAMESPACE_ONLY)) 
		| TCL_TRACE_UNSETS);
d2259 1
a2259 1
    CONST char *varName;	/* Name of variable;  may end with "(index)"
d2298 2
a2299 2
    CONST char *part1;		/* Name of scalar variable or array. */
    CONST char *part2;		/* Name of element within array;  NULL means
d2312 2
a2313 11
    int flagMask;
    
    /* 
     * We strip 'flags' down to just the parts which are relevant to
     * TclLookupVar, to avoid conflicts between trace flags and
     * internal namespace flags such as 'FIND_ONLY_NS'.  This can
     * now occur since we have trace flags with values 0x1000 and higher.
     */
    flagMask = TCL_GLOBAL_ONLY | TCL_NAMESPACE_ONLY;
    varPtr = TclLookupVar(interp, part1, part2,
	    (flags & flagMask) | TCL_LEAVE_ERR_MSG,
a2319 9
     * Check for a nonsense flag combination.  Note that this is a
     * panic() because there should be no code path that ever sets
     * both flags.
     */
    if ((flags&TCL_TRACE_RESULT_DYNAMIC) && (flags&TCL_TRACE_RESULT_OBJECT)) {
	panic("bad result flag combination");
    }

    /*
a2322 5
    flagMask = TCL_TRACE_READS | TCL_TRACE_WRITES | TCL_TRACE_UNSETS | 
	TCL_TRACE_ARRAY | TCL_TRACE_RESULT_DYNAMIC | TCL_TRACE_RESULT_OBJECT;
#ifndef TCL_REMOVE_OBSOLETE_TRACES
    flagMask |= TCL_TRACE_OLD_STYLE;
#endif
d2324 7
a2330 5
    tracePtr->traceProc		= proc;
    tracePtr->clientData	= clientData;
    tracePtr->flags		= flags & flagMask;
    tracePtr->nextPtr		= varPtr->tracePtr;
    varPtr->tracePtr		= tracePtr;
d2355 1
a2355 1
    CONST char *varName;	/* Name of variable; may end with "(index)"
d2389 2
a2390 2
    CONST char *part1;		/* Name of variable or array. */
    CONST char *part2;		/* Name of element within array;  NULL means
d2406 3
a2408 8
    int flagMask;
    
    /*
     * Set up a mask to mask out the parts of the flags that we are not
     * interested in now.
     */
    flagMask = TCL_GLOBAL_ONLY | TCL_NAMESPACE_ONLY;
    varPtr = TclLookupVar(interp, part1, part2, flags & flagMask,
d2415 2
a2416 11

    /*
     * Set up a mask to mask out the parts of the flags that we are not
     * interested in now.
     */
    flagMask = TCL_TRACE_READS | TCL_TRACE_WRITES | TCL_TRACE_UNSETS |
	TCL_TRACE_ARRAY | TCL_TRACE_RESULT_DYNAMIC | TCL_TRACE_RESULT_OBJECT; 
#ifndef TCL_REMOVE_OBSOLETE_TRACES
    flagMask |= TCL_TRACE_OLD_STYLE;
#endif
    flags &= flagMask;
d2431 1
a2431 1
     * processed by CallVarTraces.
d2434 1
a2434 1
    for (activePtr = iPtr->activeVarTracePtr;  activePtr != NULL;
d2445 1
a2445 1
    Tcl_EventuallyFree((ClientData) tracePtr, TCL_DYNAMIC);
d2486 1
a2486 1
    CONST char *varName;	/* Name of variable;  may end with "(index)"
d2521 2
a2522 2
    CONST char *part1;		/* Name of variable or array. */
    CONST char *part2;		/* Name of element within array;  NULL means
d2592 1
a2592 1
    register int i, flags = TCL_LEAVE_ERR_MSG;
d2595 2
a2596 3
    if (objc < 1) {
	Tcl_WrongNumArgs(interp, 1, objv,
		"?-nocomplain? ?--? ?varName varName ...?");
a2597 6
    } else if (objc == 1) {
	/*
	 * Do nothing if no arguments supplied, so as to match
	 * command documentation.
	 */
	return TCL_OK;
d2599 5
a2603 25

    /*
     * Simple, restrictive argument parsing.  The only options are --
     * and -nocomplain (which must come first and be given exactly to
     * be an option).
     */
    i = 1;
    name = TclGetString(objv[i]);
    if (name[0] == '-') {
 	if (strcmp("-nocomplain", name) == 0) {
	    i++;
 	    if (i == objc) {
		return TCL_OK;
	    }
 	    flags = 0;
 	    name = TclGetString(objv[i]);
 	}
 	if (strcmp("--", name) == 0) {
 	    i++;
 	}
    }

    for (; i < objc;  i++) {
	if ((TclObjUnsetVar2(interp, objv[i], NULL, flags) != TCL_OK)
		&& (flags == TCL_LEAVE_ERR_MSG)) {
a2634 3
    Var *varPtr, *arrayPtr;
    char *part1;

a2643 1

d2650 3
a2652 16
	varPtr = TclObjLookupVar(interp, objv[1], NULL, TCL_LEAVE_ERR_MSG,
		"set", /*createPart1*/ 1, /*createPart2*/ 1, &arrayPtr);
	part1 = TclGetString(objv[1]);
	if (varPtr == NULL) {
	    return TCL_ERROR;
	}
	for (i = 2;  i < objc;  i++) {	  
	    /*
	     * Note that we do not need to increase the refCount of
	     * the Var pointers: should a trace delete the variable,
	     * the return value of TclPtrSetVar will be NULL, and we 
	     * will not access the variable again.
	     */

	    varValuePtr = TclPtrSetVar(interp, varPtr, arrayPtr, part1, NULL, 
	            objv[i], (TCL_APPEND_VALUE | TCL_LEAVE_ERR_MSG));
a2690 2
    Var *varPtr, *arrayPtr;
    char *part1;
d2697 2
a2698 1
	newValuePtr = Tcl_ObjGetVar2(interp, objv[1], (Tcl_Obj *) NULL, 0);
d2705 3
a2707 3
	    varValuePtr = Tcl_NewObj();
	    newValuePtr = Tcl_ObjSetVar2(interp, objv[1], NULL, varValuePtr,
		    TCL_LEAVE_ERR_MSG);
d2709 1
a2709 1
		Tcl_DecrRefCount(varValuePtr); /* free unneeded object */
d2726 1
a2726 27

	/*
	 * Use the TCL_TRACE_READS flag to ensure that if we have an
	 * array with no elements set yet, but with a read trace on it,
	 * we will create the variable and get read traces triggered.
	 * Note that you have to protect the variable pointers around
	 * the TclPtrGetVar call to insure that they remain valid 
	 * even if the variable was undefined and unused.
	 */

	varPtr = TclObjLookupVar(interp, objv[1], NULL, TCL_LEAVE_ERR_MSG,
		"set", /*createPart1*/ 1, /*createPart2*/ 1, &arrayPtr);
	if (varPtr == NULL) {
	    return TCL_ERROR;
	}
	varPtr->refCount++;
	if (arrayPtr != NULL) {
	    arrayPtr->refCount++;
	}
	part1 = TclGetString(objv[1]);
	varValuePtr = TclPtrGetVar(interp, varPtr, arrayPtr, part1, NULL, 
	        (TCL_TRACE_READS | TCL_LEAVE_ERR_MSG));
	varPtr->refCount--;
	if (arrayPtr != NULL) {
	    arrayPtr->refCount--;
	}

d2730 1
a2730 1
	     * exist or it's an array element.  If it's new, we will try to
d2734 13
a2746 1
	    createVar = (TclIsVarUndefined(varPtr));
d2767 1
a2767 1
	listRepPtr = (List *) varValuePtr->internalRep.twoPtrValue.ptr1;
d2813 2
a2814 2
	newValuePtr = TclPtrSetVar(interp, varPtr, arrayPtr, part1, NULL, 
	            varValuePtr, TCL_LEAVE_ERR_MSG);	
d2864 2
a2865 2
	  ARRAY_STARTSEARCH, ARRAY_STATISTICS, ARRAY_UNSET}; 
    static CONST char *arrayOptions[] = {
d2867 1
a2867 1
	"set", "size", "startsearch", "statistics", "unset", (char *) NULL
d2873 1
a2873 1
    Tcl_Obj *resultPtr, *varNamePtr;
d2875 1
a2875 1
    char *varName;
d2890 1
a2890 1
     * Locate the array variable
d2893 2
a2894 3
    varNamePtr = objv[2];
    varName = TclGetString(varNamePtr);
    varPtr = TclObjLookupVar(interp, varNamePtr, NULL, /*flags*/ 0,
d2897 6
d2908 2
a2909 3
    if (varPtr != NULL && varPtr->tracePtr != NULL
	    && (TclIsVarArray(varPtr) || TclIsVarUndefined(varPtr))) {
	if (TCL_ERROR == CallVarTraces(iPtr, arrayPtr, varPtr, varName, NULL,
d2911 3
a2913 1
		TCL_TRACE_ARRAY), /* leaveErrMsg */ 1)) {
a2917 19
    /*
     * Verify that it is indeed an array variable. This test comes after
     * the traces - the variable may actually become an array as an effect 
     * of said traces.
     */

    notArray = 0;
    if ((varPtr == NULL) || !TclIsVarArray(varPtr)
	    || TclIsVarUndefined(varPtr)) {
	notArray = 1;
    }

    /*
     * We have to wait to get the resultPtr until here because
     * CallVarTraces can affect the result.
     */

    resultPtr = Tcl_GetObjResult(interp);

d2921 1
d2931 2
a2932 1
	    searchPtr = ParseSearchId(interp, varPtr, varName, objv[3]);
d2956 1
d2966 2
a2967 1
	    searchPtr = ParseSearchId(interp, varPtr, varName, objv[3]);
d2998 1
a2998 2
	    Tcl_Obj *namePtr, *valuePtr, *nameLstPtr, *tmpResPtr, **namePtrPtr;
	    int i, count;
a3009 8

	    /*
	     * Store the array names in a new object.
	     */

	    nameLstPtr = Tcl_NewObj();
	    Tcl_IncrRefCount(nameLstPtr);

d3022 1
a3022 1
		result = Tcl_ListObjAppendElement(interp, nameLstPtr,
a3025 1
		    Tcl_DecrRefCount(nameLstPtr);
a3027 1
	    }
a3028 20
	    /*
	     * Make sure the Var structure of the array is not removed by
	     * a trace while we're working.
	     */

	    varPtr->refCount++;

	    /*
	     * Get the array values corresponding to each element name 
	     */

	    tmpResPtr = Tcl_NewObj();
	    result = Tcl_ListObjGetElements(interp, nameLstPtr,
		    &count, &namePtrPtr);
	    if (result != TCL_OK) {
		goto errorInArrayGet;
	    }
	    
	    for (i = 0; i < count; i++) { 
		namePtr = *namePtrPtr++;
d3032 2
a3033 17
		    /*
		     * Some trace played a trick on us; we need to diagnose to
		     * adapt our behaviour: was the array element unset, or did
		     * the modification modify the complete array?
		     */

		    if (TclIsVarArray(varPtr) && !TclIsVarUndefined(varPtr)) {
			/*
			 * The array itself looks OK, the variable was
			 * undefined: forget it.
			 */
			
			continue;
		    } else {
			result = TCL_ERROR;
			goto errorInArrayGet;
		    }
d3035 2
a3036 1
		result = Tcl_ListObjAppendElement(interp, tmpResPtr, namePtr);
d3038 2
a3039 5
		    goto errorInArrayGet;
		}
		result = Tcl_ListObjAppendElement(interp, tmpResPtr, valuePtr);
		if (result != TCL_OK) {
		    goto errorInArrayGet;
a3041 3
	    varPtr->refCount--;
	    Tcl_SetObjResult(interp, tmpResPtr);
	    Tcl_DecrRefCount(nameLstPtr);
a3042 6

	    errorInArrayGet:
	    varPtr->refCount--;
	    Tcl_DecrRefCount(nameLstPtr);
	    Tcl_DecrRefCount(tmpResPtr); /* free unneeded temp result obj */
	    return result;
a3049 7
	    int mode, matched = 0;
	    static CONST char *options[] = {
		"-exact", "-glob", "-regexp", (char *) NULL
	    };
	    enum options { OPT_EXACT, OPT_GLOB, OPT_REGEXP };

	    mode = OPT_GLOB;
d3051 2
a3052 3
	    if ((objc < 3) || (objc > 5)) {
  	        Tcl_WrongNumArgs(interp, 2, objv,
			"arrayName ?mode? ?pattern?");
d3060 1
a3060 7
	    } else if (objc == 5) {
		pattern = Tcl_GetString(objv[4]);
		if (Tcl_GetIndexFromObj(interp, objv[3], options, "option",
			0, &mode) != TCL_OK) {
		    return TCL_ERROR;
		}
	    }       		
d3068 2
a3069 19
		if (objc > 3) {
		    switch ((enum options) mode) {
			case OPT_EXACT:
			    matched = (strcmp(name, pattern) == 0);
			    break;
			case OPT_GLOB:
			    matched = Tcl_StringMatch(name, pattern);
			    break;
			case OPT_REGEXP:
			    matched = Tcl_RegExpMatch(interp, name,
				    pattern);
			    if (matched < 0) {
				return TCL_ERROR;
			    }
			    break;
		    }
		    if (matched == 0) {
			continue;
		    }
d3083 1
d3094 2
a3095 1
	    searchPtr = ParseSearchId(interp, varPtr, varName, objv[3]);
d3181 1
a3181 21

	case ARRAY_STATISTICS: {
	    CONST char *stats;

	    if (notArray) {
		goto error;
	    }

	    stats = Tcl_HashStats(varPtr->value.tablePtr);
	    if (stats != NULL) {
		Tcl_SetStringObj(Tcl_GetObjResult(interp), stats, -1);
		ckfree((void *)stats);
	    } else {
		Tcl_SetResult(interp, "error reading array statistics",
			TCL_STATIC);
		return TCL_ERROR;
	    }
	    break;
        }
	
	case ARRAY_UNSET: {
d3198 1
a3198 1
		if (TclObjUnsetVar2(interp, varNamePtr, NULL, 0)
d3213 1
a3213 1
			    (TclObjUnsetVar2(interp, varNamePtr, name, 0)
d3257 1
a3257 1
    int result, elemLen, i, nameLen;
d3260 8
a3267 5
    varName = Tcl_GetStringFromObj(arrayNameObj, &nameLen);
    p = varName + nameLen - 1;
    if (*p == ')') {
	while (--p >= varName) {
	    if (*p == '(') {
d3271 1
d3275 2
a3276 6
    varPtr = TclObjLookupVar(interp, arrayNameObj, NULL,
	    /*flags*/ TCL_LEAVE_ERR_MSG, /*msg*/ "set", /*createPart1*/ 1,
	    /*createPart2*/ 0, &arrayPtr);
    if (varPtr == NULL) {
	return TCL_ERROR;
    }
a3290 6
	    /*
	     * We needn't worry about traces invalidating arrayPtr:
	     * should that be the case, TclPtrSetVar will return NULL
	     * so that we break out of the loop and return an error.
	     */

d3292 2
a3293 6
		char *part2 = TclGetString(elemPtrs[i]);
		Var *elemVarPtr = TclLookupArrayElement(interp, varName, 
                        part2, TCL_LEAVE_ERR_MSG, "set", 1, 1, varPtr);
		if ((elemVarPtr == NULL) ||
		        (TclPtrSetVar(interp, elemVarPtr, varPtr, varName,
			 part2, elemPtrs[i+1], TCL_LEAVE_ERR_MSG) == NULL)) {
d3323 16
d3351 1
a3351 1
 * ObjMakeUpvar --
d3369 3
a3371 3
ObjMakeUpvar(interp, framePtr, otherP1Ptr, otherP2, otherFlags, myName, myFlags, index)
    Tcl_Interp *interp;		/* Interpreter containing variables. Used
			         * for error messages, too. */
d3374 2
a3375 3
    Tcl_Obj *otherP1Ptr;
    CONST char *otherP2;	/* Two-part name of variable in framePtr. */
    CONST int otherFlags;	/* 0, TCL_GLOBAL_ONLY or TCL_NAMESPACE_ONLY:
d3377 1
a3377 1
    CONST char *myName;		/* Name of variable which will refer to
d3379 1
a3379 1
    CONST int myFlags;		/* 0, TCL_GLOBAL_ONLY or TCL_NAMESPACE_ONLY:
a3380 2
    int index;                  /* If the variable to be linked is an indexed
				 * scalar, this is its index. Otherwise, -1. */
d3382 1
a3382 1
    Interp *iPtr = (Interp *) interp;
d3385 5
a3389 1
    CONST char *errMsg;
d3394 1
a3394 1
     * pointer in the interpreter in order to use TclObjLookupVar.
a3396 1
    varFramePtr = iPtr->varFramePtr;
d3398 1
d3401 1
a3401 1
    otherPtr = TclObjLookupVar(interp, otherP1Ptr, otherP2,
d3405 1
a3405 1
	iPtr->varFramePtr = varFramePtr;
d3411 32
a3442 6
    if (index >= 0) {
	if (!varFramePtr->isProcCallFrame) {
	    panic("ObjMakeUpVar called with an index outside from a proc.\n");
	}
	varPtr = &(varFramePtr->compiledLocals[index]);
    } else {
d3449 7
d3457 31
a3487 9
	if (((otherP2 ? arrayPtr->nsPtr : otherPtr->nsPtr) == NULL) 
	    && ((myFlags & (TCL_GLOBAL_ONLY | TCL_NAMESPACE_ONLY))
		|| (varFramePtr == NULL)
		|| !varFramePtr->isProcCallFrame
		|| (strstr(myName, "::") != NULL))) {
	    Tcl_AppendResult((Tcl_Interp *) iPtr, "bad variable name \"",
		    myName, "\": upvar won't create namespace variable that ",
		    "refers to procedure variable", (char *) NULL);
	    return TCL_ERROR;
d3489 16
a3504 10
	
	/*
	 * Lookup and eventually create the new variable.
	 */
	
	varPtr = TclLookupSimpleVar(interp, myName, myFlags, /*create*/ 1, 
				    &errMsg, &index);
	if (varPtr == NULL) {
	    VarErrMsg(interp, myName, NULL, "create", errMsg);
	    return TCL_ERROR;
d3508 1
a3508 11
    if (varPtr == otherPtr) {
	Tcl_SetResult((Tcl_Interp *) iPtr,
		      "can't upvar from variable to itself", TCL_STATIC);
	return TCL_ERROR;
    }

    if (varPtr->tracePtr != NULL) {
	Tcl_AppendResult((Tcl_Interp *) iPtr, "variable \"", myName,
	        "\" has traces: can't use for upvar", (char *) NULL);
	return TCL_ERROR;
    } else if (!TclIsVarUndefined(varPtr)) {
d3510 1
a3510 1
	 * The variable already existed. Make sure this variable "varPtr"
d3516 5
d3530 1
a3530 1
	} else {
d3534 4
d3572 1
a3572 1
    CONST char *frameName;	/* Name of the frame containing the source
d3574 1
a3574 1
    CONST char *varName;	/* Name of a variable in interp to link to.
d3577 1
a3577 1
    CONST char *localName;	/* Name of link variable. */
d3581 37
a3617 1
    return Tcl_UpVar2(interp, frameName, varName, NULL, localName, flags);
d3645 1
a3645 1
    CONST char *frameName;	/* Name of the frame containing the source
d3647 1
a3647 2
    CONST char *part1;
    CONST char *part2;		/* Two parts of source variable name to
d3649 1
a3649 1
    CONST char *localName;	/* Name of link variable. */
a3654 1
    Tcl_Obj *part1Ptr;
d3656 2
a3657 1
    if (TclGetFrame(interp, frameName, &framePtr) == -1) {
d3660 2
a3661 8

    part1Ptr = Tcl_NewStringObj(part1, -1);
    Tcl_IncrRefCount(part1Ptr);
    result = ObjMakeUpvar(interp, framePtr, part1Ptr, part2, 0,
	    localName, flags, -1);
    TclDecrRefCount(part1Ptr);

    return result;
d3782 1
a3782 1
        if ((*tail == ':') && (tail > varName)) {
d3790 3
a3792 3
	result = ObjMakeUpvar(interp, (CallFrame *) NULL,
		objPtr, NULL, /*otherFlags*/ TCL_GLOBAL_ONLY,
	        /*myName*/ tail, /*myFlags*/ 0, -1);
a3846 6
    Tcl_Obj *varNamePtr;

    if (objc < 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "?name value...? name ?value?");
	return TCL_ERROR;
    }
d3854 2
a3855 3
	varNamePtr = objv[i];
	varName = TclGetString(varNamePtr);
	varPtr = TclObjLookupVar(interp, varNamePtr, NULL,
d3892 2
a3893 2
	    varValuePtr = TclPtrSetVar(interp, varPtr, arrayPtr, varName, NULL,
		    objv[i+1], (TCL_NAMESPACE_ONLY | TCL_LEAVE_ERR_MSG));
d3927 2
a3928 2
	    result = ObjMakeUpvar(interp, (CallFrame *) NULL,
		    /*otherP1*/ varNamePtr, /*otherP2*/ NULL,
d3930 1
a3930 1
		    /*myName*/ tail, /*myFlags*/ 0, -1);
d3964 1
d3966 2
a3967 1
    char *frameSpec, *localName;
d4000 28
a4027 3
	localName = TclGetString(objv[1]);
	result = ObjMakeUpvar(interp, framePtr, /* othervarName */ objv[0],
		NULL, 0, /* myVarName */ localName, /*flags*/ 0, -1);
d4038 1
a4038 33
 * DisposeTraceResult--
 *
 *	This procedure is called to dispose of the result returned from
 *	a trace procedure.  The disposal method appropriate to the type
 *	of result is determined by flags.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The memory allocated for the trace result may be freed.
 *
 *----------------------------------------------------------------------
 */

void
DisposeTraceResult(flags, result)
    int flags;			/* Indicates type of result to determine
				 * proper disposal method */
    char *result;		/* The result returned from a trace
				 * procedure to be disposed */
{
    if (flags & TCL_TRACE_RESULT_DYNAMIC) {
	ckfree(result);
    } else if (flags & TCL_TRACE_RESULT_OBJECT) {
	Tcl_DecrRefCount((Tcl_Obj *) result);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * CallVarTraces --
d4046 6
a4051 5
 *      Returns TCL_OK to indicate normal operation.  Returns TCL_ERROR
 *      if invocation of a trace procedure indicated an error.  When
 *      TCL_ERROR is returned and leaveErrMsg is true, then the
 *      ::errorInfo variable of iPtr has information about the error
 *      appended to it.
d4060 2
a4061 2
int 
CallVarTraces(iPtr, arrayPtr, varPtr, part1, part2, flags, leaveErrMsg)
d4068 1
a4068 2
    CONST char *part1;
    CONST char *part2;		/* Variable's two-part name. */
a4073 3
    CONST int leaveErrMsg;	/* If true, and one of the traces indicates an
				 * error, then leave an error message and stack
				 * trace information in *iPTr. */
d4077 1
a4077 2
    char *result;
    CONST char *openParen, *p;
a4079 2
    int code = TCL_OK;
    int disposeFlags = 0;
d4087 1
a4087 1
	return code;
a4090 3
    if (arrayPtr != NULL) {
	arrayPtr->refCount++;
    }
a4110 2
		    int offset = (openParen - part1);
		    char *newPart1;
d4113 4
a4116 4
		    newPart1 = Tcl_DStringValue(&nameCopy);
		    newPart1[offset] = 0;
		    part1 = newPart1;
		    part2 = newPart1 + offset + 1;
d4129 4
a4132 4
    active.nextPtr = iPtr->activeVarTracePtr;
    iPtr->activeVarTracePtr = &active;
    Tcl_Preserve((ClientData) iPtr);
    if (arrayPtr != NULL && !(arrayPtr->flags & VAR_TRACE_ACTIVE)) {
a4139 1
	    Tcl_Preserve((ClientData) tracePtr);
d4144 1
a4144 2
		    /* Ignore errors in unset traces */
		    DisposeTraceResult(tracePtr->flags, result);
d4146 1
a4146 2
	            disposeFlags = tracePtr->flags;
		    code = TCL_ERROR;
a4148 4
	    Tcl_Release((ClientData) tracePtr);
	    if (code == TCL_ERROR) {
		goto done;
	    }
a4165 1
	Tcl_Preserve((ClientData) tracePtr);
d4170 1
a4170 2
		/* Ignore errors in unset traces */
		DisposeTraceResult(tracePtr->flags, result);
d4172 1
a4172 2
		disposeFlags = tracePtr->flags;
		code = TCL_ERROR;
a4174 4
	Tcl_Release((ClientData) tracePtr);
	if (code == TCL_ERROR) {
	    goto done;
	}
a4182 27
    if (code == TCL_ERROR) {
	if (leaveErrMsg) {
	    CONST char *type = "";
	    switch (flags&(TCL_TRACE_READS|TCL_TRACE_WRITES|TCL_TRACE_ARRAY)) {
		case TCL_TRACE_READS: {
		    type = "read";
		    break;
		}
		case TCL_TRACE_WRITES: {
		    type = "set";
		    break;
		}
		case TCL_TRACE_ARRAY: {
		    type = "trace array";
		    break;
		}
	    }
	    if (disposeFlags & TCL_TRACE_RESULT_OBJECT) {
		VarErrMsg((Tcl_Interp *) iPtr, part1, part2, type,
			Tcl_GetString((Tcl_Obj *) result));
	    } else {
		VarErrMsg((Tcl_Interp *) iPtr, part1, part2, type, result);
	    }
	}
	DisposeTraceResult(disposeFlags,result);
    }

d4191 2
a4192 3
    iPtr->activeVarTracePtr = active.nextPtr;
    Tcl_Release((ClientData) iPtr);
    return code;
a4235 66
 * SetArraySearchObj --
 *
 *	This function converts the given tcl object into one that
 *	has the "array search" internal type.
 *
 * Results:
 *	TCL_OK if the conversion succeeded, and TCL_ERROR if it failed
 *	(when an error message will be placed in the interpreter's
 *	result.)
 *
 * Side effects:
 *	Updates the internal type and representation of the object to
 *	make this an array-search object.  See the tclArraySearchType
 *	declaration above for details of the internal representation.
 *
 *----------------------------------------------------------------------
 */

static int
SetArraySearchObj(interp, objPtr)
    Tcl_Interp *interp;
    Tcl_Obj *objPtr;
{
    char *string;
    char *end;
    int id;
    size_t offset;

    /*
     * Get the string representation. Make it up-to-date if necessary.
     */

    string = Tcl_GetString(objPtr);

    /*
     * Parse the id into the three parts separated by dashes.
     */
    if ((string[0] != 's') || (string[1] != '-')) {
	syntax:
	Tcl_AppendResult(interp, "illegal search identifier \"", string,
		"\"", (char *) NULL);
	return TCL_ERROR;
    }
    id = strtoul(string+2, &end, 10);
    if ((end == (string+2)) || (*end != '-')) {
	goto syntax;
    }
    /*
     * Can't perform value check in this context, so place reference
     * to place in string to use for the check in the object instead.
     */
    end++;
    offset = end - string;

    if (objPtr->typePtr != NULL && objPtr->typePtr->freeIntRepProc != NULL) {
	objPtr->typePtr->freeIntRepProc(objPtr);
    }
    objPtr->typePtr = &tclArraySearchType;
    objPtr->internalRep.twoPtrValue.ptr1 = (VOID *)(((char *)NULL)+id);
    objPtr->internalRep.twoPtrValue.ptr2 = (VOID *)(((char *)NULL)+offset);
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
d4238 1
a4238 1
 *	This procedure translates from a tcl object to a pointer to an
d4247 1
a4247 2
 *	The tcl object might have its internal type and representation
 *	modified.
d4253 1
a4253 1
ParseSearchId(interp, varPtr, varName, handleObj)
d4255 2
a4256 2
    CONST Var *varPtr;		/* Array variable search is for. */
    CONST char *varName;	/* Name of array variable that search is
d4258 1
a4258 1
    Tcl_Obj *handleObj;		/* Object containing id of search. Must have
d4263 1
a4263 2
    register char *string;
    register size_t offset;
d4268 1
a4268 1
     * Parse the id.
d4270 5
a4274 1
    if (Tcl_ConvertToType(interp, handleObj, &tclArraySearchType) != TCL_OK) {
d4277 5
a4281 13
    /*
     * Cast is safe, since always came from an int in the first place.
     */
    id = (int)(((char*)handleObj->internalRep.twoPtrValue.ptr1) -
	       ((char*)NULL));
    string = Tcl_GetString(handleObj);
    offset = (((char*)handleObj->internalRep.twoPtrValue.ptr2) -
	      ((char*)NULL));
    /*
     * This test cannot be placed inside the Tcl_Obj machinery, since
     * it is dependent on the variable context.
     */
    if (strcmp(string+offset, varName) != 0) {
a4289 4
     *
     * Note that we cannot store the searchPtr directly in the Tcl_Obj
     * as that would run into trouble when DeleteSearches() was called
     * so we must scan this list every time.
d4377 1
a4377 1
	flags |= TCL_GLOBAL_ONLY;
a4380 3
    if (Tcl_InterpDeleted(interp)) {
	flags |= TCL_INTERP_DESTROYED;
    }
d4414 1
a4414 1
	 * table is deleted). Note that we give CallVarTraces the variable's
d4423 2
a4424 2
	    CallVarTraces(iPtr, (Var *) NULL, varPtr, Tcl_GetString(objPtr),
		    NULL, flags, /* leaveErrMsg */ 0);
d4430 1
a4430 1
		Tcl_EventuallyFree((ClientData) tracePtr, TCL_DYNAMIC);
d4432 1
a4432 1
	    for (activePtr = iPtr->activeVarTracePtr; activePtr != NULL;
d4549 2
a4550 2
	    CallVarTraces(iPtr, (Var *) NULL, varPtr, varPtr->name, NULL,
		    flags, /* leaveErrMsg */ 0);
d4554 1
a4554 1
		Tcl_EventuallyFree((ClientData) tracePtr, TCL_DYNAMIC);
d4556 1
a4556 1
	    for (activePtr = iPtr->activeVarTracePtr; activePtr != NULL;
d4610 1
a4610 1
    CONST char *arrayName;	        /* Name of array (used for trace
d4613 1
a4613 1
    int flags;				/* Flags to pass to CallVarTraces:
d4637 2
a4638 3
	    CallVarTraces(iPtr, (Var *) NULL, elPtr, arrayName,
		    Tcl_GetHashKey(varPtr->value.tablePtr, hPtr), flags,
		    /* leaveErrMsg */ 0);
d4642 1
a4642 1
		Tcl_EventuallyFree((ClientData) tracePtr,TCL_DYNAMIC);
d4644 1
a4644 1
	    for (activePtr = iPtr->activeVarTracePtr; activePtr != NULL;
a4652 13

	/*
	 * Even though array elements are not supposed to be namespace
	 * variables, some combinations of [upvar] and [variable] may
	 * create such beasts - see [Bug 604239]. This is necessary to
	 * avoid leaking the corresponding Var struct, and is otherwise
	 * harmless. 
	 */

	if (elPtr->flags & VAR_NAMESPACE_VAR) {
	    elPtr->flags &= ~VAR_NAMESPACE_VAR;
	    elPtr->refCount--;
	}
d4732 2
a4733 3
    CONST char *part1;
    CONST char *part2;		/* Variable's two-part name. */
    CONST char *operation;      /* String describing operation that failed,
d4735 1
a4735 1
    CONST char *reason;         /* String describing why operation failed. */
d4745 1
d4768 1
a4768 1
    CONST char *varName;	/* The variable name */
d4772 1
d4785 2
a4786 2
            0, "access", /*createPart1*/ 0, /*createPart2*/ 1, &arrayPtr);

d4790 10
d4801 2
a4802 112
    if ((varPtr->tracePtr != NULL)
	    || ((arrayPtr != NULL) && (arrayPtr->tracePtr != NULL))) {
	CallVarTraces((Interp *)interp, arrayPtr, varPtr, varName, NULL,
		TCL_TRACE_READS, /* leaveErrMsg */ 0);
    }

    /*
     * If the variable doesn't exist anymore and no-one's using
     * it, then free up the relevant structures and hash table entries.
     */

    if (TclIsVarUndefined(varPtr)) {
	CleanupVar(varPtr, arrayPtr);
	return NULL;
    }

    return varPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * Internal functions for variable name object types --
 *
 *----------------------------------------------------------------------
 */

/* 
 * localVarName -
 *
 * INTERNALREP DEFINITION:
 *   twoPtrValue.ptr1 = pointer to the corresponding Proc 
 *   twoPtrValue.ptr2 = index into locals table
*/

static void 
FreeLocalVarName(objPtr)
    Tcl_Obj *objPtr;
{
    register Proc *procPtr = (Proc *) objPtr->internalRep.twoPtrValue.ptr1;
    procPtr->refCount--;
    if (procPtr->refCount <= 0) {
	TclProcCleanupProc(procPtr);
    }
}

static void
DupLocalVarName(srcPtr, dupPtr)
    Tcl_Obj *srcPtr;
    Tcl_Obj *dupPtr;
{
    register Proc *procPtr = (Proc *) srcPtr->internalRep.twoPtrValue.ptr1;

    dupPtr->internalRep.twoPtrValue.ptr1 = (VOID *) procPtr;
    dupPtr->internalRep.twoPtrValue.ptr2 = srcPtr->internalRep.twoPtrValue.ptr2;
    procPtr->refCount++;
    dupPtr->typePtr = &tclLocalVarNameType;
}

static void
UpdateLocalVarName(objPtr)
    Tcl_Obj *objPtr;
{
    Proc *procPtr = (Proc *) objPtr->internalRep.twoPtrValue.ptr1;
    unsigned int index = (unsigned int) objPtr->internalRep.twoPtrValue.ptr2;
    CompiledLocal *localPtr = procPtr->firstLocalPtr;
    unsigned int nameLen;

    if (localPtr == NULL) {
	goto emptyName;
    }
    while (index--) {
	localPtr = localPtr->nextPtr;
	if (localPtr == NULL) {
	    goto emptyName;
	}
    }

    nameLen = (unsigned int) localPtr->nameLength;
    objPtr->bytes = ckalloc(nameLen + 1);
    memcpy(objPtr->bytes, localPtr->name, nameLen + 1);
    objPtr->length = nameLen;
    return;

    emptyName:
    objPtr->bytes = ckalloc(1);
    *(objPtr->bytes) = '\0';
    objPtr->length = 0;
}

/* 
 * nsVarName -
 *
 * INTERNALREP DEFINITION:
 *   twoPtrValue.ptr1: pointer to the namespace containing the 
 *                     reference.
 *   twoPtrValue.ptr2: pointer to the corresponding Var 
*/

static void 
FreeNsVarName(objPtr)
    Tcl_Obj *objPtr;
{
    register Var *varPtr = (Var *) objPtr->internalRep.twoPtrValue.ptr2;

    varPtr->refCount--;
    if (TclIsVarUndefined(varPtr) && (varPtr->refCount <= 0)) {
	if (TclIsVarLink(varPtr)) {
	    Var *linkPtr = varPtr->value.linkPtr;
	    linkPtr->refCount--;
	    if (TclIsVarUndefined(linkPtr) && (linkPtr->refCount <= 0)) {
		CleanupVar(linkPtr, (Var *) NULL);
d4804 1
a4805 1
	CleanupVar(varPtr, NULL);
d4807 1
a4807 97
}

static void
DupNsVarName(srcPtr, dupPtr)
    Tcl_Obj *srcPtr;
    Tcl_Obj *dupPtr;
{
    Namespace *nsPtr = (Namespace *) srcPtr->internalRep.twoPtrValue.ptr1;
    register Var *varPtr = (Var *) srcPtr->internalRep.twoPtrValue.ptr2;

    dupPtr->internalRep.twoPtrValue.ptr1 =  (VOID *) nsPtr;
    dupPtr->internalRep.twoPtrValue.ptr2 = (VOID *) varPtr;
    varPtr->refCount++;
    dupPtr->typePtr = &tclNsVarNameType;
}

/* 
 * parsedVarName -
 *
 * INTERNALREP DEFINITION:
 *   twoPtrValue.ptr1 = pointer to the array name Tcl_Obj
 *                      (NULL if scalar)
 *   twoPtrValue.ptr2 = pointer to the element name string
 *                      (owned by this Tcl_Obj), or NULL if 
 *                      it is a scalar variable
 */

static void 
FreeParsedVarName(objPtr)
    Tcl_Obj *objPtr;
{
    register Tcl_Obj *arrayPtr =
	    (Tcl_Obj *) objPtr->internalRep.twoPtrValue.ptr1;
    register char *elem = (char *) objPtr->internalRep.twoPtrValue.ptr2;
    
    if (arrayPtr != NULL) {
	TclDecrRefCount(arrayPtr);
	ckfree(elem);
    }
}

static void
DupParsedVarName(srcPtr, dupPtr)
    Tcl_Obj *srcPtr;
    Tcl_Obj *dupPtr;
{
    register Tcl_Obj *arrayPtr =
	    (Tcl_Obj *) srcPtr->internalRep.twoPtrValue.ptr1;
    register char *elem = (char *) srcPtr->internalRep.twoPtrValue.ptr2;
    char *elemCopy;
    unsigned int elemLen;

    if (arrayPtr != NULL) {
	Tcl_IncrRefCount(arrayPtr);
	elemLen = strlen(elem);
	elemCopy = ckalloc(elemLen+1);
	memcpy(elemCopy, elem, elemLen);
	*(elemCopy + elemLen) = '\0';
	elem = elemCopy;
    }

    dupPtr->internalRep.twoPtrValue.ptr1 = (VOID *) arrayPtr;
    dupPtr->internalRep.twoPtrValue.ptr2 = (VOID *) elem;
    dupPtr->typePtr = &tclParsedVarNameType;
}

static void
UpdateParsedVarName(objPtr)
    Tcl_Obj *objPtr;
{
    Tcl_Obj *arrayPtr = (Tcl_Obj *) objPtr->internalRep.twoPtrValue.ptr1;
    char *part2 = (char *) objPtr->internalRep.twoPtrValue.ptr2;
    char *part1, *p;
    int len1, len2, totalLen;

    if (arrayPtr == NULL) {
	/*
	 * This is a parsed scalar name: what is it
	 * doing here?
	 */
	panic("ERROR: scalar parsedVarName without a string rep.\n");
    }
    part1 = Tcl_GetStringFromObj(arrayPtr, &len1);
    len2 = strlen(part2);
	
    totalLen = len1 + len2 + 2;
    p = ckalloc((unsigned int) totalLen + 1);
    objPtr->bytes = p;
    objPtr->length = totalLen;

    memcpy(p, part1, (unsigned int) len1);
    p += len1;
    *p++ = '(';
    memcpy(p, part2, (unsigned int) len2);
    p += len2;
    *p++ = ')';
    *p   = '\0';
@


1.3.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@a12 1
 * Copyright (c) 2001 by Kevin B. Kenny.  All rights reserved.
d17 1
a17 1
 * RCS: @@(#) $Id: tclVar.c,v 1.67 2002/09/05 20:21:06 dgp Exp $
d28 9
a36 11
static CONST char *noSuchVar =		"no such variable";
static CONST char *isArray =		"variable is array";
static CONST char *needArray =		"variable isn't array";
static CONST char *noSuchElement =	"no such element in array";
static CONST char *danglingElement =
				"upvar refers to element in deleted array";
static CONST char *danglingVar =	
				"upvar refers to variable in deleted namespace";
static CONST char *badNamespace =	"parent namespace doesn't exist";
static CONST char *missingName =	"missing variable name";
static CONST char *isArrayElement =	"name refers to an element in an array";
d42 3
a44 3
static int		CallVarTraces _ANSI_ARGS_((Interp *iPtr, Var *arrayPtr,
			    Var *varPtr, CONST char *part1, CONST char *part2,
			    int flags, CONST int leaveErrMsg));
d49 5
a53 7
			    CONST char *arrayName, Var *varPtr, int flags));
static void		DisposeTraceResult _ANSI_ARGS_((int flags,
			    char *result));
static int              ObjMakeUpvar _ANSI_ARGS_((Tcl_Interp *interp, 
                            CallFrame *framePtr, Tcl_Obj *otherP1Ptr, 
                            CONST char *otherP2, CONST int otherFlags,
		            CONST char *myName, CONST int myFlags, int index));
d56 1
a56 2
			    CONST Var *varPtr, CONST char *varName,
			    Tcl_Obj *handleObj));
d58 2
a59 78
			    CONST char *part1, CONST char *part2,
			    CONST char *operation, CONST char *reason));
static int		SetArraySearchObj _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_Obj *objPtr));


/*
 * Functions defined in this file that may be exported in the future
 * for use by the bytecode compiler and engine or to the public interface.
 */

Var *		TclLookupSimpleVar _ANSI_ARGS_((Tcl_Interp *interp,
		    CONST char *varName, int flags, CONST int create,
		    CONST char **errMsgPtr, int *indexPtr));
int		TclObjUnsetVar2 _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Obj *part1Ptr, CONST char *part2, int flags));

static Tcl_FreeInternalRepProc FreeLocalVarName;
static Tcl_DupInternalRepProc DupLocalVarName;
static Tcl_UpdateStringProc UpdateLocalVarName;
static Tcl_FreeInternalRepProc FreeNsVarName;
static Tcl_DupInternalRepProc DupNsVarName;
static Tcl_FreeInternalRepProc FreeParsedVarName;
static Tcl_DupInternalRepProc DupParsedVarName;
static Tcl_UpdateStringProc UpdateParsedVarName;

/*
 * Types of Tcl_Objs used to cache variable lookups.
 *
 * 
 * localVarName - INTERNALREP DEFINITION:
 *   twoPtrValue.ptr1 = pointer to the corresponding Proc 
 *   twoPtrValue.ptr2 = index into locals table
 *
 * nsVarName - INTERNALREP DEFINITION:
 *   twoPtrValue.ptr1: pointer to the namespace containing the 
 *                     reference
 *   twoPtrValue.ptr2: pointer to the corresponding Var 
 *
 * parsedVarName - INTERNALREP DEFINITION:
 *   twoPtrValue.ptr1 = pointer to the array name Tcl_Obj, 
 *                      or NULL if it is a scalar variable
 *   twoPtrValue.ptr2 = pointer to the element name string
 *                      (owned by this Tcl_Obj), or NULL if 
 *                      it is a scalar variable
 */

Tcl_ObjType tclLocalVarNameType = {
    "localVarName",
    FreeLocalVarName, DupLocalVarName, UpdateLocalVarName, NULL
};

Tcl_ObjType tclNsVarNameType = {
    "namespaceVarName",
    FreeNsVarName, DupNsVarName, NULL, NULL
};

Tcl_ObjType tclParsedVarNameType = {
    "parsedVarName",
    FreeParsedVarName, DupParsedVarName, UpdateParsedVarName, NULL
};

/*
 * Type of Tcl_Objs used to speed up array searches.
 *
 * INTERNALREP DEFINITION:
 *   twoPtrValue.ptr1 = searchIdNumber as offset from (char*)NULL
 *   twoPtrValue.ptr2 = variableNameStartInString as offset from (char*)NULL
 *
 * Note that the value stored in ptr2 is the offset into the string of
 * the start of the variable name and not the address of the variable
 * name itself, as this can be safely copied.
 */
Tcl_ObjType tclArraySearchType = {
    "array search",
    NULL, NULL, NULL, SetArraySearchObj
};

d66 2
a67 5
 *	This procedure is used to locate a variable given its name(s). It
 *      has been mostly superseded by TclObjLookupVar, it is now only used 
 *      by the string-based interfaces. It is kept in tcl8.4 mainly because 
 *      it is in the internal stubs table, so that some extension may be 
 *      calling it. 
d96 1
d101 1
a101 1
    CONST char *part1;	        /* If part2 isn't NULL, this is the name of
d105 1
a105 1
    CONST char *part2;		/* Name of element within array, or NULL. */
d108 1
a108 1
    CONST char *msg;			/* Verb to use in error messages, e.g.
d122 12
a133 2
    Var *varPtr;
    CONST char *elName;		/* Name of array element or NULL; may be
d135 1
a135 1
    int openParen, closeParen;
d137 9
a145 9
				 * array and index, these are the offsets to 
				 * the parens around the index.  Otherwise 
				 * they are -1. */
    register CONST char *p;
    CONST char *errMsg = NULL;
    int index;
#define VAR_NAME_BUF_SIZE 26
    char buffer[VAR_NAME_BUF_SIZE];
    char *newVarName = buffer;
d149 2
a150 1
    openParen = closeParen = -1;
d165 1
a165 1
	    openParen = p - part1;
d172 1
d176 1
a176 1
		    return NULL;
d178 3
a180 1
		closeParen = p - part1;
d182 1
a182 1
		openParen = -1;
a186 414
    if (openParen != -1) {
	if (closeParen >= VAR_NAME_BUF_SIZE) {
	    newVarName = ckalloc((unsigned int) (closeParen+1));
	}
	memcpy(newVarName, part1, (unsigned int) closeParen);
	newVarName[openParen] = '\0';
	newVarName[closeParen] = '\0';
	part1 = newVarName;
	elName = newVarName + openParen + 1;
    }

    varPtr = TclLookupSimpleVar(interp, part1, flags, 
            createPart1, &errMsg, &index);
    if (varPtr == NULL) {
	if ((errMsg != NULL) && (flags & TCL_LEAVE_ERR_MSG)) {
	    VarErrMsg(interp, part1, elName, msg, errMsg);
	}
    } else {
	while (TclIsVarLink(varPtr)) {
	    varPtr = varPtr->value.linkPtr;
	}
	if (elName != NULL) {
	    *arrayPtrPtr = varPtr;
	    varPtr = TclLookupArrayElement(interp, part1, elName, flags, 
		    msg, createPart1, createPart2, varPtr);
	}
    }
    if (newVarName != buffer) {
	ckfree(newVarName);
    }

    return varPtr;
	
#undef VAR_NAME_BUF_SIZE
}

/*
 *----------------------------------------------------------------------
 *
 * TclObjLookupVar --
 *
 *	This procedure is used by virtually all of the variable code to
 *	locate a variable given its name(s). The parsing into array/element
 *      components and (if possible) the lookup results are cached in 
 *      part1Ptr, which is converted to one of the varNameTypes.
 *
 * Results:
 *	The return value is a pointer to the variable structure indicated by
 *	part1Ptr and part2, or NULL if the variable couldn't be found. If 
 *      the variable is found, *arrayPtrPtr is filled with the address of the
 *	variable structure for the array that contains the variable (or NULL
 *	if the variable is a scalar). If the variable can't be found and
 *	either createPart1 or createPart2 are 1, a new as-yet-undefined
 *	(VAR_UNDEFINED) variable structure is created, entered into a hash
 *	table, and returned.
 *
 *	If the variable isn't found and creation wasn't specified, or some
 *	other error occurs, NULL is returned and an error message is left in
 *	the interp's result if TCL_LEAVE_ERR_MSG is set in flags. 
 *
 *	Note: it's possible for the variable returned to be VAR_UNDEFINED
 *	even if createPart1 or createPart2 are 1 (these only cause the hash
 *	table entry or array to be created). For example, the variable might
 *	be a global that has been unset but is still referenced by a
 *	procedure, or a variable that has been unset but it only being kept
 *	in existence (if VAR_UNDEFINED) by a trace.
 *
 * Side effects:
 *	New hashtable entries may be created if createPart1 or createPart2
 *	are 1.
 *      The object part1Ptr is converted to one of tclLocalVarNameType, 
 *      tclNsVarNameType or tclParsedVarNameType and caches as much of the
 *      lookup as it can.
 *
 *----------------------------------------------------------------------
 */
Var *
TclObjLookupVar(interp, part1Ptr, part2, flags, msg, createPart1, createPart2,
        arrayPtrPtr)
    Tcl_Interp *interp;		/* Interpreter to use for lookup. */
    register Tcl_Obj *part1Ptr;	/* If part2 isn't NULL, this is the name 
				 * of an array. Otherwise, this is a full 
				 * variable name that could include a parenthesized 
				 * array element. */
    CONST char *part2;		/* Name of element within array, or NULL. */
    int flags;		        /* Only TCL_GLOBAL_ONLY, TCL_NAMESPACE_ONLY,
				 * and TCL_LEAVE_ERR_MSG bits matter. */
    CONST char *msg;		/* Verb to use in error messages, e.g.
				 * "read" or "set". Only needed if
				 * TCL_LEAVE_ERR_MSG is set in flags. */
    CONST int createPart1;	/* If 1, create hash table entry for part 1
				 * of name, if it doesn't already exist. If
				 * 0, return error if it doesn't exist. */
    CONST int createPart2;	/* If 1, create hash table entry for part 2
				 * of name, if it doesn't already exist. If
				 * 0, return error if it doesn't exist. */
    Var **arrayPtrPtr;		/* If the name refers to an element of an
				 * array, *arrayPtrPtr gets filled in with
				 * address of array variable. Otherwise
				 * this is set to NULL. */
{
    Interp *iPtr = (Interp *) interp;
    register Var *varPtr;	/* Points to the variable's in-frame Var
				 * structure. */
    char *part1;
    int index, len1, len2;
    int parsed = 0;
    Tcl_Obj *objPtr;
    Tcl_ObjType *typePtr = part1Ptr->typePtr;
    CONST char *errMsg = NULL;
    CallFrame *varFramePtr = iPtr->varFramePtr;
    Namespace *nsPtr;

    /*
     * If part1Ptr is a tclParsedVarNameType, separate it into the 
     * pre-parsed parts.
     */

    *arrayPtrPtr = NULL;
    if (typePtr == &tclParsedVarNameType) {
	if (part1Ptr->internalRep.twoPtrValue.ptr1 != NULL) {
	    if (part2 != NULL) {
		/*
		 * ERROR: part1Ptr is already an array element, cannot 
		 * specify a part2.
		 */

		if (flags & TCL_LEAVE_ERR_MSG) {
		    part1 = TclGetString(part1Ptr);
		    VarErrMsg(interp, part1, part2, msg, needArray);
		}
		return NULL;
	    }
	    part2 = (char *) part1Ptr->internalRep.twoPtrValue.ptr2;
	    part1Ptr = (Tcl_Obj *) part1Ptr->internalRep.twoPtrValue.ptr1;
	    typePtr = part1Ptr->typePtr;
	}
	parsed = 1;
    }
    part1 = Tcl_GetStringFromObj(part1Ptr, &len1);    

    nsPtr = ((varFramePtr == NULL)? iPtr->globalNsPtr : varFramePtr->nsPtr);
    if (nsPtr->varResProc != NULL || iPtr->resolverPtr != NULL) {
	goto doParse;
    }
    
    if (typePtr == &tclLocalVarNameType) {
	Proc *procPtr = (Proc *) part1Ptr->internalRep.twoPtrValue.ptr1;
	int localIndex = (int) part1Ptr->internalRep.twoPtrValue.ptr2;
	int useLocal;

	useLocal = ((varFramePtr != NULL) && varFramePtr->isProcCallFrame
	        && !(flags & (TCL_GLOBAL_ONLY | TCL_NAMESPACE_ONLY)));
	if (useLocal && (procPtr == varFramePtr->procPtr)) {
	    /*
	     * part1Ptr points to an indexed local variable of the
	     * correct procedure: use the cached value.
	     */
	    
	    varPtr = &(varFramePtr->compiledLocals[localIndex]);
	    goto donePart1;
	}
	goto doneParsing;
    } else if (typePtr == &tclNsVarNameType) {
	Namespace *cachedNsPtr;
	int useGlobal, useReference;

	varPtr = (Var *) part1Ptr->internalRep.twoPtrValue.ptr2;
	cachedNsPtr = (Namespace *) part1Ptr->internalRep.twoPtrValue.ptr1;
	useGlobal = (cachedNsPtr == iPtr->globalNsPtr) 
	    && ((flags & TCL_GLOBAL_ONLY) 
		|| ((*part1 == ':') && (*(part1+1) == ':'))
		|| (varFramePtr == NULL) 
		|| (!varFramePtr->isProcCallFrame 
		    && (nsPtr == iPtr->globalNsPtr)));
	useReference = useGlobal || ((cachedNsPtr == nsPtr) 
	        && ((flags & TCL_NAMESPACE_ONLY) 
		    || (varFramePtr && !varFramePtr->isProcCallFrame 
			&& !(flags & TCL_GLOBAL_ONLY)
			/* careful: an undefined ns variable could
			 * be hiding a valid global reference. */
			&& !(varPtr->flags & VAR_UNDEFINED))));
	if (useReference && (varPtr->hPtr != NULL)) {
	    /*
	     * A straight global or namespace reference, use it. It isn't 
	     * so simple to deal with 'implicit' namespace references, i.e., 
	     * those where the reference could be to either a namespace 
	     * or a global variable. Those we lookup again.
	     *
	     * If (varPtr->hPtr == NULL), this might be a reference to a
	     * variable in a deleted namespace, kept alive by e.g. part1Ptr.
	     * We could conceivably be so unlucky that a new namespace was
	     * created at the same address as the deleted one, so to be 
	     * safe we test for a valid hPtr.
	     */
	    goto donePart1;
	}
	goto doneParsing;
    }

    doParse:
    if (!parsed && (*(part1 + len1 - 1) == ')')) {
	/*
	 * part1Ptr is possibly an unparsed array element.
	 */
	register int i;
	char *newPart2;
	len2 = -1;
	for (i = 0; i < len1; i++) {
	    if (*(part1 + i) == '(') {
		if (part2 != NULL) {
		    if (flags & TCL_LEAVE_ERR_MSG) {
			VarErrMsg(interp, part1, part2, msg, needArray);
		    }
		}			

		/*
		 * part1Ptr points to an array element; first copy 
		 * the element name to a new string part2.
		 */

		part2 = part1 + i + 1;
		len2 = len1 - i - 2;
		len1 = i;

		newPart2 = ckalloc((unsigned int) (len2+1));
		memcpy(newPart2, part2, (unsigned int) len2);
		*(newPart2+len2) = '\0';
		part2 = newPart2;

		/*
		 * Free the internal rep of the original part1Ptr, now
		 * renamed objPtr, and set it to tclParsedVarNameType.
		 */

		objPtr = part1Ptr;
		if ((typePtr != NULL) && (typePtr->freeIntRepProc != NULL)) {
		    typePtr->freeIntRepProc(objPtr);
		}
		objPtr->typePtr = &tclParsedVarNameType;

		/*
		 * Define a new string object to hold the new part1Ptr, i.e., 
		 * the array name. Set the internal rep of objPtr, reset
		 * typePtr and part1 to contain the references to the
		 * array name.
		 */

		part1Ptr = Tcl_NewStringObj(part1, len1);
		Tcl_IncrRefCount(part1Ptr);

		objPtr->internalRep.twoPtrValue.ptr1 = (VOID *) part1Ptr;
		objPtr->internalRep.twoPtrValue.ptr2 = (VOID *) part2;		

		typePtr = part1Ptr->typePtr;
		part1 = TclGetString(part1Ptr);
		break;
	    }
	}
    }
    
    doneParsing:
    /*
     * part1Ptr is not an array element; look it up, and convert 
     * it to one of the cached types if possible.
     */

    if ((typePtr != NULL) && (typePtr->freeIntRepProc != NULL)) {
	typePtr->freeIntRepProc(part1Ptr);
	part1Ptr->typePtr = NULL;
    }

    varPtr = TclLookupSimpleVar(interp, part1, flags, 
            createPart1, &errMsg, &index);
    if (varPtr == NULL) {
	if ((errMsg != NULL) && (flags & TCL_LEAVE_ERR_MSG)) {
	    VarErrMsg(interp, part1, part2, msg, errMsg);
	}
	return NULL;
    }

    /*
     * Cache the newly found variable if possible.
     */

    if (index >= 0) {
        /*
	 * An indexed local variable.
	 */

	Proc *procPtr = ((Interp *) interp)->varFramePtr->procPtr;

	part1Ptr->typePtr = &tclLocalVarNameType;
	procPtr->refCount++;
	part1Ptr->internalRep.twoPtrValue.ptr1 = (VOID *) procPtr;
	part1Ptr->internalRep.twoPtrValue.ptr2 = (VOID *) index;
    } else if (index > -3) {
	Namespace *nsPtr;
    
	nsPtr = ((index == -1)? iPtr->globalNsPtr : varFramePtr->nsPtr);
	varPtr->refCount++;
	part1Ptr->typePtr = &tclNsVarNameType;
	part1Ptr->internalRep.twoPtrValue.ptr1 = (VOID *) nsPtr;
	part1Ptr->internalRep.twoPtrValue.ptr2 = (VOID *) varPtr;
    } else {
	/*
	 * At least mark part1Ptr as already parsed.
	 */
	part1Ptr->typePtr = &tclParsedVarNameType;
	part1Ptr->internalRep.twoPtrValue.ptr1 = NULL;
	part1Ptr->internalRep.twoPtrValue.ptr2 = NULL;
    }
    
    donePart1:
#if 0
    if (varPtr == NULL) {
	if (flags & TCL_LEAVE_ERR_MSG) {
	    part1 = TclGetString(part1Ptr);
	    VarErrMsg(interp, part1, part2, msg, 
		    "Cached variable reference is NULL.");
	}
	return NULL;
    }
#endif
    while (TclIsVarLink(varPtr)) {
	varPtr = varPtr->value.linkPtr;
    }

    if (part2 != NULL) {
	/*
	 * Array element sought: look it up.
	 */

	part1 = TclGetString(part1Ptr);
	*arrayPtrPtr = varPtr;
	varPtr = TclLookupArrayElement(interp, part1, part2, 
                flags, msg, createPart1, createPart2, varPtr);
    }
    return varPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * TclLookupSimpleVar --
 *
 *	This procedure is used by to locate a simple variable (i.e., not
 *      an array element) given its name.
 *
 * Results:
 *	The return value is a pointer to the variable structure indicated by
 *	varName, or NULL if the variable couldn't be found. If the variable 
 *      can't be found and create is 1, a new as-yet-undefined (VAR_UNDEFINED) 
 *      variable structure is created, entered into a hash table, and returned.
 *
 *      If the current CallFrame corresponds to a proc and the variable found is
 *      one of the compiledLocals, its index is placed in *indexPtr. Otherwise,
 *      *indexPtr will be set to (according to the needs of TclObjLookupVar):
 *               -1 a global reference
 *               -2 a reference to a namespace variable
 *               -3 a non-cachable reference, i.e., one of:
 *                    . non-indexed local var
 *                    . a reference of unknown origin;
 *                    . resolution by a namespace or interp resolver
 *
 *	If the variable isn't found and creation wasn't specified, or some
 *	other error occurs, NULL is returned and the corresponding error
 *	message is left in *errMsgPtr. 
 *
 *	Note: it's possible for the variable returned to be VAR_UNDEFINED
 *	even if create is 1 (this only causes the hash table entry to be
 *	created).  For example, the variable might be a global that has been
 *	unset but is still referenced by a procedure, or a variable that has
 *	been unset but it only being kept in existence (if VAR_UNDEFINED) by
 *	a trace.
 *
 * Side effects:
 *	A new hashtable entry may be created if create is 1.
 *
 *----------------------------------------------------------------------
 */

Var *
TclLookupSimpleVar(interp, varName, flags, create, errMsgPtr, indexPtr)
    Tcl_Interp *interp;		/* Interpreter to use for lookup. */
    CONST char *varName;        /* This is a simple variable name that could
				 * representa scalar or an array. */
    int flags;		        /* Only TCL_GLOBAL_ONLY, TCL_NAMESPACE_ONLY,
				 * and TCL_LEAVE_ERR_MSG bits matter. */
    CONST int create;		/* If 1, create hash table entry for varname,
				 * if it doesn't already exist. If 0, return 
				 * error if it doesn't exist. */
    CONST char **errMsgPtr;
    int *indexPtr;
{    
    Interp *iPtr = (Interp *) interp;
    CallFrame *varFramePtr = iPtr->varFramePtr;
				/* Points to the procedure call frame whose
				 * variables are currently in use. Same as
				 * the current procedure's frame, if any,
				 * unless an "uplevel" is executing. */
    Tcl_HashTable *tablePtr;	/* Points to the hashtable, if any, in which
				 * to look up the variable. */
    Tcl_Var var;                /* Used to search for global names. */
    Var *varPtr;		/* Points to the Var structure returned for
				 * the variable. */
    Namespace *varNsPtr, *cxtNsPtr, *dummy1Ptr, *dummy2Ptr;
    ResolverScheme *resPtr;
    Tcl_HashEntry *hPtr;
    int new, i, result;

    varPtr = NULL;
    varNsPtr = NULL;		/* set non-NULL if a nonlocal variable */
    *indexPtr = -3;
d194 1
a194 1
    if ((flags & TCL_GLOBAL_ONLY) || iPtr->varFramePtr == NULL) {
d204 1
a204 1
            result = (*cxtNsPtr->varResProc)(interp, varName,
d212 1
a212 1
                result = (*resPtr->varResProc)(interp, varName,
d220 1
a220 1
	    return varPtr;
d222 1
a222 1
	    return NULL;
d227 1
a227 1
     * Look up varName. Look it up as either a namespace variable or as a
d229 1
a229 1
     * Interpret varName as a namespace variable if:
d235 1
a235 1
     * Otherwise, if varName is a local variable, search first in the
d239 1
a239 1
     * If create and the variable isn't found, create the variable and,
d246 2
a247 3
	    || (strstr(varName, "::") != NULL)) {
	CONST char *tail;
	int lookGlobal;
a248 10
	lookGlobal = (flags & TCL_GLOBAL_ONLY) 
	    || (cxtNsPtr == iPtr->globalNsPtr)
	    || ((*varName == ':') && (*(varName+1) == ':'));
	if (lookGlobal) {
	    *indexPtr = -1;
	    flags = (flags | TCL_GLOBAL_ONLY) & ~TCL_NAMESPACE_ONLY;
	} else if (flags & TCL_NAMESPACE_ONLY) {
	    *indexPtr = -2;
	}

d253 1
a253 1
	var = Tcl_FindNamespaceVar(interp, varName, (Tcl_Namespace *) cxtNsPtr,
d259 2
a260 2
	    if (create) {   /* var wasn't found so create it  */
		TclGetNamespaceForQualName(interp, varName, cxtNsPtr,
d262 1
d264 4
a267 2
		    *errMsgPtr = badNamespace;
		    return NULL;
d270 4
a273 2
		    *errMsgPtr = missingName;
		    return NULL;
d280 3
a282 9
		if ((lookGlobal)  || (varNsPtr == NULL)) {
		    /*
		     * The variable was created starting from the global
		     * namespace: a global reference is returned even if 
		     * it wasn't explicitly requested.
		     */
		    *indexPtr = -1;
		} else {
		    *indexPtr = -2;
d284 1
a284 3
	    } else {		/* var wasn't found and not to create it */
		*errMsgPtr = noSuchVar;
		return NULL;
d292 1
a292 1
	int varNameLen = strlen(varName);
d297 5
a301 5
		if ((varName[0] == localName[0])
		        && (varNameLen == localPtr->nameLength)
		        && (strcmp(varName, localName) == 0)) {
		    *indexPtr = i;
		    return localVarPtr;
d307 29
a335 15
	tablePtr = varFramePtr->varTablePtr;
	if (create) {
	    if (tablePtr == NULL) {
		tablePtr = (Tcl_HashTable *)
		    ckalloc(sizeof(Tcl_HashTable));
		Tcl_InitHashTable(tablePtr, TCL_STRING_KEYS);
		varFramePtr->varTablePtr = tablePtr;
	    }
	    hPtr = Tcl_CreateHashEntry(tablePtr, varName, &new);
	    if (new) {
		varPtr = NewVar();
		Tcl_SetHashValue(hPtr, varPtr);
		varPtr->hPtr = hPtr;
		varPtr->nsPtr = NULL; /* a local variable */
	    } else {
a337 10
	} else {
	    hPtr = NULL;
	    if (tablePtr != NULL) {
		hPtr = Tcl_FindHashEntry(tablePtr, varName);
	    }
	    if (hPtr == NULL) {
		*errMsgPtr = noSuchVar;
		return NULL;
	    }
	    varPtr = (Var *) Tcl_GetHashValue(hPtr);
a339 39
    return varPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * TclLookupArrayElement --
 *
 *	This procedure is used to locate a variable which is in an array's 
 *      hashtable given a pointer to the array's Var structure and the 
 *      element's name.
 *
 * Results:
 *	The return value is a pointer to the variable structure , or NULL if 
 *      the variable couldn't be found. 
 *
 *      If arrayPtr points to a variable that isn't an array and createPart1 
 *      is 1, the corresponding variable will be converted to an array. 
 *      Otherwise, NULL is returned and an error message is left in
 *	the interp's result if TCL_LEAVE_ERR_MSG is set in flags.
 *
 *      If the variable is not found and createPart2 is 1, the variable is
 *      created. Otherwise, NULL is returned and an error message is left in
 *	the interp's result if TCL_LEAVE_ERR_MSG is set in flags.
 *
 *	Note: it's possible for the variable returned to be VAR_UNDEFINED
 *	even if createPart1 or createPart2 are 1 (these only cause the hash
 *	table entry or array to be created). For example, the variable might
 *	be a global that has been unset but is still referenced by a
 *	procedure, or a variable that has been unset but it only being kept
 *	in existence (if VAR_UNDEFINED) by a trace.
 *
 * Side effects:
 *      The variable at arrayPtr may be converted to be an array if 
 *      createPart1 is 1. A new hashtable entry may be created if createPart2 
 *      is 1.
 *
 *----------------------------------------------------------------------
 */
d341 23
a363 21
Var *
TclLookupArrayElement(interp, arrayName, elName, flags, msg, createArray, createElem, arrayPtr)
    Tcl_Interp *interp;		/* Interpreter to use for lookup. */
    CONST char *arrayName;	        /* This is the name of the array. */
    CONST char *elName;		/* Name of element within array. */
    CONST int flags;		/* Only TCL_LEAVE_ERR_MSG bit matters. */
    CONST char *msg;			/* Verb to use in error messages, e.g.
				 * "read" or "set". Only needed if
				 * TCL_LEAVE_ERR_MSG is set in flags. */
    CONST int createArray;	/* If 1, transform arrayName to be an array
				 * if it isn't one yet and the transformation 
				 * is possible. If 0, return error if it 
				 * isn't already an array. */
    CONST int createElem;	/* If 1, create hash table entry for the 
				 * element, if it doesn't already exist. If
				 * 0, return error if it doesn't exist. */
    Var *arrayPtr;	        /* Pointer to the array's Var structure. */
{
    Tcl_HashEntry *hPtr;
    int new;
    Var *varPtr;
d370 2
a371 2
    if (TclIsVarUndefined(arrayPtr) && !TclIsVarArrayElement(arrayPtr)) {
	if (!createArray) {
d373 1
a373 1
		VarErrMsg(interp, arrayName, elName, msg, noSuchVar);
d375 2
a376 1
	    return NULL;
d383 1
a383 1
	if ((arrayPtr->flags & VAR_IN_HASHTABLE) && (arrayPtr->hPtr == NULL)) {
d385 1
a385 1
		VarErrMsg(interp, arrayName, elName, msg, danglingVar);
d387 2
a388 1
	    return NULL;
d391 3
a393 3
	TclSetVarArray(arrayPtr);
	TclClearVarUndefined(arrayPtr);
	arrayPtr->value.tablePtr =
d395 2
a396 2
	Tcl_InitHashTable(arrayPtr->value.tablePtr, TCL_STRING_KEYS);
    } else if (!TclIsVarArray(arrayPtr)) {
d398 1
a398 1
	    VarErrMsg(interp, arrayName, elName, msg, needArray);
d400 2
a401 1
	return NULL;
d403 9
a411 3

    if (createElem) {
	hPtr = Tcl_CreateHashEntry(arrayPtr->value.tablePtr, elName, &new);
d413 2
a414 2
	    if (arrayPtr->searchPtr != NULL) {
		DeleteSearches(arrayPtr);
d419 1
a419 1
	    varPtr->nsPtr = arrayPtr->nsPtr;
d423 4
a426 1
	hPtr = Tcl_FindHashEntry(arrayPtr->value.tablePtr, elName);
d429 1
a429 1
		VarErrMsg(interp, arrayName, elName, msg, noSuchElement);
d431 2
a432 1
	    return NULL;
d435 7
a441 1
    return (Var *) Tcl_GetHashValue(hPtr);
d466 1
a466 1
CONST char *
d470 1
a470 1
    CONST char *varName;	/* Name of a variable in interp. */
d501 1
a501 1
CONST char *
d505 1
a505 1
    CONST char *part1;		/* Name of an array (if part2 is non-NULL)
d507 1
a507 1
    CONST char *part2;		/* If non-NULL, gives the name of an element
a520 52

/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetVar2Ex --
 *
 *	Return the value of a Tcl variable as a Tcl object, given a
 *	two-part name consisting of array name and element within array.
 *
 * Results:
 *	The return value points to the current object value of the variable
 *	given by part1Ptr and part2Ptr. If the specified variable doesn't
 *	exist, or if there is a clash in array usage, then NULL is returned
 *	and a message will be left in the interpreter's result if the
 *	TCL_LEAVE_ERR_MSG flag is set.
 *
 * Side effects:
 *	The ref count for the returned object is _not_ incremented to
 *	reflect the returned reference; if you want to keep a reference to
 *	the object you must increment its ref count yourself.
 *
 *----------------------------------------------------------------------
 */

Tcl_Obj *
Tcl_GetVar2Ex(interp, part1, part2, flags)
    Tcl_Interp *interp;		/* Command interpreter in which variable is
				 * to be looked up. */
    CONST char *part1;		/* Name of an array (if part2 is non-NULL)
				 * or the name of a variable. */
    CONST char *part2;		/* If non-NULL, gives the name of an element
				 * in the array part1. */
    int flags;			/* OR-ed combination of TCL_GLOBAL_ONLY,
				 * and TCL_LEAVE_ERR_MSG bits. */
{
    Var *varPtr, *arrayPtr;

    /*
     * We need a special flag check to see if we want to create part 1,
     * because commands like lappend require read traces to trigger for
     * previously non-existent values.
     */
    varPtr = TclLookupVar(interp, part1, part2, flags, "read",
            /*createPart1*/ (flags & TCL_TRACE_READS),
	    /*createPart2*/ 1, &arrayPtr);
    if (varPtr == NULL) {
	return NULL;
    }

    return TclPtrGetVar(interp, varPtr, arrayPtr, part1, part2, flags);
}

d554 3
a556 2
    int flags;			/* OR-ed combination of TCL_GLOBAL_ONLY and
				 * TCL_LEAVE_ERR_MSG bits. */
a557 1
    Var *varPtr, *arrayPtr;
d561 5
a565 1
    part2 = ((part2Ptr == NULL) ? NULL : Tcl_GetString(part2Ptr));
d567 1
a567 13
    /*
     * We need a special flag check to see if we want to create part 1,
     * because commands like lappend require read traces to trigger for
     * previously non-existent values.
     */
    varPtr = TclObjLookupVar(interp, part1Ptr, part2, flags, "read",
            /*createPart1*/ (flags & TCL_TRACE_READS),
	    /*createPart2*/ 1, &arrayPtr);
    if (varPtr == NULL) {
	return NULL;
    }

    return TclPtrGetVar(interp, varPtr, arrayPtr, part1, part2, flags);
d573 1
a573 1
 * TclPtrGetVar --
d575 2
a576 3
 *	Return the value of a Tcl variable as a Tcl object, given the
 *      pointers to the variable's (and possibly containing array's) 
 *      VAR structure.
d580 4
a583 3
 *	given by varPtr. If the specified variable doesn't exist, or if there 
 *      is a clash in array usage, then NULL is returned and a message will be 
 *      left in the interpreter's result if the TCL_LEAVE_ERR_MSG flag is set.
d594 1
a594 1
TclPtrGetVar(interp, varPtr, arrayPtr, part1, part2, flags)
d597 1
a597 4
    register Var *varPtr;       /* The variable to be read.*/
    Var *arrayPtr;              /* NULL for scalar variables, pointer to
				 * the containing array otherwise. */
    CONST char *part1;		/* Name of an array (if part2 is non-NULL)
d599 1
a599 1
    CONST char *part2;		/* If non-NULL, gives the name of an element
d601 1
a601 1
    CONST int flags;		/* OR-ed combination of TCL_GLOBAL_ONLY,
d605 9
a613 1
    CONST char *msg;
d621 6
a626 3
	if (TCL_ERROR == CallVarTraces(iPtr, arrayPtr, varPtr, part1, part2,
		(flags & (TCL_NAMESPACE_ONLY|TCL_GLOBAL_ONLY))
		| TCL_TRACE_READS, (flags & TCL_LEAVE_ERR_MSG))) {
d666 1
a666 1
 * Tcl_SetObjCmd --
d668 3
a670 2
 *	This procedure is invoked to process the "set" Tcl command.
 *	See the user documentation for details on what it does.
d673 5
a677 1
 *	A standard Tcl result value.
d680 3
a682 1
 *	A variable's value may be changed.
d687 9
a695 7
	/* ARGSUSED */
int
Tcl_SetObjCmd(dummy, interp, objc, objv)
    ClientData dummy;			/* Not used. */
    register Tcl_Interp *interp;	/* Current interpreter. */
    int objc;				/* Number of arguments. */
    Tcl_Obj *CONST objv[];		/* Argument objects. */
d697 46
a742 1
    Tcl_Obj *varValueObj;
d744 8
a751 4
    if (objc == 2) {
	varValueObj = Tcl_ObjGetVar2(interp, objv[1], NULL, TCL_LEAVE_ERR_MSG);
	if (varValueObj == NULL) {
	    return TCL_ERROR;
d753 15
a767 3
	Tcl_SetObjResult(interp, varValueObj);
	return TCL_OK;
    } else if (objc == 3) {
a768 4
	varValueObj = Tcl_ObjSetVar2(interp, objv[1], NULL, objv[2],
		TCL_LEAVE_ERR_MSG);
	if (varValueObj == NULL) {
	    return TCL_ERROR;
d770 1
a770 5
	Tcl_SetObjResult(interp, varValueObj);
	return TCL_OK;
    } else {
	Tcl_WrongNumArgs(interp, 1, objv, "varName ?newValue?");
	return TCL_ERROR;
d772 1
d778 1
a778 1
 * Tcl_SetVar --
d780 4
a783 1
 *	Change the value of a variable.
d786 5
a790 7
 *	Returns a pointer to the malloc'ed string which is the character
 *	representation of the variable's new value. The caller must not
 *	modify this string. If the write operation was disallowed then NULL
 *	is returned; if the TCL_LEAVE_ERR_MSG flag is set, then an
 *	explanatory message will be left in the interp's result. Note that the
 *	returned string may not be the same as newValue; this is because
 *	variable traces may modify the variable's value.
d793 3
a795 3
 *	If varName is defined as a local or global variable in interp,
 *	its value is changed to newValue. If varName isn't currently
 *	defined, then a new global variable by that name is created.
d800 3
a802 3
CONST char *
Tcl_SetVar(interp, varName, newValue, flags)
    Tcl_Interp *interp;		/* Command interpreter in which varName is
d804 221
a1024 6
    CONST char *varName;	/* Name of a variable in interp. */
    CONST char *newValue;	/* New value for varName. */
    int flags;			/* Various flags that tell how to set value:
				 * any of TCL_GLOBAL_ONLY,
				 * TCL_NAMESPACE_ONLY, TCL_APPEND_VALUE,
				 * TCL_LIST_ELEMENT, TCL_LEAVE_ERR_MSG. */
d1056 1
a1056 1
CONST char *
d1060 1
a1060 1
    CONST char *part1;          /* If part2 is NULL, this is name of scalar
d1063 1
a1063 1
    CONST char *part2;		/* Name of an element within an array, or
d1065 1
a1065 1
    CONST char *newValue;       /* New value for variable. */
a1093 64
 * Tcl_SetVar2Ex --
 *
 *	Given a two-part variable name, which may refer either to a scalar
 *	variable or an element of an array, change the value of the variable
 *	to a new Tcl object value. If the named scalar or array or element
 *	doesn't exist then create one.
 *
 * Results:
 *	Returns a pointer to the Tcl_Obj holding the new value of the
 *	variable. If the write operation was disallowed because an array was
 *	expected but not found (or vice versa), then NULL is returned; if
 *	the TCL_LEAVE_ERR_MSG flag is set, then an explanatory message will
 *	be left in the interpreter's result. Note that the returned object
 *	may not be the same one referenced by newValuePtr; this is because
 *	variable traces may modify the variable's value.
 *
 * Side effects:
 *	The value of the given variable is set. If either the array or the
 *	entry didn't exist then a new variable is created.
 *
 *	The reference count is decremented for any old value of the variable
 *	and incremented for its new value. If the new value for the variable
 *	is not the same one referenced by newValuePtr (perhaps as a result
 *	of a variable trace), then newValuePtr's ref count is left unchanged
 *	by Tcl_SetVar2Ex. newValuePtr's ref count is also left unchanged if
 *	we are appending it as a string value: that is, if "flags" includes
 *	TCL_APPEND_VALUE but not TCL_LIST_ELEMENT.
 *
 *	The reference count for the returned object is _not_ incremented: if
 *	you want to keep a reference to the object you must increment its
 *	ref count yourself.
 *
 *----------------------------------------------------------------------
 */

Tcl_Obj *
Tcl_SetVar2Ex(interp, part1, part2, newValuePtr, flags)
    Tcl_Interp *interp;		/* Command interpreter in which variable is
				 * to be found. */
    CONST char *part1;		/* Name of an array (if part2 is non-NULL)
				 * or the name of a variable. */
    CONST char *part2;		/* If non-NULL, gives the name of an element
				 * in the array part1. */
    Tcl_Obj *newValuePtr;	/* New value for variable. */
    int flags;			/* Various flags that tell how to set value:
				 * any of TCL_GLOBAL_ONLY,
				 * TCL_NAMESPACE_ONLY, TCL_APPEND_VALUE,
				 * TCL_LIST_ELEMENT or TCL_LEAVE_ERR_MSG. */
{
    Var *varPtr, *arrayPtr;

    varPtr = TclLookupVar(interp, part1, part2, flags, "set",
	    /*createPart1*/ 1, /*createPart2*/ 1, &arrayPtr);
    if (varPtr == NULL) {
	return NULL;
    }

    return TclPtrSetVar(interp, varPtr, arrayPtr, part1, part2, 
            newValuePtr, flags);
}

/*
 *----------------------------------------------------------------------
 *
d1096 1
a1096 1
 *	This function is the same as Tcl_SetVar2Ex above, except the
d1111 1
d1130 2
a1131 1
				 * TCL_LIST_ELEMENT, or TCL_LEAVE_ERR_MSG. */
a1132 1
    Var *varPtr, *arrayPtr;
d1135 5
a1139 7
    part1 = TclGetString(part1Ptr);
    part2 = ((part2Ptr == NULL) ? NULL : Tcl_GetString(part2Ptr));    

    varPtr = TclObjLookupVar(interp, part1Ptr, part2, flags, "set",
	    /*createPart1*/ 1, /*createPart2*/ 1, &arrayPtr);
    if (varPtr == NULL) {
	return NULL;
d1141 2
a1142 3

    return TclPtrSetVar(interp, varPtr, arrayPtr, part1, part2, 
            newValuePtr, flags);
a1144 1

d1148 1
a1148 1
 * TclPtrSetVar --
d1150 4
a1153 3
 *	This function is the same as Tcl_SetVar2Ex above, except that
 *      it requires pointers to the variable's Var structs in addition
 *	to the variable names.
d1167 12
a1178 1

d1184 1
a1184 1
TclPtrSetVar(interp, varPtr, arrayPtr, part1, part2, newValuePtr, flags)
d1186 2
a1187 4
				 * to be looked up. */
    register Var *varPtr;
    Var *arrayPtr;
    CONST char *part1;		/* Name of an array (if part2 is non-NULL)
d1189 1
a1189 1
    CONST char *part2;		/* If non-NULL, gives the name of an element
d1192 4
a1195 2
    CONST int flags;			/* OR-ed combination of TCL_GLOBAL_ONLY,
				 * and TCL_LEAVE_ERR_MSG bits. */
d1198 2
d1202 8
a1209 1
    int result;
d1242 4
a1245 2
     * Invoke any read traces that have been set for the variable if it
     * is requested; this is only done in the core when lappending.
a1247 8
    if ((flags & TCL_TRACE_READS) && ((varPtr->tracePtr != NULL) 
	    || ((arrayPtr != NULL) && (arrayPtr->tracePtr != NULL)))) {
	if (TCL_ERROR == CallVarTraces(iPtr, arrayPtr, varPtr, part1, part2,
		TCL_TRACE_READS, (flags & TCL_LEAVE_ERR_MSG))) {
	    return NULL;
	}
    }

d1284 1
d1286 2
a1287 2
		varPtr->value.objPtr = newValuePtr;
		Tcl_IncrRefCount(newValuePtr);
d1298 9
a1306 5
    } else if (newValuePtr != oldValuePtr) {
	/*
	 * In this case we are replacing the value, so we don't need to
	 * do more than swap the objects.
	 */
d1308 18
a1325 4
	varPtr->value.objPtr = newValuePtr;
	Tcl_IncrRefCount(newValuePtr);      /* var is another ref */
	if (oldValuePtr != NULL) {
	    TclDecrRefCount(oldValuePtr);   /* discard old value */
d1340 6
a1345 3
	if (TCL_ERROR == CallVarTraces(iPtr, arrayPtr, varPtr, part1, part2,
	        (flags & (TCL_GLOBAL_ONLY|TCL_NAMESPACE_ONLY))
		| TCL_TRACE_WRITES, (flags & TCL_LEAVE_ERR_MSG))) {
d1382 397
d1818 7
a1824 2
    Var *varPtr, *arrayPtr;
    char *part1, *part2;
d1826 2
a1827 6
    part1 = TclGetString(part1Ptr);
    part2 = ((part2Ptr == NULL)? NULL : TclGetString(part2Ptr));

    varPtr = TclObjLookupVar(interp, part1Ptr, part2, flags, "read",
	    0, 1, &arrayPtr);
    if (varPtr == NULL) {
d1832 31
a1862 2
    return TclPtrIncrVar(interp, varPtr, arrayPtr, part1, part2,
	    incrAmount, flags);
d1868 1
a1868 1
 * TclPtrIncrVar --
d1870 3
a1872 3
 *	Given the pointers to a variable and possible containing array, 
 *      increment the Tcl object value of the variable by a specified 
 *      amount.
d1876 4
a1879 4
 *	variable. If the specified variable doesn't exist, or there is a
 *	clash in array usage, or an error occurs while executing variable
 *	traces, then NULL is returned and a message will be left in
 *	the interpreter's result.
d1883 3
a1885 4
 *	amount. If either the array or the entry didn't exist then a new
 *	variable is created. The ref count for the returned object is _not_
 *	incremented to reflect the returned reference; if you want to keep a
 *	reference to the object you must increment its ref count yourself.
d1891 1
a1891 1
TclPtrIncrVar(interp, varPtr, arrayPtr, part1, part2, incrAmount, flags)
d1894 3
a1896 13
    Var *varPtr;
    Var *arrayPtr;
    CONST char *part1;		/* Points to an object holding the name of
				 * an array (if part2 is non-NULL) or the
				 * name of a variable. */
    CONST char *part2;		/* If non-null, points to an object holding
				 * the name of an element in the array
				 * part1Ptr. */
    CONST long incrAmount;	/* Amount to be added to variable. */
    CONST int flags;            /* Various flags that tell how to incr value:
				 * any of TCL_GLOBAL_ONLY,
				 * TCL_NAMESPACE_ONLY, TCL_APPEND_VALUE,
				 * TCL_LIST_ELEMENT, TCL_LEAVE_ERR_MSG. */
d1899 1
d1904 1
d1906 2
a1907 2
    varValuePtr = TclPtrGetVar(interp, varPtr, arrayPtr, part1, part2, flags);

d1915 5
a1919 4
     * Increment the variable's value. If the object is unshared we can
     * modify it directly, otherwise we must create a new copy to modify:
     * this is "copy on write". Then free the variable's old string
     * representation, if any, since it will no longer be valid.
d1924 1
a1925 1
	createdNewObj = 1;
d1927 2
a1928 2
#ifdef TCL_WIDE_INT_IS_LONG
    if (Tcl_GetLongFromObj(interp, varValuePtr, &i) != TCL_OK) {
d1935 83
a2017 23
#else
    if (varValuePtr->typePtr == &tclWideIntType) {
	Tcl_WideInt wide = varValuePtr->internalRep.wideValue;
	Tcl_SetWideIntObj(varValuePtr, wide + Tcl_LongAsWide(incrAmount));
    } else if (varValuePtr->typePtr == &tclIntType) {
	i = varValuePtr->internalRep.longValue;
	Tcl_SetIntObj(varValuePtr, i + incrAmount);
    } else {
	/*
	 * Not an integer or wide internal-rep...
	 */
	Tcl_WideInt wide;
	if (Tcl_GetWideIntFromObj(interp, varValuePtr, &wide) != TCL_OK) {
	    if (createdNewObj) {
		Tcl_DecrRefCount(varValuePtr); /* free unneeded copy */
	    }
	    return NULL;
	}
	if (wide <= Tcl_LongAsWide(LONG_MAX)
		&& wide >= Tcl_LongAsWide(LONG_MIN)) {
	    Tcl_SetLongObj(varValuePtr, Tcl_WideAsLong(wide) + incrAmount);
	} else {
	    Tcl_SetWideIntObj(varValuePtr, wide + Tcl_LongAsWide(incrAmount));
d2019 1
d2021 2
a2022 2
#endif

d2027 7
a2033 2
    return TclPtrSetVar(interp, varPtr, arrayPtr, part1, part2,
	    varValuePtr, flags);
d2060 1
a2060 1
    CONST char *varName;	/* Name of a variable in interp.  May be
d2095 2
a2096 45
    CONST char *part1;		/* Name of variable or array. */
    CONST char *part2;		/* Name of element within array or NULL. */
    int flags;			/* OR-ed combination of any of
				 * TCL_GLOBAL_ONLY, TCL_NAMESPACE_ONLY,
				 * TCL_LEAVE_ERR_MSG. */
{
    int result;
    Tcl_Obj *part1Ptr;

    part1Ptr = Tcl_NewStringObj(part1, -1);
    Tcl_IncrRefCount(part1Ptr);
    result = TclObjUnsetVar2(interp, part1Ptr, part2, flags);
    TclDecrRefCount(part1Ptr);

    return result;
}


/*
 *----------------------------------------------------------------------
 *
 * TclObjUnsetVar2 --
 *
 *	Delete a variable, given a 2-object name.
 *
 * Results:
 *	Returns TCL_OK if the variable was successfully deleted, TCL_ERROR
 *	if the variable can't be unset.  In the event of an error,
 *	if the TCL_LEAVE_ERR_MSG flag is set then an error message
 *	is left in the interp's result.
 *
 * Side effects:
 *	If part1ptr and part2Ptr indicate a local or global variable in interp,
 *	it is deleted.  If part1Ptr is an array name and part2Ptr is NULL, then
 *	the whole array is deleted.
 *
 *----------------------------------------------------------------------
 */

int
TclObjUnsetVar2(interp, part1Ptr, part2, flags)
    Tcl_Interp *interp;		/* Command interpreter in which varName is
				 * to be looked up. */
    Tcl_Obj *part1Ptr;		/* Name of variable or array. */
    CONST char *part2;		/* Name of element within array or NULL. */
a2107 1
    char *part1;
d2109 1
a2109 2
    part1 = TclGetString(part1Ptr);
    varPtr = TclObjLookupVar(interp, part1Ptr, part2, flags, "unset",
a2113 1
 
d2144 1
a2144 1
     * 1. We need to increment varPtr's refCount around this: CallVarTraces
d2154 2
a2155 3
	CallVarTraces(iPtr, arrayPtr, &dummyVar, part1, part2,
		(flags & (TCL_GLOBAL_ONLY|TCL_NAMESPACE_ONLY))
		| TCL_TRACE_UNSETS, /* leaveErrMsg */ 0);
d2159 1
a2159 1
	    Tcl_EventuallyFree((ClientData) tracePtr, TCL_DYNAMIC);
d2161 1
a2161 1
	for (activePtr = iPtr->activeVarTracePtr;  activePtr != NULL;
d2193 1
a2193 2
		(flags & (TCL_GLOBAL_ONLY|TCL_NAMESPACE_ONLY)) 
		| TCL_TRACE_UNSETS);
d2259 1
a2259 1
    CONST char *varName;	/* Name of variable;  may end with "(index)"
d2298 2
a2299 2
    CONST char *part1;		/* Name of scalar variable or array. */
    CONST char *part2;		/* Name of element within array;  NULL means
d2312 2
a2313 11
    int flagMask;
    
    /* 
     * We strip 'flags' down to just the parts which are relevant to
     * TclLookupVar, to avoid conflicts between trace flags and
     * internal namespace flags such as 'FIND_ONLY_NS'.  This can
     * now occur since we have trace flags with values 0x1000 and higher.
     */
    flagMask = TCL_GLOBAL_ONLY | TCL_NAMESPACE_ONLY;
    varPtr = TclLookupVar(interp, part1, part2,
	    (flags & flagMask) | TCL_LEAVE_ERR_MSG,
a2319 9
     * Check for a nonsense flag combination.  Note that this is a
     * panic() because there should be no code path that ever sets
     * both flags.
     */
    if ((flags&TCL_TRACE_RESULT_DYNAMIC) && (flags&TCL_TRACE_RESULT_OBJECT)) {
	panic("bad result flag combination");
    }

    /*
a2322 5
    flagMask = TCL_TRACE_READS | TCL_TRACE_WRITES | TCL_TRACE_UNSETS | 
	TCL_TRACE_ARRAY | TCL_TRACE_RESULT_DYNAMIC | TCL_TRACE_RESULT_OBJECT;
#ifndef TCL_REMOVE_OBSOLETE_TRACES
    flagMask |= TCL_TRACE_OLD_STYLE;
#endif
d2324 7
a2330 5
    tracePtr->traceProc		= proc;
    tracePtr->clientData	= clientData;
    tracePtr->flags		= flags & flagMask;
    tracePtr->nextPtr		= varPtr->tracePtr;
    varPtr->tracePtr		= tracePtr;
d2355 1
a2355 1
    CONST char *varName;	/* Name of variable; may end with "(index)"
d2389 2
a2390 2
    CONST char *part1;		/* Name of variable or array. */
    CONST char *part2;		/* Name of element within array;  NULL means
d2406 3
a2408 8
    int flagMask;
    
    /*
     * Set up a mask to mask out the parts of the flags that we are not
     * interested in now.
     */
    flagMask = TCL_GLOBAL_ONLY | TCL_NAMESPACE_ONLY;
    varPtr = TclLookupVar(interp, part1, part2, flags & flagMask,
d2415 2
a2416 11

    /*
     * Set up a mask to mask out the parts of the flags that we are not
     * interested in now.
     */
    flagMask = TCL_TRACE_READS | TCL_TRACE_WRITES | TCL_TRACE_UNSETS |
	TCL_TRACE_ARRAY | TCL_TRACE_RESULT_DYNAMIC | TCL_TRACE_RESULT_OBJECT; 
#ifndef TCL_REMOVE_OBSOLETE_TRACES
    flagMask |= TCL_TRACE_OLD_STYLE;
#endif
    flags &= flagMask;
d2431 1
a2431 1
     * processed by CallVarTraces.
d2434 1
a2434 1
    for (activePtr = iPtr->activeVarTracePtr;  activePtr != NULL;
d2445 1
a2445 1
    Tcl_EventuallyFree((ClientData) tracePtr, TCL_DYNAMIC);
d2486 1
a2486 1
    CONST char *varName;	/* Name of variable;  may end with "(index)"
d2521 2
a2522 2
    CONST char *part1;		/* Name of variable or array. */
    CONST char *part2;		/* Name of element within array;  NULL means
d2592 1
a2592 1
    register int i, flags = TCL_LEAVE_ERR_MSG;
d2595 2
a2596 3
    if (objc < 1) {
	Tcl_WrongNumArgs(interp, 1, objv,
		"?-nocomplain? ?--? ?varName varName ...?");
a2597 6
    } else if (objc == 1) {
	/*
	 * Do nothing if no arguments supplied, so as to match
	 * command documentation.
	 */
	return TCL_OK;
d2599 5
a2603 25

    /*
     * Simple, restrictive argument parsing.  The only options are --
     * and -nocomplain (which must come first and be given exactly to
     * be an option).
     */
    i = 1;
    name = TclGetString(objv[i]);
    if (name[0] == '-') {
 	if (strcmp("-nocomplain", name) == 0) {
	    i++;
 	    if (i == objc) {
		return TCL_OK;
	    }
 	    flags = 0;
 	    name = TclGetString(objv[i]);
 	}
 	if (strcmp("--", name) == 0) {
 	    i++;
 	}
    }

    for (; i < objc;  i++) {
	if ((TclObjUnsetVar2(interp, objv[i], NULL, flags) != TCL_OK)
		&& (flags == TCL_LEAVE_ERR_MSG)) {
a2634 3
    Var *varPtr, *arrayPtr;
    char *part1;

a2643 1

d2650 3
a2652 16
	varPtr = TclObjLookupVar(interp, objv[1], NULL, TCL_LEAVE_ERR_MSG,
		"set", /*createPart1*/ 1, /*createPart2*/ 1, &arrayPtr);
	part1 = TclGetString(objv[1]);
	if (varPtr == NULL) {
	    return TCL_ERROR;
	}
	for (i = 2;  i < objc;  i++) {	  
	    /*
	     * Note that we do not need to increase the refCount of
	     * the Var pointers: should a trace delete the variable,
	     * the return value of TclPtrSetVar will be NULL, and we 
	     * will not access the variable again.
	     */

	    varValuePtr = TclPtrSetVar(interp, varPtr, arrayPtr, part1, NULL, 
	            objv[i], (TCL_APPEND_VALUE | TCL_LEAVE_ERR_MSG));
a2690 2
    Var *varPtr, *arrayPtr;
    char *part1;
d2697 2
a2698 1
	newValuePtr = Tcl_ObjGetVar2(interp, objv[1], (Tcl_Obj *) NULL, 0);
d2705 3
a2707 3
	    varValuePtr = Tcl_NewObj();
	    newValuePtr = Tcl_ObjSetVar2(interp, objv[1], NULL, varValuePtr,
		    TCL_LEAVE_ERR_MSG);
d2709 1
a2709 1
		Tcl_DecrRefCount(varValuePtr); /* free unneeded object */
d2726 1
a2726 27

	/*
	 * Use the TCL_TRACE_READS flag to ensure that if we have an
	 * array with no elements set yet, but with a read trace on it,
	 * we will create the variable and get read traces triggered.
	 * Note that you have to protect the variable pointers around
	 * the TclPtrGetVar call to insure that they remain valid 
	 * even if the variable was undefined and unused.
	 */

	varPtr = TclObjLookupVar(interp, objv[1], NULL, TCL_LEAVE_ERR_MSG,
		"set", /*createPart1*/ 1, /*createPart2*/ 1, &arrayPtr);
	if (varPtr == NULL) {
	    return TCL_ERROR;
	}
	varPtr->refCount++;
	if (arrayPtr != NULL) {
	    arrayPtr->refCount++;
	}
	part1 = TclGetString(objv[1]);
	varValuePtr = TclPtrGetVar(interp, varPtr, arrayPtr, part1, NULL, 
	        (TCL_TRACE_READS | TCL_LEAVE_ERR_MSG));
	varPtr->refCount--;
	if (arrayPtr != NULL) {
	    arrayPtr->refCount--;
	}

d2730 1
a2730 1
	     * exist or it's an array element.  If it's new, we will try to
d2734 13
a2746 1
	    createVar = (TclIsVarUndefined(varPtr));
d2767 1
a2767 1
	listRepPtr = (List *) varValuePtr->internalRep.twoPtrValue.ptr1;
d2813 2
a2814 2
	newValuePtr = TclPtrSetVar(interp, varPtr, arrayPtr, part1, NULL, 
	            varValuePtr, TCL_LEAVE_ERR_MSG);	
d2864 2
a2865 2
	  ARRAY_STARTSEARCH, ARRAY_STATISTICS, ARRAY_UNSET}; 
    static CONST char *arrayOptions[] = {
d2867 1
a2867 1
	"set", "size", "startsearch", "statistics", "unset", (char *) NULL
d2873 1
a2873 1
    Tcl_Obj *resultPtr, *varNamePtr;
d2875 1
a2875 1
    char *varName;
d2890 1
a2890 1
     * Locate the array variable
d2893 2
a2894 3
    varNamePtr = objv[2];
    varName = TclGetString(varNamePtr);
    varPtr = TclObjLookupVar(interp, varNamePtr, NULL, /*flags*/ 0,
d2897 6
d2908 2
a2909 3
    if (varPtr != NULL && varPtr->tracePtr != NULL
	    && (TclIsVarArray(varPtr) || TclIsVarUndefined(varPtr))) {
	if (TCL_ERROR == CallVarTraces(iPtr, arrayPtr, varPtr, varName, NULL,
d2911 3
a2913 1
		TCL_TRACE_ARRAY), /* leaveErrMsg */ 1)) {
a2917 19
    /*
     * Verify that it is indeed an array variable. This test comes after
     * the traces - the variable may actually become an array as an effect 
     * of said traces.
     */

    notArray = 0;
    if ((varPtr == NULL) || !TclIsVarArray(varPtr)
	    || TclIsVarUndefined(varPtr)) {
	notArray = 1;
    }

    /*
     * We have to wait to get the resultPtr until here because
     * CallVarTraces can affect the result.
     */

    resultPtr = Tcl_GetObjResult(interp);

d2921 1
d2931 2
a2932 1
	    searchPtr = ParseSearchId(interp, varPtr, varName, objv[3]);
d2956 1
d2966 2
a2967 1
	    searchPtr = ParseSearchId(interp, varPtr, varName, objv[3]);
d2998 1
a2998 2
	    Tcl_Obj *namePtr, *valuePtr, *nameLstPtr, *tmpResPtr, **namePtrPtr;
	    int i, count;
a3009 8

	    /*
	     * Store the array names in a new object.
	     */

	    nameLstPtr = Tcl_NewObj();
	    Tcl_IncrRefCount(nameLstPtr);

d3022 1
a3022 1
		result = Tcl_ListObjAppendElement(interp, nameLstPtr,
a3025 1
		    Tcl_DecrRefCount(nameLstPtr);
a3027 1
	    }
a3028 20
	    /*
	     * Make sure the Var structure of the array is not removed by
	     * a trace while we're working.
	     */

	    varPtr->refCount++;

	    /*
	     * Get the array values corresponding to each element name 
	     */

	    tmpResPtr = Tcl_NewObj();
	    result = Tcl_ListObjGetElements(interp, nameLstPtr,
		    &count, &namePtrPtr);
	    if (result != TCL_OK) {
		goto errorInArrayGet;
	    }
	    
	    for (i = 0; i < count; i++) { 
		namePtr = *namePtrPtr++;
d3032 2
a3033 17
		    /*
		     * Some trace played a trick on us; we need to diagnose to
		     * adapt our behaviour: was the array element unset, or did
		     * the modification modify the complete array?
		     */

		    if (TclIsVarArray(varPtr) && !TclIsVarUndefined(varPtr)) {
			/*
			 * The array itself looks OK, the variable was
			 * undefined: forget it.
			 */
			
			continue;
		    } else {
			result = TCL_ERROR;
			goto errorInArrayGet;
		    }
d3035 2
a3036 1
		result = Tcl_ListObjAppendElement(interp, tmpResPtr, namePtr);
d3038 2
a3039 5
		    goto errorInArrayGet;
		}
		result = Tcl_ListObjAppendElement(interp, tmpResPtr, valuePtr);
		if (result != TCL_OK) {
		    goto errorInArrayGet;
a3041 3
	    varPtr->refCount--;
	    Tcl_SetObjResult(interp, tmpResPtr);
	    Tcl_DecrRefCount(nameLstPtr);
a3042 6

	    errorInArrayGet:
	    varPtr->refCount--;
	    Tcl_DecrRefCount(nameLstPtr);
	    Tcl_DecrRefCount(tmpResPtr); /* free unneeded temp result obj */
	    return result;
a3049 7
	    int mode, matched = 0;
	    static CONST char *options[] = {
		"-exact", "-glob", "-regexp", (char *) NULL
	    };
	    enum options { OPT_EXACT, OPT_GLOB, OPT_REGEXP };

	    mode = OPT_GLOB;
d3051 2
a3052 3
	    if ((objc < 3) && (objc > 5)) {
  	        Tcl_WrongNumArgs(interp, 2, objv,
			"arrayName ?mode? ?pattern?");
d3060 1
a3060 7
	    } else if (objc == 5) {
		pattern = Tcl_GetString(objv[4]);
		if (Tcl_GetIndexFromObj(interp, objv[3], options, "option",
			0, &mode) != TCL_OK) {
		    return TCL_ERROR;
		}
	    }       		
d3068 2
a3069 19
		if (objc > 3) {
		    switch ((enum options) mode) {
			case OPT_EXACT:
			    matched = (strcmp(name, pattern) == 0);
			    break;
			case OPT_GLOB:
			    matched = Tcl_StringMatch(name, pattern);
			    break;
			case OPT_REGEXP:
			    matched = Tcl_RegExpMatch(interp, name,
				    pattern);
			    if (matched < 0) {
				return TCL_ERROR;
			    }
			    break;
		    }
		    if (matched == 0) {
			continue;
		    }
d3083 1
d3094 2
a3095 1
	    searchPtr = ParseSearchId(interp, varPtr, varName, objv[3]);
d3181 1
a3181 21

	case ARRAY_STATISTICS: {
	    CONST char *stats;

	    if (notArray) {
		goto error;
	    }

	    stats = Tcl_HashStats(varPtr->value.tablePtr);
	    if (stats != NULL) {
		Tcl_SetStringObj(Tcl_GetObjResult(interp), stats, -1);
		ckfree((void *)stats);
	    } else {
		Tcl_SetResult(interp, "error reading array statistics",
			TCL_STATIC);
		return TCL_ERROR;
	    }
	    break;
        }
	
	case ARRAY_UNSET: {
d3198 1
a3198 1
		if (TclObjUnsetVar2(interp, varNamePtr, NULL, 0)
d3213 1
a3213 1
			    (TclObjUnsetVar2(interp, varNamePtr, name, 0)
d3257 1
a3257 1
    int result, elemLen, i, nameLen;
d3260 8
a3267 5
    varName = Tcl_GetStringFromObj(arrayNameObj, &nameLen);
    p = varName + nameLen - 1;
    if (*p == ')') {
	while (--p >= varName) {
	    if (*p == '(') {
d3271 1
d3275 2
a3276 6
    varPtr = TclObjLookupVar(interp, arrayNameObj, NULL,
	    /*flags*/ TCL_LEAVE_ERR_MSG, /*msg*/ "set", /*createPart1*/ 1,
	    /*createPart2*/ 0, &arrayPtr);
    if (varPtr == NULL) {
	return TCL_ERROR;
    }
a3290 6
	    /*
	     * We needn't worry about traces invalidating arrayPtr:
	     * should that be the case, TclPtrSetVar will return NULL
	     * so that we break out of the loop and return an error.
	     */

d3292 2
a3293 6
		char *part2 = TclGetString(elemPtrs[i]);
		Var *elemVarPtr = TclLookupArrayElement(interp, varName, 
                        part2, TCL_LEAVE_ERR_MSG, "set", 1, 1, varPtr);
		if ((elemVarPtr == NULL) ||
		        (TclPtrSetVar(interp, elemVarPtr, varPtr, varName,
			 part2, elemPtrs[i+1], TCL_LEAVE_ERR_MSG) == NULL)) {
d3323 16
d3351 1
a3351 1
 * ObjMakeUpvar --
d3369 3
a3371 3
ObjMakeUpvar(interp, framePtr, otherP1Ptr, otherP2, otherFlags, myName, myFlags, index)
    Tcl_Interp *interp;		/* Interpreter containing variables. Used
			         * for error messages, too. */
d3374 2
a3375 3
    Tcl_Obj *otherP1Ptr;
    CONST char *otherP2;	/* Two-part name of variable in framePtr. */
    CONST int otherFlags;	/* 0, TCL_GLOBAL_ONLY or TCL_NAMESPACE_ONLY:
d3377 1
a3377 1
    CONST char *myName;		/* Name of variable which will refer to
d3379 1
a3379 1
    CONST int myFlags;		/* 0, TCL_GLOBAL_ONLY or TCL_NAMESPACE_ONLY:
a3380 2
    int index;                  /* If the variable to be linked is an indexed
				 * scalar, this is its index. Otherwise, -1. */
d3382 1
a3382 1
    Interp *iPtr = (Interp *) interp;
d3385 5
a3389 1
    CONST char *errMsg;
d3394 1
a3394 1
     * pointer in the interpreter in order to use TclObjLookupVar.
a3396 1
    varFramePtr = iPtr->varFramePtr;
d3398 1
d3401 1
a3401 1
    otherPtr = TclObjLookupVar(interp, otherP1Ptr, otherP2,
d3405 1
a3405 1
	iPtr->varFramePtr = varFramePtr;
d3411 32
a3442 6
    if (index >= 0) {
	if (!varFramePtr->isProcCallFrame) {
	    panic("ObjMakeUpVar called with an index outside from a proc.\n");
	}
	varPtr = &(varFramePtr->compiledLocals[index]);
    } else {
d3449 7
d3457 31
a3487 9
	if (((otherP2 ? arrayPtr->nsPtr : otherPtr->nsPtr) == NULL) 
	    && ((myFlags & (TCL_GLOBAL_ONLY | TCL_NAMESPACE_ONLY))
		|| (varFramePtr == NULL)
		|| !varFramePtr->isProcCallFrame
		|| (strstr(myName, "::") != NULL))) {
	    Tcl_AppendResult((Tcl_Interp *) iPtr, "bad variable name \"",
		    myName, "\": upvar won't create namespace variable that ",
		    "refers to procedure variable", (char *) NULL);
	    return TCL_ERROR;
d3489 16
a3504 10
	
	/*
	 * Lookup and eventually create the new variable.
	 */
	
	varPtr = TclLookupSimpleVar(interp, myName, myFlags, /*create*/ 1, 
				    &errMsg, &index);
	if (varPtr == NULL) {
	    VarErrMsg(interp, myName, NULL, "create", errMsg);
	    return TCL_ERROR;
d3508 1
a3508 11
    if (varPtr == otherPtr) {
	Tcl_SetResult((Tcl_Interp *) iPtr,
		      "can't upvar from variable to itself", TCL_STATIC);
	return TCL_ERROR;
    }

    if (varPtr->tracePtr != NULL) {
	Tcl_AppendResult((Tcl_Interp *) iPtr, "variable \"", myName,
	        "\" has traces: can't use for upvar", (char *) NULL);
	return TCL_ERROR;
    } else if (!TclIsVarUndefined(varPtr)) {
d3510 1
a3510 1
	 * The variable already existed. Make sure this variable "varPtr"
d3516 5
d3530 1
a3530 1
	} else {
d3534 4
d3572 1
a3572 1
    CONST char *frameName;	/* Name of the frame containing the source
d3574 1
a3574 1
    CONST char *varName;	/* Name of a variable in interp to link to.
d3577 1
a3577 1
    CONST char *localName;	/* Name of link variable. */
d3581 37
a3617 1
    return Tcl_UpVar2(interp, frameName, varName, NULL, localName, flags);
d3645 1
a3645 1
    CONST char *frameName;	/* Name of the frame containing the source
d3647 1
a3647 2
    CONST char *part1;
    CONST char *part2;		/* Two parts of source variable name to
d3649 1
a3649 1
    CONST char *localName;	/* Name of link variable. */
a3654 1
    Tcl_Obj *part1Ptr;
d3656 2
a3657 1
    if (TclGetFrame(interp, frameName, &framePtr) == -1) {
d3660 2
a3661 8

    part1Ptr = Tcl_NewStringObj(part1, -1);
    Tcl_IncrRefCount(part1Ptr);
    result = ObjMakeUpvar(interp, framePtr, part1Ptr, part2, 0,
	    localName, flags, -1);
    TclDecrRefCount(part1Ptr);

    return result;
d3782 1
a3782 1
        if ((*tail == ':') && (tail > varName)) {
d3790 3
a3792 3
	result = ObjMakeUpvar(interp, (CallFrame *) NULL,
		objPtr, NULL, /*otherFlags*/ TCL_GLOBAL_ONLY,
	        /*myName*/ tail, /*myFlags*/ 0, -1);
a3846 6
    Tcl_Obj *varNamePtr;

    if (objc < 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "?name value...? name ?value?");
	return TCL_ERROR;
    }
d3854 2
a3855 3
	varNamePtr = objv[i];
	varName = TclGetString(varNamePtr);
	varPtr = TclObjLookupVar(interp, varNamePtr, NULL,
d3892 2
a3893 2
	    varValuePtr = TclPtrSetVar(interp, varPtr, arrayPtr, varName, NULL,
		    objv[i+1], (TCL_NAMESPACE_ONLY | TCL_LEAVE_ERR_MSG));
d3927 2
a3928 2
	    result = ObjMakeUpvar(interp, (CallFrame *) NULL,
		    /*otherP1*/ varNamePtr, /*otherP2*/ NULL,
d3930 1
a3930 1
		    /*myName*/ tail, /*myFlags*/ 0, -1);
d3964 1
d3966 2
a3967 1
    char *frameSpec, *localName;
d4000 28
a4027 3
	localName = TclGetString(objv[1]);
	result = ObjMakeUpvar(interp, framePtr, /* othervarName */ objv[0],
		NULL, 0, /* myVarName */ localName, /*flags*/ 0, -1);
d4038 1
a4038 33
 * DisposeTraceResult--
 *
 *	This procedure is called to dispose of the result returned from
 *	a trace procedure.  The disposal method appropriate to the type
 *	of result is determined by flags.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The memory allocated for the trace result may be freed.
 *
 *----------------------------------------------------------------------
 */

void
DisposeTraceResult(flags, result)
    int flags;			/* Indicates type of result to determine
				 * proper disposal method */
    char *result;		/* The result returned from a trace
				 * procedure to be disposed */
{
    if (flags & TCL_TRACE_RESULT_DYNAMIC) {
	ckfree(result);
    } else if (flags & TCL_TRACE_RESULT_OBJECT) {
	Tcl_DecrRefCount((Tcl_Obj *) result);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * CallVarTraces --
d4046 6
a4051 5
 *      Returns TCL_OK to indicate normal operation.  Returns TCL_ERROR
 *      if invocation of a trace procedure indicated an error.  When
 *      TCL_ERROR is returned and leaveErrMsg is true, then the
 *      ::errorInfo variable of iPtr has information about the error
 *      appended to it.
d4060 2
a4061 2
int 
CallVarTraces(iPtr, arrayPtr, varPtr, part1, part2, flags, leaveErrMsg)
d4068 1
a4068 2
    CONST char *part1;
    CONST char *part2;		/* Variable's two-part name. */
a4073 3
    CONST int leaveErrMsg;	/* If true, and one of the traces indicates an
				 * error, then leave an error message and stack
				 * trace information in *iPTr. */
d4077 1
a4077 2
    char *result;
    CONST char *openParen, *p;
a4079 2
    int code = TCL_OK;
    int disposeFlags = 0;
d4087 1
a4087 1
	return code;
a4090 3
    if (arrayPtr != NULL) {
	arrayPtr->refCount++;
    }
a4110 2
		    int offset = (openParen - part1);
		    char *newPart1;
d4113 4
a4116 4
		    newPart1 = Tcl_DStringValue(&nameCopy);
		    newPart1[offset] = 0;
		    part1 = newPart1;
		    part2 = newPart1 + offset + 1;
d4129 4
a4132 4
    active.nextPtr = iPtr->activeVarTracePtr;
    iPtr->activeVarTracePtr = &active;
    Tcl_Preserve((ClientData) iPtr);
    if (arrayPtr != NULL && !(arrayPtr->flags & VAR_TRACE_ACTIVE)) {
a4139 1
	    Tcl_Preserve((ClientData) tracePtr);
d4144 1
a4144 2
		    /* Ignore errors in unset traces */
		    DisposeTraceResult(tracePtr->flags, result);
d4146 1
a4146 2
	            disposeFlags = tracePtr->flags;
		    code = TCL_ERROR;
a4148 4
	    Tcl_Release((ClientData) tracePtr);
	    if (code == TCL_ERROR) {
		goto done;
	    }
a4165 1
	Tcl_Preserve((ClientData) tracePtr);
d4170 1
a4170 2
		/* Ignore errors in unset traces */
		DisposeTraceResult(tracePtr->flags, result);
d4172 1
a4172 2
		disposeFlags = tracePtr->flags;
		code = TCL_ERROR;
a4174 4
	Tcl_Release((ClientData) tracePtr);
	if (code == TCL_ERROR) {
	    goto done;
	}
a4182 27
    if (code == TCL_ERROR) {
	if (leaveErrMsg) {
	    CONST char *type = "";
	    switch (flags&(TCL_TRACE_READS|TCL_TRACE_WRITES|TCL_TRACE_ARRAY)) {
		case TCL_TRACE_READS: {
		    type = "read";
		    break;
		}
		case TCL_TRACE_WRITES: {
		    type = "set";
		    break;
		}
		case TCL_TRACE_ARRAY: {
		    type = "trace array";
		    break;
		}
	    }
	    if (disposeFlags & TCL_TRACE_RESULT_OBJECT) {
		VarErrMsg((Tcl_Interp *) iPtr, part1, part2, type,
			Tcl_GetString((Tcl_Obj *) result));
	    } else {
		VarErrMsg((Tcl_Interp *) iPtr, part1, part2, type, result);
	    }
	}
	DisposeTraceResult(disposeFlags,result);
    }

d4191 2
a4192 3
    iPtr->activeVarTracePtr = active.nextPtr;
    Tcl_Release((ClientData) iPtr);
    return code;
a4235 66
 * SetArraySearchObj --
 *
 *	This function converts the given tcl object into one that
 *	has the "array search" internal type.
 *
 * Results:
 *	TCL_OK if the conversion succeeded, and TCL_ERROR if it failed
 *	(when an error message will be placed in the interpreter's
 *	result.)
 *
 * Side effects:
 *	Updates the internal type and representation of the object to
 *	make this an array-search object.  See the tclArraySearchType
 *	declaration above for details of the internal representation.
 *
 *----------------------------------------------------------------------
 */

static int
SetArraySearchObj(interp, objPtr)
    Tcl_Interp *interp;
    Tcl_Obj *objPtr;
{
    char *string;
    char *end;
    int id;
    size_t offset;

    /*
     * Get the string representation. Make it up-to-date if necessary.
     */

    string = Tcl_GetString(objPtr);

    /*
     * Parse the id into the three parts separated by dashes.
     */
    if ((string[0] != 's') || (string[1] != '-')) {
	syntax:
	Tcl_AppendResult(interp, "illegal search identifier \"", string,
		"\"", (char *) NULL);
	return TCL_ERROR;
    }
    id = strtoul(string+2, &end, 10);
    if ((end == (string+2)) || (*end != '-')) {
	goto syntax;
    }
    /*
     * Can't perform value check in this context, so place reference
     * to place in string to use for the check in the object instead.
     */
    end++;
    offset = end - string;

    if (objPtr->typePtr != NULL && objPtr->typePtr->freeIntRepProc != NULL) {
	objPtr->typePtr->freeIntRepProc(objPtr);
    }
    objPtr->typePtr = &tclArraySearchType;
    objPtr->internalRep.twoPtrValue.ptr1 = (VOID *)(((char *)NULL)+id);
    objPtr->internalRep.twoPtrValue.ptr2 = (VOID *)(((char *)NULL)+offset);
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
d4238 1
a4238 1
 *	This procedure translates from a tcl object to a pointer to an
d4247 1
a4247 2
 *	The tcl object might have its internal type and representation
 *	modified.
d4253 1
a4253 1
ParseSearchId(interp, varPtr, varName, handleObj)
d4255 2
a4256 2
    CONST Var *varPtr;		/* Array variable search is for. */
    CONST char *varName;	/* Name of array variable that search is
d4258 1
a4258 1
    Tcl_Obj *handleObj;		/* Object containing id of search. Must have
d4263 1
a4263 2
    register char *string;
    register size_t offset;
d4268 1
a4268 1
     * Parse the id.
d4270 5
a4274 1
    if (Tcl_ConvertToType(interp, handleObj, &tclArraySearchType) != TCL_OK) {
d4277 5
a4281 13
    /*
     * Cast is safe, since always came from an int in the first place.
     */
    id = (int)(((char*)handleObj->internalRep.twoPtrValue.ptr1) -
	       ((char*)NULL));
    string = Tcl_GetString(handleObj);
    offset = (((char*)handleObj->internalRep.twoPtrValue.ptr2) -
	      ((char*)NULL));
    /*
     * This test cannot be placed inside the Tcl_Obj machinery, since
     * it is dependent on the variable context.
     */
    if (strcmp(string+offset, varName) != 0) {
a4289 4
     *
     * Note that we cannot store the searchPtr directly in the Tcl_Obj
     * as that would run into trouble when DeleteSearches() was called
     * so we must scan this list every time.
d4377 1
a4377 1
	flags |= TCL_GLOBAL_ONLY;
a4380 3
    if (Tcl_InterpDeleted(interp)) {
	flags |= TCL_INTERP_DESTROYED;
    }
d4414 1
a4414 1
	 * table is deleted). Note that we give CallVarTraces the variable's
d4423 2
a4424 2
	    CallVarTraces(iPtr, (Var *) NULL, varPtr, Tcl_GetString(objPtr),
		    NULL, flags, /* leaveErrMsg */ 0);
d4430 1
a4430 1
		Tcl_EventuallyFree((ClientData) tracePtr, TCL_DYNAMIC);
d4432 1
a4432 1
	    for (activePtr = iPtr->activeVarTracePtr; activePtr != NULL;
d4549 2
a4550 2
	    CallVarTraces(iPtr, (Var *) NULL, varPtr, varPtr->name, NULL,
		    flags, /* leaveErrMsg */ 0);
d4554 1
a4554 1
		Tcl_EventuallyFree((ClientData) tracePtr, TCL_DYNAMIC);
d4556 1
a4556 1
	    for (activePtr = iPtr->activeVarTracePtr; activePtr != NULL;
d4610 1
a4610 1
    CONST char *arrayName;	        /* Name of array (used for trace
d4613 1
a4613 1
    int flags;				/* Flags to pass to CallVarTraces:
d4637 2
a4638 3
	    CallVarTraces(iPtr, (Var *) NULL, elPtr, arrayName,
		    Tcl_GetHashKey(varPtr->value.tablePtr, hPtr), flags,
		    /* leaveErrMsg */ 0);
d4642 1
a4642 1
		Tcl_EventuallyFree((ClientData) tracePtr,TCL_DYNAMIC);
d4644 1
a4644 1
	    for (activePtr = iPtr->activeVarTracePtr; activePtr != NULL;
a4652 13

	/*
	 * Even though array elements are not supposed to be namespace
	 * variables, some combinations of [upvar] and [variable] may
	 * create such beasts - see [Bug 604239]. This is necessary to
	 * avoid leaking the corresponding Var struct, and is otherwise
	 * harmless. 
	 */

	if (elPtr->flags & VAR_NAMESPACE_VAR) {
	    elPtr->flags &= ~VAR_NAMESPACE_VAR;
	    elPtr->refCount--;
	}
d4732 2
a4733 3
    CONST char *part1;
    CONST char *part2;		/* Variable's two-part name. */
    CONST char *operation;      /* String describing operation that failed,
d4735 1
a4735 1
    CONST char *reason;         /* String describing why operation failed. */
d4745 1
d4768 1
a4768 1
    CONST char *varName;	/* The variable name */
d4772 1
d4785 2
a4786 2
            0, "access", /*createPart1*/ 0, /*createPart2*/ 1, &arrayPtr);

d4790 10
d4801 2
a4802 112
    if ((varPtr->tracePtr != NULL)
	    || ((arrayPtr != NULL) && (arrayPtr->tracePtr != NULL))) {
	CallVarTraces((Interp *)interp, arrayPtr, varPtr, varName, NULL,
		TCL_TRACE_READS, /* leaveErrMsg */ 0);
    }

    /*
     * If the variable doesn't exist anymore and no-one's using
     * it, then free up the relevant structures and hash table entries.
     */

    if (TclIsVarUndefined(varPtr)) {
	CleanupVar(varPtr, arrayPtr);
	return NULL;
    }

    return varPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * Internal functions for variable name object types --
 *
 *----------------------------------------------------------------------
 */

/* 
 * localVarName -
 *
 * INTERNALREP DEFINITION:
 *   twoPtrValue.ptr1 = pointer to the corresponding Proc 
 *   twoPtrValue.ptr2 = index into locals table
*/

static void 
FreeLocalVarName(objPtr)
    Tcl_Obj *objPtr;
{
    register Proc *procPtr = (Proc *) objPtr->internalRep.twoPtrValue.ptr1;
    procPtr->refCount--;
    if (procPtr->refCount <= 0) {
	TclProcCleanupProc(procPtr);
    }
}

static void
DupLocalVarName(srcPtr, dupPtr)
    Tcl_Obj *srcPtr;
    Tcl_Obj *dupPtr;
{
    register Proc *procPtr = (Proc *) srcPtr->internalRep.twoPtrValue.ptr1;

    dupPtr->internalRep.twoPtrValue.ptr1 = (VOID *) procPtr;
    dupPtr->internalRep.twoPtrValue.ptr2 = srcPtr->internalRep.twoPtrValue.ptr2;
    procPtr->refCount++;
    dupPtr->typePtr = &tclLocalVarNameType;
}

static void
UpdateLocalVarName(objPtr)
    Tcl_Obj *objPtr;
{
    Proc *procPtr = (Proc *) objPtr->internalRep.twoPtrValue.ptr1;
    unsigned int index = (unsigned int) objPtr->internalRep.twoPtrValue.ptr2;
    CompiledLocal *localPtr = procPtr->firstLocalPtr;
    unsigned int nameLen;

    if (localPtr == NULL) {
	goto emptyName;
    }
    while (index--) {
	localPtr = localPtr->nextPtr;
	if (localPtr == NULL) {
	    goto emptyName;
	}
    }

    nameLen = (unsigned int) localPtr->nameLength;
    objPtr->bytes = ckalloc(nameLen + 1);
    memcpy(objPtr->bytes, localPtr->name, nameLen + 1);
    objPtr->length = nameLen;
    return;

    emptyName:
    objPtr->bytes = ckalloc(1);
    *(objPtr->bytes) = '\0';
    objPtr->length = 0;
}

/* 
 * nsVarName -
 *
 * INTERNALREP DEFINITION:
 *   twoPtrValue.ptr1: pointer to the namespace containing the 
 *                     reference.
 *   twoPtrValue.ptr2: pointer to the corresponding Var 
*/

static void 
FreeNsVarName(objPtr)
    Tcl_Obj *objPtr;
{
    register Var *varPtr = (Var *) objPtr->internalRep.twoPtrValue.ptr2;

    varPtr->refCount--;
    if (TclIsVarUndefined(varPtr) && (varPtr->refCount <= 0)) {
	if (TclIsVarLink(varPtr)) {
	    Var *linkPtr = varPtr->value.linkPtr;
	    linkPtr->refCount--;
	    if (TclIsVarUndefined(linkPtr) && (linkPtr->refCount <= 0)) {
		CleanupVar(linkPtr, (Var *) NULL);
d4804 1
a4805 1
	CleanupVar(varPtr, NULL);
d4807 1
a4807 97
}

static void
DupNsVarName(srcPtr, dupPtr)
    Tcl_Obj *srcPtr;
    Tcl_Obj *dupPtr;
{
    Namespace *nsPtr = (Namespace *) srcPtr->internalRep.twoPtrValue.ptr1;
    register Var *varPtr = (Var *) srcPtr->internalRep.twoPtrValue.ptr2;

    dupPtr->internalRep.twoPtrValue.ptr1 =  (VOID *) nsPtr;
    dupPtr->internalRep.twoPtrValue.ptr2 = (VOID *) varPtr;
    varPtr->refCount++;
    dupPtr->typePtr = &tclNsVarNameType;
}

/* 
 * parsedVarName -
 *
 * INTERNALREP DEFINITION:
 *   twoPtrValue.ptr1 = pointer to the array name Tcl_Obj
 *                      (NULL if scalar)
 *   twoPtrValue.ptr2 = pointer to the element name string
 *                      (owned by this Tcl_Obj), or NULL if 
 *                      it is a scalar variable
 */

static void 
FreeParsedVarName(objPtr)
    Tcl_Obj *objPtr;
{
    register Tcl_Obj *arrayPtr =
	    (Tcl_Obj *) objPtr->internalRep.twoPtrValue.ptr1;
    register char *elem = (char *) objPtr->internalRep.twoPtrValue.ptr2;
    
    if (arrayPtr != NULL) {
	TclDecrRefCount(arrayPtr);
	ckfree(elem);
    }
}

static void
DupParsedVarName(srcPtr, dupPtr)
    Tcl_Obj *srcPtr;
    Tcl_Obj *dupPtr;
{
    register Tcl_Obj *arrayPtr =
	    (Tcl_Obj *) srcPtr->internalRep.twoPtrValue.ptr1;
    register char *elem = (char *) srcPtr->internalRep.twoPtrValue.ptr2;
    char *elemCopy;
    unsigned int elemLen;

    if (arrayPtr != NULL) {
	Tcl_IncrRefCount(arrayPtr);
	elemLen = strlen(elem);
	elemCopy = ckalloc(elemLen+1);
	memcpy(elemCopy, elem, elemLen);
	*(elemCopy + elemLen) = '\0';
	elem = elemCopy;
    }

    dupPtr->internalRep.twoPtrValue.ptr1 = (VOID *) arrayPtr;
    dupPtr->internalRep.twoPtrValue.ptr2 = (VOID *) elem;
    dupPtr->typePtr = &tclParsedVarNameType;
}

static void
UpdateParsedVarName(objPtr)
    Tcl_Obj *objPtr;
{
    Tcl_Obj *arrayPtr = (Tcl_Obj *) objPtr->internalRep.twoPtrValue.ptr1;
    char *part2 = (char *) objPtr->internalRep.twoPtrValue.ptr2;
    char *part1, *p;
    int len1, len2, totalLen;

    if (arrayPtr == NULL) {
	/*
	 * This is a parsed scalar name: what is it
	 * doing here?
	 */
	panic("ERROR: scalar parsedVarName without a string rep.\n");
    }
    part1 = Tcl_GetStringFromObj(arrayPtr, &len1);
    len2 = strlen(part2);
	
    totalLen = len1 + len2 + 2;
    p = ckalloc((unsigned int) totalLen + 1);
    objPtr->bytes = p;
    objPtr->length = totalLen;

    memcpy(p, part1, (unsigned int) len1);
    p += len1;
    *p++ = '(';
    memcpy(p, part2, (unsigned int) len2);
    p += len2;
    *p++ = ')';
    *p   = '\0';
@


1.2
log
@touched all Tcl files to ease next import.
@
text
@@


1.2.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.2.16.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@a12 1
 * Copyright (c) 2001 by Kevin B. Kenny.  All rights reserved.
d28 9
a36 11
static CONST char *noSuchVar =		"no such variable";
static CONST char *isArray =		"variable is array";
static CONST char *needArray =		"variable isn't array";
static CONST char *noSuchElement =	"no such element in array";
static CONST char *danglingElement =
				"upvar refers to element in deleted array";
static CONST char *danglingVar =	
				"upvar refers to variable in deleted namespace";
static CONST char *badNamespace =	"parent namespace doesn't exist";
static CONST char *missingName =	"missing variable name";
static CONST char *isArrayElement =	"name refers to an element in an array";
d42 3
a44 3
static int		CallVarTraces _ANSI_ARGS_((Interp *iPtr, Var *arrayPtr,
			    Var *varPtr, CONST char *part1, CONST char *part2,
			    int flags, CONST int leaveErrMsg));
d49 5
a53 7
			    CONST char *arrayName, Var *varPtr, int flags));
static void		DisposeTraceResult _ANSI_ARGS_((int flags,
			    char *result));
static int              ObjMakeUpvar _ANSI_ARGS_((Tcl_Interp *interp, 
                            CallFrame *framePtr, Tcl_Obj *otherP1Ptr, 
                            CONST char *otherP2, CONST int otherFlags,
		            CONST char *myName, CONST int myFlags, int index));
d56 1
a56 2
			    CONST Var *varPtr, CONST char *varName,
			    Tcl_Obj *handleObj));
d58 2
a59 78
			    CONST char *part1, CONST char *part2,
			    CONST char *operation, CONST char *reason));
static int		SetArraySearchObj _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_Obj *objPtr));


/*
 * Functions defined in this file that may be exported in the future
 * for use by the bytecode compiler and engine or to the public interface.
 */

Var *		TclLookupSimpleVar _ANSI_ARGS_((Tcl_Interp *interp,
		    CONST char *varName, int flags, CONST int create,
		    CONST char **errMsgPtr, int *indexPtr));
int		TclObjUnsetVar2 _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Obj *part1Ptr, CONST char *part2, int flags));

static Tcl_FreeInternalRepProc FreeLocalVarName;
static Tcl_DupInternalRepProc DupLocalVarName;
static Tcl_UpdateStringProc UpdateLocalVarName;
static Tcl_FreeInternalRepProc FreeNsVarName;
static Tcl_DupInternalRepProc DupNsVarName;
static Tcl_FreeInternalRepProc FreeParsedVarName;
static Tcl_DupInternalRepProc DupParsedVarName;
static Tcl_UpdateStringProc UpdateParsedVarName;

/*
 * Types of Tcl_Objs used to cache variable lookups.
 *
 * 
 * localVarName - INTERNALREP DEFINITION:
 *   twoPtrValue.ptr1 = pointer to the corresponding Proc 
 *   twoPtrValue.ptr2 = index into locals table
 *
 * nsVarName - INTERNALREP DEFINITION:
 *   twoPtrValue.ptr1: pointer to the namespace containing the 
 *                     reference
 *   twoPtrValue.ptr2: pointer to the corresponding Var 
 *
 * parsedVarName - INTERNALREP DEFINITION:
 *   twoPtrValue.ptr1 = pointer to the array name Tcl_Obj, 
 *                      or NULL if it is a scalar variable
 *   twoPtrValue.ptr2 = pointer to the element name string
 *                      (owned by this Tcl_Obj), or NULL if 
 *                      it is a scalar variable
 */

Tcl_ObjType tclLocalVarNameType = {
    "localVarName",
    FreeLocalVarName, DupLocalVarName, UpdateLocalVarName, NULL
};

Tcl_ObjType tclNsVarNameType = {
    "namespaceVarName",
    FreeNsVarName, DupNsVarName, NULL, NULL
};

Tcl_ObjType tclParsedVarNameType = {
    "parsedVarName",
    FreeParsedVarName, DupParsedVarName, UpdateParsedVarName, NULL
};

/*
 * Type of Tcl_Objs used to speed up array searches.
 *
 * INTERNALREP DEFINITION:
 *   twoPtrValue.ptr1 = searchIdNumber as offset from (char*)NULL
 *   twoPtrValue.ptr2 = variableNameStartInString as offset from (char*)NULL
 *
 * Note that the value stored in ptr2 is the offset into the string of
 * the start of the variable name and not the address of the variable
 * name itself, as this can be safely copied.
 */
Tcl_ObjType tclArraySearchType = {
    "array search",
    NULL, NULL, NULL, SetArraySearchObj
};

d66 2
a67 5
 *	This procedure is used to locate a variable given its name(s). It
 *      has been mostly superseded by TclObjLookupVar, it is now only used 
 *      by the string-based interfaces. It is kept in tcl8.4 mainly because 
 *      it is in the internal stubs table, so that some extension may be 
 *      calling it. 
d96 1
d101 1
a101 1
    CONST char *part1;	        /* If part2 isn't NULL, this is the name of
d105 1
a105 1
    CONST char *part2;		/* Name of element within array, or NULL. */
d108 1
a108 1
    CONST char *msg;			/* Verb to use in error messages, e.g.
d122 12
a133 2
    Var *varPtr;
    CONST char *elName;		/* Name of array element or NULL; may be
d135 1
a135 1
    int openParen, closeParen;
d137 9
a145 9
				 * array and index, these are the offsets to 
				 * the parens around the index.  Otherwise 
				 * they are -1. */
    register CONST char *p;
    CONST char *errMsg = NULL;
    int index;
#define VAR_NAME_BUF_SIZE 26
    char buffer[VAR_NAME_BUF_SIZE];
    char *newVarName = buffer;
d149 2
a150 1
    openParen = closeParen = -1;
d165 1
a165 1
	    openParen = p - part1;
d172 1
d176 1
a176 1
		    return NULL;
d178 3
a180 1
		closeParen = p - part1;
d182 1
a182 1
		openParen = -1;
a186 414
    if (openParen != -1) {
	if (closeParen >= VAR_NAME_BUF_SIZE) {
	    newVarName = ckalloc((unsigned int) (closeParen+1));
	}
	memcpy(newVarName, part1, (unsigned int) closeParen);
	newVarName[openParen] = '\0';
	newVarName[closeParen] = '\0';
	part1 = newVarName;
	elName = newVarName + openParen + 1;
    }

    varPtr = TclLookupSimpleVar(interp, part1, flags, 
            createPart1, &errMsg, &index);
    if (varPtr == NULL) {
	if ((errMsg != NULL) && (flags & TCL_LEAVE_ERR_MSG)) {
	    VarErrMsg(interp, part1, elName, msg, errMsg);
	}
    } else {
	while (TclIsVarLink(varPtr)) {
	    varPtr = varPtr->value.linkPtr;
	}
	if (elName != NULL) {
	    *arrayPtrPtr = varPtr;
	    varPtr = TclLookupArrayElement(interp, part1, elName, flags, 
		    msg, createPart1, createPart2, varPtr);
	}
    }
    if (newVarName != buffer) {
	ckfree(newVarName);
    }

    return varPtr;
	
#undef VAR_NAME_BUF_SIZE
}

/*
 *----------------------------------------------------------------------
 *
 * TclObjLookupVar --
 *
 *	This procedure is used by virtually all of the variable code to
 *	locate a variable given its name(s). The parsing into array/element
 *      components and (if possible) the lookup results are cached in 
 *      part1Ptr, which is converted to one of the varNameTypes.
 *
 * Results:
 *	The return value is a pointer to the variable structure indicated by
 *	part1Ptr and part2, or NULL if the variable couldn't be found. If 
 *      the variable is found, *arrayPtrPtr is filled with the address of the
 *	variable structure for the array that contains the variable (or NULL
 *	if the variable is a scalar). If the variable can't be found and
 *	either createPart1 or createPart2 are 1, a new as-yet-undefined
 *	(VAR_UNDEFINED) variable structure is created, entered into a hash
 *	table, and returned.
 *
 *	If the variable isn't found and creation wasn't specified, or some
 *	other error occurs, NULL is returned and an error message is left in
 *	the interp's result if TCL_LEAVE_ERR_MSG is set in flags. 
 *
 *	Note: it's possible for the variable returned to be VAR_UNDEFINED
 *	even if createPart1 or createPart2 are 1 (these only cause the hash
 *	table entry or array to be created). For example, the variable might
 *	be a global that has been unset but is still referenced by a
 *	procedure, or a variable that has been unset but it only being kept
 *	in existence (if VAR_UNDEFINED) by a trace.
 *
 * Side effects:
 *	New hashtable entries may be created if createPart1 or createPart2
 *	are 1.
 *      The object part1Ptr is converted to one of tclLocalVarNameType, 
 *      tclNsVarNameType or tclParsedVarNameType and caches as much of the
 *      lookup as it can.
 *
 *----------------------------------------------------------------------
 */
Var *
TclObjLookupVar(interp, part1Ptr, part2, flags, msg, createPart1, createPart2,
        arrayPtrPtr)
    Tcl_Interp *interp;		/* Interpreter to use for lookup. */
    register Tcl_Obj *part1Ptr;	/* If part2 isn't NULL, this is the name 
				 * of an array. Otherwise, this is a full 
				 * variable name that could include a parenthesized 
				 * array element. */
    CONST char *part2;		/* Name of element within array, or NULL. */
    int flags;		        /* Only TCL_GLOBAL_ONLY, TCL_NAMESPACE_ONLY,
				 * and TCL_LEAVE_ERR_MSG bits matter. */
    CONST char *msg;		/* Verb to use in error messages, e.g.
				 * "read" or "set". Only needed if
				 * TCL_LEAVE_ERR_MSG is set in flags. */
    CONST int createPart1;	/* If 1, create hash table entry for part 1
				 * of name, if it doesn't already exist. If
				 * 0, return error if it doesn't exist. */
    CONST int createPart2;	/* If 1, create hash table entry for part 2
				 * of name, if it doesn't already exist. If
				 * 0, return error if it doesn't exist. */
    Var **arrayPtrPtr;		/* If the name refers to an element of an
				 * array, *arrayPtrPtr gets filled in with
				 * address of array variable. Otherwise
				 * this is set to NULL. */
{
    Interp *iPtr = (Interp *) interp;
    register Var *varPtr;	/* Points to the variable's in-frame Var
				 * structure. */
    char *part1;
    int index, len1, len2;
    int parsed = 0;
    Tcl_Obj *objPtr;
    Tcl_ObjType *typePtr = part1Ptr->typePtr;
    CONST char *errMsg = NULL;
    CallFrame *varFramePtr = iPtr->varFramePtr;
    Namespace *nsPtr;

    /*
     * If part1Ptr is a tclParsedVarNameType, separate it into the 
     * pre-parsed parts.
     */

    *arrayPtrPtr = NULL;
    if (typePtr == &tclParsedVarNameType) {
	if (part1Ptr->internalRep.twoPtrValue.ptr1 != NULL) {
	    if (part2 != NULL) {
		/*
		 * ERROR: part1Ptr is already an array element, cannot 
		 * specify a part2.
		 */

		if (flags & TCL_LEAVE_ERR_MSG) {
		    part1 = TclGetString(part1Ptr);
		    VarErrMsg(interp, part1, part2, msg, needArray);
		}
		return NULL;
	    }
	    part2 = (char *) part1Ptr->internalRep.twoPtrValue.ptr2;
	    part1Ptr = (Tcl_Obj *) part1Ptr->internalRep.twoPtrValue.ptr1;
	    typePtr = part1Ptr->typePtr;
	}
	parsed = 1;
    }
    part1 = Tcl_GetStringFromObj(part1Ptr, &len1);    

    nsPtr = ((varFramePtr == NULL)? iPtr->globalNsPtr : varFramePtr->nsPtr);
    if (nsPtr->varResProc != NULL || iPtr->resolverPtr != NULL) {
	goto doParse;
    }
    
    if (typePtr == &tclLocalVarNameType) {
	Proc *procPtr = (Proc *) part1Ptr->internalRep.twoPtrValue.ptr1;
	int localIndex = (int) part1Ptr->internalRep.twoPtrValue.ptr2;
	int useLocal;

	useLocal = ((varFramePtr != NULL) && varFramePtr->isProcCallFrame
	        && !(flags & (TCL_GLOBAL_ONLY | TCL_NAMESPACE_ONLY)));
	if (useLocal && (procPtr == varFramePtr->procPtr)) {
	    /*
	     * part1Ptr points to an indexed local variable of the
	     * correct procedure: use the cached value.
	     */
	    
	    varPtr = &(varFramePtr->compiledLocals[localIndex]);
	    goto donePart1;
	}
	goto doneParsing;
    } else if (typePtr == &tclNsVarNameType) {
	Namespace *cachedNsPtr;
	int useGlobal, useReference;

	varPtr = (Var *) part1Ptr->internalRep.twoPtrValue.ptr2;
	cachedNsPtr = (Namespace *) part1Ptr->internalRep.twoPtrValue.ptr1;
	useGlobal = (cachedNsPtr == iPtr->globalNsPtr) 
	    && ((flags & TCL_GLOBAL_ONLY) 
		|| ((*part1 == ':') && (*(part1+1) == ':'))
		|| (varFramePtr == NULL) 
		|| (!varFramePtr->isProcCallFrame 
		    && (nsPtr == iPtr->globalNsPtr)));
	useReference = useGlobal || ((cachedNsPtr == nsPtr) 
	        && ((flags & TCL_NAMESPACE_ONLY) 
		    || (varFramePtr && !varFramePtr->isProcCallFrame 
			&& !(flags & TCL_GLOBAL_ONLY)
			/* careful: an undefined ns variable could
			 * be hiding a valid global reference. */
			&& !(varPtr->flags & VAR_UNDEFINED))));
	if (useReference && (varPtr->hPtr != NULL)) {
	    /*
	     * A straight global or namespace reference, use it. It isn't 
	     * so simple to deal with 'implicit' namespace references, i.e., 
	     * those where the reference could be to either a namespace 
	     * or a global variable. Those we lookup again.
	     *
	     * If (varPtr->hPtr == NULL), this might be a reference to a
	     * variable in a deleted namespace, kept alive by e.g. part1Ptr.
	     * We could conceivably be so unlucky that a new namespace was
	     * created at the same address as the deleted one, so to be 
	     * safe we test for a valid hPtr.
	     */
	    goto donePart1;
	}
	goto doneParsing;
    }

    doParse:
    if (!parsed && (*(part1 + len1 - 1) == ')')) {
	/*
	 * part1Ptr is possibly an unparsed array element.
	 */
	register int i;
	char *newPart2;
	len2 = -1;
	for (i = 0; i < len1; i++) {
	    if (*(part1 + i) == '(') {
		if (part2 != NULL) {
		    if (flags & TCL_LEAVE_ERR_MSG) {
			VarErrMsg(interp, part1, part2, msg, needArray);
		    }
		}			

		/*
		 * part1Ptr points to an array element; first copy 
		 * the element name to a new string part2.
		 */

		part2 = part1 + i + 1;
		len2 = len1 - i - 2;
		len1 = i;

		newPart2 = ckalloc((unsigned int) (len2+1));
		memcpy(newPart2, part2, (unsigned int) len2);
		*(newPart2+len2) = '\0';
		part2 = newPart2;

		/*
		 * Free the internal rep of the original part1Ptr, now
		 * renamed objPtr, and set it to tclParsedVarNameType.
		 */

		objPtr = part1Ptr;
		if ((typePtr != NULL) && (typePtr->freeIntRepProc != NULL)) {
		    typePtr->freeIntRepProc(objPtr);
		}
		objPtr->typePtr = &tclParsedVarNameType;

		/*
		 * Define a new string object to hold the new part1Ptr, i.e., 
		 * the array name. Set the internal rep of objPtr, reset
		 * typePtr and part1 to contain the references to the
		 * array name.
		 */

		part1Ptr = Tcl_NewStringObj(part1, len1);
		Tcl_IncrRefCount(part1Ptr);

		objPtr->internalRep.twoPtrValue.ptr1 = (VOID *) part1Ptr;
		objPtr->internalRep.twoPtrValue.ptr2 = (VOID *) part2;		

		typePtr = part1Ptr->typePtr;
		part1 = TclGetString(part1Ptr);
		break;
	    }
	}
    }
    
    doneParsing:
    /*
     * part1Ptr is not an array element; look it up, and convert 
     * it to one of the cached types if possible.
     */

    if ((typePtr != NULL) && (typePtr->freeIntRepProc != NULL)) {
	typePtr->freeIntRepProc(part1Ptr);
	part1Ptr->typePtr = NULL;
    }

    varPtr = TclLookupSimpleVar(interp, part1, flags, 
            createPart1, &errMsg, &index);
    if (varPtr == NULL) {
	if ((errMsg != NULL) && (flags & TCL_LEAVE_ERR_MSG)) {
	    VarErrMsg(interp, part1, part2, msg, errMsg);
	}
	return NULL;
    }

    /*
     * Cache the newly found variable if possible.
     */

    if (index >= 0) {
        /*
	 * An indexed local variable.
	 */

	Proc *procPtr = ((Interp *) interp)->varFramePtr->procPtr;

	part1Ptr->typePtr = &tclLocalVarNameType;
	procPtr->refCount++;
	part1Ptr->internalRep.twoPtrValue.ptr1 = (VOID *) procPtr;
	part1Ptr->internalRep.twoPtrValue.ptr2 = (VOID *) index;
    } else if (index > -3) {
	Namespace *nsPtr;
    
	nsPtr = ((index == -1)? iPtr->globalNsPtr : varFramePtr->nsPtr);
	varPtr->refCount++;
	part1Ptr->typePtr = &tclNsVarNameType;
	part1Ptr->internalRep.twoPtrValue.ptr1 = (VOID *) nsPtr;
	part1Ptr->internalRep.twoPtrValue.ptr2 = (VOID *) varPtr;
    } else {
	/*
	 * At least mark part1Ptr as already parsed.
	 */
	part1Ptr->typePtr = &tclParsedVarNameType;
	part1Ptr->internalRep.twoPtrValue.ptr1 = NULL;
	part1Ptr->internalRep.twoPtrValue.ptr2 = NULL;
    }
    
    donePart1:
#if 0
    if (varPtr == NULL) {
	if (flags & TCL_LEAVE_ERR_MSG) {
	    part1 = TclGetString(part1Ptr);
	    VarErrMsg(interp, part1, part2, msg, 
		    "Cached variable reference is NULL.");
	}
	return NULL;
    }
#endif
    while (TclIsVarLink(varPtr)) {
	varPtr = varPtr->value.linkPtr;
    }

    if (part2 != NULL) {
	/*
	 * Array element sought: look it up.
	 */

	part1 = TclGetString(part1Ptr);
	*arrayPtrPtr = varPtr;
	varPtr = TclLookupArrayElement(interp, part1, part2, 
                flags, msg, createPart1, createPart2, varPtr);
    }
    return varPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * TclLookupSimpleVar --
 *
 *	This procedure is used by to locate a simple variable (i.e., not
 *      an array element) given its name.
 *
 * Results:
 *	The return value is a pointer to the variable structure indicated by
 *	varName, or NULL if the variable couldn't be found. If the variable 
 *      can't be found and create is 1, a new as-yet-undefined (VAR_UNDEFINED) 
 *      variable structure is created, entered into a hash table, and returned.
 *
 *      If the current CallFrame corresponds to a proc and the variable found is
 *      one of the compiledLocals, its index is placed in *indexPtr. Otherwise,
 *      *indexPtr will be set to (according to the needs of TclObjLookupVar):
 *               -1 a global reference
 *               -2 a reference to a namespace variable
 *               -3 a non-cachable reference, i.e., one of:
 *                    . non-indexed local var
 *                    . a reference of unknown origin;
 *                    . resolution by a namespace or interp resolver
 *
 *	If the variable isn't found and creation wasn't specified, or some
 *	other error occurs, NULL is returned and the corresponding error
 *	message is left in *errMsgPtr. 
 *
 *	Note: it's possible for the variable returned to be VAR_UNDEFINED
 *	even if create is 1 (this only causes the hash table entry to be
 *	created).  For example, the variable might be a global that has been
 *	unset but is still referenced by a procedure, or a variable that has
 *	been unset but it only being kept in existence (if VAR_UNDEFINED) by
 *	a trace.
 *
 * Side effects:
 *	A new hashtable entry may be created if create is 1.
 *
 *----------------------------------------------------------------------
 */

Var *
TclLookupSimpleVar(interp, varName, flags, create, errMsgPtr, indexPtr)
    Tcl_Interp *interp;		/* Interpreter to use for lookup. */
    CONST char *varName;        /* This is a simple variable name that could
				 * representa scalar or an array. */
    int flags;		        /* Only TCL_GLOBAL_ONLY, TCL_NAMESPACE_ONLY,
				 * and TCL_LEAVE_ERR_MSG bits matter. */
    CONST int create;		/* If 1, create hash table entry for varname,
				 * if it doesn't already exist. If 0, return 
				 * error if it doesn't exist. */
    CONST char **errMsgPtr;
    int *indexPtr;
{    
    Interp *iPtr = (Interp *) interp;
    CallFrame *varFramePtr = iPtr->varFramePtr;
				/* Points to the procedure call frame whose
				 * variables are currently in use. Same as
				 * the current procedure's frame, if any,
				 * unless an "uplevel" is executing. */
    Tcl_HashTable *tablePtr;	/* Points to the hashtable, if any, in which
				 * to look up the variable. */
    Tcl_Var var;                /* Used to search for global names. */
    Var *varPtr;		/* Points to the Var structure returned for
				 * the variable. */
    Namespace *varNsPtr, *cxtNsPtr, *dummy1Ptr, *dummy2Ptr;
    ResolverScheme *resPtr;
    Tcl_HashEntry *hPtr;
    int new, i, result;

    varPtr = NULL;
    varNsPtr = NULL;		/* set non-NULL if a nonlocal variable */
    *indexPtr = -3;
d194 1
a194 1
    if ((flags & TCL_GLOBAL_ONLY) || iPtr->varFramePtr == NULL) {
d204 1
a204 1
            result = (*cxtNsPtr->varResProc)(interp, varName,
d212 1
a212 1
                result = (*resPtr->varResProc)(interp, varName,
d220 1
a220 1
	    return varPtr;
d222 1
a222 1
	    return NULL;
d227 1
a227 1
     * Look up varName. Look it up as either a namespace variable or as a
d229 1
a229 1
     * Interpret varName as a namespace variable if:
d235 1
a235 1
     * Otherwise, if varName is a local variable, search first in the
d239 1
a239 1
     * If create and the variable isn't found, create the variable and,
d246 2
a247 3
	    || (strstr(varName, "::") != NULL)) {
	CONST char *tail;
	int lookGlobal;
a248 10
	lookGlobal = (flags & TCL_GLOBAL_ONLY) 
	    || (cxtNsPtr == iPtr->globalNsPtr)
	    || ((*varName == ':') && (*(varName+1) == ':'));
	if (lookGlobal) {
	    *indexPtr = -1;
	    flags = (flags | TCL_GLOBAL_ONLY) & ~TCL_NAMESPACE_ONLY;
	} else if (flags & TCL_NAMESPACE_ONLY) {
	    *indexPtr = -2;
	}

d253 1
a253 1
	var = Tcl_FindNamespaceVar(interp, varName, (Tcl_Namespace *) cxtNsPtr,
d259 2
a260 2
	    if (create) {   /* var wasn't found so create it  */
		TclGetNamespaceForQualName(interp, varName, cxtNsPtr,
d262 1
d264 4
a267 2
		    *errMsgPtr = badNamespace;
		    return NULL;
d270 4
a273 2
		    *errMsgPtr = missingName;
		    return NULL;
d280 3
a282 9
		if ((lookGlobal)  || (varNsPtr == NULL)) {
		    /*
		     * The variable was created starting from the global
		     * namespace: a global reference is returned even if 
		     * it wasn't explicitly requested.
		     */
		    *indexPtr = -1;
		} else {
		    *indexPtr = -2;
d284 1
a284 3
	    } else {		/* var wasn't found and not to create it */
		*errMsgPtr = noSuchVar;
		return NULL;
d292 1
a292 1
	int varNameLen = strlen(varName);
d297 5
a301 5
		if ((varName[0] == localName[0])
		        && (varNameLen == localPtr->nameLength)
		        && (strcmp(varName, localName) == 0)) {
		    *indexPtr = i;
		    return localVarPtr;
d307 29
a335 15
	tablePtr = varFramePtr->varTablePtr;
	if (create) {
	    if (tablePtr == NULL) {
		tablePtr = (Tcl_HashTable *)
		    ckalloc(sizeof(Tcl_HashTable));
		Tcl_InitHashTable(tablePtr, TCL_STRING_KEYS);
		varFramePtr->varTablePtr = tablePtr;
	    }
	    hPtr = Tcl_CreateHashEntry(tablePtr, varName, &new);
	    if (new) {
		varPtr = NewVar();
		Tcl_SetHashValue(hPtr, varPtr);
		varPtr->hPtr = hPtr;
		varPtr->nsPtr = NULL; /* a local variable */
	    } else {
a337 10
	} else {
	    hPtr = NULL;
	    if (tablePtr != NULL) {
		hPtr = Tcl_FindHashEntry(tablePtr, varName);
	    }
	    if (hPtr == NULL) {
		*errMsgPtr = noSuchVar;
		return NULL;
	    }
	    varPtr = (Var *) Tcl_GetHashValue(hPtr);
a339 39
    return varPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * TclLookupArrayElement --
 *
 *	This procedure is used to locate a variable which is in an array's 
 *      hashtable given a pointer to the array's Var structure and the 
 *      element's name.
 *
 * Results:
 *	The return value is a pointer to the variable structure , or NULL if 
 *      the variable couldn't be found. 
 *
 *      If arrayPtr points to a variable that isn't an array and createPart1 
 *      is 1, the corresponding variable will be converted to an array. 
 *      Otherwise, NULL is returned and an error message is left in
 *	the interp's result if TCL_LEAVE_ERR_MSG is set in flags.
 *
 *      If the variable is not found and createPart2 is 1, the variable is
 *      created. Otherwise, NULL is returned and an error message is left in
 *	the interp's result if TCL_LEAVE_ERR_MSG is set in flags.
 *
 *	Note: it's possible for the variable returned to be VAR_UNDEFINED
 *	even if createPart1 or createPart2 are 1 (these only cause the hash
 *	table entry or array to be created). For example, the variable might
 *	be a global that has been unset but is still referenced by a
 *	procedure, or a variable that has been unset but it only being kept
 *	in existence (if VAR_UNDEFINED) by a trace.
 *
 * Side effects:
 *      The variable at arrayPtr may be converted to be an array if 
 *      createPart1 is 1. A new hashtable entry may be created if createPart2 
 *      is 1.
 *
 *----------------------------------------------------------------------
 */
d341 23
a363 21
Var *
TclLookupArrayElement(interp, arrayName, elName, flags, msg, createArray, createElem, arrayPtr)
    Tcl_Interp *interp;		/* Interpreter to use for lookup. */
    CONST char *arrayName;	        /* This is the name of the array. */
    CONST char *elName;		/* Name of element within array. */
    CONST int flags;		/* Only TCL_LEAVE_ERR_MSG bit matters. */
    CONST char *msg;			/* Verb to use in error messages, e.g.
				 * "read" or "set". Only needed if
				 * TCL_LEAVE_ERR_MSG is set in flags. */
    CONST int createArray;	/* If 1, transform arrayName to be an array
				 * if it isn't one yet and the transformation 
				 * is possible. If 0, return error if it 
				 * isn't already an array. */
    CONST int createElem;	/* If 1, create hash table entry for the 
				 * element, if it doesn't already exist. If
				 * 0, return error if it doesn't exist. */
    Var *arrayPtr;	        /* Pointer to the array's Var structure. */
{
    Tcl_HashEntry *hPtr;
    int new;
    Var *varPtr;
d370 2
a371 2
    if (TclIsVarUndefined(arrayPtr) && !TclIsVarArrayElement(arrayPtr)) {
	if (!createArray) {
d373 1
a373 1
		VarErrMsg(interp, arrayName, elName, msg, noSuchVar);
d375 2
a376 1
	    return NULL;
d383 1
a383 1
	if ((arrayPtr->flags & VAR_IN_HASHTABLE) && (arrayPtr->hPtr == NULL)) {
d385 1
a385 1
		VarErrMsg(interp, arrayName, elName, msg, danglingVar);
d387 2
a388 1
	    return NULL;
d391 3
a393 3
	TclSetVarArray(arrayPtr);
	TclClearVarUndefined(arrayPtr);
	arrayPtr->value.tablePtr =
d395 2
a396 2
	Tcl_InitHashTable(arrayPtr->value.tablePtr, TCL_STRING_KEYS);
    } else if (!TclIsVarArray(arrayPtr)) {
d398 1
a398 1
	    VarErrMsg(interp, arrayName, elName, msg, needArray);
d400 2
a401 1
	return NULL;
d403 9
a411 3

    if (createElem) {
	hPtr = Tcl_CreateHashEntry(arrayPtr->value.tablePtr, elName, &new);
d413 2
a414 2
	    if (arrayPtr->searchPtr != NULL) {
		DeleteSearches(arrayPtr);
d419 1
a419 1
	    varPtr->nsPtr = arrayPtr->nsPtr;
d423 4
a426 1
	hPtr = Tcl_FindHashEntry(arrayPtr->value.tablePtr, elName);
d429 1
a429 1
		VarErrMsg(interp, arrayName, elName, msg, noSuchElement);
d431 2
a432 1
	    return NULL;
d435 7
a441 1
    return (Var *) Tcl_GetHashValue(hPtr);
d466 1
a466 1
CONST char *
d470 1
a470 1
    CONST char *varName;	/* Name of a variable in interp. */
d501 1
a501 1
CONST char *
d505 1
a505 1
    CONST char *part1;		/* Name of an array (if part2 is non-NULL)
d507 1
a507 1
    CONST char *part2;		/* If non-NULL, gives the name of an element
a520 52

/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetVar2Ex --
 *
 *	Return the value of a Tcl variable as a Tcl object, given a
 *	two-part name consisting of array name and element within array.
 *
 * Results:
 *	The return value points to the current object value of the variable
 *	given by part1Ptr and part2Ptr. If the specified variable doesn't
 *	exist, or if there is a clash in array usage, then NULL is returned
 *	and a message will be left in the interpreter's result if the
 *	TCL_LEAVE_ERR_MSG flag is set.
 *
 * Side effects:
 *	The ref count for the returned object is _not_ incremented to
 *	reflect the returned reference; if you want to keep a reference to
 *	the object you must increment its ref count yourself.
 *
 *----------------------------------------------------------------------
 */

Tcl_Obj *
Tcl_GetVar2Ex(interp, part1, part2, flags)
    Tcl_Interp *interp;		/* Command interpreter in which variable is
				 * to be looked up. */
    CONST char *part1;		/* Name of an array (if part2 is non-NULL)
				 * or the name of a variable. */
    CONST char *part2;		/* If non-NULL, gives the name of an element
				 * in the array part1. */
    int flags;			/* OR-ed combination of TCL_GLOBAL_ONLY,
				 * and TCL_LEAVE_ERR_MSG bits. */
{
    Var *varPtr, *arrayPtr;

    /*
     * We need a special flag check to see if we want to create part 1,
     * because commands like lappend require read traces to trigger for
     * previously non-existent values.
     */
    varPtr = TclLookupVar(interp, part1, part2, flags, "read",
            /*createPart1*/ (flags & TCL_TRACE_READS),
	    /*createPart2*/ 1, &arrayPtr);
    if (varPtr == NULL) {
	return NULL;
    }

    return TclPtrGetVar(interp, varPtr, arrayPtr, part1, part2, flags);
}

d554 3
a556 2
    int flags;			/* OR-ed combination of TCL_GLOBAL_ONLY and
				 * TCL_LEAVE_ERR_MSG bits. */
a557 1
    Var *varPtr, *arrayPtr;
d561 5
a565 1
    part2 = ((part2Ptr == NULL) ? NULL : Tcl_GetString(part2Ptr));
d567 1
a567 13
    /*
     * We need a special flag check to see if we want to create part 1,
     * because commands like lappend require read traces to trigger for
     * previously non-existent values.
     */
    varPtr = TclObjLookupVar(interp, part1Ptr, part2, flags, "read",
            /*createPart1*/ (flags & TCL_TRACE_READS),
	    /*createPart2*/ 1, &arrayPtr);
    if (varPtr == NULL) {
	return NULL;
    }

    return TclPtrGetVar(interp, varPtr, arrayPtr, part1, part2, flags);
d573 1
a573 1
 * TclPtrGetVar --
d575 2
a576 3
 *	Return the value of a Tcl variable as a Tcl object, given the
 *      pointers to the variable's (and possibly containing array's) 
 *      VAR structure.
d580 4
a583 3
 *	given by varPtr. If the specified variable doesn't exist, or if there 
 *      is a clash in array usage, then NULL is returned and a message will be 
 *      left in the interpreter's result if the TCL_LEAVE_ERR_MSG flag is set.
d594 1
a594 1
TclPtrGetVar(interp, varPtr, arrayPtr, part1, part2, flags)
d597 1
a597 4
    register Var *varPtr;       /* The variable to be read.*/
    Var *arrayPtr;              /* NULL for scalar variables, pointer to
				 * the containing array otherwise. */
    CONST char *part1;		/* Name of an array (if part2 is non-NULL)
d599 1
a599 1
    CONST char *part2;		/* If non-NULL, gives the name of an element
d601 1
a601 1
    CONST int flags;		/* OR-ed combination of TCL_GLOBAL_ONLY,
d605 9
a613 1
    CONST char *msg;
d621 6
a626 3
	if (TCL_ERROR == CallVarTraces(iPtr, arrayPtr, varPtr, part1, part2,
		(flags & (TCL_NAMESPACE_ONLY|TCL_GLOBAL_ONLY))
		| TCL_TRACE_READS, (flags & TCL_LEAVE_ERR_MSG))) {
d666 1
a666 1
 * Tcl_SetObjCmd --
d668 3
a670 2
 *	This procedure is invoked to process the "set" Tcl command.
 *	See the user documentation for details on what it does.
d673 5
a677 1
 *	A standard Tcl result value.
d680 3
a682 1
 *	A variable's value may be changed.
d687 9
a695 7
	/* ARGSUSED */
int
Tcl_SetObjCmd(dummy, interp, objc, objv)
    ClientData dummy;			/* Not used. */
    register Tcl_Interp *interp;	/* Current interpreter. */
    int objc;				/* Number of arguments. */
    Tcl_Obj *CONST objv[];		/* Argument objects. */
d697 46
a742 1
    Tcl_Obj *varValueObj;
d744 8
a751 4
    if (objc == 2) {
	varValueObj = Tcl_ObjGetVar2(interp, objv[1], NULL, TCL_LEAVE_ERR_MSG);
	if (varValueObj == NULL) {
	    return TCL_ERROR;
d753 15
a767 3
	Tcl_SetObjResult(interp, varValueObj);
	return TCL_OK;
    } else if (objc == 3) {
a768 4
	varValueObj = Tcl_ObjSetVar2(interp, objv[1], NULL, objv[2],
		TCL_LEAVE_ERR_MSG);
	if (varValueObj == NULL) {
	    return TCL_ERROR;
d770 1
a770 5
	Tcl_SetObjResult(interp, varValueObj);
	return TCL_OK;
    } else {
	Tcl_WrongNumArgs(interp, 1, objv, "varName ?newValue?");
	return TCL_ERROR;
d772 1
d778 1
a778 1
 * Tcl_SetVar --
d780 4
a783 1
 *	Change the value of a variable.
d786 5
a790 7
 *	Returns a pointer to the malloc'ed string which is the character
 *	representation of the variable's new value. The caller must not
 *	modify this string. If the write operation was disallowed then NULL
 *	is returned; if the TCL_LEAVE_ERR_MSG flag is set, then an
 *	explanatory message will be left in the interp's result. Note that the
 *	returned string may not be the same as newValue; this is because
 *	variable traces may modify the variable's value.
d793 3
a795 3
 *	If varName is defined as a local or global variable in interp,
 *	its value is changed to newValue. If varName isn't currently
 *	defined, then a new global variable by that name is created.
d800 3
a802 3
CONST char *
Tcl_SetVar(interp, varName, newValue, flags)
    Tcl_Interp *interp;		/* Command interpreter in which varName is
d804 221
a1024 6
    CONST char *varName;	/* Name of a variable in interp. */
    CONST char *newValue;	/* New value for varName. */
    int flags;			/* Various flags that tell how to set value:
				 * any of TCL_GLOBAL_ONLY,
				 * TCL_NAMESPACE_ONLY, TCL_APPEND_VALUE,
				 * TCL_LIST_ELEMENT, TCL_LEAVE_ERR_MSG. */
d1056 1
a1056 1
CONST char *
d1060 1
a1060 1
    CONST char *part1;          /* If part2 is NULL, this is name of scalar
d1063 1
a1063 1
    CONST char *part2;		/* Name of an element within an array, or
d1065 1
a1065 1
    CONST char *newValue;       /* New value for variable. */
a1093 64
 * Tcl_SetVar2Ex --
 *
 *	Given a two-part variable name, which may refer either to a scalar
 *	variable or an element of an array, change the value of the variable
 *	to a new Tcl object value. If the named scalar or array or element
 *	doesn't exist then create one.
 *
 * Results:
 *	Returns a pointer to the Tcl_Obj holding the new value of the
 *	variable. If the write operation was disallowed because an array was
 *	expected but not found (or vice versa), then NULL is returned; if
 *	the TCL_LEAVE_ERR_MSG flag is set, then an explanatory message will
 *	be left in the interpreter's result. Note that the returned object
 *	may not be the same one referenced by newValuePtr; this is because
 *	variable traces may modify the variable's value.
 *
 * Side effects:
 *	The value of the given variable is set. If either the array or the
 *	entry didn't exist then a new variable is created.
 *
 *	The reference count is decremented for any old value of the variable
 *	and incremented for its new value. If the new value for the variable
 *	is not the same one referenced by newValuePtr (perhaps as a result
 *	of a variable trace), then newValuePtr's ref count is left unchanged
 *	by Tcl_SetVar2Ex. newValuePtr's ref count is also left unchanged if
 *	we are appending it as a string value: that is, if "flags" includes
 *	TCL_APPEND_VALUE but not TCL_LIST_ELEMENT.
 *
 *	The reference count for the returned object is _not_ incremented: if
 *	you want to keep a reference to the object you must increment its
 *	ref count yourself.
 *
 *----------------------------------------------------------------------
 */

Tcl_Obj *
Tcl_SetVar2Ex(interp, part1, part2, newValuePtr, flags)
    Tcl_Interp *interp;		/* Command interpreter in which variable is
				 * to be found. */
    CONST char *part1;		/* Name of an array (if part2 is non-NULL)
				 * or the name of a variable. */
    CONST char *part2;		/* If non-NULL, gives the name of an element
				 * in the array part1. */
    Tcl_Obj *newValuePtr;	/* New value for variable. */
    int flags;			/* Various flags that tell how to set value:
				 * any of TCL_GLOBAL_ONLY,
				 * TCL_NAMESPACE_ONLY, TCL_APPEND_VALUE,
				 * TCL_LIST_ELEMENT or TCL_LEAVE_ERR_MSG. */
{
    Var *varPtr, *arrayPtr;

    varPtr = TclLookupVar(interp, part1, part2, flags, "set",
	    /*createPart1*/ 1, /*createPart2*/ 1, &arrayPtr);
    if (varPtr == NULL) {
	return NULL;
    }

    return TclPtrSetVar(interp, varPtr, arrayPtr, part1, part2, 
            newValuePtr, flags);
}

/*
 *----------------------------------------------------------------------
 *
d1096 1
a1096 1
 *	This function is the same as Tcl_SetVar2Ex above, except the
d1111 1
d1130 2
a1131 1
				 * TCL_LIST_ELEMENT, or TCL_LEAVE_ERR_MSG. */
a1132 1
    Var *varPtr, *arrayPtr;
d1135 5
a1139 7
    part1 = TclGetString(part1Ptr);
    part2 = ((part2Ptr == NULL) ? NULL : Tcl_GetString(part2Ptr));    

    varPtr = TclObjLookupVar(interp, part1Ptr, part2, flags, "set",
	    /*createPart1*/ 1, /*createPart2*/ 1, &arrayPtr);
    if (varPtr == NULL) {
	return NULL;
d1141 2
a1142 3

    return TclPtrSetVar(interp, varPtr, arrayPtr, part1, part2, 
            newValuePtr, flags);
a1144 1

d1148 1
a1148 1
 * TclPtrSetVar --
d1150 4
a1153 3
 *	This function is the same as Tcl_SetVar2Ex above, except that
 *      it requires pointers to the variable's Var structs in addition
 *	to the variable names.
d1167 12
a1178 1

d1184 1
a1184 1
TclPtrSetVar(interp, varPtr, arrayPtr, part1, part2, newValuePtr, flags)
d1186 2
a1187 4
				 * to be looked up. */
    register Var *varPtr;
    Var *arrayPtr;
    CONST char *part1;		/* Name of an array (if part2 is non-NULL)
d1189 1
a1189 1
    CONST char *part2;		/* If non-NULL, gives the name of an element
d1192 4
a1195 2
    CONST int flags;			/* OR-ed combination of TCL_GLOBAL_ONLY,
				 * and TCL_LEAVE_ERR_MSG bits. */
d1198 2
d1202 8
a1209 1
    int result;
d1242 4
a1245 2
     * Invoke any read traces that have been set for the variable if it
     * is requested; this is only done in the core when lappending.
a1247 8
    if ((flags & TCL_TRACE_READS) && ((varPtr->tracePtr != NULL) 
	    || ((arrayPtr != NULL) && (arrayPtr->tracePtr != NULL)))) {
	if (TCL_ERROR == CallVarTraces(iPtr, arrayPtr, varPtr, part1, part2,
		TCL_TRACE_READS, (flags & TCL_LEAVE_ERR_MSG))) {
	    return NULL;
	}
    }

d1284 1
d1286 2
a1287 2
		varPtr->value.objPtr = newValuePtr;
		Tcl_IncrRefCount(newValuePtr);
d1298 9
a1306 5
    } else if (newValuePtr != oldValuePtr) {
	/*
	 * In this case we are replacing the value, so we don't need to
	 * do more than swap the objects.
	 */
d1308 18
a1325 4
	varPtr->value.objPtr = newValuePtr;
	Tcl_IncrRefCount(newValuePtr);      /* var is another ref */
	if (oldValuePtr != NULL) {
	    TclDecrRefCount(oldValuePtr);   /* discard old value */
d1340 6
a1345 3
	if (TCL_ERROR == CallVarTraces(iPtr, arrayPtr, varPtr, part1, part2,
	        (flags & (TCL_GLOBAL_ONLY|TCL_NAMESPACE_ONLY))
		| TCL_TRACE_WRITES, (flags & TCL_LEAVE_ERR_MSG))) {
d1382 397
d1818 7
a1824 2
    Var *varPtr, *arrayPtr;
    char *part1, *part2;
d1826 2
a1827 6
    part1 = TclGetString(part1Ptr);
    part2 = ((part2Ptr == NULL)? NULL : TclGetString(part2Ptr));

    varPtr = TclObjLookupVar(interp, part1Ptr, part2, flags, "read",
	    0, 1, &arrayPtr);
    if (varPtr == NULL) {
d1832 31
a1862 2
    return TclPtrIncrVar(interp, varPtr, arrayPtr, part1, part2,
	    incrAmount, flags);
d1868 1
a1868 1
 * TclPtrIncrVar --
d1870 3
a1872 3
 *	Given the pointers to a variable and possible containing array, 
 *      increment the Tcl object value of the variable by a specified 
 *      amount.
d1876 4
a1879 4
 *	variable. If the specified variable doesn't exist, or there is a
 *	clash in array usage, or an error occurs while executing variable
 *	traces, then NULL is returned and a message will be left in
 *	the interpreter's result.
d1883 3
a1885 4
 *	amount. If either the array or the entry didn't exist then a new
 *	variable is created. The ref count for the returned object is _not_
 *	incremented to reflect the returned reference; if you want to keep a
 *	reference to the object you must increment its ref count yourself.
d1891 1
a1891 1
TclPtrIncrVar(interp, varPtr, arrayPtr, part1, part2, incrAmount, flags)
d1894 3
a1896 13
    Var *varPtr;
    Var *arrayPtr;
    CONST char *part1;		/* Points to an object holding the name of
				 * an array (if part2 is non-NULL) or the
				 * name of a variable. */
    CONST char *part2;		/* If non-null, points to an object holding
				 * the name of an element in the array
				 * part1Ptr. */
    CONST long incrAmount;	/* Amount to be added to variable. */
    CONST int flags;            /* Various flags that tell how to incr value:
				 * any of TCL_GLOBAL_ONLY,
				 * TCL_NAMESPACE_ONLY, TCL_APPEND_VALUE,
				 * TCL_LIST_ELEMENT, TCL_LEAVE_ERR_MSG. */
d1899 1
d1904 1
d1906 2
a1907 2
    varValuePtr = TclPtrGetVar(interp, varPtr, arrayPtr, part1, part2, flags);

d1915 5
a1919 4
     * Increment the variable's value. If the object is unshared we can
     * modify it directly, otherwise we must create a new copy to modify:
     * this is "copy on write". Then free the variable's old string
     * representation, if any, since it will no longer be valid.
d1924 1
a1925 1
	createdNewObj = 1;
d1927 2
a1928 2
#ifdef TCL_WIDE_INT_IS_LONG
    if (Tcl_GetLongFromObj(interp, varValuePtr, &i) != TCL_OK) {
d1935 83
a2017 23
#else
    if (varValuePtr->typePtr == &tclWideIntType) {
	Tcl_WideInt wide = varValuePtr->internalRep.wideValue;
	Tcl_SetWideIntObj(varValuePtr, wide + Tcl_LongAsWide(incrAmount));
    } else if (varValuePtr->typePtr == &tclIntType) {
	i = varValuePtr->internalRep.longValue;
	Tcl_SetIntObj(varValuePtr, i + incrAmount);
    } else {
	/*
	 * Not an integer or wide internal-rep...
	 */
	Tcl_WideInt wide;
	if (Tcl_GetWideIntFromObj(interp, varValuePtr, &wide) != TCL_OK) {
	    if (createdNewObj) {
		Tcl_DecrRefCount(varValuePtr); /* free unneeded copy */
	    }
	    return NULL;
	}
	if (wide <= Tcl_LongAsWide(LONG_MAX)
		&& wide >= Tcl_LongAsWide(LONG_MIN)) {
	    Tcl_SetLongObj(varValuePtr, Tcl_WideAsLong(wide) + incrAmount);
	} else {
	    Tcl_SetWideIntObj(varValuePtr, wide + Tcl_LongAsWide(incrAmount));
d2019 1
d2021 2
a2022 2
#endif

d2027 7
a2033 2
    return TclPtrSetVar(interp, varPtr, arrayPtr, part1, part2,
	    varValuePtr, flags);
d2060 1
a2060 1
    CONST char *varName;	/* Name of a variable in interp.  May be
d2095 2
a2096 45
    CONST char *part1;		/* Name of variable or array. */
    CONST char *part2;		/* Name of element within array or NULL. */
    int flags;			/* OR-ed combination of any of
				 * TCL_GLOBAL_ONLY, TCL_NAMESPACE_ONLY,
				 * TCL_LEAVE_ERR_MSG. */
{
    int result;
    Tcl_Obj *part1Ptr;

    part1Ptr = Tcl_NewStringObj(part1, -1);
    Tcl_IncrRefCount(part1Ptr);
    result = TclObjUnsetVar2(interp, part1Ptr, part2, flags);
    TclDecrRefCount(part1Ptr);

    return result;
}


/*
 *----------------------------------------------------------------------
 *
 * TclObjUnsetVar2 --
 *
 *	Delete a variable, given a 2-object name.
 *
 * Results:
 *	Returns TCL_OK if the variable was successfully deleted, TCL_ERROR
 *	if the variable can't be unset.  In the event of an error,
 *	if the TCL_LEAVE_ERR_MSG flag is set then an error message
 *	is left in the interp's result.
 *
 * Side effects:
 *	If part1ptr and part2Ptr indicate a local or global variable in interp,
 *	it is deleted.  If part1Ptr is an array name and part2Ptr is NULL, then
 *	the whole array is deleted.
 *
 *----------------------------------------------------------------------
 */

int
TclObjUnsetVar2(interp, part1Ptr, part2, flags)
    Tcl_Interp *interp;		/* Command interpreter in which varName is
				 * to be looked up. */
    Tcl_Obj *part1Ptr;		/* Name of variable or array. */
    CONST char *part2;		/* Name of element within array or NULL. */
a2107 1
    char *part1;
d2109 1
a2109 2
    part1 = TclGetString(part1Ptr);
    varPtr = TclObjLookupVar(interp, part1Ptr, part2, flags, "unset",
a2113 1
 
d2144 1
a2144 1
     * 1. We need to increment varPtr's refCount around this: CallVarTraces
d2154 2
a2155 3
	CallVarTraces(iPtr, arrayPtr, &dummyVar, part1, part2,
		(flags & (TCL_GLOBAL_ONLY|TCL_NAMESPACE_ONLY))
		| TCL_TRACE_UNSETS, /* leaveErrMsg */ 0);
d2159 1
a2159 1
	    Tcl_EventuallyFree((ClientData) tracePtr, TCL_DYNAMIC);
d2161 1
a2161 1
	for (activePtr = iPtr->activeVarTracePtr;  activePtr != NULL;
d2193 1
a2193 2
		(flags & (TCL_GLOBAL_ONLY|TCL_NAMESPACE_ONLY)) 
		| TCL_TRACE_UNSETS);
d2259 1
a2259 1
    CONST char *varName;	/* Name of variable;  may end with "(index)"
d2298 2
a2299 2
    CONST char *part1;		/* Name of scalar variable or array. */
    CONST char *part2;		/* Name of element within array;  NULL means
d2312 2
a2313 11
    int flagMask;
    
    /* 
     * We strip 'flags' down to just the parts which are relevant to
     * TclLookupVar, to avoid conflicts between trace flags and
     * internal namespace flags such as 'FIND_ONLY_NS'.  This can
     * now occur since we have trace flags with values 0x1000 and higher.
     */
    flagMask = TCL_GLOBAL_ONLY | TCL_NAMESPACE_ONLY;
    varPtr = TclLookupVar(interp, part1, part2,
	    (flags & flagMask) | TCL_LEAVE_ERR_MSG,
a2319 9
     * Check for a nonsense flag combination.  Note that this is a
     * panic() because there should be no code path that ever sets
     * both flags.
     */
    if ((flags&TCL_TRACE_RESULT_DYNAMIC) && (flags&TCL_TRACE_RESULT_OBJECT)) {
	panic("bad result flag combination");
    }

    /*
a2322 5
    flagMask = TCL_TRACE_READS | TCL_TRACE_WRITES | TCL_TRACE_UNSETS | 
	TCL_TRACE_ARRAY | TCL_TRACE_RESULT_DYNAMIC | TCL_TRACE_RESULT_OBJECT;
#ifndef TCL_REMOVE_OBSOLETE_TRACES
    flagMask |= TCL_TRACE_OLD_STYLE;
#endif
d2324 7
a2330 5
    tracePtr->traceProc		= proc;
    tracePtr->clientData	= clientData;
    tracePtr->flags		= flags & flagMask;
    tracePtr->nextPtr		= varPtr->tracePtr;
    varPtr->tracePtr		= tracePtr;
d2355 1
a2355 1
    CONST char *varName;	/* Name of variable; may end with "(index)"
d2389 2
a2390 2
    CONST char *part1;		/* Name of variable or array. */
    CONST char *part2;		/* Name of element within array;  NULL means
d2406 3
a2408 8
    int flagMask;
    
    /*
     * Set up a mask to mask out the parts of the flags that we are not
     * interested in now.
     */
    flagMask = TCL_GLOBAL_ONLY | TCL_NAMESPACE_ONLY;
    varPtr = TclLookupVar(interp, part1, part2, flags & flagMask,
d2415 2
a2416 11

    /*
     * Set up a mask to mask out the parts of the flags that we are not
     * interested in now.
     */
    flagMask = TCL_TRACE_READS | TCL_TRACE_WRITES | TCL_TRACE_UNSETS |
	TCL_TRACE_ARRAY | TCL_TRACE_RESULT_DYNAMIC | TCL_TRACE_RESULT_OBJECT; 
#ifndef TCL_REMOVE_OBSOLETE_TRACES
    flagMask |= TCL_TRACE_OLD_STYLE;
#endif
    flags &= flagMask;
d2431 1
a2431 1
     * processed by CallVarTraces.
d2434 1
a2434 1
    for (activePtr = iPtr->activeVarTracePtr;  activePtr != NULL;
d2445 1
a2445 1
    Tcl_EventuallyFree((ClientData) tracePtr, TCL_DYNAMIC);
d2486 1
a2486 1
    CONST char *varName;	/* Name of variable;  may end with "(index)"
d2521 2
a2522 2
    CONST char *part1;		/* Name of variable or array. */
    CONST char *part2;		/* Name of element within array;  NULL means
d2592 1
a2592 1
    register int i, flags = TCL_LEAVE_ERR_MSG;
d2595 2
a2596 3
    if (objc < 1) {
	Tcl_WrongNumArgs(interp, 1, objv,
		"?-nocomplain? ?--? ?varName varName ...?");
a2597 6
    } else if (objc == 1) {
	/*
	 * Do nothing if no arguments supplied, so as to match
	 * command documentation.
	 */
	return TCL_OK;
d2599 5
a2603 25

    /*
     * Simple, restrictive argument parsing.  The only options are --
     * and -nocomplain (which must come first and be given exactly to
     * be an option).
     */
    i = 1;
    name = TclGetString(objv[i]);
    if (name[0] == '-') {
 	if (strcmp("-nocomplain", name) == 0) {
	    i++;
 	    if (i == objc) {
		return TCL_OK;
	    }
 	    flags = 0;
 	    name = TclGetString(objv[i]);
 	}
 	if (strcmp("--", name) == 0) {
 	    i++;
 	}
    }

    for (; i < objc;  i++) {
	if ((TclObjUnsetVar2(interp, objv[i], NULL, flags) != TCL_OK)
		&& (flags == TCL_LEAVE_ERR_MSG)) {
a2634 3
    Var *varPtr, *arrayPtr;
    char *part1;

a2643 1

d2650 3
a2652 16
	varPtr = TclObjLookupVar(interp, objv[1], NULL, TCL_LEAVE_ERR_MSG,
		"set", /*createPart1*/ 1, /*createPart2*/ 1, &arrayPtr);
	part1 = TclGetString(objv[1]);
	if (varPtr == NULL) {
	    return TCL_ERROR;
	}
	for (i = 2;  i < objc;  i++) {	  
	    /*
	     * Note that we do not need to increase the refCount of
	     * the Var pointers: should a trace delete the variable,
	     * the return value of TclPtrSetVar will be NULL, and we 
	     * will not access the variable again.
	     */

	    varValuePtr = TclPtrSetVar(interp, varPtr, arrayPtr, part1, NULL, 
	            objv[i], (TCL_APPEND_VALUE | TCL_LEAVE_ERR_MSG));
a2690 2
    Var *varPtr, *arrayPtr;
    char *part1;
d2697 2
a2698 1
	newValuePtr = Tcl_ObjGetVar2(interp, objv[1], (Tcl_Obj *) NULL, 0);
d2705 3
a2707 3
	    varValuePtr = Tcl_NewObj();
	    newValuePtr = Tcl_ObjSetVar2(interp, objv[1], NULL, varValuePtr,
		    TCL_LEAVE_ERR_MSG);
d2709 1
a2709 1
		Tcl_DecrRefCount(varValuePtr); /* free unneeded object */
d2726 1
a2726 27

	/*
	 * Use the TCL_TRACE_READS flag to ensure that if we have an
	 * array with no elements set yet, but with a read trace on it,
	 * we will create the variable and get read traces triggered.
	 * Note that you have to protect the variable pointers around
	 * the TclPtrGetVar call to insure that they remain valid 
	 * even if the variable was undefined and unused.
	 */

	varPtr = TclObjLookupVar(interp, objv[1], NULL, TCL_LEAVE_ERR_MSG,
		"set", /*createPart1*/ 1, /*createPart2*/ 1, &arrayPtr);
	if (varPtr == NULL) {
	    return TCL_ERROR;
	}
	varPtr->refCount++;
	if (arrayPtr != NULL) {
	    arrayPtr->refCount++;
	}
	part1 = TclGetString(objv[1]);
	varValuePtr = TclPtrGetVar(interp, varPtr, arrayPtr, part1, NULL, 
	        (TCL_TRACE_READS | TCL_LEAVE_ERR_MSG));
	varPtr->refCount--;
	if (arrayPtr != NULL) {
	    arrayPtr->refCount--;
	}

d2730 1
a2730 1
	     * exist or it's an array element.  If it's new, we will try to
d2734 13
a2746 1
	    createVar = (TclIsVarUndefined(varPtr));
d2767 1
a2767 1
	listRepPtr = (List *) varValuePtr->internalRep.twoPtrValue.ptr1;
d2813 2
a2814 2
	newValuePtr = TclPtrSetVar(interp, varPtr, arrayPtr, part1, NULL, 
	            varValuePtr, TCL_LEAVE_ERR_MSG);	
d2864 2
a2865 2
	  ARRAY_STARTSEARCH, ARRAY_STATISTICS, ARRAY_UNSET}; 
    static CONST char *arrayOptions[] = {
d2867 1
a2867 1
	"set", "size", "startsearch", "statistics", "unset", (char *) NULL
d2873 1
a2873 1
    Tcl_Obj *resultPtr, *varNamePtr;
d2875 1
a2875 1
    char *varName;
d2890 1
a2890 1
     * Locate the array variable
d2893 2
a2894 3
    varNamePtr = objv[2];
    varName = TclGetString(varNamePtr);
    varPtr = TclObjLookupVar(interp, varNamePtr, NULL, /*flags*/ 0,
d2897 6
d2908 2
a2909 3
    if (varPtr != NULL && varPtr->tracePtr != NULL
	    && (TclIsVarArray(varPtr) || TclIsVarUndefined(varPtr))) {
	if (TCL_ERROR == CallVarTraces(iPtr, arrayPtr, varPtr, varName, NULL,
d2911 3
a2913 1
		TCL_TRACE_ARRAY), /* leaveErrMsg */ 1)) {
a2917 19
    /*
     * Verify that it is indeed an array variable. This test comes after
     * the traces - the variable may actually become an array as an effect 
     * of said traces.
     */

    notArray = 0;
    if ((varPtr == NULL) || !TclIsVarArray(varPtr)
	    || TclIsVarUndefined(varPtr)) {
	notArray = 1;
    }

    /*
     * We have to wait to get the resultPtr until here because
     * CallVarTraces can affect the result.
     */

    resultPtr = Tcl_GetObjResult(interp);

d2921 1
d2931 2
a2932 1
	    searchPtr = ParseSearchId(interp, varPtr, varName, objv[3]);
d2956 1
d2966 2
a2967 1
	    searchPtr = ParseSearchId(interp, varPtr, varName, objv[3]);
d2998 1
a2998 2
	    Tcl_Obj *namePtr, *valuePtr, *nameLstPtr, *tmpResPtr, **namePtrPtr;
	    int i, count;
a3009 8

	    /*
	     * Store the array names in a new object.
	     */

	    nameLstPtr = Tcl_NewObj();
	    Tcl_IncrRefCount(nameLstPtr);

d3022 1
a3022 1
		result = Tcl_ListObjAppendElement(interp, nameLstPtr,
a3025 1
		    Tcl_DecrRefCount(nameLstPtr);
a3027 1
	    }
a3028 20
	    /*
	     * Make sure the Var structure of the array is not removed by
	     * a trace while we're working.
	     */

	    varPtr->refCount++;

	    /*
	     * Get the array values corresponding to each element name 
	     */

	    tmpResPtr = Tcl_NewObj();
	    result = Tcl_ListObjGetElements(interp, nameLstPtr,
		    &count, &namePtrPtr);
	    if (result != TCL_OK) {
		goto errorInArrayGet;
	    }
	    
	    for (i = 0; i < count; i++) { 
		namePtr = *namePtrPtr++;
d3032 2
a3033 17
		    /*
		     * Some trace played a trick on us; we need to diagnose to
		     * adapt our behaviour: was the array element unset, or did
		     * the modification modify the complete array?
		     */

		    if (TclIsVarArray(varPtr) && !TclIsVarUndefined(varPtr)) {
			/*
			 * The array itself looks OK, the variable was
			 * undefined: forget it.
			 */
			
			continue;
		    } else {
			result = TCL_ERROR;
			goto errorInArrayGet;
		    }
d3035 2
a3036 1
		result = Tcl_ListObjAppendElement(interp, tmpResPtr, namePtr);
d3038 2
a3039 5
		    goto errorInArrayGet;
		}
		result = Tcl_ListObjAppendElement(interp, tmpResPtr, valuePtr);
		if (result != TCL_OK) {
		    goto errorInArrayGet;
a3041 3
	    varPtr->refCount--;
	    Tcl_SetObjResult(interp, tmpResPtr);
	    Tcl_DecrRefCount(nameLstPtr);
a3042 6

	    errorInArrayGet:
	    varPtr->refCount--;
	    Tcl_DecrRefCount(nameLstPtr);
	    Tcl_DecrRefCount(tmpResPtr); /* free unneeded temp result obj */
	    return result;
a3049 7
	    int mode, matched = 0;
	    static CONST char *options[] = {
		"-exact", "-glob", "-regexp", (char *) NULL
	    };
	    enum options { OPT_EXACT, OPT_GLOB, OPT_REGEXP };

	    mode = OPT_GLOB;
d3051 2
a3052 3
	    if ((objc < 3) || (objc > 5)) {
  	        Tcl_WrongNumArgs(interp, 2, objv,
			"arrayName ?mode? ?pattern?");
d3060 1
a3060 7
	    } else if (objc == 5) {
		pattern = Tcl_GetString(objv[4]);
		if (Tcl_GetIndexFromObj(interp, objv[3], options, "option",
			0, &mode) != TCL_OK) {
		    return TCL_ERROR;
		}
	    }       		
d3068 2
a3069 19
		if (objc > 3) {
		    switch ((enum options) mode) {
			case OPT_EXACT:
			    matched = (strcmp(name, pattern) == 0);
			    break;
			case OPT_GLOB:
			    matched = Tcl_StringMatch(name, pattern);
			    break;
			case OPT_REGEXP:
			    matched = Tcl_RegExpMatch(interp, name,
				    pattern);
			    if (matched < 0) {
				return TCL_ERROR;
			    }
			    break;
		    }
		    if (matched == 0) {
			continue;
		    }
d3083 1
d3094 2
a3095 1
	    searchPtr = ParseSearchId(interp, varPtr, varName, objv[3]);
d3181 1
a3181 21

	case ARRAY_STATISTICS: {
	    CONST char *stats;

	    if (notArray) {
		goto error;
	    }

	    stats = Tcl_HashStats(varPtr->value.tablePtr);
	    if (stats != NULL) {
		Tcl_SetStringObj(Tcl_GetObjResult(interp), stats, -1);
		ckfree((void *)stats);
	    } else {
		Tcl_SetResult(interp, "error reading array statistics",
			TCL_STATIC);
		return TCL_ERROR;
	    }
	    break;
        }
	
	case ARRAY_UNSET: {
d3198 1
a3198 1
		if (TclObjUnsetVar2(interp, varNamePtr, NULL, 0)
d3213 1
a3213 1
			    (TclObjUnsetVar2(interp, varNamePtr, name, 0)
d3257 1
a3257 1
    int result, elemLen, i, nameLen;
d3260 8
a3267 5
    varName = Tcl_GetStringFromObj(arrayNameObj, &nameLen);
    p = varName + nameLen - 1;
    if (*p == ')') {
	while (--p >= varName) {
	    if (*p == '(') {
d3271 1
d3275 2
a3276 6
    varPtr = TclObjLookupVar(interp, arrayNameObj, NULL,
	    /*flags*/ TCL_LEAVE_ERR_MSG, /*msg*/ "set", /*createPart1*/ 1,
	    /*createPart2*/ 0, &arrayPtr);
    if (varPtr == NULL) {
	return TCL_ERROR;
    }
a3290 6
	    /*
	     * We needn't worry about traces invalidating arrayPtr:
	     * should that be the case, TclPtrSetVar will return NULL
	     * so that we break out of the loop and return an error.
	     */

d3292 2
a3293 6
		char *part2 = TclGetString(elemPtrs[i]);
		Var *elemVarPtr = TclLookupArrayElement(interp, varName, 
                        part2, TCL_LEAVE_ERR_MSG, "set", 1, 1, varPtr);
		if ((elemVarPtr == NULL) ||
		        (TclPtrSetVar(interp, elemVarPtr, varPtr, varName,
			 part2, elemPtrs[i+1], TCL_LEAVE_ERR_MSG) == NULL)) {
d3323 16
d3351 1
a3351 1
 * ObjMakeUpvar --
d3369 3
a3371 3
ObjMakeUpvar(interp, framePtr, otherP1Ptr, otherP2, otherFlags, myName, myFlags, index)
    Tcl_Interp *interp;		/* Interpreter containing variables. Used
			         * for error messages, too. */
d3374 2
a3375 3
    Tcl_Obj *otherP1Ptr;
    CONST char *otherP2;	/* Two-part name of variable in framePtr. */
    CONST int otherFlags;	/* 0, TCL_GLOBAL_ONLY or TCL_NAMESPACE_ONLY:
d3377 1
a3377 1
    CONST char *myName;		/* Name of variable which will refer to
d3379 1
a3379 1
    CONST int myFlags;		/* 0, TCL_GLOBAL_ONLY or TCL_NAMESPACE_ONLY:
a3380 2
    int index;                  /* If the variable to be linked is an indexed
				 * scalar, this is its index. Otherwise, -1. */
d3382 1
a3382 1
    Interp *iPtr = (Interp *) interp;
d3385 5
a3389 1
    CONST char *errMsg;
d3394 1
a3394 1
     * pointer in the interpreter in order to use TclObjLookupVar.
a3396 1
    varFramePtr = iPtr->varFramePtr;
d3398 1
d3401 1
a3401 1
    otherPtr = TclObjLookupVar(interp, otherP1Ptr, otherP2,
d3405 1
a3405 1
	iPtr->varFramePtr = varFramePtr;
d3411 32
a3442 6
    if (index >= 0) {
	if (!varFramePtr->isProcCallFrame) {
	    panic("ObjMakeUpVar called with an index outside from a proc.\n");
	}
	varPtr = &(varFramePtr->compiledLocals[index]);
    } else {
d3449 7
d3457 31
a3487 9
	if (((otherP2 ? arrayPtr->nsPtr : otherPtr->nsPtr) == NULL) 
	    && ((myFlags & (TCL_GLOBAL_ONLY | TCL_NAMESPACE_ONLY))
		|| (varFramePtr == NULL)
		|| !varFramePtr->isProcCallFrame
		|| (strstr(myName, "::") != NULL))) {
	    Tcl_AppendResult((Tcl_Interp *) iPtr, "bad variable name \"",
		    myName, "\": upvar won't create namespace variable that ",
		    "refers to procedure variable", (char *) NULL);
	    return TCL_ERROR;
d3489 16
a3504 10
	
	/*
	 * Lookup and eventually create the new variable.
	 */
	
	varPtr = TclLookupSimpleVar(interp, myName, myFlags, /*create*/ 1, 
				    &errMsg, &index);
	if (varPtr == NULL) {
	    VarErrMsg(interp, myName, NULL, "create", errMsg);
	    return TCL_ERROR;
d3508 1
a3508 11
    if (varPtr == otherPtr) {
	Tcl_SetResult((Tcl_Interp *) iPtr,
		      "can't upvar from variable to itself", TCL_STATIC);
	return TCL_ERROR;
    }

    if (varPtr->tracePtr != NULL) {
	Tcl_AppendResult((Tcl_Interp *) iPtr, "variable \"", myName,
	        "\" has traces: can't use for upvar", (char *) NULL);
	return TCL_ERROR;
    } else if (!TclIsVarUndefined(varPtr)) {
d3510 1
a3510 1
	 * The variable already existed. Make sure this variable "varPtr"
d3516 5
d3530 1
a3530 1
	} else {
d3534 4
d3572 1
a3572 1
    CONST char *frameName;	/* Name of the frame containing the source
d3574 1
a3574 1
    CONST char *varName;	/* Name of a variable in interp to link to.
d3577 1
a3577 1
    CONST char *localName;	/* Name of link variable. */
d3581 37
a3617 1
    return Tcl_UpVar2(interp, frameName, varName, NULL, localName, flags);
d3645 1
a3645 1
    CONST char *frameName;	/* Name of the frame containing the source
d3647 1
a3647 2
    CONST char *part1;
    CONST char *part2;		/* Two parts of source variable name to
d3649 1
a3649 1
    CONST char *localName;	/* Name of link variable. */
a3654 1
    Tcl_Obj *part1Ptr;
d3656 2
a3657 1
    if (TclGetFrame(interp, frameName, &framePtr) == -1) {
d3660 2
a3661 8

    part1Ptr = Tcl_NewStringObj(part1, -1);
    Tcl_IncrRefCount(part1Ptr);
    result = ObjMakeUpvar(interp, framePtr, part1Ptr, part2, 0,
	    localName, flags, -1);
    TclDecrRefCount(part1Ptr);

    return result;
d3782 1
a3782 1
        if ((*tail == ':') && (tail > varName)) {
d3790 3
a3792 3
	result = ObjMakeUpvar(interp, (CallFrame *) NULL,
		objPtr, NULL, /*otherFlags*/ TCL_GLOBAL_ONLY,
	        /*myName*/ tail, /*myFlags*/ 0, -1);
a3846 6
    Tcl_Obj *varNamePtr;

    if (objc < 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "?name value...? name ?value?");
	return TCL_ERROR;
    }
d3854 2
a3855 3
	varNamePtr = objv[i];
	varName = TclGetString(varNamePtr);
	varPtr = TclObjLookupVar(interp, varNamePtr, NULL,
d3892 2
a3893 2
	    varValuePtr = TclPtrSetVar(interp, varPtr, arrayPtr, varName, NULL,
		    objv[i+1], (TCL_NAMESPACE_ONLY | TCL_LEAVE_ERR_MSG));
d3927 2
a3928 2
	    result = ObjMakeUpvar(interp, (CallFrame *) NULL,
		    /*otherP1*/ varNamePtr, /*otherP2*/ NULL,
d3930 1
a3930 1
		    /*myName*/ tail, /*myFlags*/ 0, -1);
d3964 1
d3966 2
a3967 1
    char *frameSpec, *localName;
d4000 28
a4027 3
	localName = TclGetString(objv[1]);
	result = ObjMakeUpvar(interp, framePtr, /* othervarName */ objv[0],
		NULL, 0, /* myVarName */ localName, /*flags*/ 0, -1);
d4038 1
a4038 33
 * DisposeTraceResult--
 *
 *	This procedure is called to dispose of the result returned from
 *	a trace procedure.  The disposal method appropriate to the type
 *	of result is determined by flags.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The memory allocated for the trace result may be freed.
 *
 *----------------------------------------------------------------------
 */

void
DisposeTraceResult(flags, result)
    int flags;			/* Indicates type of result to determine
				 * proper disposal method */
    char *result;		/* The result returned from a trace
				 * procedure to be disposed */
{
    if (flags & TCL_TRACE_RESULT_DYNAMIC) {
	ckfree(result);
    } else if (flags & TCL_TRACE_RESULT_OBJECT) {
	Tcl_DecrRefCount((Tcl_Obj *) result);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * CallVarTraces --
d4046 6
a4051 5
 *      Returns TCL_OK to indicate normal operation.  Returns TCL_ERROR
 *      if invocation of a trace procedure indicated an error.  When
 *      TCL_ERROR is returned and leaveErrMsg is true, then the
 *      ::errorInfo variable of iPtr has information about the error
 *      appended to it.
d4060 2
a4061 2
int 
CallVarTraces(iPtr, arrayPtr, varPtr, part1, part2, flags, leaveErrMsg)
d4068 1
a4068 2
    CONST char *part1;
    CONST char *part2;		/* Variable's two-part name. */
a4073 3
    CONST int leaveErrMsg;	/* If true, and one of the traces indicates an
				 * error, then leave an error message and stack
				 * trace information in *iPTr. */
d4077 1
a4077 2
    char *result;
    CONST char *openParen, *p;
a4079 2
    int code = TCL_OK;
    int disposeFlags = 0;
d4087 1
a4087 1
	return code;
a4090 3
    if (arrayPtr != NULL) {
	arrayPtr->refCount++;
    }
a4110 2
		    int offset = (openParen - part1);
		    char *newPart1;
d4113 4
a4116 4
		    newPart1 = Tcl_DStringValue(&nameCopy);
		    newPart1[offset] = 0;
		    part1 = newPart1;
		    part2 = newPart1 + offset + 1;
d4129 4
a4132 4
    active.nextPtr = iPtr->activeVarTracePtr;
    iPtr->activeVarTracePtr = &active;
    Tcl_Preserve((ClientData) iPtr);
    if (arrayPtr != NULL && !(arrayPtr->flags & VAR_TRACE_ACTIVE)) {
a4139 1
	    Tcl_Preserve((ClientData) tracePtr);
d4144 1
a4144 2
		    /* Ignore errors in unset traces */
		    DisposeTraceResult(tracePtr->flags, result);
d4146 1
a4146 2
	            disposeFlags = tracePtr->flags;
		    code = TCL_ERROR;
a4148 4
	    Tcl_Release((ClientData) tracePtr);
	    if (code == TCL_ERROR) {
		goto done;
	    }
a4165 1
	Tcl_Preserve((ClientData) tracePtr);
d4170 1
a4170 2
		/* Ignore errors in unset traces */
		DisposeTraceResult(tracePtr->flags, result);
d4172 1
a4172 2
		disposeFlags = tracePtr->flags;
		code = TCL_ERROR;
a4174 4
	Tcl_Release((ClientData) tracePtr);
	if (code == TCL_ERROR) {
	    goto done;
	}
a4182 27
    if (code == TCL_ERROR) {
	if (leaveErrMsg) {
	    CONST char *type = "";
	    switch (flags&(TCL_TRACE_READS|TCL_TRACE_WRITES|TCL_TRACE_ARRAY)) {
		case TCL_TRACE_READS: {
		    type = "read";
		    break;
		}
		case TCL_TRACE_WRITES: {
		    type = "set";
		    break;
		}
		case TCL_TRACE_ARRAY: {
		    type = "trace array";
		    break;
		}
	    }
	    if (disposeFlags & TCL_TRACE_RESULT_OBJECT) {
		VarErrMsg((Tcl_Interp *) iPtr, part1, part2, type,
			Tcl_GetString((Tcl_Obj *) result));
	    } else {
		VarErrMsg((Tcl_Interp *) iPtr, part1, part2, type, result);
	    }
	}
	DisposeTraceResult(disposeFlags,result);
    }

d4191 2
a4192 3
    iPtr->activeVarTracePtr = active.nextPtr;
    Tcl_Release((ClientData) iPtr);
    return code;
a4235 66
 * SetArraySearchObj --
 *
 *	This function converts the given tcl object into one that
 *	has the "array search" internal type.
 *
 * Results:
 *	TCL_OK if the conversion succeeded, and TCL_ERROR if it failed
 *	(when an error message will be placed in the interpreter's
 *	result.)
 *
 * Side effects:
 *	Updates the internal type and representation of the object to
 *	make this an array-search object.  See the tclArraySearchType
 *	declaration above for details of the internal representation.
 *
 *----------------------------------------------------------------------
 */

static int
SetArraySearchObj(interp, objPtr)
    Tcl_Interp *interp;
    Tcl_Obj *objPtr;
{
    char *string;
    char *end;
    int id;
    size_t offset;

    /*
     * Get the string representation. Make it up-to-date if necessary.
     */

    string = Tcl_GetString(objPtr);

    /*
     * Parse the id into the three parts separated by dashes.
     */
    if ((string[0] != 's') || (string[1] != '-')) {
	syntax:
	Tcl_AppendResult(interp, "illegal search identifier \"", string,
		"\"", (char *) NULL);
	return TCL_ERROR;
    }
    id = strtoul(string+2, &end, 10);
    if ((end == (string+2)) || (*end != '-')) {
	goto syntax;
    }
    /*
     * Can't perform value check in this context, so place reference
     * to place in string to use for the check in the object instead.
     */
    end++;
    offset = end - string;

    if (objPtr->typePtr != NULL && objPtr->typePtr->freeIntRepProc != NULL) {
	objPtr->typePtr->freeIntRepProc(objPtr);
    }
    objPtr->typePtr = &tclArraySearchType;
    objPtr->internalRep.twoPtrValue.ptr1 = (VOID *)(((char *)NULL)+id);
    objPtr->internalRep.twoPtrValue.ptr2 = (VOID *)(((char *)NULL)+offset);
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
d4238 1
a4238 1
 *	This procedure translates from a tcl object to a pointer to an
d4247 1
a4247 2
 *	The tcl object might have its internal type and representation
 *	modified.
d4253 1
a4253 1
ParseSearchId(interp, varPtr, varName, handleObj)
d4255 2
a4256 2
    CONST Var *varPtr;		/* Array variable search is for. */
    CONST char *varName;	/* Name of array variable that search is
d4258 1
a4258 1
    Tcl_Obj *handleObj;		/* Object containing id of search. Must have
d4263 1
a4263 2
    register char *string;
    register size_t offset;
d4268 1
a4268 1
     * Parse the id.
d4270 5
a4274 1
    if (Tcl_ConvertToType(interp, handleObj, &tclArraySearchType) != TCL_OK) {
d4277 5
a4281 13
    /*
     * Cast is safe, since always came from an int in the first place.
     */
    id = (int)(((char*)handleObj->internalRep.twoPtrValue.ptr1) -
	       ((char*)NULL));
    string = Tcl_GetString(handleObj);
    offset = (((char*)handleObj->internalRep.twoPtrValue.ptr2) -
	      ((char*)NULL));
    /*
     * This test cannot be placed inside the Tcl_Obj machinery, since
     * it is dependent on the variable context.
     */
    if (strcmp(string+offset, varName) != 0) {
a4289 4
     *
     * Note that we cannot store the searchPtr directly in the Tcl_Obj
     * as that would run into trouble when DeleteSearches() was called
     * so we must scan this list every time.
d4377 1
a4377 1
	flags |= TCL_GLOBAL_ONLY;
a4380 3
    if (Tcl_InterpDeleted(interp)) {
	flags |= TCL_INTERP_DESTROYED;
    }
d4414 1
a4414 1
	 * table is deleted). Note that we give CallVarTraces the variable's
d4423 2
a4424 2
	    CallVarTraces(iPtr, (Var *) NULL, varPtr, Tcl_GetString(objPtr),
		    NULL, flags, /* leaveErrMsg */ 0);
d4430 1
a4430 1
		Tcl_EventuallyFree((ClientData) tracePtr, TCL_DYNAMIC);
d4432 1
a4432 1
	    for (activePtr = iPtr->activeVarTracePtr; activePtr != NULL;
d4549 2
a4550 2
	    CallVarTraces(iPtr, (Var *) NULL, varPtr, varPtr->name, NULL,
		    flags, /* leaveErrMsg */ 0);
d4554 1
a4554 1
		Tcl_EventuallyFree((ClientData) tracePtr, TCL_DYNAMIC);
d4556 1
a4556 1
	    for (activePtr = iPtr->activeVarTracePtr; activePtr != NULL;
d4610 1
a4610 1
    CONST char *arrayName;	        /* Name of array (used for trace
d4613 1
a4613 1
    int flags;				/* Flags to pass to CallVarTraces:
d4637 2
a4638 3
	    CallVarTraces(iPtr, (Var *) NULL, elPtr, arrayName,
		    Tcl_GetHashKey(varPtr->value.tablePtr, hPtr), flags,
		    /* leaveErrMsg */ 0);
d4642 1
a4642 1
		Tcl_EventuallyFree((ClientData) tracePtr,TCL_DYNAMIC);
d4644 1
a4644 1
	    for (activePtr = iPtr->activeVarTracePtr; activePtr != NULL;
a4652 13

	/*
	 * Even though array elements are not supposed to be namespace
	 * variables, some combinations of [upvar] and [variable] may
	 * create such beasts - see [Bug 604239]. This is necessary to
	 * avoid leaking the corresponding Var struct, and is otherwise
	 * harmless. 
	 */

	if (elPtr->flags & VAR_NAMESPACE_VAR) {
	    elPtr->flags &= ~VAR_NAMESPACE_VAR;
	    elPtr->refCount--;
	}
d4732 2
a4733 3
    CONST char *part1;
    CONST char *part2;		/* Variable's two-part name. */
    CONST char *operation;      /* String describing operation that failed,
d4735 1
a4735 1
    CONST char *reason;         /* String describing why operation failed. */
d4745 1
d4768 1
a4768 1
    CONST char *varName;	/* The variable name */
d4772 1
d4785 2
a4786 2
            0, "access", /*createPart1*/ 0, /*createPart2*/ 1, &arrayPtr);

d4790 10
d4801 2
a4802 112
    if ((varPtr->tracePtr != NULL)
	    || ((arrayPtr != NULL) && (arrayPtr->tracePtr != NULL))) {
	CallVarTraces((Interp *)interp, arrayPtr, varPtr, varName, NULL,
		TCL_TRACE_READS, /* leaveErrMsg */ 0);
    }

    /*
     * If the variable doesn't exist anymore and no-one's using
     * it, then free up the relevant structures and hash table entries.
     */

    if (TclIsVarUndefined(varPtr)) {
	CleanupVar(varPtr, arrayPtr);
	return NULL;
    }

    return varPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * Internal functions for variable name object types --
 *
 *----------------------------------------------------------------------
 */

/* 
 * localVarName -
 *
 * INTERNALREP DEFINITION:
 *   twoPtrValue.ptr1 = pointer to the corresponding Proc 
 *   twoPtrValue.ptr2 = index into locals table
*/

static void 
FreeLocalVarName(objPtr)
    Tcl_Obj *objPtr;
{
    register Proc *procPtr = (Proc *) objPtr->internalRep.twoPtrValue.ptr1;
    procPtr->refCount--;
    if (procPtr->refCount <= 0) {
	TclProcCleanupProc(procPtr);
    }
}

static void
DupLocalVarName(srcPtr, dupPtr)
    Tcl_Obj *srcPtr;
    Tcl_Obj *dupPtr;
{
    register Proc *procPtr = (Proc *) srcPtr->internalRep.twoPtrValue.ptr1;

    dupPtr->internalRep.twoPtrValue.ptr1 = (VOID *) procPtr;
    dupPtr->internalRep.twoPtrValue.ptr2 = srcPtr->internalRep.twoPtrValue.ptr2;
    procPtr->refCount++;
    dupPtr->typePtr = &tclLocalVarNameType;
}

static void
UpdateLocalVarName(objPtr)
    Tcl_Obj *objPtr;
{
    Proc *procPtr = (Proc *) objPtr->internalRep.twoPtrValue.ptr1;
    unsigned int index = (unsigned int) objPtr->internalRep.twoPtrValue.ptr2;
    CompiledLocal *localPtr = procPtr->firstLocalPtr;
    unsigned int nameLen;

    if (localPtr == NULL) {
	goto emptyName;
    }
    while (index--) {
	localPtr = localPtr->nextPtr;
	if (localPtr == NULL) {
	    goto emptyName;
	}
    }

    nameLen = (unsigned int) localPtr->nameLength;
    objPtr->bytes = ckalloc(nameLen + 1);
    memcpy(objPtr->bytes, localPtr->name, nameLen + 1);
    objPtr->length = nameLen;
    return;

    emptyName:
    objPtr->bytes = ckalloc(1);
    *(objPtr->bytes) = '\0';
    objPtr->length = 0;
}

/* 
 * nsVarName -
 *
 * INTERNALREP DEFINITION:
 *   twoPtrValue.ptr1: pointer to the namespace containing the 
 *                     reference.
 *   twoPtrValue.ptr2: pointer to the corresponding Var 
*/

static void 
FreeNsVarName(objPtr)
    Tcl_Obj *objPtr;
{
    register Var *varPtr = (Var *) objPtr->internalRep.twoPtrValue.ptr2;

    varPtr->refCount--;
    if (TclIsVarUndefined(varPtr) && (varPtr->refCount <= 0)) {
	if (TclIsVarLink(varPtr)) {
	    Var *linkPtr = varPtr->value.linkPtr;
	    linkPtr->refCount--;
	    if (TclIsVarUndefined(linkPtr) && (linkPtr->refCount <= 0)) {
		CleanupVar(linkPtr, (Var *) NULL);
d4804 1
a4805 1
	CleanupVar(varPtr, NULL);
d4807 1
a4807 97
}

static void
DupNsVarName(srcPtr, dupPtr)
    Tcl_Obj *srcPtr;
    Tcl_Obj *dupPtr;
{
    Namespace *nsPtr = (Namespace *) srcPtr->internalRep.twoPtrValue.ptr1;
    register Var *varPtr = (Var *) srcPtr->internalRep.twoPtrValue.ptr2;

    dupPtr->internalRep.twoPtrValue.ptr1 =  (VOID *) nsPtr;
    dupPtr->internalRep.twoPtrValue.ptr2 = (VOID *) varPtr;
    varPtr->refCount++;
    dupPtr->typePtr = &tclNsVarNameType;
}

/* 
 * parsedVarName -
 *
 * INTERNALREP DEFINITION:
 *   twoPtrValue.ptr1 = pointer to the array name Tcl_Obj
 *                      (NULL if scalar)
 *   twoPtrValue.ptr2 = pointer to the element name string
 *                      (owned by this Tcl_Obj), or NULL if 
 *                      it is a scalar variable
 */

static void 
FreeParsedVarName(objPtr)
    Tcl_Obj *objPtr;
{
    register Tcl_Obj *arrayPtr =
	    (Tcl_Obj *) objPtr->internalRep.twoPtrValue.ptr1;
    register char *elem = (char *) objPtr->internalRep.twoPtrValue.ptr2;
    
    if (arrayPtr != NULL) {
	TclDecrRefCount(arrayPtr);
	ckfree(elem);
    }
}

static void
DupParsedVarName(srcPtr, dupPtr)
    Tcl_Obj *srcPtr;
    Tcl_Obj *dupPtr;
{
    register Tcl_Obj *arrayPtr =
	    (Tcl_Obj *) srcPtr->internalRep.twoPtrValue.ptr1;
    register char *elem = (char *) srcPtr->internalRep.twoPtrValue.ptr2;
    char *elemCopy;
    unsigned int elemLen;

    if (arrayPtr != NULL) {
	Tcl_IncrRefCount(arrayPtr);
	elemLen = strlen(elem);
	elemCopy = ckalloc(elemLen+1);
	memcpy(elemCopy, elem, elemLen);
	*(elemCopy + elemLen) = '\0';
	elem = elemCopy;
    }

    dupPtr->internalRep.twoPtrValue.ptr1 = (VOID *) arrayPtr;
    dupPtr->internalRep.twoPtrValue.ptr2 = (VOID *) elem;
    dupPtr->typePtr = &tclParsedVarNameType;
}

static void
UpdateParsedVarName(objPtr)
    Tcl_Obj *objPtr;
{
    Tcl_Obj *arrayPtr = (Tcl_Obj *) objPtr->internalRep.twoPtrValue.ptr1;
    char *part2 = (char *) objPtr->internalRep.twoPtrValue.ptr2;
    char *part1, *p;
    int len1, len2, totalLen;

    if (arrayPtr == NULL) {
	/*
	 * This is a parsed scalar name: what is it
	 * doing here?
	 */
	panic("ERROR: scalar parsedVarName without a string rep.\n");
    }
    part1 = Tcl_GetStringFromObj(arrayPtr, &len1);
    len2 = strlen(part2);
	
    totalLen = len1 + len2 + 2;
    p = ckalloc((unsigned int) totalLen + 1);
    objPtr->bytes = p;
    objPtr->length = totalLen;

    memcpy(p, part1, (unsigned int) len1);
    p += len1;
    *p++ = '(';
    memcpy(p, part2, (unsigned int) len2);
    p += len2;
    *p++ = ')';
    *p   = '\0';
@


1.1
log
@Initial revision
@
text
@d12 1
d17 1
a17 1
 * RCS: @@(#) $Id: tclVar.c,v 1.11 1999/01/26 03:53:19 jingham Exp $
d32 2
a33 1
static char *danglingUpvar =	"upvar refers to element in deleted array";
d36 1
d81 1
a81 3
 *	interp->result if TCL_LEAVE_ERR_MSG is set in flags. (The result
 *	isn't put in interp->objResultPtr because this procedure is used
 *	by so many string-based routines.)
d101 2
a102 3
    char *part1;		/* If part2 isn't NULL, this is the name of
				 * an array. Otherwise, if the
				 * TCL_PARSE_PART1 flag bit is set this
d104 1
a104 3
				 * include a parenthesized array elemnt. If
				 * TCL_PARSE_PART1 isn't present, then
				 * this is the name of a scalar variable. */
d107 1
a107 2
				 * TCL_LEAVE_ERR_MSG, and
				 * TCL_PARSE_PART1 bits matter. */
d153 7
a159 2
     * If the name hasn't been parsed into array name and index yet,
     * do it now.
d163 9
a171 17
    if (flags & TCL_PARSE_PART1) {
	for (p = part1; ; p++) {
	    if (*p == 0) {
		elName = NULL;
		break;
	    }
	    if (*p == '(') {
		openParen = p;
		do {
		    p++;
		} while (*p != '\0');
		p--;
		if (*p == ')') {
		    closeParen = p;
		    *openParen = 0;
		    elName = openParen+1;
		} else {
d173 4
a176 1
		    elName = NULL;
d178 5
a182 1
		break;
d184 1
d196 1
a196 2
    }
    else {
d205 1
a205 1
                (Tcl_Namespace *) cxtNsPtr, flags, &var);
d213 1
a213 1
                    (Tcl_Namespace *) cxtNsPtr, flags, &var);
d221 1
a221 2
        }
        else if (result != TCL_CONTINUE) {
d244 3
a246 3
	        || (varFramePtr == NULL)
	        || !varFramePtr->isProcCallFrame
	        || (strstr(part1, "::") != NULL)) {
d249 4
d254 1
a254 1
	        flags);
a258 3
	    if (flags & TCL_LEAVE_ERR_MSG) {
		Tcl_ResetResult(interp);
	    }
d260 3
a262 18
		result = TclGetNamespaceForQualName(interp, part1,
		        (Namespace *) NULL, flags, &varNsPtr, &dummy1Ptr,
			&dummy2Ptr, &tail);
		if (result != TCL_OK) {
		    if (flags & TCL_LEAVE_ERR_MSG) {
			/*
			 * Move the interpreter's object result to the
			 * string result, then reset the object result.
			 * FAILS IF OBJECT RESULT'S STRING REP HAS NULLS.
			 */
			
			Tcl_SetResult(interp,
	                        TclGetStringFromObj(Tcl_GetObjResult(interp),
				    (int *) NULL),
	                        TCL_VOLATILE);
		    }
		    goto done;
		}
d296 1
a296 1
		char *localName = localVarPtr->name;
d312 1
a312 1
			    ckalloc(sizeof(Tcl_HashTable));
d341 1
a341 1
lookupVarPart2:
d378 13
d394 1
a394 1
	        (Tcl_HashTable *) ckalloc(sizeof(Tcl_HashTable));
d455 1
a455 1
 *	is left in interp->result if the TCL_LEAVE_ERR_MSG flag is set.
d475 1
a475 2
    return Tcl_GetVar2(interp, varName, (char *) NULL,
		       (flags | TCL_PARSE_PART1));
d490 1
a490 1
 *	and a message will be left in interp->result if the
d510 2
a511 2
				 * TCL_NAMESPACE_ONLY, TCL_LEAVE_ERR_MSG,
                                 * and TCL_PARSE_PART1 bits. */
a512 2
    register Tcl_Obj *part1Ptr;
    register Tcl_Obj *part2Ptr = NULL;
a513 6
    int length;

    length = strlen(part1);
    TclNewObj(part1Ptr);
    TclInitStringRep(part1Ptr, part1, length);
    Tcl_IncrRefCount(part1Ptr);
d515 1
a515 14
    if (part2 != NULL) {
        length = strlen(part2);
        TclNewObj(part2Ptr);
        TclInitStringRep(part2Ptr, part2, length);
	Tcl_IncrRefCount(part2Ptr);
    }
    
    objPtr = Tcl_ObjGetVar2(interp, part1Ptr, part2Ptr, flags);
    
    TclDecrRefCount(part1Ptr);	    /* done with the part1 name object */
    if (part2Ptr != NULL) {
	TclDecrRefCount(part2Ptr);  /* and the part2 name object */
    }
    
a516 9
	/*
	 * Move the interpreter's object result to the string result, 
	 * then reset the object result.
	 * FAILS IF OBJECT RESULT'S STRING REPRESENTATION CONTAINS NULLS.
	 */

	Tcl_SetResult(interp,
	        TclGetStringFromObj(Tcl_GetObjResult(interp), (int *) NULL),
	        TCL_VOLATILE);
d519 1
a519 6

    /*
     * THIS FAILS IF Tcl_ObjGetVar2's RESULT'S STRING REP HAS A NULL BYTE.
     */
    
    return TclGetStringFromObj(objPtr, (int *) NULL);
a520 1

d558 46
d607 1
a607 6
    char *part1, *msg;
    char *part2 = NULL;

    /*
     * THIS FAILS IF A NAME OBJECT'S STRING REP HAS A NULL BYTE.
     */
a608 4
    part1 = TclGetStringFromObj(part1Ptr, (int *) NULL);
    if (part2Ptr != NULL) {
	part2 = TclGetStringFromObj(part2Ptr, (int *) NULL);
    }
d622 1
a622 1
		(flags & (TCL_NAMESPACE_ONLY|TCL_GLOBAL_ONLY|TCL_PARSE_PART1)) | TCL_TRACE_READS);
d691 1
a691 1
    int localIndex;		/* Index of variable in procedure's array
d704 1
a704 1
    Var *varPtr;		/* Points to the variable's in-frame Var
d710 1
a710 2
    Proc *procPtr = varFramePtr->procPtr;
    int localCt = procPtr->numCompiledLocals;
d714 1
a714 1
		    localIndex, (unsigned int) varFramePtr);
d716 1
a716 1
	      (unsigned int) varFramePtr);
d720 1
a720 1
		    localIndex, (unsigned int) varFramePtr, localCt);
d722 1
a722 1
	      localIndex, (unsigned int) varFramePtr);
d746 1
a746 1
	        TCL_TRACE_READS);
d768 1
d835 1
a835 1
		    localIndex, (unsigned int) varFramePtr);
d837 1
a837 1
	      (unsigned int) varFramePtr);
d841 1
a841 1
		    localIndex, (unsigned int) varFramePtr, localCt);
d843 1
a843 1
	      localIndex, (unsigned int) varFramePtr);
d847 1
a847 5
    /*
     * THIS FAILS IF THE ELEMENT NAME OBJECT'S STRING REP HAS A NULL BYTE.
     */
    
    elem = Tcl_GetStringFromObj(elemPtr, (int *) NULL);
d945 1
a945 1
 * Tcl_SetCmd --
d961 1
a961 1
Tcl_SetCmd(dummy, interp, argc, argv)
d964 2
a965 2
    int argc;				/* Number of arguments. */
    char **argv;			/* Argument strings. */
d967 1
a967 2
    if (argc == 2) {
	char *value;
d969 3
a971 3
	value = Tcl_GetVar2(interp, argv[1], (char *) NULL,
		TCL_LEAVE_ERR_MSG|TCL_PARSE_PART1);
	if (value == NULL) {
d974 1
a974 1
	Tcl_SetResult(interp, value, TCL_VOLATILE);
d976 1
a976 2
    } else if (argc == 3) {
	char *result;
d978 3
a980 3
	result = Tcl_SetVar2(interp, argv[1], (char *) NULL, argv[2],
		TCL_LEAVE_ERR_MSG|TCL_PARSE_PART1);
	if (result == NULL) {
d983 1
a983 1
	Tcl_SetResult(interp, result, TCL_VOLATILE);
d986 1
a986 2
	Tcl_AppendResult(interp, "wrong # args: should be \"",
		argv[0], " varName ?newValue?\"", (char *) NULL);
d1003 1
a1003 1
 *	explanatory message will be left in interp->result. Note that the
d1026 1
a1026 2
    return Tcl_SetVar2(interp, varName, (char *) NULL, newValue,
		       (flags | TCL_PARSE_PART1));
d1045 1
a1045 1
 *	message will be left in interp->result. Note that the returned
d1069 1
a1069 2
				 * TCL_LIST_ELEMENT, TCL_LEAVE_ERR_MSG, or 
				 * TCL_PARSE_PART1. */
a1071 2
    register Tcl_Obj *part1Ptr;
    register Tcl_Obj *part2Ptr = NULL;
a1072 1
    int length;
d1076 1
a1076 1
     * Tcl_ObjSetVar2 to actually set the variable.
d1079 1
a1079 3
    length = newValue ? strlen(newValue) : 0;
    TclNewObj(valuePtr);
    TclInitStringRep(valuePtr, newValue, length);
d1082 1
a1082 19
    length = strlen(part1) ;
    TclNewObj(part1Ptr);
    TclInitStringRep(part1Ptr, part1, length);
    Tcl_IncrRefCount(part1Ptr);

    if (part2 != NULL) {
        length = strlen(part2);
        TclNewObj(part2Ptr);
        TclInitStringRep(part2Ptr, part2, length);
	Tcl_IncrRefCount(part2Ptr);
    }
    
    varValuePtr = Tcl_ObjSetVar2(interp, part1Ptr, part2Ptr, valuePtr,
	    flags);
    
    TclDecrRefCount(part1Ptr);      /* done with the part1 name object */
    if (part2Ptr != NULL) {
	TclDecrRefCount(part2Ptr);  /* and the part2 name object */
    }
a1085 9
	/*
	 * Move the interpreter's object result to the string result, 
	 * then reset the object result.
	 * FAILS IF OBJECT RESULT'S STRING REPRESENTATION CONTAINS NULLS.
	 */

	Tcl_SetResult(interp,
	        TclGetStringFromObj(Tcl_GetObjResult(interp), (int *) NULL),
	        TCL_VOLATILE);
d1088 23
d1112 22
a1133 3
    /*
     * THIS FAILS IF Tcl_ObjSetVar2's RESULT'S STRING REP HAS A NULL BYTE.
     */
d1135 8
a1142 1
    return TclGetStringFromObj(varValuePtr, (int *) NULL);
d1148 1
a1148 1
 * Tcl_ObjSetVar2 --
d1172 1
a1172 1
 *	by Tcl_ObjSetVar2. newValuePtr's ref count is also left unchanged if
d1184 1
a1184 1
Tcl_ObjSetVar2(interp, part1Ptr, part2Ptr, newValuePtr, flags)
d1187 4
a1190 6
    register Tcl_Obj *part1Ptr;	/* Points to an object holding the name of
				 * an array (if part2 is non-NULL) or the
				 * name of a variable. */
    register Tcl_Obj *part2Ptr;	/* If non-null, points to an object holding
				 * the name of an element in the array
				 * part1Ptr. */
d1195 1
a1195 2
				 * TCL_LIST_ELEMENT, TCL_LEAVE_ERR_MSG, or
				 * TCL_PARSE_PART1. */
d1202 1
a1202 2
    char *part1, *bytes;
    char *part2 = NULL;
a1204 9
    /*
     * THIS FAILS IF A NAME OBJECT'S STRING REP HAS A NULL BYTE.
     */

    part1 = TclGetStringFromObj(part1Ptr, (int *) NULL);
    if (part2Ptr != NULL) {
	part2 = TclGetStringFromObj(part2Ptr, (int *) NULL);
    }
    
d1213 4
a1216 4
     * have an upvar to an array element where the array was deleted,
     * leaving the element dangling at the end of the upvar. Generate an
     * error (allowing the variable to be reset would screw up our storage
     * allocation and is meaningless anyway).
d1221 5
a1225 1
	    VarErrMsg(interp, part1, part2, "set", danglingUpvar);
d1267 1
a1267 1
		Tcl_IncrRefCount(oldValuePtr); /* since var is reference */
d1272 1
a1272 1
		Tcl_IncrRefCount(oldValuePtr); /* since var is reference */
d1295 1
a1295 1
		Tcl_AppendToObj(oldValuePtr, bytes, length);
d1315 1
a1315 1
		    ckalloc((unsigned) (neededBytes + 1));
d1341 1
a1341 1
	        (flags & (TCL_GLOBAL_ONLY|TCL_NAMESPACE_ONLY|TCL_PARSE_PART1)) | TCL_TRACE_WRITES);
d1442 1
a1442 1
		    localIndex, (unsigned int) varFramePtr);
d1444 1
a1444 1
	      (unsigned int) varFramePtr);
d1448 1
a1448 1
		    localIndex, (unsigned int) varFramePtr, localCt);
d1450 1
a1450 1
	      localIndex, (unsigned int) varFramePtr);
d1470 4
a1473 4
     * have an upvar to an array element where the array was deleted,
     * leaving the element dangling at the end of the upvar. Generate an
     * error (allowing the variable to be reset would screw up our storage
     * allocation and is meaningless anyway).
d1478 5
a1482 1
	    VarErrMsg(interp, varName, NULL, "set", danglingUpvar);
d1627 1
a1627 1
		    localIndex, (unsigned int) varFramePtr);
d1629 1
a1629 1
	      (unsigned int) varFramePtr);
d1633 1
a1633 1
		    localIndex, (unsigned int) varFramePtr, localCt);
d1635 1
a1635 1
	      localIndex, (unsigned int) varFramePtr);
d1639 1
a1639 5
    /*
     * THIS FAILS IF THE ELEMENT NAME OBJECT'S STRING REP HAS A NULL BYTE.
     */
    
    elem = Tcl_GetStringFromObj(elemPtr, (int *) NULL);
d1655 19
d1680 1
a1680 1
	        (Tcl_HashTable *) ckalloc(sizeof(Tcl_HashTable));
d1803 1
a1803 1
TclIncrVar2(interp, part1Ptr, part2Ptr, incrAmount, part1NotParsed)
d1813 4
a1816 2
    int part1NotParsed;		/* 1 if part1 hasn't yet been parsed into
				 * an array name and index (if any). */
d1824 1
a1824 1
    int flags, result;
a1825 5
    flags = TCL_LEAVE_ERR_MSG;
    if (part1NotParsed) {
	flags |= TCL_PARSE_PART1;
    }
    
d1858 1
a1858 2
    resultPtr = Tcl_ObjSetVar2(interp, part1Ptr, part2Ptr, varValuePtr,
	    flags);
d1907 1
a1907 1
                                      /*leaveErrorMsg*/ 1);
d1941 1
a1941 1
				    /*leaveErrorMsg*/ 1);
d1994 1
a1994 1
				              /*leaveErrorMsg*/ 1);
d2028 2
a2029 2
					    varValuePtr,
                                            /*leaveErrorMsg*/ 1);
d2047 1
a2047 1
 *	is left in interp->result.
d2067 1
a2067 2
    return Tcl_UnsetVar2(interp, varName, (char *) NULL,
	    (flags | TCL_PARSE_PART1));
d2081 1
a2081 1
 *	is left in interp->result.
d2099 1
a2099 2
				 * TCL_LEAVE_ERR_MSG, or
				 * TCL_PARSE_PART1. */
d2155 1
a2155 1
		(flags & (TCL_GLOBAL_ONLY|TCL_NAMESPACE_ONLY|TCL_PARSE_PART1)) | TCL_TRACE_UNSETS);
d2162 1
a2162 1
		activePtr = activePtr->nextPtr) {
d2179 13
d2193 3
a2195 1
	    (flags & (TCL_GLOBAL_ONLY|TCL_NAMESPACE_ONLY)) | TCL_TRACE_UNSETS);
d2205 1
a2205 3
     * If the variable was a namespace variable, decrement its reference
     * count. We are in the process of destroying its namespace so that
     * namespace will no longer "refer" to the variable.
d2269 2
a2270 2
    return Tcl_TraceVar2(interp, varName, (char *) NULL,
	    (flags | TCL_PARSE_PART1), proc, clientData);
d2305 1
a2305 2
				 * TCL_NAMESPACE_ONLY and
				 * TCL_PARSE_PART1. */
d2327 2
a2328 1
	    flags & (TCL_TRACE_READS | TCL_TRACE_WRITES | TCL_TRACE_UNSETS);
d2365 1
a2365 2
    Tcl_UntraceVar2(interp, varName, (char *) NULL,
		    (flags | TCL_PARSE_PART1), proc, clientData);
d2397 1
a2397 2
				 * TCL_NAMESPACE_ONLY and
				 * TCL_PARSE_PART1. */
d2408 1
a2408 1
	    flags & (TCL_GLOBAL_ONLY|TCL_NAMESPACE_ONLY|TCL_PARSE_PART1),
d2415 2
a2416 1
    flags &= (TCL_TRACE_READS | TCL_TRACE_WRITES | TCL_TRACE_UNSETS);
d2418 1
a2418 1
	    prevPtr = tracePtr, tracePtr = tracePtr->nextPtr) {
d2435 1
a2435 1
	    activePtr = activePtr->nextPtr) {
d2488 2
a2489 2
    int flags;			/* 0, TCL_GLOBAL_ONLY, or
				 * TCL_NAMESPACE_ONLY. */
d2498 1
a2498 1
	    (flags | TCL_PARSE_PART1), proc, prevClientData);
d2526 1
a2526 2
				 * TCL_NAMESPACE_ONLY, and
				 * TCL_PARSE_PART1. */
d2538 1
a2538 1
	    flags & (TCL_GLOBAL_ONLY|TCL_NAMESPACE_ONLY|TCL_PARSE_PART1),
d2601 1
a2601 5
	/*
	 * THIS FAILS IF A NAME OBJECT'S STRING REP HAS A NULL BYTE.
	 */

	name = Tcl_GetStringFromObj(objv[i], (int *) NULL);
d2603 1
a2603 1
	        (TCL_LEAVE_ERR_MSG | TCL_PARSE_PART1)) != TCL_OK) {
a2643 1

d2645 1
a2645 2
	varValuePtr = Tcl_ObjGetVar2(interp, objv[1], (Tcl_Obj *) NULL,
	        (TCL_LEAVE_ERR_MSG | TCL_PARSE_PART1));
d2652 1
a2652 2
		objv[i],
		(TCL_APPEND_VALUE | TCL_LEAVE_ERR_MSG | TCL_PARSE_PART1));
a2657 1
    
a2695 1
    
d2698 1
a2698 1
	    (TCL_LEAVE_ERR_MSG | TCL_PARSE_PART1));
d2707 1
a2707 1
		    nullObjPtr, (TCL_LEAVE_ERR_MSG | TCL_PARSE_PART1));
d2715 1
a2715 1
	 * We have arguments to append. We used to call Tcl_ObjSetVar2 to
d2726 1
a2726 2
	varValuePtr = Tcl_ObjGetVar2(interp, objv[1], (Tcl_Obj *) NULL,
	        TCL_PARSE_PART1);
d2734 1
a2734 1
	    char *name, *p;
d2737 2
a2738 2
	    name = TclGetStringFromObj(objv[1], &nameBytes);
	    for (i = 0, p = name;  i < nameBytes;  i++, p++) {
d2740 1
a2740 1
		    p = (name + nameBytes-1);	
d2780 1
a2780 1
		    ckalloc((unsigned) (newMax * sizeof(Tcl_Obj *)));
d2813 2
a2814 2
	newValuePtr = Tcl_ObjSetVar2(interp, objv[1], (Tcl_Obj *) NULL,
		varValuePtr, (TCL_LEAVE_ERR_MSG | TCL_PARSE_PART1));
d2864 5
a2868 4
	  ARRAY_STARTSEARCH}; 
    static char *arrayOptions[] = {"anymore", "donesearch", "exists",
	    "get", "names", "nextelement", "set", "size", "startsearch", 
            (char *) NULL};
d2870 1
d2875 1
a2875 1
    char *varName;
d2884 2
a2885 2
    if (Tcl_GetIndexFromObj(interp, objv[1], arrayOptions, "option", 0, &index)
	    != TCL_OK) {
a2890 1
     * THIS FAILS IF A NAME OBJECT'S STRING REP HAS A NULL BYTE.
d2893 1
a2893 1
    varName = TclGetStringFromObj(objv[2], (int *) NULL);
d2902 16
a2917 1
    
d2931 1
a2931 1
	    searchId = Tcl_GetStringFromObj(objv[3], (int *) NULL);
d2966 1
a2966 1
	    searchId = Tcl_GetStringFromObj(objv[3], (int *) NULL);
d2975 1
a2975 1
		        prevPtr = prevPtr->nextPtr) {
d3008 1
a3008 1
	        pattern = Tcl_GetStringFromObj(objv[3], (int *) NULL);
d3011 1
a3011 1
		    hPtr != NULL;  hPtr = Tcl_NextHashEntry(&search)) {
d3059 1
a3059 1
	        pattern = Tcl_GetStringFromObj(objv[3], (int *) NULL);
d3062 1
a3062 1
		    hPtr != NULL; hPtr = Tcl_NextHashEntry(&search)) {
d3075 1
a3075 1
		    Tcl_DecrRefCount(namePtr); /* free unneeded name object */
d3094 1
a3094 1
	    searchId = Tcl_GetStringFromObj(objv[3], (int *) NULL);
a3120 3
	    Tcl_Obj **elemPtrs;
	    int listLen, i, result;
	    
d3125 1
a3125 60
	    result = Tcl_ListObjGetElements(interp, objv[3], &listLen, 
                    &elemPtrs);
	    if (result != TCL_OK) {
	        return result;
	    }
	    if (listLen & 1) {
	        Tcl_ResetResult(interp);
		Tcl_AppendToObj(Tcl_GetObjResult(interp),
                        "list must have an even number of elements", -1);
		return TCL_ERROR;
	    }
	    if (listLen > 0) {
		for (i = 0;  i < listLen;  i += 2) {
		    if (Tcl_ObjSetVar2(interp, objv[2], elemPtrs[i],
			    elemPtrs[i+1], TCL_LEAVE_ERR_MSG) == NULL) {
			result = TCL_ERROR;
			break;
		    }
		}
		return result;
	    }
  
	    /*
	     * The list is empty make sure we have an array, or create
	     * one if necessary.
	     */
	    
	    if (varPtr != NULL) {
		if (!TclIsVarUndefined(varPtr) && TclIsVarArray(varPtr)) {
		    /*
		     * Already an array, done.
		     */
		    
		    return TCL_OK;
                }
		if (TclIsVarArrayElement(varPtr) ||
			!TclIsVarUndefined(varPtr)) {
		    /*
		     * Either an array element, or a scalar: lose!
		     */
		    
		    VarErrMsg(interp, varName, (char *)NULL, "array set",
                            needArray);
		    return TCL_ERROR;
                }
	    } else {
		/*
		 * Create variable for new array.
		 */
		
		varPtr = TclLookupVar(interp, varName, (char *) NULL, 0, 0,
			/*createPart1*/ 1, /*createPart2*/ 0,
			&arrayPtr);
	    }
	    TclSetVarArray(varPtr);
	    TclClearVarUndefined(varPtr);
	    varPtr->value.tablePtr =
		(Tcl_HashTable *) ckalloc(sizeof(Tcl_HashTable));
	    Tcl_InitHashTable(varPtr->value.tablePtr, TCL_STRING_KEYS);
          return TCL_OK;
d3140 1
a3140 1
		        hPtr != NULL;  hPtr = Tcl_NextHashEntry(&search)) {
d3167 1
a3167 1
	        char string[20];
d3172 1
a3172 1
		    (char *) NULL);
d3181 40
d3233 118
d3389 1
a3389 1
    int new, result;
d3428 6
a3433 9
	        || (varFramePtr == NULL)
	        || !varFramePtr->isProcCallFrame
	        || (strstr(myName, "::") != NULL)) {
	result = TclGetNamespaceForQualName((Tcl_Interp *) iPtr, myName,
                (Namespace *) NULL, (myFlags | TCL_LEAVE_ERR_MSG),
                &nsPtr, &altNsPtr, &dummyNsPtr, &tail);
        if (result != TCL_OK) {
	    return result;
        }
d3439 1
a3439 1
                myName, "\": unknown namespace", (char *) NULL);
d3532 1
a3532 1
		"\" already exists", (char *) NULL);
d3536 1
a3536 1
		"\" has traces: can't use for upvar", (char *) NULL);
d3557 1
a3557 1
 *	an error message is left in interp->result.
d3630 1
a3630 1
 *	an error message is left in interp->result.
d3769 1
a3769 1
	varName = Tcl_GetStringFromObj(objPtr, (int *) NULL);
d3843 1
a3843 1
    char *varName, *tail;
d3854 1
a3854 1
	varName = Tcl_GetStringFromObj(objv[i], (int *) NULL);
d3858 10
d3892 2
a3893 2
	    varValuePtr = Tcl_ObjSetVar2(interp, objv[i], (Tcl_Obj *) NULL,
		    objv[i+1], (TCL_NAMESPACE_ONLY | TCL_LEAVE_ERR_MSG));
d3909 3
d3914 6
a3919 9
	    for (tail = varName;  *tail != '\0';  tail++) {
		/* empty body */
	    }
	    while ((tail > varName)
		    && ((*tail != ':') || (*(tail-1) != ':'))) {
		tail--;
	    }
	    if (*tail == ':') {
		tail++;
d3979 1
a3979 1
     * linked to. FAILS IF objv[1]'s STRING REP CONTAINS NULLS.
d3982 1
a3982 1
    frameSpec = Tcl_GetStringFromObj(objv[1], (int *) NULL);
d4000 2
a4001 2
	myVarName = Tcl_GetStringFromObj(objv[1], (int *) NULL);
	otherVarName = Tcl_GetStringFromObj(objv[0], (int *) NULL);
d4073 1
a4073 3
				 * TCL_INTERP_DESTROYED. May also contain
				 * TCL_PARSE_PART1, which should not be
				 * passed through to callbacks. */
d4102 2
a4103 5
    if (flags & TCL_PARSE_PART1) {
	for (p = part1; ; p++) {
	    if (*p == 0) {
		break;
	    }
d4114 1
a4114 1
			    + (openParen + 1 - part1);
a4122 1
    flags &= ~TCL_PARSE_PART1;
d4135 1
a4135 1
		tracePtr = active.nextTracePtr) {
d4161 1
a4161 1
	    tracePtr = active.nextTracePtr) {
d4244 1
a4244 1
 *	interp->result contains an error message.
d4293 1
a4293 1
	    searchPtr = searchPtr->nextPtr) {
d4383 1
a4383 1
	    hPtr = Tcl_NextHashEntry(&search)) {
d4424 1
a4424 2
		    Tcl_GetStringFromObj(objPtr, (int *) NULL),
		    (char *) NULL, flags);
d4433 1
a4433 1
		    activePtr = activePtr->nextPtr) {
d4557 1
a4557 1
		    activePtr = activePtr->nextPtr) {
d4627 1
a4627 1
	    hPtr != NULL;  hPtr = Tcl_NextHashEntry(&search)) {
d4645 1
a4645 1
		    activePtr = activePtr->nextPtr) {
d4722 1
a4722 1
 *      Interp->result is reset to hold a message identifying the
d4739 1
a4739 1
		     (char *) NULL);
d4744 64
@


1.1.1.1
log
@import dejagnu-1999-11-08 snapshot
@
text
@@


1.1.1.2
log
@Tcl 8.3 upgrade
@
text
@a11 1
 * Copyright (c) 1998-1999 by Scriptics Corporation.
d16 1
a16 1
 * RCS: @@(#) $Id: tclVar.c,v 1.7.8.1 2000/04/06 22:38:30 spolk Exp $
d31 1
a31 2
static char *danglingElement =  "upvar refers to element in deleted array";
static char *danglingVar =     "upvar refers to variable in deleted namespace";
a33 1
static char *isArrayElement =   "name refers to an element in an array";
d78 3
a80 1
 *	the interp's result if TCL_LEAVE_ERR_MSG is set in flags. 
d100 3
a102 2
    register char *part1;	/* If part2 isn't NULL, this is the name of
				 * an array. Otherwise, this
d104 3
a106 1
				 * include a parenthesized array element. */
d109 2
a110 1
				 * and TCL_LEAVE_ERR_MSG bits matter. */
d156 2
a157 7
     * Parse part1 into array name and index.
     * Always check if part1 is an array element name and allow it only if
     * part2 is not given.   
     * (if one does not care about creating array elements that can't be used
     *  from tcl, and prefer slightly better performance, one can put
     *  the following in an   if (part2 == NULL) { ... } block and remove
     *  the part2's test and error reporting  or move that code in array set)
d161 17
a177 9
    for (p = part1; *p ; p++) {
	if (*p == '(') {
	    openParen = p;
	    do {
		p++;
	    } while (*p != '\0');
	    p--;
	    if (*p == ')') {
		if (part2 != NULL) {
d179 1
a179 4
		    if (flags & TCL_LEAVE_ERR_MSG) {
			VarErrMsg(interp, part1, part2, msg, needArray);
		    }
		    goto done;
d181 1
a181 5
		closeParen = p;
		*openParen = 0;
		elName = openParen+1;
	    } else {
		openParen = NULL;
a182 1
	    break;
d194 2
a195 1
    } else {
d204 1
a204 1
		    (Tcl_Namespace *) cxtNsPtr, flags, &var);
d212 1
a212 1
			(Tcl_Namespace *) cxtNsPtr, flags, &var);
d220 2
a221 1
        } else if (result != TCL_CONTINUE) {
d244 3
a246 3
	    || (varFramePtr == NULL)
	    || !varFramePtr->isProcCallFrame
	    || (strstr(part1, "::") != NULL)) {
a248 4
	/*
	 * Don't pass TCL_LEAVE_ERR_MSG, we may yet create the variable,
	 * or otherwise generate our own error!
	 */
d250 1
a250 1
		flags & ~TCL_LEAVE_ERR_MSG);
d255 3
d259 18
a276 3
		TclGetNamespaceForQualName(interp, part1, (Namespace *) NULL,
			flags, &varNsPtr, &dummy1Ptr, &dummy2Ptr, &tail);

d310 1
a310 1
		register char *localName = localVarPtr->name;
d326 1
a326 1
			ckalloc(sizeof(Tcl_HashTable));
d355 1
a355 1
    lookupVarPart2:
a391 13

	/*
	 * Make sure we are not resurrecting a namespace variable from a
	 * deleted namespace!
	 */
	if ((varPtr->flags & VAR_IN_HASHTABLE) && (varPtr->hPtr == NULL)) {
	    if (flags & TCL_LEAVE_ERR_MSG) {
		VarErrMsg(interp, part1, part2, msg, danglingVar);
	    }
	    varPtr = NULL;
	    goto done;
	}

d395 1
a395 1
	    (Tcl_HashTable *) ckalloc(sizeof(Tcl_HashTable));
d456 1
a456 1
 *	is left in the interp's result if the TCL_LEAVE_ERR_MSG flag is set.
d476 2
a477 1
    return Tcl_GetVar2(interp, varName, (char *) NULL, flags);
d492 1
a492 1
 *	and a message will be left in the interp's result if the
d512 2
a513 2
				 * TCL_NAMESPACE_ONLY and TCL_LEAVE_ERR_MSG
                                 * bits. */
d515 2
d518 6
d525 14
a538 1
    objPtr = Tcl_GetVar2Ex(interp, part1, part2, flags);
d540 9
d551 6
a556 1
    return TclGetString(objPtr);
d558 1
a595 46
    char *part1, *part2;

    part1 = Tcl_GetString(part1Ptr);
    if (part2Ptr != NULL) {
	part2 = Tcl_GetString(part2Ptr);
    } else {
	part2 = NULL;
    }
    
    return Tcl_GetVar2Ex(interp, part1, part2, flags);
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetVar2Ex --
 *
 *	Return the value of a Tcl variable as a Tcl object, given a
 *	two-part name consisting of array name and element within array.
 *
 * Results:
 *	The return value points to the current object value of the variable
 *	given by part1Ptr and part2Ptr. If the specified variable doesn't
 *	exist, or if there is a clash in array usage, then NULL is returned
 *	and a message will be left in the interpreter's result if the
 *	TCL_LEAVE_ERR_MSG flag is set.
 *
 * Side effects:
 *	The ref count for the returned object is _not_ incremented to
 *	reflect the returned reference; if you want to keep a reference to
 *	the object you must increment its ref count yourself.
 *
 *----------------------------------------------------------------------
 */

Tcl_Obj *
Tcl_GetVar2Ex(interp, part1, part2, flags)
    Tcl_Interp *interp;		/* Command interpreter in which variable is
				 * to be looked up. */
    char *part1;		/* Name of an array (if part2 is non-NULL)
				 * or the name of a variable. */
    char *part2;		/* If non-NULL, gives the name of an element
				 * in the array part1. */
    int flags;			/* OR-ed combination of TCL_GLOBAL_ONLY,
				 * and TCL_LEAVE_ERR_MSG bits. */
{
d599 6
a604 1
    char *msg;
d606 4
d623 1
a623 1
		(flags & (TCL_NAMESPACE_ONLY|TCL_GLOBAL_ONLY)) | TCL_TRACE_READS);
d692 1
a692 1
    register int localIndex;	/* Index of variable in procedure's array
d705 1
a705 1
    register Var *varPtr;	/* Points to the variable's in-frame Var
d711 2
a712 1
    int localCt = varFramePtr->procPtr->numCompiledLocals;
d716 1
a716 1
		localIndex, (unsigned int) varFramePtr);
d718 1
a718 1
		(unsigned int) varFramePtr);
d722 1
a722 1
		localIndex, (unsigned int) varFramePtr, localCt);
d724 1
a724 1
		localIndex, (unsigned int) varFramePtr);
d748 1
a748 1
		TCL_TRACE_READS);
a769 1

d836 1
a836 1
		localIndex, (unsigned int) varFramePtr);
d838 1
a838 1
		(unsigned int) varFramePtr);
d842 1
a842 1
		localIndex, (unsigned int) varFramePtr, localCt);
d844 1
a844 1
		localIndex, (unsigned int) varFramePtr);
d848 5
a852 1
    elem = TclGetString(elemPtr);
d950 1
a950 1
 * Tcl_SetObjCmd --
d966 1
a966 1
Tcl_SetObjCmd(dummy, interp, objc, objv)
d969 2
a970 2
    int objc;				/* Number of arguments. */
    Tcl_Obj *CONST objv[];		/* Argument objects. */
d972 2
a973 1
    Tcl_Obj *varValueObj;
d975 3
a977 3
    if (objc == 2) {
	varValueObj = Tcl_ObjGetVar2(interp, objv[1], NULL, TCL_LEAVE_ERR_MSG);
	if (varValueObj == NULL) {
d980 1
a980 1
	Tcl_SetObjResult(interp, varValueObj);
d982 2
a983 1
    } else if (objc == 3) {
d985 3
a987 3
	varValueObj = Tcl_ObjSetVar2(interp, objv[1], NULL, objv[2],
		TCL_LEAVE_ERR_MSG);
	if (varValueObj == NULL) {
d990 1
a990 1
	Tcl_SetObjResult(interp, varValueObj);
d993 2
a994 1
	Tcl_WrongNumArgs(interp, 1, objv, "varName ?newValue?");
d1011 1
a1011 1
 *	explanatory message will be left in the interp's result. Note that the
d1034 2
a1035 1
    return Tcl_SetVar2(interp, varName, (char *) NULL, newValue, flags);
d1054 1
a1054 1
 *	message will be left in the interp's result. Note that the returned
d1078 2
a1079 1
				 * TCL_LIST_ELEMENT, or TCL_LEAVE_ERR_MSG */
d1082 2
d1085 1
d1089 1
a1089 1
     * Tcl_SetVar2Ex to actually set the variable.
d1092 3
a1094 1
    valuePtr = Tcl_NewStringObj(newValue, -1);
d1097 19
a1115 1
    varValuePtr = Tcl_SetVar2Ex(interp, part1, part2, valuePtr, flags);
d1119 9
a1129 23
    return TclGetString(varValuePtr);
}

/*
 *----------------------------------------------------------------------
 *
 * Tcl_ObjSetVar2 --
 *
 *	This function is the same as Tcl_SetVar2Ex below, except the
 *	variable names are passed in Tcl object instead of strings.
 *
 * Results:
 *	Returns a pointer to the Tcl_Obj holding the new value of the
 *	variable. If the write operation was disallowed because an array was
 *	expected but not found (or vice versa), then NULL is returned; if
 *	the TCL_LEAVE_ERR_MSG flag is set, then an explanatory message will
 *	be left in the interpreter's result. Note that the returned object
 *	may not be the same one referenced by newValuePtr; this is because
 *	variable traces may modify the variable's value.
 *
 * Side effects:
 *	The value of the given variable is set. If either the array or the
 *	entry didn't exist then a new variable is created.
d1131 3
a1133 22
 *
 *----------------------------------------------------------------------
 */

Tcl_Obj *
Tcl_ObjSetVar2(interp, part1Ptr, part2Ptr, newValuePtr, flags)
    Tcl_Interp *interp;		/* Command interpreter in which variable is
				 * to be found. */
    register Tcl_Obj *part1Ptr;	/* Points to an object holding the name of
				 * an array (if part2 is non-NULL) or the
				 * name of a variable. */
    register Tcl_Obj *part2Ptr;	/* If non-null, points to an object holding
				 * the name of an element in the array
				 * part1Ptr. */
    Tcl_Obj *newValuePtr;	/* New value for variable. */
    int flags;			/* Various flags that tell how to set value:
				 * any of TCL_GLOBAL_ONLY,
				 * TCL_NAMESPACE_ONLY, TCL_APPEND_VALUE,
				 * TCL_LIST_ELEMENT, TCL_LEAVE_ERR_MSG, or
				 * TCL_PARSE_PART1. */
{
    char *part1, *part2;
d1135 1
a1135 8
    part1 = Tcl_GetString(part1Ptr);
    if (part2Ptr != NULL) {
	part2 = Tcl_GetString(part2Ptr);
    } else {
	part2 = NULL;
    }
    
    return Tcl_SetVar2Ex(interp, part1, part2, newValuePtr, flags);
d1141 1
a1141 1
 * Tcl_SetVar2Ex --
d1165 1
a1165 1
 *	by Tcl_SetVar2Ex. newValuePtr's ref count is also left unchanged if
d1177 1
a1177 1
Tcl_SetVar2Ex(interp, part1, part2, newValuePtr, flags)
d1180 6
a1185 4
    char *part1;		/* Name of an array (if part2 is non-NULL)
				 * or the name of a variable. */
    char *part2;		/* If non-NULL, gives the name of an element
				 * in the array part1. */
d1190 2
a1191 1
				 * TCL_LIST_ELEMENT or TCL_LEAVE_ERR_MSG. */
d1198 2
a1199 1
    char *bytes;
d1202 9
d1219 4
a1222 4
     * may have an upvar to an array element where the array was deleted
     * or an upvar to a namespace variable whose namespace was deleted.
     * Generate an error (allowing the variable to be reset would screw up
     * our storage allocation and is meaningless anyway).
d1227 1
a1227 5
	    if (TclIsVarArrayElement(varPtr)) {
		VarErrMsg(interp, part1, part2, "set", danglingElement);
	    } else {
		VarErrMsg(interp, part1, part2, "set", danglingVar);
	    }
d1269 1
a1269 1
		Tcl_IncrRefCount(oldValuePtr); /* since var is referenced */
d1274 1
a1274 1
		Tcl_IncrRefCount(oldValuePtr); /* since var is referenced */
d1297 1
a1297 1
		Tcl_AppendObjToObj(oldValuePtr, newValuePtr);
d1317 1
a1317 1
		ckalloc((unsigned) (neededBytes + 1));
d1343 1
a1343 1
	        (flags & (TCL_GLOBAL_ONLY|TCL_NAMESPACE_ONLY)) | TCL_TRACE_WRITES);
d1444 1
a1444 1
		localIndex, (unsigned int) varFramePtr);
d1446 1
a1446 1
		(unsigned int) varFramePtr);
d1450 1
a1450 1
		localIndex, (unsigned int) varFramePtr, localCt);
d1452 1
a1452 1
		localIndex, (unsigned int) varFramePtr);
d1472 4
a1475 4
     * may have an upvar to an array element where the array was deleted
     * or an upvar to a namespace variable whose namespace was deleted.
     * Generate an error (allowing the variable to be reset would screw up
     * our storage allocation and is meaningless anyway).
d1480 1
a1480 5
	    if (TclIsVarArrayElement(varPtr)) {
		VarErrMsg(interp, varName, NULL, "set", danglingElement);
	    } else {
		VarErrMsg(interp, varName, NULL, "set", danglingVar);
	    }
d1625 1
a1625 1
		localIndex, (unsigned int) varFramePtr);
d1627 1
a1627 1
		(unsigned int) varFramePtr);
d1631 1
a1631 1
		localIndex, (unsigned int) varFramePtr, localCt);
d1633 1
a1633 1
		localIndex, (unsigned int) varFramePtr);
d1637 5
a1641 1
    elem = TclGetString(elemPtr);
a1656 19
     * If the variable is in a hashtable and its hPtr field is NULL, then we
     * may have an upvar to an array element where the array was deleted
     * or an upvar to a namespace variable whose namespace was deleted.
     * Generate an error (allowing the variable to be reset would screw up
     * our storage allocation and is meaningless anyway).
     */

    if ((arrayPtr->flags & VAR_IN_HASHTABLE) && (arrayPtr->hPtr == NULL)) {
	if (leaveErrorMsg) {
	    if (TclIsVarArrayElement(arrayPtr)) {
		VarErrMsg(interp, arrayName, elem, "set", danglingElement);
	    } else {
		VarErrMsg(interp, arrayName, elem, "set", danglingVar);
	    }
	}
	goto errorReturn;
    }

    /*
d1663 1
a1663 1
	    (Tcl_HashTable *) ckalloc(sizeof(Tcl_HashTable));
d1786 1
a1786 1
TclIncrVar2(interp, part1Ptr, part2Ptr, incrAmount, flags)
d1796 2
a1797 4
    int flags;                  /* Various flags that tell how to incr value:
				 * any of TCL_GLOBAL_ONLY,
				 * TCL_NAMESPACE_ONLY, TCL_APPEND_VALUE,
				 * TCL_LIST_ELEMENT, TCL_LEAVE_ERR_MSG. */
d1805 1
a1805 1
    int result;
d1807 5
d1844 2
a1845 1
    resultPtr = Tcl_ObjSetVar2(interp, part1Ptr, part2Ptr, varValuePtr, flags);
d1894 1
a1894 1
	    /*leaveErrorMsg*/ 1);
d1928 1
a1928 1
	    /*leaveErrorMsg*/ 1);
d1981 1
a1981 1
	    /*leaveErrorMsg*/ 1);
d2015 2
a2016 2
	    varValuePtr,
	    /*leaveErrorMsg*/ 1);
d2034 1
a2034 1
 *	is left in the interp's result.
d2054 2
a2055 1
    return Tcl_UnsetVar2(interp, varName, (char *) NULL, flags);
d2069 1
a2069 1
 *	is left in the interp's result.
d2087 2
a2088 1
				 * TCL_LEAVE_ERR_MSG. */
d2144 1
a2144 1
		(flags & (TCL_GLOBAL_ONLY|TCL_NAMESPACE_ONLY)) | TCL_TRACE_UNSETS);
d2151 1
a2151 1
	     activePtr = activePtr->nextPtr) {
a2167 13
	/*
	 * Deleting the elements of the array may cause traces to be fired
	 * on those elements.  Before deleting them, bump the reference count
	 * of the array, so that if those trace procs make a global or upvar
	 * link to the array, the array is not deleted when the call stack
	 * gets popped (we will delete the array ourselves later in this
	 * function).
	 *
	 * Bumping the count can lead to the odd situation that elements of the
	 * array are being deleted when the array still exists, but since the
	 * array is about to be removed anyway, that shouldn't really matter.
	 */
	varPtr->refCount++;
d2169 1
a2169 3
		(flags & (TCL_GLOBAL_ONLY|TCL_NAMESPACE_ONLY)) | TCL_TRACE_UNSETS);
	/* Decr ref count */
	varPtr->refCount--;
d2179 3
a2181 1
     * If the variable was a namespace variable, decrement its reference count.
d2245 2
a2246 2
    return Tcl_TraceVar2(interp, varName, (char *) NULL, 
	    flags, proc, clientData);
d2281 2
a2282 1
				 * and TCL_NAMESPACE_ONLY. */
d2304 1
a2304 2
	flags & (TCL_TRACE_READS | TCL_TRACE_WRITES | TCL_TRACE_UNSETS | 
		TCL_TRACE_ARRAY);
d2341 2
a2342 1
    Tcl_UntraceVar2(interp, varName, (char *) NULL, flags, proc, clientData);
d2374 2
a2375 1
				 * and TCL_NAMESPACE_ONLY. */
d2386 1
a2386 1
	    flags & (TCL_GLOBAL_ONLY|TCL_NAMESPACE_ONLY),
d2393 1
a2393 2
    flags &= (TCL_TRACE_READS | TCL_TRACE_WRITES | TCL_TRACE_UNSETS |
	    TCL_TRACE_ARRAY);
d2395 1
a2395 1
	 prevPtr = tracePtr, tracePtr = tracePtr->nextPtr) {
d2412 1
a2412 1
	 activePtr = activePtr->nextPtr) {
d2465 2
a2466 2
    int flags;			/* OR-ed combo or TCL_GLOBAL_ONLY,
				 * TCL_NAMESPACE_ONLY (can be 0). */
d2475 1
a2475 1
	    flags, proc, prevClientData);
d2503 2
a2504 1
				 * TCL_NAMESPACE_ONLY. */
d2516 1
a2516 1
	    flags & (TCL_GLOBAL_ONLY|TCL_NAMESPACE_ONLY),
d2579 5
a2583 1
	name = TclGetString(objv[i]);
d2585 1
a2585 1
		TCL_LEAVE_ERR_MSG) != TCL_OK) {
d2626 1
d2628 2
a2629 1
	varValuePtr = Tcl_ObjGetVar2(interp, objv[1], NULL, TCL_LEAVE_ERR_MSG);
d2636 2
a2637 1
		    objv[i], (TCL_APPEND_VALUE | TCL_LEAVE_ERR_MSG));
d2643 1
d2682 1
d2685 1
a2685 1
		(TCL_LEAVE_ERR_MSG));
d2694 1
a2694 1
		    nullObjPtr, TCL_LEAVE_ERR_MSG);
d2702 1
a2702 1
	 * We have arguments to append. We used to call Tcl_SetVar2 to
d2713 2
a2714 1
	varValuePtr = Tcl_ObjGetVar2(interp, objv[1], NULL, 0);
d2722 1
a2722 1
	    char *p, *varName;
d2725 2
a2726 2
	    varName = Tcl_GetStringFromObj(objv[1], &nameBytes);
	    for (i = 0, p = varName;  i < nameBytes;  i++, p++) {
d2728 1
a2728 1
		    p = (varName + nameBytes-1);	
d2768 1
a2768 1
		ckalloc((unsigned) (newMax * sizeof(Tcl_Obj *)));
d2801 2
a2802 2
	newValuePtr = Tcl_ObjSetVar2(interp, objv[1], NULL, varValuePtr,
		TCL_LEAVE_ERR_MSG);
d2852 4
a2855 5
	  ARRAY_STARTSEARCH, ARRAY_UNSET}; 
    static char *arrayOptions[] = {
	"anymore", "donesearch", "exists", "get", "names", "nextelement",
	"set", "size", "startsearch", "unset", (char *) NULL
    };
a2856 1
    Interp *iPtr = (Interp *) interp;
d2861 1
a2861 1
    char *varName, *msg;
d2870 2
a2871 2
    if (Tcl_GetIndexFromObj(interp, objv[1], arrayOptions, "option",
	    0, &index) != TCL_OK) {
d2877 1
d2880 1
a2880 1
    varName = TclGetString(objv[2]);
d2889 1
a2889 16

    /*
     * Special array trace used to keep the env array in sync for
     * array names, array get, etc.
     */

    if (varPtr != NULL && varPtr->tracePtr != NULL) {
	msg = CallTraces(iPtr, arrayPtr, varPtr, varName, NULL,
		(TCL_LEAVE_ERR_MSG|TCL_NAMESPACE_ONLY|TCL_GLOBAL_ONLY|
		TCL_TRACE_ARRAY));
	if (msg != NULL) {
	    VarErrMsg(interp, varName, NULL, "trace array", msg);
	    return TCL_ERROR;
	}
    }

d2903 1
a2903 1
	    searchId = Tcl_GetString(objv[3]);
d2938 1
a2938 1
	    searchId = Tcl_GetString(objv[3]);
d2947 1
a2947 1
		     prevPtr = prevPtr->nextPtr) {
d2980 1
a2980 1
	        pattern = TclGetString(objv[3]);
d2983 1
a2983 1
		 hPtr != NULL;  hPtr = Tcl_NextHashEntry(&search)) {
d3031 1
a3031 1
	        pattern = Tcl_GetString(objv[3]);
d3034 1
a3034 1
		 hPtr != NULL; hPtr = Tcl_NextHashEntry(&search)) {
d3047 1
a3047 1
		    Tcl_DecrRefCount(namePtr); /* free unneeded name obj */
d3066 1
a3066 1
	    searchId = Tcl_GetString(objv[3]);
d3093 3
d3100 60
a3159 1
	    return(TclArraySet(interp, objv[2], objv[3]));
d3174 1
a3174 1
		     hPtr != NULL;  hPtr = Tcl_NextHashEntry(&search)) {
d3201 1
a3201 1
	        char string[TCL_INTEGER_SPACE];
d3206 1
a3206 1
			(char *) NULL);
a3214 40
        case ARRAY_UNSET: {
	    Tcl_HashSearch search;
	    Var *varPtr2;
	    char *pattern = NULL;
	    char *name;
          
	    if ((objc != 3) && (objc != 4)) {
		Tcl_WrongNumArgs(interp, 2, objv, "arrayName ?pattern?");
		return TCL_ERROR;
	    }
	    if (notArray) {
		return TCL_OK;
	    }
	    if (objc == 3) {
		/*
		 * When no pattern is given, just unset the whole array
		 */
		if (Tcl_UnsetVar2(interp, varName, (char *) NULL, 0)
			!= TCL_OK) {
		    return TCL_ERROR;
		}
	    } else {
		pattern = Tcl_GetString(objv[3]);
		for (hPtr = Tcl_FirstHashEntry(varPtr->value.tablePtr,
			&search);
		     hPtr != NULL; hPtr = Tcl_NextHashEntry(&search)) {
		    varPtr2 = (Var *) Tcl_GetHashValue(hPtr);
		    if (TclIsVarUndefined(varPtr2)) {
			continue;
		    }
		    name = Tcl_GetHashKey(varPtr->value.tablePtr, hPtr);
		    if (Tcl_StringMatch(name, pattern) &&
			    (Tcl_UnsetVar2(interp, varName, name, 0)
				    != TCL_OK)) {
			return TCL_ERROR;
		    }
		}
	    }
	    break;
	}
a3226 118
 * TclArraySet --
 *
 *	Set the elements of an array.  If there are no elements to
 *	set, create an empty array.  This routine is used by the
 *	Tcl_ArrayObjCmd and by the TclSetupEnv routine.
 *
 * Results:
 *	A standard Tcl result object.
 *
 * Side effects:
 *	A variable will be created if one does not already exist.
 *
 *----------------------------------------------------------------------
 */

int
TclArraySet(interp, arrayNameObj, arrayElemObj)
    Tcl_Interp *interp;		/* Current interpreter. */
    Tcl_Obj *arrayNameObj;	/* The array name. */
    Tcl_Obj *arrayElemObj;	/* The array elements list.  If this is
				 * NULL, create an empty array. */
{
    Var *varPtr, *arrayPtr;
    Tcl_Obj **elemPtrs;
    int result, elemLen, i;
    char *varName, *p;
    
    varName = TclGetString(arrayNameObj);
    for (p = varName; *p ; p++) {
	if (*p == '(') {
	    do {
		p++;
	    } while (*p != '\0');
	    p--;
	    if (*p == ')') {
		VarErrMsg(interp, varName, NULL, "set", needArray);
		return TCL_ERROR;
	    }
	    break;
	}
    }

    varPtr = TclLookupVar(interp, varName, (char *) NULL, /*flags*/ 0,
            /*msg*/ 0, /*createPart1*/ 0, /*createPart2*/ 0, &arrayPtr);

    if (arrayElemObj != NULL) {
	result = Tcl_ListObjGetElements(interp, arrayElemObj,
		&elemLen, &elemPtrs);
	if (result != TCL_OK) {
	    return result;
	}
	if (elemLen & 1) {
	    Tcl_ResetResult(interp);
	    Tcl_AppendToObj(Tcl_GetObjResult(interp),
		    "list must have an even number of elements", -1);
	    return TCL_ERROR;
	}
	if (elemLen > 0) {
	    for (i = 0;  i < elemLen;  i += 2) {
		if (Tcl_ObjSetVar2(interp, arrayNameObj, elemPtrs[i],
			elemPtrs[i+1], TCL_LEAVE_ERR_MSG) == NULL) {
		    result = TCL_ERROR;
		    break;
		}
	    }
	    return result;
	}
    }
    
    /*
     * The list is empty make sure we have an array, or create
     * one if necessary.
     */
    
    if (varPtr != NULL) {
	if (!TclIsVarUndefined(varPtr) && TclIsVarArray(varPtr)) {
	    /*
	     * Already an array, done.
	     */
	    
	    return TCL_OK;
	}
	if (TclIsVarArrayElement(varPtr) || !TclIsVarUndefined(varPtr)) {
	    /*
	     * Either an array element, or a scalar: lose!
	     */
	    
	    VarErrMsg(interp, varName, (char *)NULL, "array set", needArray);
	    return TCL_ERROR;
	}
    } else {
	/*
	 * Create variable for new array.
	 */
	
	varPtr = TclLookupVar(interp, varName, (char *) NULL,
		TCL_LEAVE_ERR_MSG, "set",
	        /*createPart1*/ 1, /*createPart2*/ 0, &arrayPtr);

	/*
	 * Still couldn't do it - this can occur if a non-existent
	 * namespace was specified
	 */
	if (varPtr == NULL) {
	    return TCL_ERROR;
	}
    }
    TclSetVarArray(varPtr);
    TclClearVarUndefined(varPtr);
    varPtr->value.tablePtr =
	(Tcl_HashTable *) ckalloc(sizeof(Tcl_HashTable));
    Tcl_InitHashTable(varPtr->value.tablePtr, TCL_STRING_KEYS);
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
d3265 1
a3265 1
    int new;
d3304 9
a3312 6
	    || (varFramePtr == NULL)
	    || !varFramePtr->isProcCallFrame
	    || (strstr(myName, "::") != NULL)) {
	TclGetNamespaceForQualName((Tcl_Interp *) iPtr, myName,
		(Namespace *) NULL, myFlags, &nsPtr, &altNsPtr, &dummyNsPtr, &tail);

d3318 1
a3318 1
		    myName, "\": unknown namespace", (char *) NULL);
d3411 1
a3411 1
		    "\" already exists", (char *) NULL);
d3415 1
a3415 1
		    "\" has traces: can't use for upvar", (char *) NULL);
d3436 1
a3436 1
 *	an error message is left in the interp's result.
d3509 1
a3509 1
 *	an error message is left in the interp's result.
d3648 1
a3648 1
	varName = TclGetString(objPtr);
d3722 1
a3722 1
    char *varName, *tail, *cp;
d3733 1
a3733 1
	varName = TclGetString(objv[i]);
a3736 10
	
        if (arrayPtr != NULL) {
            /*
             * Variable cannot be an element in an array.  If arrayPtr is
             * non-null, it is, so throw up an error and return.
             */
            VarErrMsg(interp, varName, NULL, "define", isArrayElement);
            return TCL_ERROR;
        }

d3761 2
a3762 2
	    varValuePtr = Tcl_ObjSetVar2(interp, objv[i], NULL, objv[i+1],
		    (TCL_NAMESPACE_ONLY | TCL_LEAVE_ERR_MSG));
a3777 3
	     *
	     * Locate tail in one pass: drop any prefix after two *or more*
	     * consecutive ":" characters).
d3780 9
a3788 6
	    for (tail = cp = varName;  *cp != '\0'; ) {
		if (*cp++ == ':') {
		    while (*cp == ':') {
			tail = ++cp;
		    }
		}
d3848 1
a3848 1
     * linked to. 
d3851 1
a3851 1
    frameSpec = TclGetString(objv[1]);
d3869 2
a3870 2
	myVarName = TclGetString(objv[1]);
	otherVarName = TclGetString(objv[0]);
d3942 3
a3944 1
				 * TCL_INTERP_DESTROYED. */
d3973 5
a3977 2
    if (part2 == NULL) {
	for (p = part1; *p ; p++) {
d3988 1
a3988 1
			+ (openParen + 1 - part1);
d3997 1
d4010 1
a4010 1
	     tracePtr = active.nextTracePtr) {
d4036 1
a4036 1
	 tracePtr = active.nextTracePtr) {
d4119 1
a4119 1
 *	the interp's result contains an error message.
d4168 1
a4168 1
	 searchPtr = searchPtr->nextPtr) {
d4258 1
a4258 1
	 hPtr = Tcl_NextHashEntry(&search)) {
d4299 2
a4300 1
		    Tcl_GetString(objPtr), (char *) NULL, flags);
d4309 1
a4309 1
		 activePtr = activePtr->nextPtr) {
d4433 1
a4433 1
		 activePtr = activePtr->nextPtr) {
d4503 1
a4503 1
	 hPtr != NULL;  hPtr = Tcl_NextHashEntry(&search)) {
d4521 1
a4521 1
		 activePtr = activePtr->nextPtr) {
d4598 1
a4598 1
 *      The interp's result is set to hold a message identifying the
d4615 1
a4615 1
	    (char *) NULL);
a4619 64
}


/*
 *----------------------------------------------------------------------
 *
 * TclTraceVarExists --
 *
 *	This is called from info exists.  We need to trigger read
 *	and/or array traces because they may end up creating a
 *	variable that doesn't currently exist.
 *
 * Results:
 *	A pointer to the Var structure, or NULL.
 *
 * Side effects:
 *	May fill in error messages in the interp.
 *
 *----------------------------------------------------------------------
 */

Var *
TclVarTraceExists(interp, varName)
    Tcl_Interp *interp;		/* The interpreter */
    char *varName;		/* The variable name */
{
    Var *varPtr;
    Var *arrayPtr;
    char *msg;

    /*
     * The choice of "create" flag values is delicate here, and
     * matches the semantics of GetVar.  Things are still not perfect,
     * however, because if you do "info exists x" you get a varPtr
     * and therefore trigger traces.  However, if you do 
     * "info exists x(i)", then you only get a varPtr if x is already
     * known to be an array.  Otherwise you get NULL, and no trace
     * is triggered.  This matches Tcl 7.6 semantics.
     */

    varPtr = TclLookupVar(interp, varName, (char *) NULL,
            0, "access",
            /*createPart1*/ 0, /*createPart2*/ 1, &arrayPtr);
    if (varPtr == NULL) {
	return NULL;
    }
    if ((varPtr != NULL) &&
	    ((varPtr->tracePtr != NULL)
	    || ((arrayPtr != NULL) && (arrayPtr->tracePtr != NULL)))) {
	msg = CallTraces((Interp *)interp, arrayPtr, varPtr, varName,
		(char *) NULL, TCL_TRACE_READS);
	if (msg != NULL) {
	    /*
	     * If the variable doesn't exist anymore and no-one's using
	     * it, then free up the relevant structures and hash table entries.
	     */

	    if (TclIsVarUndefined(varPtr)) {
		CleanupVar(varPtr, arrayPtr);
	    }
	    return NULL;
	}
    }
    return varPtr;
@


1.1.1.3
log
@import tcl 8.4.0
@
text
@a12 1
 * Copyright (c) 2001 by Kevin B. Kenny.  All rights reserved.
d17 1
a17 1
 * RCS: @@(#) $Id: tclVar.c,v 1.67 2002/09/05 20:21:06 dgp Exp $
d28 9
a36 11
static CONST char *noSuchVar =		"no such variable";
static CONST char *isArray =		"variable is array";
static CONST char *needArray =		"variable isn't array";
static CONST char *noSuchElement =	"no such element in array";
static CONST char *danglingElement =
				"upvar refers to element in deleted array";
static CONST char *danglingVar =	
				"upvar refers to variable in deleted namespace";
static CONST char *badNamespace =	"parent namespace doesn't exist";
static CONST char *missingName =	"missing variable name";
static CONST char *isArrayElement =	"name refers to an element in an array";
d42 3
a44 3
static int		CallVarTraces _ANSI_ARGS_((Interp *iPtr, Var *arrayPtr,
			    Var *varPtr, CONST char *part1, CONST char *part2,
			    int flags, CONST int leaveErrMsg));
d49 5
a53 7
			    CONST char *arrayName, Var *varPtr, int flags));
static void		DisposeTraceResult _ANSI_ARGS_((int flags,
			    char *result));
static int              ObjMakeUpvar _ANSI_ARGS_((Tcl_Interp *interp, 
                            CallFrame *framePtr, Tcl_Obj *otherP1Ptr, 
                            CONST char *otherP2, CONST int otherFlags,
		            CONST char *myName, CONST int myFlags, int index));
d56 1
a56 2
			    CONST Var *varPtr, CONST char *varName,
			    Tcl_Obj *handleObj));
d58 2
a59 78
			    CONST char *part1, CONST char *part2,
			    CONST char *operation, CONST char *reason));
static int		SetArraySearchObj _ANSI_ARGS_((Tcl_Interp *interp,
			    Tcl_Obj *objPtr));


/*
 * Functions defined in this file that may be exported in the future
 * for use by the bytecode compiler and engine or to the public interface.
 */

Var *		TclLookupSimpleVar _ANSI_ARGS_((Tcl_Interp *interp,
		    CONST char *varName, int flags, CONST int create,
		    CONST char **errMsgPtr, int *indexPtr));
int		TclObjUnsetVar2 _ANSI_ARGS_((Tcl_Interp *interp,
		    Tcl_Obj *part1Ptr, CONST char *part2, int flags));

static Tcl_FreeInternalRepProc FreeLocalVarName;
static Tcl_DupInternalRepProc DupLocalVarName;
static Tcl_UpdateStringProc UpdateLocalVarName;
static Tcl_FreeInternalRepProc FreeNsVarName;
static Tcl_DupInternalRepProc DupNsVarName;
static Tcl_FreeInternalRepProc FreeParsedVarName;
static Tcl_DupInternalRepProc DupParsedVarName;
static Tcl_UpdateStringProc UpdateParsedVarName;

/*
 * Types of Tcl_Objs used to cache variable lookups.
 *
 * 
 * localVarName - INTERNALREP DEFINITION:
 *   twoPtrValue.ptr1 = pointer to the corresponding Proc 
 *   twoPtrValue.ptr2 = index into locals table
 *
 * nsVarName - INTERNALREP DEFINITION:
 *   twoPtrValue.ptr1: pointer to the namespace containing the 
 *                     reference
 *   twoPtrValue.ptr2: pointer to the corresponding Var 
 *
 * parsedVarName - INTERNALREP DEFINITION:
 *   twoPtrValue.ptr1 = pointer to the array name Tcl_Obj, 
 *                      or NULL if it is a scalar variable
 *   twoPtrValue.ptr2 = pointer to the element name string
 *                      (owned by this Tcl_Obj), or NULL if 
 *                      it is a scalar variable
 */

Tcl_ObjType tclLocalVarNameType = {
    "localVarName",
    FreeLocalVarName, DupLocalVarName, UpdateLocalVarName, NULL
};

Tcl_ObjType tclNsVarNameType = {
    "namespaceVarName",
    FreeNsVarName, DupNsVarName, NULL, NULL
};

Tcl_ObjType tclParsedVarNameType = {
    "parsedVarName",
    FreeParsedVarName, DupParsedVarName, UpdateParsedVarName, NULL
};

/*
 * Type of Tcl_Objs used to speed up array searches.
 *
 * INTERNALREP DEFINITION:
 *   twoPtrValue.ptr1 = searchIdNumber as offset from (char*)NULL
 *   twoPtrValue.ptr2 = variableNameStartInString as offset from (char*)NULL
 *
 * Note that the value stored in ptr2 is the offset into the string of
 * the start of the variable name and not the address of the variable
 * name itself, as this can be safely copied.
 */
Tcl_ObjType tclArraySearchType = {
    "array search",
    NULL, NULL, NULL, SetArraySearchObj
};

d66 2
a67 5
 *	This procedure is used to locate a variable given its name(s). It
 *      has been mostly superseded by TclObjLookupVar, it is now only used 
 *      by the string-based interfaces. It is kept in tcl8.4 mainly because 
 *      it is in the internal stubs table, so that some extension may be 
 *      calling it. 
d96 1
d101 1
a101 1
    CONST char *part1;	        /* If part2 isn't NULL, this is the name of
d105 1
a105 1
    CONST char *part2;		/* Name of element within array, or NULL. */
d108 1
a108 1
    CONST char *msg;			/* Verb to use in error messages, e.g.
d122 12
a133 2
    Var *varPtr;
    CONST char *elName;		/* Name of array element or NULL; may be
d135 1
a135 1
    int openParen, closeParen;
d137 9
a145 9
				 * array and index, these are the offsets to 
				 * the parens around the index.  Otherwise 
				 * they are -1. */
    register CONST char *p;
    CONST char *errMsg = NULL;
    int index;
#define VAR_NAME_BUF_SIZE 26
    char buffer[VAR_NAME_BUF_SIZE];
    char *newVarName = buffer;
d149 2
a150 1
    openParen = closeParen = -1;
d165 1
a165 1
	    openParen = p - part1;
d172 1
d176 1
a176 1
		    return NULL;
d178 3
a180 1
		closeParen = p - part1;
d182 1
a182 1
		openParen = -1;
a186 414
    if (openParen != -1) {
	if (closeParen >= VAR_NAME_BUF_SIZE) {
	    newVarName = ckalloc((unsigned int) (closeParen+1));
	}
	memcpy(newVarName, part1, (unsigned int) closeParen);
	newVarName[openParen] = '\0';
	newVarName[closeParen] = '\0';
	part1 = newVarName;
	elName = newVarName + openParen + 1;
    }

    varPtr = TclLookupSimpleVar(interp, part1, flags, 
            createPart1, &errMsg, &index);
    if (varPtr == NULL) {
	if ((errMsg != NULL) && (flags & TCL_LEAVE_ERR_MSG)) {
	    VarErrMsg(interp, part1, elName, msg, errMsg);
	}
    } else {
	while (TclIsVarLink(varPtr)) {
	    varPtr = varPtr->value.linkPtr;
	}
	if (elName != NULL) {
	    *arrayPtrPtr = varPtr;
	    varPtr = TclLookupArrayElement(interp, part1, elName, flags, 
		    msg, createPart1, createPart2, varPtr);
	}
    }
    if (newVarName != buffer) {
	ckfree(newVarName);
    }

    return varPtr;
	
#undef VAR_NAME_BUF_SIZE
}

/*
 *----------------------------------------------------------------------
 *
 * TclObjLookupVar --
 *
 *	This procedure is used by virtually all of the variable code to
 *	locate a variable given its name(s). The parsing into array/element
 *      components and (if possible) the lookup results are cached in 
 *      part1Ptr, which is converted to one of the varNameTypes.
 *
 * Results:
 *	The return value is a pointer to the variable structure indicated by
 *	part1Ptr and part2, or NULL if the variable couldn't be found. If 
 *      the variable is found, *arrayPtrPtr is filled with the address of the
 *	variable structure for the array that contains the variable (or NULL
 *	if the variable is a scalar). If the variable can't be found and
 *	either createPart1 or createPart2 are 1, a new as-yet-undefined
 *	(VAR_UNDEFINED) variable structure is created, entered into a hash
 *	table, and returned.
 *
 *	If the variable isn't found and creation wasn't specified, or some
 *	other error occurs, NULL is returned and an error message is left in
 *	the interp's result if TCL_LEAVE_ERR_MSG is set in flags. 
 *
 *	Note: it's possible for the variable returned to be VAR_UNDEFINED
 *	even if createPart1 or createPart2 are 1 (these only cause the hash
 *	table entry or array to be created). For example, the variable might
 *	be a global that has been unset but is still referenced by a
 *	procedure, or a variable that has been unset but it only being kept
 *	in existence (if VAR_UNDEFINED) by a trace.
 *
 * Side effects:
 *	New hashtable entries may be created if createPart1 or createPart2
 *	are 1.
 *      The object part1Ptr is converted to one of tclLocalVarNameType, 
 *      tclNsVarNameType or tclParsedVarNameType and caches as much of the
 *      lookup as it can.
 *
 *----------------------------------------------------------------------
 */
Var *
TclObjLookupVar(interp, part1Ptr, part2, flags, msg, createPart1, createPart2,
        arrayPtrPtr)
    Tcl_Interp *interp;		/* Interpreter to use for lookup. */
    register Tcl_Obj *part1Ptr;	/* If part2 isn't NULL, this is the name 
				 * of an array. Otherwise, this is a full 
				 * variable name that could include a parenthesized 
				 * array element. */
    CONST char *part2;		/* Name of element within array, or NULL. */
    int flags;		        /* Only TCL_GLOBAL_ONLY, TCL_NAMESPACE_ONLY,
				 * and TCL_LEAVE_ERR_MSG bits matter. */
    CONST char *msg;		/* Verb to use in error messages, e.g.
				 * "read" or "set". Only needed if
				 * TCL_LEAVE_ERR_MSG is set in flags. */
    CONST int createPart1;	/* If 1, create hash table entry for part 1
				 * of name, if it doesn't already exist. If
				 * 0, return error if it doesn't exist. */
    CONST int createPart2;	/* If 1, create hash table entry for part 2
				 * of name, if it doesn't already exist. If
				 * 0, return error if it doesn't exist. */
    Var **arrayPtrPtr;		/* If the name refers to an element of an
				 * array, *arrayPtrPtr gets filled in with
				 * address of array variable. Otherwise
				 * this is set to NULL. */
{
    Interp *iPtr = (Interp *) interp;
    register Var *varPtr;	/* Points to the variable's in-frame Var
				 * structure. */
    char *part1;
    int index, len1, len2;
    int parsed = 0;
    Tcl_Obj *objPtr;
    Tcl_ObjType *typePtr = part1Ptr->typePtr;
    CONST char *errMsg = NULL;
    CallFrame *varFramePtr = iPtr->varFramePtr;
    Namespace *nsPtr;

    /*
     * If part1Ptr is a tclParsedVarNameType, separate it into the 
     * pre-parsed parts.
     */

    *arrayPtrPtr = NULL;
    if (typePtr == &tclParsedVarNameType) {
	if (part1Ptr->internalRep.twoPtrValue.ptr1 != NULL) {
	    if (part2 != NULL) {
		/*
		 * ERROR: part1Ptr is already an array element, cannot 
		 * specify a part2.
		 */

		if (flags & TCL_LEAVE_ERR_MSG) {
		    part1 = TclGetString(part1Ptr);
		    VarErrMsg(interp, part1, part2, msg, needArray);
		}
		return NULL;
	    }
	    part2 = (char *) part1Ptr->internalRep.twoPtrValue.ptr2;
	    part1Ptr = (Tcl_Obj *) part1Ptr->internalRep.twoPtrValue.ptr1;
	    typePtr = part1Ptr->typePtr;
	}
	parsed = 1;
    }
    part1 = Tcl_GetStringFromObj(part1Ptr, &len1);    

    nsPtr = ((varFramePtr == NULL)? iPtr->globalNsPtr : varFramePtr->nsPtr);
    if (nsPtr->varResProc != NULL || iPtr->resolverPtr != NULL) {
	goto doParse;
    }
    
    if (typePtr == &tclLocalVarNameType) {
	Proc *procPtr = (Proc *) part1Ptr->internalRep.twoPtrValue.ptr1;
	int localIndex = (int) part1Ptr->internalRep.twoPtrValue.ptr2;
	int useLocal;

	useLocal = ((varFramePtr != NULL) && varFramePtr->isProcCallFrame
	        && !(flags & (TCL_GLOBAL_ONLY | TCL_NAMESPACE_ONLY)));
	if (useLocal && (procPtr == varFramePtr->procPtr)) {
	    /*
	     * part1Ptr points to an indexed local variable of the
	     * correct procedure: use the cached value.
	     */
	    
	    varPtr = &(varFramePtr->compiledLocals[localIndex]);
	    goto donePart1;
	}
	goto doneParsing;
    } else if (typePtr == &tclNsVarNameType) {
	Namespace *cachedNsPtr;
	int useGlobal, useReference;

	varPtr = (Var *) part1Ptr->internalRep.twoPtrValue.ptr2;
	cachedNsPtr = (Namespace *) part1Ptr->internalRep.twoPtrValue.ptr1;
	useGlobal = (cachedNsPtr == iPtr->globalNsPtr) 
	    && ((flags & TCL_GLOBAL_ONLY) 
		|| ((*part1 == ':') && (*(part1+1) == ':'))
		|| (varFramePtr == NULL) 
		|| (!varFramePtr->isProcCallFrame 
		    && (nsPtr == iPtr->globalNsPtr)));
	useReference = useGlobal || ((cachedNsPtr == nsPtr) 
	        && ((flags & TCL_NAMESPACE_ONLY) 
		    || (varFramePtr && !varFramePtr->isProcCallFrame 
			&& !(flags & TCL_GLOBAL_ONLY)
			/* careful: an undefined ns variable could
			 * be hiding a valid global reference. */
			&& !(varPtr->flags & VAR_UNDEFINED))));
	if (useReference && (varPtr->hPtr != NULL)) {
	    /*
	     * A straight global or namespace reference, use it. It isn't 
	     * so simple to deal with 'implicit' namespace references, i.e., 
	     * those where the reference could be to either a namespace 
	     * or a global variable. Those we lookup again.
	     *
	     * If (varPtr->hPtr == NULL), this might be a reference to a
	     * variable in a deleted namespace, kept alive by e.g. part1Ptr.
	     * We could conceivably be so unlucky that a new namespace was
	     * created at the same address as the deleted one, so to be 
	     * safe we test for a valid hPtr.
	     */
	    goto donePart1;
	}
	goto doneParsing;
    }

    doParse:
    if (!parsed && (*(part1 + len1 - 1) == ')')) {
	/*
	 * part1Ptr is possibly an unparsed array element.
	 */
	register int i;
	char *newPart2;
	len2 = -1;
	for (i = 0; i < len1; i++) {
	    if (*(part1 + i) == '(') {
		if (part2 != NULL) {
		    if (flags & TCL_LEAVE_ERR_MSG) {
			VarErrMsg(interp, part1, part2, msg, needArray);
		    }
		}			

		/*
		 * part1Ptr points to an array element; first copy 
		 * the element name to a new string part2.
		 */

		part2 = part1 + i + 1;
		len2 = len1 - i - 2;
		len1 = i;

		newPart2 = ckalloc((unsigned int) (len2+1));
		memcpy(newPart2, part2, (unsigned int) len2);
		*(newPart2+len2) = '\0';
		part2 = newPart2;

		/*
		 * Free the internal rep of the original part1Ptr, now
		 * renamed objPtr, and set it to tclParsedVarNameType.
		 */

		objPtr = part1Ptr;
		if ((typePtr != NULL) && (typePtr->freeIntRepProc != NULL)) {
		    typePtr->freeIntRepProc(objPtr);
		}
		objPtr->typePtr = &tclParsedVarNameType;

		/*
		 * Define a new string object to hold the new part1Ptr, i.e., 
		 * the array name. Set the internal rep of objPtr, reset
		 * typePtr and part1 to contain the references to the
		 * array name.
		 */

		part1Ptr = Tcl_NewStringObj(part1, len1);
		Tcl_IncrRefCount(part1Ptr);

		objPtr->internalRep.twoPtrValue.ptr1 = (VOID *) part1Ptr;
		objPtr->internalRep.twoPtrValue.ptr2 = (VOID *) part2;		

		typePtr = part1Ptr->typePtr;
		part1 = TclGetString(part1Ptr);
		break;
	    }
	}
    }
    
    doneParsing:
    /*
     * part1Ptr is not an array element; look it up, and convert 
     * it to one of the cached types if possible.
     */

    if ((typePtr != NULL) && (typePtr->freeIntRepProc != NULL)) {
	typePtr->freeIntRepProc(part1Ptr);
	part1Ptr->typePtr = NULL;
    }

    varPtr = TclLookupSimpleVar(interp, part1, flags, 
            createPart1, &errMsg, &index);
    if (varPtr == NULL) {
	if ((errMsg != NULL) && (flags & TCL_LEAVE_ERR_MSG)) {
	    VarErrMsg(interp, part1, part2, msg, errMsg);
	}
	return NULL;
    }

    /*
     * Cache the newly found variable if possible.
     */

    if (index >= 0) {
        /*
	 * An indexed local variable.
	 */

	Proc *procPtr = ((Interp *) interp)->varFramePtr->procPtr;

	part1Ptr->typePtr = &tclLocalVarNameType;
	procPtr->refCount++;
	part1Ptr->internalRep.twoPtrValue.ptr1 = (VOID *) procPtr;
	part1Ptr->internalRep.twoPtrValue.ptr2 = (VOID *) index;
    } else if (index > -3) {
	Namespace *nsPtr;
    
	nsPtr = ((index == -1)? iPtr->globalNsPtr : varFramePtr->nsPtr);
	varPtr->refCount++;
	part1Ptr->typePtr = &tclNsVarNameType;
	part1Ptr->internalRep.twoPtrValue.ptr1 = (VOID *) nsPtr;
	part1Ptr->internalRep.twoPtrValue.ptr2 = (VOID *) varPtr;
    } else {
	/*
	 * At least mark part1Ptr as already parsed.
	 */
	part1Ptr->typePtr = &tclParsedVarNameType;
	part1Ptr->internalRep.twoPtrValue.ptr1 = NULL;
	part1Ptr->internalRep.twoPtrValue.ptr2 = NULL;
    }
    
    donePart1:
#if 0
    if (varPtr == NULL) {
	if (flags & TCL_LEAVE_ERR_MSG) {
	    part1 = TclGetString(part1Ptr);
	    VarErrMsg(interp, part1, part2, msg, 
		    "Cached variable reference is NULL.");
	}
	return NULL;
    }
#endif
    while (TclIsVarLink(varPtr)) {
	varPtr = varPtr->value.linkPtr;
    }

    if (part2 != NULL) {
	/*
	 * Array element sought: look it up.
	 */

	part1 = TclGetString(part1Ptr);
	*arrayPtrPtr = varPtr;
	varPtr = TclLookupArrayElement(interp, part1, part2, 
                flags, msg, createPart1, createPart2, varPtr);
    }
    return varPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * TclLookupSimpleVar --
 *
 *	This procedure is used by to locate a simple variable (i.e., not
 *      an array element) given its name.
 *
 * Results:
 *	The return value is a pointer to the variable structure indicated by
 *	varName, or NULL if the variable couldn't be found. If the variable 
 *      can't be found and create is 1, a new as-yet-undefined (VAR_UNDEFINED) 
 *      variable structure is created, entered into a hash table, and returned.
 *
 *      If the current CallFrame corresponds to a proc and the variable found is
 *      one of the compiledLocals, its index is placed in *indexPtr. Otherwise,
 *      *indexPtr will be set to (according to the needs of TclObjLookupVar):
 *               -1 a global reference
 *               -2 a reference to a namespace variable
 *               -3 a non-cachable reference, i.e., one of:
 *                    . non-indexed local var
 *                    . a reference of unknown origin;
 *                    . resolution by a namespace or interp resolver
 *
 *	If the variable isn't found and creation wasn't specified, or some
 *	other error occurs, NULL is returned and the corresponding error
 *	message is left in *errMsgPtr. 
 *
 *	Note: it's possible for the variable returned to be VAR_UNDEFINED
 *	even if create is 1 (this only causes the hash table entry to be
 *	created).  For example, the variable might be a global that has been
 *	unset but is still referenced by a procedure, or a variable that has
 *	been unset but it only being kept in existence (if VAR_UNDEFINED) by
 *	a trace.
 *
 * Side effects:
 *	A new hashtable entry may be created if create is 1.
 *
 *----------------------------------------------------------------------
 */

Var *
TclLookupSimpleVar(interp, varName, flags, create, errMsgPtr, indexPtr)
    Tcl_Interp *interp;		/* Interpreter to use for lookup. */
    CONST char *varName;        /* This is a simple variable name that could
				 * representa scalar or an array. */
    int flags;		        /* Only TCL_GLOBAL_ONLY, TCL_NAMESPACE_ONLY,
				 * and TCL_LEAVE_ERR_MSG bits matter. */
    CONST int create;		/* If 1, create hash table entry for varname,
				 * if it doesn't already exist. If 0, return 
				 * error if it doesn't exist. */
    CONST char **errMsgPtr;
    int *indexPtr;
{    
    Interp *iPtr = (Interp *) interp;
    CallFrame *varFramePtr = iPtr->varFramePtr;
				/* Points to the procedure call frame whose
				 * variables are currently in use. Same as
				 * the current procedure's frame, if any,
				 * unless an "uplevel" is executing. */
    Tcl_HashTable *tablePtr;	/* Points to the hashtable, if any, in which
				 * to look up the variable. */
    Tcl_Var var;                /* Used to search for global names. */
    Var *varPtr;		/* Points to the Var structure returned for
				 * the variable. */
    Namespace *varNsPtr, *cxtNsPtr, *dummy1Ptr, *dummy2Ptr;
    ResolverScheme *resPtr;
    Tcl_HashEntry *hPtr;
    int new, i, result;

    varPtr = NULL;
    varNsPtr = NULL;		/* set non-NULL if a nonlocal variable */
    *indexPtr = -3;
d194 1
a194 1
    if ((flags & TCL_GLOBAL_ONLY) || iPtr->varFramePtr == NULL) {
d204 1
a204 1
            result = (*cxtNsPtr->varResProc)(interp, varName,
d212 1
a212 1
                result = (*resPtr->varResProc)(interp, varName,
d220 1
a220 1
	    return varPtr;
d222 1
a222 1
	    return NULL;
d227 1
a227 1
     * Look up varName. Look it up as either a namespace variable or as a
d229 1
a229 1
     * Interpret varName as a namespace variable if:
d235 1
a235 1
     * Otherwise, if varName is a local variable, search first in the
d239 1
a239 1
     * If create and the variable isn't found, create the variable and,
d246 2
a247 3
	    || (strstr(varName, "::") != NULL)) {
	CONST char *tail;
	int lookGlobal;
a248 10
	lookGlobal = (flags & TCL_GLOBAL_ONLY) 
	    || (cxtNsPtr == iPtr->globalNsPtr)
	    || ((*varName == ':') && (*(varName+1) == ':'));
	if (lookGlobal) {
	    *indexPtr = -1;
	    flags = (flags | TCL_GLOBAL_ONLY) & ~TCL_NAMESPACE_ONLY;
	} else if (flags & TCL_NAMESPACE_ONLY) {
	    *indexPtr = -2;
	}

d253 1
a253 1
	var = Tcl_FindNamespaceVar(interp, varName, (Tcl_Namespace *) cxtNsPtr,
d259 2
a260 2
	    if (create) {   /* var wasn't found so create it  */
		TclGetNamespaceForQualName(interp, varName, cxtNsPtr,
d262 1
d264 4
a267 2
		    *errMsgPtr = badNamespace;
		    return NULL;
d270 4
a273 2
		    *errMsgPtr = missingName;
		    return NULL;
d280 3
a282 9
		if ((lookGlobal)  || (varNsPtr == NULL)) {
		    /*
		     * The variable was created starting from the global
		     * namespace: a global reference is returned even if 
		     * it wasn't explicitly requested.
		     */
		    *indexPtr = -1;
		} else {
		    *indexPtr = -2;
d284 1
a284 3
	    } else {		/* var wasn't found and not to create it */
		*errMsgPtr = noSuchVar;
		return NULL;
d292 1
a292 1
	int varNameLen = strlen(varName);
d297 5
a301 5
		if ((varName[0] == localName[0])
		        && (varNameLen == localPtr->nameLength)
		        && (strcmp(varName, localName) == 0)) {
		    *indexPtr = i;
		    return localVarPtr;
d307 29
a335 15
	tablePtr = varFramePtr->varTablePtr;
	if (create) {
	    if (tablePtr == NULL) {
		tablePtr = (Tcl_HashTable *)
		    ckalloc(sizeof(Tcl_HashTable));
		Tcl_InitHashTable(tablePtr, TCL_STRING_KEYS);
		varFramePtr->varTablePtr = tablePtr;
	    }
	    hPtr = Tcl_CreateHashEntry(tablePtr, varName, &new);
	    if (new) {
		varPtr = NewVar();
		Tcl_SetHashValue(hPtr, varPtr);
		varPtr->hPtr = hPtr;
		varPtr->nsPtr = NULL; /* a local variable */
	    } else {
a337 10
	} else {
	    hPtr = NULL;
	    if (tablePtr != NULL) {
		hPtr = Tcl_FindHashEntry(tablePtr, varName);
	    }
	    if (hPtr == NULL) {
		*errMsgPtr = noSuchVar;
		return NULL;
	    }
	    varPtr = (Var *) Tcl_GetHashValue(hPtr);
a339 39
    return varPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * TclLookupArrayElement --
 *
 *	This procedure is used to locate a variable which is in an array's 
 *      hashtable given a pointer to the array's Var structure and the 
 *      element's name.
 *
 * Results:
 *	The return value is a pointer to the variable structure , or NULL if 
 *      the variable couldn't be found. 
 *
 *      If arrayPtr points to a variable that isn't an array and createPart1 
 *      is 1, the corresponding variable will be converted to an array. 
 *      Otherwise, NULL is returned and an error message is left in
 *	the interp's result if TCL_LEAVE_ERR_MSG is set in flags.
 *
 *      If the variable is not found and createPart2 is 1, the variable is
 *      created. Otherwise, NULL is returned and an error message is left in
 *	the interp's result if TCL_LEAVE_ERR_MSG is set in flags.
 *
 *	Note: it's possible for the variable returned to be VAR_UNDEFINED
 *	even if createPart1 or createPart2 are 1 (these only cause the hash
 *	table entry or array to be created). For example, the variable might
 *	be a global that has been unset but is still referenced by a
 *	procedure, or a variable that has been unset but it only being kept
 *	in existence (if VAR_UNDEFINED) by a trace.
 *
 * Side effects:
 *      The variable at arrayPtr may be converted to be an array if 
 *      createPart1 is 1. A new hashtable entry may be created if createPart2 
 *      is 1.
 *
 *----------------------------------------------------------------------
 */
d341 23
a363 21
Var *
TclLookupArrayElement(interp, arrayName, elName, flags, msg, createArray, createElem, arrayPtr)
    Tcl_Interp *interp;		/* Interpreter to use for lookup. */
    CONST char *arrayName;	        /* This is the name of the array. */
    CONST char *elName;		/* Name of element within array. */
    CONST int flags;		/* Only TCL_LEAVE_ERR_MSG bit matters. */
    CONST char *msg;			/* Verb to use in error messages, e.g.
				 * "read" or "set". Only needed if
				 * TCL_LEAVE_ERR_MSG is set in flags. */
    CONST int createArray;	/* If 1, transform arrayName to be an array
				 * if it isn't one yet and the transformation 
				 * is possible. If 0, return error if it 
				 * isn't already an array. */
    CONST int createElem;	/* If 1, create hash table entry for the 
				 * element, if it doesn't already exist. If
				 * 0, return error if it doesn't exist. */
    Var *arrayPtr;	        /* Pointer to the array's Var structure. */
{
    Tcl_HashEntry *hPtr;
    int new;
    Var *varPtr;
d370 2
a371 2
    if (TclIsVarUndefined(arrayPtr) && !TclIsVarArrayElement(arrayPtr)) {
	if (!createArray) {
d373 1
a373 1
		VarErrMsg(interp, arrayName, elName, msg, noSuchVar);
d375 2
a376 1
	    return NULL;
d383 1
a383 1
	if ((arrayPtr->flags & VAR_IN_HASHTABLE) && (arrayPtr->hPtr == NULL)) {
d385 1
a385 1
		VarErrMsg(interp, arrayName, elName, msg, danglingVar);
d387 2
a388 1
	    return NULL;
d391 3
a393 3
	TclSetVarArray(arrayPtr);
	TclClearVarUndefined(arrayPtr);
	arrayPtr->value.tablePtr =
d395 2
a396 2
	Tcl_InitHashTable(arrayPtr->value.tablePtr, TCL_STRING_KEYS);
    } else if (!TclIsVarArray(arrayPtr)) {
d398 1
a398 1
	    VarErrMsg(interp, arrayName, elName, msg, needArray);
d400 2
a401 1
	return NULL;
d403 9
a411 3

    if (createElem) {
	hPtr = Tcl_CreateHashEntry(arrayPtr->value.tablePtr, elName, &new);
d413 2
a414 2
	    if (arrayPtr->searchPtr != NULL) {
		DeleteSearches(arrayPtr);
d419 1
a419 1
	    varPtr->nsPtr = arrayPtr->nsPtr;
d423 4
a426 1
	hPtr = Tcl_FindHashEntry(arrayPtr->value.tablePtr, elName);
d429 1
a429 1
		VarErrMsg(interp, arrayName, elName, msg, noSuchElement);
d431 2
a432 1
	    return NULL;
d435 7
a441 1
    return (Var *) Tcl_GetHashValue(hPtr);
d466 1
a466 1
CONST char *
d470 1
a470 1
    CONST char *varName;	/* Name of a variable in interp. */
d501 1
a501 1
CONST char *
d505 1
a505 1
    CONST char *part1;		/* Name of an array (if part2 is non-NULL)
d507 1
a507 1
    CONST char *part2;		/* If non-NULL, gives the name of an element
a520 52

/*
 *----------------------------------------------------------------------
 *
 * Tcl_GetVar2Ex --
 *
 *	Return the value of a Tcl variable as a Tcl object, given a
 *	two-part name consisting of array name and element within array.
 *
 * Results:
 *	The return value points to the current object value of the variable
 *	given by part1Ptr and part2Ptr. If the specified variable doesn't
 *	exist, or if there is a clash in array usage, then NULL is returned
 *	and a message will be left in the interpreter's result if the
 *	TCL_LEAVE_ERR_MSG flag is set.
 *
 * Side effects:
 *	The ref count for the returned object is _not_ incremented to
 *	reflect the returned reference; if you want to keep a reference to
 *	the object you must increment its ref count yourself.
 *
 *----------------------------------------------------------------------
 */

Tcl_Obj *
Tcl_GetVar2Ex(interp, part1, part2, flags)
    Tcl_Interp *interp;		/* Command interpreter in which variable is
				 * to be looked up. */
    CONST char *part1;		/* Name of an array (if part2 is non-NULL)
				 * or the name of a variable. */
    CONST char *part2;		/* If non-NULL, gives the name of an element
				 * in the array part1. */
    int flags;			/* OR-ed combination of TCL_GLOBAL_ONLY,
				 * and TCL_LEAVE_ERR_MSG bits. */
{
    Var *varPtr, *arrayPtr;

    /*
     * We need a special flag check to see if we want to create part 1,
     * because commands like lappend require read traces to trigger for
     * previously non-existent values.
     */
    varPtr = TclLookupVar(interp, part1, part2, flags, "read",
            /*createPart1*/ (flags & TCL_TRACE_READS),
	    /*createPart2*/ 1, &arrayPtr);
    if (varPtr == NULL) {
	return NULL;
    }

    return TclPtrGetVar(interp, varPtr, arrayPtr, part1, part2, flags);
}

d554 3
a556 2
    int flags;			/* OR-ed combination of TCL_GLOBAL_ONLY and
				 * TCL_LEAVE_ERR_MSG bits. */
a557 1
    Var *varPtr, *arrayPtr;
d561 5
a565 1
    part2 = ((part2Ptr == NULL) ? NULL : Tcl_GetString(part2Ptr));
d567 1
a567 13
    /*
     * We need a special flag check to see if we want to create part 1,
     * because commands like lappend require read traces to trigger for
     * previously non-existent values.
     */
    varPtr = TclObjLookupVar(interp, part1Ptr, part2, flags, "read",
            /*createPart1*/ (flags & TCL_TRACE_READS),
	    /*createPart2*/ 1, &arrayPtr);
    if (varPtr == NULL) {
	return NULL;
    }

    return TclPtrGetVar(interp, varPtr, arrayPtr, part1, part2, flags);
d573 1
a573 1
 * TclPtrGetVar --
d575 2
a576 3
 *	Return the value of a Tcl variable as a Tcl object, given the
 *      pointers to the variable's (and possibly containing array's) 
 *      VAR structure.
d580 4
a583 3
 *	given by varPtr. If the specified variable doesn't exist, or if there 
 *      is a clash in array usage, then NULL is returned and a message will be 
 *      left in the interpreter's result if the TCL_LEAVE_ERR_MSG flag is set.
d594 1
a594 1
TclPtrGetVar(interp, varPtr, arrayPtr, part1, part2, flags)
d597 1
a597 4
    register Var *varPtr;       /* The variable to be read.*/
    Var *arrayPtr;              /* NULL for scalar variables, pointer to
				 * the containing array otherwise. */
    CONST char *part1;		/* Name of an array (if part2 is non-NULL)
d599 1
a599 1
    CONST char *part2;		/* If non-NULL, gives the name of an element
d601 1
a601 1
    CONST int flags;		/* OR-ed combination of TCL_GLOBAL_ONLY,
d605 9
a613 1
    CONST char *msg;
d621 6
a626 3
	if (TCL_ERROR == CallVarTraces(iPtr, arrayPtr, varPtr, part1, part2,
		(flags & (TCL_NAMESPACE_ONLY|TCL_GLOBAL_ONLY))
		| TCL_TRACE_READS, (flags & TCL_LEAVE_ERR_MSG))) {
d666 1
a666 1
 * Tcl_SetObjCmd --
d668 3
a670 2
 *	This procedure is invoked to process the "set" Tcl command.
 *	See the user documentation for details on what it does.
d673 5
a677 1
 *	A standard Tcl result value.
d680 3
a682 1
 *	A variable's value may be changed.
d687 9
a695 7
	/* ARGSUSED */
int
Tcl_SetObjCmd(dummy, interp, objc, objv)
    ClientData dummy;			/* Not used. */
    register Tcl_Interp *interp;	/* Current interpreter. */
    int objc;				/* Number of arguments. */
    Tcl_Obj *CONST objv[];		/* Argument objects. */
d697 46
a742 1
    Tcl_Obj *varValueObj;
d744 8
a751 4
    if (objc == 2) {
	varValueObj = Tcl_ObjGetVar2(interp, objv[1], NULL, TCL_LEAVE_ERR_MSG);
	if (varValueObj == NULL) {
	    return TCL_ERROR;
d753 15
a767 3
	Tcl_SetObjResult(interp, varValueObj);
	return TCL_OK;
    } else if (objc == 3) {
a768 4
	varValueObj = Tcl_ObjSetVar2(interp, objv[1], NULL, objv[2],
		TCL_LEAVE_ERR_MSG);
	if (varValueObj == NULL) {
	    return TCL_ERROR;
d770 1
a770 5
	Tcl_SetObjResult(interp, varValueObj);
	return TCL_OK;
    } else {
	Tcl_WrongNumArgs(interp, 1, objv, "varName ?newValue?");
	return TCL_ERROR;
d772 1
d778 1
a778 1
 * Tcl_SetVar --
d780 4
a783 1
 *	Change the value of a variable.
d786 5
a790 7
 *	Returns a pointer to the malloc'ed string which is the character
 *	representation of the variable's new value. The caller must not
 *	modify this string. If the write operation was disallowed then NULL
 *	is returned; if the TCL_LEAVE_ERR_MSG flag is set, then an
 *	explanatory message will be left in the interp's result. Note that the
 *	returned string may not be the same as newValue; this is because
 *	variable traces may modify the variable's value.
d793 3
a795 3
 *	If varName is defined as a local or global variable in interp,
 *	its value is changed to newValue. If varName isn't currently
 *	defined, then a new global variable by that name is created.
d800 3
a802 3
CONST char *
Tcl_SetVar(interp, varName, newValue, flags)
    Tcl_Interp *interp;		/* Command interpreter in which varName is
d804 221
a1024 6
    CONST char *varName;	/* Name of a variable in interp. */
    CONST char *newValue;	/* New value for varName. */
    int flags;			/* Various flags that tell how to set value:
				 * any of TCL_GLOBAL_ONLY,
				 * TCL_NAMESPACE_ONLY, TCL_APPEND_VALUE,
				 * TCL_LIST_ELEMENT, TCL_LEAVE_ERR_MSG. */
d1056 1
a1056 1
CONST char *
d1060 1
a1060 1
    CONST char *part1;          /* If part2 is NULL, this is name of scalar
d1063 1
a1063 1
    CONST char *part2;		/* Name of an element within an array, or
d1065 1
a1065 1
    CONST char *newValue;       /* New value for variable. */
a1093 64
 * Tcl_SetVar2Ex --
 *
 *	Given a two-part variable name, which may refer either to a scalar
 *	variable or an element of an array, change the value of the variable
 *	to a new Tcl object value. If the named scalar or array or element
 *	doesn't exist then create one.
 *
 * Results:
 *	Returns a pointer to the Tcl_Obj holding the new value of the
 *	variable. If the write operation was disallowed because an array was
 *	expected but not found (or vice versa), then NULL is returned; if
 *	the TCL_LEAVE_ERR_MSG flag is set, then an explanatory message will
 *	be left in the interpreter's result. Note that the returned object
 *	may not be the same one referenced by newValuePtr; this is because
 *	variable traces may modify the variable's value.
 *
 * Side effects:
 *	The value of the given variable is set. If either the array or the
 *	entry didn't exist then a new variable is created.
 *
 *	The reference count is decremented for any old value of the variable
 *	and incremented for its new value. If the new value for the variable
 *	is not the same one referenced by newValuePtr (perhaps as a result
 *	of a variable trace), then newValuePtr's ref count is left unchanged
 *	by Tcl_SetVar2Ex. newValuePtr's ref count is also left unchanged if
 *	we are appending it as a string value: that is, if "flags" includes
 *	TCL_APPEND_VALUE but not TCL_LIST_ELEMENT.
 *
 *	The reference count for the returned object is _not_ incremented: if
 *	you want to keep a reference to the object you must increment its
 *	ref count yourself.
 *
 *----------------------------------------------------------------------
 */

Tcl_Obj *
Tcl_SetVar2Ex(interp, part1, part2, newValuePtr, flags)
    Tcl_Interp *interp;		/* Command interpreter in which variable is
				 * to be found. */
    CONST char *part1;		/* Name of an array (if part2 is non-NULL)
				 * or the name of a variable. */
    CONST char *part2;		/* If non-NULL, gives the name of an element
				 * in the array part1. */
    Tcl_Obj *newValuePtr;	/* New value for variable. */
    int flags;			/* Various flags that tell how to set value:
				 * any of TCL_GLOBAL_ONLY,
				 * TCL_NAMESPACE_ONLY, TCL_APPEND_VALUE,
				 * TCL_LIST_ELEMENT or TCL_LEAVE_ERR_MSG. */
{
    Var *varPtr, *arrayPtr;

    varPtr = TclLookupVar(interp, part1, part2, flags, "set",
	    /*createPart1*/ 1, /*createPart2*/ 1, &arrayPtr);
    if (varPtr == NULL) {
	return NULL;
    }

    return TclPtrSetVar(interp, varPtr, arrayPtr, part1, part2, 
            newValuePtr, flags);
}

/*
 *----------------------------------------------------------------------
 *
d1096 1
a1096 1
 *	This function is the same as Tcl_SetVar2Ex above, except the
d1111 1
d1130 2
a1131 1
				 * TCL_LIST_ELEMENT, or TCL_LEAVE_ERR_MSG. */
a1132 1
    Var *varPtr, *arrayPtr;
d1135 5
a1139 7
    part1 = TclGetString(part1Ptr);
    part2 = ((part2Ptr == NULL) ? NULL : Tcl_GetString(part2Ptr));    

    varPtr = TclObjLookupVar(interp, part1Ptr, part2, flags, "set",
	    /*createPart1*/ 1, /*createPart2*/ 1, &arrayPtr);
    if (varPtr == NULL) {
	return NULL;
d1141 2
a1142 3

    return TclPtrSetVar(interp, varPtr, arrayPtr, part1, part2, 
            newValuePtr, flags);
a1144 1

d1148 1
a1148 1
 * TclPtrSetVar --
d1150 4
a1153 3
 *	This function is the same as Tcl_SetVar2Ex above, except that
 *      it requires pointers to the variable's Var structs in addition
 *	to the variable names.
d1167 12
a1178 1

d1184 1
a1184 1
TclPtrSetVar(interp, varPtr, arrayPtr, part1, part2, newValuePtr, flags)
d1186 2
a1187 4
				 * to be looked up. */
    register Var *varPtr;
    Var *arrayPtr;
    CONST char *part1;		/* Name of an array (if part2 is non-NULL)
d1189 1
a1189 1
    CONST char *part2;		/* If non-NULL, gives the name of an element
d1192 4
a1195 2
    CONST int flags;			/* OR-ed combination of TCL_GLOBAL_ONLY,
				 * and TCL_LEAVE_ERR_MSG bits. */
d1198 2
d1202 8
a1209 1
    int result;
d1242 4
a1245 2
     * Invoke any read traces that have been set for the variable if it
     * is requested; this is only done in the core when lappending.
a1247 8
    if ((flags & TCL_TRACE_READS) && ((varPtr->tracePtr != NULL) 
	    || ((arrayPtr != NULL) && (arrayPtr->tracePtr != NULL)))) {
	if (TCL_ERROR == CallVarTraces(iPtr, arrayPtr, varPtr, part1, part2,
		TCL_TRACE_READS, (flags & TCL_LEAVE_ERR_MSG))) {
	    return NULL;
	}
    }

d1284 1
d1286 2
a1287 2
		varPtr->value.objPtr = newValuePtr;
		Tcl_IncrRefCount(newValuePtr);
d1298 9
a1306 5
    } else if (newValuePtr != oldValuePtr) {
	/*
	 * In this case we are replacing the value, so we don't need to
	 * do more than swap the objects.
	 */
d1308 18
a1325 4
	varPtr->value.objPtr = newValuePtr;
	Tcl_IncrRefCount(newValuePtr);      /* var is another ref */
	if (oldValuePtr != NULL) {
	    TclDecrRefCount(oldValuePtr);   /* discard old value */
d1340 6
a1345 3
	if (TCL_ERROR == CallVarTraces(iPtr, arrayPtr, varPtr, part1, part2,
	        (flags & (TCL_GLOBAL_ONLY|TCL_NAMESPACE_ONLY))
		| TCL_TRACE_WRITES, (flags & TCL_LEAVE_ERR_MSG))) {
d1382 397
d1818 7
a1824 2
    Var *varPtr, *arrayPtr;
    char *part1, *part2;
d1826 2
a1827 6
    part1 = TclGetString(part1Ptr);
    part2 = ((part2Ptr == NULL)? NULL : TclGetString(part2Ptr));

    varPtr = TclObjLookupVar(interp, part1Ptr, part2, flags, "read",
	    0, 1, &arrayPtr);
    if (varPtr == NULL) {
d1832 31
a1862 2
    return TclPtrIncrVar(interp, varPtr, arrayPtr, part1, part2,
	    incrAmount, flags);
d1868 1
a1868 1
 * TclPtrIncrVar --
d1870 3
a1872 3
 *	Given the pointers to a variable and possible containing array, 
 *      increment the Tcl object value of the variable by a specified 
 *      amount.
d1876 4
a1879 4
 *	variable. If the specified variable doesn't exist, or there is a
 *	clash in array usage, or an error occurs while executing variable
 *	traces, then NULL is returned and a message will be left in
 *	the interpreter's result.
d1883 3
a1885 4
 *	amount. If either the array or the entry didn't exist then a new
 *	variable is created. The ref count for the returned object is _not_
 *	incremented to reflect the returned reference; if you want to keep a
 *	reference to the object you must increment its ref count yourself.
d1891 1
a1891 1
TclPtrIncrVar(interp, varPtr, arrayPtr, part1, part2, incrAmount, flags)
d1894 3
a1896 13
    Var *varPtr;
    Var *arrayPtr;
    CONST char *part1;		/* Points to an object holding the name of
				 * an array (if part2 is non-NULL) or the
				 * name of a variable. */
    CONST char *part2;		/* If non-null, points to an object holding
				 * the name of an element in the array
				 * part1Ptr. */
    CONST long incrAmount;	/* Amount to be added to variable. */
    CONST int flags;            /* Various flags that tell how to incr value:
				 * any of TCL_GLOBAL_ONLY,
				 * TCL_NAMESPACE_ONLY, TCL_APPEND_VALUE,
				 * TCL_LIST_ELEMENT, TCL_LEAVE_ERR_MSG. */
d1899 1
d1904 1
d1906 2
a1907 2
    varValuePtr = TclPtrGetVar(interp, varPtr, arrayPtr, part1, part2, flags);

d1915 5
a1919 4
     * Increment the variable's value. If the object is unshared we can
     * modify it directly, otherwise we must create a new copy to modify:
     * this is "copy on write". Then free the variable's old string
     * representation, if any, since it will no longer be valid.
d1924 1
a1925 1
	createdNewObj = 1;
d1927 2
a1928 2
#ifdef TCL_WIDE_INT_IS_LONG
    if (Tcl_GetLongFromObj(interp, varValuePtr, &i) != TCL_OK) {
d1935 83
a2017 23
#else
    if (varValuePtr->typePtr == &tclWideIntType) {
	Tcl_WideInt wide = varValuePtr->internalRep.wideValue;
	Tcl_SetWideIntObj(varValuePtr, wide + Tcl_LongAsWide(incrAmount));
    } else if (varValuePtr->typePtr == &tclIntType) {
	i = varValuePtr->internalRep.longValue;
	Tcl_SetIntObj(varValuePtr, i + incrAmount);
    } else {
	/*
	 * Not an integer or wide internal-rep...
	 */
	Tcl_WideInt wide;
	if (Tcl_GetWideIntFromObj(interp, varValuePtr, &wide) != TCL_OK) {
	    if (createdNewObj) {
		Tcl_DecrRefCount(varValuePtr); /* free unneeded copy */
	    }
	    return NULL;
	}
	if (wide <= Tcl_LongAsWide(LONG_MAX)
		&& wide >= Tcl_LongAsWide(LONG_MIN)) {
	    Tcl_SetLongObj(varValuePtr, Tcl_WideAsLong(wide) + incrAmount);
	} else {
	    Tcl_SetWideIntObj(varValuePtr, wide + Tcl_LongAsWide(incrAmount));
d2019 1
d2021 2
a2022 2
#endif

d2027 7
a2033 2
    return TclPtrSetVar(interp, varPtr, arrayPtr, part1, part2,
	    varValuePtr, flags);
d2060 1
a2060 1
    CONST char *varName;	/* Name of a variable in interp.  May be
d2095 2
a2096 45
    CONST char *part1;		/* Name of variable or array. */
    CONST char *part2;		/* Name of element within array or NULL. */
    int flags;			/* OR-ed combination of any of
				 * TCL_GLOBAL_ONLY, TCL_NAMESPACE_ONLY,
				 * TCL_LEAVE_ERR_MSG. */
{
    int result;
    Tcl_Obj *part1Ptr;

    part1Ptr = Tcl_NewStringObj(part1, -1);
    Tcl_IncrRefCount(part1Ptr);
    result = TclObjUnsetVar2(interp, part1Ptr, part2, flags);
    TclDecrRefCount(part1Ptr);

    return result;
}


/*
 *----------------------------------------------------------------------
 *
 * TclObjUnsetVar2 --
 *
 *	Delete a variable, given a 2-object name.
 *
 * Results:
 *	Returns TCL_OK if the variable was successfully deleted, TCL_ERROR
 *	if the variable can't be unset.  In the event of an error,
 *	if the TCL_LEAVE_ERR_MSG flag is set then an error message
 *	is left in the interp's result.
 *
 * Side effects:
 *	If part1ptr and part2Ptr indicate a local or global variable in interp,
 *	it is deleted.  If part1Ptr is an array name and part2Ptr is NULL, then
 *	the whole array is deleted.
 *
 *----------------------------------------------------------------------
 */

int
TclObjUnsetVar2(interp, part1Ptr, part2, flags)
    Tcl_Interp *interp;		/* Command interpreter in which varName is
				 * to be looked up. */
    Tcl_Obj *part1Ptr;		/* Name of variable or array. */
    CONST char *part2;		/* Name of element within array or NULL. */
a2107 1
    char *part1;
d2109 1
a2109 2
    part1 = TclGetString(part1Ptr);
    varPtr = TclObjLookupVar(interp, part1Ptr, part2, flags, "unset",
a2113 1
 
d2144 1
a2144 1
     * 1. We need to increment varPtr's refCount around this: CallVarTraces
d2154 2
a2155 3
	CallVarTraces(iPtr, arrayPtr, &dummyVar, part1, part2,
		(flags & (TCL_GLOBAL_ONLY|TCL_NAMESPACE_ONLY))
		| TCL_TRACE_UNSETS, /* leaveErrMsg */ 0);
d2159 1
a2159 1
	    Tcl_EventuallyFree((ClientData) tracePtr, TCL_DYNAMIC);
d2161 1
a2161 1
	for (activePtr = iPtr->activeVarTracePtr;  activePtr != NULL;
d2193 1
a2193 2
		(flags & (TCL_GLOBAL_ONLY|TCL_NAMESPACE_ONLY)) 
		| TCL_TRACE_UNSETS);
d2259 1
a2259 1
    CONST char *varName;	/* Name of variable;  may end with "(index)"
d2298 2
a2299 2
    CONST char *part1;		/* Name of scalar variable or array. */
    CONST char *part2;		/* Name of element within array;  NULL means
d2312 2
a2313 11
    int flagMask;
    
    /* 
     * We strip 'flags' down to just the parts which are relevant to
     * TclLookupVar, to avoid conflicts between trace flags and
     * internal namespace flags such as 'FIND_ONLY_NS'.  This can
     * now occur since we have trace flags with values 0x1000 and higher.
     */
    flagMask = TCL_GLOBAL_ONLY | TCL_NAMESPACE_ONLY;
    varPtr = TclLookupVar(interp, part1, part2,
	    (flags & flagMask) | TCL_LEAVE_ERR_MSG,
a2319 9
     * Check for a nonsense flag combination.  Note that this is a
     * panic() because there should be no code path that ever sets
     * both flags.
     */
    if ((flags&TCL_TRACE_RESULT_DYNAMIC) && (flags&TCL_TRACE_RESULT_OBJECT)) {
	panic("bad result flag combination");
    }

    /*
a2322 5
    flagMask = TCL_TRACE_READS | TCL_TRACE_WRITES | TCL_TRACE_UNSETS | 
	TCL_TRACE_ARRAY | TCL_TRACE_RESULT_DYNAMIC | TCL_TRACE_RESULT_OBJECT;
#ifndef TCL_REMOVE_OBSOLETE_TRACES
    flagMask |= TCL_TRACE_OLD_STYLE;
#endif
d2324 7
a2330 5
    tracePtr->traceProc		= proc;
    tracePtr->clientData	= clientData;
    tracePtr->flags		= flags & flagMask;
    tracePtr->nextPtr		= varPtr->tracePtr;
    varPtr->tracePtr		= tracePtr;
d2355 1
a2355 1
    CONST char *varName;	/* Name of variable; may end with "(index)"
d2389 2
a2390 2
    CONST char *part1;		/* Name of variable or array. */
    CONST char *part2;		/* Name of element within array;  NULL means
d2406 3
a2408 8
    int flagMask;
    
    /*
     * Set up a mask to mask out the parts of the flags that we are not
     * interested in now.
     */
    flagMask = TCL_GLOBAL_ONLY | TCL_NAMESPACE_ONLY;
    varPtr = TclLookupVar(interp, part1, part2, flags & flagMask,
d2415 2
a2416 11

    /*
     * Set up a mask to mask out the parts of the flags that we are not
     * interested in now.
     */
    flagMask = TCL_TRACE_READS | TCL_TRACE_WRITES | TCL_TRACE_UNSETS |
	TCL_TRACE_ARRAY | TCL_TRACE_RESULT_DYNAMIC | TCL_TRACE_RESULT_OBJECT; 
#ifndef TCL_REMOVE_OBSOLETE_TRACES
    flagMask |= TCL_TRACE_OLD_STYLE;
#endif
    flags &= flagMask;
d2431 1
a2431 1
     * processed by CallVarTraces.
d2434 1
a2434 1
    for (activePtr = iPtr->activeVarTracePtr;  activePtr != NULL;
d2445 1
a2445 1
    Tcl_EventuallyFree((ClientData) tracePtr, TCL_DYNAMIC);
d2486 1
a2486 1
    CONST char *varName;	/* Name of variable;  may end with "(index)"
d2521 2
a2522 2
    CONST char *part1;		/* Name of variable or array. */
    CONST char *part2;		/* Name of element within array;  NULL means
d2592 1
a2592 1
    register int i, flags = TCL_LEAVE_ERR_MSG;
d2595 2
a2596 3
    if (objc < 1) {
	Tcl_WrongNumArgs(interp, 1, objv,
		"?-nocomplain? ?--? ?varName varName ...?");
a2597 6
    } else if (objc == 1) {
	/*
	 * Do nothing if no arguments supplied, so as to match
	 * command documentation.
	 */
	return TCL_OK;
d2599 5
a2603 25

    /*
     * Simple, restrictive argument parsing.  The only options are --
     * and -nocomplain (which must come first and be given exactly to
     * be an option).
     */
    i = 1;
    name = TclGetString(objv[i]);
    if (name[0] == '-') {
 	if (strcmp("-nocomplain", name) == 0) {
	    i++;
 	    if (i == objc) {
		return TCL_OK;
	    }
 	    flags = 0;
 	    name = TclGetString(objv[i]);
 	}
 	if (strcmp("--", name) == 0) {
 	    i++;
 	}
    }

    for (; i < objc;  i++) {
	if ((TclObjUnsetVar2(interp, objv[i], NULL, flags) != TCL_OK)
		&& (flags == TCL_LEAVE_ERR_MSG)) {
a2634 3
    Var *varPtr, *arrayPtr;
    char *part1;

a2643 1

d2650 3
a2652 16
	varPtr = TclObjLookupVar(interp, objv[1], NULL, TCL_LEAVE_ERR_MSG,
		"set", /*createPart1*/ 1, /*createPart2*/ 1, &arrayPtr);
	part1 = TclGetString(objv[1]);
	if (varPtr == NULL) {
	    return TCL_ERROR;
	}
	for (i = 2;  i < objc;  i++) {	  
	    /*
	     * Note that we do not need to increase the refCount of
	     * the Var pointers: should a trace delete the variable,
	     * the return value of TclPtrSetVar will be NULL, and we 
	     * will not access the variable again.
	     */

	    varValuePtr = TclPtrSetVar(interp, varPtr, arrayPtr, part1, NULL, 
	            objv[i], (TCL_APPEND_VALUE | TCL_LEAVE_ERR_MSG));
a2690 2
    Var *varPtr, *arrayPtr;
    char *part1;
d2697 2
a2698 1
	newValuePtr = Tcl_ObjGetVar2(interp, objv[1], (Tcl_Obj *) NULL, 0);
d2705 3
a2707 3
	    varValuePtr = Tcl_NewObj();
	    newValuePtr = Tcl_ObjSetVar2(interp, objv[1], NULL, varValuePtr,
		    TCL_LEAVE_ERR_MSG);
d2709 1
a2709 1
		Tcl_DecrRefCount(varValuePtr); /* free unneeded object */
d2726 1
a2726 27

	/*
	 * Use the TCL_TRACE_READS flag to ensure that if we have an
	 * array with no elements set yet, but with a read trace on it,
	 * we will create the variable and get read traces triggered.
	 * Note that you have to protect the variable pointers around
	 * the TclPtrGetVar call to insure that they remain valid 
	 * even if the variable was undefined and unused.
	 */

	varPtr = TclObjLookupVar(interp, objv[1], NULL, TCL_LEAVE_ERR_MSG,
		"set", /*createPart1*/ 1, /*createPart2*/ 1, &arrayPtr);
	if (varPtr == NULL) {
	    return TCL_ERROR;
	}
	varPtr->refCount++;
	if (arrayPtr != NULL) {
	    arrayPtr->refCount++;
	}
	part1 = TclGetString(objv[1]);
	varValuePtr = TclPtrGetVar(interp, varPtr, arrayPtr, part1, NULL, 
	        (TCL_TRACE_READS | TCL_LEAVE_ERR_MSG));
	varPtr->refCount--;
	if (arrayPtr != NULL) {
	    arrayPtr->refCount--;
	}

d2730 1
a2730 1
	     * exist or it's an array element.  If it's new, we will try to
d2734 13
a2746 1
	    createVar = (TclIsVarUndefined(varPtr));
d2767 1
a2767 1
	listRepPtr = (List *) varValuePtr->internalRep.twoPtrValue.ptr1;
d2813 2
a2814 2
	newValuePtr = TclPtrSetVar(interp, varPtr, arrayPtr, part1, NULL, 
	            varValuePtr, TCL_LEAVE_ERR_MSG);	
d2864 2
a2865 2
	  ARRAY_STARTSEARCH, ARRAY_STATISTICS, ARRAY_UNSET}; 
    static CONST char *arrayOptions[] = {
d2867 1
a2867 1
	"set", "size", "startsearch", "statistics", "unset", (char *) NULL
d2873 1
a2873 1
    Tcl_Obj *resultPtr, *varNamePtr;
d2875 1
a2875 1
    char *varName;
d2890 1
a2890 1
     * Locate the array variable
d2893 2
a2894 3
    varNamePtr = objv[2];
    varName = TclGetString(varNamePtr);
    varPtr = TclObjLookupVar(interp, varNamePtr, NULL, /*flags*/ 0,
d2897 6
d2908 2
a2909 3
    if (varPtr != NULL && varPtr->tracePtr != NULL
	    && (TclIsVarArray(varPtr) || TclIsVarUndefined(varPtr))) {
	if (TCL_ERROR == CallVarTraces(iPtr, arrayPtr, varPtr, varName, NULL,
d2911 3
a2913 1
		TCL_TRACE_ARRAY), /* leaveErrMsg */ 1)) {
a2917 19
    /*
     * Verify that it is indeed an array variable. This test comes after
     * the traces - the variable may actually become an array as an effect 
     * of said traces.
     */

    notArray = 0;
    if ((varPtr == NULL) || !TclIsVarArray(varPtr)
	    || TclIsVarUndefined(varPtr)) {
	notArray = 1;
    }

    /*
     * We have to wait to get the resultPtr until here because
     * CallVarTraces can affect the result.
     */

    resultPtr = Tcl_GetObjResult(interp);

d2921 1
d2931 2
a2932 1
	    searchPtr = ParseSearchId(interp, varPtr, varName, objv[3]);
d2956 1
d2966 2
a2967 1
	    searchPtr = ParseSearchId(interp, varPtr, varName, objv[3]);
d2998 1
a2998 2
	    Tcl_Obj *namePtr, *valuePtr, *nameLstPtr, *tmpResPtr, **namePtrPtr;
	    int i, count;
a3009 8

	    /*
	     * Store the array names in a new object.
	     */

	    nameLstPtr = Tcl_NewObj();
	    Tcl_IncrRefCount(nameLstPtr);

d3022 1
a3022 1
		result = Tcl_ListObjAppendElement(interp, nameLstPtr,
a3025 1
		    Tcl_DecrRefCount(nameLstPtr);
a3027 1
	    }
a3028 20
	    /*
	     * Make sure the Var structure of the array is not removed by
	     * a trace while we're working.
	     */

	    varPtr->refCount++;

	    /*
	     * Get the array values corresponding to each element name 
	     */

	    tmpResPtr = Tcl_NewObj();
	    result = Tcl_ListObjGetElements(interp, nameLstPtr,
		    &count, &namePtrPtr);
	    if (result != TCL_OK) {
		goto errorInArrayGet;
	    }
	    
	    for (i = 0; i < count; i++) { 
		namePtr = *namePtrPtr++;
d3032 2
a3033 17
		    /*
		     * Some trace played a trick on us; we need to diagnose to
		     * adapt our behaviour: was the array element unset, or did
		     * the modification modify the complete array?
		     */

		    if (TclIsVarArray(varPtr) && !TclIsVarUndefined(varPtr)) {
			/*
			 * The array itself looks OK, the variable was
			 * undefined: forget it.
			 */
			
			continue;
		    } else {
			result = TCL_ERROR;
			goto errorInArrayGet;
		    }
d3035 2
a3036 1
		result = Tcl_ListObjAppendElement(interp, tmpResPtr, namePtr);
d3038 2
a3039 5
		    goto errorInArrayGet;
		}
		result = Tcl_ListObjAppendElement(interp, tmpResPtr, valuePtr);
		if (result != TCL_OK) {
		    goto errorInArrayGet;
a3041 3
	    varPtr->refCount--;
	    Tcl_SetObjResult(interp, tmpResPtr);
	    Tcl_DecrRefCount(nameLstPtr);
a3042 6

	    errorInArrayGet:
	    varPtr->refCount--;
	    Tcl_DecrRefCount(nameLstPtr);
	    Tcl_DecrRefCount(tmpResPtr); /* free unneeded temp result obj */
	    return result;
a3049 7
	    int mode, matched = 0;
	    static CONST char *options[] = {
		"-exact", "-glob", "-regexp", (char *) NULL
	    };
	    enum options { OPT_EXACT, OPT_GLOB, OPT_REGEXP };

	    mode = OPT_GLOB;
d3051 2
a3052 3
	    if ((objc < 3) && (objc > 5)) {
  	        Tcl_WrongNumArgs(interp, 2, objv,
			"arrayName ?mode? ?pattern?");
d3060 1
a3060 7
	    } else if (objc == 5) {
		pattern = Tcl_GetString(objv[4]);
		if (Tcl_GetIndexFromObj(interp, objv[3], options, "option",
			0, &mode) != TCL_OK) {
		    return TCL_ERROR;
		}
	    }       		
d3068 2
a3069 19
		if (objc > 3) {
		    switch ((enum options) mode) {
			case OPT_EXACT:
			    matched = (strcmp(name, pattern) == 0);
			    break;
			case OPT_GLOB:
			    matched = Tcl_StringMatch(name, pattern);
			    break;
			case OPT_REGEXP:
			    matched = Tcl_RegExpMatch(interp, name,
				    pattern);
			    if (matched < 0) {
				return TCL_ERROR;
			    }
			    break;
		    }
		    if (matched == 0) {
			continue;
		    }
d3083 1
d3094 2
a3095 1
	    searchPtr = ParseSearchId(interp, varPtr, varName, objv[3]);
d3181 1
a3181 21

	case ARRAY_STATISTICS: {
	    CONST char *stats;

	    if (notArray) {
		goto error;
	    }

	    stats = Tcl_HashStats(varPtr->value.tablePtr);
	    if (stats != NULL) {
		Tcl_SetStringObj(Tcl_GetObjResult(interp), stats, -1);
		ckfree((void *)stats);
	    } else {
		Tcl_SetResult(interp, "error reading array statistics",
			TCL_STATIC);
		return TCL_ERROR;
	    }
	    break;
        }
	
	case ARRAY_UNSET: {
d3198 1
a3198 1
		if (TclObjUnsetVar2(interp, varNamePtr, NULL, 0)
d3213 1
a3213 1
			    (TclObjUnsetVar2(interp, varNamePtr, name, 0)
d3257 1
a3257 1
    int result, elemLen, i, nameLen;
d3260 8
a3267 5
    varName = Tcl_GetStringFromObj(arrayNameObj, &nameLen);
    p = varName + nameLen - 1;
    if (*p == ')') {
	while (--p >= varName) {
	    if (*p == '(') {
d3271 1
d3275 2
a3276 6
    varPtr = TclObjLookupVar(interp, arrayNameObj, NULL,
	    /*flags*/ TCL_LEAVE_ERR_MSG, /*msg*/ "set", /*createPart1*/ 1,
	    /*createPart2*/ 0, &arrayPtr);
    if (varPtr == NULL) {
	return TCL_ERROR;
    }
a3290 6
	    /*
	     * We needn't worry about traces invalidating arrayPtr:
	     * should that be the case, TclPtrSetVar will return NULL
	     * so that we break out of the loop and return an error.
	     */

d3292 2
a3293 6
		char *part2 = TclGetString(elemPtrs[i]);
		Var *elemVarPtr = TclLookupArrayElement(interp, varName, 
                        part2, TCL_LEAVE_ERR_MSG, "set", 1, 1, varPtr);
		if ((elemVarPtr == NULL) ||
		        (TclPtrSetVar(interp, elemVarPtr, varPtr, varName,
			 part2, elemPtrs[i+1], TCL_LEAVE_ERR_MSG) == NULL)) {
d3323 16
d3351 1
a3351 1
 * ObjMakeUpvar --
d3369 3
a3371 3
ObjMakeUpvar(interp, framePtr, otherP1Ptr, otherP2, otherFlags, myName, myFlags, index)
    Tcl_Interp *interp;		/* Interpreter containing variables. Used
			         * for error messages, too. */
d3374 2
a3375 3
    Tcl_Obj *otherP1Ptr;
    CONST char *otherP2;	/* Two-part name of variable in framePtr. */
    CONST int otherFlags;	/* 0, TCL_GLOBAL_ONLY or TCL_NAMESPACE_ONLY:
d3377 1
a3377 1
    CONST char *myName;		/* Name of variable which will refer to
d3379 1
a3379 1
    CONST int myFlags;		/* 0, TCL_GLOBAL_ONLY or TCL_NAMESPACE_ONLY:
a3380 2
    int index;                  /* If the variable to be linked is an indexed
				 * scalar, this is its index. Otherwise, -1. */
d3382 1
a3382 1
    Interp *iPtr = (Interp *) interp;
d3385 5
a3389 1
    CONST char *errMsg;
d3394 1
a3394 1
     * pointer in the interpreter in order to use TclObjLookupVar.
a3396 1
    varFramePtr = iPtr->varFramePtr;
d3398 1
d3401 1
a3401 1
    otherPtr = TclObjLookupVar(interp, otherP1Ptr, otherP2,
d3405 1
a3405 1
	iPtr->varFramePtr = varFramePtr;
d3411 32
a3442 6
    if (index >= 0) {
	if (!varFramePtr->isProcCallFrame) {
	    panic("ObjMakeUpVar called with an index outside from a proc.\n");
	}
	varPtr = &(varFramePtr->compiledLocals[index]);
    } else {
d3449 7
d3457 31
a3487 9
	if (((otherP2 ? arrayPtr->nsPtr : otherPtr->nsPtr) == NULL) 
	    && ((myFlags & (TCL_GLOBAL_ONLY | TCL_NAMESPACE_ONLY))
		|| (varFramePtr == NULL)
		|| !varFramePtr->isProcCallFrame
		|| (strstr(myName, "::") != NULL))) {
	    Tcl_AppendResult((Tcl_Interp *) iPtr, "bad variable name \"",
		    myName, "\": upvar won't create namespace variable that ",
		    "refers to procedure variable", (char *) NULL);
	    return TCL_ERROR;
d3489 16
a3504 10
	
	/*
	 * Lookup and eventually create the new variable.
	 */
	
	varPtr = TclLookupSimpleVar(interp, myName, myFlags, /*create*/ 1, 
				    &errMsg, &index);
	if (varPtr == NULL) {
	    VarErrMsg(interp, myName, NULL, "create", errMsg);
	    return TCL_ERROR;
d3508 1
a3508 11
    if (varPtr == otherPtr) {
	Tcl_SetResult((Tcl_Interp *) iPtr,
		      "can't upvar from variable to itself", TCL_STATIC);
	return TCL_ERROR;
    }

    if (varPtr->tracePtr != NULL) {
	Tcl_AppendResult((Tcl_Interp *) iPtr, "variable \"", myName,
	        "\" has traces: can't use for upvar", (char *) NULL);
	return TCL_ERROR;
    } else if (!TclIsVarUndefined(varPtr)) {
d3510 1
a3510 1
	 * The variable already existed. Make sure this variable "varPtr"
d3516 5
d3530 1
a3530 1
	} else {
d3534 4
d3572 1
a3572 1
    CONST char *frameName;	/* Name of the frame containing the source
d3574 1
a3574 1
    CONST char *varName;	/* Name of a variable in interp to link to.
d3577 1
a3577 1
    CONST char *localName;	/* Name of link variable. */
d3581 37
a3617 1
    return Tcl_UpVar2(interp, frameName, varName, NULL, localName, flags);
d3645 1
a3645 1
    CONST char *frameName;	/* Name of the frame containing the source
d3647 1
a3647 2
    CONST char *part1;
    CONST char *part2;		/* Two parts of source variable name to
d3649 1
a3649 1
    CONST char *localName;	/* Name of link variable. */
a3654 1
    Tcl_Obj *part1Ptr;
d3656 2
a3657 1
    if (TclGetFrame(interp, frameName, &framePtr) == -1) {
d3660 2
a3661 8

    part1Ptr = Tcl_NewStringObj(part1, -1);
    Tcl_IncrRefCount(part1Ptr);
    result = ObjMakeUpvar(interp, framePtr, part1Ptr, part2, 0,
	    localName, flags, -1);
    TclDecrRefCount(part1Ptr);

    return result;
d3782 1
a3782 1
        if ((*tail == ':') && (tail > varName)) {
d3790 3
a3792 3
	result = ObjMakeUpvar(interp, (CallFrame *) NULL,
		objPtr, NULL, /*otherFlags*/ TCL_GLOBAL_ONLY,
	        /*myName*/ tail, /*myFlags*/ 0, -1);
a3846 6
    Tcl_Obj *varNamePtr;

    if (objc < 2) {
	Tcl_WrongNumArgs(interp, 1, objv, "?name value...? name ?value?");
	return TCL_ERROR;
    }
d3854 2
a3855 3
	varNamePtr = objv[i];
	varName = TclGetString(varNamePtr);
	varPtr = TclObjLookupVar(interp, varNamePtr, NULL,
d3892 2
a3893 2
	    varValuePtr = TclPtrSetVar(interp, varPtr, arrayPtr, varName, NULL,
		    objv[i+1], (TCL_NAMESPACE_ONLY | TCL_LEAVE_ERR_MSG));
d3927 2
a3928 2
	    result = ObjMakeUpvar(interp, (CallFrame *) NULL,
		    /*otherP1*/ varNamePtr, /*otherP2*/ NULL,
d3930 1
a3930 1
		    /*myName*/ tail, /*myFlags*/ 0, -1);
d3964 1
d3966 2
a3967 1
    char *frameSpec, *localName;
d4000 28
a4027 3
	localName = TclGetString(objv[1]);
	result = ObjMakeUpvar(interp, framePtr, /* othervarName */ objv[0],
		NULL, 0, /* myVarName */ localName, /*flags*/ 0, -1);
d4038 1
a4038 33
 * DisposeTraceResult--
 *
 *	This procedure is called to dispose of the result returned from
 *	a trace procedure.  The disposal method appropriate to the type
 *	of result is determined by flags.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	The memory allocated for the trace result may be freed.
 *
 *----------------------------------------------------------------------
 */

void
DisposeTraceResult(flags, result)
    int flags;			/* Indicates type of result to determine
				 * proper disposal method */
    char *result;		/* The result returned from a trace
				 * procedure to be disposed */
{
    if (flags & TCL_TRACE_RESULT_DYNAMIC) {
	ckfree(result);
    } else if (flags & TCL_TRACE_RESULT_OBJECT) {
	Tcl_DecrRefCount((Tcl_Obj *) result);
    }
}

/*
 *----------------------------------------------------------------------
 *
 * CallVarTraces --
d4046 6
a4051 5
 *      Returns TCL_OK to indicate normal operation.  Returns TCL_ERROR
 *      if invocation of a trace procedure indicated an error.  When
 *      TCL_ERROR is returned and leaveErrMsg is true, then the
 *      ::errorInfo variable of iPtr has information about the error
 *      appended to it.
d4060 2
a4061 2
int 
CallVarTraces(iPtr, arrayPtr, varPtr, part1, part2, flags, leaveErrMsg)
d4068 1
a4068 2
    CONST char *part1;
    CONST char *part2;		/* Variable's two-part name. */
a4073 3
    CONST int leaveErrMsg;	/* If true, and one of the traces indicates an
				 * error, then leave an error message and stack
				 * trace information in *iPTr. */
d4077 1
a4077 2
    char *result;
    CONST char *openParen, *p;
a4079 2
    int code = TCL_OK;
    int disposeFlags = 0;
d4087 1
a4087 1
	return code;
a4090 3
    if (arrayPtr != NULL) {
	arrayPtr->refCount++;
    }
a4110 2
		    int offset = (openParen - part1);
		    char *newPart1;
d4113 4
a4116 4
		    newPart1 = Tcl_DStringValue(&nameCopy);
		    newPart1[offset] = 0;
		    part1 = newPart1;
		    part2 = newPart1 + offset + 1;
d4129 4
a4132 4
    active.nextPtr = iPtr->activeVarTracePtr;
    iPtr->activeVarTracePtr = &active;
    Tcl_Preserve((ClientData) iPtr);
    if (arrayPtr != NULL && !(arrayPtr->flags & VAR_TRACE_ACTIVE)) {
a4139 1
	    Tcl_Preserve((ClientData) tracePtr);
d4144 1
a4144 2
		    /* Ignore errors in unset traces */
		    DisposeTraceResult(tracePtr->flags, result);
d4146 1
a4146 2
	            disposeFlags = tracePtr->flags;
		    code = TCL_ERROR;
a4148 4
	    Tcl_Release((ClientData) tracePtr);
	    if (code == TCL_ERROR) {
		goto done;
	    }
a4165 1
	Tcl_Preserve((ClientData) tracePtr);
d4170 1
a4170 2
		/* Ignore errors in unset traces */
		DisposeTraceResult(tracePtr->flags, result);
d4172 1
a4172 2
		disposeFlags = tracePtr->flags;
		code = TCL_ERROR;
a4174 4
	Tcl_Release((ClientData) tracePtr);
	if (code == TCL_ERROR) {
	    goto done;
	}
a4182 27
    if (code == TCL_ERROR) {
	if (leaveErrMsg) {
	    CONST char *type = "";
	    switch (flags&(TCL_TRACE_READS|TCL_TRACE_WRITES|TCL_TRACE_ARRAY)) {
		case TCL_TRACE_READS: {
		    type = "read";
		    break;
		}
		case TCL_TRACE_WRITES: {
		    type = "set";
		    break;
		}
		case TCL_TRACE_ARRAY: {
		    type = "trace array";
		    break;
		}
	    }
	    if (disposeFlags & TCL_TRACE_RESULT_OBJECT) {
		VarErrMsg((Tcl_Interp *) iPtr, part1, part2, type,
			Tcl_GetString((Tcl_Obj *) result));
	    } else {
		VarErrMsg((Tcl_Interp *) iPtr, part1, part2, type, result);
	    }
	}
	DisposeTraceResult(disposeFlags,result);
    }

d4191 2
a4192 3
    iPtr->activeVarTracePtr = active.nextPtr;
    Tcl_Release((ClientData) iPtr);
    return code;
a4235 66
 * SetArraySearchObj --
 *
 *	This function converts the given tcl object into one that
 *	has the "array search" internal type.
 *
 * Results:
 *	TCL_OK if the conversion succeeded, and TCL_ERROR if it failed
 *	(when an error message will be placed in the interpreter's
 *	result.)
 *
 * Side effects:
 *	Updates the internal type and representation of the object to
 *	make this an array-search object.  See the tclArraySearchType
 *	declaration above for details of the internal representation.
 *
 *----------------------------------------------------------------------
 */

static int
SetArraySearchObj(interp, objPtr)
    Tcl_Interp *interp;
    Tcl_Obj *objPtr;
{
    char *string;
    char *end;
    int id;
    size_t offset;

    /*
     * Get the string representation. Make it up-to-date if necessary.
     */

    string = Tcl_GetString(objPtr);

    /*
     * Parse the id into the three parts separated by dashes.
     */
    if ((string[0] != 's') || (string[1] != '-')) {
	syntax:
	Tcl_AppendResult(interp, "illegal search identifier \"", string,
		"\"", (char *) NULL);
	return TCL_ERROR;
    }
    id = strtoul(string+2, &end, 10);
    if ((end == (string+2)) || (*end != '-')) {
	goto syntax;
    }
    /*
     * Can't perform value check in this context, so place reference
     * to place in string to use for the check in the object instead.
     */
    end++;
    offset = end - string;

    if (objPtr->typePtr != NULL && objPtr->typePtr->freeIntRepProc != NULL) {
	objPtr->typePtr->freeIntRepProc(objPtr);
    }
    objPtr->typePtr = &tclArraySearchType;
    objPtr->internalRep.twoPtrValue.ptr1 = (VOID *)(((char *)NULL)+id);
    objPtr->internalRep.twoPtrValue.ptr2 = (VOID *)(((char *)NULL)+offset);
    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
d4238 1
a4238 1
 *	This procedure translates from a tcl object to a pointer to an
d4247 1
a4247 2
 *	The tcl object might have its internal type and representation
 *	modified.
d4253 1
a4253 1
ParseSearchId(interp, varPtr, varName, handleObj)
d4255 2
a4256 2
    CONST Var *varPtr;		/* Array variable search is for. */
    CONST char *varName;	/* Name of array variable that search is
d4258 1
a4258 1
    Tcl_Obj *handleObj;		/* Object containing id of search. Must have
d4263 1
a4263 2
    register char *string;
    register size_t offset;
d4268 1
a4268 1
     * Parse the id.
d4270 5
a4274 1
    if (Tcl_ConvertToType(interp, handleObj, &tclArraySearchType) != TCL_OK) {
d4277 5
a4281 13
    /*
     * Cast is safe, since always came from an int in the first place.
     */
    id = (int)(((char*)handleObj->internalRep.twoPtrValue.ptr1) -
	       ((char*)NULL));
    string = Tcl_GetString(handleObj);
    offset = (((char*)handleObj->internalRep.twoPtrValue.ptr2) -
	      ((char*)NULL));
    /*
     * This test cannot be placed inside the Tcl_Obj machinery, since
     * it is dependent on the variable context.
     */
    if (strcmp(string+offset, varName) != 0) {
a4289 4
     *
     * Note that we cannot store the searchPtr directly in the Tcl_Obj
     * as that would run into trouble when DeleteSearches() was called
     * so we must scan this list every time.
d4377 1
a4377 1
	flags |= TCL_GLOBAL_ONLY;
a4380 3
    if (Tcl_InterpDeleted(interp)) {
	flags |= TCL_INTERP_DESTROYED;
    }
d4414 1
a4414 1
	 * table is deleted). Note that we give CallVarTraces the variable's
d4423 2
a4424 2
	    CallVarTraces(iPtr, (Var *) NULL, varPtr, Tcl_GetString(objPtr),
		    NULL, flags, /* leaveErrMsg */ 0);
d4430 1
a4430 1
		Tcl_EventuallyFree((ClientData) tracePtr, TCL_DYNAMIC);
d4432 1
a4432 1
	    for (activePtr = iPtr->activeVarTracePtr; activePtr != NULL;
d4549 2
a4550 2
	    CallVarTraces(iPtr, (Var *) NULL, varPtr, varPtr->name, NULL,
		    flags, /* leaveErrMsg */ 0);
d4554 1
a4554 1
		Tcl_EventuallyFree((ClientData) tracePtr, TCL_DYNAMIC);
d4556 1
a4556 1
	    for (activePtr = iPtr->activeVarTracePtr; activePtr != NULL;
d4610 1
a4610 1
    CONST char *arrayName;	        /* Name of array (used for trace
d4613 1
a4613 1
    int flags;				/* Flags to pass to CallVarTraces:
d4637 2
a4638 3
	    CallVarTraces(iPtr, (Var *) NULL, elPtr, arrayName,
		    Tcl_GetHashKey(varPtr->value.tablePtr, hPtr), flags,
		    /* leaveErrMsg */ 0);
d4642 1
a4642 1
		Tcl_EventuallyFree((ClientData) tracePtr,TCL_DYNAMIC);
d4644 1
a4644 1
	    for (activePtr = iPtr->activeVarTracePtr; activePtr != NULL;
a4652 13

	/*
	 * Even though array elements are not supposed to be namespace
	 * variables, some combinations of [upvar] and [variable] may
	 * create such beasts - see [Bug 604239]. This is necessary to
	 * avoid leaking the corresponding Var struct, and is otherwise
	 * harmless. 
	 */

	if (elPtr->flags & VAR_NAMESPACE_VAR) {
	    elPtr->flags &= ~VAR_NAMESPACE_VAR;
	    elPtr->refCount--;
	}
d4732 2
a4733 3
    CONST char *part1;
    CONST char *part2;		/* Variable's two-part name. */
    CONST char *operation;      /* String describing operation that failed,
d4735 1
a4735 1
    CONST char *reason;         /* String describing why operation failed. */
d4745 1
d4768 1
a4768 1
    CONST char *varName;	/* The variable name */
d4772 1
d4785 2
a4786 2
            0, "access", /*createPart1*/ 0, /*createPart2*/ 1, &arrayPtr);

d4790 10
d4801 2
a4802 112
    if ((varPtr->tracePtr != NULL)
	    || ((arrayPtr != NULL) && (arrayPtr->tracePtr != NULL))) {
	CallVarTraces((Interp *)interp, arrayPtr, varPtr, varName, NULL,
		TCL_TRACE_READS, /* leaveErrMsg */ 0);
    }

    /*
     * If the variable doesn't exist anymore and no-one's using
     * it, then free up the relevant structures and hash table entries.
     */

    if (TclIsVarUndefined(varPtr)) {
	CleanupVar(varPtr, arrayPtr);
	return NULL;
    }

    return varPtr;
}

/*
 *----------------------------------------------------------------------
 *
 * Internal functions for variable name object types --
 *
 *----------------------------------------------------------------------
 */

/* 
 * localVarName -
 *
 * INTERNALREP DEFINITION:
 *   twoPtrValue.ptr1 = pointer to the corresponding Proc 
 *   twoPtrValue.ptr2 = index into locals table
*/

static void 
FreeLocalVarName(objPtr)
    Tcl_Obj *objPtr;
{
    register Proc *procPtr = (Proc *) objPtr->internalRep.twoPtrValue.ptr1;
    procPtr->refCount--;
    if (procPtr->refCount <= 0) {
	TclProcCleanupProc(procPtr);
    }
}

static void
DupLocalVarName(srcPtr, dupPtr)
    Tcl_Obj *srcPtr;
    Tcl_Obj *dupPtr;
{
    register Proc *procPtr = (Proc *) srcPtr->internalRep.twoPtrValue.ptr1;

    dupPtr->internalRep.twoPtrValue.ptr1 = (VOID *) procPtr;
    dupPtr->internalRep.twoPtrValue.ptr2 = srcPtr->internalRep.twoPtrValue.ptr2;
    procPtr->refCount++;
    dupPtr->typePtr = &tclLocalVarNameType;
}

static void
UpdateLocalVarName(objPtr)
    Tcl_Obj *objPtr;
{
    Proc *procPtr = (Proc *) objPtr->internalRep.twoPtrValue.ptr1;
    unsigned int index = (unsigned int) objPtr->internalRep.twoPtrValue.ptr2;
    CompiledLocal *localPtr = procPtr->firstLocalPtr;
    unsigned int nameLen;

    if (localPtr == NULL) {
	goto emptyName;
    }
    while (index--) {
	localPtr = localPtr->nextPtr;
	if (localPtr == NULL) {
	    goto emptyName;
	}
    }

    nameLen = (unsigned int) localPtr->nameLength;
    objPtr->bytes = ckalloc(nameLen + 1);
    memcpy(objPtr->bytes, localPtr->name, nameLen + 1);
    objPtr->length = nameLen;
    return;

    emptyName:
    objPtr->bytes = ckalloc(1);
    *(objPtr->bytes) = '\0';
    objPtr->length = 0;
}

/* 
 * nsVarName -
 *
 * INTERNALREP DEFINITION:
 *   twoPtrValue.ptr1: pointer to the namespace containing the 
 *                     reference.
 *   twoPtrValue.ptr2: pointer to the corresponding Var 
*/

static void 
FreeNsVarName(objPtr)
    Tcl_Obj *objPtr;
{
    register Var *varPtr = (Var *) objPtr->internalRep.twoPtrValue.ptr2;

    varPtr->refCount--;
    if (TclIsVarUndefined(varPtr) && (varPtr->refCount <= 0)) {
	if (TclIsVarLink(varPtr)) {
	    Var *linkPtr = varPtr->value.linkPtr;
	    linkPtr->refCount--;
	    if (TclIsVarUndefined(linkPtr) && (linkPtr->refCount <= 0)) {
		CleanupVar(linkPtr, (Var *) NULL);
d4804 1
a4805 1
	CleanupVar(varPtr, NULL);
d4807 1
a4807 97
}

static void
DupNsVarName(srcPtr, dupPtr)
    Tcl_Obj *srcPtr;
    Tcl_Obj *dupPtr;
{
    Namespace *nsPtr = (Namespace *) srcPtr->internalRep.twoPtrValue.ptr1;
    register Var *varPtr = (Var *) srcPtr->internalRep.twoPtrValue.ptr2;

    dupPtr->internalRep.twoPtrValue.ptr1 =  (VOID *) nsPtr;
    dupPtr->internalRep.twoPtrValue.ptr2 = (VOID *) varPtr;
    varPtr->refCount++;
    dupPtr->typePtr = &tclNsVarNameType;
}

/* 
 * parsedVarName -
 *
 * INTERNALREP DEFINITION:
 *   twoPtrValue.ptr1 = pointer to the array name Tcl_Obj
 *                      (NULL if scalar)
 *   twoPtrValue.ptr2 = pointer to the element name string
 *                      (owned by this Tcl_Obj), or NULL if 
 *                      it is a scalar variable
 */

static void 
FreeParsedVarName(objPtr)
    Tcl_Obj *objPtr;
{
    register Tcl_Obj *arrayPtr =
	    (Tcl_Obj *) objPtr->internalRep.twoPtrValue.ptr1;
    register char *elem = (char *) objPtr->internalRep.twoPtrValue.ptr2;
    
    if (arrayPtr != NULL) {
	TclDecrRefCount(arrayPtr);
	ckfree(elem);
    }
}

static void
DupParsedVarName(srcPtr, dupPtr)
    Tcl_Obj *srcPtr;
    Tcl_Obj *dupPtr;
{
    register Tcl_Obj *arrayPtr =
	    (Tcl_Obj *) srcPtr->internalRep.twoPtrValue.ptr1;
    register char *elem = (char *) srcPtr->internalRep.twoPtrValue.ptr2;
    char *elemCopy;
    unsigned int elemLen;

    if (arrayPtr != NULL) {
	Tcl_IncrRefCount(arrayPtr);
	elemLen = strlen(elem);
	elemCopy = ckalloc(elemLen+1);
	memcpy(elemCopy, elem, elemLen);
	*(elemCopy + elemLen) = '\0';
	elem = elemCopy;
    }

    dupPtr->internalRep.twoPtrValue.ptr1 = (VOID *) arrayPtr;
    dupPtr->internalRep.twoPtrValue.ptr2 = (VOID *) elem;
    dupPtr->typePtr = &tclParsedVarNameType;
}

static void
UpdateParsedVarName(objPtr)
    Tcl_Obj *objPtr;
{
    Tcl_Obj *arrayPtr = (Tcl_Obj *) objPtr->internalRep.twoPtrValue.ptr1;
    char *part2 = (char *) objPtr->internalRep.twoPtrValue.ptr2;
    char *part1, *p;
    int len1, len2, totalLen;

    if (arrayPtr == NULL) {
	/*
	 * This is a parsed scalar name: what is it
	 * doing here?
	 */
	panic("ERROR: scalar parsedVarName without a string rep.\n");
    }
    part1 = Tcl_GetStringFromObj(arrayPtr, &len1);
    len2 = strlen(part2);
	
    totalLen = len1 + len2 + 2;
    p = ckalloc((unsigned int) totalLen + 1);
    objPtr->bytes = p;
    objPtr->length = totalLen;

    memcpy(p, part1, (unsigned int) len1);
    p += len1;
    *p++ = '(';
    memcpy(p, part2, (unsigned int) len2);
    p += len2;
    *p++ = ')';
    *p   = '\0';
@


1.1.1.4
log
@import tcl 8.4.1
@
text
@d18 1
a18 1
 * RCS: @@(#) $Id: tclVar.c,v 1.68 2002/10/17 17:41:44 dgp Exp $
d3096 1
a3096 1
	    if ((objc < 3) || (objc > 5)) {
@


