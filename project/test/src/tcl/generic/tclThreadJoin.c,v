head	1.3;
access;
symbols
	sid-snapshot-20180601:1.3
	sid-snapshot-20180501:1.3
	sid-snapshot-20180401:1.3
	sid-snapshot-20180301:1.3
	sid-snapshot-20180201:1.3
	sid-snapshot-20180101:1.3
	sid-snapshot-20171201:1.3
	sid-snapshot-20171101:1.3
	sid-snapshot-20171001:1.3
	sid-snapshot-20170901:1.3
	sid-snapshot-20170801:1.3
	sid-snapshot-20170701:1.3
	sid-snapshot-20170601:1.3
	sid-snapshot-20170501:1.3
	sid-snapshot-20170401:1.3
	sid-snapshot-20170301:1.3
	sid-snapshot-20170201:1.3
	sid-snapshot-20170101:1.3
	sid-snapshot-20161201:1.3
	sid-snapshot-20161101:1.3
	sid-snapshot-20160901:1.3
	sid-snapshot-20160801:1.3
	sid-snapshot-20160701:1.3
	sid-snapshot-20160601:1.3
	sid-snapshot-20160501:1.3
	sid-snapshot-20160401:1.3
	sid-snapshot-20160301:1.3
	sid-snapshot-20160201:1.3
	sid-snapshot-20160101:1.3
	sid-snapshot-20151201:1.3
	sid-snapshot-20151101:1.3
	sid-snapshot-20151001:1.3
	sid-snapshot-20150901:1.3
	sid-snapshot-20150801:1.3
	sid-snapshot-20150701:1.3
	sid-snapshot-20150601:1.3
	sid-snapshot-20150501:1.3
	sid-snapshot-20150401:1.3
	sid-snapshot-20150301:1.3
	sid-snapshot-20150201:1.3
	sid-snapshot-20150101:1.3
	sid-snapshot-20141201:1.3
	sid-snapshot-20141101:1.3
	sid-snapshot-20141001:1.3
	sid-snapshot-20140901:1.3
	sid-snapshot-20140801:1.3
	sid-snapshot-20140701:1.3
	sid-snapshot-20140601:1.3
	sid-snapshot-20140501:1.3
	sid-snapshot-20140401:1.3
	sid-snapshot-20140301:1.3
	sid-snapshot-20140201:1.3
	sid-snapshot-20140101:1.3
	sid-snapshot-20131201:1.3
	sid-snapshot-20131101:1.3
	sid-snapshot-20131001:1.3
	sid-snapshot-20130901:1.3
	sid-snapshot-20130801:1.3
	sid-snapshot-20130701:1.3
	sid-snapshot-20130601:1.3
	insight_7_6-2013-04-10-branchpoint:1.3
	gdb_7_6-branch:1.3.0.60
	sid-snapshot-20130501:1.3
	sid-snapshot-20130401:1.3
	sid-snapshot-20130301:1.3
	sid-snapshot-20130201:1.3
	sid-snapshot-20130101:1.3
	sid-snapshot-20121201:1.3
	sid-snapshot-20121101:1.3
	sid-snapshot-20121001:1.3
	sid-snapshot-20120901:1.3
	gdb_7_5-branch:1.3.0.58
	sid-snapshot-20120801:1.3
	sid-snapshot-20120701:1.3
	sid-snapshot-20120601:1.3
	sid-snapshot-20120501:1.3
	sid-snapshot-20120401:1.3
	gdb_7_4-branch:1.3.0.56
	sid-snapshot-20120301:1.3
	sid-snapshot-20120201:1.3
	sid-snapshot-20120101:1.3
	sid-snapshot-20111201:1.3
	sid-snapshot-20111101:1.3
	sid-snapshot-20111001:1.3
	sid-snapshot-20110901:1.3
	gdb_7_3-branch:1.3.0.54
	sid-snapshot-20110801:1.3
	sid-snapshot-20110701:1.3
	sid-snapshot-20110601:1.3
	sid-snapshot-20110501:1.3
	sid-snapshot-20110401:1.3
	sid-snapshot-20110301:1.3
	sid-snapshot-20110201:1.3
	sid-snapshot-20110101:1.3
	sid-snapshot-20101201:1.3
	sid-snapshot-20101101:1.3
	sid-snapshot-20101001:1.3
	sid-snapshot-20100901:1.3
	sid-snapshot-20100801:1.3
	sid-snapshot-20100701:1.3
	sid-snapshot-20100601:1.3
	sid-snapshot-20100501:1.3
	sid-snapshot-20100401:1.3
	sid-snapshot-20100301:1.3
	gdb_7_1-branch:1.3.0.52
	gdb_7_0-branch:1.3.0.50
	sid-snapshot-20100201:1.3
	sid-snapshot-20100101:1.3
	sid-snapshot-20091201:1.3
	sid-snapshot-20091101:1.3
	sid-snapshot-20091001:1.3
	arc-sim-20090309:1.3
	sid-snapshot-20090901:1.3
	sid-snapshot-20090801:1.3
	sid-snapshot-20090701:1.3
	sid-snapshot-20090601:1.3
	sid-snapshot-20090501:1.3
	kevinb-pre-tcl8_5_7_merge:1.3
	sid-snapshot-20090401:1.3
	arc-insight_6_8-branch:1.3.0.48
	arc-insight_6_8-branchpoint:1.3
	insight_6_8-branch:1.3.0.46
	insight_6_8-branchpoint:1.3
	sid-snapshot-20090301:1.3
	sid-snapshot-20090201:1.3
	sid-snapshot-20090101:1.3
	sid-snapshot-20081201:1.3
	sid-snapshot-20081101:1.3
	sid-snapshot-20081001:1.3
	sid-snapshot-20080901:1.3
	sid-snapshot-20080801:1.3
	sid-snapshot-20080701:1.3
	sid-snapshot-20080601:1.3
	sid-snapshot-20080501:1.3
	sid-snapshot-20080403:1.3
	sid-snapshot-20080401:1.3
	gdb_6_8-branch:1.3.0.44
	sid-snapshot-20080301:1.3
	sid-snapshot-20080201:1.3
	sid-snapshot-20080101:1.3
	sid-snapshot-20071201:1.3
	sid-snapshot-20071101:1.3
	sid-snapshot-20071001:1.3
	insight_6_6-20070208-release:1.3
	gdb_6_6-branch:1.3.0.42
	gdb_6_6-2006-11-15-branchpoint:1.3
	insight_6_5-20061003-release:1.3
	gdb_6_5-branch:1.3.0.40
	gdb_6_5-2006-05-14-branchpoint:1.3
	readline_5_1-import-branch:1.3.0.38
	readline_5_1-import-branchpoint:1.3
	gdb_6_4-branch:1.3.0.36
	gdb_6_4-2005-11-01-branchpoint:1.3
	msnyder-tracepoint-checkpoint-branch:1.3.0.34
	msnyder-tracepoint-checkpoint-branchpoint:1.3
	gdb_6_1-2004-04-05-release:1.3
	ezannoni_pie-20040323-branch:1.3.0.32
	ezannoni_pie-20040323-branchpoint:1.3
	cagney_tramp-20040321-mergepoint:1.3
	cagney_tramp-20040309-branch:1.3.0.30
	cagney_tramp-20040309-branchpoint:1.3
	gdb_6_1-branch:1.3.0.28
	gdb_6_1-2004-03-01-gmt-branchpoint:1.3
	drow-cplus-merge-20040208:1.3
	carlton_dictionary-20040126-merge:1.3
	drow-cplus-merge-20040113:1.3
	drow-cplus-merge-20031224:1.3
	drow-cplus-merge-20031220:1.3
	carlton_dictionary-20031215-merge:1.3
	drow-cplus-merge-20031214:1.3
	carlton-dictionary-20031111-merge:1.3
	gdb_6_0-2003-10-04-release:1.3
	carlton_dictionary-20030917-merge:1.3
	ezannoni_pie-20030916-branchpoint:1.3
	ezannoni_pie-20030916-branch:1.3.0.26
	gdb_5_1-2001-07-29-branch:1.3.0.24
	cagney_x86i386-20030821-branch:1.3.0.22
	cagney_x86i386-20030821-branchpoint:1.3
	carlton_dictionary-20030805-merge:1.3
	carlton_dictionary-20030627-merge:1.3
	gdb_6_0-branch:1.3.0.20
	gdb_6_0-2003-06-23-branchpoint:1.3
	cagney_convert-20030606-branch:1.3.0.18
	cagney_convert-20030606-branchpoint:1.3
	cagney_writestrings-20030508-branch:1.3.0.16
	cagney_writestrings-20030508-branchpoint:1.3
	carlton_dictionary-20030523-merge:1.3
	cagney_fileio-20030521-branch:1.3.0.14
	cagney_fileio-20030521-branchpoint:1.3
	carlton_dictionary-20030430-merge:1.3
	carlton_dictionary-20030416-merge:1.3
	cagney_frameaddr-20030409-mergepoint:1.3
	cagney_frameaddr-20030403-branchpoint:1.3
	cagney_frameaddr-20030403-branch:1.3.0.12
	cagney_framebase-20030330-mergepoint:1.3
	cagney_framebase-20030326-branch:1.3.0.10
	cagney_framebase-20030326-branchpoint:1.3
	cagney_lazyid-20030317-branch:1.3.0.8
	cagney_lazyid-20030317-branchpoint:1.3
	offbyone-20030313-branch:1.3.0.6
	offbyone-20030313-branchpoint:1.3
	carlton_dictionary-20030305-merge:1.3
	cagney_offbyone-20030303-branch:1.3.0.4
	cagney_offbyone-20030303-branchpoint:1.3
	carlton_dictionary-20030207-merge:1.3
	interps-20030202-branch:1.3.0.2
	interps-20030202-branchpoint:1.3
	TCL8_4_1:1.1.1.1
	cagney-unwind-20030108-branch:1.2.0.2
	cagney-unwind-20030108-branchpoint:1.2
	carlton_dictionary-20021223-merge:1.2
	TCL_8_4_1:1.1.1.1
	carlton_dictionary-20021115-merge:1.1
	kseitz_interps-20021105-merge:1.1
	kseitz_interps-20021103-merge:1.1
	drow-cplus-merge-20021020:1.1
	drow-cplus-merge-20021025:1.1
	carlton_dictionary-20021025-merge:1.1
	carlton_dictionary-20021011-merge:1.1
	drow-cplus-branch:1.1.0.6
	drow-cplus-branchpoint:1.1
	kseitz_interps-20020528-branch:1.1.0.4
	kseitz_interps-20020930-merge:1.1
	carlton_dictionary-branch:1.1.0.2
	carlton_dictionary-20020927-merge:1.1.1.1
	tcltk840-20020924-branch:1.1.1.1.0.2
	tcltk840-20020924-branchpoint:1.1.1.1
	TCL_8_4_0:1.1.1.1
	NET:1.1.1;
locks; strict;
comment	@ * @;


1.3
date	2003.01.21.19.40.06;	author hunt;	state Exp;
branches
	1.3.48.1;
next	1.2;

1.2
date	2002.11.26.19.47.53;	author hunt;	state Exp;
branches;
next	1.1;

1.1
date	2002.09.24.19.56.08;	author kseitz;	state Exp;
branches
	1.1.1.1
	1.1.2.1
	1.1.4.1
	1.1.6.1;
next	;

1.3.48.1
date	2009.09.11.04.45.59;	author amylaar;	state Exp;
branches;
next	;

1.1.1.1
date	2002.09.24.19.56.08;	author kseitz;	state Exp;
branches
	1.1.1.1.2.1;
next	;

1.1.1.1.2.1
date	2002.09.27.21.49.05;	author kseitz;	state Exp;
branches;
next	;

1.1.2.1
date	2002.09.27.20.03.34;	author carlton;	state Exp;
branches;
next	1.1.2.2;

1.1.2.2
date	2002.10.11.22.23.10;	author carlton;	state Exp;
branches;
next	1.1.2.3;

1.1.2.3
date	2002.12.23.19.40.25;	author carlton;	state Exp;
branches;
next	1.1.2.4;

1.1.2.4
date	2003.02.07.19.18.14;	author carlton;	state Exp;
branches;
next	;

1.1.4.1
date	2002.10.01.00.46.55;	author kseitz;	state Exp;
branches;
next	;

1.1.6.1
date	2003.12.14.20.28.44;	author drow;	state Exp;
branches;
next	;


desc
@@


1.3
log
@Updated to tcl 8.4.1
@
text
@/* 
 * tclThreadJoin.c --
 *
 *	This file implements a platform independent emulation layer for
 *	the handling of joinable threads. The Mac and Windows platforms
 *	use this code to provide the functionality of joining threads.
 *	This code is currently not necessary on Unix.
 *
 * Copyright (c) 2000 by Scriptics Corporation
 *
 * See the file "license.terms" for information on usage and redistribution
 * of this file, and for a DISCLAIMER OF ALL WARRANTIES.
 *
 * RCS: @@(#) $Id: tclThreadJoin.c,v 1.4 2002/04/24 20:35:40 hobbs Exp $
 */

#include "tclInt.h"

#if defined(WIN32) || defined(MAC_TCL)

/* The information about each joinable thread is remembered in a
 * structure as defined below.
 */

typedef struct JoinableThread {
  Tcl_ThreadId  id;                     /* The id of the joinable thread */
  int           result;                 /* A place for the result after the
					 * demise of the thread */
  int           done;                   /* Boolean flag. Initialized to 0
					 * and set to 1 after the exit of
					 * the thread. This allows a thread
					 * requesting a join to detect when
					 * waiting is not necessary. */
  int           waitedUpon;             /* Boolean flag. Initialized to 0
					 * and set to 1 by the thread waiting
					 * for this one via Tcl_JoinThread.
					 * Used to lock any other thread
					 * trying to wait on this one.
					 */
  Tcl_Mutex     threadMutex;            /* The mutex used to serialize access
					 * to this structure. */
  Tcl_Condition cond;                   /* This is the condition a thread has
					 * to wait upon to get notified of the
					 * end of the described thread. It is
					 * signaled indirectly by
					 * Tcl_ExitThread. */
  struct JoinableThread* nextThreadPtr; /* Reference to the next thread in the
					 * list of joinable threads */
} JoinableThread;

/* The following variable is used to maintain the global list of all
 * joinable threads. Usage by a thread is allowed only if the
 * thread acquired the 'joinMutex'.
 */

TCL_DECLARE_MUTEX(joinMutex)

static JoinableThread* firstThreadPtr;



/*
 *----------------------------------------------------------------------
 *
 * TclJoinThread --
 *
 *	This procedure waits for the exit of the thread with the specified
 *	id and returns its result.
 *
 * Results:
 *	A standard tcl result signaling the overall success/failure of the
 *	operation and an integer result delivered by the thread which was
 *	waited upon.
 *
 * Side effects:
 *	Deallocates the memory allocated by TclRememberJoinableThread.
 *	Removes the data associated to the thread waited upon from the
 *	list of joinable threads.
 *
 *----------------------------------------------------------------------
 */

int
TclJoinThread(id, result)
    Tcl_ThreadId id;     /* The id of the thread to wait upon. */
    int*         result; /* Reference to a location for the result
			  * of the thread we are waiting upon. */
{
    /* Steps done here:
     * i.    Acquire the joinMutex and search for the thread.
     * ii.   Error out if it could not be found.
     * iii.  If found, switch from exclusive access to the list to exclusive
     *       access to the thread structure.
     * iv.   Error out if some other is already waiting.
     * v.    Skip the waiting part of the thread is already done.
     * vi.   Wait for the thread to exit, mark it as waited upon too.
     * vii.  Get the result form the structure, 
     * viii. switch to exclusive access of the list,
     * ix.   remove the structure from the list,
     * x.    then switch back to exclusive access to the structure
     * xi.   and delete it.
     */

    JoinableThread* threadPtr;

    Tcl_MutexLock (&joinMutex);

    for (threadPtr = firstThreadPtr;
	 (threadPtr != (JoinableThread*) NULL) && (threadPtr->id != id);
	 threadPtr = threadPtr->nextThreadPtr)
        /* empty body */
      ;

    if (threadPtr == (JoinableThread*) NULL) {
        /* Thread not found. Either not joinable, or already waited
	 * upon and exited. Whatever, an error is in order.
	 */

      Tcl_MutexUnlock (&joinMutex);
      return TCL_ERROR;
    }

    /* [1] If we don't lock the structure before giving up exclusive access
     * to the list some other thread just completing its wait on the same
     * thread can delete the structure from under us, leaving us with a
     * dangling pointer.
     */

    Tcl_MutexLock   (&threadPtr->threadMutex);
    Tcl_MutexUnlock (&joinMutex);

    /* [2] Now that we have the structure mutex any other thread that just
     * tries to delete structure will wait at location [3] until we are
     * done with the structure. And in that case we are done with it
     * rather quickly as 'waitedUpon' will be set and we will have to
     * error out.
     */

    if (threadPtr->waitedUpon) {
        Tcl_MutexUnlock (&threadPtr->threadMutex);
	return TCL_ERROR;
    }

    /* We are waiting now, let other threads recognize this
     */

    threadPtr->waitedUpon = 1;

    while (!threadPtr->done) {
      Tcl_ConditionWait (&threadPtr->cond, &threadPtr->threadMutex, NULL);
    }

    /* We have to release the structure before trying to access the list
     * again or we can run into deadlock with a thread at [1] (see above)
     * because of us holding the structure and the other holding the list.
     * There is no problem with dangling pointers here as 'waitedUpon == 1'
     * is still valid and any other thread will error out and not come to
     * this place. IOW, the fact that we are here also means that no other
     * thread came here before us and is able to delete the structure.
     */

    Tcl_MutexUnlock (&threadPtr->threadMutex);
    Tcl_MutexLock   (&joinMutex);

    /* We have to search the list again as its structure may (may, almost
     * certainly) have changed while we were waiting. Especially now is the
     * time to compute the predecessor in the list. Any earlier result can
     * be dangling by now.
     */

    if (firstThreadPtr == threadPtr) {
        firstThreadPtr = threadPtr->nextThreadPtr;
    } else {
        JoinableThread* prevThreadPtr;

	for (prevThreadPtr = firstThreadPtr;
	     prevThreadPtr->nextThreadPtr != threadPtr;
	     prevThreadPtr = prevThreadPtr->nextThreadPtr)
	    /* empty body */
	  ;

	prevThreadPtr->nextThreadPtr = threadPtr->nextThreadPtr;
    }

    Tcl_MutexUnlock (&joinMutex);

    /* [3] Now that the structure is not part of the list anymore no other
     * thread can acquire its mutex from now on. But it is possible that
     * another thread is still holding the mutex though, see location [2].
     * So we have to acquire the mutex one more time to wait for that thread
     * to finish. We can (and have to) release the mutex immediately.
     */

    Tcl_MutexLock   (&threadPtr->threadMutex);
    Tcl_MutexUnlock (&threadPtr->threadMutex);

    /* Copy the result to us, finalize the synchronisation objects, then
     * free the structure and return.
     */

    *result = threadPtr->result;

    Tcl_ConditionFinalize (&threadPtr->cond);
    Tcl_MutexFinalize (&threadPtr->threadMutex);
    ckfree ((VOID*) threadPtr);

    return TCL_OK;
}

/*
 *----------------------------------------------------------------------
 *
 * TclRememberJoinableThread --
 *
 *	This procedure remebers a thread as joinable. Only a call to
 *	TclJoinThread will remove the structre created (and initialized)
 *	here. IOW, not waiting upon a joinable thread will cause memory
 *	leaks.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Allocates memory, adds it to the global list of all joinable
 *	threads.
 *
 *----------------------------------------------------------------------
 */

VOID
TclRememberJoinableThread(id)
    Tcl_ThreadId id; /* The thread to remember as joinable */
{
    JoinableThread* threadPtr;

    threadPtr = (JoinableThread*) ckalloc (sizeof (JoinableThread));
    threadPtr->id          = id;
    threadPtr->done        = 0;
    threadPtr->waitedUpon  = 0;
    threadPtr->threadMutex = (Tcl_Mutex) NULL;
    threadPtr->cond        = (Tcl_Condition) NULL;

    Tcl_MutexLock (&joinMutex);

    threadPtr->nextThreadPtr = firstThreadPtr;
    firstThreadPtr           = threadPtr;

    Tcl_MutexUnlock (&joinMutex);
}

/*
 *----------------------------------------------------------------------
 *
 * TclSignalExitThread --
 *
 *	This procedure signals that the specified thread is done with
 *	its work. If the thread is joinable this signal is propagated
 *	to the thread waiting upon it.
 *
 * Results:
 *	None.
 *
 * Side effects:
 *	Modifies the associated structure to hold the result.
 *
 *----------------------------------------------------------------------
 */

VOID
TclSignalExitThread(id,result)
    Tcl_ThreadId id;     /* Id of the thread signaling its exit */
    int          result; /* The result from the thread */
{
    JoinableThread* threadPtr;

    Tcl_MutexLock (&joinMutex);

    for (threadPtr = firstThreadPtr;
	 (threadPtr != (JoinableThread*) NULL) && (threadPtr->id != id);
	 threadPtr = threadPtr->nextThreadPtr)
        /* empty body */
      ;

    if (threadPtr == (JoinableThread*) NULL) {
        /* Thread not found. Not joinable. No problem, nothing to do.
	 */

        Tcl_MutexUnlock (&joinMutex);
	return;
    }

    /* Switch over the exclusive access from the list to the structure,
     * then store the result, set the flag and notify the waiting thread,
     * provided that it exists. The order of lock/unlock ensures that a
     * thread entering 'TclJoinThread' will not interfere with us.
     */

    Tcl_MutexLock   (&threadPtr->threadMutex);
    Tcl_MutexUnlock (&joinMutex);

    threadPtr->done   = 1;
    threadPtr->result = result;

    if (threadPtr->waitedUpon) {
      Tcl_ConditionNotify (&threadPtr->cond);
    }

    Tcl_MutexUnlock (&threadPtr->threadMutex);
}

#endif /* WIN32 || MAC_TCL */
@


1.3.48.1
log
@gdb/insight for ARCompact (from Richard Stuckey)
@
text
@d14 1
a14 1
 * RCS: @@(#) $Id: tclThreadJoin.c,v 1.3 2003/01/21 19:40:06 hunt Exp $
@


1.2
log
@touched all sources to ease next import
@
text
@d14 1
a14 1
 * RCS: @@(#) $Id: tclThreadJoin.c,v 1.1 2002/09/24 19:56:08 kseitz Exp $
@


1.1
log
@Initial revision
@
text
@d14 1
a14 1
 * RCS: @@(#) $Id: tclThreadJoin.c,v 1.4 2002/04/24 20:35:40 hobbs Exp $
@


1.1.6.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d14 1
a14 1
 * RCS: @@(#) $Id: tclThreadJoin.c,v 1.3 2003/01/21 19:40:06 hunt Exp $
@


1.1.4.1
log
@Merge with kseitz_interps-20020930-merge.
@
text
@d14 1
a14 1
 * RCS: @@(#) $Id: tclThreadJoin.c,v 1.1 2002/09/24 19:56:08 kseitz Exp $
@


1.1.2.1
log
@Merge with mainline; tag is carlton_dictionary-20020927-merge
@
text
@d14 1
a14 1
 * RCS: @@(#) $Id: tclThreadJoin.c,v 1.1.1.1 2002/09/24 19:56:08 kseitz Exp $
@


1.1.2.2
log
@Merge with mainline; merge tag carlton_dictionary-20021011-merge.
@
text
@d14 1
a14 1
 * RCS: @@(#) $Id: tclThreadJoin.c,v 1.1 2002/09/24 19:56:08 kseitz Exp $
@


1.1.2.3
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d14 1
a14 1
 * RCS: @@(#) $Id: tclThreadJoin.c,v 1.1.2.2 2002/10/11 22:23:10 carlton Exp $
@


1.1.2.4
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@d14 1
a14 1
 * RCS: @@(#) $Id: tclThreadJoin.c,v 1.1.2.3 2002/12/23 19:40:25 carlton Exp $
@


1.1.1.1
log
@import tcl 8.4.0
@
text
@@


1.1.1.1.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@d19 1
a19 1
#if defined(WIN32) || defined(MAC_TCL) || defined(__CYGWIN__)
d311 1
a311 1
#endif /* WIN32 || CYGWIN || MAC_TCL */
@

