head	1.4;
access;
symbols
	sid-snapshot-20180601:1.4
	sid-snapshot-20180501:1.4
	sid-snapshot-20180401:1.4
	sid-snapshot-20180301:1.4
	sid-snapshot-20180201:1.4
	sid-snapshot-20180101:1.4
	sid-snapshot-20171201:1.4
	sid-snapshot-20171101:1.4
	sid-snapshot-20171001:1.4
	sid-snapshot-20170901:1.4
	sid-snapshot-20170801:1.4
	sid-snapshot-20170701:1.4
	sid-snapshot-20170601:1.4
	sid-snapshot-20170501:1.4
	sid-snapshot-20170401:1.4
	sid-snapshot-20170301:1.4
	sid-snapshot-20170201:1.4
	sid-snapshot-20170101:1.4
	sid-snapshot-20161201:1.4
	sid-snapshot-20161101:1.4
	sid-snapshot-20160901:1.4
	sid-snapshot-20160801:1.4
	sid-snapshot-20160701:1.4
	sid-snapshot-20160601:1.4
	sid-snapshot-20160501:1.4
	sid-snapshot-20160401:1.4
	sid-snapshot-20160301:1.4
	sid-snapshot-20160201:1.4
	sid-snapshot-20160101:1.4
	sid-snapshot-20151201:1.4
	sid-snapshot-20151101:1.4
	sid-snapshot-20151001:1.4
	sid-snapshot-20150901:1.4
	sid-snapshot-20150801:1.4
	sid-snapshot-20150701:1.4
	sid-snapshot-20150601:1.4
	sid-snapshot-20150501:1.4
	sid-snapshot-20150401:1.4
	sid-snapshot-20150301:1.4
	sid-snapshot-20150201:1.4
	sid-snapshot-20150101:1.4
	sid-snapshot-20141201:1.4
	sid-snapshot-20141101:1.4
	sid-snapshot-20141001:1.4
	sid-snapshot-20140901:1.4
	sid-snapshot-20140801:1.4
	sid-snapshot-20140701:1.4
	sid-snapshot-20140601:1.4
	sid-snapshot-20140501:1.4
	sid-snapshot-20140401:1.4
	sid-snapshot-20140301:1.4
	sid-snapshot-20140201:1.4
	sid-snapshot-20140101:1.4
	sid-snapshot-20131201:1.4
	sid-snapshot-20131101:1.4
	sid-snapshot-20131001:1.4
	sid-snapshot-20130901:1.4
	sid-snapshot-20130801:1.4
	sid-snapshot-20130701:1.4
	sid-snapshot-20130601:1.4
	insight_7_6-2013-04-10-branchpoint:1.4
	gdb_7_6-branch:1.4.0.62
	sid-snapshot-20130501:1.4
	sid-snapshot-20130401:1.4
	sid-snapshot-20130301:1.4
	sid-snapshot-20130201:1.4
	sid-snapshot-20130101:1.4
	sid-snapshot-20121201:1.4
	sid-snapshot-20121101:1.4
	sid-snapshot-20121001:1.4
	sid-snapshot-20120901:1.4
	gdb_7_5-branch:1.4.0.60
	sid-snapshot-20120801:1.4
	sid-snapshot-20120701:1.4
	sid-snapshot-20120601:1.4
	sid-snapshot-20120501:1.4
	sid-snapshot-20120401:1.4
	gdb_7_4-branch:1.4.0.58
	sid-snapshot-20120301:1.4
	sid-snapshot-20120201:1.4
	sid-snapshot-20120101:1.4
	sid-snapshot-20111201:1.4
	sid-snapshot-20111101:1.4
	sid-snapshot-20111001:1.4
	sid-snapshot-20110901:1.4
	gdb_7_3-branch:1.4.0.56
	sid-snapshot-20110801:1.4
	sid-snapshot-20110701:1.4
	sid-snapshot-20110601:1.4
	sid-snapshot-20110501:1.4
	sid-snapshot-20110401:1.4
	sid-snapshot-20110301:1.4
	sid-snapshot-20110201:1.4
	sid-snapshot-20110101:1.4
	sid-snapshot-20101201:1.4
	sid-snapshot-20101101:1.4
	sid-snapshot-20101001:1.4
	sid-snapshot-20100901:1.4
	sid-snapshot-20100801:1.4
	sid-snapshot-20100701:1.4
	sid-snapshot-20100601:1.4
	sid-snapshot-20100501:1.4
	sid-snapshot-20100401:1.4
	sid-snapshot-20100301:1.4
	gdb_7_1-branch:1.4.0.54
	gdb_7_0-branch:1.4.0.52
	sid-snapshot-20100201:1.4
	sid-snapshot-20100101:1.4
	sid-snapshot-20091201:1.4
	sid-snapshot-20091101:1.4
	sid-snapshot-20091001:1.4
	arc-sim-20090309:1.4
	sid-snapshot-20090901:1.4
	sid-snapshot-20090801:1.4
	sid-snapshot-20090701:1.4
	sid-snapshot-20090601:1.4
	sid-snapshot-20090501:1.4
	kevinb-pre-tcl8_5_7_merge:1.4
	sid-snapshot-20090401:1.4
	arc-insight_6_8-branch:1.4.0.50
	arc-insight_6_8-branchpoint:1.4
	insight_6_8-branch:1.4.0.48
	insight_6_8-branchpoint:1.4
	sid-snapshot-20090301:1.4
	sid-snapshot-20090201:1.4
	sid-snapshot-20090101:1.4
	sid-snapshot-20081201:1.4
	sid-snapshot-20081101:1.4
	sid-snapshot-20081001:1.4
	sid-snapshot-20080901:1.4
	sid-snapshot-20080801:1.4
	sid-snapshot-20080701:1.4
	sid-snapshot-20080601:1.4
	sid-snapshot-20080501:1.4
	sid-snapshot-20080403:1.4
	sid-snapshot-20080401:1.4
	gdb_6_8-branch:1.4.0.46
	sid-snapshot-20080301:1.4
	sid-snapshot-20080201:1.4
	sid-snapshot-20080101:1.4
	sid-snapshot-20071201:1.4
	sid-snapshot-20071101:1.4
	sid-snapshot-20071001:1.4
	insight_6_6-20070208-release:1.4
	gdb_6_6-branch:1.4.0.44
	gdb_6_6-2006-11-15-branchpoint:1.4
	insight_6_5-20061003-release:1.4
	gdb_6_5-branch:1.4.0.42
	gdb_6_5-2006-05-14-branchpoint:1.4
	readline_5_1-import-branch:1.4.0.40
	readline_5_1-import-branchpoint:1.4
	gdb_6_4-branch:1.4.0.38
	gdb_6_4-2005-11-01-branchpoint:1.4
	msnyder-tracepoint-checkpoint-branch:1.4.0.36
	msnyder-tracepoint-checkpoint-branchpoint:1.4
	gdb_6_1-2004-04-05-release:1.4
	ezannoni_pie-20040323-branch:1.4.0.34
	ezannoni_pie-20040323-branchpoint:1.4
	cagney_tramp-20040321-mergepoint:1.4
	cagney_tramp-20040309-branch:1.4.0.32
	cagney_tramp-20040309-branchpoint:1.4
	gdb_6_1-branch:1.4.0.30
	gdb_6_1-2004-03-01-gmt-branchpoint:1.4
	drow-cplus-merge-20040208:1.4
	carlton_dictionary-20040126-merge:1.4
	drow-cplus-merge-20040113:1.4
	drow-cplus-merge-20031224:1.4
	drow-cplus-merge-20031220:1.4
	carlton_dictionary-20031215-merge:1.4
	drow-cplus-merge-20031214:1.4
	carlton-dictionary-20031111-merge:1.4
	gdb_6_0-2003-10-04-release:1.4
	carlton_dictionary-20030917-merge:1.4
	ezannoni_pie-20030916-branchpoint:1.4
	ezannoni_pie-20030916-branch:1.4.0.28
	gdb_5_1-2001-07-29-branch:1.4.0.26
	cagney_x86i386-20030821-branch:1.4.0.24
	cagney_x86i386-20030821-branchpoint:1.4
	carlton_dictionary-20030805-merge:1.4
	carlton_dictionary-20030627-merge:1.4
	gdb_6_0-branch:1.4.0.22
	gdb_6_0-2003-06-23-branchpoint:1.4
	cagney_convert-20030606-branch:1.4.0.20
	cagney_convert-20030606-branchpoint:1.4
	cagney_writestrings-20030508-branch:1.4.0.18
	cagney_writestrings-20030508-branchpoint:1.4
	carlton_dictionary-20030523-merge:1.4
	cagney_fileio-20030521-branch:1.4.0.16
	cagney_fileio-20030521-branchpoint:1.4
	carlton_dictionary-20030430-merge:1.4
	carlton_dictionary-20030416-merge:1.4
	cagney_frameaddr-20030409-mergepoint:1.4
	cagney_frameaddr-20030403-branchpoint:1.4
	cagney_frameaddr-20030403-branch:1.4.0.14
	cagney_framebase-20030330-mergepoint:1.4
	cagney_framebase-20030326-branch:1.4.0.12
	cagney_framebase-20030326-branchpoint:1.4
	cagney_lazyid-20030317-branch:1.4.0.10
	cagney_lazyid-20030317-branchpoint:1.4
	offbyone-20030313-branch:1.4.0.8
	offbyone-20030313-branchpoint:1.4
	carlton_dictionary-20030305-merge:1.4
	cagney_offbyone-20030303-branch:1.4.0.6
	cagney_offbyone-20030303-branchpoint:1.4
	carlton_dictionary-20030207-merge:1.4
	interps-20030202-branch:1.4.0.4
	interps-20030202-branchpoint:1.4
	TCL8_4_1:1.1.1.1
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.2
	TCL_8_4_1:1.1.1.1
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.4
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TCL_8_4_0:1.1.1.1
	carlton_dictionary-branch:1.2.0.16
	carlton_dictionary-20020920-branchpoint:1.2
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.14
	gdb_5_3-branch:1.2.0.12
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.10
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.8
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.6
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	cygnus_cvs_20020108_pre:1.2
	TCL_8_3:1.1.1.1
	NET:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.4
date	2002.11.26.19.47.51;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.37.02;	author kseitz;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.09.23.56.04;	author irox;	state Exp;
branches;
next	1.1;

1.1
date	2001.09.09.22.40.54;	author irox;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	2001.09.09.22.40.54;	author irox;	state Exp;
branches;
next	;


desc
@@


1.4
log
@touched all sources to ease next import
@
text
@/*
 * Internal interface definitions, etc., for the reg package
 *
 * Copyright (c) 1998, 1999 Henry Spencer.  All rights reserved.
 * 
 * Development of this software was funded, in part, by Cray Research Inc.,
 * UUNET Communications Services Inc., Sun Microsystems Inc., and Scriptics
 * Corporation, none of whom are responsible for the results.  The author
 * thanks all of them. 
 * 
 * Redistribution and use in source and binary forms -- with or without
 * modification -- are permitted for any purpose, provided that
 * redistributions in source form retain this entire copyright notice and
 * indicate the origin and nature of any modifications.
 * 
 * I'd appreciate being given credit for this package in the documentation
 * of software which uses it, but that is not a requirement.
 * 
 * THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY
 * AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL
 * HENRY SPENCER BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
 * EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
 * PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS;
 * OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,
 * WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR
 * OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */



/*
 * Environmental customization.  It should not (I hope) be necessary to
 * alter the file you are now reading -- regcustom.h should handle it all,
 * given care here and elsewhere.
 */
#include "regcustom.h"



/*
 * Things that regcustom.h might override.
 */

/* standard header files (NULL is a reasonable indicator for them) */
#ifndef NULL
#include <stdio.h>
#include <stdlib.h>
#include <ctype.h>
#include <limits.h>
#include <string.h>
#endif

/* assertions */
#ifndef assert
#	ifndef REG_DEBUG
#	define	NDEBUG		/* no assertions */
#	endif
#include <assert.h>
#endif

/* voids */
#ifndef VOID
#define	VOID	void			/* for function return values */
#endif
#ifndef DISCARD
#define	DISCARD	VOID			/* for throwing values away */
#endif
#ifndef PVOID
#define	PVOID	VOID *			/* generic pointer */
#endif
#ifndef VS
#define	VS(x)	((PVOID)(x))		/* cast something to generic ptr */
#endif
#ifndef NOPARMS
#define	NOPARMS	VOID			/* for empty parm lists */
#endif

/* const */
#ifndef CONST
#define	CONST	const			/* for old compilers, might be empty */
#endif

/* function-pointer declarator */
#ifndef FUNCPTR
#if __STDC__ >= 1
#define	FUNCPTR(name, args)	(*name)args
#else
#define	FUNCPTR(name, args)	(*name)()
#endif
#endif

/* memory allocation */
#ifndef MALLOC
#define	MALLOC(n)	malloc(n)
#endif
#ifndef REALLOC
#define	REALLOC(p, n)	realloc(VS(p), n)
#endif
#ifndef FREE
#define	FREE(p)		free(VS(p))
#endif

/* want size of a char in bits, and max value in bounded quantifiers */
#ifndef CHAR_BIT
#include <limits.h>
#endif
#ifndef _POSIX2_RE_DUP_MAX
#define	_POSIX2_RE_DUP_MAX	255	/* normally from <limits.h> */
#endif



/*
 * misc
 */

#define	NOTREACHED	0
#define	xxx		1

#define	DUPMAX	_POSIX2_RE_DUP_MAX
#define	INFINITY	(DUPMAX+1)

#define	REMAGIC	0xfed7		/* magic number for main struct */



/*
 * debugging facilities
 */
#ifdef REG_DEBUG
/* FDEBUG does finite-state tracing */
#define	FDEBUG(arglist)	{ if (v->eflags&REG_FTRACE) printf arglist; }
/* MDEBUG does higher-level tracing */
#define	MDEBUG(arglist)	{ if (v->eflags&REG_MTRACE) printf arglist; }
#else
#define	FDEBUG(arglist)	{}
#define	MDEBUG(arglist)	{}
#endif



/*
 * bitmap manipulation
 */
#define	UBITS	(CHAR_BIT * sizeof(unsigned))
#define	BSET(uv, sn)	((uv)[(sn)/UBITS] |= (unsigned)1 << ((sn)%UBITS))
#define	ISBSET(uv, sn)	((uv)[(sn)/UBITS] & ((unsigned)1 << ((sn)%UBITS)))



/*
 * We dissect a chr into byts for colormap table indexing.  Here we define
 * a byt, which will be the same as a byte on most machines...  The exact
 * size of a byt is not critical, but about 8 bits is good, and extraction
 * of 8-bit chunks is sometimes especially fast.
 */
#ifndef BYTBITS
#define	BYTBITS	8		/* bits in a byt */
#endif
#define	BYTTAB	(1<<BYTBITS)	/* size of table with one entry per byt value */
#define	BYTMASK	(BYTTAB-1)	/* bit mask for byt */
#define	NBYTS	((CHRBITS+BYTBITS-1)/BYTBITS)
/* the definition of GETCOLOR(), below, assumes NBYTS <= 4 */



/*
 * As soon as possible, we map chrs into equivalence classes -- "colors" --
 * which are of much more manageable number.
 */
typedef short color;		/* colors of characters */
typedef int pcolor;		/* what color promotes to */
#define	COLORLESS	(-1)	/* impossible color */
#define	WHITE		0	/* default color, parent of all others */



/*
 * A colormap is a tree -- more precisely, a DAG -- indexed at each level
 * by a byt of the chr, to map the chr to a color efficiently.  Because
 * lower sections of the tree can be shared, it can exploit the usual
 * sparseness of such a mapping table.  The tree is always NBYTS levels
 * deep (in the past it was shallower during construction but was "filled"
 * to full depth at the end of that); areas that are unaltered as yet point
 * to "fill blocks" which are entirely WHITE in color.
 */

/* the tree itself */
struct colors {
	color ccolor[BYTTAB];
};
struct ptrs {
	union tree *pptr[BYTTAB];
};
union tree {
	struct colors colors;
	struct ptrs ptrs;
};
#define	tcolor	colors.ccolor
#define	tptr	ptrs.pptr

/* internal per-color structure for the color machinery */
struct colordesc {
	uchr nchrs;		/* number of chars of this color */
	color sub;		/* open subcolor (if any); free chain ptr */
#		define	NOSUB	COLORLESS
	struct arc *arcs;	/* color chain */
	int flags;
#		define	FREECOL	01	/* currently free */
#		define	PSEUDO	02	/* pseudocolor, no real chars */
#	define	UNUSEDCOLOR(cd)	((cd)->flags&FREECOL)
	union tree *block;	/* block of solid color, if any */
};

/* the color map itself */
struct colormap {
	int magic;
#		define	CMMAGIC	0x876
	struct vars *v;			/* for compile error reporting */
	size_t ncds;			/* number of colordescs */
	size_t max;			/* highest in use */
	color free;			/* beginning of free chain (if non-0) */
	struct colordesc *cd;
#	define	CDEND(cm)	(&(cm)->cd[(cm)->max + 1])
#		define	NINLINECDS	((size_t)10)
	struct colordesc cdspace[NINLINECDS];
	union tree tree[NBYTS];		/* tree top, plus fill blocks */
};

/* optimization magic to do fast chr->color mapping */
#define	B0(c)	((c) & BYTMASK)
#define	B1(c)	(((c)>>BYTBITS) & BYTMASK)
#define	B2(c)	(((c)>>(2*BYTBITS)) & BYTMASK)
#define	B3(c)	(((c)>>(3*BYTBITS)) & BYTMASK)
#if NBYTS == 1
#define	GETCOLOR(cm, c)	((cm)->tree->tcolor[B0(c)])
#endif
/* beware, for NBYTS>1, GETCOLOR() is unsafe -- 2nd arg used repeatedly */
#if NBYTS == 2
#define	GETCOLOR(cm, c)	((cm)->tree->tptr[B1(c)]->tcolor[B0(c)])
#endif
#if NBYTS == 4
#define	GETCOLOR(cm, c)	((cm)->tree->tptr[B3(c)]->tptr[B2(c)]->tptr[B1(c)]->tcolor[B0(c)])
#endif



/*
 * Interface definitions for locale-interface functions in locale.c.
 * Multi-character collating elements (MCCEs) cause most of the trouble.
 */
struct cvec {
	int nchrs;		/* number of chrs */
	int chrspace;		/* number of chrs possible */
	chr *chrs;		/* pointer to vector of chrs */
	int nranges;		/* number of ranges (chr pairs) */
	int rangespace;		/* number of chrs possible */
	chr *ranges;		/* pointer to vector of chr pairs */
	int nmcces;		/* number of MCCEs */
	int mccespace;		/* number of MCCEs possible */
	int nmccechrs;		/* number of chrs used for MCCEs */
	chr *mcces[1];		/* pointers to 0-terminated MCCEs */
				/* and both batches of chrs are on the end */
};

/* caution:  this value cannot be changed easily */
#define	MAXMCCE	2		/* length of longest MCCE */



/*
 * definitions for NFA internal representation
 *
 * Having a "from" pointer within each arc may seem redundant, but it
 * saves a lot of hassle.
 */
struct state;

struct arc {
	int type;
#		define	ARCFREE	'\0'
	color co;
	struct state *from;	/* where it's from (and contained within) */
	struct state *to;	/* where it's to */
	struct arc *outchain;	/* *from's outs chain or free chain */
#	define	freechain	outchain
	struct arc *inchain;	/* *to's ins chain */
	struct arc *colorchain;	/* color's arc chain */
};

struct arcbatch {		/* for bulk allocation of arcs */
	struct arcbatch *next;
#	define	ABSIZE	10
	struct arc a[ABSIZE];
};

struct state {
	int no;
#		define	FREESTATE	(-1)
	char flag;		/* marks special states */
	int nins;		/* number of inarcs */
	struct arc *ins;	/* chain of inarcs */
	int nouts;		/* number of outarcs */
	struct arc *outs;	/* chain of outarcs */
	struct arc *free;	/* chain of free arcs */
	struct state *tmp;	/* temporary for traversal algorithms */
	struct state *next;	/* chain for traversing all */
	struct state *prev;	/* back chain */
	struct arcbatch oas;	/* first arcbatch, avoid malloc in easy case */
	int noas;		/* number of arcs used in first arcbatch */
};

struct nfa {
	struct state *pre;	/* pre-initial state */
	struct state *init;	/* initial state */
	struct state *final;	/* final state */
	struct state *post;	/* post-final state */
	int nstates;		/* for numbering states */
	struct state *states;	/* state-chain header */
	struct state *slast;	/* tail of the chain */
	struct state *free;	/* free list */
	struct colormap *cm;	/* the color map */
	color bos[2];		/* colors, if any, assigned to BOS and BOL */
	color eos[2];		/* colors, if any, assigned to EOS and EOL */
	struct vars *v;		/* simplifies compile error reporting */
	struct nfa *parent;	/* parent NFA, if any */
};



/*
 * definitions for compacted NFA
 */
struct carc {
	color co;		/* COLORLESS is list terminator */
	int to;			/* state number */
};

struct cnfa {
	int nstates;		/* number of states */
	int ncolors;		/* number of colors */
	int flags;
#		define	HASLACONS	01	/* uses lookahead constraints */
	int pre;		/* setup state number */
	int post;		/* teardown state number */
	color bos[2];		/* colors, if any, assigned to BOS and BOL */
	color eos[2];		/* colors, if any, assigned to EOS and EOL */
	struct carc **states;	/* vector of pointers to outarc lists */
	struct carc *arcs;	/* the area for the lists */
};
#define	ZAPCNFA(cnfa)	((cnfa).nstates = 0)
#define	NULLCNFA(cnfa)	((cnfa).nstates == 0)



/*
 * subexpression tree
 */
struct subre {
	char op;		/* '|', '.' (concat), 'b' (backref), '(', '=' */
	char flags;
#		define	LONGER	01	/* prefers longer match */
#		define	SHORTER	02	/* prefers shorter match */
#		define	MIXED	04	/* mixed preference below */
#		define	CAP	010	/* capturing parens below */
#		define	BACKR	020	/* back reference below */
#		define	INUSE	0100	/* in use in final tree */
#		define	LOCAL	03	/* bits which may not propagate up */
#		define	LMIX(f)	((f)<<2)	/* LONGER -> MIXED */
#		define	SMIX(f)	((f)<<1)	/* SHORTER -> MIXED */
#		define	UP(f)	(((f)&~LOCAL) | (LMIX(f) & SMIX(f) & MIXED))
#		define	MESSY(f)	((f)&(MIXED|CAP|BACKR))
#		define	PREF(f)	((f)&LOCAL)
#		define	PREF2(f1, f2)	((PREF(f1) != 0) ? PREF(f1) : PREF(f2))
#		define	COMBINE(f1, f2)	(UP((f1)|(f2)) | PREF2(f1, f2))
	short retry;		/* index into retry memory */
	int subno;		/* subexpression number (for 'b' and '(') */
	short min;		/* min repetitions, for backref only */
	short max;		/* max repetitions, for backref only */
	struct subre *left;	/* left child, if any (also freelist chain) */
	struct subre *right;	/* right child, if any */
	struct state *begin;	/* outarcs from here... */
	struct state *end;	/* ...ending in inarcs here */
	struct cnfa cnfa;	/* compacted NFA, if any */
	struct subre *chain;	/* for bookkeeping and error cleanup */
};



/*
 * table of function pointers for generic manipulation functions
 * A regex_t's re_fns points to one of these.
 */
struct fns {
	VOID FUNCPTR(free, (regex_t *));
};



/*
 * the insides of a regex_t, hidden behind a void *
 */
struct guts {
	int magic;
#		define	GUTSMAGIC	0xfed9
	int cflags;		/* copy of compile flags */
	long info;		/* copy of re_info */
	size_t nsub;		/* copy of re_nsub */
	struct subre *tree;
	struct cnfa search;	/* for fast preliminary search */
	int ntree;
	struct colormap cmap;
	int FUNCPTR(compare, (CONST chr *, CONST chr *, size_t));
	struct subre *lacons;	/* lookahead-constraint vector */
	int nlacons;		/* size of lacons */
};
@


1.3
log
@touched all sources to ease next import
@
text
@@


1.2
log
@touched all Tcl files to ease next import.
@
text
@@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Tcl 8.3 upgrade
@
text
@@
