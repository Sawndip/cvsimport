head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	sid-snapshot-20130901:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	insight_7_6-2013-04-10-branchpoint:1.5
	gdb_7_6-branch:1.5.0.60
	sid-snapshot-20130501:1.5
	sid-snapshot-20130401:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	sid-snapshot-20121101:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-branch:1.5.0.58
	sid-snapshot-20120801:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	sid-snapshot-20120401:1.5
	gdb_7_4-branch:1.5.0.56
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	sid-snapshot-20120101:1.5
	sid-snapshot-20111201:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	sid-snapshot-20110901:1.5
	gdb_7_3-branch:1.5.0.54
	sid-snapshot-20110801:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	sid-snapshot-20101201:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.52
	gdb_7_0-branch:1.5.0.50
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	sid-snapshot-20091001:1.5
	arc-sim-20090309:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	sid-snapshot-20090701:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	kevinb-pre-tcl8_5_7_merge:1.5
	sid-snapshot-20090401:1.5
	arc-insight_6_8-branch:1.5.0.48
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.46
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	sid-snapshot-20081201:1.5
	sid-snapshot-20081101:1.5
	sid-snapshot-20081001:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	sid-snapshot-20080701:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-branch:1.5.0.44
	sid-snapshot-20080301:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	sid-snapshot-20071001:1.5
	insight_6_6-20070208-release:1.5
	gdb_6_6-branch:1.5.0.42
	gdb_6_6-2006-11-15-branchpoint:1.5
	insight_6_5-20061003-release:1.5
	gdb_6_5-branch:1.5.0.40
	gdb_6_5-2006-05-14-branchpoint:1.5
	readline_5_1-import-branch:1.5.0.38
	readline_5_1-import-branchpoint:1.5
	gdb_6_4-branch:1.5.0.36
	gdb_6_4-2005-11-01-branchpoint:1.5
	msnyder-tracepoint-checkpoint-branch:1.5.0.34
	msnyder-tracepoint-checkpoint-branchpoint:1.5
	gdb_6_1-2004-04-05-release:1.5
	ezannoni_pie-20040323-branch:1.5.0.32
	ezannoni_pie-20040323-branchpoint:1.5
	cagney_tramp-20040321-mergepoint:1.5
	cagney_tramp-20040309-branch:1.5.0.30
	cagney_tramp-20040309-branchpoint:1.5
	gdb_6_1-branch:1.5.0.28
	gdb_6_1-2004-03-01-gmt-branchpoint:1.5
	drow-cplus-merge-20040208:1.5
	carlton_dictionary-20040126-merge:1.5
	drow-cplus-merge-20040113:1.5
	drow-cplus-merge-20031224:1.5
	drow-cplus-merge-20031220:1.5
	carlton_dictionary-20031215-merge:1.5
	drow-cplus-merge-20031214:1.5
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.26
	gdb_5_1-2001-07-29-branch:1.5.0.24
	cagney_x86i386-20030821-branch:1.5.0.22
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.20
	gdb_6_0-2003-06-23-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.18
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.16
	cagney_writestrings-20030508-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.14
	cagney_fileio-20030521-branchpoint:1.5
	carlton_dictionary-20030430-merge:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.12
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.10
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.8
	cagney_lazyid-20030317-branchpoint:1.5
	offbyone-20030313-branch:1.5.0.6
	offbyone-20030313-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.4
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.2
	interps-20030202-branchpoint:1.5
	TCL8_4_1:1.1.1.3
	cagney-unwind-20030108-branch:1.4.0.2
	cagney-unwind-20030108-branchpoint:1.4
	carlton_dictionary-20021223-merge:1.4
	gdb_5_3-2002-12-12-release:1.2
	TCL_8_4_1:1.1.1.3
	carlton_dictionary-20021115-merge:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.4
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	tcltk840-20020924-branch:1.3.0.2
	tcltk840-20020924-branchpoint:1.3
	TCL_8_4_0:1.1.1.2
	carlton_dictionary-branch:1.2.0.16
	carlton_dictionary-20020920-branchpoint:1.2
	sid-20020905-branchpoint:1.2
	sid-20020905-branch:1.2.0.14
	gdb_5_3-branch:1.2.0.12
	gdb_5_3-2002-09-04-branchpoint:1.2
	kseitz_interps-20020829-merge:1.2
	cagney_sysregs-20020825-branch:1.2.0.10
	cagney_sysregs-20020825-branchpoint:1.2
	readline_4_3-import-branch:1.2.0.8
	readline_4_3-import-branchpoint:1.2
	gdb_5_2_1-2002-07-23-release:1.2
	kseitz_interps-20020528-branch:1.2.0.6
	kseitz_interps-20020528-branchpoint:1.2
	cagney_regbuf-20020515-branch:1.2.0.4
	cagney_regbuf-20020515-branchpoint:1.2
	gdb_5_2-2002-04-29-release:1.2
	gdb_5_2-branch:1.2.0.2
	gdb_5_2-2002-03-03-branchpoint:1.2
	cygnus_cvs_20020108_pre:1.2
	TCL_8_3:1.1.1.1
	NET:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.5
date	2003.01.21.19.40.04;	author hunt;	state Exp;
branches;
next	1.4;

1.4
date	2002.11.26.19.47.53;	author hunt;	state Exp;
branches;
next	1.3;

1.3
date	2002.09.24.18.37.02;	author kseitz;	state Exp;
branches
	1.3.2.1
	1.3.4.1;
next	1.2;

1.2
date	2001.09.09.23.56.05;	author irox;	state Exp;
branches
	1.2.16.1;
next	1.1;

1.1
date	2001.09.09.22.40.56;	author irox;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2002.09.27.21.49.04;	author kseitz;	state Exp;
branches;
next	;

1.3.4.1
date	2003.12.14.20.28.44;	author drow;	state Exp;
branches;
next	;

1.2.16.1
date	2002.12.23.19.40.21;	author carlton;	state Exp;
branches;
next	1.2.16.2;

1.2.16.2
date	2003.02.07.19.18.12;	author carlton;	state Exp;
branches;
next	;

1.1.1.1
date	2001.09.09.22.40.56;	author irox;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2002.09.24.19.56.13;	author kseitz;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	2002.11.26.20.00.36;	author hunt;	state Exp;
branches;
next	;


desc
@@


1.5
log
@Updated to tcl 8.4.1
@
text
@# tclInt.decls --
#
#	This file contains the declarations for all unsupported
#	functions that are exported by the Tcl library.  This file
#	is used to generate the tclIntDecls.h, tclIntPlatDecls.h,
#	tclIntStub.c, tclPlatStub.c, tclCompileDecls.h and tclCompileStub.c
#	files
#
# Copyright (c) 1998-1999 by Scriptics Corporation.
# Copyright (c) 2001 by Kevin B. Kenny.  All rights reserved.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
# 
# RCS: @@(#) $Id: tclInt.decls,v 1.56 2002/10/09 11:54:09 das Exp $

library tcl

# Define the unsupported generic interfaces.

interface tclInt

# Declare each of the functions in the unsupported internal Tcl
# interface.  These interfaces are allowed to changed between versions.
# Use at your own risk.  Note that the position of functions should not
# be changed between versions to avoid gratuitous incompatibilities.

# Replaced by Tcl_FSAccess in 8.4:
#declare 0 generic {
#    int TclAccess(CONST char *path, int mode)
#}
declare 1 generic {
    int TclAccessDeleteProc(TclAccessProc_ *proc)
}
declare 2 generic {
    int TclAccessInsertProc(TclAccessProc_ *proc)
}
declare 3 generic {
    void TclAllocateFreeObjects(void)
}
# Replaced by TclpChdir in 8.1:
#  declare 4 generic {   
#      int TclChdir(Tcl_Interp *interp, char *dirName)
#  }
declare 5 {unix win} {
    int TclCleanupChildren(Tcl_Interp *interp, int numPids, Tcl_Pid *pidPtr,
	    Tcl_Channel errorChan)
}
declare 6 generic {
    void TclCleanupCommand(Command *cmdPtr)
}
declare 7 generic {
    int TclCopyAndCollapse(int count, CONST char *src, char *dst)
}
declare 8 generic {
    int TclCopyChannel(Tcl_Interp *interp, Tcl_Channel inChan,
	    Tcl_Channel outChan, int toRead, Tcl_Obj *cmdPtr)
}

# TclCreatePipeline unofficially exported for use by BLT.

declare 9 {unix win} {
    int TclCreatePipeline(Tcl_Interp *interp, int argc, CONST char **argv,
	    Tcl_Pid **pidArrayPtr, TclFile *inPipePtr, TclFile *outPipePtr,
	    TclFile *errFilePtr)
}
declare 10 generic {
    int TclCreateProc(Tcl_Interp *interp, Namespace *nsPtr, 
	    CONST char *procName,
	    Tcl_Obj *argsPtr, Tcl_Obj *bodyPtr, Proc **procPtrPtr)
}
declare 11 generic {
    void TclDeleteCompiledLocalVars(Interp *iPtr, CallFrame *framePtr)
}
declare 12 generic {
    void TclDeleteVars(Interp *iPtr, Tcl_HashTable *tablePtr)
}
declare 13 generic {
    int TclDoGlob(Tcl_Interp *interp, char *separators,
	    Tcl_DString *headPtr, char *tail, Tcl_GlobTypeData *types)
}
declare 14 generic {
    void TclDumpMemoryInfo(FILE *outFile)
}
# Removed in 8.1:
#  declare 15 generic {
#      void TclExpandParseValue(ParseValue *pvPtr, int needed)
#  }
declare 16 generic {
    void TclExprFloatError(Tcl_Interp *interp, double value)
}
# Removed in 8.4
#declare 17 generic {
#    int TclFileAttrsCmd(Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
#}
#declare 18 generic {
#    int TclFileCopyCmd(Tcl_Interp *interp, int argc, char **argv)
#}
#declare 19 generic {
#    int TclFileDeleteCmd(Tcl_Interp *interp, int argc, char **argv)
#}
#declare 20 generic {
#    int TclFileMakeDirsCmd(Tcl_Interp *interp, int argc, char **argv)
#}
#declare 21 generic {
#    int TclFileRenameCmd(Tcl_Interp *interp, int argc, char **argv)
#}
declare 22 generic {
    int TclFindElement(Tcl_Interp *interp, CONST char *listStr,
	    int listLength, CONST char **elementPtr, CONST char **nextPtr,
	    int *sizePtr, int *bracePtr)
}
declare 23 generic {
    Proc * TclFindProc(Interp *iPtr, CONST char *procName)
}
declare 24 generic {
    int TclFormatInt(char *buffer, long n)
}
declare 25 generic {
    void TclFreePackageInfo(Interp *iPtr)
}
# Removed in 8.1:
#  declare 26 generic {	
#      char * TclGetCwd(Tcl_Interp *interp)
#  }
declare 27 generic {
    int TclGetDate(char *p, unsigned long now, long zone,
	    unsigned long *timePtr)
}
declare 28 generic {
    Tcl_Channel TclpGetDefaultStdChannel(int type)
}
# Removed in 8.4b2:
#declare 29 generic {
#    Tcl_Obj * TclGetElementOfIndexedArray(Tcl_Interp *interp,
#	    int localIndex, Tcl_Obj *elemPtr, int flags)
#}
# Replaced by char * TclGetEnv(CONST char *name, Tcl_DString *valuePtr) in 8.1:
#  declare 30 generic {
#      char * TclGetEnv(CONST char *name)
#  }
declare 31 generic {
    char * TclGetExtension(char *name)
}
declare 32 generic {
    int TclGetFrame(Tcl_Interp *interp, CONST char *str,
	    CallFrame **framePtrPtr)
}
declare 33 generic {
    TclCmdProcType TclGetInterpProc(void)
}
declare 34 generic {
    int TclGetIntForIndex(Tcl_Interp *interp, Tcl_Obj *objPtr,
	    int endValue, int *indexPtr)
}
# Removed in 8.4b2:
#declare 35 generic {
#    Tcl_Obj * TclGetIndexedScalar(Tcl_Interp *interp, int localIndex,
#	    int flags)
#}
declare 36 generic {
    int TclGetLong(Tcl_Interp *interp, CONST char *str, long *longPtr)
}
declare 37 generic {
    int TclGetLoadedPackages(Tcl_Interp *interp, char *targetName)
}
declare 38 generic {
    int TclGetNamespaceForQualName(Tcl_Interp *interp, CONST char *qualName,
	    Namespace *cxtNsPtr, int flags, Namespace **nsPtrPtr,
	    Namespace **altNsPtrPtr, Namespace **actualCxtPtrPtr,
	    CONST char **simpleNamePtr)
}
declare 39 generic {
    TclObjCmdProcType TclGetObjInterpProc(void)
}
declare 40 generic {
    int TclGetOpenMode(Tcl_Interp *interp, CONST char *str, int *seekFlagPtr)
}
declare 41 generic {
    Tcl_Command TclGetOriginalCommand(Tcl_Command command)
}
declare 42 generic {
    char * TclpGetUserHome(CONST char *name, Tcl_DString *bufferPtr)
}
declare 43 generic {
    int TclGlobalInvoke(Tcl_Interp *interp, int argc, CONST84 char **argv, int flags)
}
declare 44 generic {
    int TclGuessPackageName(CONST char *fileName, Tcl_DString *bufPtr)
}
declare 45 generic {
    int TclHideUnsafeCommands(Tcl_Interp *interp)
}
declare 46 generic {
    int TclInExit(void)
}
# Removed in 8.4b2:
#declare 47 generic {
#    Tcl_Obj * TclIncrElementOfIndexedArray(Tcl_Interp *interp,
#	    int localIndex, Tcl_Obj *elemPtr, long incrAmount)
#}
# Removed in 8.4b2:
#declare 48 generic {
#    Tcl_Obj * TclIncrIndexedScalar(Tcl_Interp *interp, int localIndex,
#	    long incrAmount)
#}
declare 49 generic {
    Tcl_Obj * TclIncrVar2(Tcl_Interp *interp, Tcl_Obj *part1Ptr,
	    Tcl_Obj *part2Ptr, long incrAmount, int part1NotParsed)
}
declare 50 generic {
    void TclInitCompiledLocals(Tcl_Interp *interp, CallFrame *framePtr,
	    Namespace *nsPtr)
}
declare 51 generic {
    int TclInterpInit(Tcl_Interp *interp)
}
declare 52 generic {
    int TclInvoke(Tcl_Interp *interp, int argc, CONST84 char **argv, int flags)
}
declare 53 generic {
    int TclInvokeObjectCommand(ClientData clientData, Tcl_Interp *interp,
	    int argc, CONST84 char **argv)
}
declare 54 generic {
    int TclInvokeStringCommand(ClientData clientData, Tcl_Interp *interp,
	    int objc, Tcl_Obj *CONST objv[])
}
declare 55 generic {
    Proc * TclIsProc(Command *cmdPtr)
}
# Replaced with TclpLoadFile in 8.1:
#  declare 56 generic {
#      int TclLoadFile(Tcl_Interp *interp, char *fileName, char *sym1,
#  	    char *sym2, Tcl_PackageInitProc **proc1Ptr,
#  	    Tcl_PackageInitProc **proc2Ptr)
#  }
# Signature changed to take a length in 8.1:
#  declare 57 generic {
#      int TclLooksLikeInt(char *p)
#  }
declare 58 generic {
    Var * TclLookupVar(Tcl_Interp *interp, CONST char *part1, CONST char *part2,
	    int flags, CONST char *msg, int createPart1, int createPart2,
	    Var **arrayPtrPtr)
}
# Replaced by Tcl_FSMatchInDirectory in 8.4
#declare 59 generic {
#    int TclpMatchFiles(Tcl_Interp *interp, char *separators,
#	    Tcl_DString *dirPtr, char *pattern, char *tail)
#}
declare 60 generic {
    int TclNeedSpace(CONST char *start, CONST char *end)
}
declare 61 generic {
    Tcl_Obj * TclNewProcBodyObj(Proc *procPtr)
}
declare 62 generic {
    int TclObjCommandComplete(Tcl_Obj *cmdPtr)
}
declare 63 generic {
    int TclObjInterpProc(ClientData clientData, Tcl_Interp *interp,
	    int objc, Tcl_Obj *CONST objv[])
}
declare 64 generic {
    int TclObjInvoke(Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[],
	    int flags)
}
declare 65 generic {
    int TclObjInvokeGlobal(Tcl_Interp *interp, int objc,
	    Tcl_Obj *CONST objv[], int flags)
}
declare 66 generic {
    int TclOpenFileChannelDeleteProc(TclOpenFileChannelProc_ *proc)
}
declare 67 generic {
    int TclOpenFileChannelInsertProc(TclOpenFileChannelProc_ *proc)
}
# Replaced by Tcl_FSAccess in 8.4:
#declare 68 generic {
#    int TclpAccess(CONST char *path, int mode)
#}
declare 69 generic {
    char * TclpAlloc(unsigned int size)
}
#declare 70 generic {
#    int TclpCopyFile(CONST char *source, CONST char *dest)
#}
#declare 71 generic {
#    int TclpCopyDirectory(CONST char *source, CONST char *dest,
#	    Tcl_DString *errorPtr)
#}
#declare 72 generic {
#    int TclpCreateDirectory(CONST char *path)
#}
#declare 73 generic {
#    int TclpDeleteFile(CONST char *path)
#}
declare 74 generic {
    void TclpFree(char *ptr)
}
declare 75 generic {
    unsigned long TclpGetClicks(void)
}
declare 76 generic {
    unsigned long TclpGetSeconds(void)
}

# deprecated
declare 77 generic {
    void TclpGetTime(Tcl_Time *time)
}

declare 78 generic {
    int TclpGetTimeZone(unsigned long time)
}
# Replaced by Tcl_FSListVolumes in 8.4:
#declare 79 generic {
#    int TclpListVolumes(Tcl_Interp *interp)
#}
# Replaced by Tcl_FSOpenFileChannel in 8.4:
#declare 80 generic {
#    Tcl_Channel TclpOpenFileChannel(Tcl_Interp *interp, char *fileName,
#	    char *modeString, int permissions)
#}
declare 81 generic {
    char * TclpRealloc(char *ptr, unsigned int size)
}
#declare 82 generic {
#    int TclpRemoveDirectory(CONST char *path, int recursive,
#	    Tcl_DString *errorPtr)
#}
#declare 83 generic {
#    int TclpRenameFile(CONST char *source, CONST char *dest)
#}
# Removed in 8.1:
#  declare 84 generic {
#      int TclParseBraces(Tcl_Interp *interp, char *str, char **termPtr,
#  	    ParseValue *pvPtr)
#  }
#  declare 85 generic {
#      int TclParseNestedCmd(Tcl_Interp *interp, char *str, int flags,
#  	    char **termPtr, ParseValue *pvPtr)
#  }
#  declare 86 generic {
#      int TclParseQuotes(Tcl_Interp *interp, char *str, int termChar,
#  	    int flags, char **termPtr, ParseValue *pvPtr)
#  }
#  declare 87 generic {
#      void TclPlatformInit(Tcl_Interp *interp)
#  }
declare 88 generic {
    char * TclPrecTraceProc(ClientData clientData, Tcl_Interp *interp,
	    CONST char *name1, CONST char *name2, int flags)
}
declare 89 generic {
    int TclPreventAliasLoop(Tcl_Interp *interp, Tcl_Interp *cmdInterp,
	    Tcl_Command cmd)
}
# Removed in 8.1 (only available if compiled with TCL_COMPILE_DEBUG):
#  declare 90 generic {
#      void TclPrintByteCodeObj(Tcl_Interp *interp, Tcl_Obj *objPtr)
#  }
declare 91 generic {
    void TclProcCleanupProc(Proc *procPtr)
}
declare 92 generic {
    int TclProcCompileProc(Tcl_Interp *interp, Proc *procPtr,
	    Tcl_Obj *bodyPtr, Namespace *nsPtr, CONST char *description,
	    CONST char *procName)
}
declare 93 generic {
    void TclProcDeleteProc(ClientData clientData)
}
declare 94 generic {
    int TclProcInterpProc(ClientData clientData, Tcl_Interp *interp,
	    int argc, CONST84 char **argv)
}
# Replaced by Tcl_FSStat in 8.4:
#declare 95 generic {
#    int TclpStat(CONST char *path, Tcl_StatBuf *buf)
#}
declare 96 generic {
    int TclRenameCommand(Tcl_Interp *interp, char *oldName, char *newName)
}
declare 97 generic {
    void TclResetShadowedCmdRefs(Tcl_Interp *interp, Command *newCmdPtr)
}
declare 98 generic {
    int TclServiceIdle(void)
}
# Removed in 8.4b2:
#declare 99 generic {
#    Tcl_Obj * TclSetElementOfIndexedArray(Tcl_Interp *interp, int localIndex,
#	    Tcl_Obj *elemPtr, Tcl_Obj *objPtr, int flags)
#}
# Removed in 8.4b2:
#declare 100 generic {
#    Tcl_Obj * TclSetIndexedScalar(Tcl_Interp *interp, int localIndex,
#	    Tcl_Obj *objPtr, int flags)
#}
declare 101 generic {
    char * TclSetPreInitScript(char *string)
}
declare 102 generic {
    void TclSetupEnv(Tcl_Interp *interp)
}
declare 103 generic {
    int TclSockGetPort(Tcl_Interp *interp, char *str, char *proto,
	    int *portPtr)
}
declare 104 {unix win} {
    int TclSockMinimumBuffers(int sock, int size)
}
# Replaced by Tcl_FSStat in 8.4:
#declare 105 generic {
#    int TclStat(CONST char *path, Tcl_StatBuf *buf)
#}
declare 106 generic {
    int TclStatDeleteProc(TclStatProc_ *proc)
}
declare 107 generic {
    int TclStatInsertProc(TclStatProc_ *proc)
}
declare 108 generic {
    void TclTeardownNamespace(Namespace *nsPtr)
}
declare 109 generic {
    int TclUpdateReturnInfo(Interp *iPtr)
}
# Removed in 8.1:
#  declare 110 generic {
#      char * TclWordEnd(char *start, char *lastChar, int nested, int *semiPtr)
#  }

# Procedures used in conjunction with Tcl namespaces. They are
# defined here instead of in tcl.decls since they are not stable yet.

declare 111 generic {
    void Tcl_AddInterpResolvers(Tcl_Interp *interp, CONST char *name,
	    Tcl_ResolveCmdProc *cmdProc, Tcl_ResolveVarProc *varProc,
	    Tcl_ResolveCompiledVarProc *compiledVarProc)
}
declare 112 generic {
    int Tcl_AppendExportList(Tcl_Interp *interp, Tcl_Namespace *nsPtr,
	    Tcl_Obj *objPtr)
}
declare 113 generic {
    Tcl_Namespace * Tcl_CreateNamespace(Tcl_Interp *interp, CONST char *name,
	    ClientData clientData, Tcl_NamespaceDeleteProc *deleteProc)
}
declare 114 generic {
    void Tcl_DeleteNamespace(Tcl_Namespace *nsPtr)
}
declare 115 generic {
    int Tcl_Export(Tcl_Interp *interp, Tcl_Namespace *nsPtr,
	    CONST char *pattern, int resetListFirst)
}
declare 116 generic {
    Tcl_Command Tcl_FindCommand(Tcl_Interp *interp, CONST char *name,
	    Tcl_Namespace *contextNsPtr, int flags)
}
declare 117 generic {
    Tcl_Namespace * Tcl_FindNamespace(Tcl_Interp *interp, CONST char *name,
	    Tcl_Namespace *contextNsPtr, int flags)
}
declare 118 generic {
    int Tcl_GetInterpResolvers(Tcl_Interp *interp, CONST char *name,
	    Tcl_ResolverInfo *resInfo)
}
declare 119 generic {
    int Tcl_GetNamespaceResolvers(Tcl_Namespace *namespacePtr,
	    Tcl_ResolverInfo *resInfo)
}
declare 120 generic {
    Tcl_Var Tcl_FindNamespaceVar(Tcl_Interp *interp, CONST char *name,
	    Tcl_Namespace *contextNsPtr, int flags)
}
declare 121 generic {
    int Tcl_ForgetImport(Tcl_Interp *interp, Tcl_Namespace *nsPtr,
	    CONST char *pattern)
}
declare 122 generic {
    Tcl_Command Tcl_GetCommandFromObj(Tcl_Interp *interp, Tcl_Obj *objPtr)
}
declare 123 generic {
    void Tcl_GetCommandFullName(Tcl_Interp *interp, Tcl_Command command,
	    Tcl_Obj *objPtr)
}
declare 124 generic {
    Tcl_Namespace * Tcl_GetCurrentNamespace(Tcl_Interp *interp)
}
declare 125 generic {
    Tcl_Namespace * Tcl_GetGlobalNamespace(Tcl_Interp *interp)
}
declare 126 generic {
    void Tcl_GetVariableFullName(Tcl_Interp *interp, Tcl_Var variable,
	    Tcl_Obj *objPtr)
}
declare 127 generic {
    int Tcl_Import(Tcl_Interp *interp, Tcl_Namespace *nsPtr,
	    CONST char *pattern, int allowOverwrite)
}
declare 128 generic {
    void Tcl_PopCallFrame(Tcl_Interp* interp)
}
declare 129 generic {
    int Tcl_PushCallFrame(Tcl_Interp* interp, Tcl_CallFrame *framePtr,
	    Tcl_Namespace *nsPtr, int isProcCallFrame)
} 
declare 130 generic {
    int Tcl_RemoveInterpResolvers(Tcl_Interp *interp, CONST char *name)
}
declare 131 generic {
    void Tcl_SetNamespaceResolvers(Tcl_Namespace *namespacePtr,
	    Tcl_ResolveCmdProc *cmdProc, Tcl_ResolveVarProc *varProc,
	    Tcl_ResolveCompiledVarProc *compiledVarProc)
}
declare 132 generic {
    int TclpHasSockets(Tcl_Interp *interp)
}
declare 133 generic {
    struct tm *	TclpGetDate(TclpTime_t time, int useGMT)
}
declare 134 generic {
    size_t TclpStrftime(char *s, size_t maxsize, CONST char *format,
	    CONST struct tm *t, int useGMT)
}
declare 135 generic {
    int TclpCheckStackSpace(void)
}

# Added in 8.1:

#declare 137 generic {
#   int TclpChdir(CONST char *dirName)
#}
declare 138 generic {
    CONST84_RETURN char * TclGetEnv(CONST char *name, Tcl_DString *valuePtr)
}
#declare 139 generic {
#    int TclpLoadFile(Tcl_Interp *interp, char *fileName, char *sym1,
#	    char *sym2, Tcl_PackageInitProc **proc1Ptr,
#	    Tcl_PackageInitProc **proc2Ptr, ClientData *clientDataPtr)
#}
declare 140 generic {
    int TclLooksLikeInt(CONST char *bytes, int length)
}
# This is used by TclX, but should otherwise be considered private
declare 141 generic {
    CONST84_RETURN char *TclpGetCwd(Tcl_Interp *interp, Tcl_DString *cwdPtr)
}
declare 142 generic {
    int TclSetByteCodeFromAny(Tcl_Interp *interp, Tcl_Obj *objPtr,
	    CompileHookProc *hookProc, ClientData clientData)
}
declare 143 generic {
    int TclAddLiteralObj(struct CompileEnv *envPtr, Tcl_Obj *objPtr,
	    LiteralEntry **litPtrPtr)
}
declare 144 generic {
    void TclHideLiteral(Tcl_Interp *interp, struct CompileEnv *envPtr,
	    int index)
}
declare 145 generic {
    struct AuxDataType *TclGetAuxDataType(char *typeName)
}

declare 146 generic {
    TclHandle TclHandleCreate(VOID *ptr)
}

declare 147 generic {
    void TclHandleFree(TclHandle handle)
}

declare 148 generic {
    TclHandle TclHandlePreserve(TclHandle handle)
}

declare 149 generic {
    void TclHandleRelease(TclHandle handle)
}

# Added for Tcl 8.2

declare 150 generic {
    int TclRegAbout(Tcl_Interp *interp, Tcl_RegExp re)
}
declare 151 generic {
    void TclRegExpRangeUniChar(Tcl_RegExp re, int index, int *startPtr,
	    int *endPtr)
}

declare 152 generic {
    void TclSetLibraryPath(Tcl_Obj *pathPtr)
}
declare 153 generic {
    Tcl_Obj *TclGetLibraryPath(void)
}

# moved to tclTest.c (static) in 8.3.2/8.4a2
#declare 154 generic {
#    int TclTestChannelCmd(ClientData clientData,
#    Tcl_Interp *interp, int argc, char **argv)
#}
#declare 155 generic {
#    int TclTestChannelEventCmd(ClientData clientData,
#	     Tcl_Interp *interp, int argc, char **argv)
#}

declare 156 generic {
    void TclRegError (Tcl_Interp *interp, CONST char *msg,
	    int status)
}
declare 157 generic {
    Var * TclVarTraceExists (Tcl_Interp *interp, CONST char *varName)
}
declare 158 generic {
    void TclSetStartupScriptFileName(CONST char *filename)
}
declare 159 generic {
    CONST84_RETURN char *TclGetStartupScriptFileName(void)
}
#declare 160 generic {
#    int TclpMatchFilesTypes(Tcl_Interp *interp, char *separators,
#	    Tcl_DString *dirPtr, char *pattern, char *tail, GlobTypeData *types)
#}

# new in 8.3.2/8.4a2
declare 161 generic {
    int TclChannelTransform(Tcl_Interp *interp, Tcl_Channel chan,
	    Tcl_Obj *cmdObjPtr)
}
declare 162 generic {
    void TclChannelEventScriptInvoker(ClientData clientData, int flags)
}

# ALERT: The result of 'TclGetInstructionTable' is actually an
# "InstructionDesc*" but we do not want to describe this structure in
# "tclInt.h". It is described in "tclCompile.h". Use a cast to the
# correct type when calling this procedure.

declare 163 generic {
	void * TclGetInstructionTable (void)
}

# ALERT: The argument of 'TclExpandCodeArray' is actually a
# "CompileEnv*" but we do not want to describe this structure in
# "tclInt.h". It is described in "tclCompile.h".

declare 164 generic {
	void TclExpandCodeArray (void *envPtr)
}

# These functions are vfs aware, but are generally only useful internally.
declare 165 generic {
    void TclpSetInitialEncodings(void)
}

# New function due to TIP #33
declare 166 generic {
    int TclListObjSetElement(Tcl_Interp *interp, Tcl_Obj *listPtr, 
	    int index, Tcl_Obj *valuePtr)
}

# VFS-aware versions of Tcl*StartupScriptFileName (158 and 159 above)
declare 167 generic {
    void TclSetStartupScriptPath(Tcl_Obj *pathPtr)
}
declare 168 generic {
    Tcl_Obj *TclGetStartupScriptPath(void)
}
# variant of Tcl_UtfNCmp that takes n as bytes, not chars
declare 169 generic {
    int TclpUtfNcmp2(CONST char *s1, CONST char *s2, unsigned long n)
}
declare 170 generic {
    int TclCheckInterpTraces (Tcl_Interp *interp, CONST char *command, int numChars, \
            Command *cmdPtr, int result, int traceFlags, int objc, \
	    Tcl_Obj *CONST objv[])
}
declare 171 generic {
    int TclCheckExecutionTraces (Tcl_Interp *interp, CONST char *command, int numChars, \
            Command *cmdPtr, int result, int traceFlags, int objc, \
	    Tcl_Obj *CONST objv[])
}

##############################################################################

# Define the platform specific internal Tcl interface. These functions are
# only available on the designated platform.

interface tclIntPlat

########################
# Mac specific internals

declare 0 mac {
    VOID * TclpSysAlloc(long size, int isBin)
}
declare 1 mac {
    void TclpSysFree(VOID *ptr)
}
declare 2 mac {
    VOID * TclpSysRealloc(VOID *cp, unsigned int size)
}
declare 3 mac {
    void TclpExit(int status)
}

# Prototypes for functions found in the tclMacUtil.c compatability library.

declare 4 mac {
    int FSpGetDefaultDir(FSSpecPtr theSpec)
}
declare 5 mac {
    int FSpSetDefaultDir(FSSpecPtr theSpec)
}
declare 6 mac {
    OSErr FSpFindFolder(short vRefNum, OSType folderType,
	    Boolean createFolder, FSSpec *spec)
}
declare 7 mac {
    void GetGlobalMouseTcl(Point *mouse)
}

# The following routines are utility functions in Tcl.  They are exported
# here because they are needed in Tk.  They are not officially supported,
# however.  The first set are from the MoreFiles package.

declare 8 mac {
    pascal OSErr FSpGetDirectoryIDTcl(CONST FSSpec *spec, long *theDirID,
	    Boolean *isDirectory)
}
declare 9 mac {
    pascal short FSpOpenResFileCompatTcl(CONST FSSpec *spec,
	    SignedByte permission)
}
declare 10 mac {
    pascal void FSpCreateResFileCompatTcl(CONST FSSpec *spec, OSType creator,
	    OSType fileType, ScriptCode scriptTag)
}

# Like the MoreFiles routines these fix problems in the standard
# Mac calls.  These routines are from tclMacUtils.h.

declare 11 mac {
    int FSpLocationFromPath(int length, CONST char *path, FSSpecPtr theSpec)
}
declare 12 mac {
    OSErr FSpPathFromLocation(FSSpecPtr theSpec, int *length,
	    Handle *fullPath)
}

# Prototypes of Mac only internal functions.

declare 13 mac {
    void TclMacExitHandler(void)
}
declare 14 mac {
    void TclMacInitExitToShell(int usePatch)
}
declare 15 mac {
    OSErr TclMacInstallExitToShellPatch(ExitToShellProcPtr newProc)
}
declare 16 mac {
    int TclMacOSErrorToPosixError(int error)
}
declare 17 mac {
    void TclMacRemoveTimer(void *timerToken)
}
declare 18 mac {
    void * TclMacStartTimer(long ms)
}
declare 19 mac {
    int TclMacTimerExpired(void *timerToken)
}
declare 20 mac {
    int TclMacRegisterResourceFork(short fileRef, Tcl_Obj *tokenPtr,
	    int insert)
}	
declare 21 mac {
    short TclMacUnRegisterResourceFork(char *tokenPtr, Tcl_Obj *resultPtr)
}	
declare 22 mac {
    int TclMacCreateEnv(void)
}
declare 23 mac {
    FILE * TclMacFOpenHack(CONST char *path, CONST char *mode)
}
# Replaced in 8.1 by TclpReadLink:
#  declare 24 mac {
#      int TclMacReadlink(char *path, char *buf, int size)
#  }
declare 24 mac {
    char * TclpGetTZName(int isdst)
}
declare 25 mac {
    int TclMacChmod(CONST char *path, int mode)
}
# version of FSpLocationFromPath that doesn't resolve the last path component
declare 26 mac {
    int FSpLLocationFromPath(int length, CONST char *path, FSSpecPtr theSpec)
}

############################
# Windows specific internals

declare 0 win {
    void TclWinConvertError(DWORD errCode)
}
declare 1 win {
    void TclWinConvertWSAError(DWORD errCode)
}
declare 2 win {
    struct servent * TclWinGetServByName(CONST char *nm,
	    CONST char *proto)
}
declare 3 win {
    int TclWinGetSockOpt(SOCKET s, int level, int optname,
	    char FAR * optval, int FAR *optlen)
}
declare 4 win {
    HINSTANCE TclWinGetTclInstance(void)
}
# Removed in 8.1:
#  declare 5 win {
#      HINSTANCE TclWinLoadLibrary(char *name)
#  }
declare 6 win {
    u_short TclWinNToHS(u_short ns)
}
declare 7 win {
    int TclWinSetSockOpt(SOCKET s, int level, int optname,
	    CONST char FAR * optval, int optlen)
}
declare 8 win {
    unsigned long TclpGetPid(Tcl_Pid pid)
}
declare 9 win {
    int TclWinGetPlatformId(void)
}
# Removed in 8.3.1 (for Win32s only)
#declare 10 win {
#    int TclWinSynchSpawn(void *args, int type, void **trans, Tcl_Pid *pidPtr)
#}

# Pipe channel functions

declare 11 win {
    void TclGetAndDetachPids(Tcl_Interp *interp, Tcl_Channel chan)
}
declare 12 win {
    int TclpCloseFile(TclFile file)
}
declare 13 win {
    Tcl_Channel TclpCreateCommandChannel(TclFile readFile,
	    TclFile writeFile, TclFile errorFile, int numPids, Tcl_Pid *pidPtr)
}
declare 14 win {
    int TclpCreatePipe(TclFile *readPipe, TclFile *writePipe)
}
declare 15 win {
    int TclpCreateProcess(Tcl_Interp *interp, int argc, CONST char **argv,
	    TclFile inputFile, TclFile outputFile, TclFile errorFile,
	    Tcl_Pid *pidPtr)
}
# Signature changed in 8.1:
#  declare 16 win {
#      TclFile TclpCreateTempFile(char *contents, Tcl_DString *namePtr)
#  }
#  declare 17 win {
#      char * TclpGetTZName(void)
#  }
declare 18 win {
    TclFile TclpMakeFile(Tcl_Channel channel, int direction)
}
declare 19 win {
    TclFile TclpOpenFile(CONST char *fname, int mode)
}
declare 20 win {
    void TclWinAddProcess(HANDLE hProcess, DWORD id)
}

# removed permanently for 8.4
#declare 21 win {
#    void TclpAsyncMark(Tcl_AsyncHandler async)
#}

# Added in 8.1:
declare 22 win {
    TclFile TclpCreateTempFile(CONST char *contents)
}
declare 23 win {
    char * TclpGetTZName(int isdst)
}
declare 24 win {
    char * TclWinNoBackslash(char *path)
}
declare 25 win {
    TclPlatformType *TclWinGetPlatform(void)
}
declare 26 win {
    void TclWinSetInterfaces(int wide)
}

# Added in Tcl 8.3.3 / 8.4

declare 27 win {
    void TclWinFlushDirtyChannels (void)
}

#########################
# Unix specific internals

# Pipe channel functions

declare 0 unix {
    void TclGetAndDetachPids(Tcl_Interp *interp, Tcl_Channel chan)
}
declare 1 unix {
    int TclpCloseFile(TclFile file)
}
declare 2 unix {
    Tcl_Channel TclpCreateCommandChannel(TclFile readFile,
	    TclFile writeFile, TclFile errorFile, int numPids, Tcl_Pid *pidPtr)
}
declare 3 unix {
    int TclpCreatePipe(TclFile *readPipe, TclFile *writePipe)
}
declare 4 unix {
    int TclpCreateProcess(Tcl_Interp *interp, int argc, CONST char **argv,
	    TclFile inputFile, TclFile outputFile, TclFile errorFile,
	    Tcl_Pid *pidPtr)
}
# Signature changed in 8.1:
#  declare 5 unix {
#      TclFile TclpCreateTempFile(char *contents, Tcl_DString *namePtr)
#  }
declare 6 unix {
    TclFile TclpMakeFile(Tcl_Channel channel, int direction)
}
declare 7 unix {
    TclFile TclpOpenFile(CONST char *fname, int mode)
}
declare 8 unix {
    int TclUnixWaitForFile(int fd, int mask, int timeout)
}

# Added in 8.1:

declare 9 unix {
    TclFile TclpCreateTempFile(CONST char *contents)
}

# Added in 8.4:

declare 10 unix {
    Tcl_DirEntry * TclpReaddir(DIR * dir)
}

declare 11 unix {
    struct tm * TclpLocaltime(time_t * clock)
}

declare 12 unix {
    struct tm * TclpGmtime(time_t * clock)
}

declare 13 unix {
    char * TclpInetNtoa(struct in_addr addr)
}

@


1.4
log
@touched all sources to ease next import
@
text
@d10 2
d15 1
a15 1
# RCS: @@(#) $Id: tclInt.decls,v 1.2.8.2 2000/09/15 16:55:22 spolk Exp $
d28 4
a31 3
declare 0 generic {
    int TclAccess(CONST char *path, int mode)
}
d46 1
a46 1
    int TclCleanupChildren(Tcl_Interp *interp, int numPids, Tcl_Pid *pidPtr, \
d56 1
a56 1
    int TclCopyChannel(Tcl_Interp *interp, Tcl_Channel inChan, \
d63 2
a64 2
    int TclCreatePipeline(Tcl_Interp *interp, int argc, char **argv, \
	    Tcl_Pid **pidArrayPtr, TclFile *inPipePtr, TclFile *outPipePtr, \
d68 2
a69 1
    int TclCreateProc(Tcl_Interp *interp, Namespace *nsPtr, char *procName, \
d79 2
a80 2
    int TclDoGlob(Tcl_Interp *interp, char *separators, \
	    Tcl_DString *headPtr, char *tail, GlobTypeData *types)
d92 16
a107 15
declare 17 generic {
    int TclFileAttrsCmd(Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
}
declare 18 generic {
    int TclFileCopyCmd(Tcl_Interp *interp, int argc, char **argv)
}
declare 19 generic {
    int TclFileDeleteCmd(Tcl_Interp *interp, int argc, char **argv)
}
declare 20 generic {
    int TclFileMakeDirsCmd(Tcl_Interp *interp, int argc, char **argv)
}
declare 21 generic {
    int TclFileRenameCmd(Tcl_Interp *interp, int argc, char **argv)
}
d109 2
a110 2
    int TclFindElement(Tcl_Interp *interp, CONST char *listStr, \
	    int listLength, CONST char **elementPtr, CONST char **nextPtr, \
d114 1
a114 1
    Proc * TclFindProc(Interp *iPtr, char *procName)
d127 1
a127 1
    int TclGetDate(char *p, unsigned long now, long zone, \
d133 5
a137 4
declare 29 generic {
    Tcl_Obj * TclGetElementOfIndexedArray(Tcl_Interp *interp, \
	    int localIndex, Tcl_Obj *elemPtr, int leaveErrorMsg)
}
d146 2
a147 1
    int TclGetFrame(Tcl_Interp *interp, char *str, CallFrame **framePtrPtr)
d153 1
a153 1
    int TclGetIntForIndex(Tcl_Interp *interp, Tcl_Obj *objPtr, \
d156 5
a160 4
declare 35 generic {
    Tcl_Obj * TclGetIndexedScalar(Tcl_Interp *interp, int localIndex, \
	    int leaveErrorMsg)
}
d162 1
a162 1
    int TclGetLong(Tcl_Interp *interp, char *str, long *longPtr)
d168 4
a171 4
    int TclGetNamespaceForQualName(Tcl_Interp *interp, char *qualName, \
	    Namespace *cxtNsPtr, int flags, Namespace **nsPtrPtr, \
	    Namespace **altNsPtrPtr, Namespace **actualCxtPtrPtr, \
	    char **simpleNamePtr)
d177 1
a177 1
    int TclGetOpenMode(Tcl_Interp *interp, char *str, int *seekFlagPtr)
d186 1
a186 1
    int TclGlobalInvoke(Tcl_Interp *interp, int argc, char **argv, int flags)
d189 1
a189 1
    int TclGuessPackageName(char *fileName, Tcl_DString *bufPtr)
d197 10
a206 8
declare 47 generic {
    Tcl_Obj * TclIncrElementOfIndexedArray(Tcl_Interp *interp, \
	    int localIndex, Tcl_Obj *elemPtr, long incrAmount)
}
declare 48 generic {
    Tcl_Obj * TclIncrIndexedScalar(Tcl_Interp *interp, int localIndex, \
	    long incrAmount)
}
d208 1
a208 1
    Tcl_Obj * TclIncrVar2(Tcl_Interp *interp, Tcl_Obj *part1Ptr, \
d212 1
a212 1
    void TclInitCompiledLocals(Tcl_Interp *interp, CallFrame *framePtr, \
d219 1
a219 1
    int TclInvoke(Tcl_Interp *interp, int argc, char **argv, int flags)
d222 2
a223 2
    int TclInvokeObjectCommand(ClientData clientData, Tcl_Interp *interp, \
	    int argc, char **argv)
d226 1
a226 1
    int TclInvokeStringCommand(ClientData clientData, Tcl_Interp *interp, \
d234 2
a235 2
#      int TclLoadFile(Tcl_Interp *interp, char *fileName, char *sym1, \
#  	    char *sym2, Tcl_PackageInitProc **proc1Ptr, \
d243 2
a244 2
    Var * TclLookupVar(Tcl_Interp *interp, char *part1, char *part2, \
	    int flags, char *msg, int createPart1, int createPart2, \
d247 5
a251 4
declare 59 generic {
    int TclpMatchFiles(Tcl_Interp *interp, char *separators, \
	    Tcl_DString *dirPtr, char *pattern, char *tail)
}
d253 1
a253 1
    int TclNeedSpace(char *start, char *end)
d262 1
a262 1
    int TclObjInterpProc(ClientData clientData, Tcl_Interp *interp, \
d266 1
a266 1
    int TclObjInvoke(Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[], \
d270 1
a270 1
    int TclObjInvokeGlobal(Tcl_Interp *interp, int objc, \
d279 4
a282 3
declare 68 generic {
    int TclpAccess(CONST char *path, int mode)
}
d286 13
a298 13
declare 70 generic {
    int TclpCopyFile(CONST char *source, CONST char *dest)
}
declare 71 generic {
    int TclpCopyDirectory(CONST char *source, CONST char *dest, \
	    Tcl_DString *errorPtr)
}
declare 72 generic {
    int TclpCreateDirectory(CONST char *path)
}
declare 73 generic {
    int TclpDeleteFile(CONST char *path)
}
d308 2
d313 1
d317 9
a325 7
declare 79 generic {
    int TclpListVolumes(Tcl_Interp *interp)
}
declare 80 generic {
    Tcl_Channel TclpOpenFileChannel(Tcl_Interp *interp, char *fileName, \
	    char *modeString, int permissions)
}
d329 7
a335 7
declare 82 generic {
    int TclpRemoveDirectory(CONST char *path, int recursive, \
	    Tcl_DString *errorPtr)
}
declare 83 generic {
    int TclpRenameFile(CONST char *source, CONST char *dest)
}
d338 1
a338 1
#      int TclParseBraces(Tcl_Interp *interp, char *str, char **termPtr, \
d342 1
a342 1
#      int TclParseNestedCmd(Tcl_Interp *interp, char *str, int flags, \
d346 1
a346 1
#      int TclParseQuotes(Tcl_Interp *interp, char *str, int termChar, \
d353 2
a354 2
    char * TclPrecTraceProc(ClientData clientData, Tcl_Interp *interp, \
	    char *name1, char *name2, int flags)
d357 1
a357 1
    int TclPreventAliasLoop(Tcl_Interp *interp, Tcl_Interp *cmdInterp, \
d368 2
a369 2
    int TclProcCompileProc(Tcl_Interp *interp, Proc *procPtr, \
	    Tcl_Obj *bodyPtr, Namespace *nsPtr, CONST char *description, \
d376 2
a377 5
    int TclProcInterpProc(ClientData clientData, Tcl_Interp *interp, \
	    int argc, char **argv)
}
declare 95 generic {
    int TclpStat(CONST char *path, struct stat *buf)
d379 4
d392 11
a402 9
declare 99 generic {
    Tcl_Obj * TclSetElementOfIndexedArray(Tcl_Interp *interp, \
	    int localIndex, Tcl_Obj *elemPtr, Tcl_Obj *objPtr, int leaveErrorMsg)
}
declare 100 generic {
    Tcl_Obj * TclSetIndexedScalar(Tcl_Interp *interp, int localIndex, \
	    Tcl_Obj *objPtr, int leaveErrorMsg)
}
declare 101 {unix win} {
d409 1
a409 1
    int TclSockGetPort(Tcl_Interp *interp, char *str, char *proto, \
d415 4
a418 3
declare 105 generic {
    int TclStat(CONST char *path, struct stat *buf)
}
d440 2
a441 2
    void Tcl_AddInterpResolvers(Tcl_Interp *interp, char *name, \
	    Tcl_ResolveCmdProc *cmdProc, Tcl_ResolveVarProc *varProc, \
d445 1
a445 1
    int Tcl_AppendExportList(Tcl_Interp *interp, Tcl_Namespace *nsPtr, \
d449 1
a449 1
    Tcl_Namespace * Tcl_CreateNamespace(Tcl_Interp *interp, char *name, \
d456 2
a457 2
    int Tcl_Export(Tcl_Interp *interp, Tcl_Namespace *nsPtr, char *pattern, \
	    int resetListFirst)
d460 1
a460 1
    Tcl_Command Tcl_FindCommand(Tcl_Interp *interp, char *name, \
d464 1
a464 1
    Tcl_Namespace * Tcl_FindNamespace(Tcl_Interp *interp, char *name, \
d468 1
a468 1
    int Tcl_GetInterpResolvers(Tcl_Interp *interp, char *name, \
d472 1
a472 1
    int Tcl_GetNamespaceResolvers(Tcl_Namespace *namespacePtr, \
d476 1
a476 1
    Tcl_Var Tcl_FindNamespaceVar(Tcl_Interp *interp, char *name, \
d480 2
a481 2
    int Tcl_ForgetImport(Tcl_Interp *interp, Tcl_Namespace *nsPtr, \
	    char *pattern)
d487 1
a487 1
    void Tcl_GetCommandFullName(Tcl_Interp *interp, Tcl_Command command, \
d497 1
a497 1
    void Tcl_GetVariableFullName(Tcl_Interp *interp, Tcl_Var variable, \
d501 2
a502 2
    int Tcl_Import(Tcl_Interp *interp, Tcl_Namespace *nsPtr, \
	    char *pattern, int allowOverwrite)
d508 1
a508 1
    int Tcl_PushCallFrame(Tcl_Interp* interp, Tcl_CallFrame *framePtr, \
d512 1
a512 1
    int Tcl_RemoveInterpResolvers(Tcl_Interp *interp, char *name)
d515 2
a516 2
    void Tcl_SetNamespaceResolvers(Tcl_Namespace *namespacePtr, \
	    Tcl_ResolveCmdProc *cmdProc, Tcl_ResolveVarProc *varProc, \
d526 2
a527 2
    size_t TclpStrftime(char *s, size_t maxsize, CONST char *format, \
	    CONST struct tm *t)
d535 3
a537 3
declare 137 generic {
   int TclpChdir(CONST char *dirName)
}
d539 1
a539 6
    char * TclGetEnv(CONST char *name, Tcl_DString *valuePtr)
}
declare 139 generic {
    int TclpLoadFile(Tcl_Interp *interp, char *fileName, char *sym1, \
	    char *sym2, Tcl_PackageInitProc **proc1Ptr, \
	    Tcl_PackageInitProc **proc2Ptr, ClientData *clientDataPtr)
d541 5
d547 1
a547 1
    int TclLooksLikeInt(char *bytes, int length)
d549 1
d551 1
a551 1
    char *TclpGetCwd(Tcl_Interp *interp, Tcl_DString *cwdPtr)
d554 1
a554 1
    int TclSetByteCodeFromAny(Tcl_Interp *interp, Tcl_Obj *objPtr, \
d558 1
a558 1
    int TclAddLiteralObj(struct CompileEnv *envPtr, Tcl_Obj *objPtr, \
d562 1
a562 1
    void TclHideLiteral(Tcl_Interp *interp, struct CompileEnv *envPtr, \
d591 1
a591 1
    void TclRegExpRangeUniChar(Tcl_RegExp re, int index, int *startPtr, \
d602 1
a602 1
# moved to tclTest.c in 8.3.2/8.4a2
d608 1
a608 1
#    int TclTestChannelEventCmd(ClientData clientData, \
d613 1
a613 1
    void TclRegError (Tcl_Interp *interp, char *msg, \
d617 1
a617 1
    Var * TclVarTraceExists (Tcl_Interp *interp, char *varName)
d620 1
a620 1
    void TclSetStartupScriptFileName(char *filename)
d623 1
a623 5
    char *TclGetStartupScriptFileName(void)
}
declare 160 generic {
    int TclpMatchFilesTypes(Tcl_Interp *interp, char *separators, \
	    Tcl_DString *dirPtr, char *pattern, char *tail, GlobTypeData *types)
d625 4
d632 1
a632 1
    int TclChannelTransform(Tcl_Interp *interp, Tcl_Channel chan, \
d639 50
d721 1
a721 1
    OSErr FSpFindFolder(short vRefNum, OSType folderType, \
d725 1
a725 1
    void GetGlobalMouse(Point *mouse)
d733 1
a733 1
    pascal OSErr FSpGetDirectoryID(CONST FSSpec *spec, long *theDirID, \
d737 1
a737 1
    pascal short FSpOpenResFileCompat(CONST FSSpec *spec, \
d741 1
a741 1
    pascal void FSpCreateResFileCompat(CONST FSSpec *spec, OSType creator, \
d752 1
a752 1
    OSErr FSpPathFromLocation(FSSpecPtr theSpec, int *length, \
d780 1
a780 1
    int TclMacRegisterResourceFork(short fileRef, Tcl_Obj *tokenPtr, \
d796 3
d800 5
a804 1
    int TclMacChmod(char *path, int mode)
d817 1
a817 1
    struct servent * TclWinGetServByName(CONST char *nm, \
d821 1
a821 1
    int TclWinGetSockOpt(SOCKET s, int level, int optname, \
d835 1
a835 1
    int TclWinSetSockOpt(SOCKET s, int level, int optname, \
d858 1
a858 1
    Tcl_Channel TclpCreateCommandChannel(TclFile readFile, \
d865 2
a866 2
    int TclpCreateProcess(Tcl_Interp *interp, int argc, char **argv, \
	    TclFile inputFile, TclFile outputFile, TclFile errorFile, \
d885 5
a889 3
declare 21 win {
    void TclpAsyncMark(Tcl_AsyncHandler async)
}
d908 6
d926 1
a926 1
    Tcl_Channel TclpCreateCommandChannel(TclFile readFile, \
d933 2
a934 2
    int TclpCreateProcess(Tcl_Interp *interp, int argc, char **argv, \
	    TclFile inputFile, TclFile outputFile, TclFile errorFile, \
d939 1
a939 2
#      TclFile TclpCreateTempFile(char *contents, 
#      Tcl_DString *namePtr)
d955 18
@


1.3
log
@touched all sources to ease next import
@
text
@@


1.3.4.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@a9 2
# Copyright (c) 2001 by Kevin B. Kenny.  All rights reserved.
#
d13 1
a13 1
# RCS: @@(#) $Id: tclInt.decls,v 1.56 2002/10/09 11:54:09 das Exp $
d26 3
a28 4
# Replaced by Tcl_FSAccess in 8.4:
#declare 0 generic {
#    int TclAccess(CONST char *path, int mode)
#}
d43 1
a43 1
    int TclCleanupChildren(Tcl_Interp *interp, int numPids, Tcl_Pid *pidPtr,
d53 1
a53 1
    int TclCopyChannel(Tcl_Interp *interp, Tcl_Channel inChan,
d60 2
a61 2
    int TclCreatePipeline(Tcl_Interp *interp, int argc, CONST char **argv,
	    Tcl_Pid **pidArrayPtr, TclFile *inPipePtr, TclFile *outPipePtr,
d65 1
a65 2
    int TclCreateProc(Tcl_Interp *interp, Namespace *nsPtr, 
	    CONST char *procName,
d75 2
a76 2
    int TclDoGlob(Tcl_Interp *interp, char *separators,
	    Tcl_DString *headPtr, char *tail, Tcl_GlobTypeData *types)
d88 15
a102 16
# Removed in 8.4
#declare 17 generic {
#    int TclFileAttrsCmd(Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
#}
#declare 18 generic {
#    int TclFileCopyCmd(Tcl_Interp *interp, int argc, char **argv)
#}
#declare 19 generic {
#    int TclFileDeleteCmd(Tcl_Interp *interp, int argc, char **argv)
#}
#declare 20 generic {
#    int TclFileMakeDirsCmd(Tcl_Interp *interp, int argc, char **argv)
#}
#declare 21 generic {
#    int TclFileRenameCmd(Tcl_Interp *interp, int argc, char **argv)
#}
d104 2
a105 2
    int TclFindElement(Tcl_Interp *interp, CONST char *listStr,
	    int listLength, CONST char **elementPtr, CONST char **nextPtr,
d109 1
a109 1
    Proc * TclFindProc(Interp *iPtr, CONST char *procName)
d122 1
a122 1
    int TclGetDate(char *p, unsigned long now, long zone,
d128 4
a131 5
# Removed in 8.4b2:
#declare 29 generic {
#    Tcl_Obj * TclGetElementOfIndexedArray(Tcl_Interp *interp,
#	    int localIndex, Tcl_Obj *elemPtr, int flags)
#}
d140 1
a140 2
    int TclGetFrame(Tcl_Interp *interp, CONST char *str,
	    CallFrame **framePtrPtr)
d146 1
a146 1
    int TclGetIntForIndex(Tcl_Interp *interp, Tcl_Obj *objPtr,
d149 4
a152 5
# Removed in 8.4b2:
#declare 35 generic {
#    Tcl_Obj * TclGetIndexedScalar(Tcl_Interp *interp, int localIndex,
#	    int flags)
#}
d154 1
a154 1
    int TclGetLong(Tcl_Interp *interp, CONST char *str, long *longPtr)
d160 4
a163 4
    int TclGetNamespaceForQualName(Tcl_Interp *interp, CONST char *qualName,
	    Namespace *cxtNsPtr, int flags, Namespace **nsPtrPtr,
	    Namespace **altNsPtrPtr, Namespace **actualCxtPtrPtr,
	    CONST char **simpleNamePtr)
d169 1
a169 1
    int TclGetOpenMode(Tcl_Interp *interp, CONST char *str, int *seekFlagPtr)
d178 1
a178 1
    int TclGlobalInvoke(Tcl_Interp *interp, int argc, CONST84 char **argv, int flags)
d181 1
a181 1
    int TclGuessPackageName(CONST char *fileName, Tcl_DString *bufPtr)
d189 8
a196 10
# Removed in 8.4b2:
#declare 47 generic {
#    Tcl_Obj * TclIncrElementOfIndexedArray(Tcl_Interp *interp,
#	    int localIndex, Tcl_Obj *elemPtr, long incrAmount)
#}
# Removed in 8.4b2:
#declare 48 generic {
#    Tcl_Obj * TclIncrIndexedScalar(Tcl_Interp *interp, int localIndex,
#	    long incrAmount)
#}
d198 1
a198 1
    Tcl_Obj * TclIncrVar2(Tcl_Interp *interp, Tcl_Obj *part1Ptr,
d202 1
a202 1
    void TclInitCompiledLocals(Tcl_Interp *interp, CallFrame *framePtr,
d209 1
a209 1
    int TclInvoke(Tcl_Interp *interp, int argc, CONST84 char **argv, int flags)
d212 2
a213 2
    int TclInvokeObjectCommand(ClientData clientData, Tcl_Interp *interp,
	    int argc, CONST84 char **argv)
d216 1
a216 1
    int TclInvokeStringCommand(ClientData clientData, Tcl_Interp *interp,
d224 2
a225 2
#      int TclLoadFile(Tcl_Interp *interp, char *fileName, char *sym1,
#  	    char *sym2, Tcl_PackageInitProc **proc1Ptr,
d233 2
a234 2
    Var * TclLookupVar(Tcl_Interp *interp, CONST char *part1, CONST char *part2,
	    int flags, CONST char *msg, int createPart1, int createPart2,
d237 4
a240 5
# Replaced by Tcl_FSMatchInDirectory in 8.4
#declare 59 generic {
#    int TclpMatchFiles(Tcl_Interp *interp, char *separators,
#	    Tcl_DString *dirPtr, char *pattern, char *tail)
#}
d242 1
a242 1
    int TclNeedSpace(CONST char *start, CONST char *end)
d251 1
a251 1
    int TclObjInterpProc(ClientData clientData, Tcl_Interp *interp,
d255 1
a255 1
    int TclObjInvoke(Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[],
d259 1
a259 1
    int TclObjInvokeGlobal(Tcl_Interp *interp, int objc,
d268 3
a270 4
# Replaced by Tcl_FSAccess in 8.4:
#declare 68 generic {
#    int TclpAccess(CONST char *path, int mode)
#}
d274 13
a286 13
#declare 70 generic {
#    int TclpCopyFile(CONST char *source, CONST char *dest)
#}
#declare 71 generic {
#    int TclpCopyDirectory(CONST char *source, CONST char *dest,
#	    Tcl_DString *errorPtr)
#}
#declare 72 generic {
#    int TclpCreateDirectory(CONST char *path)
#}
#declare 73 generic {
#    int TclpDeleteFile(CONST char *path)
#}
a295 2

# deprecated
a298 1

d302 7
a308 9
# Replaced by Tcl_FSListVolumes in 8.4:
#declare 79 generic {
#    int TclpListVolumes(Tcl_Interp *interp)
#}
# Replaced by Tcl_FSOpenFileChannel in 8.4:
#declare 80 generic {
#    Tcl_Channel TclpOpenFileChannel(Tcl_Interp *interp, char *fileName,
#	    char *modeString, int permissions)
#}
d312 7
a318 7
#declare 82 generic {
#    int TclpRemoveDirectory(CONST char *path, int recursive,
#	    Tcl_DString *errorPtr)
#}
#declare 83 generic {
#    int TclpRenameFile(CONST char *source, CONST char *dest)
#}
d321 1
a321 1
#      int TclParseBraces(Tcl_Interp *interp, char *str, char **termPtr,
d325 1
a325 1
#      int TclParseNestedCmd(Tcl_Interp *interp, char *str, int flags,
d329 1
a329 1
#      int TclParseQuotes(Tcl_Interp *interp, char *str, int termChar,
d336 2
a337 2
    char * TclPrecTraceProc(ClientData clientData, Tcl_Interp *interp,
	    CONST char *name1, CONST char *name2, int flags)
d340 1
a340 1
    int TclPreventAliasLoop(Tcl_Interp *interp, Tcl_Interp *cmdInterp,
d351 2
a352 2
    int TclProcCompileProc(Tcl_Interp *interp, Proc *procPtr,
	    Tcl_Obj *bodyPtr, Namespace *nsPtr, CONST char *description,
d359 5
a363 2
    int TclProcInterpProc(ClientData clientData, Tcl_Interp *interp,
	    int argc, CONST84 char **argv)
a364 4
# Replaced by Tcl_FSStat in 8.4:
#declare 95 generic {
#    int TclpStat(CONST char *path, Tcl_StatBuf *buf)
#}
d374 9
a382 11
# Removed in 8.4b2:
#declare 99 generic {
#    Tcl_Obj * TclSetElementOfIndexedArray(Tcl_Interp *interp, int localIndex,
#	    Tcl_Obj *elemPtr, Tcl_Obj *objPtr, int flags)
#}
# Removed in 8.4b2:
#declare 100 generic {
#    Tcl_Obj * TclSetIndexedScalar(Tcl_Interp *interp, int localIndex,
#	    Tcl_Obj *objPtr, int flags)
#}
declare 101 generic {
d389 1
a389 1
    int TclSockGetPort(Tcl_Interp *interp, char *str, char *proto,
d395 3
a397 4
# Replaced by Tcl_FSStat in 8.4:
#declare 105 generic {
#    int TclStat(CONST char *path, Tcl_StatBuf *buf)
#}
d419 2
a420 2
    void Tcl_AddInterpResolvers(Tcl_Interp *interp, CONST char *name,
	    Tcl_ResolveCmdProc *cmdProc, Tcl_ResolveVarProc *varProc,
d424 1
a424 1
    int Tcl_AppendExportList(Tcl_Interp *interp, Tcl_Namespace *nsPtr,
d428 1
a428 1
    Tcl_Namespace * Tcl_CreateNamespace(Tcl_Interp *interp, CONST char *name,
d435 2
a436 2
    int Tcl_Export(Tcl_Interp *interp, Tcl_Namespace *nsPtr,
	    CONST char *pattern, int resetListFirst)
d439 1
a439 1
    Tcl_Command Tcl_FindCommand(Tcl_Interp *interp, CONST char *name,
d443 1
a443 1
    Tcl_Namespace * Tcl_FindNamespace(Tcl_Interp *interp, CONST char *name,
d447 1
a447 1
    int Tcl_GetInterpResolvers(Tcl_Interp *interp, CONST char *name,
d451 1
a451 1
    int Tcl_GetNamespaceResolvers(Tcl_Namespace *namespacePtr,
d455 1
a455 1
    Tcl_Var Tcl_FindNamespaceVar(Tcl_Interp *interp, CONST char *name,
d459 2
a460 2
    int Tcl_ForgetImport(Tcl_Interp *interp, Tcl_Namespace *nsPtr,
	    CONST char *pattern)
d466 1
a466 1
    void Tcl_GetCommandFullName(Tcl_Interp *interp, Tcl_Command command,
d476 1
a476 1
    void Tcl_GetVariableFullName(Tcl_Interp *interp, Tcl_Var variable,
d480 2
a481 2
    int Tcl_Import(Tcl_Interp *interp, Tcl_Namespace *nsPtr,
	    CONST char *pattern, int allowOverwrite)
d487 1
a487 1
    int Tcl_PushCallFrame(Tcl_Interp* interp, Tcl_CallFrame *framePtr,
d491 1
a491 1
    int Tcl_RemoveInterpResolvers(Tcl_Interp *interp, CONST char *name)
d494 2
a495 2
    void Tcl_SetNamespaceResolvers(Tcl_Namespace *namespacePtr,
	    Tcl_ResolveCmdProc *cmdProc, Tcl_ResolveVarProc *varProc,
d505 2
a506 2
    size_t TclpStrftime(char *s, size_t maxsize, CONST char *format,
	    CONST struct tm *t, int useGMT)
d514 3
a516 3
#declare 137 generic {
#   int TclpChdir(CONST char *dirName)
#}
d518 6
a523 1
    CONST84_RETURN char * TclGetEnv(CONST char *name, Tcl_DString *valuePtr)
a524 5
#declare 139 generic {
#    int TclpLoadFile(Tcl_Interp *interp, char *fileName, char *sym1,
#	    char *sym2, Tcl_PackageInitProc **proc1Ptr,
#	    Tcl_PackageInitProc **proc2Ptr, ClientData *clientDataPtr)
#}
d526 1
a526 1
    int TclLooksLikeInt(CONST char *bytes, int length)
a527 1
# This is used by TclX, but should otherwise be considered private
d529 1
a529 1
    CONST84_RETURN char *TclpGetCwd(Tcl_Interp *interp, Tcl_DString *cwdPtr)
d532 1
a532 1
    int TclSetByteCodeFromAny(Tcl_Interp *interp, Tcl_Obj *objPtr,
d536 1
a536 1
    int TclAddLiteralObj(struct CompileEnv *envPtr, Tcl_Obj *objPtr,
d540 1
a540 1
    void TclHideLiteral(Tcl_Interp *interp, struct CompileEnv *envPtr,
d569 1
a569 1
    void TclRegExpRangeUniChar(Tcl_RegExp re, int index, int *startPtr,
d580 1
a580 1
# moved to tclTest.c (static) in 8.3.2/8.4a2
d586 1
a586 1
#    int TclTestChannelEventCmd(ClientData clientData,
d591 1
a591 1
    void TclRegError (Tcl_Interp *interp, CONST char *msg,
d595 1
a595 1
    Var * TclVarTraceExists (Tcl_Interp *interp, CONST char *varName)
d598 1
a598 1
    void TclSetStartupScriptFileName(CONST char *filename)
d601 5
a605 1
    CONST84_RETURN char *TclGetStartupScriptFileName(void)
a606 4
#declare 160 generic {
#    int TclpMatchFilesTypes(Tcl_Interp *interp, char *separators,
#	    Tcl_DString *dirPtr, char *pattern, char *tail, GlobTypeData *types)
#}
d610 1
a610 1
    int TclChannelTransform(Tcl_Interp *interp, Tcl_Channel chan,
a616 50
# ALERT: The result of 'TclGetInstructionTable' is actually an
# "InstructionDesc*" but we do not want to describe this structure in
# "tclInt.h". It is described in "tclCompile.h". Use a cast to the
# correct type when calling this procedure.

declare 163 generic {
	void * TclGetInstructionTable (void)
}

# ALERT: The argument of 'TclExpandCodeArray' is actually a
# "CompileEnv*" but we do not want to describe this structure in
# "tclInt.h". It is described in "tclCompile.h".

declare 164 generic {
	void TclExpandCodeArray (void *envPtr)
}

# These functions are vfs aware, but are generally only useful internally.
declare 165 generic {
    void TclpSetInitialEncodings(void)
}

# New function due to TIP #33
declare 166 generic {
    int TclListObjSetElement(Tcl_Interp *interp, Tcl_Obj *listPtr, 
	    int index, Tcl_Obj *valuePtr)
}

# VFS-aware versions of Tcl*StartupScriptFileName (158 and 159 above)
declare 167 generic {
    void TclSetStartupScriptPath(Tcl_Obj *pathPtr)
}
declare 168 generic {
    Tcl_Obj *TclGetStartupScriptPath(void)
}
# variant of Tcl_UtfNCmp that takes n as bytes, not chars
declare 169 generic {
    int TclpUtfNcmp2(CONST char *s1, CONST char *s2, unsigned long n)
}
declare 170 generic {
    int TclCheckInterpTraces (Tcl_Interp *interp, CONST char *command, int numChars, \
            Command *cmdPtr, int result, int traceFlags, int objc, \
	    Tcl_Obj *CONST objv[])
}
declare 171 generic {
    int TclCheckExecutionTraces (Tcl_Interp *interp, CONST char *command, int numChars, \
            Command *cmdPtr, int result, int traceFlags, int objc, \
	    Tcl_Obj *CONST objv[])
}

d649 1
a649 1
    OSErr FSpFindFolder(short vRefNum, OSType folderType,
d653 1
a653 1
    void GetGlobalMouseTcl(Point *mouse)
d661 1
a661 1
    pascal OSErr FSpGetDirectoryIDTcl(CONST FSSpec *spec, long *theDirID,
d665 1
a665 1
    pascal short FSpOpenResFileCompatTcl(CONST FSSpec *spec,
d669 1
a669 1
    pascal void FSpCreateResFileCompatTcl(CONST FSSpec *spec, OSType creator,
d680 1
a680 1
    OSErr FSpPathFromLocation(FSSpecPtr theSpec, int *length,
d708 1
a708 1
    int TclMacRegisterResourceFork(short fileRef, Tcl_Obj *tokenPtr,
a723 3
declare 24 mac {
    char * TclpGetTZName(int isdst)
}
d725 1
a725 5
    int TclMacChmod(CONST char *path, int mode)
}
# version of FSpLocationFromPath that doesn't resolve the last path component
declare 26 mac {
    int FSpLLocationFromPath(int length, CONST char *path, FSSpecPtr theSpec)
d738 1
a738 1
    struct servent * TclWinGetServByName(CONST char *nm,
d742 1
a742 1
    int TclWinGetSockOpt(SOCKET s, int level, int optname,
d756 1
a756 1
    int TclWinSetSockOpt(SOCKET s, int level, int optname,
d779 1
a779 1
    Tcl_Channel TclpCreateCommandChannel(TclFile readFile,
d786 2
a787 2
    int TclpCreateProcess(Tcl_Interp *interp, int argc, CONST char **argv,
	    TclFile inputFile, TclFile outputFile, TclFile errorFile,
d806 3
a808 5

# removed permanently for 8.4
#declare 21 win {
#    void TclpAsyncMark(Tcl_AsyncHandler async)
#}
a826 6
# Added in Tcl 8.3.3 / 8.4

declare 27 win {
    void TclWinFlushDirtyChannels (void)
}

d839 1
a839 1
    Tcl_Channel TclpCreateCommandChannel(TclFile readFile,
d846 2
a847 2
    int TclpCreateProcess(Tcl_Interp *interp, int argc, CONST char **argv,
	    TclFile inputFile, TclFile outputFile, TclFile errorFile,
d852 2
a853 1
#      TclFile TclpCreateTempFile(char *contents, Tcl_DString *namePtr)
a868 18
}

# Added in 8.4:

declare 10 unix {
    Tcl_DirEntry * TclpReaddir(DIR * dir)
}

declare 11 unix {
    struct tm * TclpLocaltime(time_t * clock)
}

declare 12 unix {
    struct tm * TclpGmtime(time_t * clock)
}

declare 13 unix {
    char * TclpInetNtoa(struct in_addr addr)
@


1.3.2.1
log
@Import Tcl 8.4.0 into mainline-like sources. Simplest Tcl build possible for
cygwin.
@
text
@a9 2
# Copyright (c) 2001 by Kevin B. Kenny.  All rights reserved.
#
d13 1
a13 1
# RCS: @@(#) $Id: tclInt.decls,v 1.55 2002/08/06 01:49:27 das Exp $
d26 3
a28 4
# Replaced by Tcl_FSAccess in 8.4:
#declare 0 generic {
#    int TclAccess(CONST char *path, int mode)
#}
d42 2
a43 2
declare 5 {unix win cygwin} {
    int TclCleanupChildren(Tcl_Interp *interp, int numPids, Tcl_Pid *pidPtr,
d53 1
a53 1
    int TclCopyChannel(Tcl_Interp *interp, Tcl_Channel inChan,
d59 3
a61 3
declare 9 {unix win cygwin} {
    int TclCreatePipeline(Tcl_Interp *interp, int argc, CONST char **argv,
	    Tcl_Pid **pidArrayPtr, TclFile *inPipePtr, TclFile *outPipePtr,
d65 1
a65 2
    int TclCreateProc(Tcl_Interp *interp, Namespace *nsPtr, 
	    CONST char *procName,
d75 2
a76 2
    int TclDoGlob(Tcl_Interp *interp, char *separators,
	    Tcl_DString *headPtr, char *tail, Tcl_GlobTypeData *types)
d88 15
a102 16
# Removed in 8.4
#declare 17 generic {
#    int TclFileAttrsCmd(Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
#}
#declare 18 generic {
#    int TclFileCopyCmd(Tcl_Interp *interp, int argc, char **argv)
#}
#declare 19 generic {
#    int TclFileDeleteCmd(Tcl_Interp *interp, int argc, char **argv)
#}
#declare 20 generic {
#    int TclFileMakeDirsCmd(Tcl_Interp *interp, int argc, char **argv)
#}
#declare 21 generic {
#    int TclFileRenameCmd(Tcl_Interp *interp, int argc, char **argv)
#}
d104 2
a105 2
    int TclFindElement(Tcl_Interp *interp, CONST char *listStr,
	    int listLength, CONST char **elementPtr, CONST char **nextPtr,
d109 1
a109 1
    Proc * TclFindProc(Interp *iPtr, CONST char *procName)
d122 1
a122 1
    int TclGetDate(char *p, unsigned long now, long zone,
d128 4
a131 5
# Removed in 8.4b2:
#declare 29 generic {
#    Tcl_Obj * TclGetElementOfIndexedArray(Tcl_Interp *interp,
#	    int localIndex, Tcl_Obj *elemPtr, int flags)
#}
d140 1
a140 2
    int TclGetFrame(Tcl_Interp *interp, CONST char *str,
	    CallFrame **framePtrPtr)
d146 1
a146 1
    int TclGetIntForIndex(Tcl_Interp *interp, Tcl_Obj *objPtr,
d149 4
a152 5
# Removed in 8.4b2:
#declare 35 generic {
#    Tcl_Obj * TclGetIndexedScalar(Tcl_Interp *interp, int localIndex,
#	    int flags)
#}
d154 1
a154 1
    int TclGetLong(Tcl_Interp *interp, CONST char *str, long *longPtr)
d160 4
a163 4
    int TclGetNamespaceForQualName(Tcl_Interp *interp, CONST char *qualName,
	    Namespace *cxtNsPtr, int flags, Namespace **nsPtrPtr,
	    Namespace **altNsPtrPtr, Namespace **actualCxtPtrPtr,
	    CONST char **simpleNamePtr)
d169 1
a169 1
    int TclGetOpenMode(Tcl_Interp *interp, CONST char *str, int *seekFlagPtr)
d178 1
a178 1
    int TclGlobalInvoke(Tcl_Interp *interp, int argc, CONST84 char **argv, int flags)
d181 1
a181 1
    int TclGuessPackageName(CONST char *fileName, Tcl_DString *bufPtr)
d189 8
a196 10
# Removed in 8.4b2:
#declare 47 generic {
#    Tcl_Obj * TclIncrElementOfIndexedArray(Tcl_Interp *interp,
#	    int localIndex, Tcl_Obj *elemPtr, long incrAmount)
#}
# Removed in 8.4b2:
#declare 48 generic {
#    Tcl_Obj * TclIncrIndexedScalar(Tcl_Interp *interp, int localIndex,
#	    long incrAmount)
#}
d198 1
a198 1
    Tcl_Obj * TclIncrVar2(Tcl_Interp *interp, Tcl_Obj *part1Ptr,
d202 1
a202 1
    void TclInitCompiledLocals(Tcl_Interp *interp, CallFrame *framePtr,
d209 1
a209 1
    int TclInvoke(Tcl_Interp *interp, int argc, CONST84 char **argv, int flags)
d212 2
a213 2
    int TclInvokeObjectCommand(ClientData clientData, Tcl_Interp *interp,
	    int argc, CONST84 char **argv)
d216 1
a216 1
    int TclInvokeStringCommand(ClientData clientData, Tcl_Interp *interp,
d224 2
a225 2
#      int TclLoadFile(Tcl_Interp *interp, char *fileName, char *sym1,
#  	    char *sym2, Tcl_PackageInitProc **proc1Ptr,
d233 2
a234 2
    Var * TclLookupVar(Tcl_Interp *interp, CONST char *part1, CONST char *part2,
	    int flags, CONST char *msg, int createPart1, int createPart2,
d237 4
a240 5
# Replaced by Tcl_FSMatchInDirectory in 8.4
#declare 59 generic {
#    int TclpMatchFiles(Tcl_Interp *interp, char *separators,
#	    Tcl_DString *dirPtr, char *pattern, char *tail)
#}
d242 1
a242 1
    int TclNeedSpace(CONST char *start, CONST char *end)
d251 1
a251 1
    int TclObjInterpProc(ClientData clientData, Tcl_Interp *interp,
d255 1
a255 1
    int TclObjInvoke(Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[],
d259 1
a259 1
    int TclObjInvokeGlobal(Tcl_Interp *interp, int objc,
d268 3
a270 4
# Replaced by Tcl_FSAccess in 8.4:
#declare 68 generic {
#    int TclpAccess(CONST char *path, int mode)
#}
d274 13
a286 13
#declare 70 generic {
#    int TclpCopyFile(CONST char *source, CONST char *dest)
#}
#declare 71 generic {
#    int TclpCopyDirectory(CONST char *source, CONST char *dest,
#	    Tcl_DString *errorPtr)
#}
#declare 72 generic {
#    int TclpCreateDirectory(CONST char *path)
#}
#declare 73 generic {
#    int TclpDeleteFile(CONST char *path)
#}
a295 2

# deprecated
a298 1

d302 7
a308 9
# Replaced by Tcl_FSListVolumes in 8.4:
#declare 79 generic {
#    int TclpListVolumes(Tcl_Interp *interp)
#}
# Replaced by Tcl_FSOpenFileChannel in 8.4:
#declare 80 generic {
#    Tcl_Channel TclpOpenFileChannel(Tcl_Interp *interp, char *fileName,
#	    char *modeString, int permissions)
#}
d312 7
a318 7
#declare 82 generic {
#    int TclpRemoveDirectory(CONST char *path, int recursive,
#	    Tcl_DString *errorPtr)
#}
#declare 83 generic {
#    int TclpRenameFile(CONST char *source, CONST char *dest)
#}
d321 1
a321 1
#      int TclParseBraces(Tcl_Interp *interp, char *str, char **termPtr,
d325 1
a325 1
#      int TclParseNestedCmd(Tcl_Interp *interp, char *str, int flags,
d329 1
a329 1
#      int TclParseQuotes(Tcl_Interp *interp, char *str, int termChar,
d336 2
a337 2
    char * TclPrecTraceProc(ClientData clientData, Tcl_Interp *interp,
	    CONST char *name1, CONST char *name2, int flags)
d340 1
a340 1
    int TclPreventAliasLoop(Tcl_Interp *interp, Tcl_Interp *cmdInterp,
d351 2
a352 2
    int TclProcCompileProc(Tcl_Interp *interp, Proc *procPtr,
	    Tcl_Obj *bodyPtr, Namespace *nsPtr, CONST char *description,
d359 5
a363 2
    int TclProcInterpProc(ClientData clientData, Tcl_Interp *interp,
	    int argc, CONST84 char **argv)
a364 4
# Replaced by Tcl_FSStat in 8.4:
#declare 95 generic {
#    int TclpStat(CONST char *path, Tcl_StatBuf *buf)
#}
d374 9
a382 11
# Removed in 8.4b2:
#declare 99 generic {
#    Tcl_Obj * TclSetElementOfIndexedArray(Tcl_Interp *interp, int localIndex,
#	    Tcl_Obj *elemPtr, Tcl_Obj *objPtr, int flags)
#}
# Removed in 8.4b2:
#declare 100 generic {
#    Tcl_Obj * TclSetIndexedScalar(Tcl_Interp *interp, int localIndex,
#	    Tcl_Obj *objPtr, int flags)
#}
declare 101 {unix win cygwin} {
d389 1
a389 1
    int TclSockGetPort(Tcl_Interp *interp, char *str, char *proto,
d392 1
a392 1
declare 104 {unix win cygwin} {
d395 3
a397 4
# Replaced by Tcl_FSStat in 8.4:
#declare 105 generic {
#    int TclStat(CONST char *path, Tcl_StatBuf *buf)
#}
d419 2
a420 2
    void Tcl_AddInterpResolvers(Tcl_Interp *interp, CONST char *name,
	    Tcl_ResolveCmdProc *cmdProc, Tcl_ResolveVarProc *varProc,
d424 1
a424 1
    int Tcl_AppendExportList(Tcl_Interp *interp, Tcl_Namespace *nsPtr,
d428 1
a428 1
    Tcl_Namespace * Tcl_CreateNamespace(Tcl_Interp *interp, CONST char *name,
d435 2
a436 2
    int Tcl_Export(Tcl_Interp *interp, Tcl_Namespace *nsPtr,
	    CONST char *pattern, int resetListFirst)
d439 1
a439 1
    Tcl_Command Tcl_FindCommand(Tcl_Interp *interp, CONST char *name,
d443 1
a443 1
    Tcl_Namespace * Tcl_FindNamespace(Tcl_Interp *interp, CONST char *name,
d447 1
a447 1
    int Tcl_GetInterpResolvers(Tcl_Interp *interp, CONST char *name,
d451 1
a451 1
    int Tcl_GetNamespaceResolvers(Tcl_Namespace *namespacePtr,
d455 1
a455 1
    Tcl_Var Tcl_FindNamespaceVar(Tcl_Interp *interp, CONST char *name,
d459 2
a460 2
    int Tcl_ForgetImport(Tcl_Interp *interp, Tcl_Namespace *nsPtr,
	    CONST char *pattern)
d466 1
a466 1
    void Tcl_GetCommandFullName(Tcl_Interp *interp, Tcl_Command command,
d476 1
a476 1
    void Tcl_GetVariableFullName(Tcl_Interp *interp, Tcl_Var variable,
d480 2
a481 2
    int Tcl_Import(Tcl_Interp *interp, Tcl_Namespace *nsPtr,
	    CONST char *pattern, int allowOverwrite)
d487 1
a487 1
    int Tcl_PushCallFrame(Tcl_Interp* interp, Tcl_CallFrame *framePtr,
d491 1
a491 1
    int Tcl_RemoveInterpResolvers(Tcl_Interp *interp, CONST char *name)
d494 2
a495 2
    void Tcl_SetNamespaceResolvers(Tcl_Namespace *namespacePtr,
	    Tcl_ResolveCmdProc *cmdProc, Tcl_ResolveVarProc *varProc,
d505 2
a506 2
    size_t TclpStrftime(char *s, size_t maxsize, CONST char *format,
	    CONST struct tm *t, int useGMT)
d514 3
a516 3
#declare 137 generic {
#   int TclpChdir(CONST char *dirName)
#}
d518 6
a523 1
    CONST84_RETURN char * TclGetEnv(CONST char *name, Tcl_DString *valuePtr)
a524 5
#declare 139 generic {
#    int TclpLoadFile(Tcl_Interp *interp, char *fileName, char *sym1,
#	    char *sym2, Tcl_PackageInitProc **proc1Ptr,
#	    Tcl_PackageInitProc **proc2Ptr, ClientData *clientDataPtr)
#}
d526 1
a526 1
    int TclLooksLikeInt(CONST char *bytes, int length)
a527 1
# This is used by TclX, but should otherwise be considered private
d529 1
a529 1
    CONST84_RETURN char *TclpGetCwd(Tcl_Interp *interp, Tcl_DString *cwdPtr)
d532 1
a532 1
    int TclSetByteCodeFromAny(Tcl_Interp *interp, Tcl_Obj *objPtr,
d536 1
a536 1
    int TclAddLiteralObj(struct CompileEnv *envPtr, Tcl_Obj *objPtr,
d540 1
a540 1
    void TclHideLiteral(Tcl_Interp *interp, struct CompileEnv *envPtr,
d569 1
a569 1
    void TclRegExpRangeUniChar(Tcl_RegExp re, int index, int *startPtr,
d580 1
a580 1
# moved to tclTest.c (static) in 8.3.2/8.4a2
d586 1
a586 1
#    int TclTestChannelEventCmd(ClientData clientData,
d591 1
a591 1
    void TclRegError (Tcl_Interp *interp, CONST char *msg,
d595 1
a595 1
    Var * TclVarTraceExists (Tcl_Interp *interp, CONST char *varName)
d598 1
a598 1
    void TclSetStartupScriptFileName(CONST char *filename)
d601 5
a605 1
    CONST84_RETURN char *TclGetStartupScriptFileName(void)
a606 4
#declare 160 generic {
#    int TclpMatchFilesTypes(Tcl_Interp *interp, char *separators,
#	    Tcl_DString *dirPtr, char *pattern, char *tail, GlobTypeData *types)
#}
d610 1
a610 1
    int TclChannelTransform(Tcl_Interp *interp, Tcl_Channel chan,
a616 50
# ALERT: The result of 'TclGetInstructionTable' is actually an
# "InstructionDesc*" but we do not want to describe this structure in
# "tclInt.h". It is described in "tclCompile.h". Use a cast to the
# correct type when calling this procedure.

declare 163 generic {
	void * TclGetInstructionTable (void)
}

# ALERT: The argument of 'TclExpandCodeArray' is actually a
# "CompileEnv*" but we do not want to describe this structure in
# "tclInt.h". It is described in "tclCompile.h".

declare 164 generic {
	void TclExpandCodeArray (void *envPtr)
}

# These functions are vfs aware, but are generally only useful internally.
declare 165 generic {
    void TclpSetInitialEncodings(void)
}

# New function due to TIP #33
declare 166 generic {
    int TclListObjSetElement(Tcl_Interp *interp, Tcl_Obj *listPtr, 
	    int index, Tcl_Obj *valuePtr)
}

# VFS-aware versions of Tcl*StartupScriptFileName (158 and 159 above)
declare 167 generic {
    void TclSetStartupScriptPath(Tcl_Obj *pathPtr)
}
declare 168 generic {
    Tcl_Obj *TclGetStartupScriptPath(void)
}
# variant of Tcl_UtfNCmp that takes n as bytes, not chars
declare 169 generic {
    int TclpUtfNcmp2(CONST char *s1, CONST char *s2, unsigned long n)
}
declare 170 generic {
    int TclCheckInterpTraces (Tcl_Interp *interp, CONST char *command, int numChars, \
            Command *cmdPtr, int result, int traceFlags, int objc, \
	    Tcl_Obj *CONST objv[])
}
declare 171 generic {
    int TclCheckExecutionTraces (Tcl_Interp *interp, CONST char *command, int numChars, \
            Command *cmdPtr, int result, int traceFlags, int objc, \
	    Tcl_Obj *CONST objv[])
}

d649 1
a649 1
    OSErr FSpFindFolder(short vRefNum, OSType folderType,
d653 1
a653 1
    void GetGlobalMouseTcl(Point *mouse)
d661 1
a661 1
    pascal OSErr FSpGetDirectoryIDTcl(CONST FSSpec *spec, long *theDirID,
d665 1
a665 1
    pascal short FSpOpenResFileCompatTcl(CONST FSSpec *spec,
d669 1
a669 1
    pascal void FSpCreateResFileCompatTcl(CONST FSSpec *spec, OSType creator,
d680 1
a680 1
    OSErr FSpPathFromLocation(FSSpecPtr theSpec, int *length,
d708 1
a708 1
    int TclMacRegisterResourceFork(short fileRef, Tcl_Obj *tokenPtr,
a723 3
declare 24 mac {
    char * TclpGetTZName(int isdst)
}
d725 1
a725 5
    int TclMacChmod(CONST char *path, int mode)
}
# version of FSpLocationFromPath that doesn't resolve the last path component
declare 26 mac {
    int FSpLLocationFromPath(int length, CONST char *path, FSSpecPtr theSpec)
d731 1
a731 1
declare 0 {win cygwin} {
d734 1
a734 1
declare 1 {win cygwin} {
d737 2
a738 2
declare 2 {win cygwin} {
    struct servent * TclWinGetServByName(CONST char *nm,
d741 2
a742 2
declare 3 {win cygwin} {
    int TclWinGetSockOpt(SOCKET s, int level, int optname,
d745 1
a745 1
declare 4 {win cygwin} {
d752 1
a752 1
declare 6 {win cygwin} {
d755 2
a756 2
declare 7 {win cygwin} {
    int TclWinSetSockOpt(SOCKET s, int level, int optname,
d759 1
a759 1
declare 8 {win cygwin} {
d762 1
a762 1
declare 9 {win cygwin} {
d772 1
a772 1
declare 11 {win cygwin} {
d775 1
a775 1
declare 12 {win cygwin} {
d778 2
a779 2
declare 13 {win cygwin} {
    Tcl_Channel TclpCreateCommandChannel(TclFile readFile,
d782 1
a782 1
declare 14 {win cygwin} {
d785 3
a787 3
declare 15 {win cygwin} {
    int TclpCreateProcess(Tcl_Interp *interp, int argc, CONST char **argv,
	    TclFile inputFile, TclFile outputFile, TclFile errorFile,
d797 1
a797 1
declare 18 {win cygwin} {
d800 1
a800 1
declare 19 {win cygwin} {
d803 1
a803 1
declare 20 {win cygwin} {
d806 3
a808 5

# removed permanently for 8.4
#declare 21 win {
#    void TclpAsyncMark(Tcl_AsyncHandler async)
#}
d811 1
a811 1
declare 22 {win cygwin} {
d814 1
a814 1
declare 23 {win cygwin} {
d817 1
a817 1
declare 24 {win cygwin} {
d820 1
a820 1
declare 25 {win cygwin} {
d823 1
a823 1
declare 26 {win cygwin} {
a826 6
# Added in Tcl 8.3.3 / 8.4

declare 27 {win cygwin} {
    void TclWinFlushDirtyChannels (void)
}

d839 1
a839 1
    Tcl_Channel TclpCreateCommandChannel(TclFile readFile,
d846 2
a847 2
    int TclpCreateProcess(Tcl_Interp *interp, int argc, CONST char **argv,
	    TclFile inputFile, TclFile outputFile, TclFile errorFile,
d852 2
a853 1
#      TclFile TclpCreateTempFile(char *contents, Tcl_DString *namePtr)
a868 18
}

# Added in 8.4:

declare 10 unix {
    Tcl_DirEntry * TclpReaddir(DIR * dir)
}

declare 11 unix {
    struct tm * TclpLocaltime(time_t * clock)
}

declare 12 unix {
    struct tm * TclpGmtime(time_t * clock)
}

declare 13 unix {
    char * TclpInetNtoa(struct in_addr addr)
@


1.2
log
@touched all Tcl files to ease next import.
@
text
@@


1.2.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@@


1.2.16.2
log
@2003-02-07  David Carlton  <carlton@@math.stanford.edu>

	* Merge with mainline; tag is carlton_dictionary-20030207-merge.
@
text
@a9 2
# Copyright (c) 2001 by Kevin B. Kenny.  All rights reserved.
#
d26 3
a28 4
# Replaced by Tcl_FSAccess in 8.4:
#declare 0 generic {
#    int TclAccess(CONST char *path, int mode)
#}
d43 1
a43 1
    int TclCleanupChildren(Tcl_Interp *interp, int numPids, Tcl_Pid *pidPtr,
d53 1
a53 1
    int TclCopyChannel(Tcl_Interp *interp, Tcl_Channel inChan,
d60 2
a61 2
    int TclCreatePipeline(Tcl_Interp *interp, int argc, CONST char **argv,
	    Tcl_Pid **pidArrayPtr, TclFile *inPipePtr, TclFile *outPipePtr,
d65 1
a65 2
    int TclCreateProc(Tcl_Interp *interp, Namespace *nsPtr, 
	    CONST char *procName,
d75 2
a76 2
    int TclDoGlob(Tcl_Interp *interp, char *separators,
	    Tcl_DString *headPtr, char *tail, Tcl_GlobTypeData *types)
d88 15
a102 16
# Removed in 8.4
#declare 17 generic {
#    int TclFileAttrsCmd(Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
#}
#declare 18 generic {
#    int TclFileCopyCmd(Tcl_Interp *interp, int argc, char **argv)
#}
#declare 19 generic {
#    int TclFileDeleteCmd(Tcl_Interp *interp, int argc, char **argv)
#}
#declare 20 generic {
#    int TclFileMakeDirsCmd(Tcl_Interp *interp, int argc, char **argv)
#}
#declare 21 generic {
#    int TclFileRenameCmd(Tcl_Interp *interp, int argc, char **argv)
#}
d104 2
a105 2
    int TclFindElement(Tcl_Interp *interp, CONST char *listStr,
	    int listLength, CONST char **elementPtr, CONST char **nextPtr,
d109 1
a109 1
    Proc * TclFindProc(Interp *iPtr, CONST char *procName)
d122 1
a122 1
    int TclGetDate(char *p, unsigned long now, long zone,
d128 4
a131 5
# Removed in 8.4b2:
#declare 29 generic {
#    Tcl_Obj * TclGetElementOfIndexedArray(Tcl_Interp *interp,
#	    int localIndex, Tcl_Obj *elemPtr, int flags)
#}
d140 1
a140 2
    int TclGetFrame(Tcl_Interp *interp, CONST char *str,
	    CallFrame **framePtrPtr)
d146 1
a146 1
    int TclGetIntForIndex(Tcl_Interp *interp, Tcl_Obj *objPtr,
d149 4
a152 5
# Removed in 8.4b2:
#declare 35 generic {
#    Tcl_Obj * TclGetIndexedScalar(Tcl_Interp *interp, int localIndex,
#	    int flags)
#}
d154 1
a154 1
    int TclGetLong(Tcl_Interp *interp, CONST char *str, long *longPtr)
d160 4
a163 4
    int TclGetNamespaceForQualName(Tcl_Interp *interp, CONST char *qualName,
	    Namespace *cxtNsPtr, int flags, Namespace **nsPtrPtr,
	    Namespace **altNsPtrPtr, Namespace **actualCxtPtrPtr,
	    CONST char **simpleNamePtr)
d169 1
a169 1
    int TclGetOpenMode(Tcl_Interp *interp, CONST char *str, int *seekFlagPtr)
d178 1
a178 1
    int TclGlobalInvoke(Tcl_Interp *interp, int argc, CONST84 char **argv, int flags)
d181 1
a181 1
    int TclGuessPackageName(CONST char *fileName, Tcl_DString *bufPtr)
d189 8
a196 10
# Removed in 8.4b2:
#declare 47 generic {
#    Tcl_Obj * TclIncrElementOfIndexedArray(Tcl_Interp *interp,
#	    int localIndex, Tcl_Obj *elemPtr, long incrAmount)
#}
# Removed in 8.4b2:
#declare 48 generic {
#    Tcl_Obj * TclIncrIndexedScalar(Tcl_Interp *interp, int localIndex,
#	    long incrAmount)
#}
d198 1
a198 1
    Tcl_Obj * TclIncrVar2(Tcl_Interp *interp, Tcl_Obj *part1Ptr,
d202 1
a202 1
    void TclInitCompiledLocals(Tcl_Interp *interp, CallFrame *framePtr,
d209 1
a209 1
    int TclInvoke(Tcl_Interp *interp, int argc, CONST84 char **argv, int flags)
d212 2
a213 2
    int TclInvokeObjectCommand(ClientData clientData, Tcl_Interp *interp,
	    int argc, CONST84 char **argv)
d216 1
a216 1
    int TclInvokeStringCommand(ClientData clientData, Tcl_Interp *interp,
d224 2
a225 2
#      int TclLoadFile(Tcl_Interp *interp, char *fileName, char *sym1,
#  	    char *sym2, Tcl_PackageInitProc **proc1Ptr,
d233 2
a234 2
    Var * TclLookupVar(Tcl_Interp *interp, CONST char *part1, CONST char *part2,
	    int flags, CONST char *msg, int createPart1, int createPart2,
d237 4
a240 5
# Replaced by Tcl_FSMatchInDirectory in 8.4
#declare 59 generic {
#    int TclpMatchFiles(Tcl_Interp *interp, char *separators,
#	    Tcl_DString *dirPtr, char *pattern, char *tail)
#}
d242 1
a242 1
    int TclNeedSpace(CONST char *start, CONST char *end)
d251 1
a251 1
    int TclObjInterpProc(ClientData clientData, Tcl_Interp *interp,
d255 1
a255 1
    int TclObjInvoke(Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[],
d259 1
a259 1
    int TclObjInvokeGlobal(Tcl_Interp *interp, int objc,
d268 3
a270 4
# Replaced by Tcl_FSAccess in 8.4:
#declare 68 generic {
#    int TclpAccess(CONST char *path, int mode)
#}
d274 13
a286 13
#declare 70 generic {
#    int TclpCopyFile(CONST char *source, CONST char *dest)
#}
#declare 71 generic {
#    int TclpCopyDirectory(CONST char *source, CONST char *dest,
#	    Tcl_DString *errorPtr)
#}
#declare 72 generic {
#    int TclpCreateDirectory(CONST char *path)
#}
#declare 73 generic {
#    int TclpDeleteFile(CONST char *path)
#}
a295 2

# deprecated
a298 1

d302 7
a308 9
# Replaced by Tcl_FSListVolumes in 8.4:
#declare 79 generic {
#    int TclpListVolumes(Tcl_Interp *interp)
#}
# Replaced by Tcl_FSOpenFileChannel in 8.4:
#declare 80 generic {
#    Tcl_Channel TclpOpenFileChannel(Tcl_Interp *interp, char *fileName,
#	    char *modeString, int permissions)
#}
d312 7
a318 7
#declare 82 generic {
#    int TclpRemoveDirectory(CONST char *path, int recursive,
#	    Tcl_DString *errorPtr)
#}
#declare 83 generic {
#    int TclpRenameFile(CONST char *source, CONST char *dest)
#}
d321 1
a321 1
#      int TclParseBraces(Tcl_Interp *interp, char *str, char **termPtr,
d325 1
a325 1
#      int TclParseNestedCmd(Tcl_Interp *interp, char *str, int flags,
d329 1
a329 1
#      int TclParseQuotes(Tcl_Interp *interp, char *str, int termChar,
d336 2
a337 2
    char * TclPrecTraceProc(ClientData clientData, Tcl_Interp *interp,
	    CONST char *name1, CONST char *name2, int flags)
d340 1
a340 1
    int TclPreventAliasLoop(Tcl_Interp *interp, Tcl_Interp *cmdInterp,
d351 2
a352 2
    int TclProcCompileProc(Tcl_Interp *interp, Proc *procPtr,
	    Tcl_Obj *bodyPtr, Namespace *nsPtr, CONST char *description,
d359 5
a363 2
    int TclProcInterpProc(ClientData clientData, Tcl_Interp *interp,
	    int argc, CONST84 char **argv)
a364 4
# Replaced by Tcl_FSStat in 8.4:
#declare 95 generic {
#    int TclpStat(CONST char *path, Tcl_StatBuf *buf)
#}
d374 9
a382 11
# Removed in 8.4b2:
#declare 99 generic {
#    Tcl_Obj * TclSetElementOfIndexedArray(Tcl_Interp *interp, int localIndex,
#	    Tcl_Obj *elemPtr, Tcl_Obj *objPtr, int flags)
#}
# Removed in 8.4b2:
#declare 100 generic {
#    Tcl_Obj * TclSetIndexedScalar(Tcl_Interp *interp, int localIndex,
#	    Tcl_Obj *objPtr, int flags)
#}
declare 101 generic {
d389 1
a389 1
    int TclSockGetPort(Tcl_Interp *interp, char *str, char *proto,
d395 3
a397 4
# Replaced by Tcl_FSStat in 8.4:
#declare 105 generic {
#    int TclStat(CONST char *path, Tcl_StatBuf *buf)
#}
d419 2
a420 2
    void Tcl_AddInterpResolvers(Tcl_Interp *interp, CONST char *name,
	    Tcl_ResolveCmdProc *cmdProc, Tcl_ResolveVarProc *varProc,
d424 1
a424 1
    int Tcl_AppendExportList(Tcl_Interp *interp, Tcl_Namespace *nsPtr,
d428 1
a428 1
    Tcl_Namespace * Tcl_CreateNamespace(Tcl_Interp *interp, CONST char *name,
d435 2
a436 2
    int Tcl_Export(Tcl_Interp *interp, Tcl_Namespace *nsPtr,
	    CONST char *pattern, int resetListFirst)
d439 1
a439 1
    Tcl_Command Tcl_FindCommand(Tcl_Interp *interp, CONST char *name,
d443 1
a443 1
    Tcl_Namespace * Tcl_FindNamespace(Tcl_Interp *interp, CONST char *name,
d447 1
a447 1
    int Tcl_GetInterpResolvers(Tcl_Interp *interp, CONST char *name,
d451 1
a451 1
    int Tcl_GetNamespaceResolvers(Tcl_Namespace *namespacePtr,
d455 1
a455 1
    Tcl_Var Tcl_FindNamespaceVar(Tcl_Interp *interp, CONST char *name,
d459 2
a460 2
    int Tcl_ForgetImport(Tcl_Interp *interp, Tcl_Namespace *nsPtr,
	    CONST char *pattern)
d466 1
a466 1
    void Tcl_GetCommandFullName(Tcl_Interp *interp, Tcl_Command command,
d476 1
a476 1
    void Tcl_GetVariableFullName(Tcl_Interp *interp, Tcl_Var variable,
d480 2
a481 2
    int Tcl_Import(Tcl_Interp *interp, Tcl_Namespace *nsPtr,
	    CONST char *pattern, int allowOverwrite)
d487 1
a487 1
    int Tcl_PushCallFrame(Tcl_Interp* interp, Tcl_CallFrame *framePtr,
d491 1
a491 1
    int Tcl_RemoveInterpResolvers(Tcl_Interp *interp, CONST char *name)
d494 2
a495 2
    void Tcl_SetNamespaceResolvers(Tcl_Namespace *namespacePtr,
	    Tcl_ResolveCmdProc *cmdProc, Tcl_ResolveVarProc *varProc,
d505 2
a506 2
    size_t TclpStrftime(char *s, size_t maxsize, CONST char *format,
	    CONST struct tm *t, int useGMT)
d514 3
a516 3
#declare 137 generic {
#   int TclpChdir(CONST char *dirName)
#}
d518 6
a523 1
    CONST84_RETURN char * TclGetEnv(CONST char *name, Tcl_DString *valuePtr)
a524 5
#declare 139 generic {
#    int TclpLoadFile(Tcl_Interp *interp, char *fileName, char *sym1,
#	    char *sym2, Tcl_PackageInitProc **proc1Ptr,
#	    Tcl_PackageInitProc **proc2Ptr, ClientData *clientDataPtr)
#}
d526 1
a526 1
    int TclLooksLikeInt(CONST char *bytes, int length)
a527 1
# This is used by TclX, but should otherwise be considered private
d529 1
a529 1
    CONST84_RETURN char *TclpGetCwd(Tcl_Interp *interp, Tcl_DString *cwdPtr)
d532 1
a532 1
    int TclSetByteCodeFromAny(Tcl_Interp *interp, Tcl_Obj *objPtr,
d536 1
a536 1
    int TclAddLiteralObj(struct CompileEnv *envPtr, Tcl_Obj *objPtr,
d540 1
a540 1
    void TclHideLiteral(Tcl_Interp *interp, struct CompileEnv *envPtr,
d569 1
a569 1
    void TclRegExpRangeUniChar(Tcl_RegExp re, int index, int *startPtr,
d580 1
a580 1
# moved to tclTest.c (static) in 8.3.2/8.4a2
d586 1
a586 1
#    int TclTestChannelEventCmd(ClientData clientData,
d591 1
a591 1
    void TclRegError (Tcl_Interp *interp, CONST char *msg,
d595 1
a595 1
    Var * TclVarTraceExists (Tcl_Interp *interp, CONST char *varName)
d598 1
a598 1
    void TclSetStartupScriptFileName(CONST char *filename)
d601 5
a605 1
    CONST84_RETURN char *TclGetStartupScriptFileName(void)
a606 4
#declare 160 generic {
#    int TclpMatchFilesTypes(Tcl_Interp *interp, char *separators,
#	    Tcl_DString *dirPtr, char *pattern, char *tail, GlobTypeData *types)
#}
d610 1
a610 1
    int TclChannelTransform(Tcl_Interp *interp, Tcl_Channel chan,
a616 50
# ALERT: The result of 'TclGetInstructionTable' is actually an
# "InstructionDesc*" but we do not want to describe this structure in
# "tclInt.h". It is described in "tclCompile.h". Use a cast to the
# correct type when calling this procedure.

declare 163 generic {
	void * TclGetInstructionTable (void)
}

# ALERT: The argument of 'TclExpandCodeArray' is actually a
# "CompileEnv*" but we do not want to describe this structure in
# "tclInt.h". It is described in "tclCompile.h".

declare 164 generic {
	void TclExpandCodeArray (void *envPtr)
}

# These functions are vfs aware, but are generally only useful internally.
declare 165 generic {
    void TclpSetInitialEncodings(void)
}

# New function due to TIP #33
declare 166 generic {
    int TclListObjSetElement(Tcl_Interp *interp, Tcl_Obj *listPtr, 
	    int index, Tcl_Obj *valuePtr)
}

# VFS-aware versions of Tcl*StartupScriptFileName (158 and 159 above)
declare 167 generic {
    void TclSetStartupScriptPath(Tcl_Obj *pathPtr)
}
declare 168 generic {
    Tcl_Obj *TclGetStartupScriptPath(void)
}
# variant of Tcl_UtfNCmp that takes n as bytes, not chars
declare 169 generic {
    int TclpUtfNcmp2(CONST char *s1, CONST char *s2, unsigned long n)
}
declare 170 generic {
    int TclCheckInterpTraces (Tcl_Interp *interp, CONST char *command, int numChars, \
            Command *cmdPtr, int result, int traceFlags, int objc, \
	    Tcl_Obj *CONST objv[])
}
declare 171 generic {
    int TclCheckExecutionTraces (Tcl_Interp *interp, CONST char *command, int numChars, \
            Command *cmdPtr, int result, int traceFlags, int objc, \
	    Tcl_Obj *CONST objv[])
}

d649 1
a649 1
    OSErr FSpFindFolder(short vRefNum, OSType folderType,
d653 1
a653 1
    void GetGlobalMouseTcl(Point *mouse)
d661 1
a661 1
    pascal OSErr FSpGetDirectoryIDTcl(CONST FSSpec *spec, long *theDirID,
d665 1
a665 1
    pascal short FSpOpenResFileCompatTcl(CONST FSSpec *spec,
d669 1
a669 1
    pascal void FSpCreateResFileCompatTcl(CONST FSSpec *spec, OSType creator,
d680 1
a680 1
    OSErr FSpPathFromLocation(FSSpecPtr theSpec, int *length,
d708 1
a708 1
    int TclMacRegisterResourceFork(short fileRef, Tcl_Obj *tokenPtr,
a723 3
declare 24 mac {
    char * TclpGetTZName(int isdst)
}
d725 1
a725 5
    int TclMacChmod(CONST char *path, int mode)
}
# version of FSpLocationFromPath that doesn't resolve the last path component
declare 26 mac {
    int FSpLLocationFromPath(int length, CONST char *path, FSSpecPtr theSpec)
d738 1
a738 1
    struct servent * TclWinGetServByName(CONST char *nm,
d742 1
a742 1
    int TclWinGetSockOpt(SOCKET s, int level, int optname,
d756 1
a756 1
    int TclWinSetSockOpt(SOCKET s, int level, int optname,
d779 1
a779 1
    Tcl_Channel TclpCreateCommandChannel(TclFile readFile,
d786 2
a787 2
    int TclpCreateProcess(Tcl_Interp *interp, int argc, CONST char **argv,
	    TclFile inputFile, TclFile outputFile, TclFile errorFile,
d806 3
a808 5

# removed permanently for 8.4
#declare 21 win {
#    void TclpAsyncMark(Tcl_AsyncHandler async)
#}
a826 6
# Added in Tcl 8.3.3 / 8.4

declare 27 win {
    void TclWinFlushDirtyChannels (void)
}

d839 1
a839 1
    Tcl_Channel TclpCreateCommandChannel(TclFile readFile,
d846 2
a847 2
    int TclpCreateProcess(Tcl_Interp *interp, int argc, CONST char **argv,
	    TclFile inputFile, TclFile outputFile, TclFile errorFile,
d852 2
a853 1
#      TclFile TclpCreateTempFile(char *contents, Tcl_DString *namePtr)
a868 18
}

# Added in 8.4:

declare 10 unix {
    Tcl_DirEntry * TclpReaddir(DIR * dir)
}

declare 11 unix {
    struct tm * TclpLocaltime(time_t * clock)
}

declare 12 unix {
    struct tm * TclpGmtime(time_t * clock)
}

declare 13 unix {
    char * TclpInetNtoa(struct in_addr addr)
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@Tcl 8.3 upgrade
@
text
@@


1.1.1.2
log
@import tcl 8.4.0
@
text
@a9 2
# Copyright (c) 2001 by Kevin B. Kenny.  All rights reserved.
#
d13 1
a13 1
# RCS: @@(#) $Id: tclInt.decls,v 1.55 2002/08/06 01:49:27 das Exp $
d26 3
a28 4
# Replaced by Tcl_FSAccess in 8.4:
#declare 0 generic {
#    int TclAccess(CONST char *path, int mode)
#}
d43 1
a43 1
    int TclCleanupChildren(Tcl_Interp *interp, int numPids, Tcl_Pid *pidPtr,
d53 1
a53 1
    int TclCopyChannel(Tcl_Interp *interp, Tcl_Channel inChan,
d60 2
a61 2
    int TclCreatePipeline(Tcl_Interp *interp, int argc, CONST char **argv,
	    Tcl_Pid **pidArrayPtr, TclFile *inPipePtr, TclFile *outPipePtr,
d65 1
a65 2
    int TclCreateProc(Tcl_Interp *interp, Namespace *nsPtr, 
	    CONST char *procName,
d75 2
a76 2
    int TclDoGlob(Tcl_Interp *interp, char *separators,
	    Tcl_DString *headPtr, char *tail, Tcl_GlobTypeData *types)
d88 15
a102 16
# Removed in 8.4
#declare 17 generic {
#    int TclFileAttrsCmd(Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[])
#}
#declare 18 generic {
#    int TclFileCopyCmd(Tcl_Interp *interp, int argc, char **argv)
#}
#declare 19 generic {
#    int TclFileDeleteCmd(Tcl_Interp *interp, int argc, char **argv)
#}
#declare 20 generic {
#    int TclFileMakeDirsCmd(Tcl_Interp *interp, int argc, char **argv)
#}
#declare 21 generic {
#    int TclFileRenameCmd(Tcl_Interp *interp, int argc, char **argv)
#}
d104 2
a105 2
    int TclFindElement(Tcl_Interp *interp, CONST char *listStr,
	    int listLength, CONST char **elementPtr, CONST char **nextPtr,
d109 1
a109 1
    Proc * TclFindProc(Interp *iPtr, CONST char *procName)
d122 1
a122 1
    int TclGetDate(char *p, unsigned long now, long zone,
d128 4
a131 5
# Removed in 8.4b2:
#declare 29 generic {
#    Tcl_Obj * TclGetElementOfIndexedArray(Tcl_Interp *interp,
#	    int localIndex, Tcl_Obj *elemPtr, int flags)
#}
d140 1
a140 2
    int TclGetFrame(Tcl_Interp *interp, CONST char *str,
	    CallFrame **framePtrPtr)
d146 1
a146 1
    int TclGetIntForIndex(Tcl_Interp *interp, Tcl_Obj *objPtr,
d149 4
a152 5
# Removed in 8.4b2:
#declare 35 generic {
#    Tcl_Obj * TclGetIndexedScalar(Tcl_Interp *interp, int localIndex,
#	    int flags)
#}
d154 1
a154 1
    int TclGetLong(Tcl_Interp *interp, CONST char *str, long *longPtr)
d160 4
a163 4
    int TclGetNamespaceForQualName(Tcl_Interp *interp, CONST char *qualName,
	    Namespace *cxtNsPtr, int flags, Namespace **nsPtrPtr,
	    Namespace **altNsPtrPtr, Namespace **actualCxtPtrPtr,
	    CONST char **simpleNamePtr)
d169 1
a169 1
    int TclGetOpenMode(Tcl_Interp *interp, CONST char *str, int *seekFlagPtr)
d178 1
a178 1
    int TclGlobalInvoke(Tcl_Interp *interp, int argc, CONST84 char **argv, int flags)
d181 1
a181 1
    int TclGuessPackageName(CONST char *fileName, Tcl_DString *bufPtr)
d189 8
a196 10
# Removed in 8.4b2:
#declare 47 generic {
#    Tcl_Obj * TclIncrElementOfIndexedArray(Tcl_Interp *interp,
#	    int localIndex, Tcl_Obj *elemPtr, long incrAmount)
#}
# Removed in 8.4b2:
#declare 48 generic {
#    Tcl_Obj * TclIncrIndexedScalar(Tcl_Interp *interp, int localIndex,
#	    long incrAmount)
#}
d198 1
a198 1
    Tcl_Obj * TclIncrVar2(Tcl_Interp *interp, Tcl_Obj *part1Ptr,
d202 1
a202 1
    void TclInitCompiledLocals(Tcl_Interp *interp, CallFrame *framePtr,
d209 1
a209 1
    int TclInvoke(Tcl_Interp *interp, int argc, CONST84 char **argv, int flags)
d212 2
a213 2
    int TclInvokeObjectCommand(ClientData clientData, Tcl_Interp *interp,
	    int argc, CONST84 char **argv)
d216 1
a216 1
    int TclInvokeStringCommand(ClientData clientData, Tcl_Interp *interp,
d224 2
a225 2
#      int TclLoadFile(Tcl_Interp *interp, char *fileName, char *sym1,
#  	    char *sym2, Tcl_PackageInitProc **proc1Ptr,
d233 2
a234 2
    Var * TclLookupVar(Tcl_Interp *interp, CONST char *part1, CONST char *part2,
	    int flags, CONST char *msg, int createPart1, int createPart2,
d237 4
a240 5
# Replaced by Tcl_FSMatchInDirectory in 8.4
#declare 59 generic {
#    int TclpMatchFiles(Tcl_Interp *interp, char *separators,
#	    Tcl_DString *dirPtr, char *pattern, char *tail)
#}
d242 1
a242 1
    int TclNeedSpace(CONST char *start, CONST char *end)
d251 1
a251 1
    int TclObjInterpProc(ClientData clientData, Tcl_Interp *interp,
d255 1
a255 1
    int TclObjInvoke(Tcl_Interp *interp, int objc, Tcl_Obj *CONST objv[],
d259 1
a259 1
    int TclObjInvokeGlobal(Tcl_Interp *interp, int objc,
d268 3
a270 4
# Replaced by Tcl_FSAccess in 8.4:
#declare 68 generic {
#    int TclpAccess(CONST char *path, int mode)
#}
d274 13
a286 13
#declare 70 generic {
#    int TclpCopyFile(CONST char *source, CONST char *dest)
#}
#declare 71 generic {
#    int TclpCopyDirectory(CONST char *source, CONST char *dest,
#	    Tcl_DString *errorPtr)
#}
#declare 72 generic {
#    int TclpCreateDirectory(CONST char *path)
#}
#declare 73 generic {
#    int TclpDeleteFile(CONST char *path)
#}
a295 2

# deprecated
a298 1

d302 7
a308 9
# Replaced by Tcl_FSListVolumes in 8.4:
#declare 79 generic {
#    int TclpListVolumes(Tcl_Interp *interp)
#}
# Replaced by Tcl_FSOpenFileChannel in 8.4:
#declare 80 generic {
#    Tcl_Channel TclpOpenFileChannel(Tcl_Interp *interp, char *fileName,
#	    char *modeString, int permissions)
#}
d312 7
a318 7
#declare 82 generic {
#    int TclpRemoveDirectory(CONST char *path, int recursive,
#	    Tcl_DString *errorPtr)
#}
#declare 83 generic {
#    int TclpRenameFile(CONST char *source, CONST char *dest)
#}
d321 1
a321 1
#      int TclParseBraces(Tcl_Interp *interp, char *str, char **termPtr,
d325 1
a325 1
#      int TclParseNestedCmd(Tcl_Interp *interp, char *str, int flags,
d329 1
a329 1
#      int TclParseQuotes(Tcl_Interp *interp, char *str, int termChar,
d336 2
a337 2
    char * TclPrecTraceProc(ClientData clientData, Tcl_Interp *interp,
	    CONST char *name1, CONST char *name2, int flags)
d340 1
a340 1
    int TclPreventAliasLoop(Tcl_Interp *interp, Tcl_Interp *cmdInterp,
d351 2
a352 2
    int TclProcCompileProc(Tcl_Interp *interp, Proc *procPtr,
	    Tcl_Obj *bodyPtr, Namespace *nsPtr, CONST char *description,
d359 5
a363 2
    int TclProcInterpProc(ClientData clientData, Tcl_Interp *interp,
	    int argc, CONST84 char **argv)
a364 4
# Replaced by Tcl_FSStat in 8.4:
#declare 95 generic {
#    int TclpStat(CONST char *path, Tcl_StatBuf *buf)
#}
d374 8
a381 10
# Removed in 8.4b2:
#declare 99 generic {
#    Tcl_Obj * TclSetElementOfIndexedArray(Tcl_Interp *interp, int localIndex,
#	    Tcl_Obj *elemPtr, Tcl_Obj *objPtr, int flags)
#}
# Removed in 8.4b2:
#declare 100 generic {
#    Tcl_Obj * TclSetIndexedScalar(Tcl_Interp *interp, int localIndex,
#	    Tcl_Obj *objPtr, int flags)
#}
d389 1
a389 1
    int TclSockGetPort(Tcl_Interp *interp, char *str, char *proto,
d395 3
a397 4
# Replaced by Tcl_FSStat in 8.4:
#declare 105 generic {
#    int TclStat(CONST char *path, Tcl_StatBuf *buf)
#}
d419 2
a420 2
    void Tcl_AddInterpResolvers(Tcl_Interp *interp, CONST char *name,
	    Tcl_ResolveCmdProc *cmdProc, Tcl_ResolveVarProc *varProc,
d424 1
a424 1
    int Tcl_AppendExportList(Tcl_Interp *interp, Tcl_Namespace *nsPtr,
d428 1
a428 1
    Tcl_Namespace * Tcl_CreateNamespace(Tcl_Interp *interp, CONST char *name,
d435 2
a436 2
    int Tcl_Export(Tcl_Interp *interp, Tcl_Namespace *nsPtr,
	    CONST char *pattern, int resetListFirst)
d439 1
a439 1
    Tcl_Command Tcl_FindCommand(Tcl_Interp *interp, CONST char *name,
d443 1
a443 1
    Tcl_Namespace * Tcl_FindNamespace(Tcl_Interp *interp, CONST char *name,
d447 1
a447 1
    int Tcl_GetInterpResolvers(Tcl_Interp *interp, CONST char *name,
d451 1
a451 1
    int Tcl_GetNamespaceResolvers(Tcl_Namespace *namespacePtr,
d455 1
a455 1
    Tcl_Var Tcl_FindNamespaceVar(Tcl_Interp *interp, CONST char *name,
d459 2
a460 2
    int Tcl_ForgetImport(Tcl_Interp *interp, Tcl_Namespace *nsPtr,
	    CONST char *pattern)
d466 1
a466 1
    void Tcl_GetCommandFullName(Tcl_Interp *interp, Tcl_Command command,
d476 1
a476 1
    void Tcl_GetVariableFullName(Tcl_Interp *interp, Tcl_Var variable,
d480 2
a481 2
    int Tcl_Import(Tcl_Interp *interp, Tcl_Namespace *nsPtr,
	    CONST char *pattern, int allowOverwrite)
d487 1
a487 1
    int Tcl_PushCallFrame(Tcl_Interp* interp, Tcl_CallFrame *framePtr,
d491 1
a491 1
    int Tcl_RemoveInterpResolvers(Tcl_Interp *interp, CONST char *name)
d494 2
a495 2
    void Tcl_SetNamespaceResolvers(Tcl_Namespace *namespacePtr,
	    Tcl_ResolveCmdProc *cmdProc, Tcl_ResolveVarProc *varProc,
d505 2
a506 2
    size_t TclpStrftime(char *s, size_t maxsize, CONST char *format,
	    CONST struct tm *t, int useGMT)
d514 3
a516 3
#declare 137 generic {
#   int TclpChdir(CONST char *dirName)
#}
d518 6
a523 1
    CONST84_RETURN char * TclGetEnv(CONST char *name, Tcl_DString *valuePtr)
a524 5
#declare 139 generic {
#    int TclpLoadFile(Tcl_Interp *interp, char *fileName, char *sym1,
#	    char *sym2, Tcl_PackageInitProc **proc1Ptr,
#	    Tcl_PackageInitProc **proc2Ptr, ClientData *clientDataPtr)
#}
d526 1
a526 1
    int TclLooksLikeInt(CONST char *bytes, int length)
a527 1
# This is used by TclX, but should otherwise be considered private
d529 1
a529 1
    CONST84_RETURN char *TclpGetCwd(Tcl_Interp *interp, Tcl_DString *cwdPtr)
d532 1
a532 1
    int TclSetByteCodeFromAny(Tcl_Interp *interp, Tcl_Obj *objPtr,
d536 1
a536 1
    int TclAddLiteralObj(struct CompileEnv *envPtr, Tcl_Obj *objPtr,
d540 1
a540 1
    void TclHideLiteral(Tcl_Interp *interp, struct CompileEnv *envPtr,
d569 1
a569 1
    void TclRegExpRangeUniChar(Tcl_RegExp re, int index, int *startPtr,
d580 1
a580 1
# moved to tclTest.c (static) in 8.3.2/8.4a2
d586 1
a586 1
#    int TclTestChannelEventCmd(ClientData clientData,
d591 1
a591 1
    void TclRegError (Tcl_Interp *interp, CONST char *msg,
d595 1
a595 1
    Var * TclVarTraceExists (Tcl_Interp *interp, CONST char *varName)
d598 1
a598 1
    void TclSetStartupScriptFileName(CONST char *filename)
d601 5
a605 1
    CONST84_RETURN char *TclGetStartupScriptFileName(void)
a606 4
#declare 160 generic {
#    int TclpMatchFilesTypes(Tcl_Interp *interp, char *separators,
#	    Tcl_DString *dirPtr, char *pattern, char *tail, GlobTypeData *types)
#}
d610 1
a610 1
    int TclChannelTransform(Tcl_Interp *interp, Tcl_Channel chan,
a616 50
# ALERT: The result of 'TclGetInstructionTable' is actually an
# "InstructionDesc*" but we do not want to describe this structure in
# "tclInt.h". It is described in "tclCompile.h". Use a cast to the
# correct type when calling this procedure.

declare 163 generic {
	void * TclGetInstructionTable (void)
}

# ALERT: The argument of 'TclExpandCodeArray' is actually a
# "CompileEnv*" but we do not want to describe this structure in
# "tclInt.h". It is described in "tclCompile.h".

declare 164 generic {
	void TclExpandCodeArray (void *envPtr)
}

# These functions are vfs aware, but are generally only useful internally.
declare 165 generic {
    void TclpSetInitialEncodings(void)
}

# New function due to TIP #33
declare 166 generic {
    int TclListObjSetElement(Tcl_Interp *interp, Tcl_Obj *listPtr, 
	    int index, Tcl_Obj *valuePtr)
}

# VFS-aware versions of Tcl*StartupScriptFileName (158 and 159 above)
declare 167 generic {
    void TclSetStartupScriptPath(Tcl_Obj *pathPtr)
}
declare 168 generic {
    Tcl_Obj *TclGetStartupScriptPath(void)
}
# variant of Tcl_UtfNCmp that takes n as bytes, not chars
declare 169 generic {
    int TclpUtfNcmp2(CONST char *s1, CONST char *s2, unsigned long n)
}
declare 170 generic {
    int TclCheckInterpTraces (Tcl_Interp *interp, CONST char *command, int numChars, \
            Command *cmdPtr, int result, int traceFlags, int objc, \
	    Tcl_Obj *CONST objv[])
}
declare 171 generic {
    int TclCheckExecutionTraces (Tcl_Interp *interp, CONST char *command, int numChars, \
            Command *cmdPtr, int result, int traceFlags, int objc, \
	    Tcl_Obj *CONST objv[])
}

d649 1
a649 1
    OSErr FSpFindFolder(short vRefNum, OSType folderType,
d653 1
a653 1
    void GetGlobalMouseTcl(Point *mouse)
d661 1
a661 1
    pascal OSErr FSpGetDirectoryIDTcl(CONST FSSpec *spec, long *theDirID,
d665 1
a665 1
    pascal short FSpOpenResFileCompatTcl(CONST FSSpec *spec,
d669 1
a669 1
    pascal void FSpCreateResFileCompatTcl(CONST FSSpec *spec, OSType creator,
d680 1
a680 1
    OSErr FSpPathFromLocation(FSSpecPtr theSpec, int *length,
d708 1
a708 1
    int TclMacRegisterResourceFork(short fileRef, Tcl_Obj *tokenPtr,
a723 3
declare 24 mac {
    char * TclpGetTZName(int isdst)
}
d725 1
a725 5
    int TclMacChmod(CONST char *path, int mode)
}
# version of FSpLocationFromPath that doesn't resolve the last path component
declare 26 mac {
    int FSpLLocationFromPath(int length, CONST char *path, FSSpecPtr theSpec)
d738 1
a738 1
    struct servent * TclWinGetServByName(CONST char *nm,
d742 1
a742 1
    int TclWinGetSockOpt(SOCKET s, int level, int optname,
d756 1
a756 1
    int TclWinSetSockOpt(SOCKET s, int level, int optname,
d779 1
a779 1
    Tcl_Channel TclpCreateCommandChannel(TclFile readFile,
d786 2
a787 2
    int TclpCreateProcess(Tcl_Interp *interp, int argc, CONST char **argv,
	    TclFile inputFile, TclFile outputFile, TclFile errorFile,
d806 3
a808 5

# removed permanently for 8.4
#declare 21 win {
#    void TclpAsyncMark(Tcl_AsyncHandler async)
#}
a826 6
# Added in Tcl 8.3.3 / 8.4

declare 27 win {
    void TclWinFlushDirtyChannels (void)
}

d839 1
a839 1
    Tcl_Channel TclpCreateCommandChannel(TclFile readFile,
d846 2
a847 2
    int TclpCreateProcess(Tcl_Interp *interp, int argc, CONST char **argv,
	    TclFile inputFile, TclFile outputFile, TclFile errorFile,
d852 2
a853 1
#      TclFile TclpCreateTempFile(char *contents, Tcl_DString *namePtr)
a868 18
}

# Added in 8.4:

declare 10 unix {
    Tcl_DirEntry * TclpReaddir(DIR * dir)
}

declare 11 unix {
    struct tm * TclpLocaltime(time_t * clock)
}

declare 12 unix {
    struct tm * TclpGmtime(time_t * clock)
}

declare 13 unix {
    char * TclpInetNtoa(struct in_addr addr)
@


1.1.1.3
log
@import tcl 8.4.1
@
text
@d15 1
a15 1
# RCS: @@(#) $Id: tclInt.decls,v 1.56 2002/10/09 11:54:09 das Exp $
d402 1
a402 1
declare 101 generic {
@


