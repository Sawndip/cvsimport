head	1.105;
access;
symbols
	binutils-2_24-branch:1.105.0.2
	binutils-2_24-branchpoint:1.105
	binutils-2_21_1:1.87.2.3
	binutils-2_23_2:1.101.2.2
	binutils-2_23_1:1.101.2.1
	binutils-2_23:1.101.2.1
	binutils-2_23-branch:1.101.0.2
	binutils-2_23-branchpoint:1.101
	binutils-2_22_branch:1.95.0.4
	binutils-2_22:1.95
	binutils-2_22-branch:1.95.0.2
	binutils-2_22-branchpoint:1.95
	binutils-2_21:1.87
	binutils-2_21-branch:1.87.0.2
	binutils-2_21-branchpoint:1.87
	binutils-2_20_1:1.79.2.1
	binutils-2_20:1.79.2.1
	binutils-arc-20081103-branch:1.76.0.6
	binutils-arc-20081103-branchpoint:1.76
	binutils-2_20-branch:1.79.0.2
	binutils-2_20-branchpoint:1.79
	dje-cgen-play1-branch:1.76.0.4
	dje-cgen-play1-branchpoint:1.76
	arc-20081103-branch:1.76.0.2
	arc-20081103-branchpoint:1.76
	binutils-2_19_1:1.75
	binutils-2_19:1.75
	binutils-2_19-branch:1.75.0.2
	binutils-2_19-branchpoint:1.75
	binutils-2_18:1.69
	binutils-2_18-branch:1.69.0.2
	binutils-2_18-branchpoint:1.69
	binutils-csl-coldfire-4_1-32:1.57.2.1
	binutils-csl-sourcerygxx-4_1-32:1.57.2.1
	binutils-csl-innovasic-fido-3_4_4-33:1.57.2.1
	binutils-csl-sourcerygxx-3_4_4-32:1.45.2.1
	binutils-csl-coldfire-4_1-30:1.57.2.1
	binutils-csl-sourcerygxx-4_1-30:1.57.2.1
	binutils-csl-coldfire-4_1-28:1.57.2.1
	binutils-csl-sourcerygxx-4_1-29:1.57.2.1
	binutils-csl-sourcerygxx-4_1-28:1.57.2.1
	binutils-csl-arm-2006q3-27:1.57.2.1
	binutils-csl-sourcerygxx-4_1-27:1.57.2.1
	binutils-csl-arm-2006q3-26:1.57.2.1
	binutils-csl-sourcerygxx-4_1-26:1.57.2.1
	binutils-csl-sourcerygxx-4_1-25:1.57.2.1
	binutils-csl-sourcerygxx-4_1-24:1.57.2.1
	binutils-csl-sourcerygxx-4_1-23:1.57.2.1
	binutils-csl-sourcerygxx-4_1-21:1.57.2.1
	binutils-csl-arm-2006q3-21:1.57.2.1
	binutils-csl-sourcerygxx-4_1-22:1.57.2.1
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.57.2.1
	binutils-csl-sourcerygxx-4_1-20:1.57.2.1
	binutils-csl-arm-2006q3-19:1.57.2.1
	binutils-csl-sourcerygxx-4_1-19:1.57.2.1
	binutils-csl-sourcerygxx-4_1-18:1.57.2.1
	binutils-csl-renesas-4_1-9:1.57.2.1
	binutils-csl-sourcerygxx-3_4_4-25:1.45.2.1
	binutils-csl-renesas-4_1-8:1.57
	binutils-csl-renesas-4_1-7:1.57
	binutils-csl-renesas-4_1-6:1.57
	binutils-csl-sourcerygxx-4_1-17:1.57
	binutils-csl-sourcerygxx-4_1-14:1.57
	binutils-csl-sourcerygxx-4_1-15:1.57
	binutils-csl-sourcerygxx-4_1-13:1.57
	binutils-2_17:1.57
	binutils-csl-sourcerygxx-4_1-12:1.57
	binutils-csl-sourcerygxx-3_4_4-21:1.57
	binutils-csl-wrs-linux-3_4_4-24:1.45.2.1
	binutils-csl-wrs-linux-3_4_4-23:1.45.2.1
	binutils-csl-sourcerygxx-4_1-9:1.57
	binutils-csl-sourcerygxx-4_1-8:1.57
	binutils-csl-sourcerygxx-4_1-7:1.57
	binutils-csl-arm-2006q1-6:1.57
	binutils-csl-sourcerygxx-4_1-6:1.57
	binutils-csl-wrs-linux-3_4_4-22:1.45.2.1
	binutils-csl-coldfire-4_1-11:1.57
	binutils-csl-sourcerygxx-3_4_4-19:1.57
	binutils-csl-coldfire-4_1-10:1.57
	binutils-csl-sourcerygxx-4_1-5:1.57
	binutils-csl-sourcerygxx-4_1-4:1.57
	binutils-csl-wrs-linux-3_4_4-21:1.45.2.1
	binutils-csl-morpho-4_1-4:1.57
	binutils-csl-sourcerygxx-3_4_4-17:1.57
	binutils-csl-wrs-linux-3_4_4-20:1.45.2.1
	binutils-2_17-branch:1.57.0.4
	binutils-2_17-branchpoint:1.57
	binutils-csl-2_17-branch:1.57.0.2
	binutils-csl-2_17-branchpoint:1.57
	binutils-csl-gxxpro-3_4-branch:1.45.2.1.0.4
	binutils-csl-gxxpro-3_4-branchpoint:1.45.2.1
	binutils-2_16_1:1.45.2.1
	binutils-csl-arm-2005q1b:1.45.2.1
	binutils-2_16:1.45.2.1
	binutils-csl-arm-2005q1a:1.45.2.1
	binutils-csl-arm-2005q1-branch:1.45.2.1.0.2
	binutils-csl-arm-2005q1-branchpoint:1.45.2.1
	binutils-2_16-branch:1.45.0.2
	binutils-2_16-branchpoint:1.45
	csl-arm-2004-q3d:1.38
	csl-arm-2004-q3:1.35
	binutils-2_15:1.27.6.2
	binutils-2_15-branchpoint:1.27
	csl-arm-2004-q1a:1.29
	csl-arm-2004-q1:1.29
	binutils-2_15-branch:1.27.0.6
	cagney_bfdfile-20040213-branch:1.27.0.4
	cagney_bfdfile-20040213-branchpoint:1.27
	cagney_bigcore-20040122-branch:1.27.0.2
	cagney_bigcore-20040122-branchpoint:1.27
	csl-arm-2003-q4:1.26
	binutils-2_14:1.22
	binutils-2_14-branch:1.22.0.2
	binutils-2_14-branchpoint:1.22
	binutils-2_13_2_1:1.16.2.3
	binutils-2_13_2:1.16.2.3
	binutils-2_13_1:1.16.2.3
	binutils-2_13:1.16
	binutils-2_13-branchpoint:1.16
	binutils-2_13-branch:1.16.0.2
	binutils-2_12_1:1.10
	binutils-2_12:1.10
	binutils-2_12-branch:1.10.0.2
	binutils-2_12-branchpoint:1.10
	cygnus_cvs_20020108_pre:1.10
	binutils-2_11_2:1.6.2.2
	binutils-2_11_1:1.6.2.2
	binutils-2_11:1.6
	x86_64versiong3:1.7
	binutils-2_11-branch:1.6.0.2
	binutils-2_10_1:1.3
	binutils-2_10:1.3
	binutils-2_10-branch:1.3.0.2
	binutils-2_10-branchpoint:1.3
	binutils_latest_snapshot:1.105
	repo-unification-2000-02-06:1.3
	binu_ss_19990721:1.2
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.105
date	2013.08.15.07.30.14;	author nickc;	state Exp;
branches;
next	1.104;

1.104
date	2013.01.10.20.08.02;	author hjl;	state Exp;
branches;
next	1.103;

1.103
date	2012.12.17.00.16.49;	author amodra;	state Exp;
branches;
next	1.102;

1.102
date	2012.08.06.22.27.52;	author macro;	state Exp;
branches;
next	1.101;

1.101
date	2012.06.15.15.13.32;	author amodra;	state Exp;
branches
	1.101.2.1;
next	1.100;

1.100
date	2012.06.11.13.23.50;	author hjl;	state Exp;
branches;
next	1.99;

1.99
date	2012.03.14.05.24.02;	author amodra;	state Exp;
branches;
next	1.98;

1.98
date	2012.03.08.13.53.03;	author gingold;	state Exp;
branches;
next	1.97;

1.97
date	2012.02.22.16.27.32;	author nickc;	state Exp;
branches;
next	1.96;

1.96
date	2012.02.17.14.09.56;	author amodra;	state Exp;
branches;
next	1.95;

1.95
date	2011.05.16.11.34.48;	author nathan;	state Exp;
branches;
next	1.94;

1.94
date	2011.05.03.14.56.14;	author amodra;	state Exp;
branches;
next	1.93;

1.93
date	2011.01.21.13.18.19;	author amodra;	state Exp;
branches;
next	1.92;

1.92
date	2011.01.13.13.29.55;	author amodra;	state Exp;
branches;
next	1.91;

1.91
date	2011.01.13.13.06.22;	author amodra;	state Exp;
branches;
next	1.90;

1.90
date	2011.01.12.12.07.19;	author amodra;	state Exp;
branches;
next	1.89;

1.89
date	2010.12.20.13.00.13;	author amodra;	state Exp;
branches;
next	1.88;

1.88
date	2010.12.20.06.27.10;	author amodra;	state Exp;
branches;
next	1.87;

1.87
date	2010.10.01.08.15.41;	author amodra;	state Exp;
branches
	1.87.2.1;
next	1.86;

1.86
date	2010.08.19.05.51.49;	author amodra;	state Exp;
branches;
next	1.85;

1.85
date	2010.08.12.13.36.50;	author amodra;	state Exp;
branches;
next	1.84;

1.84
date	2010.07.28.06.43.32;	author amodra;	state Exp;
branches;
next	1.83;

1.83
date	2010.05.26.14.10.15;	author hjl;	state Exp;
branches;
next	1.82;

1.82
date	2010.05.14.03.15.20;	author amodra;	state Exp;
branches;
next	1.81;

1.81
date	2009.11.23.14.41.32;	author pbrook;	state Exp;
branches;
next	1.80;

1.80
date	2009.09.11.15.27.35;	author nickc;	state Exp;
branches;
next	1.79;

1.79
date	2009.09.02.07.25.35;	author amodra;	state Exp;
branches
	1.79.2.1;
next	1.78;

1.78
date	2009.08.30.05.47.43;	author amodra;	state Exp;
branches;
next	1.77;

1.77
date	2009.08.29.22.11.01;	author nickc;	state Exp;
branches;
next	1.76;

1.76
date	2008.09.25.02.34.00;	author amodra;	state Exp;
branches;
next	1.75;

1.75
date	2008.08.21.13.10.54;	author jkratoch;	state Exp;
branches
	1.75.2.1;
next	1.74;

1.74
date	2008.05.07.14.30.41;	author amodra;	state Exp;
branches;
next	1.73;

1.73
date	2008.02.16.00.06.02;	author amodra;	state Exp;
branches;
next	1.72;

1.72
date	2008.02.15.03.35.53;	author amodra;	state Exp;
branches;
next	1.71;

1.71
date	2007.09.18.00.25.06;	author hjl;	state Exp;
branches;
next	1.70;

1.70
date	2007.08.17.13.23.08;	author amodra;	state Exp;
branches;
next	1.69;

1.69
date	2007.07.06.14.09.41;	author nickc;	state Exp;
branches;
next	1.68;

1.68
date	2007.06.18.12.38.22;	author nathan;	state Exp;
branches;
next	1.67;

1.67
date	2007.04.26.14.46.59;	author amodra;	state Exp;
branches;
next	1.66;

1.66
date	2007.04.02.16.32.03;	author hjl;	state Exp;
branches;
next	1.65;

1.65
date	2007.02.19.23.51.58;	author amodra;	state Exp;
branches;
next	1.64;

1.64
date	2007.01.06.22.03.45;	author nathan;	state Exp;
branches;
next	1.63;

1.63
date	2006.08.23.01.35.31;	author amodra;	state Exp;
branches;
next	1.62;

1.62
date	2006.08.16.08.31.45;	author amodra;	state Exp;
branches;
next	1.61;

1.61
date	2006.07.26.05.05.52;	author amodra;	state Exp;
branches;
next	1.60;

1.60
date	2006.06.19.13.17.44;	author amodra;	state Exp;
branches;
next	1.59;

1.59
date	2006.06.05.12.45.34;	author amodra;	state Exp;
branches;
next	1.58;

1.58
date	2006.05.30.16.45.31;	author hjl;	state Exp;
branches;
next	1.57;

1.57
date	2005.12.07.14.43.54;	author hjl;	state Exp;
branches
	1.57.2.1;
next	1.56;

1.56
date	2005.09.20.03.00.53;	author amodra;	state Exp;
branches;
next	1.55;

1.55
date	2005.09.07.06.27.36;	author amodra;	state Exp;
branches;
next	1.54;

1.54
date	2005.08.05.13.52.13;	author hjl;	state Exp;
branches;
next	1.53;

1.53
date	2005.06.09.02.59.57;	author amodra;	state Exp;
branches;
next	1.52;

1.52
date	2005.06.09.02.05.46;	author amodra;	state Exp;
branches;
next	1.51;

1.51
date	2005.06.05.15.28.35;	author hjl;	state Exp;
branches;
next	1.50;

1.50
date	2005.06.04.14.40.21;	author hjl;	state Exp;
branches;
next	1.49;

1.49
date	2005.06.02.03.08.41;	author amodra;	state Exp;
branches;
next	1.48;

1.48
date	2005.05.17.16.42.46;	author hjl;	state Exp;
branches;
next	1.47;

1.47
date	2005.05.12.07.32.02;	author nickc;	state Exp;
branches;
next	1.46;

1.46
date	2005.03.14.12.29.13;	author amodra;	state Exp;
branches;
next	1.45;

1.45
date	2005.02.22.13.00.25;	author amodra;	state Exp;
branches
	1.45.2.1;
next	1.44;

1.44
date	2005.02.17.20.57.00;	author zack;	state Exp;
branches;
next	1.43;

1.43
date	2005.02.17.13.06.14;	author amodra;	state Exp;
branches;
next	1.42;

1.42
date	2005.01.21.04.15.58;	author bje;	state Exp;
branches;
next	1.41;

1.41
date	2004.12.17.15.50.02;	author jakub;	state Exp;
branches;
next	1.40;

1.40
date	2004.11.24.11.30.17;	author amodra;	state Exp;
branches;
next	1.39;

1.39
date	2004.11.19.09.31.53;	author nickc;	state Exp;
branches;
next	1.38;

1.38
date	2004.10.26.18.41.51;	author mmitchel;	state Exp;
branches;
next	1.37;

1.37
date	2004.10.15.06.00.15;	author amodra;	state Exp;
branches;
next	1.36;

1.36
date	2004.10.04.13.41.15;	author jakub;	state Exp;
branches;
next	1.35;

1.35
date	2004.09.19.17.09.23;	author schwab;	state Exp;
branches;
next	1.34;

1.34
date	2004.09.17.07.14.33;	author amodra;	state Exp;
branches;
next	1.33;

1.33
date	2004.09.07.15.54.47;	author schwab;	state Exp;
branches;
next	1.32;

1.32
date	2004.08.18.02.45.43;	author amodra;	state Exp;
branches;
next	1.31;

1.31
date	2004.06.24.04.46.27;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2004.05.11.17.08.34;	author jakub;	state Exp;
branches;
next	1.29;

1.29
date	2004.02.23.10.10.01;	author nathan;	state Exp;
branches;
next	1.28;

1.28
date	2004.02.20.15.31.09;	author nathan;	state Exp;
branches;
next	1.27;

1.27
date	2004.01.03.12.39.07;	author amodra;	state Exp;
branches
	1.27.6.1;
next	1.26;

1.26
date	2003.10.11.09.16.20;	author hp;	state Exp;
branches;
next	1.25;

1.25
date	2003.10.08.12.40.26;	author hp;	state Exp;
branches;
next	1.24;

1.24
date	2003.06.28.05.28.54;	author amodra;	state Exp;
branches;
next	1.23;

1.23
date	2003.06.25.06.40.26;	author amodra;	state Exp;
branches;
next	1.22;

1.22
date	2002.11.30.08.39.45;	author amodra;	state Exp;
branches;
next	1.21;

1.21
date	2002.10.30.03.57.38;	author drow;	state Exp;
branches;
next	1.20;

1.20
date	2002.09.25.02.42.13;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2002.09.02.17.03.29;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2002.09.02.14.46.56;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2002.08.13.02.08.25;	author amodra;	state Exp;
branches;
next	1.16;

1.16
date	2002.06.08.07.39.45;	author amodra;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2002.05.03.13.48.55;	author kazu;	state Exp;
branches;
next	1.14;

1.14
date	2002.04.30.09.21.27;	author rsandifo;	state Exp;
branches;
next	1.13;

1.13
date	2002.04.03.10.25.41;	author jakub;	state Exp;
branches;
next	1.12;

1.12
date	2002.02.15.02.11.05;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.12.14.50.06;	author jakub;	state Exp;
branches;
next	1.10;

1.10
date	2001.12.04.00.10.40;	author amodra;	state Exp;
branches;
next	1.9;

1.9
date	2001.07.19.16.41.00;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.13.06.14.27;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	2001.02.13.22.23.33;	author hjl;	state Exp;
branches;
next	1.6;

1.6
date	2000.10.09.15.09.17;	author kazu;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2000.10.03.07.31.55;	author kazu;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.29.11.18.18;	author kazu;	state Exp;
branches;
next	1.3;

1.3
date	2000.02.03.18.24.46;	author twall;	state Exp;
branches;
next	1.2;

1.2
date	99.07.11.20.08.59;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.29.06;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.101.2.1
date	2012.09.04.14.37.59;	author gingold;	state Exp;
branches;
next	1.101.2.2;

1.101.2.2
date	2013.01.21.13.48.48;	author amodra;	state Exp;
branches;
next	;

1.87.2.1
date	2011.02.01.12.25.46;	author amodra;	state Exp;
branches;
next	1.87.2.2;

1.87.2.2
date	2011.05.03.15.16.40;	author amodra;	state Exp;
branches;
next	1.87.2.3;

1.87.2.3
date	2011.05.29.04.51.46;	author amodra;	state Exp;
branches;
next	;

1.79.2.1
date	2009.09.11.15.28.44;	author nickc;	state Exp;
branches;
next	;

1.75.2.1
date	2009.03.02.13.29.32;	author amodra;	state Exp;
branches;
next	;

1.57.2.1
date	2006.08.29.10.57.15;	author nathan;	state Exp;
branches;
next	;

1.45.2.1
date	2005.03.14.12.33.02;	author amodra;	state Exp;
branches;
next	;

1.27.6.1
date	2004.02.20.15.32.12;	author nathan;	state Exp;
branches;
next	1.27.6.2;

1.27.6.2
date	2004.02.23.10.11.47;	author nathan;	state Exp;
branches;
next	;

1.16.2.1
date	2002.08.13.02.20.35;	author amodra;	state Exp;
branches;
next	1.16.2.2;

1.16.2.2
date	2002.09.25.02.43.16;	author amodra;	state Exp;
branches;
next	1.16.2.3;

1.16.2.3
date	2002.10.30.03.54.52;	author drow;	state Exp;
branches;
next	;

1.6.2.1
date	2001.06.07.03.17.14;	author amodra;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2001.06.11.10.05.08;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.29.06;	author rth;	state Exp;
branches;
next	;


desc
@@


1.105
log
@	* ldexp.c: Add LOG2CEIL() builtin function to linker script language
	* ldgram.y: Likewise
	* ldlex.l: Likewise
	* NEWS: Mention the new feature.
	* ld.texinfo: Document the new feature.

	* ld-scripts/log2.exp: New: Run the new log2 test.
	* ld-scripts/log2.s: Source for the new test.
	* ld-scripts/log2.t: Linker script for new test.
@
text
@/* This module handles expression trees.
   Copyright 1991-2013 Free Software Foundation, Inc.
   Written by Steve Chamberlain of Cygnus Support <sac@@cygnus.com>.

   This file is part of the GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */


/* This module is in charge of working out the contents of expressions.

   It has to keep track of the relative/absness of a symbol etc. This
   is done by keeping all values in a struct (an etree_value_type)
   which contains a value, a section to which it is relative and a
   valid bit.  */

#include "sysdep.h"
#include "bfd.h"
#include "bfdlink.h"

#include "ld.h"
#include "ldmain.h"
#include "ldmisc.h"
#include "ldexp.h"
#include "ldlex.h"
#include <ldgram.h>
#include "ldlang.h"
#include "libiberty.h"
#include "safe-ctype.h"

static void exp_fold_tree_1 (etree_type *);
static bfd_vma align_n (bfd_vma, bfd_vma);

segment_type *segments;

struct ldexp_control expld;

/* Print the string representation of the given token.  Surround it
   with spaces if INFIX_P is TRUE.  */

static void
exp_print_token (token_code_type code, int infix_p)
{
  static const struct
  {
    token_code_type code;
    const char * name;
  }
  table[] =
  {
    { INT, "int" },
    { NAME, "NAME" },
    { PLUSEQ, "+=" },
    { MINUSEQ, "-=" },
    { MULTEQ, "*=" },
    { DIVEQ, "/=" },
    { LSHIFTEQ, "<<=" },
    { RSHIFTEQ, ">>=" },
    { ANDEQ, "&=" },
    { OREQ, "|=" },
    { OROR, "||" },
    { ANDAND, "&&" },
    { EQ, "==" },
    { NE, "!=" },
    { LE, "<=" },
    { GE, ">=" },
    { LSHIFT, "<<" },
    { RSHIFT, ">>" },
    { LOG2CEIL, "LOG2CEIL" },
    { ALIGN_K, "ALIGN" },
    { BLOCK, "BLOCK" },
    { QUAD, "QUAD" },
    { SQUAD, "SQUAD" },
    { LONG, "LONG" },
    { SHORT, "SHORT" },
    { BYTE, "BYTE" },
    { SECTIONS, "SECTIONS" },
    { SIZEOF_HEADERS, "SIZEOF_HEADERS" },
    { MEMORY, "MEMORY" },
    { DEFINED, "DEFINED" },
    { TARGET_K, "TARGET" },
    { SEARCH_DIR, "SEARCH_DIR" },
    { MAP, "MAP" },
    { ENTRY, "ENTRY" },
    { NEXT, "NEXT" },
    { ALIGNOF, "ALIGNOF" },
    { SIZEOF, "SIZEOF" },
    { ADDR, "ADDR" },
    { LOADADDR, "LOADADDR" },
    { CONSTANT, "CONSTANT" },
    { ABSOLUTE, "ABSOLUTE" },
    { MAX_K, "MAX" },
    { MIN_K, "MIN" },
    { ASSERT_K, "ASSERT" },
    { REL, "relocatable" },
    { DATA_SEGMENT_ALIGN, "DATA_SEGMENT_ALIGN" },
    { DATA_SEGMENT_RELRO_END, "DATA_SEGMENT_RELRO_END" },
    { DATA_SEGMENT_END, "DATA_SEGMENT_END" },
    { ORIGIN, "ORIGIN" },
    { LENGTH, "LENGTH" },
    { SEGMENT_START, "SEGMENT_START" }
  };
  unsigned int idx;

  for (idx = 0; idx < ARRAY_SIZE (table); idx++)
    if (table[idx].code == code)
      break;

  if (infix_p)
    fputc (' ', config.map_file);

  if (idx < ARRAY_SIZE (table))
    fputs (table[idx].name, config.map_file);
  else if (code < 127)
    fputc (code, config.map_file);
  else
    fprintf (config.map_file, "<code %d>", code);

  if (infix_p)
    fputc (' ', config.map_file);
}

static void
make_log2ceil (void)
{
  bfd_vma value = expld.result.value;
  bfd_vma result = -1;
  bfd_boolean round_up = FALSE;

  do
    {
      result++;
      /* If more than one bit is set in the value we will need to round up.  */
      if ((value > 1) && (value & 1))
	round_up = TRUE;
    }
  while (value >>= 1);

  if (round_up)
    result += 1;
  expld.result.section = NULL;
  expld.result.value = result;
}

static void
make_abs (void)
{
  if (expld.result.section != NULL)
    expld.result.value += expld.result.section->vma;
  expld.result.section = bfd_abs_section_ptr;
}

static void
new_abs (bfd_vma value)
{
  expld.result.valid_p = TRUE;
  expld.result.section = bfd_abs_section_ptr;
  expld.result.value = value;
  expld.result.str = NULL;
}

etree_type *
exp_intop (bfd_vma value)
{
  etree_type *new_e = (etree_type *) stat_alloc (sizeof (new_e->value));
  new_e->type.node_code = INT;
  new_e->type.filename = ldlex_filename ();
  new_e->type.lineno = lineno;
  new_e->value.value = value;
  new_e->value.str = NULL;
  new_e->type.node_class = etree_value;
  return new_e;
}

etree_type *
exp_bigintop (bfd_vma value, char *str)
{
  etree_type *new_e = (etree_type *) stat_alloc (sizeof (new_e->value));
  new_e->type.node_code = INT;
  new_e->type.filename = ldlex_filename ();
  new_e->type.lineno = lineno;
  new_e->value.value = value;
  new_e->value.str = str;
  new_e->type.node_class = etree_value;
  return new_e;
}

/* Build an expression representing an unnamed relocatable value.  */

etree_type *
exp_relop (asection *section, bfd_vma value)
{
  etree_type *new_e = (etree_type *) stat_alloc (sizeof (new_e->rel));
  new_e->type.node_code = REL;
  new_e->type.filename = ldlex_filename ();
  new_e->type.lineno = lineno;
  new_e->type.node_class = etree_rel;
  new_e->rel.section = section;
  new_e->rel.value = value;
  return new_e;
}

static void
new_number (bfd_vma value)
{
  expld.result.valid_p = TRUE;
  expld.result.value = value;
  expld.result.str = NULL;
  expld.result.section = NULL;
}

static void
new_rel (bfd_vma value, asection *section)
{
  expld.result.valid_p = TRUE;
  expld.result.value = value;
  expld.result.str = NULL;
  expld.result.section = section;
}

static void
new_rel_from_abs (bfd_vma value)
{
  asection *s = expld.section;

  if (s == bfd_abs_section_ptr && expld.phase == lang_final_phase_enum)
    s = section_for_dot ();
  expld.result.valid_p = TRUE;
  expld.result.value = value - s->vma;
  expld.result.str = NULL;
  expld.result.section = s;
}

static void
fold_unary (etree_type *tree)
{
  exp_fold_tree_1 (tree->unary.child);
  if (expld.result.valid_p)
    {
      switch (tree->type.node_code)
	{
	case ALIGN_K:
	  if (expld.phase != lang_first_phase_enum)
	    new_rel_from_abs (align_n (expld.dot, expld.result.value));
	  else
	    expld.result.valid_p = FALSE;
	  break;

	case ABSOLUTE:
	  make_abs ();
	  break;

	case LOG2CEIL:
	  make_log2ceil ();
	  break;

	case '~':
	  expld.result.value = ~expld.result.value;
	  break;

	case '!':
	  expld.result.value = !expld.result.value;
	  break;

	case '-':
	  expld.result.value = -expld.result.value;
	  break;

	case NEXT:
	  /* Return next place aligned to value.  */
	  if (expld.phase != lang_first_phase_enum)
	    {
	      make_abs ();
	      expld.result.value = align_n (expld.dot, expld.result.value);
	    }
	  else
	    expld.result.valid_p = FALSE;
	  break;

	case DATA_SEGMENT_END:
	  if (expld.phase == lang_first_phase_enum
	      || expld.section != bfd_abs_section_ptr)
	    {
	      expld.result.valid_p = FALSE;
	    }
	  else if (expld.dataseg.phase == exp_dataseg_align_seen
		   || expld.dataseg.phase == exp_dataseg_relro_seen)
	    {
	      expld.dataseg.phase = exp_dataseg_end_seen;
	      expld.dataseg.end = expld.result.value;
	    }
	  else if (expld.dataseg.phase == exp_dataseg_done
		   || expld.dataseg.phase == exp_dataseg_adjust
		   || expld.dataseg.phase == exp_dataseg_relro_adjust)
	    {
	      /* OK.  */
	    }
	  else
	    expld.result.valid_p = FALSE;
	  break;

	default:
	  FAIL ();
	  break;
	}
    }
}

static void
fold_binary (etree_type *tree)
{
  etree_value_type lhs;
  exp_fold_tree_1 (tree->binary.lhs);

  /* The SEGMENT_START operator is special because its first
     operand is a string, not the name of a symbol.  Note that the
     operands have been swapped, so binary.lhs is second (default)
     operand, binary.rhs is first operand.  */
  if (expld.result.valid_p && tree->type.node_code == SEGMENT_START)
    {
      const char *segment_name;
      segment_type *seg;

      /* Check to see if the user has overridden the default
	 value.  */
      segment_name = tree->binary.rhs->name.name;
      for (seg = segments; seg; seg = seg->next)
	if (strcmp (seg->name, segment_name) == 0)
	  {
	    if (!seg->used
		&& config.magic_demand_paged
		&& (seg->value % config.maxpagesize) != 0)
	      einfo (_("%P: warning: address of `%s' isn't multiple of maximum page size\n"),
		     segment_name);
	    seg->used = TRUE;
	    new_rel_from_abs (seg->value);
	    break;
	  }
      return;
    }

  lhs = expld.result;
  exp_fold_tree_1 (tree->binary.rhs);
  expld.result.valid_p &= lhs.valid_p;

  if (expld.result.valid_p)
    {
      if (lhs.section != expld.result.section)
	{
	  /* If the values are from different sections, and neither is
	     just a number, make both the source arguments absolute.  */
	  if (expld.result.section != NULL
	      && lhs.section != NULL)
	    {
	      make_abs ();
	      lhs.value += lhs.section->vma;
	      lhs.section = bfd_abs_section_ptr;
	    }

	  /* If the rhs is just a number, keep the lhs section.  */
	  else if (expld.result.section == NULL)
	    {
	      expld.result.section = lhs.section;
	      /* Make this NULL so that we know one of the operands
		 was just a number, for later tests.  */
	      lhs.section = NULL;
	    }
	}
      /* At this point we know that both operands have the same
	 section, or at least one of them is a plain number.  */

      switch (tree->type.node_code)
	{
	  /* Arithmetic operators, bitwise AND, bitwise OR and XOR
	     keep the section of one of their operands only when the
	     other operand is a plain number.  Losing the section when
	     operating on two symbols, ie. a result of a plain number,
	     is required for subtraction and XOR.  It's justifiable
	     for the other operations on the grounds that adding,
	     multiplying etc. two section relative values does not
	     really make sense unless they are just treated as
	     numbers.
	     The same argument could be made for many expressions
	     involving one symbol and a number.  For example,
	     "1 << x" and "100 / x" probably should not be given the
	     section of x.  The trouble is that if we fuss about such
	     things the rules become complex and it is onerous to
	     document ld expression evaluation.  */
#define BOP(x, y) \
	case x:							\
	  expld.result.value = lhs.value y expld.result.value;	\
	  if (expld.result.section == lhs.section)		\
	    expld.result.section = NULL;			\
	  break;

	  /* Comparison operators, logical AND, and logical OR always
	     return a plain number.  */
#define BOPN(x, y) \
	case x:							\
	  expld.result.value = lhs.value y expld.result.value;	\
	  expld.result.section = NULL;				\
	  break;

	  BOP ('+', +);
	  BOP ('*', *);
	  BOP ('-', -);
	  BOP (LSHIFT, <<);
	  BOP (RSHIFT, >>);
	  BOP ('&', &);
	  BOP ('^', ^);
	  BOP ('|', |);
	  BOPN (EQ, ==);
	  BOPN (NE, !=);
	  BOPN ('<', <);
	  BOPN ('>', >);
	  BOPN (LE, <=);
	  BOPN (GE, >=);
	  BOPN (ANDAND, &&);
	  BOPN (OROR, ||);

	case '%':
	  if (expld.result.value != 0)
	    expld.result.value = ((bfd_signed_vma) lhs.value
				  % (bfd_signed_vma) expld.result.value);
	  else if (expld.phase != lang_mark_phase_enum)
	    einfo (_("%F%S %% by zero\n"), tree->binary.rhs);
	  if (expld.result.section == lhs.section)
	    expld.result.section = NULL;
	  break;

	case '/':
	  if (expld.result.value != 0)
	    expld.result.value = ((bfd_signed_vma) lhs.value
				  / (bfd_signed_vma) expld.result.value);
	  else if (expld.phase != lang_mark_phase_enum)
	    einfo (_("%F%S / by zero\n"), tree->binary.rhs);
	  if (expld.result.section == lhs.section)
	    expld.result.section = NULL;
	  break;

	case MAX_K:
	  if (lhs.value > expld.result.value)
	    expld.result.value = lhs.value;
	  break;

	case MIN_K:
	  if (lhs.value < expld.result.value)
	    expld.result.value = lhs.value;
	  break;

	case ALIGN_K:
	  expld.result.value = align_n (lhs.value, expld.result.value);
	  break;

	case DATA_SEGMENT_ALIGN:
	  expld.dataseg.relro = exp_dataseg_relro_start;
	  if (expld.phase == lang_first_phase_enum
	      || expld.section != bfd_abs_section_ptr)
	    expld.result.valid_p = FALSE;
	  else
	    {
	      bfd_vma maxpage = lhs.value;
	      bfd_vma commonpage = expld.result.value;

	      expld.result.value = align_n (expld.dot, maxpage);
	      if (expld.dataseg.phase == exp_dataseg_relro_adjust)
		expld.result.value = expld.dataseg.base;
	      else if (expld.dataseg.phase == exp_dataseg_adjust)
		{
		  if (commonpage < maxpage)
		    expld.result.value += ((expld.dot + commonpage - 1)
					   & (maxpage - commonpage));
		}
	      else
		{
		  expld.result.value += expld.dot & (maxpage - 1);
		  if (expld.dataseg.phase == exp_dataseg_done)
		    {
		      /* OK.  */
		    }
		  else if (expld.dataseg.phase == exp_dataseg_none)
		    {
		      expld.dataseg.phase = exp_dataseg_align_seen;
		      expld.dataseg.min_base = expld.dot;
		      expld.dataseg.base = expld.result.value;
		      expld.dataseg.pagesize = commonpage;
		      expld.dataseg.maxpagesize = maxpage;
		      expld.dataseg.relro_end = 0;
		    }
		  else
		    expld.result.valid_p = FALSE;
		}
	    }
	  break;

	case DATA_SEGMENT_RELRO_END:
	  expld.dataseg.relro = exp_dataseg_relro_end;
	  if (expld.phase == lang_first_phase_enum
	      || expld.section != bfd_abs_section_ptr)
	    expld.result.valid_p = FALSE;
	  else if (expld.dataseg.phase == exp_dataseg_align_seen
		   || expld.dataseg.phase == exp_dataseg_adjust
		   || expld.dataseg.phase == exp_dataseg_relro_adjust
		   || expld.dataseg.phase == exp_dataseg_done)
	    {
	      if (expld.dataseg.phase == exp_dataseg_align_seen
		  || expld.dataseg.phase == exp_dataseg_relro_adjust)
		expld.dataseg.relro_end = lhs.value + expld.result.value;

	      if (expld.dataseg.phase == exp_dataseg_relro_adjust
		  && (expld.dataseg.relro_end
		      & (expld.dataseg.pagesize - 1)))
		{
		  expld.dataseg.relro_end += expld.dataseg.pagesize - 1;
		  expld.dataseg.relro_end &= ~(expld.dataseg.pagesize - 1);
		  expld.result.value = (expld.dataseg.relro_end
					- expld.result.value);
		}
	      else
		expld.result.value = lhs.value;

	      if (expld.dataseg.phase == exp_dataseg_align_seen)
		expld.dataseg.phase = exp_dataseg_relro_seen;
	    }
	  else
	    expld.result.valid_p = FALSE;
	  break;

	default:
	  FAIL ();
	}
    }
}

static void
fold_trinary (etree_type *tree)
{
  exp_fold_tree_1 (tree->trinary.cond);
  if (expld.result.valid_p)
    exp_fold_tree_1 (expld.result.value
		     ? tree->trinary.lhs
		     : tree->trinary.rhs);
}

static void
fold_name (etree_type *tree)
{
  memset (&expld.result, 0, sizeof (expld.result));

  switch (tree->type.node_code)
    {
    case SIZEOF_HEADERS:
      if (expld.phase != lang_first_phase_enum)
	{
	  bfd_vma hdr_size = 0;
	  /* Don't find the real header size if only marking sections;
	     The bfd function may cache incorrect data.  */
	  if (expld.phase != lang_mark_phase_enum)
	    hdr_size = bfd_sizeof_headers (link_info.output_bfd, &link_info);
	  new_number (hdr_size);
	}
      break;

    case DEFINED:
      if (expld.phase == lang_first_phase_enum)
	lang_track_definedness (tree->name.name);
      else
	{
	  struct bfd_link_hash_entry *h;
	  int def_iteration
	    = lang_symbol_definition_iteration (tree->name.name);

	  h = bfd_wrapped_link_hash_lookup (link_info.output_bfd,
					    &link_info,
					    tree->name.name,
					    FALSE, FALSE, TRUE);
	  new_number (h != NULL
		      && (h->type == bfd_link_hash_defined
			  || h->type == bfd_link_hash_defweak
			  || h->type == bfd_link_hash_common)
		      && (def_iteration == lang_statement_iteration
			  || def_iteration == -1));
	}
      break;

    case NAME:
      if (expld.assign_name != NULL
	  && strcmp (expld.assign_name, tree->name.name) == 0)
	expld.assign_name = NULL;
      if (expld.phase == lang_first_phase_enum)
	;
      else if (tree->name.name[0] == '.' && tree->name.name[1] == 0)
	new_rel_from_abs (expld.dot);
      else
	{
	  struct bfd_link_hash_entry *h;

	  h = bfd_wrapped_link_hash_lookup (link_info.output_bfd,
					    &link_info,
					    tree->name.name,
					    TRUE, FALSE, TRUE);
	  if (!h)
	    einfo (_("%P%F: bfd_link_hash_lookup failed: %E\n"));
	  else if (h->type == bfd_link_hash_defined
		   || h->type == bfd_link_hash_defweak)
	    {
	      asection *output_section;

	      output_section = h->u.def.section->output_section;
	      if (output_section == NULL)
		{
		  if (expld.phase == lang_mark_phase_enum)
		    new_rel (h->u.def.value, h->u.def.section);
		  else
		    einfo (_("%X%S: unresolvable symbol `%s'"
			     " referenced in expression\n"),
			   tree, tree->name.name);
		}
	      else if (output_section == bfd_abs_section_ptr
		       && (expld.section != bfd_abs_section_ptr
			   || config.sane_expr))
		new_number (h->u.def.value + h->u.def.section->output_offset);
	      else
		new_rel (h->u.def.value + h->u.def.section->output_offset,
			 output_section);
	    }
	  else if (expld.phase == lang_final_phase_enum
		   || (expld.phase != lang_mark_phase_enum
		       && expld.assigning_to_dot))
	    einfo (_("%F%S: undefined symbol `%s'"
		     " referenced in expression\n"),
		   tree, tree->name.name);
	  else if (h->type == bfd_link_hash_new)
	    {
	      h->type = bfd_link_hash_undefined;
	      h->u.undef.abfd = NULL;
	      if (h->u.undef.next == NULL && h != link_info.hash->undefs_tail)
		bfd_link_add_undef (link_info.hash, h);
	    }
	}
      break;

    case ADDR:
      if (expld.phase != lang_first_phase_enum)
	{
	  lang_output_section_statement_type *os;

	  os = lang_output_section_find (tree->name.name);
	  if (os == NULL)
	    {
	      if (expld.phase == lang_final_phase_enum)
		einfo (_("%F%S: undefined section `%s'"
			 " referenced in expression\n"),
		       tree, tree->name.name);
	    }
	  else if (os->processed_vma)
	    new_rel (0, os->bfd_section);
	}
      break;

    case LOADADDR:
      if (expld.phase != lang_first_phase_enum)
	{
	  lang_output_section_statement_type *os;

	  os = lang_output_section_find (tree->name.name);
	  if (os == NULL)
	    {
	      if (expld.phase == lang_final_phase_enum)
		einfo (_("%F%S: undefined section `%s'"
			 " referenced in expression\n"),
		       tree, tree->name.name);
	    }
	  else if (os->processed_lma)
	    {
	      if (os->load_base == NULL)
		new_abs (os->bfd_section->lma);
	      else
		{
		  exp_fold_tree_1 (os->load_base);
		  if (expld.result.valid_p)
		    make_abs ();
		}
	    }
	}
      break;

    case SIZEOF:
    case ALIGNOF:
      if (expld.phase != lang_first_phase_enum)
	{
	  lang_output_section_statement_type *os;

	  os = lang_output_section_find (tree->name.name);
	  if (os == NULL)
	    {
	      if (expld.phase == lang_final_phase_enum)
		einfo (_("%F%S: undefined section `%s'"
			 " referenced in expression\n"),
		       tree, tree->name.name);
	      new_number (0);
	    }
	  else if (os->bfd_section != NULL)
	    {
	      bfd_vma val;

	      if (tree->type.node_code == SIZEOF)
		val = (os->bfd_section->size
		       / bfd_octets_per_byte (link_info.output_bfd));
	      else
		val = (bfd_vma)1 << os->bfd_section->alignment_power;

	      new_number (val);
	    }
	  else
	    new_number (0);
	}
      break;

    case LENGTH:
      {
        lang_memory_region_type *mem;

        mem = lang_memory_region_lookup (tree->name.name, FALSE);
        if (mem != NULL)
          new_number (mem->length);
        else
          einfo (_("%F%S: undefined MEMORY region `%s'"
		   " referenced in expression\n"),
		 tree, tree->name.name);
      }
      break;

    case ORIGIN:
      if (expld.phase != lang_first_phase_enum)
	{
	  lang_memory_region_type *mem;

	  mem = lang_memory_region_lookup (tree->name.name, FALSE);
	  if (mem != NULL)
	    new_rel_from_abs (mem->origin);
	  else
	    einfo (_("%F%S: undefined MEMORY region `%s'"
		     " referenced in expression\n"),
		   tree, tree->name.name);
	}
      break;

    case CONSTANT:
      if (strcmp (tree->name.name, "MAXPAGESIZE") == 0)
	new_number (config.maxpagesize);
      else if (strcmp (tree->name.name, "COMMONPAGESIZE") == 0)
	new_number (config.commonpagesize);
      else
	einfo (_("%F%S: unknown constant `%s' referenced in expression\n"),
	       tree, tree->name.name);
      break;

    default:
      FAIL ();
      break;
    }
}

static void
exp_fold_tree_1 (etree_type *tree)
{
  if (tree == NULL)
    {
      memset (&expld.result, 0, sizeof (expld.result));
      return;
    }

  switch (tree->type.node_class)
    {
    case etree_value:
      if (expld.section == bfd_abs_section_ptr
	  && !config.sane_expr)
	new_abs (tree->value.value);
      else
	new_number (tree->value.value);
      expld.result.str = tree->value.str;
      break;

    case etree_rel:
      if (expld.phase != lang_first_phase_enum)
	{
	  asection *output_section = tree->rel.section->output_section;
	  new_rel (tree->rel.value + tree->rel.section->output_offset,
		   output_section);
	}
      else
	memset (&expld.result, 0, sizeof (expld.result));
      break;

    case etree_assert:
      exp_fold_tree_1 (tree->assert_s.child);
      if (expld.phase == lang_final_phase_enum && !expld.result.value)
	einfo ("%X%P: %s\n", tree->assert_s.message);
      break;

    case etree_unary:
      fold_unary (tree);
      break;

    case etree_binary:
      fold_binary (tree);
      break;

    case etree_trinary:
      fold_trinary (tree);
      break;

    case etree_assign:
    case etree_provide:
    case etree_provided:
      if (tree->assign.dst[0] == '.' && tree->assign.dst[1] == 0)
	{
	  if (tree->type.node_class != etree_assign)
	    einfo (_("%F%S can not PROVIDE assignment to"
		     " location counter\n"), tree);
	  if (expld.phase != lang_first_phase_enum)
	    {
	      /* Notify the folder that this is an assignment to dot.  */
	      expld.assigning_to_dot = TRUE;
	      exp_fold_tree_1 (tree->assign.src);
	      expld.assigning_to_dot = FALSE;

	      if (!expld.result.valid_p)
		{
		  if (expld.phase != lang_mark_phase_enum)
		    einfo (_("%F%S invalid assignment to"
			     " location counter\n"), tree);
		}
	      else if (expld.dotp == NULL)
		einfo (_("%F%S assignment to location counter"
			 " invalid outside of SECTIONS\n"), tree);

	      /* After allocation, assignment to dot should not be
		 done inside an output section since allocation adds a
		 padding statement that effectively duplicates the
		 assignment.  */
	      else if (expld.phase <= lang_allocating_phase_enum
		       || expld.section == bfd_abs_section_ptr)
		{
		  bfd_vma nextdot;

		  nextdot = expld.result.value;
		  if (expld.result.section != NULL)
		    nextdot += expld.result.section->vma;
		  else
		    nextdot += expld.section->vma;
		  if (nextdot < expld.dot
		      && expld.section != bfd_abs_section_ptr)
		    einfo (_("%F%S cannot move location counter backwards"
			     " (from %V to %V)\n"),
			   tree, expld.dot, nextdot);
		  else
		    {
		      expld.dot = nextdot;
		      *expld.dotp = nextdot;
		    }
		}
	    }
	  else
	    memset (&expld.result, 0, sizeof (expld.result));
	}
      else
	{
	  struct bfd_link_hash_entry *h = NULL;

	  if (tree->type.node_class == etree_provide)
	    {
	      h = bfd_link_hash_lookup (link_info.hash, tree->assign.dst,
					FALSE, FALSE, TRUE);
	      if (h == NULL
		  || (h->type != bfd_link_hash_new
		      && h->type != bfd_link_hash_undefined
		      && h->type != bfd_link_hash_common))
		{
		  /* Do nothing.  The symbol was never referenced, or was
		     defined by some object.  */
		  break;
		}
	    }

	  expld.assign_name = tree->assign.dst;
	  exp_fold_tree_1 (tree->assign.src);
	  /* expld.assign_name remaining equal to tree->assign.dst
	     below indicates the evaluation of tree->assign.src did
	     not use the value of tree->assign.dst.  We don't allow
	     self assignment until the final phase for two reasons:
	     1) Expressions are evaluated multiple times.  With
	     relaxation, the number of times may vary.
	     2) Section relative symbol values cannot be correctly
	     converted to absolute values, as is required by many
	     expressions, until final section sizing is complete.  */
	  if ((expld.result.valid_p
	       && (expld.phase == lang_final_phase_enum
		   || expld.assign_name != NULL))
	      || (expld.phase <= lang_mark_phase_enum
		  && tree->type.node_class == etree_assign
		  && tree->assign.defsym))
	    {
	      if (h == NULL)
		{
		  h = bfd_link_hash_lookup (link_info.hash, tree->assign.dst,
					    TRUE, FALSE, TRUE);
		  if (h == NULL)
		    einfo (_("%P%F:%s: hash creation failed\n"),
			   tree->assign.dst);
		}

	      /* FIXME: Should we worry if the symbol is already
		 defined?  */
	      lang_update_definedness (tree->assign.dst, h);
	      h->type = bfd_link_hash_defined;
	      h->u.def.value = expld.result.value;
	      if (expld.result.section == NULL)
		expld.result.section = expld.section;
	      h->u.def.section = expld.result.section;
	      if (tree->type.node_class == etree_provide)
		tree->type.node_class = etree_provided;

	      /* Copy the symbol type if this is a simple assignment of
	         one symbol to another.  This could be more general
		 (e.g. a ?: operator with NAMEs in each branch).  */
	      if (tree->assign.src->type.node_class == etree_name)
		{
		  struct bfd_link_hash_entry *hsrc;

		  hsrc = bfd_link_hash_lookup (link_info.hash,
					       tree->assign.src->name.name,
					       FALSE, FALSE, TRUE);
		  if (hsrc)
		    bfd_copy_link_hash_symbol_type (link_info.output_bfd, h,
						    hsrc);
		}
	    }
	  else if (expld.phase == lang_final_phase_enum)
	    {
	      h = bfd_link_hash_lookup (link_info.hash, tree->assign.dst,
					FALSE, FALSE, TRUE);
	      if (h != NULL
		  && h->type == bfd_link_hash_new)
		h->type = bfd_link_hash_undefined;
	    }
	  expld.assign_name = NULL;
	}
      break;

    case etree_name:
      fold_name (tree);
      break;

    default:
      FAIL ();
      memset (&expld.result, 0, sizeof (expld.result));
      break;
    }
}

void
exp_fold_tree (etree_type *tree, asection *current_section, bfd_vma *dotp)
{
  expld.dot = *dotp;
  expld.dotp = dotp;
  expld.section = current_section;
  exp_fold_tree_1 (tree);
}

void
exp_fold_tree_no_dot (etree_type *tree)
{
  expld.dot = 0;
  expld.dotp = NULL;
  expld.section = bfd_abs_section_ptr;
  exp_fold_tree_1 (tree);
}

etree_type *
exp_binop (int code, etree_type *lhs, etree_type *rhs)
{
  etree_type value, *new_e;

  value.type.node_code = code;
  value.type.filename = lhs->type.filename;
  value.type.lineno = lhs->type.lineno;
  value.binary.lhs = lhs;
  value.binary.rhs = rhs;
  value.type.node_class = etree_binary;
  exp_fold_tree_no_dot (&value);
  if (expld.result.valid_p)
    return exp_intop (expld.result.value);

  new_e = (etree_type *) stat_alloc (sizeof (new_e->binary));
  memcpy (new_e, &value, sizeof (new_e->binary));
  return new_e;
}

etree_type *
exp_trinop (int code, etree_type *cond, etree_type *lhs, etree_type *rhs)
{
  etree_type value, *new_e;

  value.type.node_code = code;
  value.type.filename = cond->type.filename;
  value.type.lineno = cond->type.lineno;
  value.trinary.lhs = lhs;
  value.trinary.cond = cond;
  value.trinary.rhs = rhs;
  value.type.node_class = etree_trinary;
  exp_fold_tree_no_dot (&value);
  if (expld.result.valid_p)
    return exp_intop (expld.result.value);

  new_e = (etree_type *) stat_alloc (sizeof (new_e->trinary));
  memcpy (new_e, &value, sizeof (new_e->trinary));
  return new_e;
}

etree_type *
exp_unop (int code, etree_type *child)
{
  etree_type value, *new_e;

  value.unary.type.node_code = code;
  value.unary.type.filename = child->type.filename;
  value.unary.type.lineno = child->type.lineno;
  value.unary.child = child;
  value.unary.type.node_class = etree_unary;
  exp_fold_tree_no_dot (&value);
  if (expld.result.valid_p)
    return exp_intop (expld.result.value);

  new_e = (etree_type *) stat_alloc (sizeof (new_e->unary));
  memcpy (new_e, &value, sizeof (new_e->unary));
  return new_e;
}

etree_type *
exp_nameop (int code, const char *name)
{
  etree_type value, *new_e;

  value.name.type.node_code = code;
  value.name.type.filename = ldlex_filename ();
  value.name.type.lineno = lineno;
  value.name.name = name;
  value.name.type.node_class = etree_name;

  exp_fold_tree_no_dot (&value);
  if (expld.result.valid_p)
    return exp_intop (expld.result.value);

  new_e = (etree_type *) stat_alloc (sizeof (new_e->name));
  memcpy (new_e, &value, sizeof (new_e->name));
  return new_e;

}

static etree_type *
exp_assop (const char *dst,
	   etree_type *src,
	   enum node_tree_enum class,
	   bfd_boolean defsym,
	   bfd_boolean hidden)
{
  etree_type *n;

  n = (etree_type *) stat_alloc (sizeof (n->assign));
  n->assign.type.node_code = '=';
  n->assign.type.filename = src->type.filename;
  n->assign.type.lineno = src->type.lineno;
  n->assign.type.node_class = class;
  n->assign.src = src;
  n->assign.dst = dst;
  n->assign.defsym = defsym;
  n->assign.hidden = hidden;
  return n;
}

/* Handle linker script assignments and HIDDEN.  */

etree_type *
exp_assign (const char *dst, etree_type *src, bfd_boolean hidden)
{
  return exp_assop (dst, src, etree_assign, FALSE, hidden);
}

/* Handle --defsym command-line option.  */

etree_type *
exp_defsym (const char *dst, etree_type *src)
{
  return exp_assop (dst, src, etree_assign, TRUE, FALSE);
}

/* Handle PROVIDE.  */

etree_type *
exp_provide (const char *dst, etree_type *src, bfd_boolean hidden)
{
  return exp_assop (dst, src, etree_provide, FALSE, hidden);
}

/* Handle ASSERT.  */

etree_type *
exp_assert (etree_type *exp, const char *message)
{
  etree_type *n;

  n = (etree_type *) stat_alloc (sizeof (n->assert_s));
  n->assert_s.type.node_code = '!';
  n->assert_s.type.filename = exp->type.filename;
  n->assert_s.type.lineno = exp->type.lineno;
  n->assert_s.type.node_class = etree_assert;
  n->assert_s.child = exp;
  n->assert_s.message = message;
  return n;
}

void
exp_print_tree (etree_type *tree)
{
  bfd_boolean function_like;

  if (config.map_file == NULL)
    config.map_file = stderr;

  if (tree == NULL)
    {
      minfo ("NULL TREE\n");
      return;
    }

  switch (tree->type.node_class)
    {
    case etree_value:
      minfo ("0x%v", tree->value.value);
      return;
    case etree_rel:
      if (tree->rel.section->owner != NULL)
	minfo ("%B:", tree->rel.section->owner);
      minfo ("%s+0x%v", tree->rel.section->name, tree->rel.value);
      return;
    case etree_assign:
      fputs (tree->assign.dst, config.map_file);
      exp_print_token (tree->type.node_code, TRUE);
      exp_print_tree (tree->assign.src);
      break;
    case etree_provide:
    case etree_provided:
      fprintf (config.map_file, "PROVIDE (%s, ", tree->assign.dst);
      exp_print_tree (tree->assign.src);
      fputc (')', config.map_file);
      break;
    case etree_binary:
      function_like = FALSE;
      switch (tree->type.node_code)
	{
	case MAX_K:
	case MIN_K:
	case ALIGN_K:
	case DATA_SEGMENT_ALIGN:
	case DATA_SEGMENT_RELRO_END:
	  function_like = TRUE;
	  break;
	case SEGMENT_START:
	  /* Special handling because arguments are in reverse order and
	     the segment name is quoted.  */
	  exp_print_token (tree->type.node_code, FALSE);
	  fputs (" (\"", config.map_file);
	  exp_print_tree (tree->binary.rhs);
	  fputs ("\", ", config.map_file);
	  exp_print_tree (tree->binary.lhs);
	  fputc (')', config.map_file);
	  return;
	}
      if (function_like)
	{
	  exp_print_token (tree->type.node_code, FALSE);
	  fputc (' ', config.map_file);
	}
      fputc ('(', config.map_file);
      exp_print_tree (tree->binary.lhs);
      if (function_like)
	fprintf (config.map_file, ", ");
      else
	exp_print_token (tree->type.node_code, TRUE);
      exp_print_tree (tree->binary.rhs);
      fputc (')', config.map_file);
      break;
    case etree_trinary:
      exp_print_tree (tree->trinary.cond);
      fputc ('?', config.map_file);
      exp_print_tree (tree->trinary.lhs);
      fputc (':', config.map_file);
      exp_print_tree (tree->trinary.rhs);
      break;
    case etree_unary:
      exp_print_token (tree->unary.type.node_code, FALSE);
      if (tree->unary.child)
	{
	  fprintf (config.map_file, " (");
	  exp_print_tree (tree->unary.child);
	  fputc (')', config.map_file);
	}
      break;

    case etree_assert:
      fprintf (config.map_file, "ASSERT (");
      exp_print_tree (tree->assert_s.child);
      fprintf (config.map_file, ", %s)", tree->assert_s.message);
      break;

    case etree_name:
      if (tree->type.node_code == NAME)
	fputs (tree->name.name, config.map_file);
      else
	{
	  exp_print_token (tree->type.node_code, FALSE);
	  if (tree->name.name)
	    fprintf (config.map_file, " (%s)", tree->name.name);
	}
      break;
    default:
      FAIL ();
      break;
    }
}

bfd_vma
exp_get_vma (etree_type *tree, bfd_vma def, char *name)
{
  if (tree != NULL)
    {
      exp_fold_tree_no_dot (tree);
      if (expld.result.valid_p)
	return expld.result.value;
      else if (name != NULL && expld.phase != lang_mark_phase_enum)
	einfo (_("%F%S: nonconstant expression for %s\n"),
	       tree, name);
    }
  return def;
}

int
exp_get_value_int (etree_type *tree, int def, char *name)
{
  return exp_get_vma (tree, def, name);
}

fill_type *
exp_get_fill (etree_type *tree, fill_type *def, char *name)
{
  fill_type *fill;
  size_t len;
  unsigned int val;

  if (tree == NULL)
    return def;

  exp_fold_tree_no_dot (tree);
  if (!expld.result.valid_p)
    {
      if (name != NULL && expld.phase != lang_mark_phase_enum)
	einfo (_("%F%S: nonconstant expression for %s\n"),
	       tree, name);
      return def;
    }

  if (expld.result.str != NULL && (len = strlen (expld.result.str)) != 0)
    {
      unsigned char *dst;
      unsigned char *s;
      fill = (fill_type *) xmalloc ((len + 1) / 2 + sizeof (*fill) - 1);
      fill->size = (len + 1) / 2;
      dst = fill->data;
      s = (unsigned char *) expld.result.str;
      val = 0;
      do
	{
	  unsigned int digit;

	  digit = *s++ - '0';
	  if (digit > 9)
	    digit = (digit - 'A' + '0' + 10) & 0xf;
	  val <<= 4;
	  val += digit;
	  --len;
	  if ((len & 1) == 0)
	    {
	      *dst++ = val;
	      val = 0;
	    }
	}
      while (len != 0);
    }
  else
    {
      fill = (fill_type *) xmalloc (4 + sizeof (*fill) - 1);
      val = expld.result.value;
      fill->data[0] = (val >> 24) & 0xff;
      fill->data[1] = (val >> 16) & 0xff;
      fill->data[2] = (val >>  8) & 0xff;
      fill->data[3] = (val >>  0) & 0xff;
      fill->size = 4;
    }
  return fill;
}

bfd_vma
exp_get_abs_int (etree_type *tree, int def, char *name)
{
  if (tree != NULL)
    {
      exp_fold_tree_no_dot (tree);

      if (expld.result.valid_p)
	{
	  if (expld.result.section != NULL)
	    expld.result.value += expld.result.section->vma;
	  return expld.result.value;
	}
      else if (name != NULL && expld.phase != lang_mark_phase_enum)
	{
	  einfo (_("%F%S: nonconstant expression for %s\n"),
		 tree, name);
	}
    }
  return def;
}

static bfd_vma
align_n (bfd_vma value, bfd_vma align)
{
  if (align <= 1)
    return value;

  value = (value + align - 1) / align;
  return value * align;
}
@


1.104
log
@Remove trailing white spaces in ld

	* deffilep.y: Remove trailing white spaces.
	* elf-hints-local.h: Likewise.
	* ldexp.c: Likewise.
	* ldlang.h: Likewise.
	* ldmisc.c: Likewise.
	* ldwrite.c: Likewise.
	* pe-dll.c: Likewise.
	* emulparams/criself.sh: Likewise.
	* emulparams/crislinux.sh: Likewise.
	* emulparams/elf32_tic6x_le.sh: Likewise.
	* emulparams/elf32bmipn32-defs.sh: Likewise.
	* emulparams/elf32mb_linux.sh: Likewise.
	* emulparams/elf32mep.sh: Likewise.
	* emulparams/elf32microblaze.sh: Likewise.
	* emulparams/elf32ppc.sh: Likewise.
	* emulparams/elf64_s390.sh: Likewise.
	* emulparams/elf64alpha.sh: Likewise.
	* emulparams/elf_s390.sh: Likewise.
	* emulparams/elf_x86_64.sh: Likewise.
	* emulparams/tic80coff.sh: Likewise.
	* emultempl/aix.em: Likewise.
	* emultempl/avrelf.em: Likewise.
	* emultempl/cr16elf.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/tic6xdsbt.em: Likewise.
@
text
@d2 1
a2 3
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012
   Free Software Foundation, Inc.
d82 1
d137 22
d266 4
@


1.103
log
@	PR ld/14962
	* ldexp.h (struct ldexp_control): Add "assign_name".
	* ldexp.c (fold_name <NAME>): Compare and clear assign_name on match.
	(exp_fold_tree_1): Remove existing code testing for self assignment.
	Instead set and test expld.assign_name.
	* ldlang.c (scan_for_self_assignment): Delete.
	(print_assignment): Instead set and test expld.assign_name.
@
text
@d315 1
a315 1
      for (seg = segments; seg; seg = seg->next) 
d700 1
a700 1
	      
d711 3
a713 3
        
        mem = lang_memory_region_lookup (tree->name.name, FALSE);  
        if (mem != NULL) 
d715 1
a715 1
        else          
d726 3
a728 3
        
	  mem = lang_memory_region_lookup (tree->name.name, FALSE);  
	  if (mem != NULL) 
d730 1
a730 1
	  else          
@


1.102
log
@	bfd/
	* elflink.c (bfd_elf_record_link_assignment): Remove --defsym
	symbols special case.

	ld/
	* ldexp.h (etree_union): Add defsym member to the assign member
	structure.
	(exp_assign): Add hidden argument to prototype.
	* ldexp.c (exp_fold_tree_1): Use the defsym member to handle
	--defsym symbols.
	(exp_assop): Add defsym argument, initialize the defsym member
	of the assign structure.
	(exp_assign): Handle hidden symbols.
	(exp_defsym): Update to use the defsym argument to exp_assop.
	(exp_provide): Update to handle the defsym argument to exp_assop.
	* ldlex.l (HIDDEN): New token.
	* ldgram.y (HIDDEN): Likewise.
	(assignment, section): Update calls to exp_assign.
	* ldctor.c (ldctor_build_sets): Likewise.
	* mri.c (mri_format): Likewise.
	* ldlang.c (lang_insert_orphan, lang_leave_overlay): Likewise.
	(open_input_bfds): Remove --defsym symbols special case.
	* emultempl/beos.em (gld_${EMULATION_NAME}_set_symbols): Update
	call to exp_assign.
	* emultempl/pe.em (gld_${EMULATION_NAME}_set_symbols): Likewise.
	* emultempl/pep.em (gld_${EMULATION_NAME}_set_symbols): Likewise.
	* emultempl/spuelf.em (spu_place_special_section): Likewise.
	* emultempl/xtensaelf.em (ld_xtensa_insert_page_offsets):
	Likewise.
	* ld.texinfo (Assigning Values to Symbols): Add HIDDEN.
	(HIDDEN): New subsection.
@
text
@d575 3
a857 2
	  etree_type *name;

d875 1
a875 17
	  name = tree->assign.src;
	  if (name->type.node_class == etree_trinary)
	    {
	      exp_fold_tree_1 (name->trinary.cond);
	      if (expld.result.valid_p)
		name = (expld.result.value
			? name->trinary.lhs : name->trinary.rhs);
	    }

	  if (name->type.node_class == etree_name
	      && name->type.node_code == NAME
	      && strcmp (tree->assign.dst, name->name.name) == 0)
	    /* Leave it alone.  Do not replace a symbol with its own
	       output address, in case there is another section sizing
	       pass.  Folding does not preserve input sections.  */
	    break;

d877 12
a888 1
	  if (expld.result.valid_p
d936 1
@


1.101
log
@ld/
	* ldlang.h (lang_output_section_statement_type): Add after_end field.
	(lang_abs_symbol_at_beginning_of, lang_abs_symbol_at_end_of): Delete.
	(section_for_dot): Declare.
	* ldlang.c (lang_size_sections_1): Correct comment.
	(current_section): Move earlier.
	(current_assign, prefer_next_section): New static vars.
	(lang_do_assignments_1): Add found_end param.  Detect _end
	assignment to set found_end.  Set os->after_end.  Set above statics.
	(lang_do_assignments): Adjust lang_do_assignments_1 call.  Init
	vars.
	(section_for_dot): New function.
	(lang_set_startof): Don't make an absolute symbol.
	(lang_abs_symbol_at_beginning_of, lang_abs_symbol_at_end_of): Delete.
	* ldexp.c (new_rel_from_abs): Use section_for_dot.
	* emultempl/lnk960.em (symbol_at_beginning_of): New function.
	(symbol_at_end_of): Likewise.
	(lnk960_after_allocation): Use them.
	* scripttempl/elf.sc: Precede OTHER_GOT_SYMBOLS with . = .; and
	likewise before __bss_start.

ld/testsuite/
Update far too many tests.
@
text
@d895 1
a895 1
		  && tree->assign.hidden))
d1057 1
d1069 1
d1074 2
d1077 1
a1077 1
exp_assign (const char *dst, etree_type *src)
d1079 1
a1079 1
  return exp_assop (dst, src, etree_assign, FALSE);
d1082 2
d1087 1
a1087 1
  return exp_assop (dst, src, etree_assign, TRUE);
d1095 1
a1095 1
  return exp_assop (dst, src, etree_provide, hidden);
@


1.101.2.1
log
@bfd/
2012-08-09  Maciej W. Rozycki  <macro@@codesourcery.com>

	* elfxx-mips.c (LA25_LUI_MICROMIPS_1, LA25_LUI_MICROMIPS_2):
	Remove macros, folding them into...
	(LA25_LUI_MICROMIPS): ... this new macro.
	(LA25_J_MICROMIPS_1, LA25_J_MICROMIPS_2): Likewise into...
	(LA25_J_MICROMIPS): ... this new macro.
	(LA25_ADDIU_MICROMIPS_1, LA25_ADDIU_MICROMIPS_2): Likewise
	into...
	(LA25_ADDIU_MICROMIPS): ... this new macro.
	(bfd_put_micromips_32, bfd_get_micromips_32): New functions.
	(mips_elf_create_la25_stub): Use them.
	(check_br32_dslot, check_br32, check_relocated_bzc): Likewise.
	(_bfd_mips_elf_relax_section): Likewise.

gas/
	* config/tc-mips.c (NO_ISA_COP, COP_INSN): Remove macros.
	(is_opcode_valid): Remove coprocessor instruction exclusions.
	Replace OPCODE_IS_MEMBER with opcode_is_member.
	(is_opcode_valid_16): Replace OPCODE_IS_MEMBER with
	opcode_is_member.
	(macro): Remove coprocessor instruction exclusions.

gas/
	* gas/mips/mips.exp: Set has_newabi for all Linux targets.
	* gas/mips/cfi-n64-1.d: Adjust for targets that do not infer the
	ISA from the ABI.
	* gas/mips/elf-rel-got-n32.d: Likewise.
	* gas/mips/elf-rel-got-n64.d: Likewise.
	* gas/mips/elf-rel-xgot-n32.d: Likewise.
	* gas/mips/elf-rel-xgot-n64.d: Likewise.
	* gas/mips/elf-rel18.d: Likewise.
	* gas/mips/elf-rel28-n32.d: Likewise.
	* gas/mips/elf-rel28-n64.d: Likewise.
	* gas/mips/jal-newabi.d: Likewise.
	* gas/mips/ldstla-n64-shared.d: Likewise.
	* gas/mips/ldstla-n64-sym32.d: Likewise.
	* gas/mips/ldstla-n64.d: Likewise.
	* gas/mips/macro-warn-1-n32.d: Likewise.
	* gas/mips/macro-warn-2-n32.d: Likewise.
	* gas/mips/n32-consec.d: Likewise.

include/
2012-08-13  Richard Sandiford  <rdsandiford@@googlemail.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

	* mips.h (mips_opcode): Add the exclusions field.
	(OPCODE_IS_MEMBER): Remove macro.
	(cpu_is_member): New inline function.
	(opcode_is_member): Likewise.

ld/
	* emulparams/elf32bmip.sh: Make _gp hidden.
	* emulparams/elf32bmipn32-defs.sh: Likewise.
	* emulparams/elf32mipswindiss.sh: Likewise.
	* scripttempl/mips.sc: Likewise.

ld/
2012-08-28  Maciej W. Rozycki  <macro@@codesourcery.com>

	* ld-elf/export-class.sd: New test.
	* ld-elf/export-class.vd: New test.
	* ld-elf/export-class-def.s: New test source.
	* ld-elf/export-class-dep.s: New test source.
	* ld-elf/export-class-lib.s: New test source.
	* ld-elf/export-class-ref.s: New test source.
	* ld-elf/export-class-lib.ver: New test version script.
	* ld-elf/export-class.exp: New test script.
	* ld-arm/arm-export-class.rd: New test.
	* ld-arm/arm-export-class.xd: New test.
	* ld-arm/export-class.exp: New test script.
	* ld-i386/i386-export-class.rd: New test.
	* ld-i386/i386-export-class.xd: New test.
	* ld-i386/export-class.exp: New test script.
	* ld-mips-elf/mips-32-export-class.rd: New test.
	* ld-mips-elf/mips-32-export-class.xd: New test.
	* ld-mips-elf/mips-64-export-class.rd: New test.
	* ld-mips-elf/mips-64-export-class.xd: New test.
	* ld-mips-elf/export-class.exp: New test script.
	* ld-powerpc/powerpc-32-export-class.rd: New test.
	* ld-powerpc/powerpc-32-export-class.xd: New test.
	* ld-powerpc/powerpc-64-export-class.rd: New test.
	* ld-powerpc/powerpc-64-export-class.xd: New test.
	* ld-powerpc/export-class.exp: New test script.
	* ld-x86-64/x86-64-64-export-class.rd: New test.
	* ld-x86-64/x86-64-x32-export-class.rd: New test.
	* ld-x86-64/export-class.exp: New test script.

opcodes/
2012-08-14  Maciej W. Rozycki  <macro@@codesourcery.com>

	* mips-dis.c (print_insn_args): Add GET_OP and GET_OP_S local
	macros, use local variables for info struct member accesses,
	update the type of the variable used to hold the instruction
	word.
	(print_insn_mips, print_mips16_insn_arg): Likewise.
	(print_insn_mips16): Add GET_OP and GET_OP_S local macros, use
	local variables for info struct member accesses.
	(print_insn_micromips): Add GET_OP_S local macro.
	(_print_insn_mips): Update the type of the variable used to hold
	the instruction word.
@
text
@d895 1
a895 1
		  && tree->assign.defsym))
a1056 1
	   bfd_boolean defsym,
a1067 1
  n->assign.defsym = defsym;
a1071 2
/* Handle linker script assignments and HIDDEN.  */

d1073 1
a1073 1
exp_assign (const char *dst, etree_type *src, bfd_boolean hidden)
d1075 1
a1075 1
  return exp_assop (dst, src, etree_assign, FALSE, hidden);
a1077 2
/* Handle --defsym command-line option.  */

d1081 1
a1081 1
  return exp_assop (dst, src, etree_assign, TRUE, FALSE);
d1089 1
a1089 1
  return exp_assop (dst, src, etree_provide, FALSE, hidden);
@


1.101.2.2
log
@	PR 12549
	PR 14493
	PR 14567
	PR 14662
	PR 14758
	PR 14813
	PR 14904
	PR 14915
	PR 14926
	PR 14950
	PR 14962
	Apply mainline patches
@
text
@a574 3
      if (expld.assign_name != NULL
	  && strcmp (expld.assign_name, tree->name.name) == 0)
	expld.assign_name = NULL;
d855 2
d874 17
a890 1
	  expld.assign_name = tree->assign.dst;
d892 1
a892 12
	  /* expld.assign_name remaining equal to tree->assign.dst
	     below indicates the evaluation of tree->assign.src did
	     not use the value of tree->assign.dst.  We don't allow
	     self assignment until the final phase for two reasons:
	     1) Expressions are evaluated multiple times.  With
	     relaxation, the number of times may vary.
	     2) Section relative symbol values cannot be correctly
	     converted to absolute values, as is required by many
	     expressions, until final section sizing is complete.  */
	  if ((expld.result.valid_p
	       && (expld.phase == lang_final_phase_enum
		   || expld.assign_name != NULL))
a939 1
	  expld.assign_name = NULL;
@


1.100
log
@Don't hardcode .got.plt into DATA_SEGMENT_RELRO_END evaluation

ld/

	PR ld/14215
	* ldexp.c (fold_name <SIZEOF, ALIGNOF>): Allow forward section
	references.
	* emulparams/elf32_x86_64.sh (SEPARATE_GOTPLT): Depend on size of
	.got.plt.
	* emulparams/elf32mb_linux.sh (SEPARATE_GOTPLT): Likewise.
	* emulparams/elf32tilegx.sh (SEPARATE_GOTPLT): Likewise.
	* emulparams/elf32tilepro.sh (SEPARATE_GOTPLT): Likewise.
	* emulparams/elf64tilegx.sh (SEPARATE_GOTPLT): Likewise.
	* emulparams/elf_i386.sh (SEPARATE_GOTPLT): Likewise.
	* emulparams/elf_k1om.sh (SEPARATE_GOTPLT): Likewise.
	* emulparams/elf_l1om.sh (SEPARATE_GOTPLT): Likewise.
	* emulparams/elf_x86_64.sh (SEPARATE_GOTPLT): Likewise.

ld/testsuite/

	PR ld/14215
	* ld-i386/i386.exp: Run pr14215.
	* ld-x86-64/x86-64.exp: Likewise.

	* ld-i386/pr14215.d: New file.
	* ld-i386/pr14215.s: Likewise.
	* ld-x86-64/pr14215.d: Likewise.
	* ld-x86-64/pr14215.s: Likewise.
@
text
@d216 4
d221 1
a221 1
  expld.result.value = value - expld.section->vma;
d223 1
a223 1
  expld.result.section = expld.section;
@


1.99
log
@	PR ld/13839
	* ldexp.c (fold_name): Ignore undefined symbols when assigning to
	dot in mark phase.
	(exp_fold_tree_1): Evaluate assignment to dot expressions even when
	discarding result, for side effects.  Fix typo in error message.
@
text
@d684 1
a684 1
	  else if (os->processed_vma)
d696 2
@


1.98
log
@2012-03-08  Tristan Gingold  <gingold@@adacore.com>

        * ldexp.c (exp_print_tree): Special case for SEGMENT_START.
        (exp_print_token): Constify.
@
text
@d609 2
a610 1
		   || expld.assigning_to_dot)
d801 1
a801 8
	  /* After allocation, assignment to dot should not be done inside
	     an output section since allocation adds a padding statement
	     that effectively duplicates the assignment.  */
	  if (expld.phase == lang_mark_phase_enum
	      || expld.phase == lang_allocating_phase_enum
	      || ((expld.phase == lang_assigning_phase_enum
		   || expld.phase == lang_final_phase_enum)
		  && expld.section == bfd_abs_section_ptr))
d816 8
a823 2
			 " invalid outside of SECTION\n"), tree);
	      else
@


1.97
log
@	PR ld/13683
	* ldlang.c (lang_process): Rerun lang_do_assignments before
	starting garbage collection.
	* ldexp.c (fold_name): Generate a reloc for defined symbols
	found without an associated output section during the mark phase.
	(exp_fold_tree_1): Continue processing an expression, even if we
	are unable to fold it, if we are in the first two evaluation
	phases.
	* ldexp.h (enum lang_phase_type): Add descriptions of the phases.

	* ld-gc/pr13683.c: New test source file.
	* ld-gc/pr13683.d: New test control and output file.
	* ld-gc/gc.exp: Run the pr13683 test.

	* ld-cris/tls-gc-68: Update expected symbol table dump.
	* ld-cris/tls-gc-69: Likewise.
	* ld-cris/tls-gc-70: Likewise.
	* ld-cris/tls-gc-71: Likewise.
	* ld-cris/tls-gc-75: Likewise.
	* ld-cris/tls-gc-76.d: Likewise.
	* ld-cris/tls-gc-79.d: Likewise.
@
text
@d62 1
a62 1
    char * name;
d1148 11
@


1.96
log
@	PR ld/13343
	* ld.h (parsing_defsym): Delete.
	* ldexp.c (exp_intop, exp_bigintop, exp_relop): Set type.filename.
	(fold_binary, fold_name, exp_fold_tree_1, exp_get_vma, exp_get_fill,
	exp_get_abs_int): Add tree arg for %S in error messages.  Don't
	fudge lineno.
	(exp_binop, exp_unop, exp_nameop, exp_assop, exp_assert): Copy
	type.filename from sub-tree.
	(exp_trinop): Likewise, and use "cond" rather than "lhs".
	* ldexp.h (node_type): Add filename field to struct.
	* ldfile.c (ldfile_input_filename): Delete.  Remove all refs.
	* ldfile.h (ldfile_input_filename): Delete.
	* ldgram.y (phdr_type, phdr_qualifiers, yyerror): Add NULL arg for
	%S in error messages.
	* ldemul.c (syslib_default, hll_default): Likewise.
	* ldlang.c (lang_memory_region_lookup, lang_memory_region_alias,
	lang_get_regions, lang_new_phdr): Likewise.
	(lang_size_sections_1): Pass addr_tree for %S.
	* ldlex.h (lex_redirect): Update prototype.
	(ldlex_filename): Declare.
	* ldlex.l (<EOF>): Don't set ldfile_input_filename.
	(lex_redirect): Add fake_filename and count params.  Push
	fake_filename to file_name_stack and init lineno from count.
	(ldlex_filename): New function.
	(lex_warn_invalid): Use above.
	* ldmain.c (main): Update lex_redirect call.
	* ldmisc.c (vfinfo <%S>): Take file name and line number from
	etree_type arg, or use current if arg is NULL.
	* lexsup.c (parsing_defsym): Delete.
	(parse_args <OPTION_DEFSYM>): Update lex_redirect call.
@
text
@d593 3
a595 1
		  if (expld.phase != lang_mark_phase_enum)
d887 1
a887 1
	      || (expld.phase == lang_first_phase_enum
@


1.95
log
@	* ldlang.c (print_assignment): Use the symbol's section if we
	use its value.
	* ldexp.c (exp_fold_tree_1): Skip self-assignment.  Expand
	comment on copying symbol type.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
d159 1
d172 1
d187 1
d410 1
a410 1
	    einfo (_("%F%S %% by zero\n"));
d420 1
a420 1
	    einfo (_("%F%S / by zero\n"));
d596 1
a596 1
			   tree->name.name);
d608 3
a610 2
	    einfo (_("%F%S: undefined symbol `%s' referenced in expression\n"),
		   tree->name.name);
d630 3
a632 2
		einfo (_("%F%S: undefined section `%s' referenced in expression\n"),
		       tree->name.name);
d648 3
a650 2
		einfo (_("%F%S: undefined section `%s' referenced in expression\n"),
		       tree->name.name);
d676 3
a678 2
		einfo (_("%F%S: undefined section `%s' referenced in expression\n"),
		       tree->name.name);
d705 2
a706 1
		   " referenced in expression\n"), tree->name.name);
d720 2
a721 1
		     " referenced in expression\n"), tree->name.name);
d732 1
a732 1
	       tree->name.name);
d796 2
a797 1
	    einfo (_("%F%S can not PROVIDE assignment to location counter\n"));
d815 2
a816 1
		    einfo (_("%F%S invalid assignment to location counter\n"));
d820 1
a820 1
			 " invalid outside of SECTION\n"));
d833 2
a834 1
			     " (from %V to %V)\n"), expld.dot, nextdot);
d970 1
d990 2
a991 1
  value.type.lineno = lhs->type.lineno;
d1011 1
d1030 1
d1055 1
d1093 1
d1209 2
a1210 1
	einfo (_("%F%S: nonconstant expression for %s\n"), name);
d1235 2
a1236 1
	einfo (_("%F%S: nonconstant expression for %s\n"), name);
d1295 2
a1296 2
	  lineno = tree->type.lineno;
	  einfo (_("%F%S: nonconstant expression for %s\n"), name);
@


1.94
log
@	PR ld/12726
	* ldexp.h (lang_phase_type): Add lang_assigning_phase_enum.
	* ldexp.c (exp_fold_tree_1): Correct assign to dot comment.  Don't
	assign to dot when lang_assigning_phase_enum.
	* ldlang.h (lang_do_assignments): Update prototype.
	* ldlang.c (lang_do_assignments): Add phase parameter.  Update all
	callers.
	* pe-dll.c (pe_dll_fill_sections, pe_exe_fill_sections): Update
	lang_do_assignments calls.
@
text
@d835 2
d854 17
d898 2
a899 1
	         one symbol to annother.  */
@


1.93
log
@	* ldexp.c (fold_binary): Set result section for arithmetic and
	logical operations to NULL when both operands are in same section.
	* ld.texinfo (Expression Section): Describe this.
@
text
@a785 1
	  /* Assignment to dot can only be done during allocation.  */
d788 3
d793 2
a794 1
	      || (expld.phase == lang_final_phase_enum
@


1.92
log
@	PR ld/12356
	* ld.texinfo (Miscellaneous Commands): Describe LD_FEATURE.
	(Expression Section): Update.
	* ld.h (ld_config_type): Add sane_expr.
	* ldgram.y (ifile_p1): Add LD_FEATURE.
	* ldlex.l (LD_FEATYRE): New.
	* ldemul.c (after_parse_default): Delete code handling ld_compatibility.
	* ldexp.h (struct ldexp_control): Delete uses_defined.
	* ldexp.c: Remove all uses of uses_defined.
	(fold_name): Test config.sane_expr rather than ld_compatibility.
	(exp_fold_tree_1): Likewise.  Adjust handling of assignments
	during first phase.
	* ldlang.h (ld_compatibility): Delete.
	(lang_ld_feature): Declare.
	* ldlang.c (ld_compatibility): Delete.
	(open_input_bfds): Only handle assignments for --defsym.
	(lang_ld_feature): New function.
@
text
@d338 1
d343 6
a348 1
	    expld.result.section = lhs.section;
d350 2
d355 15
a369 16
	case '%':
	  if (expld.result.value != 0)
	    expld.result.value = ((bfd_signed_vma) lhs.value
				  % (bfd_signed_vma) expld.result.value);
	  else if (expld.phase != lang_mark_phase_enum)
	    einfo (_("%F%S %% by zero\n"));
	  break;

	case '/':
	  if (expld.result.value != 0)
	    expld.result.value = ((bfd_signed_vma) lhs.value
				  / (bfd_signed_vma) expld.result.value);
	  else if (expld.phase != lang_mark_phase_enum)
	    einfo (_("%F%S / by zero\n"));
	  break;

d373 2
d377 2
d402 20
@


1.91
log
@	PR ld/12356
	* ldexp.h (exp_assop): Delete.
	(exp_assign, exp_defsym): Declare.
	* ldexp.c (exp_assop): Make static, handle all assignment variations.
	(exp_assign, exp_defsym): New functions.
	(exp_provide): Use exp_assop.
	* ldgram.y (defsym_expr): Use exp_defsym.
	* ldctor.c, * ldgram.y, * ldlang.c, * mri.c, * emultempl/beos.em,
	* emultempl/pe.em, * emultempl/pep.em, * emultempl/spuelf.em,
	* emultempl/xtensaelf.em: Update exp_assop -> exp_assign.
@
text
@a514 1
      expld.uses_defined = TRUE;
d566 1
a566 1
			   || ld_compatibility >= 221))
d714 1
a714 1
	  && ld_compatibility < 221)
d821 2
a822 1
		  && !expld.uses_defined))
a885 1
  expld.uses_defined = FALSE;
a894 1
  expld.uses_defined = FALSE;
@


1.90
log
@	PR ld/12380
	* ldexp.h (enum phase_enum): Comment.  Add exp_dataseg_done.
	* ldexp.c (fold_unary <DATA_SEGMENT_END>): Rearrange code.  Test
	for exp_dataseg_done rather than expld.phase == lang_final_phase_enum
	to detect when we've finished sizing sections.
	(fold_binary <DATA_SEGMENT_ALIGN>): Likewise.
	(fold_binary <DATA_SEGMENT_RELRO_END>): Likewise.  Also test
	that we are not inside an output section statement.
	* ldlang.c (lang_size_sections): Set exp_dataseg_done on exit if
	not exp_dataseg_relro_adjust or exp_dataseg_adjust.  Don't set
	lang_final_phase_enum here.
	(lang_process): Set lang_final_phase_enum here.
@
text
@d977 18
d996 1
a996 1
exp_assop (int code, const char *dst, etree_type *src)
d998 2
a999 1
  etree_type *new_e;
d1001 4
a1004 7
  new_e = (etree_type *) stat_alloc (sizeof (new_e->assign));
  new_e->type.node_code = code;
  new_e->type.lineno = src->type.lineno;
  new_e->type.node_class = etree_assign;
  new_e->assign.src = src;
  new_e->assign.dst = dst;
  return new_e;
d1012 1
a1012 10
  etree_type *n;

  n = (etree_type *) stat_alloc (sizeof (n->assign));
  n->assign.type.node_code = '=';
  n->assign.type.lineno = src->type.lineno;
  n->assign.type.node_class = etree_provide;
  n->assign.src = src;
  n->assign.dst = dst;
  n->assign.hidden = hidden;
  return n;
@


1.89
log
@	* ld.texinfo (Expression Section): Describe treatment of numbers
	and absolute symbols.
	* ldemul.c (after_open_default): Look up __ld_compatibility.
	* ldexp.c (fold_name): Convert absolute symbols to numbers when
	inside output section definitions, or when __ld_compatibility >= 221.
	(exp_fold_tree_1): Convert numbers to absolute when not in output
	section definition and __ld_compatibility < 221.  Don't always
	convert values outside an output section definition to absolute.
	* ldexp.h (uses_defined): Comment.
	* ldlang.c (ld_compatibility): New variable.
	* ldlang.h (ld_compatibility): Declare.
	* emultempl/aix.em, * emultempl/armcoff.em, * emultempl/beos.em,
	* emultempl/elf32.em, * emultempl/genelf.em, * emultempl/lnk960.em,
	* emultempl/m68kcoff.em, * emultempl/mmo.em, * emultempl/pe.em,
	* emultempl/pep.em, * emultempl/sunos.em, * emultempl/z80.em: Call
	after_open_default from after_open function.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
d262 2
a263 7
	  if (expld.phase != lang_first_phase_enum
	      && expld.section == bfd_abs_section_ptr
	      && (expld.dataseg.phase == exp_dataseg_align_seen
		  || expld.dataseg.phase == exp_dataseg_relro_seen
		  || expld.dataseg.phase == exp_dataseg_adjust
		  || expld.dataseg.phase == exp_dataseg_relro_adjust
		  || expld.phase == lang_final_phase_enum))
d265 13
a277 6
	      if (expld.dataseg.phase == exp_dataseg_align_seen
		  || expld.dataseg.phase == exp_dataseg_relro_seen)
		{
		  expld.dataseg.phase = exp_dataseg_end_seen;
		  expld.dataseg.end = expld.result.value;
		}
d407 4
a410 6
	  if (expld.phase != lang_first_phase_enum
	      && expld.section == bfd_abs_section_ptr
	      && (expld.dataseg.phase == exp_dataseg_none
		  || expld.dataseg.phase == exp_dataseg_adjust
		  || expld.dataseg.phase == exp_dataseg_relro_adjust
		  || expld.phase == lang_final_phase_enum))
d418 7
a424 1
	      else if (expld.dataseg.phase != exp_dataseg_adjust)
d427 5
a431 1
		  if (expld.phase == lang_allocating_phase_enum)
d440 2
a442 3
	      else if (commonpage < maxpage)
		expld.result.value += ((expld.dot + commonpage - 1)
				       & (maxpage - commonpage));
a443 2
	  else
	    expld.result.valid_p = FALSE;
d448 7
a454 5
	  if (expld.phase != lang_first_phase_enum
	      && (expld.dataseg.phase == exp_dataseg_align_seen
		  || expld.dataseg.phase == exp_dataseg_adjust
		  || expld.dataseg.phase == exp_dataseg_relro_adjust
		  || expld.phase == lang_final_phase_enum))
@


1.88
log
@	PR ld/12001
	Revert 2010-11-03 Nick Clifton
	* ldlang.c (ldlang_def_chain_list): Delete.
	(insert_defined, ldlang_add_def, lang_place_defineds): Delete.
	(lang_process): Don't call lang_place_defineds.
	(lang_add_assignment): Don't do anything special for --defsym.

	* ldexp.h (struct ldexp_control): Add uses_defined.
	(exp_fold_tree_no_dot): Declare.
	* ldexp.c (exp_fold_tree): Clear uses_defined.
	(exp_fold_tree_no_dot): Likewise.  Make global.
	(fold_name <DEFINED>): Set uses_defined.
	(exp_fold_tree_1 <etree_assign>): Define symbol during first phase
	even when the value being assigned isn't valid.
	* ldlang.c (open_input_bfds): Process assignment statements.
	(lang_process): Bump lang_statement_iteration.
	(scan_for_self_assignment): Formatting.
	(print_assignment): Style.

testsuite/
	* ld-scripts/default-script2.d: Revert 2010-11-03 change.
@
text
@d556 3
a558 1
	      else if (output_section == bfd_abs_section_ptr)
d705 5
a709 1
      new_number (tree->value.value);
a868 6

  /* Any value not inside an output section statement is an
     absolute value.  */
  if (expld.result.valid_p
      && expld.section == bfd_abs_section_ptr)
    make_abs ();
@


1.87
log
@	PR ld/12066
	* ldexp.c (fold_name): Treat absolute symbols as plain numbers.
	* ld.texinfo (Expression Section): Don't say absolute symbols
	are addresses.
@
text
@a46 1
static void exp_fold_tree_no_dot (etree_type *);
d506 1
d805 3
a807 1
	  if (expld.result.valid_p)
d877 1
d881 1
a881 1
static void
d887 1
@


1.87.2.1
log
@backport from mainline
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
d47 1
d263 7
a269 2
	  if (expld.phase == lang_first_phase_enum
	      || expld.section != bfd_abs_section_ptr)
d271 6
a276 13
	      expld.result.valid_p = FALSE;
	    }
	  else if (expld.dataseg.phase == exp_dataseg_align_seen
		   || expld.dataseg.phase == exp_dataseg_relro_seen)
	    {
	      expld.dataseg.phase = exp_dataseg_end_seen;
	      expld.dataseg.end = expld.result.value;
	    }
	  else if (expld.dataseg.phase == exp_dataseg_done
		   || expld.dataseg.phase == exp_dataseg_adjust
		   || expld.dataseg.phase == exp_dataseg_relro_adjust)
	    {
	      /* OK.  */
a336 1
	      lhs.section = bfd_abs_section_ptr;
d341 1
a341 6
	    {
	      expld.result.section = lhs.section;
	      /* Make this NULL so that we know one of the operands
		 was just a number, for later tests.  */
	      lhs.section = NULL;
	    }
a342 2
      /* At this point we know that both operands have the same
	 section, or at least one of them is a plain number.  */
d346 16
a361 15
	  /* Arithmetic operators, bitwise AND, bitwise OR and XOR
	     keep the section of one of their operands only when the
	     other operand is a plain number.  Losing the section when
	     operating on two symbols, ie. a result of a plain number,
	     is required for subtraction and XOR.  It's justifiable
	     for the other operations on the grounds that adding,
	     multiplying etc. two section relative values does not
	     really make sense unless they are just treated as
	     numbers.
	     The same argument could be made for many expressions
	     involving one symbol and a number.  For example,
	     "1 << x" and "100 / x" probably should not be given the
	     section of x.  The trouble is that if we fuss about such
	     things the rules become complex and it is onerous to
	     document ld expression evaluation.  */
a364 2
	  if (expld.result.section == lhs.section)		\
	    expld.result.section = NULL;			\
a366 2
	  /* Comparison operators, logical AND, and logical OR always
	     return a plain number.  */
a389 20
	case '%':
	  if (expld.result.value != 0)
	    expld.result.value = ((bfd_signed_vma) lhs.value
				  % (bfd_signed_vma) expld.result.value);
	  else if (expld.phase != lang_mark_phase_enum)
	    einfo (_("%F%S %% by zero\n"));
	  if (expld.result.section == lhs.section)
	    expld.result.section = NULL;
	  break;

	case '/':
	  if (expld.result.value != 0)
	    expld.result.value = ((bfd_signed_vma) lhs.value
				  / (bfd_signed_vma) expld.result.value);
	  else if (expld.phase != lang_mark_phase_enum)
	    einfo (_("%F%S / by zero\n"));
	  if (expld.result.section == lhs.section)
	    expld.result.section = NULL;
	  break;

d406 6
a411 4
	  if (expld.phase == lang_first_phase_enum
	      || expld.section != bfd_abs_section_ptr)
	    expld.result.valid_p = FALSE;
	  else
d419 1
a419 7
	      else if (expld.dataseg.phase == exp_dataseg_adjust)
		{
		  if (commonpage < maxpage)
		    expld.result.value += ((expld.dot + commonpage - 1)
					   & (maxpage - commonpage));
		}
	      else
d422 1
a422 5
		  if (expld.dataseg.phase == exp_dataseg_done)
		    {
		      /* OK.  */
		    }
		  else if (expld.dataseg.phase == exp_dataseg_none)
a430 2
		  else
		    expld.result.valid_p = FALSE;
d432 3
d436 2
d442 5
a446 7
	  if (expld.phase == lang_first_phase_enum
	      || expld.section != bfd_abs_section_ptr)
	    expld.result.valid_p = FALSE;
	  else if (expld.dataseg.phase == exp_dataseg_align_seen
		   || expld.dataseg.phase == exp_dataseg_adjust
		   || expld.dataseg.phase == exp_dataseg_relro_adjust
		   || expld.dataseg.phase == exp_dataseg_done)
d556 1
a556 3
	      else if (output_section == bfd_abs_section_ptr
		       && (expld.section != bfd_abs_section_ptr
			   || config.sane_expr))
d703 1
a703 5
      if (expld.section == bfd_abs_section_ptr
	  && !config.sane_expr)
	new_abs (tree->value.value);
      else
	new_number (tree->value.value);
d805 1
a805 4
	  if (expld.result.valid_p
	      || (expld.phase == lang_first_phase_enum
		  && tree->type.node_class == etree_assign
		  && tree->assign.hidden))
d861 6
d878 1
a878 1
void
d964 18
a981 5
static etree_type *
exp_assop (const char *dst,
	   etree_type *src,
	   enum node_tree_enum class,
	   bfd_boolean hidden)
d988 1
a988 1
  n->assign.type.node_class = class;
a994 20
etree_type *
exp_assign (const char *dst, etree_type *src)
{
  return exp_assop (dst, src, etree_assign, FALSE);
}

etree_type *
exp_defsym (const char *dst, etree_type *src)
{
  return exp_assop (dst, src, etree_assign, TRUE);
}

/* Handle PROVIDE.  */

etree_type *
exp_provide (const char *dst, etree_type *src, bfd_boolean hidden)
{
  return exp_assop (dst, src, etree_provide, hidden);
}

@


1.87.2.2
log
@	PR ld/12726
	* ldexp.h (lang_phase_type): Add lang_assigning_phase_enum.
	* ldexp.c (exp_fold_tree_1): Correct assign to dot comment.  Don't
	assign to dot when lang_assigning_phase_enum.
	* ldlang.h (lang_do_assignments): Update prototype.
	* ldlang.c (lang_do_assignments): Add phase parameter.  Update all
	callers.
	* pe-dll.c (pe_dll_fill_sections, pe_exe_fill_sections): Update
	lang_do_assignments calls.
@
text
@d786 1
a788 3
	  /* After allocation, assignment to dot should not be done inside
	     an output section since allocation adds a padding statement
	     that effectively duplicates the assignment.  */
d791 1
a791 2
	      || ((expld.phase == lang_assigning_phase_enum
		   || expld.phase == lang_final_phase_enum)
@


1.87.2.3
log
@	PR 12365
	PR 12613
	PR 12632
	PR 12739
	PR 12753
	PR 12760
	PR 12763
Apply fix from mainline along with assorted other small fixes.
@
text
@a834 2
	  etree_type *name;

a851 17
	  name = tree->assign.src;
	  if (name->type.node_class == etree_trinary)
	    {
	      exp_fold_tree_1 (name->trinary.cond);
	      if (expld.result.valid_p)
		name = (expld.result.value
			? name->trinary.lhs : name->trinary.rhs);
	    }

	  if (name->type.node_class == etree_name
	      && name->type.node_code == NAME
	      && strcmp (tree->assign.dst, name->name.name) == 0)
	    /* Leave it alone.  Do not replace a symbol with its own
	       output address, in case there is another section sizing
	       pass.  Folding does not preserve input sections.  */
	    break;

d879 1
a879 2
	         one symbol to another.  This could be more general
		 (e.g. a ?: operator with NAMEs in each branch).  */
@


1.86
log
@binutils/
	* NEWS: Mention change in linker script expression evaluation.
ld/
	* ld.texinfo (Expression Section): Detail expression evaluation.
	(Builtin Functions <ADDR>): Correct.
	(Builtin Functions <LOADADDR>): Don't mention LOADADDR normally
	the same as ADDR.
	(Builtin Functions <SEGMENT_START>): Typo fix.
	* ldexp.c (new_number): New function.
	(make_abs, exp_get_abs_int): Cope with NULL expld.result.section.
	(fold_unary <'~', '!', '-'>): Don't make_abs.
	(fold_binary): Simplify result section logic.  Return NULL section
	for logical ops.
	(fold_binary <SEGMENT_START>): Use new_rel_from_abs to set value to
	a consistent result.
	(fold_name <SIZEOF_HEADERS>): Return new_number, not new_abs.
	(fold_name <DEFINED, SIZEOF, ALIGNOF, LENGTH, CONSTANT>): Likewise.
	(fold_name <NAME>): No need to handle absolute symbols differently
	from relative ones.
	(fold_name <ORIGIN>): Don't return valid result when
	lang_first_phase_enum.  Return new_rel_from_abs, not new_abs.
	(exp_fold_tree_1 <etree_value>): Return new_number, not new_rel.
	(exp_fold_tree_1): Ajust for NULL expld.result.section.  When assigning
	a plain number to dot, assume the value is relative to expld.section.
	Make terms not in an output section, absolute.
	* ldlang.c (print_assignment): Fix style nit.
	(lang_size_sections_1): Cope with NULL expld.result.section.
	(lang_do_assignments_1): Likewise.
ld/testsuite/
	* ld-scripts/memory.t: Remove ORIGIN fudge.
@
text
@d556 2
@


1.85
log
@	* ldexp.c (new_rel): Remove "str".  Update all call sites.
	(exp_fold_tree_1): When assigning to dot, calculate nextdot
	using expld.result.section rather than expld.section.
@
text
@d141 2
a142 1
  expld.result.value += expld.result.section->vma;
d194 9
a239 1
	  make_abs ();
a243 1
	  make_abs ();
a247 1
	  make_abs ();
d303 1
d316 1
a316 3
	    expld.result.value = seg->value;
	    expld.result.str = NULL;
	    expld.result.section = expld.section;
d328 1
a328 8
      /* If the values are from different sections, or this is an
	 absolute expression, make both the source arguments
	 absolute.  However, adding or subtracting an absolute
	 value from a relative value is meaningful, and is an
	 exception.  */
      if (expld.section != bfd_abs_section_ptr
	  && lhs.section == bfd_abs_section_ptr
	  && tree->type.node_code == '+')
d330 12
a341 17
	  /* Keep the section of the rhs term.  */
	  expld.result.value = lhs.value + expld.result.value;
	  return;
	}
      else if (expld.section != bfd_abs_section_ptr
	       && expld.result.section == bfd_abs_section_ptr
	       && (tree->type.node_code == '+'
		   || tree->type.node_code == '-'))
	{
	  /* Keep the section of the lhs term.  */
	  expld.result.section = lhs.section;
	}
      else if (expld.result.section != lhs.section
	       || expld.section == bfd_abs_section_ptr)
	{
	  make_abs ();
	  lhs.value += lhs.section->vma;
d363 9
a371 3
	    case x:							\
	      expld.result.value = lhs.value y expld.result.value;	\
	      break;
a377 6
	  BOP (EQ, ==);
	  BOP (NE, !=);
	  BOP ('<', <);
	  BOP ('>', >);
	  BOP (LE, <=);
	  BOP (GE, >=);
d381 8
a388 2
	  BOP (ANDAND, &&);
	  BOP (OROR, ||);
d502 1
a502 1
	  new_abs (hdr_size);
d519 6
a524 8
	  expld.result.value = (h != NULL
				&& (h->type == bfd_link_hash_defined
				    || h->type == bfd_link_hash_defweak
				    || h->type == bfd_link_hash_common)
				&& (def_iteration == lang_statement_iteration
				    || def_iteration == -1));
	  expld.result.section = expld.section;
	  expld.result.valid_p = TRUE;
d546 4
a549 3
	      if (bfd_is_abs_section (h->u.def.section))
		new_abs (h->u.def.value);
	      else
d551 4
a554 13
		  asection *output_section;

		  output_section = h->u.def.section->output_section;
		  if (output_section == NULL)
		    {
		      if (expld.phase != lang_mark_phase_enum)
			einfo (_("%X%S: unresolvable symbol `%s'"
				 " referenced in expression\n"),
			       tree->name.name);
		    }
		  else
		    new_rel (h->u.def.value + h->u.def.section->output_offset,
			     output_section);
d556 3
d629 1
a629 1
	      new_abs (0);
d641 1
a641 1
	      new_abs (val);
d652 1
a652 1
          new_abs (mem->length);
d660 3
a662 2
      {
        lang_memory_region_type *mem;
d664 7
a670 7
        mem = lang_memory_region_lookup (tree->name.name, FALSE);  
        if (mem != NULL) 
          new_abs (mem->origin);
        else          
          einfo (_("%F%S: undefined MEMORY region `%s'"
		   " referenced in expression\n"), tree->name.name);
      }
d675 1
a675 1
	new_abs (config.maxpagesize);
d677 1
a677 1
	new_abs (config.commonpagesize);
d701 1
a701 1
      new_rel (tree->value.value, expld.section);
d764 5
a768 1
		  nextdot = expld.result.value + expld.result.section->vma;
d819 2
d859 6
d1195 2
a1196 1
	  expld.result.value += expld.result.section->vma;
@


1.84
log
@	* ldexp.c (exp_print_tree): Print function-like binary nodes as
	functions rather than in-fix operators.  Use fputs and fputc
	where appropriate.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
d193 1
a193 1
new_rel (bfd_vma value, char *str, asection *section)
d197 1
a197 1
  expld.result.str = str;
d564 1
a564 1
			     NULL, output_section);
d594 1
a594 1
	    new_rel (0, NULL, os->bfd_section);
d707 2
a708 1
      new_rel (tree->value.value, tree->value.str, expld.section);
d716 1
a716 1
		   NULL, output_section);
d770 1
a770 1
		  nextdot = expld.result.value + expld.section->vma;
@


1.83
log
@Warn if value of SEGMENT_START isn't multiple of maximum page size.

ld/

2010-05-26  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11628
	* ldexp.c (fold_binary): Warn if value of SEGMENT_START isn't
	multiple of maximum page size.

ld/testsuite/

2010-05-26  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11628
	* ld-elf/textaddr3.d: New.
	* ld-elf/textaddr4.d: Likewise.
	* ld-elf/textaddr5.d: Likewise.
	* ld-elf/textaddr6.d: Likewise.
	* ld-elf/textaddr7.d: Likewise.
@
text
@d1005 2
d1027 1
a1027 1
      fprintf (config.map_file, "%s", tree->assign.dst);
d1035 1
a1035 1
      fprintf (config.map_file, ")");
d1038 16
a1053 1
      fprintf (config.map_file, "(");
d1055 4
a1058 1
      exp_print_token (tree->type.node_code, TRUE);
d1060 1
a1060 1
      fprintf (config.map_file, ")");
d1064 1
a1064 1
      fprintf (config.map_file, "?");
d1066 1
a1066 1
      fprintf (config.map_file, ":");
d1075 1
a1075 1
	  fprintf (config.map_file, ")");
d1087 1
a1087 3
	{
	  fprintf (config.map_file, "%s", tree->name.name);
	}
@


1.82
log
@	PR ld/11583
	* ldexp.c (exp_fold_tree_1): If assignment source expression is
	invalid, make the destination symbol undefined.
@
text
@d302 5
@


1.81
log
@2009-11-23  Paul Brook  <paul@@codesourcery.com>

	ld/
	* ldexp.c: Copy symbol type for simple assignments.

	bfd/
	* libbfd-in.h (_bfd_generic_copy_link_hash_symbol_type): Add
	prototype.
	* elf-bfd.h (_bfd_elf_copy_link_hash_symbol_type): Add prototype.
	* linker.c (_bfd_generic_copy_link_hash_symbol_type): New function.
	* elflink.c (_bfd_elf_copy_link_hash_symbol_type): New function.
	* targets.c (BFD_JUMP_TABLE_LINK, struct bfd_target): Add
	_copy_link_hash_symbol_type.
	* bfd/coff64-rs6000.c (rs6000coff64_vec, aix5coff64_vec): Add
	_bfd_generic_copy_link_hash_symbol_type.
	* bfd/coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Add
	_bfd_generic_copy_link_hash_symbol_type.
	* aout-adobe.c (aout_32_bfd_copy_link_hash_symbol_type): Define.
	* aout-target.h (MY_bfd_copy_link_hash_symbol_type): Define.
	* aout-tic30.c (MY_bfd_copy_link_hash_symbol_type): Define.
	* binary.c (binary_bfd_copy_link_hash_symbol_type): Define.
	* bout.c (b_out_bfd_copy_link_hash_symbol_type): Define.
	* coffcode.h (coff_bfd_copy_link_hash_symbol_type): Define.
	* elfxx-target.h (bfd_elfNN_bfd_copy_link_hash_symbol_type): Define.
	* i386msdos.c (msdos_bfd_copy_link_hash_symbol_type): Define.
	* i386os9k.c (os9k_bfd_copy_link_hash_symbol_type): Define.
	* ieee.c (ieee_bfd_copy_link_hash_symbol_type): Define.
	* ihex.c (ihex_bfd_copy_link_hash_symbol_type): Define.
	* libecoff.h (_bfd_ecoff_bfd_copy_link_hash_symbol_type): Define.
	* mach-o.c (bfd_mach_o_bfd_copy_link_hash_symbol_type): Define.
	* mmo.c (mmo_bfd_copy_link_hash_symbol_type): Define.
	* nlm-target.h (nlm_bfd_copy_link_hash_symbol_type): Define.
	* oasys.c (oasys_bfd_copy_link_hash_symbol_type): Define.
	* pef.c (bfd_pef_bfd_copy_link_hash_symbol_type): Define.
	* ppcboot.c (ppcboot_bfd_copy_link_hash_symbol_type): Define.
	* som.c (som_bfd_copy_link_hash_symbol_type): Define.
	* srec.c (srec_bfd_copy_link_hash_symbol_type): Define.
	* tekhex.c (tekhex_bfd_copy_link_hash_symbol_type): Define.
	* versados.c (versados_bfd_copy_link_hash_symbol_type): Define.
	* vms.c (vms_bfd_copy_link_hash_symbol_type): Define.
	* xsym.c (bfd_sym_bfd_copy_link_hash_symbol_type): Define.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.

	ld/testsuite
	* ld-arm/script-type.sym: New test.
	* ld-arm/script-type.s: New test.
	* ld-arm/script-type.s: New test.
@
text
@d833 8
@


1.80
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        * as.c (main): Call dwarf2_init.
        * config/obj-elf.c (struct group_list): New field.
        (build_group_lists): Use hash lookup.
        (free_section_idx): New function.
        (elf_frob_file): Adjust.
        * dwarf2dbg.c (all_segs_hash, last_seg_ptr): New variables.
        (get_line_subseg): Adjust.
        (dwarf2_init): New function.
        * dwarf2dbg.h (dwarf2_init): New declaration.
@
text
@d818 14
@


1.79
log
@update copyright dates
@
text
@d949 1
a949 1
  n = stat_alloc (sizeof (n->assign));
d966 1
a966 1
  n = stat_alloc (sizeof (n->assert_s));
d1098 1
a1098 1
      fill = xmalloc ((len + 1) / 2 + sizeof (*fill) - 1);
d1123 1
a1123 1
      fill = xmalloc (4 + sizeof (*fill) - 1);
@


1.79.2.1
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.
@
text
@d949 1
a949 1
  n = (etree_type *) stat_alloc (sizeof (n->assign));
d966 1
a966 1
  n = (etree_type *) stat_alloc (sizeof (n->assert_s));
d1098 1
a1098 1
      fill = (fill_type *) xmalloc ((len + 1) / 2 + sizeof (*fill) - 1);
d1123 1
a1123 1
      fill = (fill_type *) xmalloc (4 + sizeof (*fill) - 1);
@


1.78
log
@	PR ld/10569
	* ldexp.c (fold_name <MAXPAGESIZE>): Return config.maxpagesize.
	(fold_name <COMMONPAGESIZE>): Similarly.
	* ldlang.c (output_target): Make global.
	* ldlang.h (output_target): Declare.
	* ldmain.c (main): Set config.maxpagesize from bfd_emul_get_maxpagesize.
	Similarly for config.commonpagesize.
	* ldemul.c (set_output_arch_default): Call bfd_emul_set_maxpagesize
	and bfd_emul_set_commonpagesize.
	* emultempl/elf32.em (gld${EMULATION_NAME}_handle_option): Don't call
	bfd_emul_set_maxpagesize or bfd_emul_set_commonpagesize here.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
@


1.77
log
@        Updated sources to avoid using the identifier name "new", which is a
        keyword in c++.

        * bfd/aoutx.h (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol.
        * bfd/coffgen.c (coff_make_empty_symbol)
        (coff_bfd_make_debug_symbol): Rename variable new to new_symbol.
        * bfd/cpu-ia64-opc.c (ext_reg, ins_imms_scaled): Rename variable
        new to new_insn.
        * bfd/doc/chew.c (newentry, add_intrinsic): Rename variable new to
        new_d.
        * bfd/ecoff.c (_bfd_ecoff_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/elf32-m68k.c (elf_m68k_get_got_entry_type): Rename argument
        new to new_reloc.
        * bfd/hash.c (bfd_hash_lookup): Rename variable new to new_string.
        * bfd/ieee.c (ieee_make_empty_symbol): Rename variable new to
        new_symbol.
        * bfd/linker.c (bfd_new_link_order): Rename variable new to
        new_lo.
        * bfd/mach-o.c (bfd_mach_o_sizeof_headers): Rename variable new to
        symbol.
        * bfd/oasys.c (oasys_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/pdp11.c (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol_type.
        * bfd/plugin.c (bfd_plugin_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/rs6000-core.c (CoreHdr, VmInfo): Rename union member new to
        new_dump.
        (read_hdr, rs6000coff_core_p)
        (rs6000coff_core_file_matches_executable_p)
        (rs6000coff_core_file_failing_command)
        (rs6000coff_core_file_failing_signal): Updated function to use new
        union member name.
        * bfd/som.c (som_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/syms.c (_bfd_generic_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/tekhex.c (first_phase, tekhex_make_empty_symbol): Rename
        variable new to new_symbol.
        * binutils/nlmconv.c (main): Rename variable new to new_name.
        * gas/config/tc-arm.c (insert_reg_alias): Rename variable new to
        new_reg.
        * gas/config/tc-dlx.c (parse_operand): Rename variable new to
        new_pos.
        * gas/config/tc-ia64.c (ia64_gen_real_reloc_type): Rename variable
        new to newr.
        * gas/config/tc-mcore.c (parse_exp, parse_imm): Rename variable
        new to new_pointer.
        * gas/config/tc-microblaze.c (parse_exp, parse_imm, check_got):
        Change name from new to new_pointer.
        * gas/config/tc-or32.c (parse_operand): Rename variable new to
        new_pointer.
        * gas/config/tc-pdp11.c (md_assemble): Rename variable new to
        new_pointer.
        * gas/config/tc-pj.c (alias): Change argument new to new_name.
        * gas/config/tc-score.c (s3_build_score_ops_hsh): Rename variable
        new to new_opcode. (s3_build_dependency_insn_hsh) Rename variable
        new to new_i2n. (s3_convert): Rename variables old and new to
        r_old and r_new.
        * gas/config/tc-score7.c (s7_build_score_ops_hsh): Rename variable
        new to new_opcode. (s7_build_dependency_insn_hsh): Rename variable
        new to new_i2d. (s7_b32_relax_to_b16, s7_convert_frag): Rename
        variables old and new to r_old and r_new.
        * gas/config/tc-sh.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-sh64.c (shmedia_parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-tic4x.c (tic4x_operand_parse): Rename variable new
        to new_pointer.
        * gas/config/tc-z8k.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/listing.c (listing_newline): Rename variable new to new_i.
        * ld/ldexp.c (exp_intop, exp_bigintop, exp_relop, exp_binop)
        (exp_trinop, exp_unop, exp_nameop, exp_assop): Rename variable new
        to new_e.
        * ld/ldfile.c (ldfile_add_library_path): Rename variable new to
        new_dirs. (ldfile_add_arch): Rename variable new to new_arch.
        * ld/ldlang.c (new_statement, lang_final, lang_add_wild)
        (lang_target, lang_add_fill, lang_add_data, lang_add_assignment)
        (lang_add_insert): Rename variable new to new_stmt. (new_afile):
        Added missing cast. (lang_memory_region_lookup): Rename variable
        new to new_region. (init_os): Rename variable new to
        new_userdata. (lang_add_section): Rename variable new to
        new_section. (ldlang_add_undef): Rename variable new to
        new_undef. (realsymbol): Rename variable new to new_name.
        * opcodes/z8kgen.c (internal, gas): Rename variable new to new_op.

        Updated sources to avoid using the identifier name "template",
        which is a keyword in c++.

        * bfd/elf32-arm.c (struct stub_def): Rename member template to
        template_sequence. (arm_build_one_stub,
        find_stub_size_and_template, arm_size_one_stub, arm_map_one_stub):
        Rename variable template to template_sequence.
        * bfd/elfxx-ia64.c (elfNN_ia64_relax_br, elfNN_ia64_relax_brl):
        Rename variable template to template_val.
        * gas/config/tc-arm.c (struct asm_cond, struct asm_psr, struct
        asm_barrier_opt): Change member template to
        template_name. (md_begin): Update code to reflect new member
        names.
        * gas/config/tc-i386.c (struct templates, struct _i386_insn)
        (match_template, cpu_flags_match, match_reg_size, match_mem_size)
        (operand_size_match, md_begin, i386_print_statistics, pi)
        (build_vex_prefix, md_assemble, parse_insn, optimize_imm)
        (optimize_disp): Updated code to use new names. (parse_insn):
        Added casts.
        * gas/config/tc-ia64.c (dot_template, emit_one_bundle): Updated
        code to use new names.
        * gas/config/tc-score.c (struct s3_asm_opcode): Renamed member
        template to template_name. (s3_parse_16_32_inst, s3_parse_48_inst,
        s3_do_macro_ldst_label, s3_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-score7.c (struct s7_asm_opcode): Renamed member
        template to template_name. (s7_parse_16_32_inst,
        s7_do_macro_ldst_label, s7_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-tic30.c (md_begin, struct tic30_insn)
        (md_assemble): Update code to use new names.
        * gas/config/tc-tic54x.c (struct _tic54x_insn, md_begin)
        (optimize_insn, tic54x_parse_insn, next_line_shows_parallel):
        Update code to use new names.
        * include/opcode/tic30.h (template): Rename type template to
        insn_template. Updated code to use new name.
        * include/opcode/tic54x.h (template): Rename type template to
        insn_template.
        * opcodes/cris-dis.c (bytes_to_skip): Update code to use new name.
        * opcodes/i386-dis.c (putop): Update code to use new name.
        * opcodes/i386-gen.c (process_i386_opcodes): Update code to use
        new name.
        * opcodes/i386-opc.h (struct template): Rename struct template to
        insn_template. Update code accordingly.
        * opcodes/i386-tbl.h (i386_optab): Update type to use new name.
        * opcodes/ia64-dis.c (print_insn_ia64): Rename variable template
        to template_val.
        * opcodes/tic30-dis.c (struct instruction, get_tic30_instruction):
        Update code to use new name.
        * opcodes/tic54x-dis.c (has_lkaddr, get_insn_size)
        (print_parallel_instruction, print_insn_tic54x, tic54x_get_insn):
        Update code to use new name.
        * opcodes/tic54x-opc.c (tic54x_unknown_opcode, tic54x_optab):
        Update type to new name.
@
text
@d676 1
a676 1
	new_abs (bfd_emul_get_maxpagesize (default_target));
d678 1
a678 1
	new_abs (bfd_emul_get_commonpagesize (default_target));
@


1.76
log
@	* ldexp.c (fold_binary): Evaluate rhs when lhs not valid.
@
text
@d157 7
a163 7
  etree_type *new = stat_alloc (sizeof (new->value));
  new->type.node_code = INT;
  new->type.lineno = lineno;
  new->value.value = value;
  new->value.str = NULL;
  new->type.node_class = etree_value;
  return new;
d169 7
a175 7
  etree_type *new = stat_alloc (sizeof (new->value));
  new->type.node_code = INT;
  new->type.lineno = lineno;
  new->value.value = value;
  new->value.str = str;
  new->type.node_class = etree_value;
  return new;
d183 7
a189 7
  etree_type *new = stat_alloc (sizeof (new->rel));
  new->type.node_code = REL;
  new->type.lineno = lineno;
  new->type.node_class = etree_rel;
  new->rel.section = section;
  new->rel.value = value;
  return new;
d854 1
a854 1
  etree_type value, *new;
d865 3
a867 3
  new = stat_alloc (sizeof (new->binary));
  memcpy (new, &value, sizeof (new->binary));
  return new;
d873 1
a873 1
  etree_type value, *new;
d885 3
a887 3
  new = stat_alloc (sizeof (new->trinary));
  memcpy (new, &value, sizeof (new->trinary));
  return new;
d893 1
a893 1
  etree_type value, *new;
d903 3
a905 3
  new = stat_alloc (sizeof (new->unary));
  memcpy (new, &value, sizeof (new->unary));
  return new;
d911 1
a911 1
  etree_type value, *new;
d922 3
a924 3
  new = stat_alloc (sizeof (new->name));
  memcpy (new, &value, sizeof (new->name));
  return new;
d931 1
a931 1
  etree_type *new;
d933 7
a939 7
  new = stat_alloc (sizeof (new->assign));
  new->type.node_code = code;
  new->type.lineno = src->type.lineno;
  new->type.node_class = etree_assign;
  new->assign.src = src;
  new->assign.dst = dst;
  return new;
@


1.75
log
@	PR ld/6833
	* ldexp.c (fold_binary <DATA_SEGMENT_ALIGN>): Do not align
	EXPLD.DATASEG.MIN_BASE.
	* ldlang.c (lang_size_sections): New variable OLD_BASE.  Rename
	OLD_MIN_BASE to MIN_BASE with the former alignment from `ldexp.c'.
	Use OLD_BASE now for the minimal base check after the base decrease by
	the maximum alignment found.
@
text
@d285 1
d308 1
a309 3
  else if (expld.result.valid_p)
    {
      etree_value_type lhs = expld.result;
d311 3
a313 40
      exp_fold_tree_1 (tree->binary.rhs);
      if (expld.result.valid_p)
	{
	  /* If the values are from different sections, or this is an
	     absolute expression, make both the source arguments
	     absolute.  However, adding or subtracting an absolute
	     value from a relative value is meaningful, and is an
	     exception.  */
	  if (expld.section != bfd_abs_section_ptr
	      && lhs.section == bfd_abs_section_ptr
	      && tree->type.node_code == '+')
	    {
	      /* Keep the section of the rhs term.  */
	      expld.result.value = lhs.value + expld.result.value;
	      return;
	    }
	  else if (expld.section != bfd_abs_section_ptr
		   && expld.result.section == bfd_abs_section_ptr
		   && (tree->type.node_code == '+'
		       || tree->type.node_code == '-'))
	    {
	      /* Keep the section of the lhs term.  */
	      expld.result.section = lhs.section;
	    }
	  else if (expld.result.section != lhs.section
		   || expld.section == bfd_abs_section_ptr)
	    {
	      make_abs ();
	      lhs.value += lhs.section->vma;
	    }

	  switch (tree->type.node_code)
	    {
	    case '%':
	      if (expld.result.value != 0)
		expld.result.value = ((bfd_signed_vma) lhs.value
				      % (bfd_signed_vma) expld.result.value);
	      else if (expld.phase != lang_mark_phase_enum)
		einfo (_("%F%S %% by zero\n"));
	      break;
d315 47
a361 7
	    case '/':
	      if (expld.result.value != 0)
		expld.result.value = ((bfd_signed_vma) lhs.value
				      / (bfd_signed_vma) expld.result.value);
	      else if (expld.phase != lang_mark_phase_enum)
		einfo (_("%F%S / by zero\n"));
	      break;
d368 47
a414 39
	      BOP ('+', +);
	      BOP ('*', *);
	      BOP ('-', -);
	      BOP (LSHIFT, <<);
	      BOP (RSHIFT, >>);
	      BOP (EQ, ==);
	      BOP (NE, !=);
	      BOP ('<', <);
	      BOP ('>', >);
	      BOP (LE, <=);
	      BOP (GE, >=);
	      BOP ('&', &);
	      BOP ('^', ^);
	      BOP ('|', |);
	      BOP (ANDAND, &&);
	      BOP (OROR, ||);

	    case MAX_K:
	      if (lhs.value > expld.result.value)
		expld.result.value = lhs.value;
	      break;

	    case MIN_K:
	      if (lhs.value < expld.result.value)
		expld.result.value = lhs.value;
	      break;

	    case ALIGN_K:
	      expld.result.value = align_n (lhs.value, expld.result.value);
	      break;

	    case DATA_SEGMENT_ALIGN:
	      expld.dataseg.relro = exp_dataseg_relro_start;
	      if (expld.phase != lang_first_phase_enum
		  && expld.section == bfd_abs_section_ptr
		  && (expld.dataseg.phase == exp_dataseg_none
		      || expld.dataseg.phase == exp_dataseg_adjust
		      || expld.dataseg.phase == exp_dataseg_relro_adjust
		      || expld.phase == lang_final_phase_enum))
d416 2
a417 7
		  bfd_vma maxpage = lhs.value;
		  bfd_vma commonpage = expld.result.value;

		  expld.result.value = align_n (expld.dot, maxpage);
		  if (expld.dataseg.phase == exp_dataseg_relro_adjust)
		    expld.result.value = expld.dataseg.base;
		  else if (expld.dataseg.phase != exp_dataseg_adjust)
d419 6
a424 10
		      expld.result.value += expld.dot & (maxpage - 1);
		      if (expld.phase == lang_allocating_phase_enum)
			{
			  expld.dataseg.phase = exp_dataseg_align_seen;
			  expld.dataseg.min_base = expld.dot;
			  expld.dataseg.base = expld.result.value;
			  expld.dataseg.pagesize = commonpage;
			  expld.dataseg.maxpagesize = maxpage;
			  expld.dataseg.relro_end = 0;
			}
a425 3
		  else if (commonpage < maxpage)
		    expld.result.value += ((expld.dot + commonpage - 1)
					   & (maxpage - commonpage));
d427 7
a433 3
	      else
		expld.result.valid_p = FALSE;
	      break;
d435 15
a449 7
	    case DATA_SEGMENT_RELRO_END:
	      expld.dataseg.relro = exp_dataseg_relro_end;
	      if (expld.phase != lang_first_phase_enum
		  && (expld.dataseg.phase == exp_dataseg_align_seen
		      || expld.dataseg.phase == exp_dataseg_adjust
		      || expld.dataseg.phase == exp_dataseg_relro_adjust
		      || expld.phase == lang_final_phase_enum))
d451 4
a454 18
		  if (expld.dataseg.phase == exp_dataseg_align_seen
		      || expld.dataseg.phase == exp_dataseg_relro_adjust)
		    expld.dataseg.relro_end = lhs.value + expld.result.value;

		  if (expld.dataseg.phase == exp_dataseg_relro_adjust
		      && (expld.dataseg.relro_end
			  & (expld.dataseg.pagesize - 1)))
		    {
		      expld.dataseg.relro_end += expld.dataseg.pagesize - 1;
		      expld.dataseg.relro_end &= ~(expld.dataseg.pagesize - 1);
		      expld.result.value = (expld.dataseg.relro_end
					    - expld.result.value);
		    }
		  else
		    expld.result.value = lhs.value;

		  if (expld.dataseg.phase == exp_dataseg_align_seen)
		    expld.dataseg.phase = exp_dataseg_relro_seen;
d457 1
a457 2
		expld.result.valid_p = FALSE;
	      break;
d459 2
a460 2
	    default:
	      FAIL ();
d462 6
a468 2
      else
	expld.result.valid_p = FALSE;
@


1.75.2.1
log
@backport 2008-09-25  Alan Modra  <amodra@@bigpond.net.au>
@
text
@a284 1
  etree_value_type lhs;
a306 1
      return;
d308 3
d312 40
a351 3
  lhs = expld.result;
  exp_fold_tree_1 (tree->binary.rhs);
  expld.result.valid_p &= lhs.valid_p;
d353 7
a359 47
  if (expld.result.valid_p)
    {
      /* If the values are from different sections, or this is an
	 absolute expression, make both the source arguments
	 absolute.  However, adding or subtracting an absolute
	 value from a relative value is meaningful, and is an
	 exception.  */
      if (expld.section != bfd_abs_section_ptr
	  && lhs.section == bfd_abs_section_ptr
	  && tree->type.node_code == '+')
	{
	  /* Keep the section of the rhs term.  */
	  expld.result.value = lhs.value + expld.result.value;
	  return;
	}
      else if (expld.section != bfd_abs_section_ptr
	       && expld.result.section == bfd_abs_section_ptr
	       && (tree->type.node_code == '+'
		   || tree->type.node_code == '-'))
	{
	  /* Keep the section of the lhs term.  */
	  expld.result.section = lhs.section;
	}
      else if (expld.result.section != lhs.section
	       || expld.section == bfd_abs_section_ptr)
	{
	  make_abs ();
	  lhs.value += lhs.section->vma;
	}

      switch (tree->type.node_code)
	{
	case '%':
	  if (expld.result.value != 0)
	    expld.result.value = ((bfd_signed_vma) lhs.value
				  % (bfd_signed_vma) expld.result.value);
	  else if (expld.phase != lang_mark_phase_enum)
	    einfo (_("%F%S %% by zero\n"));
	  break;

	case '/':
	  if (expld.result.value != 0)
	    expld.result.value = ((bfd_signed_vma) lhs.value
				  / (bfd_signed_vma) expld.result.value);
	  else if (expld.phase != lang_mark_phase_enum)
	    einfo (_("%F%S / by zero\n"));
	  break;
d366 39
a404 47
	  BOP ('+', +);
	  BOP ('*', *);
	  BOP ('-', -);
	  BOP (LSHIFT, <<);
	  BOP (RSHIFT, >>);
	  BOP (EQ, ==);
	  BOP (NE, !=);
	  BOP ('<', <);
	  BOP ('>', >);
	  BOP (LE, <=);
	  BOP (GE, >=);
	  BOP ('&', &);
	  BOP ('^', ^);
	  BOP ('|', |);
	  BOP (ANDAND, &&);
	  BOP (OROR, ||);

	case MAX_K:
	  if (lhs.value > expld.result.value)
	    expld.result.value = lhs.value;
	  break;

	case MIN_K:
	  if (lhs.value < expld.result.value)
	    expld.result.value = lhs.value;
	  break;

	case ALIGN_K:
	  expld.result.value = align_n (lhs.value, expld.result.value);
	  break;

	case DATA_SEGMENT_ALIGN:
	  expld.dataseg.relro = exp_dataseg_relro_start;
	  if (expld.phase != lang_first_phase_enum
	      && expld.section == bfd_abs_section_ptr
	      && (expld.dataseg.phase == exp_dataseg_none
		  || expld.dataseg.phase == exp_dataseg_adjust
		  || expld.dataseg.phase == exp_dataseg_relro_adjust
		  || expld.phase == lang_final_phase_enum))
	    {
	      bfd_vma maxpage = lhs.value;
	      bfd_vma commonpage = expld.result.value;

	      expld.result.value = align_n (expld.dot, maxpage);
	      if (expld.dataseg.phase == exp_dataseg_relro_adjust)
		expld.result.value = expld.dataseg.base;
	      else if (expld.dataseg.phase != exp_dataseg_adjust)
d406 7
a412 2
		  expld.result.value += expld.dot & (maxpage - 1);
		  if (expld.phase == lang_allocating_phase_enum)
d414 10
a423 6
		      expld.dataseg.phase = exp_dataseg_align_seen;
		      expld.dataseg.min_base = expld.dot;
		      expld.dataseg.base = expld.result.value;
		      expld.dataseg.pagesize = commonpage;
		      expld.dataseg.maxpagesize = maxpage;
		      expld.dataseg.relro_end = 0;
d425 3
d429 3
a431 7
	      else if (commonpage < maxpage)
		expld.result.value += ((expld.dot + commonpage - 1)
				       & (maxpage - commonpage));
	    }
	  else
	    expld.result.valid_p = FALSE;
	  break;
d433 7
a439 15
	case DATA_SEGMENT_RELRO_END:
	  expld.dataseg.relro = exp_dataseg_relro_end;
	  if (expld.phase != lang_first_phase_enum
	      && (expld.dataseg.phase == exp_dataseg_align_seen
		  || expld.dataseg.phase == exp_dataseg_adjust
		  || expld.dataseg.phase == exp_dataseg_relro_adjust
		  || expld.phase == lang_final_phase_enum))
	    {
	      if (expld.dataseg.phase == exp_dataseg_align_seen
		  || expld.dataseg.phase == exp_dataseg_relro_adjust)
		expld.dataseg.relro_end = lhs.value + expld.result.value;

	      if (expld.dataseg.phase == exp_dataseg_relro_adjust
		  && (expld.dataseg.relro_end
		      & (expld.dataseg.pagesize - 1)))
d441 18
a458 4
		  expld.dataseg.relro_end += expld.dataseg.pagesize - 1;
		  expld.dataseg.relro_end &= ~(expld.dataseg.pagesize - 1);
		  expld.result.value = (expld.dataseg.relro_end
					- expld.result.value);
d461 2
a462 1
		expld.result.value = lhs.value;
d464 2
a465 2
	      if (expld.dataseg.phase == exp_dataseg_align_seen)
		expld.dataseg.phase = exp_dataseg_relro_seen;
a466 6
	  else
	    expld.result.valid_p = FALSE;
	  break;

	default:
	  FAIL ();
d468 2
@


1.74
log
@	* ldexp.c (exp_print_token): Add ABSOLUTE, MIN_K, ASSERT_K.  Correct
	MAX_K.
	(fold_binary <SEGMENT_START>): Set expld.result.section to
	current section.  Expand comment.  Formatting.
	(fold_name <DEFINED>): Set expld.result.section to current section.
@
text
@d418 1
a418 1
			  expld.dataseg.min_base = align_n (expld.dot, maxpage);
@


1.73
log
@	PR ld/5761
	* ldexp.c (fold_name <LOADADDR>): Check result of evaluating
	load_base before calling make_abs.
@
text
@d106 4
a109 1
    { MAX_K, "MAX_K" },
d288 3
a290 1
     operand is a string, not the name of a symbol.  */
d304 1
a304 1
	    expld.result.section = NULL;
d329 3
a331 3
	      && expld.result.section == bfd_abs_section_ptr
	      && (tree->type.node_code == '+'
		  || tree->type.node_code == '-'))
d521 1
a521 1
	  expld.result.section = bfd_abs_section_ptr;
@


1.72
log
@include/
	* bfdlink.h (struct bfd_link_hash_table): Delete creator field.
	(struct bfd_link_info): Add output_bfd.
bfd/
	* elflink.c: Replace all accesses to hash->creator field with
	output_bfd->xvec.
	* cofflink.c: Likewise.
	* coff-h8300.c: Likewise.
	* ecoff.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfxx-mips.c: Likewise.
	* i386linux.c: Likewise.
	* m68klinux.c: Likewise.
	* sparclinux.c: Likewise.
	* sunos.c: Likewise.
	* xcofflink.c: Likewise.
	* linker.c: Likewise.
	(_bfd_link_hash_table_init): Don't store creator.
ld/
	* ldmain.h (output_bfd): Delete.
	* ldmain.c (output_bfd): Delete.
	Replace all occurrences of output_bfd with link_info.output_bfd.
	* ldcref.c: Likewise.
	* ldctor.c: Likewise.
	* ldemul.c: Likewise.
	* ldexp.c: Likewise.
	* ldfile.c: Likewise.
	* ldlang.c: Likewise.
	* ldmisc.c: Likewise.
	* ldwrite.c: Likewise.
	* pe-dll.c: Likewise.
	* emultempl/aix.em: Likewise.
	* emultempl/alphaelf.em: Likewise.
	* emultempl/armcoff.em: Likewise.
	* emultempl/armelf.em: Likewise.
	* emultempl/avrelf.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/elf-generic.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/irix.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68hc1xelf.em: Likewise.
	* emultempl/mmix-elfnmmo.em: Likewise.
	* emultempl/mmo.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/scoreelf.em: Likewise.
	* emultempl/sh64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/vanilla.em: Likewise.
	* emultempl/vxworks.em: Likewise.
	* emultempl/xtensaelf.em: Likewise.
	* emultempl/z80.em: Likewise.
	* ldlang.c (open_output): Don't return output, instead write
	link_info_output_bfd directly.
	* emultempl/alphaelf.em: Replace occurrences of link_info.hash->creator
	with link_info.output_bfd->xvec.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
@
text
@d608 2
a609 1
		  make_abs ();
@


1.71
log
@bfd/

2007-09-17  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/3281
	PR binutils/5037
	* elf-bfd.h (elf_obj_tdata): Remove relro.

	* elf.c (get_program_header_size): Check info->relro instead
	of elf_tdata (abfd)->relro.
	(_bfd_elf_map_sections_to_segments): Likewise.
	(assign_file_positions_for_load_sections): Don't set
	PT_GNU_RELRO segment alignment here.
	(assign_file_positions_for_non_load_sections): Properly set up
	PT_GNU_RELRO segment for copying executable/shared library.
	(rewrite_elf_program_header): Remove PT_GNU_RELRO segment.
	(copy_elf_program_header): Set p_size and p_size_valid fields for
	PT_GNU_RELRO segment.

include/elf/

2007-09-17  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/3281
	PR binutils/5037
	* internal.h (elf_segment_map): Add p_size and p_size_valid.
	(ELF_IS_SECTION_IN_SEGMENT): Allow SHF_TLS sections in
	PT_GNU_RELRO segments.

ld/

2007-09-17  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/3281
	PR binutils/5037
	* ldexp.h (ldexp_control): Add relro, relro_start_stat and
	relro_end_stat.

	* ldexp.c (fold_binary): Set expld.dataseg.relro to
	exp_dataseg_relro_start or exp_dataseg_relro_end when
	seeing DATA_SEGMENT_ALIGN or DATA_SEGMENT_RELRO_END,
	respectively.

	* ldlang.c (lang_size_sections_1): Properly set
	expld.dataseg.relro_start_stat and
	expld.dataseg.relro_end_stat.
	(find_relro_section_callback): New function.
	(lang_find_relro_sections_1): Likewise.
	(lang_find_relro_sections): Likewise.
	(lang_process): Call lang_find_relro_sections for
	non-relocatable link.

ld/testsuite/

2007-09-17  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/3281
	PR binutils/5037
	* ld-elf/binutils.exp: Update "-z relro" tests to use relro1.s.
	Add "-z relro" tests with relro2.s.  Add "-z relro" tests with
	TLS for objcopy.

	* ld-elf/relro1.s: New file.
	* ld-elf/relro2.s: Likewise.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007
d492 1
a492 1
	    hdr_size = bfd_sizeof_headers (output_bfd, &link_info);
d506 2
a507 1
	  h = bfd_wrapped_link_hash_lookup (output_bfd, &link_info,
d530 2
a531 1
	  h = bfd_wrapped_link_hash_lookup (output_bfd, &link_info,
d633 2
a634 1
		val = os->bfd_section->size / bfd_octets_per_byte (output_bfd);
@


1.70
log
@	* ldexp.c (exp_get_vma, exp_get_fill): Canonicalise error messages.
	* lexsup.c (ld_options): Don't use tabs in help text.
	* emultempl/armcoff.em (gld${EMULATION_NAME}_finish): Fix typo.
	* emultempl/pe.em (gld${EMULATION_NAME}_finish): Fix typo.
@
text
@d393 1
d429 1
@


1.69
log
@Update sources to GPLv3
@
text
@d1055 1
a1055 1
	einfo (_("%F%S nonconstant expression for %s\n"), name);
d1080 1
a1080 1
	einfo (_("%F%S nonconstant expression for %s\n"), name);
@


1.68
log
@	* ldlex.l, ldgram.y: Add ALIGNOF.
	* ldexp.c (exp_print_token, foldname): Likewise.
	* ld.texinfo: Likewise.

	ld/testsuite/
	* ld-scripts/alignof.s: New.
	* ld-scripts/alignof.t: New
	* ld-scripts/alignof.exp: New.
@
text
@d7 1
a7 1
   This file is part of GLD, the Gnu Linker.
d9 1
a9 1
   GLD is free software; you can redistribute it and/or modify
d11 2
a12 2
   the Free Software Foundation; either version 2, or (at your option)
   any later version.
d14 1
a14 1
   GLD is distributed in the hope that it will be useful,
d20 4
a23 3
   along with GLD; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */
@


1.67
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d100 1
d610 1
a612 1
	  int opb = bfd_octets_per_byte (output_bfd);
d624 10
a633 1
	    new_abs (os->bfd_section->size / opb);
@


1.66
log
@ld/

2007-04-02  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/4090
	* ldexp.h (node_type): Add lineno.
	* ldexp.c: Include "ldlex.h".
	(exp_intop): Set the lineno field from lineno.
	(exp_bigintop): Likewise.
	(exp_relop): Likewise.
	(exp_nameop): Likewise.
	(exp_binop): Set the lineno field from lineno of lhs.
	(exp_trinop): Likewise.
	(exp_unop): Set the lineno field from lineno of child.
	(exp_assop): Set the lineno field from lineno of src.
	(exp_provide): Likewise.
	(exp_assert): Set the lineno field from lineno of exp.
	(exp_get_abs_int): Set lineno from lineno of nonconstant
	expression when report problem.

ld/testsuite/

2007-04-02  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/4090
	* ld-elf/expr1.d: New file.
	* ld-elf/expr1.s: Likewise.
	* ld-elf/expr1.t: Likewise.
@
text
@d31 1
a32 1
#include "sysdep.h"
@


1.65
log
@	* ldexp.c (fold_name <LOADADDR>): Ensure result is always absolute.
@
text
@d39 1
d154 1
d166 1
d180 1
d836 1
d855 1
d875 1
d893 1
d914 1
d930 1
d947 1
d1126 4
a1129 1
	einfo (_("%F%S nonconstant expression for %s\n"), name);
@


1.64
log
@ld/
	* ldexp.c (fold_name): Issue error on undefined sections.
ld/testsuite/
	* ld-scripts/expr.exp: New.
	* ld-scripts/expr1.s: New.
	* ld-scripts/expr1.d: New.
	* ld-scripts/expr1.t: New.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006
d488 1
d511 1
d596 4
a599 1
		exp_fold_tree_1 (os->load_base);
@


1.63
log
@	* ldexp.c (fold_name <LOADADDR>): Return an absolute value
        rather than a section relative value.
@
text
@d566 7
a572 1
	  if (os != NULL && os->processed_vma)
d583 7
a589 1
	  if (os != NULL && os->processed_lma)
d607 6
a612 1
	    new_abs (0);
@


1.62
log
@ld/
	PR 3052
	* ldlang.h (lang_output_section_statement_type): Replace
	"processed" field with "processed_vma" and "processed_lma".
	* ldlang.c (lang_do_assignments_1): Move lma setting code..
	(lang_size_sections_1): ..to here.
	(lang_reset_memory_regions): Adjust for
	lang_output_section_statement_type change.
	* ldexp.c (fold_name): Likewise.

And this is something I forgot the check in from the previous patch.
ld/testsuite/
	* ld-scripts/overlay-size-map.d: Adjust.
@
text
@d580 1
a580 2
		new_rel (os->bfd_section->lma - os->bfd_section->vma,
			 NULL, os->bfd_section);
@


1.61
log
@	* ldexp.c (fold_name <LOADADDR>): Use the lma.
	* ldlang.h (lang_memory_region_type): Delete old_length.  Add
	last_os.
	* ldlang.c (lang_memory_region_lookup): Init new field.
	(lang_reset_memory_regions): Reset new field.
	(lang_insert_orphan): Don't set load_base.
	(lang_leave_overlay): Likewise.
	(lang_size_sections_1): Delete unnecessary code setting lma_region
	to region.  Correct lma region check.
	(lang_do_assignments_1): Rename output_section_statement parm
	to current_os.  Set lma from previous section in region.
@
text
@d566 1
a566 1
	  if (os != NULL && os->processed)
d577 1
a577 1
	  if (os != NULL && os->processed)
d597 1
a597 1
	  else if (os->processed)
@


1.60
log
@bfd/
	* elf-bfd.h (struct elf_backend_data): Add bfd_link_info pointer
	parameter.
	(_bfd_elf_sizeof_headers): Replace bfd_boolean param with
	bfd_link_info pointer.
	* targets.c (struct bfd_target <_bfd_sizeof_headers>): Likewise.
	* bfd.c (bfd_sizeof_headers): Tweak param name.
	* aout-adobe.c (aout_adobe_sizeof_headers): Adjust.
	* aoutx.h (NAME (aout, sizeof_headers)): Adjust.
	* binary.c (binary_sizeof_headers): Adjust.
	* bout.c (b_out_sizeof_headers): Adjust.
	* coff-rs6000.c (_bfd_xcoff_sizeof_headers): Adjust.
	* coff64-rs6000.c (xcoff64_sizeof_headers): Adjust.
	* coffgen.c (coff_sizeof_headers): Adjust.
	* ecoff.c (_bfd_ecoff_sizeof_headers): Adjust.
	(ecoff_compute_section_file_positions): Adjust.
	(_bfd_ecoff_write_object_contents): Adjust.
	* elf.c (get_program_header_size, _bfd_elf_sizeof_headers): Adjust.
	* elf32-arm.c (elf32_arm_additional_program_headers): Adjust.
	* elf32-i370.c (elf_backend_additional_program_headers): Adjust.
	* elf32-ppc.c (ppc_elf_additional_program_headers): Adjust.
	* elf64-hppa.c (elf64_hppa_additional_program_headers): Adjust.
	* elf64-x86-64.c (elf64_x86_64_additional_program_headers): Adjust.
	* elfxx-ia64.c (elfNN_ia64_additional_program_headers): Adjust.
	* elfxx-mips.c (_bfd_mips_elf_additional_program_headers): Adjust.
	* elfxx-mips.h (_bfd_mips_elf_additional_program_headers): Adjust.
	* i386msdos.c: Convert to ISO C.
	(msdos_sizeof_headers): Adjust.
	* i386os9k.c: Convert to ISO C.
	(os9k_sizeof_headers): Adjust.
	* ieee.c (ieee_sizeof_headers): Adjust.
	* ihex.c (ihex_sizeof_headers): Adjust.
	* libaout.h (NAME (aout, sizeof_headers)): Adjust.
	* libbfd-in.h (_bfd_nolink_sizeof_headers): Adjust.
	* libcoff-in.h (coff_sizeof_headers): Adjust.
	* libecoff.h (_bfd_ecoff_sizeof_headers): Adjust.
	* mach-o.c (bfd_mach_o_sizeof_headers): Adjust.
	* mmo.c (mmo_sizeof_headers): Adjust.
	* oasys.c (oasys_sizeof_headers): Adjust.
	* pdp11.c (NAME (aout, sizeof_headers)): Adjust.
	* pef.c (bfd_pef_sizeof_headers): Adjust.
	* ppcboot.c (ppcboot_sizeof_headers): Adjust.
	* som.c (som_sizeof_headers): Adjust.
	* srec.c (srec_sizeof_headers): Adjust.
	* tekhex.c (tekhex_sizeof_headers): Adjust.
	* versados.c (versados_sizeof_headers): Adjust.
	* vms.c (vms_sizeof_headers): Adjust.
	* xcoff-target.h (_bfd_xcoff_sizeof_headers): Adjust.
	* xsym.c (bfd_sym_sizeof_headers): Adjust.
	* xsym.h (bfd_sym_sizeof_headers): Adjust.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
ld/
	* ldexp.c (fold_name): Adjust bfd_sizeof_headers call.
@
text
@d580 2
a581 1
		new_rel (0, NULL, os->bfd_section);
@


1.59
log
@	* ldexp.c (exp_get_abs_int): Make error message the same as
	others emitted in this file.
@
text
@d484 1
a484 1
	    hdr_size = bfd_sizeof_headers (output_bfd, link_info.relocatable);
@


1.58
log
@bfd/

2006-05-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfd.c (bfd_emul_get_maxpagesize): New.
	(bfd_elf_set_pagesize): Likewise.
	(bfd_emul_set_maxpagesize): Likewise.
	(bfd_emul_get_commonpagesize): Likewise.
	(bfd_emul_set_commonpagesize): Likewise.
	* bfd-in2.h: Regenerated.

	* elf-bfd.h (elf_backend_data): Add commonpagesize.
	(xvec_get_elf_backend_data): New.
	(get_elf_backend_data): Use xvec_get_elf_backend_data.

	* elf32-arm.c (elf32_arm_vxworks_bed): Remove const.
	* elfxx-target.h (elfNN_bed): Likewise.

	* elf32-arm.c (ELF_COMMONPAGESIZE): Defined.
	* elf32-mips.c (ELF_COMMONPAGESIZE): Likewise.
	* elf32-ppc.c (ELF_COMMONPAGESIZE): Likewise.
	* elf32-sh.c (ELF_COMMONPAGESIZE): Likewise.
	* elf32-sh64.c (ELF_COMMONPAGESIZE): Likewise.
	* elf32-sparc.c (ELF_COMMONPAGESIZE): Likewise.
	* elf64-alpha.c (ELF_COMMONPAGESIZE): Likewise.
	* elf64-ppc.c (ELF_COMMONPAGESIZE): Likewise.
	* elf64-sparc.c (ELF_COMMONPAGESIZE): Likewise.
	* elf64-x86-64.c (ELF_COMMONPAGESIZE): Likewise.
	* elfn32-mips.c (ELF_COMMONPAGESIZE): Likewise.
	* elfxx-ia64.c (ELF_COMMONPAGESIZE): Likewise.

	* elfxx-target.h (ELF_COMMONPAGESIZE): Define if not defined.
	(elfNN_bed): Initialize commonpagesize with ELF_COMMONPAGESIZE.

	* targets.c (bfd_find_target): Support NULL abfd.

ld/

2006-05-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* emulparams/arcelf.sh (MAXPAGESIZE): Changed to
	"CONSTANT (MAXPAGESIZE)".
	* emulparams/armelf_nbsd.sh: Likewise.
	* emulparams/armelf_vxworks.sh: Likewise.
	* emulparams/armnto.sh: Likewise.
	* emulparams/armsymbian.sh: Likewise.
	* emulparams/crislinux.sh: Likewise.
	* emulparams/elf32_i860.sh: Likewise.
	* emulparams/elf32_i960.sh: Likewise.
	* emulparams/elf32am33lin.sh: Likewise.
	* emulparams/elf32bfinfd.sh: Likewise.
	* emulparams/elf32bmipn32-defs.sh: Likewise.
	* emulparams/elf32frvfd.sh: Likewise.
	* emulparams/elf32i370.sh: Likewise.
	* emulparams/elf32lppcnto.sh: Likewise.
	* emulparams/elf32mcore.sh: Likewise.
	* emulparams/elf32openrisc.sh: Likewise.
	* emulparams/elf32ppcnto.sh: Likewise.
	* emulparams/elf32ppcwindiss.sh: Likewise.
	* emulparams/elf32vax.sh: Likewise.
	* emulparams/elf32xc16x.sh: Likewise.
	* emulparams/elf32xc16xl.sh: Likewise.
	* emulparams/elf32xc16xs.sh: Likewise.
	* emulparams/elf64_aix.sh: Likewise.
	* emulparams/elf64hppa.sh: Likewise.
	* emulparams/elf64mmix.sh: Likewise.
	* emulparams/elf_i386_be.sh: Likewise.
	* emulparams/elf_i386_chaos.sh: Likewise.
	* emulparams/elf_i386_ldso.sh: Likewise.
	* emulparams/hppa64linux.sh: Likewise.
	* emulparams/hppalinux.sh: Likewise.
	* emulparams/hppaobsd.sh: Likewise.
	* emulparams/i386lynx.sh: Likewise.
	* emulparams/i386moss.sh: Likewise.
	* emulparams/i386nto.sh: Likewise.
	* emulparams/i386nw.sh: Likewise.
	* emulparams/m32relf_linux.sh: Likewise.
	* emulparams/m68kpsos.sh: Likewise.
	* emulparams/or32elf.sh: Likewise.
	* emulparams/pjelf.sh: Likewise.
	* emulparams/pjlelf.sh: Likewise.
	* emulparams/ppclynx.sh: Likewise.
	* emulparams/ppcnw.sh: Likewise.
	* emulparams/shelf32_nbsd.sh : Likewise.
	* emulparams/shelf_nbsd.sh: Likewise.
	* emulparams/shelf_nto.sh: Likewise.
	* emulparams/shlelf_nto.sh: Likewise.
	* emulparams/xtensa-config.sh: Likewise.

	* emulparams/armelf_linux.sh (MAXPAGESIZE): Changed to
	"CONSTANT (MAXPAGESIZE)".
	(COMMONPAGESIZE): Changed to "CONSTANT (COMMONPAGESIZE)".
	* emulparams/elf32_sparc.sh: Likewise.
	* emulparams/elf32bmip.sh: Likewise.
	* emulparams/elf32ppccommon.sh: Likewise.
	* emulparams/elf64_ia64.sh: Likewise.
	* emulparams/elf64_s390.sh: Likewise.
	* emulparams/elf64_sparc.sh: Likewise.
	* emulparams/elf64alpha.sh: Likewise.
	* emulparams/elf64ppc.sh: Likewise.
	* emulparams/elf_i386.sh: Likewise.
	* emulparams/elf_i386_vxworks.sh: Likewise.
	* emulparams/elf_s390.sh: Likewise.
	* emulparams/elf_x86_64.sh: Likewise.
	* emulparams/shlelf32_linux.sh: Likewise.
	* emulparams/shlelf_linux.sh: Likewise.

	* emulparams/elf32bmipn32.sh (COMMONPAGESIZE): Changed to
	"CONSTANT (COMMONPAGESIZE)".
	* emulparams/elf32btsmipn32.sh: Likewise.

	* emultempl/elf32.em (gld${EMULATION_NAME}_handle_option): Add
	"-z max-page-size=" and "-z common-page-size=".
	(gld${EMULATION_NAME}_list_options): Likewise.

	* ld.h (ld_config_type): Add maxpagesize and commonpagesize.

	* ld.texinfo: Document "-z max-page-size=" and
	"-z common-page-size=".

	* ldexp.c (exp_print_token): Handle CONSTANT.
	(fold_name): Likewise.
	* ldgram.y: Likewise.
	* ldlex.l: Likewise.

	* ldmain.c (main): Initiliaze config.maxpagesize and
	config.commonpagesize. Call bfd_emul_set_maxpagesize if
	config.maxpagesize isn't 0. Call bfd_emul_set_commonpagesize if
	config.commonpagesize config.maxpagesize isn't 0.
ld/testsuite/

2006-05-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-elf/binutils.exp: New file.
	* ld-elf/commonpage1.d: Likewise.
	* ld-elf/maxpage1.d: Likewise.
	* ld-elf/maxpage1.s: Likewise.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005
d1093 1
a1093 1
	einfo (_("%F%S non constant expression for %s\n"), name);
@


1.57
log
@bfd/

2005-12-07  Thiemo Seufer  <ths@@networkno.de>
	    H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/1932
	* bfd-in.h (bfd_elf_record_link_assignment): Add output_bfd
	and hidden arguments.

	* bfd.c (bfd_hide_symbol): Removed.

	* bfd-in2.h: Regenerated.

	* elflink.c (bfd_elf_record_link_assignment): Handle hidden
	symbols which were provided by a linker script.

ld/

2005-12-07  Thiemo Seufer  <ths@@networkno.de>
	    H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/1932
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_exp_assignment):
	Adjust bfd_elf_record_link_assignment call.

	* ldexp.c (exp_fold_tree_1): Remove call to bfd_hide_symbol.
@
text
@d102 1
d627 10
@


1.57.2.1
log
@	ld/
	* ldexp.c (fold_name): Loadaddrs of sections with an lma_region
	are absolute.

	ld/testsuite/
	* ld-elf/loadaddr3.t: New.
	* ld-elf/loadaddr3a.d: New.
	* ld-elf/loadaddr3b.d: New.
@
text
@d581 1
a581 8
		{
		  exp_fold_tree_1 (os->load_base);
		  /* If this section has a load region, the expression
		     will be absolute.  */
		  if (os->lma_region && expld.result.valid_p)
		    expld.result.section = bfd_abs_section_ptr;
		}
	      
@


1.56
log
@	* ldlang.h (lang_output_section_statement_struct): Change type of
	"processed" to bfd_boolean.
	* ldexp.c (fold_name): Update references to os->processed.
	* ldlang.c (lang_output_section_statement_lookup_1): Likewise.
	(lang_size_sections_1): Likewise.
	(lang_reset_memory_regions): Likewise.
@
text
@a737 2
	      if (tree->assign.hidden)
		bfd_hide_symbol (output_bfd, &link_info, h, TRUE);
@


1.55
log
@	* ldexp.c (fold_name <SIZEOF>): Return 0 for non-existent section.
	(exp_fold_tree_1): Print assert message only in final stage of
	linking.  Trigger assertion failure if expression cannot be
	evaluated.
@
text
@d565 1
a565 1
	  if (os != NULL && os->processed > 0)
d576 1
a576 1
	  if (os != NULL && os->processed > 0)
d595 1
a595 1
	  else if (os->processed > 0)
@


1.54
log
@bfd/

2005-08-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfd.c (bfd_hide_symbol): New.
	* bfd-in2.h: Regenerated.

ld/

2005-08-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld.texinfo: Document PROVIDE_HIDDEN.

	* ldexp.c (exp_fold_tree_1): Hide a provided symbol if asked.
	(exp_provide): Add and set hidden.

	* ldexp.h (etree_type): Add hidden to assign.

	* ldgram.y (PROVIDE_HIDDEN): New.
	* ldlex.l (PROVIDE_HIDDEN): Likewise.

	* scripttempl/elf.sc: Use PROVIDE_HIDDEN on array bound
	symbols.
@
text
@d593 3
a595 1
	  if (os != NULL && os->processed > 0)
d660 2
a661 9
      if (expld.result.valid_p)
	{
	  if (expld.phase == lang_mark_phase_enum)
	    /* We don't care if assert fails or not when we are just
	       marking if a section is used or not.  */
	    expld.result.value = 1;
	  else if (!expld.result.value)
	    einfo ("%X%P: %s\n", tree->assert_s.message);
	}
@


1.53
log
@	* ldexp.c (fold_unary <ALIGN_K>): Revert last change.
@
text
@d743 2
d889 1
a889 1
exp_provide (const char *dst, etree_type *src)
d898 1
@


1.52
log
@	* ld.h (lang_phase_type): Move to..
	* ldexp.h: ..here.  Add lang_mark_phase_enum.
	(node_type): Remove etree_undef and etree_unspec.
	(exp_data_seg): Delete.
	(struct ldexp_control, expld): New.
	(invalid, exp_mark_used_section): Delete.
	(exp_fold_tree, exp_get_vma, exp_get_value_int, exp_get_fill,
	exp_get_abs_int): Update prototypes.
	* ldexp.c (assigning_to_dot): Delete.
	(expld): Define.
	(make_abs): Operate directly on expld.result.  Update all callers.
	(new_abs): Likewise.  Return void.
	(new_rel_from_abs): Rename from new_rel_from_section.
	(new_rel, new_rel_from_abs): Operate on expld.result and return void.
	Update all callers.
	(fold_unary): Operate on expld.result and return void.  Remove
	"current_section", "allocation_done", "dot", "dotp" and "mark_used"
	params.  Update all callers.
	(fold_binary, fold_trinary, fold_name, exp_fold_tree_1): Likewise.
	(fold_unary <ALIGN_K>): Ensure alignment is absolute.
	(fold_unary <ABSOLUTE>): Use make_abs.
	(fold_unary <DATA_SEGMENT_END>): Evaluate mark_phase as for
	allocating_phase.
	(fold_binary <DATA_SEGMENT_ALIGN, DATA_SEGMENT_RELRO_END, >): Ditto.
	(fold_binary <'%','/'>): Don't error if marking.
	(fold_name <SIZEOF_HEADERS>): Don't call bfd_sizeof_headers when
	marking.
	(fold_name <NAME>): Remove FIXME; -R is handled correctly.  Don't
	error when marking.
	(fold_name <ADDR, LOADADDR, SIZEOF>): Don't set SEC_KEEP.
	(exp_fold_tree_1): Don't error when marking.
	(exp_fold_tree_1 <etree_rel>): Evaluate in all phases except first.
	(exp_fold_tree_1 <etree_assign to dot>): Don't check for NULL
	current section, instead check for NULL dotp.
	(exp_fold_tree_1 <etree_provide>): Don't evaluate the assignment
	source unless the symbol is referenced and undefined.
	(exp_fold_tree): Remove "allocation_done" and "dot" params.  Save
	params to expld.
	(exp_fold_tree_no_dot): Remove "current_section", "allocation_done
	and "mark_used" params.  Save params to expld.  Update all callers.
	(exp_assop): Do without temp var.
	(exp_print_tree <etree_undef>): Delete code.
	(exp_get_vma): Remove "allocation_done" param.  Correct error return.
	(exp_get_fill, exp_get_abs_int): Likewise.
	(exp_get_value_int): Remove "allocation_done" param.
	(exp_mark_used_section): Delete.
	* ldgram.y (fill_exp): Update exp_get_fill call.
	(origin_spec, length_spec): Update exp_get_vma call.
	* ldlang.c (lang_init): Don't bother clearing lang_statement_iteration.
	(lang_mark_used_section_1, lang_mark_used_section): Delete.
	(strip_excluded_output_sections): Call one_lang_size_sections_pass in
	marking mode.  Merge old lang_mark_used_section code.  Correct handling
	of output sections with excluded input sections and data statements.
	Don't drop non-zero sized sections.  Don't zap os->bfd_section.
	Do set SEC_EXCLUDE when appropriate.
	(print_output_section_statement): Update for changed ldexp.c
	interface.
	(print_assignment, lang_size_sections_1): Likewise.
	(lang_do_assignments_1, lang_enter_output_section_statement): Likewise.
	(lang_new_phdr, lang_record_phdrs): Likewise.
	(lang_size_sections): Likewise.
	(insert_pad): Use following statement if it is a pad, rather than
	creating a new one.
	(lang_size_sections_1 <lang_output_section_statement_enum>): Do
	process ignored output section to set vma and lma, but don't
	update dot for these sections.  Don't error if marking.
	(lang_size_sections_1 <lang_assignment_statement_enum>): Don't
	update dot for ignored sections.
	(lang_size_sections_1 <lang_data_statement_enum>): Don't mark absolute
	section with SEC_ALLOC.
	(one_lang_size_sections_pass): New function.
	(lang_size_sections): Remove first five params.  Set expld.phase on
	entry and exit.   Use one_lang_size_sections_pass.
	(lang_do_assignments): Remove all params.  Update all callers.
	(lang_reset_memory_regions): Clear os->processed for all output
	section statements.
	* ldlang.h (lang_do_assignments): Update prototype.
	(lang_size_sections): Likewise.
	(one_lang_size_sections_pass): Declare.
	* pe-dll.c (pe_dll_fill_sections, pe_exe_fill_sections): Update
	lang_size_sections and lang_do_assignments calls.
	* emultempl/elf32.em (layout_sections_again): Likewise.
	* emultempl/ppc64elf.em (ppc_before_allocation): Use
	one_lang_size_sections_pass.
@
text
@d210 1
a210 4
	    {
	      make_abs ();
	      new_rel_from_abs (align_n (expld.dot, expld.result.value));
	    }
@


1.51
log
@ld/

2005-06-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldexp.c (exp_mark_used_section): Set SEC_KEEP on current
	section only if the symbol will be defined.

ld/testsuite/

2005-06-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-cris/hiddef1.d: Undo the last change.
	* ld-cris/libdso-10.d: Likewise.
	* ld-cris/libdso-2.d: Likewise.
@
text
@d44 3
a46 8
static etree_value_type exp_fold_tree_1
  (etree_type *, asection *, lang_phase_type, bfd_vma, bfd_vma *, bfd_boolean);
static etree_value_type exp_fold_tree_no_dot
  (etree_type *, asection *, lang_phase_type, bfd_boolean);
static bfd_vma align_n
  (bfd_vma, bfd_vma);

struct exp_data_seg exp_data_seg;
d50 1
a50 2
/* Principally used for diagnostics.  */
static bfd_boolean assigning_to_dot = FALSE;
d132 1
a132 1
make_abs (etree_value_type *ptr)
d134 2
a135 2
  ptr->value += ptr->section->vma;
  ptr->section = bfd_abs_section_ptr;
d138 1
a138 1
static etree_value_type
d141 4
a144 6
  etree_value_type new;
  new.valid_p = TRUE;
  new.section = bfd_abs_section_ptr;
  new.value = value;
  new.str = NULL;
  return new;
d182 7
a188 11
static etree_value_type
new_rel (bfd_vma value,
	 char *str,
	 asection *section)
{
  etree_value_type new;
  new.valid_p = TRUE;
  new.value = value;
  new.str = str;
  new.section = section;
  return new;
d191 2
a192 2
static etree_value_type
new_rel_from_section (bfd_vma value, asection *section)
d194 4
a197 9
  etree_value_type new;
  new.valid_p = TRUE;
  new.value = value;
  new.str = NULL;
  new.section = section;

  new.value -= section->vma;

  return new;
d200 5
a204 14
static etree_value_type
fold_unary (etree_type *tree,
	    asection *current_section,
	    lang_phase_type allocation_done,
	    bfd_vma dot,
	    bfd_vma *dotp,
	    bfd_boolean mark_used)
{
  etree_value_type result;

  result = exp_fold_tree_1 (tree->unary.child,
			    current_section,
			    allocation_done, dot, dotp, mark_used);
  if (result.valid_p)
d209 5
a213 3
	  if (allocation_done != lang_first_phase_enum)
	    result = new_rel_from_section (align_n (dot, result.value),
					   current_section);
d215 1
a215 1
	    result.valid_p = FALSE;
d219 1
a219 7
	  if (allocation_done != lang_first_phase_enum)
	    {
	      result.value += result.section->vma;
	      result.section = bfd_abs_section_ptr;
	    }
	  else
	    result.valid_p = FALSE;
d223 2
a224 2
	  make_abs (&result);
	  result.value = ~result.value;
d228 2
a229 2
	  make_abs (&result);
	  result.value = !result.value;
d233 2
a234 2
	  make_abs (&result);
	  result.value = -result.value;
d239 1
a239 1
	  if (allocation_done == lang_allocating_phase_enum)
d241 2
a242 2
	      make_abs (&result);
	      result.value = align_n (dot, result.value);
d245 1
a245 1
	    result.valid_p = FALSE;
d249 7
a255 7
	  if (allocation_done != lang_first_phase_enum
	      && current_section == bfd_abs_section_ptr
	      && (exp_data_seg.phase == exp_dataseg_align_seen
		  || exp_data_seg.phase == exp_dataseg_relro_seen
		  || exp_data_seg.phase == exp_dataseg_adjust
		  || exp_data_seg.phase == exp_dataseg_relro_adjust
		  || allocation_done != lang_allocating_phase_enum))
d257 2
a258 2
	      if (exp_data_seg.phase == exp_dataseg_align_seen
		  || exp_data_seg.phase == exp_dataseg_relro_seen)
d260 2
a261 2
		  exp_data_seg.phase = exp_dataseg_end_seen;
		  exp_data_seg.end = result.value;
d265 1
a265 1
	    result.valid_p = FALSE;
a272 2

  return result;
d275 2
a276 7
static etree_value_type
fold_binary (etree_type *tree,
	     asection *current_section,
	     lang_phase_type allocation_done,
	     bfd_vma dot,
	     bfd_vma *dotp,
	     bfd_boolean mark_used)
d278 1
a278 4
  etree_value_type result;

  result = exp_fold_tree_1 (tree->binary.lhs, current_section,
			    allocation_done, dot, dotp, mark_used);
d282 1
a282 1
  if (result.valid_p && tree->type.node_code == SEGMENT_START)
d293 3
a295 3
	    result.value = seg->value;
	    result.str = NULL;
	    result.section = NULL;
d299 1
a299 1
  else if (result.valid_p)
d301 1
a301 1
      etree_value_type other;
d303 2
a304 5
      other = exp_fold_tree_1 (tree->binary.rhs,
			       current_section,
			       allocation_done,
			       dot, dotp, mark_used);
      if (other.valid_p)
d311 10
a320 4
	  if (current_section != bfd_abs_section_ptr
	      && (other.section == bfd_abs_section_ptr
		  || (result.section == bfd_abs_section_ptr
		      && tree->type.node_code == '+'))
d324 2
a325 9
	      if (other.section != bfd_abs_section_ptr)
		{
		  /* Keep the section of the other term.  */
		  if (tree->type.node_code == '+')
		    other.value = result.value + other.value;
		  else
		    other.value = result.value - other.value;
		  return other;
		}
d327 2
a328 2
	  else if (result.section != other.section
		   || current_section == bfd_abs_section_ptr)
d330 2
a331 2
	      make_abs (&result);
	      make_abs (&other);
d337 4
a340 1
	      if (other.value == 0)
a341 2
	      result.value = ((bfd_signed_vma) result.value
			      % (bfd_signed_vma) other.value);
d345 4
a348 1
	      if (other.value == 0)
a349 2
	      result.value = ((bfd_signed_vma) result.value
			      / (bfd_signed_vma) other.value);
d352 5
a356 1
#define BOP(x,y) case x : result.value = result.value y other.value; break;
d375 2
a376 2
	      if (result.value < other.value)
		result = other;
d380 2
a381 2
	      if (result.value > other.value)
		result = other;
d385 1
a385 1
	      result.value = align_n (result.value, other.value);
d389 6
a394 6
	      if (allocation_done != lang_first_phase_enum
		  && current_section == bfd_abs_section_ptr
		  && (exp_data_seg.phase == exp_dataseg_none
		      || exp_data_seg.phase == exp_dataseg_adjust
		      || exp_data_seg.phase == exp_dataseg_relro_adjust
		      || allocation_done != lang_allocating_phase_enum))
d396 2
a397 1
		  bfd_vma maxpage = result.value;
d399 4
a402 4
		  result.value = align_n (dot, maxpage);
		  if (exp_data_seg.phase == exp_dataseg_relro_adjust)
		    result.value = exp_data_seg.base;
		  else if (exp_data_seg.phase != exp_dataseg_adjust)
d404 2
a405 2
		      result.value += dot & (maxpage - 1);
		      if (allocation_done == lang_allocating_phase_enum)
d407 6
a412 6
			  exp_data_seg.phase = exp_dataseg_align_seen;
			  exp_data_seg.min_base = align_n (dot, maxpage);
			  exp_data_seg.base = result.value;
			  exp_data_seg.pagesize = other.value;
			  exp_data_seg.maxpagesize = maxpage;
			  exp_data_seg.relro_end = 0;
d415 3
a417 3
		  else if (other.value < maxpage)
		    result.value += (dot + other.value - 1)
				    & (maxpage - other.value);
d420 1
a420 1
		result.valid_p = FALSE;
d424 5
a428 5
	      if (allocation_done != lang_first_phase_enum
		  && (exp_data_seg.phase == exp_dataseg_align_seen
		      || exp_data_seg.phase == exp_dataseg_adjust
		      || exp_data_seg.phase == exp_dataseg_relro_adjust
		      || allocation_done != lang_allocating_phase_enum))
d430 7
a436 7
		  if (exp_data_seg.phase == exp_dataseg_align_seen
		      || exp_data_seg.phase == exp_dataseg_relro_adjust)
		    exp_data_seg.relro_end
		      = result.value + other.value;
		  if (exp_data_seg.phase == exp_dataseg_relro_adjust
		      && (exp_data_seg.relro_end
			  & (exp_data_seg.pagesize - 1)))
d438 4
a441 3
		      exp_data_seg.relro_end += exp_data_seg.pagesize - 1;
		      exp_data_seg.relro_end &= ~(exp_data_seg.pagesize - 1);
		      result.value = exp_data_seg.relro_end - other.value;
d443 5
a447 2
		  if (exp_data_seg.phase == exp_dataseg_align_seen)
		    exp_data_seg.phase = exp_dataseg_relro_seen;
d450 1
a450 1
		result.valid_p = FALSE;
d458 1
a458 3
	{
	  result.valid_p = FALSE;
	}
d460 1
d462 8
a469 1
  return result;
d472 2
a473 29
static etree_value_type
fold_trinary (etree_type *tree,
	      asection *current_section,
	      lang_phase_type allocation_done,
	      bfd_vma dot,
	      bfd_vma *dotp,
	      bfd_boolean mark_used)
{
  etree_value_type result;

  result = exp_fold_tree_1 (tree->trinary.cond, current_section,
			    allocation_done, dot, dotp, mark_used);
  if (result.valid_p)
    result = exp_fold_tree_1 ((result.value
			       ? tree->trinary.lhs
			       : tree->trinary.rhs),
			      current_section,
			      allocation_done,
			      dot, dotp, mark_used);

  return result;
}

static etree_value_type
fold_name (etree_type *tree,
	   asection *current_section,
	   lang_phase_type allocation_done,
	   bfd_vma dot,
	   bfd_boolean mark_used)
d475 1
a475 3
  etree_value_type result;

  memset (&result, 0, sizeof (result));
d480 9
a488 3
      if (allocation_done != lang_first_phase_enum)
	result = new_abs (bfd_sizeof_headers (output_bfd,
					      link_info.relocatable));
d491 1
a491 1
      if (allocation_done == lang_first_phase_enum)
d502 8
a509 8
	  result.value = (h != NULL
			  && (h->type == bfd_link_hash_defined
			      || h->type == bfd_link_hash_defweak
			      || h->type == bfd_link_hash_common)
			  && (def_iteration == lang_statement_iteration
			      || def_iteration == -1));
	  result.section = bfd_abs_section_ptr;
	  result.valid_p = TRUE;
d513 5
a517 6
      if (tree->name.name[0] == '.' && tree->name.name[1] == 0)
	{
	  if (allocation_done != lang_first_phase_enum)
	    result = new_rel_from_section (dot, current_section);
	}
      else if (allocation_done != lang_first_phase_enum)
d530 2
a531 3
		result = new_abs (h->u.def.value);
	      else if (allocation_done == lang_final_phase_enum
		       || allocation_done == lang_allocating_phase_enum)
a536 3
		    einfo (_("%X%S: unresolvable symbol `%s' referenced in expression\n"),
			   tree->name.name);
		  else
d538 4
a541 7
		      /* FIXME: Is this correct if this section is
			 being linked with -R?  */
		      result = new_rel ((h->u.def.value
					 + h->u.def.section->output_offset),
					NULL,
					output_section);
		      output_section->flags |= SEC_KEEP;
d543 3
d548 2
a549 2
	  else if (allocation_done == lang_final_phase_enum
		   || assigning_to_dot)
d563 1
a563 1
      if (allocation_done != lang_first_phase_enum)
d568 2
a569 6
	  if (os)
	    {
	      os->bfd_section->flags |= SEC_KEEP;
	      if (os->processed > 0)
		result = new_rel (0, NULL, os->bfd_section);
	    }
d574 1
a574 1
      if (allocation_done != lang_first_phase_enum)
d579 1
a579 1
	  if (os)
d581 4
a584 11
	      os->bfd_section->flags |= SEC_KEEP;
	      if (os->processed != 0)
		{
		  if (os->load_base == NULL)
		    result = new_rel (0, NULL, os->bfd_section);
		  else
		    result = exp_fold_tree_no_dot (os->load_base,
						   bfd_abs_section_ptr,
						   allocation_done,
						   mark_used);
		}
d590 1
a590 1
      if (allocation_done != lang_first_phase_enum)
d596 2
a597 6
	  if (os)
	    {
	      os->bfd_section->flags |= SEC_KEEP;
	      if (os->processed > 0)
		result = new_abs (os->bfd_section->size / opb);
	    }
d607 1
a607 1
          result = new_abs (mem->length);
d609 2
a610 2
          einfo (_("%F%S: undefined MEMORY region `%s' referenced in expression\n"),
		   tree->name.name);
d620 1
a620 1
          result = new_abs (mem->origin);
d622 2
a623 2
          einfo (_("%F%S: undefined MEMORY region `%s' referenced in expression\n"),
		   tree->name.name);
a630 2

  return result;
d633 2
a634 7
static etree_value_type
exp_fold_tree_1 (etree_type *tree,
		 asection *current_section,
		 lang_phase_type allocation_done,
		 bfd_vma dot,
		 bfd_vma *dotp,
		 bfd_boolean mark_used)
a635 2
  etree_value_type result;

d638 2
a639 2
      memset (&result, 0, sizeof (result));
      return result;
d645 1
a645 1
      result = new_rel (tree->value.value, tree->value.str, current_section);
d649 6
a654 2
      if (allocation_done != lang_final_phase_enum)
	memset (&result, 0, sizeof (result));
d656 1
a656 5
	result = new_rel ((tree->rel.value
			   + tree->rel.section->output_section->vma
			   + tree->rel.section->output_offset),
			  NULL,
			  current_section);
d660 2
a661 5
      result = exp_fold_tree_1 (tree->assert_s.child,
				current_section,
				allocation_done, dot, dotp,
				mark_used);
      if (result.valid_p)
d663 1
a663 1
	  if (mark_used)
d666 2
a667 2
	    result.value = 1;
	  else if (!result.value)
d673 1
a673 2
      result = fold_unary (tree, current_section, allocation_done,
			   dot, dotp, mark_used);
d677 1
a677 2
      result = fold_binary (tree, current_section, allocation_done,
			    dot, dotp, mark_used);
d681 1
a681 2
      result = fold_trinary (tree, current_section, allocation_done,
			     dot, dotp, mark_used);
d692 4
a695 3
	  if (allocation_done == lang_allocating_phase_enum
	      || (allocation_done == lang_final_phase_enum
		  && current_section == bfd_abs_section_ptr))
d698 3
a700 6
	      assigning_to_dot = TRUE;
	      result = exp_fold_tree_1 (tree->assign.src,
					current_section,
					allocation_done,
					dot, dotp, mark_used);
	      assigning_to_dot = FALSE;
d702 8
a709 2
	      if (! result.valid_p)
		einfo (_("%F%S invalid assignment to location counter\n"));
d712 7
a718 2
		  if (current_section == NULL)
		    einfo (_("%F%S assignment to location counter invalid outside of SECTION\n"));
d721 2
a722 9
		      bfd_vma nextdot;

		      nextdot = result.value + current_section->vma;
		      if (nextdot < dot
			  && current_section != bfd_abs_section_ptr)
			einfo (_("%F%S cannot move location counter backwards (from %V to %V)\n"),
			       dot, nextdot);
		      else
			*dotp = nextdot;
d727 1
a727 1
	    memset (&result, 0, sizeof (result));
d731 3
a733 4
	  result = exp_fold_tree_1 (tree->assign.src,
				    current_section, allocation_done,
				    dot, dotp, mark_used);
	  if (result.valid_p)
d735 12
a746 2
	      bfd_boolean create;
	      struct bfd_link_hash_entry *h;
d748 3
a750 6
	      if (tree->type.node_class == etree_assign)
		create = TRUE;
	      else
		create = FALSE;
	      h = bfd_link_hash_lookup (link_info.hash, tree->assign.dst,
					create, FALSE, TRUE);
d753 3
a755 1
		  if (create)
d759 9
a767 19
	      else if (tree->type.node_class == etree_provide
		       && h->type != bfd_link_hash_new
		       && h->type != bfd_link_hash_undefined
		       && h->type != bfd_link_hash_common)
		{
		  /* Do nothing.  The symbol was defined by some
		     object.  */
		}
	      else
		{
		  /* FIXME: Should we worry if the symbol is already
		     defined?  */
		  lang_update_definedness (tree->assign.dst, h);
		  h->type = bfd_link_hash_defined;
		  h->u.def.value = result.value;
		  h->u.def.section = result.section;
		  if (tree->type.node_class == etree_provide)
		    tree->type.node_class = etree_provided;
		}
d773 1
a773 2
      result = fold_name (tree, current_section, allocation_done, dot,
			  mark_used);
d778 1
a778 1
      memset (&result, 0, sizeof (result));
a780 2

  return result;
d783 2
a784 6
etree_value_type
exp_fold_tree (etree_type *tree,
	       asection *current_section,
	       lang_phase_type allocation_done,
	       bfd_vma dot,
	       bfd_vma *dotp)
d786 4
a789 2
  return exp_fold_tree_1 (tree, current_section, allocation_done,
			  dot, dotp, FALSE);
d792 2
a793 5
static etree_value_type
exp_fold_tree_no_dot (etree_type *tree,
		      asection *current_section,
		      lang_phase_type allocation_done,
		      bfd_boolean mark_used)
d795 4
a798 2
  return exp_fold_tree_1 (tree, current_section, allocation_done, 0,
			  NULL, mark_used);
a804 1
  etree_value_type r;
d810 4
a813 7
  r = exp_fold_tree_no_dot (&value,
			    bfd_abs_section_ptr,
			    lang_first_phase_enum, FALSE);
  if (r.valid_p)
    {
      return exp_intop (r.value);
    }
d823 1
a823 1
  etree_value_type r;
d829 3
a831 3
  r = exp_fold_tree_no_dot (&value, NULL, lang_first_phase_enum, FALSE);
  if (r.valid_p)
    return exp_intop (r.value);
a842 1
  etree_value_type r;
d846 3
a848 4
  r = exp_fold_tree_no_dot (&value, bfd_abs_section_ptr,
			    lang_first_phase_enum, FALSE);
  if (r.valid_p)
    return exp_intop (r.value);
d859 1
a859 1
  etree_value_type r;
d864 3
a866 3
  r = exp_fold_tree_no_dot (&value, NULL, lang_first_phase_enum, FALSE);
  if (r.valid_p)
    return exp_intop (r.value);
d877 1
a877 7
  etree_type value, *new;

  value.assign.type.node_code = code;

  value.assign.src = src;
  value.assign.dst = dst;
  value.assign.type.node_class = etree_assign;
d880 4
a883 1
  memcpy (new, &value, sizeof (new->assign));
a979 3
    case etree_undef:
      fprintf (config.map_file, "????????");
      break;
d999 1
a999 4
exp_get_vma (etree_type *tree,
	     bfd_vma def,
	     char *name,
	     lang_phase_type allocation_done)
a1000 2
  etree_value_type r;

d1003 4
a1006 3
      r = exp_fold_tree_no_dot (tree, bfd_abs_section_ptr,
				allocation_done, FALSE);
      if (! r.valid_p && name != NULL)
a1007 1
      return r.value;
d1009 1
a1009 2
  else
    return def;
d1013 1
a1013 4
exp_get_value_int (etree_type *tree,
		   int def,
		   char *name,
		   lang_phase_type allocation_done)
d1015 1
a1015 1
  return exp_get_vma (tree, def, name, allocation_done);
d1019 1
a1019 4
exp_get_fill (etree_type *tree,
	      fill_type *def,
	      char *name,
	      lang_phase_type allocation_done)
a1021 1
  etree_value_type r;
d1028 7
a1034 4
  r = exp_fold_tree_no_dot (tree, bfd_abs_section_ptr, allocation_done,
			    FALSE);
  if (! r.valid_p && name != NULL)
    einfo (_("%F%S nonconstant expression for %s\n"), name);
d1036 1
a1036 1
  if (r.str != NULL && (len = strlen (r.str)) != 0)
d1043 1
a1043 1
      s = (unsigned char *) r.str;
d1066 1
a1066 1
      val = r.value;
d1077 5
a1081 8
exp_get_abs_int (etree_type *tree,
		 int def ATTRIBUTE_UNUSED,
		 char *name,
		 lang_phase_type allocation_done)
{
  etree_value_type res;
  res = exp_fold_tree_no_dot (tree, bfd_abs_section_ptr, allocation_done,
			      FALSE);
d1083 9
a1091 6
  if (res.valid_p)
    res.value += res.section->vma;
  else
    einfo (_("%F%S non constant expression for %s\n"), name);

  return res.value;
a1102 100

void
exp_mark_used_section (etree_type *tree, asection *current_section)
{
  bfd_vma dot = 0;

  switch (tree->type.node_class)
    {
    case etree_value:
      break;

    case etree_rel:
      break;

    case etree_assert:
      break;

    case etree_unary:
      break;

    case etree_binary:
      fold_binary (tree, current_section, lang_allocating_phase_enum,
		   dot, &dot, TRUE);
      break;

    case etree_trinary:
      break;

    case etree_assign:
    case etree_provide:
    case etree_provided:
      if (tree->assign.dst[0] != '.' || tree->assign.dst[1] != 0)
	{
	  etree_value_type result;
	  bfd_boolean create = tree->type.node_class == etree_assign;
	  struct bfd_link_hash_entry *h;

	  result = exp_fold_tree_1 (tree->assign.src,
				    current_section,
				    lang_allocating_phase_enum,
				    dot, &dot, TRUE);

	  /* We mark the current section SEC_KEEP only if the symbol
	     will be defined.  */
	  if (!create)
	    h = bfd_link_hash_lookup (link_info.hash, tree->assign.dst,
				      create, FALSE, TRUE);
	  else
	    h = NULL;

	  if ((create || h)
	      && current_section != bfd_abs_section_ptr)
	    current_section->flags |= SEC_KEEP;

	  if (result.valid_p)
	    {

	      if (create)
		h = bfd_link_hash_lookup (link_info.hash,
					  tree->assign.dst, create,
					  FALSE, TRUE);
	      if (h == NULL)
		{
		  if (create)
		    einfo (_("%P%F:%s: hash creation failed\n"),
			   tree->assign.dst);
		}
	      else if (tree->type.node_class == etree_provide
		       && h->type != bfd_link_hash_new
		       && h->type != bfd_link_hash_undefined
		       && h->type != bfd_link_hash_common)
		{
		  /* Do nothing.  The symbol was defined by some
		     object.  */
		}
	      else
		{
		  /* FIXME: Should we worry if the symbol is already
		     defined?  */
		  lang_update_definedness (tree->assign.dst, h);
		  h->type = bfd_link_hash_defined;
		  h->u.def.value = result.value;
		  h->u.def.section = result.section;
		  if (tree->type.node_class == etree_provide)
		    tree->type.node_class = etree_provided;
		}
	    }
	}
      break;

    case etree_name:
      fold_name (tree, current_section, lang_allocating_phase_enum, 0,
		 TRUE);
      break;

    default:
      abort ();
      break;
    }
}
@


1.50
log
@2005-06-04  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 992
	* ldexp.c (exp_mark_used_section): Set SEC_KEEP on current
	section for etree_assign, etree_provide and etree_provided.
	Call fold_binary on etree_binary.

	* ldlang.c (lang_mark_used_section_1): Handle load base.
@
text
@d1250 2
d1257 11
a1267 1
	  if (current_section != bfd_abs_section_ptr)
d1269 1
a1271 2
	      bfd_boolean create;
	      struct bfd_link_hash_entry *h;
d1273 4
a1276 6
	      if (tree->type.node_class == etree_assign)
		create = TRUE;
	      else
		create = FALSE;
	      h = bfd_link_hash_lookup (link_info.hash, tree->assign.dst,
					create, FALSE, TRUE);
@


1.49
log
@	* ldexp.h (etree_value_type): Use "asection *" in place of
	"struct lang_output_section_statement_struct *" for "section".
	(exp_fold_tree): Likewise.
	(exp_mark_used_section): Likewise.
	* ldexp.c (new_rel, new_rel_from_section, fold_unary, fold_binary,
	fold_trinary, fold_name, exp_fold_tree_1, exp_fold_tree,
	exp_mark_used_section): Likewise for "current_section" param.
	(make_abs, new_abs, exp_binop, exp_unop, exp_get_vma, exp_get_fill,
	exp_get_abs_int): Adjust for above changes.
	* ldlang.c (lang_mark_used_section_1, print_assignment,
	lang_size_sections_1, lang_do_assignments_1): Likewise.
	* ldexp.c (fold_name): Init entire result struct.
@
text
@d1220 2
d1237 2
a1249 1
	  bfd_vma dot = 0;
d1255 2
@


1.48
log
@bfd/

2005-05-17  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 797
	* elf32-i386.c (elf_i386_size_dynamic_sections): Also remove
	empty sdynbss section.
	* elf64-x86-64.c (elf64_x86_64_size_dynamic_sections): Likewise.

ld/

2005-05-17  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 797
	* ldexp.c (exp_fold_tree_1): Renamed from exp_fold_tree and
	take take a bfd_boolean, mark_used. Ignore assert failure if
	mark_used is TRUE.
	(exp_fold_tree) Call exp_fold_tree_1 with mark_used == FALSE.
	(exp_fold_tree_no_dot): Updated to take a bfd_boolean,
	mark_used and pass down.
	(fold_unary): Likewise.
	(fold_binary): Likewise.
	(fold_trinary): Likewise.
	(exp_binop): Add FALSE to call to exp_fold_tree_no_dot.
	(exp_trinop): Likewise.
	(exp_unop): Likewise.
	(exp_nameop): Likewise.
	(exp_get_vma): Likewise.
	(exp_get_fill): Likewise.
	(exp_get_abs_int): Likewise.
	(fold_name): Likewise. Set SEC_KEEP in output section flags.
	(exp_mark_used_section): New.

	* ldexp.h (exp_mark_used_section): New.

	* ldlang.c (lang_output_section_statement_lookup_1): Set the
	ignored field to FALSE.
	(lang_mark_used_section_1): New.
	(lang_mark_used_section): Call lang_mark_used_section_1.
	(strip_excluded_output_sections): Call lang_mark_used_section
	and check for unused sections.
	(lang_size_sections_1): Skip an output section if it should
	be ignored.
	(lang_do_assignments_1): Likewise.
	(lang_process): Don't call lang_mark_used_section here.

	* ldlang.h (lang_output_section_statement_type): Change
	all_input_readonly to bitfield. Add ignored.

ld/testsuite/

2005-05-17  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 797
	* empty-aligned.d: New file.
	* empty-aligned.exp: Likewise.
	* empty-aligned.s: Likewise.
	* empty-aligned.t: Likewise.
@
text
@d45 1
a45 2
  (etree_type *, lang_output_section_statement_type *,
   lang_phase_type, bfd_vma, bfd_vma *, bfd_boolean);
d47 1
a47 2
  (etree_type *, lang_output_section_statement_type *, lang_phase_type,
   bfd_boolean);
d140 2
a141 3
  asection *s = ptr->section->bfd_section;
  ptr->value += s->vma;
  ptr->section = abs_output_section;
d149 1
a149 1
  new.section = abs_output_section;
d193 1
a193 1
	 lang_output_section_statement_type *section)
d204 1
a204 2
new_rel_from_section (bfd_vma value,
		      lang_output_section_statement_type *section)
d212 1
a212 1
  new.value -= section->bfd_section->vma;
d219 1
a219 1
	    lang_output_section_statement_type *current_section,
d245 2
a246 2
	      result.value += result.section->bfd_section->vma;
	      result.section = abs_output_section;
d280 1
a280 1
	      && current_section == abs_output_section
d309 1
a309 1
	     lang_output_section_statement_type *current_section,
d354 3
a356 3
	  if (current_section != abs_output_section
	      && (other.section == abs_output_section
		  || (result.section == abs_output_section
d361 1
a361 1
	      if (other.section != abs_output_section)
d372 1
a372 1
		   || current_section == abs_output_section)
d428 1
a428 1
		  && current_section == abs_output_section
d501 1
a501 1
	      lang_output_section_statement_type *current_section,
d524 1
a524 1
	   lang_output_section_statement_type *current_section,
d531 1
a531 1
  result.valid_p = FALSE;
d558 1
a558 1
	  result.section = abs_output_section;
a592 6
		      lang_output_section_statement_type *os;

		      os = (lang_output_section_statement_lookup
			    (bfd_get_section_name (output_bfd,
						   output_section)));

d598 2
a599 2
					os);
		      os->bfd_section->flags |= SEC_KEEP;
d627 1
a627 1
		result = new_rel (0, NULL, os);
d644 1
a644 1
		    result = new_rel (0, NULL, os);
d647 1
a647 1
						   abs_output_section,
d707 1
a707 1
		 lang_output_section_statement_type *current_section,
d779 1
a779 1
		  && current_section == abs_output_section))
d799 1
a799 2
		      nextdot = (result.value
				 + current_section->bfd_section->vma);
d801 1
a801 1
			  && current_section != abs_output_section)
d849 1
a849 1
		  h->u.def.section = result.section->bfd_section;
d873 1
a873 1
	       lang_output_section_statement_type *current_section,
d884 1
a884 1
		      lang_output_section_statement_type *current_section,
d903 1
a903 1
			    abs_output_section,
d942 1
a942 1
  r = exp_fold_tree_no_dot (&value, abs_output_section,
d1111 1
a1111 1
      r = exp_fold_tree_no_dot (tree, abs_output_section,
d1144 1
a1144 1
  r = exp_fold_tree_no_dot (tree, abs_output_section, allocation_done,
d1196 1
a1196 1
  res = exp_fold_tree_no_dot (tree, abs_output_section, allocation_done,
d1200 1
a1200 1
    res.value += res.section->bfd_section->vma;
d1218 1
a1218 3
exp_mark_used_section
  (etree_type *tree,
   lang_output_section_statement_type *current_section)
d1284 1
a1284 1
		  h->u.def.section = result.section->bfd_section;
@


1.47
log
@Update FSF addresses
@
text
@d44 3
d48 2
a49 1
  (etree_type *, lang_output_section_statement_type *, lang_phase_type);
d226 2
a227 1
	    bfd_vma *dotp)
d231 3
a233 3
  result = exp_fold_tree (tree->unary.child,
			  current_section,
			  allocation_done, dot, dotp);
d316 2
a317 1
	     bfd_vma *dotp)
d321 2
a322 2
  result = exp_fold_tree (tree->binary.lhs, current_section,
			  allocation_done, dot, dotp);
d347 4
a350 3
      other = exp_fold_tree (tree->binary.rhs,
			     current_section,
			     allocation_done, dot, dotp);
d508 2
a509 1
	      bfd_vma *dotp)
d513 2
a514 2
  result = exp_fold_tree (tree->trinary.cond, current_section,
			  allocation_done, dot, dotp);
d516 6
a521 5
    result = exp_fold_tree ((result.value
			     ? tree->trinary.lhs
			     : tree->trinary.rhs),
			    current_section,
			    allocation_done, dot, dotp);
d530 2
a531 1
	   bfd_vma dot)
d609 1
d633 6
a638 2
	  if (os && os->processed > 0)
	    result = new_rel (0, NULL, os);
d648 1
a648 1
	  if (os && os->processed != 0)
d650 11
a660 6
	      if (os->load_base == NULL)
		result = new_rel (0, NULL, os);
	      else
		result = exp_fold_tree_no_dot (os->load_base,
					       abs_output_section,
					       allocation_done);
d672 6
a677 2
	  if (os && os->processed > 0)
	    result = new_abs (os->bfd_section->size / opb);
d715 7
a721 6
etree_value_type
exp_fold_tree (etree_type *tree,
	       lang_output_section_statement_type *current_section,
	       lang_phase_type allocation_done,
	       bfd_vma dot,
	       bfd_vma *dotp)
d749 13
a761 5
      result = exp_fold_tree (tree->assert_s.child,
			      current_section,
			      allocation_done, dot, dotp);
      if (result.valid_p && !result.value)
	einfo ("%X%P: %s\n", tree->assert_s.message);
d766 1
a766 1
			   dot, dotp);
d771 1
a771 1
			    dot, dotp);
d776 1
a776 1
			     dot, dotp);
d793 4
a796 3
	      result = exp_fold_tree (tree->assign.src,
				      current_section,
				      allocation_done, dot, dotp);
d825 3
a827 3
	  result = exp_fold_tree (tree->assign.src,
				  current_section, allocation_done,
				  dot, dotp);
d869 2
a870 1
      result = fold_name (tree, current_section, allocation_done, dot);
d882 11
d896 2
a897 1
		      lang_phase_type allocation_done)
d899 2
a900 1
  return exp_fold_tree (tree, current_section, allocation_done, 0, NULL);
d915 1
a915 1
			    lang_first_phase_enum);
d935 1
a935 1
  r = exp_fold_tree_no_dot (&value, NULL, lang_first_phase_enum);
d954 1
a954 1
			    lang_first_phase_enum);
d972 1
a972 1
  r = exp_fold_tree_no_dot (&value, NULL, lang_first_phase_enum);
d1122 2
a1123 1
      r = exp_fold_tree_no_dot (tree, abs_output_section, allocation_done);
d1155 2
a1156 1
  r = exp_fold_tree_no_dot (tree, abs_output_section, allocation_done);
d1207 2
a1208 1
  res = exp_fold_tree_no_dot (tree, abs_output_section, allocation_done);
d1227 88
@


1.46
log
@	* ldexp.c (exp_fold_tree): Ensure return value is initialized.
	Tidy etree_assert case.
@
text
@d21 2
a22 2
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.45
log
@	* ldexp.c: Warning fixes.
	* ldwrite.c: Likewise.
	* emultempl/elf32.em: Likewise.
@
text
@d702 1
a702 1
      result.valid_p = FALSE;
d714 1
a714 1
	result.valid_p = FALSE;
d727 2
a728 6
      if (result.valid_p)
	{
	  if (! result.value)
	    einfo ("%X%P: %s\n", tree->assert_s.message);
	  return result;
	}
d786 2
d840 1
@


1.45.2.1
log
@	* ldexp.c (exp_fold_tree): Ensure return value is initialized.
	Tidy etree_assert case.
@
text
@d702 1
a702 1
      memset (&result, 0, sizeof (result));
d714 1
a714 1
	memset (&result, 0, sizeof (result));
d727 6
a732 2
      if (result.valid_p && !result.value)
	einfo ("%X%P: %s\n", tree->assert_s.message);
a789 2
	  else
	    memset (&result, 0, sizeof (result));
a841 1
      memset (&result, 0, sizeof (result));
@


1.44
log
@	* ldexp.c (assigning_to_dot): New global flag.
	(fold_name): If assigning_to_dot is true, object immediately to
	an undefined symbol.
	(exp_fold_tree): Set and clear assigning_to_dot around the
	recursive call to exp_fold_tree to process the right-hand side
	of an assignment to the location counter.
testsuite:
	* ld-scripts/align.exp: Rename existing "ALIGN" test to "align1".
	Add dump tests "align2a", "align2b", "align2c".
	* ld-scripts/align2.t, ld-scripts/align2a.s, ld-scripts/align2a.d
	* ld-scripts/align2b.s, ld-scripts/align2b.d
	* ld-scripts/align2c.s, ld-scripts/align2c.d: New files.
@
text
@d1118 1
a1118 1
      s = r.str;
@


1.43
log
@	* ldexp.c (new_abs): Init new.str.
@
text
@d53 3
d602 2
a603 1
	  else if (allocation_done == lang_final_phase_enum)
d762 2
d766 3
a768 2
				      allocation_done, dot,
				      dotp);
@


1.42
log
@	* ldlang.c (lang_reasonable_defaults): Remove.
	(lang_process): Don't call lang_reasonable_defaults.

	* ldexp.c (exp_assop): Remove #if 0'd code.
	(exp_print_tree): Likewise.
	* ldlang.c (lang_memory_region_lookup): Likewise.
	(open_output): Likewise.
	(lang_do_assignments_1): Likewise.
	(lang_place_orphans): Likewise.
	(lang_enter_output_section_statement): Likewise.
	(lang_reasonable_defaults): Likewise.
	* ldlang.h (struct lang_input_statement_struct): Likewise.
	* mri.c (mri_draw_tree): Likewise.
	(mri_load): Likewise.
	* pe-dll.c (generate_reloc): Likewise.
	(make_import_fixup_entry): Likewise.
	(pe_as16): Likewise.
	* emultempl/beos.em (set_pe_subsystem): Likewise.
	* emultempl/hppaelf.em (hppaelf_after_parse): Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/xtensaelf.em (xtensa_colocate_literals): Likewise.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004
d147 1
@


1.41
log
@	* ldexp.h (exp_data_seg): Add min_base and maxpagesize fields.
	* ldexp.c (fold_binary) <case DATA_SEGMENT_ALIGN>: Initialize them.
	* ldlang.c (lang_size_sections): Use them to avoid wasting virtual
	address space at DATA_SEGMENT_ALIGN.  Fix computation of expected
	PT_GNU_RELRO segment end.
@
text
@a937 4
#if 0
  if (exp_fold_tree_no_dot (&value, &result))
    return exp_intop (result);
#endif
a995 7
#if 0
      if (tree->assign.dst->sdefs != NULL)
	fprintf (config.map_file, "%s (%x) ", tree->assign.dst->name,
		 tree->assign.dst->sdefs->value);
      else
	fprintf (config.map_file, "%s (UNDEFINED)", tree->assign.dst->name);
#endif
@


1.40
log
@	* ldexp.c (fold_name): Correct PR 338 fix.
@
text
@d438 1
d441 1
@


1.39
log
@Add ORIGIN and LENGTH linker script operators.
@
text
@d603 1
a603 1
	      if (h->u.undef.next == NULL)
@


1.38
log
@	* Makefile.in (earmsymbian.c): Depend on armbpabi.sc, not elf.sc.
	* ldexp.h (segment_type): New type.
	(segments): New variable.
	* ldexp.c (segments): New variable.
	(exp_print_token): Handle SEGMENT_START.
	(fold_binary): Likewise.
	* ldgram.y (SEGMENT_START): Declare it as a token.
	(exp): Handle SEGMENT_START.
	* ldlang.h (lang_address_statement_type): Add segment field.
	(lang_section_start): Change prototype.
	* ldlang.c (map_input_to_output_sections): Do not process section
	assignments if a corresponding SEGMENT_START has already been
	seen.
	(lang_section_start): Add segment parameter.
	* ldlex.l (SEGMENT_START): Add it.
	* lexsup.c (seg_segment_start): New function.
	(parse_args): Use it for -Tbss, -Tdata, and -Ttext.
	* ld.texinfo (SEGMENT_START): Document it.
	* emulparams/armsymbian.sh (EMBEDDED): Set it.
	* scripttempl/armbpabi.sc: Use SEGMENT_START to control segment
	base addresses.  Do not map relocations.
	* NEWS: Mention SEGMENT_START.
@
text
@d7 1
a7 1
This file is part of GLD, the Gnu Linker.
d9 14
a22 14
GLD is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GLD is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GLD; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.  */
d108 2
d650 26
@


1.37
log
@	* ldexp.c (exp_fold_tree): Don't immediately exit ld on a
	failing link script assert.
@
text
@d51 2
d107 2
a108 1
    { DATA_SEGMENT_END, "DATA_SEGMENT_END" }
d311 21
a331 1
  if (result.valid_p)
@


1.36
log
@	* ldgram.y (DATA_SEGMENT_RELRO_END): Add one argument.
	* scripttempl/elf.sc (DATA_SEGMENT_RELRO_END): Add 0 as first
	argument.
	(DATA_SEGMENT_RELRO_GOTPLT_END): Pass $SEPARATE_GOTPLT as first
	and . as second argument.
	(GOTPLT): Move $DATA_SEGMENT_RELRO_GOTPLT_END before the section.
	* ldexp.c (fold_unary): Remove DATA_SEGMENT_RELRO_END handling here.
	(fold_binary): Add it here.  Insert padding to make relro_end
	COMMONPAGESIZE bytes aligned.  For DATA_SEGMENT_ALIGN in
	exp_dataseg_relro_adjust phase just use previously computed
	exp_data_seg.base.
	* ldlang.c (lang_size_sections): Set exp_data_seg.base for
	relro_adjust here.  Call lang_size_sections_1 once more if there
	was too big padding at DATA_SEGMENT_RELRO_END.
	* ld.texinfo (DATA_SEGMENT_RELRO_END): Add documentation.
@
text
@d393 1
a393 1
	      
d495 1
a495 1
  
d672 1
a672 1
	    einfo ("%F%P: %s\n", tree->assert_s.message);
@


1.35
log
@	* ldexp.c (fold_binary) [DATA_SEGMENT_ALIGN]: Adjust data segment
	base so that relro end is suitably aligned.
@
text
@a267 19
	case DATA_SEGMENT_RELRO_END:
	  if (allocation_done != lang_first_phase_enum
	      && (exp_data_seg.phase == exp_dataseg_align_seen
		  || exp_data_seg.phase == exp_dataseg_adjust
		  || exp_data_seg.phase == exp_dataseg_relro_adjust
		  || allocation_done != lang_allocating_phase_enum))
	    {
	      if (exp_data_seg.phase == exp_dataseg_align_seen
		  || exp_data_seg.phase == exp_dataseg_relro_adjust)
		exp_data_seg.relro_end
		  = result.value + current_section->bfd_section->vma;
	      if (exp_data_seg.phase == exp_dataseg_align_seen)
		exp_data_seg.phase = exp_dataseg_relro_seen;
	      result.value = dot - current_section->bfd_section->vma;
	    }
	  else
	    result.valid_p = FALSE;
	  break;

d406 1
a406 7
		    {
		      /* Attempt to align DATA_SEGMENT_RELRO_END at
			 a common page boundary.  */
		      exp_data_seg.base += (-exp_data_seg.relro_end
					    & (other.value - 1));
		      result.value = exp_data_seg.base;
		    }
d426 26
@


1.34
log
@include/
	* bfdlink.h (struct bfd_link_hash_entry): Move und_next into elements
	of union.
bfd/
	* ecoff.c: Update u.undef.next refs.
	* elf64-ppc.c: Likewise.
	* elflink.c: Likewise.
	* linker.c: Likewise.
	* xcofflink.c: Likewise.
ld/
	* ldexp.c (fold_name): Update u.undef.next refs.
	* emultempl/pe.em: Likewise.
	* emultempl/sunos.em: Likewise.

bfd/
	* elf-bfd.h (struct elf_link_hash_entry): Rearrange.  Add FIXME to
	dynamic_def.  Combine weakdef and elf_hash_value.  Move vtable
	fields to indirect struct.
	* elf-m10300.c: Update u.weakdef refs.
	* elf32-arm.h: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-sparc.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elflink.c: Likewise.  Also u.elf_hash_value.
	(elf_gc_propagate_vtable_entries_used): Update for h->vtable
	indirection.
	(elf_gc_smash_unused_vtentry_relocs): Likewise.
	(bfd_elf_gc_record_vtinherit): Alloc vtable.
	(bfd_elf_gc_record_vtentry): Likewise.
	* elf.c (_bfd_elf_link_hash_newfunc): Use memset.
@
text
@d428 3
a430 6
		      bfd_vma relro;

		      result.value += dot & (maxpage - 1);
		      relro = exp_data_seg.relro_end - exp_data_seg.base;
		      result.value += -relro & (other.value - 1);
		      exp_data_seg.base = result.value;
@


1.33
log
@	* ldexp.c (fold_binary) [DATA_SEGMENT_ALIGN]: Apply data segment
	alignment before adjusting DATA_SEGMENT_RELRO_END.
@
text
@d580 1
a580 1
	      if (h->und_next == NULL)
@


1.32
log
@	PR 338
	* elflink.c (bfd_elf_record_link_assignment): Add comment about
	changing bfd_link_hash_undefined to bfd_link_hash_new.
	* ldexp.c (fold_name): Don't call bfd_link_add_undef if the symbol
	was already on the undefs list.
@
text
@d430 1
@


1.31
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d579 2
a580 1
	      bfd_link_add_undef (link_info.hash, h);
@


1.30
log
@bfd/
	* elflink.c (elf_bfd_final_link): Don't output STT_SECTION symbol
	into .dynsym if elf_section_data (sec)->dynindx <= 0.
	Adjust counting of last_local.
	(_bfd_elf_link_renumber_dynsyms): Don't assign dynindx to sections
	other than SHT_PROGBITS/SHT_NOBITS and neither for .got/.got.plt/.plt
	created by the linker nor !SHF_ALLOC.

	* elf32-i386.c (elf_i386_finish_dynamic_sections): Point
	DT_PLTGOT to the start of the .got.plt section instead of the
	.got output section.  Set sh_entsize for .got section in addition
	to .got.plt.
	(elf_i386_relocate_section): Don't assume _GLOBAL_OFFSET_TABLE_
	is at sgot->output_section->vma.
	* elf64-x86-64.c (elf64_x86_64_finish_dynamic_sections): Point
	DT_PLTGOT to the start of the .got.plt section instead of the
	.got output section.
	(elf64_x86_64_relocate_section): Don't assume _GLOBAL_OFFSET_TABLE_
	is at sgot->output_section->vma.  Set sh_entsize for .got section
	in addition to .got.plt.
	* elf.c (_bfd_elf_print_private_bfd_data): Handle PT_GNU_RELRO.
	(bfd_section_from_phdr): Likewise.
	(map_sections_to_segments): Likewise.
	(assign_file_positions_for_segments): Likewise.
	(get_program_header_size): Likewise.
	* elflink.c (bfd_elf_size_dynamic_sections): Set
	elf_tdata (output_bfd)->relro from info->relro.
	* elf-bfd.h (struct elf_obj_tdata): Add relro field.
include/
	* bfdlink.h (struct bfd_link_info): Add relro, relro_start and
	relro_end fields.
	* elf/common.h (PT_GNU_EH_FRAME, PT_GNU_STACK): Add comments.
	(PT_GNU_RELRO): Define.
binutils/
	* readelf.c (get_segment_type): Handle PT_GNU_RELRO.
ld/
	* genscripts.sh: Generate -z combreloc -z now -z relro scripts
	for binaries, -shared and -pie.
	* emulparams/elf_i386.sh (SEPARATE_GOTPLT): Set.
	* emulparams/elf_x86_64.sh (SEPARATE_GOTPLT): Set.
	* emulparams/elf32ppc.sh (OTHER_READWRITE_SECTIONS): Rename to...
	(OTHER_RELRO_SECTIONS): ... this.
	* ldlex.l (DATA_SEGMENT_RELRO_END): Add.
	* emultempl/elf32.em (gld${EMULATION_NAME}_handle_option): Handle
	-z relro and -z norelro.
	(gld${EMULATION_NAME}_list_options): Add it to usage.
	(gld${EMULATION_NAME}_get_script): Return -z combreloc -z now
	-z relro scripts when appropriate.
	* scripttempl/elf.sc: Unset SEPARATE_GOTPLT if RELRO_NOW is set.
	Create separate .got.plt section if SEPARATE_GOTPLT.
	Move sections which are only written during relocation handling
	to the beginning of RW segment.  If NO_SMALL_DATA, move .got
	before .data.  Add DATA_SEGMENT_RELRO_END directive.
	Include OTHER_RELRO_SECTIONS.
	* ldgram.y (DATA_SEGMENT_RELRO_END): Add.
	* ldexp.c (exp_print_token): Handle DATA_SEGMENT_RELRO_END.
	(fold_unary): Likewise.
	(fold_binary): Handle -z relro.
	* ldexp.h (struct exp_data_seg): Add exp_dataseg_relro_seen and
	exp_dataseg_relro_adjust phases.  Add relro_end field.
	* ldmain.c (main): Initialize link_info.relro to FALSE.
	* ldlang.c (lang_size_sections): Handle -z relro.
ld/testsuite/
	* ld-i386/tlspic.rd: Adjust for section reordering changes
	and removal of unneeded STT_SECTION symbols from .dynsym.
	* ld-i386/tlspic.dd: Likewise.
	* ld-i386/tlspic.sd: Likewise.
	* ld-i386/tlsbin.rd: Likewise.
	* ld-i386/tlsbinpic.s: Likewise.
	* ld-i386/tlsbin.dd: Likewise.
	* ld-i386/tlsbin.sd: Likewise.
	* ld-i386/tlsnopic.rd: Likewise.
	* ld-i386/tlsnopic1.s: Likewise.
	* ld-i386/combreloc.d: Likewise.
	* ld-i386/tlsnopic.dd: Likewise.
	* ld-i386/tlsnopic.sd: Likewise.
	* ld-x86-64/tlspic.rd: Likewise.
	* ld-x86-64/tlspic.dd: Likewise.
	* ld-x86-64/tlsbin.dd: Likewise.
	* ld-x86-64/tlspic.sd: Likewise.
	* ld-x86-64/tlsbin.sd: Likewise.
	* ld-x86-64/tlspic.td: Likewise.
	* ld-x86-64/tlsbin.td: Likewise.
	* ld-x86-64/tlsbin.rd: Likewise.
	* ld-s390/tlspic1.s: Likewise.
	* ld-s390/tlsbinpic.s: Likewise.
	* ld-s390/tlspic.rd: Likewise.
	* ld-s390/tlsbin.rd: Likewise.
	* ld-s390/tlspic.dd: Likewise.
	* ld-s390/tlsbin.dd: Likewise.
	* ld-s390/tlsbin.sd: Likewise.
	* ld-s390/tlsbin.td: Likewise.
	* ld-s390/tlspic.sd: Likewise.
	* ld-s390/tlspic.td: Likewise.
	* ld-s390/tlspic1_64.s: Likewise.
	* ld-s390/tlsbinpic_64.s: Likewise.
	* ld-s390/tlspic_64.rd: Likewise.
	* ld-s390/tlsbin_64.rd: Likewise.
	* ld-s390/tlspic_64.dd: Likewise.
	* ld-s390/tlsbin_64.dd: Likewise.
	* ld-s390/tlspic_64.sd: Likewise.
	* ld-s390/tlspic_64.td: Likewise.
	* ld-s390/tlsbin_64.td: Likewise.
	* ld-s390/tlsbin_64.sd: Likewise.
	* ld-powerpc/tlsexe32.r: Likewise.
	* ld-powerpc/tlsso32.r: Likewise.
	* ld-powerpc/tlsso32.d: Likewise.
	* ld-powerpc/tlsso32.g: Likewise.
	* ld-powerpc/tlsso32.t: Likewise.
	* ld-powerpc/tlsexe.r: Likewise.
	* ld-powerpc/tlsso.r: Likewise.
	* ld-powerpc/tlsso.g: Likewise.
	* ld-powerpc/tlsexetoc.r: Likewise.
	* ld-powerpc/tlstocso.r: Likewise.
	* ld-powerpc/tlstocso.g: Likewise.
	* ld-ia64/tlspic.rd: Likewise.
	* ld-ia64/tlspic.dd: Likewise.
	* ld-ia64/tlspic.sd: Likewise.
	* ld-ia64/tlspic.td: Likewise.
	* ld-ia64/tlsbin.rd: Likewise.
	* ld-ia64/tlsbin.sd: Likewise.
	* ld-ia64/tlsbin.td: Likewise.
	* ld-elfvsb/elfvsb.exp: XFAIL non-PIC load offset tests on s390x.
	* ld-shared/shared.exp: Likewise.
@
text
@d621 1
a621 1
	    result = new_abs (os->bfd_section->_raw_size / opb);
@


1.29
log
@	* ldlang.h (struct lang_output_section_state): Change processed
	field's type.
	* ldexp.c (check, invalid): Remove.
	(fold_name): Move valid_p assignments. Create undefined symbol
	when needed. Directly exampine section's processd flag.
	* ldlang.c (lang_output_section_statement_lookup): Adjust
	processed field init.
	(lang_size_sections_1): Allow LOADADDR when determining section's
	VMA. Adjust error message. Fold data statement's expr.
	(lang_size_sections): Correctly increment lang_statement_iteration.

	* ld-scripts/provide.exp: New.
	* ld-scripts/provide-{1,2,3}.{s,t,d}.exp: New.

	* ldexp.c (fold_tree): Follow indirect symbols.
@
text
@d104 1
d268 19
d291 1
d293 1
d296 2
a297 1
	      if (exp_data_seg.phase == exp_dataseg_align_seen)
d418 1
d424 11
a434 1
		  if (exp_data_seg.phase != exp_dataseg_adjust)
d442 1
@


1.28
log
@	* ldgram.y (exp): Add two operand ALIGN.
	* ldexp.c (fold_binary): Add ALIGN_K case.
	* ld.texinfo (ALIGN): Document two operand version.
	* ld-scripts/align.{s,t,exp}: New.
@
text
@a143 11
static void
check (lang_output_section_statement_type *os,
       const char *name,
       const char *op)
{
  if (os == NULL)
    einfo (_("%F%P: %s uses undefined section %s\n"), op, name);
  if (! os->processed)
    einfo (_("%F%P: %s forward reference of section %s\n"), op, name);
}

a451 8
etree_value_type
invalid (void)
{
  etree_value_type new;
  new.valid_p = FALSE;
  return new;
}

d460 2
d466 2
a467 8
	{
	  result = new_abs (bfd_sizeof_headers (output_bfd,
						link_info.relocatable));
	}
      else
	{
	  result.valid_p = FALSE;
	}
d471 1
a471 4
	{
	  lang_track_definedness (tree->name.name);
	  result.valid_p = FALSE;
	}
a491 1
      result.valid_p = FALSE;
a495 2
	  else
	    result = invalid ();
d503 5
a507 4
					    FALSE, FALSE, TRUE);
	  if (h != NULL
	      && (h->type == bfd_link_hash_defined
		  || h->type == bfd_link_hash_defweak))
d540 6
d555 2
a556 2
	  check (os, tree->name.name, "ADDR");
	  result = new_rel (0, NULL, os);
a557 2
      else
	result = invalid ();
d566 9
a574 7
	  check (os, tree->name.name, "LOADADDR");
	  if (os->load_base == NULL)
	    result = new_rel (0, NULL, os);
	  else
	    result = exp_fold_tree_no_dot (os->load_base,
					   abs_output_section,
					   allocation_done);
a575 2
      else
	result = invalid ();
d585 2
a586 2
	  check (os, tree->name.name, "SIZEOF");
	  result = new_abs (os->bfd_section->_raw_size / opb);
a587 2
      else
	result = invalid ();
d710 1
a710 1
					create, FALSE, FALSE);
d713 1
a713 1
		  if (tree->type.node_class == etree_assign)
d718 1
@


1.27
log
@	* ldexp.c (align_n): Make static.
	* ldexp.h (align_n): Delete declaration.
	* ldlang.h (lang_enter_output_section_statement): Remove
	block_value param.
	* ldlang.c (lang_enter_output_section_statement): Likewise.
	(TO_ADDR, TO_SIZE): Define.
	(opb): New var.
	(init_opb): New function.
	(print_input_section): Call init_opb and use TO_ADDR.
	(print_data_statement, print_reloc_statement): Likewise.
	(print_padding_statement): Likewise.
	(size_input_section): Use TO_SIZE and TO_ADDR, and global opb.
	(lang_check_section_addresses): Likewise.
	(lang_size_sections_1): Likewise.
	(lang_do_assignments_1): Likewise.
	(lang_set_startof): Likewise.
	(lang_one_common): Likewise.  Combine power_of_two and opb alignment.
	(lang_process): Call init_opb.
	(lang_abs_symbol_at_end_of): Use TO_ADDR and global opb.
	(lang_enter_overlay_section): Adjust
	lang_enter_output_section_statement call.
	* ldgram.y: Likewise.
	* mri.c (mri_draw_tree): Likewise.
	* emultempl/elf32.em (gld${EMULATION_NAME}_place_orphan): Likewise.
	* emultempl/mmo.em (mmo_place_orphan): Likewise.
	* emultempl/pe.em (gld${EMULATION_NAME}_place_orphan): Likewise.
@
text
@d397 4
@


1.27.6.1
log
@	* ldgram.y (exp): Add two operand ALIGN.
	* ldexp.c (fold_binary): Add ALIGN_K case.
	* ld.texinfo (ALIGN): Document two operand version.
	* ld-scripts/align.{s,t,exp}: New.
@
text
@a396 4
	    case ALIGN_K:
	      result.value = align_n (result.value, other.value);
	      break;
	      
@


1.27.6.2
log
@	* ldlang.h (struct lang_output_section_state): Change processed
	field's type.
	* ldexp.c (check, invalid): Remove.
	(fold_name): Move valid_p assignments. Create undefined symbol
	when needed. Directly exampine section's processd flag.
	* ldlang.c (lang_output_section_statement_lookup): Adjust
	processed field init.
	(lang_size_sections_1): Allow LOADADDR when determining section's
	VMA. Adjust error message. Fold data statement's expr.
	(lang_size_sections): Correctly increment lang_statement_iteration.

	* ld-scripts/provide.exp: New.
	* ld-scripts/provide-{1,2,3}.{s,t,d}.exp: New.

	* ldexp.c (fold_tree): Follow indirect symbols.
@
text
@d144 11
d463 8
a478 2
  result.valid_p = FALSE;
  
d483 8
a490 2
	result = new_abs (bfd_sizeof_headers (output_bfd,
					      link_info.relocatable));
d494 4
a497 1
	lang_track_definedness (tree->name.name);
d518 1
d523 2
d532 4
a535 5
					    TRUE, FALSE, TRUE);
	  if (!h)
	    einfo (_("%P%F: bfd_link_hash_lookup failed: %E\n"));
	  else if (h->type == bfd_link_hash_defined
		   || h->type == bfd_link_hash_defweak)
a567 6
	  else if (h->type == bfd_link_hash_new)
	    {
	      h->type = bfd_link_hash_undefined;
	      h->u.undef.abfd = NULL;
	      bfd_link_add_undef (link_info.hash, h);
	    }
d577 2
a578 2
	  if (os && os->processed > 0)
	    result = new_rel (0, NULL, os);
d580 2
d590 7
a596 9
	  if (os && os->processed != 0)
	    {
	      if (os->load_base == NULL)
		result = new_rel (0, NULL, os);
	      else
		result = exp_fold_tree_no_dot (os->load_base,
					       abs_output_section,
					       allocation_done);
	    }
d598 2
d609 2
a610 2
	  if (os && os->processed > 0)
	    result = new_abs (os->bfd_section->_raw_size / opb);
d612 2
d736 1
a736 1
					create, FALSE, TRUE);
d739 1
a739 1
		  if (create)
a743 1
		       && h->type != bfd_link_hash_new
@


1.26
log
@	* ld.texinfo (Builtin Functions) <DEFINED>: Say that only symbols
	defined before the statement using DEFINED yield 1.
	* ldexp.c (fold_name) <case DEFINED>: In lang_first_phase_enum,
	call lang_track_definedness on symbol.  In subsequent phases, use
	lang_symbol_definition_iteration and lang_statement_iteration to
	check whether the symbol was defined before the current statement.
	(exp_fold_tree) <case etree_assign et al>: Call
	lang_update_definedness before updating symbol type when setting
	symbol.
	* ldlang.c (lang_definedness_table): New variable.
	(lang_definedness_newfunc, lang_track_definedness)
	(lang_symbol_definition_iteration, lang_update_definedness): New
	functions.
	(lang_init): Initialize lang_definedness_table and
	lang_statement_iteration.
	(lang_finish): Destroy bfd_hash_table_free.
	(lang_size_sections): Increment lang_statement_iteration.
	(lang_do_assignments_1): New function with former
	lang_do_assignments contents.  Change recursive calls to call this
	function.
	(lang_do_assignments): Evacuate contents.  Increment
	lang_statement_iteration, then just call lang_do_assignments_1.
	* ldlang.h (struct lang_definedness_hash_entry)
	(lang_statement_iteration, lang_track_definedness)
	(lang_symbol_definition_iteration, lang_update_definedness):
	Declare.
@
text
@d3 1
a3 1
   2001, 2002, 2003
d46 2
d1104 2
a1105 1
bfd_vma align_n (bfd_vma value, bfd_vma align)
@


1.25
log
@	* ldexp.c (fold_name) <case DEFINED>: Set section of result to
	abs_output_section.
@
text
@d488 4
a491 1
	result.valid_p = FALSE;
d495 2
d504 3
a506 1
			      || h->type == bfd_link_hash_common));
d748 1
@


1.24
log
@Convert to C90
@
text
@d500 1
a500 1
	  result.section = 0;
@


1.23
log
@Correct spelling of "relocatable".
@
text
@a43 33
static void exp_print_token
  PARAMS ((token_code_type code, int infix_p));
static void make_abs
  PARAMS ((etree_value_type *ptr));
static etree_value_type new_abs
  PARAMS ((bfd_vma value));
static void check
  PARAMS ((lang_output_section_statement_type *os, const char *name,
	   const char *op));
static etree_value_type new_rel
  PARAMS ((bfd_vma, char *, lang_output_section_statement_type *section));
static etree_value_type new_rel_from_section
  PARAMS ((bfd_vma value, lang_output_section_statement_type *section));
static etree_value_type fold_unary
  PARAMS ((etree_type *tree,
	   lang_output_section_statement_type *current_section,
	   lang_phase_type allocation_done,
	   bfd_vma dot, bfd_vma *dotp));
static etree_value_type fold_binary
  PARAMS ((etree_type *tree,
	   lang_output_section_statement_type *current_section,
	   lang_phase_type allocation_done,
	   bfd_vma dot, bfd_vma *dotp));
static etree_value_type fold_trinary
  PARAMS ((etree_type *tree,
	   lang_output_section_statement_type *current_section,
	   lang_phase_type allocation_done,
	   bfd_vma dot, bfd_vma *dotp));
static etree_value_type fold_name
  PARAMS ((etree_type *tree,
	   lang_output_section_statement_type *current_section,
	   lang_phase_type allocation_done,
	   bfd_vma dot));
d45 1
a45 3
  PARAMS ((etree_type *tree,
	   lang_output_section_statement_type *current_section,
	   lang_phase_type allocation_done));
d53 1
a53 3
exp_print_token (code, infix_p)
     token_code_type code;
     int infix_p;
d125 1
a125 2
make_abs (ptr)
     etree_value_type *ptr;
d133 1
a133 2
new_abs (value)
     bfd_vma value;
d143 3
a145 4
check (os, name, op)
     lang_output_section_statement_type *os;
     const char *name;
     const char *op;
d154 1
a154 2
exp_intop (value)
     bfd_vma value;
d156 1
a156 1
  etree_type *new = (etree_type *) stat_alloc (sizeof (new->value));
d165 1
a165 3
exp_bigintop (value, str)
     bfd_vma value;
     char *str;
d167 1
a167 1
  etree_type *new = (etree_type *) stat_alloc (sizeof (new->value));
d178 1
a178 3
exp_relop (section, value)
     asection *section;
     bfd_vma value;
d180 1
a180 1
  etree_type *new = (etree_type *) stat_alloc (sizeof (new->rel));
d189 3
a191 4
new_rel (value, str, section)
     bfd_vma value;
     char *str;
     lang_output_section_statement_type *section;
d202 2
a203 3
new_rel_from_section (value, section)
     bfd_vma value;
     lang_output_section_statement_type *section;
d217 5
a221 6
fold_unary (tree, current_section, allocation_done, dot, dotp)
     etree_type *tree;
     lang_output_section_statement_type *current_section;
     lang_phase_type allocation_done;
     bfd_vma dot;
     bfd_vma *dotp;
d303 5
a307 6
fold_binary (tree, current_section, allocation_done, dot, dotp)
     etree_type *tree;
     lang_output_section_statement_type *current_section;
     lang_phase_type allocation_done;
     bfd_vma dot;
     bfd_vma *dotp;
d437 5
a441 6
fold_trinary (tree, current_section, allocation_done, dot, dotp)
     etree_type *tree;
     lang_output_section_statement_type *current_section;
     lang_phase_type allocation_done;
     bfd_vma dot;
     bfd_vma *dotp;
d458 1
a458 1
invalid ()
d466 4
a469 5
fold_name (tree, current_section, allocation_done, dot)
     etree_type *tree;
     lang_output_section_statement_type *current_section;
     lang_phase_type allocation_done;
     bfd_vma dot;
d478 1
a478 2
	  result = new_abs ((bfd_vma)
			    bfd_sizeof_headers (output_bfd,
d496 1
a496 1
	  result.value = (h != (struct bfd_link_hash_entry *) NULL
d612 5
a616 6
exp_fold_tree (tree, current_section, allocation_done, dot, dotp)
     etree_type *tree;
     lang_output_section_statement_type *current_section;
     lang_phase_type allocation_done;
     bfd_vma dot;
     bfd_vma *dotp;
d724 1
a724 1
	      if (h == (struct bfd_link_hash_entry *) NULL)
d764 3
a766 4
exp_fold_tree_no_dot (tree, current_section, allocation_done)
     etree_type *tree;
     lang_output_section_statement_type *current_section;
     lang_phase_type allocation_done;
d768 1
a768 2
  return exp_fold_tree (tree, current_section, allocation_done,
			(bfd_vma) 0, (bfd_vma *) NULL);
d772 1
a772 4
exp_binop (code, lhs, rhs)
     int code;
     etree_type *lhs;
     etree_type *rhs;
d788 2
a789 2
  new = (etree_type *) stat_alloc (sizeof (new->binary));
  memcpy ((char *) new, (char *) &value, sizeof (new->binary));
d794 1
a794 5
exp_trinop (code, cond, lhs, rhs)
     int code;
     etree_type *cond;
     etree_type *lhs;
     etree_type *rhs;
d803 1
a803 3
  r = exp_fold_tree_no_dot (&value,
			    (lang_output_section_statement_type *) NULL,
			    lang_first_phase_enum);
d807 2
a808 2
  new = (etree_type *) stat_alloc (sizeof (new->trinary));
  memcpy ((char *) new, (char *) &value, sizeof (new->trinary));
d813 1
a813 3
exp_unop (code, child)
     int code;
     etree_type *child;
d826 2
a827 2
  new = (etree_type *) stat_alloc (sizeof (new->unary));
  memcpy ((char *) new, (char *) &value, sizeof (new->unary));
d832 1
a832 3
exp_nameop (code, name)
     int code;
     const char *name;
d840 1
a840 3
  r = exp_fold_tree_no_dot (&value,
			    (lang_output_section_statement_type *) NULL,
			    lang_first_phase_enum);
d844 2
a845 2
  new = (etree_type *) stat_alloc (sizeof (new->name));
  memcpy ((char *) new, (char *) &value, sizeof (new->name));
d851 1
a851 4
exp_assop (code, dst, src)
     int code;
     const char *dst;
     etree_type *src;
d865 2
a866 2
  new = (etree_type *) stat_alloc (sizeof (new->assign));
  memcpy ((char *) new, (char *) &value, sizeof (new->assign));
d873 1
a873 3
exp_provide (dst, src)
     const char *dst;
     etree_type *src;
d877 1
a877 1
  n = (etree_type *) stat_alloc (sizeof (n->assign));
d888 1
a888 3
exp_assert (exp, message)
     etree_type *exp;
     const char *message;
d892 1
a892 1
  n = (etree_type *) stat_alloc (sizeof (n->assert_s));
d901 1
a901 2
exp_print_tree (tree)
     etree_type *tree;
d924 1
a924 1
      if (tree->assign.dst->sdefs != (asymbol *) NULL)
d992 4
a995 5
exp_get_vma (tree, def, name, allocation_done)
     etree_type *tree;
     bfd_vma def;
     char *name;
     lang_phase_type allocation_done;
d1011 4
a1014 5
exp_get_value_int (tree, def, name, allocation_done)
     etree_type *tree;
     int def;
     char *name;
     lang_phase_type allocation_done;
d1016 1
a1016 1
  return (int) exp_get_vma (tree, (bfd_vma) def, name, allocation_done);
d1020 4
a1023 5
exp_get_fill (tree, def, name, allocation_done)
     etree_type *tree;
     fill_type *def;
     char *name;
     lang_phase_type allocation_done;
d1041 1
a1041 1
      fill = (fill_type *) xmalloc ((len + 1) / 2 + sizeof (*fill) - 1);
d1066 1
a1066 1
      fill = (fill_type *) xmalloc (4 + sizeof (*fill) - 1);
d1078 4
a1081 5
exp_get_abs_int (tree, def, name, allocation_done)
     etree_type *tree;
     int def ATTRIBUTE_UNUSED;
     char *name;
     lang_phase_type allocation_done;
d1094 1
a1094 3
bfd_vma align_n (value, align)
     bfd_vma value;
     bfd_vma align;
@


1.22
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d3 1
a3 1
   2001, 2002
d137 1
a137 1
    { REL, "relocateable" },
d218 1
a218 1
/* Build an expression representing an unnamed relocateable value.  */
d531 1
a531 1
						link_info.relocateable));
@


1.21
log
@	* emultempl/aix.em: Use include <> for generated headers.
	* emultempl/beos.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/pe.em: Likewise.
	* ldctor.c: Likewise.
	* ldexp.c: Likewise.
	* ldfile.c: Likewise.
	* ldlang.c: Likewise.
	* ldlex.c: Likewise.
	* ldlex.l: Likewise.
	* ldmain.c: Likewise.
	* ldmisc.c: Likewise.
	* ldwrite.c: Likewise.
	* lexsup.c: Likewise.
	* mri.c: Likewise.
	* pe-dll.c: Likewise.
@
text
@d44 9
a52 5
static void exp_print_token PARAMS ((token_code_type code, int infix_p));
static void make_abs PARAMS ((etree_value_type *ptr));
static etree_value_type new_abs PARAMS ((bfd_vma value));
static void check PARAMS ((lang_output_section_statement_type *os,
			   const char *name, const char *op));
d85 1
a85 1
   with spaces if INFIX_P is true.  */
d175 1
a175 1
  new.valid_p = true;
d240 1
a240 1
  new.valid_p = true;
d253 1
a253 1
  new.valid_p = true;
d285 1
a285 1
	    result.valid_p = false;
d295 1
a295 1
	    result.valid_p = false;
d321 1
a321 1
	    result.valid_p = false;
d338 1
a338 1
	    result.valid_p = false;
d469 1
a469 1
		result.valid_p = false;
d478 1
a478 1
	  result.valid_p = false;
d511 1
a511 1
  new.valid_p = false;
d535 1
a535 1
	  result.valid_p = false;
d540 1
a540 1
	result.valid_p = false;
d547 1
a547 1
					    false, false, true);
d553 1
a553 1
	  result.valid_p = true;
d557 1
a557 1
      result.valid_p = false;
d571 1
a571 1
					    false, false, true);
d675 1
a675 1
      result.valid_p = false;
d687 1
a687 1
	result.valid_p = false;
d768 1
a768 1
	      boolean create;
d772 1
a772 1
		create = true;
d774 1
a774 1
		create = false;
d776 1
a776 1
					create, false, false);
d1009 1
a1009 1
      exp_print_token (tree->type.node_code, true);
d1021 1
a1021 1
      exp_print_token (tree->type.node_code, true);
d1033 1
a1033 1
      exp_print_token (tree->unary.type.node_code, false);
d1058 1
a1058 1
	  exp_print_token (tree->type.node_code, false);
@


1.20
log
@	* ldexp.c (fold_unary): New.  Split out from exp_fold_tree.
	(fold_binary): Correct abs - non-abs case.
	(fold_trinary): New.  Split out from exp_fold_tree.
@
text
@d39 1
a39 1
#include "ldgram.h"
@


1.19
log
@Add EXTERN references to __ctbpm __gp and __ep.
Define TEMPLATE_NAME.
Revert bogus change to ldexp.c
@
text
@d53 5
d63 5
d260 87
a378 4
	      etree_value_type hold;

	      /* If there is only one absolute term, make sure it is the
		 second one.  */
d381 6
a386 3
		  hold = result;
		  result = other;
		  other = hold;
d481 22
d705 2
a706 84
      result = exp_fold_tree (tree->unary.child,
			      current_section,
			      allocation_done, dot, dotp);
      if (result.valid_p)
	{
	  switch (tree->type.node_code)
	    {
	    case ALIGN_K:
	      if (allocation_done != lang_first_phase_enum)
		result = new_rel_from_section (align_n (dot, result.value),
					       current_section);
	      else
		result.valid_p = false;
	      break;

	    case ABSOLUTE:
	      if (allocation_done != lang_first_phase_enum)
		{
		  result.value += result.section->bfd_section->vma;
		  result.section = abs_output_section;
		}
	      else
		result.valid_p = false;
	      break;

	    case '~':
	      make_abs (&result);
	      result.value = ~result.value;
	      break;

	    case '!':
	      make_abs (&result);
	      result.value = !result.value;
	      break;

	    case '-':
	      make_abs (&result);
	      result.value = -result.value;
	      break;

	    case NEXT:
	      /* Return next place aligned to value.  */
	      if (allocation_done == lang_allocating_phase_enum)
		{
		  make_abs (&result);
		  result.value = align_n (dot, result.value);
		}
	      else
		result.valid_p = false;
	      break;

	    case DATA_SEGMENT_END:
	      if (allocation_done != lang_first_phase_enum
		  && current_section == abs_output_section
		  && (exp_data_seg.phase == exp_dataseg_align_seen
		      || exp_data_seg.phase == exp_dataseg_adjust
		      || allocation_done != lang_allocating_phase_enum))
		{
		  if (exp_data_seg.phase == exp_dataseg_align_seen)
		    {
		      exp_data_seg.phase = exp_dataseg_end_seen;
		      exp_data_seg.end = result.value;
		    }
		}
	      else
		result.valid_p = false;
	      break;

	    default:
	      FAIL ();
	      break;
	    }
	}
      break;

    case etree_trinary:
      result = exp_fold_tree (tree->trinary.cond, current_section,
			      allocation_done, dot, dotp);
      if (result.valid_p)
	result = exp_fold_tree ((result.value
				 ? tree->trinary.lhs
				 : tree->trinary.rhs),
				current_section,
				allocation_done, dot, dotp);
d712 5
@


1.18
log
@Fix PROVIDE
@
text
@d729 1
a729 1
		create = false;	      
a731 8
	      
	      if (tree->type.node_class == etree_provide
		  && (h == NULL
		      || h->type == bfd_link_hash_undefined
		      || h->type == bfd_link_hash_common))
		h = bfd_link_hash_lookup (link_info.hash, tree->assign.dst,
					  true, false, false);

d733 12
a744 2
		einfo (_("%P%F:%s: hash creation failed\n"),
		       tree->assign.dst);
@


1.17
log
@	* emulparams/elf32_dlx.sh (TARGET_PAGE_SIZE): Set to 1.
	(MAXPAGESIZE): Set to 1.

	* ld.h (ALIGN_N): Delete.
	* ldexp.h (align_n): Declare.
	* ldexp.c (align_n): New function.
	(fold_binary): Use align_n instead of ALIGN_N.
	(exp_fold_tree): Likewise.
	* ldlang.c (lang_size_sections_1): Likewise.
	(lang_one_common): Likewise.
@
text
@d729 1
a729 1
		create = false;
d732 8
d741 2
a742 12
		{
		  if (tree->type.node_class == etree_assign)
		    einfo (_("%P%F:%s: hash creation failed\n"),
			   tree->assign.dst);
		}
	      else if (tree->type.node_class == etree_provide
		       && h->type != bfd_link_hash_undefined
		       && h->type != bfd_link_hash_common)
		{
		  /* Do nothing.  The symbol was defined by some
		     object.  */
		}
@


1.16
log
@	* ldexp.c: Replace CONST with const.
	* ldfile.c: Likewise.
	* ldfile.h: Likewise.
	* ldlex.l: Likewise.
	* mri.c: Likewise.
	* pe-dll.h: Likewise.
@
text
@d353 1
a353 1
		  result.value = ALIGN_N (dot, maxpage);
d596 1
a596 1
		result = new_rel_from_section (ALIGN_N (dot, result.value),
d603 1
a603 1
	      if (allocation_done != lang_first_phase_enum && result.valid_p)
d632 1
a632 1
		  result.value = ALIGN_N (dot, result.value);
d1129 11
@


1.16.2.1
log
@	* emulparams/elf32_dlx.sh (TARGET_PAGE_SIZE): Set to 1.
	(MAXPAGESIZE): Set to 1.

	* ld.h (ALIGN_N): Delete.
	* ldexp.h (align_n): Declare.
	* ldexp.c (align_n): New function.
	(fold_binary): Use align_n instead of ALIGN_N.
	(exp_fold_tree): Likewise.
	* ldlang.c (lang_size_sections_1): Likewise.
	(lang_one_common): Likewise.
@
text
@d353 1
a353 1
		  result.value = align_n (dot, maxpage);
d596 1
a596 1
		result = new_rel_from_section (align_n (dot, result.value),
d603 1
a603 1
	      if (allocation_done != lang_first_phase_enum)
d632 1
a632 1
		  result.value = align_n (dot, result.value);
a1128 11
}

bfd_vma align_n (value, align)
     bfd_vma value;
     bfd_vma align;
{
  if (align <= 1)
    return value;

  value = (value + align - 1) / align;
  return value * align;
@


1.16.2.2
log
@	* ldexp.c (fold_unary): New.  Split out from exp_fold_tree.
	(fold_binary): Correct abs - non-abs case.
	(fold_trinary): New.  Split out from exp_fold_tree.
@
text
@a52 5
static etree_value_type fold_unary
  PARAMS ((etree_type *tree,
	   lang_output_section_statement_type *current_section,
	   lang_phase_type allocation_done,
	   bfd_vma dot, bfd_vma *dotp));
a57 5
static etree_value_type fold_trinary
  PARAMS ((etree_type *tree,
	   lang_output_section_statement_type *current_section,
	   lang_phase_type allocation_done,
	   bfd_vma dot, bfd_vma *dotp));
a249 87
fold_unary (tree, current_section, allocation_done, dot, dotp)
     etree_type *tree;
     lang_output_section_statement_type *current_section;
     lang_phase_type allocation_done;
     bfd_vma dot;
     bfd_vma *dotp;
{
  etree_value_type result;

  result = exp_fold_tree (tree->unary.child,
			  current_section,
			  allocation_done, dot, dotp);
  if (result.valid_p)
    {
      switch (tree->type.node_code)
	{
	case ALIGN_K:
	  if (allocation_done != lang_first_phase_enum)
	    result = new_rel_from_section (align_n (dot, result.value),
					   current_section);
	  else
	    result.valid_p = false;
	  break;

	case ABSOLUTE:
	  if (allocation_done != lang_first_phase_enum)
	    {
	      result.value += result.section->bfd_section->vma;
	      result.section = abs_output_section;
	    }
	  else
	    result.valid_p = false;
	  break;

	case '~':
	  make_abs (&result);
	  result.value = ~result.value;
	  break;

	case '!':
	  make_abs (&result);
	  result.value = !result.value;
	  break;

	case '-':
	  make_abs (&result);
	  result.value = -result.value;
	  break;

	case NEXT:
	  /* Return next place aligned to value.  */
	  if (allocation_done == lang_allocating_phase_enum)
	    {
	      make_abs (&result);
	      result.value = align_n (dot, result.value);
	    }
	  else
	    result.valid_p = false;
	  break;

	case DATA_SEGMENT_END:
	  if (allocation_done != lang_first_phase_enum
	      && current_section == abs_output_section
	      && (exp_data_seg.phase == exp_dataseg_align_seen
		  || exp_data_seg.phase == exp_dataseg_adjust
		  || allocation_done != lang_allocating_phase_enum))
	    {
	      if (exp_data_seg.phase == exp_dataseg_align_seen)
		{
		  exp_data_seg.phase = exp_dataseg_end_seen;
		  exp_data_seg.end = result.value;
		}
	    }
	  else
	    result.valid_p = false;
	  break;

	default:
	  FAIL ();
	  break;
	}
    }

  return result;
}

static etree_value_type
d282 4
d288 3
a290 6
		  /* Keep the section of the other term.  */
		  if (tree->type.node_code == '+')
		    other.value = result.value + other.value;
		  else
		    other.value = result.value - other.value;
		  return other;
a384 22
static etree_value_type
fold_trinary (tree, current_section, allocation_done, dot, dotp)
     etree_type *tree;
     lang_output_section_statement_type *current_section;
     lang_phase_type allocation_done;
     bfd_vma dot;
     bfd_vma *dotp;
{
  etree_value_type result;

  result = exp_fold_tree (tree->trinary.cond, current_section,
			  allocation_done, dot, dotp);
  if (result.valid_p)
    result = exp_fold_tree ((result.value
			     ? tree->trinary.lhs
			     : tree->trinary.rhs),
			    current_section,
			    allocation_done, dot, dotp);

  return result;
}

d587 84
a670 2
      result = fold_unary (tree, current_section, allocation_done,
			   dot, dotp);
a675 5
      break;

    case etree_trinary:
      result = fold_trinary (tree, current_section, allocation_done,
			     dot, dotp);
@


1.16.2.3
log
@        * emultempl/aix.em: Use include <> for generated headers.
        * emultempl/beos.em: Likewise.
        * emultempl/elf32.em: Likewise.
        * emultempl/pe.em: Likewise.
        * ldctor.c: Likewise.
        * ldexp.c: Likewise.
        * ldfile.c: Likewise.
        * ldlang.c: Likewise.
        * ldlex.c: Likewise.
        * ldlex.l: Likewise.
        * ldmain.c: Likewise.
        * ldmisc.c: Likewise.
        * ldwrite.c: Likewise.
        * lexsup.c: Likewise.
        * mri.c: Likewise.
        * pe-dll.c: Likewise.
@
text
@d39 1
a39 1
#include <ldgram.h>
@


1.15
log
@	* ld.h: Fix formatting.
	* ldexp.c: Likewise.
	* ldfile.c: Likewise.
	* ldlang.c: Likewise.
	* ldmain.c: Likewise.
	* lexsup.c: Likewise.
	* pe-dll.c: Likewise.
@
text
@d78 1
a78 1
  static CONST struct
d855 1
a855 1
     CONST char *name;
d878 1
a878 1
     CONST char *dst;
@


1.14
log
@	* ldlang.c (print_assignment): Update print_dot for assignments to ".".
	* ldexp.c (exp_print_token): Add "infix_p" argument.
	(exp_print_tree): Update accordingly.
@
text
@d938 1
a938 1
  
d944 1
a944 1
  
@


1.13
log
@	* ldexp.c (fold_binary) [DATA_SEGMENT_ALIGN]: If common page size
	is smaller than maximum, round dot up to common page boundary.
@
text
@d44 1
a44 1
static void exp_print_token PARAMS ((token_code_type code));
d70 3
d74 1
a74 1
exp_print_token (code)
d76 1
d129 6
a134 8
  for (idx = ARRAY_SIZE (table); idx--;)
    {
      if (table[idx].code == code)
	{
	  fprintf (config.map_file, " %s ", table[idx].name);
	  return;
	}
    }
d136 4
a139 3
  /* Not in table, just print it alone.  */
  if (code < 127)
    fprintf (config.map_file, " %c ", code);
d141 4
a144 1
    fprintf (config.map_file, " <code %d> ", code);
d964 1
a964 1
      exp_print_token (tree->type.node_code);
d976 1
a976 1
      exp_print_token (tree->type.node_code);
d988 1
a988 1
      exp_print_token (tree->unary.type.node_code);
d991 1
a991 1
	  fprintf (config.map_file, "(");
d1013 1
a1013 1
	  exp_print_token (tree->type.node_code);
d1015 1
a1015 1
	    fprintf (config.map_file, "(%s)", tree->name.name);
@


1.12
log
@	Support arbitrary length fill patterns.
	* ldexp.h (etree_value_type): Add "str" field.
	(union etree_union): Add "str" to "value" struct.
	(exp_bigintop): Declare.
	(exp_get_fill): Declare.
	* ldexp.c: Include "safe-ctype.h".
	(exp_intop): Set value.str to NULL.
	(exp_bigintop): New function.
	(new_rel): Pass in "str", and set new.str from it.
	(new_rel_from_section): Set new.str to NULL.
	(fold_name): Adjust calls to new_rel.
	(exp_fold_tree): Likewise.
	(exp_get_fill): New function.
	* ldgram.y (struct big_int bigint, fill_type *fill): New.
	(INT): Returns a "bigint".  Adjust all code handling INTs.
	(fill_opt): Returns a "fill".
	(fill_exp): Split out of fill_opt, use for FILL.
	* ldlang.h (struct _fill_type): New.
	(fill_type): Move typedef to ldexp.h.
	(lang_output_section_statement_type): "fill" is now a pointer.
	(lang_fill_statement_type): Likewise.
	(lang_padding_statement_type): Likewise.
	(lang_add_fill): Now takes a "fill_type *" param.
	(lang_leave_output_section_statement): Likewise.
	(lang_do_assignments): Likewise.
	(lang_size_sections): Likewise.
	(lang_leave_overlay_section): Likewise.
	(lang_leave_overlay): Likewise.
	* ldlang.c: Include ldgram.h after ldexp.h.
	(lang_output_section_statement_lookup): Adjust for fill_type change.
	(print_fill_statement): Likewise.
	(print_padding_statement): Likewise.
	(insert_pad): Now takes a "fill_type *" arg.
	(size_input_section): Likewise.
	(lang_size_sections_1): Likewise.
	(lang_size_sections): Likewise.
	(lang_do_assignments): Likewise.
	(lang_add_fill): Likewise.
	(lang_leave_output_section_statement): Likewise.
	(lang_leave_overlay_section): Likewise.
	(lang_leave_overlay): Likewise.
	Adjust all callers of the above function.
	* ldlex.l: Include ldgram.h after ldexp.h.  Allow hex numbers
	starting with "0X" as well as "0x".  Return bigint.str for hex
	numbers starting with "0x" or "0X", zero bigint.str otherwise.
	Always use base 16 for numbers starting with "$".
	* ldmain.c: Include ldgram.h after ldexp.h.
	* ldwrite.c (build_link_order): Use bfd_data_link_order in place
	of bfd_fill_link_order.
	* pe-dll.c: Adjust lang_do_assignments calls.
	* emultempl/elf32.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/beos.em: Include ldgram.h after ldexp.h, adjust
	lang_add_assignment call.
	* emultempl/pe.em: Likewise.
@
text
@d359 2
a360 1
		    result.value += dot & (maxpage - other.value);
@


1.11
log
@	* ldlex.l (DATA_SEGMENT_ALIGN, DATA_SEGMENT_END): New tokens.
	* ldgram.y (DATA_SEGMENT_ALIGN, DATA_SEGMENT_END): New tokens.
	(exp): Add DATA_SEGMENT_ALIGN (exp, exp) and DATA_SEGMENT_END (exp).
	* ldexp.c (exp_data_seg): New variable.
	(exp_print_token): Handle DATA_SEGMENT_ALIGN and DATA_SEGMENT_END.
	(fold_binary): Handle DATA_SEGMENT_ALIGN.
	(exp_fold_tree): Handle DATA_SEGMENT_END.
	Pass allocation_done when recursing instead of hardcoding
	lang_allocating_phase_enum.
	* ldexp.h (exp_data_seg): New.
	* ldlang.c (lang_size_sections_1): Renamed from lang_size_sections.
	(lang_size_sections): New.
	* ld.texinfo (DATA_SEGMENT_ALIGN, DATA_SEGMENT_END): Document.
	* scripttempl/elf.sc: Use DATA_SEGMENT_ALIGN and DATA_SEGMENT_END
	if COMMONPAGESIZE is defined.
	* emulparams/elf_i386.sh (COMMONPAGESIZE): Set to 4K.
	* emulparams/elf32_sparc.sh (COMMONPAGESIZE): Set to 8K.
	* emulparams/elf64_sparc.sh (COMMONPAGESIZE): Set to 8K.
	* emulparams/elf64alpha.sh (COMMONPAGESIZE): Set to 8K.
	* emulparams/elf64_ia64.sh (COMMONPAGESIZE): Set to 16K for shared
	libraries only.
@
text
@d3 1
a3 1
   2001
d42 1
d50 1
a50 1
  PARAMS ((bfd_vma value, lang_output_section_statement_type *section));
d180 1
d183 1
d185 11
d214 1
a214 1
new_rel (value, section)
d216 1
d222 1
d235 1
d470 1
d488 1
a488 1
	  result = new_rel (0, os);
d502 1
a502 1
	    result = new_rel (0, os);
d553 1
a553 1
      result = new_rel (tree->value.value, current_section);
d563 1
d1045 59
@


1.10
log
@	* ldexp.c (exp_print_token): Correct "table" entry for RSHIFT.
@
text
@d67 2
d119 2
d321 27
d612 17
d666 1
a666 1
				      lang_allocating_phase_enum, dot,
@


1.9
log
@Use stderr if config.map_file is not available.  Do not print NULL trees.
@
text
@d95 1
a95 1
    { RSHIFT, ">>=" },
@


1.8
log
@Fixtypos in ChangeLogs, fix copyright dates in files
@
text
@d41 1
d71 2
a72 1
  static CONST struct {
d74 4
a77 2
    char *name;
  } table[] = {
a78 1
    { REL, "relocateable" },
d98 5
a104 4
    { NEXT, "NEXT" },
    { SIZEOF, "SIZEOF" },
    { ADDR, "ADDR" },
    { LOADADDR, "LOADADDR" },
a109 5
    { QUAD, "QUAD" },
    { SQUAD, "SQUAD" },
    { LONG, "LONG" },
    { SHORT, "SHORT" },
    { BYTE, "BYTE" },
d111 6
a116 1
    { 0, (char *) NULL }
d120 1
a120 1
  for (idx = 0; table[idx].name != (char *) NULL; idx++)
d124 1
a124 1
	  fprintf (config.map_file, "%s", table[idx].name);
d128 6
a133 2
  /* Not in table, just print it alone */
  fprintf (config.map_file, "%c", code);
d346 1
d609 1
a609 1
	  /* Assignment to dot can only be done during allocation */
d634 2
a635 4
			{
			  einfo (_("%F%S cannot move location counter backwards (from %V to %V)\n"),
				 dot, nextdot);
			}
d750 2
a751 3
    {
      return exp_intop (r.value);
    }
d771 2
a772 3
    {
      return exp_intop (r.value);
    }
d793 2
a794 3
    {
      return exp_intop (r.value);
    }
d817 1
a817 3
    {
      return exp_intop (result);
    }
d862 9
d884 2
a885 4
	{
	  fprintf (config.map_file, "%s (%x) ", tree->assign.dst->name,
		   tree->assign.dst->sdefs->value);
	}
d887 1
a887 3
	{
	  fprintf (config.map_file, "%s (UNDEFINED)", tree->assign.dst->name);
	}
d991 1
a991 3
    {
      res.value += res.section->bfd_section->vma;
    }
d993 2
a994 3
    {
      einfo (_("%F%S non constant expression for %s\n"), name);
    }
@


1.7
log
@2001-02-13  H.J. Lu  <hjl@@gnu.org>

	* ldexp.h (node_type): Add etree_provided.
	* ldexp.c (exp_fold_tree): Handle etree_provided. Set the node
	type to etree_provided if defined by PROVIDE. Allow updating
	for etree_provided.
	(exp_print_tree): Handle etree_provided.
	* mpw-elfmips.c (gldelf32ebmip_find_exp_assignment): Handle
	etree_provided.
@
text
@d2 2
a3 1
   Copyright (C) 1991, 92, 93, 94, 95, 96, 97, 98, 99, 2000
@


1.6
log
@2000-10-09  Kazu Hirata  <kazu@@hxi.com>

	* ldcref.c: Fix formatting.
	* ldctor.h: Likewise.
	* ldemul.c: Likewise.
	* ldemul.h: Likewise.
	* ldexp.c: Likewise.
	* ldexp.h: Likewise.
	* ldfile.c: Likewise.
	* ldfile.h: Likewise.
	* ld.h: Likewise.
	* ldlang.c: Likewise.
	* ldlang.h: Likewise.
	* ldmain.c: Likewise.
@
text
@d596 1
d600 1
a600 1
	  if (tree->type.node_class == etree_provide)
d670 2
d886 1
@


1.6.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001
@


1.6.2.2
log
@Merge from mainline.
@
text
@a596 1
    case etree_provided:
d600 1
a600 1
	  if (tree->type.node_class != etree_assign)
a669 2
		  if (tree->type.node_class == etree_provide)
		    tree->type.node_class = etree_provided;
a883 1
    case etree_provided:
@


1.5
log
@2000-10-03  Kazu Hirata  <kazu@@hxi.com>

	* ldexp.c: Fix formatting.
@
text
@d69 1
a69 2
  static CONST struct
  {
@


1.4
log
@2000-09-29  Kazu Hirata  <kazu@@hxi.com>

	* ldcref.c: Fix formatting.
	* ldctor.c: Likewise.
	* ldemul.c: Likewise.
	* ldexp.c: Likewise.
	* ldfile.c: Likewise.
	* ldlang.c: Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 1991, 92, 93, 94, 95, 96, 97, 98, 1999
d4 1
a4 1
   Written by Steve Chamberlain of Cygnus Support (sac@@cygnus.com).
d23 1
a23 2
/*
This module is in charge of working out the contents of expressions.
d25 4
a28 5
It has to keep track of the relative/absness of a symbol etc. This is
done by keeping all values in a struct (an etree_value_type) which
contains a value, a section to which it is relative and a valid bit.

*/
d70 44
a113 45
    {
      token_code_type code;
      char *name;
    } table[] =
      {
	{ INT,	"int" },
	{ REL, "relocateable" },
	{ NAME,"NAME" },
	{ PLUSEQ,"+=" },
	{ MINUSEQ,"-=" },
	{ MULTEQ,"*=" },
	{ DIVEQ,"/=" },
	{ LSHIFTEQ,"<<=" },
	{ RSHIFTEQ,">>=" },
	{ ANDEQ,"&=" },
	{ OREQ,"|=" },
	{ OROR,"||" },
	{ ANDAND,"&&" },
	{ EQ,"==" },
	{ NE,"!=" },
	{ LE,"<=" },
	{ GE,">=" },
	{ LSHIFT,"<<" },
	{ RSHIFT,">>=" },
	{ ALIGN_K,"ALIGN" },
	{ BLOCK,"BLOCK" },
	{ SECTIONS,"SECTIONS" },
	{ SIZEOF_HEADERS,"SIZEOF_HEADERS" },
	{ NEXT,"NEXT" },
	{ SIZEOF,"SIZEOF" },
	{ ADDR,"ADDR" },
	{ LOADADDR,"LOADADDR" },
	{ MEMORY,"MEMORY" },
	{ DEFINED,"DEFINED" },
	{ TARGET_K,"TARGET" },
	{ SEARCH_DIR,"SEARCH_DIR" },
	{ MAP,"MAP" },
	{ QUAD,"QUAD" },
	{ SQUAD,"SQUAD" },
	{ LONG,"LONG" },
	{ SHORT,"SHORT" },
	{ BYTE,"BYTE" },
	{ ENTRY,"ENTRY" },
	{ 0,(char *)NULL }
      };
d116 7
a122 4
  for (idx = 0; table[idx].name != (char*)NULL; idx++) {
    if (table[idx].code == code) {
      fprintf(config.map_file, "%s", table[idx].name);
      return;
a123 1
  }
d125 1
a125 1
  fprintf(config.map_file, "%c",code);
d132 3
a134 3
    asection *s = ptr->section->bfd_section;
    ptr->value += s->vma;
    ptr->section = abs_output_section;
d164 1
a164 1
  etree_type *new = (etree_type *) stat_alloc(sizeof(new->value));
d209 1
a209 1
    new.value -= section->bfd_section->vma;
d232 1
a232 1
			     allocation_done, dot,dotp) ;
d261 2
a262 2
	      make_abs(&result);
	      make_abs(&other);
d282 16
a297 16
	      BOP('+',+);
	      BOP('*',*);
	      BOP('-',-);
	      BOP(LSHIFT,<<);
	      BOP(RSHIFT,>>);
	      BOP(EQ,==);
	      BOP(NE,!=);
	      BOP('<',<);
	      BOP('>',>);
	      BOP(LE,<=);
	      BOP(GE,>=);
	      BOP('&',&);
	      BOP('^',^);
	      BOP('|',|);
	      BOP(ANDAND,&&);
	      BOP(OROR,||);
d310 1
a310 1
	      FAIL();
d334 1
a334 1
     lang_phase_type  allocation_done;
d339 10
a348 15
      {
      case SIZEOF_HEADERS:
	if (allocation_done != lang_first_phase_enum)
	  {
	    result = new_abs ((bfd_vma)
			      bfd_sizeof_headers (output_bfd,
						  link_info.relocateable));
	  }
	else
	  {
	    result.valid_p = false;
	  }
	break;
      case DEFINED:
	if (allocation_done == lang_first_phase_enum)
d350 4
a353 16
	else
	  {
	    struct bfd_link_hash_entry *h;

	    h = bfd_wrapped_link_hash_lookup (output_bfd, &link_info,
					      tree->name.name,
					      false, false, true);
	    result.value = (h != (struct bfd_link_hash_entry *) NULL
			    && (h->type == bfd_link_hash_defined
				|| h->type == bfd_link_hash_defweak
				|| h->type == bfd_link_hash_common));
	    result.section = 0;
	    result.valid_p = true;
	  }
	break;
      case NAME:
d355 3
a357 55
	if (tree->name.name[0] == '.' && tree->name.name[1] == 0)
	  {
	    if (allocation_done != lang_first_phase_enum)
	      result = new_rel_from_section(dot, current_section);
	    else
	      result = invalid();
	  }
	else if (allocation_done != lang_first_phase_enum)
	  {
	    struct bfd_link_hash_entry *h;

	    h = bfd_wrapped_link_hash_lookup (output_bfd, &link_info,
					      tree->name.name,
					      false, false, true);
	    if (h != NULL
		&& (h->type == bfd_link_hash_defined
		    || h->type == bfd_link_hash_defweak))
	      {
		if (bfd_is_abs_section (h->u.def.section))
		  result = new_abs (h->u.def.value);
		else if (allocation_done == lang_final_phase_enum
			 || allocation_done == lang_allocating_phase_enum)
		  {
		    asection *output_section;

		    output_section = h->u.def.section->output_section;
		    if (output_section == NULL)
		      einfo (_("%X%S: unresolvable symbol `%s' referenced in expression\n"),
			     tree->name.name);
		    else
		      {
			lang_output_section_statement_type *os;

			os = (lang_output_section_statement_lookup
			      (bfd_get_section_name (output_bfd,
						     output_section)));

			/* FIXME: Is this correct if this section is
			   being linked with -R?  */
			result = new_rel ((h->u.def.value
					   + h->u.def.section->output_offset),
					  os);
		      }
		  }
	      }
	    else if (allocation_done == lang_final_phase_enum)
	      einfo (_("%F%S: undefined symbol `%s' referenced in expression\n"),
		     tree->name.name);
	  }
	break;

      case ADDR:
	if (allocation_done != lang_first_phase_enum)
	  {
	    lang_output_section_statement_type *os;
d359 85
a443 2
	    os = lang_output_section_find (tree->name.name);
	    check (os, tree->name.name, "ADDR");
d445 27
a471 41
	  }
	else
	  result = invalid ();
	break;

      case LOADADDR:
	if (allocation_done != lang_first_phase_enum)
	  {
	    lang_output_section_statement_type *os;

	    os = lang_output_section_find (tree->name.name);
	    check (os, tree->name.name, "LOADADDR");
	    if (os->load_base == NULL)
	      result = new_rel (0, os);
	    else
	      result = exp_fold_tree_no_dot (os->load_base,
					     abs_output_section,
					     allocation_done);
	  }
	else
	  result = invalid ();
	break;

      case SIZEOF:
	if (allocation_done != lang_first_phase_enum)
	  {
            int opb = bfd_octets_per_byte (output_bfd);
	    lang_output_section_statement_type *os;

	    os = lang_output_section_find (tree->name.name);
	    check (os, tree->name.name, "SIZEOF");
	    result = new_abs (os->bfd_section->_raw_size / opb);
	  }
	else
	  result = invalid ();
	break;

      default:
	FAIL();
	break;
      }
d475 1
d480 1
a480 1
     lang_phase_type  allocation_done;
d510 2
a511 2
                              current_section,
                              allocation_done, dot, dotp);
d693 2
a694 2
return exp_fold_tree(tree, current_section, allocation_done, (bfd_vma)
		     0, (bfd_vma *)NULL);
d710 3
a712 3
  r = exp_fold_tree_no_dot(&value,
			   abs_output_section,
			   lang_first_phase_enum );
d715 1
a715 1
      return exp_intop(r.value);
d718 1
a718 1
  memcpy((char *)new, (char *)&value, sizeof(new->binary));
d736 7
a742 5
  r= exp_fold_tree_no_dot(&value,  (lang_output_section_statement_type
				    *)NULL,lang_first_phase_enum);
  if (r.valid_p) {
    return exp_intop(r.value);
  }
d744 1
a744 1
  memcpy((char *)new,(char *) &value, sizeof(new->trinary));
d759 6
a764 5
  r = exp_fold_tree_no_dot(&value,abs_output_section,
			   lang_first_phase_enum);
  if (r.valid_p) {
    return exp_intop(r.value);
  }
d766 1
a766 1
  memcpy((char *)new, (char *)&value, sizeof(new->unary));
d781 7
a787 6
  r = exp_fold_tree_no_dot(&value,
			   (lang_output_section_statement_type *)NULL,
			   lang_first_phase_enum);
  if (r.valid_p) {
    return exp_intop(r.value);
  }
d789 1
a789 1
  memcpy((char *)new, (char *)&value, sizeof(new->name));
d809 4
a812 3
  if (exp_fold_tree_no_dot(&value, &result)) {
    return exp_intop(result);
  }
d814 2
a815 2
  new = (etree_type*) stat_alloc (sizeof (new->assign));
  memcpy((char *)new, (char *)&value, sizeof(new->assign));
d857 11
a867 10
  switch (tree->type.node_class) {
  case etree_value:
    minfo ("0x%v", tree->value.value);
    return;
  case etree_rel:
    if (tree->rel.section->owner != NULL)
      minfo ("%B:", tree->rel.section->owner);
    minfo ("%s+0x%v", tree->rel.section->name, tree->rel.value);
    return;
  case etree_assign:
d869 67
a935 3
    if (tree->assign.dst->sdefs != (asymbol *)NULL){
      fprintf(config.map_file,"%s (%x) ",tree->assign.dst->name,
	      tree->assign.dst->sdefs->value);
a936 61
    else {
      fprintf(config.map_file,"%s (UNDEFINED)",tree->assign.dst->name);
    }
#endif
    fprintf(config.map_file,"%s",tree->assign.dst);
    exp_print_token(tree->type.node_code);
    exp_print_tree(tree->assign.src);
    break;
  case etree_provide:
    fprintf (config.map_file, "PROVIDE (%s, ", tree->assign.dst);
    exp_print_tree (tree->assign.src);
    fprintf (config.map_file, ")");
    break;
  case etree_binary:
    fprintf(config.map_file,"(");
    exp_print_tree(tree->binary.lhs);
    exp_print_token(tree->type.node_code);
    exp_print_tree(tree->binary.rhs);
    fprintf(config.map_file,")");
    break;
  case etree_trinary:
    exp_print_tree(tree->trinary.cond);
    fprintf(config.map_file,"?");
    exp_print_tree(tree->trinary.lhs);
    fprintf(config.map_file,":");
    exp_print_tree(tree->trinary.rhs);
    break;
  case etree_unary:
    exp_print_token(tree->unary.type.node_code);
    if (tree->unary.child)
    {
    fprintf(config.map_file,"(");
    exp_print_tree(tree->unary.child);
    fprintf(config.map_file,")");
  }

    break;

  case etree_assert:
    fprintf (config.map_file, "ASSERT (");
    exp_print_tree (tree->assert_s.child);
    fprintf (config.map_file, ", %s)", tree->assert_s.message);
    break;

  case etree_undef:
    fprintf(config.map_file,"????????");
    break;
  case etree_name:
    if (tree->type.node_code == NAME) {
      fprintf(config.map_file,"%s", tree->name.name);
    }
    else {
      exp_print_token(tree->type.node_code);
      if (tree->name.name)
      fprintf(config.map_file,"(%s)", tree->name.name);
    }
    break;
  default:
    FAIL();
    break;
  }
d960 1
a960 1
exp_get_value_int (tree,def,name, allocation_done)
d966 1
a966 1
  return (int)exp_get_vma(tree,(bfd_vma)def,name, allocation_done);
d983 4
a986 3
  else {
    einfo (_("%F%S non constant expression for %s\n"),name);
  }
@


1.3
log
@Add octets vs bytes functionality to LD.
@
text
@a31 1

d129 1
a129 1
static void 
d149 1
a149 1
static void 
d215 1
a215 1
static etree_value_type 
d266 1
a266 1
	  switch (tree->type.node_code) 
d323 1
a323 1
etree_value_type 
d331 1
a331 1
static etree_value_type 
d339 1
a339 1
  switch (tree->type.node_code) 
d342 1
a342 1
	if (allocation_done != lang_first_phase_enum) 
d476 1
a476 1
etree_value_type 
d492 1
a492 1
  switch (tree->type.node_class) 
d526 1
a526 1
	  switch (tree->type.node_code) 
d542 1
a542 1
	      else 
d629 1
a629 1
			*dotp = nextdot; 
d687 1
a687 1
static etree_value_type 
a745 1

a766 1

a777 1

a789 3



a799 1

d848 1
a848 1
void 
d896 1
a896 1
    if (tree->unary.child) 
d902 1
a902 1
    
d950 1
a950 1
int 
a958 1

@


1.2
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Fill in structure initializations.
@
text
@d459 1
d464 1
a464 1
	    result = new_abs (os->bfd_section->_raw_size);
@


1.1
log
@Initial revision
@
text
@d2 3
a4 2
Copyright (C) 1991, 92, 93, 94, 95, 96, 97, 1998 Free Software Foundation, Inc.
Written by Steve Chamberlain of Cygnus Support (sac@@cygnus.com).
d971 1
a971 1
     int def;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

