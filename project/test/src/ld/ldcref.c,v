head	1.26;
access;
symbols
	binutils-2_24-branch:1.26.0.2
	binutils-2_24-branchpoint:1.26
	binutils-2_21_1:1.25
	binutils-2_23_2:1.25
	binutils-2_23_1:1.25
	binutils-2_23:1.25
	binutils-2_23-branch:1.25.0.8
	binutils-2_23-branchpoint:1.25
	binutils-2_22_branch:1.25.0.6
	binutils-2_22:1.25
	binutils-2_22-branch:1.25.0.4
	binutils-2_22-branchpoint:1.25
	binutils-2_21:1.25
	binutils-2_21-branch:1.25.0.2
	binutils-2_21-branchpoint:1.25
	binutils-2_20_1:1.23.2.1
	binutils-2_20:1.23.2.1
	binutils-arc-20081103-branch:1.22.0.8
	binutils-arc-20081103-branchpoint:1.22
	binutils-2_20-branch:1.23.0.2
	binutils-2_20-branchpoint:1.23
	dje-cgen-play1-branch:1.22.0.6
	dje-cgen-play1-branchpoint:1.22
	arc-20081103-branch:1.22.0.4
	arc-20081103-branchpoint:1.22
	binutils-2_19_1:1.22
	binutils-2_19:1.22
	binutils-2_19-branch:1.22.0.2
	binutils-2_19-branchpoint:1.22
	binutils-2_18:1.20
	binutils-2_18-branch:1.20.0.2
	binutils-2_18-branchpoint:1.20
	binutils-csl-coldfire-4_1-32:1.14
	binutils-csl-sourcerygxx-4_1-32:1.14
	binutils-csl-innovasic-fido-3_4_4-33:1.14
	binutils-csl-sourcerygxx-3_4_4-32:1.11
	binutils-csl-coldfire-4_1-30:1.14
	binutils-csl-sourcerygxx-4_1-30:1.14
	binutils-csl-coldfire-4_1-28:1.14
	binutils-csl-sourcerygxx-4_1-29:1.14
	binutils-csl-sourcerygxx-4_1-28:1.14
	binutils-csl-arm-2006q3-27:1.14
	binutils-csl-sourcerygxx-4_1-27:1.14
	binutils-csl-arm-2006q3-26:1.14
	binutils-csl-sourcerygxx-4_1-26:1.14
	binutils-csl-sourcerygxx-4_1-25:1.14
	binutils-csl-sourcerygxx-4_1-24:1.14
	binutils-csl-sourcerygxx-4_1-23:1.14
	binutils-csl-sourcerygxx-4_1-21:1.14
	binutils-csl-arm-2006q3-21:1.14
	binutils-csl-sourcerygxx-4_1-22:1.14
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.14
	binutils-csl-sourcerygxx-4_1-20:1.14
	binutils-csl-arm-2006q3-19:1.14
	binutils-csl-sourcerygxx-4_1-19:1.14
	binutils-csl-sourcerygxx-4_1-18:1.14
	binutils-csl-renesas-4_1-9:1.14
	binutils-csl-sourcerygxx-3_4_4-25:1.11
	binutils-csl-renesas-4_1-8:1.14
	binutils-csl-renesas-4_1-7:1.14
	binutils-csl-renesas-4_1-6:1.14
	binutils-csl-sourcerygxx-4_1-17:1.14
	binutils-csl-sourcerygxx-4_1-14:1.14
	binutils-csl-sourcerygxx-4_1-15:1.14
	binutils-csl-sourcerygxx-4_1-13:1.14
	binutils-2_17:1.14
	binutils-csl-sourcerygxx-4_1-12:1.14
	binutils-csl-sourcerygxx-3_4_4-21:1.14
	binutils-csl-wrs-linux-3_4_4-24:1.11
	binutils-csl-wrs-linux-3_4_4-23:1.11
	binutils-csl-sourcerygxx-4_1-9:1.14
	binutils-csl-sourcerygxx-4_1-8:1.14
	binutils-csl-sourcerygxx-4_1-7:1.14
	binutils-csl-arm-2006q1-6:1.14
	binutils-csl-sourcerygxx-4_1-6:1.14
	binutils-csl-wrs-linux-3_4_4-22:1.11
	binutils-csl-coldfire-4_1-11:1.14
	binutils-csl-sourcerygxx-3_4_4-19:1.14
	binutils-csl-coldfire-4_1-10:1.14
	binutils-csl-sourcerygxx-4_1-5:1.14
	binutils-csl-sourcerygxx-4_1-4:1.14
	binutils-csl-wrs-linux-3_4_4-21:1.11
	binutils-csl-morpho-4_1-4:1.14
	binutils-csl-sourcerygxx-3_4_4-17:1.14
	binutils-csl-wrs-linux-3_4_4-20:1.11
	binutils-2_17-branch:1.14.0.4
	binutils-2_17-branchpoint:1.14
	binutils-csl-2_17-branch:1.14.0.2
	binutils-csl-2_17-branchpoint:1.14
	binutils-csl-gxxpro-3_4-branch:1.11.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.11
	binutils-2_16_1:1.11
	binutils-csl-arm-2005q1b:1.11
	binutils-2_16:1.11
	binutils-csl-arm-2005q1a:1.11
	binutils-csl-arm-2005q1-branch:1.11.0.4
	binutils-csl-arm-2005q1-branchpoint:1.11
	binutils-2_16-branch:1.11.0.2
	binutils-2_16-branchpoint:1.11
	csl-arm-2004-q3d:1.10
	csl-arm-2004-q3:1.9
	binutils-2_15:1.9
	binutils-2_15-branchpoint:1.9
	csl-arm-2004-q1a:1.9
	csl-arm-2004-q1:1.9
	binutils-2_15-branch:1.9.0.6
	cagney_bfdfile-20040213-branch:1.9.0.4
	cagney_bfdfile-20040213-branchpoint:1.9
	cagney_bigcore-20040122-branch:1.9.0.2
	cagney_bigcore-20040122-branchpoint:1.9
	csl-arm-2003-q4:1.9
	binutils-2_14:1.8
	binutils-2_14-branch:1.8.0.2
	binutils-2_14-branchpoint:1.8
	binutils-2_13_2_1:1.7
	binutils-2_13_2:1.7
	binutils-2_13_1:1.7
	binutils-2_13:1.7
	binutils-2_13-branchpoint:1.7
	binutils-2_13-branch:1.7.0.4
	binutils-2_12_1:1.7
	binutils-2_12:1.7
	binutils-2_12-branch:1.7.0.2
	binutils-2_12-branchpoint:1.7
	cygnus_cvs_20020108_pre:1.7
	binutils-2_11_2:1.5.2.1
	binutils-2_11_1:1.5.2.1
	binutils-2_11:1.5
	x86_64versiong3:1.5
	binutils-2_11-branch:1.5.0.2
	binutils-2_10_1:1.3
	binutils-2_10:1.3
	binutils-2_10-branch:1.3.0.2
	binutils-2_10-branchpoint:1.3
	binutils_latest_snapshot:1.26
	repo-unification-2000-02-06:1.3
	binu_ss_19990721:1.2
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.26
date	2013.06.12.07.48.32;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	2010.03.10.22.44.01;	author amodra;	state Exp;
branches;
next	1.24;

1.24
date	2009.09.11.15.27.35;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	2009.09.02.07.25.35;	author amodra;	state Exp;
branches
	1.23.2.1;
next	1.22;

1.22
date	2008.08.17.03.12.50;	author amodra;	state Exp;
branches;
next	1.21;

1.21
date	2008.02.15.03.35.53;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2007.07.06.14.09.41;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	2007.04.28.06.04.28;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2007.04.26.14.46.59;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2007.04.19.10.45.59;	author amodra;	state Exp;
branches;
next	1.16;

1.16
date	2007.02.17.00.24.00;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2006.07.19.01.50.23;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2006.03.16.12.20.16;	author amodra;	state Exp;
branches
	1.14.4.1;
next	1.13;

1.13
date	2005.10.05.16.12.17;	author hjl;	state Exp;
branches;
next	1.12;

1.12
date	2005.05.12.07.32.02;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2005.03.03.11.51.57;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2004.10.13.02.28.01;	author amodra;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.28.05.28.54;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2002.11.30.08.39.45;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2001.07.23.07.54.04;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.13.06.14.27;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2000.10.09.15.09.17;	author kazu;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2000.09.29.11.18.18;	author kazu;	state Exp;
branches;
next	1.3;

1.3
date	2000.01.26.23.11.48;	author amodra;	state Exp;
branches;
next	1.2;

1.2
date	99.07.11.20.08.57;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.29.06;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.23.2.1
date	2009.09.11.15.28.44;	author nickc;	state Exp;
branches;
next	;

1.14.4.1
date	2006.07.19.02.37.05;	author amodra;	state Exp;
branches;
next	;

1.5.2.1
date	2001.06.07.03.17.14;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.29.06;	author rth;	state Exp;
branches;
next	;


desc
@@


1.26
log
@	* ldcref.c (output_one_cref): Place common definitions after
	ordinary definitions but before references.
@
text
@/* ldcref.c -- output a cross reference table
   Copyright 1996-2013 Free Software Foundation, Inc.
   Written by Ian Lance Taylor <ian@@cygnus.com>

   This file is part of the GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */


/* This file holds routines that manage the cross reference table.
   The table is used to generate cross reference reports.  It is also
   used to implement the NOCROSSREFS command in the linker script.  */

#include "sysdep.h"
#include "bfd.h"
#include "bfdlink.h"
#include "libiberty.h"
#include "demangle.h"
#include "objalloc.h"

#include "ld.h"
#include "ldmain.h"
#include "ldmisc.h"
#include "ldexp.h"
#include "ldlang.h"

/* We keep an instance of this structure for each reference to a
   symbol from a given object.  */

struct cref_ref {
  /* The next reference.  */
  struct cref_ref *next;
  /* The object.  */
  bfd *abfd;
  /* True if the symbol is defined.  */
  unsigned int def : 1;
  /* True if the symbol is common.  */
  unsigned int common : 1;
  /* True if the symbol is undefined.  */
  unsigned int undef : 1;
};

/* We keep a hash table of symbols.  Each entry looks like this.  */

struct cref_hash_entry {
  struct bfd_hash_entry root;
  /* The demangled name.  */
  const char *demangled;
  /* References to and definitions of this symbol.  */
  struct cref_ref *refs;
};

/* This is what the hash table looks like.  */

struct cref_hash_table {
  struct bfd_hash_table root;
};

/* Forward declarations.  */

static void output_one_cref (FILE *, struct cref_hash_entry *);
static void check_local_sym_xref (lang_input_statement_type *);
static bfd_boolean check_nocrossref (struct cref_hash_entry *, void *);
static void check_refs (const char *, bfd_boolean, asection *, bfd *,
			struct lang_nocrossrefs *);
static void check_reloc_refs (bfd *, asection *, void *);

/* Look up an entry in the cref hash table.  */

#define cref_hash_lookup(table, string, create, copy)		\
  ((struct cref_hash_entry *)					\
   bfd_hash_lookup (&(table)->root, (string), (create), (copy)))

/* Traverse the cref hash table.  */

#define cref_hash_traverse(table, func, info)				\
  (bfd_hash_traverse							\
   (&(table)->root,							\
    (bfd_boolean (*) (struct bfd_hash_entry *, void *)) (func),		\
    (info)))

/* The cref hash table.  */

static struct cref_hash_table cref_table;

/* Whether the cref hash table has been initialized.  */

static bfd_boolean cref_initialized;

/* The number of symbols seen so far.  */

static size_t cref_symcount;

/* Used to take a snapshot of the cref hash table when starting to
   add syms from an as-needed library.  */
static struct bfd_hash_entry **old_table;
static unsigned int old_size;
static unsigned int old_count;
static void *old_tab;
static void *alloc_mark;
static size_t tabsize, entsize, refsize;
static size_t old_symcount;

/* Create an entry in a cref hash table.  */

static struct bfd_hash_entry *
cref_hash_newfunc (struct bfd_hash_entry *entry,
		   struct bfd_hash_table *table,
		   const char *string)
{
  struct cref_hash_entry *ret = (struct cref_hash_entry *) entry;

  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (ret == NULL)
    ret = ((struct cref_hash_entry *)
	   bfd_hash_allocate (table, sizeof (struct cref_hash_entry)));
  if (ret == NULL)
    return NULL;

  /* Call the allocation method of the superclass.  */
  ret = ((struct cref_hash_entry *)
	 bfd_hash_newfunc ((struct bfd_hash_entry *) ret, table, string));
  if (ret != NULL)
    {
      /* Set local fields.  */
      ret->demangled = NULL;
      ret->refs = NULL;

      /* Keep a count of the number of entries created in the hash
	 table.  */
      ++cref_symcount;
    }

  return &ret->root;
}

/* Add a symbol to the cref hash table.  This is called for every
   global symbol that is seen during the link.  */

void
add_cref (const char *name,
	  bfd *abfd,
	  asection *section,
	  bfd_vma value ATTRIBUTE_UNUSED)
{
  struct cref_hash_entry *h;
  struct cref_ref *r;

  if (! cref_initialized)
    {
      if (!bfd_hash_table_init (&cref_table.root, cref_hash_newfunc,
				sizeof (struct cref_hash_entry)))
	einfo (_("%X%P: bfd_hash_table_init of cref table failed: %E\n"));
      cref_initialized = TRUE;
    }

  h = cref_hash_lookup (&cref_table, name, TRUE, FALSE);
  if (h == NULL)
    einfo (_("%X%P: cref_hash_lookup failed: %E\n"));

  for (r = h->refs; r != NULL; r = r->next)
    if (r->abfd == abfd)
      break;

  if (r == NULL)
    {
      r = (struct cref_ref *) bfd_hash_allocate (&cref_table.root, sizeof *r);
      if (r == NULL)
	einfo (_("%X%P: cref alloc failed: %E\n"));
      r->next = h->refs;
      h->refs = r;
      r->abfd = abfd;
      r->def = FALSE;
      r->common = FALSE;
      r->undef = FALSE;
    }

  if (bfd_is_und_section (section))
    r->undef = TRUE;
  else if (bfd_is_com_section (section))
    r->common = TRUE;
  else
    r->def = TRUE;
}

/* Called before loading an as-needed library to take a snapshot of
   the cref hash table, and after we have loaded or found that the
   library was not needed.  */

bfd_boolean
handle_asneeded_cref (bfd *abfd ATTRIBUTE_UNUSED,
		      enum notice_asneeded_action act)
{
  unsigned int i;

  if (!cref_initialized)
    return TRUE;

  if (act == notice_as_needed)
    {
      char *old_ent, *old_ref;

      for (i = 0; i < cref_table.root.size; i++)
	{
	  struct bfd_hash_entry *p;
	  struct cref_hash_entry *c;
	  struct cref_ref *r;

	  for (p = cref_table.root.table[i]; p != NULL; p = p->next)
	    {
	      entsize += cref_table.root.entsize;
	      c = (struct cref_hash_entry *) p;
	      for (r = c->refs; r != NULL; r = r->next)
		refsize += sizeof (struct cref_ref);
	    }
	}

      tabsize = cref_table.root.size * sizeof (struct bfd_hash_entry *);
      old_tab = xmalloc (tabsize + entsize + refsize);

      alloc_mark = bfd_hash_allocate (&cref_table.root, 1);
      if (alloc_mark == NULL)
	return FALSE;

      memcpy (old_tab, cref_table.root.table, tabsize);
      old_ent = (char *) old_tab + tabsize;
      old_ref = (char *) old_ent + entsize;
      old_table = cref_table.root.table;
      old_size = cref_table.root.size;
      old_count = cref_table.root.count;
      old_symcount = cref_symcount;

      for (i = 0; i < cref_table.root.size; i++)
	{
	  struct bfd_hash_entry *p;
	  struct cref_hash_entry *c;
	  struct cref_ref *r;

	  for (p = cref_table.root.table[i]; p != NULL; p = p->next)
	    {
	      memcpy (old_ent, p, cref_table.root.entsize);
	      old_ent = (char *) old_ent + cref_table.root.entsize;
	      c = (struct cref_hash_entry *) p;
	      for (r = c->refs; r != NULL; r = r->next)
		{
		  memcpy (old_ref, r, sizeof (struct cref_ref));
		  old_ref = (char *) old_ref + sizeof (struct cref_ref);
		}
	    }
	}
      return TRUE;
    }

  if (act == notice_not_needed)
    {
      char *old_ent, *old_ref;

      if (old_tab == NULL)
	{
	  /* The only way old_tab can be NULL is if the cref hash table
	     had not been initialised when notice_as_needed.  */
	  bfd_hash_table_free (&cref_table.root);
	  cref_initialized = FALSE;
	  return TRUE;
	}

      old_ent = (char *) old_tab + tabsize;
      old_ref = (char *) old_ent + entsize;
      cref_table.root.table = old_table;
      cref_table.root.size = old_size;
      cref_table.root.count = old_count;
      memcpy (cref_table.root.table, old_tab, tabsize);
      cref_symcount = old_symcount;

      for (i = 0; i < cref_table.root.size; i++)
	{
	  struct bfd_hash_entry *p;
	  struct cref_hash_entry *c;
	  struct cref_ref *r;

	  for (p = cref_table.root.table[i]; p != NULL; p = p->next)
	    {
	      memcpy (p, old_ent, cref_table.root.entsize);
	      old_ent = (char *) old_ent + cref_table.root.entsize;
	      c = (struct cref_hash_entry *) p;
	      for (r = c->refs; r != NULL; r = r->next)
		{
		  memcpy (r, old_ref, sizeof (struct cref_ref));
		  old_ref = (char *) old_ref + sizeof (struct cref_ref);
		}
	    }
	}

      objalloc_free_block ((struct objalloc *) cref_table.root.memory,
			   alloc_mark);
    }
  else if (act != notice_needed)
    return FALSE;

  free (old_tab);
  old_tab = NULL;
  return TRUE;
}

/* Copy the addresses of the hash table entries into an array.  This
   is called via cref_hash_traverse.  We also fill in the demangled
   name.  */

static bfd_boolean
cref_fill_array (struct cref_hash_entry *h, void *data)
{
  struct cref_hash_entry ***pph = (struct cref_hash_entry ***) data;

  ASSERT (h->demangled == NULL);
  h->demangled = bfd_demangle (link_info.output_bfd, h->root.string,
			       DMGL_ANSI | DMGL_PARAMS);
  if (h->demangled == NULL)
    h->demangled = h->root.string;

  **pph = h;

  ++*pph;

  return TRUE;
}

/* Sort an array of cref hash table entries by name.  */

static int
cref_sort_array (const void *a1, const void *a2)
{
  const struct cref_hash_entry * const *p1 =
      (const struct cref_hash_entry * const *) a1;
  const struct cref_hash_entry * const *p2 =
      (const struct cref_hash_entry * const *) a2;

  return strcmp ((*p1)->demangled, (*p2)->demangled);
}

/* Write out the cref table.  */

#define FILECOL (50)

void
output_cref (FILE *fp)
{
  int len;
  struct cref_hash_entry **csyms, **csym_fill, **csym, **csym_end;
  const char *msg;

  fprintf (fp, _("\nCross Reference Table\n\n"));
  msg = _("Symbol");
  fprintf (fp, "%s", msg);
  len = strlen (msg);
  while (len < FILECOL)
    {
      putc (' ', fp);
      ++len;
    }
  fprintf (fp, _("File\n"));

  if (! cref_initialized)
    {
      fprintf (fp, _("No symbols\n"));
      return;
    }

  csyms = (struct cref_hash_entry **) xmalloc (cref_symcount * sizeof (*csyms));

  csym_fill = csyms;
  cref_hash_traverse (&cref_table, cref_fill_array, &csym_fill);
  ASSERT ((size_t) (csym_fill - csyms) == cref_symcount);

  qsort (csyms, cref_symcount, sizeof (*csyms), cref_sort_array);

  csym_end = csyms + cref_symcount;
  for (csym = csyms; csym < csym_end; csym++)
    output_one_cref (fp, *csym);
}

/* Output one entry in the cross reference table.  */

static void
output_one_cref (FILE *fp, struct cref_hash_entry *h)
{
  int len;
  struct bfd_link_hash_entry *hl;
  struct cref_ref *r;

  hl = bfd_link_hash_lookup (link_info.hash, h->root.string, FALSE,
			     FALSE, TRUE);
  if (hl == NULL)
    einfo ("%P: symbol `%T' missing from main hash table\n",
	   h->root.string);
  else
    {
      /* If this symbol is defined in a dynamic object but never
	 referenced by a normal object, then don't print it.  */
      if (hl->type == bfd_link_hash_defined)
	{
	  if (hl->u.def.section->output_section == NULL)
	    return;
	  if (hl->u.def.section->owner != NULL
	      && (hl->u.def.section->owner->flags & DYNAMIC) != 0)
	    {
	      for (r = h->refs; r != NULL; r = r->next)
		if ((r->abfd->flags & DYNAMIC) == 0)
		  break;
	      if (r == NULL)
		return;
	    }
	}
    }

  fprintf (fp, "%s ", h->demangled);
  len = strlen (h->demangled) + 1;

  for (r = h->refs; r != NULL; r = r->next)
    {
      if (r->def)
	{
	  while (len < FILECOL)
	    {
	      putc (' ', fp);
	      ++len;
	    }
	  lfinfo (fp, "%B\n", r->abfd);
	  len = 0;
	}
    }

  for (r = h->refs; r != NULL; r = r->next)
    {
      if (r->common)
	{
	  while (len < FILECOL)
	    {
	      putc (' ', fp);
	      ++len;
	    }
	  lfinfo (fp, "%B\n", r->abfd);
	  len = 0;
	}
    }

  for (r = h->refs; r != NULL; r = r->next)
    {
      if (! r->def && ! r->common)
	{
	  while (len < FILECOL)
	    {
	      putc (' ', fp);
	      ++len;
	    }
	  lfinfo (fp, "%B\n", r->abfd);
	  len = 0;
	}
    }

  ASSERT (len == 0);
}

/* Check for prohibited cross references.  */

void
check_nocrossrefs (void)
{
  if (! cref_initialized)
    return;

  cref_hash_traverse (&cref_table, check_nocrossref, NULL);

  lang_for_each_file (check_local_sym_xref);
}

/* Check for prohibited cross references to local and section symbols.  */

static void
check_local_sym_xref (lang_input_statement_type *statement)
{
  bfd *abfd;
  asymbol **syms;

  abfd = statement->the_bfd;
  if (abfd == NULL)
    return;

  if (!bfd_generic_link_read_symbols (abfd))
    einfo (_("%B%F: could not read symbols: %E\n"), abfd);

  for (syms = bfd_get_outsymbols (abfd); *syms; ++syms)
    {
      asymbol *sym = *syms;
      if (sym->flags & (BSF_GLOBAL | BSF_WARNING | BSF_INDIRECT | BSF_FILE))
	continue;
      if ((sym->flags & (BSF_LOCAL | BSF_SECTION_SYM)) != 0
	  && sym->section->output_section != NULL)
	{
	  const char *outsecname, *symname;
	  struct lang_nocrossrefs *ncrs;
	  struct lang_nocrossref *ncr;

	  outsecname = sym->section->output_section->name;
	  symname = NULL;
	  if ((sym->flags & BSF_SECTION_SYM) == 0)
	    symname = sym->name;
	  for (ncrs = nocrossref_list; ncrs != NULL; ncrs = ncrs->next)
	    for (ncr = ncrs->list; ncr != NULL; ncr = ncr->next)
	      if (strcmp (ncr->name, outsecname) == 0)
		check_refs (symname, FALSE, sym->section, abfd, ncrs);
	}
    }
}

/* Check one symbol to see if it is a prohibited cross reference.  */

static bfd_boolean
check_nocrossref (struct cref_hash_entry *h, void *ignore ATTRIBUTE_UNUSED)
{
  struct bfd_link_hash_entry *hl;
  asection *defsec;
  const char *defsecname;
  struct lang_nocrossrefs *ncrs;
  struct lang_nocrossref *ncr;
  struct cref_ref *ref;

  hl = bfd_link_hash_lookup (link_info.hash, h->root.string, FALSE,
			     FALSE, TRUE);
  if (hl == NULL)
    {
      einfo (_("%P: symbol `%T' missing from main hash table\n"),
	     h->root.string);
      return TRUE;
    }

  if (hl->type != bfd_link_hash_defined
      && hl->type != bfd_link_hash_defweak)
    return TRUE;

  defsec = hl->u.def.section->output_section;
  if (defsec == NULL)
    return TRUE;
  defsecname = bfd_get_section_name (defsec->owner, defsec);

  for (ncrs = nocrossref_list; ncrs != NULL; ncrs = ncrs->next)
    for (ncr = ncrs->list; ncr != NULL; ncr = ncr->next)
      if (strcmp (ncr->name, defsecname) == 0)
	for (ref = h->refs; ref != NULL; ref = ref->next)
	  check_refs (hl->root.string, TRUE, hl->u.def.section,
		      ref->abfd, ncrs);

  return TRUE;
}

/* The struct is used to pass information from check_refs to
   check_reloc_refs through bfd_map_over_sections.  */

struct check_refs_info {
  const char *sym_name;
  asection *defsec;
  struct lang_nocrossrefs *ncrs;
  asymbol **asymbols;
  bfd_boolean global;
};

/* This function is called for each symbol defined in a section which
   prohibits cross references.  We need to look through all references
   to this symbol, and ensure that the references are not from
   prohibited sections.  */

static void
check_refs (const char *name,
	    bfd_boolean global,
	    asection *sec,
	    bfd *abfd,
	    struct lang_nocrossrefs *ncrs)
{
  struct check_refs_info info;

  /* We need to look through the relocations for this BFD, to see
     if any of the relocations which refer to this symbol are from
     a prohibited section.  Note that we need to do this even for
     the BFD in which the symbol is defined, since even a single
     BFD might contain a prohibited cross reference.  */

  if (!bfd_generic_link_read_symbols (abfd))
    einfo (_("%B%F: could not read symbols: %E\n"), abfd);

  info.sym_name = name;
  info.global = global;
  info.defsec = sec;
  info.ncrs = ncrs;
  info.asymbols = bfd_get_outsymbols (abfd);
  bfd_map_over_sections (abfd, check_reloc_refs, &info);
}

/* This is called via bfd_map_over_sections.  INFO->SYM_NAME is a symbol
   defined in INFO->DEFSECNAME.  If this section maps into any of the
   sections listed in INFO->NCRS, other than INFO->DEFSECNAME, then we
   look through the relocations.  If any of the relocations are to
   INFO->SYM_NAME, then we report a prohibited cross reference error.  */

static void
check_reloc_refs (bfd *abfd, asection *sec, void *iarg)
{
  struct check_refs_info *info = (struct check_refs_info *) iarg;
  asection *outsec;
  const char *outsecname;
  asection *outdefsec;
  const char *outdefsecname;
  struct lang_nocrossref *ncr;
  const char *symname;
  bfd_boolean global;
  long relsize;
  arelent **relpp;
  long relcount;
  arelent **p, **pend;

  outsec = sec->output_section;
  outsecname = bfd_get_section_name (outsec->owner, outsec);

  outdefsec = info->defsec->output_section;
  outdefsecname = bfd_get_section_name (outdefsec->owner, outdefsec);

  /* The section where the symbol is defined is permitted.  */
  if (strcmp (outsecname, outdefsecname) == 0)
    return;

  for (ncr = info->ncrs->list; ncr != NULL; ncr = ncr->next)
    if (strcmp (outsecname, ncr->name) == 0)
      break;

  if (ncr == NULL)
    return;

  /* This section is one for which cross references are prohibited.
     Look through the relocations, and see if any of them are to
     INFO->SYM_NAME.  If INFO->SYMNAME is NULL, check for relocations
     against the section symbol.  If INFO->GLOBAL is TRUE, the
     definition is global, check for relocations against the global
     symbols.  Otherwise check for relocations against the local and
     section symbols.  */

  symname = info->sym_name;
  global = info->global;

  relsize = bfd_get_reloc_upper_bound (abfd, sec);
  if (relsize < 0)
    einfo (_("%B%F: could not read relocs: %E\n"), abfd);
  if (relsize == 0)
    return;

  relpp = (arelent **) xmalloc (relsize);
  relcount = bfd_canonicalize_reloc (abfd, sec, relpp, info->asymbols);
  if (relcount < 0)
    einfo (_("%B%F: could not read relocs: %E\n"), abfd);

  p = relpp;
  pend = p + relcount;
  for (; p < pend && *p != NULL; p++)
    {
      arelent *q = *p;

      if (q->sym_ptr_ptr != NULL
	  && *q->sym_ptr_ptr != NULL
	  && ((global
	       && (bfd_is_und_section (bfd_get_section (*q->sym_ptr_ptr))
		   || bfd_is_com_section (bfd_get_section (*q->sym_ptr_ptr))
		   || ((*q->sym_ptr_ptr)->flags & (BSF_GLOBAL
						   | BSF_WEAK)) != 0))
	      || (!global
		  && ((*q->sym_ptr_ptr)->flags & (BSF_LOCAL
						  | BSF_SECTION_SYM)) != 0
		  && bfd_get_section (*q->sym_ptr_ptr) == info->defsec))
	  && (symname != NULL
	      ? strcmp (bfd_asymbol_name (*q->sym_ptr_ptr), symname) == 0
	      : ((*q->sym_ptr_ptr)->flags & BSF_SECTION_SYM) != 0))
	{
	  /* We found a reloc for the symbol.  The symbol is defined
	     in OUTSECNAME.  This reloc is from a section which is
	     mapped into a section from which references to OUTSECNAME
	     are prohibited.  We must report an error.  */
	  einfo (_("%X%C: prohibited cross reference from %s to `%T' in %s\n"),
		 abfd, sec, q->address, outsecname,
		 bfd_asymbol_name (*q->sym_ptr_ptr), outdefsecname);
	}
    }

  free (relpp);
}
@


1.25
log
@	PR ld/11367
	* ldcref.c (handle_asneeded_cref): Correct copying of refs.
@
text
@d2 1
a2 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006,
   2007, 2008  Free Software Foundation, Inc.
d448 15
a462 1
      if (! r->def)
@


1.24
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        * as.c (main): Call dwarf2_init.
        * config/obj-elf.c (struct group_list): New field.
        (build_group_lists): Use hash lookup.
        (free_section_idx): New function.
        (elf_frob_file): Adjust.
        * dwarf2dbg.c (all_segs_hash, last_seg_ptr): New variables.
        (get_line_subseg): Adjust.
        (dwarf2_init): New function.
        * dwarf2dbg.h (dwarf2_init): New declaration.
@
text
@d229 1
a229 1
		refsize += sizeof (struct cref_hash_entry);
d261 2
a262 2
		  memcpy (old_ref, r, sizeof (struct cref_hash_entry));
		  old_ref = (char *) old_ref + sizeof (struct cref_hash_entry);
d303 2
a304 2
		  memcpy (r, old_ref, sizeof (struct cref_hash_entry));
		  old_ref = (char *) old_ref + sizeof (struct cref_hash_entry);
@


1.23
log
@update copyright dates
@
text
@d182 1
a182 1
      r = bfd_hash_allocate (&cref_table.root, sizeof *r);
d327 1
a327 1
  struct cref_hash_entry ***pph = data;
d347 4
a350 2
  const struct cref_hash_entry * const *p1 = a1;
  const struct cref_hash_entry * const *p2 = a2;
d383 1
a383 1
  csyms = xmalloc (cref_symcount * sizeof (*csyms));
d607 1
a607 1
  struct check_refs_info *info = iarg;
d654 1
a654 1
  relpp = xmalloc (relsize);
@


1.23.2.1
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.
@
text
@d182 1
a182 1
      r = (struct cref_ref *) bfd_hash_allocate (&cref_table.root, sizeof *r);
d327 1
a327 1
  struct cref_hash_entry ***pph = (struct cref_hash_entry ***) data;
d347 2
a348 4
  const struct cref_hash_entry * const *p1 =
      (const struct cref_hash_entry * const *) a1;
  const struct cref_hash_entry * const *p2 =
      (const struct cref_hash_entry * const *) a2;
d381 1
a381 1
  csyms = (struct cref_hash_entry **) xmalloc (cref_symcount * sizeof (*csyms));
d605 1
a605 1
  struct check_refs_info *info = (struct check_refs_info *) iarg;
d652 1
a652 1
  relpp = (arelent **) xmalloc (relsize);
@


1.22
log
@bfd/
	* bfd.c (struct _bfd): Correct outsymbols comment.
	* bfd-in2.h: Regenerate.
	* linker.c (bfd_generic_link_read_symbols): Renamed from..
	(generic_link_read_symbols): ..this, and made global.

include/
	* bfdlink.h (bfd_generic_link_read_symbols): Declare.
ld/
	PR 6478
	* ldcref.c (check_local_sym_xref): Use bfd_generic_link_read_symbols.
	Don't free symbol pointer array.
	(check_refs): Likewise.
	* ldmain.c (warning_callback): Likewise.
	* ldmisc.c (vfinfo): Likewise.
	* pe-dll.c (process_def_file): Likewise.
	(pe_walk_relocs_of_symbol, generate_reloc): Likewise.
	* emultempl/pe.em (pe_find_data_imports): Likewise.
	(gld_${EMULATION_NAME}_after_open): Likewise.
	* emultempl/pep.em (pep_find_data_imports): Likewise.
	(gld_${EMULATION_NAME}_after_open): Likewise.
	* ldlang.h (lang_input_statement_type): Delete asymbols, symbol_count,
	passive_position, closed.
	* ldlang.c (new_afile): Don't set asymbols and symbol_count.
	* ldmain.c (add_archive_element): xcalloc lang_input_statement_type.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2006,
@


1.21
log
@include/
	* bfdlink.h (struct bfd_link_hash_table): Delete creator field.
	(struct bfd_link_info): Add output_bfd.
bfd/
	* elflink.c: Replace all accesses to hash->creator field with
	output_bfd->xvec.
	* cofflink.c: Likewise.
	* coff-h8300.c: Likewise.
	* ecoff.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfxx-mips.c: Likewise.
	* i386linux.c: Likewise.
	* m68klinux.c: Likewise.
	* sparclinux.c: Likewise.
	* sunos.c: Likewise.
	* xcofflink.c: Likewise.
	* linker.c: Likewise.
	(_bfd_link_hash_table_init): Don't store creator.
ld/
	* ldmain.h (output_bfd): Delete.
	* ldmain.c (output_bfd): Delete.
	Replace all occurrences of output_bfd with link_info.output_bfd.
	* ldcref.c: Likewise.
	* ldctor.c: Likewise.
	* ldemul.c: Likewise.
	* ldexp.c: Likewise.
	* ldfile.c: Likewise.
	* ldlang.c: Likewise.
	* ldmisc.c: Likewise.
	* ldwrite.c: Likewise.
	* pe-dll.c: Likewise.
	* emultempl/aix.em: Likewise.
	* emultempl/alphaelf.em: Likewise.
	* emultempl/armcoff.em: Likewise.
	* emultempl/armelf.em: Likewise.
	* emultempl/avrelf.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/elf-generic.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/irix.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68hc1xelf.em: Likewise.
	* emultempl/mmix-elfnmmo.em: Likewise.
	* emultempl/mmo.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/scoreelf.em: Likewise.
	* emultempl/sh64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/vanilla.em: Likewise.
	* emultempl/vxworks.em: Likewise.
	* emultempl/xtensaelf.em: Likewise.
	* emultempl/z80.em: Likewise.
	* ldlang.c (open_output): Don't return output, instead write
	link_info_output_bfd directly.
	* emultempl/alphaelf.em: Replace occurrences of link_info.hash->creator
	with link_info.output_bfd->xvec.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
@
text
@d481 1
a481 2
  lang_input_statement_type *li;
  asymbol **asymbols, **syms;
d487 2
a488 7
  li = abfd->usrdata;
  if (li != NULL && li->asymbols != NULL)
    asymbols = li->asymbols;
  else
    {
      long symsize;
      long symbol_count;
d490 1
a490 15
      symsize = bfd_get_symtab_upper_bound (abfd);
      if (symsize < 0)
	einfo (_("%B%F: could not read symbols; %E\n"), abfd);
      asymbols = xmalloc (symsize);
      symbol_count = bfd_canonicalize_symtab (abfd, asymbols);
      if (symbol_count < 0)
	einfo (_("%B%F: could not read symbols: %E\n"), abfd);
      if (li != NULL)
	{
	  li->asymbols = asymbols;
	  li->symbol_count = symbol_count;
	}
    }

  for (syms = asymbols; *syms; ++syms)
a511 3

  if (li == NULL)
    free (asymbols);
a576 2
  lang_input_statement_type *li;
  asymbol **asymbols;
d585 2
a586 21
  li = abfd->usrdata;
  if (li != NULL && li->asymbols != NULL)
    asymbols = li->asymbols;
  else
    {
      long symsize;
      long symbol_count;

      symsize = bfd_get_symtab_upper_bound (abfd);
      if (symsize < 0)
	einfo (_("%B%F: could not read symbols; %E\n"), abfd);
      asymbols = xmalloc (symsize);
      symbol_count = bfd_canonicalize_symtab (abfd, asymbols);
      if (symbol_count < 0)
	einfo (_("%B%F: could not read symbols: %E\n"), abfd);
      if (li != NULL)
	{
	  li->asymbols = asymbols;
	  li->symbol_count = symbol_count;
	}
    }
d592 1
a592 1
  info.asymbols = asymbols;
a593 3

  if (li == NULL)
    free (asymbols);
@


1.20
log
@Update sources to GPLv3
@
text
@d3 1
a3 1
   2007  Free Software Foundation, Inc.
d330 1
a330 1
  h->demangled = bfd_demangle (output_bfd, h->root.string,
@


1.19
log
@	* ldcref.c (struct cref_hash_entry): Make "demangled" const.
	(cref_fill_array): Adjust for changed demangler.
	* ldlang.c (lang_one_common): Likewise.
@
text
@d3 1
a3 1
   2007 Free Software Foundation, Inc.
d6 16
a21 1
This file is part of GLD, the Gnu Linker.
a22 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.18
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d60 1
a60 1
  char *demangled;
d330 2
@


1.17
log
@	* ldcref.c (cref_fill_array): Call bfd_demangle rather than demangle.
	* ldlang.c (lang_one_common): Likewise.
	* ldmisc.c (vfinfo): Likewise.
	(demangle): Delete.
	* ldmisc.h (demangle): Delete.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
@
text
@d26 1
a27 1
#include "sysdep.h"
@


1.16
log
@	* ldcref.c (check_reloc_refs): Compare section for local syms.
@
text
@d30 1
d328 2
a329 1
  h->demangled = demangle (h->root.string);
@


1.15
log
@bfd/
	* bfd-in.h (enum notice_asneeded_action): Define.
	* bfd-in2.h: Regenerate.
	* elflink.c (elf_link_add_object_symbols): Call linker "notice"
	function with NULL name for as-needed handling.
ld/
	* ld.h (handle_asneeded_cref): Declare.
	* ldcref.c: Include objalloc.h.
	(old_table, old_count, old_tab, alloc_mark): New variables.
	(tabsize, entsize, refsize, old_symcount): Likewise.
	(add_cref): Use bfd_hash_allocate for refs.
	(handle_asneeded_cref): New function.
	* ldmain.c (notice): Call handle_asneeded_cref for NULL name.
@
text
@d2 2
a3 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2006
   Free Software Foundation, Inc.
d713 2
a714 1
						  | BSF_SECTION_SYM)) != 0))
d717 1
a717 2
	      : (((*q->sym_ptr_ptr)->flags & BSF_SECTION_SYM) != 0
		 && bfd_get_section (*q->sym_ptr_ptr) == info->defsec)))
@


1.14
log
@	PR 2434
bfd/
	* elflink.c (struct elf_smash_syms_data, elf_smash_syms): Delete.
	(elf_link_add_object_symbols): Delete unnecessary locals.  Rename
	hash_table -> htab.  Formatting.  Save entire symbol table
	before loading as-needed syms, and restore afterwards if lib not
	needed.  Use bfd_hash_allocate rather than bfd_alloc for sym
	name.  Free some buffers earlier.
	* bfd-in.h (struct bfd_hash_table): Add entsize.
	(bfd_hash_table_init, bfd_hash_table_init_n): Adjust prototype.
	* elf-bfd.h (_bfd_elf_link_hash_table_init): Likewise
	* hash.c (bfd_hash_table_init_n): Add entsize param, save to
	hash table.
	(bfd_hash_table_init): Add param, adjust calls.
	* aoutx.h: Adjust all hash_table_init functions and calls.
	* bfd.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* i386linux.c: Likewise.
	* libaout.h: Likewise.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* linker.c: Likewise.
	* m68klinux.c: Likewise.
	* merge.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* sparclinux.c: Likewise.
	* stabs.c: Likewise.
	* sunos.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* section.c (struct section_hash_entry): Move to..
	* libbfd-in.h: ..here.
	* Makefile.am: Run "make dep-am"
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
binutils/
	* ieee.c (write_ieee_debugging_info): Adjust bfd_hash_table_init calls.
	* wrstabs.c (write_stabs_in_sections_debugging_info): Likewise.
ld/
	* ldcref.c (add_cref): Adjust bfd_hash_table_init calls.
	* ldlang.c (output_statement_table_init, lang_init): Likewise.
	* ldmain.c (add_ysym, add_wrap, add_keepsyms_file): Likewise.
	(undefined_symbol): Likewise.
@
text
@d30 1
d105 10
d179 3
a181 1
      r = xmalloc (sizeof *r);
d198 119
@


1.14.4.1
log
@bfd/
	* bfd-in.h (enum notice_asneeded_action): Define.
	* bfd-in2.h: Regenerate.
	* elflink.c (elf_link_add_object_symbols): Call linker "notice"
	function with NULL name for as-needed handling.
ld/
	* ld.h (handle_asneeded_cref): Declare.
	* ldcref.c: Include objalloc.h.
	(old_table, old_tab, alloc_mark): New variables.
	(tabsize, entsize, refsize, old_symcount): Likewise.
	(add_cref): Use bfd_hash_allocate for refs.
	(handle_asneeded_cref): New function.
	* ldmain.c (notice): Call handle_asneeded_cref for NULL name.
@
text
@a29 1
#include "objalloc.h"
a103 9
/* Used to take a snapshot of the cref hash table when starting to
   add syms from an as-needed library.  */
static struct bfd_hash_entry **old_table;
static unsigned int old_size;
static void *old_tab;
static void *alloc_mark;
static size_t tabsize, entsize, refsize;
static size_t old_symcount;

d168 1
a168 3
      r = bfd_hash_allocate (&cref_table.root, sizeof *r);
      if (r == NULL)
	einfo (_("%X%P: cref alloc failed: %E\n"));
a184 117
/* Called before loading an as-needed library to take a snapshot of
   the cref hash table, and after we have loaded or found that the
   library was not needed.  */

bfd_boolean
handle_asneeded_cref (bfd *abfd ATTRIBUTE_UNUSED,
		      enum notice_asneeded_action act)
{
  unsigned int i;

  if (!cref_initialized)
    return TRUE;

  if (act == notice_as_needed)
    {
      char *old_ent, *old_ref;

      for (i = 0; i < cref_table.root.size; i++)
	{
	  struct bfd_hash_entry *p;
	  struct cref_hash_entry *c;
	  struct cref_ref *r;

	  for (p = cref_table.root.table[i]; p != NULL; p = p->next)
	    {
	      entsize += cref_table.root.entsize;
	      c = (struct cref_hash_entry *) p;
	      for (r = c->refs; r != NULL; r = r->next)
		refsize += sizeof (struct cref_hash_entry);
	    }
	}

      tabsize = cref_table.root.size * sizeof (struct bfd_hash_entry *);
      old_tab = xmalloc (tabsize + entsize + refsize);

      alloc_mark = bfd_hash_allocate (&cref_table.root, 1);
      if (alloc_mark == NULL)
	return FALSE;

      memcpy (old_tab, cref_table.root.table, tabsize);
      old_ent = (char *) old_tab + tabsize;
      old_ref = (char *) old_ent + entsize;
      old_table = cref_table.root.table;
      old_size = cref_table.root.size;
      old_symcount = cref_symcount;

      for (i = 0; i < cref_table.root.size; i++)
	{
	  struct bfd_hash_entry *p;
	  struct cref_hash_entry *c;
	  struct cref_ref *r;

	  for (p = cref_table.root.table[i]; p != NULL; p = p->next)
	    {
	      memcpy (old_ent, p, cref_table.root.entsize);
	      old_ent = (char *) old_ent + cref_table.root.entsize;
	      c = (struct cref_hash_entry *) p;
	      for (r = c->refs; r != NULL; r = r->next)
		{
		  memcpy (old_ref, r, sizeof (struct cref_hash_entry));
		  old_ref = (char *) old_ref + sizeof (struct cref_hash_entry);
		}
	    }
	}
      return TRUE;
    }

  if (act == notice_not_needed)
    {
      char *old_ent, *old_ref;

      if (old_tab == NULL)
	{
	  /* The only way old_tab can be NULL is if the cref hash table
	     had not been initialised when notice_as_needed.  */
	  bfd_hash_table_free (&cref_table.root);
	  cref_initialized = FALSE;
	  return TRUE;
	}

      old_ent = (char *) old_tab + tabsize;
      old_ref = (char *) old_ent + entsize;
      cref_table.root.table = old_table;
      cref_table.root.size = old_size;
      memcpy (cref_table.root.table, old_tab, tabsize);
      cref_symcount = old_symcount;

      for (i = 0; i < cref_table.root.size; i++)
	{
	  struct bfd_hash_entry *p;
	  struct cref_hash_entry *c;
	  struct cref_ref *r;

	  for (p = cref_table.root.table[i]; p != NULL; p = p->next)
	    {
	      memcpy (p, old_ent, cref_table.root.entsize);
	      old_ent = (char *) old_ent + cref_table.root.entsize;
	      c = (struct cref_hash_entry *) p;
	      for (r = c->refs; r != NULL; r = r->next)
		{
		  memcpy (r, old_ref, sizeof (struct cref_hash_entry));
		  old_ref = (char *) old_ref + sizeof (struct cref_hash_entry);
		}
	    }
	}

      objalloc_free_block ((struct objalloc *) cref_table.root.memory,
			   alloc_mark);
    }
  else if (act != notice_needed)
    return FALSE;

  free (old_tab);
  old_tab = NULL;
  return TRUE;
}

@


1.13
log
@2005-10-05  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/1396
	* ldcref.c (check_refs): Accept bfd_boolean.
	(check_local_sym_xref): Pass FALSE to check_refs.
	(check_nocrossref): Pass TRUE to check_refs.
	(check_refs_info): Add bfd_boolean.
	(check_refs): Add bfd_boolean to check_refs_info.
	(check_reloc_refs): Match relocations with proper symbols.

	* ldmisc.c (vfinfo): Don't add extra ":\n".
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d152 2
a153 1
      if (! bfd_hash_table_init (&cref_table.root, cref_hash_newfunc))
@


1.12
log
@Update FSF addresses
@
text
@d74 1
a74 1
static void check_refs (const char *, asection *, bfd *,
d390 1
a390 1
		check_refs (symname, sym->section, abfd, ncrs);
d432 2
a433 1
	  check_refs (hl->root.string, hl->u.def.section, ref->abfd, ncrs);
d446 1
d456 1
d494 1
d520 1
d546 4
a549 1
     against the section symbol.  */
d552 1
d573 8
@


1.11
log
@update copyright dates
@
text
@d20 1
a20 1
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.10
log
@	PR 44
	* ldcref.c (check_section_sym_xref): Delete.
	(check_local_sym_xref): New function.
	(check_nocrossrefs): Adjust call.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 2000, 2002, 2003
@


1.9
log
@Convert to C90
@
text
@d72 1
a72 1
static void check_section_sym_xref (lang_input_statement_type *);
d139 1
a139 1
   symbol that is seen during the link.  */
d333 1
a333 1
  lang_for_each_file (check_section_sym_xref);
d336 1
a336 1
/* Checks for prohibited cross references to section symbols.  */
d339 1
a339 1
check_section_sym_xref (lang_input_statement_type *statement)
d342 2
a343 1
  asection *sec;
d349 4
a352 1
  for (sec = abfd->sections; sec != NULL; sec = sec->next)
d354 2
a355 1
      asection *outsec;
d357 21
a377 2
      outsec = sec->output_section;
      if (outsec != NULL)
d379 1
a379 1
	  const char *outsecname;
d383 4
a386 1
	  outsecname = outsec->name;
d390 1
a390 1
		check_refs (NULL, sec, abfd, ncrs);
d393 3
@


1.8
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d2 2
a3 1
   Copyright 1996, 1997, 1998, 2000, 2002 Free Software Foundation, Inc.
d69 1
a69 1
/* Local functions.  */
d71 6
a76 10
static struct bfd_hash_entry *cref_hash_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
static bfd_boolean cref_fill_array PARAMS ((struct cref_hash_entry *, PTR));
static int cref_sort_array PARAMS ((const PTR, const PTR));
static void output_one_cref PARAMS ((FILE *, struct cref_hash_entry *));
static bfd_boolean check_nocrossref PARAMS ((struct cref_hash_entry *, PTR));
static void check_section_sym_xref PARAMS ((lang_input_statement_type *));
static void check_refs
  PARAMS ((const char *, asection *, bfd *, struct lang_nocrossrefs *));
static void check_reloc_refs PARAMS ((bfd *, asection *, PTR));
d89 1
a89 1
    (bfd_boolean (*) PARAMS ((struct bfd_hash_entry *, PTR))) (func),	\
d107 3
a109 4
cref_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
d119 1
a119 1
    return (struct bfd_hash_entry *) ret;
d131 1
a131 1
         table.  */
d135 1
a135 1
  return (struct bfd_hash_entry *) ret;
d142 4
a145 5
add_cref (name, abfd, section, value)
     const char *name;
     bfd *abfd;
     asection *section;
     bfd_vma value ATTRIBUTE_UNUSED;
d167 1
a167 1
      r = (struct cref_ref *) xmalloc (sizeof *r);
d189 1
a189 3
cref_fill_array (h, data)
     struct cref_hash_entry *h;
     PTR data;
d191 1
a191 1
  struct cref_hash_entry ***pph = (struct cref_hash_entry ***) data;
d206 1
a206 3
cref_sort_array (a1, a2)
     const PTR a1;
     const PTR a2;
d208 2
a209 2
  const struct cref_hash_entry **p1 = (const struct cref_hash_entry **) a1;
  const struct cref_hash_entry **p2 = (const struct cref_hash_entry **) a2;
d219 1
a219 2
output_cref (fp)
     FILE *fp;
d242 1
a242 2
  csyms = ((struct cref_hash_entry **)
	   xmalloc (cref_symcount * sizeof (*csyms)));
d258 1
a258 3
output_one_cref (fp, h)
     FILE *fp;
     struct cref_hash_entry *h;
d326 1
a326 1
check_nocrossrefs ()
d331 1
a331 1
  cref_hash_traverse (&cref_table, check_nocrossref, (PTR) NULL);
d339 1
a339 2
check_section_sym_xref (statement)
     lang_input_statement_type *statement;
d371 1
a371 3
check_nocrossref (h, ignore)
     struct cref_hash_entry *h;
     PTR ignore ATTRIBUTE_UNUSED;
d423 4
a426 5
check_refs (name, sec, abfd, ncrs)
     const char *name;
     asection *sec;
     bfd *abfd;
     struct lang_nocrossrefs *ncrs;
d438 1
a438 1
  li = (lang_input_statement_type *) abfd->usrdata;
d449 1
a449 1
      asymbols = (asymbol **) xmalloc (symsize);
d464 1
a464 1
  bfd_map_over_sections (abfd, check_reloc_refs, (PTR) &info);
d477 1
a477 4
check_reloc_refs (abfd, sec, iarg)
     bfd *abfd;
     asection *sec;
     PTR iarg;
d479 1
a479 1
  struct check_refs_info *info = (struct check_refs_info *) iarg;
d521 1
a521 1
  relpp = (arelent **) xmalloc (relsize);
d540 3
a542 3
             in OUTSECNAME.  This reloc is from a section which is
             mapped into a section from which references to OUTSECNAME
             are prohibited.  We must report an error.  */
@


1.7
log
@	* ldcref.c (check_section_sym_xref): New function.
	(check_nocrossrefs): Call it.
	(check_nocrossref): Interate over h->refs here instead of..
	(check_refs): ..here.  Pass in the symbol name, section, and bfd
	rather than hash_entry pointers.
	(struct check_refs_info): Keep symbol name rather than hash entry.
	Remove "same".
	(check_reloc_refs): Tweak for above changes in check_refs_info.
	Only report references to section syms when symname is NULL to
	prevent duplicate messages for the same reloc.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 2000 Free Software Foundation, Inc.
d72 1
a72 1
static boolean cref_fill_array PARAMS ((struct cref_hash_entry *, PTR));
d75 1
a75 1
static boolean check_nocrossref PARAMS ((struct cref_hash_entry *, PTR));
d92 1
a92 1
    (boolean (*) PARAMS ((struct bfd_hash_entry *, PTR))) (func),	\
d101 1
a101 1
static boolean cref_initialized;
d159 1
a159 1
      cref_initialized = true;
d162 1
a162 1
  h = cref_hash_lookup (&cref_table, name, true, false);
d176 3
a178 3
      r->def = false;
      r->common = false;
      r->undef = false;
d182 1
a182 1
    r->undef = true;
d184 1
a184 1
    r->common = true;
d186 1
a186 1
    r->def = true;
d193 1
a193 1
static boolean
d207 1
a207 1
  return true;
d277 2
a278 2
  hl = bfd_link_hash_lookup (link_info.hash, h->root.string, false,
			     false, true);
d384 1
a384 1
static boolean
d396 2
a397 2
  hl = bfd_link_hash_lookup (link_info.hash, h->root.string, false,
			     false, true);
d402 1
a402 1
      return true;
d407 1
a407 1
    return true;
d411 1
a411 1
    return true;
d420 1
a420 1
  return true;
@


1.6
log
@Fixtypos in ChangeLogs, fix copyright dates in files
@
text
@d76 1
d78 1
a78 2
  PARAMS ((struct cref_hash_entry *, struct bfd_link_hash_entry *,
	   struct lang_nocrossrefs *));
d345 35
d394 1
d417 2
a418 1
	check_refs (h, hl, ncrs);
d427 1
a427 1
  struct cref_hash_entry *h;
a430 1
  boolean same;
d439 4
a442 3
check_refs (h, hl, ncrs)
     struct cref_hash_entry *h;
     struct bfd_link_hash_entry *hl;
d445 3
a447 1
  struct cref_ref *ref;
d449 10
a458 1
  for (ref = h->refs; ref != NULL; ref = ref->next)
d460 11
a470 17
      lang_input_statement_type *li;
      asymbol **asymbols;
      struct check_refs_info info;

      /* We need to look through the relocations for this BFD, to see
         if any of the relocations which refer to this symbol are from
         a prohibited section.  Note that we need to do this even for
         the BFD in which the symbol is defined, since even a single
         BFD might contain a prohibited cross reference; for this
         case, we set the SAME field in INFO, which will cause
         CHECK_RELOCS_REFS to check for relocations against the
         section as well as against the symbol.  */

      li = (lang_input_statement_type *) ref->abfd->usrdata;
      if (li != NULL && li->asymbols != NULL)
	asymbols = li->asymbols;
      else
d472 2
a473 15
	  long symsize;
	  long symbol_count;

	  symsize = bfd_get_symtab_upper_bound (ref->abfd);
	  if (symsize < 0)
	    einfo (_("%B%F: could not read symbols; %E\n"), ref->abfd);
	  asymbols = (asymbol **) xmalloc (symsize);
	  symbol_count = bfd_canonicalize_symtab (ref->abfd, asymbols);
	  if (symbol_count < 0)
	    einfo (_("%B%F: could not read symbols: %E\n"), ref->abfd);
	  if (li != NULL)
	    {
	      li->asymbols = asymbols;
	      li->symbol_count = symbol_count;
	    }
d475 1
d477 5
a481 9
      info.h = h;
      info.defsec = hl->u.def.section;
      info.ncrs = ncrs;
      info.asymbols = asymbols;
      if (ref->abfd == hl->u.def.section->owner)
	info.same = true;
      else
	info.same = false;
      bfd_map_over_sections (ref->abfd, check_reloc_refs, (PTR) &info);
d483 2
a484 3
      if (li == NULL)
	free (asymbols);
    }
d487 1
a487 1
/* This is called via bfd_map_over_sections.  INFO->H is a symbol
d491 1
a491 1
   INFO->H, then we report a prohibited cross reference error.  */
d530 2
a531 1
     INFO->H.  */
d533 1
a533 1
  symname = info->h->root.string;
d554 4
a557 3
	  && (strcmp (bfd_asymbol_name (*q->sym_ptr_ptr), symname) == 0
	      || (info->same
		  && bfd_get_section (*q->sym_ptr_ptr) == info->defsec)))
@


1.5
log
@2000-10-09  Kazu Hirata  <kazu@@hxi.com>

	* ldcref.c: Fix formatting.
	* ldctor.h: Likewise.
	* ldemul.c: Likewise.
	* ldemul.h: Likewise.
	* ldexp.c: Likewise.
	* ldexp.h: Likewise.
	* ldfile.c: Likewise.
	* ldfile.h: Likewise.
	* ld.h: Likewise.
	* ldlang.c: Likewise.
	* ldlang.h: Likewise.
	* ldmain.c: Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 1996, 97, 98, 99, 2000 Free Software Foundation, Inc.
@


1.5.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 2000 Free Software Foundation, Inc.
@


1.4
log
@2000-09-29  Kazu Hirata  <kazu@@hxi.com>

	* ldcref.c: Fix formatting.
	* ldctor.c: Likewise.
	* ldemul.c: Likewise.
	* ldexp.c: Likewise.
	* ldfile.c: Likewise.
	* ldlang.c: Likewise.
@
text
@d39 1
a39 2
struct cref_ref
{
d54 1
a54 2
struct cref_hash_entry
{
d64 1
a64 2
struct cref_hash_table
{
d389 1
a389 2
struct check_refs_info
{
@


1.3
log
@Most of these changes are really only cosmetic.  The readelf.c patch
fixes a thinko in get_dynamic_flags.  I found at least one message
string that included a `%' being passed to printf in the format
argument.
@
text
@a147 1
/*ARGSUSED*/
d244 1
a244 1
      putc (' ' , fp);
a351 1
/*ARGSUSED*/
@


1.2
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Fill in structure initializations.
@
text
@d2 1
a2 1
   Copyright (C) 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
d241 1
a241 1
  fprintf (fp, msg);
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.
d154 1
a154 1
     bfd_vma value;
d357 1
a357 1
     PTR ignore;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

