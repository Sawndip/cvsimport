head	1.51;
access;
symbols
	binutils-2_24-branch:1.50.0.2
	binutils-2_24-branchpoint:1.50
	binutils-2_21_1:1.7.2.6
	binutils-2_23_2:1.45.2.1
	binutils-2_23_1:1.45
	binutils-2_23:1.45
	binutils-2_23-branch:1.45.0.2
	binutils-2_23-branchpoint:1.45
	binutils-2_22_branch:1.40.2.3.0.2
	binutils-2_22:1.40.2.3
	binutils-2_22-branch:1.40.0.2
	binutils-2_22-branchpoint:1.40
	binutils-2_21:1.7.2.1
	binutils-2_21-branch:1.7.0.2
	binutils-2_21-branchpoint:1.7
	binutils_latest_snapshot:1.51;
locks; strict;
comment	@ * @;


1.51
date	2013.10.09.18.16.18;	author roland;	state Exp;
branches;
next	1.50;

1.50
date	2013.02.19.03.59.08;	author sandra;	state Exp;
branches
	1.50.2.1;
next	1.49;

1.49
date	2013.02.16.17.54.35;	author hjl;	state Exp;
branches;
next	1.48;

1.48
date	2013.02.16.17.50.20;	author hjl;	state Exp;
branches;
next	1.47;

1.47
date	2012.12.03.14.34.05;	author hjl;	state Exp;
branches;
next	1.46;

1.46
date	2012.10.22.04.54.25;	author amodra;	state Exp;
branches;
next	1.45;

1.45
date	2012.06.14.23.44.38;	author hjl;	state Exp;
branches
	1.45.2.1;
next	1.44;

1.44
date	2012.03.05.22.43.40;	author amodra;	state Exp;
branches;
next	1.43;

1.43
date	2011.10.20.09.50.59;	author amodra;	state Exp;
branches;
next	1.42;

1.42
date	2011.10.10.12.43.14;	author amodra;	state Exp;
branches;
next	1.41;

1.41
date	2011.10.06.10.07.17;	author amodra;	state Exp;
branches;
next	1.40;

1.40
date	2011.09.16.01.15.19;	author hjl;	state Exp;
branches
	1.40.2.1;
next	1.39;

1.39
date	2011.08.17.00.39.41;	author amodra;	state Exp;
branches;
next	1.38;

1.38
date	2011.08.09.09.27.34;	author amodra;	state Exp;
branches;
next	1.37;

1.37
date	2011.08.05.03.17.12;	author amodra;	state Exp;
branches;
next	1.36;

1.36
date	2011.07.09.06.20.52;	author amodra;	state Exp;
branches;
next	1.35;

1.35
date	2011.05.17.13.02.18;	author amodra;	state Exp;
branches;
next	1.34;

1.34
date	2011.05.16.00.58.11;	author amodra;	state Exp;
branches;
next	1.33;

1.33
date	2011.04.24.10.02.14;	author amodra;	state Exp;
branches;
next	1.32;

1.32
date	2011.04.20.00.22.08;	author amodra;	state Exp;
branches;
next	1.31;

1.31
date	2011.04.20.00.11.33;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2011.04.17.23.15.13;	author amodra;	state Exp;
branches;
next	1.29;

1.29
date	2011.03.28.10.27.07;	author jsm28;	state Exp;
branches;
next	1.28;

1.28
date	2011.03.10.10.27.50;	author davek;	state Exp;
branches;
next	1.27;

1.27
date	2011.03.10.10.22.24;	author davek;	state Exp;
branches;
next	1.26;

1.26
date	2011.03.04.23.44.01;	author hjl;	state Exp;
branches;
next	1.25;

1.25
date	2011.02.26.04.38.34;	author hjl;	state Exp;
branches;
next	1.24;

1.24
date	2011.02.24.22.58.05;	author hjl;	state Exp;
branches;
next	1.23;

1.23
date	2011.02.14.09.53.15;	author amodra;	state Exp;
branches;
next	1.22;

1.22
date	2011.01.22.10.16.29;	author rsandifo;	state Exp;
branches;
next	1.21;

1.21
date	2011.01.14.12.37.17;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2011.01.05.14.25.26;	author hjl;	state Exp;
branches;
next	1.19;

1.19
date	2010.12.06.21.47.43;	author hjl;	state Exp;
branches;
next	1.18;

1.18
date	2010.12.06.20.25.49;	author hjl;	state Exp;
branches;
next	1.17;

1.17
date	2010.12.06.12.44.51;	author hjl;	state Exp;
branches;
next	1.16;

1.16
date	2010.12.06.05.38.11;	author hjl;	state Exp;
branches;
next	1.15;

1.15
date	2010.12.06.02.28.31;	author hjl;	state Exp;
branches;
next	1.14;

1.14
date	2010.12.06.00.59.14;	author hjl;	state Exp;
branches;
next	1.13;

1.13
date	2010.12.06.00.53.20;	author hjl;	state Exp;
branches;
next	1.12;

1.12
date	2010.12.06.00.49.00;	author hjl;	state Exp;
branches;
next	1.11;

1.11
date	2010.12.06.00.00.13;	author hjl;	state Exp;
branches;
next	1.10;

1.10
date	2010.11.21.20.36.25;	author hjl;	state Exp;
branches;
next	1.9;

1.9
date	2010.11.20.17.34.16;	author hjl;	state Exp;
branches;
next	1.8;

1.8
date	2010.11.19.03.31.06;	author davek;	state Exp;
branches;
next	1.7;

1.7
date	2010.11.05.07.20.07;	author davek;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2010.11.04.12.44.54;	author amodra;	state Exp;
branches;
next	1.5;

1.5
date	2010.10.25.06.22.50;	author amodra;	state Exp;
branches;
next	1.4;

1.4
date	2010.10.20.17.01.05;	author davek;	state Exp;
branches;
next	1.3;

1.3
date	2010.10.15.16.21.41;	author davek;	state Exp;
branches;
next	1.2;

1.2
date	2010.10.15.16.09.36;	author davek;	state Exp;
branches;
next	1.1;

1.1
date	2010.10.14.01.31.31;	author davek;	state Exp;
branches;
next	;

1.50.2.1
date	2013.10.09.18.18.49;	author roland;	state Exp;
branches;
next	;

1.45.2.1
date	2013.01.21.13.48.48;	author amodra;	state Exp;
branches;
next	;

1.40.2.1
date	2011.10.25.02.51.22;	author amodra;	state Exp;
branches;
next	1.40.2.2;

1.40.2.2
date	2011.10.25.03.00.00;	author amodra;	state Exp;
branches;
next	1.40.2.3;

1.40.2.3
date	2011.10.25.03.15.08;	author amodra;	state Exp;
branches;
next	;

1.7.2.1
date	2010.11.19.03.37.18;	author davek;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2011.02.01.12.25.46;	author amodra;	state Exp;
branches;
next	1.7.2.3;

1.7.2.3
date	2011.02.14.10.03.37;	author amodra;	state Exp;
branches;
next	1.7.2.4;

1.7.2.4
date	2011.04.27.07.17.43;	author amodra;	state Exp;
branches;
next	1.7.2.5;

1.7.2.5
date	2011.05.16.00.54.45;	author amodra;	state Exp;
branches;
next	1.7.2.6;

1.7.2.6
date	2011.05.29.04.51.49;	author amodra;	state Exp;
branches;
next	;


desc
@@


1.51
log
@ld/
	* emultempl/elf32.em (id_note_section_size): Use ATTRIBUTE_UNUSED
	rather than a dummy assignment for unused parameter.
	* plugin.c (get_input_file, release_input_file): Likewise.
@
text
@/* Plugin control for the GNU linker.
   Copyright 2010, 2011, 2012, 2013 Free Software Foundation, Inc.

   This file is part of the GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "libiberty.h"
#include "bfd.h"
#include "bfdlink.h"
#include "bfdver.h"
#include "ld.h"
#include "ldmain.h"
#include "ldmisc.h"
#include "ldexp.h"
#include "ldlang.h"
#include "ldfile.h"
#include "plugin.h"
#include "plugin-api.h"
#include "elf-bfd.h"
#if !defined (HAVE_DLFCN_H) && defined (HAVE_WINDOWS_H)
#include <windows.h>
#endif

/* Report plugin symbols.  */
bfd_boolean report_plugin_symbols;

/* The suffix to append to the name of the real (claimed) object file
   when generating a dummy BFD to hold the IR symbols sent from the
   plugin.  For cosmetic use only; appears in maps, crefs etc.  */
#define IRONLY_SUFFIX " (symbol from plugin)"

/* Stores a single argument passed to a plugin.  */
typedef struct plugin_arg
{
  struct plugin_arg *next;
  const char *arg;
} plugin_arg_t;

/* Holds all details of a single plugin.  */
typedef struct plugin
{
  /* Next on the list of plugins, or NULL at end of chain.  */
  struct plugin *next;
  /* The argument string given to --plugin.  */
  const char *name;
  /* The shared library handle returned by dlopen.  */
  void *dlhandle;
  /* The list of argument string given to --plugin-opt.  */
  plugin_arg_t *args;
  /* Number of args in the list, for convenience.  */
  size_t n_args;
  /* The plugin's event handlers.  */
  ld_plugin_claim_file_handler claim_file_handler;
  ld_plugin_all_symbols_read_handler all_symbols_read_handler;
  ld_plugin_cleanup_handler cleanup_handler;
  /* TRUE if the cleanup handlers have been called.  */
  bfd_boolean cleanup_done;
} plugin_t;

/* The master list of all plugins.  */
static plugin_t *plugins_list = NULL;

/* We keep a tail pointer for easy linking on the end.  */
static plugin_t **plugins_tail_chain_ptr = &plugins_list;

/* The last plugin added to the list, for receiving args.  */
static plugin_t *last_plugin = NULL;

/* The tail of the arg chain of the last plugin added to the list.  */
static plugin_arg_t **last_plugin_args_tail_chain_ptr = NULL;

/* The plugin which is currently having a callback executed.  */
static plugin_t *called_plugin = NULL;

/* Last plugin to cause an error, if any.  */
static const char *error_plugin = NULL;

/* State of linker "notice" interface before we poked at it.  */
static bfd_boolean orig_notice_all;

/* Original linker callbacks, and the plugin version.  */
static const struct bfd_link_callbacks *orig_callbacks;
static struct bfd_link_callbacks plugin_callbacks;

/* Set at all symbols read time, to avoid recursively offering the plugin
   its own newly-added input files and libs to claim.  */
bfd_boolean no_more_claiming = FALSE;

/* List of tags to set in the constant leading part of the tv array. */
static const enum ld_plugin_tag tv_header_tags[] =
{
  LDPT_MESSAGE,
  LDPT_API_VERSION,
  LDPT_GNU_LD_VERSION,
  LDPT_LINKER_OUTPUT,
  LDPT_OUTPUT_NAME,
  LDPT_REGISTER_CLAIM_FILE_HOOK,
  LDPT_REGISTER_ALL_SYMBOLS_READ_HOOK,
  LDPT_REGISTER_CLEANUP_HOOK,
  LDPT_ADD_SYMBOLS,
  LDPT_GET_INPUT_FILE,
  LDPT_RELEASE_INPUT_FILE,
  LDPT_GET_SYMBOLS,
  LDPT_GET_SYMBOLS_V2,
  LDPT_ADD_INPUT_FILE,
  LDPT_ADD_INPUT_LIBRARY,
  LDPT_SET_EXTRA_LIBRARY_PATH
};

/* How many entries in the constant leading part of the tv array.  */
static const size_t tv_header_size = ARRAY_SIZE (tv_header_tags);

/* Forward references.  */
static bfd_boolean plugin_notice (struct bfd_link_info *,
				  struct bfd_link_hash_entry *, bfd *,
				  asection *, bfd_vma, flagword, const char *);

#if !defined (HAVE_DLFCN_H) && defined (HAVE_WINDOWS_H)

#define RTLD_NOW 0	/* Dummy value.  */

static void *
dlopen (const char *file, int mode ATTRIBUTE_UNUSED)
{
  return LoadLibrary (file);
}

static void *
dlsym (void *handle, const char *name)
{
  return GetProcAddress (handle, name);
}

static int
dlclose (void *handle)
{
  FreeLibrary (handle);
  return 0;
}

#endif /* !defined (HAVE_DLFCN_H) && defined (HAVE_WINDOWS_H)  */

#ifndef HAVE_DLFCN_H
static const char *
dlerror (void)
{
  return "";
}
#endif

/* Helper function for exiting with error status.  */
static int
set_plugin_error (const char *plugin)
{
  error_plugin = plugin;
  return -1;
}

/* Test if an error occurred.  */
static bfd_boolean
plugin_error_p (void)
{
  return error_plugin != NULL;
}

/* Return name of plugin which caused an error if any.  */
const char *
plugin_error_plugin (void)
{
  return error_plugin ? error_plugin : _("<no plugin>");
}

/* Handle -plugin arg: find and load plugin, or return error.  */
void
plugin_opt_plugin (const char *plugin)
{
  plugin_t *newplug;

  newplug = xmalloc (sizeof *newplug);
  memset (newplug, 0, sizeof *newplug);
  newplug->name = plugin;
  newplug->dlhandle = dlopen (plugin, RTLD_NOW);
  if (!newplug->dlhandle)
    einfo (_("%P%F: %s: error loading plugin: %s\n"), plugin, dlerror ());

  /* Chain on end, so when we run list it is in command-line order.  */
  *plugins_tail_chain_ptr = newplug;
  plugins_tail_chain_ptr = &newplug->next;

  /* Record it as current plugin for receiving args.  */
  last_plugin = newplug;
  last_plugin_args_tail_chain_ptr = &newplug->args;
}

/* Accumulate option arguments for last-loaded plugin, or return
   error if none.  */
int
plugin_opt_plugin_arg (const char *arg)
{
  plugin_arg_t *newarg;

  if (!last_plugin)
    return set_plugin_error (_("<no plugin>"));

  newarg = xmalloc (sizeof *newarg);
  newarg->arg = arg;
  newarg->next = NULL;

  /* Chain on end to preserve command-line order.  */
  *last_plugin_args_tail_chain_ptr = newarg;
  last_plugin_args_tail_chain_ptr = &newarg->next;
  last_plugin->n_args++;
  return 0;
}

/* Create a dummy BFD.  */
bfd *
plugin_get_ir_dummy_bfd (const char *name, bfd *srctemplate)
{
  bfd *abfd;

  bfd_use_reserved_id = 1;
  abfd = bfd_create (concat (name, IRONLY_SUFFIX, (const char *) NULL),
		     srctemplate);
  if (abfd != NULL)
    {
      abfd->flags |= BFD_LINKER_CREATED | BFD_PLUGIN;
      bfd_set_arch_info (abfd, bfd_get_arch_info (srctemplate));
      bfd_set_gp_size (abfd, bfd_get_gp_size (srctemplate));
      if (bfd_make_writable (abfd)
	  && bfd_copy_private_bfd_data (srctemplate, abfd))
	{
	  flagword flags;

	  /* Create section to own the symbols.  */
	  flags = (SEC_CODE | SEC_HAS_CONTENTS | SEC_READONLY
		   | SEC_ALLOC | SEC_LOAD | SEC_KEEP | SEC_EXCLUDE);
	  if (bfd_make_section_anyway_with_flags (abfd, ".text", flags))
	    return abfd;
	}
    }
  einfo (_("could not create dummy IR bfd: %F%E\n"));
  return NULL;
}

/* Check if the BFD passed in is an IR dummy object file.  */
static bfd_boolean
is_ir_dummy_bfd (const bfd *abfd)
{
  /* ABFD can sometimes legitimately be NULL, e.g. when called from one
     of the linker callbacks for a symbol in the *ABS* or *UND* sections.
     Likewise, the usrdata field may be NULL if ABFD was added by the
     backend without a corresponding input statement, as happens e.g.
     when processing DT_NEEDED dependencies.  */
  return (abfd
	  && abfd->usrdata
	  && ((lang_input_statement_type *)(abfd->usrdata))->flags.claimed);
}

/* Helpers to convert between BFD and GOLD symbol formats.  */
static enum ld_plugin_status
asymbol_from_plugin_symbol (bfd *abfd, asymbol *asym,
			    const struct ld_plugin_symbol *ldsym)
{
  flagword flags = BSF_NO_FLAGS;
  struct bfd_section *section;

  asym->the_bfd = abfd;
  asym->name = (ldsym->version
		? concat (ldsym->name, "@@", ldsym->version, (const char *) NULL)
		: ldsym->name);
  asym->value = 0;
  switch (ldsym->def)
    {
    case LDPK_WEAKDEF:
      flags = BSF_WEAK;
      /* FALLTHRU */
    case LDPK_DEF:
      flags |= BSF_GLOBAL;
      if (ldsym->comdat_key)
	{
	  char *name = concat (".gnu.linkonce.t.", ldsym->comdat_key,
			       (const char *) NULL);
	  section = bfd_get_section_by_name (abfd, name);
	  if (section != NULL)
	    free (name);
	  else
	    {
	      flagword sflags;

	      sflags = (SEC_CODE | SEC_HAS_CONTENTS | SEC_READONLY
			| SEC_ALLOC | SEC_LOAD | SEC_KEEP | SEC_EXCLUDE
			| SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD);
	      section = bfd_make_section_anyway_with_flags (abfd, name, sflags);
	      if (section == NULL)
		return LDPS_ERR;
	    }
	}
      else
	section = bfd_get_section_by_name (abfd, ".text");
      break;

    case LDPK_WEAKUNDEF:
      flags = BSF_WEAK;
      /* FALLTHRU */
    case LDPK_UNDEF:
      section = bfd_und_section_ptr;
      break;

    case LDPK_COMMON:
      flags = BSF_GLOBAL;
      section = bfd_com_section_ptr;
      asym->value = ldsym->size;
      /* For ELF targets, set alignment of common symbol to 1.  */
      if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)
	{
	  ((elf_symbol_type *) asym)->internal_elf_sym.st_shndx = SHN_COMMON;
	  ((elf_symbol_type *) asym)->internal_elf_sym.st_value = 1;
	}
      break;

    default:
      return LDPS_ERR;
    }
  asym->flags = flags;
  asym->section = section;

  /* Visibility only applies on ELF targets.  */
  if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)
    {
      elf_symbol_type *elfsym = elf_symbol_from (abfd, asym);
      unsigned char visibility;

      if (!elfsym)
	einfo (_("%P%F: %s: non-ELF symbol in ELF BFD!\n"), asym->name);
      switch (ldsym->visibility)
	{
	default:
	  einfo (_("%P%F: unknown ELF symbol visibility: %d!\n"),
		 ldsym->visibility);
	case LDPV_DEFAULT:
	  visibility = STV_DEFAULT;
	  break;
	case LDPV_PROTECTED:
	  visibility = STV_PROTECTED;
	  break;
	case LDPV_INTERNAL:
	  visibility = STV_INTERNAL;
	  break;
	case LDPV_HIDDEN:
	  visibility = STV_HIDDEN;
	  break;
	}
      elfsym->internal_elf_sym.st_other
	= (visibility | (elfsym->internal_elf_sym.st_other
			 & ~ELF_ST_VISIBILITY (-1)));
    }

  return LDPS_OK;
}

/* Register a claim-file handler.  */
static enum ld_plugin_status
register_claim_file (ld_plugin_claim_file_handler handler)
{
  ASSERT (called_plugin);
  called_plugin->claim_file_handler = handler;
  return LDPS_OK;
}

/* Register an all-symbols-read handler.  */
static enum ld_plugin_status
register_all_symbols_read (ld_plugin_all_symbols_read_handler handler)
{
  ASSERT (called_plugin);
  called_plugin->all_symbols_read_handler = handler;
  return LDPS_OK;
}

/* Register a cleanup handler.  */
static enum ld_plugin_status
register_cleanup (ld_plugin_cleanup_handler handler)
{
  ASSERT (called_plugin);
  called_plugin->cleanup_handler = handler;
  return LDPS_OK;
}

/* Add symbols from a plugin-claimed input file.  */
static enum ld_plugin_status
add_symbols (void *handle, int nsyms, const struct ld_plugin_symbol *syms)
{
  asymbol **symptrs;
  bfd *abfd = handle;
  int n;

  ASSERT (called_plugin);
  symptrs = xmalloc (nsyms * sizeof *symptrs);
  for (n = 0; n < nsyms; n++)
    {
      enum ld_plugin_status rv;
      asymbol *bfdsym;

      bfdsym = bfd_make_empty_symbol (abfd);
      symptrs[n] = bfdsym;
      rv = asymbol_from_plugin_symbol (abfd, bfdsym, syms + n);
      if (rv != LDPS_OK)
	return rv;
    }
  bfd_set_symtab (abfd, symptrs, nsyms);
  return LDPS_OK;
}

/* Get the input file information with an open (possibly re-opened)
   file descriptor.  */
static enum ld_plugin_status
get_input_file (const void *handle ATTRIBUTE_UNUSED,
                struct ld_plugin_input_file *file ATTRIBUTE_UNUSED)
{
  ASSERT (called_plugin);
  return LDPS_ERR;
}

/* Release the input file.  */
static enum ld_plugin_status
release_input_file (const void *handle ATTRIBUTE_UNUSED)
{
  ASSERT (called_plugin);
  return LDPS_ERR;
}

/* Return TRUE if a defined symbol might be reachable from outside the
   universe of claimed objects.  */
static inline bfd_boolean
is_visible_from_outside (struct ld_plugin_symbol *lsym,
			 struct bfd_link_hash_entry *blhe)
{
  struct bfd_sym_chain *sym;

  if (link_info.relocatable)
    return TRUE;
  if (link_info.export_dynamic || !link_info.executable)
    {
      /* Check if symbol is hidden by version script.  */
      if (bfd_hide_sym_by_version (link_info.version_info,
				   blhe->root.string))
	return FALSE;
      /* Only ELF symbols really have visibility.  */
      if (bfd_get_flavour (link_info.output_bfd) == bfd_target_elf_flavour)
	{
	  struct elf_link_hash_entry *el = (struct elf_link_hash_entry *)blhe;
	  int vis = ELF_ST_VISIBILITY (el->other);
	  return vis == STV_DEFAULT || vis == STV_PROTECTED;
	}
      /* On non-ELF targets, we can safely make inferences by considering
	 what visibility the plugin would have liked to apply when it first
	 sent us the symbol.  During ELF symbol processing, visibility only
	 ever becomes more restrictive, not less, when symbols are merged,
	 so this is a conservative estimate; it may give false positives,
	 declaring something visible from outside when it in fact would
	 not have been, but this will only lead to missed optimisation
	 opportunities during LTRANS at worst; it will not give false
	 negatives, which can lead to the disastrous conclusion that the
	 related symbol is IRONLY.  (See GCC PR46319 for an example.)  */
      return (lsym->visibility == LDPV_DEFAULT
	      || lsym->visibility == LDPV_PROTECTED);
    }

  for (sym = &entry_symbol; sym != NULL; sym = sym->next)
    if (sym->name
	&& strcmp (sym->name, blhe->root.string) == 0)
      return TRUE;

  return FALSE;
}

/* Get the symbol resolution info for a plugin-claimed input file.  */
static enum ld_plugin_status
get_symbols (const void *handle, int nsyms, struct ld_plugin_symbol *syms,
	     int def_ironly_exp)
{
  const bfd *abfd = handle;
  int n;

  ASSERT (called_plugin);
  for (n = 0; n < nsyms; n++)
    {
      struct bfd_link_hash_entry *blhe;
      asection *owner_sec;
      int res;

      if (syms[n].def != LDPK_UNDEF)
	blhe = bfd_link_hash_lookup (link_info.hash, syms[n].name,
				     FALSE, FALSE, TRUE);
      else
	blhe = bfd_wrapped_link_hash_lookup (link_info.output_bfd, &link_info,
					     syms[n].name, FALSE, FALSE, TRUE);
      if (!blhe)
	{
	  res = LDPR_UNKNOWN;
	  goto report_symbol;
	}

      /* Determine resolution from blhe type and symbol's original type.  */
      if (blhe->type == bfd_link_hash_undefined
	  || blhe->type == bfd_link_hash_undefweak)
	{
	  res = LDPR_UNDEF;
	  goto report_symbol;
	}
      if (blhe->type != bfd_link_hash_defined
	  && blhe->type != bfd_link_hash_defweak
	  && blhe->type != bfd_link_hash_common)
	{
	  /* We should not have a new, indirect or warning symbol here.  */
	  einfo ("%P%F: %s: plugin symbol table corrupt (sym type %d)\n",
		 called_plugin->name, blhe->type);
	}

      /* Find out which section owns the symbol.  Since it's not undef,
	 it must have an owner; if it's not a common symbol, both defs
	 and weakdefs keep it in the same place. */
      owner_sec = (blhe->type == bfd_link_hash_common
		   ? blhe->u.c.p->section
		   : blhe->u.def.section);


      /* If it was originally undefined or common, then it has been
	 resolved; determine how.  */
      if (syms[n].def == LDPK_UNDEF
	  || syms[n].def == LDPK_WEAKUNDEF
	  || syms[n].def == LDPK_COMMON)
	{
	  if (owner_sec->owner == link_info.output_bfd)
	    res = LDPR_RESOLVED_EXEC;
	  else if (owner_sec->owner == abfd)
	    res = LDPR_PREVAILING_DEF_IRONLY;
	  else if (is_ir_dummy_bfd (owner_sec->owner))
	    res = LDPR_RESOLVED_IR;
	  else if (owner_sec->owner != NULL
		   && (owner_sec->owner->flags & DYNAMIC) != 0)
	    res = LDPR_RESOLVED_DYN;
	  else
	    res = LDPR_RESOLVED_EXEC;
	}

      /* Was originally def, or weakdef.  Does it prevail?  If the
	 owner is the original dummy bfd that supplied it, then this
	 is the definition that has prevailed.  */
      else if (owner_sec->owner == link_info.output_bfd)
	res = LDPR_PREEMPTED_REG;
      else if (owner_sec->owner == abfd)
	res = LDPR_PREVAILING_DEF_IRONLY;

      /* Was originally def, weakdef, or common, but has been pre-empted.  */
      else if (is_ir_dummy_bfd (owner_sec->owner))
	res = LDPR_PREEMPTED_IR;
      else
	res = LDPR_PREEMPTED_REG;

      if (res == LDPR_PREVAILING_DEF_IRONLY)
	{
	  /* We need to know if the sym is referenced from non-IR files.  Or
	     even potentially-referenced, perhaps in a future final link if
	     this is a partial one, perhaps dynamically at load-time if the
	     symbol is externally visible.  */
	  if (blhe->non_ir_ref)
	    res = LDPR_PREVAILING_DEF;
	  else if (is_visible_from_outside (&syms[n], blhe))
	    res = def_ironly_exp;
	}

    report_symbol:
      syms[n].resolution = res;
      if (report_plugin_symbols)
	einfo (_("%P: %B: symbol `%s' "
		 "definition: %d, visibility: %d, resolution: %d\n"),
	       abfd, syms[n].name,
	       syms[n].def, syms[n].visibility, res);
    }
  return LDPS_OK;
}

static enum ld_plugin_status
get_symbols_v1 (const void *handle, int nsyms, struct ld_plugin_symbol *syms)
{
  return get_symbols (handle, nsyms, syms, LDPR_PREVAILING_DEF);
}

static enum ld_plugin_status
get_symbols_v2 (const void *handle, int nsyms, struct ld_plugin_symbol *syms)
{
  return get_symbols (handle, nsyms, syms, LDPR_PREVAILING_DEF_IRONLY_EXP);
}

/* Add a new (real) input file generated by a plugin.  */
static enum ld_plugin_status
add_input_file (const char *pathname)
{
  ASSERT (called_plugin);
  if (!lang_add_input_file (xstrdup (pathname), lang_input_file_is_file_enum,
			    NULL))
    return LDPS_ERR;
  return LDPS_OK;
}

/* Add a new (real) library required by a plugin.  */
static enum ld_plugin_status
add_input_library (const char *pathname)
{
  ASSERT (called_plugin);
  if (!lang_add_input_file (xstrdup (pathname), lang_input_file_is_l_enum,
			    NULL))
    return LDPS_ERR;
  return LDPS_OK;
}

/* Set the extra library path to be used by libraries added via
   add_input_library.  */
static enum ld_plugin_status
set_extra_library_path (const char *path)
{
  ASSERT (called_plugin);
  ldfile_add_library_path (xstrdup (path), FALSE);
  return LDPS_OK;
}

/* Issue a diagnostic message from a plugin.  */
static enum ld_plugin_status
message (int level, const char *format, ...)
{
  va_list args;
  va_start (args, format);

  switch (level)
    {
    case LDPL_INFO:
      vfinfo (stdout, format, args, FALSE);
      putchar ('\n');
      break;
    case LDPL_WARNING:
      vfinfo (stdout, format, args, TRUE);
      putchar ('\n');
      break;
    case LDPL_FATAL:
    case LDPL_ERROR:
    default:
      {
	char *newfmt = ACONCAT ((level == LDPL_FATAL ? "%P%F: " : "%P%X: ",
				 format, "\n", (const char *) NULL));
	fflush (stdout);
	vfinfo (stderr, newfmt, args, TRUE);
	fflush (stderr);
      }
      break;
    }

  va_end (args);
  return LDPS_OK;
}

/* Helper to size leading part of tv array and set it up. */
static void
set_tv_header (struct ld_plugin_tv *tv)
{
  size_t i;

  /* Version info.  */
  static const unsigned int major = (unsigned)(BFD_VERSION / 100000000UL);
  static const unsigned int minor = (unsigned)(BFD_VERSION / 1000000UL) % 100;

  for (i = 0; i < tv_header_size; i++)
    {
      tv[i].tv_tag = tv_header_tags[i];
#define TVU(x) tv[i].tv_u.tv_ ## x
      switch (tv[i].tv_tag)
	{
	case LDPT_MESSAGE:
	  TVU(message) = message;
	  break;
	case LDPT_API_VERSION:
	  TVU(val) = LD_PLUGIN_API_VERSION;
	  break;
	case LDPT_GNU_LD_VERSION:
	  TVU(val) = major * 100 + minor;
	  break;
	case LDPT_LINKER_OUTPUT:
	  TVU(val) = (link_info.relocatable
		      ? LDPO_REL
		      : (link_info.executable
			 ? (link_info.pie ? LDPO_PIE : LDPO_EXEC)
			 : LDPO_DYN));
	  break;
	case LDPT_OUTPUT_NAME:
	  TVU(string) = output_filename;
	  break;
	case LDPT_REGISTER_CLAIM_FILE_HOOK:
	  TVU(register_claim_file) = register_claim_file;
	  break;
	case LDPT_REGISTER_ALL_SYMBOLS_READ_HOOK:
	  TVU(register_all_symbols_read) = register_all_symbols_read;
	  break;
	case LDPT_REGISTER_CLEANUP_HOOK:
	  TVU(register_cleanup) = register_cleanup;
	  break;
	case LDPT_ADD_SYMBOLS:
	  TVU(add_symbols) = add_symbols;
	  break;
	case LDPT_GET_INPUT_FILE:
	  TVU(get_input_file) = get_input_file;
	  break;
	case LDPT_RELEASE_INPUT_FILE:
	  TVU(release_input_file) = release_input_file;
	  break;
	case LDPT_GET_SYMBOLS:
	  TVU(get_symbols) = get_symbols_v1;
	  break;
	case LDPT_GET_SYMBOLS_V2:
	  TVU(get_symbols) = get_symbols_v2;
	  break;
	case LDPT_ADD_INPUT_FILE:
	  TVU(add_input_file) = add_input_file;
	  break;
	case LDPT_ADD_INPUT_LIBRARY:
	  TVU(add_input_library) = add_input_library;
	  break;
	case LDPT_SET_EXTRA_LIBRARY_PATH:
	  TVU(set_extra_library_path) = set_extra_library_path;
	  break;
	default:
	  /* Added a new entry to the array without adding
	     a new case to set up its value is a bug.  */
	  FAIL ();
	}
#undef TVU
    }
}

/* Append the per-plugin args list and trailing LDPT_NULL to tv.  */
static void
set_tv_plugin_args (plugin_t *plugin, struct ld_plugin_tv *tv)
{
  plugin_arg_t *arg = plugin->args;
  while (arg)
    {
      tv->tv_tag = LDPT_OPTION;
      tv->tv_u.tv_string = arg->arg;
      arg = arg->next;
      tv++;
    }
  tv->tv_tag = LDPT_NULL;
  tv->tv_u.tv_val = 0;
}

/* Return true if any plugins are active this run.  Only valid
   after options have been processed.  */
bfd_boolean
plugin_active_plugins_p (void)
{
  return plugins_list != NULL;
}

/* Load up and initialise all plugins after argument parsing.  */
void
plugin_load_plugins (void)
{
  struct ld_plugin_tv *my_tv;
  unsigned int max_args = 0;
  plugin_t *curplug = plugins_list;

  /* If there are no plugins, we need do nothing this run.  */
  if (!curplug)
    return;

  /* First pass over plugins to find max # args needed so that we
     can size and allocate the tv array.  */
  while (curplug)
    {
      if (curplug->n_args > max_args)
	max_args = curplug->n_args;
      curplug = curplug->next;
    }

  /* Allocate tv array and initialise constant part.  */
  my_tv = xmalloc ((max_args + 1 + tv_header_size) * sizeof *my_tv);
  set_tv_header (my_tv);

  /* Pass over plugins again, activating them.  */
  curplug = plugins_list;
  while (curplug)
    {
      enum ld_plugin_status rv;
      ld_plugin_onload onloadfn;

      onloadfn = (ld_plugin_onload) dlsym (curplug->dlhandle, "onload");
      if (!onloadfn)
	onloadfn = (ld_plugin_onload) dlsym (curplug->dlhandle, "_onload");
      if (!onloadfn)
        einfo (_("%P%F: %s: error loading plugin: %s\n"),
	       curplug->name, dlerror ());
      set_tv_plugin_args (curplug, &my_tv[tv_header_size]);
      called_plugin = curplug;
      rv = (*onloadfn) (my_tv);
      called_plugin = NULL;
      if (rv != LDPS_OK)
	einfo (_("%P%F: %s: plugin error: %d\n"), curplug->name, rv);
      curplug = curplug->next;
    }

  /* Since plugin(s) inited ok, assume they're going to want symbol
     resolutions, which needs us to track which symbols are referenced
     by non-IR files using the linker's notice callback.  */
  orig_notice_all = link_info.notice_all;
  orig_callbacks = link_info.callbacks;
  plugin_callbacks = *orig_callbacks;
  plugin_callbacks.notice = &plugin_notice;
  link_info.notice_all = TRUE;
  link_info.callbacks = &plugin_callbacks;
}

/* Call 'claim file' hook for all plugins.  */
static int
plugin_call_claim_file (const struct ld_plugin_input_file *file, int *claimed)
{
  plugin_t *curplug = plugins_list;
  *claimed = FALSE;
  if (no_more_claiming)
    return 0;
  while (curplug && !*claimed)
    {
      if (curplug->claim_file_handler)
	{
	  enum ld_plugin_status rv;
	  called_plugin = curplug;
	  rv = (*curplug->claim_file_handler) (file, claimed);
	  called_plugin = NULL;
	  if (rv != LDPS_OK)
	    set_plugin_error (curplug->name);
	}
      curplug = curplug->next;
    }
  return plugin_error_p () ? -1 : 0;
}

void
plugin_maybe_claim (struct ld_plugin_input_file *file,
		    lang_input_statement_type *entry)
{
  int claimed = 0;

  /* We create a dummy BFD, initially empty, to house whatever symbols
     the plugin may want to add.  */
  file->handle = plugin_get_ir_dummy_bfd (entry->the_bfd->filename,
					  entry->the_bfd);
  if (plugin_call_claim_file (file, &claimed))
    einfo (_("%P%F: %s: plugin reported error claiming file\n"),
	   plugin_error_plugin ());
  /* fd belongs to us, not the plugin; but we don't need it.  */
  close (file->fd);
  if (claimed)
    {
      /* Discard the real file's BFD and substitute the dummy one.  */

      /* BFD archive handling caches elements so we can't call
	 bfd_close for archives.  */
      if (entry->the_bfd->my_archive == NULL)
	bfd_close (entry->the_bfd);
      entry->the_bfd = file->handle;
      entry->flags.claimed = TRUE;
      bfd_make_readable (entry->the_bfd);
    }
  else
    {
      /* If plugin didn't claim the file, we don't need the dummy bfd.
	 Can't avoid speculatively creating it, alas.  */
      bfd_close_all_done (file->handle);
      entry->flags.claimed = FALSE;
    }
}

/* Call 'all symbols read' hook for all plugins.  */
int
plugin_call_all_symbols_read (void)
{
  plugin_t *curplug = plugins_list;

  /* Disable any further file-claiming.  */
  no_more_claiming = TRUE;

  while (curplug)
    {
      if (curplug->all_symbols_read_handler)
	{
	  enum ld_plugin_status rv;
	  called_plugin = curplug;
	  rv = (*curplug->all_symbols_read_handler) ();
	  called_plugin = NULL;
	  if (rv != LDPS_OK)
	    set_plugin_error (curplug->name);
	}
      curplug = curplug->next;
    }
  return plugin_error_p () ? -1 : 0;
}

/* Call 'cleanup' hook for all plugins at exit.  */
void
plugin_call_cleanup (void)
{
  plugin_t *curplug = plugins_list;
  while (curplug)
    {
      if (curplug->cleanup_handler && !curplug->cleanup_done)
	{
	  enum ld_plugin_status rv;
	  curplug->cleanup_done = TRUE;
	  called_plugin = curplug;
	  rv = (*curplug->cleanup_handler) ();
	  called_plugin = NULL;
	  if (rv != LDPS_OK)
	    info_msg (_("%P: %s: error in plugin cleanup: %d (ignored)\n"),
		      curplug->name, rv);
	  dlclose (curplug->dlhandle);
	}
      curplug = curplug->next;
    }
}

/* To determine which symbols should be resolved LDPR_PREVAILING_DEF
   and which LDPR_PREVAILING_DEF_IRONLY, we notice all the symbols as
   the linker adds them to the linker hash table.  Mark those
   referenced from a non-IR file with non_ir_ref.  We have to
   notice_all symbols, because we won't necessarily know until later
   which ones will be contributed by IR files.  */
static bfd_boolean
plugin_notice (struct bfd_link_info *info,
	       struct bfd_link_hash_entry *h,
	       bfd *abfd,
	       asection *section,
	       bfd_vma value,
	       flagword flags,
	       const char *string)
{
  if (h != NULL)
    {
      bfd *sym_bfd;

      /* Nothing to do here if this def/ref is from an IR dummy BFD.  */
      if (is_ir_dummy_bfd (abfd))
	;

      /* Making an indirect symbol counts as a reference unless this
	 is a brand new symbol.  */
      else if (bfd_is_ind_section (section)
	       || (flags & BSF_INDIRECT) != 0)
	{
	  if (h->type != bfd_link_hash_new)
	    {
	      struct bfd_link_hash_entry *inh;

	      h->non_ir_ref = TRUE;
	      inh = bfd_wrapped_link_hash_lookup (abfd, info, string, FALSE,
						  FALSE, FALSE);
	      if (inh != NULL)
		inh->non_ir_ref = TRUE;
	    }
	}

      /* Nothing to do here for warning symbols.  */
      else if ((flags & BSF_WARNING) != 0)
	;

      /* Nothing to do here for constructor symbols.  */
      else if ((flags & BSF_CONSTRUCTOR) != 0)
	;

      /* If this is a ref, set non_ir_ref.  */
      else if (bfd_is_und_section (section))
	{
	  /* Replace the undefined dummy bfd with the real one.  */
	  if ((h->type == bfd_link_hash_undefined
	       || h->type == bfd_link_hash_undefweak)
	      && (h->u.undef.abfd == NULL
		  || (h->u.undef.abfd->flags & BFD_PLUGIN) != 0))
	    h->u.undef.abfd = abfd;
	  h->non_ir_ref = TRUE;
	}

      /* Otherwise, it must be a new def.  Ensure any symbol defined
	 in an IR dummy BFD takes on a new value from a real BFD.
	 Weak symbols are not normally overridden by a new weak
	 definition, and strong symbols will normally cause multiple
	 definition errors.  Avoid this by making the symbol appear
	 to be undefined.  */
      else if (((h->type == bfd_link_hash_defweak
		 || h->type == bfd_link_hash_defined)
		&& is_ir_dummy_bfd (sym_bfd = h->u.def.section->owner))
	       || (h->type == bfd_link_hash_common
		   && is_ir_dummy_bfd (sym_bfd = h->u.c.p->section->owner)))
	{
	  h->type = bfd_link_hash_undefweak;
	  h->u.undef.abfd = sym_bfd;
	}
    }

  /* Continue with cref/nocrossref/trace-sym processing.  */
  if (h == NULL
      || orig_notice_all
      || (info->notice_hash != NULL
	  && bfd_hash_lookup (info->notice_hash, h->root.string,
			      FALSE, FALSE) != NULL))
    return (*orig_callbacks->notice) (info, h,
				      abfd, section, value, flags, string);
  return TRUE;
}

/* Return true if bfd is a dynamic library that should be reloaded.  */

bfd_boolean
plugin_should_reload (bfd *abfd)
{
  return ((abfd->flags & DYNAMIC) != 0
	  && bfd_get_flavour (abfd) == bfd_target_elf_flavour
	  && bfd_get_format (abfd) == bfd_object
	  && (elf_dyn_lib_class (abfd) & DYN_AS_NEEDED) != 0);
}
@


1.50
log
@2013-02-19  Sandra Loosemore  <sandra@@codesourcery.com>

	PR ld/15146

	ld/
	* plugin.c (plugin_notice): Add null check before dereferencing
	pointer.
@
text
@d2 1
a2 1
   Copyright 2010, 2011, 2012 Free Software Foundation, Inc.
d432 2
a433 1
get_input_file (const void *handle, struct ld_plugin_input_file *file)
a435 2
  handle = handle;
  file = file;
d441 1
a441 1
release_input_file (const void *handle)
a443 1
  handle = handle;
@


1.50.2.1
log
@ld/
	* emultempl/elf32.em (id_note_section_size): Use ATTRIBUTE_UNUSED
	rather than a dummy assignment for unused parameter.
	* plugin.c (get_input_file, release_input_file): Likewise.
@
text
@d2 1
a2 1
   Copyright 2010, 2011, 2012, 2013 Free Software Foundation, Inc.
d432 1
a432 2
get_input_file (const void *handle ATTRIBUTE_UNUSED,
                struct ld_plugin_input_file *file ATTRIBUTE_UNUSED)
d435 2
d442 1
a442 1
release_input_file (const void *handle ATTRIBUTE_UNUSED)
d445 1
@


1.49
log
@Don't add DT_NEEDED for references from the dummy bfd

bfd/

	PR ld/15146
	* elflink.c (elf_link_add_object_symbols): Don't add DT_NEEDED
	for references from the dummy bfd.

ld/

	PR ld/15146
	* plugin.c (plugin_notice): Replace the undefined dummy bfd with
	the real one.

ld/testsuite/

	PR ld/15146
	* ld-plugin/pr15146.d: New file.
	* ld-plugin/pr15146a.c: Likewise.
	* ld-plugin/pr15146b.c: Likewise.
	* ld-plugin/pr15146c.c: Likewise.
	* ld-plugin/pr15146d.c: Likewise.

	* ld-plugin/lto.exp: Add tests for PR ld/15146.
@
text
@d1000 2
a1001 1
	      && (h->u.undef.abfd->flags & BFD_PLUGIN) != 0)
@


1.48
log
@Also trace symbol from the IR bfd

	PR ld/15141
	* plugin.c (plugin_notice): Also trace symbol from the IR bfd.
@
text
@d996 8
a1003 1
	h->non_ir_ref = TRUE;
@


1.47
log
@Improve plugin error handling

ld/

	PR ld/14904
	* ldmain.c (main): Don't check plugin_load_plugins return.

	* lexsup.c (parse_args): Don't check plugin_opt_plugin return.

	* plugin.c (dlerror): New.  Defined if HAVE_DLFCN_H isn't
	defined.
	(plugin_opt_plugin): Change return type to void.  Stop on
	dlopen error and report error with dlerror ().
	(plugin_load_plugins): Change return type to void.  Stop on
	dlsym error and report error with dlerror ().  Don't use
	set_plugin_error.
	(plugin_call_cleanup): Issue an error for each plugin.

	* plugin.h (plugin_opt_plugin): Change return type to void.
	(plugin_load_plugins): Likewise.

ld/testsuite/

	PR ld/14904
	* ld-plugin/plugin-2.d: Update expected error message.
	* ld-plugin/plugin-4.d: Likewise.
@
text
@d965 1
a965 1
      /* No further processing if this def/ref is from an IR dummy BFD.  */
d967 1
a967 1
	return TRUE;
d971 2
a972 2
      if (bfd_is_ind_section (section)
	  || (flags & BSF_INDIRECT) != 0)
@


1.46
log
@	* plugin.c (plugin_load_plugins): Warning fix.
@
text
@d158 8
d189 1
a189 1
int
d199 1
a199 1
    return set_plugin_error (plugin);
a207 1
  return 0;
d781 1
a781 1
int
d790 1
a790 1
    return 0;
d816 2
a817 1
	return set_plugin_error (curplug->name);
d823 1
a823 1
	return set_plugin_error (curplug->name);
a835 2

  return 0;
d938 2
a939 1
	    set_plugin_error (curplug->name);
a943 3
  if (plugin_error_p ())
    info_msg (_("%P: %s: error in plugin cleanup (ignored)\n"),
	      plugin_error_plugin ());
@


1.45
log
@Handle link_info.pie in ld plugin

	* plugin.c (set_tv_header): Handle link_info.pie.
@
text
@d803 3
a805 1
      ld_plugin_onload onloadfn = dlsym (curplug->dlhandle, "onload");
d807 1
a807 1
	onloadfn = dlsym (curplug->dlhandle, "_onload");
@


1.45.2.1
log
@	PR 12549
	PR 14493
	PR 14567
	PR 14662
	PR 14758
	PR 14813
	PR 14904
	PR 14915
	PR 14926
	PR 14950
	PR 14962
	Apply mainline patches
@
text
@a157 8
#ifndef HAVE_DLFCN_H
static const char *
dlerror (void)
{
  return "";
}
#endif

d181 1
a181 1
void
d191 1
a191 1
    einfo (_("%P%F: %s: error loading plugin: %s\n"), plugin, dlerror ());
d200 1
d774 1
a774 1
void
d783 1
a783 1
    return;
d803 1
a803 3
      ld_plugin_onload onloadfn;

      onloadfn = (ld_plugin_onload) dlsym (curplug->dlhandle, "onload");
d805 1
a805 1
	onloadfn = (ld_plugin_onload) dlsym (curplug->dlhandle, "_onload");
d807 1
a807 2
        einfo (_("%P%F: %s: error loading plugin: %s\n"),
	       curplug->name, dlerror ());
d813 1
a813 1
	einfo (_("%P%F: %s: plugin error: %d\n"), curplug->name, rv);
d826 2
d930 1
a930 2
	    info_msg (_("%P: %s: error in plugin cleanup: %d (ignored)\n"),
		      curplug->name, rv);
d935 3
@


1.44
log
@	* ldlang.h (struct lang_input_statement_flags): New, extract from..
	(lang_input_statement_type): ..here.  New field "flags".
	(input_flags): Declare.
	(missing_file): Delete.
	* ldmain.h (whole_archive): Delete.
	(add_DT_NEEDED_for_regular, add_DT_NEEDED_for_dynamic): Delete.
	* ld.h (ld_config_type <dynamic_link>): Delete.
	* ldmain.c (whole_archive): Delete.
	(add_DT_NEEDED_for_regular, add_DT_NEEDED_for_dynamic): Delete.
	* ldlang.c (missing_file, ldlang_sysrooted_script): Delete.
	(input_flags): New variable.  Replace all uses of config.dynamic_link,
	missing_file, ldlang_sysrooted_script, whole_archive,
	add_DT_NEEDED_for_regular and add_DT_NEEDED_for_dynamic with fields
	from here.
	* ldfile.c: Likewise.
	* ldgram.y: Likewise.
	* ldmain.c: Likewise.
	* ldwrite.c: Likewise.
	* lexsup.c: Likewise.
	* plugin.c: Likewise.
	* emultempl/aix.em: Likewise.
	* emultempl/armelf.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/scoreelf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/vms.em: Likewise.
	* ldlang.c (new_afile): Use memset to init zero fields.
	(load_symbols): Simplify save and restore of flags around command
	file processing.
	* ldfile.c (is_sysrooted_pathname): Tidy.
@
text
@d700 3
a702 1
		      : link_info.executable ? LDPO_EXEC : LDPO_DYN);
@


1.43
log
@	PR ld/13287
	* plugin.c (plugin_should_reload): New function.
	* plugin.h (plugin_should_reload): Declare.
	* ldlang.c (open_input_bfds): Use above function.
@
text
@d2 1
a2 1
   Copyright 2010, 2011 Free Software Foundation, Inc.
d265 1
a265 1
	  && ((lang_input_statement_type *)(abfd->usrdata))->claimed);
d876 1
a876 1
      entry->claimed = TRUE;
d884 1
a884 1
      entry->claimed = FALSE;
@


1.42
log
@	* ldmain.c (main): Move code twiddling various config and link_info
	bits to..
	* lexsup.c (parse_args): ..here.  Move plugin_load_plugins call
	into main.
	* plugin.c (set_tv_header): Test link_info.executable, not
	link_info.shared.
	(is_visible_from_outside): Likewise.  Delete redundant
	is_ir_dummy_bfd check and "section" parameter.
@
text
@d1017 11
@


1.41
log
@	PR ld/13329
ld/
	* plugin.c (tv_header_tags): Add LDPT_GET_SYMBOLS_V2.
	(set_tv_header): Handle it.  Adjust LDPT_GET_SYMBOLS.  Return void.
	(get_symbols): Add def_ironly_exp param.  Return that value for
	syms exported from shared libs.
	(get_symbols_v1, get_symbols_v2): New wrapper functions.
	* testplug.c: Update for above changes.
ld/testsuite/
	* ld-plugin/plugin-1.d, * ld-plugin/plugin-2.d, * ld-plugin/plugin-3.d,
	* ld-plugin/plugin-4.d, * ld-plugin/plugin-5.d, * ld-plugin/plugin-6.d,
	* ld-plugin/plugin-7.d, * ld-plugin/plugin-8.d, * ld-plugin/plugin-9.d,
	* ld-plugin/plugin-10.d, * ld-plugin/plugin-11.d: Update.
@
text
@d445 1
a445 1
is_visible_from_outside (struct ld_plugin_symbol *lsym, asection *section,
a449 4
  /* Section's owner may be NULL if it is the absolute
     section, fortunately is_ir_dummy_bfd handles that.  */
  if (!is_ir_dummy_bfd (section->owner))
    return TRUE;
d452 1
a452 1
  if (link_info.export_dynamic || link_info.shared)
d579 1
a579 1
	  else if (is_visible_from_outside (&syms[n], owner_sec, blhe))
d700 1
a700 1
		      : (link_info.shared ? LDPO_DYN : LDPO_EXEC));
@


1.40
log
@Check if a symbol is hidden by linker script.

bfd/

2011-09-15  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12975
	* bfd-in.h (bfd_elf_size_dynamic_sections): Remove pointer
	to struct bfd_elf_version_tree.

	* elflink.c (elf_info_failed): Remove verdefs.
	(_bfd_elf_export_symbol): Updated.
	_bfd_elf_link_assign_sym_version): Likewise.
	(bfd_elf_size_dynamic_sections): Remove pointer to struct
	bfd_elf_version_tree.  Updated.
	(bfd_elf_gc_mark_dynamic_ref_symbol): Check if a symbol is hidden
	by linker script.

	* linker.c (bfd_hide_sym_by_version): New.

	* bfd-in2.h: Regenerated.

include/

2011-09-15  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12975
	* bfdlink.h (bfd_link_info): Add version_info.

ld/

2011-09-15  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12975
	* ldlang.c (lang_elf_version_info): Removed.
	(lang_register_vers_node): Replace lang_elf_version_info with
	link_info.version_info.
	(lang_add_vers_depend): Likewise.
	* pe-dll.c (process_def_file_and_drectve): Likewise.
	* emultempl/solaris2.em (elf_solaris2_before_allocation): Likewise.

	* ldlang.h (lang_elf_version_info): Removed.

	* plugin.c  (is_visible_from_outside): Check if symbol is hidden
	by version script.

	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation):
	Remove lang_elf_version_info.

ld/testsuite/

2011-09-15  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12975
	* ld-elf/pr12975.d: New.
	* ld-elf/pr12975.s: Likewise.
	* ld-elf/pr12975.t: Likewise.
@
text
@d119 1
d493 2
a494 1
get_symbols (const void *handle, int nsyms, struct ld_plugin_symbol *syms)
d498 1
a502 1
      bfd_boolean ironly;
d504 2
d514 1
a514 1
	  syms[n].resolution = LDPR_UNKNOWN;
d522 1
a522 1
	  syms[n].resolution = LDPR_UNDEF;
a540 6
      /* We need to know if the sym is referenced from non-IR files.  Or
	 even potentially-referenced, perhaps in a future final link if
	 this is a partial one, perhaps dynamically at load-time if the
	 symbol is externally visible.  */
      ironly = !(blhe->non_ir_ref
		 || is_visible_from_outside (&syms[n], owner_sec, blhe));
d549 1
a549 1
	    syms[n].resolution = LDPR_RESOLVED_EXEC;
d551 1
a551 3
	    syms[n].resolution = (ironly
				  ? LDPR_PREVAILING_DEF_IRONLY
				  : LDPR_PREVAILING_DEF);
d553 1
a553 1
	    syms[n].resolution = LDPR_RESOLVED_IR;
d556 1
a556 1
	    syms[n].resolution =  LDPR_RESOLVED_DYN;
d558 1
a558 2
	    syms[n].resolution = LDPR_RESOLVED_EXEC;
	  goto report_symbol;
d564 2
a565 2
      if (owner_sec->owner == link_info.output_bfd)
	syms[n].resolution = LDPR_PREEMPTED_REG;
d567 9
d577 8
a584 4
	  syms[n].resolution = (ironly
				? LDPR_PREVAILING_DEF_IRONLY
				: LDPR_PREVAILING_DEF);
	  goto report_symbol;
a586 5
      /* Was originally def, weakdef, or common, but has been pre-empted.  */
      syms[n].resolution = (is_ir_dummy_bfd (owner_sec->owner)
			    ? LDPR_PREEMPTED_IR
			    : LDPR_PREEMPTED_REG);

d588 1
d593 1
a593 1
	       syms[n].def, syms[n].visibility, syms[n].resolution);
d598 12
d677 1
a677 1
static size_t
a685 3
  if (!tv)
    return tv_header_size;

d728 4
a731 1
	  TVU(get_symbols) = get_symbols;
a748 1
  return tv_header_size;
@


1.40.2.1
log
@	PR ld/13229
	Apply mainline patches
ld/
	2011-10-06  Alan Modra  <amodra@@gmail.com>
	* plugin.c (tv_header_tags): Add LDPT_GET_SYMBOLS_V2.
	(set_tv_header): Handle it.  Adjust LDPT_GET_SYMBOLS.  Return void.
	(get_symbols): Add def_ironly_exp param.  Return that value for
	syms exported from shared libs.
	(get_symbols_v1, get_symbols_v2): New wrapper functions.
	* testplug.c: Update for above changes.
ld/testsuite/
	2011-10-06  Alan Modra  <amodra@@gmail.com>
	* ld-plugin/plugin-1.d, * ld-plugin/plugin-2.d, * ld-plugin/plugin-3.d,
	* ld-plugin/plugin-4.d, * ld-plugin/plugin-5.d, * ld-plugin/plugin-6.d,
	* ld-plugin/plugin-7.d, * ld-plugin/plugin-8.d, * ld-plugin/plugin-9.d,
	* ld-plugin/plugin-10.d, * ld-plugin/plugin-11.d: Update.
@
text
@a118 1
  LDPT_GET_SYMBOLS_V2,
d492 1
a492 2
get_symbols (const void *handle, int nsyms, struct ld_plugin_symbol *syms,
	     int def_ironly_exp)
a495 1

d500 1
a501 2
      int res;

d510 1
a510 1
	  res = LDPR_UNKNOWN;
d518 1
a518 1
	  res = LDPR_UNDEF;
d537 6
d551 1
a551 1
	    res = LDPR_RESOLVED_EXEC;
d553 3
a555 1
	    res = LDPR_PREVAILING_DEF_IRONLY;
d557 1
a557 1
	    res = LDPR_RESOLVED_IR;
d560 1
a560 1
	    res = LDPR_RESOLVED_DYN;
d562 2
a563 1
	    res = LDPR_RESOLVED_EXEC;
d569 2
a570 2
      else if (owner_sec->owner == link_info.output_bfd)
	res = LDPR_PREEMPTED_REG;
d572 6
a577 1
	res = LDPR_PREVAILING_DEF_IRONLY;
d580 3
a582 16
      else if (is_ir_dummy_bfd (owner_sec->owner))
	res = LDPR_PREEMPTED_IR;
      else
	res = LDPR_PREEMPTED_REG;

      if (res == LDPR_PREVAILING_DEF_IRONLY)
	{
	  /* We need to know if the sym is referenced from non-IR files.  Or
	     even potentially-referenced, perhaps in a future final link if
	     this is a partial one, perhaps dynamically at load-time if the
	     symbol is externally visible.  */
	  if (blhe->non_ir_ref)
	    res = LDPR_PREVAILING_DEF;
	  else if (is_visible_from_outside (&syms[n], owner_sec, blhe))
	    res = def_ironly_exp;
	}
a584 1
      syms[n].resolution = res;
d589 1
a589 1
	       syms[n].def, syms[n].visibility, res);
a593 12
static enum ld_plugin_status
get_symbols_v1 (const void *handle, int nsyms, struct ld_plugin_symbol *syms)
{
  return get_symbols (handle, nsyms, syms, LDPR_PREVAILING_DEF);
}

static enum ld_plugin_status
get_symbols_v2 (const void *handle, int nsyms, struct ld_plugin_symbol *syms)
{
  return get_symbols (handle, nsyms, syms, LDPR_PREVAILING_DEF_IRONLY_EXP);
}

d661 1
a661 1
static void
d670 3
d715 1
a715 4
	  TVU(get_symbols) = get_symbols_v1;
	  break;
	case LDPT_GET_SYMBOLS_V2:
	  TVU(get_symbols) = get_symbols_v2;
d733 1
@


1.40.2.2
log
@	2011-10-10  Alan Modra  <amodra@@gmail.com>
	* ldmain.c (main): Move code twiddling various config and link_info
	bits to..
	* lexsup.c (parse_args): ..here.  Move plugin_load_plugins call
	into main.
	* plugin.c (set_tv_header): Test link_info.executable, not
	link_info.shared.
	(is_visible_from_outside): Likewise.  Delete redundant
	is_ir_dummy_bfd check and "section" parameter.
@
text
@d445 1
a445 1
is_visible_from_outside (struct ld_plugin_symbol *lsym,
d450 4
d456 1
a456 1
  if (link_info.export_dynamic || !link_info.executable)
d583 1
a583 1
	  else if (is_visible_from_outside (&syms[n], blhe))
d704 1
a704 1
		      : link_info.executable ? LDPO_EXEC : LDPO_DYN);
@


1.40.2.3
log
@	PR ld/13287
	2011-10-20  Alan Modra  <amodra@@gmail.com>
	* plugin.c (plugin_should_reload): New function.
	* plugin.h (plugin_should_reload): Declare.
	* ldlang.c (open_input_bfds): Use above function.
@
text
@a1016 11

/* Return true if bfd is a dynamic library that should be reloaded.  */

bfd_boolean
plugin_should_reload (bfd *abfd)
{
  return ((abfd->flags & DYNAMIC) != 0
	  && bfd_get_flavour (abfd) == bfd_target_elf_flavour
	  && bfd_get_format (abfd) == bfd_object
	  && (elf_dyn_lib_class (abfd) & DYN_AS_NEEDED) != 0);
}
@


1.39
log
@	PR ld/12762
bfd/
	* bfd-in.h (struct bfd_section_already_linked): Forward declare.
	(_bfd_handle_already_linked): Declare.
	* coff-alpha.c (_bfd_ecoff_section_already_linked): Define as
	_bfd_coff_section_already_linked.
	* coff-mips.c (_bfd_ecoff_section_already_linked): Likewise.
	* coffcode.h (coff_section_already_linked): Likewise.
	* cofflink.c (coff_link_add_symbols): Revert 2011-07-09 changes.
	* elf-bfd.h: Likewise.
	* libbfd-in.h: Likewise.
	* targets.c: Likewise.
	* linker.c (bfd_section_already_linked): Likewise.
	(bfd_section_already_linked_table_lookup): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.
	(_bfd_generic_section_already_linked): Likewise.  Call
	_bfd_handle_already_linked.
	(_bfd_handle_already_linked): New function, split out from..
	* elflink.c (_bfd_elf_section_already_linked): ..here.  Revert
	2011-07-09 changes.  Avoid unnecessary strcmp when matching
	already_linked_list entries.  Match plugin linkonce section.
	(section_signature): Delete.
	* coffgen.c (_bfd_coff_section_already_linked): New function.
	* libcoff-in.h (_bfd_coff_section_already_linked): Declare.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
	* bfd-in2.h: Regenerate.
ld/
	* ldlang.c (section_already_linked): Revert 2011-07-09 changes.
	* plugin.c: Likewise.
	(asymbol_from_plugin_symbol): Create linkonce section for syms
	with comdat_key.
@
text
@d457 4
@


1.38
log
@	PR ld/13066
	PR ld/12762
	* plugin.c (add_symbols): Revert 2011-08-05.
@
text
@a34 1
#include "libbfd.h"
d242 1
a242 1
	  /* Create sections to own the symbols.  */
d287 21
a307 1
      section = bfd_get_section_by_name (abfd, ".text");
a410 7
      if (syms[n].comdat_key)
	{
	  struct already_linked linked;
	  linked.comdat_key = xstrdup (syms[n].comdat_key);
	  linked.u.abfd = abfd;
	  bfd_section_already_linked (abfd, &linked, &link_info);
	}
@


1.37
log
@	PR ld/12762
bfd/
	* elflink.c (_bfd_elf_section_already_linked): Return matched
	status.  Remove COFF comdat section handling.
	* linker.c (_bfd_generic_section_already_linked): Return matched
	status.  Don't set SEC_GROUP in l_flags for plugin entries.
	(bfd_section_already_linked): Update prototype.
	* targets.c (_section_already_linked): Likewise.
	* elf-bfd.h (_bfd_elf_section_already_linked): Likewise.
	* libbfd-in.h (_bfd_generic_section_already_linked): Likewise.
	(_bfd_nolink_section_already_linked): Update.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.
ld/
	* plugin.c (add_symbols): Exclude comdat_key symbols from symbol
	table if already seen.
@
text
@d383 1
a383 1
  int n, k;
d387 1
a387 1
  for (n = 0, k = 0; n < nsyms; n++)
d397 1
a397 2
	  if (bfd_section_already_linked (abfd, &linked, &link_info))
	    continue;
d400 1
a400 1
      symptrs[k++] = bfdsym;
d405 1
a405 1
  bfd_set_symtab (abfd, symptrs, k);
@


1.36
log
@	PR ld/12942
bfd/
	* elflink.c (elf_link_add_object_symbols): Use elf_discarded_section
	rather than kept_section to determine whether a symbol is from
	a discarded section.
	* cofflink.c (coff_link_add_symbols): Make symbols from discarded
	sections appear undefined.

	* elf-bfd.h (_bfd_elf_section_already_linked): Replace
	"asection *" with "struct already_linked *".
	* libbfd-in.h (_bfd_nolink_section_already_linked): Likewise.
	(_bfd_generic_section_already_linked): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.
	(struct already_linked): New.
	(struct bfd_section_already_linked): Use it.
	* elflink.c (_bfd_elf_section_already_linked): Replace.
	"asection *" with "struct already_linked *".  Replace the plugin
	dummy with the LTO output.
	* linker.c (_bfd_generic_section_already_linked): Likewise.
	* targets.c (struct already_linked): Add forward declaration.
	(bfd_target): Replace "struct bfd_section *" with
	"struct already_linked *" in _section_already_linked.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.

include/
	* bfdlink.h (bfd_link_info): Add loading_lto_outputs.

ld/
	* ldlang.c (section_already_linked): Pass "struct already_linked *"
	to bfd_section_already_linked.
	(lang_process): Set link_info.loading_lto_outputs before
	loading LTO outputs.
	* plugin.c: Include "libbfd.h".
	(add_symbols): Call bfd_section_already_linked with comdat_key.
@
text
@d383 2
a384 1
  int n;
d387 1
a387 1
  for (n = 0; n < nsyms; n++)
d397 2
a398 1
	  bfd_section_already_linked (abfd, &linked, &link_info);
d401 1
a401 1
      symptrs[n] = bfdsym;
d406 1
a406 1
  bfd_set_symtab (abfd, symptrs, nsyms);
@


1.35
log
@	PR ld/12760
include/
	* bfdlink.h (struct bfd_link_callbacks <notice>): Add "flags" and
	"string" param.
bfd/
	* coff-aux.c (coff_m68k_aux_link_add_one_symbol): Adjust "notice" call.
	* elflink.c (elf_link_add_object_symbols): Likewise.
	* linker.c (_bfd_generic_link_add_one_symbol): Likewise.
ld/
	* ldmain.c (notice): Add "flags" and "string" param.
	* plugin.c (plugin_notice): Likewise.  Handle indirect, warning
	and constructor syms.
@
text
@d35 1
d389 10
a398 1
      asymbol *bfdsym = bfd_make_empty_symbol (abfd);
@


1.34
log
@	PR ld/12760
	* plugin.c (plugin_notice): Set u.undef.abfd for symbols made
	undefweak.
@
text
@d128 3
a130 3
static bfd_boolean plugin_notice (struct bfd_link_info *info,
				  struct bfd_link_hash_entry *h, bfd *abfd,
				  asection *section, bfd_vma value);
d911 3
a913 1
	       bfd_vma value)
d923 25
d949 1
a949 1
      if (bfd_is_und_section (section))
d975 2
a976 1
    return (*orig_callbacks->notice) (info, h, abfd, section, value);
@


1.33
log
@	PR ld/12365
	PR ld/12696
include/
	* bfdlink.h (ENUM_BITFIELD): Define.
	(struct bfd_link_hash_entry): Make "type" a bitfield.  Add "non_ir_ref".
	(struct bfd_link_callbacks <notice>): Pass bfd_link_hash_entry pointer
	rather than "name".
bfd/
	* coff-aux.c (coff_m68k_aux_link_add_one_symbol): Update "notice" call.
	* linker.c (_bfd_link_hash_newfunc): Clear bitfields.
	(_bfd_generic_link_add_one_symbol): Update "notice" call.
	* elflink.c (_bfd_elf_merge_symbol): Don't skip weak redefs when
	it is a redef of an IR symbol in a real BFD.
ld/
	* ldmain.c (notice): Delete "name" param, add "h".
	* plugin.c (plugin_notice): Likewise.  Set non_ir_ref.  Handle
	redefinitions of IR symbols in real BFDs.
	(plugin_multiple_definition, plugin_multiple_common): Delete.
	(non_ironly_hash, init_non_ironly_hash): Delete.
	(is_visible_from_outside): Traverse entry_symbol chain.
	(get_symbols): Use non_ir_ref flag rather than hash lookup.
@
text
@d915 2
d933 1
a933 1
		&& is_ir_dummy_bfd (h->u.def.section->owner))
d935 5
a939 2
		   && is_ir_dummy_bfd (h->u.c.p->section->owner)))
	h->type = bfd_link_hash_undefweak;
@


1.32
log
@	PR ld/12365
bfd/
	* elfcode.h (elf_slurp_symbol_table): Put common plugin IR symbols
	in their own common section.
	* elflink.c (elf_link_add_object_symbols): Likewise.
	* linker.c (generic_link_check_archive_element): Don't lose flags
	if common section is pre-existing.
	(_bfd_generic_link_add_one_symbol): Likewise.
ld/
	* ldfile.c (ldfile_try_open_bfd): Move code creating and switching
	to plugin IR BFD..
	* ldmain.c (add_archive_element): ..and similar code here..
	* plugin.c (plugin_maybe_claim): ..to here.  New function.
	(plugin_call_claim_file): Make static.
	(asymbol_from_plugin_symbol): Set ELF st_shndx for common syms.
	(plugin_multiple_common): New function.
	(plugin_call_all_symbols_read): Hook in plugin_multiple_common.
	* plugin.h (plugin_call_claim_file): Don't declare.
	(plugin_maybe_claim): Declare.
@
text
@a92 7
/* A hash table that records symbols referenced by non-IR files.  Used
   at get_symbols time to determine whether any prevailing defs from
   IR files are referenced only from other IR files, so tthat we can
   we can distinguish the LDPR_PREVAILING_DEF and LDPR_PREVAILING_DEF_IRONLY
   cases when establishing symbol resolutions.  */
static struct bfd_hash_table *non_ironly_hash = NULL;

d129 1
a129 1
				  const char *name, bfd *abfd,
a130 10
static bfd_boolean plugin_multiple_definition (struct bfd_link_info *info,
					       struct bfd_link_hash_entry *h,
					       bfd *nbfd,
					       asection *nsec,
					       bfd_vma nval);
static bfd_boolean plugin_multiple_common (struct bfd_link_info *info,
					   struct bfd_link_hash_entry *h,
					   bfd *nbfd,
					   enum bfd_link_hash_type ntype,
					   bfd_vma nsize);
d424 2
d454 6
d514 2
a515 3
      ironly = (!is_visible_from_outside (&syms[n], owner_sec, blhe)
		&& !bfd_hash_lookup (non_ironly_hash, syms[n].name,
				     FALSE, FALSE));
a732 21
/* Init the non_ironly hash table.  */
static void
init_non_ironly_hash (void)
{
  struct bfd_sym_chain *sym;

  non_ironly_hash
    = (struct bfd_hash_table *) xmalloc (sizeof (struct bfd_hash_table));
  if (!bfd_hash_table_init_n (non_ironly_hash,
			      bfd_hash_newfunc,
			      sizeof (struct bfd_hash_entry),
			      61))
    einfo (_("%P%F: bfd_hash_table_init failed: %E\n"));

  for (sym = &entry_symbol; sym != NULL; sym = sym->next)
    if (sym->name
	&& !bfd_hash_lookup (non_ironly_hash, sym->name, TRUE, TRUE))
      einfo (_("%P%X: hash table failure adding symbol %s\n"),
	     sym->name);
}

a785 1
  init_non_ironly_hash ();
a858 3
  plugin_callbacks.multiple_definition = &plugin_multiple_definition;
  plugin_callbacks.multiple_common = &plugin_multiple_common;

d902 4
a905 6
   the linker adds them to the linker hash table.  If we see a symbol
   being referenced from a non-IR file, we add it to the non_ironly hash
   table.  If we can't find it there at get_symbols time, we know that
   it was referenced only by IR files.  We have to notice_all symbols,
   because we won't necessarily know until later which ones will be
   contributed by IR files.  */
d908 1
a908 1
	       const char *name,
d913 1
a913 1
  if (name != NULL)
d919 1
a919 3
      /* We only care about refs, not defs, indicated by section
	 pointing to the undefined section (according to the bfd
	 linker notice callback interface definition).  */
d921 14
a934 7
	{
	  /* This is a ref from a non-IR file, so note the ref'd
	     symbol in the non-IR-only hash.  */
	  if (!bfd_hash_lookup (non_ironly_hash, name, TRUE, TRUE))
	    einfo (_("%P%X: %s: hash table failure adding symbol %s\n"),
		   abfd->filename, name);
	}
d938 1
a938 1
  if (name == NULL
d941 3
a943 2
	  && bfd_hash_lookup (info->notice_hash, name, FALSE, FALSE) != NULL))
    return (*orig_callbacks->notice) (info, name, abfd, section, value);
a945 45

/* When we add new object files to the link at all symbols read time,
   these contain the real code and symbols generated from the IR files,
   and so duplicate all the definitions already supplied by the dummy
   IR-only BFDs that we created at claim files time.  We use the linker's
   multiple-definitions callback hook to fix up the clash, discarding
   the symbol from the IR-only BFD in favour of the symbol from the
   real BFD.  We return true if this was not-really-a-clash because
   we've fixed it up, or anyway if --allow-multiple-definition was in
   effect (before we disabled it to ensure we got called back).  */
static bfd_boolean
plugin_multiple_definition (struct bfd_link_info *info,
			    struct bfd_link_hash_entry *h,
			    bfd *nbfd, asection *nsec, bfd_vma nval)
{
  if (h->type == bfd_link_hash_defined
      && is_ir_dummy_bfd (h->u.def.section->owner))
    {
      /* Replace it with new details.  */
      h->u.def.section = nsec;
      h->u.def.value = nval;
      return TRUE;
    }

  return (*orig_callbacks->multiple_definition) (info, h, nbfd, nsec, nval);
}

static bfd_boolean
plugin_multiple_common (struct bfd_link_info *info,
			struct bfd_link_hash_entry *h,
			bfd *nbfd, enum bfd_link_hash_type ntype, bfd_vma nsize)
{
  if (h->type == bfd_link_hash_common
      && is_ir_dummy_bfd (h->u.c.p->section->owner)
      && ntype == bfd_link_hash_common
      && !is_ir_dummy_bfd (nbfd))
    {
      /* Arrange to have it replaced.  */
      ASSERT (nsize != 0);
      h->u.c.size = 0;
      return TRUE;
    }

  return (*orig_callbacks->multiple_common) (info, h, nbfd, ntype, nsize);
}
@


1.31
log
@	PR ld/12365
include/
	* bfdlink.h (struct bfd_link_callbacks): Modify multiple_definition
	and multiple_common parameters to pass in a bfd_link_hash_entry
	pointer rather than name,bfd etc. found in the hash entry.
bfd/
	* elflink.c (_bfd_elf_merge_symbol): Update multiple_common calls.
	* linker.c (_bfd_generic_link_add_one_symbol): Likewise.  Call
	multiple_definition regardless of allow_multiple_definition.
	* simple.c (simple_dummy_multiple_definition): Update.
	* xcofflink.c (xcoff_link_add_symbols): Update multiple_definition
	calls.
ld/
	* ldmain.c (multiple_definition): Take a bfd_link_hash_entry
	pointer arg rather than "name", "obfd", "osec", "oval".  Add code
	removed from linker.c.  Hack around xcofflink.c oddity in
	passing NULL nbfd.
	(multiple_common): Similarly.
	* plugin.c (orig_allow_multiple_defs): Delete.
	(plugin_call_all_symbols_read): Don't twiddle allow_multiple_definition.
	(plugin_multiple_definition): Update.
@
text
@d143 5
d320 4
a323 1
	((elf_symbol_type *) asym)->internal_elf_sym.st_value = 1;
d823 1
a823 1
int
d846 36
d892 1
d1003 19
@


1.30
log
@	PR ld/12365
	PR ld/12672
bfd/
	* bfd.c (BFD_PLUGIN): Define.
	(BFD_FLAGS_SAVED, BFD_FLAGS_FOR_BFD_USE_MASK): Add BFD_PLUGIN.
	* bfd-in2.h: Regenerate.
	* elflink.c (elf_link_output_extsym): Strip undefined plugin syms.
	* opncls.c (bfd_make_readable): Don't lose original bfd flags.
ld/
	* ldfile.c (ldfile_try_open_bfd): Don't attempt any plugin action
	when no_more_claiming.
	* ldmain.c (add_archive_element): Likewise.
	(multiple_definition): Remove plugin_multiple_definition call.
	(notice): Remove plugin_notice call.
	* ldlang.c (lang_list_insert_after, void lang_list_remove_tail): Move.
	Delete prototype.
	(plugin_insert): New static var.
	(open_input_bfds): Only rescan libs after plugin insert point.
	(lang_gc_sections): Omit plugin claimed files.
	(lang_process): Set plugin_insert.  Only rescan when plugin adds
	objects.
	* plugin.h (no_more_claiming): Declare.
	(plugin_notice, plugin_multiple_definition): Don't declare.
	* plugin.c: Formatting.
	(orig_notice_all, orig_allow_multiple_defs, orig_callbacks,
	plugin_callbacks): New static vars.
	(no_more_claiming): Make global.
	(plugin_cached_allow_multiple_defs): Delete.
	(plugin_get_ir_dummy_bfd): Set SEC_EXCLUDE on dummy .text section,
	use newer bfd_make_section variant.  Make COMMON section too.
	Error handling.  Correct setting of gp size.
	(asymbol_from_plugin_symbol): Properly cast last arg of concat.
	(message): Likewise for ACONCAT.
	(asymbol_from_plugin_symbol): Use our COMMON section.
	(get_symbols): When report_plugin_symbols, show visibility too.
	(init_non_ironly_hash): Move.  Don't test non_ironly_hash.
	(plugin_load_plugins): Save state of linker callbacks, set up to
	call plugin_notice instead.  Call init_non_ironly_hash here.
	(plugin_call_all_symbols_read): Set plugin_multiple_definition in
	plugin callbacks.
	(plugin_notice): Rewrite.
	(plugin_multiple_definition): Make static, call original callback.
ld/testsuite/
	* ld-plugin/plugin-7.d: Adjust for plugin changes.
	* ld-plugin/plugin-8.d: Likewise.
	* ld-plugin/plugin.exp: Pass --verbose=2 for visibility test, and
	compare ld output to..
	* ld-plugin/plugin-12.d: New.
@
text
@d100 1
a100 2
/* State of linker "notice" and "multiple_definition" interfaces
   before we poked at them.  */
a101 1
static bfd_boolean orig_allow_multiple_defs;
d139 2
a140 3
					       const char *name,
					       bfd *obfd, asection *osec,
					       bfd_vma oval, bfd *nbfd,
a846 6
  /* If --allow-multiple-definition is in effect, we need to disable it,
     as the plugin infrastructure relies on the multiple_definition
     callback to swap out the dummy IR-only BFDs for new real ones
     when it starts opening the files added during this callback.  */
  orig_allow_multiple_defs = link_info.allow_multiple_definition;
  link_info.allow_multiple_definition = FALSE;
d943 2
a944 2
plugin_multiple_definition (struct bfd_link_info *info, const char *name,
			    bfd *obfd, asection *osec, bfd_vma oval,
d947 2
a948 1
  if (is_ir_dummy_bfd (obfd))
a949 7
      struct bfd_link_hash_entry *blhe
	= bfd_link_hash_lookup (info->hash, name, FALSE, FALSE, FALSE);
      if (!blhe)
	einfo (_("%P%X: %s: can't find IR symbol '%s'\n"), nbfd->filename,
	       name);
      else if (blhe->type != bfd_link_hash_defined)
	einfo (_("%P%x: %s: bad IR symbol type %d\n"), name, blhe->type);
d951 2
a952 2
      blhe->u.def.section = nsec;
      blhe->u.def.value = nval;
d956 1
a956 5
  if (orig_allow_multiple_defs)
    return TRUE;

  return (*orig_callbacks->multiple_definition) (info, name, obfd, osec, oval,
						 nbfd, nsec, nval);
@


1.29
log
@	* configure.in: Check for windows.h, not Windows.h.
	* configure: Regenerate.
	* plugin.c: Include windows.h, not Windows.h.
@
text
@d100 9
d111 1
a111 7
static bfd_boolean no_more_claiming = FALSE;

/* If the --allow-multiple-definition command-line option is active, we
   have to disable it so that BFD always calls our hook, and simulate the
   effect (when not resolving IR vs. real symbols) ourselves by ensuring
   TRUE is returned from the hook.  */
static bfd_boolean plugin_cached_allow_multiple_defs = FALSE;
d136 11
a241 1
  asection *sec;
d245 1
a245 1
  abfd = bfd_create (concat (name, IRONLY_SUFFIX, (const char *)NULL),
d247 19
a265 12
  bfd_set_arch_info (abfd, bfd_get_arch_info (srctemplate));
  bfd_make_writable (abfd);
  bfd_copy_private_bfd_data (srctemplate, abfd);
  bfd_set_gp_size (abfd, bfd_get_gp_size (abfd));
  /* Create a minimal set of sections to own the symbols.  */
  sec = bfd_make_section_old_way (abfd, ".text");
  bfd_set_section_flags (abfd, sec,
			 (SEC_CODE | SEC_HAS_CONTENTS | SEC_READONLY
			  | SEC_ALLOC | SEC_LOAD | SEC_KEEP));
  sec->output_section = sec;
  sec->output_offset = 0;
  return abfd;
d277 3
a279 3
  return abfd
	 && abfd->usrdata
	 && ((lang_input_statement_type *)(abfd->usrdata))->claimed;
d292 1
a292 1
		? concat (ldsym->name, "@@", ldsym->version, NULL)
d510 3
a512 3
      owner_sec = (blhe->type == bfd_link_hash_common)
	? blhe->u.c.p->section
	: blhe->u.def.section;
d562 1
a562 1
report_symbol:
d564 4
a567 2
	einfo ("%P: %B: symbol `%s' definition: %d, resolution: %d\n",
	       abfd, syms[n].name, syms[n].def, syms[n].resolution);
d624 7
a630 8
	{
	  char *newfmt = ACONCAT ((level == LDPL_FATAL
				   ? "%P%F: " : "%P%X: ",
				   format, "\n", NULL));
	  fflush (stdout);
	  vfinfo (stderr, newfmt, args, TRUE);
	  fflush (stderr);
	}
d738 21
d806 4
d811 2
d854 1
a854 1
  plugin_cached_allow_multiple_defs = link_info.allow_multiple_definition;
d856 1
a898 24
/* Lazily init the non_ironly hash table.  */
static void
init_non_ironly_hash (void)
{
  struct bfd_sym_chain *sym;

  if (non_ironly_hash == NULL)
    {
      non_ironly_hash =
	(struct bfd_hash_table *) xmalloc (sizeof (struct bfd_hash_table));
      if (!bfd_hash_table_init_n (non_ironly_hash,
				  bfd_hash_newfunc,
				  sizeof (struct bfd_hash_entry),
				  61))
	einfo (_("%P%F: bfd_hash_table_init failed: %E\n"));

      for (sym = &entry_symbol; sym != NULL; sym = sym->next)
	if (sym->name
	    && !bfd_hash_lookup (non_ironly_hash, sym->name, TRUE, TRUE))
	  einfo (_("%P%X: hash table failure adding symbol %s\n"),
		 sym->name);
    }
}

d907 24
a930 23
bfd_boolean
plugin_notice (struct bfd_link_info *info ATTRIBUTE_UNUSED,
	       const char *name, bfd *abfd,
	       asection *section, bfd_vma value ATTRIBUTE_UNUSED)
{
  bfd_boolean is_ref = bfd_is_und_section (section);
  bfd_boolean is_dummy = is_ir_dummy_bfd (abfd);
  init_non_ironly_hash ();
  /* We only care about refs, not defs, indicated by section pointing
     to the undefined section (according to the bfd linker notice callback
     interface definition).  */
  if (is_ref && !is_dummy)
    {
      /* This is a ref from a non-IR file, so note the ref'd symbol
	 in the non-IR-only hash.  */
      if (!bfd_hash_lookup (non_ironly_hash, name, TRUE, TRUE))
	einfo (_("%P%X: %s: hash table failure adding symbol %s\n"),
	       abfd->filename, name);
    }
  else if (!is_ref && is_dummy)
    {
      /* No further processing since this is a def from an IR dummy BFD.  */
      return FALSE;
d934 5
d951 1
a951 1
bfd_boolean
d953 1
a953 2
			    bfd *obfd, asection *osec ATTRIBUTE_UNUSED,
			    bfd_vma oval ATTRIBUTE_UNUSED,
d970 6
a975 1
  return plugin_cached_allow_multiple_defs;
@


1.28
log
@[PATCH] Respect symbol wrappers when computing symbol resolutions.

ld/ChangeLog:

2011-03-10  Dave Korn  <dave.korn.cygwin@@gmail.com>

	* plugin.c (get_symbols): Use wrapped lookup for undefined symbols.
@
text
@d36 1
a36 1
#include <Windows.h>
@


1.27
log
@[PATCH] Do not use dummy bfd suffix for recognition, make it human-readable instead.

ld/ChangeLog:

2011-03-10  Dave Korn  <dave.korn.cygwin@@gmail.com>

	* plugin.c (IRONLY_SUFFIX): Revise to nicely human-readable form.
	(IRONLY_SUFFIX_LEN): Delete.
	(plugin_get_ir_dummy_bfd): Don't append IRONLY_SUFFIX.
	(is_ir_dummy_bfd): Don't look for suffix; check claimed flag of
	enclosing lang input statement instead.
@
text
@d459 6
a464 3

      blhe = bfd_link_hash_lookup (link_info.hash, syms[n].name,
				   FALSE, FALSE, TRUE);
@


1.26
log
@Report plugin symbols for --verbose=N.

2011-03-04  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld.texinfo: Document --verbose[=NUMBER].

	* lexsup.c (ld_options): Update --verbose.
	(parse_args): Set report_plugin_symbols.

	* plugin.c (report_plugin_symbols): New.
	(get_symbols): Report plugin symbols if report_plugin_symbols
	is TRUE.

	* plugin.h (report_plugin_symbols): New.
@
text
@d44 2
a45 6
   plugin.  */
#define IRONLY_SUFFIX		".ironly\004"

/* This is sizeof an array of chars, not sizeof a const char *.  We
   also have to avoid inadvertently counting the trailing NUL.  */
#define IRONLY_SUFFIX_LEN	(sizeof (IRONLY_SUFFIX) - 1)
d252 8
a259 8
  size_t namlen;

  if (abfd == NULL)
    return FALSE;
  namlen = strlen (abfd->filename);
  if (namlen < IRONLY_SUFFIX_LEN)
    return FALSE;
  return !strcmp (abfd->filename + namlen - IRONLY_SUFFIX_LEN, IRONLY_SUFFIX);
@


1.25
log
@Add entry_symbol chain into non_ironly_hash.

2011-02-24  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12507
	* plugin.c (get_symbols): Don't check entry symbol here.
	(init_non_ironly_hash): Add entry_symbol chain into
	non_ironly_hash.
@
text
@d39 3
d469 1
a469 1
	  continue;
d477 1
a477 1
	  continue;
d522 1
a522 1
	  continue;
d535 1
a535 1
	  continue;
d539 8
a546 3
      syms[n].resolution = is_ir_dummy_bfd (owner_sec->owner)
	? LDPR_PREEMPTED_IR
	: LDPR_PREEMPTED_REG;
@


1.24
log
@Don't mark entry symbol IR only.

2011-02-24  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12507
	* plugin.c (get_symbols): Don't mark entry symbol IR only.
@
text
@d498 1
a498 2
				     FALSE, FALSE)
		&& strcmp (syms[n].name, entry_symbol.name) != 0);
d847 2
d858 6
@


1.23
log
@	* ldmain.c (remove_output): Rename to..
	(ld_cleanup): ..this. Call bfd_cache_close_all and plugin_call_cleanup.
	(main): Adjust.
	* plugin.c (plugin_call_cleanup): Make global.
	(plugin_load_plugins): Don't register plugin_call_cleanup with xatexit.
	* plugin.h (plugin_call_cleanup): Declare.
@
text
@d496 4
a499 2
      ironly = !is_visible_from_outside (&syms[n], owner_sec, blhe)
	&& !bfd_hash_lookup (non_ironly_hash, syms[n].name, FALSE, FALSE);
@


1.22
log
@bfd/
	* elfxx-mips.c (_bfd_mips_elf_merge_private_bfd_data): Ignore
	common sections too.

ld/
	* plugin.c (plugin_get_ir_dummy_bfd): Copy across the bfd's
	private data and GP size.
@
text
@a110 3
/* Call 'cleanup' hook for all plugins at exit.  */
static void plugin_call_cleanup (void);

a720 2
  xatexit (plugin_call_cleanup);

d818 1
a818 1
static void
@


1.21
log
@	* ldmain.c (main): Flush stdout before and stderr after printing
	message.
	* ldmisc.c (einfo): Similarly.
	* plugin.c (message): Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/xtensaelf.em: Likewise.
	* emulparams/elf32mcore.sh: Use einfo rather than printf.
	* emultempl/beos.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
@
text
@d240 2
@


1.20
log
@Check if a bfd is NULL before accessing its flags field.

2011-01-05  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12364
	* plugin.c (get_symbols): Check if owner_sec->owner is NULL
	before accessing its flags field.
@
text
@d2 1
a2 1
   Copyright 2010 Free Software Foundation, Inc.
d599 1
d601 1
@


1.19
log
@Don't add the trailing `\n' for LDPL_ERROR.

2010-12-06  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12288
	* plugin.c (message): Don't add the trailing `\n' for
	LDPL_ERROR.
@
text
@d514 2
a515 1
	  else if (owner_sec->owner->flags & DYNAMIC)
@


1.18
log
@Use putchar for the trailing `\n' in plugin message.

bfd/

2010-12-06  Dmitry Gorbachev  <d.g.gorbachev@@gmail.com>

	PR ld/12288
	* plugin.c (message): Add putchar for the trailing `\n'.

ld/

2010-12-06  Dmitry Gorbachev  <d.g.gorbachev@@gmail.com>

	PR ld/12288
	* plugin.c (message): Use putchar for the trailing `\n'.
@
text
@d585 1
d589 1
a602 2
  putchar('\n');

@


1.17
log
@Call xatexit with plugin_call_cleanup.

2010-12-06  H.J. Lu  <hongjiu.lu@@intel.com>
	    Dmitry Gorbachev  <d.g.gorbachev@@gmail.com>

	PR ld/12289
	* ldmain.c (main): Don't call plugin_call_cleanup.

	* plugin.c (plugin_call_cleanup): Make it static.
	(message): Don't call plugin_call_cleanup.
	(plugin_load_plugins): Call xatexit with plugin_call_cleanup.
@
text
@d601 1
a601 1
  fputc('\n', stderr);
@


1.16
log
@Call plugin_call_cleanup on plugin fatal error.

2010-12-05  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12289
	* plugin.c (message): Call plugin_call_cleanup on fatal
	error.
@
text
@d111 3
a595 3
	  if (plugin_call_cleanup ())
	    info_msg (_("%P: %s: error in plugin cleanup (ignored)\n"),
		      plugin_error_plugin ());
d719 2
d817 2
a818 2
/* Call 'cleanup' hook for all plugins.  */
int
d837 3
a839 1
  return plugin_error_p () ? -1 : 0;
@


1.15
log
@Add a space after `:' in plugin error message.

2010-12-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* plugin.c (message): Add a space after `:' in error message.
@
text
@d593 3
@


1.14
log
@Add `%P' on error in plugin message.
@
text
@d590 2
a591 1
	  char *newfmt = ACONCAT ((level == LDPL_FATAL ? "%P%F:" : "%P%X:",
@


1.13
log
@Add the trailing `\n' to einfo in plugin.c.

2010-12-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* plugin.c (asymbol_from_plugin_symbol): Add the trailing `\n'
	to einfo.
	(get_symbols): Likewise.
	(plugin_notice): Likewise.
	(plugin_multiple_definition): Likewise.
@
text
@d590 1
a590 1
	  char *newfmt = ACONCAT ((level == LDPL_FATAL ? "%F" : "%X",
@


1.12
log
@Add the trailing `\n' to pluin message.

2010-12-05  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12288
	* plugin.c (message): Add the trailing `\n'.
@
text
@d313 1
a313 1
	einfo (_("%P%F: %s: non-ELF symbol in ELF BFD!"), asym->name);
d317 1
a317 1
	  einfo (_("%P%F: unknown ELF symbol visibility: %d!"),
d479 1
a479 1
	  einfo ("%P%F: %s: plugin symbol table corrupt (sym type %d)",
d874 1
a874 1
	einfo (_("%P%X: %s: hash table failure adding symbol %s"),
d907 1
a907 1
	einfo (_("%P%X: %s: can't find IR symbol '%s'"), nbfd->filename,
d910 1
a910 1
	einfo (_("%P%x: %s: bad IR symbol type %d"), name, blhe->type);
@


1.11
log
@Properly convert LTO plugin visibility to ELF visibility.

ld/

2010-12-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* plugin.c (asymbol_from_plugin_symbol): Properly convert LTO
	plugin visibility to ELF visibility.
	(is_visible_from_outside): Re-indent.

ld/testsuite/

2010-12-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-plugin/plugin-vis-1.d: Updated.
@
text
@d591 1
a591 1
				   format, NULL));
d597 2
@


1.10
log
@Re-indent plugin code.

2010-11-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldfile.c: Re-indent plugin code.
	* ldlang.c: Likewise.
	* ldmain.c: Likewise.
	* plugin.c: Likewise.
@
text
@d310 2
d314 21
a334 2
      elfsym->internal_elf_sym.st_other &= ~3;
      elfsym->internal_elf_sym.st_other |= ldsym->visibility;
d440 2
a441 2
      return lsym->visibility == LDPV_DEFAULT
	|| lsym->visibility == LDPV_PROTECTED;
@


1.9
log
@Set alignment of common plugin symbol to 1 for For ELF targets.

2010-11-20  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12246
	* plugin.c (asymbol_from_plugin_symbol): Set alignment of
	common symbol to 1 for For ELF targets.
@
text
@d264 1
a264 1
				const struct ld_plugin_symbol *ldsym)
d270 1
a270 1
  asym->name = ldsym->version
d272 1
a272 1
		: ldsym->name;
d392 1
a392 1
			struct bfd_link_hash_entry *blhe)
d410 1
a410 1
         what visibility the plugin would have liked to apply when it first
d420 1
a420 1
	  || lsym->visibility == LDPV_PROTECTED;
d439 1
a439 1
				FALSE, FALSE, TRUE);
d448 1
a448 1
		|| blhe->type == bfd_link_hash_undefweak)
d454 2
a455 2
		&& blhe->type != bfd_link_hash_defweak
		&& blhe->type != bfd_link_hash_common)
d459 1
a459 1
		called_plugin->name, blhe->type);
d466 2
a467 2
		? blhe->u.c.p->section
		: blhe->u.def.section;
d470 1
a470 1
         even potentially-referenced, perhaps in a future final link if
d477 3
a479 2
         resolved; determine how.  */
      if (syms[n].def == LDPK_UNDEF || syms[n].def == LDPK_WEAKUNDEF
d485 3
a487 3
	    syms[n].resolution = (ironly)
				? LDPR_PREVAILING_DEF_IRONLY
				: LDPR_PREVAILING_DEF;
d498 1
a498 1
         owner is the original dummy bfd that supplied it, then this
d504 1
a504 1
	  syms[n].resolution = (ironly)
d506 1
a506 1
				: LDPR_PREVAILING_DEF;
d512 2
a513 2
				? LDPR_PREEMPTED_IR
				: LDPR_PREEMPTED_REG;
d524 1
a524 1
	NULL))
d535 1
a535 1
	NULL))
d568 5
a572 5
      {
	char *newfmt = ACONCAT ((level == LDPL_FATAL ? "%F" : "%X",
				format, NULL));
	vfinfo (stderr, newfmt, args, TRUE);
      }
d599 51
a649 50
	  case LDPT_MESSAGE:
	    TVU(message) = message;
	    break;
	  case LDPT_API_VERSION:
	    TVU(val) = LD_PLUGIN_API_VERSION;
	    break;
	  case LDPT_GNU_LD_VERSION:
	    TVU(val) = major * 100 + minor;
	    break;
	  case LDPT_LINKER_OUTPUT:
	    TVU(val) = link_info.relocatable ? LDPO_REL
			: (link_info.shared ? LDPO_DYN : LDPO_EXEC);
	    break;
	  case LDPT_OUTPUT_NAME:
	    TVU(string) = output_filename;
	    break;
	  case LDPT_REGISTER_CLAIM_FILE_HOOK:
	    TVU(register_claim_file) = register_claim_file;
	    break;
	  case LDPT_REGISTER_ALL_SYMBOLS_READ_HOOK:
	    TVU(register_all_symbols_read) = register_all_symbols_read;
	    break;
	  case LDPT_REGISTER_CLEANUP_HOOK:
	    TVU(register_cleanup) = register_cleanup;
	    break;
	  case LDPT_ADD_SYMBOLS:
	    TVU(add_symbols) = add_symbols;
	    break;
	  case LDPT_GET_INPUT_FILE:
	    TVU(get_input_file) = get_input_file;
	    break;
	  case LDPT_RELEASE_INPUT_FILE:
	    TVU(release_input_file) = release_input_file;
	    break;
	  case LDPT_GET_SYMBOLS:
	    TVU(get_symbols) = get_symbols;
	    break;
	  case LDPT_ADD_INPUT_FILE:
	    TVU(add_input_file) = add_input_file;
	    break;
	  case LDPT_ADD_INPUT_LIBRARY:
	    TVU(add_input_library) = add_input_library;
	    break;
	  case LDPT_SET_EXTRA_LIBRARY_PATH:
	    TVU(set_extra_library_path) = set_extra_library_path;
	    break;
	  default:
	    /* Added a new entry to the array without adding
	       a new case to set up its value is a bug.  */
	    FAIL ();
d714 1
a714 1
        return set_plugin_error (curplug->name);
d720 1
a720 1
        return set_plugin_error (curplug->name);
d818 1
a818 1
          (struct bfd_hash_table *) xmalloc (sizeof (struct bfd_hash_table));
d837 2
a838 2
		const char *name, bfd *abfd,
		asection *section, bfd_vma value ATTRIBUTE_UNUSED)
d849 1
a849 1
         in the non-IR-only hash.  */
d851 2
a852 2
        einfo (_("%P%X: %s: hash table failure adding symbol %s"),
		abfd->filename, name);
d875 3
a877 3
		bfd *obfd, asection *osec ATTRIBUTE_UNUSED,
		bfd_vma oval ATTRIBUTE_UNUSED,
		bfd *nbfd, asection *nsec, bfd_vma nval)
d881 2
a882 2
      struct bfd_link_hash_entry *blhe = bfd_link_hash_lookup (info->hash,
					name, FALSE, FALSE, FALSE);
d885 1
a885 1
		name);
@


1.8
log
@	* plugin.c (is_visible_from_outside): New function.
	(get_symbols): Use it.
@
text
@d295 3
@


1.7
log
@	* plugin.h (plugin_active_plugins_p): New prototype.
	(is_ir_dummy_bfd): Delete prototype.
	* plugin.c: Fix formatting issues.
	(is_ir_dummy_bfd): Make static.
	(plugin_active_plugins_p): New function.
	* ldfile.c (ldfile_try_open_bfd): Use it to save work if no plugins
	are loaded.  Always close file descriptor after claim handler returns.
	* ldmain.c (add_archive_element): Likewise.
@
text
@d385 37
d433 1
d459 13
a471 2
      /* We need to know if the sym is referenced from non-IR files.  */
      ironly = !bfd_hash_lookup (non_ironly_hash, syms[n].name, FALSE, FALSE);
a477 3
	  asection *owner_sec = (blhe->type == bfd_link_hash_common)
				? blhe->u.c.p->section
				: blhe->u.def.section;
d496 1
a496 1
      if (blhe->u.def.section->owner == link_info.output_bfd)
d498 1
a498 1
      else if (blhe->u.def.section->owner == abfd)
d507 1
a507 1
      syms[n].resolution = is_ir_dummy_bfd (blhe->u.def.section->owner)
@


1.7.2.1
log
@	* plugin.c (is_visible_from_outside): New function.
	(get_symbols): Use it.
@
text
@a384 37
/* Return TRUE if a defined symbol might be reachable from outside the
   universe of claimed objects.  */
static inline bfd_boolean
is_visible_from_outside (struct ld_plugin_symbol *lsym, asection *section,
			struct bfd_link_hash_entry *blhe)
{
  /* Section's owner may be NULL if it is the absolute
     section, fortunately is_ir_dummy_bfd handles that.  */
  if (!is_ir_dummy_bfd (section->owner))
    return TRUE;
  if (link_info.relocatable)
    return TRUE;
  if (link_info.export_dynamic || link_info.shared)
    {
      /* Only ELF symbols really have visibility.  */
      if (bfd_get_flavour (link_info.output_bfd) == bfd_target_elf_flavour)
	{
	  struct elf_link_hash_entry *el = (struct elf_link_hash_entry *)blhe;
	  int vis = ELF_ST_VISIBILITY (el->other);
	  return vis == STV_DEFAULT || vis == STV_PROTECTED;
	}
      /* On non-ELF targets, we can safely make inferences by considering
         what visibility the plugin would have liked to apply when it first
	 sent us the symbol.  During ELF symbol processing, visibility only
	 ever becomes more restrictive, not less, when symbols are merged,
	 so this is a conservative estimate; it may give false positives,
	 declaring something visible from outside when it in fact would
	 not have been, but this will only lead to missed optimisation
	 opportunities during LTRANS at worst; it will not give false
	 negatives, which can lead to the disastrous conclusion that the
	 related symbol is IRONLY.  (See GCC PR46319 for an example.)  */
      return lsym->visibility == LDPV_DEFAULT
	  || lsym->visibility == LDPV_PROTECTED;
    }
  return FALSE;
}

a395 1
      asection *owner_sec;
d421 2
a422 13
      /* Find out which section owns the symbol.  Since it's not undef,
	 it must have an owner; if it's not a common symbol, both defs
	 and weakdefs keep it in the same place. */
      owner_sec = (blhe->type == bfd_link_hash_common)
		? blhe->u.c.p->section
		: blhe->u.def.section;

      /* We need to know if the sym is referenced from non-IR files.  Or
         even potentially-referenced, perhaps in a future final link if
	 this is a partial one, perhaps dynamically at load-time if the
	 symbol is externally visible.  */
      ironly = !is_visible_from_outside (&syms[n], owner_sec, blhe)
	&& !bfd_hash_lookup (non_ironly_hash, syms[n].name, FALSE, FALSE);
d429 3
d450 1
a450 1
      if (owner_sec->owner == link_info.output_bfd)
d452 1
a452 1
      else if (owner_sec->owner == abfd)
d461 1
a461 1
      syms[n].resolution = is_ir_dummy_bfd (owner_sec->owner)
@


1.7.2.2
log
@backport from mainline
@
text
@d2 1
a2 1
   Copyright 2010, 2011 Free Software Foundation, Inc.
a110 3
/* Call 'cleanup' hook for all plugins at exit.  */
static void plugin_call_cleanup (void);

a236 2
  bfd_copy_private_bfd_data (srctemplate, abfd);
  bfd_set_gp_size (abfd, bfd_get_gp_size (abfd));
d264 1
a264 1
			    const struct ld_plugin_symbol *ldsym)
d270 1
a270 1
  asym->name = (ldsym->version
d272 1
a272 1
		: ldsym->name);
a294 3
      /* For ELF targets, set alignment of common symbol to 1.  */
      if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)
	((elf_symbol_type *) asym)->internal_elf_sym.st_value = 1;
a306 2
      unsigned char visibility;

d308 3
a310 22
	einfo (_("%P%F: %s: non-ELF symbol in ELF BFD!\n"), asym->name);
      switch (ldsym->visibility)
	{
	default:
	  einfo (_("%P%F: unknown ELF symbol visibility: %d!\n"),
		 ldsym->visibility);
	case LDPV_DEFAULT:
	  visibility = STV_DEFAULT;
	  break;
	case LDPV_PROTECTED:
	  visibility = STV_PROTECTED;
	  break;
	case LDPV_INTERNAL:
	  visibility = STV_INTERNAL;
	  break;
	case LDPV_HIDDEN:
	  visibility = STV_HIDDEN;
	  break;
	}
      elfsym->internal_elf_sym.st_other
	= (visibility | (elfsym->internal_elf_sym.st_other
			 & ~ELF_ST_VISIBILITY (-1)));
d389 1
a389 1
			 struct bfd_link_hash_entry *blhe)
d407 1
a407 1
	 what visibility the plugin would have liked to apply when it first
d416 2
a417 2
      return (lsym->visibility == LDPV_DEFAULT
	      || lsym->visibility == LDPV_PROTECTED);
d436 1
a436 1
				   FALSE, FALSE, TRUE);
d445 1
a445 1
	  || blhe->type == bfd_link_hash_undefweak)
d451 2
a452 2
	  && blhe->type != bfd_link_hash_defweak
	  && blhe->type != bfd_link_hash_common)
d455 2
a456 2
	  einfo ("%P%F: %s: plugin symbol table corrupt (sym type %d)\n",
		 called_plugin->name, blhe->type);
d463 2
a464 2
	? blhe->u.c.p->section
	: blhe->u.def.section;
d467 1
a467 1
	 even potentially-referenced, perhaps in a future final link if
d474 2
a475 3
	 resolved; determine how.  */
      if (syms[n].def == LDPK_UNDEF
	  || syms[n].def == LDPK_WEAKUNDEF
d481 3
a483 3
	    syms[n].resolution = (ironly
				  ? LDPR_PREVAILING_DEF_IRONLY
				  : LDPR_PREVAILING_DEF);
d486 1
a486 2
	  else if (owner_sec->owner != NULL
		   && (owner_sec->owner->flags & DYNAMIC) != 0)
d494 1
a494 1
	 owner is the original dummy bfd that supplied it, then this
d500 1
a500 1
	  syms[n].resolution = (ironly
d502 1
a502 1
				: LDPR_PREVAILING_DEF);
d508 2
a509 2
	? LDPR_PREEMPTED_IR
	: LDPR_PREEMPTED_REG;
d520 1
a520 1
			    NULL))
d531 1
a531 1
			    NULL))
a556 1
      putchar ('\n');
a559 1
      putchar ('\n');
d564 5
a568 8
	{
	  char *newfmt = ACONCAT ((level == LDPL_FATAL
				   ? "%P%F: " : "%P%X: ",
				   format, "\n", NULL));
	  fflush (stdout);
	  vfinfo (stderr, newfmt, args, TRUE);
	  fflush (stderr);
	}
d595 50
a644 51
	case LDPT_MESSAGE:
	  TVU(message) = message;
	  break;
	case LDPT_API_VERSION:
	  TVU(val) = LD_PLUGIN_API_VERSION;
	  break;
	case LDPT_GNU_LD_VERSION:
	  TVU(val) = major * 100 + minor;
	  break;
	case LDPT_LINKER_OUTPUT:
	  TVU(val) = (link_info.relocatable
		      ? LDPO_REL
		      : (link_info.shared ? LDPO_DYN : LDPO_EXEC));
	  break;
	case LDPT_OUTPUT_NAME:
	  TVU(string) = output_filename;
	  break;
	case LDPT_REGISTER_CLAIM_FILE_HOOK:
	  TVU(register_claim_file) = register_claim_file;
	  break;
	case LDPT_REGISTER_ALL_SYMBOLS_READ_HOOK:
	  TVU(register_all_symbols_read) = register_all_symbols_read;
	  break;
	case LDPT_REGISTER_CLEANUP_HOOK:
	  TVU(register_cleanup) = register_cleanup;
	  break;
	case LDPT_ADD_SYMBOLS:
	  TVU(add_symbols) = add_symbols;
	  break;
	case LDPT_GET_INPUT_FILE:
	  TVU(get_input_file) = get_input_file;
	  break;
	case LDPT_RELEASE_INPUT_FILE:
	  TVU(release_input_file) = release_input_file;
	  break;
	case LDPT_GET_SYMBOLS:
	  TVU(get_symbols) = get_symbols;
	  break;
	case LDPT_ADD_INPUT_FILE:
	  TVU(add_input_file) = add_input_file;
	  break;
	case LDPT_ADD_INPUT_LIBRARY:
	  TVU(add_input_library) = add_input_library;
	  break;
	case LDPT_SET_EXTRA_LIBRARY_PATH:
	  TVU(set_extra_library_path) = set_extra_library_path;
	  break;
	default:
	  /* Added a new entry to the array without adding
	     a new case to set up its value is a bug.  */
	  FAIL ();
a686 2
  xatexit (plugin_call_cleanup);

d709 1
a709 1
	return set_plugin_error (curplug->name);
d715 1
a715 1
	return set_plugin_error (curplug->name);
d783 2
a784 2
/* Call 'cleanup' hook for all plugins at exit.  */
static void
d803 1
a803 3
  if (plugin_error_p ())
    info_msg (_("%P: %s: error in plugin cleanup (ignored)\n"),
	      plugin_error_plugin ());
d813 1
a813 1
	(struct bfd_hash_table *) xmalloc (sizeof (struct bfd_hash_table));
d832 2
a833 2
	       const char *name, bfd *abfd,
	       asection *section, bfd_vma value ATTRIBUTE_UNUSED)
d844 1
a844 1
	 in the non-IR-only hash.  */
d846 2
a847 2
	einfo (_("%P%X: %s: hash table failure adding symbol %s\n"),
	       abfd->filename, name);
d870 3
a872 3
			    bfd *obfd, asection *osec ATTRIBUTE_UNUSED,
			    bfd_vma oval ATTRIBUTE_UNUSED,
			    bfd *nbfd, asection *nsec, bfd_vma nval)
d876 2
a877 2
      struct bfd_link_hash_entry *blhe
	= bfd_link_hash_lookup (info->hash, name, FALSE, FALSE, FALSE);
d879 2
a880 2
	einfo (_("%P%X: %s: can't find IR symbol '%s'\n"), nbfd->filename,
	       name);
d882 1
a882 1
	einfo (_("%P%x: %s: bad IR symbol type %d\n"), name, blhe->type);
@


1.7.2.3
log
@	* ldmain.c (remove_output): Rename to..
	(ld_cleanup): ..this. Call bfd_cache_close_all and plugin_call_cleanup.
	(main): Adjust.
	* plugin.c (plugin_call_cleanup): Make global.
	(plugin_load_plugins): Don't register plugin_call_cleanup with xatexit.
	* plugin.h (plugin_call_cleanup): Declare.
@
text
@d111 3
d724 2
d823 1
a823 1
void
@


1.7.2.4
log
@	PR ld/12696
	PR ld/12672
	PR ld/12507
	PR ld/12365
	PR 10549
Backport fixes for these PRs.
@
text
@a38 3
/* Report plugin symbols.  */
bfd_boolean report_plugin_symbols;

d41 6
a46 2
   plugin.  For cosmetic use only; appears in maps, crefs etc.  */
#define IRONLY_SUFFIX " (symbol from plugin)"
d94 6
a99 6
/* State of linker "notice" interface before we poked at it.  */
static bfd_boolean orig_notice_all;

/* Original linker callbacks, and the plugin version.  */
static const struct bfd_link_callbacks *orig_callbacks;
static struct bfd_link_callbacks plugin_callbacks;
d103 7
a109 1
bfd_boolean no_more_claiming = FALSE;
a133 5
/* Forward references.  */
static bfd_boolean plugin_notice (struct bfd_link_info *info,
				  struct bfd_link_hash_entry *h, bfd *abfd,
				  asection *section, bfd_vma value);

d229 1
d233 1
a233 1
  abfd = bfd_create (concat (name, IRONLY_SUFFIX, (const char *) NULL),
d235 12
a246 19
  if (abfd != NULL)
    {
      abfd->flags |= BFD_LINKER_CREATED | BFD_PLUGIN;
      bfd_set_arch_info (abfd, bfd_get_arch_info (srctemplate));
      bfd_set_gp_size (abfd, bfd_get_gp_size (srctemplate));
      if (bfd_make_writable (abfd)
	  && bfd_copy_private_bfd_data (srctemplate, abfd))
	{
	  flagword flags;

	  /* Create sections to own the symbols.  */
	  flags = (SEC_CODE | SEC_HAS_CONTENTS | SEC_READONLY
		   | SEC_ALLOC | SEC_LOAD | SEC_KEEP | SEC_EXCLUDE);
	  if (bfd_make_section_anyway_with_flags (abfd, ".text", flags))
	    return abfd;
	}
    }
  einfo (_("could not create dummy IR bfd: %F%E\n"));
  return NULL;
d253 8
a260 8
  /* ABFD can sometimes legitimately be NULL, e.g. when called from one
     of the linker callbacks for a symbol in the *ABS* or *UND* sections.
     Likewise, the usrdata field may be NULL if ABFD was added by the
     backend without a corresponding input statement, as happens e.g.
     when processing DT_NEEDED dependencies.  */
  return (abfd
	  && abfd->usrdata
	  && ((lang_input_statement_type *)(abfd->usrdata))->claimed);
d273 1
a273 1
		? concat (ldsym->name, "@@", ldsym->version, (const char *) NULL)
d299 1
a299 4
	{
	  ((elf_symbol_type *) asym)->internal_elf_sym.st_shndx = SHN_COMMON;
	  ((elf_symbol_type *) asym)->internal_elf_sym.st_value = 1;
	}
a416 2
  struct bfd_sym_chain *sym;

a444 6

  for (sym = &entry_symbol; sym != NULL; sym = sym->next)
    if (sym->name
	&& strcmp (sym->name, blhe->root.string) == 0)
      return TRUE;

d460 3
a462 6
      if (syms[n].def != LDPK_UNDEF)
	blhe = bfd_link_hash_lookup (link_info.hash, syms[n].name,
				     FALSE, FALSE, TRUE);
      else
	blhe = bfd_wrapped_link_hash_lookup (link_info.output_bfd, &link_info,
					     syms[n].name, FALSE, FALSE, TRUE);
d466 1
a466 1
	  goto report_symbol;
d474 1
a474 1
	  goto report_symbol;
d488 3
a490 3
      owner_sec = (blhe->type == bfd_link_hash_common
		   ? blhe->u.c.p->section
		   : blhe->u.def.section);
d496 2
a497 2
      ironly = !(blhe->non_ir_ref
		 || is_visible_from_outside (&syms[n], owner_sec, blhe));
d518 1
a518 1
	  goto report_symbol;
d531 1
a531 1
	  goto report_symbol;
d535 3
a537 10
      syms[n].resolution = (is_ir_dummy_bfd (owner_sec->owner)
			    ? LDPR_PREEMPTED_IR
			    : LDPR_PREEMPTED_REG);

    report_symbol:
      if (report_plugin_symbols)
	einfo (_("%P: %B: symbol `%s' "
		 "definition: %d, visibility: %d, resolution: %d\n"),
	       abfd, syms[n].name,
	       syms[n].def, syms[n].visibility, syms[n].resolution);
d594 8
a601 7
      {
	char *newfmt = ACONCAT ((level == LDPL_FATAL ? "%P%F: " : "%P%X: ",
				 format, "\n", (const char *) NULL));
	fflush (stdout);
	vfinfo (stderr, newfmt, args, TRUE);
	fflush (stderr);
      }
a755 4
  orig_notice_all = link_info.notice_all;
  orig_callbacks = link_info.callbacks;
  plugin_callbacks = *orig_callbacks;
  plugin_callbacks.notice = &plugin_notice;
a756 1
  link_info.callbacks = &plugin_callbacks;
d762 1
a762 1
static int
a784 36
void
plugin_maybe_claim (struct ld_plugin_input_file *file,
		    lang_input_statement_type *entry)
{
  int claimed = 0;

  /* We create a dummy BFD, initially empty, to house whatever symbols
     the plugin may want to add.  */
  file->handle = plugin_get_ir_dummy_bfd (entry->the_bfd->filename,
					  entry->the_bfd);
  if (plugin_call_claim_file (file, &claimed))
    einfo (_("%P%F: %s: plugin reported error claiming file\n"),
	   plugin_error_plugin ());
  /* fd belongs to us, not the plugin; but we don't need it.  */
  close (file->fd);
  if (claimed)
    {
      /* Discard the real file's BFD and substitute the dummy one.  */

      /* BFD archive handling caches elements so we can't call
	 bfd_close for archives.  */
      if (entry->the_bfd->my_archive == NULL)
	bfd_close (entry->the_bfd);
      entry->the_bfd = file->handle;
      entry->claimed = TRUE;
      bfd_make_readable (entry->the_bfd);
    }
  else
    {
      /* If plugin didn't claim the file, we don't need the dummy bfd.
	 Can't avoid speculatively creating it, alas.  */
      bfd_close_all_done (file->handle);
      entry->claimed = FALSE;
    }
}

d794 7
d842 16
d860 29
a888 33
   the linker adds them to the linker hash table.  Mark those
   referenced from a non-IR file with non_ir_ref.  We have to
   notice_all symbols, because we won't necessarily know until later
   which ones will be contributed by IR files.  */
static bfd_boolean
plugin_notice (struct bfd_link_info *info,
	       struct bfd_link_hash_entry *h,
	       bfd *abfd,
	       asection *section,
	       bfd_vma value)
{
  if (h != NULL)
    {
      /* No further processing if this def/ref is from an IR dummy BFD.  */
      if (is_ir_dummy_bfd (abfd))
	return TRUE;

      /* If this is a ref, set non_ir_ref.  */
      if (bfd_is_und_section (section))
	h->non_ir_ref = TRUE;

      /* Otherwise, it must be a new def.  Ensure any symbol defined
	 in an IR dummy BFD takes on a new value from a real BFD.
	 Weak symbols are not normally overridden by a new weak
	 definition, and strong symbols will normally cause multiple
	 definition errors.  Avoid this by making the symbol appear
	 to be undefined.  */
      else if (((h->type == bfd_link_hash_defweak
		 || h->type == bfd_link_hash_defined)
		&& is_ir_dummy_bfd (h->u.def.section->owner))
	       || (h->type == bfd_link_hash_common
		   && is_ir_dummy_bfd (h->u.c.p->section->owner)))
	h->type = bfd_link_hash_undefweak;
a891 6
  if (h == NULL
      || orig_notice_all
      || (info->notice_hash != NULL
	  && bfd_hash_lookup (info->notice_hash, h->root.string,
			      FALSE, FALSE) != NULL))
    return (*orig_callbacks->notice) (info, h, abfd, section, value);
d894 32
@


1.7.2.5
log
@	PR ld/12760
	* plugin.c (plugin_notice): Set u.undef.abfd for symbols made
	undefweak.
@
text
@a914 2
      bfd *sym_bfd;

d931 1
a931 1
		&& is_ir_dummy_bfd (sym_bfd = h->u.def.section->owner))
d933 2
a934 5
		   && is_ir_dummy_bfd (sym_bfd = h->u.c.p->section->owner)))
	{
	  h->type = bfd_link_hash_undefweak;
	  h->u.undef.abfd = sym_bfd;
	}
@


1.7.2.6
log
@	PR 12365
	PR 12613
	PR 12632
	PR 12739
	PR 12753
	PR 12760
	PR 12763
Apply fix from mainline along with assorted other small fixes.
@
text
@d128 3
a130 3
static bfd_boolean plugin_notice (struct bfd_link_info *,
				  struct bfd_link_hash_entry *, bfd *,
				  asection *, bfd_vma, flagword, const char *);
d911 1
a911 3
	       bfd_vma value,
	       flagword flags,
	       const char *string)
a920 25
      /* Making an indirect symbol counts as a reference unless this
	 is a brand new symbol.  */
      if (bfd_is_ind_section (section)
	  || (flags & BSF_INDIRECT) != 0)
	{
	  if (h->type != bfd_link_hash_new)
	    {
	      struct bfd_link_hash_entry *inh;

	      h->non_ir_ref = TRUE;
	      inh = bfd_wrapped_link_hash_lookup (abfd, info, string, FALSE,
						  FALSE, FALSE);
	      if (inh != NULL)
		inh->non_ir_ref = TRUE;
	    }
	}

      /* Nothing to do here for warning symbols.  */
      else if ((flags & BSF_WARNING) != 0)
	;

      /* Nothing to do here for constructor symbols.  */
      else if ((flags & BSF_CONSTRUCTOR) != 0)
	;

d922 1
a922 1
      else if (bfd_is_und_section (section))
d948 1
a948 2
    return (*orig_callbacks->notice) (info, h,
				      abfd, section, value, flags, string);
@


1.6
log
@	* plugin.c (is_ir_dummy_bfd): Don't segfault on NULL abfd.
@
text
@d175 2
a176 1
const char *plugin_error_plugin (void)
d182 2
a183 1
int plugin_opt_plugin (const char *plugin)
d206 2
a207 1
int plugin_opt_plugin_arg (const char *arg)
d247 2
a248 2
/* Check if the BFD is an IR dummy.  */
bfd_boolean
d621 8
d630 2
a631 1
int plugin_load_plugins (void)
@


1.5
log
@	* plugin.c (plugin_get_ir_dummy_bfd): Set bfd_use_reserved_id.
	Formatting.
@
text
@d248 5
a252 1
  size_t namlen = strlen (abfd->filename);
@


1.4
log
@	* plugin.c (get_symbols): Check symbol type correctly.
@
text
@d227 5
a231 3
  bfd *abfd = bfd_create (
		concat (name, IRONLY_SUFFIX, (const char *)NULL),
		srctemplate);
d237 2
a238 2
	SEC_CODE | SEC_HAS_CONTENTS | SEC_READONLY
	| SEC_ALLOC | SEC_LOAD | SEC_KEEP);
@


1.3
log
@Provide win32-based dlapi replacements on windows platforms without dlfcn.h.

ld/ChangeLog:

	* configure.in: If <dlfcn.h> can't be found, try for <Windows.h>
	* configure: Regenerate.
	* config.in: Likewise.
	* plugin.c [!HAVE_DLFCN_H && HAVE_WINDOWS_H] (dlopen): Provide
	trival LoadLibrary-based replacement for Windows systems.
	[!HAVE_DLFCN_H && HAVE_WINDOWS_H] (dlsym): Likewise trivial
	replacement based on GetProcAddress.
	[!HAVE_DLFCN_H && HAVE_WINDOWS_H] (dlsym): Likewise FreeLibrary.
	* sysdep.h: Don't infer presence of <dlfcn.h> from ENABLE_PLUGINS
	anymore, use its own guard.
@
text
@d420 1
a420 1
	  asection *owner_sec = (syms[n].def == LDPK_COMMON)
@


1.2
log
@Fix potential use-after-free bugs.

ld/ChangeLog:

	* plugin.c (add_input_file): Take copy of input string.
	(add_input_library): Likewise.
	(set_extra_library_path): Likewise.
@
text
@d35 3
d134 25
@


1.1
log
@Applied patch series for LD plugin interface (six parts).

[PATCH] Add infrastructure for plugin API; functionality to follow.

    include/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 1/6).
	* plugin-api.h (LDPT_GNU_LD_VERSION): New ld_plugin_tag enum member.

    ld/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 1/6).
	* configure.in: Add AC_CHECKs for file io and dlfcn headers and
	functions and AC_SEARCH for -ldl.
	(enable_plugins): New shell variable set if above tests find dlopen
	functionality.
	(ENABLE_PLUGINS): Add related automake conditional.
	* configure: Regenerate.
	* config.in: Likewise.
	* Makefile.am (PLUGIN_C): Declare plugin C source file, conditional
	on ENABLE_PLUGINS being defined.
	(PLUGIN_H): Likewise for header file.
	(PLUGIN_OBJECT): Likewise for object file.
	(PLUGIN_CFLAGS): Likewise -D flag required to compile plugin support.
	(AM_CPPFLAGS): Use PLUGIN_CFLAGS.
	(CFILES): Use PLUGIN_C.
	(HFILES): Use PLUGIN_H.
	(OFILES): Use PLUGIN_OBJECT.
	(ld_new_SOURCES): Use PLUGIN_C.
	(noinst_LTLIBRARIES)[ENABLE_PLUGINS]: Declare test plugin.
	(libldtestplug_la_SOURCES)[ENABLE_PLUGINS]: Add automake definition
	for test plugin.
	(libldtestplug_la_CFLAGS)[ENABLE_PLUGINS]: Likewise.
	(libldtestplug_la_LDFLAGS)[ENABLE_PLUGINS]: Likewise.
	* Makefile.in: Regenerate.
	* sysdep.h: Include stdarg.h, unistd.h and one of fcntl.h or
	sys/file.h where available.  Include dlfcn.h when ENABLE_PLUGINS.
	(O_RDONLY): Supply default definition likewise to bfd's sysdep.h
	(O_WRONLY): Likewise.
	(O_RDWR): Likewise.
	(O_ACCMODE): Likewise.
	(O_BINARY): Likewise.
	(SEEK_SET): Likewise.
	(SEEK_CUR): Likewise.
	(SEEK_END): Likewise.
	* ldmisc.c (vfinfo): Make non-static.  Add %p format char.
	* ldmisc.h (vfinfo): Declare extern prototype.
	* lexsup.c (enum option_values)[ENABLE_PLUGINS]: Add new entries for
	OPTION_PLUGIN and OPTION_PLUGIN_OPT.
	(ld_options[])[ENABLE_PLUGINS]: Add option data for the above two.
	(parse_args)[ENABLE_PLUGINS]: Handle them, and load all plugins once
	option parsing is complete.
	* ldmain.c (main)[ENABLE_PLUGINS]: Call plugin cleanup hooks just
	after lang_finish.
	* plugin.c: New source file.
	* plugin.h: Likewise new header.
	* testplug.c: New source file.

    ld/testsuite/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 1/6).
	* ld-bootstrap/bootstrap.exp: Skip static tests also if LD plugins
	are enabled.
	* lib/ld-lib.exp (proc regexp_diff): Extend verbose debug output.
	(proc set_file_contents): Write a file with the supplied content.
	(run_ld_link_tests): Add new 'ld' action to test linker output.
	(proc check_plugin_api_available): Return true if linker under test
	supports the plugin API.
	* ld-plugin/func.c: New test source file.
	* ld-plugin/main.c: Likewise.
	* ld-plugin/text.c: Likewise.
	* ld-plugin/plugin-1.d: New dump test output pattern script.
	* ld-plugin/plugin-2.d: Likewise.
	* ld-plugin/plugin-3.d: Likewise.
	* ld-plugin/plugin-4.d: Likewise.
	* ld-plugin/plugin-5.d: Likewise.
	* ld-plugin/plugin.exp: New test control script.
---
[PATCH] Implement claim file and all symbols read hooks and add symbols callback.

  ld/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 2/6).
	* ldfile.c (ldfile_try_open_bfd)[ENABLE_PLUGINS]: Don't return early
	during compat checks if they pass, instead offer any successfully
	opened and accepted file to the plugin claim file hooks chain.  Create
	a dummy bfd to accept symbols added by the plugin, if the plugin
	claims the file.
	* ldlang.c (lang_process)[ENABLE_PLUGINS]: Call plugin all symbols
	read hook chain before ldemul_after_open.
	* ldlang.h (struct lang_input_statement_struct): Add new single-bit
	'claimed' flag.
	* plugin.c (IRONLY_SUFFIX): New macro for dummy bfd file suffix.
	(IRONLY_SUFFIX_LEN): Length of the above string.
	(plugin_get_ir_dummy_bfd): New function to create the dummy bfd used
	to store symbols for ir-only files.
	(is_ir_dummy_bfd): New function to check if a bfd is ir-only.
	(asymbol_from_plugin_symbol): New function converts symbol formats.
	(add_symbols): Call it to convert plugin syms to bfd syms and add
	them to the dummy bfd.
	* plugin.h: Add missing include guards.
	(plugin_get_ir_dummy_bfd): Add prototype.
	(is_ir_dummy_bfd): Likewise.
	* testplug.c (TV_MESSAGE): New helper macro.
	(struct claim_file): New struct.
	(claim_file_t): New typedef.
	(tag_names[]): Make static and const.
	(claimfiles_list): New variable.
	(claimfiles_tail_chain_ptr): Likewise.
	(last_claimfile): Likewise.
	(record_claim_file): Record a file to claim on a singly-linked list.
	(parse_symdefstr): Parse an ASCII representation of a symbol from a
	plugin option into the fields of a struct ld_plugin_symbol.
	(record_claimed_file_symbol):  Use it to parse plugin option for
	adding a symbol.
	(parse_option): Parse claim file and add symbol options.
	(dump_tv_tag): Use TV_MESSAGE.
	(onload): Likewise.
	(onclaim_file): Make static.  Use TV_MESSAGE.  Scan list of files to
	claim and claim this file if required, adding any symbols specified.
	(onall_symbols_read): Make static and use TV_MESSAGE.
	(oncleanup): Likewise.

  ld/testsuite/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 2/6).
	* ld-plugin/plugin-3.d: Enable regexes for new functionality.
	* ld-plugin/plugin-5.d: Likewise.
	* ld-plugin/plugin-6.d: New testcase.
	* ld-plugin/plugin-7.d: Likewise.
	* ld-plugin/plugin.exp: Use 'nm' on compiled test objects to determine
	whether symbols in plugin arguments need an underscore prefix.  Add
	new plugin-6.d and plugin-7.d testcases.
---
[PATCH] Implement get symbols callback.

  ld/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 3/6).
	* ldmain.c (notice)[ENABLE_PLUGINS]: Call plugin_notice.
	* plugin.c (non_ironly_hash): Add new bfd hash table.
	(plugin_load_plugins): Exit early if no plugins to load.  If plugins
	do load successfully, set notice_all flag in link info.
	(get_symbols): Implement.
	(plugin_load_plugins): Exit early if no plugins to load, else after
	loading plugins successfully enable notice_all mode.
	(init_non_ironly_hash): Lazily init non_ironly_hash table.
	(plugin_notice): Record symbols referenced from non-IR files in the
	non_ironly_hash.  Suppress tracing, cref generation and nocrossrefs
	tracking for symbols from dummy IR bfds.
	* plugin.h: Fix formatting.
	(plugin_notice): Add prototype.
	* testplug.c (dumpresolutions): New global var.
	(parse_options): Accept "dumpresolutions".
	(onall_symbols_read): Get syms and dump resolutions if it was given.

  ld/testsuite/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 3/6).
	* ld-plugin/plugin-8.d: New testcase.
	* ld-plugin/plugin.exp: Invoke it.
---
[PATCH] Implement add input file, add input lib and set extra lib path callbacks.

  ld/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 4/6).
	* ldlang.c (lang_process)[ENABLE_PLUGINS]: Move invocation of
	plugin_call_all_symbols_read to before setting of gc_sym_list, and
	open any new input files that may have been added during it.
	* ldmain.c (multiple_definition)[ENABLE_PLUGINS]: Call out to
	plugin_multiple_definition and let it have first say over what to do
	with the clashing definitions.
	* plugin.c (no_more_claiming): New boolean variable.
	(plugin_cached_allow_multiple_defs): Likewise.
	(add_input_file): Implement.
	(add_input_library): Likewise.
	(set_extra_library_path): Likewise.
	(plugin_call_claim_file): Don't do anything when no_more_claiming set.
	(plugin_call_all_symbols_read): Set it.  Disable link info
	"allow_multiple_definition" flag, but cache its value.
	(plugin_multiple_definition): New function.
	* plugin.h (plugin_multiple_definition): Add prototype.
	* testplug.c (addfile_enum_t): New enumerated typedef.
	(add_file_t): New struct typedef.
	(addfiles_list): New variable.
	(addfiles_tail_chain_ptr): Likewise.
	(record_add_file): New function.
	(parse_option): Parse "add:", "lib:" and "dir:" options and call it.
	(onall_symbols_read): Iterate the list of new files, libs and dirs,
	adding them.

  ld/testsuite/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 4/6).
	* ld-plugin/plugin-9.d: New testcase.
	* ld-plugin/plugin.exp: Invoke it.
---
[PATCH] Add ELF symbol visibility support to plugin interface.

  ld/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 5/6).
	* plugin.c (asymbol_from_plugin_symbol): If the bfd is an ELF bfd,
	find the elf symbol data and set the visibility in the st_other field.

  ld/testsuite/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 5/6).
	* ld-plugin/plugin-ignore.d: New dump test control script.
	* ld-plugin/plugin-vis-1.d: Likewise.
	* ld-plugin/plugin.exp: Add list of ELF-only tests and run them if
	testing on an ELF target.
---
[PATCH] Add archive support to plugin interface.

  bfd/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 6/6).
	* aoutx.h (aout_link_check_ar_symbols): Take new "subsbfd" reference
	parameter and pass it when invoking add_archive_element callback.
	(aout_link_check_archive_element): Handle substitute bfd if it
	was set during add_archive_element callback in the above.
	* cofflink.c (coff_link_check_ar_symbols): Take new "subsbfd" reference
	parameter and pass it when invoking add_archive_element callback.
	(coff_link_check_archive_element): Handle substitute bfd if it
	was set during add_archive_element callback in the above.
	* ecoff.c (read_ext_syms_and_strs): New function holds symbol-reading
	code factored-out from ecoff_link_check_archive_element.
	(reread_ext_syms_and_strs): Clear old symbols and call it.
	(ecoff_link_check_archive_element):  Use the above.  Handle substitute
	BFD if one is set by add_archive_element callback.
	(ecoff_link_add_archive_symbols): Likewise allow bfd substitution.
	* elflink.c (elf_link_add_archive_symbols): Likewise.
	* linker.c (generic_link_check_archive_element): Likewise.
	* pdp11.c (aout_link_check_ar_symbols): Take new "subsbfd" reference
	parameter and pass it when invoking add_archive_element callback.
	(aout_link_check_archive_element): Handle substitute bfd if it was
	set during add_archive_element callback in the above.
	* vms-alpha.c (alpha_vms_link_add_archive_symbols): Handle substitute
	BFD if one is set by add_archive_element callback.
	* xcofflink.c (xcoff_link_check_dynamic_ar_symbols): Take new "subsbfd"
	reference parameter and pass it when invoking add_archive_element
	callback.
	(xcoff_link_check_ar_symbols): Likewise.
	(xcoff_link_check_archive_element): Handle bfd substitution if it was
	set by callback in the above.

  include/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 6/6).
	* bfdlink.h (struct_bfd_link_callbacks): Document new argument
	to add_archive_element callback used to return a replacement bfd which
	is to be added to the hash table in place of the original element.

  ld/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 6/6).
	* ldlang.c (load_symbols): Handle bfd subsitution when calling the
	add_archive_element callback.
	* ldmain.c (add_archive_element)[ENABLE_PLUGINS]: Offer the archive
	member to the plugins and if claimed set "subsbfd" output parameter to
	point to the dummy IR-only BFD.

  ld/testsuite/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 6/6).
	* ld-plugin/plugin-10.d: New dump test control script.
	* ld-plugin/plugin-11.d: Likewise.
	* ld-plugin/plugin.exp: Run them.
---
@
text
@d436 2
a437 1
  if (!lang_add_input_file (pathname, lang_input_file_is_file_enum, NULL))
d447 2
a448 1
  if (!lang_add_input_file (pathname, lang_input_file_is_l_enum, NULL))
d459 1
a459 1
  ldfile_add_library_path (path, FALSE);
@

