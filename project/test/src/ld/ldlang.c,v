head	1.407;
access;
symbols
	binutils-2_24-branch:1.407.0.2
	binutils-2_24-branchpoint:1.407
	binutils-2_21_1:1.347.2.6
	binutils-2_23_2:1.397.2.5
	binutils-2_23_1:1.397.2.2
	binutils-2_23:1.397.2.2
	binutils-2_23-branch:1.397.0.2
	binutils-2_23-branchpoint:1.397
	binutils-2_22_branch:1.378.2.1.0.2
	binutils-2_22:1.378.2.1
	binutils-2_22-branch:1.378.0.2
	binutils-2_22-branchpoint:1.378
	binutils-2_21:1.347
	binutils-2_21-branch:1.347.0.2
	binutils-2_21-branchpoint:1.347
	binutils-2_20_1:1.317.2.4
	binutils-2_20:1.317.2.4
	binutils-arc-20081103-branch:1.296.0.4
	binutils-arc-20081103-branchpoint:1.296
	binutils-2_20-branch:1.317.0.2
	binutils-2_20-branchpoint:1.317
	dje-cgen-play1-branch:1.311.0.2
	dje-cgen-play1-branchpoint:1.311
	arc-20081103-branch:1.296.0.2
	arc-20081103-branchpoint:1.296
	binutils-2_19_1:1.292
	binutils-2_19:1.292
	binutils-2_19-branch:1.292.0.2
	binutils-2_19-branchpoint:1.292
	binutils-2_18:1.268
	binutils-2_18-branch:1.268.0.2
	binutils-2_18-branchpoint:1.268
	binutils-csl-coldfire-4_1-32:1.213.2.3
	binutils-csl-sourcerygxx-4_1-32:1.213.2.3
	binutils-csl-innovasic-fido-3_4_4-33:1.213.2.3
	binutils-csl-sourcerygxx-3_4_4-32:1.173.2.1.4.1
	binutils-csl-coldfire-4_1-30:1.213.2.3
	binutils-csl-sourcerygxx-4_1-30:1.213.2.3
	binutils-csl-coldfire-4_1-28:1.213.2.3
	binutils-csl-sourcerygxx-4_1-29:1.213.2.3
	binutils-csl-sourcerygxx-4_1-28:1.213.2.3
	binutils-csl-arm-2006q3-27:1.213.2.3
	binutils-csl-sourcerygxx-4_1-27:1.213.2.3
	binutils-csl-arm-2006q3-26:1.213.2.3
	binutils-csl-sourcerygxx-4_1-26:1.213.2.3
	binutils-csl-sourcerygxx-4_1-25:1.213.2.3
	binutils-csl-sourcerygxx-4_1-24:1.213.2.3
	binutils-csl-sourcerygxx-4_1-23:1.213.2.3
	binutils-csl-sourcerygxx-4_1-21:1.213.2.3
	binutils-csl-arm-2006q3-21:1.213.2.3
	binutils-csl-sourcerygxx-4_1-22:1.213.2.3
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.213.2.3
	binutils-csl-sourcerygxx-4_1-20:1.213.2.3
	binutils-csl-arm-2006q3-19:1.213.2.3
	binutils-csl-sourcerygxx-4_1-19:1.213.2.3
	binutils-csl-sourcerygxx-4_1-18:1.213.2.3
	binutils-csl-renesas-4_1-9:1.213.2.3
	binutils-csl-sourcerygxx-3_4_4-25:1.173.2.1.4.1
	binutils-csl-renesas-4_1-8:1.213.2.1
	binutils-csl-renesas-4_1-7:1.213.2.1
	binutils-csl-renesas-4_1-6:1.213.2.1
	binutils-csl-sourcerygxx-4_1-17:1.213.2.1
	binutils-csl-sourcerygxx-4_1-14:1.213.2.1
	binutils-csl-sourcerygxx-4_1-15:1.213.2.1
	binutils-csl-sourcerygxx-4_1-13:1.213.2.1
	binutils-2_17:1.216.2.1
	binutils-csl-sourcerygxx-4_1-12:1.213.2.1
	binutils-csl-sourcerygxx-3_4_4-21:1.213.2.1
	binutils-csl-wrs-linux-3_4_4-24:1.173.2.1.2.1
	binutils-csl-wrs-linux-3_4_4-23:1.173.2.1.2.1
	binutils-csl-sourcerygxx-4_1-9:1.213
	binutils-csl-sourcerygxx-4_1-8:1.213
	binutils-csl-sourcerygxx-4_1-7:1.213
	binutils-csl-arm-2006q1-6:1.213
	binutils-csl-sourcerygxx-4_1-6:1.213
	binutils-csl-wrs-linux-3_4_4-22:1.173.2.1.2.1
	binutils-csl-coldfire-4_1-11:1.213
	binutils-csl-sourcerygxx-3_4_4-19:1.213
	binutils-csl-coldfire-4_1-10:1.213
	binutils-csl-sourcerygxx-4_1-5:1.213
	binutils-csl-sourcerygxx-4_1-4:1.213
	binutils-csl-wrs-linux-3_4_4-21:1.173.2.1.2.1
	binutils-csl-morpho-4_1-4:1.213
	binutils-csl-sourcerygxx-3_4_4-17:1.213
	binutils-csl-wrs-linux-3_4_4-20:1.173.2.1.2.1
	binutils-2_17-branch:1.216.0.2
	binutils-2_17-branchpoint:1.216
	binutils-csl-2_17-branch:1.213.0.2
	binutils-csl-2_17-branchpoint:1.213
	binutils-csl-gxxpro-3_4-branch:1.173.2.1.0.4
	binutils-csl-gxxpro-3_4-branchpoint:1.173.2.1
	binutils-2_16_1:1.173.2.1
	binutils-csl-arm-2005q1b:1.173.2.1
	binutils-2_16:1.173.2.1
	binutils-csl-arm-2005q1a:1.173.2.1
	binutils-csl-arm-2005q1-branch:1.173.2.1.0.2
	binutils-csl-arm-2005q1-branchpoint:1.173.2.1
	binutils-2_16-branch:1.173.0.2
	binutils-2_16-branchpoint:1.173
	csl-arm-2004-q3d:1.168
	csl-arm-2004-q3:1.162
	binutils-2_15:1.136.2.5
	binutils-2_15-branchpoint:1.136
	csl-arm-2004-q1a:1.143
	csl-arm-2004-q1:1.141
	binutils-2_15-branch:1.136.0.2
	cagney_bfdfile-20040213-branch:1.135.0.4
	cagney_bfdfile-20040213-branchpoint:1.135
	cagney_bigcore-20040122-branch:1.135.0.2
	cagney_bigcore-20040122-branchpoint:1.135
	csl-arm-2003-q4:1.131
	binutils-2_14:1.111.2.1
	binutils-2_14-branch:1.111.0.2
	binutils-2_14-branchpoint:1.111
	binutils-2_13_2_1:1.93.2.6
	binutils-2_13_2:1.93.2.6
	binutils-2_13_1:1.93.2.6
	binutils-2_13:1.93.2.1
	binutils-2_13-branchpoint:1.93
	binutils-2_13-branch:1.93.0.2
	binutils-2_12_1:1.71.2.4
	binutils-2_12:1.71.2.2
	binutils-2_12-branch:1.71.0.2
	binutils-2_12-branchpoint:1.71
	cygnus_cvs_20020108_pre:1.69
	binutils-2_11_2:1.40.2.2
	binutils-2_11_1:1.40.2.2
	binutils-2_11:1.40
	x86_64versiong3:1.41
	binutils-2_11-branch:1.40.0.2
	binutils-2_10_1:1.24.2.1
	binutils-2_10:1.24
	binutils-2_10-branch:1.24.0.2
	binutils-2_10-branchpoint:1.24
	binutils_latest_snapshot:1.407
	repo-unification-2000-02-06:1.21
	binu_ss_19990721:1.9
	binu_ss_19990602:1.2
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.407
date	2013.07.19.10.39.51;	author nickc;	state Exp;
branches;
next	1.406;

1.406
date	2013.04.04.14.38.47;	author amodra;	state Exp;
branches;
next	1.405;

1.405
date	2013.03.05.02.55.24;	author amodra;	state Exp;
branches;
next	1.404;

1.404
date	2013.02.11.02.07.20;	author amodra;	state Exp;
branches;
next	1.403;

1.403
date	2012.12.17.00.16.49;	author amodra;	state Exp;
branches;
next	1.402;

1.402
date	2012.11.21.19.56.37;	author roland;	state Exp;
branches;
next	1.401;

1.401
date	2012.11.01.04.15.07;	author amodra;	state Exp;
branches;
next	1.400;

1.400
date	2012.08.06.22.27.52;	author macro;	state Exp;
branches;
next	1.399;

1.399
date	2012.08.01.01.07.38;	author hjl;	state Exp;
branches;
next	1.398;

1.398
date	2012.08.01.01.03.47;	author hjl;	state Exp;
branches;
next	1.397;

1.397
date	2012.07.13.13.20.26;	author nickc;	state Exp;
branches
	1.397.2.1;
next	1.396;

1.396
date	2012.07.10.06.50.55;	author hjl;	state Exp;
branches;
next	1.395;

1.395
date	2012.06.28.12.53.29;	author hjl;	state Exp;
branches;
next	1.394;

1.394
date	2012.06.25.01.49.08;	author amodra;	state Exp;
branches;
next	1.393;

1.393
date	2012.06.21.03.32.59;	author amodra;	state Exp;
branches;
next	1.392;

1.392
date	2012.06.15.15.13.32;	author amodra;	state Exp;
branches;
next	1.391;

1.391
date	2012.05.30.04.19.11;	author amodra;	state Exp;
branches;
next	1.390;

1.390
date	2012.05.14.19.45.28;	author jwlemke;	state Exp;
branches;
next	1.389;

1.389
date	2012.04.24.05.12.40;	author amodra;	state Exp;
branches;
next	1.388;

1.388
date	2012.03.25.06.45.15;	author amodra;	state Exp;
branches;
next	1.387;

1.387
date	2012.03.23.09.35.34;	author amodra;	state Exp;
branches;
next	1.386;

1.386
date	2012.03.08.05.29.32;	author amodra;	state Exp;
branches;
next	1.385;

1.385
date	2012.03.05.22.43.40;	author amodra;	state Exp;
branches;
next	1.384;

1.384
date	2012.02.22.16.27.32;	author nickc;	state Exp;
branches;
next	1.383;

1.383
date	2012.02.17.14.09.57;	author amodra;	state Exp;
branches;
next	1.382;

1.382
date	2012.01.31.17.54.36;	author hjl;	state Exp;
branches;
next	1.381;

1.381
date	2012.01.15.01.57.15;	author amodra;	state Exp;
branches;
next	1.380;

1.380
date	2011.11.15.18.22.27;	author schwab;	state Exp;
branches;
next	1.379;

1.379
date	2011.10.20.09.50.59;	author amodra;	state Exp;
branches;
next	1.378;

1.378
date	2011.09.20.04.58.56;	author amodra;	state Exp;
branches
	1.378.2.1;
next	1.377;

1.377
date	2011.09.16.01.15.19;	author hjl;	state Exp;
branches;
next	1.376;

1.376
date	2011.08.17.00.39.40;	author amodra;	state Exp;
branches;
next	1.375;

1.375
date	2011.07.16.07.58.40;	author roland;	state Exp;
branches;
next	1.374;

1.374
date	2011.07.11.15.03.09;	author clm;	state Exp;
branches;
next	1.373;

1.373
date	2011.07.09.06.20.52;	author amodra;	state Exp;
branches;
next	1.372;

1.372
date	2011.06.13.00.59.42;	author amodra;	state Exp;
branches;
next	1.371;

1.371
date	2011.06.07.23.58.30;	author amodra;	state Exp;
branches;
next	1.370;

1.370
date	2011.05.23.05.41.01;	author amodra;	state Exp;
branches;
next	1.369;

1.369
date	2011.05.16.11.34.48;	author nathan;	state Exp;
branches;
next	1.368;

1.368
date	2011.05.16.00.22.39;	author amodra;	state Exp;
branches;
next	1.367;

1.367
date	2011.05.03.14.56.14;	author amodra;	state Exp;
branches;
next	1.366;

1.366
date	2011.04.17.23.15.13;	author amodra;	state Exp;
branches;
next	1.365;

1.365
date	2011.04.15.03.47.30;	author amodra;	state Exp;
branches;
next	1.364;

1.364
date	2011.03.10.10.26.26;	author davek;	state Exp;
branches;
next	1.363;

1.363
date	2011.03.10.10.25.02;	author davek;	state Exp;
branches;
next	1.362;

1.362
date	2011.02.28.18.34.52;	author ktietz;	state Exp;
branches;
next	1.361;

1.361
date	2011.02.14.17.03.43;	author vapier;	state Exp;
branches;
next	1.360;

1.360
date	2011.01.14.02.18.22;	author amodra;	state Exp;
branches;
next	1.359;

1.359
date	2011.01.13.13.29.55;	author amodra;	state Exp;
branches;
next	1.358;

1.358
date	2011.01.13.13.06.22;	author amodra;	state Exp;
branches;
next	1.357;

1.357
date	2011.01.12.12.07.19;	author amodra;	state Exp;
branches;
next	1.356;

1.356
date	2011.01.10.13.13.32;	author hjl;	state Exp;
branches;
next	1.355;

1.355
date	2010.12.20.13.00.13;	author amodra;	state Exp;
branches;
next	1.354;

1.354
date	2010.12.20.06.27.10;	author amodra;	state Exp;
branches;
next	1.353;

1.353
date	2010.12.15.14.56.37;	author hjl;	state Exp;
branches;
next	1.352;

1.352
date	2010.12.13.01.06.35;	author amodra;	state Exp;
branches;
next	1.351;

1.351
date	2010.12.12.14.52.27;	author hjl;	state Exp;
branches;
next	1.350;

1.350
date	2010.12.06.00.07.05;	author hjl;	state Exp;
branches;
next	1.349;

1.349
date	2010.12.04.03.30.45;	author amodra;	state Exp;
branches;
next	1.348;

1.348
date	2010.11.21.20.36.24;	author hjl;	state Exp;
branches;
next	1.347;

1.347
date	2010.11.05.05.56.53;	author amodra;	state Exp;
branches
	1.347.2.1;
next	1.346;

1.346
date	2010.11.03.17.18.19;	author nickc;	state Exp;
branches;
next	1.345;

1.345
date	2010.10.28.06.45.32;	author amodra;	state Exp;
branches;
next	1.344;

1.344
date	2010.10.14.01.31.31;	author davek;	state Exp;
branches;
next	1.343;

1.343
date	2010.09.29.06.17.12;	author amodra;	state Exp;
branches;
next	1.342;

1.342
date	2010.09.23.11.40.06;	author amodra;	state Exp;
branches;
next	1.341;

1.341
date	2010.09.22.14.20.24;	author ktietz;	state Exp;
branches;
next	1.340;

1.340
date	2010.09.16.00.06.12;	author amodra;	state Exp;
branches;
next	1.339;

1.339
date	2010.09.10.01.23.12;	author amodra;	state Exp;
branches;
next	1.338;

1.338
date	2010.08.19.05.51.49;	author amodra;	state Exp;
branches;
next	1.337;

1.337
date	2010.08.06.01.51.17;	author amodra;	state Exp;
branches;
next	1.336;

1.336
date	2010.07.17.03.12.02;	author amodra;	state Exp;
branches;
next	1.335;

1.335
date	2010.04.09.14.40.12;	author nickc;	state Exp;
branches;
next	1.334;

1.334
date	2010.03.17.08.37.10;	author amodra;	state Exp;
branches;
next	1.333;

1.333
date	2010.03.16.14.14.39;	author drow;	state Exp;
branches;
next	1.332;

1.332
date	2010.02.25.03.49.15;	author amodra;	state Exp;
branches;
next	1.331;

1.331
date	2010.02.23.14.27.16;	author amodra;	state Exp;
branches;
next	1.330;

1.330
date	2010.02.22.12.09.59;	author amodra;	state Exp;
branches;
next	1.329;

1.329
date	2010.02.19.01.47.13;	author amodra;	state Exp;
branches;
next	1.328;

1.328
date	2010.01.21.10.31.32;	author nickc;	state Exp;
branches;
next	1.327;

1.327
date	2009.12.11.13.42.14;	author nickc;	state Exp;
branches;
next	1.326;

1.326
date	2009.11.26.13.45.25;	author nickc;	state Exp;
branches;
next	1.325;

1.325
date	2009.11.05.15.35.50;	author nickc;	state Exp;
branches;
next	1.324;

1.324
date	2009.10.14.01.48.53;	author amodra;	state Exp;
branches;
next	1.323;

1.323
date	2009.10.09.05.19.37;	author amodra;	state Exp;
branches;
next	1.322;

1.322
date	2009.10.08.01.00.27;	author amodra;	state Exp;
branches;
next	1.321;

1.321
date	2009.10.07.07.25.35;	author nathan;	state Exp;
branches;
next	1.320;

1.320
date	2009.09.29.02.24.56;	author amodra;	state Exp;
branches;
next	1.319;

1.319
date	2009.09.27.16.08.34;	author cgf;	state Exp;
branches;
next	1.318;

1.318
date	2009.09.11.15.27.35;	author nickc;	state Exp;
branches;
next	1.317;

1.317
date	2009.08.30.05.47.43;	author amodra;	state Exp;
branches
	1.317.2.1;
next	1.316;

1.316
date	2009.08.29.22.11.01;	author nickc;	state Exp;
branches;
next	1.315;

1.315
date	2009.08.12.12.40.55;	author gingold;	state Exp;
branches;
next	1.314;

1.314
date	2009.08.10.07.50.56;	author amodra;	state Exp;
branches;
next	1.313;

1.313
date	2009.07.23.00.08.22;	author hjl;	state Exp;
branches;
next	1.312;

1.312
date	2009.07.11.00.10.29;	author amodra;	state Exp;
branches;
next	1.311;

1.311
date	2009.06.25.13.18.46;	author gingold;	state Exp;
branches;
next	1.310;

1.310
date	2009.05.26.01.20.39;	author amodra;	state Exp;
branches;
next	1.309;

1.309
date	2009.05.22.11.27.43;	author nathan;	state Exp;
branches;
next	1.308;

1.308
date	2009.05.15.14.22.35;	author amodra;	state Exp;
branches;
next	1.307;

1.307
date	2009.05.14.02.21.45;	author amodra;	state Exp;
branches;
next	1.306;

1.306
date	2009.04.16.23.07.00;	author rsandifo;	state Exp;
branches;
next	1.305;

1.305
date	2009.04.15.03.22.42;	author kazu;	state Exp;
branches;
next	1.304;

1.304
date	2009.04.03.07.45.27;	author nathan;	state Exp;
branches;
next	1.303;

1.303
date	2009.03.20.17.39.03;	author hjl;	state Exp;
branches;
next	1.302;

1.302
date	2009.03.02.17.27.35;	author nickc;	state Exp;
branches;
next	1.301;

1.301
date	2009.02.16.08.02.29;	author amodra;	state Exp;
branches;
next	1.300;

1.300
date	2009.02.16.07.25.52;	author amodra;	state Exp;
branches;
next	1.299;

1.299
date	2009.02.09.14.46.40;	author nathan;	state Exp;
branches;
next	1.298;

1.298
date	2008.11.26.01.04.17;	author amodra;	state Exp;
branches;
next	1.297;

1.297
date	2008.11.24.07.54.34;	author amodra;	state Exp;
branches;
next	1.296;

1.296
date	2008.10.25.09.54.01;	author nickc;	state Exp;
branches;
next	1.295;

1.295
date	2008.10.21.22.55.04;	author amodra;	state Exp;
branches;
next	1.294;

1.294
date	2008.10.04.06.08.59;	author amodra;	state Exp;
branches;
next	1.293;

1.293
date	2008.10.03.09.40.49;	author amodra;	state Exp;
branches;
next	1.292;

1.292
date	2008.09.07.04.02.30;	author amodra;	state Exp;
branches
	1.292.2.1;
next	1.291;

1.291
date	2008.08.21.13.10.54;	author jkratoch;	state Exp;
branches;
next	1.290;

1.290
date	2008.08.17.03.12.50;	author amodra;	state Exp;
branches;
next	1.289;

1.289
date	2008.06.12.11.27.38;	author nickc;	state Exp;
branches;
next	1.288;

1.288
date	2008.06.07.11.35.46;	author amodra;	state Exp;
branches;
next	1.287;

1.287
date	2008.06.06.06.02.00;	author amodra;	state Exp;
branches;
next	1.286;

1.286
date	2008.05.31.16.35.56;	author nickc;	state Exp;
branches;
next	1.285;

1.285
date	2008.05.15.17.00.14;	author nickc;	state Exp;
branches;
next	1.284;

1.284
date	2008.04.28.12.45.33;	author nathan;	state Exp;
branches;
next	1.283;

1.283
date	2008.02.22.14.19.43;	author nickc;	state Exp;
branches;
next	1.282;

1.282
date	2008.02.15.03.35.53;	author amodra;	state Exp;
branches;
next	1.281;

1.281
date	2008.02.07.08.41.10;	author amodra;	state Exp;
branches;
next	1.280;

1.280
date	2008.01.25.17.34.29;	author hjl;	state Exp;
branches;
next	1.279;

1.279
date	2008.01.25.12.03.37;	author amodra;	state Exp;
branches;
next	1.278;

1.278
date	2008.01.16.01.28.21;	author amodra;	state Exp;
branches;
next	1.277;

1.277
date	2008.01.16.00.31.18;	author amodra;	state Exp;
branches;
next	1.276;

1.276
date	2008.01.15.07.25.49;	author amodra;	state Exp;
branches;
next	1.275;

1.275
date	2008.01.11.09.11.17;	author gingold;	state Exp;
branches;
next	1.274;

1.274
date	2008.01.10.14.28.49;	author nickc;	state Exp;
branches;
next	1.273;

1.273
date	2007.10.17.19.26.10;	author drow;	state Exp;
branches;
next	1.272;

1.272
date	2007.09.18.00.25.06;	author hjl;	state Exp;
branches;
next	1.271;

1.271
date	2007.08.31.14.46.55;	author nickc;	state Exp;
branches;
next	1.270;

1.270
date	2007.08.31.00.39.53;	author amodra;	state Exp;
branches;
next	1.269;

1.269
date	2007.08.28.13.21.57;	author jsm28;	state Exp;
branches;
next	1.268;

1.268
date	2007.07.29.12.33.37;	author amodra;	state Exp;
branches;
next	1.267;

1.267
date	2007.07.13.07.34.25;	author amodra;	state Exp;
branches;
next	1.266;

1.266
date	2007.07.12.01.40.25;	author amodra;	state Exp;
branches;
next	1.265;

1.265
date	2007.07.06.14.09.41;	author nickc;	state Exp;
branches;
next	1.264;

1.264
date	2007.05.31.15.04.52;	author amodra;	state Exp;
branches;
next	1.263;

1.263
date	2007.05.02.01.22.40;	author amodra;	state Exp;
branches;
next	1.262;

1.262
date	2007.05.01.13.35.34;	author amodra;	state Exp;
branches;
next	1.261;

1.261
date	2007.04.28.06.04.28;	author amodra;	state Exp;
branches;
next	1.260;

1.260
date	2007.04.26.14.46.59;	author amodra;	state Exp;
branches;
next	1.259;

1.259
date	2007.04.19.10.45.59;	author amodra;	state Exp;
branches;
next	1.258;

1.258
date	2007.04.18.03.55.10;	author amodra;	state Exp;
branches;
next	1.257;

1.257
date	2007.04.10.18.00.26;	author rth;	state Exp;
branches;
next	1.256;

1.256
date	2007.03.29.17.16.05;	author rsandifo;	state Exp;
branches;
next	1.255;

1.255
date	2007.03.26.11.10.44;	author amodra;	state Exp;
branches;
next	1.254;

1.254
date	2007.03.24.06.49.02;	author amodra;	state Exp;
branches;
next	1.253;

1.253
date	2007.03.16.15.13.21;	author nickc;	state Exp;
branches;
next	1.252;

1.252
date	2007.03.08.04.38.45;	author amodra;	state Exp;
branches;
next	1.251;

1.251
date	2007.02.21.16.43.50;	author nickc;	state Exp;
branches;
next	1.250;

1.250
date	2007.02.06.16.03.52;	author hjl;	state Exp;
branches;
next	1.249;

1.249
date	2007.02.06.13.56.38;	author amodra;	state Exp;
branches;
next	1.248;

1.248
date	2007.01.16.14.56.31;	author hjl;	state Exp;
branches;
next	1.247;

1.247
date	2006.12.12.08.10.40;	author amodra;	state Exp;
branches;
next	1.246;

1.246
date	2006.10.30.23.25.51;	author hjl;	state Exp;
branches;
next	1.245;

1.245
date	2006.10.27.03.22.08;	author amodra;	state Exp;
branches;
next	1.244;

1.244
date	2006.10.25.06.49.21;	author amodra;	state Exp;
branches;
next	1.243;

1.243
date	2006.10.19.02.10.41;	author amodra;	state Exp;
branches;
next	1.242;

1.242
date	2006.10.17.13.41.48;	author amodra;	state Exp;
branches;
next	1.241;

1.241
date	2006.10.11.14.58.19;	author jakub;	state Exp;
branches;
next	1.240;

1.240
date	2006.09.27.04.18.15;	author hjl;	state Exp;
branches;
next	1.239;

1.239
date	2006.09.15.09.48.58;	author nickc;	state Exp;
branches;
next	1.238;

1.238
date	2006.09.07.17.16.34;	author hjl;	state Exp;
branches;
next	1.237;

1.237
date	2006.08.29.11.27.45;	author nathan;	state Exp;
branches;
next	1.236;

1.236
date	2006.08.24.14.59.24;	author nickc;	state Exp;
branches;
next	1.235;

1.235
date	2006.08.22.07.41.05;	author amodra;	state Exp;
branches;
next	1.234;

1.234
date	2006.08.16.08.31.45;	author amodra;	state Exp;
branches;
next	1.233;

1.233
date	2006.08.08.16.08.47;	author hjl;	state Exp;
branches;
next	1.232;

1.232
date	2006.08.08.15.07.15;	author hjl;	state Exp;
branches;
next	1.231;

1.231
date	2006.08.01.17.50.52;	author hjl;	state Exp;
branches;
next	1.230;

1.230
date	2006.07.26.05.05.52;	author amodra;	state Exp;
branches;
next	1.229;

1.229
date	2006.07.26.00.42.33;	author amodra;	state Exp;
branches;
next	1.228;

1.228
date	2006.07.25.14.45.17;	author amodra;	state Exp;
branches;
next	1.227;

1.227
date	2006.07.23.15.32.08;	author nickc;	state Exp;
branches;
next	1.226;

1.226
date	2006.06.21.13.25.54;	author shinwell;	state Exp;
branches;
next	1.225;

1.225
date	2006.06.20.16.37.29;	author amodra;	state Exp;
branches;
next	1.224;

1.224
date	2006.06.20.02.22.14;	author amodra;	state Exp;
branches;
next	1.223;

1.223
date	2006.06.09.01.13.39;	author amodra;	state Exp;
branches;
next	1.222;

1.222
date	2006.06.07.04.55.11;	author amodra;	state Exp;
branches;
next	1.221;

1.221
date	2006.06.06.02.24.33;	author amodra;	state Exp;
branches;
next	1.220;

1.220
date	2006.06.05.06.12.40;	author amodra;	state Exp;
branches;
next	1.219;

1.219
date	2006.05.19.06.09.31;	author amodra;	state Exp;
branches;
next	1.218;

1.218
date	2006.05.17.16.46.54;	author drow;	state Exp;
branches;
next	1.217;

1.217
date	2006.04.19.02.10.43;	author amodra;	state Exp;
branches;
next	1.216;

1.216
date	2006.04.07.07.03.51;	author kkojima;	state Exp;
branches
	1.216.2.1;
next	1.215;

1.215
date	2006.04.06.18.52.45;	author hjl;	state Exp;
branches;
next	1.214;

1.214
date	2006.04.04.08.52.21;	author ebotcazou;	state Exp;
branches;
next	1.213;

1.213
date	2006.03.16.12.20.16;	author amodra;	state Exp;
branches
	1.213.2.1;
next	1.212;

1.212
date	2005.12.24.07.48.30;	author amodra;	state Exp;
branches;
next	1.211;

1.211
date	2005.12.19.15.06.40;	author hjl;	state Exp;
branches;
next	1.210;

1.210
date	2005.11.24.06.02.08;	author amodra;	state Exp;
branches;
next	1.209;

1.209
date	2005.11.24.00.58.28;	author amodra;	state Exp;
branches;
next	1.208;

1.208
date	2005.11.18.04.12.27;	author amodra;	state Exp;
branches;
next	1.207;

1.207
date	2005.11.17.00.10.05;	author amodra;	state Exp;
branches;
next	1.206;

1.206
date	2005.11.16.08.32.54;	author amodra;	state Exp;
branches;
next	1.205;

1.205
date	2005.11.16.07.17.20;	author amodra;	state Exp;
branches;
next	1.204;

1.204
date	2005.11.04.13.26.53;	author amodra;	state Exp;
branches;
next	1.203;

1.203
date	2005.11.03.02.54.10;	author amodra;	state Exp;
branches;
next	1.202;

1.202
date	2005.10.24.01.40.58;	author hjl;	state Exp;
branches;
next	1.201;

1.201
date	2005.10.15.14.57.54;	author hjl;	state Exp;
branches;
next	1.200;

1.200
date	2005.10.13.17.29.57;	author mmitchel;	state Exp;
branches;
next	1.199;

1.199
date	2005.09.30.22.10.54;	author wilson;	state Exp;
branches;
next	1.198;

1.198
date	2005.09.30.17.45.45;	author hjl;	state Exp;
branches;
next	1.197;

1.197
date	2005.09.20.03.00.53;	author amodra;	state Exp;
branches;
next	1.196;

1.196
date	2005.09.19.23.17.47;	author amodra;	state Exp;
branches;
next	1.195;

1.195
date	2005.08.04.06.22.12;	author amodra;	state Exp;
branches;
next	1.194;

1.194
date	2005.08.03.05.09.48;	author amodra;	state Exp;
branches;
next	1.193;

1.193
date	2005.07.28.20.08.15;	author dj;	state Exp;
branches;
next	1.192;

1.192
date	2005.07.15.12.19.13;	author amodra;	state Exp;
branches;
next	1.191;

1.191
date	2005.07.14.13.54.23;	author amodra;	state Exp;
branches;
next	1.190;

1.190
date	2005.07.08.06.20.15;	author amodra;	state Exp;
branches;
next	1.189;

1.189
date	2005.06.09.02.05.46;	author amodra;	state Exp;
branches;
next	1.188;

1.188
date	2005.06.04.14.40.21;	author hjl;	state Exp;
branches;
next	1.187;

1.187
date	2005.06.02.03.08.41;	author amodra;	state Exp;
branches;
next	1.186;

1.186
date	2005.06.01.04.04.17;	author zack;	state Exp;
branches;
next	1.185;

1.185
date	2005.05.17.16.42.46;	author hjl;	state Exp;
branches;
next	1.184;

1.184
date	2005.05.17.14.39.08;	author nickc;	state Exp;
branches;
next	1.183;

1.183
date	2005.05.17.14.35.21;	author nickc;	state Exp;
branches;
next	1.182;

1.182
date	2005.05.12.07.32.02;	author nickc;	state Exp;
branches;
next	1.181;

1.181
date	2005.05.11.14.10.09;	author amodra;	state Exp;
branches;
next	1.180;

1.180
date	2005.05.04.11.00.26;	author amodra;	state Exp;
branches;
next	1.179;

1.179
date	2005.05.03.01.04.51;	author hjl;	state Exp;
branches;
next	1.178;

1.178
date	2005.04.28.23.54.32;	author bje;	state Exp;
branches;
next	1.177;

1.177
date	2005.04.06.15.33.02;	author jakub;	state Exp;
branches;
next	1.176;

1.176
date	2005.03.18.13.56.26;	author amodra;	state Exp;
branches;
next	1.175;

1.175
date	2005.03.17.16.20.19;	author bwilson;	state Exp;
branches;
next	1.174;

1.174
date	2005.03.16.21.52.42;	author hjl;	state Exp;
branches;
next	1.173;

1.173
date	2005.02.22.18.35.32;	author drow;	state Exp;
branches
	1.173.2.1;
next	1.172;

1.172
date	2005.02.22.00.50.07;	author hjl;	state Exp;
branches;
next	1.171;

1.171
date	2005.01.21.04.15.58;	author bje;	state Exp;
branches;
next	1.170;

1.170
date	2005.01.18.08.51.54;	author amodra;	state Exp;
branches;
next	1.169;

1.169
date	2004.12.17.15.50.02;	author jakub;	state Exp;
branches;
next	1.168;

1.168
date	2004.10.26.18.41.51;	author mmitchel;	state Exp;
branches;
next	1.167;

1.167
date	2004.10.19.15.44.58;	author hjl;	state Exp;
branches;
next	1.166;

1.166
date	2004.10.16.18.13.53;	author drow;	state Exp;
branches;
next	1.165;

1.165
date	2004.10.14.12.54.44;	author amodra;	state Exp;
branches;
next	1.164;

1.164
date	2004.10.04.16.45.51;	author hjl;	state Exp;
branches;
next	1.163;

1.163
date	2004.10.04.13.41.15;	author jakub;	state Exp;
branches;
next	1.162;

1.162
date	2004.08.25.23.40.56;	author amodra;	state Exp;
branches;
next	1.161;

1.161
date	2004.08.25.06.11.43;	author hjl;	state Exp;
branches;
next	1.160;

1.160
date	2004.07.23.16.32.53;	author nickc;	state Exp;
branches;
next	1.159;

1.159
date	2004.07.21.15.42.58;	author hjl;	state Exp;
branches;
next	1.158;

1.158
date	2004.07.21.15.05.46;	author nickc;	state Exp;
branches;
next	1.157;

1.157
date	2004.07.19.16.40.51;	author hjl;	state Exp;
branches;
next	1.156;

1.156
date	2004.06.29.14.13.47;	author amodra;	state Exp;
branches;
next	1.155;

1.155
date	2004.06.24.04.46.27;	author amodra;	state Exp;
branches;
next	1.154;

1.154
date	2004.06.14.12.46.43;	author amodra;	state Exp;
branches;
next	1.153;

1.153
date	2004.05.29.04.30.41;	author amodra;	state Exp;
branches;
next	1.152;

1.152
date	2004.05.28.10.34.17;	author amodra;	state Exp;
branches;
next	1.151;

1.151
date	2004.05.28.05.42.29;	author amodra;	state Exp;
branches;
next	1.150;

1.150
date	2004.05.27.05.53.36;	author hjl;	state Exp;
branches;
next	1.149;

1.149
date	2004.05.26.10.23.51;	author amodra;	state Exp;
branches;
next	1.148;

1.148
date	2004.05.25.06.33.50;	author amodra;	state Exp;
branches;
next	1.147;

1.147
date	2004.05.19.14.15.55;	author amylaar;	state Exp;
branches;
next	1.146;

1.146
date	2004.05.19.14.01.14;	author jakub;	state Exp;
branches;
next	1.145;

1.145
date	2004.05.11.17.08.34;	author jakub;	state Exp;
branches;
next	1.144;

1.144
date	2004.05.07.15.21.27;	author amylaar;	state Exp;
branches;
next	1.143;

1.143
date	2004.04.30.14.26.09;	author amodra;	state Exp;
branches;
next	1.142;

1.142
date	2004.04.19.07.35.12;	author jakub;	state Exp;
branches;
next	1.141;

1.141
date	2004.03.18.12.50.20;	author amodra;	state Exp;
branches;
next	1.140;

1.140
date	2004.03.05.11.26.04;	author nathan;	state Exp;
branches;
next	1.139;

1.139
date	2004.02.23.19.41.53;	author ian;	state Exp;
branches;
next	1.138;

1.138
date	2004.02.23.10.10.01;	author nathan;	state Exp;
branches;
next	1.137;

1.137
date	2004.02.19.14.08.31;	author nathan;	state Exp;
branches;
next	1.136;

1.136
date	2004.02.18.16.37.20;	author nathan;	state Exp;
branches
	1.136.2.1;
next	1.135;

1.135
date	2004.01.13.11.10.53;	author nickc;	state Exp;
branches;
next	1.134;

1.134
date	2004.01.13.08.24.20;	author nickc;	state Exp;
branches;
next	1.133;

1.133
date	2004.01.12.13.47.32;	author amodra;	state Exp;
branches;
next	1.132;

1.132
date	2004.01.03.12.39.07;	author amodra;	state Exp;
branches;
next	1.131;

1.131
date	2003.12.08.03.43.33;	author hjl;	state Exp;
branches;
next	1.130;

1.130
date	2003.12.04.22.43.33;	author hjl;	state Exp;
branches;
next	1.129;

1.129
date	2003.12.04.12.09.25;	author amodra;	state Exp;
branches;
next	1.128;

1.128
date	2003.11.19.02.40.55;	author wilson;	state Exp;
branches;
next	1.127;

1.127
date	2003.10.31.10.27.34;	author nickc;	state Exp;
branches;
next	1.126;

1.126
date	2003.10.25.16.26.30;	author kazu;	state Exp;
branches;
next	1.125;

1.125
date	2003.10.24.18.55.39;	author hjl;	state Exp;
branches;
next	1.124;

1.124
date	2003.10.24.15.40.20;	author hjl;	state Exp;
branches;
next	1.123;

1.123
date	2003.10.24.14.55.13;	author hjl;	state Exp;
branches;
next	1.122;

1.122
date	2003.10.22.06.58.17;	author jakub;	state Exp;
branches;
next	1.121;

1.121
date	2003.10.21.15.33.47;	author nickc;	state Exp;
branches;
next	1.120;

1.120
date	2003.10.17.23.05.50;	author hp;	state Exp;
branches;
next	1.119;

1.119
date	2003.10.11.09.16.20;	author hp;	state Exp;
branches;
next	1.118;

1.118
date	2003.10.08.22.17.35;	author aoliva;	state Exp;
branches;
next	1.117;

1.117
date	2003.07.27.11.58.28;	author amodra;	state Exp;
branches;
next	1.116;

1.116
date	2003.06.28.05.28.54;	author amodra;	state Exp;
branches;
next	1.115;

1.115
date	2003.06.25.06.40.26;	author amodra;	state Exp;
branches;
next	1.114;

1.114
date	2003.06.18.00.30.04;	author hjl;	state Exp;
branches;
next	1.113;

1.113
date	2003.05.09.16.12.07;	author nickc;	state Exp;
branches;
next	1.112;

1.112
date	2003.04.29.01.53.46;	author hjl;	state Exp;
branches;
next	1.111;

1.111
date	2003.03.31.18.12.52;	author nickc;	state Exp;
branches
	1.111.2.1;
next	1.110;

1.110
date	2003.03.03.20.00.35;	author aoliva;	state Exp;
branches;
next	1.109;

1.109
date	2003.02.21.10.51.24;	author nickc;	state Exp;
branches;
next	1.108;

1.108
date	2003.01.02.03.53.53;	author kazu;	state Exp;
branches;
next	1.107;

1.107
date	2002.12.23.10.45.00;	author nickc;	state Exp;
branches;
next	1.106;

1.106
date	2002.12.06.22.33.18;	author amodra;	state Exp;
branches;
next	1.105;

1.105
date	2002.11.30.08.39.45;	author amodra;	state Exp;
branches;
next	1.104;

1.104
date	2002.11.12.11.31.43;	author amodra;	state Exp;
branches;
next	1.103;

1.103
date	2002.10.30.03.57.38;	author drow;	state Exp;
branches;
next	1.102;

1.102
date	2002.10.15.00.09.02;	author amodra;	state Exp;
branches;
next	1.101;

1.101
date	2002.10.14.13.08.19;	author amodra;	state Exp;
branches;
next	1.100;

1.100
date	2002.10.10.15.59.10;	author jakub;	state Exp;
branches;
next	1.99;

1.99
date	2002.10.08.20.12.45;	author hjl;	state Exp;
branches;
next	1.98;

1.98
date	2002.10.07.16.08.21;	author nickc;	state Exp;
branches;
next	1.97;

1.97
date	2002.08.20.23.48.18;	author amodra;	state Exp;
branches;
next	1.96;

1.96
date	2002.08.13.02.08.25;	author amodra;	state Exp;
branches;
next	1.95;

1.95
date	2002.08.08.03.50.17;	author hjl;	state Exp;
branches;
next	1.94;

1.94
date	2002.07.30.14.28.55;	author jakub;	state Exp;
branches;
next	1.93;

1.93
date	2002.07.05.12.54.28;	author amodra;	state Exp;
branches
	1.93.2.1;
next	1.92;

1.92
date	2002.07.04.14.41.01;	author amodra;	state Exp;
branches;
next	1.91;

1.91
date	2002.07.01.08.07.29;	author amodra;	state Exp;
branches;
next	1.90;

1.90
date	2002.06.10.16.12.04;	author rsandifo;	state Exp;
branches;
next	1.89;

1.89
date	2002.06.04.01.07.29;	author amodra;	state Exp;
branches;
next	1.88;

1.88
date	2002.05.27.08.22.07;	author rsandifo;	state Exp;
branches;
next	1.87;

1.87
date	2002.05.25.13.10.11;	author amodra;	state Exp;
branches;
next	1.86;

1.86
date	2002.05.23.13.12.52;	author jakub;	state Exp;
branches;
next	1.85;

1.85
date	2002.05.22.09.01.56;	author amodra;	state Exp;
branches;
next	1.84;

1.84
date	2002.05.15.00.19.23;	author amodra;	state Exp;
branches;
next	1.83;

1.83
date	2002.05.07.11.04.53;	author rsandifo;	state Exp;
branches;
next	1.82;

1.82
date	2002.05.03.13.48.55;	author kazu;	state Exp;
branches;
next	1.81;

1.81
date	2002.04.30.09.21.27;	author rsandifo;	state Exp;
branches;
next	1.80;

1.80
date	2002.04.08.01.01.43;	author amodra;	state Exp;
branches;
next	1.79;

1.79
date	2002.03.20.07.49.53;	author amodra;	state Exp;
branches;
next	1.78;

1.78
date	2002.03.18.02.55.51;	author amodra;	state Exp;
branches;
next	1.77;

1.77
date	2002.03.14.10.39.46;	author amodra;	state Exp;
branches;
next	1.76;

1.76
date	2002.03.13.02.56.36;	author amodra;	state Exp;
branches;
next	1.75;

1.75
date	2002.02.15.02.11.05;	author amodra;	state Exp;
branches;
next	1.74;

1.74
date	2002.02.14.04.24.33;	author amodra;	state Exp;
branches;
next	1.73;

1.73
date	2002.02.12.14.50.06;	author jakub;	state Exp;
branches;
next	1.72;

1.72
date	2002.02.10.10.55.18;	author amodra;	state Exp;
branches;
next	1.71;

1.71
date	2002.02.05.06.52.15;	author hp;	state Exp;
branches
	1.71.2.1;
next	1.70;

1.70
date	2002.01.08.14.56.09;	author aoliva;	state Exp;
branches;
next	1.69;

1.69
date	2001.12.18.12.15.35;	author jakub;	state Exp;
branches;
next	1.68;

1.68
date	2001.11.21.01.13.15;	author amodra;	state Exp;
branches;
next	1.67;

1.67
date	2001.11.20.15.31.10;	author amodra;	state Exp;
branches;
next	1.66;

1.66
date	2001.10.31.01.12.26;	author amodra;	state Exp;
branches;
next	1.65;

1.65
date	2001.10.29.22.36.32;	author kazu;	state Exp;
branches;
next	1.64;

1.64
date	2001.09.29.12.57.54;	author amodra;	state Exp;
branches;
next	1.63;

1.63
date	2001.09.29.12.07.01;	author amodra;	state Exp;
branches;
next	1.62;

1.62
date	2001.09.19.05.33.33;	author hjl;	state Exp;
branches;
next	1.61;

1.61
date	2001.08.20.03.09.07;	author amodra;	state Exp;
branches;
next	1.60;

1.60
date	2001.08.20.02.14.49;	author amodra;	state Exp;
branches;
next	1.59;

1.59
date	2001.08.20.01.21.06;	author amodra;	state Exp;
branches;
next	1.58;

1.58
date	2001.08.18.14.54.26;	author amodra;	state Exp;
branches;
next	1.57;

1.57
date	2001.08.14.02.01.31;	author amodra;	state Exp;
branches;
next	1.56;

1.56
date	2001.08.03.01.11.21;	author amodra;	state Exp;
branches;
next	1.55;

1.55
date	2001.07.19.16.21.39;	author nickc;	state Exp;
branches;
next	1.54;

1.54
date	2001.06.19.19.57.39;	author hp;	state Exp;
branches;
next	1.53;

1.53
date	2001.06.19.14.39.02;	author hjl;	state Exp;
branches;
next	1.52;

1.52
date	2001.06.18.17.23.52;	author hjl;	state Exp;
branches;
next	1.51;

1.51
date	2001.06.15.13.13.46;	author hp;	state Exp;
branches;
next	1.50;

1.50
date	2001.06.15.09.00.11;	author nickc;	state Exp;
branches;
next	1.49;

1.49
date	2001.06.08.01.58.20;	author amodra;	state Exp;
branches;
next	1.48;

1.48
date	2001.05.31.21.14.59;	author hjl;	state Exp;
branches;
next	1.47;

1.47
date	2001.05.17.03.58.45;	author amodra;	state Exp;
branches;
next	1.46;

1.46
date	2001.05.11.12.23.48;	author jakub;	state Exp;
branches;
next	1.45;

1.45
date	2001.05.02.16.42.55;	author hjl;	state Exp;
branches;
next	1.44;

1.44
date	2001.04.28.18.00.10;	author nickc;	state Exp;
branches;
next	1.43;

1.43
date	2001.04.13.00.34.36;	author jakub;	state Exp;
branches;
next	1.42;

1.42
date	2001.03.13.06.14.27;	author nickc;	state Exp;
branches;
next	1.41;

1.41
date	2001.02.27.01.38.05;	author nickc;	state Exp;
branches;
next	1.40;

1.40
date	2001.01.25.02.31.42;	author amodra;	state Exp;
branches
	1.40.2.1;
next	1.39;

1.39
date	2001.01.23.11.48.28;	author amodra;	state Exp;
branches;
next	1.38;

1.38
date	2001.01.16.21.04.29;	author hjl;	state Exp;
branches;
next	1.37;

1.37
date	2001.01.14.04.36.34;	author amodra;	state Exp;
branches;
next	1.36;

1.36
date	2000.12.13.18.28.52;	author nickc;	state Exp;
branches;
next	1.35;

1.35
date	2000.11.30.19.30.32;	author nickc;	state Exp;
branches;
next	1.34;

1.34
date	2000.10.12.03.44.51;	author amodra;	state Exp;
branches;
next	1.33;

1.33
date	2000.10.09.15.09.17;	author kazu;	state Exp;
branches;
next	1.32;

1.32
date	2000.10.05.13.03.30;	author kazu;	state Exp;
branches;
next	1.31;

1.31
date	2000.09.29.11.18.18;	author kazu;	state Exp;
branches;
next	1.30;

1.30
date	2000.09.05.03.21.16;	author amodra;	state Exp;
branches;
next	1.29;

1.29
date	2000.08.25.20.44.09;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	2000.07.11.03.42.41;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2000.06.20.13.29.06;	author twall;	state Exp;
branches;
next	1.26;

1.26
date	2000.05.10.23.12.35;	author hjl;	state Exp;
branches;
next	1.25;

1.25
date	2000.04.25.05.14.16;	author amodra;	state Exp;
branches;
next	1.24;

1.24
date	2000.02.21.12.01.27;	author amodra;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2000.02.16.18.53.32;	author twall;	state Exp;
branches;
next	1.22;

1.22
date	2000.02.09.14.42.48;	author twall;	state Exp;
branches;
next	1.21;

1.21
date	2000.02.04.19.49.21;	author twall;	state Exp;
branches;
next	1.20;

1.20
date	2000.02.03.18.24.46;	author twall;	state Exp;
branches;
next	1.19;

1.19
date	2000.01.21.17.44.51;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2000.01.18.23.58.58;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2000.01.05.14.12.23;	author clm;	state Exp;
branches;
next	1.16;

1.16
date	99.11.24.11.43.11;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	99.11.23.14.13.07;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	99.11.01.23.37.48;	author ian;	state Exp;
branches;
next	1.13;

1.13
date	99.09.12.16.10.00;	author ian;	state Exp;
branches;
next	1.12;

1.12
date	99.09.12.14.50.15;	author ian;	state Exp;
branches;
next	1.11;

1.11
date	99.08.09.06.14.09;	author ian;	state Exp;
branches;
next	1.10;

1.10
date	99.08.09.03.22.27;	author ian;	state Exp;
branches;
next	1.9;

1.9
date	99.07.20.22.27.31;	author devans;	state Exp;
branches;
next	1.8;

1.8
date	99.07.19.14.57.03;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	99.07.14.16.45.13;	author rth;	state Exp;
branches;
next	1.6;

1.6
date	99.07.11.20.09.01;	author ian;	state Exp;
branches;
next	1.5;

1.5
date	99.07.02.07.45.31;	author ian;	state Exp;
branches;
next	1.4;

1.4
date	99.06.22.21.13.24;	author ian;	state Exp;
branches;
next	1.3;

1.3
date	99.06.12.21.24.55;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.05.08.23.40.58;	author rth;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.29.06;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.397.2.1
date	2012.08.02.13.59.25;	author hjl;	state Exp;
branches;
next	1.397.2.2;

1.397.2.2
date	2012.09.04.14.37.59;	author gingold;	state Exp;
branches;
next	1.397.2.3;

1.397.2.3
date	2012.11.29.22.56.29;	author roland;	state Exp;
branches;
next	1.397.2.4;

1.397.2.4
date	2013.01.21.13.48.48;	author amodra;	state Exp;
branches;
next	1.397.2.5;

1.397.2.5
date	2013.03.05.03.11.30;	author amodra;	state Exp;
branches;
next	;

1.378.2.1
date	2011.10.25.03.15.08;	author amodra;	state Exp;
branches;
next	1.378.2.2;

1.378.2.2
date	2012.05.11.12.24.39;	author nickc;	state Exp;
branches;
next	;

1.347.2.1
date	2010.12.15.15.43.27;	author gingold;	state Exp;
branches;
next	1.347.2.2;

1.347.2.2
date	2011.02.01.12.25.46;	author amodra;	state Exp;
branches;
next	1.347.2.3;

1.347.2.3
date	2011.04.27.07.17.42;	author amodra;	state Exp;
branches;
next	1.347.2.4;

1.347.2.4
date	2011.05.03.15.16.40;	author amodra;	state Exp;
branches;
next	1.347.2.5;

1.347.2.5
date	2011.05.16.00.53.46;	author amodra;	state Exp;
branches;
next	1.347.2.6;

1.347.2.6
date	2011.05.29.04.51.46;	author amodra;	state Exp;
branches;
next	;

1.317.2.1
date	2009.09.11.15.28.44;	author nickc;	state Exp;
branches;
next	1.317.2.2;

1.317.2.2
date	2009.09.29.03.18.21;	author amodra;	state Exp;
branches;
next	1.317.2.3;

1.317.2.3
date	2009.10.09.05.43.07;	author amodra;	state Exp;
branches;
next	1.317.2.4;

1.317.2.4
date	2009.10.14.09.28.21;	author gingold;	state Exp;
branches;
next	;

1.292.2.1
date	2009.03.02.13.32.54;	author amodra;	state Exp;
branches;
next	1.292.2.2;

1.292.2.2
date	2009.03.02.13.34.02;	author amodra;	state Exp;
branches;
next	1.292.2.3;

1.292.2.3
date	2009.03.02.13.56.19;	author amodra;	state Exp;
branches;
next	;

1.216.2.1
date	2006.06.09.01.14.53;	author amodra;	state Exp;
branches;
next	1.216.2.2;

1.216.2.2
date	2006.07.04.13.29.24;	author drow;	state Exp;
branches;
next	;

1.213.2.1
date	2006.06.21.14.40.24;	author shinwell;	state Exp;
branches;
next	1.213.2.2;

1.213.2.2
date	2006.08.22.15.08.43;	author jsm28;	state Exp;
branches;
next	1.213.2.3;

1.213.2.3
date	2006.08.29.11.09.04;	author nathan;	state Exp;
branches;
next	;

1.173.2.1
date	2005.03.17.16.37.33;	author bwilson;	state Exp;
branches
	1.173.2.1.2.1
	1.173.2.1.4.1;
next	;

1.173.2.1.2.1
date	2005.05.18.13.57.35;	author jules;	state Exp;
branches;
next	;

1.173.2.1.4.1
date	2005.10.13.22.14.22;	author mmitchel;	state Exp;
branches;
next	;

1.136.2.1
date	2004.02.19.16.22.18;	author nathan;	state Exp;
branches;
next	1.136.2.2;

1.136.2.2
date	2004.02.23.10.11.47;	author nathan;	state Exp;
branches;
next	1.136.2.3;

1.136.2.3
date	2004.03.05.11.42.01;	author nathan;	state Exp;
branches;
next	1.136.2.4;

1.136.2.4
date	2004.04.08.12.41.53;	author amodra;	state Exp;
branches;
next	1.136.2.5;

1.136.2.5
date	2004.04.09.18.28.15;	author drow;	state Exp;
branches;
next	;

1.111.2.1
date	2003.05.03.16.02.32;	author drow;	state Exp;
branches;
next	;

1.93.2.1
date	2002.07.30.18.21.03;	author drow;	state Exp;
branches;
next	1.93.2.2;

1.93.2.2
date	2002.08.13.02.20.35;	author amodra;	state Exp;
branches;
next	1.93.2.3;

1.93.2.3
date	2002.09.23.22.15.57;	author drow;	state Exp;
branches;
next	1.93.2.4;

1.93.2.4
date	2002.10.15.00.11.25;	author amodra;	state Exp;
branches;
next	1.93.2.5;

1.93.2.5
date	2002.10.28.18.45.52;	author drow;	state Exp;
branches;
next	1.93.2.6;

1.93.2.6
date	2002.10.30.03.54.52;	author drow;	state Exp;
branches;
next	;

1.71.2.1
date	2002.02.10.23.05.33;	author amodra;	state Exp;
branches;
next	1.71.2.2;

1.71.2.2
date	2002.02.14.04.25.55;	author amodra;	state Exp;
branches;
next	1.71.2.3;

1.71.2.3
date	2002.03.28.06.26.57;	author amodra;	state Exp;
branches;
next	1.71.2.4;

1.71.2.4
date	2002.04.27.12.51.26;	author amodra;	state Exp;
branches;
next	1.71.2.5;

1.71.2.5
date	2002.07.07.09.40.08;	author amodra;	state Exp;
branches;
next	;

1.40.2.1
date	2001.05.23.03.41.11;	author amodra;	state Exp;
branches;
next	1.40.2.2;

1.40.2.2
date	2001.06.08.02.01.12;	author amodra;	state Exp;
branches;
next	1.40.2.3;

1.40.2.3
date	2001.07.19.16.23.29;	author nickc;	state Exp;
branches;
next	;

1.24.2.1
date	2000.11.06.09.37.30;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.29.06;	author rth;	state Exp;
branches;
next	;


desc
@@


1.407
log
@	* ldgram.y: Add ALIGN_WITH_INPUT output section attribute.
	* ldlang.c: Likewise.
	* ldlang.h: Likewise.
	* ldlex.l: Likewise.
	* mri.c: Likewise.
	* ld.texinfo: Document new feature.
	* NEWS: Mention new feature.

	* ld-scripts/script.exp: Run align with input test.
	* ld-scripts/align-with-input.t: New file.
	* ld-scripts/rgn-at8.d: Likewise.
	* ld-scripts/rgn-at8.t: Likewise.
@
text
@/* Linker command language support.
   Copyright 1991-2013 Free Software Foundation, Inc.

   This file is part of the GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "libiberty.h"
#include "filenames.h"
#include "safe-ctype.h"
#include "obstack.h"
#include "bfdlink.h"

#include "ld.h"
#include "ldmain.h"
#include "ldexp.h"
#include "ldlang.h"
#include <ldgram.h>
#include "ldlex.h"
#include "ldmisc.h"
#include "ldctor.h"
#include "ldfile.h"
#include "ldemul.h"
#include "fnmatch.h"
#include "demangle.h"
#include "hashtab.h"
#include "libbfd.h"
#ifdef ENABLE_PLUGINS
#include "plugin.h"
#endif /* ENABLE_PLUGINS */

#ifndef offsetof
#define offsetof(TYPE, MEMBER) ((size_t) & (((TYPE*) 0)->MEMBER))
#endif

/* Locals variables.  */
static struct obstack stat_obstack;
static struct obstack map_obstack;

#define obstack_chunk_alloc xmalloc
#define obstack_chunk_free free
static const char *entry_symbol_default = "start";
static bfd_boolean placed_commons = FALSE;
static bfd_boolean stripped_excluded_sections = FALSE;
static lang_output_section_statement_type *default_common_section;
static bfd_boolean map_option_f;
static bfd_vma print_dot;
static lang_input_statement_type *first_file;
static const char *current_target;
static lang_statement_list_type statement_list;
static struct bfd_hash_table lang_definedness_table;
static lang_statement_list_type *stat_save[10];
static lang_statement_list_type **stat_save_ptr = &stat_save[0];
static struct unique_sections *unique_section_list;

/* Forward declarations.  */
static void exp_init_os (etree_type *);
static void init_map_userdata (bfd *, asection *, void *);
static lang_input_statement_type *lookup_name (const char *);
static struct bfd_hash_entry *lang_definedness_newfunc
 (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);
static void insert_undefined (const char *);
static bfd_boolean sort_def_symbol (struct bfd_link_hash_entry *, void *);
static void print_statement (lang_statement_union_type *,
			     lang_output_section_statement_type *);
static void print_statement_list (lang_statement_union_type *,
				  lang_output_section_statement_type *);
static void print_statements (void);
static void print_input_section (asection *, bfd_boolean);
static bfd_boolean lang_one_common (struct bfd_link_hash_entry *, void *);
static void lang_record_phdrs (void);
static void lang_do_version_exports_section (void);
static void lang_finalize_version_expr_head
  (struct bfd_elf_version_expr_head *);

/* Exported variables.  */
const char *output_target;
lang_output_section_statement_type *abs_output_section;
lang_statement_list_type lang_output_section_statement;
lang_statement_list_type *stat_ptr = &statement_list;
lang_statement_list_type file_chain = { NULL, NULL };
lang_statement_list_type input_file_chain;
struct bfd_sym_chain entry_symbol = { NULL, NULL };
const char *entry_section = ".text";
struct lang_input_statement_flags input_flags;
bfd_boolean entry_from_cmdline;
bfd_boolean undef_from_cmdline;
bfd_boolean lang_has_input_file = FALSE;
bfd_boolean had_output_filename = FALSE;
bfd_boolean lang_float_flag = FALSE;
bfd_boolean delete_output_file_on_failure = FALSE;
struct lang_phdr *lang_phdr_list;
struct lang_nocrossrefs *nocrossref_list;

 /* Functions that traverse the linker script and might evaluate
    DEFINED() need to increment this.  */
int lang_statement_iteration = 0;

etree_type *base; /* Relocation base - or null */

/* Return TRUE if the PATTERN argument is a wildcard pattern.
   Although backslashes are treated specially if a pattern contains
   wildcards, we do not consider the mere presence of a backslash to
   be enough to cause the pattern to be treated as a wildcard.
   That lets us handle DOS filenames more naturally.  */
#define wildcardp(pattern) (strpbrk ((pattern), "?*[") != NULL)

#define new_stat(x, y) \
  (x##_type *) new_statement (x##_enum, sizeof (x##_type), y)

#define outside_section_address(q) \
  ((q)->output_offset + (q)->output_section->vma)

#define outside_symbol_address(q) \
  ((q)->value + outside_section_address (q->section))

#define SECTION_NAME_MAP_LENGTH (16)

void *
stat_alloc (size_t size)
{
  return obstack_alloc (&stat_obstack, size);
}

static int
name_match (const char *pattern, const char *name)
{
  if (wildcardp (pattern))
    return fnmatch (pattern, name, 0);
  return strcmp (pattern, name);
}

/* If PATTERN is of the form archive:file, return a pointer to the
   separator.  If not, return NULL.  */

static char *
archive_path (const char *pattern)
{
  char *p = NULL;

  if (link_info.path_separator == 0)
    return p;

  p = strchr (pattern, link_info.path_separator);
#ifdef HAVE_DOS_BASED_FILE_SYSTEM
  if (p == NULL || link_info.path_separator != ':')
    return p;

  /* Assume a match on the second char is part of drive specifier,
     as in "c:\silly.dos".  */
  if (p == pattern + 1 && ISALPHA (*pattern))
    p = strchr (p + 1, link_info.path_separator);
#endif
  return p;
}

/* Given that FILE_SPEC results in a non-NULL SEP result from archive_path,
   return whether F matches FILE_SPEC.  */

static bfd_boolean
input_statement_is_archive_path (const char *file_spec, char *sep,
				 lang_input_statement_type *f)
{
  bfd_boolean match = FALSE;

  if ((*(sep + 1) == 0
       || name_match (sep + 1, f->filename) == 0)
      && ((sep != file_spec)
	  == (f->the_bfd != NULL && f->the_bfd->my_archive != NULL)))
    {
      match = TRUE;

      if (sep != file_spec)
	{
	  const char *aname = f->the_bfd->my_archive->filename;
	  *sep = 0;
	  match = name_match (file_spec, aname) == 0;
	  *sep = link_info.path_separator;
	}
    }
  return match;
}

static bfd_boolean
unique_section_p (const asection *sec,
		  const lang_output_section_statement_type *os)
{
  struct unique_sections *unam;
  const char *secnam;

  if (link_info.relocatable
      && sec->owner != NULL
      && bfd_is_group_section (sec->owner, sec))
    return !(os != NULL
	     && strcmp (os->name, DISCARD_SECTION_NAME) == 0);

  secnam = sec->name;
  for (unam = unique_section_list; unam; unam = unam->next)
    if (name_match (unam->name, secnam) == 0)
      return TRUE;

  return FALSE;
}

/* Generic traversal routines for finding matching sections.  */

/* Try processing a section against a wildcard.  This just calls
   the callback unless the filename exclusion list is present
   and excludes the file.  It's hardly ever present so this
   function is very fast.  */

static void
walk_wild_consider_section (lang_wild_statement_type *ptr,
			    lang_input_statement_type *file,
			    asection *s,
			    struct wildcard_list *sec,
			    callback_t callback,
			    void *data)
{
  struct name_list *list_tmp;

  /* Don't process sections from files which were excluded.  */
  for (list_tmp = sec->spec.exclude_name_list;
       list_tmp;
       list_tmp = list_tmp->next)
    {
      char *p = archive_path (list_tmp->name);

      if (p != NULL)
	{
	  if (input_statement_is_archive_path (list_tmp->name, p, file))
	    return;
	}

      else if (name_match (list_tmp->name, file->filename) == 0)
	return;

      /* FIXME: Perhaps remove the following at some stage?  Matching
	 unadorned archives like this was never documented and has
	 been superceded by the archive:path syntax.  */
      else if (file->the_bfd != NULL
	       && file->the_bfd->my_archive != NULL
	       && name_match (list_tmp->name,
			      file->the_bfd->my_archive->filename) == 0)
	return;
    }

  (*callback) (ptr, sec, s, ptr->section_flag_list, file, data);
}

/* Lowest common denominator routine that can handle everything correctly,
   but slowly.  */

static void
walk_wild_section_general (lang_wild_statement_type *ptr,
			   lang_input_statement_type *file,
			   callback_t callback,
			   void *data)
{
  asection *s;
  struct wildcard_list *sec;

  for (s = file->the_bfd->sections; s != NULL; s = s->next)
    {
      sec = ptr->section_list;
      if (sec == NULL)
	(*callback) (ptr, sec, s, ptr->section_flag_list, file, data);

      while (sec != NULL)
	{
	  bfd_boolean skip = FALSE;

	  if (sec->spec.name != NULL)
	    {
	      const char *sname = bfd_get_section_name (file->the_bfd, s);

	      skip = name_match (sec->spec.name, sname) != 0;
	    }

	  if (!skip)
	    walk_wild_consider_section (ptr, file, s, sec, callback, data);

	  sec = sec->next;
	}
    }
}

/* Routines to find a single section given its name.  If there's more
   than one section with that name, we report that.  */

typedef struct
{
  asection *found_section;
  bfd_boolean multiple_sections_found;
} section_iterator_callback_data;

static bfd_boolean
section_iterator_callback (bfd *abfd ATTRIBUTE_UNUSED, asection *s, void *data)
{
  section_iterator_callback_data *d = (section_iterator_callback_data *) data;

  if (d->found_section != NULL)
    {
      d->multiple_sections_found = TRUE;
      return TRUE;
    }

  d->found_section = s;
  return FALSE;
}

static asection *
find_section (lang_input_statement_type *file,
	      struct wildcard_list *sec,
	      bfd_boolean *multiple_sections_found)
{
  section_iterator_callback_data cb_data = { NULL, FALSE };

  bfd_get_section_by_name_if (file->the_bfd, sec->spec.name,
			      section_iterator_callback, &cb_data);
  *multiple_sections_found = cb_data.multiple_sections_found;
  return cb_data.found_section;
}

/* Code for handling simple wildcards without going through fnmatch,
   which can be expensive because of charset translations etc.  */

/* A simple wild is a literal string followed by a single '*',
   where the literal part is at least 4 characters long.  */

static bfd_boolean
is_simple_wild (const char *name)
{
  size_t len = strcspn (name, "*?[");
  return len >= 4 && name[len] == '*' && name[len + 1] == '\0';
}

static bfd_boolean
match_simple_wild (const char *pattern, const char *name)
{
  /* The first four characters of the pattern are guaranteed valid
     non-wildcard characters.  So we can go faster.  */
  if (pattern[0] != name[0] || pattern[1] != name[1]
      || pattern[2] != name[2] || pattern[3] != name[3])
    return FALSE;

  pattern += 4;
  name += 4;
  while (*pattern != '*')
    if (*name++ != *pattern++)
      return FALSE;

  return TRUE;
}

/* Return the numerical value of the init_priority attribute from
   section name NAME.  */

static unsigned long
get_init_priority (const char *name)
{
  char *end;
  unsigned long init_priority;

  /* GCC uses the following section names for the init_priority
     attribute with numerical values 101 and 65535 inclusive. A
     lower value means a higher priority.

     1: .init_array.NNNN/.fini_array.NNNN: Where NNNN is the
	decimal numerical value of the init_priority attribute.
	The order of execution in .init_array is forward and
	.fini_array is backward.
     2: .ctors.NNNN/.dtors.NNNN: Where NNNN is 65535 minus the
	decimal numerical value of the init_priority attribute.
	The order of execution in .ctors is backward and .dtors
	is forward.
   */
  if (strncmp (name, ".init_array.", 12) == 0
      || strncmp (name, ".fini_array.", 12) == 0)
    {
      init_priority = strtoul (name + 12, &end, 10);
      return *end ? 0 : init_priority;
    }
  else if (strncmp (name, ".ctors.", 7) == 0
	   || strncmp (name, ".dtors.", 7) == 0)
    {
      init_priority = strtoul (name + 7, &end, 10);
      return *end ? 0 : 65535 - init_priority;
    }

  return 0;
}

/* Compare sections ASEC and BSEC according to SORT.  */

static int
compare_section (sort_type sort, asection *asec, asection *bsec)
{
  int ret;
  unsigned long ainit_priority, binit_priority;

  switch (sort)
    {
    default:
      abort ();

    case by_init_priority:
      ainit_priority
	= get_init_priority (bfd_get_section_name (asec->owner, asec));
      binit_priority
	= get_init_priority (bfd_get_section_name (bsec->owner, bsec));
      if (ainit_priority == 0 || binit_priority == 0)
	goto sort_by_name;
      ret = ainit_priority - binit_priority;
      if (ret)
	break;
      else
	goto sort_by_name;

    case by_alignment_name:
      ret = (bfd_section_alignment (bsec->owner, bsec)
	     - bfd_section_alignment (asec->owner, asec));
      if (ret)
	break;
      /* Fall through.  */

    case by_name:
sort_by_name:
      ret = strcmp (bfd_get_section_name (asec->owner, asec),
		    bfd_get_section_name (bsec->owner, bsec));
      break;

    case by_name_alignment:
      ret = strcmp (bfd_get_section_name (asec->owner, asec),
		    bfd_get_section_name (bsec->owner, bsec));
      if (ret)
	break;
      /* Fall through.  */

    case by_alignment:
      ret = (bfd_section_alignment (bsec->owner, bsec)
	     - bfd_section_alignment (asec->owner, asec));
      break;
    }

  return ret;
}

/* Build a Binary Search Tree to sort sections, unlike insertion sort
   used in wild_sort(). BST is considerably faster if the number of
   of sections are large.  */

static lang_section_bst_type **
wild_sort_fast (lang_wild_statement_type *wild,
		struct wildcard_list *sec,
		lang_input_statement_type *file ATTRIBUTE_UNUSED,
		asection *section)
{
  lang_section_bst_type **tree;

  tree = &wild->tree;
  if (!wild->filenames_sorted
      && (sec == NULL || sec->spec.sorted == none))
    {
      /* Append at the right end of tree.  */
      while (*tree)
	tree = &((*tree)->right);
      return tree;
    }

  while (*tree)
    {
      /* Find the correct node to append this section.  */
      if (compare_section (sec->spec.sorted, section, (*tree)->section) < 0)
	tree = &((*tree)->left);
      else
	tree = &((*tree)->right);
    }

  return tree;
}

/* Use wild_sort_fast to build a BST to sort sections.  */

static void
output_section_callback_fast (lang_wild_statement_type *ptr,
			      struct wildcard_list *sec,
			      asection *section,
			      struct flag_info *sflag_list ATTRIBUTE_UNUSED,
			      lang_input_statement_type *file,
			      void *output)
{
  lang_section_bst_type *node;
  lang_section_bst_type **tree;
  lang_output_section_statement_type *os;

  os = (lang_output_section_statement_type *) output;

  if (unique_section_p (section, os))
    return;

  node = (lang_section_bst_type *) xmalloc (sizeof (lang_section_bst_type));
  node->left = 0;
  node->right = 0;
  node->section = section;

  tree = wild_sort_fast (ptr, sec, file, section);
  if (tree != NULL)
    *tree = node;
}

/* Convert a sorted sections' BST back to list form.  */

static void
output_section_callback_tree_to_list (lang_wild_statement_type *ptr,
				      lang_section_bst_type *tree,
				      void *output)
{
  if (tree->left)
    output_section_callback_tree_to_list (ptr, tree->left, output);

  lang_add_section (&ptr->children, tree->section, NULL,
		    (lang_output_section_statement_type *) output);

  if (tree->right)
    output_section_callback_tree_to_list (ptr, tree->right, output);

  free (tree);
}

/* Specialized, optimized routines for handling different kinds of
   wildcards */

static void
walk_wild_section_specs1_wild0 (lang_wild_statement_type *ptr,
				lang_input_statement_type *file,
				callback_t callback,
				void *data)
{
  /* We can just do a hash lookup for the section with the right name.
     But if that lookup discovers more than one section with the name
     (should be rare), we fall back to the general algorithm because
     we would otherwise have to sort the sections to make sure they
     get processed in the bfd's order.  */
  bfd_boolean multiple_sections_found;
  struct wildcard_list *sec0 = ptr->handler_data[0];
  asection *s0 = find_section (file, sec0, &multiple_sections_found);

  if (multiple_sections_found)
    walk_wild_section_general (ptr, file, callback, data);
  else if (s0)
    walk_wild_consider_section (ptr, file, s0, sec0, callback, data);
}

static void
walk_wild_section_specs1_wild1 (lang_wild_statement_type *ptr,
				lang_input_statement_type *file,
				callback_t callback,
				void *data)
{
  asection *s;
  struct wildcard_list *wildsec0 = ptr->handler_data[0];

  for (s = file->the_bfd->sections; s != NULL; s = s->next)
    {
      const char *sname = bfd_get_section_name (file->the_bfd, s);
      bfd_boolean skip = !match_simple_wild (wildsec0->spec.name, sname);

      if (!skip)
	walk_wild_consider_section (ptr, file, s, wildsec0, callback, data);
    }
}

static void
walk_wild_section_specs2_wild1 (lang_wild_statement_type *ptr,
				lang_input_statement_type *file,
				callback_t callback,
				void *data)
{
  asection *s;
  struct wildcard_list *sec0 = ptr->handler_data[0];
  struct wildcard_list *wildsec1 = ptr->handler_data[1];
  bfd_boolean multiple_sections_found;
  asection *s0 = find_section (file, sec0, &multiple_sections_found);

  if (multiple_sections_found)
    {
      walk_wild_section_general (ptr, file, callback, data);
      return;
    }

  /* Note that if the section was not found, s0 is NULL and
     we'll simply never succeed the s == s0 test below.  */
  for (s = file->the_bfd->sections; s != NULL; s = s->next)
    {
      /* Recall that in this code path, a section cannot satisfy more
	 than one spec, so if s == s0 then it cannot match
	 wildspec1.  */
      if (s == s0)
	walk_wild_consider_section (ptr, file, s, sec0, callback, data);
      else
	{
	  const char *sname = bfd_get_section_name (file->the_bfd, s);
	  bfd_boolean skip = !match_simple_wild (wildsec1->spec.name, sname);

	  if (!skip)
	    walk_wild_consider_section (ptr, file, s, wildsec1, callback,
					data);
	}
    }
}

static void
walk_wild_section_specs3_wild2 (lang_wild_statement_type *ptr,
				lang_input_statement_type *file,
				callback_t callback,
				void *data)
{
  asection *s;
  struct wildcard_list *sec0 = ptr->handler_data[0];
  struct wildcard_list *wildsec1 = ptr->handler_data[1];
  struct wildcard_list *wildsec2 = ptr->handler_data[2];
  bfd_boolean multiple_sections_found;
  asection *s0 = find_section (file, sec0, &multiple_sections_found);

  if (multiple_sections_found)
    {
      walk_wild_section_general (ptr, file, callback, data);
      return;
    }

  for (s = file->the_bfd->sections; s != NULL; s = s->next)
    {
      if (s == s0)
	walk_wild_consider_section (ptr, file, s, sec0, callback, data);
      else
	{
	  const char *sname = bfd_get_section_name (file->the_bfd, s);
	  bfd_boolean skip = !match_simple_wild (wildsec1->spec.name, sname);

	  if (!skip)
	    walk_wild_consider_section (ptr, file, s, wildsec1, callback, data);
	  else
	    {
	      skip = !match_simple_wild (wildsec2->spec.name, sname);
	      if (!skip)
		walk_wild_consider_section (ptr, file, s, wildsec2, callback,
					    data);
	    }
	}
    }
}

static void
walk_wild_section_specs4_wild2 (lang_wild_statement_type *ptr,
				lang_input_statement_type *file,
				callback_t callback,
				void *data)
{
  asection *s;
  struct wildcard_list *sec0 = ptr->handler_data[0];
  struct wildcard_list *sec1 = ptr->handler_data[1];
  struct wildcard_list *wildsec2 = ptr->handler_data[2];
  struct wildcard_list *wildsec3 = ptr->handler_data[3];
  bfd_boolean multiple_sections_found;
  asection *s0 = find_section (file, sec0, &multiple_sections_found), *s1;

  if (multiple_sections_found)
    {
      walk_wild_section_general (ptr, file, callback, data);
      return;
    }

  s1 = find_section (file, sec1, &multiple_sections_found);
  if (multiple_sections_found)
    {
      walk_wild_section_general (ptr, file, callback, data);
      return;
    }

  for (s = file->the_bfd->sections; s != NULL; s = s->next)
    {
      if (s == s0)
	walk_wild_consider_section (ptr, file, s, sec0, callback, data);
      else
	if (s == s1)
	  walk_wild_consider_section (ptr, file, s, sec1, callback, data);
	else
	  {
	    const char *sname = bfd_get_section_name (file->the_bfd, s);
	    bfd_boolean skip = !match_simple_wild (wildsec2->spec.name,
						   sname);

	    if (!skip)
	      walk_wild_consider_section (ptr, file, s, wildsec2, callback,
					  data);
	    else
	      {
		skip = !match_simple_wild (wildsec3->spec.name, sname);
		if (!skip)
		  walk_wild_consider_section (ptr, file, s, wildsec3,
					      callback, data);
	      }
	  }
    }
}

static void
walk_wild_section (lang_wild_statement_type *ptr,
		   lang_input_statement_type *file,
		   callback_t callback,
		   void *data)
{
  if (file->flags.just_syms)
    return;

  (*ptr->walk_wild_section_handler) (ptr, file, callback, data);
}

/* Returns TRUE when name1 is a wildcard spec that might match
   something name2 can match.  We're conservative: we return FALSE
   only if the prefixes of name1 and name2 are different up to the
   first wildcard character.  */

static bfd_boolean
wild_spec_can_overlap (const char *name1, const char *name2)
{
  size_t prefix1_len = strcspn (name1, "?*[");
  size_t prefix2_len = strcspn (name2, "?*[");
  size_t min_prefix_len;

  /* Note that if there is no wildcard character, then we treat the
     terminating 0 as part of the prefix.  Thus ".text" won't match
     ".text." or ".text.*", for example.  */
  if (name1[prefix1_len] == '\0')
    prefix1_len++;
  if (name2[prefix2_len] == '\0')
    prefix2_len++;

  min_prefix_len = prefix1_len < prefix2_len ? prefix1_len : prefix2_len;

  return memcmp (name1, name2, min_prefix_len) == 0;
}

/* Select specialized code to handle various kinds of wildcard
   statements.  */

static void
analyze_walk_wild_section_handler (lang_wild_statement_type *ptr)
{
  int sec_count = 0;
  int wild_name_count = 0;
  struct wildcard_list *sec;
  int signature;
  int data_counter;

  ptr->walk_wild_section_handler = walk_wild_section_general;
  ptr->handler_data[0] = NULL;
  ptr->handler_data[1] = NULL;
  ptr->handler_data[2] = NULL;
  ptr->handler_data[3] = NULL;
  ptr->tree = NULL;

  /* Count how many wildcard_specs there are, and how many of those
     actually use wildcards in the name.  Also, bail out if any of the
     wildcard names are NULL. (Can this actually happen?
     walk_wild_section used to test for it.)  And bail out if any
     of the wildcards are more complex than a simple string
     ending in a single '*'.  */
  for (sec = ptr->section_list; sec != NULL; sec = sec->next)
    {
      ++sec_count;
      if (sec->spec.name == NULL)
	return;
      if (wildcardp (sec->spec.name))
	{
	  ++wild_name_count;
	  if (!is_simple_wild (sec->spec.name))
	    return;
	}
    }

  /* The zero-spec case would be easy to optimize but it doesn't
     happen in practice.  Likewise, more than 4 specs doesn't
     happen in practice.  */
  if (sec_count == 0 || sec_count > 4)
    return;

  /* Check that no two specs can match the same section.  */
  for (sec = ptr->section_list; sec != NULL; sec = sec->next)
    {
      struct wildcard_list *sec2;
      for (sec2 = sec->next; sec2 != NULL; sec2 = sec2->next)
	{
	  if (wild_spec_can_overlap (sec->spec.name, sec2->spec.name))
	    return;
	}
    }

  signature = (sec_count << 8) + wild_name_count;
  switch (signature)
    {
    case 0x0100:
      ptr->walk_wild_section_handler = walk_wild_section_specs1_wild0;
      break;
    case 0x0101:
      ptr->walk_wild_section_handler = walk_wild_section_specs1_wild1;
      break;
    case 0x0201:
      ptr->walk_wild_section_handler = walk_wild_section_specs2_wild1;
      break;
    case 0x0302:
      ptr->walk_wild_section_handler = walk_wild_section_specs3_wild2;
      break;
    case 0x0402:
      ptr->walk_wild_section_handler = walk_wild_section_specs4_wild2;
      break;
    default:
      return;
    }

  /* Now fill the data array with pointers to the specs, first the
     specs with non-wildcard names, then the specs with wildcard
     names.  It's OK to process the specs in different order from the
     given order, because we've already determined that no section
     will match more than one spec.  */
  data_counter = 0;
  for (sec = ptr->section_list; sec != NULL; sec = sec->next)
    if (!wildcardp (sec->spec.name))
      ptr->handler_data[data_counter++] = sec;
  for (sec = ptr->section_list; sec != NULL; sec = sec->next)
    if (wildcardp (sec->spec.name))
      ptr->handler_data[data_counter++] = sec;
}

/* Handle a wild statement for a single file F.  */

static void
walk_wild_file (lang_wild_statement_type *s,
		lang_input_statement_type *f,
		callback_t callback,
		void *data)
{
  if (f->the_bfd == NULL
      || ! bfd_check_format (f->the_bfd, bfd_archive))
    walk_wild_section (s, f, callback, data);
  else
    {
      bfd *member;

      /* This is an archive file.  We must map each member of the
	 archive separately.  */
      member = bfd_openr_next_archived_file (f->the_bfd, NULL);
      while (member != NULL)
	{
	  /* When lookup_name is called, it will call the add_symbols
	     entry point for the archive.  For each element of the
	     archive which is included, BFD will call ldlang_add_file,
	     which will set the usrdata field of the member to the
	     lang_input_statement.  */
	  if (member->usrdata != NULL)
	    {
	      walk_wild_section (s,
				 (lang_input_statement_type *) member->usrdata,
				 callback, data);
	    }

	  member = bfd_openr_next_archived_file (f->the_bfd, member);
	}
    }
}

static void
walk_wild (lang_wild_statement_type *s, callback_t callback, void *data)
{
  const char *file_spec = s->filename;
  char *p;

  if (file_spec == NULL)
    {
      /* Perform the iteration over all files in the list.  */
      LANG_FOR_EACH_INPUT_STATEMENT (f)
	{
	  walk_wild_file (s, f, callback, data);
	}
    }
  else if ((p = archive_path (file_spec)) != NULL)
    {
      LANG_FOR_EACH_INPUT_STATEMENT (f)
	{
	  if (input_statement_is_archive_path (file_spec, p, f))
	    walk_wild_file (s, f, callback, data);
	}
    }
  else if (wildcardp (file_spec))
    {
      LANG_FOR_EACH_INPUT_STATEMENT (f)
	{
	  if (fnmatch (file_spec, f->filename, 0) == 0)
	    walk_wild_file (s, f, callback, data);
	}
    }
  else
    {
      lang_input_statement_type *f;

      /* Perform the iteration over a single file.  */
      f = lookup_name (file_spec);
      if (f)
	walk_wild_file (s, f, callback, data);
    }
}

/* lang_for_each_statement walks the parse tree and calls the provided
   function for each node, except those inside output section statements
   with constraint set to -1.  */

void
lang_for_each_statement_worker (void (*func) (lang_statement_union_type *),
				lang_statement_union_type *s)
{
  for (; s != NULL; s = s->header.next)
    {
      func (s);

      switch (s->header.type)
	{
	case lang_constructors_statement_enum:
	  lang_for_each_statement_worker (func, constructor_list.head);
	  break;
	case lang_output_section_statement_enum:
	  if (s->output_section_statement.constraint != -1)
	    lang_for_each_statement_worker
	      (func, s->output_section_statement.children.head);
	  break;
	case lang_wild_statement_enum:
	  lang_for_each_statement_worker (func,
					  s->wild_statement.children.head);
	  break;
	case lang_group_statement_enum:
	  lang_for_each_statement_worker (func,
					  s->group_statement.children.head);
	  break;
	case lang_data_statement_enum:
	case lang_reloc_statement_enum:
	case lang_object_symbols_statement_enum:
	case lang_output_statement_enum:
	case lang_target_statement_enum:
	case lang_input_section_enum:
	case lang_input_statement_enum:
	case lang_assignment_statement_enum:
	case lang_padding_statement_enum:
	case lang_address_statement_enum:
	case lang_fill_statement_enum:
	case lang_insert_statement_enum:
	  break;
	default:
	  FAIL ();
	  break;
	}
    }
}

void
lang_for_each_statement (void (*func) (lang_statement_union_type *))
{
  lang_for_each_statement_worker (func, statement_list.head);
}

/*----------------------------------------------------------------------*/

void
lang_list_init (lang_statement_list_type *list)
{
  list->head = NULL;
  list->tail = &list->head;
}

void
push_stat_ptr (lang_statement_list_type *new_ptr)
{
  if (stat_save_ptr >= stat_save + sizeof (stat_save) / sizeof (stat_save[0]))
    abort ();
  *stat_save_ptr++ = stat_ptr;
  stat_ptr = new_ptr;
}

void
pop_stat_ptr (void)
{
  if (stat_save_ptr <= stat_save)
    abort ();
  stat_ptr = *--stat_save_ptr;
}

/* Build a new statement node for the parse tree.  */

static lang_statement_union_type *
new_statement (enum statement_enum type,
	       size_t size,
	       lang_statement_list_type *list)
{
  lang_statement_union_type *new_stmt;

  new_stmt = (lang_statement_union_type *) stat_alloc (size);
  new_stmt->header.type = type;
  new_stmt->header.next = NULL;
  lang_statement_append (list, new_stmt, &new_stmt->header.next);
  return new_stmt;
}

/* Build a new input file node for the language.  There are several
   ways in which we treat an input file, eg, we only look at symbols,
   or prefix it with a -l etc.

   We can be supplied with requests for input files more than once;
   they may, for example be split over several lines like foo.o(.text)
   foo.o(.data) etc, so when asked for a file we check that we haven't
   got it already so we don't duplicate the bfd.  */

static lang_input_statement_type *
new_afile (const char *name,
	   lang_input_file_enum_type file_type,
	   const char *target,
	   bfd_boolean add_to_list)
{
  lang_input_statement_type *p;

  lang_has_input_file = TRUE;

  if (add_to_list)
    p = (lang_input_statement_type *) new_stat (lang_input_statement, stat_ptr);
  else
    {
      p = (lang_input_statement_type *)
	  stat_alloc (sizeof (lang_input_statement_type));
      p->header.type = lang_input_statement_enum;
      p->header.next = NULL;
    }

  memset (&p->the_bfd, 0,
	  sizeof (*p) - offsetof (lang_input_statement_type, the_bfd));
  p->target = target;
  p->flags.dynamic = input_flags.dynamic;
  p->flags.add_DT_NEEDED_for_dynamic = input_flags.add_DT_NEEDED_for_dynamic;
  p->flags.add_DT_NEEDED_for_regular = input_flags.add_DT_NEEDED_for_regular;
  p->flags.whole_archive = input_flags.whole_archive;
  p->flags.sysrooted = input_flags.sysrooted;

  if (file_type == lang_input_file_is_l_enum
      && name[0] == ':' && name[1] != '\0')
    {
      file_type = lang_input_file_is_search_file_enum;
      name = name + 1;
    }

  switch (file_type)
    {
    case lang_input_file_is_symbols_only_enum:
      p->filename = name;
      p->local_sym_name = name;
      p->flags.real = TRUE;
      p->flags.just_syms = TRUE;
      break;
    case lang_input_file_is_fake_enum:
      p->filename = name;
      p->local_sym_name = name;
      break;
    case lang_input_file_is_l_enum:
      p->filename = name;
      p->local_sym_name = concat ("-l", name, (const char *) NULL);
      p->flags.maybe_archive = TRUE;
      p->flags.real = TRUE;
      p->flags.search_dirs = TRUE;
      break;
    case lang_input_file_is_marker_enum:
      p->filename = name;
      p->local_sym_name = name;
      p->flags.search_dirs = TRUE;
      break;
    case lang_input_file_is_search_file_enum:
      p->filename = name;
      p->local_sym_name = name;
      p->flags.real = TRUE;
      p->flags.search_dirs = TRUE;
      break;
    case lang_input_file_is_file_enum:
      p->filename = name;
      p->local_sym_name = name;
      p->flags.real = TRUE;
      break;
    default:
      FAIL ();
    }

  lang_statement_append (&input_file_chain,
			 (lang_statement_union_type *) p,
			 &p->next_real_file);
  return p;
}

lang_input_statement_type *
lang_add_input_file (const char *name,
		     lang_input_file_enum_type file_type,
		     const char *target)
{
  return new_afile (name, file_type, target, TRUE);
}

struct out_section_hash_entry
{
  struct bfd_hash_entry root;
  lang_statement_union_type s;
};

/* The hash table.  */

static struct bfd_hash_table output_section_statement_table;

/* Support routines for the hash table used by lang_output_section_find,
   initialize the table, fill in an entry and remove the table.  */

static struct bfd_hash_entry *
output_section_statement_newfunc (struct bfd_hash_entry *entry,
				  struct bfd_hash_table *table,
				  const char *string)
{
  lang_output_section_statement_type **nextp;
  struct out_section_hash_entry *ret;

  if (entry == NULL)
    {
      entry = (struct bfd_hash_entry *) bfd_hash_allocate (table,
							   sizeof (*ret));
      if (entry == NULL)
	return entry;
    }

  entry = bfd_hash_newfunc (entry, table, string);
  if (entry == NULL)
    return entry;

  ret = (struct out_section_hash_entry *) entry;
  memset (&ret->s, 0, sizeof (ret->s));
  ret->s.header.type = lang_output_section_statement_enum;
  ret->s.output_section_statement.subsection_alignment = -1;
  ret->s.output_section_statement.section_alignment = -1;
  ret->s.output_section_statement.block_value = 1;
  lang_list_init (&ret->s.output_section_statement.children);
  lang_statement_append (stat_ptr, &ret->s, &ret->s.header.next);

  /* For every output section statement added to the list, except the
     first one, lang_output_section_statement.tail points to the "next"
     field of the last element of the list.  */
  if (lang_output_section_statement.head != NULL)
    ret->s.output_section_statement.prev
      = ((lang_output_section_statement_type *)
	 ((char *) lang_output_section_statement.tail
	  - offsetof (lang_output_section_statement_type, next)));

  /* GCC's strict aliasing rules prevent us from just casting the
     address, so we store the pointer in a variable and cast that
     instead.  */
  nextp = &ret->s.output_section_statement.next;
  lang_statement_append (&lang_output_section_statement,
			 &ret->s,
			 (lang_statement_union_type **) nextp);
  return &ret->root;
}

static void
output_section_statement_table_init (void)
{
  if (!bfd_hash_table_init_n (&output_section_statement_table,
			      output_section_statement_newfunc,
			      sizeof (struct out_section_hash_entry),
			      61))
    einfo (_("%P%F: can not create hash table: %E\n"));
}

static void
output_section_statement_table_free (void)
{
  bfd_hash_table_free (&output_section_statement_table);
}

/* Build enough state so that the parser can build its tree.  */

void
lang_init (void)
{
  obstack_begin (&stat_obstack, 1000);

  stat_ptr = &statement_list;

  output_section_statement_table_init ();

  lang_list_init (stat_ptr);

  lang_list_init (&input_file_chain);
  lang_list_init (&lang_output_section_statement);
  lang_list_init (&file_chain);
  first_file = lang_add_input_file (NULL, lang_input_file_is_marker_enum,
				    NULL);
  abs_output_section =
    lang_output_section_statement_lookup (BFD_ABS_SECTION_NAME, 0, TRUE);

  abs_output_section->bfd_section = bfd_abs_section_ptr;

  /* The value "3" is ad-hoc, somewhat related to the expected number of
     DEFINED expressions in a linker script.  For most default linker
     scripts, there are none.  Why a hash table then?  Well, it's somewhat
     simpler to re-use working machinery than using a linked list in terms
     of code-complexity here in ld, besides the initialization which just
     looks like other code here.  */
  if (!bfd_hash_table_init_n (&lang_definedness_table,
			      lang_definedness_newfunc,
			      sizeof (struct lang_definedness_hash_entry),
			      3))
    einfo (_("%P%F: can not create hash table: %E\n"));
}

void
lang_finish (void)
{
  bfd_link_hash_table_free (link_info.output_bfd, link_info.hash);
  bfd_hash_table_free (&lang_definedness_table);
  output_section_statement_table_free ();
}

/*----------------------------------------------------------------------
  A region is an area of memory declared with the
  MEMORY {  name:org=exp, len=exp ... }
  syntax.

  We maintain a list of all the regions here.

  If no regions are specified in the script, then the default is used
  which is created when looked up to be the entire data space.

  If create is true we are creating a region inside a MEMORY block.
  In this case it is probably an error to create a region that has
  already been created.  If we are not inside a MEMORY block it is
  dubious to use an undeclared region name (except DEFAULT_MEMORY_REGION)
  and so we issue a warning.

  Each region has at least one name.  The first name is either
  DEFAULT_MEMORY_REGION or the name given in the MEMORY block.  You can add
  alias names to an existing region within a script with
  REGION_ALIAS (alias, region_name).  Each name corresponds to at most one
  region.  */

static lang_memory_region_type *lang_memory_region_list;
static lang_memory_region_type **lang_memory_region_list_tail
  = &lang_memory_region_list;

lang_memory_region_type *
lang_memory_region_lookup (const char *const name, bfd_boolean create)
{
  lang_memory_region_name *n;
  lang_memory_region_type *r;
  lang_memory_region_type *new_region;

  /* NAME is NULL for LMA memspecs if no region was specified.  */
  if (name == NULL)
    return NULL;

  for (r = lang_memory_region_list; r != NULL; r = r->next)
    for (n = &r->name_list; n != NULL; n = n->next)
      if (strcmp (n->name, name) == 0)
	{
	  if (create)
	    einfo (_("%P:%S: warning: redeclaration of memory region `%s'\n"),
		   NULL, name);
	  return r;
	}

  if (!create && strcmp (name, DEFAULT_MEMORY_REGION))
    einfo (_("%P:%S: warning: memory region `%s' not declared\n"),
	   NULL, name);

  new_region = (lang_memory_region_type *)
      stat_alloc (sizeof (lang_memory_region_type));

  new_region->name_list.name = xstrdup (name);
  new_region->name_list.next = NULL;
  new_region->next = NULL;
  new_region->origin = 0;
  new_region->length = ~(bfd_size_type) 0;
  new_region->current = 0;
  new_region->last_os = NULL;
  new_region->flags = 0;
  new_region->not_flags = 0;
  new_region->had_full_message = FALSE;

  *lang_memory_region_list_tail = new_region;
  lang_memory_region_list_tail = &new_region->next;

  return new_region;
}

void
lang_memory_region_alias (const char * alias, const char * region_name)
{
  lang_memory_region_name * n;
  lang_memory_region_type * r;
  lang_memory_region_type * region;

  /* The default region must be unique.  This ensures that it is not necessary
     to iterate through the name list if someone wants the check if a region is
     the default memory region.  */
  if (strcmp (region_name, DEFAULT_MEMORY_REGION) == 0
      || strcmp (alias, DEFAULT_MEMORY_REGION) == 0)
    einfo (_("%F%P:%S: error: alias for default memory region\n"), NULL);

  /* Look for the target region and check if the alias is not already
     in use.  */
  region = NULL;
  for (r = lang_memory_region_list; r != NULL; r = r->next)
    for (n = &r->name_list; n != NULL; n = n->next)
      {
	if (region == NULL && strcmp (n->name, region_name) == 0)
	  region = r;
	if (strcmp (n->name, alias) == 0)
	  einfo (_("%F%P:%S: error: redefinition of memory region "
		   "alias `%s'\n"),
		 NULL, alias);
      }

  /* Check if the target region exists.  */
  if (region == NULL)
    einfo (_("%F%P:%S: error: memory region `%s' "
	     "for alias `%s' does not exist\n"),
	   NULL, region_name, alias);

  /* Add alias to region name list.  */
  n = (lang_memory_region_name *) stat_alloc (sizeof (lang_memory_region_name));
  n->name = xstrdup (alias);
  n->next = region->name_list.next;
  region->name_list.next = n;
}

static lang_memory_region_type *
lang_memory_default (asection * section)
{
  lang_memory_region_type *p;

  flagword sec_flags = section->flags;

  /* Override SEC_DATA to mean a writable section.  */
  if ((sec_flags & (SEC_ALLOC | SEC_READONLY | SEC_CODE)) == SEC_ALLOC)
    sec_flags |= SEC_DATA;

  for (p = lang_memory_region_list; p != NULL; p = p->next)
    {
      if ((p->flags & sec_flags) != 0
	  && (p->not_flags & sec_flags) == 0)
	{
	  return p;
	}
    }
  return lang_memory_region_lookup (DEFAULT_MEMORY_REGION, FALSE);
}

/* Find or create an output_section_statement with the given NAME.
   If CONSTRAINT is non-zero match one with that constraint, otherwise
   match any non-negative constraint.  If CREATE, always make a
   new output_section_statement for SPECIAL CONSTRAINT.  */

lang_output_section_statement_type *
lang_output_section_statement_lookup (const char *name,
				      int constraint,
				      bfd_boolean create)
{
  struct out_section_hash_entry *entry;

  entry = ((struct out_section_hash_entry *)
	   bfd_hash_lookup (&output_section_statement_table, name,
			    create, FALSE));
  if (entry == NULL)
    {
      if (create)
	einfo (_("%P%F: failed creating section `%s': %E\n"), name);
      return NULL;
    }

  if (entry->s.output_section_statement.name != NULL)
    {
      /* We have a section of this name, but it might not have the correct
	 constraint.  */
      struct out_section_hash_entry *last_ent;

      name = entry->s.output_section_statement.name;
      if (create && constraint == SPECIAL)
	/* Not traversing to the end reverses the order of the second
	   and subsequent SPECIAL sections in the hash table chain,
	   but that shouldn't matter.  */
	last_ent = entry;
      else
	do
	  {
	    if (constraint == entry->s.output_section_statement.constraint
		|| (constraint == 0
		    && entry->s.output_section_statement.constraint >= 0))
	      return &entry->s.output_section_statement;
	    last_ent = entry;
	    entry = (struct out_section_hash_entry *) entry->root.next;
	  }
	while (entry != NULL
	       && name == entry->s.output_section_statement.name);

      if (!create)
	return NULL;

      entry
	= ((struct out_section_hash_entry *)
	   output_section_statement_newfunc (NULL,
					     &output_section_statement_table,
					     name));
      if (entry == NULL)
	{
	  einfo (_("%P%F: failed creating section `%s': %E\n"), name);
	  return NULL;
	}
      entry->root = last_ent->root;
      last_ent->root.next = &entry->root;
    }

  entry->s.output_section_statement.name = name;
  entry->s.output_section_statement.constraint = constraint;
  return &entry->s.output_section_statement;
}

/* Find the next output_section_statement with the same name as OS.
   If CONSTRAINT is non-zero, find one with that constraint otherwise
   match any non-negative constraint.  */

lang_output_section_statement_type *
next_matching_output_section_statement (lang_output_section_statement_type *os,
					int constraint)
{
  /* All output_section_statements are actually part of a
     struct out_section_hash_entry.  */
  struct out_section_hash_entry *entry = (struct out_section_hash_entry *)
    ((char *) os
     - offsetof (struct out_section_hash_entry, s.output_section_statement));
  const char *name = os->name;

  ASSERT (name == entry->root.string);
  do
    {
      entry = (struct out_section_hash_entry *) entry->root.next;
      if (entry == NULL
	  || name != entry->s.output_section_statement.name)
	return NULL;
    }
  while (constraint != entry->s.output_section_statement.constraint
	 && (constraint != 0
	     || entry->s.output_section_statement.constraint < 0));

  return &entry->s.output_section_statement;
}

/* A variant of lang_output_section_find used by place_orphan.
   Returns the output statement that should precede a new output
   statement for SEC.  If an exact match is found on certain flags,
   sets *EXACT too.  */

lang_output_section_statement_type *
lang_output_section_find_by_flags (const asection *sec,
				   lang_output_section_statement_type **exact,
				   lang_match_sec_type_func match_type)
{
  lang_output_section_statement_type *first, *look, *found;
  flagword flags;

  /* We know the first statement on this list is *ABS*.  May as well
     skip it.  */
  first = &lang_output_section_statement.head->output_section_statement;
  first = first->next;

  /* First try for an exact match.  */
  found = NULL;
  for (look = first; look; look = look->next)
    {
      flags = look->flags;
      if (look->bfd_section != NULL)
	{
	  flags = look->bfd_section->flags;
	  if (match_type && !match_type (link_info.output_bfd,
					 look->bfd_section,
					 sec->owner, sec))
	    continue;
	}
      flags ^= sec->flags;
      if (!(flags & (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_READONLY
		     | SEC_CODE | SEC_SMALL_DATA | SEC_THREAD_LOCAL)))
	found = look;
    }
  if (found != NULL)
    {
      if (exact != NULL)
	*exact = found;
      return found;
    }

  if ((sec->flags & SEC_CODE) != 0
      && (sec->flags & SEC_ALLOC) != 0)
    {
      /* Try for a rw code section.  */
      for (look = first; look; look = look->next)
	{
	  flags = look->flags;
	  if (look->bfd_section != NULL)
	    {
	      flags = look->bfd_section->flags;
	      if (match_type && !match_type (link_info.output_bfd,
					     look->bfd_section,
					     sec->owner, sec))
		continue;
	    }
	  flags ^= sec->flags;
	  if (!(flags & (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD
			 | SEC_CODE | SEC_SMALL_DATA | SEC_THREAD_LOCAL)))
	    found = look;
	}
    }
  else if ((sec->flags & (SEC_READONLY | SEC_THREAD_LOCAL)) != 0
	   && (sec->flags & SEC_ALLOC) != 0)
    {
      /* .rodata can go after .text, .sdata2 after .rodata.  */
      for (look = first; look; look = look->next)
	{
	  flags = look->flags;
	  if (look->bfd_section != NULL)
	    {
	      flags = look->bfd_section->flags;
	      if (match_type && !match_type (link_info.output_bfd,
					     look->bfd_section,
					     sec->owner, sec))
		continue;
	    }
	  flags ^= sec->flags;
	  if (!(flags & (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD
			 | SEC_READONLY | SEC_SMALL_DATA))
	      || (!(flags & (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD
			     | SEC_READONLY))
		  && !(look->flags & SEC_SMALL_DATA))
	      || (!(flags & (SEC_THREAD_LOCAL | SEC_ALLOC))
		  && (look->flags & SEC_THREAD_LOCAL)
		  && (!(flags & SEC_LOAD)
		      || (look->flags & SEC_LOAD))))
	    found = look;
	}
    }
  else if ((sec->flags & SEC_SMALL_DATA) != 0
	   && (sec->flags & SEC_ALLOC) != 0)
    {
      /* .sdata goes after .data, .sbss after .sdata.  */
      for (look = first; look; look = look->next)
	{
	  flags = look->flags;
	  if (look->bfd_section != NULL)
	    {
	      flags = look->bfd_section->flags;
	      if (match_type && !match_type (link_info.output_bfd,
					     look->bfd_section,
					     sec->owner, sec))
		continue;
	    }
	  flags ^= sec->flags;
	  if (!(flags & (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD
			 | SEC_THREAD_LOCAL))
	      || ((look->flags & SEC_SMALL_DATA)
		  && !(sec->flags & SEC_HAS_CONTENTS)))
	    found = look;
	}
    }
  else if ((sec->flags & SEC_HAS_CONTENTS) != 0
	   && (sec->flags & SEC_ALLOC) != 0)
    {
      /* .data goes after .rodata.  */
      for (look = first; look; look = look->next)
	{
	  flags = look->flags;
	  if (look->bfd_section != NULL)
	    {
	      flags = look->bfd_section->flags;
	      if (match_type && !match_type (link_info.output_bfd,
					     look->bfd_section,
					     sec->owner, sec))
		continue;
	    }
	  flags ^= sec->flags;
	  if (!(flags & (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD
			 | SEC_SMALL_DATA | SEC_THREAD_LOCAL)))
	    found = look;
	}
    }
  else if ((sec->flags & SEC_ALLOC) != 0)
    {
      /* .bss goes after any other alloc section.  */
      for (look = first; look; look = look->next)
	{
	  flags = look->flags;
	  if (look->bfd_section != NULL)
	    {
	      flags = look->bfd_section->flags;
	      if (match_type && !match_type (link_info.output_bfd,
					     look->bfd_section,
					     sec->owner, sec))
		continue;
	    }
	  flags ^= sec->flags;
	  if (!(flags & SEC_ALLOC))
	    found = look;
	}
    }
  else
    {
      /* non-alloc go last.  */
      for (look = first; look; look = look->next)
	{
	  flags = look->flags;
	  if (look->bfd_section != NULL)
	    flags = look->bfd_section->flags;
	  flags ^= sec->flags;
	  if (!(flags & SEC_DEBUGGING))
	    found = look;
	}
      return found;
    }

  if (found || !match_type)
    return found;

  return lang_output_section_find_by_flags (sec, NULL, NULL);
}

/* Find the last output section before given output statement.
   Used by place_orphan.  */

static asection *
output_prev_sec_find (lang_output_section_statement_type *os)
{
  lang_output_section_statement_type *lookup;

  for (lookup = os->prev; lookup != NULL; lookup = lookup->prev)
    {
      if (lookup->constraint < 0)
	continue;

      if (lookup->bfd_section != NULL && lookup->bfd_section->owner != NULL)
	return lookup->bfd_section;
    }

  return NULL;
}

/* Look for a suitable place for a new output section statement.  The
   idea is to skip over anything that might be inside a SECTIONS {}
   statement in a script, before we find another output section
   statement.  Assignments to "dot" before an output section statement
   are assumed to belong to it, except in two cases;  The first
   assignment to dot, and assignments before non-alloc sections.
   Otherwise we might put an orphan before . = . + SIZEOF_HEADERS or
   similar assignments that set the initial address, or we might
   insert non-alloc note sections among assignments setting end of
   image symbols.  */

static lang_statement_union_type **
insert_os_after (lang_output_section_statement_type *after)
{
  lang_statement_union_type **where;
  lang_statement_union_type **assign = NULL;
  bfd_boolean ignore_first;

  ignore_first
    = after == &lang_output_section_statement.head->output_section_statement;

  for (where = &after->header.next;
       *where != NULL;
       where = &(*where)->header.next)
    {
      switch ((*where)->header.type)
	{
	case lang_assignment_statement_enum:
	  if (assign == NULL)
	    {
	      lang_assignment_statement_type *ass;

	      ass = &(*where)->assignment_statement;
	      if (ass->exp->type.node_class != etree_assert
		  && ass->exp->assign.dst[0] == '.'
		  && ass->exp->assign.dst[1] == 0
		  && !ignore_first)
		assign = where;
	    }
	  ignore_first = FALSE;
	  continue;
	case lang_wild_statement_enum:
	case lang_input_section_enum:
	case lang_object_symbols_statement_enum:
	case lang_fill_statement_enum:
	case lang_data_statement_enum:
	case lang_reloc_statement_enum:
	case lang_padding_statement_enum:
	case lang_constructors_statement_enum:
	  assign = NULL;
	  continue;
	case lang_output_section_statement_enum:
	  if (assign != NULL)
	    {
	      asection *s = (*where)->output_section_statement.bfd_section;

	      if (s == NULL
		  || s->map_head.s == NULL
		  || (s->flags & SEC_ALLOC) != 0)
		where = assign;
	    }
	  break;
	case lang_input_statement_enum:
	case lang_address_statement_enum:
	case lang_target_statement_enum:
	case lang_output_statement_enum:
	case lang_group_statement_enum:
	case lang_insert_statement_enum:
	  continue;
	}
      break;
    }

  return where;
}

lang_output_section_statement_type *
lang_insert_orphan (asection *s,
		    const char *secname,
		    int constraint,
		    lang_output_section_statement_type *after,
		    struct orphan_save *place,
		    etree_type *address,
		    lang_statement_list_type *add_child)
{
  lang_statement_list_type add;
  const char *ps;
  lang_output_section_statement_type *os;
  lang_output_section_statement_type **os_tail;

  /* If we have found an appropriate place for the output section
     statements for this orphan, add them to our own private list,
     inserting them later into the global statement list.  */
  if (after != NULL)
    {
      lang_list_init (&add);
      push_stat_ptr (&add);
    }

  if (link_info.relocatable || (s->flags & (SEC_LOAD | SEC_ALLOC)) == 0)
    address = exp_intop (0);

  os_tail = ((lang_output_section_statement_type **)
	     lang_output_section_statement.tail);
  os = lang_enter_output_section_statement (secname, address, normal_section,
					    NULL, NULL, NULL, constraint, 0);

  ps = NULL;
  if (config.build_constructors && *os_tail == os)
    {
      /* If the name of the section is representable in C, then create
	 symbols to mark the start and the end of the section.  */
      for (ps = secname; *ps != '\0'; ps++)
	if (! ISALNUM ((unsigned char) *ps) && *ps != '_')
	  break;
      if (*ps == '\0')
	{
	  char *symname;

	  symname = (char *) xmalloc (ps - secname + sizeof "__start_" + 1);
	  symname[0] = bfd_get_symbol_leading_char (link_info.output_bfd);
	  sprintf (symname + (symname[0] != 0), "__start_%s", secname);
	  lang_add_assignment (exp_provide (symname,
					    exp_nameop (NAME, "."),
					    FALSE));
	}
    }

  if (add_child == NULL)
    add_child = &os->children;
  lang_add_section (add_child, s, NULL, os);

  if (after && (s->flags & (SEC_LOAD | SEC_ALLOC)) != 0)
    {
      const char *region = (after->region
			    ? after->region->name_list.name
			    : DEFAULT_MEMORY_REGION);
      const char *lma_region = (after->lma_region
				? after->lma_region->name_list.name
				: NULL);
      lang_leave_output_section_statement (NULL, region, after->phdrs,
					   lma_region);
    }
  else
    lang_leave_output_section_statement (NULL, DEFAULT_MEMORY_REGION, NULL,
					 NULL);

  if (ps != NULL && *ps == '\0')
    {
      char *symname;

      symname = (char *) xmalloc (ps - secname + sizeof "__stop_" + 1);
      symname[0] = bfd_get_symbol_leading_char (link_info.output_bfd);
      sprintf (symname + (symname[0] != 0), "__stop_%s", secname);
      lang_add_assignment (exp_provide (symname,
					exp_nameop (NAME, "."),
					FALSE));
    }

  /* Restore the global list pointer.  */
  if (after != NULL)
    pop_stat_ptr ();

  if (after != NULL && os->bfd_section != NULL)
    {
      asection *snew, *as;

      snew = os->bfd_section;

      /* Shuffle the bfd section list to make the output file look
	 neater.  This is really only cosmetic.  */
      if (place->section == NULL
	  && after != (&lang_output_section_statement.head
		       ->output_section_statement))
	{
	  asection *bfd_section = after->bfd_section;

	  /* If the output statement hasn't been used to place any input
	     sections (and thus doesn't have an output bfd_section),
	     look for the closest prior output statement having an
	     output section.  */
	  if (bfd_section == NULL)
	    bfd_section = output_prev_sec_find (after);

	  if (bfd_section != NULL && bfd_section != snew)
	    place->section = &bfd_section->next;
	}

      if (place->section == NULL)
	place->section = &link_info.output_bfd->sections;

      as = *place->section;

      if (!as)
	{
	  /* Put the section at the end of the list.  */

	  /* Unlink the section.  */
	  bfd_section_list_remove (link_info.output_bfd, snew);

	  /* Now tack it back on in the right place.  */
	  bfd_section_list_append (link_info.output_bfd, snew);
	}
      else if (as != snew && as->prev != snew)
	{
	  /* Unlink the section.  */
	  bfd_section_list_remove (link_info.output_bfd, snew);

	  /* Now tack it back on in the right place.  */
	  bfd_section_list_insert_before (link_info.output_bfd, as, snew);
	}

      /* Save the end of this list.  Further ophans of this type will
	 follow the one we've just added.  */
      place->section = &snew->next;

      /* The following is non-cosmetic.  We try to put the output
	 statements in some sort of reasonable order here, because they
	 determine the final load addresses of the orphan sections.
	 In addition, placing output statements in the wrong order may
	 require extra segments.  For instance, given a typical
	 situation of all read-only sections placed in one segment and
	 following that a segment containing all the read-write
	 sections, we wouldn't want to place an orphan read/write
	 section before or amongst the read-only ones.  */
      if (add.head != NULL)
	{
	  lang_output_section_statement_type *newly_added_os;

	  if (place->stmt == NULL)
	    {
	      lang_statement_union_type **where = insert_os_after (after);

	      *add.tail = *where;
	      *where = add.head;

	      place->os_tail = &after->next;
	    }
	  else
	    {
	      /* Put it after the last orphan statement we added.  */
	      *add.tail = *place->stmt;
	      *place->stmt = add.head;
	    }

	  /* Fix the global list pointer if we happened to tack our
	     new list at the tail.  */
	  if (*stat_ptr->tail == add.head)
	    stat_ptr->tail = add.tail;

	  /* Save the end of this list.  */
	  place->stmt = add.tail;

	  /* Do the same for the list of output section statements.  */
	  newly_added_os = *os_tail;
	  *os_tail = NULL;
	  newly_added_os->prev = (lang_output_section_statement_type *)
	    ((char *) place->os_tail
	     - offsetof (lang_output_section_statement_type, next));
	  newly_added_os->next = *place->os_tail;
	  if (newly_added_os->next != NULL)
	    newly_added_os->next->prev = newly_added_os;
	  *place->os_tail = newly_added_os;
	  place->os_tail = &newly_added_os->next;

	  /* Fixing the global list pointer here is a little different.
	     We added to the list in lang_enter_output_section_statement,
	     trimmed off the new output_section_statment above when
	     assigning *os_tail = NULL, but possibly added it back in
	     the same place when assigning *place->os_tail.  */
	  if (*os_tail == NULL)
	    lang_output_section_statement.tail
	      = (lang_statement_union_type **) os_tail;
	}
    }
  return os;
}

static void
lang_map_flags (flagword flag)
{
  if (flag & SEC_ALLOC)
    minfo ("a");

  if (flag & SEC_CODE)
    minfo ("x");

  if (flag & SEC_READONLY)
    minfo ("r");

  if (flag & SEC_DATA)
    minfo ("w");

  if (flag & SEC_LOAD)
    minfo ("l");
}

void
lang_map (void)
{
  lang_memory_region_type *m;
  bfd_boolean dis_header_printed = FALSE;
  bfd *p;

  LANG_FOR_EACH_INPUT_STATEMENT (file)
    {
      asection *s;

      if ((file->the_bfd->flags & (BFD_LINKER_CREATED | DYNAMIC)) != 0
	  || file->flags.just_syms)
	continue;

      for (s = file->the_bfd->sections; s != NULL; s = s->next)
	if ((s->output_section == NULL
	     || s->output_section->owner != link_info.output_bfd)
	    && (s->flags & (SEC_LINKER_CREATED | SEC_KEEP)) == 0)
	  {
	    if (! dis_header_printed)
	      {
		fprintf (config.map_file, _("\nDiscarded input sections\n\n"));
		dis_header_printed = TRUE;
	      }

	    print_input_section (s, TRUE);
	  }
    }

  minfo (_("\nMemory Configuration\n\n"));
  fprintf (config.map_file, "%-16s %-18s %-18s %s\n",
	   _("Name"), _("Origin"), _("Length"), _("Attributes"));

  for (m = lang_memory_region_list; m != NULL; m = m->next)
    {
      char buf[100];
      int len;

      fprintf (config.map_file, "%-16s ", m->name_list.name);

      sprintf_vma (buf, m->origin);
      minfo ("0x%s ", buf);
      len = strlen (buf);
      while (len < 16)
	{
	  print_space ();
	  ++len;
	}

      minfo ("0x%V", m->length);
      if (m->flags || m->not_flags)
	{
#ifndef BFD64
	  minfo ("        ");
#endif
	  if (m->flags)
	    {
	      print_space ();
	      lang_map_flags (m->flags);
	    }

	  if (m->not_flags)
	    {
	      minfo (" !");
	      lang_map_flags (m->not_flags);
	    }
	}

      print_nl ();
    }

  fprintf (config.map_file, _("\nLinker script and memory map\n\n"));

  if (! link_info.reduce_memory_overheads)
    {
      obstack_begin (&map_obstack, 1000);
      for (p = link_info.input_bfds; p != (bfd *) NULL; p = p->link_next)
	bfd_map_over_sections (p, init_map_userdata, 0);
      bfd_link_hash_traverse (link_info.hash, sort_def_symbol, 0);
    }
  lang_statement_iteration ++;
  print_statements ();
}

static void
init_map_userdata (bfd *abfd ATTRIBUTE_UNUSED,
		   asection *sec,
		   void *data ATTRIBUTE_UNUSED)
{
  fat_section_userdata_type *new_data
    = ((fat_section_userdata_type *) (stat_alloc
				      (sizeof (fat_section_userdata_type))));

  ASSERT (get_userdata (sec) == NULL);
  get_userdata (sec) = new_data;
  new_data->map_symbol_def_tail = &new_data->map_symbol_def_head;
  new_data->map_symbol_def_count = 0;
}

static bfd_boolean
sort_def_symbol (struct bfd_link_hash_entry *hash_entry,
		 void *info ATTRIBUTE_UNUSED)
{
  if (hash_entry->type == bfd_link_hash_defined
      || hash_entry->type == bfd_link_hash_defweak)
    {
      struct fat_user_section_struct *ud;
      struct map_symbol_def *def;

      ud = (struct fat_user_section_struct *)
	  get_userdata (hash_entry->u.def.section);
      if  (! ud)
	{
	  /* ??? What do we have to do to initialize this beforehand?  */
	  /* The first time we get here is bfd_abs_section...  */
	  init_map_userdata (0, hash_entry->u.def.section, 0);
	  ud = (struct fat_user_section_struct *)
	      get_userdata (hash_entry->u.def.section);
	}
      else if  (!ud->map_symbol_def_tail)
	ud->map_symbol_def_tail = &ud->map_symbol_def_head;

      def = (struct map_symbol_def *) obstack_alloc (&map_obstack, sizeof *def);
      def->entry = hash_entry;
      *(ud->map_symbol_def_tail) = def;
      ud->map_symbol_def_tail = &def->next;
      ud->map_symbol_def_count++;
    }
  return TRUE;
}

/* Initialize an output section.  */

static void
init_os (lang_output_section_statement_type *s, flagword flags)
{
  if (strcmp (s->name, DISCARD_SECTION_NAME) == 0)
    einfo (_("%P%F: Illegal use of `%s' section\n"), DISCARD_SECTION_NAME);

  if (s->constraint != SPECIAL)
    s->bfd_section = bfd_get_section_by_name (link_info.output_bfd, s->name);
  if (s->bfd_section == NULL)
    s->bfd_section = bfd_make_section_anyway_with_flags (link_info.output_bfd,
							 s->name, flags);
  if (s->bfd_section == NULL)
    {
      einfo (_("%P%F: output format %s cannot represent section called %s\n"),
	     link_info.output_bfd->xvec->name, s->name);
    }
  s->bfd_section->output_section = s->bfd_section;
  s->bfd_section->output_offset = 0;

  if (!link_info.reduce_memory_overheads)
    {
      fat_section_userdata_type *new_userdata = (fat_section_userdata_type *)
	stat_alloc (sizeof (fat_section_userdata_type));
      memset (new_userdata, 0, sizeof (fat_section_userdata_type));
      get_userdata (s->bfd_section) = new_userdata;
    }

  /* If there is a base address, make sure that any sections it might
     mention are initialized.  */
  if (s->addr_tree != NULL)
    exp_init_os (s->addr_tree);

  if (s->load_base != NULL)
    exp_init_os (s->load_base);

  /* If supplied an alignment, set it.  */
  if (s->section_alignment != -1)
    s->bfd_section->alignment_power = s->section_alignment;
}

/* Make sure that all output sections mentioned in an expression are
   initialized.  */

static void
exp_init_os (etree_type *exp)
{
  switch (exp->type.node_class)
    {
    case etree_assign:
    case etree_provide:
      exp_init_os (exp->assign.src);
      break;

    case etree_binary:
      exp_init_os (exp->binary.lhs);
      exp_init_os (exp->binary.rhs);
      break;

    case etree_trinary:
      exp_init_os (exp->trinary.cond);
      exp_init_os (exp->trinary.lhs);
      exp_init_os (exp->trinary.rhs);
      break;

    case etree_assert:
      exp_init_os (exp->assert_s.child);
      break;

    case etree_unary:
      exp_init_os (exp->unary.child);
      break;

    case etree_name:
      switch (exp->type.node_code)
	{
	case ADDR:
	case LOADADDR:
	case SIZEOF:
	  {
	    lang_output_section_statement_type *os;

	    os = lang_output_section_find (exp->name.name);
	    if (os != NULL && os->bfd_section == NULL)
	      init_os (os, 0);
	  }
	}
      break;

    default:
      break;
    }
}

static void
section_already_linked (bfd *abfd, asection *sec, void *data)
{
  lang_input_statement_type *entry = (lang_input_statement_type *) data;

  /* If we are only reading symbols from this object, then we want to
     discard all sections.  */
  if (entry->flags.just_syms)
    {
      bfd_link_just_syms (abfd, sec, &link_info);
      return;
    }

  if (!(abfd->flags & DYNAMIC))
    bfd_section_already_linked (abfd, sec, &link_info);
}

/* The wild routines.

   These expand statements like *(.text) and foo.o to a list of
   explicit actions, like foo.o(.text), bar.o(.text) and
   foo.o(.text, .data).  */

/* Add SECTION to the output section OUTPUT.  Do this by creating a
   lang_input_section statement which is placed at PTR.  */

void
lang_add_section (lang_statement_list_type *ptr,
		  asection *section,
		  struct flag_info *sflag_info,
		  lang_output_section_statement_type *output)
{
  flagword flags = section->flags;

  bfd_boolean discard;
  lang_input_section_type *new_section;
  bfd *abfd = link_info.output_bfd;

  /* Discard sections marked with SEC_EXCLUDE.  */
  discard = (flags & SEC_EXCLUDE) != 0;

  /* Discard input sections which are assigned to a section named
     DISCARD_SECTION_NAME.  */
  if (strcmp (output->name, DISCARD_SECTION_NAME) == 0)
    discard = TRUE;

  /* Discard debugging sections if we are stripping debugging
     information.  */
  if ((link_info.strip == strip_debugger || link_info.strip == strip_all)
      && (flags & SEC_DEBUGGING) != 0)
    discard = TRUE;

  if (discard)
    {
      if (section->output_section == NULL)
	{
	  /* This prevents future calls from assigning this section.  */
	  section->output_section = bfd_abs_section_ptr;
	}
      return;
    }

  if (sflag_info)
    {
      bfd_boolean keep;

      keep = bfd_lookup_section_flags (&link_info, sflag_info, section);
      if (!keep)
	return;
    }

  if (section->output_section != NULL)
    return;

  /* We don't copy the SEC_NEVER_LOAD flag from an input section
     to an output section, because we want to be able to include a
     SEC_NEVER_LOAD section in the middle of an otherwise loaded
     section (I don't know why we want to do this, but we do).
     build_link_order in ldwrite.c handles this case by turning
     the embedded SEC_NEVER_LOAD section into a fill.  */
  flags &= ~ SEC_NEVER_LOAD;

  /* If final link, don't copy the SEC_LINK_ONCE flags, they've
     already been processed.  One reason to do this is that on pe
     format targets, .text$foo sections go into .text and it's odd
     to see .text with SEC_LINK_ONCE set.  */

  if (!link_info.relocatable)
    flags &= ~(SEC_LINK_ONCE | SEC_LINK_DUPLICATES | SEC_RELOC);

  switch (output->sectype)
    {
    case normal_section:
    case overlay_section:
      break;
    case noalloc_section:
      flags &= ~SEC_ALLOC;
      break;
    case noload_section:
      flags &= ~SEC_LOAD;
      flags |= SEC_NEVER_LOAD;
      /* Unfortunately GNU ld has managed to evolve two different
	 meanings to NOLOAD in scripts.  ELF gets a .bss style noload,
	 alloc, no contents section.  All others get a noload, noalloc
	 section.  */
      if (bfd_get_flavour (link_info.output_bfd) == bfd_target_elf_flavour)
	flags &= ~SEC_HAS_CONTENTS;
      else
	flags &= ~SEC_ALLOC;
      break;
    }

  if (output->bfd_section == NULL)
    init_os (output, flags);

  /* If SEC_READONLY is not set in the input section, then clear
     it from the output section.  */
  output->bfd_section->flags &= flags | ~SEC_READONLY;

  if (output->bfd_section->linker_has_input)
    {
      /* Only set SEC_READONLY flag on the first input section.  */
      flags &= ~ SEC_READONLY;

      /* Keep SEC_MERGE and SEC_STRINGS only if they are the same.  */
      if ((output->bfd_section->flags & (SEC_MERGE | SEC_STRINGS))
	  != (flags & (SEC_MERGE | SEC_STRINGS))
	  || ((flags & SEC_MERGE) != 0
	      && output->bfd_section->entsize != section->entsize))
	{
	  output->bfd_section->flags &= ~ (SEC_MERGE | SEC_STRINGS);
	  flags &= ~ (SEC_MERGE | SEC_STRINGS);
	}
    }
  output->bfd_section->flags |= flags;

  if (!output->bfd_section->linker_has_input)
    {
      output->bfd_section->linker_has_input = 1;
      /* This must happen after flags have been updated.  The output
	 section may have been created before we saw its first input
	 section, eg. for a data statement.  */
      bfd_init_private_section_data (section->owner, section,
				     link_info.output_bfd,
				     output->bfd_section,
				     &link_info);
      if ((flags & SEC_MERGE) != 0)
	output->bfd_section->entsize = section->entsize;
    }

  if ((flags & SEC_TIC54X_BLOCK) != 0
      && bfd_get_arch (section->owner) == bfd_arch_tic54x)
    {
      /* FIXME: This value should really be obtained from the bfd...  */
      output->block_value = 128;
    }

  if (section->alignment_power > output->bfd_section->alignment_power)
    output->bfd_section->alignment_power = section->alignment_power;

  section->output_section = output->bfd_section;

  if (!link_info.relocatable
      && !stripped_excluded_sections)
    {
      asection *s = output->bfd_section->map_tail.s;
      output->bfd_section->map_tail.s = section;
      section->map_head.s = NULL;
      section->map_tail.s = s;
      if (s != NULL)
	s->map_head.s = section;
      else
	output->bfd_section->map_head.s = section;
    }

  /* Add a section reference to the list.  */
  new_section = new_stat (lang_input_section, ptr);
  new_section->section = section;
}

/* Handle wildcard sorting.  This returns the lang_input_section which
   should follow the one we are going to create for SECTION and FILE,
   based on the sorting requirements of WILD.  It returns NULL if the
   new section should just go at the end of the current list.  */

static lang_statement_union_type *
wild_sort (lang_wild_statement_type *wild,
	   struct wildcard_list *sec,
	   lang_input_statement_type *file,
	   asection *section)
{
  lang_statement_union_type *l;

  if (!wild->filenames_sorted
      && (sec == NULL || sec->spec.sorted == none))
    return NULL;

  for (l = wild->children.head; l != NULL; l = l->header.next)
    {
      lang_input_section_type *ls;

      if (l->header.type != lang_input_section_enum)
	continue;
      ls = &l->input_section;

      /* Sorting by filename takes precedence over sorting by section
	 name.  */

      if (wild->filenames_sorted)
	{
	  const char *fn, *ln;
	  bfd_boolean fa, la;
	  int i;

	  /* The PE support for the .idata section as generated by
	     dlltool assumes that files will be sorted by the name of
	     the archive and then the name of the file within the
	     archive.  */

	  if (file->the_bfd != NULL
	      && bfd_my_archive (file->the_bfd) != NULL)
	    {
	      fn = bfd_get_filename (bfd_my_archive (file->the_bfd));
	      fa = TRUE;
	    }
	  else
	    {
	      fn = file->filename;
	      fa = FALSE;
	    }

	  if (bfd_my_archive (ls->section->owner) != NULL)
	    {
	      ln = bfd_get_filename (bfd_my_archive (ls->section->owner));
	      la = TRUE;
	    }
	  else
	    {
	      ln = ls->section->owner->filename;
	      la = FALSE;
	    }

	  i = filename_cmp (fn, ln);
	  if (i > 0)
	    continue;
	  else if (i < 0)
	    break;

	  if (fa || la)
	    {
	      if (fa)
		fn = file->filename;
	      if (la)
		ln = ls->section->owner->filename;

	      i = filename_cmp (fn, ln);
	      if (i > 0)
		continue;
	      else if (i < 0)
		break;
	    }
	}

      /* Here either the files are not sorted by name, or we are
	 looking at the sections for this file.  */

      if (sec != NULL
	  && sec->spec.sorted != none
	  && sec->spec.sorted != by_none)
	if (compare_section (sec->spec.sorted, section, ls->section) < 0)
	  break;
    }

  return l;
}

/* Expand a wild statement for a particular FILE.  SECTION may be
   NULL, in which case it is a wild card.  */

static void
output_section_callback (lang_wild_statement_type *ptr,
			 struct wildcard_list *sec,
			 asection *section,
			 struct flag_info *sflag_info,
			 lang_input_statement_type *file,
			 void *output)
{
  lang_statement_union_type *before;
  lang_output_section_statement_type *os;

  os = (lang_output_section_statement_type *) output;

  /* Exclude sections that match UNIQUE_SECTION_LIST.  */
  if (unique_section_p (section, os))
    return;

  before = wild_sort (ptr, sec, file, section);

  /* Here BEFORE points to the lang_input_section which
     should follow the one we are about to add.  If BEFORE
     is NULL, then the section should just go at the end
     of the current list.  */

  if (before == NULL)
    lang_add_section (&ptr->children, section, sflag_info, os);
  else
    {
      lang_statement_list_type list;
      lang_statement_union_type **pp;

      lang_list_init (&list);
      lang_add_section (&list, section, sflag_info, os);

      /* If we are discarding the section, LIST.HEAD will
	 be NULL.  */
      if (list.head != NULL)
	{
	  ASSERT (list.head->header.next == NULL);

	  for (pp = &ptr->children.head;
	       *pp != before;
	       pp = &(*pp)->header.next)
	    ASSERT (*pp != NULL);

	  list.head->header.next = *pp;
	  *pp = list.head;
	}
    }
}

/* Check if all sections in a wild statement for a particular FILE
   are readonly.  */

static void
check_section_callback (lang_wild_statement_type *ptr ATTRIBUTE_UNUSED,
			struct wildcard_list *sec ATTRIBUTE_UNUSED,
			asection *section,
			struct flag_info *sflag_info ATTRIBUTE_UNUSED,
			lang_input_statement_type *file ATTRIBUTE_UNUSED,
			void *output)
{
  lang_output_section_statement_type *os;

  os = (lang_output_section_statement_type *) output;

  /* Exclude sections that match UNIQUE_SECTION_LIST.  */
  if (unique_section_p (section, os))
    return;

  if (section->output_section == NULL && (section->flags & SEC_READONLY) == 0)
    os->all_input_readonly = FALSE;
}

/* This is passed a file name which must have been seen already and
   added to the statement tree.  We will see if it has been opened
   already and had its symbols read.  If not then we'll read it.  */

static lang_input_statement_type *
lookup_name (const char *name)
{
  lang_input_statement_type *search;

  for (search = (lang_input_statement_type *) input_file_chain.head;
       search != NULL;
       search = (lang_input_statement_type *) search->next_real_file)
    {
      /* Use the local_sym_name as the name of the file that has
	 already been loaded as filename might have been transformed
	 via the search directory lookup mechanism.  */
      const char *filename = search->local_sym_name;

      if (filename != NULL
	  && filename_cmp (filename, name) == 0)
	break;
    }

  if (search == NULL)
    search = new_afile (name, lang_input_file_is_search_file_enum,
			default_target, FALSE);

  /* If we have already added this file, or this file is not real
     don't add this file.  */
  if (search->flags.loaded || !search->flags.real)
    return search;

  if (! load_symbols (search, NULL))
    return NULL;

  return search;
}

/* Save LIST as a list of libraries whose symbols should not be exported.  */

struct excluded_lib
{
  char *name;
  struct excluded_lib *next;
};
static struct excluded_lib *excluded_libs;

void
add_excluded_libs (const char *list)
{
  const char *p = list, *end;

  while (*p != '\0')
    {
      struct excluded_lib *entry;
      end = strpbrk (p, ",:");
      if (end == NULL)
	end = p + strlen (p);
      entry = (struct excluded_lib *) xmalloc (sizeof (*entry));
      entry->next = excluded_libs;
      entry->name = (char *) xmalloc (end - p + 1);
      memcpy (entry->name, p, end - p);
      entry->name[end - p] = '\0';
      excluded_libs = entry;
      if (*end == '\0')
	break;
      p = end + 1;
    }
}

static void
check_excluded_libs (bfd *abfd)
{
  struct excluded_lib *lib = excluded_libs;

  while (lib)
    {
      int len = strlen (lib->name);
      const char *filename = lbasename (abfd->filename);

      if (strcmp (lib->name, "ALL") == 0)
	{
	  abfd->no_export = TRUE;
	  return;
	}

      if (filename_ncmp (lib->name, filename, len) == 0
	  && (filename[len] == '\0'
	      || (filename[len] == '.' && filename[len + 1] == 'a'
		  && filename[len + 2] == '\0')))
	{
	  abfd->no_export = TRUE;
	  return;
	}

      lib = lib->next;
    }
}

/* Get the symbols for an input file.  */

bfd_boolean
load_symbols (lang_input_statement_type *entry,
	      lang_statement_list_type *place)
{
  char **matching;

  if (entry->flags.loaded)
    return TRUE;

  ldfile_open_file (entry);

  /* Do not process further if the file was missing.  */
  if (entry->flags.missing_file)
    return TRUE;

  if (! bfd_check_format (entry->the_bfd, bfd_archive)
      && ! bfd_check_format_matches (entry->the_bfd, bfd_object, &matching))
    {
      bfd_error_type err;
      struct lang_input_statement_flags save_flags;
      extern FILE *yyin;

      err = bfd_get_error ();

      /* See if the emulation has some special knowledge.  */
      if (ldemul_unrecognized_file (entry))
	return TRUE;

      if (err == bfd_error_file_ambiguously_recognized)
	{
	  char **p;

	  einfo (_("%B: file not recognized: %E\n"), entry->the_bfd);
	  einfo (_("%B: matching formats:"), entry->the_bfd);
	  for (p = matching; *p != NULL; p++)
	    einfo (" %s", *p);
	  einfo ("%F\n");
	}
      else if (err != bfd_error_file_not_recognized
	       || place == NULL)
	einfo (_("%F%B: file not recognized: %E\n"), entry->the_bfd);

      bfd_close (entry->the_bfd);
      entry->the_bfd = NULL;

      /* Try to interpret the file as a linker script.  */
      save_flags = input_flags;
      ldfile_open_command_file (entry->filename);

      push_stat_ptr (place);
      input_flags.add_DT_NEEDED_for_regular
	= entry->flags.add_DT_NEEDED_for_regular;
      input_flags.add_DT_NEEDED_for_dynamic
	= entry->flags.add_DT_NEEDED_for_dynamic;
      input_flags.whole_archive = entry->flags.whole_archive;
      input_flags.dynamic = entry->flags.dynamic;

      ldfile_assumed_script = TRUE;
      parser_input = input_script;
      yyparse ();
      ldfile_assumed_script = FALSE;

      /* missing_file is sticky.  sysrooted will already have been
	 restored when seeing EOF in yyparse, but no harm to restore
	 again.  */
      save_flags.missing_file |= input_flags.missing_file;
      input_flags = save_flags;
      pop_stat_ptr ();
      fclose (yyin);
      yyin = NULL;
      entry->flags.loaded = TRUE;

      return TRUE;
    }

  if (ldemul_recognized_file (entry))
    return TRUE;

  /* We don't call ldlang_add_file for an archive.  Instead, the
     add_symbols entry point will call ldlang_add_file, via the
     add_archive_element callback, for each element of the archive
     which is used.  */
  switch (bfd_get_format (entry->the_bfd))
    {
    default:
      break;

    case bfd_object:
#ifdef ENABLE_PLUGINS
      if (!entry->flags.reload)
#endif
	ldlang_add_file (entry);
      if (trace_files || verbose)
	info_msg ("%I\n", entry);
      break;

    case bfd_archive:
      check_excluded_libs (entry->the_bfd);

      if (entry->flags.whole_archive)
	{
	  bfd *member = NULL;
	  bfd_boolean loaded = TRUE;

	  for (;;)
	    {
	      bfd *subsbfd;
	      member = bfd_openr_next_archived_file (entry->the_bfd, member);

	      if (member == NULL)
		break;

	      if (! bfd_check_format (member, bfd_object))
		{
		  einfo (_("%F%B: member %B in archive is not an object\n"),
			 entry->the_bfd, member);
		  loaded = FALSE;
		}

	      subsbfd = member;
	      if (!(*link_info.callbacks
		    ->add_archive_element) (&link_info, member,
					    "--whole-archive", &subsbfd))
		abort ();

	      /* Potentially, the add_archive_element hook may have set a
		 substitute BFD for us.  */
	      if (!bfd_link_add_symbols (subsbfd, &link_info))
		{
		  einfo (_("%F%B: error adding symbols: %E\n"), member);
		  loaded = FALSE;
		}
	    }

	  entry->flags.loaded = loaded;
	  return loaded;
	}
      break;
    }

  if (bfd_link_add_symbols (entry->the_bfd, &link_info))
    entry->flags.loaded = TRUE;
  else
    einfo (_("%F%B: error adding symbols: %E\n"), entry->the_bfd);

  return entry->flags.loaded;
}

/* Handle a wild statement.  S->FILENAME or S->SECTION_LIST or both
   may be NULL, indicating that it is a wildcard.  Separate
   lang_input_section statements are created for each part of the
   expansion; they are added after the wild statement S.  OUTPUT is
   the output section.  */

static void
wild (lang_wild_statement_type *s,
      const char *target ATTRIBUTE_UNUSED,
      lang_output_section_statement_type *output)
{
  struct wildcard_list *sec;

  if (s->handler_data[0]
      && s->handler_data[0]->spec.sorted == by_name
      && !s->filenames_sorted)
    {
      lang_section_bst_type *tree;

      walk_wild (s, output_section_callback_fast, output);

      tree = s->tree;
      if (tree)
	{
	  output_section_callback_tree_to_list (s, tree, output);
	  s->tree = NULL;
	}
    }
  else
    walk_wild (s, output_section_callback, output);

  if (default_common_section == NULL)
    for (sec = s->section_list; sec != NULL; sec = sec->next)
      if (sec->spec.name != NULL && strcmp (sec->spec.name, "COMMON") == 0)
	{
	  /* Remember the section that common is going to in case we
	     later get something which doesn't know where to put it.  */
	  default_common_section = output;
	  break;
	}
}

/* Return TRUE iff target is the sought target.  */

static int
get_target (const bfd_target *target, void *data)
{
  const char *sought = (const char *) data;

  return strcmp (target->name, sought) == 0;
}

/* Like strcpy() but convert to lower case as well.  */

static void
stricpy (char *dest, char *src)
{
  char c;

  while ((c = *src++) != 0)
    *dest++ = TOLOWER (c);

  *dest = 0;
}

/* Remove the first occurrence of needle (if any) in haystack
   from haystack.  */

static void
strcut (char *haystack, char *needle)
{
  haystack = strstr (haystack, needle);

  if (haystack)
    {
      char *src;

      for (src = haystack + strlen (needle); *src;)
	*haystack++ = *src++;

      *haystack = 0;
    }
}

/* Compare two target format name strings.
   Return a value indicating how "similar" they are.  */

static int
name_compare (char *first, char *second)
{
  char *copy1;
  char *copy2;
  int result;

  copy1 = (char *) xmalloc (strlen (first) + 1);
  copy2 = (char *) xmalloc (strlen (second) + 1);

  /* Convert the names to lower case.  */
  stricpy (copy1, first);
  stricpy (copy2, second);

  /* Remove size and endian strings from the name.  */
  strcut (copy1, "big");
  strcut (copy1, "little");
  strcut (copy2, "big");
  strcut (copy2, "little");

  /* Return a value based on how many characters match,
     starting from the beginning.   If both strings are
     the same then return 10 * their length.  */
  for (result = 0; copy1[result] == copy2[result]; result++)
    if (copy1[result] == 0)
      {
	result *= 10;
	break;
      }

  free (copy1);
  free (copy2);

  return result;
}

/* Set by closest_target_match() below.  */
static const bfd_target *winner;

/* Scan all the valid bfd targets looking for one that has the endianness
   requirement that was specified on the command line, and is the nearest
   match to the original output target.  */

static int
closest_target_match (const bfd_target *target, void *data)
{
  const bfd_target *original = (const bfd_target *) data;

  if (command_line.endian == ENDIAN_BIG
      && target->byteorder != BFD_ENDIAN_BIG)
    return 0;

  if (command_line.endian == ENDIAN_LITTLE
      && target->byteorder != BFD_ENDIAN_LITTLE)
    return 0;

  /* Must be the same flavour.  */
  if (target->flavour != original->flavour)
    return 0;

  /* Ignore generic big and little endian elf vectors.  */
  if (strcmp (target->name, "elf32-big") == 0
      || strcmp (target->name, "elf64-big") == 0
      || strcmp (target->name, "elf32-little") == 0
      || strcmp (target->name, "elf64-little") == 0)
    return 0;

  /* If we have not found a potential winner yet, then record this one.  */
  if (winner == NULL)
    {
      winner = target;
      return 0;
    }

  /* Oh dear, we now have two potential candidates for a successful match.
     Compare their names and choose the better one.  */
  if (name_compare (target->name, original->name)
      > name_compare (winner->name, original->name))
    winner = target;

  /* Keep on searching until wqe have checked them all.  */
  return 0;
}

/* Return the BFD target format of the first input file.  */

static char *
get_first_input_target (void)
{
  char *target = NULL;

  LANG_FOR_EACH_INPUT_STATEMENT (s)
    {
      if (s->header.type == lang_input_statement_enum
	  && s->flags.real)
	{
	  ldfile_open_file (s);

	  if (s->the_bfd != NULL
	      && bfd_check_format (s->the_bfd, bfd_object))
	    {
	      target = bfd_get_target (s->the_bfd);

	      if (target != NULL)
		break;
	    }
	}
    }

  return target;
}

const char *
lang_get_output_target (void)
{
  const char *target;

  /* Has the user told us which output format to use?  */
  if (output_target != NULL)
    return output_target;

  /* No - has the current target been set to something other than
     the default?  */
  if (current_target != default_target && current_target != NULL)
    return current_target;

  /* No - can we determine the format of the first input file?  */
  target = get_first_input_target ();
  if (target != NULL)
    return target;

  /* Failed - use the default output target.  */
  return default_target;
}

/* Open the output file.  */

static void
open_output (const char *name)
{
  output_target = lang_get_output_target ();

  /* Has the user requested a particular endianness on the command
     line?  */
  if (command_line.endian != ENDIAN_UNSET)
    {
      const bfd_target *target;
      enum bfd_endian desired_endian;

      /* Get the chosen target.  */
      target = bfd_search_for_target (get_target, (void *) output_target);

      /* If the target is not supported, we cannot do anything.  */
      if (target != NULL)
	{
	  if (command_line.endian == ENDIAN_BIG)
	    desired_endian = BFD_ENDIAN_BIG;
	  else
	    desired_endian = BFD_ENDIAN_LITTLE;

	  /* See if the target has the wrong endianness.  This should
	     not happen if the linker script has provided big and
	     little endian alternatives, but some scrips don't do
	     this.  */
	  if (target->byteorder != desired_endian)
	    {
	      /* If it does, then see if the target provides
		 an alternative with the correct endianness.  */
	      if (target->alternative_target != NULL
		  && (target->alternative_target->byteorder == desired_endian))
		output_target = target->alternative_target->name;
	      else
		{
		  /* Try to find a target as similar as possible to
		     the default target, but which has the desired
		     endian characteristic.  */
		  bfd_search_for_target (closest_target_match,
					 (void *) target);

		  /* Oh dear - we could not find any targets that
		     satisfy our requirements.  */
		  if (winner == NULL)
		    einfo (_("%P: warning: could not find any targets"
			     " that match endianness requirement\n"));
		  else
		    output_target = winner->name;
		}
	    }
	}
    }

  link_info.output_bfd = bfd_openw (name, output_target);

  if (link_info.output_bfd == NULL)
    {
      if (bfd_get_error () == bfd_error_invalid_target)
	einfo (_("%P%F: target %s not found\n"), output_target);

      einfo (_("%P%F: cannot open output file %s: %E\n"), name);
    }

  delete_output_file_on_failure = TRUE;

  if (! bfd_set_format (link_info.output_bfd, bfd_object))
    einfo (_("%P%F:%s: can not make object file: %E\n"), name);
  if (! bfd_set_arch_mach (link_info.output_bfd,
			   ldfile_output_architecture,
			   ldfile_output_machine))
    einfo (_("%P%F:%s: can not set architecture: %E\n"), name);

  link_info.hash = bfd_link_hash_table_create (link_info.output_bfd);
  if (link_info.hash == NULL)
    einfo (_("%P%F: can not create hash table: %E\n"));

  bfd_set_gp_size (link_info.output_bfd, g_switch_value);
}

static void
ldlang_open_output (lang_statement_union_type *statement)
{
  switch (statement->header.type)
    {
    case lang_output_statement_enum:
      ASSERT (link_info.output_bfd == NULL);
      open_output (statement->output_statement.name);
      ldemul_set_output_arch ();
      if (config.magic_demand_paged && !link_info.relocatable)
	link_info.output_bfd->flags |= D_PAGED;
      else
	link_info.output_bfd->flags &= ~D_PAGED;
      if (config.text_read_only)
	link_info.output_bfd->flags |= WP_TEXT;
      else
	link_info.output_bfd->flags &= ~WP_TEXT;
      if (link_info.traditional_format)
	link_info.output_bfd->flags |= BFD_TRADITIONAL_FORMAT;
      else
	link_info.output_bfd->flags &= ~BFD_TRADITIONAL_FORMAT;
      break;

    case lang_target_statement_enum:
      current_target = statement->target_statement.target;
      break;
    default:
      break;
    }
}

/* Convert between addresses in bytes and sizes in octets.
   For currently supported targets, octets_per_byte is always a power
   of two, so we can use shifts.  */
#define TO_ADDR(X) ((X) >> opb_shift)
#define TO_SIZE(X) ((X) << opb_shift)

/* Support the above.  */
static unsigned int opb_shift = 0;

static void
init_opb (void)
{
  unsigned x = bfd_arch_mach_octets_per_byte (ldfile_output_architecture,
					      ldfile_output_machine);
  opb_shift = 0;
  if (x > 1)
    while ((x & 1) == 0)
      {
	x >>= 1;
	++opb_shift;
      }
  ASSERT (x == 1);
}

/* Open all the input files.  */

enum open_bfd_mode
  {
    OPEN_BFD_NORMAL = 0,
    OPEN_BFD_FORCE = 1,
    OPEN_BFD_RESCAN = 2
  };
#ifdef ENABLE_PLUGINS
static lang_input_statement_type *plugin_insert = NULL;
#endif

static void
open_input_bfds (lang_statement_union_type *s, enum open_bfd_mode mode)
{
  for (; s != NULL; s = s->header.next)
    {
      switch (s->header.type)
	{
	case lang_constructors_statement_enum:
	  open_input_bfds (constructor_list.head, mode);
	  break;
	case lang_output_section_statement_enum:
	  open_input_bfds (s->output_section_statement.children.head, mode);
	  break;
	case lang_wild_statement_enum:
	  /* Maybe we should load the file's symbols.  */
	  if ((mode & OPEN_BFD_RESCAN) == 0
	      && s->wild_statement.filename
	      && !wildcardp (s->wild_statement.filename)
	      && !archive_path (s->wild_statement.filename))
	    lookup_name (s->wild_statement.filename);
	  open_input_bfds (s->wild_statement.children.head, mode);
	  break;
	case lang_group_statement_enum:
	  {
	    struct bfd_link_hash_entry *undefs;

	    /* We must continually search the entries in the group
	       until no new symbols are added to the list of undefined
	       symbols.  */

	    do
	      {
		undefs = link_info.hash->undefs_tail;
		open_input_bfds (s->group_statement.children.head,
				 mode | OPEN_BFD_FORCE);
	      }
	    while (undefs != link_info.hash->undefs_tail);
	  }
	  break;
	case lang_target_statement_enum:
	  current_target = s->target_statement.target;
	  break;
	case lang_input_statement_enum:
	  if (s->input_statement.flags.real)
	    {
	      lang_statement_union_type **os_tail;
	      lang_statement_list_type add;

	      s->input_statement.target = current_target;

	      /* If we are being called from within a group, and this
		 is an archive which has already been searched, then
		 force it to be researched unless the whole archive
		 has been loaded already.  Do the same for a rescan.  */
	      if (mode != OPEN_BFD_NORMAL
#ifdef ENABLE_PLUGINS
		  && ((mode & OPEN_BFD_RESCAN) == 0
		      || plugin_insert == NULL)
#endif
		  && !s->input_statement.flags.whole_archive
		  && s->input_statement.flags.loaded
		  && s->input_statement.the_bfd != NULL
		  && bfd_check_format (s->input_statement.the_bfd,
				       bfd_archive))
		s->input_statement.flags.loaded = FALSE;
#ifdef ENABLE_PLUGINS
	      /* When rescanning, reload --as-needed shared libs.  */
	      else if ((mode & OPEN_BFD_RESCAN) != 0
		       && plugin_insert == NULL
		       && s->input_statement.flags.loaded
		       && s->input_statement.flags.add_DT_NEEDED_for_regular
		       && s->input_statement.the_bfd != NULL
		       && ((s->input_statement.the_bfd->flags) & DYNAMIC) != 0
		       && plugin_should_reload (s->input_statement.the_bfd))
		{
		  s->input_statement.flags.loaded = FALSE;
		  s->input_statement.flags.reload = TRUE;
		}
#endif

	      os_tail = lang_output_section_statement.tail;
	      lang_list_init (&add);

	      if (! load_symbols (&s->input_statement, &add))
		config.make_executable = FALSE;

	      if (add.head != NULL)
		{
		  /* If this was a script with output sections then
		     tack any added statements on to the end of the
		     list.  This avoids having to reorder the output
		     section statement list.  Very likely the user
		     forgot -T, and whatever we do here will not meet
		     naive user expectations.  */
		  if (os_tail != lang_output_section_statement.tail)
		    {
		      einfo (_("%P: warning: %s contains output sections;"
			       " did you forget -T?\n"),
			     s->input_statement.filename);
		      *stat_ptr->tail = add.head;
		      stat_ptr->tail = add.tail;
		    }
		  else
		    {
		      *add.tail = s->header.next;
		      s->header.next = add.head;
		    }
		}
	    }
#ifdef ENABLE_PLUGINS
	  /* If we have found the point at which a plugin added new
	     files, clear plugin_insert to enable archive rescan.  */
	  if (&s->input_statement == plugin_insert)
	    plugin_insert = NULL;
#endif
	  break;
	case lang_assignment_statement_enum:
	  if (s->assignment_statement.exp->assign.defsym)
	    /* This is from a --defsym on the command line.  */
	    exp_fold_tree_no_dot (s->assignment_statement.exp);
	  break;
	default:
	  break;
	}
    }

  /* Exit if any of the files were missing.  */
  if (input_flags.missing_file)
    einfo ("%F");
}

/* Add a symbol to a hash of symbols used in DEFINED (NAME) expressions.  */

void
lang_track_definedness (const char *name)
{
  if (bfd_hash_lookup (&lang_definedness_table, name, TRUE, FALSE) == NULL)
    einfo (_("%P%F: bfd_hash_lookup failed creating symbol %s\n"), name);
}

/* New-function for the definedness hash table.  */

static struct bfd_hash_entry *
lang_definedness_newfunc (struct bfd_hash_entry *entry,
			  struct bfd_hash_table *table ATTRIBUTE_UNUSED,
			  const char *name ATTRIBUTE_UNUSED)
{
  struct lang_definedness_hash_entry *ret
    = (struct lang_definedness_hash_entry *) entry;

  if (ret == NULL)
    ret = (struct lang_definedness_hash_entry *)
      bfd_hash_allocate (table, sizeof (struct lang_definedness_hash_entry));

  if (ret == NULL)
    einfo (_("%P%F: bfd_hash_allocate failed creating symbol %s\n"), name);

  ret->iteration = -1;
  return &ret->root;
}

/* Return the iteration when the definition of NAME was last updated.  A
   value of -1 means that the symbol is not defined in the linker script
   or the command line, but may be defined in the linker symbol table.  */

int
lang_symbol_definition_iteration (const char *name)
{
  struct lang_definedness_hash_entry *defentry
    = (struct lang_definedness_hash_entry *)
    bfd_hash_lookup (&lang_definedness_table, name, FALSE, FALSE);

  /* We've already created this one on the presence of DEFINED in the
     script, so it can't be NULL unless something is borked elsewhere in
     the code.  */
  if (defentry == NULL)
    FAIL ();

  return defentry->iteration;
}

/* Update the definedness state of NAME.  */

void
lang_update_definedness (const char *name, struct bfd_link_hash_entry *h)
{
  struct lang_definedness_hash_entry *defentry
    = (struct lang_definedness_hash_entry *)
    bfd_hash_lookup (&lang_definedness_table, name, FALSE, FALSE);

  /* We don't keep track of symbols not tested with DEFINED.  */
  if (defentry == NULL)
    return;

  /* If the symbol was already defined, and not from an earlier statement
     iteration, don't update the definedness iteration, because that'd
     make the symbol seem defined in the linker script at this point, and
     it wasn't; it was defined in some object.  If we do anyway, DEFINED
     would start to yield false before this point and the construct "sym =
     DEFINED (sym) ? sym : X;" would change sym to X despite being defined
     in an object.  */
  if (h->type != bfd_link_hash_undefined
      && h->type != bfd_link_hash_common
      && h->type != bfd_link_hash_new
      && defentry->iteration == -1)
    return;

  defentry->iteration = lang_statement_iteration;
}

/* Add the supplied name to the symbol table as an undefined reference.
   This is a two step process as the symbol table doesn't even exist at
   the time the ld command line is processed.  First we put the name
   on a list, then, once the output file has been opened, transfer the
   name to the symbol table.  */

typedef struct bfd_sym_chain ldlang_undef_chain_list_type;

#define ldlang_undef_chain_list_head entry_symbol.next

void
ldlang_add_undef (const char *const name, bfd_boolean cmdline)
{
  ldlang_undef_chain_list_type *new_undef;

  undef_from_cmdline = undef_from_cmdline || cmdline;
  new_undef = (ldlang_undef_chain_list_type *) stat_alloc (sizeof (*new_undef));
  new_undef->next = ldlang_undef_chain_list_head;
  ldlang_undef_chain_list_head = new_undef;

  new_undef->name = xstrdup (name);

  if (link_info.output_bfd != NULL)
    insert_undefined (new_undef->name);
}

/* Insert NAME as undefined in the symbol table.  */

static void
insert_undefined (const char *name)
{
  struct bfd_link_hash_entry *h;

  h = bfd_link_hash_lookup (link_info.hash, name, TRUE, FALSE, TRUE);
  if (h == NULL)
    einfo (_("%P%F: bfd_link_hash_lookup failed: %E\n"));
  if (h->type == bfd_link_hash_new)
    {
      h->type = bfd_link_hash_undefined;
      h->u.undef.abfd = NULL;
      bfd_link_add_undef (link_info.hash, h);
    }
}

/* Run through the list of undefineds created above and place them
   into the linker hash table as undefined symbols belonging to the
   script file.  */

static void
lang_place_undefineds (void)
{
  ldlang_undef_chain_list_type *ptr;

  for (ptr = ldlang_undef_chain_list_head; ptr != NULL; ptr = ptr->next)
    insert_undefined (ptr->name);
}

/* Check for all readonly or some readwrite sections.  */

static void
check_input_sections
  (lang_statement_union_type *s,
   lang_output_section_statement_type *output_section_statement)
{
  for (; s != (lang_statement_union_type *) NULL; s = s->header.next)
    {
      switch (s->header.type)
	{
	case lang_wild_statement_enum:
	  walk_wild (&s->wild_statement, check_section_callback,
		     output_section_statement);
	  if (! output_section_statement->all_input_readonly)
	    return;
	  break;
	case lang_constructors_statement_enum:
	  check_input_sections (constructor_list.head,
				output_section_statement);
	  if (! output_section_statement->all_input_readonly)
	    return;
	  break;
	case lang_group_statement_enum:
	  check_input_sections (s->group_statement.children.head,
				output_section_statement);
	  if (! output_section_statement->all_input_readonly)
	    return;
	  break;
	default:
	  break;
	}
    }
}

/* Update wildcard statements if needed.  */

static void
update_wild_statements (lang_statement_union_type *s)
{
  struct wildcard_list *sec;

  switch (sort_section)
    {
    default:
      FAIL ();

    case none:
      break;

    case by_name:
    case by_alignment:
      for (; s != NULL; s = s->header.next)
	{
	  switch (s->header.type)
	    {
	    default:
	      break;

	    case lang_wild_statement_enum:
	      for (sec = s->wild_statement.section_list; sec != NULL;
		   sec = sec->next)
		{
		  switch (sec->spec.sorted)
		    {
		    case none:
		      sec->spec.sorted = sort_section;
		      break;
		    case by_name:
		      if (sort_section == by_alignment)
			sec->spec.sorted = by_name_alignment;
		      break;
		    case by_alignment:
		      if (sort_section == by_name)
			sec->spec.sorted = by_alignment_name;
		      break;
		    default:
		      break;
		    }
		}
	      break;

	    case lang_constructors_statement_enum:
	      update_wild_statements (constructor_list.head);
	      break;

	    case lang_output_section_statement_enum:
	      /* Don't sort .init/.fini sections.  */
	      if (strcmp (s->output_section_statement.name, ".init") != 0
		  && strcmp (s->output_section_statement.name, ".fini") != 0)
		update_wild_statements
		  (s->output_section_statement.children.head);
	      break;

	    case lang_group_statement_enum:
	      update_wild_statements (s->group_statement.children.head);
	      break;
	    }
	}
      break;
    }
}

/* Open input files and attach to output sections.  */

static void
map_input_to_output_sections
  (lang_statement_union_type *s, const char *target,
   lang_output_section_statement_type *os)
{
  for (; s != NULL; s = s->header.next)
    {
      lang_output_section_statement_type *tos;
      flagword flags;

      switch (s->header.type)
	{
	case lang_wild_statement_enum:
	  wild (&s->wild_statement, target, os);
	  break;
	case lang_constructors_statement_enum:
	  map_input_to_output_sections (constructor_list.head,
					target,
					os);
	  break;
	case lang_output_section_statement_enum:
	  tos = &s->output_section_statement;
	  if (tos->constraint != 0)
	    {
	      if (tos->constraint != ONLY_IF_RW
		  && tos->constraint != ONLY_IF_RO)
		break;
	      tos->all_input_readonly = TRUE;
	      check_input_sections (tos->children.head, tos);
	      if (tos->all_input_readonly != (tos->constraint == ONLY_IF_RO))
		{
		  tos->constraint = -1;
		  break;
		}
	    }
	  map_input_to_output_sections (tos->children.head,
					target,
					tos);
	  break;
	case lang_output_statement_enum:
	  break;
	case lang_target_statement_enum:
	  target = s->target_statement.target;
	  break;
	case lang_group_statement_enum:
	  map_input_to_output_sections (s->group_statement.children.head,
					target,
					os);
	  break;
	case lang_data_statement_enum:
	  /* Make sure that any sections mentioned in the expression
	     are initialized.  */
	  exp_init_os (s->data_statement.exp);
	  /* The output section gets CONTENTS, ALLOC and LOAD, but
	     these may be overridden by the script.  */
	  flags = SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD;
	  switch (os->sectype)
	    {
	    case normal_section:
	    case overlay_section:
	      break;
	    case noalloc_section:
	      flags = SEC_HAS_CONTENTS;
	      break;
	    case noload_section:
	      if (bfd_get_flavour (link_info.output_bfd)
		  == bfd_target_elf_flavour)
		flags = SEC_NEVER_LOAD | SEC_ALLOC;
	      else
		flags = SEC_NEVER_LOAD | SEC_HAS_CONTENTS;
	      break;
	    }
	  if (os->bfd_section == NULL)
	    init_os (os, flags);
	  else
	    os->bfd_section->flags |= flags;
	  break;
	case lang_input_section_enum:
	  break;
	case lang_fill_statement_enum:
	case lang_object_symbols_statement_enum:
	case lang_reloc_statement_enum:
	case lang_padding_statement_enum:
	case lang_input_statement_enum:
	  if (os != NULL && os->bfd_section == NULL)
	    init_os (os, 0);
	  break;
	case lang_assignment_statement_enum:
	  if (os != NULL && os->bfd_section == NULL)
	    init_os (os, 0);

	  /* Make sure that any sections mentioned in the assignment
	     are initialized.  */
	  exp_init_os (s->assignment_statement.exp);
	  break;
	case lang_address_statement_enum:
	  /* Mark the specified section with the supplied address.
	     If this section was actually a segment marker, then the
	     directive is ignored if the linker script explicitly
	     processed the segment marker.  Originally, the linker
	     treated segment directives (like -Ttext on the
	     command-line) as section directives.  We honor the
	     section directive semantics for backwards compatibilty;
	     linker scripts that do not specifically check for
	     SEGMENT_START automatically get the old semantics.  */
	  if (!s->address_statement.segment
	      || !s->address_statement.segment->used)
	    {
	      const char *name = s->address_statement.section_name;

	      /* Create the output section statement here so that
		 orphans with a set address will be placed after other
		 script sections.  If we let the orphan placement code
		 place them in amongst other sections then the address
		 will affect following script sections, which is
		 likely to surprise naive users.  */
	      tos = lang_output_section_statement_lookup (name, 0, TRUE);
	      tos->addr_tree = s->address_statement.address;
	      if (tos->bfd_section == NULL)
		init_os (tos, 0);
	    }
	  break;
	case lang_insert_statement_enum:
	  break;
	}
    }
}

/* An insert statement snips out all the linker statements from the
   start of the list and places them after the output section
   statement specified by the insert.  This operation is complicated
   by the fact that we keep a doubly linked list of output section
   statements as well as the singly linked list of all statements.  */

static void
process_insert_statements (void)
{
  lang_statement_union_type **s;
  lang_output_section_statement_type *first_os = NULL;
  lang_output_section_statement_type *last_os = NULL;
  lang_output_section_statement_type *os;

  /* "start of list" is actually the statement immediately after
     the special abs_section output statement, so that it isn't
     reordered.  */
  s = &lang_output_section_statement.head;
  while (*(s = &(*s)->header.next) != NULL)
    {
      if ((*s)->header.type == lang_output_section_statement_enum)
	{
	  /* Keep pointers to the first and last output section
	     statement in the sequence we may be about to move.  */
	  os = &(*s)->output_section_statement;

	  ASSERT (last_os == NULL || last_os->next == os);
	  last_os = os;

	  /* Set constraint negative so that lang_output_section_find
	     won't match this output section statement.  At this
	     stage in linking constraint has values in the range
	     [-1, ONLY_IN_RW].  */
	  last_os->constraint = -2 - last_os->constraint;
	  if (first_os == NULL)
	    first_os = last_os;
	}
      else if ((*s)->header.type == lang_insert_statement_enum)
	{
	  lang_insert_statement_type *i = &(*s)->insert_statement;
	  lang_output_section_statement_type *where;
	  lang_statement_union_type **ptr;
	  lang_statement_union_type *first;

	  where = lang_output_section_find (i->where);
	  if (where != NULL && i->is_before)
	    {
	      do
		where = where->prev;
	      while (where != NULL && where->constraint < 0);
	    }
	  if (where == NULL)
	    {
	      einfo (_("%F%P: %s not found for insert\n"), i->where);
	      return;
	    }

	  /* Deal with reordering the output section statement list.  */
	  if (last_os != NULL)
	    {
	      asection *first_sec, *last_sec;
	      struct lang_output_section_statement_struct **next;

	      /* Snip out the output sections we are moving.  */
	      first_os->prev->next = last_os->next;
	      if (last_os->next == NULL)
		{
		  next = &first_os->prev->next;
		  lang_output_section_statement.tail
		    = (lang_statement_union_type **) next;
		}
	      else
		last_os->next->prev = first_os->prev;
	      /* Add them in at the new position.  */
	      last_os->next = where->next;
	      if (where->next == NULL)
		{
		  next = &last_os->next;
		  lang_output_section_statement.tail
		    = (lang_statement_union_type **) next;
		}
	      else
		where->next->prev = last_os;
	      first_os->prev = where;
	      where->next = first_os;

	      /* Move the bfd sections in the same way.  */
	      first_sec = NULL;
	      last_sec = NULL;
	      for (os = first_os; os != NULL; os = os->next)
		{
		  os->constraint = -2 - os->constraint;
		  if (os->bfd_section != NULL
		      && os->bfd_section->owner != NULL)
		    {
		      last_sec = os->bfd_section;
		      if (first_sec == NULL)
			first_sec = last_sec;
		    }
		  if (os == last_os)
		    break;
		}
	      if (last_sec != NULL)
		{
		  asection *sec = where->bfd_section;
		  if (sec == NULL)
		    sec = output_prev_sec_find (where);

		  /* The place we want to insert must come after the
		     sections we are moving.  So if we find no
		     section or if the section is the same as our
		     last section, then no move is needed.  */
		  if (sec != NULL && sec != last_sec)
		    {
		      /* Trim them off.  */
		      if (first_sec->prev != NULL)
			first_sec->prev->next = last_sec->next;
		      else
			link_info.output_bfd->sections = last_sec->next;
		      if (last_sec->next != NULL)
			last_sec->next->prev = first_sec->prev;
		      else
			link_info.output_bfd->section_last = first_sec->prev;
		      /* Add back.  */
		      last_sec->next = sec->next;
		      if (sec->next != NULL)
			sec->next->prev = last_sec;
		      else
			link_info.output_bfd->section_last = last_sec;
		      first_sec->prev = sec;
		      sec->next = first_sec;
		    }
		}

	      first_os = NULL;
	      last_os = NULL;
	    }

	  ptr = insert_os_after (where);
	  /* Snip everything after the abs_section output statement we
	     know is at the start of the list, up to and including
	     the insert statement we are currently processing.  */
	  first = lang_output_section_statement.head->header.next;
	  lang_output_section_statement.head->header.next = (*s)->header.next;
	  /* Add them back where they belong.  */
	  *s = *ptr;
	  if (*s == NULL)
	    statement_list.tail = s;
	  *ptr = first;
	  s = &lang_output_section_statement.head;
	}
    }

  /* Undo constraint twiddling.  */
  for (os = first_os; os != NULL; os = os->next)
    {
      os->constraint = -2 - os->constraint;
      if (os == last_os)
	break;
    }
}

/* An output section might have been removed after its statement was
   added.  For example, ldemul_before_allocation can remove dynamic
   sections if they turn out to be not needed.  Clean them up here.  */

void
strip_excluded_output_sections (void)
{
  lang_output_section_statement_type *os;

  /* Run lang_size_sections (if not already done).  */
  if (expld.phase != lang_mark_phase_enum)
    {
      expld.phase = lang_mark_phase_enum;
      expld.dataseg.phase = exp_dataseg_none;
      one_lang_size_sections_pass (NULL, FALSE);
      lang_reset_memory_regions ();
    }

  for (os = &lang_output_section_statement.head->output_section_statement;
       os != NULL;
       os = os->next)
    {
      asection *output_section;
      bfd_boolean exclude;

      if (os->constraint < 0)
	continue;

      output_section = os->bfd_section;
      if (output_section == NULL)
	continue;

      exclude = (output_section->rawsize == 0
		 && (output_section->flags & SEC_KEEP) == 0
		 && !bfd_section_removed_from_list (link_info.output_bfd,
						    output_section));

      /* Some sections have not yet been sized, notably .gnu.version,
	 .dynsym, .dynstr and .hash.  These all have SEC_LINKER_CREATED
	 input sections, so don't drop output sections that have such
	 input sections unless they are also marked SEC_EXCLUDE.  */
      if (exclude && output_section->map_head.s != NULL)
	{
	  asection *s;

	  for (s = output_section->map_head.s; s != NULL; s = s->map_head.s)
	    if ((s->flags & SEC_EXCLUDE) == 0
		&& ((s->flags & SEC_LINKER_CREATED) != 0
		    || link_info.emitrelocations))
	      {
		exclude = FALSE;
		break;
	      }
	}

      /* TODO: Don't just junk map_head.s, turn them into link_orders.  */
      output_section->map_head.link_order = NULL;
      output_section->map_tail.link_order = NULL;

      if (exclude)
	{
	  /* We don't set bfd_section to NULL since bfd_section of the
	     removed output section statement may still be used.  */
	  if (!os->update_dot)
	    os->ignored = TRUE;
	  output_section->flags |= SEC_EXCLUDE;
	  bfd_section_list_remove (link_info.output_bfd, output_section);
	  link_info.output_bfd->section_count--;
	}
    }

  /* Stop future calls to lang_add_section from messing with map_head
     and map_tail link_order fields.  */
  stripped_excluded_sections = TRUE;
}

static void
print_output_section_statement
  (lang_output_section_statement_type *output_section_statement)
{
  asection *section = output_section_statement->bfd_section;
  int len;

  if (output_section_statement != abs_output_section)
    {
      minfo ("\n%s", output_section_statement->name);

      if (section != NULL)
	{
	  print_dot = section->vma;

	  len = strlen (output_section_statement->name);
	  if (len >= SECTION_NAME_MAP_LENGTH - 1)
	    {
	      print_nl ();
	      len = 0;
	    }
	  while (len < SECTION_NAME_MAP_LENGTH)
	    {
	      print_space ();
	      ++len;
	    }

	  minfo ("0x%V %W", section->vma, section->size);

	  if (section->vma != section->lma)
	    minfo (_(" load address 0x%V"), section->lma);

	  if (output_section_statement->update_dot_tree != NULL)
	    exp_fold_tree (output_section_statement->update_dot_tree,
			   bfd_abs_section_ptr, &print_dot);
	}

      print_nl ();
    }

  print_statement_list (output_section_statement->children.head,
			output_section_statement);
}

static void
print_assignment (lang_assignment_statement_type *assignment,
		  lang_output_section_statement_type *output_section)
{
  unsigned int i;
  bfd_boolean is_dot;
  etree_type *tree;
  asection *osec;

  for (i = 0; i < SECTION_NAME_MAP_LENGTH; i++)
    print_space ();

  if (assignment->exp->type.node_class == etree_assert)
    {
      is_dot = FALSE;
      tree = assignment->exp->assert_s.child;
    }
  else
    {
      const char *dst = assignment->exp->assign.dst;

      is_dot = (dst[0] == '.' && dst[1] == 0);
      expld.assign_name = dst;
      tree = assignment->exp->assign.src;
    }

  osec = output_section->bfd_section;
  if (osec == NULL)
    osec = bfd_abs_section_ptr;
  exp_fold_tree (tree, osec, &print_dot);
  if (expld.result.valid_p)
    {
      bfd_vma value;

      if (assignment->exp->type.node_class == etree_assert
	  || is_dot
	  || expld.assign_name != NULL)
	{
	  value = expld.result.value;

	  if (expld.result.section != NULL)
	    value += expld.result.section->vma;

	  minfo ("0x%V", value);
	  if (is_dot)
	    print_dot = value;
	}
      else
	{
	  struct bfd_link_hash_entry *h;

	  h = bfd_link_hash_lookup (link_info.hash, assignment->exp->assign.dst,
				    FALSE, FALSE, TRUE);
	  if (h)
	    {
	      value = h->u.def.value;
	      value += h->u.def.section->output_section->vma;
	      value += h->u.def.section->output_offset;

	      minfo ("[0x%V]", value);
	    }
	  else
	    minfo ("[unresolved]");
	}
    }
  else
    {
      minfo ("*undef*   ");
#ifdef BFD64
      minfo ("        ");
#endif
    }
  expld.assign_name = NULL;

  minfo ("                ");
  exp_print_tree (assignment->exp);
  print_nl ();
}

static void
print_input_statement (lang_input_statement_type *statm)
{
  if (statm->filename != NULL
      && (statm->the_bfd == NULL
	  || (statm->the_bfd->flags & BFD_LINKER_CREATED) == 0))
    fprintf (config.map_file, "LOAD %s\n", statm->filename);
}

/* Print all symbols defined in a particular section.  This is called
   via bfd_link_hash_traverse, or by print_all_symbols.  */

static bfd_boolean
print_one_symbol (struct bfd_link_hash_entry *hash_entry, void *ptr)
{
  asection *sec = (asection *) ptr;

  if ((hash_entry->type == bfd_link_hash_defined
       || hash_entry->type == bfd_link_hash_defweak)
      && sec == hash_entry->u.def.section)
    {
      int i;

      for (i = 0; i < SECTION_NAME_MAP_LENGTH; i++)
	print_space ();
      minfo ("0x%V   ",
	     (hash_entry->u.def.value
	      + hash_entry->u.def.section->output_offset
	      + hash_entry->u.def.section->output_section->vma));

      minfo ("             %T\n", hash_entry->root.string);
    }

  return TRUE;
}

static int
hash_entry_addr_cmp (const void *a, const void *b)
{
  const struct bfd_link_hash_entry *l = *(const struct bfd_link_hash_entry **)a;
  const struct bfd_link_hash_entry *r = *(const struct bfd_link_hash_entry **)b;

  if (l->u.def.value < r->u.def.value)
    return -1;
  else if (l->u.def.value > r->u.def.value)
    return 1;
  else
    return 0;
}

static void
print_all_symbols (asection *sec)
{
  struct fat_user_section_struct *ud =
      (struct fat_user_section_struct *) get_userdata (sec);
  struct map_symbol_def *def;
  struct bfd_link_hash_entry **entries;
  unsigned int i;

  if (!ud)
    return;

  *ud->map_symbol_def_tail = 0;

  /* Sort the symbols by address.  */
  entries = (struct bfd_link_hash_entry **)
      obstack_alloc (&map_obstack, ud->map_symbol_def_count * sizeof (*entries));

  for (i = 0, def = ud->map_symbol_def_head; def; def = def->next, i++)
    entries[i] = def->entry;

  qsort (entries, ud->map_symbol_def_count, sizeof (*entries),
	 hash_entry_addr_cmp);

  /* Print the symbols.  */
  for (i = 0; i < ud->map_symbol_def_count; i++)
    print_one_symbol (entries[i], sec);

  obstack_free (&map_obstack, entries);
}

/* Print information about an input section to the map file.  */

static void
print_input_section (asection *i, bfd_boolean is_discarded)
{
  bfd_size_type size = i->size;
  int len;
  bfd_vma addr;

  init_opb ();

  print_space ();
  minfo ("%s", i->name);

  len = 1 + strlen (i->name);
  if (len >= SECTION_NAME_MAP_LENGTH - 1)
    {
      print_nl ();
      len = 0;
    }
  while (len < SECTION_NAME_MAP_LENGTH)
    {
      print_space ();
      ++len;
    }

  if (i->output_section != NULL
      && i->output_section->owner == link_info.output_bfd)
    addr = i->output_section->vma + i->output_offset;
  else
    {
      addr = print_dot;
      if (!is_discarded)
	size = 0;
    }

  minfo ("0x%V %W %B\n", addr, TO_ADDR (size), i->owner);

  if (size != i->rawsize && i->rawsize != 0)
    {
      len = SECTION_NAME_MAP_LENGTH + 3;
#ifdef BFD64
      len += 16;
#else
      len += 8;
#endif
      while (len > 0)
	{
	  print_space ();
	  --len;
	}

      minfo (_("%W (size before relaxing)\n"), i->rawsize);
    }

  if (i->output_section != NULL
      && i->output_section->owner == link_info.output_bfd)
    {
      if (link_info.reduce_memory_overheads)
	bfd_link_hash_traverse (link_info.hash, print_one_symbol, i);
      else
	print_all_symbols (i);

      /* Update print_dot, but make sure that we do not move it
	 backwards - this could happen if we have overlays and a
	 later overlay is shorter than an earier one.  */
      if (addr + TO_ADDR (size) > print_dot)
	print_dot = addr + TO_ADDR (size);
    }
}

static void
print_fill_statement (lang_fill_statement_type *fill)
{
  size_t size;
  unsigned char *p;
  fputs (" FILL mask 0x", config.map_file);
  for (p = fill->fill->data, size = fill->fill->size; size != 0; p++, size--)
    fprintf (config.map_file, "%02x", *p);
  fputs ("\n", config.map_file);
}

static void
print_data_statement (lang_data_statement_type *data)
{
  int i;
  bfd_vma addr;
  bfd_size_type size;
  const char *name;

  init_opb ();
  for (i = 0; i < SECTION_NAME_MAP_LENGTH; i++)
    print_space ();

  addr = data->output_offset;
  if (data->output_section != NULL)
    addr += data->output_section->vma;

  switch (data->type)
    {
    default:
      abort ();
    case BYTE:
      size = BYTE_SIZE;
      name = "BYTE";
      break;
    case SHORT:
      size = SHORT_SIZE;
      name = "SHORT";
      break;
    case LONG:
      size = LONG_SIZE;
      name = "LONG";
      break;
    case QUAD:
      size = QUAD_SIZE;
      name = "QUAD";
      break;
    case SQUAD:
      size = QUAD_SIZE;
      name = "SQUAD";
      break;
    }

  minfo ("0x%V %W %s 0x%v", addr, size, name, data->value);

  if (data->exp->type.node_class != etree_value)
    {
      print_space ();
      exp_print_tree (data->exp);
    }

  print_nl ();

  print_dot = addr + TO_ADDR (size);
}

/* Print an address statement.  These are generated by options like
   -Ttext.  */

static void
print_address_statement (lang_address_statement_type *address)
{
  minfo (_("Address of section %s set to "), address->section_name);
  exp_print_tree (address->address);
  print_nl ();
}

/* Print a reloc statement.  */

static void
print_reloc_statement (lang_reloc_statement_type *reloc)
{
  int i;
  bfd_vma addr;
  bfd_size_type size;

  init_opb ();
  for (i = 0; i < SECTION_NAME_MAP_LENGTH; i++)
    print_space ();

  addr = reloc->output_offset;
  if (reloc->output_section != NULL)
    addr += reloc->output_section->vma;

  size = bfd_get_reloc_size (reloc->howto);

  minfo ("0x%V %W RELOC %s ", addr, size, reloc->howto->name);

  if (reloc->name != NULL)
    minfo ("%s+", reloc->name);
  else
    minfo ("%s+", reloc->section->name);

  exp_print_tree (reloc->addend_exp);

  print_nl ();

  print_dot = addr + TO_ADDR (size);
}

static void
print_padding_statement (lang_padding_statement_type *s)
{
  int len;
  bfd_vma addr;

  init_opb ();
  minfo (" *fill*");

  len = sizeof " *fill*" - 1;
  while (len < SECTION_NAME_MAP_LENGTH)
    {
      print_space ();
      ++len;
    }

  addr = s->output_offset;
  if (s->output_section != NULL)
    addr += s->output_section->vma;
  minfo ("0x%V %W ", addr, (bfd_vma) s->size);

  if (s->fill->size != 0)
    {
      size_t size;
      unsigned char *p;
      for (p = s->fill->data, size = s->fill->size; size != 0; p++, size--)
	fprintf (config.map_file, "%02x", *p);
    }

  print_nl ();

  print_dot = addr + TO_ADDR (s->size);
}

static void
print_wild_statement (lang_wild_statement_type *w,
		      lang_output_section_statement_type *os)
{
  struct wildcard_list *sec;

  print_space ();

  if (w->filenames_sorted)
    minfo ("SORT(");
  if (w->filename != NULL)
    minfo ("%s", w->filename);
  else
    minfo ("*");
  if (w->filenames_sorted)
    minfo (")");

  minfo ("(");
  for (sec = w->section_list; sec; sec = sec->next)
    {
      if (sec->spec.sorted)
	minfo ("SORT(");
      if (sec->spec.exclude_name_list != NULL)
	{
	  name_list *tmp;
	  minfo ("EXCLUDE_FILE(%s", sec->spec.exclude_name_list->name);
	  for (tmp = sec->spec.exclude_name_list->next; tmp; tmp = tmp->next)
	    minfo (" %s", tmp->name);
	  minfo (") ");
	}
      if (sec->spec.name != NULL)
	minfo ("%s", sec->spec.name);
      else
	minfo ("*");
      if (sec->spec.sorted)
	minfo (")");
      if (sec->next)
	minfo (" ");
    }
  minfo (")");

  print_nl ();

  print_statement_list (w->children.head, os);
}

/* Print a group statement.  */

static void
print_group (lang_group_statement_type *s,
	     lang_output_section_statement_type *os)
{
  fprintf (config.map_file, "START GROUP\n");
  print_statement_list (s->children.head, os);
  fprintf (config.map_file, "END GROUP\n");
}

/* Print the list of statements in S.
   This can be called for any statement type.  */

static void
print_statement_list (lang_statement_union_type *s,
		      lang_output_section_statement_type *os)
{
  while (s != NULL)
    {
      print_statement (s, os);
      s = s->header.next;
    }
}

/* Print the first statement in statement list S.
   This can be called for any statement type.  */

static void
print_statement (lang_statement_union_type *s,
		 lang_output_section_statement_type *os)
{
  switch (s->header.type)
    {
    default:
      fprintf (config.map_file, _("Fail with %d\n"), s->header.type);
      FAIL ();
      break;
    case lang_constructors_statement_enum:
      if (constructor_list.head != NULL)
	{
	  if (constructors_sorted)
	    minfo (" SORT (CONSTRUCTORS)\n");
	  else
	    minfo (" CONSTRUCTORS\n");
	  print_statement_list (constructor_list.head, os);
	}
      break;
    case lang_wild_statement_enum:
      print_wild_statement (&s->wild_statement, os);
      break;
    case lang_address_statement_enum:
      print_address_statement (&s->address_statement);
      break;
    case lang_object_symbols_statement_enum:
      minfo (" CREATE_OBJECT_SYMBOLS\n");
      break;
    case lang_fill_statement_enum:
      print_fill_statement (&s->fill_statement);
      break;
    case lang_data_statement_enum:
      print_data_statement (&s->data_statement);
      break;
    case lang_reloc_statement_enum:
      print_reloc_statement (&s->reloc_statement);
      break;
    case lang_input_section_enum:
      print_input_section (s->input_section.section, FALSE);
      break;
    case lang_padding_statement_enum:
      print_padding_statement (&s->padding_statement);
      break;
    case lang_output_section_statement_enum:
      print_output_section_statement (&s->output_section_statement);
      break;
    case lang_assignment_statement_enum:
      print_assignment (&s->assignment_statement, os);
      break;
    case lang_target_statement_enum:
      fprintf (config.map_file, "TARGET(%s)\n", s->target_statement.target);
      break;
    case lang_output_statement_enum:
      minfo ("OUTPUT(%s", s->output_statement.name);
      if (output_target != NULL)
	minfo (" %s", output_target);
      minfo (")\n");
      break;
    case lang_input_statement_enum:
      print_input_statement (&s->input_statement);
      break;
    case lang_group_statement_enum:
      print_group (&s->group_statement, os);
      break;
    case lang_insert_statement_enum:
      minfo ("INSERT %s %s\n",
	     s->insert_statement.is_before ? "BEFORE" : "AFTER",
	     s->insert_statement.where);
      break;
    }
}

static void
print_statements (void)
{
  print_statement_list (statement_list.head, abs_output_section);
}

/* Print the first N statements in statement list S to STDERR.
   If N == 0, nothing is printed.
   If N < 0, the entire list is printed.
   Intended to be called from GDB.  */

void
dprint_statement (lang_statement_union_type *s, int n)
{
  FILE *map_save = config.map_file;

  config.map_file = stderr;

  if (n < 0)
    print_statement_list (s, abs_output_section);
  else
    {
      while (s && --n >= 0)
	{
	  print_statement (s, abs_output_section);
	  s = s->header.next;
	}
    }

  config.map_file = map_save;
}

static void
insert_pad (lang_statement_union_type **ptr,
	    fill_type *fill,
	    bfd_size_type alignment_needed,
	    asection *output_section,
	    bfd_vma dot)
{
  static fill_type zero_fill;
  lang_statement_union_type *pad = NULL;

  if (ptr != &statement_list.head)
    pad = ((lang_statement_union_type *)
	   ((char *) ptr - offsetof (lang_statement_union_type, header.next)));
  if (pad != NULL
      && pad->header.type == lang_padding_statement_enum
      && pad->padding_statement.output_section == output_section)
    {
      /* Use the existing pad statement.  */
    }
  else if ((pad = *ptr) != NULL
	   && pad->header.type == lang_padding_statement_enum
	   && pad->padding_statement.output_section == output_section)
    {
      /* Use the existing pad statement.  */
    }
  else
    {
      /* Make a new padding statement, linked into existing chain.  */
      pad = (lang_statement_union_type *)
	  stat_alloc (sizeof (lang_padding_statement_type));
      pad->header.next = *ptr;
      *ptr = pad;
      pad->header.type = lang_padding_statement_enum;
      pad->padding_statement.output_section = output_section;
      if (fill == NULL)
	fill = &zero_fill;
      pad->padding_statement.fill = fill;
    }
  pad->padding_statement.output_offset = dot - output_section->vma;
  pad->padding_statement.size = alignment_needed;
  output_section->size = TO_SIZE (dot + TO_ADDR (alignment_needed)
				  - output_section->vma);
}

/* Work out how much this section will move the dot point.  */

static bfd_vma
size_input_section
  (lang_statement_union_type **this_ptr,
   lang_output_section_statement_type *output_section_statement,
   fill_type *fill,
   bfd_vma dot)
{
  lang_input_section_type *is = &((*this_ptr)->input_section);
  asection *i = is->section;

  if (i->sec_info_type != SEC_INFO_TYPE_JUST_SYMS
      && (i->flags & SEC_EXCLUDE) == 0)
    {
      bfd_size_type alignment_needed;
      asection *o;

      /* Align this section first to the input sections requirement,
	 then to the output section's requirement.  If this alignment
	 is greater than any seen before, then record it too.  Perform
	 the alignment by inserting a magic 'padding' statement.  */

      if (output_section_statement->subsection_alignment != -1)
	i->alignment_power = output_section_statement->subsection_alignment;

      o = output_section_statement->bfd_section;
      if (o->alignment_power < i->alignment_power)
	o->alignment_power = i->alignment_power;

      alignment_needed = align_power (dot, i->alignment_power) - dot;

      if (alignment_needed != 0)
	{
	  insert_pad (this_ptr, fill, TO_SIZE (alignment_needed), o, dot);
	  dot += alignment_needed;
	}

      /* Remember where in the output section this input section goes.  */

      i->output_offset = dot - o->vma;

      /* Mark how big the output section must be to contain this now.  */
      dot += TO_ADDR (i->size);
      o->size = TO_SIZE (dot - o->vma);
    }
  else
    {
      i->output_offset = i->vma - output_section_statement->bfd_section->vma;
    }

  return dot;
}

static int
sort_sections_by_lma (const void *arg1, const void *arg2)
{
  const asection *sec1 = *(const asection **) arg1;
  const asection *sec2 = *(const asection **) arg2;

  if (bfd_section_lma (sec1->owner, sec1)
      < bfd_section_lma (sec2->owner, sec2))
    return -1;
  else if (bfd_section_lma (sec1->owner, sec1)
	   > bfd_section_lma (sec2->owner, sec2))
    return 1;
  else if (sec1->id < sec2->id)
    return -1;
  else if (sec1->id > sec2->id)
    return 1;

  return 0;
}

#define IGNORE_SECTION(s) \
  ((s->flags & SEC_ALLOC) == 0				\
   || ((s->flags & SEC_THREAD_LOCAL) != 0		\
	&& (s->flags & SEC_LOAD) == 0))

/* Check to see if any allocated sections overlap with other allocated
   sections.  This can happen if a linker script specifies the output
   section addresses of the two sections.  Also check whether any memory
   region has overflowed.  */

static void
lang_check_section_addresses (void)
{
  asection *s, *p;
  asection **sections, **spp;
  unsigned int count;
  bfd_vma s_start;
  bfd_vma s_end;
  bfd_vma p_start;
  bfd_vma p_end;
  bfd_size_type amt;
  lang_memory_region_type *m;

  if (bfd_count_sections (link_info.output_bfd) <= 1)
    return;

  amt = bfd_count_sections (link_info.output_bfd) * sizeof (asection *);
  sections = (asection **) xmalloc (amt);

  /* Scan all sections in the output list.  */
  count = 0;
  for (s = link_info.output_bfd->sections; s != NULL; s = s->next)
    {
      /* Only consider loadable sections with real contents.  */
      if (!(s->flags & SEC_LOAD)
	  || !(s->flags & SEC_ALLOC)
	  || s->size == 0)
	continue;

      sections[count] = s;
      count++;
    }

  if (count <= 1)
    return;

  qsort (sections, (size_t) count, sizeof (asection *),
	 sort_sections_by_lma);

  spp = sections;
  s = *spp++;
  s_start = s->lma;
  s_end = s_start + TO_ADDR (s->size) - 1;
  for (count--; count; count--)
    {
      /* We must check the sections' LMA addresses not their VMA
	 addresses because overlay sections can have overlapping VMAs
	 but they must have distinct LMAs.  */
      p = s;
      p_start = s_start;
      p_end = s_end;
      s = *spp++;
      s_start = s->lma;
      s_end = s_start + TO_ADDR (s->size) - 1;

      /* Look for an overlap.  We have sorted sections by lma, so we
	 know that s_start >= p_start.  Besides the obvious case of
	 overlap when the current section starts before the previous
	 one ends, we also must have overlap if the previous section
	 wraps around the address space.  */
      if (s_start <= p_end
	  || p_end < p_start)
	einfo (_("%X%P: section %s loaded at [%V,%V] overlaps section %s loaded at [%V,%V]\n"),
	       s->name, s_start, s_end, p->name, p_start, p_end);
    }

  free (sections);

  /* If any memory region has overflowed, report by how much.
     We do not issue this diagnostic for regions that had sections
     explicitly placed outside their bounds; os_region_check's
     diagnostics are adequate for that case.

     FIXME: It is conceivable that m->current - (m->origin + m->length)
     might overflow a 32-bit integer.  There is, alas, no way to print
     a bfd_vma quantity in decimal.  */
  for (m = lang_memory_region_list; m; m = m->next)
    if (m->had_full_message)
      einfo (_("%X%P: region `%s' overflowed by %ld bytes\n"),
	     m->name_list.name, (long)(m->current - (m->origin + m->length)));

}

/* Make sure the new address is within the region.  We explicitly permit the
   current address to be at the exact end of the region when the address is
   non-zero, in case the region is at the end of addressable memory and the
   calculation wraps around.  */

static void
os_region_check (lang_output_section_statement_type *os,
		 lang_memory_region_type *region,
		 etree_type *tree,
		 bfd_vma rbase)
{
  if ((region->current < region->origin
       || (region->current - region->origin > region->length))
      && ((region->current != region->origin + region->length)
	  || rbase == 0))
    {
      if (tree != NULL)
	{
	  einfo (_("%X%P: address 0x%v of %B section `%s'"
		   " is not within region `%s'\n"),
		 region->current,
		 os->bfd_section->owner,
		 os->bfd_section->name,
		 region->name_list.name);
	}
      else if (!region->had_full_message)
	{
	  region->had_full_message = TRUE;

	  einfo (_("%X%P: %B section `%s' will not fit in region `%s'\n"),
		 os->bfd_section->owner,
		 os->bfd_section->name,
		 region->name_list.name);
	}
    }
}

/* Set the sizes for all the output sections.  */

static bfd_vma
lang_size_sections_1
  (lang_statement_union_type **prev,
   lang_output_section_statement_type *output_section_statement,
   fill_type *fill,
   bfd_vma dot,
   bfd_boolean *relax,
   bfd_boolean check_regions)
{
  lang_statement_union_type *s;

  /* Size up the sections from their constituent parts.  */
  for (s = *prev; s != NULL; s = s->header.next)
    {
      switch (s->header.type)
	{
	case lang_output_section_statement_enum:
	  {
	    bfd_vma newdot, after;
	    lang_output_section_statement_type *os;
	    lang_memory_region_type *r;
	    int section_alignment = 0;

	    os = &s->output_section_statement;
	    if (os->constraint == -1)
	      break;

	    /* FIXME: We shouldn't need to zero section vmas for ld -r
	       here, in lang_insert_orphan, or in the default linker scripts.
	       This is covering for coff backend linker bugs.  See PR6945.  */
	    if (os->addr_tree == NULL
		&& link_info.relocatable
		&& (bfd_get_flavour (link_info.output_bfd)
		    == bfd_target_coff_flavour))
	      os->addr_tree = exp_intop (0);
	    if (os->addr_tree != NULL)
	      {
		os->processed_vma = FALSE;
		exp_fold_tree (os->addr_tree, bfd_abs_section_ptr, &dot);

		if (expld.result.valid_p)
		  {
		    dot = expld.result.value;
		    if (expld.result.section != NULL)
		      dot += expld.result.section->vma;
		  }
		else if (expld.phase != lang_mark_phase_enum)
		  einfo (_("%F%S: non constant or forward reference"
			   " address expression for section %s\n"),
			 os->addr_tree, os->name);
	      }

	    if (os->bfd_section == NULL)
	      /* This section was removed or never actually created.  */
	      break;

	    /* If this is a COFF shared library section, use the size and
	       address from the input section.  FIXME: This is COFF
	       specific; it would be cleaner if there were some other way
	       to do this, but nothing simple comes to mind.  */
	    if (((bfd_get_flavour (link_info.output_bfd)
		  == bfd_target_ecoff_flavour)
		 || (bfd_get_flavour (link_info.output_bfd)
		     == bfd_target_coff_flavour))
		&& (os->bfd_section->flags & SEC_COFF_SHARED_LIBRARY) != 0)
	      {
		asection *input;

		if (os->children.head == NULL
		    || os->children.head->header.next != NULL
		    || (os->children.head->header.type
			!= lang_input_section_enum))
		  einfo (_("%P%X: Internal error on COFF shared library"
			   " section %s\n"), os->name);

		input = os->children.head->input_section.section;
		bfd_set_section_vma (os->bfd_section->owner,
				     os->bfd_section,
				     bfd_section_vma (input->owner, input));
		os->bfd_section->size = input->size;
		break;
	      }

	    newdot = dot;
	    if (bfd_is_abs_section (os->bfd_section))
	      {
		/* No matter what happens, an abs section starts at zero.  */
		ASSERT (os->bfd_section->vma == 0);
	      }
	    else
	      {
		if (os->addr_tree == NULL)
		  {
		    /* No address specified for this section, get one
		       from the region specification.  */
		    if (os->region == NULL
			|| ((os->bfd_section->flags & (SEC_ALLOC | SEC_LOAD))
			    && os->region->name_list.name[0] == '*'
			    && strcmp (os->region->name_list.name,
				       DEFAULT_MEMORY_REGION) == 0))
		      {
			os->region = lang_memory_default (os->bfd_section);
		      }

		    /* If a loadable section is using the default memory
		       region, and some non default memory regions were
		       defined, issue an error message.  */
		    if (!os->ignored
			&& !IGNORE_SECTION (os->bfd_section)
			&& ! link_info.relocatable
			&& check_regions
			&& strcmp (os->region->name_list.name,
				   DEFAULT_MEMORY_REGION) == 0
			&& lang_memory_region_list != NULL
			&& (strcmp (lang_memory_region_list->name_list.name,
				    DEFAULT_MEMORY_REGION) != 0
			    || lang_memory_region_list->next != NULL)
			&& expld.phase != lang_mark_phase_enum)
		      {
			/* By default this is an error rather than just a
			   warning because if we allocate the section to the
			   default memory region we can end up creating an
			   excessively large binary, or even seg faulting when
			   attempting to perform a negative seek.  See
			   sources.redhat.com/ml/binutils/2003-04/msg00423.html
			   for an example of this.  This behaviour can be
			   overridden by the using the --no-check-sections
			   switch.  */
			if (command_line.check_section_addresses)
			  einfo (_("%P%F: error: no memory region specified"
				   " for loadable section `%s'\n"),
				 bfd_get_section_name (link_info.output_bfd,
						       os->bfd_section));
			else
			  einfo (_("%P: warning: no memory region specified"
				   " for loadable section `%s'\n"),
				 bfd_get_section_name (link_info.output_bfd,
						       os->bfd_section));
		      }

		    newdot = os->region->current;
		    section_alignment = os->bfd_section->alignment_power;
		  }
		else
		  section_alignment = os->section_alignment;

		/* Align to what the section needs.  */
		if (section_alignment > 0)
		  {
		    bfd_vma savedot = newdot;
		    newdot = align_power (newdot, section_alignment);

		    if (newdot != savedot
			&& (config.warn_section_align
			    || os->addr_tree != NULL)
			&& expld.phase != lang_mark_phase_enum)
		      einfo (_("%P: warning: changing start of section"
			       " %s by %lu bytes\n"),
			     os->name, (unsigned long) (newdot - savedot));
		  }

		bfd_set_section_vma (0, os->bfd_section, newdot);

		os->bfd_section->output_offset = 0;
	      }

	    lang_size_sections_1 (&os->children.head, os,
				  os->fill, newdot, relax, check_regions);

	    os->processed_vma = TRUE;

	    if (bfd_is_abs_section (os->bfd_section) || os->ignored)
	      /* Except for some special linker created sections,
		 no output section should change from zero size
		 after strip_excluded_output_sections.  A non-zero
		 size on an ignored section indicates that some
		 input section was not sized early enough.  */
	      ASSERT (os->bfd_section->size == 0);
	    else
	      {
		dot = os->bfd_section->vma;

		/* Put the section within the requested block size, or
		   align at the block boundary.  */
		after = ((dot
			  + TO_ADDR (os->bfd_section->size)
			  + os->block_value - 1)
			 & - (bfd_vma) os->block_value);

		os->bfd_section->size = TO_SIZE (after - os->bfd_section->vma);
	      }

	    /* Set section lma.  */
	    r = os->region;
	    if (r == NULL)
	      r = lang_memory_region_lookup (DEFAULT_MEMORY_REGION, FALSE);

	    if (os->load_base)
	      {
		bfd_vma lma = exp_get_abs_int (os->load_base, 0, "load base");
		os->bfd_section->lma = lma;
	      }
	    else if (os->lma_region != NULL)
	      {
		bfd_vma lma = os->lma_region->current;

		/* When LMA_REGION is the same as REGION, align the LMA
		   as we did for the VMA, possibly including alignment
		   from the bfd section.  If a different region, then
		   only align according to the value in the output
		   statement unless specified otherwise.  */
		if (os->lma_region != os->region && !os->align_lma_with_input)
		  section_alignment = os->section_alignment;
		if (section_alignment > 0)
		  lma = align_power (lma, section_alignment);
		os->bfd_section->lma = lma;
	      }
	    else if (r->last_os != NULL
		     && (os->bfd_section->flags & SEC_ALLOC) != 0)
	      {
		bfd_vma lma;
		asection *last;

		last = r->last_os->output_section_statement.bfd_section;

		/* A backwards move of dot should be accompanied by
		   an explicit assignment to the section LMA (ie.
		   os->load_base set) because backwards moves can
		   create overlapping LMAs.  */
		if (dot < last->vma
		    && os->bfd_section->size != 0
		    && dot + os->bfd_section->size <= last->vma)
		  {
		    /* If dot moved backwards then leave lma equal to
		       vma.  This is the old default lma, which might
		       just happen to work when the backwards move is
		       sufficiently large.  Nag if this changes anything,
		       so people can fix their linker scripts.  */

		    if (last->vma != last->lma)
		      einfo (_("%P: warning: dot moved backwards before `%s'\n"),
			     os->name);
		  }
		else
		  {
		    /* If this is an overlay, set the current lma to that
		       at the end of the previous section.  */
		    if (os->sectype == overlay_section)
		      lma = last->lma + last->size;

		    /* Otherwise, keep the same lma to vma relationship
		       as the previous section.  */
		    else
		      lma = dot + last->lma - last->vma;

		    if (section_alignment > 0)
		      lma = align_power (lma, section_alignment);
		    os->bfd_section->lma = lma;
		  }
	      }
	    os->processed_lma = TRUE;

	    if (bfd_is_abs_section (os->bfd_section) || os->ignored)
	      break;

	    /* Keep track of normal sections using the default
	       lma region.  We use this to set the lma for
	       following sections.  Overlays or other linker
	       script assignment to lma might mean that the
	       default lma == vma is incorrect.
	       To avoid warnings about dot moving backwards when using
	       -Ttext, don't start tracking sections until we find one
	       of non-zero size or with lma set differently to vma.  */
	    if (((os->bfd_section->flags & SEC_HAS_CONTENTS) != 0
		 || (os->bfd_section->flags & SEC_THREAD_LOCAL) == 0)
		&& (os->bfd_section->flags & SEC_ALLOC) != 0
		&& (os->bfd_section->size != 0
		    || (r->last_os == NULL
			&& os->bfd_section->vma != os->bfd_section->lma)
		    || (r->last_os != NULL
			&& dot >= (r->last_os->output_section_statement
				   .bfd_section->vma)))
		&& os->lma_region == NULL
		&& !link_info.relocatable)
	      r->last_os = s;

	    /* .tbss sections effectively have zero size.  */
	    if ((os->bfd_section->flags & SEC_HAS_CONTENTS) != 0
		|| (os->bfd_section->flags & SEC_THREAD_LOCAL) == 0
		|| link_info.relocatable)
	      dot += TO_ADDR (os->bfd_section->size);

	    if (os->update_dot_tree != 0)
	      exp_fold_tree (os->update_dot_tree, bfd_abs_section_ptr, &dot);

	    /* Update dot in the region ?
	       We only do this if the section is going to be allocated,
	       since unallocated sections do not contribute to the region's
	       overall size in memory.  */
	    if (os->region != NULL
		&& (os->bfd_section->flags & (SEC_ALLOC | SEC_LOAD)))
	      {
		os->region->current = dot;

		if (check_regions)
		  /* Make sure the new address is within the region.  */
		  os_region_check (os, os->region, os->addr_tree,
				   os->bfd_section->vma);

		if (os->lma_region != NULL && os->lma_region != os->region
		    && (os->bfd_section->flags & SEC_LOAD))
		  {
		    os->lma_region->current
		      = os->bfd_section->lma + TO_ADDR (os->bfd_section->size);

		    if (check_regions)
		      os_region_check (os, os->lma_region, NULL,
				       os->bfd_section->lma);
		  }
	      }
	  }
	  break;

	case lang_constructors_statement_enum:
	  dot = lang_size_sections_1 (&constructor_list.head,
				      output_section_statement,
				      fill, dot, relax, check_regions);
	  break;

	case lang_data_statement_enum:
	  {
	    unsigned int size = 0;

	    s->data_statement.output_offset =
	      dot - output_section_statement->bfd_section->vma;
	    s->data_statement.output_section =
	      output_section_statement->bfd_section;

	    /* We might refer to provided symbols in the expression, and
	       need to mark them as needed.  */
	    exp_fold_tree (s->data_statement.exp, bfd_abs_section_ptr, &dot);

	    switch (s->data_statement.type)
	      {
	      default:
		abort ();
	      case QUAD:
	      case SQUAD:
		size = QUAD_SIZE;
		break;
	      case LONG:
		size = LONG_SIZE;
		break;
	      case SHORT:
		size = SHORT_SIZE;
		break;
	      case BYTE:
		size = BYTE_SIZE;
		break;
	      }
	    if (size < TO_SIZE ((unsigned) 1))
	      size = TO_SIZE ((unsigned) 1);
	    dot += TO_ADDR (size);
	    output_section_statement->bfd_section->size
	      = TO_SIZE (dot - output_section_statement->bfd_section->vma);

	  }
	  break;

	case lang_reloc_statement_enum:
	  {
	    int size;

	    s->reloc_statement.output_offset =
	      dot - output_section_statement->bfd_section->vma;
	    s->reloc_statement.output_section =
	      output_section_statement->bfd_section;
	    size = bfd_get_reloc_size (s->reloc_statement.howto);
	    dot += TO_ADDR (size);
	    output_section_statement->bfd_section->size
	      = TO_SIZE (dot - output_section_statement->bfd_section->vma);
	  }
	  break;

	case lang_wild_statement_enum:
	  dot = lang_size_sections_1 (&s->wild_statement.children.head,
				      output_section_statement,
				      fill, dot, relax, check_regions);
	  break;

	case lang_object_symbols_statement_enum:
	  link_info.create_object_symbols_section =
	    output_section_statement->bfd_section;
	  break;

	case lang_output_statement_enum:
	case lang_target_statement_enum:
	  break;

	case lang_input_section_enum:
	  {
	    asection *i;

	    i = s->input_section.section;
	    if (relax)
	      {
		bfd_boolean again;

		if (! bfd_relax_section (i->owner, i, &link_info, &again))
		  einfo (_("%P%F: can't relax section: %E\n"));
		if (again)
		  *relax = TRUE;
	      }
	    dot = size_input_section (prev, output_section_statement,
				      output_section_statement->fill, dot);
	  }
	  break;

	case lang_input_statement_enum:
	  break;

	case lang_fill_statement_enum:
	  s->fill_statement.output_section =
	    output_section_statement->bfd_section;

	  fill = s->fill_statement.fill;
	  break;

	case lang_assignment_statement_enum:
	  {
	    bfd_vma newdot = dot;
	    etree_type *tree = s->assignment_statement.exp;

	    expld.dataseg.relro = exp_dataseg_relro_none;

	    exp_fold_tree (tree,
			   output_section_statement->bfd_section,
			   &newdot);

	    if (expld.dataseg.relro == exp_dataseg_relro_start)
	      {
		if (!expld.dataseg.relro_start_stat)
		  expld.dataseg.relro_start_stat = s;
		else
		  {
		    ASSERT (expld.dataseg.relro_start_stat == s);
		  }
	      }
	    else if (expld.dataseg.relro == exp_dataseg_relro_end)
	      {
		if (!expld.dataseg.relro_end_stat)
		  expld.dataseg.relro_end_stat = s;
		else
		  {
		    ASSERT (expld.dataseg.relro_end_stat == s);
		  }
	      }
	    expld.dataseg.relro = exp_dataseg_relro_none;

	    /* This symbol may be relative to this section.  */
	    if ((tree->type.node_class == etree_provided
		 || tree->type.node_class == etree_assign)
		&& (tree->assign.dst [0] != '.'
		    || tree->assign.dst [1] != '\0'))
	      output_section_statement->update_dot = 1;

	    if (!output_section_statement->ignored)
	      {
		if (output_section_statement == abs_output_section)
		  {
		    /* If we don't have an output section, then just adjust
		       the default memory address.  */
		    lang_memory_region_lookup (DEFAULT_MEMORY_REGION,
					       FALSE)->current = newdot;
		  }
		else if (newdot != dot)
		  {
		    /* Insert a pad after this statement.  We can't
		       put the pad before when relaxing, in case the
		       assignment references dot.  */
		    insert_pad (&s->header.next, fill, TO_SIZE (newdot - dot),
				output_section_statement->bfd_section, dot);

		    /* Don't neuter the pad below when relaxing.  */
		    s = s->header.next;

		    /* If dot is advanced, this implies that the section
		       should have space allocated to it, unless the
		       user has explicitly stated that the section
		       should not be allocated.  */
		    if (output_section_statement->sectype != noalloc_section
			&& (output_section_statement->sectype != noload_section
			    || (bfd_get_flavour (link_info.output_bfd)
				== bfd_target_elf_flavour)))
		      output_section_statement->bfd_section->flags |= SEC_ALLOC;
		  }
		dot = newdot;
	      }
	  }
	  break;

	case lang_padding_statement_enum:
	  /* If this is the first time lang_size_sections is called,
	     we won't have any padding statements.  If this is the
	     second or later passes when relaxing, we should allow
	     padding to shrink.  If padding is needed on this pass, it
	     will be added back in.  */
	  s->padding_statement.size = 0;

	  /* Make sure output_offset is valid.  If relaxation shrinks
	     the section and this pad isn't needed, it's possible to
	     have output_offset larger than the final size of the
	     section.  bfd_set_section_contents will complain even for
	     a pad size of zero.  */
	  s->padding_statement.output_offset
	    = dot - output_section_statement->bfd_section->vma;
	  break;

	case lang_group_statement_enum:
	  dot = lang_size_sections_1 (&s->group_statement.children.head,
				      output_section_statement,
				      fill, dot, relax, check_regions);
	  break;

	case lang_insert_statement_enum:
	  break;

	  /* We can only get here when relaxing is turned on.  */
	case lang_address_statement_enum:
	  break;

	default:
	  FAIL ();
	  break;
	}
      prev = &s->header.next;
    }
  return dot;
}

/* Callback routine that is used in _bfd_elf_map_sections_to_segments.
   The BFD library has set NEW_SEGMENT to TRUE iff it thinks that
   CURRENT_SECTION and PREVIOUS_SECTION ought to be placed into different
   segments.  We are allowed an opportunity to override this decision.  */

bfd_boolean
ldlang_override_segment_assignment (struct bfd_link_info * info ATTRIBUTE_UNUSED,
				    bfd * abfd ATTRIBUTE_UNUSED,
				    asection * current_section,
				    asection * previous_section,
				    bfd_boolean new_segment)
{
  lang_output_section_statement_type * cur;
  lang_output_section_statement_type * prev;

  /* The checks below are only necessary when the BFD library has decided
     that the two sections ought to be placed into the same segment.  */
  if (new_segment)
    return TRUE;

  /* Paranoia checks.  */
  if (current_section == NULL || previous_section == NULL)
    return new_segment;

  /* If this flag is set, the target never wants code and non-code
     sections comingled in the same segment.  */
  if (config.separate_code
      && ((current_section->flags ^ previous_section->flags) & SEC_CODE))
    return TRUE;

  /* Find the memory regions associated with the two sections.
     We call lang_output_section_find() here rather than scanning the list
     of output sections looking for a matching section pointer because if
     we have a large number of sections then a hash lookup is faster.  */
  cur  = lang_output_section_find (current_section->name);
  prev = lang_output_section_find (previous_section->name);

  /* More paranoia.  */
  if (cur == NULL || prev == NULL)
    return new_segment;

  /* If the regions are different then force the sections to live in
     different segments.  See the email thread starting at the following
     URL for the reasons why this is necessary:
     http://sourceware.org/ml/binutils/2007-02/msg00216.html  */
  return cur->region != prev->region;
}

void
one_lang_size_sections_pass (bfd_boolean *relax, bfd_boolean check_regions)
{
  lang_statement_iteration++;
  lang_size_sections_1 (&statement_list.head, abs_output_section,
			0, 0, relax, check_regions);
}

void
lang_size_sections (bfd_boolean *relax, bfd_boolean check_regions)
{
  expld.phase = lang_allocating_phase_enum;
  expld.dataseg.phase = exp_dataseg_none;

  one_lang_size_sections_pass (relax, check_regions);
  if (expld.dataseg.phase == exp_dataseg_end_seen
      && link_info.relro && expld.dataseg.relro_end)
    {
      /* If DATA_SEGMENT_ALIGN DATA_SEGMENT_RELRO_END pair was seen, try
	 to put expld.dataseg.relro on a (common) page boundary.  */
      bfd_vma min_base, old_base, relro_end, maxpage;

      expld.dataseg.phase = exp_dataseg_relro_adjust;
      maxpage = expld.dataseg.maxpagesize;
      /* MIN_BASE is the absolute minimum address we are allowed to start the
	 read-write segment (byte before will be mapped read-only).  */
      min_base = (expld.dataseg.min_base + maxpage - 1) & ~(maxpage - 1);
      /* OLD_BASE is the address for a feasible minimum address which will
	 still not cause a data overlap inside MAXPAGE causing file offset skip
	 by MAXPAGE.  */
      old_base = expld.dataseg.base;
      expld.dataseg.base += (-expld.dataseg.relro_end
			     & (expld.dataseg.pagesize - 1));
      /* Compute the expected PT_GNU_RELRO segment end.  */
      relro_end = ((expld.dataseg.relro_end + expld.dataseg.pagesize - 1)
		   & ~(expld.dataseg.pagesize - 1));
      if (min_base + maxpage < expld.dataseg.base)
	{
	  expld.dataseg.base -= maxpage;
	  relro_end -= maxpage;
	}
      lang_reset_memory_regions ();
      one_lang_size_sections_pass (relax, check_regions);
      if (expld.dataseg.relro_end > relro_end)
	{
	  /* The alignment of sections between DATA_SEGMENT_ALIGN
	     and DATA_SEGMENT_RELRO_END caused huge padding to be
	     inserted at DATA_SEGMENT_RELRO_END.  Try to start a bit lower so
	     that the section alignments will fit in.  */
	  asection *sec;
	  unsigned int max_alignment_power = 0;

	  /* Find maximum alignment power of sections between
	     DATA_SEGMENT_ALIGN and DATA_SEGMENT_RELRO_END.  */
	  for (sec = link_info.output_bfd->sections; sec; sec = sec->next)
	    if (sec->vma >= expld.dataseg.base
		&& sec->vma < expld.dataseg.relro_end
		&& sec->alignment_power > max_alignment_power)
	      max_alignment_power = sec->alignment_power;

	  if (((bfd_vma) 1 << max_alignment_power) < expld.dataseg.pagesize)
	    {
	      if (expld.dataseg.base - (1 << max_alignment_power) < old_base)
		expld.dataseg.base += expld.dataseg.pagesize;
	      expld.dataseg.base -= (1 << max_alignment_power);
	      lang_reset_memory_regions ();
	      one_lang_size_sections_pass (relax, check_regions);
	    }
	}
      link_info.relro_start = expld.dataseg.base;
      link_info.relro_end = expld.dataseg.relro_end;
    }
  else if (expld.dataseg.phase == exp_dataseg_end_seen)
    {
      /* If DATA_SEGMENT_ALIGN DATA_SEGMENT_END pair was seen, check whether
	 a page could be saved in the data segment.  */
      bfd_vma first, last;

      first = -expld.dataseg.base & (expld.dataseg.pagesize - 1);
      last = expld.dataseg.end & (expld.dataseg.pagesize - 1);
      if (first && last
	  && ((expld.dataseg.base & ~(expld.dataseg.pagesize - 1))
	      != (expld.dataseg.end & ~(expld.dataseg.pagesize - 1)))
	  && first + last <= expld.dataseg.pagesize)
	{
	  expld.dataseg.phase = exp_dataseg_adjust;
	  lang_reset_memory_regions ();
	  one_lang_size_sections_pass (relax, check_regions);
	}
      else
	expld.dataseg.phase = exp_dataseg_done;
    }
  else
    expld.dataseg.phase = exp_dataseg_done;
}

static lang_output_section_statement_type *current_section;
static lang_assignment_statement_type *current_assign;
static bfd_boolean prefer_next_section;

/* Worker function for lang_do_assignments.  Recursiveness goes here.  */

static bfd_vma
lang_do_assignments_1 (lang_statement_union_type *s,
		       lang_output_section_statement_type *current_os,
		       fill_type *fill,
		       bfd_vma dot,
		       bfd_boolean *found_end)
{
  for (; s != NULL; s = s->header.next)
    {
      switch (s->header.type)
	{
	case lang_constructors_statement_enum:
	  dot = lang_do_assignments_1 (constructor_list.head,
				       current_os, fill, dot, found_end);
	  break;

	case lang_output_section_statement_enum:
	  {
	    lang_output_section_statement_type *os;

	    os = &(s->output_section_statement);
	    os->after_end = *found_end;
	    if (os->bfd_section != NULL && !os->ignored)
	      {
		if ((os->bfd_section->flags & SEC_ALLOC) != 0)
		  {
		    current_section = os;
		    prefer_next_section = FALSE;
		  }
		dot = os->bfd_section->vma;

		lang_do_assignments_1 (os->children.head,
				       os, os->fill, dot, found_end);

		/* .tbss sections effectively have zero size.  */
		if ((os->bfd_section->flags & SEC_HAS_CONTENTS) != 0
		    || (os->bfd_section->flags & SEC_THREAD_LOCAL) == 0
		    || link_info.relocatable)
		  dot += TO_ADDR (os->bfd_section->size);

		if (os->update_dot_tree != NULL)
		  exp_fold_tree (os->update_dot_tree, bfd_abs_section_ptr, &dot);
	      }
	  }
	  break;

	case lang_wild_statement_enum:

	  dot = lang_do_assignments_1 (s->wild_statement.children.head,
				       current_os, fill, dot, found_end);
	  break;

	case lang_object_symbols_statement_enum:
	case lang_output_statement_enum:
	case lang_target_statement_enum:
	  break;

	case lang_data_statement_enum:
	  exp_fold_tree (s->data_statement.exp, bfd_abs_section_ptr, &dot);
	  if (expld.result.valid_p)
	    {
	      s->data_statement.value = expld.result.value;
	      if (expld.result.section != NULL)
		s->data_statement.value += expld.result.section->vma;
	    }
	  else
	    einfo (_("%F%P: invalid data statement\n"));
	  {
	    unsigned int size;
	    switch (s->data_statement.type)
	      {
	      default:
		abort ();
	      case QUAD:
	      case SQUAD:
		size = QUAD_SIZE;
		break;
	      case LONG:
		size = LONG_SIZE;
		break;
	      case SHORT:
		size = SHORT_SIZE;
		break;
	      case BYTE:
		size = BYTE_SIZE;
		break;
	      }
	    if (size < TO_SIZE ((unsigned) 1))
	      size = TO_SIZE ((unsigned) 1);
	    dot += TO_ADDR (size);
	  }
	  break;

	case lang_reloc_statement_enum:
	  exp_fold_tree (s->reloc_statement.addend_exp,
			 bfd_abs_section_ptr, &dot);
	  if (expld.result.valid_p)
	    s->reloc_statement.addend_value = expld.result.value;
	  else
	    einfo (_("%F%P: invalid reloc statement\n"));
	  dot += TO_ADDR (bfd_get_reloc_size (s->reloc_statement.howto));
	  break;

	case lang_input_section_enum:
	  {
	    asection *in = s->input_section.section;

	    if ((in->flags & SEC_EXCLUDE) == 0)
	      dot += TO_ADDR (in->size);
	  }
	  break;

	case lang_input_statement_enum:
	  break;

	case lang_fill_statement_enum:
	  fill = s->fill_statement.fill;
	  break;

	case lang_assignment_statement_enum:
	  current_assign = &s->assignment_statement;
	  if (current_assign->exp->type.node_class != etree_assert)
	    {
	      const char *p = current_assign->exp->assign.dst;

	      if (current_os == abs_output_section && p[0] == '.' && p[1] == 0)
		prefer_next_section = TRUE;

	      while (*p == '_')
		++p;
	      if (strcmp (p, "end") == 0)
		*found_end = TRUE;
	    }
	  exp_fold_tree (s->assignment_statement.exp,
			 current_os->bfd_section,
			 &dot);
	  break;

	case lang_padding_statement_enum:
	  dot += TO_ADDR (s->padding_statement.size);
	  break;

	case lang_group_statement_enum:
	  dot = lang_do_assignments_1 (s->group_statement.children.head,
				       current_os, fill, dot, found_end);
	  break;

	case lang_insert_statement_enum:
	  break;

	case lang_address_statement_enum:
	  break;

	default:
	  FAIL ();
	  break;
	}
    }
  return dot;
}

void
lang_do_assignments (lang_phase_type phase)
{
  bfd_boolean found_end = FALSE;

  current_section = NULL;
  prefer_next_section = FALSE;
  expld.phase = phase;
  lang_statement_iteration++;
  lang_do_assignments_1 (statement_list.head,
			 abs_output_section, NULL, 0, &found_end);
}

/* For an assignment statement outside of an output section statement,
   choose the best of neighbouring output sections to use for values
   of "dot".  */

asection *
section_for_dot (void)
{
  asection *s;

  /* Assignments belong to the previous output section, unless there
     has been an assignment to "dot", in which case following
     assignments belong to the next output section.  (The assumption
     is that an assignment to "dot" is setting up the address for the
     next output section.)  Except that past the assignment to "_end"
     we always associate with the previous section.  This exception is
     for targets like SH that define an alloc .stack or other
     weirdness after non-alloc sections.  */
  if (current_section == NULL || prefer_next_section)
    {
      lang_statement_union_type *stmt;
      lang_output_section_statement_type *os;

      for (stmt = (lang_statement_union_type *) current_assign;
	   stmt != NULL;
	   stmt = stmt->header.next)
	if (stmt->header.type == lang_output_section_statement_enum)
	  break;

      os = &stmt->output_section_statement;
      while (os != NULL
	     && !os->after_end
	     && (os->bfd_section == NULL
		 || (os->bfd_section->flags & SEC_EXCLUDE) != 0
		 || bfd_section_removed_from_list (link_info.output_bfd,
						   os->bfd_section)))
	os = os->next;

      if (current_section == NULL || os == NULL || !os->after_end)
	{
	  if (os != NULL)
	    s = os->bfd_section;
	  else
	    s = link_info.output_bfd->section_last;
	  while (s != NULL
		 && ((s->flags & SEC_ALLOC) == 0
		     || (s->flags & SEC_THREAD_LOCAL) != 0))
	    s = s->prev;
	  if (s != NULL)
	    return s;

	  return bfd_abs_section_ptr;
	}
    }

  s = current_section->bfd_section;

  /* The section may have been stripped.  */
  while (s != NULL
	 && ((s->flags & SEC_EXCLUDE) != 0
	     || (s->flags & SEC_ALLOC) == 0
	     || (s->flags & SEC_THREAD_LOCAL) != 0
	     || bfd_section_removed_from_list (link_info.output_bfd, s)))
    s = s->prev;
  if (s == NULL)
    s = link_info.output_bfd->sections;
  while (s != NULL
	 && ((s->flags & SEC_ALLOC) == 0
	     || (s->flags & SEC_THREAD_LOCAL) != 0))
    s = s->next;
  if (s != NULL)
    return s;

  return bfd_abs_section_ptr;
}

/* Fix any .startof. or .sizeof. symbols.  When the assemblers see the
   operator .startof. (section_name), it produces an undefined symbol
   .startof.section_name.  Similarly, when it sees
   .sizeof. (section_name), it produces an undefined symbol
   .sizeof.section_name.  For all the output sections, we look for
   such symbols, and set them to the correct value.  */

static void
lang_set_startof (void)
{
  asection *s;

  if (link_info.relocatable)
    return;

  for (s = link_info.output_bfd->sections; s != NULL; s = s->next)
    {
      const char *secname;
      char *buf;
      struct bfd_link_hash_entry *h;

      secname = bfd_get_section_name (link_info.output_bfd, s);
      buf = (char *) xmalloc (10 + strlen (secname));

      sprintf (buf, ".startof.%s", secname);
      h = bfd_link_hash_lookup (link_info.hash, buf, FALSE, FALSE, TRUE);
      if (h != NULL && h->type == bfd_link_hash_undefined)
	{
	  h->type = bfd_link_hash_defined;
	  h->u.def.value = 0;
	  h->u.def.section = s;
	}

      sprintf (buf, ".sizeof.%s", secname);
      h = bfd_link_hash_lookup (link_info.hash, buf, FALSE, FALSE, TRUE);
      if (h != NULL && h->type == bfd_link_hash_undefined)
	{
	  h->type = bfd_link_hash_defined;
	  h->u.def.value = TO_ADDR (s->size);
	  h->u.def.section = bfd_abs_section_ptr;
	}

      free (buf);
    }
}

static void
lang_end (void)
{
  struct bfd_link_hash_entry *h;
  bfd_boolean warn;

  if ((link_info.relocatable && !link_info.gc_sections)
      || (link_info.shared && !link_info.executable))
    warn = entry_from_cmdline;
  else
    warn = TRUE;

  /* Force the user to specify a root when generating a relocatable with
     --gc-sections.  */
  if (link_info.gc_sections && link_info.relocatable
      && !(entry_from_cmdline || undef_from_cmdline))
    einfo (_("%P%F: gc-sections requires either an entry or "
	     "an undefined symbol\n"));

  if (entry_symbol.name == NULL)
    {
      /* No entry has been specified.  Look for the default entry, but
	 don't warn if we don't find it.  */
      entry_symbol.name = entry_symbol_default;
      warn = FALSE;
    }

  h = bfd_link_hash_lookup (link_info.hash, entry_symbol.name,
			    FALSE, FALSE, TRUE);
  if (h != NULL
      && (h->type == bfd_link_hash_defined
	  || h->type == bfd_link_hash_defweak)
      && h->u.def.section->output_section != NULL)
    {
      bfd_vma val;

      val = (h->u.def.value
	     + bfd_get_section_vma (link_info.output_bfd,
				    h->u.def.section->output_section)
	     + h->u.def.section->output_offset);
      if (! bfd_set_start_address (link_info.output_bfd, val))
	einfo (_("%P%F:%s: can't set start address\n"), entry_symbol.name);
    }
  else
    {
      bfd_vma val;
      const char *send;

      /* We couldn't find the entry symbol.  Try parsing it as a
	 number.  */
      val = bfd_scan_vma (entry_symbol.name, &send, 0);
      if (*send == '\0')
	{
	  if (! bfd_set_start_address (link_info.output_bfd, val))
	    einfo (_("%P%F: can't set start address\n"));
	}
      else
	{
	  asection *ts;

	  /* Can't find the entry symbol, and it's not a number.  Use
	     the first address in the text section.  */
	  ts = bfd_get_section_by_name (link_info.output_bfd, entry_section);
	  if (ts != NULL)
	    {
	      if (warn)
		einfo (_("%P: warning: cannot find entry symbol %s;"
			 " defaulting to %V\n"),
		       entry_symbol.name,
		       bfd_get_section_vma (link_info.output_bfd, ts));
	      if (!(bfd_set_start_address
		    (link_info.output_bfd,
		     bfd_get_section_vma (link_info.output_bfd, ts))))
		einfo (_("%P%F: can't set start address\n"));
	    }
	  else
	    {
	      if (warn)
		einfo (_("%P: warning: cannot find entry symbol %s;"
			 " not setting start address\n"),
		       entry_symbol.name);
	    }
	}
    }
}

/* This is a small function used when we want to ignore errors from
   BFD.  */

static void
ignore_bfd_errors (const char *s ATTRIBUTE_UNUSED, ...)
{
  /* Don't do anything.  */
}

/* Check that the architecture of all the input files is compatible
   with the output file.  Also call the backend to let it do any
   other checking that is needed.  */

static void
lang_check (void)
{
  lang_statement_union_type *file;
  bfd *input_bfd;
  const bfd_arch_info_type *compatible;

  for (file = file_chain.head; file != NULL; file = file->input_statement.next)
    {
#ifdef ENABLE_PLUGINS
      /* Don't check format of files claimed by plugin.  */
      if (file->input_statement.flags.claimed)
	continue;
#endif /* ENABLE_PLUGINS */
      input_bfd = file->input_statement.the_bfd;
      compatible
	= bfd_arch_get_compatible (input_bfd, link_info.output_bfd,
				   command_line.accept_unknown_input_arch);

      /* In general it is not possible to perform a relocatable
	 link between differing object formats when the input
	 file has relocations, because the relocations in the
	 input format may not have equivalent representations in
	 the output format (and besides BFD does not translate
	 relocs for other link purposes than a final link).  */
      if ((link_info.relocatable || link_info.emitrelocations)
	  && (compatible == NULL
	      || (bfd_get_flavour (input_bfd)
		  != bfd_get_flavour (link_info.output_bfd)))
	  && (bfd_get_file_flags (input_bfd) & HAS_RELOC) != 0)
	{
	  einfo (_("%P%F: Relocatable linking with relocations from"
		   " format %s (%B) to format %s (%B) is not supported\n"),
		 bfd_get_target (input_bfd), input_bfd,
		 bfd_get_target (link_info.output_bfd), link_info.output_bfd);
	  /* einfo with %F exits.  */
	}

      if (compatible == NULL)
	{
	  if (command_line.warn_mismatch)
	    einfo (_("%P%X: %s architecture of input file `%B'"
		     " is incompatible with %s output\n"),
		   bfd_printable_name (input_bfd), input_bfd,
		   bfd_printable_name (link_info.output_bfd));
	}
      else if (bfd_count_sections (input_bfd))
	{
	  /* If the input bfd has no contents, it shouldn't set the
	     private data of the output bfd.  */

	  bfd_error_handler_type pfn = NULL;

	  /* If we aren't supposed to warn about mismatched input
	     files, temporarily set the BFD error handler to a
	     function which will do nothing.  We still want to call
	     bfd_merge_private_bfd_data, since it may set up
	     information which is needed in the output file.  */
	  if (! command_line.warn_mismatch)
	    pfn = bfd_set_error_handler (ignore_bfd_errors);
	  if (! bfd_merge_private_bfd_data (input_bfd, link_info.output_bfd))
	    {
	      if (command_line.warn_mismatch)
		einfo (_("%P%X: failed to merge target specific data"
			 " of file %B\n"), input_bfd);
	    }
	  if (! command_line.warn_mismatch)
	    bfd_set_error_handler (pfn);
	}
    }
}

/* Look through all the global common symbols and attach them to the
   correct section.  The -sort-common command line switch may be used
   to roughly sort the entries by alignment.  */

static void
lang_common (void)
{
  if (command_line.inhibit_common_definition)
    return;
  if (link_info.relocatable
      && ! command_line.force_common_definition)
    return;

  if (! config.sort_common)
    bfd_link_hash_traverse (link_info.hash, lang_one_common, NULL);
  else
    {
      unsigned int power;

      if (config.sort_common == sort_descending)
	{
	  for (power = 4; power > 0; power--)
	    bfd_link_hash_traverse (link_info.hash, lang_one_common, &power);

	  power = 0;
	  bfd_link_hash_traverse (link_info.hash, lang_one_common, &power);
	}
      else
	{
	  for (power = 0; power <= 4; power++)
	    bfd_link_hash_traverse (link_info.hash, lang_one_common, &power);

	  power = UINT_MAX;
	  bfd_link_hash_traverse (link_info.hash, lang_one_common, &power);
	}
    }
}

/* Place one common symbol in the correct section.  */

static bfd_boolean
lang_one_common (struct bfd_link_hash_entry *h, void *info)
{
  unsigned int power_of_two;
  bfd_vma size;
  asection *section;

  if (h->type != bfd_link_hash_common)
    return TRUE;

  size = h->u.c.size;
  power_of_two = h->u.c.p->alignment_power;

  if (config.sort_common == sort_descending
      && power_of_two < *(unsigned int *) info)
    return TRUE;
  else if (config.sort_common == sort_ascending
	   && power_of_two > *(unsigned int *) info)
    return TRUE;

  section = h->u.c.p->section;
  if (!bfd_define_common_symbol (link_info.output_bfd, &link_info, h))
    einfo (_("%P%F: Could not define common symbol `%T': %E\n"),
	   h->root.string);

  if (config.map_file != NULL)
    {
      static bfd_boolean header_printed;
      int len;
      char *name;
      char buf[50];

      if (! header_printed)
	{
	  minfo (_("\nAllocating common symbols\n"));
	  minfo (_("Common symbol       size              file\n\n"));
	  header_printed = TRUE;
	}

      name = bfd_demangle (link_info.output_bfd, h->root.string,
			   DMGL_ANSI | DMGL_PARAMS);
      if (name == NULL)
	{
	  minfo ("%s", h->root.string);
	  len = strlen (h->root.string);
	}
      else
	{
	  minfo ("%s", name);
	  len = strlen (name);
	  free (name);
	}

      if (len >= 19)
	{
	  print_nl ();
	  len = 0;
	}
      while (len < 20)
	{
	  print_space ();
	  ++len;
	}

      minfo ("0x");
      if (size <= 0xffffffff)
	sprintf (buf, "%lx", (unsigned long) size);
      else
	sprintf_vma (buf, size);
      minfo ("%s", buf);
      len = strlen (buf);

      while (len < 16)
	{
	  print_space ();
	  ++len;
	}

      minfo ("%B\n", section->owner);
    }

  return TRUE;
}

/* Run through the input files and ensure that every input section has
   somewhere to go.  If one is found without a destination then create
   an input request and place it into the statement tree.  */

static void
lang_place_orphans (void)
{
  LANG_FOR_EACH_INPUT_STATEMENT (file)
    {
      asection *s;

      for (s = file->the_bfd->sections; s != NULL; s = s->next)
	{
	  if (s->output_section == NULL)
	    {
	      /* This section of the file is not attached, root
		 around for a sensible place for it to go.  */

	      if (file->flags.just_syms)
		bfd_link_just_syms (file->the_bfd, s, &link_info);
	      else if ((s->flags & SEC_EXCLUDE) != 0)
		s->output_section = bfd_abs_section_ptr;
	      else if (strcmp (s->name, "COMMON") == 0)
		{
		  /* This is a lonely common section which must have
		     come from an archive.  We attach to the section
		     with the wildcard.  */
		  if (! link_info.relocatable
		      || command_line.force_common_definition)
		    {
		      if (default_common_section == NULL)
			default_common_section
			  = lang_output_section_statement_lookup (".bss", 0,
								  TRUE);
		      lang_add_section (&default_common_section->children, s,
					NULL, default_common_section);
		    }
		}
	      else
		{
		  const char *name = s->name;
		  int constraint = 0;

		  if (config.unique_orphan_sections
		      || unique_section_p (s, NULL))
		    constraint = SPECIAL;

		  if (!ldemul_place_orphan (s, name, constraint))
		    {
		      lang_output_section_statement_type *os;
		      os = lang_output_section_statement_lookup (name,
								 constraint,
								 TRUE);
		      if (os->addr_tree == NULL
			  && (link_info.relocatable
			      || (s->flags & (SEC_LOAD | SEC_ALLOC)) == 0))
			os->addr_tree = exp_intop (0);
		      lang_add_section (&os->children, s, NULL, os);
		    }
		}
	    }
	}
    }
}

void
lang_set_flags (lang_memory_region_type *ptr, const char *flags, int invert)
{
  flagword *ptr_flags;

  ptr_flags = invert ? &ptr->not_flags : &ptr->flags;
  while (*flags)
    {
      switch (*flags)
	{
	case 'A': case 'a':
	  *ptr_flags |= SEC_ALLOC;
	  break;

	case 'R': case 'r':
	  *ptr_flags |= SEC_READONLY;
	  break;

	case 'W': case 'w':
	  *ptr_flags |= SEC_DATA;
	  break;

	case 'X': case 'x':
	  *ptr_flags |= SEC_CODE;
	  break;

	case 'L': case 'l':
	case 'I': case 'i':
	  *ptr_flags |= SEC_LOAD;
	  break;

	default:
	  einfo (_("%P%F: invalid syntax in flags\n"));
	  break;
	}
      flags++;
    }
}

/* Call a function on each input file.  This function will be called
   on an archive, but not on the elements.  */

void
lang_for_each_input_file (void (*func) (lang_input_statement_type *))
{
  lang_input_statement_type *f;

  for (f = (lang_input_statement_type *) input_file_chain.head;
       f != NULL;
       f = (lang_input_statement_type *) f->next_real_file)
    func (f);
}

/* Call a function on each file.  The function will be called on all
   the elements of an archive which are included in the link, but will
   not be called on the archive file itself.  */

void
lang_for_each_file (void (*func) (lang_input_statement_type *))
{
  LANG_FOR_EACH_INPUT_STATEMENT (f)
    {
      func (f);
    }
}

void
ldlang_add_file (lang_input_statement_type *entry)
{
  lang_statement_append (&file_chain,
			 (lang_statement_union_type *) entry,
			 &entry->next);

  /* The BFD linker needs to have a list of all input BFDs involved in
     a link.  */
  ASSERT (entry->the_bfd->link_next == NULL);
  ASSERT (entry->the_bfd != link_info.output_bfd);

  *link_info.input_bfds_tail = entry->the_bfd;
  link_info.input_bfds_tail = &entry->the_bfd->link_next;
  entry->the_bfd->usrdata = entry;
  bfd_set_gp_size (entry->the_bfd, g_switch_value);

  /* Look through the sections and check for any which should not be
     included in the link.  We need to do this now, so that we can
     notice when the backend linker tries to report multiple
     definition errors for symbols which are in sections we aren't
     going to link.  FIXME: It might be better to entirely ignore
     symbols which are defined in sections which are going to be
     discarded.  This would require modifying the backend linker for
     each backend which might set the SEC_LINK_ONCE flag.  If we do
     this, we should probably handle SEC_EXCLUDE in the same way.  */

  bfd_map_over_sections (entry->the_bfd, section_already_linked, entry);
}

void
lang_add_output (const char *name, int from_script)
{
  /* Make -o on command line override OUTPUT in script.  */
  if (!had_output_filename || !from_script)
    {
      output_filename = name;
      had_output_filename = TRUE;
    }
}

static int
topower (int x)
{
  unsigned int i = 1;
  int l;

  if (x < 0)
    return -1;

  for (l = 0; l < 32; l++)
    {
      if (i >= (unsigned int) x)
	return l;
      i <<= 1;
    }

  return 0;
}

lang_output_section_statement_type *
lang_enter_output_section_statement (const char *output_section_statement_name,
				     etree_type *address_exp,
				     enum section_type sectype,
				     etree_type *align,
				     etree_type *subalign,
				     etree_type *ebase,
				     int constraint,
				     int align_with_input)
{
  lang_output_section_statement_type *os;

  os = lang_output_section_statement_lookup (output_section_statement_name,
					     constraint, TRUE);
  current_section = os;

  if (os->addr_tree == NULL)
    {
      os->addr_tree = address_exp;
    }
  os->sectype = sectype;
  if (sectype != noload_section)
    os->flags = SEC_NO_FLAGS;
  else
    os->flags = SEC_NEVER_LOAD;
  os->block_value = 1;

  /* Make next things chain into subchain of this.  */
  push_stat_ptr (&os->children);

  os->align_lma_with_input = align_with_input == ALIGN_WITH_INPUT;
  if (os->align_lma_with_input && align != NULL)
    einfo (_("%F%P:%S: error: align with input and explicit align specified\n"), NULL);

  os->subsection_alignment =
    topower (exp_get_value_int (subalign, -1, "subsection alignment"));
  os->section_alignment =
    topower (exp_get_value_int (align, -1, "section alignment"));

  os->load_base = ebase;
  return os;
}

void
lang_final (void)
{
  lang_output_statement_type *new_stmt;

  new_stmt = new_stat (lang_output_statement, stat_ptr);
  new_stmt->name = output_filename;

}

/* Reset the current counters in the regions.  */

void
lang_reset_memory_regions (void)
{
  lang_memory_region_type *p = lang_memory_region_list;
  asection *o;
  lang_output_section_statement_type *os;

  for (p = lang_memory_region_list; p != NULL; p = p->next)
    {
      p->current = p->origin;
      p->last_os = NULL;
    }

  for (os = &lang_output_section_statement.head->output_section_statement;
       os != NULL;
       os = os->next)
    {
      os->processed_vma = FALSE;
      os->processed_lma = FALSE;
    }

  for (o = link_info.output_bfd->sections; o != NULL; o = o->next)
    {
      /* Save the last size for possible use by bfd_relax_section.  */
      o->rawsize = o->size;
      o->size = 0;
    }
}

/* Worker for lang_gc_sections_1.  */

static void
gc_section_callback (lang_wild_statement_type *ptr,
		     struct wildcard_list *sec ATTRIBUTE_UNUSED,
		     asection *section,
		     struct flag_info *sflag_info ATTRIBUTE_UNUSED,
		     lang_input_statement_type *file ATTRIBUTE_UNUSED,
		     void *data ATTRIBUTE_UNUSED)
{
  /* If the wild pattern was marked KEEP, the member sections
     should be as well.  */
  if (ptr->keep_sections)
    section->flags |= SEC_KEEP;
}

/* Iterate over sections marking them against GC.  */

static void
lang_gc_sections_1 (lang_statement_union_type *s)
{
  for (; s != NULL; s = s->header.next)
    {
      switch (s->header.type)
	{
	case lang_wild_statement_enum:
	  walk_wild (&s->wild_statement, gc_section_callback, NULL);
	  break;
	case lang_constructors_statement_enum:
	  lang_gc_sections_1 (constructor_list.head);
	  break;
	case lang_output_section_statement_enum:
	  lang_gc_sections_1 (s->output_section_statement.children.head);
	  break;
	case lang_group_statement_enum:
	  lang_gc_sections_1 (s->group_statement.children.head);
	  break;
	default:
	  break;
	}
    }
}

static void
lang_gc_sections (void)
{
  /* Keep all sections so marked in the link script.  */

  lang_gc_sections_1 (statement_list.head);

  /* SEC_EXCLUDE is ignored when doing a relocatable link, except in
     the special case of debug info.  (See bfd/stabs.c)
     Twiddle the flag here, to simplify later linker code.  */
  if (link_info.relocatable)
    {
      LANG_FOR_EACH_INPUT_STATEMENT (f)
	{
	  asection *sec;
#ifdef ENABLE_PLUGINS
	  if (f->flags.claimed)
	    continue;
#endif
	  for (sec = f->the_bfd->sections; sec != NULL; sec = sec->next)
	    if ((sec->flags & SEC_DEBUGGING) == 0)
	      sec->flags &= ~SEC_EXCLUDE;
	}
    }

  if (link_info.gc_sections)
    bfd_gc_sections (link_info.output_bfd, &link_info);
}

/* Worker for lang_find_relro_sections_1.  */

static void
find_relro_section_callback (lang_wild_statement_type *ptr ATTRIBUTE_UNUSED,
			     struct wildcard_list *sec ATTRIBUTE_UNUSED,
			     asection *section,
			     struct flag_info *sflag_info ATTRIBUTE_UNUSED,
			     lang_input_statement_type *file ATTRIBUTE_UNUSED,
			     void *data)
{
  /* Discarded, excluded and ignored sections effectively have zero
     size.  */
  if (section->output_section != NULL
      && section->output_section->owner == link_info.output_bfd
      && (section->output_section->flags & SEC_EXCLUDE) == 0
      && !IGNORE_SECTION (section)
      && section->size != 0)
    {
      bfd_boolean *has_relro_section = (bfd_boolean *) data;
      *has_relro_section = TRUE;
    }
}

/* Iterate over sections for relro sections.  */

static void
lang_find_relro_sections_1 (lang_statement_union_type *s,
			    bfd_boolean *has_relro_section)
{
  if (*has_relro_section)
    return;

  for (; s != NULL; s = s->header.next)
    {
      if (s == expld.dataseg.relro_end_stat)
	break;

      switch (s->header.type)
	{
	case lang_wild_statement_enum:
	  walk_wild (&s->wild_statement,
		     find_relro_section_callback,
		     has_relro_section);
	  break;
	case lang_constructors_statement_enum:
	  lang_find_relro_sections_1 (constructor_list.head,
				      has_relro_section);
	  break;
	case lang_output_section_statement_enum:
	  lang_find_relro_sections_1 (s->output_section_statement.children.head,
				      has_relro_section);
	  break;
	case lang_group_statement_enum:
	  lang_find_relro_sections_1 (s->group_statement.children.head,
				      has_relro_section);
	  break;
	default:
	  break;
	}
    }
}

static void
lang_find_relro_sections (void)
{
  bfd_boolean has_relro_section = FALSE;

  /* Check all sections in the link script.  */

  lang_find_relro_sections_1 (expld.dataseg.relro_start_stat,
			      &has_relro_section);

  if (!has_relro_section)
    link_info.relro = FALSE;
}

/* Relax all sections until bfd_relax_section gives up.  */

void
lang_relax_sections (bfd_boolean need_layout)
{
  if (RELAXATION_ENABLED)
    {
      /* We may need more than one relaxation pass.  */
      int i = link_info.relax_pass;

      /* The backend can use it to determine the current pass.  */
      link_info.relax_pass = 0;

      while (i--)
	{
	  /* Keep relaxing until bfd_relax_section gives up.  */
	  bfd_boolean relax_again;

	  link_info.relax_trip = -1;
	  do
	    {
	      link_info.relax_trip++;

	      /* Note: pe-dll.c does something like this also.  If you find
		 you need to change this code, you probably need to change
		 pe-dll.c also.  DJ  */

	      /* Do all the assignments with our current guesses as to
		 section sizes.  */
	      lang_do_assignments (lang_assigning_phase_enum);

	      /* We must do this after lang_do_assignments, because it uses
		 size.  */
	      lang_reset_memory_regions ();

	      /* Perform another relax pass - this time we know where the
		 globals are, so can make a better guess.  */
	      relax_again = FALSE;
	      lang_size_sections (&relax_again, FALSE);
	    }
	  while (relax_again);

	  link_info.relax_pass++;
	}
      need_layout = TRUE;
    }

  if (need_layout)
    {
      /* Final extra sizing to report errors.  */
      lang_do_assignments (lang_assigning_phase_enum);
      lang_reset_memory_regions ();
      lang_size_sections (NULL, TRUE);
    }
}

#ifdef ENABLE_PLUGINS
/* Find the insert point for the plugin's replacement files.  We
   place them after the first claimed real object file, or if the
   first claimed object is an archive member, after the last real
   object file immediately preceding the archive.  In the event
   no objects have been claimed at all, we return the first dummy
   object file on the list as the insert point; that works, but
   the callee must be careful when relinking the file_chain as it
   is not actually on that chain, only the statement_list and the
   input_file list; in that case, the replacement files must be
   inserted at the head of the file_chain.  */

static lang_input_statement_type *
find_replacements_insert_point (void)
{
  lang_input_statement_type *claim1, *lastobject;
  lastobject = &input_file_chain.head->input_statement;
  for (claim1 = &file_chain.head->input_statement;
       claim1 != NULL;
       claim1 = &claim1->next->input_statement)
    {
      if (claim1->flags.claimed)
	return claim1->flags.claim_archive ? lastobject : claim1;
      /* Update lastobject if this is a real object file.  */
      if (claim1->the_bfd && (claim1->the_bfd->my_archive == NULL))
	lastobject = claim1;
    }
  /* No files were claimed by the plugin.  Choose the last object
     file found on the list (maybe the first, dummy entry) as the
     insert point.  */
  return lastobject;
}

/* Insert SRCLIST into DESTLIST after given element by chaining
   on FIELD as the next-pointer.  (Counterintuitively does not need
   a pointer to the actual after-node itself, just its chain field.)  */

static void
lang_list_insert_after (lang_statement_list_type *destlist,
			lang_statement_list_type *srclist,
			lang_statement_union_type **field)
{
  *(srclist->tail) = *field;
  *field = srclist->head;
  if (destlist->tail == field)
    destlist->tail = srclist->tail;
}

/* Detach new nodes added to DESTLIST since the time ORIGLIST
   was taken as a copy of it and leave them in ORIGLIST.  */

static void
lang_list_remove_tail (lang_statement_list_type *destlist,
		       lang_statement_list_type *origlist)
{
  union lang_statement_union **savetail;
  /* Check that ORIGLIST really is an earlier state of DESTLIST.  */
  ASSERT (origlist->head == destlist->head);
  savetail = origlist->tail;
  origlist->head = *(savetail);
  origlist->tail = destlist->tail;
  destlist->tail = savetail;
  *savetail = NULL;
}
#endif /* ENABLE_PLUGINS */

void
lang_process (void)
{
  /* Finalize dynamic list.  */
  if (link_info.dynamic_list)
    lang_finalize_version_expr_head (&link_info.dynamic_list->head);

  current_target = default_target;

  /* Open the output file.  */
  lang_for_each_statement (ldlang_open_output);
  init_opb ();

  ldemul_create_output_section_statements ();

  /* Add to the hash table all undefineds on the command line.  */
  lang_place_undefineds ();

  if (!bfd_section_already_linked_table_init ())
    einfo (_("%P%F: Failed to create hash table\n"));

  /* Create a bfd for each input file.  */
  current_target = default_target;
  open_input_bfds (statement_list.head, OPEN_BFD_NORMAL);

#ifdef ENABLE_PLUGINS
  if (plugin_active_plugins_p ())
    {
      lang_statement_list_type added;
      lang_statement_list_type files, inputfiles;

      /* Now all files are read, let the plugin(s) decide if there
	 are any more to be added to the link before we call the
	 emulation's after_open hook.  We create a private list of
	 input statements for this purpose, which we will eventually
	 insert into the global statment list after the first claimed
	 file.  */
      added = *stat_ptr;
      /* We need to manipulate all three chains in synchrony.  */
      files = file_chain;
      inputfiles = input_file_chain;
      if (plugin_call_all_symbols_read ())
	einfo (_("%P%F: %s: plugin reported error after all symbols read\n"),
	       plugin_error_plugin ());
      /* Open any newly added files, updating the file chains.  */
      link_info.loading_lto_outputs = TRUE;
      open_input_bfds (*added.tail, OPEN_BFD_NORMAL);
      /* Restore the global list pointer now they have all been added.  */
      lang_list_remove_tail (stat_ptr, &added);
      /* And detach the fresh ends of the file lists.  */
      lang_list_remove_tail (&file_chain, &files);
      lang_list_remove_tail (&input_file_chain, &inputfiles);
      /* Were any new files added?  */
      if (added.head != NULL)
	{
	  /* If so, we will insert them into the statement list immediately
	     after the first input file that was claimed by the plugin.  */
	  plugin_insert = find_replacements_insert_point ();
	  /* If a plugin adds input files without having claimed any, we
	     don't really have a good idea where to place them.  Just putting
	     them at the start or end of the list is liable to leave them
	     outside the crtbegin...crtend range.  */
	  ASSERT (plugin_insert != NULL);
	  /* Splice the new statement list into the old one.  */
	  lang_list_insert_after (stat_ptr, &added,
				  &plugin_insert->header.next);
	  /* Likewise for the file chains.  */
	  lang_list_insert_after (&input_file_chain, &inputfiles,
				  &plugin_insert->next_real_file);
	  /* We must be careful when relinking file_chain; we may need to
	     insert the new files at the head of the list if the insert
	     point chosen is the dummy first input file.  */
	  if (plugin_insert->filename)
	    lang_list_insert_after (&file_chain, &files, &plugin_insert->next);
	  else
	    lang_list_insert_after (&file_chain, &files, &file_chain.head);

	  /* Rescan archives in case new undefined symbols have appeared.  */
	  open_input_bfds (statement_list.head, OPEN_BFD_RESCAN);
	}
    }
#endif /* ENABLE_PLUGINS */

  link_info.gc_sym_list = &entry_symbol;
  if (entry_symbol.name == NULL)
    link_info.gc_sym_list = ldlang_undef_chain_list_head;

  ldemul_after_open ();

  bfd_section_already_linked_table_free ();

  /* Make sure that we're not mixing architectures.  We call this
     after all the input files have been opened, but before we do any
     other processing, so that any operations merge_private_bfd_data
     does on the output file will be known during the rest of the
     link.  */
  lang_check ();

  /* Handle .exports instead of a version script if we're told to do so.  */
  if (command_line.version_exports_section)
    lang_do_version_exports_section ();

  /* Build all sets based on the information gathered from the input
     files.  */
  ldctor_build_sets ();

  /* PR 13683: We must rerun the assignments prior to running garbage
     collection in order to make sure that all symbol aliases are resolved.  */
  lang_do_assignments (lang_mark_phase_enum);
  expld.phase = lang_first_phase_enum;

  /* Remove unreferenced sections if asked to.  */
  lang_gc_sections ();

  /* Size up the common data.  */
  lang_common ();

  /* Update wild statements.  */
  update_wild_statements (statement_list.head);

  /* Run through the contours of the script and attach input sections
     to the correct output sections.  */
  lang_statement_iteration++;
  map_input_to_output_sections (statement_list.head, NULL, NULL);

  process_insert_statements ();

  /* Find any sections not attached explicitly and handle them.  */
  lang_place_orphans ();

  if (! link_info.relocatable)
    {
      asection *found;

      /* Merge SEC_MERGE sections.  This has to be done after GC of
	 sections, so that GCed sections are not merged, but before
	 assigning dynamic symbols, since removing whole input sections
	 is hard then.  */
      bfd_merge_sections (link_info.output_bfd, &link_info);

      /* Look for a text section and set the readonly attribute in it.  */
      found = bfd_get_section_by_name (link_info.output_bfd, ".text");

      if (found != NULL)
	{
	  if (config.text_read_only)
	    found->flags |= SEC_READONLY;
	  else
	    found->flags &= ~SEC_READONLY;
	}
    }

  /* Do anything special before sizing sections.  This is where ELF
     and other back-ends size dynamic sections.  */
  ldemul_before_allocation ();

  /* We must record the program headers before we try to fix the
     section positions, since they will affect SIZEOF_HEADERS.  */
  lang_record_phdrs ();

  /* Check relro sections.  */
  if (link_info.relro && ! link_info.relocatable)
    lang_find_relro_sections ();

  /* Size up the sections.  */
  lang_size_sections (NULL, ! RELAXATION_ENABLED);

  /* See if anything special should be done now we know how big
     everything is.  This is where relaxation is done.  */
  ldemul_after_allocation ();

  /* Fix any .startof. or .sizeof. symbols.  */
  lang_set_startof ();

  /* Do all the assignments, now that we know the final resting places
     of all the symbols.  */
  lang_do_assignments (lang_final_phase_enum);

  ldemul_finish ();

  /* Make sure that the section addresses make sense.  */
  if (command_line.check_section_addresses)
    lang_check_section_addresses ();

  lang_end ();
}

/* EXPORTED TO YACC */

void
lang_add_wild (struct wildcard_spec *filespec,
	       struct wildcard_list *section_list,
	       bfd_boolean keep_sections)
{
  struct wildcard_list *curr, *next;
  lang_wild_statement_type *new_stmt;

  /* Reverse the list as the parser puts it back to front.  */
  for (curr = section_list, section_list = NULL;
       curr != NULL;
       section_list = curr, curr = next)
    {
      if (curr->spec.name != NULL && strcmp (curr->spec.name, "COMMON") == 0)
	placed_commons = TRUE;

      next = curr->next;
      curr->next = section_list;
    }

  if (filespec != NULL && filespec->name != NULL)
    {
      if (strcmp (filespec->name, "*") == 0)
	filespec->name = NULL;
      else if (! wildcardp (filespec->name))
	lang_has_input_file = TRUE;
    }

  new_stmt = new_stat (lang_wild_statement, stat_ptr);
  new_stmt->filename = NULL;
  new_stmt->filenames_sorted = FALSE;
  new_stmt->section_flag_list = NULL;
  if (filespec != NULL)
    {
      new_stmt->filename = filespec->name;
      new_stmt->filenames_sorted = filespec->sorted == by_name;
      new_stmt->section_flag_list = filespec->section_flag_list;
    }
  new_stmt->section_list = section_list;
  new_stmt->keep_sections = keep_sections;
  lang_list_init (&new_stmt->children);
  analyze_walk_wild_section_handler (new_stmt);
}

void
lang_section_start (const char *name, etree_type *address,
		    const segment_type *segment)
{
  lang_address_statement_type *ad;

  ad = new_stat (lang_address_statement, stat_ptr);
  ad->section_name = name;
  ad->address = address;
  ad->segment = segment;
}

/* Set the start symbol to NAME.  CMDLINE is nonzero if this is called
   because of a -e argument on the command line, or zero if this is
   called by ENTRY in a linker script.  Command line arguments take
   precedence.  */

void
lang_add_entry (const char *name, bfd_boolean cmdline)
{
  if (entry_symbol.name == NULL
      || cmdline
      || ! entry_from_cmdline)
    {
      entry_symbol.name = name;
      entry_from_cmdline = cmdline;
    }
}

/* Set the default start symbol to NAME.  .em files should use this,
   not lang_add_entry, to override the use of "start" if neither the
   linker script nor the command line specifies an entry point.  NAME
   must be permanently allocated.  */
void
lang_default_entry (const char *name)
{
  entry_symbol_default = name;
}

void
lang_add_target (const char *name)
{
  lang_target_statement_type *new_stmt;

  new_stmt = new_stat (lang_target_statement, stat_ptr);
  new_stmt->target = name;
}

void
lang_add_map (const char *name)
{
  while (*name)
    {
      switch (*name)
	{
	case 'F':
	  map_option_f = TRUE;
	  break;
	}
      name++;
    }
}

void
lang_add_fill (fill_type *fill)
{
  lang_fill_statement_type *new_stmt;

  new_stmt = new_stat (lang_fill_statement, stat_ptr);
  new_stmt->fill = fill;
}

void
lang_add_data (int type, union etree_union *exp)
{
  lang_data_statement_type *new_stmt;

  new_stmt = new_stat (lang_data_statement, stat_ptr);
  new_stmt->exp = exp;
  new_stmt->type = type;
}

/* Create a new reloc statement.  RELOC is the BFD relocation type to
   generate.  HOWTO is the corresponding howto structure (we could
   look this up, but the caller has already done so).  SECTION is the
   section to generate a reloc against, or NAME is the name of the
   symbol to generate a reloc against.  Exactly one of SECTION and
   NAME must be NULL.  ADDEND is an expression for the addend.  */

void
lang_add_reloc (bfd_reloc_code_real_type reloc,
		reloc_howto_type *howto,
		asection *section,
		const char *name,
		union etree_union *addend)
{
  lang_reloc_statement_type *p = new_stat (lang_reloc_statement, stat_ptr);

  p->reloc = reloc;
  p->howto = howto;
  p->section = section;
  p->name = name;
  p->addend_exp = addend;

  p->addend_value = 0;
  p->output_section = NULL;
  p->output_offset = 0;
}

lang_assignment_statement_type *
lang_add_assignment (etree_type *exp)
{
  lang_assignment_statement_type *new_stmt;

  new_stmt = new_stat (lang_assignment_statement, stat_ptr);
  new_stmt->exp = exp;
  return new_stmt;
}

void
lang_add_attribute (enum statement_enum attribute)
{
  new_statement (attribute, sizeof (lang_statement_header_type), stat_ptr);
}

void
lang_startup (const char *name)
{
  if (first_file->filename != NULL)
    {
      einfo (_("%P%F: multiple STARTUP files\n"));
    }
  first_file->filename = name;
  first_file->local_sym_name = name;
  first_file->flags.real = TRUE;
}

void
lang_float (bfd_boolean maybe)
{
  lang_float_flag = maybe;
}


/* Work out the load- and run-time regions from a script statement, and
   store them in *LMA_REGION and *REGION respectively.

   MEMSPEC is the name of the run-time region, or the value of
   DEFAULT_MEMORY_REGION if the statement didn't specify one.
   LMA_MEMSPEC is the name of the load-time region, or null if the
   statement didn't specify one.HAVE_LMA_P is TRUE if the statement
   had an explicit load address.

   It is an error to specify both a load region and a load address.  */

static void
lang_get_regions (lang_memory_region_type **region,
		  lang_memory_region_type **lma_region,
		  const char *memspec,
		  const char *lma_memspec,
		  bfd_boolean have_lma,
		  bfd_boolean have_vma)
{
  *lma_region = lang_memory_region_lookup (lma_memspec, FALSE);

  /* If no runtime region or VMA has been specified, but the load region
     has been specified, then use the load region for the runtime region
     as well.  */
  if (lma_memspec != NULL
      && ! have_vma
      && strcmp (memspec, DEFAULT_MEMORY_REGION) == 0)
    *region = *lma_region;
  else
    *region = lang_memory_region_lookup (memspec, FALSE);

  if (have_lma && lma_memspec != 0)
    einfo (_("%X%P:%S: section has both a load address and a load region\n"),
	   NULL);
}

void
lang_leave_output_section_statement (fill_type *fill, const char *memspec,
				     lang_output_section_phdr_list *phdrs,
				     const char *lma_memspec)
{
  lang_get_regions (&current_section->region,
		    &current_section->lma_region,
		    memspec, lma_memspec,
		    current_section->load_base != NULL,
		    current_section->addr_tree != NULL);

  /* If this section has no load region or base, but uses the same
     region as the previous section, then propagate the previous
     section's load region.  */

  if (current_section->lma_region == NULL
      && current_section->load_base == NULL
      && current_section->addr_tree == NULL
      && current_section->region == current_section->prev->region)
    current_section->lma_region = current_section->prev->lma_region;

  current_section->fill = fill;
  current_section->phdrs = phdrs;
  pop_stat_ptr ();
}

void
lang_statement_append (lang_statement_list_type *list,
		       lang_statement_union_type *element,
		       lang_statement_union_type **field)
{
  *(list->tail) = element;
  list->tail = field;
}

/* Set the output format type.  -oformat overrides scripts.  */

void
lang_add_output_format (const char *format,
			const char *big,
			const char *little,
			int from_script)
{
  if (output_target == NULL || !from_script)
    {
      if (command_line.endian == ENDIAN_BIG
	  && big != NULL)
	format = big;
      else if (command_line.endian == ENDIAN_LITTLE
	       && little != NULL)
	format = little;

      output_target = format;
    }
}

void
lang_add_insert (const char *where, int is_before)
{
  lang_insert_statement_type *new_stmt;

  new_stmt = new_stat (lang_insert_statement, stat_ptr);
  new_stmt->where = where;
  new_stmt->is_before = is_before;
  saved_script_handle = previous_script_handle;
}

/* Enter a group.  This creates a new lang_group_statement, and sets
   stat_ptr to build new statements within the group.  */

void
lang_enter_group (void)
{
  lang_group_statement_type *g;

  g = new_stat (lang_group_statement, stat_ptr);
  lang_list_init (&g->children);
  push_stat_ptr (&g->children);
}

/* Leave a group.  This just resets stat_ptr to start writing to the
   regular list of statements again.  Note that this will not work if
   groups can occur inside anything else which can adjust stat_ptr,
   but currently they can't.  */

void
lang_leave_group (void)
{
  pop_stat_ptr ();
}

/* Add a new program header.  This is called for each entry in a PHDRS
   command in a linker script.  */

void
lang_new_phdr (const char *name,
	       etree_type *type,
	       bfd_boolean filehdr,
	       bfd_boolean phdrs,
	       etree_type *at,
	       etree_type *flags)
{
  struct lang_phdr *n, **pp;
  bfd_boolean hdrs;

  n = (struct lang_phdr *) stat_alloc (sizeof (struct lang_phdr));
  n->next = NULL;
  n->name = name;
  n->type = exp_get_value_int (type, 0, "program header type");
  n->filehdr = filehdr;
  n->phdrs = phdrs;
  n->at = at;
  n->flags = flags;

  hdrs = n->type == 1 && (phdrs || filehdr);

  for (pp = &lang_phdr_list; *pp != NULL; pp = &(*pp)->next)
    if (hdrs
	&& (*pp)->type == 1
	&& !((*pp)->filehdr || (*pp)->phdrs))
      {
	einfo (_("%X%P:%S: PHDRS and FILEHDR are not supported"
		 " when prior PT_LOAD headers lack them\n"), NULL);
	hdrs = FALSE;
      }

  *pp = n;
}

/* Record the program header information in the output BFD.  FIXME: We
   should not be calling an ELF specific function here.  */

static void
lang_record_phdrs (void)
{
  unsigned int alc;
  asection **secs;
  lang_output_section_phdr_list *last;
  struct lang_phdr *l;
  lang_output_section_statement_type *os;

  alc = 10;
  secs = (asection **) xmalloc (alc * sizeof (asection *));
  last = NULL;

  for (l = lang_phdr_list; l != NULL; l = l->next)
    {
      unsigned int c;
      flagword flags;
      bfd_vma at;

      c = 0;
      for (os = &lang_output_section_statement.head->output_section_statement;
	   os != NULL;
	   os = os->next)
	{
	  lang_output_section_phdr_list *pl;

	  if (os->constraint < 0)
	    continue;

	  pl = os->phdrs;
	  if (pl != NULL)
	    last = pl;
	  else
	    {
	      if (os->sectype == noload_section
		  || os->bfd_section == NULL
		  || (os->bfd_section->flags & SEC_ALLOC) == 0)
		continue;

	      /* Don't add orphans to PT_INTERP header.  */
	      if (l->type == 3)
		continue;

	      if (last == NULL)
		{
		  lang_output_section_statement_type * tmp_os;

		  /* If we have not run across a section with a program
		     header assigned to it yet, then scan forwards to find
		     one.  This prevents inconsistencies in the linker's
		     behaviour when a script has specified just a single
		     header and there are sections in that script which are
		     not assigned to it, and which occur before the first
		     use of that header. See here for more details:
		     http://sourceware.org/ml/binutils/2007-02/msg00291.html  */
		  for (tmp_os = os; tmp_os; tmp_os = tmp_os->next)
		    if (tmp_os->phdrs)
		      {
			last = tmp_os->phdrs;
			break;
		      }
		  if (last == NULL)
		    einfo (_("%F%P: no sections assigned to phdrs\n"));
		}
	      pl = last;
	    }

	  if (os->bfd_section == NULL)
	    continue;

	  for (; pl != NULL; pl = pl->next)
	    {
	      if (strcmp (pl->name, l->name) == 0)
		{
		  if (c >= alc)
		    {
		      alc *= 2;
		      secs = (asection **) xrealloc (secs,
						     alc * sizeof (asection *));
		    }
		  secs[c] = os->bfd_section;
		  ++c;
		  pl->used = TRUE;
		}
	    }
	}

      if (l->flags == NULL)
	flags = 0;
      else
	flags = exp_get_vma (l->flags, 0, "phdr flags");

      if (l->at == NULL)
	at = 0;
      else
	at = exp_get_vma (l->at, 0, "phdr load address");

      if (! bfd_record_phdr (link_info.output_bfd, l->type,
			     l->flags != NULL, flags, l->at != NULL,
			     at, l->filehdr, l->phdrs, c, secs))
	einfo (_("%F%P: bfd_record_phdr failed: %E\n"));
    }

  free (secs);

  /* Make sure all the phdr assignments succeeded.  */
  for (os = &lang_output_section_statement.head->output_section_statement;
       os != NULL;
       os = os->next)
    {
      lang_output_section_phdr_list *pl;

      if (os->constraint < 0
	  || os->bfd_section == NULL)
	continue;

      for (pl = os->phdrs;
	   pl != NULL;
	   pl = pl->next)
	if (! pl->used && strcmp (pl->name, "NONE") != 0)
	  einfo (_("%X%P: section `%s' assigned to non-existent phdr `%s'\n"),
		 os->name, pl->name);
    }
}

/* Record a list of sections which may not be cross referenced.  */

void
lang_add_nocrossref (lang_nocrossref_type *l)
{
  struct lang_nocrossrefs *n;

  n = (struct lang_nocrossrefs *) xmalloc (sizeof *n);
  n->next = nocrossref_list;
  n->list = l;
  nocrossref_list = n;

  /* Set notice_all so that we get informed about all symbols.  */
  link_info.notice_all = TRUE;
}

/* Overlay handling.  We handle overlays with some static variables.  */

/* The overlay virtual address.  */
static etree_type *overlay_vma;
/* And subsection alignment.  */
static etree_type *overlay_subalign;

/* An expression for the maximum section size seen so far.  */
static etree_type *overlay_max;

/* A list of all the sections in this overlay.  */

struct overlay_list {
  struct overlay_list *next;
  lang_output_section_statement_type *os;
};

static struct overlay_list *overlay_list;

/* Start handling an overlay.  */

void
lang_enter_overlay (etree_type *vma_expr, etree_type *subalign)
{
  /* The grammar should prevent nested overlays from occurring.  */
  ASSERT (overlay_vma == NULL
	  && overlay_subalign == NULL
	  && overlay_max == NULL);

  overlay_vma = vma_expr;
  overlay_subalign = subalign;
}

/* Start a section in an overlay.  We handle this by calling
   lang_enter_output_section_statement with the correct VMA.
   lang_leave_overlay sets up the LMA and memory regions.  */

void
lang_enter_overlay_section (const char *name)
{
  struct overlay_list *n;
  etree_type *size;

  lang_enter_output_section_statement (name, overlay_vma, overlay_section,
				       0, overlay_subalign, 0, 0, 0);

  /* If this is the first section, then base the VMA of future
     sections on this one.  This will work correctly even if `.' is
     used in the addresses.  */
  if (overlay_list == NULL)
    overlay_vma = exp_nameop (ADDR, name);

  /* Remember the section.  */
  n = (struct overlay_list *) xmalloc (sizeof *n);
  n->os = current_section;
  n->next = overlay_list;
  overlay_list = n;

  size = exp_nameop (SIZEOF, name);

  /* Arrange to work out the maximum section end address.  */
  if (overlay_max == NULL)
    overlay_max = size;
  else
    overlay_max = exp_binop (MAX_K, overlay_max, size);
}

/* Finish a section in an overlay.  There isn't any special to do
   here.  */

void
lang_leave_overlay_section (fill_type *fill,
			    lang_output_section_phdr_list *phdrs)
{
  const char *name;
  char *clean, *s2;
  const char *s1;
  char *buf;

  name = current_section->name;

  /* For now, assume that DEFAULT_MEMORY_REGION is the run-time memory
     region and that no load-time region has been specified.  It doesn't
     really matter what we say here, since lang_leave_overlay will
     override it.  */
  lang_leave_output_section_statement (fill, DEFAULT_MEMORY_REGION, phdrs, 0);

  /* Define the magic symbols.  */

  clean = (char *) xmalloc (strlen (name) + 1);
  s2 = clean;
  for (s1 = name; *s1 != '\0'; s1++)
    if (ISALNUM (*s1) || *s1 == '_')
      *s2++ = *s1;
  *s2 = '\0';

  buf = (char *) xmalloc (strlen (clean) + sizeof "__load_start_");
  sprintf (buf, "__load_start_%s", clean);
  lang_add_assignment (exp_provide (buf,
				    exp_nameop (LOADADDR, name),
				    FALSE));

  buf = (char *) xmalloc (strlen (clean) + sizeof "__load_stop_");
  sprintf (buf, "__load_stop_%s", clean);
  lang_add_assignment (exp_provide (buf,
				    exp_binop ('+',
					       exp_nameop (LOADADDR, name),
					       exp_nameop (SIZEOF, name)),
				    FALSE));

  free (clean);
}

/* Finish an overlay.  If there are any overlay wide settings, this
   looks through all the sections in the overlay and sets them.  */

void
lang_leave_overlay (etree_type *lma_expr,
		    int nocrossrefs,
		    fill_type *fill,
		    const char *memspec,
		    lang_output_section_phdr_list *phdrs,
		    const char *lma_memspec)
{
  lang_memory_region_type *region;
  lang_memory_region_type *lma_region;
  struct overlay_list *l;
  lang_nocrossref_type *nocrossref;

  lang_get_regions (&region, &lma_region,
		    memspec, lma_memspec,
		    lma_expr != NULL, FALSE);

  nocrossref = NULL;

  /* After setting the size of the last section, set '.' to end of the
     overlay region.  */
  if (overlay_list != NULL)
    {
      overlay_list->os->update_dot = 1;
      overlay_list->os->update_dot_tree
	= exp_assign (".", exp_binop ('+', overlay_vma, overlay_max), FALSE);
    }

  l = overlay_list;
  while (l != NULL)
    {
      struct overlay_list *next;

      if (fill != NULL && l->os->fill == NULL)
	l->os->fill = fill;

      l->os->region = region;
      l->os->lma_region = lma_region;

      /* The first section has the load address specified in the
	 OVERLAY statement.  The rest are worked out from that.
	 The base address is not needed (and should be null) if
	 an LMA region was specified.  */
      if (l->next == 0)
	{
	  l->os->load_base = lma_expr;
	  l->os->sectype = normal_section;
	}
      if (phdrs != NULL && l->os->phdrs == NULL)
	l->os->phdrs = phdrs;

      if (nocrossrefs)
	{
	  lang_nocrossref_type *nc;

	  nc = (lang_nocrossref_type *) xmalloc (sizeof *nc);
	  nc->name = l->os->name;
	  nc->next = nocrossref;
	  nocrossref = nc;
	}

      next = l->next;
      free (l);
      l = next;
    }

  if (nocrossref != NULL)
    lang_add_nocrossref (nocrossref);

  overlay_vma = NULL;
  overlay_list = NULL;
  overlay_max = NULL;
}

/* Version handling.  This is only useful for ELF.  */

/* If PREV is NULL, return first version pattern matching particular symbol.
   If PREV is non-NULL, return first version pattern matching particular
   symbol after PREV (previously returned by lang_vers_match).  */

static struct bfd_elf_version_expr *
lang_vers_match (struct bfd_elf_version_expr_head *head,
		 struct bfd_elf_version_expr *prev,
		 const char *sym)
{
  const char *c_sym;
  const char *cxx_sym = sym;
  const char *java_sym = sym;
  struct bfd_elf_version_expr *expr = NULL;
  enum demangling_styles curr_style;

  curr_style = CURRENT_DEMANGLING_STYLE;
  cplus_demangle_set_style (no_demangling);
  c_sym = bfd_demangle (link_info.output_bfd, sym, DMGL_NO_OPTS);
  if (!c_sym)
    c_sym = sym;
  cplus_demangle_set_style (curr_style);

  if (head->mask & BFD_ELF_VERSION_CXX_TYPE)
    {
      cxx_sym = bfd_demangle (link_info.output_bfd, sym,
			      DMGL_PARAMS | DMGL_ANSI);
      if (!cxx_sym)
	cxx_sym = sym;
    }
  if (head->mask & BFD_ELF_VERSION_JAVA_TYPE)
    {
      java_sym = bfd_demangle (link_info.output_bfd, sym, DMGL_JAVA);
      if (!java_sym)
	java_sym = sym;
    }

  if (head->htab && (prev == NULL || prev->literal))
    {
      struct bfd_elf_version_expr e;

      switch (prev ? prev->mask : 0)
	{
	case 0:
	  if (head->mask & BFD_ELF_VERSION_C_TYPE)
	    {
	      e.pattern = c_sym;
	      expr = (struct bfd_elf_version_expr *)
		  htab_find ((htab_t) head->htab, &e);
	      while (expr && strcmp (expr->pattern, c_sym) == 0)
		if (expr->mask == BFD_ELF_VERSION_C_TYPE)
		  goto out_ret;
		else
		  expr = expr->next;
	    }
	  /* Fallthrough */
	case BFD_ELF_VERSION_C_TYPE:
	  if (head->mask & BFD_ELF_VERSION_CXX_TYPE)
	    {
	      e.pattern = cxx_sym;
	      expr = (struct bfd_elf_version_expr *)
		  htab_find ((htab_t) head->htab, &e);
	      while (expr && strcmp (expr->pattern, cxx_sym) == 0)
		if (expr->mask == BFD_ELF_VERSION_CXX_TYPE)
		  goto out_ret;
		else
		  expr = expr->next;
	    }
	  /* Fallthrough */
	case BFD_ELF_VERSION_CXX_TYPE:
	  if (head->mask & BFD_ELF_VERSION_JAVA_TYPE)
	    {
	      e.pattern = java_sym;
	      expr = (struct bfd_elf_version_expr *)
		  htab_find ((htab_t) head->htab, &e);
	      while (expr && strcmp (expr->pattern, java_sym) == 0)
		if (expr->mask == BFD_ELF_VERSION_JAVA_TYPE)
		  goto out_ret;
		else
		  expr = expr->next;
	    }
	  /* Fallthrough */
	default:
	  break;
	}
    }

  /* Finally, try the wildcards.  */
  if (prev == NULL || prev->literal)
    expr = head->remaining;
  else
    expr = prev->next;
  for (; expr; expr = expr->next)
    {
      const char *s;

      if (!expr->pattern)
	continue;

      if (expr->pattern[0] == '*' && expr->pattern[1] == '\0')
	break;

      if (expr->mask == BFD_ELF_VERSION_JAVA_TYPE)
	s = java_sym;
      else if (expr->mask == BFD_ELF_VERSION_CXX_TYPE)
	s = cxx_sym;
      else
	s = c_sym;
      if (fnmatch (expr->pattern, s, 0) == 0)
	break;
    }

 out_ret:
  if (c_sym != sym)
    free ((char *) c_sym);
  if (cxx_sym != sym)
    free ((char *) cxx_sym);
  if (java_sym != sym)
    free ((char *) java_sym);
  return expr;
}

/* Return NULL if the PATTERN argument is a glob pattern, otherwise,
   return a pointer to the symbol name with any backslash quotes removed.  */

static const char *
realsymbol (const char *pattern)
{
  const char *p;
  bfd_boolean changed = FALSE, backslash = FALSE;
  char *s, *symbol = (char *) xmalloc (strlen (pattern) + 1);

  for (p = pattern, s = symbol; *p != '\0'; ++p)
    {
      /* It is a glob pattern only if there is no preceding
	 backslash.  */
      if (backslash)
	{
	  /* Remove the preceding backslash.  */
	  *(s - 1) = *p;
	  backslash = FALSE;
	  changed = TRUE;
	}
      else
	{
	  if (*p == '?' || *p == '*' || *p == '[')
	    {
	      free (symbol);
	      return NULL;
	    }

	  *s++ = *p;
	  backslash = *p == '\\';
	}
    }

  if (changed)
    {
      *s = '\0';
      return symbol;
    }
  else
    {
      free (symbol);
      return pattern;
    }
}

/* This is called for each variable name or match expression.  NEW_NAME is
   the name of the symbol to match, or, if LITERAL_P is FALSE, a glob
   pattern to be matched against symbol names.  */

struct bfd_elf_version_expr *
lang_new_vers_pattern (struct bfd_elf_version_expr *orig,
		       const char *new_name,
		       const char *lang,
		       bfd_boolean literal_p)
{
  struct bfd_elf_version_expr *ret;

  ret = (struct bfd_elf_version_expr *) xmalloc (sizeof *ret);
  ret->next = orig;
  ret->symver = 0;
  ret->script = 0;
  ret->literal = TRUE;
  ret->pattern = literal_p ? new_name : realsymbol (new_name);
  if (ret->pattern == NULL)
    {
      ret->pattern = new_name;
      ret->literal = FALSE;
    }

  if (lang == NULL || strcasecmp (lang, "C") == 0)
    ret->mask = BFD_ELF_VERSION_C_TYPE;
  else if (strcasecmp (lang, "C++") == 0)
    ret->mask = BFD_ELF_VERSION_CXX_TYPE;
  else if (strcasecmp (lang, "Java") == 0)
    ret->mask = BFD_ELF_VERSION_JAVA_TYPE;
  else
    {
      einfo (_("%X%P: unknown language `%s' in version information\n"),
	     lang);
      ret->mask = BFD_ELF_VERSION_C_TYPE;
    }

  return ldemul_new_vers_pattern (ret);
}

/* This is called for each set of variable names and match
   expressions.  */

struct bfd_elf_version_tree *
lang_new_vers_node (struct bfd_elf_version_expr *globals,
		    struct bfd_elf_version_expr *locals)
{
  struct bfd_elf_version_tree *ret;

  ret = (struct bfd_elf_version_tree *) xcalloc (1, sizeof *ret);
  ret->globals.list = globals;
  ret->locals.list = locals;
  ret->match = lang_vers_match;
  ret->name_indx = (unsigned int) -1;
  return ret;
}

/* This static variable keeps track of version indices.  */

static int version_index;

static hashval_t
version_expr_head_hash (const void *p)
{
  const struct bfd_elf_version_expr *e =
      (const struct bfd_elf_version_expr *) p;

  return htab_hash_string (e->pattern);
}

static int
version_expr_head_eq (const void *p1, const void *p2)
{
  const struct bfd_elf_version_expr *e1 =
      (const struct bfd_elf_version_expr *) p1;
  const struct bfd_elf_version_expr *e2 =
      (const struct bfd_elf_version_expr *) p2;

  return strcmp (e1->pattern, e2->pattern) == 0;
}

static void
lang_finalize_version_expr_head (struct bfd_elf_version_expr_head *head)
{
  size_t count = 0;
  struct bfd_elf_version_expr *e, *next;
  struct bfd_elf_version_expr **list_loc, **remaining_loc;

  for (e = head->list; e; e = e->next)
    {
      if (e->literal)
	count++;
      head->mask |= e->mask;
    }

  if (count)
    {
      head->htab = htab_create (count * 2, version_expr_head_hash,
				version_expr_head_eq, NULL);
      list_loc = &head->list;
      remaining_loc = &head->remaining;
      for (e = head->list; e; e = next)
	{
	  next = e->next;
	  if (!e->literal)
	    {
	      *remaining_loc = e;
	      remaining_loc = &e->next;
	    }
	  else
	    {
	      void **loc = htab_find_slot ((htab_t) head->htab, e, INSERT);

	      if (*loc)
		{
		  struct bfd_elf_version_expr *e1, *last;

		  e1 = (struct bfd_elf_version_expr *) *loc;
		  last = NULL;
		  do
		    {
		      if (e1->mask == e->mask)
			{
			  last = NULL;
			  break;
			}
		      last = e1;
		      e1 = e1->next;
		    }
		  while (e1 && strcmp (e1->pattern, e->pattern) == 0);

		  if (last == NULL)
		    {
		      /* This is a duplicate.  */
		      /* FIXME: Memory leak.  Sometimes pattern is not
			 xmalloced alone, but in larger chunk of memory.  */
		      /* free (e->pattern); */
		      free (e);
		    }
		  else
		    {
		      e->next = last->next;
		      last->next = e;
		    }
		}
	      else
		{
		  *loc = e;
		  *list_loc = e;
		  list_loc = &e->next;
		}
	    }
	}
      *remaining_loc = NULL;
      *list_loc = head->remaining;
    }
  else
    head->remaining = head->list;
}

/* This is called when we know the name and dependencies of the
   version.  */

void
lang_register_vers_node (const char *name,
			 struct bfd_elf_version_tree *version,
			 struct bfd_elf_version_deps *deps)
{
  struct bfd_elf_version_tree *t, **pp;
  struct bfd_elf_version_expr *e1;

  if (name == NULL)
    name = "";

  if (link_info.version_info != NULL
      && (name[0] == '\0' || link_info.version_info->name[0] == '\0'))
    {
      einfo (_("%X%P: anonymous version tag cannot be combined"
	       " with other version tags\n"));
      free (version);
      return;
    }

  /* Make sure this node has a unique name.  */
  for (t = link_info.version_info; t != NULL; t = t->next)
    if (strcmp (t->name, name) == 0)
      einfo (_("%X%P: duplicate version tag `%s'\n"), name);

  lang_finalize_version_expr_head (&version->globals);
  lang_finalize_version_expr_head (&version->locals);

  /* Check the global and local match names, and make sure there
     aren't any duplicates.  */

  for (e1 = version->globals.list; e1 != NULL; e1 = e1->next)
    {
      for (t = link_info.version_info; t != NULL; t = t->next)
	{
	  struct bfd_elf_version_expr *e2;

	  if (t->locals.htab && e1->literal)
	    {
	      e2 = (struct bfd_elf_version_expr *)
		  htab_find ((htab_t) t->locals.htab, e1);
	      while (e2 && strcmp (e1->pattern, e2->pattern) == 0)
		{
		  if (e1->mask == e2->mask)
		    einfo (_("%X%P: duplicate expression `%s'"
			     " in version information\n"), e1->pattern);
		  e2 = e2->next;
		}
	    }
	  else if (!e1->literal)
	    for (e2 = t->locals.remaining; e2 != NULL; e2 = e2->next)
	      if (strcmp (e1->pattern, e2->pattern) == 0
		  && e1->mask == e2->mask)
		einfo (_("%X%P: duplicate expression `%s'"
			 " in version information\n"), e1->pattern);
	}
    }

  for (e1 = version->locals.list; e1 != NULL; e1 = e1->next)
    {
      for (t = link_info.version_info; t != NULL; t = t->next)
	{
	  struct bfd_elf_version_expr *e2;

	  if (t->globals.htab && e1->literal)
	    {
	      e2 = (struct bfd_elf_version_expr *)
		  htab_find ((htab_t) t->globals.htab, e1);
	      while (e2 && strcmp (e1->pattern, e2->pattern) == 0)
		{
		  if (e1->mask == e2->mask)
		    einfo (_("%X%P: duplicate expression `%s'"
			     " in version information\n"),
			   e1->pattern);
		  e2 = e2->next;
		}
	    }
	  else if (!e1->literal)
	    for (e2 = t->globals.remaining; e2 != NULL; e2 = e2->next)
	      if (strcmp (e1->pattern, e2->pattern) == 0
		  && e1->mask == e2->mask)
		einfo (_("%X%P: duplicate expression `%s'"
			 " in version information\n"), e1->pattern);
	}
    }

  version->deps = deps;
  version->name = name;
  if (name[0] != '\0')
    {
      ++version_index;
      version->vernum = version_index;
    }
  else
    version->vernum = 0;

  for (pp = &link_info.version_info; *pp != NULL; pp = &(*pp)->next)
    ;
  *pp = version;
}

/* This is called when we see a version dependency.  */

struct bfd_elf_version_deps *
lang_add_vers_depend (struct bfd_elf_version_deps *list, const char *name)
{
  struct bfd_elf_version_deps *ret;
  struct bfd_elf_version_tree *t;

  ret = (struct bfd_elf_version_deps *) xmalloc (sizeof *ret);
  ret->next = list;

  for (t = link_info.version_info; t != NULL; t = t->next)
    {
      if (strcmp (t->name, name) == 0)
	{
	  ret->version_needed = t;
	  return ret;
	}
    }

  einfo (_("%X%P: unable to find version dependency `%s'\n"), name);

  ret->version_needed = NULL;
  return ret;
}

static void
lang_do_version_exports_section (void)
{
  struct bfd_elf_version_expr *greg = NULL, *lreg;

  LANG_FOR_EACH_INPUT_STATEMENT (is)
    {
      asection *sec = bfd_get_section_by_name (is->the_bfd, ".exports");
      char *contents, *p;
      bfd_size_type len;

      if (sec == NULL)
	continue;

      len = sec->size;
      contents = (char *) xmalloc (len);
      if (!bfd_get_section_contents (is->the_bfd, sec, contents, 0, len))
	einfo (_("%X%P: unable to read .exports section contents\n"), sec);

      p = contents;
      while (p < contents + len)
	{
	  greg = lang_new_vers_pattern (greg, p, NULL, FALSE);
	  p = strchr (p, '\0') + 1;
	}

      /* Do not free the contents, as we used them creating the regex.  */

      /* Do not include this section in the link.  */
      sec->flags |= SEC_EXCLUDE | SEC_KEEP;
    }

  lreg = lang_new_vers_pattern (NULL, "*", NULL, FALSE);
  lang_register_vers_node (command_line.version_exports_section,
			   lang_new_vers_node (greg, lreg), NULL);
}

void
lang_add_unique (const char *name)
{
  struct unique_sections *ent;

  for (ent = unique_section_list; ent; ent = ent->next)
    if (strcmp (ent->name, name) == 0)
      return;

  ent = (struct unique_sections *) xmalloc (sizeof *ent);
  ent->name = xstrdup (name);
  ent->next = unique_section_list;
  unique_section_list = ent;
}

/* Append the list of dynamic symbols to the existing one.  */

void
lang_append_dynamic_list (struct bfd_elf_version_expr *dynamic)
{
  if (link_info.dynamic_list)
    {
      struct bfd_elf_version_expr *tail;
      for (tail = dynamic; tail->next != NULL; tail = tail->next)
	;
      tail->next = link_info.dynamic_list->head.list;
      link_info.dynamic_list->head.list = dynamic;
    }
  else
    {
      struct bfd_elf_dynamic_list *d;

      d = (struct bfd_elf_dynamic_list *) xcalloc (1, sizeof *d);
      d->head.list = dynamic;
      d->match = lang_vers_match;
      link_info.dynamic_list = d;
    }
}

/* Append the list of C++ typeinfo dynamic symbols to the existing
   one.  */

void
lang_append_dynamic_list_cpp_typeinfo (void)
{
  const char * symbols [] =
    {
      "typeinfo name for*",
      "typeinfo for*"
    };
  struct bfd_elf_version_expr *dynamic = NULL;
  unsigned int i;

  for (i = 0; i < ARRAY_SIZE (symbols); i++)
    dynamic = lang_new_vers_pattern (dynamic, symbols [i], "C++",
				     FALSE);

  lang_append_dynamic_list (dynamic);
}

/* Append the list of C++ operator new and delete dynamic symbols to the
   existing one.  */

void
lang_append_dynamic_list_cpp_new (void)
{
  const char * symbols [] =
    {
      "operator new*",
      "operator delete*"
    };
  struct bfd_elf_version_expr *dynamic = NULL;
  unsigned int i;

  for (i = 0; i < ARRAY_SIZE (symbols); i++)
    dynamic = lang_new_vers_pattern (dynamic, symbols [i], "C++",
				     FALSE);

  lang_append_dynamic_list (dynamic);
}

/* Scan a space and/or comma separated string of features.  */

void
lang_ld_feature (char *str)
{
  char *p, *q;

  p = str;
  while (*p)
    {
      char sep;
      while (*p == ',' || ISSPACE (*p))
	++p;
      if (!*p)
	break;
      q = p + 1;
      while (*q && *q != ',' && !ISSPACE (*q))
	++q;
      sep = *q;
      *q = 0;
      if (strcasecmp (p, "SANE_EXPR") == 0)
	config.sane_expr = TRUE;
      else
	einfo (_("%X%P: unknown feature `%s'\n"), p);
      *q = sep;
      p = q;
    }
}
@


1.406
log
@	* ldlang.c (load_symbols): Report "error adding symbols" on
	bfd_link_add_symbols failure.
	* emultempl/elf32.em (gld${EMULATION_NAME}_try_needed): Likewise.
	* emultempl/sunos.em (gld${EMULATION_NAME}_after_open): Likewise.
	(gld${EMULATION_NAME}_try_needed): Likewise.
@
text
@d2 1
a2 3
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012
   Free Software Foundation, Inc.
d1780 1
a1780 1
					    NULL, NULL, NULL, constraint);
d4968 2
a4969 2
		   statement.  */
		if (os->lma_region != os->region)
d6236 2
a6237 1
				     int constraint)
d6259 4
d7313 1
a7313 1
				       0, overlay_subalign, 0, 0);
@


1.405
log
@	PR ld/15222
ld/
	* ldlang.c (lang_size_sections_1): When given an lma_region align
	LMA as per VMA only if lma_region is the same as region.
ld/testsuite/
	* ld-scripts/rgn-at6.s, * ld-scripts/rgn-at6.t, * ld-scripts/rgn-at6.d,
	* ld-scripts/rgn-at7.t, * ld-scripts/rgn-at7.d: New tests.
@
text
@d2784 1
a2784 1
		  einfo (_("%F%B: could not read symbols: %E\n"), member);
d2798 1
a2798 1
    einfo (_("%F%B: could not read symbols: %E\n"), entry->the_bfd);
@


1.404
log
@	* ldlang.c (get_init_priority): Comment typo.
	(lang_finish): Free link_info.hash and lang_definedness_table.
	(lang_end): Delete lang_definedness_table comment.
@
text
@d4966 7
@


1.403
log
@	PR ld/14962
	* ldexp.h (struct ldexp_control): Add "assign_name".
	* ldexp.c (fold_name <NAME>): Compare and clear assign_name on match.
	(exp_fold_tree_1): Remove existing code testing for self assignment.
	Instead set and test expld.assign_name.
	* ldlang.c (scan_for_self_assignment): Delete.
	(print_assignment): Instead set and test expld.assign_name.
@
text
@d390 1
a390 1
     2: .ctors.NNNN/.ctors.NNNN: Where NNNN is 65535 minus the
d1243 2
a5821 3

  /* Don't bfd_hash_table_free (&lang_definedness_table);
     map file output may result in a call of lang_track_definedness.  */
@


1.402
log
@ld/
	* ld.h (ld_config_type): New flag member separate_code.
	* emultempl/elf32.em
	(gld${EMULATION_NAME}_before_parse): Set it based on $SEPARATE_CODE.
	* ldlang.c (ldlang_override_segment_assignment): If it's set, then
	always return TRUE when SEC_CODE differs between the sections.
@
text
@a3953 50
/* Scan for the use of the destination in the right hand side
   of an expression.  In such cases we will not compute the
   correct expression, since the value of DST that is used on
   the right hand side will be its final value, not its value
   just before this expression is evaluated.  */

static bfd_boolean
scan_for_self_assignment (const char * dst, etree_type * rhs)
{
  if (rhs == NULL || dst == NULL)
    return FALSE;

  switch (rhs->type.node_class)
    {
    case etree_binary:
      return (scan_for_self_assignment (dst, rhs->binary.lhs)
	      || scan_for_self_assignment (dst, rhs->binary.rhs));

    case etree_trinary:
      return (scan_for_self_assignment (dst, rhs->trinary.lhs)
	      || scan_for_self_assignment (dst, rhs->trinary.rhs));

    case etree_assign:
    case etree_provided:
    case etree_provide:
      if (strcmp (dst, rhs->assign.dst) == 0)
	return TRUE;
      return scan_for_self_assignment (dst, rhs->assign.src);

    case etree_unary:
      return scan_for_self_assignment (dst, rhs->unary.child);

    case etree_value:
      if (rhs->value.str)
	return strcmp (dst, rhs->value.str) == 0;
      return FALSE;

    case etree_name:
      if (rhs->name.name)
	return strcmp (dst, rhs->name.name) == 0;
      return FALSE;

    default:
      break;
    }

  return FALSE;
}


a3959 1
  bfd_boolean computation_is_valid = TRUE;
a3969 1
      computation_is_valid = TRUE;
d3976 1
a3977 1
      computation_is_valid = is_dot || !scan_for_self_assignment (dst, tree);
d3988 3
a3990 1
      if (computation_is_valid)
d4026 1
@


1.401
log
@	* ldlang.c (insert_pad): Correct output section size calculation.
	(lang_size_sections_1): Likewise for lang_data_statement and
	lang_reloc_statement.
@
text
@d881 2
a882 2
                                 (lang_input_statement_type *) member->usrdata,
                                 callback, data);
d1053 1
a1053 1
          stat_alloc (sizeof (lang_input_statement_type));
d1151 1
a1151 1
                                                           sizeof (*ret));
d1286 6
a1291 6
        {
          if (create)
            einfo (_("%P:%S: warning: redeclaration of memory region `%s'\n"),
                   NULL, name);
          return r;
        }
d1337 6
a1342 6
        if (region == NULL && strcmp (n->name, region_name) == 0)
          region = r;
        if (strcmp (n->name, alias) == 0)
          einfo (_("%F%P:%S: error: redefinition of memory region "
                   "alias `%s'\n"),
                 NULL, alias);
d1348 2
a1349 2
             "for alias `%s' does not exist\n"),
           NULL, region_name, alias);
d1780 1
a1780 1
                                            NULL, NULL, NULL, constraint);
d2083 1
a2083 1
          get_userdata (hash_entry->u.def.section);
d2090 1
a2090 1
              get_userdata (hash_entry->u.def.section);
d2128 1
a2128 1
        stat_alloc (sizeof (fat_section_userdata_type));
d2267 1
a2267 1
        return;
d4154 1
a4154 1
         hash_entry_addr_cmp);
d4586 1
a4586 1
          stat_alloc (sizeof (lang_padding_statement_type));
d5364 6
d7246 1
a7246 1
                                                     alc * sizeof (asection *));
d7548 1
a7548 1
                  htab_find ((htab_t) head->htab, &e);
d7561 1
a7561 1
                  htab_find ((htab_t) head->htab, &e);
d7574 1
a7574 1
                  htab_find ((htab_t) head->htab, &e);
d7871 1
a7871 1
                  htab_find ((htab_t) t->locals.htab, e1);
d7898 1
a7898 1
                  htab_find ((htab_t) t->globals.htab, e1);
@


1.400
log
@	bfd/
	* elflink.c (bfd_elf_record_link_assignment): Remove --defsym
	symbols special case.

	ld/
	* ldexp.h (etree_union): Add defsym member to the assign member
	structure.
	(exp_assign): Add hidden argument to prototype.
	* ldexp.c (exp_fold_tree_1): Use the defsym member to handle
	--defsym symbols.
	(exp_assop): Add defsym argument, initialize the defsym member
	of the assign structure.
	(exp_assign): Handle hidden symbols.
	(exp_defsym): Update to use the defsym argument to exp_assop.
	(exp_provide): Update to handle the defsym argument to exp_assop.
	* ldlex.l (HIDDEN): New token.
	* ldgram.y (HIDDEN): Likewise.
	(assignment, section): Update calls to exp_assign.
	* ldctor.c (ldctor_build_sets): Likewise.
	* mri.c (mri_format): Likewise.
	* ldlang.c (lang_insert_orphan, lang_leave_overlay): Likewise.
	(open_input_bfds): Remove --defsym symbols special case.
	* emultempl/beos.em (gld_${EMULATION_NAME}_set_symbols): Update
	call to exp_assign.
	* emultempl/pe.em (gld_${EMULATION_NAME}_set_symbols): Likewise.
	* emultempl/pep.em (gld_${EMULATION_NAME}_set_symbols): Likewise.
	* emultempl/spuelf.em (spu_place_special_section): Likewise.
	* emultempl/xtensaelf.em (ld_xtensa_insert_page_offsets):
	Likewise.
	* ld.texinfo (Assigning Values to Symbols): Add HIDDEN.
	(HIDDEN): New subsection.
@
text
@d4597 2
a4598 1
  output_section->size += alignment_needed;
d5163 3
a5165 1
	    output_section_statement->bfd_section->size += size;
d5179 2
a5180 1
	    output_section_statement->bfd_section->size += size;
@


1.399
log
@Properly handle by_none
@
text
@d3289 1
a3289 1
	  if (s->assignment_statement.exp->assign.hidden)
d7440 1
a7440 1
	= exp_assign (".", exp_binop ('+', overlay_vma, overlay_max));
@


1.398
log
@Don't call compare_section in case of by_none

	PR ld/14156
	* ldlang.c (wild_sort): Don't call compare_section in case of
	by_none.

	* scripttempl/elf.sc: Add SORT_NONE to .init and .fini sections.
	* scripttempl/elf32msp430.sc: Likewise.
	* scripttempl/elf32msp430_3.sc: Likewise.
	* scripttempl/elfd10v.sc: Likewise.
	* scripttempl/elfd30v.sc: Likewise.
	* scripttempl/elfxtensa.sc: Likewise.
@
text
@a3514 2
		    case by_none:
		      sec->spec.sorted = none;
@


1.397
log
@	PR ld/14357
	* ldmain.c (trace_file_tries): Rename to 'verbose'.
	* ldfile.c: Likewise.
	* ldlang.c: Likewise.
	* ldmain.h: Likewise.
	* lexsup.c: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultemp/spuelf.em: Likewise.
	* pe-dll.c (pe_dll_generate_implib): Only print creation message
	in verbose mode.
@
text
@d2465 3
a2467 1
      if (sec != NULL && sec->spec.sorted != none)
@


1.397.2.1
log
@Properly handle by_none

	Backport from mainline

	PR ld/14156
	* ldlang.c (wild_sort): Properly handle by_none.

	* scripttempl/elf.sc: Add SORT_NONE to .init and .fini sections.
	* scripttempl/elf32msp430.sc: Likewise.
	* scripttempl/elf32msp430_3.sc: Likewise.
	* scripttempl/elfd10v.sc: Likewise.
	* scripttempl/elfd30v.sc: Likewise.
	* scripttempl/elfxtensa.sc: Likewise.
@
text
@d2465 1
a2465 3
      if (sec != NULL
	  && sec->spec.sorted != none
	  && sec->spec.sorted != by_none)
d3513 2
@


1.397.2.2
log
@bfd/
2012-08-09  Maciej W. Rozycki  <macro@@codesourcery.com>

	* elfxx-mips.c (LA25_LUI_MICROMIPS_1, LA25_LUI_MICROMIPS_2):
	Remove macros, folding them into...
	(LA25_LUI_MICROMIPS): ... this new macro.
	(LA25_J_MICROMIPS_1, LA25_J_MICROMIPS_2): Likewise into...
	(LA25_J_MICROMIPS): ... this new macro.
	(LA25_ADDIU_MICROMIPS_1, LA25_ADDIU_MICROMIPS_2): Likewise
	into...
	(LA25_ADDIU_MICROMIPS): ... this new macro.
	(bfd_put_micromips_32, bfd_get_micromips_32): New functions.
	(mips_elf_create_la25_stub): Use them.
	(check_br32_dslot, check_br32, check_relocated_bzc): Likewise.
	(_bfd_mips_elf_relax_section): Likewise.

gas/
	* config/tc-mips.c (NO_ISA_COP, COP_INSN): Remove macros.
	(is_opcode_valid): Remove coprocessor instruction exclusions.
	Replace OPCODE_IS_MEMBER with opcode_is_member.
	(is_opcode_valid_16): Replace OPCODE_IS_MEMBER with
	opcode_is_member.
	(macro): Remove coprocessor instruction exclusions.

gas/
	* gas/mips/mips.exp: Set has_newabi for all Linux targets.
	* gas/mips/cfi-n64-1.d: Adjust for targets that do not infer the
	ISA from the ABI.
	* gas/mips/elf-rel-got-n32.d: Likewise.
	* gas/mips/elf-rel-got-n64.d: Likewise.
	* gas/mips/elf-rel-xgot-n32.d: Likewise.
	* gas/mips/elf-rel-xgot-n64.d: Likewise.
	* gas/mips/elf-rel18.d: Likewise.
	* gas/mips/elf-rel28-n32.d: Likewise.
	* gas/mips/elf-rel28-n64.d: Likewise.
	* gas/mips/jal-newabi.d: Likewise.
	* gas/mips/ldstla-n64-shared.d: Likewise.
	* gas/mips/ldstla-n64-sym32.d: Likewise.
	* gas/mips/ldstla-n64.d: Likewise.
	* gas/mips/macro-warn-1-n32.d: Likewise.
	* gas/mips/macro-warn-2-n32.d: Likewise.
	* gas/mips/n32-consec.d: Likewise.

include/
2012-08-13  Richard Sandiford  <rdsandiford@@googlemail.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

	* mips.h (mips_opcode): Add the exclusions field.
	(OPCODE_IS_MEMBER): Remove macro.
	(cpu_is_member): New inline function.
	(opcode_is_member): Likewise.

ld/
	* emulparams/elf32bmip.sh: Make _gp hidden.
	* emulparams/elf32bmipn32-defs.sh: Likewise.
	* emulparams/elf32mipswindiss.sh: Likewise.
	* scripttempl/mips.sc: Likewise.

ld/
2012-08-28  Maciej W. Rozycki  <macro@@codesourcery.com>

	* ld-elf/export-class.sd: New test.
	* ld-elf/export-class.vd: New test.
	* ld-elf/export-class-def.s: New test source.
	* ld-elf/export-class-dep.s: New test source.
	* ld-elf/export-class-lib.s: New test source.
	* ld-elf/export-class-ref.s: New test source.
	* ld-elf/export-class-lib.ver: New test version script.
	* ld-elf/export-class.exp: New test script.
	* ld-arm/arm-export-class.rd: New test.
	* ld-arm/arm-export-class.xd: New test.
	* ld-arm/export-class.exp: New test script.
	* ld-i386/i386-export-class.rd: New test.
	* ld-i386/i386-export-class.xd: New test.
	* ld-i386/export-class.exp: New test script.
	* ld-mips-elf/mips-32-export-class.rd: New test.
	* ld-mips-elf/mips-32-export-class.xd: New test.
	* ld-mips-elf/mips-64-export-class.rd: New test.
	* ld-mips-elf/mips-64-export-class.xd: New test.
	* ld-mips-elf/export-class.exp: New test script.
	* ld-powerpc/powerpc-32-export-class.rd: New test.
	* ld-powerpc/powerpc-32-export-class.xd: New test.
	* ld-powerpc/powerpc-64-export-class.rd: New test.
	* ld-powerpc/powerpc-64-export-class.xd: New test.
	* ld-powerpc/export-class.exp: New test script.
	* ld-x86-64/x86-64-64-export-class.rd: New test.
	* ld-x86-64/x86-64-x32-export-class.rd: New test.
	* ld-x86-64/export-class.exp: New test script.

opcodes/
2012-08-14  Maciej W. Rozycki  <macro@@codesourcery.com>

	* mips-dis.c (print_insn_args): Add GET_OP and GET_OP_S local
	macros, use local variables for info struct member accesses,
	update the type of the variable used to hold the instruction
	word.
	(print_insn_mips, print_mips16_insn_arg): Likewise.
	(print_insn_mips16): Add GET_OP and GET_OP_S local macros, use
	local variables for info struct member accesses.
	(print_insn_micromips): Add GET_OP_S local macro.
	(_print_insn_mips): Update the type of the variable used to hold
	the instruction word.
@
text
@d3289 1
a3289 1
	  if (s->assignment_statement.exp->assign.defsym)
d7440 1
a7440 1
	= exp_assign (".", exp_binop ('+', overlay_vma, overlay_max), FALSE);
@


1.397.2.3
log
@ld/
	* ld.h (ld_config_type): New flag member separate_code.
	* emultempl/elf32.em
	(gld${EMULATION_NAME}_before_parse): Set it based on $SEPARATE_CODE.
	* ldlang.c (ldlang_override_segment_assignment): If it's set, then
	always return TRUE when SEC_CODE differs between the sections.
@
text
@d881 2
a882 2
				 (lang_input_statement_type *) member->usrdata,
				 callback, data);
d1053 1
a1053 1
	  stat_alloc (sizeof (lang_input_statement_type));
d1151 1
a1151 1
							   sizeof (*ret));
d1286 6
a1291 6
	{
	  if (create)
	    einfo (_("%P:%S: warning: redeclaration of memory region `%s'\n"),
		   NULL, name);
	  return r;
	}
d1337 6
a1342 6
	if (region == NULL && strcmp (n->name, region_name) == 0)
	  region = r;
	if (strcmp (n->name, alias) == 0)
	  einfo (_("%F%P:%S: error: redefinition of memory region "
		   "alias `%s'\n"),
		 NULL, alias);
d1348 2
a1349 2
	     "for alias `%s' does not exist\n"),
	   NULL, region_name, alias);
d1780 1
a1780 1
					    NULL, NULL, NULL, constraint);
d2083 1
a2083 1
	  get_userdata (hash_entry->u.def.section);
d2090 1
a2090 1
	      get_userdata (hash_entry->u.def.section);
d2128 1
a2128 1
	stat_alloc (sizeof (fat_section_userdata_type));
d2267 1
a2267 1
	return;
d4154 1
a4154 1
	 hash_entry_addr_cmp);
d4586 1
a4586 1
	  stat_alloc (sizeof (lang_padding_statement_type));
a5359 6
  /* If this flag is set, the target never wants code and non-code
     sections comingled in the same segment.  */
  if (config.separate_code
      && ((current_section->flags ^ previous_section->flags) & SEC_CODE))
    return TRUE;

d7236 1
a7236 1
						     alc * sizeof (asection *));
d7538 1
a7538 1
		  htab_find ((htab_t) head->htab, &e);
d7551 1
a7551 1
		  htab_find ((htab_t) head->htab, &e);
d7564 1
a7564 1
		  htab_find ((htab_t) head->htab, &e);
d7861 1
a7861 1
		  htab_find ((htab_t) t->locals.htab, e1);
d7888 1
a7888 1
		  htab_find ((htab_t) t->globals.htab, e1);
@


1.397.2.4
log
@	PR 12549
	PR 14493
	PR 14567
	PR 14662
	PR 14758
	PR 14813
	PR 14904
	PR 14915
	PR 14926
	PR 14950
	PR 14962
	Apply mainline patches
@
text
@d3954 50
d4010 1
d4021 1
a4027 1
      expld.assign_name = dst;
d4029 1
d4040 1
a4040 3
      if (assignment->exp->type.node_class == etree_assert
	  || is_dot
	  || expld.assign_name != NULL)
a4075 1
  expld.assign_name = NULL;
d4597 1
a4597 2
  output_section->size = TO_SIZE (dot + TO_ADDR (alignment_needed)
				  - output_section->vma);
d5162 1
a5162 3
	    output_section_statement->bfd_section->size
	      = TO_SIZE (dot - output_section_statement->bfd_section->vma);

d5176 1
a5176 2
	    output_section_statement->bfd_section->size
	      = TO_SIZE (dot - output_section_statement->bfd_section->vma);
@


1.397.2.5
log
@	PR ld/15222
ld/
	* ldlang.c (lang_size_sections_1): When given an lma_region align
	LMA as per VMA only if lma_region is the same as region.
ld/testsuite/
	* ld-scripts/rgn-at6.s, * ld-scripts/rgn-at6.t, * ld-scripts/rgn-at6.d,
	* ld-scripts/rgn-at7.t, * ld-scripts/rgn-at7.d: New tests.
@
text
@a4963 7
		/* When LMA_REGION is the same as REGION, align the LMA
		   as we did for the VMA, possibly including alignment
		   from the bfd section.  If a different region, then
		   only align according to the value in the output
		   statement.  */
		if (os->lma_region != os->region)
		  section_alignment = os->section_alignment;
@


1.396
log
@Add SORT_NONE and don't sort sort .init/.fini sections

ld/

	PR ld/14156
	* NEWS: Mention SORT_NONE.

	* ld.h (sort_type): Add by_none.

	* ld.texinfo: Document SORT_NONE.

	* ldgram.y: Handle SORT_NONE.

	* ldlang.c (update_wild_statements): Handle by_none.  Don't
	sort .init/.fini sections.

	* ldlex.l: Add SORT_NONE.

ld/testsuite/

	PR ld/14156
	* ld-elf/fini0.s: New file.
	* ld-elf/fini1.s: Likewise.
	* ld-elf/fini2.s: Likewise.
	* ld-elf/fini3.s: Likewise.
	* ld-elf/finin.s: Likewise.
	* ld-elf/foo0.s: Likewise.
	* ld-elf/foo1.s: Likewise.
	* ld-elf/foo2.s: Likewise.
	* ld-elf/foo3.s: Likewise.
	* ld-elf/foon.s: Likewise.
	* ld-elf/init0.s: Likewise.
	* ld-elf/init1.s: Likewise.
	* ld-elf/init2.s: Likewise.
	* ld-elf/init3.s: Likewise.
	* ld-elf/initn.s: Likewise.
	* ld-elf/pr14156a.d: Likewise.
	* ld-elf/pr14156b.d: Likewise.
	* ld-elf/pr14156c.d: Likewise.
	* ld-elf/pr14156c.t: Likewise.
@
text
@d2743 1
a2743 1
      if (trace_files || trace_file_tries)
@


1.395
log
@Remove redundant statement

	* ldlang.c (update_wild_statements): Remove redundant statement.
@
text
@d3513 2
d3526 5
a3530 2
	      update_wild_statements
		(s->output_section_statement.children.head);
@


1.394
log
@	* ldlang.c (load_symbols): Close file and set flags.loaded
	after parsing script file.
	(open_input_bfds): Don't segv on closed script.
@
text
@a3496 1
	      sec = s->wild_statement.section_list;
@


1.393
log
@ld/
	* ldlang.c (lang_insert_orphan): Don't make __start_<sec> symbol
	absolute, and remove unnecessary alignment.
ld/testsuite/
	* ld-gc/start.d: Update.
@
text
@d2671 1
d2719 3
d3231 1
d3241 1
@


1.392
log
@ld/
	* ldlang.h (lang_output_section_statement_type): Add after_end field.
	(lang_abs_symbol_at_beginning_of, lang_abs_symbol_at_end_of): Delete.
	(section_for_dot): Declare.
	* ldlang.c (lang_size_sections_1): Correct comment.
	(current_section): Move earlier.
	(current_assign, prefer_next_section): New static vars.
	(lang_do_assignments_1): Add found_end param.  Detect _end
	assignment to set found_end.  Set os->after_end.  Set above statics.
	(lang_do_assignments): Adjust lang_do_assignments_1 call.  Init
	vars.
	(section_for_dot): New function.
	(lang_set_startof): Don't make an absolute symbol.
	(lang_abs_symbol_at_beginning_of, lang_abs_symbol_at_end_of): Delete.
	* ldexp.c (new_rel_from_abs): Use section_for_dot.
	* emultempl/lnk960.em (symbol_at_beginning_of): New function.
	(symbol_at_end_of): Likewise.
	(lnk960_after_allocation): Use them.
	* scripttempl/elf.sc: Precede OTHER_GOT_SYMBOLS with . = .; and
	likewise before __bss_start.

ld/testsuite/
Update far too many tests.
@
text
@a1792 1
	  etree_type *e_align;
a1796 3
	  e_align = exp_unop (ALIGN_K,
			      exp_intop ((bfd_vma) 1 << s->alignment_power));
	  lang_add_assignment (exp_assign (".", e_align));
d1798 1
a1798 2
					    exp_unop (ABSOLUTE,
						      exp_nameop (NAME, ".")),
@


1.391
log
@	* ldlang.h (lang_output_section_statement_type): Rename
	"section_relative_symbol" field to "update_dot".
	* ldlang.c: Update all uses.
	(strip_excluded_output_sections): Don't test update_dot_tree here..
	(lang_leave_overlay): ..set update_dot here.
@
text
@d5250 1
a5250 1
	    /* This symbol is relative to this section.  */
d5469 4
d5479 2
a5480 1
		       bfd_vma dot)
d5488 1
a5488 1
				       current_os, fill, dot);
d5496 1
d5499 5
d5506 2
a5507 1
		lang_do_assignments_1 (os->children.head, os, os->fill, dot);
d5524 1
a5524 1
				       current_os, fill, dot);
d5595 13
d5619 1
a5619 1
				       current_os, fill, dot);
d5639 4
d5645 77
a5721 1
  lang_do_assignments_1 (statement_list.head, abs_output_section, NULL, 0);
d5753 2
a5754 2
	  h->u.def.value = bfd_get_section_vma (link_info.output_bfd, s);
	  h->u.def.section = bfd_abs_section_ptr;
a6239 2
static lang_output_section_statement_type *current_section;

a7046 63
/* Create an absolute symbol with the given name with the value of the
   address of first byte of the section named.

   If the symbol already exists, then do nothing.  */

void
lang_abs_symbol_at_beginning_of (const char *secname, const char *name)
{
  struct bfd_link_hash_entry *h;

  h = bfd_link_hash_lookup (link_info.hash, name, TRUE, TRUE, TRUE);
  if (h == NULL)
    einfo (_("%P%F: bfd_link_hash_lookup failed: %E\n"));

  if (h->type == bfd_link_hash_new
      || h->type == bfd_link_hash_undefined)
    {
      asection *sec;

      h->type = bfd_link_hash_defined;

      sec = bfd_get_section_by_name (link_info.output_bfd, secname);
      if (sec == NULL)
	h->u.def.value = 0;
      else
	h->u.def.value = bfd_get_section_vma (link_info.output_bfd, sec);

      h->u.def.section = bfd_abs_section_ptr;
    }
}

/* Create an absolute symbol with the given name with the value of the
   address of the first byte after the end of the section named.

   If the symbol already exists, then do nothing.  */

void
lang_abs_symbol_at_end_of (const char *secname, const char *name)
{
  struct bfd_link_hash_entry *h;

  h = bfd_link_hash_lookup (link_info.hash, name, TRUE, TRUE, TRUE);
  if (h == NULL)
    einfo (_("%P%F: bfd_link_hash_lookup failed: %E\n"));

  if (h->type == bfd_link_hash_new
      || h->type == bfd_link_hash_undefined)
    {
      asection *sec;

      h->type = bfd_link_hash_defined;

      sec = bfd_get_section_by_name (link_info.output_bfd, secname);
      if (sec == NULL)
	h->u.def.value = 0;
      else
	h->u.def.value = (bfd_get_section_vma (link_info.output_bfd, sec)
			  + TO_ADDR (sec->size));

      h->u.def.section = bfd_abs_section_ptr;
    }
}

@


1.390
log
@
Add support for PowerPC VLE.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	* NEWS:  Mention PowerPC VLE port.

2012-05-14  James Lemke <jwlemke@@codesourcery.com>
	    Catherine Moore  <clm@@codesourcery.com>

	bfd/
	* bfd.c (bfd_lookup_section_flags): Add section parm.
	* ecoff.c (bfd_debug_section): Remove flag_info initializer.
	* elf-bfd.h (bfd_elf_section_data): Move in section_flag_info.
	(bfd_elf_lookup_section_flags): Add section parm.
	* elf32-ppc.c (is_ppc_vle): New function.
	(ppc_elf_modify_segment_map): New function.
	(elf_backend_modify_segment_map): Define.
	(has_vle_insns): New define.
	* elf32-ppc.h (ppc_elf_modify_segment_map): Declare.
	* elflink.c (bfd_elf_lookup_section_flags): Add return value & parm.
	Move in logic to omit / include a section.
	* libbfd-in.h (bfd_link_info): Add section parm.
	(bfd_generic_lookup_section_flags): Likewise.
	* reloc.c (bfd_generic_lookup_section_flags): Likewise.
	* section.c (bfd_section): Move out section_flag_info.
	(BFD_FAKE_SECTION): Remove flag_info initializer.
	* targets.c (_bfd_lookup_section_flags): Add section parm.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	bfd/
	* archures.c (bfd_mach_ppc_vle): New.
	* bfd-in2.h: Regenerated.
	* cpu-powerpc.c (bfd_powerpc_archs): New entry for vle.
	* elf32-ppc.c (split16_format_type): New enumeration.
	(ppc_elf_vle_split16): New function.
	(HOWTO): Add entries for R_PPC_VLE relocations.
	(ppc_elf_reloc_type_lookup): Handle PPC_VLE relocations.
	(ppc_elf_section_flags): New function.
	(ppc_elf_lookup_section_flags): New function.
	(ppc_elf_section_processing): New function.
	(ppc_elf_check_relocs): Handle PPC_VLE relocations.
	(ppc_elf_relocation_section): Likewise.
	(elf_backend_lookup_section_flags_hook): Define.
	(elf_backend_section_flags): Define.
	(elf_backend_section_processing): Define.
	* elf32-ppc.h (ppc_elf_section_processing): Declare.
	* libbfd.h: Regenerated.
	* reloc.c (BFD_RELOC_PPC_VLE_REL8, BFD_RELOC_PPC_VLE_REL15,
	BFD_RELOC_PPC_VLE_REL24, BFD_RELOC_PPC_VLE_LO16A,
	BFD_RELOC_PPC_VLE_LO16D, BFD_RELOC_PPC_VLE_HI16A,
	BFD_RELOC_PPC_VLE_HI16D, BFD_RELOC_PPC_VLE_HA16A,
	BFD_RELOC_PPC_VLE_HA16D, BFD_RELOC_PPC_VLE_SDA21,
	BFD_RELOC_PPC_VLE_SDA21_LO, BFD_RELOC_PPC_VLE_SDAREL_LO16A,
	BFD_RELOC_PPC_VLE_SDAREL_LO16D, BFD_RELOC_PPC_VLE_SDAREL_HI16A,
	BFD_RELOC_PPC_VLE_SDAREL_HI16D, BFD_RELOC_PPC_VLE_SDAREL_HA16A,
	BFD_RELOC_PPC_VLE_SDAREL_HA16D): New bfd relocations.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	gas/
	* config/tc-ppc.c (insn_validate): New func of existing code to call..
	(ppc_setup_opcodes): ..from 2 places here.
	Revise for second (VLE) opcode table.
	Add #ifdef'd code to print opcode tables.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	gas/
	* config/tc-ppc.c (ppc_setup_opcodes): Allow out-of-order
	for the VLE conditional branches.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>
	    Rhonda Wittels  <rhonda@@codesourcery.com>

	gas/
	* config/tc-ppc.c (PPC_VLE_SPLIT16A): New macro.
	(PPC_VLE_SPLIT16D): New macro.
	(PPC_VLE_LO16A): New macro.
	(PPC_VLE_LO16D): New macro.
	(PPC_VLE_HI16A): New macro.
	(PPC_VLE_HI16D): New macro.
	(PPC_VLE_HA16A): New macro.
	(PPC_VLE_HA16D): New macro.
	(PPC_APUINFO_VLE): New definition.
	(md_chars_to_number): New function.
	(md_parse_option): Check for combinations of little
	endian and -mvle.
	(md_show_usage): Document -mvle.
	(ppc_arch): Recognize VLE.
	(ppc_mach): Recognize bfd_mach_ppc_vle.
	(ppc_setup_opcodes): Print the opcode table if
	* config/tc-ppc.h (ppc_frag_check): Declare.
	* doc/c-ppc.texi: Document -mvle.
	* NEWS:  Mention PowerPC VLE port.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	gas/
	* config/tc-ppc.h (ppc_dw2_line_min_insn_length): Declare.
	(DWARF2_LINE_MIN_INSN_LENGTH): Redefine.
	* config/tc-ppc.c (ppc_dw2_line_min_insn_length): New.
	* dwarf2dbg.c (scale_addr_delta): Handle values of 1
	for DWARF2_LINE_MIN_INSN_LENGTH.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>
	    Rhonda Wittels  <rhonda@@codesourcery.com>

	gas/testsuite/
	* gas/ppc/ppc.exp: Run new tests.
	* gas/ppc/vle-reloc.d: New test.
	* gas/ppc/vle-reloc.s: New test.
	* gas/ppc/vle-simple-1.d: New test.
	* gas/ppc/vle-simple-1.s: New test.
	* gas/ppc/vle-simple-2.d: New test.
	* gas/ppc/vle-simple-2.s: New test.
	* gas/ppc/vle-simple-3.d: New test.
	* gas/ppc/vle-simple-3.s: New test.
	* gas/ppc/vle-simple-4.d: New test.
	* gas/ppc/vle-simple-4.s: New test.
	* gas/ppc/vle-simple-5.d: New test.
	* gas/ppc/vle-simple-5.s: New test.
	* gas/ppc/vle-simple-6.d: New test.
	* gas/ppc/vle-simple-6.s: New test.
	* gas/ppc/vle.d: New test.
	* gas/ppc/vle.s: New test.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>
	include/elf/
	* ppc.h (SEC_PPC_VLE): Remove.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
	    James Lemke  <jwlemke@@codesourcery.com>

	include/elf/
	* ppc.h (R_PPC_VLE_REL8): New reloction.
	(R_PPC_VLE_REL15): Likewise.
	(R_PPC_VLE_REL24): Likewise.
	(R_PPC_VLE_LO16A): Likewise.
	(R_PPC_VLE_LO16D): Likewise.
	(R_PPC_VLE_HI16A): Likewise.
	(R_PPC_VLE_HI16D): Likewise.
	(R_PPC_VLE_HA16A): Likewise.
	(R_PPC_VLE_HA16D): Likewise.
	(R_PPC_VLE_SDA21): Likewise.
	(R_PPC_VLE_SDA21_LO): Likewise.
	(R_PPC_VLE_SDAREL_LO16A): Likewise.
	(R_PPC_VLE_SDAREL_LO16D): Likewise.
	(R_PPC_VLE_SDAREL_HI16A): Likewise.
	(R_PPC_VLE_SDAREL_HI16D): Likewise.
	(R_PPC_VLE_SDAREL_HA16A): Likewise.
	(R_PPC_VLE_SDAREL_HA16D): Likewise.
	(SEC_PPC_VLE): Remove.
	(PF_PPC_VLE): New program header flag.
	(SHF_PPC_VLE): New section header flag.
	(vle_opcodes, vle_num_opcodes): New.
	(VLE_OP): New macro.
	(VLE_OP_TO_SEG): New macro.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>
	    Rhonda Wittels  <rhonda@@codesourcery.com>

	include/opcode/
	* ppc.h (PPC_OPCODE_VLE): New definition.
	(PPC_OP_SA): New macro.
	(PPC_OP_SE_VLE): New macro.
	(PPC_OP): Use a variable shift amount.
	(powerpc_operand): Update comments.
	(PPC_OPSHIFT_INV): New macro.
	(PPC_OPERAND_CR): Replace with...
	(PPC_OPERAND_CR_BIT): ...this and
	(PPC_OPERAND_CR_REG): ...this.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	ld/
	* ldlang.c (walk_wild_consider_section): Don't copy section_flag_list.
	Pass it to callback.
	(walk_wild_section_general): Pass section_flag_list to callback.
	(lang_add_section): Add sflag_list parm.
	Move out logic to keep / omit a section & call bfd_lookup_section_flags.
	(output_section_callback_fast): Add sflag_list parm.
	Add new parm to lang_add_section calls.
	(output_section_callback): Likewise.
	(check_section_callback): Add sflag_list parm.
	(lang_place_orphans): Add new parm to lang_add_section calls.
	(gc_section_callback): Add sflag_list parm.
	(find_relro_section_callback): Likewise.
	* ldlang.h (callback_t): Add flag_info parm.
	(lang_add_section): Add sflag_list parm.
	* emultempl/armelf.em (elf32_arm_add_stub_section):
	Add lang_add_section parm.
	* emultempl/beos.em (gld*_place_orphan): Likewise.
	* emultempl/elf32.em (gld*_place_orphan): Likewise.
	* emultempl/hppaelf.em (hppaelf_add_stub_section): Likewise.
	* emultempl/m68hc1xelf.em (m68hc11elf_add_stub_section): Likewise.
	* emultempl/mipself.em (mips_add_stub_section): Likewise.
	* emultempl/mmo.em (mmo_place_orphan): Likewise.
	* emultempl/pe.em (gld_*_place_orphan): Likewise.
	* emultempl/pep.em (gld_*_place_orphan): Likewise.
	* emultempl/ppc64elf.em (ppc_add_stub_section): Likewise.
	* emultempl/spuelf.em (spu_place_special_section): Likewise.
	* emultempl/vms.em (vms_place_orphan): Likewise.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	ld/testsuite/
	* ld-powerpc/powerpc.exp: Create ppceabitests.
	* ld-powerpc/vle-multiseg.s: New.
	* ld-powerpc/vle-multiseg-1.d: New.
	* ld-powerpc/vle-multiseg-1.ld: New.
	* ld-powerpc/vle-multiseg-2.d: New.
	* ld-powerpc/vle-multiseg-2.ld: New.
	* ld-powerpc/vle-multiseg-3.d: New.
	* ld-powerpc/vle-multiseg-3.ld: New.
	* ld-powerpc/vle-multiseg-4.d: New.
	* ld-powerpc/vle-multiseg-4.ld: New.
	* ld-powerpc/vle-multiseg-5.d: New.
	* ld-powerpc/vle-multiseg-5.ld: New.
	* ld-powerpc/vle-multiseg-6.d: New.
	* ld-powerpc/vle-multiseg-6.ld: New.
	* ld-powerpc/vle-multiseg-6a.s: New.
	* ld-powerpc/vle-multiseg-6b.s: New.
	* ld-powerpc/vle-multiseg-6c.s: New.
	* ld-powerpc/vle-multiseg-6d.s: New.
	* ld-powerpc/powerpc.exp: Run new tests.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	ld/
	* NEWS:  Mention PowerPC VLE port.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	ld/testsuite/
	* ld-powerpc/apuinfo.rd: Update for VLE.
	* ld-powerpc/vle-reloc-1.d: New.
	* ld-powerpc/vle-reloc-1.s: New.
	* ld-powerpc/vle-reloc-2.d: New.
	* ld-powerpc/vle-reloc-2.s: New.
	* ld-powerpc/vle-reloc-3.d: New.
	* ld-powerpc/vle-reloc-3.s: New.
	* ld-powerpc/vle-reloc-def-1.s: New.
	* ld-powerpc/vle-reloc-def-2.s: New.
	* ld-powerpc/vle-reloc-def-3.s: New.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	opcodes/
	* ppc-dis.c (get_powerpc_dialect): Use is_ppc_vle.
	(PPC_OPCD_SEGS, VLE_OPCD_SEGS): New defines.
	(vle_opcd_indices): New array.
	(lookup_vle): New function.
	(disassemble_init_powerpc): Revise for second (VLE) opcode table.
	(print_insn_powerpc): Likewise.
	* ppc-opc.c: Likewise.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>
	    Rhonda Wittels  <rhonda@@codesourcery.com>
	    Nathan Froyd <froydnj@@codesourcery.com>

	opcodes/
	* ppc-opc.c (insert_arx, extract_arx): New functions.
	(insert_ary, extract_ary): New functions.
	(insert_li20, extract_li20): New functions.
	(insert_rx, extract_rx): New functions.
	(insert_ry, extract_ry): New functions.
	(insert_sci8, extract_sci8): New functions.
	(insert_sci8n, extract_sci8n): New functions.
	(insert_sd4h, extract_sd4h): New functions.
	(insert_sd4w, extract_sd4w): New functions.
	(insert_vlesi, extract_vlesi): New functions.
	(insert_vlensi, extract_vlensi): New functions.
	(insert_vleui, extract_vleui): New functions.
	(insert_vleil, extract_vleil): New functions.
 	(BI_MASK, BB_MASK, BT): Use PPC_OPERAND_CR_BIT.
 	(BI16, BI32, BO32, B8): New.
	(B15, B24, CRD32, CRS): New.
 	(CRD, OBF, BFA, CR, CRFS): Use PPC_OPERAND_CR_REG.
	(DB, IMM20, RD, Rx, ARX, RY, RZ): New.
	(ARY, SCLSCI8, SCLSCI8N, SE_SD, SE_SDH): New.
	(SH6_MASK): Use PPC_OPSHIFT_INV.
	(SI8, UI5, OIMM5, UI7, BO16): New.
	(VLESIMM, VLENSIMM, VLEUIMM, VLEUIMML): New.
	(XT6, XA6, XB6, XB6S, XC6): Use PPC_OPSHIFT_INV.
	(ALLOW8_SPRG): New.
	(insert_sprg, extract_sprg): Check ALLOW8_SPRG.
	(OPVUP, OPVUP_MASK OPVUP): New
	(BD8, BD8_MASK, BD8IO, BD8IO_MASK): New.
	(EBD8IO, EBD8IO1_MASK, EBD8IO2_MASK, EBD8IO3_MASK): New.
	(BD15, BD15_MASK, EBD15, EBD15_MASK, EBD15BI, EBD15BI_MASK): New.
	(BD24,BD24_MASK, C_LK, C_LK_MASK, C, C_MASK): New.
 	(IA16, IA16_MASK, I16A, I16A_MASK, I16L, I16L_MASK): New.
	(IM7, IM7_MASK, LI20, LI20_MASK, SCI8, SCI8_MASK): New.
	(SCI8BF, SCI8BF_MASK, SD4, SD4_MASK): New.
	(SE_IM5, SE_IM5_MASK): New.
	(SE_R, SE_R_MASK, SE_RR, SE_RR_MASK): New.
	(EX, EX_MASK, BO16F, BO16T, BO32F, BO32T): New.
	(BO32DNZ, BO32DZ): New.
	(NO371, PPCSPE, PPCISEL, PPCEFS, MULHW): Include PPC_OPCODE_VLE.
	(PPCVLE): New.
	(powerpc_opcodes): Add new VLE instructions.  Update existing
	instruction to include PPCVLE if supported.
	* ppc-dis.c (ppc_opts): Add vle entry.
	(get_powerpc_dialect): New function.
	(powerpc_init_dialect): VLE support.
	(print_insn_big_powerpc): Call get_powerpc_dialect.
	(print_insn_little_powerpc): Likewise.
	(operand_value_powerpc): Handle negative shift counts.
	(print_insn_powerpc): Handle 2-byte instruction lengths.
@
text
@d3892 1
a3892 2
	  if (!os->section_relative_symbol
	      && !os->update_dot_tree)
d5255 1
a5255 1
	      output_section_statement->section_relative_symbol = 1;
d7392 5
a7396 2
    overlay_list->os->update_dot_tree
      = exp_assign (".", exp_binop ('+', overlay_vma, overlay_max));
@


1.389
log
@	PR ld/13991
bfd/
	* bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
	_bfd_generic_link_just_syms.
	* bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
	* bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

	* bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
	* bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
	SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
	SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
	* bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
	* bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
	* bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
	* bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
	* bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
	* bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
	* bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
	* bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
	* bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
	* bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
	* bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
	* bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
	* bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
	* bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
	* bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
	* bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
	* bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
	* bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
	* bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
	* bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
	* bfd/reloc.c: Update all references.
	* bfd/bfd-in2.h: Regenerate.
ld/
	* ld/ldlang.c (size_input_section): Use sec_info_type rather than
	usrdata->flags.just_syms.
	* ld/ldwrite.c (build_link_order): Likewise.
	* ld/emultempl/hppaelf.em (build_section_lists): Likewise.
	* ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
	* ld/emultempl/armelf.em (build_section_lists): Likewise.
	(after_allocation): Update for renamed sec_info_type value.
	* ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@a238 3
  /* Propagate the section_flag_info from the wild statement to the section.  */
  s->section_flag_info = ptr->section_flag_list;

d265 1
a265 1
  (*callback) (ptr, sec, s, file, data);
d284 1
a284 1
	(*callback) (ptr, sec, s, file, data);
d506 1
d539 1
a539 1
  lang_add_section (&ptr->children, tree->section,
d1810 1
a1810 1
  lang_add_section (add_child, s, os);
d2228 1
a2228 2
   lang_input_section statement which is placed at PTR.  FILE is the
   input file which holds SECTION.  */
d2233 1
a2236 1
  struct flag_info *sflag_info = section->section_flag_info;
d2268 1
a2268 9
      if (sflag_info->flags_initialized == FALSE)
	bfd_lookup_section_flags (&link_info, sflag_info);

      if (sflag_info->only_with_flags != 0
	  && sflag_info->not_with_flags != 0
          && ((sflag_info->not_with_flags & flags) != 0
	       || (sflag_info->only_with_flags & flags)
                   != sflag_info->only_with_flags))
	return;
d2270 3
a2272 8
      if (sflag_info->only_with_flags != 0
	  && (sflag_info->only_with_flags & flags)
              != sflag_info->only_with_flags)
	return;

      if (sflag_info->not_with_flags != 0
          && (sflag_info->not_with_flags & flags) != 0)
	return;
d2485 1
d2506 1
a2506 1
    lang_add_section (&ptr->children, section, os);
d2513 1
a2513 1
      lang_add_section (&list, section, os);
d2539 1
d5999 1
a5999 1
					default_common_section);
d6021 1
a6021 1
		      lang_add_section (&os->children, s, os);
d6242 1
d6314 1
@


1.388
log
@ld/
	* ldemul.c (before_allocation_default): Revert last change.
	ldlang.c (lang_add_section): Likewise.
	(strip_excluded_output_sections): Don't strip output sections with
	user input sections when emitrelocations, unless all are SEC_EXCLUDE.
ld/testsuite/
	* ld-powerpc/vxworks-relax.rd: Remove check on reloc section
	file offset and reloc symbol indices.
@
text
@d4622 1
a4622 1
  if (!((lang_input_statement_type *) i->owner->usrdata)->flags.just_syms
@


1.387
log
@	* ldemul.c (before_allocation_default): When emitrelocations,
	don't strip sections..
	* ldlang.c (lang_add_section): ..and don't set up map_head, map_tail.
@
text
@a2382 1
      && !link_info.emitrelocations
d3889 3
a3891 2
	    if ((s->flags & SEC_LINKER_CREATED) != 0
		&& (s->flags & SEC_EXCLUDE) == 0)
@


1.386
log
@	PR ld/10340
	* ldfile.c (is_sysrooted_pathname): Remove notsame param.
	(ldfile_add_library_path): Don't set sysrooted flag.
	(ldfile_open_file_search): Likewise, and don't copy them.
	(try_open): Delete exten and code handling such.  Add sysrooted
	param and return whether path is in sysroot.
	(ldfile_find_command_file): Delete extend param.  Add sysrooted
	param.  Rename local var.  Update try_open calls.
	(ldfile_open_command_file_1): Pass sysrooted to lex_push_file.
	* ldfile.h (search_dirs_type): Remove sysrooted field.
	* ldlang.c (new_afile): Always set sysrooted from input_flags.
	(load_symbols): Don't set input_flags.sysrooted.
	* ldlang.h (struct lang_input_statement_flags): Revise sysrooted
	comment.
	* ldlex.h (lex_push_file): Update prototype.
	* ldlex.l (sysrooted_stack): New array.
	(EOF): Pop input_flags.sysrooted.
	(lex_push_file): Add sysrooted param.  Save and set
	input_flags.sysrooted.
@
text
@d2383 1
@


1.385
log
@	* ldlang.h (struct lang_input_statement_flags): New, extract from..
	(lang_input_statement_type): ..here.  New field "flags".
	(input_flags): Declare.
	(missing_file): Delete.
	* ldmain.h (whole_archive): Delete.
	(add_DT_NEEDED_for_regular, add_DT_NEEDED_for_dynamic): Delete.
	* ld.h (ld_config_type <dynamic_link>): Delete.
	* ldmain.c (whole_archive): Delete.
	(add_DT_NEEDED_for_regular, add_DT_NEEDED_for_dynamic): Delete.
	* ldlang.c (missing_file, ldlang_sysrooted_script): Delete.
	(input_flags): New variable.  Replace all uses of config.dynamic_link,
	missing_file, ldlang_sysrooted_script, whole_archive,
	add_DT_NEEDED_for_regular and add_DT_NEEDED_for_dynamic with fields
	from here.
	* ldfile.c: Likewise.
	* ldgram.y: Likewise.
	* ldmain.c: Likewise.
	* ldwrite.c: Likewise.
	* lexsup.c: Likewise.
	* plugin.c: Likewise.
	* emultempl/aix.em: Likewise.
	* emultempl/armelf.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/scoreelf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/vms.em: Likewise.
	* ldlang.c (new_afile): Use memset to init zero fields.
	(load_symbols): Simplify save and restore of flags around command
	file processing.
	* ldfile.c (is_sysrooted_pathname): Tidy.
@
text
@d1067 1
a1104 1
      p->flags.sysrooted = input_flags.sysrooted;
a2718 1
      input_flags.sysrooted = entry->flags.sysrooted;
d2731 3
a2733 1
      /* missing_file is sticky.  */
@


1.384
log
@	PR ld/13683
	* ldlang.c (lang_process): Rerun lang_do_assignments before
	starting garbage collection.
	* ldexp.c (fold_name): Generate a reloc for defined symbols
	found without an associated output section during the mark phase.
	(exp_fold_tree_1): Continue processing an expression, even if we
	are unable to fold it, if we are in the first two evaluation
	phases.
	* ldexp.h (enum lang_phase_type): Add descriptions of the phases.

	* ld-gc/pr13683.c: New test source file.
	* ld-gc/pr13683.d: New test control and output file.
	* ld-gc/gc.exp: Run the pr13683 test.

	* ld-cris/tls-gc-68: Update expected symbol table dump.
	* ld-cris/tls-gc-69: Likewise.
	* ld-cris/tls-gc-70: Likewise.
	* ld-cris/tls-gc-71: Likewise.
	* ld-cris/tls-gc-75: Likewise.
	* ld-cris/tls-gc-76.d: Likewise.
	* ld-cris/tls-gc-79.d: Likewise.
@
text
@a71 1
static bfd_boolean ldlang_sysrooted_script = FALSE;
d102 1
a110 1
bfd_boolean missing_file = FALSE;
d733 1
a733 1
  if (file->just_syms_flag)
d1048 2
d1060 2
a1061 1
  lang_has_input_file = TRUE;
d1063 4
a1066 1
  p->sysrooted = FALSE;
a1078 2
      p->maybe_archive = FALSE;
      p->real = TRUE;
d1080 2
a1081 2
      p->just_syms_flag = TRUE;
      p->search_dirs_flag = FALSE;
a1084 2
      p->maybe_archive = FALSE;
      p->real = FALSE;
a1085 2
      p->just_syms_flag = FALSE;
      p->search_dirs_flag = FALSE;
a1087 1
      p->maybe_archive = TRUE;
a1088 1
      p->real = TRUE;
d1090 3
a1092 2
      p->just_syms_flag = FALSE;
      p->search_dirs_flag = TRUE;
a1095 2
      p->maybe_archive = FALSE;
      p->real = FALSE;
d1097 1
a1097 2
      p->just_syms_flag = FALSE;
      p->search_dirs_flag = TRUE;
a1099 1
      p->sysrooted = ldlang_sysrooted_script;
a1100 2
      p->maybe_archive = FALSE;
      p->real = TRUE;
d1102 3
a1104 2
      p->just_syms_flag = FALSE;
      p->search_dirs_flag = TRUE;
a1107 2
      p->maybe_archive = FALSE;
      p->real = TRUE;
d1109 1
a1109 2
      p->just_syms_flag = FALSE;
      p->search_dirs_flag = FALSE;
a1113 14
  p->the_bfd = NULL;
  p->next_real_file = NULL;
  p->next = NULL;
  p->dynamic = config.dynamic_link;
  p->add_DT_NEEDED_for_dynamic = add_DT_NEEDED_for_dynamic;
  p->add_DT_NEEDED_for_regular = add_DT_NEEDED_for_regular;
  p->whole_archive = whole_archive;
  p->loaded = FALSE;
  p->missing_file = FALSE;
#ifdef ENABLE_PLUGINS
  p->claimed = FALSE;
  p->claim_archive = FALSE;
  p->reload = FALSE;
#endif /* ENABLE_PLUGINS */
d1991 1
a1991 1
	  || file->just_syms_flag)
d2213 1
a2213 1
  if (entry->just_syms_flag)
d2598 1
a2598 1
  if (search->loaded || !search->real)
d2676 1
a2676 1
  if (entry->loaded)
d2682 1
a2682 1
  if (entry->missing_file)
d2689 1
a2689 4
      bfd_boolean save_ldlang_sysrooted_script;
      bfd_boolean save_add_DT_NEEDED_for_regular;
      bfd_boolean save_add_DT_NEEDED_for_dynamic;
      bfd_boolean save_whole_archive;
d2715 1
d2719 7
a2725 8
      save_ldlang_sysrooted_script = ldlang_sysrooted_script;
      ldlang_sysrooted_script = entry->sysrooted;
      save_add_DT_NEEDED_for_regular = add_DT_NEEDED_for_regular;
      add_DT_NEEDED_for_regular = entry->add_DT_NEEDED_for_regular;
      save_add_DT_NEEDED_for_dynamic = add_DT_NEEDED_for_dynamic;
      add_DT_NEEDED_for_dynamic = entry->add_DT_NEEDED_for_dynamic;
      save_whole_archive = whole_archive;
      whole_archive = entry->whole_archive;
a2728 3
      /* We want to use the same -Bdynamic/-Bstatic as the one for
	 ENTRY.  */
      config.dynamic_link = entry->dynamic;
d2732 3
a2734 4
      ldlang_sysrooted_script = save_ldlang_sysrooted_script;
      add_DT_NEEDED_for_regular = save_add_DT_NEEDED_for_regular;
      add_DT_NEEDED_for_dynamic = save_add_DT_NEEDED_for_dynamic;
      whole_archive = save_whole_archive;
d2754 1
a2754 1
      if (!entry->reload)
d2764 1
a2764 1
      if (entry->whole_archive)
d2799 1
a2799 1
	  entry->loaded = loaded;
d2806 1
a2806 1
    entry->loaded = TRUE;
d2810 1
a2810 1
  return entry->loaded;
d2994 1
a2994 1
	  && s->real)
d3227 1
a3227 1
	  if (s->input_statement.real)
d3243 2
a3244 2
		  && !s->input_statement.whole_archive
		  && s->input_statement.loaded
d3247 1
a3247 1
		s->input_statement.loaded = FALSE;
d3252 2
a3253 2
		       && s->input_statement.loaded
		       && s->input_statement.add_DT_NEEDED_for_regular
d3257 2
a3258 2
		  s->input_statement.loaded = FALSE;
		  s->input_statement.reload = TRUE;
d3309 1
a3309 1
  if (missing_file)
d4620 1
a4620 1
  if (!((lang_input_statement_type *) i->owner->usrdata)->just_syms_flag
d5791 1
a5791 1
      if (file->input_statement.claimed)
d5994 1
a5994 1
	      if (file->just_syms_flag)
d6306 1
a6306 1
	  if (f->claimed)
d6471 2
a6472 2
      if (claim1->claimed)
	return claim1->claim_archive ? lastobject : claim1;
d6883 1
a6883 1
  first_file->real = TRUE;
@


1.383
log
@	PR ld/13343
	* ld.h (parsing_defsym): Delete.
	* ldexp.c (exp_intop, exp_bigintop, exp_relop): Set type.filename.
	(fold_binary, fold_name, exp_fold_tree_1, exp_get_vma, exp_get_fill,
	exp_get_abs_int): Add tree arg for %S in error messages.  Don't
	fudge lineno.
	(exp_binop, exp_unop, exp_nameop, exp_assop, exp_assert): Copy
	type.filename from sub-tree.
	(exp_trinop): Likewise, and use "cond" rather than "lhs".
	* ldexp.h (node_type): Add filename field to struct.
	* ldfile.c (ldfile_input_filename): Delete.  Remove all refs.
	* ldfile.h (ldfile_input_filename): Delete.
	* ldgram.y (phdr_type, phdr_qualifiers, yyerror): Add NULL arg for
	%S in error messages.
	* ldemul.c (syslib_default, hll_default): Likewise.
	* ldlang.c (lang_memory_region_lookup, lang_memory_region_alias,
	lang_get_regions, lang_new_phdr): Likewise.
	(lang_size_sections_1): Pass addr_tree for %S.
	* ldlex.h (lex_redirect): Update prototype.
	(ldlex_filename): Declare.
	* ldlex.l (<EOF>): Don't set ldfile_input_filename.
	(lex_redirect): Add fake_filename and count params.  Push
	fake_filename to file_name_stack and init lineno from count.
	(ldlex_filename): New function.
	(lex_warn_invalid): Use above.
	* ldmain.c (main): Update lex_redirect call.
	* ldmisc.c (vfinfo <%S>): Take file name and line number from
	etree_type arg, or use current if arg is NULL.
	* lexsup.c (parsing_defsym): Delete.
	(parse_args <OPTION_DEFSYM>): Update lex_redirect call.
@
text
@d6653 5
@


1.382
log
@Support arch-dependent fill

bfd/

2012-01-31  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13616
	* archures.c (bfd_arch_info): Add fill.
	(bfd_default_arch_struct): Add bfd_arch_default_fill.
	(bfd_arch_default_fill): New.

	* configure.in: Set bfd version to 2.22.52.
	* configure: Regenerated.

	* cpu-alpha.c: Add bfd_arch_default_fill to bfd_arch_info
	initializer.
	* cpu-arc.c: Likewise.
	* cpu-arm.c: Likewise.
	* cpu-avr.c: Likewise.
	* cpu-bfin.c: Likewise.
	* cpu-cr16.c: Likewise.
	* cpu-cr16c.c: Likewise.
	* cpu-cris.c: Likewise.
	* cpu-crx.c: Likewise.
	* cpu-d10v.c: Likewise.
	* cpu-d30v.c: Likewise.
	* cpu-dlx.c: Likewise.
	* cpu-epiphany.c: Likewise.
	* cpu-fr30.c: Likewise.
	* cpu-frv.c: Likewise.
	* cpu-h8300.c: Likewise.
	* cpu-h8500.c: Likewise.
	* cpu-hppa.c: Likewise.
	* cpu-i370.c: Likewise.
	* cpu-i860.c: Likewise.
	* cpu-i960.c: Likewise.
	* cpu-ia64.c: Likewise.
	* cpu-ip2k.c: Likewise.
	* cpu-iq2000.c: Likewise.
	* cpu-lm32.c: Likewise.
	* cpu-m10200.c: Likewise.
	* cpu-m10300.c: Likewise.
	* cpu-m32c.c: Likewise.
	* cpu-m32r.c: Likewise.
	* cpu-m68hc11.c: Likewise.
	* cpu-m68hc12.c: Likewise.
	* cpu-m68k.c: Likewise.
	* cpu-m88k.c: Likewise.
	* cpu-mcore.c: Likewise.
	* cpu-mep.c: Likewise.
	* cpu-microblaze.c: Likewise.
	* cpu-mips.c: Likewise.
	* cpu-mmix.c: Likewise.
	* cpu-moxie.c: Likewise.
	* cpu-msp430.c: Likewise.
	* cpu-mt.c: Likewise.
	* cpu-ns32k.c: Likewise.
	* cpu-openrisc.c: Likewise.
	* cpu-or32.c: Likewise.
	* cpu-pdp11.c: Likewise.
	* cpu-pj.c: Likewise.
	* cpu-plugin.c: Likewise.
	* cpu-powerpc.c: Likewise.
	* cpu-rl78.c: Likewise.
	* cpu-rs6000.c: Likewise.
	* cpu-rx.c: Likewise.
	* cpu-s390.c: Likewise.
	* cpu-score.c: Likewise.
	* cpu-sh.c: Likewise.
	* cpu-sparc.c: Likewise.
	* cpu-spu.c: Likewise.
	* cpu-tic30.c: Likewise.
	* cpu-tic4x.c: Likewise.
	* cpu-tic54x.c: Likewise.
	* cpu-tic6x.c: Likewise.
	* cpu-tic80.c: Likewise.
	* cpu-tilegx.c: Likewise.
	* cpu-tilepro.c: Likewise.
	* cpu-v850.c: Likewise.
	* cpu-vax.c: Likewise.
	* cpu-w65.c: Likewise.
	* cpu-we32k.c: Likewise.
	* cpu-xc16x.c: Likewise.
	* cpu-xstormy16.c: Likewise.
	* cpu-xtensa.c: Likewise.
	* cpu-z80.c: Likewise.
	* cpu-z8k.c: Likewise.

	* cpu-i386.c: Include "libiberty.h".
	(bfd_arch_i386_fill): New.
	Add bfd_arch_i386_fill to  bfd_arch_info initializer.

	* cpu-k1om.c: Add bfd_arch_i386_fill to  bfd_arch_info initializer.
	* cpu-l1om.c: Likewise.

	* linker.c (default_data_link_order): Call abfd->arch_info->fill
	if fill size is 0.

	* bfd-in2.h: Regenerated.

include/

2012-01-31  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13616
	* bfdlink.h (bfd_link_order): Update comments on data size.

ld/

2012-01-31  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13616
	* emulparams/elf32_x86_64.sh: Remove NOP.
	* emulparams/elf_i386.sh: Likewise.
	* emulparams/elf_i386_be.sh: Likewise.
	* emulparams/elf_i386_ldso.sh: Likewise.
	* emulparams/elf_i386_vxworks.sh: Likewise.
	* emulparams/elf_k1om.sh: Likewise.
	* emulparams/elf_l1om.sh: Likewise.
	* emulparams/elf_x86_64.sh: Likewise.

	* ldlang.c (zero_fill): Initialized to 0.

	* ldwrite.c (build_link_order): Set data size to linker odrder
	size when they are the same.

	* scripttempl/elf.sc: Don't specify fill if NOP is undefined.

ld/testsuite/

2012-01-31  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/13616
	* ld-i386/tlsbindesc.dd: Update no-op padding.
	* ld-i386/tlsnopic.dd: Likewise.
	* ld-i386/tlspic.dd: Likewise.
	* ld-x86-64/tlsbin.dd: Likewise.
	* ld-x86-64/tlsbindesc.dd: Likewise.
	* ld-x86-64/tlspic.dd: Likewise.
@
text
@d1315 1
a1315 1
                   name);
d1320 2
a1321 1
    einfo (_("%P:%S: warning: memory region `%s' not declared\n"), name);
d1355 1
a1355 1
    einfo (_("%F%P:%S: error: alias for default memory region\n"));
d1368 1
a1368 1
                 alias);
d1375 1
a1375 2
           region_name,
           alias);
d4894 1
a4894 1
			 os->name);
d6951 2
a6952 1
    einfo (_("%X%P:%S: section has both a load address and a load region\n"));
d7139 2
a7140 1
	einfo (_("%X%P:%S: PHDRS and FILEHDR are not supported when prior PT_LOAD headers lack them\n"));
@


1.381
log
@	PR ld/12758
	* ldlang.c (lang_process): Don't reopen all files, just those
	newly added by plugin.
@
text
@d4603 1
a4603 1
  static fill_type zero_fill = { 1, { 0 } };
@


1.380
log
@* ld/ldlang.c (insert_pad): Change alignment_needed argument to
bfd_size_type.
(size_input_section): Change alignment_needed varible to
bfd_size_type.
* ld/ldlang.h (lang_padding_statement_type): Change size field to
bfd_size_type.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
d6593 1
a6593 1
      open_input_bfds (added.head, OPEN_BFD_NORMAL);
@


1.379
log
@	PR ld/13287
	* plugin.c (plugin_should_reload): New function.
	* plugin.h (plugin_should_reload): Declare.
	* ldlang.c (open_input_bfds): Use above function.
@
text
@d4599 1
a4599 1
	    unsigned int alignment_needed,
d4654 1
a4654 1
      unsigned int alignment_needed;
@


1.378
log
@	PR ld/12301
	* ldlang.h (lang_input_statement_type): Add "reload" bitfield.
	Clarify comments.
	* ldlang.c (new_afile): Init new field.
	(load_symbols): Don't call ldlang_add_file when reloading.
	(open_input_bfds): Reload as-needed libs during plugin rescan.
@
text
@d3285 2
a3286 1
		       && ((s->input_statement.the_bfd->flags) & DYNAMIC) != 0)
@


1.378.2.1
log
@	PR ld/13287
	2011-10-20  Alan Modra  <amodra@@gmail.com>
	* plugin.c (plugin_should_reload): New function.
	* plugin.h (plugin_should_reload): Declare.
	* ldlang.c (open_input_bfds): Use above function.
@
text
@d3285 1
a3285 2
		       && ((s->input_statement.the_bfd->flags) & DYNAMIC) != 0
		       && plugin_should_reload (s->input_statement.the_bfd))
@


1.378.2.2
log
@    PR ld/13991
    bfd/
    * bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
    _bfd_generic_link_just_syms.
    * bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
    * bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

    * bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
    * bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
    SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
    SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
    * bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
    * bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
    * bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
    * bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
    * bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
    * bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
    * bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
    * bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
    * bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
    * bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
    * bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
    * bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
    * bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
    * bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
    * bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
    * bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
    * bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
    * bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
    * bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
    * bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
    * bfd/reloc.c: Update all references.
    * bfd/bfd-in2.h: Regenerate.
    ld/
    * ld/ldlang.c (size_input_section): Use sec_info_type rather than
    usrdata->flags.just_syms.
    * ld/ldwrite.c (build_link_order): Likewise.
    * ld/emultempl/hppaelf.em (build_section_lists): Likewise.
    * ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
    * ld/emultempl/armelf.em (build_section_lists): Likewise.
    (after_allocation): Update for renamed sec_info_type value.
    * ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d4651 1
a4651 1
  if (i->sec_info_type != SEC_INFO_TYPE_JUST_SYMS
@


1.377
log
@Check if a symbol is hidden by linker script.

bfd/

2011-09-15  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12975
	* bfd-in.h (bfd_elf_size_dynamic_sections): Remove pointer
	to struct bfd_elf_version_tree.

	* elflink.c (elf_info_failed): Remove verdefs.
	(_bfd_elf_export_symbol): Updated.
	_bfd_elf_link_assign_sym_version): Likewise.
	(bfd_elf_size_dynamic_sections): Remove pointer to struct
	bfd_elf_version_tree.  Updated.
	(bfd_elf_gc_mark_dynamic_ref_symbol): Check if a symbol is hidden
	by linker script.

	* linker.c (bfd_hide_sym_by_version): New.

	* bfd-in2.h: Regenerated.

include/

2011-09-15  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12975
	* bfdlink.h (bfd_link_info): Add version_info.

ld/

2011-09-15  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12975
	* ldlang.c (lang_elf_version_info): Removed.
	(lang_register_vers_node): Replace lang_elf_version_info with
	link_info.version_info.
	(lang_add_vers_depend): Likewise.
	* pe-dll.c (process_def_file_and_drectve): Likewise.
	* emultempl/solaris2.em (elf_solaris2_before_allocation): Likewise.

	* ldlang.h (lang_elf_version_info): Removed.

	* plugin.c  (is_visible_from_outside): Check if symbol is hidden
	by version script.

	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation):
	Remove lang_elf_version_info.

ld/testsuite/

2011-09-15  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12975
	* ld-elf/pr12975.d: New.
	* ld-elf/pr12975.s: Likewise.
	* ld-elf/pr12975.t: Likewise.
@
text
@d1136 1
d2784 4
a2787 1
      ldlang_add_file (entry);
d3279 12
@


1.376
log
@	PR ld/12762
bfd/
	* bfd-in.h (struct bfd_section_already_linked): Forward declare.
	(_bfd_handle_already_linked): Declare.
	* coff-alpha.c (_bfd_ecoff_section_already_linked): Define as
	_bfd_coff_section_already_linked.
	* coff-mips.c (_bfd_ecoff_section_already_linked): Likewise.
	* coffcode.h (coff_section_already_linked): Likewise.
	* cofflink.c (coff_link_add_symbols): Revert 2011-07-09 changes.
	* elf-bfd.h: Likewise.
	* libbfd-in.h: Likewise.
	* targets.c: Likewise.
	* linker.c (bfd_section_already_linked): Likewise.
	(bfd_section_already_linked_table_lookup): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.
	(_bfd_generic_section_already_linked): Likewise.  Call
	_bfd_handle_already_linked.
	(_bfd_handle_already_linked): New function, split out from..
	* elflink.c (_bfd_elf_section_already_linked): ..here.  Revert
	2011-07-09 changes.  Avoid unnecessary strcmp when matching
	already_linked_list entries.  Match plugin linkonce section.
	(section_signature): Delete.
	* coffgen.c (_bfd_coff_section_already_linked): New function.
	* libcoff-in.h (_bfd_coff_section_already_linked): Declare.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
	* bfd-in2.h: Regenerate.
ld/
	* ldlang.c (section_already_linked): Revert 2011-07-09 changes.
	* plugin.c: Likewise.
	(asymbol_from_plugin_symbol): Create linkonce section for syms
	with comdat_key.
@
text
@a7460 4
/* This global variable holds the version tree that we build.  */

struct bfd_elf_version_tree *lang_elf_version_info;

d7802 2
a7803 2
  if ((name[0] == '\0' && lang_elf_version_info != NULL)
      || (lang_elf_version_info && lang_elf_version_info->name[0] == '\0'))
d7812 1
a7812 1
  for (t = lang_elf_version_info; t != NULL; t = t->next)
d7824 1
a7824 1
      for (t = lang_elf_version_info; t != NULL; t = t->next)
d7851 1
a7851 1
      for (t = lang_elf_version_info; t != NULL; t = t->next)
d7887 1
a7887 1
  for (pp = &lang_elf_version_info; *pp != NULL; pp = &(*pp)->next)
d7903 1
a7903 1
  for (t = lang_elf_version_info; t != NULL; t = t->next)
@


1.375
log
@Implement ld --print-output-format.
@
text
@d2243 1
a2243 6
    {
      struct already_linked linked;
      linked.comdat_key = NULL;
      linked.u.sec = sec;
      bfd_section_already_linked (abfd, &linked, &link_info);
    }
@


1.374
log
@include/ChangeLog
2011-07-11  Catherine Moore  <clm@@codesourcery.com>

	* bfdlink.h (flag_type): New enumeration.
	(flag_info_list): New structure.
	(flag_info): New structure.

bfd/ChangeLog
2011-07-11  Catherine Moore  <clm@@codesourcery.com>

	* aout-adobe.c (aout_32_bfd_lookup_section_flags): New definition.
	* aout-target.h (MY_bfd_lookup_section_flags): New definition.
	* aout-tic30.c (MY_bfd_lookup_section_flags): New definition.
        * bfd-in2.h: Regenerated.
	* bfd.c (bfd_lookup_section_flags): New definition.
	* binary.c (binary_bfd_lookup_section_flags): New definition.
	* bout.c (b_out_bfd_lookup_section_flags): New definition.
	* coff-alpha.c (_bfd_ecoff_bfd_lookup_section_flags): New definition.
	* coff-mips.c (_bfd_ecoff_bfd_lookup_section_flags): New definition.
	* coff-rs6000.c (rs6000coff_vec): Include
	bfd_generic_lookup_section_flags.
	(pmac_xcoff_vec): Likewise.
	* coffcode.h (coff_bfd_lookup_section_flags): New definition.
	* coff64-rs6000.c (rs6000coff64_vec): Include
	bfd_generic_lookup_section_flags.
	(aix5coff64_vec): Likewise.
	* ecoff.c (bfd_debug_section): Initialize flag_info field.
	* elf-bfd.h (elf_backend_lookup_section_flags_hook): Declare.
	(bfd_elf_lookup_section_flags): Declare.
	* elflink.c (bfd_elf_lookup_section_flags): New function.
	* elfxx-target.h (bfd_elfNN_bfd_lookup_section_flags): Define.
	(elf_backend_lookup_section_flags_hook): Define.
	(elf_backend_data): Add elf_backend_lookup_section_flags_hook.
	* i386msdos.c (msdos_bfd_lookup_section_flags): New define.
	* i386os9k.c (os9k_bfd_lookup_section_flags): New define.
	* ieee.c (ieee_bfd_lookup_section_flags): New define.
	* ihex.c (ihex_bfd_lookup_section_flags): New define.
	* libbfd-in.h (_bfd_nolink_bfd_lookup_section_flags): Declare.
	(bfd_generic_lookup_section_flags): Declare.
	* libbfd.h: Regenerated.
	* mach-o-target.c (bfd_mach_o_bfd_lookup_section_flags): New.
	* mmo.c (mmo_bfd_lookup_section_flags): New definition.
	* nlm-target.h (nlm_bfd_lookup_section_flags): New definition.
	* oasys.c (oasys_bfd_lookup_section_flags): New definition.
	* pef.c (bfd_pef_bfd_lookup_section_flags): New definition.
	* plugin.c (bfd_plugin_bfd_lookup_section_flags): New definition.
	* ppcboot.c (ppcboot_bfd_lookup_section_flags): New definition.
	* reloc.c (bfd_generic_lookup_section_flags): New function.
	* som.c (som_bfd_lookup_section_flags): New definition.
	* srec.c (srec_bfd_lookup_section_flags): New definition.
	* targets.c (flag_info): Declare.
	(NAME##_bfd_lookup_section_flags): Add to LINK jump table.
	(_bfd_lookup_section_flags): New.
	* tekhex.c (tekhex_bfd_lookup_section_flags): New definition.
	* versados.c (versados_bfd_lookup_section_flags): New definition.
	* vms-alpha.c (alpha_vms_bfd_lookup_section_flag): New definition.
	* xsym.c (bfd_sym_bfd_lookup_section_flags): New definition.

ld/ChangeLog
2011-07-11  Catherine Moore  <clm@@codesourcery.com>

	* ld.h (section_flag_list): Add field to struct wildcard_spec.
	* ld.texinfo (INPUT_SECTION_FLAGS): Document.
	* ldgram.y (flag_info_list, flag_info): Add to union.
	(INPUT_SECTION_FLAGS): New token.
	(wildcard_spec): Initialize section_flag_list to NULL for
	each alternative.
	(sect_flag_list, sect_flags): New rules.
	(input_section_spec_no_keep): Add alternatives to recognize
	sect_flags.
	* ldlang.c (walk_wild_consider_section): Initialize
	section_flag_info field of the section struct.
	(lang_add_section): Check input section flags.
	(lang_add_wild): Initialize section_flag_list field of
	the statement struct.
	* ldlang.h (lang_input_statement_struct): Add section_flag_list field.
	(lang_wild_statement_struct): Likewise.
	* ldlex.l (INPUT_SECTION_FLAGS): New token.
	* mri.c (mri_draw_tree): Initialize section_flag_list to NULL.
	* NEWS: Announce INPUT_SECTION_FLAGS enhancement.

ld/testsuite/ChangeLog
2011-07-11 Catherine Moore  <clm@@cm00re.com>

	* ld-scripts/section-flags-1.s: New.
	* ld-scripts/section-flags-1.t: New.
	* ld-scripts/section-flags-2.s: New.
	* ld-scripts/section-flags-2.t: New.
	* ld-scripts/section-flags.exp: New.
@
text
@d3055 1
a3055 1
  if (current_target != default_target)
@


1.373
log
@	PR ld/12942
bfd/
	* elflink.c (elf_link_add_object_symbols): Use elf_discarded_section
	rather than kept_section to determine whether a symbol is from
	a discarded section.
	* cofflink.c (coff_link_add_symbols): Make symbols from discarded
	sections appear undefined.

	* elf-bfd.h (_bfd_elf_section_already_linked): Replace
	"asection *" with "struct already_linked *".
	* libbfd-in.h (_bfd_nolink_section_already_linked): Likewise.
	(_bfd_generic_section_already_linked): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.
	(struct already_linked): New.
	(struct bfd_section_already_linked): Use it.
	* elflink.c (_bfd_elf_section_already_linked): Replace.
	"asection *" with "struct already_linked *".  Replace the plugin
	dummy with the LTO output.
	* linker.c (_bfd_generic_section_already_linked): Likewise.
	* targets.c (struct already_linked): Add forward declaration.
	(bfd_target): Replace "struct bfd_section *" with
	"struct already_linked *" in _section_already_linked.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.

include/
	* bfdlink.h (bfd_link_info): Add loading_lto_outputs.

ld/
	* ldlang.c (section_already_linked): Pass "struct already_linked *"
	to bfd_section_already_linked.
	(lang_process): Set link_info.loading_lto_outputs before
	loading LTO outputs.
	* plugin.c: Include "libbfd.h".
	(add_symbols): Call bfd_section_already_linked with comdat_key.
@
text
@d240 3
d2267 2
d2271 1
d2297 22
d6750 1
d6755 1
@


1.372
log
@	* ldlang.c (sort_def_symbol, lang_one_common): Don't handle
	warning symbols here.
	* emultempl/pe.em (pr_sym): Remove redundant test.
	* emultempl/pep.em (pr_sym): Likewise.
@
text
@d2240 6
a2245 1
    bfd_section_already_linked (abfd, sec, &link_info);
d6552 1
@


1.371
log
@	* ldlang.c (lang_one_common): Handle warning symbols.
@
text
@a2102 3
  if (hash_entry->type == bfd_link_hash_warning)
    hash_entry = (struct bfd_link_hash_entry *) hash_entry->u.i.link;

a5884 3
  if (h->type == bfd_link_hash_warning)
    h = h->u.i.link;

@


1.370
log
@	PR 12763
bfd/
	* elf.c (assign_file_positions_for_load_sections): Set sh_offset for
	.tbss, and page align same for all SHT_NOBITS sections.
ld/
	* ldlang.c (lang_output_section_find_by_flags): Match orphan .sdata2
	like sections to existing .sdata2, and similarly for orphan TLS
	sections.
	* emultempl/elf32.em (place_orphan): Exclude .tbss from orphan_bss.
@
text
@d5888 3
@


1.369
log
@	* ldlang.c (print_assignment): Use the symbol's section if we
	use its value.
	* ldexp.c (exp_fold_tree_1): Skip self-assignment.  Expand
	comment on copying symbol type.
@
text
@d1582 8
a1589 2
			 | SEC_READONLY))
	      && !(look->flags & (SEC_SMALL_DATA | SEC_THREAD_LOCAL)))
@


1.368
log
@	* ldlang.c (lang_leave_output_section_statement): Don't copy
	previous lma_region if given address.
@
text
@d4051 2
a4052 3

	      if (expld.result.section != NULL)
		value += expld.result.section->vma;
@


1.367
log
@	PR ld/12726
	* ldexp.h (lang_phase_type): Add lang_assigning_phase_enum.
	* ldexp.c (exp_fold_tree_1): Correct assign to dot comment.  Don't
	assign to dot when lang_assigning_phase_enum.
	* ldlang.h (lang_do_assignments): Update prototype.
	* ldlang.c (lang_do_assignments): Add phase parameter.  Update all
	callers.
	* pe-dll.c (pe_dll_fill_sections, pe_exe_fill_sections): Update
	lang_do_assignments calls.
@
text
@d6915 1
a6915 1
  /* If this section has no load region or base, but has the same
d6919 3
a6921 1
  if (!current_section->lma_region && !current_section->load_base
@


1.366
log
@	PR ld/12365
	PR ld/12672
bfd/
	* bfd.c (BFD_PLUGIN): Define.
	(BFD_FLAGS_SAVED, BFD_FLAGS_FOR_BFD_USE_MASK): Add BFD_PLUGIN.
	* bfd-in2.h: Regenerate.
	* elflink.c (elf_link_output_extsym): Strip undefined plugin syms.
	* opncls.c (bfd_make_readable): Don't lose original bfd flags.
ld/
	* ldfile.c (ldfile_try_open_bfd): Don't attempt any plugin action
	when no_more_claiming.
	* ldmain.c (add_archive_element): Likewise.
	(multiple_definition): Remove plugin_multiple_definition call.
	(notice): Remove plugin_notice call.
	* ldlang.c (lang_list_insert_after, void lang_list_remove_tail): Move.
	Delete prototype.
	(plugin_insert): New static var.
	(open_input_bfds): Only rescan libs after plugin insert point.
	(lang_gc_sections): Omit plugin claimed files.
	(lang_process): Set plugin_insert.  Only rescan when plugin adds
	objects.
	* plugin.h (no_more_claiming): Declare.
	(plugin_notice, plugin_multiple_definition): Don't declare.
	* plugin.c: Formatting.
	(orig_notice_all, orig_allow_multiple_defs, orig_callbacks,
	plugin_callbacks): New static vars.
	(no_more_claiming): Make global.
	(plugin_cached_allow_multiple_defs): Delete.
	(plugin_get_ir_dummy_bfd): Set SEC_EXCLUDE on dummy .text section,
	use newer bfd_make_section variant.  Make COMMON section too.
	Error handling.  Correct setting of gp size.
	(asymbol_from_plugin_symbol): Properly cast last arg of concat.
	(message): Likewise for ACONCAT.
	(asymbol_from_plugin_symbol): Use our COMMON section.
	(get_symbols): When report_plugin_symbols, show visibility too.
	(init_non_ironly_hash): Move.  Don't test non_ironly_hash.
	(plugin_load_plugins): Save state of linker callbacks, set up to
	call plugin_notice instead.  Call init_non_ironly_hash here.
	(plugin_call_all_symbols_read): Set plugin_multiple_definition in
	plugin callbacks.
	(plugin_notice): Rewrite.
	(plugin_multiple_definition): Make static, call original callback.
ld/testsuite/
	* ld-plugin/plugin-7.d: Adjust for plugin changes.
	* ld-plugin/plugin-8.d: Likewise.
	* ld-plugin/plugin.exp: Pass --verbose=2 for visibility test, and
	compare ld output to..
	* ld-plugin/plugin-12.d: New.
@
text
@d5609 1
a5609 1
lang_do_assignments (void)
d5611 1
d6407 1
a6407 1
	      lang_do_assignments ();
d6428 1
a6428 1
      lang_do_assignments ();
d6670 1
a6670 2
  expld.phase = lang_final_phase_enum;
  lang_do_assignments ();
@


1.365
log
@	PR ld/12672
	* ldlang.c (enum open_bfd_mode): New.
	(open_input_bfds): Replace "force" param with "mode".  Reload
	archives for rescan.  Update all callers.
	(lang_process): Make another open_input_bfds pass for plugins.
@
text
@a88 7
#ifdef ENABLE_PLUGINS
static void lang_list_insert_after (lang_statement_list_type *destlist,
				    lang_statement_list_type *srclist,
				    lang_statement_union_type **field);
static void lang_list_remove_tail (lang_statement_list_type *destlist,
				   lang_statement_list_type *origlist);
#endif /* ENABLE_PLUGINS */
d3176 3
d3235 4
d3274 6
d6288 4
d6465 32
d6529 1
d6555 1
a6555 1
	  lang_input_statement_type *claim1 = find_replacements_insert_point ();
d6560 4
a6563 3
	  ASSERT (claim1 != NULL);
	  /* Splice the new statement list into the old one after claim1.  */
	  lang_list_insert_after (stat_ptr, &added, &claim1->header.next);
d6566 1
a6566 1
				  &claim1->next_real_file);
d6570 2
a6571 2
	  if (claim1->filename)
	    lang_list_insert_after (&file_chain, &files, &claim1->next);
d6574 3
a6577 2
      /* Rescan any archives in case new undefined symbols have appeared.  */
      open_input_bfds (statement_list.head, OPEN_BFD_RESCAN);
a6999 34
#ifdef ENABLE_PLUGINS
/* Insert SRCLIST into DESTLIST after given element by chaining
   on FIELD as the next-pointer.  (Counterintuitively does not need
   a pointer to the actual after-node itself, just its chain field.)  */

static void
lang_list_insert_after (lang_statement_list_type *destlist,
			lang_statement_list_type *srclist,
			lang_statement_union_type **field)
{
  *(srclist->tail) = *field;
  *field = srclist->head;
  if (destlist->tail == field)
    destlist->tail = srclist->tail;
}

/* Detach new nodes added to DESTLIST since the time ORIGLIST
   was taken as a copy of it and leave them in ORIGLIST.  */

static void
lang_list_remove_tail (lang_statement_list_type *destlist,
		       lang_statement_list_type *origlist)
{
  union lang_statement_union **savetail;
  /* Check that ORIGLIST really is an earlier state of DESTLIST.  */
  ASSERT (origlist->head == destlist->head);
  savetail = origlist->tail;
  origlist->head = *(savetail);
  origlist->tail = destlist->tail;
  destlist->tail = savetail;
  *savetail = NULL;
}
#endif /* ENABLE_PLUGINS */

@


1.364
log
@[PATCH] Fix issue from GCC PR47527: no ELF flags, EABI attribs, etc. in dummy IR BFD.

ld/ChangeLog:

2011-03-10  Dave Korn  <dave.korn.cygwin@@gmail.com>

	* ldlang.c (lang_check): Don't run checks on dummy IR BFDs.
@
text
@d3177 7
d3185 1
a3185 1
open_input_bfds (lang_statement_union_type *s, bfd_boolean force)
d3192 1
a3192 1
	  open_input_bfds (constructor_list.head, force);
d3195 1
a3195 1
	  open_input_bfds (s->output_section_statement.children.head, force);
d3199 2
a3200 1
	  if (s->wild_statement.filename
d3204 1
a3204 1
	  open_input_bfds (s->wild_statement.children.head, force);
d3217 2
a3218 1
		open_input_bfds (s->group_statement.children.head, TRUE);
d3237 2
a3238 2
		 has been loaded already.  */
	      if (force
d6480 1
a6480 1
  open_input_bfds (statement_list.head, FALSE);
d6501 1
a6501 1
      open_input_bfds (added.head, FALSE);
d6531 2
@


1.363
log
@[PATCH] Revise linker plugin API to better preserve link order.

ld/ChangeLog:

2011-03-10  Dave Korn  <dave.korn.cygwin@@gmail.com>

	* ldlang.h (lang_input_statement_type): Add new 'claim_archive' flag,
	wrapping both it and 'claim' flag in #ifdef ENABLE_PLUGINS.
	* ldmain.c (add_archive_element): Set it if the member is claimed.
	* ldlang.c (new_afile): Initialise claim_archive and claimed members.
	(find_replacements_insert_point): New helper function.
	(lang_process): After adding and opening replacement files passed
	from plugin, splice them into correct place in statement list and
	file chains to preserve critical link order.
	(lang_list_insert_after): New helper function.
	(lang_list_remove_tail): Likewise.
@
text
@d5757 5
@


1.362
log
@2011-02-28  Kai Tietz  <kai.tietz@@onevision.com>

	* emultempl/beos.em (sort_by_file_name): Use filename_(n)cmp.
	* emultempl/elf32.em (gld${EMULATION_NAME}_vercheck):
	Likewise.
	(gld${EMULATION_NAME}_stat_needed): Likewise.
	(gld${EMULATION_NAME}_check_needed): Likewise.
	* emultempl/pe.em (gld_${EMULATION_NAME}_after_open): Likewise.
	(gld_${EMULATION_NAME}_unrecognized_file): Likewise.
	* emultempl/pep.em (gld_${EMULATION_NAME}_after_open): Likewise.
	(gld_${EMULATION_NAME}_unrecognized_file): Likewise.
	* ldfile.c (ldfile_open_file): Likewise.
	* ldlang.c (wild_sort): Likewise.
	(lookup_name): Likewise.
	(check_excluded_libs): Likewise.
	* ldmisc.c (vfinfo): Likewise.
	* pe-dll.c (libnamencmp): Likewise.
	(auto_export): Likewise.
	(pe_dll_generate_implib): Likewise.
	* testplug.c (onclaim_file): Likewise.
@
text
@d89 7
d1137 4
d6409 34
d6469 1
d6471 2
a6472 1
      union lang_statement_union **listend;
d6475 8
a6482 3
	 emulation's after_open hook.  */
      listend = statement_list.tail;
      ASSERT (!*listend);
d6486 31
a6516 5
      /* If any new files were added, they will be on the end of the
	 statement list, and we can open them now by getting open_input_bfds
	 to carry on from where it ended last time.  */
      if (*listend)
	open_input_bfds (*listend, FALSE);
d6939 34
@


1.361
log
@bfd/ld: handle ABI prefixes in version scripts

The default language in version scripts is supposed to be C, but no
symbol demangling is performed on the symbols by default.  This makes
targets with a symbol prefix to fail with most version scripts out
there.  So strip away this prefix by default.

This fixes many tests (real world and ld's testsuite) for Blackfin
targets and doesn't seem to cause regressions for x86_64.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d26 1
d2450 1
a2450 1
	  i = strcmp (fn, ln);
d2463 1
a2463 1
	      i = strcmp (fn, ln);
d2576 1
a2576 1
	  && strcmp (filename, name) == 0)
d2643 1
a2643 1
      if (strncmp (lib->name, filename, len) == 0
@


1.360
log
@	PR ld/12339
	* ldlang.c (sort_def_symbol): Handle bfd_link_hash_warning symbols.
@
text
@d7299 1
d7303 8
d7314 2
a7315 1
      cxx_sym = cplus_demangle (sym, DMGL_PARAMS | DMGL_ANSI);
d7321 1
a7321 1
      java_sym = cplus_demangle (sym, DMGL_JAVA);
d7335 1
a7335 1
	      e.pattern = sym;
d7338 1
a7338 1
	      while (expr && strcmp (expr->pattern, sym) == 0)
d7396 1
a7396 1
	s = sym;
d7402 2
@


1.359
log
@	PR ld/12356
	* ld.texinfo (Miscellaneous Commands): Describe LD_FEATURE.
	(Expression Section): Update.
	* ld.h (ld_config_type): Add sane_expr.
	* ldgram.y (ifile_p1): Add LD_FEATURE.
	* ldlex.l (LD_FEATYRE): New.
	* ldemul.c (after_parse_default): Delete code handling ld_compatibility.
	* ldexp.h (struct ldexp_control): Delete uses_defined.
	* ldexp.c: Remove all uses of uses_defined.
	(fold_name): Test config.sane_expr rather than ld_compatibility.
	(exp_fold_tree_1): Likewise.  Adjust handling of assignments
	during first phase.
	* ldlang.h (ld_compatibility): Delete.
	(lang_ld_feature): Declare.
	* ldlang.c (ld_compatibility): Delete.
	(open_input_bfds): Only handle assignments for --defsym.
	(lang_ld_feature): New function.
@
text
@d2092 3
@


1.358
log
@	PR ld/12356
	* ldexp.h (exp_assop): Delete.
	(exp_assign, exp_defsym): Declare.
	* ldexp.c (exp_assop): Make static, handle all assignment variations.
	(exp_assign, exp_defsym): New functions.
	(exp_provide): Use exp_assop.
	* ldgram.y (defsym_expr): Use exp_defsym.
	* ldctor.c, * ldgram.y, * ldlang.c, * mri.c, * emultempl/beos.em,
	* emultempl/pe.em, * emultempl/pep.em, * emultempl/spuelf.em,
	* emultempl/xtensaelf.em: Update exp_assop -> exp_assign.
@
text
@a110 1
int ld_compatibility;
d3252 3
a3254 1
	  exp_fold_tree_no_dot (s->assignment_statement.exp);
d7849 29
@


1.357
log
@	PR ld/12380
	* ldexp.h (enum phase_enum): Comment.  Add exp_dataseg_done.
	* ldexp.c (fold_unary <DATA_SEGMENT_END>): Rearrange code.  Test
	for exp_dataseg_done rather than expld.phase == lang_final_phase_enum
	to detect when we've finished sizing sections.
	(fold_binary <DATA_SEGMENT_ALIGN>): Likewise.
	(fold_binary <DATA_SEGMENT_RELRO_END>): Likewise.  Also test
	that we are not inside an output section statement.
	* ldlang.c (lang_size_sections): Set exp_dataseg_done on exit if
	not exp_dataseg_relro_adjust or exp_dataseg_adjust.  Don't set
	lang_final_phase_enum here.
	(lang_process): Set lang_final_phase_enum here.
@
text
@d1812 1
a1812 1
	  lang_add_assignment (exp_assop ('=', ".", e_align));
d7232 1
a7232 1
      = exp_assop ('=', ".", exp_binop ('+', overlay_vma, overlay_max));
@


1.356
log
@Remove startup_file from ldlang.c.

2011-01-10  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldlang.c (startup_file): Removed.
	(lang_startup): Updated.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
d5428 2
d5431 2
a5432 2

  expld.phase = lang_final_phase_enum;
d6525 1
a6525 1

@


1.355
log
@	* ld.texinfo (Expression Section): Describe treatment of numbers
	and absolute symbols.
	* ldemul.c (after_open_default): Look up __ld_compatibility.
	* ldexp.c (fold_name): Convert absolute symbols to numbers when
	inside output section definitions, or when __ld_compatibility >= 221.
	(exp_fold_tree_1): Convert numbers to absolute when not in output
	section definition and __ld_compatibility < 221.  Don't always
	convert values outside an output section definition to absolute.
	* ldexp.h (uses_defined): Comment.
	* ldlang.c (ld_compatibility): New variable.
	* ldlang.h (ld_compatibility): Declare.
	* emultempl/aix.em, * emultempl/armcoff.em, * emultempl/beos.em,
	* emultempl/elf32.em, * emultempl/genelf.em, * emultempl/lnk960.em,
	* emultempl/m68kcoff.em, * emultempl/mmo.em, * emultempl/pe.em,
	* emultempl/pep.em, * emultempl/sunos.em, * emultempl/z80.em: Call
	after_open_default from after_open function.
@
text
@a57 1
static const char *startup_file;
d6707 1
a6707 1
  if (startup_file != NULL)
a6713 2

  startup_file = name;
@


1.354
log
@	PR ld/12001
	Revert 2010-11-03 Nick Clifton
	* ldlang.c (ldlang_def_chain_list): Delete.
	(insert_defined, ldlang_add_def, lang_place_defineds): Delete.
	(lang_process): Don't call lang_place_defineds.
	(lang_add_assignment): Don't do anything special for --defsym.

	* ldexp.h (struct ldexp_control): Add uses_defined.
	(exp_fold_tree_no_dot): Declare.
	* ldexp.c (exp_fold_tree): Clear uses_defined.
	(exp_fold_tree_no_dot): Likewise.  Make global.
	(fold_name <DEFINED>): Set uses_defined.
	(exp_fold_tree_1 <etree_assign>): Define symbol during first phase
	even when the value being assigned isn't valid.
	* ldlang.c (open_input_bfds): Process assignment statements.
	(lang_process): Bump lang_statement_iteration.
	(scan_for_self_assignment): Formatting.
	(print_assignment): Style.

testsuite/
	* ld-scripts/default-script2.d: Revert 2010-11-03 change.
@
text
@d112 1
@


1.353
log
@Add SORT_BY_INIT_PRIORITY.

bfd/

2010-12-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf.c (_bfd_elf_new_section_hook): Special handling for
	.init_array/.fini_array output sections.

ld/

2010-12-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* Makefile.am (GENSCRIPTS): Add @@enable_initfini_array@@.

	* NEWS: Mention SORT_BY_INIT_PRIORITY.

	* configure.in: Add AC_CANONICAL_BUILD.
	Add --enable-initfini-array.

	* genscripts.sh (ENABLE_INITFINI_ARRAY): New.

	* ld.h (sort_type): Add by_init_priority.

	* ld.texinfo: Document SORT_BY_INIT_PRIORITY.

	* ldgram.y (SORT_BY_INIT_PRIORITY): New.
	(wildcard_spec): Handle SORT_BY_INIT_PRIORITY.

	* ldlang.c (get_init_priority): New.
	(compare_section): Use get_init_priority for by_init_priority.

	* ldlex.l (SORT_BY_INIT_PRIORITY): New.

	* scripttempl/elf.sc: Support ENABLE_INITFINI_ARRAY.

	* Makefile.in: Regenerated.
	* aclocal.m4: Regenerated.
	* config.in: Likewise.
	* configure: Likewise.

ld/testsuite/

2010-12-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-elf/elf.exp (array_tests): Add init-mixed.
	(array_tests_static): Likewise.
	Also delete tmpdir/init-mixed.

	* ld-elf/init-mixed.c: New.
	* ld-elf/init-mixed.out: Likewise.
@
text
@d3252 3
a3400 59
typedef struct bfd_sym_chain ldlang_def_chain_list_type;

static ldlang_def_chain_list_type ldlang_def_chain_list_head;

/* Insert NAME as defined in the symbol table.  */

static void
insert_defined (const char *name)
{
  struct bfd_link_hash_entry *h;

  h = bfd_link_hash_lookup (link_info.hash, name, TRUE, FALSE, TRUE);
  if (h == NULL)
    einfo (_("%P%F: bfd_link_hash_lookup failed: %E\n"));
  if (h->type == bfd_link_hash_new
      || h->type == bfd_link_hash_undefined
      || h->type == bfd_link_hash_undefweak)
    {
      h->type = bfd_link_hash_defined;
      h->u.def.section = bfd_abs_section_ptr;
      h->u.def.value   = 0;
    }
}

/* Like lang_add_undef, but this time for symbols defined on the
   command line.  */

static void
ldlang_add_def (const char *const name)
{
  if (link_info.output_bfd != NULL)
    insert_defined (xstrdup (name));
  else
    {
      ldlang_def_chain_list_type *new_def;

      new_def = (ldlang_def_chain_list_type *) stat_alloc (sizeof (*new_def));
      new_def->next = ldlang_def_chain_list_head.next;
      ldlang_def_chain_list_head.next = new_def;

      new_def->name = xstrdup (name);
    }
}

/* Run through the list of defineds created above and place them
   into the linker hash table as defined symbols belonging to the
   script file.  */

static void
lang_place_defineds (void)
{
  ldlang_def_chain_list_type *ptr;

  for (ptr = ldlang_def_chain_list_head.next;
       ptr != NULL;
       ptr = ptr->next)
    insert_defined (ptr->name);
}

d3929 2
a3930 2
      return scan_for_self_assignment (dst, rhs->binary.lhs)
	||   scan_for_self_assignment (dst, rhs->binary.rhs);
d3933 2
a3934 2
      return scan_for_self_assignment (dst, rhs->trinary.lhs)
	||   scan_for_self_assignment (dst, rhs->trinary.rhs);
d3989 1
a3989 1
      computation_is_valid = is_dot || (scan_for_self_assignment (dst, tree) == FALSE);
a6407 1
  lang_place_defineds ();
d6469 1
a6692 4
  extern int parsing_defsym;
  if (parsing_defsym)
    ldlang_add_def (exp->assign.dst);

@


1.352
log
@	* ldlang.c (load_symbols): Correct last change.
@
text
@d374 38
d418 1
d425 13
d446 1
@


1.351
log
@Optimize for add_archive_element.

bfd/

2010-12-12  H.J. Lu  <hongjiu.lu@@intel.com>

	* elflink.c (elf_link_add_archive_symbols): Remove subsbfd.

ld/

2010-12-12  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldlang.c (load_symbols): Optimize for add_archive_element.
@
text
@d2721 3
a2723 2
	      if (! ((*link_info.callbacks->add_archive_element)
		     (&link_info, member, "--whole-archive", &subsbfd)))
d2728 1
a2728 1
	      if (! bfd_link_add_symbols (member, &link_info))
@


1.350
log
@Replace is_archive with maybe_archive.

2010-12-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldfile.c (ldfile_open_file_search): Check maybe_archive instead
	of is_archive.
	* emultempl/aix.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/vms.em: Likewise.

	* ldlang.c (new_afile): Set maybe_archive instead of is_archive..

	* ldlang.h (lang_input_statement_struct): Replace is_archive
	with maybe_archive.
@
text
@d2720 1
a2720 1
	      subsbfd = NULL;
d2727 1
a2727 2
	      if (! bfd_link_add_symbols (subsbfd ? subsbfd : member,
					&link_info))
@


1.349
log
@	* ldlang.c (lang_size_sections_1): Align lma using same alignment
	as for vma.
@
text
@d1018 1
a1018 1
      p->is_archive = FALSE;
d1026 1
a1026 1
      p->is_archive = FALSE;
d1033 1
a1033 1
      p->is_archive = TRUE;
d1042 1
a1042 1
      p->is_archive = FALSE;
d1051 1
a1051 1
      p->is_archive = FALSE;
d1059 1
a1059 1
      p->is_archive = FALSE;
@


1.348
log
@Re-indent plugin code.

2010-11-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldfile.c: Re-indent plugin code.
	* ldlang.c: Likewise.
	* ldmain.c: Likewise.
	* plugin.c: Likewise.
@
text
@d4791 1
a4860 2
		int align;

d4911 1
a4911 1
		    align = os->bfd_section->alignment_power;
d4914 1
a4914 1
		  align = os->section_alignment;
d4917 1
a4917 1
		if (align > 0)
d4920 1
a4920 1
		    newdot = align_power (newdot, align);
d4976 2
a4977 2
		if (os->section_alignment != -1)
		  lma = align_power (lma, os->section_alignment);
d5018 2
a5019 2
		    if (os->section_alignment != -1)
		      lma = align_power (lma, os->section_alignment);
@


1.347
log
@	* ldlang.c (lang_add_section): Distinguish ELF treatment of NOLOAD.
	(map_input_to_output_sections): Likewise.
	(lang_size_sections_1): Likewise.
	(IGNORE_SECTION): Don't test SEC_NEVER_LOAD.
	(lang_check_section_addresses): Likewise.
@
text
@d6422 16
a6437 16
  {
    union lang_statement_union **listend;
    /* Now all files are read, let the plugin(s) decide if there
       are any more to be added to the link before we call the
       emulation's after_open hook.  */
    listend = statement_list.tail;
    ASSERT (!*listend);
    if (plugin_call_all_symbols_read ())
      einfo (_("%P%F: %s: plugin reported error after all symbols read\n"),
	plugin_error_plugin ());
    /* If any new files were added, they will be on the end of the
       statement list, and we can open them now by getting open_input_bfds
       to carry on from where it ended last time.  */
    if (*listend)
      open_input_bfds (*listend, FALSE);
  }
@


1.347.2.1
log
@Merge

Changes by:	amodra@@sourceware.org	2010-12-04 03:30:46

Modified files:
	ld             : ChangeLog ldlang.c

Log message:
	* ldlang.c (lang_size_sections_1): Align lma using same alignment
	as for vma.
@
text
@a4790 1
	    int section_alignment = 0;
d4860 2
d4912 1
a4912 1
		    section_alignment = os->bfd_section->alignment_power;
d4915 1
a4915 1
		  section_alignment = os->section_alignment;
d4918 1
a4918 1
		if (section_alignment > 0)
d4921 1
a4921 1
		    newdot = align_power (newdot, section_alignment);
d4977 2
a4978 2
		if (section_alignment > 0)
		  lma = align_power (lma, section_alignment);
d5019 2
a5020 2
		    if (section_alignment > 0)
		      lma = align_power (lma, section_alignment);
@


1.347.2.2
log
@backport from mainline
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
d1018 1
a1018 1
      p->maybe_archive = FALSE;
d1026 1
a1026 1
      p->maybe_archive = FALSE;
d1033 1
a1033 1
      p->maybe_archive = TRUE;
d1042 1
a1042 1
      p->maybe_archive = FALSE;
d1051 1
a1051 1
      p->maybe_archive = FALSE;
d1059 1
a1059 1
      p->maybe_archive = FALSE;
d1759 1
a1759 1
	  lang_add_assignment (exp_assign (".", e_align));
a2039 3
  if (hash_entry->type == bfd_link_hash_warning)
    hash_entry = (struct bfd_link_hash_entry *) hash_entry->u.i.link;

d2720 3
a2722 4
	      subsbfd = member;
	      if (!(*link_info.callbacks
		    ->add_archive_element) (&link_info, member,
					    "--whole-archive", &subsbfd))
d2727 2
a2728 1
	      if (!bfd_link_add_symbols (subsbfd, &link_info))
a3198 5
	case lang_assignment_statement_enum:
	  if (s->assignment_statement.exp->assign.hidden)
	    /* This is from a --defsym on the command line.  */
	    exp_fold_tree_no_dot (s->assignment_statement.exp);
	  break;
d3345 59
d3932 2
a3933 2
      return (scan_for_self_assignment (dst, rhs->binary.lhs)
	      || scan_for_self_assignment (dst, rhs->binary.rhs));
d3936 2
a3937 2
      return (scan_for_self_assignment (dst, rhs->trinary.lhs)
	      || scan_for_self_assignment (dst, rhs->trinary.rhs));
d3992 1
a3992 1
      computation_is_valid = is_dot || !scan_for_self_assignment (dst, tree);
a5430 2
      else
	expld.dataseg.phase = exp_dataseg_done;
d5432 2
a5433 2
  else
    expld.dataseg.phase = exp_dataseg_done;
d6411 1
d6421 16
a6436 16
    {
      union lang_statement_union **listend;
      /* Now all files are read, let the plugin(s) decide if there
	 are any more to be added to the link before we call the
	 emulation's after_open hook.  */
      listend = statement_list.tail;
      ASSERT (!*listend);
      if (plugin_call_all_symbols_read ())
	einfo (_("%P%F: %s: plugin reported error after all symbols read\n"),
	       plugin_error_plugin ());
      /* If any new files were added, they will be on the end of the
	 statement list, and we can open them now by getting open_input_bfds
	 to carry on from where it ended last time.  */
      if (*listend)
	open_input_bfds (*listend, FALSE);
    }
a6472 1
  lang_statement_iteration++;
d6526 1
a6526 1
  expld.phase = lang_final_phase_enum;
d6696 4
d7239 1
a7239 1
      = exp_assign (".", exp_binop ('+', overlay_vma, overlay_max));
a7854 29

/* Scan a space and/or comma separated string of features.  */

void
lang_ld_feature (char *str)
{
  char *p, *q;

  p = str;
  while (*p)
    {
      char sep;
      while (*p == ',' || ISSPACE (*p))
	++p;
      if (!*p)
	break;
      q = p + 1;
      while (*q && *q != ',' && !ISSPACE (*q))
	++q;
      sep = *q;
      *q = 0;
      if (strcasecmp (p, "SANE_EXPR") == 0)
	config.sane_expr = TRUE;
      else
	einfo (_("%X%P: unknown feature `%s'\n"), p);
      *q = sep;
      p = q;
    }
}
@


1.347.2.3
log
@	PR ld/12696
	PR ld/12672
	PR ld/12507
	PR ld/12365
	PR 10549
Backport fixes for these PRs.
@
text
@a1076 4
#ifdef ENABLE_PLUGINS
  p->claimed = FALSE;
  p->claim_archive = FALSE;
#endif /* ENABLE_PLUGINS */
a3112 10
enum open_bfd_mode
  {
    OPEN_BFD_NORMAL = 0,
    OPEN_BFD_FORCE = 1,
    OPEN_BFD_RESCAN = 2
  };
#ifdef ENABLE_PLUGINS
static lang_input_statement_type *plugin_insert = NULL;
#endif

d3114 1
a3114 1
open_input_bfds (lang_statement_union_type *s, enum open_bfd_mode mode)
d3121 1
a3121 1
	  open_input_bfds (constructor_list.head, mode);
d3124 1
a3124 1
	  open_input_bfds (s->output_section_statement.children.head, mode);
d3128 1
a3128 2
	  if ((mode & OPEN_BFD_RESCAN) == 0
	      && s->wild_statement.filename
d3132 1
a3132 1
	  open_input_bfds (s->wild_statement.children.head, mode);
d3145 1
a3145 2
		open_input_bfds (s->group_statement.children.head,
				 mode | OPEN_BFD_FORCE);
d3164 2
a3165 6
		 has been loaded already.  Do the same for a rescan.  */
	      if (mode != OPEN_BFD_NORMAL
#ifdef ENABLE_PLUGINS
		  && ((mode & OPEN_BFD_RESCAN) == 0
		      || plugin_insert == NULL)
#endif
a3200 6
#ifdef ENABLE_PLUGINS
	  /* If we have found the point at which a plugin added new
	     files, clear plugin_insert to enable archive rescan.  */
	  if (&s->input_statement == plugin_insert)
	    plugin_insert = NULL;
#endif
a5692 5
#ifdef ENABLE_PLUGINS
      /* Don't check format of files claimed by plugin.  */
      if (file->input_statement.claimed)
	continue;
#endif /* ENABLE_PLUGINS */
a6203 4
#ifdef ENABLE_PLUGINS
	  if (f->claimed)
	    continue;
#endif
a6344 66
#ifdef ENABLE_PLUGINS
/* Find the insert point for the plugin's replacement files.  We
   place them after the first claimed real object file, or if the
   first claimed object is an archive member, after the last real
   object file immediately preceding the archive.  In the event
   no objects have been claimed at all, we return the first dummy
   object file on the list as the insert point; that works, but
   the callee must be careful when relinking the file_chain as it
   is not actually on that chain, only the statement_list and the
   input_file list; in that case, the replacement files must be
   inserted at the head of the file_chain.  */

static lang_input_statement_type *
find_replacements_insert_point (void)
{
  lang_input_statement_type *claim1, *lastobject;
  lastobject = &input_file_chain.head->input_statement;
  for (claim1 = &file_chain.head->input_statement;
       claim1 != NULL;
       claim1 = &claim1->next->input_statement)
    {
      if (claim1->claimed)
	return claim1->claim_archive ? lastobject : claim1;
      /* Update lastobject if this is a real object file.  */
      if (claim1->the_bfd && (claim1->the_bfd->my_archive == NULL))
	lastobject = claim1;
    }
  /* No files were claimed by the plugin.  Choose the last object
     file found on the list (maybe the first, dummy entry) as the
     insert point.  */
  return lastobject;
}

/* Insert SRCLIST into DESTLIST after given element by chaining
   on FIELD as the next-pointer.  (Counterintuitively does not need
   a pointer to the actual after-node itself, just its chain field.)  */

static void
lang_list_insert_after (lang_statement_list_type *destlist,
			lang_statement_list_type *srclist,
			lang_statement_union_type **field)
{
  *(srclist->tail) = *field;
  *field = srclist->head;
  if (destlist->tail == field)
    destlist->tail = srclist->tail;
}

/* Detach new nodes added to DESTLIST since the time ORIGLIST
   was taken as a copy of it and leave them in ORIGLIST.  */

static void
lang_list_remove_tail (lang_statement_list_type *destlist,
		       lang_statement_list_type *origlist)
{
  union lang_statement_union **savetail;
  /* Check that ORIGLIST really is an earlier state of DESTLIST.  */
  ASSERT (origlist->head == destlist->head);
  savetail = origlist->tail;
  origlist->head = *(savetail);
  origlist->tail = destlist->tail;
  destlist->tail = savetail;
  *savetail = NULL;
}
#endif /* ENABLE_PLUGINS */

d6368 1
a6368 1
  open_input_bfds (statement_list.head, OPEN_BFD_NORMAL);
a6370 1
  if (plugin_active_plugins_p ())
d6372 1
a6372 3
      lang_statement_list_type added;
      lang_statement_list_type files, inputfiles;

d6375 3
a6377 8
	 emulation's after_open hook.  We create a private list of
	 input statements for this purpose, which we will eventually
	 insert into the global statment list after the first claimed
	 file.  */
      added = *stat_ptr;
      /* We need to manipulate all three chains in synchrony.  */
      files = file_chain;
      inputfiles = input_file_chain;
d6381 5
a6385 35
      /* Open any newly added files, updating the file chains.  */
      open_input_bfds (added.head, OPEN_BFD_NORMAL);
      /* Restore the global list pointer now they have all been added.  */
      lang_list_remove_tail (stat_ptr, &added);
      /* And detach the fresh ends of the file lists.  */
      lang_list_remove_tail (&file_chain, &files);
      lang_list_remove_tail (&input_file_chain, &inputfiles);
      /* Were any new files added?  */
      if (added.head != NULL)
	{
	  /* If so, we will insert them into the statement list immediately
	     after the first input file that was claimed by the plugin.  */
	  plugin_insert = find_replacements_insert_point ();
	  /* If a plugin adds input files without having claimed any, we
	     don't really have a good idea where to place them.  Just putting
	     them at the start or end of the list is liable to leave them
	     outside the crtbegin...crtend range.  */
	  ASSERT (plugin_insert != NULL);
	  /* Splice the new statement list into the old one.  */
	  lang_list_insert_after (stat_ptr, &added,
				  &plugin_insert->header.next);
	  /* Likewise for the file chains.  */
	  lang_list_insert_after (&input_file_chain, &inputfiles,
				  &plugin_insert->next_real_file);
	  /* We must be careful when relinking file_chain; we may need to
	     insert the new files at the head of the list if the insert
	     point chosen is the dummy first input file.  */
	  if (plugin_insert->filename)
	    lang_list_insert_after (&file_chain, &files, &plugin_insert->next);
	  else
	    lang_list_insert_after (&file_chain, &files, &file_chain.head);

	  /* Rescan archives in case new undefined symbols have appeared.  */
	  open_input_bfds (statement_list.head, OPEN_BFD_RESCAN);
	}
@


1.347.2.4
log
@	PR ld/12726
	* ldexp.h (lang_phase_type): Add lang_assigning_phase_enum.
	* ldexp.c (exp_fold_tree_1): Correct assign to dot comment.  Don't
	assign to dot when lang_assigning_phase_enum.
	* ldlang.h (lang_do_assignments): Update prototype.
	* ldlang.c (lang_do_assignments): Add phase parameter.  Update all
	callers.
	* pe-dll.c (pe_dll_fill_sections, pe_exe_fill_sections): Update
	lang_do_assignments calls.
@
text
@d5556 1
a5556 1
lang_do_assignments (lang_phase_type phase)
a5557 1
  expld.phase = phase;
d6353 1
a6353 1
	      lang_do_assignments (lang_assigning_phase_enum);
d6374 1
a6374 1
      lang_do_assignments (lang_assigning_phase_enum);
d6616 2
a6617 1
  lang_do_assignments (lang_final_phase_enum);
@


1.347.2.5
log
@	* ldlang.c (lang_leave_output_section_statement): Don't copy
	previous lma_region if given address.
@
text
@d6864 1
a6864 1
  /* If this section has no load region or base, but uses the same
d6868 1
a6868 3
  if (current_section->lma_region == NULL
      && current_section->load_base == NULL
      && current_section->addr_tree == NULL
@


1.347.2.6
log
@	PR 12365
	PR 12613
	PR 12632
	PR 12739
	PR 12753
	PR 12760
	PR 12763
Apply fix from mainline along with assorted other small fixes.
@
text
@d1529 2
a1530 8
			 | SEC_READONLY | SEC_SMALL_DATA))
	      || (!(flags & (SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD
			     | SEC_READONLY))
		  && !(look->flags & SEC_SMALL_DATA))
	      || (!(flags & (SEC_THREAD_LOCAL | SEC_ALLOC))
		  && (look->flags & SEC_THREAD_LOCAL)
		  && (!(flags & SEC_LOAD)
		      || (look->flags & SEC_LOAD))))
d3998 3
a4000 2
	      value += h->u.def.section->output_section->vma;
	      value += h->u.def.section->output_offset;
a7389 1
  const char *c_sym;
a7392 8
  enum demangling_styles curr_style;

  curr_style = CURRENT_DEMANGLING_STYLE;
  cplus_demangle_set_style (no_demangling);
  c_sym = bfd_demangle (link_info.output_bfd, sym, DMGL_NO_OPTS);
  if (!c_sym)
    c_sym = sym;
  cplus_demangle_set_style (curr_style);
d7396 1
a7396 2
      cxx_sym = bfd_demangle (link_info.output_bfd, sym,
			      DMGL_PARAMS | DMGL_ANSI);
d7402 1
a7402 1
      java_sym = bfd_demangle (link_info.output_bfd, sym, DMGL_JAVA);
d7416 1
a7416 1
	      e.pattern = c_sym;
d7419 1
a7419 1
	      while (expr && strcmp (expr->pattern, c_sym) == 0)
d7477 1
a7477 1
	s = c_sym;
a7482 2
  if (c_sym != sym)
    free ((char *) c_sym);
@


1.346
log
@        PR ld/12001
        * ldlang.c (ldlang_def_chain_list): New variable.  Contains a list
        of symbols defined via the --defsym command line option and
        currently waiting assignment.
        (insert_defined): Add a defined symbol to the symbol table.
        (ldlang_add_def): Add a entry to the ldlang_def_chain_list.
        (lang_place_defineds): Walk ldlang_def_chain_list defining the
        symbols.
        (lang_process): Call lang_place_defineds.
        (lang_add_assignment): If the assignment has come from a --defsym
        command line option then call lang_add_def.

        * ld-script/default-script2.d: Fix expected address for text
        section.

        PR gold/12001
        * script.h (class Symbol_assignment: name): New member.  Returns
        the name of the symbol.
        * scrfipt.cc (Script_options::is_pending_assignment): New member.
        Returns true if the given symbol name is on the list of
        assignments wating to be processed.
        * archive.cc (should_incldue_member): If the symbol is undefined,
        check to see if it is on the list of symbols pending assignment.
@
text
@d2253 6
a2258 8
      if (((bfd_get_flavour (section->owner)
	    == bfd_target_ecoff_flavour)
	   || (bfd_get_flavour (section->owner)
	       == bfd_target_coff_flavour)))
	{
	  if ((flags & (SEC_COFF_SHARED_LIBRARY | SEC_DEBUGGING)) == 0)
	    flags &= ~SEC_HAS_CONTENTS;
	}
d2260 1
a2260 1
	flags &= ~SEC_HAS_CONTENTS;
d3572 5
a3576 1
	      flags = SEC_NEVER_LOAD;
a4637 3
/* On ELF, a debugging section must never set SEC_NEVER_LOAD, as no output
   would be written for it. So the combination of debugging and never-load
   is something which can only happen for pe-coff and must not be ignored.  */
d4639 2
a4640 3
  ((s->flags & (SEC_NEVER_LOAD | SEC_DEBUGGING)) == SEC_NEVER_LOAD	\
   || (s->flags & SEC_ALLOC) == 0				\
   || ((s->flags & SEC_THREAD_LOCAL) != 0			\
d4672 1
a4672 2
      if ((s->flags & (SEC_NEVER_LOAD | SEC_DEBUGGING)) == SEC_NEVER_LOAD
	  || !(s->flags & SEC_LOAD)
d5251 4
a5254 1
		    if (output_section_statement->sectype != noalloc_section)
@


1.345
log
@	* ldlang.h (ldlang_add_undef): Add cmdline param.
	* ldlang.c (undef_from_cmdline): New var.
	(ldlang_add_undef): Add cmdline param.  Set undef_from_cmdline.
	(lang_end): Really require -e or -u from command line on
	relocatable --gc-sections.
	* ldemul.c (after_parse_default): Adjust ldlang_add_undef call.
	* ldgram.y (extern_name_list_body): Likewise.
	* lexsup.c (parse_args): Likewise.
	* emultempl/aix.em (gld${EMULATION_NAME}_read_file): Likewise.
@
text
@d3347 59
d6412 1
d6697 4
@


1.344
log
@Applied patch series for LD plugin interface (six parts).

[PATCH] Add infrastructure for plugin API; functionality to follow.

    include/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 1/6).
	* plugin-api.h (LDPT_GNU_LD_VERSION): New ld_plugin_tag enum member.

    ld/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 1/6).
	* configure.in: Add AC_CHECKs for file io and dlfcn headers and
	functions and AC_SEARCH for -ldl.
	(enable_plugins): New shell variable set if above tests find dlopen
	functionality.
	(ENABLE_PLUGINS): Add related automake conditional.
	* configure: Regenerate.
	* config.in: Likewise.
	* Makefile.am (PLUGIN_C): Declare plugin C source file, conditional
	on ENABLE_PLUGINS being defined.
	(PLUGIN_H): Likewise for header file.
	(PLUGIN_OBJECT): Likewise for object file.
	(PLUGIN_CFLAGS): Likewise -D flag required to compile plugin support.
	(AM_CPPFLAGS): Use PLUGIN_CFLAGS.
	(CFILES): Use PLUGIN_C.
	(HFILES): Use PLUGIN_H.
	(OFILES): Use PLUGIN_OBJECT.
	(ld_new_SOURCES): Use PLUGIN_C.
	(noinst_LTLIBRARIES)[ENABLE_PLUGINS]: Declare test plugin.
	(libldtestplug_la_SOURCES)[ENABLE_PLUGINS]: Add automake definition
	for test plugin.
	(libldtestplug_la_CFLAGS)[ENABLE_PLUGINS]: Likewise.
	(libldtestplug_la_LDFLAGS)[ENABLE_PLUGINS]: Likewise.
	* Makefile.in: Regenerate.
	* sysdep.h: Include stdarg.h, unistd.h and one of fcntl.h or
	sys/file.h where available.  Include dlfcn.h when ENABLE_PLUGINS.
	(O_RDONLY): Supply default definition likewise to bfd's sysdep.h
	(O_WRONLY): Likewise.
	(O_RDWR): Likewise.
	(O_ACCMODE): Likewise.
	(O_BINARY): Likewise.
	(SEEK_SET): Likewise.
	(SEEK_CUR): Likewise.
	(SEEK_END): Likewise.
	* ldmisc.c (vfinfo): Make non-static.  Add %p format char.
	* ldmisc.h (vfinfo): Declare extern prototype.
	* lexsup.c (enum option_values)[ENABLE_PLUGINS]: Add new entries for
	OPTION_PLUGIN and OPTION_PLUGIN_OPT.
	(ld_options[])[ENABLE_PLUGINS]: Add option data for the above two.
	(parse_args)[ENABLE_PLUGINS]: Handle them, and load all plugins once
	option parsing is complete.
	* ldmain.c (main)[ENABLE_PLUGINS]: Call plugin cleanup hooks just
	after lang_finish.
	* plugin.c: New source file.
	* plugin.h: Likewise new header.
	* testplug.c: New source file.

    ld/testsuite/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 1/6).
	* ld-bootstrap/bootstrap.exp: Skip static tests also if LD plugins
	are enabled.
	* lib/ld-lib.exp (proc regexp_diff): Extend verbose debug output.
	(proc set_file_contents): Write a file with the supplied content.
	(run_ld_link_tests): Add new 'ld' action to test linker output.
	(proc check_plugin_api_available): Return true if linker under test
	supports the plugin API.
	* ld-plugin/func.c: New test source file.
	* ld-plugin/main.c: Likewise.
	* ld-plugin/text.c: Likewise.
	* ld-plugin/plugin-1.d: New dump test output pattern script.
	* ld-plugin/plugin-2.d: Likewise.
	* ld-plugin/plugin-3.d: Likewise.
	* ld-plugin/plugin-4.d: Likewise.
	* ld-plugin/plugin-5.d: Likewise.
	* ld-plugin/plugin.exp: New test control script.
---
[PATCH] Implement claim file and all symbols read hooks and add symbols callback.

  ld/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 2/6).
	* ldfile.c (ldfile_try_open_bfd)[ENABLE_PLUGINS]: Don't return early
	during compat checks if they pass, instead offer any successfully
	opened and accepted file to the plugin claim file hooks chain.  Create
	a dummy bfd to accept symbols added by the plugin, if the plugin
	claims the file.
	* ldlang.c (lang_process)[ENABLE_PLUGINS]: Call plugin all symbols
	read hook chain before ldemul_after_open.
	* ldlang.h (struct lang_input_statement_struct): Add new single-bit
	'claimed' flag.
	* plugin.c (IRONLY_SUFFIX): New macro for dummy bfd file suffix.
	(IRONLY_SUFFIX_LEN): Length of the above string.
	(plugin_get_ir_dummy_bfd): New function to create the dummy bfd used
	to store symbols for ir-only files.
	(is_ir_dummy_bfd): New function to check if a bfd is ir-only.
	(asymbol_from_plugin_symbol): New function converts symbol formats.
	(add_symbols): Call it to convert plugin syms to bfd syms and add
	them to the dummy bfd.
	* plugin.h: Add missing include guards.
	(plugin_get_ir_dummy_bfd): Add prototype.
	(is_ir_dummy_bfd): Likewise.
	* testplug.c (TV_MESSAGE): New helper macro.
	(struct claim_file): New struct.
	(claim_file_t): New typedef.
	(tag_names[]): Make static and const.
	(claimfiles_list): New variable.
	(claimfiles_tail_chain_ptr): Likewise.
	(last_claimfile): Likewise.
	(record_claim_file): Record a file to claim on a singly-linked list.
	(parse_symdefstr): Parse an ASCII representation of a symbol from a
	plugin option into the fields of a struct ld_plugin_symbol.
	(record_claimed_file_symbol):  Use it to parse plugin option for
	adding a symbol.
	(parse_option): Parse claim file and add symbol options.
	(dump_tv_tag): Use TV_MESSAGE.
	(onload): Likewise.
	(onclaim_file): Make static.  Use TV_MESSAGE.  Scan list of files to
	claim and claim this file if required, adding any symbols specified.
	(onall_symbols_read): Make static and use TV_MESSAGE.
	(oncleanup): Likewise.

  ld/testsuite/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 2/6).
	* ld-plugin/plugin-3.d: Enable regexes for new functionality.
	* ld-plugin/plugin-5.d: Likewise.
	* ld-plugin/plugin-6.d: New testcase.
	* ld-plugin/plugin-7.d: Likewise.
	* ld-plugin/plugin.exp: Use 'nm' on compiled test objects to determine
	whether symbols in plugin arguments need an underscore prefix.  Add
	new plugin-6.d and plugin-7.d testcases.
---
[PATCH] Implement get symbols callback.

  ld/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 3/6).
	* ldmain.c (notice)[ENABLE_PLUGINS]: Call plugin_notice.
	* plugin.c (non_ironly_hash): Add new bfd hash table.
	(plugin_load_plugins): Exit early if no plugins to load.  If plugins
	do load successfully, set notice_all flag in link info.
	(get_symbols): Implement.
	(plugin_load_plugins): Exit early if no plugins to load, else after
	loading plugins successfully enable notice_all mode.
	(init_non_ironly_hash): Lazily init non_ironly_hash table.
	(plugin_notice): Record symbols referenced from non-IR files in the
	non_ironly_hash.  Suppress tracing, cref generation and nocrossrefs
	tracking for symbols from dummy IR bfds.
	* plugin.h: Fix formatting.
	(plugin_notice): Add prototype.
	* testplug.c (dumpresolutions): New global var.
	(parse_options): Accept "dumpresolutions".
	(onall_symbols_read): Get syms and dump resolutions if it was given.

  ld/testsuite/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 3/6).
	* ld-plugin/plugin-8.d: New testcase.
	* ld-plugin/plugin.exp: Invoke it.
---
[PATCH] Implement add input file, add input lib and set extra lib path callbacks.

  ld/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 4/6).
	* ldlang.c (lang_process)[ENABLE_PLUGINS]: Move invocation of
	plugin_call_all_symbols_read to before setting of gc_sym_list, and
	open any new input files that may have been added during it.
	* ldmain.c (multiple_definition)[ENABLE_PLUGINS]: Call out to
	plugin_multiple_definition and let it have first say over what to do
	with the clashing definitions.
	* plugin.c (no_more_claiming): New boolean variable.
	(plugin_cached_allow_multiple_defs): Likewise.
	(add_input_file): Implement.
	(add_input_library): Likewise.
	(set_extra_library_path): Likewise.
	(plugin_call_claim_file): Don't do anything when no_more_claiming set.
	(plugin_call_all_symbols_read): Set it.  Disable link info
	"allow_multiple_definition" flag, but cache its value.
	(plugin_multiple_definition): New function.
	* plugin.h (plugin_multiple_definition): Add prototype.
	* testplug.c (addfile_enum_t): New enumerated typedef.
	(add_file_t): New struct typedef.
	(addfiles_list): New variable.
	(addfiles_tail_chain_ptr): Likewise.
	(record_add_file): New function.
	(parse_option): Parse "add:", "lib:" and "dir:" options and call it.
	(onall_symbols_read): Iterate the list of new files, libs and dirs,
	adding them.

  ld/testsuite/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 4/6).
	* ld-plugin/plugin-9.d: New testcase.
	* ld-plugin/plugin.exp: Invoke it.
---
[PATCH] Add ELF symbol visibility support to plugin interface.

  ld/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 5/6).
	* plugin.c (asymbol_from_plugin_symbol): If the bfd is an ELF bfd,
	find the elf symbol data and set the visibility in the st_other field.

  ld/testsuite/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 5/6).
	* ld-plugin/plugin-ignore.d: New dump test control script.
	* ld-plugin/plugin-vis-1.d: Likewise.
	* ld-plugin/plugin.exp: Add list of ELF-only tests and run them if
	testing on an ELF target.
---
[PATCH] Add archive support to plugin interface.

  bfd/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 6/6).
	* aoutx.h (aout_link_check_ar_symbols): Take new "subsbfd" reference
	parameter and pass it when invoking add_archive_element callback.
	(aout_link_check_archive_element): Handle substitute bfd if it
	was set during add_archive_element callback in the above.
	* cofflink.c (coff_link_check_ar_symbols): Take new "subsbfd" reference
	parameter and pass it when invoking add_archive_element callback.
	(coff_link_check_archive_element): Handle substitute bfd if it
	was set during add_archive_element callback in the above.
	* ecoff.c (read_ext_syms_and_strs): New function holds symbol-reading
	code factored-out from ecoff_link_check_archive_element.
	(reread_ext_syms_and_strs): Clear old symbols and call it.
	(ecoff_link_check_archive_element):  Use the above.  Handle substitute
	BFD if one is set by add_archive_element callback.
	(ecoff_link_add_archive_symbols): Likewise allow bfd substitution.
	* elflink.c (elf_link_add_archive_symbols): Likewise.
	* linker.c (generic_link_check_archive_element): Likewise.
	* pdp11.c (aout_link_check_ar_symbols): Take new "subsbfd" reference
	parameter and pass it when invoking add_archive_element callback.
	(aout_link_check_archive_element): Handle substitute bfd if it was
	set during add_archive_element callback in the above.
	* vms-alpha.c (alpha_vms_link_add_archive_symbols): Handle substitute
	BFD if one is set by add_archive_element callback.
	* xcofflink.c (xcoff_link_check_dynamic_ar_symbols): Take new "subsbfd"
	reference parameter and pass it when invoking add_archive_element
	callback.
	(xcoff_link_check_ar_symbols): Likewise.
	(xcoff_link_check_archive_element): Handle bfd substitution if it was
	set by callback in the above.

  include/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 6/6).
	* bfdlink.h (struct_bfd_link_callbacks): Document new argument
	to add_archive_element callback used to return a replacement bfd which
	is to be added to the hash table in place of the original element.

  ld/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 6/6).
	* ldlang.c (load_symbols): Handle bfd subsitution when calling the
	add_archive_element callback.
	* ldmain.c (add_archive_element)[ENABLE_PLUGINS]: Offer the archive
	member to the plugins and if claimed set "subsbfd" output parameter to
	point to the dummy IR-only BFD.

  ld/testsuite/ChangeLog:

2010-10-14  Dave Korn  <dave.korn.cygwin@@gmail.com>

	Apply LD plugin patch series (part 6/6).
	* ld-plugin/plugin-10.d: New dump test control script.
	* ld-plugin/plugin-11.d: Likewise.
	* ld-plugin/plugin.exp: Run them.
---
@
text
@d104 1
d3301 1
a3301 1
ldlang_add_undef (const char *const name)
d3303 1
a3303 2
  ldlang_undef_chain_list_type *new_undef = (ldlang_undef_chain_list_type *)
      stat_alloc (sizeof (ldlang_undef_chain_list_type));
d3305 2
d5588 1
a5588 2
      && (entry_symbol.name == NULL
	  && ldlang_undef_chain_list_head == NULL))
@


1.343
log
@	* ldlang.c (lang_place_orphans): Zero vma when relocatable or non-load
	section for orphans handled here.
@
text
@d43 4
d2708 1
d2721 1
d2723 1
a2723 1
		     (&link_info, member, "--whole-archive")))
d2726 4
a2729 1
	      if (! bfd_link_add_symbols (member, &link_info))
d6360 19
@


1.342
log
@ld/
	* ldlang.c (lang_add_section): Don't copy SEC_RELOC from input
	to output section on a final link.
bfd/
	* elf.c (_bfd_elf_init_private_section_data): Allow for SEC_RELOC
	difference between input and output section.
@
text
@d5909 4
@


1.341
log
@2010-09-22  Kai Tietz  <kai.tietz@@onevision.com>

        * ldlang.c (lang_add_section): Allow for debugging
        section to be marked as noload but to keep content.
        (IGNORE_SECTION): Likewise.
        (lang_check_section_addresses): Likewise.
        * ldwrite.c (build_link_order): Likewise.
@
text
@d2235 1
a2235 1
    flags &= ~ (SEC_LINK_ONCE | SEC_LINK_DUPLICATES);
@


1.340
log
@bfd/
	* elf.c (bfd_elf_get_default_section_type): Don't test SEC_NEVER_LOAD.
	* elflink.c (elf_link_input_bfd): Likewise.
ld/
	* ld.texinfo (NOLOAD): Do not erroneously state that contents will
	appear in output file.
	* ldlang.c (lang_add_section): Clear SEC_HAS_CONTENTS on noload
	unless SEC_COFF_SHARED_LIBRARY.
	(map_input_to_output_sections): Don't set SEC_HAS_CONTENTS for noload
	output sections.
	(lang_size_sections_1): Don't test SEC_NEVER_LOAD when deciding
	to update dot in region.  Ditto when setting SEC_ALLOC if dot
	advanced due to assignment.
	* ldwrite.c (build_link_order): Don't test SEC_NEVER_LOAD.
@
text
@d2248 9
a2256 1
      if ((flags & SEC_COFF_SHARED_LIBRARY) == 0)
d4566 3
d4570 1
a4570 1
  ((s->flags & SEC_NEVER_LOAD) != 0				\
d4604 1
a4604 1
      if ((s->flags & SEC_NEVER_LOAD)
@


1.339
log
@	PR ld/11931
	* ldlang.h (lang_for_each_statement_worker): Declare.
	* ldlang.c (lang_for_each_statement_worker): Make global.  Don't
	recurse into children of output_section_statement with constraint
	set to -1.
	(print_assignment): Handle NULL output_section->bfd_section.
	(lang_size_sections_1): Ignore output section statement address
	when constraint is -1.
	* emultempl/xtensaelf.em (lang_for_each_statement_worker): Delete.
@
text
@d2248 2
d3484 2
a3485 2
	  /* The output section gets CONTENTS, and usually ALLOC and
	     LOAD, but the latter two may be overridden by the script.  */
d3496 1
a3496 1
	      flags = SEC_HAS_CONTENTS | SEC_NEVER_LOAD;
d4984 1
a4984 5
	       overall size in memory.

	       If the SEC_NEVER_LOAD bit is not set, it will affect the
	       addresses of sections after it. We have to update
	       dot.  */
d4986 1
a4986 2
		&& ((os->bfd_section->flags & SEC_NEVER_LOAD) == 0
		    || (os->bfd_section->flags & (SEC_ALLOC | SEC_LOAD))))
d5172 2
a5173 2
		       should never be loaded.  */
		    if (!(output_section_statement->flags & SEC_NEVER_LOAD))
@


1.338
log
@binutils/
	* NEWS: Mention change in linker script expression evaluation.
ld/
	* ld.texinfo (Expression Section): Detail expression evaluation.
	(Builtin Functions <ADDR>): Correct.
	(Builtin Functions <LOADADDR>): Don't mention LOADADDR normally
	the same as ADDR.
	(Builtin Functions <SEGMENT_START>): Typo fix.
	* ldexp.c (new_number): New function.
	(make_abs, exp_get_abs_int): Cope with NULL expld.result.section.
	(fold_unary <'~', '!', '-'>): Don't make_abs.
	(fold_binary): Simplify result section logic.  Return NULL section
	for logical ops.
	(fold_binary <SEGMENT_START>): Use new_rel_from_abs to set value to
	a consistent result.
	(fold_name <SIZEOF_HEADERS>): Return new_number, not new_abs.
	(fold_name <DEFINED, SIZEOF, ALIGNOF, LENGTH, CONSTANT>): Likewise.
	(fold_name <NAME>): No need to handle absolute symbols differently
	from relative ones.
	(fold_name <ORIGIN>): Don't return valid result when
	lang_first_phase_enum.  Return new_rel_from_abs, not new_abs.
	(exp_fold_tree_1 <etree_value>): Return new_number, not new_rel.
	(exp_fold_tree_1): Ajust for NULL expld.result.section.  When assigning
	a plain number to dot, assume the value is relative to expld.section.
	Make terms not in an output section, absolute.
	* ldlang.c (print_assignment): Fix style nit.
	(lang_size_sections_1): Cope with NULL expld.result.section.
	(lang_do_assignments_1): Likewise.
ld/testsuite/
	* ld-scripts/memory.t: Remove ORIGIN fudge.
@
text
@d874 2
a875 1
   function for each node.  */
d877 1
a877 1
static void
d891 3
a893 2
	  lang_for_each_statement_worker
	    (func, s->output_section_statement.children.head);
d3893 1
d3913 4
a3916 1
  exp_fold_tree (tree, output_section->bfd_section, &print_dot);
d4713 3
@


1.337
log
@	PR ld/11887
	* ldlang.c (lang_add_vers_depend): Don't leave version_needed
	uninitialised.
@
text
@d3919 1
a3919 1
	  if (expld.result.section)
d3936 1
a3936 1
	      if (expld.result.section)
d4721 5
a4725 1
		  dot = expld.result.value + expld.result.section->vma;
d5404 5
a5408 2
	    s->data_statement.value = (expld.result.value
				       + expld.result.section->vma);
@


1.336
log
@	* ldlang.c (lang_check_section_addresses): Catch overlap for
	sections that wrap around the address space.
@
text
@d1219 1
a1219 1
  
d4021 1
a4021 1
  
d6665 1
a6665 1
  
d6821 1
a6821 1
  
d7614 1
@


1.335
log
@bfd/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * aoutx.h (aout_link_input_bfd): Remove unused variable sym_count.
        * elf-eh-frame.c (_bfd_elf_eh_frame_section_offset): Remove unused
        variables htab and hdr_info and mark info parameter as unused.
        * elf.c (prep_headers): Remove unused variable i_phdrp.
        (_bfd_elf_write_object_contents): Remove unused variable i_ehdrp.
        * elf32-i386.c (elf_i386_relocate_section): Mark variabled warned
        as unused.
        * peXXigen.c (pe_print_reloc): Remove unused variable datasize.
        * verilog.c (verilog_write_section): Remove unused variable
        address.

binutils/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * dwarf.c (process_debug_info): Remove unused variable
        cu_abbrev_offset_ptr.
        (display_debug_lines_decoded): Remove unused variable prev_line.
        * elfedit.c (process_archive): Remove unused variable
        file_name_size.
        * ieee.c (ieee_start_compilation_unit): Remove unused variable
        nindx.
        (ieee_set_type): Remove unused variables info, targetindx and
        baseindx.
        * objdump.c (disassmble_byte): Remove unused variable done_dot.
        * rddbg.c (read_section_stabs_debugging_info): Remove unused
        variable other.
        * readelf.c (dump_section_as_strings): Remove unused variable
        addr.
        (process_archive): Remove unused variable file_name_size.
        * stabs.c (parse_stab_string): Mark desc parameter as unused.
        Remove unused variable lineno.
        (parse_stab_struct_type): Remove unused variable orig.
        (stab_demangle_type): Remove unused variables constp, volatilep
        and hold.

gas/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * as.c (create_obj_attrs_section): Remove unused variable addr.
        * listing.c (listing_listing): Remove unused variable message.
        * read.c: Remove unnecessary register type qualifiers.
        (s_mri): Only define/use old_flag variable if MRI_MODE_CHANGE is
        defined.

ld/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * ldlang.c (wild_sort): Remove unused variable section_name.

opcodes/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * i386-dis.c (print_insn): Remove unused variable op.
        (OP_sI): Remove unused variable mask.
@
text
@d4564 1
a4564 1
  asection *s, *os;
d4569 2
a4570 2
  bfd_vma os_start;
  bfd_vma os_end;
d4603 1
a4603 1
  s_start = bfd_section_lma (link_info.output_bfd, s);
d4610 3
a4612 3
      os = s;
      os_start = s_start;
      os_end = s_end;
d4614 1
a4614 1
      s_start = bfd_section_lma (link_info.output_bfd, s);
d4617 7
a4623 2
      /* Look for an overlap.  */
      if (s_end >= os_start && s_start <= os_end)
d4625 1
a4625 1
	       s->name, s_start, s_end, os->name, os_start, os_end);
@


1.334
log
@	* ldlang.c (lang_size_sections_1): Remove "s" param.  Set "s" from
	*prev instead.  Update all callers.
@
text
@a2327 1
  const char *section_name;
a2333 1
  section_name = bfd_get_section_name (file->the_bfd, section);
@


1.333
log
@	* ldlang.c (lang_insert_orphan): Place loadable orphans in the same
	region and phdrs as their placement section.

	testsuite/
	* ld-elf/orphan-region.d, ld-elf/orphan-region.ld,
	ld-elf/orphan-region.s: New files.
@
text
@d4683 1
a4683 1
  (lang_statement_union_type *s,
a4684 1
   lang_statement_union_type **prev,
d4690 2
d4693 1
a4693 1
  for (; s != NULL; s = s->header.next)
d4841 1
a4841 1
	    lang_size_sections_1 (os->children.head, os, &os->children.head,
d4997 1
a4997 1
	  dot = lang_size_sections_1 (constructor_list.head,
a4998 1
				      &s->wild_statement.children.head,
d5055 1
a5055 1
	  dot = lang_size_sections_1 (s->wild_statement.children.head,
a5056 1
				      &s->wild_statement.children.head,
d5073 1
a5073 1
	    i = (*prev)->input_section.section;
d5186 1
a5186 1
	  dot = lang_size_sections_1 (s->group_statement.children.head,
a5187 1
				      &s->group_statement.children.head,
d5253 2
a5254 2
  lang_size_sections_1 (statement_list.head, abs_output_section,
			&statement_list.head, 0, 0, relax, check_regions);
@


1.332
log
@bfd/
	PR ld/11304
	* elf.c (_bfd_elf_init_private_section_data): Rename need_group
	to final_link and invert.  For final link allow some flags to
	differ.  Don't specially allow flags to be all zero.
ld/
	* ldlang.c (init_os): Remove isec param.  Don't check for
	bfd_section already set or call bfd_init_private_section_data
	here.
	(exp_init_os): Update init_os call.
	(lang_add_section): Tidy.  Really don't set SEC_LINK_ONCE
	flags.  Call bfd_init_private_section_data here.
	(map_input_to_output_sections): Tidy.  Update init_os calls.
	Use os->sectype to select sec flags for lang_data_statement.
@
text
@d1764 14
a1777 1
  lang_leave_output_section_statement (0, "*default*", NULL, NULL);
@


1.331
log
@	PR ld/11304
	* ldlang.c: Revert last patch.
@
text
@d2051 1
a2051 2
init_os (lang_output_section_statement_type *s, asection *isec,
	 flagword flags)
a2052 3
  if (s->bfd_section != NULL)
    return;

a2087 5

  if (isec)
    bfd_init_private_section_data (isec->owner, isec,
				   link_info.output_bfd, s->bfd_section,
				   &link_info);
d2133 1
a2133 1
	      init_os (os, NULL, 0);
d2177 1
d2203 2
a2204 4
  if (section->output_section == NULL)
    {
      bfd_boolean first;
      lang_input_section_type *new_section;
d2206 12
a2217 7
      /* We don't copy the SEC_NEVER_LOAD flag from an input section
	 to an output section, because we want to be able to include a
	 SEC_NEVER_LOAD section in the middle of an otherwise loaded
	 section (I don't know why we want to do this, but we do).
	 build_link_order in ldwrite.c handles this case by turning
	 the embedded SEC_NEVER_LOAD section into a fill.  */
      flags &= ~ SEC_NEVER_LOAD;
d2219 2
a2220 13
      switch (output->sectype)
	{
	case normal_section:
	case overlay_section:
	  break;
	case noalloc_section:
	  flags &= ~SEC_ALLOC;
	  break;
	case noload_section:
	  flags &= ~SEC_LOAD;
	  flags |= SEC_NEVER_LOAD;
	  break;
	}
d2222 13
a2234 18
      if (output->bfd_section == NULL)
	init_os (output, section, flags);

      first = ! output->bfd_section->linker_has_input;
      output->bfd_section->linker_has_input = 1;

      if (!link_info.relocatable
	  && !stripped_excluded_sections)
	{
	  asection *s = output->bfd_section->map_tail.s;
	  output->bfd_section->map_tail.s = section;
	  section->map_head.s = NULL;
	  section->map_tail.s = s;
	  if (s != NULL)
	    s->map_head.s = section;
	  else
	    output->bfd_section->map_head.s = section;
	}
d2236 2
a2237 2
      /* Add a section reference to the list.  */
      new_section = new_stat (lang_input_section, ptr);
d2239 3
a2241 2
      new_section->section = section;
      section->output_section = output->bfd_section;
d2243 4
a2246 14
      /* If final link, don't copy the SEC_LINK_ONCE flags, they've
	 already been processed.  One reason to do this is that on pe
	 format targets, .text$foo sections go into .text and it's odd
	 to see .text with SEC_LINK_ONCE set.  */

      if (! link_info.relocatable)
	flags &= ~ (SEC_LINK_ONCE | SEC_LINK_DUPLICATES);

      /* If this is not the first input section, and the SEC_READONLY
	 flag is not currently set, then don't set it just because the
	 input section has it set.  */

      if (! first && (output->bfd_section->flags & SEC_READONLY) == 0)
	flags &= ~ SEC_READONLY;
d2249 4
a2252 5
      if (! first
	  && ((output->bfd_section->flags & (SEC_MERGE | SEC_STRINGS))
	      != (flags & (SEC_MERGE | SEC_STRINGS))
	      || ((flags & SEC_MERGE)
		  && output->bfd_section->entsize != section->entsize)))
d2257 16
d2274 9
a2282 1
      output->bfd_section->flags |= flags;
d2284 1
a2284 2
      if (flags & SEC_MERGE)
	output->bfd_section->entsize = section->entsize;
d2286 11
a2296 19
      /* If SEC_READONLY is not set in the input section, then clear
	 it from the output section.  */
      if ((section->flags & SEC_READONLY) == 0)
	output->bfd_section->flags &= ~SEC_READONLY;

      /* Copy over SEC_SMALL_DATA.  */
      if (section->flags & SEC_SMALL_DATA)
	output->bfd_section->flags |= SEC_SMALL_DATA;

      if (section->alignment_power > output->bfd_section->alignment_power)
	output->bfd_section->alignment_power = section->alignment_power;

      if (bfd_get_arch (section->owner) == bfd_arch_tic54x
	  && (section->flags & SEC_TIC54X_BLOCK) != 0)
	{
	  output->bfd_section->flags |= SEC_TIC54X_BLOCK;
	  /* FIXME: This value should really be obtained from the bfd...  */
	  output->block_value = 128;
	}
d2298 4
a3420 2
  flagword flags;

d3423 3
d3437 2
a3438 1
	  if (s->output_section_statement.constraint)
d3440 2
a3441 2
	      if (s->output_section_statement.constraint != ONLY_IF_RW
		  && s->output_section_statement.constraint != ONLY_IF_RO)
d3443 3
a3445 7
	      s->output_section_statement.all_input_readonly = TRUE;
	      check_input_sections (s->output_section_statement.children.head,
				    &s->output_section_statement);
	      if ((s->output_section_statement.all_input_readonly
		   && s->output_section_statement.constraint == ONLY_IF_RW)
		  || (!s->output_section_statement.all_input_readonly
		      && s->output_section_statement.constraint == ONLY_IF_RO))
d3447 1
a3447 1
		  s->output_section_statement.constraint = -1;
d3451 1
a3451 2

	  map_input_to_output_sections (s->output_section_statement.children.head,
d3453 1
a3453 1
					&s->output_section_statement);
d3469 15
a3483 5
	  flags = SEC_HAS_CONTENTS;
	  /* The output section gets contents, and then we inspect for
	     any flags set in the input script which override any ALLOC.  */
	  if (!(os->flags & SEC_NEVER_LOAD))
	    flags |= SEC_ALLOC | SEC_LOAD;
d3485 1
a3485 1
	    init_os (os, NULL, flags);
d3497 1
a3497 1
	    init_os (os, NULL, 0);
d3501 1
a3501 1
	    init_os (os, NULL, 0);
d3520 12
a3531 7
	      lang_output_section_statement_type *aos
		= (lang_output_section_statement_lookup
		   (s->address_statement.section_name, 0, TRUE));

	      if (aos->bfd_section == NULL)
		init_os (aos, NULL, 0);
	      aos->addr_tree = s->address_statement.address;
@


1.330
log
@	PR ld/11304
	* ldlang.c (exp_init_os): Delete forward declaration.
	(init_os): Don't check for bfd_section already created and don't
	init addr_tree and load_base expressions here.
	(map_input_to_output_sections): Only map input to output sections
	and set constraints here, and as an exception, create output
	sections which have their address set.  Move all the other code to..
	(create_other_output_sections): ..here.  New function.  Handle init
	of addr_tree and load_base here too.
	(lang_process): Call create_other_output_sections.
@
text
@d71 1
d2051 2
a2052 1
init_os (lang_output_section_statement_type *s, asection *isec, flagword flags)
d2054 3
d2081 8
d3433 2
a3436 2
      lang_output_section_statement_type *tos;

d3448 1
a3448 2
	  tos = &s->output_section_statement;
	  if (tos->constraint != 0)
d3450 2
a3451 2
	      if (tos->constraint != ONLY_IF_RW
		  && tos->constraint != ONLY_IF_RO)
d3453 7
a3459 3
	      tos->all_input_readonly = TRUE;
	      check_input_sections (tos->children.head, tos);
	      if (tos->all_input_readonly != (tos->constraint == ONLY_IF_RO))
d3461 1
a3461 1
		  tos->constraint = -1;
d3465 2
a3466 1
	  map_input_to_output_sections (tos->children.head,
d3468 3
a3470 1
					tos);
a3479 84
	case lang_address_statement_enum:
	  /* Mark the specified section with the supplied address.
	     If this section was actually a segment marker, then the
	     directive is ignored if the linker script explicitly
	     processed the segment marker.  Originally, the linker
	     treated segment directives (like -Ttext on the
	     command-line) as section directives.  We honor the
	     section directive semantics for backwards compatibilty;
	     linker scripts that do not specifically check for
	     SEGMENT_START automatically get the old semantics.  */
	  if (!s->address_statement.segment
	      || !s->address_statement.segment->used)
	    {
	      const char *name = s->address_statement.section_name;

	      /* Create the output section statement here rather than
		 in create_other_output_sections so that orphans with
		 a set address will be placed after other script
		 sections.  If we let the orphan placement code place
		 them in amongst other sections then the address will
		 affect following script sections, which is likely to
		 surprise naive users.  */
	      tos = lang_output_section_statement_lookup (name, 0, TRUE);
	      tos->addr_tree = s->address_statement.address;
	    }
	  break;
	case lang_output_statement_enum:
	case lang_data_statement_enum:
	case lang_input_section_enum:
	case lang_fill_statement_enum:
	case lang_object_symbols_statement_enum:
	case lang_reloc_statement_enum:
	case lang_padding_statement_enum:
	case lang_input_statement_enum:
	case lang_assignment_statement_enum:
	case lang_insert_statement_enum:
	  break;
	}
    }
}

/* Create any other output sections, such as needed for data statements
   or those referenced in expressions.  */

static void
create_other_output_sections
  (lang_statement_union_type *s,
   lang_output_section_statement_type *os)
{
  lang_output_section_statement_type *tos;
  flagword flags;

  for (; s != NULL; s = s->header.next)
    {
      switch (s->header.type)
	{
	case lang_wild_statement_enum:
	  break;
	case lang_constructors_statement_enum:
	  create_other_output_sections (constructor_list.head, os);
	  break;
	case lang_output_section_statement_enum:
	  tos = &s->output_section_statement;
	  if (tos->constraint != 0
	      && tos->constraint != ONLY_IF_RW
	      && tos->constraint != ONLY_IF_RO)
	    break;
	  create_other_output_sections (tos->children.head, tos);
	  if (tos->bfd_section != NULL)
	    {
	      /* If there is a base address, make sure that any sections
		 it might mention are initialized.  */
	      if (tos->addr_tree != NULL)
		exp_init_os (tos->addr_tree);
	      if (tos->load_base != NULL)
		exp_init_os (tos->load_base);
	    }
	  break;
	case lang_output_statement_enum:
	case lang_target_statement_enum:
	  break;
	case lang_group_statement_enum:
	  create_other_output_sections (s->group_statement.children.head, os);
	  break;
a3483 2
	  if (os->bfd_section == NULL)
	    init_os (os, NULL, 0);
d3489 4
a3492 1
	  os->bfd_section->flags |= flags;
d3513 9
d3525 7
a3531 5
	      const char *name = s->address_statement.section_name;

	      tos = lang_output_section_find (name);
	      if (tos->bfd_section == NULL)
		init_os (tos, NULL, 0);
a6349 4
  /* Create sections for data statements and those referenced in
     expressions but otherwise empty.  */
  create_other_output_sections (statement_list.head, NULL);

@


1.329
log
@bfd/
	* elf.c (_bfd_elf_fixup_group_sections): New function, split out from..
	(_bfd_elf_copy_private_header_data): ..here.
	* elflink.c (_bfd_elf_size_group_sections): New function.
	(bfd_elf_size_dynamic_sections): Call it.
	* elf-bfd.h (_bfd_elf_size_group_sections): Declare.
	(_bfd_elf_fixup_group_sections): Declare.
ld/
	* ldlang.c (unique_section_p): Add os param.  Allow group
	sections to match /DISCARD/.  Update all callers.
	* emultempl/genelf.em (gld${EMULATION_NAME}_before_allocation): New.
	(LDEMUL_BEFORE_ALLOCATION): Define.
ld/testsuite/
	* ld-elf/group.ld: Discard .dropme sections.
	* ld-elf/group10.d, * ld-elf/group10.s: New test.
@
text
@a70 1
static void exp_init_os (etree_type *);
d2050 1
a2050 2
init_os (lang_output_section_statement_type *s, asection *isec,
	 flagword flags)
a2051 3
  if (s->bfd_section != NULL)
    return;

a2075 8
  /* If there is a base address, make sure that any sections it might
     mention are initialized.  */
  if (s->addr_tree != NULL)
    exp_init_os (s->addr_tree);

  if (s->load_base != NULL)
    exp_init_os (s->load_base);

a3419 2
  flagword flags;

d3422 2
d3435 2
a3436 1
	  if (s->output_section_statement.constraint)
d3438 2
a3439 2
	      if (s->output_section_statement.constraint != ONLY_IF_RW
		  && s->output_section_statement.constraint != ONLY_IF_RO)
d3441 3
a3443 7
	      s->output_section_statement.all_input_readonly = TRUE;
	      check_input_sections (s->output_section_statement.children.head,
				    &s->output_section_statement);
	      if ((s->output_section_statement.all_input_readonly
		   && s->output_section_statement.constraint == ONLY_IF_RW)
		  || (!s->output_section_statement.all_input_readonly
		      && s->output_section_statement.constraint == ONLY_IF_RO))
d3445 1
a3445 1
		  s->output_section_statement.constraint = -1;
d3449 1
a3449 2

	  map_input_to_output_sections (s->output_section_statement.children.head,
d3451 1
a3451 3
					&s->output_section_statement);
	  break;
	case lang_output_statement_enum:
d3461 84
d3549 2
d3556 1
a3556 4
	  if (os->bfd_section == NULL)
	    init_os (os, NULL, flags);
	  else
	    os->bfd_section->flags |= flags;
a3576 9
	  /* Mark the specified section with the supplied address.
	     If this section was actually a segment marker, then the
	     directive is ignored if the linker script explicitly
	     processed the segment marker.  Originally, the linker
	     treated segment directives (like -Ttext on the
	     command-line) as section directives.  We honor the
	     section directive semantics for backwards compatibilty;
	     linker scripts that do not specifically check for
	     SEGMENT_START automatically get the old semantics.  */
d3580 5
a3584 7
	      lang_output_section_statement_type *aos
		= (lang_output_section_statement_lookup
		   (s->address_statement.section_name, 0, TRUE));

	      if (aos->bfd_section == NULL)
		init_os (aos, NULL, 0);
	      aos->addr_tree = s->address_statement.address;
d6403 4
@


1.328
log
@        PR 4437
        * ldfile.c: (ldfile_open_file): Do not stop link upon encountering
        a missing file or library.  Instead mark the entry as missing and
        set the global flag to indicate that missing files were
        encountered.
        * ldlang.c (missing_files): New exported variable.
        (load_symbols): Skip loading if the file is missing.
        (open_input_bfds): Terminate link if any input files were
        missing.
        * ldlang.h (struct lang_input_statement_struct): Add missing_file
        field.
        Add export of missing_file variable.
@
text
@d198 2
a199 1
unique_section_p (const asection *sec)
d207 2
a208 1
    return TRUE;
d450 1
a450 1
			      void *output ATTRIBUTE_UNUSED)
d454 1
d456 3
a458 1
  if (unique_section_p (section))
d2423 3
d2428 1
a2428 1
  if (unique_section_p (section))
d2439 1
a2439 2
    lang_add_section (&ptr->children, section,
		      (lang_output_section_statement_type *) output);
d2446 1
a2446 2
      lang_add_section (&list, section,
			(lang_output_section_statement_type *) output);
d2473 1
a2473 1
			void *data)
d2475 4
d2480 1
a2480 1
  if (unique_section_p (section))
d2484 1
a2484 1
    ((lang_output_section_statement_type *) data)->all_input_readonly = FALSE;
d5861 2
a5862 1
		  if (config.unique_orphan_sections || unique_section_p (s))
@


1.327
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
d67 2
d106 1
a106 2
static struct unique_sections *unique_section_list;
static bfd_boolean ldlang_sysrooted_script = FALSE;
d1064 2
d2589 4
d3174 4
@


1.326
log
@        PR ld/10956
        * ld.h (struct args_type): Rename 'relax' field to
        'disable_target_specific_optimizations' and turn it into a
        tri-state variable.
        (RELAXATION_DISABLED_BY_DEFAULT): New macro.
        (RELAXATION_DISABLED_BY_USER): New macro.
        (RELAXATION_ENABLED): New macro.
        (DISABLE_RELAXATION): New macro.
        (ENABLE_RELAXATION): New macro.
        * lexsup (enum option_values): Add OPTION_NO_RELAX.
        (struct ld_options): Add --no-relax.
        (parse_args): Handle OPTION_NO_RELAX.  Use DISABLE_RELAXATION and
        ENABLE_RELAXATION macros.
        * ldlang.c (lang_relax_sections): Use RELAXATION_ENABLED macro.
        (lang_process): Likewise.
        * ldmain.c (main): Initialise
        disable_target_specific_optimizations field.
        (multiple_definition): Use RELAXATION_ENABLED macro.
        * ld.texinfo: Document new command line option.
        * emultempl/alphaelf.em: Remove --no-relax option.
        (before_allocation): Test RELAXATION_DISABLED_BY_USER macro.
        Use ENABLE_RELAXATION macro.
        * emultempl/avrelf.em: (after_allocation): Test RELAXATION_ENABLED
        macro.
        * emultempl/cr16elf.em: Remove --no-relax option.
        (before_allocation): Test RELAXATION_DISABLED_BY_USER macro.
        Use ENABLE_RELAXATION macro.
        * emultempl/crxelf.em: Remove --no-relax option.
        (before_allocation): Test RELAXATION_DISABLED_BY_USER macro.
        Use ENABLE_RELAXATION macro.
        * emultempl/mmix-elfnmmo.em: (before_allocation): Use
        ENABLE_RELAXATION macro.
        * emultempl/needrelax.em: (before_allocation): Use
        ENABLE_RELAXATION macro.
        * emultempl/ppc32elf.em: (before_allocation): Test
        RELAXATION_DISABLED_BY_DEFAULT macro. Use
        ENABLE_RELAXATION macro.
        * emultempl/sh64elf.em: (before_allocation): Test
        RELAXATION_ENABLED macro. Use DISABLE_RELAXATION macro.
        * emultempl/xtensaelf.em: Remove --no-relax option.
        (before_allocation): Test RELAXATION_ENABLED macro.
        Use ENABLE_RELAXATION macro.
@
text
@d308 1
a308 1
section_iterator_callback (bfd *bfd ATTRIBUTE_UNUSED, asection *s, void *data)
a2206 3
      flagword flags;

      flags = section->flags;
a2213 1

d4617 1
a4617 1
		 bfd_vma base)
d4622 1
a4622 1
	  || base == 0))
@


1.325
log
@        * lexsup.c: Rename --add-needed to --copy-dt-needed-entries.
        * ldlang.h (struct lang_input_statement_struct): Rename add_needed
        to add_DT_NEEDED_for_dynamic.  Rename as_needed to
        add_DT_NEEDED_for_regular.
        * ldlang.c: Likewise.
        * ldlang.h: Likewise.
        * ldlang.c: Use the new variable names.
        * ldgram.y: Likewise.
        * emultempl/elf32.em: Likewise.
        * ld.texinfo: Document the renamed option.  Also mention its
        affect on the resolution of dynamic symbols.
        * NEWS: Mention the changed option name.
@
text
@d6215 1
a6215 1
  if (command_line.relax)
d6367 1
a6367 1
  lang_size_sections (NULL, !command_line.relax);
@


1.324
log
@	* ldlang.c (load_symbols): Set whole_archive from entry when
	parsing a linker script.
@
text
@d1059 2
a1060 2
  p->add_needed = add_needed;
  p->as_needed = as_needed;
d2595 3
a2597 1
      bfd_boolean save_as_needed, save_add_needed, save_whole_archive;
d2628 4
a2631 4
      save_as_needed = as_needed;
      as_needed = entry->as_needed;
      save_add_needed = add_needed;
      add_needed = entry->add_needed;
d2644 2
a2645 2
      as_needed = save_as_needed;
      add_needed = save_add_needed;
@


1.323
log
@	PR ld/10749
	* ldlang.c (lang_size_sections_1): Zero section vmas only for COFF.
@
text
@d2595 1
a2595 1
      bfd_boolean save_as_needed, save_add_needed;
d2630 2
d2644 1
@


1.322
log
@	PR ld/10744
	* ldlang.c (lang_new_phdr): Allow FILEHDR/PHDRS on more than the
	first PT_LOAD header.
	* ld.texinfo: Update.
@
text
@d4668 7
a4674 1
	    if (os->addr_tree == NULL && link_info.relocatable)
@


1.321
log
@	ld/
	* ldlang.c (lang_new_phdr): Check PHDRS and FILEHDR in loadable
	segments do not appear after a different loadable segment.
	* ld.texinfo (PHDRS): Document order of processing segments.
	Document where PHDRS and FILEHDR may appear.

	ld/testsuite/
	* ld-scripts/phdrs3.d: New.
	* ld-scripts/phdrs3.t: New.
	* ld-scripts/phdrs3.exp: New.
@
text
@d6782 3
a6784 1
    if (hdrs && (*pp)->type == 1)
d6786 1
a6786 1
	einfo (_("%X%P:%S: PHDRS and FILEHDR are only permitted for the first PT_LOAD segment\n"));
@


1.320
log
@	* ldlang.c (lang_size_sections_1): Allow scripts to specify a
	non-zero vma even when relocatable.
@
text
@d6768 1
d6778 2
d6782 6
a6787 1
    ;
@


1.319
log
@* ldlang.c (lang_size_sections_1): Always force output vma to zero for
relocatable sections.
(lang_size_sections_1): Revert previous COFF-only accommodation for relocatable
sections.
@
text
@d4668 1
a4668 1
	    if (link_info.relocatable)
@


1.318
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        * as.c (main): Call dwarf2_init.
        * config/obj-elf.c (struct group_list): New field.
        (build_group_lists): Use hash lookup.
        (free_section_idx): New function.
        (elf_frob_file): Adjust.
        * dwarf2dbg.c (all_segs_hash, last_seg_ptr): New variables.
        (get_line_subseg): Adjust.
        (dwarf2_init): New function.
        * dwarf2dbg.h (dwarf2_init): New declaration.
@
text
@d4668 2
d4794 1
a4794 6
		/* PR 6945: Do not update the vma's of output sections
		   when performing a relocatable link on COFF objects.  */
		if (! link_info.relocatable
		    || (bfd_get_flavour (link_info.output_bfd)
			!= bfd_target_coff_flavour))
		  bfd_set_section_vma (0, os->bfd_section, newdot);
@


1.317
log
@	PR ld/10569
	* ldexp.c (fold_name <MAXPAGESIZE>): Return config.maxpagesize.
	(fold_name <COMMONPAGESIZE>): Similarly.
	* ldlang.c (output_target): Make global.
	* ldlang.h (output_target): Declare.
	* ldmain.c (main): Set config.maxpagesize from bfd_emul_get_maxpagesize.
	Similarly for config.commonpagesize.
	* ldemul.c (set_output_arch_default): Call bfd_emul_set_maxpagesize
	and bfd_emul_set_commonpagesize.
	* emultempl/elf32.em (gld${EMULATION_NAME}_handle_option): Don't call
	bfd_emul_set_maxpagesize or bfd_emul_set_commonpagesize here.
@
text
@d310 1
a310 1
  section_iterator_callback_data *d = data;
d455 1
a455 1
  node = xmalloc (sizeof (lang_section_bst_type));
d816 3
a818 1
	      walk_wild_section (s, member->usrdata, callback, data);
d1100 2
a1101 1
      entry = bfd_hash_allocate (table, sizeof (*ret));
d1302 1
a1302 1
  n = stat_alloc (sizeof (lang_memory_region_name));
d1723 2
a1724 2
  os = lang_enter_output_section_statement (secname, address, 0, NULL, NULL,
					    NULL, constraint);
d2018 2
a2019 1
      ud = get_userdata (hash_entry->u.def.section);
d2025 2
a2026 1
	  ud = get_userdata (hash_entry->u.def.section);
d2031 1
a2031 1
      def = obstack_alloc (&map_obstack, sizeof *def);
d2147 1
a2147 1
  lang_input_statement_type *entry = data;
d2536 1
a2536 1
      entry = xmalloc (sizeof (*entry));
d2538 1
a2538 1
      entry->name = xmalloc (end - p + 1);
d2759 1
a2759 1
  const char *sought = data;
d2806 2
a2807 2
  copy1 = xmalloc (strlen (first) + 1);
  copy2 = xmalloc (strlen (second) + 1);
d2845 1
a2845 1
  const bfd_target *original = data;
d3940 1
a3940 1
  asection *sec = ptr;
d3978 2
a3979 1
  struct fat_user_section_struct *ud = get_userdata (sec);
d3990 2
a3991 2
  entries = obstack_alloc (&map_obstack,
                           ud->map_symbol_def_count * sizeof (*entries));
d4428 2
a4429 1
      pad = stat_alloc (sizeof (lang_padding_statement_type));
d4545 1
a4545 1
  sections = xmalloc (amt);
d5475 1
a5475 1
      buf = xmalloc (10 + strlen (secname));
d6772 1
a6772 1
  n = stat_alloc (sizeof (struct lang_phdr));
d6799 1
a6799 1
  secs = xmalloc (alc * sizeof (asection *));
d6866 2
a6867 1
		      secs = xrealloc (secs, alc * sizeof (asection *));
d6921 1
a6921 1
  n = xmalloc (sizeof *n);
d6983 1
a6983 1
  n = xmalloc (sizeof *n);
d7019 1
a7019 1
  clean = xmalloc (strlen (name) + 1);
d7026 1
a7026 1
  buf = xmalloc (strlen (clean) + sizeof "__load_start_");
d7032 1
a7032 1
  buf = xmalloc (strlen (clean) + sizeof "__load_stop_");
d7098 1
a7098 1
	  nc = xmalloc (sizeof *nc);
d7159 2
a7160 1
	      expr = htab_find (head->htab, &e);
d7172 2
a7173 1
	      expr = htab_find (head->htab, &e);
d7185 2
a7186 1
	      expr = htab_find (head->htab, &e);
d7240 1
a7240 1
  char *s, *symbol = xmalloc (strlen (pattern) + 1);
d7327 1
a7327 1
  ret = xcalloc (1, sizeof *ret);
d7342 2
a7343 1
  const struct bfd_elf_version_expr *e = p;
d7351 4
a7354 2
  const struct bfd_elf_version_expr *e1 = p1;
  const struct bfd_elf_version_expr *e2 = p2;
d7389 1
a7389 1
	      void **loc = htab_find_slot (head->htab, e, INSERT);
d7395 1
a7395 1
		  e1 = *loc;
d7480 2
a7481 1
	      e2 = htab_find (t->locals.htab, e1);
d7507 2
a7508 1
	      e2 = htab_find (t->globals.htab, e1);
d7550 1
a7550 1
  ret = xmalloc (sizeof *ret);
d7582 1
a7582 1
      contents = xmalloc (len);
d7613 1
a7613 1
  ent = xmalloc (sizeof *ent);
d7636 1
a7636 1
      d = xcalloc (1, sizeof *d);
@


1.317.2.1
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.
@
text
@d310 1
a310 1
  section_iterator_callback_data *d = (section_iterator_callback_data *) data;
d455 1
a455 1
  node = (lang_section_bst_type *) xmalloc (sizeof (lang_section_bst_type));
d816 1
a816 3
	      walk_wild_section (s,
                                 (lang_input_statement_type *) member->usrdata,
                                 callback, data);
d1098 1
a1098 2
      entry = (struct bfd_hash_entry *) bfd_hash_allocate (table,
                                                           sizeof (*ret));
d1299 1
a1299 1
  n = (lang_memory_region_name *) stat_alloc (sizeof (lang_memory_region_name));
d1720 2
a1721 2
  os = lang_enter_output_section_statement (secname, address, normal_section,
                                            NULL, NULL, NULL, constraint);
d2015 1
a2015 2
      ud = (struct fat_user_section_struct *)
          get_userdata (hash_entry->u.def.section);
d2021 1
a2021 2
	  ud = (struct fat_user_section_struct *)
              get_userdata (hash_entry->u.def.section);
d2026 1
a2026 1
      def = (struct map_symbol_def *) obstack_alloc (&map_obstack, sizeof *def);
d2142 1
a2142 1
  lang_input_statement_type *entry = (lang_input_statement_type *) data;
d2531 1
a2531 1
      entry = (struct excluded_lib *) xmalloc (sizeof (*entry));
d2533 1
a2533 1
      entry->name = (char *) xmalloc (end - p + 1);
d2754 1
a2754 1
  const char *sought = (const char *) data;
d2801 2
a2802 2
  copy1 = (char *) xmalloc (strlen (first) + 1);
  copy2 = (char *) xmalloc (strlen (second) + 1);
d2840 1
a2840 1
  const bfd_target *original = (const bfd_target *) data;
d3935 1
a3935 1
  asection *sec = (asection *) ptr;
d3973 1
a3973 2
  struct fat_user_section_struct *ud =
      (struct fat_user_section_struct *) get_userdata (sec);
d3984 2
a3985 2
  entries = (struct bfd_link_hash_entry **)
      obstack_alloc (&map_obstack, ud->map_symbol_def_count * sizeof (*entries));
d4422 1
a4422 2
      pad = (lang_statement_union_type *)
          stat_alloc (sizeof (lang_padding_statement_type));
d4538 1
a4538 1
  sections = (asection **) xmalloc (amt);
d5468 1
a5468 1
      buf = (char *) xmalloc (10 + strlen (secname));
d6765 1
a6765 1
  n = (struct lang_phdr *) stat_alloc (sizeof (struct lang_phdr));
d6792 1
a6792 1
  secs = (asection **) xmalloc (alc * sizeof (asection *));
d6859 1
a6859 2
		      secs = (asection **) xrealloc (secs,
                                                     alc * sizeof (asection *));
d6913 1
a6913 1
  n = (struct lang_nocrossrefs *) xmalloc (sizeof *n);
d6975 1
a6975 1
  n = (struct overlay_list *) xmalloc (sizeof *n);
d7011 1
a7011 1
  clean = (char *) xmalloc (strlen (name) + 1);
d7018 1
a7018 1
  buf = (char *) xmalloc (strlen (clean) + sizeof "__load_start_");
d7024 1
a7024 1
  buf = (char *) xmalloc (strlen (clean) + sizeof "__load_stop_");
d7090 1
a7090 1
	  nc = (lang_nocrossref_type *) xmalloc (sizeof *nc);
d7151 1
a7151 2
	      expr = (struct bfd_elf_version_expr *)
                  htab_find ((htab_t) head->htab, &e);
d7163 1
a7163 2
	      expr = (struct bfd_elf_version_expr *)
                  htab_find ((htab_t) head->htab, &e);
d7175 1
a7175 2
	      expr = (struct bfd_elf_version_expr *)
                  htab_find ((htab_t) head->htab, &e);
d7229 1
a7229 1
  char *s, *symbol = (char *) xmalloc (strlen (pattern) + 1);
d7316 1
a7316 1
  ret = (struct bfd_elf_version_tree *) xcalloc (1, sizeof *ret);
d7331 1
a7331 2
  const struct bfd_elf_version_expr *e =
      (const struct bfd_elf_version_expr *) p;
d7339 2
a7340 4
  const struct bfd_elf_version_expr *e1 =
      (const struct bfd_elf_version_expr *) p1;
  const struct bfd_elf_version_expr *e2 =
      (const struct bfd_elf_version_expr *) p2;
d7375 1
a7375 1
	      void **loc = htab_find_slot ((htab_t) head->htab, e, INSERT);
d7381 1
a7381 1
		  e1 = (struct bfd_elf_version_expr *) *loc;
d7466 1
a7466 2
	      e2 = (struct bfd_elf_version_expr *)
                  htab_find ((htab_t) t->locals.htab, e1);
d7492 1
a7492 2
	      e2 = (struct bfd_elf_version_expr *)
                  htab_find ((htab_t) t->globals.htab, e1);
d7534 1
a7534 1
  ret = (struct bfd_elf_version_deps *) xmalloc (sizeof *ret);
d7566 1
a7566 1
      contents = (char *) xmalloc (len);
d7597 1
a7597 1
  ent = (struct unique_sections *) xmalloc (sizeof *ent);
d7620 1
a7620 1
      d = (struct bfd_elf_dynamic_list *) xcalloc (1, sizeof *d);
@


1.317.2.2
log
@2009-09-29  Alan Modra  <amodra@@bigpond.net.au>

	* ldlang.c (lang_size_sections_1): Allow scripts to specify a
	non-zero vma even when relocatable.

2009-09-28  Alan Modra  <amodra@@bigpond.net.au>

	* scripttempl/elf32cr16.sc: Emit empty script for ld -r and ld -Ur.
	* scripttempl/elf32cr16c.sc: Likewise.
	* scripttempl/elf32crx.sc: Likewise.
	* scripttempl/tic54xcoff.sc: Likewise.
	* scripttempl/aix.sc: Delete ${RELOCATING-0}.
	* scripttempl/avr.sc: Likewise.
	* scripttempl/elf32msp430.sc: Likewise.
	* scripttempl/elf32msp430_3.sc: Likewise.
	* scripttempl/elf32sh-symbian.sc: Likewise.
	* scripttempl/elf_chaos.sc: Likewise.
	* scripttempl/elfi370.sc: Likewise.
	* scripttempl/nw.sc: Likewise.
	* scripttempl/psos.sc: Likewise.
	* scripttempl/armbpabi.sc: Delete ${RELOCATING-0} and ${CONSTRUCTING-0}.
	* scripttempl/elf.sc: Likewise.
	* scripttempl/elf64hppa.sc: Likewise.
	* scripttempl/elfd10v.sc: Likewise.
	* scripttempl/elfd30v.sc: Likewise.
	* scripttempl/elfm68hc11.sc: Likewise.
	* scripttempl/elfm68hc12.sc: Likewise.
	* scripttempl/elfmicroblaze.sc: Likewise.
	* scripttempl/elfxtensa.sc: Likewise.
	* scripttempl/iq2000.sc: Likewise.
	* scripttempl/mep.sc: Likewise.
	* scripttempl/xstormy16.sc: Likewise.

2009-09-27  Christopher Faylor  <me+cygwin@@cgf.cx>

	* ldlang.c (lang_size_sections_1): Always force output vma to zero for
	relocatable sections.
	(lang_size_sections_1): Revert previous COFF-only accommodation for
	relocatable sections.
@
text
@a4667 2
	    if (os->addr_tree == NULL && link_info.relocatable)
	      os->addr_tree = exp_intop (0);
d4792 6
a4797 1
		bfd_set_section_vma (0, os->bfd_section, newdot);
@


1.317.2.3
log
@	PR ld/10749
	* ldlang.c (lang_size_sections_1): Zero section vmas only for COFF.
	* scripttempl/elf32cr16.sc: Revert 2009-09-28 change.
	* scripttempl/elf32cr16c.sc: Likewise.
	* scripttempl/elf32crx.sc: Likewise.
	* scripttempl/tic54xcoff.sc: Likewise.
	* scripttempl/aix.sc: Likewise.
	* scripttempl/avr.sc: Likewise.
	* scripttempl/elf32msp430.sc: Likewise.
	* scripttempl/elf32msp430_3.sc: Likewise.
	* scripttempl/elf32sh-symbian.sc: Likewise.
	* scripttempl/elf_chaos.sc: Likewise.
	* scripttempl/elfi370.sc: Likewise.
	* scripttempl/nw.sc: Likewise.
	* scripttempl/psos.sc: Likewise.
	* scripttempl/armbpabi.sc: Likewise.
	* scripttempl/elf.sc: Likewise.
	* scripttempl/elf64hppa.sc: Likewise.
	* scripttempl/elfd10v.sc: Likewise.
	* scripttempl/elfd30v.sc: Likewise.
	* scripttempl/elfm68hc11.sc: Likewise.
	* scripttempl/elfm68hc12.sc: Likewise.
	* scripttempl/elfmicroblaze.sc: Likewise.
	* scripttempl/elfxtensa.sc: Likewise.
	* scripttempl/iq2000.sc: Likewise.
	* scripttempl/mep.sc: Likewise.
	* scripttempl/xstormy16.sc: Likewise.

2009-10-03  Alan Modra  <amodra@@bigpond.net.au>

	* emultempl/ppc32elf.em (emit_stub_syms): Init to -1.
	(ppc_after_open): Set emit_stubs_syms by default when shared.
	(OPTION_NO_STUBSYMS): Define.
	(PARSE_AND_LIST_LONGOPTS, PARSE_AND_LIST_OPTIONS,
	PARSE_AND_LIST_ARGS_CASES): Handle --no-emit-stub-syms.
	* emultempl/ppc64elf.em (emit_stub_syms): Init to -1.
	(gld${EMULATION_NAME}_finish): Set emit_stubs_syms by default.
	(OPTION_NO_STUBSYMS): Define.
	(PARSE_AND_LIST_LONGOPTS, PARSE_AND_LIST_OPTIONS,
	PARSE_AND_LIST_ARGS_CASES): Handle --no-emit-stub-syms.

2009-09-30  Matthias Klose  <doko@@ubuntu.com>

	PR ld/9863
	* emulparams/armelf_linux.sh (DATA_START_SYMBOLS): Use PROVIDE
	with __data_start.

2009-09-29  Joel Sherrill <joel.sherrill@@oarcorp.com>

	* emulparams/m68kelf.sh (NOP): Use 0x4e71 (nop) rather than 0x4e75
	(rts).

2009-09-29  Alan Modra  <amodra@@bigpond.net.au>

	* ldlang.c (lang_size_sections_1): Allow scripts to specify a
	non-zero vma even when relocatable.

2009-09-28  Alan Modra  <amodra@@bigpond.net.au>

	* scripttempl/elf32cr16.sc: Emit empty script for ld -r and ld -Ur.
	* scripttempl/elf32cr16c.sc: Likewise.
	* scripttempl/elf32crx.sc: Likewise.
	* scripttempl/tic54xcoff.sc: Likewise.
	* scripttempl/aix.sc: Delete ${RELOCATING-0}.
	* scripttempl/avr.sc: Likewise.
	* scripttempl/elf32msp430.sc: Likewise.
	* scripttempl/elf32msp430_3.sc: Likewise.
	* scripttempl/elf32sh-symbian.sc: Likewise.
	* scripttempl/elf_chaos.sc: Likewise.
	* scripttempl/elfi370.sc: Likewise.
	* scripttempl/nw.sc: Likewise.
	* scripttempl/psos.sc: Likewise.
	* scripttempl/armbpabi.sc: Delete ${RELOCATING-0} and ${CONSTRUCTING-0}.
	* scripttempl/elf.sc: Likewise.
	* scripttempl/elf64hppa.sc: Likewise.
	* scripttempl/elfd10v.sc: Likewise.
	* scripttempl/elfd30v.sc: Likewise.
	* scripttempl/elfm68hc11.sc: Likewise.
	* scripttempl/elfm68hc12.sc: Likewise.
	* scripttempl/elfmicroblaze.sc: Likewise.
	* scripttempl/elfxtensa.sc: Likewise.
	* scripttempl/iq2000.sc: Likewise.
	* scripttempl/mep.sc: Likewise.
	* scripttempl/xstormy16.sc: Likewise.
@
text
@d4668 1
a4668 7
	    /* FIXME: We shouldn't need to zero section vmas for ld -r
	       here, in lang_insert_orphan, or in the default linker scripts.
	       This is covering for coff backend linker bugs.  See PR6945.  */
	    if (os->addr_tree == NULL
		&& link_info.relocatable
		&& (bfd_get_flavour (link_info.output_bfd)
		    == bfd_target_coff_flavour))
@


1.317.2.4
log
@2009-10-14  Ryan Mansfield  <rmansfield@@qnx.com>

	* ldlang.c (load_symbols): Set whole_archive from entry when
	parsing a linker script.
@
text
@d2595 1
a2595 1
      bfd_boolean save_as_needed, save_add_needed, save_whole_archive;
a2629 2
      save_whole_archive = whole_archive;
      whole_archive = entry->whole_archive;
a2641 1
      whole_archive = save_whole_archive;
@


1.316
log
@        Updated sources to avoid using the identifier name "new", which is a
        keyword in c++.

        * bfd/aoutx.h (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol.
        * bfd/coffgen.c (coff_make_empty_symbol)
        (coff_bfd_make_debug_symbol): Rename variable new to new_symbol.
        * bfd/cpu-ia64-opc.c (ext_reg, ins_imms_scaled): Rename variable
        new to new_insn.
        * bfd/doc/chew.c (newentry, add_intrinsic): Rename variable new to
        new_d.
        * bfd/ecoff.c (_bfd_ecoff_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/elf32-m68k.c (elf_m68k_get_got_entry_type): Rename argument
        new to new_reloc.
        * bfd/hash.c (bfd_hash_lookup): Rename variable new to new_string.
        * bfd/ieee.c (ieee_make_empty_symbol): Rename variable new to
        new_symbol.
        * bfd/linker.c (bfd_new_link_order): Rename variable new to
        new_lo.
        * bfd/mach-o.c (bfd_mach_o_sizeof_headers): Rename variable new to
        symbol.
        * bfd/oasys.c (oasys_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/pdp11.c (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol_type.
        * bfd/plugin.c (bfd_plugin_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/rs6000-core.c (CoreHdr, VmInfo): Rename union member new to
        new_dump.
        (read_hdr, rs6000coff_core_p)
        (rs6000coff_core_file_matches_executable_p)
        (rs6000coff_core_file_failing_command)
        (rs6000coff_core_file_failing_signal): Updated function to use new
        union member name.
        * bfd/som.c (som_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/syms.c (_bfd_generic_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/tekhex.c (first_phase, tekhex_make_empty_symbol): Rename
        variable new to new_symbol.
        * binutils/nlmconv.c (main): Rename variable new to new_name.
        * gas/config/tc-arm.c (insert_reg_alias): Rename variable new to
        new_reg.
        * gas/config/tc-dlx.c (parse_operand): Rename variable new to
        new_pos.
        * gas/config/tc-ia64.c (ia64_gen_real_reloc_type): Rename variable
        new to newr.
        * gas/config/tc-mcore.c (parse_exp, parse_imm): Rename variable
        new to new_pointer.
        * gas/config/tc-microblaze.c (parse_exp, parse_imm, check_got):
        Change name from new to new_pointer.
        * gas/config/tc-or32.c (parse_operand): Rename variable new to
        new_pointer.
        * gas/config/tc-pdp11.c (md_assemble): Rename variable new to
        new_pointer.
        * gas/config/tc-pj.c (alias): Change argument new to new_name.
        * gas/config/tc-score.c (s3_build_score_ops_hsh): Rename variable
        new to new_opcode. (s3_build_dependency_insn_hsh) Rename variable
        new to new_i2n. (s3_convert): Rename variables old and new to
        r_old and r_new.
        * gas/config/tc-score7.c (s7_build_score_ops_hsh): Rename variable
        new to new_opcode. (s7_build_dependency_insn_hsh): Rename variable
        new to new_i2d. (s7_b32_relax_to_b16, s7_convert_frag): Rename
        variables old and new to r_old and r_new.
        * gas/config/tc-sh.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-sh64.c (shmedia_parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-tic4x.c (tic4x_operand_parse): Rename variable new
        to new_pointer.
        * gas/config/tc-z8k.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/listing.c (listing_newline): Rename variable new to new_i.
        * ld/ldexp.c (exp_intop, exp_bigintop, exp_relop, exp_binop)
        (exp_trinop, exp_unop, exp_nameop, exp_assop): Rename variable new
        to new_e.
        * ld/ldfile.c (ldfile_add_library_path): Rename variable new to
        new_dirs. (ldfile_add_arch): Rename variable new to new_arch.
        * ld/ldlang.c (new_statement, lang_final, lang_add_wild)
        (lang_target, lang_add_fill, lang_add_data, lang_add_assignment)
        (lang_add_insert): Rename variable new to new_stmt. (new_afile):
        Added missing cast. (lang_memory_region_lookup): Rename variable
        new to new_region. (init_os): Rename variable new to
        new_userdata. (lang_add_section): Rename variable new to
        new_section. (ldlang_add_undef): Rename variable new to
        new_undef. (realsymbol): Rename variable new to new_name.
        * opcodes/z8kgen.c (internal, gas): Rename variable new to new_op.

        Updated sources to avoid using the identifier name "template",
        which is a keyword in c++.

        * bfd/elf32-arm.c (struct stub_def): Rename member template to
        template_sequence. (arm_build_one_stub,
        find_stub_size_and_template, arm_size_one_stub, arm_map_one_stub):
        Rename variable template to template_sequence.
        * bfd/elfxx-ia64.c (elfNN_ia64_relax_br, elfNN_ia64_relax_brl):
        Rename variable template to template_val.
        * gas/config/tc-arm.c (struct asm_cond, struct asm_psr, struct
        asm_barrier_opt): Change member template to
        template_name. (md_begin): Update code to reflect new member
        names.
        * gas/config/tc-i386.c (struct templates, struct _i386_insn)
        (match_template, cpu_flags_match, match_reg_size, match_mem_size)
        (operand_size_match, md_begin, i386_print_statistics, pi)
        (build_vex_prefix, md_assemble, parse_insn, optimize_imm)
        (optimize_disp): Updated code to use new names. (parse_insn):
        Added casts.
        * gas/config/tc-ia64.c (dot_template, emit_one_bundle): Updated
        code to use new names.
        * gas/config/tc-score.c (struct s3_asm_opcode): Renamed member
        template to template_name. (s3_parse_16_32_inst, s3_parse_48_inst,
        s3_do_macro_ldst_label, s3_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-score7.c (struct s7_asm_opcode): Renamed member
        template to template_name. (s7_parse_16_32_inst,
        s7_do_macro_ldst_label, s7_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-tic30.c (md_begin, struct tic30_insn)
        (md_assemble): Update code to use new names.
        * gas/config/tc-tic54x.c (struct _tic54x_insn, md_begin)
        (optimize_insn, tic54x_parse_insn, next_line_shows_parallel):
        Update code to use new names.
        * include/opcode/tic30.h (template): Rename type template to
        insn_template. Updated code to use new name.
        * include/opcode/tic54x.h (template): Rename type template to
        insn_template.
        * opcodes/cris-dis.c (bytes_to_skip): Update code to use new name.
        * opcodes/i386-dis.c (putop): Update code to use new name.
        * opcodes/i386-gen.c (process_i386_opcodes): Update code to use
        new name.
        * opcodes/i386-opc.h (struct template): Rename struct template to
        insn_template. Update code accordingly.
        * opcodes/i386-tbl.h (i386_optab): Update type to use new name.
        * opcodes/ia64-dis.c (print_insn_ia64): Rename variable template
        to template_val.
        * opcodes/tic30-dis.c (struct instruction, get_tic30_instruction):
        Update code to use new name.
        * opcodes/tic54x-dis.c (has_lkaddr, get_insn_size)
        (print_parallel_instruction, print_insn_tic54x, tic54x_get_insn):
        Update code to use new name.
        * opcodes/tic54x-opc.c (tic54x_unknown_opcode, tic54x_optab):
        Update type to new name.
@
text
@d55 1
a62 1
static const char *output_target;
d89 1
a95 1
static const char *entry_symbol_default = "start";
@


1.315
log
@2009-08-12  Tristan Gingold  <gingold@@adacore.com>

	* ld.h (fat_user_section_struct): Add map_symbol_def_count field.
	* ldlang.c (hash_entry_addr_cmp): New function.
	(print_all_symbols): Sort the symbols by address before printing them.
@
text
@d952 1
a952 1
  lang_statement_union_type *new;
d954 5
a958 5
  new = stat_alloc (size);
  new->header.type = type;
  new->header.next = NULL;
  lang_statement_append (list, new, &new->header.next);
  return new;
d979 1
a979 1
    p = new_stat (lang_input_statement, stat_ptr);
d982 2
a983 1
      p = stat_alloc (sizeof (lang_input_statement_type));
d1224 1
a1224 1
  lang_memory_region_type *new;
d1243 2
a1244 1
  new = stat_alloc (sizeof (lang_memory_region_type));
d1246 10
a1255 10
  new->name_list.name = xstrdup (name);
  new->name_list.next = NULL;
  new->next = NULL;
  new->origin = 0;
  new->length = ~(bfd_size_type) 0;
  new->current = 0;
  new->last_os = NULL;
  new->flags = 0;
  new->not_flags = 0;
  new->had_full_message = FALSE;
d1257 2
a1258 2
  *lang_memory_region_list_tail = new;
  lang_memory_region_list_tail = &new->next;
d1260 1
a1260 1
  return new;
d2062 4
a2065 4
      fat_section_userdata_type *new
	= stat_alloc (sizeof (fat_section_userdata_type));
      memset (new, 0, sizeof (fat_section_userdata_type));
      get_userdata (s->bfd_section) = new;
d2201 1
a2201 1
      lang_input_section_type *new;
d2249 1
a2249 1
      new = new_stat (lang_input_section, ptr);
d2251 1
a2251 1
      new->section = section;
d3255 2
a3256 2
  ldlang_undef_chain_list_type *new =
    stat_alloc (sizeof (ldlang_undef_chain_list_type));
d3258 2
a3259 2
  new->next = ldlang_undef_chain_list_head;
  ldlang_undef_chain_list_head = new;
d3261 1
a3261 1
  new->name = xstrdup (name);
d3264 1
a3264 1
    insert_undefined (new->name);
d6015 4
a6018 1
  lang_output_statement_type *new;
a6019 2
  new = new_stat (lang_output_statement, stat_ptr);
  new->name = output_filename;
d6383 1
a6383 1
  lang_wild_statement_type *new;
d6405 3
a6407 3
  new = new_stat (lang_wild_statement, stat_ptr);
  new->filename = NULL;
  new->filenames_sorted = FALSE;
d6410 2
a6411 2
      new->filename = filespec->name;
      new->filenames_sorted = filespec->sorted == by_name;
d6413 4
a6416 4
  new->section_list = section_list;
  new->keep_sections = keep_sections;
  lang_list_init (&new->children);
  analyze_walk_wild_section_handler (new);
d6461 1
a6461 1
  lang_target_statement_type *new;
d6463 2
a6464 2
  new = new_stat (lang_target_statement, stat_ptr);
  new->target = name;
d6485 1
a6485 1
  lang_fill_statement_type *new;
d6487 2
a6488 2
  new = new_stat (lang_fill_statement, stat_ptr);
  new->fill = fill;
d6494 1
a6494 1
  lang_data_statement_type *new;
d6496 3
a6498 3
  new = new_stat (lang_data_statement, stat_ptr);
  new->exp = exp;
  new->type = type;
d6531 1
a6531 1
  lang_assignment_statement_type *new;
d6533 3
a6535 3
  new = new_stat (lang_assignment_statement, stat_ptr);
  new->exp = exp;
  return new;
d6720 1
a6720 1
  lang_insert_statement_type *new;
d6722 3
a6724 3
  new = new_stat (lang_insert_statement, stat_ptr);
  new->where = where;
  new->is_before = is_before;
d7267 1
a7267 1
/* This is called for each variable name or match expression.  NEW is
d7273 1
a7273 1
		       const char *new,
d7279 1
a7279 1
  ret = xmalloc (sizeof *ret);
d7284 1
a7284 1
  ret->pattern = literal_p ? new : realsymbol (new);
d7287 1
a7287 1
      ret->pattern = new;
@


1.314
log
@	PR 10474
	* ldemul.c (after_allocation_default): Run lang_relax_sections.
	* ldlang.h (lang_relax_sections): Declare.
	* ldlang.c (relax_sections): Delete.
	(lang_relax_sections): New function.
	(lang_process): Don't relax directly from here.
	* emultempl/alphaelf.em (alpha_finish): Call finish_default.
	* emultempl/armelf.em (arm_elf_after_allocation): Delete.  Move body..
	(gld${EMULATION_NAME}_finish): ..to here.  Move existing code..
	(gld${EMULATION_NAME}_after_allocation): ..to here.  New function.
	(LDEMUL_AFTER_ALLOCATION): Update.
	* emultempl/avrelf.em (avr_elf_finish, LDEMUL_FINISH): Delete.
	(avr_elf_after_allocation): New function.
	(LDEMUL_AFTER_ALLOCATION): Define.
	* emultempl/elf-generic.em (gld${EMULATION_NAME}_map_segments): Call
	lang_relax_sections.
	* emultempl/elf32.em (gld${EMULATION_NAME}_finish): Delete.  Move..
	(gld${EMULATION_NAME}_after_allocation): ..code to here.  New function.
	(LDEMUL_AFTER_ALLOCATION, LDEMUL_FINISH): Update.
	* emultempl/genelf.em (gld${EMULATION_NAME}_finish): Delete.  Move..
	(gld${EMULATION_NAME}_after_allocation): ..code to here.  New function.
	(LDEMUL_FINISH): Delete.
	(LDEMUL_AFTER_ALLOCATION): Define.
	* emultempl/hppaelf.em (gld${EMULATION_NAME}_finish): Delete.  Move..
	(gld${EMULATION_NAME}_after_allocation): ..to here.  New function.
	(LDEMUL_FINISH): Delete.
	(LDEMUL_AFTER_ALLOCATION): Define.
	* emultempl/m68hc1xelf.em (m68hc11elf_finish): Delete.  Move..
	(m68hc11elf_after_allocation): ..to here.  New function.
	(LDEMUL_FINISH): Delete.
	(LDEMUL_AFTER_ALLOCATION): Define.
	* emultempl/m68kelf.em (m68k_elf_after_allocation): Call
	gld${EMULATION_NAME}_after_allocation.
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): Call
	gld${EMULATION_NAME}_after_allocation.
	* emultempl/mmo.em (mmo_finish): Delete.  Move body..
	(gld${EMULATION_NAME}_after_allocation): ..to here.  New function.
	(LDEMUL_FINISH): Define.
	* emultempl/ppc64elf.em (ppc_layout_sections_again): Set elf_gp.
	(gld${EMULATION_NAME}_finish): Move code sizing sections..
	(gld${EMULATION_NAME}_after_allocation): ..to here.
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_after_allocation):
	Call gld${EMULATION_NAME}_after_allocation.
	* emultempl/spuelf.em (gld${EMULATION_NAME}_finish): Delete
	bfd_elf_discard_info and map_segments call.
@
text
@d2000 1
d2028 1
d3954 14
d3973 2
d3980 16
a3995 2
  for (def = ud->map_symbol_def_head; def; def = def->next)
    print_one_symbol (def->entry, sec);
@


1.313
log
@2009-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/10429
	* ldlang.c (insert_os_after): Tie assignments to non-alloc
	output sections if there is no-input section.
@
text
@d6162 2
a6163 2
static void
relax_sections (void)
d6165 12
a6176 2
  /* Keep relaxing until bfd_relax_section gives up.  */
  bfd_boolean relax_again;
d6178 4
a6181 5
  link_info.relax_trip = -1;
  do
    {
      relax_again = FALSE;
      link_info.relax_trip++;
d6183 18
a6200 3
      /* Note: pe-dll.c does something like this also.  If you find
	 you need to change this code, you probably need to change
	 pe-dll.c also.  DJ  */
d6202 8
a6209 2
      /* Do all the assignments with our current guesses as to
	 section sizes.  */
a6210 3

      /* We must do this after lang_do_assignments, because it uses
	 size.  */
d6212 1
a6212 4

      /* Perform another relax pass - this time we know where the
	 globals are, so can make a better guess.  */
      lang_size_sections (&relax_again, FALSE);
a6213 1
  while (relax_again);
a6318 21
  /* Now run around and relax if we can.  */
  if (command_line.relax)
    {
      /* We may need more than one relaxation pass.  */
      int i = link_info.relax_pass;

      /* The backend can use it to determine the current pass.  */
      link_info.relax_pass = 0;

      while (i--)
	{
	  relax_sections ();
	  link_info.relax_pass++;
	}

      /* Final extra sizing to report errors.  */
      lang_do_assignments ();
      lang_reset_memory_regions ();
      lang_size_sections (NULL, TRUE);
    }

d6320 1
a6320 1
     everything is.  */
@


1.312
log
@	* ldlang.c (insert_os_after): Don't tie assignments to non-alloc
	output sections.
@
text
@d1670 3
a1672 1
	      if (s == NULL || (s->flags & SEC_ALLOC) != 0)
@


1.311
log
@2009-06-25  Tristan Gingold  <gingold@@adacore.com>

	* ldlang.c (print_input_section): Add is_discarded parameter.  Adjust
	prototype.
	(lang_map): Print the size of discarded sections.
	(print_statement): Adjust call to print_input_section.
@
text
@d1618 6
a1623 4
   are assumed to belong to it.  An exception to this rule is made for
   the first assignment to dot, otherwise we might put an orphan
   before . = . + SIZEOF_HEADERS or similar assignments that set the
   initial address.  */
d1667 6
a1672 1
	    where = assign;
@


1.310
log
@	* ldlang.c (lang_check_section_addresses): Ignore non-alloc sections.
@
text
@d81 1
a81 1
static void print_input_section (asection *);
d1920 1
a1920 1
	    print_input_section (s);
d3960 1
a3960 1
print_input_section (asection *i)
d3989 2
a3990 1
      size = 0;
d4285 1
a4285 1
      print_input_section (s->input_section.section);
@


1.309
log
@	* ldlang.c (lang_check_section_addresses): Ignore non-loadable
	sections when checking for overlap.  Clarify error message
	concerns load address.

	testsuite/
	* ld-scripts/rgn-at4.t: New.
	* ld-scripts/rgn-at4.d: New.
@
text
@d4501 3
a4503 1
      if ((s->flags & SEC_NEVER_LOAD) || !(s->flags & SEC_LOAD)
@


1.308
log
@ld/
	* ldlang.c (lang_output_section_statement_lookup): Add function
	comment.  Make "name" non-const.  Ensure duplicate entries use
	the same string, allowing simple comparison in hash bucket loop.
	Tweak constraint check.
	(next_matching_output_section_statement): New function.
	* ldlang.h (lang_output_section_statement_lookup): Update.
	(next_matching_output_section_statement): Declare.
	* emultempl/elf32.em (gld${EMULATION_NAME}_place_orphan): Don't
	combine orphan sections when input sections flags differ in
	alloc or load.
	* emultempl/pe.em: Formatting throughout.
	(gld${EMULATION_NAME}_place_orphan): As for elf32.em.
	* emultempl/pep.em: Formatting throughout.
	(gld${EMULATION_NAME}_place_orphan): As for elf32.em.
ld/testsuite/
	* ld-elf/orphan3.d, * ld-elf/orphan3a.s, * ld-elf/orphan3b.s,
	* ld-elf/orphan3c.s, * ld-elf/orphan3d.s, * ld-elf/orphan3e.s,
	* ld-elf/orphan3f.s: New test.
	* ld-pe/orphan.d, * ld-pe/orphana.s, * ld-pe/orphanb.s,
	* ld-pe/orphand.s, * ld-pe/orphane.s: New test.
	* ld-pe/direct.exp: Use is_pecoff_format.
	* ld-pe/longsecn.exp: Delete.
	* ld-pe/pe.exp: Run new test and longsecn tests.
@
text
@d4501 2
a4502 1
      if (IGNORE_SECTION (s) || s->size == 0)
d4533 1
a4533 1
	einfo (_("%X%P: section %s [%V -> %V] overlaps section %s [%V -> %V]\n"),
@


1.307
log
@	* ldlang.c (lang_insert_orphan): Add __start_<section> symbol
	assignment inside output section statement.  Ensure only one
	set of symbols per output section.
	* emultempl/pe.em (gld_${EMULATION_NAME}_place_orphan): Add non-
	dollar sections before dollar sections.  Correct add_child
	list insertion.
	* emultempl/pep.em (gld_${EMULATION_NAME}_place_orphan): Likewise.
@
text
@d1325 5
d1331 1
a1331 1
lang_output_section_statement_lookup (const char *const name,
a1351 1
      unsigned long hash = entry->root.hash;
d1353 1
d1362 3
a1364 4
	    if (entry->s.output_section_statement.constraint >= 0
		&& (constraint == 0
		    || (constraint
			== entry->s.output_section_statement.constraint)))
d1370 1
a1370 2
	       && entry->root.hash == hash
	       && strcmp (name, entry->s.output_section_statement.name) == 0);
d1394 30
@


1.306
log
@bfd/
	* aout-adobe.c (aout_32_bfd_define_common_symbol): Define.
	* aout-target.h (MY_bfd_define_common_symbol): Likewise.
	* aout-tic30.c (MY_bfd_define_common_symbol): Likewise.
	* binary.c (binary_bfd_define_common_symbol): Likewise.
	* bout.c (b_out_bfd_define_common_symbol): Likewise.
	* coff-alpha.c (_bfd_ecoff_bfd_define_common_symbol): Likewise.
	* coff-mips.c (_bfd_ecoff_bfd_define_common_symbol): Likewise.
	* coffcode.h (coff_bfd_define_common_symbol): Likewise.
	* elfxx-target.h (bfd_elfNN_bfd_define_common_symbol): Likewise.
	* i386msdos.c (msdos_bfd_define_common_symbol): Likewise.
	* i386os9k.c (os9k_bfd_define_common_symbol): Likewise.
	* ieee.c (ieee_bfd_define_common_symbol): Likewise.
	* ihex.c (ihex_bfd_define_common_symbol): Likewise.
	* libbfd-in.h (_bfd_nolink_bfd_define_common_symbol): Likewise.
	* mach-o.c (bfd_mach_o_bfd_define_common_symbol): Likewise.
	* mmo.c (mmo_bfd_define_common_symbol): Likewise.
	* nlm-target.h (nlm_bfd_define_common_symbol): Likewise.
	* oasys.c (oasys_bfd_define_common_symbol): Likewise.
	* pef.c (bfd_pef_bfd_define_common_symbol): Likewise.
	* ppcboot.c (ppcboot_bfd_define_common_symbol): Likewise.
	* som.c (som_bfd_define_common_symbol): Likewise.
	* srec.c (srec_bfd_define_common_symbol): Likewise.
	* tekhex.c (tekhex_bfd_define_common_symbol): Likewise.
	* versados.c (versados_bfd_define_common_symbol): Likewise.
	* vms.c (vms_bfd_define_common_symbol): Likewise.
	* xcoff-target.h (_bfd_xcoff_bfd_define_common_symbol): Likewise.
	* xsym.c (bfd_sym_bfd_define_common_symbol): Likewise.
	* coff-rs6000.c (rs6000coff_vec): Add _bfd_xcoff_define_common_symbol.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.
	* linker.c (bfd_generic_define_common_symbol): New function.
	* targets.c (BFD_JUMP_TABLE_LINK): Add NAME##_bfd_define_common_symbol.
	(_bfd_define_common_symbol): New field.
	* libcoff-in.h (_bfd_xcoff_define_common_symbol): Declare.
	* xcofflink.c (_bfd_xcoff_define_common_symbol): New function.
	(xcoff_build_ldsyms): Don't set XCOFF_DEF_REGULAR for common
	symbols here.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Likewise.
	* libcoff.h: Likewise.

ld/
	* ldlang.c (lang_one_common): Use bfd_define_common_symbol.

ld/testsuite/
	* ld-powerpc/aix-export-2.s, ld-powerpc/aix-export-2.nd: New test.
	* ld-powerpc/aix52.exp: Run it.
@
text
@d1671 8
d1680 1
a1680 1
  if (config.build_constructors)
d1699 2
a1700 1
					    exp_nameop (NAME, "."),
a1704 8
  if (link_info.relocatable || (s->flags & (SEC_LOAD | SEC_ALLOC)) == 0)
    address = exp_intop (0);

  os_tail = ((lang_output_section_statement_type **)
	     lang_output_section_statement.tail);
  os = lang_enter_output_section_statement (secname, address, 0, NULL, NULL,
					    NULL, constraint);

d1711 1
a1711 1
  if (config.build_constructors && *ps == '\0')
@


1.305
log
@gprof/
	* gprof.h: Include gconfig.h.  #undef PACKAGE.

ld/
	* ldlang.c: Do not include limits.h.
@
text
@d5642 3
a5644 21

  /* Increase the size of the section to align the common sym.  */
  section->size += ((bfd_vma) 1 << (power_of_two + opb_shift)) - 1;
  section->size &= (- (bfd_vma) 1 << (power_of_two + opb_shift));

  /* Adjust the alignment if necessary.  */
  if (power_of_two > section->alignment_power)
    section->alignment_power = power_of_two;

  /* Change the symbol from common to defined.  */
  h->type = bfd_link_hash_defined;
  h->u.def.section = section;
  h->u.def.value = section->size;

  /* Increase the size of the section.  */
  section->size += size;

  /* Make sure the section is allocated in memory, and make sure that
     it is no longer a common section.  */
  section->flags |= SEC_ALLOC;
  section->flags &= ~SEC_IS_COMMON;
@


1.304
log
@	* ldlang.c (lang_leave_output_section_statement): Set lma_region
	if it is not overridden and section is for the same vma region as
	the previous section.

	* ld-scripts/rgn-at.exp: New.
	* ld-scripts/rgn-at.s: New.
	* ld-scripts/rgn-at1.d: New.
	* ld-scripts/rgn-at1.t: New.
	* ld-scripts/rgn-at2.d: New.
	* ld-scripts/rgn-at2.t: New.
	* ld-scripts/rgn-at3.d: New.
	* ld-scripts/rgn-at3.t: New.
@
text
@a22 2
#include <limits.h>

@


1.303
log
@ld/

2009-03-20  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/9970
	* ldlang.c (lang_end): Warn missing entry symbol for -pie.

ld/testsuite/

2009-03-20  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/9970
	* ld-pie/pie.exp: Use -fpie to compile.  Run *.d tests.

	* ld-pie/start.d: New.
	* ld-pie/start.s: Likewise.
@
text
@d6546 9
@


1.302
log
@        * ldgram.y: Add support for REGION_ALIAS operator.
        * ldlang.c: Likewise.
        * ldlang.h: Likewise.
        * ldlex.l: Likewise.
        * NEWS: Mention the new feature.
        * ld.texinfo: Document the new feature.
        * ld-scripts/regions-alias-1.t: New file.
        * ld-scripts/regions-alias-2.t: New file.
        * ld-scripts/regions-alias-3.t: New file.
        * ld-scripts/regions-alias-4.t: New file.
        * ld-scripts/script.exp: Run region alias tests.
@
text
@d5420 1
a5420 1
      || link_info.shared)
@


1.301
log
@	* ldlang.c (process_insert_statements): ASSERT that output section
	statements are in order.
@
text
@d1208 7
a1214 1
  and so we issue a warning.  */
d1223 2
a1224 1
  lang_memory_region_type *p;
d1231 9
a1239 8
  for (p = lang_memory_region_list; p != NULL; p = p->next)
    if (strcmp (p->name, name) == 0)
      {
	if (create)
	  einfo (_("%P:%S: warning: redeclaration of memory region '%s'\n"),
		 name);
	return p;
      }
d1242 1
a1242 1
    einfo (_("%P:%S: warning: memory region %s not declared\n"), name);
d1246 2
a1247 1
  new->name = xstrdup (name);
d1263 42
d1306 1
a1306 1
lang_memory_default (asection *section)
d1901 1
a1901 1
      fprintf (config.map_file, "%-16s ", m->name);
d4516 2
a4517 2
      einfo (_("%X%P: region %s overflowed by %ld bytes\n"),
	     m->name, (long)(m->current - (m->origin + m->length)));
d4539 2
a4540 2
	  einfo (_("%X%P: address 0x%v of %B section %s"
		   " is not within region %s\n"),
d4544 1
a4544 1
		 region->name);
d4550 1
a4550 1
	  einfo (_("%X%P: %B section %s will not fit in region %s\n"),
d4553 1
a4553 1
		 region->name);
d4642 2
a4643 2
			    && os->region->name[0] == '*'
			    && strcmp (os->region->name,
d4656 1
a4656 1
			&& strcmp (os->region->name,
d4659 1
a4659 1
			&& (strcmp (lang_memory_region_list->name,
@


1.300
log
@	* ldlang.c (push_stat_ptr, pop_stat_ptr): New functions.
	(stat_save, stat_save_ptr): New variables.
	(lang_insert_orphan): Use push_stat_ptr and pop_stat_ptr.
	(load_symbols): Likewise.  Delete dead "bad_load" code.
	(open_input_bfds): Warn on script containing output sections.
	(lang_enter_output_section_statement): Use push_stat_ptr.
	(lang_enter_group): Likewise.
	(lang_leave_output_section_statement): Use pop_stat_ptr.
	(lang_leave_group): Likewise.
	* ldlang.h (push_stat_ptr, pop_stat_ptr): Declare.
	* ldctor.c (ldctor_build_sets): Use push_stat_ptr and pop_stat_ptr.
	* emultempl/beos.em (gld_${EMULATION_NAME}_set_symbols): Likewise.
	* emultempl/pe.em (gld_${EMULATION_NAME}_set_symbols): Likewise.
	* emultempl/pep.em (gld_${EMULATION_NAME}_set_symbols): Likewise.
	* emultempl/spuelf.em (spu_place_special_section): Likewise.
	* emultempl/xtensaelf.em (ld_xtensa_insert_page_offsets): Likewise.
@
text
@d3441 4
a3444 1
	  last_os = &(*s)->output_section_statement;
@


1.299
log
@	Missing piece of 2009-01-26 commit
	* ldlang.c (lang_process): Don't consider relocatable flag when
	checking for overlap.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
d67 2
d930 17
a1607 1
  lang_statement_list_type *old;
a1612 4
  /* Start building a list of statements for this section.
     First save the current statement pointer.  */
  old = stat_ptr;

d1618 2
a1619 2
      stat_ptr = &add;
      lang_list_init (stat_ptr);
a1664 5
      /* lang_leave_ouput_section_statement resets stat_ptr.
	 Put stat_ptr back where we want it.  */
      if (after != NULL)
	stat_ptr = &add;

d1675 1
a1675 1
    stat_ptr = old;
d1761 2
a1762 2
	  if (*old->tail == add.head)
	    old->tail = add.tail;
a2492 2
      lang_statement_list_type *hold;
      bfd_boolean bad_load = TRUE;
a2514 2
      else
	bad_load = FALSE;
d2522 1
a2522 2
      hold = stat_ptr;
      stat_ptr = place;
d2541 1
a2541 1
      stat_ptr = hold;
d2543 1
a2543 1
      return ! bad_load;
d3015 1
d3031 1
d3039 19
a3057 2
		  *add.tail = s->header.next;
		  s->header.next = add.head;
d5886 1
a5886 1
  stat_ptr = &os->children;
d6494 1
a6494 1
  stat_ptr = &statement_list;
d6611 1
a6611 1
  stat_ptr = &g->children;
d6622 1
a6622 1
  stat_ptr = &statement_list;
@


1.298
log
@include/
	PR 7047
	* bfdlink.h (struct bfd_elf_version_expr): Delete "symbol".
	Add "literal".
bfd/
	PR 7047
	* configure.in: Bump version.
	* configure: Regenerate.
	* elflink.c (_bfd_elf_link_assign_sym_version): Continue matching
	against version nodes when a global match is a wildcard.  Similarly
	continue matching on local wildcard matches, rather than only
	continuing for "*".  Have any global wildcard match override a
	local wildcard match.  Correct logic hiding unversioned symbol.
	(bfd_elf_size_dynamic_sections): Update for changes to struct
	bfd_elf_version_expr.
ld/
	PR 7047
	* emultempl/ppc64elf.em (gld${EMULATION_NAME}_new_vers_pattern): Update
	for changes to struct bfd_elf_version_expr.
	* ldlang.c (lang_vers_match, version_expr_head_hash): Likewise.
	(version_expr_head_eq, lang_finalize_version_expr_head): Likewise.
	(lang_register_vers_node): Likewise.
	(lang_new_vers_pattern): Likewise.  Ensure "literal" is set when
	no glob chars found in "pattern".
	(realsymbol): Correct backslash quote logic.
	* ld.texinfo (VERSION): Warn about global wildcards.
@
text
@d6228 1
a6228 2
  if (! link_info.relocatable
      && command_line.check_section_addresses)
@


1.297
log
@	* ldlang.c (lang_record_phdrs): Don't add orphans to PT_INTERP header.
@
text
@d6992 1
a6992 1
  if (head->htab && (prev == NULL || prev->symbol))
d7001 1
a7001 1
	      e.symbol = sym;
d7003 1
a7003 1
	      while (expr && strcmp (expr->symbol, sym) == 0)
d7013 1
a7013 1
	      e.symbol = cxx_sym;
d7015 1
a7015 1
	      while (expr && strcmp (expr->symbol, cxx_sym) == 0)
d7025 1
a7025 1
	      e.symbol = java_sym;
d7027 1
a7027 1
	      while (expr && strcmp (expr->symbol, java_sym) == 0)
d7040 1
a7040 1
  if (prev == NULL || prev->symbol)
d7073 1
a7073 1
   return a string pointing to the symbol name.  */
a7085 6
      if (! backslash && (*p == '?' || *p == '*' || *p == '['))
	{
	  free (symbol);
	  return NULL;
	}

d7090 1
d7094 6
a7099 1
	*s++ = *p;
d7101 3
a7103 1
      backslash = *p == '\\';
a7131 1
  ret->pattern = literal_p ? NULL : new;
d7134 7
a7140 1
  ret->symbol = literal_p ? new : realsymbol (new);
d7184 1
a7184 1
  return htab_hash_string (e->symbol);
d7193 1
a7193 1
  return strcmp (e1->symbol, e2->symbol) == 0;
d7205 1
a7205 1
      if (e->symbol)
d7219 1
a7219 1
	  if (!e->symbol)
d7244 1
a7244 1
		  while (e1 && strcmp (e1->symbol, e->symbol) == 0);
d7251 1
a7251 1
		      /* free (e->symbol); */
d7315 1
a7315 1
	  if (t->locals.htab && e1->symbol)
d7318 1
a7318 1
	      while (e2 && strcmp (e1->symbol, e2->symbol) == 0)
d7322 1
a7322 1
			     " in version information\n"), e1->symbol);
d7326 1
a7326 1
	  else if (!e1->symbol)
d7341 1
a7341 1
	  if (t->globals.htab && e1->symbol)
d7344 1
a7344 1
	      while (e2 && strcmp (e1->symbol, e2->symbol) == 0)
d7349 1
a7349 1
			   e1->symbol);
d7353 1
a7353 1
	  else if (!e1->symbol)
@


1.296
log
@        PR 6945
        * ldlang.c (lang_size_sections_1): Do not update the VMAs of
        output sections when performing a relocatable link on COFF
        objects.
@
text
@d6672 4
@


1.295
log
@	* ldlang.c (lang_output_section_find_by_flags): Handle non-alloc
	sections.
	* emultempl/elf32.em (enum orphan_save_index): Add orphan_nonalloc.
	(hold): Likewise.
	(gld${EMULATION_NAME}_place_orphan): Handle non-alloc orphans.
@
text
@d4629 6
a4634 1
		bfd_set_section_vma (0, os->bfd_section, newdot);
@


1.294
log
@	* ldemul.c (ldemul_place_orphan): Add "constraint" param.
	* ldemul.h (ldemul_place_orphan): Update prototype.
	(struct ld_emulation_xfer_struct <place_orphan>): Likewise add param.
	* ldlang.c (unique_section_p): Make static.
	(lang_output_section_statement_lookup): Optimise creation of SPECIAL
	sections.
	(lang_insert_orphan): Add "constraint" param.  Pass to
	lang_enter_output_section_statement.
	(init_os): Don't use an existing bfd section for SPECIAL sections.
	(lang_place_orphans): Don't rename unique output sections, instead
	mark their output section statements SPECIAL.
	* ldlang.h (lang_insert_orphan): Update prototype.
	(unique_section_p): Delete.
	* emultempl/beos.em (place_orphan): Add "constraint" param.
	* emultempl/elf32.em (place_orphan): Likewise.  Don't match existing
	output sections if set.
	* emultempl/pe.em (place_orphan): Likewise.
	* emultempl/pep.em (place_orphan): Likewise.
	* emultempl/mmo.em (mmo_place_orphan): Update.
	* emultempl/spuelf.em (spu_place_special_section): Update.
@
text
@d1366 2
a1367 1
  if (sec->flags & SEC_CODE)
d1387 2
a1388 1
  else if (sec->flags & (SEC_READONLY | SEC_THREAD_LOCAL))
d1409 2
a1410 1
  else if (sec->flags & SEC_SMALL_DATA)
d1432 2
a1433 1
  else if (sec->flags & SEC_HAS_CONTENTS)
d1453 1
a1453 1
  else
d1455 1
a1455 1
      /* .bss goes last.  */
d1472 14
@


1.293
log
@bfd/
	* elf.c (bfd_elf_set_group_contents): Assign sh_info for ld -r when
	the signature symbol is global.
	* elflink.c (elf_link_input_bfd): Ensure group signature symbol
	is output when ld -r.  Set group sh_info when local.
	* linker.c (default_indirect_link_order): Handle group sections
	specially.
ld/
	* ldemul.c (ldemul_place_orphan): Add "name" param.
	* ldemul.h (ldemul_place_orphan): Update prototype.
	(struct ld_emulation_xfer_struct <place_orphan>): Likewise.
	* ldlang.c (lang_place_orphans): Generate unique section names here..
	* emultempl/elf32.em (place_orphan): ..rather than here.  Don't
	directly use an existing output section statement that has no
	bfd section.
	* emultempl/pe.em (place_orphan): Likewise.
	* emultempl/pep.em (place_orphan): Likewise.
	* emultempl/beos.em (place_orphan): Adjust.
	* emultempl/spuelf.em (spu_place_special_section): Adjust
	place_orphan call.
	* emultempl/genelf.em (gld${EMULATION_NAME}_after_open): New function.
	(LDEMUL_AFTER_OPEN): Define.
@
text
@d196 1
a196 1
bfd_boolean
d1281 19
a1299 13
      do
	{
	  if (entry->s.output_section_statement.constraint >= 0
	      && (constraint == 0
		  || (constraint == entry->s.output_section_statement.constraint
		      && constraint != SPECIAL)))
	    return &entry->s.output_section_statement;
	  last_ent = entry;
	  entry = (struct out_section_hash_entry *) entry->root.next;
	}
      while (entry != NULL
	     && entry->root.hash == hash
	     && strcmp (name, entry->s.output_section_statement.name) == 0);
d1565 1
d1621 1
a1621 1
					    NULL, 0);
d1924 2
a1925 1
  s->bfd_section = bfd_get_section_by_name (link_info.output_bfd, s->name);
d1927 2
a1928 2
    s->bfd_section = bfd_make_section_with_flags (link_info.output_bfd,
						  s->name, flags);
d5666 1
d5668 2
a5669 11
		  if ((config.unique_orphan_sections
		       || unique_section_p (s))
		      && bfd_get_section_by_name (link_info.output_bfd,
						  name) != NULL)
		    {
		      static int count = 1;
		      name = bfd_get_unique_section_name (link_info.output_bfd,
							  name, &count);
		      if (name == NULL)
			einfo ("%F%P: place_orphan failed: %E\n");
		    }
d5671 1
a5671 1
		  if (!ldemul_place_orphan (s, name))
d5674 2
a5675 1
		      os = lang_output_section_statement_lookup (name, 0,
@


1.292
log
@	* ldlang.h (lang_output_section_find): Define.
	(lang_output_section_statement_lookup): Update prototype.
	* ldlang.c (lang_output_section_find,
	lang_output_section_statement_lookup_1): Merge into..
	(lang_output_section_statement_lookup): ..here.  Update all callers.
	(process_insert_statements): Set constraint negative
	for output section statements we might be inserting.  Make error
	fatal on not finding insertion section.
	(lang_output_section_find): Rather than comparing
	output_section_statement.constraint against -1, test whether
	it is postive.
	(lang_output_section_statement_lookup_1): Likewise.
	(output_prev_sec_find, strip_excluded_output_sections): Likewise.
	(lang_record_phdrs): Likewise.
	* emultempl/elf32.em (output_rel_find): Likewise.
	* NEWS: Mention INSERT.
@
text
@a5654 2
	      else if (ldemul_place_orphan (s))
		;
d5657 1
a5657 1
		  lang_output_section_statement_type *os;
d5659 19
a5677 2
		  os = lang_output_section_statement_lookup (s->name, 0, TRUE);
		  lang_add_section (&os->children, s, os);
@


1.292.2.1
log
@backport 2008-10-03  Alan Modra  <amodra@@bigpond.net.au>
@
text
@d5655 2
d5659 1
a5659 1
		  const char *name = s->name;
d5661 2
a5662 19
		  if ((config.unique_orphan_sections
		       || unique_section_p (s))
		      && bfd_get_section_by_name (link_info.output_bfd,
						  name) != NULL)
		    {
		      static int count = 1;
		      name = bfd_get_unique_section_name (link_info.output_bfd,
							  name, &count);
		      if (name == NULL)
			einfo ("%F%P: place_orphan failed: %E\n");
		    }

		  if (!ldemul_place_orphan (s, name))
		    {
		      lang_output_section_statement_type *os;
		      os = lang_output_section_statement_lookup (name, 0,
								 TRUE);
		      lang_add_section (&os->children, s, os);
		    }
@


1.292.2.2
log
@backport 2008-10-04  Alan Modra  <amodra@@bigpond.net.au>
@
text
@d196 1
a196 1
static bfd_boolean
d1281 13
a1293 19
      if (create && constraint == SPECIAL)
	/* Not traversing to the end reverses the order of the second
	   and subsequent SPECIAL sections in the hash table chain,
	   but that shouldn't matter.  */
	last_ent = entry;
      else
	do
	  {
	    if (entry->s.output_section_statement.constraint >= 0
		&& (constraint == 0
		    || (constraint
			== entry->s.output_section_statement.constraint)))
	      return &entry->s.output_section_statement;
	    last_ent = entry;
	    entry = (struct out_section_hash_entry *) entry->root.next;
	  }
	while (entry != NULL
	       && entry->root.hash == hash
	       && strcmp (name, entry->s.output_section_statement.name) == 0);
a1558 1
		    int constraint,
d1614 1
a1614 1
					    NULL, constraint);
d1917 1
a1917 2
  if (s->constraint != SPECIAL)
    s->bfd_section = bfd_get_section_by_name (link_info.output_bfd, s->name);
d1919 2
a1920 2
    s->bfd_section = bfd_make_section_anyway_with_flags (link_info.output_bfd,
							 s->name, flags);
a5657 1
		  int constraint = 0;
d5659 11
a5669 2
		  if (config.unique_orphan_sections || unique_section_p (s))
		    constraint = SPECIAL;
d5671 1
a5671 1
		  if (!ldemul_place_orphan (s, name, constraint))
d5674 1
a5674 2
		      os = lang_output_section_statement_lookup (name,
								 constraint,
@


1.292.2.3
log
@backport 2009-02-16  Alan Modra  <amodra@@bigpond.net.au>
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
a66 2
static lang_statement_list_type *stat_save[10];
static lang_statement_list_type **stat_save_ptr = &stat_save[0];
a927 17
void
push_stat_ptr (lang_statement_list_type *new_ptr)
{
  if (stat_save_ptr >= stat_save + sizeof (stat_save) / sizeof (stat_save[0]))
    abort ();
  *stat_save_ptr++ = stat_ptr;
  stat_ptr = new_ptr;
}

void
pop_stat_ptr (void)
{
  if (stat_save_ptr <= stat_save)
    abort ();
  stat_ptr = *--stat_save_ptr;
}

d1571 1
d1577 4
d1586 2
a1587 2
      lang_list_init (&add);
      push_stat_ptr (&add);
d1633 5
d1648 1
a1648 1
    pop_stat_ptr ();
d1734 2
a1735 2
	  if (*stat_ptr->tail == add.head)
	    stat_ptr->tail = add.tail;
d2466 2
d2490 2
d2499 2
a2500 1
      push_stat_ptr (place);
d2519 1
a2519 1
      pop_stat_ptr ();
d2521 1
a2521 1
      return TRUE;
a2992 1
	      lang_statement_union_type **os_tail;
a3007 1
	      os_tail = lang_output_section_statement.tail;
d3015 2
a3016 19
		  /* If this was a script with output sections then
		     tack any added statements on to the end of the
		     list.  This avoids having to reorder the output
		     section statement list.  Very likely the user
		     forgot -T, and whatever we do here will not meet
		     naive user expectations.  */
		  if (os_tail != lang_output_section_statement.tail)
		    {
		      einfo (_("%P: warning: %s contains output sections;"
			       " did you forget -T?\n"),
			     s->input_statement.filename);
		      *stat_ptr->tail = add.head;
		      stat_ptr->tail = add.tail;
		    }
		  else
		    {
		      *add.tail = s->header.next;
		      s->header.next = add.head;
		    }
d5840 1
a5840 1
  push_stat_ptr (&os->children);
d6449 1
a6449 1
  pop_stat_ptr ();
d6566 1
a6566 1
  push_stat_ptr (&g->children);
d6577 1
a6577 1
  pop_stat_ptr ();
@


1.291
log
@	PR ld/6833
	* ldexp.c (fold_binary <DATA_SEGMENT_ALIGN>): Do not align
	EXPLD.DATASEG.MIN_BASE.
	* ldlang.c (lang_size_sections): New variable OLD_BASE.  Rename
	OLD_MIN_BASE to MIN_BASE with the former alignment from `ldexp.c'.
	Use OLD_BASE now for the minimal base check after the base decrease by
	the maximum alignment found.
@
text
@d1152 1
a1152 1
    lang_output_section_statement_lookup (BFD_ABS_SECTION_NAME);
d1258 3
a1260 1
lang_output_section_find (const char *const name)
a1262 1
  unsigned long hash;
d1266 1
a1266 28
			    FALSE, FALSE));
  if (entry == NULL)
    return NULL;

  hash = entry->root.hash;
  do
    {
      if (entry->s.output_section_statement.constraint != -1)
	return &entry->s.output_section_statement;
      entry = (struct out_section_hash_entry *) entry->root.next;
    }
  while (entry != NULL
	 && entry->root.hash == hash
	 && strcmp (name, entry->s.output_section_statement.name) == 0);

  return NULL;
}

static lang_output_section_statement_type *
lang_output_section_statement_lookup_1 (const char *const name, int constraint)
{
  struct out_section_hash_entry *entry;
  struct out_section_hash_entry *last_ent;
  unsigned long hash;

  entry = ((struct out_section_hash_entry *)
	   bfd_hash_lookup (&output_section_statement_table, name,
			    TRUE, FALSE));
d1269 2
a1270 1
      einfo (_("%P%F: failed creating section `%s': %E\n"), name);
d1278 3
a1280 1
      hash = entry->root.hash;
d1283 1
a1283 1
	  if (entry->s.output_section_statement.constraint != -1
d1295 3
a1316 6
lang_output_section_statement_type *
lang_output_section_statement_lookup (const char *const name)
{
  return lang_output_section_statement_lookup_1 (name, 0);
}

d1479 1
a1479 1
      if (lookup->constraint == -1)
d3355 1
a3355 1
		   (s->address_statement.section_name));
d3380 1
d3393 6
a3405 1
	  lang_output_section_statement_type *os;
d3414 1
a3414 1
	      while (where != NULL && where->constraint == -1);
d3418 2
a3419 11
	      einfo (_("%X%P: %s not found for insert\n"), i->where);
	      continue;
	    }
	  /* You can't insert into the list you are moving.  */
	  for (os = first_os; os != NULL; os = os->next)
	    if (os == where || os == last_os)
	      break;
	  if (os == where)
	    {
	      einfo (_("%X%P: %s not found for insert\n"), i->where);
	      continue;
d3456 1
d3517 8
d3552 1
a3552 1
      if (os->constraint == -1)
d5648 3
a5650 5
			{
			  default_common_section =
			    lang_output_section_statement_lookup (".bss");

			}
d5661 1
a5661 1
		  os = lang_output_section_statement_lookup (s->name);
d5808 2
a5809 2
  os = lang_output_section_statement_lookup_1 (output_section_statement_name,
					       constraint);
a5811 2
  /* Make next things chain into subchain of this.  */

d5822 2
d6620 1
a6620 1
	  if (os->constraint == -1)
d6701 1
a6701 1
      if (os->constraint == -1
@


1.290
log
@bfd/
	* bfd.c (struct _bfd): Correct outsymbols comment.
	* bfd-in2.h: Regenerate.
	* linker.c (bfd_generic_link_read_symbols): Renamed from..
	(generic_link_read_symbols): ..this, and made global.

include/
	* bfdlink.h (bfd_generic_link_read_symbols): Declare.
ld/
	PR 6478
	* ldcref.c (check_local_sym_xref): Use bfd_generic_link_read_symbols.
	Don't free symbol pointer array.
	(check_refs): Likewise.
	* ldmain.c (warning_callback): Likewise.
	* ldmisc.c (vfinfo): Likewise.
	* pe-dll.c (process_def_file): Likewise.
	(pe_walk_relocs_of_symbol, generate_reloc): Likewise.
	* emultempl/pe.em (pe_find_data_imports): Likewise.
	(gld_${EMULATION_NAME}_after_open): Likewise.
	* emultempl/pep.em (pep_find_data_imports): Likewise.
	(gld_${EMULATION_NAME}_after_open): Likewise.
	* ldlang.h (lang_input_statement_type): Delete asymbols, symbol_count,
	passive_position, closed.
	* ldlang.c (new_afile): Don't set asymbols and symbol_count.
	* ldmain.c (add_archive_element): xcalloc lang_input_statement_type.
@
text
@d5059 1
a5059 1
      bfd_vma old_min_base, relro_end, maxpage;
a5061 1
      old_min_base = expld.dataseg.min_base;
d5063 7
d5075 1
a5075 1
      if (old_min_base + maxpage < expld.dataseg.base)
d5086 2
a5087 1
	     inserted at DATA_SEGMENT_RELRO_END.  Try some other base.  */
d5101 1
a5101 2
	      if (expld.dataseg.base - (1 << max_alignment_power)
		  < old_min_base)
@


1.289
log
@        * ldlang.c (print_output_section_statement): If the output section
        statement has an update_dot_tree expression, apply it to
        print_dot.
        (print_input_section): Do not update print_dot if it would move
        print_dot backwards.
        (lang_do_assignments_1): If the output section statement has an
        update_dot_tree expression apply it to dot.

  * ld-scripts/overlay-size.t (end_of_bss_overlays): Define.
  (end_of_text_overlays): Define.
  (end_of_data_overlays): Define.
  * ld-scripts/overlay-size-map.d: Add expected values for
  end_of_bss_overlays, end_of_text_overlays and
  end_of_data_overlays.
@
text
@a1035 1
  p->asymbols = NULL;
a1037 1
  p->symbol_count = 0;
@


1.288
log
@	* NEWS: Mention archive:path patterns.
	* ld.texinfo: Likewise.
	* ldlang.c: Formatting throughout.
	(archive_path): Only assume "[A-Za-z]:" is a dos drive.
	(input_statement_is_archive_path): New function, extracted from..
	(walk_wild): ..here.
	(walk_wild_consider_section): Match archive:path here too.
	(init_map_userdata, sort_def_symbol): Convert to ISO C.
	* ldmain.c (main): Set link_info.path_separator.
	* emultempl/spuelf.em (choose_target): Don't set it here.
@
text
@d3656 4
d3906 5
a3910 1
      print_dot = addr + TO_ADDR (size);
d5162 3
@


1.287
log
@include/
	* bfdlink.h (struct bfd_link_info): Add "path_separator".
bfd/
	* elf32-spu.c (spu_elf_auto_overlay): Relax requirement that
	file names be unique.  Specify archive:path in overlay script.
ld/
	* ldlang.c (name_match): New function.
	(unique_section_p, walk_wild_consider_section): Use it here.
	(walk_wild_section_general): And here.
	(archive_path): New function.
	(walk_wild): Match archive:path filespecs.
	(open_input_bfds): Don't load archive:path files.
	* emultempl/spuelf.em (choose_target): Set path_separator.
	* emulparams/elf32_spu.sh: Add ._ea.* sections to ._ea output.
@
text
@d163 1
a163 1
  if (p == pattern + 1)
d169 27
a229 1
  bfd_boolean skip = FALSE;
d237 1
a237 1
      skip = name_match (list_tmp->name, file->filename) == 0;
d239 1
a239 5
      /* If this file is part of an archive, and the archive is
	 excluded, exclude this file.  */
      if (! skip && file->the_bfd != NULL
	  && file->the_bfd->my_archive != NULL
	  && file->the_bfd->my_archive->filename != NULL)
d241 2
a242 2
	  skip = name_match (list_tmp->name,
			     file->the_bfd->my_archive->filename) == 0;
d245 11
a255 2
      if (skip)
	break;
d258 1
a258 2
  if (!skip)
    (*callback) (ptr, sec, s, file, data);
d842 2
a843 17
	  if ((*(p + 1) == 0
	       || name_match (p + 1, f->filename) == 0)
	      && ((p != file_spec)
		  == (f->the_bfd != NULL && f->the_bfd->my_archive != NULL)))
	    {
	      bfd_boolean skip = FALSE;

	      if (p != file_spec)
		{
		  const char *aname = f->the_bfd->my_archive->filename;
		  *p = 0;
		  skip = name_match (file_spec, aname) != 0;
		  *p = link_info.path_separator;
		}
	      if (!skip)
		walk_wild_file (s, f, callback, data);
	    }
d1891 3
a1893 4
init_map_userdata (abfd, sec, data)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     void *data ATTRIBUTE_UNUSED;
d1905 2
a1906 3
sort_def_symbol (hash_entry, info)
     struct bfd_link_hash_entry *hash_entry;
     void *info ATTRIBUTE_UNUSED;
d2509 1
a2509 1
	  einfo (_("%F%B: file not recognized: %E\n"), entry->the_bfd);
d2757 1
a2757 1
  if (   strcmp (target->name, "elf32-big") == 0
d3191 22
a3212 22
      {
      case lang_wild_statement_enum:
	walk_wild (&s->wild_statement, check_section_callback,
		   output_section_statement);
	if (! output_section_statement->all_input_readonly)
	  return;
	break;
      case lang_constructors_statement_enum:
	check_input_sections (constructor_list.head,
			      output_section_statement);
	if (! output_section_statement->all_input_readonly)
	  return;
	break;
      case lang_group_statement_enum:
	check_input_sections (s->group_statement.children.head,
			      output_section_statement);
	if (! output_section_statement->all_input_readonly)
	  return;
	break;
      default:
	break;
      }
a3369 1

d3434 1
a3434 1
	      do 
d3793 3
a3795 4
  if ((statm->filename != NULL)
       && ((statm->the_bfd == NULL)
	   ||
	   ((statm->the_bfd->flags & BFD_LINKER_CREATED) == 0)))
d5061 2
a5062 2
      relro_end = (expld.dataseg.relro_end + expld.dataseg.pagesize - 1)
		  & ~(expld.dataseg.pagesize - 1);
d5500 7
a5506 7
        {
          for (power = 4; power > 0; power--)
  	    bfd_link_hash_traverse (link_info.hash, lang_one_common, &power);
  	    
  	  power = 0;
          bfd_link_hash_traverse (link_info.hash, lang_one_common, &power);
        }
d5508 3
a5510 3
        {
          for (power = 0; power <= 4; power++)
            bfd_link_hash_traverse (link_info.hash, lang_one_common, &power);
d5512 1
a5512 1
      	  power = UINT_MAX;
d5537 1
a5537 1
           && power_of_two > *(unsigned int *) info)
d5815 3
a5817 3
   os = lang_output_section_statement_lookup_1 (output_section_statement_name,
						constraint);
   current_section = os;
d6962 38
a6999 38
	  case 0:
	    if (head->mask & BFD_ELF_VERSION_C_TYPE)
	      {
		e.symbol = sym;
		expr = htab_find (head->htab, &e);
		while (expr && strcmp (expr->symbol, sym) == 0)
		  if (expr->mask == BFD_ELF_VERSION_C_TYPE)
		    goto out_ret;
		  else
		    expr = expr->next;
	      }
	    /* Fallthrough */
	  case BFD_ELF_VERSION_C_TYPE:
	    if (head->mask & BFD_ELF_VERSION_CXX_TYPE)
	      {
		e.symbol = cxx_sym;
		expr = htab_find (head->htab, &e);
		while (expr && strcmp (expr->symbol, cxx_sym) == 0)
		  if (expr->mask == BFD_ELF_VERSION_CXX_TYPE)
		    goto out_ret;
		  else
		    expr = expr->next;
	      }
	    /* Fallthrough */
	  case BFD_ELF_VERSION_CXX_TYPE:
	    if (head->mask & BFD_ELF_VERSION_JAVA_TYPE)
	      {
		e.symbol = java_sym;
		expr = htab_find (head->htab, &e);
		while (expr && strcmp (expr->symbol, java_sym) == 0)
		  if (expr->mask == BFD_ELF_VERSION_JAVA_TYPE)
		    goto out_ret;
		  else
		    expr = expr->next;
	      }
	    /* Fallthrough */
	  default:
	    break;
d7028 1
a7028 1
out_ret:
@


1.286
log
@            PR ld/6430
            * testsuite/ld-elfcomm/elfcomm.exp (test_sort_common): Test the
            ascending/descending argument to the --sort-common command line
            option.
            * testsuite/ld-elfcomm/sort-common.s: New file.
            * ld.h (enum sort_order): New.
            * ldlang.c (lang_check: Fix comment.
            (lang_common): Sort commons in ascending or descending order.
            (lang_one_common): Likewise.
            * lexsup.c (ld_options): Have --sort-common take an option
            argument.
            (parse_args): Handle argument to --sort-common.
            * ld.texinfo (--sort-common): Document new optional argument.
            * NEWS: Mention new feature.
@
text
@d137 32
d182 2
a183 6
    if (wildcardp (unam->name)
	? fnmatch (unam->name, secnam, 0) == 0
	: strcmp (unam->name, secnam) == 0)
      {
	return TRUE;
      }
d206 1
a206 2
  /* Don't process sections from files which were
     excluded.  */
d211 1
a211 5
      bfd_boolean is_wildcard = wildcardp (list_tmp->name);
      if (is_wildcard)
	skip = fnmatch (list_tmp->name, file->filename, 0) == 0;
      else
	skip = strcmp (list_tmp->name, file->filename) == 0;
d219 2
a220 7
	  if (is_wildcard)
	    skip = fnmatch (list_tmp->name,
			    file->the_bfd->my_archive->filename,
			    0) == 0;
	  else
	    skip = strcmp (list_tmp->name,
			   file->the_bfd->my_archive->filename) == 0;
d257 1
a257 4
	      if (wildcardp (sec->spec.name))
		skip = fnmatch (sec->spec.name, sname, 0) != 0;
	      else
		skip = strcmp (sec->spec.name, sname) != 0;
d798 1
d808 23
d2973 2
a2974 1
	      && ! wildcardp (s->wild_statement.filename))
@


1.285
log
@        bfd/
        * elf32-arm.c (THM2_MAX_FWD_BRANCH_OFFSET): Define.
        (THM2_MAX_BWD_BRANCH_OFFSET): Define.
        (ARM_MAX_FWD_BRANCH_OFFSET): Define.
        (ARM_MAX_BWD_BRANCH_OFFSET): Define.
        (THM_MAX_FWD_BRANCH_OFFSET): Define.
        (THM_MAX_BWD_BRANCH_OFFSET): Define.
        (arm_long_branch_stub): Define.
        (arm_pic_long_branch_stub): Define.
        (arm_thumb_v4t_long_branch_stub): Define.
        (arm_thumb_thumb_long_branch_stub): Define.
        (arm_thumb_arm_v4t_long_branch_stub): Define.
        (STUB_SUFFIX): Define.
        (elf32_arm_stub_type): Define.
        (elf32_arm_stub_hash_entry): Define.
        (elf32_arm_link_hash_entry): Add stub_cache field.
        (arm_stub_hash_lookup): Define.
        (elf32_arm_link_hash_table): Add stub_hash_table, stub_bfd,
        add_stub_section, layout_sections_again, stub_group, bfd_count,
        top_index, input_list fields.
        (elf32_arm_link_hash_newfunc): Init new field.
        (stub_hash_newfunc): New function.
        (elf32_arm_link_hash_table_create): Init stub_hash_table.
        (elf32_arm_hash_table_free): New function.
        (arm_type_of_stub): New function.
        (elf32_arm_stub_name): New function.
        (elf32_arm_get_stub_entry): New function.
        (elf32_arm_stub_add_mapping_symbol): New function.
        (elf32_arm_add_stub): New function.
        (arm_build_one_stub): New function.
        (arm_size_one_stub): New function.
        (elf32_arm_setup_section_lists): New function.
        (elf32_arm_next_input_section): New function.
        (group_sections): New function.
        (elf32_arm_size_stubs): New function.
        (elf32_arm_build_stubs): New function.
        (bfd_elf32_arm_add_glue_sections_to_bfd): Skip stub sections.
        (bfd_elf32_arm_process_before_allocation): No longer handle
        R_ARM_CALL and R_ARM_THM_CALL.
        (using_thumb_only): New function.
        (elf32_arm_final_link_relocate): Redirect calls to stub if range
        exceeds encoding capabilities.
        (bfd_elf32_bfd_link_hash_table_free): Define.
        * bfd-in.h (R_ARM_max): Fix value to 130.
        (elf32_arm_setup_section_lists): Protype.
        (elf32_arm_next_input_section): Protype.
        (elf32_arm_size_stubs): Protype.
        (elf32_arm_build_stubs): Protype.

        ld/
        * emultempl/armelf.em (build_section_lists): New function.
        (stub_file): Define.
        (need_laying_out): Define.
        (group_size): Define.
        (hook_stub_info): Define.
        (hook_in_stub): New function.
        (elf32_arm_add_stub_section): New function.
        (gldarm_layout_sections_again): New function.
        (gld${EMULATION_NAME}_finish): Replace arm_elf_finish(). Generate
        stubs for long calls if needed.
        (arm_elf_create_output_section_statements): create stub_file bfd.
        (arm_for_each_input_file_wrapper): New function.
        (arm_lang_for_each_input_file): New function.
        (lang_for_each_input_file): Define.
        (PARSE_AND_LIST_PROLOGUE): Add option token OPTION_STUBGROUP_SIZE.
        (PARSE_AND_LIST_LONGOPTS): Add option stub-group-size.
        (PARSE_AND_LIST_OPTIONS): Add option stub-group-size.
        (PARSE_AND_LIST_ARGS_CASES): Add OPTION_STUBGROUP_SIZE case.
        (LDEMUL_FINISH): Update to gld${EMULATION_NAME}_finish.
        * ld/lang.c (print_input_statement): Skip if bfd has
        BFD_LINKER_CREATED.

        ld/testsuite
        * ld-arm/arm-elf.exp (armelftests): Add farcall-arm-arm,
        farcall-arm-arm-pic-veneer, farcall-arm-arm-be8 farcall-arm-thumb,
        farcall-arm-thumb-blx, farcall-arm-thumb-pic-veneer,
        farcall-arm-thumb-blx-pic-veneer, farcall-thumb-thumb,
        farcall-thumb-thumb-pic-veneer, farcall-thumb-thumb-blx,
        farcall-thumb-thumb-m, farcall-thumb-thumb-m-pic-veneer,
        farcall-thumb-thumb-blx-pic-veneer, farcall-thumb-arm,
        farcall-thumb-arm-pic-veneer, farcall-thumb-arm-blx,
        farcall-thumb-arm-blx-pic-veneer.
        Change thumb2-bl-as-thumb1-bad, thumb2-bl-bad.
        * ld-arm/thumb2-bl-as-thumb1-bad.d: Reflects farcall stub
        generation.
        * ld-arm/thumb2-bl-bad.d: Likewise.
        * ld-arm/thumb2-bl-as-thumb1-bad.s: Update comments.
        * ld-arm/thumb2-bl-bad.s: Likewise.
@
text
@d23 2
d2704 7
d5431 1
a5431 1
   to roughly sort the entries by size.  */
d5446 1
a5446 1
      int power;
d5448 16
a5463 2
      for (power = 4; power >= 0; power--)
	bfd_link_hash_traverse (link_info.hash, lang_one_common, &power);
d5482 5
a5486 2
  if (config.sort_common
      && power_of_two < (unsigned int) *(int *) info)
@


1.284
log
@ld/
	* ldlang.c (lang_size_sections_1): Don't check LMA overflow on
	non-load sections.
ld/testsuite/
	* ld-scripts/rgn-over.exp: Allow -ok file names to pass.
	* ld-scripts/rgn-over8.s: New.
	* ld-scripts/rgn-over8.t: New.
	* ld-scripts/rgn-over8-ok.d: New.
@
text
@d3732 5
a3736 4
  if (statm->filename != NULL)
    {
      fprintf (config.map_file, "LOAD %s\n", statm->filename);
    }
d4189 2
a4190 2
      && pad->header.type == lang_padding_statement_enum
      && pad->padding_statement.output_section == output_section)
@


1.283
log
@        PR ld/5785
        * ldlang.c (lang_size_sections_1): Honour the setting of an
        lma_region even if there is no vma region set, or the vma region
        is the same as the lma region.
@
text
@d4702 2
a4703 1
		if (os->lma_region != NULL && os->lma_region != os->region)
@


1.282
log
@include/
	* bfdlink.h (struct bfd_link_hash_table): Delete creator field.
	(struct bfd_link_info): Add output_bfd.
bfd/
	* elflink.c: Replace all accesses to hash->creator field with
	output_bfd->xvec.
	* cofflink.c: Likewise.
	* coff-h8300.c: Likewise.
	* ecoff.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfxx-mips.c: Likewise.
	* i386linux.c: Likewise.
	* m68klinux.c: Likewise.
	* sparclinux.c: Likewise.
	* sunos.c: Likewise.
	* xcofflink.c: Likewise.
	* linker.c: Likewise.
	(_bfd_link_hash_table_init): Don't store creator.
ld/
	* ldmain.h (output_bfd): Delete.
	* ldmain.c (output_bfd): Delete.
	Replace all occurrences of output_bfd with link_info.output_bfd.
	* ldcref.c: Likewise.
	* ldctor.c: Likewise.
	* ldemul.c: Likewise.
	* ldexp.c: Likewise.
	* ldfile.c: Likewise.
	* ldlang.c: Likewise.
	* ldmisc.c: Likewise.
	* ldwrite.c: Likewise.
	* pe-dll.c: Likewise.
	* emultempl/aix.em: Likewise.
	* emultempl/alphaelf.em: Likewise.
	* emultempl/armcoff.em: Likewise.
	* emultempl/armelf.em: Likewise.
	* emultempl/avrelf.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/elf-generic.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/irix.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68hc1xelf.em: Likewise.
	* emultempl/mmix-elfnmmo.em: Likewise.
	* emultempl/mmo.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/scoreelf.em: Likewise.
	* emultempl/sh64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/vanilla.em: Likewise.
	* emultempl/vxworks.em: Likewise.
	* emultempl/xtensaelf.em: Likewise.
	* emultempl/z80.em: Likewise.
	* ldlang.c (open_output): Don't return output, instead write
	link_info_output_bfd directly.
	* emultempl/alphaelf.em: Replace occurrences of link_info.hash->creator
	with link_info.output_bfd->xvec.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
@
text
@d4597 1
a4597 3
	    else if (os->region != NULL
		     && os->lma_region != NULL
		     && os->lma_region != os->region)
@


1.281
log
@	* ldlang.c (new_afile): Don't pass unadorned NULL to concat.
	* ldfile.c (ldfile_add_library_path): Likewise.
	* emultempl/elf32.em (check_ld_elf_hints, check_ld_so_conf): Likewise.
	* emultempl/lnk960.em (lnk960_before_parse): Likewise.
	* emultempl/spuelf.em (embedded_spu_file): Likewise.
@
text
@d1315 2
a1316 1
	  if (match_type && !match_type (output_bfd, look->bfd_section,
d1341 2
a1342 1
	      if (match_type && !match_type (output_bfd, look->bfd_section,
d1361 2
a1362 1
	      if (match_type && !match_type (output_bfd, look->bfd_section,
d1382 2
a1383 1
	      if (match_type && !match_type (output_bfd, look->bfd_section,
d1404 2
a1405 1
	      if (match_type && !match_type (output_bfd, look->bfd_section,
d1424 2
a1425 1
	      if (match_type && !match_type (output_bfd, look->bfd_section,
d1569 1
a1569 1
	  symname[0] = bfd_get_symbol_leading_char (output_bfd);
d1604 1
a1604 1
      symname[0] = bfd_get_symbol_leading_char (output_bfd);
d1641 1
a1641 1
	place->section = &output_bfd->sections;
d1650 1
a1650 1
	  bfd_section_list_remove (output_bfd, snew);
d1653 1
a1653 1
	  bfd_section_list_append (output_bfd, snew);
d1658 1
a1658 1
	  bfd_section_list_remove (output_bfd, snew);
d1661 1
a1661 1
	  bfd_section_list_insert_before (output_bfd, as, snew);
d1766 1
a1766 1
	     || s->output_section->owner != output_bfd)
d1891 1
a1891 1
  s->bfd_section = bfd_get_section_by_name (output_bfd, s->name);
d1893 2
a1894 2
    s->bfd_section = bfd_make_section_with_flags (output_bfd, s->name,
						  flags);
d1898 1
a1898 1
	     output_bfd->xvec->name, s->name);
d1925 1
a1925 1
				   output_bfd, s->bfd_section,
d2772 1
a2772 1
static bfd *
a2774 2
  bfd *output;

d2826 1
a2826 1
  output = bfd_openw (name, output_target);
d2828 1
a2828 1
  if (output == NULL)
d2838 1
a2838 1
  if (! bfd_set_format (output, bfd_object))
d2840 1
a2840 1
  if (! bfd_set_arch_mach (output,
d2845 1
a2845 1
  link_info.hash = bfd_link_hash_table_create (output);
d2849 1
a2849 2
  bfd_set_gp_size (output, g_switch_value);
  return output;
d2858 2
a2859 2
      ASSERT (output_bfd == NULL);
      output_bfd = open_output (statement->output_statement.name);
d2862 1
a2862 1
	output_bfd->flags |= D_PAGED;
d2864 1
a2864 1
	output_bfd->flags &= ~D_PAGED;
d2866 1
a2866 1
	output_bfd->flags |= WP_TEXT;
d2868 1
a2868 1
	output_bfd->flags &= ~WP_TEXT;
d2870 1
a2870 1
	output_bfd->flags |= BFD_TRADITIONAL_FORMAT;
d2872 1
a2872 1
	output_bfd->flags &= ~BFD_TRADITIONAL_FORMAT;
d3084 1
a3084 1
  if (output_bfd != NULL)
d3452 1
a3452 1
			output_bfd->sections = last_sec->next;
d3456 1
a3456 1
			output_bfd->section_last = first_sec->prev;
d3462 1
a3462 1
			output_bfd->section_last = last_sec;
d3522 1
a3522 1
		 && !bfd_section_removed_from_list (output_bfd,
d3554 2
a3555 2
	  bfd_section_list_remove (output_bfd, output_section);
	  output_bfd->section_count--;
d3805 2
a3806 1
  if (i->output_section != NULL && i->output_section->owner == output_bfd)
d3833 2
a3834 1
  if (i->output_section != NULL && i->output_section->owner == output_bfd)
d4308 1
a4308 1
  if (bfd_count_sections (output_bfd) <= 1)
d4311 1
a4311 1
  amt = bfd_count_sections (output_bfd) * sizeof (asection *);
d4316 1
a4316 1
  for (s = output_bfd->sections; s != NULL; s = s->next)
d4334 1
a4334 1
  s_start = bfd_section_lma (output_bfd, s);
d4345 1
a4345 1
      s_start = bfd_section_lma (output_bfd, s);
d4453 4
a4456 2
	    if ((bfd_get_flavour (output_bfd) == bfd_target_ecoff_flavour
		 || bfd_get_flavour (output_bfd) == bfd_target_coff_flavour)
d4526 1
a4526 1
				 bfd_get_section_name (output_bfd,
d4531 1
a4531 1
				 bfd_get_section_name (output_bfd,
d5020 1
a5020 1
	  for (sec = output_bfd->sections; sec; sec = sec->next)
d5219 1
a5219 1
  for (s = output_bfd->sections; s != NULL; s = s->next)
d5225 1
a5225 1
      secname = bfd_get_section_name (output_bfd, s);
d5233 1
a5233 1
	  h->u.def.value = bfd_get_section_vma (output_bfd, s);
d5288 1
a5288 1
	     + bfd_get_section_vma (output_bfd,
d5291 1
a5291 1
      if (! bfd_set_start_address (output_bfd, val))
d5304 1
a5304 1
	  if (! bfd_set_start_address (output_bfd, val))
d5313 1
a5313 1
	  ts = bfd_get_section_by_name (output_bfd, entry_section);
d5320 4
a5323 4
		       bfd_get_section_vma (output_bfd, ts));
	      if (! bfd_set_start_address (output_bfd,
					   bfd_get_section_vma (output_bfd,
								ts)))
d5364 1
a5364 1
	= bfd_arch_get_compatible (input_bfd, output_bfd,
d5375 2
a5376 1
	      || bfd_get_flavour (input_bfd) != bfd_get_flavour (output_bfd))
d5382 1
a5382 1
		 bfd_get_target (output_bfd), output_bfd);
d5392 1
a5392 1
		   bfd_printable_name (output_bfd));
d5408 1
a5408 1
	  if (! bfd_merge_private_bfd_data (input_bfd, output_bfd))
d5500 1
a5500 1
      name = bfd_demangle (output_bfd, h->root.string,
d5675 1
a5675 1
  ASSERT (entry->the_bfd != output_bfd);
d5797 1
a5797 1
  for (o = output_bfd->sections; o != NULL; o = o->next)
d5869 1
a5869 1
    bfd_gc_sections (output_bfd, &link_info);
d5884 1
a5884 1
      && section->output_section->owner == output_bfd
d6054 1
a6054 1
      bfd_merge_sections (output_bfd, &link_info);
d6057 1
a6057 1
      found = bfd_get_section_by_name (output_bfd, ".text");
d6387 1
a6387 1
      sec = bfd_get_section_by_name (output_bfd, secname);
d6391 1
a6391 1
	h->u.def.value = bfd_get_section_vma (output_bfd, sec);
d6418 1
a6418 1
      sec = bfd_get_section_by_name (output_bfd, secname);
d6422 1
a6422 1
	h->u.def.value = (bfd_get_section_vma (output_bfd, sec)
d6616 1
a6616 1
      if (! bfd_record_phdr (output_bfd, l->type,
@


1.280
log
@2008-01-25  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/5670
	* ldlang.c (process_insert_statements): Silence gcc 4.1 alias
	warning.
@
text
@d947 1
a947 1
      p->local_sym_name = concat ("-l", name, NULL);
@


1.279
log
@ld/
	* ld.texinfo (INSERT): Describe.
	* ldgram.y (ldgram_in_script, ldgram_had_equals): Delete.
	(INSERT_K, AFTER, BEFORE): Add as tokens.
	(ifile_p1): Handle INSERT statements.
	(saved_script_handle, force_make_executable): Move to..
	* ldmain.c: ..here.
	(previous_script_handle): New global var.
	* ldmain.h (saved_script_handle, force_make_executable): Declare.
	(previous_script_handle): Likewise.
	* ldlex.l (INSERT_K, AFTER, BEFORE): Add tokens.
	* lexsup.c (parge_args <-T>): Set previous_script_handle.
	* ldlang.c (lang_for_each_statement_worker): Handle insert statement.
	(map_input_to_output_sections, print_statement): Likewise.
	(lang_size_sections_1, lang_do_assignments_1): Likewise.
	(insert_os_after): New function, extracted from..
	(lang_insert_orphan): ..here.
	(process_insert_statements): New function.
	(lang_process): Call it.
	(lang_add_insert): New function.
	* ldlang.h (lang_insert_statement_enum): New.
	(lang_insert_statement_type): New.
	(lang_statement_union_type): Add insert_statement.
	(lang_add_insert): Declare.
ld/testsuite/
	* ld-spu/ovl.lnk: Delete overlay.
	* ld-spu/ovl1.lnk: New file.
	* ld-spu/ovl2.lnk: New file.
	* ld-spu/ovl.d: Update.
	* ld-spu/ovl2.d: Update.
@
text
@d3393 1
d3398 5
a3402 2
		lang_output_section_statement.tail
		  = (union lang_statement_union **) &first_os->prev->next;
d3408 5
a3412 2
		lang_output_section_statement.tail
		  = (union lang_statement_union **) &last_os->next;
@


1.278
log
@	* ldlang.c (lang_size_sections_1): Simplify SEC_NEVER_LOAD test.
@
text
@d848 1
d1455 67
d1677 1
a1677 58
	      lang_statement_union_type **where;
	      lang_statement_union_type **assign = NULL;
	      bfd_boolean ignore_first;

	      /* Look for a suitable place for the new statement list.
		 The idea is to skip over anything that might be inside
		 a SECTIONS {} statement in a script, before we find
		 another output_section_statement.  Assignments to "dot"
		 before an output section statement are assumed to
		 belong to it.  An exception to this rule is made for
		 the first assignment to dot, otherwise we might put an
		 orphan before . = . + SIZEOF_HEADERS or similar
		 assignments that set the initial address.  */

	      ignore_first = after == (&lang_output_section_statement.head
				       ->output_section_statement);
	      for (where = &after->header.next;
		   *where != NULL;
		   where = &(*where)->header.next)
		{
		  switch ((*where)->header.type)
		    {
		    case lang_assignment_statement_enum:
		      if (assign == NULL)
			{
			  lang_assignment_statement_type *ass;
			  ass = &(*where)->assignment_statement;
			  if (ass->exp->type.node_class != etree_assert
			      && ass->exp->assign.dst[0] == '.'
			      && ass->exp->assign.dst[1] == 0
			      && !ignore_first)
			    assign = where;
			}
		      ignore_first = FALSE;
		      continue;
		    case lang_wild_statement_enum:
		    case lang_input_section_enum:
		    case lang_object_symbols_statement_enum:
		    case lang_fill_statement_enum:
		    case lang_data_statement_enum:
		    case lang_reloc_statement_enum:
		    case lang_padding_statement_enum:
		    case lang_constructors_statement_enum:
		      assign = NULL;
		      continue;
		    case lang_output_section_statement_enum:
		      if (assign != NULL)
			where = assign;
		      break;
		    case lang_input_statement_enum:
		    case lang_address_statement_enum:
		    case lang_target_statement_enum:
		    case lang_output_statement_enum:
		    case lang_group_statement_enum:
		      continue;
		    }
		  break;
		}
d3326 148
d4116 5
d4901 1
a4901 2
	default:
	  FAIL ();
d4907 4
d5169 1
a5169 2
	default:
	  FAIL ();
d5174 4
d6026 2
d6444 11
@


1.277
log
@	* ldlang.h (lang_afile_asection_pair_statement_enum): Delete.
	(lang_afile_asection_pair_statement_type): Delete.
	(lang_statement_union_type): Delete afile_asection_pair_statement.
	* ldlang.c (lang_insert_orphan): Delete case handling the above.
	(map_input_to_output_sections, print_statement): Likewise.
@
text
@d4705 1
a4705 2
		    if (!(output_section_statement->flags
			  & (SEC_NEVER_LOAD | SEC_ALLOC)))
@


1.276
log
@bfd/
	PR 5604
	* elf-bfd.h (struct elf_backend_data): Add gc_keep.  Remove param
	names from others.
	(_bfd_elf_gc_keep): Declare.
	* elfxx-target.h (elf_backend_gc_keep): Define.
	(elfNN_bed): Init new field.
	* elflink.c (_bfd_elf_gc_keep): New function.
	(bfd_elf_gc_sections): Call gc_keep.
	* elf64-ppc.c (elf_backend_gc_keep): Define.
	(struct _ppc64_elf_section_data): Move .opd related fields to
	a struct so they don't occupy the same storage.  Adjust accesses
	throughout file.
	(ppc64_elf_gc_keep): New function, split out from..
	(ppc64_elf_gc_mark_hook): ..here.  Don't call _bfd_elf_gc_mark
	to mark .opd section, just set gc_mark.
	(ppc64_elf_edit_opd): Remove no_opd_opt parm.  Don't set opd->adjust
	unless we are changing .opd.  Test non-NULL opd->adjust at all
	accesses throughout file.
	* elf64-ppc.h (ppc64_elf_edit_opd): Update prototype.
ld/
	PR 5604
	* ldlang.c (lang_gc_sections): Move code to set SEC_KEEP on entry
	syms to _bfd_elf_gc_keep.
	* emultempl/ppc64elf.em (ppc_before_allocation): Don't call
	ppc64_elf_edit_opd if no_opd_opt.
@
text
@a1662 1
		    case lang_afile_asection_pair_statement_enum:
a3291 3
	case lang_afile_asection_pair_statement_enum:
	  FAIL ();
	  break;
a3956 3
    case lang_afile_asection_pair_statement_enum:
      FAIL ();
      break;
@


1.275
log
@ld:
2008-01-11  Tristan Gingold  <gingold@@adacore.com>
	    Eric Botcazou  <ebotcazou@@adacore.com>

	* ldlang.c (lang_end): Warns if the entry point is not found when
	--gc-sections.
	Emit an error if no root is specified when --gc-sections -r.
	* ld.texinfo (Options): Document that --gc-sections is compatible
	with -r and -q.
	* ldmain.c (main): Do not error out if -r and --gc-sections.
	* scripttempl/elf.sc: Emit ENTRY command only if relocating.

ld/testsuite:
2008-01-11  Tristan Gingold  <gingold@@adacore.com>

	* lib/ld-lib.exp (check_gc_sections_available): Now available on
	VxWorks.
	* ld-gc: New directory for testing --gc-sections.
	* ld-gc/gc.c: New file.
	* ld-gc/gc.exp: New file.
	* ld-gc/noent.s: New file.
	* ld-gc/noent.d: New file.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007
a5672 3
  struct bfd_link_hash_entry *h;
  ldlang_undef_chain_list_type *ulist;

a5676 17
  /* Keep all sections containing symbols undefined on the command-line,
     and the section containing the entry symbol.  */

  for (ulist = link_info.gc_sym_list; ulist; ulist = ulist->next)
    {
      h = bfd_link_hash_lookup (link_info.hash, ulist->name,
				FALSE, FALSE, FALSE);

      if (h != NULL
	  && (h->type == bfd_link_hash_defined
	      || h->type == bfd_link_hash_defweak)
	  && ! bfd_is_abs_section (h->u.def.section))
	{
	  h->u.def.section->flags |= SEC_KEEP;
	}
    }

@


1.274
log
@        PR ld/5533
        * ldlang.c (lang_end): Issue a warning for a missing start symbol
        of a shared library if the symbol was specified on the command
        line.
@
text
@d5080 2
a5081 1
  if (link_info.relocatable || link_info.shared)
d5086 8
@


1.273
log
@2007-10-17  Zack Weinberg  <zack@@codesourcery.com>

	* ldlang.c (lang_check_section_addresses): Also report size of
	overflow for any overflowed memory regions.
	(os_region_check): Diagnose an overflowed region only once per
	region.  Do not reset region->current on overflow.

2007-10-17  Zack Weinberg  <zack@@codesourcery.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>
	    Mark Shinwell  <shinwell@@codesourcery.com>
	    Joseph Myers  <joseph@@codesourcery.com>

	* ld-scripts/rgn-over.exp: New driver.
	* ld-scripts/rgn-over.s: New file.
	* ld-scripts/rgn-over1.d, ld-scripts/rgn-over1.t,
	ld-scripts/rgn-over2.d, ld-scripts/rgn-over2.t,
	ld-scripts/rgn-over3.d, ld-scripts/rgn-over3.t,
	ld-scripts/rgn-over4.d, ld-scripts/rgn-over4.t,
	ld-scripts/rgn-over5.d, ld-scripts/rgn-over5.t,
	ld-scripts/rgn-over6.d, ld-scripts/rgn-over6.t,
	ld-scripts/rgn-over7.d, ld-scripts/rgn-over7.t:
	New test cases.
@
text
@d5081 1
a5081 1
    warn = FALSE;
@


1.272
log
@bfd/

2007-09-17  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/3281
	PR binutils/5037
	* elf-bfd.h (elf_obj_tdata): Remove relro.

	* elf.c (get_program_header_size): Check info->relro instead
	of elf_tdata (abfd)->relro.
	(_bfd_elf_map_sections_to_segments): Likewise.
	(assign_file_positions_for_load_sections): Don't set
	PT_GNU_RELRO segment alignment here.
	(assign_file_positions_for_non_load_sections): Properly set up
	PT_GNU_RELRO segment for copying executable/shared library.
	(rewrite_elf_program_header): Remove PT_GNU_RELRO segment.
	(copy_elf_program_header): Set p_size and p_size_valid fields for
	PT_GNU_RELRO segment.

include/elf/

2007-09-17  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/3281
	PR binutils/5037
	* internal.h (elf_segment_map): Add p_size and p_size_valid.
	(ELF_IS_SECTION_IN_SEGMENT): Allow SHF_TLS sections in
	PT_GNU_RELRO segments.

ld/

2007-09-17  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/3281
	PR binutils/5037
	* ldexp.h (ldexp_control): Add relro, relro_start_stat and
	relro_end_stat.

	* ldexp.c (fold_binary): Set expld.dataseg.relro to
	exp_dataseg_relro_start or exp_dataseg_relro_end when
	seeing DATA_SEGMENT_ALIGN or DATA_SEGMENT_RELRO_END,
	respectively.

	* ldlang.c (lang_size_sections_1): Properly set
	expld.dataseg.relro_start_stat and
	expld.dataseg.relro_end_stat.
	(find_relro_section_callback): New function.
	(lang_find_relro_sections_1): Likewise.
	(lang_find_relro_sections): Likewise.
	(lang_process): Call lang_find_relro_sections for
	non-relocatable link.

ld/testsuite/

2007-09-17  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/3281
	PR binutils/5037
	* ld-elf/binutils.exp: Update "-z relro" tests to use relro1.s.
	Add "-z relro" tests with relro2.s.  Add "-z relro" tests with
	TLS for objcopy.

	* ld-elf/relro1.s: New file.
	* ld-elf/relro2.s: Likewise.
@
text
@d4123 2
a4124 1
   section addresses of the two sections.  */
d4137 1
d4186 14
d4227 1
a4227 1
      else
d4229 3
a4231 2
	  einfo (_("%X%P: region %s is full (%B section %s)\n"),
		 region->name,
d4233 2
a4234 1
		 os->bfd_section->name);
a4235 2
      /* Reset the region pointer.  */
      region->current = region->origin;
@


1.271
log
@* ldlang.c (lang_map): Increment lang_statement_iteration so that DEFINED() expressions are correctly computed.
* testsuite/ld-script/map-address.d,
* testsuite/ld-script/map-address.t: Add a test for testing DEFINED in map output.
@
text
@d4639 2
d4645 20
d5690 75
d5892 4
@


1.270
log
@	* ldlang.c (lang_record_phdrs): Give a fatal error if no sections
	assigned to phdrs.  Avoid multiple forward scans for a section
	with phdr assignment.
@
text
@d1814 1
d3543 1
a3543 1
	      value += expld.result.section->vma;
@


1.269
log
@bfd:
2007-08-28  Mark Shinwell  <shinwell@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>

	* elf32-arm.c (elf32_arm_compare_mapping): Compare first on vma,
	then on type.

binutils/testsuite:
2007-08-28  Mark Shinwell  <shinwell@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>

	* binutils-all/ar.exp (long_filenames): Delete temporary files on
	the host.
	* binutils-all/arm/objdump.exp: Only check "which $OBJDUMP" if
	host is local.
	* binutils-all/objcopy.exp: Use ${srecfile} to get the name of the
	srec file to be passed to binutils_run.
	(objcopy_test_readelf): Use remote_exec.
	* binutils-all/readelf.exp (readelf_find_size): Use remote_exec.
	(readelf_test): Likewise.
	(readelf_wi_test): Likewise.
	* lib/utils-lib.exp (run_dump_test): Only check "which $binary" if
	host is local.  Use remote_exec.  Use $tempfile not
	tmpdir/bintest.o.

gas:
2007-08-28  Mark Shinwell  <shinwell@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>

	* as.c (main): Flush stderr before printing listings to ensure
	consistent output order across platforms.

gas/testsuite:
2007-08-28  Mark Shinwell  <shinwell@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>

	* lib/gas-defs.exp (gas_version): Use remote_* functions instead
	of exec.
	(gas_host_run): New.
	(gas_run): Use gas_host_run.
	(gas_start): Likewise.
	(run_dump_test): Likewise.
	(objdump): Use gas_host_run.
	(objdump_start_no_subdir): Likewise.
	* lib/gas-dg.exp (gas-dg-test): Use "remote_file host delete".
	* lib/run: Remove.
	* gas/macros/macros.exp: Download app4b.s to host.
	* gas/i386/i386.exp (gas_64_check): Use gas_host_run.
	(gas_32_check): Likewise.
	* gas/maxq10/maxq10.exp (gas_64_check): Likewise
	(gas_32_check): Likewise.
	* gas/maxq20/maxq20.exp (gas_64_check): Likewise
	(gas_32_check): Likewise.
	* gas/sparc/sparc.exp (gas_64_check): Likewise.
	* gas/cfi/cfi.exp: Likewise.
	* gas/elf/elf.exp (run_list_test): Likewise.  Use temporary file
	for readelf output in place of pipe.
	* gas/all/gas.exp: Download incbin.dat to host.
	(do_comment): Allow \r\r\n.

ld:
2007-08-28  Mark Shinwell  <shinwell@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>

	* ldlang.c (sort_sections_by_lma): Sort by internal id after lma
	for stable sort.

ld/testsuite:
2007-08-28  Mark Shinwell  <shinwell@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>

	* ld-elfcomm/elfcomm.exp: Use run_host_cmd.  Only check "which
	$CC" if host is local.
	* ld-checks/checks.exp: Use run_host_cmd.
	* ld-elf/exclude.exp: Likewise.
	* ld-elf/elf.exp: Download merge.ld if host is remote.
	* ld-elf/binutils.exp (binutils_test): Use remote_exec.
	* ld-elf/tls_common.exp: Use run_host_cmd.
	* lib/ld-lib.exp (ld_version): Only check "which $ld" if host is
	local.  Use remote_exec.
	(run_host_cmd): New.
	(run_host_cmd_yesno): New.
	(default_ld_relocate): Use run_host_cmd_yesno.
	(default_ld_link): Likewise.
	(default_ld_simple_link): Use run_host_cmd.
	(default_ld_compile): Only check "which $ccprog" if host is local.
	Use remote_file and remote_exec.
	(default_ld_assemble): Only check "which $as" if host is local.
	Use run_host_cmd.
	(default_ld_nm): Use remote_exec, remote_upload and remote_file.
	(run_dump_test): Use remote_exec, remote_upload and remote_file.
	Only check "which $binary" if host is local.
	(run_ld_link_tests): Use remote_exec, remote_upload and
	remote_file.
	* ld-selective/selective.exp: Only check "which $CXX" if host is
	local.  Use remote_exec.
	* ld-scripts/phdrs.exp: Only check "which $objdump" if host is
	local.  Use run_host_cmd.
	* ld-scripts/phdrs2.exp: Likewise.
	* ld-scripts/weak.exp: Likewise.
	* ld-undefined/weak-undef.exp: Likewise.
	* ld-scripts/crossref.exp: Only check "which $CC" if host is local.
	Use run_host_cmd.
	* ld-scripts/map-address.exp: Upload map_address.map if host is
	remote.
	* ld-srec/srec.exp (run_srec_tests): Use run_host_cmd.  Only check
	"which $CC" and "which $CXX" if host is local.
	* ld-undefined/undefined.exp: Only check "which $CC" if host is
	local.  Use remote_file and run_host_cmd.
	* config/default.exp: Use remote_exec to create tmpdir.
@
text
@d6266 1
a6266 3
	      if (last)
		pl = last;
	      else
d6280 6
a6285 2
		      break;
		  pl = tmp_os->phdrs;
d6287 1
@


1.268
log
@ld/
	* ldlang.c (lang_insert_orphan): When searching through linker
	script to place an orphan, don't stop on statements that appear
	outside of SECTIONS.
	* emultempl/elf32.em (output_rel_find): Prefer read-only alloc
	sections over read/write alloc sections.
ld/testsuite/
	* ld-elf/weak-dyn-1.rd: Adjust.
@
text
@d4106 4
@


1.267
log
@	* ldlang.c (strip_excluded_output_sections): Don't ignore sections
	with update_dot_tree.
@
text
@d1657 1
d1664 1
a1664 1
		      break;
@


1.266
log
@	PR 4782
	* ldlang.c (lang_size_sections_1 <output_section_statement>): Only
	use expld.result when valid.
@
text
@d3383 2
a3384 1
	  if (!os->section_relative_symbol)
@


1.265
log
@Update sources to GPLv3
@
text
@d4245 3
a4247 2
		if (!expld.result.valid_p
		    && expld.phase != lang_mark_phase_enum)
a4250 2

		dot = expld.result.value + expld.result.section->vma;
@


1.264
log
@include/
	* bfdlink.h (struct bfd_link_info): Add input_bfds_tail.
bfd/
	* simple.c (bfd_simple_get_relocated_section_content): Init
	input_bfds_tail.
ld/
	* ldlang.c (ldlang_add_file): Use input_bfds_tail.
	* ldmain.c (main): Init input_bfds_tail.  Sort link_info
	initialization.
@
text
@d6 1
a6 1
   This file is part of GLD, the Gnu Linker.
d8 1
a8 1
   GLD is free software; you can redistribute it and/or modify
d10 2
a11 2
   the Free Software Foundation; either version 2, or (at your option)
   any later version.
d13 1
a13 1
   GLD is distributed in the hope that it will be useful,
d19 3
a21 3
   along with GLD; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */
@


1.263
log
@commit the Robert's removal of "warning:"
@
text
@a5437 2
  bfd **pp;

d5446 3
a5448 3
  for (pp = &link_info.input_bfds; *pp != NULL; pp = &(*pp)->link_next)
    ;
  *pp = entry->the_bfd;
@


1.262
log
@	* ldlang.c (lang_check): Error on architecture mismatch.
@
text
@d5159 1
a5159 1
	    einfo (_("%P%X: warning: %s architecture of input file `%B'"
@


1.261
log
@	* ldcref.c (struct cref_hash_entry): Make "demangled" const.
	(cref_fill_array): Adjust for changed demangler.
	* ldlang.c (lang_one_common): Likewise.
@
text
@d5159 1
a5159 1
	    einfo (_("%P: warning: %s architecture of input file `%B'"
@


1.260
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d5272 11
a5282 3
      minfo ("%s", name);
      len = strlen (name);
      free (name);
@


1.259
log
@	* ldcref.c (cref_fill_array): Call bfd_demangle rather than demangle.
	* ldlang.c (lang_one_common): Likewise.
	* ldmisc.c (vfinfo): Likewise.
	(demangle): Delete.
	* ldmisc.h (demangle): Delete.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
@
text
@d23 1
a24 1
#include "sysdep.h"
@


1.258
log
@ld/
	* ldlang.h (enum section_type): Add overlay_section.
	* ldlang.c (lang_add_section): Handle flags for overlay_section
	as per normal_section.
	(lang_size_sections_1): When setting lma, detect overlays by
	os->sectype rather than by looking for overlapping vmas.
	(lang_enter_overlay_section): Use overlay_section type.
	(lang_leave_overlay): Set first overlay section to normal.
ld/testsuite/
	* ld-spu/ovl.lnk: Use OVERLAY keyword.
@
text
@d5270 2
a5271 1
      name = demangle (h->root.string);
@


1.257
log
@bfd/
        * elf64-alpha.c (struct alpha_elf_link_hash_table): Add relax_trip.
        (elf64_alpha_size_got_sections): Remove unused something_changed local.
        (elf64_alpha_size_plt_section): Return void.
        (elf64_alpha_size_rela_got_section): Likewise.
        (elf64_alpha_relax_section): Only regenerate got+plt if the
        relax_trip counter has changed.
include/
        * bfdlink.h (struct bfd_link_info): Add relax_trip.
ld/
        * ldlang.c (relax_sections): Initialize and increment
        link_info.relax_trip.
@
text
@d2043 1
d4442 3
a4444 8
		    /* If the current vma overlaps the previous section,
		       then set the current lma to that at the end of
		       the previous section.  The previous section was
		       probably an overlay.  */
		    if ((dot >= last->vma
			 && dot < last->vma + last->size)
			|| (last->vma >= dot
			    && last->vma < dot + os->bfd_section->size))
d6391 1
a6391 1
  lang_enter_output_section_statement (name, overlay_vma, normal_section,
d6505 4
a6508 1
	l->os->load_base = lma_expr;
@


1.256
log
@ld/
200x-xx-xx  Richard Sandiford  <richard@@codesourcery.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* NEWS: Mention -l:foo.
	* ld.texinfo: Document it.
	* ldlang.c (new_afile): If a lang_input_file_is_l_enum
	entry as a name beginning with a coloh, convert it to a
	lang_input_file_is_search_file_enum entry without the colon.

ld/testsuite/
	* ld-libs/lib-1.s, ld-libs/lib-2.s, ld-libs/lib-2.d,
	* ld-libs/libs.exp: New files.
@
text
@d5667 1
d5671 1
@


1.255
log
@	* Makefile.am: Add dependency on ldemul-list.h for powerpc and
	spu target emul files.
	* configure.in: Check for mkstemp and waitpid.
	* Makefile.in: Regenerate.
	* configure: Regenerate.
	* config.in: Regenerate.
	* ldlang.c (input_file_chain): Make global.
	(lang_add_input_file): Don't set lang_has_input_file here.
	* ldlang.h (input_file_chain): Declare.
	* emultempl/ppc32elf.em (ppc_recognized_file): New function.
	(LDEMUL_RECOGNIZED_FILE): Define.
	* emultempl/ppc64elf.em (ppc64_recognized_file): New function.
	(LDEMUL_RECOGNIZED_FILE): Define.
	* emultempl/spuelf.em (struct tflist): New.
	(tmp_file_list): New var.
@
text
@d916 8
@


1.254
log
@ld/
	* ldlang.c (lang_insert_orphan): Provide start/stop loadaddr syms
	rather than defining unconditionally.
	(lang_leave_overlay_section): Likewise.
	* ld.texinfo (Overlay Description): Update description and examples
	for start/stop syms.
ld/testsuite/
	* ld-elf/overlay.d: -u symbols we want to see in the output.
@
text
@a54 1
static lang_statement_list_type input_file_chain;
d91 1
a990 1
  lang_has_input_file = TRUE;
@


1.253
log
@Use pc-relative relocation instead of an absolute relocation for x86_64-pc-mingw32 target.
@
text
@d1493 3
a1495 2
	  lang_add_assignment (exp_assop ('=', symname,
					  exp_nameop (NAME, ".")));
d1525 3
a1527 2
      lang_add_assignment (exp_assop ('=', symname,
				      exp_nameop (NAME, ".")));
d6441 3
a6443 2
  lang_add_assignment (exp_assop ('=', buf,
				  exp_nameop (LOADADDR, name)));
d6447 5
a6451 4
  lang_add_assignment (exp_assop ('=', buf,
				  exp_binop ('+',
					     exp_nameop (LOADADDR, name),
					     exp_nameop (SIZEOF, name))));
@


1.252
log
@	* ldlang.c (lang_size_sections_1): Correct backwards dot move
	test to not trigger on overlays.  Only warn on backwards move
	if non-default lma.
@
text
@d4709 4
a4712 1
/* Callback routine that is used in _bfd_elf_map_sections_to_segments.  */
d4723 3
a4725 1
  
d4736 1
a4736 1
     we have a large number of sections a hash lookup is faster.  */
d4740 1
d4745 2
a4746 2
     different segments.  See the email thread starting here for the
     reasons why this is necessary:
d6220 1
d6246 20
a6265 1
	      pl = last;
a6496 1

@


1.251
log
@Take into account MEMORY regions when creating a segment map.
@
text
@d4414 1
a4414 1
		   os->load_base set) because backwards moves normally
d4417 2
a4418 1
		    && os->bfd_section->size != 0)
a4419 3
		    einfo (_("%P: warning: dot moved backwards before `%s'\n"),
			   os->name);

d4423 6
a4428 2
		       sufficiently large.  Nag anyway, so people fix
		       their linker scripts.  */
@


1.250
log
@2007-02-06  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldlang.c (lang_size_sections_1): Add a missing `)'.
@
text
@d4707 36
@


1.249
log
@	* ldlang.c (lang_size_sections_1): Don't warn on backwards dot
	move unless section size is non-zero.
@
text
@d4471 1
a4471 1
				   .bfd_section->vma))
@


1.248
log
@bfd/

2007-01-16  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/3831
	* elf-bfd.h (bfd_elf_link_mark_dynamic_symbol): Add an
	argument, Elf_Internal_Sym *.

	* elflink.c (bfd_elf_link_mark_dynamic_symbol): Mark a data
	symbol dynamic if info->dynamic_data is TRUE.
	(bfd_elf_record_link_assignment): Updated call to
	bfd_elf_record_link_assignment.
	(_bfd_elf_merge_symbol): Likewise.  Always call
	bfd_elf_link_mark_dynamic_symbol.

include/

2007-01-16  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/3831
	* bfdlink.h (bfd_link_info): Rename dynamic to dynamic_list.
	Add dynamic and dynamic_data.

ld/

2007-01-16  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/3831
	* NEWS: Mention -Bsymbolic-functions, --dynamic-list-data and
	--dynamic-list-cpp-new.

	* ld.texinfo: Document -Bsymbolic-functions, --dynamic-list-data
	and --dynamic-list-cpp-new.

	* ldlang.c (lang_append_dynamic_list_cpp_new): New.
	(lang_process): Change link_info.dynamic to
	link_info.dynamic_list.
	(lang_append_dynamic_list): Likewise.
	* ldmain.c (main): Likewise.  Initialize link_info.dynamic and
	link_info.dynamic_data to FALSE.

	* ldlang.h (lang_append_dynamic_list_cpp_new): New.

	* lexsup.c (option_values): Add OPTION_DYNAMIC_LIST_DATA and
	OPTION_DYNAMIC_LIST_CPP_NEW.
	(ld_options): Add entries for -Bsymbolic-functions,
	--dynamic-list-data and --dynamic-list-cpp-new.  Make
	-Bsymbolic-functions an alias of --dynamic-list-data.
	(parse_args): Change link_info.dynamic to link_info.dynamic_list.
	Set link_info.dynamic to TRUE for --dynamic-list and
	--dynamic-list-cpp-typeinfo.  Handle --dynamic-list-data and
	--dynamic-list-cpp-new.

ld/testsuite/

2007-01-16  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/3831
	* ld-elf/del.cc: New.
	* ld-elf/dl5.cc: Likewise.
	* ld-elf/dl5.out: Likewise.
	* ld-elf/new.cc: Likewise.

	* ld-elf/shared.exp: Add tests for --dynamic-list-data and
	 --dynamic-list-cpp-new.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006
d4416 2
a4417 1
		if (dot < last->vma)
d4467 5
a4471 2
		    || os->bfd_section->vma != os->bfd_section->lma
		    || r->last_os != NULL)
@


1.247
log
@	* ldlang.c (print_output_section_statement): Print load address
	when lma differs from vma.
testsuite/
	* ld-scripts/overlay-size-map.d: Update.
@
text
@d5637 2
a5638 2
  if (link_info.dynamic)
    lang_finalize_version_expr_head (&link_info.dynamic->head);
d6948 1
a6948 1
  if (link_info.dynamic)
d6953 2
a6954 2
      tail->next = link_info.dynamic->head.list;
      link_info.dynamic->head.list = dynamic;
d6963 1
a6963 1
      link_info.dynamic = d;
d6987 21
@


1.246
log
@bfd/

2006-10-30  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/3111
	* elf-bfd.h (elf_obj_tdata): Add symbuf.
	(_bfd_elf_section_already_linked): Add struct bfd_link_info *.
	(_bfd_elf_check_kept_section): Likewise.
	(bfd_elf_match_symbols_in_sections): Likewise.

	* elf.c (assign_section_numbers): Updated to add
	struct bfd_link_info *.
	(bfd_elf_match_symbols_in_sections): Updated. Cache symbol
	buffer if info->reduce_memory_overheads is false.

	* elflink.c (match_group_member): Updated to add
	struct bfd_link_info *.
	(_bfd_elf_check_kept_section): Likewise.
	(elf_link_input_bfd): Likewise.
	(_bfd_elf_section_already_linked): Likewise.
	(bfd_elf_final_link): Free symbol buffer if
	info->reduce_memory_overheads is false.

	* libbfd-in.h (_bfd_nolink_section_already_linked): Add
	struct bfd_link_info *.
	(_bfd_generic_section_already_linked): Likewise.
	* libbfd.h: Regenerated.

	* linker.c (bfd_section_already_linked): Add
	struct bfd_link_info *.
	(_bfd_generic_section_already_linked): Likewise.
	* targets.c (bfd_target): Add struct bfd_link_info * to
	_section_already_linked.
	* bfd-in2.h: Regenerated.

include/

2006-10-30  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/3111
	* bfdlink.h (bfd_link_info): Add reduce_memory_overheads.

ld/

2006-10-30  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/3111
	* ld.h (args_type): Remove reduce_memory_overheads.

	* ldlang.c (lang_map): Updated.
	(section_already_linked): Likewise.
	(print_input_section): Likewise.
	* ldmain.c (main): Likewise.
	* lexsup.c (parse_args): Likewise.
@
text
@d3415 2
a3416 8
	  if (output_section_statement->load_base != NULL)
	    {
	      bfd_vma addr;

	      addr = exp_get_abs_int (output_section_statement->load_base, 0,
				      "load base");
	      minfo (_(" load address 0x%V"), addr);
	    }
@


1.245
log
@bfd/
	* section.c (SEC_KEEP): Update comment.
	* bfd-in2.h: Regenerate.
	* elflink.c (bfd_elf_gc_sections): Ignore SEC_EXCLUDE sections.
	* merge.c (_bfd_merge_sections): Set SEC_KEEP on excluded sections.
	* stabs.c (_bfd_discard_section_stabs): Likewise.
	(_bfd_link_section_stabs): Likewise.  Simplify abs_section check.
ld/
	* ldlang.c (lang_map): Don't say SEC_LINKER_CREATED and SEC_KEEP
	sections have been discarded.
	(lang_do_version_exports_section): Set SEC_KEEP on export section.
	* emultempl/elf32.em (before_allocation): Set SEC_KEEP on warning
	sections.
@
text
@d1797 1
a1797 1
  if (! command_line.reduce_memory_overheads)
d1876 1
a1876 1
  if (!command_line.reduce_memory_overheads)
d1969 1
a1969 1
    bfd_section_already_linked (abfd, sec);
d3662 1
a3662 1
      if (command_line.reduce_memory_overheads)
@


1.244
log
@New Cell SPU port.
@
text
@d1739 3
a1741 2
	if (s->output_section == NULL
	    || s->output_section->owner != output_bfd)
d4633 1
a4633 1
	    if ((tree->type.node_class == etree_provided 
d6926 1
a6926 1
      sec->flags |= SEC_EXCLUDE;
@


1.243
log
@bfd/
	* elf32-arm.c (bfd_elf32_arm_allocate_interworking_sect): Check,
	don't set, glue section size.
	(record_arm_to_thumb_glue): Set glue section size here.
	(record_thumb_to_arm_glue): Likewise.
	(bfd_elf32_arm_add_glue_sections_to_bfd): Formatting.
	(bfd_elf32_arm_process_before_allocation): Ignore exluded sections.

ld/
	* emultempl/armelf.em (arm_elf_before_allocation): Run
	gld${EMULATION_NAME}_before_allocation later.
	* ldlang.c (lang_size_sections_1): Revert 2006-09-15 change.
@
text
@a70 2
static bfd_boolean load_symbols (lang_input_statement_type *,
				 lang_statement_list_type *);
d2388 1
a2388 1
static bfd_boolean
@


1.242
log
@bfd/
	* elf-bfd.h (struct elf_link_hash_table): Reorder.  Add
	text_index_section and data_index_section.
	(struct elf_backend_data): Add elf_backend_init_index_section.
	(_bfd_elf_init_1_index_section): Declare.
	(_bfd_elf_init_2_index_sections): Declare.
	* elfxx-target.h (elf_backend_init_index_section): Define.
	(elfNN_bed): Init new field.
	* elflink.c (_bfd_elf_link_omit_section_dynsym): Keep first tls
	section and text_index_section plus data_index_section.
	(_bfd_elf_link_renumber_dynsyms): Clear dynindx on omitted sections.
	(_bfd_elf_init_1_index_section): New function.
	(_bfd_elf_init_2_index_sections): New function.
	(bfd_elf_size_dynsym_hash_dynstr): Call elf_backend_init_index_section.
	(elf_link_input_bfd): When emitting relocs, use text_index_section
	and data_index_section for removed sections.
	* elf-m10300.c (elf_backend_omit_section_dynsym): Define.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-xstormy16.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-mmix.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elf32-arm.c (elf32_arm_final_link_relocate): Use text_index_section
	and data_index_section sym for relocs against sections with no dynamic
	section sym.
	(elf_backend_init_index_section): Define.
	* elf32-cris.c: Similarly.
	* elf32-hppa.c: Similarly.
	* elf32-i370.c: Similarly.
	* elf32-m68k.c: Similarly.
	* elf32-mips.c: Similarly.
	* elf32-ppc.c: Similarly.
	* elf32-s390.c: Similarly.
	* elf32-sparc.c: Similarly.
	* elf32-vax.c: Similarly.
	* elf64-mips.c: Similarly.
	* elf64-ppc.c: Similarly.
	* elf64-s390.c: Similarly.
	* elf64-sparc.c: Similarly.
	* elf64-x86-64.c: Similarly.
	* elfn32-mips.c: Similarly.
	* elfxx-mips.c: Similarly.
	* elfxx-sparc.c: Similarly.
	* linker.c (fix_syms): Base symbols in removed sections on
	previous section in preference to using absolute section.

ld/
	* ldlang.c (strip_excluded_output_sections): Do strip sections
	that define syms, but don't ignore them.
	* ld.texinfo (Output Section Discarding): Revise.
	* emultempl/armcoff.em (gld${EMULATION_NAME}_finish): Always call
	finish_default.

ld/testsuite/
	Update for section sym changes.
@
text
@d4371 6
a4376 12
	      {
		if (os->bfd_section->size > 0)
		  {
		    /* PR ld/3107:  Do not abort when a buggy linker script
		       causes a non-empty section to be discarded.  */
		    if (bfd_is_abs_section (os->bfd_section))
		      einfo (_("%P%X: internal error: attempting to take the size of the non-section *ABS*\n"));
		    else
		      einfo (_("%P: warning: discarding non-empty, well known section %A\n"),
			     os->bfd_section);
		  }
	      }
@


1.241
log
@	* ldlang.c (lang_append_dynamic_list): When appending, add all elements
	of the dynamic list rather than just the first entry.
@
text
@a3344 1
		 && !os->section_relative_symbol
d3374 2
a3375 1
	  os->ignored = TRUE;
@


1.240
log
@bfd/

2006-09-26  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/3223
	PR ld/3267
	* elf.c (assign_file_positions_for_non_load_sections): Don't
	warn zero size allocated sections.

ld/

2006-09-26  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/3223
	PR ld/3267
	* ld.texinfo: Updated Output Section Discarding.

	* ldlang.h (lang_output_section_statement_type): Add
	section_relative_symbol.
	* ldlang.c (strip_excluded_output_sections): Don't strip a
	section with a symbol relative to it.
	(lang_size_sections_1): Mark if an output section has a symbol
	symbol relative to it.

ld/testsuite/

2006-09-26  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/3223
	PR ld/3267
	* ld-scripts/empty-address-1.d: New file.
	* ld-scripts/empty-address-1.s: Likewise.
	* ld-scripts/empty-address-1.t: Likewise.
	* ld-scripts/empty-address-2.s: Likewise.
	* ld-scripts/empty-address-2a.d: Likewise.
	* ld-scripts/empty-address-2a.t: Likewise.
	* ld-scripts/empty-address-2b.d: Likewise.
	* ld-scripts/empty-address-2b.t: Likewise.
	* ld-scripts/empty-address-3.s: Likewise.
	* ld-scripts/empty-address-3a.d: Likewise.
	* ld-scripts/empty-address-3a.t: Likewise.
	* ld-scripts/empty-address-3b.d: Likewise.
	* ld-scripts/empty-address-3b.t: Likewise.
	* ld-scripts/empty-address-3c.d: Likewise.
	* ld-scripts/empty-address-3c.t: Likewise.
	* ld-scripts/empty-address.exp: Likewise.
@
text
@d6963 4
a6966 1
      dynamic->next = link_info.dynamic->head.list;
@


1.239
log
@PR ld/3107
* ldlang.c (lang_size_sections_1): Do not abort when encountering a non-empty
  section that is ignored.  Instead produce a warning message.
@
text
@d3345 1
d4633 1
d4635 1
a4635 1
	    exp_fold_tree (s->assignment_statement.exp,
d4639 7
@


1.238
log
@bfd/

2006-09-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (elf_link_hash_entry): Add a dynamic field.
	(bfd_elf_link_mark_dynamic_symbol): New.
	(SYMBOLIC_BIND): New.

	* elf32-i386.c (elf_i386_check_relocs): Replace info->symbolic
	with SYMBOLIC_BIND (info, h).
	(elf_i386_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_check_relocs): Likewise.
	(elf64_x86_64_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_check_relocs): Likewise.

	* elflink.c (bfd_elf_link_mark_dynamic_symbol): New.
	(bfd_elf_record_link_assignment): Call
	bfd_elf_link_mark_dynamic_symbol on new entry.
	(_bfd_elf_merge_symbol): Likewise.
	(_bfd_elf_export_symbol): Return if the symbol isn't exported.
	(_bfd_elf_fix_symbol_flags): Replace info->symbolic with
	SYMBOLIC_BIND (info, h).
	(_bfd_elf_dynamic_symbol_p): Likewise.
	(_bfd_elf_symbol_refs_local_p): Likewise.
	(bfd_elf_size_dynamic_sections): Updated.

include/

2006-09-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfdlink.h (bfd_elf_dynamic_list): New.
	(bfd_link_info): Add a dynamic field.

ld/

2006-09-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* Makefile.am (CXX): Set to g++.
	(CXX_FOR_TARGET): Likewise.
	* Makefile.in: Regenerated.

	* NEWS: Mention --dynamic-list.

	* ld.texinfo: Document --dynamic-list.

	* ldgram.y: Support dynamic list.

	* ldlang.c (lang_process): Call lang_finalize_version_expr_head
	on link_info.dynamic if needed.
	(lang_append_dynamic_list): New.
	(lang_append_dynamic_list_cpp_typeinfo): New.
	* ldlang.h (lang_append_dynamic_list): Likewise.
	* ldlang.h (lang_append_dynamic_list_cpp_typeinfo): Likewise.

	* ldlex.h (input_enum): Add input_dynamic_list.
	* ldlex.l: Handle it.

	* ldmain.c (main): Initialize link_info.dynamic.

	* lexsup.c (option_values): Add OPTION_DYNAMIC_LIST and
	OPTION_DYNAMIC_LIST_CPP_TYPEINFO.
	(ld_options): Add entries for OPTION_DYNAMIC_LIST and
	OPTION_DYNAMIC_LIST_CPP_TYPEINFO.
	(parse_args): Handle OPTION_DYNAMIC_LIST and
	OPTION_DYNAMIC_LIST_CPP_TYPEINFO.

ld/testsuite/

2006-09-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-elf/dl1.c: New file.
	* ld-elf/dl1.list: Likewise.
	* ld-elf/dl1.out: Likewise.
	* ld-elf/dl1main.c: Likewise.
	* ld-elf/dl2.c: Likewise.
	* ld-elf/dl2.list: Likewise.
	* ld-elf/dl2a.out: Likewise.
	* ld-elf/dl2b.out: Likewise.
	* ld-elf/dl2main.c: Likewise.
	* ld-elf/dl2xxx.c: Likewise.
	* ld-elf/dl2xxx.list: Likewise.
	* ld-elf/dl3.cc: Likewise.
	* ld-elf/dl3.list: Likewise.
	* ld-elf/dl3a.out: Likewise.
	* ld-elf/dl3b.out: Likewise.
	* ld-elf/dl3header.h: Likewise.
	* ld-elf/dl3main.cc: Likewise.

	* ld-elf/shared.exp: Updated.

	* lib/ld-lib.exp (run_ld_link_exec_tests): Take an optional
	argument for source language. Use CC/CXX for link, depending
	on source language.
	(run_cc_link_tests): Likewise.
@
text
@d4370 12
a4381 1
	      ASSERT (os->bfd_section->size == 0);
@


1.237
log
@	* ldlang.c (walk_wild): Allow * to glob '/' in wildcarded match.
@
text
@d86 2
d5629 4
d6935 42
@


1.236
log
@* ldlang.c (lang_size_sections_1, lang_assignment_statement_enum):
  Adjust the current address of DEFAULT_MEMORY_REGION even when dot hasn't changed.
@
text
@d794 1
a794 1
	  if (fnmatch (file_spec, f->filename, FNM_FILE_NAME) == 0)
@


1.235
log
@	* NEWS: Mention LMA default change.
	* ld.texinfo (Output Section LMA): Update default description.
	(Location Counter): Clarify backward movement.
	* ldlang.c (lang_size_sections_1): Leave non-alloc sections with
	default lma equal to vma.  Warn on backward movement of dot.
@
text
@d4624 1
a4624 1
	    if (newdot != dot && !output_section_statement->ignored)
d4633 1
a4633 1
		else
@


1.234
log
@ld/
	PR 3052
	* ldlang.h (lang_output_section_statement_type): Replace
	"processed" field with "processed_vma" and "processed_lma".
	* ldlang.c (lang_do_assignments_1): Move lma setting code..
	(lang_size_sections_1): ..to here.
	(lang_reset_memory_regions): Adjust for
	lang_output_section_statement_type change.
	* ldexp.c (fold_name): Likewise.

And this is something I forgot the check in from the previous patch.
ld/testsuite/
	* ld-scripts/overlay-size-map.d: Adjust.
@
text
@d4403 2
a4404 1
	    else if (r->last_os != NULL)
d4410 17
a4426 4
		/* If dot moved backwards (which is invalid according
		   to ld docs) then leave lma equal to vma.  This
		   keeps users of buggy ld scripts happy.  */
		if (dot >= last->vma)
d4457 4
a4460 1
	       default lma == vma is incorrect.  */
d4463 4
@


1.233
log
@2006-08-08  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/3006
	* ldlang.c (lang_section_bst_type): Moved to ...
	* ldlang.h: Here.

	* ldlang.h (lang_wild_statement_struct): Add a tree field.

	* ldlang.c (wild_sort_fast): Use the tree field for BST.
	(wild): Likeise.
	(analyze_walk_wild_section_handler): Initialize the tree field.
@
text
@d4231 1
d4236 1
a4236 1
		os->processed = FALSE;
d4365 1
a4365 1
	    os->processed = TRUE;
d4368 21
d4390 12
a4401 2
		ASSERT (os->bfd_section->size == 0);
		break;
d4403 20
d4424 11
a4434 1
	    dot = os->bfd_section->vma;
d4436 2
a4437 6
	    /* Put the section within the requested block size, or
	       align at the block boundary.  */
	    after = ((dot
		      + TO_ADDR (os->bfd_section->size)
		      + os->block_value - 1)
		     & - (bfd_vma) os->block_value);
d4439 10
a4448 1
	    os->bfd_section->size = TO_SIZE (after - os->bfd_section->vma);
d4480 2
a4481 4
		    /* Set load_base, which will be handled later.  */
		    os->load_base = exp_intop (os->lma_region->current);
		    os->lma_region->current +=
		      TO_ADDR (os->bfd_section->size);
d4485 1
a4485 1
				       os->lma_region->current);
a4784 2
		lang_memory_region_type *r;

a4785 33
		r = os->region;
		if (r == NULL)
		  r = lang_memory_region_lookup (DEFAULT_MEMORY_REGION, FALSE);

		if (os->load_base)
		  os->bfd_section->lma
		    = exp_get_abs_int (os->load_base, 0, "load base");
		else if (r->last_os != NULL)
		  {
		    asection *last;
		    bfd_vma lma;

		    last = r->last_os->output_section_statement.bfd_section;

		    /* If the current vma overlaps the previous section,
		       then set the current lma to that at the end of
		       the previous section.  The previous section was
		       probably an overlay.  */
		    if ((dot >= last->vma
			 && dot < last->vma + last->size)
			|| (last->vma >= dot
			    && last->vma < dot + os->bfd_section->size))
		      lma = last->lma + last->size;

		    /* Otherwise, keep the same lma to vma relationship
		       as the previous section.  */
		    else
		      lma = dot + last->lma - last->vma;

		    if (os->section_alignment != -1)
		      lma = align_power (lma, os->section_alignment);
		    os->bfd_section->lma = lma;
		  }
d4787 1
a4787 2
		lang_do_assignments_1 (os->children.head,
				       os, os->fill, dot);
d4793 1
a4793 12
		  {
		    dot += TO_ADDR (os->bfd_section->size);

		    /* Keep track of normal sections using the default
		       lma region.  We use this to set the lma for
		       following sections.  Overlays or other linker
		       script assignment to lma might mean that the
		       default lma == vma is incorrect.  */
		    if (!link_info.relocatable
			&& os->lma_region == NULL)
		      r->last_os = s;
		  }
d5472 4
a5475 1
    os->processed = FALSE;
@


1.232
log
@ld/

2006-08-08  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/3009
	* ldlang.c (update_wild_statements): Update the whole wild
	section list.

ld/testsuite/

2006-08-08  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/3009
	* ld-scripts/sort.t: New file.
	* ld-scripts/sort_b_a-1.d: Likewise.
	* ld-scripts/sort_b_a-1.s: Likewise.
	* ld-scripts/sort_b_n-1.d: Likewise.
	* ld-scripts/sort_b_n-1.s: Likewise.
@
text
@a47 9
/* Binary search tree structure to
   efficiently sort sections by name.  */
typedef struct lang_section_bst
{
  asection *section;
  struct lang_section_bst *left;
  struct lang_section_bst *right;
} lang_section_bst_type;

d371 1
a371 1
  tree = (lang_section_bst_type **) &wild->handler_data[1];
d668 1
d2547 1
a2547 1
      tree = (lang_section_bst_type *) s->handler_data[1];
d2549 4
a2552 2
	output_section_callback_tree_to_list (s, tree, output);
      s->handler_data[1] = NULL;
@


1.231
log
@ld/

2006-08-01  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldlang.c (init_os): Add flags. Replace bfd_make_section with
	bfd_make_section_with_flags.
	(exp_init_os): Updated.
	(lang_add_section): Call init_os with flags.
	(map_input_to_output_sections): Likewise.

ld/testsuite/

2006-08-01  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-elf/noload-1.d: New.
	* ld-elf/noload-1.s: Likewise.
	* ld-elf/noload-1.t: Likewise.
@
text
@d3160 2
a3161 1
	      if (sec != NULL)
@


1.230
log
@	* ldexp.c (fold_name <LOADADDR>): Use the lma.
	* ldlang.h (lang_memory_region_type): Delete old_length.  Add
	last_os.
	* ldlang.c (lang_memory_region_lookup): Init new field.
	(lang_reset_memory_regions): Reset new field.
	(lang_insert_orphan): Don't set load_base.
	(lang_leave_overlay): Likewise.
	(lang_size_sections_1): Delete unnecessary code setting lma_region
	to region.  Correct lma region check.
	(lang_do_assignments_1): Rename output_section_statement parm
	to current_os.  Set lma from previous section in region.
@
text
@d1862 2
a1863 1
init_os (lang_output_section_statement_type *s, asection *isec)
d1873 2
a1874 1
    s->bfd_section = bfd_make_section (output_bfd, s->name);
d1952 1
a1952 1
	      init_os (os, NULL);
d2027 24
d2052 1
a2052 1
	init_os (output, section);
a2075 11
      flags = section->flags;

      /* We don't copy the SEC_NEVER_LOAD flag from an input section
	 to an output section, because we want to be able to include a
	 SEC_NEVER_LOAD section in the middle of an otherwise loaded
	 section (I don't know why we want to do this, but we do).
	 build_link_order in ldwrite.c handles this case by turning
	 the embedded SEC_NEVER_LOAD section into a fill.  */

      flags &= ~ SEC_NEVER_LOAD;

a2111 13
      switch (output->sectype)
	{
	case normal_section:
	  break;
	case noalloc_section:
	  output->bfd_section->flags &= ~SEC_ALLOC;
	  break;
	case noload_section:
	  output->bfd_section->flags &= ~SEC_LOAD;
	  output->bfd_section->flags |= SEC_NEVER_LOAD;
	  break;
	}

d3206 2
d3257 1
a3257 2
	  if (os != NULL && os->bfd_section == NULL)
	    init_os (os, NULL);
a3259 1
	  os->bfd_section->flags |= SEC_HAS_CONTENTS;
d3261 5
a3265 1
	    os->bfd_section->flags |= SEC_ALLOC | SEC_LOAD;
d3275 1
a3275 1
	    init_os (os, NULL);
d3279 1
a3279 1
	    init_os (os, NULL);
d3307 1
a3307 1
		init_os (aos, NULL);
@


1.229
log
@	* ldlang.c: Formatting.
@
text
@a1166 3

  *lang_memory_region_list_tail = new;
  lang_memory_region_list_tail = &new->next;
d1168 3
a1172 2
  new->length = ~(bfd_size_type) 0;
  new->current = 0;
d1175 3
a1465 1
  etree_type *load_base;
a1508 10
  load_base = NULL;
  if (after != NULL && after->load_base != NULL)
    {
      etree_type *lma_from_vma;
      lma_from_vma = exp_binop ('-', after->load_base,
				exp_nameop (ADDR, after->name));
      load_base = exp_binop ('+', lma_from_vma,
			     exp_nameop (ADDR, secname));
    }

d1512 1
a1512 1
					    load_base, 0);
a4409 5
		/* If there's no load address specified, use the run
		   region as the load region.  */
		if (os->lma_region == NULL && os->load_base == NULL)
		  os->lma_region = os->region;

d4416 1
d4419 1
a4419 1
				       os->bfd_section->lma);
d4698 4
a4701 5
lang_do_assignments_1
  (lang_statement_union_type *s,
   lang_output_section_statement_type *output_section_statement,
   fill_type *fill,
   bfd_vma dot)
d4709 1
a4709 3
				       output_section_statement,
				       fill,
				       dot);
d4719 2
d4722 37
a4758 1
		lang_do_assignments_1 (os->children.head, os, os->fill, dot);
a4762 7
		  dot += TO_ADDR (os->bfd_section->size);
	      }
	    if (os->load_base)
	      {
		/* If nothing has been placed into the output section then
		   it won't have a bfd_section.  */
		if (os->bfd_section && !os->ignored)
d4764 10
a4773 2
		    os->bfd_section->lma
		      = exp_get_abs_int (os->load_base, 0, "load base");
d4782 1
a4782 2
				       output_section_statement,
				       fill, dot);
d4851 1
a4851 1
			 output_section_statement->bfd_section,
d4861 1
a4861 2
				       output_section_statement,
				       fill, dot);
a5445 1
      p->old_length = (bfd_size_type) (p->current - p->origin);
d5447 1
a6372 4
      else if (lma_region == 0)
	l->os->load_base = exp_binop ('+',
				      exp_nameop (LOADADDR, l->next->os->name),
				      exp_nameop (SIZEOF, l->next->os->name));
@


1.228
log
@	* ldlang.c (analyze_walk_wild_section_handler): Init handler_data
	earlier.
@
text
@d291 1
a291 1
  bfd_get_section_by_name_if (file->the_bfd, sec->spec.name, 
d368 1
a368 1
/* Build a Binary Search Tree to sort sections, unlike insertion sort 
d374 3
a376 3
                struct wildcard_list *sec,
                lang_input_statement_type *file ATTRIBUTE_UNUSED,
                asection *section) 
d378 1
a378 2
  lang_section_bst_type **tree
    = (lang_section_bst_type **) (&(wild->handler_data[1]));
d380 1
d382 1
a382 1
      && (sec == NULL || sec->spec.sorted == none)) 
d386 1
a386 1
        tree = &((*tree)->right);
d390 1
a390 1
  while (*tree) 
d393 4
a396 4
      if (compare_section (sec->spec.sorted, section, (*tree)->section) < 0) 
        tree = &((*tree)->left);
      else 
        tree = &((*tree)->right);
d406 4
a409 4
                              struct wildcard_list *sec,
                              asection *section,
                              lang_input_statement_type *file,
                              void *output ATTRIBUTE_UNUSED) 
d430 3
a432 3
output_section_callback_tree_to_list (lang_wild_statement_type *ptr, 
                                      lang_section_bst_type *tree, 
                                      void *output) 
d437 2
a438 2
  lang_add_section (& ptr->children, tree->section,
                    (lang_output_section_statement_type *) output);
d1017 1
a1017 1
output_section_statement_newfunc (struct bfd_hash_entry *entry, 
d1581 2
a1582 2
        {
          /* Put the section at the end of the list.  */
d1589 1
a1589 1
        }
d2368 1
a2368 1
        break;
d2556 1
a2556 1
      && (s->handler_data[0]->spec.sorted == by_name) 
d2559 2
d2563 3
a2565 4
      if (s->handler_data[1]) 
        output_section_callback_tree_to_list (s, 
                                              (lang_section_bst_type *) s->handler_data[1], 
                                              output);
d2568 1
a2568 1
  else 
d3293 1
a3293 1
	  /* Mark the specified section with the supplied address.  
d3303 1
a3303 1
	  if (!s->address_statement.segment 
d3309 1
a3309 1
	      
d3444 1
a3444 1
   
d4150 1
a4150 1
  
d4167 1
a4167 1
      os_start = s_start; 
d5540 1
a5540 1
      relax_again = FALSE; 
@


1.227
log
@* ldlang.c (lang_section_bst): New structure for sorting sections by name.
  (wild_sort_fast): New function: Insert a section into a binary search tree.
  (output_section_callback_fast): New function: Store a section in BST.
  (output_section_callback_tree_to_list): New function: Convert a BST into a list.
  (analyze_walk_wild_section_handler): Initialize handler_data elements.
  (wild): If the data is sorted by name use the BST method to sort the names.
@
text
@d673 4
a741 4
  ptr->handler_data[0] = NULL;
  ptr->handler_data[1] = NULL;
  ptr->handler_data[2] = NULL;
  ptr->handler_data[3] = NULL;
@


1.226
log
@Fix for segmentation fault.

	* ldlang.c (lang_insert_orphan): Correctly handle the case where
	the section is to end up after the section currently at the end
	of the list in output_bfd.
@
text
@d48 9
d328 118
d738 4
a2136 40
/* Compare sections ASEC and BSEC according to SORT.  */

static int
compare_section (sort_type sort, asection *asec, asection *bsec)
{
  int ret;

  switch (sort)
    {
    default:
      abort ();

    case by_alignment_name:
      ret = (bfd_section_alignment (bsec->owner, bsec)
	     - bfd_section_alignment (asec->owner, asec));
      if (ret)
	break;
      /* Fall through.  */

    case by_name:
      ret = strcmp (bfd_get_section_name (asec->owner, asec),
		    bfd_get_section_name (bsec->owner, bsec));
      break;

    case by_name_alignment:
      ret = strcmp (bfd_get_section_name (asec->owner, asec),
		    bfd_get_section_name (bsec->owner, bsec));
      if (ret)
	break;
      /* Fall through.  */

    case by_alignment:
      ret = (bfd_section_alignment (bsec->owner, bsec)
	     - bfd_section_alignment (asec->owner, asec));
      break;
    }

  return ret;
}

d2555 14
a2568 1
  walk_wild (s, output_section_callback, output);
@


1.225
log
@	* emultempl/elf-generic.em (gld${EMULATION_NAME}_map_segments): Limit
	loop to ten iterations.  Throw away any previous linker generated
	segment map.
	* ldlang.c (lang_phdr_list): Make global.
	* ldlang.h (lang_phdr_list): Declare.
	* Makefile.am (ELF_GEN_DEPS): Define.  Use in emul deps.
	* Makefile.in: Regenerate.
@
text
@d1448 12
a1459 1
      if (as != snew && as->prev != snew)
@


1.224
log
@bfd/
	* elf-bfd.h: Formatting.
	(_bfd_elf_map_sections_to_segments): Declare.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame_hdr): Don't
	clear program_header_size.
	* elf.c (get_program_header_size): Move.  Don't use or set saved
	program_header_size here.
	(elf_modify_segment_map): New function.  Split out from..
	(assign_file_positions_for_load_sections): ..here.  Assert
	header size is correct.  Remove dead code.
	(_bfd_elf_map_sections_to_segments): Rename from
	map_sections_to_segments.  Make global.  Use get_program_header_size
	when we need estimate of header size.  Call elf_modify_segment_map.
	Set program_header_size.
	(print_segment_map): Delete.
	(_bfd_elf_sizeof_headers): If segment_map available, get the
	actual size.
	* elf32-arm.c (elf32_arm_symbian_modify_segment_map): Make safe
	for calling more than once.
	* elf32-bfin.c (elf32_bfinfdpic_modify_segment_map): Likewise.
	* elf32-frv.c (elf32_frvfdpic_modify_segment_map): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_modify_segment_map): Likewise.
	* elf32-i370.c (elf_backend_add_symbol_hook): Delete.
	(elf_backend_additional_program_headers): Delete.
	(elf_backend_modify_segment_map): Delete.
	* elf64-hppa.c (elf64_hppa_modify_segment_map): Convert to ISO C.
	* elfxx-ia64.c (elfNN_ia64_modify_segment_map): Likewise.
	* doc/bfdint.texi: Delete SIZEOF_HEADERS difficulties.
ld/
	* Makefile.am (ELF_DEPS): Define.  Use in emul file deps.  Fix
	many ELF emul file deps that incorrectly said they needed elf32.em
	instead of generic.em.  Add genelf.em as required.
	* Makefile.in: Regenerate.
	* ldlang.c (lang_process): Call ldemul_finish before
	lang_check_section_addresses.
	* emulparams/arcelf.sh: Generic elf target needs genelf.
	* emulparams/d30v_e.sh: Likewise.
	* emulparams/d30v_o.sh: Likewise.
	* emulparams/d30velf.sh: Likewise.
	* emulparams/elf32_dlx.sh: Likewise.
	* emulparams/elf32_i860.sh: Likewise.
	* emulparams/elf32fr30.sh: Likewise.
	* emulparams/elf32frv.sh: Likewise.
	* emulparams/elf32iq10.sh: Likewise.
	* emulparams/elf32iq2000.sh: Likewise.
	* emulparams/elf32mt.sh: Likewise.
	* emulparams/mn10200.sh: Likewise.
	* emulparams/or32.sh: Likewise.
	* emulparams/or32elf.sh: Likewise.
	* emulparams/pjelf.sh: Likewise.
	* emulparams/msp430all.sh: Likewise.  Extract common entries.
	* emulparams/pjlelf.sh: Include pjelf.sh.
	* emulparams/elf32frvfd.sh (EXTRA_EM_FILE): Unset.
	* emulparams/mn10300.sh (EXTRA_EM_FILE): Unset.
	* emultempl/elf-generic.em: New file.
	* emultempl/genelf.em: New file.
	* emultempl/elf32.em: Include elf-generic.em.
	(gld${EMULATION_NAME}_layout_sections_again): Delete.
	(gld${EMULATION_NAME}_finish): Call gld${EMULATION_NAME}_map_segments.
	* emultempl/hppaelf.em (hppaelf_layout_sections_again): Likewise.
	(gld${EMULATION_NAME}_finish): Rename from hppaelf_finish.  Call
	gld${EMULATION_NAME}_map_segments.
	(LDEMUL_FINISH): Update.
	* emultempl/mmo.em: Correct comment.  Include elf-bfd.h and
	source elf-generic.em.
	(mmo_finish): Call gld${EMULATION_NAME}_map_segments.
	* emultempl/ppc64elf.em (ppc_layout_sections_again): Likewise.
	(gld${EMULATION_NAME}_finish): Rename from ppc_finish.  Call
	gld${EMULATION_NAME}_map_segments.
	(LDEMUL_FINISH): Update.
ld/testsuite/
	* ld-elf/eh1.d: Update for fewer program headers.
	* ld-elf/eh2.d: Likewise.
	* ld-elf/eh3.d: Likewise.
@
text
@a64 1
static struct lang_phdr *lang_phdr_list;
d100 1
@


1.223
log
@	* ldlang.h (lang_input_statement_type): Use bitfields for booleans.
	* ldlang.c (struct out_section_hash_entry): Rename from
	output_statement_hash_entry.  Delete output_section_statement_type
	entry.  Add statement_union_type entry.  Adjust all users.
	(output_section_statement_table): Rename from output_statement_table.
	Adjust all users.
	(output_section_statement_newfunc): Rename from
	output_statement_newfunc.  Adjust all users.
	(output_section_statement_table_init): Rename from
	output_statement_table_init.  Adjust all users.
	(output_section_statement_table_free): Rename from
	output_statement_table_free.  Adjust all users.
@
text
@d5571 2
a5577 2
  /* Final stuffs.  */
  ldemul_finish ();
@


1.222
log
@	* ldlang.h (enum section_type): Delete dsect_section, copy_section,
	info_section and overlay_section.  Add noalloc_section.
	* ldlang.c (lang_add_section): Adjust.
	* ldgram.y (type): Adjust.
@
text
@d872 1
a872 1
struct output_statement_hash_entry
d875 1
a875 1
  lang_output_section_statement_type os;
d880 1
a880 1
static struct bfd_hash_table output_statement_table;
d886 3
a888 3
output_statement_newfunc (struct bfd_hash_entry *entry, 
			  struct bfd_hash_table *table,
			  const char *string)
d891 1
a891 1
  struct output_statement_hash_entry *ret;
d904 8
a911 10
  ret = (struct output_statement_hash_entry *) entry;
  memset (&ret->os, 0, sizeof (ret->os));
  ret->os.header.type = lang_output_section_statement_enum;
  ret->os.subsection_alignment = -1;
  ret->os.section_alignment = -1;
  ret->os.block_value = 1;
  lang_list_init (&ret->os.children);
  lang_statement_append (stat_ptr,
			 (lang_statement_union_type *) &ret->os,
			 &ret->os.header.next);
d917 4
a920 3
    ret->os.prev = (lang_output_section_statement_type *)
      ((char *) lang_output_section_statement.tail
       - offsetof (lang_output_section_statement_type, next));
d925 1
a925 1
  nextp = &ret->os.next;
d927 1
a927 1
			 (lang_statement_union_type *) &ret->os,
d933 1
a933 1
output_statement_table_init (void)
d935 3
a937 3
  if (!bfd_hash_table_init_n (&output_statement_table,
			      output_statement_newfunc,
			      sizeof (struct output_statement_hash_entry),
d943 1
a943 1
output_statement_table_free (void)
d945 1
a945 1
  bfd_hash_table_free (&output_statement_table);
d957 1
a957 1
  output_statement_table_init ();
d987 1
a987 1
  output_statement_table_free ();
d1074 1
a1074 1
  struct output_statement_hash_entry *entry;
d1077 3
a1079 2
  entry = ((struct output_statement_hash_entry *)
	   bfd_hash_lookup (&output_statement_table, name, FALSE, FALSE));
d1086 3
a1088 3
      if (entry->os.constraint != -1)
	return &entry->os;
      entry = (struct output_statement_hash_entry *) entry->root.next;
d1092 1
a1092 1
	 && strcmp (name, entry->os.name) == 0);
d1100 2
a1101 2
  struct output_statement_hash_entry *entry;
  struct output_statement_hash_entry *last_ent;
d1104 3
a1106 2
  entry = ((struct output_statement_hash_entry *)
	   bfd_hash_lookup (&output_statement_table, name, TRUE, FALSE));
d1113 1
a1113 1
  if (entry->os.name != NULL)
d1120 1
a1120 1
	  if (entry->os.constraint != -1
d1122 1
a1122 1
		  || (constraint == entry->os.constraint
d1124 1
a1124 1
	    return &entry->os;
d1126 1
a1126 1
	  entry = (struct output_statement_hash_entry *) entry->root.next;
d1130 1
a1130 1
	     && strcmp (name, entry->os.name) == 0);
d1132 5
a1136 2
      entry = ((struct output_statement_hash_entry *)
	       output_statement_newfunc (NULL, &output_statement_table, name));
d1146 3
a1148 3
  entry->os.name = name;
  entry->os.constraint = constraint;
  return &entry->os;
@


1.221
log
@	* ldlang.c (init_os): Whitespace.
	(map_input_to_output_sections): Don't init_os for lang_input_section.
	(print_all_symbols): Remove forward declaration.  Convert to ISO C.
@
text
@d1965 1
a1965 4
	case dsect_section:
	case copy_section:
	case info_section:
	case overlay_section:
@


1.220
log
@	* ldlang.c (lookup_name): Delete dead code.  Remove FIXMEs.
@
text
@a76 1
static void print_all_symbols (asection *);
d1744 1
a1752 1

d3154 2
a3156 1
	case lang_input_section_enum:
d3484 1
a3484 2
print_all_symbols (sec)
     asection *sec;
@


1.219
log
@	* ldlang.c (lang_size_sections_1): Don't check mem regions for
	os->ignored sections.
@
text
@d2217 1
a2217 1
      const char * filename = search->local_sym_name;
a2218 2
      if (filename == NULL && name == NULL)
	return search;
a2219 1
	  && name != NULL
d2229 2
a2230 5
     (FIXME: can that ever actually happen?) or the name is NULL
     (FIXME: can that ever actually happen?) don't add this file.  */
  if (search->loaded
      || ! search->real
      || search->filename == NULL)
@


1.218
log
@	* ldlang.c (lang_size_sections): Call lang_reset_memory_regions
	before redoing one_lang_size_sections_pass.
@
text
@d4201 2
a4202 1
		    if (!IGNORE_SECTION (os->bfd_section)
@


1.217
log
@	* ldlang.c (wild): Tidy default_common_section loop.
	(print_input_section): Format.
@
text
@d4545 1
d4569 1
d4590 1
@


1.216
log
@	* ldlang.c (load_symbols): Set as_needed and add_needed according
	to the corresponding script's fields while processing it.
@
text
@d2461 2
a2462 4
  for (sec = s->section_list; sec != NULL; sec = sec->next)
    {
      if (default_common_section != NULL)
	break;
d2468 1
a2469 1
    }
d3510 2
d3515 10
a3525 3
      int len;
      bfd_vma addr;

d3527 2
a3528 1
      minfo ("%s", i->name);
d3530 7
a3536 19
      len = 1 + strlen (i->name);
      if (len >= SECTION_NAME_MAP_LENGTH - 1)
	{
	  print_nl ();
	  len = 0;
	}
      while (len < SECTION_NAME_MAP_LENGTH)
	{
	  print_space ();
	  ++len;
	}

      if (i->output_section != NULL && i->output_section->owner == output_bfd)
	addr = i->output_section->vma + i->output_offset;
      else
	{
	  addr = print_dot;
	  size = 0;
	}
d3538 1
a3538 1
      minfo ("0x%V %W %B\n", addr, TO_ADDR (size), i->owner);
d3540 3
a3542 3
      if (size != i->rawsize && i->rawsize != 0)
	{
	  len = SECTION_NAME_MAP_LENGTH + 3;
d3544 1
a3544 1
	  len += 16;
d3546 1
a3546 1
	  len += 8;
d3548 5
a3552 5
	  while (len > 0)
	    {
	      print_space ();
	      --len;
	    }
d3554 2
a3555 2
	  minfo (_("%W (size before relaxing)\n"), i->rawsize);
	}
d3557 6
a3562 6
      if (i->output_section != NULL && i->output_section->owner == output_bfd)
	{
	  if (command_line.reduce_memory_overheads)
	    bfd_link_hash_traverse (link_info.hash, print_one_symbol, i);
	  else
	    print_all_symbols (i);
d3564 1
a3564 2
	  print_dot = addr + TO_ADDR (size);
	}
@


1.216.2.1
log
@	* ldlang.h (lang_input_statement_type): Use bitfields for booleans.
	* ldlang.c (struct out_section_hash_entry): Rename from
	output_statement_hash_entry.  Delete output_section_statement_type
	entry.  Add statement_union_type entry.  Adjust all users.
	(output_section_statement_table): Rename from output_statement_table.
	Adjust all users.
	(output_section_statement_newfunc): Rename from
	output_statement_newfunc.  Adjust all users.
	(output_section_statement_table_init): Rename from
	output_statement_table_init.  Adjust all users.
	(output_section_statement_table_free): Rename from
	output_statement_table_free.  Adjust all users.
@
text
@d873 1
a873 1
struct out_section_hash_entry
d876 1
a876 1
  lang_statement_union_type s;
d881 1
a881 1
static struct bfd_hash_table output_section_statement_table;
d887 3
a889 3
output_section_statement_newfunc (struct bfd_hash_entry *entry, 
				  struct bfd_hash_table *table,
				  const char *string)
d892 1
a892 1
  struct out_section_hash_entry *ret;
d905 10
a914 8
  ret = (struct out_section_hash_entry *) entry;
  memset (&ret->s, 0, sizeof (ret->s));
  ret->s.header.type = lang_output_section_statement_enum;
  ret->s.output_section_statement.subsection_alignment = -1;
  ret->s.output_section_statement.section_alignment = -1;
  ret->s.output_section_statement.block_value = 1;
  lang_list_init (&ret->s.output_section_statement.children);
  lang_statement_append (stat_ptr, &ret->s, &ret->s.header.next);
d920 3
a922 4
    ret->s.output_section_statement.prev
      = ((lang_output_section_statement_type *)
	 ((char *) lang_output_section_statement.tail
	  - offsetof (lang_output_section_statement_type, next)));
d927 1
a927 1
  nextp = &ret->s.output_section_statement.next;
d929 1
a929 1
			 &ret->s,
d935 1
a935 1
output_section_statement_table_init (void)
d937 3
a939 3
  if (!bfd_hash_table_init_n (&output_section_statement_table,
			      output_section_statement_newfunc,
			      sizeof (struct out_section_hash_entry),
d945 1
a945 1
output_section_statement_table_free (void)
d947 1
a947 1
  bfd_hash_table_free (&output_section_statement_table);
d959 1
a959 1
  output_section_statement_table_init ();
d989 1
a989 1
  output_section_statement_table_free ();
d1076 1
a1076 1
  struct out_section_hash_entry *entry;
d1079 2
a1080 3
  entry = ((struct out_section_hash_entry *)
	   bfd_hash_lookup (&output_section_statement_table, name,
			    FALSE, FALSE));
d1087 3
a1089 3
      if (entry->s.output_section_statement.constraint != -1)
	return &entry->s.output_section_statement;
      entry = (struct out_section_hash_entry *) entry->root.next;
d1093 1
a1093 1
	 && strcmp (name, entry->s.output_section_statement.name) == 0);
d1101 2
a1102 2
  struct out_section_hash_entry *entry;
  struct out_section_hash_entry *last_ent;
d1105 2
a1106 3
  entry = ((struct out_section_hash_entry *)
	   bfd_hash_lookup (&output_section_statement_table, name,
			    TRUE, FALSE));
d1113 1
a1113 1
  if (entry->s.output_section_statement.name != NULL)
d1120 1
a1120 1
	  if (entry->s.output_section_statement.constraint != -1
d1122 1
a1122 1
		  || (constraint == entry->s.output_section_statement.constraint
d1124 1
a1124 1
	    return &entry->s.output_section_statement;
d1126 1
a1126 1
	  entry = (struct out_section_hash_entry *) entry->root.next;
d1130 1
a1130 1
	     && strcmp (name, entry->s.output_section_statement.name) == 0);
d1132 2
a1133 5
      entry
	= ((struct out_section_hash_entry *)
	   output_section_statement_newfunc (NULL,
					     &output_section_statement_table,
					     name));
d1143 3
a1145 3
  entry->s.output_section_statement.name = name;
  entry->s.output_section_statement.constraint = constraint;
  return &entry->s.output_section_statement;
@


1.216.2.2
log
@ld/
	Backport:
	2006-05-19  Alan Modra  <amodra@@bigpond.net.au>
	* ldlang.c (lang_size_sections_1): Don't check mem regions for
	os->ignored sections.
ld/testsuite/
	Backport:
	2006-05-19  Alan Modra  <amodra@@bigpond.net.au>
	* ld-scripts/empty-orphan.d: Update again.

	* ld-scripts/empty-orphan.t: Discard .reginfo.
	* ld-scripts/empty-orphan.d: Update.
@
text
@d4210 1
a4210 2
		    if (!os->ignored
			&& !IGNORE_SECTION (os->bfd_section)
@


1.215
log
@bfd/

2006-04-06  H.J. Lu  <hongjiu.lu@@intel.com>

	* elfxx-ia64.c (elfNN_ia64_relax_section): Skip unneeded passes
	with the skip_relax_pass_0 and skip_relax_pass_1 bits in the
	section structure.

include/

2006-04-06  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfdlink.h (bfd_link_info): Replace need_relax_finalize with
	relax_pass.

ld/

2006-04-06  H.J. Lu  <hongjiu.lu@@intel.com>

	* emultempl/ia64elf.em: Set link_info.relax_pass to 2. Remove
	link_info.need_relax_finalize.

	* ldlang.c (relax_sections): New.
	(lang_process): Use. Call relax_sections link_info.relax_pass
	times.

	* ldmain.c (main): Set link_info.relax_pass to 1. Remove
	link_info.need_relax_finalize.
@
text
@d2326 1
d2360 4
d2374 2
@


1.214
log
@	* ldlang.c (lang_map): Print the list of discarded input sections.
	(print_input_section): Change parameter and print zero-sized sections.
	(print_statement): Adjust call to print_input_section.
@
text
@d5414 31
d5541 2
a5542 2
      /* Keep relaxing until bfd_relax_section gives up.  */
      bfd_boolean relax_again;
d5544 4
a5547 1
      do
d5549 2
a5550 25
	  relax_again = FALSE;

	  /* Note: pe-dll.c does something like this also.  If you find
	     you need to change this code, you probably need to change
	     pe-dll.c also.  DJ  */

	  /* Do all the assignments with our current guesses as to
	     section sizes.  */
	  lang_do_assignments ();

	  /* We must do this after lang_do_assignments, because it uses
	     size.  */
	  lang_reset_memory_regions ();

	  /* Perform another relax pass - this time we know where the
	     globals are, so can make a better guess.  */
	  lang_size_sections (&relax_again, FALSE);

	  /* If the normal relax is done and the relax finalize pass
	     is not performed yet, we perform another relax pass.  */
	  if (!relax_again && link_info.need_relax_finalize)
	    {
	      link_info.need_relax_finalize = FALSE;
	      relax_again = TRUE;
	    }
a5551 1
      while (relax_again);
@


1.213
log
@	PR 2434
bfd/
	* elflink.c (struct elf_smash_syms_data, elf_smash_syms): Delete.
	(elf_link_add_object_symbols): Delete unnecessary locals.  Rename
	hash_table -> htab.  Formatting.  Save entire symbol table
	before loading as-needed syms, and restore afterwards if lib not
	needed.  Use bfd_hash_allocate rather than bfd_alloc for sym
	name.  Free some buffers earlier.
	* bfd-in.h (struct bfd_hash_table): Add entsize.
	(bfd_hash_table_init, bfd_hash_table_init_n): Adjust prototype.
	* elf-bfd.h (_bfd_elf_link_hash_table_init): Likewise
	* hash.c (bfd_hash_table_init_n): Add entsize param, save to
	hash table.
	(bfd_hash_table_init): Add param, adjust calls.
	* aoutx.h: Adjust all hash_table_init functions and calls.
	* bfd.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* i386linux.c: Likewise.
	* libaout.h: Likewise.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* linker.c: Likewise.
	* m68klinux.c: Likewise.
	* merge.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* sparclinux.c: Likewise.
	* stabs.c: Likewise.
	* sunos.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* section.c (struct section_hash_entry): Move to..
	* libbfd-in.h: ..here.
	* Makefile.am: Run "make dep-am"
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
binutils/
	* ieee.c (write_ieee_debugging_info): Adjust bfd_hash_table_init calls.
	* wrstabs.c (write_stabs_in_sections_debugging_info): Likewise.
ld/
	* ldcref.c (add_cref): Adjust bfd_hash_table_init calls.
	* ldlang.c (output_statement_table_init, lang_init): Likewise.
	* ldmain.c (add_ysym, add_wrap, add_keepsyms_file): Likewise.
	(undefined_symbol): Likewise.
@
text
@d84 1
d1600 1
d1603 22
d3502 1
a3502 1
print_input_section (lang_input_section_type *in)
a3503 1
  asection *i = in->section;
d3507 1
a3507 1
  if (size != 0)
d3527 1
a3527 1
      if (i->output_section != NULL && (i->flags & SEC_EXCLUDE) == 0)
d3554 1
a3554 1
      if (i->output_section != NULL && (i->flags & SEC_EXCLUDE) == 0)
d3823 1
a3823 1
      print_input_section (&s->input_section);
@


1.213.2.1
log
@ld/
	* ldlang.c (lang_insert_orphan): Correctly handle the case where
	the section is to end up after the section currently at the end
	of the list in output_bfd.
@
text
@d1444 1
a1444 12

      if (!as)
        {
          /* Put the section at the end of the list.  */

	  /* Unlink the section.  */
	  bfd_section_list_remove (output_bfd, snew);

	  /* Now tack it back on in the right place.  */
	  bfd_section_list_append (output_bfd, snew);
        }
      else if (as != snew && as->prev != snew)
@


1.213.2.2
log
@Merge changes between binutils-csl-2_17-branchpoint and
binutils-2_17, except for the addition of generated files to CVS.
@
text
@a83 1
static void print_input_section (asection *);
d872 1
a872 1
struct out_section_hash_entry
d875 1
a875 1
  lang_statement_union_type s;
d880 1
a880 1
static struct bfd_hash_table output_section_statement_table;
d886 3
a888 3
output_section_statement_newfunc (struct bfd_hash_entry *entry, 
				  struct bfd_hash_table *table,
				  const char *string)
d891 1
a891 1
  struct out_section_hash_entry *ret;
d904 10
a913 8
  ret = (struct out_section_hash_entry *) entry;
  memset (&ret->s, 0, sizeof (ret->s));
  ret->s.header.type = lang_output_section_statement_enum;
  ret->s.output_section_statement.subsection_alignment = -1;
  ret->s.output_section_statement.section_alignment = -1;
  ret->s.output_section_statement.block_value = 1;
  lang_list_init (&ret->s.output_section_statement.children);
  lang_statement_append (stat_ptr, &ret->s, &ret->s.header.next);
d919 3
a921 4
    ret->s.output_section_statement.prev
      = ((lang_output_section_statement_type *)
	 ((char *) lang_output_section_statement.tail
	  - offsetof (lang_output_section_statement_type, next)));
d926 1
a926 1
  nextp = &ret->s.output_section_statement.next;
d928 1
a928 1
			 &ret->s,
d934 1
a934 1
output_section_statement_table_init (void)
d936 3
a938 3
  if (!bfd_hash_table_init_n (&output_section_statement_table,
			      output_section_statement_newfunc,
			      sizeof (struct out_section_hash_entry),
d944 1
a944 1
output_section_statement_table_free (void)
d946 1
a946 1
  bfd_hash_table_free (&output_section_statement_table);
d958 1
a958 1
  output_section_statement_table_init ();
d988 1
a988 1
  output_section_statement_table_free ();
d1075 1
a1075 1
  struct out_section_hash_entry *entry;
d1078 2
a1079 3
  entry = ((struct out_section_hash_entry *)
	   bfd_hash_lookup (&output_section_statement_table, name,
			    FALSE, FALSE));
d1086 3
a1088 3
      if (entry->s.output_section_statement.constraint != -1)
	return &entry->s.output_section_statement;
      entry = (struct out_section_hash_entry *) entry->root.next;
d1092 1
a1092 1
	 && strcmp (name, entry->s.output_section_statement.name) == 0);
d1100 2
a1101 2
  struct out_section_hash_entry *entry;
  struct out_section_hash_entry *last_ent;
d1104 2
a1105 3
  entry = ((struct out_section_hash_entry *)
	   bfd_hash_lookup (&output_section_statement_table, name,
			    TRUE, FALSE));
d1112 1
a1112 1
  if (entry->s.output_section_statement.name != NULL)
d1119 1
a1119 1
	  if (entry->s.output_section_statement.constraint != -1
d1121 1
a1121 1
		  || (constraint == entry->s.output_section_statement.constraint
d1123 1
a1123 1
	    return &entry->s.output_section_statement;
d1125 1
a1125 1
	  entry = (struct out_section_hash_entry *) entry->root.next;
d1129 1
a1129 1
	     && strcmp (name, entry->s.output_section_statement.name) == 0);
d1131 2
a1132 5
      entry
	= ((struct out_section_hash_entry *)
	   output_section_statement_newfunc (NULL,
					     &output_section_statement_table,
					     name));
d1142 3
a1144 3
  entry->s.output_section_statement.name = name;
  entry->s.output_section_statement.constraint = constraint;
  return &entry->s.output_section_statement;
a1609 1
  bfd_boolean dis_header_printed = FALSE;
a1611 22
  LANG_FOR_EACH_INPUT_STATEMENT (file)
    {
      asection *s;

      if ((file->the_bfd->flags & (BFD_LINKER_CREATED | DYNAMIC)) != 0
	  || file->just_syms_flag)
	continue;

      for (s = file->the_bfd->sections; s != NULL; s = s->next)
	if (s->output_section == NULL
	    || s->output_section->owner != output_bfd)
	  {
	    if (! dis_header_printed)
	      {
		fprintf (config.map_file, _("\nDiscarded input sections\n\n"));
		dis_header_printed = TRUE;
	      }

	    print_input_section (s);
	  }
    }

a2312 1
      bfd_boolean save_as_needed, save_add_needed;
a2345 4
      save_as_needed = as_needed;
      as_needed = entry->as_needed;
      save_add_needed = add_needed;
      add_needed = entry->add_needed;
a2355 2
      as_needed = save_as_needed;
      add_needed = save_add_needed;
d3489 1
a3489 1
print_input_section (asection *i)
d3491 1
d3495 1
a3495 1

d3515 1
a3515 1
      if (i->output_section != NULL && i->output_section->owner == output_bfd)
d3542 1
a3542 1
      if (i->output_section != NULL && i->output_section->owner == output_bfd)
d3811 1
a3811 1
      print_input_section (s->input_section.section);
a5401 31
/* Relax all sections until bfd_relax_section gives up.  */

static void
relax_sections (void)
{
  /* Keep relaxing until bfd_relax_section gives up.  */
  bfd_boolean relax_again;

  do
    {
      relax_again = FALSE; 

      /* Note: pe-dll.c does something like this also.  If you find
	 you need to change this code, you probably need to change
	 pe-dll.c also.  DJ  */

      /* Do all the assignments with our current guesses as to
	 section sizes.  */
      lang_do_assignments ();

      /* We must do this after lang_do_assignments, because it uses
	 size.  */
      lang_reset_memory_regions ();

      /* Perform another relax pass - this time we know where the
	 globals are, so can make a better guess.  */
      lang_size_sections (&relax_again, FALSE);
    }
  while (relax_again);
}

d5498 2
a5499 2
      /* We may need more than one relaxation pass.  */
      int i = link_info.relax_pass;
d5501 3
a5503 2
      /* The backend can use it to determine the current pass.  */
      link_info.relax_pass = 0;
d5505 23
a5527 4
      while (i--)
	{
	  relax_sections ();
	  link_info.relax_pass++;
d5529 1
@


1.213.2.3
log
@	* ldlang.c (walk_wild): Allow * to glob '/' in wildcarded match.
@
text
@d672 1
a672 1
	  if (fnmatch (file_spec, f->filename, 0) == 0)
@


1.212
log
@	* ldlang.h (lang_output_section_statement_type): Add prev.
	* ldlang.c (output_statement_newfunc): Set os.prev.
	(lang_insert_orphan): Likewise.
	(output_prev_sec_find): Use os.prev.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005
d936 4
a939 2
  if (! bfd_hash_table_init_n (&output_statement_table,
			       output_statement_newfunc, 61))
d979 3
a981 1
			      lang_definedness_newfunc, 3))
@


1.211
log
@2005-12-19  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/2065
	* ldlang.c (output_statement_newfunc): Revert the change made on
	2005-11-16.
	(output_prev_sec_find): Likewsise.
	* ldlang.h (lang_statement_list_type): Likewsise.
@
text
@d915 8
a1300 1
  asection *s = (asection *) NULL;
d1303 1
a1303 3
  for (lookup = &lang_output_section_statement.head->output_section_statement;
       lookup != NULL;
       lookup = lookup->next)
a1306 2
      if (lookup == os)
	return s;
d1309 1
a1309 1
	s = lookup->bfd_section;
d1550 3
d1554 2
@


1.210
log
@bfd/
	* elf-bfd.h (_bfd_generic_match_sections_by_type): Don't define.
	* libbfd-in.h (_bfd_generic_match_sections_by_type): Delete.
	* libbfd.c (_bfd_generic_match_sections_by_type): Delete.
	* targets.c (bfd_match_sections_by_type): Don't define.
	(BFD_JUMP_TABLE_LINK): Remove _bfd_generic_match_sections_by_type.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec, aix5coff64_vec): Likewise.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
ld/
	* ldlang.c (lang_output_section_find_by_flags): Add match_type param.
	Run two passes, first using match_type, second without.
	* ldlang.h (lang_match_sec_type_func): New typedef.
	(lang_output_section_find_by_flags): Update prototype.
	bfd_match_sections_by_type and lang_output_section_find_by_flags.
	* emultempl/pe.em (place_orphan): Likewise.
@
text
@a914 2
  ret->os.prev = &((*lang_output_section_statement.tail)
		   ->output_section_statement);
d1293 1
d1296 3
a1298 1
  for (lookup = os->prev; lookup != NULL; lookup = lookup->prev)
d1302 2
d1306 1
a1306 1
	return lookup->bfd_section;
@


1.209
log
@	* ldlang.c (lang_insert_orphan): Skip first assignment to dot
	in script when looking for place to insert orphan statements.
@
text
@d1150 2
a1151 1
				   lang_output_section_statement_type **exact)
d1169 2
a1170 3
	  if (!bfd_match_sections_by_type (output_bfd,
					   look->bfd_section,
					   sec->owner, sec))
d1180 2
a1181 1
      *exact = found;
d1194 2
a1195 3
	      if (!bfd_match_sections_by_type (output_bfd,
					       look->bfd_section,
					       sec->owner, sec))
a1202 1
      return found;
d1204 1
a1204 2

  if (sec->flags & (SEC_READONLY | SEC_THREAD_LOCAL))
d1213 2
a1214 3
	      if (!bfd_match_sections_by_type (output_bfd,
					       look->bfd_section,
					       sec->owner, sec))
a1222 1
      return found;
d1224 1
a1224 2

  if (sec->flags & SEC_SMALL_DATA)
d1233 2
a1234 3
	      if (!bfd_match_sections_by_type (output_bfd,
					       look->bfd_section,
					       sec->owner, sec))
a1243 1
      return found;
d1245 1
a1245 2

  if (sec->flags & SEC_HAS_CONTENTS)
d1254 2
a1255 3
	      if (!bfd_match_sections_by_type (output_bfd,
					       look->bfd_section,
					       sec->owner, sec))
a1262 1
      return found;
d1264 1
a1264 3

  /* .bss goes last.  */
  for (look = first; look; look = look->next)
d1266 2
a1267 2
      flags = look->flags;
      if (look->bfd_section != NULL)
d1269 11
a1279 5
	  flags = look->bfd_section->flags;
	  if (!bfd_match_sections_by_type (output_bfd,
					   look->bfd_section,
					   sec->owner, sec))
	    continue;
a1280 3
      flags ^= sec->flags;
      if (!(flags & SEC_ALLOC))
	found = look;
d1283 4
a1286 1
  return found;
@


1.208
log
@	* ldlang.c (lang_size_sections_1): Revert 2005-11-16 functional
	changes to section alignment.
	* ldmisc.c (vfinfo): Handle %ld and %lu.
@
text
@d1470 1
d1477 7
a1483 1
		 belong to it.  */
d1497 2
a1498 1
			      && ass->exp->assign.dst[1] == 0)
d1501 1
@


1.207
log
@	* ldlang.h (lang_input_section_type): Remove "ifile" field.
	(lang_insert_orphan, lang_add_section): Update prototypes.
	* ldlang.c (lang_insert_orphan): Remove "file" param.
	(lang_add_section): Likewise.  Update all callers.
	(wild_sort): Get an input section's bfd via "section->owner".
	(size_input_section): Access just_syms_flag via bfd usrdata.
	(lang_place_orphans): Update ldemul_place_orphan call.
	* ldemul.h (ldemul_place_orphan): Remove input_statement param.
	(struct ld_emulation_xfer_struct <place_orphan>): Likewise.
	* ldemul.c (ldemul_place_orphan): Likewise.
	* ldwrite.c (build_link_order): Access just_syms_flag via bfd usrdata.
	* emultempl/armelf.em (arm_elf_set_bfd_for_interworking): Likewise.
	* emultempl/beos.em (sort_by_file_name): Access bfd by section->owner.
	(sort_sections): Likewise.
	(place_orphan): Remove "file" param.  Adjust lang_add_section call.
	* emultempl/elf32.em (place_orphan): Remove "file" param.  Adjust
	lang_add_section and lang_insert_orphan calls.
	* emultempl/hppaelf.em (hppaelf_add_stub_section): Adjust
	lang_add_section call.
	(build_section_lists): Access just_syms_flag via bfd usrdata.
	* emultempl/m68hc1xelf.em (m68hc11elf_add_stub_section): Adjust
	lang_add_section call.
	* emultempl/mmo.em (mmo_place_orphan): Remove "file" param.  Adjust
	lang_add_section and lang_insert_orphan calls.
	* emultempl/pe.em (place_orphan): Likewise.  Access bfd via section
	owner.
	* emultempl/ppc64elf.em (ppc_add_stub_section): Adjust
	lang_add_section call.
	(build_toc_list): Access just_syms_flag via bfd usrdata.
	(build_section_lists): Likewise.
	* emultempl/xtensaelf.em (elf_xtensa_place_orphan): Remove "file"
	param.  Adjust place_orphan call.
	(ld_build_required_section_dependence): Access bfd via section owner.
@
text
@d4140 1
a4140 1
		bfd_vma savedot;
d4191 1
d4193 2
d4197 13
a4209 11
		savedot = newdot;
		newdot = align_power (newdot,
				      os->bfd_section->alignment_power);

		if (newdot != savedot
		    && (config.warn_section_align
			|| os->addr_tree != NULL)
		    && expld.phase != lang_mark_phase_enum)
		  einfo (_("%P: warning: changing start of section"
			   " %s by %lu bytes\n"),
			 os->name, (unsigned long) (newdot - savedot));
@


1.206
log
@	* ldlang.h (lang_output_section_statement_type): Add prev.
	* ldlang.c (new_afile): Always init header.type.
	(output_statement_newfunc): Set os.prev.
	(output_prev_sec_find): Use os.prev.
	(lang_enter_output_section_statement): Formatting.
	(lang_final, lang_add_target, lang_add_fill): Likewise.
	(lang_add_data, lang_add_reloc): Likewise.
	(lang_add_attribute): Only alloc the header.
@
text
@d1316 1
a1316 2
lang_insert_orphan (lang_input_statement_type *file,
		    asection *s,
d1387 1
a1387 1
  lang_add_section (add_child, s, os, file);
d1813 1
a1813 2
		  lang_output_section_statement_type *output,
		  lang_input_statement_type *file)
a1870 1
      new->ifile = file;
d2046 1
a2046 2
	  if (ls->ifile->the_bfd != NULL
	      && bfd_my_archive (ls->ifile->the_bfd) != NULL)
d2048 1
a2048 1
	      ln = bfd_get_filename (bfd_my_archive (ls->ifile->the_bfd));
d2053 1
a2053 1
	      ln = ls->ifile->filename;
d2068 1
a2068 1
		ln = ls->ifile->filename;
d2114 1
a2114 2
		      (lang_output_section_statement_type *) output,
		      file);
d2122 1
a2122 2
			(lang_output_section_statement_type *) output,
			file);
d3900 2
a3901 1
  if (!is->ifile->just_syms_flag && (i->flags & SEC_EXCLUDE) == 0)
d5059 1
a5059 1
					default_common_section, file);
d5062 1
a5062 1
	      else if (ldemul_place_orphan (file, s))
d5069 1
a5069 1
		  lang_add_section (&os->children, s, os, file);
@


1.205
log
@	* ld.texinfo (Forced Output Alignment): Specify that this is an
	alignment increase, not an override.
	* ldlang.c (init_os): Set output section alignment here..
	(lang_add_section): ..rather than here.
	(lang_size_sections_1): Consolidate alignment code.  Warn if section
	alignment affects start address when explicit address given.
@
text
@d786 1
d915 2
a1300 1
  asection *s = (asection *) NULL;
d1303 1
a1303 3
  for (lookup = &lang_output_section_statement.head->output_section_statement;
       lookup != NULL;
       lookup = lookup->next)
a1306 2
      if (lookup == os)
	return s;
d1309 1
a1309 1
	s = lookup->bfd_section;
d5222 3
a5224 4
  current_section =
   os =
    lang_output_section_statement_lookup_1 (output_section_statement_name,
					    constraint);
d5252 1
a5252 2
  lang_output_statement_type *new =
    new_stat (lang_output_statement, stat_ptr);
d5254 1
d5616 1
a5616 2
  lang_target_statement_type *new = new_stat (lang_target_statement,
					      stat_ptr);
d5618 1
a5619 1

d5640 1
a5640 2
  lang_fill_statement_type *new = new_stat (lang_fill_statement,
					    stat_ptr);
d5642 1
d5649 1
d5651 1
a5651 3
  lang_data_statement_type *new = new_stat (lang_data_statement,
					    stat_ptr);

a5653 1

d5686 1
a5686 2
  lang_assignment_statement_type *new = new_stat (lang_assignment_statement,
						  stat_ptr);
d5688 1
d5696 1
a5696 1
  new_statement (attribute, sizeof (lang_statement_union_type), stat_ptr);
@


1.204
log
@	* ldlang.c (struct output_statement_hash_entry): Don't indirect to os.
	(output_statement_newfunc): Rewrite.
	(lang_output_section_find_1): Merge into..
	(lang_output_section_find): ..here.
	(lang_output_section_statement_lookup_1): Rewrite to handle
	multiple sections with the same name.
	(output_statement_table_init): Commonise error message.
	(lang_init, open_output): Likewise.
@
text
@d1723 4
a1947 4
      /* If supplied an alignment, then force it.  */
      if (output->section_alignment != -1)
	output->bfd_section->alignment_power = output->section_alignment;

d4147 2
a4197 14

		    if (os->section_alignment == -1)
		      {
			bfd_vma savedot = newdot;
			newdot = align_power (newdot,
					      os->bfd_section->alignment_power);

			if (newdot != savedot
			    && config.warn_section_align
			    && expld.phase != lang_mark_phase_enum)
			  einfo (_("%P: warning: changing start of section"
				   " %s by %lu bytes\n"),
				 os->name, (unsigned long) (newdot - savedot));
		      }
d4200 12
a4211 5
		/* The section starts here.
		   First, align to what the section needs.  */

		if (os->section_alignment != -1)
		  newdot = align_power (newdot, os->section_alignment);
@


1.203
log
@	* ldlang.h (lang_output_section_statement_type): Rearrange.  Remove
	memspec.  Make "processed" a bitfield.
	(lang_data_statement_type, lang_reloc_statement_type): Rename
	output_vma to output_offset.
	* ldlang.c (lang_output_section_statement_lookup_1): Init
	all_input_readonly.  Don't init memspec.
	(init_os): Remove incorrect comment.
	(print_data_statement, print_reloc_statement): Adjust for
	lang_data_statement_type and lang_reloc_statement_type change.
	(lang_size_sections_1, lang_add_reloc): Likewise.
	* ldwrite.c (build_link_order): Likewise.
@
text
@d874 1
a874 1
  lang_output_section_statement_type *entry;
d881 1
a881 1
/* Support routines for the hash table used by lang_output_section_find_1,
d885 1
a885 1
output_statement_newfunc (struct bfd_hash_entry *entry ATTRIBUTE_UNUSED, 
d887 1
a887 1
			  const char *string ATTRIBUTE_UNUSED)
d889 33
a921 5
  struct output_statement_hash_entry *ret
    = bfd_hash_allocate (table,
			 sizeof (struct output_statement_hash_entry));
  ret->entry = NULL;
  return (struct bfd_hash_entry *) ret;
d929 1
a929 1
    einfo (_("%P%F: Failed to create hash table\n"));
d969 1
a969 1
    einfo (_("%P%F: out of memory during initialization"));
d1059 2
a1060 2
static lang_output_section_statement_type *
lang_output_section_find_1 (const char *const name, int constraint)
a1061 1
  lang_output_section_statement_type *lookup;
d1066 2
a1067 3
	   bfd_hash_lookup (&output_statement_table, name, FALSE,
			    FALSE));
  if (entry == NULL || (lookup = entry->entry) == NULL)
d1073 2
a1074 5
      if (lookup->constraint != -1
	  && (constraint == 0
	      || (constraint == lookup->constraint
		  && constraint != SPECIAL)))
	return lookup;
a1075 1
      lookup = entry ? entry->entry : NULL;
d1079 1
a1079 1
	 && strcmp (name, lookup->name) == 0);
a1083 6
lang_output_section_statement_type *
lang_output_section_find (const char *const name)
{
  return lang_output_section_find_1 (name, 0);
}

d1087 3
a1089 2
  lang_output_section_statement_type *lookup;
  lang_output_section_statement_type **nextp;
d1091 3
a1093 2
  lookup = lang_output_section_find_1 (name, constraint);
  if (lookup == NULL)
d1095 3
a1097 1
      struct output_statement_hash_entry *entry;
d1099 18
a1116 23
      lookup = new_stat (lang_output_section_statement, stat_ptr);
      lookup->region = NULL;
      lookup->lma_region = NULL;
      lookup->fill = 0;
      lookup->block_value = 1;
      lookup->name = name;

      lookup->next = NULL;
      lookup->bfd_section = NULL;
      lookup->processed = FALSE;
      lookup->constraint = constraint;
      lookup->all_input_readonly = FALSE;
      lookup->ignored = FALSE;
      lookup->sectype = normal_section;
      lookup->addr_tree = NULL;
      lang_list_init (&lookup->children);

      lookup->flags = 0;
      lookup->subsection_alignment = -1;
      lookup->section_alignment = -1;
      lookup->load_base = NULL;
      lookup->update_dot_tree = NULL;
      lookup->phdrs = NULL;
d1119 1
a1119 2
	       bfd_hash_lookup (&output_statement_table, name, TRUE,
				FALSE));
d1121 7
a1127 2
	einfo (_("%P%F: bfd_hash_lookup failed creating section `%s'\n"),
	       name);
d1129 3
a1131 11
      entry->entry = lookup;

      /* GCC's strict aliasing rules prevent us from just casting the
	 address, so we store the pointer in a variable and cast that
	 instead.  */
      nextp = &lookup->next;
      lang_statement_append (&lang_output_section_statement,
			     (lang_statement_union_type *) lookup,
			     (lang_statement_union_type **) nextp);
    }
  return lookup;
d2685 1
a2685 1
    einfo (_("%P%F: can not create link hash table: %E\n"));
@


1.202
log
@bfd/

2005-10-23  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/1487
	* elf-bfd.h (_bfd_generic_init_private_section_data): New.
	(_bfd_elf_init_private_section_data): New.

	* elf.c (elf_fake_sections): Don't set SHF_GROUP for
	relocatable link.
	(bfd_elf_set_group_contents): Don't handle relocatable link
	specially.
	(assign_section_numbers): If it isn't called by assembler,
	use the output section of elf_linked_to_section for
	SHF_LINK_ORDER.
	(_bfd_elf_init_private_section_data): New.
	(_bfd_elf_copy_private_section_data): Call it.

	* libbfd-in.h (_bfd_generic_init_private_section_data): New.

	* libbfd.c (_bfd_generic_init_private_section_data): New.

	* targets.c (BFD_JUMP_TABLE_COPY): Add
	_bfd_generic_init_private_section_data.
	(bfd_init_private_section_data): Likewise.

	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.

ld/

2005-10-23  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/1487
	* emultempl/elf32.em (gld${EMULATION_NAME}_place_orphan): Call
	bfd_match_sections_by_type to match section types.

	* ldlang.c (init_os): Take the input section. Call
	bfd_init_private_section_data if the input section isn't NULL.
	(exp_init_os): Pass NULL to init_os.
	(map_input_to_output_sections): Likewise.
	(lang_add_section): Pass the input section to init_os.

ld/testsuite/

2005-10-23  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/1487
	* ld-ia64/tlspic.rd: Updated.
@
text
@d1090 1
a1095 1
      lookup->memspec = NULL;
a1693 3

  /* We initialize an output sections output offset to minus its own
     vma to allow us to output a section through itself.  */
d3545 1
a3545 1
  addr = data->output_vma;
d3612 1
a3612 1
  addr = reloc->output_vma;
d4292 1
a4292 1
	    s->data_statement.output_vma =
d4330 1
a4330 1
	    s->reloc_statement.output_vma =
d5680 1
a5680 1
  p->output_vma = 0;
@


1.201
log
@bfd/

2005-10-15  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/1467
	* elf-bfd.h (_bfd_elf_match_sections_by_type): New.
	(_bfd_generic_match_sections_by_type): New. Defined.

	* elf.c (_bfd_elf_match_sections_by_type): New.

	* libbfd-in.h (_bfd_generic_match_sections_by_type): New.

	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.

	* libbfd.c (_bfd_generic_match_sections_by_type): New.

	* targets.c (BFD_JUMP_TABLE_LINK): Initialize
	_bfd_match_sections_by_type with
	_bfd_generic_match_sections_by_type.
	(bfd_target): Add _bfd_match_sections_by_type.

ld/

2005-10-15  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/1467
	* emultempl/elf32.em: Include "elf-bfd.h".
	(gld${EMULATION_NAME}_place_orphan): Check section type and
	don't use section name for ELF input sections.

	* ld.texinfo: Document orphan section processing.

	* ldlang.c (lang_output_section_find_by_flags): Match section
	types by calling bfd_match_sections_by_type.
@
text
@d1677 1
a1677 1
init_os (lang_output_section_statement_type *s)
d1714 5
d1764 1
a1764 1
	      init_os (os);
d1841 1
a1841 1
	init_os (output);
d3107 1
a3107 1
	    init_os (os);
d3121 1
a3121 1
	    init_os (os);
d3125 1
a3125 1
	    init_os (os);
d3153 1
a3153 1
		init_os (aos);
@


1.200
log
@	* ld.texino: Describe double-quoted string syntax for version
	nodes.
	* ldlang.h (lang_new_vers_pattern): Add literal_p parameter.
	* ldgram.y (vers_defns): Allow NAME as well as VERS_IDENTIFIER.
	Adjust calls to lang_new_vers_pattern to pass literal_p argument.
	* ldlang.c (lang_vers_match): Fix indentation.  Do not glob-match
	version nodes without a pattern.
	(lang_new_vers_pattern): Add literal_p parameter.
	(lang_do_version_exports_section): Pass it.

	* ld-elfvers/vers.exp: Add vers31.
	* ld-elfvers/vers31.c: New file.
	* ld-elfvers/vers31.dsym: Likewise.
	* ld-elfvers/vers31.map: Likewise.
	* ld-elfvers/vers31.ver: Likewise.
@
text
@d1152 7
a1158 1
	flags = look->bfd_section->flags;
d1177 7
a1183 1
	    flags = look->bfd_section->flags;
d1199 7
a1205 1
	    flags = look->bfd_section->flags;
d1222 7
a1228 1
	    flags = look->bfd_section->flags;
d1246 7
a1252 1
	    flags = look->bfd_section->flags;
d1266 7
a1272 1
	flags = look->bfd_section->flags;
@


1.199
log
@Fix malformed error message.
* ldlang.c (lang_startup): Add missing ": " to einfo call.
@
text
@d6225 2
a6226 2
		else
		  expr = expr->next;
d6237 2
a6238 2
		else
		  expr = expr->next;
d6249 2
a6250 2
		else
		  expr = expr->next;
d6263 1
a6263 1
  while (expr)
d6267 3
a6280 1
      expr = expr->next;
d6335 3
a6337 1
/* This is called for each variable name or match expression.  */
d6342 2
a6343 1
		       const char *lang)
d6349 1
a6349 1
  ret->pattern = new;
d6352 1
a6352 1
  ret->symbol = realsymbol (new);
d6636 1
a6636 1
	  greg = lang_new_vers_pattern (greg, p, NULL);
d6646 1
a6646 1
  lreg = lang_new_vers_pattern (NULL, "*", NULL);
@


1.198
log
@ld/

2005-09-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldlang.c (output_statement_hash_entry): New type.
	(output_statement_table): New variable for hash table.
	(output_statement_newfunc): New function.
	(output_statement_table_init): Likewise.
	(output_statement_table_free): Likewise.
	(lang_init): Call output_statement_table_init.
	(lang_finish): Renamed to ...
	(lang_end): This.
	(lang_process): Updated.
	(lang_finish): New function.
	(lang_output_section_find_1): Use hash table.
	(lang_output_section_statement_lookup_1): Likewise.

	* ldlang.h (lang_finish): New.

	* ldmain.c (main): Call lang_finish.

ld/testsuite/

2005-09-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-elf/sec64k.exp: Enabled for all ELF targets.
@
text
@d5666 1
a5666 1
      einfo (_("%P%Fmultiple STARTUP files\n"));
@


1.197
log
@	* ldlang.h (lang_output_section_statement_struct): Change type of
	"processed" to bfd_boolean.
	* ldexp.c (fold_name): Update references to os->processed.
	* ldlang.c (lang_output_section_statement_lookup_1): Likewise.
	(lang_size_sections_1): Likewise.
	(lang_reset_memory_regions): Likewise.
@
text
@d871 39
d919 2
d944 6
d1035 8
d1044 2
a1045 3
  for (lookup = &lang_output_section_statement.head->output_section_statement;
       lookup != NULL;
       lookup = lookup->next)
d1047 1
a1047 2
      if (strcmp (name, lookup->name) == 0
	  && lookup->constraint != -1
d1052 2
d1055 4
d1077 2
d1103 9
d4710 1
a4710 1
lang_finish (void)
d5486 1
a5486 1
  lang_finish ();
@


1.196
log
@	PR ld/1353
	* ldlang.c (lang_size_sections_1): Process addr_tree earlier,
	so that unused output section statements affect dot.
@
text
@d1027 1
a1027 1
      lookup->processed = 0;
d3979 1
a3979 1
		os->processed = -1;
a3980 1
		os->processed = 0;
d4107 1
a4107 1
	    os->processed = 1;
d5165 1
a5165 1
    os->processed = 0;
@


1.195
log
@bfd/
	* elf32-ppc.c (struct elf_linker_section): Replace sym_val field
	with sym.
	(ppc_elf_relocate_section): Adjust for above.
	(create_sdata_sym): New function.
	(ppc_elf_create_linker_section): Call it.
	(ppc_elf_check_relocs): Correct has_sda_refs and non_got_refs.
	Create sdata syms for all SDA relocs.
	(ppc_elf_adjust_dynamic_symbol): Don't special case _SDA_BASE_
	and _SDA2_BASE_.
	(ppc_elf_set_sdata_syms): Delete.
	* elflink.c (bfd_elf_size_dynamic_sections): Don't create DT_INIT
	and DT_FINI tags unless associated section has input.
	(bfd_elf_set_symbol, _bfd_elf_provide_symbol): Delete.
	(_bfd_elf_provide_section_bound_symbols): Delete.
	* bfd-in.h (_bfd_elf_provide_symbol): Delete.
	(_bfd_elf_provide_section_bound_symbols): Delete.
	* bfd-in2.h: Regenerate.
ld/
	* ldemul.c (ldemul_do_assignments, do_assignments_default): Delete.
	* ldemul.h (ldemul_do_assignments, do_assignments_default): Delete.
	(struct ld_emulation_xfer_struct): Remove do_assignments field.
	* ldlang.c (lang_do_assignments): Don't call ldemul_do_assignments.
	* emulparams/elf32ppc.sh (SDATA_START_SYMBOLS): New.
	(SDATA2_START_SYMBOLS, SBSS_START_SYMBOLS, SBSS_END_SYMBOLS): New.
	* emultempl/aix.em (ld_*_emulation): Delete do_assignments init.
	* emultempl/armcoff.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/generic.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/gld960c.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68kcoff.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/ticoff.em: Likewise.
	* emultempl/vanilla.em: Likewise.
	* emultempl/elf32.em: Likewise.
	(gld*_provide_bound_symbols): Delete.
	(gld*_provide_init_fini_syms): Delete.
	(gld*_before_allocation): Don't call ldemul_do_assignments.
	* emultempl/ppc32elf.em (ppc_do_assignments): Delete.
	(LDEMUL_DO_ASSIGNMENTS): Delete.
	* scripttempl/elf.sc: Provide init/fini syms.  Add SBSS_START_SYMBOLS,
	SBSS_END_SYMBOLS, SDATA2_START_SYMBOLS.
@
text
@d3977 15
d4021 1
a4092 16
		else
		  {
		    newdot = dot;
		    os->processed = -1;
		    exp_fold_tree (os->addr_tree, bfd_abs_section_ptr,
				   &newdot);
		    os->processed = 0;

		    if (!expld.result.valid_p
			&& expld.phase != lang_mark_phase_enum)
		      einfo (_("%F%S: non constant or forward reference"
			       " address expression for section %s\n"),
			     os->name);

		    newdot = expld.result.value + expld.result.section->vma;
		  }
@


1.194
log
@	* ldlang.c (exp_init_os): Handle etree_provide.
	* emulparams/armelf.sh (OTHER_END_SYMBOLS): Rename from..
	(OTHER_BSS_END_SYMBOLS): ..this.
	* emulparams/armelf_linux.sh: Likewise.
	* emulparams/armnto.sh: Likewise.
	* emulparams/criself.sh: Likewise.
	* emulparams/crislinux.sh: Likewise.
	* emulparams/elf32frv.sh: Likewise.
	* emulparams/elf32mcore.sh: Likewise.
	* emulparams/elf32ppc.sh: Likewise.
	* emulparams/elf32ppclinux.sh: Likewise.
	* emulparams/hppa64linux.sh: Likewise.
	* scripttempl/armbpabi.sc: Substitute $OTHER_END_SYMBOLS, not
	$OTHER_BSS_END_SYMBOLS.
	* scripttempl/elf32sh-symbian.sc: Likewise.
	* scripttempl/elf_chaos.sc: Likewise.
	* scripttempl/iq2000.sc: Likewise.
	* scripttempl/xstormy16.sc: Likewise.
	* scripttempl/elf.sc: Likewise.  Delete __bss_start comment.
	* scripttempl/elfxtensa.sc: Likewise.
@
text
@d3059 1
a3059 3
  /* Run lang_size_sections (if not already done) to ensure that all
     symbols defined in the linker script are put in the bfd hash
     table.  */
a4591 1
  ldemul_do_assignments ();
@


1.193
log
@* ldlang.c (lang_output_section_statement_lookup_1): Don't cast a
unary & address operator, as that breaks GCC's strict aliasing
rules.
@
text
@d1619 1
@


1.192
log
@	* ldemul.c (ldemul_do_assignments): New function.
	(do_assignments_default): New function.
	* ldemul.h (ldemul_do_assignments): Declare.
	(do_assignments_default): Declare.
	(struct ld_emulation_xfer_struct): Add do_assignments.
	* ldlang.c (lang_do_assignments) Call ldemul_do_assignments.
	* emultempl/aix.em (ld_*_emulation): Init do_assignments field.
	* emultempl/armcoff.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/generic.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/gld960c.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68kcoff.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/ticoff.em: Likewise.
	* emultempl/vanilla.em: Likewise.
	* emultempl/elf32.em: Likewise, to call gld*_provide_init_fini_syms.
	(gld*_find_exp_assignment): Adjust bfd_elf_record_link_assignment call.
@
text
@d1013 1
d1042 4
d1048 1
a1048 1
			     (lang_statement_union_type **) &lookup->next);
@


1.191
log
@bfd/
	* bfd-in.h (_bfd_elf_fix_excluded_sec_syms): Declare.
	(_bfd_elf_provide_section_bound_symbols): Remove param name.
	Formatting.
	* bfd-in2.h: Regenerate.
	* elflink.c (bfd_elf_gc_sections): Don't call generic function.
	(_bfd_elf_provide_symbol): Formatting.
	(_bfd_elf_provide_section_bound_symbols): Remove all hacks, just
	create section relative syms.
	(fix_syms, _bfd_elf_fix_excluded_sec_syms): New functions.
	* elf32-ppc.c (ppc_elf_set_sdata_syms): Use
	_bfd_elf_provide_section_bound_symbols.
	* reloc.c (bfd_mark_used_section): Delete.
	(bfd_generic_gc_sections): Don't call the above.
ld/
	* ldlang.c (strip_excluded_output_sections): Don't call
	bfd_gc_sections.
	* emultempl/elf32.em (gld*_provide_bound_symbols): Move.
	(gld*_provide_init_fini_syms): Move.
	(gld*_before_allocation): Call the above from here..
	(gld*_finish): ..not here.  Call _bfd_elf_fix_excluded_sec_syms.
	* emultempl/hppaelf.em (hppaelf_finish): Likewise.
	* emultempl/ppc64elf.em (ppc_finish): Likewise.
@
text
@d4588 1
@


1.190
log
@	* ldlang.c (wild_sort): Formatting.
	(strip_excluded_output_sections): Strip zero size sections here.
	* emultempl/elf32.em (gld*_strip_empty_sections): Delete.
	(gld*_finish): Don't call the above.
	* emultempl/hppaelf.em (hppaelf_finish): Likewise.
	* emultempl/ppc64elf.em (ppc_finish): Likewise.
@
text
@a3051 1
  unsigned int gc_sections;
a3063 7
  /* Now call into bfd_gc_sections to mark all sections defining global
     symbols with SEC_KEEP.  */
  gc_sections = link_info.gc_sections;
  link_info.gc_sections = 0;
  bfd_gc_sections (output_bfd, &link_info);
  link_info.gc_sections = gc_sections;

@


1.189
log
@	* ld.h (lang_phase_type): Move to..
	* ldexp.h: ..here.  Add lang_mark_phase_enum.
	(node_type): Remove etree_undef and etree_unspec.
	(exp_data_seg): Delete.
	(struct ldexp_control, expld): New.
	(invalid, exp_mark_used_section): Delete.
	(exp_fold_tree, exp_get_vma, exp_get_value_int, exp_get_fill,
	exp_get_abs_int): Update prototypes.
	* ldexp.c (assigning_to_dot): Delete.
	(expld): Define.
	(make_abs): Operate directly on expld.result.  Update all callers.
	(new_abs): Likewise.  Return void.
	(new_rel_from_abs): Rename from new_rel_from_section.
	(new_rel, new_rel_from_abs): Operate on expld.result and return void.
	Update all callers.
	(fold_unary): Operate on expld.result and return void.  Remove
	"current_section", "allocation_done", "dot", "dotp" and "mark_used"
	params.  Update all callers.
	(fold_binary, fold_trinary, fold_name, exp_fold_tree_1): Likewise.
	(fold_unary <ALIGN_K>): Ensure alignment is absolute.
	(fold_unary <ABSOLUTE>): Use make_abs.
	(fold_unary <DATA_SEGMENT_END>): Evaluate mark_phase as for
	allocating_phase.
	(fold_binary <DATA_SEGMENT_ALIGN, DATA_SEGMENT_RELRO_END, >): Ditto.
	(fold_binary <'%','/'>): Don't error if marking.
	(fold_name <SIZEOF_HEADERS>): Don't call bfd_sizeof_headers when
	marking.
	(fold_name <NAME>): Remove FIXME; -R is handled correctly.  Don't
	error when marking.
	(fold_name <ADDR, LOADADDR, SIZEOF>): Don't set SEC_KEEP.
	(exp_fold_tree_1): Don't error when marking.
	(exp_fold_tree_1 <etree_rel>): Evaluate in all phases except first.
	(exp_fold_tree_1 <etree_assign to dot>): Don't check for NULL
	current section, instead check for NULL dotp.
	(exp_fold_tree_1 <etree_provide>): Don't evaluate the assignment
	source unless the symbol is referenced and undefined.
	(exp_fold_tree): Remove "allocation_done" and "dot" params.  Save
	params to expld.
	(exp_fold_tree_no_dot): Remove "current_section", "allocation_done
	and "mark_used" params.  Save params to expld.  Update all callers.
	(exp_assop): Do without temp var.
	(exp_print_tree <etree_undef>): Delete code.
	(exp_get_vma): Remove "allocation_done" param.  Correct error return.
	(exp_get_fill, exp_get_abs_int): Likewise.
	(exp_get_value_int): Remove "allocation_done" param.
	(exp_mark_used_section): Delete.
	* ldgram.y (fill_exp): Update exp_get_fill call.
	(origin_spec, length_spec): Update exp_get_vma call.
	* ldlang.c (lang_init): Don't bother clearing lang_statement_iteration.
	(lang_mark_used_section_1, lang_mark_used_section): Delete.
	(strip_excluded_output_sections): Call one_lang_size_sections_pass in
	marking mode.  Merge old lang_mark_used_section code.  Correct handling
	of output sections with excluded input sections and data statements.
	Don't drop non-zero sized sections.  Don't zap os->bfd_section.
	Do set SEC_EXCLUDE when appropriate.
	(print_output_section_statement): Update for changed ldexp.c
	interface.
	(print_assignment, lang_size_sections_1): Likewise.
	(lang_do_assignments_1, lang_enter_output_section_statement): Likewise.
	(lang_new_phdr, lang_record_phdrs): Likewise.
	(lang_size_sections): Likewise.
	(insert_pad): Use following statement if it is a pad, rather than
	creating a new one.
	(lang_size_sections_1 <lang_output_section_statement_enum>): Do
	process ignored output section to set vma and lma, but don't
	update dot for these sections.  Don't error if marking.
	(lang_size_sections_1 <lang_assignment_statement_enum>): Don't
	update dot for ignored sections.
	(lang_size_sections_1 <lang_data_statement_enum>): Don't mark absolute
	section with SEC_ALLOC.
	(one_lang_size_sections_pass): New function.
	(lang_size_sections): Remove first five params.  Set expld.phase on
	entry and exit.   Use one_lang_size_sections_pass.
	(lang_do_assignments): Remove all params.  Update all callers.
	(lang_reset_memory_regions): Clear os->processed for all output
	section statements.
	* ldlang.h (lang_do_assignments): Update prototype.
	(lang_size_sections): Likewise.
	(one_lang_size_sections_pass): Declare.
	* pe-dll.c (pe_dll_fill_sections, pe_exe_fill_sections): Update
	lang_size_sections and lang_do_assignments calls.
	* emultempl/elf32.em (layout_sections_again): Likewise.
	* emultempl/ppc64elf.em (ppc_before_allocation): Use
	one_lang_size_sections_pass.
@
text
@d1963 2
a1964 5
	{
	  if (compare_section (sec->spec.sorted, section,
			       ls->section) < 0)
	    break;
	}
d3086 10
a3095 2
      exclude = TRUE;
      if (output_section->map_head.s != NULL)
d3099 3
a3101 3
	  for (s = output_section->map_head.s; s != NULL;
	       s = s->map_head.s)
	    if ((s->flags & SEC_EXCLUDE) == 0)
d3106 1
d3108 3
a3110 3
	  output_section->map_head.link_order = NULL;
	  output_section->map_tail.link_order = NULL;
	}
d3112 1
a3112 4
      if (exclude
	  && (output_section->flags & SEC_KEEP) == 0
	  && output_section->rawsize == 0
	  && !bfd_is_abs_section (output_section))
d3118 2
a3119 7

	  if (!bfd_section_removed_from_list (output_bfd,
					      output_section))
	    {
	      bfd_section_list_remove (output_bfd, output_section);
	      output_bfd->section_count--;
	    }
@


1.188
log
@2005-06-04  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 992
	* ldexp.c (exp_mark_used_section): Set SEC_KEEP on current
	section for etree_assign, etree_provide and etree_provided.
	Call fold_binary on etree_binary.

	* ldlang.c (lang_mark_used_section_1): Handle load base.
@
text
@d104 3
a900 3

  /* Callers of exp_fold_tree need to increment this.  */
  lang_statement_iteration = 0;
a3046 89
/* Worker function for lang_mark_used_section.  Recursiveness goes
   here.  */

static void
lang_mark_used_section_1
  (lang_statement_union_type *s,
   lang_output_section_statement_type *output_section_statement)
{
  for (; s != NULL; s = s->header.next)
    {
      switch (s->header.type)
	{
	case lang_constructors_statement_enum:
	  break;

	case lang_output_section_statement_enum:
	  {
	    lang_output_section_statement_type *os;

	    os = &(s->output_section_statement);
	    if (os->bfd_section != NULL)
	      {
		lang_mark_used_section_1 (os->children.head, os);
		if (os->load_base)
		  exp_mark_used_section (os->load_base,
					 bfd_abs_section_ptr);
	      }
	  }
	  break;
	case lang_wild_statement_enum:
	  lang_mark_used_section_1 (s->wild_statement.children.head,
				    output_section_statement);

	  break;

	case lang_object_symbols_statement_enum:
	case lang_output_statement_enum:
	case lang_target_statement_enum:
	  break;
	case lang_data_statement_enum:
	  exp_mark_used_section (s->data_statement.exp,
				 bfd_abs_section_ptr);
	  break;

	case lang_reloc_statement_enum:
	  break;

	case lang_input_section_enum:
	  break;

	case lang_input_statement_enum:
	  break;
	case lang_fill_statement_enum:
	  break;
	case lang_assignment_statement_enum:
	  exp_mark_used_section (s->assignment_statement.exp,
				 output_section_statement->bfd_section);
	  break;
	case lang_padding_statement_enum:
	  break;

	case lang_group_statement_enum:
	  lang_mark_used_section_1 (s->group_statement.children.head,
				    output_section_statement);
	  break;

	default:
	  FAIL ();
	  break;
	case lang_address_statement_enum:
	  break;
	}
    }
}

static void
lang_mark_used_section (void)
{
  unsigned int gc_sections = link_info.gc_sections;

  /* Callers of exp_fold_tree need to increment this.  */
  lang_statement_iteration++;
  lang_mark_used_section_1 (statement_list.head, abs_output_section);

  link_info.gc_sections = 0;
  bfd_gc_sections (output_bfd, &link_info);
  link_info.gc_sections = gc_sections;
}

d3055 1
d3057 17
a3073 1
  lang_mark_used_section ();
d3089 1
a3089 1
      exclude = FALSE;
d3097 4
a3100 1
	      break;
a3103 3

	  if (s == NULL)
	    exclude = TRUE;
d3107 9
a3115 10
	  || (output_section->linker_has_input == 0
	      && ((output_section->flags
		   & (SEC_KEEP | SEC_HAS_CONTENTS)) == 0)))
	{
	  if (exclude)
	    os->bfd_section = NULL;
	  else
	    /* We don't set bfd_section to NULL since bfd_section of the
	     * removed output section statement may still be used.  */
	    os->ignored = TRUE;
d3164 1
a3164 1
				      "load base", lang_final_phase_enum);
a3233 1
  etree_value_type result;
d3253 2
a3254 3
  result = exp_fold_tree (tree, output_section->bfd_section,
			  lang_final_phase_enum, print_dot, &print_dot);
  if (result.valid_p)
d3260 1
a3260 1
	  value = result.value;
d3262 2
a3263 2
	  if (result.section)
	    value += result.section->vma;
d3279 2
a3280 2
	      if (result.section)
	      value += result.section->vma;
d3749 1
a3749 1
  lang_statement_union_type *pad;
d3751 4
a3754 3
  pad = ((lang_statement_union_type *)
	 ((char *) ptr - offsetof (lang_statement_union_type, header.next)));
  if (ptr != &statement_list.head
d3758 7
a3764 2
      /* Use the existing pad statement.  The above test on output
	 section is probably redundant, but it doesn't hurt to check.  */
d3979 1
a3979 1
	    bfd_vma after;
d3983 1
a3983 1
	    if (os->bfd_section == NULL || os->ignored)
d4043 2
a4044 1
			    || lang_memory_region_list->next != NULL))
d4067 1
a4067 1
		    dot = os->region->current;
d4071 7
a4077 7
			bfd_vma olddot;

			olddot = dot;
			dot = align_power (dot,
					   os->bfd_section->alignment_power);

			if (dot != olddot && config.warn_section_align)
d4079 2
a4080 2
				   " %s by %u bytes\n"),
				 os->name, (unsigned int) (dot - olddot));
d4085 1
a4085 2
		    etree_value_type r;

d4087 2
a4088 4
		    r = exp_fold_tree (os->addr_tree,
				       bfd_abs_section_ptr,
				       lang_allocating_phase_enum,
				       dot, &dot);
d4091 2
a4092 1
		    if (!r.valid_p)
d4097 1
a4097 1
		    dot = r.value + r.section->vma;
d4104 1
a4104 1
		  dot = align_power (dot, os->section_alignment);
d4106 1
a4106 1
		bfd_set_section_vma (0, os->bfd_section, dot);
d4112 11
a4122 1
				  os->fill, dot, relax, check_regions);
d4126 1
a4126 1
	    after = ((os->bfd_section->vma
d4131 1
a4131 5
	    if (bfd_is_abs_section (os->bfd_section))
	      ASSERT (after == os->bfd_section->vma);
	    else
	      os->bfd_section->size
		= TO_SIZE (after - os->bfd_section->vma);
a4132 1
	    dot = os->bfd_section->vma;
a4138 2
	    os->processed = 1;

d4140 1
a4140 2
	      exp_fold_tree (os->update_dot_tree, bfd_abs_section_ptr,
			     lang_allocating_phase_enum, dot, &dot);
d4198 1
a4198 2
	    exp_fold_tree (s->data_statement.exp, bfd_abs_section_ptr,
			   lang_allocating_phase_enum, dot, &dot);
a4239 1

a4243 1

d4250 1
d4254 1
d4273 1
d4276 1
d4283 1
a4289 2
			   lang_allocating_phase_enum,
			   dot,
d4292 1
a4292 1
	    if (newdot != dot)
d4311 8
a4319 8

		/* If dot is advanced, this implies that the section should
		   have space allocated to it, unless the user has explicitly
		   stated that the section should never be loaded.  */
		if (!(output_section_statement->flags
		      & (SEC_NEVER_LOAD | SEC_ALLOC)))
		  output_section_statement->bfd_section->flags |= SEC_ALLOC;

d4362 2
a4363 9
bfd_vma
lang_size_sections
  (lang_statement_union_type *s,
   lang_output_section_statement_type *output_section_statement,
   lang_statement_union_type **prev,
   fill_type *fill,
   bfd_vma dot,
   bfd_boolean *relax,
   bfd_boolean check_regions)
d4365 4
a4368 1
  bfd_vma result;
d4370 5
a4374 2
  /* Callers of exp_fold_tree need to increment this.  */
  lang_statement_iteration++;
d4376 3
a4378 5
  exp_data_seg.phase = exp_dataseg_none;
  result = lang_size_sections_1 (s, output_section_statement, prev, fill,
				 dot, relax, check_regions);
  if (exp_data_seg.phase == exp_dataseg_end_seen
      && link_info.relro && exp_data_seg.relro_end)
d4381 1
a4381 1
	 to put exp_data_seg.relro on a (common) page boundary.  */
d4384 5
a4388 5
      exp_data_seg.phase = exp_dataseg_relro_adjust;
      old_min_base = exp_data_seg.min_base;
      maxpage = exp_data_seg.maxpagesize;
      exp_data_seg.base += (-exp_data_seg.relro_end
			    & (exp_data_seg.pagesize - 1));
d4390 3
a4392 3
      relro_end = (exp_data_seg.relro_end + exp_data_seg.pagesize - 1)
		  & ~(exp_data_seg.pagesize - 1);
      if (old_min_base + maxpage < exp_data_seg.base)
d4394 1
a4394 1
	  exp_data_seg.base -= maxpage;
d4397 2
a4398 3
      result = lang_size_sections_1 (s, output_section_statement, prev, fill,
				     dot, relax, check_regions);
      if (exp_data_seg.relro_end > relro_end)
d4409 2
a4410 2
	    if (sec->vma >= exp_data_seg.base
		&& sec->vma < exp_data_seg.relro_end
d4414 1
a4414 1
	  if (((bfd_vma) 1 << max_alignment_power) < exp_data_seg.pagesize)
d4416 1
a4416 1
	      if (exp_data_seg.base - (1 << max_alignment_power)
d4418 3
a4420 5
		exp_data_seg.base += exp_data_seg.pagesize;
	      exp_data_seg.base -= (1 << max_alignment_power);
	      result = lang_size_sections_1 (s, output_section_statement,
					     prev, fill, dot, relax,
					     check_regions);
d4423 2
a4424 2
      link_info.relro_start = exp_data_seg.base;
      link_info.relro_end = exp_data_seg.relro_end;
d4426 1
a4426 1
  else if (exp_data_seg.phase == exp_dataseg_end_seen)
d4432 2
a4433 2
      first = -exp_data_seg.base & (exp_data_seg.pagesize - 1);
      last = exp_data_seg.end & (exp_data_seg.pagesize - 1);
d4435 6
a4440 8
	  && ((exp_data_seg.base & ~(exp_data_seg.pagesize - 1))
	      != (exp_data_seg.end & ~(exp_data_seg.pagesize - 1)))
	  && first + last <= exp_data_seg.pagesize)
	{
	  exp_data_seg.phase = exp_dataseg_adjust;
	  lang_statement_iteration++;
	  result = lang_size_sections_1 (s, output_section_statement, prev,
					 fill, dot, relax, check_regions);
d4444 1
a4444 1
  return result;
d4489 1
a4489 2
		      = exp_get_abs_int (os->load_base, 0, "load base",
					 lang_final_phase_enum);
d4494 1
a4499 1

d4506 1
d4508 6
a4513 11
	  {
	    etree_value_type value;

	    value = exp_fold_tree (s->data_statement.exp,
				   bfd_abs_section_ptr,
				   lang_final_phase_enum, dot, &dot);
	    if (!value.valid_p)
	      einfo (_("%F%P: invalid data statement\n"));
	    s->data_statement.value
	      = value.value + value.section->vma;
	  }
d4541 6
a4546 10
	  {
	    etree_value_type value;

	    value = exp_fold_tree (s->reloc_statement.addend_exp,
				   bfd_abs_section_ptr,
				   lang_final_phase_enum, dot, &dot);
	    s->reloc_statement.addend_value = value.value;
	    if (!value.valid_p)
	      einfo (_("%F%P: invalid reloc statement\n"));
	  }
d4561 1
d4565 1
d4567 4
a4570 7
	  {
	    exp_fold_tree (s->assignment_statement.exp,
			   output_section_statement->bfd_section,
			   lang_final_phase_enum,
			   dot,
			   &dot);
	  }
a4571 1
	  break;
a4579 1

d4585 1
a4588 1

d4594 1
a4594 5
lang_do_assignments
  (lang_statement_union_type *s,
   lang_output_section_statement_type *output_section_statement,
   fill_type *fill,
   bfd_vma dot)
a4595 1
  /* Callers of exp_fold_tree need to increment this.  */
d4597 1
a4597 1
  lang_do_assignments_1 (s, output_section_statement, fill, dot);
d5137 1
a5137 1
    topower (exp_get_value_int (subalign, -1, "subsection alignment", 0));
d5139 1
a5139 1
    topower (exp_get_value_int (align, -1, "section alignment", 0));
d5161 1
d5169 5
d5360 1
a5360 3
  lang_size_sections (statement_list.head, abs_output_section,
		      &statement_list.head, 0, 0, NULL,
		      command_line.relax ? FALSE : TRUE);
d5378 1
a5378 2
	  lang_do_assignments (statement_list.head, abs_output_section,
			       NULL, 0);
d5386 1
a5386 2
	  lang_size_sections (statement_list.head, abs_output_section,
			      &statement_list.head, 0, 0, &relax_again, FALSE);
d5399 1
a5399 1
      lang_do_assignments (statement_list.head, abs_output_section, NULL, 0);
d5401 1
a5401 2
      lang_size_sections (statement_list.head, abs_output_section,
			  &statement_list.head, 0, 0, NULL, TRUE);
d5414 1
a5414 1
  lang_do_assignments (statement_list.head, abs_output_section, NULL, 0);
d5802 1
a5802 2
  n->type = exp_get_value_int (type, 0, "program header type",
			       lang_final_phase_enum);
d5878 1
a5878 2
	flags = exp_get_vma (l->flags, 0, "phdr flags",
			     lang_final_phase_enum);
d5883 1
a5883 2
	at = exp_get_vma (l->at, 0, "phdr load address",
			  lang_final_phase_enum);
@


1.187
log
@	* ldexp.h (etree_value_type): Use "asection *" in place of
	"struct lang_output_section_statement_struct *" for "section".
	(exp_fold_tree): Likewise.
	(exp_mark_used_section): Likewise.
	* ldexp.c (new_rel, new_rel_from_section, fold_unary, fold_binary,
	fold_trinary, fold_name, exp_fold_tree_1, exp_fold_tree,
	exp_mark_used_section): Likewise for "current_section" param.
	(make_abs, new_abs, exp_binop, exp_unop, exp_get_vma, exp_get_fill,
	exp_get_abs_int): Adjust for above changes.
	* ldlang.c (lang_mark_used_section_1, print_assignment,
	lang_size_sections_1, lang_do_assignments_1): Likewise.
	* ldexp.c (fold_name): Init entire result struct.
@
text
@d3068 6
a3073 1
	      lang_mark_used_section_1 (os->children.head, os);
@


1.186
log
@ld:
	* ldlang.c (entry_symbol_default): New file-scope global.
	(lang_finish): Use it, not a hardwired "start".
	(lang_default_entry): Set it.
	* ldlang.h: Declare lang_default_entry.
	* emultempl/beos.em, emultempl/pe.em: Use lang_default_entry,
	not lang_add_entry, to override default entry point symbol.

ld/testsuite:
	* ld-scripts/align.exp: Mark align1 XFAIL on PECOFF targets.
	* ld-scripts/data.exp: Mark data UNSUPPORTED on a.out targets.
	* ld-scripts/provide.exp, ld-scripts/size.exp: Mark all tests
	UNSUPPORTED on a.out targets.  Tidy.
@
text
@d3083 1
a3083 1
				 abs_output_section);
d3098 1
a3098 1
				 output_section_statement);
d3322 2
a3323 2
  result = exp_fold_tree (tree, output_section, lang_final_phase_enum,
			  print_dot, &print_dot);
d3333 1
a3333 1
	    value += result.section->bfd_section->vma;
d3350 1
a3350 1
	      value += result.section->bfd_section->vma;
d4152 1
a4152 1
				       abs_output_section,
d4162 1
a4162 1
		    dot = r.value + r.section->bfd_section->vma;
d4202 1
a4202 1
	      exp_fold_tree (os->update_dot_tree, abs_output_section,
d4261 1
a4261 1
	    exp_fold_tree (s->data_statement.exp, abs_output_section,
d4350 1
a4350 1
			   output_section_statement,
d4583 1
a4583 1
				   abs_output_section,
d4588 1
a4588 1
	      = value.value + value.section->bfd_section->vma;
d4621 1
a4621 1
				   abs_output_section,
d4647 1
a4647 1
			   output_section_statement,
@


1.185
log
@bfd/

2005-05-17  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 797
	* elf32-i386.c (elf_i386_size_dynamic_sections): Also remove
	empty sdynbss section.
	* elf64-x86-64.c (elf64_x86_64_size_dynamic_sections): Likewise.

ld/

2005-05-17  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 797
	* ldexp.c (exp_fold_tree_1): Renamed from exp_fold_tree and
	take take a bfd_boolean, mark_used. Ignore assert failure if
	mark_used is TRUE.
	(exp_fold_tree) Call exp_fold_tree_1 with mark_used == FALSE.
	(exp_fold_tree_no_dot): Updated to take a bfd_boolean,
	mark_used and pass down.
	(fold_unary): Likewise.
	(fold_binary): Likewise.
	(fold_trinary): Likewise.
	(exp_binop): Add FALSE to call to exp_fold_tree_no_dot.
	(exp_trinop): Likewise.
	(exp_unop): Likewise.
	(exp_nameop): Likewise.
	(exp_get_vma): Likewise.
	(exp_get_fill): Likewise.
	(exp_get_abs_int): Likewise.
	(fold_name): Likewise. Set SEC_KEEP in output section flags.
	(exp_mark_used_section): New.

	* ldexp.h (exp_mark_used_section): New.

	* ldlang.c (lang_output_section_statement_lookup_1): Set the
	ignored field to FALSE.
	(lang_mark_used_section_1): New.
	(lang_mark_used_section): Call lang_mark_used_section_1.
	(strip_excluded_output_sections): Call lang_mark_used_section
	and check for unused sections.
	(lang_size_sections_1): Skip an output section if it should
	be ignored.
	(lang_do_assignments_1): Likewise.
	(lang_process): Don't call lang_mark_used_section here.

	* ldlang.h (lang_output_section_statement_type): Change
	all_input_readonly to bitfield. Add ignored.

ld/testsuite/

2005-05-17  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 797
	* empty-aligned.d: New file.
	* empty-aligned.exp: Likewise.
	* empty-aligned.s: Likewise.
	* empty-aligned.t: Likewise.
@
text
@d94 1
d4747 3
a4749 3
      /* No entry has been specified.  Look for start, but don't warn
	 if we don't find it.  */
      entry_symbol.name = "start";
d5586 10
@


1.184
log
@ldlang.c (print_assignment): Do not rely upon a valid result having a section
  associated with it.
elf32-arm.c (elf32_arm_final_link_relocate): Gracefully handle the situation
  where a symbols's section is not known but a section relative R_ARM_RELATIVE
  reloc has to be generated for the Symbian OS.
@
text
@d1027 1
d3046 84
d3139 2
d3145 2
a3146 1
      asection *s;
d3151 2
a3152 1
      if (os->bfd_section == NULL || os->bfd_section->map_head.s == NULL)
d3155 12
a3166 3
      for (s = os->bfd_section->map_head.s; s != NULL; s = s->map_head.s)
	if ((s->flags & SEC_EXCLUDE) == 0)
	  break;
d3168 3
a3170 2
      os->bfd_section->map_head.link_order = NULL;
      os->bfd_section->map_tail.link_order = NULL;
d3172 4
a3175 1
      if (s == NULL)
d3177 8
a3184 3
	  s = os->bfd_section;
	  os->bfd_section = NULL;
	  if (!bfd_section_removed_from_list (output_bfd, s))
d3186 1
a3186 1
	      bfd_section_list_remove (output_bfd, s);
d4046 2
a4047 2
	    if (os->bfd_section == NULL)
	      /* This section was never actually created.  */
d4542 1
a4542 1
	    if (os->bfd_section != NULL)
d4556 1
a4556 1
		if (os->bfd_section)
a5349 10
static void
lang_mark_used_section (void)
{
  unsigned int gc_sections = link_info.gc_sections;

  link_info.gc_sections = 0;
  bfd_gc_sections (output_bfd, &link_info);
  link_info.gc_sections = gc_sections;
}

a5507 1
  lang_mark_used_section ();
@


1.183
log
@* ldlang.c (Scan_for_self_assignment): Check an assignment tree to
	see if the same value is being used on the rhs as on the lhs.
	(print_assignment): Call scan_for_self_assignment and if it
	returns true, do no display the result of the computation but
	instead just the final value of the symbol on the lhs.
* ld.texinfo: Document this behaviour and provide an example of
	when it will happen.
@
text
@d3222 4
a3225 1
	  value = result.value + result.section->bfd_section->vma;
d3239 4
a3242 1
	      value = h->u.def.value + result.section->bfd_section->vma;
@


1.182
log
@Update FSF addresses
@
text
@d3136 50
d3190 3
a3192 2
  int i;
  int is_dot;
d3201 1
a3201 1
      is_dot = 0;
d3203 1
d3208 2
a3209 1
      is_dot = dst[0] == '.' && dst[1] == 0;
d3211 1
d3220 17
a3236 1
      value = result.value + result.section->bfd_section->vma;
d3238 5
a3242 3
      minfo ("0x%V", value);
      if (is_dot)
	print_dot = value;
@


1.181
log
@	* ldgram.y: Add SPECIAL token.
	(sect_constraint): Handle SPECIAL.
	* ldlang.c (lang_output_section_find_1): Don't match SPECIAL.
	(map_input_to_output_sections): Likewise.
	* ldlex.l (SPECIAL): Define.
	* emulparams/elf32ppc.sh (DATA_GOT, SDATA_GOT, SEPARATE_GOTPLT,
	GOT, PLT, GOTPLT): Define.
	* emultempl/ppc32elf.em (old_plt, old_got): New static vars.
	(ppc_after_open): New function.
	(PARSE_AND_LIST_PROLOGUE): Define OPTION_OLD_LPT and OPTION_OLD_GOT.
	(PARSE_AND_LIST_LONGOPTS): Add "bss-plt" and "sdata-got".
	(PARSE_AND_LIST_OPTIONS): Document them.
	(PARSE_AND_LIST_ARGS_CASES): Handle them.
	(LDEMUL_AFTER_OPEN): Define.
	* scripttempl/elf.sc (PLT): Don't override existing define.
	(DATA_GOT, SDATA_GOT): Define and use to enable alternate got
	placement rather than using NO_SMALL_DATA.  Emit GOTPLT for RELRO_NOW.
@
text
@d20 2
a21 2
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.180
log
@bfd/
	* section.c (struct bfd_section): Replace link_order_head and
	link_order_tail with map_head and map_tail union.
	(STD_SECTION): Update.
	(_bfd_strip_section_from_output): Delete.
	* aoutx.h: Update throughout for above changes.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* linker.c: Likewise.
	* merge.c: Likewise.
	* pdp11.c: Likewise.
	* xcofflink.c: Likewise.
	* elflink.c (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Split
	out from bfd_elf_size_dynamic_sections.
	* bfd-in.h (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Declare.
	* bfd-in2.h: Regenerate.
ld/
	* ldemul.c: Include bfdlink.h.
	(ldemul_before_allocation): Assume before_allocation is non-zero.
	(before_allocation_default): Call strip_excluded_output_sections.
	* ldlang.c (stripped_excluded_sections): New variable.
	(lang_add_section): Build input section list for each output
	section, attached via map_head and map_tail pointers.
	(strip_excluded_output_sections): Make global.  Traverse the
	input section lists to find which output sections can go.  Clear
	link_order pointers and set stripped_excluded_sections.
	(lang_process): Call strip_excluded_output_sections.
	* ldlang.h (strip_excluded_output_sections): Declare.
	* ldwrite.c: Update throuhout for link_order_head -> map_head change.
	* emultempl/aix.em (before_allocation): Call
	strip_excluded_output_sections.
	* emultempl/armcoff.em (before_allocation): Likewise.
	* emultempl/beos.em (before_allocation): Likewise.
	* emultempl/linux.em (before_allocation): Likewise.
	* emultempl/pe.em (before_allocation): Likewise.
	* emultempl/sunos.em (before_allocation): Likewise.
	* emultempl/elf32.em (before_allocation): Likewise.  Call
	bfd_elf_size_dynsym_hash_dynstr too.
	* emultempl/lnk960.em (lnk960_before_allocation): Delete.
	(ld_lnk960): Use before_allocation_default.
@
text
@d994 3
a996 1
	  && (constraint == 0 || constraint == lookup->constraint))
d2956 2
a2957 1
	      if (s->output_section_statement.constraint == -1)
@


1.179
log
@bfd/

2005-05-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfd.c (bfd): Remove section_tail and add section_last.
	(bfd_preserve): Likewise.
	(bfd_preserve_save): Likewise.
	(bfd_preserve_restore): Likewise.
	* opncls.c (_bfd_new_bfd): Likewise.

	* coffcode.h (coff_compute_section_file_positions): Updated.
	(coff_compute_section_file_positions): Likewise.
	* elf.c (assign_section_numbers): Likewise.
	* elf32-i370.c (i370_elf_size_dynamic_sections): Likewise.
	* elf64-mmix.c (mmix_elf_final_link): Likewise.
	* elfxx-ia64.c (elfNN_ia64_object_p): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* sunos.c (sunos_add_dynamic_symbols): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_final_link): Likewise.

	* ecoff.c (bfd_debug_section): Initialize prev.

	* section.c (bfd_section): Add prev.
	(bfd_section_list_remove): Updated.
	(bfd_section_list_append): New.
	(bfd_section_list_insert_after): New.
	(bfd_section_list_insert_before): New.
	(bfd_section_list_insert): Removed.
	(bfd_section_removed_from_list): Updated.
	(STD_SECTION): Initialize prev.
	(bfd_section_init): Updated.
	(bfd_section_list_clear): Updated.

	* bfd-in2.h: Regenerated.

gas/

2005-05-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* write.c (write_object_file): Use bfd_section_double_list_remove
	to remove sections.

ld/

2005-05-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* emultempl/elf32.em (gld${EMULATION_NAME}_strip_empty_section):
	Updated for bfd_section_list_remove change.
	* ldlang.c (lang_insert_orphan): Likewise.
	(strip_excluded_output_sections): Likewise.
	(sort_sections_by_lma): New.
	(lang_check_section_addresses): Sort the sections before
	checking addresses.
@
text
@d57 1
d1725 13
d3046 1
a3046 1
static void
d3059 12
a3070 2
      s = os->bfd_section;
      if (s != NULL && (s->flags & SEC_EXCLUDE) != 0)
d3072 1
d3081 4
a5257 3
  if (!link_info.relocatable)
    strip_excluded_output_sections ();

@


1.178
log
@	* ldgram.y (lang_memory_region_type): Make static.
	(ldgram_want_filename): Likewise.
	* ldemul.c (ld_emulation): Make static.
	* ldfile.h (ldfile_find_command_file): Remove extern.
	* ldfile.c (ldfile_find_command_file): Make static.
	* ldlang.h (unique_section_list): Remove extern declaration.
	* ldlang.c (unique_section_list): Make static.
	* mri.h (symbol_truncate): Remove extern declaration.
	* mri.c (symbol_truncate): Make static.
	(order, only_load, address, alias): Likewise.
	(alignment, subalignment): Likewise.
@
text
@a1204 1
  asection **bfd_tail;
a1257 1
  bfd_tail = output_bfd->section_tail;
d1289 1
a1289 1
      asection *snew;
d1315 5
a1319 3
      /* Unlink the section.  */
      ASSERT (*bfd_tail == snew);
      bfd_section_list_remove (output_bfd, bfd_tail);
d1321 3
a1323 2
      /* Now tack it back on in the right place.  */
      bfd_section_list_insert (output_bfd, place->section, snew);
a3047 2
	  asection **p;

d3049 5
a3053 8

	  for (p = &output_bfd->sections; *p; p = &(*p)->next)
	    if (*p == s)
	      {
		bfd_section_list_remove (output_bfd, p);
		output_bfd->section_count--;
		break;
	      }
d3682 16
d3711 14
a3724 1
  asection *s;
d3727 1
d3730 1
a3730 3
      asection *os;

      /* Ignore sections which are not loaded or which have no contents.  */
d3734 6
a3739 9
      /* Once we reach section 's' stop our seach.  This prevents two
	 warning messages from being produced, one for 'section A overlaps
	 section B' and one for 'section B overlaps section A'.  */
      for (os = output_bfd->sections; os != s; os = os->next)
	{
	  bfd_vma s_start;
	  bfd_vma s_end;
	  bfd_vma os_start;
	  bfd_vma os_end;
d3741 2
a3742 3
	  /* Only consider loadable sections with real contents.  */
	  if (IGNORE_SECTION (os) || os->size == 0)
	    continue;
d3744 21
a3764 11
	  /* We must check the sections' LMA addresses not their
	     VMA addresses because overlay sections can have
	     overlapping VMAs but they must have distinct LMAs.  */
	  s_start = bfd_section_lma (output_bfd, s);
	  os_start = bfd_section_lma (output_bfd, os);
	  s_end = s_start + TO_ADDR (s->size) - 1;
	  os_end = os_start + TO_ADDR (os->size) - 1;

	  /* Look for an overlap.  */
	  if ((s_end < os_start) || (s_start > os_end))
	    continue;
d3766 1
a3766 9
	  einfo (
_("%X%P: section %s [%V -> %V] overlaps section %s [%V -> %V]\n"),
		 s->name, s_start, s_end, os->name, os_start, os_end);

	  /* Once we have found one overlap for this section,
	     stop looking for others.  */
	  break;
	}
    }
@


1.177
log
@2005-04-06  Jakub Jelinek  <jakub@@redhat.com>

	* ldlang.c: Formatting.
	(walk_wild_consider_section): Remember return value from wildcardp.
	(is_simple_wild): Use strcspn instead of 2 strpbrk calls and strlen.
	(wild_spec_can_overlap): Use strcspn instead of strpbrk and strlen.

2005-04-06  Robert O'Callahan  <rocallahan@@novell.com>

	* ld.h (lean_section_userdata_type): Remove.
	(fat_section_userdata_type): Remove file field.
	(SECTION_USERDATA_SIZE): Remove.
	* ldlang.c (init_os): Eliminate initialization of unused
	lean_section_userdata_type.

	* ldlang.h (callback_t, walk_wild_section_handler_t): New
	typedefs.
	(struct lang_wild_statement_struct): Add walk_wild_section_handler
	and handler_data fields.
	* ldlang.c (callback_t): Removed.
	(walk_wild_consider_section, walk_wild_section_general,
	section_iterator_callback, find_section, is_simple_wild,
	match_simple_wild, walk_wild_section_specs1_wild0,
	walk_wild_section_specs1_wild1, walk_wild_section_specs2_wild1,
	walk_wild_section_specs3_wild2, walk_wild_section_specs4_wild2,
	wild_spec_can_overlap, analyze_walk_wild_section_handler): New
	functions.
	(lang_add_wild): Call analyze_walk_wild_section_handler.
	(walk_wild_section): Renamed to walk_wild_section_general and
	created a wrapper function.
	(section_iterator_callback_data): New typedef.
@
text
@d100 1
a100 1
struct unique_sections *unique_section_list;
@


1.176
log
@	* ldlang.c (lang_insert_orphan): Use old section_tail rather than
	traversing the bfd section list to find pointer to new section.
@
text
@a86 3
typedef void (*callback_t) (lang_wild_statement_type *, struct wildcard_list *,
			    asection *, lang_input_statement_type *, void *);

d155 54
d210 4
a213 4
walk_wild_section (lang_wild_statement_type *ptr,
		   lang_input_statement_type *file,
		   callback_t callback,
		   void *data)
d216 1
a216 3

  if (file->just_syms_flag)
    return;
a219 2
      struct wildcard_list *sec;

a226 1
	  struct name_list *list_tmp;
d228 1
a228 31
	  /* Don't process sections from files which were
	     excluded.  */
	  for (list_tmp = sec->spec.exclude_name_list;
	       list_tmp;
	       list_tmp = list_tmp->next)
	    {
	      if (wildcardp (list_tmp->name))
		skip = fnmatch (list_tmp->name, file->filename, 0) == 0;
	      else
		skip = strcmp (list_tmp->name, file->filename) == 0;

	      /* If this file is part of an archive, and the archive is
		 excluded, exclude this file.  */
	      if (! skip && file->the_bfd != NULL
		  && file->the_bfd->my_archive != NULL
		  && file->the_bfd->my_archive->filename != NULL)
		{
		  if (wildcardp (list_tmp->name))
		    skip = fnmatch (list_tmp->name,
				    file->the_bfd->my_archive->filename,
				    0) == 0;
		  else
		    skip = strcmp (list_tmp->name,
				   file->the_bfd->my_archive->filename) == 0;
		}

	      if (skip)
		break;
	    }

	  if (!skip && sec->spec.name != NULL)
d239 1
a239 1
	    (*callback) (ptr, sec, s, file, data);
d246 368
a1561 2
  lean_section_userdata_type *new;

a1567 3
  new = stat_alloc (SECTION_USERDATA_SIZE);
  memset (new, 0, SECTION_USERDATA_SIZE);

d1581 8
a1588 1
  get_userdata (s->bfd_section) = new;
d5328 1
@


1.175
log
@ld/ChangeLog:
        * ldlang.c (IGNORE_SECTION): Remove check for zero size.
        (lang_check_section_addresses): Ignore zero size sections here.
ld/testsuite/ChangeLog:
        * ld-scripts/empty-orphan.d, ld-scripts/empty-orphan.exp,
        ld-scripts/empty-orphan.s, ld-scripts/emtpy-orphan.t: New test.
@
text
@d821 1
d875 1
d907 1
a907 1
      asection *snew, **pps;
d934 2
a935 3
      for (pps = &output_bfd->sections; *pps != snew; pps = &(*pps)->next)
	continue;
      bfd_section_list_remove (output_bfd, pps);
@


1.174
log
@bfd/

2005-03-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* elflink.c (elf_mark_used_section): New.
	(bfd_elf_gc_sections): Call elf_gc_mark_section for
	non-relocatable link if we don't do GC.

include/

2005-03-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfdlink.h (bfd_link_info): Add gc_sections.

ld/

2005-03-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* emultempl/elf32.em (gld${EMULATION_NAME}_finish): Remove
	unused empty output sections for non-relocatable link.

	* ld.h (args_type): Remove gc_sections.

	* ldlang.c (lang_mark_used_section): New.
	(lang_gc_sections): Use link_info.gc_sections instead of
	command_line.gc_sections.
	* ldmain.c (main): Likewise.
	* lexsup.c (parse_args): Likewise.
	* ldlang.c (lang_process): Call lang_mark_used_section.

	* ldmain.c (main): Initialize link_info.gc_sections to FALSE.

ld/testsuite/

2005-03-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-alpha/tlsbin.rd: Updated for empty section removal.
	* ld-alpha/tlsbinr.rd: Likewise.
	* ld-alpha/tlspic.rd: Likewise.
	* ld-arm/mixed-lib.sym: Likewise.
	* ld-i386/tlsbin.rd: Likewise.
	* ld-i386/tlsnopic.rd: Likewise.
	* ld-i386/tlspic.rd: Likewise.
	* ld-ia64/tlsbin.rd: Likewise.
	* ld-ia64/tlspic.rd: Likewise.
	* ld-powerpc/apuinfo.rd: Likewise.
	* ld-powerpc/powerpc.exp: Likewise.
	* ld-powerpc/tlsexe32.r: Likewise.
	* ld-s390/tlsbin.rd: Likewise.
	* ld-s390/tlsbin_64.rd: Likewise.
	* ld-s390/tlspic.rd: Likewise.
	* ld-s390/tlspic_64.rd: Likewise.
	* ld-sh/tlsbin-2.d: Likewise.
	* ld-sh/tlspic-2.d: Likewise.
	* ld-sparc/tlssunbin32.rd: Likewise.
	* ld-sparc/tlssunnopic32.rd: Likewise.
	* ld-sparc/tlssunpic32.rd: Likewise.
	* ld-x86-64/tlsbin.rd: Likewise.
	* ld-x86-64/tlspic.rd: Likewise.
@
text
@d3303 1
a3303 2
	&& (s->flags & SEC_LOAD) == 0)				\
   || s->size == 0)
d3320 1
a3320 1
      if (IGNORE_SECTION (s))
d3334 1
a3334 1
	  if (IGNORE_SECTION (os))
@


1.173
log
@	* ldlang.c (section_already_linked): Don't call
	bfd_section_already_linked for dynamic objects.
@
text
@d4721 1
a4721 1
  if (command_line.gc_sections)
d4725 10
d4896 1
a4896 1

@


1.173.2.1
log
@ld/ChangeLog:
        * ldlang.c (IGNORE_SECTION): Remove check for zero size.
        (lang_check_section_addresses): Ignore zero size sections here.
ld/testsuite/ChangeLog:
        * ld-scripts/empty-orphan.d, ld-scripts/empty-orphan.exp,
        ld-scripts/empty-orphan.s, ld-scripts/emtpy-orphan.t: New test.
@
text
@d3303 2
a3304 1
	&& (s->flags & SEC_LOAD) == 0))
d3321 1
a3321 1
      if (IGNORE_SECTION (s) || s->size == 0)
d3335 1
a3335 1
	  if (IGNORE_SECTION (os) || os->size == 0)
@


1.173.2.1.4.1
log
@	Issue #439
	Backport:
	2005-10-13  Mark Mitchell  <mark@@codesourcery.com>
	* ld.texino: Describe double-quoted string syntax for version
	nodes.
	* ldlang.h (lang_new_vers_pattern): Add literal_p parameter.
	* ldgram.y (vers_defns): Allow NAME as well as VERS_IDENTIFIER.
	Adjust calls to lang_new_vers_pattern to pass literal_p argument.
	* ldlang.c (lang_vers_match): Fix indentation.  Do not glob-match
	version nodes without a pattern.
	(lang_new_vers_pattern): Add literal_p parameter.
	(lang_do_version_exports_section): Pass it.
@
text
@d5618 2
a5619 2
		  else
		    expr = expr->next;
d5630 2
a5631 2
		  else
		    expr = expr->next;
d5642 2
a5643 2
		  else
		    expr = expr->next;
d5656 1
a5656 1
  for (; expr; expr = expr->next)
a5659 3
      if (!expr->pattern)
	continue;

d5671 1
d5726 1
a5726 3
/* This is called for each variable name or match expression.  NEW is
   the name of the symbol to match, or, if LITERAL_P is FALSE, a glob
   pattern to be matched against symbol names.  */
d5731 1
a5731 2
		       const char *lang,
		       bfd_boolean literal_p)
d5737 1
a5737 1
  ret->pattern = literal_p ? NULL : new;
d5740 1
a5740 1
  ret->symbol = literal_p ? new : realsymbol (new);
d6024 1
a6024 1
	  greg = lang_new_vers_pattern (greg, p, NULL, FALSE);
d6034 1
a6034 1
  lreg = lang_new_vers_pattern (NULL, "*", NULL, FALSE);
@


1.173.2.1.2.1
log
@	* ldlang.c (Scan_for_self_assignment): Check an assignment tree to
	see if the same value is being used on the rhs as on the lhs.
	(print_assignment): Call scan_for_self_assignment and if it
	returns true, do no display the result of the computation but
	instead just the final value of the symbol on the lhs.
	* ld.texinfo: Document this behaviour and provide an example of
	when it will happen.
@
text
@a2720 50
/* Scan for the use of the destination in the right hand side
   of an expression.  In such cases we will not compute the
   correct expression, since the value of DST that is used on
   the right hand side will be its final value, not its value
   just before this expression is evaluated.  */
   
static bfd_boolean
scan_for_self_assignment (const char * dst, etree_type * rhs)
{
  if (rhs == NULL || dst == NULL)
    return FALSE;

  switch (rhs->type.node_class)
    {
    case etree_binary:
      return scan_for_self_assignment (dst, rhs->binary.lhs)
	||   scan_for_self_assignment (dst, rhs->binary.rhs);

    case etree_trinary:
      return scan_for_self_assignment (dst, rhs->trinary.lhs)
	||   scan_for_self_assignment (dst, rhs->trinary.rhs);

    case etree_assign:
    case etree_provided:
    case etree_provide:
      if (strcmp (dst, rhs->assign.dst) == 0)
	return TRUE;
      return scan_for_self_assignment (dst, rhs->assign.src);

    case etree_unary:
      return scan_for_self_assignment (dst, rhs->unary.child);

    case etree_value:
      if (rhs->value.str)
	return strcmp (dst, rhs->value.str) == 0;
      return FALSE;

    case etree_name:
      if (rhs->name.name)
	return strcmp (dst, rhs->name.name) == 0;
      return FALSE;

    default:
      break;
    }

  return FALSE;
}


d2725 2
a2726 3
  unsigned int i;
  bfd_boolean is_dot;
  bfd_boolean computation_is_valid = TRUE;
d2735 1
a2735 1
      is_dot = FALSE;
a2736 1
      computation_is_valid = TRUE;
d2741 1
a2741 2

      is_dot = (dst[0] == '.' && dst[1] == 0);
a2742 1
      computation_is_valid = is_dot || (scan_for_self_assignment (dst, tree) == FALSE);
d2751 1
a2751 14
      if (computation_is_valid)
	{
	  value = result.value;

	  if (result.section)
	    value += result.section->bfd_section->vma;

	  minfo ("0x%V", value);
	  if (is_dot)
	    print_dot = value;
	}
      else
	{
	  struct bfd_link_hash_entry *h;
d2753 3
a2755 14
	  h = bfd_link_hash_lookup (link_info.hash, assignment->exp->assign.dst,
				    FALSE, FALSE, TRUE);
	  if (h)
	    {
	      value = h->u.def.value;

	      if (result.section)
	      value += result.section->bfd_section->vma;

	      minfo ("[0x%V]", value);
	    }
	  else
	    minfo ("          ");
	}
@


1.172
log
@bfd/

2005-02-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* coffcode.h (sec_to_styp_flags): Replaced SEC_CLINK with
	SEC_TIC54X_CLINK. Replace SEC_BLOCK with SEC_TIC54X_BLOCK.
	Replace SEC_SHARED with SEC_COFF_SHARED.
	(styp_to_sec_flags): Likewise.

	* elfxx-target.h (TARGET_BIG_SYM): Remove SEC_ARCH_BIT_0.
	(TARGET_LITTLE_SYM): Likewise.

	* section.c (SEC_ARCH_BIT_0): Removed.
	(SEC_LINK_DUPLICATES_SAME_CONTENTS): Defined with
	SEC_LINK_DUPLICATES_ONE_ONLY and SEC_LINK_DUPLICATES_SAME_SIZE.
	(SEC_SHARED): Renamed to ...
	(SEC_COFF_SHARED): This.
	(SEC_BLOCK): Renamed to ...
	(SEC_TIC54X_BLOCK): This.
	(SEC_CLINK): Renamed to ...
	(SEC_TIC54X_CLINK): This.
	(SEC_XXX): Rearranged. Move SEC_COFF_SHARED_LIBRARY,
	SEC_COFF_SHARED, SEC_TIC54X_BLOCK and SEC_TIC54X_CLINK to the
	end.
	* bfd-in2.h: Regenerated.

binutils/

2005-02-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* objcopy.c (parse_flags): Replace SEC_SHARED with
	SEC_COFF_SHARED.

	* objdump.c (dump_section_header): Dump SEC_TIC54X_BLOCK and
	SEC_TIC54X_CLINK for TI c54x only. Remove SEC_ARCH_BIT_0. Dump
	SEC_COFF_SHARED for COFF only.

gas/

2005-02-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/obj-coff.c (obj_coff_section): Replace SEC_SHARED with
	SEC_COFF_SHARED.

	* config/tc-tic54x.c (tic54x_bss): Replace SEC_BLOCK with
	SEC_TIC54X_BLOCK.
	(demand_empty_rest_of_line): Likewise.
	(tic54x_sblock): Likewise.
	(tic54x_clink): Replace with SEC_CLINK with SEC_TIC54X_CLINK.

ld/

2005-02-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldlang.c (lang_add_section): Check SEC_TIC54X_BLOCK for TI
	tic54x input only.
	(lang_size_sections_1): Check SEC_COFF_SHARED_LIBRARY for COFF
	and ECOFF output only.
@
text
@d1277 2
a1278 1
  bfd_section_already_linked (abfd, sec);
@


1.171
log
@	* ldlang.c (lang_reasonable_defaults): Remove.
	(lang_process): Don't call lang_reasonable_defaults.

	* ldexp.c (exp_assop): Remove #if 0'd code.
	(exp_print_tree): Likewise.
	* ldlang.c (lang_memory_region_lookup): Likewise.
	(open_output): Likewise.
	(lang_do_assignments_1): Likewise.
	(lang_place_orphans): Likewise.
	(lang_enter_output_section_statement): Likewise.
	(lang_reasonable_defaults): Likewise.
	* ldlang.h (struct lang_input_statement_struct): Likewise.
	* mri.c (mri_draw_tree): Likewise.
	(mri_load): Likewise.
	* pe-dll.c (generate_reloc): Likewise.
	(make_import_fixup_entry): Likewise.
	(pe_as16): Likewise.
	* emultempl/beos.em (set_pe_subsystem): Likewise.
	* emultempl/hppaelf.em (hppaelf_after_parse): Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/xtensaelf.em (xtensa_colocate_literals): Likewise.
@
text
@d1416 2
a1417 1
      if (section->flags & SEC_BLOCK)
d1419 1
a1419 1
	  output->bfd_section->flags |= SEC_BLOCK;
d3428 3
a3430 1
	    if ((os->bfd_section->flags & SEC_COFF_SHARED_LIBRARY) != 0)
@


1.170
log
@bfd/
	* bfd.c (bfd_link_just_syms): Add abfd param.
	* bfd-in2.h: Regenerate.
ld/
	* ldlang.c (section_already_linked): Adjust bfd_link_just_syms call.
	(lang_place_orphans): Don't abort on just_syms_flag, instead call
	bfd_link_just_syms.
@
text
@a555 14
#if 0
  /* This code used to always use the first region in the list as the
     default region.  I changed it to instead use a region
     encompassing all of memory as the default region.  This permits
     NOLOAD sections to work reasonably without requiring a region.
     People should specify what region they mean, if they really want
     a region.  */
  if (strcmp (name, DEFAULT_MEMORY_REGION) == 0)
    {
      if (lang_memory_region_list != NULL)
	return lang_memory_region_list;
    }
#endif

a2145 4
#if 0
  output->flags |= D_PAGED;
#endif

a2292 25
/* If there are [COMMONS] statements, put a wild one into the bss
   section.  */

static void
lang_reasonable_defaults (void)
{
#if 0
  lang_output_section_statement_lookup (".text");
  lang_output_section_statement_lookup (".data");

  default_common_section = lang_output_section_statement_lookup (".bss");

  if (!placed_commons)
    {
      lang_wild_statement_type *new =
      new_stat (lang_wild_statement,
		&default_common_section->children);

      new->section_name = "COMMON";
      new->filename = NULL;
      lang_list_init (&new->children);
    }
#endif
}

a3946 3
#if 0
	case lang_common_statement_enum:
#endif
a4411 7
#if 0
			  /* This message happens when using the
			     svr3.ifile linker script, so I have
			     disabled it.  */
			  info_msg (_("%P: no [COMMON] command,"
				      " defaulting to .bss\n"));
#endif
a4579 5
  /* Add this statement to tree.  */
#if 0
  add_statement (lang_output_section_statement_enum,
		 output_section_statement);
#endif
a4723 1
  lang_reasonable_defaults ();
@


1.169
log
@	* ldexp.h (exp_data_seg): Add min_base and maxpagesize fields.
	* ldexp.c (fold_binary) <case DATA_SEGMENT_ALIGN>: Initialize them.
	* ldlang.c (lang_size_sections): Use them to avoid wasting virtual
	address space at DATA_SEGMENT_ALIGN.  Fix computation of expected
	PT_GNU_RELRO segment end.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004
d1287 1
a1287 1
      bfd_link_just_syms (sec, &link_info);
d4445 2
a4446 3
		abort ();

	      if ((s->flags & SEC_EXCLUDE) != 0)
@


1.168
log
@	* Makefile.in (earmsymbian.c): Depend on armbpabi.sc, not elf.sc.
	* ldexp.h (segment_type): New type.
	(segments): New variable.
	* ldexp.c (segments): New variable.
	(exp_print_token): Handle SEGMENT_START.
	(fold_binary): Likewise.
	* ldgram.y (SEGMENT_START): Declare it as a token.
	(exp): Handle SEGMENT_START.
	* ldlang.h (lang_address_statement_type): Add segment field.
	(lang_section_start): Change prototype.
	* ldlang.c (map_input_to_output_sections): Do not process section
	assignments if a corresponding SEGMENT_START has already been
	seen.
	(lang_section_start): Add segment parameter.
	* ldlex.l (SEGMENT_START): Add it.
	* lexsup.c (seg_segment_start): New function.
	(parse_args): Use it for -Tbss, -Tdata, and -Ttext.
	* ld.texinfo (SEGMENT_START): Document it.
	* emulparams/armsymbian.sh (EMBEDDED): Set it.
	* scripttempl/armbpabi.sc: Use SEGMENT_START to control segment
	base addresses.  Do not map relocations.
	* NEWS: Mention SEGMENT_START.
@
text
@d3861 1
a3861 1
      bfd_vma old_base, relro_end;
d3864 2
a3865 1
      old_base = exp_data_seg.base;
d3870 6
a3875 1
		  & (exp_data_seg.pagesize - 1);
d3897 1
a3897 1
		  < old_base)
@


1.167
log
@2004-10-19  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 459
	* ldlang.c (load_symbols): Use the same -Bdynamic/-Bstatic
	option on linker script as the one for linker script.
@
text
@d2655 21
a2675 10
	  /* Mark the specified section with the supplied address.  */
	  {
	    lang_output_section_statement_type *aos
	      = (lang_output_section_statement_lookup
		 (s->address_statement.section_name));

	    if (aos->bfd_section == NULL)
	      init_os (aos);
	    aos->addr_tree = s->address_statement.address;
	  }
d4985 2
a4986 1
lang_section_start (const char *name, etree_type *address)
d4993 1
@


1.166
log
@bfd/
	* bfd-in2.h: Regenerate.
	* bfd.c (struct bfd): Add no_export.
	* elflink.c (elf_link_add_object_symbols): Handle no_export.
ld/
	* ldlang.c (struct excluded_lib, excluded_libs, add_excluded_libs)
	(check_excluded_libs): New.
	(load_symbols): Call check_excluded_libs.
	* ldlang.h (add_excluded_libs): New prototype.
	* emultempl/elf32.em (OPTION_EXCLUDED_LIBS): Define.
	(gld${EMULATION_NAME}_add_options): Add --exclude-libs.
	(gld${EMULATION_NAME}_handle_option): Handle --exclude-libs.
	* ld.texinfo (Command Line Variables): Document --exclude-libs.
	(Options Specific to i386 PE Targets): Remove --exclude-libs.
ld/testsuite/
	* ld-elf/exclude1.s, ld-elf/exclude2.s, ld-elf/exclude.exp: New.
@
text
@d1812 3
@


1.165
log
@ld/
	PR 63
	* ldlang.h (lang_output_section_statement_type): Make "next" a
	struct lang_output_section_statement_struct *.
	(struct orphan_save): Move from elf32.em.  Add "name" and "flags".
	(lang_output_section_find_by_flags, lang_insert_orphan): Declare.
	* ldlang.c (lang_output_section_find_1): Adjust for changed
	output_section_statement "next".
	(strip_excluded_output_sections): Likewise.
	(lang_record_phdrs): Likewise.
	(lang_output_section_find_by_flags): New function.
	(output_prev_sec_find): Move from pe.em.  Adjust iterator.
	(lang_insert_orphan): New function.  Tail end of elf32.em's
	place_orphan merged with that from pe.em.  Allow bfd_section to
	be placed first.  New heuristic for placing new output section
	statement in existing script, and accompanying split of __start
	symbol alignment into a separate assignment to dot.
	(lang_add_section): Consistently use output->bfd_section rather than
	an alias, section->output_section.
	(map_input_to_output_sections): Rename overly long arg.  Move
	initialization of data_statement output section to here..
	(lang_check_section_addresses): ..from here.
	(print_assignment): Correct printing of etree_assert.
	(print_all_symbols): Don't bomb if userdata is NULL.
	(IGNORE_SECTION): Rearrange.
	* emultempl/elf32.em (output_rel_find): Adjust interator.
	(output_prev_sec_find): Delete.
	(struct orphan_save): Delete.
	(gld${EMULATION_NAME}_place_orphan): Cater for zero bfd_section
	flags without creating a duplicate output section statement.
	Revise code holding history of various orphan section placements.
	Allow orphan sections to place before script specified output
	sections.  Call lang_output_section_find_by_flags when placement
	by name fails.  Use lang_insert_orphan.
	* emultempl/mmo.em (output_prev_sec_find): Delete.
	(struct orphan_save): Delete.
	(mmo_place_orphan): Revise code holding history of orphan placement.
	Allow orphans to place before existing output sections.  Use
	lang_insert_orphan.
	* emultempl/pe.em (output_prev_sec_find): Delete.
	(struct orphan_save): Delete.
	(gld_${EMULATION_NAME}_place_orphan): Revise to suit use of
	lang_insert_orphan.
ld/testsuite/
	* ld-scripts/overlay-size.d: Update for changed orphan section
	placement.
	* ld-mmix/bpo-18.d: Likewise.
@
text
@d1695 61
d1840 2
@


1.164
log
@ld/

2004-10-04  H.J. Lu  <hongjiu.lu@@intel.com>

	* NEWS: Mention SORT_BY_NAME, SORT_BY_ALIGNMENT and
	--sort-section name|alignment.

	* ld.texinfo: Document SORT_BY_NAME, SORT_BY_ALIGNMENT and
	--sort-section name|alignment.

	* ld.h (sort_type): New enum.
	(wildcard_spec): Change the type of `sorted' to sort_type.

	* ldgram.y (SORT): Removed.
	(SORT_BY_NAME): Added.
	(SORT_BY_ALIGNMENT): Added.
	(wildcard_spec): Updated `sorted'. Handle SORT_BY_NAME and
	SORT_BY_ALIGNMENT.
	(input_section_spec_no_keep): Updated `sorted'.
	(statement): Replace SORT with SORT_BY_NAME.

	* ldlang.c (compare_section): New function to compare 2
	sections with different sorting schemes.
	(wild_sort): Updated. Use compare_section.
	(update_wild_statements): New function.
	(lang_process): Call update_wild_statements before
	map_input_to_output_sections.

	* ldlex.l (SORT_BY_NAME): New.
	(SORT_BY_ALIGNMENT): New.
	(SORT): Return SORT_BY_NAME.

	* ldmain.c (sort_section): New. Defined.
	(main): Initialize it to none.

	* lexsup.c (option_values): Add OPTION_SORT_SECTION.
	(ld_options): Add an entry for OPTION_SORT_SECTION.
	(parse_args): Handle OPTION_SORT_SECTION.

	* mri.c (mri_draw_tree): Updated `sorted'.

ld/testsuite/

2004-10-04  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-scripts/sort.exp: New file for section sorting tests.
	* ld-scripts/sort_b_a.d: Likewise
	* ld-scripts/sort_b_a.s: Likewise
	* ld-scripts/sort_b_a.t: Likewise
	* ld-scripts/sort_b_a_a-1.d: Likewise
	* ld-scripts/sort_b_a_a-2.d: Likewise
	* ld-scripts/sort_b_a_a-3.d: Likewise
	* ld-scripts/sort_b_a_a.t: Likewise
	* ld-scripts/sort_b_a_n-1.d: Likewise
	* ld-scripts/sort_b_a_n-2.d: Likewise
	* ld-scripts/sort_b_a_n-3.d: Likewise
	* ld-scripts/sort_b_a_n.t: Likewise
	* ld-scripts/sort_b_n.d: Likewise
	* ld-scripts/sort_b_n.s: Likewise
	* ld-scripts/sort_b_n.t: Likewise
	* ld-scripts/sort_b_n_a-1.d: Likewise
	* ld-scripts/sort_b_n_a-2.d: Likewise
	* ld-scripts/sort_b_n_a-3.d: Likewise
	* ld-scripts/sort_b_n_a.t: Likewise
	* ld-scripts/sort_b_n_n-1.d: Likewise
	* ld-scripts/sort_b_n_n-2.d: Likewise
	* ld-scripts/sort_b_n_n-3.d: Likewise
	* ld-scripts/sort_b_n_n.t: Likewise
	* ld-scripts/sort_n_a-a.s: Likewise
	* ld-scripts/sort_n_a-b.s: Likewise
	* ld-scripts/sort_no-1.d: Likewise
	* ld-scripts/sort_no-2.d: Likewise
	* ld-scripts/sort_no.t: Likewise
@
text
@a614 1
  lang_statement_union_type *u;
d617 3
a619 1
  for (u = lang_output_section_statement.head; u != NULL; u = lookup->next)
a620 2
      lookup = &u->output_section_statement;
      
d668 1
a668 1
			     &lookup->next);
d679 383
d1177 1
a1177 1
      
d1252 1
a1252 1
      
d1376 2
a1377 2
         flag is not currently set, then don't set it just because the
         input section has it set.  */
d1379 1
a1379 1
      if (! first && (section->output_section->flags & SEC_READONLY) == 0)
d1384 1
a1384 1
	  && ((section->output_section->flags & (SEC_MERGE | SEC_STRINGS))
d1387 1
a1387 1
		  && section->output_section->entsize != section->entsize)))
d1389 1
a1389 1
	  section->output_section->flags &= ~ (SEC_MERGE | SEC_STRINGS);
d1393 1
a1393 1
      section->output_section->flags |= flags;
d1396 1
a1396 1
	section->output_section->entsize = section->entsize;
d1399 1
a1399 1
         it from the output section.  */
d1401 1
a1401 1
	section->output_section->flags &= ~SEC_READONLY;
d1421 1
a1421 1
	section->output_section->flags |= SEC_SMALL_DATA;
d1432 1
a1432 1
	  section->output_section->flags |= SEC_BLOCK;
d1507 1
a1507 1
         name.  */
d1516 3
a1518 3
             dlltool assumes that files will be sorted by the name of
             the archive and then the name of the file within the
             archive.  */
d1566 1
a1566 1
         looking at the sections for this file.  */
d2217 2
a2218 2
                 is an archive which has already been searched, then
                 force it to be researched unless the whole archive
d2510 1
a2510 1
   lang_output_section_statement_type *output_section_statement)
d2517 1
a2517 1
	  wild (&s->wild_statement, target, output_section_statement);
d2522 1
a2522 1
					output_section_statement);
d2554 1
a2554 1
					output_section_statement);
d2560 8
a2567 1
	  /* FALLTHROUGH */
d2574 2
a2575 3
	  if (output_section_statement != NULL
	      && output_section_statement->bfd_section == NULL)
	    init_os (output_section_statement);
d2578 2
a2579 3
	  if (output_section_statement != NULL
	      && output_section_statement->bfd_section == NULL)
	    init_os (output_section_statement);
d2591 7
a2597 7
	    lang_output_section_statement_type *os =
	      lang_output_section_statement_lookup
		(s->address_statement.section_name);

	    if (os->bfd_section == NULL)
	      init_os (os);
	    os->addr_tree = s->address_statement.address;
d2611 1
a2611 1
  lang_statement_union_type *u;
d2613 3
a2615 3
  for (u = lang_output_section_statement.head;
       u != NULL;
       u = u->output_section_statement.next)
a2616 1
      lang_output_section_statement_type *os;
a2618 1
      os = &u->output_section_statement;
d2690 2
d2697 14
a2710 2
  result = exp_fold_tree (assignment->exp->assign.src, output_section,
			  lang_final_phase_enum, print_dot, &print_dot);
a2712 1
      const char *dst;
a2715 1
      dst = assignment->exp->assign.dst;
d2718 1
a2718 1
      if (dst[0] == '.' && dst[1] == 0)
a2729 1

a2730 1

d2777 3
d3264 4
a3267 3
  (((s->flags & SEC_THREAD_LOCAL) != 0				\
    ? (s->flags & (SEC_LOAD | SEC_NEVER_LOAD)) != SEC_LOAD	\
    : (s->flags & (SEC_ALLOC | SEC_NEVER_LOAD)) != SEC_ALLOC)	\
d3271 2
a3272 2
   sections.  This can happen when the linker script specifically specifies
   the output section addresses of the two sections.  */
d3492 1
a3492 1
		    
a3621 8
	    /* The output section gets contents, and then we inspect for
	       any flags set in the input script which override any ALLOC.  */
	    output_section_statement->bfd_section->flags |= SEC_HAS_CONTENTS;
	    if (!(output_section_statement->flags & SEC_NEVER_LOAD))
	      {
		output_section_statement->bfd_section->flags |=
		  SEC_ALLOC | SEC_LOAD;
	      }
d4108 1
a4108 1
         number.  */
d4209 4
a4212 4
             files, temporarily set the BFD error handler to a
             function which will do nothing.  We still want to call
             bfd_merge_private_bfd_data, since it may set up
             information which is needed in the output file.  */
d4359 1
a4359 1
	         around for a sensible place for it to go.  */
d4378 2
a4379 2
                             svr3.ifile linker script, so I have
                             disabled it.  */
d5249 1
a5249 1
  lang_statement_union_type *u;
d5261 3
a5263 3
      for (u = lang_output_section_statement.head;
	   u != NULL;
	   u = u->output_section_statement.next)
a5264 1
	  lang_output_section_statement_type *os;
a5266 1
	  os = &u->output_section_statement;
d5322 3
a5324 3
  for (u = lang_output_section_statement.head;
       u != NULL;
       u = u->output_section_statement.next)
d5328 2
a5329 2
      if (u->output_section_statement.constraint == -1
	  || u->output_section_statement.bfd_section == NULL)
d5332 1
a5332 1
      for (pl = u->output_section_statement.phdrs;
d5337 1
a5337 1
		 u->output_section_statement.name, pl->name);
@


1.163
log
@	* ldgram.y (DATA_SEGMENT_RELRO_END): Add one argument.
	* scripttempl/elf.sc (DATA_SEGMENT_RELRO_END): Add 0 as first
	argument.
	(DATA_SEGMENT_RELRO_GOTPLT_END): Pass $SEPARATE_GOTPLT as first
	and . as second argument.
	(GOTPLT): Move $DATA_SEGMENT_RELRO_GOTPLT_END before the section.
	* ldexp.c (fold_unary): Remove DATA_SEGMENT_RELRO_END handling here.
	(fold_binary): Add it here.  Insert padding to make relro_end
	COMMONPAGESIZE bytes aligned.  For DATA_SEGMENT_ALIGN in
	exp_dataseg_relro_adjust phase just use previously computed
	exp_data_seg.base.
	* ldlang.c (lang_size_sections): Set exp_data_seg.base for
	relro_adjust here.  Call lang_size_sections_1 once more if there
	was too big padding at DATA_SEGMENT_RELRO_END.
	* ld.texinfo (DATA_SEGMENT_RELRO_END): Add documentation.
@
text
@d1057 40
d1111 2
a1112 1
  if (!wild->filenames_sorted && (sec == NULL || !sec->spec.sorted))
d1186 1
a1186 1
      if (sec != NULL && sec->spec.sorted)
d1188 2
a1189 4
	  if (strcmp (section_name,
		      bfd_get_section_name (ls->ifile->the_bfd,
					    ls->section))
	      < 0)
d2058 65
d4357 3
d4509 1
a4509 1
      new->filenames_sorted = filespec->sorted;
@


1.162
log
@bfd/
	* elf32-m32r.c (m32r_elf_relocate_section): Don't compare with
	TRUE or FALSE.
ld/
	* ldlang.c (lang_init): Don't compare with TRUE.
@
text
@d3289 1
d3292 6
d3300 27
@


1.161
log
@2004-08-24  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldlang.c (wildcardp): Defined as a macro with strpbrk.
@
text
@d509 2
a510 2
  if (bfd_hash_table_init_n (&lang_definedness_table,
			     lang_definedness_newfunc, 3) != TRUE)
@


1.160
log
@(_place_orphan): Use an already existing section name if that section does not
have any flags set.
@
text
@a69 1
static bfd_boolean wildcardp (const char *);
d109 7
a917 19
/* Return TRUE if the PATTERN argument is a wildcard pattern.
   Although backslashes are treated specially if a pattern contains
   wildcards, we do not consider the mere presence of a backslash to
   be enough to cause the pattern to be treated as a wildcard.
   That lets us handle DOS filenames more naturally.  */

static bfd_boolean
wildcardp (const char *pattern)
{
  const char *s;

  for (s = pattern; *s != '\0'; ++s)
    if (*s == '?'
	|| *s == '*'
	|| *s == '[')
      return TRUE;
  return FALSE;
}

@


1.159
log
@bfd/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* aout-adobe.c (aout_32_section_already_linked): Defined.
	* aout-target.h (MY_section_already_linked): Likewise.
	* aout-tic30.c (MY_section_already_linked): Likewise.
	* binary.c (binary_section_already_linked): Likewise.
	* bout.c (b_out_section_already_linked): Likewise.
	* coff-alpha.c (_bfd_ecoff_section_already_linked): Likewise.
	* coff-mips.c (_bfd_ecoff_section_already_linked): Likewise.
	* coffcode.h (coff_section_already_linked): Likewise.
	* i386msdos.c (msdos_section_already_linked): Likewise.
	* i386os9k.c (os9k_section_already_linked): Likewise.
	* ieee.c (ieee_section_already_linked): Likewise.
	* ihex.c (ihex_section_already_linked): Likewise.
	* mach-o.c (bfd_mach_o_section_already_linked): Likewise.
	* mmo.c (mmo_section_already_linked): Likewise.
	* nlm-target.h (nlm_section_already_linked): Likewise.
	* oasys.c (oasys_section_already_linked): Likewise.
	* pef.c (bfd_pef_section_already_linked): Likewise.
	* ppcboot.c (ppcboot_section_already_linked): Likewise.
	* som.c (som_bfd_discard_group): Likewise.
	* srec.c (srec_section_already_linked): Likewise.
	* tekhex.c (tekhex_section_already_linked): Likewise.
	* versados.c (versados_section_already_linked): Likewise.
	* vms.c (vms_section_already_linked): Likewise.
	* coff-target.h (_bfd_xcoff_section_already_linked): Likewise.
	* xsym.c (bfd_sym_section_already_linked): Likewise.

	* bfd-in.h (bfd_section_already_linked_table_init): New.
	(bfd_section_already_linked_table_free): Likewise.

	* coff-rs6000.c (rs6000coff_vec): Add
	_bfd_generic_section_already_linked.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.

	* elf-bfd.h (_bfd_elf_section_already_linked): New prototype.
	* elflink.c (_bfd_elf_section_already_linked): New function.

	* elfxx-target.h (bfd_elfNN_section_already_linked): Defined.

	* libbfd-in.h (_bfd_nolink_section_already_linked): Defined.
	(_bfd_generic_section_already_linked): New.
	(bfd_section_already_linked_hash_entry): Likewise.
	(bfd_section_already_linked): Likewise.
	(bfd_section_already_linked_table_lookup): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.

	* linker.c (bfd_section_already_linked): New.
	(_bfd_section_already_linked_table): Likewise.
	(bfd_section_already_linked_table_lookup): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.
	(already_linked_newfunc): Likewise.
	(bfd_section_already_linked_table_init): Likewise.
	(bfd_section_already_linked_table_free): Likewise.
	(_bfd_generic_section_already_linked): Likewise.

	* section.c (bfd_section): Remove comdat.
	(bfd_comdat_info): Moved to ...
	* bfd-in.h (coff_comdat_info): Here.
	(bfd_coff_get_comdat_section): New.
	* coffgen.c (bfd_coff_get_comdat_section): Likewise.
	* libcoff-in.h (coff_section_tdata): Add comdat.
	* coffcode.h (handle_COMDAT): Updated.
	* cofflink.c (coff_link_add_symbols): Likewise.
	* ecoff.c (bfd_debug_section): Likewise.

	* targets.c (bfd_target): Add _section_already_linked.
	(BFD_JUMP_TABLE_LINK): Updated.

	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.
	* libcoff.h: Likewise.

binutils/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* objcopy.c (filter_symbols): Use bfd_coff_get_comdat_section
	to access comdat.
	* objdump.c (dump_section_header): Likewise.

ld/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldlang.c (already_linked_hash_entry): Removed.
	(already_linked): Likewise.
	(already_linked_table): Likewise.
	(section_already_linked): Call bfd_section_already_linked.
	(lang_process): Replace already_linked_table_init with
	bfd_section_already_linked_table_init and check return. Replace
	already_linked_table_free with bfd_section_already_linked_table_free.
@
text
@d615 1
@


1.158
log
@(init_os): Make sure that the newly allocated userdata structure is zeroed out.
@
text
@a888 30
/* Sections marked with the SEC_LINK_ONCE flag should only be linked
   once into the output.  This routine checks each section, and
   arrange to discard it if a section of the same name has already
   been linked.  If the section has COMDAT information, then it uses
   that to decide whether the section should be included.  This code
   assumes that all relevant sections have the SEC_LINK_ONCE flag set;
   that is, it does not depend solely upon the section name.
   section_already_linked is called via bfd_map_over_sections.  */

/* This is the shape of the elements inside the already_linked hash
   table. It maps a name onto a list of already_linked elements with
   the same name.  It's possible to get more than one element in a
   list if the COMDAT sections have different names.  */

struct already_linked_hash_entry
{
  struct bfd_hash_entry root;
  struct already_linked *entry;
};

struct already_linked
{
  struct already_linked *next;
  asection *sec;
};

/* The hash table.  */

static struct bfd_hash_table already_linked_table;

a892 4
  flagword flags;
  const char *name;
  struct already_linked *l;
  struct already_linked_hash_entry *already_linked_list;
d902 1
a902 122
  flags = sec->flags;
  if ((flags & SEC_LINK_ONCE) == 0)
    return;

  /* FIXME: When doing a relocatable link, we may have trouble
     copying relocations in other sections that refer to local symbols
     in the section being discarded.  Those relocations will have to
     be converted somehow; as of this writing I'm not sure that any of
     the backends handle that correctly.

     It is tempting to instead not discard link once sections when
     doing a relocatable link (technically, they should be discarded
     whenever we are building constructors).  However, that fails,
     because the linker winds up combining all the link once sections
     into a single large link once section, which defeats the purpose
     of having link once sections in the first place.

     Also, not merging link once sections in a relocatable link
     causes trouble for MIPS ELF, which relies on link once semantics
     to handle the .reginfo section correctly.  */

  name = bfd_get_section_name (abfd, sec);

  already_linked_list =
    ((struct already_linked_hash_entry *)
     bfd_hash_lookup (&already_linked_table, name, TRUE, FALSE));

  for (l = already_linked_list->entry; l != NULL; l = l->next)
    {
      if (sec->comdat == NULL
	  || l->sec->comdat == NULL
	  || strcmp (sec->comdat->name, l->sec->comdat->name) == 0)
	{
	  /* The section has already been linked.  See if we should
             issue a warning.  */
	  switch (flags & SEC_LINK_DUPLICATES)
	    {
	    default:
	      abort ();

	    case SEC_LINK_DUPLICATES_DISCARD:
	      break;

	    case SEC_LINK_DUPLICATES_ONE_ONLY:
	      if (sec->comdat == NULL)
		einfo (_("%P: %B: warning: ignoring duplicate section `%s'\n"),
		       abfd, name);
	      else
		einfo (_("%P: %B: warning: ignoring duplicate `%s'"
			 " section symbol `%s'\n"),
		       abfd, name, sec->comdat->name);
	      break;

	    case SEC_LINK_DUPLICATES_SAME_CONTENTS:
	      /* FIXME: We should really dig out the contents of both
                 sections and memcmp them.  The COFF/PE spec says that
                 the Microsoft linker does not implement this
                 correctly, so I'm not going to bother doing it
                 either.  */
	      /* Fall through.  */
	    case SEC_LINK_DUPLICATES_SAME_SIZE:
	      if (sec->size != l->sec->size)
		einfo (_("%P: %B: warning: duplicate section `%s'"
			 " has different size\n"),
		       abfd, name);
	      break;
	    }

	  /* Set the output_section field so that lang_add_section
	     does not create a lang_input_section structure for this
	     section.  Since there might be a symbol in the section
	     being discarded, we must retain a pointer to the section
	     which we are really going to use.  */
	  sec->output_section = bfd_abs_section_ptr;
	  sec->kept_section = l->sec;

	  if (flags & SEC_GROUP)
	    bfd_discard_group (abfd, sec);

	  return;
	}
    }

  /* This is the first section with this name.  Record it.  Allocate
     the memory from the same obstack as the hash table is kept in.  */

  l = bfd_hash_allocate (&already_linked_table, sizeof *l);

  l->sec = sec;
  l->next = already_linked_list->entry;
  already_linked_list->entry = l;
}

/* Support routines for the hash table used by section_already_linked,
   initialize the table, fill in an entry and remove the table.  */

static struct bfd_hash_entry *
already_linked_newfunc (struct bfd_hash_entry *entry ATTRIBUTE_UNUSED,
			struct bfd_hash_table *table,
			const char *string ATTRIBUTE_UNUSED)
{
  struct already_linked_hash_entry *ret =
    bfd_hash_allocate (table, sizeof (struct already_linked_hash_entry));

  ret->entry = NULL;

  return &ret->root;
}

static void
already_linked_table_init (void)
{
  if (! bfd_hash_table_init_n (&already_linked_table,
			       already_linked_newfunc,
			       42))
    einfo (_("%P%F: Failed to create hash table\n"));
}

static void
already_linked_table_free (void)
{
  bfd_hash_table_free (&already_linked_table);
d4195 2
a4196 1
  already_linked_table_init ();
d4208 1
a4208 1
  already_linked_table_free ();
@


1.157
log
@bfd/

2004-07-19  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfd-in.h (dynamic_lib_link_class): Add DYN_NO_ADD_NEEDED and
	DYN_NO_NEEDED.
	(bfd_elf_get_dyn_lib_class): New prototype.
	* elf.c (bfd_elf_get_dyn_lib_class): New function.

	* elflink.c (elf_link_add_object_symbols): Check DYN_AS_NEEDED,
	DYN_DT_NEEDED and DYN_NO_NEEDED bits to see if a DT_NEEDED
	entry is needed. Issue an error if a DT_NEEDED entry is needed
	for a file marked DYN_NO_NEEDED.
	(elf_link_check_versioned_symbol): Check the DYN_DT_NEEDED bit
	for DT_NEEDED tags.

	* bfd-in2.h: Regenerated.

ld/

2004-07-19  H.J. Lu  <hongjiu.lu@@intel.com>

	* emultempl/elf32.em (gld${EMULATION_NAME}_load_symbols): Also
	check the add_needed field.
	(dt_needed): New struct.
	(gld${EMULATION_NAME}_try_needed): Change the first argument
	to a pointer to struct dt_needed. Check the DYN_NO_ADD_NEEDED
	bit in the file where the DT_NEEDED entry comes from.
	(gld${EMULATION_NAME}_search_needed): Change the second
	argument to a pointer to struct dt_needed.
	(gld${EMULATION_NAME}_check_ld_so_conf): Updated.
	(gld${EMULATION_NAME}_after_open): Likewise.

	* ld.texinfo: Add --add-needed document.
	* ldlang.c (new_afile): Set p->add_needed.
	* ldlang.h (lang_input_statement_type): Add add_needed field.
	* ldmain.h (add_needed): Declare.
	* ldmain.c (add_needed): New global var.
	* lexsup.c (option_values): Add OPTION_ADD_NEEDED and
	OPTION_NO_ADD_NEEDED.
	(ld_options): Likewise.
	(parse_args): Handle them.
@
text
@d788 1
d791 1
a791 1
      *ud->map_symbol_def_tail = def;
d811 1
@


1.156
log
@bfd/
	* elf64-mmix.c (mmix_set_relaxable_size): Save original size in
	rawsize.
	(mmix_elf_perform_relocation): Adjust for above change.
	(mmix_elf_relocate_section): Likewise.
	(mmix_elf_relax_section): Likewise.  Use output_section->rawsize.
	(mmix_elf_get_section_contents): Delete.
	(bfd_elf64_get_section_contents): Delete.
	(mmix_elf_relocate_section): Zero stub area.
	* linker.c (default_indirect_link_order): Alloc max of section size
	and rawsize.
	* simple.c (bfd_simple_get_relocated_section_contents): Likewise.
	* section.c (bfd_malloc_and_get_section): Likewise.
	(struct bfd_section): Update rawsize comment.
	* bfd-in2.h: Regenerate.
ld/
	* ldlang.c (lang_reset_memory_regions): Save last relax pass section
	size in rawsize.
@
text
@d457 1
@


1.155
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d4238 5
a4242 1
    o->size = 0;
@


1.154
log
@	* ldlang.c (lang_finish): Don't free lang_definedness_table.
@
text
@d994 1
a994 2
	      if (bfd_section_size (abfd, sec)
		  != bfd_section_size (l->sec->owner, l->sec))
d2341 1
a2341 1
	  minfo ("0x%V %W", section->vma, section->_raw_size);
d2453 1
a2453 1
  bfd_size_type size = i->_cooked_size != 0 ? i->_cooked_size : i->_raw_size;
d2486 1
a2486 1
      if (size != i->_raw_size)
d2500 1
a2500 1
	  minfo (_("%W (size before relaxing)\n"), i->_raw_size);
d2869 1
a2869 1
  output_section->_raw_size += alignment_needed;
d2914 2
a2915 5
      if (i->_cooked_size != 0)
	dot += TO_ADDR (i->_cooked_size);
      else
	dot += TO_ADDR (i->_raw_size);
      o->_raw_size = TO_SIZE (dot - o->vma);
d2925 1
a2925 1
#define IGNORE_SECTION(bfd, s) \
d2929 1
a2929 1
   || bfd_section_size (bfd, s) == 0)
d2946 1
a2946 1
      if (IGNORE_SECTION (output_bfd, s))
d2960 1
a2960 1
	  if (IGNORE_SECTION (output_bfd, os))
d2968 2
a2969 2
	  s_end = s_start + TO_ADDR (bfd_section_size (output_bfd, s)) - 1;
	  os_end = os_start + TO_ADDR (bfd_section_size (output_bfd, os)) - 1;
d3069 1
a3069 1
		os->bfd_section->_raw_size = input->_raw_size;
d3096 1
a3096 1
		    if (!IGNORE_SECTION (output_bfd, os->bfd_section)
d3179 1
a3179 1
		      + TO_ADDR (os->bfd_section->_raw_size)
d3186 1
a3186 1
	      os->bfd_section->_raw_size
d3194 1
a3194 1
	      dot += TO_ADDR (os->bfd_section->_raw_size);
d3231 1
a3231 1
		      TO_ADDR (os->bfd_section->_raw_size);
d3282 1
a3282 1
	    output_section_statement->bfd_section->_raw_size += size;
d3304 1
a3304 1
	    output_section_statement->bfd_section->_raw_size += size;
d3329 1
a3329 6
	    if (! relax)
	      {
		if (i->_cooked_size == 0)
		  i->_cooked_size = i->_raw_size;
	      }
	    else
a3440 1
  asection *o;
a3479 8
  /* Some backend relaxers want to refer to the output section size.  Give
     them a section size that does not change on the next call while they
     relax.  We can't set this at top because lang_reset_memory_regions
     which is called before we get here, sets _raw_size to 0 on relaxing
     rounds.  */
  for (o = output_bfd->sections; o != NULL; o = o->next)
    o->_cooked_size = o->_raw_size;

d3516 1
a3516 1
		  dot += TO_ADDR (os->bfd_section->_raw_size);
d3603 1
a3603 6
	      {
		if (in->_cooked_size != 0)
		  dot += TO_ADDR (in->_cooked_size);
		else
		  dot += TO_ADDR (in->_raw_size);
	      }
d3694 1
a3694 4
	  if (s->_cooked_size != 0)
	    h->u.def.value = TO_ADDR (s->_cooked_size);
	  else
	    h->u.def.value = TO_ADDR (s->_raw_size);
d3908 2
a3909 2
  section->_cooked_size += ((bfd_vma) 1 << (power_of_two + opb_shift)) - 1;
  section->_cooked_size &= (- (bfd_vma) 1 << (power_of_two + opb_shift));
d3918 1
a3918 1
  h->u.def.value = section->_cooked_size;
d3921 1
a3921 1
  section->_cooked_size += size;
d4238 1
a4238 1
    o->_raw_size = 0;
d4443 1
a4443 1
	     _raw_size.  */
d4778 1
a4778 1
			  + TO_ADDR (bfd_section_size (output_bfd, sec)));
d5617 1
a5617 1
      len = bfd_section_size (is->the_bfd, sec);
@


1.153
log
@	* ldlang.c (gc_section_callback): Move SEC_EXCLUDE twiddles..
	(lang_gc_sections): .. to a LANG_FOR_EACH_INPUT_STATEMENT loop here.
@
text
@d3805 2
a3806 1
  bfd_hash_table_free (&lang_definedness_table);
@


1.152
log
@	* ldlang.c: Formatting.  Wrap long lines, expand bfd_get_section_flags
	throughout file.
	* lexsup.c: Formatting.  Wrap long lines.
	* ldwrite.c: Update copyright date.
@
text
@a4274 6
  /* SEC_EXCLUDE is ignored when doing a relocatable link, except in
     the special case of debug info.  (See bfd/stabs.c)
     Twiddle the flag here, to simplify later linker code.  */
  if (link_info.relocatable && (section->flags & SEC_DEBUGGING) == 0)
    section->flags &= ~SEC_EXCLUDE;

d4335 14
@


1.151
log
@	* ldlang.c (lang_add_section): Don't twidlle SEC_EXCLUDE here.
	(output_section_callback): Nor SEC_KEEP here.
	(gc_section_callback): Twiddle SEC_EXCLUDE here.
	(lang_gc_wild): Delete.  Fold into..
	(lang_gc_sections_1): ..here.  Only call bfd_gc_sections when garbage
	collecting.
	(lang_process): Always call lang_gc_sections.
	(lang_place_orphans): Handle SEC_EXCLUDE sections.
	* emultempl/elf32.em (gld${EMULATION_NAME}_place_orphan): Remove
	SEC_EXCLUDE code.
@
text
@d309 1
a309 2
	    (func,
	     s->output_section_statement.children.head);
d312 2
a313 3
	  lang_for_each_statement_worker
	    (func,
	     s->wild_statement.children.head);
d527 2
a528 1
static lang_memory_region_type **lang_memory_region_list_tail = &lang_memory_region_list;
d544 2
a545 1
	  einfo (_("%P:%S: warning: redeclaration of memory region '%s'\n"), name);
d787 1
a787 1
      def = (struct map_symbol_def *) obstack_alloc (&map_obstack, sizeof *def);
d933 1
a933 2
  flags = bfd_get_section_flags (abfd, sec);

d981 2
a982 1
		einfo (_("%P: %B: warning: ignoring duplicate `%s' section symbol `%s'\n"),
d996 2
a997 1
		einfo (_("%P: %B: warning: duplicate section `%s' has different size\n"),
d1385 1
a1385 1
			void *output)
d1391 2
a1392 8
  if (section->output_section == NULL)
    {
      flagword flags = bfd_get_section_flags (section->owner, section);

      if ((flags & SEC_READONLY) == 0)
	((lang_output_section_statement_type *) output)->all_input_readonly
	  = FALSE;
    }
d1422 2
a1423 2
    search = new_afile (name, lang_input_file_is_search_file_enum, default_target,
			FALSE);
d1817 2
a1818 1
		    einfo (_("%P: warning: could not find any targets that match endianness requirement\n"));
d2152 3
a2154 2
check_input_sections (lang_statement_union_type *s,
		      lang_output_section_statement_type *output_section_statement)
d2876 5
a2880 4
size_input_section (lang_statement_union_type **this_ptr,
		    lang_output_section_statement_type *output_section_statement,
		    fill_type *fill,
		    bfd_vma dot)
d2930 3
a2932 5
  (((bfd_get_section_flags (bfd, s) & SEC_THREAD_LOCAL)			\
    ? ((bfd_get_section_flags (bfd, s) & (SEC_LOAD | SEC_NEVER_LOAD))	\
       != SEC_LOAD)							\
    :  ((bfd_get_section_flags (bfd, s) & (SEC_ALLOC | SEC_NEVER_LOAD)) \
	!= SEC_ALLOC))							\
d3008 2
a3009 1
	  einfo (_("%X%P: address 0x%v of %B section %s is not within region %s\n"),
d3064 4
a3067 3
		    || os->children.head->header.type != lang_input_section_enum)
		  einfo (_("%P%X: Internal error on COFF shared library section %s\n"),
			 os->name);
d3089 1
a3089 2
			|| (((bfd_get_section_flags (output_bfd, os->bfd_section)
			      & (SEC_ALLOC | SEC_LOAD)) != 0)
d3091 2
a3092 1
			    && strcmp (os->region->name, DEFAULT_MEMORY_REGION) == 0))
d3103 2
a3104 1
			&& strcmp (os->region->name, DEFAULT_MEMORY_REGION) == 0
d3115 1
a3115 1
			     http://sources.redhat.com/ml/binutils/2003-04/msg00423.html
d3120 2
a3121 1
			  einfo (_("%P%F: error: no memory region specified for loadable section `%s'\n"),
d3125 2
a3126 1
			  einfo (_("%P: warning: no memory region specified for loadable section `%s'\n"),
d3142 2
a3143 1
			  einfo (_("%P: warning: changing start of section %s by %u bytes\n"),
d3159 2
a3160 1
		      einfo (_("%F%S: non constant or forward reference address expression for section %s\n"),
d3215 2
a3216 4
		&& ((bfd_get_section_flags (output_bfd, os->bfd_section)
		     & SEC_NEVER_LOAD) == 0
		    || (bfd_get_section_flags (output_bfd, os->bfd_section)
			& (SEC_ALLOC | SEC_LOAD))))
d3375 2
a3376 1
		    lang_memory_region_lookup (DEFAULT_MEMORY_REGION, FALSE)->current = newdot;
d3393 2
a3394 1
		if (!(output_section_statement->flags & (SEC_NEVER_LOAD | SEC_ALLOC)))
d3668 5
a3672 4
lang_do_assignments (lang_statement_union_type *s,
		     lang_output_section_statement_type *output_section_statement,
		     fill_type *fill,
		     bfd_vma dot)
d3786 2
a3787 1
		einfo (_("%P: warning: cannot find entry symbol %s; defaulting to %V\n"),
d3798 2
a3799 1
		einfo (_("%P: warning: cannot find entry symbol %s; not setting start address\n"),
d3831 3
a3833 2
      compatible = bfd_arch_get_compatible (input_bfd, output_bfd,
					    command_line.accept_unknown_input_arch);
d3846 2
a3847 1
	  einfo (_("%P%F: Relocatable linking with relocations from format %s (%B) to format %s (%B) is not supported\n"),
d3856 2
a3857 1
	    einfo (_("%P: warning: %s architecture of input file `%B' is incompatible with %s output\n"),
d3878 2
a3879 2
		einfo (_("%P%X: failed to merge target specific data of file %B\n"),
		       input_bfd);
d4040 2
a4041 1
			  info_msg (_("%P: no [COMMON] command, defaulting to .bss\n"));
d4709 3
a4711 2
  /* If no runtime region or VMA has been specified, but the load region has
     been specified, then use the load region for the runtime region as well.  */
d5510 2
a5511 1
      einfo (_("%X%P: anonymous version tag cannot be combined with other version tags\n"));
d5539 2
a5540 2
		    einfo (_("%X%P: duplicate expression `%s' in version information\n"),
			   e1->symbol);
d5546 4
a5549 3
	      if (strcmp (e1->pattern, e2->pattern) == 0 && e1->mask == e2->mask)
		einfo (_("%X%P: duplicate expression `%s' in version information\n"),
		       e1->pattern);
d5565 2
a5566 1
		    einfo (_("%X%P: duplicate expression `%s' in version information\n"),
d5573 4
a5576 3
	      if (strcmp (e1->pattern, e2->pattern) == 0 && e1->mask == e2->mask)
		einfo (_("%X%P: duplicate expression `%s' in version information\n"),
		       e1->pattern);
d5649 1
a5649 2
      bfd_set_section_flags (is->the_bfd, sec,
	bfd_get_section_flags (is->the_bfd, sec) | SEC_EXCLUDE);
@


1.150
log
@bfd/

2004-05-26  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf.c (_bfd_elf_make_section_from_shdr): Undo the last
	change.

ld/

2004-05-26  H.J. Lu  <hongjiu.lu@@intel.com>

	* emultempl/elf32.em (gld${EMULATION_NAME}_place_orphan): Clear
	SEC_EXCLUDE on non-SEC_DEBUGGING sections for relocatable link.
	* ldlang.c (lang_add_section): Likewise.
@
text
@d1092 1
a1092 1
  flagword flags;
a1094 14
  flags = bfd_get_section_flags (section->owner, section);

  /* SEC_EXCLUDE is ignored when doing a relocatable link, except in
     the special case of debug info.  (See bfd/stabs.c)  */
  if (link_info.relocatable && (flags & SEC_DEBUGGING) == 0)
    {
      flags &= ~SEC_EXCLUDE;

      /* Write the modified flag back, to simplify later linker
	 code.  */
      if (section->owner != NULL)
	bfd_set_section_flags (section->owner, section, flags);
    }

a1337 5
  /* If the wild pattern was marked KEEP, the member sections
     should be as well.  */
  if (ptr->keep_sections)
    section->flags |= SEC_KEEP;

d4013 4
a4016 3
		{
		  abort ();
		}
d4256 1
a4256 2
/* If the wild pattern was marked KEEP, the member sections
   should be as well.  */
d4265 8
a4276 8
/* Handle a wild statement, marking it against GC.  */

static void
lang_gc_wild (lang_wild_statement_type *s)
{
  walk_wild (s, gc_section_callback, NULL);
}

d4287 1
a4287 1
	  lang_gc_wild (&s->wild_statement);
d4331 2
a4332 1
  bfd_gc_sections (output_bfd, &link_info);
d4380 1
a4380 2
  if (command_line.gc_sections)
    lang_gc_sections ();
@


1.149
log
@bfd/
	* elf.c (_bfd_elf_make_section_from_shdr): Don't set SEC_EXCLUDE
	for SHT_GROUP sections.
ld/
	* ldlang.c (lang_add_section): Set SEC_EXCLUDE for SEC_GROUP
	sections when doing a final link.  Clear SEC_EXCLUDE when doing
	a relocable link, except for SEC_DEBUGGING sections.
	* emultempl/elf32.em (gld${EMULATION_NAME}_place_orphan): Use the
	same condition here to drop SEC_EXCLUDE orphan sections.
@
text
@d1097 10
a1106 14
  discard = FALSE;

  if (link_info.relocatable)
    {
      /* SEC_EXCLUDE is ignored when doing a relocatable link,
	 except in the special case of debug info.  (See bfd/stabs.c)  */
      if ((flags & SEC_DEBUGGING) == 0)
	flags &= ~SEC_EXCLUDE;
    }
  else
    {
      /* SEC_GROUP sections should be dropped on a final link.  */
      if ((flags & SEC_GROUP) != 0)
	flags |= SEC_EXCLUDE;
a1108 4
  /* Write SEC_EXCLUDE flag back, to simplify later linker code.  */
  if (section->owner != NULL)
    bfd_set_section_flags (section->owner, section, flags);

d1110 1
a1110 2
  if ((flags & SEC_EXCLUDE) != 0)
    discard = TRUE;
@


1.148
log
@bfd/
	* elflink.c (elf_link_add_object_symbols): Don't set up merge
	section data here..
	* elf.c (_bfd_elf_merge_sections): .. Do it here instead.
	* merge.c: Formatting.  Remove unnecessary casts.  Expand
	bfd_get_section_alignment macro.
	(struct sec_merge_sec_info): Rename "first" to "first_str".  Update
	use throughout file.
	(_bfd_add_merge_section): Rename from _bfd_merge_section.  Update
	comment.  Abort on dynamic or non-SEC_MERGE input.  Don't test
	section name to determine sinfo group, instead test output section
	and alignment.
	(_bfd_merge_sections): Add struct bfd_link_info param.  Call
	_bfd_strip_section_from_output rather than just twiddling flags.
	* libbfd-in.h (_bfd_add_merge_section): Rename, update comment.
	(_bfd_merge_sections): Update prototype.
	* libbfd.h: Regenerate.
ld/
	* ldlang.c (lang_process): Call bfd_merge_sections later, and
	only when not a relocatable link.
	(print_input_section): Handle SEC_EXCLUDE sections.
	(size_input_section): Don't update dot on SEC_EXCLUDE sections.
	(lang_do_assignments_1): Likewise.
	* ldwrite.c (build_link_order): Ignore SEC_EXCLUDE input sections.
	* emultempl/armelf.em (arm_elf_set_bfd_for_interworking): Likewise.
	* emultempl/hppaelf.em (build_section_lists): Likewise.
	* emultempl/ppc64elf.em (build_toc_list): Likewise.
	(build_section_lists): Likewise.
@
text
@d1099 20
a1118 5
  /* Discard sections marked with SEC_EXCLUDE if we are doing a final
     link.  Discard debugging sections marked with SEC_EXCLUDE on a
     relocatable link too.  */
  if ((flags & SEC_EXCLUDE) != 0
      && ((flags & SEC_DEBUGGING) != 0 || !link_info.relocatable))
@


1.147
log
@	* NEWS: Mention new linker map file generation and the
	--reduce-memory-overheads option.
	* ld.texinfo: Document --reduce-memory-overheads option.
	* ld.h (map_symbol_def): New struct.
	(struct user_section_struct, section_userdata_type): Rename to:
	(struct lean_user_section_struct, lean_section_userdata_type).
	(struct fat_user_section_struct, fat_section_userdata_type): New.
	(SECTION_USERDATA_SIZE): Define.
	(args_type): New member reduce_memory_overheads.
	* ldlang.c (map_obstack): New static variable.
	(init_map_userdata, print_all_symbols, sort_def_symbol): New functions.
	(lang_map): Unless command_line.reduce_memory_overheads is set,
	initialize lists of defined symbols for each section.
	(print_input_section): Unless command_line.reduce_memory_overheads
	is set, use print_all_symbols.
	(init_os): Use lean_section_userdata_type / SECTION_USERDATA_SIZE.
	* ldmain.c (main): Initialize command_line.reduce_memory_overheads.
	* lexsup.c (enum option_values): Add OPTION_REDUCE_MEMORY_OVERHEADS.
	(ld_options): Add entry for --reduce-memory-overheads.
	(parse_args): Handle OPTION_REDUCE_MEMORY_OVERHEADS.
@
text
@d2475 3
a2478 1

d2481 2
a2482 1
      if (i->output_section != NULL)
d2484 8
a2491 1
	  int len;
d2493 7
a2499 11
	  len = 1 + strlen (i->name);
	  if (len >= SECTION_NAME_MAP_LENGTH - 1)
	    {
	      print_nl ();
	      len = 0;
	    }
	  while (len < SECTION_NAME_MAP_LENGTH)
	    {
	      print_space ();
	      ++len;
	    }
d2501 1
a2501 3
	  minfo ("0x%V %W %B\n",
		 i->output_section->vma + i->output_offset, TO_ADDR (size),
		 i->owner);
d2503 3
a2505 3
	  if (i->_cooked_size != 0 && i->_cooked_size != i->_raw_size)
	    {
	      len = SECTION_NAME_MAP_LENGTH + 3;
d2507 1
a2507 1
	      len += 16;
d2509 1
a2509 1
	      len += 8;
d2511 5
a2515 5
	      while (len > 0)
		{
		  print_space ();
		  --len;
		}
d2517 2
a2518 2
	      minfo (_("%W (size before relaxing)\n"), i->_raw_size);
	    }
d2520 2
d2527 1
a2527 2
	  print_dot = (i->output_section->vma + i->output_offset
		       + TO_ADDR (size));
d2900 1
a2900 1
  if (!is->ifile->just_syms_flag)
d3630 7
a3636 4
	    if (in->_cooked_size != 0)
	      dot += TO_ADDR (in->_cooked_size);
	    else
	      dot += TO_ADDR (in->_raw_size);
a4394 6
  /* If there were any SEC_MERGE sections, finish their merging, so that
     section sizes can be computed.  This has to be done after GC of sections,
     so that GCed sections are not merged, but before assigning output
     sections, since removing whole input sections is hard then.  */
  bfd_merge_sections (output_bfd, &link_info);

d4407 8
d4416 1
a4416 1
      asection *found = bfd_get_section_by_name (output_bfd, ".text");
@


1.146
log
@	* ldgram.y (sect_constraint): New.
	(ONLY_IF_RO, ONLY_IF_RW): New tokens.
	(section): Add sect_constraint.  Pass additional argument
	to lang_enter_output_section_statement.
	* mri.c (mri_draw_tree): Pass additional argument to
	lang_enter_output_section_statement.
	* emultempl/pe.em (place_orphan): Likewise.
	(output_prev_sec_find): Disregard output section statements with
	constraint == -1.
	* emultempl/mmo.em (output_prev_sec_find): Likewise.
	(mmo_place_orphan): Pass additional argument to
	lang_enter_output_section_statement.
	* emultempl/elf32.em (output_prev_sec_find): Disregard output section
	statements with constraint == -1.
	(place_orphan): Pass additional argument to
	lang_enter_output_section_statement.
	* ldlang.c (lang_enter_overlay_section): Likewise.
	(lang_output_section_find_1): New.
	(lang_output_section_find): Use it.
	(lang_output_section_statement_lookup_1): New.
	(lang_output_section_statement_lookup): Use it.
	(check_section_callback, check_input_sections): New.
	(map_input_to_output_sections): Check if all input sections
	are readonly if ONLY_IF_RO or ONLY_IF_RW was seen.
	(strip_excluded_output_sections): Disregard output section statements
	with constraint == -1.
	(lang_record_phdrs): Likewise.
	(lang_enter_output_section_statement): Add constraint argument.
	Use lang_output_section_statement_lookup_1.
	* ldlang.h (lang_output_section_statement_type): Add constraint
	and all_input_readonly fields.
	(lang_enter_output_section_statement): Adjust prototype.
	* ldlex.l (ONLY_IF_RO, ONLY_IF_RW): New tokens.
	* scripttempl/elf.sc (.eh_frame, .gcc_except_table): Move into text
	segment if all input sections are readonly.
@
text
@d50 1
d69 1
d77 2
d695 1
d741 7
d751 44
d800 1
a800 1
  section_userdata_type *new;
d808 1
a808 1
  new = stat_alloc (sizeof (section_userdata_type));
d2426 1
a2426 1
   via bfd_link_hash_traverse.  */
d2452 12
d2516 4
a2519 1
	  bfd_link_hash_traverse (link_info.hash, print_one_symbol, i);
@


1.145
log
@bfd/
	* elflink.c (elf_bfd_final_link): Don't output STT_SECTION symbol
	into .dynsym if elf_section_data (sec)->dynindx <= 0.
	Adjust counting of last_local.
	(_bfd_elf_link_renumber_dynsyms): Don't assign dynindx to sections
	other than SHT_PROGBITS/SHT_NOBITS and neither for .got/.got.plt/.plt
	created by the linker nor !SHF_ALLOC.

	* elf32-i386.c (elf_i386_finish_dynamic_sections): Point
	DT_PLTGOT to the start of the .got.plt section instead of the
	.got output section.  Set sh_entsize for .got section in addition
	to .got.plt.
	(elf_i386_relocate_section): Don't assume _GLOBAL_OFFSET_TABLE_
	is at sgot->output_section->vma.
	* elf64-x86-64.c (elf64_x86_64_finish_dynamic_sections): Point
	DT_PLTGOT to the start of the .got.plt section instead of the
	.got output section.
	(elf64_x86_64_relocate_section): Don't assume _GLOBAL_OFFSET_TABLE_
	is at sgot->output_section->vma.  Set sh_entsize for .got section
	in addition to .got.plt.
	* elf.c (_bfd_elf_print_private_bfd_data): Handle PT_GNU_RELRO.
	(bfd_section_from_phdr): Likewise.
	(map_sections_to_segments): Likewise.
	(assign_file_positions_for_segments): Likewise.
	(get_program_header_size): Likewise.
	* elflink.c (bfd_elf_size_dynamic_sections): Set
	elf_tdata (output_bfd)->relro from info->relro.
	* elf-bfd.h (struct elf_obj_tdata): Add relro field.
include/
	* bfdlink.h (struct bfd_link_info): Add relro, relro_start and
	relro_end fields.
	* elf/common.h (PT_GNU_EH_FRAME, PT_GNU_STACK): Add comments.
	(PT_GNU_RELRO): Define.
binutils/
	* readelf.c (get_segment_type): Handle PT_GNU_RELRO.
ld/
	* genscripts.sh: Generate -z combreloc -z now -z relro scripts
	for binaries, -shared and -pie.
	* emulparams/elf_i386.sh (SEPARATE_GOTPLT): Set.
	* emulparams/elf_x86_64.sh (SEPARATE_GOTPLT): Set.
	* emulparams/elf32ppc.sh (OTHER_READWRITE_SECTIONS): Rename to...
	(OTHER_RELRO_SECTIONS): ... this.
	* ldlex.l (DATA_SEGMENT_RELRO_END): Add.
	* emultempl/elf32.em (gld${EMULATION_NAME}_handle_option): Handle
	-z relro and -z norelro.
	(gld${EMULATION_NAME}_list_options): Add it to usage.
	(gld${EMULATION_NAME}_get_script): Return -z combreloc -z now
	-z relro scripts when appropriate.
	* scripttempl/elf.sc: Unset SEPARATE_GOTPLT if RELRO_NOW is set.
	Create separate .got.plt section if SEPARATE_GOTPLT.
	Move sections which are only written during relocation handling
	to the beginning of RW segment.  If NO_SMALL_DATA, move .got
	before .data.  Add DATA_SEGMENT_RELRO_END directive.
	Include OTHER_RELRO_SECTIONS.
	* ldgram.y (DATA_SEGMENT_RELRO_END): Add.
	* ldexp.c (exp_print_token): Handle DATA_SEGMENT_RELRO_END.
	(fold_unary): Likewise.
	(fold_binary): Handle -z relro.
	* ldexp.h (struct exp_data_seg): Add exp_dataseg_relro_seen and
	exp_dataseg_relro_adjust phases.  Add relro_end field.
	* ldmain.c (main): Initialize link_info.relro to FALSE.
	* ldlang.c (lang_size_sections): Handle -z relro.
ld/testsuite/
	* ld-i386/tlspic.rd: Adjust for section reordering changes
	and removal of unneeded STT_SECTION symbols from .dynsym.
	* ld-i386/tlspic.dd: Likewise.
	* ld-i386/tlspic.sd: Likewise.
	* ld-i386/tlsbin.rd: Likewise.
	* ld-i386/tlsbinpic.s: Likewise.
	* ld-i386/tlsbin.dd: Likewise.
	* ld-i386/tlsbin.sd: Likewise.
	* ld-i386/tlsnopic.rd: Likewise.
	* ld-i386/tlsnopic1.s: Likewise.
	* ld-i386/combreloc.d: Likewise.
	* ld-i386/tlsnopic.dd: Likewise.
	* ld-i386/tlsnopic.sd: Likewise.
	* ld-x86-64/tlspic.rd: Likewise.
	* ld-x86-64/tlspic.dd: Likewise.
	* ld-x86-64/tlsbin.dd: Likewise.
	* ld-x86-64/tlspic.sd: Likewise.
	* ld-x86-64/tlsbin.sd: Likewise.
	* ld-x86-64/tlspic.td: Likewise.
	* ld-x86-64/tlsbin.td: Likewise.
	* ld-x86-64/tlsbin.rd: Likewise.
	* ld-s390/tlspic1.s: Likewise.
	* ld-s390/tlsbinpic.s: Likewise.
	* ld-s390/tlspic.rd: Likewise.
	* ld-s390/tlsbin.rd: Likewise.
	* ld-s390/tlspic.dd: Likewise.
	* ld-s390/tlsbin.dd: Likewise.
	* ld-s390/tlsbin.sd: Likewise.
	* ld-s390/tlsbin.td: Likewise.
	* ld-s390/tlspic.sd: Likewise.
	* ld-s390/tlspic.td: Likewise.
	* ld-s390/tlspic1_64.s: Likewise.
	* ld-s390/tlsbinpic_64.s: Likewise.
	* ld-s390/tlspic_64.rd: Likewise.
	* ld-s390/tlsbin_64.rd: Likewise.
	* ld-s390/tlspic_64.dd: Likewise.
	* ld-s390/tlsbin_64.dd: Likewise.
	* ld-s390/tlspic_64.sd: Likewise.
	* ld-s390/tlspic_64.td: Likewise.
	* ld-s390/tlsbin_64.td: Likewise.
	* ld-s390/tlsbin_64.sd: Likewise.
	* ld-powerpc/tlsexe32.r: Likewise.
	* ld-powerpc/tlsso32.r: Likewise.
	* ld-powerpc/tlsso32.d: Likewise.
	* ld-powerpc/tlsso32.g: Likewise.
	* ld-powerpc/tlsso32.t: Likewise.
	* ld-powerpc/tlsexe.r: Likewise.
	* ld-powerpc/tlsso.r: Likewise.
	* ld-powerpc/tlsso.g: Likewise.
	* ld-powerpc/tlsexetoc.r: Likewise.
	* ld-powerpc/tlstocso.r: Likewise.
	* ld-powerpc/tlstocso.g: Likewise.
	* ld-ia64/tlspic.rd: Likewise.
	* ld-ia64/tlspic.dd: Likewise.
	* ld-ia64/tlspic.sd: Likewise.
	* ld-ia64/tlspic.td: Likewise.
	* ld-ia64/tlsbin.rd: Likewise.
	* ld-ia64/tlsbin.sd: Likewise.
	* ld-ia64/tlsbin.td: Likewise.
	* ld-elfvsb/elfvsb.exp: XFAIL non-PIC load offset tests on s390x.
	* ld-shared/shared.exp: Likewise.
@
text
@d601 2
a602 2
lang_output_section_statement_type *
lang_output_section_find (const char *const name)
d610 3
a612 1
      if (strcmp (name, lookup->name) == 0)
d619 7
a625 1
lang_output_section_statement_lookup (const char *const name)
d629 1
a629 1
  lookup = lang_output_section_find (name);
d642 1
d662 6
d1333 24
d2110 34
d2164 17
d2255 2
d4124 2
a4125 1
				     etree_type *ebase)
d4131 2
a4132 1
    lang_output_section_statement_lookup (output_section_statement_name);
d4834 2
d4895 2
a4896 1
      if (u->output_section_statement.bfd_section == NULL)
d4968 1
a4968 1
				       0, overlay_subalign, 0);
@


1.144
log
@	* ldlang.c (print_padding_statement): Cast size_t to bfd_vma
	before printing it with %W.
@
text
@d3300 13
a3312 1
  if (exp_data_seg.phase == exp_dataseg_end_seen)
@


1.143
log
@	* ldlang.c (unique_section_p): Pass section parm, return true on
	group sections.
	(output_section_callback): Adjust.
	* ldlang.h (unique_section_p): Update prototype.
	* emultempl/elf32.em (gld${EMULATION_NAME}_place_orphan): Adjust.
@
text
@d2493 1
a2493 1
  minfo ("0x%V %W ", addr, s->size);
@


1.142
log
@	* ldlang.c (lang_do_assignments_1): Handle .tbss output section
	specially.
@
text
@d124 1
a124 1
unique_section_p (const char *secnam)
d127 1
d129 6
d1272 1
a1272 1
  if (unique_section_p (bfd_get_section_name (file->the_bfd, section)))
@


1.141
log
@bfd/
	* elf-bfd.h (struct elf_obj_tdata): Delete dt_soname field.  Add
	dyn_lib_class field.  Rearrange for better packing.
	(elf_dt_soname): Delete.
	(elf_dyn_lib_class): Define.
	* elf.c (bfd_elf_set_dt_needed_name): Update comment.
	(bfd_elf_set_dt_needed_soname): Delete.
	(bfd_elf_set_dyn_lib_class): New function.
	* elflink.h (add_dt_needed_tag): New function.  Split out from..
	(elf_link_add_object_symbols): ..here.  Rename "name" to "soname".
	Use elf_dyn_lib_class to set dt_needed and add_needed.  Move fallback
	initialization of soname.
	(elf_link_check_versioned_symbol): Test elf_dyn_lib_class instead of
	elf_dt_soname.
	* bfd-in.h (enum dynamic_lib_link_class): New.
	(bfd_elf_set_dt_needed_soname): Delete.
	(bfd_elf_set_dyn_lib_class): Declare.
	* bfd-in2.h: Regenerate.
ld/
	* ld.texinfo: Add --as-needed doco.
	* ldmain.c (as_needed): New global var.
	* ldmain.h (as_needed): Declare.
	* lexsup.c (option_values): Add OPTION_AS_NEEDED and
	OPTION_NO_AS_NEEDED.
	(ld_options): Likewise.
	(parse_args): Handle them.
	* ldlang.h (lang_input_statement_type): Add as_needed field.
	* ldlang.c (new_afile): Set p->as_needed.
	* emultempl/elf32.em (gld${EMULATION_NAME}_load_symbols): New function.
	(gld${EMULATION_NAME}_try_needed): Use bfd_elf_set_dyn_lib_class.
	(ld_${EMULATION_NAME}_emulation): Set LDEMUL_RECOGNIZED_FILE entry.

	* ldlang.c (open_input_bfds): Remove useless cast.
	(lang_do_assignments_1): Likewise.
	(lang_for_each_input_section): Delete.
@
text
@d3353 5
a3357 3
		dot = (os->bfd_section->vma
		       + TO_ADDR (os->bfd_section->_raw_size));

@


1.140
log
@	* elf.c (map_sections_to_segments): Ignore .tbss sections for
	layout purposes.

	* ldlang.c (lang_add_section): Don't force SEC_LOAD on
	SEC_THREAD_LOCAL.
	(IGNORE_SECTION): Ignore .tbss sections too.
	(lang_size_sections_1): .tbss sections do not advance dot.

	* ld-scripts/size.exp: New.
	* ld-scripts/size-[12].{d,s,t}: New.
@
text
@d448 1
d1846 1
a1846 1
	    (void) lookup_name (s->wild_statement.filename);
d3352 1
a3352 2
		(void) lang_do_assignments_1 (os->children.head, os,
					      os->fill, dot);
a3939 18

#if 0

/* Not used.  */

void
lang_for_each_input_section (void (*func) (bfd *ab, asection *as))
{
  LANG_FOR_EACH_INPUT_STATEMENT (f)
    {
      asection *s;

      for (s = f->the_bfd->sections; s != NULL; s = s->next)
	func (f->the_bfd, s);
    }
}

#endif
@


1.139
log
@	* ldlang.c (lang_check): Use %P, not %E, in error message.
@
text
@a1103 4
      /* For now make .tbss normal section.  */
      if ((flags & SEC_THREAD_LOCAL) && ! link_info.relocatable)
	flags |= SEC_LOAD;

d2769 5
a2773 2
  (((bfd_get_section_flags (bfd, s) & (SEC_ALLOC | SEC_NEVER_LOAD))	\
    != SEC_ALLOC)							\
a3022 4
	    else if ((os->bfd_section->flags & SEC_HAS_CONTENTS) == 0
		     && (os->bfd_section->flags & SEC_THREAD_LOCAL)
		     && ! link_info.relocatable)
	      os->bfd_section->_raw_size = 0;
d3027 7
a3033 1
	    dot = os->bfd_section->vma + TO_ADDR (os->bfd_section->_raw_size);
@


1.138
log
@	* ldlang.h (struct lang_output_section_state): Change processed
	field's type.
	* ldexp.c (check, invalid): Remove.
	(fold_name): Move valid_p assignments. Create undefined symbol
	when needed. Directly exampine section's processd flag.
	* ldlang.c (lang_output_section_statement_lookup): Adjust
	processed field init.
	(lang_size_sections_1): Allow LOADADDR when determining section's
	VMA. Adjust error message. Fold data statement's expr.
	(lang_size_sections): Correctly increment lang_statement_iteration.

	* ld-scripts/provide.exp: New.
	* ld-scripts/provide-{1,2,3}.{s,t,d}.exp: New.

	* ldexp.c (fold_tree): Follow indirect symbols.
@
text
@d3689 1
a3689 1
		einfo (_("%E%X: failed to merge target specific data of file %B\n"),
@


1.137
log
@	* ldlang.c (map_input_to_output_sections): Initialize sections
	mentioned in a data statement expression.
	(lang_do_assignments_1): Add data statement's expression's
	section's vma.
	* ld-scripts/data.{s,t,d,exp}: New.
@
text
@d625 1
a625 1
      lookup->processed = FALSE;
d2987 1
d2992 2
d2995 1
a2995 1
		      einfo (_("%F%S: non constant address expression for section %s\n"),
d3033 1
a3033 1
	    os->processed = TRUE;
d3095 5
d3305 1
@


1.136
log
@	* ldgram.y (statement_anywhere): Add assert rule.
	* ldlang.c (exp_init_os): Add assert case.
	* testsuite/ld-scripts/assert.{s,t,exp}: New.
@
text
@d2101 5
a2108 1
	case lang_data_statement_enum:
a3381 1
	    s->data_statement.value = value.value;
d3384 2
@


1.136.2.1
log
@	* ldlang.c (map_input_to_output_sections): Initialize sections
	mentioned in a data statement expression.
	(lang_do_assignments_1): Add data statement's expression's
	section's vma.
	* ld-scripts/data.{s,t,d,exp}: New.
@
text
@a2100 5
	case lang_data_statement_enum:
	  /* Make sure that any sections mentioned in the expression
	     are initialized.  */
	  exp_init_os (s->data_statement.exp);
	  /* FALLTHROUGH */
d2104 1
d3378 1
a3380 2
	    s->data_statement.value
	      = value.value + value.section->bfd_section->vma;
@


1.136.2.2
log
@	* ldlang.h (struct lang_output_section_state): Change processed
	field's type.
	* ldexp.c (check, invalid): Remove.
	(fold_name): Move valid_p assignments. Create undefined symbol
	when needed. Directly exampine section's processd flag.
	* ldlang.c (lang_output_section_statement_lookup): Adjust
	processed field init.
	(lang_size_sections_1): Allow LOADADDR when determining section's
	VMA. Adjust error message. Fold data statement's expr.
	(lang_size_sections): Correctly increment lang_statement_iteration.

	* ld-scripts/provide.exp: New.
	* ld-scripts/provide-{1,2,3}.{s,t,d}.exp: New.

	* ldexp.c (fold_tree): Follow indirect symbols.
@
text
@d625 1
a625 1
      lookup->processed = 0;
a2986 1
		    os->processed = -1;
a2990 2
		    os->processed = 0;
		    
d2992 1
a2992 1
		      einfo (_("%F%S: non constant or forward reference address expression for section %s\n"),
d3030 1
a3030 1
	    os->processed = 1;
a3091 5
	    /* We might refer to provided symbols in the expression, and
	       need to mark them as needed.  */
	    exp_fold_tree (s->data_statement.exp, abs_output_section,
			   lang_allocating_phase_enum, dot, &dot);

a3296 1
	  lang_statement_iteration++;
@


1.136.2.3
log
@	* elf.c (map_sections_to_segments): Ignore .tbss sections for
	layout purposes.

	* ldlang.c (lang_add_section): Don't force SEC_LOAD on
	SEC_THREAD_LOCAL.
	(IGNORE_SECTION): Ignore .tbss sections too.
	(lang_size_sections_1): .tbss sections do not advance dot.

	* ld-scripts/size.exp: New.
	* ld-scripts/size-[12].{d,s,t}: New.
@
text
@d1104 4
d2773 2
a2774 5
  (((bfd_get_section_flags (bfd, s) & SEC_THREAD_LOCAL)			\
    ? ((bfd_get_section_flags (bfd, s) & (SEC_LOAD | SEC_NEVER_LOAD))	\
       != SEC_LOAD)							\
    :  ((bfd_get_section_flags (bfd, s) & (SEC_ALLOC | SEC_NEVER_LOAD)) \
	!= SEC_ALLOC))							\
d3024 4
d3032 1
a3032 7
	    dot = os->bfd_section->vma;
	    /* .tbss sections effectively have zero size.  */
	    if ((os->bfd_section->flags & SEC_HAS_CONTENTS) != 0
		|| (os->bfd_section->flags & SEC_THREAD_LOCAL) == 0
		|| link_info.relocatable)
	      dot += TO_ADDR (os->bfd_section->_raw_size);

@


1.136.2.4
log
@Merge from mainline
@
text
@a447 1
  p->as_needed = as_needed;
d1845 1
a1845 1
	    lookup_name (s->wild_statement.filename);
d3351 2
a3352 1
		lang_do_assignments_1 (os->children.head, os, os->fill, dot);
d3940 18
@


1.136.2.5
log
@Merge to 2.15 branch.
@
text
@d3690 1
a3690 1
		einfo (_("%P%X: failed to merge target specific data of file %B\n"),
@


1.135
log
@* ldlang.c (lang_get_regions): Add extra parameter 'have_vma' which if true will
  prevent the LMA region being used as a replacement for a default VMA region.
  (lang_leave_output_section_statement): Pass extra parameter.
  (lang_leave_overlay): Likewise.
* ld.texinfo (Output Section LMA): Document that the LMA region can be set to
  the VMA region if no VMA has been set.
* ldlang.h (struct lang_output_section_phdr_list): Create a typedef for this
  type.  Minor formatting fixes.
@
text
@d778 4
@


1.134
log
@If dot is advanced, then assume that the section should be allocated.
@
text
@d2831 1
a2831 1
		 struct memory_region_struct *region,
d4506 2
a4507 2
lang_get_regions (struct memory_region_struct **region,
		  struct memory_region_struct **lma_region,
d4510 2
a4511 1
		  int have_lma_p)
d4515 5
a4519 3
  /* If no runtime region has been given, but the load region has
     been, use the load region.  */
  if (lma_memspec != 0 && strcmp (memspec, DEFAULT_MEMORY_REGION) == 0)
d4524 1
a4524 1
  if (have_lma_p && lma_memspec != 0)
d4529 3
a4531 3
lang_leave_output_section_statement
  (fill_type *fill, const char *memspec,
   struct lang_output_section_phdr_list *phdrs, const char *lma_memspec)
d4536 2
a4537 1
		    current_section->load_base != 0);
d4696 1
a4696 1
  struct lang_output_section_phdr_list *last;
d4715 1
a4715 1
	  struct lang_output_section_phdr_list *pl;
d4775 1
a4775 1
      struct lang_output_section_phdr_list *pl;
d4792 1
a4792 1
lang_add_nocrossref (struct lang_nocrossref *l)
d4877 1
a4877 1
			    struct lang_output_section_phdr_list *phdrs)
d4924 1
a4924 1
		    struct lang_output_section_phdr_list *phdrs,
d4930 1
a4930 1
  struct lang_nocrossref *nocrossref;
d4934 1
a4934 1
		    lma_expr != 0);
d4971 1
a4971 1
	  struct lang_nocrossref *nc;
@


1.133
log
@	* ldlang.c (IGNORE_SECTION): Don't ignore SEC_ALLOC && !SEC_LOAD
	sections.  Do ignore SEC_NEVER_LOAD sections.
	(lang_size_sections_1): Remove test made redundant with the above.
@
text
@d3208 6
@


1.132
log
@	* ldexp.c (align_n): Make static.
	* ldexp.h (align_n): Delete declaration.
	* ldlang.h (lang_enter_output_section_statement): Remove
	block_value param.
	* ldlang.c (lang_enter_output_section_statement): Likewise.
	(TO_ADDR, TO_SIZE): Define.
	(opb): New var.
	(init_opb): New function.
	(print_input_section): Call init_opb and use TO_ADDR.
	(print_data_statement, print_reloc_statement): Likewise.
	(print_padding_statement): Likewise.
	(size_input_section): Use TO_SIZE and TO_ADDR, and global opb.
	(lang_check_section_addresses): Likewise.
	(lang_size_sections_1): Likewise.
	(lang_do_assignments_1): Likewise.
	(lang_set_startof): Likewise.
	(lang_one_common): Likewise.  Combine power_of_two and opb alignment.
	(lang_process): Call init_opb.
	(lang_abs_symbol_at_end_of): Use TO_ADDR and global opb.
	(lang_enter_overlay_section): Adjust
	lang_enter_output_section_statement call.
	* ldgram.y: Likewise.
	* mri.c (mri_draw_tree): Likewise.
	* emultempl/elf32.em (gld${EMULATION_NAME}_place_orphan): Likewise.
	* emultempl/mmo.em (mmo_place_orphan): Likewise.
	* emultempl/pe.em (gld${EMULATION_NAME}_place_orphan): Likewise.
@
text
@d2765 2
a2766 2
  (((bfd_get_section_flags (bfd, s) & (SEC_ALLOC | SEC_LOAD))	\
    != (SEC_ALLOC | SEC_LOAD))					\
a2932 2
			&& (bfd_get_section_flags (output_bfd, os->bfd_section)
			    & SEC_NEVER_LOAD) == 0
@


1.131
log
@2003-12-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldlang.c (lang_vers_match): Pass "DMGL_PARAMS | DMGL_ANSI" to
	cplus_demangle.
@
text
@d3 1
a3 1
   2001, 2002, 2003
d1802 24
d2299 2
a2300 2
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture,
						ldfile_output_machine);
d2324 1
a2324 1
		 i->output_section->vma + i->output_offset, size / opb,
d2346 2
a2347 1
	  print_dot = i->output_section->vma + i->output_offset + size / opb;
a2369 2
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture,
						ldfile_output_machine);
d2371 1
d2415 1
a2415 2
  print_dot = addr + size / opb;

a2436 2
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture,
						ldfile_output_machine);
d2438 1
d2459 1
a2459 1
  print_dot = addr + size / opb;
a2466 2
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture,
						ldfile_output_machine);
d2468 1
d2493 1
a2493 1
  print_dot = addr + s->size / opb;
a2721 2
      unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture,
						    ldfile_output_machine);
d2741 1
a2741 1
	  insert_pad (this_ptr, fill, alignment_needed * opb, o, dot);
d2751 1
a2751 1
	dot += i->_cooked_size / opb;
d2753 2
a2754 2
	dot += i->_raw_size / opb;
      o->_raw_size = (dot - o->vma) * opb;
a2776 1
  unsigned opb = bfd_octets_per_byte (output_bfd);
d2804 1
a2804 1
	  s_start  = bfd_section_lma (output_bfd, s);
d2806 2
a2807 2
	  s_end    = s_start  + bfd_section_size (output_bfd, s) / opb - 1;
	  os_end   = os_start + bfd_section_size (output_bfd, os) / opb - 1;
a2871 3
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture,
						ldfile_output_machine);

d3008 4
a3011 3
	    after = align_n (os->bfd_section->vma
			     + os->bfd_section->_raw_size / opb,
			     (bfd_vma) os->block_value);
d3020 2
a3021 2
	      os->bfd_section->_raw_size =
		(after - os->bfd_section->vma) * opb;
d3023 1
a3023 1
	    dot = os->bfd_section->vma + os->bfd_section->_raw_size / opb;
d3061 1
a3061 1
		      os->bfd_section->_raw_size / opb;
d3104 3
a3106 3
	    if (size < opb)
	      size = opb;
	    dot += size / opb;
d3128 1
a3128 1
	    dot += size / opb;
d3203 1
a3203 1
		    insert_pad (&s->header.next, fill, (newdot - dot) * opb,
a3309 3
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture,
						ldfile_output_machine);

d3331 2
a3332 1
		dot = os->bfd_section->vma + os->bfd_section->_raw_size / opb;
d3394 3
a3396 3
	    if (size < opb)
	      size = opb;
	    dot += size / opb;
d3411 1
a3411 1
	  dot += bfd_get_reloc_size (s->reloc_statement.howto) / opb;
d3419 1
a3419 1
	      dot += in->_cooked_size / opb;
d3421 1
a3421 1
	      dot += in->_raw_size / opb;
d3441 1
a3441 1
	  dot += s->padding_statement.size / opb;
d3464 1
a3464 2
		     lang_output_section_statement_type
		     *output_section_statement,
a3509 4
	  unsigned opb;

	  opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture,
					       ldfile_output_machine);
d3512 1
a3512 1
	    h->u.def.value = s->_cooked_size / opb;
d3514 1
a3514 1
	    h->u.def.value = s->_raw_size / opb;
a3707 2
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture,
						ldfile_output_machine);
d3721 3
a3723 3
  /* Increase the size of the section.  */
  section->_cooked_size = align_n ((section->_cooked_size + opb - 1) / opb,
				   (bfd_vma) 1 << power_of_two) * opb;
a4003 1
				     bfd_vma block_value,
d4030 1
a4030 1
  os->block_value = block_value ? block_value : 1;
d4156 1
d4592 1
a4592 2
			  + bfd_section_size (output_bfd, sec) /
                          bfd_octets_per_byte (output_bfd));
d4841 1
a4841 1
				       0, 0, overlay_subalign, 0);
@


1.130
log
@bfd/

2003-12-04  H.J. Lu  <hongjiu.lu@@intel.com>

	* elfxx-ia64.c (elfNN_ia64_relax_section): Use the
	need_relax_finalize field in link_info instead of
	relax_finalizing to check if the relax finalize pass is being
	done.

include/

2003-12-04  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfdlink.h (bfd_link_info): Change relax_finalizing to
	need_relax_finalize.

ld/

2003-12-04  H.J. Lu  <hongjiu.lu@@intel.com>

	* emultempl/ia64elf.em (gld${EMULATION_NAME}_after_parse): Set
	link_info.need_relax_finalize to TRUE.

	* ldlang.c (lang_process): Use link_info.need_relax_finalize
	instead of link_info.relax_finalizing.
	* ldmain.c (main): Likewise.
@
text
@d4999 1
a4999 1
      cxx_sym = cplus_demangle (sym, /* DMGL_NO_TPARAMS */ 0);
@


1.129
log
@	* ldlang.c (lang_do_assignments): Function return is void.
	* ldlang.h (lang_do_assignments): Ditto.
	* emultempl/netbsd.em (gld${EMULATION_NAME}_before_parse): Declare.
	* Makefile.am (ens32knbsd.c): Depend on netbsd.em.
	* Makefile.in: Regenerate.
@
text
@d4265 1
a4265 1
	  if (!relax_again && !link_info.relax_finalizing)
d4267 1
a4267 1
	      link_info.relax_finalizing = TRUE;
@


1.128
log
@Fix IA-64 linker failure reported by Andreas Schwab.
	* ldlang.c (lang_process): Move lang_reset_memory_regions call after
	lang_do_assignments call.
@
text
@d3448 1
a3448 1
bfd_vma
@


1.127
log
@When looking for a previously loaded file compare the local_sym_name not the
filename, as the filename might have been transformed via the search directory
path lookup.  If the sought-for file has not been found in the input file
chain then create a new node with the search_dirs_flag set so that the entire
set of directory paths will be scanned for it.
@
text
@a4242 2
	  lang_reset_memory_regions ();

d4254 4
d4274 1
a4275 1
      lang_do_assignments (statement_list.head, abs_output_section, NULL, 0);
@


1.126
log
@	* ChangeLog-9197: Fix typos.
	* NEWS: Likewise.
	* ld.texinfo: Likewise.
	* ldlang.c: Fix comment typos.
@
text
@d1323 6
a1328 1
      if (search->filename == NULL && name == NULL)
d1330 1
a1330 1
      if (search->filename != NULL
d1332 1
a1332 1
	  && strcmp (search->filename, name) == 0)
d1337 1
a1337 1
    search = new_afile (name, lang_input_file_is_file_enum, default_target,
@


1.125
log
@2003-10-24  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldlang.c (lang_vers_match): Fix a typo.
@
text
@d2926 2
a2927 2
			   excessivly large binary, or even seg faulting when
			   attmepting to perform a negative seek.  See
@


1.124
log
@2003-10-24  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldlang.c (lang_vers_match): Check demangled symbols.
@
text
@d4996 1
a4996 1
  else if (head->mask & BFD_ELF_VERSION_JAVA_TYPE)
@


1.123
log
@bfd/

2003-10-24  H.J. Lu  <hongjiu.lu@@intel.com>

	* elflink.h (NAME(bfd_elf,size_dynamic_sections)): Look up
	hash table for real symbols.

include/

2003-10-24  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfdlink.h (bfd_elf_version_expr): Add "symbol" and remove
	"wildcard".

ld/

2003-10-24  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldlang.c (lang_vers_match): Check "symbol" instead of
	"wildcard" and "pattern". Fix a typo.
	(lang_finalize_version_expr_head): Likewise.
	(lang_register_vers_node): Likewise.
	(realsymbol): New function.
	(lang_new_vers_pattern): Set "symbol" and remove "wildcard".

	* ldlex.l (V_IDENTIFIER): Allow '\\'.
@
text
@d4996 1
a4996 1
  if (head->mask & BFD_ELF_VERSION_JAVA_TYPE)
d5026 1
a5026 1
		while (expr && strcmp (expr->symbol, sym) == 0)
d5038 1
a5038 1
		while (expr && strcmp (expr->symbol, sym) == 0)
@


1.122
log
@bfd/
	* elflink.c (_bfd_elf_export_symbol): Adjust for globals and locals
	field changes.
	(_bfd_elf_link_assign_sym_version): Likewise.
	* elflink.h (size_dynamic_sections): Likewise.
include/
	* bfdlink.h (struct bfd_elf_version_expr): Remove match field.
	Add wildcard and mask fields.
	(BFD_ELF_VERSION_C_TYPE): Define.
	(BFD_ELF_VERSION_CXX_TYPE): Likewise.
	(BFD_ELF_VERSION_JAVA_TYPE): Likewise.
	(struct bfd_elf_version_expr_head): New.
	(struct bfd_elf_version_tree): Add match field.
	Change type of globals and locals fields
	to struct bfd_elf_version_expr_head.
ld/
	* ldlang.c: Include hashtab.h.
	(lang_vers_match_lang_c, lang_vers_match_lang_cplusplus,
	lang_vers_match_lang_java): Remove.
	(lang_vers_match): New function.
	(lang_new_vers_pattern): Initialize wildcard and mask
	fields, don't initialize match.
	(lang_new_vers_node): Use xcalloc.  Adjust for globals and
	locals field type changes.  Set match field.
	(version_expr_head_hash, version_expr_head_eq): New functions.
	(lang_finalize_version_expr_head): New function.
	(lang_register_vers_node): Call lang_finalize_version_expr_head.
	Search in hash table if not wildcard when looking for duplicates.
	* emultempl/ppc64elf.em (new_vers_pattern): Don't bother with
	duplicate checking.  Initialize all fields of dot_entry from entry
	with the exception of pattern and next.
@
text
@d5003 1
a5003 1
  if (head->htab && (prev == NULL || prev->wildcard == 0))
d5012 1
a5012 1
		e.pattern = sym;
d5014 1
a5014 1
		while (expr && strcmp (expr->pattern, sym) == 0)
d5024 1
a5024 1
		e.pattern = cxx_sym;
d5026 1
a5026 1
		while (expr && strcmp (expr->pattern, sym) == 0)
d5036 1
a5036 1
		e.pattern = java_sym;
d5038 1
a5038 1
		while (expr && strcmp (expr->pattern, sym) == 0)
d5051 1
a5051 1
  if (prev == NULL || prev->wildcard == 0)
d5068 1
a5068 1
      if (fnmatch (expr->pattern, sym, 0) == 0)
d5081 44
d5139 1
a5139 1
  ret->wildcard = wildcardp (new);
d5183 1
a5183 1
  return htab_hash_string (e->pattern);
d5192 1
a5192 1
  return strcmp (e1->pattern, e2->pattern) == 0;
d5204 1
a5204 1
      if (!e->wildcard)
d5218 1
a5218 1
	  if (e->wildcard)
d5243 1
a5243 1
		  while (e1 && strcmp (e1->pattern, e->pattern) == 0);
d5250 1
a5250 1
		      /* free (e->pattern); */
d5313 1
a5313 1
	  if (t->locals.htab && e1->wildcard == 0)
d5316 1
a5316 1
	      while (e2 && strcmp (e1->pattern, e2->pattern) == 0)
d5320 1
a5320 1
			   e1->pattern);
d5324 1
a5324 1
	  else if (e1->wildcard)
d5338 1
a5338 1
	  if (t->globals.htab && e1->wildcard == 0)
d5341 1
a5341 1
	      while (e2 && strcmp (e1->pattern, e2->pattern) == 0)
d5345 1
a5345 1
			   e1->pattern);
d5349 1
a5349 1
	  else if (e1->wildcard)
@


1.121
log
@Add warning messages for the use of an undeclared memory region and the
redefintion of an already declared region.
@
text
@d42 1
d4977 3
a4979 8
static int
lang_vers_match_lang_c (struct bfd_elf_version_expr *expr,
			const char *sym)
{
  if (expr->pattern[0] == '*' && expr->pattern[1] == '\0')
    return 1;
  return fnmatch (expr->pattern, sym, 0) == 0;
}
d4981 4
a4984 3
static int
lang_vers_match_lang_cplusplus (struct bfd_elf_version_expr *expr,
				const char *sym)
d4986 3
a4988 5
  char *alt_sym;
  int result;

  if (expr->pattern[0] == '*' && expr->pattern[1] == '\0')
    return 1;
d4990 1
a4990 2
  alt_sym = cplus_demangle (sym, /* DMGL_NO_TPARAMS */ 0);
  if (!alt_sym)
d4992 3
a4994 3
      /* cplus_demangle (also) returns NULL when it is not a C++ symbol.
	 Should we early out FALSE in this case?  */
      result = fnmatch (expr->pattern, sym, 0) == 0;
d4996 1
a4996 1
  else
d4998 3
a5000 2
      result = fnmatch (expr->pattern, alt_sym, 0) == 0;
      free (alt_sym);
d5003 3
a5005 2
  return result;
}
d5007 42
a5048 6
static int
lang_vers_match_lang_java (struct bfd_elf_version_expr *expr,
			   const char *sym)
{
  char *alt_sym;
  int result;
d5050 3
a5052 10
  if (expr->pattern[0] == '*' && expr->pattern[1] == '\0')
    return 1;

  alt_sym = cplus_demangle (sym, DMGL_JAVA);
  if (!alt_sym)
    {
      /* cplus_demangle (also) returns NULL when it is not a Java symbol.
	 Should we early out FALSE in this case?  */
      result = fnmatch (expr->pattern, sym, 0) == 0;
    }
d5054 2
d5057 14
a5070 2
      result = fnmatch (expr->pattern, alt_sym, 0) == 0;
      free (alt_sym);
d5073 6
a5078 1
  return result;
d5095 1
d5098 1
a5098 1
    ret->match = lang_vers_match_lang_c;
d5100 1
a5100 1
    ret->match = lang_vers_match_lang_cplusplus;
d5102 1
a5102 1
    ret->match = lang_vers_match_lang_java;
d5107 1
a5107 1
      ret->match = lang_vers_match_lang_c;
d5122 4
a5125 7
  ret = xmalloc (sizeof *ret);
  ret->next = NULL;
  ret->name = NULL;
  ret->vernum = 0;
  ret->globals = globals;
  ret->locals = locals;
  ret->deps = NULL;
a5126 1
  ret->used = 0;
d5134 96
d5257 3
d5263 1
a5263 1
  for (e1 = version->globals; e1 != NULL; e1 = e1->next)
d5269 16
a5284 4
	  for (e2 = t->locals; e2 != NULL; e2 = e2->next)
	    if (strcmp (e1->pattern, e2->pattern) == 0)
	      einfo (_("%X%P: duplicate expression `%s' in version information\n"),
		     e1->pattern);
d5288 1
a5288 1
  for (e1 = version->locals; e1 != NULL; e1 = e1->next)
d5294 16
a5309 4
	  for (e2 = t->globals; e2 != NULL; e2 = e2->next)
	    if (strcmp (e1->pattern, e2->pattern) == 0)
	      einfo (_("%X%P: duplicate expression `%s' in version information\n"),
		     e1->pattern);
@


1.120
log
@	* ldlang.c (lang_size_sections): Last, set _cooked_size for output
	sections.
@
text
@d507 7
a513 1
  which is created when looked up to be the entire data space.  */
d519 1
a519 1
lang_memory_region_lookup (const char *const name)
d529 4
a532 2
    {
      if (strcmp (p->name, name) == 0)
d534 1
a534 1
    }
d543 1
a543 1
  if (strcmp (name, "*default*") == 0)
d550 3
d589 1
a589 1
  return lang_memory_region_lookup ("*default*");
d2903 1
a2903 1
			    && strcmp (os->region->name, "*default*") == 0))
d2916 1
a2916 1
			&& strcmp (os->region->name, "*default*") == 0
d2919 1
a2919 1
				    "*default*") != 0
d3174 1
a3174 1
		    lang_memory_region_lookup ("*default*")->current = newdot;
d4478 5
a4482 4
   MEMSPEC is the name of the run-time region, or "*default*" if the
   statement didn't specify one.  LMA_MEMSPEC is the name of the
   load-time region, or null if the statement didn't specify one.
   HAVE_LMA_P is TRUE if the statement had an explicit load address.
d4493 1
a4493 1
  *lma_region = lang_memory_region_lookup (lma_memspec);
d4497 1
a4497 1
  if (lma_memspec != 0 && strcmp (memspec, "*default*") == 0)
d4500 1
a4500 1
    *region = lang_memory_region_lookup (memspec);
d4864 5
a4868 4
  /* For now, assume that "*default*" is the run-time memory region and
     that no load-time region has been specified.  It doesn't really
     matter what we say here, since lang_leave_overlay will override it.  */
  lang_leave_output_section_statement (fill, "*default*", phdrs, 0);
@


1.119
log
@	* ld.texinfo (Builtin Functions) <DEFINED>: Say that only symbols
	defined before the statement using DEFINED yield 1.
	* ldexp.c (fold_name) <case DEFINED>: In lang_first_phase_enum,
	call lang_track_definedness on symbol.  In subsequent phases, use
	lang_symbol_definition_iteration and lang_statement_iteration to
	check whether the symbol was defined before the current statement.
	(exp_fold_tree) <case etree_assign et al>: Call
	lang_update_definedness before updating symbol type when setting
	symbol.
	* ldlang.c (lang_definedness_table): New variable.
	(lang_definedness_newfunc, lang_track_definedness)
	(lang_symbol_definition_iteration, lang_update_definedness): New
	functions.
	(lang_init): Initialize lang_definedness_table and
	lang_statement_iteration.
	(lang_finish): Destroy bfd_hash_table_free.
	(lang_size_sections): Increment lang_statement_iteration.
	(lang_do_assignments_1): New function with former
	lang_do_assignments contents.  Change recursive calls to call this
	function.
	(lang_do_assignments): Evacuate contents.  Increment
	lang_statement_iteration, then just call lang_do_assignments_1.
	* ldlang.h (struct lang_definedness_hash_entry)
	(lang_statement_iteration, lang_track_definedness)
	(lang_symbol_definition_iteration, lang_update_definedness):
	Declare.
@
text
@d3230 1
d3256 8
@


1.118
log
@* ldlang.c (lang_size_sections_1): Use IGNORE_SECTION to tell
whether to skip test for no memory region.
@
text
@d63 1
d71 2
d101 1
d484 13
d1887 79
d3231 3
d3259 4
a3262 2
bfd_vma
lang_do_assignments
d3276 4
a3279 4
	  dot = lang_do_assignments (constructor_list.head,
				     output_section_statement,
				     fill,
				     dot);
d3290 2
a3291 2
		(void) lang_do_assignments (os->children.head, os,
					    os->fill, dot);
d3310 3
a3312 3
	  dot = lang_do_assignments (s->wild_statement.children.head,
				     output_section_statement,
				     fill, dot);
d3405 3
a3407 3
	  dot = lang_do_assignments (s->group_statement.children.head,
				     output_section_statement,
				     fill, dot);
d3422 12
d3561 2
@


1.117
log
@	* ld.texinfo: Typo fixes.  Document SUBALIGN.
	* ldgram.y (opt_subalign): Add.
	* ldlex.l (SUBALIGN): Recognize.
	* ldlang.c (overlay_subalign): New var.
	(lang_enter_overlay): Add subalign param.
	(lang_enter_overlay_section): Pass overlay_subalign to
	lang_enter_output_section_statement.
	* ldlang.h (lang_enter_overlay): Update.
@
text
@d2804 1
a2804 2
		    if ((bfd_get_section_flags (output_bfd, os->bfd_section)
			 & (SEC_ALLOC | SEC_LOAD)) != 0
@


1.116
log
@Convert to C90
@
text
@d4652 2
d4670 1
a4670 1
lang_enter_overlay (etree_type *vma_expr)
d4673 3
a4675 1
  ASSERT (overlay_vma == NULL && overlay_max == NULL);
d4678 1
d4692 1
a4692 1
				       0, 0, 0, 0);
@


1.115
log
@Correct spelling of "relocatable".
@
text
@d65 17
a81 163
static lang_statement_union_type *new_statement
  PARAMS ((enum statement_enum, size_t, lang_statement_list_type *));
static void lang_for_each_statement_worker
  PARAMS ((void (*) (lang_statement_union_type *),
	   lang_statement_union_type *));
static lang_input_statement_type *new_afile
  PARAMS ((const char *, lang_input_file_enum_type, const char *,
	   bfd_boolean));
static lang_memory_region_type *lang_memory_default
  PARAMS ((asection *));
static void lang_map_flags
  PARAMS ((flagword));
static void init_os
  PARAMS ((lang_output_section_statement_type *));
static void exp_init_os
  PARAMS ((etree_type *));
static void section_already_linked
  PARAMS ((bfd *, asection *, PTR));
static struct bfd_hash_entry *already_linked_newfunc
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
static void already_linked_table_init
  PARAMS ((void));
static void already_linked_table_free
  PARAMS ((void));
static bfd_boolean wildcardp
  PARAMS ((const char *));
static lang_statement_union_type *wild_sort
  PARAMS ((lang_wild_statement_type *, struct wildcard_list *,
	   lang_input_statement_type *, asection *));
static void output_section_callback
  PARAMS ((lang_wild_statement_type *, struct wildcard_list *, asection *,
	   lang_input_statement_type *, PTR));
static lang_input_statement_type *lookup_name
  PARAMS ((const char *));
static bfd_boolean load_symbols
  PARAMS ((lang_input_statement_type *, lang_statement_list_type *));
static void wild
  PARAMS ((lang_wild_statement_type *,
	   const char *, lang_output_section_statement_type *));
static bfd *open_output
  PARAMS ((const char *));
static void ldlang_open_output
  PARAMS ((lang_statement_union_type *));
static void open_input_bfds
  PARAMS ((lang_statement_union_type *, bfd_boolean));
static void lang_reasonable_defaults
  PARAMS ((void));
static void insert_undefined
  PARAMS ((const char *));
static void lang_place_undefineds
  PARAMS ((void));
static void map_input_to_output_sections
  PARAMS ((lang_statement_union_type *, const char *,
	   lang_output_section_statement_type *));
static void strip_excluded_output_sections
  PARAMS ((void));
static void print_output_section_statement
  PARAMS ((lang_output_section_statement_type *));
static void print_assignment
  PARAMS ((lang_assignment_statement_type *,
	   lang_output_section_statement_type *));
static void print_input_statement
  PARAMS ((lang_input_statement_type *));
static bfd_boolean print_one_symbol
  PARAMS ((struct bfd_link_hash_entry *, PTR));
static void print_input_section
  PARAMS ((lang_input_section_type *));
static void print_fill_statement
  PARAMS ((lang_fill_statement_type *));
static void print_data_statement
  PARAMS ((lang_data_statement_type *));
static void print_address_statement
  PARAMS ((lang_address_statement_type *));
static void print_reloc_statement
  PARAMS ((lang_reloc_statement_type *));
static void print_padding_statement
  PARAMS ((lang_padding_statement_type *));
static void print_wild_statement
  PARAMS ((lang_wild_statement_type *, lang_output_section_statement_type *));
static void print_group
  PARAMS ((lang_group_statement_type *, lang_output_section_statement_type *));
static void print_statement
  PARAMS ((lang_statement_union_type *, lang_output_section_statement_type *));
static void print_statement_list
  PARAMS ((lang_statement_union_type *, lang_output_section_statement_type *));
static void print_statements
  PARAMS ((void));
static void insert_pad
  PARAMS ((lang_statement_union_type **, fill_type *,
	   unsigned int, asection *, bfd_vma));
static bfd_vma size_input_section
  PARAMS ((lang_statement_union_type **, lang_output_section_statement_type *,
	   fill_type *, bfd_vma));
static void lang_finish
  PARAMS ((void));
static void ignore_bfd_errors
  PARAMS ((const char *, ...));
static void lang_check
  PARAMS ((void));
static void lang_common
  PARAMS ((void));
static bfd_boolean lang_one_common
  PARAMS ((struct bfd_link_hash_entry *, PTR));
static void lang_place_orphans
  PARAMS ((void));
static int topower
  PARAMS ((int));
static void lang_set_startof
  PARAMS ((void));
static void gc_section_callback
  PARAMS ((lang_wild_statement_type *, struct wildcard_list *, asection *,
	   lang_input_statement_type *, PTR));
static void lang_get_regions
  PARAMS ((struct memory_region_struct **, struct memory_region_struct **,
	   const char *, const char *, int));
static void lang_record_phdrs
  PARAMS ((void));
static void lang_gc_wild
  PARAMS ((lang_wild_statement_type *));
static void lang_gc_sections_1
  PARAMS ((lang_statement_union_type *));
static void lang_gc_sections
  PARAMS ((void));
static int lang_vers_match_lang_c
  PARAMS ((struct bfd_elf_version_expr *, const char *));
static int lang_vers_match_lang_cplusplus
  PARAMS ((struct bfd_elf_version_expr *, const char *));
static int lang_vers_match_lang_java
  PARAMS ((struct bfd_elf_version_expr *, const char *));
static void lang_do_version_exports_section
  PARAMS ((void));
static void lang_check_section_addresses
  PARAMS ((void));
static void os_region_check
  PARAMS ((lang_output_section_statement_type *,
	   struct memory_region_struct *, etree_type *, bfd_vma));
static bfd_vma lang_size_sections_1
  PARAMS ((lang_statement_union_type *, lang_output_section_statement_type *,
	   lang_statement_union_type **, fill_type *, bfd_vma, bfd_boolean *,
	   bfd_boolean));
typedef void (*callback_t)
  PARAMS ((lang_wild_statement_type *, struct wildcard_list *, asection *,
	   lang_input_statement_type *, PTR));
static void walk_wild
  PARAMS ((lang_wild_statement_type *, callback_t, PTR));
static void walk_wild_section
  PARAMS ((lang_wild_statement_type *, lang_input_statement_type *,
	   callback_t, PTR));
static void walk_wild_file
  PARAMS ((lang_wild_statement_type *, lang_input_statement_type *,
	   callback_t, PTR));
static int get_target
  PARAMS ((const bfd_target *, PTR));
static void stricpy
  PARAMS ((char *, char *));
static void strcut
  PARAMS ((char *, char *));
static int name_compare
  PARAMS ((char *, char *));
static int closest_target_match
  PARAMS ((const bfd_target *, PTR));
static char * get_first_input_target
  PARAMS ((void));
a100 8
#if defined (__STDC__) || defined (ALMOST_STDC)
#define cat(a,b) a##b
#else
#define cat(a,b) a/**/b
#endif

/* Don't beautify the line below with "innocent" whitespace, it breaks
   the K&R C preprocessor!  */
d102 1
a102 1
  (cat (x,_type)*) new_statement (cat (x,_enum), sizeof (cat (x,_type)), y)
d112 2
a113 3
PTR
stat_alloc (size)
     size_t size;
d119 1
a119 2
unique_section_p (secnam)
     const char *secnam;
d137 4
a140 5
walk_wild_section (ptr, file, callback, data)
     lang_wild_statement_type *ptr;
     lang_input_statement_type *file;
     callback_t callback;
     PTR data;
d211 4
a214 5
walk_wild_file (s, f, callback, data)
     lang_wild_statement_type *s;
     lang_input_statement_type *f;
     callback_t callback;
     PTR data;
d225 1
a225 1
      member = bfd_openr_next_archived_file (f->the_bfd, (bfd *) NULL);
d235 1
a235 3
	      walk_wild_section (s,
				 (lang_input_statement_type *) member->usrdata,
				 callback, data);
d244 1
a244 4
walk_wild (s, callback, data)
     lang_wild_statement_type *s;
     callback_t callback;
     PTR data;
d279 2
a280 3
lang_for_each_statement_worker (func, s)
     void (*func) PARAMS ((lang_statement_union_type *));
     lang_statement_union_type *s;
d282 1
a282 1
  for (; s != (lang_statement_union_type *) NULL; s = s->header.next)
d325 1
a325 2
lang_for_each_statement (func)
     void (*func) PARAMS ((lang_statement_union_type *));
d333 1
a333 2
lang_list_init (list)
     lang_statement_list_type *list;
d335 1
a335 1
  list->head = (lang_statement_union_type *) NULL;
d342 3
a344 4
new_statement (type, size, list)
     enum statement_enum type;
     size_t size;
     lang_statement_list_type *list;
d346 1
a346 2
  lang_statement_union_type *new = (lang_statement_union_type *)
  stat_alloc (size);
d348 1
d350 1
a350 1
  new->header.next = (lang_statement_union_type *) NULL;
d365 4
a368 5
new_afile (name, file_type, target, add_to_list)
     const char *name;
     lang_input_file_enum_type file_type;
     const char *target;
     bfd_boolean add_to_list;
d376 1
a376 2
      p = ((lang_input_statement_type *)
	   stat_alloc (sizeof (lang_input_statement_type)));
d405 1
a405 1
      p->local_sym_name = concat ("-l", name, (const char *) NULL);
d437 4
a440 4
  p->the_bfd = (bfd *) NULL;
  p->asymbols = (asymbol **) NULL;
  p->next_real_file = (lang_statement_union_type *) NULL;
  p->next = (lang_statement_union_type *) NULL;
d452 3
a454 4
lang_add_input_file (name, file_type, target)
     const char *name;
     lang_input_file_enum_type file_type;
     const char *target;
d463 1
a463 1
lang_init ()
d474 2
a475 3
  first_file = lang_add_input_file ((char *) NULL,
				    lang_input_file_is_marker_enum,
				    (char *) NULL);
a479 1

d496 1
a496 2
lang_memory_region_lookup (name)
     const char *const name;
d499 1
d505 1
a505 3
  for (p = lang_memory_region_list;
       p != (lang_memory_region_type *) NULL;
       p = p->next)
d508 1
a508 3
	{
	  return p;
	}
d520 2
a521 4
      if (lang_memory_region_list != (lang_memory_region_type *) NULL)
	{
	  return lang_memory_region_list;
	}
d525 1
a525 15
  {
    lang_memory_region_type *new =
    (lang_memory_region_type *) stat_alloc (sizeof (lang_memory_region_type));

    new->name = xstrdup (name);
    new->next = (lang_memory_region_type *) NULL;

    *lang_memory_region_list_tail = new;
    lang_memory_region_list_tail = &new->next;
    new->origin = 0;
    new->flags = 0;
    new->not_flags = 0;
    new->length = ~(bfd_size_type) 0;
    new->current = 0;
    new->had_full_message = FALSE;
d527 13
a539 2
    return new;
  }
d543 1
a543 2
lang_memory_default (section)
     asection *section;
d553 1
a553 3
  for (p = lang_memory_region_list;
       p != (lang_memory_region_type *) NULL;
       p = p->next)
d565 1
a565 2
lang_output_section_find (name)
     const char *const name;
d570 1
a570 3
  for (u = lang_output_section_statement.head;
       u != (lang_statement_union_type *) NULL;
       u = lookup->next)
d574 1
a574 3
	{
	  return lookup;
	}
d576 1
a576 1
  return (lang_output_section_statement_type *) NULL;
d580 1
a580 2
lang_output_section_statement_lookup (name)
     const char *const name;
d585 1
a585 1
  if (lookup == (lang_output_section_statement_type *) NULL)
d587 4
a590 6

      lookup = (lang_output_section_statement_type *)
	new_stat (lang_output_section_statement, stat_ptr);
      lookup->region = (lang_memory_region_type *) NULL;
      lookup->lma_region = (lang_memory_region_type *) NULL;
      lookup->fill = (fill_type *) 0;
d594 2
a595 2
      lookup->next = (lang_statement_union_type *) NULL;
      lookup->bfd_section = (asection *) NULL;
d598 1
a598 1
      lookup->addr_tree = (etree_type *) NULL;
d601 1
a601 1
      lookup->memspec = (const char *) NULL;
d605 1
a605 1
      lookup->load_base = (union etree_union *) NULL;
d617 1
a617 2
lang_map_flags (flag)
     flagword flag;
d636 1
a636 1
lang_map ()
d644 1
a644 3
  for (m = lang_memory_region_list;
       m != (lang_memory_region_type *) NULL;
       m = m->next)
d690 1
a690 2
init_os (s)
     lang_output_section_statement_type *s;
d700 1
a700 2
  new = ((section_userdata_type *)
	 stat_alloc (sizeof (section_userdata_type)));
d703 1
a703 1
  if (s->bfd_section == (asection *) NULL)
d705 1
a705 1
  if (s->bfd_section == (asection *) NULL)
d715 1
a715 1
  get_userdata (s->bfd_section) = (PTR) new;
d730 1
a730 2
exp_init_os (exp)
     etree_type *exp;
d805 1
a805 4
section_already_linked (abfd, sec, data)
     bfd *abfd;
     asection *sec;
     PTR data;
d807 1
a807 1
  lang_input_statement_type *entry = (lang_input_statement_type *) data;
d907 1
a907 2
  l = ((struct already_linked *)
       bfd_hash_allocate (&already_linked_table, sizeof *l));
d918 3
a920 4
already_linked_newfunc (entry, table, string)
     struct bfd_hash_entry *entry ATTRIBUTE_UNUSED;
     struct bfd_hash_table *table;
     const char *string ATTRIBUTE_UNUSED;
d927 1
a927 1
  return (struct bfd_hash_entry *) ret;
d931 1
a931 1
already_linked_table_init ()
d940 1
a940 1
already_linked_table_free ()
d958 1
a958 2
wildcardp (pattern)
     const char *pattern;
d975 4
a978 5
lang_add_section (ptr, section, output, file)
     lang_statement_list_type *ptr;
     asection *section;
     lang_output_section_statement_type *output;
     lang_input_statement_type *file;
d1127 4
a1130 5
wild_sort (wild, sec, file, section)
     lang_wild_statement_type *wild;
     struct wildcard_list *sec;
     lang_input_statement_type *file;
     asection *section;
d1226 5
a1230 6
output_section_callback (ptr, sec, section, file, output)
     lang_wild_statement_type *ptr;
     struct wildcard_list *sec;
     asection *section;
     lang_input_statement_type *file;
     PTR output;
d1286 1
a1286 2
lookup_name (name)
     const char *name;
d1291 1
a1291 1
       search != (lang_input_statement_type *) NULL;
d1294 1
a1294 1
      if (search->filename == (char *) NULL && name == (char *) NULL)
d1296 2
a1297 2
      if (search->filename != (char *) NULL
	  && name != (char *) NULL
d1302 1
a1302 1
  if (search == (lang_input_statement_type *) NULL)
d1311 1
a1311 1
      || search->filename == (const char *) NULL)
d1314 1
a1314 1
  if (! load_symbols (search, (lang_statement_list_type *) NULL))
d1323 2
a1324 3
load_symbols (entry, place)
     lang_input_statement_type *entry;
     lang_statement_list_type *place;
d1455 3
a1457 4
wild (s, target, output)
     lang_wild_statement_type *s;
     const char *target ATTRIBUTE_UNUSED;
     lang_output_section_statement_type *output;
d1461 1
a1461 1
  walk_wild (s, output_section_callback, (PTR) output);
d1479 1
a1479 3
get_target (target, data)
     const bfd_target *target;
     PTR data;
d1481 1
a1481 1
  const char *sought = (const char *) data;
d1489 1
a1489 3
stricpy (dest, src)
     char *dest;
     char *src;
d1503 1
a1503 3
strcut (haystack, needle)
     char *haystack;
     char *needle;
d1522 1
a1522 3
name_compare (first, second)
     char *first;
     char *second;
d1535 1
a1535 1
  /* Remove and endian strings from the name.  */
d1565 1
a1565 3
closest_target_match (target, data)
     const bfd_target *target;
     PTR data;
d1567 1
a1567 1
  const bfd_target *original = (const bfd_target *) data;
d1601 1
a1601 1
get_first_input_target ()
d1627 1
a1627 1
lang_get_output_target ()
d1632 1
a1632 1
  if (output_target != (char *) NULL)
d1652 1
a1652 2
open_output (name)
     const char *name;
d1666 1
a1666 1
      target = bfd_search_for_target (get_target, (PTR) output_target);
d1692 2
a1693 2
		  (void) bfd_search_for_target (closest_target_match,
						(PTR) target);
d1708 1
a1708 1
  if (output == (bfd *) NULL)
d1730 1
a1730 1
  if (link_info.hash == (struct bfd_link_hash_table *) NULL)
d1738 1
a1738 2
ldlang_open_output (statement)
     lang_statement_union_type *statement;
d1743 1
a1743 1
      ASSERT (output_bfd == (bfd *) NULL);
d1771 1
a1771 3
open_input_bfds (s, force)
     lang_statement_union_type *s;
     bfd_boolean force;
d1773 1
a1773 1
  for (; s != (lang_statement_union_type *) NULL; s = s->header.next)
d1849 1
a1849 1
lang_reasonable_defaults ()
d1864 1
a1864 1
      new->filename = (char *) NULL;
d1881 1
a1881 2
ldlang_add_undef (name)
     const char *const name;
d1884 1
a1884 2
    ((ldlang_undef_chain_list_type *)
     stat_alloc (sizeof (ldlang_undef_chain_list_type)));
d1898 1
a1898 2
insert_undefined (name)
     const char *name;
d1903 1
a1903 1
  if (h == (struct bfd_link_hash_entry *) NULL)
d1918 1
a1918 1
lang_place_undefineds ()
d1922 2
a1923 6
  for (ptr = ldlang_undef_chain_list_head;
       ptr != (ldlang_undef_chain_list_type *) NULL;
       ptr = ptr->next)
    {
      insert_undefined (ptr->name);
    }
d1929 3
a1931 4
map_input_to_output_sections (s, target, output_section_statement)
     lang_statement_union_type *s;
     const char *target;
     lang_output_section_statement_type *output_section_statement;
d1933 1
a1933 1
  for (; s != (lang_statement_union_type *) NULL; s = s->header.next)
d2004 1
a2004 1
strip_excluded_output_sections ()
d2035 2
a2036 2
print_output_section_statement (output_section_statement)
     lang_output_section_statement_type *output_section_statement;
d2081 2
a2082 3
print_assignment (assignment, output_section)
     lang_assignment_statement_type *assignment;
     lang_output_section_statement_type *output_section;
d2120 1
a2120 2
print_input_statement (statm)
     lang_input_statement_type *statm;
d2122 1
a2122 1
  if (statm->filename != (char *) NULL)
d2132 1
a2132 3
print_one_symbol (hash_entry, ptr)
     struct bfd_link_hash_entry *hash_entry;
     PTR ptr;
d2134 1
a2134 1
  asection *sec = (asection *) ptr;
d2158 1
a2158 2
print_input_section (in)
     lang_input_section_type *in;
d2207 1
a2207 1
	  bfd_link_hash_traverse (link_info.hash, print_one_symbol, (PTR) i);
d2215 1
a2215 2
print_fill_statement (fill)
     lang_fill_statement_type *fill;
d2226 1
a2226 2
print_data_statement (data)
     lang_data_statement_type *data;
d2286 1
a2286 2
print_address_statement (address)
     lang_address_statement_type *address;
d2296 1
a2296 2
print_reloc_statement (reloc)
     lang_reloc_statement_type *reloc;
d2328 1
a2328 2
print_padding_statement (s)
     lang_padding_statement_type *s;
d2363 2
a2364 3
print_wild_statement (w, os)
     lang_wild_statement_type *w;
     lang_output_section_statement_type *os;
d2411 2
a2412 3
print_group (s, os)
     lang_group_statement_type *s;
     lang_output_section_statement_type *os;
d2423 2
a2424 3
print_statement_list (s, os)
     lang_statement_union_type *s;
     lang_output_section_statement_type *os;
d2437 2
a2438 3
print_statement (s, os)
     lang_statement_union_type *s;
     lang_output_section_statement_type *os;
d2508 1
a2508 1
print_statements ()
d2519 1
a2519 3
dprint_statement (s, n)
     lang_statement_union_type *s;
     int n;
d2540 5
a2544 6
insert_pad (ptr, fill, alignment_needed, output_section, dot)
     lang_statement_union_type **ptr;
     fill_type *fill;
     unsigned int alignment_needed;
     asection *output_section;
     bfd_vma dot;
d2561 1
a2561 2
      pad = ((lang_statement_union_type *)
	     stat_alloc (sizeof (lang_padding_statement_type)));
d2566 1
a2566 1
      if (fill == (fill_type *) 0)
d2578 4
a2581 5
size_input_section (this_ptr, output_section_statement, fill, dot)
     lang_statement_union_type **this_ptr;
     lang_output_section_statement_type *output_section_statement;
     fill_type *fill;
     bfd_vma dot;
d2642 1
a2642 1
lang_check_section_addresses ()
d2699 4
a2702 5
os_region_check (os, region, tree, base)
     lang_output_section_statement_type *os;
     struct memory_region_struct *region;
     etree_type *tree;
     bfd_vma base;
d2709 1
a2709 1
      if (tree != (etree_type *) NULL)
d2732 8
a2739 9
lang_size_sections_1 (s, output_section_statement, prev, fill, dot, relax,
		      check_regions)
     lang_statement_union_type *s;
     lang_output_section_statement_type *output_section_statement;
     lang_statement_union_type **prev;
     fill_type *fill;
     bfd_vma dot;
     bfd_boolean *relax;
     bfd_boolean check_regions;
d2745 1
a2745 1
  for (; s != (lang_statement_union_type *) NULL; s = s->header.next)
d2788 1
a2788 1
		if (os->addr_tree == (etree_type *) NULL)
d2792 1
a2792 1
		    if (os->region == (lang_memory_region_type *) NULL
d2821 1
a2821 1
			     http://sources.redhat.com/ml/binutils/2003-04/msg00423.html			 
d2910 1
a2910 1
	    if (os->region != (lang_memory_region_type *) NULL
d3125 8
a3132 9
lang_size_sections (s, output_section_statement, prev, fill, dot, relax,
		    check_regions)
     lang_statement_union_type *s;
     lang_output_section_statement_type *output_section_statement;
     lang_statement_union_type **prev;
     fill_type *fill;
     bfd_vma dot;
     bfd_boolean *relax;
     bfd_boolean check_regions;
d3162 5
a3166 5
lang_do_assignments (s, output_section_statement, fill, dot)
     lang_statement_union_type *s;
     lang_output_section_statement_type *output_section_statement;
     fill_type *fill;
     bfd_vma dot;
d3171 1
a3171 1
  for (; s != (lang_statement_union_type *) NULL; s = s->header.next)
d3330 1
a3330 1
lang_set_startof ()
d3376 1
a3376 1
lang_finish ()
d3386 1
a3386 1
  if (entry_symbol.name == (const char *) NULL)
d3396 1
a3396 1
  if (h != (struct bfd_link_hash_entry *) NULL
d3430 1
a3430 1
	  if (ts != (asection *) NULL)
a3454 1
#ifdef ANSI_PROTOTYPES
a3455 4
#else
ignore_bfd_errors (s)
     const char *s ATTRIBUTE_UNUSED;
#endif
d3465 1
a3465 1
lang_check ()
d3471 1
a3471 3
  for (file = file_chain.head;
       file != (lang_statement_union_type *) NULL;
       file = file->input_statement.next)
d3532 1
a3532 1
lang_common ()
d3541 1
a3541 1
    bfd_link_hash_traverse (link_info.hash, lang_one_common, (PTR) NULL);
d3547 1
a3547 2
	bfd_link_hash_traverse (link_info.hash, lang_one_common,
				(PTR) &power);
d3554 1
a3554 3
lang_one_common (h, info)
     struct bfd_link_hash_entry *h;
     PTR info;
d3650 1
a3650 1
lang_place_orphans ()
d3656 1
a3656 3
      for (s = file->the_bfd->sections;
	   s != (asection *) NULL;
	   s = s->next)
d3658 1
a3658 1
	  if (s->output_section == (asection *) NULL)
d3706 1
a3706 4
lang_set_flags (ptr, flags, invert)
     lang_memory_region_type *ptr;
     const char *flags;
     int invert;
d3748 1
a3748 2
lang_for_each_input_file (func)
     void (*func) PARAMS ((lang_input_statement_type *));
d3763 1
a3763 2
lang_for_each_file (func)
     void (*func) PARAMS ((lang_input_statement_type *));
d3776 1
a3776 2
lang_for_each_input_section (func)
     void (*func) PARAMS ((bfd *ab, asection *as));
d3782 2
a3783 6
      for (s = f->the_bfd->sections;
	   s != (asection *) NULL;
	   s = s->next)
	{
	  func (f->the_bfd, s);
	}
d3790 1
a3790 2
ldlang_add_file (entry)
     lang_input_statement_type *entry;
d3800 1
a3800 1
  ASSERT (entry->the_bfd->link_next == (bfd *) NULL);
d3802 1
a3802 3
  for (pp = &link_info.input_bfds;
       *pp != (bfd *) NULL;
       pp = &(*pp)->link_next)
d3805 1
a3805 1
  entry->the_bfd->usrdata = (PTR) entry;
d3818 1
a3818 1
  bfd_map_over_sections (entry->the_bfd, section_already_linked, (PTR) entry);
d3822 1
a3822 3
lang_add_output (name, from_script)
     const char *name;
     int from_script;
d3835 1
a3835 2
topower (x)
     int x;
d3854 7
a3860 10
lang_enter_output_section_statement (output_section_statement_name,
				     address_exp, sectype, block_value,
				     align, subalign, ebase)
     const char *output_section_statement_name;
     etree_type *address_exp;
     enum section_type sectype;
     bfd_vma block_value;
     etree_type *align;
     etree_type *subalign;
     etree_type *ebase;
d3875 1
a3875 1
  if (os->addr_tree == (etree_type *) NULL)
d3897 1
a3897 1
lang_final ()
d3908 1
a3908 1
lang_reset_memory_regions ()
d3913 1
a3913 3
  for (p = lang_memory_region_list;
       p != (lang_memory_region_type *) NULL;
       p = p->next)
d3927 5
a3931 6
gc_section_callback (ptr, sec, section, file, data)
     lang_wild_statement_type *ptr;
     struct wildcard_list *sec ATTRIBUTE_UNUSED;
     asection *section;
     lang_input_statement_type *file ATTRIBUTE_UNUSED;
     PTR data ATTRIBUTE_UNUSED;
d3940 1
a3940 2
lang_gc_wild (s)
     lang_wild_statement_type *s;
d3948 1
a3948 2
lang_gc_sections_1 (s)
     lang_statement_union_type *s;
d3950 1
a3950 1
  for (; s != (lang_statement_union_type *) NULL; s = s->header.next)
d3973 1
a3973 1
lang_gc_sections ()
d3990 1
a3990 1
      if (h != (struct bfd_link_hash_entry *) NULL
d4003 1
a4003 1
lang_process ()
d4060 1
a4060 2
  map_input_to_output_sections (statement_list.head, (char *) NULL,
				(lang_output_section_statement_type *) NULL);
d4070 1
a4070 1
      if (found != (asection *) NULL)
d4091 2
a4092 3
  lang_size_sections (statement_list.head,
		      abs_output_section,
		      &statement_list.head, 0, (bfd_vma) 0, NULL,
d4113 2
a4114 3
	  lang_do_assignments (statement_list.head,
			       abs_output_section,
			       (fill_type *) 0, (bfd_vma) 0);
d4118 2
a4119 4
	  lang_size_sections (statement_list.head,
			      abs_output_section,
			      &statement_list.head, 0, (bfd_vma) 0,
			      &relax_again, FALSE);
d4133 3
a4135 7
      lang_do_assignments (statement_list.head,
			   abs_output_section,
			   (fill_type *) 0, (bfd_vma) 0);
      lang_size_sections (statement_list.head,
			  abs_output_section,
			  & statement_list.head, 0, (bfd_vma) 0, 
			  NULL, TRUE);
d4148 1
a4148 3
  lang_do_assignments (statement_list.head,
		       abs_output_section,
		       (fill_type *) 0, (bfd_vma) 0);
d4164 3
a4166 4
lang_add_wild (filespec, section_list, keep_sections)
     struct wildcard_spec *filespec;
     struct wildcard_list *section_list;
     bfd_boolean keep_sections;
d4205 1
a4205 3
lang_section_start (name, address)
     const char *name;
     etree_type *address;
d4220 1
a4220 3
lang_add_entry (name, cmdline)
     const char *name;
     bfd_boolean cmdline;
d4232 1
a4232 2
lang_add_target (name)
     const char *name;
d4242 1
a4242 2
lang_add_map (name)
     const char *name;
d4257 1
a4257 2
lang_add_fill (fill)
     fill_type *fill;
d4266 1
a4266 3
lang_add_data (type, exp)
     int type;
     union etree_union *exp;
d4285 5
a4289 6
lang_add_reloc (reloc, howto, section, name, addend)
     bfd_reloc_code_real_type reloc;
     reloc_howto_type *howto;
     asection *section;
     const char *name;
     union etree_union *addend;
d4305 1
a4305 2
lang_add_assignment (exp)
     etree_type *exp;
d4315 1
a4315 2
lang_add_attribute (attribute)
     enum statement_enum attribute;
d4321 1
a4321 2
lang_startup (name)
     const char *name;
d4323 1
a4323 1
  if (startup_file != (char *) NULL)
d4335 1
a4335 2
lang_float (maybe)
     bfd_boolean maybe;
d4352 5
a4356 4
lang_get_regions (region, lma_region, memspec, lma_memspec, have_lma_p)
     struct memory_region_struct **region, **lma_region;
     const char *memspec, *lma_memspec;
     int have_lma_p;
d4372 3
a4374 5
lang_leave_output_section_statement (fill, memspec, phdrs, lma_memspec)
     fill_type *fill;
     const char *memspec;
     struct lang_output_section_phdr_list *phdrs;
     const char *lma_memspec;
d4391 1
a4391 3
lang_abs_symbol_at_beginning_of (secname, name)
     const char *secname;
     const char *name;
d4396 1
a4396 1
  if (h == (struct bfd_link_hash_entry *) NULL)
d4407 1
a4407 1
      if (sec == (asection *) NULL)
d4422 1
a4422 3
lang_abs_symbol_at_end_of (secname, name)
     const char *secname;
     const char *name;
d4427 1
a4427 1
  if (h == (struct bfd_link_hash_entry *) NULL)
d4438 1
a4438 1
      if (sec == (asection *) NULL)
d4450 3
a4452 4
lang_statement_append (list, element, field)
     lang_statement_list_type *list;
     lang_statement_union_type *element;
     lang_statement_union_type **field;
d4461 4
a4464 5
lang_add_output_format (format, big, little, from_script)
     const char *format;
     const char *big;
     const char *little;
     int from_script;
d4483 1
a4483 1
lang_enter_group ()
d4498 1
a4498 1
lang_leave_group ()
d4507 6
a4512 7
lang_new_phdr (name, type, filehdr, phdrs, at, flags)
     const char *name;
     etree_type *type;
     bfd_boolean filehdr;
     bfd_boolean phdrs;
     etree_type *at;
     etree_type *flags;
d4516 1
a4516 1
  n = (struct lang_phdr *) stat_alloc (sizeof (struct lang_phdr));
d4535 1
a4535 1
lang_record_phdrs ()
d4544 1
a4544 1
  secs = (asection **) xmalloc (alc * sizeof (asection *));
d4584 1
a4584 2
		      secs = ((asection **)
			      xrealloc (secs, alc * sizeof (asection *)));
d4635 1
a4635 2
lang_add_nocrossref (l)
     struct lang_nocrossref *l;
d4639 1
a4639 1
  n = (struct lang_nocrossrefs *) xmalloc (sizeof *n);
d4668 1
a4668 2
lang_enter_overlay (vma_expr)
     etree_type *vma_expr;
d4681 1
a4681 2
lang_enter_overlay_section (name)
     const char *name;
d4696 1
a4696 1
  n = (struct overlay_list *) xmalloc (sizeof *n);
d4714 2
a4715 3
lang_leave_overlay_section (fill, phdrs)
     fill_type *fill;
     struct lang_output_section_phdr_list *phdrs;
d4757 6
a4762 7
lang_leave_overlay (lma_expr, nocrossrefs, fill, memspec, phdrs, lma_memspec)
     etree_type *lma_expr;
     int nocrossrefs;
     fill_type *fill;
     const char *memspec;
     struct lang_output_section_phdr_list *phdrs;
     const char *lma_memspec;
d4786 1
a4786 1
      if (fill != (fill_type *) 0 && l->os->fill == (fill_type *) 0)
d4810 1
a4810 1
	  nc = (struct lang_nocrossref *) xmalloc (sizeof *nc);
d4836 2
a4837 3
lang_vers_match_lang_c (expr, sym)
     struct bfd_elf_version_expr *expr;
     const char *sym;
d4845 2
a4846 3
lang_vers_match_lang_cplusplus (expr, sym)
     struct bfd_elf_version_expr *expr;
     const char *sym;
d4871 2
a4872 3
lang_vers_match_lang_java (expr, sym)
     struct bfd_elf_version_expr *expr;
     const char *sym;
d4899 3
a4901 4
lang_new_vers_pattern (orig, new, lang)
     struct bfd_elf_version_expr *orig;
     const char *new;
     const char *lang;
d4905 1
a4905 1
  ret = (struct bfd_elf_version_expr *) xmalloc (sizeof *ret);
d4931 2
a4932 3
lang_new_vers_node (globals, locals)
     struct bfd_elf_version_expr *globals;
     struct bfd_elf_version_expr *locals;
d4936 1
a4936 1
  ret = (struct bfd_elf_version_tree *) xmalloc (sizeof *ret);
d4956 3
a4958 4
lang_register_vers_node (name, version, deps)
     const char *name;
     struct bfd_elf_version_tree *version;
     struct bfd_elf_version_deps *deps;
d5026 1
a5026 3
lang_add_vers_depend (list, name)
     struct bfd_elf_version_deps *list;
     const char *name;
d5031 1
a5031 1
  ret = (struct bfd_elf_version_deps *) xmalloc (sizeof *ret);
d5049 1
a5049 1
lang_do_version_exports_section ()
d5087 1
a5087 2
lang_add_unique (name)
     const char *name;
d5095 1
a5095 1
  ent = (struct unique_sections *) xmalloc (sizeof *ent);
@


1.114
log
@bfd/

2003-06-17  H.J. Lu <hongjiu.lu@@intel.com>

	* section.c (struct sec): Put back kept_section.
	(STD_SECTION): Put back kept_section initialization.
	* bfd-in2.h: Regenerate.

	* elflink.h (elf_link_input_bfd): Also check discarded linkonce
	sections for relocateable output. Use kept_section to preserve
	debug information discarded by linkonce.

ld/

2003-06-17  H.J. Lu <hongjiu.lu@@intel.com>

	* ldlang.c (section_already_linked): Put back assignment of
	kept_section.
@
text
@d1196 1
a1196 1
      && ((flags & SEC_DEBUGGING) != 0 || !link_info.relocateable))
d1255 1
a1255 1
      if (! link_info.relocateable)
d1277 1
a1277 1
      if ((flags & SEC_THREAD_LOCAL) && ! link_info.relocateable)
d1968 1
a1968 1
      if (config.magic_demand_paged && !link_info.relocateable)
d3061 1
a3061 1
			&& ! link_info.relocateable
d3142 1
a3142 1
		     && ! link_info.relocateable)
d3588 1
a3588 1
  if (link_info.relocateable)
d3635 1
a3635 1
  if (link_info.relocateable || link_info.shared)
d3744 1
a3744 1
      if ((link_info.relocateable || link_info.emitrelocations)
d3797 1
a3797 1
  if (link_info.relocateable
d3938 1
a3938 1
		  if (! link_info.relocateable
d4356 1
a4356 1
  if (! link_info.relocateable)
d4374 1
a4374 1
  if (!link_info.relocateable)
d4452 1
a4452 1
  if (! link_info.relocateable
@


1.113
log
@Default to generating a fatal error message if a loadable section is not
allocated to a memory region when regions are defined.
@
text
@d1092 3
a1094 1
	     section.  */
d1096 1
@


1.112
log
@bfd/

2003-04-28  H.J. Lu <hjl@@gnu.org>

	* elfxx-ia64.c (elfNN_ia64_relax_section): Relax ldxmov during
	the relax finalize pass.

	* section.c (struct sec): Add need_finalize_relax and remove
	flag11.
	(STD_SECTION): Update struct sec initializer.
	* bfd-in2.h: Regenerated.

include/

2003-04-28  H.J. Lu <hjl@@gnu.org>

	* bfdlink.h (bfd_link_info): Add relax_finalizing.

ld/

2003-04-28  H.J. Lu <hjl@@gnu.org>

	* ldlang.c (lang_process): Add the relax finalize pass.

	* ldmain.c (main): Initialize link_info.relax_finalizing to
	FALSE.
@
text
@d3053 1
a3053 1
		       defined, issue a warning.  */
d3065 19
a3083 3
		      einfo (_("%P: warning: no memory region specified for section `%s'\n"),
			     bfd_get_section_name (output_bfd,
						   os->bfd_section));
@


1.111
log
@Fix memory leaks
@
text
@d4396 8
@


1.111.2.1
log
@	* ldlang.c (lang_process): Add the relax finalize pass.

	* ldmain.c (main): Initialize link_info.relax_finalizing to
	FALSE.
@
text
@a4395 8

	  /* If the normal relax is done and the relax finalize pass
	     is not performed yet, we perform another relax pass.  */
	  if (!relax_again && !link_info.relax_finalizing)
	    {
	      link_info.relax_finalizing = TRUE;
	      relax_again = TRUE;
	    }
@


1.110
log
@* ldfile.h (struct search_dirs): Added sysrooted field.
* ldlang.h (struct lang_input_statement_struct): Likewise.
* ldfile.c (ldfile_add_library_path): Mark sysrooted paths.
(ldfile_open_file_search): Look for sysrooted filename starting
with / in ld_sysroot instead of in the current directory.  Clear
sysrooted flag if it's found in the current directory.  Set it
from the search directory's sysrooted flag where it is found
otherwise.
* ldlang.c (ldlang_sysrooted_script): New static variable.
(new_afile): Mark search_file_enums as sysrooted if
ldlang_sysrooted_script.
(load_symbols): Set ldlang_sysrooted_script according to the
script's sysrooted field while processing it.
* ld.texinfo: Document INPUT behavior in sysroot.
@
text
@d5279 1
@


1.109
log
@Disable region size checking whilst relaxing sections.
@
text
@d243 1
d551 1
d587 1
d1545 1
d1577 2
d1585 1
@


1.108
log
@	* ldfile.c: Fix comment typos.
	* ldlang.c: Likewise.
	* mri.c: Likewise.
	* pe-dll.c: Likewise.
@
text
@d3 1
a3 1
   2001, 2002
d44 1
a44 1
#define offsetof(TYPE,MEMBER) ((size_t)&(((TYPE*)0)->MEMBER))
d47 1
a47 5
/* FORWARDS */
static lang_statement_union_type *new_statement
  PARAMS ((enum statement_enum, size_t, lang_statement_list_type *));

/* LOCALS */
d64 3
d203 2
a204 1
	   lang_statement_union_type **, fill_type *, bfd_vma, bfd_boolean *));
d229 1
a229 1
/* EXPORTS */
d2974 2
a2975 1
lang_size_sections_1 (s, output_section_statement, prev, fill, dot, relax)
d2982 1
d3052 1
d3104 1
a3104 1
				  os->fill, dot, relax);
d3145 4
a3148 3
		/* Make sure the new address is within the region.  */
		os_region_check (os, os->region, os->addr_tree,
				 os->bfd_section->vma);
d3161 3
a3163 2
		    os_region_check (os, os->lma_region, NULL,
				     os->bfd_section->lma);
d3173 1
a3173 1
				      fill, dot, relax);
d3237 1
a3237 1
				      fill, dot, relax);
d3335 1
a3335 1
				      fill, dot, relax);
d3352 2
a3353 1
lang_size_sections (s, output_section_statement, prev, fill, dot, relax)
d3360 1
d3366 1
a3366 1
				 dot, relax);
d3382 1
a3382 1
					 fill, dot, relax);
d4358 2
a4359 1
		      &statement_list.head, 0, (bfd_vma) 0, NULL);
d4388 1
a4388 1
			      &relax_again);
d4391 10
@


1.107
log
@Change linker's default behaviour - it will now reject binary files whoes
architecture it does not recognise, unless it has explicitly told to accept
them.
@
text
@d526 1
a526 1
   they may, for example be split over serveral lines like foo.o(.text)
d1307 1
a1307 1
      /* If supplied an aligment, then force it.  */
d1703 1
a1703 1
/* Remove the first occurance of needle (if any) in haystack
d2147 1
a2147 1
/* Open input files and attatch to output sections.  */
d3893 1
a3893 1
	      /* This section of the file is not attatched, root
@


1.106
log
@	* ldlang.c (init_os): Ensure sections mentioned in load_base
	are initialized.
@
text
@d3702 2
a3703 1
      compatible = bfd_arch_get_compatible (input_bfd, output_bfd);
@


1.105
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d915 3
@


1.104
log
@	* ldlang.c (lang_add_section): Discard debugging sections that have
        been marked SEC_EXCLUDE.
@
text
@d58 1
a58 1
static boolean placed_commons = false;
d60 1
a60 1
static boolean map_option_f;
d72 12
a83 6
  PARAMS ((const char *, lang_input_file_enum_type, const char *, boolean));
static lang_memory_region_type *lang_memory_default PARAMS ((asection *));
static void lang_map_flags PARAMS ((flagword));
static void init_os PARAMS ((lang_output_section_statement_type *));
static void exp_init_os PARAMS ((etree_type *));
static void section_already_linked PARAMS ((bfd *, asection *, PTR));
d86 6
a91 3
static void already_linked_table_init PARAMS ((void));
static void already_linked_table_free PARAMS ((void));
static boolean wildcardp PARAMS ((const char *));
d98 3
a100 2
static lang_input_statement_type *lookup_name PARAMS ((const char *));
static boolean load_symbols
d105 12
a116 6
static bfd *open_output PARAMS ((const char *));
static void ldlang_open_output PARAMS ((lang_statement_union_type *));
static void open_input_bfds PARAMS ((lang_statement_union_type *, boolean));
static void lang_reasonable_defaults PARAMS ((void));
static void insert_undefined PARAMS ((const char *));
static void lang_place_undefineds PARAMS ((void));
d120 2
a121 1
static void strip_excluded_output_sections PARAMS ((void));
d127 16
a142 8
static void print_input_statement PARAMS ((lang_input_statement_type *));
static boolean print_one_symbol PARAMS ((struct bfd_link_hash_entry *, PTR));
static void print_input_section PARAMS ((lang_input_section_type *));
static void print_fill_statement PARAMS ((lang_fill_statement_type *));
static void print_data_statement PARAMS ((lang_data_statement_type *));
static void print_address_statement PARAMS ((lang_address_statement_type *));
static void print_reloc_statement PARAMS ((lang_reloc_statement_type *));
static void print_padding_statement PARAMS ((lang_padding_statement_type *));
d151 2
a152 1
static void print_statements PARAMS ((void));
d159 16
a174 8
static void lang_finish PARAMS ((void));
static void ignore_bfd_errors PARAMS ((const char *, ...));
static void lang_check PARAMS ((void));
static void lang_common PARAMS ((void));
static boolean lang_one_common PARAMS ((struct bfd_link_hash_entry *, PTR));
static void lang_place_orphans PARAMS ((void));
static int topower PARAMS ((int));
static void lang_set_startof PARAMS ((void));
d178 11
a188 7
static void lang_get_regions PARAMS ((struct memory_region_struct **,
				      struct memory_region_struct **,
				      const char *, const char *, int));
static void lang_record_phdrs PARAMS ((void));
static void lang_gc_wild PARAMS ((lang_wild_statement_type *));
static void lang_gc_sections_1 PARAMS ((lang_statement_union_type *));
static void lang_gc_sections PARAMS ((void));
d195 4
a198 2
static void lang_do_version_exports_section PARAMS ((void));
static void lang_check_section_addresses PARAMS ((void));
d204 4
a207 7
	   lang_statement_union_type **, fill_type *, bfd_vma, boolean *));

typedef void (*callback_t) PARAMS ((lang_wild_statement_type *,
				    struct wildcard_list *,
				    asection *,
				    lang_input_statement_type *,
				    PTR));
d216 12
a227 7

static int    get_target PARAMS ((const bfd_target *, PTR));
static void   stricpy PARAMS ((char *, char *));
static void   strcut PARAMS ((char *, char *));
static int    name_compare PARAMS ((char *, char *));
static int    closest_target_match PARAMS ((const bfd_target *, PTR));
static char * get_first_input_target PARAMS ((void));
d236 5
a240 5
boolean entry_from_cmdline;
boolean lang_has_input_file = false;
boolean had_output_filename = false;
boolean lang_float_flag = false;
boolean delete_output_file_on_failure = false;
d272 1
a272 1
boolean
d283 1
a283 1
	return true;
d286 1
a286 1
  return false;
d313 1
a313 1
	  boolean skip = false;
d535 1
a535 1
     boolean add_to_list;
d548 1
a548 1
  lang_has_input_file = true;
d554 2
a555 2
      p->is_archive = false;
      p->real = true;
d557 2
a558 2
      p->just_syms_flag = true;
      p->search_dirs_flag = false;
d562 2
a563 2
      p->is_archive = false;
      p->real = false;
d565 2
a566 2
      p->just_syms_flag = false;
      p->search_dirs_flag = false;
d569 1
a569 1
      p->is_archive = true;
d571 1
a571 1
      p->real = true;
d573 2
a574 2
      p->just_syms_flag = false;
      p->search_dirs_flag = true;
d578 2
a579 2
      p->is_archive = false;
      p->real = false;
d581 2
a582 2
      p->just_syms_flag = false;
      p->search_dirs_flag = true;
d586 2
a587 2
      p->is_archive = false;
      p->real = true;
d589 2
a590 2
      p->just_syms_flag = false;
      p->search_dirs_flag = true;
d594 2
a595 2
      p->is_archive = false;
      p->real = true;
d597 2
a598 2
      p->just_syms_flag = false;
      p->search_dirs_flag = false;
d610 1
a610 1
  p->loaded = false;
d623 2
a624 2
  lang_has_input_file = true;
  return new_afile (name, file_type, target, true);
d714 1
a714 1
    new->had_full_message = false;
d785 1
a785 1
      lookup->processed = false;
d1042 1
a1042 1
     bfd_hash_lookup (&already_linked_table, name, true, false));
d1145 1
a1145 1
/* Return true if the PATTERN argument is a wildcard pattern.
d1151 1
a1151 1
static boolean
d1161 2
a1162 2
      return true;
  return false;
d1177 1
a1177 1
  boolean discard;
d1181 1
a1181 1
  discard = false;
d1188 1
a1188 1
    discard = true;
d1193 1
a1193 1
    discard = true;
d1199 1
a1199 1
    discard = true;
d1213 1
a1213 1
      boolean first;
d1350 1
a1350 1
	  boolean fa, la;
d1362 1
a1362 1
	      fa = true;
d1367 1
a1367 1
	      fa = false;
d1374 1
a1374 1
	      la = true;
d1379 1
a1379 1
	      la = false;
d1503 1
a1503 1
			false);
d1521 1
a1521 1
static boolean
d1529 1
a1529 1
    return true;
d1538 1
a1538 1
      boolean bad_load = true;
d1544 1
a1544 1
	return true;
d1560 1
a1560 1
	bad_load = false;
d1571 1
a1571 1
      ldfile_assumed_script = true;
d1574 1
a1574 1
      ldfile_assumed_script = false;
d1582 1
a1582 1
    return true;
d1603 1
a1603 1
	  boolean loaded = true;
d1616 1
a1616 1
		  loaded = false;
d1626 1
a1626 1
		  loaded = false;
d1637 1
a1637 1
    entry->loaded = true;
d1673 1
a1673 1
/* Return true iff target is the sought target.  */
d1924 1
a1924 1
  delete_output_file_on_failure = true;
d1982 1
a1982 1
     boolean force;
d2012 1
a2012 1
		open_input_bfds (s->group_statement.children.head, true);
d2036 1
a2036 1
		s->input_statement.loaded = false;
d2041 1
a2041 1
		config.make_executable = false;
d2116 1
a2116 1
  h = bfd_link_hash_lookup (link_info.hash, name, true, false, true);
d2352 1
a2352 1
static boolean
d2375 1
a2375 1
  return true;
d2977 1
a2977 1
     boolean *relax;
d3117 1
a3117 1
	    os->processed = true;
d3252 1
a3252 1
		boolean again;
d3257 1
a3257 1
		  *relax = true;
d3350 1
a3350 1
     boolean *relax;
d3565 1
a3565 1
      h = bfd_link_hash_lookup (link_info.hash, buf, false, false, true);
d3574 1
a3574 1
      h = bfd_link_hash_lookup (link_info.hash, buf, false, false, true);
d3597 1
a3597 1
  boolean warn;
d3600 1
a3600 1
    warn = false;
d3602 1
a3602 1
    warn = true;
d3609 1
a3609 1
      warn = false;
d3613 1
a3613 1
			    false, false, true);
d3778 1
a3778 1
static boolean
d3790 1
a3790 1
    return true;
d3797 1
a3797 1
    return true;
d3824 1
a3824 1
      static boolean header_printed;
d3833 1
a3833 1
	  header_printed = true;
d3869 1
a3869 1
  return true;
d4072 1
a4072 1
      had_output_filename = true;
d4241 1
a4241 1
				false, false, false);
d4273 1
a4273 1
  open_input_bfds (statement_list.head, false);
d4353 1
a4353 1
      boolean relax_again;
d4359 1
a4359 1
	  relax_again = false;
d4412 1
a4412 1
     boolean keep_sections;
d4423 1
a4423 1
	placed_commons = true;
d4434 1
a4434 1
	lang_has_input_file = true;
d4439 1
a4439 1
  new->filenames_sorted = false;
d4470 1
a4470 1
     boolean cmdline;
d4501 1
a4501 1
	  map_option_f = true;
d4588 1
a4588 1
  first_file->real = true;
d4595 1
a4595 1
     boolean maybe;
d4607 1
a4607 1
   HAVE_LMA_P is true if the statement had an explicit load address.
d4658 1
a4658 1
  h = bfd_link_hash_lookup (link_info.hash, name, true, true, true);
d4691 1
a4691 1
  h = bfd_link_hash_lookup (link_info.hash, name, true, true, true);
d4777 2
a4778 2
     boolean filehdr;
     boolean phdrs;
d4857 1
a4857 1
		  pl->used = true;
d4915 1
a4915 1
  link_info.notice_all = true;
d5134 1
a5134 1
	 Should we early out false in this case?  */
d5161 1
a5161 1
	 Should we early out false in this case?  */
@


1.103
log
@	* emultempl/aix.em: Use include <> for generated headers.
	* emultempl/beos.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/pe.em: Likewise.
	* ldctor.c: Likewise.
	* ldexp.c: Likewise.
	* ldfile.c: Likewise.
	* ldlang.c: Likewise.
	* ldlex.c: Likewise.
	* ldlex.l: Likewise.
	* ldmain.c: Likewise.
	* ldmisc.c: Likewise.
	* ldwrite.c: Likewise.
	* lexsup.c: Likewise.
	* mri.c: Likewise.
	* pe-dll.c: Likewise.
@
text
@d1141 5
a1145 4
  /* If we are doing a final link, discard sections marked with
     SEC_EXCLUDE.  */
  if (! link_info.relocateable
      && (flags & SEC_EXCLUDE) != 0)
@


1.102
log
@	* ldlang.c (load_symbols): Revert last change.
@
text
@d34 1
a34 1
#include "ldgram.h"
@


1.101
log
@	* ldlang.c (load_symbols): Don't call bfd_link_add_symbols when
	just_syms_flag.
	(lang_reasonable_defaults): Don't compare against false.
	(size_input_section): Likewise.
	(lang_size_sections_1): Likewise.
	(lang_do_assignments): Likewise.
	(lang_add_output): Likewise.
@
text
@d1593 1
a1593 3
  if (entry->just_syms_flag)
    entry->loaded = true;
  else if (bfd_link_add_symbols (entry->the_bfd, &link_info))
@


1.100
log
@	* ldfile.c (ldfile_try_open_bfd): When searching skip linker scripts if
	they have OUTPUT_FORMAT not matching actual output format.
	* ldlang.c (lang_get_output_target): New function.
	(open_output): Use it.
	* ldlang.h (lang_get_output_target): New prototype.
@
text
@d1593 3
a1595 1
  if (bfd_link_add_symbols (entry->the_bfd, &link_info))
d2027 1
a2027 1
  if (placed_commons == false)
d2783 1
a2783 1
  if (is->ifile->just_syms_flag == false)
d3038 4
a3041 5
		    if (r.valid_p == false)
		      {
			einfo (_("%F%S: non constant address expression for section %s\n"),
			       os->name);
		      }
d3408 1
a3408 1
	    if (value.valid_p == false)
d3445 1
a3445 1
	    if (value.valid_p == false)
d4028 1
a4028 1
  if (had_output_filename == false || !from_script)
@


1.99
log
@2002-10-08  H.J. Lu <hjl@@gnu.org>

	* ldlang.c (lang_file_exist): Removed.
	(new_afile): Revert the last change.
	* ldlang.h (lang_file_exist): Removed.
	* lexsup.c (parse_args): Revert the last change.
@
text
@d1790 23
d1821 1
a1821 18
  /* Has the user told us which output format to use?  */
  if (output_target == (char *) NULL)
    {
      /* No - has the current target been set to something other than
         the default?  */
      if (current_target != default_target)
	output_target = current_target;

      /* No - can we determine the format of the first input file?  */
      else
	{
	  output_target = get_first_input_target ();

	  /* Failed - use the default output target.  */
	  if (output_target == NULL)
	    output_target = default_target;
	}
    }
@


1.98
log
@Abort if the filename to be added matches the linker output filename.
@
text
@a461 21
/* Check if a file exist in the input_file_chain list.  */

boolean
lang_file_exists (name)
    const char *name;
{
  lang_input_statement_type *p;

  if (name == NULL)
    return false;

  for (p = (lang_input_statement_type *) input_file_chain.head;
       p != (lang_input_statement_type *) NULL;
       p = (lang_input_statement_type *) p->next_real_file)
    if (p->filename != (char *) NULL
	&& strcmp (p->filename, name) == 0)
      return true;

  return false;
}

a496 5
  /* We abort if an input file name is identical with the output file name.  */
  if (name != NULL && output_filename != NULL
      && !strcmp (name, output_filename))
    einfo ("%P%F: input file %s is also the output file!\n", name);
 
@


1.97
log
@	* ldlang.c (offsetof): Define if not defined.
@
text
@d6 1
a6 1
This file is part of GLD, the Gnu Linker.
d8 14
a21 14
GLD is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GLD is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GLD; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.  */
d462 21
d518 5
@


1.96
log
@	* emulparams/elf32_dlx.sh (TARGET_PAGE_SIZE): Set to 1.
	(MAXPAGESIZE): Set to 1.

	* ld.h (ALIGN_N): Delete.
	* ldexp.h (align_n): Declare.
	* ldexp.c (align_n): New function.
	(fold_binary): Use align_n instead of ALIGN_N.
	(exp_fold_tree): Likewise.
	* ldlang.c (lang_size_sections_1): Likewise.
	(lang_one_common): Likewise.
@
text
@d43 4
@


1.95
log
@Check symbols with undefine version.
@
text
@d3050 1
a3050 1
	    after = ALIGN_N (os->bfd_section->vma
a3051 1
			     /* The coercion here is important, see ld.h.  */
d3750 2
a3751 2
  section->_cooked_size = ALIGN_N ((section->_cooked_size + opb - 1) / opb,
				   (bfd_size_type) (1 << power_of_two)) * opb;
@


1.94
log
@	* elf.c (elf_fake_sections): Fix up .tbss sh_size and sh_type.

	* ldlang.c (lang_add_section): Don't turn .tbss into normal sections
	for relocatable link.
	(lang_size_sections_1): Don't make .tbss zero size for relocatable
	link.
@
text
@d5135 2
@


1.93
log
@	* ldlang.c (print_wild_statement): Fix output formatting.
@
text
@d1221 1
a1221 1
      if (flags & SEC_THREAD_LOCAL)
d3058 2
a3059 1
		     && (os->bfd_section->flags & SEC_THREAD_LOCAL))
@


1.93.2.1
log
@        Merge from mainline:
        2002-07-14  H.J. Lu <hjl@@gnu.org>
        * ld.texinfo: Document a .symver takes precedence over a
        version script.
@
text
@d1221 1
a1221 1
      if ((flags & SEC_THREAD_LOCAL) && ! link_info.relocateable)
d3058 1
a3058 2
		     && (os->bfd_section->flags & SEC_THREAD_LOCAL)
		     && ! link_info.relocateable)
@


1.93.2.2
log
@	* emulparams/elf32_dlx.sh (TARGET_PAGE_SIZE): Set to 1.
	(MAXPAGESIZE): Set to 1.

	* ld.h (ALIGN_N): Delete.
	* ldexp.h (align_n): Declare.
	* ldexp.c (align_n): New function.
	(fold_binary): Use align_n instead of ALIGN_N.
	(exp_fold_tree): Likewise.
	* ldlang.c (lang_size_sections_1): Likewise.
	(lang_one_common): Likewise.
@
text
@d3050 1
a3050 1
	    after = align_n (os->bfd_section->vma
d3052 1
d3751 2
a3752 2
  section->_cooked_size = align_n ((section->_cooked_size + opb - 1) / opb,
				   (bfd_vma) 1 << power_of_two) * opb;
@


1.93.2.3
log
@2002-09-23  Daniel Jacobowitz  <drow@@mvista.com>

	Merge from mainline:
	2002-09-22  Mark Elbrecht  <snowball3@@softhome.net>
	* scripttempl/i386go32.sc: Handle bss unique sections.

	2002-09-11  Nick Clifton  <nickc@@redhat.com>
	* po/tr.po: Updated Turkish translation.

	2002-08-28  Alan Modra  <amodra@@bigpond.net.au>
	* emultempl/aix.em (gld${EMULATION_NAME}_parse_args): Replace strtoll,
	strtoul and strtoull with bfd_scan_vma.
	(gld${EMULATION_NAME}_read_file): Likewise.

	2002-08-07  Nick Clifton  <nickc@@redhat.com>
	* emultempl/armelf.em (arm_elf_before_allocation): Only search
	for an interworking bfd if there are input bfds.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* emultempl/aix.em (gld*_before_parse): Set default arch.  Reverts
	2002-05-10 change.

	2002-08-06  H.J. Lu <hjl@@gnu.org>
	* ld.texinfo: Document --no-undefined-version.

	* ldlang.c (lang_new_vers_pattern): Set the `symver' and
	`script.' fields to 0.

	* ldmain.c (main): Initialize the allow_undefined_version to
	true.

	* lexsup.c (OPTION_NO_UNDEFINED_VERSION): New.
	(ld_options): Add --no-undefined-version.
	(parse_args): Support OPTION_NO_UNDEFINED_VERSION.

	2002-07-04  Bruno Haible  <bruno@@clisp.org>
	* emulparams/elf_i386_fbsd.sh: Set OUTPUT_FORMAT to
	elf32-i386-freebsd.
	* emulparams/elf64alpha_fbsd.sh: Set OUTPUT_FORMAT to
	elf64-alpha-freebsd.
@
text
@a5133 2
  ret->symver = 0;
  ret->script = 0;
@


1.93.2.4
log
@	* ldlang.c (load_symbols): Revert last change.
@
text
@d2015 1
a2015 1
  if (!placed_commons)
d2771 1
a2771 1
  if (!is->ifile->just_syms_flag)
d3026 5
a3030 4
		    if (!r.valid_p)
		      einfo (_("%F%S: non constant address expression for section %s\n"),
			     os->name);

d3397 1
a3397 1
	    if (!value.valid_p)
d3434 1
a3434 1
	    if (!value.valid_p)
d4017 1
a4017 1
  if (!had_output_filename || !from_script)
@


1.93.2.5
log
@Merge from mainline.
@
text
@a1785 23
const char *
lang_get_output_target ()
{
  const char *target;

  /* Has the user told us which output format to use?  */
  if (output_target != (char *) NULL)
    return output_target;

  /* No - has the current target been set to something other than
     the default?  */
  if (current_target != default_target)
    return current_target;

  /* No - can we determine the format of the first input file?  */
  target = get_first_input_target ();
  if (target != NULL)
    return target;

  /* Failed - use the default output target.  */
  return default_target;
}

d1794 18
a1811 1
  output_target = lang_get_output_target ();
@


1.93.2.6
log
@        * emultempl/aix.em: Use include <> for generated headers.
        * emultempl/beos.em: Likewise.
        * emultempl/elf32.em: Likewise.
        * emultempl/pe.em: Likewise.
        * ldctor.c: Likewise.
        * ldexp.c: Likewise.
        * ldfile.c: Likewise.
        * ldlang.c: Likewise.
        * ldlex.c: Likewise.
        * ldlex.l: Likewise.
        * ldmain.c: Likewise.
        * ldmisc.c: Likewise.
        * ldwrite.c: Likewise.
        * lexsup.c: Likewise.
        * mri.c: Likewise.
        * pe-dll.c: Likewise.
@
text
@d34 1
a34 1
#include <ldgram.h>
@


1.92
log
@	* ldlang.c: (strip_excluded_output_sections): New function.
	(lang_process): Call it.
	(lang_size_sections_1): Revert 2002-06-10 change.
@
text
@d2564 1
a2564 1
	  minfo ("EXCLUDE_FILE ( %s", sec->spec.exclude_name_list->name);
d2566 2
a2567 2
	    minfo (", %s", tmp->name);
	  minfo (")");
d2575 2
@


1.91
log
@	* ldlang.h (entry_sym): Make it a struct bfd_sym_chain.
	* ldlang.c (entry_sym): Likewise.
	(ldlang_undef_chain_list_type): Likewise.
	(lang_finish): Adjust references to entry_symbol.
	(lang_add_entry): Likewise.
	(lang_gc_sections): Use link_info.gc_sym_list.
	(lang_process): Set link_info.gc_sym_list.
	* ldlex.l: Include bfdlink.h.
	* ldmain.c (main): Init link_info.gc_sym_list.
	* emultempl/aix.em: Adjust references to entry_symbol.
	* emultempl/armcoff.em: Likewise.
	* emultempl/armelf.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/ppc64elf.em (ppc_after_open): New function.
	(LDEMUL_AFTER_OPEN): Define.
	* emulparams/elf64ppc.sh: KEEP .opd sections.
@
text
@d100 1
d2165 35
a2941 8
	    /* The section might have been removed after its statement was
	       added.  For example, ldemul_before_allocation can remove
	       dynamic sections if they turn out not to be needed.  */
	    if (!link_info.relocateable
		&& (bfd_get_section_flags (output_bfd, os->bfd_section)
		    & SEC_EXCLUDE) != 0)
	      break;

d4282 3
@


1.90
log
@	* ldlang.c (lang_size_sections_1): Skip removed output sections.
@
text
@d187 1
a187 1
const char *entry_symbol = NULL;
d2033 1
a2033 5
typedef struct ldlang_undef_chain_list
{
  struct ldlang_undef_chain_list *next;
  char *name;
}                       ldlang_undef_chain_list_type;
d2035 1
a2035 1
static ldlang_undef_chain_list_type *ldlang_undef_chain_list_head;
d3522 1
a3522 1
  if (entry_symbol == (char *) NULL)
d3526 1
a3526 1
      entry_symbol = "start";
d3530 2
a3531 1
  h = bfd_link_hash_lookup (link_info.hash, entry_symbol, false, false, true);
d3544 1
a3544 1
	einfo (_("%P%F:%s: can't set start address\n"), entry_symbol);
d3553 1
a3553 1
      val = bfd_scan_vma (entry_symbol, &send, 0);
d3570 2
a3571 1
		       entry_symbol, bfd_get_section_vma (output_bfd, ts));
d3581 1
a3581 1
		       entry_symbol);
d4147 1
a4147 1
  ldlang_undef_chain_list_type *ulist, fake_list_start;
d4153 2
a4154 11
  /* Keep all sections containing symbols undefined on the command-line.
     Handle the entry symbol at the same time.  */

  if (entry_symbol != NULL)
    {
      fake_list_start.next = ldlang_undef_chain_list_head;
      fake_list_start.name = (char *) entry_symbol;
      ulist = &fake_list_start;
    }
  else
    ulist = ldlang_undef_chain_list_head;
d4156 1
a4156 1
  for (; ulist; ulist = ulist->next)
d4193 4
d4387 1
a4387 1
  if (entry_symbol == NULL
d4391 1
a4391 1
      entry_symbol = name;
@


1.89
log
@	* ldlang.c (section_already_linked): Call bfd_discard_group.  Typo fix.
@
text
@d2910 8
@


1.88
log
@	* ldlang.c (lang_size_sections_1): Move check for conflicting load
	addresses and regions from here...
	(lang_get_regions): ...to this new function.
	(lang_leave_output_section_statement): Use lang_get_regions.
	(lang_leave_overlay): Likewise.
	* mri.c (mri_draw_tree): Pass null as last argument to
	lang_leave_output_section_statement.
	* emultempl/elf32.em (gld*_place_orphan): Likewise.
	* emultempl/mmo.em (mmo_place_orphan): Likewise.
	* emultempl/pe.em (gld*_place_orphan): Likewise.
@
text
@d988 1
a988 1
     causes trouble for MIPS ELF, which relies in link once semantics
d1041 3
@


1.87
log
@	* ldlang.c (lang_process): Formatting, grammar.
@
text
@d139 3
d3059 1
a3059 1
		if (os->lma_region != NULL)
d3061 6
a3066 18
		    if (os->load_base != NULL)
		      {
			einfo (_("%X%P: use an absolute load address or a load memory region, not both\n"));
		      }
		    else
		      {
			/* Don't allocate twice.  */
			if (os->lma_region != os->region)
			  {
			    /* Set load_base, which will be handled later.  */
			    os->load_base =
			      exp_intop (os->lma_region->current);
			    os->lma_region->current +=
			      os->bfd_section->_raw_size / opb;
			    os_region_check (os, os->lma_region, NULL,
					     os->bfd_section->lma);
			  }
		      }
d4511 30
d4548 4
a4552 8
  current_section->region = lang_memory_region_lookup (memspec);
  current_section->lma_region = lang_memory_region_lookup (lma_memspec);

  /* If no runtime region has been given, but the load region has
     been, use the load region.  */
  if (current_section->lma_region != 0 && strcmp (memspec, "*default*") == 0)
    current_section->region = current_section->lma_region;

d4954 3
a4956 2
  region = lang_memory_region_lookup (memspec);
  lma_region = lang_memory_region_lookup (lma_memspec);
@


1.86
log
@	* elf.c (_bfd_elf_make_section_from_shdr): Set SEC_THREAD_LOCAL
	for symbols from SHF_TLS section.
	(_bfd_elf_print_private_bfd_data): Add PT_TLS.
	(elf_fake_sections): Set SHF_TLS for SEC_THREAD_LOCAL sections.
	(map_sections_to_segments): Build PT_TLS segment if necessary.
	(assign_file_positions_for_segments): Likewise.
	(get_program_header_size): Account for PT_TLS segment.
	(swap_out_syms): Set type of BSF_THREAD_LOCAL symbols and symbols from
	SEC_THREAD_LOCAL sections to STT_TLS.
	* reloc.c: Add 386 and IA-64 TLS relocs.
	* section.c (SEC_THREAD_LOCAL): Define.
	(SEC_CONSTRUCTOR_TEXT, SEC_CONSTRUCTOR_DATA, SEC_CONSTRUCTOR_BSS):
	Remove.
	* elflink.h (elf_link_add_object_symbols): Support .tcommon.
	(size_dynamic_sections): If DF_STATIC_TLS, set DF_FLAGS
	unconditionally.
	(struct elf_final_link_info): Add first_tls_sec.
	(elf_bfd_final_link): Set first_tls_sec.
	Compute elf_hash_table (info)->tls_segment.
	(elf_link_output_extsym): Handle STT_TLS symbols.
	(elf_link_input_bfd): Likewise.
	* syms.c (BSF_THREAD_LOCAL): Define.
	* bfd-in2.h: Rebuilt.
	* libbfd.h: Rebuilt.
	* elf32-i386.c (elf_i386_tls_transition, dtpoff_base, tpoff,
	elf_i386_mkobject, elf_i386_object_p): New functions.
	(elf_howto_table): Add TLS relocs.
	(elf_i386_reloc_type_lookup): Support TLS relocs.
	(elf_i386_info_to_howto_rel): Likewise.
	(struct elf_i386_link_hash_entry): Add tls_type.
	(struct elf_i386_obj_tdata): New.
	(elf_i386_hash_entry, elf_i386_tdata, elf_i386_local_got_tls_type):
	New macros.
	(struct elf_i386_link_hash_table): Add tls_ldm_got.
	(link_hash_newfunc): Clear tls_type.
	(elf_i386_check_relocs): Support TLS relocs.
	(elf_i386_gc_sweep_hook): Likewise.
	(allocate_dynrelocs): Likewise.
	(elf_i386_size_dynamic_sections): Likewise.
	(elf_i386_relocate_section): Likewise.
	(elf_i386_finish_dynamic_symbol): Likewise.
	(bfd_elf32_mkobject, elf_backend_object_p): Define.
	* elfxx-ia64.c (struct elfNN_ia64_dyn_sym_info): Add tprel_offset,
	dtpmod_offset, dtprel_offset, tprel_done, dtpmod_done, dtprel_done,
	want_tprel, want_dtpmod, want_dtprel.
	(elfNN_ia64_tprel_base, elfNN_ia64_dtprel_base): New functions.
	(ia64_howto_table): Add TLS relocs, rename R_IA64_LTOFF_TP22 to
	R_IA64_LTOFF_TPREL22.
	(elf_code_to_howto_index): Add TLS relocs.
	(elfNN_ia64_check_relocs): Support TLS relocs.
	(allocate_global_data_got): Account for TLS .got data.
	(allocate_dynrel_entries): Account for TLS dynamic relocations.
	(elfNN_ia64_install_value): Supprt TLS relocs.
	(set_got_entry): Support TLS relocs.
	(elfNN_ia64_relocate_section): Likewise.

	* config/obj-elf.c (elf_common): Renamed from obj_elf_common.
	(obj_elf_common): Call elf_common.
	(obj_elf_tls_common): New function.
	(elf_pseudo_tab): Support .tls_common.
	(special_sections): Add .tdata and .tbss.
	(obj_elf_change_section): Set SEC_THREAD_LOCAL for SHF_TLS
	sections.
	(obj_elf_parse_section_letters): Support T in section flags (SHF_TLS).
	(obj_elf_parse_section_letters): Include T in error message.
	* config/tc-ppc.c (ppc_section_letter): Likewise.
	* config/tc-alpha.c (alpha_elf_section_letter): Likewise.
	(tc_gen_reloc): Handle SEC_THREAD_LOCAL the same way as
	SEC_MERGE.
	* config/tc-sparc.c (md_apply_fix3): Likewise.
	* config/tc-i386.c (tc_i386_fix_adjustable): Add TLS relocs.
	Define them if not BFD_ASSEMBLER.
	(lex_got): Support @@TLSGD, @@TLSLDM, @@GOTTPOFF, @@TPOFF, @@DTPOFF
	and @@NTPOFF.
	(md_apply_fix3): Add TLS relocs.
	* config/tc-ia64.c (enum reloc_func): Add FUNC_DTP_MODULE,
	FUNC_DTP_RELATIVE, FUNC_TP_RELATIVE, FUNC_LT_DTP_MODULE,
	FUNC_LT_DTP_RELATIVE, FUNC_LT_TP_RELATIVE.
	(pseudo_func): Support @@dtpmod(), @@dtprel() and @@tprel().
	(ia64_elf_section_letter): Include T in error message.
	(md_begin): Support TLS operators.
	(md_operand): Likewise.
	(ia64_gen_real_reloc_type): Support TLS relocs.
	* testsuite/gas/i386/tlspic.s: New file.
	* testsuite/gas/i386/tlsd.s: New file.
	* testsuite/gas/i386/tlsnopic.s: New file.
	* testsuite/gas/i386/tlsd.d: New file.
	* testsuite/gas/i386/tlsnopic.d: New file.
	* testsuite/gas/i386/tlspic.d: New file.
	* testsuite/gas/i386/i386.exp: Add tlsd, tlsnopic and tlspic tests.
	* testsuite/gas/ia64/tls.s: New file.
	* testsuite/gas/ia64/tls.d: New file.
	* testsuite/gas/ia64/ia64.exp: Add tls test.
	* write.c (adjust_reloc_syms): Don't change symbols in
	SEC_THREAD_LOCAL sections to STT_SECTION + addend.

	* elf/common.h (PT_TLS, SHF_TLS, STT_TLS, DF_STATIC_TLS): Define.
	* elf/ia64.h (R_IA64_LTOFF_TPREL22): Renamed from R_IA64_LTOFF_TP22.
	* elf/i386.h: Add TLS relocs.

	* scripttempl/elf.sc: Add .rel{,a}.t{bss,data}, .tdata and .tbss.
	* ldlang.c (lang_add_section): Set SEC_THREAD_LOCAL for
	output section if necessary.  Handle .tbss.
	(lang_size_sections): Clear _raw_size for .tbss section
	(it allocates space in PT_TLS segment only).
	* ldwrite.c (build_link_order): Build link order for .tbss too.

	* readelf.c (get_segment_type): Add PT_TLS.
	(get_elf_section_flags): Add SHF_TLS.
	(get_dynamic_flags): Optimize.  Add DF_STATIC_TLS.
	(process_dynamic_segment): Use puts instead of printf.
	(get_symbol_type): Support STT_TLS.
	* objdump.c (dump_section_header): Remove SEC_CONSTRUCTOR_TEXT,
	SEC_CONSTRUCTOR_DATA, SEC_CONSTRUCTOR_BSS.
	Add SEC_THREAD_LOCAL.
@
text
@d4292 1
a4292 1
	     globals are, so can make better guess.  */
d4295 1
a4295 1
			      &(statement_list.head), 0, (bfd_vma) 0,
@


1.85
log
@	* ldemul.c (ldemul_new_vers_pattern): New function.
	* ldemul.h (ldemul_new_vers_pattern): Declare.
	(struct ld_emulation_xfer_struct): Add new_vers_pattern.
	* ldlang.c (lang_new_vers_pattern): Call ldemul_new_vers_pattern.
	* emultempl/ppc64elf.em (dotsyms): New static var.
	(gld${EMULATION_NAME}_new_vers_pattern): New function.
	(LDEMUL_NEW_VERS_PATTERN): Define.
	(PARSE_AND_LIST_PROLOGUE): Add OPTION_DOTSYMS, OPTION_NO_DOTSYMS.
	(PARSE_AND_LIST_LONGOPTS): Likewise.
	(PARSE_AND_LIST_ARGS_CASES): Handle them.
	* emultempl/aix.em (ld_${EMULATION_NAME}_emulation): Update
	initialiser.
	* emultempl/armcoff.em: Likewise.
	* emultempl/armelf_oabi.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/generic.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/gld960c.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68kcoff.em: Likewise.
	* emultempl/mipsecoff.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/ticoff.em: Likewise.
	* emultempl/vanilla.em: Likewise.
@
text
@d1213 4
d3017 3
@


1.84
log
@	* ldlang.c (section_already_linked): Call bfd_link_just_syms.
	(lang_place_orphans): Abort if just_syms_flag.
@
text
@d5086 1
a5086 1
  return ret;
@


1.83
log
@	* ldlang.h (lang_output_section_statement_type): Add update_dot_tree.
	(lang_enter_overlay): Remove the last two parameters.
	(lang_leave_overlay): Take them here instead.
	* ldgram.y (memspec_at_opt): Set $$ to null if no region is given.
	(section): Pass LMA and crossref flag to lang_leave_overlay rather
	than lang_enter_overlay.
	* ldlang.c (lang_memory_region_lookup): Return null for null names.
	(lang_output_section_statement_lookup): Initialize update_dot_tree.
	(lang_size_sections_1): Evaluate it.
	(lang_leave_output_section_statement): Rework LMA lookup.
	(overlay_lma, overlay_nocrossrefs): Remove.
	(lang_enter_overlay): Remove LMA and corssref arguments.
	(lang_enter_overlay_section): Don't set the LMA here.
	(lang_leave_overlay): Take LMA and crossref arguments.  Move the '.'
	assignment to the last section's update_dot_tree.  Unconditionally
	use the load and run-time regions specified in the OVERLAY statement.
	Likewise the first section's LMA.  Only set the other sections' LMAs
	when no load region is given.
@
text
@d962 1
a962 2
      sec->output_section = bfd_abs_section_ptr;
      sec->output_offset = sec->vma;
d3805 1
a3805 5
		  /* We are only retrieving symbol values from this
                     file.  We want the symbols to act as though the
                     values in the file are absolute.  */
		  s->output_section = bfd_abs_section_ptr;
		  s->output_offset = s->vma;
@


1.82
log
@	* ld.h: Fix formatting.
	* ldexp.c: Likewise.
	* ldfile.c: Likewise.
	* ldlang.c: Likewise.
	* ldmain.c: Likewise.
	* lexsup.c: Likewise.
	* pe-dll.c: Likewise.
@
text
@d620 4
d745 1
d3017 1
d3021 4
d4527 7
a4533 8
  if (strcmp (lma_memspec, "*default*") != 0)
    {
      current_section->lma_region = lang_memory_region_lookup (lma_memspec);
      /* If no runtime region has been given, but the load region has
         been, use the load region.  */
      if (strcmp (memspec, "*default*") == 0)
	current_section->region = lang_memory_region_lookup (lma_memspec);
    }
a4814 6
/* The overlay load address.  */
static etree_type *overlay_lma;

/* Whether nocrossrefs is set for this overlay.  */
static int overlay_nocrossrefs;

d4830 1
a4830 1
lang_enter_overlay (vma_expr, lma_expr, nocrossrefs)
a4831 2
     etree_type *lma_expr;
     int nocrossrefs;
d4834 1
a4834 4
  ASSERT (overlay_vma == NULL
	  && overlay_lma == NULL
	  && overlay_list == NULL
	  && overlay_max == NULL);
a4836 2
  overlay_lma = lma_expr;
  overlay_nocrossrefs = nocrossrefs;
d4840 2
a4841 1
   lang_enter_output_section_statement with the correct VMA and LMA.  */
d4851 1
a4851 1
				       0, 0, 0, overlay_lma);
d4853 1
a4853 1
  /* If this is the first section, then base the VMA and LMA of future
d4857 1
a4857 4
    {
      overlay_vma = exp_nameop (ADDR, name);
      overlay_lma = exp_nameop (LOADADDR, name);
    }
a4866 3
  /* Adjust the LMA for the next section.  */
  overlay_lma = exp_binop ('+', overlay_lma, size);

d4889 4
a4892 2
  lang_leave_output_section_statement (fill, "*default*",
				       phdrs, "*default*");
d4922 3
a4924 1
lang_leave_overlay (fill, memspec, phdrs, lma_memspec)
a4930 1
  lang_memory_region_type *default_region;
d4935 2
a4936 1
  default_region = lang_memory_region_lookup ("*default*");
d4938 1
a4938 9
  if (memspec == NULL)
    region = NULL;
  else
    region = lang_memory_region_lookup (memspec);

  if (lma_memspec == NULL)
    lma_region = NULL;
  else
    lma_region = lang_memory_region_lookup (lma_memspec);
d4940 5
a4944 1
  nocrossref = NULL;
d4954 13
a4966 17
      /* Assign a region to the sections, if one has been specified.
	 Override the assignment of the default section, but not
	 other sections.  */
      if (region != NULL &&
	  (l->os->region == NULL ||
	   l->os->region == default_region))
	l->os->region = region;

      /* We only set lma_region for the first overlay section, as
	 subsequent overlay sections will have load_base set relative
	 to the first section.  Also, don't set lma_region if
	 load_base is specified.  FIXME:  There should really be a test
	 that `AT ( LDADDR )' doesn't conflict with `AT >LMA_REGION'
	 rather than letting LDADDR simply override LMA_REGION.  */
      if (lma_region != NULL && l->os->lma_region == NULL
	  && l->next == NULL && l->os->load_base == NULL)
	l->os->lma_region = lma_region;
d4971 1
a4971 1
      if (overlay_nocrossrefs)
a4988 4
  /* Update . for the end of the overlay.  */
  lang_add_assignment (exp_assop ('=', ".",
				  exp_binop ('+', overlay_vma, overlay_max)));

a4989 2
  overlay_lma = NULL;
  overlay_nocrossrefs = 0;
@


1.81
log
@	* ldlang.c (print_assignment): Update print_dot for assignments to ".".
	* ldexp.c (exp_print_token): Add "infix_p" argument.
	(exp_print_tree): Update accordingly.
@
text
@d1477 1
a1477 1
      
d1499 1
a1499 1
      
d1540 1
a1540 1
	  bfd * member = NULL;
d1549 1
a1549 1
	      
d1605 1
a1605 1
	     later get something which doesn't know where to put it.  */ 
d2845 1
a2845 1
           || base == 0))
d2848 7
a2854 7
        {
          einfo (_("%X%P: address 0x%v of %B section %s is not within region %s\n"),
                 region->current,
                 os->bfd_section->owner,
                 os->bfd_section->name,
                 region->name);
        }
d2856 6
a2861 6
        {
          einfo (_("%X%P: region %s is full (%B section %s)\n"),
                 region->name,
                 os->bfd_section->owner,
                 os->bfd_section->name);
        }
d3356 2
a3357 2
          {
            unsigned int size;
d3481 1
a3481 1
          unsigned opb;
d3483 1
a3483 1
          opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture,
d3630 1
a3630 1
	     private data of the output bfd. */
d4523 1
a4523 1
        current_section->region = lang_memory_region_lookup (lma_memspec);
d4899 1
a4899 1
                                       phdrs, "*default*");
d4936 1
a4936 1
  lang_memory_region_type * default_region;
d5249 1
a5249 1
        continue;
@


1.80
log
@	* ldlang.c (lang_size_sections_1): Don't complain about
	SEC_NEVER_LOAD sections having no memory region specified.
@
text
@d2214 11
a2224 1
    minfo ("0x%V", result.value + result.section->bfd_section->vma);
@


1.79
log
@	* ldlang.c (ldlang_add_undef): If the output bfd has been opened,
	add the symbol to the linker hash table immediately.
	(lang_place_undefineds): Split symbol creation out..
	(insert_undefined): ..to here.
@
text
@d2933 2
@


1.78
log
@	* ldmain.c (main): Move .text readonly flag fudges from here..
	* ldlang.c (lang_process): ..to here.
@
text
@d95 1
d2014 5
a2018 1
   Remove items from the chain as we open input bfds.  */
d2039 22
d2076 1
a2076 11
      struct bfd_link_hash_entry *h;

      h = bfd_link_hash_lookup (link_info.hash, ptr->name, true, false, true);
      if (h == (struct bfd_link_hash_entry *) NULL)
	einfo (_("%P%F: bfd_link_hash_lookup failed: %E\n"));
      if (h->type == bfd_link_hash_new)
	{
	  h->type = bfd_link_hash_undefined;
	  h->u.undef.abfd = NULL;
	  bfd_link_add_undef (link_info.hash, h);
	}
@


1.77
log
@	* ldlang.c (lang_check): Remove the word size check added in last
	change.  Treat emitrelocations case as for relocatable links.
@
text
@d4201 16
@


1.76
log
@	* ldlang.c (lang_check): Do relocatable link checks first, so that
	warn_mismatch can't override.  Check compatible and word size too.
@
text
@d3580 1
a3580 1
      if (link_info.relocateable
d3582 1
a3582 3
	      || bfd_get_flavour (input_bfd) != bfd_get_flavour (output_bfd)
	      || (input_bfd->arch_info->bits_per_word
		  != output_bfd->arch_info->bits_per_word))
@


1.75
log
@	Support arbitrary length fill patterns.
	* ldexp.h (etree_value_type): Add "str" field.
	(union etree_union): Add "str" to "value" struct.
	(exp_bigintop): Declare.
	(exp_get_fill): Declare.
	* ldexp.c: Include "safe-ctype.h".
	(exp_intop): Set value.str to NULL.
	(exp_bigintop): New function.
	(new_rel): Pass in "str", and set new.str from it.
	(new_rel_from_section): Set new.str to NULL.
	(fold_name): Adjust calls to new_rel.
	(exp_fold_tree): Likewise.
	(exp_get_fill): New function.
	* ldgram.y (struct big_int bigint, fill_type *fill): New.
	(INT): Returns a "bigint".  Adjust all code handling INTs.
	(fill_opt): Returns a "fill".
	(fill_exp): Split out of fill_opt, use for FILL.
	* ldlang.h (struct _fill_type): New.
	(fill_type): Move typedef to ldexp.h.
	(lang_output_section_statement_type): "fill" is now a pointer.
	(lang_fill_statement_type): Likewise.
	(lang_padding_statement_type): Likewise.
	(lang_add_fill): Now takes a "fill_type *" param.
	(lang_leave_output_section_statement): Likewise.
	(lang_do_assignments): Likewise.
	(lang_size_sections): Likewise.
	(lang_leave_overlay_section): Likewise.
	(lang_leave_overlay): Likewise.
	* ldlang.c: Include ldgram.h after ldexp.h.
	(lang_output_section_statement_lookup): Adjust for fill_type change.
	(print_fill_statement): Likewise.
	(print_padding_statement): Likewise.
	(insert_pad): Now takes a "fill_type *" arg.
	(size_input_section): Likewise.
	(lang_size_sections_1): Likewise.
	(lang_size_sections): Likewise.
	(lang_do_assignments): Likewise.
	(lang_add_fill): Likewise.
	(lang_leave_output_section_statement): Likewise.
	(lang_leave_overlay_section): Likewise.
	(lang_leave_overlay): Likewise.
	Adjust all callers of the above function.
	* ldlex.l: Include ldgram.h after ldexp.h.  Allow hex numbers
	starting with "0X" as well as "0x".  Return bigint.str for hex
	numbers starting with "0x" or "0X", zero bigint.str otherwise.
	Always use base 16 for numbers starting with "$".
	* ldmain.c: Include ldgram.h after ldexp.h.
	* ldwrite.c (build_link_order): Use bfd_data_link_order in place
	of bfd_fill_link_order.
	* pe-dll.c: Adjust lang_do_assignments calls.
	* emultempl/elf32.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/beos.em: Include ldgram.h after ldexp.h, adjust
	lang_add_assignment call.
	* emultempl/pe.em: Likewise.
@
text
@d3572 21
a3592 2
      compatible = bfd_arch_get_compatible (input_bfd,
					    output_bfd);
a3599 12
      else if (link_info.relocateable
	       /* In general it is not possible to perform a relocatable
		  link between differing object formats when the input
		  file has relocations, because the relocations in the
		  input format may not have equivalent representations in
		  the output format (and besides BFD does not translate
		  relocs for other link purposes than a final link).  */
	       && bfd_get_flavour (input_bfd) != bfd_get_flavour (output_bfd)
	       && (bfd_get_file_flags (input_bfd) & HAS_RELOC) != 0)
	einfo (_("%P%F: Relocatable linking with relocations from format %s (%B) to format %s (%B) is not supported\n"),
	       bfd_get_target (input_bfd), input_bfd,
	       bfd_get_target (output_bfd), output_bfd);
@


1.74
log
@	* ld.texinfo (VERSION scripts):  Symbol names are globbing patterns.
	* ldgram.y (lang_new_vers_regex):  Rename to lang_new_vers_pattern;
	the pattern in question is not a regexp.
	* ldlang.c:  Likewise.
	* ldlang.h:  Likewise.
	* ldlex.l (V_IDENTIFIER):  Allow '[', ']', '-', '!', and '^' also.
@
text
@a31 1
#include "ldgram.h"
d34 1
d122 1
a122 1
  PARAMS ((lang_statement_union_type **, fill_type,
d126 1
a126 1
	   fill_type, bfd_vma));
d155 1
a155 1
	   lang_statement_union_type **, fill_type, bfd_vma, boolean *));
d724 1
a724 1
      lookup->fill = 0;
d2316 6
a2321 1
  fprintf (config.map_file, " FILL mask 0x%x\n", fill->fill);
d2450 1
a2450 1
  minfo ("0x%V %W", addr, s->size);
d2452 7
a2458 2
  if (s->fill != 0)
    minfo (" %u", s->fill);
d2649 1
a2649 1
     fill_type fill;
d2654 1
d2675 2
d2690 1
a2690 1
     fill_type fill;
d2847 1
a2847 1
     fill_type fill;
d3223 1
a3223 1
     fill_type fill;
d3258 1
a3258 1
     fill_type fill;
d4227 1
a4227 1
			       (fill_type) 0, (bfd_vma) 0);
d4251 1
a4251 1
		       (fill_type) 0, (bfd_vma) 0);
d4367 2
a4368 2
lang_add_fill (exp)
     int exp;
d4373 1
a4373 1
  new->fill = exp;
d4460 1
a4460 1
     bfd_vma fill;
d4838 1
a4838 1
     bfd_vma fill;
d4880 1
a4880 1
     bfd_vma fill;
d4910 1
a4910 1
      if (fill != 0 && l->os->fill == 0)
@


1.73
log
@	* ldlex.l (DATA_SEGMENT_ALIGN, DATA_SEGMENT_END): New tokens.
	* ldgram.y (DATA_SEGMENT_ALIGN, DATA_SEGMENT_END): New tokens.
	(exp): Add DATA_SEGMENT_ALIGN (exp, exp) and DATA_SEGMENT_END (exp).
	* ldexp.c (exp_data_seg): New variable.
	(exp_print_token): Handle DATA_SEGMENT_ALIGN and DATA_SEGMENT_END.
	(fold_binary): Handle DATA_SEGMENT_ALIGN.
	(exp_fold_tree): Handle DATA_SEGMENT_END.
	Pass allocation_done when recursing instead of hardcoding
	lang_allocating_phase_enum.
	* ldexp.h (exp_data_seg): New.
	* ldlang.c (lang_size_sections_1): Renamed from lang_size_sections.
	(lang_size_sections): New.
	* ld.texinfo (DATA_SEGMENT_ALIGN, DATA_SEGMENT_END): Document.
	* scripttempl/elf.sc: Use DATA_SEGMENT_ALIGN and DATA_SEGMENT_END
	if COMMONPAGESIZE is defined.
	* emulparams/elf_i386.sh (COMMONPAGESIZE): Set to 4K.
	* emulparams/elf32_sparc.sh (COMMONPAGESIZE): Set to 8K.
	* emulparams/elf64_sparc.sh (COMMONPAGESIZE): Set to 8K.
	* emulparams/elf64alpha.sh (COMMONPAGESIZE): Set to 8K.
	* emulparams/elf64_ia64.sh (COMMONPAGESIZE): Set to 16K for shared
	libraries only.
@
text
@d5023 1
a5023 1
lang_new_vers_regex (orig, new, lang)
d5196 1
a5196 1
	  greg = lang_new_vers_regex (greg, p, NULL);
d5207 1
a5207 1
  lreg = lang_new_vers_regex (NULL, "*", NULL);
@


1.72
log
@	* ldlang.c (entry_section): New initialised variable.
	(lang_finish): Use it.
	* ldlang.h (entry_section): Declare.
	* emultempl/ppc64elf.em (gld${EMULATION_NAME}_finish): Set
	entry_section to ".opd".
@
text
@d153 3
d2829 2
a2830 2
bfd_vma
lang_size_sections (s, output_section_statement, prev, fill, dot, relax)
d2955 2
a2956 2
	    lang_size_sections (os->children.head, os, &os->children.head,
				os->fill, dot, relax);
d3024 4
a3027 4
	  dot = lang_size_sections (constructor_list.head,
				    output_section_statement,
				    &s->wild_statement.children.head,
				    fill, dot, relax);
d3088 4
a3091 4
	  dot = lang_size_sections (s->wild_statement.children.head,
				    output_section_statement,
				    &s->wild_statement.children.head,
				    fill, dot, relax);
d3186 4
a3189 4
	  dot = lang_size_sections (s->group_statement.children.head,
				    output_section_statement,
				    &s->group_statement.children.head,
				    fill, dot, relax);
d3203 36
@


1.71
log
@	* ldlang.c (lang_reset_memory_regions): Rename from
	reset_memory_regions.  Change all callers.  Make public.
	* ldlang.h (lang_reset_memory_regions): Prototype.
	* emultempl/elf32.em (gld${EMULATION_NAME}_finish): Call
	lang_reset_memory_regions before lang_size_sections.
@
text
@d181 1
d3469 1
a3469 1
	  ts = bfd_get_section_by_name (output_bfd, ".text");
@


1.71.2.1
log
@	* ldlang.c (entry_section): New initialised variable.
	(lang_finish): Use it.
	* ldlang.h (entry_section): Declare.
	* emultempl/ppc64elf.em (gld${EMULATION_NAME}_finish): Set
	entry_section to ".opd".
@
text
@a180 1
const char *entry_section = ".text";
d3468 1
a3468 1
	  ts = bfd_get_section_by_name (output_bfd, entry_section);
@


1.71.2.2
log
@	* ld.texinfo (VERSION scripts):  Symbol names are globbing patterns.
	* ldgram.y (lang_new_vers_regex):  Rename to lang_new_vers_pattern;
	the pattern in question is not a regexp.
	* ldlang.c:  Likewise.
	* ldlang.h:  Likewise.
	* ldlex.l (V_IDENTIFIER):  Allow '[', ']', '-', '!', and '^' also.
@
text
@d4984 1
a4984 1
lang_new_vers_pattern (orig, new, lang)
d5157 1
a5157 1
	  greg = lang_new_vers_pattern (greg, p, NULL);
d5168 1
a5168 1
  lreg = lang_new_vers_pattern (NULL, "*", NULL);
@


1.71.2.3
log
@	Merge from mainline.
	2002-03-21  Albert Chin-A-Young  <china@@thewrittenword.com>
	* genscripts.sh (LIB_SEARCH_DIRS): Quote path.

	2002-03-20  Alan Modra  <amodra@@bigpond.net.au>
	* ldlang.c (ldlang_add_undef): If the output bfd has been opened,
	add the symbol to the linker hash table immediately.
	(lang_place_undefineds): Split symbol creation out..
	(insert_undefined): ..to here.

	2002-03-18  Alan Modra  <amodra@@bigpond.net.au>
	* ldmain.c (main): Move .text readonly flag fudges from here..
	* ldlang.c (lang_process): ..to here.

	2002-03-14  Alan Modra  <amodra@@bigpond.net.au>
	* ldlang.c (lang_check): Remove the word size check added in last
	change.  Treat emitrelocations case as for relocatable links.

	2002-03-13  Alan Modra  <amodra@@bigpond.net.au>
	* ldlang.c (lang_check): Do relocatable link checks first, so that
	warn_mismatch can't override.  Check compatible and word size too.

	2002-03-04  H.J. Lu <hjl@@gnu.org>
	* scripttempl/elf.sc: Put .preinit_array, .init_array and
	.fini_array in the data segment.

	2002-03-04  Alan Modra  <amodra@@bigpond.net.au>
	* scripttempl/elf.sc: Correct syntax errors in 2002-03-01 commit.

	2002-03-01  David Mosberger  <davidm@@hpl.hp.com>
	* scripttempl/elf.sc (SECTIONS): Add entries for .preinit_array,
	.init_array, and .fini_array.
@
text
@a94 1
static void insert_undefined PARAMS ((const char *));
d2010 1
a2010 5
   This is a two step process as the symbol table doesn't even exist at
   the time the ld command line is processed.  First we put the name
   on a list, then, once the output file has been opened, transfer the
   name to the symbol table.  */

a2030 22

  if (output_bfd != NULL)
    insert_undefined (new->name);
}

/* Insert NAME as undefined in the symbol table.  */

static void
insert_undefined (name)
     const char *name;
{
  struct bfd_link_hash_entry *h;

  h = bfd_link_hash_lookup (link_info.hash, name, true, false, true);
  if (h == (struct bfd_link_hash_entry *) NULL)
    einfo (_("%P%F: bfd_link_hash_lookup failed: %E\n"));
  if (h->type == bfd_link_hash_new)
    {
      h->type = bfd_link_hash_undefined;
      h->u.undef.abfd = NULL;
      bfd_link_add_undef (link_info.hash, h);
    }
d2046 11
a2056 1
      insert_undefined (ptr->name);
d3520 2
a3521 19
      compatible = bfd_arch_get_compatible (input_bfd, output_bfd);

      /* In general it is not possible to perform a relocatable
	 link between differing object formats when the input
	 file has relocations, because the relocations in the
	 input format may not have equivalent representations in
	 the output format (and besides BFD does not translate
	 relocs for other link purposes than a final link).  */
      if ((link_info.relocateable || link_info.emitrelocations)
	  && (compatible == NULL
	      || bfd_get_flavour (input_bfd) != bfd_get_flavour (output_bfd))
	  && (bfd_get_file_flags (input_bfd) & HAS_RELOC) != 0)
	{
	  einfo (_("%P%F: Relocatable linking with relocations from format %s (%B) to format %s (%B) is not supported\n"),
		 bfd_get_target (input_bfd), input_bfd,
		 bfd_get_target (output_bfd), output_bfd);
	  /* einfo with %F exits.  */
	}

d3529 12
a4143 16
  if (! link_info.relocateable)
    {
      /* Look for a text section and set the readonly attribute in it.  */
      asection *found = bfd_get_section_by_name (output_bfd, ".text");

      if (found != (asection *) NULL)
	{
	  if (config.text_read_only)
	    found->flags |= SEC_READONLY;
	  else
	    found->flags &= ~SEC_READONLY;
	}
    }

  /* Do anything special before sizing sections.  This is where ELF
     and other back-ends size dynamic sections.  */
@


1.71.2.4
log
@	Merge from mainline
	2002-04-08  Alan Modra  <amodra@@bigpond.net.au>
	* ldlang.c (lang_size_sections): Don't complain about
	SEC_NEVER_LOAD sections having no memory region specified.
	* ld.texinfo (Format Commands <OUTPUT_FORMAT>): Typo fix.

	2002-04-07  matthew green  <mrg@@redhat.com>
	* ld/configure.host (*-*-netbsd*): Add support for NetBSD/ELF.

	2002-02-19  Martin Schwidefsky  <schwidefsky@@de.ibm.com>
	* emulparams/elf64_s390.sh (ARCH): Change to "s390:64-bit".
	* emulparams/elf_s390.sh (ARCH): Change to "s390:31-bit".
@
text
@a2916 2
			&& (bfd_get_section_flags (output_bfd, os->bfd_section)
			    & SEC_NEVER_LOAD) == 0
@


1.71.2.5
log
@	* ldlang.c (print_wild_statement): Fix output formatting.
@
text
@d2495 1
a2495 1
	  minfo ("EXCLUDE_FILE(%s", sec->spec.exclude_name_list->name);
d2497 2
a2498 2
	    minfo (" %s", tmp->name);
	  minfo (") ");
a2505 2
      if (sec->next)
	minfo (" ");
@


1.70
log
@* ldlang.c (walk_wild_section): Exclude object file if enclosing
archive is excluded.
@
text
@a134 1
static void reset_memory_regions PARAMS ((void));
d3974 2
a3975 2
static void
reset_memory_regions ()
d4162 1
a4162 1
	  reset_memory_regions ();
@


1.69
log
@	* ldgram.y (vers_node): Support anonymous version tags.
	* ldlang.c (lang_register_vers_node): Ensure anonymous version
	tag is not defined together with non-anonymous versions.
	* ld.texinfo: Document it.

	* elflink.h (size_dynamic_sections): Skip anonymous version tag.
	(elf_link_assign_sym_version): Don't count anonymous version tag.
@
text
@d3 1
a3 1
   2001
d272 15
@


1.68
log
@	* ldlang.c (map_input_to_output_sections): Replace "break"
	accidentally removed with 2001-08-03 change.
	(lang_gc_sections_1): Likewise.
@
text
@d5034 10
d5080 7
a5086 2
  ++version_index;
  version->vernum = version_index;
@


1.67
log
@	* ldlang.c (walk_wild_section): Move sec == NULL case out of loop.
@
text
@d2059 1
d4014 1
@


1.66
log
@	* ldlang.c (lang_size_sections): Keep a valid output_offset field
	for padding statements.
@
text
@d254 4
a257 1
      do
d260 16
d277 1
a277 1
	  if (sec != NULL)
d279 1
a279 1
	      struct name_list *list_tmp;
d281 4
a284 24
	      /* Don't process sections from files which were
		 excluded.  */
	      for (list_tmp = sec->spec.exclude_name_list;
		   list_tmp;
		   list_tmp = list_tmp->next)
		{
		  if (wildcardp (list_tmp->name))
		    skip = fnmatch (list_tmp->name, file->filename, 0) == 0;
		  else
		    skip = strcmp (list_tmp->name, file->filename) == 0;

		  if (skip)
		    break;
		}

	      if (!skip && sec->spec.name != NULL)
		{
		  const char *sname = bfd_get_section_name (file->the_bfd, s);

		  if (wildcardp (sec->spec.name))
		    skip = fnmatch (sec->spec.name, sname, 0) != 0;
		  else
		    skip = strcmp (sec->spec.name, sname) != 0;
		}
d290 1
a290 2
	  if (sec != NULL)
	    sec = sec->next;
a291 1
      while (sec != NULL);
@


1.65
log
@	* ldlang.c: Fix a comment typo.
@
text
@d3159 8
@


1.64
log
@From John Reiser <jreiser@@BitWagon.com>
	* ldlang.c (lang_common): Conditionally inhibit Common allocation.
	* lexsup.c: Add --no-define-common commandline option.
	* ldgram.y: Add INHIBIT_COMMON_ALLOCATION script command.
	* ldlex.l: Likewise.
	* ld.h: Add command_line.inhibit_common_definition.
	* ldmain.c (main): Initialize.
	* ld.texinfo: Document.
@
text
@d1075 1
a1075 1
   be enough to cause the the pattern to be treated as a wildcard.
@


1.63
log
@	* section.c (struct sec): Remove kept_section.
	(STD_SECTION): Remove kept_section initialisation.
	(bfd_make_section_anyway): Here too.
	* ecoff.c (bfd_debug_section): Remove kept_section initialisation.
	* cofflink.c (_bfd_coff_link_input_bfd): Don't test kept_section.
	* elflink.h (elf_link_input_bfd): Set discarded link-once section
	symbols to zero, and remove all code involved with kept_section
	and tracking section symbol values.
	* bfd-in2.h: Regenerate.
	* configure.in: Bump version number.
	* configure: Regenerate.

	* ldlang.c (section_already_linked): Remove assignment to kept_section.
@
text
@d3553 2
@


1.62
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d1016 1
a1016 3
	     section.  Since there might be a symbol in the section
	     being discarded, we must retain a pointer to the section
	     which we are really going to use.  */
a1017 1
	  sec->kept_section = l->sec;
@


1.61
log
@	* ldlang.c (insert_pad): Fix typos in last patch.
@
text
@d26 1
a42 2
#include <ctype.h>

d1620 1
a1620 6
    {
      if (isupper ((unsigned char) c))
	c = tolower (c);

      *dest++ = c;
    }
d4783 1
a4783 1
    if (isalnum ((unsigned char) *s1) || *s1 == '_')
@


1.60
log
@	* ldlang.c: When traversing lang_statement_union_type lists,
	consistently use "header.next" rather than "next".
	* mpw-eppcmac.c: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/pe.em: Likewise.
	* ldlang.h (union lang_statement_union): Remove "next" field.
@
text
@d2640 1
a2640 1
	 ((char *) ptr - offsetof (lang_statement_union_type *, header.next)));
d2642 1
a2642 1
      && pad->header.type == lang_padding_statement_enum)
@


1.59
log
@	* ldlang.c (insert_pad): Use offsetof macro.
	(lang_size_sections): Always neuter padding statements.
	* emultempl/hppaelf.em (hppaelf_delete_padding_statements): Delete.
@
text
@d380 1
a380 1
  for (; s != (lang_statement_union_type *) NULL; s = s->next)
d1262 1
a1262 1
  for (l = wild->children.head; l != NULL; l = l->next)
d1392 1
a1392 1
	  ASSERT (list.head->next == NULL);
d1396 1
a1396 1
	       pp = &(*pp)->next)
d1399 1
a1399 1
	  list.head->next = *pp;
d1909 1
a1909 1
  for (; s != (lang_statement_union_type *) NULL; s = s->next)
d1970 2
a1971 2
		  *add.tail = s->next;
		  s->next = add.head;
d2065 1
a2065 1
  for (; s != (lang_statement_union_type *) NULL; s = s->next)
d2516 1
a2516 1
      s = s->next;
d2622 1
a2622 1
	  s = s->next;
d2835 1
a2835 1
  for (; s != (lang_statement_union_type *) NULL; s = s->next)
d2858 1
a2858 1
		    || os->children.head->next != NULL
d3200 1
a3200 1
  for (; s != (lang_statement_union_type *) NULL; s = s->next)
d4009 1
a4009 1
  for (; s != (lang_statement_union_type *) NULL; s = s->next)
@


1.58
log
@	* ldlang.c (insert_pad): Make use of an existing pad statement if
	available.  Move code calculating alignment, adjusting section
	alignment power, and adjusting dot to ..
	(size_input_section): .. here.  Remove unused relax param.
	(lang_size_sections): Change boolean `relax' param to boolean *.
	Adjust call to size_input_section.  Make use of insert_pad to
	place pad after the assignment statement.  If relaxing, zap
	padding statements.
	(reset_memory_regions): Reset output_bfd section sizes too.
	(relax_again): Move to..
	(lang_process): ..here.  Adjust call to lang_size_sections, and
	remove duplicated code.
	* ldlang.h (lang_size_sections): Change `relax' param to boolean *.
@
text
@a2637 1
  size_t ptr_off;
d2639 2
a2640 4
  /* ptr_off is zero, but let's not be too fast and loose with
     pointers.  */
  ptr_off = ((char *) &((lang_statement_union_type *) 0)->header.next
	     - (char *) 0);
d2642 1
a2642 2
      && ((pad = (lang_statement_union_type *) ((char *) ptr - ptr_off))
	  ->header.type == lang_padding_statement_enum)
d3162 6
a3167 12
	  if (relax)
	    {
	      /* If we are relaxing, and this is not the first pass,
		 we need to allow padding to shrink.  If padding is
		 needed on this pass, it will be added back in.  */
	      s->padding_statement.size = 0;
	      break;
	    }

	  dot += s->padding_statement.size / opb;
	  output_section_statement->bfd_section->_raw_size +=
	    s->padding_statement.size;
d3181 1
a3181 2
	  /* This can only get here when relaxing is turned on.  */

@


1.57
log
@(wild_doit): Rename to lang_add_section.
@
text
@d122 1
a122 1
static bfd_vma insert_pad
d127 1
a127 1
	   fill_type, bfd_vma, boolean));
d2629 3
a2631 3
static bfd_vma
insert_pad (this_ptr, fill, power, output_section_statement, dot)
     lang_statement_union_type **this_ptr;
d2633 2
a2634 2
     unsigned int power;
     asection *output_section_statement;
d2637 2
a2638 6
  /* Align this section first to the
     input sections requirement, then
     to the output section's requirement.
     If this alignment is > than any seen before,
     then record it too. Perform the alignment by
     inserting a magic 'padding' statement.  */
d2640 8
a2647 5
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture,
						ldfile_output_machine);
  unsigned int alignment_needed = align_power (dot, power) - dot;

  if (alignment_needed != 0)
d2649 2
a2650 13
      lang_statement_union_type *new =
	((lang_statement_union_type *)
	 stat_alloc (sizeof (lang_padding_statement_type)));

      /* Link into existing chain.  */
      new->header.next = *this_ptr;
      *this_ptr = new;
      new->header.type = lang_padding_statement_enum;
      new->padding_statement.output_section = output_section_statement;
      new->padding_statement.output_offset =
	dot - output_section_statement->vma;
      new->padding_statement.fill = fill;
      new->padding_statement.size = alignment_needed * opb;
d2652 1
a2652 3

  /* Remember the most restrictive alignment.  */
  if (power > output_section_statement->alignment_power)
d2654 12
a2665 5
      output_section_statement->alignment_power = power;
    }
  output_section_statement->_raw_size += alignment_needed * opb;

  return dot + alignment_needed;
d2671 1
a2671 1
size_input_section (this_ptr, output_section_statement, fill, dot, relax)
a2675 1
     boolean relax ATTRIBUTE_UNUSED;
a2678 2
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture,
						ldfile_output_machine);
d2682 10
d2693 5
a2697 2
       i->alignment_power =
	output_section_statement->subsection_alignment;
d2699 7
a2705 2
      dot = insert_pad (this_ptr, fill, i->alignment_power,
			output_section_statement->bfd_section, dot);
d2709 1
a2709 1
      i->output_offset = dot - output_section_statement->bfd_section->vma;
d2716 1
a2716 2
      output_section_statement->bfd_section->_raw_size =
	(dot - output_section_statement->bfd_section->vma) * opb;
a2786 5
/* This variable indicates whether bfd_relax_section should be called
   again.  */

static boolean relax_again;

d2833 1
a2833 1
     boolean relax;
d2952 2
a2953 3
	    (void) lang_size_sections (os->children.head, os,
				       &os->children.head,
				       os->fill, dot, relax);
d3024 1
a3024 2
				    fill,
				    dot, relax);
d3116 1
a3116 1
		  relax_again = true;
d3118 2
a3119 4
	    dot = size_input_section (prev,
				      output_section_statement,
				      output_section_statement->fill,
				      dot, relax);
a3141 1
		/* The assignment changed dot.  Insert a pad.  */
d3148 1
a3148 1
		else if (!relax)
d3150 8
a3157 16
		    lang_statement_union_type *new =
		      ((lang_statement_union_type *)
		       stat_alloc (sizeof (lang_padding_statement_type)));

		    /* Link into existing chain.  */
		    new->header.next = *prev;
		    *prev = new;
		    new->header.type = lang_padding_statement_enum;
		    new->padding_statement.output_section =
		      output_section_statement->bfd_section;
		    new->padding_statement.output_offset =
		      dot - output_section_statement->bfd_section->vma;
		    new->padding_statement.fill = fill;
		    new->padding_statement.size = (newdot - dot) * opb;
		    output_section_statement->bfd_section->_raw_size +=
		      new->padding_statement.size;
d3166 9
a3174 7
	  /* If we are relaxing, and this is not the first pass, some
	     padding statements may have been inserted during previous
	     passes.  We may have to move the padding statement to a new
	     location if dot has a different value at this point in this
	     pass than it did at this point in the previous pass.  */
	  s->padding_statement.output_offset =
	    dot - output_section_statement->bfd_section->vma;
d3976 1
d3985 3
d4146 5
d4154 2
a4155 5
      /* First time round is a trial run to get the 'worst case'
	 addresses of the objects if there was no relaxing.  */
      lang_size_sections (statement_list.head,
			  abs_output_section,
			  &(statement_list.head), 0, (bfd_vma) 0, false);
a4156 1
      /* Keep relaxing until bfd_relax_section gives up.  */
d4177 2
a4178 1
			      &(statement_list.head), 0, (bfd_vma) 0, true);
a4180 7
    }
  else
    {
      /* Size up the sections.  */
      lang_size_sections (statement_list.head,
			  abs_output_section,
			  &(statement_list.head), 0, (bfd_vma) 0, false);
@


1.56
log
@	* ld.texinfo (Input Section Basics): Clarify ordering of output
	sections.
	* ldlang.c (callback_t): Add wildcard_list param.
	(walk_wild_section): Remove "section" param.  Rewrite for
	lang_wild_statement_type change.  Remove unique_section_p test.
	(walk_wild_file): Remove "section" param.
	(walk_wild): Remove "section" and "file" params.
	(lang_gc_wild): Likewise.
	(wild): Likewise.  Modify for lang_wild_statement_type change.
	(wild_sort): Likewise.  Add "sec" param.
	(gc_section_callback): Likewise.
	(output_section_callback): Likewise.  Do unique_section_p test.
	(map_input_to_output_sections): Modify call to wild.
	(lang_gc_sections_1): Likewise.
	(print_wild_statement): Modify for lang_wild_statement_type
	change.
	(lang_add_wild): Replace filename, filenames_sorted param with
	filespec.  Replace section_name, sections_sorted,
	exclude_filename_list with section_list.
	* ldlang.h (lang_add_wild): Here too.
	(lang_wild_statement_type): Replace section_name, sections_sorted,
	and exclude_filename_list with section_list.
	* ldgram.y (current_file): Delete.
	(%union): Add wildcard_list.
	(file_NAME_list): Set type to wildcard_list.  Build a linked list
	rather than calling lang_add_wild for each entry.
	(input_section_spec_no_keep): Call lang_add_wild here instead.
	* ld.h (struct wildcard_list): Declare.
	* mri.c (mri_draw_tree): Modify to suit new lang_add_wild.
@
text
@d1015 5
a1019 5
	  /* Set the output_section field so that wild_doit does not
	     create a lang_input_section structure for this section.
	     Since there might be a symbol in the section being
	     discarded, we must retain a pointer to the section which
	     we are really going to use.  */
d1101 1
a1101 1
wild_doit (ptr, section, output, file)
d1375 3
a1377 3
    wild_doit (&ptr->children, section,
	       (lang_output_section_statement_type *) output,
	       file);
d1384 3
a1386 3
      wild_doit (&list, section,
		 (lang_output_section_statement_type *) output,
		 file);
d3742 2
a3743 2
		      wild_doit (&default_common_section->children, s,
				 default_common_section, file);
d3750 1
a3750 2
		  lang_output_section_statement_type *os =
		  lang_output_section_statement_lookup (s->name);
d3752 2
a3753 1
		  wild_doit (&os->children, s, os, file);
@


1.55
log
@If a region is specified assign it to all sections inside the overlay unless    they have been assigned to the own, non-default, memory region.
@
text
@d81 2
a82 2
  PARAMS ((lang_wild_statement_type *, lang_input_statement_type *,
	   asection *));
d84 1
a84 1
  PARAMS ((lang_wild_statement_type *, asection *,
d90 1
a90 1
  PARAMS ((lang_wild_statement_type *, const char *, const char *,
d138 1
a138 1
  PARAMS ((lang_wild_statement_type *, asection *,
d141 1
a141 2
static void lang_gc_wild
  PARAMS ((lang_wild_statement_type *, const char *, const char *));
d157 3
a159 1
				    asection *, lang_input_statement_type *,
d162 1
a162 2
  PARAMS ((lang_wild_statement_type *, const char *, const char *,
	 callback_t, PTR));
d164 2
a165 2
  PARAMS ((lang_wild_statement_type *, const char *,
	   lang_input_statement_type *, callback_t, PTR));
d167 2
a168 2
  PARAMS ((lang_wild_statement_type *, const char *,
	   lang_input_statement_type *, callback_t, PTR));
d239 1
a239 1
walk_wild_section (ptr, section, file, callback, data)
a240 1
     const char *section;
d245 6
a250 2
  /* Don't process sections from files which were excluded.  */
  if (ptr->exclude_filename_list != NULL)
d252 4
a255 4
      struct name_list *list_tmp;
      for (list_tmp = ptr->exclude_filename_list;
	   list_tmp;
	   list_tmp = list_tmp->next)
d257 1
a257 1
	  boolean match;
d259 3
a261 4
	  if (wildcardp (list_tmp->name))
	    match = fnmatch (list_tmp->name, file->filename, 0) == 0;
	  else
	    match = strcmp (list_tmp->name, file->filename) == 0;
d263 10
a272 4
	  if (match)
	    return;
	}
    }
d274 3
a276 4
  if (file->just_syms_flag == false)
    {
      register asection *s;
      boolean wildcard = false;
d278 3
a280 2
      if (section != NULL)
	wildcard = wildcardp (section);
d282 6
a287 4
      for (s = file->the_bfd->sections; s != NULL; s = s->next)
	{
	  boolean match;
	  const char *sname = bfd_get_section_name (file->the_bfd, s);
d289 2
a290 6
	  if (section == NULL)
	    match = true;
	  else if (wildcard)
	    match = fnmatch (section, sname, 0) == 0;
	  else
	    match = strcmp (section, sname) == 0;
d292 2
a293 4
	  /* If this is a wild-card output section statement, exclude
	     sections that match UNIQUE_SECTION_LIST.  */
	  if (match && (data == NULL || !unique_section_p (sname)))
	    (*callback) (ptr, s, file, data);
d295 1
d302 1
a302 1
walk_wild_file (s, section, f, callback, data)
a303 1
     const char *section;
d310 1
a310 1
    walk_wild_section (s, section, f, callback, data);
d327 1
a327 1
	      walk_wild_section (s, section,
d338 1
a338 1
walk_wild (s, section, file, callback, data)
a339 2
     const char *section;
     const char *file;
d343 3
a345 1
  if (file == (char *) NULL)
d350 1
a350 1
	  walk_wild_file (s, section, f, callback, data);
d353 1
a353 1
  else if (wildcardp (file))
d357 2
a358 2
	  if (fnmatch (file, f->filename, FNM_FILE_NAME) == 0)
	    walk_wild_file (s, section, f, callback, data);
d366 1
a366 1
      f = lookup_name (file);
d368 1
a368 1
	walk_wild_file (s, section, f, callback, data);
d1249 1
a1249 1
wild_sort (wild, file, section)
d1251 1
d1258 1
a1258 1
  if (! wild->filenames_sorted && ! wild->sections_sorted)
d1332 1
a1332 1
      if (wild->sections_sorted)
d1349 1
a1349 1
output_section_callback (ptr, section, file, output)
d1351 1
d1358 4
d1367 1
a1367 1
  before = wild_sort (ptr, file, section);
d1570 5
a1574 4
/* Handle a wild statement.  SECTION or FILE or both may be NULL,
   indicating that it is a wildcard.  Separate lang_input_section
   statements are created for each part of the expansion; they are
   added after the wild statement S.  OUTPUT is the output section.  */
d1577 1
a1577 1
wild (s, section, file, target, output)
a1578 2
     const char *section;
     const char *file;
d1582 1
a1582 1
  walk_wild (s, section, file, output_section_callback, (PTR) output);
d1584 12
a1595 7
  if (section != (char *) NULL
      && strcmp (section, "COMMON") == 0
      && default_common_section == NULL)
    {
      /* Remember the section that common is going to in case we later
         get something which doesn't know where to put it.  */
      default_common_section = output;
a2068 1

d2070 1
a2070 5
	  wild (&s->wild_statement, s->wild_statement.section_name,
		s->wild_statement.filename, target,
		output_section_statement);

	  break;
d2453 2
a2458 8
  if (w->exclude_filename_list != NULL)
    {
      name_list *tmp;
      minfo ("EXCLUDE_FILE ( %s", w->exclude_filename_list->name);
      for (tmp = w->exclude_filename_list->next; tmp; tmp = tmp->next)
	minfo (", %s", tmp->name);
      minfo (")");
    }
d2467 19
a2485 8
  if (w->sections_sorted)
    minfo ("SORT(");
  if (w->section_name != NULL)
    minfo ("%s", w->section_name);
  else
    minfo ("*");
  if (w->sections_sorted)
    minfo (")");
d3995 2
a3996 2
/* Expand a wild statement for a particular FILE, marking its sections KEEP
   as needed.  SECTION may be NULL, in which case it is a wild card.  */
d3999 1
a3999 1
gc_section_callback (ptr, section, file, data)
d4001 1
a4005 2
  /* If the wild pattern was marked KEEP, the member sections
     should be as well.  */
d4010 1
a4010 2
/* Handle a wild statement, marking it against GC.  SECTION or FILE or both
   may be NULL, indicating that it is a wildcard.  */
d4013 1
a4013 1
lang_gc_wild (s, section, file)
a4014 2
     const char *section;
     const char *file;
d4016 1
a4016 1
  walk_wild (s, section, file, gc_section_callback, NULL);
d4030 1
a4030 4
	  lang_gc_wild (&s->wild_statement,
			s->wild_statement.section_name,
			s->wild_statement.filename);
	  break;
d4221 3
a4223 6
lang_add_wild (section_name, sections_sorted, filename, filenames_sorted,
	       keep_sections, exclude_filename_list)
     const char *const section_name;
     boolean sections_sorted;
     const char *const filename;
     boolean filenames_sorted;
a4224 1
     struct name_list *exclude_filename_list;
d4226 10
a4235 2
  lang_wild_statement_type *new = new_stat (lang_wild_statement,
					    stat_ptr);
d4237 5
a4241 1
  if (section_name != (char *) NULL && strcmp (section_name, "COMMON") == 0)
d4243 4
a4246 1
      placed_commons = true;
d4248 5
a4252 1
  if (filename != NULL && ! wildcardp (filename))
d4254 2
a4255 1
      lang_has_input_file = true;
d4257 1
a4257 4
  new->section_name = section_name;
  new->sections_sorted = sections_sorted;
  new->filename = filename;
  new->filenames_sorted = filenames_sorted;
a4258 1
  new->exclude_filename_list = exclude_filename_list;
@


1.54
log
@	* ldlang.c (lang_check): Emit fatal error if relocatable link
	between different object flavours with relocations in input.
@
text
@d4821 1
d4826 2
d4847 7
a4853 1
      if (region != NULL && l->os->region == NULL)
d4855 1
d4865 1
@


1.53
log
@2001-06-19  H.J. Lu <hjl@@gnu.org>

	* ldlang.c (lang_check): Revert the change mode on 2001-06-15.
@
text
@d3523 12
@


1.52
log
@2001-06-18  H.J. Lu  <hjl@@gnu.org>

	* ldlang.c (init_os): Add the newline to the einfo call.
	(lang_check): Likewise.
	(lang_do_version_exports_section): Likewise.
@
text
@a3522 5
      else if (link_info.relocateable
	       && bfd_get_flavour (input_bfd) != bfd_get_flavour (output_bfd))
	einfo (_("%P%F: Relocatable linking from format %s (%B) to format %s (%B) is not supported\n"),
	       bfd_get_target (input_bfd), input_bfd,
	       bfd_get_target (output_bfd), output_bfd);
@


1.51
log
@	* ldlang.c (lang_check): Emit fatal error if relocatable link
	between different object flavours.
@
text
@d817 1
a817 1
    einfo (_("%P%F: Illegal use of `%s' section"), DISCARD_SECTION_NAME);
d3525 1
a3525 1
	einfo (_("%P%F: Relocatable linking from format %s (%B) to format %s (%B) is not supported"),
d5106 1
a5106 1
	einfo (_("%X%P: unable to read .exports section contents"), sec);
@


1.50
log
@Chnage load_symbols() to a boolean function
@
text
@d3523 5
@


1.49
log
@	* ldlang.c (record_bfd_errors): Remove.

	* emultempl/aix.em: Fix copyright dates.
@
text
@d87 1
a87 1
static void load_symbols
d363 2
a364 1
      walk_wild_file (s, section, f, callback, data);
d1429 2
a1430 1
  load_symbols (search, (lang_statement_list_type *) NULL);
d1437 1
a1437 1
static void
d1445 1
a1445 1
    return;
d1454 2
a1455 1

d1460 1
a1460 1
	return;
d1474 4
a1477 2
	einfo (_("%F%B: file not recognized: %E\n"), entry->the_bfd);

d1494 1
a1494 1
      return;
d1498 1
a1498 1
    return;
d1518 4
a1521 3
	  bfd *member = bfd_openr_next_archived_file (entry->the_bfd,
						      (bfd *) NULL);
	  while (member != NULL)
d1523 5
d1529 6
a1534 2
		einfo (_("%F%B: object %B in archive is not object\n"),
		       entry->the_bfd, member);
d1538 1
d1540 4
a1543 3
		einfo (_("%F%B: could not read symbols: %E\n"), member);
	      member = bfd_openr_next_archived_file (entry->the_bfd,
						     member);
d1546 2
a1547 3
	  entry->loaded = true;

	  return;
d1549 1
d1552 3
a1554 1
  if (! bfd_link_add_symbols (entry->the_bfd, &link_info))
d1557 1
a1557 1
  entry->loaded = true;
d1951 2
a1952 1
	      load_symbols (&s->input_statement, &add);
@


1.48
log
@2001-05-31  H.J. Lu  <hjl@@gnu.org>

	* ldlang.c (open_input_bfds): Don't change the bfd error
	handler whilst loading symbols.
@
text
@a129 1
static void record_bfd_errors PARAMS ((const char *, ...));
a3462 47

/* This is the routine to handle BFD error messages.  */

#ifdef ANSI_PROTOTYPES

static void
record_bfd_errors (const char *s, ...)
{
  va_list p;

  einfo ("%P: ");

  va_start (p, s);

  vfprintf (stderr, s, p);

  va_end (p);

  fprintf (stderr, "\n");

  einfo ("%X");
}

#else /* ! defined (ANSI_PROTOTYPES) */

static void
record_bfd_errors (va_alist)
     va_dcl
{
  va_list p;
  const char *s;

  einfo ("%P: ");

  va_start (p);

  s = va_arg (p, const char *);
  vfprintf (stderr, s, p);

  va_end (p);

  fprintf (stderr, "\n");

  einfo ("%X");
}

#endif /* ! defined (ANSI_PROTOTYPES) */
@


1.47
log
@Add a flag to asection, linker_has_input, and use it to reliably
determine whether an input section is the first one assigned to
an output section.
@
text
@a1916 1
	      bfd_error_handler_type pfn;
a1932 5
	      /* We need to know if an error occurs whilst loading the
		 symbols, since this means that a valid executable can
		 not be produced.  */
	      pfn = bfd_set_error_handler (record_bfd_errors);

a1933 2

	      bfd_set_error_handler (pfn);
@


1.46
log
@	* merge.c (struct sec_merge_hash_entry): Add u.entsize and u.suffix
	fields, change sec into secinfo.
	(struct sec_merge_info): Add chain, remove last fields.
	(struct sec_merge_sec_info): Add next, sec, psecinfo fields.
	(sec_merge_hash_lookup): If lookup could not use a string only
	because it has bad alignment, mark the old string for deletion.
	(sec_merge_add): Add secinfo argument. Don't compute entry's
	position, instead record the section.
	(sec_merge_emit): Update for the sec into secinfo change in
	struct sec_merge_hash_entry.
	(_bfd_merge_section): Only record the section for merging, defer
	putting strings into the hash table.
	(cmplengthentry, last4_eq, last_eq, record_section, merge_strings,
	_bfd_merge_sections): New functions.
	(_bfd_merged_section_offset): Update for the sec_merge_hash_entry
	changes.
	* libbfd-in.h (_bfd_merge_sections): Add prototype.
	(_bfd_nolink_bfd_merge_sections): Define.
	* libbfd.h: Likewise.
	(bfd_generic_merge_sections): Add prototype.
	* targets.c (BFD_JUMP_TABLE_LINK): Add _bfd_merge_sections.
	(struct bfd_target): Likewise.
	* bfd.c (bfd_merge_sections): Define.
	* bfd-in2.h: Rebuilt.
	* elf.c (_bfd_elf_merge_sections): New function.
	* elf-bfd.h (_bfd_elf_merge_sections): Add prototype.
	* elfxx-target.h (bfd_elfNN_bfd_merge_sections): Define.
	* reloc.c (bfd_generic_merge_sections): New function.
	* vms.c (vms_bfd_merge_sections): New function.
	* aout-adobe.c (aout_32_bfd_merge_sections): Define.
	* aout-target.h (MY_bfd_merge_sections): Define.
	* aout-tic30.c (MY_bfd_merge_sections): Define.
	* binary.c (binary_bfd_merge_sections): Define.
	* bout.c (b_out_bfd_merge_sections): Define.
	* coff-alpha.c (_bfd_ecoff_bfd_merge_sections): Define.
	* coffcode.c (coff_bfd_merge_sections): Define.
	* coff-mips.c (_bfd_ecoff_bfd_merge_sections): Define.
	* i386msdos.c (msdos_bfd_merge_sections): Define.
	* i386os9k.c (os9k_bfd_merge_sections): Define.
	* ieee.c (ieee_bfd_merge_sections): Define.
	* ihex.c (ihex_bfd_merge_sections): Define.
	* nlm-target.h (nlm_bfd_merge_sections): Define.
	* oasys.c (oasys_bfd_merge_sections): Define.
	* ppcboot.c (ppcboot_bfd_merge_sections): Define.
	* som.c (som_bfd_merge_sections): Define.
	* srec.c (srec_bfd_merge_sections): Define.
	* tekhex.c (tekhex_bfd_merge_sections): Define.
	* versados.c (versados_bfd_merge_sections): Define.
	* xcoff-target.h (_bfd_xcoff_bfd_merge_sections): Define.

	* ldlang.c (lang_process): Call bfd_merge_sections.
@
text
@d45 2
a46 3
static lang_statement_union_type *new_statement PARAMS ((enum statement_enum,
							 size_t,
							 lang_statement_list_type *));
d194 1
a194 1
#if defined(__STDC__) || defined(ALMOST_STDC)
d200 4
a203 2
/* Don't beautify the line below with "innocent" whitespace, it breaks the K&R C preprocessor!  */
#define new_stat(x, y) (cat (x,_type)*) new_statement (cat (x,_enum), sizeof (cat (x,_type)), y)
d205 2
a206 1
#define outside_section_address(q) ((q)->output_offset + (q)->output_section->vma)
d208 2
a209 1
#define outside_symbol_address(q) ((q)->value + outside_section_address (q->section))
d251 3
a253 1
      for (list_tmp = ptr->exclude_filename_list; list_tmp; list_tmp = list_tmp->next)
d258 1
a258 1
	    match = fnmatch (list_tmp->name, file->filename, 0) == 0 ? true : false;
d260 1
a260 1
	    match = strcmp (list_tmp->name, file->filename) == 0 ? true : false;
d283 1
a283 1
	    match = fnmatch (section, sname, 0) == 0 ? true : false;
d285 1
a285 1
	    match = strcmp (section, sname) == 0 ? true : false;
d458 1
a458 1
   foo.o(.data) etc, so when asked for a file we check that we havn't
d1144 4
a1147 6
	{
	  init_os (output);
	  first = true;
	}
      else
	first = false;
d1696 2
a1697 1
  if (name_compare (target->name, original->name) > name_compare (winner->name, original->name))
d1793 2
a1794 1
		  (void) bfd_search_for_target (closest_target_match, (PTR) target);
d1932 1
a1932 1
	      lang_list_init (& add);
d1934 1
a1934 1
	      /* We need to know if an error occurs whilst loading the 
d2695 2
a2696 1
  (((bfd_get_section_flags (bfd, s) & (SEC_ALLOC | SEC_LOAD)) != (SEC_ALLOC | SEC_LOAD)) \
d2698 1
a2708 1

d2819 1
a2819 1
	    lang_output_section_statement_type *os = &s->output_section_statement;
d2821 1
d2876 2
a2877 1
			&& (strcmp (lang_memory_region_list->name, "*default*") != 0
d2880 2
a2881 1
			     bfd_get_section_name (output_bfd, os->bfd_section));
d2890 2
a2891 1
			dot = align_power (dot, os->bfd_section->alignment_power);
d3208 1
a3208 2
	    lang_output_section_statement_type *os =
	      &(s->output_section_statement);
d3210 1
d3383 4
a3386 2
          unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture,
							ldfile_output_machine);
a3472 1

d3519 1
d4272 1
a4272 1
  lang_address_statement_type *ad = new_stat (lang_address_statement, stat_ptr);
d4274 1
d4667 1
a4667 3
			     l->flags == NULL ? false : true,
			     flags,
			     l->at == NULL ? false : true,
@


1.45
log
@2001-05-02  H.J. Lu  <hjl@@gnu.org>

	* ldfile.c: Include "libiberty.h".
	* ldlex.l: Likewise.

	* ldmisc.c (buystring): Removed.
	* ldmisc.h: Likewise.

	* ldfile.c: Replace buystring with xstrdup.
	* ldlang.c: Likewise.
	* ldlex.l: Likewise.
	* ldmain.c: Likewise.
	* ldmisc.c: Likewise.
	* lexsup.c: Likewise.
	* mpw-eppcmac.c: Likewise.
@
text
@d4133 6
@


1.44
log
@Give emulation a chance to process unrecognized file before fatal error is
reported, not after.
@
text
@d626 1
a626 1
    new->name = buystring (name);
d1997 1
a1997 1
  new->name = buystring (name);
@


1.43
log
@bfd/
	* libbfd-in.h (_bfd_merge_section): New.
	(_bfd_write_merged_section): New.
	(_bfd_merged_section_offset): New.
	* libbfd.h: Rebuilt.
	* linker.c (_bfd_generic_link_output_symbols): Handle
	discard_sec_merge.
	* aoutx.h (aout_link_write_symbols): Likewise.
	* pdp11.c (aout_link_write_symbols): Likewise.
	* elflink.h (elf_link_add_object_symbols): Call _bfd_merge_section.
	(elf_bfd_final_link): Adjust global symbols pointing into SEC_MERGE
	sections.
	(elf_link_sec_merge_syms): New.
	(elf_link_input_bfd): Call _bfd_merged_section_offset
	and _bfd_write_merged_section.
	Handle discard_sec_merge.
	* elf-bfd.h (struct elf_link_hash_table): Add merge_info
	field.
	(struct bfd_elf_section_data): Likewise.
	* elf.c (_bfd_elf_make_section_from_shdr): Set SEC_MERGE and
	SEC_STRINGS section flags and entsize from their ELF counterparts.
	(_bfd_elf_link_hash_table_init): Initialize merge_info.
	(elf_fake_sections): Set SHF_MERGE, SHF_STRINGS and sh_entsize
	from their BFD counterparts.
	* merge.c: New file.
	* Makefile.am: Add strtab.lo.
	* Makefile.in: Rebuilt.
include/
	* bfdlink.h (bfd_link_discard): Add discard_sec_merge.
gas/
	* config/obj-elf.c (obj_elf_change_section): Add entsize argument,
	handle SHF_MERGE and SHF_STRINGS.
	(obj_elf_parse_section_letters): Set SHF_MERGE and SHF_STRINGS.
	(obj_elf_section): Allow additional argument specifying entity size.
	* write.c (adjust_reloc_syms): Keep relocations against local symbols
	in SEC_MERGE sections.
ld/
	* ldmain.c (main): Default to discard_sec_merge.
	* lexsup.c (OPTION_DISCARD_NONE): Define.
	(ld_options): Add --discard-none.
	(parse_args): Handle OPTION_DISCARD_NONE.
	* ldlang.c (wild_doit): SEC_MERGE should be set in the output
	section only if SEC_MERGE and SEC_STRINGS flags and entsize of
	all its input sections match.
@
text
@d1452 5
a1473 5
      /* See if the emulation has some special knowledge.  */

      if (ldemul_unrecognized_file (entry))
	return;

a1474 1

@


1.42
log
@Fixtypos in ChangeLogs, fix copyright dates in files
@
text
@d1179 11
d1191 3
@


1.41
log
@BFD: Catch & report unhandled PE section flags.
LD: Catch BFD errors whilst loading symbols and do not produce an executable.
@
text
@d2 2
a3 1
   Copyright (C) 1991, 92, 93, 94, 95, 96, 97, 98, 99, 2000, 2001
a2678 1

d2688 1
@


1.40
log
@(lang_leave_overlay): Don't set lma_region when load_base is specified.
@
text
@d130 1
d1898 1
d1913 6
a1918 1
	      lang_list_init (&add);
d1922 2
d3447 47
@


1.40.2.1
log
@Merge from mainline.
@
text
@d2 1
a2 2
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001
d44 3
a46 2
static lang_statement_union_type *new_statement
  PARAMS ((enum statement_enum, size_t, lang_statement_list_type *));
a129 1
static void record_bfd_errors PARAMS ((const char *, ...));
d193 1
a193 1
#if defined (__STDC__) || defined (ALMOST_STDC)
d199 2
a200 4
/* Don't beautify the line below with "innocent" whitespace, it breaks
   the K&R C preprocessor!  */
#define new_stat(x, y) \
  (cat (x,_type)*) new_statement (cat (x,_enum), sizeof (cat (x,_type)), y)
d202 1
a202 2
#define outside_section_address(q) \
  ((q)->output_offset + (q)->output_section->vma)
d204 1
a204 2
#define outside_symbol_address(q) \
  ((q)->value + outside_section_address (q->section))
d246 1
a246 3
      for (list_tmp = ptr->exclude_filename_list;
	   list_tmp;
	   list_tmp = list_tmp->next)
d251 1
a251 1
	    match = fnmatch (list_tmp->name, file->filename, 0) == 0;
d253 1
a253 1
	    match = strcmp (list_tmp->name, file->filename) == 0;
d276 1
a276 1
	    match = fnmatch (section, sname, 0) == 0;
d278 1
a278 1
	    match = strcmp (section, sname) == 0;
d451 1
a451 1
   foo.o(.data) etc, so when asked for a file we check that we haven't
d624 1
a624 1
    new->name = xstrdup (name);
d1137 6
a1142 4
	init_os (output);

      first = ! output->bfd_section->linker_has_input;
      output->bfd_section->linker_has_input = 1;
a1435 5

      /* See if the emulation has some special knowledge.  */
      if (ldemul_unrecognized_file (entry))
	return;

d1453 5
d1459 1
d1678 1
a1678 2
  if (name_compare (target->name, original->name)
      > name_compare (winner->name, original->name))
d1774 1
a1774 2
		  (void) bfd_search_for_target (closest_target_match,
						(PTR) target);
a1896 1
	      bfd_error_handler_type pfn;
a1912 5
	      /* We need to know if an error occurs whilst loading the
		 symbols, since this means that a valid executable can
		 not be produced.  */
	      pfn = bfd_set_error_handler (record_bfd_errors);

a1914 2
	      bfd_set_error_handler (pfn);

d1974 1
a1974 1
  new->name = xstrdup (name);
d2667 1
a2667 2
  (((bfd_get_section_flags (bfd, s) & (SEC_ALLOC | SEC_LOAD))	\
    != (SEC_ALLOC | SEC_LOAD))					\
d2790 1
a2790 1
	    lang_output_section_statement_type *os;
a2791 1
	    os = &s->output_section_statement;
d2846 1
a2846 2
			&& (strcmp (lang_memory_region_list->name,
				    "*default*") != 0
d2849 1
a2849 2
			     bfd_get_section_name (output_bfd,
						   os->bfd_section));
d2858 1
a2858 2
			dot = align_power (dot,
					   os->bfd_section->alignment_power);
d3175 2
a3176 1
	    lang_output_section_statement_type *os;
a3177 1
	    os = &(s->output_section_statement);
d3350 2
a3351 4
          unsigned opb;

          opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture,
					       ldfile_output_machine);
a3437 47
/* This is the routine to handle BFD error messages.  */

#ifdef ANSI_PROTOTYPES

static void
record_bfd_errors (const char *s, ...)
{
  va_list p;

  einfo ("%P: ");

  va_start (p, s);

  vfprintf (stderr, s, p);

  va_end (p);

  fprintf (stderr, "\n");

  einfo ("%X");
}

#else /* ! defined (ANSI_PROTOTYPES) */

static void
record_bfd_errors (va_alist)
     va_dcl
{
  va_list p;
  const char *s;

  einfo ("%P: ");

  va_start (p);

  s = va_arg (p, const char *);
  vfprintf (stderr, s, p);

  va_end (p);

  fprintf (stderr, "\n");

  einfo ("%X");
}

#endif /* ! defined (ANSI_PROTOTYPES) */

d4184 1
a4184 1
  lang_address_statement_type *ad;
a4185 1
  ad = new_stat (lang_address_statement, stat_ptr);
d4578 3
a4580 1
			     l->flags != NULL, flags, l->at != NULL,
@


1.40.2.2
log
@	* ldlang.c (record_bfd_errors): Remove.

	Merge from mainline.
	2001-05-31  H.J. Lu  <hjl@@gnu.org>
	* ldlang.c (open_input_bfds): Don't change the bfd error
	handler whilst loading symbols.

	2001-05-02  Nick Clifton  <nickc@@redhat.com>
	* emultempl/aix.em: Replace buystring with xstrdup.
	* emultempl/beos.em: Replace buystring with xstrdup.
@
text
@d130 1
d1903 1
d1920 5
d1927 2
d3458 47
@


1.40.2.3
log
@If a region is specified assign it to all sections inside the overlay unless
they have been assigned to the own, non-default, memory region
@
text
@a4768 1
  lang_memory_region_type * default_region;
a4772 2
  default_region = lang_memory_region_lookup ("*default*");

d4792 1
a4792 7

      /* Assign a region to the sections, if one has been specified.
	 Override the assignment of the default section, but not
	 other sections.  */
      if (region != NULL &&
	  (l->os->region == NULL ||
	   l->os->region == default_region))
a4793 1

a4802 1

@


1.39
log
@Only set lma_region from the default for the first section
of a group of overlay sections.
@
text
@d4785 6
a4790 2
	 to the first section.  */
      if (lma_region != NULL && l->os->lma_region == NULL && l->next == NULL)
@


1.38
log
@2001-01-16  H.J. Lu  <hjl@@gnu.org>

	* ldlang.c (lang_check): Merge the private data only if the
	input file has contents.
@
text
@d4783 4
a4786 1
      if (lma_region != NULL && l->os->lma_region == NULL)
@


1.37
log
@Extend "ld --unique" functionality.
@
text
@d3477 1
a3477 1
      else
d3479 3
@


1.36
log
@Revert the last beautification with "innocent" whitespace,
it breaks the K&R C preprocessor.
@
text
@d2 1
a2 1
   Copyright (C) 1991, 92, 93, 94, 95, 96, 97, 98, 99, 2000
d189 1
d215 17
d263 1
a263 1
      boolean wildcard;
d265 1
a265 3
      if (section == NULL)
	wildcard = false;
      else
d271 1
d275 2
d278 1
a278 2
	    {
	      const char *name;
d280 3
a282 8
	      name = bfd_get_section_name (file->the_bfd, s);
	      if (wildcard)
		match = fnmatch (section, name, 0) == 0 ? true : false;
	      else
		match = strcmp (section, name) == 0 ? true : false;
	    }

	  if (match)
d941 1
a941 1
  /* FIXME: When doing a relocateable link, we may have trouble
d948 1
a948 1
     doing a relocateable link (technically, they should be discarded
d954 1
a954 1
     Also, not merging link once sections in a relocateable link
d5059 16
@


1.35
log
@Add support for x86_64-*-linux-gnu* target
@
text
@d198 2
a199 1
#define new_stat(x, y) (cat (x, _type)*) new_statement (cat (x, _enum), sizeof (cat (x, _type)), y)
@


1.34
log
@Another try at correcting relocations against discarded
link-once section symbols.
@
text
@d123 2
a124 3
  PARAMS ((lang_statement_union_type **this_ptr, fill_type fill,
	   unsigned int power, asection *output_section_statement,
	   bfd_vma dot));
d126 2
a127 3
  PARAMS ((lang_statement_union_type **this_ptr,
	   lang_output_section_statement_type *output_section_statement,
	   fill_type fill, bfd_vma dot, boolean relax));
d198 1
a198 1
#define new_stat(x,y) (cat(x,_type)*) new_statement(cat(x,_enum), sizeof(cat(x,_type)),y)
d202 1
a202 1
#define outside_symbol_address(q) ((q)->value + outside_section_address(q->section))
@


1.33
log
@2000-10-09  Kazu Hirata  <kazu@@hxi.com>

	* ldcref.c: Fix formatting.
	* ldctor.h: Likewise.
	* ldemul.c: Likewise.
	* ldemul.h: Likewise.
	* ldexp.c: Likewise.
	* ldexp.h: Likewise.
	* ldfile.c: Likewise.
	* ldfile.h: Likewise.
	* ld.h: Likewise.
	* ldlang.c: Likewise.
	* ldlang.h: Likewise.
	* ldmain.c: Likewise.
@
text
@d998 1
a998 2
	  if (sec->comdat != NULL)
	    sec->comdat->sec = l->sec;
@


1.32
log
@2000-10-05  Kazu Hirata  <kazu@@hxi.com>

	* ldlang.c: Fix formatting.
@
text
@d46 1
a46 1
							 lang_statement_list_type*));
d4625 1
a4625 2
struct overlay_list
{
d5032 1
a5032 1
      while (p < contents+len)
@


1.31
log
@2000-09-29  Kazu Hirata  <kazu@@hxi.com>

	* ldcref.c: Fix formatting.
	* ldctor.c: Likewise.
	* ldemul.c: Likewise.
	* ldexp.c: Likewise.
	* ldfile.c: Likewise.
	* ldlang.c: Likewise.
@
text
@d202 1
a202 1
#define outside_section_address(q) ( (q)->output_offset + (q)->output_section->vma)
d204 1
a204 1
#define outside_symbol_address(q) ((q)->value +   outside_section_address(q->section))
d215 1
a215 3
/*----------------------------------------------------------------------
  Generic traversal routines for finding matching sections.
*/
d230 1
a230 1
        {
d349 2
a350 4
/*----------------------------------------------------------------------
  lang_for_each_statement walks the parse tree and calls the provided
  function for each node
*/
d403 1
a403 2
  lang_for_each_statement_worker (func,
				  statement_list.head);
d407 1
d416 1
a416 1
/*----------------------------------------------------------------------
d418 1
a418 6
  build a new statement node for the parse tree

 */

static
lang_statement_union_type *
d422 1
a422 1
     lang_statement_list_type * list;
d433 8
a440 9
/*
  Build a new input file node for the language. There are several ways
  in which we treat an input file, eg, we only look at symbols, or
  prefix it with a -l etc.

  We can be supplied with requests for input files more than once;
  they may, for example be split over serveral lines like foo.o(.text)
  foo.o(.data) etc, so when asked for a file we check that we havn't
  got it already so we don't duplicate the bfd.
a441 1
 */
d539 2
a540 1
/* Build enough state so that the parser can build its tree */
d556 2
a557 1
  abs_output_section = lang_output_section_statement_lookup (BFD_ABS_SECTION_NAME);
d564 8
a571 9
 A region is an area of memory declared with the
 MEMORY {  name:org=exp, len=exp ... }
 syntax.

 We maintain a list of all the regions here

 If no regions are specified in the script, then the default is used
 which is created when looked up to be the entire data space
*/
d620 1
a620 1
    new->length = ~(bfd_size_type)0;
d813 2
a814 2
  /* We initialize an output sections output offset to minus its own */
  /* vma to allow us to output a section through itself */
d952 1
a952 1
  for (l = already_linked_list->entry;  l != NULL; l = l->next)
d1133 1
a1133 1
      /* Add a section reference to the list */
d1201 5
a1205 5
        {
          section->output_section->flags |= SEC_BLOCK;
          /* FIXME: This value should really be obtained from the bfd...  */
          output->block_value = 128;
        }
d1539 1
d1542 1
a1542 1
     const bfd_target * target;
d1545 1
a1545 1
  const char * sought = (const char *) data;
d1551 1
d1554 2
a1555 2
     char * dest;
     char * src;
d1559 1
a1559 1
  while ((c = * src ++) != 0)
d1564 1
a1564 1
      * dest ++ = c;
d1567 1
a1567 1
  * dest = 0;
d1572 1
d1575 2
a1576 2
     char * haystack;
     char * needle;
d1582 1
a1582 1
      char * src;
d1584 2
a1585 2
      for (src = haystack + strlen (needle); * src;)
	* haystack ++ = * src ++;
d1587 1
a1587 1
      * haystack = 0;
d1593 1
d1596 2
a1597 2
     char * first;
     char * second;
d1599 3
a1601 3
  char * copy1;
  char * copy2;
  int    result;
d1619 2
a1620 2
  for (result = 0; copy1 [result] == copy2 [result]; result ++)
    if (copy1 [result] == 0)
d1633 1
a1633 1
static const bfd_target * winner;
d1638 1
d1641 1
a1641 1
     const bfd_target * target;
d1644 1
a1644 1
  const bfd_target * original = (const bfd_target *) data;
d1646 2
a1647 1
  if (command_line.endian == ENDIAN_BIG && target->byteorder != BFD_ENDIAN_BIG)
d1650 2
a1651 1
  if (command_line.endian == ENDIAN_LITTLE && target->byteorder != BFD_ENDIAN_LITTLE)
d1675 1
d1679 1
a1679 1
  char * target = NULL;
d1706 1
a1706 1
     const char * name;
d1708 1
a1708 1
  bfd * output;
d1710 1
a1710 1
  /* Has the user told us which output format to use ?  */
d1713 2
a1714 1
      /* No - has the current target been set to something other than the default ?  */
d1718 1
a1718 1
      /* No - can we determine the format of the first input file ? */
d1729 2
a1730 1
  /* Has the user requested a particular endianness on the command line ?  */
d1733 1
a1733 1
      const bfd_target * target;
d1788 3
a1790 1
  /*  output->flags |= D_PAGED;*/
d1809 1
a1809 1
     lang_statement_union_type * statement;
d1857 1
a1857 1
	  /* Maybe we should load the file's symbols */
d1868 2
a1869 2
               until no new symbols are added to the list of undefined
               symbols.  */
d1917 2
a1918 1
/* If there are [COMMONS] statements, put a wild one into the bss section */
d1927 1
a1927 2
  default_common_section =
    lang_output_section_statement_lookup (".bss");
a1939 1

d1942 2
a1943 4
/*
 Add the supplied name to the symbol table as an undefined reference.
 Remove items from the chain as we open input bfds
 */
d1968 2
a1969 2
   script file.
*/
d1993 2
a1994 1
/* Open input files and attatch to output sections */
d1997 1
a1997 1
     lang_statement_union_type * s;
d1999 1
a1999 1
     lang_output_section_statement_type * output_section_statement;
d2049 1
a2049 1
             are initialized.  */
d2056 1
a2056 1
	  /* Mark the specified section with the supplied address */
d2073 1
a2073 1
     lang_output_section_statement_type * output_section_statement;
d2119 2
a2120 2
     lang_assignment_statement_type * assignment;
     lang_output_section_statement_type * output_section;
d2149 1
a2149 1
     lang_input_statement_type * statm;
d2190 1
a2190 1
     lang_input_section_type * in;
d2248 1
a2248 1
     lang_fill_statement_type * fill;
d2255 1
a2255 1
     lang_data_statement_type * data;
d2391 2
a2392 2
     lang_wild_statement_type * w;
     lang_output_section_statement_type * os;
d2402 2
a2403 2
      for (tmp=w->exclude_filename_list->next; tmp; tmp = tmp->next)
        minfo (", %s", tmp->name);
d2405 2
a2406 2
     }
   if (w->filename != NULL)
d2544 1
a2544 1
     lang_statement_union_type * s;
d2567 1
a2567 1
     lang_statement_union_type ** this_ptr;
d2570 1
a2570 1
     asection * output_section_statement;
d2578 1
a2578 2
     inserting a magic 'padding' statement.
     */
d2590 1
a2590 1
      /* Link into existing chain */
d2601 1
a2601 1
  /* Remember the most restrictive alignment */
d2611 2
a2612 1
/* Work out how much this section will move the dot point */
d2615 2
a2616 2
     lang_statement_union_type ** this_ptr;
     lang_output_section_statement_type * output_section_statement;
d2635 1
a2635 1
      /* Remember where in the output section this input section goes */
d2639 1
a2639 2
      /* Mark how big the output section must be to contain this now
	 */
d2645 1
a2645 1
        (dot - output_section_statement->bfd_section->vma) * opb;
d2662 1
d2666 1
a2666 1
  asection * s;
d2672 1
a2672 1
      asection * os;
d2727 4
a2730 4
  lang_output_section_statement_type *os;
  struct memory_region_struct *region;
  etree_type *tree;
  bfd_vma base;
d2761 3
a2763 3
     lang_statement_union_type * s;
     lang_output_section_statement_type * output_section_statement;
     lang_statement_union_type ** prev;
d2791 1
a2791 1
		asection * input;
d2881 2
a2882 1
	    (void) lang_size_sections (os->children.head, os, &os->children.head,
d2885 2
a2886 2
            /* put the section within the requested block size, or align at
               the block boundary */
d2896 1
a2896 1
                (after - os->bfd_section->vma) * opb;
d2917 7
a2923 2
                os_region_check (os, os->region, os->addr_tree,
                                 os->bfd_section->vma);
d2925 21
a2945 25
                /* if there's no load address specified, use the run region as
                   the load region */
                if (os->lma_region == NULL && os->load_base == NULL)
                    os->lma_region = os->region;

                if (os->lma_region != NULL)
                  {
                    if (os->load_base != NULL)
                      {
                        einfo (_("%X%P: use an absolute load address or a load memory region, not both\n"));
                      }
                    else
                      {
                        /* don't allocate twice */
                        if (os->lma_region != os->region)
                          {
                            /* set load_base, which will be handled later */
                            os->load_base = exp_intop (os->lma_region->current);
                            os->lma_region->current +=
                              os->bfd_section->_raw_size / opb;
                            os_region_check (os, os->lma_region, NULL,
                                             os->bfd_section->lma);
                          }
                      }
                  }
d2962 2
a2963 1
	    s->data_statement.output_vma = dot - output_section_statement->bfd_section->vma;
d2969 2
a2970 2
              default:
                abort();
d2985 2
a2986 2
            if (size < opb)
              size = opb;
d2992 5
a2996 3
	    if (!(output_section_statement->flags & SEC_NEVER_LOAD)) {
	      output_section_statement->bfd_section->flags |= SEC_ALLOC | SEC_LOAD;
	    }
a3018 1

d3058 2
a3059 1
	  s->fill_statement.output_section = output_section_statement->bfd_section;
d3143 2
a3144 2
     lang_statement_union_type * s;
     lang_output_section_statement_type * output_section_statement;
d3182 2
a3183 2
		      = exp_get_abs_int(os->load_base, 0,"load base",
					lang_final_phase_enum);
d3216 22
a3237 22
            switch (s->data_statement.type)
              {
              default:
                abort();
              case QUAD:
              case SQUAD:
                size = QUAD_SIZE;
                break;
              case LONG:
                size = LONG_SIZE;
                break;
              case SHORT:
                size = SHORT_SIZE;
                break;
              case BYTE:
                size = BYTE_SIZE;
                break;
              }
            if (size < opb)
              size = opb;
            dot += size / opb;
          }
d3556 1
a3556 1
  section->flags &= ~ SEC_IS_COMMON;
d3608 3
a3610 6
/*
run through the input files and ensure that every input
section has somewhere to go. If one is found without
a destination then create an input request and place it
into the statement tree.
*/
d3626 1
a3626 1
	         around for a sensible place for it to go */
d3751 1
a3751 1
     void (*func) PARAMS ((bfd * ab, asection * as));
d3755 1
a3755 1
      asection * s;
d3770 1
a3770 1
     lang_input_statement_type * entry;
d3843 1
a3843 1
     etree_type * address_exp;
d3856 6
a3861 4
  /* Add this statement to tree */
  /*  add_statement(lang_output_section_statement_enum,
      output_section_statement);*/
  /* Make next things chain into subchain of this */
d3863 4
a3866 6
  if (os->addr_tree ==
      (etree_type *) NULL)
  {
    os->addr_tree =
     address_exp;
  }
d3875 4
a3878 7
  os->subsection_alignment = topower(
   exp_get_value_int(subalign, -1,
		     "subsection alignment",
		     0));
  os->section_alignment = topower(
   exp_get_value_int(align, -1,
		     "section alignment", 0));
d3893 2
a3894 1
/* Reset the current counters in the regions */
d3941 1
a3941 1
     lang_statement_union_type * s;
d3995 2
a3996 2
          && (h->type == bfd_link_hash_defined
              || h->type == bfd_link_hash_defweak)
d4012 2
a4013 1
  lang_for_each_statement (ldlang_open_output);	/* Open the output file */
d4017 1
a4017 1
  /* Add to the hash table all undefineds on the command line */
d4022 1
a4022 1
  /* Create a bfd for each input file */
d4049 1
a4049 1
  /* Size up the common data */
d4053 1
a4053 2
     to the correct output sections
     */
d4057 1
a4057 1
  /* Find any sections not attached explicitly and handle them */
d4066 1
a4066 1
  /* Now run around and relax if we can */
d4084 1
a4084 1
	     pe-dll.c also.  DJ */
d4115 2
a4116 2
  /* Do all the assignments, now that we know the final restingplaces
     of all the symbols */
d4127 1
a4127 1
  /* Final stuffs */
d4168 1
a4168 1
     etree_type * address;
d4214 1
a4214 1
	  case 'F':
d4276 1
a4276 1
     etree_type * exp;
d4326 2
a4327 2
      /* if no runtime region has been given, but the load region has been,
         use the load region */
d4335 4
a4338 3
/*
 Create an absolute symbol with the given name with the value of the
 address of first byte of the section named.
a4339 2
 If the symbol already exists, then do nothing.
*/
d4368 4
a4371 3
/*
 Create an absolute symbol with the given name with the value of the
 address of the first byte after the end of the section named.
a4372 2
 If the symbol already exists, then do nothing.
*/
d4405 3
a4407 3
     lang_statement_list_type * list;
     lang_statement_union_type * element;
     lang_statement_union_type ** field;
d4771 1
a4771 1
        l->os->lma_region = lma_region;
d4831 1
a4831 1
  alt_sym = cplus_demangle(sym, /* DMGL_NO_TPARAMS */ 0);
d4858 1
a4858 1
  alt_sym = cplus_demangle(sym, DMGL_JAVA);
@


1.30
log
@A tidy of ld/ldlang.c, and add missing Makefile dependencies
I should have added with the 2000-07-28 patch.
@
text
@a47 1

a193 1

d227 1
a227 1
  /* Don't process sections from files which were excluded. */
a637 1

a912 1
/*ARGSUSED*/
d1213 1
a1213 1
          /* FIXME: This value should really be obtained from the bfd... */
a1522 2


d1669 1
a1669 1
     Compare their names and choose the better one. */
a1926 1

a2005 1

a2601 1

d3173 1
a3173 1
		   it won't have a bfd_section. */
a3671 1

a3813 1

a3853 2


a4055 1

@


1.29
log
@When choosing the target for a particular endianness, do nothing if the target
is not supported.
@
text
@d54 1
a54 1
static CONST char *startup_file;
d61 2
a62 2
static CONST char *current_target;
static CONST char *output_target;
d67 2
a68 2
  PARAMS ((void (*func) (lang_statement_union_type *),
	   lang_statement_union_type *s));
d70 4
a73 3
  PARAMS ((const char *name, lang_input_file_enum_type file_type,
	   const char *target, boolean add_to_list));
static void init_os PARAMS ((lang_output_section_statement_type *s));
d77 1
a77 2
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *,
	   const char *string));
d84 12
a95 11
static lang_input_statement_type *lookup_name PARAMS ((const char *name));
static void load_symbols PARAMS ((lang_input_statement_type *entry,
				  lang_statement_list_type *));
static void wild PARAMS ((lang_wild_statement_type *s,
			  const char *section, const char *file,
			  const char *target,
			  lang_output_section_statement_type *output));
static bfd *open_output PARAMS ((const char *name));
static void ldlang_open_output PARAMS ((lang_statement_union_type *statement));
static void open_input_bfds
  PARAMS ((lang_statement_union_type *statement, boolean));
d99 2
a100 3
  PARAMS ((lang_statement_union_type *s,
	   const char *target,
	   lang_output_section_statement_type *output_section_statement));
d102 1
a102 1
  PARAMS ((lang_output_section_statement_type *output_section_statement));
d104 3
a106 3
  PARAMS ((lang_assignment_statement_type *assignment,
	   lang_output_section_statement_type *output_section));
static void print_input_statement PARAMS ((lang_input_statement_type *statm));
d108 3
a110 3
static void print_input_section PARAMS ((lang_input_section_type *in));
static void print_fill_statement PARAMS ((lang_fill_statement_type *fill));
static void print_data_statement PARAMS ((lang_data_statement_type *data));
d112 2
a113 2
static void print_reloc_statement PARAMS ((lang_reloc_statement_type *reloc));
static void print_padding_statement PARAMS ((lang_padding_statement_type *s));
d115 1
a115 2
  PARAMS ((lang_wild_statement_type *w,
	   lang_output_section_statement_type *os));
d118 4
a121 4
static void print_statement PARAMS ((lang_statement_union_type *s,
				     lang_output_section_statement_type *os));
static void print_statement_list PARAMS ((lang_statement_union_type *s,
					  lang_output_section_statement_type *os));
d123 4
a126 4
static bfd_vma insert_pad PARAMS ((lang_statement_union_type **this_ptr,
				   fill_type fill, unsigned int power,
				   asection *output_section_statement,
				   bfd_vma dot));
d140 3
d148 6
d156 3
d162 4
a165 1
				    void *));
d168 1
a168 1
	   lang_input_statement_type *, callback_t, void *));
d171 1
a171 1
	   lang_input_statement_type *, callback_t, void *));
d173 1
a173 1
static int    get_target PARAMS ((const bfd_target *, void *));
d177 1
a177 1
static int    closest_target_match PARAMS ((const bfd_target *, void *));
d179 1
a179 1
					
d227 1
a227 1
     void *data;
d288 1
a288 1
     void *data;
d325 1
a325 1
     void *data;
d351 2
a352 2
}  
     
d457 1
a457 1
     CONST char *name;
d459 1
a459 1
     CONST char *target;
d544 1
a544 1
     CONST char *name;
d546 1
a546 1
     CONST char *target;
d590 1
a590 1
     CONST char *CONST name;
d641 1
a641 1
lang_memory_region_type *
d668 1
a668 1
     CONST char *CONST name;
d688 1
a688 1
     CONST char *CONST name;
d711 1
a711 1
      lookup->memspec = (CONST char *) NULL;
d900 1
a900 1
struct already_linked_hash_entry 
d906 1
a906 1
struct already_linked 
d962 1
a962 1
  already_linked_list = 
d1022 1
a1022 1
  l = ((struct already_linked *) 
d1039 1
a1039 1
  struct already_linked_hash_entry *ret = 
d1332 1
a1332 1
     void *output;
d1335 1
a1335 1
  
d1340 1
a1340 1
  
d1342 1
a1342 1
  
d1347 1
a1347 1
  
d1349 2
a1350 2
    wild_doit (&ptr->children, section, 
	       (lang_output_section_statement_type *) output, 
d1356 1
a1356 1
      
d1358 2
a1359 2
      wild_doit (&list, section, 
		 (lang_output_section_statement_type *) output, 
d1361 1
a1361 1
      
d1367 1
a1367 1
	  
d1372 1
a1372 1
	  
d1527 1
a1527 1
     
d1542 1
a1542 1
  walk_wild (s, section, file, output_section_callback, (void *) output);
d1558 1
a1558 1
     void * data;
d1561 1
a1561 1
  
d1572 1
a1572 1
  
d1592 1
a1592 1
  
d1599 1
a1599 1
      
d1614 1
a1614 1
  
d1637 1
a1637 1
  
d1653 1
a1653 1
     void * data;
d1656 1
a1656 1
  
d1659 1
a1659 1
  
d1695 1
a1695 1
	  
d1700 1
a1700 1
	  
d1706 1
a1706 1
  
d1735 1
a1735 1
  
d1743 1
a1743 1
      target = bfd_search_for_target (get_target, (void *) output_target);
d1752 5
a1756 4
	  
	  /* See if the target has the wrong endianness.  This should not happen
	     if the linker script has provided big and little endian alternatives,
	     but some scrips don't do this.  */
d1766 7
a1772 6
		  /* Try to find a target as similar as possible to the default
		     target, but which has the desired endian characteristic.  */
		  (void) bfd_search_for_target (closest_target_match, (void *) target);
		  
		  /* Oh dear - we could not find any targets that satisfy our
		     requirements.  */
d1781 1
a1781 1
      
d1962 1
a1962 1
     CONST char *CONST name;
d2005 1
a2005 1
     CONST char *target;
d2168 1
a2168 1
static boolean 
d2202 1
a2202 1
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
d2269 1
a2269 1
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
d2340 2
a2341 2
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
						ldfile_output_machine); 
d2364 1
a2364 1
}  
d2372 2
a2373 2
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
						ldfile_output_machine); 
d2589 2
a2590 2
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
						ldfile_output_machine); 
d2632 2
a2633 2
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
						ldfile_output_machine); 
d2654 1
a2654 1
      output_section_statement->bfd_section->_raw_size = 
d2682 1
a2682 1
      
d2686 1
a2686 1
      
d2696 1
a2696 1
	  
d2708 1
a2708 1
	  
d2712 1
a2712 1
	  
d2716 1
a2716 1
	  
d2732 1
a2732 1
   calculation wraps around.  */ 
d2777 1
a2777 1
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
d2850 1
a2850 1
 
d2878 1
a2878 1
		
d2886 1
a2886 1
		
d2892 1
a2892 1
	    
d2903 1
a2903 1
	      os->bfd_section->_raw_size = 
d2912 1
a2912 1
	       
d2923 1
a2923 1
		
d2925 1
a2925 1
                os_region_check (os, os->region, os->addr_tree, 
d2946 1
a2946 1
                            os->lma_region->current += 
d3017 1
a3017 1
     
d3152 2
a3153 2
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
						ldfile_output_machine); 
d3183 1
a3183 1
		if (os->bfd_section) 
d3185 1
a3185 1
		    os->bfd_section->lma 
d3343 1
a3343 1
          unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
d3394 1
a3394 1
      CONST char *send;
d3454 1
a3454 1
  CONST bfd_arch_info_type *compatible;
d3526 2
a3527 2
  unsigned opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
						ldfile_output_machine); 
d3685 1
a3685 1
     CONST char *flags;
d3813 1
a3813 1
     CONST char *name;
d3837 1
a3837 1
  for (l = 0; l < 32; l++) 
d3930 1
a3930 1
     void *data ATTRIBUTE_UNUSED;
d3992 1
a3992 1
  
d4004 1
a4004 1
      h = bfd_link_hash_lookup (link_info.hash, ulist->name, 
d4140 1
a4140 1
  
d4181 1
a4181 1
     CONST char *name;
d4197 1
a4197 1
     CONST char *name;
d4211 1
a4211 1
     CONST char *name;
d4222 1
a4222 1
     CONST char *name;
d4276 1
a4276 1
  
d4308 1
a4308 1
     CONST char *name;
d4723 1
a4723 1
  lang_leave_output_section_statement (fill, "*default*", 
@


1.28
log
@Remove some forward declarations in ldemul.h and ldfile.h, and
re-arrange header include order.
Fix shadowing warnings in ldlang.h
Fix compile errors in mpw-elfmips.c
@
text
@d1731 5
a1735 15
      if (command_line.endian == ENDIAN_BIG)
	desired_endian = BFD_ENDIAN_BIG;
      else
	desired_endian = BFD_ENDIAN_LITTLE;
      
      /* See if the target has the wrong endianness.  This should not happen
	 if the linker script has provided big and little endian alternatives,
	 but some scrips don't do this.  */
      if (target->byteorder != desired_endian)
	{
	  /* If it does, then see if the target provides
	     an alternative with the correct endianness.  */
	  if (target->alternative_target != NULL
	      && (target->alternative_target->byteorder == desired_endian))
	    output_target = target->alternative_target->name;
d1737 6
d1744 5
a1748 7
	      /* Try to find a target as similar as possible to the default
		 target, but which has the desired endian characteristic.  */
	      (void) bfd_search_for_target (closest_target_match, (void *) target);
	      
	      /* Oh dear - we could not find any targets that satisfy our requirements.  */
	      if (winner == NULL)
		einfo (_("%P: warning: could not find any targets that match endianness requirement\n"));
d1750 12
a1761 1
		output_target = winner->name;
d3163 1
a3163 1
	    if (os->load_base) 
d3170 2
a3171 1
		      = exp_get_abs_int(os->load_base, 0,"load base", lang_final_phase_enum);
a3880 1

@


1.27
log
@tic54x/ibmc54xdsp target for ld.
@
text
@a32 1
#include "ldemul.h"
d37 1
@


1.26
log
@2000-05-10  H.J. Lu  <hjl@@gnu.org>

	* ldlang.c (open_input_bfds): Don't load the same file within
	a group again if the whole archive has been loaded already.
@
text
@d1199 7
@


1.25
log
@place_orphan optimisations
@
text
@d1867 2
a1868 1
                 force it to be researched.  */
d1870 1
@


1.24
log
@This lot mainly cleans up `comparison between signed and unsigned' gcc
warnings.  One usused var, and a macro parenthesis fix too.  Also check
input sections are elf when doing gc in elflink.h.
@
text
@a60 1
static lang_statement_list_type lang_output_section_statement;
d168 1
d3816 1
a3816 1
void
d3864 1
@


1.24.2.1
log
@Merge elf32.em place_orphan changes from mainline.
@
text
@d61 1
a168 1
lang_statement_list_type lang_output_section_statement;
d3816 1
a3816 1
lang_output_section_statement_type *
a3863 1
  return os;
@


1.23
log
@Add LMA memory region functionality.
@
text
@d2172 2
a2173 2
  int opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
                                           ldfile_output_machine);
d2239 2
a2240 2
  int opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
                                           ldfile_output_machine);
d2310 2
a2311 2
  int opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
                                           ldfile_output_machine); 
d2342 2
a2343 2
  int opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
                                           ldfile_output_machine); 
d2559 2
a2560 2
  int opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
                                           ldfile_output_machine); 
d2602 2
a2603 2
  int opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
                                           ldfile_output_machine); 
d2646 1
a2646 1
  int opb = bfd_octets_per_byte (output_bfd);
d2747 2
a2748 2
  int opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
                                           ldfile_output_machine);
d3122 2
a3123 2
  int opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
                                           ldfile_output_machine); 
d3188 1
a3188 1
            int size;
d3312 2
a3313 2
          int opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
                                                   ldfile_output_machine); 
d3495 2
a3496 2
  int opb = bfd_arch_mach_octets_per_byte (ldfile_output_architecture, 
                                           ldfile_output_machine); 
@


1.22
log
@These snippets were missed in the previous bytes vs octets patch to
the linker.
@
text
@d685 1
d2699 37
d2894 29
a2922 31
		/* Make sure the new address is within the region.  We
                   explicitly permit the current address to be at the
                   exact end of the region when the VMA is non-zero,
                   in case the region is at the end of addressable
                   memory and the calculation wraps around.  */
		if ((os->region->current < os->region->origin
		     || (os->region->current - os->region->origin
			 > os->region->length))
		    && ((os->region->current
			 != os->region->origin + os->region->length)
			|| os->bfd_section->vma == 0))

		  {
		    if (os->addr_tree != (etree_type *) NULL)
		      {
			einfo (_("%X%P: address 0x%v of %B section %s is not within region %s\n"),
			       os->region->current,
			       os->bfd_section->owner,
			       os->bfd_section->name,
			       os->region->name);
		      }
		    else
		      {
			einfo (_("%X%P: region %s is full (%B section %s)\n"),
			       os->region->name,
			       os->bfd_section->owner,
			       os->bfd_section->name);
		      }
		    /* Reset the region pointer.  */
		    os->region->current = os->region->origin;
		  }
d4298 1
a4298 1
lang_leave_output_section_statement (fill, memspec, phdrs)
d4302 1
d4306 8
d4692 2
a4693 1
  lang_leave_output_section_statement (fill, "*default*", phdrs);
d4723 1
a4723 1
lang_leave_overlay (fill, memspec, phdrs)
d4727 1
d4730 1
d4739 5
d4755 2
@


1.21
log
@Fix typo in ALIGN_N usage.
@
text
@d2675 2
a2676 2
	  s_end    = s_start  + bfd_section_size (output_bfd, s) - 1;
	  os_end   = os_start + bfd_section_size (output_bfd, os) - 1;
d2909 2
d3155 2
@


1.20
log
@Add octets vs bytes functionality to LD.
@
text
@d2827 2
a2828 2
	    after = ALIGN_N (os->bfd_section->vma,
			     os->bfd_section->_raw_size / opb,
@


1.19
log
@fix typo in comment.
@
text
@d2171 2
a2172 1

d2196 1
a2196 1
		 i->output_section->vma + i->output_offset, size,
d2218 1
a2218 1
	  print_dot = i->output_section->vma + i->output_offset + size;
d2238 2
d2284 2
a2285 1
  print_dot = addr + size;
d2309 2
d2332 1
a2332 1
  print_dot = addr + size;
d2341 2
d2363 1
a2363 1
  print_dot = addr + s->size;
d2558 2
d2576 1
a2576 1
      new->padding_statement.size = alignment_needed;
d2585 1
a2585 2
  output_section_statement->_raw_size += alignment_needed;
  return alignment_needed + dot;
d2587 1
d2601 2
d2620 1
a2620 1
	dot += i->_cooked_size;
d2622 3
a2624 2
	dot += i->_raw_size;
      output_section_statement->bfd_section->_raw_size = dot - output_section_statement->bfd_section->vma;
d2645 1
d2709 3
d2825 4
a2828 5
	    /* Ignore the size of the input sections, use the vma and size to
	       align against.  */

	    after = ALIGN_N (os->bfd_section->vma +
			     os->bfd_section->_raw_size,
d2835 3
a2837 2
	      os->bfd_section->_raw_size = after - os->bfd_section->vma;
	    dot = os->bfd_section->vma + os->bfd_section->_raw_size;
d2923 3
a2925 2

	    dot += size;
d2945 1
a2945 1
	    dot += size;
d3033 1
a3033 1
		    new->padding_statement.size = newdot - dot;
d3051 1
a3051 1
	  dot += s->padding_statement.size;
d3084 3
d3108 2
a3109 1
		dot = os->bfd_section->vma + os->bfd_section->_raw_size;
d3149 22
a3170 16
	  switch (s->data_statement.type)
	    {
	    case QUAD:
	    case SQUAD:
	      dot += QUAD_SIZE;
	      break;
	    case LONG:
	      dot += LONG_SIZE;
	      break;
	    case SHORT:
	      dot += SHORT_SIZE;
	      break;
	    case BYTE:
	      dot += BYTE_SIZE;
	      break;
	    }
d3184 1
a3184 1
	  dot += bfd_get_reloc_size (s->reloc_statement.howto);
d3192 1
a3192 1
	      dot += in->_cooked_size;
d3194 1
a3194 1
	      dot += in->_raw_size;
d3214 1
a3214 1
	  dot += s->padding_statement.size;
d3272 2
d3276 1
a3276 1
	    h->u.def.value = s->_cooked_size;
d3278 1
a3278 1
	    h->u.def.value = s->_raw_size;
d3455 2
d3471 2
a3472 2
  section->_cooked_size = ALIGN_N (section->_cooked_size,
				   (bfd_size_type) (1 << power_of_two));
d4332 2
a4333 1
			  + bfd_section_size (output_bfd, sec));
@


1.18
log
@Apply H.J.'s patch to fix NOLOAD section sizes and dot updates
@
text
@d2826 1
@


1.17
log
@        * ld.h (wildcard_spec):  Change exclude_name to exclude_name_list.
        (name_list): New.
        * ld.texinfo (EXCLUDE_FILE): Update documentation.
        * ldgram.y (wildcard_spec): Support a list of excluded_files.
        (exclude_name_list): New.
        ldlang.c (walk_wild_section): Support list of excluded files.
        (print_wild_statement): Likewise.
        (lang_add_wild): Likewise.
        * ldlang.h (lang_wild_statement_type): Likewise.
        * scripttempl/elf.sc (OTHER_EXCLUDE_FILES): Support.
@
text
@d2826 4
a2829 1
	       overall size in memory.  */
d2831 4
a2834 2
		&& (bfd_get_section_flags (output_bfd, os->bfd_section)
		    & (SEC_ALLOC | SEC_LOAD)))
@


1.16
log
@Fix bug in previous delta
@
text
@d2 1
a2 1
   Copyright (C) 1991, 92, 93, 94, 95, 96, 97, 98, 1999
d216 1
a216 1
  if (ptr->exclude_filename != NULL)
d218 4
a221 1
      boolean match;
d223 4
a226 4
      if (wildcardp (ptr->exclude_filename))
         match = fnmatch (ptr->exclude_filename, file->filename, 0) == 0 ? true : false;
      else
         match = strcmp (ptr->exclude_filename, file->filename) == 0 ? true : false;
d228 3
a230 2
      if (match)
        return;
d2367 9
a2375 3
  if (w->exclude_filename != NULL)
    minfo ("EXCLUDE_FILE ( %s )", w->exclude_filename);
  if (w->filename != NULL)
d4042 1
a4042 1
	       keep_sections, exclude_filename)
d4048 1
a4048 1
     const char *exclude_filename;
d4066 1
a4066 1
  new->exclude_filename = exclude_filename;
@


1.15
log
@Do not check sections without a LOAD attribute for overlap
@
text
@d2612 1
a2612 1
  (((bfd_get_section_flags (bfd, s) & (SEC_ALLOC | SEC_LOAD)) == 0) \
@


1.14
log
@1999-11-01  Steve Chamberlain  <sac@@pobox.com>

	* ldlang.c (section_already_linked): Rework to use hash table.
	(already_linked_newfunc): New function.
	(already_linked_table_init): New function.
	(already_linked_table_free): New function.
	(lang_process): Initialize and free the already_linked hash table.
@
text
@d2611 4
d2625 34
a2658 35
    /* Ignore sections which are not loaded or which have no contents.  */
    if ((bfd_get_section_flags (output_bfd, s) & (SEC_ALLOC | SEC_LOAD))
	&& bfd_section_size (output_bfd, s) != 0)
      {
	asection * os;

	/* Once we reach section 's' stop our seach.  This prevents two
	   warning messages from being produced, one for 'section A overlaps
	   section B' and one for 'section B overlaps section A'.  */
	for (os = output_bfd->sections; os != s; os = os->next)
	  {
	    bfd_vma s_start;
	    bfd_vma s_end;
	    bfd_vma os_start;
	    bfd_vma os_end;

	    /* Only consider loadable sections with real contents.  */
	    if (((bfd_get_section_flags (output_bfd, os)
		  & (SEC_ALLOC | SEC_LOAD)) == 0)
		|| bfd_section_size (output_bfd, os) == 0)
	      continue;

	    /* We must check the sections' LMA addresses not their
	       VMA addresses because overlay sections can have
	       overlapping VMAs but they must have distinct LMAs.  */
	    s_start  = bfd_section_lma (output_bfd, s);
	    os_start = bfd_section_lma (output_bfd, os);
	    s_end    = s_start  + bfd_section_size (output_bfd, s) - 1;
	    os_end   = os_start + bfd_section_size (output_bfd, os) - 1;

	    /* Look for an overlap.  */
	    if ((s_end < os_start) || (s_start > os_end))
	      continue;
	    
	    einfo (
d2660 7
a2666 7
		   s->name, s_start, s_end, os->name, os_start, os_end);

	    /* Once we have found one overlap for this section,
	       stop looking for others.  */
	    break;
	  }
      }
@


1.13
log
@1999-09-12  Donn Terry  <donn@@interix.com>

	* ldlang.c (section_already_linked): Use comdat information if it
	is available.
@
text
@d76 5
d866 1
a866 1

d868 2
a869 2
   once into the output.  This routine checks each sections, and
   arranges to discard it if a section of the same name has already
d873 23
a895 2
   that is, it does not depend solely upon the section name.  This is
   called via bfd_map_over_sections.  */
a904 6
  struct sec_link_once
    {
      struct sec_link_once *next;
      asection *sec;
    };
  static struct sec_link_once *sec_link_once_list;
d907 2
a908 1
  struct sec_link_once *l;
d943 9
a951 6
  for (l = sec_link_once_list; l != NULL; l = l->next)
    {
      if (strcmp (name, bfd_get_section_name (l->sec->owner, l->sec)) == 0
	  && (sec->comdat == NULL
	      || l->sec->comdat == NULL
	      || strcmp (sec->comdat->name, l->sec->comdat->name) == 0))
d1000 5
a1004 1
  /* This is the first section with this name.  Record it.  */
a1005 1
  l = (struct sec_link_once *) xmalloc (sizeof *l);
d1007 34
a1040 2
  l->next = sec_link_once_list;
  sec_link_once_list = l;
d3910 2
d3917 2
@


1.12
log
@	* ldlang.c (open_output): Change local variable desired_endian
	from int to enum bfd_endian.
@
text
@d865 5
a869 3
   been linked.  This code assumes that all relevant sections have the
   SEC_LINK_ONCE flag set; that is, it does not depend solely upon the
   section name.  This is called via bfd_map_over_sections.  */
d924 4
a927 1
      if (strcmp (name, bfd_get_section_name (l->sec->owner, l->sec)) == 0)
d940 6
a945 2
	      einfo (_("%P: %B: warning: ignoring duplicate section `%s'\n"),
		     abfd, name);
d964 4
a967 1
	     create a lang_input_section structure for this section.  */
d969 2
@


1.11
log
@	From Wally Iimura <iimura@@microunity.com>:
	* ldlang.c (lang_size_sections): When checking whether an address
	is within a region, don't get confused by wrapping around at the
	end of the address space.
@
text
@d1641 1
a1641 1
      int desired_endian;
@


1.10
log
@	* ldlang.c (wild_doit): Update for renaming of SEC_SHORT to
	SEC_SMALL_DATA.
@
text
@d2743 1
a2743 1
		& (SEC_ALLOC | SEC_LOAD)))
d2747 12
a2758 4
		/* Make sure this isn't silly.  */
		if (os->region->current < os->region->origin
		    || (os->region->current - os->region->origin
			> os->region->length))
@


1.9
log
@	* ldlang.c (lang_gc_sections): Only handle the start symbol
	specially if there is one.
@
text
@d1111 3
a1113 3
      /* Copy over SEC_SHORT.  */
      if (section->flags & SEC_SHORT)
	section->output_section->flags |= SEC_SHORT;
@


1.8
log
@Improve selection of output format
@
text
@d3789 7
a3795 4

  fake_list_start.next = ldlang_undef_chain_list_head;
  if (entry_symbol == NULL)
    fake_list_start.name = "start";
d3797 1
a3797 1
    fake_list_start.name = (char *) entry_symbol;
d3799 1
a3799 1
  for (ulist = &fake_list_start; ulist; ulist = ulist->next)
@


1.7
log
@        * ldlang.c (wild_doit): Copy SEC_SHORT to output section.
@
text
@d154 7
a303 2
  lang_input_statement_type *f;

d307 1
a307 3
      for (f = (lang_input_statement_type *) file_chain.head;
	   f != (lang_input_statement_type *) NULL;
	   f = (lang_input_statement_type *) f->next)
d314 1
a314 3
      for (f = (lang_input_statement_type *) file_chain.head;
	   f != (lang_input_statement_type *) NULL;
	   f = (lang_input_statement_type *) f->next)
d322 2
d1455 156
d1615 1
a1615 1
     const char *name;
d1617 1
a1617 1
  bfd *output;
d1619 1
d1622 2
a1623 1
      if (current_target != (char *) NULL)
d1625 23
d1649 25
a1673 1
	output_target = default_target;
d1675 1
d1681 2
a1682 3
	{
	  einfo (_("%P%F: target %s not found\n"), output_target);
	}
a1704 3



d1781 1
a1781 1
	  if (s->input_statement.real == true)
d3419 1
a3419 5
  lang_input_statement_type *file;

  for (file = (lang_input_statement_type *) file_chain.head;
       file != (lang_input_statement_type *) NULL;
       file = (lang_input_statement_type *) file->next)
d3544 1
a3544 5
  lang_input_statement_type *f;

  for (f = (lang_input_statement_type *) file_chain.head;
       f != (lang_input_statement_type *) NULL;
       f = (lang_input_statement_type *) f->next)
d3558 1
a3558 5
  lang_input_statement_type *f;

  for (f = (lang_input_statement_type *) file_chain.head;
       f != (lang_input_statement_type *) NULL;
       f = (lang_input_statement_type *) f->next)
d3560 1
a3560 1
      asection *s;
@


1.6
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Fill in structure initializations.
@
text
@d1108 4
@


1.5
log
@	* ldlang.c: Revert change of 1999-06-23.
@
text
@d158 1
a158 1
lang_statement_list_type file_chain = { 0 };
d1433 1
a1433 1
     const char *target;
d2295 1
a2295 1
     boolean relax;
d3026 1
a3026 1
ignore_bfd_errors (const char *s, ...)
d3029 1
a3029 1
     const char *s;
d3529 2
a3530 2
     lang_input_statement_type *file;
     void *data;
@


1.4
log
@	* ldlang.c (section_already_linked): Only discard link once
	sections if we are building constructors.
@
text
@a892 5
  /* If we aren't building constructors, don't discard link once
     sections.  Otherwise we can get confused when generating relocs.  */
  if (! config.build_constructors)
    return;

d897 17
@


1.3
log
@This fixes ! to work as documented in a memory region attribute list.
	From Thomas Zenker <thz@@lennartz-electronic.de>:
	* ldgram.y (attributes_opt): Use attributes_list instead of NAME.
	(attributes_list, attributes_string): New nonterminals.
	* ldlang.c (lang_set_flags): Add invert parameter.  Don't handle
	'!'.
	* ldlang.c (lang_set_flags): Update declaration.
@
text
@d893 5
@


1.2
log
@     * ldlang.c (walk_wild, walk_wild_file, walk_wild_section,
     output_section_callback, gc_section_callback): New functions for
     generic section walks.
     (wild, lang_gc_wild): Use walk_wild.
     (wild_file, lang_gc_wild_file): Deleted. Common logic moved to
     walk_wild_file.
     (wild_section, lang_gc_wild_section): Deleted. Common logic moved
     to walk_fild_section.  Unique logic moved into callbacks
     output_section_callback and gc_section_callback.
@
text
@d3258 1
a3258 1
lang_set_flags (ptr, flags)
d3261 1
d3263 1
a3263 1
  flagword *ptr_flags = &ptr->flags;
d3265 1
a3265 1
  ptr->flags = ptr->not_flags = 0;
a3269 4
	case '!':
	  ptr_flags = (ptr_flags == &ptr->flags) ? &ptr->not_flags : &ptr->flags;
	  break;

@


1.1
log
@Initial revision
@
text
@a79 4
static void wild_section PARAMS ((lang_wild_statement_type *ptr,
				  const char *section,
				  lang_input_statement_type *file,
				  lang_output_section_statement_type *output));
a82 3
static void wild_file PARAMS ((lang_wild_statement_type *, const char *,
			       lang_input_statement_type *,
			       lang_output_section_statement_type *));
a137 6
static void lang_gc_wild_section
  PARAMS ((lang_wild_statement_type *, const char *,
	   lang_input_statement_type *));
static void lang_gc_wild_file
  PARAMS ((lang_wild_statement_type *, const char *,
	   lang_input_statement_type *));
d144 10
a154 1

d192 136
d1205 1
a1205 1
wild_section (ptr, section, file, output)
d1207 1
a1207 1
     const char *section;
d1209 1
a1209 1
     lang_output_section_statement_type *output;
d1211 19
a1229 3

  /* Don't process sections from files which were excluded. */
  if (ptr->exclude_filename != NULL)
d1231 21
a1251 88
      boolean match;

      if (wildcardp (ptr->exclude_filename))
         match = fnmatch (ptr->exclude_filename, file->filename, 0) == 0 ? true : false;
      else
         match = strcmp (ptr->exclude_filename, file->filename) == 0 ? true : false;

      if (match)
        return;
    }

  if (file->just_syms_flag == false)
    {
      register asection *s;
      boolean wildcard;

      if (section == NULL)
	wildcard = false;
      else
	wildcard = wildcardp (section);

      for (s = file->the_bfd->sections; s != NULL; s = s->next)
	{
	  boolean match;

	  /* Attach all sections named SECTION.  If SECTION is NULL,
	     then attach all sections.

	     Previously, if SECTION was NULL, this code did not call
	     wild_doit if the SEC_IS_COMMON flag was set for the
	     section.  I did not understand that, and I took it out.
	     --ian@@cygnus.com.  */

	  if (section == NULL)
	    match = true;
	  else
	    {
	      const char *name;

	      name = bfd_get_section_name (file->the_bfd, s);
	      if (wildcard)
		match = fnmatch (section, name, 0) == 0 ? true : false;
	      else
		match = strcmp (section, name) == 0 ? true : false;
	    }

	  if (match)
	    {
	      lang_statement_union_type *before;

	      /* If the wild pattern was marked KEEP, the member sections
		 should be as well.  */
	      if (ptr->keep_sections)
		s->flags |= SEC_KEEP;

	      before = wild_sort (ptr, file, s);

	      /* Here BEFORE points to the lang_input_section which
		 should follow the one we are about to add.  If BEFORE
		 is NULL, then the section should just go at the end
		 of the current list.  */

	      if (before == NULL)
		wild_doit (&ptr->children, s, output, file);
	      else
		{
		  lang_statement_list_type list;
		  lang_statement_union_type **pp;

		  lang_list_init (&list);
		  wild_doit (&list, s, output, file);

		  /* If we are discarding the section, LIST.HEAD will
                     be NULL.  */
		  if (list.head != NULL)
		    {
		      ASSERT (list.head->next == NULL);

		      for (pp = &ptr->children.head;
			   *pp != before;
			   pp = &(*pp)->next)
			ASSERT (*pp != NULL);

		      list.head->next = *pp;
		      *pp = list.head;
		    }
		}
	    }
d1404 1
a1404 37
/* Handle a wild statement for a single file F.  */

static void
wild_file (s, section, f, output)
     lang_wild_statement_type *s;
     const char *section;
     lang_input_statement_type *f;
     lang_output_section_statement_type *output;
{
  if (f->the_bfd == NULL
      || ! bfd_check_format (f->the_bfd, bfd_archive))
    wild_section (s, section, f, output);
  else
    {
      bfd *member;

      /* This is an archive file.  We must map each member of the
	 archive separately.  */
      member = bfd_openr_next_archived_file (f->the_bfd, (bfd *) NULL);
      while (member != NULL)
	{
	  /* When lookup_name is called, it will call the add_symbols
	     entry point for the archive.  For each element of the
	     archive which is included, BFD will call ldlang_add_file,
	     which will set the usrdata field of the member to the
	     lang_input_statement.  */
	  if (member->usrdata != NULL)
	    {
	      wild_section (s, section,
			    (lang_input_statement_type *) member->usrdata,
			    output);
	    }

	  member = bfd_openr_next_archived_file (f->the_bfd, member);
	}
    }
}
d1419 1
a1419 28
  lang_input_statement_type *f;

  if (file == (char *) NULL)
    {
      /* Perform the iteration over all files in the list */
      for (f = (lang_input_statement_type *) file_chain.head;
	   f != (lang_input_statement_type *) NULL;
	   f = (lang_input_statement_type *) f->next)
	{
	  wild_file (s, section, f, output);
	}
    }
  else if (wildcardp (file))
    {
      for (f = (lang_input_statement_type *) file_chain.head;
	   f != (lang_input_statement_type *) NULL;
	   f = (lang_input_statement_type *) f->next)
	{
	  if (fnmatch (file, f->filename, FNM_FILE_NAME) == 0)
	    wild_file (s, section, f, output);
	}
    }
  else
    {
      /* Perform the iteration over a single file */
      f = lookup_name (file);
      wild_file (s, section, f, output);
    }
a3507 3
/* ??? At some point this traversal for GC should share code with the
   traversal for manipulating the output file.  */

d3512 1
a3512 1
lang_gc_wild_section (ptr, section, file)
d3514 1
a3514 1
     const char *section;
d3516 1
d3518 4
a3521 72
  if (file->just_syms_flag == false)
    {
      register asection *s;
      boolean wildcard;

      if (section == NULL)
	wildcard = false;
      else
	wildcard = wildcardp (section);

      for (s = file->the_bfd->sections; s != NULL; s = s->next)
	{
	  boolean match;

	  if (section == NULL)
	    match = true;
	  else
	    {
	      const char *name;

	      name = bfd_get_section_name (file->the_bfd, s);
	      if (wildcard)
		match = fnmatch (section, name, 0) == 0 ? true : false;
	      else
		match = strcmp (section, name) == 0 ? true : false;
	    }

	  if (match)
	    {
	      /* If the wild pattern was marked KEEP, the member sections
		 should be as well.  */
	      if (ptr->keep_sections)
		s->flags |= SEC_KEEP;
	    }
	}
    }
}

/* Handle a wild statement for a single file F.  */

static void
lang_gc_wild_file (s, section, f)
     lang_wild_statement_type *s;
     const char *section;
     lang_input_statement_type *f;
{
  if (f->the_bfd == NULL
      || ! bfd_check_format (f->the_bfd, bfd_archive))
    lang_gc_wild_section (s, section, f);
  else
    {
      bfd *member;

      /* This is an archive file.  We must map each member of the
	 archive separately.  */
      member = bfd_openr_next_archived_file (f->the_bfd, (bfd *) NULL);
      while (member != NULL)
	{
	  /* When lookup_name is called, it will call the add_symbols
	     entry point for the archive.  For each element of the
	     archive which is included, BFD will call ldlang_add_file,
	     which will set the usrdata field of the member to the
	     lang_input_statement.  */
	  if (member->usrdata != NULL)
	    {
	      lang_gc_wild_section (s, section,
			    (lang_input_statement_type *) member->usrdata);
	    }

	  member = bfd_openr_next_archived_file (f->the_bfd, member);
	}
    }
d3533 1
a3533 28
  lang_input_statement_type *f;

  if (file == (char *) NULL)
    {
      /* Perform the iteration over all files in the list */
      for (f = (lang_input_statement_type *) file_chain.head;
	   f != (lang_input_statement_type *) NULL;
	   f = (lang_input_statement_type *) f->next)
	{
	  lang_gc_wild_file (s, section, f);
	}
    }
  else if (wildcardp (file))
    {
      for (f = (lang_input_statement_type *) file_chain.head;
	   f != (lang_input_statement_type *) NULL;
	   f = (lang_input_statement_type *) f->next)
	{
	  if (fnmatch (file, f->filename, FNM_FILE_NAME) == 0)
	    lang_gc_wild_file (s, section, f);
	}
    }
  else
    {
      /* Perform the iteration over a single file */
      f = lookup_name (file);
      lang_gc_wild_file (s, section, f);
    }
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

