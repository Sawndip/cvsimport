head	1.43;
access;
symbols
	binutils-2_24-branch:1.43.0.2
	binutils-2_24-branchpoint:1.43
	binutils-2_21_1:1.33
	binutils-2_23_2:1.40
	binutils-2_23_1:1.40
	binutils-2_23:1.40
	binutils-2_23-branch:1.40.0.2
	binutils-2_23-branchpoint:1.40
	binutils-2_22_branch:1.36.0.4
	binutils-2_22:1.36
	binutils-2_22-branch:1.36.0.2
	binutils-2_22-branchpoint:1.36
	binutils-2_21:1.33
	binutils-2_21-branch:1.33.0.2
	binutils-2_21-branchpoint:1.33
	binutils-2_20_1:1.28
	binutils-2_20:1.28
	binutils-arc-20081103-branch:1.24.0.8
	binutils-arc-20081103-branchpoint:1.24
	binutils-2_20-branch:1.28.0.2
	binutils-2_20-branchpoint:1.28
	dje-cgen-play1-branch:1.27.0.2
	dje-cgen-play1-branchpoint:1.27
	arc-20081103-branch:1.24.0.6
	arc-20081103-branchpoint:1.24
	binutils-2_19_1:1.24
	binutils-2_19:1.24
	binutils-2_19-branch:1.24.0.4
	binutils-2_19-branchpoint:1.24
	binutils-2_18:1.24
	binutils-2_18-branch:1.24.0.2
	binutils-2_18-branchpoint:1.24
	binutils-csl-coldfire-4_1-32:1.21.2.1
	binutils-csl-sourcerygxx-4_1-32:1.21.2.1
	binutils-csl-innovasic-fido-3_4_4-33:1.21.2.1
	binutils-csl-sourcerygxx-3_4_4-32:1.19
	binutils-csl-coldfire-4_1-30:1.21.2.1
	binutils-csl-sourcerygxx-4_1-30:1.21.2.1
	binutils-csl-coldfire-4_1-28:1.21.2.1
	binutils-csl-sourcerygxx-4_1-29:1.21.2.1
	binutils-csl-sourcerygxx-4_1-28:1.21.2.1
	binutils-csl-arm-2006q3-27:1.21.2.1
	binutils-csl-sourcerygxx-4_1-27:1.21.2.1
	binutils-csl-arm-2006q3-26:1.21.2.1
	binutils-csl-sourcerygxx-4_1-26:1.21.2.1
	binutils-csl-sourcerygxx-4_1-25:1.21.2.1
	binutils-csl-sourcerygxx-4_1-24:1.21.2.1
	binutils-csl-sourcerygxx-4_1-23:1.21.2.1
	binutils-csl-sourcerygxx-4_1-21:1.21.2.1
	binutils-csl-arm-2006q3-21:1.21.2.1
	binutils-csl-sourcerygxx-4_1-22:1.21.2.1
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.21.2.1
	binutils-csl-sourcerygxx-4_1-20:1.21.2.1
	binutils-csl-arm-2006q3-19:1.21.2.1
	binutils-csl-sourcerygxx-4_1-19:1.21.2.1
	binutils-csl-sourcerygxx-4_1-18:1.21.2.1
	binutils-csl-renesas-4_1-9:1.21.2.1
	binutils-csl-sourcerygxx-3_4_4-25:1.19
	binutils-csl-renesas-4_1-8:1.21
	binutils-csl-renesas-4_1-7:1.21
	binutils-csl-renesas-4_1-6:1.21
	binutils-csl-sourcerygxx-4_1-17:1.21
	binutils-csl-sourcerygxx-4_1-14:1.21
	binutils-csl-sourcerygxx-4_1-15:1.21
	binutils-csl-sourcerygxx-4_1-13:1.21
	binutils-2_17:1.22
	binutils-csl-sourcerygxx-4_1-12:1.21
	binutils-csl-sourcerygxx-3_4_4-21:1.21
	binutils-csl-wrs-linux-3_4_4-24:1.19
	binutils-csl-wrs-linux-3_4_4-23:1.19
	binutils-csl-sourcerygxx-4_1-9:1.21
	binutils-csl-sourcerygxx-4_1-8:1.21
	binutils-csl-sourcerygxx-4_1-7:1.21
	binutils-csl-arm-2006q1-6:1.21
	binutils-csl-sourcerygxx-4_1-6:1.21
	binutils-csl-wrs-linux-3_4_4-22:1.19
	binutils-csl-coldfire-4_1-11:1.21
	binutils-csl-sourcerygxx-3_4_4-19:1.21
	binutils-csl-coldfire-4_1-10:1.21
	binutils-csl-sourcerygxx-4_1-5:1.21
	binutils-csl-sourcerygxx-4_1-4:1.21
	binutils-csl-wrs-linux-3_4_4-21:1.19
	binutils-csl-morpho-4_1-4:1.21
	binutils-csl-sourcerygxx-3_4_4-17:1.21
	binutils-csl-wrs-linux-3_4_4-20:1.19
	binutils-2_17-branch:1.22.0.2
	binutils-2_17-branchpoint:1.22
	binutils-csl-2_17-branch:1.21.0.2
	binutils-csl-2_17-branchpoint:1.21
	binutils-csl-gxxpro-3_4-branch:1.19.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.19
	binutils-2_16_1:1.19
	binutils-csl-arm-2005q1b:1.19
	binutils-2_16:1.19
	binutils-csl-arm-2005q1a:1.19
	binutils-csl-arm-2005q1-branch:1.19.0.4
	binutils-csl-arm-2005q1-branchpoint:1.19
	binutils-2_16-branch:1.19.0.2
	binutils-2_16-branchpoint:1.19
	csl-arm-2004-q3d:1.17
	csl-arm-2004-q3:1.17
	binutils-2_15:1.17
	binutils-2_15-branchpoint:1.17
	csl-arm-2004-q1a:1.17
	csl-arm-2004-q1:1.17
	binutils-2_15-branch:1.17.0.6
	cagney_bfdfile-20040213-branch:1.17.0.4
	cagney_bfdfile-20040213-branchpoint:1.17
	cagney_bigcore-20040122-branch:1.17.0.2
	cagney_bigcore-20040122-branchpoint:1.17
	csl-arm-2003-q4:1.17
	binutils-2_14:1.14
	binutils-2_14-branch:1.14.0.2
	binutils-2_14-branchpoint:1.14
	binutils-2_13_2_1:1.9
	binutils-2_13_2:1.9
	binutils-2_13_1:1.9
	binutils-2_13:1.9
	binutils-2_13-branchpoint:1.9
	binutils-2_13-branch:1.9.0.4
	binutils-2_12_1:1.9
	binutils-2_12:1.9
	binutils-2_12-branch:1.9.0.2
	binutils-2_12-branchpoint:1.9
	cygnus_cvs_20020108_pre:1.9
	binutils-2_11_2:1.5.4.1
	binutils-2_11_1:1.5.4.1
	binutils-2_11:1.5
	x86_64versiong3:1.5
	binutils-2_11-branch:1.5.0.4
	binutils-2_10_1:1.5
	binutils-2_10:1.5
	binutils-2_10-branch:1.5.0.2
	binutils-2_10-branchpoint:1.5
	binutils_latest_snapshot:1.43
	repo-unification-2000-02-06:1.5
	binu_ss_19990721:1.1.1.1
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.43
date	2013.09.17.13.57.21;	author nickc;	state Exp;
branches;
next	1.42;

1.42
date	2013.01.25.11.39.42;	author ktietz;	state Exp;
branches;
next	1.41;

1.41
date	2013.01.10.20.08.02;	author hjl;	state Exp;
branches;
next	1.40;

1.40
date	2012.02.24.14.20.19;	author ktietz;	state Exp;
branches;
next	1.39;

1.39
date	2012.02.19.21.18.08;	author ktietz;	state Exp;
branches;
next	1.38;

1.38
date	2012.02.13.20.42.07;	author ktietz;	state Exp;
branches;
next	1.37;

1.37
date	2012.02.11.20.02.03;	author ktietz;	state Exp;
branches;
next	1.36;

1.36
date	2011.04.18.15.40.27;	author ktietz;	state Exp;
branches;
next	1.35;

1.35
date	2011.04.18.15.38.03;	author ktietz;	state Exp;
branches;
next	1.34;

1.34
date	2011.04.13.12.53.36;	author ktietz;	state Exp;
branches;
next	1.33;

1.33
date	2010.05.25.10.05.16;	author ktietz;	state Exp;
branches;
next	1.32;

1.32
date	2009.12.17.19.33.59;	author davek;	state Exp;
branches;
next	1.31;

1.31
date	2009.12.11.13.42.14;	author nickc;	state Exp;
branches;
next	1.30;

1.30
date	2009.10.23.11.40.17;	author ktietz;	state Exp;
branches;
next	1.29;

1.29
date	2009.10.23.11.33.44;	author ktietz;	state Exp;
branches;
next	1.28;

1.28
date	2009.09.02.07.25.35;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2009.05.27.18.40.53;	author davek;	state Exp;
branches;
next	1.26;

1.26
date	2009.05.19.16.08.07;	author davek;	state Exp;
branches;
next	1.25;

1.25
date	2009.04.29.01.17.54;	author amodra;	state Exp;
branches;
next	1.24;

1.24
date	2007.07.06.14.09.41;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	2007.04.26.14.46.59;	author amodra;	state Exp;
branches;
next	1.22;

1.22
date	2006.04.01.04.51.23;	author dannysmith;	state Exp;
branches;
next	1.21;

1.21
date	2006.02.01.21.28.29;	author dannysmith;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2005.05.12.07.32.02;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	2005.03.03.11.51.55;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2005.01.16.09.18.35;	author dannysmith;	state Exp;
branches;
next	1.17;

1.17
date	2003.10.19.15.21.31;	author schwab;	state Exp;
branches;
next	1.16;

1.16
date	2003.06.28.05.28.54;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2003.06.27.08.10.57;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2003.03.18.21.33.43;	author dannysmith;	state Exp;
branches;
next	1.13;

1.13
date	2003.03.13.09.39.09;	author dannysmith;	state Exp;
branches;
next	1.12;

1.12
date	2003.03.12.08.38.16;	author dannysmith;	state Exp;
branches;
next	1.11;

1.11
date	2003.01.28.11.39.43;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2002.11.06.19.36.20;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2001.09.19.05.33.33;	author hjl;	state Exp;
branches;
next	1.8;

1.8
date	2001.09.18.10.10.20;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2001.08.21.11.42.57;	author aj;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.13.06.14.27;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2000.01.04.23.33.29;	author nickc;	state Exp;
branches
	1.5.4.1;
next	1.4;

1.4
date	2000.01.04.23.30.51;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	99.09.28.20.22.55;	author dj;	state Exp;
branches;
next	1.2;

1.2
date	99.09.12.15.27.47;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.29.06;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.21.2.1
date	2006.08.22.15.08.43;	author jsm28;	state Exp;
branches;
next	;

1.5.4.1
date	2001.06.07.03.17.14;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.29.06;	author rth;	state Exp;
branches;
next	;


desc
@@


1.43
log
@	PR ld/15957
	* deffilep.y (def_file_add_directive): Avoid readin past end of
	buffer.
@
text
@%{ /* deffilep.y - parser for .def files */

/*   Copyright 1995, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2006,
     2007, 2009 Free Software Foundation, Inc.

     This file is part of GNU Binutils.

     This program is free software; you can redistribute it and/or modify
     it under the terms of the GNU General Public License as published by
     the Free Software Foundation; either version 3 of the License, or
     (at your option) any later version.

     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program; if not, write to the Free Software
     Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
     MA 02110-1301, USA.  */

#include "sysdep.h"
#include "libiberty.h"
#include "safe-ctype.h"
#include "bfd.h"
#include "ld.h"
#include "ldmisc.h"
#include "deffile.h"

#define TRACE 0

#define ROUND_UP(a, b) (((a)+((b)-1))&~((b)-1))

/* Remap normal yacc parser interface names (yyparse, yylex, yyerror, etc),
   as well as gratuitiously global symbol names, so we can have multiple
   yacc generated parsers in ld.  Note that these are only the variables
   produced by yacc.  If other parser generators (bison, byacc, etc) produce
   additional global names that conflict at link time, then those parser
   generators need to be fixed instead of adding those names to this list.  */

#define	yymaxdepth def_maxdepth
#define	yyparse	def_parse
#define	yylex	def_lex
#define	yyerror	def_error
#define	yylval	def_lval
#define	yychar	def_char
#define	yydebug	def_debug
#define	yypact	def_pact
#define	yyr1	def_r1
#define	yyr2	def_r2
#define	yydef	def_def
#define	yychk	def_chk
#define	yypgo	def_pgo
#define	yyact	def_act
#define	yyexca	def_exca
#define yyerrflag def_errflag
#define yynerrs	def_nerrs
#define	yyps	def_ps
#define	yypv	def_pv
#define	yys	def_s
#define	yy_yys	def_yys
#define	yystate	def_state
#define	yytmp	def_tmp
#define	yyv	def_v
#define	yy_yyv	def_yyv
#define	yyval	def_val
#define	yylloc	def_lloc
#define yyreds	def_reds		/* With YYDEBUG defined.  */
#define yytoks	def_toks		/* With YYDEBUG defined.  */
#define yylhs	def_yylhs
#define yylen	def_yylen
#define yydefred def_yydefred
#define yydgoto	def_yydgoto
#define yysindex def_yysindex
#define yyrindex def_yyrindex
#define yygindex def_yygindex
#define yytable	 def_yytable
#define yycheck	 def_yycheck

typedef struct def_pool_str {
  struct def_pool_str *next;
  char data[1];
} def_pool_str;

static def_pool_str *pool_strs = NULL;

static char *def_pool_alloc (size_t sz);
static char *def_pool_strdup (const char *str);
static void def_pool_free (void);

static void def_description (const char *);
static void def_exports (const char *, const char *, int, int, const char *);
static void def_heapsize (int, int);
static void def_import (const char *, const char *, const char *, const char *,
			int, const char *);
static void def_image_name (const char *, bfd_vma, int);
static void def_section (const char *, int);
static void def_section_alt (const char *, const char *);
static void def_stacksize (int, int);
static void def_version (int, int);
static void def_directive (char *);
static void def_aligncomm (char *str, int align);
static int def_parse (void);
static int def_error (const char *);
static int def_lex (void);

static int lex_forced_token = 0;
static const char *lex_parse_string = 0;
static const char *lex_parse_string_end = 0;

%}

%union {
  char *id;
  const char *id_const;
  int number;
  bfd_vma vma;
  char *digits;
};

%token NAME LIBRARY DESCRIPTION STACKSIZE_K HEAPSIZE CODE DATAU DATAL
%token SECTIONS EXPORTS IMPORTS VERSIONK BASE CONSTANTU CONSTANTL
%token PRIVATEU PRIVATEL ALIGNCOMM
%token READ WRITE EXECUTE SHARED NONAMEU NONAMEL DIRECTIVE EQUAL
%token <id> ID
%token <digits> DIGITS
%type  <number> NUMBER
%type  <vma> VMA opt_base
%type  <digits> opt_digits
%type  <number> opt_ordinal
%type  <number> attr attr_list opt_number exp_opt_list exp_opt
%type  <id> opt_name opt_name2 opt_equal_name anylang_id opt_id
%type  <id> opt_equalequal_name
%type  <id_const> keyword_as_name

%%

start: start command
	| command
	;

command:
		NAME opt_name opt_base { def_image_name ($2, $3, 0); }
	|	LIBRARY opt_name opt_base { def_image_name ($2, $3, 1); }
	|	DESCRIPTION ID { def_description ($2);}
	|	STACKSIZE_K NUMBER opt_number { def_stacksize ($2, $3);}
	|	HEAPSIZE NUMBER opt_number { def_heapsize ($2, $3);}
	|	CODE attr_list { def_section ("CODE", $2);}
	|	DATAU attr_list  { def_section ("DATA", $2);}
	|	SECTIONS seclist
	|	EXPORTS explist
	|	IMPORTS implist
	|	VERSIONK NUMBER { def_version ($2, 0);}
	|	VERSIONK NUMBER '.' NUMBER { def_version ($2, $4);}
	|	DIRECTIVE ID { def_directive ($2);}
	|	ALIGNCOMM anylang_id ',' NUMBER { def_aligncomm ($2, $4);}
	;


explist:
		/* EMPTY */
	|	expline
	|	explist expline
	;

expline:
		/* The opt_comma is necessary to support both the usual
		  DEF file syntax as well as .drectve syntax which
		  mandates <expsym>,<expoptlist>.  */
		opt_name2 opt_equal_name opt_ordinal opt_comma exp_opt_list opt_comma opt_equalequal_name
			{ def_exports ($1, $2, $3, $5, $7); }
	;
exp_opt_list:
		/* The opt_comma is necessary to support both the usual
		   DEF file syntax as well as .drectve syntax which
		   allows for comma separated opt list.  */
		exp_opt opt_comma exp_opt_list { $$ = $1 | $3; }
	|	{ $$ = 0; }
	;
exp_opt:
		NONAMEU		{ $$ = 1; }
	|	NONAMEL		{ $$ = 1; }
	|	CONSTANTU	{ $$ = 2; }
	|	CONSTANTL	{ $$ = 2; }
	|	DATAU		{ $$ = 4; }
	|	DATAL		{ $$ = 4; }
	|	PRIVATEU	{ $$ = 8; }
	|	PRIVATEL	{ $$ = 8; }
	;
implist:
		implist impline
	|	impline
	;

impline:
               ID '=' ID '.' ID '.' ID opt_equalequal_name
                 { def_import ($1, $3, $5, $7, -1, $8); }
       |       ID '=' ID '.' ID '.' NUMBER opt_equalequal_name
				 { def_import ($1, $3, $5,  0, $7, $8); }
       |       ID '=' ID '.' ID opt_equalequal_name
                 { def_import ($1, $3,  0, $5, -1, $6); }
       |       ID '=' ID '.' NUMBER opt_equalequal_name
                 { def_import ($1, $3,  0,  0, $5, $6); }
       |       ID '.' ID '.' ID opt_equalequal_name
                 { def_import( 0, $1, $3, $5, -1, $6); }
       |       ID '.' ID opt_equalequal_name
                 { def_import ( 0, $1,  0, $3, -1, $4); }
;

seclist:
		seclist secline
	|	secline
	;

secline:
	ID attr_list { def_section ($1, $2);}
	| ID ID { def_section_alt ($1, $2);}
	;

attr_list:
	attr_list opt_comma attr { $$ = $1 | $3; }
	| attr { $$ = $1; }
	;

opt_comma:
	','
	|
	;
opt_number: ',' NUMBER { $$=$2;}
	|	   { $$=-1;}
	;

attr:
		READ	{ $$ = 1;}
	|	WRITE	{ $$ = 2;}
	|	EXECUTE	{ $$=4;}
	|	SHARED	{ $$=8;}
	;


keyword_as_name: BASE { $$ = "BASE"; }
	 | CODE { $$ = "CODE"; }
	 | CONSTANTU { $$ = "CONSTANT"; }
	 | CONSTANTL { $$ = "constant"; }
	 | DATAU { $$ = "DATA"; }
	 | DATAL { $$ = "data"; }
	 | DESCRIPTION { $$ = "DESCRIPTION"; }
	 | DIRECTIVE { $$ = "DIRECTIVE"; }
	 | EXECUTE { $$ = "EXECUTE"; }
	 | EXPORTS { $$ = "EXPORTS"; }
	 | HEAPSIZE { $$ = "HEAPSIZE"; }
	 | IMPORTS { $$ = "IMPORTS"; }
/* Disable LIBRARY keyword as valid symbol-name.  This is necessary
   for libtool, which places this command after EXPORTS command.
   This behavior is illegal by specification, but sadly required by
   by compatibility reasons.
   See PR binutils/13710
	 | LIBRARY { $$ = "LIBRARY"; } */
	 | NAME { $$ = "NAME"; }
	 | NONAMEU { $$ = "NONAME"; }
	 | NONAMEL { $$ = "noname"; }
	 | PRIVATEU { $$ = "PRIVATE"; }
	 | PRIVATEL { $$ = "private"; }
	 | READ { $$ = "READ"; }
	 | SHARED  { $$ = "SHARED"; }
	 | STACKSIZE_K { $$ = "STACKSIZE"; }
	 | VERSIONK { $$ = "VERSION"; }
	 | WRITE { $$ = "WRITE"; }
	 ;

opt_name2: ID { $$ = $1; }
	| '.' keyword_as_name
	  {
	    char *name = xmalloc (strlen ($2) + 2);
	    sprintf (name, ".%s", $2);
	    $$ = name;
	  }
	| '.' opt_name2
	  {
	    char *name = def_pool_alloc (strlen ($2) + 2);
	    sprintf (name, ".%s", $2);
	    $$ = name;
	  }
	| keyword_as_name '.' opt_name2
	  {
	    char *name = def_pool_alloc (strlen ($1) + 1 + strlen ($3) + 1);
	    sprintf (name, "%s.%s", $1, $3);
	    $$ = name;
	  }
	| ID '.' opt_name2
	  {
	    char *name = def_pool_alloc (strlen ($1) + 1 + strlen ($3) + 1);
	    sprintf (name, "%s.%s", $1, $3);
	    $$ = name;
	  }
	;

opt_name: opt_name2 { $$ = $1; }
	|		{ $$ = ""; }
	;

opt_equalequal_name: EQUAL ID	{ $$ = $2; }
	|							{ $$ = 0; }
	;

opt_ordinal:
	  '@@' NUMBER     { $$ = $2;}
	|                { $$ = -1;}
	;

opt_equal_name:
          '=' opt_name2	{ $$ = $2; }
        | 		{ $$ =  0; }
	;

opt_base: BASE	'=' VMA	{ $$ = $3;}
	|	{ $$ = (bfd_vma) -1;}
	;

anylang_id: ID		{ $$ = $1; }
	| '.' ID
	  {
	    char *id = def_pool_alloc (strlen ($2) + 2);
	    sprintf (id, ".%s", $2);
	    $$ = id;
	  }
	| anylang_id '.' opt_digits opt_id
	  {
	    char *id = def_pool_alloc (strlen ($1) + 1 + strlen ($3) + strlen ($4) + 1);
	    sprintf (id, "%s.%s%s", $1, $3, $4);
	    $$ = id;
	  }
	;

opt_digits: DIGITS	{ $$ = $1; }
	|		{ $$ = ""; }
	;

opt_id: ID		{ $$ = $1; }
	|		{ $$ = ""; }
	;

NUMBER: DIGITS		{ $$ = strtoul ($1, 0, 0); }
	;
VMA: DIGITS		{ $$ = (bfd_vma) strtoull ($1, 0, 0); }

%%

/*****************************************************************************
 API
 *****************************************************************************/

static FILE *the_file;
static const char *def_filename;
static int linenumber;
static def_file *def;
static int saw_newline;

struct directive
  {
    struct directive *next;
    char *name;
    int len;
  };

static struct directive *directives = 0;

def_file *
def_file_empty (void)
{
  def_file *rv = xmalloc (sizeof (def_file));
  memset (rv, 0, sizeof (def_file));
  rv->is_dll = -1;
  rv->base_address = (bfd_vma) -1;
  rv->stack_reserve = rv->stack_commit = -1;
  rv->heap_reserve = rv->heap_commit = -1;
  rv->version_major = rv->version_minor = -1;
  return rv;
}

def_file *
def_file_parse (const char *filename, def_file *add_to)
{
  struct directive *d;

  the_file = fopen (filename, "r");
  def_filename = filename;
  linenumber = 1;
  if (!the_file)
    {
      perror (filename);
      return 0;
    }
  if (add_to)
    {
      def = add_to;
    }
  else
    {
      def = def_file_empty ();
    }

  saw_newline = 1;
  if (def_parse ())
    {
      def_file_free (def);
      fclose (the_file);
      def_pool_free ();
      return 0;
    }

  fclose (the_file);

  while ((d = directives) != NULL)
    {
#if TRACE
      printf ("Adding directive %08x `%s'\n", d->name, d->name);
#endif
      def_file_add_directive (def, d->name, d->len);
      directives = d->next;
      free (d->name);
      free (d);
    }
  def_pool_free ();

  return def;
}

void
def_file_free (def_file *fdef)
{
  int i;

  if (!fdef)
    return;
  if (fdef->name)
    free (fdef->name);
  if (fdef->description)
    free (fdef->description);

  if (fdef->section_defs)
    {
      for (i = 0; i < fdef->num_section_defs; i++)
	{
	  if (fdef->section_defs[i].name)
	    free (fdef->section_defs[i].name);
	  if (fdef->section_defs[i].class)
	    free (fdef->section_defs[i].class);
	}
      free (fdef->section_defs);
    }

  if (fdef->exports)
    {
      for (i = 0; i < fdef->num_exports; i++)
	{
	  if (fdef->exports[i].internal_name
	      && fdef->exports[i].internal_name != fdef->exports[i].name)
	    free (fdef->exports[i].internal_name);
	  if (fdef->exports[i].name)
	    free (fdef->exports[i].name);
	  if (fdef->exports[i].its_name)
	    free (fdef->exports[i].its_name);
	}
      free (fdef->exports);
    }

  if (fdef->imports)
    {
      for (i = 0; i < fdef->num_imports; i++)
	{
	  if (fdef->imports[i].internal_name
	      && fdef->imports[i].internal_name != fdef->imports[i].name)
	    free (fdef->imports[i].internal_name);
	  if (fdef->imports[i].name)
	    free (fdef->imports[i].name);
	  if (fdef->imports[i].its_name)
	    free (fdef->imports[i].its_name);
	}
      free (fdef->imports);
    }

  while (fdef->modules)
    {
      def_file_module *m = fdef->modules;

      fdef->modules = fdef->modules->next;
      free (m);
    }

  while (fdef->aligncomms)
    {
      def_file_aligncomm *c = fdef->aligncomms;

      fdef->aligncomms = fdef->aligncomms->next;
      free (c->symbol_name);
      free (c);
    }

  free (fdef);
}

#ifdef DEF_FILE_PRINT
void
def_file_print (FILE *file, def_file *fdef)
{
  int i;

  fprintf (file, ">>>> def_file at 0x%08x\n", fdef);
  if (fdef->name)
    fprintf (file, "  name: %s\n", fdef->name ? fdef->name : "(unspecified)");
  if (fdef->is_dll != -1)
    fprintf (file, "  is dll: %s\n", fdef->is_dll ? "yes" : "no");
  if (fdef->base_address != (bfd_vma) -1)
    {
      fprintf (file, "  base address: 0x");
      fprintf_vma (file, fdef->base_address);
      fprintf (file, "\n");
    }
  if (fdef->description)
    fprintf (file, "  description: `%s'\n", fdef->description);
  if (fdef->stack_reserve != -1)
    fprintf (file, "  stack reserve: 0x%08x\n", fdef->stack_reserve);
  if (fdef->stack_commit != -1)
    fprintf (file, "  stack commit: 0x%08x\n", fdef->stack_commit);
  if (fdef->heap_reserve != -1)
    fprintf (file, "  heap reserve: 0x%08x\n", fdef->heap_reserve);
  if (fdef->heap_commit != -1)
    fprintf (file, "  heap commit: 0x%08x\n", fdef->heap_commit);

  if (fdef->num_section_defs > 0)
    {
      fprintf (file, "  section defs:\n");

      for (i = 0; i < fdef->num_section_defs; i++)
	{
	  fprintf (file, "    name: `%s', class: `%s', flags:",
		   fdef->section_defs[i].name, fdef->section_defs[i].class);
	  if (fdef->section_defs[i].flag_read)
	    fprintf (file, " R");
	  if (fdef->section_defs[i].flag_write)
	    fprintf (file, " W");
	  if (fdef->section_defs[i].flag_execute)
	    fprintf (file, " X");
	  if (fdef->section_defs[i].flag_shared)
	    fprintf (file, " S");
	  fprintf (file, "\n");
	}
    }

  if (fdef->num_exports > 0)
    {
      fprintf (file, "  exports:\n");

      for (i = 0; i < fdef->num_exports; i++)
	{
	  fprintf (file, "    name: `%s', int: `%s', ordinal: %d, flags:",
		   fdef->exports[i].name, fdef->exports[i].internal_name,
		   fdef->exports[i].ordinal);
	  if (fdef->exports[i].flag_private)
	    fprintf (file, " P");
	  if (fdef->exports[i].flag_constant)
	    fprintf (file, " C");
	  if (fdef->exports[i].flag_noname)
	    fprintf (file, " N");
	  if (fdef->exports[i].flag_data)
	    fprintf (file, " D");
	  fprintf (file, "\n");
	}
    }

  if (fdef->num_imports > 0)
    {
      fprintf (file, "  imports:\n");

      for (i = 0; i < fdef->num_imports; i++)
	{
	  fprintf (file, "    int: %s, from: `%s', name: `%s', ordinal: %d\n",
		   fdef->imports[i].internal_name,
		   fdef->imports[i].module,
		   fdef->imports[i].name,
		   fdef->imports[i].ordinal);
	}
    }

  if (fdef->version_major != -1)
    fprintf (file, "  version: %d.%d\n", fdef->version_major, fdef->version_minor);

  fprintf (file, "<<<< def_file at 0x%08x\n", fdef);
}
#endif

/* Helper routine to check for identity of string pointers,
   which might be NULL.  */

static int
are_names_equal (const char *s1, const char *s2)
{
  if (!s1 && !s2)
    return 0;
  if (!s1 || !s2)
    return (!s1 ? -1 : 1);
  return strcmp (s1, s2);
}

static int
cmp_export_elem (const def_file_export *e, const char *ex_name,
		 const char *in_name, const char *its_name,
		 int ord)
{
  int r;

  if ((r = are_names_equal (ex_name, e->name)) != 0)
    return r;
  if ((r = are_names_equal (in_name, e->internal_name)) != 0)
    return r;
  if ((r = are_names_equal (its_name, e->its_name)) != 0)
    return r;
  return (ord - e->ordinal);
}

/* Search the position of the identical element, or returns the position
   of the next higher element. If last valid element is smaller, then MAX
   is returned.  */

static int
find_export_in_list (def_file_export *b, int max,
		     const char *ex_name, const char *in_name,
		     const char *its_name, int ord, int *is_ident)
{
  int e, l, r, p;

  *is_ident = 0;
  if (!max)
    return 0;
  if ((e = cmp_export_elem (b, ex_name, in_name, its_name, ord)) <= 0)
    {
      if (!e)
        *is_ident = 1;
      return 0;
    }
  if (max == 1)
    return 1;
  if ((e = cmp_export_elem (b + (max - 1), ex_name, in_name, its_name, ord)) > 0)
    return max;
  else if (!e || max == 2)
    {
      if (!e)
	*is_ident = 1;
      return max - 1;
    }
  l = 0; r = max - 1;
  while (l < r)
    {
      p = (l + r) / 2;
      e = cmp_export_elem (b + p, ex_name, in_name, its_name, ord);
      if (!e)
        {
          *is_ident = 1;
          return p;
        }
      else if (e < 0)
        r = p - 1;
      else if (e > 0)
        l = p + 1;
    }
  if ((e = cmp_export_elem (b + l, ex_name, in_name, its_name, ord)) > 0)
    ++l;
  else if (!e)
    *is_ident = 1;
  return l;
}

def_file_export *
def_file_add_export (def_file *fdef,
		     const char *external_name,
		     const char *internal_name,
		     int ordinal,
		     const char *its_name,
		     int *is_dup)
{
  def_file_export *e;
  int pos;
  int max_exports = ROUND_UP(fdef->num_exports, 32);

  if (internal_name && !external_name)
    external_name = internal_name;
  if (external_name && !internal_name)
    internal_name = external_name;

  /* We need to avoid duplicates.  */
  *is_dup = 0;
  pos = find_export_in_list (fdef->exports, fdef->num_exports,
		     external_name, internal_name,
		     its_name, ordinal, is_dup);

  if (*is_dup != 0)
    return (fdef->exports + pos);

  if (fdef->num_exports >= max_exports)
    {
      max_exports = ROUND_UP(fdef->num_exports + 1, 32);
      if (fdef->exports)
	fdef->exports = xrealloc (fdef->exports,
				 max_exports * sizeof (def_file_export));
      else
	fdef->exports = xmalloc (max_exports * sizeof (def_file_export));
    }

  e = fdef->exports + pos;
  if (pos != fdef->num_exports)
    memmove (&e[1], e, (sizeof (def_file_export) * (fdef->num_exports - pos)));
  memset (e, 0, sizeof (def_file_export));
  e->name = xstrdup (external_name);
  e->internal_name = xstrdup (internal_name);
  e->its_name = (its_name ? xstrdup (its_name) : NULL);
  e->ordinal = ordinal;
  fdef->num_exports++;
  return e;
}

def_file_module *
def_get_module (def_file *fdef, const char *name)
{
  def_file_module *s;

  for (s = fdef->modules; s; s = s->next)
    if (strcmp (s->name, name) == 0)
      return s;

  return NULL;
}

static def_file_module *
def_stash_module (def_file *fdef, const char *name)
{
  def_file_module *s;

  if ((s = def_get_module (fdef, name)) != NULL)
      return s;
  s = xmalloc (sizeof (def_file_module) + strlen (name));
  s->next = fdef->modules;
  fdef->modules = s;
  s->user_data = 0;
  strcpy (s->name, name);
  return s;
}

static int
cmp_import_elem (const def_file_import *e, const char *ex_name,
		 const char *in_name, const char *module,
		 int ord)
{
  int r;

  if ((r = are_names_equal (module, (e->module ? e->module->name : NULL))))
    return r;
  if ((r = are_names_equal (ex_name, e->name)) != 0)
    return r;
  if ((r = are_names_equal (in_name, e->internal_name)) != 0)
    return r;
  if (ord != e->ordinal)
    return (ord < e->ordinal ? -1 : 1);
  return 0;
}

/* Search the position of the identical element, or returns the position
   of the next higher element. If last valid element is smaller, then MAX
   is returned.  */

static int
find_import_in_list (def_file_import *b, int max,
		     const char *ex_name, const char *in_name,
		     const char *module, int ord, int *is_ident)
{
  int e, l, r, p;

  *is_ident = 0;
  if (!max)
    return 0;
  if ((e = cmp_import_elem (b, ex_name, in_name, module, ord)) <= 0)
    {
      if (!e)
        *is_ident = 1;
      return 0;
    }
  if (max == 1)
    return 1;
  if ((e = cmp_import_elem (b + (max - 1), ex_name, in_name, module, ord)) > 0)
    return max;
  else if (!e || max == 2)
    {
      if (!e)
        *is_ident = 1;
      return max - 1;
    }
  l = 0; r = max - 1;
  while (l < r)
    {
      p = (l + r) / 2;
      e = cmp_import_elem (b + p, ex_name, in_name, module, ord);
      if (!e)
        {
          *is_ident = 1;
          return p;
        }
      else if (e < 0)
        r = p - 1;
      else if (e > 0)
        l = p + 1;
    }
  if ((e = cmp_import_elem (b + l, ex_name, in_name, module, ord)) > 0)
    ++l;
  else if (!e)
    *is_ident = 1;
  return l;
}

def_file_import *
def_file_add_import (def_file *fdef,
		     const char *name,
		     const char *module,
		     int ordinal,
		     const char *internal_name,
		     const char *its_name,
		     int *is_dup)
{
  def_file_import *i;
  int pos;
  int max_imports = ROUND_UP (fdef->num_imports, 16);

  /* We need to avoid here duplicates.  */
  *is_dup = 0;
  pos = find_import_in_list (fdef->imports, fdef->num_imports,
			     name,
			     (!internal_name ? name : internal_name),
			     module, ordinal, is_dup);
  if (*is_dup != 0)
    return fdef->imports + pos;

  if (fdef->num_imports >= max_imports)
    {
      max_imports = ROUND_UP (fdef->num_imports+1, 16);

      if (fdef->imports)
	fdef->imports = xrealloc (fdef->imports,
				 max_imports * sizeof (def_file_import));
      else
	fdef->imports = xmalloc (max_imports * sizeof (def_file_import));
    }
  i = fdef->imports + pos;
  if (pos != fdef->num_imports)
    memmove (&i[1], i, (sizeof (def_file_import) * (fdef->num_imports - pos)));
  memset (i, 0, sizeof (def_file_import));
  if (name)
    i->name = xstrdup (name);
  if (module)
    i->module = def_stash_module (fdef, module);
  i->ordinal = ordinal;
  if (internal_name)
    i->internal_name = xstrdup (internal_name);
  else
    i->internal_name = i->name;
  i->its_name = (its_name ? xstrdup (its_name) : NULL);
  fdef->num_imports++;

  return i;
}

struct
{
  char *param;
  int token;
}
diropts[] =
{
  { "-heap", HEAPSIZE },
  { "-stack", STACKSIZE_K },
  { "-attr", SECTIONS },
  { "-export", EXPORTS },
  { "-aligncomm", ALIGNCOMM },
  { 0, 0 }
};

void
def_file_add_directive (def_file *my_def, const char *param, int len)
{
  def_file *save_def = def;
  const char *pend = param + len;
  char * tend = (char *) param;
  int i;

  def = my_def;

  while (param < pend)
    {
      while (param < pend
	     && (ISSPACE (*param) || *param == '\n' || *param == 0))
	param++;

      if (param == pend)
	break;

      /* Scan forward until we encounter any of:
          - the end of the buffer
	  - the start of a new option
	  - a newline seperating options
          - a NUL seperating options.  */
      for (tend = (char *) (param + 1);
	   (tend < pend
	    && !(ISSPACE (tend[-1]) && *tend == '-')
	    && *tend != '\n' && *tend != 0);
	   tend++)
	;

      for (i = 0; diropts[i].param; i++)
	{
	  len = strlen (diropts[i].param);

	  if (tend - param >= len
	      && strncmp (param, diropts[i].param, len) == 0
	      && (param[len] == ':' || param[len] == ' '))
	    {
	      lex_parse_string_end = tend;
	      lex_parse_string = param + len + 1;
	      lex_forced_token = diropts[i].token;
	      saw_newline = 0;
	      if (def_parse ())
		continue;
	      break;
	    }
	}

      if (!diropts[i].param)
	{
	  if (tend < pend)
	    {
	      char saved;

	      saved = * tend;
	      * tend = 0;
	      /* xgettext:c-format */
	      einfo (_("Warning: .drectve `%s' unrecognized\n"), param);
	      * tend = saved;
	    }
	  else
	    {
	      einfo (_("Warning: corrupt .drectve at end of def file\n"));
	    }
	}

      lex_parse_string = 0;
      param = tend;
    }

  def = save_def;
  def_pool_free ();
}

/* Parser Callbacks.  */

static void
def_image_name (const char *name, bfd_vma base, int is_dll)
{
  /* If a LIBRARY or NAME statement is specified without a name, there is nothing
     to do here.  We retain the output filename specified on command line.  */
  if (*name)
    {
      const char* image_name = lbasename (name);

      if (image_name != name)
	einfo ("%s:%d: Warning: path components stripped from %s, '%s'\n",
	       def_filename, linenumber, is_dll ? "LIBRARY" : "NAME",
	       name);
      if (def->name)
	free (def->name);
      /* Append the default suffix, if none specified.  */
      if (strchr (image_name, '.') == 0)
	{
	  const char * suffix = is_dll ? ".dll" : ".exe";

	  def->name = xmalloc (strlen (image_name) + strlen (suffix) + 1);
	  sprintf (def->name, "%s%s", image_name, suffix);
        }
      else
	def->name = xstrdup (image_name);
    }

  /* Honor a BASE address statement, even if LIBRARY string is empty.  */
  def->base_address = base;
  def->is_dll = is_dll;
}

static void
def_description (const char *text)
{
  int len = def->description ? strlen (def->description) : 0;

  len += strlen (text) + 1;
  if (def->description)
    {
      def->description = xrealloc (def->description, len);
      strcat (def->description, text);
    }
  else
    {
      def->description = xmalloc (len);
      strcpy (def->description, text);
    }
}

static void
def_stacksize (int reserve, int commit)
{
  def->stack_reserve = reserve;
  def->stack_commit = commit;
}

static void
def_heapsize (int reserve, int commit)
{
  def->heap_reserve = reserve;
  def->heap_commit = commit;
}

static void
def_section (const char *name, int attr)
{
  def_file_section *s;
  int max_sections = ROUND_UP (def->num_section_defs, 4);

  if (def->num_section_defs >= max_sections)
    {
      max_sections = ROUND_UP (def->num_section_defs+1, 4);

      if (def->section_defs)
	def->section_defs = xrealloc (def->section_defs,
				      max_sections * sizeof (def_file_import));
      else
	def->section_defs = xmalloc (max_sections * sizeof (def_file_import));
    }
  s = def->section_defs + def->num_section_defs;
  memset (s, 0, sizeof (def_file_section));
  s->name = xstrdup (name);
  if (attr & 1)
    s->flag_read = 1;
  if (attr & 2)
    s->flag_write = 1;
  if (attr & 4)
    s->flag_execute = 1;
  if (attr & 8)
    s->flag_shared = 1;

  def->num_section_defs++;
}

static void
def_section_alt (const char *name, const char *attr)
{
  int aval = 0;

  for (; *attr; attr++)
    {
      switch (*attr)
	{
	case 'R':
	case 'r':
	  aval |= 1;
	  break;
	case 'W':
	case 'w':
	  aval |= 2;
	  break;
	case 'X':
	case 'x':
	  aval |= 4;
	  break;
	case 'S':
	case 's':
	  aval |= 8;
	  break;
	}
    }
  def_section (name, aval);
}

static void
def_exports (const char *external_name,
	     const char *internal_name,
	     int ordinal,
	     int flags,
	     const char *its_name)
{
  def_file_export *dfe;
  int is_dup = 0;

  if (!internal_name && external_name)
    internal_name = external_name;
#if TRACE
  printf ("def_exports, ext=%s int=%s\n", external_name, internal_name);
#endif

  dfe = def_file_add_export (def, external_name, internal_name, ordinal,
			     its_name, &is_dup);

  /* We might check here for flag redefinition and warn.  For now we
     ignore duplicates silently.  */
  if (is_dup)
    return;

  if (flags & 1)
    dfe->flag_noname = 1;
  if (flags & 2)
    dfe->flag_constant = 1;
  if (flags & 4)
    dfe->flag_data = 1;
  if (flags & 8)
    dfe->flag_private = 1;
}

static void
def_import (const char *internal_name,
	    const char *module,
	    const char *dllext,
	    const char *name,
	    int ordinal,
	    const char *its_name)
{
  char *buf = 0;
  const char *ext = dllext ? dllext : "dll";
  int is_dup = 0;

  buf = xmalloc (strlen (module) + strlen (ext) + 2);
  sprintf (buf, "%s.%s", module, ext);
  module = buf;

  def_file_add_import (def, name, module, ordinal, internal_name, its_name,
		       &is_dup);
  free (buf);
}

static void
def_version (int major, int minor)
{
  def->version_major = major;
  def->version_minor = minor;
}

static void
def_directive (char *str)
{
  struct directive *d = xmalloc (sizeof (struct directive));

  d->next = directives;
  directives = d;
  d->name = xstrdup (str);
  d->len = strlen (str);
}

static void
def_aligncomm (char *str, int align)
{
  def_file_aligncomm *c, *p;

  p = NULL;
  c = def->aligncomms;
  while (c != NULL)
    {
      int e = strcmp (c->symbol_name, str);
      if (!e)
	{
	  /* Not sure if we want to allow here duplicates with
	     different alignments, but for now we keep them.  */
	  e = (int) c->alignment - align;
	  if (!e)
	    return;
	}
      if (e > 0)
        break;
      c = (p = c)->next;
    }

  c = xmalloc (sizeof (def_file_aligncomm));
  c->symbol_name = xstrdup (str);
  c->alignment = (unsigned int) align;
  if (!p)
    {
      c->next = def->aligncomms;
      def->aligncomms = c;
    }
  else
    {
      c->next = p->next;
      p->next = c;
    }
}

static int
def_error (const char *err)
{
  einfo ("%P: %s:%d: %s\n",
	 def_filename ? def_filename : "<unknown-file>", linenumber, err);
  return 0;
}


/* Lexical Scanner.  */

#undef TRACE
#define TRACE 0

/* Never freed, but always reused as needed, so no real leak.  */
static char *buffer = 0;
static int buflen = 0;
static int bufptr = 0;

static void
put_buf (char c)
{
  if (bufptr == buflen)
    {
      buflen += 50;		/* overly reasonable, eh?  */
      if (buffer)
	buffer = xrealloc (buffer, buflen + 1);
      else
	buffer = xmalloc (buflen + 1);
    }
  buffer[bufptr++] = c;
  buffer[bufptr] = 0;		/* not optimal, but very convenient.  */
}

static struct
{
  char *name;
  int token;
}
tokens[] =
{
  { "BASE", BASE },
  { "CODE", CODE },
  { "CONSTANT", CONSTANTU },
  { "constant", CONSTANTL },
  { "DATA", DATAU },
  { "data", DATAL },
  { "DESCRIPTION", DESCRIPTION },
  { "DIRECTIVE", DIRECTIVE },
  { "EXECUTE", EXECUTE },
  { "EXPORTS", EXPORTS },
  { "HEAPSIZE", HEAPSIZE },
  { "IMPORTS", IMPORTS },
  { "LIBRARY", LIBRARY },
  { "NAME", NAME },
  { "NONAME", NONAMEU },
  { "noname", NONAMEL },
  { "PRIVATE", PRIVATEU },
  { "private", PRIVATEL },
  { "READ", READ },
  { "SECTIONS", SECTIONS },
  { "SEGMENTS", SECTIONS },
  { "SHARED", SHARED },
  { "STACKSIZE", STACKSIZE_K },
  { "VERSION", VERSIONK },
  { "WRITE", WRITE },
  { 0, 0 }
};

static int
def_getc (void)
{
  int rv;

  if (lex_parse_string)
    {
      if (lex_parse_string >= lex_parse_string_end)
	rv = EOF;
      else
	rv = *lex_parse_string++;
    }
  else
    {
      rv = fgetc (the_file);
    }
  if (rv == '\n')
    saw_newline = 1;
  return rv;
}

static int
def_ungetc (int c)
{
  if (lex_parse_string)
    {
      lex_parse_string--;
      return c;
    }
  else
    return ungetc (c, the_file);
}

static int
def_lex (void)
{
  int c, i, q;

  if (lex_forced_token)
    {
      i = lex_forced_token;
      lex_forced_token = 0;
#if TRACE
      printf ("lex: forcing token %d\n", i);
#endif
      return i;
    }

  c = def_getc ();

  /* Trim leading whitespace.  */
  while (c != EOF && (c == ' ' || c == '\t') && saw_newline)
    c = def_getc ();

  if (c == EOF)
    {
#if TRACE
      printf ("lex: EOF\n");
#endif
      return 0;
    }

  if (saw_newline && c == ';')
    {
      do
	{
	  c = def_getc ();
	}
      while (c != EOF && c != '\n');
      if (c == '\n')
	return def_lex ();
      return 0;
    }

  /* Must be something else.  */
  saw_newline = 0;

  if (ISDIGIT (c))
    {
      bufptr = 0;
      while (c != EOF && (ISXDIGIT (c) || (c == 'x')))
	{
	  put_buf (c);
	  c = def_getc ();
	}
      if (c != EOF)
	def_ungetc (c);
      yylval.digits = def_pool_strdup (buffer);
#if TRACE
      printf ("lex: `%s' returns DIGITS\n", buffer);
#endif
      return DIGITS;
    }

  if (ISALPHA (c) || strchr ("$:-_?@@", c))
    {
      bufptr = 0;
      q = c;
      put_buf (c);
      c = def_getc ();

      if (q == '@@')
	{
          if (ISBLANK (c) ) /* '@@' followed by whitespace.  */
	    return (q);
          else if (ISDIGIT (c)) /* '@@' followed by digit.  */
            {
	      def_ungetc (c);
              return (q);
	    }
#if TRACE
	  printf ("lex: @@ returns itself\n");
#endif
	}

      while (c != EOF && (ISALNUM (c) || strchr ("$:-_?/@@<>", c)))
	{
	  put_buf (c);
	  c = def_getc ();
	}
      if (c != EOF)
	def_ungetc (c);
      if (ISALPHA (q)) /* Check for tokens.  */
	{
          for (i = 0; tokens[i].name; i++)
	    if (strcmp (tokens[i].name, buffer) == 0)
	      {
#if TRACE
	        printf ("lex: `%s' is a string token\n", buffer);
#endif
	        return tokens[i].token;
	      }
	}
#if TRACE
      printf ("lex: `%s' returns ID\n", buffer);
#endif
      yylval.id = def_pool_strdup (buffer);
      return ID;
    }

  if (c == '\'' || c == '"')
    {
      q = c;
      c = def_getc ();
      bufptr = 0;

      while (c != EOF && c != q)
	{
	  put_buf (c);
	  c = def_getc ();
	}
      yylval.id = def_pool_strdup (buffer);
#if TRACE
      printf ("lex: `%s' returns ID\n", buffer);
#endif
      return ID;
    }

  if ( c == '=')
    {
      c = def_getc ();
      if (c == '=')
        {
#if TRACE
          printf ("lex: `==' returns EQUAL\n");
#endif
		  return EQUAL;
        }
      def_ungetc (c);
#if TRACE
      printf ("lex: `=' returns itself\n");
#endif
      return '=';
    }
  if (c == '.' || c == ',')
    {
#if TRACE
      printf ("lex: `%c' returns itself\n", c);
#endif
      return c;
    }

  if (c == '\n')
    {
      linenumber++;
      saw_newline = 1;
    }

  /*printf ("lex: 0x%02x ignored\n", c); */
  return def_lex ();
}

static char *
def_pool_alloc (size_t sz)
{
  def_pool_str *e;

  e = (def_pool_str *) xmalloc (sizeof (def_pool_str) + sz);
  e->next = pool_strs;
  pool_strs = e;
  return e->data;
}

static char *
def_pool_strdup (const char *str)
{
  char *s;
  size_t len;
  if (!str)
    return NULL;
  len = strlen (str) + 1;
  s = def_pool_alloc (len);
  memcpy (s, str, len);
  return s;
}

static void
def_pool_free (void)
{
  def_pool_str *p;
  while ((p = pool_strs) != NULL)
    {
      pool_strs = p->next;
      free (p);
    }
}
@


1.42
log
@        * deffilep.y (def_image_name): Adjust type of base-address
        argument.
        (%union): Add new type bfd_vma as vma.
        (VMA):  New rule.
        (opt_base): Use VMA instead of NUMBER rule to evaluate value.
        (def_file_print): Use bfd's fprintf_vma to output base-address.
@
text
@d937 14
a950 7
	  char saved;

	  saved = * tend;
	  * tend = 0;
	  /* xgettext:c-format */
	  einfo (_("Warning: .drectve `%s' unrecognized\n"), param);
	  * tend = saved;
@


1.41
log
@Remove trailing white spaces in ld

	* deffilep.y: Remove trailing white spaces.
	* elf-hints-local.h: Likewise.
	* ldexp.c: Likewise.
	* ldlang.h: Likewise.
	* ldmisc.c: Likewise.
	* ldwrite.c: Likewise.
	* pe-dll.c: Likewise.
	* emulparams/criself.sh: Likewise.
	* emulparams/crislinux.sh: Likewise.
	* emulparams/elf32_tic6x_le.sh: Likewise.
	* emulparams/elf32bmipn32-defs.sh: Likewise.
	* emulparams/elf32mb_linux.sh: Likewise.
	* emulparams/elf32mep.sh: Likewise.
	* emulparams/elf32microblaze.sh: Likewise.
	* emulparams/elf32ppc.sh: Likewise.
	* emulparams/elf64_s390.sh: Likewise.
	* emulparams/elf64alpha.sh: Likewise.
	* emulparams/elf_s390.sh: Likewise.
	* emulparams/elf_x86_64.sh: Likewise.
	* emulparams/tic80coff.sh: Likewise.
	* emultempl/aix.em: Likewise.
	* emultempl/avrelf.em: Likewise.
	* emultempl/cr16elf.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/tic6xdsbt.em: Likewise.
@
text
@d97 1
a97 1
static void def_image_name (const char *, int, int);
d118 1
d129 1
d131 1
a131 1
%type  <number> opt_base opt_ordinal
d317 2
a318 2
opt_base: BASE	'=' NUMBER	{ $$ = $3;}
	|	{ $$ = -1;}
d345 2
d516 5
a520 1
    fprintf (file, "  base address: 0x%08x\n", fdef->base_address);
d957 1
a957 1
def_image_name (const char *name, int base, int is_dll)
@


1.40
log
@	PR binutils/13710
	* defparse.y (keyword_as_name): Disable LIBRARY
	keyword.
	* doc/binutils.texi: Document LIBRARY exception.

	PR binutils/13710
	* deffilep.y (keyword_as_name): Disable LIBRARY
	keyword.
@
text
@d49 7
a55 7
#define	yypact	def_pact	
#define	yyr1	def_r1			
#define	yyr2	def_r2			
#define	yydef	def_def		
#define	yychk	def_chk		
#define	yypgo	def_pgo		
#define	yyact	def_act		
d141 1
a141 1
command: 
d150 1
a150 1
	|	EXPORTS explist 
d189 1
a189 1
implist:	
d226 1
a226 1
	| 
d231 1
a231 1
	
d234 1
a234 1
	|	WRITE	{ $$ = 2;}	
d278 1
a278 1
	  { 
d284 1
a284 1
	  { 
d290 1
a290 1
	  { 
d305 1
a305 1
opt_ordinal: 
d312 1
a312 1
        | 		{ $$ =  0; }			 
d963 1
a963 1
      /* Append the default suffix, if none specified.  */ 
d1118 1
a1118 1
   
d1150 1
a1150 1
  
@


1.39
log
@        * deffilep.y (cmp_import_elem): Sort first by module name.
        * pe-dll.c (process_def_file_and_drectve): Free strings
        from removed export-element.
        (add_bfd_to_link): Optimize loop on import-elements and lower
        allocated memory.
        (pe_implied_import_dll): Pass NULL instead of 0 for pointer
        argument.
@
text
@d252 6
a257 1
	 | LIBRARY { $$ = "LIBRARY"; }
@


1.38
log
@        * deffilep.y (find_export_in_list): Set is_indent for
        first or last element, if identical.
        (find_import_in_list): Likewise.
@
text
@d744 2
d752 1
a752 1
  return are_names_equal (module, (e->module ? e->module->name : NULL));
@


1.37
log
@ChangeLog binutils

2012-02-11  Kai Tietz  <ktietz@@redhat.com>

	PR binutils/13657
	* defparse.y (%union): New type id_const.
	(opt_name2): New rule.
	(keyword_as_name): New rule.
	(opt_name): Adjust rule.
	(opt_import_name): Likewise.
	(opt_equal_name): Likewise.

ChangeLog binutils/testsuite

2012-02-11  Kai Tietz  <ktietz@@redhat.com>

	* binutils-all/version.def: New file.
	* binutils-all/dlltool.exp: Add version-dll test.

ChangeLog ld

2012-02-11  Kai Tietz  <ktietz@@redhat.com>

	* deffilep.y (%union): New type id_const.
	(opt_name2): New rule.
	(keyword_as_name): New rule.
	(dot_name): Replaced by opt_name2 rule.
	(opt_name): Adjust rule.
	(opt_equal_name): Likewise.
@
text
@d625 5
a629 1
    return 0;
d635 5
a639 1
    return max - 1;
d768 5
a772 1
    return 0;
d778 5
a782 1
    return max - 1;
@


1.36
log
@2011-04-18  Kai Tietz  <ktietz@@redhat.com>

        * deffilep.y (def_aligncomm): Avoid duplets.
@
text
@d116 1
d131 1
a131 1
%type  <id> opt_name opt_equal_name dot_name anylang_id opt_id
d133 1
d169 1
a169 1
		dot_name opt_equal_name opt_ordinal opt_comma exp_opt_list opt_comma opt_equalequal_name
d239 28
a266 2
opt_name: ID		{ $$ = $1; }
	| '.' ID
d268 6
d278 1
a278 1
	| ID '.' ID	
d284 9
d306 1
a306 1
          '=' dot_name	{ $$ = $2; }
a313 15
dot_name: ID		{ $$ = $1; }
	| '.' ID
	  {
	    char *name = def_pool_alloc (strlen ($2) + 2);
	    sprintf (name, ".%s", $2);
	    $$ = name;
	  }
	| dot_name '.' ID	
	  { 
	    char *name = def_pool_alloc (strlen ($1) + 1 + strlen ($3) + 1);
	    sprintf (name, "%s.%s", $1, $3);
	    $$ = name;
	  }
	;

@


1.35
log
@2011-04-18  Kai Tietz  <ktietz@@redhat.com>

	* deffilep.y (def_pool_str): New type.
	(pool_strs): Local static.
	(def_pool_alloc): Local function.
	(def_pool_strdup): Likewise.
	(def_pool_free): Likewise.
	(opt_name): Replace xmalloc/xstrdup by
	def_pool_alloc/def_pool_strdup.
	(dot_name): Likewise.
	(anylang_id): Likewise.
	(def_lex): Likewise.
	(def_file_parse): Call def_pool_free on
	exit and cleanup directives elements.
	(def_file_add_directive): Call def_pool_free.
@
text
@d1098 19
a1116 1
  def_file_aligncomm *c = xmalloc (sizeof (def_file_aligncomm));
d1118 1
d1121 10
a1130 3

  c->next = def->aligncomms;
  def->aligncomms = c;
@


1.34
log
@2011-04-13  Kai Tietz  <ktietz@@redhat.com>

	PR binutils/12658
	* deffile.h (def_file_add_export): Add is_dup argument.
	(def_file_add_import): Likewise.
	* deffilep.y (are_names_equal): New helper.
	(cmp_export_elem): New helper.
	(find_export_in_list): Add search routine for exports.
	(def_file_add_export): Check for duplicates.
	(cmp_import_elem): New helper.
	(find_import_in_list): Add search routine for imports.
	(def_file_add_import): Check for duplicates.
	(def_exports): Handle duplicates.
	(def_imports): Likewise.
	* pe-dll.c (process_def_file_and_drectve): Likewise.
	(pe_implied_import_dll): Likewise.
@
text
@d81 11
d240 1
a240 1
	    char *name = xmalloc (strlen ($2) + 2);
d246 1
a246 1
	    char *name = xmalloc (strlen ($1) + 1 + strlen ($3) + 1);
d274 1
a274 1
	    char *name = xmalloc (strlen ($2) + 2);
d280 1
a280 1
	    char *name = xmalloc (strlen ($1) + 1 + strlen ($3) + 1);
d289 1
a289 1
	    char *id = xmalloc (strlen ($2) + 2);
d295 1
a295 1
	    char *id = xmalloc (strlen ($1) + 1 + strlen ($3) + strlen ($4) + 1);
d372 1
d378 1
a378 1
  for (d = directives; d; d = d->next)
d384 3
d388 1
d892 1
d1263 1
a1263 1
      yylval.digits = xstrdup (buffer);
d1312 1
a1312 1
      yylval.id = xstrdup (buffer);
d1327 1
a1327 1
      yylval.id = xstrdup (buffer);
d1367 35
@


1.33
log
@2010-05-25  Kai Tietz  <kai.tietz@@onevision.com>


        * deffilep.y (opt_name): Allow leading dot.
        (dot_name): Likewise.
        (anylang_id): Likewise.
@
text
@d537 73
d615 2
a616 1
		     const char *its_name)
d619 1
d622 14
d645 4
a648 1
  e = fdef->exports + fdef->num_exports;
a649 4
  if (internal_name && !external_name)
    external_name = internal_name;
  if (external_name && !internal_name)
    internal_name = external_name;
d685 60
d751 2
a752 1
		     const char *its_name)
d755 1
d758 9
d777 3
a779 1
  i = fdef->imports + fdef->num_imports;
d1013 1
d1022 7
a1028 1
  							 its_name);
d1048 2
a1049 1
  const char *ext = dllext ? dllext : "dll";    
d1055 3
a1057 3
  def_file_add_import (def, name, module, ordinal, internal_name, its_name);
  if (buf)
    free (buf);
@


1.32
log
@	* deffilep.y (def_file_free): Add missing shadow parameter renaming.
	(def_file_print): Likewise.
	(def_stash_module): Likewise.
	(def_file_add_import): Likewise.
@
text
@d227 6
d261 6
d276 6
@


1.31
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d385 1
a385 1
      for (i = 0; i < def->num_exports; i++)
d515 1
a515 1
  fprintf (file, "<<<< def_file at 0x%08x\n", def);
d572 1
a572 1
  s->next = def->modules;
d605 1
a605 1
    i->module = def_stash_module (def, module);
@


1.30
log
@2009-10-23  Kai Tietz  <kai.tietz@@onevision.com>

	* deffile.h (def_file_export): New member its_name.
	(def_file_import): Likewise.
	(def_file_add_export): Add argument its_name.
	(def_file_add_import): Likewise.
	* deffilep.y (def_exports): Add argument its_name.
	(def_import): Likewise.
	(EQUAL): Add new token for '=='.
	(opt_equalequal_name): New rule.
	(expline): Add rule opt_equalequal_name.
	(impline): Likewise.
	(def_file_free): Free for exports and imports
	the optional member its_name.
	(def_lex): Add scan of '==' as EQUAL.
	* pe-dll.c (pe_export_sort): Sort for its_name too.
	(process_def_file_and_drectve): Adjust calls to
	def_file_add_export.
	(generate_edata): Take its_name in account.
	(make_one): Likewise.
	(pe_process_import_defs): Likewise.
	(pe_dll_generate_def_file): Add print of new '==' option.
	* ld.texinfo: Extend documentation about .def file syntax.
	* NEWS: Mention new feature.
@
text
@d360 1
a360 1
def_file_free (def_file *def)
d364 1
a364 1
  if (!def)
d366 4
a369 4
  if (def->name)
    free (def->name);
  if (def->description)
    free (def->description);
d371 1
a371 1
  if (def->section_defs)
d373 1
a373 1
      for (i = 0; i < def->num_section_defs; i++)
d375 4
a378 4
	  if (def->section_defs[i].name)
	    free (def->section_defs[i].name);
	  if (def->section_defs[i].class)
	    free (def->section_defs[i].class);
d380 1
a380 1
      free (def->section_defs);
d383 1
a383 1
  if (def->exports)
d387 7
a393 7
	  if (def->exports[i].internal_name
	      && def->exports[i].internal_name != def->exports[i].name)
	    free (def->exports[i].internal_name);
	  if (def->exports[i].name)
	    free (def->exports[i].name);
	  if (def->exports[i].its_name)
	    free (def->exports[i].its_name);
d395 1
a395 1
      free (def->exports);
d398 1
a398 1
  if (def->imports)
d400 1
a400 1
      for (i = 0; i < def->num_imports; i++)
d402 7
a408 7
	  if (def->imports[i].internal_name
	      && def->imports[i].internal_name != def->imports[i].name)
	    free (def->imports[i].internal_name);
	  if (def->imports[i].name)
	    free (def->imports[i].name);
	  if (def->imports[i].its_name)
	    free (def->imports[i].its_name);
d410 1
a410 1
      free (def->imports);
d413 1
a413 1
  while (def->modules)
d415 3
a417 2
      def_file_module *m = def->modules;
      def->modules = def->modules->next;
d421 1
a421 1
  while (def->aligncomms)
d423 3
a425 2
      def_file_aligncomm *c = def->aligncomms;
      def->aligncomms = def->aligncomms->next;
d430 1
a430 1
  free (def);
d435 1
a435 1
def_file_print (FILE *file, def_file *def)
d439 17
a455 17
  fprintf (file, ">>>> def_file at 0x%08x\n", def);
  if (def->name)
    fprintf (file, "  name: %s\n", def->name ? def->name : "(unspecified)");
  if (def->is_dll != -1)
    fprintf (file, "  is dll: %s\n", def->is_dll ? "yes" : "no");
  if (def->base_address != (bfd_vma) -1)
    fprintf (file, "  base address: 0x%08x\n", def->base_address);
  if (def->description)
    fprintf (file, "  description: `%s'\n", def->description);
  if (def->stack_reserve != -1)
    fprintf (file, "  stack reserve: 0x%08x\n", def->stack_reserve);
  if (def->stack_commit != -1)
    fprintf (file, "  stack commit: 0x%08x\n", def->stack_commit);
  if (def->heap_reserve != -1)
    fprintf (file, "  heap reserve: 0x%08x\n", def->heap_reserve);
  if (def->heap_commit != -1)
    fprintf (file, "  heap commit: 0x%08x\n", def->heap_commit);
d457 1
a457 1
  if (def->num_section_defs > 0)
d461 1
a461 1
      for (i = 0; i < def->num_section_defs; i++)
d464 2
a465 2
		   def->section_defs[i].name, def->section_defs[i].class);
	  if (def->section_defs[i].flag_read)
d467 1
a467 1
	  if (def->section_defs[i].flag_write)
d469 1
a469 1
	  if (def->section_defs[i].flag_execute)
d471 1
a471 1
	  if (def->section_defs[i].flag_shared)
d477 1
a477 1
  if (def->num_exports > 0)
d481 1
a481 1
      for (i = 0; i < def->num_exports; i++)
d484 3
a486 3
		   def->exports[i].name, def->exports[i].internal_name,
		   def->exports[i].ordinal);
	  if (def->exports[i].flag_private)
d488 1
a488 1
	  if (def->exports[i].flag_constant)
d490 1
a490 1
	  if (def->exports[i].flag_noname)
d492 1
a492 1
	  if (def->exports[i].flag_data)
d498 1
a498 1
  if (def->num_imports > 0)
d502 1
a502 1
      for (i = 0; i < def->num_imports; i++)
d505 4
a508 4
		   def->imports[i].internal_name,
		   def->imports[i].module,
		   def->imports[i].name,
		   def->imports[i].ordinal);
d512 2
a513 2
  if (def->version_major != -1)
    fprintf (file, "  version: %d.%d\n", def->version_major, def->version_minor);
d520 1
a520 1
def_file_add_export (def_file *def,
d527 1
a527 1
  int max_exports = ROUND_UP(def->num_exports, 32);
d529 1
a529 1
  if (def->num_exports >= max_exports)
d531 3
a533 3
      max_exports = ROUND_UP(def->num_exports + 1, 32);
      if (def->exports)
	def->exports = xrealloc (def->exports,
d536 1
a536 1
	def->exports = xmalloc (max_exports * sizeof (def_file_export));
d538 1
a538 1
  e = def->exports + def->num_exports;
d548 1
a548 1
  def->num_exports++;
d553 1
a553 1
def_get_module (def_file *def, const char *name)
d557 1
a557 1
  for (s = def->modules; s; s = s->next)
d565 1
a565 1
def_stash_module (def_file *def, const char *name)
d569 1
a569 1
  if ((s = def_get_module (def, name)) != NULL)
d573 1
a573 1
  def->modules = s;
d580 1
a580 1
def_file_add_import (def_file *def,
d588 1
a588 1
  int max_imports = ROUND_UP (def->num_imports, 16);
d590 1
a590 1
  if (def->num_imports >= max_imports)
d592 1
a592 1
      max_imports = ROUND_UP (def->num_imports+1, 16);
d594 2
a595 2
      if (def->imports)
	def->imports = xrealloc (def->imports,
d598 1
a598 1
	def->imports = xmalloc (max_imports * sizeof (def_file_import));
d600 1
a600 1
  i = def->imports + def->num_imports;
d612 1
a612 1
  def->num_imports++;
d665 1
a665 1
	  int len = strlen (diropts[i].param);
d709 1
@


1.29
log
@2009-10-23  Kai Tietz  <kai.tietz@@onevision.com>

	* deffilep.y (def_lex): Allow '<' and '>' characters in identifier
	strings.
@
text
@d82 1
a82 1
static void def_exports (const char *, const char *, int, int);
d85 1
a85 1
			int);
d112 1
a112 1
%token READ WRITE EXECUTE SHARED NONAMEU NONAMEL DIRECTIVE
d120 1
d156 2
a157 2
		dot_name opt_equal_name opt_ordinal opt_comma exp_opt_list
			{ def_exports ($1, $2, $3, $5); }
d182 12
a193 6
               ID '=' ID '.' ID '.' ID     { def_import ($1, $3, $5, $7, -1); }
       |       ID '=' ID '.' ID '.' NUMBER { def_import ($1, $3, $5,  0, $7); }
       |       ID '=' ID '.' ID            { def_import ($1, $3,  0, $5, -1); }
       |       ID '=' ID '.' NUMBER        { def_import ($1, $3,  0,  0, $5); }
       |       ID '.' ID '.' ID            { def_import ( 0, $1, $3, $5, -1); }
       |       ID '.' ID                   { def_import ( 0, $1,  0, $3, -1); }
d236 4
d392 2
d407 2
d521 2
a522 1
		     int ordinal)
d544 1
d582 2
a583 1
		     const char *internal_name)
d609 1
d827 2
a828 1
	     int flags)
d838 2
a839 1
  dfe = def_file_add_export (def, external_name, internal_name, ordinal);
d855 2
a856 1
	    int ordinal)
d865 1
a865 1
  def_file_add_import (def, name, module, ordinal, internal_name);
d1127 17
a1143 1
  if (c == '=' || c == '.' || c == ',')
@


1.28
log
@update copyright dates
@
text
@d1062 1
a1062 1
      while (c != EOF && (ISALNUM (c) || strchr ("$:-_?/@@", c)))
@


1.27
log
@ld/ChangeLog

	* deffilep.y (%union):  Add new string-type semantic value 'digits'.
	(%token):  Remove NUMBER as token, add DIGITS.
	(%type):  Add NUMBER as type.  Add new id types anylang_id, opt_id.
	(ALIGNCOMM):  Parse an anylang_id instead of a plain ID.
	(anylang_id):  New production.
	(opt_digits):  Likewise.
	(opt_id):  Likewise.
	(NUMBER):  Likewise.
	(def_lex):  Return strings of digits in raw string form as DIGITS
	token, instead of converting to numeric integer type.

ld/testsuite/ChangeLog

	* ld-pe/non-c-lang-syms.c:  New dump test source file.
	* ld-pe/non-c-lang-syms.d:  New dump test pattern file.
	* ld-pe/pe.exp:  Run new "foreign symbol" test.
@
text
@d3 2
a4 2
/*   Copyright 1995, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2007
     Free Software Foundation, Inc.
@


1.26
log
@==> bfd/ChangeLog <==
2009-05-19  Dave Korn  <dave.korn.cygwin@@gmail.com>

	* cofflink.c (process_embedded_commands):  Ignore "-aligncomm".

==> gas/ChangeLog <==
2009-05-19  Dave Korn  <dave.korn.cygwin@@gmail.com>

	* NEWS:  Mention new feature.
	* config/obj-coff.c (obj_coff_common_parse):  New function.
	(obj_coff_comm):  Likewise.
	(coff_pseudo_table):  Override default ".comm" definition on PE.
	* doc/as.texinfo:  Document new feature.

==> gas/testsuite/ChangeLog <==
2009-05-19  Dave Korn  <dave.korn.cygwin@@gmail.com>

	* gas/pe/:  New directory for PE format-specific tests.
	* gas/pe/aligncomm-a.d:  New test pattern file.
	* gas/pe/aligncomm-a.s:  New test source file.
	* gas/pe/aligncomm-b.d:  New test pattern file.
	* gas/pe/aligncomm-b.s:  New test source file.
	* gas/pe/aligncomm-c.d:  New test pattern file.
	* gas/pe/aligncomm-c.s:  New test source file.
	* gas/pe/aligncomm-d.d:  New test pattern file.
	* gas/pe/aligncomm-d.s:  New test source file.
	* gas/pe/pe.exp:  New test control script.
	* lib/gas-defs.exp (is_pecoff_format):  New function.

==> ld/ChangeLog <==
2009-05-19  Dave Korn  <dave.korn.cygwin@@gmail.com>

	* NEWS:  Mention new feature.
	* deffile.h (def_file_aligncomm):  Add new struct definition.
	(def_file):  Add new def_file_aligncomm member.
	* deffilep.y (%token):  Add new ALIGNCOMM token.
	(command):  Add production rule for ALIGNCOMM.
	(def_file_free):  Free any chained def_file_aligncomm structs.
	(diropts[]):  Add entry for '-aligncomm' .drectve command.
	(def_aligncomm):  New grammar function.
	* ld.texinfo:  Document new feature.
	* pe-dll.c (process_def_file):  Rename from this ...
	(process_def_file_and_drectve):  ... to this, updating all callers,
	and process any aligncomms chained to the def file after scanning
	all .drectve sections.
	(generate_edata):  Updated to match.
	(pe_dll_build_sections):  Likewise.

==> ld/testsuite/ChangeLog <==
2009-05-19  Dave Korn  <dave.korn.cygwin@@gmail.com>

	* ld-pe/aligncomm-1.c:  New test source file.
	* ld-pe/aligncomm-2.c:  Likewise.
	* ld-pe/aligncomm-3.c:  Likewise.
	* ld-pe/aligncomm-4.c:  Likewise.
	* ld-pe/aligncomm.d:  New test pattern file.

	* ld-pe/direct.exp:  Deleted, and content moved into ...
	* ld-pe/pe-run.exp:  ... New common file for all PE run tests.

	* ld-pe/vers-script.exp:  Deleted, and content merged into ...
	* ld-pe/pe-compile.exp:  ... New common file for PE tests needing
	a compiler, adding aligned common tests.

	* ld-pe/pe.exp:  Update header comment.
@
text
@d106 1
d114 3
a116 1
%token <number> NUMBER
d119 1
a119 1
%type  <id> opt_name opt_equal_name dot_name 
d141 1
a141 1
	|	ALIGNCOMM ID ',' NUMBER { def_aligncomm ($2, $4);}
d251 19
a269 1
	
d1034 1
a1034 1
      yylval.number = strtoul (buffer, 0, 0);
d1036 1
a1036 1
      printf ("lex: `%s' returns NUMBER %d\n", buffer, yylval.number);
d1038 1
a1038 1
      return NUMBER;
@


1.25
log
@	* deffilep.y (STACKSIZE_K): Rename from STACKSIZE.
@
text
@d92 1
d110 1
a110 1
%token PRIVATEU PRIVATEL
d138 1
d384 8
d586 1
d845 12
@


1.24
log
@Update sources to GPLv3
@
text
@d107 1
a107 1
%token NAME LIBRARY DESCRIPTION STACKSIZE HEAPSIZE CODE DATAU DATAL
d127 1
a127 1
	|	STACKSIZE NUMBER opt_number { def_stacksize ($2, $3);}
d573 1
a573 1
  { "-stack", STACKSIZE },
d897 1
a897 1
  { "STACKSIZE", STACKSIZE },
@


1.23
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d10 1
a10 1
     the Free Software Foundation; either version 2 of the License, or
d20 2
a21 1
     Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.22
log
@	* deffilep.y (def_image_name): If LIBRARY or NAME statement
	specifies an empty string, retain the name specified on command
	line.
	* ld.texinfo: Document above
@
text
@d3 1
a3 1
/*   Copyright 1995, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005
d22 1
a22 1
#include <stdio.h>
a25 1
#include "sysdep.h"
@


1.21
log
@	* deffilep.y (def_image_name): If the image name does not have
	a suffix, append the default.
	* ld.texinfo: Document NAME, LIBRARY usage in PE-COFF .def files.
@
text
@d651 24
a674 16
  const char* image_name = lbasename (name);
  if (image_name != name)
    einfo ("%s:%d: Warning: path components stripped from %s, '%s'\n",
	  def_filename, linenumber, is_dll ? "LIBRARY" : "NAME", name);
  if (def->name)
    free (def->name);
  /* Append the default suffix, if none specified.  */ 
   if (strchr (image_name, '.') == 0)
     {
        const char * suffix = is_dll ? ".dll" : ".exe";

        def->name = xmalloc (strlen (image_name) + strlen (suffix) + 1);
        sprintf (def->name, "%s%s", image_name, suffix);
     }
  else
    def->name = xstrdup (image_name);
@


1.21.2.1
log
@Merge changes between binutils-csl-2_17-branchpoint and
binutils-2_17, except for the addition of generated files to CVS.
@
text
@d651 16
a666 24
  /* If a LIBRARY or NAME statement is specified without a name, there is nothing
     to do here.  We retain the output filename specified on command line.  */
  if (*name)
    {
      const char* image_name = lbasename (name);
      if (image_name != name)
	einfo ("%s:%d: Warning: path components stripped from %s, '%s'\n",
	       def_filename, linenumber, is_dll ? "LIBRARY" : "NAME",
	       name);
      if (def->name)
	free (def->name);
      /* Append the default suffix, if none specified.  */ 
      if (strchr (image_name, '.') == 0)
	{
	  const char * suffix = is_dll ? ".dll" : ".exe";

	  def->name = xmalloc (strlen (image_name) + strlen (suffix) + 1);
	  sprintf (def->name, "%s%s", image_name, suffix);
        }
      else
	def->name = xstrdup (image_name);
    }

  /* Honor a BASE address statement, even if LIBRARY string is empty.  */
@


1.20
log
@Update FSF addresses
@
text
@d657 10
a666 1
  def->name = xstrdup (image_name);
@


1.19
log
@update copyright dates
@
text
@d20 1
a20 1
     Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.18
log
@	* defilep.y (def_name, def_library): Combine into...
	(def_image_name): New function.  Strip name to basename,
	with warning.
@
text
@d3 1
a3 1
/*   Copyright 1995, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@


1.17
log
@	* deffilep.y: Remove commas from %token lines.
@
text
@d86 1
a86 2
static void def_library (const char *, int);
static void def_name (const char *, int);
d124 2
a125 2
		NAME opt_name opt_base { def_name ($2, $3); }
	|	LIBRARY opt_name opt_base { def_library ($2, $3); }
d649 1
a649 1
def_name (const char *name, int base)
d651 4
d657 1
a657 1
  def->name = xstrdup (name);
d659 1
a659 11
  def->is_dll = 0;
}

static void
def_library (const char *name, int base)
{
  if (def->name)
    free (def->name);
  def->name = xstrdup (name);
  def->base_address = base;
  def->is_dll = 1;
@


1.16
log
@Convert to C90
@
text
@d108 3
a110 3
%token NAME, LIBRARY, DESCRIPTION, STACKSIZE, HEAPSIZE, CODE, DATAU, DATAL
%token SECTIONS, EXPORTS, IMPORTS, VERSIONK, BASE, CONSTANTU, CONSTANTL
%token PRIVATEU, PRIVATEL
@


1.15
log
@Cope with NUL seperated	directives.  Fix reporting of unparseable directives.
@
text
@d81 15
a95 18
static void def_description PARAMS ((const char *));
static void def_exports PARAMS ((const char *, const char *, int, int));
static void def_heapsize PARAMS ((int, int));
static void def_import PARAMS ((const char *, const char *, const char *, const char *, int));
static void def_library PARAMS ((const char *, int));
static def_file_module *def_stash_module PARAMS ((def_file *, const char *));
static void def_name PARAMS ((const char *, int));
static void def_section PARAMS ((const char *, int));
static void def_section_alt PARAMS ((const char *, const char *));
static void def_stacksize PARAMS ((int, int));
static void def_version PARAMS ((int, int));
static void def_directive PARAMS ((char *));
static int def_parse PARAMS ((void));
static int def_error PARAMS ((const char *));
static void put_buf PARAMS ((char));
static int def_getc PARAMS ((void));
static int def_ungetc PARAMS ((int));
static int def_lex PARAMS ((void));
d218 1
a218 1
	    char * name = xmalloc (strlen ($1) + 1 + strlen ($3) + 1);
d242 1
a242 1
	    char * name = xmalloc (strlen ($1) + 1 + strlen ($3) + 1);
d271 1
a271 1
def_file_empty ()
d273 1
a273 1
  def_file *rv = (def_file *) xmalloc (sizeof (def_file));
d276 1
a276 1
  rv->base_address = (bfd_vma) (-1);
d284 1
a284 3
def_file_parse (filename, add_to)
     const char *filename;
     def_file *add_to;
d327 1
a327 2
def_file_free (def)
     def_file *def;
d388 1
a388 3
def_file_print (file, def)
     FILE *file;
     def_file *def;
d397 1
a397 1
  if (def->base_address != (bfd_vma) (-1))
d473 4
a476 5
def_file_add_export (def, external_name, internal_name, ordinal)
     def_file *def;
     const char *external_name;
     const char *internal_name;
     int ordinal;
d485 2
a486 2
	def->exports = (def_file_export *)
	  xrealloc (def->exports, max_exports * sizeof (def_file_export));
d488 1
a488 2
	def->exports = (def_file_export *)
	  xmalloc (max_exports * sizeof (def_file_export));
d504 1
a504 3
def_get_module (def, name)
     def_file *def;
     const char *name;
d512 1
a512 1
  return (def_file_module *) 0;
d516 1
a516 3
def_stash_module (def, name)
     def_file *def;
     const char *name;
d520 1
a520 1
  if ((s = def_get_module (def, name)) != (def_file_module *) 0)
d522 1
a522 1
  s = (def_file_module *) xmalloc (sizeof (def_file_module) + strlen (name));
d531 5
a535 6
def_file_add_import (def, name, module, ordinal, internal_name)
     def_file *def;
     const char *name;
     const char *module;
     int ordinal;
     const char *internal_name;
d538 1
a538 1
  int max_imports = ROUND_UP(def->num_imports, 16);
d542 1
a542 1
      max_imports = ROUND_UP(def->num_imports+1, 16);
d545 2
a546 2
	def->imports = (def_file_import *)
	  xrealloc (def->imports, max_imports * sizeof (def_file_import));
d548 1
a548 2
	def->imports = (def_file_import *)
	  xmalloc (max_imports * sizeof (def_file_import));
d581 1
a581 4
def_file_add_directive (my_def, param, len)
     def_file *my_def;
     const char *param;
     int len;
d592 2
a593 1
      while (param < pend && (ISSPACE (*param) || * param == '\n' || * param == 0))
d605 3
a607 1
	   tend < pend && !(ISSPACE (tend[-1]) && *tend == '-') && (*tend != '\n') && (*tend != 0);
d650 1
a650 3
def_name (name, base)
     const char *name;
     int base;
d660 1
a660 3
def_library (name, base)
     const char *name;
     int base;
d670 1
a670 2
def_description (text)
     const char *text;
d677 1
a677 1
      def->description = (char *) xrealloc (def->description, len);
d682 1
a682 1
      def->description = (char *) xmalloc (len);
d688 1
a688 3
def_stacksize (reserve, commit)
     int reserve;
     int commit;
d695 1
a695 3
def_heapsize (reserve, commit)
     int reserve;
     int commit;
d702 1
a702 3
def_section (name, attr)
     const char *name;
     int attr;
d705 1
a705 1
  int max_sections = ROUND_UP(def->num_section_defs, 4);
d709 1
a709 1
      max_sections = ROUND_UP(def->num_section_defs+1, 4);
d712 2
a713 1
	def->section_defs = (def_file_section *) xrealloc (def->section_defs, max_sections * sizeof (def_file_import));
d715 1
a715 1
	def->section_defs = (def_file_section *) xmalloc (max_sections * sizeof (def_file_import));
d733 1
a733 3
def_section_alt (name, attr)
     const char *name;
     const char *attr;
d763 4
a766 5
def_exports (external_name, internal_name, ordinal, flags)
     const char *external_name;
     const char *internal_name;
     int ordinal;
     int flags;
d788 5
a792 6
def_import (internal_name, module, dllext, name, ordinal)
     const char *internal_name;
     const char *module;
     const char *dllext;
     const char *name;
     int ordinal;
d797 1
a797 1
  buf = (char *) xmalloc (strlen (module) + strlen (ext) + 2);
d807 1
a807 3
def_version (major, minor)
     int major;
     int minor;
d814 1
a814 2
def_directive (str)
     char *str;
d816 1
a816 1
  struct directive *d = (struct directive *) xmalloc (sizeof (struct directive));
d825 1
a825 2
def_error (err)
     const char *err;
d827 2
a828 2
  einfo ("%P: %s:%d: %s\n", def_filename ? def_filename : "<unknown-file>", linenumber, err);

d844 1
a844 2
put_buf (c)
     char c;
d850 1
a850 1
	buffer = (char *) xrealloc (buffer, buflen + 1);
d852 1
a852 1
	buffer = (char *) xmalloc (buflen + 1);
d894 1
a894 1
def_getc ()
d915 1
a915 2
def_ungetc (c)
     int c;
d927 1
a927 1
def_lex ()
@


1.14
log
@	* defilep.y (opt_base): If no number given, set to default
	(-1), not 0.
@
text
@d604 1
a604 1
  const char *tend = param;
d611 1
a611 1
      while (param < pend && ISSPACE (*param))
d614 10
a623 2
      for (tend = param + 1;
	   tend < pend && !(ISSPACE (tend[-1]) && *tend == '-');
d639 2
a640 1
	      def_parse ();
d646 9
a654 3
	/* xgettext:c-format */
	einfo (_("Warning: .drectve `%.*s' unrecognized\n"),
	       tend - param, param);
d861 1
a861 1
  einfo ("%P: %s:%d: %s\n", def_filename, linenumber, err);
@


1.13
log
@	* deffilep.y (def_import):  Use default extension of "dll"
	if no extension provided in parsed IMPORT definition.

	* deffilep.y (def_lex): Revert 2003-03-12 change.
	(dot_name): New id type and rule.
	(expline): Use instead of ID.
	(opt_equal_name): Likewise.
@
text
@d239 1
a239 1
	|	{ $$ = 0;}
@


1.12
log
@	* deffilep.y (def_lex): Accept '.' as valid non-lead char.
@
text
@d119 1
a119 1
%type  <id> opt_name opt_equal_name 
d154 1
a154 1
		ID opt_equal_name opt_ordinal opt_comma exp_opt_list
d234 1
a234 1
          '=' ID	{ $$ = $2; }
d242 8
d810 5
a814 7

  if (dllext != NULL)
    {
      buf = (char *) xmalloc (strlen (module) + strlen (dllext) + 2);
      sprintf (buf, "%s.%s", module, dllext);
      module = buf;
    }
d1029 1
a1029 1
      while (c != EOF && (ISALNUM (c) || strchr ("$:-_?/@@.", c)))
@


1.11
log
@Add code to prevent importing a dll multiple times.
@
text
@d1023 1
a1023 1
      while (c != EOF && (ISALNUM (c) || strchr ("$:-_?/@@", c)))
@


1.10
log
@Adds support for fastcall symbols as used on Microsoft Windows platforms
(i386)
@
text
@d3 1
a3 1
/*   Copyright 1995, 1997, 1998, 1999, 2000, 2001, 2002
d6 1
a6 1
This file is part of GNU Binutils.
d8 13
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d40 1
a40 1
   generators need to be fixed instead of adding those names to this list. */
d69 2
a70 2
#define yyreds	def_reds		/* With YYDEBUG defined */
#define yytoks	def_toks		/* With YYDEBUG defined */
d84 1
a84 2
static void def_import
  PARAMS ((const char *, const char *, const char *, const char *, int));
d328 1
d391 1
d413 1
d433 1
d454 1
d464 1
d467 1
d481 1
d484 1
a484 1
      max_exports = ROUND_UP(def->num_exports+1, 32);
d486 2
a487 1
	def->exports = (def_file_export *) xrealloc (def->exports, max_exports * sizeof (def_file_export));
d489 2
a490 1
	def->exports = (def_file_export *) xmalloc (max_exports * sizeof (def_file_export));
d505 14
d525 2
a526 2
  for (s=def->modules; s; s=s->next)
    if (strcmp (s->name, name) == 0)
d546 1
d550 1
d552 2
a553 1
	def->imports = (def_file_import *) xrealloc (def->imports, max_imports * sizeof (def_file_import));
d555 2
a556 1
	def->imports = (def_file_import *) xmalloc (max_imports * sizeof (def_file_import));
d570 1
d605 1
d608 2
a609 1
	   tend++);
d614 1
d629 4
a632 5
	{
	  /* xgettext:c-format */
	  einfo (_("Warning: .drectve `%.*s' unrecognized\n"),
		 tend - param, param);
	}
d640 1
a640 3
/*****************************************************************************
 Parser Callbacks
 *****************************************************************************/
d671 1
d710 1
d714 1
d741 1
d829 1
d846 1
a846 3
/*****************************************************************************
 Lexical Scanner
 *****************************************************************************/
d851 1
a851 1
/* Never freed, but always reused as needed, so no real leak */
d862 1
a862 1
      buflen += 50;		/* overly reasonable, eh? */
d869 1
a869 1
  buffer[bufptr] = 0;		/* not optimal, but very convenient */
d911 1
d958 1
a958 1
  /* trim leading whitespace */
d981 2
a982 1
  /* must be something else */
d1053 1
@


1.9
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d3 1
a3 1
/*   Copyright 1995, 1997, 1998, 1999, 2000, 2001
d969 1
a969 1
  if (ISALPHA (c) || strchr ("$:-_?", c))
d972 18
d997 5
a1001 3
      for (i = 0; tokens[i].name; i++)
	if (strcmp (tokens[i].name, buffer) == 0)
	  {
d1003 1
a1003 1
	    printf ("lex: `%s' is a string token\n", buffer);
d1005 3
a1007 2
	    return tokens[i].token;
	  }
d1032 1
a1032 1
  if (c == '=' || c == '.' || c == '@@' || c == ',')
@


1.8
log
@	* deffilep.y (def_stash_module): Constify "name" param.

	* pe-dll.c: Replace CONST with const throughout.
	(quick_symbol): Constify "n1", "n2", "n3" params.
	(make_singleton_name_thunk): Constify "import" param.  Make
	"buffer_len" a size_t.
	(make_import_fixup_entry): Constify "name", "fixup_name",
	"dll_symname" params.
	(pe_get16): Cast args of bfd_seek.  Replace bfd_read with bfd_bread.
	(pe_get32): Likewise.
	(pe_implied_import_dll): Likewise.

	* emultempl/beos.em (sort_by_file_name): Constify "ra", "rb".
	(sort_by_section_name): Likewise.

	* emultempl/pe.em: Move defines for arm_epoc_pe before bfd.h included.
	(make_import_fixup): Cast printf arg, rel->address to long rather
	than int.
	(gld_${EMULATION_NAME}_after_open): Don't compare NULL against int.
@
text
@a22 1
#include <ctype.h>
d24 1
d575 1
a575 1
      while (param < pend && isspace (*param))
d578 1
a578 1
	   tend < pend && !(isspace (tend[-1]) && *tend == '-');
d952 1
a952 1
  if (isdigit (c))
d955 1
a955 1
      while (c != EOF && (isxdigit (c) || (c == 'x')))
d969 1
a969 1
  if (isalpha (c) || strchr ("$:-_?", c))
d972 1
a972 1
      while (c != EOF && (isalnum (c) || strchr ("$:-_?/@@", c)))
@


1.7
log
@	* deffilep.y: Add missing prototypes.
	* pe-dll.c: Likewise.
@
text
@d3 2
a4 1
/*   Copyright 1995, 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
d87 1
a87 1
static def_file_module *def_stash_module PARAMS ((def_file *, char *));
d499 1
a499 1
     char *name;
d536 1
a536 1
    i->module = def_stash_module(def, module);
@


1.6
log
@Fixtypos in ChangeLogs, fix copyright dates in files
@
text
@d3 1
a3 1
/*   Copyright 1995, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
a79 2
static int def_lex ();

d86 1
d95 3
@


1.5
log
@Added year 2000 copyright notice
@
text
@d3 1
a3 1
/*   Copyright (C) 1995, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
@


1.5.4.1
log
@Update copyright notices.
@
text
@d3 1
a3 1
/*   Copyright 1995, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
@


1.4
log
@Apply patch from Mumit Khan to fix bugs generating dll names.
@
text
@d3 1
a3 1
/*   Copyright (C) 1995, 1997, 1998, 1999 Free Software Foundation, Inc.
@


1.3
log
@* deffilep.y (tokens): Add upper and lower case versions of DATA,
CONSTANT, NONAME and PRIVATE tokens.
(command): Use DATAU.
(expline): Allow for drectve syntax as well.
(exp_opt_list): Likewise.
(exp_opt): Likewise.
* pe-dll.c (make_one): Only generate the idata entries for data
symbols.
@
text
@d217 7
a223 1
	|		{ $$ = 0; }
@


1.2
log
@	* pe-dll.h: New file.
	* pe-dll.c: Include "pe-dll.h".  Mark unused arguments as needed
	to avoid warnings.
	(edata_sz, reloc_sz): Change from int to size_t.
	(pe_details_type): Change type of imagebase_reloc from int to
	unsigned int.
	(pe_detail_list): Fully initialize last entry.
	(pe_dll_id_target): Change parameter to const.
	(pe_dll_generate_def_file): Likewise.
	(pe_dll_generate_implib): Likewise.
	(pe_implied_import_dll): Likewise.  Change dll_name to const.
	* emultempl/pe.em: Include "pe-dll.h".  Remove declarations now in
	pe-dll.h.
	(init): Fully initialize __dll__ entry.
	(gld_${EMULATION_NAME}_after_open): Remove unused variables
	sequence, elt, and i.
	* deffile.h: Add preprocessor guard.
	* deffilep.y (def_debug): Remove.
	* Makefile.am: Rebuild dependencies.
	(HFILES): Add pe-dll.h.
@
text
@d109 4
a112 3
%token NAME, LIBRARY, DESCRIPTION, STACKSIZE, HEAPSIZE, CODE, DATA
%token SECTIONS, EXPORTS, IMPORTS, VERSIONK, BASE, CONSTANT, PRIVATE
%token READ WRITE EXECUTE SHARED NONAME DIRECTIVE
d132 1
a132 1
	|	DATA attr_list  { def_section ("DATA", $2);}
d149 5
a153 2
		ID opt_equal_name opt_ordinal exp_opt_list
			{ def_exports ($1, $2, $3, $4); }
d156 4
a159 1
		exp_opt exp_opt_list { $$ = $1 | $2; }
d163 8
a170 4
		NONAME		{ $$ = 1; }
	|	CONSTANT	{ $$ = 2; }
	|	DATA		{ $$ = 4; }
	|	PRIVATE		{ $$ = 8; }
d841 4
a844 2
  { "CONSTANT", CONSTANT },
  { "DATA", DATA },
d853 4
a856 2
  { "NONAME", NONAME },
  { "PRIVATE", PRIVATE },
@


1.1
log
@Initial revision
@
text
@a95 1
static int def_debug;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

