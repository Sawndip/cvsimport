head	1.14;
access;
symbols
	binutils-2_24-branch:1.14.0.12
	binutils-2_24-branchpoint:1.14
	binutils-2_21_1:1.14
	binutils-2_23_2:1.14
	binutils-2_23_1:1.14
	binutils-2_23:1.14
	binutils-2_23-branch:1.14.0.10
	binutils-2_23-branchpoint:1.14
	binutils-2_22_branch:1.14.0.8
	binutils-2_22:1.14
	binutils-2_22-branch:1.14.0.6
	binutils-2_22-branchpoint:1.14
	binutils-2_21:1.14
	binutils-2_21-branch:1.14.0.4
	binutils-2_21-branchpoint:1.14
	binutils-2_20_1:1.14
	binutils-2_20:1.14
	binutils-arc-20081103-branch:1.12.0.8
	binutils-arc-20081103-branchpoint:1.12
	binutils-2_20-branch:1.14.0.2
	binutils-2_20-branchpoint:1.14
	dje-cgen-play1-branch:1.12.0.6
	dje-cgen-play1-branchpoint:1.12
	arc-20081103-branch:1.12.0.4
	arc-20081103-branchpoint:1.12
	binutils-2_19_1:1.12
	binutils-2_19:1.12
	binutils-2_19-branch:1.12.0.2
	binutils-2_19-branchpoint:1.12
	binutils-2_18:1.10
	binutils-2_18-branch:1.10.0.2
	binutils-2_18-branchpoint:1.10
	binutils-csl-coldfire-4_1-32:1.8
	binutils-csl-sourcerygxx-4_1-32:1.8
	binutils-csl-innovasic-fido-3_4_4-33:1.8
	binutils-csl-sourcerygxx-3_4_4-32:1.7
	binutils-csl-coldfire-4_1-30:1.8
	binutils-csl-sourcerygxx-4_1-30:1.8
	binutils-csl-coldfire-4_1-28:1.8
	binutils-csl-sourcerygxx-4_1-29:1.8
	binutils-csl-sourcerygxx-4_1-28:1.8
	binutils-csl-arm-2006q3-27:1.8
	binutils-csl-sourcerygxx-4_1-27:1.8
	binutils-csl-arm-2006q3-26:1.8
	binutils-csl-sourcerygxx-4_1-26:1.8
	binutils-csl-sourcerygxx-4_1-25:1.8
	binutils-csl-sourcerygxx-4_1-24:1.8
	binutils-csl-sourcerygxx-4_1-23:1.8
	binutils-csl-sourcerygxx-4_1-21:1.8
	binutils-csl-arm-2006q3-21:1.8
	binutils-csl-sourcerygxx-4_1-22:1.8
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.8
	binutils-csl-sourcerygxx-4_1-20:1.8
	binutils-csl-arm-2006q3-19:1.8
	binutils-csl-sourcerygxx-4_1-19:1.8
	binutils-csl-sourcerygxx-4_1-18:1.8
	binutils-csl-renesas-4_1-9:1.8
	binutils-csl-sourcerygxx-3_4_4-25:1.7
	binutils-csl-renesas-4_1-8:1.8
	binutils-csl-renesas-4_1-7:1.8
	binutils-csl-renesas-4_1-6:1.8
	binutils-csl-sourcerygxx-4_1-17:1.8
	binutils-csl-sourcerygxx-4_1-14:1.8
	binutils-csl-sourcerygxx-4_1-15:1.8
	binutils-csl-sourcerygxx-4_1-13:1.8
	binutils-2_17:1.8
	binutils-csl-sourcerygxx-4_1-12:1.8
	binutils-csl-sourcerygxx-3_4_4-21:1.8
	binutils-csl-wrs-linux-3_4_4-24:1.7
	binutils-csl-wrs-linux-3_4_4-23:1.7
	binutils-csl-sourcerygxx-4_1-9:1.8
	binutils-csl-sourcerygxx-4_1-8:1.8
	binutils-csl-sourcerygxx-4_1-7:1.8
	binutils-csl-arm-2006q1-6:1.8
	binutils-csl-sourcerygxx-4_1-6:1.8
	binutils-csl-wrs-linux-3_4_4-22:1.7
	binutils-csl-coldfire-4_1-11:1.8
	binutils-csl-sourcerygxx-3_4_4-19:1.8
	binutils-csl-coldfire-4_1-10:1.8
	binutils-csl-sourcerygxx-4_1-5:1.8
	binutils-csl-sourcerygxx-4_1-4:1.8
	binutils-csl-wrs-linux-3_4_4-21:1.7
	binutils-csl-morpho-4_1-4:1.8
	binutils-csl-sourcerygxx-3_4_4-17:1.8
	binutils-csl-wrs-linux-3_4_4-20:1.7
	binutils-2_17-branch:1.8.0.4
	binutils-2_17-branchpoint:1.8
	binutils-csl-2_17-branch:1.8.0.2
	binutils-csl-2_17-branchpoint:1.8
	binutils-csl-gxxpro-3_4-branch:1.7.0.12
	binutils-csl-gxxpro-3_4-branchpoint:1.7
	binutils-2_16_1:1.7
	binutils-csl-arm-2005q1b:1.7
	binutils-2_16:1.7
	binutils-csl-arm-2005q1a:1.7
	binutils-csl-arm-2005q1-branch:1.7.0.10
	binutils-csl-arm-2005q1-branchpoint:1.7
	binutils-2_16-branch:1.7.0.8
	binutils-2_16-branchpoint:1.7
	csl-arm-2004-q3d:1.7
	csl-arm-2004-q3:1.7
	binutils-2_15:1.7
	binutils-2_15-branchpoint:1.7
	csl-arm-2004-q1a:1.7
	csl-arm-2004-q1:1.7
	binutils-2_15-branch:1.7.0.6
	cagney_bfdfile-20040213-branch:1.7.0.4
	cagney_bfdfile-20040213-branchpoint:1.7
	cagney_bigcore-20040122-branch:1.7.0.2
	cagney_bigcore-20040122-branchpoint:1.7
	csl-arm-2003-q4:1.7
	binutils-2_14:1.4
	binutils-2_14-branch:1.4.0.6
	binutils-2_14-branchpoint:1.4
	binutils-2_13_2_1:1.4
	binutils-2_13_2:1.4
	binutils-2_13_1:1.4
	binutils-2_13:1.4
	binutils-2_13-branchpoint:1.4
	binutils-2_13-branch:1.4.0.4
	binutils-2_12_1:1.4
	binutils-2_12:1.4
	binutils-2_12-branch:1.4.0.2
	binutils-2_12-branchpoint:1.4
	cygnus_cvs_20020108_pre:1.4
	binutils-2_11_2:1.2.2.2
	binutils-2_11_1:1.2.2.2
	binutils-2_11:1.2.2.1
	x86_64versiong3:1.2
	binutils-2_11-branch:1.2.0.2
	binutils_latest_snapshot:1.14;
locks; strict;
comment	@# @;


1.14
date	2009.09.02.07.25.35;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2009.08.10.07.50.56;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2008.07.07.00.46.51;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2008.05.21.12.01.35;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2007.07.19.19.56.10;	author roland;	state Exp;
branches;
next	1.9;

1.9
date	2007.07.06.14.09.42;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2005.05.12.07.32.03;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.28.05.28.54;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2003.06.27.00.38.25;	author amodra;	state Exp;
branches;
next	1.5;

1.5
date	2003.06.25.06.40.27;	author amodra;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.13.06.14.27;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.05.05.02.03;	author amodra;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.22.00.41.50;	author nickc;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	2000.09.15.18.52.52;	author nickc;	state Exp;
branches;
next	;

1.2.2.1
date	2001.03.05.05.08.51;	author amodra;	state Exp;
branches;
next	1.2.2.2;

1.2.2.2
date	2001.06.07.03.17.16;	author amodra;	state Exp;
branches;
next	;


desc
@@


1.14
log
@update copyright dates
@
text
@# This shell script emits a C file. -*- C -*-
#   Copyright 2000, 2001, 2003, 2005, 2007, 2008, 2009
#   Free Software Foundation, Inc.
#   Written by Michael Sokolov <msokolov@@ivan.Harhan.ORG>, based on armelf.em
#
# This file is part of the GNU Binutils.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
# MA 02110-1301, USA.


# This file is sourced from elf32.em, and defines some extra routines for m68k
# embedded systems using ELF and for some other systems using m68k ELF.  While
# it is sourced from elf32.em for all m68k ELF configurations, here we include
# only the features we want depending on the configuration.

case ${target} in
  m68*-*-elf)
    echo "#define SUPPORT_EMBEDDED_RELOCS" >>e${EMULATION_NAME}.c
    ;;
esac

case ${target} in
  *-linux*)
# Don't use multi-GOT by default due to glibc linker's assumption
# that GOT pointer points to GOT[0].
#   got_handling_target_default=GOT_HANDLING_MULTIGOT
    got_handling_target_default=GOT_HANDLING_SINGLE
    ;;
  *)
    got_handling_target_default=GOT_HANDLING_SINGLE
    ;;
esac

fragment <<EOF

#define GOT_HANDLING_SINGLE   (0)
#define GOT_HANDLING_NEGATIVE (1)
#define GOT_HANDLING_MULTIGOT (2)
#define GOT_HANDLING_TARGET_DEFAULT ${got_handling_target_default}

/* How to generate GOT.  */
static int got_handling = GOT_HANDLING_DEFAULT;

#ifdef SUPPORT_EMBEDDED_RELOCS
static void check_sections (bfd *, asection *, void *);
#endif

/* This function is run after all the input files have been opened.  */

static void
m68k_elf_after_open (void)
{
  /* Call the standard elf routine.  */
  gld${EMULATION_NAME}_after_open ();

#ifdef SUPPORT_EMBEDDED_RELOCS
  if (command_line.embedded_relocs
      && (! link_info.relocatable))
    {
      bfd *abfd;

      /* In the embedded relocs mode we create a .emreloc section for each
	 input file with a nonzero .data section.  The BFD backend will fill in
	 these sections with magic numbers which can be used to relocate the
	 data section at run time.  */
      for (abfd = link_info.input_bfds; abfd != NULL; abfd = abfd->link_next)
	{
	  asection *datasec;

	  /* As first-order business, make sure that each input BFD is either
	     COFF or ELF.  We need to call a special BFD backend function to
	     generate the embedded relocs, and we have such functions only for
	     COFF and ELF.  */
	  if (bfd_get_flavour (abfd) != bfd_target_coff_flavour
	      && bfd_get_flavour (abfd) != bfd_target_elf_flavour)
	    einfo ("%F%B: all input objects must be COFF or ELF for --embedded-relocs\n");

	  datasec = bfd_get_section_by_name (abfd, ".data");

	  /* Note that we assume that the reloc_count field has already
	     been set up.  We could call bfd_get_reloc_upper_bound, but
	     that returns the size of a memory buffer rather than a reloc
	     count.  We do not want to call bfd_canonicalize_reloc,
	     because although it would always work it would force us to
	     read in the relocs into BFD canonical form, which would waste
	     a significant amount of time and memory.  */
	  if (datasec != NULL && datasec->reloc_count > 0)
	    {
	      asection *relsec;

	      relsec = bfd_make_section_with_flags (abfd, ".emreloc",
						    (SEC_ALLOC
						    | SEC_LOAD
						    | SEC_HAS_CONTENTS
						    | SEC_IN_MEMORY));
	      if (relsec == NULL
		  || ! bfd_set_section_alignment (abfd, relsec, 2)
		  || ! bfd_set_section_size (abfd, relsec,
					     datasec->reloc_count * 12))
		einfo ("%F%B: can not create .emreloc section: %E\n");
	    }

	  /* Double check that all other data sections are empty, as is
	     required for embedded PIC code.  */
	  bfd_map_over_sections (abfd, check_sections, datasec);
	}
    }
#endif /* SUPPORT_EMBEDDED_RELOCS */
}

#ifdef SUPPORT_EMBEDDED_RELOCS
/* Check that of the data sections, only the .data section has
   relocs.  This is called via bfd_map_over_sections.  */

static void
check_sections (bfd *abfd, asection *sec, void *datasec)
{
  if ((bfd_get_section_flags (abfd, sec) & SEC_DATA)
      && sec != datasec
      && sec->reloc_count != 0)
    einfo ("%B%X: section %s has relocs; can not use --embedded-relocs\n",
	   abfd, bfd_get_section_name (abfd, sec));
}

#endif /* SUPPORT_EMBEDDED_RELOCS */

/* This function is called after the section sizes and offsets have
   been set.  */

static void
m68k_elf_after_allocation (void)
{
  /* Call the standard elf routine.  */
  gld${EMULATION_NAME}_after_allocation ();

#ifdef SUPPORT_EMBEDDED_RELOCS
  if (command_line.embedded_relocs
      && (! link_info.relocatable))
    {
      bfd *abfd;

      /* If we are generating embedded relocs, call a special BFD backend
	 routine to do the work.  */
      for (abfd = link_info.input_bfds; abfd != NULL; abfd = abfd->link_next)
	{
	  asection *datasec, *relsec;
	  char *errmsg;

	  datasec = bfd_get_section_by_name (abfd, ".data");

	  if (datasec == NULL || datasec->reloc_count == 0)
	    continue;

	  relsec = bfd_get_section_by_name (abfd, ".emreloc");
	  ASSERT (relsec != NULL);

	  if (bfd_get_flavour (abfd) == bfd_target_coff_flavour)
	    {
	      if (! bfd_m68k_coff_create_embedded_relocs (abfd, &link_info,
							  datasec, relsec,
							  &errmsg))
		{
		  if (errmsg == NULL)
		    einfo ("%B%X: can not create runtime reloc information: %E\n",
			   abfd);
		  else
		    einfo ("%X%B: can not create runtime reloc information: %s\n",
			   abfd, errmsg);
		}
	    }
	  else if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)
	    {
	      if (! bfd_m68k_elf32_create_embedded_relocs (abfd, &link_info,
							   datasec, relsec,
							   &errmsg))
		{
		  if (errmsg == NULL)
		    einfo ("%B%X: can not create runtime reloc information: %E\n",
			   abfd);
		  else
		    einfo ("%X%B: can not create runtime reloc information: %s\n",
			   abfd, errmsg);
		}
	    }
	  else
	    abort ();
	}
    }
#endif /* SUPPORT_EMBEDDED_RELOCS */
}

/* This is a convenient point to tell BFD about target specific flags.
   After the output has been created, but before inputs are read.  */

static void
elf_m68k_create_output_section_statements (void)
{
  bfd_elf_m68k_set_target_options (&link_info, got_handling);
}

EOF

# Define some shell vars to insert bits of code into the standard elf
# parse_args and list_options functions.
#
PARSE_AND_LIST_PROLOGUE='
#define OPTION_GOT	301
'

PARSE_AND_LIST_LONGOPTS='
  { "got", required_argument, NULL, OPTION_GOT},
'

PARSE_AND_LIST_OPTIONS='
  fprintf (file, _("  --got=<type>                Specify GOT handling scheme\n"));
'

PARSE_AND_LIST_ARGS_CASES='
    case OPTION_GOT:
      if (strcmp (optarg, "target") == 0)
        got_handling = GOT_HANDLING_TARGET_DEFAULT;
      else if (strcmp (optarg, "single") == 0)
        got_handling = 0;
      else if (strcmp (optarg, "negative") == 0)
        got_handling = 1;
      else if (strcmp (optarg, "multigot") == 0)
        got_handling = 2;
      else
        einfo (_("Unrecognized --got argument '\''%s'\''.\n"), optarg);
      break;
'

# We have our own after_open and after_allocation functions, but they call
# the standard routines, so give them a different name.
LDEMUL_AFTER_OPEN=m68k_elf_after_open
LDEMUL_AFTER_ALLOCATION=m68k_elf_after_allocation
LDEMUL_CREATE_OUTPUT_SECTION_STATEMENTS=elf_m68k_create_output_section_statements
@


1.13
log
@	PR 10474
	* ldemul.c (after_allocation_default): Run lang_relax_sections.
	* ldlang.h (lang_relax_sections): Declare.
	* ldlang.c (relax_sections): Delete.
	(lang_relax_sections): New function.
	(lang_process): Don't relax directly from here.
	* emultempl/alphaelf.em (alpha_finish): Call finish_default.
	* emultempl/armelf.em (arm_elf_after_allocation): Delete.  Move body..
	(gld${EMULATION_NAME}_finish): ..to here.  Move existing code..
	(gld${EMULATION_NAME}_after_allocation): ..to here.  New function.
	(LDEMUL_AFTER_ALLOCATION): Update.
	* emultempl/avrelf.em (avr_elf_finish, LDEMUL_FINISH): Delete.
	(avr_elf_after_allocation): New function.
	(LDEMUL_AFTER_ALLOCATION): Define.
	* emultempl/elf-generic.em (gld${EMULATION_NAME}_map_segments): Call
	lang_relax_sections.
	* emultempl/elf32.em (gld${EMULATION_NAME}_finish): Delete.  Move..
	(gld${EMULATION_NAME}_after_allocation): ..code to here.  New function.
	(LDEMUL_AFTER_ALLOCATION, LDEMUL_FINISH): Update.
	* emultempl/genelf.em (gld${EMULATION_NAME}_finish): Delete.  Move..
	(gld${EMULATION_NAME}_after_allocation): ..code to here.  New function.
	(LDEMUL_FINISH): Delete.
	(LDEMUL_AFTER_ALLOCATION): Define.
	* emultempl/hppaelf.em (gld${EMULATION_NAME}_finish): Delete.  Move..
	(gld${EMULATION_NAME}_after_allocation): ..to here.  New function.
	(LDEMUL_FINISH): Delete.
	(LDEMUL_AFTER_ALLOCATION): Define.
	* emultempl/m68hc1xelf.em (m68hc11elf_finish): Delete.  Move..
	(m68hc11elf_after_allocation): ..to here.  New function.
	(LDEMUL_FINISH): Delete.
	(LDEMUL_AFTER_ALLOCATION): Define.
	* emultempl/m68kelf.em (m68k_elf_after_allocation): Call
	gld${EMULATION_NAME}_after_allocation.
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): Call
	gld${EMULATION_NAME}_after_allocation.
	* emultempl/mmo.em (mmo_finish): Delete.  Move body..
	(gld${EMULATION_NAME}_after_allocation): ..to here.  New function.
	(LDEMUL_FINISH): Define.
	* emultempl/ppc64elf.em (ppc_layout_sections_again): Set elf_gp.
	(gld${EMULATION_NAME}_finish): Move code sizing sections..
	(gld${EMULATION_NAME}_after_allocation): ..to here.
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_after_allocation):
	Call gld${EMULATION_NAME}_after_allocation.
	* emultempl/spuelf.em (gld${EMULATION_NAME}_finish): Delete
	bfd_elf_discard_info and map_segments call.
@
text
@d2 2
a3 1
#   Copyright 2000, 2001, 2003, 2007, 2008 Free Software Foundation, Inc.
@


1.12
log
@	* emultempl/armelf.em (elf32_arm_add_stub_section): Use
	bfd_make_section_with_flags.
	* emultempl/avrelf.em (avr_elf_create_output_section_statements):
	Likewise.
	* emultempl/hppaelf.em (hppaelf_add_stub_section): Likewise.
	* emultempl/m68hc1xelf.em (m68hc11elf_add_stub_section): Likewise.
	* emultempl/m68kcoff.em (gld${EMULATION_NAME}_after_open): Likewise.
	* emultempl/m68kelf.em (m68k_elf_after_open): Likewise.
	* emultempl/ppc64elf.em (ppc_add_stub_section): Likewise.
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation):
	Likewise.
@
text
@d146 1
a146 1
  after_allocation_default ();
@


1.11
log
@        Multi-GOT support for m68k.

        bfd/

        * elf32-m68k.c (struct elf_m68k_link_hash_entry: got_entry_key,
        glist): New fields.
        (struct elf_m68k_got_entry_key, struct elf_m68k_got_entry,
        struct elf_m68k_got, struct elf_m68k_bfd2got_entry,
        struct elf_m68k_multi_got): New data structures.
        (struct elf_m68k_link_hash_table: local_gp_p, use_neg_got_offsets_p,
        allow_multigot_p, multi_got_): New fields.
        (elf_m68k_multi_got): New macro.
        (elf_m68k_link_hash_newfunc): Initialize new fields of
        struct elf_m68k_link_hash_entry.
        (elf_m68k_link_hash_table_create): Initialize new fields of
        struct elf_m68k_link_hash_table.
        (elf_m68k_link_hash_table_free): New static function implementing hook.
        (elf_m68k_init_got, elf_m68k_clear_got, elf_m68k_create_empty_got): New
        static functions for struct elf_m68k_got.
        (elf_m68k_init_got_entry_key, elf_m68k_got_entry_hash,
        elf_m68k_got_entry_eq): New static functions for
        struct elf_m68k_got_entry.
        (ELF_M68K_REL_8O_MAX_N_ENTRIES_IN_GOT,
        ELF_M68K_REL_8O_16O_MAX_N_ENTRIES_IN_GOT): New macros.
        (enum elf_m68k_get_entry_howto): New enum.
        (elf_m68k_get_got_entry, elf_m68k_update_got_entry_type,
        elf_m68k_remove_got_entry_type): New static functions for
        struct elf_m68k_got_entry.
        (elf_m68k_add_entry_to_got): New static function.
        (elf_m68k_bfd2got_entry_hash, elf_m68k_bfd2got_entry_eq,
        elf_m68k_bfd2got_entry_del, elf_m68k_get_bfd2got_entry): New static
        functions for struct elf_m68k_bfd2got_entry.
        (struct elf_m68k_can_merge_gots_arg, elf_m68k_can_merge_gots_1,
        elf_m68k_can_merge_gots): New traversal.
        (struct elf_m68k_merge_gots_arg, elf_m68k_merge_gots_1,
        elf_m68k_merge_gots): Ditto.
        (struct elf_m68k_finalize_got_offsets_arg,
        elf_m68k_finalize_got_offsets_1, elf_m68k_finalize_got_offsets): Ditto.
        (struct elf_m68k_partition_multi_got_arg,
        elf_m68k_partition_multi_got_1, elf_m68k_init_symndx2h_1,
        elf_m68k_partition_multi_got): Ditto.
        (elf_m68k_find_got_entry_ptr, elf_m68k_remove_got_entry): New static
        functions.
        (elf_m68k_copy_indirect_symbol): New static function implementing
        a hook.
        (elf_m68k_check_relocs): Update to add entries to multi-GOT.
        (elf_m68k_gc_sweep_hook): Update to remove entries from multi-GOT.
        (elf_m68k_always_size_sections): Assign BFDs to GOTs.
        (elf_m68k_relocate_section): Update to properly handle GOT relocations.
        (elf_m68k_finish_dynamic_symbol): Update to traverse all GOT entries
        of a global symbol.
        (bfd_elf_m68k_set_target_options): New function.
        (bfd_elf32_bfd_link_hash_table_free): Define hook.
        (bfd_elf32_bfd_final_link): Change expansion to bfd_elf_final_link
        to skip generic calculation of GOT offsets.
        (elf_backend_copy_indirect_symbol): Define hook.

        * bfd-in.h (bfd_elf_m68k_set_target_options): Declare function.
        * bfd-in2.h: Regenerate.

        ld/

        * configure.in (--enable-got): New option.  Handle it.
        * configure: Regenerate.
        * config.in: Regenerate.

        * emultempl/m68kelf.em: (got_handling_target_default): New shell
        variable.
        (GOT_HANDLING_TARGET_DEFAULT): New macro.
        (GOT_HANDLING_DEFAULT): New macro.  Initialize it from configure
        option if one was given.
        (got_handling): New static variable.
        (elf_m68k_create_output_section_statements): New static function
        implementing hook.
        (PARSE_AND_LIST_PROLOGUE): Define shell variable.
        (OPTION_GOT): New macro.
        (PARSE_AND_LIST_LONGOPTS): Define shell variable.  Specify
        --got option.
        (got): New linker option.
        (PARSE_AND_LIST_OPTIONS): Define shell variable.  Print help string
        for --got option.
        (PARSE_AND_LIST_ARGS_CASES): Define shell variable.  Handle --got
        option.

        * ld.texinfo: Document --got=<type> option.
        * gen-doc.texi: Add M68K.
        * NEWS: Mention the new feature.

        ld/testsuite/

        * ld-m68k/got-12.s: New file.
        * ld-m68k/got-13.s: New file.
        * ld-m68k/got-14.s: New file.
        * ld-m68k/got-15.s: New file.
        * ld-m68k/got-34.s: New file.
        * ld-m68k/got-35.s: New file.
        * ld-m68k/got-single-12-ok.d: New dump test.
        * ld-m68k/got-single-13-er.d: New dump test.
        * ld-m68k/got-negative-14-ok.d: New dump test.
        * ld-m68k/got-negative-15-er.d: New dump test.
        * ld-m68k/got-negative-12-13-14-34-ok.d: New dump test.
        * ld-m68k/got-negative-12-13-14-35-er.d: New dump test.
        * ld-m68k/got-multigot-14-ok.d: New dump test.
        * ld-m68k/got-multigot-15-er.d: New dump test.
        * ld-m68k/got-multigot-12-13-14-34-35-ok.d: New dump test.
        * ld-m68k/xgot-15.s: New source.
        * ld-m68k/got-xgot-15-ok.d: New test.
        * ld-m68k/got-xgot-12-13-14-15-34-35-ok.d: New test.
        * ld-m68k/m68k.exp: Run new tests.
@
text
@d103 5
a107 1
	      relsec = bfd_make_section (abfd, ".emreloc");
a108 5
		  || ! bfd_set_section_flags (abfd, relsec,
					      (SEC_ALLOC
					       | SEC_LOAD
					       | SEC_HAS_CONTENTS
					       | SEC_IN_MEMORY))
@


1.10
log
@2007-07-19  Roland McGrath  <roland@@redhat.com>

	* genscripts.sh (source_em, fragment): New sh functions.
	Truncate e${EMULATION_NAME}.c file before .em script fills it.
	Use source_em in place of . for the .em script.
	* emultempl/generic.em: Use fragment and source_em functions.
	* emultempl/aix.em: Likewise.
	* emultempl/alphaelf.em: Likewise.
	* emultempl/armcoff.em: Likewise.
	* emultempl/armelf.em: Likewise.
	* emultempl/avrelf.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/cr16elf.em: Likewise.
	* emultempl/crxelf.em: Likewise.
	* emultempl/elf-generic.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/genelf.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/gld960c.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/ia64elf.em: Likewise.
	* emultempl/irix.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68hc1xelf.em: Likewise.
	* emultempl/m68kcoff.em: Likewise.
	* emultempl/m68kelf.em: Likewise.
	* emultempl/mipsecoff.em: Likewise.
	* emultempl/mipself.em: Likewise.
	* emultempl/mmix-elfnmmo.em: Likewise.
	* emultempl/mmixelf.em: Likewise.
	* emultempl/mmo.em: Likewise.
	* emultempl/needrelax.em: Likewise.
	* emultempl/netbsd.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/scoreelf.em: Likewise.
	* emultempl/sh64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/ticoff.em: Likewise.
	* emultempl/vanilla.em: Likewise.
	* emultempl/vxworks.em: Likewise.
	* emultempl/xtensaelf.em: Likewise.
	* emultempl/z80.em: Likewise.
@
text
@d2 1
a2 1
#   Copyright 2000, 2001, 2003, 2007 Free Software Foundation, Inc.
d34 12
d48 8
d205 9
d216 30
d250 1
@


1.9
log
@Update sources to GPLv3
@
text
@d34 1
a34 1
cat >>e${EMULATION_NAME}.c <<EOF
@


1.8
log
@Update FSF addresses
@
text
@d2 1
a2 1
#   Copyright 2000, 2001, 2003 Free Software Foundation, Inc.
d5 1
a5 1
# This file is part of GLD, the Gnu Linker.
d9 1
a9 1
# the Free Software Foundation; either version 2 of the License, or
d19 3
a21 1
# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
@


1.7
log
@Convert to C90
@
text
@d19 1
a19 1
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
@


1.6
log
@	* emultempl/aix.em: Convert to C90, remove unnecessary prototypes
	and casts.  Replace PTR with void *.  Formatting.
	* emultempl/alphaelf.em: Likewise
	* emultempl/armcoff.em: Likewise
	* emultempl/armelf.em: Likewise
	* emultempl/armelf_oabi.em: Likewise
	* emultempl/beos.em: Likewise
	* emultempl/elf32.em: Likewise
	* emultempl/generic.em: Likewise
	* emultempl/gld960.em: Likewise
	* emultempl/gld960c.em: Likewise
	* emultempl/hppaelf.em: Likewise
	* emultempl/linux.em: Likewise
	* emultempl/lnk960.em: Likewise
	* emultempl/m68hc1xelf.em: Likewise
	* emultempl/m68kcoff.em: Likewise
	* emultempl/m68kelf.em: Likewise
	* emultempl/mipsecoff.em: Likewise
	* emultempl/mipself.em: Likewise
	* emultempl/mmix-elfnmmo.em: Likewise
	* emultempl/mmixelf.em: Likewise
	* emultempl/mmo.em: Likewise
	* emultempl/needrelax.em: Likewise
	* emultempl/netbsd.em: Likewise
	* emultempl/pe.em: Likewise
	* emultempl/sh64elf.em: Likewise
	* emultempl/sunos.em: Likewise
	* emultempl/ticoff.em: Likewise
	* emultempl/vanilla.em: Likewise
	* emultempl/xtensaelf.em: Likewise
	* Makefile.am: Correct dependencies.
	* Makefile.in: Regenerate.
@
text
@d96 1
a96 1
	  bfd_map_over_sections (abfd, check_sections, (PTR) datasec);
d107 1
a107 1
check_sections (bfd *abfd, asection *sec, PTR datasec)
d110 1
a110 1
      && sec != (asection *) datasec
@


1.5
log
@Correct spelling of "relocatable".
@
text
@a33 1
static void m68k_elf_after_open PARAMS ((void));
d35 1
a35 1
static void check_sections PARAMS ((bfd *, asection *, PTR));
a36 1
static void m68k_elf_after_allocation PARAMS ((void));
d41 1
a41 1
m68k_elf_after_open ()
d107 1
a107 4
check_sections (abfd, sec, datasec)
     bfd *abfd;
     asection *sec;
     PTR datasec;
d122 1
a122 1
m68k_elf_after_allocation ()
@


1.4
log
@Fixtypos in ChangeLogs, fix copyright dates in files
@
text
@d2 1
a2 1
#   Copyright 2000, 2001 Free Software Foundation, Inc.
d50 1
a50 1
      && (! link_info.relocateable))
d134 1
a134 1
      && (! link_info.relocateable))
@


1.3
log
@* emultempl/m68kelf.em (m68k_elf_after_allocation): Call
after_allocation_default, not gld..._before_allocation.
@
text
@d2 1
a2 1
#   Copyright (C) 2000 Free Software Foundation, Inc.
@


1.2
log
@Conditionalise the embedded relocs feature on the m68*-*-elf target
@
text
@d130 1
a130 1
  gld${EMULATION_NAME}_before_allocation ();
@


1.2.2.1
log
@* emultempl/m68kelf.em (m68k_elf_after_allocation): Call
after_allocation_default, not gld..._before_allocation.
@
text
@d130 1
a130 1
  after_allocation_default ();
@


1.2.2.2
log
@Update copyright notices.
@
text
@d2 1
a2 1
#   Copyright 2000, 2001 Free Software Foundation, Inc.
@


1.1
log
@add support for embedded relocs in m68k ELF port
@
text
@a19 1
#
d21 11
a31 3
# This file is sourced from elf32.em, and defines extra m68k ELF
# specific routines.
#
d34 2
a35 1
static void m68k_elf_after_open PARAMS((void));
d37 1
d40 1
a40 5
/* This function is run after all the input files have been opened.
   We create a .emreloc section for each input file with a non zero
   .data section.  The BFD backend will fill in these sections with
   magic numbers which can be used to relocate the data section at run
   time.  */
a44 2
  bfd *abfd;

d48 3
a50 5
  if (! command_line.embedded_relocs
      || link_info.relocateable)
    return;

  for (abfd = link_info.input_bfds; abfd != NULL; abfd = abfd->link_next)
d52 1
a52 1
      asection *datasec;
d54 5
a58 15
      /* As first-order business, make sure that each input BFD is ELF. It
         better be, as we are directly calling a ELF backend function.  */
      if (bfd_get_flavour (abfd) != bfd_target_elf_flavour)
	einfo ("%F%B: all input objects must be ELF for --embedded-relocs\n");

      datasec = bfd_get_section_by_name (abfd, ".data");

      /* Note that we assume that the reloc_count field has already
         been set up.  We could call bfd_get_reloc_upper_bound, but
         that returns the size of a memory buffer rather than a reloc
         count.  We do not want to call bfd_canonicalize_reloc,
         because although it would always work it would force us to
         read in the relocs into BFD canonical form, which would waste
         a significant amount of time and memory.  */
      if (datasec != NULL && datasec->reloc_count > 0)
d60 1
a60 1
	  asection *relsec;
d62 37
a98 11
	  relsec = bfd_make_section (abfd, ".emreloc");
	  if (relsec == NULL
	      || ! bfd_set_section_flags (abfd, relsec,
					  (SEC_ALLOC
					   | SEC_LOAD
					   | SEC_HAS_CONTENTS
					   | SEC_IN_MEMORY))
	      || ! bfd_set_section_alignment (abfd, relsec, 2)
	      || ! bfd_set_section_size (abfd, relsec,
					 datasec->reloc_count * 12))
	    einfo ("%F%B: can not create .emreloc section: %E\n");
a99 4

      /* Double check that all other data sections are empty, as is
         required for embedded PIC code.  */
      bfd_map_over_sections (abfd, check_sections, (PTR) datasec);
d101 1
d104 1
d121 2
d124 1
a124 2
   been set.  If we are generating embedded relocs, it calls a special
   BFD backend routine to do the work.  */
a128 2
  bfd *abfd;

d132 3
a134 5
  if (! command_line.embedded_relocs
      || link_info.relocateable)
    return;

  for (abfd = link_info.input_bfds; abfd != NULL; abfd = abfd->link_next)
d136 1
a136 2
      asection *datasec, *relsec;
      char *errmsg;
d138 6
a143 1
      datasec = bfd_get_section_by_name (abfd, ".data");
d145 1
a145 2
      if (datasec == NULL || datasec->reloc_count == 0)
	continue;
d147 2
a148 2
      relsec = bfd_get_section_by_name (abfd, ".emreloc");
      ASSERT (relsec != NULL);
d150 31
a180 7
      if (! bfd_m68k_elf32_create_embedded_relocs (abfd, &link_info,
						   datasec, relsec,
						   &errmsg))
	{
	  if (errmsg == NULL)
	    einfo ("%B%X: can not create runtime reloc information: %E\n",
		   abfd);
d182 1
a182 2
	    einfo ("%X%B: can not create runtime reloc information: %s\n",
		   abfd, errmsg);
d185 1
@

