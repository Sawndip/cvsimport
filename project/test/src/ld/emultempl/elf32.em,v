head	1.247;
access;
symbols
	binutils-2_24-branch:1.246.0.2
	binutils-2_24-branchpoint:1.246
	binutils-2_21_1:1.214.2.2
	binutils-2_23_2:1.229.2.2
	binutils-2_23_1:1.229
	binutils-2_23:1.229
	binutils-2_23-branch:1.229.0.2
	binutils-2_23-branchpoint:1.229
	binutils-2_22_branch:1.223.2.1.0.2
	binutils-2_22:1.223.2.1
	binutils-2_22-branch:1.223.0.2
	binutils-2_22-branchpoint:1.223
	binutils-2_21:1.214
	binutils-2_21-branch:1.214.0.2
	binutils-2_21-branchpoint:1.214
	binutils-2_20_1:1.201.2.2
	binutils-2_20:1.201.2.2
	binutils-arc-20081103-branch:1.196.0.4
	binutils-arc-20081103-branchpoint:1.196
	binutils-2_20-branch:1.201.0.2
	binutils-2_20-branchpoint:1.201
	dje-cgen-play1-branch:1.197.0.2
	dje-cgen-play1-branchpoint:1.197
	arc-20081103-branch:1.196.0.2
	arc-20081103-branchpoint:1.196
	binutils-2_19_1:1.192
	binutils-2_19:1.192
	binutils-2_19-branch:1.192.0.2
	binutils-2_19-branchpoint:1.192
	binutils-2_18:1.184.2.1
	binutils-2_18-branch:1.184.0.2
	binutils-2_18-branchpoint:1.184
	binutils-csl-coldfire-4_1-32:1.162.2.3
	binutils-csl-sourcerygxx-4_1-32:1.162.2.3
	binutils-csl-innovasic-fido-3_4_4-33:1.162.2.3
	binutils-csl-sourcerygxx-3_4_4-32:1.131.2.2
	binutils-csl-coldfire-4_1-30:1.162.2.2
	binutils-csl-sourcerygxx-4_1-30:1.162.2.2
	binutils-csl-coldfire-4_1-28:1.162.2.2
	binutils-csl-sourcerygxx-4_1-29:1.162.2.3
	binutils-csl-sourcerygxx-4_1-28:1.162.2.2
	binutils-csl-arm-2006q3-27:1.162.2.2
	binutils-csl-sourcerygxx-4_1-27:1.162.2.2
	binutils-csl-arm-2006q3-26:1.162.2.1
	binutils-csl-sourcerygxx-4_1-26:1.162.2.1
	binutils-csl-sourcerygxx-4_1-25:1.162.2.1
	binutils-csl-sourcerygxx-4_1-24:1.162.2.1
	binutils-csl-sourcerygxx-4_1-23:1.162.2.1
	binutils-csl-sourcerygxx-4_1-21:1.162.2.1
	binutils-csl-arm-2006q3-21:1.162.2.1
	binutils-csl-sourcerygxx-4_1-22:1.162.2.1
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.162.2.1
	binutils-csl-sourcerygxx-4_1-20:1.162.2.1
	binutils-csl-arm-2006q3-19:1.162.2.1
	binutils-csl-sourcerygxx-4_1-19:1.162.2.1
	binutils-csl-sourcerygxx-4_1-18:1.162.2.1
	binutils-csl-renesas-4_1-9:1.162.2.1
	binutils-csl-sourcerygxx-3_4_4-25:1.131.2.2
	binutils-csl-renesas-4_1-8:1.162
	binutils-csl-renesas-4_1-7:1.162
	binutils-csl-renesas-4_1-6:1.162
	binutils-csl-sourcerygxx-4_1-17:1.162
	binutils-csl-sourcerygxx-4_1-14:1.162
	binutils-csl-sourcerygxx-4_1-15:1.162
	binutils-csl-sourcerygxx-4_1-13:1.162
	binutils-2_17:1.164.2.1
	binutils-csl-sourcerygxx-4_1-12:1.162
	binutils-csl-sourcerygxx-3_4_4-21:1.162
	binutils-csl-wrs-linux-3_4_4-24:1.131.2.1.2.1
	binutils-csl-wrs-linux-3_4_4-23:1.131.2.1.2.1
	binutils-csl-sourcerygxx-4_1-9:1.162
	binutils-csl-sourcerygxx-4_1-8:1.162
	binutils-csl-sourcerygxx-4_1-7:1.162
	binutils-csl-arm-2006q1-6:1.162
	binutils-csl-sourcerygxx-4_1-6:1.162
	binutils-csl-wrs-linux-3_4_4-22:1.131.2.1.2.1
	binutils-csl-coldfire-4_1-11:1.162
	binutils-csl-sourcerygxx-3_4_4-19:1.162
	binutils-csl-coldfire-4_1-10:1.162
	binutils-csl-sourcerygxx-4_1-5:1.162
	binutils-csl-sourcerygxx-4_1-4:1.162
	binutils-csl-wrs-linux-3_4_4-21:1.131.2.1.2.1
	binutils-csl-morpho-4_1-4:1.162
	binutils-csl-sourcerygxx-3_4_4-17:1.162
	binutils-csl-wrs-linux-3_4_4-20:1.131.2.1.2.1
	binutils-2_17-branch:1.164.0.2
	binutils-2_17-branchpoint:1.164
	binutils-csl-2_17-branch:1.162.0.2
	binutils-csl-2_17-branchpoint:1.162
	binutils-csl-gxxpro-3_4-branch:1.131.2.2.0.2
	binutils-csl-gxxpro-3_4-branchpoint:1.131.2.2
	binutils-2_16_1:1.131.2.2
	binutils-csl-arm-2005q1b:1.131.2.1.2.1
	binutils-2_16:1.131.2.2
	binutils-csl-arm-2005q1a:1.131.2.1
	binutils-csl-arm-2005q1-branch:1.131.2.1.0.2
	binutils-csl-arm-2005q1-branchpoint:1.131.2.1
	binutils-2_16-branch:1.131.0.2
	binutils-2_16-branchpoint:1.131
	csl-arm-2004-q3d:1.125
	csl-arm-2004-q3:1.121
	binutils-2_15:1.108.6.1
	binutils-2_15-branchpoint:1.108
	csl-arm-2004-q1a:1.112
	csl-arm-2004-q1:1.111
	binutils-2_15-branch:1.108.0.6
	cagney_bfdfile-20040213-branch:1.108.0.4
	cagney_bfdfile-20040213-branchpoint:1.108
	cagney_bigcore-20040122-branch:1.108.0.2
	cagney_bigcore-20040122-branchpoint:1.108
	csl-arm-2003-q4:1.106
	binutils-2_14:1.95
	binutils-2_14-branch:1.95.0.2
	binutils-2_14-branchpoint:1.95
	binutils-2_13_2_1:1.79.2.4
	binutils-2_13_2:1.79.2.4
	binutils-2_13_1:1.79.2.3
	binutils-2_13:1.79.2.1
	binutils-2_13-branchpoint:1.79
	binutils-2_13-branch:1.79.0.2
	binutils-2_12_1:1.71.2.1
	binutils-2_12:1.71
	binutils-2_12-branch:1.71.0.2
	binutils-2_12-branchpoint:1.71
	cygnus_cvs_20020108_pre:1.70
	binutils-2_11_2:1.41.2.2
	binutils-2_11_1:1.41.2.2
	binutils-2_11:1.41.2.1
	x86_64versiong3:1.41
	binutils-2_11-branch:1.41.0.2
	binutils-2_10_1:1.12.2.2
	binutils-2_10:1.12
	binutils-2_10-branch:1.12.0.2
	binutils-2_10-branchpoint:1.12
	binutils_latest_snapshot:1.247
	repo-unification-2000-02-06:1.10
	binu_ss_19990721:1.4
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@# @;


1.247
date	2013.10.09.18.16.18;	author roland;	state Exp;
branches;
next	1.246;

1.246
date	2013.05.03.15.19.26;	author macro;	state Exp;
branches
	1.246.2.1;
next	1.245;

1.245
date	2013.05.03.15.01.19;	author macro;	state Exp;
branches;
next	1.244;

1.244
date	2013.05.01.17.18.43;	author macro;	state Exp;
branches;
next	1.243;

1.243
date	2013.04.26.01.26.45;	author amodra;	state Exp;
branches;
next	1.242;

1.242
date	2013.04.04.14.38.47;	author amodra;	state Exp;
branches;
next	1.241;

1.241
date	2013.02.21.04.35.22;	author amodra;	state Exp;
branches;
next	1.240;

1.240
date	2013.02.18.23.50.32;	author amodra;	state Exp;
branches;
next	1.239;

1.239
date	2013.02.05.21.47.32;	author amodra;	state Exp;
branches;
next	1.238;

1.238
date	2013.02.05.01.36.04;	author hjl;	state Exp;
branches;
next	1.237;

1.237
date	2013.01.22.22.07.34;	author roland;	state Exp;
branches;
next	1.236;

1.236
date	2013.01.21.08.21.46;	author vapier;	state Exp;
branches;
next	1.235;

1.235
date	2013.01.08.06.10.39;	author amodra;	state Exp;
branches;
next	1.234;

1.234
date	2012.12.06.00.25.18;	author hjl;	state Exp;
branches;
next	1.233;

1.233
date	2012.11.21.19.56.38;	author roland;	state Exp;
branches;
next	1.232;

1.232
date	2012.11.20.22.16.04;	author hjl;	state Exp;
branches;
next	1.231;

1.231
date	2012.11.01.14.26.47;	author nathan;	state Exp;
branches;
next	1.230;

1.230
date	2012.10.23.09.33.55;	author nathan;	state Exp;
branches;
next	1.229;

1.229
date	2012.07.13.13.20.27;	author nickc;	state Exp;
branches
	1.229.2.1;
next	1.228;

1.228
date	2012.05.25.01.13.59;	author amodra;	state Exp;
branches;
next	1.227;

1.227
date	2012.05.16.10.43.41;	author nickc;	state Exp;
branches;
next	1.226;

1.226
date	2012.05.14.19.45.28;	author jwlemke;	state Exp;
branches;
next	1.225;

1.225
date	2012.03.05.22.43.40;	author amodra;	state Exp;
branches;
next	1.224;

1.224
date	2011.10.19.04.13.28;	author amodra;	state Exp;
branches;
next	1.223;

1.223
date	2011.09.16.01.15.19;	author hjl;	state Exp;
branches
	1.223.2.1;
next	1.222;

1.222
date	2011.07.14.12.43.35;	author amodra;	state Exp;
branches;
next	1.221;

1.221
date	2011.07.14.02.38.43;	author amodra;	state Exp;
branches;
next	1.220;

1.220
date	2011.06.20.13.18.48;	author jakub;	state Exp;
branches;
next	1.219;

1.219
date	2011.05.27.12.47.12;	author amodra;	state Exp;
branches;
next	1.218;

1.218
date	2011.02.28.18.34.52;	author ktietz;	state Exp;
branches;
next	1.217;

1.217
date	2011.01.14.02.27.41;	author amodra;	state Exp;
branches;
next	1.216;

1.216
date	2010.12.20.13.00.14;	author amodra;	state Exp;
branches;
next	1.215;

1.215
date	2010.12.06.00.07.06;	author hjl;	state Exp;
branches;
next	1.214;

1.214
date	2010.10.29.12.10.36;	author hjl;	state Exp;
branches
	1.214.2.1;
next	1.213;

1.213
date	2010.08.25.16.57.32;	author hjl;	state Exp;
branches;
next	1.212;

1.212
date	2010.08.22.20.21.21;	author hjl;	state Exp;
branches;
next	1.211;

1.211
date	2010.08.22.19.11.58;	author hjl;	state Exp;
branches;
next	1.210;

1.210
date	2010.08.20.15.01.45;	author nickc;	state Exp;
branches;
next	1.209;

1.209
date	2010.06.25.04.46.05;	author amodra;	state Exp;
branches;
next	1.208;

1.208
date	2010.01.14.04.56.11;	author dj;	state Exp;
branches;
next	1.207;

1.207
date	2009.12.11.13.42.15;	author nickc;	state Exp;
branches;
next	1.206;

1.206
date	2009.11.05.15.35.50;	author nickc;	state Exp;
branches;
next	1.205;

1.205
date	2009.10.23.01.21.12;	author amodra;	state Exp;
branches;
next	1.204;

1.204
date	2009.09.23.13.54.28;	author amodra;	state Exp;
branches;
next	1.203;

1.203
date	2009.09.11.15.27.35;	author nickc;	state Exp;
branches;
next	1.202;

1.202
date	2009.09.05.07.56.25;	author nickc;	state Exp;
branches;
next	1.201;

1.201
date	2009.09.02.07.25.35;	author amodra;	state Exp;
branches
	1.201.2.1;
next	1.200;

1.200
date	2009.08.30.05.47.43;	author amodra;	state Exp;
branches;
next	1.199;

1.199
date	2009.08.26.13.08.07;	author nickc;	state Exp;
branches;
next	1.198;

1.198
date	2009.08.10.07.50.56;	author amodra;	state Exp;
branches;
next	1.197;

1.197
date	2009.05.15.14.22.35;	author amodra;	state Exp;
branches;
next	1.196;

1.196
date	2008.10.21.22.55.04;	author amodra;	state Exp;
branches;
next	1.195;

1.195
date	2008.10.20.12.14.29;	author amodra;	state Exp;
branches;
next	1.194;

1.194
date	2008.10.04.06.08.59;	author amodra;	state Exp;
branches;
next	1.193;

1.193
date	2008.10.03.09.40.49;	author amodra;	state Exp;
branches;
next	1.192;

1.192
date	2008.09.07.04.02.31;	author amodra;	state Exp;
branches
	1.192.2.1;
next	1.191;

1.191
date	2008.08.08.08.06.16;	author amodra;	state Exp;
branches;
next	1.190;

1.190
date	2008.02.15.03.35.53;	author amodra;	state Exp;
branches;
next	1.189;

1.189
date	2008.02.07.08.41.10;	author amodra;	state Exp;
branches;
next	1.188;

1.188
date	2007.09.16.18.55.23;	author hjl;	state Exp;
branches;
next	1.187;

1.187
date	2007.09.15.06.21.06;	author amodra;	state Exp;
branches;
next	1.186;

1.186
date	2007.08.17.13.50.48;	author amodra;	state Exp;
branches;
next	1.185;

1.185
date	2007.08.15.06.03.11;	author amodra;	state Exp;
branches;
next	1.184;

1.184
date	2007.07.29.12.33.38;	author amodra;	state Exp;
branches
	1.184.2.1;
next	1.183;

1.183
date	2007.07.19.19.56.10;	author roland;	state Exp;
branches;
next	1.182;

1.182
date	2007.07.18.09.46.05;	author roland;	state Exp;
branches;
next	1.181;

1.181
date	2007.07.13.10.44.26;	author roland;	state Exp;
branches;
next	1.180;

1.180
date	2007.07.09.21.25.34;	author roland;	state Exp;
branches;
next	1.179;

1.179
date	2007.07.06.14.09.42;	author nickc;	state Exp;
branches;
next	1.178;

1.178
date	2007.04.26.14.46.59;	author amodra;	state Exp;
branches;
next	1.177;

1.177
date	2007.03.28.14.42.28;	author rsandifo;	state Exp;
branches;
next	1.176;

1.176
date	2007.01.19.15.06.27;	author hjl;	state Exp;
branches;
next	1.175;

1.175
date	2006.12.04.08.57.09;	author jbeulich;	state Exp;
branches;
next	1.174;

1.174
date	2006.11.08.11.29.15;	author amodra;	state Exp;
branches;
next	1.173;

1.173
date	2006.11.06.10.39.17;	author vprus;	state Exp;
branches;
next	1.172;

1.172
date	2006.10.27.03.22.09;	author amodra;	state Exp;
branches;
next	1.171;

1.171
date	2006.09.16.18.12.16;	author nickc;	state Exp;
branches;
next	1.170;

1.170
date	2006.09.05.16.26.29;	author hjl;	state Exp;
branches;
next	1.169;

1.169
date	2006.07.10.21.40.24;	author jakub;	state Exp;
branches;
next	1.168;

1.168
date	2006.06.20.02.22.14;	author amodra;	state Exp;
branches;
next	1.167;

1.167
date	2006.06.14.02.43.58;	author amodra;	state Exp;
branches;
next	1.166;

1.166
date	2006.06.03.02.45.26;	author amodra;	state Exp;
branches;
next	1.165;

1.165
date	2006.05.30.16.45.32;	author hjl;	state Exp;
branches;
next	1.164;

1.164
date	2006.04.11.10.36.26;	author nickc;	state Exp;
branches
	1.164.2.1;
next	1.163;

1.163
date	2006.04.05.15.40.40;	author amodra;	state Exp;
branches;
next	1.162;

1.162
date	2006.02.09.01.05.10;	author hjl;	state Exp;
branches
	1.162.2.1;
next	1.161;

1.161
date	2005.12.07.14.43.54;	author hjl;	state Exp;
branches;
next	1.160;

1.160
date	2005.11.24.06.02.08;	author amodra;	state Exp;
branches;
next	1.159;

1.159
date	2005.11.17.00.10.05;	author amodra;	state Exp;
branches;
next	1.158;

1.158
date	2005.10.24.01.40.58;	author hjl;	state Exp;
branches;
next	1.157;

1.157
date	2005.10.15.14.57.54;	author hjl;	state Exp;
branches;
next	1.156;

1.156
date	2005.09.07.05.01.53;	author hjl;	state Exp;
branches;
next	1.155;

1.155
date	2005.08.04.06.22.13;	author amodra;	state Exp;
branches;
next	1.154;

1.154
date	2005.08.04.01.19.09;	author amodra;	state Exp;
branches;
next	1.153;

1.153
date	2005.07.16.03.30.24;	author amodra;	state Exp;
branches;
next	1.152;

1.152
date	2005.07.15.12.19.14;	author amodra;	state Exp;
branches;
next	1.151;

1.151
date	2005.07.14.13.54.23;	author amodra;	state Exp;
branches;
next	1.150;

1.150
date	2005.07.08.06.20.15;	author amodra;	state Exp;
branches;
next	1.149;

1.149
date	2005.07.04.04.04.19;	author amodra;	state Exp;
branches;
next	1.148;

1.148
date	2005.06.09.02.05.47;	author amodra;	state Exp;
branches;
next	1.147;

1.147
date	2005.05.12.07.32.03;	author nickc;	state Exp;
branches;
next	1.146;

1.146
date	2005.05.10.01.07.30;	author hjl;	state Exp;
branches;
next	1.145;

1.145
date	2005.05.07.02.14.21;	author hjl;	state Exp;
branches;
next	1.144;

1.144
date	2005.05.06.15.40.24;	author hjl;	state Exp;
branches;
next	1.143;

1.143
date	2005.05.04.13.19.02;	author hjl;	state Exp;
branches;
next	1.142;

1.142
date	2005.05.04.11.00.28;	author amodra;	state Exp;
branches;
next	1.141;

1.141
date	2005.05.03.01.04.51;	author hjl;	state Exp;
branches;
next	1.140;

1.140
date	2005.04.28.02.41.40;	author hjl;	state Exp;
branches;
next	1.139;

1.139
date	2005.04.11.14.26.46;	author amodra;	state Exp;
branches;
next	1.138;

1.138
date	2005.04.04.11.27.15;	author nickc;	state Exp;
branches;
next	1.137;

1.137
date	2005.03.29.11.07.37;	author amodra;	state Exp;
branches;
next	1.136;

1.136
date	2005.03.23.15.35.50;	author nickc;	state Exp;
branches;
next	1.135;

1.135
date	2005.03.23.04.14.46;	author hjl;	state Exp;
branches;
next	1.134;

1.134
date	2005.03.22.14.49.16;	author amodra;	state Exp;
branches;
next	1.133;

1.133
date	2005.03.18.15.56.27;	author hjl;	state Exp;
branches;
next	1.132;

1.132
date	2005.03.16.21.52.44;	author hjl;	state Exp;
branches;
next	1.131;

1.131
date	2005.02.22.13.00.26;	author amodra;	state Exp;
branches
	1.131.2.1;
next	1.130;

1.130
date	2005.02.16.07.49.26;	author mmitchel;	state Exp;
branches;
next	1.129;

1.129
date	2005.02.16.05.10.02;	author kkojima;	state Exp;
branches;
next	1.128;

1.128
date	2005.02.11.23.52.03;	author zack;	state Exp;
branches;
next	1.127;

1.127
date	2005.02.03.14.12.54;	author amodra;	state Exp;
branches;
next	1.126;

1.126
date	2005.01.25.01.40.04;	author amodra;	state Exp;
branches;
next	1.125;

1.125
date	2004.10.16.18.13.54;	author drow;	state Exp;
branches;
next	1.124;

1.124
date	2004.10.14.12.54.45;	author amodra;	state Exp;
branches;
next	1.123;

1.123
date	2004.10.11.14.42.30;	author jakub;	state Exp;
branches;
next	1.122;

1.122
date	2004.10.11.14.12.11;	author jakub;	state Exp;
branches;
next	1.121;

1.121
date	2004.07.26.07.55.14;	author nickc;	state Exp;
branches;
next	1.120;

1.120
date	2004.07.23.16.32.53;	author nickc;	state Exp;
branches;
next	1.119;

1.119
date	2004.07.19.16.40.52;	author hjl;	state Exp;
branches;
next	1.118;

1.118
date	2004.06.24.04.46.28;	author amodra;	state Exp;
branches;
next	1.117;

1.117
date	2004.05.28.05.42.30;	author amodra;	state Exp;
branches;
next	1.116;

1.116
date	2004.05.27.05.53.36;	author hjl;	state Exp;
branches;
next	1.115;

1.115
date	2004.05.26.10.23.51;	author amodra;	state Exp;
branches;
next	1.114;

1.114
date	2004.05.19.14.01.14;	author jakub;	state Exp;
branches;
next	1.113;

1.113
date	2004.05.11.17.08.35;	author jakub;	state Exp;
branches;
next	1.112;

1.112
date	2004.04.30.14.26.09;	author amodra;	state Exp;
branches;
next	1.111;

1.111
date	2004.03.27.10.58.35;	author amodra;	state Exp;
branches;
next	1.110;

1.110
date	2004.03.25.12.48.45;	author amodra;	state Exp;
branches;
next	1.109;

1.109
date	2004.03.18.12.50.20;	author amodra;	state Exp;
branches;
next	1.108;

1.108
date	2004.01.03.12.39.07;	author amodra;	state Exp;
branches
	1.108.6.1;
next	1.107;

1.107
date	2004.01.03.11.09.07;	author amodra;	state Exp;
branches;
next	1.106;

1.106
date	2003.12.01.06.28.56;	author amodra;	state Exp;
branches;
next	1.105;

1.105
date	2003.11.04.06.16.39;	author amodra;	state Exp;
branches;
next	1.104;

1.104
date	2003.08.20.08.37.15;	author nickc;	state Exp;
branches;
next	1.103;

1.103
date	2003.08.04.11.32.52;	author nickc;	state Exp;
branches;
next	1.102;

1.102
date	2003.08.04.04.01.39;	author amodra;	state Exp;
branches;
next	1.101;

1.101
date	2003.06.27.00.38.25;	author amodra;	state Exp;
branches;
next	1.100;

1.100
date	2003.06.25.06.40.26;	author amodra;	state Exp;
branches;
next	1.99;

1.99
date	2003.06.06.06.28.42;	author roland;	state Exp;
branches;
next	1.98;

1.98
date	2003.06.03.22.27.24;	author jakub;	state Exp;
branches;
next	1.97;

1.97
date	2003.05.30.15.50.12;	author jakub;	state Exp;
branches;
next	1.96;

1.96
date	2003.05.09.02.28.01;	author amodra;	state Exp;
branches;
next	1.95;

1.95
date	2003.02.28.22.55.11;	author amodra;	state Exp;
branches;
next	1.94;

1.94
date	2003.02.28.04.46.04;	author amodra;	state Exp;
branches;
next	1.93;

1.93
date	2003.02.28.01.32.31;	author amodra;	state Exp;
branches;
next	1.92;

1.92
date	2003.02.26.00.56.14;	author aoliva;	state Exp;
branches;
next	1.91;

1.91
date	2003.02.21.10.51.24;	author nickc;	state Exp;
branches;
next	1.90;

1.90
date	2003.02.03.17.47.23;	author drow;	state Exp;
branches;
next	1.89;

1.89
date	2003.01.17.10.36.49;	author aj;	state Exp;
branches;
next	1.88;

1.88
date	2003.01.06.16.14.01;	author drow;	state Exp;
branches;
next	1.87;

1.87
date	2002.12.10.03.34.43;	author amodra;	state Exp;
branches;
next	1.86;

1.86
date	2002.12.04.23.56.14;	author amodra;	state Exp;
branches;
next	1.85;

1.85
date	2002.11.30.08.39.46;	author amodra;	state Exp;
branches;
next	1.84;

1.84
date	2002.10.30.03.57.39;	author drow;	state Exp;
branches;
next	1.83;

1.83
date	2002.10.23.20.13.01;	author jakub;	state Exp;
branches;
next	1.82;

1.82
date	2002.10.10.02.52.27;	author amodra;	state Exp;
branches;
next	1.81;

1.81
date	2002.09.30.03.34.46;	author amodra;	state Exp;
branches;
next	1.80;

1.80
date	2002.07.20.13.41.11;	author amodra;	state Exp;
branches;
next	1.79;

1.79
date	2002.06.17.14.08.38;	author trix;	state Exp;
branches
	1.79.2.1;
next	1.78;

1.78
date	2002.06.13.02.43.23;	author hjl;	state Exp;
branches;
next	1.77;

1.77
date	2002.06.05.14.07.29;	author amodra;	state Exp;
branches;
next	1.76;

1.76
date	2002.05.27.08.22.08;	author rsandifo;	state Exp;
branches;
next	1.75;

1.75
date	2002.05.22.09.02.04;	author amodra;	state Exp;
branches;
next	1.74;

1.74
date	2002.05.22.05.08.31;	author hjl;	state Exp;
branches;
next	1.73;

1.73
date	2002.03.19.21.03.43;	author obrien;	state Exp;
branches;
next	1.72;

1.72
date	2002.02.15.02.11.05;	author amodra;	state Exp;
branches;
next	1.71;

1.71
date	2002.02.05.06.52.17;	author hp;	state Exp;
branches
	1.71.2.1;
next	1.70;

1.70
date	2002.01.05.13.14.00;	author amodra;	state Exp;
branches;
next	1.69;

1.69
date	2001.12.17.00.40.53;	author amodra;	state Exp;
branches;
next	1.68;

1.68
date	2001.12.13.11.09.34;	author jakub;	state Exp;
branches;
next	1.67;

1.67
date	2001.11.20.15.19.39;	author amodra;	state Exp;
branches;
next	1.66;

1.66
date	2001.11.15.12.44.02;	author amodra;	state Exp;
branches;
next	1.65;

1.65
date	2001.11.15.01.34.12;	author drow;	state Exp;
branches;
next	1.64;

1.64
date	2001.10.15.23.28.21;	author amodra;	state Exp;
branches;
next	1.63;

1.63
date	2001.10.12.10.34.25;	author nickc;	state Exp;
branches;
next	1.62;

1.62
date	2001.10.10.23.05.55;	author cgd;	state Exp;
branches;
next	1.61;

1.61
date	2001.10.05.16.36.55;	author jakub;	state Exp;
branches;
next	1.60;

1.60
date	2001.10.03.15.11.48;	author amodra;	state Exp;
branches;
next	1.59;

1.59
date	2001.09.19.05.33.35;	author hjl;	state Exp;
branches;
next	1.58;

1.58
date	2001.08.23.15.14.17;	author jakub;	state Exp;
branches;
next	1.57;

1.57
date	2001.08.14.04.40.38;	author amodra;	state Exp;
branches;
next	1.56;

1.56
date	2001.08.14.02.01.31;	author amodra;	state Exp;
branches;
next	1.55;

1.55
date	2001.08.13.14.28.57;	author amodra;	state Exp;
branches;
next	1.54;

1.54
date	2001.08.13.10.56.21;	author amodra;	state Exp;
branches;
next	1.53;

1.53
date	2001.08.09.14.44.18;	author amodra;	state Exp;
branches;
next	1.52;

1.52
date	2001.07.14.16.36.25;	author hjl;	state Exp;
branches;
next	1.51;

1.51
date	2001.07.13.07.25.18;	author jakub;	state Exp;
branches;
next	1.50;

1.50
date	2001.07.10.00.38.16;	author obrien;	state Exp;
branches;
next	1.49;

1.49
date	2001.06.18.22.20.57;	author hp;	state Exp;
branches;
next	1.48;

1.48
date	2001.05.25.05.39.22;	author hjl;	state Exp;
branches;
next	1.47;

1.47
date	2001.05.24.02.44.06;	author aoliva;	state Exp;
branches;
next	1.46;

1.46
date	2001.05.22.14.00.18;	author nickc;	state Exp;
branches;
next	1.45;

1.45
date	2001.05.03.06.26.26;	author hjl;	state Exp;
branches;
next	1.44;

1.44
date	2001.03.20.18.39.21;	author drepper;	state Exp;
branches;
next	1.43;

1.43
date	2001.03.17.21.24.26;	author drepper;	state Exp;
branches;
next	1.42;

1.42
date	2001.03.13.06.14.27;	author nickc;	state Exp;
branches;
next	1.41;

1.41
date	2001.01.24.06.14.09;	author hp;	state Exp;
branches
	1.41.2.1;
next	1.40;

1.40
date	2001.01.14.04.36.35;	author amodra;	state Exp;
branches;
next	1.39;

1.39
date	2001.01.08.05.25.58;	author obrien;	state Exp;
branches;
next	1.38;

1.38
date	2000.12.12.19.37.01;	author nickc;	state Exp;
branches;
next	1.37;

1.37
date	2000.11.08.00.39.32;	author wilson;	state Exp;
branches;
next	1.36;

1.36
date	2000.09.20.04.20.26;	author amodra;	state Exp;
branches;
next	1.35;

1.35
date	2000.09.07.09.09.19;	author amodra;	state Exp;
branches;
next	1.34;

1.34
date	2000.09.07.07.08.58;	author amodra;	state Exp;
branches;
next	1.33;

1.33
date	2000.09.06.15.28.25;	author amodra;	state Exp;
branches;
next	1.32;

1.32
date	2000.09.05.03.05.19;	author amodra;	state Exp;
branches;
next	1.31;

1.31
date	2000.08.25.20.24.11;	author hjl;	state Exp;
branches;
next	1.30;

1.30
date	2000.08.23.23.03.00;	author hjl;	state Exp;
branches;
next	1.29;

1.29
date	2000.08.22.19.34.37;	author hjl;	state Exp;
branches;
next	1.28;

1.28
date	2000.08.09.00.51.42;	author nickc;	state Exp;
branches;
next	1.27;

1.27
date	2000.08.04.04.41.33;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2000.07.28.01.33.14;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2000.07.28.01.07.09;	author amodra;	state Exp;
branches;
next	1.24;

1.24
date	2000.07.20.21.59.40;	author hjl;	state Exp;
branches;
next	1.23;

1.23
date	2000.07.20.21.18.23;	author hjl;	state Exp;
branches;
next	1.22;

1.22
date	2000.07.20.16.13.26;	author hjl;	state Exp;
branches;
next	1.21;

1.21
date	2000.07.20.03.25.10;	author hjl;	state Exp;
branches;
next	1.20;

1.20
date	2000.07.20.03.17.32;	author hjl;	state Exp;
branches;
next	1.19;

1.19
date	2000.07.11.03.42.41;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2000.06.19.01.22.43;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2000.04.25.05.14.16;	author amodra;	state Exp;
branches;
next	1.16;

1.16
date	2000.04.18.23.39.03;	author hjl;	state Exp;
branches;
next	1.15;

1.15
date	2000.04.18.05.53.41;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2000.04.14.01.58.29;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2000.04.12.02.43.37;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2000.02.29.05.53.53;	author amodra;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2000.02.16.18.53.32;	author twall;	state Exp;
branches;
next	1.10;

1.10
date	99.11.04.06.45.07;	author law;	state Exp;
branches;
next	1.9;

1.9
date	99.09.17.21.58.45;	author law;	state Exp;
branches;
next	1.8;

1.8
date	99.09.16.20.53.09;	author law;	state Exp;
branches;
next	1.7;

1.7
date	99.09.14.02.42.51;	author law;	state Exp;
branches;
next	1.6;

1.6
date	99.08.23.09.07.45;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	99.08.06.22.46.03;	author ian;	state Exp;
branches;
next	1.4;

1.4
date	99.07.12.06.21.12;	author schwab;	state Exp;
branches;
next	1.3;

1.3
date	99.07.11.20.09.04;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.06.20.14.12.07;	author rth;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.29.07;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.246.2.1
date	2013.10.09.18.18.49;	author roland;	state Exp;
branches;
next	;

1.229.2.1
date	2012.11.29.22.56.29;	author roland;	state Exp;
branches;
next	1.229.2.2;

1.229.2.2
date	2013.01.21.13.48.49;	author amodra;	state Exp;
branches;
next	;

1.223.2.1
date	2011.10.25.03.12.18;	author amodra;	state Exp;
branches;
next	;

1.214.2.1
date	2011.02.01.12.25.47;	author amodra;	state Exp;
branches;
next	1.214.2.2;

1.214.2.2
date	2011.05.29.04.51.49;	author amodra;	state Exp;
branches;
next	;

1.201.2.1
date	2009.09.05.08.00.21;	author nickc;	state Exp;
branches;
next	1.201.2.2;

1.201.2.2
date	2009.09.11.15.28.44;	author nickc;	state Exp;
branches;
next	;

1.192.2.1
date	2009.03.02.13.32.55;	author amodra;	state Exp;
branches;
next	1.192.2.2;

1.192.2.2
date	2009.03.02.13.34.03;	author amodra;	state Exp;
branches;
next	;

1.184.2.1
date	2007.08.15.06.06.01;	author amodra;	state Exp;
branches;
next	;

1.164.2.1
date	2006.06.08.00.24.02;	author amodra;	state Exp;
branches;
next	;

1.162.2.1
date	2006.08.22.15.08.43;	author jsm28;	state Exp;
branches;
next	1.162.2.2;

1.162.2.2
date	2006.11.04.10.20.53;	author vprus;	state Exp;
branches;
next	1.162.2.3;

1.162.2.3
date	2006.11.29.16.31.09;	author shinwell;	state Exp;
branches;
next	;

1.131.2.1
date	2005.03.22.14.49.54;	author amodra;	state Exp;
branches
	1.131.2.1.2.1;
next	1.131.2.2;

1.131.2.2
date	2005.04.12.12.22.11;	author amodra;	state Exp;
branches;
next	;

1.131.2.1.2.1
date	2005.04.13.14.58.17;	author pbrook;	state Exp;
branches;
next	;

1.108.6.1
date	2004.04.08.12.41.54;	author amodra;	state Exp;
branches;
next	;

1.79.2.1
date	2002.07.20.13.45.41;	author amodra;	state Exp;
branches;
next	1.79.2.2;

1.79.2.2
date	2002.10.28.18.45.53;	author drow;	state Exp;
branches;
next	1.79.2.3;

1.79.2.3
date	2002.10.30.03.54.53;	author drow;	state Exp;
branches;
next	1.79.2.4;

1.79.2.4
date	2002.12.15.22.31.49;	author drow;	state Exp;
branches;
next	;

1.71.2.1
date	2002.03.19.21.27.41;	author obrien;	state Exp;
branches;
next	;

1.41.2.1
date	2001.03.20.22.59.10;	author pb;	state Exp;
branches;
next	1.41.2.2;

1.41.2.2
date	2001.05.23.03.41.11;	author amodra;	state Exp;
branches;
next	1.41.2.3;

1.41.2.3
date	2001.07.20.02.22.18;	author obrien;	state Exp;
branches;
next	;

1.12.2.1
date	2000.10.12.13.56.39;	author obrien;	state Exp;
branches;
next	1.12.2.2;

1.12.2.2
date	2000.11.06.09.37.30;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.29.07;	author rth;	state Exp;
branches;
next	;


desc
@@


1.247
log
@ld/
	* emultempl/elf32.em (id_note_section_size): Use ATTRIBUTE_UNUSED
	rather than a dummy assignment for unused parameter.
	* plugin.c (get_input_file, release_input_file): Likewise.
@
text
@# This shell script emits a C file. -*- C -*-
# It does some substitutions.
# This file is now misnamed, because it supports both 32 bit and 64 bit
# ELF emulations.
test -z "${ELFSIZE}" && ELFSIZE=32
if [ -z "$MACHINE" ]; then
  OUTPUT_ARCH=${ARCH}
else
  OUTPUT_ARCH=${ARCH}:${MACHINE}
fi
fragment <<EOF
/* This file is is generated by a shell script.  DO NOT EDIT! */

/* ${ELFSIZE} bit ELF emulation code for ${EMULATION_NAME}
   Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001,
   2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013
   Free Software Foundation, Inc.
   Written by Steve Chamberlain <sac@@cygnus.com>
   ELF support by Ian Lance Taylor <ian@@cygnus.com>

   This file is part of the GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#define TARGET_IS_${EMULATION_NAME}

#include "sysdep.h"
#include "bfd.h"
#include "libiberty.h"
#include "filenames.h"
#include "safe-ctype.h"
#include "getopt.h"
#include "md5.h"
#include "sha1.h"
#include <fcntl.h>

#include "bfdlink.h"

#include "ld.h"
#include "ldmain.h"
#include "ldmisc.h"
#include "ldexp.h"
#include "ldlang.h"
#include "ldfile.h"
#include "ldemul.h"
#include <ldgram.h>
#include "elf/common.h"
#include "elf-bfd.h"
#include "filenames.h"

/* Declare functions used by various EXTRA_EM_FILEs.  */
static void gld${EMULATION_NAME}_before_parse (void);
static void gld${EMULATION_NAME}_after_open (void);
static void gld${EMULATION_NAME}_before_allocation (void);
static void gld${EMULATION_NAME}_after_allocation (void);
static lang_output_section_statement_type *gld${EMULATION_NAME}_place_orphan
  (asection *, const char *, int);
EOF

if [ "x${USE_LIBPATH}" = xyes ] ; then
  case ${target} in
    *-*-linux-* | *-*-k*bsd*-* | *-*-gnu*)
  fragment <<EOF
#ifdef HAVE_GLOB
#include <glob.h>
#endif
EOF
    ;;
  esac
fi

# Import any needed special functions and/or overrides.
#
source_em ${srcdir}/emultempl/elf-generic.em
if test -n "$EXTRA_EM_FILE" ; then
  source_em ${srcdir}/emultempl/${EXTRA_EM_FILE}.em
fi

# Functions in this file can be overridden by setting the LDEMUL_* shell
# variables.  If the name of the overriding function is the same as is
# defined in this file, then don't output this file's version.
# If a different overriding name is given then output the standard function
# as presumably it is called from the overriding function.
#
if test x"$LDEMUL_BEFORE_PARSE" != xgld"$EMULATION_NAME"_before_parse; then
fragment <<EOF

static void
gld${EMULATION_NAME}_before_parse (void)
{
  ldfile_set_output_arch ("${OUTPUT_ARCH}", bfd_arch_`echo ${ARCH} | sed -e 's/:.*//'`);
  input_flags.dynamic = ${DYNAMIC_LINK-TRUE};
  config.has_shared = `if test -n "$GENERATE_SHLIB_SCRIPT" ; then echo TRUE ; else echo FALSE ; fi`;
  config.separate_code = `if test "x${SEPARATE_CODE}" = xyes ; then echo TRUE ; else echo FALSE ; fi`;
}

EOF
fi

if test x"$LDEMUL_RECOGNIZED_FILE" != xgld"${EMULATION_NAME}"_load_symbols; then
fragment <<EOF
/* Handle the generation of DT_NEEDED tags.  */

static bfd_boolean
gld${EMULATION_NAME}_load_symbols (lang_input_statement_type *entry)
{
  int link_class = 0;

  /* Tell the ELF linker that we don't want the output file to have a
     DT_NEEDED entry for this file, unless it is used to resolve
     references in a regular object.  */
  if (entry->flags.add_DT_NEEDED_for_regular)
    link_class = DYN_AS_NEEDED;

  /* Tell the ELF linker that we don't want the output file to have a
     DT_NEEDED entry for any dynamic library in DT_NEEDED tags from
     this file at all.  */
  if (!entry->flags.add_DT_NEEDED_for_dynamic)
    link_class |= DYN_NO_ADD_NEEDED;

  if (entry->flags.just_syms
      && (bfd_get_file_flags (entry->the_bfd) & DYNAMIC) != 0)
    einfo (_("%P%F: --just-symbols may not be used on DSO: %B\n"),
	   entry->the_bfd);

  if (link_class == 0
      || (bfd_get_file_flags (entry->the_bfd) & DYNAMIC) == 0)
    return FALSE;

  bfd_elf_set_dyn_lib_class (entry->the_bfd,
			     (enum dynamic_lib_link_class) link_class);

  /* Continue on with normal load_symbols processing.  */
  return FALSE;
}
EOF
fi

fragment <<EOF

/* These variables are required to pass information back and forth
   between after_open and check_needed and stat_needed and vercheck.  */

static struct bfd_link_needed_list *global_needed;
static struct stat global_stat;
static lang_input_statement_type *global_found;
static struct bfd_link_needed_list *global_vercheck_needed;
static bfd_boolean global_vercheck_failed;

/* These variables are used to implement target options */

static char *audit; /* colon (typically) separated list of libs */
static char *depaudit; /* colon (typically) separated list of libs */

/* Style of .note.gnu.build-id section.  */
static const char *emit_note_gnu_build_id;

/* On Linux, it's possible to have different versions of the same
   shared library linked against different versions of libc.  The
   dynamic linker somehow tags which libc version to use in
   /etc/ld.so.cache, and, based on the libc that it sees in the
   executable, chooses which version of the shared library to use.

   We try to do a similar check here by checking whether this shared
   library needs any other shared libraries which may conflict with
   libraries we have already included in the link.  If it does, we
   skip it, and try to find another shared library farther on down the
   link path.

   This is called via lang_for_each_input_file.
   GLOBAL_VERCHECK_NEEDED is the list of objects needed by the object
   which we are checking.  This sets GLOBAL_VERCHECK_FAILED if we find
   a conflicting version.  */

static void
gld${EMULATION_NAME}_vercheck (lang_input_statement_type *s)
{
  const char *soname;
  struct bfd_link_needed_list *l;

  if (global_vercheck_failed)
    return;
  if (s->the_bfd == NULL
      || (bfd_get_file_flags (s->the_bfd) & DYNAMIC) == 0)
    return;

  soname = bfd_elf_get_dt_soname (s->the_bfd);
  if (soname == NULL)
    soname = lbasename (bfd_get_filename (s->the_bfd));

  for (l = global_vercheck_needed; l != NULL; l = l->next)
    {
      const char *suffix;

      if (filename_cmp (soname, l->name) == 0)
	{
	  /* Probably can't happen, but it's an easy check.  */
	  continue;
	}

      if (strchr (l->name, '/') != NULL)
	continue;

      suffix = strstr (l->name, ".so.");
      if (suffix == NULL)
	continue;

      suffix += sizeof ".so." - 1;

      if (filename_ncmp (soname, l->name, suffix - l->name) == 0)
	{
	  /* Here we know that S is a dynamic object FOO.SO.VER1, and
	     the object we are considering needs a dynamic object
	     FOO.SO.VER2, and VER1 and VER2 are different.  This
	     appears to be a version mismatch, so we tell the caller
	     to try a different version of this library.  */
	  global_vercheck_failed = TRUE;
	  return;
	}
    }
}


/* See if an input file matches a DT_NEEDED entry by running stat on
   the file.  */

static void
gld${EMULATION_NAME}_stat_needed (lang_input_statement_type *s)
{
  struct stat st;
  const char *suffix;
  const char *soname;

  if (global_found != NULL)
    return;
  if (s->the_bfd == NULL)
    return;

  /* If this input file was an as-needed entry, and wasn't found to be
     needed at the stage it was linked, then don't say we have loaded it.  */
  if ((bfd_elf_get_dyn_lib_class (s->the_bfd) & DYN_AS_NEEDED) != 0)
    return;

  if (bfd_stat (s->the_bfd, &st) != 0)
    {
      einfo ("%P:%B: bfd_stat failed: %E\n", s->the_bfd);
      return;
    }

  /* Some operating systems, e.g. Windows, do not provide a meaningful
     st_ino; they always set it to zero.  (Windows does provide a
     meaningful st_dev.)  Do not indicate a duplicate library in that
     case.  While there is no guarantee that a system that provides
     meaningful inode numbers will never set st_ino to zero, this is
     merely an optimization, so we do not need to worry about false
     negatives.  */
  if (st.st_dev == global_stat.st_dev
      && st.st_ino == global_stat.st_ino
      && st.st_ino != 0)
    {
      global_found = s;
      return;
    }

  /* We issue a warning if it looks like we are including two
     different versions of the same shared library.  For example,
     there may be a problem if -lc picks up libc.so.6 but some other
     shared library has a DT_NEEDED entry of libc.so.5.  This is a
     heuristic test, and it will only work if the name looks like
     NAME.so.VERSION.  FIXME: Depending on file names is error-prone.
     If we really want to issue warnings about mixing version numbers
     of shared libraries, we need to find a better way.  */

  if (strchr (global_needed->name, '/') != NULL)
    return;
  suffix = strstr (global_needed->name, ".so.");
  if (suffix == NULL)
    return;
  suffix += sizeof ".so." - 1;

  soname = bfd_elf_get_dt_soname (s->the_bfd);
  if (soname == NULL)
    soname = lbasename (s->filename);

  if (filename_ncmp (soname, global_needed->name, suffix - global_needed->name) == 0)
    einfo ("%P: warning: %s, needed by %B, may conflict with %s\n",
	   global_needed->name, global_needed->by, soname);
}

struct dt_needed
{
  bfd *by;
  const char *name;
};

/* This function is called for each possible name for a dynamic object
   named by a DT_NEEDED entry.  The FORCE parameter indicates whether
   to skip the check for a conflicting version.  */

static bfd_boolean
gld${EMULATION_NAME}_try_needed (struct dt_needed *needed,
				 int force)
{
  bfd *abfd;
  const char *name = needed->name;
  const char *soname;
  int link_class;

  abfd = bfd_openr (name, bfd_get_target (link_info.output_bfd));
  if (abfd == NULL)
    return FALSE;

  /* Linker needs to decompress sections.  */
  abfd->flags |= BFD_DECOMPRESS;

  if (! bfd_check_format (abfd, bfd_object))
    {
      bfd_close (abfd);
      return FALSE;
    }
  if ((bfd_get_file_flags (abfd) & DYNAMIC) == 0)
    {
      bfd_close (abfd);
      return FALSE;
    }

  /* For DT_NEEDED, they have to match.  */
  if (abfd->xvec != link_info.output_bfd->xvec)
    {
      bfd_close (abfd);
      return FALSE;
    }

  /* Check whether this object would include any conflicting library
     versions.  If FORCE is set, then we skip this check; we use this
     the second time around, if we couldn't find any compatible
     instance of the shared library.  */

  if (! force)
    {
      struct bfd_link_needed_list *needs;

      if (! bfd_elf_get_bfd_needed_list (abfd, &needs))
	einfo ("%F%P:%B: bfd_elf_get_bfd_needed_list failed: %E\n", abfd);

      if (needs != NULL)
	{
	  global_vercheck_needed = needs;
	  global_vercheck_failed = FALSE;
	  lang_for_each_input_file (gld${EMULATION_NAME}_vercheck);
	  if (global_vercheck_failed)
	    {
	      bfd_close (abfd);
	      /* Return FALSE to force the caller to move on to try
		 another file on the search path.  */
	      return FALSE;
	    }

	  /* But wait!  It gets much worse.  On Linux, if a shared
	     library does not use libc at all, we are supposed to skip
	     it the first time around in case we encounter a shared
	     library later on with the same name which does use the
	     version of libc that we want.  This is much too horrible
	     to use on any system other than Linux.  */

EOF
case ${target} in
  *-*-linux-* | *-*-k*bsd*-* | *-*-gnu*)
    fragment <<EOF
	  {
	    struct bfd_link_needed_list *l;

	    for (l = needs; l != NULL; l = l->next)
	      if (CONST_STRNEQ (l->name, "libc.so"))
		break;
	    if (l == NULL)
	      {
		bfd_close (abfd);
		return FALSE;
	      }
	  }

EOF
    ;;
esac
fragment <<EOF
	}
    }

  /* We've found a dynamic object matching the DT_NEEDED entry.  */

  /* We have already checked that there is no other input file of the
     same name.  We must now check again that we are not including the
     same file twice.  We need to do this because on many systems
     libc.so is a symlink to, e.g., libc.so.1.  The SONAME entry will
     reference libc.so.1.  If we have already included libc.so, we
     don't want to include libc.so.1 if they are the same file, and we
     can only check that using stat.  */

  if (bfd_stat (abfd, &global_stat) != 0)
    einfo ("%F%P:%B: bfd_stat failed: %E\n", abfd);

  /* First strip off everything before the last '/'.  */
  soname = lbasename (abfd->filename);

  if (verbose)
    info_msg (_("found %s at %s\n"), soname, name);

  global_found = NULL;
  lang_for_each_input_file (gld${EMULATION_NAME}_stat_needed);
  if (global_found != NULL)
    {
      /* Return TRUE to indicate that we found the file, even though
	 we aren't going to do anything with it.  */
      return TRUE;
    }

  /* Specify the soname to use.  */
  bfd_elf_set_dt_needed_name (abfd, soname);

  /* Tell the ELF linker that we don't want the output file to have a
     DT_NEEDED entry for this file, unless it is used to resolve
     references in a regular object.  */
  link_class = DYN_DT_NEEDED;

  /* Tell the ELF linker that we don't want the output file to have a
     DT_NEEDED entry for this file at all if the entry is from a file
     with DYN_NO_ADD_NEEDED.  */
  if (needed->by != NULL
      && (bfd_elf_get_dyn_lib_class (needed->by) & DYN_NO_ADD_NEEDED) != 0)
    link_class |= DYN_NO_NEEDED | DYN_NO_ADD_NEEDED;

  bfd_elf_set_dyn_lib_class (abfd, (enum dynamic_lib_link_class) link_class);

  /* Add this file into the symbol table.  */
  if (! bfd_link_add_symbols (abfd, &link_info))
    einfo ("%F%B: error adding symbols: %E\n", abfd);

  return TRUE;
}


/* Search for a needed file in a path.  */

static bfd_boolean
gld${EMULATION_NAME}_search_needed (const char *path,
				    struct dt_needed *n, int force)
{
  const char *s;
  const char *name = n->name;
  size_t len;
  struct dt_needed needed;

  if (name[0] == '/')
    return gld${EMULATION_NAME}_try_needed (n, force);

  if (path == NULL || *path == '\0')
    return FALSE;

  needed.by = n->by;
  needed.name = n->name;

  len = strlen (name);
  while (1)
    {
      char *filename, *sset;

      s = strchr (path, config.rpath_separator);
      if (s == NULL)
	s = path + strlen (path);

#if HAVE_DOS_BASED_FILE_SYSTEM
      /* Assume a match on the second char is part of drive specifier.  */
      else if (config.rpath_separator == ':'
	       && s == path + 1
	       && ISALPHA (*path))
	{
	  s = strchr (s + 1, config.rpath_separator);
	  if (s == NULL)
	    s = path + strlen (path);
	}
#endif
      filename = (char *) xmalloc (s - path + len + 2);
      if (s == path)
	sset = filename;
      else
	{
	  memcpy (filename, path, s - path);
	  filename[s - path] = '/';
	  sset = filename + (s - path) + 1;
	}
      strcpy (sset, name);

      needed.name = filename;
      if (gld${EMULATION_NAME}_try_needed (&needed, force))
	return TRUE;

      free (filename);

      if (*s == '\0')
	break;
      path = s + 1;
    }

  return FALSE;
}

EOF
if [ "x${USE_LIBPATH}" = xyes ] ; then
  fragment <<EOF

/* Add the sysroot to every entry in a path separated by
   config.rpath_separator.  */

static char *
gld${EMULATION_NAME}_add_sysroot (const char *path)
{
  int len, colons, i;
  char *ret, *p;

  len = strlen (path);
  colons = 0;
  i = 0;
  while (path[i])
    if (path[i++] == config.rpath_separator)
      colons++;

  if (path[i])
    colons++;

  len = len + (colons + 1) * strlen (ld_sysroot);
  ret = xmalloc (len + 1);
  strcpy (ret, ld_sysroot);
  p = ret + strlen (ret);
  i = 0;
  while (path[i])
    if (path[i] == config.rpath_separator)
      {
	*p++ = path[i++];
	strcpy (p, ld_sysroot);
	p = p + strlen (p);
      }
    else
      *p++ = path[i++];

  *p = 0;
  return ret;
}

EOF
  case ${target} in
    *-*-freebsd* | *-*-dragonfly*)
      fragment <<EOF
/* Read the system search path the FreeBSD way rather than the Linux way.  */
#ifdef HAVE_ELF_HINTS_H
#include <elf-hints.h>
#else
#include "elf-hints-local.h"
#endif

static bfd_boolean
gld${EMULATION_NAME}_check_ld_elf_hints (const struct bfd_link_needed_list *l,
					 int force)
{
  static bfd_boolean initialized;
  static char *ld_elf_hints;
  struct dt_needed needed;

  if (!initialized)
    {
      FILE *f;
      char *tmppath;

      tmppath = concat (ld_sysroot, _PATH_ELF_HINTS, (const char *) NULL);
      f = fopen (tmppath, FOPEN_RB);
      free (tmppath);
      if (f != NULL)
	{
	  struct elfhints_hdr hdr;

	  if (fread (&hdr, 1, sizeof (hdr), f) == sizeof (hdr)
	      && hdr.magic == ELFHINTS_MAGIC
	      && hdr.version == 1)
	    {
	      if (fseek (f, hdr.strtab + hdr.dirlist, SEEK_SET) != -1)
		{
		  char *b;

		  b = xmalloc (hdr.dirlistlen + 1);
		  if (fread (b, 1, hdr.dirlistlen + 1, f) ==
		      hdr.dirlistlen + 1)
		    ld_elf_hints = gld${EMULATION_NAME}_add_sysroot (b);

		  free (b);
		}
	    }
	  fclose (f);
	}

      initialized = TRUE;
    }

  if (ld_elf_hints == NULL)
    return FALSE;

  needed.by = l->by;
  needed.name = l->name;
  return gld${EMULATION_NAME}_search_needed (ld_elf_hints, &needed, force);
}
EOF
    # FreeBSD
    ;;

    *-*-linux-* | *-*-k*bsd*-* | *-*-gnu*)
      fragment <<EOF
/* For a native linker, check the file /etc/ld.so.conf for directories
   in which we may find shared libraries.  /etc/ld.so.conf is really
   only meaningful on Linux.  */

struct gld${EMULATION_NAME}_ld_so_conf
{
  char *path;
  size_t len, alloc;
};

static bfd_boolean
gld${EMULATION_NAME}_parse_ld_so_conf
     (struct gld${EMULATION_NAME}_ld_so_conf *info, const char *filename);

static void
gld${EMULATION_NAME}_parse_ld_so_conf_include
     (struct gld${EMULATION_NAME}_ld_so_conf *info, const char *filename,
      const char *pattern)
{
  char *newp = NULL;
#ifdef HAVE_GLOB
  glob_t gl;
#endif

  if (pattern[0] != '/')
    {
      char *p = strrchr (filename, '/');
      size_t patlen = strlen (pattern) + 1;

      newp = xmalloc (p - filename + 1 + patlen);
      memcpy (newp, filename, p - filename + 1);
      memcpy (newp + (p - filename + 1), pattern, patlen);
      pattern = newp;
    }

#ifdef HAVE_GLOB
  if (glob (pattern, 0, NULL, &gl) == 0)
    {
      size_t i;

      for (i = 0; i < gl.gl_pathc; ++i)
	gld${EMULATION_NAME}_parse_ld_so_conf (info, gl.gl_pathv[i]);
      globfree (&gl);
    }
#else
  /* If we do not have glob, treat the pattern as a literal filename.  */
  gld${EMULATION_NAME}_parse_ld_so_conf (info, pattern);
#endif

  if (newp)
    free (newp);
}

static bfd_boolean
gld${EMULATION_NAME}_parse_ld_so_conf
     (struct gld${EMULATION_NAME}_ld_so_conf *info, const char *filename)
{
  FILE *f = fopen (filename, FOPEN_RT);
  char *line;
  size_t linelen;

  if (f == NULL)
    return FALSE;

  linelen = 256;
  line = xmalloc (linelen);
  do
    {
      char *p = line, *q;

      /* Normally this would use getline(3), but we need to be portable.  */
      while ((q = fgets (p, linelen - (p - line), f)) != NULL
	     && strlen (q) == linelen - (p - line) - 1
	     && line[linelen - 2] != '\n')
	{
	  line = xrealloc (line, 2 * linelen);
	  p = line + linelen - 1;
	  linelen += linelen;
	}

      if (q == NULL && p == line)
	break;

      p = strchr (line, '\n');
      if (p)
	*p = '\0';

      /* Because the file format does not know any form of quoting we
	 can search forward for the next '#' character and if found
	 make it terminating the line.  */
      p = strchr (line, '#');
      if (p)
	*p = '\0';

      /* Remove leading whitespace.  NUL is no whitespace character.  */
      p = line;
      while (*p == ' ' || *p == '\f' || *p == '\r' || *p == '\t' || *p == '\v')
	++p;

      /* If the line is blank it is ignored.  */
      if (p[0] == '\0')
	continue;

      if (CONST_STRNEQ (p, "include") && (p[7] == ' ' || p[7] == '\t'))
	{
	  char *dir, c;
	  p += 8;
	  do
	    {
	      while (*p == ' ' || *p == '\t')
		++p;

	      if (*p == '\0')
		break;

	      dir = p;

	      while (*p != ' ' && *p != '\t' && *p)
		++p;

	      c = *p;
	      *p++ = '\0';
	      if (dir[0] != '\0')
		gld${EMULATION_NAME}_parse_ld_so_conf_include (info, filename,
							       dir);
	    }
	  while (c != '\0');
	}
      else
	{
	  char *dir = p;
	  while (*p && *p != '=' && *p != ' ' && *p != '\t' && *p != '\f'
		 && *p != '\r' && *p != '\v')
	    ++p;

	  while (p != dir && p[-1] == '/')
	    --p;
	  if (info->path == NULL)
	    {
	      info->alloc = p - dir + 1 + 256;
	      info->path = xmalloc (info->alloc);
	      info->len = 0;
	    }
	  else
	    {
	      if (info->len + 1 + (p - dir) >= info->alloc)
		{
		  info->alloc += p - dir + 256;
		  info->path = xrealloc (info->path, info->alloc);
		}
	      info->path[info->len++] = config.rpath_separator;
	    }
	  memcpy (info->path + info->len, dir, p - dir);
	  info->len += p - dir;
	  info->path[info->len] = '\0';
	}
    }
  while (! feof (f));
  free (line);
  fclose (f);
  return TRUE;
}

static bfd_boolean
gld${EMULATION_NAME}_check_ld_so_conf (const struct bfd_link_needed_list *l,
				       int force)
{
  static bfd_boolean initialized;
  static char *ld_so_conf;
  struct dt_needed needed;

  if (! initialized)
    {
      char *tmppath;
      struct gld${EMULATION_NAME}_ld_so_conf info;

      info.path = NULL;
      info.len = info.alloc = 0;
      tmppath = concat (ld_sysroot, "${prefix}/etc/ld.so.conf",
			(const char *) NULL);
      if (!gld${EMULATION_NAME}_parse_ld_so_conf (&info, tmppath))
	{
	  free (tmppath);
	  tmppath = concat (ld_sysroot, "/etc/ld.so.conf",
			    (const char *) NULL);
	  gld${EMULATION_NAME}_parse_ld_so_conf (&info, tmppath);
	}
      free (tmppath);

      if (info.path)
	{
	  char *d = gld${EMULATION_NAME}_add_sysroot (info.path);
	  free (info.path);
	  ld_so_conf = d;
	}
      initialized = TRUE;
    }

  if (ld_so_conf == NULL)
    return FALSE;


  needed.by = l->by;
  needed.name = l->name;
  return gld${EMULATION_NAME}_search_needed (ld_so_conf, &needed, force);
}

EOF
    # Linux
    ;;
  esac
fi
fragment <<EOF

/* See if an input file matches a DT_NEEDED entry by name.  */

static void
gld${EMULATION_NAME}_check_needed (lang_input_statement_type *s)
{
  const char *soname;

  /* Stop looking if we've found a loaded lib.  */
  if (global_found != NULL
      && (bfd_elf_get_dyn_lib_class (global_found->the_bfd)
	  & DYN_AS_NEEDED) == 0)
    return;

  if (s->filename == NULL || s->the_bfd == NULL)
    return;

  /* Don't look for a second non-loaded as-needed lib.  */
  if (global_found != NULL
      && (bfd_elf_get_dyn_lib_class (s->the_bfd) & DYN_AS_NEEDED) != 0)
    return;

  if (filename_cmp (s->filename, global_needed->name) == 0)
    {
      global_found = s;
      return;
    }

  if (s->flags.search_dirs)
    {
      const char *f = strrchr (s->filename, '/');
      if (f != NULL
	  && filename_cmp (f + 1, global_needed->name) == 0)
	{
	  global_found = s;
	  return;
	}
    }

  soname = bfd_elf_get_dt_soname (s->the_bfd);
  if (soname != NULL
      && filename_cmp (soname, global_needed->name) == 0)
    {
      global_found = s;
      return;
    }
}

EOF

if test x"$LDEMUL_AFTER_OPEN" != xgld"$EMULATION_NAME"_after_open; then
fragment <<EOF

static bfd_size_type
id_note_section_size (bfd *abfd ATTRIBUTE_UNUSED)
{
  const char *style = emit_note_gnu_build_id;
  bfd_size_type size;

  size = offsetof (Elf_External_Note, name[sizeof "GNU"]);
  size = (size + 3) & -(bfd_size_type) 4;

  if (!strcmp (style, "md5") || !strcmp (style, "uuid"))
    size += 128 / 8;
  else if (!strcmp (style, "sha1"))
    size += 160 / 8;
  else if (!strncmp (style, "0x", 2))
    {
      /* ID is in string form (hex).  Convert to bits.  */
      const char *id = style + 2;
      do
	{
	  if (ISXDIGIT (id[0]) && ISXDIGIT (id[1]))
	    {
	      ++size;
	      id += 2;
	    }
	  else if (*id == '-' || *id == ':')
	    ++id;
	  else
	    {
	      size = 0;
	      break;
	    }
	} while (*id != '\0');
    }
  else
    size = 0;

  return size;
}

static unsigned char
read_hex (const char xdigit)
{
  if (ISDIGIT (xdigit))
    return xdigit - '0';
  if (ISUPPER (xdigit))
    return xdigit - 'A' + 0xa;
  if (ISLOWER (xdigit))
    return xdigit - 'a' + 0xa;
  abort ();
  return 0;
}

static bfd_boolean
write_build_id (bfd *abfd)
{
  const struct elf_backend_data *bed = get_elf_backend_data (abfd);
  struct elf_obj_tdata *t = elf_tdata (abfd);
  const char *style;
  asection *asec;
  Elf_Internal_Shdr *i_shdr;
  unsigned char *contents, *id_bits;
  bfd_size_type size;
  file_ptr position;
  Elf_External_Note *e_note;
  typedef void (*sum_fn) (const void *, size_t, void *);

  style = t->o->build_id.style;
  asec = t->o->build_id.sec;
  if (bfd_is_abs_section (asec->output_section))
    {
      einfo (_("%P: warning: .note.gnu.build-id section discarded,"
	       " --build-id ignored.\n"));
      return TRUE;
    }
  i_shdr = &elf_section_data (asec->output_section)->this_hdr;

  if (i_shdr->contents == NULL)
    {
      if (asec->contents == NULL)
	asec->contents = (unsigned char *) xmalloc (asec->size);
      contents = asec->contents;
    }
  else
    contents = i_shdr->contents + asec->output_offset;

  e_note = (Elf_External_Note *) contents;
  size = offsetof (Elf_External_Note, name[sizeof "GNU"]);
  size = (size + 3) & -(bfd_size_type) 4;
  id_bits = contents + size;
  size = asec->size - size;

  bfd_h_put_32 (abfd, sizeof "GNU", &e_note->namesz);
  bfd_h_put_32 (abfd, size, &e_note->descsz);
  bfd_h_put_32 (abfd, NT_GNU_BUILD_ID, &e_note->type);
  memcpy (e_note->name, "GNU", sizeof "GNU");

  if (strcmp (style, "md5") == 0)
    {
      struct md5_ctx ctx;

      md5_init_ctx (&ctx);
      if (!bed->s->checksum_contents (abfd, (sum_fn) &md5_process_bytes, &ctx))
	return FALSE;
      md5_finish_ctx (&ctx, id_bits);
    }
  else if (strcmp (style, "sha1") == 0)
    {
      struct sha1_ctx ctx;

      sha1_init_ctx (&ctx);
      if (!bed->s->checksum_contents (abfd, (sum_fn) &sha1_process_bytes, &ctx))
	return FALSE;
      sha1_finish_ctx (&ctx, id_bits);
    }
  else if (strcmp (style, "uuid") == 0)
    {
      int n;
      int fd = open ("/dev/urandom", O_RDONLY);
      if (fd < 0)
	return FALSE;
      n = read (fd, id_bits, size);
      close (fd);
      if (n < (int) size)
	return FALSE;
    }
  else if (strncmp (style, "0x", 2) == 0)
    {
      /* ID is in string form (hex).  Convert to bits.  */
      const char *id = style + 2;
      size_t n = 0;
      do
	{
	  if (ISXDIGIT (id[0]) && ISXDIGIT (id[1]))
	    {
	      id_bits[n] = read_hex (*id++) << 4;
	      id_bits[n++] |= read_hex (*id++);
	    }
	  else if (*id == '-' || *id == ':')
	    ++id;
	  else
	    abort ();		/* Should have been validated earlier.  */
	} while (*id != '\0');
    }
  else
    abort ();			/* Should have been validated earlier.  */

  position = i_shdr->sh_offset + asec->output_offset;
  size = asec->size;
  return (bfd_seek (abfd, position, SEEK_SET) == 0
	  && bfd_bwrite (contents, size, abfd) == size);
}

/* Make .note.gnu.build-id section, and set up elf_tdata->build_id.  */

static bfd_boolean
setup_build_id (bfd *ibfd)
{
  asection *s;
  bfd_size_type size;
  flagword flags;

  size = id_note_section_size (ibfd);
  if (size == 0)
    {
      einfo ("%P: warning: unrecognized --build-id style ignored.\n");
      return FALSE;
    }

  flags = (SEC_ALLOC | SEC_LOAD | SEC_IN_MEMORY
	   | SEC_LINKER_CREATED | SEC_READONLY | SEC_DATA);
  s = bfd_make_section_with_flags (ibfd, ".note.gnu.build-id", flags);
  if (s != NULL && bfd_set_section_alignment (ibfd, s, 2))
    {
      struct elf_obj_tdata *t = elf_tdata (link_info.output_bfd);
      t->o->build_id.after_write_object_contents = &write_build_id;
      t->o->build_id.style = emit_note_gnu_build_id;
      t->o->build_id.sec = s;
      elf_section_type (s) = SHT_NOTE;
      s->size = size;
      return TRUE;
    }

  einfo ("%P: warning: Cannot create .note.gnu.build-id section,"
	 " --build-id ignored.\n");
  return FALSE;
}

/* This is called after all the input files have been opened.  */

static void
gld${EMULATION_NAME}_after_open (void)
{
  struct bfd_link_needed_list *needed, *l;
  struct elf_link_hash_table *htab;

  after_open_default ();

  htab = elf_hash_table (&link_info);
  if (!is_elf_hash_table (htab))
    return;

  if (emit_note_gnu_build_id != NULL)
    {
      bfd *abfd;

      /* Find an ELF input.  */
      for (abfd = link_info.input_bfds;
	   abfd != (bfd *) NULL; abfd = abfd->link_next)
	if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)
	  break;

      /* PR 10555: If there are no ELF input files do not try to
	 create a .note.gnu-build-id section.  */
      if (abfd == NULL
	  || !setup_build_id (abfd))
	{
	  free ((char *) emit_note_gnu_build_id);
	  emit_note_gnu_build_id = NULL;
	}
    }

  if (link_info.relocatable)
    return;

  if (link_info.eh_frame_hdr
      && !link_info.traditional_format)
    {
      bfd *abfd, *elfbfd = NULL;
      bfd_boolean warn_eh_frame = FALSE;
      asection *s;

      for (abfd = link_info.input_bfds; abfd; abfd = abfd->link_next)
	{
	  if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)
	    elfbfd = abfd;
	  if (!warn_eh_frame)
	    {
	      s = bfd_get_section_by_name (abfd, ".eh_frame");
	      while (s != NULL
		     && (s->size <= 8
			 || bfd_is_abs_section (s->output_section)))
		s = bfd_get_next_section_by_name (s);
	      warn_eh_frame = s != NULL;
	    }
	  if (elfbfd && warn_eh_frame)
	    break;
	}
      if (elfbfd)
	{
	  const struct elf_backend_data *bed;

	  bed = get_elf_backend_data (elfbfd);
	  s = bfd_make_section_with_flags (elfbfd, ".eh_frame_hdr",
					   bed->dynamic_sec_flags
					   | SEC_READONLY);
	  if (s != NULL
	      && bfd_set_section_alignment (elfbfd, s, 2))
	    {
	      htab->eh_info.hdr_sec = s;
	      warn_eh_frame = FALSE;
	    }
	}
      if (warn_eh_frame)
	einfo ("%P: warning: Cannot create .eh_frame_hdr section,"
	       " --eh-frame-hdr ignored.\n");
    }

  /* Get the list of files which appear in DT_NEEDED entries in
     dynamic objects included in the link (often there will be none).
     For each such file, we want to track down the corresponding
     library, and include the symbol table in the link.  This is what
     the runtime dynamic linker will do.  Tracking the files down here
     permits one dynamic object to include another without requiring
     special action by the person doing the link.  Note that the
     needed list can actually grow while we are stepping through this
     loop.  */
  needed = bfd_elf_get_needed_list (link_info.output_bfd, &link_info);
  for (l = needed; l != NULL; l = l->next)
    {
      struct bfd_link_needed_list *ll;
      struct dt_needed n, nn;
      int force;

      /* If the lib that needs this one was --as-needed and wasn't
	 found to be needed, then this lib isn't needed either.  */
      if (l->by != NULL
	  && (bfd_elf_get_dyn_lib_class (l->by) & DYN_AS_NEEDED) != 0)
	continue;

      /* Skip the lib if --no-copy-dt-needed-entries and
	 --allow-shlib-undefined is in effect.  */
      if (l->by != NULL
	  && link_info.unresolved_syms_in_shared_libs == RM_IGNORE
	  && (bfd_elf_get_dyn_lib_class (l->by) & DYN_NO_ADD_NEEDED) != 0)
	continue;

      /* If we've already seen this file, skip it.  */
      for (ll = needed; ll != l; ll = ll->next)
	if ((ll->by == NULL
	     || (bfd_elf_get_dyn_lib_class (ll->by) & DYN_AS_NEEDED) == 0)
	    && strcmp (ll->name, l->name) == 0)
	  break;
      if (ll != l)
	continue;

      /* See if this file was included in the link explicitly.  */
      global_needed = l;
      global_found = NULL;
      lang_for_each_input_file (gld${EMULATION_NAME}_check_needed);
      if (global_found != NULL
	  && (bfd_elf_get_dyn_lib_class (global_found->the_bfd)
	      & DYN_AS_NEEDED) == 0)
	continue;

      n.by = l->by;
      n.name = l->name;
      nn.by = l->by;
      if (verbose)
	info_msg (_("%s needed by %B\n"), l->name, l->by);

      /* As-needed libs specified on the command line (or linker script)
	 take priority over libs found in search dirs.  */
      if (global_found != NULL)
	{
	  nn.name = global_found->filename;
	  if (gld${EMULATION_NAME}_try_needed (&nn, TRUE))
	    continue;
	}

      /* We need to find this file and include the symbol table.  We
	 want to search for the file in the same way that the dynamic
	 linker will search.  That means that we want to use
	 rpath_link, rpath, then the environment variable
	 LD_LIBRARY_PATH (native only), then the DT_RPATH/DT_RUNPATH
	 entries (native only), then the linker script LIB_SEARCH_DIRS.
	 We do not search using the -L arguments.

	 We search twice.  The first time, we skip objects which may
	 introduce version mismatches.  The second time, we force
	 their use.  See gld${EMULATION_NAME}_vercheck comment.  */
      for (force = 0; force < 2; force++)
	{
	  size_t len;
	  search_dirs_type *search;
EOF
if [ "x${NATIVE}" = xyes ] ; then
fragment <<EOF
	  const char *lib_path;
EOF
fi
if [ "x${USE_LIBPATH}" = xyes ] ; then
fragment <<EOF
	  struct bfd_link_needed_list *rp;
	  int found;
EOF
fi
fragment <<EOF

	  if (gld${EMULATION_NAME}_search_needed (command_line.rpath_link,
						  &n, force))
	    break;
EOF
if [ "x${USE_LIBPATH}" = xyes ] ; then
fragment <<EOF
	  if (gld${EMULATION_NAME}_search_needed (command_line.rpath,
						  &n, force))
	    break;
EOF
fi
if [ "x${NATIVE}" = xyes ] ; then
fragment <<EOF
	  if (command_line.rpath_link == NULL
	      && command_line.rpath == NULL)
	    {
	      lib_path = (const char *) getenv ("LD_RUN_PATH");
	      if (gld${EMULATION_NAME}_search_needed (lib_path, &n,
						      force))
		break;
	    }
	  lib_path = (const char *) getenv ("LD_LIBRARY_PATH");
	  if (gld${EMULATION_NAME}_search_needed (lib_path, &n, force))
	    break;
EOF
fi
if [ "x${USE_LIBPATH}" = xyes ] ; then
fragment <<EOF
	  found = 0;
	  rp = bfd_elf_get_runpath_list (link_info.output_bfd, &link_info);
	  for (; !found && rp != NULL; rp = rp->next)
	    {
	      char *tmpname = gld${EMULATION_NAME}_add_sysroot (rp->name);
	      found = (rp->by == l->by
		       && gld${EMULATION_NAME}_search_needed (tmpname,
							      &n,
							      force));
	      free (tmpname);
	    }
	  if (found)
	    break;

EOF
fi
if [ "x${USE_LIBPATH}" = xyes ] ; then
  case ${target} in
    *-*-freebsd* | *-*-dragonfly*)
      fragment <<EOF
	  if (gld${EMULATION_NAME}_check_ld_elf_hints (l, force))
	    break;
EOF
    # FreeBSD
    ;;

    *-*-linux-* | *-*-k*bsd*-* | *-*-gnu*)
      fragment <<EOF
	  if (gld${EMULATION_NAME}_check_ld_so_conf (l, force))
	    break;

EOF
    # Linux
    ;;
  esac
fi
fragment <<EOF
	  len = strlen (l->name);
	  for (search = search_head; search != NULL; search = search->next)
	    {
	      char *filename;

	      if (search->cmdline)
		continue;
	      filename = (char *) xmalloc (strlen (search->name) + len + 2);
	      sprintf (filename, "%s/%s", search->name, l->name);
	      nn.name = filename;
	      if (gld${EMULATION_NAME}_try_needed (&nn, force))
		break;
	      free (filename);
	    }
	  if (search != NULL)
	    break;
EOF
fragment <<EOF
	}

      if (force < 2)
	continue;

      einfo ("%P: warning: %s, needed by %B, not found (try using -rpath or -rpath-link)\n",
	     l->name, l->by);
    }
}

EOF
fi

fragment <<EOF

/* Look through an expression for an assignment statement.  */

static void
gld${EMULATION_NAME}_find_exp_assignment (etree_type *exp)
{
  bfd_boolean provide = FALSE;

  switch (exp->type.node_class)
    {
    case etree_provide:
    case etree_provided:
      provide = TRUE;
      /* Fall thru */
    case etree_assign:
      /* We call record_link_assignment even if the symbol is defined.
	 This is because if it is defined by a dynamic object, we
	 actually want to use the value defined by the linker script,
	 not the value from the dynamic object (because we are setting
	 symbols like etext).  If the symbol is defined by a regular
	 object, then, as it happens, calling record_link_assignment
	 will do no harm.  */
      if (strcmp (exp->assign.dst, ".") != 0)
	{
	  if (!bfd_elf_record_link_assignment (link_info.output_bfd,
					       &link_info,
					       exp->assign.dst, provide,
					       exp->assign.hidden))
	    einfo ("%P%F: failed to record assignment to %s: %E\n",
		   exp->assign.dst);
	}
      gld${EMULATION_NAME}_find_exp_assignment (exp->assign.src);
      break;

    case etree_binary:
      gld${EMULATION_NAME}_find_exp_assignment (exp->binary.lhs);
      gld${EMULATION_NAME}_find_exp_assignment (exp->binary.rhs);
      break;

    case etree_trinary:
      gld${EMULATION_NAME}_find_exp_assignment (exp->trinary.cond);
      gld${EMULATION_NAME}_find_exp_assignment (exp->trinary.lhs);
      gld${EMULATION_NAME}_find_exp_assignment (exp->trinary.rhs);
      break;

    case etree_unary:
      gld${EMULATION_NAME}_find_exp_assignment (exp->unary.child);
      break;

    default:
      break;
    }
}


/* This is called by the before_allocation routine via
   lang_for_each_statement.  It locates any assignment statements, and
   tells the ELF backend about them, in case they are assignments to
   symbols which are referred to by dynamic objects.  */

static void
gld${EMULATION_NAME}_find_statement_assignment (lang_statement_union_type *s)
{
  if (s->header.type == lang_assignment_statement_enum)
    gld${EMULATION_NAME}_find_exp_assignment (s->assignment_statement.exp);
}

EOF

if test x"$LDEMUL_BEFORE_ALLOCATION" != xgld"$EMULATION_NAME"_before_allocation; then
  if test x"${ELF_INTERPRETER_NAME+set}" = xset; then
    ELF_INTERPRETER_SET_DEFAULT="
  if (sinterp != NULL)
    {
      sinterp->contents = (unsigned char *) ${ELF_INTERPRETER_NAME};
      sinterp->size = strlen ((char *) sinterp->contents) + 1;
    }

"
  else
    ELF_INTERPRETER_SET_DEFAULT=
  fi
fragment <<EOF

/* used by before_allocation and handle_option. */
static void
gld${EMULATION_NAME}_append_to_separated_string (char **to, char *op_arg)
{
  if (*to == NULL)
    *to = xstrdup (op_arg);
  else
    {
      size_t to_len = strlen (*to);
      size_t op_arg_len = strlen (op_arg);
      char *buf;
      char *cp = *to;

      /* First see whether OPTARG is already in the path.  */
      do
	{
	  if (strncmp (op_arg, cp, op_arg_len) == 0
	      && (cp[op_arg_len] == 0
		  || cp[op_arg_len] == config.rpath_separator))
	    /* We found it.  */
	    break;

	  /* Not yet found.  */
	  cp = strchr (cp, config.rpath_separator);
	  if (cp != NULL)
	    ++cp;
	}
      while (cp != NULL);

      if (cp == NULL)
	{
	  buf = xmalloc (to_len + op_arg_len + 2);
	  sprintf (buf, "%s%c%s", *to,
		   config.rpath_separator, op_arg);
	  free (*to);
	  *to = buf;
	}
    }
}

/* This is called after the sections have been attached to output
   sections, but before any sizes or addresses have been set.  */

static void
gld${EMULATION_NAME}_before_allocation (void)
{
  const char *rpath;
  asection *sinterp;
  bfd *abfd;

  if (is_elf_hash_table (link_info.hash))
    {
      _bfd_elf_tls_setup (link_info.output_bfd, &link_info);

      /* Make __ehdr_start hidden if it has been referenced, to
	 prevent the symbol from being dynamic.  */
      if (!bfd_elf_record_link_assignment (link_info.output_bfd, &link_info,
					   "__ehdr_start", TRUE, TRUE))
	einfo ("%P%F: failed to record assignment to %s: %E\n",
	       "__ehdr_start");

      /* If we are going to make any variable assignments, we need to
	 let the ELF backend know about them in case the variables are
	 referred to by dynamic objects.  */
      lang_for_each_statement (gld${EMULATION_NAME}_find_statement_assignment);
    }

  /* Let the ELF backend work out the sizes of any sections required
     by dynamic linking.  */
  rpath = command_line.rpath;
  if (rpath == NULL)
    rpath = (const char *) getenv ("LD_RUN_PATH");

  for (abfd = link_info.input_bfds; abfd; abfd = abfd->link_next)
    if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)
      {
	const char *audit_libs = elf_dt_audit (abfd);

	/* If the input bfd contains an audit entry, we need to add it as
	   a dep audit entry.  */
	if (audit_libs && *audit_libs != '\0')
	  {
	    char *cp = xstrdup (audit_libs);
	    do
	      {
		int more = 0;
		char *cp2 = strchr (cp, config.rpath_separator);

		if (cp2)
		  {
		    *cp2 = '\0';
		    more = 1;
		  }

		if (cp != NULL && *cp != '\0')
		  gld${EMULATION_NAME}_append_to_separated_string (&depaudit, cp);

		cp = more ? ++cp2 : NULL;
	      }
	    while (cp != NULL);
	  }
      }

  if (! (bfd_elf_size_dynamic_sections
	 (link_info.output_bfd, command_line.soname, rpath,
	  command_line.filter_shlib, audit, depaudit,
	  (const char * const *) command_line.auxiliary_filters,
	  &link_info, &sinterp)))
    einfo ("%P%F: failed to set dynamic section sizes: %E\n");

${ELF_INTERPRETER_SET_DEFAULT}
  /* Let the user override the dynamic linker we are using.  */
  if (command_line.interpreter != NULL
      && sinterp != NULL)
    {
      sinterp->contents = (bfd_byte *) command_line.interpreter;
      sinterp->size = strlen (command_line.interpreter) + 1;
    }

  /* Look for any sections named .gnu.warning.  As a GNU extensions,
     we treat such sections as containing warning messages.  We print
     out the warning message, and then zero out the section size so
     that it does not get copied into the output file.  */

  {
    LANG_FOR_EACH_INPUT_STATEMENT (is)
      {
	asection *s;
	bfd_size_type sz;
	char *msg;
	bfd_boolean ret;

	if (is->flags.just_syms)
	  continue;

	s = bfd_get_section_by_name (is->the_bfd, ".gnu.warning");
	if (s == NULL)
	  continue;

	sz = s->size;
	msg = (char *) xmalloc ((size_t) (sz + 1));
	if (! bfd_get_section_contents (is->the_bfd, s,	msg,
					(file_ptr) 0, sz))
	  einfo ("%F%B: Can't read contents of section .gnu.warning: %E\n",
		 is->the_bfd);
	msg[sz] = '\0';
	ret = link_info.callbacks->warning (&link_info, msg,
					    (const char *) NULL,
					    is->the_bfd, (asection *) NULL,
					    (bfd_vma) 0);
	ASSERT (ret);
	free (msg);

	/* Clobber the section size, so that we don't waste space
	   copying the warning into the output file.  If we've already
	   sized the output section, adjust its size.  The adjustment
	   is on rawsize because targets that size sections early will
	   have called lang_reset_memory_regions after sizing.  */
	if (s->output_section != NULL
	    && s->output_section->rawsize >= s->size)
	  s->output_section->rawsize -= s->size;

	s->size = 0;

	/* Also set SEC_EXCLUDE, so that local symbols defined in the
	   warning section don't get copied to the output.  */
	s->flags |= SEC_EXCLUDE | SEC_KEEP;
      }
  }

  before_allocation_default ();

  if (!bfd_elf_size_dynsym_hash_dynstr (link_info.output_bfd, &link_info))
    einfo ("%P%F: failed to set dynamic section sizes: %E\n");
}

EOF
fi

if test x"$LDEMUL_OPEN_DYNAMIC_ARCHIVE" != xgld"$EMULATION_NAME"_open_dynamic_archive; then
fragment <<EOF

/* Try to open a dynamic archive.  This is where we know that ELF
   dynamic libraries have an extension of .so (or .sl on oddball systems
   like hpux).  */

static bfd_boolean
gld${EMULATION_NAME}_open_dynamic_archive
  (const char *arch, search_dirs_type *search, lang_input_statement_type *entry)
{
  const char *filename;
  char *string;

  if (! entry->flags.maybe_archive)
    return FALSE;

  filename = entry->filename;

  /* This allocates a few bytes too many when EXTRA_SHLIB_EXTENSION
     is defined, but it does not seem worth the headache to optimize
     away those two bytes of space.  */
  string = (char *) xmalloc (strlen (search->name)
			     + strlen (filename)
			     + strlen (arch)
#ifdef EXTRA_SHLIB_EXTENSION
			     + strlen (EXTRA_SHLIB_EXTENSION)
#endif
			     + sizeof "/lib.so");

  sprintf (string, "%s/lib%s%s.so", search->name, filename, arch);

#ifdef EXTRA_SHLIB_EXTENSION
  /* Try the .so extension first.  If that fails build a new filename
     using EXTRA_SHLIB_EXTENSION.  */
  if (! ldfile_try_open_bfd (string, entry))
    {
      sprintf (string, "%s/lib%s%s%s", search->name,
	       filename, arch, EXTRA_SHLIB_EXTENSION);
#endif

  if (! ldfile_try_open_bfd (string, entry))
    {
      free (string);
      return FALSE;
    }
#ifdef EXTRA_SHLIB_EXTENSION
    }
#endif

  entry->filename = string;

  /* We have found a dynamic object to include in the link.  The ELF
     backend linker will create a DT_NEEDED entry in the .dynamic
     section naming this file.  If this file includes a DT_SONAME
     entry, it will be used.  Otherwise, the ELF linker will just use
     the name of the file.  For an archive found by searching, like
     this one, the DT_NEEDED entry should consist of just the name of
     the file, without the path information used to find it.  Note
     that we only need to do this if we have a dynamic object; an
     archive will never be referenced by a DT_NEEDED entry.

     FIXME: This approach--using bfd_elf_set_dt_needed_name--is not
     very pretty.  I haven't been able to think of anything that is
     pretty, though.  */
  if (bfd_check_format (entry->the_bfd, bfd_object)
      && (entry->the_bfd->flags & DYNAMIC) != 0)
    {
      ASSERT (entry->flags.maybe_archive && entry->flags.search_dirs);

      /* Rather than duplicating the logic above.  Just use the
	 filename we recorded earlier.  */

      filename = lbasename (entry->filename);
      bfd_elf_set_dt_needed_name (entry->the_bfd, filename);
    }

  return TRUE;
}

EOF
fi

if test x"$LDEMUL_PLACE_ORPHAN" != xgld"$EMULATION_NAME"_place_orphan; then
fragment <<EOF

/* A variant of lang_output_section_find used by place_orphan.  */

static lang_output_section_statement_type *
output_rel_find (asection *sec, int isdyn)
{
  lang_output_section_statement_type *lookup;
  lang_output_section_statement_type *last = NULL;
  lang_output_section_statement_type *last_alloc = NULL;
  lang_output_section_statement_type *last_ro_alloc = NULL;
  lang_output_section_statement_type *last_rel = NULL;
  lang_output_section_statement_type *last_rel_alloc = NULL;
  int rela = sec->name[4] == 'a';

  for (lookup = &lang_output_section_statement.head->output_section_statement;
       lookup != NULL;
       lookup = lookup->next)
    {
      if (lookup->constraint >= 0
	  && CONST_STRNEQ (lookup->name, ".rel"))
	{
	  int lookrela = lookup->name[4] == 'a';

	  /* .rel.dyn must come before all other reloc sections, to suit
	     GNU ld.so.  */
	  if (isdyn)
	    break;

	  /* Don't place after .rel.plt as doing so results in wrong
	     dynamic tags.  */
	  if (strcmp (".plt", lookup->name + 4 + lookrela) == 0)
	    break;

	  if (rela == lookrela || last_rel == NULL)
	    last_rel = lookup;
	  if ((rela == lookrela || last_rel_alloc == NULL)
	      && lookup->bfd_section != NULL
	      && (lookup->bfd_section->flags & SEC_ALLOC) != 0)
	    last_rel_alloc = lookup;
	}

      last = lookup;
      if (lookup->bfd_section != NULL
	  && (lookup->bfd_section->flags & SEC_ALLOC) != 0)
	{
	  last_alloc = lookup;
	  if ((lookup->bfd_section->flags & SEC_READONLY) != 0)
	    last_ro_alloc = lookup;
	}
    }

  if (last_rel_alloc)
    return last_rel_alloc;

  if (last_rel)
    return last_rel;

  if (last_ro_alloc)
    return last_ro_alloc;

  if (last_alloc)
    return last_alloc;

  return last;
}

/* Place an orphan section.  We use this to put random SHF_ALLOC
   sections in the right segment.  */

static lang_output_section_statement_type *
gld${EMULATION_NAME}_place_orphan (asection *s,
				   const char *secname,
				   int constraint)
{
  static struct orphan_save hold[] =
    {
      { ".text",
	SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_CODE,
	0, 0, 0, 0 },
      { ".rodata",
	SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_DATA,
	0, 0, 0, 0 },
      { ".data",
	SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_DATA,
	0, 0, 0, 0 },
      { ".bss",
	SEC_ALLOC,
	0, 0, 0, 0 },
      { 0,
	SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_DATA,
	0, 0, 0, 0 },
      { ".interp",
	SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_DATA,
	0, 0, 0, 0 },
      { ".sdata",
	SEC_HAS_CONTENTS | SEC_ALLOC | SEC_LOAD | SEC_DATA | SEC_SMALL_DATA,
	0, 0, 0, 0 },
      { ".comment",
	SEC_HAS_CONTENTS,
	0, 0, 0, 0 },
    };
  enum orphan_save_index
    {
      orphan_text = 0,
      orphan_rodata,
      orphan_data,
      orphan_bss,
      orphan_rel,
      orphan_interp,
      orphan_sdata,
      orphan_nonalloc
    };
  static int orphan_init_done = 0;
  struct orphan_save *place;
  lang_output_section_statement_type *after;
  lang_output_section_statement_type *os;
  lang_output_section_statement_type *match_by_name = NULL;
  int isdyn = 0;
  int iself = s->owner->xvec->flavour == bfd_target_elf_flavour;
  unsigned int sh_type = iself ? elf_section_type (s) : SHT_NULL;

  if (! link_info.relocatable
      && link_info.combreloc
      && (s->flags & SEC_ALLOC))
    {
      if (iself)
	switch (sh_type)
	  {
	  case SHT_RELA:
	    secname = ".rela.dyn";
	    isdyn = 1;
	    break;
	  case SHT_REL:
	    secname = ".rel.dyn";
	    isdyn = 1;
	    break;
	  default:
	    break;
	  }
      else if (CONST_STRNEQ (secname, ".rel"))
	{
	  secname = secname[4] == 'a' ? ".rela.dyn" : ".rel.dyn";
	  isdyn = 1;
	}
    }

  /* Look through the script to see where to place this section.  */
  if (constraint == 0)
    for (os = lang_output_section_find (secname);
	 os != NULL;
	 os = next_matching_output_section_statement (os, 0))
      {
	/* If we don't match an existing output section, tell
	   lang_insert_orphan to create a new output section.  */
	constraint = SPECIAL;

	if (os->bfd_section != NULL
	    && (os->bfd_section->flags == 0
		|| (_bfd_elf_match_sections_by_type (link_info.output_bfd,
						     os->bfd_section,
						     s->owner, s)
		    && ((s->flags ^ os->bfd_section->flags)
			& (SEC_LOAD | SEC_ALLOC)) == 0)))
	  {
	    /* We already have an output section statement with this
	       name, and its bfd section has compatible flags.
	       If the section already exists but does not have any flags
	       set, then it has been created by the linker, probably as a
	       result of a --section-start command line switch.  */
	    lang_add_section (&os->children, s, NULL, os);
	    return os;
	  }

	/* Save unused output sections in case we can match them
	   against orphans later.  */
	if (os->bfd_section == NULL)
	  match_by_name = os;
      }

  /* If we didn't match an active output section, see if we matched an
     unused one and use that.  */
  if (match_by_name)
    {
      lang_add_section (&match_by_name->children, s, NULL, match_by_name);
      return match_by_name;
    }

  if (!orphan_init_done)
    {
      struct orphan_save *ho;

      for (ho = hold; ho < hold + sizeof (hold) / sizeof (hold[0]); ++ho)
	if (ho->name != NULL)
	  {
	    ho->os = lang_output_section_find (ho->name);
	    if (ho->os != NULL && ho->os->flags == 0)
	      ho->os->flags = ho->flags;
	  }
      orphan_init_done = 1;
    }

  /* If this is a final link, then always put .gnu.warning.SYMBOL
     sections into the .text section to get them out of the way.  */
  if (link_info.executable
      && ! link_info.relocatable
      && CONST_STRNEQ (s->name, ".gnu.warning.")
      && hold[orphan_text].os != NULL)
    {
      os = hold[orphan_text].os;
      lang_add_section (&os->children, s, NULL, os);
      return os;
    }

  /* Decide which segment the section should go in based on the
     section name and section flags.  We put loadable .note sections
     right after the .interp section, so that the PT_NOTE segment is
     stored right after the program headers where the OS can read it
     in the first page.  */

  place = NULL;
  if ((s->flags & (SEC_ALLOC | SEC_DEBUGGING)) == 0)
    place = &hold[orphan_nonalloc];
  else if ((s->flags & SEC_ALLOC) == 0)
    ;
  else if ((s->flags & SEC_LOAD) != 0
	   && ((iself && sh_type == SHT_NOTE)
	       || (!iself && CONST_STRNEQ (secname, ".note"))))
    place = &hold[orphan_interp];
  else if ((s->flags & (SEC_LOAD | SEC_HAS_CONTENTS | SEC_THREAD_LOCAL)) == 0)
    place = &hold[orphan_bss];
  else if ((s->flags & SEC_SMALL_DATA) != 0)
    place = &hold[orphan_sdata];
  else if ((s->flags & SEC_READONLY) == 0)
    place = &hold[orphan_data];
  else if (((iself && (sh_type == SHT_RELA || sh_type == SHT_REL))
	    || (!iself && CONST_STRNEQ (secname, ".rel")))
	   && (s->flags & SEC_LOAD) != 0)
    place = &hold[orphan_rel];
  else if ((s->flags & SEC_CODE) == 0)
    place = &hold[orphan_rodata];
  else
    place = &hold[orphan_text];

  after = NULL;
  if (place != NULL)
    {
      if (place->os == NULL)
	{
	  if (place->name != NULL)
	    place->os = lang_output_section_find (place->name);
	  else
	    place->os = output_rel_find (s, isdyn);
	}
      after = place->os;
      if (after == NULL)
	after = lang_output_section_find_by_flags
	  (s, &place->os, _bfd_elf_match_sections_by_type);
      if (after == NULL)
	/* *ABS* is always the first output section statement.  */
	after = &lang_output_section_statement.head->output_section_statement;
    }

  return lang_insert_orphan (s, secname, constraint, after, place, NULL, NULL);
}
EOF
fi

if test x"$LDEMUL_AFTER_ALLOCATION" != xgld"$EMULATION_NAME"_after_allocation; then
fragment <<EOF

static void
gld${EMULATION_NAME}_after_allocation (void)
{
  bfd_boolean need_layout = bfd_elf_discard_info (link_info.output_bfd,
						  &link_info);
  gld${EMULATION_NAME}_map_segments (need_layout);
}
EOF
fi

if test x"$LDEMUL_GET_SCRIPT" != xgld"$EMULATION_NAME"_get_script; then
fragment <<EOF

static char *
gld${EMULATION_NAME}_get_script (int *isfile)
EOF

if test -n "$COMPILE_IN"
then
# Scripts compiled in.

# sed commands to quote an ld script as a C string.
sc="-f stringify.sed"

fragment <<EOF
{
  *isfile = 0;

  if (link_info.relocatable && config.build_constructors)
    return
EOF
sed $sc ldscripts/${EMULATION_NAME}.xu			>> e${EMULATION_NAME}.c
echo '  ; else if (link_info.relocatable) return'	>> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xr			>> e${EMULATION_NAME}.c
echo '  ; else if (!config.text_read_only) return'	>> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xbn			>> e${EMULATION_NAME}.c
if cmp -s ldscripts/${EMULATION_NAME}.x ldscripts/${EMULATION_NAME}.xn; then : ; else
echo '  ; else if (!config.magic_demand_paged) return'	>> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xn			>> e${EMULATION_NAME}.c
fi
if test -n "$GENERATE_PIE_SCRIPT" ; then
if test -n "$GENERATE_COMBRELOC_SCRIPT" ; then
echo '  ; else if (link_info.pie && link_info.combreloc' >> e${EMULATION_NAME}.c
echo '             && link_info.relro' >> e${EMULATION_NAME}.c
echo '             && (link_info.flags & DF_BIND_NOW)) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xdw			>> e${EMULATION_NAME}.c
echo '  ; else if (link_info.pie && link_info.combreloc) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xdc			>> e${EMULATION_NAME}.c
fi
echo '  ; else if (link_info.pie) return'		>> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xd			>> e${EMULATION_NAME}.c
fi
if test -n "$GENERATE_SHLIB_SCRIPT" ; then
if test -n "$GENERATE_COMBRELOC_SCRIPT" ; then
echo '  ; else if (link_info.shared && link_info.combreloc' >> e${EMULATION_NAME}.c
echo '             && link_info.relro' >> e${EMULATION_NAME}.c
echo '             && (link_info.flags & DF_BIND_NOW)) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xsw			>> e${EMULATION_NAME}.c
echo '  ; else if (link_info.shared && link_info.combreloc) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xsc			>> e${EMULATION_NAME}.c
fi
echo '  ; else if (link_info.shared) return'		>> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xs			>> e${EMULATION_NAME}.c
fi
if test -n "$GENERATE_COMBRELOC_SCRIPT" ; then
echo '  ; else if (link_info.combreloc && link_info.relro' >> e${EMULATION_NAME}.c
echo '             && (link_info.flags & DF_BIND_NOW)) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xw			>> e${EMULATION_NAME}.c
echo '  ; else if (link_info.combreloc) return'		>> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xc			>> e${EMULATION_NAME}.c
fi
echo '  ; else return'					>> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.x			>> e${EMULATION_NAME}.c
echo '; }'						>> e${EMULATION_NAME}.c

else
# Scripts read from the filesystem.

fragment <<EOF
{
  *isfile = 1;

  if (link_info.relocatable && config.build_constructors)
    return "ldscripts/${EMULATION_NAME}.xu";
  else if (link_info.relocatable)
    return "ldscripts/${EMULATION_NAME}.xr";
  else if (!config.text_read_only)
    return "ldscripts/${EMULATION_NAME}.xbn";
EOF
if cmp -s ldscripts/${EMULATION_NAME}.x ldscripts/${EMULATION_NAME}.xn; then :
else
fragment <<EOF
  else if (!config.magic_demand_paged)
    return "ldscripts/${EMULATION_NAME}.xn";
EOF
fi
if test -n "$GENERATE_PIE_SCRIPT" ; then
if test -n "$GENERATE_COMBRELOC_SCRIPT" ; then
fragment <<EOF
  else if (link_info.pie && link_info.combreloc
	   && link_info.relro && (link_info.flags & DF_BIND_NOW))
    return "ldscripts/${EMULATION_NAME}.xdw";
  else if (link_info.pie && link_info.combreloc)
    return "ldscripts/${EMULATION_NAME}.xdc";
EOF
fi
fragment <<EOF
  else if (link_info.pie)
    return "ldscripts/${EMULATION_NAME}.xd";
EOF
fi
if test -n "$GENERATE_SHLIB_SCRIPT" ; then
if test -n "$GENERATE_COMBRELOC_SCRIPT" ; then
fragment <<EOF
  else if (link_info.shared && link_info.combreloc
	   && link_info.relro && (link_info.flags & DF_BIND_NOW))
    return "ldscripts/${EMULATION_NAME}.xsw";
  else if (link_info.shared && link_info.combreloc)
    return "ldscripts/${EMULATION_NAME}.xsc";
EOF
fi
fragment <<EOF
  else if (link_info.shared)
    return "ldscripts/${EMULATION_NAME}.xs";
EOF
fi
if test -n "$GENERATE_COMBRELOC_SCRIPT" ; then
fragment <<EOF
  else if (link_info.combreloc && link_info.relro
	   && (link_info.flags & DF_BIND_NOW))
    return "ldscripts/${EMULATION_NAME}.xw";
  else if (link_info.combreloc)
    return "ldscripts/${EMULATION_NAME}.xc";
EOF
fi
fragment <<EOF
  else
    return "ldscripts/${EMULATION_NAME}.x";
}

EOF
fi
fi

if test -n "$PARSE_AND_LIST_PROLOGUE" ; then
fragment <<EOF
 $PARSE_AND_LIST_PROLOGUE
EOF
fi

fragment <<EOF

#define OPTION_DISABLE_NEW_DTAGS	(400)
#define OPTION_ENABLE_NEW_DTAGS		(OPTION_DISABLE_NEW_DTAGS + 1)
#define OPTION_GROUP			(OPTION_ENABLE_NEW_DTAGS + 1)
#define OPTION_EH_FRAME_HDR		(OPTION_GROUP + 1)
#define OPTION_EXCLUDE_LIBS		(OPTION_EH_FRAME_HDR + 1)
#define OPTION_HASH_STYLE		(OPTION_EXCLUDE_LIBS + 1)
#define OPTION_BUILD_ID			(OPTION_HASH_STYLE + 1)
#define OPTION_AUDIT			(OPTION_BUILD_ID + 1)

static void
gld${EMULATION_NAME}_add_options
  (int ns, char **shortopts, int nl, struct option **longopts,
   int nrl ATTRIBUTE_UNUSED, struct option **really_longopts ATTRIBUTE_UNUSED)
{
EOF
if test x"$GENERATE_SHLIB_SCRIPT" = xyes; then
fragment <<EOF
  static const char xtra_short[] = "${PARSE_AND_LIST_SHORTOPTS}z:P:";
EOF
else
fragment <<EOF
  static const char xtra_short[] = "${PARSE_AND_LIST_SHORTOPTS}z:";
EOF
fi
fragment <<EOF
  static const struct option xtra_long[] = {
EOF
if test x"$GENERATE_SHLIB_SCRIPT" = xyes; then
fragment <<EOF
    {"audit", required_argument, NULL, OPTION_AUDIT},
    {"Bgroup", no_argument, NULL, OPTION_GROUP},
EOF
fi
fragment <<EOF
    {"build-id", optional_argument, NULL, OPTION_BUILD_ID},
EOF
if test x"$GENERATE_SHLIB_SCRIPT" = xyes; then
fragment <<EOF
    {"depaudit", required_argument, NULL, 'P'},
    {"disable-new-dtags", no_argument, NULL, OPTION_DISABLE_NEW_DTAGS},
    {"enable-new-dtags", no_argument, NULL, OPTION_ENABLE_NEW_DTAGS},
    {"eh-frame-hdr", no_argument, NULL, OPTION_EH_FRAME_HDR},
    {"exclude-libs", required_argument, NULL, OPTION_EXCLUDE_LIBS},
    {"hash-style", required_argument, NULL, OPTION_HASH_STYLE},
EOF
fi
if test -n "$PARSE_AND_LIST_LONGOPTS" ; then
fragment <<EOF
    $PARSE_AND_LIST_LONGOPTS
EOF
fi
fragment <<EOF
    {NULL, no_argument, NULL, 0}
  };

  *shortopts = (char *) xrealloc (*shortopts, ns + sizeof (xtra_short));
  memcpy (*shortopts + ns, &xtra_short, sizeof (xtra_short));
  *longopts = (struct option *)
    xrealloc (*longopts, nl * sizeof (struct option) + sizeof (xtra_long));
  memcpy (*longopts + nl, &xtra_long, sizeof (xtra_long));
}

#define DEFAULT_BUILD_ID_STYLE	"sha1"

static bfd_boolean
gld${EMULATION_NAME}_handle_option (int optc)
{
  switch (optc)
    {
    default:
      return FALSE;

    case OPTION_BUILD_ID:
      if (emit_note_gnu_build_id != NULL)
	{
	  free ((char *) emit_note_gnu_build_id);
	  emit_note_gnu_build_id = NULL;
	}
      if (optarg == NULL)
	optarg = DEFAULT_BUILD_ID_STYLE;
      if (strcmp (optarg, "none"))
	emit_note_gnu_build_id = xstrdup (optarg);
      break;

EOF

if test x"$GENERATE_SHLIB_SCRIPT" = xyes; then
fragment <<EOF
    case OPTION_AUDIT:
	gld${EMULATION_NAME}_append_to_separated_string (&audit, optarg);
	break;

    case 'P':
	gld${EMULATION_NAME}_append_to_separated_string (&depaudit, optarg);
	break;

    case OPTION_DISABLE_NEW_DTAGS:
      link_info.new_dtags = FALSE;
      break;

    case OPTION_ENABLE_NEW_DTAGS:
      link_info.new_dtags = TRUE;
      break;

    case OPTION_EH_FRAME_HDR:
      link_info.eh_frame_hdr = TRUE;
      break;

    case OPTION_GROUP:
      link_info.flags_1 |= (bfd_vma) DF_1_GROUP;
      /* Groups must be self-contained.  */
      link_info.unresolved_syms_in_objects = RM_GENERATE_ERROR;
      link_info.unresolved_syms_in_shared_libs = RM_GENERATE_ERROR;
      break;

    case OPTION_EXCLUDE_LIBS:
      add_excluded_libs (optarg);
      break;

    case OPTION_HASH_STYLE:
      link_info.emit_hash = FALSE;
      link_info.emit_gnu_hash = FALSE;
      if (strcmp (optarg, "sysv") == 0)
	link_info.emit_hash = TRUE;
      else if (strcmp (optarg, "gnu") == 0)
	link_info.emit_gnu_hash = TRUE;
      else if (strcmp (optarg, "both") == 0)
	{
	  link_info.emit_hash = TRUE;
	  link_info.emit_gnu_hash = TRUE;
	}
      else
	einfo (_("%P%F: invalid hash style \`%s'\n"), optarg);
      break;

EOF
fi
fragment <<EOF
    case 'z':
      if (strcmp (optarg, "defs") == 0)
	link_info.unresolved_syms_in_objects = RM_GENERATE_ERROR;
      else if (strcmp (optarg, "muldefs") == 0)
	link_info.allow_multiple_definition = TRUE;
      else if (CONST_STRNEQ (optarg, "max-page-size="))
	{
	  char *end;

	  config.maxpagesize = strtoul (optarg + 14, &end, 0);
	  if (*end || (config.maxpagesize & (config.maxpagesize - 1)) != 0)
	    einfo (_("%P%F: invalid maxium page size \`%s'\n"),
		   optarg + 14);
	}
      else if (CONST_STRNEQ (optarg, "common-page-size="))
	{
	  char *end;
	  config.commonpagesize = strtoul (optarg + 17, &end, 0);
	  if (*end
	      || (config.commonpagesize & (config.commonpagesize - 1)) != 0)
	    einfo (_("%P%F: invalid common page size \`%s'\n"),
		   optarg + 17);
	}
      else if (CONST_STRNEQ (optarg, "stack-size="))
	{
	  char *end;
	  link_info.stacksize = strtoul (optarg + 11, &end, 0);
	  if (*end || link_info.stacksize < 0)
	    einfo (_("%P%F: invalid stack size \`%s'\n"), optarg + 11);
	  if (!link_info.stacksize)
	    /* Use -1 for explicit no-stack, because zero means
	       'default'.   */
	    link_info.stacksize = -1;
	}
      else if (strcmp (optarg, "execstack") == 0)
	{
	  link_info.execstack = TRUE;
	  link_info.noexecstack = FALSE;
	}
      else if (strcmp (optarg, "noexecstack") == 0)
	{
	  link_info.noexecstack = TRUE;
	  link_info.execstack = FALSE;
	}
EOF
if test x"$GENERATE_SHLIB_SCRIPT" = xyes; then
fragment <<EOF
      else if (strcmp (optarg, "global") == 0)
	link_info.flags_1 |= (bfd_vma) DF_1_GLOBAL;
      else if (strcmp (optarg, "initfirst") == 0)
	link_info.flags_1 |= (bfd_vma) DF_1_INITFIRST;
      else if (strcmp (optarg, "interpose") == 0)
	link_info.flags_1 |= (bfd_vma) DF_1_INTERPOSE;
      else if (strcmp (optarg, "loadfltr") == 0)
	link_info.flags_1 |= (bfd_vma) DF_1_LOADFLTR;
      else if (strcmp (optarg, "nodefaultlib") == 0)
	link_info.flags_1 |= (bfd_vma) DF_1_NODEFLIB;
      else if (strcmp (optarg, "nodelete") == 0)
	link_info.flags_1 |= (bfd_vma) DF_1_NODELETE;
      else if (strcmp (optarg, "nodlopen") == 0)
	link_info.flags_1 |= (bfd_vma) DF_1_NOOPEN;
      else if (strcmp (optarg, "nodump") == 0)
	link_info.flags_1 |= (bfd_vma) DF_1_NODUMP;
      else if (strcmp (optarg, "now") == 0)
	{
	  link_info.flags |= (bfd_vma) DF_BIND_NOW;
	  link_info.flags_1 |= (bfd_vma) DF_1_NOW;
	}
      else if (strcmp (optarg, "lazy") == 0)
	{
	  link_info.flags &= ~(bfd_vma) DF_BIND_NOW;
	  link_info.flags_1 &= ~(bfd_vma) DF_1_NOW;
	}
      else if (strcmp (optarg, "origin") == 0)
	{
	  link_info.flags |= (bfd_vma) DF_ORIGIN;
	  link_info.flags_1 |= (bfd_vma) DF_1_ORIGIN;
	}
      else if (strcmp (optarg, "combreloc") == 0)
	link_info.combreloc = TRUE;
      else if (strcmp (optarg, "nocombreloc") == 0)
	link_info.combreloc = FALSE;
      else if (strcmp (optarg, "nocopyreloc") == 0)
	link_info.nocopyreloc = TRUE;
      else if (strcmp (optarg, "relro") == 0)
	link_info.relro = TRUE;
      else if (strcmp (optarg, "norelro") == 0)
	link_info.relro = FALSE;
      else if (strcmp (optarg, "text") == 0)
	link_info.error_textrel = TRUE;
      else if (strcmp (optarg, "notext") == 0)
	link_info.error_textrel = FALSE;
      else if (strcmp (optarg, "textoff") == 0)
	link_info.error_textrel = FALSE;
EOF
fi

fragment <<EOF
      else
	einfo (_("%P: warning: -z %s ignored.\n"), optarg);
      break;
EOF

if test -n "$PARSE_AND_LIST_ARGS_CASES" ; then
fragment <<EOF
 $PARSE_AND_LIST_ARGS_CASES
EOF
fi

fragment <<EOF
    }

  return TRUE;
}

EOF

if test x"$LDEMUL_LIST_OPTIONS" != xgld"$EMULATION_NAME"_list_options; then
fragment <<EOF

static void
gld${EMULATION_NAME}_list_options (FILE * file)
{
EOF
if test x"$GENERATE_SHLIB_SCRIPT" = xyes; then
fragment <<EOF
  fprintf (file, _("\
  --audit=AUDITLIB            Specify a library to use for auditing\n"));
  fprintf (file, _("\
  -Bgroup                     Selects group name lookup rules for DSO\n"));
EOF
fi
fragment <<EOF
  fprintf (file, _("\
  --build-id[=STYLE]          Generate build ID note\n"));
EOF
if test x"$GENERATE_SHLIB_SCRIPT" = xyes; then
fragment <<EOF
  fprintf (file, _("\
  -P AUDITLIB, --depaudit=AUDITLIB\n" "\
			      Specify a library to use for auditing dependencies\n"));
  fprintf (file, _("\
  --disable-new-dtags         Disable new dynamic tags\n"));
  fprintf (file, _("\
  --enable-new-dtags          Enable new dynamic tags\n"));
  fprintf (file, _("\
  --eh-frame-hdr              Create .eh_frame_hdr section\n"));
  fprintf (file, _("\
  --exclude-libs=LIBS         Make all symbols in LIBS hidden\n"));
  fprintf (file, _("\
  --hash-style=STYLE          Set hash style to sysv, gnu or both\n"));
  fprintf (file, _("\
  -z combreloc                Merge dynamic relocs into one section and sort\n"));
EOF
fi

fragment <<EOF
  fprintf (file, _("\
  -z common-page-size=SIZE    Set common page size to SIZE\n"));
  fprintf (file, _("\
  -z defs                     Report unresolved symbols in object files.\n"));
  fprintf (file, _("\
  -z execstack                Mark executable as requiring executable stack\n"));
EOF

if test x"$GENERATE_SHLIB_SCRIPT" = xyes; then
fragment <<EOF
  fprintf (file, _("\
  -z global                   Make symbols in DSO available for subsequently\n\
			       loaded objects\n"));
  fprintf (file, _("\
  -z initfirst                Mark DSO to be initialized first at runtime\n"));
  fprintf (file, _("\
  -z interpose                Mark object to interpose all DSOs but executable\n"));
  fprintf (file, _("\
  -z lazy                     Mark object lazy runtime binding (default)\n"));
  fprintf (file, _("\
  -z loadfltr                 Mark object requiring immediate process\n"));
EOF
fi

fragment <<EOF
  fprintf (file, _("\
  -z max-page-size=SIZE       Set maximum page size to SIZE\n"));
  fprintf (file, _("\
  -z muldefs                  Allow multiple definitions\n"));
EOF

if test x"$GENERATE_SHLIB_SCRIPT" = xyes; then
fragment <<EOF
  fprintf (file, _("\
  -z nocombreloc              Don't merge dynamic relocs into one section\n"));
  fprintf (file, _("\
  -z nocopyreloc              Don't create copy relocs\n"));
  fprintf (file, _("\
  -z nodefaultlib             Mark object not to use default search paths\n"));
  fprintf (file, _("\
  -z nodelete                 Mark DSO non-deletable at runtime\n"));
  fprintf (file, _("\
  -z nodlopen                 Mark DSO not available to dlopen\n"));
  fprintf (file, _("\
  -z nodump                   Mark DSO not available to dldump\n"));
EOF
fi
fragment <<EOF
  fprintf (file, _("\
  -z noexecstack              Mark executable as not requiring executable stack\n"));
EOF
if test x"$GENERATE_SHLIB_SCRIPT" = xyes; then
fragment <<EOF
  fprintf (file, _("\
  -z norelro                  Don't create RELRO program header\n"));
  fprintf (file, _("\
  -z now                      Mark object non-lazy runtime binding\n"));
  fprintf (file, _("\
  -z origin                   Mark object requiring immediate \$ORIGIN\n\
				processing at runtime\n"));
  fprintf (file, _("\
  -z relro                    Create RELRO program header\n"));
  fprintf (file, _("\
  -z stacksize=SIZE           Set size of stack segment\n"));
EOF
fi

if test -n "$PARSE_AND_LIST_OPTIONS" ; then
fragment <<EOF
 $PARSE_AND_LIST_OPTIONS
EOF
fi

fragment <<EOF
}
EOF

if test -n "$PARSE_AND_LIST_EPILOGUE" ; then
fragment <<EOF
 $PARSE_AND_LIST_EPILOGUE
EOF
fi
fi

fragment <<EOF

struct ld_emulation_xfer_struct ld_${EMULATION_NAME}_emulation =
{
  ${LDEMUL_BEFORE_PARSE-gld${EMULATION_NAME}_before_parse},
  ${LDEMUL_SYSLIB-syslib_default},
  ${LDEMUL_HLL-hll_default},
  ${LDEMUL_AFTER_PARSE-after_parse_default},
  ${LDEMUL_AFTER_OPEN-gld${EMULATION_NAME}_after_open},
  ${LDEMUL_AFTER_ALLOCATION-gld${EMULATION_NAME}_after_allocation},
  ${LDEMUL_SET_OUTPUT_ARCH-set_output_arch_default},
  ${LDEMUL_CHOOSE_TARGET-ldemul_default_target},
  ${LDEMUL_BEFORE_ALLOCATION-gld${EMULATION_NAME}_before_allocation},
  ${LDEMUL_GET_SCRIPT-gld${EMULATION_NAME}_get_script},
  "${EMULATION_NAME}",
  "${OUTPUT_FORMAT}",
  ${LDEMUL_FINISH-finish_default},
  ${LDEMUL_CREATE_OUTPUT_SECTION_STATEMENTS-NULL},
  ${LDEMUL_OPEN_DYNAMIC_ARCHIVE-gld${EMULATION_NAME}_open_dynamic_archive},
  ${LDEMUL_PLACE_ORPHAN-gld${EMULATION_NAME}_place_orphan},
  ${LDEMUL_SET_SYMBOLS-NULL},
  ${LDEMUL_PARSE_ARGS-NULL},
  gld${EMULATION_NAME}_add_options,
  gld${EMULATION_NAME}_handle_option,
  ${LDEMUL_UNRECOGNIZED_FILE-NULL},
  ${LDEMUL_LIST_OPTIONS-gld${EMULATION_NAME}_list_options},
  ${LDEMUL_RECOGNIZED_FILE-gld${EMULATION_NAME}_load_symbols},
  ${LDEMUL_FIND_POTENTIAL_LIBRARIES-NULL},
  ${LDEMUL_NEW_VERS_PATTERN-NULL}
};
EOF
@


1.246
log
@        gold/
        PR ld/15365
        * layout.cc (Layout::finalize): Make __ehdr_start STV_HIDDEN.

        ld/
        PR ld/15365
        * emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation):
        Restrict __ehdr_start's export class to no less than STV_HIDDEN.

        ld/testsuite/
        PR ld/15365
        * ld-elf/ehdr_start.d: Expect __ehdr_start to be STB_LOCAL.
        * ld-mips-elf/ehdr_start-1.nd: New test.
        * ld-mips-elf/ehdr_start-2.nd: New test.
        * ld-mips-elf/ehdr_start-1.ld: New test linker script.
        * ld-mips-elf/ehdr_start-2.ld: New test linker script.
        * ld-mips-elf/ehdr_start-new.s: New test source.
        * ld-mips-elf/ehdr_start-o32.s: New test source.
        * ld-mips-elf/mips-elf.exp: Run the new tests.
@
text
@d896 1
a896 1
id_note_section_size (bfd *abfd)
a900 2
  abfd = abfd;

@


1.246.2.1
log
@ld/
	* emultempl/elf32.em (id_note_section_size): Use ATTRIBUTE_UNUSED
	rather than a dummy assignment for unused parameter.
	* plugin.c (get_input_file, release_input_file): Likewise.
@
text
@d896 1
a896 1
id_note_section_size (bfd *abfd ATTRIBUTE_UNUSED)
d901 2
@


1.245
log
@	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation):
	Only call lang_for_each_statement if an ELF hash table is used.
@
text
@d1490 7
@


1.244
log
@	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation):
	Use is_elf_hash_table rather than a handcoded condition.
@
text
@d1487 2
a1488 1
    _bfd_elf_tls_setup (link_info.output_bfd, &link_info);
d1490 5
a1494 4
  /* If we are going to make any variable assignments, we need to let
     the ELF backend know about them in case the variables are
     referred to by dynamic objects.  */
  lang_for_each_statement (gld${EMULATION_NAME}_find_statement_assignment);
@


1.243
log
@	* emultempl/elf32.em (gld${EMULATION_NAME}_after_open): Test
	unresolved_syms_in_shared_libs rather than !executable to
	determine whether to load DT_NEEDED libraries.
@
text
@d1486 1
a1486 1
  if (link_info.hash->type == bfd_link_elf_hash_table)
@


1.242
log
@	* ldlang.c (load_symbols): Report "error adding symbols" on
	bfd_link_add_symbols failure.
	* emultempl/elf32.em (gld${EMULATION_NAME}_try_needed): Likewise.
	* emultempl/sunos.em (gld${EMULATION_NAME}_after_open): Likewise.
	(gld${EMULATION_NAME}_try_needed): Likewise.
@
text
@d1181 1
a1181 3
	 found to be needed, then this lib isn't needed either.  Skip
	 the lib when creating a shared object unless we are copying
	 DT_NEEDED entres.  */
d1183 8
a1190 3
	  && ((bfd_elf_get_dyn_lib_class (l->by) & DYN_AS_NEEDED) != 0
	      || (!link_info.executable
		  && bfd_elf_get_dyn_lib_class (l->by) & DYN_NO_ADD_NEEDED) != 0))
@


1.241
log
@bfd/
	* elf-bfd.h (struct elf_build_id): Extracted from..
	(struct elf_build_id_info): ..here.  Delete.
	(struct output_elf_obj_tdata): New, extracted from..
	(struct elf_obj_tdata): ..here.  Reorganize for better packing.
	Add "o" field.
	(elf_program_header_size): Reference tdata->o.
	(elf_seg_map, elf_next_file_pos, elf_eh_frame_hdr, elf_linker,
	elf_stack_flags, elf_shstrtab, elf_strtab_sec, elf_shstrtab_sec,
	elf_section_syms, elf_num_section_syms, elf_flags_init): Likewise.
	* elf.c (bfd_elf_allocate_object): Allocate output_elf_obj_tdata
	when opening bfd in any mode that might write.
	(_bfd_elf_write_object_contents): Use build_id field in
	output_elf_obj_tdata.
	(_bfd_elf_close_and_cleanup): Tweak elf_shstrtab test.
	(elfobj_grok_gnu_build_id): Adjust for elf_tdata changes.
gdb/
	* elfread.c (build_id_bfd_get): Adjust for elf_tdata changes.
ld/
	* emultempl/elf32.em (write_build_id, setup_build_id): Adjust
	for elf_tdata changes.
@
text
@d450 1
a450 1
    einfo ("%F%B: could not read symbols: %E\n", abfd);
@


1.240
log
@include/
	* bfdlink.h (struct bfd_link_info): Delete emit_note_gnu_build_id.
bfd/
	* configure.in: Bump version to 2.23.52.
	* elf-bfd.h (struct elf_build_id_info): New.
	(struct elf_obj_tdata): Delete after_write_object_contents,
	after_write_object_contents_info and build_id_size.  Make build_id
	a pointer to struct elf_build_id_info.
	* elf.c (_bfd_elf_write_object_contents): Style.  Update
	after_write_ibject_contents invocation.
	(elfobj_grok_gnu_build_id): Update for new build_id struct.  Don't
	allow zero size notes.
	* configure: Regenerate.
gdb/
	* elfread.c (struct build_id): Delete.  Use struct elf_build_id
	throughout file instead.
	(build_id_bfd_get): Update to use new elf_tdata build_id field.
	Don't xmalloc return value.
	(build_id_verify): Similarly.  Don't xfree.
	(build_id_to_debug_filename): Update.
	(find_separate_debug_file_by_buildid): Update, don't xfree.
ld/
	* emultempl/elf32.em (emit_note_gnu_build_id): New static var.
	Replace all info->emit_note_gnu_build_id refs.
	(id_note_section_size): Rename from
	gld${EMULATION_NAME}_id_note_section_size.
	(struct build_id_info): Delete.
	(write_build_id): Rename from
	gld${EMULATION_NAME}_write_build_id_section.
	Update elf_tdata usage.  Style, formatting.
	(setup_build_id): New function.
	(gld${EMULATION_NAME}_after_open): Use setup_build_id.
@
text
@d963 2
a964 2
  style = t->build_id->u.o.style;
  asec = t->build_id->u.o.sec;
d1071 6
a1076 11
      t->build_id = bfd_alloc (link_info.output_bfd, sizeof (t->build_id->u.o));
      if (t->build_id != NULL)
	{
	  t->build_id->u.o.zero = 0;
	  t->build_id->u.o.after_write_object_contents = &write_build_id;
	  t->build_id->u.o.style = emit_note_gnu_build_id;
	  t->build_id->u.o.sec = s;
	  elf_section_type (s) = SHT_NOTE;
	  s->size = size;
	  return TRUE;
	}
@


1.239
log
@Revert 2013-02-04, 2013-01-22 and 2013-01-21 changes.
@
text
@d168 3
d896 1
a896 2
gld${EMULATION_NAME}_id_note_section_size (bfd *abfd,
					   struct bfd_link_info *linfo)
d898 1
a898 1
  const char *style = linfo->emit_note_gnu_build_id;
a948 6
struct build_id_info
{
  const char *style;
  asection *sec;
};

d950 1
a950 1
gld${EMULATION_NAME}_write_build_id_section (bfd *abfd)
d953 2
a954 2
  struct build_id_info *info = (struct build_id_info *)
    elf_tdata (abfd)->after_write_object_contents_info;
d959 1
d961 1
d963 2
a964 1
  asec = info->sec;
d993 1
a993 1
  if (!strcmp (info->style, "md5"))
d996 1
d998 1
a998 6
      if (bed->s->checksum_contents (abfd,
				     (void (*) (const void *, size_t, void *))
				     &md5_process_bytes,
				     &ctx))
	md5_finish_ctx (&ctx, id_bits);
      else
d1000 1
d1002 1
a1002 1
  else if (!strcmp (info->style, "sha1"))
d1005 1
d1007 1
a1007 6
      if (bed->s->checksum_contents (abfd,
				     (void (*) (const void *, size_t, void *))
				     &sha1_process_bytes,
				     &ctx))
	sha1_finish_ctx (&ctx, id_bits);
      else
d1009 1
d1011 1
a1011 1
  else if (!strcmp (info->style, "uuid"))
d1022 1
a1022 1
  else if (!strncmp (info->style, "0x", 2))
d1025 1
a1025 1
      const char *id = info->style + 2;
d1043 1
d1045 1
a1045 2
  return (bfd_seek (abfd,
		    i_shdr->sh_offset + asec->output_offset, SEEK_SET) == 0
d1049 39
d1103 1
a1103 1
  if (link_info.emit_note_gnu_build_id)
a1105 2
      asection *s;
      bfd_size_type size;
d1113 4
a1116 8
      if (abfd == NULL)
	{
	  /* PR 10555: If there are no input files do not
	     try to create a .note.gnu-build-id section.  */
	  free (link_info.emit_note_gnu_build_id);
	  link_info.emit_note_gnu_build_id = NULL;
	}
      else
d1118 2
a1119 35
	  size = gld${EMULATION_NAME}_id_note_section_size (abfd, &link_info);
	  if (size == 0)
	    {
	      einfo ("%P: warning: unrecognized --build-id style ignored.\n");
	      free (link_info.emit_note_gnu_build_id);
	      link_info.emit_note_gnu_build_id = NULL;
	    }
	  else
	    {
	      s = bfd_make_section_with_flags (abfd, ".note.gnu.build-id",
					       SEC_ALLOC | SEC_LOAD
					       | SEC_IN_MEMORY | SEC_LINKER_CREATED
					       | SEC_READONLY | SEC_DATA);
	      if (s != NULL && bfd_set_section_alignment (abfd, s, 2))
		{
		  struct elf_obj_tdata *t = elf_tdata (link_info.output_bfd);
		  struct build_id_info *b =
		      (struct build_id_info *) xmalloc (sizeof *b);

		  b->style = link_info.emit_note_gnu_build_id;
		  b->sec = s;
		  elf_section_type (s) = SHT_NOTE;
		  s->size = size;
		  t->after_write_object_contents
		    = &gld${EMULATION_NAME}_write_build_id_section;
		  t->after_write_object_contents_info = b;
		}
	      else
		{
		  einfo ("%P: warning: Cannot create .note.gnu.build-id section,"
			 " --build-id ignored.\n");
		  free (link_info.emit_note_gnu_build_id);
		  link_info.emit_note_gnu_build_id = NULL;
		}
	    }
d2188 1
a2188 1
      if (link_info.emit_note_gnu_build_id != NULL)
d2190 2
a2191 2
	  free (link_info.emit_note_gnu_build_id);
	  link_info.emit_note_gnu_build_id = NULL;
d2196 1
a2196 1
	link_info.emit_note_gnu_build_id = xstrdup (optarg);
@


1.238
log
@Don't enable new dtags by default with -rpath

ld/

2013-02-04  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/15096
	* emultempl/alphaelf.em (alpha_after_parse): Call
	gld${EMULATION_NAME}_after_parse instead of after_parse_default.
	* emultempl/cr16elf.em (cr16elf_after_parse): Likewise.
	* emultempl/crxelf.em (crxelf_after_parse): Likewise.
	* emultempl/hppaelf.em (hppaelf_after_parse): Likewise.
	* emultempl/mipself.em (mips_after_parse): Likewise.

	* emultempl/ia64elf.em (gld${EMULATION_NAME}_after_parse): Renamed
	to ...
	(gld_${EMULATION_NAME}_after_parse): This.  Call
	gld${EMULATION_NAME}_after_parse instead of after_parse_default.
	(LDEMUL_AFTER_PARSE): Set to gld_${EMULATION_NAME}_after_parse.

	* emultempl/elf32.em (new_dtags_set): New variable.
	(gld${EMULATION_NAME}_before_parse): Don't set link_info.new_dtags
	here.
	(gld${EMULATION_NAME}_after_parse): New function.
	(ld_${EMULATION_NAME}_emulation): Replace after_parse_default'
	with gld${EMULATION_NAME}_after_parse.
	(gld${EMULATION_NAME}_handle_option): Set new_dtags_set to TRUE
	when setting link_info.new_dtags.

ld/testsuite/

2013-02-04  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/15096
	* ld-elf/new-dtags-1.d: New test.
	* ld-elf/new-dtags-2.d: Likewise.
	* ld-elf/new-dtags-3.d: Likewise.
	* ld-elf/new-dtags-4.d: Likewise.
	* ld-elf/new-dtags-5.d: Likewise.
	* ld-elf/new-dtags-6.d: Likewise.
	* ld-elf/new-dtags-7.d: Likewise.
	* ld-elf/new-dtags-8.d: Likewise.
@
text
@a65 1
static void gld${EMULATION_NAME}_after_parse (void);
a72 9
if test x"$GENERATE_SHLIB_SCRIPT" = xyes; then
  fragment <<EOF

/* TRUE if link_info.new_dtags is set.  */
static bfd_boolean new_dtags_set;

EOF
fi

a112 29
fragment <<EOF
static void
gld${EMULATION_NAME}_after_parse (void)
{
EOF

if test x"$LDEMUL_AFTER_PARSE" != xgld"$EMULATION_NAME"_after_parse; then
# Enable the "new" dtags by default only for Linux target emulation if
# -rpath isn't used.
case ${target} in
  *-*-linux-* | *-*-k*bsd*-* | *-*-gnu* | *-*-nacl*)
    case " ${EMULATION_LIBPATH} " in
      *" ${EMULATION_NAME} "*)
fragment <<EOF
  if (!new_dtags_set && command_line.rpath == NULL) 
    link_info.new_dtags = TRUE;
EOF
      ;;
    esac
    ;;
esac

fragment <<EOF
  after_parse_default ();
}

EOF
fi

a1318 1
    # Linux
d1324 1
a2219 1
      new_dtags_set = TRUE;
a2223 1
      new_dtags_set = TRUE;
d2508 1
a2508 1
  ${LDEMUL_AFTER_PARSE-gld${EMULATION_NAME}_after_parse},
@


1.237
log
@ld/
	* emultempl/elf32.em (gld${EMULATION_NAME}_before_parse): Set
	new_dtags to TRUE for *-*-nacl* targets.
@
text
@d66 1
d74 9
d118 2
d121 1
d123 9
d134 5
a138 2
    fragment <<EOF
  link_info.new_dtags = TRUE;
d140 2
d144 1
d146 1
d2259 1
d2264 1
d2549 1
a2549 1
  ${LDEMUL_AFTER_PARSE-after_parse_default},
@


1.236
log
@ld: enable new dtags by default for linux/gnu targets

The "new" dtags options have been around for 14+ years now, so for Linux
and GNU targets, enable them by default.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d16 1
a16 1
   2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012
d111 1
a111 1
  *-*-linux-* | *-*-k*bsd*-* | *-*-gnu*)
@


1.235
log
@	* emultempl/elf32.em (gld${EMULATION_NAME}_check_ld_so_conf): Replace
	"name" param with a bfd_link_needed_list pointer.  Update caller.
	(gld${EMULATION_NAME}_check_ld_elf_hints): Likewise.
@
text
@d108 10
@


1.234
log
@Extend --copy-dt-needed-entries to creating DSO

ld/

	PR ld/14915
	* emultempl/elf32.em (gld${EMULATION_NAME}_after_open): Also
	check DT_NEEDED entries when creating shared object with
	--copy-dt-needed-entries.

ld/testsuite/

	PR ld/14915
	* ld-elf/shared.exp (build_tests): Test --add-needed,
	--copy-dt-needed-entries, --no-add-needed and
	--no-copy-dt-needed-entries with -shared.
	Add tests for --no-add-needed and --no-copy-dt-needed-entries
	with -shared.
@
text
@d572 2
a573 1
gld${EMULATION_NAME}_check_ld_elf_hints (const char *name, int force)
d616 3
a618 4
  needed.by = NULL;
  needed.name = name;
  return gld${EMULATION_NAME}_search_needed (ld_elf_hints, & needed,
					     force);
d790 2
a791 1
gld${EMULATION_NAME}_check_ld_so_conf (const char *name, int force)
d828 2
a829 2
  needed.by = NULL;
  needed.name = name;
d1312 1
a1312 1
	  if (gld${EMULATION_NAME}_check_ld_elf_hints (l->name, force))
d1321 1
a1321 1
	  if (gld${EMULATION_NAME}_check_ld_so_conf (l->name, force))
@


1.233
log
@ld/
	* ld.h (ld_config_type): New flag member separate_code.
	* emultempl/elf32.em
	(gld${EMULATION_NAME}_before_parse): Set it based on $SEPARATE_CODE.
	* ldlang.c (ldlang_override_segment_assignment): If it's set, then
	always return TRUE when SEC_CODE differs between the sections.
@
text
@a1183 2
  if (!link_info.executable)
    return;
d1192 3
a1194 1
	 found to be needed, then this lib isn't needed either.  */
d1196 3
a1198 1
	  && (bfd_elf_get_dyn_lib_class (l->by) & DYN_AS_NEEDED) != 0)
@


1.232
log
@Implement ELF linker -z global option

ld/

	* ld.texinfo: Document "-z global".

	* emultempl/elf32.em (gld${EMULATION_NAME}_handle_option): Support
	"-z global".
	(gld${EMULATION_NAME}_list_options): Likewise.

ld/testsuite/

	* ld-elf/global1.d: New file.
@
text
@d107 1
d144 1
a144 1
                             (enum dynamic_lib_link_class) link_class);
d1108 1
a1108 1
                      (struct build_id_info *) xmalloc (sizeof *b);
d1443 1
a1443 1
static void 
d1511 1
a1511 1
	/* If the input bfd contains an audit entry, we need to add it as 
d2208 1
a2208 1
  	gld${EMULATION_NAME}_append_to_separated_string (&audit, optarg); 
d2397 1
a2397 1
                              Specify a library to use for auditing dependencies\n"));
d2426 1
a2426 1
                               loaded objects\n"));
d2473 1
a2473 1
                                processing at runtime\n"));
@


1.231
log
@	* emultempl/elf32.em: Print stacksize help.
@
text
@d2303 2
d2424 3
@


1.230
log
@	bfd/
	* bfd-in.h (bfd_elf_stack_segment_size): Declare.
	* bfd-in2.h: Rebuilt.
	* elfxx-target.h (elf_backend_stack_align): New.
	(elfNN_bed): Add it.
	* elf-bfd.h (struct elf_backend_data): Add stack_align field.
	* elf.c (bfd_elf_map_sections_to_segments): Pay attention to
	stack_align and stacksize for PT_GNU_STACK segment.
	(assign_file_positions_for_non_load_sections): Set p_memsz for
	PT_GNU_STACK segment.
	(copy_elf_program_header): Copy PT_GNU_STACK size.
	* elflink.c (bfd_elf_stack_segment_size): New function, taken from
	uclinux backends.
	(bfd_elf_size_dynamic_sections): Determine
	PT_GNU_STACK requirements after calling backend.  Pay attention to
	stacksize.
	* elf32-bfin.c (elf32_bfinfdpic_always_size_sections): Call
	bfd_elf_stack_segment_size.
	(elf32_bfinfdpic_modify_program_headers): Delete.
	(elf32_bfingfdpic_copy_private_bfd_data): Don't copy PT_GNU_STACK
	here.
	(elf_backend_stack_align): Override.
	(elf_backend_modify_program_headers): Don't override.
	* elf32-frv.c (frvfdpic_always_size_sections): Call
	bfd_elf_stack_segment_size.
	(elf32_frvfdpic_modify_program_headers): Delete.
	(elf32_frvfdpic_copy_private_bfd_data): Don't copy PT_GNU_STACK
	here.
	(elf_backend_stack_align): Override.
	(elf_backend_modify_program_headers): Don't override.
	* elf32-lm32.c (lm32_elf_always_size_sections): Leave
	PT_GNU_STACK creation to underlying elf support.  Check
	__stacksize here for backwards compatibility, and set it if
	needed.
	(lm32_elf_modify_segment_map): Delete.
	(lm32_elf_modify_program_headers): Delete.
	(elf_backend_stack_align): Override.
	(elf_backend_modify_segment_map): Don't override.
	(elf_backend_modify_program_headers): Don't override.
	* elf32-sh.c (sh_elf_always_size_sections): Call
	bfd_elf_stack_segment_size.
	(sh_elf_modify_program_headers): Delete.
	(sh_elf_copy_private_data): Don't copy PT_GNU_STACK
	here.
	(elf_backend_stack_align): Override.
	(elf_backend_modify_program_headers): Don't override.
	* elf32-tic6x.c (elf32_tic6x_always_size_sections): Call
	bfd_elf_stack_segment_size.
	(elf32_tic6x_modify_program_headers): Delete.
	(elf32_tic6x_copy_private_data): Delete.
	(elf_backend_stack_align): Override.
	(bfd_elf32_bfd_copy_private_bfd_data): Don't override.
	(elf_backend_modify_program_headers): Don't override.

	include/
	* bfdlink.h (struct bfd_link_info): Add stacksize option.

	ld/
	* ld.texinfo (stack-size): New option.
	* emultempl/elf32.em: Add stack-size option.

	ld/testsuite/
	* ld-elf/binutils.exp: Add -z stack-size=0.
	* ld-elf/elf.exp: Add stack-exec and stack-size tests.
	* ld-elf/orphan-region.d: Add stack-size option. Remove xfail.
	* ld-elf/stack-exec.rd: New.
	* ld-elf/stack-size.rd: New.
	* ld-elf/stack.s: New.
	* ld-scripts/empty-aligned.d: Add stack-size option.
	* ld-sh/fdpic-stack-set.d: New.
	* ld-tic6x/shlib-1.rd: Remove __stacksize symbol.
	* ld-tic6x/shlib-1b.rd: Likewise.
	* ld-tic6x/shlib-1r.rd: Likewise.
	* ld-tic6x/shlib-1rb.rd: Likewise.
	* ld-tic6x/shlib-app-1.rd: Likewise.
	* ld-tic6x/shlib-app-1b.rd: Likewise.
	* ld-tic6x/shlib-app-1r.rd: Likewise.
	* ld-tic6x/shlib-app-1rb.rd: Likewise.
	* ld-tic6x/shlib-noindex.rd: Likewise.
	* ld-tic6x/static-app-1.rd: Likewise.
	* ld-tic6x/static-app-1b.rd: Likewise.
	* ld-tic6x/static-app-1r.rd: Likewise.
	* ld-tic6x/static-app-1rb.rd: Likewise.
@
text
@d2470 2
@


1.229
log
@	PR ld/14357
	* ldmain.c (trace_file_tries): Rename to 'verbose'.
	* ldfile.c: Likewise.
	* ldlang.c: Likewise.
	* ldmain.h: Likewise.
	* lexsup.c: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultemp/spuelf.em: Likewise.
	* pe-dll.c (pe_dll_generate_implib): Only print creation message
	in verbose mode.
@
text
@d2279 11
@


1.229.2.1
log
@ld/
	* ld.h (ld_config_type): New flag member separate_code.
	* emultempl/elf32.em
	(gld${EMULATION_NAME}_before_parse): Set it based on $SEPARATE_CODE.
	* ldlang.c (ldlang_override_segment_assignment): If it's set, then
	always return TRUE when SEC_CODE differs between the sections.
@
text
@a106 1
  config.separate_code = `if test "x${SEPARATE_CODE}" = xyes ; then echo TRUE ; else echo FALSE ; fi`;
d143 1
a143 1
			     (enum dynamic_lib_link_class) link_class);
d1107 1
a1107 1
		      (struct build_id_info *) xmalloc (sizeof *b);
d1442 1
a1442 1
static void
d1510 1
a1510 1
	/* If the input bfd contains an audit entry, we need to add it as
d2207 1
a2207 1
	gld${EMULATION_NAME}_append_to_separated_string (&audit, optarg);
d2383 1
a2383 1
			      Specify a library to use for auditing dependencies\n"));
d2456 1
a2456 1
				processing at runtime\n"));
@


1.229.2.2
log
@	PR 12549
	PR 14493
	PR 14567
	PR 14662
	PR 14758
	PR 14813
	PR 14904
	PR 14915
	PR 14926
	PR 14950
	PR 14962
	Apply mainline patches
@
text
@d572 1
a572 2
gld${EMULATION_NAME}_check_ld_elf_hints (const struct bfd_link_needed_list *l,
					 int force)
d615 4
a618 3
  needed.by = l->by;
  needed.name = l->name;
  return gld${EMULATION_NAME}_search_needed (ld_elf_hints, &needed, force);
d790 1
a790 2
gld${EMULATION_NAME}_check_ld_so_conf (const struct bfd_link_needed_list *l,
				       int force)
d827 2
a828 2
  needed.by = l->by;
  needed.name = l->name;
d1184 2
d1194 1
a1194 3
	 found to be needed, then this lib isn't needed either.  Skip
	 the lib when creating a shared object unless we are copying
	 DT_NEEDED entres.  */
d1196 1
a1196 3
	  && ((bfd_elf_get_dyn_lib_class (l->by) & DYN_AS_NEEDED) != 0
	      || (!link_info.executable
		  && bfd_elf_get_dyn_lib_class (l->by) & DYN_NO_ADD_NEEDED) != 0))
d1309 1
a1309 1
	  if (gld${EMULATION_NAME}_check_ld_elf_hints (l, force))
d1318 1
a1318 1
	  if (gld${EMULATION_NAME}_check_ld_so_conf (l, force))
@


1.228
log
@	PR ld/13909
	* emultempl/elf32.em (gld${EMULATION_NAME}_after_open): Handle
	multiple .eh_frame sections attached to bfd.
@
text
@d415 1
a415 1
  if (trace_file_tries)
d1219 1
a1219 1
      if (trace_file_tries)
@


1.227
log
@	PR ld/14069
	* emultempl/elf32.em: Include *-*-gnu* targets in ld.so.conf
	support.
@
text
@d1145 5
a1149 4
	      warn_eh_frame
		= (s
		   && s->size > 8
		   && !bfd_is_abs_section (s->output_section));
@


1.226
log
@
Add support for PowerPC VLE.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	* NEWS:  Mention PowerPC VLE port.

2012-05-14  James Lemke <jwlemke@@codesourcery.com>
	    Catherine Moore  <clm@@codesourcery.com>

	bfd/
	* bfd.c (bfd_lookup_section_flags): Add section parm.
	* ecoff.c (bfd_debug_section): Remove flag_info initializer.
	* elf-bfd.h (bfd_elf_section_data): Move in section_flag_info.
	(bfd_elf_lookup_section_flags): Add section parm.
	* elf32-ppc.c (is_ppc_vle): New function.
	(ppc_elf_modify_segment_map): New function.
	(elf_backend_modify_segment_map): Define.
	(has_vle_insns): New define.
	* elf32-ppc.h (ppc_elf_modify_segment_map): Declare.
	* elflink.c (bfd_elf_lookup_section_flags): Add return value & parm.
	Move in logic to omit / include a section.
	* libbfd-in.h (bfd_link_info): Add section parm.
	(bfd_generic_lookup_section_flags): Likewise.
	* reloc.c (bfd_generic_lookup_section_flags): Likewise.
	* section.c (bfd_section): Move out section_flag_info.
	(BFD_FAKE_SECTION): Remove flag_info initializer.
	* targets.c (_bfd_lookup_section_flags): Add section parm.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	bfd/
	* archures.c (bfd_mach_ppc_vle): New.
	* bfd-in2.h: Regenerated.
	* cpu-powerpc.c (bfd_powerpc_archs): New entry for vle.
	* elf32-ppc.c (split16_format_type): New enumeration.
	(ppc_elf_vle_split16): New function.
	(HOWTO): Add entries for R_PPC_VLE relocations.
	(ppc_elf_reloc_type_lookup): Handle PPC_VLE relocations.
	(ppc_elf_section_flags): New function.
	(ppc_elf_lookup_section_flags): New function.
	(ppc_elf_section_processing): New function.
	(ppc_elf_check_relocs): Handle PPC_VLE relocations.
	(ppc_elf_relocation_section): Likewise.
	(elf_backend_lookup_section_flags_hook): Define.
	(elf_backend_section_flags): Define.
	(elf_backend_section_processing): Define.
	* elf32-ppc.h (ppc_elf_section_processing): Declare.
	* libbfd.h: Regenerated.
	* reloc.c (BFD_RELOC_PPC_VLE_REL8, BFD_RELOC_PPC_VLE_REL15,
	BFD_RELOC_PPC_VLE_REL24, BFD_RELOC_PPC_VLE_LO16A,
	BFD_RELOC_PPC_VLE_LO16D, BFD_RELOC_PPC_VLE_HI16A,
	BFD_RELOC_PPC_VLE_HI16D, BFD_RELOC_PPC_VLE_HA16A,
	BFD_RELOC_PPC_VLE_HA16D, BFD_RELOC_PPC_VLE_SDA21,
	BFD_RELOC_PPC_VLE_SDA21_LO, BFD_RELOC_PPC_VLE_SDAREL_LO16A,
	BFD_RELOC_PPC_VLE_SDAREL_LO16D, BFD_RELOC_PPC_VLE_SDAREL_HI16A,
	BFD_RELOC_PPC_VLE_SDAREL_HI16D, BFD_RELOC_PPC_VLE_SDAREL_HA16A,
	BFD_RELOC_PPC_VLE_SDAREL_HA16D): New bfd relocations.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	gas/
	* config/tc-ppc.c (insn_validate): New func of existing code to call..
	(ppc_setup_opcodes): ..from 2 places here.
	Revise for second (VLE) opcode table.
	Add #ifdef'd code to print opcode tables.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	gas/
	* config/tc-ppc.c (ppc_setup_opcodes): Allow out-of-order
	for the VLE conditional branches.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>
	    Rhonda Wittels  <rhonda@@codesourcery.com>

	gas/
	* config/tc-ppc.c (PPC_VLE_SPLIT16A): New macro.
	(PPC_VLE_SPLIT16D): New macro.
	(PPC_VLE_LO16A): New macro.
	(PPC_VLE_LO16D): New macro.
	(PPC_VLE_HI16A): New macro.
	(PPC_VLE_HI16D): New macro.
	(PPC_VLE_HA16A): New macro.
	(PPC_VLE_HA16D): New macro.
	(PPC_APUINFO_VLE): New definition.
	(md_chars_to_number): New function.
	(md_parse_option): Check for combinations of little
	endian and -mvle.
	(md_show_usage): Document -mvle.
	(ppc_arch): Recognize VLE.
	(ppc_mach): Recognize bfd_mach_ppc_vle.
	(ppc_setup_opcodes): Print the opcode table if
	* config/tc-ppc.h (ppc_frag_check): Declare.
	* doc/c-ppc.texi: Document -mvle.
	* NEWS:  Mention PowerPC VLE port.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	gas/
	* config/tc-ppc.h (ppc_dw2_line_min_insn_length): Declare.
	(DWARF2_LINE_MIN_INSN_LENGTH): Redefine.
	* config/tc-ppc.c (ppc_dw2_line_min_insn_length): New.
	* dwarf2dbg.c (scale_addr_delta): Handle values of 1
	for DWARF2_LINE_MIN_INSN_LENGTH.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>
	    Rhonda Wittels  <rhonda@@codesourcery.com>

	gas/testsuite/
	* gas/ppc/ppc.exp: Run new tests.
	* gas/ppc/vle-reloc.d: New test.
	* gas/ppc/vle-reloc.s: New test.
	* gas/ppc/vle-simple-1.d: New test.
	* gas/ppc/vle-simple-1.s: New test.
	* gas/ppc/vle-simple-2.d: New test.
	* gas/ppc/vle-simple-2.s: New test.
	* gas/ppc/vle-simple-3.d: New test.
	* gas/ppc/vle-simple-3.s: New test.
	* gas/ppc/vle-simple-4.d: New test.
	* gas/ppc/vle-simple-4.s: New test.
	* gas/ppc/vle-simple-5.d: New test.
	* gas/ppc/vle-simple-5.s: New test.
	* gas/ppc/vle-simple-6.d: New test.
	* gas/ppc/vle-simple-6.s: New test.
	* gas/ppc/vle.d: New test.
	* gas/ppc/vle.s: New test.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>
	include/elf/
	* ppc.h (SEC_PPC_VLE): Remove.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
	    James Lemke  <jwlemke@@codesourcery.com>

	include/elf/
	* ppc.h (R_PPC_VLE_REL8): New reloction.
	(R_PPC_VLE_REL15): Likewise.
	(R_PPC_VLE_REL24): Likewise.
	(R_PPC_VLE_LO16A): Likewise.
	(R_PPC_VLE_LO16D): Likewise.
	(R_PPC_VLE_HI16A): Likewise.
	(R_PPC_VLE_HI16D): Likewise.
	(R_PPC_VLE_HA16A): Likewise.
	(R_PPC_VLE_HA16D): Likewise.
	(R_PPC_VLE_SDA21): Likewise.
	(R_PPC_VLE_SDA21_LO): Likewise.
	(R_PPC_VLE_SDAREL_LO16A): Likewise.
	(R_PPC_VLE_SDAREL_LO16D): Likewise.
	(R_PPC_VLE_SDAREL_HI16A): Likewise.
	(R_PPC_VLE_SDAREL_HI16D): Likewise.
	(R_PPC_VLE_SDAREL_HA16A): Likewise.
	(R_PPC_VLE_SDAREL_HA16D): Likewise.
	(SEC_PPC_VLE): Remove.
	(PF_PPC_VLE): New program header flag.
	(SHF_PPC_VLE): New section header flag.
	(vle_opcodes, vle_num_opcodes): New.
	(VLE_OP): New macro.
	(VLE_OP_TO_SEG): New macro.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>
	    Rhonda Wittels  <rhonda@@codesourcery.com>

	include/opcode/
	* ppc.h (PPC_OPCODE_VLE): New definition.
	(PPC_OP_SA): New macro.
	(PPC_OP_SE_VLE): New macro.
	(PPC_OP): Use a variable shift amount.
	(powerpc_operand): Update comments.
	(PPC_OPSHIFT_INV): New macro.
	(PPC_OPERAND_CR): Replace with...
	(PPC_OPERAND_CR_BIT): ...this and
	(PPC_OPERAND_CR_REG): ...this.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	ld/
	* ldlang.c (walk_wild_consider_section): Don't copy section_flag_list.
	Pass it to callback.
	(walk_wild_section_general): Pass section_flag_list to callback.
	(lang_add_section): Add sflag_list parm.
	Move out logic to keep / omit a section & call bfd_lookup_section_flags.
	(output_section_callback_fast): Add sflag_list parm.
	Add new parm to lang_add_section calls.
	(output_section_callback): Likewise.
	(check_section_callback): Add sflag_list parm.
	(lang_place_orphans): Add new parm to lang_add_section calls.
	(gc_section_callback): Add sflag_list parm.
	(find_relro_section_callback): Likewise.
	* ldlang.h (callback_t): Add flag_info parm.
	(lang_add_section): Add sflag_list parm.
	* emultempl/armelf.em (elf32_arm_add_stub_section):
	Add lang_add_section parm.
	* emultempl/beos.em (gld*_place_orphan): Likewise.
	* emultempl/elf32.em (gld*_place_orphan): Likewise.
	* emultempl/hppaelf.em (hppaelf_add_stub_section): Likewise.
	* emultempl/m68hc1xelf.em (m68hc11elf_add_stub_section): Likewise.
	* emultempl/mipself.em (mips_add_stub_section): Likewise.
	* emultempl/mmo.em (mmo_place_orphan): Likewise.
	* emultempl/pe.em (gld_*_place_orphan): Likewise.
	* emultempl/pep.em (gld_*_place_orphan): Likewise.
	* emultempl/ppc64elf.em (ppc_add_stub_section): Likewise.
	* emultempl/spuelf.em (spu_place_special_section): Likewise.
	* emultempl/vms.em (vms_place_orphan): Likewise.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	ld/testsuite/
	* ld-powerpc/powerpc.exp: Create ppceabitests.
	* ld-powerpc/vle-multiseg.s: New.
	* ld-powerpc/vle-multiseg-1.d: New.
	* ld-powerpc/vle-multiseg-1.ld: New.
	* ld-powerpc/vle-multiseg-2.d: New.
	* ld-powerpc/vle-multiseg-2.ld: New.
	* ld-powerpc/vle-multiseg-3.d: New.
	* ld-powerpc/vle-multiseg-3.ld: New.
	* ld-powerpc/vle-multiseg-4.d: New.
	* ld-powerpc/vle-multiseg-4.ld: New.
	* ld-powerpc/vle-multiseg-5.d: New.
	* ld-powerpc/vle-multiseg-5.ld: New.
	* ld-powerpc/vle-multiseg-6.d: New.
	* ld-powerpc/vle-multiseg-6.ld: New.
	* ld-powerpc/vle-multiseg-6a.s: New.
	* ld-powerpc/vle-multiseg-6b.s: New.
	* ld-powerpc/vle-multiseg-6c.s: New.
	* ld-powerpc/vle-multiseg-6d.s: New.
	* ld-powerpc/powerpc.exp: Run new tests.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	ld/
	* NEWS:  Mention PowerPC VLE port.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	ld/testsuite/
	* ld-powerpc/apuinfo.rd: Update for VLE.
	* ld-powerpc/vle-reloc-1.d: New.
	* ld-powerpc/vle-reloc-1.s: New.
	* ld-powerpc/vle-reloc-2.d: New.
	* ld-powerpc/vle-reloc-2.s: New.
	* ld-powerpc/vle-reloc-3.d: New.
	* ld-powerpc/vle-reloc-3.s: New.
	* ld-powerpc/vle-reloc-def-1.s: New.
	* ld-powerpc/vle-reloc-def-2.s: New.
	* ld-powerpc/vle-reloc-def-3.s: New.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	opcodes/
	* ppc-dis.c (get_powerpc_dialect): Use is_ppc_vle.
	(PPC_OPCD_SEGS, VLE_OPCD_SEGS): New defines.
	(vle_opcd_indices): New array.
	(lookup_vle): New function.
	(disassemble_init_powerpc): Revise for second (VLE) opcode table.
	(print_insn_powerpc): Likewise.
	* ppc-opc.c: Likewise.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>
	    Rhonda Wittels  <rhonda@@codesourcery.com>
	    Nathan Froyd <froydnj@@codesourcery.com>

	opcodes/
	* ppc-opc.c (insert_arx, extract_arx): New functions.
	(insert_ary, extract_ary): New functions.
	(insert_li20, extract_li20): New functions.
	(insert_rx, extract_rx): New functions.
	(insert_ry, extract_ry): New functions.
	(insert_sci8, extract_sci8): New functions.
	(insert_sci8n, extract_sci8n): New functions.
	(insert_sd4h, extract_sd4h): New functions.
	(insert_sd4w, extract_sd4w): New functions.
	(insert_vlesi, extract_vlesi): New functions.
	(insert_vlensi, extract_vlensi): New functions.
	(insert_vleui, extract_vleui): New functions.
	(insert_vleil, extract_vleil): New functions.
 	(BI_MASK, BB_MASK, BT): Use PPC_OPERAND_CR_BIT.
 	(BI16, BI32, BO32, B8): New.
	(B15, B24, CRD32, CRS): New.
 	(CRD, OBF, BFA, CR, CRFS): Use PPC_OPERAND_CR_REG.
	(DB, IMM20, RD, Rx, ARX, RY, RZ): New.
	(ARY, SCLSCI8, SCLSCI8N, SE_SD, SE_SDH): New.
	(SH6_MASK): Use PPC_OPSHIFT_INV.
	(SI8, UI5, OIMM5, UI7, BO16): New.
	(VLESIMM, VLENSIMM, VLEUIMM, VLEUIMML): New.
	(XT6, XA6, XB6, XB6S, XC6): Use PPC_OPSHIFT_INV.
	(ALLOW8_SPRG): New.
	(insert_sprg, extract_sprg): Check ALLOW8_SPRG.
	(OPVUP, OPVUP_MASK OPVUP): New
	(BD8, BD8_MASK, BD8IO, BD8IO_MASK): New.
	(EBD8IO, EBD8IO1_MASK, EBD8IO2_MASK, EBD8IO3_MASK): New.
	(BD15, BD15_MASK, EBD15, EBD15_MASK, EBD15BI, EBD15BI_MASK): New.
	(BD24,BD24_MASK, C_LK, C_LK_MASK, C, C_MASK): New.
 	(IA16, IA16_MASK, I16A, I16A_MASK, I16L, I16L_MASK): New.
	(IM7, IM7_MASK, LI20, LI20_MASK, SCI8, SCI8_MASK): New.
	(SCI8BF, SCI8BF_MASK, SD4, SD4_MASK): New.
	(SE_IM5, SE_IM5_MASK): New.
	(SE_R, SE_R_MASK, SE_RR, SE_RR_MASK): New.
	(EX, EX_MASK, BO16F, BO16T, BO32F, BO32T): New.
	(BO32DNZ, BO32DZ): New.
	(NO371, PPCSPE, PPCISEL, PPCEFS, MULHW): Include PPC_OPCODE_VLE.
	(PPCVLE): New.
	(powerpc_opcodes): Add new VLE instructions.  Update existing
	instruction to include PPCVLE if supported.
	* ppc-dis.c (ppc_opts): Add vle entry.
	(get_powerpc_dialect): New function.
	(powerpc_init_dialect): VLE support.
	(print_insn_big_powerpc): Call get_powerpc_dialect.
	(print_insn_little_powerpc): Likewise.
	(operand_value_powerpc): Handle negative shift counts.
	(print_insn_powerpc): Handle 2-byte instruction lengths.
@
text
@d75 1
a75 1
    *-*-linux-* | *-*-k*bsd*-*)
d377 1
a377 1
  *-*-linux-* | *-*-k*bsd*-*)
d623 1
a623 1
    *-*-linux-* | *-*-k*bsd*-*)
d1313 1
a1313 1
    *-*-linux-* | *-*-k*bsd*-*)
@


1.225
log
@	* ldlang.h (struct lang_input_statement_flags): New, extract from..
	(lang_input_statement_type): ..here.  New field "flags".
	(input_flags): Declare.
	(missing_file): Delete.
	* ldmain.h (whole_archive): Delete.
	(add_DT_NEEDED_for_regular, add_DT_NEEDED_for_dynamic): Delete.
	* ld.h (ld_config_type <dynamic_link>): Delete.
	* ldmain.c (whole_archive): Delete.
	(add_DT_NEEDED_for_regular, add_DT_NEEDED_for_dynamic): Delete.
	* ldlang.c (missing_file, ldlang_sysrooted_script): Delete.
	(input_flags): New variable.  Replace all uses of config.dynamic_link,
	missing_file, ldlang_sysrooted_script, whole_archive,
	add_DT_NEEDED_for_regular and add_DT_NEEDED_for_dynamic with fields
	from here.
	* ldfile.c: Likewise.
	* ldgram.y: Likewise.
	* ldmain.c: Likewise.
	* ldwrite.c: Likewise.
	* lexsup.c: Likewise.
	* plugin.c: Likewise.
	* emultempl/aix.em: Likewise.
	* emultempl/armelf.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/scoreelf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/vms.em: Likewise.
	* ldlang.c (new_afile): Use memset to init zero fields.
	(load_symbols): Simplify save and restore of flags around command
	file processing.
	* ldfile.c (is_sysrooted_pathname): Tidy.
@
text
@d1864 1
a1864 1
	    lang_add_section (&os->children, s, os);
d1878 1
a1878 1
      lang_add_section (&match_by_name->children, s, match_by_name);
d1904 1
a1904 1
      lang_add_section (&os->children, s, os);
@


1.224
log
@	PR ld/13254
include/
	* bfdlink.h (struct bfd_link_info): Add error_textrel.
bfd/
	* elflink.c (bfd_elf_final_link): Emit error_textrel error.
ld/
	* emultempl/elf32.em (gld${EMULATION_NAME}_handle_option): Add
	-z text, -z notext, -z textoff options for all targets having
	shared lib support.
@
text
@d16 1
a16 1
   2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
d105 1
a105 1
  config.dynamic_link = ${DYNAMIC_LINK-TRUE};
d124 1
a124 1
  if (entry->add_DT_NEEDED_for_regular)
d130 1
a130 1
  if (!entry->add_DT_NEEDED_for_dynamic)
d133 1
a133 1
  if (entry->just_syms_flag
d865 1
a865 1
  if (s->search_dirs_flag)
d1563 1
a1563 1
	if (is->just_syms_flag)
d1624 1
a1624 1
  if (! entry->maybe_archive)
d1678 1
a1678 1
      ASSERT (entry->maybe_archive && entry->search_dirs_flag);
@


1.223
log
@Check if a symbol is hidden by linker script.

bfd/

2011-09-15  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12975
	* bfd-in.h (bfd_elf_size_dynamic_sections): Remove pointer
	to struct bfd_elf_version_tree.

	* elflink.c (elf_info_failed): Remove verdefs.
	(_bfd_elf_export_symbol): Updated.
	_bfd_elf_link_assign_sym_version): Likewise.
	(bfd_elf_size_dynamic_sections): Remove pointer to struct
	bfd_elf_version_tree.  Updated.
	(bfd_elf_gc_mark_dynamic_ref_symbol): Check if a symbol is hidden
	by linker script.

	* linker.c (bfd_hide_sym_by_version): New.

	* bfd-in2.h: Regenerated.

include/

2011-09-15  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12975
	* bfdlink.h (bfd_link_info): Add version_info.

ld/

2011-09-15  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12975
	* ldlang.c (lang_elf_version_info): Removed.
	(lang_register_vers_node): Replace lang_elf_version_info with
	link_info.version_info.
	(lang_add_vers_depend): Likewise.
	* pe-dll.c (process_def_file_and_drectve): Likewise.
	* emultempl/solaris2.em (elf_solaris2_before_allocation): Likewise.

	* ldlang.h (lang_elf_version_info): Removed.

	* plugin.c  (is_visible_from_outside): Check if symbol is hidden
	by version script.

	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation):
	Remove lang_elf_version_info.

ld/testsuite/

2011-09-15  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/12975
	* ld-elf/pr12975.d: New.
	* ld-elf/pr12975.s: Likewise.
	* ld-elf/pr12975.t: Likewise.
@
text
@d2330 6
@


1.223.2.1
log
@	PR ld/13254
include/
	2011-10-19  Alan Modra  <amodra@@gmail.com>
	* bfdlink.h (struct bfd_link_info): Add error_textrel.
bfd/
	2011-10-19  Alan Modra  <amodra@@gmail.com>
	* elflink.c (bfd_elf_final_link): Emit error_textrel error.
ld/
	2011-10-19  Alan Modra  <amodra@@gmail.com>
	* emultempl/elf32.em (gld${EMULATION_NAME}_handle_option): Add
	-z text, -z notext, -z textoff options for all targets having
	shared lib support.
@
text
@a2329 6
      else if (strcmp (optarg, "text") == 0)
	link_info.error_textrel = TRUE;
      else if (strcmp (optarg, "notext") == 0)
	link_info.error_textrel = FALSE;
      else if (strcmp (optarg, "textoff") == 0)
	link_info.error_textrel = FALSE;
@


1.222
log
@	* emultempl/elf32.em (gld${EMULATION_NAME}_handle_option,
	gld${EMULATION_NAME}_list_options): Don't condition -z relro
	and -z norelro on COMMONPAGESIZE being defined.
@
text
@d1538 1
a1538 1
	  &link_info, &sinterp, lang_elf_version_info)))
@


1.221
log
@	* emultempl/elf32.em (gld${EMULATION_NAME}_add_options,
	gld${EMULATION_NAME}_handle_option, gld${EMULATION_NAME}_list_options):
	Provide --build-id, -z defs, -z muldefs, -z max-page-size,
	-z common-page-size, -z execstack, -z noexecstack for all targets.
	Add help for --exclude-libs.
	(OPTION_LD_GENERATED_UNWIND_INFO,
	OPTION_NO_LD_GENERATED_UNWIND_INFO): Move this..
	(gld${EMULATION_NAME}_handle_option): ..and code handling
	--ld-generated-unwind-info and --no-ld-generated-unwind-info..
	* emulparams/plt_unwind.sh: ..to here.  New file.  Add help.
	* emulparams/elf32_x86_64.sh: Include plt_unwind.sh.
	* emulparams/elf_i386.sh: Likewise.
	* emulparams/elf_i386_chaos.sh: Likewise.
	* emulparams/elf_i386_ldso.sh: Likewise.
	* emulparams/elf_l1om.sh: Likewise.
	* emulparams/elf_x86_64.sh: Likewise.
@
text
@a2325 4
EOF

  if test -n "$COMMONPAGESIZE"; then
fragment <<EOF
a2330 1
  fi
a2441 1
  if test -n "$COMMONPAGESIZE"; then
a2444 4
EOF
  fi

fragment <<EOF
a2449 4
EOF

  if test -n "$COMMONPAGESIZE"; then
fragment <<EOF
a2452 1
  fi
@


1.220
log
@	PR ld/12570
include/
	* bfdlink.h (struct bfd_link_info): Add no_ld_generated_unwind_info
	option.
ld/
	* emultempl/elf32.em (OPTION_LD_GENERATED_UNWIND_INFO,
	OPTION_NO_LD_GENERATED_UNWIND_INFO): Define.
	(gld${EMULATION_NAME}_handle_option): Handle
	--ld-generated-unwind-info and --no-ld-generated-unwind-info.
	* ld.texinfo (--ld-generated-unwind-info,
	--no-ld-generated-unwind-info): Document.
bfd/
	* elf-eh-frame.c (_bfd_elf_parse_eh_frame): Allow no relocations
	at all for linker created .eh_frame sections.
	(_bfd_elf_discard_section_eh_frame): Handle linker created
	.eh_frame sections with no relocations.
	* elf64-x86-64.c: Include dwarf2.h.
	(elf_x86_64_eh_frame_plt): New variable.
	(PLT_CIE_LENGTH, PLT_FDE_LENGTH, PLT_FDE_START_OFFSET,
	PLT_FDE_LEN_OFFSET): Define.
	(struct elf_x86_64_link_hash_table): Add plt_eh_frame field.
	(elf_x86_64_create_dynamic_sections): Create and fill in
	.eh_frame section for .plt section.
	(elf_x86_64_size_dynamic_sections): Write .plt section size
	into .eh_frame FDE covering .plt section.
	(elf_x86_64_finish_dynamic_sections): Write .plt section
	start into .eh_frame FDE covering .plt section.  Call
	_bfd_elf_write_section_eh_frame on htab->plt_eh_frame section.
	(elf_backend_plt_alignment): Define to 4.
	* elf32-i386.c: Include dwarf2.h.
	(elf_i386_eh_frame_plt): New variable.
	(PLT_CIE_LENGTH, PLT_FDE_LENGTH, PLT_FDE_START_OFFSET,
	PLT_FDE_LEN_OFFSET): Define.
	(struct elf_i386_link_hash_table): Add plt_eh_frame field.
	(elf_i386_create_dynamic_sections): Create and fill in
	.eh_frame section for .plt section.
	(elf_i386_size_dynamic_sections): Write .plt section size
	into .eh_frame FDE covering .plt section.
	(elf_i386_finish_dynamic_sections): Write .plt section
	start into .eh_frame FDE covering .plt section.  Call
	_bfd_elf_write_section_eh_frame on htab->plt_eh_frame section.
	(elf_backend_plt_alignment): Define to 4.
ld/testsuite/
	* ld-x86-64/x86-64.exp: Link some testcases with
	--no-ld-generated-unwind-info.
	* ld-x86-64/tlsbin.rd: Add --no-ld-generated-unwind-info to ld
	comment.
	* ld-x86-64/tlsdesc.dd: Likewise.
	* ld-x86-64/tlspic.dd: Likewise.
	* ld-x86-64/tlsdesc.sd: Likewise.
	* ld-x86-64/tlspic.rd: Likewise.
	* ld-x86-64/tlsbindesc.rd: Likewise.
	* ld-x86-64/tlsbindesc.sd: Likewise.
	* ld-x86-64/tlsbin.td: Likewise.
	* ld-x86-64/tlsdesc.pd: Likewise.
	* ld-x86-64/tlsdesc.td: Likewise.
	* ld-x86-64/tlsbindesc.dd: Likewise.
	* ld-x86-64/tlsbin.dd: Likewise.
	* ld-x86-64/tlsgdesc.rd: Likewise.
	* ld-x86-64/tlspic.sd: Likewise.
	* ld-x86-64/tlsbindesc.td: Likewise.
	* ld-x86-64/tlspic.td: Likewise.
	* ld-x86-64/tlsbin.sd: Likewise.
	* ld-x86-64/ilp32-4.d: Likewise.
	* ld-x86-64/tlsgdesc.dd: Add --no-ld-generated-unwind-info to ld
	comment.  Adjust.
	* ld-x86-64/tlsdesc.rd: Likewise.
	* ld-x86-64/tlsgd6.dd: Adjust.
	* ld-x86-64/tlsgd5.dd: Likewise.
	* ld-i386/i386.exp: Link some testcases with
	--no-ld-generated-unwind-info.
	* ld-i386/tlsbin.rd: Add --no-ld-generated-unwind-info to ld
	comment..
	* ld-i386/tlsdesc.dd: Likewise.
	* ld-i386/tlspic.dd: Likewise.
	* ld-i386/tlsdesc.sd: Likewise.
	* ld-i386/tlsgdesc.dd: Likewise.
	* ld-i386/tlsnopic.sd: Likewise.
	* ld-i386/tlspic.rd: Likewise.
	* ld-i386/tlsdesc.rd: Likewise.
	* ld-i386/tlsbindesc.rd: Likewise.
	* ld-i386/tlsbindesc.sd: Likewise.
	* ld-i386/tlsbin.td: Likewise.
	* ld-i386/tlsdesc.td: Likewise.
	* ld-i386/tlsnopic.dd: Likewise.
	* ld-i386/tlsbindesc.dd: Likewise.
	* ld-i386/tlsbin.dd: Likewise.
	* ld-i386/tlsgdesc.rd: Likewise.
	* ld-i386/tlspic.sd: Likewise.
	* ld-i386/tlsnopic.rd: Likewise.
	* ld-i386/tlsbindesc.td: Likewise.
	* ld-i386/tlspic.td: Likewise.
	* ld-i386/tlsbin.sd: Likewise.
@
text
@a2108 2
if test -n "$PARSE_AND_LIST_ARGS_CASES" -o x"$GENERATE_SHLIB_SCRIPT" = xyes; then

a2124 2
#define OPTION_LD_GENERATED_UNWIND_INFO	(OPTION_AUDIT + 1)
#define OPTION_NO_LD_GENERATED_UNWIND_INFO (OPTION_LD_GENERATED_UNWIND_INFO + 1)
d2131 3
d2135 7
d2143 8
a2151 2
    {"audit", required_argument, NULL, OPTION_AUDIT},
    {"depaudit", required_argument, NULL, 'P'},
a2152 1

d2155 1
a2160 5
    {"ld-generated-unwind-info", no_argument, NULL,
      OPTION_LD_GENERATED_UNWIND_INFO},
    {"no-ld-generated-unwind-info", no_argument, NULL,
      OPTION_NO_LD_GENERATED_UNWIND_INFO},
    {"Bgroup", no_argument, NULL, OPTION_GROUP},
a2162 1

a2167 1

d2200 5
d2208 1
a2212 4
EOF

if test x"$GENERATE_SHLIB_SCRIPT" = xyes; then
fragment <<EOF
a2224 8
    case OPTION_LD_GENERATED_UNWIND_INFO:
      link_info.no_ld_generated_unwind_info = FALSE;
      break;

    case OPTION_NO_LD_GENERATED_UNWIND_INFO:
      link_info.no_ld_generated_unwind_info = TRUE;
      break;

d2252 3
d2256 36
a2291 1
      if (strcmp (optarg, "initfirst") == 0)
a2319 4
      else if (strcmp (optarg, "defs") == 0)
	link_info.unresolved_syms_in_objects = RM_GENERATE_ERROR;
      else if (strcmp (optarg, "muldefs") == 0)
	link_info.allow_multiple_definition = TRUE;
a2325 10
      else if (strcmp (optarg, "execstack") == 0)
	{
	  link_info.execstack = TRUE;
	  link_info.noexecstack = FALSE;
	}
      else if (strcmp (optarg, "noexecstack") == 0)
	{
	  link_info.noexecstack = TRUE;
	  link_info.execstack = FALSE;
	}
d2336 1
d2339 2
a2340 19
      else if (CONST_STRNEQ (optarg, "max-page-size="))
	{
	  char *end;

	  config.maxpagesize = strtoul (optarg + 14, &end, 0);
	  if (*end || (config.maxpagesize & (config.maxpagesize - 1)) != 0)
	    einfo (_("%P%F: invalid maxium page size \`%s'\n"),
		   optarg + 14);
	}
      else if (CONST_STRNEQ (optarg, "common-page-size="))
	{
	  char *end;
	  config.commonpagesize = strtoul (optarg + 17, &end, 0);
	  if (*end
	      || (config.commonpagesize & (config.commonpagesize - 1)) != 0)
	    einfo (_("%P%F: invalid common page size \`%s'\n"),
		   optarg + 17);
	}
      /* What about the other Solaris -z options? FIXME.  */
a2342 1
fi
d2364 3
d2368 1
a2368 1
  --build-id[=STYLE]          Generate build ID note\n"));
d2370 4
a2373 1
  --audit=AUDITLIB            Specify a library to use for auditing\n"));
d2375 1
a2375 2
  -P AUDITLIB, --depaudit=AUDITLIB\n" "\
                              Specify a library to use for auditing dependencies\n"));
a2376 1

d2380 2
a2381 1
  -Bgroup                     Selects group name lookup rules for DSO\n"));
d2389 2
d2394 6
d2404 4
d2416 6
d2424 4
d2440 3
d2446 1
a2446 1

a2467 9

fragment <<EOF
  fprintf (file, _("\
  -z max-page-size=SIZE       Set maximum page size to SIZE\n"));
  fprintf (file, _("\
  -z common-page-size=SIZE    Set common page size to SIZE\n"));
  fprintf (file, _("\
  -z KEYWORD                  Ignored for Solaris compatibility\n"));
EOF
a2485 11
else
fragment <<EOF
#define gld${EMULATION_NAME}_add_options NULL
#define gld${EMULATION_NAME}_handle_option NULL
EOF
if test x"$LDEMUL_LIST_OPTIONS" != xgld"$EMULATION_NAME"_list_options; then
fragment <<EOF
#define gld${EMULATION_NAME}_list_options NULL
EOF
fi
fi
@


1.219
log
@	PR 12763
missed from last commit
@
text
@d2127 2
d2149 4
d2218 8
@


1.218
log
@2011-02-28  Kai Tietz  <kai.tietz@@onevision.com>

	* emultempl/beos.em (sort_by_file_name): Use filename_(n)cmp.
	* emultempl/elf32.em (gld${EMULATION_NAME}_vercheck):
	Likewise.
	(gld${EMULATION_NAME}_stat_needed): Likewise.
	(gld${EMULATION_NAME}_check_needed): Likewise.
	* emultempl/pe.em (gld_${EMULATION_NAME}_after_open): Likewise.
	(gld_${EMULATION_NAME}_unrecognized_file): Likewise.
	* emultempl/pep.em (gld_${EMULATION_NAME}_after_open): Likewise.
	(gld_${EMULATION_NAME}_unrecognized_file): Likewise.
	* ldfile.c (ldfile_open_file): Likewise.
	* ldlang.c (wild_sort): Likewise.
	(lookup_name): Likewise.
	(check_excluded_libs): Likewise.
	* ldmisc.c (vfinfo): Likewise.
	* pe-dll.c (libnamencmp): Likewise.
	(auto_export): Likewise.
	(pe_dll_generate_implib): Likewise.
	* testplug.c (onclaim_file): Likewise.
@
text
@d1923 1
a1923 1
  else if ((s->flags & (SEC_LOAD | SEC_HAS_CONTENTS)) == 0)
@


1.217
log
@	* emultempl/elf32.em (gld${EMULATION_NAME}_place_orphan): Don't
	attempt to put non-alloc orphans before debug sections, just place
	them after .comment.
@
text
@d43 1
d204 1
a204 1
      if (strcmp (soname, l->name) == 0)
d219 1
a219 1
      if (strncmp (soname, l->name, suffix - l->name) == 0)
d294 1
a294 1
  if (strncmp (soname, global_needed->name, suffix - global_needed->name) == 0)
d859 1
a859 1
  if (strcmp (s->filename, global_needed->name) == 0)
d869 1
a869 1
	  && strcmp (f + 1, global_needed->name) == 0)
d878 1
a878 1
      && strcmp (soname, global_needed->name) == 0)
@


1.216
log
@	* ld.texinfo (Expression Section): Describe treatment of numbers
	and absolute symbols.
	* ldemul.c (after_open_default): Look up __ld_compatibility.
	* ldexp.c (fold_name): Convert absolute symbols to numbers when
	inside output section definitions, or when __ld_compatibility >= 221.
	(exp_fold_tree_1): Convert numbers to absolute when not in output
	section definition and __ld_compatibility < 221.  Don't always
	convert values outside an output section definition to absolute.
	* ldexp.h (uses_defined): Comment.
	* ldlang.c (ld_compatibility): New variable.
	* ldlang.h (ld_compatibility): Declare.
	* emultempl/aix.em, * emultempl/armcoff.em, * emultempl/beos.em,
	* emultempl/elf32.em, * emultempl/genelf.em, * emultempl/lnk960.em,
	* emultempl/m68kcoff.em, * emultempl/mmo.em, * emultempl/pe.em,
	* emultempl/pep.em, * emultempl/sunos.em, * emultempl/z80.em: Call
	after_open_default from after_open function.
@
text
@d16 1
a16 1
   2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
d1791 1
a1791 1
      { 0,
a1882 1
      lang_output_section_statement_type *lookup;
a1891 10
      lookup = hold[orphan_bss].os;
      if (lookup == NULL)
	lookup = &lang_output_section_statement.head->output_section_statement;
      for (; lookup != NULL; lookup = lookup->next)
	if ((lookup->bfd_section != NULL
	     && (lookup->bfd_section->flags & SEC_DEBUGGING) != 0)
	    || strcmp (lookup->name, ".comment") == 0)
	  break;
      hold[orphan_nonalloc].os = lookup ? lookup->prev : NULL;
      hold[orphan_nonalloc].name = ".comment";
@


1.215
log
@Replace is_archive with maybe_archive.

2010-12-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldfile.c (ldfile_open_file_search): Check maybe_archive instead
	of is_archive.
	* emultempl/aix.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/vms.em: Likewise.

	* ldlang.c (new_afile): Set maybe_archive instead of is_archive..

	* ldlang.h (lang_input_statement_struct): Replace is_archive
	with maybe_archive.
@
text
@d1062 2
@


1.214
log
@Add compressed debug section support to binutils and ld.

bfd/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>
	    Cary Coutant  <ccoutant@@google.com>

	* archive.c (bfd_openr_next_archived_file): Copy BFD_COMPRESS
	and BFD_DECOMPRESS.

	* bfd.c (BFD_COMPRESS): New.
	(BFD_DECOMPRESS): Likewise.
	(BFD_FLAGS_SAVED): Likewise.
	(bfd_preserve_save): Replace BFD_IN_MEMORY with BFD_FLAGS_SAVED.

	* compress.c (bfd_uncompress_section_contents): Removed.
	(get_uncompressed_size): New.
	(decompress_contents): Likewise.
	(bfd_compress_section_contents): Likewise.
	(bfd_get_full_section_contents): Likewise.
	(bfd_is_section_compressed): Likewise.
	(bfd_init_section_decompress_status): Likewise.
	(bfd_init_section_compress_status): Likewise.

	* dwarf2.c (dwarf_debug_sections): New.
	(dwarf_debug_section_enum): Likewise.
	(read_section): Remove section_name and compressed_section_name.
	Add dwarf_debug_section_enum.  Try compressed debug section.
	(read_indirect_string): Updated.
	(read_abbrevs): Likewise.
	(decode_line_info): Likewise.
	(read_debug_ranges): Likewise.
	(find_line): Updated.

	* ecoff.c (bfd_debug_section): Add compress_status and
	compressed_size.

	* elf.c (_bfd_elf_make_section_from_shdr): Call
	bfd_is_section_compressed to check if a DWARF debug section is
	compressed.  Call bfd_init_section_compress_status or
	bfd_init_section_decompress_status if needed.

	* elflink.c (elf_link_input_bfd): Replace bfd_get_section_contents
	with bfd_get_full_section_contents.
	* merge.c (_bfd_add_merge_section): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents): Likewise.
	* simple.c (bfd_simple_get_relocated_section_contents): Likewise.

	* elfxx-target.h (TARGET_BIG_SYM): Allow BFD_COMPRESS and
	BFD_DECOMPRESS.
	(TARGET_LITTLE_SYM): Likewise.

	* libbfd-in.h (dwarf_debug_section): New.
	(dwarf_debug_sections): Likewise.

	* libbfd.c (_bfd_generic_get_section_contents): Issue an error
	when getting contents on compressed/decompressed section.

	* section.c (COMPRESS_SECTION_NONE): New.
	(COMPRESS_SECTION_DONE): Likewise.
	(DECOMPRESS_SECTION_SIZED): Likewise.
	(BFD_FAKE_SECTION): Add compress_status and compressed_size.
	(bfd_malloc_and_get_section): Replace bfd_get_section_contents
	with bfd_get_full_section_contents.

	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.

binutils/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* addr2line.c (process_file): Set BFD_DECOMPRESS.

	* objcopy.c (do_debug_sections): New.
	(OPTION_COMPRESS_DEBUG_SECTIONS): New.
	(OPTION_DECOMPRESS_DEBUG_SECTIONS): Likewise.
	(copy_options): Add OPTION_COMPRESS_DEBUG_SECTIONS and
	OPTION_DECOMPRESS_DEBUG_SECTIONS.
	(copy_usage): Add --compress-debug-sections and
	--decompress-debug-sections.
	(copy_file): Set BFD_COMPRESS or BFD_DECOMPRESS.
	(copy_section): Replace bfd_get_section_contents with
	bfd_get_full_section_contents.
	(copy_main): Handle OPTION_COMPRESS_DEBUG_SECTIONS and
	OPTION_DECOMPRESS_DEBUG_SECTIONS.  Check do_debug_sections to
	rename DWARF debug sections.

	* objdump.c (load_specific_debug_section): Replace
	bfd_get_section_contents with bfd_get_full_section_contents.
	Remove bfd_uncompress_section_contents.
	(dump_section): Replace bfd_get_section_contents with
	bfd_get_full_section_contents.
	(display_file): Set BFD_DECOMPRESS if needed.

	* readelf.c (uncompress_section_contents): Set buffer to NULL
	to indiate decompression failure.
	(load_specific_debug_section): Always call
	uncompress_section_contents.

	* doc/binutils.texi: Document --compress-debug-sections and
	--decompress-debug-sections.

binutils/testsuite/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* binutils-all/compress.exp: New.
	* binutils-all/dw2-1.S: Likewise.
	* binutils-all/dw2-2.S: Likewise.
	* binutils-all/libdw2-compressed.out: Likewise.
	* binutils-all/libdw2.out: Likewise.

gas/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* write.c (compress_debug): Optimize section flags check.

gas/testsuite/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf/dwarf2-1.s: Replace .zdebug_abbrev section with
	.debug_abbrev section.
	* elf/dwarf2-2.3: Likewise.

	* elf/dwarf2-1.d: Pass --compress-debug-sections to assembler.
	Updated.
	* elf/dwarf2-2.d: Likewise.

	* gas/i386/i386.exp: Remove xfail on dw2-compress-2 and
	x86-64-dw2-compress-2.

ld/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldfile.c (ldfile_try_open_bfd): Set BFD_DECOMPRESS after
	bfd_openr returns.
	* emultempl/elf32.em (gld${EMULATION_NAME}_try_needed): Likewise.

	* scripttempl/elf.sc: Include compressed DWARF debug sections.

ld/testsuite/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-elf/compress.exp: New.
	* ld-elf/compress1.s: Likewise.
	* ld-elf/compress1a.d: Likewise.
	* ld-elf/compress1b.d: Likewise.
	* ld-elf/compress1c.d: Likewise.
@
text
@d1621 1
a1621 1
  if (! entry->is_archive)
d1675 1
a1675 1
      ASSERT (entry->is_archive && entry->search_dirs_flag);
@


1.214.2.1
log
@backport from mainline
@
text
@d16 1
a16 1
   2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
a1061 2
  after_open_default ();

d1621 1
a1621 1
  if (! entry->maybe_archive)
d1675 1
a1675 1
      ASSERT (entry->maybe_archive && entry->search_dirs_flag);
d1789 1
a1789 1
      { ".comment",
d1881 1
d1891 10
@


1.214.2.2
log
@	PR 12365
	PR 12613
	PR 12632
	PR 12739
	PR 12753
	PR 12760
	PR 12763
Apply fix from mainline along with assorted other small fixes.
@
text
@d1922 1
a1922 1
  else if ((s->flags & (SEC_LOAD | SEC_HAS_CONTENTS | SEC_THREAD_LOCAL)) == 0)
@


1.213
log
@Check audit entry only on ELF input.

2010-08-25  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11946
	* emultempl/elf32.em (_before_allocation): Check audit entry
	only on ELF input.
@
text
@d320 4
@


1.212
log
@Find one .eh_frame section for --eh-frame-hdr.

2010-08-22  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11937
	* emultempl/elf32.em (_after_open): Find one .eh_frame section
	for --eh-frame-hdr.
@
text
@d1498 3
a1500 2
    {
      const char *audit_libs = elf_dt_audit (abfd);
d1502 24
a1525 24
      /* If the input bfd contains an audit entry, we need to add it as 
         a dep audit entry.  */
      if (audit_libs && *audit_libs != '\0')
	{
	  char *cp = xstrdup (audit_libs);
	  do
	    {
	      int more = 0;
	      char *cp2 = strchr (cp, config.rpath_separator);

	      if (cp2)
		{
	          *cp2 = '\0';
		  more = 1;
		}
	      
	      if (cp != NULL && *cp != '\0')
	        gld${EMULATION_NAME}_append_to_separated_string (&depaudit, cp);

	      cp = more ? ++cp2 : NULL;
	    }
	  while (cp != NULL);
	}
    }
@


1.211
log
@Find an ELF input for --build-id and --eh-frame-hdr.

2010-08-22  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11937
	* emultempl/elf32.em (_after_open): Find an ELF input for
	--build-id and --eh-frame-hdr.
@
text
@d1135 10
a1144 5
	  s = bfd_get_section_by_name (abfd, ".eh_frame");
	   if (s && s->size > 8 && !bfd_is_abs_section (s->output_section))
	     warn_eh_frame = TRUE;
	   if (elfbfd && warn_eh_frame)
	     break;
@


1.210
log
@        * emultempl/elf32.em (_after_open): Check for get_elf_backend_data
        returning NULL.
@
text
@d1068 5
a1072 1
      abfd = link_info.input_bfds;
d1127 2
a1128 1
      bfd *abfd;
d1133 2
d1136 4
a1139 2
	  if (s && s->size > 8 && !bfd_is_abs_section (s->output_section))
	    break;
d1141 1
a1141 1
      if (abfd)
d1145 4
a1148 7
	  bed = get_elf_backend_data (abfd);
	  if (bed == NULL)
	    s = NULL;
	  else
	    s = bfd_make_section_with_flags (abfd, ".eh_frame_hdr",
					     bed->dynamic_sec_flags
					     | SEC_READONLY);
d1150 5
a1154 5
	      && bfd_set_section_alignment (abfd, s, 2))
	    htab->eh_info.hdr_sec = s;
	  else
	    einfo ("%P: warning: Cannot create .eh_frame_hdr section,"
		   " --eh-frame-hdr ignored.\n");
d1156 3
@


1.209
log
@	* emultempl/elf32.em (find_exp_assignment): Handle etree_provided.
@
text
@d1137 6
a1142 3
	  s = bfd_make_section_with_flags (abfd, ".eh_frame_hdr",
					   bed->dynamic_sec_flags
					   | SEC_READONLY);
@


1.208
log
@* emultempl/elf32.em (_place_orphan): If an input section doesn't
match an existing output section, but an unused output section
statement does match, use it.
* emultempl/pe.em (_place_orphan): Likewise.
* emultempl/pep.em (_place_orphan): Likewise.

* ld-elf/orphan4.d: New.
* ld-elf/orphan4.ld: New.
* ld-elf/orphan4.s: New.
@
text
@d1343 1
@


1.207
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d1785 1
d1841 5
d1848 8
@


1.206
log
@        * lexsup.c: Rename --add-needed to --copy-dt-needed-entries.
        * ldlang.h (struct lang_input_statement_struct): Rename add_needed
        to add_DT_NEEDED_for_dynamic.  Rename as_needed to
        add_DT_NEEDED_for_regular.
        * ldlang.c: Likewise.
        * ldlang.h: Likewise.
        * ldlang.c: Use the new variable names.
        * ldgram.y: Likewise.
        * emultempl/elf32.em: Likewise.
        * ld.texinfo: Document the renamed option.  Also mention its
        affect on the resolution of dynamic symbols.
        * NEWS: Mention the changed option name.
@
text
@d345 1
a345 1
      struct bfd_link_needed_list *needed;
d347 1
a347 1
      if (! bfd_elf_get_bfd_needed_list (abfd, &needed))
d350 1
a350 1
      if (needed != NULL)
d352 1
a352 1
	  global_vercheck_needed = needed;
d377 1
a377 1
	    for (l = needed; l != NULL; l = l->next)
d887 1
a887 1
					   struct bfd_link_info *link_info)
d889 1
a889 1
  const char *style = link_info->emit_note_gnu_build_id;
d1417 1
a1417 1
gld${EMULATION_NAME}_append_to_separated_string (char **to, char *optarg)
d1420 1
a1420 1
    *to = xstrdup (optarg);
d1424 1
a1424 1
      size_t optarg_len = strlen (optarg);
d1431 3
a1433 3
	  if (strncmp (optarg, cp, optarg_len) == 0
	      && (cp[optarg_len] == 0
		  || cp[optarg_len] == config.rpath_separator))
d1446 1
a1446 1
	  buf = xmalloc (to_len + optarg_len + 2);
d1448 1
a1448 1
		   config.rpath_separator, optarg);
@


1.205
log
@	PR ld/10489
	* emultempl/elf32.em (gld${EMULATION_NAME}_search_needed): Handle
	drive specifiers for DOS based filesystems in rpath-link strings.
@
text
@d113 1
a113 1
/* Handle as_needed DT_NEEDED.  */
d123 1
a123 1
  if (entry->as_needed)
d129 1
a129 1
  if (!entry->add_needed)
d137 1
a137 1
  if (!link_class
@


1.204
log
@bfd/
	* bfd-in.h (bfd_elf_size_dynamic_sections): Add audit and depaudit
	arguments.
	* elflink.c (bfd_elf_size_dynamic_sections): Generate DT_AUDIT,
	DT_DEPAUDIT from audit/depaudit arguments.
	(elf_finalize_dynstr): Finalize DT_AUDIT and DT_DEPAUDIT strtab entries.
	(elf_link_add_object_symbols): Set dt_audit target data when finding a
	DT_AUDIT.
	* bfd-in2.h: Regenerate.
	* bfd-elf.h: Add dt_audit to elf_obj_tdata, and elf_dt_audit macro.
ld/
	* emultempl/elf32.em (gld${EMULATION_NAME}_add_options): Add --audit,
	--depaudit, and -P options.
	(gld${EULATION_NAME}_handle_options): Ditto.
	(gld${EULATION_NAME}_list_options): Ditto.
	(gld${EMULATION_NAME}_append_to_separated_string): New function for
	handling rpath-like colon separated strings.
	(gld${EMULATION_NAME}_before_allocation): Pass the audit and depaudit
	libs to bfd.  Propagate DT_AUDIT from needed libs to depaudit.
	* ld.texinfo: Document new options.
ld/testsuite/
	* ld-elf/audit.exp: New.
	* ld-elf/audit.rd: New.
	* ld-elf/depaudit.rd: New.
	* ld-elf/depaudit2.rd: New.
@
text
@d61 1
d476 11
@


1.203
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        * as.c (main): Call dwarf2_init.
        * config/obj-elf.c (struct group_list): New field.
        (build_group_lists): Use hash lookup.
        (free_section_idx): New function.
        (elf_frob_file): Adjust.
        * dwarf2dbg.c (all_segs_hash, last_seg_ptr): New variables.
        (get_line_subseg): Adjust.
        (dwarf2_init): New function.
        * dwarf2dbg.h (dwarf2_init): New declaration.
@
text
@d160 4
d1403 40
d1451 1
d1466 30
d1498 1
a1498 1
	  command_line.filter_shlib,
d2085 1
d2092 1
a2092 1
  static const char xtra_short[] = "${PARSE_AND_LIST_SHORTOPTS}z:";
d2095 2
d2148 6
d2305 5
@


1.202
log
@        * bfd/coff-arm.c (coff_arm_relocate_section)
        (record_thumb_to_arm_glue, bfd_arm_process_before_allocation):
        Change member name class to symbol_class.
        * bfd/coff-i960.c (coff_i960_relocate_section) Rename variable
        class to class_val. Change member name class to symbol_class.
        * bfd/coff-rs6000.c (_bfd_xcoff_swap_aux_in)
        (_bfd_xcoff_swap_aux_out): Rename arguments class to in_class.
        * bfd/coff-stgo32.c (adjust_aux_in_post)
        (adjust_aux_out_pre, adjust_aux_out_post): Rename arguments class
        to in_class.
        * bfd/coff64-rs6000.c (_bfd_xcoff64_swap_aux_in)
        (_bfd_xcoff64_swap_aux_out): Rename arguments class to in_class.
        * bfd/coffcode.h (coff_pointerize_aux_hook): Rename variable class
        to n_sclass.
        * bfd/coffgen.c (coff_write_symbol, coff_pointerize_aux): Rename
        variables named class to n_sclass. (coff_write_symbols): Rename
        variable class to sym_class. (bfd_coff_set_symbol_class): Rename
        argument class to symbol_class.
        * bfd/cofflink.c (_bfd_coff_link_hash_newfunc)
        (coff_link_add_symbols, _bfd_coff_link_input_bfd)
        (_bfd_coff_write_global_sym, _bfd_coff_generic_relocate_section):
        Update code to use renamed members.
        * bfd/coffswap.h (coff_swap_aux_in, coff_swap_aux_out): Rename
        argument class to in_class.
        * bfd/libcoff-in.h (struct coff_link_hash_entry, struct
        coff_debug_merge_type) Renamed members class to symbol_class and
        type_class.
        * bfd/libcoff.h Regenerated.
        * bfd/peXXigen.c: (_bfd_XXi_swap_aux_in, _bfd_XXi_swap_aux_out):
        Rename argument class to in_class.
        * bfd/pef.c (bfd_pef_parse_imported_symbol): Update code to use
        renamed members.
        * bfd/pef.h (struct bfd_pef_imported_symbol): Changed name of
        member class to symbol_class.
        * binutils/ieee.c (ieee_read_cxx_misc, ieee_read_cxx_class)
        (ieee_read_reference): Rename variables named class to cxxclass.
        * gas/config/tc-arc.c (struct syntax_classes): Rename member class
        to s_class. (arc_extinst): Rename variable class to
        s_class. Update code to use renamed members.
        * gas/config/tc-mips.c (insn_uses_reg): Rename argument class to
        regclass.
        * gas/config/tc-ppc.c (ppc_csect, ppc_change_csect, ppc_function)
        (ppc_tc, ppc_is_toc_sym, ppc_symbol_new_hook, ppc_frob_label)
        (ppc_fix_adjustable, md_apply_fix): Update code to use renamed
        members.
        * gas/config/tc-ppc.h (struct ppc_tc_sy): Change name of member
        from class to symbol_class. (OBJ_COPY_SYMBOL_ATTRIBUTES): Update
        code to use renamed members.
        * gas/config/tc-score.c (s3_adjust_paritybit): Rename argument
        class to i_class.
        * gas/config/tc-score7.c (s7_adjust_paritybit): Rename argument
        class to i_class.
        * gprof/corefile.c (core_create_function_syms): Rename variable
        class to cxxclass.
        * include/coff/ti.h (GET_LNSZ_SIZE, PUT_LNSZ_SIZE): Updated name
        of class variable to in_class to match changes in function that
        use this macro.
        * include/opcode/ia64.h (struct ia64_operand): Renamed member
        class to op_class
        * ld/emultempl/elf32.em (gld${EMULATION_NAME}_load_symbols)
        (gld${EMULATION_NAME}_try_needed): Rename variable class to
        link_class
        * opcodes/ia64-dis.c (print_insn_ia64): Update code to use renamed
        member.
        * opcodes/m88k-dis.c (m88kdis): Rename variable class to in_class.
        * opcodes/tic80-opc.c (tic80_symbol_to_value)
        (tic80_value_to_symbol): Rename argument class to symbol_class.
@
text
@d140 2
a141 1
  bfd_elf_set_dyn_lib_class (entry->the_bfd, link_class);
d432 1
a432 1
  bfd_elf_set_dyn_lib_class (abfd, link_class);
d934 1
a934 1
  struct build_id_info *info =
d954 1
a954 1
	asec->contents = xmalloc (asec->size);
d960 1
a960 1
  e_note = (void *) contents;
d1079 2
a1080 1
		  struct build_id_info *b = xmalloc (sizeof *b);
d1458 1
a1458 1
	msg = xmalloc ((size_t) (sz + 1));
@


1.201
log
@update copyright dates
@
text
@d117 1
a117 1
  int class = 0;
d123 1
a123 1
    class = DYN_AS_NEEDED;
d129 1
a129 1
    class |= DYN_NO_ADD_NEEDED;
d136 1
a136 1
  if (!class
d140 1
a140 1
  bfd_elf_set_dyn_lib_class (entry->the_bfd, class);
d309 1
a309 1
  int class;
d422 1
a422 1
  class = DYN_DT_NEEDED;
d429 1
a429 1
    class |= DYN_NO_NEEDED | DYN_NO_ADD_NEEDED;
d431 1
a431 1
  bfd_elf_set_dyn_lib_class (abfd, class);
@


1.201.2.1
log
@        * coff-arm.c (coff_arm_relocate_section)
        (record_thumb_to_arm_glue, bfd_arm_process_before_allocation):
        Change member name class to symbol_class.
        * coff-i960.c (coff_i960_relocate_section) Rename variable
        class to class_val. Change member name class to symbol_class.
        * coff-rs6000.c (_bfd_xcoff_swap_aux_in)
        (_bfd_xcoff_swap_aux_out): Rename arguments class to in_class.
        * coff-stgo32.c (adjust_aux_in_post)
        (adjust_aux_out_pre, adjust_aux_out_post): Rename arguments class
        to in_class.
        * coff64-rs6000.c (_bfd_xcoff64_swap_aux_in)
        (_bfd_xcoff64_swap_aux_out): Rename arguments class to in_class.
        * coffcode.h (coff_pointerize_aux_hook): Rename variable class
        to n_sclass.
        * coffgen.c (coff_write_symbol, coff_pointerize_aux): Rename
        variables named class to n_sclass. (coff_write_symbols): Rename
        variable class to sym_class. (bfd_coff_set_symbol_class): Rename
        argument class to symbol_class.
        * cofflink.c (_bfd_coff_link_hash_newfunc)
        (coff_link_add_symbols, _bfd_coff_link_input_bfd)
        (_bfd_coff_write_global_sym, _bfd_coff_generic_relocate_section):
        Update code to use renamed members.
        * coffswap.h (coff_swap_aux_in, coff_swap_aux_out): Rename
        argument class to in_class.
        * libcoff-in.h (struct coff_link_hash_entry, struct
        coff_debug_merge_type) Renamed members class to symbol_class and
        type_class.
        * libcoff.h Regenerated.
        * peXXigen.c: (_bfd_XXi_swap_aux_in, _bfd_XXi_swap_aux_out):
        Rename argument class to in_class.
        * pef.c (bfd_pef_parse_imported_symbol): Update code to use
        renamed members.
        * pef.h (struct bfd_pef_imported_symbol): Changed name of
        member class to symbol_class.
@
text
@d117 1
a117 1
  int link_class = 0;
d123 1
a123 1
    link_class = DYN_AS_NEEDED;
d129 1
a129 1
    link_class |= DYN_NO_ADD_NEEDED;
d136 1
a136 1
  if (!link_class
d140 1
a140 1
  bfd_elf_set_dyn_lib_class (entry->the_bfd, link_class);
d309 1
a309 1
  int link_class;
d422 1
a422 1
  link_class = DYN_DT_NEEDED;
d429 1
a429 1
    link_class |= DYN_NO_NEEDED | DYN_NO_ADD_NEEDED;
d431 1
a431 1
  bfd_elf_set_dyn_lib_class (abfd, link_class);
@


1.201.2.2
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.
@
text
@d140 1
a140 2
  bfd_elf_set_dyn_lib_class (entry->the_bfd,
                             (enum dynamic_lib_link_class) link_class);
d431 1
a431 1
  bfd_elf_set_dyn_lib_class (abfd, (enum dynamic_lib_link_class) link_class);
d933 1
a933 1
  struct build_id_info *info = (struct build_id_info *)
d953 1
a953 1
	asec->contents = (unsigned char *) xmalloc (asec->size);
d959 1
a959 1
  e_note = (Elf_External_Note *) contents;
d1078 1
a1078 2
		  struct build_id_info *b =
                      (struct build_id_info *) xmalloc (sizeof *b);
d1456 1
a1456 1
	msg = (char *) xmalloc ((size_t) (sz + 1));
@


1.200
log
@	PR ld/10569
	* ldexp.c (fold_name <MAXPAGESIZE>): Return config.maxpagesize.
	(fold_name <COMMONPAGESIZE>): Similarly.
	* ldlang.c (output_target): Make global.
	* ldlang.h (output_target): Declare.
	* ldmain.c (main): Set config.maxpagesize from bfd_emul_get_maxpagesize.
	Similarly for config.commonpagesize.
	* ldemul.c (set_output_arch_default): Call bfd_emul_set_maxpagesize
	and bfd_emul_set_commonpagesize.
	* emultempl/elf32.em (gld${EMULATION_NAME}_handle_option): Don't call
	bfd_emul_set_maxpagesize or bfd_emul_set_commonpagesize here.
@
text
@d16 2
a17 1
   2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
@


1.199
log
@        PR ld/10555
        * emultempl/elf32.em (_after_open): Do not create a
        .note.gnu-build-id section if there are no input files.
@
text
@a2180 2
	  ASSERT (default_target != NULL);
	  bfd_emul_set_maxpagesize (default_target, config.maxpagesize);
a2189 3
	  ASSERT (default_target != NULL);
	  bfd_emul_set_commonpagesize (default_target,
				       config.commonpagesize);
@


1.198
log
@	PR 10474
	* ldemul.c (after_allocation_default): Run lang_relax_sections.
	* ldlang.h (lang_relax_sections): Declare.
	* ldlang.c (relax_sections): Delete.
	(lang_relax_sections): New function.
	(lang_process): Don't relax directly from here.
	* emultempl/alphaelf.em (alpha_finish): Call finish_default.
	* emultempl/armelf.em (arm_elf_after_allocation): Delete.  Move body..
	(gld${EMULATION_NAME}_finish): ..to here.  Move existing code..
	(gld${EMULATION_NAME}_after_allocation): ..to here.  New function.
	(LDEMUL_AFTER_ALLOCATION): Update.
	* emultempl/avrelf.em (avr_elf_finish, LDEMUL_FINISH): Delete.
	(avr_elf_after_allocation): New function.
	(LDEMUL_AFTER_ALLOCATION): Define.
	* emultempl/elf-generic.em (gld${EMULATION_NAME}_map_segments): Call
	lang_relax_sections.
	* emultempl/elf32.em (gld${EMULATION_NAME}_finish): Delete.  Move..
	(gld${EMULATION_NAME}_after_allocation): ..code to here.  New function.
	(LDEMUL_AFTER_ALLOCATION, LDEMUL_FINISH): Update.
	* emultempl/genelf.em (gld${EMULATION_NAME}_finish): Delete.  Move..
	(gld${EMULATION_NAME}_after_allocation): ..code to here.  New function.
	(LDEMUL_FINISH): Delete.
	(LDEMUL_AFTER_ALLOCATION): Define.
	* emultempl/hppaelf.em (gld${EMULATION_NAME}_finish): Delete.  Move..
	(gld${EMULATION_NAME}_after_allocation): ..to here.  New function.
	(LDEMUL_FINISH): Delete.
	(LDEMUL_AFTER_ALLOCATION): Define.
	* emultempl/m68hc1xelf.em (m68hc11elf_finish): Delete.  Move..
	(m68hc11elf_after_allocation): ..to here.  New function.
	(LDEMUL_FINISH): Delete.
	(LDEMUL_AFTER_ALLOCATION): Define.
	* emultempl/m68kelf.em (m68k_elf_after_allocation): Call
	gld${EMULATION_NAME}_after_allocation.
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): Call
	gld${EMULATION_NAME}_after_allocation.
	* emultempl/mmo.em (mmo_finish): Delete.  Move body..
	(gld${EMULATION_NAME}_after_allocation): ..to here.  New function.
	(LDEMUL_FINISH): Define.
	* emultempl/ppc64elf.em (ppc_layout_sections_again): Set elf_gp.
	(gld${EMULATION_NAME}_finish): Move code sizing sections..
	(gld${EMULATION_NAME}_after_allocation): ..to here.
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_after_allocation):
	Call gld${EMULATION_NAME}_after_allocation.
	* emultempl/spuelf.em (gld${EMULATION_NAME}_finish): Delete
	bfd_elf_discard_info and map_segments call.
@
text
@d1052 1
a1052 2
      size = gld${EMULATION_NAME}_id_note_section_size (abfd, &link_info);
      if (size == 0)
d1054 2
a1055 1
	  einfo ("%P: warning: unrecognized --build-id style ignored.\n");
d1061 2
a1062 5
	  s = bfd_make_section_with_flags (abfd, ".note.gnu.build-id",
					   SEC_ALLOC | SEC_LOAD
					   | SEC_IN_MEMORY | SEC_LINKER_CREATED
					   | SEC_READONLY | SEC_DATA);
	  if (s != NULL && bfd_set_section_alignment (abfd, s, 2))
d1064 3
a1066 9
	      struct elf_obj_tdata *t = elf_tdata (link_info.output_bfd);
	      struct build_id_info *b = xmalloc (sizeof *b);
	      b->style = link_info.emit_note_gnu_build_id;
	      b->sec = s;
	      elf_section_type (s) = SHT_NOTE;
	      s->size = size;
	      t->after_write_object_contents
		= &gld${EMULATION_NAME}_write_build_id_section;
	      t->after_write_object_contents_info = b;
d1070 24
a1093 4
	      einfo ("%P: warning: Cannot create .note.gnu.build-id section,"
		     " --build-id ignored.\n");
	      free (link_info.emit_note_gnu_build_id);
	      link_info.emit_note_gnu_build_id = NULL;
@


1.197
log
@ld/
	* ldlang.c (lang_output_section_statement_lookup): Add function
	comment.  Make "name" non-const.  Ensure duplicate entries use
	the same string, allowing simple comparison in hash bucket loop.
	Tweak constraint check.
	(next_matching_output_section_statement): New function.
	* ldlang.h (lang_output_section_statement_lookup): Update.
	(next_matching_output_section_statement): Declare.
	* emultempl/elf32.em (gld${EMULATION_NAME}_place_orphan): Don't
	combine orphan sections when input sections flags differ in
	alloc or load.
	* emultempl/pe.em: Formatting throughout.
	(gld${EMULATION_NAME}_place_orphan): As for elf32.em.
	* emultempl/pep.em: Formatting throughout.
	(gld${EMULATION_NAME}_place_orphan): As for elf32.em.
ld/testsuite/
	* ld-elf/orphan3.d, * ld-elf/orphan3a.s, * ld-elf/orphan3b.s,
	* ld-elf/orphan3c.s, * ld-elf/orphan3d.s, * ld-elf/orphan3e.s,
	* ld-elf/orphan3f.s: New test.
	* ld-pe/orphan.d, * ld-pe/orphana.s, * ld-pe/orphanb.s,
	* ld-pe/orphand.s, * ld-pe/orphane.s: New test.
	* ld-pe/direct.exp: Use is_pecoff_format.
	* ld-pe/longsecn.exp: Delete.
	* ld-pe/pe.exp: Run new test and longsecn tests.
@
text
@d65 1
a67 2
static void gld${EMULATION_NAME}_finish (void);

d1832 1
a1832 1
if test x"$LDEMUL_FINISH" != xgld"$EMULATION_NAME"_finish; then
d1836 1
a1836 1
gld${EMULATION_NAME}_finish (void)
a1839 1

a1840 1
  finish_default ();
d2327 1
a2327 1
  ${LDEMUL_AFTER_ALLOCATION-after_allocation_default},
d2334 1
a2334 1
  ${LDEMUL_FINISH-gld${EMULATION_NAME}_finish},
@


1.196
log
@	* ldlang.c (lang_output_section_find_by_flags): Handle non-alloc
	sections.
	* emultempl/elf32.em (enum orphan_save_index): Add orphan_nonalloc.
	(hold): Likewise.
	(gld${EMULATION_NAME}_place_orphan): Handle non-alloc orphans.
@
text
@d1715 26
a1740 17
  if (constraint == 0
      && (os = lang_output_section_find (secname)) != NULL
      && os->bfd_section != NULL
      && (os->bfd_section->flags == 0
	  || (_bfd_elf_match_sections_by_type (link_info.output_bfd,
					       os->bfd_section, s->owner, s)
	      && ((s->flags ^ os->bfd_section->flags)
		  & (SEC_LOAD | SEC_ALLOC)) == 0)))
    {
      /* We already have an output section statement with this
	 name, and its bfd section has compatible flags.
	 If the section already exists but does not have any flags
	 set, then it has been created by the linker, probably as a
	 result of a --section-start command line switch.  */
      lang_add_section (&os->children, s, os);
      return os;
    }
@


1.195
log
@	* ldemul.h (ldemul_place_orphan): Update prototype.
	(struct ld_emulation_xfer_struct <place_orphan>): Likewise.
	* ldemul.c (ldemul_place_orphan): Return pointer to output
	section statement.
	* emultempl/beos.em (gld${EMULATION_NAME}_place_orphan): Likewise.
	* emultempl/elf32.em (gld${EMULATION_NAME}_place_orphan): Likewise.
	* emultempl/mmo.em (mmo_place_orphan): Likewise.
	* emultempl/pe.em (gld_${EMULATION_NAME}_place_orphan): Likewise.
	* emultempl/pep.em (gld_${EMULATION_NAME}_place_orphan): Likewise.
@
text
@d1665 4
a1668 1
	0, 0, 0, 0 }
d1678 2
a1679 1
      orphan_sdata
d1735 1
d1737 1
d1745 10
d1777 3
a1779 1
  if ((s->flags & SEC_ALLOC) == 0)
@


1.194
log
@	* ldemul.c (ldemul_place_orphan): Add "constraint" param.
	* ldemul.h (ldemul_place_orphan): Update prototype.
	(struct ld_emulation_xfer_struct <place_orphan>): Likewise add param.
	* ldlang.c (unique_section_p): Make static.
	(lang_output_section_statement_lookup): Optimise creation of SPECIAL
	sections.
	(lang_insert_orphan): Add "constraint" param.  Pass to
	lang_enter_output_section_statement.
	(init_os): Don't use an existing bfd section for SPECIAL sections.
	(lang_place_orphans): Don't rename unique output sections, instead
	mark their output section statements SPECIAL.
	* ldlang.h (lang_insert_orphan): Update prototype.
	(unique_section_p): Delete.
	* emultempl/beos.em (place_orphan): Add "constraint" param.
	* emultempl/elf32.em (place_orphan): Likewise.  Don't match existing
	output sections if set.
	* emultempl/pe.em (place_orphan): Likewise.
	* emultempl/pep.em (place_orphan): Likewise.
	* emultempl/mmo.em (mmo_place_orphan): Update.
	* emultempl/spuelf.em (spu_place_special_section): Update.
@
text
@d65 1
a65 1
static bfd_boolean gld${EMULATION_NAME}_place_orphan
d1638 1
a1638 1
static bfd_boolean
d1726 1
a1726 1
      return TRUE;
d1749 3
a1751 3
      lang_add_section (&hold[orphan_text].os->children, s,
			hold[orphan_text].os);
      return TRUE;
d1801 1
a1801 3
  lang_insert_orphan (s, secname, constraint, after, place, NULL, NULL);

  return TRUE;
@


1.193
log
@bfd/
	* elf.c (bfd_elf_set_group_contents): Assign sh_info for ld -r when
	the signature symbol is global.
	* elflink.c (elf_link_input_bfd): Ensure group signature symbol
	is output when ld -r.  Set group sh_info when local.
	* linker.c (default_indirect_link_order): Handle group sections
	specially.
ld/
	* ldemul.c (ldemul_place_orphan): Add "name" param.
	* ldemul.h (ldemul_place_orphan): Update prototype.
	(struct ld_emulation_xfer_struct <place_orphan>): Likewise.
	* ldlang.c (lang_place_orphans): Generate unique section names here..
	* emultempl/elf32.em (place_orphan): ..rather than here.  Don't
	directly use an existing output section statement that has no
	bfd section.
	* emultempl/pe.em (place_orphan): Likewise.
	* emultempl/pep.em (place_orphan): Likewise.
	* emultempl/beos.em (place_orphan): Adjust.
	* emultempl/spuelf.em (spu_place_special_section): Adjust
	place_orphan call.
	* emultempl/genelf.em (gld${EMULATION_NAME}_after_open): New function.
	(LDEMUL_AFTER_OPEN): Define.
@
text
@d65 2
a66 1
static bfd_boolean gld${EMULATION_NAME}_place_orphan (asection *, const char *);
d1639 3
a1641 1
gld${EMULATION_NAME}_place_orphan (asection *s, const char *secname)
d1711 2
a1712 3
  os = lang_output_section_find (secname);

  if (os != NULL
d1801 1
a1801 1
  lang_insert_orphan (s, secname, after, place, NULL, NULL);
@


1.192
log
@	* ldlang.h (lang_output_section_find): Define.
	(lang_output_section_statement_lookup): Update prototype.
	* ldlang.c (lang_output_section_find,
	lang_output_section_statement_lookup_1): Merge into..
	(lang_output_section_statement_lookup): ..here.  Update all callers.
	(process_insert_statements): Set constraint negative
	for output section statements we might be inserting.  Make error
	fatal on not finding insertion section.
	(lang_output_section_find): Rather than comparing
	output_section_statement.constraint against -1, test whether
	it is postive.
	(lang_output_section_statement_lookup_1): Likewise.
	(output_prev_sec_find, strip_excluded_output_sections): Likewise.
	(lang_record_phdrs): Likewise.
	* emultempl/elf32.em (output_rel_find): Likewise.
	* NEWS: Mention INSERT.
@
text
@d65 1
a65 1
static bfd_boolean gld${EMULATION_NAME}_place_orphan (asection *s);
d1638 1
a1638 1
gld${EMULATION_NAME}_place_orphan (asection *s)
a1675 1
  const char *secname;
a1681 2
  secname = bfd_get_section_name (s->owner, s);

d1707 2
a1708 4
  if (isdyn || (!config.unique_orphan_sections && !unique_section_p (s)))
    {
      /* Look through the script to see where to place this section.  */
      os = lang_output_section_find (secname);
d1710 15
a1724 17
      if (os != NULL
	  && (os->bfd_section == NULL
	      || os->bfd_section->flags == 0
	      || (_bfd_elf_match_sections_by_type (link_info.output_bfd,
						   os->bfd_section,
						   s->owner, s)
		  && ((s->flags ^ os->bfd_section->flags)
		      & (SEC_LOAD | SEC_ALLOC)) == 0)))
	{
	  /* We already have an output section statement with this
	     name, and its bfd section, if any, has compatible flags.
	     If the section already exists but does not have any flags
	     set, then it has been created by the linker, probably as a
	     result of a --section-start command line switch.  */
	  lang_add_section (&os->children, s, os);
	  return TRUE;
	}
d1744 1
a1744 1
      && CONST_STRNEQ (secname, ".gnu.warning.")
a1798 12
  /* Choose a unique name for the section.  This will be needed if the
     same section name appears in the input file with different
     loadable or allocatable characteristics.  */
  if (bfd_get_section_by_name (link_info.output_bfd, secname) != NULL)
    {
      static int count = 1;
      secname = bfd_get_unique_section_name (link_info.output_bfd,
					     secname, &count);
      if (secname == NULL)
	einfo ("%F%P: place_orphan failed: %E\n");
    }

@


1.192.2.1
log
@backport 2008-10-03  Alan Modra  <amodra@@bigpond.net.au>
@
text
@d65 1
a65 1
static bfd_boolean gld${EMULATION_NAME}_place_orphan (asection *, const char *);
d1638 1
a1638 1
gld${EMULATION_NAME}_place_orphan (asection *s, const char *secname)
d1676 1
d1683 2
d1710 4
a1713 2
  /* Look through the script to see where to place this section.  */
  os = lang_output_section_find (secname);
d1715 17
a1731 15
  if (os != NULL
      && os->bfd_section != NULL
      && (os->bfd_section->flags == 0
	  || (_bfd_elf_match_sections_by_type (link_info.output_bfd,
					       os->bfd_section, s->owner, s)
	      && ((s->flags ^ os->bfd_section->flags)
		  & (SEC_LOAD | SEC_ALLOC)) == 0)))
    {
      /* We already have an output section statement with this
	 name, and its bfd section has compatible flags.
	 If the section already exists but does not have any flags
	 set, then it has been created by the linker, probably as a
	 result of a --section-start command line switch.  */
      lang_add_section (&os->children, s, os);
      return TRUE;
d1751 1
a1751 1
      && CONST_STRNEQ (s->name, ".gnu.warning.")
d1806 12
@


1.192.2.2
log
@backport 2008-10-04  Alan Modra  <amodra@@bigpond.net.au>
@
text
@d65 1
a65 2
static bfd_boolean gld${EMULATION_NAME}_place_orphan
  (asection *, const char *, int);
d1638 1
a1638 3
gld${EMULATION_NAME}_place_orphan (asection *s,
				   const char *secname,
				   int constraint)
d1708 3
a1710 2
  if (constraint == 0
      && (os = lang_output_section_find (secname)) != NULL
d1799 1
a1799 1
  lang_insert_orphan (s, secname, constraint, after, place, NULL, NULL);
@


1.191
log
@	* ldfile.c (ldfile_open_file_search): Use concat.
	(try_open): Don't use a fixed size pathname buffer.
	(ldfile_find_command_file): Likewise.
	* emultempl/elf32.em (gld${EMULATION_NAME}_open_dynamic_archive): If
	using EXTRA_SHLIB_EXTENSION, don't open twice.
@
text
@d1586 1
a1586 1
      if (lookup->constraint != -1
@


1.190
log
@include/
	* bfdlink.h (struct bfd_link_hash_table): Delete creator field.
	(struct bfd_link_info): Add output_bfd.
bfd/
	* elflink.c: Replace all accesses to hash->creator field with
	output_bfd->xvec.
	* cofflink.c: Likewise.
	* coff-h8300.c: Likewise.
	* ecoff.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfxx-mips.c: Likewise.
	* i386linux.c: Likewise.
	* m68klinux.c: Likewise.
	* sparclinux.c: Likewise.
	* sunos.c: Likewise.
	* xcofflink.c: Likewise.
	* linker.c: Likewise.
	(_bfd_link_hash_table_init): Don't store creator.
ld/
	* ldmain.h (output_bfd): Delete.
	* ldmain.c (output_bfd): Delete.
	Replace all occurrences of output_bfd with link_info.output_bfd.
	* ldcref.c: Likewise.
	* ldctor.c: Likewise.
	* ldemul.c: Likewise.
	* ldexp.c: Likewise.
	* ldfile.c: Likewise.
	* ldlang.c: Likewise.
	* ldmisc.c: Likewise.
	* ldwrite.c: Likewise.
	* pe-dll.c: Likewise.
	* emultempl/aix.em: Likewise.
	* emultempl/alphaelf.em: Likewise.
	* emultempl/armcoff.em: Likewise.
	* emultempl/armelf.em: Likewise.
	* emultempl/avrelf.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/elf-generic.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/irix.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68hc1xelf.em: Likewise.
	* emultempl/mmix-elfnmmo.em: Likewise.
	* emultempl/mmo.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/scoreelf.em: Likewise.
	* emultempl/sh64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/vanilla.em: Likewise.
	* emultempl/vxworks.em: Likewise.
	* emultempl/xtensaelf.em: Likewise.
	* emultempl/z80.em: Likewise.
	* ldlang.c (open_output): Don't return output, instead write
	link_info_output_bfd directly.
	* emultempl/alphaelf.em: Replace occurrences of link_info.hash->creator
	with link_info.output_bfd->xvec.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
@
text
@d1519 3
a1521 2
    sprintf (string, "%s/lib%s%s%s", search->name,
	     filename, arch, EXTRA_SHLIB_EXTENSION);
d1529 3
@


1.189
log
@	* ldlang.c (new_afile): Don't pass unadorned NULL to concat.
	* ldfile.c (ldfile_add_library_path): Likewise.
	* emultempl/elf32.em (check_ld_elf_hints, check_ld_so_conf): Likewise.
	* emultempl/lnk960.em (lnk960_before_parse): Likewise.
	* emultempl/spuelf.em (embedded_spu_file): Likewise.
@
text
@d310 1
a310 1
  abfd = bfd_openr (name, bfd_get_target (output_bfd));
d325 1
a325 1
  if (abfd->xvec != output_bfd->xvec)
d1067 1
a1067 1
	      struct elf_obj_tdata *t = elf_tdata (output_bfd);
d1130 1
a1130 1
  needed = bfd_elf_get_needed_list (output_bfd, &link_info);
d1234 1
a1234 1
	  rp = bfd_elf_get_runpath_list (output_bfd, &link_info);
d1325 2
a1326 1
	  if (!bfd_elf_record_link_assignment (output_bfd, &link_info,
d1395 1
a1395 1
    _bfd_elf_tls_setup (output_bfd, &link_info);
d1408 1
a1408 1
	 (output_bfd, command_line.soname, rpath,
d1476 1
a1476 1
  if (!bfd_elf_size_dynsym_hash_dynstr (output_bfd, &link_info))
d1714 1
a1714 1
	      || (_bfd_elf_match_sections_by_type (output_bfd,
d1805 1
a1805 1
  if (bfd_get_section_by_name (output_bfd, secname) != NULL)
d1808 2
a1809 1
      secname = bfd_get_unique_section_name (output_bfd, secname, &count);
d1827 2
a1828 1
  bfd_boolean need_layout = bfd_elf_discard_info (output_bfd, &link_info);
@


1.188
log
@2007-09-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* emultempl/elf32.em: Check DF_BIND_NOW instead of DT_BIND_NOW.
@
text
@d16 1
a16 1
   2002, 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.
d559 1
a559 1
      tmppath = concat (ld_sysroot, _PATH_ELF_HINTS, NULL);
d779 2
a780 1
      tmppath = concat (ld_sysroot, "${prefix}/etc/ld.so.conf", NULL);
d784 2
a785 1
	  tmppath = concat (ld_sysroot, "/etc/ld.so.conf", NULL);
@


1.187
log
@	PR ld/5025
	* emultempl/elf32.em (write_build_id_section): Correct test for
	"missing" .note.gnu.build-id.  Downgrade error to a warning if
	it has been discarded.
@
text
@d1865 1
a1865 1
echo '             && (link_info.flags & DT_BIND_NOW)) return' >> e${EMULATION_NAME}.c
d1877 1
a1877 1
echo '             && (link_info.flags & DT_BIND_NOW)) return' >> e${EMULATION_NAME}.c
d1887 1
a1887 1
echo '             && (link_info.flags & DT_BIND_NOW)) return' >> e${EMULATION_NAME}.c
d1921 1
a1921 1
	   && link_info.relro && (link_info.flags & DT_BIND_NOW))
d1936 1
a1936 1
	   && link_info.relro && (link_info.flags & DT_BIND_NOW))
d1950 1
a1950 1
	   && (link_info.flags & DT_BIND_NOW))
@


1.186
log
@	* emultempl/alphaelf.em: Format option help.
	* emultempl/armcoff.em: Likewise.
	* emultempl/armelf.em: Likewise.
	* emultempl/avrelf.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/ia64elf.em: Likewise.
	* emultempl/m68hc1xelf.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/scoreelf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/ticoff.em: Likewise.
	* emultempl/vxworks.em: Likewise.
	* emultempl/xtensaelf.em: Likewise.
@
text
@d939 1
a939 1
  if (asec->output_section == NULL)
d941 3
a943 2
      einfo (_("%P: .note.gnu.build-id section missing"));
      return FALSE;
@


1.185
log
@	PR 4923
	* emultempl/elf32.em (after_open): Return immediately when
        non-ELF output.
@
text
@d2195 2
a2196 1
  fprintf (file, _("  --build-id[=STYLE]\tGenerate build ID note\n"));
d2201 40
a2240 20
  fprintf (file, _("  -Bgroup\t\tSelects group name lookup rules for DSO\n"));
  fprintf (file, _("  --disable-new-dtags\tDisable new dynamic tags\n"));
  fprintf (file, _("  --enable-new-dtags\tEnable new dynamic tags\n"));
  fprintf (file, _("  --eh-frame-hdr\tCreate .eh_frame_hdr section\n"));
  fprintf (file, _("  --hash-style=STYLE\tSet hash style to sysv, gnu or both\n"));
  fprintf (file, _("  -z combreloc\t\tMerge dynamic relocs into one section and sort\n"));
  fprintf (file, _("  -z defs\t\tReport unresolved symbols in object files.\n"));
  fprintf (file, _("  -z execstack\t\tMark executable as requiring executable stack\n"));
  fprintf (file, _("  -z initfirst\t\tMark DSO to be initialized first at runtime\n"));
  fprintf (file, _("  -z interpose\t\tMark object to interpose all DSOs but executable\n"));
  fprintf (file, _("  -z lazy\t\tMark object lazy runtime binding (default)\n"));
  fprintf (file, _("  -z loadfltr\t\tMark object requiring immediate process\n"));
  fprintf (file, _("  -z muldefs\t\tAllow multiple definitions\n"));
  fprintf (file, _("  -z nocombreloc\tDon't merge dynamic relocs into one section\n"));
  fprintf (file, _("  -z nocopyreloc\tDon't create copy relocs\n"));
  fprintf (file, _("  -z nodefaultlib\tMark object not to use default search paths\n"));
  fprintf (file, _("  -z nodelete\t\tMark DSO non-deletable at runtime\n"));
  fprintf (file, _("  -z nodlopen\t\tMark DSO not available to dlopen\n"));
  fprintf (file, _("  -z nodump\t\tMark DSO not available to dldump\n"));
  fprintf (file, _("  -z noexecstack\tMark executable as not requiring executable stack\n"));
d2245 2
a2246 1
  fprintf (file, _("  -z norelro\t\tDon't create RELRO program header\n"));
d2251 5
a2255 2
  fprintf (file, _("  -z now\t\tMark object non-lazy runtime binding\n"));
  fprintf (file, _("  -z origin\t\tMark object requiring immediate \$ORIGIN processing\n\t\t\t  at runtime\n"));
d2260 2
a2261 1
  fprintf (file, _("  -z relro\t\tCreate RELRO program header\n"));
d2266 6
a2271 3
  fprintf (file, _("  -z max-page-size=SIZE\tSet maximum page size to SIZE\n"));
  fprintf (file, _("  -z common-page-size=SIZE\n\t\t\tSet common page size to SIZE\n"));
  fprintf (file, _("  -z KEYWORD\t\tIgnored for Solaris compatibility\n"));
@


1.184
log
@ld/
	* ldlang.c (lang_insert_orphan): When searching through linker
	script to place an orphan, don't stop on statements that appear
	outside of SECTIONS.
	* emultempl/elf32.em (output_rel_find): Prefer read-only alloc
	sections over read/write alloc sections.
ld/testsuite/
	* ld-elf/weak-dyn-1.rd: Adjust.
@
text
@d1035 5
d1084 3
d1088 1
a1088 2
      && ! link_info.traditional_format
      && ! link_info.relocatable)
d1090 2
a1091 1
      struct elf_link_hash_table *htab;
d1093 7
a1099 2
      htab = elf_hash_table (&link_info);
      if (is_elf_hash_table (htab))
d1101 1
a1101 2
	  bfd *abfd;
	  asection *s;
d1103 10
a1112 21
	  for (abfd = link_info.input_bfds; abfd; abfd = abfd->link_next)
	    {
	      s = bfd_get_section_by_name (abfd, ".eh_frame");
	      if (s && s->size > 8 && !bfd_is_abs_section (s->output_section))
		 break;
	    }
	  if (abfd)
	    {
	      const struct elf_backend_data *bed;

	      bed = get_elf_backend_data (abfd);
	      s = bfd_make_section_with_flags (abfd, ".eh_frame_hdr",
					       bed->dynamic_sec_flags
					       | SEC_READONLY);
	      if (s != NULL
		 && bfd_set_section_alignment (abfd, s, 2))
		htab->eh_info.hdr_sec = s;
	      else
		einfo ("%P: warning: Cannot create .eh_frame_hdr section,"
		       " --eh-frame-hdr ignored.\n");
	    }
a1115 4
  /* We only need to worry about this when doing a final link.  */
  if (link_info.relocatable || !link_info.executable)
    return;

d1125 2
@


1.184.2.1
log
@	PR 4923
	* emultempl/elf32.em (after_open): Return immediately when
        non-ELF output.
@
text
@a1034 5
  struct elf_link_hash_table *htab;

  htab = elf_hash_table (&link_info);
  if (!is_elf_hash_table (htab))
    return;
a1078 3
  if (link_info.relocatable)
    return;

d1080 2
a1081 1
      && !link_info.traditional_format)
d1083 1
a1083 2
      bfd *abfd;
      asection *s;
d1085 2
a1086 1
      for (abfd = link_info.input_bfds; abfd; abfd = abfd->link_next)
d1088 12
a1099 7
	  s = bfd_get_section_by_name (abfd, ".eh_frame");
	  if (s && s->size > 8 && !bfd_is_abs_section (s->output_section))
	    break;
	}
      if (abfd)
	{
	  const struct elf_backend_data *bed;
d1101 11
a1111 10
	  bed = get_elf_backend_data (abfd);
	  s = bfd_make_section_with_flags (abfd, ".eh_frame_hdr",
					   bed->dynamic_sec_flags
					   | SEC_READONLY);
	  if (s != NULL
	      && bfd_set_section_alignment (abfd, s, 2))
	    htab->eh_info.hdr_sec = s;
	  else
	    einfo ("%P: warning: Cannot create .eh_frame_hdr section,"
		   " --eh-frame-hdr ignored.\n");
d1115 4
a1127 2
  if (!link_info.executable)
    return;
@


1.183
log
@2007-07-19  Roland McGrath  <roland@@redhat.com>

	* genscripts.sh (source_em, fragment): New sh functions.
	Truncate e${EMULATION_NAME}.c file before .em script fills it.
	Use source_em in place of . for the .em script.
	* emultempl/generic.em: Use fragment and source_em functions.
	* emultempl/aix.em: Likewise.
	* emultempl/alphaelf.em: Likewise.
	* emultempl/armcoff.em: Likewise.
	* emultempl/armelf.em: Likewise.
	* emultempl/avrelf.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/cr16elf.em: Likewise.
	* emultempl/crxelf.em: Likewise.
	* emultempl/elf-generic.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/genelf.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/gld960c.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/ia64elf.em: Likewise.
	* emultempl/irix.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68hc1xelf.em: Likewise.
	* emultempl/m68kcoff.em: Likewise.
	* emultempl/m68kelf.em: Likewise.
	* emultempl/mipsecoff.em: Likewise.
	* emultempl/mipself.em: Likewise.
	* emultempl/mmix-elfnmmo.em: Likewise.
	* emultempl/mmixelf.em: Likewise.
	* emultempl/mmo.em: Likewise.
	* emultempl/needrelax.em: Likewise.
	* emultempl/netbsd.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/scoreelf.em: Likewise.
	* emultempl/sh64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/ticoff.em: Likewise.
	* emultempl/vanilla.em: Likewise.
	* emultempl/vxworks.em: Likewise.
	* emultempl/xtensaelf.em: Likewise.
	* emultempl/z80.em: Likewise.
@
text
@d1570 1
d1605 5
a1609 1
	last_alloc = lookup;
d1618 3
@


1.182
log
@2007-07-18  Roland McGrath  <roland@@redhat.com>

	* emultempl/elf32.em (gld${EMULATION_NAME}_write_build_id_section):
	Use ASEC->contents for CONTENTS when missing, and allocate
	ASEC->size if needed.
@
text
@d11 1
a11 1
cat >e${EMULATION_NAME}.c <<EOF
d73 1
a73 1
  cat >>e${EMULATION_NAME}.c <<EOF
d84 1
a84 1
. ${srcdir}/emultempl/elf-generic.em
d86 1
a86 1
. ${srcdir}/emultempl/${EXTRA_EM_FILE}.em
d96 1
a96 1
cat >>e${EMULATION_NAME}.c <<EOF
d110 1
a110 1
cat >>e${EMULATION_NAME}.c <<EOF
d147 1
a147 1
cat >>e${EMULATION_NAME}.c <<EOF
d366 1
a366 1
    cat >>e${EMULATION_NAME}.c <<EOF
d383 1
a383 1
cat >>e${EMULATION_NAME}.c <<EOF
d496 1
a496 1
  cat >>e${EMULATION_NAME}.c <<EOF
d539 1
a539 1
      cat >>e${EMULATION_NAME}.c <<EOF
d601 1
a601 1
      cat >>e${EMULATION_NAME}.c <<EOF
d811 1
a811 1
cat >>e${EMULATION_NAME}.c <<EOF
d863 1
a863 1
cat >>e${EMULATION_NAME}.c <<EOF
d1191 1
a1191 1
cat >>e${EMULATION_NAME}.c <<EOF
d1196 1
a1196 1
cat >>e${EMULATION_NAME}.c <<EOF
d1201 1
a1201 1
cat >>e${EMULATION_NAME}.c <<EOF
d1208 1
a1208 1
cat >>e${EMULATION_NAME}.c <<EOF
d1215 1
a1215 1
cat >>e${EMULATION_NAME}.c <<EOF
d1230 1
a1230 1
cat >>e${EMULATION_NAME}.c <<EOF
d1250 1
a1250 1
      cat >>e${EMULATION_NAME}.c <<EOF
d1259 1
a1259 1
      cat >>e${EMULATION_NAME}.c <<EOF
d1267 1
a1267 1
cat >>e${EMULATION_NAME}.c <<EOF
d1285 1
a1285 1
cat >>e${EMULATION_NAME}.c <<EOF
d1299 1
a1299 1
cat >>e${EMULATION_NAME}.c <<EOF
d1380 1
a1380 1
cat >>e${EMULATION_NAME}.c <<EOF
d1481 1
a1481 1
cat >>e${EMULATION_NAME}.c <<EOF
d1560 1
a1560 1
cat >>e${EMULATION_NAME}.c <<EOF
d1810 1
a1810 1
cat >>e${EMULATION_NAME}.c <<EOF
d1824 1
a1824 1
cat >>e${EMULATION_NAME}.c <<EOF
d1837 1
a1837 1
cat >>e${EMULATION_NAME}.c <<EOF
d1891 1
a1891 1
cat >>e${EMULATION_NAME}.c <<EOF
d1904 1
a1904 1
cat >>e${EMULATION_NAME}.c <<EOF
d1911 1
a1911 1
cat >>e${EMULATION_NAME}.c <<EOF
d1919 1
a1919 1
cat >>e${EMULATION_NAME}.c <<EOF
d1926 1
a1926 1
cat >>e${EMULATION_NAME}.c <<EOF
d1934 1
a1934 1
cat >>e${EMULATION_NAME}.c <<EOF
d1940 1
a1940 1
cat >>e${EMULATION_NAME}.c <<EOF
d1948 1
a1948 1
cat >>e${EMULATION_NAME}.c <<EOF
d1960 1
a1960 1
cat >>e${EMULATION_NAME}.c <<EOF
d1965 1
a1965 1
cat >>e${EMULATION_NAME}.c <<EOF
d1986 1
a1986 1
cat >>e${EMULATION_NAME}.c <<EOF
d1997 1
a1997 1
cat >>e${EMULATION_NAME}.c <<EOF
d2002 1
a2002 1
cat >>e${EMULATION_NAME}.c <<EOF
d2038 1
a2038 1
cat >>e${EMULATION_NAME}.c <<EOF
d2131 1
a2131 1
cat >>e${EMULATION_NAME}.c <<EOF
d2139 1
a2139 1
cat >>e${EMULATION_NAME}.c <<EOF
d2169 1
a2169 1
cat >>e${EMULATION_NAME}.c <<EOF
d2174 1
a2174 1
cat >>e${EMULATION_NAME}.c <<EOF
d2183 1
a2183 1
cat >>e${EMULATION_NAME}.c <<EOF
d2192 1
a2192 1
cat >>e${EMULATION_NAME}.c <<EOF
d2216 1
a2216 1
cat >>e${EMULATION_NAME}.c <<EOF
d2221 1
a2221 1
cat >>e${EMULATION_NAME}.c <<EOF
d2227 1
a2227 1
cat >>e${EMULATION_NAME}.c <<EOF
d2232 1
a2232 1
cat >>e${EMULATION_NAME}.c <<EOF
d2240 1
a2240 1
cat >>e${EMULATION_NAME}.c <<EOF
d2245 1
a2245 1
cat >>e${EMULATION_NAME}.c <<EOF
d2250 1
a2250 1
cat >>e${EMULATION_NAME}.c <<EOF
d2256 1
a2256 1
cat >>e${EMULATION_NAME}.c <<EOF
d2261 1
a2261 1
cat >>e${EMULATION_NAME}.c <<EOF
d2267 1
a2267 1
cat >>e${EMULATION_NAME}.c <<EOF
@


1.181
log
@2007-07-13  Roland McGrath  <roland@@redhat.com>

	* emultempl/elf32.em (struct build_id_info): New type.
	(gld${EMULATION_NAME}_id_note_section_size): New function.
	(gld${EMULATION_NAME}_write_build_id_section): New function.
	(gld${EMULATION_NAME}_after_open): Use them.
	(DEFAULT_BUILD_ID_STYLE): Change to "sha1".
	* ld.texinfo (Options): Mention --build-id=sha1.
@
text
@d948 3
a950 4
      ASSERT (asec->output_offset == 0);
      i_shdr->contents = xcalloc (i_shdr->sh_size, 1);
      if (i_shdr->contents == NULL)
	return FALSE;
d952 2
a953 1
  contents = i_shdr->contents + asec->output_offset;
d1022 4
a1025 3
  size = i_shdr->sh_size;
  return (bfd_seek (abfd, i_shdr->sh_offset, SEEK_SET) == 0
	  && bfd_bwrite (i_shdr->contents, size, abfd) == size);
@


1.180
log
@2007-07-09  Roland McGrath  <roland@@redhat.com>

	* emultempl/elf32.em (gld${EMULATION_NAME}_add_option): Add --build-id.
	(gld${EMULATION_NAME}_handle_option): Handle --build-id.
	(gld${EMULATION_NAME}_list_options): List --build-id.
	(gld${EMULATION_NAME}_after_open): If --build-id was given,
	synthesize a ".note.gnu.build-id" section and cache it in elf_tdata.
	* ld.texinfo (Options): Describe --build-id.
	* NEWS: Mention --build-id.
@
text
@d44 3
d865 163
d1043 1
a1043 1
      size = _bfd_id_note_section_size (abfd, &link_info);
d1059 3
a1061 2
	      t->emit_note_gnu_build_id = link_info.emit_note_gnu_build_id;
	      t->note_gnu_build_id_sec = s;
d1064 3
d2012 1
a2012 1
#define DEFAULT_BUILD_ID_STYLE	"md5"
@


1.179
log
@Update sources to GPLv3
@
text
@d869 39
d1802 1
d1811 1
d1842 2
d1852 12
d2017 1
@


1.178
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d20 1
a20 1
This file is part of GLD, the Gnu Linker.
d22 14
a35 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.177
log
@ld/
	* ld.h (ld_config_type): Add rpath_separator.
	* ldmain.c (main): Initialize it.
	* lexsup.c (parse_args): Honor config.rpath_separator.
	* emultempl/elf32.em (gld${EMULATION_NAME}_search_needed): Likewise.
	(gld${EMULATION_NAME}_add_sysroot): Likewise.
	(gld${EMULATION_NAME}_parse_ld_so_conf): Use config.rpath_separator
	rather than ':' when building the path.
	* emultempl/vxworks.em (vxworks_before_parse): New function.
	Override config.rpath_separator.
	(LDEMUL_AFTER_OPEN): Do not change if EXTRA_EM_FILE has been
	set to gld${EMULATION_NAME}_after_open; #define that identifier
	to vxworks_foo instead.
	(LDEMUL_BEFORE_PARSE): Override in the same way as LDEMUL_AFTER_OPEN.

ld/testsuite/
	* ld-vxworks/rpath-1.s, ld-vxworks/rpath-1.d,
	* ld-vxworks/vxworks.exp: New files.
@
text
@d16 1
a16 1
   2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
d38 1
a38 1
#include "config.h"
a39 1
#include "sysdep.h"
@


1.176
log
@ld/

2007-01-19  Jakub Jelinek  <jakub@@redhat.com>
	    H.J. Lu  <hongjiu.lu@@intel.com>

	* emultempl/elf32.em (handle_option): Make sure -z max-page-size
	or -z common-page-size argument is a power of 2.  Call
	bfd_emul_set_maxpagesize and bfd_emul_set_commonpagesize.

2007-01-19  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldmain.c (main): Don't call bfd_emul_set_maxpagesize nor
	bfd_emul_set_commonpagesize.

ld/testsuite/

2007-01-19  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-elf/maxpage3.t: New file.
	* ld-elf/maxpage3a.d: Likewise.
	* ld-elf/maxpage3b.d: Likewise.
	* ld-elf/maxpage3c.d: Likewise.
@
text
@d462 1
a462 1
      s = strchr (path, ':');
d495 2
a496 1
/* Add the sysroot to every entry in a colon-separated path.  */
d508 1
a508 1
    if (path[i++] == ':')
d520 1
a520 1
    if (path[i] == ':')
d749 1
a749 1
	      info->path[info->len++] = ':';
@


1.175
log
@bfd/
2006-12-04  Jan Beulich  <jbeulich@@novell.com>

	* elflink.c (_bfd_elf_link_create_dynamic_sections): Don't create
	.eh_frame_hdr section from here anymore.
	(bfd_elf_size_dynamic_sections): Call _bfd_elf_maybe_strip_eh_frame_hdr
	a little earlier.

ld/
2006-12-04  Jan Beulich  <jbeulich@@novell.com>

	* emultempl/elf32.em (gld${EMULATION_NAME}_after_open): Create
	.eh_frame_hdr section here.

ld/testsuite/
2006-12-04  Jan Beulich  <jbeulich@@novell.com>

	* ld-elf/eh-frame-hdr.d: New.
	* ld-elf/eh-frame-hdr.s: New.
	* ld-ia64/tlsbin.dd, ld-ia64/tlsbin.sd: Don't depend on exact linkage
	table layout.
@
text
@d1918 1
a1918 1
	  if (*end)
d1921 2
d1928 2
a1929 1
	  if (*end)
d1932 3
@


1.174
log
@ld/
	* emultempl/elf32.em (gld*_before_allocation): Adjust output section
	size for warning sections.
ld/testsuite/
	* ld-elf/group.ld: Handle .rodata.brlt for powerpc64.
@
text
@d868 36
@


1.173
log
@	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation):
	Don't prepend "warning" to the message.
	* testsuite/ld-elf/warn2.d: New.
	* testsuite/ld-elf/symbol2w.s: New.
	* testsuite/ld-elf/symbol2ref.s: New.
@
text
@d1207 9
a1215 2
	/* Clobber the section size, so that we don't waste copying the
	   warning into the output file.  */
d1218 2
a1219 2
	/* Also set SEC_EXCLUDE, so that symbols defined in the warning
	   section don't get copied to the output.  */
@


1.172
log
@bfd/
	* section.c (SEC_KEEP): Update comment.
	* bfd-in2.h: Regenerate.
	* elflink.c (bfd_elf_gc_sections): Ignore SEC_EXCLUDE sections.
	* merge.c (_bfd_merge_sections): Set SEC_KEEP on excluded sections.
	* stabs.c (_bfd_discard_section_stabs): Likewise.
	(_bfd_link_section_stabs): Likewise.  Simplify abs_section check.
ld/
	* ldlang.c (lang_map): Don't say SEC_LINKER_CREATED and SEC_KEEP
	sections have been discarded.
	(lang_do_version_exports_section): Set SEC_KEEP on export section.
	* emultempl/elf32.em (before_allocation): Set SEC_KEEP on warning
	sections.
@
text
@a1182 1
	bfd_size_type prefix_len;
a1184 1
	const char * gnu_warning_prefix = _("warning: ");
d1194 2
a1195 4
	prefix_len = strlen (gnu_warning_prefix);
	msg = xmalloc ((size_t) (prefix_len + sz + 1));
	strcpy (msg, gnu_warning_prefix);
	if (! bfd_get_section_contents (is->the_bfd, s,	msg + prefix_len,
d1199 1
a1199 1
	msg[prefix_len + sz] = '\0';
@


1.171
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d1217 1
a1217 1
	s->flags |= SEC_EXCLUDE;
@


1.170
log
@2006-09-05  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/3015
	* emultempl/elf32.em: Enable "-z relro" only if $COMMONPAGESIZE
	is defined.
@
text
@d368 1
a368 1
	      if (strncmp (l->name, "libc.so", 7) == 0)
d701 1
a701 1
      if (!strncmp (p, "include", 7) && (p[7] == ' ' || p[7] == '\t'))
d1329 1
a1329 1
	  && strncmp (".rel", lookup->name, 4) == 0)
d1438 1
a1438 1
      else if (strncmp (secname, ".rel", 4) == 0)
d1486 1
a1486 1
      && strncmp (secname, ".gnu.warning.", sizeof ".gnu.warning." - 1) == 0
d1505 1
a1505 1
	       || (!iself && strncmp (secname, ".note", 5) == 0)))
d1514 1
a1514 1
	    || (!iself && strncmp (secname, ".rel", 4) == 0))
d1874 1
a1874 1
      else if (strncmp (optarg, "max-page-size=", 14) == 0)
d1877 1
d1883 1
a1883 1
      else if (strncmp (optarg, "common-page-size=", 17) == 0)
@


1.169
log
@include/
	* bfdlink.h (struct bfd_link_info): Add emit_hash and
	emit_gnu_hash bitfields.
include/elf/
	* common.h (SHT_GNU_HASH, DT_GNU_HASH): Define.
ld/
	* scripttempl/elf.sc: Add .gnu.hash section.
	* emultempl/elf32.em (OPTION_HASH_STYLE): Define.
	(gld${EMULATION_NAME}_add_options): Register --hash-style option.
	(gld${EMULATION_NAME}_handle_option): Handle it.
	(gld${EMULATION_NAME}_list_options): Document it.
	* ldmain.c (main): Initialize emit_hash and emit_gnu_hash.
	* ld.texinfo: Document --hash-style option.
bfd/
	* elf.c (_bfd_elf_print_private_bfd_data): Handle DT_GNU_HASH.
	(bfd_section_from_shdr, elf_fake_sections, assign_section_numbers):
	Handle SHT_GNU_HASH.
	(special_sections_g): Include .gnu.hash section.
	(bfd_elf_gnu_hash): New function.
	* elf-bfd.h (bfd_elf_gnu_hash, _bfd_elf_hash_symbol): New prototypes.
	(struct elf_backend_data): Add elf_hash_symbol method.
	* elflink.c (_bfd_elf_link_create_dynamic_sections): Create .hash
	only if info->emit_hash, create .gnu.hash section if
	info->emit_gnu_hash.
	(struct collect_gnu_hash_codes): New type.
	(elf_collect_gnu_hash_codes, elf_renumber_gnu_hash_syms,
	_bfd_elf_hash_symbol): New functions.
	(compute_bucket_count): Don't compute HASHCODES array, instead add
	that and NSYMS as arguments.  Use bed->s->sizeof_hash_entry
	instead of bed->s->arch_size / 8.  Fix .hash size estimation.
	When not optimizing, use the number of hashed symbols rather than
	dynsymcount.
	(bfd_elf_size_dynamic_sections): Only add DT_HASH if info->emit_hash,
	and ADD DT_GNU_HASH if info->emit_gnu_hash.
	(bfd_elf_size_dynsym_hash_dynstr): Size .hash only if info->emit_hash,
	adjust compute_bucket_count caller.  Create and populate .gnu.hash
	section if info->emit_gnu_hash.
	(elf_link_output_extsym): Only populate .hash section if
	finfo->hash_sec != NULL.
	(bfd_elf_final_link): Adjust assertion.  Handle DT_GNU_HASH.
	* elfxx-target.h (elf_backend_hash_symbol): Define if not yet defined.
	(elfNN_bed): Add elf_backend_hash_symbol.
	* elf64-x86-64.c (elf64_x86_64_hash_symbol): New function.
	(elf_backend_hash_symbol): Define.
	* elf32-i386.c (elf_i386_hash_symbol): New function.
	(elf_backend_hash_symbol): Define.
binutils/
	* readelf.c (get_dynamic_type): Handle DT_GNU_HASH.
	(get_section_type_name): Handle SHT_GNU_HASH.
	(dynamic_info_DT_GNU_HASH): New variable.
	(process_dynamic_section): Handle DT_GNU_HASH.
	(process_symbol_table): Print also DT_GNU_HASH histogram.
ld/testsuite/
	* ld-powerpc/tlsso32.r: Adjust.
	* ld-powerpc/tlsso32.d: Adjust.
	* ld-powerpc/tlsso32.g: Adjust.
	* ld-powerpc/tlsso.r: Adjust.
	* ld-powerpc/tlsso.g: Adjust.
	* ld-powerpc/tlstocso.g: Adjust.
@
text
@d1862 4
d1870 4
d1939 4
d1944 4
d1950 4
d1955 4
@


1.168
log
@bfd/
	* elf-bfd.h: Formatting.
	(_bfd_elf_map_sections_to_segments): Declare.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame_hdr): Don't
	clear program_header_size.
	* elf.c (get_program_header_size): Move.  Don't use or set saved
	program_header_size here.
	(elf_modify_segment_map): New function.  Split out from..
	(assign_file_positions_for_load_sections): ..here.  Assert
	header size is correct.  Remove dead code.
	(_bfd_elf_map_sections_to_segments): Rename from
	map_sections_to_segments.  Make global.  Use get_program_header_size
	when we need estimate of header size.  Call elf_modify_segment_map.
	Set program_header_size.
	(print_segment_map): Delete.
	(_bfd_elf_sizeof_headers): If segment_map available, get the
	actual size.
	* elf32-arm.c (elf32_arm_symbian_modify_segment_map): Make safe
	for calling more than once.
	* elf32-bfin.c (elf32_bfinfdpic_modify_segment_map): Likewise.
	* elf32-frv.c (elf32_frvfdpic_modify_segment_map): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_modify_segment_map): Likewise.
	* elf32-i370.c (elf_backend_add_symbol_hook): Delete.
	(elf_backend_additional_program_headers): Delete.
	(elf_backend_modify_segment_map): Delete.
	* elf64-hppa.c (elf64_hppa_modify_segment_map): Convert to ISO C.
	* elfxx-ia64.c (elfNN_ia64_modify_segment_map): Likewise.
	* doc/bfdint.texi: Delete SIZEOF_HEADERS difficulties.
ld/
	* Makefile.am (ELF_DEPS): Define.  Use in emul file deps.  Fix
	many ELF emul file deps that incorrectly said they needed elf32.em
	instead of generic.em.  Add genelf.em as required.
	* Makefile.in: Regenerate.
	* ldlang.c (lang_process): Call ldemul_finish before
	lang_check_section_addresses.
	* emulparams/arcelf.sh: Generic elf target needs genelf.
	* emulparams/d30v_e.sh: Likewise.
	* emulparams/d30v_o.sh: Likewise.
	* emulparams/d30velf.sh: Likewise.
	* emulparams/elf32_dlx.sh: Likewise.
	* emulparams/elf32_i860.sh: Likewise.
	* emulparams/elf32fr30.sh: Likewise.
	* emulparams/elf32frv.sh: Likewise.
	* emulparams/elf32iq10.sh: Likewise.
	* emulparams/elf32iq2000.sh: Likewise.
	* emulparams/elf32mt.sh: Likewise.
	* emulparams/mn10200.sh: Likewise.
	* emulparams/or32.sh: Likewise.
	* emulparams/or32elf.sh: Likewise.
	* emulparams/pjelf.sh: Likewise.
	* emulparams/msp430all.sh: Likewise.  Extract common entries.
	* emulparams/pjlelf.sh: Include pjelf.sh.
	* emulparams/elf32frvfd.sh (EXTRA_EM_FILE): Unset.
	* emulparams/mn10300.sh (EXTRA_EM_FILE): Unset.
	* emultempl/elf-generic.em: New file.
	* emultempl/genelf.em: New file.
	* emultempl/elf32.em: Include elf-generic.em.
	(gld${EMULATION_NAME}_layout_sections_again): Delete.
	(gld${EMULATION_NAME}_finish): Call gld${EMULATION_NAME}_map_segments.
	* emultempl/hppaelf.em (hppaelf_layout_sections_again): Likewise.
	(gld${EMULATION_NAME}_finish): Rename from hppaelf_finish.  Call
	gld${EMULATION_NAME}_map_segments.
	(LDEMUL_FINISH): Update.
	* emultempl/mmo.em: Correct comment.  Include elf-bfd.h and
	source elf-generic.em.
	(mmo_finish): Call gld${EMULATION_NAME}_map_segments.
	* emultempl/ppc64elf.em (ppc_layout_sections_again): Likewise.
	(gld${EMULATION_NAME}_finish): Rename from ppc_finish.  Call
	gld${EMULATION_NAME}_map_segments.
	(LDEMUL_FINISH): Update.
ld/testsuite/
	* ld-elf/eh1.d: Update for fewer program headers.
	* ld-elf/eh2.d: Likewise.
	* ld-elf/eh3.d: Likewise.
@
text
@d1722 1
d1739 1
d1796 16
d1915 1
@


1.167
log
@	* ld.texinfo: Document new -z lazy option.
	* emultempl/elf32.em (gld${EMULATION_NAME}_handle_option): Handle
	new option.
	(gld${EMULATION_NAME}_list_options): Update help text.
@
text
@d63 1
a63 2
static void gld${EMULATION_NAME}_layout_sections_again (void);
static void gld${EMULATION_NAME}_finish (void) ATTRIBUTE_UNUSED;
d81 1
a1562 15
gld${EMULATION_NAME}_layout_sections_again (void)
{
  lang_reset_memory_regions ();

  /* Resize the sections.  */
  lang_size_sections (NULL, TRUE);

  /* Redo special stuff.  */
  ldemul_after_allocation ();

  /* Do the assignments again.  */
  lang_do_assignments ();
}

static void
d1565 1
a1565 2
  if (bfd_elf_discard_info (output_bfd, &link_info))
    gld${EMULATION_NAME}_layout_sections_again ();
d1567 1
@


1.166
log
@	* emultempl/elf32.em (global_found): Make it a pointer.
	(stat_needed, try_needed): Adjust.
	(check_needed): Don't skip non-loaded as-needed entries.  Only
	consider entries with both filename and the_bfd non-null.
	(after_open): Try loading non-loaded as-needed libs to satisfy
	DT_NEEDED libs.
@
text
@d1829 5
d1917 1
@


1.165
log
@bfd/

2006-05-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfd.c (bfd_emul_get_maxpagesize): New.
	(bfd_elf_set_pagesize): Likewise.
	(bfd_emul_set_maxpagesize): Likewise.
	(bfd_emul_get_commonpagesize): Likewise.
	(bfd_emul_set_commonpagesize): Likewise.
	* bfd-in2.h: Regenerated.

	* elf-bfd.h (elf_backend_data): Add commonpagesize.
	(xvec_get_elf_backend_data): New.
	(get_elf_backend_data): Use xvec_get_elf_backend_data.

	* elf32-arm.c (elf32_arm_vxworks_bed): Remove const.
	* elfxx-target.h (elfNN_bed): Likewise.

	* elf32-arm.c (ELF_COMMONPAGESIZE): Defined.
	* elf32-mips.c (ELF_COMMONPAGESIZE): Likewise.
	* elf32-ppc.c (ELF_COMMONPAGESIZE): Likewise.
	* elf32-sh.c (ELF_COMMONPAGESIZE): Likewise.
	* elf32-sh64.c (ELF_COMMONPAGESIZE): Likewise.
	* elf32-sparc.c (ELF_COMMONPAGESIZE): Likewise.
	* elf64-alpha.c (ELF_COMMONPAGESIZE): Likewise.
	* elf64-ppc.c (ELF_COMMONPAGESIZE): Likewise.
	* elf64-sparc.c (ELF_COMMONPAGESIZE): Likewise.
	* elf64-x86-64.c (ELF_COMMONPAGESIZE): Likewise.
	* elfn32-mips.c (ELF_COMMONPAGESIZE): Likewise.
	* elfxx-ia64.c (ELF_COMMONPAGESIZE): Likewise.

	* elfxx-target.h (ELF_COMMONPAGESIZE): Define if not defined.
	(elfNN_bed): Initialize commonpagesize with ELF_COMMONPAGESIZE.

	* targets.c (bfd_find_target): Support NULL abfd.

ld/

2006-05-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* emulparams/arcelf.sh (MAXPAGESIZE): Changed to
	"CONSTANT (MAXPAGESIZE)".
	* emulparams/armelf_nbsd.sh: Likewise.
	* emulparams/armelf_vxworks.sh: Likewise.
	* emulparams/armnto.sh: Likewise.
	* emulparams/armsymbian.sh: Likewise.
	* emulparams/crislinux.sh: Likewise.
	* emulparams/elf32_i860.sh: Likewise.
	* emulparams/elf32_i960.sh: Likewise.
	* emulparams/elf32am33lin.sh: Likewise.
	* emulparams/elf32bfinfd.sh: Likewise.
	* emulparams/elf32bmipn32-defs.sh: Likewise.
	* emulparams/elf32frvfd.sh: Likewise.
	* emulparams/elf32i370.sh: Likewise.
	* emulparams/elf32lppcnto.sh: Likewise.
	* emulparams/elf32mcore.sh: Likewise.
	* emulparams/elf32openrisc.sh: Likewise.
	* emulparams/elf32ppcnto.sh: Likewise.
	* emulparams/elf32ppcwindiss.sh: Likewise.
	* emulparams/elf32vax.sh: Likewise.
	* emulparams/elf32xc16x.sh: Likewise.
	* emulparams/elf32xc16xl.sh: Likewise.
	* emulparams/elf32xc16xs.sh: Likewise.
	* emulparams/elf64_aix.sh: Likewise.
	* emulparams/elf64hppa.sh: Likewise.
	* emulparams/elf64mmix.sh: Likewise.
	* emulparams/elf_i386_be.sh: Likewise.
	* emulparams/elf_i386_chaos.sh: Likewise.
	* emulparams/elf_i386_ldso.sh: Likewise.
	* emulparams/hppa64linux.sh: Likewise.
	* emulparams/hppalinux.sh: Likewise.
	* emulparams/hppaobsd.sh: Likewise.
	* emulparams/i386lynx.sh: Likewise.
	* emulparams/i386moss.sh: Likewise.
	* emulparams/i386nto.sh: Likewise.
	* emulparams/i386nw.sh: Likewise.
	* emulparams/m32relf_linux.sh: Likewise.
	* emulparams/m68kpsos.sh: Likewise.
	* emulparams/or32elf.sh: Likewise.
	* emulparams/pjelf.sh: Likewise.
	* emulparams/pjlelf.sh: Likewise.
	* emulparams/ppclynx.sh: Likewise.
	* emulparams/ppcnw.sh: Likewise.
	* emulparams/shelf32_nbsd.sh : Likewise.
	* emulparams/shelf_nbsd.sh: Likewise.
	* emulparams/shelf_nto.sh: Likewise.
	* emulparams/shlelf_nto.sh: Likewise.
	* emulparams/xtensa-config.sh: Likewise.

	* emulparams/armelf_linux.sh (MAXPAGESIZE): Changed to
	"CONSTANT (MAXPAGESIZE)".
	(COMMONPAGESIZE): Changed to "CONSTANT (COMMONPAGESIZE)".
	* emulparams/elf32_sparc.sh: Likewise.
	* emulparams/elf32bmip.sh: Likewise.
	* emulparams/elf32ppccommon.sh: Likewise.
	* emulparams/elf64_ia64.sh: Likewise.
	* emulparams/elf64_s390.sh: Likewise.
	* emulparams/elf64_sparc.sh: Likewise.
	* emulparams/elf64alpha.sh: Likewise.
	* emulparams/elf64ppc.sh: Likewise.
	* emulparams/elf_i386.sh: Likewise.
	* emulparams/elf_i386_vxworks.sh: Likewise.
	* emulparams/elf_s390.sh: Likewise.
	* emulparams/elf_x86_64.sh: Likewise.
	* emulparams/shlelf32_linux.sh: Likewise.
	* emulparams/shlelf_linux.sh: Likewise.

	* emulparams/elf32bmipn32.sh (COMMONPAGESIZE): Changed to
	"CONSTANT (COMMONPAGESIZE)".
	* emulparams/elf32btsmipn32.sh: Likewise.

	* emultempl/elf32.em (gld${EMULATION_NAME}_handle_option): Add
	"-z max-page-size=" and "-z common-page-size=".
	(gld${EMULATION_NAME}_list_options): Likewise.

	* ld.h (ld_config_type): Add maxpagesize and commonpagesize.

	* ld.texinfo: Document "-z max-page-size=" and
	"-z common-page-size=".

	* ldexp.c (exp_print_token): Handle CONSTANT.
	(fold_name): Likewise.
	* ldgram.y: Likewise.
	* ldlex.l: Likewise.

	* ldmain.c (main): Initiliaze config.maxpagesize and
	config.commonpagesize. Call bfd_emul_set_maxpagesize if
	config.maxpagesize isn't 0. Call bfd_emul_set_commonpagesize if
	config.commonpagesize config.maxpagesize isn't 0.
ld/testsuite/

2006-05-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-elf/binutils.exp: New file.
	* ld-elf/commonpage1.d: Likewise.
	* ld-elf/maxpage1.d: Likewise.
	* ld-elf/maxpage1.s: Likewise.
@
text
@d151 1
a151 1
static bfd_boolean global_found;
d232 1
a232 1
  if (global_found)
d236 4
a239 2
  if (s->as_needed
      && (bfd_elf_get_dyn_lib_class (s->the_bfd) & DYN_AS_NEEDED) != 0)
d259 1
a259 1
      global_found = TRUE;
d403 1
a403 1
  global_found = FALSE;
d405 1
a405 1
  if (global_found)
d574 1
a574 1
		
d590 1
a590 1
			       		     force);
d814 6
a819 1
  if (global_found)
d822 6
a827 5
  /* If this input file was an as-needed entry, and wasn't found to be
     needed at the stage it was linked, then don't say we have loaded it.  */
  if (s->as_needed
      && (s->the_bfd == NULL
	  || (bfd_elf_get_dyn_lib_class (s->the_bfd) & DYN_AS_NEEDED) != 0))
d830 1
a830 1
  if (s->filename != NULL)
d832 3
a834 1
      const char *f;
d836 5
a840 1
      if (strcmp (s->filename, global_needed->name) == 0)
d842 1
a842 1
	  global_found = TRUE;
a844 11

      if (s->search_dirs_flag)
	{
	  f = strrchr (s->filename, '/');
	  if (f != NULL
	      && strcmp (f + 1, global_needed->name) == 0)
	    {
	      global_found = TRUE;
	      return;
	    }
	}
d847 3
a849 1
  if (s->the_bfd != NULL)
d851 2
a852 9
      const char *soname;

      soname = bfd_elf_get_dt_soname (s->the_bfd);
      if (soname != NULL
	  && strcmp (soname, global_needed->name) == 0)
	{
	  global_found = TRUE;
	  return;
	}
d905 1
a905 1
      global_found = FALSE;
d907 3
a909 1
      if (global_found)
d918 9
d1737 1
a1737 1
  
@


1.164
log
@* emultempl/elf32.em: Add support for elf-hints.h on FreeBSD and Dragonfly targets.
* configure.in (AC_CHECK_HEADERS): Add elf-hints.h.
* Makefile.am (HFILES): Add elf-hints-local.h.
* elf-hints-local.h: New file.
* Makefile.in: Regenerate.
* configure: Regenerate.
@
text
@d1849 16
d1916 2
@


1.164.2.1
log
@	* emultempl/elf32.em (global_found): Make it a pointer.
	(stat_needed, try_needed): Adjust.
	(check_needed): Don't skip non-loaded as-needed entries.  Only
	consider entries with both filename and the_bfd non-null.
	(after_open): Try loading non-loaded as-needed libs to satisfy
	DT_NEEDED libs.
@
text
@d151 1
a151 1
static lang_input_statement_type *global_found;
d232 1
a232 1
  if (global_found != NULL)
d236 2
a237 4

  /* If this input file was an as-needed entry, and wasn't found to be
     needed at the stage it was linked, then don't say we have loaded it.  */
  if ((bfd_elf_get_dyn_lib_class (s->the_bfd) & DYN_AS_NEEDED) != 0)
d257 1
a257 1
      global_found = s;
d401 1
a401 1
  global_found = NULL;
d403 1
a403 1
  if (global_found != NULL)
d572 1
a572 1

d588 1
a588 1
					     force);
d812 1
a812 6
  const char *soname;

  /* Stop looking if we've found a loaded lib.  */
  if (global_found != NULL
      && (bfd_elf_get_dyn_lib_class (global_found->the_bfd)
	  & DYN_AS_NEEDED) == 0)
d815 5
a819 6
  if (s->filename == NULL || s->the_bfd == NULL)
    return;

  /* Don't look for a second non-loaded as-needed lib.  */
  if (global_found != NULL
      && (bfd_elf_get_dyn_lib_class (s->the_bfd) & DYN_AS_NEEDED) != 0)
d822 1
a822 1
  if (strcmp (s->filename, global_needed->name) == 0)
d824 1
a824 3
      global_found = s;
      return;
    }
d826 1
a826 5
  if (s->search_dirs_flag)
    {
      const char *f = strrchr (s->filename, '/');
      if (f != NULL
	  && strcmp (f + 1, global_needed->name) == 0)
d828 1
a828 1
	  global_found = s;
d831 11
d844 1
a844 3
  soname = bfd_elf_get_dt_soname (s->the_bfd);
  if (soname != NULL
      && strcmp (soname, global_needed->name) == 0)
d846 9
a854 2
      global_found = s;
      return;
d907 1
a907 1
      global_found = NULL;
d909 1
a909 3
      if (global_found != NULL
	  && (bfd_elf_get_dyn_lib_class (global_found->the_bfd)
	      & DYN_AS_NEEDED) == 0)
a917 9
      /* As-needed libs specified on the command line (or linker script)
	 take priority over libs found in search dirs.  */
      if (global_found != NULL)
	{
	  nn.name = global_found->filename;
	  if (gld${EMULATION_NAME}_try_needed (&nn, TRUE))
	    continue;
	}

d1728 1
a1728 1

@


1.163
log
@	* Makefile.am (GENSCRIPTS): Pass prefix.
	* Makefile.in: Regenerate.
	* genscripts.sh: Adjust for extra parameter.
	* emultempl/elf32.em (parse_ld_so_conf): Return true iff file
	exists.
	(check_ld_so_conf): Use ${prefix}/etc/ld.so.conf if it exists.
	* NEWS: Update.
@
text
@d532 62
d993 8
@


1.162
log
@2006-02-08  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/2290
	* NEWS: Updated for the Linux linker search order change.

	* emultempl/elf32.em (gld${EMULATION_NAME}_after_open): Call
	gld${EMULATION_NAME}_check_ld_so_conf before checking default
	search directories for DT_NEEDED entries.
@
text
@d16 1
a16 1
   2002, 2003, 2004, 2005 Free Software Foundation, Inc.
d544 1
a544 1
static void
d587 1
a587 1
static void
d596 1
a596 1
    return;
d694 1
a708 1
      tmppath = concat (ld_sysroot, "/etc/ld.so.conf", NULL);
d711 7
a717 1
      gld${EMULATION_NAME}_parse_ld_so_conf (&info, tmppath);
d719 1
@


1.162.2.1
log
@Merge changes between binutils-csl-2_17-branchpoint and
binutils-2_17, except for the addition of generated files to CVS.
@
text
@d16 1
a16 1
   2002, 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
d151 1
a151 1
static lang_input_statement_type *global_found;
d232 1
a232 1
  if (global_found != NULL)
d236 2
a237 4

  /* If this input file was an as-needed entry, and wasn't found to be
     needed at the stage it was linked, then don't say we have loaded it.  */
  if ((bfd_elf_get_dyn_lib_class (s->the_bfd) & DYN_AS_NEEDED) != 0)
d257 1
a257 1
      global_found = s;
d401 1
a401 1
  global_found = NULL;
d403 1
a403 1
  if (global_found != NULL)
a531 62
    *-*-freebsd* | *-*-dragonfly*)
      cat >>e${EMULATION_NAME}.c <<EOF
/* Read the system search path the FreeBSD way rather than the Linux way.  */
#ifdef HAVE_ELF_HINTS_H
#include <elf-hints.h>
#else
#include "elf-hints-local.h"
#endif

static bfd_boolean
gld${EMULATION_NAME}_check_ld_elf_hints (const char *name, int force)
{
  static bfd_boolean initialized;
  static char *ld_elf_hints;
  struct dt_needed needed;

  if (!initialized)
    {
      FILE *f;
      char *tmppath;

      tmppath = concat (ld_sysroot, _PATH_ELF_HINTS, NULL);
      f = fopen (tmppath, FOPEN_RB);
      free (tmppath);
      if (f != NULL)
	{
	  struct elfhints_hdr hdr;

	  if (fread (&hdr, 1, sizeof (hdr), f) == sizeof (hdr)
	      && hdr.magic == ELFHINTS_MAGIC
	      && hdr.version == 1)
	    {
	      if (fseek (f, hdr.strtab + hdr.dirlist, SEEK_SET) != -1)
		{
		  char *b;

		  b = xmalloc (hdr.dirlistlen + 1);
		  if (fread (b, 1, hdr.dirlistlen + 1, f) ==
		      hdr.dirlistlen + 1)
		    ld_elf_hints = gld${EMULATION_NAME}_add_sysroot (b);

		  free (b);
		}
	    }
	  fclose (f);
	}

      initialized = TRUE;
    }

  if (ld_elf_hints == NULL)
    return FALSE;

  needed.by = NULL;
  needed.name = name;
  return gld${EMULATION_NAME}_search_needed (ld_elf_hints, & needed,
					     force);
}
EOF
    # FreeBSD
    ;;

d544 1
a544 1
static bfd_boolean
d587 1
a587 1
static bfd_boolean
d596 1
a596 1
    return FALSE;
a693 1
  return TRUE;
d708 1
d711 1
a711 7
      tmppath = concat (ld_sysroot, "${prefix}/etc/ld.so.conf", NULL);
      if (!gld${EMULATION_NAME}_parse_ld_so_conf (&info, tmppath))
	{
	  free (tmppath);
	  tmppath = concat (ld_sysroot, "/etc/ld.so.conf", NULL);
	  gld${EMULATION_NAME}_parse_ld_so_conf (&info, tmppath);
	}
a712 1

d743 1
a743 6
  const char *soname;

  /* Stop looking if we've found a loaded lib.  */
  if (global_found != NULL
      && (bfd_elf_get_dyn_lib_class (global_found->the_bfd)
	  & DYN_AS_NEEDED) == 0)
d746 5
a750 1
  if (s->filename == NULL || s->the_bfd == NULL)
d753 1
a753 6
  /* Don't look for a second non-loaded as-needed lib.  */
  if (global_found != NULL
      && (bfd_elf_get_dyn_lib_class (s->the_bfd) & DYN_AS_NEEDED) != 0)
    return;

  if (strcmp (s->filename, global_needed->name) == 0)
d755 1
a755 3
      global_found = s;
      return;
    }
d757 1
a757 5
  if (s->search_dirs_flag)
    {
      const char *f = strrchr (s->filename, '/');
      if (f != NULL
	  && strcmp (f + 1, global_needed->name) == 0)
d759 1
a759 1
	  global_found = s;
d762 11
d775 1
a775 3
  soname = bfd_elf_get_dt_soname (s->the_bfd);
  if (soname != NULL
      && strcmp (soname, global_needed->name) == 0)
d777 9
a785 2
      global_found = s;
      return;
d838 1
a838 1
      global_found = NULL;
d840 1
a840 3
      if (global_found != NULL
	  && (bfd_elf_get_dyn_lib_class (global_found->the_bfd)
	      & DYN_AS_NEEDED) == 0)
a848 9
      /* As-needed libs specified on the command line (or linker script)
	 take priority over libs found in search dirs.  */
      if (global_found != NULL)
	{
	  nn.name = global_found->filename;
	  if (gld${EMULATION_NAME}_try_needed (&nn, TRUE))
	    continue;
	}

a923 8
    *-*-freebsd* | *-*-dragonfly*)
      cat >>e${EMULATION_NAME}.c <<EOF
	  if (gld${EMULATION_NAME}_check_ld_elf_hints (l->name, force))
	    break;
EOF
    # FreeBSD
    ;;

d1651 1
a1651 1

@


1.162.2.2
log
@        ld/
        * emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation):
        Don't prepend "warning" to the message.

        ld/testsuite
        * ld-elf/warn2.d: New.
        * ld-elf/symbol2w.s: New.
        * ld-elf/symbol2ref.s: New.
@
text
@d1183 1
d1186 1
d1196 4
a1199 2
	msg = xmalloc ((size_t) (sz + 1));
	if (! bfd_get_section_contents (is->the_bfd, s,	msg,
d1203 1
a1203 1
	msg[sz] = '\0';
@


1.162.2.3
log
@        Backport from mainline:

        2006-07-29  Richard Sandiford  <richard@@codesourcery.com>

        ld/
        * Makefile.am (eelf32b4300.c): Update dependencies.
        (eelf32bmip.c): Likewise.
        (eelf32bsmip.c): Likewise.
        (eelf32btsmip.c): Likewise.
        (eelf32btsmipn32.c): Likewise.
        (eelf32ltsmip.c): Likewise.
        (eelf32ltsmipn32.c): Likewise.
        (eelf32ebmip.c): Likewise.
        (eelf32ebmipvxworks.c): Likewise.
        (eelf32elmip.c): Likewise.
        (eelf32elmipvxworks.c): Likewise.
        (eelf32bmipn32.c): Likewise.
        (eelf32lmip.c): Likewise.
        (eelf32mipswindiss.c): Likewise.
        (eelf32lsmip.c): Likewise.
        (eelf64bmip.c): Likewise.
        (eelf64btsmip.c): Likewise.
        (eelf64ltsmip.c): Likewise.
        (emipsbig.c): Likewise.  Canonicalize ${GENSCRIPTS} line.
        (emipsbsd.c): Likewise.
        (emipsidt.c): Update dependencies.
        (emipsidtl.c): Likewise.
        (emipslit.c): Likewise.
        (emipslnews.c): Likewise.
        (emipspe.c): Likewise.  Fix ${GENSCRIPTS} invocation.
        * Makefile.in: Regenerate.
        * emulparams/elf32bmip.sh (EXTRA_EM_FILE): Define.
        * emulparams/elf32bmipn32-defs.sh (EXTRA_EM_FILE): Likewise.
        * emultempl/irix.em: Include emultempl/mipself.em.
        * emultempl/mipself.em: New file.

        ld/testsuite/
        * ld-mips-elf/hash1.s, ld-mips-elf/hash1a.d,
        * ld-mips-elf/hash1b.d, ld-mips-elf/hash1c.d: New tests.
        * ld-mips-elf/mips-elf.exp: Run them.

        2006-07-14  Jakub Jelinek  <jakub@@redhat.com>

        * elflink.c (bfd_elf_size_dynsym_hash_dynstr): Fix cinfo.shift2 value.

        2006-07-10  Jakub Jelinek  <jakub@@redhat.com>

        include/
        * bfdlink.h (struct bfd_link_info): Add emit_hash and
        emit_gnu_hash bitfields.

        include/elf/
        * common.h (SHT_GNU_HASH, DT_GNU_HASH): Define.

        ld/
        * scripttempl/elf.sc: Add .gnu.hash section.
        * emultempl/elf32.em (OPTION_HASH_STYLE): Define.
        (gld${EMULATION_NAME}_add_options): Register --hash-style option.
        (gld${EMULATION_NAME}_handle_option): Handle it.
        (gld${EMULATION_NAME}_list_options): Document it.
        * ldmain.c (main): Initialize emit_hash and emit_gnu_hash.
        * ld.texinfo: Document --hash-style option.

        ld/testsuite/
        * ld-powerpc/tlsso32.r: Adjust.
        * ld-powerpc/tlsso32.d: Adjust.
        * ld-powerpc/tlsso32.g: Adjust.
        * ld-powerpc/tlsso.r: Adjust.
        * ld-powerpc/tlsso.g: Adjust.
        * ld-powerpc/tlstocso.g: Adjust.

        bfd/
        * elf.c (_bfd_elf_print_private_bfd_data): Handle DT_GNU_HASH.
        (bfd_section_from_shdr, elf_fake_sections, assign_section_numbers):
        Handle SHT_GNU_HASH.
        (special_sections_g): Include .gnu.hash section.
        (bfd_elf_gnu_hash): New function.
        * elf-bfd.h (bfd_elf_gnu_hash, _bfd_elf_hash_symbol): New prototypes.
        (struct elf_backend_data): Add elf_hash_symbol method.
        * elflink.c (_bfd_elf_link_create_dynamic_sections): Create .hash
        only if info->emit_hash, create .gnu.hash section if
        info->emit_gnu_hash.
        (struct collect_gnu_hash_codes): New type.
        (elf_collect_gnu_hash_codes, elf_renumber_gnu_hash_syms,
        _bfd_elf_hash_symbol): New functions.
        (compute_bucket_count): Don't compute HASHCODES array, instead add
        that and NSYMS as arguments.  Use bed->s->sizeof_hash_entry
        instead of bed->s->arch_size / 8.  Fix .hash size estimation.
        When not optimizing, use the number of hashed symbols rather than
        dynsymcount.
        (bfd_elf_size_dynamic_sections): Only add DT_HASH if info->emit_hash,
        and ADD DT_GNU_HASH if info->emit_gnu_hash.
        (bfd_elf_size_dynsym_hash_dynstr): Size .hash only if info->emit_hash,
        adjust compute_bucket_count caller.  Create and populate .gnu.hash
        section if info->emit_gnu_hash.
        (elf_link_output_extsym): Only populate .hash section if
        finfo->hash_sec != NULL.
        (bfd_elf_final_link): Adjust assertion.  Handle DT_GNU_HASH.
        * elfxx-target.h (elf_backend_hash_symbol): Define if not yet defined.
        (elfNN_bed): Add elf_backend_hash_symbol.
        * elf64-x86-64.c (elf64_x86_64_hash_symbol): New function.
        (elf_backend_hash_symbol): Define.
        * elf32-i386.c (elf_i386_hash_symbol): New function.
        (elf_backend_hash_symbol): Define.

        binutils/
        * readelf.c (get_dynamic_type): Handle DT_GNU_HASH.
        (get_section_type_name): Handle SHT_GNU_HASH.
        (dynamic_info_DT_GNU_HASH): New variable.
        (process_dynamic_section): Handle DT_GNU_HASH.
        (process_symbol_table): Print also DT_GNU_HASH histogram.
@
text
@a1732 1
#define OPTION_HASH_STYLE		(OPTION_EXCLUDE_LIBS + 1)
a1748 1
    {"hash-style", required_argument, NULL, OPTION_HASH_STYLE},
a1804 16
    case OPTION_HASH_STYLE:
      link_info.emit_hash = FALSE;
      link_info.emit_gnu_hash = FALSE;
      if (strcmp (optarg, "sysv") == 0)
	link_info.emit_hash = TRUE;
      else if (strcmp (optarg, "gnu") == 0)
	link_info.emit_gnu_hash = TRUE;
      else if (strcmp (optarg, "both") == 0)
	{
	  link_info.emit_hash = TRUE;
	  link_info.emit_gnu_hash = TRUE;
	}
      else
	einfo (_("%P%F: invalid hash style \`%s'\n"), optarg);
      break;

a1886 1
  fprintf (file, _("  --hash-style=STYLE\tSet hash style to sysv, gnu or both\n"));
@


1.161
log
@bfd/

2005-12-07  Thiemo Seufer  <ths@@networkno.de>
	    H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/1932
	* bfd-in.h (bfd_elf_record_link_assignment): Add output_bfd
	and hidden arguments.

	* bfd.c (bfd_hide_symbol): Removed.

	* bfd-in2.h: Regenerated.

	* elflink.c (bfd_elf_record_link_assignment): Handle hidden
	symbols which were provided by a linker script.

ld/

2005-12-07  Thiemo Seufer  <ths@@networkno.de>
	    H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/1932
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_exp_assignment):
	Adjust bfd_elf_record_link_assignment call.

	* ldexp.c (exp_fold_tree_1): Remove call to bfd_hide_symbol.
@
text
@d922 12
a951 11
if [ "x${USE_LIBPATH}" = xyes ] ; then
  case ${target} in
    *-*-linux-* | *-*-k*bsd*-*)
      cat >>e${EMULATION_NAME}.c <<EOF
	  if (gld${EMULATION_NAME}_check_ld_so_conf (l->name, force))
	    break;
EOF
    # Linux
    ;;
  esac
fi
@


1.160
log
@bfd/
	* elf-bfd.h (_bfd_generic_match_sections_by_type): Don't define.
	* libbfd-in.h (_bfd_generic_match_sections_by_type): Delete.
	* libbfd.c (_bfd_generic_match_sections_by_type): Delete.
	* targets.c (bfd_match_sections_by_type): Don't define.
	(BFD_JUMP_TABLE_LINK): Remove _bfd_generic_match_sections_by_type.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec, aix5coff64_vec): Likewise.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
ld/
	* ldlang.c (lang_output_section_find_by_flags): Add match_type param.
	Run two passes, first using match_type, second without.
	* ldlang.h (lang_match_sec_type_func): New typedef.
	(lang_output_section_find_by_flags): Update prototype.
	bfd_match_sections_by_type and lang_output_section_find_by_flags.
	* emultempl/pe.em (place_orphan): Likewise.
@
text
@d989 3
a991 2
	  if (!bfd_elf_record_link_assignment (&link_info, exp->assign.dst,
					       provide))
@


1.159
log
@	* ldlang.h (lang_input_section_type): Remove "ifile" field.
	(lang_insert_orphan, lang_add_section): Update prototypes.
	* ldlang.c (lang_insert_orphan): Remove "file" param.
	(lang_add_section): Likewise.  Update all callers.
	(wild_sort): Get an input section's bfd via "section->owner".
	(size_input_section): Access just_syms_flag via bfd usrdata.
	(lang_place_orphans): Update ldemul_place_orphan call.
	* ldemul.h (ldemul_place_orphan): Remove input_statement param.
	(struct ld_emulation_xfer_struct <place_orphan>): Likewise.
	* ldemul.c (ldemul_place_orphan): Likewise.
	* ldwrite.c (build_link_order): Access just_syms_flag via bfd usrdata.
	* emultempl/armelf.em (arm_elf_set_bfd_for_interworking): Likewise.
	* emultempl/beos.em (sort_by_file_name): Access bfd by section->owner.
	(sort_sections): Likewise.
	(place_orphan): Remove "file" param.  Adjust lang_add_section call.
	* emultempl/elf32.em (place_orphan): Remove "file" param.  Adjust
	lang_add_section and lang_insert_orphan calls.
	* emultempl/hppaelf.em (hppaelf_add_stub_section): Adjust
	lang_add_section call.
	(build_section_lists): Access just_syms_flag via bfd usrdata.
	* emultempl/m68hc1xelf.em (m68hc11elf_add_stub_section): Adjust
	lang_add_section call.
	* emultempl/mmo.em (mmo_place_orphan): Remove "file" param.  Adjust
	lang_add_section and lang_insert_orphan calls.
	* emultempl/pe.em (place_orphan): Likewise.  Access bfd via section
	owner.
	* emultempl/ppc64elf.em (ppc_add_stub_section): Adjust
	lang_add_section call.
	(build_toc_list): Access just_syms_flag via bfd usrdata.
	(build_section_lists): Likewise.
	* emultempl/xtensaelf.em (elf_xtensa_place_orphan): Remove "file"
	param.  Adjust place_orphan call.
	(ld_build_required_section_dependence): Access bfd via section owner.
@
text
@d1365 3
a1367 3
	      || (bfd_match_sections_by_type (output_bfd,
					      os->bfd_section,
					      s->owner, s)
d1446 2
a1447 1
	after = lang_output_section_find_by_flags (s, &place->os);
@


1.158
log
@bfd/

2005-10-23  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/1487
	* elf-bfd.h (_bfd_generic_init_private_section_data): New.
	(_bfd_elf_init_private_section_data): New.

	* elf.c (elf_fake_sections): Don't set SHF_GROUP for
	relocatable link.
	(bfd_elf_set_group_contents): Don't handle relocatable link
	specially.
	(assign_section_numbers): If it isn't called by assembler,
	use the output section of elf_linked_to_section for
	SHF_LINK_ORDER.
	(_bfd_elf_init_private_section_data): New.
	(_bfd_elf_copy_private_section_data): Call it.

	* libbfd-in.h (_bfd_generic_init_private_section_data): New.

	* libbfd.c (_bfd_generic_init_private_section_data): New.

	* targets.c (BFD_JUMP_TABLE_COPY): Add
	_bfd_generic_init_private_section_data.
	(bfd_init_private_section_data): Likewise.

	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.

ld/

2005-10-23  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/1487
	* emultempl/elf32.em (gld${EMULATION_NAME}_place_orphan): Call
	bfd_match_sections_by_type to match section types.

	* ldlang.c (init_os): Take the input section. Call
	bfd_init_private_section_data if the input section isn't NULL.
	(exp_init_os): Pass NULL to init_os.
	(map_input_to_output_sections): Likewise.
	(lang_add_section): Pass the input section to init_os.

ld/testsuite/

2005-10-23  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/1487
	* ld-ia64/tlspic.rd: Updated.
@
text
@d62 1
a62 2
static bfd_boolean gld${EMULATION_NAME}_place_orphan
  (lang_input_statement_type *file, asection *s);
d1285 1
a1285 1
gld${EMULATION_NAME}_place_orphan (lang_input_statement_type *file, asection *s)
d1376 1
a1376 1
	  lang_add_section (&os->children, s, os, file);
d1402 1
a1402 1
			hold[orphan_text].os, file);
d1463 1
a1463 1
  lang_insert_orphan (file, s, secname, after, place, NULL, NULL);
@


1.157
log
@bfd/

2005-10-15  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/1467
	* elf-bfd.h (_bfd_elf_match_sections_by_type): New.
	(_bfd_generic_match_sections_by_type): New. Defined.

	* elf.c (_bfd_elf_match_sections_by_type): New.

	* libbfd-in.h (_bfd_generic_match_sections_by_type): New.

	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.

	* libbfd.c (_bfd_generic_match_sections_by_type): New.

	* targets.c (BFD_JUMP_TABLE_LINK): Initialize
	_bfd_match_sections_by_type with
	_bfd_generic_match_sections_by_type.
	(bfd_target): Add _bfd_match_sections_by_type.

ld/

2005-10-15  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/1467
	* emultempl/elf32.em: Include "elf-bfd.h".
	(gld${EMULATION_NAME}_place_orphan): Check section type and
	don't use section name for ELF input sections.

	* ld.texinfo: Document orphan section processing.

	* ldlang.c (lang_output_section_find_by_flags): Match section
	types by calling bfd_match_sections_by_type.
@
text
@d1366 3
a1368 2
	      || ((!iself
		   || sh_type == elf_section_type (os->bfd_section))
@


1.156
log
@2005-09-06  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/1263
	* emultempl/elf32.em (gld${EMULATION_NAME}_load_symbols): Check
	--just-symbols on DSO.
@
text
@d56 1
d1328 2
d1335 1
a1335 2
      && (s->flags & SEC_ALLOC)
      && strncmp (secname, ".rel", 4) == 0)
d1337 19
a1355 5
      if (secname[4] == 'a')
	secname = ".rela.dyn";
      else
	secname = ".rel.dyn";
      isdyn = 1;
d1366 4
a1369 2
	      || ((s->flags ^ os->bfd_section->flags)
		  & (SEC_LOAD | SEC_ALLOC)) == 0))
d1416 2
a1417 1
	   && strncmp (secname, ".note", 5) == 0)
d1425 2
a1426 1
  else if (strncmp (secname, ".rel", 4) == 0
@


1.155
log
@bfd/
	* elf32-ppc.c (struct elf_linker_section): Replace sym_val field
	with sym.
	(ppc_elf_relocate_section): Adjust for above.
	(create_sdata_sym): New function.
	(ppc_elf_create_linker_section): Call it.
	(ppc_elf_check_relocs): Correct has_sda_refs and non_got_refs.
	Create sdata syms for all SDA relocs.
	(ppc_elf_adjust_dynamic_symbol): Don't special case _SDA_BASE_
	and _SDA2_BASE_.
	(ppc_elf_set_sdata_syms): Delete.
	* elflink.c (bfd_elf_size_dynamic_sections): Don't create DT_INIT
	and DT_FINI tags unless associated section has input.
	(bfd_elf_set_symbol, _bfd_elf_provide_symbol): Delete.
	(_bfd_elf_provide_section_bound_symbols): Delete.
	* bfd-in.h (_bfd_elf_provide_symbol): Delete.
	(_bfd_elf_provide_section_bound_symbols): Delete.
	* bfd-in2.h: Regenerate.
ld/
	* ldemul.c (ldemul_do_assignments, do_assignments_default): Delete.
	* ldemul.h (ldemul_do_assignments, do_assignments_default): Delete.
	(struct ld_emulation_xfer_struct): Remove do_assignments field.
	* ldlang.c (lang_do_assignments): Don't call ldemul_do_assignments.
	* emulparams/elf32ppc.sh (SDATA_START_SYMBOLS): New.
	(SDATA2_START_SYMBOLS, SBSS_START_SYMBOLS, SBSS_END_SYMBOLS): New.
	* emultempl/aix.em (ld_*_emulation): Delete do_assignments init.
	* emultempl/armcoff.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/generic.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/gld960c.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68kcoff.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/ticoff.em: Likewise.
	* emultempl/vanilla.em: Likewise.
	* emultempl/elf32.em: Likewise.
	(gld*_provide_bound_symbols): Delete.
	(gld*_provide_init_fini_syms): Delete.
	(gld*_before_allocation): Don't call ldemul_do_assignments.
	* emultempl/ppc32elf.em (ppc_do_assignments): Delete.
	(LDEMUL_DO_ASSIGNMENTS): Delete.
	* scripttempl/elf.sc: Provide init/fini syms.  Add SBSS_START_SYMBOLS,
	SBSS_END_SYMBOLS, SDATA2_START_SYMBOLS.
@
text
@d127 5
@


1.154
log
@bfd/
	* elflink.c (fix_syms, _bfd_elf_fix_excluded_sec_syms): Move to..
	* linker.c (fix_syms, _bfd_fix_excluded_sec_syms): ..here.
	* bfd-in.h (_bfd_fix_excluded_sec_syms): Rename.
	* bfd-in2.h: Regenerate.
ld/
	* ldemul.c (ldemul_finish): Call ld_emulation->finish unconditionally.
	(finish_default): New function.
	* ldemul.h (finish_default): Declare.
	* emultempl/aix.em (gld*_before_allocation): Call
	before_allocation_default rather than strip_excluded_output_sections.
	(ld_*_emulation): Init finish field to finish_default.
	* emultempl/armcoff.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/generic.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/gld960c.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68kcoff.em: Likewise.
	* emultempl/mmo.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/ticoff.em: Likewise.
	* emultempl/vanilla.em: Likewise.
@
text
@a59 1
static void gld${EMULATION_NAME}_provide_init_fini_syms (void);
a1041 41
static void
gld${EMULATION_NAME}_provide_bound_symbols (const char *sec,
					    const char *start,
					    const char *end)
{
  asection *s = bfd_get_section_by_name (output_bfd, sec);
  _bfd_elf_provide_section_bound_symbols (&link_info, s, start, end);
}

/* If not building a shared library, provide

   __preinit_array_start
   __preinit_array_end
   __init_array_start
   __init_array_end
   __fini_array_start
   __fini_array_end

   They are set here rather than via PROVIDE in the linker
   script, because using PROVIDE inside an output section
   statement results in unnecessary output sections.  Using
   PROVIDE outside an output section statement runs the risk of
   section alignment affecting where the section starts.  */

static void
gld${EMULATION_NAME}_provide_init_fini_syms (void)
{
  if (!link_info.relocatable && link_info.executable)
    {
      gld${EMULATION_NAME}_provide_bound_symbols (".preinit_array",
						  "__preinit_array_start",
						  "__preinit_array_end");
      gld${EMULATION_NAME}_provide_bound_symbols (".init_array",
						  "__init_array_start",
						  "__init_array_end");
      gld${EMULATION_NAME}_provide_bound_symbols (".fini_array",
						  "__fini_array_start",
						  "__fini_array_end");
    }
}

a1058 2
  ldemul_do_assignments ();

a1839 1
  ${LDEMUL_DO_ASSIGNMENTS-gld${EMULATION_NAME}_provide_init_fini_syms},
@


1.153
log
@bfd/
	* elf32-ppc.c (ppc_elf_set_sdata_syms): Return void.  Remove hack
	for zero size sections.  Don't set .sbss syms here.
	* elf32-ppc.h (ppc_elf_set_sdata_syms): Adjust prototype.
ld/
	* emultempl/elf32.em (gld*_provide_init_fini_syms): Prototype.
	(gld*_before_allocation): Call ldemul_do_assignments rather than
	gld*_provide_init_fini_syms directly.
	* emultempl/ppc32elf.em (gld*_after_allocation): Delete.
	(ppc_do_assignments): New function.
	(LDEMUL_AFTER_ALLOCATION): Don't define.
	(LDEMUL_DO_ASSIGNMENTS): Define.
@
text
@d1172 1
a1172 2
  if (!link_info.relocatable)
    strip_excluded_output_sections ();
d1513 1
a1513 1
  _bfd_elf_fix_excluded_sec_syms (output_bfd, &link_info);
@


1.152
log
@	* ldemul.c (ldemul_do_assignments): New function.
	(do_assignments_default): New function.
	* ldemul.h (ldemul_do_assignments): Declare.
	(do_assignments_default): Declare.
	(struct ld_emulation_xfer_struct): Add do_assignments.
	* ldlang.c (lang_do_assignments) Call ldemul_do_assignments.
	* emultempl/aix.em (ld_*_emulation): Init do_assignments field.
	* emultempl/armcoff.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/generic.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/gld960c.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68kcoff.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/ticoff.em: Likewise.
	* emultempl/vanilla.em: Likewise.
	* emultempl/elf32.em: Likewise, to call gld*_provide_init_fini_syms.
	(gld*_find_exp_assignment): Adjust bfd_elf_record_link_assignment call.
@
text
@d60 1
d1101 1
a1101 1
  gld${EMULATION_NAME}_provide_init_fini_syms ();
@


1.151
log
@bfd/
	* bfd-in.h (_bfd_elf_fix_excluded_sec_syms): Declare.
	(_bfd_elf_provide_section_bound_symbols): Remove param name.
	Formatting.
	* bfd-in2.h: Regenerate.
	* elflink.c (bfd_elf_gc_sections): Don't call generic function.
	(_bfd_elf_provide_symbol): Formatting.
	(_bfd_elf_provide_section_bound_symbols): Remove all hacks, just
	create section relative syms.
	(fix_syms, _bfd_elf_fix_excluded_sec_syms): New functions.
	* elf32-ppc.c (ppc_elf_set_sdata_syms): Use
	_bfd_elf_provide_section_bound_symbols.
	* reloc.c (bfd_mark_used_section): Delete.
	(bfd_generic_gc_sections): Don't call the above.
ld/
	* ldlang.c (strip_excluded_output_sections): Don't call
	bfd_gc_sections.
	* emultempl/elf32.em (gld*_provide_bound_symbols): Move.
	(gld*_provide_init_fini_syms): Move.
	(gld*_before_allocation): Call the above from here..
	(gld*_finish): ..not here.  Call _bfd_elf_fix_excluded_sec_syms.
	* emultempl/hppaelf.em (hppaelf_finish): Likewise.
	* emultempl/ppc64elf.em (ppc_finish): Likewise.
@
text
@d984 2
a985 2
	  if (!bfd_elf_record_link_assignment (output_bfd, &link_info,
					       exp->assign.dst, provide))
d1884 1
@


1.150
log
@	* ldlang.c (wild_sort): Formatting.
	(strip_excluded_output_sections): Strip zero size sections here.
	* emultempl/elf32.em (gld*_strip_empty_sections): Delete.
	(gld*_finish): Don't call the above.
	* emultempl/hppaelf.em (hppaelf_finish): Likewise.
	* emultempl/ppc64elf.em (ppc_finish): Likewise.
@
text
@a63 1
static void gld${EMULATION_NAME}_provide_init_fini_syms (void);
d1042 41
d1100 2
a1492 43
gld${EMULATION_NAME}_provide_bound_symbols (const char *sec,
					    const char *start,
					    const char *end)
{
  asection *s = bfd_get_section_by_name (output_bfd, sec);
  if (s && bfd_section_removed_from_list (output_bfd, s))
    s = NULL;
  _bfd_elf_provide_section_bound_symbols (&link_info, s, start, end);
}

/* If not building a shared library, provide

   __preinit_array_start
   __preinit_array_end
   __init_array_start
   __init_array_end
   __fini_array_start
   __fini_array_end

   They are set here rather than via PROVIDE in the linker
   script, because using PROVIDE inside an output section
   statement results in unnecessary output sections.  Using
   PROVIDE outside an output section statement runs the risk of
   section alignment affecting where the section starts.  */

static void
gld${EMULATION_NAME}_provide_init_fini_syms (void)
{
  if (!link_info.relocatable && link_info.executable)
    {
      gld${EMULATION_NAME}_provide_bound_symbols (".preinit_array",
						  "__preinit_array_start",
						  "__preinit_array_end");
      gld${EMULATION_NAME}_provide_bound_symbols (".init_array",
						  "__init_array_start",
						  "__init_array_end");
      gld${EMULATION_NAME}_provide_bound_symbols (".fini_array",
						  "__fini_array_start",
						  "__fini_array_end");
    }
}

static void
d1513 1
a1513 1
  gld${EMULATION_NAME}_provide_init_fini_syms ();
@


1.149
log
@	* emultempl/elf32.em: Enable use of ld.so.conf for *-*-k*bsd-*.
@
text
@a63 1
static void gld${EMULATION_NAME}_strip_empty_sections (void);
a1508 28
gld${EMULATION_NAME}_strip_empty_sections (void)
{
  if (!link_info.relocatable)
    {
      lang_output_section_statement_type *os;

      for (os = &lang_output_section_statement.head->output_section_statement;
	   os != NULL;
	   os = os->next)
	{
	  asection *s;

	  if (os == abs_output_section || os->constraint == -1)
	    continue;
	  s = os->bfd_section;
	  if (s != NULL
	      && s->size == 0
	      && (s->flags & SEC_KEEP) == 0
	      && !bfd_section_removed_from_list (output_bfd, s))
	    {
	      bfd_section_list_remove (output_bfd, s);
	      output_bfd->section_count--;
	    }
	}
    }
}

static void
a1513 1
  gld${EMULATION_NAME}_strip_empty_sections ();
@


1.148
log
@	* ld.h (lang_phase_type): Move to..
	* ldexp.h: ..here.  Add lang_mark_phase_enum.
	(node_type): Remove etree_undef and etree_unspec.
	(exp_data_seg): Delete.
	(struct ldexp_control, expld): New.
	(invalid, exp_mark_used_section): Delete.
	(exp_fold_tree, exp_get_vma, exp_get_value_int, exp_get_fill,
	exp_get_abs_int): Update prototypes.
	* ldexp.c (assigning_to_dot): Delete.
	(expld): Define.
	(make_abs): Operate directly on expld.result.  Update all callers.
	(new_abs): Likewise.  Return void.
	(new_rel_from_abs): Rename from new_rel_from_section.
	(new_rel, new_rel_from_abs): Operate on expld.result and return void.
	Update all callers.
	(fold_unary): Operate on expld.result and return void.  Remove
	"current_section", "allocation_done", "dot", "dotp" and "mark_used"
	params.  Update all callers.
	(fold_binary, fold_trinary, fold_name, exp_fold_tree_1): Likewise.
	(fold_unary <ALIGN_K>): Ensure alignment is absolute.
	(fold_unary <ABSOLUTE>): Use make_abs.
	(fold_unary <DATA_SEGMENT_END>): Evaluate mark_phase as for
	allocating_phase.
	(fold_binary <DATA_SEGMENT_ALIGN, DATA_SEGMENT_RELRO_END, >): Ditto.
	(fold_binary <'%','/'>): Don't error if marking.
	(fold_name <SIZEOF_HEADERS>): Don't call bfd_sizeof_headers when
	marking.
	(fold_name <NAME>): Remove FIXME; -R is handled correctly.  Don't
	error when marking.
	(fold_name <ADDR, LOADADDR, SIZEOF>): Don't set SEC_KEEP.
	(exp_fold_tree_1): Don't error when marking.
	(exp_fold_tree_1 <etree_rel>): Evaluate in all phases except first.
	(exp_fold_tree_1 <etree_assign to dot>): Don't check for NULL
	current section, instead check for NULL dotp.
	(exp_fold_tree_1 <etree_provide>): Don't evaluate the assignment
	source unless the symbol is referenced and undefined.
	(exp_fold_tree): Remove "allocation_done" and "dot" params.  Save
	params to expld.
	(exp_fold_tree_no_dot): Remove "current_section", "allocation_done
	and "mark_used" params.  Save params to expld.  Update all callers.
	(exp_assop): Do without temp var.
	(exp_print_tree <etree_undef>): Delete code.
	(exp_get_vma): Remove "allocation_done" param.  Correct error return.
	(exp_get_fill, exp_get_abs_int): Likewise.
	(exp_get_value_int): Remove "allocation_done" param.
	(exp_mark_used_section): Delete.
	* ldgram.y (fill_exp): Update exp_get_fill call.
	(origin_spec, length_spec): Update exp_get_vma call.
	* ldlang.c (lang_init): Don't bother clearing lang_statement_iteration.
	(lang_mark_used_section_1, lang_mark_used_section): Delete.
	(strip_excluded_output_sections): Call one_lang_size_sections_pass in
	marking mode.  Merge old lang_mark_used_section code.  Correct handling
	of output sections with excluded input sections and data statements.
	Don't drop non-zero sized sections.  Don't zap os->bfd_section.
	Do set SEC_EXCLUDE when appropriate.
	(print_output_section_statement): Update for changed ldexp.c
	interface.
	(print_assignment, lang_size_sections_1): Likewise.
	(lang_do_assignments_1, lang_enter_output_section_statement): Likewise.
	(lang_new_phdr, lang_record_phdrs): Likewise.
	(lang_size_sections): Likewise.
	(insert_pad): Use following statement if it is a pad, rather than
	creating a new one.
	(lang_size_sections_1 <lang_output_section_statement_enum>): Do
	process ignored output section to set vma and lma, but don't
	update dot for these sections.  Don't error if marking.
	(lang_size_sections_1 <lang_assignment_statement_enum>): Don't
	update dot for ignored sections.
	(lang_size_sections_1 <lang_data_statement_enum>): Don't mark absolute
	section with SEC_ALLOC.
	(one_lang_size_sections_pass): New function.
	(lang_size_sections): Remove first five params.  Set expld.phase on
	entry and exit.   Use one_lang_size_sections_pass.
	(lang_do_assignments): Remove all params.  Update all callers.
	(lang_reset_memory_regions): Clear os->processed for all output
	section statements.
	* ldlang.h (lang_do_assignments): Update prototype.
	(lang_size_sections): Likewise.
	(one_lang_size_sections_pass): Declare.
	* pe-dll.c (pe_dll_fill_sections, pe_exe_fill_sections): Update
	lang_size_sections and lang_do_assignments calls.
	* emultempl/elf32.em (layout_sections_again): Likewise.
	* emultempl/ppc64elf.em (ppc_before_allocation): Use
	one_lang_size_sections_pass.
@
text
@d72 1
a72 1
    *-*-linux-*)
d357 1
a357 1
  *-*-linux-*)
d529 1
a529 1
    *-*-linux-*)
d939 1
a939 1
    *-*-linux-*)
@


1.147
log
@Update FSF addresses
@
text
@d1500 1
a1500 2
  lang_size_sections (stat_ptr->head, abs_output_section,
		      &stat_ptr->head, 0, (bfd_vma) 0, NULL, TRUE);
d1506 1
a1506 2
  lang_do_assignments (stat_ptr->head, abs_output_section,
		       (fill_type *) 0, (bfd_vma) 0);
@


1.146
log
@2005-05-09  H.J. Lu  <hongjiu.lu@@intel.com>

	* emultempl/elf32.em (gld${EMULATION_NAME}_provide_bound_symbols):
	Don't use a removed section.
@
text
@d34 1
a34 1
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.145
log
@2005-05-06  H.J. Lu  <hongjiu.lu@@intel.com>

	* emultempl/elf32.em (gld${EMULATION_NAME}_provide_init_fini_syms):
	Put back !link_info.relocatable.
@
text
@d1457 2
@


1.144
log
@2005-05-06  H.J. Lu  <hongjiu.lu@@intel.com>

	* emultempl/elf32.em (gld${EMULATION_NAME}_provide_init_fini_syms):
	Just check link_info.executable.
@
text
@d1478 1
a1478 1
  if (link_info.executable)
@


1.143
log
@bfd/

2005-05-04  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfd-in.h (_bfd_elf_provide_section_bound_symbols): New.
	* bfd-in2.h: Regenerated.

	* elflink.c (bfd_elf_set_symbol): New.
	(_bfd_elf_provide_symbol): Call it.
	(_bfd_elf_provide_section_bound_symbols): New.

ld/

2005-05-04  H.J. Lu  <hongjiu.lu@@intel.com>

	* emultempl/elf32.em (gld${EMULATION_NAME}_provide_bound_symbols):
	Call _bfd_elf_provide_section_bound_symbols.
@
text
@d1478 1
a1478 1
  if (!link_info.relocatable && !link_info.shared)
@


1.142
log
@bfd/
	* section.c (struct bfd_section): Replace link_order_head and
	link_order_tail with map_head and map_tail union.
	(STD_SECTION): Update.
	(_bfd_strip_section_from_output): Delete.
	* aoutx.h: Update throughout for above changes.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* elf-eh-frame.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elflink.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* linker.c: Likewise.
	* merge.c: Likewise.
	* pdp11.c: Likewise.
	* xcofflink.c: Likewise.
	* elflink.c (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Split
	out from bfd_elf_size_dynamic_sections.
	* bfd-in.h (bfd_boolean bfd_elf_size_dynsym_hash_dynstr): Declare.
	* bfd-in2.h: Regenerate.
ld/
	* ldemul.c: Include bfdlink.h.
	(ldemul_before_allocation): Assume before_allocation is non-zero.
	(before_allocation_default): Call strip_excluded_output_sections.
	* ldlang.c (stripped_excluded_sections): New variable.
	(lang_add_section): Build input section list for each output
	section, attached via map_head and map_tail pointers.
	(strip_excluded_output_sections): Make global.  Traverse the
	input section lists to find which output sections can go.  Clear
	link_order pointers and set stripped_excluded_sections.
	(lang_process): Call strip_excluded_output_sections.
	* ldlang.h (strip_excluded_output_sections): Declare.
	* ldwrite.c: Update throuhout for link_order_head -> map_head change.
	* emultempl/aix.em (before_allocation): Call
	strip_excluded_output_sections.
	* emultempl/armcoff.em (before_allocation): Likewise.
	* emultempl/beos.em (before_allocation): Likewise.
	* emultempl/linux.em (before_allocation): Likewise.
	* emultempl/pe.em (before_allocation): Likewise.
	* emultempl/sunos.em (before_allocation): Likewise.
	* emultempl/elf32.em (before_allocation): Likewise.  Call
	bfd_elf_size_dynsym_hash_dynstr too.
	* emultempl/lnk960.em (lnk960_before_allocation): Delete.
	(ld_lnk960): Use before_allocation_default.
@
text
@d1456 2
a1457 29
  asection *s;
  bfd_vma start_val, end_val;

  s = bfd_get_section_by_name (output_bfd, sec);
  if (s != NULL)
    {
      start_val = s->vma;
      end_val = start_val + s->size;
    }
  else
    {
      /* We have to choose those values very carefully.  Some targets,
	 like alpha, may have relocation overflow with 0.  We use the
	 first SEC_ALLOC section which isn't SEC_READONLY or the last
	 SEC_ALLOC section.   */
      start_val = 0;
      for (s = output_bfd->sections; s != NULL; s = s->next)
	{
	  if ((s->flags & SEC_ALLOC) != 0)
	    {
	      start_val = s->vma;
	      if ((s->flags & SEC_READONLY) == 0)
		break;
	    }
	}
      end_val = start_val;
    }
  _bfd_elf_provide_symbol (&link_info, start, start_val);
  _bfd_elf_provide_symbol (&link_info, end, end_val);
@


1.141
log
@bfd/

2005-05-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfd.c (bfd): Remove section_tail and add section_last.
	(bfd_preserve): Likewise.
	(bfd_preserve_save): Likewise.
	(bfd_preserve_restore): Likewise.
	* opncls.c (_bfd_new_bfd): Likewise.

	* coffcode.h (coff_compute_section_file_positions): Updated.
	(coff_compute_section_file_positions): Likewise.
	* elf.c (assign_section_numbers): Likewise.
	* elf32-i370.c (i370_elf_size_dynamic_sections): Likewise.
	* elf64-mmix.c (mmix_elf_final_link): Likewise.
	* elfxx-ia64.c (elfNN_ia64_object_p): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* sunos.c (sunos_add_dynamic_symbols): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_final_link): Likewise.

	* ecoff.c (bfd_debug_section): Initialize prev.

	* section.c (bfd_section): Add prev.
	(bfd_section_list_remove): Updated.
	(bfd_section_list_append): New.
	(bfd_section_list_insert_after): New.
	(bfd_section_list_insert_before): New.
	(bfd_section_list_insert): Removed.
	(bfd_section_removed_from_list): Updated.
	(STD_SECTION): Initialize prev.
	(bfd_section_init): Updated.
	(bfd_section_list_clear): Updated.

	* bfd-in2.h: Regenerated.

gas/

2005-05-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* write.c (write_object_file): Use bfd_section_double_list_remove
	to remove sections.

ld/

2005-05-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* emultempl/elf32.em (gld${EMULATION_NAME}_strip_empty_section):
	Updated for bfd_section_list_remove change.
	* ldlang.c (lang_insert_orphan): Likewise.
	(strip_excluded_output_sections): Likewise.
	(sort_sections_by_lma): New.
	(lang_check_section_addresses): Sort the sections before
	checking addresses.
@
text
@d1072 1
d1129 6
@


1.140
log
@2005-04-27  H.J. Lu  <hongjiu.lu@@intel.com>

	* emultempl/elf32.em (gld${EMULATION_NAME}_provide_bound_symbols):
	Use the first SEC_ALLOC section which isn't SEC_READONLY or the
	last SEC_ALLOC section if such a section doesn't exist.
@
text
@d1545 4
a1548 1
	  if (s != NULL && s->size == 0 && (s->flags & SEC_KEEP) == 0)
d1550 2
a1551 9
	      asection **p;

	      for (p = &output_bfd->sections; *p; p = &(*p)->next)
		if (*p == s)
		  {
		    bfd_section_list_remove (output_bfd, p);
		    output_bfd->section_count--;
		    break;
		  }
@


1.139
log
@	* emultempl/elf32.em (gld${EMULATION_NAME}_stat_needed): Ignore
	as_needed libs that were not needed.
	(gld${EMULATION_NAME}_check_needed): Likewise.
@
text
@d1460 4
d1465 10
a1474 1
      end_val = 0;
@


1.138
log
@Add a check for <unistd.h> providing a prototype for getopt() which is compatible
with the one in	include/getopt.h.  If so then define HAVE_DECL_GETOPT.
@
text
@d233 3
d743 7
@


1.137
log
@	* emultempl/elf32.em (gld${EMULATION_NAME}_layout_sections_again):
	New function, extracted from static void gld${EMULATION_NAME}_finish.
	(gld${EMULATION_NAME}_strip_empty_sections): Likewise.
	(gld${EMULATION_NAME}_provide_init_fini_syms): Likewise.
	* emultempl/ppc64elf.em: Revert last change.
	(ppc_layout_sections_again): Use
	gld${EMULATION_NAME}_layout_sections_again.
	(ppc_finish): Don't call gld${EMULATION_NAME}_finish.  Instead call
	gld${EMULATION_NAME}_strip_empty_sections and
	gld${EMULATION_NAME}_provide_init_fini_syms.
	* emultempl/hppaelf.em: Similarly.
@
text
@d38 1
@


1.136
log
@Accept any C library to accompany a GNU Linux implementation, not just the GNU
C library.
@
text
@d62 4
a65 1
static void gld${EMULATION_NAME}_finish (void);
d1456 15
d1472 1
a1472 1
gld${EMULATION_NAME}_finish (void)
d1474 1
a1474 1
  if (bfd_elf_discard_info (output_bfd, &link_info))
d1476 11
a1486 1
      lang_reset_memory_regions ();
d1488 16
a1503 11
      /* Resize the sections.  */
      lang_size_sections (stat_ptr->head, abs_output_section,
			  &stat_ptr->head, 0, (bfd_vma) 0, NULL, TRUE);

      /* Redo special stuff.  */
      ldemul_after_allocation ();

      /* Do the assignments again.  */
      lang_do_assignments (stat_ptr->head, abs_output_section,
			   (fill_type *) 0, (bfd_vma) 0);
    }
d1505 3
d1534 2
d1537 5
a1541 1
      /* If not building shared library, provide
d1543 2
a1544 26
	 __preinit_array_start
	 __preinit_array_end
	 __init_array_start
	 __init_array_end
	 __fini_array_start
	 __fini_array_end

	 They are set here rather than via PROVIDE in the linker
	 script, because using PROVIDE inside an output section
	 statement results in unnecessary output sections.  Using
	 PROVIDE outside an output section statement runs the risk of
	 section alignment affecting where the section starts.  */

      if (!link_info.shared)
	{
	  gld${EMULATION_NAME}_provide_bound_symbols
	    (".preinit_array", "__preinit_array_start",
	     "__preinit_array_end");
	  gld${EMULATION_NAME}_provide_bound_symbols
	    (".init_array", "__init_array_start",
	     "__init_array_end");
	  gld${EMULATION_NAME}_provide_bound_symbols
	    (".fini_array", "__fini_array_start",
	     "__fini_array_end");
	}
    }
@


1.135
log
@bfd/

2005-03-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfd-in.h (_bfd_elf_provide_symbol): New.
	* bfd-in2.h: Regenerated.

	* elf32-ppc.c (set_linker_sym): Moved to elflink.c.
	(ppc_elf_set_sdata_syms): Call _bfd_elf_provide_symbol instead
	of set_linker_sym.

	* elflink.c (_bfd_elf_provide_symbol): New. Moved and renamed
	from elf32-ppc.c.

ld/

2005-03-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* emultempl/elf32.em (gld${EMULATION_NAME}_provide_bound_symbols): New
	(gld${EMULATION_NAME}_finish): Call
	gld${EMULATION_NAME}_provide_bound_symbols to provide
	__preinit_array_start, __preinit_array_end, __init_array_start,
	__init_array_end, __fini_array_start and __fini_array_end.

	* scripttempl/elf.sc: Don't provide __preinit_array_start,
	__preinit_array_end, __init_array_start, __init_array_end,
	__fini_array_start nor __fini_array_end.
@
text
@d68 1
a68 1
    *-*-linux-gnu*)
d350 1
a350 1
  *-*-linux-gnu*)
d522 1
a522 1
    *-*-linux-gnu*)
d925 1
a925 1
    *-*-linux-gnu*)
@


1.134
log
@bfd/
	* elflink.c (elf_link_add_object_symbols): Set SEC_EXCLUDE on
	.gnu.warning.* sections.
ld/
	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation): Set
	SEC_EXCLUDE on .gnu.warning sections.
@
text
@d1431 23
d1498 28
@


1.133
log
@2005-03-18  H.J. Lu  <hongjiu.lu@@intel.com>

	* emultempl/elf32.em (gld${EMULATION_NAME}_finish): Don't set
	bfd_section when removing unused empty output sections for
	non-relocatable link.
@
text
@d1108 4
@


1.132
log
@bfd/

2005-03-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* elflink.c (elf_mark_used_section): New.
	(bfd_elf_gc_sections): Call elf_gc_mark_section for
	non-relocatable link if we don't do GC.

include/

2005-03-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfdlink.h (bfd_link_info): Add gc_sections.

ld/

2005-03-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* emultempl/elf32.em (gld${EMULATION_NAME}_finish): Remove
	unused empty output sections for non-relocatable link.

	* ld.h (args_type): Remove gc_sections.

	* ldlang.c (lang_mark_used_section): New.
	(lang_gc_sections): Use link_info.gc_sections instead of
	command_line.gc_sections.
	* ldmain.c (main): Likewise.
	* lexsup.c (parse_args): Likewise.
	* ldlang.c (lang_process): Call lang_mark_used_section.

	* ldmain.c (main): Initialize link_info.gc_sections to FALSE.

ld/testsuite/

2005-03-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-alpha/tlsbin.rd: Updated for empty section removal.
	* ld-alpha/tlsbinr.rd: Likewise.
	* ld-alpha/tlspic.rd: Likewise.
	* ld-arm/mixed-lib.sym: Likewise.
	* ld-i386/tlsbin.rd: Likewise.
	* ld-i386/tlsnopic.rd: Likewise.
	* ld-i386/tlspic.rd: Likewise.
	* ld-ia64/tlsbin.rd: Likewise.
	* ld-ia64/tlspic.rd: Likewise.
	* ld-powerpc/apuinfo.rd: Likewise.
	* ld-powerpc/powerpc.exp: Likewise.
	* ld-powerpc/tlsexe32.r: Likewise.
	* ld-s390/tlsbin.rd: Likewise.
	* ld-s390/tlsbin_64.rd: Likewise.
	* ld-s390/tlspic.rd: Likewise.
	* ld-s390/tlspic_64.rd: Likewise.
	* ld-sh/tlsbin-2.d: Likewise.
	* ld-sh/tlspic-2.d: Likewise.
	* ld-sparc/tlssunbin32.rd: Likewise.
	* ld-sparc/tlssunnopic32.rd: Likewise.
	* ld-sparc/tlssunpic32.rd: Likewise.
	* ld-x86-64/tlsbin.rd: Likewise.
	* ld-x86-64/tlspic.rd: Likewise.
@
text
@a1461 2
	      os->bfd_section = NULL;

@


1.131
log
@	* ldexp.c: Warning fixes.
	* ldwrite.c: Likewise.
	* emultempl/elf32.em: Likewise.
@
text
@d1444 30
@


1.131.2.1
log
@bfd/
	* elflink.c (elf_link_add_object_symbols): Set SEC_EXCLUDE on
	.gnu.warning.* sections.
ld/
	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation): Set
	SEC_EXCLUDE on .gnu.warning sections.
@
text
@a1107 4

	/* Also set SEC_EXCLUDE, so that symbols defined in the warning
	   section don't get copied to the output.  */
	s->flags |= SEC_EXCLUDE;
@


1.131.2.1.2.1
log
@2005-04-13  Paul Brook  <paul@@codesourcery.com>

	Backport from mainline.
	2005-04-11  Alan Modra  <amodra@@bigpond.net.au>
	* emultempl/elf32.em (gld${EMULATION_NAME}_stat_needed): Ignore
	as_needed libs that were not needed.
	(gld${EMULATION_NAME}_check_needed): Likewise.
@
text
@a228 3
  if (s->as_needed
      && (bfd_elf_get_dyn_lib_class (s->the_bfd) & DYN_AS_NEEDED) != 0)
    return;
a735 7
  /* If this input file was an as-needed entry, and wasn't found to be
     needed at the stage it was linked, then don't say we have loaded it.  */
  if (s->as_needed
      && (s->the_bfd == NULL
	  || (bfd_elf_get_dyn_lib_class (s->the_bfd) & DYN_AS_NEEDED) != 0))
    return;

@


1.131.2.2
log
@	* emultempl/elf32.em (gld${EMULATION_NAME}_stat_needed): Ignore
	as_needed libs that were not needed.
	(gld${EMULATION_NAME}_check_needed): Likewise.
@
text
@a228 3
  if (s->as_needed
      && (bfd_elf_get_dyn_lib_class (s->the_bfd) & DYN_AS_NEEDED) != 0)
    return;
a735 7
  /* If this input file was an as-needed entry, and wasn't found to be
     needed at the stage it was linked, then don't say we have loaded it.  */
  if (s->as_needed
      && (s->the_bfd == NULL
	  || (bfd_elf_get_dyn_lib_class (s->the_bfd) & DYN_AS_NEEDED) != 0))
    return;

@


1.130
log
@	* configure.in (AC_CHECK_FUNCS): Add glob.
	* configure: Regenerated.
	* emultempl/elf32.em (<glob.h>): Do not include if HAVE_GLOB is
	not defined.
	(gld${EMULATION_NAME}_parse_ld_so_conf_include): Do not use glob
	if HAVE_GLOB is not defined.
@
text
@d1020 2
a1021 2
      sinterp->contents = ${ELF_INTERPRETER_NAME};
      sinterp->size = strlen (sinterp->contents) + 1;
@


1.129
log
@	* emultempl/elf32.em (gld${EMULATION_NAME}_after_open): Define
	lib_path if NATIVE is yes.
@
text
@d70 1
d72 1
d544 1
d546 1
d559 1
d568 4
@


1.128
log
@	* emultempl/elf32.em (gld${EMULATION_NAME}_stat_needed):
	If st.st_ino is zero, do not treat the library as a duplicate.
@
text
@d839 5
a845 1
	  const char *lib_path;
@


1.127
log
@bfd/
	* elflink.c (bfd_elf_record_link_assignment): Do "provide" symbol
	lookup here.  Set to new before calling bfd_link_repair_undef_list.
	(elf_smash_syms): Check that u.undef.weak isn't the not_needed bfd.
ld/
	emultempl/elf32.em (gld${EMULATION_NAME}_find_exp_assignment): Don't
	look up symbol for etree_provide here.
@
text
@d234 7
d242 2
a243 1
      && st.st_ino == global_stat.st_ino)
@


1.126
log
@bfd/
	* elflink.c (elf_link_add_object_symbols): Don't create link dynamic
	sections immediately when linking shared libs.  Instead, wait until
	we know a lib is needed.
	(_bfd_elf_link_create_dynstrtab): Extract from..
	(_bfd_elf_link_create_dynamic_sections_): ..here.
	(elf_add_dt_needed_tag): Call _bfd_elf_link_create_dynstrtab and
	_bfd_elf_link_create_dynamic_sections.  Add abfd param.  Allow
	for non-existent .dynamic.
	(elf_link_output_extsym): Don't complain about undefined symbols
	in as-needed dynamic libs that aren't actually linked.
ld/
	* emultempl/elf32.em (gld${EMULATION_NAME}_try_needed): Formatting.
	(gld${EMULATION_NAME}_after_open): Ignore needed libs if they were
	only needed by an as-needed lib that didn't get linked.
@
text
@d934 1
a934 1
  struct bfd_link_hash_entry *h;
d939 3
a941 5
      h = bfd_link_hash_lookup (link_info.hash, exp->assign.dst,
				FALSE, FALSE, FALSE);
      if (h == NULL)
	break;

a948 3

      /* Fall through.  */
    case etree_assign:
d951 2
a952 3
	  if (! (bfd_elf_record_link_assignment
		 (output_bfd, &link_info, exp->assign.dst,
		  exp->type.node_class == etree_provide ? TRUE : FALSE)))
@


1.125
log
@bfd/
	* bfd-in2.h: Regenerate.
	* bfd.c (struct bfd): Add no_export.
	* elflink.c (elf_link_add_object_symbols): Handle no_export.
ld/
	* ldlang.c (struct excluded_lib, excluded_libs, add_excluded_libs)
	(check_excluded_libs): New.
	(load_symbols): Call check_excluded_libs.
	* ldlang.h (add_excluded_libs): New prototype.
	* emultempl/elf32.em (OPTION_EXCLUDED_LIBS): Define.
	(gld${EMULATION_NAME}_add_options): Add --exclude-libs.
	(gld${EMULATION_NAME}_handle_option): Handle --exclude-libs.
	* ld.texinfo (Command Line Variables): Document --exclude-libs.
	(Options Specific to i386 PE Targets): Remove --exclude-libs.
ld/testsuite/
	* ld-elf/exclude1.s, ld-elf/exclude2.s, ld-elf/exclude.exp: New.
@
text
@d16 1
a16 1
   2002, 2003, 2004 Free Software Foundation, Inc.
d401 2
a402 3
  if (needed->by
      && (bfd_elf_get_dyn_lib_class (needed->by)
	  & DYN_NO_ADD_NEEDED) != 0)
d787 6
d795 3
a797 1
	if (strcmp (ll->name, l->name) == 0)
@


1.124
log
@ld/
	PR 63
	* ldlang.h (lang_output_section_statement_type): Make "next" a
	struct lang_output_section_statement_struct *.
	(struct orphan_save): Move from elf32.em.  Add "name" and "flags".
	(lang_output_section_find_by_flags, lang_insert_orphan): Declare.
	* ldlang.c (lang_output_section_find_1): Adjust for changed
	output_section_statement "next".
	(strip_excluded_output_sections): Likewise.
	(lang_record_phdrs): Likewise.
	(lang_output_section_find_by_flags): New function.
	(output_prev_sec_find): Move from pe.em.  Adjust iterator.
	(lang_insert_orphan): New function.  Tail end of elf32.em's
	place_orphan merged with that from pe.em.  Allow bfd_section to
	be placed first.  New heuristic for placing new output section
	statement in existing script, and accompanying split of __start
	symbol alignment into a separate assignment to dot.
	(lang_add_section): Consistently use output->bfd_section rather than
	an alias, section->output_section.
	(map_input_to_output_sections): Rename overly long arg.  Move
	initialization of data_statement output section to here..
	(lang_check_section_addresses): ..from here.
	(print_assignment): Correct printing of etree_assert.
	(print_all_symbols): Don't bomb if userdata is NULL.
	(IGNORE_SECTION): Rearrange.
	* emultempl/elf32.em (output_rel_find): Adjust interator.
	(output_prev_sec_find): Delete.
	(struct orphan_save): Delete.
	(gld${EMULATION_NAME}_place_orphan): Cater for zero bfd_section
	flags without creating a duplicate output section statement.
	Revise code holding history of various orphan section placements.
	Allow orphan sections to place before script specified output
	sections.  Call lang_output_section_find_by_flags when placement
	by name fails.  Use lang_insert_orphan.
	* emultempl/mmo.em (output_prev_sec_find): Delete.
	(struct orphan_save): Delete.
	(mmo_place_orphan): Revise code holding history of orphan placement.
	Allow orphans to place before existing output sections.  Use
	lang_insert_orphan.
	* emultempl/pe.em (output_prev_sec_find): Delete.
	(struct orphan_save): Delete.
	(gld_${EMULATION_NAME}_place_orphan): Revise to suit use of
	lang_insert_orphan.
ld/testsuite/
	* ld-scripts/overlay-size.d: Update for changed orphan section
	placement.
	* ld-mmix/bpo-18.d: Likewise.
@
text
@d1574 2
a1575 1

d1590 1
d1643 4
@


1.123
log
@	* emultempl/elf32.em (gld${EMULATION_NAME}_parse_ld_so_conf): Avoid
	getline for portability.
@
text
@d1175 1
a1175 1
/* A variant of lang_output_section_find.  Used by place_orphan.  */
a1179 1
  lang_statement_union_type *u;
d1187 3
a1189 1
  for (u = lang_output_section_statement.head; u; u = lookup->next)
a1190 1
      lookup = &u->output_section_statement;
a1231 25
/* Find the last output section before given output statement.
   Used by place_orphan.  */

static asection *
output_prev_sec_find (lang_output_section_statement_type *os)
{
  asection *s = (asection *) NULL;
  lang_statement_union_type *u;
  lang_output_section_statement_type *lookup;

  for (u = lang_output_section_statement.head;
       u != (lang_statement_union_type *) NULL;
       u = lookup->next)
    {
      lookup = &u->output_section_statement;
      if (lookup == os)
	return s;

      if (lookup->bfd_section != NULL && lookup->bfd_section->owner != NULL)
	s = lookup->bfd_section;
    }

  return NULL;
}

a1234 7
struct orphan_save {
  lang_output_section_statement_type *os;
  asection **section;
  lang_statement_union_type **stmt;
  lang_statement_union_type **os_tail;
};

d1238 35
a1272 8
  static struct orphan_save hold_text;
  static struct orphan_save hold_rodata;
  static struct orphan_save hold_data;
  static struct orphan_save hold_bss;
  static struct orphan_save hold_rel;
  static struct orphan_save hold_interp;
  static struct orphan_save hold_sdata;
  static int count = 1;
a1273 3
  lang_statement_list_type *old;
  lang_statement_list_type add;
  etree_type *address;
d1275 1
a1275 1
  const char *ps = NULL;
a1276 2
  lang_statement_union_type **os_tail;
  etree_type *load_base;
a1277 1
  asection *sec;
d1300 1
d1305 4
a1308 1
	     name, and its bfd section, if any, has compatible flags.  */
d1314 12
a1325 2
  if (hold_text.os == NULL)
    hold_text.os = lang_output_section_find (".text");
d1332 1
a1332 1
      && hold_text.os != NULL)
d1334 2
a1335 1
      lang_add_section (&hold_text.os->children, s, hold_text.os, file);
a1343 2
#define HAVE_SECTION(hold, name) \
(hold.os != NULL || (hold.os = lang_output_section_find (name)) != NULL)
d1349 8
a1356 12
	   && strncmp (secname, ".note", 5) == 0
	   && HAVE_SECTION (hold_interp, ".interp"))
    place = &hold_interp;
  else if ((s->flags & SEC_HAS_CONTENTS) == 0
	   && HAVE_SECTION (hold_bss, ".bss"))
    place = &hold_bss;
  else if ((s->flags & SEC_SMALL_DATA) != 0
	   && HAVE_SECTION (hold_sdata, ".sdata"))
    place = &hold_sdata;
  else if ((s->flags & SEC_READONLY) == 0
	   && HAVE_SECTION (hold_data, ".data"))
    place = &hold_data;
d1358 6
a1363 10
	   && (s->flags & SEC_LOAD) != 0
	   && (hold_rel.os != NULL
	       || (hold_rel.os = output_rel_find (s, isdyn)) != NULL))
    place = &hold_rel;
  else if ((s->flags & (SEC_CODE | SEC_READONLY)) == SEC_READONLY
	   && HAVE_SECTION (hold_rodata, ".rodata"))
    place = &hold_rodata;
  else if ((s->flags & (SEC_CODE | SEC_READONLY)) == (SEC_CODE | SEC_READONLY)
	   && hold_text.os != NULL)
    place = &hold_text;
d1365 17
a1381 1
#undef HAVE_SECTION
d1385 2
a1386 6
     loadable or allocatable characteristics.  But if the section
     already exists but does not have any flags set, then it has been
     created by the linker, probably as a result of a --section-start
     command line switch.  */
  if ((sec = bfd_get_section_by_name (output_bfd, secname)) != NULL
      && bfd_get_section_flags (output_bfd, sec) != 0)
d1388 1
d1394 1
a1394 167
  /* Start building a list of statements for this section.
     First save the current statement pointer.  */
  old = stat_ptr;

  /* If we have found an appropriate place for the output section
     statements for this orphan, add them to our own private list,
     inserting them later into the global statement list.  */
  if (place != NULL)
    {
      stat_ptr = &add;
      lang_list_init (stat_ptr);
    }

  if (config.build_constructors)
    {
      /* If the name of the section is representable in C, then create
	 symbols to mark the start and the end of the section.  */
      for (ps = secname; *ps != '\0'; ps++)
	if (! ISALNUM (*ps) && *ps != '_')
	  break;
      if (*ps == '\0')
	{
	  char *symname;
	  etree_type *e_align;

	  symname = (char *) xmalloc (ps - secname + sizeof "__start_");
	  sprintf (symname, "__start_%s", secname);
	  e_align = exp_unop (ALIGN_K,
			      exp_intop ((bfd_vma) 1 << s->alignment_power));
	  lang_add_assignment (exp_assop ('=', symname, e_align));
	}
    }

  address = NULL;
  if (link_info.relocatable || (s->flags & (SEC_LOAD | SEC_ALLOC)) == 0)
    address = exp_intop ((bfd_vma) 0);

  load_base = NULL;
  if (place != NULL && place->os->load_base != NULL)
    {
      etree_type *lma_from_vma;
      lma_from_vma = exp_binop ('-', place->os->load_base,
				exp_nameop (ADDR, place->os->name));
      load_base = exp_binop ('+', lma_from_vma,
			     exp_nameop (ADDR, secname));
    }

  os_tail = lang_output_section_statement.tail;
  os = lang_enter_output_section_statement (secname, address, 0,
					    (etree_type *) NULL,
					    (etree_type *) NULL,
					    load_base, 0);

  lang_add_section (&os->children, s, os, file);

  lang_leave_output_section_statement
    ((bfd_vma) 0, "*default*",
     (struct lang_output_section_phdr_list *) NULL, NULL);

  if (config.build_constructors && *ps == '\0')
    {
      char *symname;

      /* lang_leave_ouput_section_statement resets stat_ptr.  Put
	 stat_ptr back where we want it.  */
      if (place != NULL)
	stat_ptr = &add;

      symname = (char *) xmalloc (ps - secname + sizeof "__stop_");
      sprintf (symname, "__stop_%s", secname);
      lang_add_assignment (exp_assop ('=', symname,
				      exp_nameop (NAME, ".")));
    }

  /* Restore the global list pointer.  */
  stat_ptr = old;

  if (place != NULL && os->bfd_section != NULL)
    {
      asection *snew, **pps;

      snew = os->bfd_section;

      /* Shuffle the bfd section list to make the output file look
	 neater.  This is really only cosmetic.  */
      if (place->section == NULL)
	{
	  asection *bfd_section = place->os->bfd_section;

	  /* If the output statement hasn't been used to place
	     any input sections (and thus doesn't have an output
	     bfd_section), look for the closest prior output statement
	     having an output section.  */
	  if (bfd_section == NULL)
	    bfd_section = output_prev_sec_find (place->os);

	  if (bfd_section != NULL && bfd_section != snew)
	    place->section = &bfd_section->next;
	}

      if (place->section != NULL)
	{
	  /* Unlink the section.  */
	  for (pps = &output_bfd->sections; *pps != snew; pps = &(*pps)->next)
	    ;
	  bfd_section_list_remove (output_bfd, pps);

	  /* Now tack it on to the "place->os" section list.  */
	  bfd_section_list_insert (output_bfd, place->section, snew);
	}

      /* Save the end of this list.  Further ophans of this type will
	 follow the one we've just added.  */
      place->section = &snew->next;

      /* The following is non-cosmetic.  We try to put the output
	 statements in some sort of reasonable order here, because
	 they determine the final load addresses of the orphan
	 sections.  In addition, placing output statements in the
	 wrong order may require extra segments.  For instance,
	 given a typical situation of all read-only sections placed
	 in one segment and following that a segment containing all
	 the read-write sections, we wouldn't want to place an orphan
	 read/write section before or amongst the read-only ones.  */
      if (add.head != NULL)
	{
	  lang_statement_union_type *newly_added_os;

	  if (place->stmt == NULL)
	    {
	      /* Put the new statement list right at the head.  */
	      *add.tail = place->os->header.next;
	      place->os->header.next = add.head;

	      place->os_tail = &place->os->next;
	    }
	  else
	    {
	      /* Put it after the last orphan statement we added.  */
	      *add.tail = *place->stmt;
	      *place->stmt = add.head;
	    }

	  /* Fix the global list pointer if we happened to tack our
	     new list at the tail.  */
	  if (*old->tail == add.head)
	    old->tail = add.tail;

	  /* Save the end of this list.  */
	  place->stmt = add.tail;

	  /* Do the same for the list of output section statements.  */
	  newly_added_os = *os_tail;
	  *os_tail = NULL;
	  newly_added_os->output_section_statement.next = *place->os_tail;
	  *place->os_tail = newly_added_os;
	  place->os_tail = &newly_added_os->output_section_statement.next;

	  /* Fixing the global list pointer here is a little different.
	     We added to the list in lang_enter_output_section_statement,
	     trimmed off the new output_section_statment above when
	     assigning *os_tail = NULL, but possibly added it back in
	     the same place when assigning *place->os_tail.  */
	  if (*os_tail == NULL)
	    lang_output_section_statement.tail = os_tail;
	}
    }
d1447 5
a1451 5
sed $sc ldscripts/${EMULATION_NAME}.xu                 >> e${EMULATION_NAME}.c
echo '  ; else if (link_info.relocatable) return'     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xr                 >> e${EMULATION_NAME}.c
echo '  ; else if (!config.text_read_only) return'     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xbn                >> e${EMULATION_NAME}.c
d1453 2
a1454 2
echo '  ; else if (!config.magic_demand_paged) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xn                 >> e${EMULATION_NAME}.c
d1461 1
a1461 1
sed $sc ldscripts/${EMULATION_NAME}.xdw                >> e${EMULATION_NAME}.c
d1463 1
a1463 1
sed $sc ldscripts/${EMULATION_NAME}.xdc                >> e${EMULATION_NAME}.c
d1465 2
a1466 2
echo '  ; else if (link_info.pie) return'	       >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xd                 >> e${EMULATION_NAME}.c
d1473 1
a1473 1
sed $sc ldscripts/${EMULATION_NAME}.xsw                >> e${EMULATION_NAME}.c
d1475 1
a1475 1
sed $sc ldscripts/${EMULATION_NAME}.xsc                >> e${EMULATION_NAME}.c
d1477 2
a1478 2
echo '  ; else if (link_info.shared) return'	       >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xs                 >> e${EMULATION_NAME}.c
d1483 7
a1489 7
sed $sc ldscripts/${EMULATION_NAME}.xw                 >> e${EMULATION_NAME}.c
echo '  ; else if (link_info.combreloc) return'        >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xc                 >> e${EMULATION_NAME}.c
fi
echo '  ; else return'                                 >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.x                  >> e${EMULATION_NAME}.c
echo '; }'                                             >> e${EMULATION_NAME}.c
@


1.122
log
@	* emultempl/elf32.em (gld${EMULATION_NAME}_ld_so_conf): New structure.
	(gld${EMULATION_NAME}_parse_ld_so_conf,
	gld${EMULATION_NAME}_parse_ld_so_conf_include): New functions.
	(gld${EMULATION_NAME}_check_ld_so_conf): Use them.
@
text
@d566 2
a567 2
  char *line = NULL;
  size_t linelen = 0;
d572 18
a589 3
  while (getline (&line, &linelen, f) != -1)
    {
      char *p;
d665 1
@


1.121
log
@remove duplicated word
@
text
@d66 10
d519 45
a563 2
static bfd_boolean
gld${EMULATION_NAME}_check_ld_so_conf (const char *name, int force)
d565 6
a570 3
  static bfd_boolean initialized;
  static char *ld_so_conf;
  struct dt_needed needed;
d572 1
a572 1
  if (! initialized)
d574 21
a594 2
      FILE *f;
      char *tmppath;
d596 1
a596 4
      tmppath = concat (ld_sysroot, "/etc/ld.so.conf", NULL);
      f = fopen (tmppath, FOPEN_RT);
      free (tmppath);
      if (f != NULL)
d598 11
a608 3
	  char *b;
	  size_t len, alloc;
	  int c;
d610 2
a611 3
	  len = 0;
	  alloc = 100;
	  b = (char *) xmalloc (alloc);
d613 18
a630 1
	  while ((c = getc (f)) != EOF)
d632 3
a634 22
	      if (len + 1 >= alloc)
		{
		  alloc *= 2;
		  b = (char *) xrealloc (b, alloc);
		}
	      if (c != ':'
		  && c != ' '
		  && c != '\t'
		  && c != '\n'
		  && c != ',')
		{
		  b[len] = c;
		  ++len;
		}
	      else
		{
		  if (len > 0 && b[len - 1] != ':')
		    {
		      b[len] = ':';
		      ++len;
		    }
		}
a635 6

	  if (len > 0 && b[len - 1] == ':')
	    --len;

	  if (len > 0)
	    b[len] = '\0';
d638 6
a643 2
	      free (b);
	      b = NULL;
d645 8
d654 6
a659 1
	  fclose (f);
d661 4
a664 6
	  if (b)
	    {
	      char *d = gld${EMULATION_NAME}_add_sysroot (b);
	      free (b);
	      b = d;
	    }
d666 10
a675 1
	  ld_so_conf = b;
a676 1

@


1.120
log
@(_place_orphan): Use an already existing section name if that section does not
have any flags set.
@
text
@d1267 1
a1267 1
     been created by the linker, probably as a result of a --section-start
@


1.119
log
@bfd/

2004-07-19  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfd-in.h (dynamic_lib_link_class): Add DYN_NO_ADD_NEEDED and
	DYN_NO_NEEDED.
	(bfd_elf_get_dyn_lib_class): New prototype.
	* elf.c (bfd_elf_get_dyn_lib_class): New function.

	* elflink.c (elf_link_add_object_symbols): Check DYN_AS_NEEDED,
	DYN_DT_NEEDED and DYN_NO_NEEDED bits to see if a DT_NEEDED
	entry is needed. Issue an error if a DT_NEEDED entry is needed
	for a file marked DYN_NO_NEEDED.
	(elf_link_check_versioned_symbol): Check the DYN_DT_NEEDED bit
	for DT_NEEDED tags.

	* bfd-in2.h: Regenerated.

ld/

2004-07-19  H.J. Lu  <hongjiu.lu@@intel.com>

	* emultempl/elf32.em (gld${EMULATION_NAME}_load_symbols): Also
	check the add_needed field.
	(dt_needed): New struct.
	(gld${EMULATION_NAME}_try_needed): Change the first argument
	to a pointer to struct dt_needed. Check the DYN_NO_ADD_NEEDED
	bit in the file where the DT_NEEDED entry comes from.
	(gld${EMULATION_NAME}_search_needed): Change the second
	argument to a pointer to struct dt_needed.
	(gld${EMULATION_NAME}_check_ld_so_conf): Updated.
	(gld${EMULATION_NAME}_after_open): Likewise.

	* ld.texinfo: Add --add-needed document.
	* ldlang.c (new_afile): Set p->add_needed.
	* ldlang.h (lang_input_statement_type): Add add_needed field.
	* ldmain.h (add_needed): Declare.
	* ldmain.c (add_needed): New global var.
	* lexsup.c (option_values): Add OPTION_ADD_NEEDED and
	OPTION_NO_ADD_NEEDED.
	(ld_options): Likewise.
	(parse_args): Handle them.
@
text
@d1178 1
d1181 1
d1265 6
a1270 2
     loadable or allocatable characteristics.  */
  if (bfd_get_section_by_name (output_bfd, secname) != NULL)
@


1.118
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d99 1
a99 3
  if (!entry->as_needed
      || (bfd_get_file_flags (entry->the_bfd) & DYNAMIC) == 0)
    return FALSE;
d104 14
a117 1
  bfd_elf_set_dyn_lib_class (entry->the_bfd, DYN_AS_NEEDED);
d256 5
d267 2
a268 1
gld${EMULATION_NAME}_try_needed (const char *name, int force)
d271 1
d273 1
d386 11
a396 1
  bfd_elf_set_dyn_lib_class (abfd, DYN_DT_NEEDED);
d409 2
a410 1
gld${EMULATION_NAME}_search_needed (const char *path, const char *name, int force)
d413 1
d415 1
d418 1
a418 1
    return gld${EMULATION_NAME}_try_needed (name, force);
d422 4
d446 2
a447 1
      if (gld${EMULATION_NAME}_try_needed (filename, force))
d514 1
d589 4
a592 1
  return gld${EMULATION_NAME}_search_needed (ld_so_conf, name, force);
d675 1
d692 3
d724 1
a724 1
						  l->name, force))
d730 1
a730 1
						  l->name, force))
d740 1
a740 1
	      if (gld${EMULATION_NAME}_search_needed (lib_path, l->name,
d745 1
a745 1
	  if (gld${EMULATION_NAME}_search_needed (lib_path, l->name, force))
d758 1
a758 1
							      l->name,
d777 2
a778 1
	      if (gld${EMULATION_NAME}_try_needed (filename, force))
@


1.117
log
@	* ldlang.c (lang_add_section): Don't twidlle SEC_EXCLUDE here.
	(output_section_callback): Nor SEC_KEEP here.
	(gc_section_callback): Twiddle SEC_EXCLUDE here.
	(lang_gc_wild): Delete.  Fold into..
	(lang_gc_sections_1): ..here.  Only call bfd_gc_sections when garbage
	collecting.
	(lang_process): Always call lang_gc_sections.
	(lang_place_orphans): Handle SEC_EXCLUDE sections.
	* emultempl/elf32.em (gld${EMULATION_NAME}_place_orphan): Remove
	SEC_EXCLUDE code.
@
text
@d843 1
a843 1
      sinterp->_raw_size = strlen (sinterp->contents) + 1;
d886 1
a886 1
      sinterp->_raw_size = strlen (command_line.interpreter) + 1;
d911 1
a911 1
	sz = bfd_section_size (is->the_bfd, s);
d929 1
a929 1
	s->_raw_size = 0;
@


1.116
log
@bfd/

2004-05-26  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf.c (_bfd_elf_make_section_from_shdr): Undo the last
	change.

ld/

2004-05-26  H.J. Lu  <hongjiu.lu@@intel.com>

	* emultempl/elf32.em (gld${EMULATION_NAME}_place_orphan): Clear
	SEC_EXCLUDE on non-SEC_DEBUGGING sections for relocatable link.
	* ldlang.c (lang_add_section): Likewise.
@
text
@a1184 10
  if (link_info.relocatable && (s->flags & SEC_DEBUGGING) == 0)
    s->flags &= ~SEC_EXCLUDE;

  if ((s->flags & SEC_EXCLUDE) != 0)
    {
      if (s->output_section == NULL)
	s->output_section = bfd_abs_section_ptr;
      return TRUE;
    }

@


1.115
log
@bfd/
	* elf.c (_bfd_elf_make_section_from_shdr): Don't set SEC_EXCLUDE
	for SHT_GROUP sections.
ld/
	* ldlang.c (lang_add_section): Set SEC_EXCLUDE for SEC_GROUP
	sections when doing a final link.  Clear SEC_EXCLUDE when doing
	a relocable link, except for SEC_DEBUGGING sections.
	* emultempl/elf32.em (gld${EMULATION_NAME}_place_orphan): Use the
	same condition here to drop SEC_EXCLUDE orphan sections.
@
text
@d1185 4
a1188 3
  if (((s->flags & (SEC_EXCLUDE | SEC_GROUP)) != 0 && !link_info.relocatable)
      || ((s->flags & (SEC_EXCLUDE | SEC_DEBUGGING))
	  == (SEC_EXCLUDE | SEC_DEBUGGING)))
@


1.114
log
@	* ldgram.y (sect_constraint): New.
	(ONLY_IF_RO, ONLY_IF_RW): New tokens.
	(section): Add sect_constraint.  Pass additional argument
	to lang_enter_output_section_statement.
	* mri.c (mri_draw_tree): Pass additional argument to
	lang_enter_output_section_statement.
	* emultempl/pe.em (place_orphan): Likewise.
	(output_prev_sec_find): Disregard output section statements with
	constraint == -1.
	* emultempl/mmo.em (output_prev_sec_find): Likewise.
	(mmo_place_orphan): Pass additional argument to
	lang_enter_output_section_statement.
	* emultempl/elf32.em (output_prev_sec_find): Disregard output section
	statements with constraint == -1.
	(place_orphan): Pass additional argument to
	lang_enter_output_section_statement.
	* ldlang.c (lang_enter_overlay_section): Likewise.
	(lang_output_section_find_1): New.
	(lang_output_section_find): Use it.
	(lang_output_section_statement_lookup_1): New.
	(lang_output_section_statement_lookup): Use it.
	(check_section_callback, check_input_sections): New.
	(map_input_to_output_sections): Check if all input sections
	are readonly if ONLY_IF_RO or ONLY_IF_RW was seen.
	(strip_excluded_output_sections): Disregard output section statements
	with constraint == -1.
	(lang_record_phdrs): Likewise.
	(lang_enter_output_section_statement): Add constraint argument.
	Use lang_output_section_statement_lookup_1.
	* ldlang.h (lang_output_section_statement_type): Add constraint
	and all_input_readonly fields.
	(lang_enter_output_section_statement): Adjust prototype.
	* ldlex.l (ONLY_IF_RO, ONLY_IF_RW): New tokens.
	* scripttempl/elf.sc (.eh_frame, .gcc_except_table): Move into text
	segment if all input sections are readonly.
@
text
@d1185 3
a1187 1
  if ((s->flags & SEC_EXCLUDE) != 0 && !link_info.relocatable)
@


1.113
log
@bfd/
	* elflink.c (elf_bfd_final_link): Don't output STT_SECTION symbol
	into .dynsym if elf_section_data (sec)->dynindx <= 0.
	Adjust counting of last_local.
	(_bfd_elf_link_renumber_dynsyms): Don't assign dynindx to sections
	other than SHT_PROGBITS/SHT_NOBITS and neither for .got/.got.plt/.plt
	created by the linker nor !SHF_ALLOC.

	* elf32-i386.c (elf_i386_finish_dynamic_sections): Point
	DT_PLTGOT to the start of the .got.plt section instead of the
	.got output section.  Set sh_entsize for .got section in addition
	to .got.plt.
	(elf_i386_relocate_section): Don't assume _GLOBAL_OFFSET_TABLE_
	is at sgot->output_section->vma.
	* elf64-x86-64.c (elf64_x86_64_finish_dynamic_sections): Point
	DT_PLTGOT to the start of the .got.plt section instead of the
	.got output section.
	(elf64_x86_64_relocate_section): Don't assume _GLOBAL_OFFSET_TABLE_
	is at sgot->output_section->vma.  Set sh_entsize for .got section
	in addition to .got.plt.
	* elf.c (_bfd_elf_print_private_bfd_data): Handle PT_GNU_RELRO.
	(bfd_section_from_phdr): Likewise.
	(map_sections_to_segments): Likewise.
	(assign_file_positions_for_segments): Likewise.
	(get_program_header_size): Likewise.
	* elflink.c (bfd_elf_size_dynamic_sections): Set
	elf_tdata (output_bfd)->relro from info->relro.
	* elf-bfd.h (struct elf_obj_tdata): Add relro field.
include/
	* bfdlink.h (struct bfd_link_info): Add relro, relro_start and
	relro_end fields.
	* elf/common.h (PT_GNU_EH_FRAME, PT_GNU_STACK): Add comments.
	(PT_GNU_RELRO): Define.
binutils/
	* readelf.c (get_segment_type): Handle PT_GNU_RELRO.
ld/
	* genscripts.sh: Generate -z combreloc -z now -z relro scripts
	for binaries, -shared and -pie.
	* emulparams/elf_i386.sh (SEPARATE_GOTPLT): Set.
	* emulparams/elf_x86_64.sh (SEPARATE_GOTPLT): Set.
	* emulparams/elf32ppc.sh (OTHER_READWRITE_SECTIONS): Rename to...
	(OTHER_RELRO_SECTIONS): ... this.
	* ldlex.l (DATA_SEGMENT_RELRO_END): Add.
	* emultempl/elf32.em (gld${EMULATION_NAME}_handle_option): Handle
	-z relro and -z norelro.
	(gld${EMULATION_NAME}_list_options): Add it to usage.
	(gld${EMULATION_NAME}_get_script): Return -z combreloc -z now
	-z relro scripts when appropriate.
	* scripttempl/elf.sc: Unset SEPARATE_GOTPLT if RELRO_NOW is set.
	Create separate .got.plt section if SEPARATE_GOTPLT.
	Move sections which are only written during relocation handling
	to the beginning of RW segment.  If NO_SMALL_DATA, move .got
	before .data.  Add DATA_SEGMENT_RELRO_END directive.
	Include OTHER_RELRO_SECTIONS.
	* ldgram.y (DATA_SEGMENT_RELRO_END): Add.
	* ldexp.c (exp_print_token): Handle DATA_SEGMENT_RELRO_END.
	(fold_unary): Likewise.
	(fold_binary): Handle -z relro.
	* ldexp.h (struct exp_data_seg): Add exp_dataseg_relro_seen and
	exp_dataseg_relro_adjust phases.  Add relro_end field.
	* ldmain.c (main): Initialize link_info.relro to FALSE.
	* ldlang.c (lang_size_sections): Handle -z relro.
ld/testsuite/
	* ld-i386/tlspic.rd: Adjust for section reordering changes
	and removal of unneeded STT_SECTION symbols from .dynsym.
	* ld-i386/tlspic.dd: Likewise.
	* ld-i386/tlspic.sd: Likewise.
	* ld-i386/tlsbin.rd: Likewise.
	* ld-i386/tlsbinpic.s: Likewise.
	* ld-i386/tlsbin.dd: Likewise.
	* ld-i386/tlsbin.sd: Likewise.
	* ld-i386/tlsnopic.rd: Likewise.
	* ld-i386/tlsnopic1.s: Likewise.
	* ld-i386/combreloc.d: Likewise.
	* ld-i386/tlsnopic.dd: Likewise.
	* ld-i386/tlsnopic.sd: Likewise.
	* ld-x86-64/tlspic.rd: Likewise.
	* ld-x86-64/tlspic.dd: Likewise.
	* ld-x86-64/tlsbin.dd: Likewise.
	* ld-x86-64/tlspic.sd: Likewise.
	* ld-x86-64/tlsbin.sd: Likewise.
	* ld-x86-64/tlspic.td: Likewise.
	* ld-x86-64/tlsbin.td: Likewise.
	* ld-x86-64/tlsbin.rd: Likewise.
	* ld-s390/tlspic1.s: Likewise.
	* ld-s390/tlsbinpic.s: Likewise.
	* ld-s390/tlspic.rd: Likewise.
	* ld-s390/tlsbin.rd: Likewise.
	* ld-s390/tlspic.dd: Likewise.
	* ld-s390/tlsbin.dd: Likewise.
	* ld-s390/tlsbin.sd: Likewise.
	* ld-s390/tlsbin.td: Likewise.
	* ld-s390/tlspic.sd: Likewise.
	* ld-s390/tlspic.td: Likewise.
	* ld-s390/tlspic1_64.s: Likewise.
	* ld-s390/tlsbinpic_64.s: Likewise.
	* ld-s390/tlspic_64.rd: Likewise.
	* ld-s390/tlsbin_64.rd: Likewise.
	* ld-s390/tlspic_64.dd: Likewise.
	* ld-s390/tlsbin_64.dd: Likewise.
	* ld-s390/tlspic_64.sd: Likewise.
	* ld-s390/tlspic_64.td: Likewise.
	* ld-s390/tlsbin_64.td: Likewise.
	* ld-s390/tlsbin_64.sd: Likewise.
	* ld-powerpc/tlsexe32.r: Likewise.
	* ld-powerpc/tlsso32.r: Likewise.
	* ld-powerpc/tlsso32.d: Likewise.
	* ld-powerpc/tlsso32.g: Likewise.
	* ld-powerpc/tlsso32.t: Likewise.
	* ld-powerpc/tlsexe.r: Likewise.
	* ld-powerpc/tlsso.r: Likewise.
	* ld-powerpc/tlsso.g: Likewise.
	* ld-powerpc/tlsexetoc.r: Likewise.
	* ld-powerpc/tlstocso.r: Likewise.
	* ld-powerpc/tlstocso.g: Likewise.
	* ld-ia64/tlspic.rd: Likewise.
	* ld-ia64/tlspic.dd: Likewise.
	* ld-ia64/tlspic.sd: Likewise.
	* ld-ia64/tlspic.td: Likewise.
	* ld-ia64/tlsbin.rd: Likewise.
	* ld-ia64/tlsbin.sd: Likewise.
	* ld-ia64/tlsbin.td: Likewise.
	* ld-elfvsb/elfvsb.exp: XFAIL non-PIC load offset tests on s390x.
	* ld-shared/shared.exp: Likewise.
@
text
@d1035 2
a1036 1
      if (strncmp (".rel", lookup->name, 4) == 0)
d1283 1
a1283 1
					    load_base);
@


1.112
log
@	* ldlang.c (unique_section_p): Pass section parm, return true on
	group sections.
	(output_section_callback): Adjust.
	* ldlang.h (unique_section_p): Update prototype.
	* emultempl/elf32.em (gld${EMULATION_NAME}_place_orphan): Adjust.
@
text
@d1461 4
d1473 4
d1484 3
d1518 3
d1533 3
d1547 3
d1689 4
d1740 1
d1743 1
@


1.111
log
@	* emultempl/elf32.em: Update new bfd_elf_discard_info name.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/sh64elf.em: Likewise.
@
text
@d1145 1
a1145 1
  if (isdyn || (!config.unique_orphan_sections && !unique_section_p (secname)))
@


1.110
log
@bfd/
	* elflink.h (elf_link_add_object_symbols): Add DT_NEEDED for as-needed
	and chained shared libs only if dynsym.  Clear dynsym on forced-local.

	* elf-bfd.h (_bfd_elf_add_dynamic_entry): Declare.
	(bfd_elf32_add_dynamic_entry, bfd_elf64_add_dynamic_entry): Delete.
	(_bfd_elf_add_dt_needed_tag): Declare.
	(_bfd_elf_sort_symbol): Declare.
	(_bfd_elf_finalize_dynstr): Declare.
	(RELOC_FOR_GLOBAL_SYM): Formatting.
	* elfcode.h (elf_add_dynamic_entry): Delete.
	* elflink.c (_bfd_elf_add_dynamic_entry): New function.  Corresponding
	elflink.h function converted to use elf_size_info.
	(_bfd_elf_add_dt_needed_tag): Likewise.
	(_bfd_elf_sort_symbol): Likewise.
	(_bfd_elf_finalize_dynstr): Likewise.
	(compute_bucket_count): Likewise.
	(bfd_elf_size_dynamic_sections): Likewise.  Check result of
	_bfd_elf_strtab_add before calling _bfd_elf_strtab_addref.
	(elf_adjust_dynstr_offsets, elf_collect_hash_codes): Moved from..
	* elflink.h: ..here.
	(sort_symbol, add_dt_needed_tag): Delete.
	(elf_add_dynamic_entry, elf_finalize_dynstr): Delete.
	(compute_bucket_count, NAME(bfd_elf,size_dynamic_sections)): Delete.
	Update all users.
	* elf32-arm.h (add_dynamic_entry): Update.  Remove casts.
	* elf32-cris.c (add_dynamic_entry): Likewise.
	* elf32-hppa.c (add_dynamic_entry): Likewise.
	* elf32-i370.c (add_dynamic_entry): Likewise.
	* elf32-i386.c (add_dynamic_entry): Likewise.
	* elf32-m32r.c (add_dynamic_entry): Likewise.
	* elf32-m68k.c (add_dynamic_entry): Likewise.
	* elf32-ppc.c (add_dynamic_entry): Likewise.
	* elf32-s390.c (add_dynamic_entry): Likewise.
	* elf32-sh.c (add_dynamic_entry): Likewise.
	* elf32-sparc.c (add_dynamic_entry): Likewise.
	* elf32-vax.c (add_dynamic_entry): Likewise.
	* elf32-xtensa.c (add_dynamic_entry): Likewise.
	* elf64-alpha.c (add_dynamic_entry): Likewise.
	* elf64-hppa.c (add_dynamic_entry): Likewise.
	* elf64-ppc.c (add_dynamic_entry): Likewise.
	* elf64-s390.c (add_dynamic_entry): Likewise.
	* elf64-sparc.c (add_dynamic_entry): Likewise.
	* elf64-x86-64.c (add_dynamic_entry): Likewise.
	* elfxx-ia64.c (add_dynamic_entry): Likewise.
	* elfxx-mips.c (MIPS_ELF_ADD_DYNAMIC_ENTRY): Likewise.
	* elf-m10300.c (_bfd_mn10300_elf_size_dynamic_sections): Likewise.
	* elf32-frv.c (elf32_frv_size_dynamic_sections): Likewise.
	* elf64-sh64.c (sh64_elf64_size_dynamic_sections): Likewise.
ld/
	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation): Update
	size_dynamic_sections call.
@
text
@d1410 1
a1410 1
  if (bfd_elf${ELFSIZE}_discard_info (output_bfd, &link_info))
@


1.109
log
@bfd/
	* elf-bfd.h (struct elf_obj_tdata): Delete dt_soname field.  Add
	dyn_lib_class field.  Rearrange for better packing.
	(elf_dt_soname): Delete.
	(elf_dyn_lib_class): Define.
	* elf.c (bfd_elf_set_dt_needed_name): Update comment.
	(bfd_elf_set_dt_needed_soname): Delete.
	(bfd_elf_set_dyn_lib_class): New function.
	* elflink.h (add_dt_needed_tag): New function.  Split out from..
	(elf_link_add_object_symbols): ..here.  Rename "name" to "soname".
	Use elf_dyn_lib_class to set dt_needed and add_needed.  Move fallback
	initialization of soname.
	(elf_link_check_versioned_symbol): Test elf_dyn_lib_class instead of
	elf_dt_soname.
	* bfd-in.h (enum dynamic_lib_link_class): New.
	(bfd_elf_set_dt_needed_soname): Delete.
	(bfd_elf_set_dyn_lib_class): Declare.
	* bfd-in2.h: Regenerate.
ld/
	* ld.texinfo: Add --as-needed doco.
	* ldmain.c (as_needed): New global var.
	* ldmain.h (as_needed): Declare.
	* lexsup.c (option_values): Add OPTION_AS_NEEDED and
	OPTION_NO_AS_NEEDED.
	(ld_options): Likewise.
	(parse_args): Handle them.
	* ldlang.h (lang_input_statement_type): Add as_needed field.
	* ldlang.c (new_afile): Set p->as_needed.
	* emultempl/elf32.em (gld${EMULATION_NAME}_load_symbols): New function.
	(gld${EMULATION_NAME}_try_needed): Use bfd_elf_set_dyn_lib_class.
	(ld_${EMULATION_NAME}_emulation): Set LDEMUL_RECOGNIZED_FILE entry.

	* ldlang.c (open_input_bfds): Remove useless cast.
	(lang_do_assignments_1): Likewise.
	(lang_for_each_input_section): Delete.
@
text
@d874 1
a874 1
  if (! (bfd_elf${ELFSIZE}_size_dynamic_sections
@


1.108
log
@	* ldexp.c (align_n): Make static.
	* ldexp.h (align_n): Delete declaration.
	* ldlang.h (lang_enter_output_section_statement): Remove
	block_value param.
	* ldlang.c (lang_enter_output_section_statement): Likewise.
	(TO_ADDR, TO_SIZE): Define.
	(opb): New var.
	(init_opb): New function.
	(print_input_section): Call init_opb and use TO_ADDR.
	(print_data_statement, print_reloc_statement): Likewise.
	(print_padding_statement): Likewise.
	(size_input_section): Use TO_SIZE and TO_ADDR, and global opb.
	(lang_check_section_addresses): Likewise.
	(lang_size_sections_1): Likewise.
	(lang_do_assignments_1): Likewise.
	(lang_set_startof): Likewise.
	(lang_one_common): Likewise.  Combine power_of_two and opb alignment.
	(lang_process): Call init_opb.
	(lang_abs_symbol_at_end_of): Use TO_ADDR and global opb.
	(lang_enter_overlay_section): Adjust
	lang_enter_output_section_statement call.
	* ldgram.y: Likewise.
	* mri.c (mri_draw_tree): Likewise.
	* emultempl/elf32.em (gld${EMULATION_NAME}_place_orphan): Likewise.
	* emultempl/mmo.em (mmo_place_orphan): Likewise.
	* emultempl/pe.em (gld${EMULATION_NAME}_place_orphan): Likewise.
@
text
@d92 22
d361 7
a367 8
  /* Tell the ELF backend that we don't want the output file to have a
     DT_NEEDED entry for this file.  */
  bfd_elf_set_dt_needed_name (abfd, "");

  /* Tell the ELF backend that the output file needs a DT_NEEDED
     entry for this file if it is used to resolve the reference in
     a regular object.  */
  bfd_elf_set_dt_needed_soname (abfd, soname);
d1776 1
a1776 1
  ${LDEMUL_RECOGNIZED_FILE-NULL},
@


1.108.6.1
log
@Merge from mainline
@
text
@a91 22
if test x"$LDEMUL_RECOGNIZED_FILE" != xgld"${EMULATION_NAME}"_load_symbols; then
cat >>e${EMULATION_NAME}.c <<EOF
/* Handle as_needed DT_NEEDED.  */

static bfd_boolean
gld${EMULATION_NAME}_load_symbols (lang_input_statement_type *entry)
{
  if (!entry->as_needed
      || (bfd_get_file_flags (entry->the_bfd) & DYNAMIC) == 0)
    return FALSE;

  /* Tell the ELF linker that we don't want the output file to have a
     DT_NEEDED entry for this file, unless it is used to resolve
     references in a regular object.  */
  bfd_elf_set_dyn_lib_class (entry->the_bfd, DYN_AS_NEEDED);

  /* Continue on with normal load_symbols processing.  */
  return FALSE;
}
EOF
fi

d339 8
a346 7
  /* Specify the soname to use.  */
  bfd_elf_set_dt_needed_name (abfd, soname);

  /* Tell the ELF linker that we don't want the output file to have a
     DT_NEEDED entry for this file, unless it is used to resolve
     references in a regular object.  */
  bfd_elf_set_dyn_lib_class (abfd, DYN_DT_NEEDED);
d853 1
a853 1
  if (! (bfd_elf_size_dynamic_sections
d1389 1
a1389 1
  if (bfd_elf_discard_info (output_bfd, &link_info))
d1755 1
a1755 1
  ${LDEMUL_RECOGNIZED_FILE-gld${EMULATION_NAME}_load_symbols},
@


1.107
log
@	* ldfile.c (ldfile_set_output_arch): Add defarch param.
	* ldfile.h (ldfile_set_output_arch): Ditto.
	* emultempl/aix.em (gld${EMULATION_NAME}_before_parse): Use
	ldfile_set_output_arch.
	* emultempl/beos.em (gld${EMULATION_NAME}_before_parse): Ditto.
	* emultempl/elf32.em (gld${EMULATION_NAME}_before_parse): Ditto.
	* emultempl/linux.em (gld${EMULATION_NAME}_before_parse): Ditto.
	* emultempl/mipsecoff.em (gld${EMULATION_NAME}_before_parse): Ditto.
	* emultempl/pe.em (gld${EMULATION_NAME}_before_parse): Ditto.
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_parse): Ditto.
	* ldgram.y: Adjust ldfile_set_output_arch call.
	* emultempl/armcoff.em (gld${EMULATION_NAME}_before_parse): Ditto.
	* emultempl/armelf.em (gld${EMULATION_NAME}_before_parse): Ditto.
	* emultempl/armelf_oabi.em (gld${EMULATION_NAME}_before_parse): Ditto.
	* emultempl/generic.em (gld${EMULATION_NAME}_before_parse): Ditto.
	* emultempl/gld960c.em (gld960_set_output_arch): Ditto.
	* emultempl/m68kcoff.em (gld${EMULATION_NAME}_before_parse): Ditto.
	* emultempl/ticoff.em (gld${EMULATION_NAME}_before_parse): Ditto.
@
text
@a1258 1
					    (bfd_vma) 0,
@


1.106
log
@	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation): Test
	hash table type rather than testing creator flavour.
	* emultempl/hppaelf.em (hppaelf_create_output_section_statements):
	Only create stub_file bfd if hash table creator is as expected.
	(gld${EMULATION_NAME}_finish): Test stub_file.
@
text
@d16 1
a16 1
   2002, 2003 Free Software Foundation, Inc.
d84 1
a84 9
  const bfd_arch_info_type *arch = bfd_scan_arch ("${OUTPUT_ARCH}");
  if (arch)
    {
      ldfile_output_architecture = arch->arch;
      ldfile_output_machine = arch->mach;
      ldfile_output_machine_name = arch->printable_name;
    }
  else
    ldfile_output_architecture = bfd_arch_`echo ${ARCH} | sed -e 's/:.*//'`;
@


1.105
log
@	* bfd-in.h (_bfd_elf_tls_setup): Declare.
	* bfd-in2.h: Regenerate.
	* elf-bfd.h (struct elf_link_tls_segment): Delete.
	(struct elf_link_hash_table): Add tls_sec and tls_size.
	* elf.c (_bfd_elf_link_hash_table_init): Init tls_sec and tls_size.
	* elflink.c (_bfd_elf_tls_setup): New function.
	* elflink.h (struct elf_final_link_info): Remove first_tls_sec.
	(elf_bfd_final_link): Don't set first_tls_sec here.  Update code
	saving tls segment info, round segment size up.
	(elf_link_output_extsym): Adjust code using tls segment info.
	(elf_link_input_bfd): Likewise.
	* elf32-i386.c (dtpoff_base, tpoff): Likewise.
	* elf32-s390.c (dtpoff_base, tpoff): Likewise.
	* elf32-sh.c (dtpoff_base, tpoff): Likewise.
	* elf32-sparc.c (dtpoff_base, tpoff): Likewise.
	* elf64-s390.c (dtpoff_base, tpoff): Likewise.
	* elf64-x86-64.c (dtpoff_base, tpoff): Likewise.
	* elfxx-ia64.c (elfNN_ia64_tprel_base): Likewise.
	(elfNN_ia64_dtprel_base): Likewise.
	* elf64-alpha.c (alpha_get_dtprel_base): Likewise.
	(alpha_get_tprel_base): Likewise.
	(struct alpha_relax_info): Remove tls_segment.
	(elf64_alpha_relax_got_load): Adjust invocation of
	alpha_get_dtprel_base and alpha_get_tprel_base.
	(elf64_alpha_relax_tls_get_addr): Likewise.
	(elf64_alpha_relax_section): Likewise.
	(elf64_alpha_relocate_section): Likewise.
	(elf64_alpha_relax_find_tls_segment): Delete.
	* elf32-ppc.c (struct ppc_elf_link_hash_table): Remove tls_sec.
	(ppc_elf_tls_setup): Call _bfd_elf_tls_setup.  Return section.
	(ppc_elf_relocate_section): Adjust to use elf.tls_sec.
	* elf32-ppc.h (ppc_elf_tls_setup): Update.
	* elf64-ppc.c (struct ppc_link_hash_table): Remove tls_sec.
	(ppc64_elf_tls_setup): Call _bfd_elf_tls_setup.  Return section.
	(ppc64_elf_tls_optimize): Adjust to use elf.tls_sec.
	(ppc64_elf_relocate_section): Likewise.
	* elf64-ppc.h (ppc64_elf_tls_setup): Update.

	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation): Call
	_bfd_elf_tls_setup.
@
text
@d848 1
a848 1
  if (link_info.hash->creator->flavour == bfd_target_elf_flavour)
@


1.104
log
@Better handking for unresolved symbols
@
text
@d848 3
@


1.103
log
@Prefix .gnu.warning section messages with "warning: ".
@
text
@d1605 2
a1606 1
      link_info.no_undefined = TRUE;
d1635 1
a1635 1
	link_info.no_undefined = TRUE;
d1688 1
a1688 1
  fprintf (file, _("  -z defs\t\tDisallows undefined symbols\n"));
@


1.102
log
@	* emultempl/elf32.em (output_rel_find): Add "isdyn" param.  Put
	.rel.dyn before other reloc sections.  Don't stop looking for reloc
	sections on finding one that isn't allocated.  Match .rel even when
	placing .rela and vice versa, when setting last_rel and
	last_rel_alloc for the first time.  If no reloc sections in script,
	prefer allocated section over non-alloc.
	(gld${EMULATION_NAME}_place_orphan): Handle orphan .rel.dyn.
@
text
@d883 1
d886 1
d896 5
a900 2
	msg = xmalloc ((size_t) sz + 1);
	if (! bfd_get_section_contents (is->the_bfd, s, msg, (file_ptr) 0, sz))
d903 1
a903 1
	msg[sz] = '\0';
@


1.101
log
@	* emultempl/aix.em: Convert to C90, remove unnecessary prototypes
	and casts.  Replace PTR with void *.  Formatting.
	* emultempl/alphaelf.em: Likewise
	* emultempl/armcoff.em: Likewise
	* emultempl/armelf.em: Likewise
	* emultempl/armelf_oabi.em: Likewise
	* emultempl/beos.em: Likewise
	* emultempl/elf32.em: Likewise
	* emultempl/generic.em: Likewise
	* emultempl/gld960.em: Likewise
	* emultempl/gld960c.em: Likewise
	* emultempl/hppaelf.em: Likewise
	* emultempl/linux.em: Likewise
	* emultempl/lnk960.em: Likewise
	* emultempl/m68hc1xelf.em: Likewise
	* emultempl/m68kcoff.em: Likewise
	* emultempl/m68kelf.em: Likewise
	* emultempl/mipsecoff.em: Likewise
	* emultempl/mipself.em: Likewise
	* emultempl/mmix-elfnmmo.em: Likewise
	* emultempl/mmixelf.em: Likewise
	* emultempl/mmo.em: Likewise
	* emultempl/needrelax.em: Likewise
	* emultempl/netbsd.em: Likewise
	* emultempl/pe.em: Likewise
	* emultempl/sh64elf.em: Likewise
	* emultempl/sunos.em: Likewise
	* emultempl/ticoff.em: Likewise
	* emultempl/vanilla.em: Likewise
	* emultempl/xtensaelf.em: Likewise
	* Makefile.am: Correct dependencies.
	* Makefile.in: Regenerate.
@
text
@d1001 1
a1001 1
output_rel_find (asection *sec)
d1006 1
a1015 3
	  /* Don't place after .rel.plt as doing so results in wrong
	     dynamic tags.  Also, place allocated reloc sections before
	     non-allocated.  */
d1018 8
a1025 3
	  if (strcmp (".plt", lookup->name + 4 + lookrela) == 0
	      || (lookup->bfd_section != NULL
		  && (lookup->bfd_section->flags & SEC_ALLOC) == 0))
d1027 2
a1028 2
	  last = lookup;
	  if (rela == lookrela)
d1030 2
a1031 1
	  if (lookup->bfd_section != NULL
d1035 5
d1048 3
d1189 1
a1189 1
	       || (hold_rel.os = output_rel_find (s)) != NULL))
@


1.100
log
@Correct spelling of "relocatable".
@
text
@d56 4
a59 26
static void gld${EMULATION_NAME}_before_parse
  PARAMS ((void));
static void gld${EMULATION_NAME}_vercheck
  PARAMS ((lang_input_statement_type *));
static void gld${EMULATION_NAME}_stat_needed
  PARAMS ((lang_input_statement_type *));
static bfd_boolean gld${EMULATION_NAME}_try_needed
  PARAMS ((const char *, int));
static bfd_boolean gld${EMULATION_NAME}_search_needed
  PARAMS ((const char *, const char *, int));
static void gld${EMULATION_NAME}_check_needed
  PARAMS ((lang_input_statement_type *));
static void gld${EMULATION_NAME}_after_open
  PARAMS ((void));
static void gld${EMULATION_NAME}_find_exp_assignment
  PARAMS ((etree_type *));
static void gld${EMULATION_NAME}_find_statement_assignment
  PARAMS ((lang_statement_union_type *));
static void gld${EMULATION_NAME}_before_allocation
  PARAMS ((void));
static bfd_boolean gld${EMULATION_NAME}_open_dynamic_archive
  PARAMS ((const char *, search_dirs_type *, lang_input_statement_type *));
static lang_output_section_statement_type *output_rel_find
  PARAMS ((asection *));
static asection *output_prev_sec_find
  PARAMS ((lang_output_section_statement_type *));
d61 2
a62 5
  PARAMS ((lang_input_statement_type *, asection *));
static void gld${EMULATION_NAME}_finish
  PARAMS ((void));
static char *gld${EMULATION_NAME}_get_script
  PARAMS ((int *isfile));
d82 1
a82 1
gld${EMULATION_NAME}_before_parse ()
d130 1
a130 2
gld${EMULATION_NAME}_vercheck (s)
     lang_input_statement_type *s;
d167 4
a170 4
             the object we are considering needs a dynamic object
             FOO.SO.VER2, and VER1 and VER2 are different.  This
             appears to be a version mismatch, so we tell the caller
             to try a different version of this library.  */
d182 1
a182 2
gld${EMULATION_NAME}_stat_needed (s)
     lang_input_statement_type *s;
d237 1
a237 3
gld${EMULATION_NAME}_try_needed (name, force)
     const char *name;
     int force;
d284 1
a284 1
                 another file on the search path.  */
d289 5
a293 5
             library does not use libc at all, we are supposed to skip
             it the first time around in case we encounter a shared
             library later on with the same name which does use the
             version of libc that we want.  This is much too horrible
             to use on any system other than Linux.  */
d343 1
a343 1
         we aren't going to do anything with it.  */
d367 1
a367 4
gld${EMULATION_NAME}_search_needed (path, name, force)
     const char *path;
     const char *name;
     int force;
a415 2
static char * gld${EMULATION_NAME}_add_sysroot PARAMS ((const char *));

d417 1
a417 2
gld${EMULATION_NAME}_add_sysroot (path)
     const char *path;
d440 1
a440 1
        *p++ = path[i++];
a458 3
static bfd_boolean gld${EMULATION_NAME}_check_ld_so_conf
  PARAMS ((const char *, int));

d460 1
a460 3
gld${EMULATION_NAME}_check_ld_so_conf (name, force)
     const char *name;
     int force;
d551 1
a551 2
gld${EMULATION_NAME}_check_needed (s)
     lang_input_statement_type *s;
d600 1
a600 1
gld${EMULATION_NAME}_after_open ()
d756 1
a756 2
gld${EMULATION_NAME}_find_exp_assignment (exp)
     etree_type *exp;
d816 1
a816 2
gld${EMULATION_NAME}_find_statement_assignment (s)
     lang_statement_union_type *s;
d843 1
a843 1
gld${EMULATION_NAME}_before_allocation ()
d859 1
a859 1
         (output_bfd, command_line.soname, rpath,
d924 2
a925 4
gld${EMULATION_NAME}_open_dynamic_archive (arch, search, entry)
     const char *arch;
     search_dirs_type *search;
     lang_input_statement_type *entry;
d1001 1
a1001 2
output_rel_find (sec)
     asection *sec;
d1046 1
a1046 2
output_prev_sec_find (os)
     lang_output_section_statement_type *os;
d1078 1
a1078 3
gld${EMULATION_NAME}_place_orphan (file, s)
     lang_input_statement_type *file;
     asection *s;
d1376 1
a1376 1
gld${EMULATION_NAME}_finish ()
d1401 1
a1401 2
gld${EMULATION_NAME}_get_script (isfile)
     int *isfile;
a1525 3
static void gld${EMULATION_NAME}_add_options
  PARAMS ((int, char **, int, struct option **, int, struct option **));

d1527 3
a1529 7
gld${EMULATION_NAME}_add_options (ns, shortopts, nl, longopts, nrl, really_longopts)
     int ns;
     char **shortopts;
     int nl;
     struct option **longopts;
     int nrl ATTRIBUTE_UNUSED;
     struct option **really_longopts ATTRIBUTE_UNUSED;
a1560 3
static bfd_boolean gld${EMULATION_NAME}_handle_option
  PARAMS ((int));

d1562 1
a1562 2
gld${EMULATION_NAME}_handle_option (optc)
     int optc;
d1625 1
a1625 1
        link_info.nocopyreloc = TRUE;
a1657 2
static void gld${EMULATION_NAME}_list_options PARAMS ((FILE * file));

d1659 1
a1659 2
gld${EMULATION_NAME}_list_options (file)
     FILE * file;
@


1.99
log
@2003-06-05  Roland McGrath  <roland@@redhat.com>

	* emultempl/elf32.em (gld${EMULATION_NAME}_list_options): Remove
	extra \t in -z noexecstack line.
@
text
@d646 1
a646 1
  if (link_info.relocateable || !link_info.executable)
d1149 1
a1149 1
  if (! link_info.relocateable
d1184 1
a1184 1
      && ! link_info.relocateable
d1200 1
a1200 1
  if ((s->flags & SEC_EXCLUDE) != 0 && !link_info.relocateable)
d1281 1
a1281 1
  if (link_info.relocateable || (s->flags & (SEC_LOAD | SEC_ALLOC)) == 0)
d1465 1
a1465 1
  if (link_info.relocateable && config.build_constructors)
d1469 1
a1469 1
echo '  ; else if (link_info.relocateable) return'     >> e${EMULATION_NAME}.c
d1508 1
a1508 1
  if (link_info.relocateable && config.build_constructors)
d1510 1
a1510 1
  else if (link_info.relocateable)
@


1.98
log
@binutils/
	* readelf.c (get_segment_type): Handle PT_GNU_STACK.
bfd/
	* elf.c (_bfd_elf_print_private_bfd_data): Handle PT_GNU_STACK.
	(bfd_section_from_phdr): Likewise.
	(map_sections_to_segments): Create PT_GNU_STACK segment header.
	(get_program_header_size): Count with PT_GNU_STACK.
	* elf-bfd.h (struct elf_obj_tdata): Add stack_flags.
	* elflink.h (bfd_elfNN_size_dynamic_sections): Set stack_flags.
include/
	* bfdlink.h (struct bfd_link_info): Add execstack and noexecstack.
	* elf/common.h (PT_GNU_STACK): Define.
ld/
	* ldgram.y (phdr_type): Grok PT_GNU_STACK.
	* emultempl/elf32.em (gld${EMULATION_NAME}_handle_option): Add
	-z execstack and -z noexecstack.
	(gld${EMULATION_NAME}_list_options): Likewise.
	* scripttempl/elf.sc: If not -r, discard .note.GNU-stack section.
@
text
@d1746 1
a1746 1
  fprintf (file, _("  -z noexecstack\t\tMark executable as not requiring executable stack\n"));
@


1.97
log
@bfd/
	* elflink.h (elf_link_add_object_symbols): Use !info->executable
	instead of info->shared where appropriate.
	(bfd_elfNN_size_dynamic_sections, elf_link_output_extsym): Likewise.
	* elflink.c (_bfd_elf_create_got_section): Likewise.
	(_bfd_elf_link_create_dynamic_sections): Likewise.
	(_bfd_elf_link_assign_sym_version): Likewise.
	* elf32-i386.c (elf_i386_size_dynamic_sections): Create .interp section
	and DT_DEBUG dynamic tag even for position independent executables.
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Likewise.
	* elf32-s390.c (elf_s390_size_dynamic_sections: Likewise.
	* elf64-ppc.c (ppc64_elf_size_dynamic_sections: Likewise.
	* elf64-s390.c (elf_s390_size_dynamic_sections: Likewise.
	* elf64-x86-64.c (elf64_x86_64_size_dynamic_sections: Likewise.
	* elfxx-ia64.c (elfNN_ia64_size_dynamic_sections: Likewise.
	* elf32-sparc.c (elf32_sparc_size_dynamic_sections: Likewise.
	* elf64-alpha.c (elf64_alpha_size_dynamic_sections: Likewise.
	* elf64-sparc.c (sparc64_elf_size_dynamic_sections: Likewise.
include/
	* bfdlink.h (struct bfd_link_info): Add pie and executable
	bits.
ld/
	* lexsup.c (OPTION_PIE): Define.
	(ld_options): Add -pie and --pic-executable options.
	(parse_args): Handle OPTION_PIE.
	* ldmain.c (main): Initialize link_info.pie and
	link_info.executable.
	* genscripts.sh: Generate PIE scripts.
	* ld.texinfo: Document -pie and --pic-executable options.
	* emultempl/elf32.em (gld${EMULATION_NAME}_after_open):
	(gld${EMULATION_NAME}_place_orphan): Likewise.
	(gld${EMULATION_NAME}_get_script): Include PIE scripts.
	* scripttempl/elf.sc: In PIE scripts set . the same way as in
	shared scripts.
	* emulparams/elf_i386.sh (GENERATE_PIE_SCRIPT): Set to yes.
	* emulparams/elf64_ia64.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf32ppc.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf64ppc.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf_x86_64.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf_s390.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf32_sparc.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf64_sparc.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf64alpha.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf64_s390.sh (GENERATE_PIE_SCRIPT): Likewise.
	* emulparams/elf_i386.sh (GENERATE_PIE_SCRIPT): Likewise.
@
text
@d1687 10
d1735 1
d1746 1
@


1.96
log
@	* Makefile.am (em68hc11elf.c): Correct dependencies.
	(em68hc11elfb.c, em68hc12elf.c, em68hc12elfb.c): Likewise.
	* Makefile.in: Regenerate.
	* emultempl/elf32.em (find_exp_assignment): Adjust for changed
	bfd_elf_record_link_assignment name.
@
text
@d646 1
a646 1
  if (link_info.relocateable || link_info.shared)
d1183 1
a1183 1
  if (! link_info.shared
d1477 8
d1520 12
@


1.95
log
@	* ldemul.c: Include getopt.h.
	* emultempl/elf32.em: Include getopt.h earlier.
	* emultempl/ticoff.em: Likewise.
@
text
@d822 1
a822 1
	  if (! (bfd_elf${ELFSIZE}_record_link_assignment
@


1.94
log
@	* emultempl/elf32.em (gld${EMULATION_NAME}_get_script): Add combreloc
	support when scripts read from files.
@
text
@d42 1
a54 1
#include "getopt.h"
@


1.93
log
@	* ldemul.c (ldemul_add_options, ldemul_handle_option): New functions.
	(ldemul_parse_args): Return bfd_boolean.  Formatting.
	* ldemul.h (ldemul_add_options, ldemul_handle_option): Declare.
	(ldemul_parse_args): Adjust.
	(struct ld_emulation_xfer_struct): Add add_options and handle_option.
	Return bfd_boolean from parse_args.
	* lexsup.c (parse_args): Malloc shortopts, longopts and
	really_longopts.  Call ldemul_add_options and ldemul_handle_option.
	* emultempl/aix.em (gld${EMULATION_NAME}_add_options): Split out from
	gld${EMULATION_NAME}_parse_args.
	(gld${EMULATION_NAME}_handle_option): Likewise.
	(ld_${EMULATION_NAME}_emulation): Adjust initializer.
	* emultempl/armcoff.em: As for aix.em, but remove parse_args.
	* emultempl/beos.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/ticoff.em: Likewise.
	* emultempl/elf32.em: Likewise.  Don't duplicate long options either.
	(gld${EMULATION_NAME}_add_sysroot): Prototype.
	* emultempl/armelf.em (PARSE_AND_LIST_LONGOPTS): Don't duplicate
	options.
	* emultempl/hppaelf.em (PARSE_AND_LIST_LONGOPTS): Likewise.
	* emultempl/ppc32elf.em (PARSE_AND_LIST_LONGOPTS): Likewise.
	* emultempl/ppc64elf.em (PARSE_AND_LIST_LONGOPTS): Likewise.
	* emultempl/armelf_oabi.em (ld_${EMULATION_NAME}_emulation): Adjust
	initializer.
	* emultempl/generic.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/gld960c.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68kcoff.em: Likewise.
	* emultempl/mipsecoff.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/vanilla.em: Likewise.
	* emultempl/netbsd.em (gldnetbsd_before_parse): Prototype.
@
text
@d1506 4
d1512 10
d1524 9
@


1.92
log
@* emultempl/elf32.em (gld${EMULATION_NAME}_add_sysroot): Fix
memory allocation error.
@
text
@d54 1
d448 2
a1519 2
if test x"$LDEMUL_PARSE_ARGS" != xgld"$EMULATION_NAME"_parse_args; then

a1527 2
#include "getopt.h"

d1533 11
a1543 1
static struct option longopts[] =
d1545 2
d1551 4
a1554 9
  /* getopt allows abbreviations, so we do this to stop it from
     treating -d/-e as abbreviations for these options. */
  {"disable-new-dtags", no_argument, NULL, OPTION_DISABLE_NEW_DTAGS},
  {"disable-new-dtags", no_argument, NULL, OPTION_DISABLE_NEW_DTAGS},
  {"enable-new-dtags", no_argument, NULL, OPTION_ENABLE_NEW_DTAGS},
  {"enable-new-dtags", no_argument, NULL, OPTION_ENABLE_NEW_DTAGS},
  {"eh-frame-hdr", no_argument, NULL, OPTION_EH_FRAME_HDR},
  {"Bgroup", no_argument, NULL, OPTION_GROUP},
  {"Bgroup", no_argument, NULL, OPTION_GROUP},
d1560 1
a1560 1
 $PARSE_AND_LIST_LONGOPTS
d1565 2
a1566 2
  {NULL, no_argument, NULL, 0}
};
d1568 6
d1575 2
a1576 23
static int gld${EMULATION_NAME}_parse_args PARAMS ((int, char **));

static int
gld${EMULATION_NAME}_parse_args (argc, argv)
     int argc;
     char ** argv;
{
  int longind;
  int optc;
  static int prevoptind = -1;
  int prevopterr = opterr;
  int wanterror;

  if (prevoptind != optind)
    opterr = 0;

  wanterror = opterr;
  prevoptind = optind;

  optc = getopt_long_only (argc, argv,
			   "-${PARSE_AND_LIST_SHORTOPTS}z:", longopts,
			   &longind);
  opterr = prevopterr;
d1578 4
d1585 1
a1585 4
      if (wanterror)
	xexit (1);
      optind = prevoptind;
      return 0;
d1658 1
a1658 1
  return 1;
a1661 1
fi
a1714 1
if test x"$LDEMUL_PARSE_ARGS" != xgld"$EMULATION_NAME"_parse_args; then
d1716 2
a1717 1
#define gld${EMULATION_NAME}_parse_args   NULL
a1718 1
fi
d1747 3
a1749 1
  ${LDEMUL_PARSE_ARGS-gld${EMULATION_NAME}_parse_args},
@


1.91
log
@Disable region size checking whilst relaxing sections.
@
text
@d464 1
a464 1
  len = len + colons * strlen (ld_sysroot);
@


1.90
log
@	* emultempl/elf32.em: Move gld${EMULATION_NAME}_add_sysroot
	outside of GNU/Linux conditional.
@
text
@d1430 1
a1430 1
			  &stat_ptr->head, 0, (bfd_vma) 0, NULL);
@


1.89
log
@	* emultempl/elf32.em (gld${EMULATION_NAME}_add_sysroot): Do not
	skip ':'.
@
text
@d443 1
a443 3
  case ${target} in
    *-*-linux-gnu*)
      cat >>e${EMULATION_NAME}.c <<EOF
d483 4
@


1.88
log
@	* Makefile.am (eelf32iq10.c): Fix tab/whitespace mixup.

	* Makefile.am (ldmain.o): Add @@TARGET_SYSTEM_ROOT_DEFINE@@.
	(GENSCRIPTS): Add @@use_sysroot@@.
	* Makefile.in: Regenerated.
	* configure.host: Move setting of NATIVE_LIB_DIRS to...
	* configure.tgt: ... here.  Use ${target} instead of ${host}
	for NATIVE_LIB_DIRS.
	* configure.in: Add --with-sysroot.
	* configure: Regenerated.
	* genscripts.sh: Accept use_sysroot option.  Set new variables
	NATIVE and USE_LIBPATH.  Prepend "=" to directory names if
	$use_sysroot.  Don't search $tool_lib if $use_sysroot.
	* ldfile.c (ldfile_add_library_path): Handle leading '='.
	* ldmain.c (TARGET_SYSTEM_ROOT): Define if not defined.
	(ld_sysroot): New variable.
	(main): Initialize ld_sysroot.
	* ldmain.h (ld_sysroot): New extern.
	* emultempl/elf32.em: Use NATIVE and USE_LIBPATH instead of
	searching $EMULATION_LIBPATH.
	(gld${EMULATION_NAME}_add_sysroot): New function.
	(gld${EMULATION_NAME}_check_ld_so_conf): Use it.  Honor ld_sysroot.
	(gld${EMULATION_NAME}_after_open): Likewise.  Only search
	environment variables if $NATIVE.
	* ld.texinfo (Options): Mention "=" prefix in the description of -L.
	* NEWS: Mention --with-sysroot.

	* emulparams/elf32bmipn32-defs.sh: Set NATIVE and LIBPATH_SUFFIX
	instead of setting LIB_PATH.
	* emulparams/elf32ppc.sh: Likewise.
	* emulparams/elf64_s390.sh: Likewise.
	* emulparams/elf64_sparc.sh: Likewise.
	* emulparams/elf64ppc.sh: Likewise.
	* emulparams/elf_x86_64.sh: Likewise.

	* emulparams/elf64_aix.sh: Add "=" prefixes to LIB_PATH.
	* emulparams/elf64hppa.sh: Add "=" prefixes to LIB_PATH.
@
text
@d474 1
a476 1
	i++;
@


1.87
log
@	* emultempl/elf32.em (struct orphan_save): Add os_tail field.
	(gld${EMULATION_NAME}_place_orphan): Re-order output_section_statement
	list too.
@
text
@d16 1
a16 1
   2002 Free Software Foundation, Inc.
d442 42
a483 6
if [ "x${host}" = "x${target}" ] ; then
  case " ${EMULATION_LIBPATH} " in
  *" ${EMULATION_NAME} "*)
    case ${target} in
      *-*-linux-gnu*)
	cat >>e${EMULATION_NAME}.c <<EOF
d503 1
d505 3
a507 1
      f = fopen ("/etc/ld.so.conf", FOPEN_RT);
d557 7
d577 2
a578 3
	# Linux
	;;
    esac
d692 1
a692 3
if [ "x${host}" = "x${target}" ] ; then
  case " ${EMULATION_LIBPATH} " in
  *" ${EMULATION_NAME} "*)
a697 2
  ;;
  esac
d705 1
a705 3
if [ "x${host}" = "x${target}" ] ; then
  case " ${EMULATION_LIBPATH} " in
  *" ${EMULATION_NAME} "*)
d710 4
d725 4
a728 1

d733 1
d735 1
a735 1
		       && gld${EMULATION_NAME}_search_needed (rp->name,
d738 1
a743 2
  ;;
  esac
d762 4
a765 6
if [ "x${host}" = "x${target}" ] ; then
  case " ${EMULATION_LIBPATH} " in
  *" ${EMULATION_NAME} "*)
    case ${target} in
      *-*-linux-gnu*)
	cat >>e${EMULATION_NAME}.c <<EOF
d769 2
a770 4
	# Linux
        ;;
    esac
  ;;
@


1.86
log
@	* emultempl/elf32.em (gld${EMULATION_NAME}_place_orphan): Set
	load_base for orphans that follow a section with load_base set.
@
text
@d1074 1
d1097 1
d1247 1
d1327 2
d1334 2
d1351 15
@


1.85
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d1096 1
d1231 1
d1234 10
a1243 2
  else
    address = NULL;
d1249 1
a1249 1
					    (etree_type *) NULL);
@


1.84
log
@	* emultempl/aix.em: Use include <> for generated headers.
	* emultempl/beos.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/pe.em: Likewise.
	* ldctor.c: Likewise.
	* ldexp.c: Likewise.
	* ldfile.c: Likewise.
	* ldlang.c: Likewise.
	* ldlex.c: Likewise.
	* ldlex.l: Likewise.
	* ldmain.c: Likewise.
	* ldmisc.c: Likewise.
	* ldwrite.c: Likewise.
	* lexsup.c: Likewise.
	* mri.c: Likewise.
	* pe-dll.c: Likewise.
@
text
@d61 1
a61 1
static boolean gld${EMULATION_NAME}_try_needed
d63 1
a63 1
static boolean gld${EMULATION_NAME}_search_needed
d75 1
a75 1
static boolean gld${EMULATION_NAME}_open_dynamic_archive
d81 1
a81 1
static boolean gld${EMULATION_NAME}_place_orphan
d117 2
a118 2
  config.dynamic_link = ${DYNAMIC_LINK-true};
  config.has_shared = `if test -n "$GENERATE_SHLIB_SCRIPT" ; then echo true ; else echo false ; fi`;
d131 1
a131 1
static boolean global_found;
d133 1
a133 1
static boolean global_vercheck_failed;
d196 1
a196 1
	  global_vercheck_failed = true;
d228 1
a228 1
      global_found = true;
d262 1
a262 1
static boolean
d272 1
a272 1
    return false;
d276 1
a276 1
      return false;
d281 1
a281 1
      return false;
d288 1
a288 1
      return false;
d306 1
a306 1
	  global_vercheck_failed = false;
d311 1
a311 1
	      /* Return false to force the caller to move on to try
d313 1
a313 1
	      return false;
d336 1
a336 1
		return false;
d366 1
a366 1
  global_found = false;
d370 1
a370 1
      /* Return true to indicate that we found the file, even though
d372 1
a372 1
      return true;
d388 1
a388 1
  return true;
d394 1
a394 1
static boolean
d407 1
a407 1
    return false;
d429 1
a429 1
	return true;
d438 1
a438 1
  return false;
d453 1
a453 1
static boolean gld${EMULATION_NAME}_check_ld_so_conf
d456 1
a456 1
static boolean
d461 1
a461 1
  static boolean initialized;
d521 1
a521 1
      initialized = true;
d525 1
a525 1
    return false;
d553 1
a553 1
	  global_found = true;
d563 1
a563 1
	      global_found = true;
d577 1
a577 1
	  global_found = true;
d623 1
a623 1
      global_found = false;
d759 1
a759 1
				false, false, false);
d777 1
a777 1
		  exp->type.node_class == etree_provide ? true : false)))
d880 1
a880 1
	boolean ret;
d919 1
a919 1
static boolean
d929 1
a929 1
    return false;
d957 1
a957 1
      return false;
d987 1
a987 1
  return true;
d1076 1
a1076 1
static boolean
d1124 1
a1124 1
	  return true;
d1139 1
a1139 1
      return true;
d1154 1
a1154 1
      return true;
d1337 1
a1337 1
  return true;
d1386 1
a1386 1
  if (link_info.relocateable == true && config.build_constructors == true)
d1389 5
a1393 5
sed $sc ldscripts/${EMULATION_NAME}.xu                     >> e${EMULATION_NAME}.c
echo '  ; else if (link_info.relocateable == true) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xr                     >> e${EMULATION_NAME}.c
echo '  ; else if (!config.text_read_only) return'         >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xbn                    >> e${EMULATION_NAME}.c
d1395 2
a1396 2
echo '  ; else if (!config.magic_demand_paged) return'     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xn                     >> e${EMULATION_NAME}.c
d1401 1
a1401 1
sed $sc ldscripts/${EMULATION_NAME}.xsc                    >> e${EMULATION_NAME}.c
d1403 2
a1404 2
echo '  ; else if (link_info.shared) return'		   >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xs                     >> e${EMULATION_NAME}.c
d1407 2
a1408 2
echo '  ; else if (link_info.combreloc) return'            >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xc                     >> e${EMULATION_NAME}.c
d1410 3
a1412 3
echo '  ; else return'                                     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.x                      >> e${EMULATION_NAME}.c
echo '; }'                                                 >> e${EMULATION_NAME}.c
d1421 1
a1421 1
  if (link_info.relocateable == true && config.build_constructors == true)
d1423 1
a1423 1
  else if (link_info.relocateable == true)
d1524 1
a1524 1
      link_info.new_dtags = false;
d1528 1
a1528 1
      link_info.new_dtags = true;
d1532 1
a1532 1
      link_info.eh_frame_hdr = true;
d1538 1
a1538 1
      link_info.no_undefined = true;
d1567 1
a1567 1
	link_info.no_undefined = true;
d1569 1
a1569 1
	link_info.allow_multiple_definition = true;
d1571 1
a1571 1
	link_info.combreloc = true;
d1573 1
a1573 1
	link_info.combreloc = false;
d1575 1
a1575 1
        link_info.nocopyreloc = true;
@


1.83
log
@	* emultempl/elf32.em (place_orphan): Don't put non-allocated .rel*
	sections into .rel{,a}.dyn.
@
text
@d52 1
a52 1
#include "ldgram.h"
@


1.82
log
@	* emultempl/elf32.em (output_rel_find): Prefer .rel script sections
	when orphan is .rel, .rela when orphan is .rela.
	(gld${EMULATION_NAME}_place_orphan): Handle combreloc .rel* case
	first.  Remove outsecname var.
@
text
@d1101 1
@


1.81
log
@	* emultempl/elf32.em (output_rel_find): Always place orphan loadable
	reloc sections just before .rel.plt/.rela.plt.
	(gld${EMULATION_NAME}_place_orphan <.rel>): Remove combreloc code.
	Only put loadable reloc sections in hold_rel.
@
text
@d78 1
a78 1
  PARAMS ((void));
d999 2
a1000 1
output_rel_find ()
d1007 1
d1017 1
a1017 1
	  int rela = lookup->name[4] == 'a';
d1019 1
a1019 1
	  if (strcmp (".plt", lookup->name + 4 + rela) == 0
d1023 3
a1025 1
	  last_rel = lookup;
a1029 1
      last = lookup;
a1093 1
  const char *outsecname;
d1096 1
d1099 10
d1110 1
a1110 1
  if (! config.unique_orphan_sections && ! unique_section_p (secname))
d1175 1
a1175 1
	       || (hold_rel.os = output_rel_find ()) != NULL))
d1189 1
a1189 2
  outsecname = secname;
  if (bfd_get_section_by_name (output_bfd, outsecname) != NULL)
d1191 2
a1192 4
      outsecname = bfd_get_unique_section_name (output_bfd,
						outsecname,
						&count);
      if (outsecname == NULL)
d1213 1
a1213 1
      for (ps = outsecname; *ps != '\0'; ps++)
d1221 2
a1222 2
	  symname = (char *) xmalloc (ps - outsecname + sizeof "__start_");
	  sprintf (symname, "__start_%s", outsecname);
d1234 1
a1234 1
  os = lang_enter_output_section_statement (outsecname, address, 0,
d1255 2
a1256 2
      symname = (char *) xmalloc (ps - outsecname + sizeof "__stop_");
      sprintf (symname, "__stop_%s", outsecname);
@


1.80
log
@	* emultempl/elf32.em (gld${EMULATION_NAME}_place_orphan): Don't
	bomb on /DISCARD/ input section.
	* emultempl/pe.em (gld_${EMULATION_NAME}_place_orphan): Likewise.
	* emultempl/mmo.em (mmo_place_orphan): Likewise.
@
text
@d1003 3
d1007 1
a1007 3
  for (u = lang_output_section_statement.head;
       u != (lang_statement_union_type *) NULL;
       u = lookup->next)
d1010 1
a1010 3
      if (strncmp (".rel", lookup->name, 4) == 0
	  && lookup->bfd_section != NULL
	  && (lookup->bfd_section->flags & SEC_ALLOC) != 0)
d1012 13
a1024 1
	  return lookup;
d1026 1
d1028 8
a1035 1
  return (lang_output_section_statement_type *) NULL;
d1160 1
d1163 1
a1163 19
    {
      if (! link_info.relocateable && link_info.combreloc)
	{
	  if (strncmp (secname, ".rela", 5) == 0)
	    os = lang_output_section_find (".rela.dyn");
	  else
	    os = lang_output_section_find (".rel.dyn");

	  if (os != NULL
	      && os->bfd_section != NULL
	      && ((s->flags ^ os->bfd_section->flags)
		  & (SEC_LOAD | SEC_ALLOC)) == 0)
	    {
	      lang_add_section (&os->children, s, os, file);
	      return true;
	    }
	}
      place = &hold_rel;
    }
@


1.79
log
@Fix ld segfault for some elf targets.  Fix default layout for d10v.
@
text
@d1252 1
a1252 1
  if (place != NULL)
@


1.79.2.1
log
@	* emultempl/elf32.em (gld${EMULATION_NAME}_place_orphan): Don't
	bomb on /DISCARD/ input section.
	* emultempl/pe.em (gld_${EMULATION_NAME}_place_orphan): Likewise.
	* emultempl/mmo.em (mmo_place_orphan): Likewise.
@
text
@d1252 1
a1252 1
  if (place != NULL && os->bfd_section != NULL)
@


1.79.2.2
log
@Merge from mainline.
@
text
@d78 1
a78 1
  PARAMS ((asection *));
d999 1
a999 2
output_rel_find (sec)
     asection *sec;
a1002 4
  lang_output_section_statement_type *last = NULL;
  lang_output_section_statement_type *last_rel = NULL;
  lang_output_section_statement_type *last_rel_alloc = NULL;
  int rela = sec->name[4] == 'a';
d1004 3
a1006 1
  for (u = lang_output_section_statement.head; u; u = lookup->next)
d1009 3
a1011 1
      if (strncmp (".rel", lookup->name, 4) == 0)
d1013 1
a1013 15
	  /* Don't place after .rel.plt as doing so results in wrong
	     dynamic tags.  Also, place allocated reloc sections before
	     non-allocated.  */
	  int lookrela = lookup->name[4] == 'a';

	  if (strcmp (".plt", lookup->name + 4 + lookrela) == 0
	      || (lookup->bfd_section != NULL
		  && (lookup->bfd_section->flags & SEC_ALLOC) == 0))
	    break;
	  last = lookup;
	  if (rela == lookrela)
	    last_rel = lookup;
	  if (lookup->bfd_section != NULL
	      && (lookup->bfd_section->flags & SEC_ALLOC) != 0)
	    last_rel_alloc = lookup;
d1016 1
a1016 8

  if (last_rel_alloc)
    return last_rel_alloc;

  if (last_rel)
    return last_rel;

  return last;
d1072 1
a1074 1
  int isdyn = 0;
a1076 11
  if (! link_info.relocateable
      && link_info.combreloc
      && (s->flags & SEC_ALLOC)
      && strncmp (secname, ".rel", 4) == 0)
    {
      if (secname[4] == 'a')
	secname = ".rela.dyn";
      else
	secname = ".rel.dyn";
      isdyn = 1;
    }
d1078 1
a1078 1
  if (isdyn || (!config.unique_orphan_sections && !unique_section_p (secname)))
a1140 1
	   && (s->flags & SEC_LOAD) != 0
d1142 20
a1161 2
	       || (hold_rel.os = output_rel_find (s)) != NULL))
    place = &hold_rel;
d1174 2
a1175 1
  if (bfd_get_section_by_name (output_bfd, secname) != NULL)
d1177 4
a1180 2
      secname = bfd_get_unique_section_name (output_bfd, secname, &count);
      if (secname == NULL)
d1201 1
a1201 1
      for (ps = secname; *ps != '\0'; ps++)
d1209 2
a1210 2
	  symname = (char *) xmalloc (ps - secname + sizeof "__start_");
	  sprintf (symname, "__start_%s", secname);
d1222 1
a1222 1
  os = lang_enter_output_section_statement (secname, address, 0,
d1243 2
a1244 2
      symname = (char *) xmalloc (ps - secname + sizeof "__stop_");
      sprintf (symname, "__stop_%s", secname);
@


1.79.2.3
log
@        * emultempl/aix.em: Use include <> for generated headers.
        * emultempl/beos.em: Likewise.
        * emultempl/elf32.em: Likewise.
        * emultempl/pe.em: Likewise.
        * ldctor.c: Likewise.
        * ldexp.c: Likewise.
        * ldfile.c: Likewise.
        * ldlang.c: Likewise.
        * ldlex.c: Likewise.
        * ldlex.l: Likewise.
        * ldmain.c: Likewise.
        * ldmisc.c: Likewise.
        * ldwrite.c: Likewise.
        * lexsup.c: Likewise.
        * mri.c: Likewise.
        * pe-dll.c: Likewise.
@
text
@d52 1
a52 1
#include <ldgram.h>
@


1.79.2.4
log
@Merge fixes from trunk.
@
text
@a1073 1
  lang_statement_union_type **os_tail;
a1095 2
  lang_statement_union_type **os_tail;
  etree_type *load_base;
a1229 1
  address = NULL;
d1232 2
a1234 11
  load_base = NULL;
  if (place != NULL && place->os->load_base != NULL)
    {
      etree_type *lma_from_vma;
      lma_from_vma = exp_binop ('-', place->os->load_base,
				exp_nameop (ADDR, place->os->name));
      load_base = exp_binop ('+', lma_from_vma,
			     exp_nameop (ADDR, secname));
    }

  os_tail = lang_output_section_statement.tail;
d1239 1
a1239 1
					    load_base);
a1313 2
	  lang_statement_union_type *newly_added_os;

a1318 2

	      place->os_tail = &place->os->next;
a1333 15

	  /* Do the same for the list of output statements.  */
	  newly_added_os = *os_tail;
	  *os_tail = NULL;
	  newly_added_os->output_section_statement.next = *place->os_tail;
	  *place->os_tail = newly_added_os;
	  place->os_tail = &newly_added_os->output_section_statement.next;

	  /* Fixing the global list pointer here is a little different.
	     We added to the list in lang_enter_output_section_statement,
	     trimmed off the new output_section_statment above when
	     assigning *os_tail = NULL, but possibly added it back in
	     the same place when assigning *place->os_tail.  */
	  if (*os_tail == NULL)
	    lang_output_section_statement.tail = os_tail;
@


1.78
log
@2002-06-12  H.J. Lu <hjl@@gnu.org>

	* emultempl/elf32.em (gld${EMULATION_NAME}_try_needed): Return
	false if xvec doesn't match.
@
text
@d1386 1
d1389 1
d1393 1
d1396 1
@


1.77
log
@	* emultempl/elf32.em (gld${EMULATION_NAME}_place_orphan): Place
	SEC_EXCLUDE sections when doing a relocatable link.
@
text
@d284 7
@


1.76
log
@	* ldlang.c (lang_size_sections_1): Move check for conflicting load
	addresses and regions from here...
	(lang_get_regions): ...to this new function.
	(lang_leave_output_section_statement): Use lang_get_regions.
	(lang_leave_overlay): Likewise.
	* mri.c (mri_draw_tree): Pass null as last argument to
	lang_leave_output_section_statement.
	* emultempl/elf32.em (gld*_place_orphan): Likewise.
	* emultempl/mmo.em (mmo_place_orphan): Likewise.
	* emultempl/pe.em (gld*_place_orphan): Likewise.
@
text
@d1110 1
a1110 1
  if (s->flags & SEC_EXCLUDE)
@


1.75
log
@	* ldemul.c (ldemul_new_vers_pattern): New function.
	* ldemul.h (ldemul_new_vers_pattern): Declare.
	(struct ld_emulation_xfer_struct): Add new_vers_pattern.
	* ldlang.c (lang_new_vers_pattern): Call ldemul_new_vers_pattern.
	* emultempl/ppc64elf.em (dotsyms): New static var.
	(gld${EMULATION_NAME}_new_vers_pattern): New function.
	(LDEMUL_NEW_VERS_PATTERN): Define.
	(PARSE_AND_LIST_PROLOGUE): Add OPTION_DOTSYMS, OPTION_NO_DOTSYMS.
	(PARSE_AND_LIST_LONGOPTS): Likewise.
	(PARSE_AND_LIST_ARGS_CASES): Handle them.
	* emultempl/aix.em (ld_${EMULATION_NAME}_emulation): Update
	initialiser.
	* emultempl/armcoff.em: Likewise.
	* emultempl/armelf_oabi.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/generic.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/gld960c.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68kcoff.em: Likewise.
	* emultempl/mipsecoff.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/ticoff.em: Likewise.
	* emultempl/vanilla.em: Likewise.
@
text
@d1225 1
a1225 1
     (struct lang_output_section_phdr_list *) NULL, "*default*");
@


1.74
log
@2002-05-21  H.J. Lu  (hjl@@gnu.org)

	* emultempl/elf32.em (gld${EMULATION_NAME}_parse_args): Handle
	"-z muldefs".
	(gld${EMULATION_NAME}_list_options): Add "-z muldefs".

	* ld.texinfo: Updated for --allow-multiple-definition and
	"-z muldefs".

	* ldmain.c (main): Initialize the allow_multiple_definition
	field to false.

	* lexsup.c (OPTION_ALLOW_MULTIPLE_DEFINITION): New.
	(ld_options): Add --allow-multiple-definition.
	(parse_args): Support OPTION_ALLOW_MULTIPLE_DEFINITION.
@
text
@d1662 1
@


1.73
log
@2002-03-18  David O'Brien  <obrien@@FreeBSD.org>
	* emultempl/elf32.em: Use lbasename vs. basename to fix problem where
	the contents of the buffer returned from basename function will are
	getting overwritten while still being used.

Approved by:  Alan Modra <amodra@@bigpond.net.au>
              Message-ID: <20020318032031.GD1089@@bubble.sa.bigpond.net.au>
@
text
@d1544 2
d1594 1
@


1.72
log
@	Support arbitrary length fill patterns.
	* ldexp.h (etree_value_type): Add "str" field.
	(union etree_union): Add "str" to "value" struct.
	(exp_bigintop): Declare.
	(exp_get_fill): Declare.
	* ldexp.c: Include "safe-ctype.h".
	(exp_intop): Set value.str to NULL.
	(exp_bigintop): New function.
	(new_rel): Pass in "str", and set new.str from it.
	(new_rel_from_section): Set new.str to NULL.
	(fold_name): Adjust calls to new_rel.
	(exp_fold_tree): Likewise.
	(exp_get_fill): New function.
	* ldgram.y (struct big_int bigint, fill_type *fill): New.
	(INT): Returns a "bigint".  Adjust all code handling INTs.
	(fill_opt): Returns a "fill".
	(fill_exp): Split out of fill_opt, use for FILL.
	* ldlang.h (struct _fill_type): New.
	(fill_type): Move typedef to ldexp.h.
	(lang_output_section_statement_type): "fill" is now a pointer.
	(lang_fill_statement_type): Likewise.
	(lang_padding_statement_type): Likewise.
	(lang_add_fill): Now takes a "fill_type *" param.
	(lang_leave_output_section_statement): Likewise.
	(lang_do_assignments): Likewise.
	(lang_size_sections): Likewise.
	(lang_leave_overlay_section): Likewise.
	(lang_leave_overlay): Likewise.
	* ldlang.c: Include ldgram.h after ldexp.h.
	(lang_output_section_statement_lookup): Adjust for fill_type change.
	(print_fill_statement): Likewise.
	(print_padding_statement): Likewise.
	(insert_pad): Now takes a "fill_type *" arg.
	(size_input_section): Likewise.
	(lang_size_sections_1): Likewise.
	(lang_size_sections): Likewise.
	(lang_do_assignments): Likewise.
	(lang_add_fill): Likewise.
	(lang_leave_output_section_statement): Likewise.
	(lang_leave_overlay_section): Likewise.
	(lang_leave_overlay): Likewise.
	Adjust all callers of the above function.
	* ldlex.l: Include ldgram.h after ldexp.h.  Allow hex numbers
	starting with "0X" as well as "0x".  Return bigint.str for hex
	numbers starting with "0x" or "0X", zero bigint.str otherwise.
	Always use base 16 for numbers starting with "$".
	* ldmain.c: Include ldgram.h after ldexp.h.
	* ldwrite.c (build_link_order): Use bfd_data_link_order in place
	of bfd_fill_link_order.
	* pe-dll.c: Adjust lang_do_assignments calls.
	* emultempl/elf32.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/beos.em: Include ldgram.h after ldexp.h, adjust
	lang_add_assignment call.
	* emultempl/pe.em: Likewise.
@
text
@d168 1
a168 1
    soname = basename (bfd_get_filename (s->the_bfd));
d250 1
a250 1
    soname = basename (s->filename);
d354 1
a354 1
  soname = basename (abfd->filename);
a371 3
  /* Previos basename call was clobbered in lang_for_each_input_file.  */
  soname = basename (abfd->filename);

d976 1
a976 1
      filename = xstrdup (basename (entry->filename));
@


1.71
log
@	* ldlang.c (lang_reset_memory_regions): Rename from
	reset_memory_regions.  Change all callers.  Make public.
	* ldlang.h (lang_reset_memory_regions): Prototype.
	* emultempl/elf32.em (gld${EMULATION_NAME}_finish): Call
	lang_reset_memory_regions before lang_size_sections.
@
text
@d1344 1
a1344 1
			   (fill_type) 0, (bfd_vma) 0);
@


1.71.2.1
log
@2002-03-18  David O'Brien  <obrien@@FreeBSD.org>
	* emultempl/elf32.em: Use lbasename vs. basename to fix problem where
	the contents of the buffer returned from basename function will are
	getting overwritten while still being used.

Approved by:  Alan Modra <amodra@@bigpond.net.au>
              Message-ID: <20020318032031.GD1089@@bubble.sa.bigpond.net.au>
@
text
@d168 1
a168 1
    soname = lbasename (bfd_get_filename (s->the_bfd));
d250 1
a250 1
    soname = lbasename (s->filename);
d354 1
a354 1
  soname = lbasename (abfd->filename);
d372 3
d979 1
a979 1
      filename = lbasename (entry->filename);
@


1.70
log
@	* emultempl/elf32.em (gld${EMULATION_NAME}_place_orphan): Make use
	of bfd_section_list_remove and bfd_section_list_insert macros.
	* emultempl/pe.em (gld_${EMULATION_NAME}_place_orphan): Likewise.
	* emultempl/mmo.em (mmo_place_orphan): Likewise.
@
text
@d15 2
a16 2
   Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
d1333 2
@


1.69
log
@hash bfd sections for fast lookup and create.
bfd/ChangeLog
	* bfd.c (struct _bfd): Add section_htab, section_tail.
	* libbfd-in.h (_bfd_delete_bfd): Declare.
	(bfd_section_hash_newfunc): Declare.
	* opncls.c (_bfd_new_bfd): Free memory on failure.  Init
	section_htab and section_tail.
	(_bfd_delete_bfd): New function.
	(bfd_openr): Use it.
	(bfd_fdopenr): Likewise.
	(bfd_openstreamr): Likewise.
	(bfd_openw): Likewise.
	(bfd_close): Likewise.
	(bfd_close_all_done): Likewise.
	(bfd_release): Comment.
	* section.c (struct section_hash_entry): New.
	(bfd_section_hash_newfunc): New function.
	(section_hash_lookup): Define.
	(bfd_section_init): New function, split out from
	bfd_make_section_anyway.
	(bfd_get_section_by_name): Lookup via hash table.
	(bfd_get_unique_section_name): Likewise.
	(bfd_make_section_old_way): Rewrite to use hash table.
	(bfd_make_section_anyway): Likewise.
	(bfd_make_section): Likewise.  Return NULL for attempts to make
	BFD_{ABS,COM,UND,IND}_SECTION_NAME.
	(_bfd_strip_section_from_output): Adjust section_tail if needed.
	* configure.in: Bump bfd version.
	* configure: Regenerate.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

ld/ChangeLog
	* emultempl/elf32.em (gld${EMULATION_NAME}_place_orphan): Adjust
	section_tail when fiddling with section list.
	(gld${EMULATION_NAME}_list_options): Ensure sentences aren't
	broken into separate strings to make translation easier.
	* emultempl/mmo.em (mmo_place_orphan): Adjust section_tail when
	fiddling with section list.
	* emultempl/pe.em (gld_${EMULATION_NAME}_place_orphan): Likewise.
@
text
@d1273 1
a1273 1
	  /*  Unlink the section.  */
d1276 1
a1276 3
	  *pps = snew->next;
	  if (snew->next == NULL)
	    snew->owner->section_tail = pps;
d1279 1
a1279 4
	  snew->next = *place->section;
	  *place->section = snew;
	  if (snew->next == NULL)
	    snew->owner->section_tail = &snew->next;
@


1.68
log
@	* elf-bfd.h (enum elf_link_info_type): New.
	(struct bfd_elf_section_data): Remove stab_info and merge_info
	fields, add sec_info and sec_info_type.
	(struct elf_obj_tdata): Add eh_frame_hdr field.
	(_bfd_elf_discard_section_eh_frame): New prototype.
	(_bfd_elf_discard_section_eh_frame_hdr): Likewise.
	(_bfd_elf_eh_frame_section_offset): Likewise.
	(_bfd_elf_write_section_eh_frame): Likewise.
	(_bfd_elf_write_section_eh_frame_hdr): Likewise.
	* Makefile.am (BFD32_BACKENDS): Add elf-eh-frame.lo.
	(BFD32_BACKENDS_CFILES): Add elf-eh-frame.c.
	(elf-eh-frame.lo): New.
	* Makefile.in: Rebuilt.
	* configure.in (elf): Add elf-eh-frame.lo.
	* configure: Rebuilt.
	* elf.c (_bfd_elf_print_private_bfd_data): Support PT_GNU_EH_FRAME.
	(map_sections_to_segments): Create PT_GNU_EH_FRAME if requested.
	(get_program_header_size): Take into account PT_GNU_EH_FRAME
	segment.
	(_bfd_elf_rela_local_sym): Use sec_info_type and sec_info.
	(_bfd_elf_rel_local_sym): Likewise.
	(_bfd_elf_section_offset): Likewise.  Call
	_bfd_elf_eh_frame_section_offset too.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Use sec_info_type and
	sec_info.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf-eh-frame.c: New file.
	* elflink.h (elf_link_add_object_symbols): Don't optimize SHF_MERGE
	.stab sections.  Set sec_info_type, use sec_info instead
	of merge_info and stab_info.
	(elf_link_create_dynamic_sections): Create .eh_frame_hdr section
	if --eh-frame-hdr.
	(elf_bfd_final_link): Write .eh_frame_hdr section.
	(elf_link_sec_merge_syms): Use sec_info_type and sec_info.
	(elf_link_input_bfd): Likewise.
	Call _bfd_elf_write_section_eh_frame to write .eh_frame sections.
	(elf_bfd_discard_info): Add output_bfd argument.
	Call _bfd_elf_discard_section_eh_frame and
	_bfd_elf_discard_section_eh_frame_hdr.
	(elf_section_ignore_discarded_relocs): Use sec_info_type, not section
	names.
	* bfd-in.h (bfd_elf32_discard_info, bfd_elf64_discard_info): Adjust
	prototypes.
	* bfd-in2.h (bfd_elf32_discard_info, bfd_elf64_discard_info): Likewise.

	* elf/common.h (PT_GNU_EH_FRAME): Define.
	* bfdlink.h (struct bfd_link_info): Add eh_frame_hdr field.

	* emultempl/elf32.em (finish): Supply output_bfd
	to bfd_elf*_discard_info.
	(OPTION_EH_FRAME_HDR): Define.
	(longopts): Add --eh-frame-hdr.
	(parse_args): Handle it.
	(list_options): Add --eh-frame-hdr to help.
	* emultempl/hppaelf.em (finish): Supply output_bfd
	to bfd_elf*_discard_info.
	* scripttempl/elf.sc (.eh_frame_hdr): Add.

	* readelf.c (get_segment_type): Support PT_GNU_EH_FRAME.
@
text
@d1277 2
d1283 2
d1605 1
a1605 2
  fprintf (file, _("  -z origin\t\tMark object requiring immediate \$ORIGIN processing\n"));
  fprintf (file, _("\t\t\t  at runtime\n"));
@


1.67
log
@	* emultempl/elf32.em (gld${EMULATION_NAME}_finish): Use NULL instead
        of false when calling lang_size_sections.
	(hppaelf_layout_sections_again): Likewise.
@
text
@d1332 1
a1332 1
  if (bfd_elf${ELFSIZE}_discard_info (&link_info))
d1434 1
d1448 1
d1509 4
d1588 1
@


1.66
log
@	* emultempl/elf32.em (gld${EMULATION_NAME}_finish): Only emit this
	function when LDEMUL_FINISH isn't set to the same name.  Don't
	call ${LDEMUL_FINISH}.
	(ld_${EMULATION_NAME}_emulation): Call $LDEMUL_FINISH if defined.
	* emultempl/armelf.em (arm_elf_finish): Call
	gld${EMULATION_NAME}_finish.
	* emultempl/hppaelf.em (hppaelf_finish): Rename to
	gld${EMULATION_NAME}_finish.  Call bfd_elf32_discard_info and
	hppaelf_layout_sections_again if necessary.
	(need_laying_out): New var.
	(hppaelf_layaout_sections_again): Rename to
	hppaelf_layout_sections_again.  Clear need_laying_out.
	(PARSE_AND_LIST_OPTIONS): Format text.
@
text
@d1336 1
a1336 1
			  &stat_ptr->head, 0, (bfd_vma) 0, false);
@


1.65
log
@2001-11-11  Daniel Jacobowitz  <drow@@mvista.com>

	* bfd-in.h (bfd_elf32_discard_info): Add prototype.
	(bfd_elf64_discard_info): Likewise.
	* bfd-in2.h: Regenerate.
	* elf-bfd.h (struct elf_reloc_cookie): New.
	(struct elf_backend_data): Add elf_backend_discard_info,
	elf_backend_ignore_discarded_relocs, and elf_backend_write_section.
	(_bfd_elf32_reloc_symbol_deleted_p): Add prototype.
	(_bfd_elf64_reloc_symbol_deleted_p): Likewise.
	* elf32-mips.c (_bfd_elf32_mips_discard_info): New.
	(_bfd_elf32_mips_ignore_discarded_relocs): New.
	(_bfd_elf32_mips_write_section): New.
	(elf_backend_discard_info): Define.
	(elf_backend_ignore_discarded_relocs): Define.
	(elf_backend_write_section): Define.
	* elfcode.h (elf_bfd_discard_info): Define.
	(elf_reloc_symbol_deleted_p): Define.
	* elflink.h (elf_link_input_bfd): Check
	elf_section_ignore_discarded_relocs.  Call
	bed->elf_backend_write_section if available.
	(elf_reloc_symbol_deleted_p): New.
	(elf_bfd_discard_info): New.
	(elf_section_ignore_discarded_relocs): New.
	* elfxx-target.h (elf_backend_discard_info): Define.
	(elf_backend_ignore_discarded_relocs): Define.
	(elf_backend_write_section): Define.
	(elfNN_bed): Add elf_backend_discard_info,
	elf_backend_ignore_discarded_relocs, and
	elf_backend_write_section.
	* libbfd-in.h (_bfd_discard_section_stabs): Add prototype.
	* libbfd.h: Regenerate.
	* stabs.c (_bfd_discard_section_stabs): New.

2001-11-11  Daniel Jacobowitz  <drow@@mvista.com>

	* emultempl/elf32.em (gld${EMULATION_NAME}_finish): New.
	(struct ld_emulation_xfer_struct): Use it.
@
text
@d1323 5
a1331 2
  ${LDEMUL_FINISH+${LDEMUL_FINISH} ();}

d1645 1
a1645 1
  gld${EMULATION_NAME}_finish,
@


1.64
log
@	* emultempl/elf32.em (gld*_list_options): Remove extra '\t' from
	-z nocopyreloc and -z nocombreloc usage strings.
@
text
@d83 2
d1324 19
d1642 1
a1642 1
  ${LDEMUL_FINISH-NULL},
@


1.63
log
@Include -z nocopyreloc in usage
@
text
@d1563 2
a1564 2
  fprintf (file, _("  -z nocombreloc\t\tDon't merge dynamic relocs into one section\n"));
  fprintf (file, _("  -z nocopyreloc\t\tDon't create copy relocs\n"));
@


1.62
log
@2001-10-10  Chris Demetriou  <cgd@@broadcom.com>

        * emultempl/elf32.em: Fix shell 'if' usage for portability.
@
text
@d1564 1
@


1.61
log
@	* doc/as.texinfo: Document M and S ELF section flags.

	* emultempl/elf32.em (gld_*_list_options): Include -z combreloc and
	-z nocombreloc in usage.
@
text
@d1352 1
a1352 1
if ! cmp -s ldscripts/${EMULATION_NAME}.x ldscripts/${EMULATION_NAME}.xn; then
@


1.60
log
@Add support for -z nocopyreloc.
@
text
@d1558 1
d1563 1
@


1.59
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d1520 2
@


1.58
log
@	* elf-bfd.h (enum elf_reloc_type_class): New.
	(struct elf_backend_data): Add elf_backend_reloc_type_class.
	(_bfd_elf_reloc_type_class): New.
	* elfxx-target.h (elf_backend_reloc_type_class): Define.
	(elfNN_bed): Add elf_backend_reloc_type_class.
	* elf.c (_bfd_elf_reloc_type_class): New.
	* elf32-i386.c (elf_i386_check_relocs): Set DF_TEXTREL if the reloc
	is against read-only section.
	(elf_i386_size_dynamic_sections): Use DF_TEXTREL flag instead of
	looking up section names for DT_TEXTREL.
	(elf_i386_reloc_type_class): New.
	(elf_backend_reloc_type_class): Define.
	* elf32-sparc.c (elf32_sparc_check_relocs): Set DF_TEXTREL if the
	reloc is against read-only section.
	(elf32_sparc_size_dynamic_sections): Use DF_TEXTREL flag instead of
	looking up section names for DT_TEXTREL.
	(elf32_sparc_reloc_type_class): New.
	(elf_backend_reloc_type_class): Define.
	* elf64-sparc.c (sparc64_elf_check_relocs): Set DF_TEXTREL if the
	reloc is against read-only section.
	(sparc64_elf_size_dynamic_sections): Use DF_TEXTREL flag instead of
	looking up section names for DT_TEXTREL.
	(sparc64_elf_reloc_type_class): New.
	(elf_backend_reloc_type_class): Define.
	* elfxx-ia64.c (struct elfNN_ia64_link_hash_table): Add reltext field.
	(elfNN_ia64_hash_table_create): Clear ia64_info.
	(get_reloc_section): Set DF_TEXTREL if the reloc is against read-only
	section.
	(elfNN_ia64_size_dynamic_sections): Use ia64_info->reltext flag
	instead of looking up section names for DT_TEXTREL.
	(elfNN_ia64_reloc_type_class): New.
	(elf_backend_reloc_type_class): Define.
	* elflink.h (size_dynamic_sections): Add spare DT_NULL tags.
	(struct elf_link_sort_rela): New.
	(elf_link_sort_cmp1, elf_link_sort_cmp2, elf_link_sort_relocs): New.
	(elf_bfd_final_link): Call elf_link_sort_relocs.
	Convert one spare DT_NULL into DT_RELCOUNT resp. DT_RELACOUNT if
	necessary.

	* bfdlink.h (struct bfd_link_info): Add combreloc and
	spare_dynamic_tags fields.

	* emultempl/elf32.em (place_orphan): Place orphan .rel* sections
	into .rel.dyn resp. .rela.dyn if combreloc.
	(get_script): If .x linker script is equal to .xn, only put it
	once into the binary.
	Add .xc and .xsc scripts.
	(parse_args): Handle -z combreloc and -z nocombreloc.
	* scripttempl/elf.sc (.rela.sbss): Fix a typo.
	For .xc and .xsc scripts put all .rel* or .rela* input sections
	but .rel*.plt and PLT-like sections into .rel.dyn resp. .rela.dyn.
	* genscripts.sh (GENERATE_COMBRELOC_SCRIPT): Set if SCRIPT_NAME
	is elf.
	Strip trailing whitespace from script.
	Generate .xc and .xsc scripts if requested.
	* ldmain.c (main): Initialize link_info.combreloc and
	link_info.spare_dynamic_tags.
	* lexsup.c (OPTION_SPARE_DYNAMIC_TAGS): Define.
	(ld_options): Add --spare-dynamic-tags option.
	(parse_args): Likewise.
	* ld.texinfo: Document -z combreloc and -z nocombreloc.
	* ldint.texinfo: Document .xc and .xsc linker scripts.
	* NEWS: Add notes about -z combreloc and SHF_MERGE.
@
text
@d41 1
a41 2

#include <ctype.h>
d1196 1
a1196 1
	if (! isalnum ((unsigned char) *ps) && *ps != '_')
@


1.57
log
@	* emultempl/elf32.em: Formatting fixes.
	(output_prev_sec_find): Test for bfd_ind_section too;  do so by
	looking at sec->owner.
	(output_rel_find): Move function inside LDEMUL_PLACE_ORPHAN test.
	(gld${EMULATION_NAME}_place_orphan): Add a few comments.  Remove
	unused code, and reorganize orphan section placement code.
@
text
@d1138 19
a1156 1
    place = &hold_rel;
d1353 1
d1356 1
a1356 1

d1358 2
d1363 2
a1364 1

d1517 4
@


1.56
log
@(wild_doit): Rename to lang_add_section.
@
text
@d56 2
a57 1
static void gld${EMULATION_NAME}_before_parse PARAMS ((void));
d62 2
a63 1
static boolean gld${EMULATION_NAME}_try_needed PARAMS ((const char *, int));
d68 4
a71 2
static void gld${EMULATION_NAME}_after_open PARAMS ((void));
static void gld${EMULATION_NAME}_find_exp_assignment PARAMS ((etree_type *));
d74 2
a75 1
static void gld${EMULATION_NAME}_before_allocation PARAMS ((void));
d78 2
a79 1
static lang_output_section_statement_type *output_rel_find PARAMS ((void));
d84 2
a85 1
static char *gld${EMULATION_NAME}_get_script PARAMS ((int *isfile));
d251 1
a251 2
  if (strncmp (soname, global_needed->name,
	       suffix - global_needed->name) == 0)
d274 1
a274 1
      (void) bfd_close (abfd);
d279 1
a279 1
      (void) bfd_close (abfd);
d302 1
a302 1
	      (void) bfd_close (abfd);
d327 1
a327 1
		(void) bfd_close (abfd);
d987 2
a1013 5
EOF

if test x"$LDEMUL_PLACE_ORPHAN" != xgld"$EMULATION_NAME"_place_orphan; then
cat >>e${EMULATION_NAME}.c <<EOF

d1031 3
a1033 5
	break;
      if (lookup->bfd_section != NULL
          && lookup->bfd_section != bfd_abs_section_ptr
          && lookup->bfd_section != bfd_com_section_ptr 
          && lookup->bfd_section != bfd_und_section_ptr)
d1037 1
a1037 4
  if (u == NULL)
    return NULL;

  return s;
a1039 1

d1231 1
a1231 1
      asection *snew, **pps, *bfd_section;
d1234 4
a1237 7
      bfd_section = place->os->bfd_section;
      if (place->section == NULL && bfd_section == NULL)
	bfd_section = output_prev_sec_find (place->os);

      if (place->section != NULL
	  || (bfd_section != NULL
	      && bfd_section != snew))
d1239 12
a1250 18
	  /* Shuffle the section to make the output file look neater.
	     This is really only cosmetic.  */
	  if (place->section == NULL)
	    {
#if 0
	      /* Finding the end of the list is a little tricky.  We
		 make a wild stab at it by comparing section flags.  */
	      flagword first_flags = bfd_section->flags;
	      for (pps = &bfd_section->next;
		   *pps != NULL && (*pps)->flags == first_flags;
		   pps = &(*pps)->next)
		;
	      place->section = pps;
#else
	      /* Put orphans after the first section on the list.  */
	      place->section = &bfd_section->next;
#endif
	    }
d1252 2
a1262 1
      place->section = &snew->next;	/* Save the end of this list.  */
d1264 13
a1278 3
	  /* We try to put the output statements in some sort of
	     reasonable order here, because they determine the final
	     load addresses of the orphan sections.  */
@


1.55
log
@	* emultempl/elf32.em: For SEC_EXCLUDE sections, ensure that
	output_section is set non-NULL.
@
text
@d1088 1
a1088 1
	  wild_doit (&os->children, s, os, file);
d1103 1
a1103 1
      wild_doit (&hold_text.os->children, s, hold_text.os, file);
d1208 1
a1208 1
  wild_doit (&os->children, s, os, file);
@


1.54
log
@	* emultempl/elf32.em (gld${EMULATION_NAME}_place_orphan): Return
	`true' for SEC_EXCLUDE sections so that the generic code doesn't
	needlessly create an output_section_statement.  Treat a correctly
	named output_section_statement with NULL bfd_section as compatible.
@
text
@d1087 1
a1087 1
	     name, and its bfd section has compatible flags.  */
d1116 5
a1120 1
    return true;
@


1.53
log
@	* emultempl/elf32.em (output_prev_sec_find): Add missing prototype.
@
text
@d1082 3
a1084 3
	  && os->bfd_section != NULL
	  && ((s->flags ^ os->bfd_section->flags)
	      & (SEC_LOAD | SEC_ALLOC)) == 0)
d1086 2
a1087 1
	  /* We have already placed a section with this name.  */
d1116 1
a1116 1
    return false;
@


1.52
log
@2001-07-14  H.J. Lu  <hjl@@gnu.org>

	* emultempl/elf32.em (output_prev_sec_find): Never return
	bfd_abs_section_ptr, bfd_com_section_ptr nor
	bfd_und_section_ptr.
@
text
@d74 2
@


1.51
log
@	* emultempl/elf32.em (output_prev_sec_find): New.
	(place_orphan): Use it.
@
text
@d1027 4
a1030 1
      if (lookup->bfd_section != NULL)
@


1.50
log
@2001-07-09  David O'Brien  <obrien@@FreeBSD.org>
	* emultempl/elf32.em: Do not assuming that contents of the buffer
	returned from basename function will remain unchanged accross other
	function calls.

NOTE: DJ Delorie recomends doing a basename()->lbasename() conversion.

Approved by:  DJ Delorie
              <200107100030.UAA01223@@envy.delorie.com>
@
text
@d1009 29
d1224 1
a1224 1
      asection *snew, **pps;
d1227 4
d1232 2
a1233 2
	  || (place->os->bfd_section != NULL
	      && place->os->bfd_section != snew))
d1242 2
a1243 2
	      flagword first_flags = place->os->bfd_section->flags;
	      for (pps = &place->os->bfd_section->next;
d1250 1
a1250 1
	      place->section = &place->os->bfd_section->next;
@


1.49
log
@	* emultempl/elf32.em (gld${EMULATION_NAME}_before_allocation):
	Update for API change in bfd_elf${ELFSIZE}_size_dynamic_sections.
	* mpw-elfmips.c (gldelf32ebmip_before_allocation): Ditto.
	* ld.h (args_type): Remove member export_dynamic.  All users
	changed to use struct bfd_link_info member.
@
text
@d363 3
@


1.48
log
@2001-05-24  H.J. Lu  <hjl@@gnu.org>

	* emultempl/aix.em (OUTPUT_ARCH): Defined.
	(gld${EMULATION_NAME}_before_parse): Initialize
	ldfile_output_architecture, ldfile_output_machine and
	ldfile_output_machine_name from ${OUTPUT_ARCH} if possible.
	* emultempl/beos.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/mipsecoff.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/sunos.em: Likewise.
@
text
@d840 1
a840 1
	  command_line.export_dynamic, command_line.filter_shlib,
@


1.47
log
@* emultempl/elf32.em (ELF_INTERPRETER_SET_DEFAULT): Use this new
variable to avoid non-portable shell construct.
@
text
@d6 5
d98 9
a106 1
  ldfile_output_architecture = bfd_arch_`echo ${ARCH} | sed -e 's/:.*//'`;
@


1.46
log
@Improve Solaris compatability
@
text
@d792 12
d831 1
a831 9

${ELF_INTERPRETER_NAME+"
  if (sinterp != NULL)
    {
      sinterp->contents = ${ELF_INTERPRETER_NAME};
      sinterp->_raw_size = strlen (sinterp->contents) + 1;
    }

"}
@


1.45
log
@2001-05-03  H.J. Lu  <hjl@@gnu.org>

	* emultempl/elf32.em: Include "libiberty.h".
	(gld${EMULATION_NAME}_vercheck): Call basename () to get the
	basename of the bfd filename.
	(gld${EMULATION_NAME}_stat_needed): Likewise.
	(gld${EMULATION_NAME}_try_needed): Likewise.
	(gld${EMULATION_NAME}_open_dynamic_archive): Likewise.
@
text
@d820 8
@


1.44
log
@	* emultmpl/elf32.em (gld${EMULATION_NAME}_search_needed): If NAME
	is an absolute path look only for this file and not along the path.
@
text
@d35 1
d134 1
a134 1
  const char *soname, *f;
d145 1
a145 7
    soname = bfd_get_filename (s->the_bfd);

  f = strrchr (soname, '/');
  if (f != NULL)
    ++f;
  else
    f = soname;
d151 1
a151 1
      if (strcmp (f, l->name) == 0)
d166 1
a166 1
      if (strncmp (f, l->name, suffix - l->name) == 0)
a189 1
  const char *f;
d227 1
a227 1
    soname = s->filename;
d229 2
a230 7
  f = strrchr (soname, '/');
  if (f != NULL)
    ++f;
  else
    f = soname;

  if (strncmp (f, global_needed->name, suffix - global_needed->name) == 0)
d232 1
a232 1
	   global_needed->name, global_needed->by, f);
d332 1
a332 5
  soname = strrchr (abfd->filename, '/');
  if (soname)
    soname++;
  else
    soname = abfd->filename;
a936 2
      char *needed_name;

d940 1
a940 1
	 filename we recorded earlier.
d942 2
a943 7
	 First strip off everything before the last '/'.  */
      filename = strrchr (entry->filename, '/');
      filename++;

      needed_name = (char *) xmalloc (strlen (filename) + 1);
      strcpy (needed_name, filename);
      bfd_elf_set_dt_needed_name (entry->the_bfd, needed_name);
@


1.43
log
@	* emultempl/elf32.em (OPTION_GROUP): New macro.
	Add new option Bgroup to longopts.
	(gld*_parse_args): Handle GROUP_OPTION and recognize -z defs.
	(gld*_list_options): Add -Bgroup and -z defs.
	* ld.1: Document -Bgroup and -z defs.
	* ld.texinfo: Likewise.
@
text
@d389 3
@


1.42
log
@Fixtypos in ChangeLogs, fix copyright dates in files
@
text
@d1337 1
d1351 2
d1411 6
d1442 2
d1477 1
d1480 1
@


1.41
log
@	* emultempl/elf32.em: Correct spelling in comments and listed
	options.
@
text
@d10 1
a10 1
   Copyright (C) 1991, 93, 94, 95, 96, 97, 98, 99, 2000, 2001
@


1.41.2.1
log
@2001-03-17  Ulrich Drepper  <drepper@@redhat.com>

	* emultmpl/elf32.em (gld${EMULATION_NAME}_search_needed): If NAME
	is an absolute path look only for this file and not along the path.
@
text
@a388 3
  if (name[0] == '/')
    return gld${EMULATION_NAME}_try_needed (name, force);

@


1.41.2.2
log
@Merge from mainline.
@
text
@d10 1
a10 1
   Copyright 1991, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
a34 1
#include "libiberty.h"
d133 1
a133 1
  const char *soname;
d144 7
a150 1
    soname = basename (bfd_get_filename (s->the_bfd));
d156 1
a156 1
      if (strcmp (soname, l->name) == 0)
d171 1
a171 1
      if (strncmp (soname, l->name, suffix - l->name) == 0)
d195 1
d233 7
a239 1
    soname = basename (s->filename);
d241 1
a241 2
  if (strncmp (soname, global_needed->name,
	       suffix - global_needed->name) == 0)
d243 1
a243 1
	   global_needed->name, global_needed->by, soname);
d343 5
a347 1
  soname = basename (abfd->filename);
d952 2
d957 1
a957 1
	 filename we recorded earlier.  */
d959 7
a965 2
      filename = xstrdup (basename (entry->filename));
      bfd_elf_set_dt_needed_name (entry->the_bfd, filename);
a1339 1
#define OPTION_GROUP			(OPTION_ENABLE_NEW_DTAGS + 1)
a1352 2
  {"Bgroup", no_argument, NULL, OPTION_GROUP},
  {"Bgroup", no_argument, NULL, OPTION_GROUP},
a1410 6
    case OPTION_GROUP:
      link_info.flags_1 |= (bfd_vma) DF_1_GROUP;
      /* Groups must be self-contained.  */
      link_info.no_undefined = true;
      break;

a1435 2
      else if (strcmp (optarg, "defs") == 0)
	link_info.no_undefined = true;
a1468 1
  fprintf (file, _("  -Bgroup\t\tSelects group name lookup rules for DSO\n"));
a1470 1
  fprintf (file, _("  -z defs\t\tDisallows undefined symbols\n"));
@


1.41.2.3
log
@2001-07-19  David O'Brien  <obrien@@FreeBSD.org>
	* lbasename.c: New file.
	* libiberty.h: Add lbasename.

Approved by:  Philip Blundell <philb@@gnu.org>
              <E15K1Xn-00032C-00@@kings-cross.london.uk.eu.org>


	* emultempl/elf32.em: Do not assuming that contents of the buffer
	returned from basename function will remain unchanged accross other
	function calls.

Approved by:  Philip Blundell <philb@@gnu.org>
              <E15MO4s-00017V-00@@kings-cross.london.uk.eu.org>
@
text
@d145 1
a145 1
    soname = lbasename (bfd_get_filename (s->the_bfd));
d227 1
a227 1
    soname = lbasename (s->filename);
d332 1
a332 1
  soname = lbasename (abfd->filename);
@


1.40
log
@Extend "ld --unique" functionality.
@
text
@d80 1
a80 1
# Functions in this file can be overriden by setting the LDEMUL_* shell
d126 1
a126 1
   which we ar checking.  This sets GLOBAL_VERCHECK_FAILED if we find
d219 1
a219 1
     hueristic test, and it will only work if the name looks like
d1105 1
a1105 1
     loadable or allocateable characteristics.  */
d1468 2
a1469 2
  fprintf (file, _("  -z initfirst\t\tMark DSO to be initialized first at rutime\n"));
  fprintf (file, _("  -z interpose\t\tMark object to interpose all DSOs but execuable\n"));
d1473 2
a1474 2
  fprintf (file, _("  -z nodlopen\t\tMark DSO not availale to dlopen\n"));
  fprintf (file, _("  -z nodump\t\tMark DSO not availale to dldump\n"));
@


1.39
log
@2000-01-07  David O'Brien  <obrien@@BSDi.com>
	* emultempl/elf32.em: Only perform Linux ld hints processing when
	targeting Linux.

Approved by:  Nick Clifton <nickc@@redhat.com>
              Message-Id: <200101040127.RAA15127@@elmo.cygnus.com>
@
text
@d10 1
a10 1
   Copyright (C) 1991, 93, 94, 95, 96, 97, 98, 99, 2000
d530 1
a530 2
  if (s->filename != NULL
      && strcmp (s->filename, global_needed->name) == 0)
d532 18
a549 2
      global_found = true;
      return;
a563 15
	  
  if (s->search_dirs_flag
      && s->filename != NULL
      && strchr (global_needed->name, '/') == NULL)
    {
      const char *f;

      f = strrchr (s->filename, '/');
      if (f != NULL
	  && strcmp (f + 1, global_needed->name) == 0)
	{
	  global_found = true;
	  return;
	}
    }
d1033 1
a1033 1
  if (! config.unique_orphan_sections)
d1078 1
a1078 1
	   && strncmp (secname, ".note", 4) == 0
@


1.38
log
@Remove spurious whitespace
@
text
@d428 3
a430 1
cat >>e${EMULATION_NAME}.c <<EOF
d434 1
a434 1
   only meaningful on Linux, but we check it on other systems anyhow.  */
d514 3
a516 1
  ;;
d702 3
a704 1
cat >>e${EMULATION_NAME}.c <<EOF
d708 3
@


1.37
log
@Handle srdata sections emitted by Intel compiler.
	* emultempl/elf32.em (gld${EMULATION_NAME}_place_orphan): New local
	hold_sdata.  If SEC_SMALL_DATA set, set place to hold_sdata.
@
text
@d1026 1
a1026 1
      /* Look through the script to see where to place this section.  */ 
@


1.36
log
@Handle out of memory situations.
@
text
@d1011 1
d1075 3
@


1.35
log
@Fix an orphan section problem caused by weird linker scripts.
@
text
@d1095 7
a1101 3
    outsecname = bfd_get_unique_section_name (output_bfd,
					      outsecname,
					      &count);
@


1.34
log
@Fix list handling for orphan section output statements.
@
text
@d1206 1
a1206 4
      /* We try to put the output statements in some sort of
	 reasonable order here, because they determine the final load
	 addresses of the orphan sections.  */
      if (place->stmt == NULL)
d1208 15
a1222 10
	  /* Put the new statement list right at the head.  */
	  *add.tail = place->os->header.next;
	  place->os->header.next = add.head;
	}
      else
	{
	  /* Put it after the last orphan statement we added.  */
	  *add.tail = *place->stmt;
	  *place->stmt = add.head;
	}
d1224 4
a1227 4
      /* Fix the global list pointer if we happened to tack our new
	 list at the tail.  */
      if (*old->tail == add.head)
	old->tail = add.tail;
d1229 3
a1231 2
      /* Save the end of this list.  */
      place->stmt = add.tail;
@


1.33
log
@Fix place_orphan crash.
@
text
@d1013 1
a1013 1
  lang_statement_list_type *old = NULL;
d1063 4
a1066 2
  else if ((s->flags & SEC_ALLOC) == 0)
    place = NULL;
d1081 1
a1081 2
  else if ((s->flags & SEC_CODE) == 0
	   && (s->flags & SEC_READONLY) != 0
d1084 1
a1084 1
  else if ((s->flags & SEC_READONLY) != 0
a1086 2
  else
    place = NULL;
d1099 7
a1107 2
      /* Start building a list of statements for this section.  */
      old = stat_ptr;
d1110 1
d1112 2
d1119 1
a1119 1
      if (*ps == '\0' && config.build_constructors)
d1149 1
a1149 1
  if (place != NULL)
d1151 1
a1151 1
      asection *snew, **pps;
d1153 10
a1162 1
      stat_ptr = &add;
d1164 2
a1165 3
      if (*ps == '\0' && config.build_constructors)
	{
	  char *symname;
d1167 3
a1169 6
	  symname = (char *) xmalloc (ps - outsecname + sizeof "__stop_");
	  sprintf (symname, "__stop_%s", outsecname);
	  lang_add_assignment (exp_assop ('=', symname,
					  exp_nameop (NAME, ".")));
	}
      stat_ptr = old;
d1176 2
a1177 1
	  /* Shuffle the section to make the output file look neater.  */
d1206 3
d1221 8
a1228 1
      place->stmt = add.tail;		/* Save the end of this list.  */
@


1.32
log
@--split-by-reloc, --split-by-file extensions.  --unique option.
@
text
@d1011 1
d1096 3
a1098 1
    outsecname = bfd_get_unique_section_name (output_bfd, outsecname, NULL);
d1160 3
a1162 1
      if (place->os->bfd_section != NULL || place->section != NULL)
@


1.31
log
@2000-08-24  H.J. Lu  <hjl@@gnu.org>

	* emultempl/elf32.em (gld${EMULATION_NAME}_after_open): Don't
	check -rpath nor LD_RUN_PATH for cross link.
	* ld.texinfo: Document the change.
@
text
@d1015 1
a1015 1
  const char *secname, *ps = NULL;
d1017 1
d1022 4
a1025 2
  /* Look through the script to see where to place this section.  */
  os = lang_output_section_find (secname);
d1027 9
a1035 7
  if (os != NULL
      && os->bfd_section != NULL
      && ((s->flags ^ os->bfd_section->flags) & (SEC_LOAD | SEC_ALLOC)) == 0)
    {
      /* We have already placed a section with this name.  */
      wild_doit (&os->children, s, os, file);
      return true;
d1095 1
a1095 18
    {
      unsigned int len;
      char *newname;
      unsigned int i;

      len = strlen (outsecname);
      newname = xmalloc (len + 5);
      strcpy (newname, outsecname);
      i = 0;
      do
	{
	  sprintf (newname + len, "%d", i);
	  ++i;
	}
      while (bfd_get_section_by_name (output_bfd, newname) != NULL);

      outsecname = newname;
    }
@


1.30
log
@2000-08-23  H.J. Lu  <hjl@@gnu.org>

	* emultempl/elf32.em (gld${EMULATION_NAME}_after_open): Get
	the current runpath list from bfd_elf_get_runpath_list ()
	before search.
@
text
@a622 1
	  const char *lib_path;
d630 1
d642 5
a657 5
EOF
if [ "x${host}" = "x${target}" ] ; then
  case " ${EMULATION_LIBPATH} " in
  *" ${EMULATION_NAME} "*)
cat >>e${EMULATION_NAME}.c <<EOF
@


1.29
log
@2000-08-22  H.J. Lu  <hjl@@gnu.org>

	* emultempl/elf32.em (gld${EMULATION_NAME}_after_open): Search
	the DT_RPATH/DT_RUNPATH entries for DT_NEEDED after
	LD_LIBRARY_PATH for native linker. Display the needed DSO if
	trace_file_tries is non-zero.
	(gld${EMULATION_NAME}_try_needed): Report the needed DSO found
	if trace_file_tries is non-zero.

	* ld.texinfo: Document the usage of DT_RPATH/DT_RUNPATH.
	* News: Mention it.
@
text
@a572 11
EOF
if [ "x${host}" = "x${target}" ] ; then
  case " ${EMULATION_LIBPATH} " in
  *" ${EMULATION_NAME} "*)
cat >>e${EMULATION_NAME}.c <<EOF
  struct bfd_link_needed_list *run_path;
EOF
  ;;
  esac
fi
cat >>e${EMULATION_NAME}.c <<EOF
a577 12
EOF
if [ "x${host}" = "x${target}" ] ; then
  case " ${EMULATION_LIBPATH} " in
  *" ${EMULATION_NAME} "*)
cat >>e${EMULATION_NAME}.c <<EOF
  run_path = bfd_elf_get_runpath_list (output_bfd, &link_info);
EOF
  ;;
  esac
fi
cat >>e${EMULATION_NAME}.c <<EOF

a591 12
EOF
if [ "x${host}" = "x${target}" ] ; then
  case " ${EMULATION_LIBPATH} " in
  *" ${EMULATION_NAME} "*)
cat >>e${EMULATION_NAME}.c <<EOF
      struct bfd_link_needed_list *rp;
      int found;
EOF
  ;;
  esac
fi
cat >>e${EMULATION_NAME}.c <<EOF
d626 12
d663 2
a664 1
	  for (rp = run_path; !found && rp != NULL; rp = rp->next)
@


1.28
log
@Refer to -rpath not --rpath in error message
@
text
@d257 1
d341 11
a364 7
  /* First strip off everything before the last '/'.  */
  name = strrchr (abfd->filename, '/');
  if (name)
    name++;
  else
    name = abfd->filename;

d368 1
a368 1
  bfd_elf_set_dt_needed_soname (abfd, name);
d573 11
d589 12
d615 12
d642 3
d649 3
a651 2
	 LD_LIBRARY_PATH (native only), then the linker script
	 LIB_SEARCH_DIRS.  We do not search using the -L arguments.
d684 12
@


1.27
log
@Keep track of last optind value, and rename a couple of functions
for consistency.
@
text
@d677 1
a677 1
      einfo ("%P: warning: %s, needed by %B, not found (try using --rpath)\n",
d978 1
a978 1
  lang_statement_list_type *old;
d981 1
a981 1
  const char *secname, *ps;
@


1.26
log
@Add some shell variables and shell code to elf32.em
to allow elf32.em to be used by ports that require
some minor variations or a few extra functions.
Implement for hppaelf and armelf.
Fix header file include order in m68kcoff.em
@
text
@d1253 1
a1253 1
if test x"$LDEMUL_PARSE_ARGS" != xgld_"$EMULATION_NAME"_parse_args; then
d1294 1
a1294 1
static int gld_${EMULATION_NAME}_parse_args PARAMS ((int, char **));
d1297 1
a1297 1
gld_${EMULATION_NAME}_parse_args (argc, argv)
d1301 3
a1303 2
  int longind, optc;
  int prevoptind = optind;
a1305 1
  static int lastoptind = -1;
d1307 1
a1307 1
  if (lastoptind != optind)
d1310 3
a1312 1
  wanterror  = opterr;
d1323 1
a1323 1
      optind =  prevoptind;
d1383 1
a1383 1
if test x"$LDEMUL_LIST_OPTIONS" != xgld_"$EMULATION_NAME"_list_options; then
d1386 1
a1386 1
static void gld_${EMULATION_NAME}_list_options PARAMS ((FILE * file));
d1389 1
a1389 1
gld_${EMULATION_NAME}_list_options (file)
d1429 1
a1429 1
if test x"$LDEMUL_PARSE_ARGS" != xgld_"$EMULATION_NAME"_parse_args; then
d1431 1
a1431 1
#define gld_${EMULATION_NAME}_parse_args   NULL
d1434 1
a1434 1
if test x"$LDEMUL_LIST_OPTIONS" != xgld_"$EMULATION_NAME"_list_options; then
d1436 1
a1436 1
#define gld_${EMULATION_NAME}_list_options NULL
d1462 1
a1462 1
  ${LDEMUL_PARSE_ARGS-gld_${EMULATION_NAME}_parse_args},
d1464 1
a1464 1
  ${LDEMUL_LIST_OPTIONS-gld_${EMULATION_NAME}_list_options},
@


1.25
log
@Move functions around in preparation for next patch
@
text
@d72 17
d90 1
a90 1
gld${EMULATION_NAME}_before_parse()
d97 4
d349 1
a349 1
  /* Tell the ELF backend that don't want the output file to have a
d557 4
d682 4
d758 4
d837 5
d925 5
a930 1
/* A variant of lang_output_section_find.  */
d952 4
d960 1
a960 2
struct orphan_save
{
a965 1
/*ARGSUSED*/
d1184 5
d1191 1
a1191 1
gld${EMULATION_NAME}_get_script(isfile)
d1246 1
a1247 1

d1249 1
d1251 1
a1251 14
if test -n "$PARSE_AND_LIST_ARGS_CASES" || test x"$GENERATE_SHLIB_SCRIPT" = xyes; then
NEED_PARSE_AND_LIST=yes

cat >>e${EMULATION_NAME}.c <<EOF
static int  gld_${EMULATION_NAME}_parse_args PARAMS ((int, char **));
static void gld_${EMULATION_NAME}_list_options PARAMS ((FILE * file));
EOF
else
NEED_PARSE_AND_LIST=no

cat >>e${EMULATION_NAME}.c <<EOF
#define gld_${EMULATION_NAME}_parse_args   NULL
#define gld_${EMULATION_NAME}_list_options NULL
EOF
d1253 1
a1253 1
fi
a1260 1
if test "$NEED_PARSE_AND_LIST" = yes; then
a1270 1
fi
a1288 1
if test "$NEED_PARSE_AND_LIST" = yes; then
d1294 2
d1311 3
a1313 1
  optc = getopt_long_only (argc, argv, "-z:", longopts, &longind);
a1324 1
fi
a1371 1
if test "$NEED_PARSE_AND_LIST" = yes; then
d1378 7
a1390 1
fi
a1415 1
if test "$NEED_PARSE_AND_LIST" = yes; then
a1418 1
fi
d1425 13
d1443 10
a1452 10
  gld${EMULATION_NAME}_before_parse,
  syslib_default,
  hll_default,
  after_parse_default,
  gld${EMULATION_NAME}_after_open,
  after_allocation_default,
  set_output_arch_default,
  ldemul_default_target,
  gld${EMULATION_NAME}_before_allocation,
  gld${EMULATION_NAME}_get_script,
d1455 10
a1464 10
  NULL, 	/* finish */
  NULL, 	/* create output section statements */
  gld${EMULATION_NAME}_open_dynamic_archive,
  gld${EMULATION_NAME}_place_orphan,
  NULL,		/* set_symbols */
  gld_${EMULATION_NAME}_parse_args,
  NULL,		/* unrecognized_file */
  gld_${EMULATION_NAME}_list_options,
  NULL,		/* recognized_file */
  NULL		/* find_potential_libraries */
@


1.24
log
@2000-07-20  H.J. Lu  <hjl@@gnu.org>

	* emultempl/elf32.em (longopts): Duplicate "disable-new-dtags"
	and "disable-new-dtags" to stop getopt from treating -d/-e as
	abbreviations for these options.
@
text
@d51 1
a51 4
static boolean gld${EMULATION_NAME}_open_dynamic_archive
  PARAMS ((const char *, search_dirs_type *, lang_input_statement_type *));
static void gld${EMULATION_NAME}_after_open PARAMS ((void));
static void gld${EMULATION_NAME}_check_needed
d55 1
d58 1
a58 2
static boolean gld${EMULATION_NAME}_try_needed PARAMS ((const char *, int));
static void gld${EMULATION_NAME}_vercheck
d60 2
a61 1
static void gld${EMULATION_NAME}_before_allocation PARAMS ((void));
d64 4
a67 1
static void gld${EMULATION_NAME}_find_exp_assignment PARAMS ((etree_type *));
a69 1
static lang_output_section_statement_type *output_rel_find PARAMS ((void));
a79 174
/* Try to open a dynamic archive.  This is where we know that ELF
   dynamic libraries have an extension of .so (or .sl on oddball systems
   like hpux).  */

static boolean
gld${EMULATION_NAME}_open_dynamic_archive (arch, search, entry)
     const char *arch;
     search_dirs_type *search;
     lang_input_statement_type *entry;
{
  const char *filename;
  char *string;

  if (! entry->is_archive)
    return false;

  filename = entry->filename;

  /* This allocates a few bytes too many when EXTRA_SHLIB_EXTENSION
     is defined, but it does not seem worth the headache to optimize
     away those two bytes of space.  */
  string = (char *) xmalloc (strlen (search->name)
			     + strlen (filename)
			     + strlen (arch)
#ifdef EXTRA_SHLIB_EXTENSION
			     + strlen (EXTRA_SHLIB_EXTENSION)
#endif
			     + sizeof "/lib.so");

  sprintf (string, "%s/lib%s%s.so", search->name, filename, arch);

#ifdef EXTRA_SHLIB_EXTENSION
  /* Try the .so extension first.  If that fails build a new filename
     using EXTRA_SHLIB_EXTENSION.  */
  if (! ldfile_try_open_bfd (string, entry))
    sprintf (string, "%s/lib%s%s%s", search->name,
	     filename, arch, EXTRA_SHLIB_EXTENSION);
#endif

  if (! ldfile_try_open_bfd (string, entry))
    {
      free (string);
      return false;
    }

  entry->filename = string;

  /* We have found a dynamic object to include in the link.  The ELF
     backend linker will create a DT_NEEDED entry in the .dynamic
     section naming this file.  If this file includes a DT_SONAME
     entry, it will be used.  Otherwise, the ELF linker will just use
     the name of the file.  For an archive found by searching, like
     this one, the DT_NEEDED entry should consist of just the name of
     the file, without the path information used to find it.  Note
     that we only need to do this if we have a dynamic object; an
     archive will never be referenced by a DT_NEEDED entry.

     FIXME: This approach--using bfd_elf_set_dt_needed_name--is not
     very pretty.  I haven't been able to think of anything that is
     pretty, though.  */
  if (bfd_check_format (entry->the_bfd, bfd_object)
      && (entry->the_bfd->flags & DYNAMIC) != 0)
    {
      char *needed_name;

      ASSERT (entry->is_archive && entry->search_dirs_flag);

      /* Rather than duplicating the logic above.  Just use the
	 filename we recorded earlier.

	 First strip off everything before the last '/'.  */
      filename = strrchr (entry->filename, '/');
      filename++;

      needed_name = (char *) xmalloc (strlen (filename) + 1);
      strcpy (needed_name, filename);
      bfd_elf_set_dt_needed_name (entry->the_bfd, needed_name);
    }

  return true;
}

EOF
if [ "x${host}" = "x${target}" ] ; then
  case " ${EMULATION_LIBPATH} " in
  *" ${EMULATION_NAME} "*)
cat >>e${EMULATION_NAME}.c <<EOF

/* For a native linker, check the file /etc/ld.so.conf for directories
   in which we may find shared libraries.  /etc/ld.so.conf is really
   only meaningful on Linux, but we check it on other systems anyhow.  */

static boolean gld${EMULATION_NAME}_check_ld_so_conf
  PARAMS ((const char *, int));

static boolean
gld${EMULATION_NAME}_check_ld_so_conf (name, force)
     const char *name;
     int force;
{
  static boolean initialized;
  static char *ld_so_conf;

  if (! initialized)
    {
      FILE *f;

      f = fopen ("/etc/ld.so.conf", FOPEN_RT);
      if (f != NULL)
	{
	  char *b;
	  size_t len, alloc;
	  int c;

	  len = 0;
	  alloc = 100;
	  b = (char *) xmalloc (alloc);

	  while ((c = getc (f)) != EOF)
	    {
	      if (len + 1 >= alloc)
		{
		  alloc *= 2;
		  b = (char *) xrealloc (b, alloc);
		}
	      if (c != ':'
		  && c != ' '
		  && c != '\t'
		  && c != '\n'
		  && c != ',')
		{
		  b[len] = c;
		  ++len;
		}
	      else
		{
		  if (len > 0 && b[len - 1] != ':')
		    {
		      b[len] = ':';
		      ++len;
		    }
		}
	    }

	  if (len > 0 && b[len - 1] == ':')
	    --len;

	  if (len > 0)
	    b[len] = '\0';
	  else
	    {
	      free (b);
	      b = NULL;
	    }

	  fclose (f);

	  ld_so_conf = b;
	}

      initialized = true;
    }

  if (ld_so_conf == NULL)
    return false;

  return gld${EMULATION_NAME}_search_needed (ld_so_conf, name, force);
}

EOF
  ;;
  esac
fi
cat >>e${EMULATION_NAME}.c <<EOF
d90 17
a106 1
/* This is called after all the input files have been opened.  */
d109 2
a110 1
gld${EMULATION_NAME}_after_open ()
d112 2
a113 1
  struct bfd_link_needed_list *needed, *l;
d115 4
a118 2
  /* We only need to worry about this when doing a final link.  */
  if (link_info.relocateable || link_info.shared)
d121 11
a131 11
  /* Get the list of files which appear in DT_NEEDED entries in
     dynamic objects included in the link (often there will be none).
     For each such file, we want to track down the corresponding
     library, and include the symbol table in the link.  This is what
     the runtime dynamic linker will do.  Tracking the files down here
     permits one dynamic object to include another without requiring
     special action by the person doing the link.  Note that the
     needed list can actually grow while we are stepping through this
     loop.  */
  needed = bfd_elf_get_needed_list (output_bfd, &link_info);
  for (l = needed; l != NULL; l = l->next)
d133 7
a139 2
      struct bfd_link_needed_list *ll;
      int force;
d141 1
a141 5
      /* If we've already seen this file, skip it.  */
      for (ll = needed; ll != l; ll = ll->next)
	if (strcmp (ll->name, l->name) == 0)
	  break;
      if (ll != l)
d144 2
a145 5
      /* See if this file was included in the link explicitly.  */
      global_needed = l;
      global_found = false;
      lang_for_each_input_file (gld${EMULATION_NAME}_check_needed);
      if (global_found)
d148 1
a148 6
      /* We need to find this file and include the symbol table.  We
	 want to search for the file in the same way that the dynamic
	 linker will search.  That means that we want to use
	 rpath_link, rpath, then the environment variable
	 LD_LIBRARY_PATH (native only), then the linker script
	 LIB_SEARCH_DIRS.  We do not search using the -L arguments.
d150 1
a150 4
	 We search twice.  The first time, we skip objects which may
	 introduce version mismatches.  The second time, we force
	 their use.  See gld${EMULATION_NAME}_vercheck comment.  */
      for (force = 0; force < 2; force++)
d152 7
a158 58
	  const char *lib_path;
	  size_t len;
	  search_dirs_type *search;

	  if (gld${EMULATION_NAME}_search_needed (command_line.rpath_link,
						  l->name, force))
	    break;
	  if (gld${EMULATION_NAME}_search_needed (command_line.rpath,
						  l->name, force))
	    break;
	  if (command_line.rpath_link == NULL
	      && command_line.rpath == NULL)
	    {
	      lib_path = (const char *) getenv ("LD_RUN_PATH");
	      if (gld${EMULATION_NAME}_search_needed (lib_path, l->name,
						      force))
		break;
	    }
EOF
if [ "x${host}" = "x${target}" ] ; then
  case " ${EMULATION_LIBPATH} " in
  *" ${EMULATION_NAME} "*)
cat >>e${EMULATION_NAME}.c <<EOF
	  lib_path = (const char *) getenv ("LD_LIBRARY_PATH");
	  if (gld${EMULATION_NAME}_search_needed (lib_path, l->name, force))
	    break;
EOF
  ;;
  esac
fi
cat >>e${EMULATION_NAME}.c <<EOF
	  len = strlen (l->name);
	  for (search = search_head; search != NULL; search = search->next)
	    {
	      char *filename;

	      if (search->cmdline)
		continue;
	      filename = (char *) xmalloc (strlen (search->name) + len + 2);
	      sprintf (filename, "%s/%s", search->name, l->name);
	      if (gld${EMULATION_NAME}_try_needed (filename, force))
		break;
	      free (filename);
	    }
	  if (search != NULL)
	    break;
EOF
if [ "x${host}" = "x${target}" ] ; then
  case " ${EMULATION_LIBPATH} " in
  *" ${EMULATION_NAME} "*)
cat >>e${EMULATION_NAME}.c <<EOF
	  if (gld${EMULATION_NAME}_check_ld_so_conf (l->name, force))
	    break;
EOF
  ;;
  esac
fi
cat >>e${EMULATION_NAME}.c <<EOF
a159 6

      if (force < 2)
	continue;

      einfo ("%P: warning: %s, needed by %B, not found (try using --rpath)\n",
	     l->name, l->by);
a162 1
/* Search for a needed file in a path.  */
d164 6
a169 5
static boolean
gld${EMULATION_NAME}_search_needed (path, name, force)
     const char *path;
     const char *name;
     int force;
d171 9
a179 2
  const char *s;
  size_t len;
d181 1
a181 4
  if (path == NULL || *path == '\0')
    return false;
  len = strlen (name);
  while (1)
d183 3
a185 1
      char *filename, *sset;
d187 6
a192 3
      s = strchr (path, ':');
      if (s == NULL)
	s = path + strlen (path);
d194 8
a201 10
      filename = (char *) xmalloc (s - path + len + 2);
      if (s == path)
	sset = filename;
      else
	{
	  memcpy (filename, path, s - path);
	  filename[s - path] = '/';
	  sset = filename + (s - path) + 1;
	}
      strcpy (sset, name);
d203 6
a208 2
      if (gld${EMULATION_NAME}_try_needed (filename, force))
	return true;
d210 3
a212 1
      free (filename);
d214 5
a218 4
      if (*s == '\0')
	break;
      path = s + 1;
    }
d220 3
a222 1
  return false;
d225 1
d288 171
a458 1
	    struct bfd_link_needed_list *l;
d460 2
a461 9
	    for (l = needed; l != NULL; l = l->next)
	      if (strncmp (l->name, "libc.so", 7) == 0)
		break;
	    if (l == NULL)
	      {
		(void) bfd_close (abfd);
		return false;
	      }
	  }
d463 7
a469 6
EOF
    ;;
esac
cat >>e${EMULATION_NAME}.c <<EOF
	}
    }
d471 1
a471 1
  /* We've found a dynamic object matching the DT_NEEDED entry.  */
d473 2
a474 7
  /* We have already checked that there is no other input file of the
     same name.  We must now check again that we are not including the
     same file twice.  We need to do this because on many systems
     libc.so is a symlink to, e.g., libc.so.1.  The SONAME entry will
     reference libc.so.1.  If we have already included libc.so, we
     don't want to include libc.so.1 if they are the same file, and we
     can only check that using stat.  */
d476 1
a476 9
  if (bfd_stat (abfd, &global_stat) != 0)
    einfo ("%F%P:%B: bfd_stat failed: %E\n", abfd);
  global_found = false;
  lang_for_each_input_file (gld${EMULATION_NAME}_stat_needed);
  if (global_found)
    {
      /* Return true to indicate that we found the file, even though
         we aren't going to do anything with it.  */
      return true;
d479 2
a480 3
  /* Tell the ELF backend that don't want the output file to have a
     DT_NEEDED entry for this file.  */
  bfd_elf_set_dt_needed_name (abfd, "");
d482 2
a483 6
  /* First strip off everything before the last '/'.  */
  name = strrchr (abfd->filename, '/');
  if (name)
    name++;
  else
    name = abfd->filename;
d485 5
a489 11
  /* Tell the ELF backend that the output file needs a DT_NEEDED
     entry for this file if it is used to resolve the reference in
     a regular object.  */
  bfd_elf_set_dt_needed_soname (abfd, name);

  /* Add this file into the symbol table.  */
  if (! bfd_link_add_symbols (abfd, &link_info))
    einfo ("%F%B: could not read symbols: %E\n", abfd);

  return true;
}
d536 2
a537 2
/* See if an input file matches a DT_NEEDED entry by running stat on
   the file.  */
d540 1
a540 2
gld${EMULATION_NAME}_stat_needed (s)
     lang_input_statement_type *s;
d542 1
a542 4
  struct stat st;
  const char *suffix;
  const char *soname;
  const char *f;
d544 2
a545 3
  if (global_found)
    return;
  if (s->the_bfd == NULL)
d548 11
a558 1
  if (bfd_stat (s->the_bfd, &st) != 0)
d560 2
a561 3
      einfo ("%P:%B: bfd_stat failed: %E\n", s->the_bfd);
      return;
    }
d563 6
a568 6
  if (st.st_dev == global_stat.st_dev
      && st.st_ino == global_stat.st_ino)
    {
      global_found = true;
      return;
    }
d570 6
a575 8
  /* We issue a warning if it looks like we are including two
     different versions of the same shared library.  For example,
     there may be a problem if -lc picks up libc.so.6 but some other
     shared library has a DT_NEEDED entry of libc.so.5.  This is a
     hueristic test, and it will only work if the name looks like
     NAME.so.VERSION.  FIXME: Depending on file names is error-prone.
     If we really want to issue warnings about mixing version numbers
     of shared libraries, we need to find a better way.  */
d577 6
a582 6
  if (strchr (global_needed->name, '/') != NULL)
    return;
  suffix = strstr (global_needed->name, ".so.");
  if (suffix == NULL)
    return;
  suffix += sizeof ".so." - 1;
d584 8
a591 3
  soname = bfd_elf_get_dt_soname (s->the_bfd);
  if (soname == NULL)
    soname = s->filename;
d593 31
a623 5
  f = strrchr (soname, '/');
  if (f != NULL)
    ++f;
  else
    f = soname;
d625 23
a647 4
  if (strncmp (f, global_needed->name, suffix - global_needed->name) == 0)
    einfo ("%P: warning: %s, needed by %B, may conflict with %s\n",
	   global_needed->name, global_needed->by, f);
}
d649 2
a650 5
/* On Linux, it's possible to have different versions of the same
   shared library linked against different versions of libc.  The
   dynamic linker somehow tags which libc version to use in
   /etc/ld.so.cache, and, based on the libc that it sees in the
   executable, chooses which version of the shared library to use.
d652 4
a655 17
   We try to do a similar check here by checking whether this shared
   library needs any other shared libraries which may conflict with
   libraries we have already included in the link.  If it does, we
   skip it, and try to find another shared library farther on down the
   link path.

   This is called via lang_for_each_input_file.
   GLOBAL_VERCHECK_NEEDED is the list of objects needed by the object
   which we ar checking.  This sets GLOBAL_VERCHECK_FAILED if we find
   a conflicting version.  */

static void
gld${EMULATION_NAME}_vercheck (s)
     lang_input_statement_type *s;
{
  const char *soname, *f;
  struct bfd_link_needed_list *l;
a656 5
  if (global_vercheck_failed)
    return;
  if (s->the_bfd == NULL
      || (bfd_get_file_flags (s->the_bfd) & DYNAMIC) == 0)
    return;
d658 1
a658 3
  soname = bfd_elf_get_dt_soname (s->the_bfd);
  if (soname == NULL)
    soname = bfd_get_filename (s->the_bfd);
d660 5
a664 5
  f = strrchr (soname, '/');
  if (f != NULL)
    ++f;
  else
    f = soname;
d666 1
a666 1
  for (l = global_vercheck_needed; l != NULL; l = l->next)
d668 13
a680 1
      const char *suffix;
d682 3
a684 1
      if (strcmp (f, l->name) == 0)
d686 5
a690 2
	  /* Probably can't happen, but it's an easy check.  */
	  continue;
d692 2
d695 4
a698 2
      if (strchr (l->name, '/') != NULL)
	continue;
d700 5
a704 3
      suffix = strstr (l->name, ".so.");
      if (suffix == NULL)
	continue;
d706 3
a708 1
      suffix += sizeof ".so." - 1;
d710 2
a711 10
      if (strncmp (f, l->name, suffix - l->name) == 0)
	{
	  /* Here we know that S is a dynamic object FOO.SO.VER1, and
             the object we are considering needs a dynamic object
             FOO.SO.VER2, and VER1 and VER2 are different.  This
             appears to be a version mismatch, so we tell the caller
             to try a different version of this library.  */
	  global_vercheck_failed = true;
	  return;
	}
d715 15
a803 4
/* This is called by the before_allocation routine via
   lang_for_each_statement.  It locates any assignment statements, and
   tells the ELF backend about them, in case they are assignments to
   symbols which are referred to by dynamic objects.  */
d805 9
a813 3
static void
gld${EMULATION_NAME}_find_statement_assignment (s)
     lang_statement_union_type *s;
d815 34
a848 3
  if (s->header.type == lang_assignment_statement_enum)
    gld${EMULATION_NAME}_find_exp_assignment (s->assignment_statement.exp);
}
d850 1
a850 1
/* Look through an expression for an assignment statement.  */
d852 9
a860 5
static void
gld${EMULATION_NAME}_find_exp_assignment (exp)
     etree_type *exp;
{
  struct bfd_link_hash_entry *h;
d862 5
a866 1
  switch (exp->type.node_class)
d868 6
a873 5
    case etree_provide:
      h = bfd_link_hash_lookup (link_info.hash, exp->assign.dst,
				false, false, false);
      if (h == NULL)
	break;
d875 3
a877 7
      /* We call record_link_assignment even if the symbol is defined.
	 This is because if it is defined by a dynamic object, we
	 actually want to use the value defined by the linker script,
	 not the value from the dynamic object (because we are setting
	 symbols like etext).  If the symbol is defined by a regular
	 object, then, as it happens, calling record_link_assignment
	 will do no harm.  */
d879 4
a882 12
      /* Fall through.  */
    case etree_assign:
      if (strcmp (exp->assign.dst, ".") != 0)
	{
	  if (! (bfd_elf${ELFSIZE}_record_link_assignment
		 (output_bfd, &link_info, exp->assign.dst,
		  exp->type.node_class == etree_provide ? true : false)))
	    einfo ("%P%F: failed to record assignment to %s: %E\n",
		   exp->assign.dst);
	}
      gld${EMULATION_NAME}_find_exp_assignment (exp->assign.src);
      break;
d884 2
a885 4
    case etree_binary:
      gld${EMULATION_NAME}_find_exp_assignment (exp->binary.lhs);
      gld${EMULATION_NAME}_find_exp_assignment (exp->binary.rhs);
      break;
a886 5
    case etree_trinary:
      gld${EMULATION_NAME}_find_exp_assignment (exp->trinary.cond);
      gld${EMULATION_NAME}_find_exp_assignment (exp->trinary.lhs);
      gld${EMULATION_NAME}_find_exp_assignment (exp->trinary.rhs);
      break;
d888 6
a893 3
    case etree_unary:
      gld${EMULATION_NAME}_find_exp_assignment (exp->unary.child);
      break;
d895 11
a905 2
    default:
      break;
d907 1
d910 1
a1139 21
/* A variant of lang_output_section_find.  */
static lang_output_section_statement_type *
output_rel_find ()
{
  lang_statement_union_type *u;
  lang_output_section_statement_type *lookup;

  for (u = lang_output_section_statement.head;
       u != (lang_statement_union_type *) NULL;
       u = lookup->next)
    {
      lookup = &u->output_section_statement;
      if (strncmp (".rel", lookup->name, 4) == 0
	  && lookup->bfd_section != NULL
	  && (lookup->bfd_section->flags & SEC_ALLOC) != 0)
	{
	  return lookup;
	}
    }
  return (lang_output_section_statement_type *) NULL;
}
d1259 1
d1341 1
@


1.23
log
@2000-07-20  H.J. Lu  <hjl@@gnu.org>

	* ld.texinfo: Add documentation for --disable-new-dtags and
	--enable-new-dtags.

	* ldmain.c (main): Initialize link_info.new_dtags to false.

	* emultempl/elf32.em (gld_${EMULATION_NAME}_parse_args): Add
	--disable-new-dtags and --enable-new-dtags.
	(gld_${EMULATION_NAME}_list_options): Likewise.
@
text
@d1226 2
d1229 2
@


1.22
log
@2000-07-20  H.J. Lu  <hjl@@gnu.org>

	* emultempl/elf32.em (gld_${EMULATION_NAME}_list_options):
	Print out ignored -z options.
@
text
@d1216 3
d1226 2
a1227 1
  {NULL, required_argument, NULL, 'z'},
d1267 1
d1273 8
d1307 1
a1307 1
    break;
d1333 2
@


1.21
log
@2000-07-19  H.J. Lu  <hjl@@gnu.org>

	* emulparams/elf32mcore.sh (PARSE_AND_LIST_ARGS): Removed.
	(PARSE_AND_LIST_PROLOGUE): New.
	(PARSE_AND_LIST_LONGOPTS): Likewise.
	(PARSE_AND_LIST_OPTIONS): Likewise.
	(PARSE_AND_LIST_ARGS_CASES): Likewise.

	* ldmain.c (main): Clear link_info.flags and link_info.flags_1.

	* lexsup.c (ld_options): Comment out 'z'.
	(parse_args): Likewise.

	* emultempl/elf32.em: Include "elf/common.h".
	(gld_${EMULATION_NAME}_parse_args): Defined. Handle some -z
	options.
	(gld_${EMULATION_NAME}_list_options): Likewise.

	* ld.texinfo: Add documentation for the recognized -z options.
@
text
@d1330 1
@


1.20
log
@2000-07-19  H.J. Lu  <hjl@@gnu.org>

	* emultempl/elf32.em (gld${EMULATION_NAME}_try_needed): Call
	bfd_elf_set_dt_needed_soname ().
@
text
@d48 1
d1188 3
a1190 1
if test -n "$PARSE_AND_LIST_ARGS" ; then
a1193 2

 $PARSE_AND_LIST_ARGS
d1196 1
d1203 146
@


1.19
log
@Remove some forward declarations in ldemul.h and ldfile.h, and
re-arrange header include order.
Fix shadowing warnings in ldlang.h
Fix compile errors in mpw-elfmips.c
@
text
@d535 12
@


1.18
log
@Applied Stephane Carrez <Stephane.Carrez@@worldnet.fr> patches to add support
for m68hc11 and m68hc12 processors.
@
text
@d10 1
a10 1
   Copyright (C) 1991, 93, 94, 95, 96, 97, 98, 1999
a41 2
#include "ldemul.h"
#include "ldfile.h"
d45 2
@


1.17
log
@place_orphan optimisations
@
text
@d426 1
a426 1
  return false;	  
d1128 1
a1128 1
{			     
d1155 1
a1155 1
{			     
d1193 1
a1193 1
struct ld_emulation_xfer_struct ld_${EMULATION_NAME}_emulation = 
@


1.16
log
@2000-04-18  H.J. Lu  <hjl@@gnu.org>

	* emultempl/elf32.em (gld${EMULATION_NAME}_place_orphan): Call
	lang_leave_output_section_statement () after calling
	lang_enter_output_section_statement ().
	* emultempl/armelf.em: Likewise.
@
text
@d68 1
a68 2
static void gld${EMULATION_NAME}_place_section
  PARAMS ((lang_statement_union_type *));
a866 3
static asection *hold_section;
static lang_output_section_statement_type *hold_use;

a872 6
static struct orphan_save hold_text;
static struct orphan_save hold_rodata;
static struct orphan_save hold_data;
static struct orphan_save hold_bss;
static struct orphan_save hold_rel;
static struct orphan_save hold_interp;
d880 6
d894 2
d897 1
a897 3
  hold_section = s;
  hold_use = NULL;
  lang_for_each_statement (gld${EMULATION_NAME}_place_section);
d899 3
a901 1
  if (hold_use != NULL)
d904 1
a904 1
      wild_doit (&hold_use->children, s, hold_use, file);
d908 2
a909 1
  secname = bfd_get_section_name (s->owner, s);
d927 3
d936 1
a936 1
	   && hold_interp.os != NULL)
d939 1
a939 1
	   && hold_bss.os != NULL)
d942 1
a942 1
	   && hold_data.os != NULL)
d945 2
a946 1
	   && hold_rel.os != NULL)
d950 1
a950 1
	   && hold_rodata.os != NULL)
d958 2
d1014 5
a1018 5
  lang_enter_output_section_statement (outsecname, address, 0,
				       (bfd_vma) 0,
				       (etree_type *) NULL,
				       (etree_type *) NULL,
				       (etree_type *) NULL);
a1019 1
  os = lang_output_section_statement_lookup (outsecname);
d1093 3
a1095 3
static void
gld${EMULATION_NAME}_place_section (s)
     lang_statement_union_type *s;
d1097 2
a1098 1
  lang_output_section_statement_type *os;
d1100 13
a1112 26
  if (s->header.type != lang_output_section_statement_enum)
    return;

  os = &s->output_section_statement;

  if (strcmp (os->name, hold_section->name) == 0
      && os->bfd_section != NULL
      && ((hold_section->flags & (SEC_LOAD | SEC_ALLOC))
	  == (os->bfd_section->flags & (SEC_LOAD | SEC_ALLOC))))
    hold_use = os;

  if (strcmp (os->name, ".text") == 0)
    hold_text.os = os;
  else if (strcmp (os->name, ".rodata") == 0)
    hold_rodata.os = os;
  else if (strcmp (os->name, ".data") == 0)
    hold_data.os = os;
  else if (strcmp (os->name, ".bss") == 0)
    hold_bss.os = os;
  else if (hold_rel.os == NULL
	   && os->bfd_section != NULL
	   && (os->bfd_section->flags & SEC_ALLOC) != 0
	   && strncmp (os->name, ".rel", 4) == 0)
    hold_rel.os = os;
  else if (strcmp (os->name, ".interp") == 0)
    hold_interp.os = os;
@


1.15
log
@Yet another set of fixes for orphan sections.
@
text
@d1018 4
a1025 3
      lang_leave_output_section_statement
	((bfd_vma) 0, "*default*",
	 (struct lang_output_section_phdr_list *) NULL, "*default*");
@


1.14
log
@Zero start address of orphan ~(SEC_LOAD | SEC_ALLOC) sections.
@
text
@d874 1
a890 1
  asection *snew, **pps;
d930 2
d979 1
a979 7
  /* Create the section in the output file, and put it in the right
     place.  This shuffling is to make the output file look neater.  */
  snew = bfd_make_section (output_bfd, outsecname);
  if (snew == NULL)
      einfo ("%P%F: output format %s cannot represent section called %s\n",
	     output_bfd->xvec->name, outsecname);
  if (place != NULL && place->os->bfd_section != NULL)
d981 14
a994 10
      /* Unlink it first.  */
      for (pps = &output_bfd->sections; *pps != snew; pps = &(*pps)->next)
	;
      *pps = snew->next;
      snew->next = NULL;
      /* Now tack it on to the end of the "place->os" section list.  */
      for (pps = &place->os->bfd_section; *pps; pps = &(*pps)->next)
	;
      *pps = snew;
    }
d996 6
a1001 20
  /* Start building a list of statements for this section.  */
  old = stat_ptr;
  stat_ptr = &add;
  lang_list_init (stat_ptr);

  /* If the name of the section is representable in C, then create
     symbols to mark the start and the end of the section.  */
  for (ps = outsecname; *ps != '\0'; ps++)
    if (! isalnum ((unsigned char) *ps) && *ps != '_')
      break;
  if (*ps == '\0' && config.build_constructors)
    {
      char *symname;

      symname = (char *) xmalloc (ps - outsecname + sizeof "__start_");
      sprintf (symname, "__start_%s", outsecname);
      lang_add_assignment (exp_assop ('=', symname,
				      exp_unop (ALIGN_K,
						exp_intop ((bfd_vma) 1
							   << s->alignment_power))));
d1018 8
a1025 4
  lang_leave_output_section_statement
    ((bfd_vma) 0, "*default*", (struct lang_output_section_phdr_list *) NULL,
     "*default*");
  stat_ptr = &add;
d1027 10
a1036 3
  if (*ps == '\0' && config.build_constructors)
    {
      char *symname;
d1038 31
a1068 5
      symname = (char *) xmalloc (ps - outsecname + sizeof "__stop_");
      sprintf (symname, "__stop_%s", outsecname);
      lang_add_assignment (exp_assop ('=', symname,
				      exp_nameop (NAME, ".")));
    }
d1070 1
a1070 3
  if (place != NULL)
    {
      if (! place->stmt)
d1082 1
a1082 1
      place->stmt = add.tail;	/* Save the end of this list.  */
a1083 1
  stat_ptr = old;
@


1.13
log
@Keep output orphan sections in the same order as input.
@
text
@a897 3
  if ((s->flags & SEC_ALLOC) == 0)
    return false;

d951 1
a951 1
    return false;
d983 1
a983 1
  if (place->os->bfd_section != NULL)
d1018 3
a1020 1
  if (! link_info.relocateable)
a1021 2
  else
    address = exp_intop ((bfd_vma) 0);
d1047 1
a1047 1
  if (! place->stmt)
d1049 13
a1061 3
      /* Put the new statement list right at the head.  */
      *add.tail = place->os->header.next;
      place->os->header.next = add.head;
a1062 8
  else
    {
      /* Put it after the last orphan statement we added.  */
      *add.tail = *place->stmt;
      *place->stmt = add.head;
    }
  place->stmt = add.tail;	/* Save the end of this list.  */

@


1.12
log
@GCC warning fix: Add missing NULL initialiser for find_potential_libraries.
@
text
@d870 12
a881 6
static lang_output_section_statement_type *hold_text;
static lang_output_section_statement_type *hold_rodata;
static lang_output_section_statement_type *hold_data;
static lang_output_section_statement_type *hold_bss;
static lang_output_section_statement_type *hold_rel;
static lang_output_section_statement_type *hold_interp;
d889 1
a889 1
  lang_output_section_statement_type *place;
d920 1
a920 1
      && hold_text != NULL)
d922 1
a922 1
      wild_doit (&hold_text->children, s, hold_text, file);
a930 1
  place = NULL;
d934 3
a936 3
      && strncmp (secname, ".note", 4) == 0
      && hold_interp != NULL)
    place = hold_interp;
d938 2
a939 2
	   && hold_bss != NULL)
    place = hold_bss;
d941 2
a942 2
	   && hold_data != NULL)
    place = hold_data;
d944 2
a945 2
	   && hold_rel != NULL)
    place = hold_rel;
d948 2
a949 2
	   && hold_rodata != NULL)
    place = hold_rodata;
d951 3
a953 3
	   && hold_text != NULL)
    place = hold_text;
  if (place == NULL)
d986 1
a986 1
  if (place->bfd_section != NULL)
d988 1
d992 5
a996 2
      snew->next = place->bfd_section->next;
      place->bfd_section->next = snew;
d1050 13
a1062 3
  /* Now stick the new statement list right after PLACE.  */
  *add.tail = place->header.next;
  place->header.next = add.head;
d1087 1
a1087 1
    hold_text = os;
d1089 1
a1089 1
    hold_rodata = os;
d1091 1
a1091 1
    hold_data = os;
d1093 2
a1094 2
    hold_bss = os;
  else if (hold_rel == NULL
d1098 1
a1098 1
    hold_rel = os;
d1100 1
a1100 1
    hold_interp = os;
@


1.12.2.1
log
@2000-10-12  Peter Jeremy  <peter.jeremy@@alcatel.com.au>
	From 2000-08-08  Peter Jeremy  <peter.jeremy@@alcatel.com.au>
	* emultempl/elf32.em (_after_close): Refer to -rpath not --rpath
	in error message.
	(gld${EMULATION_NAME}_place_orphan): Quite compiler warnings.

Approved by:  Philip Blundell <pb@@futuretv.com>
              Message-Id: <E13jdVk-0002fY-00@@fountain.labs.futuretv.com>
@
text
@d379 1
a379 1
      einfo ("%P: warning: %s, needed by %B, not found (try using -rpath or -rpath-link)\n",
d885 1
a885 1
  lang_statement_list_type *old = NULL;
d888 1
a888 1
  const char *secname, *ps = NULL;
@


1.12.2.2
log
@Merge elf32.em place_orphan changes from mainline.
@
text
@d10 1
a10 1
   Copyright (C) 1991, 93, 94, 95, 96, 97, 98, 99, 2000
a65 1
static lang_output_section_statement_type *output_rel_find PARAMS ((void));
d68 2
a864 23
/* A variant of lang_output_section_find.  Used by place_orphan.  */

static lang_output_section_statement_type *
output_rel_find ()
{
  lang_statement_union_type *u;
  lang_output_section_statement_type *lookup;

  for (u = lang_output_section_statement.head;
       u != (lang_statement_union_type *) NULL;
       u = lookup->next)
    {
      lookup = &u->output_section_statement;
      if (strncmp (".rel", lookup->name, 4) == 0
	  && lookup->bfd_section != NULL
	  && (lookup->bfd_section->flags & SEC_ALLOC) != 0)
	{
	  return lookup;
	}
    }
  return (lang_output_section_statement_type *) NULL;
}

d868 8
a875 5
struct orphan_save {
  lang_output_section_statement_type *os;
  asection **section;
  lang_statement_union_type **stmt;
};
d877 1
d883 3
a885 8
  static struct orphan_save hold_text;
  static struct orphan_save hold_rodata;
  static struct orphan_save hold_data;
  static struct orphan_save hold_bss;
  static struct orphan_save hold_rel;
  static struct orphan_save hold_interp;
  struct orphan_save *place;
  lang_statement_list_type *old;
d888 1
a888 1
  const char *secname;
a889 1
  const char *ps = NULL;
d892 2
a893 1
  secname = bfd_get_section_name (s->owner, s);
d895 4
a898 2
  /* Look through the script to see where to place this section.  */ 
  os = lang_output_section_find (secname);
d900 1
a900 3
  if (os != NULL
      && os->bfd_section != NULL
      && ((s->flags ^ os->bfd_section->flags) & (SEC_LOAD | SEC_ALLOC)) == 0)
d903 1
a903 1
      wild_doit (&os->children, s, os, file);
d907 1
a907 2
  if (hold_text.os == NULL)
    hold_text.os = lang_output_section_find (".text");
d914 1
a914 1
      && hold_text.os != NULL)
d916 1
a916 1
      wild_doit (&hold_text.os->children, s, hold_text.os, file);
d925 1
a925 3
#define HAVE_SECTION(hold, name) \
(hold.os != NULL || (hold.os = lang_output_section_find (name)) != NULL)

a927 4

  place = NULL;
  if ((s->flags & SEC_ALLOC) == 0)
    ;
d929 3
a931 3
	   && strncmp (secname, ".note", 4) == 0
	   && HAVE_SECTION (hold_interp, ".interp"))
    place = &hold_interp;
d933 2
a934 2
	   && HAVE_SECTION (hold_bss, ".bss"))
    place = &hold_bss;
d936 2
a937 2
	   && HAVE_SECTION (hold_data, ".data"))
    place = &hold_data;
d939 11
a949 11
	   && (hold_rel.os != NULL
	       || (hold_rel.os = output_rel_find ()) != NULL))
    place = &hold_rel;
  else if ((s->flags & (SEC_CODE | SEC_READONLY)) == SEC_READONLY
	   && HAVE_SECTION (hold_rodata, ".rodata"))
    place = &hold_rodata;
  else if ((s->flags & (SEC_CODE | SEC_READONLY)) == (SEC_CODE | SEC_READONLY)
	   && hold_text.os != NULL)
    place = &hold_text;

#undef HAVE_SECTION
d975 16
a990 2
  /* Start building a list of statements for this section.
     First save the current statement pointer.  */
d992 2
d995 6
a1000 4
  /* If we have found an appropriate place for the output section
     statements for this orphan, add them to our own private list,
     inserting them later into the global statement list.  */
  if (place != NULL)
d1002 1
a1002 3
      stat_ptr = &add;
      lang_list_init (stat_ptr);
    }
d1004 6
a1009 18
  if (config.build_constructors)
    {
      /* If the name of the section is representable in C, then create
	 symbols to mark the start and the end of the section.  */
      for (ps = outsecname; *ps != '\0'; ps++)
	if (! isalnum ((unsigned char) *ps) && *ps != '_')
	  break;
      if (*ps == '\0')
	{
	  char *symname;
	  etree_type *e_align;

	  symname = (char *) xmalloc (ps - outsecname + sizeof "__start_");
	  sprintf (symname, "__start_%s", outsecname);
	  e_align = exp_unop (ALIGN_K,
			      exp_intop ((bfd_vma) 1 << s->alignment_power));
	  lang_add_assignment (exp_assop ('=', symname, e_align));
	}
d1012 3
a1014 1
  if (link_info.relocateable || (s->flags & (SEC_LOAD | SEC_ALLOC)) == 0)
a1015 2
  else
    address = NULL;
d1017 5
a1021 5
  os = lang_enter_output_section_statement (outsecname, address, 0,
					    (bfd_vma) 0,
					    (etree_type *) NULL,
					    (etree_type *) NULL,
					    (etree_type *) NULL);
d1023 1
d1027 3
a1029 2
    ((bfd_vma) 0, "*default*",
     (struct lang_output_section_phdr_list *) NULL, "*default*");
d1031 1
a1031 1
  if (config.build_constructors && *ps == '\0')
a1034 5
      /* lang_leave_ouput_section_statement resets stat_ptr.  Put
	 stat_ptr back where we want it.  */
      if (place != NULL)
	stat_ptr = &add;

d1041 4
a1044 1
  /* Restore the global list pointer.  */
d1047 2
a1048 3
  if (place != NULL)
    {
      asection *snew, **pps;
d1050 5
a1054 23
      snew = os->bfd_section;
      if (place->section != NULL
	  || (place->os->bfd_section != NULL
	      && place->os->bfd_section != snew))
	{
	  /* Shuffle the section to make the output file look neater.
	     This is really only cosmetic.  */
	  if (place->section == NULL)
	    {
#if 0
	      /* Finding the end of the list is a little tricky.  We
		 make a wild stab at it by comparing section flags.  */
	      flagword first_flags = place->os->bfd_section->flags;
	      for (pps = &place->os->bfd_section->next;
		   *pps != NULL && (*pps)->flags == first_flags;
		   pps = &(*pps)->next)
		;
	      place->section = pps;
#else
	      /* Put orphans after the first section on the list.  */
	      place->section = &place->os->bfd_section->next;
#endif
	    }
d1056 2
a1057 28
	  /*  Unlink the section.  */
	  for (pps = &output_bfd->sections; *pps != snew; pps = &(*pps)->next)
	    ;
	  *pps = snew->next;

	  /* Now tack it on to the "place->os" section list.  */
	  snew->next = *place->section;
	  *place->section = snew;
	}
      place->section = &snew->next;	/* Save the end of this list.  */

      if (add.head != NULL)
	{
	  /* We try to put the output statements in some sort of
	     reasonable order here, because they determine the final
	     load addresses of the orphan sections.  */
	  if (place->stmt == NULL)
	    {
	      /* Put the new statement list right at the head.  */
	      *add.tail = place->os->header.next;
	      place->os->header.next = add.head;
	    }
	  else
	    {
	      /* Put it after the last orphan statement we added.  */
	      *add.tail = *place->stmt;
	      *place->stmt = add.head;
	    }
d1059 1
a1059 4
	  /* Fix the global list pointer if we happened to tack our
	     new list at the tail.  */
	  if (*old->tail == add.head)
	    old->tail = add.tail;
d1061 21
a1081 6
	  /* Save the end of this list.  */
	  place->stmt = add.tail;
	}
    }

  return true;
@


1.11
log
@Add LMA memory region functionality.
@
text
@d1184 2
a1185 1
  NULL		/* recognized_file */
@


1.10
log
@Wed Nov  3 23:31:19 1999  Jeffrey A Law  (law@@cygnus.com)

        * emultempl/elf32.em (gld${EMULATION_NAME}_open_dynamic_archive):
        Clean up code to use EXTRA_SHLIB_EXTENSION.

1999-09-14  Ulrich Drepper  <drepper@@cygnus.com>

        * configure.in: Define EXTRA_SHLIB_EXTENSION to ".sl" for HP target.
        * config.in: Add EXTRA_SHLIB_EXTENSION.

        * emultempl/elf32.em (gld${EMULATION_NAME}_open_dynamic_archive):
        Search for second shared lib extension only if EXTRA_SHLIB_EXTENSION
        is defined.
@
text
@d1027 2
a1028 1
    ((bfd_vma) 0, "*default*", (struct lang_output_section_phdr_list *) NULL);
@


1.9
log
@Fix typo in last change.
@
text
@d98 3
d104 3
d111 8
d121 2
a122 9
      /* It failed using .so, try again with .sl for oddball systems
	 that use a different naming scheme (ie hpux).  */
      sprintf (string, "%s/lib%s%s.sl", search->name, filename, arch);

      if (! ldfile_try_open_bfd (string, entry))
	{
	  free (string);
	  return false;
	}
d143 1
a143 1
      char *filname, *needed_name;
d148 1
a148 1
	 filename we recorded earlier.o
@


1.8
log
@        * emultempl/elf32.em (gld${EMULATION_NAME}_open_dynamic_archive):
        Use the same filename extension for the bfd_elf_dt_needed_name call
        as we did for finding the library.
@
text
@d147 1
a147 1
      needed_name = (char *) xmalloc (strlen (filename)) + 1;
@


1.7
log
@        * emultempl/elf32.em (gld${EMULATION_NAME}_open_dynamic_archive):
        Search for file with .sl extension if no file with a .so extension
        is found.
@
text
@d136 1
a136 1
      char *needed_name;
d139 10
a148 4
      needed_name = (char *) xmalloc (strlen (filename)
				      + strlen (arch)
				      + sizeof "lib.so");
      sprintf (needed_name, "lib%s%s.so", filename, arch);
@


1.6
log
@Add ability for individual targets to have their own command line switches by
defining PARSE_AND_LIST_ARGS.
@
text
@d81 2
a82 1
   dynamic libraries have an extension of .so.  */
d107 9
a115 2
      free (string);
      return false;
@


1.5
log
@	* emultempl/ostring.sed: Rename from stringify.sed.
	* emultempl/astring.sed: New file.
	* Makefile.am (stringify.sed): New target.
	(GEN_DEPENDS): Change $(srcdir)/emultempl/stringify.sed to
	stringify.sed.
	* configure.in: Define and substitute STRINGIFY.
	* emultempl/*.em: Use stringify.sed from build directory rather
	than source directory.
	* emultempl/elf32.em: Use stringify.sed rather than inline sed
	script.
	* emultempl/gld960.em, emultempl/gld960c.em: Likewise.
	* emultempl/hppaelf.em, emultempl/linux.em: Likewise.
	* emultempl/lnk960.em, emultempl/sunos.em: Likewise.
	* configure, Makefile.in: Rebuild.
@
text
@d1122 16
d1154 2
a1155 2
  NULL,
  NULL,
d1159 1
a1159 1
  NULL,		/* parse_args */
d1161 1
a1161 1
  NULL,		/* list_options */
@


1.4
log
@	* emultempl/elf32.em (ld_${EMULATION_NAME}_emulation): Add missing
	comma in initializer.
@
text
@d1072 1
a1072 5
sc='s/["\\]/\\&/g
s/$/\\n\\/
1s/^/"/
$s/$/n"/
'
d1079 1
a1079 7
    return `sed "$sc" ldscripts/${EMULATION_NAME}.xu`;
  else if (link_info.relocateable == true)
    return `sed "$sc" ldscripts/${EMULATION_NAME}.xr`;
  else if (!config.text_read_only)
    return `sed "$sc" ldscripts/${EMULATION_NAME}.xbn`;
  else if (!config.magic_demand_paged)
    return `sed "$sc" ldscripts/${EMULATION_NAME}.xn`;
d1081 7
d1090 2
a1091 4
cat >>e${EMULATION_NAME}.c <<EOF
  else if (link_info.shared)
    return `sed "$sc" ldscripts/${EMULATION_NAME}.xs`;
EOF
d1094 3
a1096 5
cat >>e${EMULATION_NAME}.c <<EOF
  else
    return `sed "$sc" ldscripts/${EMULATION_NAME}.x`;
}
EOF
@


1.3
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Fill in structure initializations.
@
text
@d1148 1
a1148 1
  gld${EMULATION_NAME}_place_orphan
@


1.2
log
@        * emultempl/armelf.em: Watch EMULATION_LIBPATH instead of
        DEFAULT_EMULATION.
        * emultempl/elf32.em: Likewise.
        * emultempl/sunos.em: Likewise.
@
text
@d10 2
a11 1
   Copyright (C) 1991, 93, 94, 95, 96, 97, 1998 Free Software Foundation, Inc.
d1149 5
@


1.1
log
@Initial revision
@
text
@d142 2
a143 1
  if [ "x${DEFAULT_EMULATION}" = "x${EMULATION_NAME}" ] ; then
d228 2
a229 1
  fi
d314 2
a315 1
  if [ "x${DEFAULT_EMULATION}" = "x${EMULATION_NAME}" ] ; then
d321 2
a322 1
  fi
d342 2
a343 1
  if [ "x${DEFAULT_EMULATION}" = "x${EMULATION_NAME}" ] ; then
d348 2
a349 1
  fi
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

