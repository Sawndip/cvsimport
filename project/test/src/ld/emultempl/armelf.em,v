head	1.88;
access;
symbols
	binutils-2_24-branch:1.88.0.2
	binutils-2_24-branchpoint:1.88
	binutils-2_21_1:1.79
	binutils-2_23_2:1.86.2.1
	binutils-2_23_1:1.86
	binutils-2_23:1.86
	binutils-2_23-branch:1.86.0.2
	binutils-2_23-branchpoint:1.86
	binutils-2_22_branch:1.82.0.4
	binutils-2_22:1.82
	binutils-2_22-branch:1.82.0.2
	binutils-2_22-branchpoint:1.82
	binutils-2_21:1.79
	binutils-2_21-branch:1.79.0.2
	binutils-2_21-branchpoint:1.79
	binutils-2_20_1:1.76
	binutils-2_20:1.76
	binutils-arc-20081103-branch:1.68.0.4
	binutils-arc-20081103-branchpoint:1.68
	binutils-2_20-branch:1.76.0.2
	binutils-2_20-branchpoint:1.76
	dje-cgen-play1-branch:1.74.0.2
	dje-cgen-play1-branchpoint:1.74
	arc-20081103-branch:1.68.0.2
	arc-20081103-branchpoint:1.68
	binutils-2_19_1:1.66
	binutils-2_19:1.66
	binutils-2_19-branch:1.66.0.2
	binutils-2_19-branchpoint:1.66
	binutils-2_18:1.57
	binutils-2_18-branch:1.57.0.2
	binutils-2_18-branchpoint:1.57
	binutils-csl-coldfire-4_1-32:1.49.2.1
	binutils-csl-sourcerygxx-4_1-32:1.49.2.1
	binutils-csl-innovasic-fido-3_4_4-33:1.49.2.1
	binutils-csl-sourcerygxx-3_4_4-32:1.44
	binutils-csl-coldfire-4_1-30:1.49.2.1
	binutils-csl-sourcerygxx-4_1-30:1.49.2.1
	binutils-csl-coldfire-4_1-28:1.49.2.1
	binutils-csl-sourcerygxx-4_1-29:1.49.2.1
	binutils-csl-sourcerygxx-4_1-28:1.49.2.1
	binutils-csl-arm-2006q3-27:1.49.2.1
	binutils-csl-sourcerygxx-4_1-27:1.49.2.1
	binutils-csl-arm-2006q3-26:1.49.2.1
	binutils-csl-sourcerygxx-4_1-26:1.49.2.1
	binutils-csl-sourcerygxx-4_1-25:1.49.2.1
	binutils-csl-sourcerygxx-4_1-24:1.49.2.1
	binutils-csl-sourcerygxx-4_1-23:1.49.2.1
	binutils-csl-sourcerygxx-4_1-21:1.49.2.1
	binutils-csl-arm-2006q3-21:1.49.2.1
	binutils-csl-sourcerygxx-4_1-22:1.49.2.1
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.49.2.1
	binutils-csl-sourcerygxx-4_1-20:1.49.2.1
	binutils-csl-arm-2006q3-19:1.49.2.1
	binutils-csl-sourcerygxx-4_1-19:1.49.2.1
	binutils-csl-sourcerygxx-4_1-18:1.49.2.1
	binutils-csl-renesas-4_1-9:1.49.2.1
	binutils-csl-sourcerygxx-3_4_4-25:1.44
	binutils-csl-renesas-4_1-8:1.49.2.1
	binutils-csl-renesas-4_1-7:1.49
	binutils-csl-renesas-4_1-6:1.49
	binutils-csl-sourcerygxx-4_1-17:1.49
	binutils-csl-sourcerygxx-4_1-14:1.49
	binutils-csl-sourcerygxx-4_1-15:1.49
	binutils-csl-sourcerygxx-4_1-13:1.49
	binutils-2_17:1.49
	binutils-csl-sourcerygxx-4_1-12:1.49
	binutils-csl-sourcerygxx-3_4_4-21:1.49
	binutils-csl-wrs-linux-3_4_4-24:1.44
	binutils-csl-wrs-linux-3_4_4-23:1.44
	binutils-csl-sourcerygxx-4_1-9:1.49
	binutils-csl-sourcerygxx-4_1-8:1.49
	binutils-csl-sourcerygxx-4_1-7:1.49
	binutils-csl-arm-2006q1-6:1.49
	binutils-csl-sourcerygxx-4_1-6:1.49
	binutils-csl-wrs-linux-3_4_4-22:1.44
	binutils-csl-coldfire-4_1-11:1.49
	binutils-csl-sourcerygxx-3_4_4-19:1.49
	binutils-csl-coldfire-4_1-10:1.49
	binutils-csl-sourcerygxx-4_1-5:1.49
	binutils-csl-sourcerygxx-4_1-4:1.49
	binutils-csl-wrs-linux-3_4_4-21:1.44
	binutils-csl-morpho-4_1-4:1.49
	binutils-csl-sourcerygxx-3_4_4-17:1.49
	binutils-csl-wrs-linux-3_4_4-20:1.44
	binutils-2_17-branch:1.49.0.4
	binutils-2_17-branchpoint:1.49
	binutils-csl-2_17-branch:1.49.0.2
	binutils-csl-2_17-branchpoint:1.49
	binutils-csl-gxxpro-3_4-branch:1.44.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.44
	binutils-2_16_1:1.44
	binutils-csl-arm-2005q1b:1.44
	binutils-2_16:1.44
	binutils-csl-arm-2005q1a:1.44
	binutils-csl-arm-2005q1-branch:1.44.0.4
	binutils-csl-arm-2005q1-branchpoint:1.44
	binutils-2_16-branch:1.44.0.2
	binutils-2_16-branchpoint:1.44
	csl-arm-2004-q3d:1.40
	csl-arm-2004-q3:1.40
	binutils-2_15:1.36
	binutils-2_15-branchpoint:1.36
	csl-arm-2004-q1a:1.37
	csl-arm-2004-q1:1.37
	binutils-2_15-branch:1.36.0.6
	cagney_bfdfile-20040213-branch:1.36.0.4
	cagney_bfdfile-20040213-branchpoint:1.36
	cagney_bigcore-20040122-branch:1.36.0.2
	cagney_bigcore-20040122-branchpoint:1.36
	csl-arm-2003-q4:1.35
	binutils-2_14:1.33.2.1
	binutils-2_14-branch:1.33.0.2
	binutils-2_14-branchpoint:1.33
	binutils-2_13_2_1:1.27.2.1
	binutils-2_13_2:1.27.2.1
	binutils-2_13_1:1.27.2.1
	binutils-2_13:1.27
	binutils-2_13-branchpoint:1.27
	binutils-2_13-branch:1.27.0.2
	binutils-2_12_1:1.24.2.1
	binutils-2_12:1.24
	binutils-2_12-branch:1.24.0.2
	binutils-2_12-branchpoint:1.24
	cygnus_cvs_20020108_pre:1.24
	binutils-2_11_2:1.21.2.1
	binutils-2_11_1:1.21.2.1
	binutils-2_11:1.21
	x86_64versiong3:1.21
	binutils-2_11-branch:1.21.0.2
	binutils-2_10_1:1.14
	binutils-2_10:1.14
	binutils-2_10-branch:1.14.0.2
	binutils-2_10-branchpoint:1.14
	binutils_latest_snapshot:1.88
	repo-unification-2000-02-06:1.12
	binu_ss_19990721:1.8
	binu_ss_19990602:1.4
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@# @;


1.88
date	2013.07.18.11.24.08;	author nickc;	state Exp;
branches;
next	1.87;

1.87
date	2012.11.26.23.26.35;	author roland;	state Exp;
branches;
next	1.86;

1.86
date	2012.05.14.19.45.28;	author jwlemke;	state Exp;
branches
	1.86.2.1;
next	1.85;

1.85
date	2012.04.24.05.12.40;	author amodra;	state Exp;
branches;
next	1.84;

1.84
date	2012.03.05.22.43.40;	author amodra;	state Exp;
branches;
next	1.83;

1.83
date	2011.11.25.15.04.09;	author nickc;	state Exp;
branches;
next	1.82;

1.82
date	2011.08.09.13.10.44;	author mgretton;	state Exp;
branches
	1.82.2.1;
next	1.81;

1.81
date	2011.03.14.15.55.03;	author rsandifo;	state Exp;
branches;
next	1.80;

1.80
date	2011.03.14.15.53.58;	author rsandifo;	state Exp;
branches;
next	1.79;

1.79
date	2010.04.21.16.32.31;	author aph;	state Exp;
branches;
next	1.78;

1.78
date	2010.02.05.13.57.47;	author nickc;	state Exp;
branches;
next	1.77;

1.77
date	2009.09.25.19.13.27;	author nickc;	state Exp;
branches;
next	1.76;

1.76
date	2009.09.02.07.25.35;	author amodra;	state Exp;
branches;
next	1.75;

1.75
date	2009.08.10.07.50.56;	author amodra;	state Exp;
branches;
next	1.74;

1.74
date	2009.06.12.14.27.21;	author pb;	state Exp;
branches;
next	1.73;

1.73
date	2009.05.22.11.58.45;	author jules;	state Exp;
branches;
next	1.72;

1.72
date	2009.05.05.14.18.30;	author pbrook;	state Exp;
branches;
next	1.71;

1.71
date	2009.04.21.22.05.03;	author drow;	state Exp;
branches;
next	1.70;

1.70
date	2009.02.24.22.43.09;	author drow;	state Exp;
branches;
next	1.69;

1.69
date	2009.01.29.16.36.45;	author jsm28;	state Exp;
branches;
next	1.68;

1.68
date	2008.10.22.14.23.44;	author nickc;	state Exp;
branches;
next	1.67;

1.67
date	2008.10.21.22.20.29;	author amodra;	state Exp;
branches;
next	1.66;

1.66
date	2008.08.26.11.11.17;	author nickc;	state Exp;
branches;
next	1.65;

1.65
date	2008.07.18.20.49.12;	author jsm28;	state Exp;
branches;
next	1.64;

1.64
date	2008.07.07.00.46.51;	author amodra;	state Exp;
branches;
next	1.63;

1.63
date	2008.05.28.15.38.36;	author nickc;	state Exp;
branches;
next	1.62;

1.62
date	2008.05.15.17.00.15;	author nickc;	state Exp;
branches;
next	1.61;

1.61
date	2008.02.20.15.17.56;	author pbrook;	state Exp;
branches;
next	1.60;

1.60
date	2008.02.15.03.35.53;	author amodra;	state Exp;
branches;
next	1.59;

1.59
date	2007.10.04.13.35.18;	author nickc;	state Exp;
branches;
next	1.58;

1.58
date	2007.08.17.13.50.48;	author amodra;	state Exp;
branches;
next	1.57;

1.57
date	2007.07.19.19.56.10;	author roland;	state Exp;
branches;
next	1.56;

1.56
date	2007.07.06.14.09.42;	author nickc;	state Exp;
branches;
next	1.55;

1.55
date	2007.03.20.20.19.07;	author pbrook;	state Exp;
branches;
next	1.54;

1.54
date	2007.03.20.14.24.57;	author shinwell;	state Exp;
branches;
next	1.53;

1.53
date	2007.01.29.16.28.40;	author jules;	state Exp;
branches;
next	1.52;

1.52
date	2006.11.13.20.39.21;	author drow;	state Exp;
branches;
next	1.51;

1.51
date	2006.10.23.03.07.49;	author amodra;	state Exp;
branches;
next	1.50;

1.50
date	2006.08.18.15.00.18;	author pbrook;	state Exp;
branches;
next	1.49;

1.49
date	2006.02.07.03.50.20;	author pbrook;	state Exp;
branches
	1.49.2.1;
next	1.48;

1.48
date	2005.11.17.00.10.05;	author amodra;	state Exp;
branches;
next	1.47;

1.47
date	2005.06.16.09.46.10;	author nickc;	state Exp;
branches;
next	1.46;

1.46
date	2005.05.12.07.32.03;	author nickc;	state Exp;
branches;
next	1.45;

1.45
date	2005.04.15.16.37.47;	author jules;	state Exp;
branches;
next	1.44;

1.44
date	2005.03.03.11.52.04;	author amodra;	state Exp;
branches;
next	1.43;

1.43
date	2005.01.28.17.24.41;	author jules;	state Exp;
branches;
next	1.42;

1.42
date	2004.11.30.17.45.54;	author pbrook;	state Exp;
branches;
next	1.41;

1.41
date	2004.11.17.17.50.27;	author drow;	state Exp;
branches;
next	1.40;

1.40
date	2004.09.17.12.18.18;	author pbrook;	state Exp;
branches;
next	1.39;

1.39
date	2004.09.13.14.14.32;	author pbrook;	state Exp;
branches;
next	1.38;

1.38
date	2004.05.25.06.33.50;	author amodra;	state Exp;
branches;
next	1.37;

1.37
date	2004.04.01.11.20.04;	author pbrook;	state Exp;
branches;
next	1.36;

1.36
date	2004.01.03.11.09.07;	author amodra;	state Exp;
branches;
next	1.35;

1.35
date	2003.06.27.00.38.25;	author amodra;	state Exp;
branches;
next	1.34;

1.34
date	2003.05.30.08.19.30;	author nickc;	state Exp;
branches;
next	1.33;

1.33
date	2003.02.28.01.32.31;	author amodra;	state Exp;
branches
	1.33.2.1;
next	1.32;

1.32
date	2003.02.07.15.32.22;	author nickc;	state Exp;
branches;
next	1.31;

1.31
date	2002.11.30.08.39.46;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2002.08.27.11.01.53;	author nickc;	state Exp;
branches;
next	1.29;

1.29
date	2002.08.22.19.11.51;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	2002.08.07.15.22.41;	author nickc;	state Exp;
branches;
next	1.27;

1.27
date	2002.07.01.08.07.31;	author amodra;	state Exp;
branches
	1.27.2.1;
next	1.26;

1.26
date	2002.05.29.16.02.57;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	2002.04.11.16.55.27;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	2001.11.15.12.44.03;	author amodra;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2001.11.15.07.12.48;	author hjl;	state Exp;
branches;
next	1.22;

1.22
date	2001.03.13.06.14.27;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2000.07.28.01.33.14;	author amodra;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2000.07.11.03.42.41;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2000.04.25.05.14.16;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2000.04.18.23.39.03;	author hjl;	state Exp;
branches;
next	1.17;

1.17
date	2000.04.18.05.53.41;	author amodra;	state Exp;
branches;
next	1.16;

1.16
date	2000.04.14.01.58.29;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2000.04.12.02.43.37;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2000.02.29.05.53.53;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2000.02.16.18.53.32;	author twall;	state Exp;
branches;
next	1.12;

1.12
date	2000.01.22.23.22.17;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	99.10.27.18.13.28;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	99.10.26.12.13.20;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	99.08.06.22.46.03;	author ian;	state Exp;
branches;
next	1.8;

1.8
date	99.07.05.07.51.39;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	99.06.29.02.45.00;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	99.06.21.03.30.32;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	99.06.20.14.12.06;	author rth;	state Exp;
branches;
next	1.4;

1.4
date	99.05.29.10.57.43;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	99.05.24.12.49.28;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	99.05.22.09.55.50;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.29.07;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.86.2.1
date	2012.11.29.22.56.52;	author roland;	state Exp;
branches;
next	1.86.2.2;

1.86.2.2
date	2013.07.18.21.48.09;	author roland;	state Exp;
branches;
next	;

1.82.2.1
date	2012.05.11.12.24.39;	author nickc;	state Exp;
branches;
next	;

1.49.2.1
date	2006.08.18.15.01.16;	author pbrook;	state Exp;
branches;
next	;

1.33.2.1
date	2003.05.31.09.46.35;	author nickc;	state Exp;
branches;
next	;

1.27.2.1
date	2002.09.23.22.15.59;	author drow;	state Exp;
branches;
next	;

1.24.2.1
date	2002.05.10.10.08.53;	author nickc;	state Exp;
branches;
next	;

1.21.2.1
date	2001.06.07.03.17.16;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.29.07;	author rth;	state Exp;
branches;
next	;


desc
@@


1.88
log
@	* elf32-arm.c (elf32_arm_stub_long_branch_arm_nacl): New variable.
	(elf32_arm_stub_long_branch_arm_nacl_pic): New variable.
	(arm_build_one_stub): Increase MAXRELOCS to 3.
	(arm_type_of_stub): Use them if GLOBALS->nacl_p.
	(struct elf32_arm_link_hash_table): Give add_stub_section member's
	pointee type a third argument.
	(elf32_arm_create_or_find_stub_sec): Update caller.
	(elf32_arm_size_stubs): Update argument type.
	* bfd-in.h (elf32_arm_size_stubs): Update decl.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.

	* emultempl/armelf.em (elf32_arm_add_stub_section): Take third
	argument ALIGNMENT_POWER, use it instead of constant 3.

	* ld-arm/farcall-arm-nacl.d: New file.
	* ld-arm/farcall-arm-nacl-pic.d: New file.
	* ld-arm/farcall-data-nacl.d: New file.
	* ld-arm/arm-elf.exp (armeabitests_common): Add extra element to
	"action" lists for those cases to use a different dump file for NaCl
	targets.
	Massage $armeabitests_common to drop the extra element or the one
	before it, depending on [istarget "arm*-*-nacl*"].

	* ld-arm/arm-elf.exp (armelftests_common): Move all "Cortex-A8
	erratum fix", Thumb-only and interworking cases to ...
	(armelftests_nonacl): ... here.
	(armeabitests_common): Move all "erratum 760522 fix", Thumb-only
	and interworking cases to ...
	(armeabitests_nonacl): ... here.
@
text
@# This shell script emits a C file. -*- C -*-
#   Copyright 1991-2013 Free Software Foundation, Inc.
#
# This file is part of the GNU Binutils.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
# MA 02110-1301, USA.
#

# This file is sourced from elf32.em, and defines extra arm-elf
# specific routines.
#
test -z "$TARGET2_TYPE" && TARGET2_TYPE="rel"
fragment <<EOF

#include "ldctor.h"
#include "elf/arm.h"

static char *thumb_entry_symbol = NULL;
static int byteswap_code = 0;
static int target1_is_rel = 0${TARGET1_IS_REL};
static char *target2_type = "${TARGET2_TYPE}";
static int fix_v4bx = 0;
static int use_blx = 0;
static bfd_arm_vfp11_fix vfp11_denorm_fix = BFD_ARM_VFP11_FIX_DEFAULT;
static int fix_cortex_a8 = -1;
static int no_enum_size_warning = 0;
static int no_wchar_size_warning = 0;
static int pic_veneer = 0;
static int merge_exidx_entries = -1;
static int fix_arm1176 = 1;

static void
gld${EMULATION_NAME}_before_parse (void)
{
#ifndef TARGET_			/* I.e., if not generic.  */
  ldfile_set_output_arch ("`echo ${ARCH}`", bfd_arch_unknown);
#endif /* not TARGET_ */
  input_flags.dynamic = ${DYNAMIC_LINK-TRUE};
  config.has_shared = `if test -n "$GENERATE_SHLIB_SCRIPT" ; then echo TRUE ; else echo FALSE ; fi`;
  config.separate_code = `if test "x${SEPARATE_CODE}" = xyes ; then echo TRUE ; else echo FALSE ; fi`;
}

static void
arm_elf_before_allocation (void)
{
  bfd_elf32_arm_set_byteswap_code (&link_info, byteswap_code);

  /* Choose type of VFP11 erratum fix, or warn if specified fix is unnecessary
     due to architecture version.  */
  bfd_elf32_arm_set_vfp11_fix (link_info.output_bfd, &link_info);

  /* Auto-select Cortex-A8 erratum fix if it wasn't explicitly specified.  */
  bfd_elf32_arm_set_cortex_a8_fix (link_info.output_bfd, &link_info);

  /* We should be able to set the size of the interworking stub section.  We
     can't do it until later if we have dynamic sections, though.  */
  if (elf_hash_table (&link_info)->dynobj == NULL)
    {
      /* Here we rummage through the found bfds to collect glue information.  */
      LANG_FOR_EACH_INPUT_STATEMENT (is)
	{
          /* Initialise mapping tables for code/data.  */
          bfd_elf32_arm_init_maps (is->the_bfd);

	  if (!bfd_elf32_arm_process_before_allocation (is->the_bfd,
							&link_info)
	      || !bfd_elf32_arm_vfp11_erratum_scan (is->the_bfd, &link_info))
	    /* xgettext:c-format */
	    einfo (_("Errors encountered processing file %s"), is->filename);
	}

      /* We have seen it all.  Allocate it, and carry on.  */
      bfd_elf32_arm_allocate_interworking_sections (& link_info);
    }

  /* Call the standard elf routine.  */
  gld${EMULATION_NAME}_before_allocation ();
}

/* Fake input file for stubs.  */
static lang_input_statement_type *stub_file;

/* Whether we need to call gldarm_layout_sections_again.  */
static int need_laying_out = 0;

/* Maximum size of a group of input sections that can be handled by
   one stub section.  A value of +/-1 indicates the bfd back-end
   should use a suitable default size.  */
static bfd_signed_vma group_size = 1;

struct hook_stub_info
{
  lang_statement_list_type add;
  asection *input_section;
};

/* Traverse the linker tree to find the spot where the stub goes.  */

static bfd_boolean
hook_in_stub (struct hook_stub_info *info, lang_statement_union_type **lp)
{
  lang_statement_union_type *l;
  bfd_boolean ret;

  for (; (l = *lp) != NULL; lp = &l->header.next)
    {
      switch (l->header.type)
	{
	case lang_constructors_statement_enum:
	  ret = hook_in_stub (info, &constructor_list.head);
	  if (ret)
	    return ret;
	  break;

	case lang_output_section_statement_enum:
	  ret = hook_in_stub (info,
			      &l->output_section_statement.children.head);
	  if (ret)
	    return ret;
	  break;

	case lang_wild_statement_enum:
	  ret = hook_in_stub (info, &l->wild_statement.children.head);
	  if (ret)
	    return ret;
	  break;

	case lang_group_statement_enum:
	  ret = hook_in_stub (info, &l->group_statement.children.head);
	  if (ret)
	    return ret;
	  break;

	case lang_input_section_enum:
	  if (l->input_section.section == info->input_section)
	    {
	      /* We've found our section.  Insert the stub immediately
		 after its associated input section.  */
	      *(info->add.tail) = l->header.next;
	      l->header.next = info->add.head;
	      return TRUE;
	    }
	  break;

	case lang_data_statement_enum:
	case lang_reloc_statement_enum:
	case lang_object_symbols_statement_enum:
	case lang_output_statement_enum:
	case lang_target_statement_enum:
	case lang_input_statement_enum:
	case lang_assignment_statement_enum:
	case lang_padding_statement_enum:
	case lang_address_statement_enum:
	case lang_fill_statement_enum:
	  break;

	default:
	  FAIL ();
	  break;
	}
    }
  return FALSE;
}


/* Call-back for elf32_arm_size_stubs.  */

/* Create a new stub section, and arrange for it to be linked
   immediately after INPUT_SECTION.  */

static asection *
elf32_arm_add_stub_section (const char * stub_sec_name,
			    asection *   input_section,
			    unsigned int alignment_power)
{
  asection *stub_sec;
  flagword flags;
  asection *output_section;
  const char *secname;
  lang_output_section_statement_type *os;
  struct hook_stub_info info;

  flags = (SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_CODE
	   | SEC_HAS_CONTENTS | SEC_RELOC | SEC_IN_MEMORY | SEC_KEEP);
  stub_sec = bfd_make_section_anyway_with_flags (stub_file->the_bfd,
						 stub_sec_name, flags);
  if (stub_sec == NULL)
    goto err_ret;

  bfd_set_section_alignment (stub_file->the_bfd, stub_sec, alignment_power);

  output_section = input_section->output_section;
  secname = bfd_get_section_name (output_section->owner, output_section);
  os = lang_output_section_find (secname);

  info.input_section = input_section;
  lang_list_init (&info.add);
  lang_add_section (&info.add, stub_sec, NULL, os);

  if (info.add.head == NULL)
    goto err_ret;

  if (hook_in_stub (&info, &os->children.head))
    return stub_sec;

 err_ret:
  einfo ("%X%P: can not make stub section: %E\n");
  return NULL;
}

/* Another call-back for elf_arm_size_stubs.  */

static void
gldarm_layout_sections_again (void)
{
  /* If we have changed sizes of the stub sections, then we need
     to recalculate all the section offsets.  This may mean we need to
     add even more stubs.  */
  gld${EMULATION_NAME}_map_segments (TRUE);
  need_laying_out = -1;
}

static void
build_section_lists (lang_statement_union_type *statement)
{
  if (statement->header.type == lang_input_section_enum)
    {
      asection *i = statement->input_section.section;

      if (i->sec_info_type != SEC_INFO_TYPE_JUST_SYMS
	  && (i->flags & SEC_EXCLUDE) == 0
	  && i->output_section != NULL
	  && i->output_section->owner == link_info.output_bfd)
	elf32_arm_next_input_section (& link_info, i);
    }
}

static int
compare_output_sec_vma (const void *a, const void *b)
{
  asection *asec = *(asection **) a, *bsec = *(asection **) b;
  asection *aout = asec->output_section, *bout = bsec->output_section;
  bfd_vma avma, bvma;

  /* If there's no output section for some reason, compare equal.  */
  if (!aout || !bout)
    return 0;

  avma = aout->vma + asec->output_offset;
  bvma = bout->vma + bsec->output_offset;

  if (avma > bvma)
    return 1;
  else if (avma < bvma)
    return -1;

  return 0;
}

static void
gld${EMULATION_NAME}_after_allocation (void)
{
  if (!link_info.relocatable)
    {
      /* Build a sorted list of input text sections, then use that to process
	 the unwind table index.  */
      unsigned int list_size = 10;
      asection **sec_list = (asection **)
          xmalloc (list_size * sizeof (asection *));
      unsigned int sec_count = 0;

      LANG_FOR_EACH_INPUT_STATEMENT (is)
	{
	  bfd *abfd = is->the_bfd;
	  asection *sec;

	  if ((abfd->flags & (EXEC_P | DYNAMIC)) != 0)
	    continue;

	  for (sec = abfd->sections; sec != NULL; sec = sec->next)
	    {
	      asection *out_sec = sec->output_section;

	      if (out_sec
		  && elf_section_data (sec)
		  && elf_section_type (sec) == SHT_PROGBITS
		  && (elf_section_flags (sec) & SHF_EXECINSTR) != 0
		  && (sec->flags & SEC_EXCLUDE) == 0
		  && sec->sec_info_type != SEC_INFO_TYPE_JUST_SYMS
		  && out_sec != bfd_abs_section_ptr)
		{
		  if (sec_count == list_size)
		    {
		      list_size *= 2;
		      sec_list = (asection **)
                          xrealloc (sec_list, list_size * sizeof (asection *));
		    }

		  sec_list[sec_count++] = sec;
		}
	    }
	}

      qsort (sec_list, sec_count, sizeof (asection *), &compare_output_sec_vma);

      if (elf32_arm_fix_exidx_coverage (sec_list, sec_count, &link_info,
					   merge_exidx_entries))
	need_laying_out = 1;

      free (sec_list);
    }

  /* bfd_elf32_discard_info just plays with debugging sections,
     ie. doesn't affect any code, so we can delay resizing the
     sections.  It's likely we'll resize everything in the process of
     adding stubs.  */
  if (bfd_elf_discard_info (link_info.output_bfd, & link_info))
    need_laying_out = 1;

  /* If generating a relocatable output file, then we don't
     have to examine the relocs.  */
  if (stub_file != NULL && !link_info.relocatable)
    {
      int  ret = elf32_arm_setup_section_lists (link_info.output_bfd, & link_info);

      if (ret != 0)
	{
	  if (ret < 0)
	    {
	      einfo ("%X%P: could not compute sections lists for stub generation: %E\n");
	      return;
	    }

	  lang_for_each_statement (build_section_lists);

	  /* Call into the BFD backend to do the real work.  */
	  if (! elf32_arm_size_stubs (link_info.output_bfd,
				      stub_file->the_bfd,
				      & link_info,
				      group_size,
				      & elf32_arm_add_stub_section,
				      & gldarm_layout_sections_again))
	    {
	      einfo ("%X%P: cannot size stub section: %E\n");
	      return;
	    }
	}
    }

  if (need_laying_out != -1)
    gld${EMULATION_NAME}_map_segments (need_laying_out);
}

static void
gld${EMULATION_NAME}_finish (void)
{
  struct bfd_link_hash_entry * h;

  {
    LANG_FOR_EACH_INPUT_STATEMENT (is)
      {
        /* Figure out where VFP11 erratum veneers (and the labels returning
           from same) have been placed.  */
        bfd_elf32_arm_vfp11_fix_veneer_locations (is->the_bfd, &link_info);
      }
  }

  if (! link_info.relocatable)
    {
      /* Now build the linker stubs.  */
      if (stub_file->the_bfd->sections != NULL)
	{
	  if (! elf32_arm_build_stubs (& link_info))
	    einfo ("%X%P: can not build stubs: %E\n");
	}
    }

  finish_default ();

  if (thumb_entry_symbol)
    {
      h = bfd_link_hash_lookup (link_info.hash, thumb_entry_symbol,
				FALSE, FALSE, TRUE);
    }
  else
    {
      struct elf_link_hash_entry * eh;

      if (!entry_symbol.name)
	return;

      h = bfd_link_hash_lookup (link_info.hash, entry_symbol.name,
				FALSE, FALSE, TRUE);
      eh = (struct elf_link_hash_entry *)h;
      if (!h || eh->target_internal != ST_BRANCH_TO_THUMB)
	return;
    }


  if (h != (struct bfd_link_hash_entry *) NULL
      && (h->type == bfd_link_hash_defined
	  || h->type == bfd_link_hash_defweak)
      && h->u.def.section->output_section != NULL)
    {
      static char buffer[32];
      bfd_vma val;

      /* Special procesing is required for a Thumb entry symbol.  The
	 bottom bit of its address must be set.  */
      val = (h->u.def.value
	     + bfd_get_section_vma (link_info.output_bfd,
				    h->u.def.section->output_section)
	     + h->u.def.section->output_offset);

      val |= 1;

      /* Now convert this value into a string and store it in entry_symbol
	 where the lang_finish() function will pick it up.  */
      buffer[0] = '0';
      buffer[1] = 'x';

      sprintf_vma (buffer + 2, val);

      if (thumb_entry_symbol != NULL && entry_symbol.name != NULL
	  && entry_from_cmdline)
	einfo (_("%P: warning: '--thumb-entry %s' is overriding '-e %s'\n"),
	       thumb_entry_symbol, entry_symbol.name);
      entry_symbol.name = buffer;
    }
  else
    einfo (_("%P: warning: cannot find thumb start symbol %s\n"),
	   thumb_entry_symbol);
}

/* This is a convenient point to tell BFD about target specific flags.
   After the output has been created, but before inputs are read.  */
static void
arm_elf_create_output_section_statements (void)
{
  if (strstr (bfd_get_target (link_info.output_bfd), "arm") == NULL)
    {
      /* The arm backend needs special fields in the output hash structure.
	 These will only be created if the output format is an arm format,
	 hence we do not support linking and changing output formats at the
	 same time.  Use a link followed by objcopy to change output formats.  */
      einfo ("%F%X%P: error: Cannot change output format whilst linking ARM binaries.\n");
      return;
    }

  bfd_elf32_arm_set_target_relocs (link_info.output_bfd, &link_info,
				   target1_is_rel,
				   target2_type, fix_v4bx, use_blx,
				   vfp11_denorm_fix, no_enum_size_warning,
				   no_wchar_size_warning,
				   pic_veneer, fix_cortex_a8,
				   fix_arm1176);

  stub_file = lang_add_input_file ("linker stubs",
 				   lang_input_file_is_fake_enum,
 				   NULL);
  stub_file->the_bfd = bfd_create ("linker stubs", link_info.output_bfd);
  if (stub_file->the_bfd == NULL
      || ! bfd_set_arch_mach (stub_file->the_bfd,
 			      bfd_get_arch (link_info.output_bfd),
 			      bfd_get_mach (link_info.output_bfd)))
    {
      einfo ("%X%P: can not create BFD %E\n");
      return;
    }

  stub_file->the_bfd->flags |= BFD_LINKER_CREATED;
  ldlang_add_file (stub_file);

  /* Also use the stub file for stubs placed in a single output section.  */
  bfd_elf32_arm_add_glue_sections_to_bfd (stub_file->the_bfd, &link_info);
  bfd_elf32_arm_get_bfd_for_interworking (stub_file->the_bfd, &link_info);
}

/* Avoid processing the fake stub_file in vercheck, stat_needed and
   check_needed routines.  */

static void (*real_func) (lang_input_statement_type *);

static void arm_for_each_input_file_wrapper (lang_input_statement_type *l)
{
  if (l != stub_file)
    (*real_func) (l);
}

static void
arm_lang_for_each_input_file (void (*func) (lang_input_statement_type *))
{
  real_func = func;
  lang_for_each_input_file (&arm_for_each_input_file_wrapper);
}

#define lang_for_each_input_file arm_lang_for_each_input_file

EOF

# Define some shell vars to insert bits of code into the standard elf
# parse_args and list_options functions.
#
PARSE_AND_LIST_PROLOGUE='
#define OPTION_THUMB_ENTRY		301
#define OPTION_BE8			302
#define OPTION_TARGET1_REL		303
#define OPTION_TARGET1_ABS		304
#define OPTION_TARGET2			305
#define OPTION_FIX_V4BX			306
#define OPTION_USE_BLX			307
#define OPTION_VFP11_DENORM_FIX		308
#define OPTION_NO_ENUM_SIZE_WARNING	309
#define OPTION_PIC_VENEER		310
#define OPTION_FIX_V4BX_INTERWORKING	311
#define OPTION_STUBGROUP_SIZE           312
#define OPTION_NO_WCHAR_SIZE_WARNING	313
#define OPTION_FIX_CORTEX_A8		314
#define OPTION_NO_FIX_CORTEX_A8		315
#define OPTION_NO_MERGE_EXIDX_ENTRIES   316
#define OPTION_FIX_ARM1176		317
#define OPTION_NO_FIX_ARM1176		318
'

PARSE_AND_LIST_SHORTOPTS=p

PARSE_AND_LIST_LONGOPTS='
  { "no-pipeline-knowledge", no_argument, NULL, '\'p\''},
  { "thumb-entry", required_argument, NULL, OPTION_THUMB_ENTRY},
  { "be8", no_argument, NULL, OPTION_BE8},
  { "target1-rel", no_argument, NULL, OPTION_TARGET1_REL},
  { "target1-abs", no_argument, NULL, OPTION_TARGET1_ABS},
  { "target2", required_argument, NULL, OPTION_TARGET2},
  { "fix-v4bx", no_argument, NULL, OPTION_FIX_V4BX},
  { "fix-v4bx-interworking", no_argument, NULL, OPTION_FIX_V4BX_INTERWORKING},
  { "use-blx", no_argument, NULL, OPTION_USE_BLX},
  { "vfp11-denorm-fix", required_argument, NULL, OPTION_VFP11_DENORM_FIX},
  { "no-enum-size-warning", no_argument, NULL, OPTION_NO_ENUM_SIZE_WARNING},
  { "pic-veneer", no_argument, NULL, OPTION_PIC_VENEER},
  { "stub-group-size", required_argument, NULL, OPTION_STUBGROUP_SIZE },
  { "no-wchar-size-warning", no_argument, NULL, OPTION_NO_WCHAR_SIZE_WARNING},
  { "fix-cortex-a8", no_argument, NULL, OPTION_FIX_CORTEX_A8 },
  { "no-fix-cortex-a8", no_argument, NULL, OPTION_NO_FIX_CORTEX_A8 },
  { "no-merge-exidx-entries", no_argument, NULL, OPTION_NO_MERGE_EXIDX_ENTRIES },
  { "fix-arm1176", no_argument, NULL, OPTION_FIX_ARM1176 },
  { "no-fix-arm1176", no_argument, NULL, OPTION_NO_FIX_ARM1176 },
'

PARSE_AND_LIST_OPTIONS='
  fprintf (file, _("  --thumb-entry=<sym>         Set the entry point to be Thumb symbol <sym>\n"));
  fprintf (file, _("  --be8                       Output BE8 format image\n"));
  fprintf (file, _("  --target1-rel               Interpret R_ARM_TARGET1 as R_ARM_REL32\n"));
  fprintf (file, _("  --target1-abs               Interpret R_ARM_TARGET1 as R_ARM_ABS32\n"));
  fprintf (file, _("  --target2=<type>            Specify definition of R_ARM_TARGET2\n"));
  fprintf (file, _("  --fix-v4bx                  Rewrite BX rn as MOV pc, rn for ARMv4\n"));
  fprintf (file, _("  --fix-v4bx-interworking     Rewrite BX rn branch to ARMv4 interworking veneer\n"));
  fprintf (file, _("  --use-blx                   Enable use of BLX instructions\n"));
  fprintf (file, _("  --vfp11-denorm-fix          Specify how to fix VFP11 denorm erratum\n"));
  fprintf (file, _("  --no-enum-size-warning      Don'\''t warn about objects with incompatible\n"
		   "                                enum sizes\n"));
  fprintf (file, _("  --no-wchar-size-warning     Don'\''t warn about objects with incompatible\n"
		   "                                wchar_t sizes\n"));
  fprintf (file, _("  --pic-veneer                Always generate PIC interworking veneers\n"));
  fprintf (file, _("\
  --stub-group-size=N         Maximum size of a group of input sections that\n\
                               can be handled by one stub section.  A negative\n\
                               value locates all stubs after their branches\n\
                               (with a group size of -N), while a positive\n\
                               value allows two groups of input sections, one\n\
                               before, and one after each stub section.\n\
                               Values of +/-1 indicate the linker should\n\
                               choose suitable defaults.\n"));
  fprintf (file, _("  --[no-]fix-cortex-a8        Disable/enable Cortex-A8 Thumb-2 branch erratum fix\n"));
  fprintf (file, _("  --no-merge-exidx-entries    Disable merging exidx entries\n"));
  fprintf (file, _("  --[no-]fix-arm1176          Disable/enable ARM1176 BLX immediate erratum fix\n"));
'

PARSE_AND_LIST_ARGS_CASES='
    case '\'p\'':
      /* Only here for backwards compatibility.  */
      break;

    case OPTION_THUMB_ENTRY:
      thumb_entry_symbol = optarg;
      break;

    case OPTION_BE8:
      byteswap_code = 1;
      break;

    case OPTION_TARGET1_REL:
      target1_is_rel = 1;
      break;

    case OPTION_TARGET1_ABS:
      target1_is_rel = 0;
      break;

    case OPTION_TARGET2:
      target2_type = optarg;
      break;

    case OPTION_FIX_V4BX:
      fix_v4bx = 1;
      break;

    case OPTION_FIX_V4BX_INTERWORKING:
      fix_v4bx = 2;
      break;

    case OPTION_USE_BLX:
      use_blx = 1;
      break;

    case OPTION_VFP11_DENORM_FIX:
      if (strcmp (optarg, "none") == 0)
        vfp11_denorm_fix = BFD_ARM_VFP11_FIX_NONE;
      else if (strcmp (optarg, "scalar") == 0)
        vfp11_denorm_fix = BFD_ARM_VFP11_FIX_SCALAR;
      else if (strcmp (optarg, "vector") == 0)
        vfp11_denorm_fix = BFD_ARM_VFP11_FIX_VECTOR;
      else
        einfo (_("Unrecognized VFP11 fix type '\''%s'\''.\n"), optarg);
      break;

    case OPTION_NO_ENUM_SIZE_WARNING:
      no_enum_size_warning = 1;
      break;

    case OPTION_NO_WCHAR_SIZE_WARNING:
      no_wchar_size_warning = 1;
      break;

    case OPTION_PIC_VENEER:
      pic_veneer = 1;
      break;

    case OPTION_STUBGROUP_SIZE:
      {
	const char *end;

        group_size = bfd_scan_vma (optarg, &end, 0);
        if (*end)
	  einfo (_("%P%F: invalid number `%s'\''\n"), optarg);
      }
      break;

    case OPTION_FIX_CORTEX_A8:
      fix_cortex_a8 = 1;
      break;

    case OPTION_NO_FIX_CORTEX_A8:
      fix_cortex_a8 = 0;
      break;

   case OPTION_NO_MERGE_EXIDX_ENTRIES:
      merge_exidx_entries = 0;
      break;

   case OPTION_FIX_ARM1176:
      fix_arm1176 = 1;
      break;

   case OPTION_NO_FIX_ARM1176:
      fix_arm1176 = 0;
      break;
'

# We have our own before_allocation etc. functions, but they call
# the standard routines, so give them a different name.
LDEMUL_BEFORE_ALLOCATION=arm_elf_before_allocation
LDEMUL_AFTER_ALLOCATION=gld${EMULATION_NAME}_after_allocation
LDEMUL_CREATE_OUTPUT_SECTION_STATEMENTS=arm_elf_create_output_section_statements

# Replace the elf before_parse function with our own.
LDEMUL_BEFORE_PARSE=gld"${EMULATION_NAME}"_before_parse

# Call the extra arm-elf function
LDEMUL_FINISH=gld${EMULATION_NAME}_finish
@


1.87
log
@ld/
	* emultempl/aarch64elf.em (gld${EMULATION_NAME}_before_parse):
	Copy last elf32.em here too.
	* emultempl/armelf.em (gld${EMULATION_NAME}_before_parse): Likewise.
	* emultempl/mmixelf.em (gld${EMULATION_NAME}_before_parse): Likewise.
	* emultempl/scoreelf.em (gld${EMULATION_NAME}_before_parse): Likewise.
@
text
@d2 1
a2 3
#   Copyright 1991, 1993, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
#   2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012
#   Free Software Foundation, Inc.
d185 3
a187 2
elf32_arm_add_stub_section (const char *stub_sec_name,
			    asection *input_section)
d203 1
a203 1
  bfd_set_section_alignment (stub_file->the_bfd, stub_sec, 3);
@


1.86
log
@
Add support for PowerPC VLE.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	* NEWS:  Mention PowerPC VLE port.

2012-05-14  James Lemke <jwlemke@@codesourcery.com>
	    Catherine Moore  <clm@@codesourcery.com>

	bfd/
	* bfd.c (bfd_lookup_section_flags): Add section parm.
	* ecoff.c (bfd_debug_section): Remove flag_info initializer.
	* elf-bfd.h (bfd_elf_section_data): Move in section_flag_info.
	(bfd_elf_lookup_section_flags): Add section parm.
	* elf32-ppc.c (is_ppc_vle): New function.
	(ppc_elf_modify_segment_map): New function.
	(elf_backend_modify_segment_map): Define.
	(has_vle_insns): New define.
	* elf32-ppc.h (ppc_elf_modify_segment_map): Declare.
	* elflink.c (bfd_elf_lookup_section_flags): Add return value & parm.
	Move in logic to omit / include a section.
	* libbfd-in.h (bfd_link_info): Add section parm.
	(bfd_generic_lookup_section_flags): Likewise.
	* reloc.c (bfd_generic_lookup_section_flags): Likewise.
	* section.c (bfd_section): Move out section_flag_info.
	(BFD_FAKE_SECTION): Remove flag_info initializer.
	* targets.c (_bfd_lookup_section_flags): Add section parm.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	bfd/
	* archures.c (bfd_mach_ppc_vle): New.
	* bfd-in2.h: Regenerated.
	* cpu-powerpc.c (bfd_powerpc_archs): New entry for vle.
	* elf32-ppc.c (split16_format_type): New enumeration.
	(ppc_elf_vle_split16): New function.
	(HOWTO): Add entries for R_PPC_VLE relocations.
	(ppc_elf_reloc_type_lookup): Handle PPC_VLE relocations.
	(ppc_elf_section_flags): New function.
	(ppc_elf_lookup_section_flags): New function.
	(ppc_elf_section_processing): New function.
	(ppc_elf_check_relocs): Handle PPC_VLE relocations.
	(ppc_elf_relocation_section): Likewise.
	(elf_backend_lookup_section_flags_hook): Define.
	(elf_backend_section_flags): Define.
	(elf_backend_section_processing): Define.
	* elf32-ppc.h (ppc_elf_section_processing): Declare.
	* libbfd.h: Regenerated.
	* reloc.c (BFD_RELOC_PPC_VLE_REL8, BFD_RELOC_PPC_VLE_REL15,
	BFD_RELOC_PPC_VLE_REL24, BFD_RELOC_PPC_VLE_LO16A,
	BFD_RELOC_PPC_VLE_LO16D, BFD_RELOC_PPC_VLE_HI16A,
	BFD_RELOC_PPC_VLE_HI16D, BFD_RELOC_PPC_VLE_HA16A,
	BFD_RELOC_PPC_VLE_HA16D, BFD_RELOC_PPC_VLE_SDA21,
	BFD_RELOC_PPC_VLE_SDA21_LO, BFD_RELOC_PPC_VLE_SDAREL_LO16A,
	BFD_RELOC_PPC_VLE_SDAREL_LO16D, BFD_RELOC_PPC_VLE_SDAREL_HI16A,
	BFD_RELOC_PPC_VLE_SDAREL_HI16D, BFD_RELOC_PPC_VLE_SDAREL_HA16A,
	BFD_RELOC_PPC_VLE_SDAREL_HA16D): New bfd relocations.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	gas/
	* config/tc-ppc.c (insn_validate): New func of existing code to call..
	(ppc_setup_opcodes): ..from 2 places here.
	Revise for second (VLE) opcode table.
	Add #ifdef'd code to print opcode tables.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	gas/
	* config/tc-ppc.c (ppc_setup_opcodes): Allow out-of-order
	for the VLE conditional branches.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>
	    Rhonda Wittels  <rhonda@@codesourcery.com>

	gas/
	* config/tc-ppc.c (PPC_VLE_SPLIT16A): New macro.
	(PPC_VLE_SPLIT16D): New macro.
	(PPC_VLE_LO16A): New macro.
	(PPC_VLE_LO16D): New macro.
	(PPC_VLE_HI16A): New macro.
	(PPC_VLE_HI16D): New macro.
	(PPC_VLE_HA16A): New macro.
	(PPC_VLE_HA16D): New macro.
	(PPC_APUINFO_VLE): New definition.
	(md_chars_to_number): New function.
	(md_parse_option): Check for combinations of little
	endian and -mvle.
	(md_show_usage): Document -mvle.
	(ppc_arch): Recognize VLE.
	(ppc_mach): Recognize bfd_mach_ppc_vle.
	(ppc_setup_opcodes): Print the opcode table if
	* config/tc-ppc.h (ppc_frag_check): Declare.
	* doc/c-ppc.texi: Document -mvle.
	* NEWS:  Mention PowerPC VLE port.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	gas/
	* config/tc-ppc.h (ppc_dw2_line_min_insn_length): Declare.
	(DWARF2_LINE_MIN_INSN_LENGTH): Redefine.
	* config/tc-ppc.c (ppc_dw2_line_min_insn_length): New.
	* dwarf2dbg.c (scale_addr_delta): Handle values of 1
	for DWARF2_LINE_MIN_INSN_LENGTH.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>
	    Rhonda Wittels  <rhonda@@codesourcery.com>

	gas/testsuite/
	* gas/ppc/ppc.exp: Run new tests.
	* gas/ppc/vle-reloc.d: New test.
	* gas/ppc/vle-reloc.s: New test.
	* gas/ppc/vle-simple-1.d: New test.
	* gas/ppc/vle-simple-1.s: New test.
	* gas/ppc/vle-simple-2.d: New test.
	* gas/ppc/vle-simple-2.s: New test.
	* gas/ppc/vle-simple-3.d: New test.
	* gas/ppc/vle-simple-3.s: New test.
	* gas/ppc/vle-simple-4.d: New test.
	* gas/ppc/vle-simple-4.s: New test.
	* gas/ppc/vle-simple-5.d: New test.
	* gas/ppc/vle-simple-5.s: New test.
	* gas/ppc/vle-simple-6.d: New test.
	* gas/ppc/vle-simple-6.s: New test.
	* gas/ppc/vle.d: New test.
	* gas/ppc/vle.s: New test.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>
	include/elf/
	* ppc.h (SEC_PPC_VLE): Remove.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
	    James Lemke  <jwlemke@@codesourcery.com>

	include/elf/
	* ppc.h (R_PPC_VLE_REL8): New reloction.
	(R_PPC_VLE_REL15): Likewise.
	(R_PPC_VLE_REL24): Likewise.
	(R_PPC_VLE_LO16A): Likewise.
	(R_PPC_VLE_LO16D): Likewise.
	(R_PPC_VLE_HI16A): Likewise.
	(R_PPC_VLE_HI16D): Likewise.
	(R_PPC_VLE_HA16A): Likewise.
	(R_PPC_VLE_HA16D): Likewise.
	(R_PPC_VLE_SDA21): Likewise.
	(R_PPC_VLE_SDA21_LO): Likewise.
	(R_PPC_VLE_SDAREL_LO16A): Likewise.
	(R_PPC_VLE_SDAREL_LO16D): Likewise.
	(R_PPC_VLE_SDAREL_HI16A): Likewise.
	(R_PPC_VLE_SDAREL_HI16D): Likewise.
	(R_PPC_VLE_SDAREL_HA16A): Likewise.
	(R_PPC_VLE_SDAREL_HA16D): Likewise.
	(SEC_PPC_VLE): Remove.
	(PF_PPC_VLE): New program header flag.
	(SHF_PPC_VLE): New section header flag.
	(vle_opcodes, vle_num_opcodes): New.
	(VLE_OP): New macro.
	(VLE_OP_TO_SEG): New macro.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>
	    Rhonda Wittels  <rhonda@@codesourcery.com>

	include/opcode/
	* ppc.h (PPC_OPCODE_VLE): New definition.
	(PPC_OP_SA): New macro.
	(PPC_OP_SE_VLE): New macro.
	(PPC_OP): Use a variable shift amount.
	(powerpc_operand): Update comments.
	(PPC_OPSHIFT_INV): New macro.
	(PPC_OPERAND_CR): Replace with...
	(PPC_OPERAND_CR_BIT): ...this and
	(PPC_OPERAND_CR_REG): ...this.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	ld/
	* ldlang.c (walk_wild_consider_section): Don't copy section_flag_list.
	Pass it to callback.
	(walk_wild_section_general): Pass section_flag_list to callback.
	(lang_add_section): Add sflag_list parm.
	Move out logic to keep / omit a section & call bfd_lookup_section_flags.
	(output_section_callback_fast): Add sflag_list parm.
	Add new parm to lang_add_section calls.
	(output_section_callback): Likewise.
	(check_section_callback): Add sflag_list parm.
	(lang_place_orphans): Add new parm to lang_add_section calls.
	(gc_section_callback): Add sflag_list parm.
	(find_relro_section_callback): Likewise.
	* ldlang.h (callback_t): Add flag_info parm.
	(lang_add_section): Add sflag_list parm.
	* emultempl/armelf.em (elf32_arm_add_stub_section):
	Add lang_add_section parm.
	* emultempl/beos.em (gld*_place_orphan): Likewise.
	* emultempl/elf32.em (gld*_place_orphan): Likewise.
	* emultempl/hppaelf.em (hppaelf_add_stub_section): Likewise.
	* emultempl/m68hc1xelf.em (m68hc11elf_add_stub_section): Likewise.
	* emultempl/mipself.em (mips_add_stub_section): Likewise.
	* emultempl/mmo.em (mmo_place_orphan): Likewise.
	* emultempl/pe.em (gld_*_place_orphan): Likewise.
	* emultempl/pep.em (gld_*_place_orphan): Likewise.
	* emultempl/ppc64elf.em (ppc_add_stub_section): Likewise.
	* emultempl/spuelf.em (spu_place_special_section): Likewise.
	* emultempl/vms.em (vms_place_orphan): Likewise.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	ld/testsuite/
	* ld-powerpc/powerpc.exp: Create ppceabitests.
	* ld-powerpc/vle-multiseg.s: New.
	* ld-powerpc/vle-multiseg-1.d: New.
	* ld-powerpc/vle-multiseg-1.ld: New.
	* ld-powerpc/vle-multiseg-2.d: New.
	* ld-powerpc/vle-multiseg-2.ld: New.
	* ld-powerpc/vle-multiseg-3.d: New.
	* ld-powerpc/vle-multiseg-3.ld: New.
	* ld-powerpc/vle-multiseg-4.d: New.
	* ld-powerpc/vle-multiseg-4.ld: New.
	* ld-powerpc/vle-multiseg-5.d: New.
	* ld-powerpc/vle-multiseg-5.ld: New.
	* ld-powerpc/vle-multiseg-6.d: New.
	* ld-powerpc/vle-multiseg-6.ld: New.
	* ld-powerpc/vle-multiseg-6a.s: New.
	* ld-powerpc/vle-multiseg-6b.s: New.
	* ld-powerpc/vle-multiseg-6c.s: New.
	* ld-powerpc/vle-multiseg-6d.s: New.
	* ld-powerpc/powerpc.exp: Run new tests.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	ld/
	* NEWS:  Mention PowerPC VLE port.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	ld/testsuite/
	* ld-powerpc/apuinfo.rd: Update for VLE.
	* ld-powerpc/vle-reloc-1.d: New.
	* ld-powerpc/vle-reloc-1.s: New.
	* ld-powerpc/vle-reloc-2.d: New.
	* ld-powerpc/vle-reloc-2.s: New.
	* ld-powerpc/vle-reloc-3.d: New.
	* ld-powerpc/vle-reloc-3.s: New.
	* ld-powerpc/vle-reloc-def-1.s: New.
	* ld-powerpc/vle-reloc-def-2.s: New.
	* ld-powerpc/vle-reloc-def-3.s: New.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	opcodes/
	* ppc-dis.c (get_powerpc_dialect): Use is_ppc_vle.
	(PPC_OPCD_SEGS, VLE_OPCD_SEGS): New defines.
	(vle_opcd_indices): New array.
	(lookup_vle): New function.
	(disassemble_init_powerpc): Revise for second (VLE) opcode table.
	(print_insn_powerpc): Likewise.
	* ppc-opc.c: Likewise.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>
	    Rhonda Wittels  <rhonda@@codesourcery.com>
	    Nathan Froyd <froydnj@@codesourcery.com>

	opcodes/
	* ppc-opc.c (insert_arx, extract_arx): New functions.
	(insert_ary, extract_ary): New functions.
	(insert_li20, extract_li20): New functions.
	(insert_rx, extract_rx): New functions.
	(insert_ry, extract_ry): New functions.
	(insert_sci8, extract_sci8): New functions.
	(insert_sci8n, extract_sci8n): New functions.
	(insert_sd4h, extract_sd4h): New functions.
	(insert_sd4w, extract_sd4w): New functions.
	(insert_vlesi, extract_vlesi): New functions.
	(insert_vlensi, extract_vlensi): New functions.
	(insert_vleui, extract_vleui): New functions.
	(insert_vleil, extract_vleil): New functions.
 	(BI_MASK, BB_MASK, BT): Use PPC_OPERAND_CR_BIT.
 	(BI16, BI32, BO32, B8): New.
	(B15, B24, CRD32, CRS): New.
 	(CRD, OBF, BFA, CR, CRFS): Use PPC_OPERAND_CR_REG.
	(DB, IMM20, RD, Rx, ARX, RY, RZ): New.
	(ARY, SCLSCI8, SCLSCI8N, SE_SD, SE_SDH): New.
	(SH6_MASK): Use PPC_OPSHIFT_INV.
	(SI8, UI5, OIMM5, UI7, BO16): New.
	(VLESIMM, VLENSIMM, VLEUIMM, VLEUIMML): New.
	(XT6, XA6, XB6, XB6S, XC6): Use PPC_OPSHIFT_INV.
	(ALLOW8_SPRG): New.
	(insert_sprg, extract_sprg): Check ALLOW8_SPRG.
	(OPVUP, OPVUP_MASK OPVUP): New
	(BD8, BD8_MASK, BD8IO, BD8IO_MASK): New.
	(EBD8IO, EBD8IO1_MASK, EBD8IO2_MASK, EBD8IO3_MASK): New.
	(BD15, BD15_MASK, EBD15, EBD15_MASK, EBD15BI, EBD15BI_MASK): New.
	(BD24,BD24_MASK, C_LK, C_LK_MASK, C, C_MASK): New.
 	(IA16, IA16_MASK, I16A, I16A_MASK, I16L, I16L_MASK): New.
	(IM7, IM7_MASK, LI20, LI20_MASK, SCI8, SCI8_MASK): New.
	(SCI8BF, SCI8BF_MASK, SD4, SD4_MASK): New.
	(SE_IM5, SE_IM5_MASK): New.
	(SE_R, SE_R_MASK, SE_RR, SE_RR_MASK): New.
	(EX, EX_MASK, BO16F, BO16T, BO32F, BO32T): New.
	(BO32DNZ, BO32DZ): New.
	(NO371, PPCSPE, PPCISEL, PPCEFS, MULHW): Include PPC_OPCODE_VLE.
	(PPCVLE): New.
	(powerpc_opcodes): Add new VLE instructions.  Update existing
	instruction to include PPCVLE if supported.
	* ppc-dis.c (ppc_opts): Add vle entry.
	(get_powerpc_dialect): New function.
	(powerpc_init_dialect): VLE support.
	(print_insn_big_powerpc): Call get_powerpc_dialect.
	(print_insn_little_powerpc): Likewise.
	(operand_value_powerpc): Handle negative shift counts.
	(print_insn_powerpc): Handle 2-byte instruction lengths.
@
text
@d55 1
d258 1
a258 1
  
d262 1
a262 1
  
d265 1
a265 1
  
d270 1
a270 1
  
d290 1
a290 1
	  
d293 1
a293 1
	  
d309 1
a309 1
		      sec_list = (asection **) 
d317 1
a317 1
	
d319 1
a319 1
      
d323 1
a323 1
      
d469 1
a469 1
				   pic_veneer, fix_cortex_a8, 
d484 1
a484 1
 
@


1.86.2.1
log
@ld/
	* emultempl/aarch64elf.em (gld${EMULATION_NAME}_before_parse):
	Copy last elf32.em here too.
	* emultempl/armelf.em (gld${EMULATION_NAME}_before_parse): Likewise.
	* emultempl/mmixelf.em (gld${EMULATION_NAME}_before_parse): Likewise.
	* emultempl/scoreelf.em (gld${EMULATION_NAME}_before_parse): Likewise.
@
text
@a54 1
  config.separate_code = `if test "x${SEPARATE_CODE}" = xyes ; then echo TRUE ; else echo FALSE ; fi`;
d257 1
a257 1

d261 1
a261 1

d264 1
a264 1

d269 1
a269 1

d289 1
a289 1

d292 1
a292 1

d308 1
a308 1
		      sec_list = (asection **)
d316 1
a316 1

d318 1
a318 1

d322 1
a322 1

d468 1
a468 1
				   pic_veneer, fix_cortex_a8,
d483 1
a483 1

@


1.86.2.2
log
@bfd/
	* elf32-arm.c (elf32_arm_stub_long_branch_arm_nacl): New variable.
	(elf32_arm_stub_long_branch_arm_nacl_pic): New variable.
	(arm_build_one_stub): Increase MAXRELOCS to 3.
	(arm_type_of_stub): Use them if GLOBALS->nacl_p.
	(struct elf32_arm_link_hash_table): Give add_stub_section member's
	pointee type a third argument.
	(elf32_arm_create_or_find_stub_sec): Update caller.
	(elf32_arm_size_stubs): Update argument type.
	* bfd-in.h (elf32_arm_size_stubs): Update decl.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.

ld/
	* emultempl/armelf.em (elf32_arm_add_stub_section): Take third
	argument ALIGNMENT_POWER, use it instead of constant 3.

ld/testsuite/
	* ld-arm/farcall-arm-nacl.d: New file.
	* ld-arm/farcall-arm-nacl-pic.d: New file.
	* ld-arm/farcall-data-nacl.d: New file.
	* ld-arm/arm-elf.exp (armeabitests_common): Add extra element to
	"action" lists for those cases to use a different dump file for NaCl
	targets.
	Massage $armeabitests_common to drop the extra element or the one
	before it, depending on [istarget "arm*-*-nacl*"].

	* ld-arm/arm-elf.exp (armelftests_common): Move all "Cortex-A8
	erratum fix", Thumb-only and interworking cases to ...
	(armelftests_nonacl): ... here.
	(armeabitests_common): Move all "erratum 760522 fix", Thumb-only
	and interworking cases to ...
	(armeabitests_nonacl): ... here.
@
text
@d3 1
a3 1
#   2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013
d77 2
a78 2
	  /* Initialise mapping tables for code/data.  */
	  bfd_elf32_arm_init_maps (is->the_bfd);
d188 1
a188 2
			    asection *input_section,
			    unsigned int alignment_power)
d204 1
a204 1
  bfd_set_section_alignment (stub_file->the_bfd, stub_sec, alignment_power);
d283 1
a283 1
	  xmalloc (list_size * sizeof (asection *));
d310 1
a310 1
			  xrealloc (sec_list, list_size * sizeof (asection *));
d376 3
a378 3
	/* Figure out where VFP11 erratum veneers (and the labels returning
	   from same) have been placed.  */
	bfd_elf32_arm_vfp11_fix_veneer_locations (is->the_bfd, &link_info);
d473 2
a474 2
				   lang_input_file_is_fake_enum,
				   NULL);
d478 2
a479 2
			      bfd_get_arch (link_info.output_bfd),
			      bfd_get_mach (link_info.output_bfd)))
d580 7
a586 7
			       can be handled by one stub section.  A negative\n\
			       value locates all stubs after their branches\n\
			       (with a group size of -N), while a positive\n\
			       value allows two groups of input sections, one\n\
			       before, and one after each stub section.\n\
			       Values of +/-1 indicate the linker should\n\
			       choose suitable defaults.\n"));
d631 1
a631 1
	vfp11_denorm_fix = BFD_ARM_VFP11_FIX_NONE;
d633 1
a633 1
	vfp11_denorm_fix = BFD_ARM_VFP11_FIX_SCALAR;
d635 1
a635 1
	vfp11_denorm_fix = BFD_ARM_VFP11_FIX_VECTOR;
d637 1
a637 1
	einfo (_("Unrecognized VFP11 fix type '\''%s'\''.\n"), optarg);
d656 2
a657 2
	group_size = bfd_scan_vma (optarg, &end, 0);
	if (*end)
@


1.85
log
@	PR ld/13991
bfd/
	* bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
	_bfd_generic_link_just_syms.
	* bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
	* bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

	* bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
	* bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
	SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
	SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
	* bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
	* bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
	* bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
	* bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
	* bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
	* bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
	* bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
	* bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
	* bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
	* bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
	* bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
	* bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
	* bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
	* bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
	* bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
	* bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
	* bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
	* bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
	* bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
	* bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
	* bfd/reloc.c: Update all references.
	* bfd/bfd-in2.h: Regenerate.
ld/
	* ld/ldlang.c (size_input_section): Use sec_info_type rather than
	usrdata->flags.just_syms.
	* ld/ldwrite.c (build_link_order): Likewise.
	* ld/emultempl/hppaelf.em (build_section_lists): Likewise.
	* ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
	* ld/emultempl/armelf.em (build_section_lists): Likewise.
	(after_allocation): Update for renamed sec_info_type value.
	* ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d211 1
a211 1
  lang_add_section (&info.add, stub_sec, os);
@


1.84
log
@	* ldlang.h (struct lang_input_statement_flags): New, extract from..
	(lang_input_statement_type): ..here.  New field "flags".
	(input_flags): Declare.
	(missing_file): Delete.
	* ldmain.h (whole_archive): Delete.
	(add_DT_NEEDED_for_regular, add_DT_NEEDED_for_dynamic): Delete.
	* ld.h (ld_config_type <dynamic_link>): Delete.
	* ldmain.c (whole_archive): Delete.
	(add_DT_NEEDED_for_regular, add_DT_NEEDED_for_dynamic): Delete.
	* ldlang.c (missing_file, ldlang_sysrooted_script): Delete.
	(input_flags): New variable.  Replace all uses of config.dynamic_link,
	missing_file, ldlang_sysrooted_script, whole_archive,
	add_DT_NEEDED_for_regular and add_DT_NEEDED_for_dynamic with fields
	from here.
	* ldfile.c: Likewise.
	* ldgram.y: Likewise.
	* ldmain.c: Likewise.
	* ldwrite.c: Likewise.
	* lexsup.c: Likewise.
	* plugin.c: Likewise.
	* emultempl/aix.em: Likewise.
	* emultempl/armelf.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/scoreelf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/vms.em: Likewise.
	* ldlang.c (new_afile): Use memset to init zero fields.
	(load_symbols): Simplify save and restore of flags around command
	file processing.
	* ldfile.c (is_sysrooted_pathname): Tidy.
@
text
@d243 1
a243 1
      if (!((lang_input_statement_type *) i->owner->usrdata)->flags.just_syms
d302 1
a302 1
		  && sec->sec_info_type != ELF_INFO_TYPE_JUST_SYMS
@


1.83
log
@	* emultempl/armelf.em: Update copyright to 2010 and 2011.
	(PARSE_AND_LIST_OPTIONS): Fix formatting.
@
text
@d3 1
a3 1
#   2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
d53 1
a53 1
  config.dynamic_link = ${DYNAMIC_LINK-TRUE};
d243 1
a243 1
      if (!((lang_input_statement_type *) i->owner->usrdata)->just_syms_flag
@


1.82
log
@	* bfd/bfd-in.h (bfd_elf32_arm_set_target_relocs): Update prototype.
	* bfd/bfd-in2.h (bfd_elf32_arm_set_target_relocs): Likewise.
	* bfd/elf32-arm.c (elf32_arm_link_hash_table): New field.
	(elf232_arm_link_hash_table_create): Initialise new field.
	(check_use_blx): Change test depending on fix_arm1176.
	(bfd_elf32_arm_set_target_relocs): Set fix_arm1176 from
	command line options.
	* ld/emultempl/armelf.em (fix_arm1176): New variable.
	(arm_elf_create_output_section_statements): Pass
	fix_arm1176 option to bfd backend.
	(OPTION_FIX_ARM1176): New define.
	(OPTION_NO_FIX_ARM1176): Likewise.
	(PARSE_AND_LIST_LONGOPTS): Add new command line options.
	(PARSE_AND_LIST_OPTIONS): Likewise.
	(PARSE_AND_LIST_ARGS_CASES): Likewise.
	* ld/ld.texinfo: Document new command line options.
	* ld/testsuite/ld-arm/arm-elf.exp (armelftests): Update for new command-line
	options.
	(armeabitests): Update for new command-line options, and add
	new test cases.
	* ld/testsuite/ld-arm/fix-arm1176.s: Add test case.
	* ld/testsuite/ld-arm/fix-arm1176-off.d: Likewise.
	* ld/testsuite/ld-arm/fix-arm1176-on.d: Likewise.
@
text
@d3 1
a3 1
#   2004, 2005, 2006, 2007, 2008, 2009
d574 1
a574 1
  fprintf (file, _("  --no-wchar-size-warning     Don'\''t warn about objects with incompatible"
d578 8
a585 8
   --stub-group-size=N   Maximum size of a group of input sections that can be\n\
                           handled by one stub section.  A negative value\n\
                           locates all stubs after their branches (with a\n\
                           group size of -N), while a positive value allows\n\
                           two groups of input sections, one before, and one\n\
                           after each stub section.  Values of +/-1 indicate\n\
                           the linker should choose suitable defaults.\n"
 		   ));
@


1.82.2.1
log
@    PR ld/13991
    bfd/
    * bfd/elf-bfd.h (_bfd_elf_link_just_syms): Define as
    _bfd_generic_link_just_syms.
    * bfd/elflink.c (_bfd_elf_link_just_syms): Delete.
    * bfd/linker.c (_bfd_generic_link_just_syms): Set sec_info_type.

    * bfd/bfd-in.h (discarded_section): Renamed from elf_discarded_section.
    * bfd/section.c (SEC_INFO_TYPE_NONE, SEC_INFO_TYPE_STABS,
    SEC_INFO_TYPE_MERGE, SEC_INFO_TYPE_EH_FRAME,
    SEC_INFO_TYPE_JUST_SYMS): Renamed from corresponding ELF_INFO_TYPE.
    * bfd/elf-eh-frame.c, * bfd/elf-m10200.c, * bfd/elf-m10300.c,
    * bfd/elf.c, * bfd/elf32-arm.c, * bfd/elf32-avr.c, * bfd/elf32-bfin.c,
    * bfd/elf32-cr16.c, * bfd/elf32-cr16c.c, * bfd/elf32-cris.c,
    * bfd/elf32-crx.c, * bfd/elf32-d10v.c, * bfd/elf32-epiphany.c,
    * bfd/elf32-fr30.c, * bfd/elf32-frv.c, * bfd/elf32-h8300.c,
    * bfd/elf32-hppa.c, * bfd/elf32-i370.c, * bfd/elf32-i386.c,
    * bfd/elf32-i860.c, * bfd/elf32-ip2k.c, * bfd/elf32-iq2000.c,
    * bfd/elf32-lm32.c, * bfd/elf32-m32c.c, * bfd/elf32-m32r.c,
    * bfd/elf32-m68hc1x.c, * bfd/elf32-m68k.c, * bfd/elf32-mcore.c,
    * bfd/elf32-mep.c, * bfd/elf32-moxie.c, * bfd/elf32-msp430.c,
    * bfd/elf32-mt.c, * bfd/elf32-openrisc.c, * bfd/elf32-ppc.c,
    * bfd/elf32-rl78.c, * bfd/elf32-rx.c, * bfd/elf32-s390.c,
    * bfd/elf32-score.c, * bfd/elf32-score7.c, * bfd/elf32-sh.c,
    * bfd/elf32-spu.c, * bfd/elf32-tic6x.c, * bfd/elf32-tilepro.c,
    * bfd/elf32-v850.c, * bfd/elf32-vax.c, * bfd/elf32-xc16x.c,
    * bfd/elf32-xstormy16.c, * bfd/elf32-xtensa.c, * bfd/elf64-alpha.c,
    * bfd/elf64-hppa.c, * bfd/elf64-ia64-vms.c, * bfd/elf64-mmix.c,
    * bfd/elf64-ppc.c, * bfd/elf64-s390.c, * bfd/elf64-sh64.c,
    * bfd/elf64-x86-64.c, * bfd/elflink.c, * bfd/elfnn-ia64.c,
    * bfd/elfxx-mips.c, * bfd/elfxx-sparc.c, * bfd/elfxx-tilegx.c,
    * bfd/reloc.c: Update all references.
    * bfd/bfd-in2.h: Regenerate.
    ld/
    * ld/ldlang.c (size_input_section): Use sec_info_type rather than
    usrdata->flags.just_syms.
    * ld/ldwrite.c (build_link_order): Likewise.
    * ld/emultempl/hppaelf.em (build_section_lists): Likewise.
    * ld/emultempl/ppc64elf.em (build_toc_list): Likewise.
    * ld/emultempl/armelf.em (build_section_lists): Likewise.
    (after_allocation): Update for renamed sec_info_type value.
    * ld/emultempl/tic6xdsbt.em: Likewise.
@
text
@d243 1
a243 1
      if (i->sec_info_type != SEC_INFO_TYPE_JUST_SYMS
d302 1
a302 1
		  && sec->sec_info_type != SEC_INFO_TYPE_JUST_SYMS
@


1.81
log
@include/elf/
	* internal.h (elf_internal_sym): Add st_target_internal.
	* arm.h (arm_st_branch_type): New enum.
	(ARM_SYM_BRANCH_TYPE): New macro.

bfd/
	* elf-bfd.h (elf_link_hash_entry): Add target_internal.
	* elf.c (swap_out_syms): Set st_target_internal for each
	Elf_Internal_Sym.
	* elfcode.h (elf_swap_symbol_in): Likewise.
	* elf32-i370.c (i370_elf_finish_dynamic_sections): Likewise.
	* elf32-sh-symbian.c (sh_symbian_relocate_section): Likewise.
	* elf64-sparc.c (elf64_sparc_output_arch_syms): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_size_dynamic_sections): Likewise.
	* elflink.c (elf_link_output_extsym): Likewise.
	(bfd_elf_final_link): Likewise.
	(elf_link_add_object_symbols): Copy st_target_internal
	to the hash table if we see a definition.
	(_bfd_elf_copy_link_hash_symbol_type): Copy target_internal.
	* elf32-arm.c (elf32_arm_stub_hash_entry): Replace st_type with
	a branch_type field.
	(a8_erratum_fix, a8_erratum_reloc): Likewise.
	(arm_type_of_stub): Replace actual_st_type with an
	actual_branch_type parameter.
	(arm_build_one_stub): Use branch types rather than st_types to
	determine the type of branch.
	(cortex_a8_erratum_scan): Likewise.
	(elf32_arm_size_stubs): Likewise.
	(bfd_elf32_arm_process_before_allocation): Likewise.
	(allocate_dynrelocs_for_symbol): Likewise.
	(elf32_arm_finish_dynamic_sections): Likewise.
	(elf32_arm_final_link_relocate): Replace sym_flags parameter with
	a branch_type parameter.
	(elf32_arm_relocate_section): Update call accordingly.
	(elf32_arm_adjust_dynamic_symbol): Don't check STT_ARM_TFUNC.
	(elf32_arm_output_map_sym): Initialize st_target_internal.
	(elf32_arm_output_stub_sym): Likewise.
	(elf32_arm_symbol_processing): Delete.
	(elf32_arm_swap_symbol_in): Convert STT_ARM_TFUNCs into STT_FUNCs.
	Use st_target_internal to record the branch type.
	(elf32_arm_swap_symbol_out): Use st_target_internal to test for
	Thumb functions.
	(elf32_arm_is_function_type): Delete.
	(elf_backend_symbol_processing): Likewise.
	(elf_backend_is_function_type): Likewise.

gas/
	* config/tc-arm.c (arm_adjust_symtab): Set the branch type
	for Thumb symbols.

ld/
	* emultempl/armelf.em (gld${EMULATION_NAME}_finish): Check
	eh->target_internal.

opcodes/
	* arm-dis.c (get_sym_code_type): Don't check for STT_ARM_TFUNC.
	Use branch types instead.
	(print_insn): Likewise.
@
text
@d45 1
d468 2
a469 1
				   pic_veneer, fix_cortex_a8);
d534 2
d558 2
d588 1
a588 1
 
d671 1
d673 7
@


1.80
log
@bfd/
	* elf32-arm.c (elf32_arm_check_relocs): Always assign a dynobj.
	(elf32_arm_finish_dynamic_sections): Move sgot != NULL assertion
	into the PLT block.

ld/
	* emultempl/armelf.em (arm_elf_before_allocation): Check dynobj
	instead of dynamic_sections_created.
@
text
@d407 1
a407 1
      if (!h || ELF_ST_TYPE(eh->type) != STT_ARM_TFUNC)
@


1.79
log
@2010-04-15  Andrew Haley  <aph@@redhat.com>

	* emultempl/armelf.em (merge_exidx_entries): New variable.
	(OPTION_NO_MERGE_EXIDX_ENTRIES): New definition.
	("no-merge-exidx-entries"): New option.
	* ld.texinfo (merge-exidx-entries): Document this option.

2010-04-15  Andrew Haley  <aph@@redhat.com>

	* bfd-in.h (elf32_arm_fix_exidx_coverage): Add new flag:
	merge_exidx_entries.
	* bfd-in2.h: Likewise.
	* elf32-arm.c (elf32_arm_fix_exidx_coverage): Likewise.  Use it to
	control merging of exidx entries.

2010-04-15  Andrew Haley  <aph@@redhat.com>

	* options.h (merge_exidx_entries): New option.
	* arm.cc (class Arm_exidx_fixup): Add new arg, merge_exidx_entries.
	(class Arm_exidx_fixup::merge_exidx_entries_): New member.
	(Output_section::fix_exidx_coverage): Add new arg, merge_exidx_entries.
	(Target_arm::merge_exidx_entries): New function.
	(process_exidx_entry): Don't merge if merge_exidx_entries_ is false.
	(Arm_output_section::fix_exidx_coverage): Pass merge_exidx_entries
	to Arm_exidx_fixup constructor.
	Add new arg, merge_exidx_entries.
	(Target_arm::fix_exidx_coverage): pass merge_exidx_entries to
	Arm_output_section::fix_exidx_coverage.
@
text
@d70 1
a70 1
  if (! elf_hash_table (&link_info)->dynamic_sections_created)
@


1.78
log
@        * emultempl/armelf.em (PARSE_AND_LIST_OPTIONS): Fix help for
        --target1-abs and --target1-rel options.
@
text
@d44 1
d318 2
a319 1
      if (elf32_arm_fix_exidx_coverage (sec_list, sec_count, &link_info))
d531 1
d553 1
d581 2
d662 4
@


1.77
log
@        Update soruces to make alpha, arc and arm targets compile cleanly
        with -Wc++-compat:
        * config/tc-alpha.c: Add casts.
        (extended_bfd_reloc_code_real_type): New type. Used to avoid
        enumeration conversion warnings.
        (struct alpha_fixup, void assemble_insn, assemble_insn)
        (assemble_tokens): Use new type.
        * ecoff.c: Add casts. (mark_stabs): Use enumeration names.
        * config/obj-elf.c: Add cast
        * config/tc-arc.c: Add casts.
        * config/obj-aout.h (text_section,data_section,bss_section):
        Make extern.
        * config/obj-elf.c: Add cast.
        * config/tc-arm.c: Add casts.
        (X, TxCE, TxCE, TxC3, TxC3w, TxCM_, TxCM, TUE, TUF, CE, CL, cCE)
        (cCL, C3E, xCM_, nUF, nCE_tag): Change input format to avoid the
        need for keywords as arguments.
        * ecoff.c: Add casts.
        * ecofflink.c: Add casts.
        * elf64-alpha.c: Add casts.
        (struct alpha_elf_got_entry, struct alpha_elf_reloc_entry): Move
        to top level.
        (SKIP_HOWTO): Use enum name.
        * elf32-arm.c: Add casts.
        (elf32_arm_vxworks_bed): Update code to avoid multiple
        declarations.
        (struct map_stub): Move to top level.
        * arc-dis.c Fix casts.
        * arc-ext.c: Add casts.
        * arm-dis.c (enum opcode_sentinel_enum): Gave name to anonymous
        enum.
        * emultempl/armelf.em: Add casts.
@
text
@d555 2
a556 2
  fprintf (file, _("  --target1=rel               Interpret R_ARM_TARGET1 as R_ARM_REL32\n"));
  fprintf (file, _("  --target1=abs               Interpret R_ARM_TARGET1 as R_ARM_ABS32\n"));
@


1.76
log
@update copyright dates
@
text
@d279 2
a280 1
      asection **sec_list = xmalloc (list_size * sizeof (asection *));
d306 2
a307 2
		      sec_list = xrealloc (sec_list,
					   list_size * sizeof (asection *));
@


1.75
log
@	PR 10474
	* ldemul.c (after_allocation_default): Run lang_relax_sections.
	* ldlang.h (lang_relax_sections): Declare.
	* ldlang.c (relax_sections): Delete.
	(lang_relax_sections): New function.
	(lang_process): Don't relax directly from here.
	* emultempl/alphaelf.em (alpha_finish): Call finish_default.
	* emultempl/armelf.em (arm_elf_after_allocation): Delete.  Move body..
	(gld${EMULATION_NAME}_finish): ..to here.  Move existing code..
	(gld${EMULATION_NAME}_after_allocation): ..to here.  New function.
	(LDEMUL_AFTER_ALLOCATION): Update.
	* emultempl/avrelf.em (avr_elf_finish, LDEMUL_FINISH): Delete.
	(avr_elf_after_allocation): New function.
	(LDEMUL_AFTER_ALLOCATION): Define.
	* emultempl/elf-generic.em (gld${EMULATION_NAME}_map_segments): Call
	lang_relax_sections.
	* emultempl/elf32.em (gld${EMULATION_NAME}_finish): Delete.  Move..
	(gld${EMULATION_NAME}_after_allocation): ..code to here.  New function.
	(LDEMUL_AFTER_ALLOCATION, LDEMUL_FINISH): Update.
	* emultempl/genelf.em (gld${EMULATION_NAME}_finish): Delete.  Move..
	(gld${EMULATION_NAME}_after_allocation): ..code to here.  New function.
	(LDEMUL_FINISH): Delete.
	(LDEMUL_AFTER_ALLOCATION): Define.
	* emultempl/hppaelf.em (gld${EMULATION_NAME}_finish): Delete.  Move..
	(gld${EMULATION_NAME}_after_allocation): ..to here.  New function.
	(LDEMUL_FINISH): Delete.
	(LDEMUL_AFTER_ALLOCATION): Define.
	* emultempl/m68hc1xelf.em (m68hc11elf_finish): Delete.  Move..
	(m68hc11elf_after_allocation): ..to here.  New function.
	(LDEMUL_FINISH): Delete.
	(LDEMUL_AFTER_ALLOCATION): Define.
	* emultempl/m68kelf.em (m68k_elf_after_allocation): Call
	gld${EMULATION_NAME}_after_allocation.
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): Call
	gld${EMULATION_NAME}_after_allocation.
	* emultempl/mmo.em (mmo_finish): Delete.  Move body..
	(gld${EMULATION_NAME}_after_allocation): ..to here.  New function.
	(LDEMUL_FINISH): Define.
	* emultempl/ppc64elf.em (ppc_layout_sections_again): Set elf_gp.
	(gld${EMULATION_NAME}_finish): Move code sizing sections..
	(gld${EMULATION_NAME}_after_allocation): ..to here.
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_after_allocation):
	Call gld${EMULATION_NAME}_after_allocation.
	* emultempl/spuelf.em (gld${EMULATION_NAME}_finish): Delete
	bfd_elf_discard_info and map_segments call.
@
text
@d3 1
a3 1
#   2004, 2005, 2007, 2008
@


1.74
log
@2009-06-10  Philip Blundell  <philb@@gnu.org>

	* emultempl/armelf.em (gld${EMULATION_NAME}_finish): Avoid crash
	if section has no ELF data.
@
text
@a91 16
static void
arm_elf_after_allocation (void)
{
  /* Call the standard elf routine.  */
  after_allocation_default ();

  {
    LANG_FOR_EACH_INPUT_STATEMENT (is)
      {
        /* Figure out where VFP11 erratum veneers (and the labels returning
           from same) have been placed.  */
        bfd_elf32_arm_vfp11_fix_veneer_locations (is->the_bfd, &link_info);
      }
  }
}

d272 1
a272 1
gld${EMULATION_NAME}_finish (void)
a273 5
  struct bfd_link_hash_entry * h;
  unsigned int list_size = 10;
  asection **sec_list = xmalloc (list_size * sizeof (asection *));
  unsigned int sec_count = 0;

d278 4
d361 15
d660 1
a660 1
LDEMUL_AFTER_ALLOCATION=arm_elf_after_allocation
@


1.73
log
@    ld/
    * emultempl/armelf.em (fix_cortex_a8): New.
    (arm_elf_before_allocation): Call bfd_elf32_arm_set_cortex_a8_fix.
    (arm_elf_create_output_section_statements): Add fix_cortex_a8 to
    bfd_elf32_arm_set_target_relocs.
    (OPTION_FIX_CORTEX_A8, OPTION_NO_FIX_CORTEX_A8): New.
    (PARSE_AND_LIST_LONGOPTS): Add [no-]fix-cortex-a8 options.
    (PARSE_AND_LIST_OPTIONS): Add [no-]fix-cortex-a8 options.
    (PARSE_AND_LIST_ARGS_CASES): Handle OPTION_[NO_]FIX_CORTEX_A8.
    * ld.texinfo (--[no-]fix-cortex-a8): Briefly document new options.

    bfd/
    * elf32-arm.c (THUMB16_BCOND_INSN, THUMB32_INSN, THUMB32_B_INSN):
    New macros.
    (elf32_arm_stub_a8_veneer_b_cond, elf32_arm_stub_a8_veneer_b)
    (elf32_arm_stub_a8_veneer_blx): New stub sequences.
    (elf32_arm_stub_type): Add arm_stub_a8_veneer_b_cond,
    arm_stub_a8_veneer_b and arm_stub_a8_veneer_blx.
    (elf32_arm_stub_hash_entry): Add target_addend, orig_insn fields.
    (a8_erratum_fix, a8_erratum_reloc): New structs.
    (elf32_arm_link_hash_table): Add a8_erratum_fixes,
    num_a8_erratum_fixes, fix_cortex_a8 fields.
    (elf32_arm_link_hash_table_create): Zero fix_cortex_a8.
    (elf32_arm_add_stub): Split into two parts, creating...
    (elf32_arm_create_or_find_stub_sec): New function.
    (elf32_arm_final_link_relocate): Add forward declaration.
    (arm_build_one_stub): Add support for THUMB32_TYPE, Thumb-2
    relocations, multiple relocations per stub.
    (find_stub_size_and_template): New (using parts of
    arm_size_one_stub).
    (arm_size_one_stub): Use find_stub_size_and_template.
    (a8_reloc_compare): New.
    (find_thumb_glue): Add forward declaration.
    (cortex_a8_erratum_scan): New.
    (elf32_arm_size_stubs): Add Cortex-A8 erratum workaround support.
    (bfd_elf32_arm_set_cortex_a8_fix): New.
    (bfd_elf32_arm_set_target_relocs): Add fix_cortex_a8 argument.
    (arm_map_one_stub): Add THUMB32_TYPE support.
    (a8_branch_to_stub_data): New.
    (make_branch_to_a8_stub): New.
    (elf32_arm_write_section): Add Cortex-A8 erratum workaround support.
    * bfd-in.h (bfd_elf32_arm_set_cortex_a8_fix): New.
    (bfd_elf32_arm_set_target_relocs): Add argument for controlling
    Cortex-A8 erratum workaround.
    * bfd-in2.h: Regenerate.

    ld/testsuite/
    * ld-arm/cortex-a8-arm-target.s: New.
    * ld-arm/cortex-a8-thumb-target.s: New.
    * ld-arm/cortex-a8-fix-b-rel.s: New.
    * ld-arm/cortex-a8-fix-b-rel-arm.d: New.
    * ld-arm/cortex-a8-fix-b-rel-thumb.d: New.
    * ld-arm/cortex-a8-fix-b.s: New.
    * ld-arm/cortex-a8-fix-b.d: New.
    * ld-arm/cortex-a8-fix-bl-rel.s: New.
    * ld-arm/cortex-a8-fix-bl-rel-arm.d: New.
    * ld-arm/cortex-a8-fix-bl-rel-thumb.d: New.
    * ld-arm/cortex-a8-fix-bl.s: New.
    * ld-arm/cortex-a8-fix-bl.d: New.
    * ld-arm/cortex-a8-fix-bcc-rel.s: New.
    * ld-arm/cortex-a8-fix-bcc-rel-thumb.d: New.
    * ld-arm/cortex-a8-fix-bcc.s: New.
    * ld-arm/cortex-a8-fix-bcc.d: New.
    * ld-arm/cortex-a8-fix-blx-rel.s: New.
    * ld-arm/cortex-a8-fix-blx-rel-arm.d: New.
    * ld-arm/cortex-a8-fix-blx-rel-thumb.d: New.
    * ld-arm/cortex-a8-fix-blx.s: New.
    * ld-arm/cortex-a8-fix-blx.d: New.
    * ld-arm/arm-elf.exp: Add new tests.
@
text
@d312 1
@


1.72
log
@2009-05-05  Paul Brook  <paul@@codesourcery.com>

	bfd/
	* bfd-in.h (elf32_arm_fix_exidx_coverage): Add prototype.
	* bfd-in2.h: Regenerate.
	* elf32-arm.c (arm_unwind_edit_type, arm_unwind_table_edit): Define.
	(_arm_elf_section_data): Add text and exidx fields.
	(add_unwind_table_edit, get_arm_elf_section_data, adjust_exidx_size,
	insert_cantunwind_after, elf32_arm_fix_exidx_coverage, offset_prel31,
	copy_exidx_entry): New functions.
	(elf32_arm_write_section): Fixup .ARM.exidx contents.

	ld/
	* emultempl/armelf.em (compare_output_sec_vma): New function.
	(gld${EMULATION_NAME}_finish): Add exidx munging code.

	ld/testsuite/
	* ld-arm/arm.ld: Add .ARM.exidx and .ARM.extab.
	* ld-arm/arm-elf.exp: Add unwind-[1-4].
	* ld-arm/unwind-1.d: New test.
	* ld-arm/unwind-1.s: New test.
	* ld-arm/unwind-2.d: New test.
	* ld-arm/unwind-2.s: New test.
	* ld-arm/unwind-3.d: New test.
	* ld-arm/unwind-3.s: New test.
	* ld-arm/unwind-4.d: New test.
	* ld-arm/unwind-4.s: New test.
@
text
@d40 1
d64 3
d465 1
a465 1
				   pic_veneer);
d527 2
d548 2
d576 1
d648 8
@


1.71
log
@	bfd/
	* elf32-arm.c (INTERWORK_FLAG): Check BFD_LINKER_CREATED.
	(elf32_arm_write_section): Declare early.
	(elf32_arm_size_stubs): Skip non-stub sections in the stub BFD.
	(arm_allocate_glue_section_space): Exclude empty sections.
	(ARM_GLUE_SECTION_FLAGS): Add SEC_LINKER_CREATED.
	(bfd_elf32_arm_add_glue_sections_to_bfd): Do not skip the stub
	BFD.
	(elf32_arm_output_glue_section, elf32_arm_final_link): New.
	(elf32_arm_merge_eabi_attributes): Skip the stub BFD.
	(elf32_arm_size_dynamic_sections): Allocate interworking
	sections here.
	(bfd_elf32_bfd_final_link): Define.

	ld/
	* emultempl/armelf.em (bfd_for_interwork, arm_elf_after_open)
	(arm_elf_set_bfd_for_interworking): Delete.
	(arm_elf_before_allocation): Do not set the interworking BFD.
	Move allocation inside not-dynamic block.
	(arm_elf_create_output_section_statements): Create glue sections
	and set the interworking BFD here.
	(LDEMUL_AFTER_OPEN): Delete.

	ld/testsuite/
	* ld-arm/farcall-mix.d, ld-arm/farcall-mix2.d,
	ld-arm/farcall-group-size2.d, ld-arm/farcall-group.d,
	ld-arm/farcall-mixed-lib.d: Update for linker changes.
@
text
@d261 22
d287 46
@


1.70
log
@2009-02-24  Joseph Myers  <joseph@@codesourcery.com>

	bfd/
	* elf32-arm.c (PREV_SEC): Update comment.
	(group_sections): Rename argument to stubs_always_after_branch.
	Reverse the list and place stubs at the end of input sections.
	Undefine NEXT_SEC.
	(elf32_arm_size_stubs): Update to use stubs_always_after_branch.

	ld/
	* ld.texinfo (ARM): Document changed meaning of --stub-group-size.
	* emultempl/armelf.em (hook_in_stub): Insert after the input section.
	(elf32_arm_add_stub_section): Update comment.
	(PARSE_AND_LIST_OPTIONS): Update help for --stub-group-size.

2009-02-24  Daniel Jacobowitz  <dan@@codesourcery.com>

	ld/testsuite/
	* ld-arm/arm-elf.exp (armeabitests): Update duplicate test names.
	Use normal output files for big-endian.
	* ld-arm/farcall-arm-arm-be.d, ld-arm/farcall-thumb-arm-be.d: Delete.
	* ld-arm/farcall-arm-arm-be8.d, ld-arm/farcall-arm-arm-pic-veneer.d,
	ld-arm/farcall-arm-arm.d, ld-arm/farcall-arm-thumb-blx-pic-veneer.d,
	ld-arm/farcall-arm-thumb-blx.d, ld-arm/farcall-arm-thumb-pic-veneer.d,
	ld-arm/farcall-arm-thumb.d, ld-arm/farcall-group-size2.d,
	ld-arm/farcall-group.d, ld-arm/farcall-mix.d, ld-arm/farcall-mix2.d,
	ld-arm/farcall-thumb-arm-be8.d,
	ld-arm/farcall-thumb-arm-blx-pic-veneer.d,
	ld-arm/farcall-thumb-arm-blx.d, ld-arm/farcall-thumb-arm-short.d,
	ld-arm/farcall-thumb-arm.d,
	ld-arm/farcall-thumb-thumb-blx-pic-veneer.d,
	ld-arm/farcall-thumb-thumb-blx.d, ld-arm/farcall-thumb-thumb-m.d,
	ld-arm/farcall-thumb-thumb.d, ld-arm/thumb2-bl-as-thumb1-bad.d,
	ld-arm/thumb2-bl-bad.d: Update for moved stubs.
@
text
@a33 1
static bfd *bfd_for_interwork;
a54 38
arm_elf_after_open (void)
{
  {
    LANG_FOR_EACH_INPUT_STATEMENT (is)
      {
	bfd_elf32_arm_add_glue_sections_to_bfd (is->the_bfd, & link_info);
      }
  }

  /* Call the standard elf routine.  */
  gld${EMULATION_NAME}_after_open ();
}

static void
arm_elf_set_bfd_for_interworking (lang_statement_union_type *statement)
{
  if (statement->header.type == lang_input_section_enum)
    {
      asection *i = statement->input_section.section;

      if (!((lang_input_statement_type *) i->owner->usrdata)->just_syms_flag
	  && (i->flags & SEC_EXCLUDE) == 0)
	{
	  asection *output_section = i->output_section;

	  ASSERT (output_section->owner == link_info.output_bfd);

	  /* Don't attach the interworking stubs to a dynamic object, to
	     an empty section, etc.  */
	  if ((output_section->flags & SEC_HAS_CONTENTS) != 0
	      && (i->flags & SEC_NEVER_LOAD) == 0
	      && ! (i->owner->flags & DYNAMIC))
	    bfd_for_interwork = i->owner;
	}
    }
}

static void
a56 15
  if (link_info.input_bfds != NULL)
    {
      /* The interworking bfd must be the last one in the link.  */
      bfd_for_interwork = NULL;

      lang_for_each_statement (arm_elf_set_bfd_for_interworking);

      /* If bfd_for_interwork is NULL, then there are no loadable sections
	 with real contents to be linked, so we are not going to have to
	 create any interworking stubs, so it is OK not to call
	 bfd_elf32_arm_get_bfd_for_interworking.  */
      if (bfd_for_interwork != NULL)
	bfd_elf32_arm_get_bfd_for_interworking (bfd_for_interwork, &link_info);
    }

d79 3
a85 3

  /* We have seen it all. Allocate it, and carry on.  */
  bfd_elf32_arm_allocate_interworking_sections (& link_info);
d410 4
d573 1
a573 1
# We have our own after_open and before_allocation functions, but they call
a574 1
LDEMUL_AFTER_OPEN=arm_elf_after_open
@


1.69
log
@2009-01-29  Andrew Jenner  <andrew@@codesourcery.com>

	* emultempl/armelf.em: Correct formatting of help text for
	--no-enum-size-warning option.
@
text
@d216 3
a218 3
		 before its associated input section.  */
	      *lp = info->add.head;
	      *(info->add.tail) = l;
d247 1
a247 1
   immediately before INPUT_SECTION.  */
d544 1
a544 1
                           locates all stubs before their branches (with a\n\
@


1.68
log
@        * emultempl/armelf.em (arm_elf_after_open): Move check for using a
        non-arm output target from here...
        (arm_elf_create_output_section_statements): ... to here, so that
        the check is made at the earliest possible opportunity.
@
text
@d536 1
a536 1
  fprintf (file, _("  --no-enum-size-warning      Don'\''t warn about objects with incompatible"
@


1.67
log
@	* emultempl/armelf.em (PARSE_AND_LIST_OPTIONS): Correct typo in
	help text of --be8.
@
text
@a57 10
  if (strstr (bfd_get_target (link_info.output_bfd), "arm") == NULL)
    {
      /* The arm backend needs special fields in the output hash structure.
	 These will only be created if the output format is an arm format,
	 hence we do not support linking and changing output formats at the
	 same time.  Use a link followed by objcopy to change output formats.  */
      einfo ("%F%X%P: error: cannot change output format whilst linking ARM binaries\n");
      return;
    }

d432 10
@


1.66
log
@PR 6727
   * emultempl/armelf.em (arm_elf_set_bfd_for_interworking): Scan all
   input sections in all input bfds and always select the last
   suitable one, so that interworking stubs are always processed
   after all other input sections.
   (arm_elf_before_allocation): Remove redundant use of
   output_has_begun flag.
@
text
@d528 1
a528 1
  fprintf (file, _("  --be8                       Oputput BE8 format image\n"));
@


1.65
log
@bfd:
	* bfd-in.h (bfd_elf32_arm_set_target_relocs): Add new parameter.
	* bfd-in2.h: Regenerate.
	* elf32-arm.c (struct elf_arm_obj_tdata): Add field
	no_wchar_size_warning.
	(bfd_elf32_arm_set_target_relocs): Add new parameter
	no_wchar_warn.
	(elf32_arm_merge_eabi_attributes): Give a warning, not an error,
	for conflicting wchar_t attributes.  Do not warn if
	--no-wchar-size-warning.  Make diagnostic text more specific.

ld:
	* ld.texinfo (--no-wchar-size-warning): Document new ARM option.
	* emultempl/armelf.em (no_wchar_size_warning): New.
	(arm_elf_create_output_section_statements): Pass
	no_wchar_size_warning to arm_elf_create_output_section_statements.
	(OPTION_NO_WCHAR_SIZE_WARNING): New.
	(PARSE_AND_LIST_LONGOPTS): Add no-wchar-size-warning.
	(PARSE_AND_LIST_OPTIONS): List --no-wchar-size-warning.
	(PARSE_AND_LIST_ARGS_CASES): Handle --no-wchar-size-warning.

ld/testsuite:
	* ld-arm/attr-merge-wchar-0.s,ld-arm/attr-merge-wchar-2.s,
	ld-arm/attr-merge-wchar-4.s, ld-arm/attr-merge-wchar-00-nowarn.d,
	ld-arm/attr-merge-wchar-00.d, ld-arm/attr-merge-wchar-02-nowarn.d,
	ld-arm/attr-merge-wchar-02.d, ld-arm/attr-merge-wchar-04-nowarn.d,
	ld-arm/attr-merge-wchar-04.d, ld-arm/attr-merge-wchar-20-nowarn.d,
	ld-arm/attr-merge-wchar-20.d, ld-arm/attr-merge-wchar-22-nowarn.d,
	ld-arm/attr-merge-wchar-22.d, ld-arm/attr-merge-wchar-24-nowarn.d,
	ld-arm/attr-merge-wchar-24.d, ld-arm/attr-merge-wchar-40-nowarn.d,
	ld-arm/attr-merge-wchar-40.d, ld-arm/attr-merge-wchar-42-nowarn.d,
	ld-arm/attr-merge-wchar-42.d, ld-arm/attr-merge-wchar-44-nowarn.d,
	ld-arm/attr-merge-wchar-44.d: New.
	* ld-arm/arm-elf.exp: Run new tests.
@
text
@d97 2
a98 6
	      && ! (i->owner->flags & DYNAMIC)
	      && ! i->owner->output_has_begun)
	    {
	      bfd_for_interwork = i->owner;
	      bfd_for_interwork->output_has_begun = TRUE;
	    }
a105 2
  bfd *tem;

a109 2
      for (tem = link_info.input_bfds; tem != NULL; tem = tem->link_next)
	tem->output_has_begun = FALSE;
a111 2
      for (tem = link_info.input_bfds; tem != NULL; tem = tem->link_next)
	tem->output_has_begun = FALSE;
@


1.64
log
@	* emultempl/armelf.em (elf32_arm_add_stub_section): Use
	bfd_make_section_with_flags.
	* emultempl/avrelf.em (avr_elf_create_output_section_statements):
	Likewise.
	* emultempl/hppaelf.em (hppaelf_add_stub_section): Likewise.
	* emultempl/m68hc1xelf.em (m68hc11elf_add_stub_section): Likewise.
	* emultempl/m68kcoff.em (gld${EMULATION_NAME}_after_open): Likewise.
	* emultempl/m68kelf.em (m68k_elf_after_open): Likewise.
	* emultempl/ppc64elf.em (ppc_add_stub_section): Likewise.
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation):
	Likewise.
@
text
@d42 1
d456 1
d514 1
d533 1
d548 2
d614 4
@


1.63
log
@        ld/testsuite/
        * ld-arm/arm-elf.exp: Skip farcalls tests for non-ARM-EABI
        targets.
        * ld-arm/thumb2-bl-as-thumb1-bad-noeabi.d: New file.
        * ld-arm/thumb2-bl-bad-noeabi.d: Likewise.

        ld/
        * ld.texinfo: State that farcalls stubs are supported for ARM-EABI
        only.
@
text
@a278 4
  stub_sec = bfd_make_section_anyway (stub_file->the_bfd, stub_sec_name);
  if (stub_sec == NULL)
    goto err_ret;

d281 3
a283 1
  if (!bfd_set_section_flags (stub_file->the_bfd, stub_sec, flags))
@


1.62
log
@        bfd/
        * elf32-arm.c (THM2_MAX_FWD_BRANCH_OFFSET): Define.
        (THM2_MAX_BWD_BRANCH_OFFSET): Define.
        (ARM_MAX_FWD_BRANCH_OFFSET): Define.
        (ARM_MAX_BWD_BRANCH_OFFSET): Define.
        (THM_MAX_FWD_BRANCH_OFFSET): Define.
        (THM_MAX_BWD_BRANCH_OFFSET): Define.
        (arm_long_branch_stub): Define.
        (arm_pic_long_branch_stub): Define.
        (arm_thumb_v4t_long_branch_stub): Define.
        (arm_thumb_thumb_long_branch_stub): Define.
        (arm_thumb_arm_v4t_long_branch_stub): Define.
        (STUB_SUFFIX): Define.
        (elf32_arm_stub_type): Define.
        (elf32_arm_stub_hash_entry): Define.
        (elf32_arm_link_hash_entry): Add stub_cache field.
        (arm_stub_hash_lookup): Define.
        (elf32_arm_link_hash_table): Add stub_hash_table, stub_bfd,
        add_stub_section, layout_sections_again, stub_group, bfd_count,
        top_index, input_list fields.
        (elf32_arm_link_hash_newfunc): Init new field.
        (stub_hash_newfunc): New function.
        (elf32_arm_link_hash_table_create): Init stub_hash_table.
        (elf32_arm_hash_table_free): New function.
        (arm_type_of_stub): New function.
        (elf32_arm_stub_name): New function.
        (elf32_arm_get_stub_entry): New function.
        (elf32_arm_stub_add_mapping_symbol): New function.
        (elf32_arm_add_stub): New function.
        (arm_build_one_stub): New function.
        (arm_size_one_stub): New function.
        (elf32_arm_setup_section_lists): New function.
        (elf32_arm_next_input_section): New function.
        (group_sections): New function.
        (elf32_arm_size_stubs): New function.
        (elf32_arm_build_stubs): New function.
        (bfd_elf32_arm_add_glue_sections_to_bfd): Skip stub sections.
        (bfd_elf32_arm_process_before_allocation): No longer handle
        R_ARM_CALL and R_ARM_THM_CALL.
        (using_thumb_only): New function.
        (elf32_arm_final_link_relocate): Redirect calls to stub if range
        exceeds encoding capabilities.
        (bfd_elf32_bfd_link_hash_table_free): Define.
        * bfd-in.h (R_ARM_max): Fix value to 130.
        (elf32_arm_setup_section_lists): Protype.
        (elf32_arm_next_input_section): Protype.
        (elf32_arm_size_stubs): Protype.
        (elf32_arm_build_stubs): Protype.

        ld/
        * emultempl/armelf.em (build_section_lists): New function.
        (stub_file): Define.
        (need_laying_out): Define.
        (group_size): Define.
        (hook_stub_info): Define.
        (hook_in_stub): New function.
        (elf32_arm_add_stub_section): New function.
        (gldarm_layout_sections_again): New function.
        (gld${EMULATION_NAME}_finish): Replace arm_elf_finish(). Generate
        stubs for long calls if needed.
        (arm_elf_create_output_section_statements): create stub_file bfd.
        (arm_for_each_input_file_wrapper): New function.
        (arm_lang_for_each_input_file): New function.
        (lang_for_each_input_file): Define.
        (PARSE_AND_LIST_PROLOGUE): Add option token OPTION_STUBGROUP_SIZE.
        (PARSE_AND_LIST_LONGOPTS): Add option stub-group-size.
        (PARSE_AND_LIST_OPTIONS): Add option stub-group-size.
        (PARSE_AND_LIST_ARGS_CASES): Add OPTION_STUBGROUP_SIZE case.
        (LDEMUL_FINISH): Update to gld${EMULATION_NAME}_finish.
        * ld/lang.c (print_input_statement): Skip if bfd has
        BFD_LINKER_CREATED.

        ld/testsuite
        * ld-arm/arm-elf.exp (armelftests): Add farcall-arm-arm,
        farcall-arm-arm-pic-veneer, farcall-arm-arm-be8 farcall-arm-thumb,
        farcall-arm-thumb-blx, farcall-arm-thumb-pic-veneer,
        farcall-arm-thumb-blx-pic-veneer, farcall-thumb-thumb,
        farcall-thumb-thumb-pic-veneer, farcall-thumb-thumb-blx,
        farcall-thumb-thumb-m, farcall-thumb-thumb-m-pic-veneer,
        farcall-thumb-thumb-blx-pic-veneer, farcall-thumb-arm,
        farcall-thumb-arm-pic-veneer, farcall-thumb-arm-blx,
        farcall-thumb-arm-blx-pic-veneer.
        Change thumb2-bl-as-thumb1-bad, thumb2-bl-bad.
        * ld-arm/thumb2-bl-as-thumb1-bad.d: Reflects farcall stub
        generation.
        * ld-arm/thumb2-bl-bad.d: Likewise.
        * ld-arm/thumb2-bl-as-thumb1-bad.s: Update comments.
        * ld-arm/thumb2-bl-bad.s: Likewise.
@
text
@d358 1
a358 1
	      einfo ("%X%P: can not size stub section: %E\n");
d372 1
a372 1
	      einfo ("%X%P: can not size stub section: %E\n");
@


1.61
log
@2008-02-20  Paul Brook  <paul@@codesourcery.com>

	ld/
	* emultempl/armelf.em (OPTION_FIX_V4BX_INTERWORKING): Define.
	(PARSE_AND_LIST_LONGOPTS): Add fix-v4bx-interworking.
	(PARSE_AND_LIST_OPTIONS): Ditto.
	(PARSE_AND_LIST_ARGS_CASES): Handle OPTION_FIX_V4BX_INTERWORKING.
	* emulparams/armelf.sh (OTHER_TEXT_SECTIONS): Add .v4_bx.
	* emulparams/armelf_linux.sh (OTHER_TEXT_SECTIONS): Ditto.
	* emulparams/armnto.sh (OTHER_TEXT_SECTIONS): Ditto.
	* ld.texinfo: Document --fix-v4bx-interworking.

	ld/testsuite/
	* ld-arm/armv4-bx.d: New test.
	* ld-arm/armv4-bx.s: New test.
	* ld-arm/arm.ld: Add .v4bx.
	* ld-arm/arm-elf.exp: Add armv4-bx.

	gas/testsuite/
	* gas/arm/thumb.d: Exclude EABI targets.
	* gas/arm/arch4t.d: Exclude EABI targts.
	* gas/arm/v4bx.d: New test.
	* gas/arm/v4bx.s: New test.
	* gas/arm/thumb-eabi.d: New test.
	* gas/arm/arch4t-eabi.d: New test.

	gas/
	* config/tc-arm.c (fix_v4bx): New variable.
	(do_bx): Generate V4BX relocations.
	(md_assemble): Allow bx on v4 codes when fix_v4bx.
	(md_apply_fix): Handle BFD_RELOC_ARM_V4BX.
	(tc_gen_reloc): Ditto.
	(OPTION_FIX_V4BX): Define.
	(md_longopts): Add fix-v4bx.
	(md_parse_option): Handle OPTION_FIX_V4BX.
	(md_show_usage): Document --fix-v4bx.
	* doc/c-arm.texi: Document --fix-v4bx.

	bfd/
	* reloc.c: Add BFD_RELOC_ARM_V4BX.
	* elf32-arm.c (elf32_arm_reloc_map): Add BFD_RELOC_ARM_V4BX.
	(ARM_BX_GLUE_SECTION_NAME, ARM_BX_GLUE_SECTION_NAME): Define.
	(elf32_arm_link_hash_table): Add bx_glue_size and bx_glue_offset.
	Update comment for fix_v4bx.
	(elf32_arm_link_hash_table_create): Zero bx_glue_size and
	bx_glue_offset.
	(ARM_BX_VENEER_SIZE, armbx1_tst_insn, armbx2_moveq_insn,
	armbx3_bx_insn): New.
	(bfd_elf32_arm_allocate_interworking_sections): Allocate BX veneer
	section.
	(bfd_elf32_arm_add_glue_sections_to_bfd): Ditto.
	(bfd_elf32_arm_process_before_allocation): Record BX veneers.
	(record_arm_bx_glue, elf32_arm_bx_glue): New functions.
	(elf32_arm_final_link_relocate): Handle BX veneers.
	(elf32_arm_output_arch_local_syms): Output mapping symbol for .v4_bx.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d30 1
d177 159
d337 1
a337 1
arm_elf_finish (void)
d341 51
a391 2
  /* Call the elf32.em routine.  */
  gld${EMULATION_NAME}_finish ();
d458 27
d487 9
d513 1
d531 1
d547 9
d613 10
d636 1
a636 1
LDEMUL_FINISH=arm_elf_finish
@


1.60
log
@include/
	* bfdlink.h (struct bfd_link_hash_table): Delete creator field.
	(struct bfd_link_info): Add output_bfd.
bfd/
	* elflink.c: Replace all accesses to hash->creator field with
	output_bfd->xvec.
	* cofflink.c: Likewise.
	* coff-h8300.c: Likewise.
	* ecoff.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sparc.c: Likewise.
	* elfxx-mips.c: Likewise.
	* i386linux.c: Likewise.
	* m68klinux.c: Likewise.
	* sparclinux.c: Likewise.
	* sunos.c: Likewise.
	* xcofflink.c: Likewise.
	* linker.c: Likewise.
	(_bfd_link_hash_table_init): Don't store creator.
ld/
	* ldmain.h (output_bfd): Delete.
	* ldmain.c (output_bfd): Delete.
	Replace all occurrences of output_bfd with link_info.output_bfd.
	* ldcref.c: Likewise.
	* ldctor.c: Likewise.
	* ldemul.c: Likewise.
	* ldexp.c: Likewise.
	* ldfile.c: Likewise.
	* ldlang.c: Likewise.
	* ldmisc.c: Likewise.
	* ldwrite.c: Likewise.
	* pe-dll.c: Likewise.
	* emultempl/aix.em: Likewise.
	* emultempl/alphaelf.em: Likewise.
	* emultempl/armcoff.em: Likewise.
	* emultempl/armelf.em: Likewise.
	* emultempl/avrelf.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/elf-generic.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/irix.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68hc1xelf.em: Likewise.
	* emultempl/mmix-elfnmmo.em: Likewise.
	* emultempl/mmo.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/scoreelf.em: Likewise.
	* emultempl/sh64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/vanilla.em: Likewise.
	* emultempl/vxworks.em: Likewise.
	* emultempl/xtensaelf.em: Likewise.
	* emultempl/z80.em: Likewise.
	* ldlang.c (open_output): Don't return output, instead write
	link_info_output_bfd directly.
	* emultempl/alphaelf.em: Replace occurrences of link_info.hash->creator
	with link_info.output_bfd->xvec.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
@
text
@d267 1
d280 1
d294 1
d331 4
@


1.59
log
@PR linker/5097
* emultempl/armelf.em (arm_elf_finish): Fix spelling typo.
@
text
@d3 1
a3 1
#   2004, 2005, 2007
d56 1
a56 1
  if (strstr (bfd_get_target (output_bfd), "arm") == NULL)
d89 1
a89 1
	  ASSERT (output_section->owner == output_bfd);
d133 1
a133 1
  bfd_elf32_arm_set_vfp11_fix (output_bfd, &link_info);
d215 1
a215 1
	     + bfd_get_section_vma (output_bfd,
d244 2
a245 1
  bfd_elf32_arm_set_target_relocs (output_bfd, &link_info, target1_is_rel,
@


1.58
log
@	* emultempl/alphaelf.em: Format option help.
	* emultempl/armcoff.em: Likewise.
	* emultempl/armelf.em: Likewise.
	* emultempl/avrelf.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/ia64elf.em: Likewise.
	* emultempl/m68hc1xelf.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/scoreelf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/ticoff.em: Likewise.
	* emultempl/vxworks.em: Likewise.
	* emultempl/xtensaelf.em: Likewise.
@
text
@d235 1
a235 1
    einfo (_("%P: warning: connot find thumb start symbol %s\n"),
@


1.57
log
@2007-07-19  Roland McGrath  <roland@@redhat.com>

	* genscripts.sh (source_em, fragment): New sh functions.
	Truncate e${EMULATION_NAME}.c file before .em script fills it.
	Use source_em in place of . for the .em script.
	* emultempl/generic.em: Use fragment and source_em functions.
	* emultempl/aix.em: Likewise.
	* emultempl/alphaelf.em: Likewise.
	* emultempl/armcoff.em: Likewise.
	* emultempl/armelf.em: Likewise.
	* emultempl/avrelf.em: Likewise.
	* emultempl/beos.em: Likewise.
	* emultempl/cr16elf.em: Likewise.
	* emultempl/crxelf.em: Likewise.
	* emultempl/elf-generic.em: Likewise.
	* emultempl/elf32.em: Likewise.
	* emultempl/genelf.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/gld960c.em: Likewise.
	* emultempl/hppaelf.em: Likewise.
	* emultempl/ia64elf.em: Likewise.
	* emultempl/irix.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68hc1xelf.em: Likewise.
	* emultempl/m68kcoff.em: Likewise.
	* emultempl/m68kelf.em: Likewise.
	* emultempl/mipsecoff.em: Likewise.
	* emultempl/mipself.em: Likewise.
	* emultempl/mmix-elfnmmo.em: Likewise.
	* emultempl/mmixelf.em: Likewise.
	* emultempl/mmo.em: Likewise.
	* emultempl/needrelax.em: Likewise.
	* emultempl/netbsd.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/pep.em: Likewise.
	* emultempl/ppc32elf.em: Likewise.
	* emultempl/ppc64elf.em: Likewise.
	* emultempl/scoreelf.em: Likewise.
	* emultempl/sh64elf.em: Likewise.
	* emultempl/spuelf.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/ticoff.em: Likewise.
	* emultempl/vanilla.em: Likewise.
	* emultempl/vxworks.em: Likewise.
	* emultempl/xtensaelf.em: Likewise.
	* emultempl/z80.em: Likewise.
@
text
@d285 11
a295 10
  fprintf (file, _("     --thumb-entry=<sym>      Set the entry point to be Thumb symbol <sym>\n"));
  fprintf (file, _("     --be8                    Oputput BE8 format image\n"));
  fprintf (file, _("     --target1=rel            Interpret R_ARM_TARGET1 as R_ARM_REL32\n"));
  fprintf (file, _("     --target1=abs            Interpret R_ARM_TARGET1 as R_ARM_ABS32\n"));
  fprintf (file, _("     --target2=<type>         Specify definition of R_ARM_TARGET2\n"));
  fprintf (file, _("     --fix-v4bx               Rewrite BX rn as MOV pc, rn for ARMv4\n"));
  fprintf (file, _("     --use-blx                Enable use of BLX instructions\n"));
  fprintf (file, _("     --vfp11-denorm-fix       Specify how to fix VFP11 denorm erratum\n"));
  fprintf (file, _("     --no-enum-size-warning   Don'\''t warn about objects with incompatible enum sizes\n"));
  fprintf (file, _("     --pic-veneer             Always generate PIC interworking veneers\n"));
@


1.56
log
@Update sources to GPLv3
@
text
@d28 1
a28 1
cat >>e${EMULATION_NAME}.c <<EOF
d329 1
a329 1
    
@


1.55
log
@2007-03-20  Paul Brook  <paul@@codesourcery.com>

	ld/
	* emultempl/armelf.em (pic_veneer): New variable.
	(PARSE_AND_LIST_PROLOGUE): Add OPTION_PIC_VENEER.
	(PARSE_AND_LIST_ARGS_CASES): Ditto.
	(PARSE_AND_LIST_LONGOPTS): Add "pic-veneer".
	(PARSE_AND_LIST_OPTIONS): Ditto.
	* ld.texinfo: Document --pic-veneer.

	ld/testsuite/
	* ld-arm/arm-elf.exp (ld-arm/arm-elf.exp): Add arm-pic-veneer.
	* ld-arm/arm-pic-veneer.d: New test.
	* ld-arm/arm-pic-veneer.s: New test.

	bfd/
	* bfd-in.h (bfd_elf32_arm_set_target_relocs): Update prototype.
	* bfd-in2.h: Regenerate.
	* elf32-arm.c (elf32_arm_link_hash_table): Add pic_veneer.
	(record_arm_to_thumb_glue): Use globals->pic_veneer.
	(elf32_arm_create_thumb_stub): Ditto.
	(bfd_elf32_arm_set_target_relocs): Set globals->pic_veneer.
@
text
@d3 1
a3 1
#   2004, 2005
d6 1
a6 1
# This file is part of GLD, the Gnu Linker.
d10 1
a10 1
# the Free Software Foundation; either version 2 of the License, or
d20 2
a21 1
# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
@


1.54
log
@	bfd/
	* bfd-in.h (bfd_elf32_arm_set_target_relocs): Add "bfd *"
	argument and extra last argument.
	* bfd-in2.h: Regenerate.
	* elf32-arm.c (elf32_arm_obj_tdata): Add no_enum_size_warning
	member.
	(bfd_elf32_arm_set_target_relocs): Add "bfd *" argument and
	extra last argument.  Set no_enum_size_warning appropriately.
	(elf32_arm_merge_eabi_attributes): Improve enum sizes
	diagnostic, suppressing it when no_enum_size_warning dictates.

	ld/
	* ld.texinfo: Document --no-enum-size-warning.
	* emultempl/armelf.em (no_enum_size_warning): New.
	(arm_elf_create_output_section_statements): Correct typo
	in comment.  Pass no_enum_size_warning to
	bfd_elf32_arm_set_target_relocs.
	(PARSE_AND_LIST_PROLOGUE): Define OPTION_NO_ENUM_SIZE_WARNING.
	(PARSE_AND_LIST_OPTIONS): Document --no-enum-size-warning.
	(PARSE_AND_LIST_ARGS_CASES): Add OPTION_NO_ENUM_SIZE_WARNING
	case.
@
text
@d40 1
d245 2
a246 1
				   vfp11_denorm_fix, no_enum_size_warning);
d264 1
d280 1
d293 1
d343 4
@


1.53
log
@	* NEWS: Mention --vfp11-denorm-fix option.
	* ld.texinfo: Document above.
	* emulparams/armelf_linux.sh (OTHER_TEXT_SECTIONS): Add
	.vfp11_veneer section.
	* emulparams/armelf.sh (OTHER_TEXT_SECTIONS): Likewise.
	* emultempl/armelf.em (vfp11_denorm_fix): New static variable.
	(arm_elf_before_allocation): Call bfd_elf32_arm_set_vfp11_fix,
	bfd_elf32_arm_init_maps and bfd_elf32_arm_vfp11_erratum_scan.
	(arm_elf_after_allocation): New function. Call
	bfd_elf32_arm_vfp11_fix_veneer_locations for all input statements.
	(arm_elf_create_output_section_statements): Pass vfp11 fix command
	line option to BFD.
	(OPTION_VFP11_DENORM_FIX): New option.
	(PARSE_AND_LIST_LONGOPTS): Handle new option.
	(PARSE_AND_LIST_OPTIONS): Likewise.
	(PARSE_AND_LIST_ARGS_CASES): Likewise.
	(LDEMUL_AFTER_ALLOCATION): Define.
@
text
@d39 1
d237 1
a237 1
/* This is a convenitent point to tell BFD about target specific flags.
d242 3
a244 2
  bfd_elf32_arm_set_target_relocs (&link_info, target1_is_rel, target2_type,
                                   fix_v4bx, use_blx, vfp11_denorm_fix);
d261 1
d276 1
d288 1
d334 4
@


1.52
log
@bfd/
	* bfd-in.h (bfd_elf32_arm_process_before_allocation): Update
	prototype.
	(bfd_elf32_arm_set_byteswap_code): New prototype.
	* bfd-in2.h: Regenerate.
	* elf32-arm.c (bfd_elf32_arm_process_before_allocation): Don't take
	byteswap_code as an argument.  Revert 2006-11-01 change.
	(bfd_elf32_arm_set_byteswap_code): New.
	(elf32_arm_size_dynamic_sections): Call
	bfd_elf32_arm_process_before_allocation.
ld/
	* emultempl/armelf.em (arm_elf_before_allocation): Only call
	bfd_elf32_arm_process_before_allocation if no dynamic sections.
@
text
@d38 1
d128 4
d139 3
d143 2
a144 1
							&link_info))
d158 16
d242 1
a242 1
                                   fix_v4bx, use_blx);
d258 1
d272 1
d283 1
d318 11
d335 1
@


1.51
log
@missed from 2006-10-19 commit.
@
text
@a123 1
  /* We should be able to set the size of the interworking stub section.  */
d125 11
a135 8
  /* Here we rummage through the found bfds to collect glue information.  */
  /* FIXME: should this be based on a command line option? krk@@cygnus.com  */
  {
    LANG_FOR_EACH_INPUT_STATEMENT (is)
      {
	if (!bfd_elf32_arm_process_before_allocation (is->the_bfd, & link_info,
						      byteswap_code))
	  {
d138 2
a139 3
	  }
      }
  }
@


1.50
log
@2006-08-18  Paul Brook  <paul@@codesourcery.com>

	bfd/
	* elf32-arm.c (elf32_arm_link_hash_entry): Add export_glue.
	(elf32_arm_link_hash_newfunc): Initialize export_glue.
	(record_arm_to_thumb_glue): Return stub symbol.
	(elf32_arm_create_thumb_stub): New function.
	(elf32_arm_to_thumb_stub): Use it.
	(elf32_arm_to_thumb_export_stub): New function.
	(elf32_arm_begin_write_processing): New function.
	(allocate_dynrelocs): Allocate Arm stubs.
	(elf_backend_begin_write_processing): Define.
	(elf32_arm_symbian_begin_write_processing): Remove ATTRIBUTE_UNUSED.
	Call elf32_arm_begin_write_processing.

	ld/
	* emultempl/armelf.em (arm_elf_before_allocation): Call
	gld${EMULATION_NAME}_before_allocation after setting interworking bfd.

	ld/testsuite/
	* ld-arm/arm-elf.exp (armelftests): Add armthumb-lib.so.  Add
	-use-blx to mixed-lib.so
	* ld-arm/armthumb-lib.d: New file.
	* ld-arm/armthumb-lib.sym: New file.
@
text
@a125 3
  /* Call the standard elf routine.  */
  gld${EMULATION_NAME}_before_allocation ();

d140 3
@


1.49
log
@2006-02-07  Paul Brook  <paul@@codesourcery.com>

ld/
	* emultempl/armelf.em: Include elf/arm.h.
	(arm_elf_finish): Set low address bit if enty point is a Thumb
	function.
ld/testsuite/
	* ld-arm/arm-elf.exp: Add thumb-entry test.
	* ld-arm/thumb-entry.d: New test.
	* ld-arm/thumb-entry.s: New test.
@
text
@a105 3
  /* Call the standard elf routine.  */
  gld${EMULATION_NAME}_before_allocation ();

d126 3
@


1.49.2.1
log
@2006-08-18  Paul Brook  <paul@@codesourcery.com>

	Backport from mainline.
	bfd/
	* elf32-arm.c (elf32_arm_link_hash_entry): Add export_glue.
	(elf32_arm_link_hash_newfunc): Initialize export_glue.
	(record_arm_to_thumb_glue): Return stub symbol.
	(elf32_arm_create_thumb_stub): New function.
	(elf32_arm_to_thumb_stub): Use it.
	(elf32_arm_to_thumb_export_stub): New function.
	(elf32_arm_begin_write_processing): New function.
	(allocate_dynrelocs): Allocate Arm stubs.
	(elf_backend_begin_write_processing): Define.
	(elf32_arm_symbian_begin_write_processing): Remove ATTRIBUTE_UNUSED.
	Call elf32_arm_begin_write_processing.

	ld/
	* emultempl/armelf.em (arm_elf_before_allocation): Call
	gld${EMULATION_NAME}_before_allocation after setting interworking bfd.

	ld/testsuite/
	* ld-arm/arm-elf.exp (armelftests): Add armthumb-lib.so.  Add
	-use-blx to mixed-lib.so
	* ld-arm/armthumb-lib.d: New file.
	* ld-arm/armthumb-lib.sym: New file.
@
text
@d106 3
a128 3
  /* Call the standard elf routine.  */
  gld${EMULATION_NAME}_before_allocation ();

@


1.48
log
@	* ldlang.h (lang_input_section_type): Remove "ifile" field.
	(lang_insert_orphan, lang_add_section): Update prototypes.
	* ldlang.c (lang_insert_orphan): Remove "file" param.
	(lang_add_section): Likewise.  Update all callers.
	(wild_sort): Get an input section's bfd via "section->owner".
	(size_input_section): Access just_syms_flag via bfd usrdata.
	(lang_place_orphans): Update ldemul_place_orphan call.
	* ldemul.h (ldemul_place_orphan): Remove input_statement param.
	(struct ld_emulation_xfer_struct <place_orphan>): Likewise.
	* ldemul.c (ldemul_place_orphan): Likewise.
	* ldwrite.c (build_link_order): Access just_syms_flag via bfd usrdata.
	* emultempl/armelf.em (arm_elf_set_bfd_for_interworking): Likewise.
	* emultempl/beos.em (sort_by_file_name): Access bfd by section->owner.
	(sort_sections): Likewise.
	(place_orphan): Remove "file" param.  Adjust lang_add_section call.
	* emultempl/elf32.em (place_orphan): Remove "file" param.  Adjust
	lang_add_section and lang_insert_orphan calls.
	* emultempl/hppaelf.em (hppaelf_add_stub_section): Adjust
	lang_add_section call.
	(build_section_lists): Access just_syms_flag via bfd usrdata.
	* emultempl/m68hc1xelf.em (m68hc11elf_add_stub_section): Adjust
	lang_add_section call.
	* emultempl/mmo.em (mmo_place_orphan): Remove "file" param.  Adjust
	lang_add_section and lang_insert_orphan calls.
	* emultempl/pe.em (place_orphan): Likewise.  Access bfd via section
	owner.
	* emultempl/ppc64elf.em (ppc_add_stub_section): Adjust
	lang_add_section call.
	(build_toc_list): Access just_syms_flag via bfd usrdata.
	(build_section_lists): Likewise.
	* emultempl/xtensaelf.em (elf_xtensa_place_orphan): Remove "file"
	param.  Adjust place_orphan call.
	(ld_build_required_section_dependence): Access bfd via section owner.
@
text
@d29 2
d155 18
a172 2
  if (thumb_entry_symbol == NULL)
    return;
a173 2
  h = bfd_link_hash_lookup (link_info.hash, thumb_entry_symbol,
			    FALSE, FALSE, TRUE);
d199 2
a200 1
      if (entry_symbol.name != NULL && entry_from_cmdline)
@


1.47
log
@Add quotes to avoid a null test expression.
@
text
@d74 1
a74 3
  if (statement->header.type == lang_input_section_enum
      && !statement->input_section.ifile->just_syms_flag
      && (statement->input_section.section->flags & SEC_EXCLUDE) == 0)
a76 1
      asection *output_section = i->output_section;
d78 6
a83 1
      ASSERT (output_section->owner == output_bfd);
d85 10
a94 9
      /* Don't attach the interworking stubs to a dynamic object, to
	 an empty section, etc.  */
      if ((output_section->flags & SEC_HAS_CONTENTS) != 0
	  && (i->flags & SEC_NEVER_LOAD) == 0
	  && ! (i->owner->flags & DYNAMIC)
	  && ! i->owner->output_has_begun)
	{
	  bfd_for_interwork = i->owner;
	  bfd_for_interwork->output_has_begun = TRUE;
@


1.46
log
@Update FSF addresses
@
text
@d26 1
a26 1
test -z $TARGET2_TYPE && TARGET2_TYPE="rel"
@


1.45
log
@	* bfd/bfd-in.h (bfd_elf32_arm_set_target_relocs): Update prototype.
	* bfd/bfd-in2.h: Regenerate.
	* bfd/elf32-arm.c (elf32_arm_link_hash_table): New field, 'use_blx'.
	(elf32_arm_link_hash_table_create): Initialise fix_v4bx, use_blx.
	(bfd_elf32_arm_set_target_relocs): Handle use_blx.
	(elf32_arm_final_link_relocate): Use Thumb BLX for R_ARM_THM_PC22
	relocations if requested to.
	(allocate_dynrelocs): Don't count size of omitted Thumb stubs based on
	use_blx rather than symbian_p.
	(elf32_arm_finish_dynamic_symbol): Don't output Thumb PLT stubs if
	use_blx is in effect.
	(elf32_arm_symbian_link_hash_table_create): Enable use_blx by default
	for SymbianOS.
	* ld/ld.texinfo: Document --use-blx.
	* ld/emultempl/armelf.em (use_blx): New variable.
	(arm_elf_create_output_section_statements): Communicate value of
	use_blx to bfd.
	(PARSE_AND_LIST_PROLOGUE): Add OPTION_USE_BLX.
	(PARSE_AND_LIST_OPTIONS): Add --use-blx option.
	(PARSE_AND_LIST_ARGS_CASES): Add OPTION_USE_BLX case.
@
text
@d20 1
a20 1
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
@


1.44
log
@update copyright dates
@
text
@d35 1
d196 1
a196 1
                                   fix_v4bx);
d210 2
a211 1
#define OPTION_FIX_V4BX                 306
d224 1
d234 1
d265 4
@


1.43
log
@	* bfd/bin-in.h (bfd_elf32_arm_set_target_relocs): Update prototype.
	* bfd/bin-in2.h (bfd_elf32_arm_set_target_relocs): Update prototype.
	* bfd/elf32-arm.c (elf32_arm_link_hash_table): Add fix_v4bx flag.
	(bfd_elf32_arm_set_target_relocs): Add formal parameter fix_v4bx for
	passing flag value from ld. Set flag value in global hash table entry.
	(elf32_arm_final_link_relocate): Add code to implement R_ARM_V4BX
	relocation.
	* ld/emultempl/armelf.em (fix_v4bx): New variable.
	(arm_elf_create_output_section_statements): Communicate fix_v4bx flag
	value to bfd.
	(PARSE_AND_LIST_PROLOGUE): Add option token OPTION_FIX_V4BX.
	(PARSE_AND_LIST_LONGOPTS): Add option --fix-v4bx.
	(PARSE_AND_LIST_OPTIONS): Add option --fix-v4bx.
	(PARSE_AND_LIST_ARGS_CASES): Add option OPTION_FIX_V4BX.
	* ld/NEWS: Mention --fix-v4bx.
	* ld/ld.texinfo: Document --fix-v4bx.
@
text
@d2 2
a3 1
#   Copyright 1991, 1993, 1996, 1997, 1998, 1999, 2000, 2002, 2003, 2004
@


1.42
log
@2004-11-30  Paul Brook  <paul@@codesourcery.com>

bfd/
	* elf32-arm.c (struct elf32_arm_link_hash_table): Remove
	no_pipeline_knowledge
	(elf32_arm_link_hash_table_create): Ditto.
	(bfd_elf32_arm_process_before_allocation): Ditto.
	(elf32_arm_final_link_relocate): Ditto.  Remove oabi relocation
	handling.
	* bfd-in.h (bfd_elf32_arm_process_before_allocation): Update
	prototype.
	* bfd-in2.h: Regenerate.
ld/
	* emultempl/armelf.em: Ignore -p and -no-pipeline-knowledge.
@
text
@d33 1
d193 2
a194 1
  bfd_elf32_arm_set_target_relocs (&link_info, target1_is_rel, target2_type);
d208 1
d220 1
d229 1
d256 4
@


1.41
log
@bfd/
	* elf32-arm.c (PLT_THUMB_STUB_SIZE): Define.
	(elf32_arm_plt_thumb_stub): New.
	(struct elf32_arm_link_hash_entry): Add plt_thumb_refcount
	and plt_got_offset.
	(elf32_arm_link_hash_traverse): Fix typo.
	(elf32_arm_link_hash_table): Add obfd.
	(elf32_arm_link_hash_newfunc): Initialize new fields.
	(elf32_arm_copy_indirect_symbol): Copy plt_thumb_refcount.
	(elf32_arm_link_hash_table_create): Initialize obfd.
	(record_arm_to_thumb_glue): Mark the glue as a local ARM function.
	(record_thumb_to_arm_glue): Mark the glue as a local Thumb function.
	(bfd_elf32_arm_get_bfd_for_interworking): Verify that the
	interworking BFD is not dynamic.
	(bfd_elf32_arm_process_before_allocation): Handle R_ARM_PLT32.  Do
	not emit glue for PLT references.
	(elf32_arm_final_link_relocate): Handle Thumb functions.  Do not
	emit glue for PLT references.  Support the Thumb PLT prefix.
	(elf32_arm_gc_sweep_hook): Handle R_ARM_THM_PC22 and
	plt_thumb_refcount.
	(elf32_arm_check_relocs): Likewise.
	(elf32_arm_adjust_dynamic_symbol): Handle Thumb functions and
	plt_thumb_refcount.
	(allocate_dynrelocs): Handle Thumb PLT references.
	(elf32_arm_finish_dynamic_symbol): Likewise.
	(elf32_arm_symbol_processing): New function.
	(elf_backend_symbol_processing): Define.
opcodes/
	* arm-dis.c (WORD_ADDRESS): Define.
	(print_insn): Use it.  Correct big-endian end-of-section handling.
gas/testsuite/
	* gas/arm/mapping.d: Expect F markers for Thumb code.
	* gas/arm/unwind.d: Update big-endian pattern.
ld/
	* emultempl/armelf.em (arm_elf_set_bfd_for_interworking): Don't use
	a dynamic object for stubs.
ld/testsuite/
	* ld-arm/mixed-app.d, ld-arm/mixed-app.r, ld-arm/mixed-app.s,
	ld-arm/mixed-app.sym, ld-arm/mixed-lib.d, ld-arm/mixed-lib.r,
	ld-arm/mixed-lib.s, ld-arm/mixed-lib.sym, ld-arm/arm-dyn.ld,
	ld-arm/arm-lib.ld: New files.
	* ld-arm/arm-app-abs32.d, ld-arm/arm-app-abs32.r, ld-arm/arm-app.d,
	ld-arm/arm-app.r, ld-arm/arm-lib-plt32.d, ld-arm/arm-lib-plt32.r,
	ld-arm/arm-lib.d, ld-arm/arm-lib.r, ld-arm/arm-static-app.d,
	ld-arm/arm-static-app.r: Update for big-endian.
	* ld-arm/arm-elf.exp: Run the new tests.
@
text
@a27 1
static int no_pipeline_knowledge = 0;
a126 1
						      no_pipeline_knowledge,
a219 1
  fprintf (file, _("  -p --no-pipeline-knowledge  Stop the linker knowing about the pipeline length\n"));
d229 1
a229 1
      no_pipeline_knowledge = 1;
@


1.40
log
@bfd/
	* bfd-in.h (bfd_elf32_arm_set_target_relocs): Add prototype.
	(bfd_elf32_arm_process_before_allocation): Update prototype.
	* bfd-in2.h: Regenerate.
	* bfd/elf32-arm.h (elf32_arm_link_hash_table): Add target2_reloc.
	(elf32_arm_link_hash_table_create): Set it.
	(bfd_elf32_arm_process_before_allocation): Remove target1_is_rel.
	(bfd_elf32_arm_set_target_relocs): New function.
	(arm_real_reloc_type): New function.
	(elf32_arm_final_link_relocate): Use it.  Handle R_ARM_PREL31 and
	R_ARM_GOT_PREL.  Remove R_ARM_TARGET1.
	(elf32_arm_gc_sweep_hook): Ditto.
	(elf32_arm_check_relocs): Ditto.
	(elf32_arm_relocate_section): Handle R_ARM_GOT_PREL.
	* elfarm-nabi.c (elf32_arm_howto_table): Add R_ARM_PREL31 and
	R_ARM_GOT_TARGET2.
	(elf32_arm_got_prel): New variable.
	(elf32_arm_howto_from_type): New function.
	(elf32_arm_info_to_howto): Use it.
	(elf32_arm_reloc_map): Add BFD_RELOC_ARM_PREL31 and
	BFD_RELOC_ARM_TARGET2.
	* libbfd.h: Regenerate.
	* reloc.c: Add BFD_RELOC_ARM_TARGET2 and BFD_RELOC_ARM_PREL31.
gas/
	* config/tc-arm.c (s_arm_rel31): New funciton.
	(md_pseudo_table): Add .rel31.
	(md_apply_fix3): Handle BFD_RELOC_ARM_TARGET2,
	BFD_RELOC_32_PCREL and BFD_RELOC_ARM_PREL31.
	(tc_gen_reloc): Handle BFD_RELOC_ARM_PREL31 and BFD_RELOC_ARM_TARGET2.
	(arm_fix_adjustable): Return 0 for BFD_RELOC_ARM_TARGET2.
	(arm_parse_reloc): Add (target2).
gas/testsuite/
	* gas/arm/pic.s: Add (target2).
	* gas/arm/pic.d: Ditto.
include/
	* elf/arm.h: Remove R_ARM_STKCHK and R_ARM_THM_STKCHK.
	Add R_ARM_TARGET2, R_ARM_PREL31, R_ARM_GOT_ABS, R_ARM_GOT_PREL,
	R_ARM_GOT_BREL12, R_ARM_GOTOFF12 and R_ARM_GOTRELAX.
ld/
	* ld.texinfo: Rename arm-specific section.  Document --target*
	* emulparams/armelf_fbsd.sh: Set TARGET2_TYPE.
	* emulparams/armelf_linux.sh: Ditto.
	* emulparams/armelf_nbsd.sh: Ditto.
	* emultempl/armelf.em: Set default for TARGET2_TYPE.
	(target2_type): New variable.
	(arm_elf_before_allocation): Don't pass target1_type.
	(arm_elf_create_output_section_statements): New function.
	(PARSE_AND_LIST_PROLOGUE): Add OPTION_TARGET2.
	(PARSE_AND_LIST_LONGOPTS, PARSE_AND_LIST_OPTIONS): Add --target=.
	(PARSE_AND_LIST_ARGS_CASES): Handle OPTION_TARGET2.
	(LDEMUL_CREATE_OUTPUT_SECTION_STATEMENTS): Set.
	* emultempl/armelf_oabi.em (_before_allocation): Remove extra
	argument to bfd_elf32_arm_process_before_allocation.
ld/testsuite/
	* ld-arm/arm-target1-{abs,rel}.d}: New files.
	* ld-arm/arm-target1.s: New file.
	* ld-arm/arm-target2-{,got-}rel.d: New files.
	* ld-arm/arm-target2.s: New file.
	* ld-arm/arm-rel31.d: New files.
	* ld-arm/arm-rel31.s: New files.
	* ld-arm/arm.ld: New file.
	* ld-arm/arm-elf.exp: Add new tests.
@
text
@d81 2
d85 1
@


1.39
log
@bfd/
	* bfd-in.h (bfd_elf32_arm_process_before_allocation): Update
	prototype.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* elf32-arm.h (elf32_arm_link_hash_table): Add target1_is_rel.
	(elf32_arm_link_hash_table_create): Set target1_is_rel.
	(bfd_elf32_arm_process_before_allocation): Ditto.
	(elf32_arm_final_link_relocate): Handle R_ARM_TARGET1.
	(elf32_arm_gc_sweep_hook, elf32_arm_check_relocs): Ditto.
	* elfarm-nabi.c (elf32_arm_howto_table): Rename RELABS to TARGET1.
	* reloc.c: Ditto.
gas/
	* config/tc-arm.c: Rename RELABS to TARGET1.
gas/testsuite/
	* gas/arm/pic.d: Rename RELABS to TARGET1.
	* gas/arm/pic.s: Ditto.
include/
	* elf/arm.h: Rename RELABS to TARGET1.
ld/
	* emulparams/armsymbian.sh: Set TARGET1_IS_REL.
	* emultempl/armelf.em: Use TARGET1_IS_REL.  Add --target1-{rel,abs}.
@
text
@d25 1
d33 1
d126 1
a126 2
						      byteswap_code,
						      target1_is_rel))
d186 8
d204 1
d215 1
d222 3
a224 2
  fprintf (file, _("     --target1-rel            Interpret R_ARM_TARGET1 as R_ARM_REL32\n"));
  fprintf (file, _("     --target1-abs            Interpret R_ARM_TARGET1 as R_ARM_ABS32\n"));
d247 4
d257 1
@


1.38
log
@bfd/
	* elflink.c (elf_link_add_object_symbols): Don't set up merge
	section data here..
	* elf.c (_bfd_elf_merge_sections): .. Do it here instead.
	* merge.c: Formatting.  Remove unnecessary casts.  Expand
	bfd_get_section_alignment macro.
	(struct sec_merge_sec_info): Rename "first" to "first_str".  Update
	use throughout file.
	(_bfd_add_merge_section): Rename from _bfd_merge_section.  Update
	comment.  Abort on dynamic or non-SEC_MERGE input.  Don't test
	section name to determine sinfo group, instead test output section
	and alignment.
	(_bfd_merge_sections): Add struct bfd_link_info param.  Call
	_bfd_strip_section_from_output rather than just twiddling flags.
	* libbfd-in.h (_bfd_add_merge_section): Rename, update comment.
	(_bfd_merge_sections): Update prototype.
	* libbfd.h: Regenerate.
ld/
	* ldlang.c (lang_process): Call bfd_merge_sections later, and
	only when not a relocatable link.
	(print_input_section): Handle SEC_EXCLUDE sections.
	(size_input_section): Don't update dot on SEC_EXCLUDE sections.
	(lang_do_assignments_1): Likewise.
	* ldwrite.c (build_link_order): Ignore SEC_EXCLUDE input sections.
	* emultempl/armelf.em (arm_elf_set_bfd_for_interworking): Likewise.
	* emultempl/hppaelf.em (build_section_lists): Likewise.
	* emultempl/ppc64elf.em (build_toc_list): Likewise.
	(build_section_lists): Likewise.
@
text
@d31 1
d124 2
a125 1
						      byteswap_code))
d193 2
d203 2
d211 2
d227 8
@


1.37
log
@	* bfd/bfd-in.h (bfd_elf32_arm_process_before_allocation): Update.
	* bfd/elf32-arm.h (struct elf32_elf_section_map): New.
	(struct _arm_elf_section_data): New.
	(elf32_arm_section_data): Define.
	(struct elf32_arm_link_hash_table): Add byteswap_code.
	(elf32_arm_link_hash_table_create): Initialize byteswap_code.
	(bfd_elf32_arm_process_before_allocation): Add byteswap_code.
	(elf32_arm_post_process_headers): Set EF_ARM_BE8.
	(elf32_arm_output_symbol_hook, elf32_arm_new_section_hook,
	elf32_arm_compare_mapping, elf32_arm_write_section): New functions.
	(bfd_elf32_new_section_hook, elf_backend_write_section,
	elf_backend_link_output_symbol_hook): Define.
	* ld/emultempl/armelf.em (byteswap_code): Add.
	(arm_elf_before_allocation): Pass extra parameter.
	(PARSE_AND_LIST_PROLOGUE): Add OPTION_BE8.
	(PARSE_AND_LIST_LONGOPTS, PARSE_AND_LIST_OPTIONS): Add be8.
	(PARSE_AND_LIST_ARGS_CASES): Handle OPTION_BE8.
	* ld/emultempl/armelf_oabi.em: Pass extra parameter.
	* ld/ld.texinfo: Document --be8.
@
text
@d70 2
a71 1
      && !statement->input_section.ifile->just_syms_flag)
@


1.36
log
@	* ldfile.c (ldfile_set_output_arch): Add defarch param.
	* ldfile.h (ldfile_set_output_arch): Ditto.
	* emultempl/aix.em (gld${EMULATION_NAME}_before_parse): Use
	ldfile_set_output_arch.
	* emultempl/beos.em (gld${EMULATION_NAME}_before_parse): Ditto.
	* emultempl/elf32.em (gld${EMULATION_NAME}_before_parse): Ditto.
	* emultempl/linux.em (gld${EMULATION_NAME}_before_parse): Ditto.
	* emultempl/mipsecoff.em (gld${EMULATION_NAME}_before_parse): Ditto.
	* emultempl/pe.em (gld${EMULATION_NAME}_before_parse): Ditto.
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_parse): Ditto.
	* ldgram.y: Adjust ldfile_set_output_arch call.
	* emultempl/armcoff.em (gld${EMULATION_NAME}_before_parse): Ditto.
	* emultempl/armelf.em (gld${EMULATION_NAME}_before_parse): Ditto.
	* emultempl/armelf_oabi.em (gld${EMULATION_NAME}_before_parse): Ditto.
	* emultempl/generic.em (gld${EMULATION_NAME}_before_parse): Ditto.
	* emultempl/gld960c.em (gld960_set_output_arch): Ditto.
	* emultempl/m68kcoff.em (gld${EMULATION_NAME}_before_parse): Ditto.
	* emultempl/ticoff.em (gld${EMULATION_NAME}_before_parse): Ditto.
@
text
@d30 1
d121 2
a122 1
						      no_pipeline_knowledge))
d189 1
d197 1
d203 1
d213 4
@


1.35
log
@	* emultempl/aix.em: Convert to C90, remove unnecessary prototypes
	and casts.  Replace PTR with void *.  Formatting.
	* emultempl/alphaelf.em: Likewise
	* emultempl/armcoff.em: Likewise
	* emultempl/armelf.em: Likewise
	* emultempl/armelf_oabi.em: Likewise
	* emultempl/beos.em: Likewise
	* emultempl/elf32.em: Likewise
	* emultempl/generic.em: Likewise
	* emultempl/gld960.em: Likewise
	* emultempl/gld960c.em: Likewise
	* emultempl/hppaelf.em: Likewise
	* emultempl/linux.em: Likewise
	* emultempl/lnk960.em: Likewise
	* emultempl/m68hc1xelf.em: Likewise
	* emultempl/m68kcoff.em: Likewise
	* emultempl/m68kelf.em: Likewise
	* emultempl/mipsecoff.em: Likewise
	* emultempl/mipself.em: Likewise
	* emultempl/mmix-elfnmmo.em: Likewise
	* emultempl/mmixelf.em: Likewise
	* emultempl/mmo.em: Likewise
	* emultempl/needrelax.em: Likewise
	* emultempl/netbsd.em: Likewise
	* emultempl/pe.em: Likewise
	* emultempl/sh64elf.em: Likewise
	* emultempl/sunos.em: Likewise
	* emultempl/ticoff.em: Likewise
	* emultempl/vanilla.em: Likewise
	* emultempl/xtensaelf.em: Likewise
	* Makefile.am: Correct dependencies.
	* Makefile.in: Regenerate.
@
text
@d2 1
a2 1
#   Copyright 1991, 1993, 1996, 1997, 1998, 1999, 2000, 2002, 2003
d35 1
a35 1
  ldfile_set_output_arch ("`echo ${ARCH}`");
@


1.34
log
@(arm_elf_before_allocation): Replace ASSERT with a test for a NULL
bfd_for_interworking.
@
text
@a30 1

d32 1
a32 1
gld${EMULATION_NAME}_before_parse ()
a40 2
static void arm_elf_after_open PARAMS ((void));

d42 1
a42 1
arm_elf_after_open ()
a64 3
static void arm_elf_set_bfd_for_interworking
  PARAMS ((lang_statement_union_type *));

d66 1
a66 2
arm_elf_set_bfd_for_interworking (statement)
     lang_statement_union_type *statement;
a85 2
static void arm_elf_before_allocation PARAMS ((void));

d87 1
a87 1
arm_elf_before_allocation ()
a131 2
static void arm_elf_finish PARAMS ((void));

d133 1
a133 1
arm_elf_finish ()
d142 1
a142 1
  
d153 1
a153 1
      
d160 1
a160 1
      
d164 1
a164 1
         where the lang_finish() function will pick it up.  */
d167 1
a167 1
      
@


1.33
log
@	* ldemul.c (ldemul_add_options, ldemul_handle_option): New functions.
	(ldemul_parse_args): Return bfd_boolean.  Formatting.
	* ldemul.h (ldemul_add_options, ldemul_handle_option): Declare.
	(ldemul_parse_args): Adjust.
	(struct ld_emulation_xfer_struct): Add add_options and handle_option.
	Return bfd_boolean from parse_args.
	* lexsup.c (parse_args): Malloc shortopts, longopts and
	really_longopts.  Call ldemul_add_options and ldemul_handle_option.
	* emultempl/aix.em (gld${EMULATION_NAME}_add_options): Split out from
	gld${EMULATION_NAME}_parse_args.
	(gld${EMULATION_NAME}_handle_option): Likewise.
	(ld_${EMULATION_NAME}_emulation): Adjust initializer.
	* emultempl/armcoff.em: As for aix.em, but remove parse_args.
	* emultempl/beos.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/ticoff.em: Likewise.
	* emultempl/elf32.em: Likewise.  Don't duplicate long options either.
	(gld${EMULATION_NAME}_add_sysroot): Prototype.
	* emultempl/armelf.em (PARSE_AND_LIST_LONGOPTS): Don't duplicate
	options.
	* emultempl/hppaelf.em (PARSE_AND_LIST_LONGOPTS): Likewise.
	* emultempl/ppc32elf.em (PARSE_AND_LIST_LONGOPTS): Likewise.
	* emultempl/ppc64elf.em (PARSE_AND_LIST_LONGOPTS): Likewise.
	* emultempl/armelf_oabi.em (ld_${EMULATION_NAME}_emulation): Adjust
	initializer.
	* emultempl/generic.em: Likewise.
	* emultempl/gld960.em: Likewise.
	* emultempl/gld960c.em: Likewise.
	* emultempl/linux.em: Likewise.
	* emultempl/lnk960.em: Likewise.
	* emultempl/m68kcoff.em: Likewise.
	* emultempl/mipsecoff.em: Likewise.
	* emultempl/sunos.em: Likewise.
	* emultempl/vanilla.em: Likewise.
	* emultempl/netbsd.em (gldnetbsd_before_parse): Prototype.
@
text
@a110 1
      ASSERT (bfd_for_interwork != NULL);
d114 6
a119 1
      bfd_elf32_arm_get_bfd_for_interworking (bfd_for_interwork, &link_info);
@


1.33.2.1
log
@(arm_elf_before_allocation): Replace ASSERT with a test for a NULL
bfd_for_interworking.
@
text
@d111 1
d115 1
a115 6
      /* If bfd_for_interwork is NULL, then there are no loadable sections
	 with real contents to be linked, so we are not going to have to
	 create any interworking stubs, so it is OK not to call
	 bfd_elf32_arm_get_bfd_for_interworking.  */
      if (bfd_for_interwork != NULL)
	bfd_elf32_arm_get_bfd_for_interworking (bfd_for_interwork, &link_info);
@


1.32
log
@Add duplicate entry for no-pipeline-knowledge.  This will prevent the getopt
package from thinking that there are any shorter abbreviations for
--no-pipeline-knowledge.
@
text
@d2 1
a2 1
#   Copyright 1991, 1993, 1996, 1997, 1998, 1999, 2000, 2002
a197 3
# Note we have duplicate entries for no-pipeline-knowledge in order
# to prevent getopt_long_only from thinking that -n is a unique
# abbreviation for --no-pipeline-knowledge.
a198 1
  { "no-pipeline-knowledge", no_argument, NULL, '\'p\''},
@


1.31
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d196 1
a196 6
# Note we add 'n' to the short option list in order to prevent
# getopt_long_only from thinking that -n is a unique abbreviation
# for --no-pipeline-knowledge.  There is no case to handle 'n' here
# however, so instead it will be passed back to parse_args() in
# lexsup.c where it will be handled.
PARSE_AND_LIST_SHORTOPTS=pn
d198 3
d202 1
@


1.30
log
@Revert ARM linker patch and apply similar patch to bfd instead
@
text
@d38 2
a39 2
  config.dynamic_link = ${DYNAMIC_LINK-true};
  config.has_shared = `if test -n "$GENERATE_SHLIB_SCRIPT" ; then echo true ; else echo false ; fi`;
d76 1
a76 1
      && statement->input_section.ifile->just_syms_flag == false)
d88 1
a88 1
	  bfd_for_interwork->output_has_begun = true;
d108 1
a108 1
	tem->output_has_begun = false;
d113 1
a113 1
	tem->output_has_begun = false;
d151 1
a151 1
			    false, false, true);
@


1.29
log
@Set the last bit of DT_INIT and DT_FINI depending on the type of the function.
@
text
@d27 3
a29 12
#include "elf-bfd.h"
#include "elf/arm.h"

static int    no_pipeline_knowledge = 0;
static char * thumb_entry_symbol = NULL;
static bfd *  bfd_for_interwork;

static void  arm_elf_after_open                PARAMS ((void));
static void  arm_elf_set_bfd_for_interworking  PARAMS ((lang_statement_union_type *));
static void  arm_elf_before_allocation         PARAMS ((void));
static void  arm_elf_stringify_thumb_address   PARAMS ((struct bfd_link_hash_entry *, char *));
static void  arm_elf_finish                    PARAMS ((void));
d42 2
d68 3
d73 1
a73 1
     lang_statement_union_type * statement;
d78 2
a79 2
      asection * i = statement->input_section.section;
      asection * output_section = i->output_section;
d93 2
d98 1
a98 1
  bfd * tem;
d137 1
a137 21
void
arm_elf_stringify_thumb_address (h, buffer)
     struct bfd_link_hash_entry * h;
     char * buffer;
{
  bfd_vma val;
      
  /* Get the address of the symbol.  */
  val = (h->u.def.value
	 + bfd_get_section_vma (output_bfd,
				h->u.def.section->output_section)
	 + h->u.def.section->output_offset);
  /* This is a thumb address, so the bottom bit of its address must be set.  */
  val |= 1;

  /* Now convert this value into a string.  */
  buffer[0] = '0';
  buffer[1] = 'x';

  sprintf_vma (buffer + 2, val);
}
d147 5
a151 27
  if (thumb_entry_symbol != NULL)
    {
      static char buffer[32];

      h = bfd_link_hash_lookup (link_info.hash, thumb_entry_symbol,
				false, false, true);

      if (h != (struct bfd_link_hash_entry *) NULL
	  && (h->type == bfd_link_hash_defined
	      || h->type == bfd_link_hash_defweak)
	  && h->u.def.section->output_section != NULL)
	{
	  if (entry_symbol.name != NULL && entry_from_cmdline)
	    einfo (_("%P: warning: '--thumb-entry %s' is overriding '-e %s'\n"),
		   thumb_entry_symbol, entry_symbol.name);
	  
	  arm_elf_stringify_thumb_address (h, buffer);
	  entry_symbol.name = buffer;
	}
      else
	einfo (_("%P: warning: cannot find thumb start symbol %s\n"),
	       thumb_entry_symbol);
    }

  /* If init is a Thumb function set the LSB.  */
  h = bfd_link_hash_lookup (link_info.hash, link_info.init_function, false,
			    false, true);
a155 1
      && ELF_ST_TYPE (((struct elf_link_hash_entry *)h)->type) == STT_ARM_TFUNC
d159 10
d170 6
a175 15
      arm_elf_stringify_thumb_address (h, buffer);
      link_info.init_function = buffer;
    }

  /* If fini is a Thumb function set the LSB.  */
  h = bfd_link_hash_lookup (link_info.hash, link_info.fini_function, false,
			    false, true);

  if (h != (struct bfd_link_hash_entry *) NULL
      && (h->type == bfd_link_hash_defined
	  || h->type == bfd_link_hash_defweak)
      && ELF_ST_TYPE (((struct elf_link_hash_entry *)h)->type) == STT_ARM_TFUNC
      && h->u.def.section->output_section != NULL)
    {
      static char buffer[32];
d177 8
a184 3
      arm_elf_stringify_thumb_address (h, buffer);
      link_info.fini_function = buffer;
    }
@


1.28
log
@Only search for an interworking bfd if there are input bfds.
@
text
@d27 12
a38 3
static int no_pipeline_knowledge = 0;
static char *thumb_entry_symbol = NULL;
static bfd *bfd_for_interwork;
a50 2
static void arm_elf_after_open PARAMS ((void));

a74 3
static void arm_elf_set_bfd_for_interworking
  PARAMS ((lang_statement_union_type *));

d77 1
a77 1
     lang_statement_union_type *statement;
d82 2
a83 2
      asection *i = statement->input_section.section;
      asection *output_section = i->output_section;
a96 2
static void arm_elf_before_allocation PARAMS ((void));

d100 1
a100 1
  bfd *tem;
d139 21
a159 1
static void arm_elf_finish PARAMS ((void));
d169 27
a195 5
  if (thumb_entry_symbol == NULL)
    return;
  
  h = bfd_link_hash_lookup (link_info.hash, thumb_entry_symbol,
			    false, false, true);
d200 1
a203 10
      bfd_vma val;
      
      /* Special procesing is required for a Thumb entry symbol.  The
	 bottom bit of its address must be set.  */
      val = (h->u.def.value
	     + bfd_get_section_vma (output_bfd,
				    h->u.def.section->output_section)
	     + h->u.def.section->output_offset);
      
      val |= 1;
d205 15
a219 6
      /* Now convert this value into a string and store it in entry_symbol
         where the lang_finish() function will pick it up.  */
      buffer[0] = '0';
      buffer[1] = 'x';
      
      sprintf_vma (buffer + 2, val);
d221 3
a223 8
      if (entry_symbol.name != NULL && entry_from_cmdline)
	einfo (_("%P: warning: '--thumb-entry %s' is overriding '-e %s'\n"),
	       thumb_entry_symbol, entry_symbol.name);
      entry_symbol.name = buffer;
    }
  else
    einfo (_("%P: warning: connot find thumb start symbol %s\n"),
	   thumb_entry_symbol);
@


1.27
log
@	* ldlang.h (entry_sym): Make it a struct bfd_sym_chain.
	* ldlang.c (entry_sym): Likewise.
	(ldlang_undef_chain_list_type): Likewise.
	(lang_finish): Adjust references to entry_symbol.
	(lang_add_entry): Likewise.
	(lang_gc_sections): Use link_info.gc_sym_list.
	(lang_process): Set link_info.gc_sym_list.
	* ldlex.l: Include bfdlink.h.
	* ldmain.c (main): Init link_info.gc_sym_list.
	* emultempl/aix.em: Adjust references to entry_symbol.
	* emultempl/armcoff.em: Likewise.
	* emultempl/armelf.em: Likewise.
	* emultempl/pe.em: Likewise.
	* emultempl/ppc64elf.em (ppc_after_open): New function.
	(LDEMUL_AFTER_OPEN): Define.
	* emulparams/elf64ppc.sh: KEEP .opd sections.
@
text
@d103 6
a108 4
  /* The interworking bfd must be the last one in the link.  */
  bfd_for_interwork = NULL;
  for (tem = link_info.input_bfds; tem != NULL; tem = tem->link_next)
    tem->output_has_begun = false;
d110 4
a113 6
  lang_for_each_statement (arm_elf_set_bfd_for_interworking);
  ASSERT (bfd_for_interwork != NULL);
  for (tem = link_info.input_bfds; tem != NULL; tem = tem->link_next)
    tem->output_has_begun = false;

  bfd_elf32_arm_get_bfd_for_interworking (bfd_for_interwork, &link_info);
d115 2
@


1.27.2.1
log
@2002-09-23  Daniel Jacobowitz  <drow@@mvista.com>

	Merge from mainline:
	2002-09-22  Mark Elbrecht  <snowball3@@softhome.net>
	* scripttempl/i386go32.sc: Handle bss unique sections.

	2002-09-11  Nick Clifton  <nickc@@redhat.com>
	* po/tr.po: Updated Turkish translation.

	2002-08-28  Alan Modra  <amodra@@bigpond.net.au>
	* emultempl/aix.em (gld${EMULATION_NAME}_parse_args): Replace strtoll,
	strtoul and strtoull with bfd_scan_vma.
	(gld${EMULATION_NAME}_read_file): Likewise.

	2002-08-07  Nick Clifton  <nickc@@redhat.com>
	* emultempl/armelf.em (arm_elf_before_allocation): Only search
	for an interworking bfd if there are input bfds.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* emultempl/aix.em (gld*_before_parse): Set default arch.  Reverts
	2002-05-10 change.

	2002-08-06  H.J. Lu <hjl@@gnu.org>
	* ld.texinfo: Document --no-undefined-version.

	* ldlang.c (lang_new_vers_pattern): Set the `symver' and
	`script.' fields to 0.

	* ldmain.c (main): Initialize the allow_undefined_version to
	true.

	* lexsup.c (OPTION_NO_UNDEFINED_VERSION): New.
	(ld_options): Add --no-undefined-version.
	(parse_args): Support OPTION_NO_UNDEFINED_VERSION.

	2002-07-04  Bruno Haible  <bruno@@clisp.org>
	* emulparams/elf_i386_fbsd.sh: Set OUTPUT_FORMAT to
	elf32-i386-freebsd.
	* emulparams/elf64alpha_fbsd.sh: Set OUTPUT_FORMAT to
	elf64-alpha-freebsd.
@
text
@d103 4
a106 6
  if (link_info.input_bfds != NULL)
    {
      /* The interworking bfd must be the last one in the link.  */
      bfd_for_interwork = NULL;
      for (tem = link_info.input_bfds; tem != NULL; tem = tem->link_next)
	tem->output_has_begun = false;
d108 6
a113 4
      lang_for_each_statement (arm_elf_set_bfd_for_interworking);
      ASSERT (bfd_for_interwork != NULL);
      for (tem = link_info.input_bfds; tem != NULL; tem = tem->link_next)
	tem->output_has_begun = false;
a114 2
      bfd_elf32_arm_get_bfd_for_interworking (bfd_for_interwork, &link_info);
    }
@


1.26
log
@Fix genreation of arm <->thumb glue stubs by ensuring that they are in the last section linked.
@
text
@d175 1
a175 1
      if (entry_symbol != NULL && entry_from_cmdline)
d177 2
a178 2
	       thumb_entry_symbol, entry_symbol);
      entry_symbol = buffer;
@


1.25
log
@Add 'n' in order to prevent "-n" from being taken as an abbreviation for
"--no-pipeline-knowledge".
@
text
@d2 1
a2 1
#   Copyright 1991, 1993, 1996, 1997, 1998, 1999, 2000
d29 1
d42 1
a42 2

static void arm_elf_after_open PARAMS((void));
d60 1
a60 3
	/* The interworking bfd must be the last one to be processed */
	if (!is->next)
	  bfd_elf32_arm_get_bfd_for_interworking (is->the_bfd, & link_info);
d68 24
d98 2
d103 9
a111 1
  /* We should be able to set the size of the interworking stub section */
d113 6
a118 2
  /* Here we rummage through the found bfds to collect glue information */
  /* FIXME: should this be based on a command line option? krk@@cygnus.com */
d131 1
a131 1
  /* We have seen it all. Allocate it, and carry on */
a133 1

@


1.24
log
@	* emultempl/elf32.em (gld${EMULATION_NAME}_finish): Only emit this
	function when LDEMUL_FINISH isn't set to the same name.  Don't
	call ${LDEMUL_FINISH}.
	(ld_${EMULATION_NAME}_emulation): Call $LDEMUL_FINISH if defined.
	* emultempl/armelf.em (arm_elf_finish): Call
	gld${EMULATION_NAME}_finish.
	* emultempl/hppaelf.em (hppaelf_finish): Rename to
	gld${EMULATION_NAME}_finish.  Call bfd_elf32_discard_info and
	hppaelf_layout_sections_again if necessary.
	(need_laying_out): New var.
	(hppaelf_layaout_sections_again): Rename to
	hppaelf_layout_sections_again.  Clear need_laying_out.
	(PARSE_AND_LIST_OPTIONS): Format text.
@
text
@d159 6
a164 1
PARSE_AND_LIST_SHORTOPTS=p
@


1.24.2.1
log
@Add 'n' to short option list in order to prevent "-n" from being taken as an
abbreviation for "--no-pipeline-knowledge".
@
text
@d159 1
a159 6
# Note we add 'n' to the short option list in order to prevent
# getopt_long_only from thinking that -n is a unique abbreviation
# for --no-pipeline-knowledge.  There is no case to handle 'n' here
# however, so instead it will be passed back to parse_args() in
# lexsup.c where it will be handled.
PARSE_AND_LIST_SHORTOPTS=pn
@


1.23
log
@2001-11-14  H.J. Lu  <hjl@@gnu.org>

	* emultempl/armelf.em (arm_elf_finish): Renamed from
	gld${EMULATION_NAME}_finish.
	(LDEMUL_FINISH): Set to arm_elf_finish.
@
text
@d107 3
@


1.22
log
@Fixtypos in ChangeLogs, fix copyright dates in files
@
text
@d100 1
a100 1
static void gld${EMULATION_NAME}_finish PARAMS ((void));
d103 1
a103 1
gld${EMULATION_NAME}_finish PARAMS((void))
d187 1
a187 1
LDEMUL_FINISH=gld${EMULATION_NAME}_finish
@


1.21
log
@Add some shell variables and shell code to elf32.em
to allow elf32.em to be used by ports that require
some minor variations or a few extra functions.
Implement for hppaelf and armelf.
Fix header file include order in m68kcoff.em
@
text
@d2 1
a2 1
#   Copyright (C) 1991, 93, 96, 97, 98, 99, 2000
@


1.21.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
#   Copyright 1991, 1993, 1996, 1997, 1998, 1999, 2000
@


1.20
log
@Remove some forward declarations in ldemul.h and ldfile.h, and
re-arrange header include order.
Fix shadowing warnings in ldlang.h
Fix compile errors in mpw-elfmips.c
@
text
@d2 24
a25 70
# It does some substitutions.
ELFSIZE=32
cat >e${EMULATION_NAME}.c <<EOF
/* This file is is generated by a shell script.  DO NOT EDIT! */

/* emulate the original gld for the given ${EMULATION_NAME}
   Copyright (C) 1991, 93, 96, 97, 98, 99, 2000
   Free Software Foundation, Inc.
   Written by Steve Chamberlain steve@@cygnus.com

This file is part of GLD, the Gnu Linker.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

#define TARGET_IS_${EMULATION_NAME}

#include "bfd.h"
#include "sysdep.h"

#include <ctype.h>

#include "bfdlink.h"
#include "getopt.h"

#include "ld.h"
#include "ldmain.h"
#include "ldmisc.h"

#include "ldexp.h"
#include "ldlang.h"
#include "ldfile.h"
#include "ldemul.h"
#include "ldgram.h"

static boolean gld${EMULATION_NAME}_open_dynamic_archive
  PARAMS ((const char *, search_dirs_type *, lang_input_statement_type *));
static void gld${EMULATION_NAME}_after_open PARAMS ((void));
static void gld${EMULATION_NAME}_check_needed
  PARAMS ((lang_input_statement_type *));
static void gld${EMULATION_NAME}_stat_needed
  PARAMS ((lang_input_statement_type *));
static boolean gld${EMULATION_NAME}_search_needed
  PARAMS ((const char *, const char *, int));
static boolean gld${EMULATION_NAME}_try_needed PARAMS ((const char *, int));
static void gld${EMULATION_NAME}_vercheck
  PARAMS ((lang_input_statement_type *));
static void gld${EMULATION_NAME}_find_statement_assignment
  PARAMS ((lang_statement_union_type *));
static void gld${EMULATION_NAME}_find_exp_assignment PARAMS ((etree_type *));
static boolean gld${EMULATION_NAME}_place_orphan
  PARAMS ((lang_input_statement_type *, asection *));
static lang_output_section_statement_type *output_rel_find PARAMS ((void));
static void gld${EMULATION_NAME}_before_parse PARAMS ((void));
static void gld${EMULATION_NAME}_before_allocation PARAMS ((void));
static char *gld${EMULATION_NAME}_get_script PARAMS ((int *isfile));
static int  gld${EMULATION_NAME}_parse_args PARAMS((int, char **));
static void gld${EMULATION_NAME}_list_options PARAMS ((FILE *));
static void gld${EMULATION_NAME}_finish PARAMS ((void));
a26 1

d28 1
a28 1
static char * thumb_entry_symbol = NULL;
a29 58
#define OPTION_THUMB_ENTRY		301

static struct option longopts[] =
{
  { "no-pipeline-knowledge", no_argument, NULL, 'p'},
  { "thumb-entry", required_argument, NULL, OPTION_THUMB_ENTRY},
  { NULL, no_argument, NULL, 0 }
};

static void
gld${EMULATION_NAME}_list_options (file)
     FILE * file;
{
  fprintf (file, _("  -p --no-pipeline-knowledge  Stop the linker knowing about the pipeline length\n"));
  fprintf (file, _("     --thumb-entry=<sym>      Set the entry point to be Thumb symbol <sym>\n"));
}

static int
gld${EMULATION_NAME}_parse_args (argc, argv)
     int     argc;
     char ** argv;
{
  int        longind;
  int        optc;
  int        prevoptind = optind;
  int        prevopterr = opterr;
  int        wanterror;
  static int lastoptind = -1;

  if (lastoptind != optind)
    opterr = 0;
  
  wanterror  = opterr;
  lastoptind = optind;

  optc   = getopt_long_only (argc, argv, "-p", longopts, & longind);
  opterr = prevopterr;

  switch (optc)
    {
    default:
      if (wanterror)
	xexit (1);
      optind =  prevoptind;
      return 0;

    case 'p':
      no_pipeline_knowledge = 1;
      break;

    case OPTION_THUMB_ENTRY:
      thumb_entry_symbol = optarg;
      break;
    }
  
  return 1;
}

a40 66
/* Try to open a dynamic archive.  This is where we know that ELF
   dynamic libraries have an extension of .so.  */

static boolean
gld${EMULATION_NAME}_open_dynamic_archive (arch, search, entry)
     const char *arch;
     search_dirs_type *search;
     lang_input_statement_type *entry;
{
  const char *filename;
  char *string;

  if (! entry->is_archive)
    return false;

  filename = entry->filename;

  string = (char *) xmalloc (strlen (search->name)
			     + strlen (filename)
			     + strlen (arch)
			     + sizeof "/lib.so");

  sprintf (string, "%s/lib%s%s.so", search->name, filename, arch);

  if (! ldfile_try_open_bfd (string, entry))
    {
      free (string);
      return false;
    }

  entry->filename = string;

  /* We have found a dynamic object to include in the link.  The ELF
     backend linker will create a DT_NEEDED entry in the .dynamic
     section naming this file.  If this file includes a DT_SONAME
     entry, it will be used.  Otherwise, the ELF linker will just use
     the name of the file.  For an archive found by searching, like
     this one, the DT_NEEDED entry should consist of just the name of
     the file, without the path information used to find it.  Note
     that we only need to do this if we have a dynamic object; an
     archive will never be referenced by a DT_NEEDED entry.

     FIXME: This approach--using bfd_elf_set_dt_needed_name--is not
     very pretty.  I haven't been able to think of anything that is
     pretty, though.  */
  if (bfd_check_format (entry->the_bfd, bfd_object)
      && (entry->the_bfd->flags & DYNAMIC) != 0)
    {
      char *needed_name;

      ASSERT (entry->is_archive && entry->search_dirs_flag);
      needed_name = (char *) xmalloc (strlen (filename)
				      + strlen (arch)
				      + sizeof "lib.so");
      sprintf (needed_name, "lib%s%s.so", filename, arch);
      bfd_elf_set_dt_needed_name (entry->the_bfd, needed_name);
    }

  return true;
}

EOF
if [ "x${host}" = "x${target}" ] ; then
  case " ${EMULATION_LIBPATH} " in
  *" ${EMULATION_NAME} "*)
cat >>e${EMULATION_NAME}.c <<EOF
d42 1
a42 95
/* For a native linker, check the file /etc/ld.so.conf for directories
   in which we may find shared libraries.  /etc/ld.so.conf is really
   only meaningful on Linux, but we check it on other systems anyhow.  */

static boolean gld${EMULATION_NAME}_check_ld_so_conf
  PARAMS ((const char *, int));

static boolean
gld${EMULATION_NAME}_check_ld_so_conf (name, force)
     const char *name;
     int force;
{
  static boolean initialized;
  static char *ld_so_conf;

  if (! initialized)
    {
      FILE *f;

      f = fopen ("/etc/ld.so.conf", FOPEN_RT);
      if (f != NULL)
	{
	  char *b;
	  size_t len, alloc;
	  int c;

	  len = 0;
	  alloc = 100;
	  b = (char *) xmalloc (alloc);

	  while ((c = getc (f)) != EOF)
	    {
	      if (len + 1 >= alloc)
		{
		  alloc *= 2;
		  b = (char *) xrealloc (b, alloc);
		}
	      if (c != ':'
		  && c != ' '
		  && c != '\t'
		  && c != '\n'
		  && c != ',')
		{
		  b[len] = c;
		  ++len;
		}
	      else
		{
		  if (len > 0 && b[len - 1] != ':')
		    {
		      b[len] = ':';
		      ++len;
		    }
		}
	    }

	  if (len > 0 && b[len - 1] == ':')
	    --len;

	  if (len > 0)
	    b[len] = '\0';
	  else
	    {
	      free (b);
	      b = NULL;
	    }

	  fclose (f);

	  ld_so_conf = b;
	}

      initialized = true;
    }

  if (ld_so_conf == NULL)
    return false;

  return gld${EMULATION_NAME}_search_needed (ld_so_conf, name, force);
}

EOF
  ;;
  esac
fi
cat >>e${EMULATION_NAME}.c <<EOF

/* These variables are required to pass information back and forth
   between after_open and check_needed and stat_needed and vercheck.  */

static struct bfd_link_needed_list *global_needed;
static struct stat global_stat;
static boolean global_found;
static struct bfd_link_needed_list *global_vercheck_needed;
static boolean global_vercheck_failed;
d45 1
a45 1
gld${EMULATION_NAME}_after_open ()
a46 2
  struct bfd_link_needed_list *needed, *l;

d66 2
a67 315
  /* We only need to worry about this when doing a final link.  */
  if (link_info.relocateable || link_info.shared)
    return;

  /* Get the list of files which appear in DT_NEEDED entries in
     dynamic objects included in the link (often there will be none).
     For each such file, we want to track down the corresponding
     library, and include the symbol table in the link.  This is what
     the runtime dynamic linker will do.  Tracking the files down here
     permits one dynamic object to include another without requiring
     special action by the person doing the link.  Note that the
     needed list can actually grow while we are stepping through this
     loop.  */
  needed = bfd_elf_get_needed_list (output_bfd, &link_info);
  for (l = needed; l != NULL; l = l->next)
    {
      struct bfd_link_needed_list *ll;
      int force;

      /* If we've already seen this file, skip it.  */
      for (ll = needed; ll != l; ll = ll->next)
	if (strcmp (ll->name, l->name) == 0)
	  break;
      if (ll != l)
	continue;

      /* See if this file was included in the link explicitly.  */
      global_needed = l;
      global_found = false;
      lang_for_each_input_file (gld${EMULATION_NAME}_check_needed);
      if (global_found)
	continue;

      /* We need to find this file and include the symbol table.  We
	 want to search for the file in the same way that the dynamic
	 linker will search.  That means that we want to use
	 rpath_link, rpath, then the environment variable
	 LD_LIBRARY_PATH (native only), then the linker script
	 LIB_SEARCH_DIRS.  We do not search using the -L arguments.

	 We search twice.  The first time, we skip objects which may
	 introduce version mismatches.  The second time, we force
	 their use.  See gld${EMULATION_NAME}_vercheck comment.  */
      for (force = 0; force < 2; force++)
	{
	  const char *lib_path;
	  size_t len;
	  search_dirs_type *search;

	  if (gld${EMULATION_NAME}_search_needed (command_line.rpath_link,
						  l->name, force))
	    break;
	  if (gld${EMULATION_NAME}_search_needed (command_line.rpath,
						  l->name, force))
	    break;
	  if (command_line.rpath_link == NULL
	      && command_line.rpath == NULL)
	    {
	      lib_path = (const char *) getenv ("LD_RUN_PATH");
	      if (gld${EMULATION_NAME}_search_needed (lib_path, l->name,
						      force))
		break;
	    }
EOF
if [ "x${host}" = "x${target}" ] ; then
  case " ${EMULATION_LIBPATH} " in
  *" ${EMULATION_NAME} "*)
cat >>e${EMULATION_NAME}.c <<EOF
	  lib_path = (const char *) getenv ("LD_LIBRARY_PATH");
	  if (gld${EMULATION_NAME}_search_needed (lib_path, l->name, force))
	    break;
EOF
  ;;
  esac
fi
cat >>e${EMULATION_NAME}.c <<EOF
	  len = strlen (l->name);
	  for (search = search_head; search != NULL; search = search->next)
	    {
	      char *filename;

	      if (search->cmdline)
		continue;
	      filename = (char *) xmalloc (strlen (search->name) + len + 2);
	      sprintf (filename, "%s/%s", search->name, l->name);
	      if (gld${EMULATION_NAME}_try_needed (filename, force))
		break;
	      free (filename);
	    }
	  if (search != NULL)
	    break;
EOF
if [ "x${host}" = "x${target}" ] ; then
  case " ${EMULATION_LIBPATH} " in
  *" ${EMULATION_NAME} "*)
cat >>e${EMULATION_NAME}.c <<EOF
	  if (gld${EMULATION_NAME}_check_ld_so_conf (l->name, force))
	    break;
EOF
  ;;
  esac
fi
cat >>e${EMULATION_NAME}.c <<EOF
	}

      if (force < 2)
	continue;

      einfo ("%P: warning: %s, needed by %B, not found (try using --rpath)\n",
	     l->name, l->by);
    }
}

/* Search for a needed file in a path.  */

static boolean
gld${EMULATION_NAME}_search_needed (path, name, force)
     const char *path;
     const char *name;
     int force;
{
  const char *s;
  size_t len;

  if (path == NULL || *path == '\0')
    return false;
  len = strlen (name);
  while (1)
    {
      char *filename, *sset;

      s = strchr (path, ':');
      if (s == NULL)
	s = path + strlen (path);

      filename = (char *) xmalloc (s - path + len + 2);
      if (s == path)
	sset = filename;
      else
	{
	  memcpy (filename, path, s - path);
	  filename[s - path] = '/';
	  sset = filename + (s - path) + 1;
	}
      strcpy (sset, name);

      if (gld${EMULATION_NAME}_try_needed (filename, force))
	return true;

      free (filename);

      if (*s == '\0')
	break;
      path = s + 1;
    }

  return false;	  
}

/* This function is called for each possible name for a dynamic object
   named by a DT_NEEDED entry.  The FORCE parameter indicates whether
   to skip the check for a conflicting version.  */

static boolean
gld${EMULATION_NAME}_try_needed (name, force)
     const char *name;
     int force;
{
  bfd *abfd;

  abfd = bfd_openr (name, bfd_get_target (output_bfd));
  if (abfd == NULL)
    return false;
  if (! bfd_check_format (abfd, bfd_object))
    {
      (void) bfd_close (abfd);
      return false;
    }
  if ((bfd_get_file_flags (abfd) & DYNAMIC) == 0)
    {
      (void) bfd_close (abfd);
      return false;
    }

  /* Check whether this object would include any conflicting library
     versions.  If FORCE is set, then we skip this check; we use this
     the second time around, if we couldn't find any compatible
     instance of the shared library.  */

  if (! force)
    {
      struct bfd_link_needed_list *needed;

      if (! bfd_elf_get_bfd_needed_list (abfd, &needed))
	einfo ("%F%P:%B: bfd_elf_get_bfd_needed_list failed: %E\n", abfd);

      if (needed != NULL)
	{
	  global_vercheck_needed = needed;
	  global_vercheck_failed = false;
	  lang_for_each_input_file (gld${EMULATION_NAME}_vercheck);
	  if (global_vercheck_failed)
	    {
	      (void) bfd_close (abfd);
	      /* Return false to force the caller to move on to try
                 another file on the search path.  */
	      return false;
	    }

	  /* But wait!  It gets much worse.  On Linux, if a shared
             library does not use libc at all, we are supposed to skip
             it the first time around in case we encounter a shared
             library later on with the same name which does use the
             version of libc that we want.  This is much too horrible
             to use on any system other than Linux.  */

EOF
case ${target} in
  *-*-linux-gnu*)
    cat >>e${EMULATION_NAME}.c <<EOF
	  {
	    struct bfd_link_needed_list *l;

	    for (l = needed; l != NULL; l = l->next)
	      if (strncmp (l->name, "libc.so", 7) == 0)
		break;
	    if (l == NULL)
	      {
		(void) bfd_close (abfd);
		return false;
	      }
	  }

EOF
    ;;
esac
cat >>e${EMULATION_NAME}.c <<EOF
	}
    }

  /* We've found a dynamic object matching the DT_NEEDED entry.  */

  /* We have already checked that there is no other input file of the
     same name.  We must now check again that we are not including the
     same file twice.  We need to do this because on many systems
     libc.so is a symlink to, e.g., libc.so.1.  The SONAME entry will
     reference libc.so.1.  If we have already included libc.so, we
     don't want to include libc.so.1 if they are the same file, and we
     can only check that using stat.  */

  if (bfd_stat (abfd, &global_stat) != 0)
    einfo ("%F%P:%B: bfd_stat failed: %E\n", abfd);
  global_found = false;
  lang_for_each_input_file (gld${EMULATION_NAME}_stat_needed);
  if (global_found)
    {
      /* Return true to indicate that we found the file, even though
         we aren't going to do anything with it.  */
      return true;
    }

  /* Tell the ELF backend that don't want the output file to have a
     DT_NEEDED entry for this file.  */
  bfd_elf_set_dt_needed_name (abfd, "");

  /* Add this file into the symbol table.  */
  if (! bfd_link_add_symbols (abfd, &link_info))
    einfo ("%F%B: could not read symbols: %E\n", abfd);

  return true;
}

/* See if an input file matches a DT_NEEDED entry by name.  */

static void
gld${EMULATION_NAME}_check_needed (s)
     lang_input_statement_type *s;
{
  if (global_found)
    return;

  if (s->filename != NULL
      && strcmp (s->filename, global_needed->name) == 0)
    {
      global_found = true;
      return;
    }

  if (s->the_bfd != NULL)
    {
      const char *soname;

      soname = bfd_elf_get_dt_soname (s->the_bfd);
      if (soname != NULL
	  && strcmp (soname, global_needed->name) == 0)
	{
	  global_found = true;
	  return;
	}
    }
	  
  if (s->search_dirs_flag
      && s->filename != NULL
      && strchr (global_needed->name, '/') == NULL)
    {
      const char *f;

      f = strrchr (s->filename, '/');
      if (f != NULL
	  && strcmp (f + 1, global_needed->name) == 0)
	{
	  global_found = true;
	  return;
	}
    }
a69 29
/* See if an input file matches a DT_NEEDED entry by running stat on
   the file.  */

static void
gld${EMULATION_NAME}_stat_needed (s)
     lang_input_statement_type *s;
{
  struct stat st;
  const char *suffix;
  const char *soname;
  const char *f;

  if (global_found)
    return;
  if (s->the_bfd == NULL)
    return;

  if (bfd_stat (s->the_bfd, &st) != 0)
    {
      einfo ("%P:%B: bfd_stat failed: %E\n", s->the_bfd);
      return;
    }

  if (st.st_dev == global_stat.st_dev
      && st.st_ino == global_stat.st_ino)
    {
      global_found = true;
      return;
    }
d71 1
a71 47
  /* We issue a warning if it looks like we are including two
     different versions of the same shared library.  For example,
     there may be a problem if -lc picks up libc.so.6 but some other
     shared library has a DT_NEEDED entry of libc.so.5.  This is a
     hueristic test, and it will only work if the name looks like
     NAME.so.VERSION.  FIXME: Depending on file names is error-prone.
     If we really want to issue warnings about mixing version numbers
     of shared libraries, we need to find a better way.  */

  if (strchr (global_needed->name, '/') != NULL)
    return;
  suffix = strstr (global_needed->name, ".so.");
  if (suffix == NULL)
    return;
  suffix += sizeof ".so." - 1;

  soname = bfd_elf_get_dt_soname (s->the_bfd);
  if (soname == NULL)
    soname = s->filename;

  f = strrchr (soname, '/');
  if (f != NULL)
    ++f;
  else
    f = soname;

  if (strncmp (f, global_needed->name, suffix - global_needed->name) == 0)
    einfo ("%P: warning: %s, needed by %B, may conflict with %s\n",
	   global_needed->name, global_needed->by, f);
}

/* On Linux, it's possible to have different versions of the same
   shared library linked against different versions of libc.  The
   dynamic linker somehow tags which libc version to use in
   /etc/ld.so.cache, and, based on the libc that it sees in the
   executable, chooses which version of the shared library to use.

   We try to do a similar check here by checking whether this shared
   library needs any other shared libraries which may conflict with
   libraries we have already included in the link.  If it does, we
   skip it, and try to find another shared library farther on down the
   link path.

   This is called via lang_for_each_input_file.
   GLOBAL_VERCHECK_NEEDED is the list of objects needed by the object
   which we ar checking.  This sets GLOBAL_VERCHECK_FAILED if we find
   a conflicting version.  */
d74 1
a74 58
gld${EMULATION_NAME}_vercheck (s)
     lang_input_statement_type *s;
{
  const char *soname, *f;
  struct bfd_link_needed_list *l;

  if (global_vercheck_failed)
    return;
  if (s->the_bfd == NULL
      || (bfd_get_file_flags (s->the_bfd) & DYNAMIC) == 0)
    return;

  soname = bfd_elf_get_dt_soname (s->the_bfd);
  if (soname == NULL)
    soname = bfd_get_filename (s->the_bfd);

  f = strrchr (soname, '/');
  if (f != NULL)
    ++f;
  else
    f = soname;

  for (l = global_vercheck_needed; l != NULL; l = l->next)
    {
      const char *suffix;

      if (strcmp (f, l->name) == 0)
	{
	  /* Probably can't happen, but it's an easy check.  */
	  continue;
	}

      if (strchr (l->name, '/') != NULL)
	continue;

      suffix = strstr (l->name, ".so.");
      if (suffix == NULL)
	continue;

      suffix += sizeof ".so." - 1;

      if (strncmp (f, l->name, suffix - l->name) == 0)
	{
	  /* Here we know that S is a dynamic object FOO.SO.VER1, and
             the object we are considering needs a dynamic object
             FOO.SO.VER2, and VER1 and VER2 are different.  This
             appears to be a version mismatch, so we tell the caller
             to try a different version of this library.  */
	  global_vercheck_failed = true;
	  return;
	}
    }
}

/* Place an orphan section.  We use this to put random SHF_ALLOC
   sections in the right segment.  */

struct orphan_save
d76 2
a77 111
  lang_output_section_statement_type *os;
  asection **section;
  lang_statement_union_type **stmt;
};

/*ARGSUSED*/
static boolean
gld${EMULATION_NAME}_place_orphan (file, s)
     lang_input_statement_type *file;
     asection *s;
{
  static struct orphan_save hold_text;
  static struct orphan_save hold_rodata;
  static struct orphan_save hold_data;
  static struct orphan_save hold_bss;
  static struct orphan_save hold_rel;
  static struct orphan_save hold_interp;
  struct orphan_save *place;
  lang_statement_list_type *old;
  lang_statement_list_type add;
  etree_type *address;
  const char *secname, *ps;
  const char *outsecname;
  lang_output_section_statement_type *os;

  secname = bfd_get_section_name (s->owner, s);

  /* Look through the script to see where to place this section.  */
  os = lang_output_section_find (secname);

  if (os != NULL
      && os->bfd_section != NULL
      && ((s->flags ^ os->bfd_section->flags) & (SEC_LOAD | SEC_ALLOC)) == 0)
    {
      /* We have already placed a section with this name.  */
      wild_doit (&os->children, s, os, file);
      return true;
    }

  if (hold_text.os == NULL)
    hold_text.os = lang_output_section_find (".text");

  /* If this is a final link, then always put .gnu.warning.SYMBOL
     sections into the .text section to get them out of the way.  */
  if (! link_info.shared
      && ! link_info.relocateable
      && strncmp (secname, ".gnu.warning.", sizeof ".gnu.warning." - 1) == 0
      && hold_text.os != NULL)
    {
      wild_doit (&hold_text.os->children, s, hold_text.os, file);
      return true;
    }

  /* Decide which segment the section should go in based on the
     section name and section flags.  We put loadable .note sections
     right after the .interp section, so that the PT_NOTE segment is
     stored right after the program headers where the OS can read it
     in the first page.  */
#define HAVE_SECTION(hold, name) \
(hold.os != NULL || (hold.os = lang_output_section_find (name)) != NULL)

  if (s->flags & SEC_EXCLUDE)
    return false;
  else if ((s->flags & SEC_ALLOC) == 0)
    place = NULL;
  else if ((s->flags & SEC_LOAD) != 0
	   && strncmp (secname, ".note", 4) == 0
	   && HAVE_SECTION (hold_interp, ".interp"))
    place = &hold_interp;
  else if ((s->flags & SEC_HAS_CONTENTS) == 0
	   && HAVE_SECTION (hold_bss, ".bss"))
    place = &hold_bss;
  else if ((s->flags & SEC_READONLY) == 0
	   && HAVE_SECTION (hold_data, ".data"))
    place = &hold_data;
  else if (strncmp (secname, ".rel", 4) == 0
	   && (hold_rel.os != NULL
	       || (hold_rel.os = output_rel_find ()) != NULL))
    place = &hold_rel;
  else if ((s->flags & SEC_CODE) == 0
	   && (s->flags & SEC_READONLY) != 0
	   && HAVE_SECTION (hold_rodata, ".rodata"))
    place = &hold_rodata;
  else if ((s->flags & SEC_READONLY) != 0
	   && hold_text.os != NULL)
    place = &hold_text;
  else
    place = NULL;

#undef HAVE_SECTION

  /* Choose a unique name for the section.  This will be needed if the
     same section name appears in the input file with different
     loadable or allocateable characteristics.  */
  outsecname = secname;
  if (bfd_get_section_by_name (output_bfd, outsecname) != NULL)
    {
      unsigned int len;
      char *newname;
      unsigned int i;

      len = strlen (outsecname);
      newname = xmalloc (len + 5);
      strcpy (newname, outsecname);
      i = 0;
      do
	{
	  sprintf (newname + len, "%d", i);
	  ++i;
	}
      while (bfd_get_section_by_name (output_bfd, newname) != NULL);
d79 1
a79 278
      outsecname = newname;
    }

  if (place != NULL)
    {
      /* Start building a list of statements for this section.  */
      old = stat_ptr;
      stat_ptr = &add;
      lang_list_init (stat_ptr);

      /* If the name of the section is representable in C, then create
	 symbols to mark the start and the end of the section.  */
      for (ps = outsecname; *ps != '\0'; ps++)
	if (! isalnum ((unsigned char) *ps) && *ps != '_')
	  break;
      if (*ps == '\0' && config.build_constructors)
	{
	  char *symname;
	  etree_type *e_align;

	  symname = (char *) xmalloc (ps - outsecname + sizeof "__start_");
	  sprintf (symname, "__start_%s", outsecname);
	  e_align = exp_unop (ALIGN_K,
			      exp_intop ((bfd_vma) 1 << s->alignment_power));
	  lang_add_assignment (exp_assop ('=', symname, e_align));
	}
    }

  if (link_info.relocateable || (s->flags & (SEC_LOAD | SEC_ALLOC)) == 0)
    address = exp_intop ((bfd_vma) 0);
  else
    address = NULL;

  os = lang_enter_output_section_statement (outsecname, address, 0,
					    (bfd_vma) 0,
					    (etree_type *) NULL,
					    (etree_type *) NULL,
					    (etree_type *) NULL);

  wild_doit (&os->children, s, os, file);

  lang_leave_output_section_statement
    ((bfd_vma) 0, "*default*",
     (struct lang_output_section_phdr_list *) NULL, "*default*");

  if (place != NULL)
    {
      asection *snew, **pps;

      stat_ptr = &add;

      if (*ps == '\0' && config.build_constructors)
	{
	  char *symname;

	  symname = (char *) xmalloc (ps - outsecname + sizeof "__stop_");
	  sprintf (symname, "__stop_%s", outsecname);
	  lang_add_assignment (exp_assop ('=', symname,
					  exp_nameop (NAME, ".")));
	}
      stat_ptr = old;

      snew = os->bfd_section;
      if (place->os->bfd_section != NULL || place->section != NULL)
	{
	  /* Shuffle the section to make the output file look neater.  */
	  if (place->section == NULL)
	    {
#if 0
	      /* Finding the end of the list is a little tricky.  We
		 make a wild stab at it by comparing section flags.  */
	      flagword first_flags = place->os->bfd_section->flags;
	      for (pps = &place->os->bfd_section->next;
		   *pps != NULL && (*pps)->flags == first_flags;
		   pps = &(*pps)->next)
		;
	      place->section = pps;
#else
	      /* Put orphans after the first section on the list.  */
	      place->section = &place->os->bfd_section->next;
#endif
	    }

	  /*  Unlink the section.  */
	  for (pps = &output_bfd->sections; *pps != snew; pps = &(*pps)->next)
	    ;
	  *pps = snew->next;

	  /* Now tack it on to the "place->os" section list.  */
	  snew->next = *place->section;
	  *place->section = snew;
	}
      place->section = &snew->next;	/* Save the end of this list.  */

      if (place->stmt == NULL)
	{
	  /* Put the new statement list right at the head.  */
	  *add.tail = place->os->header.next;
	  place->os->header.next = add.head;
	}
      else
	{
	  /* Put it after the last orphan statement we added.  */
	  *add.tail = *place->stmt;
	  *place->stmt = add.head;
	}
      place->stmt = add.tail;		/* Save the end of this list.  */
    }

  return true;
}

/* A variant of lang_output_section_find.  */
static lang_output_section_statement_type *
output_rel_find ()
{
  lang_statement_union_type *u;
  lang_output_section_statement_type *lookup;

  for (u = lang_output_section_statement.head;
       u != (lang_statement_union_type *) NULL;
       u = lookup->next)
    {
      lookup = &u->output_section_statement;
      if (strncmp (".rel", lookup->name, 4) == 0
	  && lookup->bfd_section != NULL
	  && (lookup->bfd_section->flags & SEC_ALLOC) != 0)
	{
	  return lookup;
	}
    }
  return (lang_output_section_statement_type *) NULL;
}

/* Look through an expression for an assignment statement.  */

static void
gld${EMULATION_NAME}_find_exp_assignment (exp)
     etree_type *exp;
{
  struct bfd_link_hash_entry *h;

  switch (exp->type.node_class)
    {
    case etree_provide:
      h = bfd_link_hash_lookup (link_info.hash, exp->assign.dst,
				false, false, false);
      if (h == NULL)
	break;

      /* We call record_link_assignment even if the symbol is defined.
	 This is because if it is defined by a dynamic object, we
	 actually want to use the value defined by the linker script,
	 not the value from the dynamic object (because we are setting
	 symbols like etext).  If the symbol is defined by a regular
	 object, then, as it happens, calling record_link_assignment
	 will do no harm.  */

      /* Fall through.  */
    case etree_assign:
      if (strcmp (exp->assign.dst, ".") != 0)
	{
	  if (! (bfd_elf${ELFSIZE}_record_link_assignment
		 (output_bfd, &link_info, exp->assign.dst,
		  exp->type.node_class == etree_provide ? true : false)))
	    einfo ("%P%F: failed to record assignment to %s: %E\n",
		   exp->assign.dst);
	}
      gld${EMULATION_NAME}_find_exp_assignment (exp->assign.src);
      break;

    case etree_binary:
      gld${EMULATION_NAME}_find_exp_assignment (exp->binary.lhs);
      gld${EMULATION_NAME}_find_exp_assignment (exp->binary.rhs);
      break;

    case etree_trinary:
      gld${EMULATION_NAME}_find_exp_assignment (exp->trinary.cond);
      gld${EMULATION_NAME}_find_exp_assignment (exp->trinary.lhs);
      gld${EMULATION_NAME}_find_exp_assignment (exp->trinary.rhs);
      break;

    case etree_unary:
      gld${EMULATION_NAME}_find_exp_assignment (exp->unary.child);
      break;

    default:
      break;
    }
}

/* This is called by the before_allocation routine via
   lang_for_each_statement.  It locates any assignment statements, and
   tells the ELF backend about them, in case they are assignments to
   symbols which are referred to by dynamic objects.  */

static void
gld${EMULATION_NAME}_find_statement_assignment (s)
     lang_statement_union_type *s;
{
  if (s->header.type == lang_assignment_statement_enum)
    gld${EMULATION_NAME}_find_exp_assignment (s->assignment_statement.exp);
}

/* This is called after the sections have been attached to output
   sections, but before any sizes or addresses have been set.  */

static void
gld${EMULATION_NAME}_before_allocation ()
{
  const char *rpath;
  asection *sinterp;

  /* If we are going to make any variable assignments, we need to let
     the ELF backend know about them in case the variables are
     referred to by dynamic objects.  */
  lang_for_each_statement (gld${EMULATION_NAME}_find_statement_assignment);

  /* Let the ELF backend work out the sizes of any sections required
     by dynamic linking.  */
  rpath = command_line.rpath;
  if (rpath == NULL)
    rpath = (const char *) getenv ("LD_RUN_PATH");
  if (! (bfd_elf${ELFSIZE}_size_dynamic_sections
         (output_bfd, command_line.soname, rpath,
	  command_line.export_dynamic, command_line.filter_shlib,
	  (const char * const *) command_line.auxiliary_filters,
	  &link_info, &sinterp, lang_elf_version_info)))
    einfo ("%P%F: failed to set dynamic section sizes: %E\n");

  /* Let the user override the dynamic linker we are using.  */
  if (command_line.interpreter != NULL
      && sinterp != NULL)
    {
      sinterp->contents = (bfd_byte *) command_line.interpreter;
      sinterp->_raw_size = strlen (command_line.interpreter) + 1;
    }

  /* Look for any sections named .gnu.warning.  As a GNU extensions,
     we treat such sections as containing warning messages.  We print
     out the warning message, and then zero out the section size so
     that it does not get copied into the output file.  */

  {
    LANG_FOR_EACH_INPUT_STATEMENT (is)
      {
	asection *s;
	bfd_size_type sz;
	char *msg;
	boolean ret;

	if (is->just_syms_flag)
	  continue;

	s = bfd_get_section_by_name (is->the_bfd, ".gnu.warning");
	if (s == NULL)
	  continue;

	sz = bfd_section_size (is->the_bfd, s);
	msg = xmalloc ((size_t) sz + 1);
	if (! bfd_get_section_contents (is->the_bfd, s, msg, (file_ptr) 0, sz))
	  einfo ("%F%B: Can't read contents of section .gnu.warning: %E\n",
		 is->the_bfd);
	msg[sz] = '\0';
	ret = link_info.callbacks->warning (&link_info, msg,
					    (const char *) NULL,
					    is->the_bfd, (asection *) NULL,
					    (bfd_vma) 0);
	ASSERT (ret);
	free (msg);

	/* Clobber the section size, so that we don't waste copying the
	   warning into the output file.  */
	s->_raw_size = 0;
      }
  }

  /* we should be able to set the size of the interworking stub section */
d99 3
d110 2
a111 1
  h = bfd_link_hash_lookup (link_info.hash, thumb_entry_symbol, false, false, true);
d143 2
a144 1
    einfo (_("%P: warning: connot find thumb start symbol %s\n"), thumb_entry_symbol);
a146 3
static char *
gld${EMULATION_NAME}_get_script (isfile)
     int *isfile;
d149 6
a154 3
if test -n "$COMPILE_IN"
then
# Scripts compiled in.
d156 1
a156 2
# sed commands to quote an ld script as a C string.
sc="-f stringify.sed"
d158 4
a161 3
cat >>e${EMULATION_NAME}.c <<EOF
{			     
  *isfile = 0;
d163 4
a166 17
  if (link_info.relocateable == true && config.build_constructors == true)
    return
EOF
sed $sc ldscripts/${EMULATION_NAME}.xu                     >> e${EMULATION_NAME}.c
echo '  ; else if (link_info.relocateable == true) return' >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xr                     >> e${EMULATION_NAME}.c
echo '  ; else if (!config.text_read_only) return'         >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xbn                    >> e${EMULATION_NAME}.c
echo '  ; else if (!config.magic_demand_paged) return'     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.xn                     >> e${EMULATION_NAME}.c
if test -n "$GENERATE_SHLIB_SCRIPT" ; then
        echo '  ; else if (link_info.shared) return'       >> e${EMULATION_NAME}.c
        sed $sc ldscripts/${EMULATION_NAME}.xs             >> e${EMULATION_NAME}.c
fi
echo '  ; else return'                                     >> e${EMULATION_NAME}.c
sed $sc ldscripts/${EMULATION_NAME}.x                      >> e${EMULATION_NAME}.c
echo '; }'                                                 >> e${EMULATION_NAME}.c
d168 4
a171 2
else
# Scripts read from the filesystem.
d173 4
a176 18
cat >>e${EMULATION_NAME}.c <<EOF
{			     
  *isfile = 1;

  if (link_info.relocateable == true && config.build_constructors == true)
    return "ldscripts/${EMULATION_NAME}.xu";
  else if (link_info.relocateable == true)
    return "ldscripts/${EMULATION_NAME}.xr";
  else if (!config.text_read_only)
    return "ldscripts/${EMULATION_NAME}.xbn";
  else if (!config.magic_demand_paged)
    return "ldscripts/${EMULATION_NAME}.xn";
  else if (link_info.shared)
    return "ldscripts/${EMULATION_NAME}.xs";
  else
    return "ldscripts/${EMULATION_NAME}.x";
}
EOF
d178 4
a181 1
fi
d183 2
a184 1
cat >>e${EMULATION_NAME}.c <<EOF
d186 2
a187 26
struct ld_emulation_xfer_struct ld_${EMULATION_NAME}_emulation = 
{
  gld${EMULATION_NAME}_before_parse,
  syslib_default,
  hll_default,
  after_parse_default,
  gld${EMULATION_NAME}_after_open,
  after_allocation_default,
  set_output_arch_default,
  ldemul_default_target,
  gld${EMULATION_NAME}_before_allocation,
  gld${EMULATION_NAME}_get_script,
  "${EMULATION_NAME}",
  "${OUTPUT_FORMAT}",
  gld${EMULATION_NAME}_finish,
  NULL,	/* create output section statements */
  gld${EMULATION_NAME}_open_dynamic_archive,
  gld${EMULATION_NAME}_place_orphan,
  NULL,	/* set symbols */
  gld${EMULATION_NAME}_parse_args,
  NULL,	/* unrecognized file */
  gld${EMULATION_NAME}_list_options,
  NULL,	/* recognized file */
  NULL 	/* find_potential_libraries */
};
EOF
@


1.19
log
@place_orphan optimisations
@
text
@d8 2
a9 1
   Copyright (C) 1991, 93, 96, 97, 98, 1999 Free Software Foundation, Inc.
a39 2
#include "ldemul.h"
#include "ldfile.h"
d44 2
@


1.18
log
@2000-04-18  H.J. Lu  <hjl@@gnu.org>

	* emultempl/elf32.em (gld${EMULATION_NAME}_place_orphan): Call
	lang_leave_output_section_statement () after calling
	lang_enter_output_section_statement ().
	* emultempl/armelf.em: Likewise.
@
text
@d64 1
a64 2
static void gld${EMULATION_NAME}_place_section
  PARAMS ((lang_statement_union_type *));
a784 3
static asection *hold_section;
static lang_output_section_statement_type *hold_use;

a790 6
static struct orphan_save hold_text;
static struct orphan_save hold_rodata;
static struct orphan_save hold_data;
static struct orphan_save hold_bss;
static struct orphan_save hold_rel;
static struct orphan_save hold_interp;
d798 6
d812 2
d815 1
a815 3
  hold_section = s;
  hold_use = NULL;
  lang_for_each_statement (gld${EMULATION_NAME}_place_section);
d817 3
a819 1
  if (hold_use != NULL)
d822 1
a822 1
      wild_doit (&hold_use->children, s, hold_use, file);
d826 2
a827 1
  secname = bfd_get_section_name (s->owner, s);
d845 3
d854 1
a854 1
	   && hold_interp.os != NULL)
d857 1
a857 1
	   && hold_bss.os != NULL)
d860 1
a860 1
	   && hold_data.os != NULL)
d863 2
a864 1
	   && hold_rel.os != NULL)
d868 1
a868 1
	   && hold_rodata.os != NULL)
d876 2
d932 5
a936 5
  lang_enter_output_section_statement (outsecname, address, 0,
				       (bfd_vma) 0,
				       (etree_type *) NULL,
				       (etree_type *) NULL,
				       (etree_type *) NULL);
a937 1
  os = lang_output_section_statement_lookup (outsecname);
d1011 3
a1013 3
static void
gld${EMULATION_NAME}_place_section (s)
     lang_statement_union_type *s;
d1015 2
a1016 1
  lang_output_section_statement_type *os;
d1018 13
a1030 26
  if (s->header.type != lang_output_section_statement_enum)
    return;

  os = &s->output_section_statement;

  if (strcmp (os->name, hold_section->name) == 0
      && os->bfd_section != NULL
      && ((hold_section->flags & (SEC_LOAD | SEC_ALLOC))
	  == (os->bfd_section->flags & (SEC_LOAD | SEC_ALLOC))))
    hold_use = os;

  if (strcmp (os->name, ".text") == 0)
    hold_text.os = os;
  else if (strcmp (os->name, ".rodata") == 0)
    hold_rodata.os = os;
  else if (strcmp (os->name, ".data") == 0)
    hold_data.os = os;
  else if (strcmp (os->name, ".bss") == 0)
    hold_bss.os = os;
  else if (hold_rel.os == NULL
	   && os->bfd_section != NULL
	   && (os->bfd_section->flags & SEC_ALLOC) != 0
	   && strncmp (os->name, ".rel", 4) == 0)
    hold_rel.os = os;
  else if (strcmp (os->name, ".interp") == 0)
    hold_interp.os = os;
@


1.17
log
@Yet another set of fixes for orphan sections.
@
text
@d936 4
a943 3
      lang_leave_output_section_statement
	((bfd_vma) 0, "*default*",
	 (struct lang_output_section_phdr_list *) NULL, "*default*");
@


1.16
log
@Zero start address of orphan ~(SEC_LOAD | SEC_ALLOC) sections.
@
text
@d792 1
a808 1
  asection *snew, **pps;
d848 2
d897 1
a897 7
  /* Create the section in the output file, and put it in the right
     place.  This shuffling is to make the output file look neater.  */
  snew = bfd_make_section (output_bfd, outsecname);
  if (snew == NULL)
      einfo ("%P%F: output format %s cannot represent section called %s\n",
	     output_bfd->xvec->name, outsecname);
  if (place != NULL && place->os->bfd_section != NULL)
d899 14
a912 10
      /* Unlink it first.  */
      for (pps = &output_bfd->sections; *pps != snew; pps = &(*pps)->next)
	;
      *pps = snew->next;
      snew->next = NULL;
      /* Now tack it on to the end of the "place->os" section list.  */
      for (pps = &place->os->bfd_section; *pps; pps = &(*pps)->next)
	;
      *pps = snew;
    }
d914 6
a919 20
  /* Start building a list of statements for this section.  */
  old = stat_ptr;
  stat_ptr = &add;
  lang_list_init (stat_ptr);

  /* If the name of the section is representable in C, then create
     symbols to mark the start and the end of the section.  */
  for (ps = outsecname; *ps != '\0'; ps++)
    if (! isalnum ((unsigned char) *ps) && *ps != '_')
      break;
  if (*ps == '\0' && config.build_constructors)
    {
      char *symname;

      symname = (char *) xmalloc (ps - outsecname + sizeof "__start_");
      sprintf (symname, "__start_%s", outsecname);
      lang_add_assignment (exp_assop ('=', symname,
				      exp_unop (ALIGN_K,
						exp_intop ((bfd_vma) 1
							   << s->alignment_power))));
d936 8
a943 4
  lang_leave_output_section_statement
    ((bfd_vma) 0, "*default*", (struct lang_output_section_phdr_list *) NULL,
     "*default*");
  stat_ptr = &add;
d945 10
a954 3
  if (*ps == '\0' && config.build_constructors)
    {
      char *symname;
d956 31
a986 5
      symname = (char *) xmalloc (ps - outsecname + sizeof "__stop_");
      sprintf (symname, "__stop_%s", outsecname);
      lang_add_assignment (exp_assop ('=', symname,
				      exp_nameop (NAME, ".")));
    }
d988 1
a988 3
  if (place != NULL)
    {
      if (! place->stmt)
d1000 1
a1000 1
      place->stmt = add.tail;	/* Save the end of this list.  */
a1001 1
  stat_ptr = old;
@


1.15
log
@Keep output orphan sections in the same order as input.
@
text
@a815 3
  if ((s->flags & SEC_ALLOC) == 0)
    return false;

d869 1
a869 1
    return false;
d901 1
a901 1
  if (place->os->bfd_section != NULL)
d936 3
a938 1
  if (! link_info.relocateable)
a939 2
  else
    address = exp_intop ((bfd_vma) 0);
d965 1
a965 1
  if (! place->stmt)
d967 13
a979 3
      /* Put the new statement list right at the head.  */
      *add.tail = place->os->header.next;
      place->os->header.next = add.head;
a980 8
  else
    {
      /* Put it after the last orphan statement we added.  */
      *add.tail = *place->stmt;
      *place->stmt = add.head;
    }
  place->stmt = add.tail;	/* Save the end of this list.  */

@


1.14
log
@GCC warning fix: Add missing NULL initialiser for find_potential_libraries.
@
text
@d788 12
a799 6
static lang_output_section_statement_type *hold_text;
static lang_output_section_statement_type *hold_rodata;
static lang_output_section_statement_type *hold_data;
static lang_output_section_statement_type *hold_bss;
static lang_output_section_statement_type *hold_rel;
static lang_output_section_statement_type *hold_interp;
d807 1
a807 1
  lang_output_section_statement_type *place;
d838 1
a838 1
      && hold_text != NULL)
d840 1
a840 1
      wild_doit (&hold_text->children, s, hold_text, file);
a848 1
  place = NULL;
d852 3
a854 3
      && strncmp (secname, ".note", 4) == 0
      && hold_interp != NULL)
    place = hold_interp;
d856 2
a857 2
	   && hold_bss != NULL)
    place = hold_bss;
d859 2
a860 2
	   && hold_data != NULL)
    place = hold_data;
d862 2
a863 2
	   && hold_rel != NULL)
    place = hold_rel;
d866 2
a867 2
	   && hold_rodata != NULL)
    place = hold_rodata;
d869 3
a871 3
	   && hold_text != NULL)
    place = hold_text;
  if (place == NULL)
d904 1
a904 1
  if (place->bfd_section != NULL)
d906 1
d910 5
a914 2
      snew->next = place->bfd_section->next;
      place->bfd_section->next = snew;
d968 13
a980 3
  /* Now stick the new statement list right after PLACE.  */
  *add.tail = place->header.next;
  place->header.next = add.head;
d1005 1
a1005 1
    hold_text = os;
d1007 1
a1007 1
    hold_rodata = os;
d1009 1
a1009 1
    hold_data = os;
d1011 2
a1012 2
    hold_bss = os;
  else if (hold_rel == NULL
d1016 1
a1016 1
    hold_rel = os;
d1018 1
a1018 1
    hold_interp = os;
@


1.13
log
@Add LMA memory region functionality.
@
text
@d1290 2
a1291 1
  NULL 	/* recognized file */
@


1.12
log
@To satisfy latest CVS gcc:
	* emultempl/*.em (ld_emulation_xfer_struct): Add missing NULL
	initialisers, and comments.
	* testsuite/ld-srec/sr3.cc (__rethrow): New.
@
text
@d945 2
a946 1
    ((bfd_vma) 0, "*default*", (struct lang_output_section_phdr_list *) NULL);
@


1.11
log
@fix compile time warnings
@
text
@d1281 2
a1282 2
  gld${EMULATION_NAME}_finish, /* finish */
  NULL, /* create output section statements */
d1285 1
a1285 1
  NULL, /* set_symbols */
d1287 1
a1287 1
  NULL, /* unrecognised file */
d1289 1
a1289 1
  NULL /* recognized file */
@


1.10
log
@Remove extraneous underscore from prototype
@
text
@d31 3
@


1.9
log
@	* emultempl/ostring.sed: Rename from stringify.sed.
	* emultempl/astring.sed: New file.
	* Makefile.am (stringify.sed): New target.
	(GEN_DEPENDS): Change $(srcdir)/emultempl/stringify.sed to
	stringify.sed.
	* configure.in: Define and substitute STRINGIFY.
	* emultempl/*.em: Use stringify.sed from build directory rather
	than source directory.
	* emultempl/elf32.em: Use stringify.sed rather than inline sed
	script.
	* emultempl/gld960.em, emultempl/gld960c.em: Likewise.
	* emultempl/hppaelf.em, emultempl/linux.em: Likewise.
	* emultempl/lnk960.em, emultempl/sunos.em: Likewise.
	* configure, Makefile.in: Rebuild.
@
text
@d68 1
a68 1
static void gld_${EMULATION_NAME}_finish PARAMS ((void));
@


1.8
log
@Abort if input format is ARM and output format is not
@
text
@d1214 1
a1214 1
sc="-f ${srcdir}/emultempl/stringify.sed"
@


1.7
log
@Patch from: Jim Pick <jim@@jimpick.com>
Added code so that .xs linker scripts are called so that ARM shared libraries
are built correctly.
  CVS: ----------------------------------------------------------------------
@
text
@d311 1
a311 1
  LANG_FOR_EACH_INPUT_STATEMENT (is)
d313 6
a318 3
      /* The interworking bfd must be the last one to be processed */
      if (!is->next)
         bfd_elf32_arm_get_bfd_for_interworking (is->the_bfd, & link_info);
d320 9
@


1.6
log
@Add new command line switch --thumb-entry.
@
text
@d1218 4
d1241 2
@


1.5
log
@        * emultempl/armelf.em: Watch EMULATION_LIBPATH instead of
        DEFAULT_EMULATION.
        * emultempl/elf32.em: Likewise.
        * emultempl/sunos.em: Likewise.
@
text
@d68 1
d72 3
d79 1
d88 1
d123 4
d1149 43
d1260 1
a1260 1
  NULL, /* finish */
@


1.4
log
@Implement new command line option for new ABI: -p which prevents the ARM code
from exhibiting any knowledge of the length of the processor's pipeline.
@
text
@d196 2
a197 1
  if [ "x${DEFAULT_EMULATION}" = "x${EMULATION_NAME}" ] ; then
d282 2
a283 1
  fi
d373 2
a374 1
  if [ "x${DEFAULT_EMULATION}" = "x${EMULATION_NAME}" ] ; then
d380 2
a381 1
  fi
d401 2
a402 1
  if [ "x${DEFAULT_EMULATION}" = "x${EMULATION_NAME}" ] ; then
d407 2
a408 1
  fi
@


1.3
log
@1999-05-24  Philip Blundell  <philb@@gnu.org>
	* emultempl/armelf.em (before_parse): Set config.dynamic_link and
 	config.has_shared.
	* emulparams/armelf.sh (GENERATE_SHLIB_SCRIPT): Define.
	* emulparams/armelf_linux.sh (GENERATE_SHLIB_SCRIPT): Likewise
@
text
@d66 56
d1120 2
a1121 1
	if (!bfd_elf32_arm_process_before_allocation (is->the_bfd, &link_info))
d1206 1
a1206 1
  NULL,
d1208 2
a1209 1
  NULL
@


1.2
log
@Add definitions related to shared objects (copied from elf32.em)
@
text
@d73 2
@


1.1
log
@Initial revision
@
text
@d3 1
d8 1
a8 1
   Copyright (C) 1991, 93, 96, 97, 1998 Free Software Foundation, Inc.
d42 1
d44 19
d75 907
d988 67
a1073 12
static void
gld${EMULATION_NAME}_after_open ()
{

  LANG_FOR_EACH_INPUT_STATEMENT (is)
    {
      /* The interworking bfd must be the last one to be processed */
      if (!is->next)
         bfd_elf32_arm_get_bfd_for_interworking (is->the_bfd, & link_info);
    }
}

d1144 2
a1145 2
  NULL, /* open dynamic archive */
  NULL, /* place orphan */
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

